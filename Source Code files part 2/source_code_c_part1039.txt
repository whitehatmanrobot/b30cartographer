_RESOURCE_UNAVAILABLE);
        WsbAffirmHr(WsbConvertToBytes(&m_value[m_size], value, &size));
        m_size += size;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbDbKey::AppendBool"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CWsbDbKey::AppendBytes(
    UCHAR* value, 
    ULONG size
    )

/*++

Implements:

  IWsbDbKey::AppendBytes

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("CWsbDbKey::AppendBytes"), OLESTR("size = <%ld>"), size);
    
    try {
        WsbAssert(size > 0, E_UNEXPECTED);
        WsbAssert(make_key(size + m_size), WSB_E_RESOURCE_UNAVAILABLE);
        memcpy(&m_value[m_size], value, size);
        m_size += size;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbDbKey::AppendBytes"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return(hr);
}



HRESULT
CWsbDbKey::AppendFiletime(
    FILETIME value
    )

/*++

Implements:

  IWsbDbKey::AppendFiletime

--*/
{
    HRESULT             hr = S_OK;
    ULONG               size;

    WsbTraceIn(OLESTR("CWsbDbKey::AppendFiletime"), OLESTR(""));
    
    try {
        WsbAssert(make_key(m_size + WsbByteSize(value)), WSB_E_RESOURCE_UNAVAILABLE);
        WsbAffirmHr(WsbConvertToBytes(&m_value[m_size], value, &size));
        m_size += size;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbDbKey::AppendFiletime"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return(hr);
}



HRESULT
CWsbDbKey::AppendGuid(
    GUID value
    )

/*++

Implements:

  IWsbDbKey::AppendGuid

--*/
{
    HRESULT             hr = S_OK;
    ULONG               size;

    WsbTraceIn(OLESTR("CWsbDbKey::AppendGuid"), OLESTR("value = <%ls>"), WsbGuidAsString(value));
    
    try {
        WsbAssert(make_key(m_size + WsbByteSize(value)), WSB_E_RESOURCE_UNAVAILABLE);
        WsbAffirmHr(WsbConvertToBytes(&m_value[m_size], value, &size));
        m_size += size;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbDbKey::AppendGuid"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return(hr);
}



HRESULT
CWsbDbKey::AppendLonglong(
    LONGLONG value
    )

/*++

Implements:

  IWsbDbKey::AppendLonglong

--*/
{
    HRESULT             hr = S_OK;
    ULONG               size;

    WsbTraceIn(OLESTR("CWsbDbKey::AppendLonglong"), OLESTR("value = <%ls>"), 
            WsbLonglongAsString(value));
    
    try {
        WsbAssert(make_key(m_size + WsbByteSize(value)), WSB_E_RESOURCE_UNAVAILABLE);
        WsbAffirmHr(WsbConvertToBytes(&m_value[m_size], value, &size));
        m_size += size;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbDbKey::AppendLonglong"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return(hr);
}



HRESULT
CWsbDbKey::AppendString(
    OLECHAR* value
    )

/*++

Implements:

  IWsbDbKey::AppendString

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("CWsbDbKey::AppendString"), OLESTR(""));
    
    try {
        ULONG size;

        size = wcslen(value) * sizeof(OLECHAR);
        WsbAffirmHr(AppendBytes((UCHAR *)value, size));
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbDbKey::AppendString"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return(hr);
}



HRESULT
CWsbDbKey::CompareTo(
    IN IUnknown* pCollectable,
    OUT SHORT* pResult
    )

/*++

Implements:

  IWsbCollectable::CompareTo

--*/
{
    HRESULT             hr = S_FALSE;

    WsbTraceIn(OLESTR("CWsbDbKey::CompareTo"), OLESTR(""));
    
    try {
        UCHAR*             bytes2;
        CComPtr<IWsbDbKey> pKey2;
        CComPtr<IWsbDbKeyPriv> pKeyPriv2;
        SHORT              result;
        ULONG              size2;

        // Did they give us a valid item to compare to?
        WsbAssert(0 != pCollectable, E_POINTER);

        // We need the IWsbDbKey interface to get the value.
        WsbAffirmHr(pCollectable->QueryInterface(IID_IWsbDbKey, (void**) &pKey2));
        WsbAffirmHr(pKey2->QueryInterface(IID_IWsbDbKeyPriv, 
                (void**)&pKeyPriv2));

        // Get the other key's bytes
        bytes2 = NULL;
        WsbAffirmHr(pKeyPriv2->GetBytes(&bytes2, &size2));

        // Do compare
        if (size2 == 0 && m_size == 0) {
            result = 0;
        } else if (size2 == 0) {
            result = 1;
        } else if (m_size == 0) {
            result = -1;
        } else {
            result = WsbSign( memcmp(m_value, bytes2, min(m_size, size2)) );
            if (result == 0 && m_size != size2) {
                result = (m_size > size2) ? (SHORT)1 : (SHORT)-1;
            }
        }
        WsbFree(bytes2);

        // If the aren't equal, then return false.
        if (result != 0) {
            hr = S_FALSE;
        }
        else {
            hr = S_OK;
        }
        *pResult = result;
            
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbDbKey::CompareTo"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CWsbDbKey::GetBytes(
    OUT UCHAR** ppBytes,
    OUT ULONG* pSize
    )

/*++

Implements:

  IWsbDbKey::GetBytes
    
--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbDbKey::GetBytes"), OLESTR(""));

    try {
        if (ppBytes && m_size) {
            if (*ppBytes == NULL) {
                *ppBytes = (UCHAR *)WsbAlloc(m_size);
            }
            if (*ppBytes) {
                memcpy(*ppBytes, m_value, m_size);
            } else {
                WsbThrow(E_OUTOFMEMORY);
            }
        }
        if (pSize) {
            *pSize = m_size;
        }
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbDbKey::GetBytes"), OLESTR("hr = <%ls>"), 
            WsbHrAsString(hr));
    
    return(hr);
}


HRESULT
CWsbDbKey::GetType(
    OUT ULONG* pType
    )

/*++

Implements:

  IWsbDbKey::GetType
    
--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbDbKey::GetType"), OLESTR(""));

    try {
        WsbAffirm(pType != NULL, E_POINTER);
        *pType = m_type;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbDbKey::GetType"), OLESTR("hr = <%ls>, value = <%ls>"), WsbHrAsString(hr), m_value);
    
    return(hr);
}



HRESULT
CWsbDbKey::SetToBool(
    BOOL value
    )

/*++

Implements:

  IWsbDbKey::SetToBool

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("CWsbDbKey::SetToBool"), OLESTR("value = <%ls>"), 
            WsbBoolAsString(value));
    
    try {
        WsbAssert(make_key(WsbByteSize(value)), WSB_E_RESOURCE_UNAVAILABLE);
        WsbAffirmHr(WsbConvertToBytes(m_value, value, &m_size));
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbDbKey::SetToBool"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return(hr);
}



HRESULT
CWsbDbKey::SetToBytes(
    UCHAR* value, 
    ULONG size
    )

/*++

Implements:

  IWsbDbKey::SetToBytes

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("CWsbDbKey::SetToBytes"), OLESTR("size = <%ld>"), size);
    
    try {
        WsbAssert(size > 0, E_UNEXPECTED);
        WsbAssert(make_key(size), WSB_E_RESOURCE_UNAVAILABLE);
        memcpy(m_value, value, size);
        m_size = size;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbDbKey::SetToBytes"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return(hr);
}



HRESULT
CWsbDbKey::SetToFiletime(
    FILETIME value
    )

/*++

Implements:

  IWsbDbKey::SetToFiletime

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("CWsbDbKey::SetToFiletime"), OLESTR(""));
    
    try {
        WsbAssert(make_key(WsbByteSize(value)), WSB_E_RESOURCE_UNAVAILABLE);
        WsbAffirmHr(WsbConvertToBytes(m_value, value, &m_size));
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbDbKey::SetToFiletime"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return(hr);
}



HRESULT
CWsbDbKey::SetToGuid(
    GUID value
    )

/*++

Implements:

  IWsbDbKey::SetToGuid

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("CWsbDbKey::SetToGuid"), OLESTR("value = <%ls>"), 
            WsbGuidAsString(value));
    
    try {
        WsbAssert(make_key(WsbByteSize(value)), WSB_E_RESOURCE_UNAVAILABLE);
        WsbAffirmHr(WsbConvertToBytes(m_value, value, &m_size));
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbDbKey::SetToGuid"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return(hr);
}



HRESULT
CWsbDbKey::SetToLonglong(
    LONGLONG value
    )

/*++

Implements:

  IWsbDbKey::SetToLonglong

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("CWsbDbKey::SetToLonglong"), OLESTR("value = <%ls>"), 
            WsbLonglongAsString(value));
    
    try {
        WsbAssert(make_key(WsbByteSize(value)), WSB_E_RESOURCE_UNAVAILABLE);
        WsbAffirmHr(WsbConvertToBytes(m_value, value, &m_size));
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbDbKey::SetToLonglong"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return(hr);
}



HRESULT
CWsbDbKey::SetToUlong(
    ULONG value
    )

/*++

Implements:

  IWsbDbKey::SetToUlong

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("CWsbDbKey::SetToUlong"), OLESTR("value = <%ld>"), value);
    
    try {
        WsbAssert(make_key(WsbByteSize(value)), WSB_E_RESOURCE_UNAVAILABLE);
        WsbAffirmHr(WsbConvertToBytes(m_value, value, &m_size));
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbDbKey::SetToUlong"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return(hr);
}



HRESULT
CWsbDbKey::SetToString(
    OLECHAR* value
    )

/*++

Implements:

  IWsbDbKey::SetToString

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("CWsbDbKey::SetToString"), OLESTR(""));
    
    try {
        ULONG size;

        size = wcslen(value) * sizeof(OLECHAR);
        WsbAffirmHr(SetToBytes((UCHAR *)value, size));
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbDbKey::SetToString"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return(hr);
}



HRESULT
CWsbDbKey::FinalConstruct(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalConstruct

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("CWsbDbKey::FinalConstruct"), OLESTR("") );

    try {
        WsbAffirmHr(CWsbObject::FinalConstruct());
        m_value = NULL;
        m_size = 0;
        m_max = 0;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbDbKey::FinalConstruct"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return(hr);
}



void
CWsbDbKey::FinalRelease(
    void
    )

/*++

Routine Description:

  This method does some cleanup of the object that is necessary
  during destruction.

Arguments:

  None.

Return Value:

  None.

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("CWsbDbKey::FinalRelease"), OLESTR(""));

    try {
        if (m_value) {
            WsbFree(m_value);
            m_value = NULL;
        }
        CWsbObject::FinalRelease();
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbDbKey::FinalRelease"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));
}


HRESULT
CWsbDbKey::GetClassID(
    OUT CLSID* pClsid
    )

/*++

Implements:

  IPersist::GetClassID().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbDbKey::GetClassID"), OLESTR(""));

    try {
        WsbAssert(0 != pClsid, E_POINTER);
        *pClsid = CLSID_CWsbDbKey;
    } WsbCatch(hr);
    
    WsbTraceOut(OLESTR("CWsbDbKey::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return(hr);
}


HRESULT
CWsbDbKey::GetSizeMax(
    OUT ULARGE_INTEGER* /*pSize*/
    )

/*++

Implements:

  IPersistStream::GetSizeMax().

--*/
{
    HRESULT             hr = E_NOTIMPL;
    return(hr);
}


HRESULT
CWsbDbKey::Load(
    IN IStream* /*pStream*/
    )

/*++

Implements:

  IPersistStream::Load().

--*/
{
    HRESULT                     hr = E_NOTIMPL;
    return(hr);
}


HRESULT
CWsbDbKey::Save(
    IN IStream* /*pStream*/,
    IN BOOL /*clearDirty*/
    )

/*++

Implements:

  IPersistStream::Save().

--*/
{
    HRESULT                     hr = E_NOTIMPL;
    return(hr);
}


// CWsbDbKey internal helper functions

// make_key - create a key of the specified size
BOOL
CWsbDbKey::make_key(
    ULONG size
    )
{
    BOOL status = FALSE;
    LPVOID pTemp;

    if ( (size > IDB_MAX_KEY_SIZE) || (size == 0) ) {
        status = FALSE;
    } else if (m_value && m_max >= size) {
        status = TRUE;
    } else {
        pTemp = WsbRealloc(m_value, size);
        if ( pTemp ) {
            m_value = (PUCHAR) pTemp;
            status = TRUE;
            m_max = size;
        } 
    }
    return(status);
}



HRESULT
CWsbDbKey::Test(
    OUT USHORT* passed,
    OUT USHORT* failed
    )

/*++

Implements:

  IWsbTestable::Test().

--*/
{
    *passed = 0;
    *failed = 0;

    HRESULT                 hr = S_OK;

#if !defined(WSB_NO_TEST)
    CComPtr<IWsbDbKey>      pDbKey1;

    WsbTraceIn(OLESTR("CWsbDbKey::Test"), OLESTR(""));

    try {

        try {
            WsbAssertHr(((IUnknown*) (IWsbDbKey*) this)->QueryInterface(IID_IWsbDbKey, (void**) &pDbKey1));

            // Set o a ULONG value, and see if it is returned.
            hr = S_OK;
            try {
                WsbAssertHr(pDbKey1->SetToUlong(0xffffffff));
//              ULONG value;
//              WsbAssertHr(pDbKey1->GetUlong(&value));
//              WsbAssert(value == 0xffffffff, E_FAIL);
            } WsbCatch(hr);

            if (hr == S_OK) {
                (*passed)++;
            } else {
                (*failed)++;
            }

        } WsbCatch(hr);

        if (hr == S_OK) {
            (*passed)++;
        } else {
            (*failed)++;
        }
    
    } WsbCatch(hr);


    // Tally up the results
    if (*failed) {
        hr = S_FALSE;
    } else {
        hr = S_OK;
    }

    WsbTraceOut(OLESTR("CWsbDbKey::Test"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
#endif  // WSB_NO_TEST

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\idb\wsbdbses.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    Wsbdbses.h

Abstract:

    The CWsbDbSes class.

Author:

    Ron White   [ronw]   20-Jun-1997

Revision History:

--*/


#ifndef _WSBDBSES_
#define _WSBDBSES_

#include "wsbdb.h"
#include "wsbdbses.h"



/*++

Class Name:

    CWsbDbSession

Class Description:

    A data base session object.

--*/

class CWsbDbSession :
    public CComObjectRoot,
    public IWsbDbSession,
    public IWsbDbSessionPriv
{
friend class CWsbDb;
public:
    CWsbDbSession() {}
BEGIN_COM_MAP(CWsbDbSession)
    COM_INTERFACE_ENTRY(IWsbDbSession)
    COM_INTERFACE_ENTRY(IWsbDbSessionPriv)
END_COM_MAP()

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);
    void FinalRelease(void);

// IWsbDbSession
public:
    STDMETHOD(TransactionBegin)(void);
    STDMETHOD(TransactionCancel)(void);
    STDMETHOD(TransactionEnd)(void);

//  IWsbDbSessionPriv
    STDMETHOD(Init)(JET_INSTANCE *pInstance);
    STDMETHOD(GetJetId)(JET_SESID *pSessionId);

// Data
protected:

    JET_SESID  m_SessionId;   // Jet session ID

};


#endif // _WSBDBSES_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\idl\hsmguid\makefile.inc ===
clean:
    -del $(O)\*.sbr
    -del $(O)\*.obj
    -del $(O)\*.res
    -del $(O)\*.pch
    -del $(TARGETPATH)\$(TARGET_DIRECTORY)\$(TARGETNAME).*
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\idl\rmsguid\makefile.inc ===
clean:
    -del $(O)\*.sbr
    -del $(O)\*.obj
    -del $(O)\*.res
    -del $(O)\*.pch
    -del $(TARGETPATH)\$(TARGET_DIRECTORY)\$(TARGETNAME).*
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\idl\fsaguid\makefile.inc ===
clean:
    -del $(O)\*.sbr
    -del $(O)\*.obj
    -del $(O)\*.res
    -del $(O)\*.pch
    -del $(TARGETPATH)\$(TARGET_DIRECTORY)\$(TARGETNAME).*
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\idb\wsbdbsys.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    Wsbdbsys.h

Abstract:

    The CWsbDbSys class.

Author:

    Ron White   [ronw]   7-May-1997

Revision History:

--*/


#ifndef _WSBDBSYS_
#define _WSBDBSYS_

#include "wsbdb.h"
#include "wsbdbses.h"
#include "resource.h"


#define IDB_DB_FILE_SUFFIX    L"jet"

// Default no. of Jet sessions per process is currently 128 which may not be enough for HSM
#define IDB_MAX_NOF_SESSIONS    32

/*++

Class Name:

    CWsbDbSys

Class Description:

    The IDB system object.  One must be created for each process
    that wants to use the IDB system.  The Init method needs to be
    called after the object is created.

--*/

class CWsbDbSys :
    public IWsbDbSys,
    public IWsbDbSysPriv,
    public CComObjectRoot,
    public CComCoClass<CWsbDbSys,&CLSID_CWsbDbSys>
{
friend class CWsbDb;
friend class CWsbDbSes;

public:
    CWsbDbSys() {}
BEGIN_COM_MAP( CWsbDbSys )
    COM_INTERFACE_ENTRY( IWsbDbSys )
    COM_INTERFACE_ENTRY( IWsbDbSysPriv )
END_COM_MAP( )

DECLARE_REGISTRY_RESOURCEID( IDR_CWsbDbSys )


// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);
    void FinalRelease(void);

// IWsbDbSys
public:
    STDMETHOD(Backup)(OLECHAR* path, ULONG flags);
    STDMETHOD(Init)(OLECHAR* path, ULONG flags);
    STDMETHOD(Terminate)(void);
    STDMETHOD(NewSession)(IWsbDbSession** ppSession);
    STDMETHOD(GetGlobalSession)(IWsbDbSession** ppSession);
    STDMETHOD(Restore)(OLECHAR* fromPath, OLECHAR* toPath);
    STDMETHOD(IncrementChangeCount)(void);

// IWsbDbSysPriv
public:
    STDMETHOD(DbAttachedAdd)(OLECHAR* name, BOOL attach);
    STDMETHOD(DbAttachedEmptySlot)(void);
    STDMETHOD(DbAttachedInit)(void);
    STDMETHOD(DbAttachedRemove)(OLECHAR* name);

//  Internal
    STDMETHOD(AutoBackup)(void);

//  Data
private:
    HANDLE                      m_AutoThread;
    CWsbStringPtr               m_BackupPath;       // File path for backup directory
    CWsbStringPtr               m_InitPath;         // File path from Init() call
    LONG                        m_ChangeCount;      // Count of DB changes since last backup
    FILETIME                    m_LastChange;       // Time of last DB change
    CComPtr<IWsbDbSession>      m_pWsbDbSession;    // A global Jet session for this Jet instance
    HANDLE                      m_BackupEvent;      // An event to sync Jet backups
    HANDLE                      m_terminateEvent;   // An event for signaling termination to the auto-backup thread
    BOOL                        m_bLogErrors;       // Whether to log errors or not     

    BOOL                        m_jet_initialized;
    JET_INSTANCE                m_jet_instance;
};

HRESULT wsb_db_jet_check_error(LONG jstat, char *fileName, DWORD lineNo);
HRESULT wsb_db_jet_fix_path(OLECHAR* path, OLECHAR* ext, char** new_path);

//  Capture FILE/LINE info on a JET error
#define jet_error(_jstat) \
        wsb_db_jet_check_error(_jstat, __FILE__, __LINE__)

#endif // _WSBDBSYS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\idl\wsbguid\makefile.inc ===
clean:
    -del $(O)\*.sbr
    -del $(O)\*.obj
    -del $(O)\*.res
    -del $(O)\*.pch
    -del $(TARGETPATH)\$(TARGET_DIRECTORY)\$(TARGETNAME).*
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\idb\wsbdbsys.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    Wsbdbsys.cpp

Abstract:

    CWsbDbSys class.

Author:

    Ron White   [ronw]   1-Jul-1997

Revision History:

--*/

#include "stdafx.h"

#include "rsevents.h"
#include "wsbdbsys.h"
#include "wsbdbses.h"


#include <mbstring.h>
#include <limits.h>

#define MAX_ATTACHED_DB            6    // Set by ESE/JET engine (suppose to be 7)

#if !defined(BACKUP_TEST_TIMES)
//  Normal values
#define DEFAULT_AUTOBACKUP_INTERVAL        (3 * 60 * 60 * 1000)  // 3 hours
#define DEFAULT_AUTOBACKUP_IDLE_MINUTES       5
#define DEFAULT_AUTOBACKUP_COUNT_MIN          100
#define DEFAULT_AUTOBACKUP_LOG_COUNT          10

#else
//  Test values
#define DEFAULT_AUTOBACKUP_INTERVAL        (4 * 60 * 1000)  // 4 minutes
#define DEFAULT_AUTOBACKUP_IDLE_MINUTES       1
#define DEFAULT_AUTOBACKUP_COUNT_MIN          5
#define DEFAULT_AUTOBACKUP_LOG_COUNT          4
#endif

#define DEFAULT_AUTOBACKUP_COUNT_MAX          500

// Local stuff

//  ATTACHED_DB_DATA holds information about currently attached DBs
typedef struct {
    CWsbStringPtr  Name;       // Database name
    LONG           LastOpen;   // Sequence number of last open
} ATTACHED_DB_DATA;

// This static data manages a list of attached databases for this process.
// (Future: If we want this list to be managed on a per instance basis, all of 
//  this data should become class members and handled appropriately)
static ATTACHED_DB_DATA   Attached[MAX_ATTACHED_DB];
static LONG               AttachedCount = 0;
static CRITICAL_SECTION   AttachedCritSect;
static BOOL               AttachedInit = FALSE;
static SHORT              AttachedCritSectUsers = 0;

static CComCreator< CComObject<CWsbDbSession>  >  SessionFactory;

// Local functions
static HRESULT AddExtension(OLECHAR** pPath, OLECHAR* Ext);
static HRESULT ClearDirectory(const OLECHAR* DirPath);
static HRESULT CopyDirectory(const OLECHAR* DirSource, const OLECHAR* DirTarget);
static HRESULT DirectoryHasFullBackup(const OLECHAR* DirPath);
static HRESULT FileCount(const OLECHAR* DirPath, const OLECHAR* Pattern,
                    ULONG* Count);
static HRESULT RenameDirectory(const OLECHAR* OldDir, const OLECHAR* NewDir);



//  Non-member function initially called for autobackup thread
static DWORD WsbDbSysStartAutoBackup(
    void* pVoid
    )
{
    return(((CWsbDbSys*) pVoid)->AutoBackup());
}


HRESULT
CWsbDbSys::AutoBackup(
    void
    )

/*++

Routine Description:

  Implements an auto-backup loop.

Arguments:

  None.
  
Return Value:

  Doesn't matter.


--*/
{
    HRESULT    hr = S_OK;

    try {
        ULONG   SleepPeriod = DEFAULT_AUTOBACKUP_INTERVAL;
        BOOL    exitLoop = FALSE;

        while (! exitLoop) {

            // Wait for termination event, if timeout occurs, check the sleep period criteria
            switch (WaitForSingleObject(m_terminateEvent, SleepPeriod)) {
                case WAIT_OBJECT_0:
                    // Need to terminate
                    WsbTrace(OLESTR("CWsbDbSys::AutoBackup: signaled to terminate\n"));
                    exitLoop = TRUE;
                    break;

                case WAIT_TIMEOUT: 
                    // Check if backup need to be performed
                    WsbTrace(OLESTR("CWsbDbSys::AutoBackup awakened, ChangeCount = %ld\n"), m_ChangeCount);

                    //  Don't do a backup if there hasn't been much activity
                    if (DEFAULT_AUTOBACKUP_COUNT_MIN < m_ChangeCount) {
                        LONG     DiffMinutes;
                        FILETIME ftNow;
                        LONGLONG NowMinutes;
                        LONGLONG ThenMinutes;

                        //  Wait for an idle time
                        GetSystemTimeAsFileTime(&ftNow);
                        NowMinutes = WsbFTtoLL(ftNow) / WSB_FT_TICKS_PER_MINUTE;
                        ThenMinutes = WsbFTtoLL(m_LastChange) / WSB_FT_TICKS_PER_MINUTE;
                        DiffMinutes = static_cast<LONG>(NowMinutes - ThenMinutes);

                        WsbTrace(OLESTR("CWsbDbSys::AutoBackup idle minutes = %ld\n"),
                        DiffMinutes);
                        if (DEFAULT_AUTOBACKUP_IDLE_MINUTES < DiffMinutes ||
                                DEFAULT_AUTOBACKUP_COUNT_MAX < m_ChangeCount) {
                            hr = Backup(NULL, 0);
                            if (S_OK != hr) {
                                // Just trace and go back to wait for the next round...
                                WsbTrace(OLESTR("CWsbDbSys::AutoBackup: Backup failed, hr=<%ls>\n"), WsbHrAsString(hr));
                            }
                            SleepPeriod = DEFAULT_AUTOBACKUP_INTERVAL;;
                        } else {
                            //  Reduce the sleep time so we catch the next idle time
                            ULONG SleepMinutes = SleepPeriod / (1000 * 60);

                            if (SleepMinutes > (DEFAULT_AUTOBACKUP_IDLE_MINUTES * 2)) {
                                SleepPeriod /= 2;
                            }
                        }
                    }

                    break;  // end of timeout case

                case WAIT_FAILED:
                default:
                    WsbTrace(OLESTR("CWsbDbSys::AutoBackup: WaitForSingleObject returned error %lu\n"), GetLastError());
                    exitLoop = TRUE;
                    break;

            } // end of switch

        } // end of while

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CWsbDbSys::Backup(
    IN OLECHAR* path,
    IN ULONG    flags
    )

/*++

Implements:

  IWsbDbSys::Backup

--*/
{
    HRESULT    hr = S_OK;
    char*      backup_path = NULL;

    WsbTraceIn(OLESTR("CWsbDbSys::Backup"), OLESTR("path = <%ls>, flags = %lx"), 
            path, flags);
    
    try {

        CWsbStringPtr   BackupDir;
        JET_ERR         jstat = JET_errSuccess;

        WsbAffirm(m_jet_initialized, WSB_E_NOT_INITIALIZED);

        //  Set and save the backup path; make sure it exists
        if (NULL != path) {
            m_BackupPath = path;
        }
        CreateDirectory(m_BackupPath, NULL);

        //  Start the automatic backup thread if requested
        if (flags & IDB_BACKUP_FLAG_AUTO) {

            //  Don't start AutoBackup thread if it's already running
            if (0 == m_AutoThread) {
                DWORD  threadId;

                // Create termination event for auto-backup thread
                WsbAffirmHandle(m_terminateEvent = CreateEvent(NULL, TRUE, FALSE, NULL));

                WsbAffirm((m_AutoThread = CreateThread(0, 0, WsbDbSysStartAutoBackup, 
                        (void*) this, 0, &threadId)) != 0, HRESULT_FROM_WIN32(GetLastError()));
            }

        //  Do a full backup to a temporary directory
        } else if (flags & IDB_BACKUP_FLAG_FORCE_FULL) {
            BOOL            UsedTempDir = FALSE;

            //  Don't wipe out an existing backup -- if the normal backup
            //  directory contains a full backup, do the full backup to
            //  the .ful directory
            BackupDir = m_BackupPath;
            WsbAffirm(0 != (WCHAR *)BackupDir, E_OUTOFMEMORY);
            if (S_OK == DirectoryHasFullBackup(BackupDir)) {
                WsbAffirmHr(AddExtension(&BackupDir, L".ful"));
                UsedTempDir = TRUE;
            }

            //  Make sure the directory exists (should check for errors?)
            CreateDirectory(BackupDir, NULL);

            //  Make sure the directory is empty (the call to JetBackup will
            //  fail if it's not)
            WsbAffirmHr(ClearDirectory(BackupDir));

            //  Convert to narrow char string for parameter
            WsbAffirmHr(wsb_db_jet_fix_path(BackupDir, NULL, &backup_path));
            WsbTrace(OLESTR("CWsbDbSys::Backup: backup_path = <%hs>\n"), backup_path);

            //  Do backup
            WsbAffirm(NULL != m_BackupEvent, WSB_E_IDB_WRONG_BACKUP_SETTINGS);
            DWORD status = WaitForSingleObject(m_BackupEvent, EVENT_WAIT_TIMEOUT);
            DWORD errWait;
            switch(status) {
                case WAIT_OBJECT_0:
                    // Expected case - do Backup
                    jstat = JetBackupInstance(m_jet_instance, backup_path, 0, NULL);
                    if (! SetEvent(m_BackupEvent)) {
                        // Don't abort, just trace error
                        WsbTraceAlways(OLESTR("CWsbDbSys::Backup: SetEvent returned unexpected error %lu\n"), GetLastError());
                    }
                    WsbAffirmHr(jet_error(jstat));
                    break;

                case WAIT_TIMEOUT: 
                    // Timeout - don't do backup
                    WsbTraceAlways(OLESTR("CWsbDbSys::Backup, Wait for Single Object timed out after %lu ms\n"), EVENT_WAIT_TIMEOUT);
                    WsbThrow(E_ABORT);
                    break;                      

                case WAIT_FAILED:
                    errWait = GetLastError();
                    WsbTraceAlways(OLESTR("CWsbDbSys::Backup, Wait for Single Object returned error %lu\n"), errWait);
                    WsbThrow(HRESULT_FROM_WIN32(errWait));
                    break;

                default:
                    WsbTraceAlways(OLESTR("CWsbDbSys::Backup, Wait for Single Object returned unexpected status %lu\n"), status);
                    WsbThrow(E_UNEXPECTED);
                    break;
            }

            //  Full backup worked -- copy to real backup directory
            if (UsedTempDir) {
                try {
                    WsbAffirmHr(ClearDirectory(m_BackupPath));
                    WsbAffirmHr(CopyDirectory(BackupDir, m_BackupPath));
                    WsbAffirmHr(ClearDirectory(BackupDir));

                    //  Try to delete temporary directory (may fail)
                    DeleteFile(BackupDir);
                    BackupDir = m_BackupPath;
                } WsbCatch(hr);
            }
            WsbLogEvent(WSB_MESSAGE_IDB_BACKUP_FULL, 0, NULL,
                WsbAbbreviatePath(BackupDir, 120), NULL);
            m_ChangeCount = 0;
            WsbAffirmHr(hr);

        //  Try an incremental backup
        } else {
            ULONG   LogCount;
            BOOL    TryFullBackup = FALSE;

            WsbAffirmHr(FileCount(m_BackupPath, L"*.log", &LogCount));

            if (LogCount > DEFAULT_AUTOBACKUP_LOG_COUNT ||
                    S_FALSE == DirectoryHasFullBackup(m_BackupPath)) {
                //  Do a full backup instead of the incremental if there
                //  are already too many log files, or there's no full
                //  backup in the backup directory (which means the incremental
                //  wouldn't work anyway)
                TryFullBackup = TRUE;
            } else {
                WsbTrace(OLESTR("CWsbDbSys::Backup, trying incremental backup\n"));

                //  Convert to narrow char string for parameter
                WsbAffirmHr(wsb_db_jet_fix_path(m_BackupPath, NULL, &backup_path));
                WsbTrace(OLESTR("CWsbDbSys::Backup: backup_path = <%hs>\n"), backup_path);

                WsbAffirm(NULL != m_BackupEvent, WSB_E_IDB_WRONG_BACKUP_SETTINGS);
                DWORD status = WaitForSingleObject(m_BackupEvent, EVENT_WAIT_TIMEOUT);
                DWORD errWait;
                switch(status) {
                    case WAIT_OBJECT_0:
                        // Expected case - do Backup
                        jstat = JetBackupInstance(m_jet_instance, backup_path, JET_bitBackupIncremental, NULL);
                        if (! SetEvent(m_BackupEvent)) {
                            // Don't abort, just trace error
                            WsbTraceAlways(OLESTR("CWsbDbSys::Backup: SetEvent returned unexpected error %lu\n"), GetLastError());
                        }
                        break;

                    case WAIT_TIMEOUT: 
                        // Timeout - don't do backup
                        WsbTraceAlways(OLESTR("CWsbDbSys::Backup, Wait for Single Object timed out after %lu ms\n"), EVENT_WAIT_TIMEOUT);
                        WsbThrow(E_ABORT);
                        break;                      

                    case WAIT_FAILED:
                        errWait = GetLastError();
                        WsbTraceAlways(OLESTR("CWsbDbSys::Backup, Wait for Single Object returned error %lu\n"), errWait);
                        WsbThrow(HRESULT_FROM_WIN32(errWait));
                        break;

                    default:
                        WsbTraceAlways(OLESTR("CWsbDbSys::Backup, Wait for Single Object returned unexpected status %lu\n"), status);
                        WsbThrow(E_UNEXPECTED);
                        break;
                }

                //  Check for an error.
                if (JET_errSuccess != jstat) {
                    if (JET_errMissingFullBackup == jstat) {
                        // Full backup need to be performed
                        WsbLogEvent(WSB_MESSAGE_IDB_MISSING_FULL_BACKUP, 0, NULL, 
                                WsbAbbreviatePath(m_BackupPath, 120), NULL);
                    } else {
                        // Unknown error of incremental backup. Try a full backup anyway
                        WsbLogEvent(WSB_MESSAGE_IDB_INCREMENTAL_BACKUP_FAILED, 0, NULL, 
                                WsbAbbreviatePath(m_BackupPath, 120),
                                WsbLongAsString(jstat), NULL );
                    }
                    TryFullBackup = TRUE;
                } else {
                    //  The incremental backup worked
                    WsbLogEvent(WSB_MESSAGE_IDB_BACKUP_INCREMENTAL, 0, NULL,
                        WsbAbbreviatePath(m_BackupPath, 120), NULL);
                    m_ChangeCount = 0;
                }
            }

            //  Try full backup?
            if (TryFullBackup) {
                WsbAffirmHr(Backup(NULL, IDB_BACKUP_FLAG_FORCE_FULL));
            }
        }

    } WsbCatchAndDo(hr, 
            WsbLogEvent(WSB_MESSAGE_IDB_BACKUP_FAILED, 0, NULL,
            WsbAbbreviatePath(m_BackupPath, 120), NULL);
        );

    if (NULL != backup_path) {
        WsbFree(backup_path);
    }

    WsbTraceOut(OLESTR("CWsbDbSys::Backup"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CWsbDbSys::FinalConstruct(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalConstruct

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("CWsbDbSys::FinalConstruct"), OLESTR("") );

    try {
        m_AutoThread = 0;
        m_terminateEvent = NULL;
        m_ChangeCount = 0;

        m_jet_initialized = FALSE;
        m_jet_instance = JET_instanceNil;

        m_BackupEvent = NULL;

        try {
            // Initialize critical sections (global resource, so init only for first user)
            if (AttachedCritSectUsers == 0) {
                WsbAffirmStatus(InitializeCriticalSectionAndSpinCount (&AttachedCritSect, 1000));
            }
            AttachedCritSectUsers++;
        } catch(DWORD status) {
                AttachedCritSectUsers--;
                WsbLogEvent(status, 0, NULL, NULL);
                switch (status) {
                case STATUS_NO_MEMORY:
                    WsbThrow(E_OUTOFMEMORY);
                    break;
                default:
                    WsbThrow(E_UNEXPECTED);
                    break;
                }
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbDbSys::FinalConstruct"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return(hr);
}



void
CWsbDbSys::FinalRelease(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalRelease

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("CWsbDbSys::FinalRelease"), OLESTR(""));

    try {
        // Make sure that Terminate was called
        if (m_jet_initialized == TRUE) {
            WsbAffirmHr(Terminate());
        }
    } WsbCatch(hr);

    // Global resource, so delete only for last user
    AttachedCritSectUsers--;
    if (AttachedCritSectUsers == 0) {
        DeleteCriticalSection(&AttachedCritSect);
    }

    WsbTraceOut(OLESTR("CWsbDbSys::FinalRelease"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));
}


HRESULT
CWsbDbSys::Init(
    IN OLECHAR* path,
    IN ULONG    flags
    )

/*++

Implements:

  IWsbDbSys::Init

--*/
{
    HRESULT             hr = S_OK;
    char*               log_path = NULL;
    static BOOL         bFirstTime = TRUE;
    static int          nInstance = 0;

    WsbTraceIn(OLESTR("CWsbDbSys::Init"), OLESTR("path = <%ls>"), path);
    
    try {

        CWsbStringPtr   dir;
        JET_ERR         jstat = JET_errSuccess;

        // Initialize the Jet engine just once per Jet instance
        WsbAffirm(!m_jet_initialized, E_FAIL);

        // Initialize backup event, unless Jet backup is not required for this isntance
        if (! (flags & IDB_SYS_INIT_FLAG_NO_BACKUP)) {
            WsbAffirmHandle(m_BackupEvent = CreateEvent(NULL, FALSE, TRUE, HSM_IDB_STATE_EVENT));
        }

        // WsbDbSys represents one Jet instance.
        // However, some Jet initialization should be done only once per process,
        //  before the first instance is being created.
        if (bFirstTime) {
            bFirstTime = FALSE;

            // Increase the default number of maximum Jet sesions for the process
            //  TEMPORARY: Can this be set separately per instance?
            jstat = JetSetSystemParameter(0, 0, JET_paramCacheSizeMin , (IDB_MAX_NOF_SESSIONS*4), NULL);
            WsbTrace(OLESTR("CWsbDbSys::Init, JetSetSystemParameter(CacheSizeMax) = %ld\n"), jstat);
            WsbAffirmHr(jet_error(jstat));
            jstat = JetSetSystemParameter(0, 0, JET_paramMaxSessions, IDB_MAX_NOF_SESSIONS, NULL);
            WsbTrace(OLESTR("CWsbDbSys::Init, JetSetSystemParameter(MaxSessions) = %ld\n"), jstat);
            WsbAffirmHr(jet_error(jstat));

            // Tell Jet we are going to use multiple instances
            jstat = JetEnableMultiInstance(NULL, 0, NULL);
            WsbAffirmHr(jet_error(jstat));
        }

        // Here start the per-instance initialization. 
        // First step is creating the instance
        //  Use a numeric counter as instance name - we care only that the name is unique
        WsbAssert(JET_instanceNil == m_jet_instance, E_FAIL);
        nInstance++;
        char szInstance[10];
        sprintf(szInstance, "%d", nInstance);
        WsbTrace(OLESTR("CWsbDbSys::Init, Jet instance name = <%hs>\n"), szInstance);
        jstat = JetCreateInstance(&m_jet_instance, szInstance);
        WsbAffirmHr(jet_error(jstat));


        // Set some per-instance parameters:
            
        //  Create path for log directory (same path is also used for system files and temp files)
        WsbAffirm(NULL != path, E_INVALIDARG);
        m_InitPath = path;
        m_BackupPath = m_InitPath;
        WsbAffirmHr(AddExtension(&m_BackupPath, L".bak"));
        WsbTrace(OLESTR("CWsbDbSys::Init, BackupPath = <%ls>\n"),  (WCHAR *)m_BackupPath);
        WsbAffirmHr(wsb_db_jet_fix_path(path, OLESTR(""), &log_path));
        dir = log_path;  // Convert to WCHAR

        //  Make sure the directory exists.
        WsbTrace(OLESTR("CWsbDbSys::Init, Creating dir = <%ls>\n"), (WCHAR *)dir);
        if (! CreateDirectory(dir, NULL)) {
            DWORD status = GetLastError();
            if ((status == ERROR_ALREADY_EXISTS) || (status == ERROR_FILE_EXISTS)) {
                status = NO_ERROR;
            }
            WsbAffirmNoError(status);
        }

        ULONG  checkpointDepth;
        ULONG  logFileSize = 128;        // In kilobytes

        if (! (flags & IDB_SYS_INIT_FLAG_NO_LOGGING)) {

            WsbTrace(OLESTR("CWsbDbSys::Init, LogFilePath = <%hs>\n"), log_path);
            jstat = JetSetSystemParameter(&m_jet_instance, 0, JET_paramLogFilePath, 0, log_path);
            WsbTrace(OLESTR("CWsbDbSys::Init, JetSetSystemParameter(LogFilePath) = %ld\n"), jstat);
            WsbAffirmHr(jet_error(jstat));

            // Use circular logging for "limited" logging
            if (flags & IDB_SYS_INIT_FLAG_LIMITED_LOGGING) {
                logFileSize = 512;   // Increase the log file size
                jstat = JetSetSystemParameter(&m_jet_instance, 0, JET_paramCircularLog, 1, NULL);
                WsbAffirmHr(jet_error(jstat));
                WsbTrace(OLESTR("CWsbDbSys::Init: set circular logging\n"));

                //  Set the amount of logging allowed before a check point
                //  to allow about 4 log files
                //  (the check point depth is set in bytes.)
                checkpointDepth = 4 * logFileSize * 1024;
                jstat = JetSetSystemParameter(&m_jet_instance, 0, JET_paramCheckpointDepthMax, 
                                checkpointDepth, NULL);
                WsbAffirmHr(jet_error(jstat));
                WsbTrace(OLESTR("CWsbDbSys::Init: set CheckpointDepthMax = %ld\n"), checkpointDepth);
            }

        } else {
            jstat = JetSetSystemParameter(&m_jet_instance, 0, JET_paramRecovery, 
                            0, "off");
            WsbAffirmHr(jet_error(jstat));
            WsbTrace(OLESTR("CWsbDbSys::Init: set JET_paramRecovery to 0 (no logging)\n"));
        }

        //  Set parameters for where to put auxiliary data
        WsbTrace(OLESTR("CWsbDbSys::Init, SystemPath = <%hs>\n"), log_path);
        jstat = JetSetSystemParameter(&m_jet_instance, 0, JET_paramSystemPath, 0, log_path);
        WsbAffirmHr(jet_error(jstat));

        // The next one, for some unknown reason, needs a file name at the end of the path
        WsbAffirmHr(dir.Append("\\temp.edb"));
        WsbAffirmHr(dir.CopyTo(&log_path));
        WsbTrace(OLESTR("CWsbDbSys::Init, TempPath = <%hs>\n"), log_path);
        jstat = JetSetSystemParameter(&m_jet_instance, 0, JET_paramTempPath, 0, log_path);
        WsbAffirmHr(jet_error(jstat));

        if (! (flags & IDB_SYS_INIT_FLAG_NO_LOGGING)) {

            //  Set the log file size (in KB). The minimum seems to be 128KB.
            jstat = JetSetSystemParameter(&m_jet_instance, 0, JET_paramLogFileSize, 
                            logFileSize, NULL);
            WsbAffirmHr(jet_error(jstat));
            WsbTrace(OLESTR("CWsbDbSys::Init: set logFileSize to %ld Kb\n"), logFileSize);
        }

        // Set parameter for deleting out-of-range log files. 
        // These files may exist after a restore from a db backup without clearing the db directory first
        if (! (flags & IDB_SYS_INIT_FLAG_NO_BACKUP)) {
            jstat = JetSetSystemParameter(&m_jet_instance, 0, JET_paramDeleteOutOfRangeLogs, 1, NULL);
            WsbAffirmHr(jet_error(jstat));
            WsbTrace(OLESTR("CWsbDbSys::Init: set delete out-of-range logs\n"));
        }

        // Initialize the DB instance
        jstat = JetInit(&m_jet_instance);
        hr = jet_error(jstat);

        // If this failed, report the error
        if (!SUCCEEDED(hr)) {
            if (flags & IDB_SYS_INIT_FLAG_SPECIAL_ERROR_MSG) {
                // Special message for FSA
                WsbLogEvent(WSB_E_IDB_DELETABLE_DATABASE_CORRUPT, 0, NULL, NULL);
                WsbThrow(WSB_E_RESOURCE_UNAVAILABLE);
            } else {
                WsbThrow(hr);
            }
        }
        WsbTrace(OLESTR("CWsbDbSys::Init: jet instance = %p\n"), (LONG_PTR)m_jet_instance);
        m_jet_initialized = TRUE;

        //  Create a session for internal use of this instance
        WsbAffirmHr(NewSession(&m_pWsbDbSession));
        WsbTrace(OLESTR("CWsbDbSys::Init, m_pWsbDbSession = %p\n"), (IWsbDbSession*)m_pWsbDbSession);

    } WsbCatchAndDo(hr, 
            WsbLogEvent(WSB_MESSAGE_IDB_INIT_FAILED, 0, NULL,
            WsbAbbreviatePath(m_InitPath, 120), NULL);
        );

    if (NULL != log_path) {
        WsbFree(log_path);
    }

    WsbTraceOut(OLESTR("CWsbDbSys::Init"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return(hr);
}

HRESULT
CWsbDbSys::Terminate(
    void
    )

/*++

Implements:

  IWsbDbSys::Terminate

--*/
{
    HRESULT             hr = S_OK;
    WsbTraceIn(OLESTR("CWsbDbSys::Terminate"), OLESTR(""));

    try {
        // If wasn't initialized or alreday cleaned up - just get out
        if (m_jet_initialized == FALSE) {
            WsbTrace(OLESTR("CWsbDbSys::Terminate - this insatnce is not initialized"));
            WsbThrow(S_OK);
        }

        // Terminate the auto-backup thread
        if (m_AutoThread) {
            // Signal thread to terminate
            SetEvent(m_terminateEvent);

            // Wait for the thread, if it doesn't terminate gracefully - kill it
            switch (WaitForSingleObject(m_AutoThread, 20000)) {
                case WAIT_FAILED: {
                    WsbTrace(OLESTR("CWsbDbSys::Terminate: WaitForSingleObject returned error %lu\n"), GetLastError());
                }
                // fall through...

                case WAIT_TIMEOUT: {
                    WsbTrace(OLESTR("CWsbDbSys::Terminate: force terminating of auto-backup thread.\n"));

                    DWORD dwExitCode;
                    if (GetExitCodeThread( m_AutoThread, &dwExitCode)) {
                        if (dwExitCode == STILL_ACTIVE) {   // thread still active
                            if (!TerminateThread (m_AutoThread, 0)) {
                                WsbTrace(OLESTR("CWsbDbSys::Terminate: TerminateThread returned error %lu\n"), GetLastError());
                            }
                        }
                    } else {
                        WsbTrace(OLESTR("CWsbDbSys::Terminate: GetExitCodeThread returned error %lu\n"), GetLastError());
                    }

                    break;
                }

                default:
                    // Thread terminated gracefully
                    break;
            }

            // Best effort done for terminating auto-backup thread
            CloseHandle(m_AutoThread);
            m_AutoThread = 0;
        }
        if (m_terminateEvent != NULL) {
            CloseHandle(m_terminateEvent);
            m_terminateEvent = NULL;
        }

        //  Detach DBs before exiting so they don't automatically get
        //  reattached the next time we start up
        if (m_pWsbDbSession) {
            JET_SESID sid;

            CComQIPtr<IWsbDbSessionPriv, &IID_IWsbDbSessionPriv> pSessionPriv = m_pWsbDbSession;
            WsbAffirmPointer(pSessionPriv);
            WsbAffirmHr(pSessionPriv->GetJetId(&sid));

            // Clean up the Attached data
            if (AttachedInit) {
                EnterCriticalSection(&AttachedCritSect);
                for (int i = 0; i < MAX_ATTACHED_DB; i++) {
                    Attached[i].Name.Free();
                    Attached[i].LastOpen = 0;
                }
                JetDetachDatabase(sid, NULL);
                AttachedInit = FALSE;
                LeaveCriticalSection(&AttachedCritSect);
            }

            // Release the global session for this instance
            m_pWsbDbSession = 0;
        }

        // Terminate Jet
        JetTerm(m_jet_instance);
        m_jet_initialized = FALSE;
        m_jet_instance = JET_instanceNil;

    } WsbCatch(hr);

    if (m_BackupEvent) {
        CloseHandle(m_BackupEvent);
        m_BackupEvent = NULL;
    }

    WsbTraceOut(OLESTR("CWsbDbSys::Terminate"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return (hr);
}


HRESULT
CWsbDbSys::NewSession(
    OUT IWsbDbSession** ppSession
    )

/*++

Implements:

  IWsbDbSys::NewSession

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("CWsbDbSys::NewSession"), OLESTR(""));
    
    try {
        WsbAffirm(0 != ppSession, E_POINTER);
        WsbAffirmHr(SessionFactory.CreateInstance(NULL, IID_IWsbDbSession, 
                (void**)ppSession));

        CComQIPtr<IWsbDbSessionPriv, &IID_IWsbDbSessionPriv> pSessionPriv = *ppSession;
        WsbAffirmPointer(pSessionPriv);
        WsbAffirmHr(pSessionPriv->Init(&m_jet_instance));

    } WsbCatch(hr);
    WsbTraceOut(OLESTR("CWsbDbSys::NewSession"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return(hr);
}

HRESULT CWsbDbSys::GetGlobalSession(
    OUT IWsbDbSession** ppSession
    )
/*++

Implements:

  IWsbDbSys::GetGlobalSession

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CWsbDbSys::GetGlobalSession"), OLESTR(""));

    //
    // If the Task Manager has been created, return the pointer. Otherwise, 
    // fail.
    try {
        WsbAssert(0 != ppSession, E_POINTER);
        *ppSession = m_pWsbDbSession;
        WsbAffirm(m_pWsbDbSession != 0, E_FAIL);
        m_pWsbDbSession->AddRef();
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbDbSys::GetGlobalSession"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));
    return (hr);
}


HRESULT
CWsbDbSys::Restore(
    IN OLECHAR* fromPath,
    IN OLECHAR* toPath
    )

/*++

Implements:

  IWsbDbSys::Restore

--*/
{
    HRESULT    hr = S_OK;
    char*      backup_path = NULL;
    char*      restore_path = NULL;

    WsbTraceIn(OLESTR("CWsbDbSys::Restore"), OLESTR("fromPath = <%ls>, toPath = <%ls>"), 
            fromPath, toPath);
    
    try {

        CWsbStringPtr   dir;
        JET_ERR         jstat;

        //  This is only allowed before Init
        WsbAffirm(!m_jet_initialized, E_UNEXPECTED);
        WsbAffirm(NULL != fromPath, E_POINTER);
        WsbAffirm(NULL != toPath, E_POINTER);

        //  Convert pathes
        WsbAffirmHr(wsb_db_jet_fix_path(fromPath, OLESTR(""), &backup_path));
        WsbAffirmHr(wsb_db_jet_fix_path(toPath, OLESTR(""), &restore_path));

        //  Make sure the target directory exists.  Should check for error.
        dir = restore_path;
        CreateDirectory(dir, NULL);

        jstat = JetRestoreInstance(m_jet_instance, backup_path, restore_path, NULL);
        WsbAffirmHr(jet_error(jstat));

    } WsbCatch(hr);

    if (NULL != backup_path) {
        WsbFree(backup_path);
    }
    if (NULL != restore_path) {
        WsbFree(restore_path);
    }

    WsbTraceOut(OLESTR("CWsbDbSys::Restore"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));

    return(hr);
}

HRESULT
CWsbDbSys::IncrementChangeCount(
    void
    )

/*++

Implements:

  IWsbDbSysPriv::IncrementChangeCount

Routine Description:

  Increments the write count used by AutoBackup.

Arguments:

  None.
  
Return Value:

  S_OK

--*/
{

    HRESULT   hr = S_OK;

    WsbTraceIn(OLESTR("CWsbDbSys::IncrementChangeCount"), 
            OLESTR("count = %ld"), m_ChangeCount);

    try {
        m_ChangeCount++;
        GetSystemTimeAsFileTime(&m_LastChange);
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CWsbDbSys::IncrementChangeCount"), 
            OLESTR("count = %ld"), m_ChangeCount);

    return(hr);
}


HRESULT
CWsbDbSys::DbAttachedAdd(
    OLECHAR* name, 
    BOOL attach)
/*++

Implements:

  IWsbDbSysPriv::DbAttachedAdd

Routine Description:

  Make sure DB is attached and update the last-used count.

--*/
{
    HRESULT hr = S_OK;
    char*   jet_name = NULL;

    WsbTraceIn(OLESTR("CWsbDbSys::DbAttachedAdd"), OLESTR("name = %ls, attach = %ls"), 
            name, WsbBoolAsString(attach));

    try {
        int           i;
        int           i_empty = -1;
        int           i_found = -1;
        LONG          min_count = AttachedCount + 1;
        CWsbStringPtr match_name;

        WsbAssert(name, E_POINTER);

        //  Make sure the list is initialized
        if (!AttachedInit) {
            WsbAffirmHr(DbAttachedInit());
        }

        //  Convert the name
        WsbAffirmHr(wsb_db_jet_fix_path(name, L"." IDB_DB_FILE_SUFFIX, &jet_name));
        match_name = jet_name;

        //  See if it's already in the list; look for an empty slot; find the
        //  least-recently used DB
        EnterCriticalSection(&AttachedCritSect);
        for (i = 0; i < MAX_ATTACHED_DB; i++) {

            //  Empty slot?
            if (!Attached[i].Name) {
                if (-1 == i_empty) {
                    //  Save the first one found
                    i_empty = i;
                }
            } else {

                //  Gather some data for later
                if (Attached[i].LastOpen < min_count) {
                    min_count = Attached[i].LastOpen;
                }

                //  Already in list?
                if (match_name.IsEqual(Attached[i].Name)) {
                    i_found = i;
                }
            }
        }

        //  Make sure the count isn't going to overflow
        if (LONG_MAX == AttachedCount + 1) {
            WsbAffirm(0 < min_count, E_FAIL);

            //  Adjust counts down to avoid overflow
            for (i = 0; i < MAX_ATTACHED_DB; i++) {
                if (min_count <= Attached[i].LastOpen) {
                    Attached[i].LastOpen -= min_count;
                }
            }
            AttachedCount -= min_count;
        }
        AttachedCount++;

        //  If it's already in the list, update the info
        if (-1 != i_found) {
            WsbTrace(OLESTR("CWsbDbSys::DbAttachedAdd: i_found = %d\n"), i_found);
            Attached[i_found].LastOpen = AttachedCount;

        //  If there's an empty slot, use it
        } else if (-1 != i_empty) {
            WsbTrace(OLESTR("CWsbDbSys::DbAttachedAdd: i_empty = %d\n"), i_empty);
            if (attach) {
                JET_ERR       jstat;
                JET_SESID sid;

                WsbAffirm(m_pWsbDbSession, WSB_E_NOT_INITIALIZED);
                CComQIPtr<IWsbDbSessionPriv, &IID_IWsbDbSessionPriv> pSessionPriv = m_pWsbDbSession;
                WsbAffirmPointer(pSessionPriv);
                WsbAffirmHr(pSessionPriv->GetJetId(&sid));

                jstat = JetAttachDatabase(sid, jet_name, 0);
                if (JET_errFileNotFound == jstat) {
                    WsbThrow(STG_E_FILENOTFOUND);
                } else if (JET_wrnDatabaseAttached == jstat) {
                    WsbTrace(OLESTR("CWsbDbSys::DbAttachedAdd: DB is already attached\n"));
                    // No problem
                } else {
                    WsbAffirmHr(jet_error(jstat));
                }
            }
            Attached[i_empty].Name = match_name;
            Attached[i_empty].LastOpen = AttachedCount;

        //  Try to detach the oldest DB first
        } else {
            WsbAffirmHr(DbAttachedEmptySlot());
            WsbAffirmHr(DbAttachedAdd(name, attach));
        }
    } WsbCatch(hr);

    if (jet_name) {
        WsbFree(jet_name);
    }
    LeaveCriticalSection(&AttachedCritSect);

    WsbTraceOut(OLESTR("CWsbDbSys::DbAttachedAdd"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));
    return(hr);
}

HRESULT
CWsbDbSys::DbAttachedEmptySlot(
    void)
/*++

Implements:

  IWsbDbSysPriv::DbAttachedEmptySlot

Routine Description:

  Force an empty slot in the attached list even if this means detaching a DB.

--*/
{
    HRESULT hr = S_OK;

    WsbTraceIn(OLESTR("CWsbDbSys::DbAttachedEmptySlot"), OLESTR(""));

    //  Don't worry about it if we're not initialized yet --
    //  all the slots are empty
    if (AttachedInit) {
        EnterCriticalSection(&AttachedCritSect);

        try {
            BOOL  has_empty = FALSE;
            int   i;
            int   i_oldest;
            LONG  oldest_count;

            //  Find an empty slot or the oldest that is not currently open
reloop:
            i_oldest = -1;
            oldest_count = AttachedCount;
            for (i = 0; i < MAX_ATTACHED_DB; i++) {
                if (!Attached[i].Name) {
                    has_empty = TRUE;
                    break;
                } else if (Attached[i].LastOpen < oldest_count) {
                    i_oldest = i;
                    oldest_count = Attached[i].LastOpen;
                }
            }

            //  If there's no empty slot, try detaching the oldest
            WsbTrace(OLESTR("CWsbDbSys::DbAttachedEmptySlot: has_empty = %ls, i = %d, i_oldest = %d\n"), 
                WsbBoolAsString(has_empty), i, i_oldest);
            if (!has_empty) {
                JET_ERR       jstat;
                char*         name;
                JET_SESID     sid;

                WsbAffirm(m_pWsbDbSession, WSB_E_NOT_INITIALIZED);
                CComQIPtr<IWsbDbSessionPriv, &IID_IWsbDbSessionPriv> pSessionPriv = m_pWsbDbSession;
                WsbAffirmPointer(pSessionPriv);
                WsbAffirmHr(pSessionPriv->GetJetId(&sid));

                WsbAffirm(-1 != i_oldest, WSB_E_IDB_TOO_MANY_DB);
                WsbAffirmHr(wsb_db_jet_fix_path(Attached[i_oldest].Name, L"." IDB_DB_FILE_SUFFIX, &name));
                jstat = JetDetachDatabase(sid, name);
                WsbFree(name);
                WsbTrace(OLESTR("CWsbDbSys::DbAttachedEmptySlot: JetDetachDatabase = %ld\n"),
                        (LONG)jstat);
                if (JET_errDatabaseInUse == jstat) {
                    WsbTrace(OLESTR("CWsbDbSys::DbAttachedEmptySlot: DB in use; try again\n"));
                    Attached[i_oldest].LastOpen = AttachedCount;
                    goto reloop;
                } else if (JET_errDatabaseNotFound != jstat) {
                    WsbAffirmHr(jet_error(jstat));
                }
                Attached[i_oldest].Name.Free();
                Attached[i_oldest].LastOpen = 0;
            }
        } WsbCatch(hr);
        LeaveCriticalSection(&AttachedCritSect);
    }

    WsbTraceOut(OLESTR("CWsbDbSys::DbAttachedEmptySlot"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));
    return(hr);
}

HRESULT 
CWsbDbSys::DbAttachedInit(
    void)
/*++

Implements:

  IWsbDbSysPriv::DbAttachedInit

Routine Description:

  Initialize the attached-DB-list data.

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CWsbDbSys::DbAttachedInit"), OLESTR(""));

    EnterCriticalSection(&AttachedCritSect);

    try {
        if (!AttachedInit) {
            ULONG   actual = 0;
            int     i;
            JET_ERR jstat;
            JET_SESID sid;

            WsbAffirm(m_pWsbDbSession, WSB_E_NOT_INITIALIZED);
            CComQIPtr<IWsbDbSessionPriv, &IID_IWsbDbSessionPriv> pSessionPriv = m_pWsbDbSession;
            WsbAffirmPointer(pSessionPriv);
            WsbAffirmHr(pSessionPriv->GetJetId(&sid));

            //  Initialize data
            for (i = 0; i < MAX_ATTACHED_DB; i++) {
                Attached[i].Name.Free();
                Attached[i].LastOpen = 0;
            }

            //  Make sure there aren't pre-attached DBs
            jstat = JetDetachDatabase(sid, NULL);
            WsbTrace(OLESTR("CWsbDbSys::DbAttachedInit: JetDetachDatabase(NULL) = %ld\n"), (LONG)jstat);
            WsbAffirmHr(jet_error(jstat));

            AttachedInit = TRUE;
        }
    } WsbCatch(hr);

    LeaveCriticalSection(&AttachedCritSect);

    WsbTraceOut(OLESTR("CWsbDbSys::DbAttachedInit"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));
    return(hr);
}

HRESULT 
CWsbDbSys::DbAttachedRemove(
    OLECHAR* name)
/*++

Implements:

  IWsbDbSysPriv::DbAttachedRemove

Routine Description:

  Detach a DB (if attached).

--*/
{
    HRESULT hr = S_FALSE;
    char*   jet_name = NULL;

    WsbTraceIn(OLESTR("CWsbDbSys::DbAttachedRemove"), OLESTR("name = %ls"), 
            name);

    try {
        int           i;
        CWsbStringPtr match_name;

        WsbAssert(name, E_POINTER);
        WsbAffirm(AttachedInit, S_FALSE);

        //  Convert the name
        WsbAffirmHr(wsb_db_jet_fix_path(name, L"." IDB_DB_FILE_SUFFIX, &jet_name));
        match_name = jet_name;

        //  See if it's in the list
        EnterCriticalSection(&AttachedCritSect);
        for (i = 0; i < MAX_ATTACHED_DB; i++) {
            if (Attached[i].Name) {
                if (match_name.IsEqual(Attached[i].Name)) {
                    JET_ERR       jstat;
                    JET_SESID     sid;

                    WsbTrace(OLESTR("CWsbDbSys::DbAttachedRemove: found DB, index = %d\n"), i);
                    WsbAffirm(m_pWsbDbSession, WSB_E_NOT_INITIALIZED);
                    CComQIPtr<IWsbDbSessionPriv, &IID_IWsbDbSessionPriv> pSessionPriv = m_pWsbDbSession;
                    WsbAffirmPointer(pSessionPriv);
                    WsbAffirmHr(pSessionPriv->GetJetId(&sid));

                    jstat = JetDetachDatabase(sid, jet_name);
                    WsbTrace(OLESTR("CWsbDbSys::DbAttachedRemove: JetDetachDatabase = %ld\n"),
                            (LONG)jstat);
                    if (JET_errDatabaseNotFound != jstat) {
                        WsbAffirmHr(jet_error(jstat));
                        hr = S_OK;
                    }
                    Attached[i].Name.Free();
                    Attached[i].LastOpen = 0;
                    break;
                }
            }
        }
    } WsbCatch(hr);

    if (jet_name) {
        WsbFree(jet_name);
    }
    LeaveCriticalSection(&AttachedCritSect);

    WsbTraceOut(OLESTR("CWsbDbSys::DbAttachedRemove"), OLESTR("hr =<%ls>"), WsbHrAsString(hr));
    return(hr);
}

//  wsb_db_jet_check_error - check for a jet error; return S_OK for no error;
//    print error to trace otherwise
HRESULT wsb_db_jet_check_error(LONG jstat, char *fileName, DWORD lineNo)
{
    HRESULT hr = S_OK;

    if (jstat != JET_errSuccess) {
        WsbTrace(OLESTR("Jet error = %ld (%hs line %ld)\n"), jstat,
                fileName, lineNo);

        //  Convert JET error to IDB error for some common values
        switch (jstat) {
        case JET_errDiskFull:
        case JET_errLogDiskFull:
            hr = WSB_E_IDB_DISK_FULL;
            break;
        case JET_errDatabaseNotFound:
            hr = WSB_E_IDB_FILE_NOT_FOUND;
            break;
        case JET_errDatabaseInconsistent:
        case JET_errPageNotInitialized:
        case JET_errReadVerifyFailure:
        case JET_errDatabaseCorrupted:
        case JET_errBadLogSignature:
        case JET_errBadDbSignature:
        case JET_errBadCheckpointSignature:
        case JET_errCheckpointCorrupt:
        case JET_errMissingPatchPage:
        case JET_errBadPatchPage:
            hr = WSB_E_IDB_DATABASE_CORRUPT;
            break;
        case JET_errWriteConflict:
            hr = WSB_E_IDB_UPDATE_CONFLICT;
            break;
        default:
            hr = WSB_E_IDB_IMP_ERROR;
            break;
        }

        //  Log this error in the event log
        if (g_WsbLogLevel) {
            CWsbStringPtr str;

            WsbSetEventInfo(fileName, lineNo, VER_PRODUCTBUILD, RS_BUILD_VERSION); \
            str = WsbLongAsString(jstat);
            if (WSB_E_IDB_IMP_ERROR != hr) {
                str.Prepend(" (");
                str.Prepend(WsbHrAsString(hr));
                str.Append(")");
            }
            WsbTraceAndLogEvent(WSB_MESSAGE_IDB_ERROR, 0, NULL,
                static_cast<OLECHAR *>(str), NULL);
        }
    }
    return(hr);
}

// wsb_db_jet_fix_path - convert database path name from OLESTR to char*,
//    change (or add) extension.
//    Returns HRESULT
//
//  NOTE: OLECHAR* is passed in, but char* is returned
HRESULT 
wsb_db_jet_fix_path(OLECHAR* path, OLECHAR* ext, char** new_path)
{
    HRESULT hr = S_OK;

    try {
        CWsbStringPtr  string;
        int            tlen;

        WsbAssertPointer(path);
        WsbAssertPointer(new_path);

        //  Add extension if given
        string = path;
        WsbAffirm(0 != (WCHAR *)string, E_OUTOFMEMORY);
        if (ext) {
            WsbAffirmHr(AddExtension(&string, ext));
        }

        // Allocate char string
        tlen = (wcslen(string) + 1) * sizeof(OLECHAR);
        *new_path = (char*)WsbAlloc(tlen);
        WsbAffirm(*new_path, E_OUTOFMEMORY);

        //  Convert from wide char to char
        if (wcstombs(*new_path, string, tlen) == (size_t)-1) {
            WsbFree(*new_path);
            *new_path = NULL;
            WsbThrow(WSB_E_STRING_CONVERSION);
        }
    } WsbCatch(hr);

    return(hr);
}


//  Local functions

//  AddExtension - add (or replace) the file extension to the path.
//    If Ext is NULL, remove the existing extension.
//
//    Return S_OK if no errors occurred.
static HRESULT AddExtension(OLECHAR** pPath, OLECHAR* Ext)
{
    HRESULT           hr = S_OK;

    WsbTraceIn(OLESTR("AddExtension(wsbdbsys)"), OLESTR("Path = \"%ls\", Ext = \"%ls\""),
            WsbAbbreviatePath(*pPath, 120), Ext );

    try {
        int      elen;
        int      len;
        OLECHAR* new_path;
        OLECHAR* pc;
        OLECHAR* pc2;
        int      tlen;

        WsbAssertPointer(pPath);
        WsbAssertPointer(*pPath);

        // Allocate string and copy path
        len = wcslen(*pPath);
        if (Ext) {
            elen = wcslen(Ext);
        } else {
            elen = 0;
        }
        tlen = (len + elen + 1) * sizeof(OLECHAR);
        new_path = static_cast<OLECHAR*>(WsbAlloc(tlen));
        WsbAffirm(new_path, E_OUTOFMEMORY);
        wcscpy(new_path, *pPath);

        //  Remove old extension (if there)
        pc = wcsrchr(new_path, L'.');
        pc2 = wcsrchr(new_path, L'\\');
        if (pc && (!pc2 || pc2 < pc)) {
            *pc = L'\0';
        }

        //  Add the new extension (if given)
        if (Ext) {
            wcscat(new_path, Ext);
        }

        //  Return the new path
        WsbFree(*pPath);
        *pPath = new_path;
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("AddExtension(wsbdbsys)"), OLESTR("hr =<%ls>, new path = \"%ls\""), 
            WsbHrAsString(hr), WsbAbbreviatePath(*pPath, 120));

    return(hr);
}

//  ClearDirectory - delete all files in a directory
//    Return S_OK if no errors occurred.
static HRESULT ClearDirectory(const OLECHAR* DirPath)
{
    DWORD             err;
    WIN32_FIND_DATA   FindData;
    HANDLE            hFind = 0;
    HRESULT           hr = S_OK;
    int               nDeleted = 0;
    int               nSkipped = 0;
    CWsbStringPtr     SearchPath;

    WsbTraceIn(OLESTR("ClearDirectory(wsbdbsys)"), OLESTR("Path = <%ls>"),
            WsbAbbreviatePath(DirPath, 120));

    try {
        SearchPath = DirPath;
        SearchPath.Append("\\*");

        hFind =  FindFirstFile(SearchPath, &FindData);
        if (INVALID_HANDLE_VALUE == hFind) {
            hFind = 0;
            err = GetLastError();
            WsbTrace(OLESTR("ClearDirectory(wsbdbsys): FindFirstFile(%ls) failed, error = %ld\n"),
                    static_cast<OLECHAR*>(SearchPath), err);
            WsbThrow(HRESULT_FROM_WIN32(err));
        }

        while (TRUE) {

            if (FindData.dwFileAttributes & (FILE_ATTRIBUTE_DIRECTORY |
                    FILE_ATTRIBUTE_HIDDEN)) {
                nSkipped++;
            } else {
                CWsbStringPtr     DeletePath;

                DeletePath = DirPath;
                DeletePath.Append("\\");
                DeletePath.Append(FindData.cFileName);
                if (!DeleteFile(DeletePath)) {
                    err = GetLastError();
                    WsbTrace(OLESTR("ClearDirectory(wsbdbsys): DeleteFile(%ls) failed, error = %ld\n"),
                            static_cast<OLECHAR*>(DeletePath), err);
                    WsbThrow(HRESULT_FROM_WIN32(err));
                }
                nDeleted++;
            }
            if (!FindNextFile(hFind, &FindData)) { 
                err = GetLastError();
                if (ERROR_NO_MORE_FILES == err) break;
                WsbTrace(OLESTR("ClearDirectory(wsbdbsys): FindNextFile failed, error = %ld\n"),
                        err);
                WsbThrow(HRESULT_FROM_WIN32(err));
            }
        }
    } WsbCatch(hr);

    if (0 != hFind) {
        FindClose(hFind);
    }

    WsbTraceOut(OLESTR("ClearDirectory(wsbdbsys)"), OLESTR("hr =<%ls>, # deleted = %d, # skipped = %d"), 
            WsbHrAsString(hr), nDeleted, nSkipped);

    return(hr);
}

//  CopyDirectory - copy files from one directory to another
//    Return S_OK if no errors occurred.
static HRESULT CopyDirectory(const OLECHAR* DirSource, const OLECHAR* DirTarget)
{
    DWORD             err;
    WIN32_FIND_DATA   FindData;
    HANDLE            hFind = 0;
    HRESULT           hr = S_OK;
    int               nCopied = 0;
    int               nSkipped = 0;
    CWsbStringPtr     SearchPath;

    WsbTraceIn(OLESTR("CopyDirectory(wsbdbsys)"), OLESTR("OldPath = \"%ls\", NewPath = \"%ls\""),
            WsbQuickString(WsbAbbreviatePath(DirSource, 120)), 
            WsbQuickString(WsbAbbreviatePath(DirTarget, 120)));

    try {
        SearchPath = DirSource;
        SearchPath.Append("\\*");

        hFind =  FindFirstFile(SearchPath, &FindData);
        if (INVALID_HANDLE_VALUE == hFind) {
            hFind = 0;
            err = GetLastError();
            WsbTrace(OLESTR("ClearDirectory(wsbdbsys): FindFirstFile(%ls) failed, error = %ld\n"),
                    static_cast<OLECHAR*>(SearchPath), err);
            WsbThrow(HRESULT_FROM_WIN32(err));
        }

        while (TRUE) {

            if (FindData.dwFileAttributes & (FILE_ATTRIBUTE_DIRECTORY |
                    FILE_ATTRIBUTE_HIDDEN)) {
                nSkipped++;
            } else {
                CWsbStringPtr     NewPath;
                CWsbStringPtr     OldPath;

                OldPath = DirSource;
                OldPath.Append("\\");
                OldPath.Append(FindData.cFileName);
                NewPath = DirTarget;
                NewPath.Append("\\");
                NewPath.Append(FindData.cFileName);
                if (!CopyFile(OldPath, NewPath, FALSE)) {
                    err = GetLastError();
                    WsbTrace(OLESTR("ClearDirectory(wsbdbsys): CopyFile(%ls, %ls) failed, error = %ld\n"),
                            static_cast<OLECHAR*>(OldPath), 
                            static_cast<OLECHAR*>(NewPath), err);
                    WsbThrow(HRESULT_FROM_WIN32(err));
                }
                nCopied++;
            }
            if (!FindNextFile(hFind, &FindData)) { 
                err = GetLastError();
                if (ERROR_NO_MORE_FILES == err) break;
                WsbTrace(OLESTR("ClearDirectory(wsbdbsys): FindNextFile failed, error = %ld\n"),
                        err);
                WsbThrow(HRESULT_FROM_WIN32(err));
            }
        }
    } WsbCatch(hr);

    if (0 != hFind) {
        FindClose(hFind);
    }

    WsbTraceOut(OLESTR("CopyDirectory(wsbdbsys)"), OLESTR("hr =<%ls>, copied = %ld, skipped = %ld"), 
            WsbHrAsString(hr), nCopied, nSkipped);

    return(hr);
}

//  DirectoryHasFullBackup - try to determine if the directory contains a full backup
//    Return 
//      S_OK    if it contains a full backup
//      S_FALSE if it doesn't
//      E_*     on errors
//
//  The technique use here is somewhat ad hoc since it expects the full backup
//  filename to end in IDB_DB_FILE_SUFFIX

static HRESULT DirectoryHasFullBackup(const OLECHAR* DirPath)
{
    HRESULT           hr = S_OK;

    WsbTraceIn(OLESTR("DirectoryHasFullBackup(wsbdbsys)"), OLESTR("Path = <%ls>"),
            WsbAbbreviatePath(DirPath, 120));

    try {
        ULONG         Count;

        WsbAffirmHr(FileCount(DirPath, L"*." IDB_DB_FILE_SUFFIX, &Count));
        if (0 == Count) {
            hr = S_FALSE;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("DirectoryHasFullBackup(wsbdbsys)"), OLESTR("hr =<%ls>"), 
            WsbHrAsString(hr));

    return(hr);
}

//  FileCount - count all files in a directory matching a pattern.  Skip
//    directories and hidden files.
//    Return S_OK if no errors occurred.
static HRESULT FileCount(const OLECHAR* DirPath, const OLECHAR* Pattern,
                    ULONG* Count)
{
    DWORD             err;
    WIN32_FIND_DATA   FindData;
    HANDLE            hFind = 0;
    HRESULT           hr = S_OK;
    int               lCount = 0;
    int               nSkipped = 0;
    CWsbStringPtr     SearchPath;

    WsbTraceIn(OLESTR("FileCount(wsbdbsys)"), OLESTR("Path = <%ls>"),
            WsbAbbreviatePath(DirPath, 120));

    try {
        SearchPath = DirPath;
        SearchPath.Append("\\");
        SearchPath.Append(Pattern);
        *Count = 0;

        hFind =  FindFirstFile(SearchPath, &FindData);
        if (INVALID_HANDLE_VALUE == hFind) {
            hFind = 0;
            err = GetLastError();
            if (ERROR_FILE_NOT_FOUND == err) WsbThrow(S_OK);
            WsbTrace(OLESTR("FileCount(wsbdbsys): FindFirstFile(%ls) failed, error = %ld\n"),
                    static_cast<OLECHAR*>(SearchPath), err);
            WsbThrow(HRESULT_FROM_WIN32(err));
        }

        while (TRUE) {

            if (FindData.dwFileAttributes & (FILE_ATTRIBUTE_DIRECTORY |
                    FILE_ATTRIBUTE_HIDDEN)) {
                nSkipped++;
            } else {
                lCount++;
            }
            if (!FindNextFile(hFind, &FindData)) { 
                err = GetLastError();
                if (ERROR_NO_MORE_FILES == err) break;
                WsbTrace(OLESTR("FileCount(wsbdbsys): FindNextFile failed, error = %ld\n"),
                        err);
                WsbThrow(HRESULT_FROM_WIN32(err));
            }
        }
    } WsbCatch(hr);

    if (0 != hFind) {
        FindClose(hFind);
    }

    if (S_OK == hr) {
        *Count = lCount;
    }

    WsbTraceOut(OLESTR("FileCount(wsbdbsys)"), OLESTR("hr =<%ls>, # skipped = %d, Count = %ld"), 
            WsbHrAsString(hr), nSkipped, *Count);

    return(hr);
}

//  RenameDirectory - rename a directory
//    Return S_OK if no errors occurred.
static HRESULT RenameDirectory(const OLECHAR* OldDir, const OLECHAR* NewDir)
{
    DWORD             err;
    HRESULT           hr = S_OK;

    WsbTraceIn(OLESTR("RenameDirectory(wsbdbsys)"), OLESTR("OldPath = \"%ls\", NewPath = \"%ls\""),
            WsbQuickString(WsbAbbreviatePath(OldDir, 120)), 
            WsbQuickString(WsbAbbreviatePath(NewDir, 120)));

    try {
        if (!MoveFile(OldDir, NewDir)) {
            err = GetLastError();
            WsbTrace(OLESTR("RenameDirectory(wsbdbsys): MoveFile failed, error = %ld\n"), err);
            WsbThrow(HRESULT_FROM_WIN32(err));
        }
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("RenameDirectory(wsbdbsys)"), OLESTR("hr =<%ls>"), 
            WsbHrAsString(hr));

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\idl\hsmsguid\makefile.inc ===
clean:
    -del $(O)\*.sbr
    -del $(O)\*.obj
    -del $(O)\*.res
    -del $(O)\*.pch
    -del $(TARGETPATH)\$(TARGET_DIRECTORY)\$(TARGETNAME).*
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\idl\mvrguid\makefile.inc ===
clean:
    -del $(O)\*.sbr
    -del $(O)\*.obj
    -del $(O)\*.res
    -del $(O)\*.pch
    -del $(TARGETPATH)\$(TARGET_DIRECTORY)\$(TARGETNAME).*
    -del *_i.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\idl\rmsps\makefile.inc ===
clean:
    -del $(O)\*.sbr
    -del $(O)\*.obj
    -del $(O)\*.res
    -del $(O)\*.pch
    -del $(TARGETPATH)\$(TARGET_DIRECTORY)\$(TARGETNAME).*
    -del $(TARGETPATHLIB)\$(TARGET_DIRECTORY)\$(TARGETNAME).*
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\inc\engine.h ===
#ifndef _ENGINE_H
#define _ENGINE_H

/*++

Copyright (c) 1997  Microsoft Corporation
 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    Engine.h

Abstract:

    Include file for all the public Engine files.

Author:

    Rohde Wakefield [rohde]     23-Apr-1997

Revision History:

--*/


#include "HsmEng.h"


// Engine lives in Remote Storage Server service thus its appid apply here
// RsServ AppID {FD0E2EC7-4055-4A49-9AA9-1BF34B39438E} 
static const GUID APPID_RemoteStorageEngine = 
{ 0xFD0E2EC7, 0x4055, 0x4A49, { 0x9A, 0xA9, 0x1B, 0xF3, 0x4B, 0x39, 0x43, 0x8E } };

// The name of the default manage job.
# define HSM_DEFAULT_MANAGE_JOB_NAME        OLESTR("Manage")
//
// Key types for the metadata database
//
#define HSM_SEG_REC_TYPE          1    
#define HSM_MEDIA_INFO_REC_TYPE   2
#define HSM_BAG_INFO_REC_TYPE     3
#define HSM_BAG_HOLE_REC_TYPE     4
#define HSM_VOL_ASSIGN_REC_TYPE   5

//
// Mask options for segment record flags
//
#define		SEG_REC_NONE				0x0000

#define		SEG_REC_INDIRECT_RECORD     0x0001
#define		SEG_REC_MARKED_AS_VALID		0x0002

//
// Maximum number of copies supported by this engine
//
#define HSM_MAX_NUMBER_MEDIA_COPIES 3

//
// Strings for session names that are written to media
//
#define HSM_BAG_NAME            OLESTR("Remote Storage Set - ")
#define HSM_ENGINE_ID           OLESTR("Remote Storage ID - ")
#define HSM_METADATA_NAME       OLESTR("Remote Storage Metadata")   // Currently, in use only for Optical media

//
// Engine's Registry location
//
#define HSM_ENGINE_REGISTRY_STRING      OLESTR("SYSTEM\\CurrentControlSet\\Services\\Remote_Storage_Server\\Parameters")

#endif // _ENGINE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\inc\fsa.h ===
#ifndef _FSA_
#define _FSA_

// fsa.h
//
// This header file collects up all the FSA and related objects
// and common function definitions. The COM objects are available in
// FSA.EXE.

#include "wsb.h"

// A definition for 1% and 100% as used by the resource's configured HsmLevel.
#define FSA_HSMLEVEL_1              10000000
#define FSA_HSMLEVEL_100            1000000000

// Records types for FSA Unmanage database
#define UNMANAGE_REC_TYPE                   1

// Macros to convert the Hsm management levels into percentages (and the inverse 
// macro, as well)
#define CONVERT_TO_PCT(__x) ( (__x) / FSA_HSMLEVEL_1 )
#define CONVERT_TO_HSMNUM(__x) ( (__x) * FSA_HSMLEVEL_1 )

// COM Interface & LibraryDefintions
#include "fsadef.h"
#include "fsaint.h"
#include "fsalib.h"

// Common Functions
#include "fsatrace.h"

// Recall notification
#include "fsantfy.h"

// Fsa lives now in Remote Storage Server service thus its appid apply here
// (This may change in the future if Fsa may reside in Client service as well)
// RsServ AppID {FD0E2EC7-4055-4A49-9AA9-1BF34B39438E} 
static const GUID APPID_RemoteStorageFileSystemAgent = 
{ 0xFD0E2EC7, 0x4055, 0x4A49, { 0x9A, 0xA9, 0x1B, 0xF3, 0x4B, 0x39, 0x43, 0x8E } };

#endif // _FSA_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\inc\fsatrace.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    FsaTrace.h

Abstract:

    This header file defines the part of the FSA code that is
    responsible for tracing FSA specific parameters.

Author:

    Cat Brant       [cbrant]   7-Det-1996

Revision History:

--*/

#ifndef _FSATRACE_
#define _FSATRACE_

#ifdef __cplusplus
extern "C" {
#endif

// Helper Functions
//
// NOTE: Be careful with some of these helper functions, since they
// use static memory and a second call to the function will overwrite
// the results of the first call to the function. 
extern const OLECHAR* FsaRequestActionAsString(FSA_REQUEST_ACTION requestAction);
extern const OLECHAR* FsaResultActionAsString(FSA_RESULT_ACTION resultAction);

#ifdef __cplusplus
}
#endif


#endif // _FSATRACE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\inc\job.h ===
// job.h
//
// This header file collects up all the HSM Job and related objects
// and common function definitions. The COM objects are available in
// RSJOB.DLL, and the functions in RSJOB.LIB.

// A definition for 1% and 100% as used by the job policies scale.
#define HSM_JOBSCALE_1              0x0010
#define HSM_JOBSCALE_100            0x0640

// Error codes
#include "wsb.h"

// COM Interface & LibraryDefintions
#include "jobdef.h"
#include "jobint.h"
#include "joblib.h"

// Common Functions

// Defines for groups of job states.
#define HSM_JOB_STATE_IS_ACTIVE(state)  ((HSM_JOB_STATE_ACTIVE == state) || \
                                         (HSM_JOB_STATE_CANCELLING == state) || \
                                         (HSM_JOB_STATE_PAUSING == state) || \
                                         (HSM_JOB_STATE_RESUMING == state) || \
                                         (HSM_JOB_STATE_STARTING == state) || \
                                         (HSM_JOB_STATE_SUSPENDING == state))

#define HSM_JOB_STATE_IS_DONE(state)    ((HSM_JOB_STATE_DONE == state) || \
                                         (HSM_JOB_STATE_CANCELLED == state) || \
                                         (HSM_JOB_STATE_FAILED == state) || \
                                         (HSM_JOB_STATE_SKIPPED == state) || \
                                         (HSM_JOB_STATE_SUSPENDED == state))

#define HSM_JOB_STATE_IS_PAUSED(state)  (HSM_JOB_STATE_PAUSED == state)


// This bits tell the session when to log events.
#define HSM_JOB_LOG_EVENT               0x00000001
#define HSM_JOB_LOG_ITEMMOSTFAIL        0x00000002
#define HSM_JOB_LOG_ITEMALLFAIL         0x00000004
#define HSM_JOB_LOG_ITEMALL             0x00000008
#define HSM_JOB_LOG_HR                  0x00000010
#define HSM_JOB_LOG_MEDIASTATE          0x00000020
#define HSM_JOB_LOG_PRIORITY            0x00000040
#define HSM_JOB_LOG_STATE               0x00000080
#define HSM_JOB_LOG_STRING              0x00000100

#define HSM_JOB_LOG_NONE                0x0
#define HSM_JOB_LOG_NORMAL              HSM_JOB_LOG_ITEMMOSTFAIL | HSM_JOB_LOG_HR | HSM_JOB_LOG_STATE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\inc\hsmconn.h ===
/*++

Copyright (c) 1996  Microsoft Corporation
 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    HsmFind.h

Abstract:

    This is the header file for HsmConn.dll

Author:

    Rohde Wakefield    [rohde]   21-Oct-1996

Revision History:

--*/




#ifndef __HSMFIND__
#define __HSMFIND__

// Need for IEnumGUID
#include "activeds.h"
#include "inetsdk.h"

#include "HsmEng.h"

#ifdef __cplusplus
extern "C"
{
#endif

#ifdef HSMCONN_IMPL
#define HSMCONN_EXPORT __declspec(dllexport)
#else
#define HSMCONN_EXPORT __declspec(dllimport)
#endif

#define HSMCONN_API __stdcall

typedef enum _hsmconn_type {

    HSMCONN_TYPE_HSM,
    HSMCONN_TYPE_FSA,
    HSMCONN_TYPE_RESOURCE,
    HSMCONN_TYPE_FILTER,
    HSMCONN_TYPE_RMS        //stays just as literal for GUI needs, but NOT supported
                            //by HsmConn anymore
} HSMCONN_TYPE;


HSMCONN_EXPORT HRESULT HSMCONN_API
HsmConnectFromId (
    IN  HSMCONN_TYPE type,
    IN  REFGUID rguid,
    IN  REFIID riid,
    OUT void ** ppv
    );

HSMCONN_EXPORT HRESULT HSMCONN_API
HsmConnectFromName (
    IN  HSMCONN_TYPE type,
    IN  const OLECHAR * szName,
    IN  REFIID riid,
    OUT void ** ppv
    );

HSMCONN_EXPORT HRESULT HSMCONN_API
HsmPublish (
    IN  HSMCONN_TYPE type,
    IN  const OLECHAR * szName,
    IN  REFGUID rguidObjectId,
    IN  const OLECHAR * szServer,
    IN  REFGUID rguid
    );

HSMCONN_EXPORT HRESULT HSMCONN_API
HsmGetComputerNameFromADsPath(
    IN  const OLECHAR * szADsPath,
    OUT OLECHAR **      pszComputerName
    );

#ifdef __cplusplus
}
#endif

#endif //__HSMFIND__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\inc\cli.h ===
/*++
Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    CLI.H

Abstract:

    This module defines the prototype for the Command Line Interface
    for HSM. These are interfaces the parse module of the CLI would
    call 

Author:

    Ravisankar Pudipeddi (ravisp)  2/23/00

Environment:

    User Mode

--*/

#ifndef _RSCLI_
#define _RSCLI_

#ifdef __cplusplus
extern "C" {
#endif

typedef enum _HSM_JOB_TYPE {
    InvalidJobType = 0,
    CopyFiles,
    CreateFreeSpace,
    Validate,
    Unmanage
}  HSM_JOB_TYPE;

typedef enum _HSM_JOB_FREQUENCY {
    InvalidJobFrequency = 0,
    Daily,
    Weekly,
    Monthly,
    Once,
    SystemStartup,
    Login,
    WhenIdle
} HSM_JOB_FREQUENCY;
    
    
typedef struct _HSM_JOB_SCHEDULE {
    HSM_JOB_FREQUENCY Frequency;
    union {
        struct {
            SYSTEMTIME  Time;
            DWORD       Occurrence;
        } Daily;
        struct {
            SYSTEMTIME  Time;
            DWORD       Occurrence;
        } Weekly;
        struct {
            SYSTEMTIME  Time;
        } Monthly;
        struct {
            SYSTEMTIME  Time;
        } Once;
        struct {
        } SystemStartup;
        struct {
        } Login;
        struct {
            DWORD       Occurrence;
        } WhenIdle;
    } Parameters;
} HSM_JOB_SCHEDULE, *PHSM_JOB_SCHEDULE;
    
#define INVALID_DWORD_ARG       ((DWORD) -1)
#define INVALID_POINTER_ARG     NULL
#define CLI_ALL_STR             L"*"

#ifdef CLI_IMPL
#define CLI_EXPORT      __declspec(dllexport)
#else
#define CLI_EXPORT      __declspec(dllimport)
#endif

CLI_EXPORT HRESULT
AdminSet(
   IN DWORD RecallLimit,
   IN DWORD AdminExempt,
   IN DWORD MediaCopies,
   IN DWORD Concurrency,
   IN PVOID Schedule
);
          

CLI_EXPORT HRESULT
AdminShow(
   IN BOOL RecallLimit,
   IN BOOL AdminExempt,
   IN BOOL MediaCopies,
   IN BOOL Concurrency,
   IN BOOL Schedule,
   IN BOOL General,
   IN BOOL Manageables,
   IN BOOL Managed,
   IN BOOL Media
);

CLI_EXPORT HRESULT
AdminJob(
   IN BOOL Enable
);

CLI_EXPORT HRESULT
VolumeManage(
   IN LPWSTR *Volumes,
   IN DWORD  NumberOfVolumes,
   IN DWORD  Dfs,
   IN DWORD  Size,
   IN DWORD  Access,
   IN LPWSTR RulePath,
   IN LPWSTR RuleFileSpec,
   IN BOOL   Include,
   IN BOOL   Recursive
);

CLI_EXPORT HRESULT
VolumeUnmanage(
   IN LPWSTR *Volumes,
   IN DWORD  NumberOfVolumes,
   IN BOOL   Full
);

CLI_EXPORT HRESULT
VolumeSet(
   IN LPWSTR *Volumes,
   IN DWORD  NumberOfVolumes,
   IN DWORD  Dfs,
   IN DWORD  Size,
   IN DWORD  Access,
   IN LPWSTR RulePath,
   IN LPWSTR RuleFileSpec,
   IN BOOL   Include,
   IN BOOL   Recursive
);

CLI_EXPORT HRESULT
VolumeShow(
   IN LPWSTR *Volumes,
   IN DWORD  NumberOfVolumes,
   IN BOOL   Dfs, 
   IN BOOL   Size,
   IN BOOL   Access,
   IN BOOL   Rules,
   IN BOOL   Statistics
);

CLI_EXPORT HRESULT
VolumeDeleteRule(
   IN LPWSTR *Volumes,
   IN DWORD  NumberOfVolumes,
   IN LPWSTR RulePath,
   IN LPWSTR RuleFileSpec
);

CLI_EXPORT HRESULT
VolumeJob(
   IN LPWSTR *Volumes,
   IN DWORD  NumberOfVolumes,
   IN HSM_JOB_TYPE Job,
   IN BOOL  RunOrCancel,
   IN BOOL  Synchronous
);  

CLI_EXPORT HRESULT
FileRecall(
   IN LPWSTR *FileSpecs,
   IN DWORD NumberOfFileSpecs
);

CLI_EXPORT HRESULT
MediaSynchronize(
   IN DWORD CopySetNumber,
   IN BOOL  Synchronous
);

CLI_EXPORT HRESULT
MediaRecreateMaster(
   IN LPWSTR MediaName,
   IN DWORD  CopySetNumber,
   IN BOOL   Synchronous
);

CLI_EXPORT HRESULT
MediaDelete(
   IN LPWSTR *MediaNames,
   IN DWORD  NumberOfMedia,
   IN DWORD  CopySetNumber
);

CLI_EXPORT HRESULT
MediaShow(
   IN LPWSTR *MediaNames,
   IN DWORD  NumberOfMedia,
   IN BOOL   Name,
   IN BOOL   Status,
   IN BOOL   Capacity,
   IN BOOL   FreeSpace,
   IN BOOL   Version,
   IN BOOL   Copies
);

#ifdef __cplusplus
}
#endif

#endif // _RSCLI_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\inc\fsantfy.h ===
#ifndef _FSANTFY_
#define _FSANTFY_

// fsantfy.h
//
// This header file has the definitions needed for recall notification
//

//
// The name of the mailslot, created by the client, that notification messages are sent to
//
#define WSB_MAILSLOT_NAME       L"HSM_MAILSLOT"

//
// The following messages will be sent between the FSA and the recall notification client
//
//
// Request to identify yourself
//
typedef struct wsb_identify_req {
WCHAR           fsaName[MAX_COMPUTERNAME_LENGTH + 1];       // Name of machine that FSA is on
ULONG           holdOff;                                    // Wait period before attempting ID response (milliseconds)
} WSB_IDENTIFY_REQ, *PWSB_IDENTIFY_REQ;


//
// Recall notification message
//
typedef struct wsb_notify_recall {
WCHAR           fsaName[MAX_COMPUTERNAME_LENGTH + 1];   // Name of server the FSA is on
LONGLONG        fileSize;                               // Size of file being recalled
HSM_JOB_STATE   state;                                  // Job state 
GUID            identifier;                             // ID of this recall
//
// TBD - need more information here (or make them get it via recall object) ??
//
} WSB_NOTIFY_RECALL, *PWSB_NOTIFY_RECALL;

typedef union wsb_msg {
WSB_IDENTIFY_REQ        idrq;
WSB_NOTIFY_RECALL       ntfy;
} WSB_MSG, *PWSB_MSG;

typedef struct wsb_mailslot_msg {
ULONG           msgType;
ULONG           msgCount;
WSB_MSG         msg;
} WSB_MAILSLOT_MSG, *PWSB_MAILSLOT_MSG;

//
// msgType values
//

#define WSB_MSG_IDENTIFY        1
#define WSB_MSG_NOTIFY          2

//
// Holdoff increment (milliseconds)
//
#define WSB_HOLDOFF_INCREMENT   300

//
// The following message is sent by the notification client via a named pipe 
// in response to a identification request.
//
typedef struct wsb_identify_rep {
WCHAR           clientName[MAX_COMPUTERNAME_LENGTH + 1];    // Name of server that notification client is on
} WSB_IDENTIFY_REP, *PWSB_IDENTIFY_REP;


typedef union wsb_pmsg {
WSB_IDENTIFY_REP        idrp;
} WSB_PMSG, *PWSB_PMSG;

typedef struct wsb_pipe_msg {
ULONG           msgType;
WSB_PMSG        msg;
} WSB_PIPE_MSG, *PWSB_PIPE_MSG;

//
// msgType values
//

#define WSB_PMSG_IDENTIFY       1


//
// FSA pipe name used for identification response
//
#define WSB_PIPE_NAME   L"HSM_PIPE"
//
// Pipe defines
//
#define     WSB_MAX_PIPES       PIPE_UNLIMITED_INSTANCES
#define     WSB_PIPE_BUFF_SIZE  sizeof(WSB_PIPE_MSG)
#define     WSB_PIPE_TIME_OUT   5000



#endif // _FSANTFY_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\inc\mll.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    Mll.h

Abstract:

    RemoteStorage Media Label Library defines

Author:

    Brian Dodd          [brian]         09-Jun-1997

Revision History:

--*/

#ifndef _MLL_H
#define _MLL_H

#include <ntmsmli.h>
#include <tchar.h>
#include "resource.h"

#ifdef __cplusplus
extern "C" {
#endif  /* __cplusplus */

#ifdef MLL_IMPL
#define MLL_API __declspec(dllexport)
#else
#define MLL_API __declspec(dllimport)
#endif

// Defines for media label identification
#define REMOTE_STORAGE_MLL_SOFTWARE_NAME         L"Remote Storage version 6.0"
#define REMOTE_STORAGE_MLL_SOFTWARE_NAME_SIZE    wcslen(REMOTE_STORAGE_MLL_SOFTWARE_NAME)

// API prototypes
MLL_API DWORD ClaimMediaLabel(const BYTE * const pBuffer,
                              const DWORD nBufferSize,
                              MediaLabelInfo * const pLabelInfo);

MLL_API DWORD MaxMediaLabel (DWORD * const pMaxSize);

#ifdef __cplusplus
}
#endif

#endif // _MLL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\inc\rpdata.h ===
/*++

   (c) 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    RpData.h

Abstract:

    Contains structure definitions for the interface between RsFilter and the Fsa

Environment:

    User and  Kernel mode

--*/

#if !defined (RPDATA_H)

#define  RPDATA_H

/*
 Reparse point information for placeholder files

 The version must be changed whenever the structure of the reparse point
 data has changed.  Initial version is 100
*/

#define RP_VERSION    101


//
// Used to verify that the placeholder data is valid
//
#define RP_GEN_QUALIFIER(hsmData, qual) {UCHAR * __cP;  ULONG __ix;\
__cP = (UCHAR *) &(hsmData)->version;\
(qual) = 0L;\
for (__ix = 0; __ix < sizeof(RP_DATA) - sizeof(ULONG) - sizeof(GUID) ; __ix++){\
qual += (ULONG) *__cP;\
__cP++;}}


//
// Bit flag defined that indicates state of data: Truncated or Premigrated
// Use macros to test the bits.
//
// The following bits are mutually exclusive - if the file is truncated then truncate on close
// or premigrate on close make no sense, and if the file is set to truncate on close it is not
// truncated now and should not be added to the premigrated list on close...
//
   #define RP_FLAG_TRUNCATED            0x00000001  // File is a placeholder
   #define RP_FLAG_TRUNCATE_ON_CLOSE    0x00000002  // Truncate this file when closed   
   #define RP_FLAG_PREMIGRATE_ON_CLOSE 0x00000004   // Add to premigrated list on close
//
// The following flag is never to be written to media.  It is set by the engine after
// the CRC has been calculated and is cleared by the filter.  It is used to indicate that
// it is the engine that is setting the reparse point.
//
   #define RP_FLAG_ENGINE_ORIGINATED    0x80000000

   #define RP_FILE_IS_TRUNCATED( bitFlag )   ( bitFlag & RP_FLAG_TRUNCATED)
   #define RP_FILE_IS_PREMIGRATED( bitFlag ) ( !( bitFlag & RP_FLAG_TRUNCATED ) )
   #define RP_INIT_BITFLAG( bitflag )        ( ( bitflag ) = 0 )
   #define RP_SET_TRUNCATED_BIT( bitflag )   ( ( bitflag ) |= RP_FLAG_TRUNCATED)
   #define RP_CLEAR_TRUNCATED_BIT( bitflag)  ( ( bitflag ) &= ~RP_FLAG_TRUNCATED)

   #define RP_IS_ENGINE_ORIGINATED( bitFlag ) ( ( bitFlag & RP_FLAG_ENGINE_ORIGINATED) )
   #define RP_SET_ORIGINATOR_BIT( bitflag )   ( ( bitflag ) |= RP_FLAG_ENGINE_ORIGINATED)
   #define RP_CLEAR_ORIGINATOR_BIT( bitflag)  ( ( bitflag ) &= ~RP_FLAG_ENGINE_ORIGINATED)

   #define RP_FILE_DO_TRUNCATE_ON_CLOSE( bitFlag )   ( bitFlag & RP_FLAG_TRUNCATE_ON_CLOSE)
   #define RP_SET_TRUNCATE_ON_CLOSE_BIT( bitflag )   ( ( bitflag ) |= RP_FLAG_TRUNCATE_ON_CLOSE)
   #define RP_CLEAR_TRUNCATE_ON_CLOSE_BIT( bitflag)  ( ( bitflag ) &= ~RP_FLAG_TRUNCATE_ON_CLOSE)

   #define RP_FILE_DO_PREMIGRATE_ON_CLOSE( bitFlag )   ( bitFlag & RP_FLAG_PREMIGRATE_ON_CLOSE)
   #define RP_SET_PREMIGRATE_ON_CLOSE_BIT( bitflag )   ( ( bitflag ) |= RP_FLAG_PREMIGRATE_ON_CLOSE)
   #define RP_CLEAR_PREMIGRATE_ON_CLOSE_BIT( bitflag)  ( ( bitflag ) &= ~RP_FLAG_PREMIGRATE_ON_CLOSE)

   #define RP_RESV_SIZE 52

//
// Some important shared limits
//

//
// Number of outstanding IOCTLs FSA has pending with RsFilter used
// for communication. The cost is basically thenon-paged pool that is 
// sizeof(IRP) multiplied by this number 
// (i.e. approx. 100 * RP_MAX_RECALL_BUFFERS is the Non-paged pool outstanding)
//
#define RP_MAX_RECALL_BUFFERS           20  
#define RP_DEFAULT_RUNAWAY_RECALL_LIMIT 60

//
// Placeholder data - all versions unioned together
//
typedef struct _RP_PRIVATE_DATA {
   CHAR           reserved[RP_RESV_SIZE];        // Must be 0
   ULONG          bitFlags;            // bitflags indicating status of the segment
   LARGE_INTEGER  migrationTime;       // When migration occurred
   GUID           hsmId;
   GUID           bagId;
   LARGE_INTEGER  fileStart;
   LARGE_INTEGER  fileSize;
   LARGE_INTEGER  dataStart;
   LARGE_INTEGER  dataSize;
   LARGE_INTEGER  fileVersionId;
   LARGE_INTEGER  verificationData;
   ULONG          verificationType;
   ULONG          recallCount;
   LARGE_INTEGER  recallTime;
   LARGE_INTEGER  dataStreamStart;
   LARGE_INTEGER  dataStreamSize;
   ULONG          dataStream;
   ULONG          dataStreamCRCType;
   LARGE_INTEGER  dataStreamCRC;
} RP_PRIVATE_DATA, *PRP_PRIVATE_DATA;



typedef struct _RP_DATA {
   GUID              vendorId;         // Unique HSM vendor ID -- This is first to match REPARSE_GUID_DATA_BUFFER
   ULONG             qualifier;        // Used to checksum the data
   ULONG             version;          // Version of the structure
   ULONG             globalBitFlags;   // bitflags indicating status of the file
   ULONG             numPrivateData;   // number of private data entries
   GUID              fileIdentifier;   // Unique file ID
   RP_PRIVATE_DATA   data;             // Vendor specific data
} RP_DATA, *PRP_DATA;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\inc\rpfilt.h ===
/*++

(c) 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    RpFilt.h

Abstract:

  Contains service related definitions for the RsFilter service

Environment:

    Kernel mode


Revision History:


--*/

/*
  Registry defines for RsFilter component.  These are not required but will
  be read if there.                                                        
*/

/* Service configuration information */
//
// Name of the executable
//
#define RSFILTER_APPNAME            "RsFilter"
#define RSFILTER_EXTENSION          ".sys"
#define RSFILTER_FULLPATH           "%SystemRoot%\\System32\\Drivers\\RsFilter.Sys"
//
// Internal name of the service
//
#define RSFILTER_SERVICENAME        "RsFilter"
//
// Displayed name of the service
//
#define RSFILTER_DISPLAYNAME "Remote Storage Recall Support"
//
// List of service dependencies - "dep1\0dep2\0\0"
//
#define RSFILTER_DEPENDENCIES       "\0\0"
//
// Load order group
//
#define RSFILTER_GROUP              "Filter"


LONG RpInstallFilter(
    UCHAR  *machine,    /* I Machine to install on */
    UCHAR  *path,       /* I points to dir with RsFilter.sys */
    LONG  doCopy); /* I TRUE = copy file even if service exists (upgrade) */


LONG RpGetSystemDirectory(
    UCHAR *machine,  /* I machine name */
    UCHAR *sysPath); /* O System root */


LONG RpCheckService(
    UCHAR *machine,      // I Machine name
    UCHAR *serviceName,  // I Service to look for
    UCHAR *path,         // O Path where found
    LONG *isThere);      // O True if the service was there
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\inc\rpfsa.h ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 2001
(c) 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    RpFsa.h

Abstract:

    Contains function declarations and structures for the File System Filter for Remote Storage

Author:

    Rick Winter

Environment:

    Kernel mode


Revision History:

	X-13	108353		Michael C. Johnson		 3-May-2001
		When checking a file to determine the type of recall also
		check a the potential target disk to see whether or not
		it is writable. This is necessary now that we have read-only
		NTFS volumes.

	X-12	365077		Michael C. Johnson		 1-May-2001
		Revert to previous form of RsOpenTarget() with extra access
		parameter to allow us to apply the desired access bypassing 
		the access check.

	X-11	194325		Michael C. Johnson		 1-Mar-2001
		Clean up RsMountCompletion() and RsLoadFsCompletion() to 
		ensure they don't call routines such as IoDeleteDevice()
		if not running at PASSIVE_LEVEL.

		Add in memory trace mechanism in preparation for attempts
		to flush out lingering reparse point deletion troubles.


	X-10	326345		Michael C. Johnson		26-Feb-2001
		Only send a single RP_RECALL_WAITING to the fsa on any one
		file object. Use the new flag RP_NOTIFICATION_SENT to record 
		when notification has been done.



--*/


/* Defines */

// memory allocation Tags for debug usage
#define    RP_RQ_TAG    'SFSR'    // Recall queue
#define    RP_FN_TAG    'NFSR'    // File name cache
#define    RP_SE_TAG    'ESSR'    // Security info
#define    RP_WQ_TAG    'QWSR'    // Work queue
#define    RP_QI_TAG    'IQSR'    // Work Q info
#define    RP_LT_TAG    'TLSR'    // Long term memory
#define    RP_IO_TAG    'OISR'    // IOCTL queue
#define    RP_FO_TAG    'OFSR'    // File Object Queue
#define    RP_VO_TAG    'OVSR'    // Validate Queue
#define    RP_ER_TAG    'RESR'    // Error log data
#define    RP_CC_TAG    'CCSR'    // Cache buffers
#define    RP_US_TAG    'SUSR'    // Usn record
#define    RP_CX_TAG    'CCSR'    // Completion context
#define    RP_TC_TAG    'CTSR'    // Trace control block
#define    RP_TE_TAG    'ETSR'    // Trace entry buffer
#define    RP_RD_TAG    'DRSR'    // Root directory path



//
// Device extension for the RsFilter device object
//
typedef enum _RP_VOLUME_WRITE_STATUS {
    RsVolumeStatusUnknown = 0,		// No attempt has been made to determine volume writeability 
					// or attempt to determine volume writeability failed
    RsVolumeStatusReadOnly,		// volume is readonly
    RsVolumeStatusReadWrite		// Volume is writeable
} RP_VOLUME_WRITE_STATUS;

typedef struct _DEVICE_EXTENSION {
   CSHORT Type;
   CSHORT Size;
   PDEVICE_OBJECT FileSystemDeviceObject;

   PDEVICE_OBJECT RealDeviceObject;

   BOOLEAN Attached;

   BOOLEAN AttachedToNtfsControlDevice;

   volatile RP_VOLUME_WRITE_STATUS WriteStatus;

} DEVICE_EXTENSION, *PDEVICE_EXTENSION;


#define RSFILTER_PARAMS_KEY            L"RsFilter\\Parameters"
#define RS_TRACE_LEVEL_VALUE_NAME      L"TraceLevel"
#define RS_TRACE_LEVEL_DEFAULT         0


extern PDEVICE_OBJECT FsDeviceObject;


// Fsa validate job registry entry location

#define FSA_VALIDATE_LOG_KEY_NAME L"\\Registry\\Machine\\SYSTEM\\CurrentControlSet\\Services\\Remote_Storage_File_System_Agent\\Validate"

#define  FT_VOL_LEN  32

/* First guess at device name length */
#define     AV_DEV_OBJ_NAME_SIZE    (40 * sizeof(wchar_t))

/* Space for a NULL and a delimiter */
#define     AV_NAME_OVERHEAD        (2 * sizeof(wchar_t))

#define RP_NTFS_NAME L"\\FileSystem\\NTFS"

// FILE_HSM_ACTION_ACCESS is any access that requires HSM action (delete or recall or both)

#ifdef WHEN_WE_HANDLE_DELETE
   #define FILE_HSM_ACTION_ACCESS (FILE_READ_DATA | FILE_WRITE_DATA | FILE_EXECUTE | DELETE)
#else
   #define FILE_HSM_ACTION_ACCESS (FILE_READ_DATA | FILE_WRITE_DATA | FILE_EXECUTE)
#endif

/* FILE_HSM_RECALL_ACCESS is any access that allows the data to be read. */

#define FILE_HSM_RECALL_ACCESS (FILE_READ_DATA | FILE_WRITE_DATA | FILE_EXECUTE)

//
// Timeout and retry values when waiting for the FSA to issue an IOCTL
// Represents the amount of time - under multiple concurrent recall situations -
// that an app will have to wait before the i/o it issued completes with
// STATUS_FILE_IS_OFFLINE because RsFilter couldn't get any IOCTLs to 
// communicate with the FSA
//
#define RP_WAIT_FOR_FSA_IO_TIMEOUT        -((LONGLONG) 4800000000) // 8 minutes

/* Module ID defines for error/event logging */

#define AV_MODULE_RPFILTER    1
#define AV_MODULE_RPFILFUN    2
#define AV_MODULE_RPSEC       3
#define AV_MODULE_RPZW        4
#define AV_MODULE_RPCACHE     5

#define AV_BUFFER_SIZE 1024


#ifndef BooleanFlagOn
#define BooleanFlagOn(F,SF) ( (BOOLEAN)(((F) & (SF)) != 0) )
#endif


#define AV_FT_TICKS_PER_SECOND      ((LONGLONG) 10000000)
#define AV_FT_TICKS_PER_MINUTE      ((LONGLONG) ((LONGLONG) 60  * AV_FT_TICKS_PER_SECOND))
#define AV_FT_TICKS_PER_HOUR        ((LONGLONG) ((LONGLONG) 60  * AV_FT_TICKS_PER_MINUTE))


//
// The filter ID tracks recalls and no-recalls as follows:
// The id is a longlong where the highest order bit identifies the type of recall
// (no-recall or recall).  The remaining part of the high order long identifies the
// read RP_IRP_QUEUE entry (for no-recall) or the file object entry (for recall).
// The lower long identifies the file context entry.
//

#define    RP_TYPE_RECALL       (ULONGLONG) 0x8000000000000000
#define    RP_CONTEXT_MASK      (ULONGLONG) 0x00000000ffffffff
#define    RP_READ_MASK         0x7fffffff
#define    RP_FILE_MASK         (ULONGLONG) 0xffffffff00000000

typedef struct _RP_CREATE_INFO {
   PIRP                        irp;
   PIO_STACK_LOCATION          irpSp;
   POBJECT_NAME_INFORMATION    str;
   ULONG                       options;
   //
   // Reparse point data
   //
   RP_DATA                     rpData;
   LONGLONG                    fileId;
   LONGLONG                    objIdHi;
   LONGLONG                    objIdLo;
   ULONG                       serial;
   ULONG                       action;
   ULONG                       desiredAccess;
} RP_CREATE_INFO, *PRP_CREATE_INFO;


typedef struct _RP_PENDING_CREATE {
   //
   // Filter id
   //
   ULONGLONG     filterId;
   //
   //
   //
   PRP_CREATE_INFO  qInfo;
   //
   // Event used to signal irp completion
   //
   KEVENT        irpCompleteEvent;
   //
   // File object for irp
   //
   PFILE_OBJECT  fileObject;
   //
   // Device object for irp
   //
   PDEVICE_OBJECT  deviceObject;
   //
   // Open options
   //
   ULONG         options;


   //
   // Indicates if oplocks should not be granted (to CI for instance..)
   //
#define RP_PENDING_NO_OPLOCK        0x1
   //
   // Indicates if IRP should be sent down again
   //
#define RP_PENDING_RESEND_IRP       0x2
   //
   // Indicates if we should wait for irp to complete
   //
#define RP_PENDING_WAIT_FOR_EVENT   0x4
   //
   //  Indicates if this is a recall
   //
#define RP_PENDING_IS_RECALL        0x8
   //
   //  Indicates if we should reset the offline attribute of the file
   //
#define RP_PENDING_RESET_OFFLINE    0x10
   ULONG         flags;
} RP_PENDING_CREATE, *PRP_PENDING_CREATE;


#define RP_IRP_NO_RECALL                1

typedef struct _RP_IRP_QUEUE {
   LIST_ENTRY      list;
   PIRP            irp;
   PDEVICE_EXTENSION deviceExtension;
   ULONG           flags;
   //
   // For regular read and write, offset and length
   // denote the offset and length within the file
   // For no-recall reads, offset and length would
   // denote the offset/length within the cacheBuffer
   //
   ULONGLONG       offset;
   ULONGLONG       length;
   //
   // These fields are used only for no-recall reads
   // filterId for no-recall (see filterid description)
   ULONGLONG       readId;
   ULONGLONG       recallOffset;
   ULONGLONG       recallLength;
   //
   // User buffer for data from read-no-recall
   // 
   PVOID           userBuffer; 
   //
   // Cache block buffer for no recall data
   //
   PVOID           cacheBuffer;
} RP_IRP_QUEUE, *PRP_IRP_QUEUE;

//
// Structure tracking the no-recall master IRP and associated irps
//
typedef struct _RP_NO_RECALL_MASTER_IRP {
   LIST_ENTRY AssocIrps;
   PIRP       MasterIrp;
} RP_NO_RECALL_MASTER_IRP, *PRP_NO_RECALL_MASTER_IRP;

//
// User security info structure: this is required for HSM 
// to do the pop-up for clients indicating the file is being recalled
//
typedef struct _RP_USER_SECURITY_INFO {
   //
   // Sid info
   //
   PCHAR                       userInfo;
   ULONG                       userInfoLen;
   LUID                        userAuthentication;
   LUID                        userInstance;
   LUID                        tokenSourceId;
   //
   // Token source info for user
   //
   CHAR                        tokenSource[TOKEN_SOURCE_LENGTH];
   //
   // Indicates if this was opened by user with admin privileges
   //
   BOOLEAN                     isAdmin;
   //
   // Indicates if this is a local proc
   //
   BOOLEAN                     localProc;

} RP_USER_SECURITY_INFO, *PRP_USER_SECURITY_INFO;

//
// Associated macro for above
//
#define RsFreeUserSecurityInfo(UserSecurityInfo)           {    \
    if (UserSecurityInfo) {                                     \
        if (UserSecurityInfo->userInfo) {                       \
            ExFreePool(UserSecurityInfo->userInfo);             \
        }                                                       \
        ExFreePool(UserSecurityInfo);                           \
    }                                                           \
}

//
// The file object entry keeps track of an open instance of a file.
// For each NTFS file object there is one of these (if the file has an HSM tag)
// This structure points to a FS_CONTEXT entry for which there is one for each file.
// For instance if 3 clients open \\server\share\foo there will be 3 file object
// structures and they will all point to the same FS_CONTEXT structure.
//
// The file objects we are tracking will have a pointer to one of there structures attached via
// FsRtlInsertFilterContext.  From there one can find the file context entry via the pointer to it.
//
typedef struct _RP_FILE_OBJ {
   //
   // Link to next file object
   //
   LIST_ENTRY                  list;
   //
   // File object itself
   //
   PFILE_OBJECT                fileObj;
   //
   // Device object
   //
   PDEVICE_OBJECT              devObj;
   //
   // Pointer to the RP_FILE_CONTEXT entry - there's one such entry for every *file*
   //
   PVOID                       fsContext;
   //
   // Resource protecting this entry
   //
   ERESOURCE                   resource;
   //
   // Spin lock protecting read/write IRP queues
   //
   KSPIN_LOCK                  qLock;
   //
   // Pending read IRP queue
   //
   LIST_ENTRY                  readQueue;
   //
   // Pending write IRP queue
   //
   LIST_ENTRY                  writeQueue;
   //
   // File create options specified when opening it
   //
   ULONG                       openOptions;
   //
   // File desired access spcecified when opening it
   //
   ULONG                       desiredAccess;
   //
   // Flags (descriptions below)
   //
   ULONG                       flags;
   //
   // Object id
   //
   LONGLONG                    objIdHi;
   LONGLONG                    objIdLo;
   //
   // File Id if available
   //
   LONGLONG                    fileId;
   //
   // Unique ID we generate for the file object
   //
   ULONGLONG                   filterId;
   //
   // Recall action flags (see rpio.h - RP_RECALL_ACTION..)
   //
   ULONG                       recallAction;
   PRP_USER_SECURITY_INFO      userSecurityInfo;
}  RP_FILE_OBJ, *PRP_FILE_OBJ;

//
// RP_FILE_OBJ Flags
//
//
// File was not opened for read or write access
//
#define RP_NO_DATA_ACCESS    1
//
// Opener is admin equivalent
//
#define RP_OPEN_BY_ADMIN     2
//
// Opened by local process
//
#define RP_OPEN_LOCAL        4
//
// Recall waiting notification already sent
//
#define RP_NOTIFICATION_SENT 8


//
// Recall state
//
typedef enum _RP_RECALL_STATE {
   RP_RECALL_INVALID   = -1,
   RP_RECALL_NOT_RECALLED,
   RP_RECALL_STARTED,
   RP_RECALL_COMPLETED
} RP_RECALL_STATE, *PRP_RECALL_STATE;

//
// Filter context for RsFilter:
// Since filter contexts are attached to the SCB (stream control block) we need to use
// the instance ID to indicate which file object we are interested in.  We attach this
// structure to and use myFileObjEntry to point to the RP_FILE_OBJ struct that
// represents this file object.
//
typedef struct _RP_FILTER_CONTEXT {
   FSRTL_PER_STREAM_CONTEXT       context;
   PVOID                          myFileObjEntry;
} RP_FILTER_CONTEXT, *PRP_FILTER_CONTEXT;

//
// File context: one per *file*
//
typedef struct _RP_FILE_CONTEXT {
   //
   // Links to next/prev file (hanging off RsFileObjQHead)
   //
   LIST_ENTRY                  list;
   //
   // Lock protecting file object queue
   //
   KSPIN_LOCK                  qLock;
   //
   // Queue of all related file object entries
   //
   LIST_ENTRY                  fileObjects;
   //
   // Recalled data is written using this file object
   //
   PFILE_OBJECT                fileObjectToWrite;
   //
   // Handle for the file object we use to write to
   //
   HANDLE                      handle;

   PDEVICE_OBJECT              devObj;

   PDEVICE_OBJECT              FilterDeviceObject;

   //
   // Unicode name of file
   //
   POBJECT_NAME_INFORMATION    uniName;
   //
   // From the file object - unique file identifier
   //
   PVOID                       fsContext;
   //
   // Buffer to write out to file
   //
   PVOID                       nextWriteBuffer;
   //
   // Size of next write to the file  (of recall data)
   //
   ULONG                       nextWriteSize;
   //
   // Lock protecting this entry
   //
   ERESOURCE                   resource;
   //
   // This notification event is signalled when recall completes for this file
   //
   KEVENT                      recallCompletedEvent;
   //
   // File id if available
   //
   LONGLONG                    fileId;
   //
   // Size in bytes of  recall needed
   //
   LARGE_INTEGER               recallSize;
   //
   // All bytes up to this offset have been recalled
   //
   LARGE_INTEGER               currentOffset;
   //
   // Lower half of filter id (unique per file)
   //
   ULONGLONG                   filterId;
   //
   // Volume serial number
   //
   ULONG                       serial;
   //
   // If the recall is complete this is the status
   //
   NTSTATUS                    recallStatus;
   //
   // Recall state
   //
   RP_RECALL_STATE             state;
   //
   // Flags (see below for description)
   //
   ULONG                       flags;
   //
   // Reference count for the file context
   //
   ULONG                       refCount;
   //
   // Usn of the file
   //
   USN                         usn;
   //
   // Tracks create section lock
   //
   LONG                        createSectionLock;
   //
   // Reparse point data
   //
   RP_DATA                     rpData;

} RP_FILE_CONTEXT, *PRP_FILE_CONTEXT;

//
// RP_FILE_CONTEXT Flags
//
// We have seen a write to this file
#define RP_FILE_WAS_WRITTEN                  1
#define RP_FILE_INITIALIZED                  2
#define RP_FILE_REPARSE_POINT_DELETED        4

/*++

VOID
RsInitializeFileContextQueueLock()

Routine Description

Initializes lock guarding the file context queue

Arguments

none

Return Value

none

--*/
#define RsInitializeFileContextQueueLock()  {             \
        DebugTrace((DPFLTR_RSFILTER_ID, DBG_LOCK,"RsFilter: RsInitializeFileContextQueueLock.\n"));\
        ExInitializeFastMutex(&RsFileContextQueueLock);      \
}

/*++

VOID
RsAcquireFileContextQueueLock()

Routine Description

Acquire lock guarding  the file context queue

Arguments

none

Return Value

none

--*/
#define RsAcquireFileContextQueueLock()  {                \
        ExAcquireFastMutex(&RsFileContextQueueLock);      \
        DebugTrace((DPFLTR_RSFILTER_ID, DBG_LOCK, "RsFilter: RsAcquireFileContextQueueLock.\n"));\
}

/*++

VOID
RsReleaseFileContextQueueLock()

Routine Description

Release lock guarding  the file context queue

Arguments

none

Return Value

none

--*/
#define RsReleaseFileContextQueueLock()  {                \
        DebugTrace((DPFLTR_RSFILTER_ID,DBG_LOCK, "RsFilter: RsReleaseFileContextQueueLock.\n"));\
        ExReleaseFastMutex(&RsFileContextQueueLock);      \
}



/*++

VOID
RsAcquireFileObjectLockExclusive()

Routine Description

Acquire lock guarding a file object entry

Arguments

none

Return Value

none

--*/
#define RsAcquireFileObjectEntryLockExclusive(entry)  {                \
        DebugTrace((DPFLTR_RSFILTER_ID,DBG_LOCK, "RsFilter: RsAcquireFileObjectEntryLockExclusive Waiting (%x).\n", entry));\
        FsRtlEnterFileSystem();                                   \
        ExAcquireResourceExclusiveLite(&(entry)->resource, TRUE); \
        DebugTrace((DPFLTR_RSFILTER_ID,DBG_LOCK, "RsFilter: RsAcquireFileObjectEntryLockExclusive Owned (%x).\n", entry));\
}

/*++
VOID
RsAcquireFileObjectEntryLockShared()

Routine Description

Acquire lock guarding a file object entry

Arguments

none

Return Value

none

--*/
#define RsAcquireFileObjectEntryLockShared(entry)  {                 \
        DebugTrace((DPFLTR_RSFILTER_ID,DBG_LOCK, "RsFilter: RsAcquireFileObjectEntryLockShared Waiting (%x).\n", entry));\
        FsRtlEnterFileSystem();                                      \
        ExAcquireResourceSharedLite(&(entry)->resource, TRUE);       \
        DebugTrace((DPFLTR_RSFILTER_ID,DBG_LOCK, "RsFilter: RsAcquireFileObjectEntryLockShared Owned (%x).\n", entry));\
}

/*++

VOID
RsReleaseFileObjectEntryLock()

Routine Description

Release lock guarding a file object entry

Arguments

none

Return Value

none

--*/
#define RsReleaseFileObjectEntryLock(entry)  {           \
        DebugTrace((DPFLTR_RSFILTER_ID,DBG_LOCK, "RsFilter: RsReleaseFileObjectEntryLock (%x).\n", entry));\
        ExReleaseResourceLite(&(entry)->resource);           \
        FsRtlExitFileSystem();                          \
}


/*++

VOID
RsAcquireFileContextEntryLockExclusive()

Routine Description

Acquire lock guarding a file context entry

Arguments

none

Return Value

none

--*/
#define RsAcquireFileContextEntryLockExclusive(entry)  {                \
        DebugTrace((DPFLTR_RSFILTER_ID,DBG_LOCK, "RsFilter: RsAcquireFileContextEntryLockExclusive Waiting (%x).\n", entry));\
        FsRtlEnterFileSystem();                                   \
        ExAcquireResourceExclusiveLite(&(entry)->resource, TRUE); \
        DebugTrace((DPFLTR_RSFILTER_ID,DBG_LOCK, "RsFilter: RsAcquireFileContextEntryLockExclusive Owned (%x).\n", entry));\
}

/*++

VOID
RsAcquireFileContextEntryLockShared()

Routine Description

Acquire lock guarding a file context entry

Arguments

none

Return Value

none

--*/
#define RsAcquireFileContextEntryLockShared(entry)  {                \
        DebugTrace((DPFLTR_RSFILTER_ID,DBG_LOCK, "RsFilter: RsAcquireFileContextEntryLockShared Waiting (%x).\n", entry));\
        FsRtlEnterFileSystem();                                      \
        ExAcquireResourceSharedLite(&(entry)->resource, TRUE);       \
        DebugTrace((DPFLTR_RSFILTER_ID,DBG_LOCK, "RsFilter: RsAcquireFileContextEntryLockShared Owned (%x).\n", entry));\
}

/*++

VOID
RsReleaseFileContextEntryLock()

Routine Description

Release lock guarding a file context entry

Arguments

none

Return Value

none

--*/
#define RsReleaseFileContextEntryLock(entry)  {           \
        DebugTrace((DPFLTR_RSFILTER_ID,DBG_LOCK, "RsFilter: RsReleaseFileContextEntryLock. (%x)\n", entry));\
        ExReleaseResourceLite(&(entry)->resource);            \
        FsRtlExitFileSystem();                           \
}

/*++

VOID
RsGetValidateLock(PKIRQL irql)

Routine Description:

   Get a lock on the validate queue

Arguments:
   Place to save irql

Return Value:
    None

--*/
#define RsGetValidateLock(irql)  ExAcquireSpinLock(&RsValidateQueueLock, irql)

/*++

VOID
RsPutValidateLock(KIRQL oldIrql)

Routine Description:

   Free a lock on the validate queue

Arguments:
   Saved irql

Return Value:
    None

--*/

#define RsPutValidateLock(oldIrql)  ExReleaseSpinLock(&RsValidateQueueLock, oldIrql)

/*++

VOID
RsGetIoLock(PKIRQL irql)

Routine Description:

    Lock the IO queue

Arguments:

    Variable to receive current irql

Return Value:

    0

Note:

--*/

#define RsGetIoLock(irql)   ExAcquireSpinLock(&RsIoQueueLock, irql)

/*++

VOID
RsPutIoLock(KIRQL oldIrql)

Routine Description:

    Unlock the IO queue

Arguments:

    oldIrql - Saved irql

Return Value:

    0

Note:

--*/

#define RsPutIoLock(oldIrql)   ExReleaseSpinLock(&RsIoQueueLock, oldIrql)

#define RP_IS_NO_RECALL_OPTION(OpenOptions) \
      (RsNoRecallDefault?!((OpenOptions) & FILE_OPEN_NO_RECALL) : ((OpenOptions) & FILE_OPEN_NO_RECALL))

#define RP_SET_NO_RECALL_OPTION(OpenOptions)   \
      (RsNoRecallDefault ? ((OpenOptions) &=  ~FILE_OPEN_NO_RECALL):((OpenOptions) |= FILE_OPEN_NO_RECALL))

#define RP_RESET_NO_RECALL_OPTION(OpenOptions) \
      (RsNoRecallDefault ?((OpenOptions) |=  FILE_OPEN_NO_RECALL) : ((OpenOptions) &= ~FILE_OPEN_NO_RECALL))


#define RP_IS_NO_RECALL(Entry)                           \
       (RP_IS_NO_RECALL_OPTION((Entry)->openOptions) && !(((PRP_FILE_CONTEXT) (Entry)->fsContext)->flags & RP_FILE_WAS_WRITTEN))

#define RP_SET_NO_RECALL(Entry)                          \
         RP_SET_NO_RECALL_OPTION((Entry)->openOptions)

#define RP_RESET_NO_RECALL(Entry)                        \
        RP_RESET_NO_RECALL_OPTION(Entry->openOptions)


typedef struct _RP_VALIDATE_INFO {
   LIST_ENTRY                 list;
   LARGE_INTEGER              lastSetTime;    // Last time a RP was set.
   ULONG                      serial;         // Volume serial number
} RP_VALIDATE_INFO, *PRP_VALIDATE_INFO;

typedef struct _AV_ERR {
   ULONG   line;
   ULONG   file;
   ULONG   code;
   WCHAR   string[1];  /* Actual size will vary */
} AV_ERR, *PAV_ERR;

//
// Possible create flags:
//
#define SF_FILE_CREATE_PATH     1
#define SF_FILE_CREATE_ID       2
#define SF_FILE_READ            3


typedef enum _RP_FILE_BUF_STATE {
    RP_FILE_BUF_INVALID=0,
    RP_FILE_BUF_IO,
    RP_FILE_BUF_VALID,
    RP_FILE_BUF_ERROR
} RP_FILE_BUF_STATE, *PRP_FILE_BUF_STATE;

//
// Define the cache buffer structure
//
typedef struct _RP_FILE_BUF {
   //
   // IRPs waiting on this block
   //
   LIST_ENTRY   WaitQueue;
   //
   // Volume serial number for the volume on which the file
   // this block maps to resides
   //
   ULONG      VolumeSerial;
   //
   // File id uniquely indicating which file this block
   // belongs to
   //
   ULONGLONG   FileId;
   //
   // Block number this buffer maps to
   //
   ULONGLONG   Block;
   //
   // Lock for the buffer
   //
   ERESOURCE   Lock;
   //
   // Links in the hash queue this buffer belongs
   //
   LIST_ENTRY  BucketLinks;
   //
   // Links in the lru  list
   //
   LIST_ENTRY  LruLinks;
   //
   // Indicates the current buffer state
   //
   RP_FILE_BUF_STATE  State;
   //
   // If i/o completed with errors, this is useful
   //
   NTSTATUS    IoStatus;
   //
   // Actual buffer contents themselves
   //
   PUCHAR       Data;
   //
   // Usn used to validate block
   //
   LONGLONG     Usn;

} RP_FILE_BUF, *PRP_FILE_BUF;

//
// The hash bucket structure
//
typedef struct _RP_CACHE_BUCKET {
   //
   // Link to the head of the entries in this bucket
   //
   LIST_ENTRY FileBufHead;

} RP_CACHE_BUCKET, *PRP_CACHE_BUCKET;

//
// Cache LRU structure
//
typedef struct _RP_CACHE_LRU {
    //
    // Pointer to head of LRU
    //
    LIST_ENTRY FileBufHead;
    //
    // Lock structure for protecting the LRU
    //
    FAST_MUTEX Lock;
    //
    // Total number of buffers in the cache
    //
    //
    ULONG   TotalCount;
    //
    // Number of buffers in LRU (just for bookkeeping)
    //
    ULONG   LruCount;
    //
    // Counting semaphore used to signal availability (and number)
    // of buffers in LRU
    //
    KSEMAPHORE AvailableSemaphore;

} RP_CACHE_LRU, *PRP_CACHE_LRU;




//
// Completion Context used by Mount and LoadFs completion routines.
//

typedef struct _RP_COMPLETION_CONTEXT {
    LIST_ENTRY		        leQueueHead;
    PIO_WORKITEM		pIoWorkItem;
    PIRP			pIrp;
    PIO_WORKITEM_ROUTINE	prtnWorkItemRoutine;
    union {
        struct {
            PVPB		pvpbOriginalVpb;
            PDEVICE_OBJECT	pdoRealDevice;
            PDEVICE_OBJECT	pdoNewFilterDevice;
        } Mount;

        struct {
            PVOID               pvDummy;
        } LoadFs;
    } Parameters;
} RP_COMPLETION_CONTEXT, *PRP_COMPLETION_CONTEXT;


//
// Some utility macros
//

#define MAX(a,b) ((a) > (b) ? (a) : (b))
#define MIN(a,b) ((a) > (b) ? (b) : (a))

//
// Debug support
//
#define DBG_INFO        DPFLTR_INFO_LEVEL
#define DBG_ERROR       DPFLTR_ERROR_LEVEL
#define DBG_VERBOSE     DPFLTR_TRACE_LEVEL
#define DBG_LOCK        DPFLTR_TRACE_LEVEL

#define DebugTrace(MSG)  DbgPrintEx MSG                              


//
// Function prototypes
//


NTSTATUS
RsAddQueue(IN  ULONG          Serial,
           OUT PULONGLONG     RecallId,
           IN  ULONG          OpenOption,
           IN  PFILE_OBJECT   FileObject,
           IN  PDEVICE_OBJECT DevObj,
           IN  PDEVICE_OBJECT FilterDeviceObject,
           IN  PRP_DATA       PhData,
           IN  LARGE_INTEGER  RecallStart,
           IN  LARGE_INTEGER  RecallSize,
           IN  LONGLONG       FileId,
           IN  LONGLONG       ObjIdHi,
           IN  LONGLONG       ObjIdLo,
           IN  ULONG          DesiredAccess,
           IN  PRP_USER_SECURITY_INFO UserSecurityInfo);

NTSTATUS
RsAddFileObj(IN PFILE_OBJECT   fileObj,
             IN PDEVICE_OBJECT FilterDeviceObject,
             IN RP_DATA        *phData,
             IN ULONG          openOption);


NTSTATUS
RsQueueCancel(IN ULONGLONG filterId);

NTSTATUS
RsMakeContext(IN PFILE_OBJECT fileObj,
              OUT PRP_FILE_CONTEXT *context);

NTSTATUS
RsReleaseFileContext(IN PRP_FILE_CONTEXT context);

NTSTATUS
RsFreeFileObject(IN PLIST_ENTRY FilterContext);

PRP_FILE_CONTEXT
RsAcquireFileContext(IN ULONGLONG FilterId,
                     IN BOOLEAN   Exclusive);

VOID
RsReleaseFileObject(IN PRP_FILE_OBJ entry);

NTSTATUS
RsGenerateDevicePath(IN PDEVICE_OBJECT deviceObject,
                     OUT POBJECT_NAME_INFORMATION *nameInfo
                    );

NTSTATUS
RsGenerateFullPath(IN POBJECT_NAME_INFORMATION fileName,
                   IN PDEVICE_OBJECT deviceObject,
                   OUT POBJECT_NAME_INFORMATION *nameInfo
                  );

ULONG
RsRemoveQueue(IN PFILE_OBJECT fileObj);

NTSTATUS
RsCompleteRecall(IN PDEVICE_OBJECT DeviceObject,
                 IN ULONGLONG FilterId,
                 IN NTSTATUS  Status,
                 IN ULONG     RecallAction,
                 IN BOOLEAN   CancellableRead);

NTSTATUS
RsCompleteReads(IN PRP_FILE_CONTEXT Context);


NTSTATUS
RsPreserveDates(IN PRP_FILE_CONTEXT Context);

NTSTATUS
RsMarkUsn(IN PRP_FILE_CONTEXT Context);

NTSTATUS
RsOpenTarget(IN PRP_FILE_CONTEXT  Context,
             IN ULONG             OpenAccess,
	     IN  ULONG            AdditionalAccess,
             OUT HANDLE          *Handle,
             OUT PFILE_OBJECT    *FileObject);


ULONG
RsIsNoRecall(IN  PFILE_OBJECT fileObj,
             OUT PRP_DATA *rpData);

NTSTATUS
RsPartialData(IN PDEVICE_OBJECT   DeviceObject,
              IN ULONGLONG filterId,
              IN NTSTATUS status,
              IN CHAR *buffer,
              IN ULONG bytesRead,
              IN ULONGLONG offset);

NTSTATUS
RsPartialWrite(IN PDEVICE_OBJECT   DeviceObject,
               IN PRP_FILE_CONTEXT Context,
               IN CHAR *Buffer,
               IN ULONG BufLen,
               IN ULONGLONG Offset);

NTSTATUS
RsDoWrite(IN PDEVICE_OBJECT   DeviceObject,
          IN PRP_FILE_CONTEXT Context);


NTSTATUS
RsQueueRecall(IN ULONGLONG filterId,
              IN ULONGLONG recallStart,
              IN ULONGLONG recallSize);


NTSTATUS
RsQueueNoRecall(IN PFILE_OBJECT FileObject,
                IN PIRP      Irp,
                IN ULONGLONG RecallStart,
                IN ULONGLONG RecallSize,
                IN ULONG     BufferOffset,
                IN ULONG     BufferLength,
                IN PRP_FILE_BUF CacheBuffer,
                IN PVOID     UserBuffer);

NTSTATUS
RsQueueNoRecallOpen(IN PRP_FILE_OBJ entry,
                    IN ULONGLONG filterId,
                    IN ULONGLONG offset,
                    IN ULONGLONG size);
NTSTATUS
RsQueueRecallOpen(IN PRP_FILE_CONTEXT Context,
                  IN PRP_FILE_OBJ Entry,
                  IN ULONGLONG FilterId,
                  IN ULONGLONG Offset,
                  IN ULONGLONG Size,
                  IN ULONG     Command);

NTSTATUS
RsGetFileInfo(IN PRP_FILE_OBJ    Entry,
              IN PDEVICE_OBJECT  DeviceObject);

NTSTATUS
RsGetFileId(IN PRP_FILE_OBJ entry,
            IN PDEVICE_OBJECT  DeviceObject);

NTSTATUS
RsGetFileName(IN PRP_FILE_OBJ entry,
              IN PDEVICE_OBJECT  DeviceObject);

NTSTATUS
RsCloseFile(IN ULONGLONG filterId);

NTSTATUS
RsCleanupFileObject(IN ULONGLONG filterId);

NTSTATUS
RsCompleteIrp(
             IN PDEVICE_OBJECT DeviceObject,
             IN PIRP Irp,
             IN PVOID Context);

NTSTATUS
RsCheckRead(IN PIRP irp,
            IN PFILE_OBJECT fileObject,
            IN PDEVICE_EXTENSION deviceExtension);

NTSTATUS
RsCheckWrite(IN PIRP irp,
             IN PFILE_OBJECT fileObject,
             IN PDEVICE_EXTENSION deviceExtension);

NTSTATUS
RsFailAllRequests(IN PRP_FILE_CONTEXT Context,
                  IN BOOLEAN          Norecall);

NTSTATUS
RsCompleteAllRequests(
                     IN PRP_FILE_CONTEXT Context,
                     IN PRP_FILE_OBJ Entry,
                     IN NTSTATUS Status
                     );

NTSTATUS
RsWriteReparsePointData(IN PRP_FILE_CONTEXT Context);

NTSTATUS
RsTruncateFile(IN PRP_FILE_CONTEXT Context);


NTSTATUS
RsSetEndOfFile(IN PRP_FILE_CONTEXT Context,
               IN ULONGLONG size);

BOOLEAN
RsIsFastIoPossible(IN PFILE_OBJECT fileObj);

PIRP
RsGetFsaRequest(VOID);

PRP_FILE_OBJ
RsFindQueue(IN ULONGLONG filterId);


NTSTATUS
RsAddIo(IN PIRP irp);

PIRP
RsRemoveIo(VOID);

VOID
RsCompleteRead(IN PRP_IRP_QUEUE Irp,
               IN BOOLEAN unlock);


BOOLEAN
RsIsFileObj(IN PFILE_OBJECT fileObj,
            IN BOOLEAN      returnContextData,
            OUT PRP_DATA *rpData,
            OUT POBJECT_NAME_INFORMATION *str,
            OUT LONGLONG *fileId,
            OUT LONGLONG *objIdHi,
            OUT LONGLONG *objIdLo,
            OUT ULONG *options,
            OUT ULONGLONG *filterId,
            OUT USN       *usn);

VOID
RsCancelRecalls(VOID);

VOID
RsCancelIo(VOID);

VOID
RsLogValidateNeeded(IN ULONG serial);

BOOLEAN
RsAddValidateObj(IN  ULONG serial,
                 IN  LARGE_INTEGER cTime);
BOOLEAN
RsRemoveValidateObj(IN ULONG serial);

NTSTATUS
RsQueueValidate(IN ULONG serial);

ULONG
RsTerminate(VOID);

NTSTATUS
RsGetRecallInfo(IN OUT PRP_MSG              Msg,
                OUT    PULONG_PTR           InfoSize,
                IN     KPROCESSOR_MODE      RequestorMode);


VOID
RsCancelReadRecall(IN PDEVICE_OBJECT DeviceObject,
                   IN PIRP Irp);
VOID
RsCancelWriteRecall(IN PDEVICE_OBJECT DeviceObject,
                    IN PIRP Irp);

VOID
RsLogError(IN  ULONG line,
           IN  ULONG file,
           IN  ULONG code,
           IN  NTSTATUS ioError,
           IN  PIO_STACK_LOCATION irpSp,
           IN  WCHAR *msgString);



ULONG
RsGetReparseData(IN  PFILE_OBJECT fileObject,
                 IN  PDEVICE_OBJECT deviceObject,
                 OUT PRP_DATA rpData);


NTSTATUS
RsCheckVolumeReadOnly (IN     PDEVICE_OBJECT FilterDeviceObject,
		       IN OUT PBOOLEAN       pbReturnedFlagReadOnly);


NTSTATUS
RsQueryValueKey (
                IN PUNICODE_STRING KeyName,
                IN PUNICODE_STRING ValueName,
                IN OUT PULONG ValueLength,
                IN OUT PKEY_VALUE_FULL_INFORMATION *KeyValueInformation,
                IN OUT PBOOLEAN DeallocateKeyValue);


NTSTATUS
RsCacheInitialize(
 VOID
);

VOID
RsCacheFsaPartialData(
    IN PRP_IRP_QUEUE ReadIo,
    IN PUCHAR        Buffer,
    IN ULONGLONG     Offset,
    IN ULONG     Length,
    IN NTSTATUS  Status
);

VOID
RsCacheFsaIoComplete(
    IN PRP_IRP_QUEUE ReadIo,
    IN NTSTATUS      Status
);

NTSTATUS
RsGetNoRecallData(
      IN PFILE_OBJECT FileObject,
      IN PIRP         Irp,
      IN USN          Usn,
      IN LONGLONG     FileOffset,
      IN LONGLONG     Length,
      IN PUCHAR       UserBuffer
);

LONG
RsExceptionFilter(
    IN WCHAR *FunctionName,
    IN PEXCEPTION_POINTERS ExceptionPointer);

NTSTATUS
RsTruncateOnClose(
    IN PRP_FILE_CONTEXT Context
    );

NTSTATUS
RsSetPremigratedState(IN PRP_FILE_CONTEXT Context);

NTSTATUS
RsDeleteReparsePoint(IN PRP_FILE_CONTEXT Context);
NTSTATUS
RsSetResetAttributes(IN PFILE_OBJECT     FileObject,
                     IN ULONG            SetAttributes,
                     IN ULONG            ResetAttributes);
BOOLEAN
RsSetCancelRoutine(IN PIRP Irp,
                   IN PDRIVER_CANCEL CancelRoutine);
BOOLEAN
RsClearCancelRoutine (
                     IN PIRP Irp
                     );
NTSTATUS
RsGetFileUsn(IN PRP_FILE_CONTEXT Context,
             IN PFILE_OBJECT     FileObject,
             IN PDEVICE_OBJECT   FilterDeviceObject);
VOID
RsInterlockedRemoveEntryList(PLIST_ENTRY Entry,
                             PKSPIN_LOCK Lock);
VOID
RsGetUserInfo(
              IN  PSECURITY_SUBJECT_CONTEXT SubjectContext,
              OUT PRP_USER_SECURITY_INFO    UserSecurityInfo);





typedef enum _RpModuleCode
    {
     ModRpFilter = 100
    ,ModRpFilfun
    ,ModRpCache
    ,ModRpzw
    ,ModRpSec
    } RpModuleCode;

typedef struct _RP_TRACE_ENTRY
    {
    RpModuleCode	ModuleCode;
    USHORT		usLineNumber;
    USHORT		usIrql;
    LARGE_INTEGER	Timestamp;
    ULONG_PTR		Value1;
    ULONG_PTR		Value2;
    ULONG_PTR		Value3;
    ULONG_PTR		Value4;
    } RP_TRACE_ENTRY, *PRP_TRACE_ENTRY;


typedef struct _RP_TRACE_CONTROL_BLOCK
    {
    KSPIN_LOCK		Lock;
    PRP_TRACE_ENTRY	EntryBuffer;
    ULONG		EntryMaximum;
    ULONG		EntryNext;
    } RP_TRACE_CONTROL_BLOCK, *PRP_TRACE_CONTROL_BLOCK;



#define RsTrace0(_ModuleCode)						RsTrace4 ((_ModuleCode), 0,         0,         0,         0)
#define RsTrace1(_ModuleCode, _Value1)					RsTrace4 ((_ModuleCode), (_Value1), 0,         0,         0)
#define RsTrace2(_ModuleCode, _Value1, _Value2)				RsTrace4 ((_ModuleCode), (_Value1), (_Value2), 0,         0)
#define RsTrace3(_ModuleCode, _Value1, _Value2, _Value3)		RsTrace4 ((_ModuleCode), (_Value1), (_Value2), (_Value3), 0)

#if DBG
#define RsTrace4(_ModuleCode, _Value1, _Value2, _Value3, _Value4)	RsTraceAddEntry ((_ModuleCode),			\
											 ((USHORT)(__LINE__)),		\
											 ((ULONG_PTR)(_Value1)),	\
											 ((ULONG_PTR)(_Value2)),	\
											 ((ULONG_PTR)(_Value3)),	\
											 ((ULONG_PTR)(_Value4)))
#else
#define RsTrace4(_ModuleCode, _Value1, _Value2, _Value3, _Value4)
#endif


#if DBG
#define DEFAULT_TRACE_ENTRIES	(0x4000)
#else
#define DEFAULT_TRACE_ENTRIES	(0)
#endif

VOID RsTraceAddEntry (RpModuleCode ModuleCode,
		      USHORT       usLineNumber,
		      ULONG_PTR    Value1,
		      ULONG_PTR    Value2,
		      ULONG_PTR    Value3,
		      ULONG_PTR    Value4);

NTSTATUS RsTraceInitialize (ULONG ulRequestedTraceEntries);

extern PRP_TRACE_CONTROL_BLOCK RsTraceControlBlock;
extern ULONG                   RsDefaultTraceEntries;

NTSTATUS RsLookupContext (PFILE_OBJECT        pFileObject, 
			  PRP_FILE_OBJ       *pReturnedRpFileObject,
			  PRP_FILE_CONTEXT   *pReturnedRpFileContext);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\inc\mover.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    Mover.h

Abstract:

    Data Mover defines

Author:

    Brian Dodd          [brian]         01-Apr-1997

Revision History:

--*/

#ifndef _MVR_
#define _MVR_

// Are we defining imports or exports?
#ifdef MVRDLL
#define MVRAPI  __declspec(dllexport)
#else
#define MVRAPI  __declspec(dllimport)
#endif

#include "Wsb.h"
#include "Rms.h"
#include "MvrLib.h"

////////////////////////////////////////////////////////////////////////////////////////
//
//  Mvr enumerations
//


/*++

Enumeration Name:

    

Description:

    

--*/


////////////////////////////////////////////////////////////////////////////////////////
//
//  MVR defines
//

// Session options

#define MVR_SESSION_APPEND_TO_DATA_SET      0x000000001
#define MVR_SESSION_OVERWRITE_DATA_SET      0x000000002
#define MVR_SESSION_AS_LAST_DATA_SET        0x000000004

#define MVR_SESSION_TYPE_TRANSFER           0x000000010
#define MVR_SESSION_TYPE_COPY               0x000000020
#define MVR_SESSION_TYPE_NORMAL             0x000000040
#define MVR_SESSION_TYPE_DIFFERENTIAL       0x000000080
#define MVR_SESSION_TYPE_INCREMENTAL        0x000000100
#define MVR_SESSION_TYPE_DAILY              0x000000200

#define MVR_SESSION_METADATA                0x000001000

// The following is used to select only
// session type from the session options
#define MVR_SESSION_TYPES (MVR_SESSION_TYPE_TRANSFER     | \
                           MVR_SESSION_TYPE_COPY         | \
                           MVR_SESSION_TYPE_NORMAL       | \
                           MVR_SESSION_TYPE_DIFFERENTIAL | \
                           MVR_SESSION_TYPE_INCREMENTAL  | \
                           MVR_SESSION_TYPE_DAILY)




// Stream modes / StoreData flags

#define MVR_MODE_READ                       0x000000001
#define MVR_MODE_WRITE                      0x000000002
#define MVR_MODE_APPEND                     0x000000004
#define MVR_MODE_RECOVER                    0x000000008
#define MVR_MODE_FORMATTED                  0x000000010
#define MVR_MODE_UNFORMATTED                0x000000020

#define MVR_FLAG_BACKUP_SEMANTICS           0x000000100
#define MVR_FLAG_HSM_SEMANTICS              0x000000200
#define MVR_FLAG_POSIX_SEMANTICS            0x000000400
#define MVR_FLAG_WRITE_PARENT_DIR_INFO      0x000000800
#define MVR_FLAG_COMMIT_FILE                0x000001000
#define MVR_FLAG_NO_CACHING                 0x000002000
#define MVR_FLAG_SAFE_STORAGE               0x000004000


// Verification types

#define MVR_VERIFICATION_TYPE_NONE          0x000000000
#define MVR_VERIFICATION_TYPE_HEADER_CRC    0x000000001
#define MVR_VERIFICATION_TYPE_DATA_CRC      0x000000002
#define MVR_VERIFICATION_TYPE_HEADER_CRC32  0x000000004
#define MVR_VERIFICATION_TYPE_DATA_CRC32    0x000000008




// Duplication options

#define MVR_DUPLICATE_UPDATE                0x000000001
#define MVR_DUPLICATE_REFRESH               0x000000002


// Misc defines
#define MVR_UNDEFINED_STRING                OLESTR("Uninitialized String")
#define MVR_NULL_STRING                     OLESTR("")

#define MVR_RSDATA_PATH                     OLESTR("RSData\\")
#define MVR_LABEL_FILENAME                  OLESTR("MediaLabel")
#define MVR_DATASET_FILETYPE                OLESTR(".bkf")
#define MVR_RECOVERY_FILETYPE               OLESTR(".$")
#define MVR_SAFE_STORAGE_FILETYPE           OLESTR(".bak")
#define MVR_VOLUME_LABEL                    OLESTR("RSS")


/*++

Structure Name:

    MVR_HINTS

Description:

    Structure used to specify a locate of file and unamed data in remote storage.

--*/
typedef struct _MVR_REMOTESTORAGE_HINTS {
    ULARGE_INTEGER  DataSetStart;
    ULARGE_INTEGER  FileStart;
    ULARGE_INTEGER  FileSize;
    ULARGE_INTEGER  DataStart;
    ULARGE_INTEGER  DataSize;
    DWORD           VerificationType;
    ULARGE_INTEGER  VerificationData;
    DWORD           DatastreamCRCType;
    ULARGE_INTEGER  DatastreamCRC;
    ULARGE_INTEGER  FileUSN;
} MVR_REMOTESTORAGE_HINTS, *LP_MVR_REMOTESTORAGE_HINTS;



#endif // _MVR_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\inc\rpio.h ===
/*++

   (c) 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    RpIo.h

Abstract:

    Contains structure definitions for the interface between RsFilter and the Fsa

Author:

    Rick Winter

Environment:

    Kernel mode

Revision History:

	X-10	244816		Michael C. Johnson		 5-Dec-2000
		Change device name from \Device\RsFilter to \FileSystem\Filters\RsFilter

--*/


#define RS_FILTER_DEVICE_NAME       L"\\FileSystem\\Filters\\RsFilter"
#define RS_FILTER_INTERNAL_SYM_LINK L"\\??\\RsFilter"
#define RS_FILTER_SYM_LINK          L"\\\\.\\RsFilter"
#define USER_NAME_LEN      128


// The following messages pass between the WIN32 component (FsAgent)
// and the File System Filter component (RsFilter.sys) via FSCTL calls.
//
// (See ntioapi.h for FSCTL defines FSCTL_HSM_MSG and FSCTL_HSM_DATA)
// 

//
// FSCTL_HSM_MSG
//
// Events are passed to user mode by completing the IRP for a RP_GET_REQUEST with the output buffer 
// containing the event information.  The FsAgent issues several of these and waits for any of them to complete.
//
#define RP_GET_REQUEST           1   

//
// FSCTL_HSM_DATA
//
//
// Signals the completion of the data transfer for a recall.
//
#define RP_RECALL_COMPLETE       3  

//
// FSCTL_HSM_DATA
//
//
// Tells the filter to suspend recall events.  Any file accesses that require offline data will return error.
//
#define RP_SUSPEND_NEW_RECALLS   4  

//
// FSCTL_HSM_DATA
//
//
// Tells the filter to resume recall events
//
#define RP_ALLOW_NEW_RECALLS     5  

//
// FSCTL_HSM_DATA
//
//
// Cancel all active recall requests.  Any pending file io that requires offline data will return error.
//
#define RP_CANCEL_ALL_RECALLS    6  

//
// FSCTL_HSM_DATA
//
//
// Cancel all pending device io requests (RP_GET_REQUEST).
//
#define RP_CANCEL_ALL_DEVICEIO   7  

//
// FSCTL_HSM_DATA
//
//
// Returns variable size information for a recall request such as the file path and user information needed for recall notification.
//
#define RP_GET_RECALL_INFO       8  

//
// FSCTL_HSM_DATA
//
//
// Obosolete
//
#define RP_SET_ADMIN_SID         9  

//
// FSCTL_HSM_DATA
//
//
//  Passes recall data for a portion of a file.  The data will be written to the file or used to complete a read request, depending
//  on the type of recall.
//
#define RP_PARTIAL_DATA          10 

//
// FSCTL_HSM_MSG
//
//
// Returns TRUE if a given file is currently memory mapped.
//
#define RP_CHECK_HANDLE          11 



//
// The following events are sent by the filter to the FSA (by completion of a RP_GET_REQUEST)
//

//
// A file was opened for either a normal or FILE_OPEN_NO_RECALL access
//
#define RP_OPEN_FILE             20    
//
// Offline data is required for this file.  For a normal open this will initiate transfer of the complete file sequentially.  
// If the file was opened with FILE_OPEN_NO_RECALL this indicates the amount of data required and what portion of the file.
//
#define RP_RECALL_FILE           21    
//
// Not used
//
#define RP_CLOSE_FILE            22    
//
// A request for a recall was cancelled.  The data is no longer required.
//
#define RP_CANCEL_RECALL         23    
//
// A validate job should be run because some application other than HSM has written HSM reparse point information.
//
#define RP_RUN_VALIDATE          24    
//
// Not used
//
#define RP_START_NOTIFY          25    
//
// Not used
//
#define RP_END_NOTIFY            26    

//
// Waiting for a recall
//
#define RP_RECALL_WAITING        27    


//
// This information is returned information output buffer for a FSCTL messages issued by the FSA
//

//
// RP_GET_REQUEST
//
// File open event.  Sent when a placeholder is opened or when data is needed for a part of a file opened with FILE_OPEN_NO_RECALL
// Data transfer does not start until _RP_NT_RECALL_REQUEST is sent.
//
// For normal opens this sets up the recall notification information.
//
typedef struct _RP_NT_OPEN_REQ {
   LUID               userAuthentication;           /* Unique to this instance of this user */
   LUID               userInstance;
   LUID               tokenSourceId;
   LARGE_INTEGER      offset;                       /* Offset of data in the target file. */
   LARGE_INTEGER      size;                         /* Number of bytes needed */
   //
   // If the file was opened by ID then it is either the file Id or an object ID.  It is assumed
   // that one or the other will not be NULL.
   //
   LONGLONG           fileId;                        
   LONGLONG           objIdHi;                        
   LONGLONG           objIdLo;
   ULONGLONG          filterId;                     /* Unique ID  (lives while file is open) */
   ULONG              localProc;                    /* True if recall is from local process */
   ULONG              userInfoLen;                  /* Size of SID info in bytes */
   ULONG              isAdmin;                      /* TRUE = user is admin */
   ULONG              nameLen;                      /* Size of file path\name (in CHARacters)*/
   ULONG              options;                      /* Create options */
   ULONG              action;                       /* RP_OPEN or RP_READ_NO_RECALL */
   ULONG              serial;                       /* Serial number of volume */
   RP_DATA            eaData;                       /* PH info from file */
   CHAR               tokenSource[TOKEN_SOURCE_LENGTH]; 
} RP_NT_OPEN_REQ, *PRP_NT_OPEN_REQ;

//
// Not used
//
typedef struct _RP_NT_CLOSE_REQ {
   ULONGLONG          filterId;                     // Unique ID  (lives while file is open) 
   BOOLEAN            wasModified;                  // TRUE if the file was modified by the user.
} RP_NT_CLOSE_REQ, *PRP_NT_CLOSE_REQ;

//
// RP_GET_REQUEST
//
//
// Recall request - for previously opened file.  This initiates the data transfer from secondary
// storage to the file.
//
typedef struct _RP_NT_RECALL_REQ {
   ULONGLONG          filterId;                     // Unique ID passed to FSA by open request. 
   ULONGLONG          offset;                       // Offset to recall from
   ULONGLONG          length;                       // Length of recall
   ULONG              threadId;                     // id of thread causing recall
} RP_NT_RECALL_REQ, *PRP_NT_RECALL_REQ;

//
// Not used - Start recall notification for this user.
//
typedef struct _RP_NT_START_NOTIFY {
   ULONGLONG          filterId;                     // Unique ID passed to FSA by open request. 
} RP_NT_START_NOTIFY, *PRP_NT_START_NOTIFY;

// End recall notification for this user.
//
typedef struct _RP_NT_END_NOTIFY {
   ULONGLONG          filterId;                     // Unique ID passed to FSA by open request. 
} RP_NT_END_NOTIFY, *PRP_NT_END_NOTIFY;

//
// RP_RECALL_COMPLETE
//
// Recall completion information.
//
typedef struct _RP_NT_RECALL_REP {
   ULONGLONG        filterId;                   // Unique ID 
   BOOLEAN          recallCompleted;            // TRUE if data has been transferred - false if open processing complete
   ULONG            actionFlags;                // See below
} RP_NT_RECALL_REP, *PRP_NT_RECALL_REP;

//
// Action flags for recall completion 
//
#define RP_RECALL_ACTION_TRUNCATE   1           // Truncate on close - **** Not currently implemented ****

//
// RP_PARTIAL_DATA 
//
// Partial data recall reply.  Used by both normal recalls and FILE_OPEN_NO_RECALL to transfer some
// or all of the data requested.  The filter knows (by the id) what to do with the data.
//
typedef struct _RP_NT_PARTIAL_REP {
   ULONGLONG    filterId;                     // Unique ID 
   ULONG        bytesRead;                    // Number of bytes read (partial recalls) 
   ULONGLONG    byteOffset;                   // Offset of this data chunk
   ULONG        offsetToData;                 // Offset to the data - must be aligned for non-cached writes
} RP_NT_PARTIAL_REP, *PRP_NT_PARTIAL_REP;

//
// RP_GET_RECALL_INFO
//
// The following message is used to get the recall information that is
// variable in size.  The offset in the structure for userToken marks the
// beginning of the SID info.  After the SID the UNICODE file name can be
// found.  The size of the SID and file name is returned on the recall
// request.  Note that the size of the file path\name is in CHARacters.
// Since these are UNICODE CHARacters the actual buffer size in bytes is
// 2 times the file name length.

typedef struct _RP_NT_INFO_REQ {
   ULONGLONG  filterId;               // Unique ID 
   LONGLONG   fileId;                 // File ID
   CHAR       userToken;              // Actual size varies 
   CHAR       unicodeName;            // Actual size varies 
} RP_NT_INFO_REQ, *PRP_NT_INFO_REQ;

typedef struct _RP_NT_SET_SID {
   CHAR   adminSid;               // Actual size varies 
} RP_NT_SET_SID, *PRP_NT_SET_SID;


//
// RP_GET_REQUEST
//
// Recall cancelled message.
// Sent when the Irp for a pending recall is cancelled.
// No reply expected.
//
typedef struct _RP_NT_RECALL_CANCEL_REQ {
   ULONGLONG  filterId;                     /* Unique ID from original recall request */
} RP_NT_RECALL_CANCEL_REQ, *PRP_NT_RECALL_CANCEL_REQ;

//
// RP_GET_RECALL_INFO
//
// Returns TRUE or FALSE based on check if file is memory mapped
//
typedef struct _RP_CHECK_HANDLE_REP {
   BOOLEAN      canTruncate;
} RP_CHECK_HANDLE_REP, *PRP_CHECK_HANDLE_REP;


#define RP_MAX_MSG   1024  /* Max data size */

/* A pad to set the union size */
typedef struct _RP_NT_MSG_PAD {
   CHAR     padd[RP_MAX_MSG];
} RP_NT_MSG_PAD, *PRP_NT_MSG_PAD;

/* Union of possible commands */

typedef union _RP_MSG_UN {
   RP_NT_OPEN_REQ          oReq;
   RP_NT_CLOSE_REQ         clReq;
   RP_NT_START_NOTIFY      snReq;
   RP_NT_END_NOTIFY        enReq;
   RP_NT_RECALL_REQ        rReq;
   RP_NT_RECALL_REP        rRep;
   RP_NT_PARTIAL_REP       pRep;
   RP_NT_INFO_REQ          riReq;
   RP_NT_SET_SID           sReq;
   RP_NT_RECALL_CANCEL_REQ cReq;
   RP_CHECK_HANDLE_REP     hRep;
   RP_NT_MSG_PAD           pad;
} RP_MSG_UN, *PRP_MSG_UN;

typedef struct _RP_CMD {
   ULONG        command;    /* Requested function */
   ULONG        status;     /* Result code */
} RP_CMD, *PRP_CMD;


typedef struct _RP_MSG {
   RP_CMD      inout;
   RP_MSG_UN   msg;
} RP_MSG, *PRP_MSG;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\inc\rms.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    Rms.h

Abstract:

    Remote Media Service defines

Author:

    Brian Dodd          [brian]         15-Nov-1996

Revision History:

--*/

#ifndef _RMS_
#define _RMS_

// Are we defining imports or exports?
#ifdef RMSDLL
#define RMSAPI  __declspec(dllexport)
#else
#define RMSAPI  __declspec(dllimport)
#endif

#include "Wsb.h"
#include "HsmConn.h"
#include "Mover.h"
#include "RmsLib.h"

////////////////////////////////////////////////////////////////////////////////////////
//
//  Rms enumerations
//


/*++

Enumeration Name:

    RmsFindBy

Description:

    Specifies a type of find to perform using CompareTo.

--*/
typedef enum RmsFindBy {
    RmsFindByUnknown,               // Unknown (or default) find
    RmsFindByCartridgeId,           // Find by Cartridge Id.
    RmsFindByClassId,               // Find by Class Id.
    RmsFindByDescription,           // Find by Description.
    RmsFindByDeviceAddress,         // Find by Device Address.
    RmsFindByDeviceInfo,            // Find by unique device information.
    RmsFindByDeviceName,            // Find by Device Name.
    RmsFindByDeviceType,            // Find by Device Type.
    RmsFindByDriveClassId,          // Find by Drive Class Id.
    RmsFindByElementNumber,         // Find by Element Number.
    RmsFindByExternalLabel,         // Find by External Label.
    RmsFindByExternalNumber,        // Find by External Number.
    RmsFindByLibraryId,             // Find by Library Id.
    RmsFindByLocation,              // Find by Location.
    RmsFindByMediaSupported,        // Find by Media Supported.
    RmsFindByMediaType,             // Find by Media Type.
    RmsFindByScratchMediaCriteria,  // Find by Scratch Media Criteria.
    RmsFindByName,                  // Find by Name.
    RmsFindByObjectId,              // Find by Object Id.
    RmsFindByPartitionNumber,       // Find by Partition Number.
    RmsFindByMediaSetId,            // Find by Media Set Id.
    RmsFindByRequestNo,             // Find by Request Number.
    RmsFindBySerialNumber           // Find by Serial Number.
};


/*++

Enumeration Name:

    RmsObject

Description:

    Specifies a type of Rms object.

--*/
typedef enum RmsObject {
    RmsObjectUnknown = 0,
    RmsObjectCartridge,
    RmsObjectClient,
    RmsObjectDrive,
    RmsObjectDriveClass,
    RmsObjectDevice,
    RmsObjectIEPort,
    RmsObjectLibrary,
    RmsObjectMedia,
    RmsObjectMediaSet,
    RmsObjectNTMS,
    RmsObjectPartition,
    RmsObjectRequest,
    RmsObjectServer,
    RmsObjectCartridgeSide,
    RmsObjectStorageSlot,

    NumberOfRmsObjectTypes
};


/*++

Enumeration Name:

    RmsServerState

Description:

    Specifies the state of the Rms server object.

--*/
typedef enum RmsServerState {
    RmsServerStateUnknown = 0,
    RmsServerStateStarting,
    RmsServerStateStarted,
    RmsServerStateInitializing,
    RmsServerStateReady,
    RmsServerStateStopping,
    RmsServerStateStopped,
    RmsServerStateSuspending,
    RmsServerStateSuspended,
    RmsServerStateResuming,

    NumberOfRmsServerStates
};


/*++

Enumeration Name:

    RmsNtmsState

Description:

    Specifies the state of the Rms NTMS object.

--*/
typedef enum RmsNtmsState {
    RmsNtmsStateUnknown = 0,
    RmsNtmsStateStarting,
    RmsNtmsStateStarted,
    RmsNtmsStateInitializing,
    RmsNtmsStateReady,
    RmsNtmsStateStopping,
    RmsNtmsStateStopped,
    RmsNtmsStateSuspending,
    RmsNtmsStateSuspended,
    RmsNtmsStateResuming,

    NumberOfRmsNtmsStates
};


/*++

Enumeration Name:

    RmsElement

Description:

    Specifies a type of cartridge storage location.

--*/
typedef enum RmsElement {
    RmsElementUnknown,              // Unknown storage location
    RmsElementStage,                // A storage slot used for staging media.
    RmsElementStorage,              // A normal storage slot element within a
                                    //   library device.
    RmsElementShelf,                // A local shelf storage element.  Alternate
                                    //   position specifiers further delineate
                                    //   location.
    RmsElementOffSite,              // An off-site storage element.  Alternate
                                    //   position specifiers further delineate
                                    //   location.
    RmsElementDrive,                // A data transport element.
    RmsElementChanger,              // A medium transport element.
    RmsElementIEPort                // An import/export element.
};


/*++

Enumeration Name:

    RmsChanger

Description:

    Specifies a type of medium changer.

--*/
typedef enum RmsChanger {
    RmsChangerUnknown,              // Unknown medium changer.
    RmsChangerAutomatic,            // A robotic medium changer device.
    RmsChangerManual                // A human jukebox.
};


/*++

Enumeration Name:

    RmsPort

Description:

    Specifies a type of import / export element.

--*/
typedef enum RmsPort {
    RmsPortUnknown,                 // port type unknown
    RmsPortImport,                  // The portal can be used to import media
    RmsPortExport,                  // The portal can be used to export media
    RmsPortImportExport             // The portal is capable of importing and
                                    //   exporting media
};


/*++

Enumeration Name:

    RmsSlotSelect

Description:

    Specifies the slot selection policy.

--*/
typedef enum RmsSlotSelect {
    RmsSlotSelectUnknown,           // Selection policy unknown.
    RmsSlotSelectMinMount,          // Select slot that minimizes mount times.
    RmsSlotSelectGroup,             // Select slot that groups cartridges by
                                    //   application.
    RmsSlotSelectSortName,          // Select slot by sorting cartridges by
                                    //   name.
    RmsSlotSelectSortBarCode,       // Select slot by sorting cartridges by
                                    //   bar code label.
    RmsSlotSelectSortLabel          // Select slot by sorting cartridges by
                                    //   their on-media label.

};


/*++

Enumeration Name:

    RmsStatus

Description:

    Specifies the status for a cartridge.

--*/
typedef enum RmsStatus {
    RmsStatusUnknown,               // The cartridge is unknown to Rms.
    RmsStatusPrivate,               // The Cartridge is labeled and owned by an
                                    //   application.
    RmsStatusScratch,               // The Cartridge is blank, unlabeled, can be
                                    //   used for scratch media requests from
                                    //   any application.
    RmsStatusCleaning               // The cartridge is a cleaning cartridge.
};


/*++

Enumeration Name:

    RmsAttributes

Description:

    Specifies the attributes of a cartridge partition.

--*/
typedef enum RmsAttribute {
    RmsAttributesUnknown,           // Attributes are unknown.
    RmsAttributesRead,              // Data on the partition can be read by an
                                    //   owning application.
    RmsAttributesWrite,             // Data can be written to the partition by
                                    //   an owning application.
    RmsAttributesReadWrite,         // The partition can be read from and
                                    //   written to.
    RmsAttributesVerify             // The partition can only be mounted to read
                                    //   on-media Id or data verification.
};


/*++

Enumeration Name:

    RmsDriveSelect

Description:

    Specifies the drive selection policy.

--*/
typedef enum RmsDriveSelect {
    RmsDriveSelectUnknown,          // Drive selection policy unknown.
    RmsDriveSelectRandom,           // Select drives randomly.
    RmsDriveSelectLRU,              // Select the least recently used drive.
    RmsDriveSelectRoundRobin        // Select drives in round robin order.
};


/*++

Enumeration Name:

    RmsState

Description:

    Specifies the state of an Rms object.

--*/
typedef enum RmsState {
    RmsStateUnknown,                // State unknown.
    RmsStateEnabled,                // Normal access to the object is enabled.
    RmsStateDisabled,               // Normal access to the object is disabled.
    RmsStateError                   // Normal access disabled due to an error
                                    //   condition.
};


/*++

Enumeration Name:

    RmsMedia

Description:

    Specifies the type of RMS media.

--*/
typedef enum RmsMedia {
    RmsMediaUnknown =       0,          // Media type unknown.
    RmsMedia8mm     =       0x0001,     // 8mm tape.
    RmsMedia4mm     =       0x0002,     // 4mm tape.
    RmsMediaDLT     =       0x0004,     // DLT tape.
    RmsMediaOptical =       0x0008,     // All types of read-write (rewriteable) optical disks.
    RmsMediaMO35    =       0x0010,     // 3 1/2 inch magneto-optical. (not used)
    RmsMediaWORM    =       0x0020,     // 5 1/4 inch two-sided write-once optical.
    RmsMediaCDR     =       0x0040,     // 5 1/4 inch compact-disc, recordable.
    RmsMediaDVD     =       0x0080,     // All types of read-write (rewriteable) DVD.
    RmsMediaDisk    =       0x0100,     // Removable hard disk of various formats.
    RmsMediaFixed   =       0x0200,     // Fixed Hard disk.
    RmsMediaTape   =        0x0400      // Generic tape
};

#define     RMSMAXMEDIATYPES   12       // Number of enum's from RmsMedia


/*++

Enumeration Name:

    RmsDevice

Description:

    Specifies a type of RMS supported device.

--*/
typedef enum RmsDevice {
    RmsDeviceUnknown,               // unknown device type.
    RmsDeviceFixedDisk,             // Direct access fixed disk.
    RmsDeviceRemovableDisk,         // Direct access removable disk.
    RmsDeviceTape,                  // Sequential access tape.
    RmsDeviceCDROM,                 // Read only, CDROM.
    RmsDeviceWORM,                  // Write once, WORM.
    RmsDeviceOptical,               // Optical memory/disk.
    RmsDeviceChanger                // MediumChanger.
};


/*++

Enumeration Name:

    RmsMode

Description:

    Specifies the access mode supported by a drive or specified when
    mounting a Cartridge.

--*/
typedef enum RmsMode {
    RmsModeUnknown,                 // access mode supported unknown.
    RmsModeRead,                    // Read operations.
    RmsModeReadWrite,               // Read or write operations.
    RmsModeWriteOnly                // Write only operations.
};


/*++

Enumeration Name:

    RmsMediaSet

Description:

    Specifies the type of a Media Set.

--*/
typedef enum RmsMediaSet {
    RmsMediaSetUnknown = 1300,      // Unknown.
    RmsMediaSetFolder,              // Contains for other media sets.
    RmsMediaSetLibrary,             // Cartridges in the media set are accessible via
                                    //   robotic device.
    RmsMediaSetShelf,               // Cartridges are shelved locally, and
                                    //   accessible via human intervention.
    RmsMediaSetOffSite,             // Cartridges are stored at an off-site
                                    //   location, and are not directly
                                    //   accessible for mounting.
    RmsMediaSetNTMS,                // Cartridges are accessible through NTMS.
    RmsMediaSetLAST
};

/*++

Enumeration Name:

    RmsMediaManager

Description:

    Specifies the media manager that controls a resource.

--*/
typedef enum RmsMediaManager {
    RmsMediaManagerUnknown = 1400,      // Unknown.
    RmsMediaManagerNative,              // Resource managed by RMS (native).
    RmsMediaManagerNTMS,                // Resource managed by NTMS.
    RmsMediaManagerLAST
};

/*++

Enumeration Name:

    RmsCreate

Description:

    Specifies the create disposition for objects.

--*/
typedef enum RmsCreate {
    RmsCreateUnknown,
    RmsOpenExisting,                // Opens an existing object.
    RmsOpenAlways,                  // Opens an existing object, or creates a new one.
    RmsCreateNew                    // Creates a new object if it doesn't exists.
};

/*++

Enumeration Name:

    RmsOnMediaIdentifier

Description:

    Specifies the type on media identifier.

--*/
typedef enum RmsOnMediaIdentifier {
    RmsOnMediaIdentifierUnknown,
    RmsOnMediaIdentifierMTF,                // MTF Media Identifier
    RmsOnMediaIdentifierWIN32               // WIN32 Filesystem Identifier
};

////////////////////////////////////////////////////////////////////////////////////////
//
//  Rms structs
//

/*++

Structure Name:

    RMS_FILESYSTEM_INFO

Description:

    Structure used to specify on media file system information.

    NOTE:  This is a dup of the NTMS_FILESYSTEM_INFO struct.

--*/
typedef struct _RMS_FILESYSTEM_INFO {
    WCHAR FileSystemType[64];
    WCHAR VolumeName[256];
    DWORD SerialNumber;
} RMS_FILESYSTEM_INFO, *LP_RMS_FILESYSTEM_INFO;

////////////////////////////////////////////////////////////////////////////////////////
//
//  Rms defines
//
#define RMS_DUPLICATE_RECYCLEONERROR    0x00010000  // DuplicateCartridge option used to
                                                    // recyle a new cartridge if an error occurs.

#define RMS_STR_MAX_CARTRIDGE_INFO      128     // Max string len for Cartridge info
#define RMS_STR_MAX_CARTRIDGE_NAME       64     // Max string len for Cartridge Name
#define RMS_STR_MAX_EXTERNAL_LABEL       32     // Max string len for External Label
#define RMS_STR_MAX_MAIL_STOP            64     // Max string len for Mail Stop
#define RMS_STR_MAX_LENGTH              128     // Max string length of any string

//
// Inquiry defines. Used to interpret data returned from target as result
// of inquiry command.
//
// DeviceType field
//

#define DIRECT_ACCESS_DEVICE            0x00    // disks
#define SEQUENTIAL_ACCESS_DEVICE        0x01    // tapes
#define PRINTER_DEVICE                  0x02    // printers
#define PROCESSOR_DEVICE                0x03    // scanners, printers, etc
#define WRITE_ONCE_READ_MULTIPLE_DEVICE 0x04    // worms
#define READ_ONLY_DIRECT_ACCESS_DEVICE  0x05    // cdroms
#define SCANNER_DEVICE                  0x06    // scanners
#define OPTICAL_DEVICE                  0x07    // optical disks
#define MEDIUM_CHANGER                  0x08    // jukebox
#define COMMUNICATION_DEVICE            0x09    // network

//
// Default object names
//

#define RMS_DEFAULT_FIXEDDRIVE_LIBRARY_NAME     OLESTR("Fixed Drive Library")
#define RMS_DEFAULT_FIXEDDRIVE_MEDIASET_NAME    OLESTR("Fixed Drive Media (Testing Only !!)")
#define RMS_DEFAULT_OPTICAL_LIBRARY_NAME        OLESTR("Optical Library")
#define RMS_DEFAULT_OPTICAL_MEDIASET_NAME       OLESTR("Optical Media")
#define RMS_DEFAULT_TAPE_LIBRARY_NAME           OLESTR("Tape Library")
#define RMS_DEFAULT_TAPE_MEDIASET_NAME          OLESTR("Tape Media")

#define RMS_UNDEFINED_STRING                    OLESTR("Uninitialized String")
#define RMS_NULL_STRING                         OLESTR("")

#define RMS_DIR_LEN                             256
#define RMS_TRACE_FILE_NAME                     OLESTR("rms.trc")
#define RMS_NTMS_REGISTRY_STRING                OLESTR("SYSTEM\\CurrentControlSet\\Services\\NtmsSvc")

// Currently, RMS Registry location points to same location of Engine parameters
//  keeping this literal enables moving RMS parameters to another key easily.
#define RMS_REGISTRY_STRING                     OLESTR("SYSTEM\\CurrentControlSet\\Services\\Remote_Storage_Server\\Parameters")

// Registry parameters (all parameters are string values in the registry)
#define RMS_PARAMETER_HARD_DRIVES_TO_USE        OLESTR("HardDrivesToUse")       // "ABCDEFG", if "" defaults to any volume with "RS", "RemoteStor", "Remote Stor"
#define RMS_PARAMETER_NTMS_SUPPORT              OLESTR("NTMSSupport")           // 1 | 0
#define RMS_PARAMETER_NEW_STYLE_IO              OLESTR("NewStyleIo")            // 1 | 0
#define RMS_PARAMETER_BLOCK_SIZE                OLESTR("BlockSize")             // Must be mod 512
#define RMS_PARAMETER_BUFFER_SIZE               OLESTR("BufferSize")            // Must be mod 512
#define RMS_PARAMETER_COPY_BUFFER_SIZE          OLESTR("MediaCopyBufferSize")   // Buffer size for media copy on FS-media like optical
#define RMS_PARAMETER_FORMAT_COMMAND            OLESTR("FormatCommand")         // Full pathname specifier to format command
#define RMS_PARAMETER_FORMAT_OPTIONS            OLESTR("FormatOptions")         // Format command options
#define RMS_PARAMETER_FORMAT_OPTIONS_ALT1       OLESTR("FormatOptionsAlt1")     // Format command options - alternate
#define RMS_PARAMETER_FORMAT_OPTIONS_ALT2       OLESTR("FormatOptionsAlt2")     // Format command options - second alternate
#define RMS_PARAMETER_FORMAT_WAIT_TIME          OLESTR("FormatWaitTime")        // Format time-out interval, in milliseconds
#define RMS_PARAMETER_TAPE                      OLESTR("Tape")                  // 1 | 0
#define RMS_PARAMETER_OPTICAL                   OLESTR("Optical")               // 1 | 0
#define RMS_PARAMETER_FIXED_DRIVE               OLESTR("FixedDrive")            // 1 | 0
#define RMS_PARAMETER_DVD                       OLESTR("DVD")                   // 1 | 0
#define RMS_PARAMETER_ADDITIONAL_TAPE           OLESTR("TapeTypesToSupport")   // Additional media types to support (REG_MULTI_SZ)
#define RMS_PARAMETER_DEFAULT_MEDIASET          OLESTR("DefaultMediaSet")       // The name of the media set to use for unspecified scratch media requests.
#define RMS_PARAMETER_MEDIA_TYPES_TO_EXCLUDE    OLESTR("MediaTypesToExclude")   // A delimited list of media types to exclude.  First char is delimiter.
#define RMS_PARAMETER_NOTIFICATION_WAIT_TIME    OLESTR("NotificationWaitTime")  // Milliseconds to wait for an object notification
#define RMS_PARAMETER_ALLOCATE_WAIT_TIME        OLESTR("AllocateWaitTime")      // Milliseconds to wait for a media allocation
#define RMS_PARAMETER_MOUNT_WAIT_TIME           OLESTR("MountWaitTime")         // Milliseconds to wait for a mount
#define RMS_PARAMETER_REQUEST_WAIT_TIME         OLESTR("RequestWaitTime")       // Milliseconds to wait for a request
#define RMS_PARAMETER_DISMOUNT_WAIT_TIME        OLESTR("DismountWaitTime")      // Milliseconds to wait before dismount
#define RMS_PARAMETER_AFTER_DISMOUNT_WAIT_TIME  OLESTR("AfterDismountWaitTime") // Milliseconds to wait after dismount
#define RMS_PARAMETER_SHORT_WAIT_TIME           OLESTR("ShortWaitTime")         // Milliseconds when asked to wait for short periods
#define RMS_PARAMETER_MEDIA_COPY_TOLERANCE      OLESTR("MediaCopyTolerance")    // Percent copy media can be shorter than original

// Default parameter values
#define RMS_DEFAULT_HARD_DRIVES_TO_USE          OLESTR("")
#define RMS_DEFAULT_NTMS_SUPPORT                TRUE
#define RMS_DEFAULT_NEW_STYLE_IO                TRUE
#define RMS_DEFAULT_BLOCK_SIZE                  1024
#define RMS_DEFAULT_BUFFER_SIZE                 (64*1024)
#define RMS_DEFAULT_FORMAT_COMMAND              OLESTR("%SystemRoot%\\System32\\format.com")
#define RMS_DEFAULT_FORMAT_OPTIONS              OLESTR("/fs:ntfs /force /q /x")
#define RMS_DEFAULT_FORMAT_OPTIONS_ALT1         OLESTR("/fs:ntfs /force /x")
#define RMS_DEFAULT_FORMAT_OPTIONS_ALT2         OLESTR("")
#define RMS_DEFAULT_FORMAT_WAIT_TIME            (20*60*1000)
#define RMS_DEFAULT_TAPE                        TRUE
#define RMS_DEFAULT_OPTICAL                     TRUE
#define RMS_DEFAULT_FIXED_DRIVE                 FALSE
#define RMS_DEFAULT_DVD                         FALSE
#define RMS_DEFAULT_MEDIASET                    OLESTR("")
#define RMS_DEFAULT_MEDIA_TYPES_TO_EXCLUDE      OLESTR("")
#define RMS_DEFAULT_NOTIFICATION_WAIT_TIME      (10000)
#define RMS_DEFAULT_ALLOCATE_WAIT_TIME          (3600000)
#define RMS_DEFAULT_MOUNT_WAIT_TIME             (14400000)
#define RMS_DEFAULT_REQUEST_WAIT_TIME           (3600000)
#define RMS_DEFAULT_DISMOUNT_WAIT_TIME          (5000)
#define RMS_DEFAULT_AFTER_DISMOUNT_WAIT_TIME    (1000)
#define RMS_DEFAULT_SHORT_WAIT_TIME             (1800000)
#define RMS_DEFAULT_MEDIA_COPY_TOLERANCE        (2)         // Percent copy media can be shorter than original

#define RMS_DEFAULT_DATA_BASE_FILE_NAME         OLESTR("RsSub.col")
#define RMS_NTMS_ROOT_MEDIA_POOL_NAME           OLESTR("Remote Storage")

#define RMS_NTMS_OBJECT_NAME                    OLESTR("NTMS")
#define RMS_NTMS_OBJECT_DESCRIPTION             OLESTR("NT Media Services")


//	RMS media status
#define		RMS_MEDIA_ENABLED			0x00000001
#define		RMS_MEDIA_ONLINE    		0x00000002
#define		RMS_MEDIA_AVAILABLE 		0x00000004

//	RMS Options - Flags literal
//		Keep the default for each flag value as zero, i.e. RM_NONE should always be the
//		default mask for all methods		
#define		RMS_NONE					0x0

#define		RMS_MOUNT_NO_BLOCK			0x00000001
#define		RMS_DISMOUNT_IMMEDIATE		0x00000002
#define     RMS_SHORT_TIMEOUT           0x00000004
#define     RMS_DISMOUNT_DEFERRED_ONLY  0x00000008
#define     RMS_ALLOCATE_NO_BLOCK       0x00000010
#define     RMS_USE_MOUNT_NO_DEADLOCK   0x00000020
#define     RMS_SERIALIZE_MOUNT         0x00000040

//
// CRmsSink helper class
//
class CRmsSink : 
    public IRmsSinkEveryEvent,
    public CComObjectRoot
{
    public:
        // constructor/destructor
            CRmsSink(void) {};

        BEGIN_COM_MAP(CRmsSink)
            COM_INTERFACE_ENTRY(IRmsSinkEveryEvent)
        END_COM_MAP()

        HRESULT FinalConstruct( void ) {
            HRESULT hr = S_OK;
            try {
                m_Cookie = 0;
                m_hReady = 0;
                WsbAffirmHr( CComObjectRoot::FinalConstruct( ) );
            } WsbCatch( hr );
            return hr;
        }

        void FinalRelease( void ) {
            DoUnadvise( );
            CComObjectRoot::FinalRelease( );
        }


    public: 
        STDMETHOD( ProcessObjectStatusChange ) ( IN BOOL isEnabled, IN LONG state, IN HRESULT statusCode ) {
            HRESULT hr = S_OK;
            UNREFERENCED_PARAMETER(statusCode);
            if( isEnabled ) {
                switch( state ) {
                case RmsServerStateStarting:
                case RmsServerStateStarted:
                case RmsServerStateInitializing:
                    break;
                default:
                    SetEvent( m_hReady );
                }
            } else {
                SetEvent( m_hReady );
            }
            return hr;
        }

        HRESULT Construct( IN IUnknown * pUnk ) {
            HRESULT hr = S_OK;
            try {
                WsbAffirmHr( FinalConstruct( ) );
                WsbAffirmHr( DoAdvise( pUnk ) );
            } WsbCatch( hr );
            return hr;
        }

        HRESULT DoAdvise( IN IUnknown * pUnk ) {
            HRESULT hr = S_OK;
            try {
#define         RmsQueryInterface( pUnk, interf, pNew )  (pUnk)->QueryInterface( IID_##interf, (void**) static_cast<interf **>( &pNew ) )
                WsbAffirmHr( RmsQueryInterface( pUnk, IRmsServer, m_pRms ) );
#if 0
                WCHAR buf[100];
                static int count = 0;
                swprintf( buf, L"CRmsSinkEvent%d", count++ );
#else
                WCHAR* buf = 0;
#endif
                m_hReady = CreateEvent( 0, TRUE, FALSE, buf );
                WsbAffirmStatus( ( 0 != m_hReady ) );
                WsbAffirmHr( AtlAdvise( pUnk, (IUnknown*)(IRmsSinkEveryEvent*)this, IID_IRmsSinkEveryEvent, &m_Cookie ) );
            } WsbCatch( hr );
            return hr;
        }

        HRESULT DoUnadvise( void ) {
            HRESULT hr = S_OK;
            if( m_hReady ) {
                CloseHandle( m_hReady );
                m_hReady = 0;
            }
            if( m_Cookie ) {
                hr = AtlUnadvise( m_pRms, IID_IRmsSinkEveryEvent, m_Cookie );
                m_Cookie = 0;
            }
            return hr;
        }

        HRESULT WaitForReady( void ) {
            HRESULT hr = S_OK;
            try {
                DWORD waitResult;
                HRESULT hrReady = m_pRms->IsReady( );
                switch( hrReady ) {
                case RMS_E_NOT_READY_SERVER_STARTING:
                case RMS_E_NOT_READY_SERVER_STARTED:
                case RMS_E_NOT_READY_SERVER_INITIALIZING:
                case RMS_E_NOT_READY_SERVER_LOCKED:
                    //
                    // We must wait, but the message queue must be pumped so that
                    // the COM Apartment model calls can be made in (like the
                    // call into the connection point)
                    //
                    while( TRUE ) {
                        waitResult = MsgWaitForMultipleObjects( 1, &m_hReady, FALSE, INFINITE, QS_ALLINPUT );
                        if( WAIT_OBJECT_0 == waitResult ) {
                            break;
                        } else {
                            MSG msg;
                            while( PeekMessage( &msg, 0, 0, 0, PM_REMOVE ) ) {
                                DispatchMessage( &msg );
                            }
                        }
                    };
                    WsbAffirmHr( m_pRms->IsReady( ) );
                    break;
                case S_OK:
                    break;
                default:
                    WsbThrow( hrReady );
                }
            } WsbCatch( hr );
            return hr;
        }

    private:
        CComPtr<IRmsServer>       m_pRms;
        DWORD                     m_Cookie;
        HANDLE                    m_hReady;
};

#endif // _RMS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\inc\rpguid.h ===
/*++

   (c) 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    RpGuid.h

Abstract:

    Contains GUID definitions for filter

Environment:

    User and  Kernel mode

--*/
#ifndef _RPGUID_H_
#define _RPGUID_H_

#ifdef __cplusplus
extern "C" {
#endif

//
//
// HSM vendor ID for Sakkara
// {12268890-64D1-11d0-A9B0-00A0248903EA}
//
DEFINE_GUID( RP_MSFT_VENDOR_ID, 0x12268890L, 0x64d1, 0x11d0,  0xa9, 0xb0, 
0x0,  0xa0, 0x24, 0x89, 0x3, 0xea);

#ifdef __cplusplus
}
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\inc\rsevents.h ===
/*++
Copyright (C) Microsoft Corporation, 1996 - 2000

Module Name:

    rsevents.h

Abstract:

    This module defines names of events that are used to synchronize HSM components,
    which are located in different units.

Author:

    Ran Kalach (rankala)  4/5/00

--*/


#ifndef _RSEVENTS_
#define _RSEVENTS_


// State event parameters
#define     SYNC_STATE_EVENTS_NUM       3
#define     HSM_ENGINE_STATE_EVENT      OLESTR("HSM Engine State Event")
#define     HSM_FSA_STATE_EVENT         OLESTR("HSM Fsa State Event")
#define     HSM_IDB_STATE_EVENT         OLESTR("HSM Idb State Event")
#define     EVENT_WAIT_TIMEOUT          (10*60*1000)    // 10 minutes

// RSS backup name

// Note: The Backup/Snapshot writer string should be the same as the name written to the 
//       Registry for NTBackup exclude list (FilesNotToBackup value)
#define     RSS_BACKUP_NAME             OLESTR("Remote Storage")



#endif // _RSEVENTS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\inc\rslimits.h ===
/*++
Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    rslimits.h

Abstract:

    This module defines the limits for various configurable parameters in HSM.
    These definitions should be used by:
    1) The UI
    2) The CLI
    3) The corresponding implementing objects

Author:

    Ran Kalach (rankala)  3/6/00

--*/

#ifndef _RSLIMITS_
#define _RSLIMITS_

#define HSMADMIN_DEFAULT_MINSIZE        12
#define HSMADMIN_DEFAULT_FREESPACE      5
#define HSMADMIN_DEFAULT_INACTIVITY     180

#define HSMADMIN_MIN_MINSIZE            2
#define HSMADMIN_MAX_MINSIZE            32000

#define HSMADMIN_MIN_FREESPACE          0
#define HSMADMIN_MAX_FREESPACE          99

#define HSMADMIN_MIN_INACTIVITY         0
#define HSMADMIN_MAX_INACTIVITY         999

#define HSMADMIN_MIN_COPY_SETS          0
#define HSMADMIN_MAX_COPY_SETS          3

#define HSMADMIN_MIN_RECALL_LIMIT       1
#define HSMADMIN_MIN_CONCURRENT_TASKS   1

#define HSMADMIN_MAX_VOLUMES        512 // This ought to be plenty

#endif // _RSLIMITS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\inc\rsbuild.h ===
#ifndef _RSBUILD_H
#define _RSBUILD_H 

/*++

Copyright (c) 1997  Microsoft Corporation
 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    rsbuild.h

Abstract:

    Include file to identify the code build 

Author:

    Cat Brant   [cbrant@avail.com]      09-OCT-1997

Revision History:

    Brian Dodd  [brian@avail.com]       20-Aug-1998
        Added Major, Minor macros

--*/

//
// These need to be update each time a build is released
//
#define RS_BUILD_NUMBER 602
#define RS_BUILD_REVISION 0


//
//
//
//  RS_BUILD_VERSION is a 32 bit value layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +-------------------------------+-------------------------------+
//  |           Revision            |             Number            |
//  +-------------------------------+-------------------------------+
//
//  where
//
//      Revision - is the build revision number, or dot release.
//
//      Number   - is the build number
//
//
//  The version is typically displayed as: Number.Revision
//
//


//
//  Return the build version
//

#define RS_BUILD_VERSION ((RS_BUILD_REVISION << 16) | RS_BUILD_NUMBER)


//
//  Return the revision, and number
//

#define RS_BUILD_REV(ver)  ((ver) >> 16)
#define RS_BUILD_NUM(ver)  ((ver) & 0x0000ffff)


//
//  Return the static build version as a string
//

#define RS_STRINGIZE(a) OLESTR(#a)
#define RS_BUILD_VERSION_STR(num, rev) \
    ((0 == rev) ? RS_STRINGIZE(num) : (RS_STRINGIZE(num)L"."RS_STRINGIZE(rev)))

#define RS_BUILD_VERSION_STRING (RS_BUILD_VERSION_STR(RS_BUILD_NUMBER, RS_BUILD_REVISION))


//
//  Inline to return dyncamic build version as a string
//

inline WCHAR * RsBuildVersionAsString(ULONG ver) {
    static WCHAR string[16];

    if (RS_BUILD_REV(ver) > 0) {
        swprintf(string, L"%d.%d", RS_BUILD_NUM(ver), RS_BUILD_REV(ver));
    }
    else {
        swprintf(string, L"%d", RS_BUILD_NUM(ver));
    }

    return string;
}


//
//  Persistency Files versions
//
#define  FSA_WIN2K_DB_VERSION           1
#define  ENGINE_WIN2K_DB_VERSION        2
#define  RMS_WIN2K_DB_VERSION           2

#define  FSA_CURRENT_DB_VERSION         1
#define  ENGINE_CURRENT_DB_VERSION      3

#endif // _RSBUILD_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\inc\rsstrdef.h ===
/*++
Copyright (C) Microsoft Corporation, 1996 - 1999

Module Name:

    rsstrdef.h

Abstract:

    This module defines common string identifiers that are held in Wsb resources

Author:

    Ran Kalach (rankala)  3/23/00

--*/

#ifndef _RSSTRDEF_
#define _RSSTRDEF_

// Gloabl HSM string identifiers    (reserved range: 1024 - 2047)

#define IDS_HSM_SCHED_TASK_TITLE             1024
#define IDS_HSM_SCHED_COMMENT                1025

#endif // _RSSTRDEF_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\inc\wsb.h ===
#ifndef _WSB_H
#define _WSB_H

/*++

Copyright (c) 1996 Microsoft Corporation
 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    wsb.h

Abstract:

    This module defines very basic error results, as well as
    helper macros for exception handling.

Author:

    Chuck Bardeen   [cbardeen]      29-Oct-1996

Revision History:

    Christopher J. Timmes   [ctimmes]   24-Jun-1997
        - added new header file 'wsbfile.h' to list of includes.  This is the header
          for the new common file manipulation routines source file (wsbfile.cpp).

--*/

// First Wsb header that should be included. Sets up special initialization.
#include "wsbfirst.h"

#include "wsbint.h"
#include "wsblib.h"

#include "wsbtrak.h"
#include "wsbassrt.h"
#include "wsbbstrg.h"
#include "wsbcltbl.h"
#include "wsberror.h"
#include "wsbfile.h"
#include "wsbport.h"
#include "wsbpstbl.h"
#include "wsbpstrg.h"
#include "wsbregty.h"
#include "wsbtrace.h"
#include "wsbvar.h"
#include "wsbserv.h"


// Generic Wsb header that should always be last
#include "wsbgen.h"

#endif // _WSB_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\inc\task.h ===
#ifndef _TASK_
#define _TASK_

// task.h
//
// This header file collects up all the task manager and related objects
// and common function definitions. The COM objects are available in
// TASK.DLL.

// COM Interface & LibraryDefintions
//#include "tskdef.h"
#include "tskdef.h"
#include "tskint.h"
#include "tsklib.h"

// Common Functions
#include "tsktrace.h"

#endif // _TASK_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\inc\tskmgr.h ===
// TskMgr.h : Declaration of the CTskMgr

#include "resource.h"       // main symbols
#include "wsb.h"            // Wsb structure definitions


#ifndef __TSKMGR__
#define __TSKMGR__

#define HsmWorkQueueArrayBumpSize  10

/////////////////////////////////////////////////////////////////////////////
// task

typedef struct _HSM_WORK_QUEUES {
    //
    // Note: First 2 fields (sessionId and pSession)
    // are not used for demand recall queues. 
    //
    GUID                    sessionId;      // GUID of the session
    CComPtr<IHsmSession>    pSession;       // Session interface
    CComPtr<IHsmWorkQueue>    pWorkQueue;   // WorkQueue for the session
    CComPtr<IHsmRecallQueue>  pRecallQueue; // Demand RecallQueue
    HSM_WORK_QUEUE_TYPE     queueType;      // Type of queue
    HSM_WORK_QUEUE_STATE    queueState;     // State of the queue
    FILETIME                birthDate;      // Birth of queue
} HSM_WORK_QUEUES, *PHSM_WORK_QUEUES;

typedef struct {
    HSM_WORK_QUEUE_TYPE  Type;
    ULONG                MaxActiveAllowed;
    ULONG                NumActive;
} HSM_WORK_QUEUE_TYPE_INFO, *PHSM_WORK_QUEUE_TYPE_INFO;

class CHsmTskMgr :
    public CComObjectRoot,
    public IHsmFsaTskMgr,
    public CComCoClass<CHsmTskMgr,&CLSID_CHsmTskMgr>
{
public:
    CHsmTskMgr() {}
BEGIN_COM_MAP(CHsmTskMgr)
    COM_INTERFACE_ENTRY(IHsmFsaTskMgr)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID( IDR_CHsmTskMgr )

// IHsmFsaTskMgr
public:
    STDMETHOD(ContactOk)( void );
    STDMETHOD(DoFsaWork)(IFsaPostIt *fsaWorkItem );
    STDMETHOD(FinalConstruct)(void);
    STDMETHOD(FinalRelease)(void);
    STDMETHOD(Init)(IUnknown *pServer);

    STDMETHOD(WorkQueueDone)(IHsmSession *pSession, HSM_WORK_QUEUE_TYPE type, GUID *pMediaId);

private:
    STDMETHOD(IncreaseWorkQueueArraySize)(ULONG numToAdd);
    STDMETHOD(StartQueues)( void );
    STDMETHOD(StartFsaQueueType)(HSM_WORK_QUEUE_TYPE type);
    STDMETHOD(FindOldestQueue)(HSM_WORK_QUEUE_TYPE type, ULONG *pIndex);
    STDMETHOD(EnsureQueueForFsaSession)(IHsmSession *pSession, FSA_REQUEST_ACTION fsaAction, IHsmWorkQueue **ppWorkQueue, BOOL *bCreated);
    STDMETHOD(AddToRecallQueueForFsaSession)(IHsmSession *pSession, IHsmRecallQueue **ppWorkQueue, BOOL *bCreated, GUID *pMediaId, GUID *pBagId, LONGLONG dataSetStart, IFsaPostIt *pFsaWorkItem);
    STDMETHOD(AddWorkQueueElement)(IHsmSession *pSession, HSM_WORK_QUEUE_TYPE type, ULONG *pIndex);
    STDMETHOD(FindWorkQueueElement)(IHsmSession *pSession, HSM_WORK_QUEUE_TYPE type, ULONG *pIndex, GUID *pMediaId);
    STDMETHOD(FindRecallQueueElement(IN IHsmSession *pSession, IN GUID  *pMediaId,  OUT IHsmRecallQueue **ppWorkQueue, OUT BOOL *bCreated));
    STDMETHOD(GetWorkQueueElement)(ULONG index, IHsmSession **ppSession, IHsmWorkQueue **ppWorkQueue, HSM_WORK_QUEUE_TYPE *pType, HSM_WORK_QUEUE_STATE *pState, FILETIME *pBirthDate);
    STDMETHOD(SetWorkQueueElement)(ULONG index, IHsmSession *pSession, IHsmWorkQueue *pWorkQueue, HSM_WORK_QUEUE_TYPE type, HSM_WORK_QUEUE_STATE state, FILETIME birthdate);
    STDMETHOD(GetRecallQueueElement)(ULONG index, IHsmRecallQueue **ppWorkQueue, HSM_WORK_QUEUE_STATE *pState, FILETIME *pBirthDate);
    STDMETHOD(SetRecallQueueElement)(ULONG index, IHsmRecallQueue *pWorkQueue,  HSM_WORK_QUEUE_TYPE queueType, HSM_WORK_QUEUE_STATE state, FILETIME birthdate);
    STDMETHOD(RemoveWorkQueueElement)(ULONG index);

    STDMETHOD(FindRecallMediaToUse)(IN IFsaPostIt *pFsaWorkItem, OUT GUID *pMediaToUse, OUT GUID *pBagId, OUT LONGLONG *pDataSetStart);

// IHsmSystemState
    STDMETHOD( ChangeSysState )( HSM_SYSTEM_STATE* pSysState );

    // We want the next two pointers (to the Hsm Server) to be weak
    // references and **not** add ref the server.  This is so shutting
    // down the server really works.
//  CComPtr<IHsmServer>             m_pServer;              // Server owning TskMgr
//  CComPtr<IWsbCreateLocalObject>  m_pHsmServerCreate;     // Server object creater
    IHsmServer              *m_pServer;                     // Server owning TskMgr
    IWsbCreateLocalObject   *m_pHsmServerCreate;            // Server object creater

    PHSM_WORK_QUEUES                m_pWorkQueues;          // Work delegated by TskMgr
    ULONG                           m_NumWorkQueues;        // Number of work queues

    CRITICAL_SECTION                m_WorkQueueLock;        // Protect array access and update
                                                            // from multiple thread access
    CRITICAL_SECTION                m_CurrentRunningLock;   // Protect starting queues
                                                            // from multiple thread access
    CRITICAL_SECTION                m_CreateWorkQueueLock;  // Protect creating queues
                                                            // from multiple thread access
    PHSM_WORK_QUEUE_TYPE_INFO       m_pWorkQueueTypeInfo;   // Info about work queue types
    ULONG                           m_nWorkQueueTypes;      // Number of work queue types
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\inc\tsktrace.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    tskTrace.h

Abstract:

    This header file defines the part of the task manager code that is
    responsible for tracing task manager specific parameters.

Author:

    Cat Brant       [cbrant]   7-Det-1996

Revision History:

--*/

#ifndef _TSKTRACE_H_
#define _TSKTRACE_H_

// Helper Functions
//
// NOTE: Be careful with some of these helper functions, since they
// use static memory and a second call to the function will overwrite
// the results of the first call to the function. 
extern const OLECHAR* TmFsaRequestActionAsString(FSA_REQUEST_ACTION requestAction);
extern const OLECHAR* TmFsaResultActionAsString(FSA_RESULT_ACTION resultAction);

#endif // _TSKTRACE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\inc\wsbbstrg.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    wsbbstrg.h

Abstract:

    This component is C++ object representations a smart BSTR pointer. It
    is similar to the CComPtr, in that it takes care of allocating and
    freeing the memory needed to represent the string automatically. This
    simplifies cleanup of functions in error handling cases and it limits
    the need for FinalConstruct() and FinalRelease() calls in objects that
    derive from CComObjectRoot. It is similar to the CWsbStringPtr class.

Author:

    Chuck Bardeen   [cbardeen]   11-Dec-1996

Revision History:

--*/

#ifndef _WSBBSTRG_
#define _WSBBSTRG_

/*++

Class Name:
    
    CWsbBstrPtr

Class Description:

    This component is C++ object representations a smart BSTR pointer. It
    is similar to the CComPtr, in that it takes care of allocating and
    freeing the memory needed to represent the string automatically. This
    simplifies cleanup of functions in error handling cases and it limits
    the need for FinalConstruct() and FinalRelease() calls in objects that
    derive from CComObjectRoot. It is similar to the CWsbStringPtr class.

--*/

class WSB_EXPORT CWsbBstrPtr
{

// Constructors
public:
    CWsbBstrPtr();
    CWsbBstrPtr(const CHAR* pChar);
    CWsbBstrPtr(const WCHAR* pWchar);
    CWsbBstrPtr(const CWsbBstrPtr& pString);
    CWsbBstrPtr(REFGUID rguid);

// Destructor
public:
    ~CWsbBstrPtr();

// Operator Overloading
public:
    operator BSTR();
    WCHAR& operator *();
    BSTR* operator &();
    WCHAR& operator [](const int i);
    CWsbBstrPtr& operator =(const CHAR* pChar);
    CWsbBstrPtr& operator =(const WCHAR* pWchar);
    CWsbBstrPtr& operator =(REFGUID rguid);
    CWsbBstrPtr& operator =(const CWsbBstrPtr& pString);
    BOOL operator !();

// Memory Allocation
public:
    HRESULT Alloc(ULONG size);
    HRESULT Free(void);
    HRESULT GetSize(ULONG* size);
    HRESULT Realloc(ULONG size);

// String Manipulation
public:
    HRESULT Append(const CHAR* pChar);
    HRESULT Append(const WCHAR* pWchar);
    HRESULT Append(const CWsbBstrPtr& pString);
    HRESULT CopyTo(CHAR** pChar);
    HRESULT CopyTo(WCHAR** pWchar);
    HRESULT CopyTo(GUID * pguid);
    HRESULT CopyToBstr(BSTR* pBstr);
    HRESULT CopyTo(CHAR** pChar, ULONG bufferSize);
    HRESULT CopyTo(WCHAR** pWchar,ULONG bufferSize);
    HRESULT CopyToBstr(BSTR* pBstr,ULONG bufferSize);
    HRESULT FindInRsc(ULONG startId, ULONG idsToCheck, ULONG* pMatchId);
    HRESULT GiveTo(BSTR* pBstr);
    HRESULT LoadFromRsc(HINSTANCE instance, ULONG id);
    HRESULT Prepend(const CHAR* pChar);
    HRESULT Prepend(const WCHAR* pWchar);
    HRESULT Prepend(const CWsbBstrPtr& pString);
    HRESULT TakeFrom(BSTR bstr, ULONG bufferSize);

// Guid Translation
public:

// Member Data
protected:
    BSTR                    m_pString;
    ULONG                   m_givenSize;
};

#endif // _WSBBSTRG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\inc\wsbcltbl.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    WsbCollectable.h

Abstract:

    Abstract classes that provide methods that allow the derived objects to
    be stored in collections.

Author:

    Chuck Bardeen   [cbardeen]   29-Oct-1996

Revision History:

--*/

#include "WsbPstbl.h"

#ifndef _WSBCLTBL_
#define _WSBCLTBL_


/*++

Class Name:
    
    CWsbObject

Class Description:

    Base class for collectable objects that are persistable
    to/from a stream.

--*/

class WSB_EXPORT CWsbObject : 
    public CWsbPersistStream,
    public IWsbCollectable,
    public IWsbTestable
{
// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);
    void FinalRelease(void);

// IWsbCollectable
public:
    STDMETHOD(CompareTo)(IUnknown* pCollectable, SHORT* pResult);
    STDMETHOD(IsEqual)(IUnknown* pCollectable);
};

#define WSB_FROM_CWSBOBJECT \
    STDMETHOD(IsEqual)(IUnknown* pObject) \
    {return(CWsbObject::IsEqual(pObject));}

/*++

Class Name:
    
    CWsbCollectable

Class Description:

    Base class for collectable objects that are persistable
    to/from stream, storage, or file.  CWsbObject should be used instead of
    this object unless storage and/or file persistence is absolutely necessary!
    If the object is persisted as part of a parent
    object, then only the parent object (or its parent) needs to support
    persistence to storage and/or file.

--*/

class WSB_EXPORT CWsbCollectable : 
    public CWsbPersistable,
    public IWsbCollectable,
    public IWsbTestable
{
// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);
    void FinalRelease(void);

// IWsbCollectable
public:
    STDMETHOD(CompareTo)(IUnknown* pCollectable, SHORT* pResult);
    STDMETHOD(IsEqual)(IUnknown* pCollectable);
};

#define WSB_FROM_CWSBCOLLECTABLE \
    STDMETHOD(IsEqual)(IUnknown* pCollectable) \
    {return(CWsbCollectable::IsEqual(pCollectable));}

#endif // _WSBCLTBL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\inc\wsbassrt.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    Wsbassrt.h

Abstract:

    This header file defines the part of the platform code that is
    responsible for the low level error handling used by all other
    modules.

Author:

    Rohde Wakefield    [rohde]   23-Oct-1996

Revision History:

    Brian Dodd         [brian]    6-Dec-1996
        added WsbAssertStatus, WsbAssertNoError, WsbAssertHandle
        added WsbAffirmStatus, WsbAffirmNoError, WsbAffirmHandle
    Michael Lotz       [lotz]     3-Mar-1997
        added WsbAffirmNtStatus
    Cat Brant          [cbrant]   10-Feb-1998
        added WsbAssertNtStatus

--*/

#include "stdio.h"
#include "crtdbg.h"

#include "wsbtrace.h"

#ifndef _WSBASSRT_
#define _WSBASSRT_

//
// The following macros should be used when dealing with
// many HRESULT return values in C++ exception handling.

/*++

Macro Name:

    WsbAssert

Macro Description:

    Should be used for checking conditions that if seen
    would be considered coding errors (i.e. the conditions should
    never occur).

Arguments:

    cond - A boolean expression for the condition to check.

    hr   - The result parameter to throw if the condition is false.

--*/

#define WsbAssert(cond, hr)         \
    if (!(cond)) {                  \
        WsbLogEvent(WSB_MESSAGE_PROGRAM_ASSERT, 0, NULL, WsbHrAsString(hr), NULL); \
        _ASSERTE(cond);             \
        WsbThrow(hr);               \
    }


/*++

Macro Name:

    WsbThrow

Macro Description:

    Throw the argument.

Arguments:

    hr - Parameter to throw.

--*/

#ifdef WSB_TRACE_IS
#define WsbThrow(hr)                                            \
    {                                                           \
        WsbTrace(OLESTR("WsbThrow <%hs>, <%d>, hr = <%ls>.\n"), __FILE__, __LINE__, WsbHrAsString(hr)); \
        throw((HRESULT)hr); \
    }
#else
#define WsbThrow(hr)                    throw((HRESULT)hr)
#endif


/*++

Macro Name:

    WsbAffirm

Macro Description:

    Should be used for checking conditions that are
    considered errors to the function (and the function should not
    continue), but are the result of errors that are allowable (although
    potentially rare). This function has failed, but the caller needs to
    determine whether this is a fatal problem, a problem that needs to
    be logged an worked around, or whether it can handle the problem.

Arguments:

    cond - A boolean expression for the condition to check.

    hr   - The result parameter to throw if the condition is false.

--*/

#define WsbAffirm(cond, hr)             if (!(cond)) WsbThrow(hr)

/*++

Macro Name:

    WsbAffirmHr

Macro Description:

   
    Similar to WsbAffirm(), but is used to wrap functions
    that return an HRESULT (normally COM methods).
   
    A sample use is:
   
        HRESULT hr = S_OK;
   
        try {
   
            WsbAssert(0 != pUnk);
            
            WsbAffirmHr(CoCreateInstance(...));
            
   
        } WsbCatch(hr)
   
        return (hr);
   

Arguments:

    hr  - Result from a function call.

--*/


#define WsbAffirmHr(hr)                 \
    {                                   \
        HRESULT     lHr;                \
        lHr = (hr);                     \
        WsbAffirm(SUCCEEDED(lHr), lHr); \
    }

#define WsbAffirmHrOk(hr)               \
    {                                   \
        HRESULT     lHr;                \
        lHr = (hr);                     \
        WsbAffirm(S_OK == lHr, lHr);    \
    }

/*++

Macro Name:

    WsbAssertHr

Macro Description:

    Similar to WsbAssert(), but is used to wrap functions
    that return an HRESULT (normally COM methods).

Arguments:

    hr  - Result from a function call.

--*/

#define WsbAssertHr(hr)                 \
    {                                   \
        HRESULT     lHr;                \
        lHr = (hr);                     \
        WsbAssert(SUCCEEDED(lHr), lHr); \
    }

/*++

Macro Name:

    WsbAssertHrOk

Macro Description:

    Checks that a function result is S_OK.

Arguments:

    hr  - Result from a function call.

--*/

#define WsbAssertHrOk(hr)               \
    {                                   \
        HRESULT     lHr;                \
        lHr = (hr);                     \
        WsbAssert(S_OK == lHr, lHr);    \
    }


/*++

Macro Name:

    WsbAssertStatus

Macro Description:

    Similar to WsbAssert(), but is used to wrap Win32 functions
    that return a BOOL status.

    This macro checks the status, and if FALSE, gets the
    last error and converts it to HRESULT, then asserts
    the result.

Arguments:

    status  - a BOOL result from a function call.

See Also:

    WsbAffirmStatus

--*/

#define WsbAssertStatus(status)         \
    {                                   \
        BOOL bStatus;                   \
        bStatus = (status);             \
        if (!bStatus) {                 \
            DWORD dwErr = GetLastError();               \
            HRESULT lHr = HRESULT_FROM_WIN32(dwErr);    \
            WsbAssert(SUCCEEDED(lHr), lHr);             \
        }                               \
    }

/*++

Macro Name:

    WsbAssertWin32

Macro Description:

    Similar to WsbAssert(), but is used to wrap Win32 functions
    that return a Win32 status.

    This macro checks the status, and if not ERROR_SUCCESS, 
    converts it to HRESULT, then asserts the result.

Arguments:

    status  - a Win32 result from a function call.

See Also:

    WsbAffirmStatus

--*/

#define WsbAssertWin32( status )        \
    {                                   \
        LONG lStatus;                   \
        lStatus = (status);             \
        if ( lStatus != ERROR_SUCCESS ) {               \
            HRESULT lHr = HRESULT_FROM_WIN32( lStatus );    \
            WsbAssert(SUCCEEDED(lHr), lHr);             \
        }                               \
    }

/*++

Macro Name:

    WsbAssertNoError

Macro Description:

    Similar to WsbAssert(), but is used to wrap Win32 functions
    that return a DWORD error code.  These functions return NO_ERROR
    if the function completed successfully.

    This macro checks the return value and if an error condition
    is detected, the error is converted to an HRESULT, then asserts
    the result.

Arguments:

    err - a DWORD result from a function call.

See Also:

    WsbAffirmNoError

--*/

#define WsbAssertNoError(retval)        \
    {                                   \
        DWORD dwErr;                    \
        dwErr = (retval);               \
        if (dwErr != NO_ERROR) {        \
            HRESULT lHr = HRESULT_FROM_WIN32(dwErr);    \
            WsbAssert(SUCCEEDED(lHr), lHr);             \
        }                               \
    }

/*++

Macro Name:

    WsbAssertHandle

Macro Description:

    Similar to WsbAssert(), but is used to wrap Win32 functions
    that return a HANDLE.

    This macro checks the handle and if it is invalid, gets the
    last error, converts it to an HRESULT, then asserts the result.

Arguments:

    hndl    - a HANDLE result from a function call.

See Also:

    WsbAffirmHandle

--*/

#define WsbAssertHandle(hndl)           \
    {                                   \
        HANDLE hHndl;                   \
        hHndl = (hndl);                 \
        if ((hHndl == INVALID_HANDLE_VALUE) || (hHndl == NULL)) { \
            DWORD dwErr = GetLastError();               \
            HRESULT lHr = HRESULT_FROM_WIN32(dwErr);    \
            WsbAssert(SUCCEEDED(lHr), lHr);             \
        }                               \
    }

/*++

Macro Name:

    WsbAssertPointer

Macro Description:

    Similar to WsbAssert(), but is used specifically to check for
    a valid pointer.

    This macro asserts that the pointer is non-zero, and throws
    E_POINTER if it is not.

Arguments:

    ptr     - the pointer to test.

See Also:

    WsbAffirmPointer

--*/

#define WsbAssertPointer( ptr )         \
    {                                   \
        WsbAssert( ptr != 0, E_POINTER);\
    }

/*++

Macro Name:

    WsbAssertAlloc

Macro Description:

    Similar to WsbAssert(), but is used specifically to check for
    a valid memory allocation.

    This macro asserts that the pointer is non-zero, and throws
    E_OUTOFMEMORY if it is not.

Arguments:

    ptr     - the pointer to test.

See Also:

    WsbAffirmAlloc

--*/

#define WsbAssertAlloc( ptr )         \
    {                                   \
        WsbAssert( (ptr) != 0, E_OUTOFMEMORY );\
    }

/*++

Macro Name:

    WsbAffirmStatus

Macro Description:

    Similar to WsbAffirm(), but is used to wrap Win32 functions
    that return a BOOL status.

    This macro checks the status, and if FALSE, gets the
    last error and converts it to HRESULT, then affirms
    the result.

Arguments:

    status  - a BOOL result from a function call.

See Also:

    WsbAssertStatus

--*/

#define WsbAffirmStatus(status)         \
    {                                   \
        BOOL bStatus;                   \
        bStatus = (status);             \
        if (!bStatus) {                 \
            DWORD dwErr = GetLastError();               \
            HRESULT lHr = HRESULT_FROM_WIN32(dwErr);    \
            WsbAffirm(SUCCEEDED(lHr), lHr);             \
        }                               \
    }

/*++

Macro Name:

    WsbAffirmWin32

Macro Description:

    Similar to WsbAssert(), but is used to wrap Win32 functions
    that return a Win32 status.

    This macro checks the status, and if not ERROR_SUCCESS, 
    converts it to HRESULT, then asserts the result.

Arguments:

    status  - a Win32 result from a function call.

See Also:

    WsbAffirmStatus

--*/

#define WsbAffirmWin32( status )        \
    {                                   \
        LONG lStatus;                   \
        lStatus = (status);             \
        if ( lStatus != ERROR_SUCCESS ) {               \
            HRESULT lHr = HRESULT_FROM_WIN32( lStatus );    \
            WsbAffirm(SUCCEEDED(lHr), lHr);             \
        }                               \
    }

/*++

Macro Name:

    WsbAffirmNtStatus

Macro Description:

    Similar to WsbAffirm(), but is used to wrap NT System functions
    that return a NTSTATUS result.

    This macro checks the status, and if not successful, gets the
    last error and converts it to HRESULT, then affirms
    the result.

Arguments:

    status  - a NTSTATUS result from a function call.

See Also:

    WsbAffirmStatus

--*/
#define WsbAffirmNtStatus(status)           \
    {                                   \
        NTSTATUS _ntStatus;             \
        _ntStatus = (NTSTATUS)( status );           \
        if ( !NT_SUCCESS( _ntStatus ) ) {           \
            HRESULT _lHr = HRESULT_FROM_NT( _ntStatus );    \
            WsbAffirm(SUCCEEDED(_lHr), _lHr);               \
        }                               \
    }

/*++

Macro Name:

    WsbAssertNtStatus

Macro Description:

    Similar to WsbAssert(), but is used to wrap NT System functions
    that return a NTSTATUS result.

    This macro checks the status, and if not successful, gets the
    last error and converts it to HRESULT, then affirms
    the result.

Arguments:

    status  - a NTSTATUS result from a function call.

See Also:

    WsbAssertStatus

--*/
#define WsbAssertNtStatus(status)           \
    {                                   \
        NTSTATUS _ntStatus;             \
        _ntStatus = (NTSTATUS)( status );           \
        if ( !NT_SUCCESS( _ntStatus ) ) {           \
            HRESULT _lHr = HRESULT_FROM_NT( _ntStatus );    \
            WsbAssert(SUCCEEDED(_lHr), _lHr);               \
        }                               \
    }
/*++

Macro Name:

    WsbAffirmLsaStatus

Macro Description:

    Similar to WsbAffirm(), but is used to wrap NT System functions
    that return a NTSTATUS result.

    This macro checks the status, and if not successful, gets the
    last error and converts it to HRESULT, then affirms
    the result.

Arguments:

    status  - a NTSTATUS result from a function call.

See Also:

    WsbAffirmStatus

--*/
#define WsbAffirmLsaStatus(status)          \
    {                                   \
        NTSTATUS _ntStatus;             \
        _ntStatus = (NTSTATUS)( status );           \
        if ( !NT_SUCCESS( _ntStatus ) ) {           \
            HRESULT _lHr = HRESULT_FROM_WIN32( LsaNtStatusToWinError(_ntStatus) );  \
            WsbAffirm(SUCCEEDED(_lHr), _lHr);               \
        }                               \
    }

/*++

Macro Name:

    WsbAffirmNoError

Macro Description:

    Similar to WsbAffirm(), but is used to wrap Win32 functions
    that return a DWORD error code.  These functions return NO_ERROR
    if the function completed successfully.

    This macro checks the return value and if an error condition
    is detected, the error is converted to an HRESULT, then affirms
    the result.

Arguments:

    err - a DWORD result from a function call.

See Also:

    WsbAssertNoError

--*/

#define WsbAffirmNoError(retval)        \
    {                                   \
        DWORD dwErr;                    \
        dwErr = (retval);               \
        if (dwErr != NO_ERROR) {        \
            HRESULT lHr = HRESULT_FROM_WIN32(dwErr);    \
            WsbAffirm(SUCCEEDED(lHr), lHr);             \
        }                               \
    }

/*++

Macro Name:

    WsbAffirmHandle

Macro Description:

    Similar to WsbAffirm(), but is used to wrap Win32 functions
    that return a HANDLE.

    This macro checks the handle and if it is invalid, gets the
    last error, converts it to an HRESULT, then affirms the result.

Arguments:

    hndl    - a HANDLE result from a function call.

See Also:

    WsbAssertHandle

--*/

#define WsbAffirmHandle(hndl)           \
    {                                   \
        HANDLE hHndl;                   \
        hHndl = (hndl);                 \
        if ((hHndl == INVALID_HANDLE_VALUE) || (hHndl == NULL)) { \
            DWORD dwErr = GetLastError();               \
            HRESULT lHr = HRESULT_FROM_WIN32(dwErr);    \
            WsbAffirm(SUCCEEDED(lHr), lHr);             \
        }                               \
    }

/*++

Macro Name:

    WsbAffirmPointer

Macro Description:

    Similar to WsbAffirm(), but is used specifically to check for
    a valid pointer.

    This macro affrims that the pointer is non-zero, and returns
    E_POINTER if it is not.

Arguments:

    ptr     - the pointer to test.

See Also:

    WsbAssertPointer

--*/

#define WsbAffirmPointer( ptr )         \
    {                                   \
        WsbAffirm( ptr != 0, E_POINTER);\
    }

/*++

Macro Name:

    WsbAffirmAlloc

Macro Description:

    Similar to WsbAffirm(), but is used specifically to check for
    a valid memory allocation.

    This macro affrims that the pointer is non-zero, and returns
    E_OUTOFMEMORY if it is not.

Arguments:

    ptr     - the pointer to test.

See Also:

    WsbAssertAlloc

--*/

#define WsbAffirmAlloc( ptr )         \
    {                                   \
        WsbAffirm( (ptr) != 0, E_OUTOFMEMORY );\
    }

/*++

Macro Name:

    WsbCatchAndDo

Macro Description:

    Catch an exception and execute some code.

Arguments:

    hr   - The result value that was thrown.

    code - Code to execute.

--*/

#define WsbCatchAndDo(hr, code)         \
    catch (HRESULT catchHr) {           \
        hr = catchHr;                   \
        { code }                        \
    }

/*++

Macro Name:

    WsbCatch

Macro Description:

    Catch an exception and save the error code value.

Arguments:

    hr   - The result value that was thrown.

--*/

#define WsbCatch(hr)                    \
    catch(HRESULT catchHr) {            \
        hr = catchHr;                   \
    }

#endif // _WSBASSRT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\inc\wsbfile.h ===
/*++

Copyright (c) 1996  Microsoft Corporation
 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    wsbfile.h

Abstract:

    This module defines very specific CRC algorithm code

Author:

    Christopher J. Timmes    [ctimmes@avail.com]   23 Jun 1997

Revision History:
    Michael Lotz    [lotz]      30-Sept-1997

--*/


#ifndef _WSBFILE_H
#define _WSBFILE_H

extern   unsigned long crc_32_tab[];



extern "C"
{
extern
WSB_EXPORT
HRESULT  WsbCRCReadFile    (  BYTE*                                     pchCurrent,
                              ULONG*                                    oldcrc32       );
}
            

// ---------- implementation code for WsbCalcCRCofFile() ----------

// This is the CRC calculation algorythm.
// It is called with the current byte in the file and the current CRC value,
// and uses the 'crc_32_tab[]' table. The crc_32_tab[] look up table is externed above and resides
// in the wsbfile.obj object module. Any function or method using the macro below must include
// the wsbfile.obj in the link list.
//
// For example, it can be used in the following way:
// unsigned long ulCRC ;
//    
//      INITIALIZE_CRC( ulCRC );
//      for( all *bytes* that are to be CRCed )
//          CALC_CRC( current_byte, ulCRC );
//      FINIALIZE_CRC( ulCRC );
// 
// at this point ulCRC is the CRC value and can be used as the calculated CRC value
// 

#define INITIALIZE_CRC( crc )  ((crc) = 0xFFFFFFFF )
#define CALC_CRC( octet, crc ) ((crc) = ( crc_32_tab[((crc)^ (octet)) & 0xff] ^ ((crc) >> 8) ) )
#define FINIALIZE_CRC( crc )   ((crc) = ~(crc) )

// ---------------------- Defines to identify the CRC calculation types -------------
#define WSB_CRC_CALC_NONE               0x00000000
// Identify this algorithm and the Microsoft 32 bit CRC calculation
#define WSB_CRC_CALC_MICROSOFT_32       0x00000001

#endif // _WSBFILE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\inc\wsbdbent.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    Wsbdbent.h

Abstract:

    The CWsbDbEntity class.

Author:

    Ron White   [ronw]   11-Dec-1996

Revision History:

--*/


#ifndef _WSBDBENT_
#define _WSBDBENT_

#include "wsbdb.h"


/*++

Class Name:

    CWsbDbEntity

Class Description:

    A data base entity.

--*/

class IDB_EXPORT CWsbDbEntity :
    public CWsbObject,
    public IWsbDbEntity,
    public IWsbDbEntityPriv
{

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);
    void FinalRelease(void);

// IWsbCollectable
public:
    STDMETHOD(CompareTo)(IUnknown* pCollectable, SHORT* pResult);
    WSB_FROM_CWSBOBJECT;

// IWsbDbEntity
public:
    STDMETHOD(Clone)(REFIID riid, void** ppEntity);
    STDMETHOD(Disconnect)(void);
    STDMETHOD(FindEQ)(void);
    STDMETHOD(FindGT)(void);
    STDMETHOD(FindGTE)(void);
    STDMETHOD(FindLT)(void);
    STDMETHOD(FindLTE)(void);
    STDMETHOD(First)(void);
    STDMETHOD(Last)(void);
    STDMETHOD(MarkAsNew)(void);
    STDMETHOD(Next)(void);
    STDMETHOD(Previous)(void);
    STDMETHOD(Print)(IStream* pStream);
    STDMETHOD(Remove)(void);
    STDMETHOD(UseKey)(ULONG type);
    STDMETHOD(Write)(void);
    STDMETHOD(SetSequentialScan)(void);
    STDMETHOD(ResetSequentialScan)(void);

// IWsbDbPriv - For internal use only!
    STDMETHOD(Copy)(IWsbDbEntity* pEntity);
    STDMETHOD(CopyValues)(ULONG flags, IWsbDbEntity* pEntity);
    STDMETHOD(GetCurKey)(IWsbDbKey** ppKey);
    STDMETHOD(GetKey)(ULONG KeyType, IWsbDbKey** ppKey);
    STDMETHOD(GetValue)(ULONG flag, ULONG* pValue);
    STDMETHOD(Init)(IWsbDb* pDb, IWsbDbSys *pDbSys, ULONG RecType, JET_SESID SessionId);
    STDMETHOD(SetValue)(ULONG flag, ULONG value);

// Derived Entity needs to define this:
    STDMETHOD(UpdateKey)(IWsbDbKey* /*pKey*/) { return(E_NOTIMPL); }

// Private utility functions
private:
    HRESULT compare(IWsbDbEntity* pEntity, SHORT* pResult);
    HRESULT fromMem(HGLOBAL hMem);
    HRESULT get_key(ULONG key_type, UCHAR* bytes, ULONG* pSize);
    HRESULT getMem(HGLOBAL* phMem);
    HRESULT toMem(HGLOBAL hMem, ULONG*  pSize);

    HRESULT jet_compare_field(ULONG col_id, UCHAR* bytes, ULONG size);
    HRESULT jet_get_data(void);
    HRESULT jet_make_current(void);
    HRESULT jet_move(LONG pos);
    HRESULT jet_seek(ULONG seek_flag);

protected:
    CComPtr<IWsbDbSys>  m_pDbSys;      // Pointer to associated Instance
    CComPtr<IWsbDb>     m_pDb;         // Pointer to associated DB
    COM_IDB_KEY_INFO*   m_pKeyInfo;    // Info. about rec. keys
    COM_IDB_REC_INFO    m_RecInfo;     // Rec. type, size, etc.
    BOOL                m_SaveAsNew;   // AsNew flag
    USHORT              m_UseKeyIndex; // Index into m_pKeyInfo of current control key

    ULONG               m_ColId;       // Jet column ID for record data
    HGLOBAL             m_hMem;        // Mem block for DB I/O
    LONG                m_SeqNum;      // Unique sequence number (for ID)
    BOOL                m_PosOk;       // Cursor is at current record?
    JET_SESID           m_SessionId;   // Jet session ID
    JET_TABLEID         m_TableId;     // Jet table ID

    BOOL                m_Sequential;  // Flag for sequential scan settings
};

#define WSB_FROM_CWSBDBENTITY_BASE \
    STDMETHOD(Clone)(REFIID riid, void** ppEntity) \
    {return(CWsbDbEntity::Clone(riid, ppEntity));} \
    STDMETHOD(Copy)(IWsbDbEntity* pEntity) \
    {return(CWsbDbEntity::Copy(pEntity)); } \
    STDMETHOD(Disconnect)(void) \
    {return(CWsbDbEntity::Disconnect());} \
    STDMETHOD(FindEQ)(void) \
    {return(CWsbDbEntity::FindEQ());} \
    STDMETHOD(FindGT)(void) \
    {return(CWsbDbEntity::FindGT());} \
    STDMETHOD(FindGTE)(void) \
    {return(CWsbDbEntity::FindGTE());} \
    STDMETHOD(FindLT)(void) \
    {return(CWsbDbEntity::FindLT());} \
    STDMETHOD(FindLTE)(void) \
    {return(CWsbDbEntity::FindLTE());} \
    STDMETHOD(First)(void) \
    {return(CWsbDbEntity::First());} \
    STDMETHOD(GetCurKey)(IWsbDbKey** ppKey) \
    {return(CWsbDbEntity::GetCurKey(ppKey)); } \
    STDMETHOD(Init)(IWsbDb* pDb, IWsbDbSys *pDbSys, ULONG RecType, ULONG Session) \
    {return(CWsbDbEntity::Init(pDb, pDbSys, RecType, Session)); } \
    STDMETHOD(Last)(void) \
    {return(CWsbDbEntity::Last());} \
    STDMETHOD(MarkAsNew)(void) \
    {return(CWsbDbEntity::MarkAsNew());} \
    STDMETHOD(Next)(void) \
    {return(CWsbDbEntity::Next());} \
    STDMETHOD(Previous)(void) \
    {return(CWsbDbEntity::Previous());} \
    STDMETHOD(Remove)(void) \
    {return(CWsbDbEntity::Remove());} \
    STDMETHOD(UseKey)(ULONG type) \
    {return(CWsbDbEntity::UseKey(type)); } \
    STDMETHOD(Write)(void) \
    {return(CWsbDbEntity::Write());} \
    STDMETHOD(SetSequentialScan)(void) \
    {return(CWsbDbEntity::SetSequentialScan());} \
    STDMETHOD(ResetSequentialScan)(void) \
    {return(CWsbDbEntity::ResetSequentialScan());} \


#define WSB_FROM_CWSBDBENTITY_IMP \
    STDMETHOD(CompareTo)(IUnknown* pCollectable, SHORT* pResult) \
    {return(CWsbDbEntity::CompareTo(pCollectable, pResult)); } \
    STDMETHOD(IsEqual)(IUnknown* pCollectable) \
    {return(CWsbDbEntity::IsEqual(pCollectable)); } \


#define WSB_FROM_CWSBDBENTITY \
    WSB_FROM_CWSBDBENTITY_BASE \
    WSB_FROM_CWSBDBENTITY_IMP


#endif // _WSBDBENT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\inc\wsbdb.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    Wsbdb.h

Abstract:

    These classes provide support for data bases.

Author:

    Ron White   [ronw]   19-Nov-1996

Revision History:

--*/


#ifndef _WSBDB_
#define _WSBDB_

// Are we defining imports or exports?
#if defined(IDB_IMPL)
#define IDB_EXPORT      __declspec(dllexport)
#else
#define IDB_EXPORT      __declspec(dllimport)
#endif

#include "wsbdef.h"
#include "wsbdbent.h"

#define IDB_MAX_REC_TYPES     16
#define IDB_MAX_KEYS_PER_REC  10

// Maximum key size in bytes; Jet limit is currently 255 so we limit
// all implementations
#define IDB_MAX_KEY_SIZE      255

//  IDB_SYS_INIT_FLAG_* flags for use with IWsbDbSys::Init
#define IDB_SYS_INIT_FLAG_FULL_LOGGING       0x00000000  // I.e. the default
#define IDB_SYS_INIT_FLAG_LIMITED_LOGGING    0x00000001
#define IDB_SYS_INIT_FLAG_SPECIAL_ERROR_MSG  0x00000002
#define IDB_SYS_INIT_FLAG_NO_BACKUP          0x00000004
#define IDB_SYS_INIT_FLAG_NO_LOGGING         0x00000008

//  IDB_CREATE_FLAG_* flags for use with IWsbDb::Create
#define IDB_CREATE_FLAG_NO_TRANSACTION       0x00000001
#define IDB_CREATE_FLAG_FIXED_SCHEMA         0x00000002

//  IDB_DELETE_FLAG_* flags for use with IWsbDb::Delete
#define IDB_DELETE_FLAG_NO_ERROR             0x00000001

//  IDB_DUMP_FLAG_* flags for use with IWsbDB::Dump
#define IDB_DUMP_FLAG_DB_INFO        0x00000001
#define IDB_DUMP_FLAG_REC_INFO       0x00000002
#define IDB_DUMP_FLAG_KEY_INFO       0x00000004
#define IDB_DUMP_FLAG_RECORDS        0x00000008
#define IDB_DUMP_FLAG_EVERYTHING     0x0000000F
#define IDB_DUMP_FLAG_RECORD_TYPE    0x00000010
#define IDB_DUMP_FLAG_APPEND_TO_FILE 0x00000100

//  IDB_KEY_FLAG_* flags for use in IDB_KEY_INFO structure:
#define IDB_KEY_FLAG_DUP_ALLOWED     0x00000001   // Duplicate keys allowed
#define IDB_KEY_FLAG_PRIMARY         0x00000002   // Primary key

//  IDB_KEY_INFO - data about record keys
//    Note: Only one key per record type can be a primary key.  The primary
//    key can not be modified in a record.  In general, the primary key is
//    used for the physical clustering of the records in the DB.

typedef struct : _COM_IDB_KEY_INFO {
//  ULONG  Type;       // Key type ID; must be > 0
//  ULONG  Size;       // Key size in bytes
//  ULONG  Flags;      // IDB_KEY_FLAG_* values
} IDB_KEY_INFO;


//  IDB_REC_FLAG_* flags for use in IDB_REC_INFO structur
#define IDB_REC_FLAG_VARIABLE   0x00000001 // Record size is not fixed

//  IDB_REC_INFO - data about IDB records
//    Note: It there are multiple keys, the first key is taken as the
//    default key to use for a new entity created by GetEntity.

typedef struct : _COM_IDB_REC_INFO {
    IDB_KEY_INFO *Key;    // Key info (must be allocated by derived DB object)
} IDB_REC_INFO;

//  IDB_BACKUP_FLAG_* flags for use with IWsbDbSys::Backup
#define IDB_BACKUP_FLAG_AUTO        0x00000001  // Start auto backup thread
#define IDB_BACKUP_FLAG_FORCE_FULL  0x00000002  // Force a full backup




/*++

Class Name:

    CWsbDb

Class Description:

    The base class for a data base object.

--*/

class IDB_EXPORT CWsbDb :
    public CWsbPersistable,
    public IWsbDbPriv
{
public:

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);
    void FinalRelease(void);

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pclsid);

// IPersistStream
public:
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER* /*pSize*/) {
            return(E_NOTIMPL); }
    STDMETHOD(Load)(IStream* pStream);
    STDMETHOD(Save)(IStream* pStream, BOOL clearDirty);

// IWsbDb
public:
    STDMETHOD(Close)(IWsbDbSession* pSession);
    STDMETHOD(Create)(OLECHAR* path, ULONG flags = 0);
    STDMETHOD(Delete)(OLECHAR* path, ULONG flags = 0);
    STDMETHOD(Dump)(OLECHAR* Filename, ULONG Flags, ULONG Data);
    STDMETHOD(GetEntity)(IWsbDbSession* pSession, ULONG RecId, REFIID riid, void** ppEntity);
    STDMETHOD(GetName)(OLECHAR** /*pName*/) { return(E_NOTIMPL); }
    STDMETHOD(GetPath)(OLECHAR** /*pPath*/) { return(E_NOTIMPL); }
    STDMETHOD(GetVersion)(ULONG* /*pVer*/) { return(E_NOTIMPL); }
    STDMETHOD(Locate)(OLECHAR* path);
    STDMETHOD(Open)(IWsbDbSession** ppSession);

    // IWsbDbPriv - For internal use only!
    STDMETHOD(GetKeyInfo)(ULONG RecType, USHORT nKeys, COM_IDB_KEY_INFO* pKeyInfo);
    STDMETHOD(GetRecInfo)(ULONG RecType, COM_IDB_REC_INFO* pRecInfo);
    STDMETHOD(Lock)(void) { CWsbPersistable::Lock(); return(S_OK); }
    STDMETHOD(Unlock)(void) { CWsbPersistable::Unlock(); return(S_OK); }

    STDMETHOD(GetJetIds)(JET_SESID SessionId, ULONG RecType,
                JET_TABLEID* pTableId, ULONG* pDataColId);
    STDMETHOD(GetJetIndexInfo)(JET_SESID SessionId, ULONG RecType, ULONG KeyType,
                ULONG* pColId, OLECHAR** pName, ULONG bufferSize);
    STDMETHOD(GetNewSQN)(ULONG /*RecType*/, ULONG* /*pSeqNum*/)
            { return(E_NOTIMPL); }

private:
    HRESULT db_info_from_file_block(void* block);
    HRESULT db_info_to_file_block(void* block);
    HRESULT rec_info_from_file_block(int index, void* block);
    HRESULT rec_info_to_file_block(int index, void* block);
    HRESULT session_current_index(IWsbDbSession* pSession);

    HRESULT jet_init(void);
    HRESULT jet_make_index_name(ULONG key_type, char* pName, ULONG bufsize);
    HRESULT jet_make_table_name(ULONG rec_type, char* pName, ULONG bufsize);
    HRESULT jet_load_info(void);
    HRESULT jet_save_info(void);

protected:
// Values to be supplied by derived class:

    CComPtr<IWsbDbSys>  m_pWsbDbSys;    // Strong reference to DbSys object - ensures that 
                                        //  this object dies after the DBs
                                        // Note: CWsbDbSys must NOT have strong reference to 
                                        //  objects of this class (WsbDb)
    ULONG               m_version;      // DB version
    USHORT              m_nRecTypes;    // Number of record (object) types
    IDB_REC_INFO*       m_RecInfo;      // Record/key info (must be allocated
                                        //  by derived DB object)

// Not to be changed by derived class:
    CWsbStringPtr   m_path;
    void *          m_pImp;  // Secret stuff

    ULONG           m_SessionIndex;

};

#define WSB_FROM_CWSBDB \
    STDMETHOD(Close)(IWsbDbSession* pSession) \
    {return(CWsbDb::Close(pSession));} \
    STDMETHOD(Create)(OLECHAR* path, ULONG flags = 0) \
    {return(CWsbDb::Create(path, flags));} \
    STDMETHOD(Delete)(OLECHAR* path, ULONG flags = 0) \
    {return(CWsbDb::Delete(path, flags));} \
    STDMETHOD(Dump)(OLECHAR* Filename, ULONG Flags, ULONG Data) \
    {return(CWsbDb::Dump(Filename, Flags, Data));} \
    STDMETHOD(GetEntity)(IWsbDbSession* pSession, ULONG RecId, REFIID riid, void** ppEntity) \
    {return(CWsbDb::GetEntity(pSession, RecId, riid, ppEntity));} \
    STDMETHOD(GetName)(OLECHAR** pName) \
    {return(CWsbDb::GetName(pName)); } \
    STDMETHOD(GetPath)(OLECHAR** pPath) \
    {return(CWsbDb::GetPath(pPath)); } \
    STDMETHOD(GetVersion)(ULONG* pVer) \
    {return(CWsbDb::GetVersion(pVer)); } \
    STDMETHOD(Locate)(OLECHAR* path) \
    {return(CWsbDb::Locate(path));} \
    STDMETHOD(Open)(IWsbDbSession** ppSession) \
    {return(CWsbDb::Open(ppSession));} \




#endif // _WSBDB_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\inc\wsbdate.h ===
#ifndef __WSBDATE_H__
#define __WSBDATE_H__

#include "time.h"

// WSBAPI is used on global public functions
#ifndef WSBAPI
        #define WSBAPI __stdcall
#endif


//      #ifdef _WSB_NO_WSB_SUPPORT
//          #error WSB classes not supported in this library variant.
//      #endif
//
//      #ifndef __WSBWIN_H__
//          #include <afxwin.h>
//      #endif
//
//      // include necessary WSB headers
//      #ifndef _OBJBASE_H_
//          #include <objbase.h>
//      #endif
//      #ifndef _WSBAUTO_H_
//          #include <oleauto.h>
//      #endif
//      #ifndef _WSBCTL_H_
//          #include <olectl.h>
//      #endif
//      //REVIEW: This header has no symbol to prevent repeated includes
//      #include <olectlid.h>
//      #ifndef __ocidl_h__
//          #include <ocidl.h>
//      #endif
//
//      #ifdef _WSB_MINREBUILD
//      #pragma component(minrebuild, off)
//      #endif
//      #ifndef _WSB_FULLTYPEINFO
//      #pragma component(mintypeinfo, on)
//      #endif
//
//      #ifndef _WSB_NOFORCE_LIBS
//      #ifndef _MAC
//
//      /////////////////////////////////////////////////////////////////////////////
//      // Win32 libraries
//
//      #ifdef _WSBDLL
//          #if defined(_DEBUG) && !defined(_WSB_MONOLITHIC)
//              #ifndef _UNICODE
//                  #pragma comment(lib, "mfco42d.lib")
//              #else
//                  #pragma comment(lib, "mfco42ud.lib")
//              #endif
//          #endif
//      #endif
//
//      #pragma comment(lib, "oledlg.lib")
//      #pragma comment(lib, "ole32.lib")
//      #pragma comment(lib, "olepro32.lib")
//      #pragma comment(lib, "oleaut32.lib")
//      #pragma comment(lib, "uuid.lib")
//      #pragma comment(lib, "urlmon.lib")
//
//      #else //!_MAC
//
//      /////////////////////////////////////////////////////////////////////////////
//      // Mac libraries
//
//      #ifdef _WSBDLL
//          #ifdef _DEBUG
//              #pragma comment(lib, "mfco42pd.lib")
//          #else
//              #pragma comment(lib, "mfco42p.lib")
//          #endif
//      #endif
//
//      #if !defined(_WSBDLL) && !defined(_USRDLL)
//          #ifdef _DEBUG
//              #pragma comment(lib, "wlmoled.lib")
//              #pragma comment(lib, "ole2uid.lib")
//          #else
//              #pragma comment(lib, "wlmole.lib")
//              #pragma comment(lib, "ole2ui.lib")
//          #endif
//          #pragma comment(linker, "/macres:ole2ui.rsc")
//      #else
//          #ifdef _DEBUG
//              #pragma comment(lib, "oledlgd.lib")
//              #pragma comment(lib, "msvcoled.lib")
//          #else
//              #pragma comment(lib, "oledlg.lib")
//              #pragma comment(lib, "msvcole.lib")
//          #endif
//      #endif
//
//      #pragma comment(lib, "uuid.lib")
//
//      #ifdef _DEBUG
//          #pragma comment(lib, "ole2d.lib")
//          #pragma comment(lib, "ole2autd.lib")
//      #else
//          #pragma comment(lib, "ole2.lib")
//          #pragma comment(lib, "ole2auto.lib")
//      #endif
//
//      #endif //_MAC
//      #endif //!_WSB_NOFORCE_LIBS
//
//      /////////////////////////////////////////////////////////////////////////////
//
//      #ifdef _WSB_PACKING
//      #pragma pack(push, _WSB_PACKING)
//      #endif
//
//      /////////////////////////////////////////////////////////////////////////////
//      // WSBDATE - MFC IDispatch & ClassFactory support
//
//      // Classes declared in this file
//
//      //CCmdTarget
//          class CWsbObjectFactory;    // glue for IClassFactory -> runtime class
//          class CWsbTemplateServer;       // server documents using CDocTemplate
//
//      class CWsbDispatchDriver;       // helper class to call IDispatch


//      class CWsbCurrency;     // Based on OLE CY
//      class CWsbSafeArray;    // Based on WSB VARIANT

//      //CException
//          class CWsbException;            // caught by client or server
//          class CWsbDispatchException;    // special exception for IDispatch calls


class CWsbDVariant;                     // WSB VARIANT wrapper
class CWsbDateTime;                     // Based on WSB DATE
class CWsbDateTimeSpan;                 // Based on a double

/////////////////////////////////////////////////////////////////////////////

//      // WSBDLL support
//      #undef WSB_DATA
//      #define WSB_DATA WSB_DATA
//
//      /////////////////////////////////////////////////////////////////////////////
//      // WSB COM (Component Object Model) implementation infrastructure
//      //      - data driven QueryInterface
//      //      - standard implementation of aggregate AddRef and Release
//      // (see CCmdTarget in WSBWIN.H for more information)
//
//      #define METHOD_PROLOGUE(theClass, localClass) \
//          theClass* pThis = \
//              ((theClass*)((BYTE*)this - offsetof(theClass, m_x##localClass))); \
//          WSB_MANAGE_STATE(pThis->m_pModuleState) \
//
//      #define METHOD_PROLOGUE_(theClass, localClass) \
//          theClass* pThis = \
//              ((theClass*)((BYTE*)this - offsetof(theClass, m_x##localClass))); \
//
//      #ifndef _WSB_NO_NESTED_DERIVATION
//      #define METHOD_PROLOGUE_EX(theClass, localClass) \
//          theClass* pThis = ((theClass*)((BYTE*)this - m_nOffset)); \
//          WSB_MANAGE_STATE(pThis->m_pModuleState) \
//
//      #define METHOD_PROLOGUE_EX_(theClass, localClass) \
//          theClass* pThis = ((theClass*)((BYTE*)this - m_nOffset)); \
//
//      #else
//      #define METHOD_PROLOGUE_EX(theClass, localClass) \
//          METHOD_PROLOGUE(theClass, localClass) \
//
//      #define METHOD_PROLOGUE_EX_(theClass, localClass) \
//          METHOD_PROLOGUE_(theClass, localClass) \
//
//      #endif
//
//      // Provided only for compatibility with CDK 1.x
//      #define METHOD_MANAGE_STATE(theClass, localClass) \
//          METHOD_PROLOGUE_EX(theClass, localClass) \
//
//      #define BEGIN_INTERFACE_PART(localClass, baseClass) \
//          class X##localClass : public baseClass \
//          { \
//          public: \
//              STDMETHOD_(ULONG, AddRef)(); \
//              STDMETHOD_(ULONG, Release)(); \
//              STDMETHOD(QueryInterface)(REFIID iid, LPVOID* ppvObj); \
//
//      #ifndef _WSB_NO_NESTED_DERIVATION
//      #define BEGIN_INTERFACE_PART_DERIVE(localClass, baseClass) \
//          class X##localClass : public baseClass \
//          { \
//          public: \
//
//      #else
//      #define BEGIN_INTERFACE_PART_DERIVE(localClass, baseClass) \
//          BEGIN_INTERFACE_PART(localClass, baseClass) \
//
//      #endif
//
//      #ifndef _WSB_NO_NESTED_DERIVATION
//      #define INIT_INTERFACE_PART(theClass, localClass) \
//              size_t m_nOffset; \
//              INIT_INTERFACE_PART_DERIVE(theClass, localClass) \
//
//      #define INIT_INTERFACE_PART_DERIVE(theClass, localClass) \
//              X##localClass() \
//                  { m_nOffset = offsetof(theClass, m_x##localClass); } \
//
//      #else
//      #define INIT_INTERFACE_PART(theClass, localClass)
//      #define INIT_INTERFACE_PART_DERIVE(theClass, localClass)
//
//      #endif
//
//      // Note: Inserts the rest of WSB functionality between these two macros,
//      //  depending upon the interface that is being implemented.  It is not
//      //  necessary to include AddRef, Release, and QueryInterface since those
//      //  member functions are declared by the macro.
//
//      #define END_INTERFACE_PART(localClass) \
//          } m_x##localClass; \
//          friend class X##localClass; \
//
//      #ifdef _WSBDLL
//      #define BEGIN_INTERFACE_MAP(theClass, theBase) \
//          const WSB_INTERFACEMAP* PASCAL theClass::_GetBaseInterfaceMap() \
//              { return &theBase::interfaceMap; } \
//          const WSB_INTERFACEMAP* theClass::GetInterfaceMap() const \
//              { return &theClass::interfaceMap; } \
//          const WSB_DATADEF WSB_INTERFACEMAP theClass::interfaceMap = \
//              { &theClass::_GetBaseInterfaceMap, &theClass::_interfaceEntries[0], }; \
//          const WSB_DATADEF WSB_INTERFACEMAP_ENTRY theClass::_interfaceEntries[] = \
//          { \
//
//      #else
//      #define BEGIN_INTERFACE_MAP(theClass, theBase) \
//          const WSB_INTERFACEMAP* theClass::GetInterfaceMap() const \
//              { return &theClass::interfaceMap; } \
//          const WSB_DATADEF WSB_INTERFACEMAP theClass::interfaceMap = \
//              { &theBase::interfaceMap, &theClass::_interfaceEntries[0], }; \
//          const WSB_DATADEF WSB_INTERFACEMAP_ENTRY theClass::_interfaceEntries[] = \
//          { \
//
//      #endif
//
//      #define INTERFACE_PART(theClass, iid, localClass) \
//              { &iid, offsetof(theClass, m_x##localClass) }, \
//
//      #define INTERFACE_AGGREGATE(theClass, theAggr) \
//              { NULL, offsetof(theClass, theAggr) }, \
//
//      #define END_INTERFACE_MAP() \
//              { NULL, (size_t)-1 } \
//          }; \

//      /////////////////////////////////////////////////////////////////////////////
//      // CWsbException - unexpected or rare WSB error returned
//
//      class CWsbException : public CException
//      {
//          DECLARE_DYNAMIC(CWsbException)
//
//      public:
//          SCODE m_sc;
//          static SCODE PASCAL Process(const CException* pAnyException);
//
//      // Implementation (use WsbThrowWsbException to create)
//      public:
//          CWsbException();
//          virtual ~CWsbException();
//
//          virtual BOOL GetErrorMessage(LPTSTR lpszError, UINT nMaxError,
//              PUINT pnHelpContext = NULL);
//      };
//
//      void WSBAPI WsbThrowWsbException(SCODE sc);

//      /////////////////////////////////////////////////////////////////////////////
//      // IDispatch specific exception
//
//      class CWsbDispatchException : public CException
//      {
//          DECLARE_DYNAMIC(CWsbDispatchException)
//
//      public:
//      // Attributes
//          WORD m_wCode;               // error code (specific to IDispatch implementation)
//          CString m_strDescription;   // human readable description of the error
//          DWORD m_dwHelpContext;      // help context for error
//
//          // usually empty in application which creates it (eg. servers)
//          CString m_strHelpFile;      // help file to use with m_dwHelpContext
//          CString m_strSource;        // source of the error (name of server)
//
//      // Implementation
//      public:
//          CWsbDispatchException(LPCTSTR lpszDescription, UINT nHelpID, WORD wCode);
//          virtual ~CWsbDispatchException();
//          static void PASCAL Process(
//              EXCEPINFO* pInfo, const CException* pAnyException);
//
//          virtual BOOL GetErrorMessage(LPTSTR lpszError, UINT nMaxError,
//              PUINT pnHelpContext = NULL);
//
//          SCODE m_scError;        // SCODE describing the error
//      };
//
//      void WSBAPI WsbThrowWsbDispatchException(WORD wCode, LPCTSTR lpszDescription,
//          UINT nHelpID = 0);
//      void WSBAPI WsbThrowWsbDispatchException(WORD wCode, UINT nDescriptionID,
//          UINT nHelpID = (UINT)-1);

//      /////////////////////////////////////////////////////////////////////////////
//      // Macros for CCmdTarget IDispatchable classes
//
//      #ifdef _WSBDLL
//      #define BEGIN_DISPATCH_MAP(theClass, baseClass) \
//          const WSB_DISPMAP* PASCAL theClass::_GetBaseDispatchMap() \
//              { return &baseClass::dispatchMap; } \
//          const WSB_DISPMAP* theClass::GetDispatchMap() const \
//              { return &theClass::dispatchMap; } \
//          const WSB_DISPMAP theClass::dispatchMap = \
//              { &theClass::_GetBaseDispatchMap, &theClass::_dispatchEntries[0], \
//                &theClass::_dispatchEntryCount, &theClass::_dwStockPropMask };  \
//          UINT theClass::_dispatchEntryCount = (UINT)-1; \
//          DWORD theClass::_dwStockPropMask = (DWORD)-1; \
//          const WSB_DISPMAP_ENTRY theClass::_dispatchEntries[] = \
//          { \
//
//      #else
//      #define BEGIN_DISPATCH_MAP(theClass, baseClass) \
//          const WSB_DISPMAP* theClass::GetDispatchMap() const \
//              { return &theClass::dispatchMap; } \
//          const WSB_DISPMAP theClass::dispatchMap = \
//              { &baseClass::dispatchMap, &theClass::_dispatchEntries[0], \
//                &theClass::_dispatchEntryCount, &theClass::_dwStockPropMask }; \
//          UINT theClass::_dispatchEntryCount = (UINT)-1; \
//          DWORD theClass::_dwStockPropMask = (DWORD)-1; \
//          const WSB_DISPMAP_ENTRY theClass::_dispatchEntries[] = \
//          { \
//
//      #endif
//
//      #define END_DISPATCH_MAP() \
//          { VTS_NONE, DISPID_UNKNOWN, VTS_NONE, VT_VOID, \
//              (WSB_PMSG)NULL, (WSB_PMSG)NULL, (size_t)-1, afxDispCustom } }; \
//
//      // parameter types: by value VTs
//      #define VTS_I2          "\x02"      // a 'short'
//      #define VTS_I4          "\x03"      // a 'long'
//      #define VTS_R4          "\x04"      // a 'float'
//      #define VTS_R8          "\x05"      // a 'double'
//      #define VTS_CY          "\x06"      // a 'CY' or 'CY*'
//      #define VTS_DATE        "\x07"      // a 'DATE'
//      #define VTS_WBSTR       "\x08"      // an 'LPCWSBSTR'
//      #define VTS_DISPATCH    "\x09"      // an 'IDispatch*'
//      #define VTS_SCODE       "\x0A"      // an 'SCODE'
//      #define VTS_BOOL        "\x0B"      // a 'BOOL'
//      #define VTS_VARIANT     "\x0C"      // a 'const VARIANT&' or 'VARIANT*'
//      #define VTS_UNKNOWN     "\x0D"      // an 'IUnknown*'
//      #if defined(_UNICODE) || defined(WSB2ANSI)
//          #define VTS_BSTR        VTS_WBSTR// an 'LPCWSBSTR'
//          #define VT_BSTRT        VT_BSTR
//      #else
//          #define VTS_BSTR        "\x0E"  // an 'LPCSTR'
//          #define VT_BSTRA        14
//          #define VT_BSTRT        VT_BSTRA
//      #endif
//
//      // parameter types: by reference VTs
//      #define VTS_PI2         "\x42"      // a 'short*'
//      #define VTS_PI4         "\x43"      // a 'long*'
//      #define VTS_PR4         "\x44"      // a 'float*'
//      #define VTS_PR8         "\x45"      // a 'double*'
//      #define VTS_PCY         "\x46"      // a 'CY*'
//      #define VTS_PDATE       "\x47"      // a 'DATE*'
//      #define VTS_PBSTR       "\x48"      // a 'BSTR*'
//      #define VTS_PDISPATCH   "\x49"      // an 'IDispatch**'
//      #define VTS_PSCODE      "\x4A"      // an 'SCODE*'
//      #define VTS_PBOOL       "\x4B"      // a 'VARIANT_BOOL*'
//      #define VTS_PVARIANT    "\x4C"      // a 'VARIANT*'
//      #define VTS_PUNKNOWN    "\x4D"      // an 'IUnknown**'
//
//      // special VT_ and VTS_ values
//      #define VTS_NONE        NULL        // used for members with 0 params
//      #define VT_MFCVALUE     0xFFF       // special value for DISPID_VALUE
//      #define VT_MFCBYREF     0x40        // indicates VT_BYREF type
//      #define VT_MFCMARKER    0xFF        // delimits named parameters (INTERNAL USE)
//
//      // variant handling (use V_BSTRT when you have ANSI BSTRs, as in DAO)
//      #ifndef _UNICODE
//          #define V_BSTRT(b)  (LPSTR)V_BSTR(b)
//      #else
//          #define V_BSTRT(b)  V_BSTR(b)
//      #endif
//
//      /////////////////////////////////////////////////////////////////////////////
//      // WSB control parameter types
//
//      #define VTS_COLOR           VTS_I4      // WSB_COLOR
//      #define VTS_XPOS_PIXELS     VTS_I4      // WSB_XPOS_PIXELS
//      #define VTS_YPOS_PIXELS     VTS_I4      // WSB_YPOS_PIXELS
//      #define VTS_XSIZE_PIXELS    VTS_I4      // WSB_XSIZE_PIXELS
//      #define VTS_YSIZE_PIXELS    VTS_I4      // WSB_YSIZE_PIXELS
//      #define VTS_XPOS_HIMETRIC   VTS_I4      // WSB_XPOS_HIMETRIC
//      #define VTS_YPOS_HIMETRIC   VTS_I4      // WSB_YPOS_HIMETRIC
//      #define VTS_XSIZE_HIMETRIC  VTS_I4      // WSB_XSIZE_HIMETRIC
//      #define VTS_YSIZE_HIMETRIC  VTS_I4      // WSB_YSIZE_HIMETRIC
//      #define VTS_TRISTATE        VTS_I2      // WSB_TRISTATE
//      #define VTS_OPTEXCLUSIVE    VTS_BOOL    // WSB_OPTEXCLUSIVE
//
//      #define VTS_PCOLOR          VTS_PI4     // WSB_COLOR*
//      #define VTS_PXPOS_PIXELS    VTS_PI4     // WSB_XPOS_PIXELS*
//      #define VTS_PYPOS_PIXELS    VTS_PI4     // WSB_YPOS_PIXELS*
//      #define VTS_PXSIZE_PIXELS   VTS_PI4     // WSB_XSIZE_PIXELS*
//      #define VTS_PYSIZE_PIXELS   VTS_PI4     // WSB_YSIZE_PIXELS*
//      #define VTS_PXPOS_HIMETRIC  VTS_PI4     // WSB_XPOS_HIMETRIC*
//      #define VTS_PYPOS_HIMETRIC  VTS_PI4     // WSB_YPOS_HIMETRIC*
//      #define VTS_PXSIZE_HIMETRIC VTS_PI4     // WSB_XSIZE_HIMETRIC*
//      #define VTS_PYSIZE_HIMETRIC VTS_PI4     // WSB_YSIZE_HIMETRIC*
//      #define VTS_PTRISTATE       VTS_PI2     // WSB_TRISTATE*
//      #define VTS_POPTEXCLUSIVE   VTS_PBOOL   // WSB_OPTEXCLUSIVE*
//
//      #define VTS_FONT            VTS_DISPATCH    // IFontDispatch*
//      #define VTS_PICTURE         VTS_DISPATCH    // IPictureDispatch*
//
//      #define VTS_HANDLE          VTS_I4      // WSB_HANDLE
//      #define VTS_PHANDLE         VTS_PI4     // WSB_HANDLE*
//
//      // these DISP_ macros cause the framework to generate the DISPID
//      #define DISP_FUNCTION(theClass, szExternalName, pfnMember, vtRetVal, vtsParams) \
//          { _T(szExternalName), DISPID_UNKNOWN, vtsParams, vtRetVal, \
//              (WSB_PMSG)(void (theClass::*)(void))&pfnMember, (WSB_PMSG)0, 0, \
//              afxDispCustom }, \
//
//      #define DISP_PROPERTY(theClass, szExternalName, memberName, vtPropType) \
//          { _T(szExternalName), DISPID_UNKNOWN, NULL, vtPropType, (WSB_PMSG)0, (WSB_PMSG)0, \
//              offsetof(theClass, memberName), afxDispCustom }, \
//
//      #define DISP_PROPERTY_NOTIFY(theClass, szExternalName, memberName, pfnAfterSet, vtPropType) \
//          { _T(szExternalName), DISPID_UNKNOWN, NULL, vtPropType, (WSB_PMSG)0, \
//              (WSB_PMSG)(void (theClass::*)(void))&pfnAfterSet, \
//              offsetof(theClass, memberName), afxDispCustom }, \
//
//      #define DISP_PROPERTY_EX(theClass, szExternalName, pfnGet, pfnSet, vtPropType) \
//          { _T(szExternalName), DISPID_UNKNOWN, NULL, vtPropType, \
//              (WSB_PMSG)(void (theClass::*)(void))&pfnGet, \
//              (WSB_PMSG)(void (theClass::*)(void))&pfnSet, 0, afxDispCustom }, \
//
//      #define DISP_PROPERTY_PARAM(theClass, szExternalName, pfnGet, pfnSet, vtPropType, vtsParams) \
//          { _T(szExternalName), DISPID_UNKNOWN, vtsParams, vtPropType, \
//              (WSB_PMSG)(void (theClass::*)(void))&pfnGet, \
//              (WSB_PMSG)(void (theClass::*)(void))&pfnSet, 0, afxDispCustom }, \
//
//      // these DISP_ macros allow the app to determine the DISPID
//      #define DISP_FUNCTION_ID(theClass, szExternalName, dispid, pfnMember, vtRetVal, vtsParams) \
//          { _T(szExternalName), dispid, vtsParams, vtRetVal, \
//              (WSB_PMSG)(void (theClass::*)(void))&pfnMember, (WSB_PMSG)0, 0, \
//              afxDispCustom }, \
//
//      #define DISP_PROPERTY_ID(theClass, szExternalName, dispid, memberName, vtPropType) \
//          { _T(szExternalName), dispid, NULL, vtPropType, (WSB_PMSG)0, (WSB_PMSG)0, \
//              offsetof(theClass, memberName), afxDispCustom }, \
//
//      #define DISP_PROPERTY_NOTIFY_ID(theClass, szExternalName, dispid, memberName, pfnAfterSet, vtPropType) \
//          { _T(szExternalName), dispid, NULL, vtPropType, (WSB_PMSG)0, \
//              (WSB_PMSG)(void (theClass::*)(void))&pfnAfterSet, \
//              offsetof(theClass, memberName), afxDispCustom }, \
//
//      #define DISP_PROPERTY_EX_ID(theClass, szExternalName, dispid, pfnGet, pfnSet, vtPropType) \
//          { _T(szExternalName), dispid, NULL, vtPropType, \
//              (WSB_PMSG)(void (theClass::*)(void))&pfnGet, \
//              (WSB_PMSG)(void (theClass::*)(void))&pfnSet, 0, afxDispCustom }, \
//
//      #define DISP_PROPERTY_PARAM_ID(theClass, szExternalName, dispid, pfnGet, pfnSet, vtPropType, vtsParams) \
//          { _T(szExternalName), dispid, vtsParams, vtPropType, \
//              (WSB_PMSG)(void (theClass::*)(void))&pfnGet, \
//              (WSB_PMSG)(void (theClass::*)(void))&pfnSet, 0, afxDispCustom }, \
//
//      // the DISP_DEFVALUE is a special case macro that creates an alias for DISPID_VALUE
//      #define DISP_DEFVALUE(theClass, szExternalName) \
//          { _T(szExternalName), DISPID_UNKNOWN, NULL, VT_MFCVALUE, \
//              (WSB_PMSG)0, (WSB_PMSG)0, 0, afxDispCustom }, \
//
//      #define DISP_DEFVALUE_ID(theClass, dispid) \
//          { NULL, dispid, NULL, VT_MFCVALUE, (WSB_PMSG)0, (WSB_PMSG)0, 0, \
//              afxDispCustom }, \
//
//      /////////////////////////////////////////////////////////////////////////////
//      // Macros for creating "creatable" automation classes.
//
//      #define DECLARE_WSBCREATE(class_name) \
//      public: \
//          static WSB_DATA CWsbObjectFactory factory; \
//          static WSB_DATA const GUID guid; \
//
//      #define IMPLEMENT_WSBCREATE(class_name, external_name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
//          WSB_DATADEF CWsbObjectFactory class_name::factory(class_name::guid, \
//              RUNTIME_CLASS(class_name), FALSE, _T(external_name)); \
//          const WSB_DATADEF GUID class_name::guid = \
//              { l, w1, w2, { b1, b2, b3, b4, b5, b6, b7, b8 } }; \
//
//      /////////////////////////////////////////////////////////////////////////////
//      // Helper class for driving IDispatch
//
//      class CWsbDispatchDriver
//      {
//      // Constructors
//      public:
//          CWsbDispatchDriver();
//          CWsbDispatchDriver(LPDISPATCH lpDispatch, BOOL bAutoRelease = TRUE);
//          CWsbDispatchDriver(const CWsbDispatchDriver& dispatchSrc);
//
//      // Attributes
//          LPDISPATCH m_lpDispatch;
//          BOOL m_bAutoRelease;
//
//      // Operations
//          BOOL CreateDispatch(REFCLSID clsid, CWsbException* pError = NULL);
//          BOOL CreateDispatch(LPCTSTR lpszProgID, CWsbException* pError = NULL);
//
//          void AttachDispatch(LPDISPATCH lpDispatch, BOOL bAutoRelease = TRUE);
//          LPDISPATCH DetachDispatch();
//              // detach and get ownership of m_lpDispatch
//          void ReleaseDispatch();
//
//          // helpers for IDispatch::Invoke
//          void WSB_CDECL InvokeHelper(DISPID dwDispID, WORD wFlags,
//              VARTYPE vtRet, void* pvRet, const BYTE* pbParamInfo, ...);
//          void WSB_CDECL SetProperty(DISPID dwDispID, VARTYPE vtProp, ...);
//          void GetProperty(DISPID dwDispID, VARTYPE vtProp, void* pvProp) const;
//
//          // special operators
//          operator LPDISPATCH();
//          const CWsbDispatchDriver& operator=(const CWsbDispatchDriver& dispatchSrc);
//
//      // Implementation
//      public:
//          ~CWsbDispatchDriver();
//          void InvokeHelperV(DISPID dwDispID, WORD wFlags, VARTYPE vtRet,
//              void* pvRet, const BYTE* pbParamInfo, va_list argList);
//      };
//
//      /////////////////////////////////////////////////////////////////////////////
//      // Class Factory implementation (binds WSB class factory -> runtime class)
//      //  (all specific class factories derive from this class factory)
//
//      class CWsbObjectFactory : public CCmdTarget
//      {
//          DECLARE_DYNAMIC(CWsbObjectFactory)
//
//      // Construction
//      public:
//          CWsbObjectFactory(REFCLSID clsid, CRuntimeClass* pRuntimeClass,
//              BOOL bMultiInstance, LPCTSTR lpszProgID);
//
//      // Attributes
//          virtual BOOL IsRegistered() const;
//          REFCLSID GetClassID() const;
//
//      // Operations
//          virtual BOOL Register();
//          void Revoke();
//          void UpdateRegistry(LPCTSTR lpszProgID = NULL);
//              // default uses m_lpszProgID if not NULL
//          BOOL IsLicenseValid();
//
//          static BOOL PASCAL RegisterAll();
//          static void PASCAL RevokeAll();
//          static BOOL PASCAL UpdateRegistryAll(BOOL bRegister = TRUE);
//
//      // Overridables
//      protected:
//          virtual CCmdTarget* OnCreateObject();
//          virtual BOOL UpdateRegistry(BOOL bRegister);
//          virtual BOOL VerifyUserLicense();
//          virtual BOOL GetLicenseKey(DWORD dwReserved, BSTR* pbstrKey);
//          virtual BOOL VerifyLicenseKey(BSTR bstrKey);
//
//      // Implementation
//      public:
//          virtual ~CWsbObjectFactory();
//      #ifdef _DEBUG
//          void AssertValid() const;
//          void Dump(CDumpContext& dc) const;
//      #endif
//
//      public:
//          CWsbObjectFactory* m_pNextFactory;  // list of factories maintained
//
//      protected:
//          DWORD m_dwRegister;         // registry identifier
//          CLSID m_clsid;          // registered class ID
//          CRuntimeClass* m_pRuntimeClass; // runtime class of CCmdTarget derivative
//          BOOL m_bMultiInstance;      // multiple instance?
//          LPCTSTR m_lpszProgID;       // human readable class ID
//          BYTE m_bLicenseChecked;
//          BYTE m_bLicenseValid;
//          BYTE m_bRegistered;         // is currently registered w/ system
//          BYTE m_bReserved;           // reserved for future use
//
//      // Interface Maps
//      public:
//          BEGIN_INTERFACE_PART(ClassFactory, IClassFactory2)
//              INIT_INTERFACE_PART(CWsbObjectFactory, ClassFactory)
//              STDMETHOD(CreateInstance)(LPUNKNOWN, REFIID, LPVOID*);
//              STDMETHOD(LockServer)(BOOL);
//              STDMETHOD(GetLicInfo)(LPLICINFO);
//              STDMETHOD(RequestLicKey)(DWORD, BSTR*);
//              STDMETHOD(CreateInstanceLic)(LPUNKNOWN, LPUNKNOWN, REFIID, BSTR,
//                  LPVOID*);
//          END_INTERFACE_PART(ClassFactory)
//
//          DECLARE_INTERFACE_MAP()
//
//          friend SCODE WSBAPI WsbDllGetClassObject(REFCLSID, REFIID, LPVOID*);
//          friend SCODE STDAPICALLTYPE DllGetClassObject(REFCLSID, REFIID, LPVOID*);
//      };
//
//      // Define CWsbObjectFactoryEx for compatibility with old CDK
//      #define CWsbObjectFactoryEx CWsbObjectFactory
//
//      //////////////////////////////////////////////////////////////////////////////
//      // CWsbTemplateServer - CWsbObjectFactory using CDocTemplates
//
//      // This enumeration is used in WsbWsbRegisterServerClass to pick the
//      //  correct registration entries given the application type.
//      enum WSB_APPTYPE
//      {
//          OAT_INPLACE_SERVER = 0,     // server has full server user-interface
//          OAT_SERVER = 1,         // server supports only embedding
//          OAT_CONTAINER = 2,      // container supports links to embeddings
//          OAT_DISPATCH_OBJECT = 3,    // IDispatch capable object
//          OAT_DOC_OBJECT_SERVER = 4,  // sever supports DocObject embedding
//          OAT_DOC_OBJECT_CONTAINER =5,// container supports DocObject clients
//      };
//
//      class CWsbTemplateServer : public CWsbObjectFactory
//      {
//      // Constructors
//      public:
//          CWsbTemplateServer();
//
//      // Operations
//          void ConnectTemplate(REFCLSID clsid, CDocTemplate* pDocTemplate,
//              BOOL bMultiInstance);
//              // set doc template after creating it in InitInstance
//          void UpdateRegistry(WSB_APPTYPE nAppType = OAT_INPLACE_SERVER,
//              LPCTSTR* rglpszRegister = NULL, LPCTSTR* rglpszOverwrite = NULL);
//              // may want to UpdateRegistry if not run with /Embedded
//          BOOL Register();
//
//      // Implementation
//      protected:
//          virtual CCmdTarget* OnCreateObject();
//          CDocTemplate* m_pDocTemplate;
//
//      private:
//          void UpdateRegistry(LPCTSTR lpszProgID);
//              // hide base class version of UpdateRegistry
//      };
//
//      /////////////////////////////////////////////////////////////////////////////
//      // System registry helpers
//
//      // Helper to register server in case of no .REG file loaded
//      BOOL WSBAPI WsbWsbRegisterServerClass(
//          REFCLSID clsid, LPCTSTR lpszClassName,
//          LPCTSTR lpszShortTypeName, LPCTSTR lpszLongTypeName,
//          WSB_APPTYPE nAppType = OAT_SERVER,
//          LPCTSTR* rglpszRegister = NULL, LPCTSTR* rglpszOverwrite = NULL,
//          int nIconIndex = 0, LPCTSTR lpszLocalFilterName = NULL);
//
//      // WsbWsbRegisterHelper is a worker function used by WsbWsbRegisterServerClass
//      //  (available for advanced registry work)
//      BOOL WSBAPI WsbWsbRegisterHelper(LPCTSTR const* rglpszRegister,
//          LPCTSTR const* rglpszSymbols, int nSymbols, BOOL bReplace,
//          HKEY hKeyRoot = ((HKEY)0x80000000)); // HKEY_CLASSES_ROOT
//
//      /////////////////////////////////////////////////////////////////////////////
//      // Connection maps
//
//      #define BEGIN_CONNECTION_PART(theClass, localClass) \
//          class X##localClass : public CConnectionPoint \
//          { \
//          public: \
//              X##localClass() \
//                  { m_nOffset = offsetof(theClass, m_x##localClass); }
//
//      #define CONNECTION_IID(iid) \
//              REFIID GetIID() { return iid; }
//
//      #define END_CONNECTION_PART(localClass) \
//          } m_x##localClass; \
//          friend class X##localClass;
//
//      #ifdef _WSBDLL
//      #define BEGIN_CONNECTION_MAP(theClass, theBase) \
//          const WSB_CONNECTIONMAP* PASCAL theClass::_GetBaseConnectionMap() \
//              { return &theBase::connectionMap; } \
//          const WSB_CONNECTIONMAP* theClass::GetConnectionMap() const \
//              { return &theClass::connectionMap; } \
//          const WSB_DATADEF WSB_CONNECTIONMAP theClass::connectionMap = \
//              { &theClass::_GetBaseConnectionMap, &theClass::_connectionEntries[0], }; \
//          const WSB_DATADEF WSB_CONNECTIONMAP_ENTRY theClass::_connectionEntries[] = \
//          { \
//
//      #else
//      #define BEGIN_CONNECTION_MAP(theClass, theBase) \
//          const WSB_CONNECTIONMAP* theClass::GetConnectionMap() const \
//              { return &theClass::connectionMap; } \
//          const WSB_DATADEF WSB_CONNECTIONMAP theClass::connectionMap = \
//              { &(theBase::connectionMap), &theClass::_connectionEntries[0], }; \
//          const WSB_DATADEF WSB_CONNECTIONMAP_ENTRY theClass::_connectionEntries[] = \
//          { \
//
//      #endif
//
//      #define CONNECTION_PART(theClass, iid, localClass) \
//              { &iid, offsetof(theClass, m_x##localClass) }, \
//
//      #define END_CONNECTION_MAP() \
//              { NULL, (size_t)-1 } \
//          }; \
//
//      /////////////////////////////////////////////////////////////////////////////
//      // CConnectionPoint
//
//      class CConnectionPoint : public CCmdTarget
//      {
//      // Constructors
//      public:
//          CConnectionPoint();
//
//      // Operations
//          POSITION GetStartPosition() const;
//          LPUNKNOWN GetNextConnection(POSITION& pos) const;
//          const CPtrArray* GetConnections();  // obsolete
//
//      // Overridables
//          virtual LPCONNECTIONPOINTCONTAINER GetContainer();
//          virtual REFIID GetIID() = 0;
//          virtual void OnAdvise(BOOL bAdvise);
//          virtual int GetMaxConnections();
//          virtual LPUNKNOWN QuerySinkInterface(LPUNKNOWN pUnkSink);
//
//      // Implementation
//          ~CConnectionPoint();
//          void CreateConnectionArray();
//          int GetConnectionCount();
//
//      protected:
//          size_t m_nOffset;
//          LPUNKNOWN m_pUnkFirstConnection;
//          CPtrArray* m_pConnections;
//
//      // Interface Maps
//      public:
//          BEGIN_INTERFACE_PART(ConnPt, IConnectionPoint)
//              INIT_INTERFACE_PART(CConnectionPoint, ConnPt)
//              STDMETHOD(GetConnectionInterface)(IID* pIID);
//              STDMETHOD(GetConnectionPointContainer)(
//                  IConnectionPointContainer** ppCPC);
//              STDMETHOD(Advise)(LPUNKNOWN pUnkSink, DWORD* pdwCookie);
//              STDMETHOD(Unadvise)(DWORD dwCookie);
//              STDMETHOD(EnumConnections)(LPENUMCONNECTIONS* ppEnum);
//          END_INTERFACE_PART(ConnPt)
//      };
//
//      /////////////////////////////////////////////////////////////////////////////
//      // EventSink Maps
//
//      #ifndef _WSB_NO_OCC_SUPPORT
//
//      #ifdef _WSBDLL
//      #define BEGIN_EVENTSINK_MAP(theClass, baseClass) \
//          const WSB_EVENTSINKMAP* PASCAL theClass::_GetBaseEventSinkMap() \
//              { return &baseClass::eventsinkMap; } \
//          const WSB_EVENTSINKMAP* theClass::GetEventSinkMap() const \
//              { return &theClass::eventsinkMap; } \
//          const WSB_EVENTSINKMAP theClass::eventsinkMap = \
//              { &theClass::_GetBaseEventSinkMap, &theClass::_eventsinkEntries[0], \
//                  &theClass::_eventsinkEntryCount }; \
//          UINT theClass::_eventsinkEntryCount = (UINT)-1; \
//          const WSB_EVENTSINKMAP_ENTRY theClass::_eventsinkEntries[] = \
//          { \
//
//      #else
//      #define BEGIN_EVENTSINK_MAP(theClass, baseClass) \
//          const WSB_EVENTSINKMAP* theClass::GetEventSinkMap() const \
//              { return &theClass::eventsinkMap; } \
//          const WSB_EVENTSINKMAP theClass::eventsinkMap = \
//              { &baseClass::eventsinkMap, &theClass::_eventsinkEntries[0], \
//                  &theClass::_eventsinkEntryCount }; \
//          UINT theClass::_eventsinkEntryCount = (UINT)-1; \
//          const WSB_EVENTSINKMAP_ENTRY theClass::_eventsinkEntries[] = \
//          { \
//
//      #endif
//
//      #define END_EVENTSINK_MAP() \
//          { VTS_NONE, DISPID_UNKNOWN, VTS_NONE, VT_VOID, \
//              (WSB_PMSG)NULL, (WSB_PMSG)NULL, (size_t)-1, afxDispCustom, \
//              (UINT)-1, 0 } }; \
//
//      #define ON_EVENT(theClass, id, dispid, pfnHandler, vtsParams) \
//          { _T(""), dispid, vtsParams, VT_BOOL, \
//              (WSB_PMSG)(void (theClass::*)(void))&pfnHandler, (WSB_PMSG)0, 0, \
//              afxDispCustom, id, (UINT)-1 }, \
//
//      #define ON_EVENT_RANGE(theClass, idFirst, idLast, dispid, pfnHandler, vtsParams) \
//          { _T(""), dispid, vtsParams, VT_BOOL, \
//              (WSB_PMSG)(void (theClass::*)(void))&pfnHandler, (WSB_PMSG)0, 0, \
//              afxDispCustom, idFirst, idLast }, \
//
//      #define ON_PROPNOTIFY(theClass, id, dispid, pfnRequest, pfnChanged) \
//          { _T(""), dispid, VTS_NONE, VT_VOID, \
//              (WSB_PMSG)(BOOL (CCmdTarget::*)(BOOL*))&pfnRequest, \
//              (WSB_PMSG)(BOOL (CCmdTarget::*)(void))&pfnChanged, \
//              1, afxDispCustom, id, (UINT)-1 }, \
//
//      #define ON_PROPNOTIFY_RANGE(theClass, idFirst, idLast, dispid, pfnRequest, pfnChanged) \
//          { _T(""), dispid, VTS_NONE, VT_VOID, \
//              (WSB_PMSG)(BOOL (CCmdTarget::*)(UINT, BOOL*))&pfnRequest, \
//              (WSB_PMSG)(BOOL (CCmdTarget::*)(UINT))&pfnChanged, \
//              1, afxDispCustom, idFirst, idLast }, \
//
//      #define ON_DSCNOTIFY(theClass, id, pfnNotify) \
//          { _T(""), DISPID_UNKNOWN, VTS_NONE, VT_VOID, \
//              (WSB_PMSG)(BOOL (CCmdTarget::*)(DSCSTATE, DSCREASON, BOOL*))&pfnNotify, (WSB_PMSG)0, \
//              1, afxDispCustom, id, (UINT)-1 }, \
//
//      #define ON_DSCNOTIFY_RANGE(theClass, idFirst, idLast, pfnNotify) \
//          { _T(""), DISPID_UNKNOWN, VTS_NONE, VT_VOID, \
//              (WSB_PMSG)(BOOL (CCmdTarget::*)(UINT, DSCSTATE, DSCREASON, BOOL*))&pfnNotify, (WSB_PMSG)0, \
//              1, afxDispCustom, idFirst, idLast }, \
//
//      #define ON_EVENT_REFLECT(theClass, dispid, pfnHandler, vtsParams) \
//          { _T(""), dispid, vtsParams, VT_BOOL, \
//              (WSB_PMSG)(void (theClass::*)(void))&pfnHandler, (WSB_PMSG)0, 0, \
//              afxDispCustom, (UINT)-1, (UINT)-1 }, \
//
//      #define ON_PROPNOTIFY_REFLECT(theClass, dispid, pfnRequest, pfnChanged) \
//          { _T(""), dispid, VTS_NONE, VT_VOID, \
//              (WSB_PMSG)(BOOL (CCmdTarget::*)(BOOL*))&pfnRequest, \
//              (WSB_PMSG)(BOOL (CCmdTarget::*)(void))&pfnChanged, \
//              1, afxDispCustom, (UINT)-1, (UINT)-1 }, \
//
//      #endif // !_WSB_NO_OCC_SUPPORT
//
//      /////////////////////////////////////////////////////////////////////////////
//      // Macros for type library information
//
//      CTypeLibCache* WSBAPI WsbGetTypeLibCache(const GUID* pTypeLibID);
//
//      #define DECLARE_WSBTYPELIB(class_name) \
//          protected: \
//              virtual UINT GetTypeInfoCount(); \
//              virtual HRESULT GetTypeLib(LCID, LPTYPELIB*); \
//              virtual CTypeLibCache* GetTypeLibCache(); \
//
//      #define IMPLEMENT_WSBTYPELIB(class_name, tlid, wVerMajor, wVerMinor) \
//          UINT class_name::GetTypeInfoCount() \
//              { return 1; } \
//          HRESULT class_name::GetTypeLib(LCID lcid, LPTYPELIB* ppTypeLib) \
//              { return ::LoadRegTypeLib(tlid, wVerMajor, wVerMinor, lcid, ppTypeLib); } \
//          CTypeLibCache* class_name::GetTypeLibCache() \
//              { WSB_MANAGE_STATE(m_pModuleState); return WsbGetTypeLibCache(&tlid); } \
//
//      /////////////////////////////////////////////////////////////////////////////
//      // Init & Term helpers
//
//      BOOL WSBAPI WsbWsbInit();
//      void WSBAPI WsbWsbTerm(BOOL bJustRevoke = FALSE);
//      void WSBAPI WsbWsbTermOrFreeLib(BOOL bTerm = TRUE, BOOL bJustRevoke = FALSE);
//
//      /////////////////////////////////////////////////////////////////////////////
//      // Memory management helpers (for WSB task allocator memory)
//
//      #define WsbAllocTaskMem(nSize) CoTaskMemAlloc(nSize)
//      #define WsbFreeTaskMem(p) CoTaskMemFree(p)
//
//      LPWSTR WSBAPI WsbAllocTaskWideString(LPCWSTR lpszString);
//      LPWSTR WSBAPI WsbAllocTaskWideString(LPCSTR lpszString);
//      LPSTR WSBAPI WsbAllocTaskAnsiString(LPCWSTR lpszString);
//      LPSTR WSBAPI WsbAllocTaskAnsiString(LPCSTR lpszString);
//
//      #ifdef _UNICODE
//          #define WsbAllocTaskString(x) WsbAllocTaskWideString(x)
//      #else
//          #define WsbAllocTaskString(x) WsbAllocTaskAnsiString(x)
//      #endif
//
//      #ifdef WSB2ANSI
//          #define WsbAllocTaskWsbString(x) WsbAllocTaskAnsiString(x)
//      #else
//          #define WsbAllocTaskWsbString(x) WsbAllocTaskWideString(x)
//      #endif
//
//      HRESULT WSBAPI WsbGetClassIDFromString(LPCTSTR lpsz, LPCLSID lpClsID);
//
//      /////////////////////////////////////////////////////////////////////////////
//      // Special in-proc server APIs
//
//      SCODE WSBAPI WsbDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);
//      SCODE WSBAPI WsbDllCanUnloadNow(void);

/////////////////////////////////////////////////////////////////////////////
// CWsbDVariant class helpers

#define WSB_TRUE (-1)
#define WSB_FALSE 0

class CLongBinary;                      // forward reference (see afxdb_.h)

/////////////////////////////////////////////////////////////////////////////
// CWsbDVariant class - wraps VARIANT types

typedef const VARIANT* LPCVARIANT;

class CWsbDVariant : public tagVARIANT
{
// Constructors
public:
    CWsbDVariant();

    CWsbDVariant(const VARIANT& varSrc);
    CWsbDVariant(LPCVARIANT pSrc);
    CWsbDVariant(const CWsbDVariant& varSrc);

    CWsbDVariant(LPCTSTR lpszSrc);
    CWsbDVariant(LPCTSTR lpszSrc, VARTYPE vtSrc); // used to set to ANSI string
//  CWsbDVariant(CString& strSrc);

    CWsbDVariant(BYTE nSrc);
    CWsbDVariant(short nSrc, VARTYPE vtSrc = VT_I2);
    CWsbDVariant(long lSrc, VARTYPE vtSrc = VT_I4);
//  CWsbDVariant(const CWsbCurrency& curSrc);

    CWsbDVariant(float fltSrc);
    CWsbDVariant(double dblSrc);
    CWsbDVariant(const CWsbDateTime& timeSrc);

//  CWsbDVariant(const CByteArray& arrSrc);
//  CWsbDVariant(const CLongBinary& lbSrc);

// Operations
public:
    void Clear();
    void ChangeType(VARTYPE vartype, LPVARIANT pSrc = NULL);
    void Attach(VARIANT& varSrc);
    VARIANT Detach();

    BOOL operator==(const VARIANT& varSrc) const;
    BOOL operator==(LPCVARIANT pSrc) const;

    const CWsbDVariant& operator=(const VARIANT& varSrc);
    const CWsbDVariant& operator=(LPCVARIANT pSrc);
    const CWsbDVariant& operator=(const CWsbDVariant& varSrc);

    const CWsbDVariant& operator=(const LPCTSTR lpszSrc);
//  const CWsbDVariant& operator=(const CString& strSrc);

    const CWsbDVariant& operator=(BYTE nSrc);
    const CWsbDVariant& operator=(short nSrc);
    const CWsbDVariant& operator=(long lSrc);
//  const CWsbDVariant& operator=(const CWsbCurrency& curSrc);

    const CWsbDVariant& operator=(float fltSrc);
    const CWsbDVariant& operator=(double dblSrc);
    const CWsbDVariant& operator=(const CWsbDateTime& dateSrc);

//  const CWsbDVariant& operator=(const CByteArray& arrSrc);
//  const CWsbDVariant& operator=(const CLongBinary& lbSrc);

    void SetString(LPCTSTR lpszSrc, VARTYPE vtSrc); // used to set ANSI string

    operator LPVARIANT();
    operator LPCVARIANT() const;

//      // Implementation
    public:
        ~CWsbDVariant();
};

// CWsbDVariant diagnostics and serialization
//      #ifdef _DEBUG
//      CDumpContext& WSBAPI operator<<(CDumpContext& dc, CWsbDVariant varSrc);
//      #endif
//      CArchive& WSBAPI operator<<(CArchive& ar, CWsbDVariant varSrc);
//      CArchive& WSBAPI operator>>(CArchive& ar, CWsbDVariant& varSrc);

// Helper for initializing VARIANT structures
void WSBAPI WsbDVariantInit(LPVARIANT pVar);

//      /////////////////////////////////////////////////////////////////////////////
//      // CWsbCurrency class
//
//      class CWsbCurrency
//      {
//      // Constructors
//      public:
//          CWsbCurrency();
//
//          CWsbCurrency(CURRENCY cySrc);
//          CWsbCurrency(const CWsbCurrency& curSrc);
//          CWsbCurrency(const VARIANT& varSrc);
//          CWsbCurrency(long nUnits, long nFractionalUnits);
//
//      // Attributes
//      public:
//          enum CurrencyStatus
//          {
//              valid = 0,
//              invalid = 1,    // Invalid currency (overflow, div 0, etc.)
//              null = 2,       // Literally has no value
//          };
//
//          CURRENCY m_cur;
//          CurrencyStatus m_status;
//
//          void SetStatus(CurrencyStatus status);
//          CurrencyStatus etStatus() const;
//
//      // Operations
//      public:
//          const CWsbCurrency& operator=(CURRENCY cySrc);
//          const CWsbCurrency& operator=(const CWsbCurrency& curSrc);
//          const CWsbCurrency& operator=(const VARIANT& varSrc);
//
//          BOOL operator==(const CWsbCurrency& cur) const;
//          BOOL operator!=(const CWsbCurrency& cur) const;
//          BOOL operator<(const CWsbCurrency& cur) const;
//          BOOL operator>(const CWsbCurrency& cur) const;
//          BOOL operator<=(const CWsbCurrency& cur) const;
//          BOOL operator>=(const CWsbCurrency& cur) const;
//
//          // Currency math
//          CWsbCurrency operator+(const CWsbCurrency& cur) const;
//          CWsbCurrency operator-(const CWsbCurrency& cur) const;
//          const CWsbCurrency& operator+=(const CWsbCurrency& cur);
//          const CWsbCurrency& operator-=(const CWsbCurrency& cur);
//          CWsbCurrency operator-() const;
//
//          CWsbCurrency operator*(long nOperand) const;
//          CWsbCurrency operator/(long nOperand) const;
//          const CWsbCurrency& operator*=(long nOperand);
//          const CWsbCurrency& operator/=(long nOperand);
//
//          operator CURRENCY() const;
//
//          // Currency definition
//          void SetCurrency(long nUnits, long nFractionalUnits);
//          BOOL ParseCurrency(LPCTSTR lpszCurrency, DWORD dwFlags = 0,
//              LCID = LANG_USER_DEFAULT);
//
//          // formatting
//          CString Format(DWORD dwFlags = 0, LCID lcid = LANG_USER_DEFAULT) const;
//      };
//
//      // CWsbCurrency diagnostics and serialization
//      #ifdef _DEBUG
//      CDumpContext& WSBAPI operator<<(CDumpContext& dc, CWsbCurrency curSrc);
//      #endif
//      CArchive& WSBAPI operator<<(CArchive& ar, CWsbCurrency curSrc);
//      CArchive& WSBAPI operator>>(CArchive& ar, CWsbCurrency& curSrc);

/////////////////////////////////////////////////////////////////////////////
// CWsbDateTime class helpers

#define WSB_DATETIME_ERROR (-1)

/////////////////////////////////////////////////////////////////////////////
// CWsbDateTime class

class CWsbDateTime
{
// Constructors
public:
    static CWsbDateTime PASCAL GetCurrentTime();

    CWsbDateTime();

    CWsbDateTime(const CWsbDateTime& dateSrc);
    CWsbDateTime(const VARIANT& varSrc);
    CWsbDateTime(DATE dtSrc);

    CWsbDateTime(time_t timeSrc);
    CWsbDateTime(const SYSTEMTIME& systimeSrc);
    CWsbDateTime(const FILETIME& filetimeSrc);

    CWsbDateTime(int nYear, int nMonth, int nDay,
        int nHour, int nMin, int nSec);
    CWsbDateTime(WORD wDosDate, WORD wDosTime);

// Attributes
public:
    enum DateTimeStatus
    {
        valid = 0,
        invalid = 1,    // Invalid date (out of range, etc.)
        null = 2,       // Literally has no value
    };

    DATE m_dt;
    DateTimeStatus m_status;

    void SetStatus(DateTimeStatus status);
    DateTimeStatus GetStatus() const;

    int GetYear() const;
    int GetMonth() const;       // month of year (1 = Jan)
    int GetDay() const;         // day of month (0-31)
    int GetHour() const;        // hour in day (0-23)
    int GetMinute() const;      // minute in hour (0-59)
    int GetSecond() const;      // second in minute (0-59)
    int GetDayOfWeek() const;   // 1=Sun, 2=Mon, ..., 7=Sat
    int GetDayOfYear() const;   // days since start of year, Jan 1 = 1

// Operations
public:
    const CWsbDateTime& operator=(const CWsbDateTime& dateSrc);
    const CWsbDateTime& operator=(const VARIANT& varSrc);
    const CWsbDateTime& operator=(DATE dtSrc);

    const CWsbDateTime& operator=(const time_t& timeSrc);
    const CWsbDateTime& operator=(const SYSTEMTIME& systimeSrc);
    const CWsbDateTime& operator=(const FILETIME& filetimeSrc);

    BOOL operator==(const CWsbDateTime& date) const;
    BOOL operator!=(const CWsbDateTime& date) const;
    BOOL operator<(const CWsbDateTime& date) const;
    BOOL operator>(const CWsbDateTime& date) const;
    BOOL operator<=(const CWsbDateTime& date) const;
    BOOL operator>=(const CWsbDateTime& date) const;

    // DateTime math
    CWsbDateTime operator+(const CWsbDateTimeSpan& dateSpan) const;
    CWsbDateTime operator-(const CWsbDateTimeSpan& dateSpan) const;
    const CWsbDateTime& operator+=(const CWsbDateTimeSpan dateSpan);
    const CWsbDateTime& operator-=(const CWsbDateTimeSpan dateSpan);

    // DateTimeSpan math
    CWsbDateTimeSpan operator-(const CWsbDateTime& date) const;

    operator DATE() const;

    BOOL SetDateTime(int nYear, int nMonth, int nDay,
        int nHour, int nMin, int nSec);
    BOOL SetDate(int nYear, int nMonth, int nDay);
    BOOL SetTime(int nHour, int nMin, int nSec);

//  BOOL ParseDateTime(LPCTSTR lpszDate, DWORD dwFlags = 0,
//      LCID lcid = LANG_USER_DEFAULT);

    // formatting
//          CString Format(DWORD dwFlags = 0, LCID lcid = LANG_USER_DEFAULT) const;
//          CString Format(LPCTSTR lpszFormat) const;
//          CString Format(UINT nFormatID) const;

// Implementation
protected:
    void CheckRange();
    friend CWsbDateTimeSpan;
};

// CWsbDateTime diagnostics and serialization
//      #ifdef _DEBUG
//      CDumpContext& WSBAPI operator<<(CDumpContext& dc, CWsbDateTime dateSrc);
//      #endif
//      CArchive& WSBAPI operator<<(CArchive& ar, CWsbDateTime dateSrc);
//      CArchive& WSBAPI operator>>(CArchive& ar, CWsbDateTime& dateSrc);

/////////////////////////////////////////////////////////////////////////////
// CWsbDateTimeSpan class
class CWsbDateTimeSpan
{
// Constructors
public:
    CWsbDateTimeSpan();

    CWsbDateTimeSpan(double dblSpanSrc);
    CWsbDateTimeSpan(const CWsbDateTimeSpan& dateSpanSrc);
    CWsbDateTimeSpan(long lDays, int nHours, int nMins, int nSecs);

// Attributes
public:
    enum DateTimeSpanStatus
    {
        valid = 0,
        invalid = 1,    // Invalid span (out of range, etc.)
        null = 2,       // Literally has no value
    };

    double m_span;
    DateTimeSpanStatus m_status;

    void SetStatus(DateTimeSpanStatus status);
    DateTimeSpanStatus GetStatus() const;

    double GetTotalDays() const;    // span in days (about -3.65e6 to 3.65e6)
    double GetTotalHours() const;   // span in hours (about -8.77e7 to 8.77e6)
    double GetTotalMinutes() const; // span in minutes (about -5.26e9 to 5.26e9)
    double GetTotalSeconds() const; // span in seconds (about -3.16e11 to 3.16e11)

    long GetDays() const;           // component days in span
    long GetHours() const;          // component hours in span (-23 to 23)
    long GetMinutes() const;        // component minutes in span (-59 to 59)
    long GetSeconds() const;        // component seconds in span (-59 to 59)

// Operations
public:
    const CWsbDateTimeSpan& operator=(double dblSpanSrc);
    const CWsbDateTimeSpan& operator=(const CWsbDateTimeSpan& dateSpanSrc);

    BOOL operator==(const CWsbDateTimeSpan& dateSpan) const;
    BOOL operator!=(const CWsbDateTimeSpan& dateSpan) const;
    BOOL operator<(const CWsbDateTimeSpan& dateSpan) const;
    BOOL operator>(const CWsbDateTimeSpan& dateSpan) const;
    BOOL operator<=(const CWsbDateTimeSpan& dateSpan) const;
    BOOL operator>=(const CWsbDateTimeSpan& dateSpan) const;

    // DateTimeSpan math
    CWsbDateTimeSpan operator+(const CWsbDateTimeSpan& dateSpan) const;
    CWsbDateTimeSpan operator-(const CWsbDateTimeSpan& dateSpan) const;
    const CWsbDateTimeSpan& operator+=(const CWsbDateTimeSpan dateSpan);
    const CWsbDateTimeSpan& operator-=(const CWsbDateTimeSpan dateSpan);
    CWsbDateTimeSpan operator-() const;

    operator double() const;

    void SetDateTimeSpan(long lDays, int nHours, int nMins, int nSecs);

    // formatting
//          CString Format(LPCTSTR pFormat) const;
//          CString Format(UINT nID) const;

// Implementation
public:
    void CheckRange();
    friend CWsbDateTime;
};

// CWsbDateTimeSpan diagnostics and serialization
//      #ifdef _DEBUG
//      CDumpContext& WSBAPI operator<<(CDumpContext& dc,CWsbDateTimeSpan dateSpanSrc);
//      #endif
//      CArchive& WSBAPI operator<<(CArchive& ar, CWsbDateTimeSpan dateSpanSrc);
//      CArchive& WSBAPI operator>>(CArchive& ar, CWsbDateTimeSpan& dateSpanSrc);

/////////////////////////////////////////////////////////////////////////////
// Helper for initializing CWsbSafeArray
//      void WSBAPI WsbSafeArrayInit(CWsbSafeArray* psa);

//      /////////////////////////////////////////////////////////////////////////////
//      // CSafeArray class
//
//      typedef const SAFEARRAY* LPCSAFEARRAY;
//
//      class CWsbSafeArray : public tagVARIANT
//      {
//      //Constructors
//      public:
//          CWsbSafeArray();
//          CWsbSafeArray(const SAFEARRAY& saSrc, VARTYPE vtSrc);
//          CWsbSafeArray(LPCSAFEARRAY pSrc, VARTYPE vtSrc);
//          CWsbSafeArray(const CWsbSafeArray& saSrc);
//          CWsbSafeArray(const VARIANT& varSrc);
//          CWsbSafeArray(LPCVARIANT pSrc);
//          CWsbSafeArray(const CWsbDVariant& varSrc);
//
//      // Operations
//      public:
//          void Clear();
//          void Attach(VARIANT& varSrc);
//          VARIANT Detach();
//
//          CWsbSafeArray& operator=(const CWsbSafeArray& saSrc);
//          CWsbSafeArray& operator=(const VARIANT& varSrc);
//          CWsbSafeArray& operator=(LPCVARIANT pSrc);
//          CWsbSafeArray& operator=(const CWsbDVariant& varSrc);
//
//          BOOL operator==(const SAFEARRAY& saSrc) const;
//          BOOL operator==(LPCSAFEARRAY pSrc) const;
//          BOOL operator==(const CWsbSafeArray& saSrc) const;
//          BOOL operator==(const VARIANT& varSrc) const;
//          BOOL operator==(LPCVARIANT pSrc) const;
//          BOOL operator==(const CWsbDVariant& varSrc) const;
//
//          operator LPVARIANT();
//          operator LPCVARIANT() const;
//
//          // One dim array helpers
//          void CreateOneDim(VARTYPE vtSrc, DWORD dwElements,
//              void* pvSrcData = NULL, long nLBound = 0);
//          DWORD GetOneDimSize();
//          void ResizeOneDim(DWORD dwElements);
//
//          // Multi dim array helpers
//          void Create(VARTYPE vtSrc, DWORD dwDims, DWORD* rgElements);
//
//          // SafeArray wrapper classes
//          void Create(VARTYPE vtSrc, DWORD dwDims, SAFEARRAYBOUND* rgsabounds);
//          void AccessData(void** ppvData);
//          void UnaccessData();
//          void AllocData();
//          void AllocDescriptor(DWORD dwDims);
//          void Copy(LPSAFEARRAY* ppsa);
//          void GetLBound(DWORD dwDim, long* pLBound);
//          void GetUBound(DWORD dwDim, long* pUBound);
//          void GetElement(long* rgIndices, void* pvData);
//          void PtrOfIndex(long* rgIndices, void** ppvData);
//          void PutElement(long* rgIndices, void* pvData);
//          void Redim(SAFEARRAYBOUND* psaboundNew);
//          void Lock();
//          void Unlock();
//          DWORD GetDim();
//          DWORD GetElemSize();
//          void Destroy();
//          void DestroyData();
//          void DestroyDescriptor();
//
//      //Implementation
//      public:
//          ~CWsbSafeArray();
//
//          // Cache info to make element access (operator []) faster
//          DWORD m_dwElementSize;
//          DWORD m_dwDims;
//      };
//
//      // CWsbSafeArray diagnostics and serialization
//      #ifdef _DEBUG
//      CDumpContext& WSBAPI operator<<(CDumpContext& dc, CWsbSafeArray saSrc);
//      #endif
//      CArchive& WSBAPI operator<<(CArchive& ar, CWsbSafeArray saSrc);
//      CArchive& WSBAPI operator>>(CArchive& ar, CWsbSafeArray& saSrc);

//      /////////////////////////////////////////////////////////////////////////////
//      // DDX_ functions for WSB controls on dialogs
//
//      #ifndef _WSB_NO_OCC_SUPPORT
//
//      void WSBAPI DDX_OCText(CDataExchange* pDX, int nIDC, DISPID dispid,
//          CString& value);
//      void WSBAPI DDX_OCTextRO(CDataExchange* pDX, int nIDC, DISPID dispid,
//          CString& value);
//      void WSBAPI DDX_OCBool(CDataExchange* pDX, int nIDC, DISPID dispid,
//          BOOL& value);
//      void WSBAPI DDX_OCBoolRO(CDataExchange* pDX, int nIDC, DISPID dispid,
//          BOOL& value);
//      void WSBAPI DDX_OCInt(CDataExchange* pDX, int nIDC, DISPID dispid,
//          int &value);
//      void WSBAPI DDX_OCIntRO(CDataExchange* pDX, int nIDC, DISPID dispid,
//          int &value);
//      void WSBAPI DDX_OCInt(CDataExchange* pDX, int nIDC, DISPID dispid,
//          long &value);
//      void WSBAPI DDX_OCIntRO(CDataExchange* pDX, int nIDC, DISPID dispid,
//          long &value);
//      void WSBAPI DDX_OCShort(CDataExchange* pDX, int nIDC, DISPID dispid,
//          short& value);
//      void WSBAPI DDX_OCShortRO(CDataExchange* pDX, int nIDC, DISPID dispid,
//          short& value);
//      void WSBAPI DDX_OCColor(CDataExchange* pDX, int nIDC, DISPID dispid,
//          WSB_COLOR& value);
//      void WSBAPI DDX_OCColorRO(CDataExchange* pDX, int nIDC, DISPID dispid,
//          WSB_COLOR& value);
//      void WSBAPI DDX_OCFloat(CDataExchange* pDX, int nIDC, DISPID dispid,
//          float& value);
//      void WSBAPI DDX_OCFloatRO(CDataExchange* pDX, int nIDC, DISPID dispid,
//          float& value);
//      void WSBAPI DDX_OCFloat(CDataExchange* pDX, int nIDC, DISPID dispid,
//          double& value);
//      void WSBAPI DDX_OCFloatRO(CDataExchange* pDX, int nIDC, DISPID dispid,
//                                double& value);
//
//      #endif // !_WSB_NO_OCC_SUPPORT
//
//      /////////////////////////////////////////////////////////////////////////////
//      // Function to enable containment of WSB controls
//
//      #ifndef _WSB_NO_OCC_SUPPORT
//      void WSB_CDECL WsbEnableControlContainer(COccManager* pOccManager=NULL);
//      #else
//      #define WsbEnableControlContainer()
//      #endif
//
//      /////////////////////////////////////////////////////////////////////////////
//      // Inline function declarations
//
//      #ifdef _WSB_PACKING
//      #pragma pack(pop)
//      #endif
//
//      #ifdef _WSB_ENABLE_INLINES
//      #define _WSBDATE_INLINE inline
//      #include <afxole.inl>
//      #undef _WSBDATE_INLINE
//      #endif
//
//      #undef WSB_DATA
//      #define WSB_DATA
//
//      #ifdef _WSB_MINREBUILD
//      #pragma component(minrebuild, on)
//      #endif
//      #ifndef _WSB_FULLTYPEINFO
//      #pragma component(mintypeinfo, off)
//      #endif
//


//
// Low level sanity checks for memory blocks
//
//     this was copied from afx.h

BOOL WSBAPI WsbIsValidAddress(const void* lp,
                        UINT nBytes, BOOL bReadWrite = TRUE);


//
// Inline Functions
//
//     These were copied from afxole.inl
//

#define _WSBDISP_INLINE inline

// CWsbDVariant
_WSBDISP_INLINE CWsbDVariant::CWsbDVariant()
    { WsbDVariantInit(this); }
_WSBDISP_INLINE CWsbDVariant::~CWsbDVariant()
    { ::VariantClear(this); }
_WSBDISP_INLINE CWsbDVariant::CWsbDVariant(LPCTSTR lpszSrc)
    { vt = VT_EMPTY; *this = lpszSrc; }
//      _WSBDISP_INLINE CWsbDVariant::CWsbDVariant(CString& strSrc)
//          { vt = VT_EMPTY; *this = strSrc; }
//      _WSBDISP_INLINE CWsbDVariant::CWsbDVariant(BYTE nSrc)
//          { vt = VT_UI1; bVal = nSrc; }
//      _WSBDISP_INLINE CWsbDVariant::CWsbDVariant(const CWsbCurrency& curSrc)
//          { vt = VT_CY; cyVal = curSrc.m_cur; }
_WSBDISP_INLINE CWsbDVariant::CWsbDVariant(float fltSrc)
    { vt = VT_R4; fltVal = fltSrc; }
_WSBDISP_INLINE CWsbDVariant::CWsbDVariant(double dblSrc)
    { vt = VT_R8; dblVal = dblSrc; }
_WSBDISP_INLINE CWsbDVariant::CWsbDVariant(const CWsbDateTime& dateSrc)
    { vt = VT_DATE; date = dateSrc.m_dt; }
//      _WSBDISP_INLINE CWsbDVariant::CWsbDVariant(const CByteArray& arrSrc)
//          { vt = VT_EMPTY; *this = arrSrc; }
//      _WSBDISP_INLINE CWsbDVariant::CWsbDVariant(const CLongBinary& lbSrc)
//          { vt = VT_EMPTY; *this = lbSrc; }
_WSBDISP_INLINE BOOL CWsbDVariant::operator==(LPCVARIANT pSrc) const
    { return *this == *pSrc; }
_WSBDISP_INLINE CWsbDVariant::operator LPVARIANT()
    { return this; }
_WSBDISP_INLINE CWsbDVariant::operator LPCVARIANT() const
    { return this; }


// CWsbDateTime
_WSBDISP_INLINE CWsbDateTime::CWsbDateTime()
    { m_dt = 0; SetStatus(valid); }
_WSBDISP_INLINE CWsbDateTime::CWsbDateTime(const CWsbDateTime& dateSrc)
    { m_dt = dateSrc.m_dt; m_status = dateSrc.m_status; }
_WSBDISP_INLINE CWsbDateTime::CWsbDateTime(const VARIANT& varSrc)
    { *this = varSrc; }
_WSBDISP_INLINE CWsbDateTime::CWsbDateTime(DATE dtSrc)
    { m_dt = dtSrc; SetStatus(valid); }
_WSBDISP_INLINE CWsbDateTime::CWsbDateTime(time_t timeSrc)
    { *this = timeSrc; }
_WSBDISP_INLINE CWsbDateTime::CWsbDateTime(const SYSTEMTIME& systimeSrc)
    { *this = systimeSrc; }
_WSBDISP_INLINE CWsbDateTime::CWsbDateTime(const FILETIME& filetimeSrc)
    { *this = filetimeSrc; }
_WSBDISP_INLINE CWsbDateTime::CWsbDateTime(int nYear, int nMonth, int nDay,
    int nHour, int nMin, int nSec)
    { SetDateTime(nYear, nMonth, nDay, nHour, nMin, nSec); }
_WSBDISP_INLINE CWsbDateTime::CWsbDateTime(WORD wDosDate, WORD wDosTime)
    { m_status = DosDateTimeToVariantTime(wDosDate, wDosTime, &m_dt) ?
        valid : invalid; }
_WSBDISP_INLINE const CWsbDateTime& CWsbDateTime::operator=(const CWsbDateTime& dateSrc)
    { m_dt = dateSrc.m_dt; m_status = dateSrc.m_status; return *this; }
_WSBDISP_INLINE CWsbDateTime::DateTimeStatus CWsbDateTime::GetStatus() const
    { return m_status; }
_WSBDISP_INLINE void CWsbDateTime::SetStatus(DateTimeStatus status)
    { m_status = status; }
_WSBDISP_INLINE BOOL CWsbDateTime::operator==(const CWsbDateTime& date) const
    { return (m_status == date.m_status && m_dt == date.m_dt); }
_WSBDISP_INLINE BOOL CWsbDateTime::operator!=(const CWsbDateTime& date) const
    { return (m_status != date.m_status || m_dt != date.m_dt); }
_WSBDISP_INLINE const CWsbDateTime& CWsbDateTime::operator+=(
    const CWsbDateTimeSpan dateSpan)
    { *this = *this + dateSpan; return *this; }
_WSBDISP_INLINE const CWsbDateTime& CWsbDateTime::operator-=(
    const CWsbDateTimeSpan dateSpan)
    { *this = *this - dateSpan; return *this; }
_WSBDISP_INLINE CWsbDateTime::operator DATE() const
    { return m_dt; }
_WSBDISP_INLINE CWsbDateTime::SetDate(int nYear, int nMonth, int nDay)
    { return SetDateTime(nYear, nMonth, nDay, 0, 0, 0); }
_WSBDISP_INLINE CWsbDateTime::SetTime(int nHour, int nMin, int nSec)
    // Set date to zero date - 12/30/1899
    { return SetDateTime(1899, 12, 30, nHour, nMin, nSec); }

// CWsbDateTimeSpan
_WSBDISP_INLINE CWsbDateTimeSpan::CWsbDateTimeSpan()
    { m_span = 0; SetStatus(valid); }
_WSBDISP_INLINE CWsbDateTimeSpan::CWsbDateTimeSpan(double dblSpanSrc)
    { m_span = dblSpanSrc; SetStatus(valid); }
_WSBDISP_INLINE CWsbDateTimeSpan::CWsbDateTimeSpan(
    const CWsbDateTimeSpan& dateSpanSrc)
    { m_span = dateSpanSrc.m_span; m_status = dateSpanSrc.m_status; }
_WSBDISP_INLINE CWsbDateTimeSpan::CWsbDateTimeSpan(
    long lDays, int nHours, int nMins, int nSecs)
    { SetDateTimeSpan(lDays, nHours, nMins, nSecs); }
_WSBDISP_INLINE CWsbDateTimeSpan::DateTimeSpanStatus CWsbDateTimeSpan::GetStatus() const
    { return m_status; }
_WSBDISP_INLINE void CWsbDateTimeSpan::SetStatus(DateTimeSpanStatus status)
    { m_status = status; }
_WSBDISP_INLINE double CWsbDateTimeSpan::GetTotalDays() const
    { WsbAssert(GetStatus() == valid, WSB_E_INVALID_DATA); return m_span; }
_WSBDISP_INLINE double CWsbDateTimeSpan::GetTotalHours() const
    { WsbAssert(GetStatus() == valid, WSB_E_INVALID_DATA); return m_span * 24; }
_WSBDISP_INLINE double CWsbDateTimeSpan::GetTotalMinutes() const
    { WsbAssert(GetStatus() == valid, WSB_E_INVALID_DATA); return m_span * 24 * 60; }
_WSBDISP_INLINE double CWsbDateTimeSpan::GetTotalSeconds() const
    { WsbAssert(GetStatus() == valid, WSB_E_INVALID_DATA); return m_span * 24 * 60 * 60; }
_WSBDISP_INLINE long CWsbDateTimeSpan::GetDays() const
    { WsbAssert(GetStatus() == valid, WSB_E_INVALID_DATA); return (long)m_span; }
_WSBDISP_INLINE BOOL CWsbDateTimeSpan::operator==(
    const CWsbDateTimeSpan& dateSpan) const
    { return (m_status == dateSpan.m_status &&
        m_span == dateSpan.m_span); }
_WSBDISP_INLINE BOOL CWsbDateTimeSpan::operator!=(
    const CWsbDateTimeSpan& dateSpan) const
    { return (m_status != dateSpan.m_status ||
        m_span != dateSpan.m_span); }
_WSBDISP_INLINE BOOL CWsbDateTimeSpan::operator<(
    const CWsbDateTimeSpan& dateSpan) const
    { WsbAssert(GetStatus() == valid, WSB_E_INVALID_DATA);
        WsbAssert(dateSpan.GetStatus() == valid, WSB_E_INVALID_DATA);
        return m_span < dateSpan.m_span; }
_WSBDISP_INLINE BOOL CWsbDateTimeSpan::operator>(
    const CWsbDateTimeSpan& dateSpan) const
    { WsbAssert(GetStatus() == valid, WSB_E_INVALID_DATA);
        WsbAssert(dateSpan.GetStatus() == valid, WSB_E_INVALID_DATA);
        return m_span > dateSpan.m_span; }
_WSBDISP_INLINE BOOL CWsbDateTimeSpan::operator<=(
    const CWsbDateTimeSpan& dateSpan) const
    { WsbAssert(GetStatus() == valid, WSB_E_INVALID_DATA);
        WsbAssert(dateSpan.GetStatus() == valid, WSB_E_INVALID_DATA);
        return m_span <= dateSpan.m_span; }
_WSBDISP_INLINE BOOL CWsbDateTimeSpan::operator>=(
    const CWsbDateTimeSpan& dateSpan) const
    { WsbAssert(GetStatus() == valid, WSB_E_INVALID_DATA);
        WsbAssert(dateSpan.GetStatus() == valid, WSB_E_INVALID_DATA);
        return m_span >= dateSpan.m_span; }
_WSBDISP_INLINE const CWsbDateTimeSpan& CWsbDateTimeSpan::operator+=(
    const CWsbDateTimeSpan dateSpan)
    { *this = *this + dateSpan; return *this; }
_WSBDISP_INLINE const CWsbDateTimeSpan& CWsbDateTimeSpan::operator-=(
    const CWsbDateTimeSpan dateSpan)
    { *this = *this - dateSpan; return *this; }
_WSBDISP_INLINE CWsbDateTimeSpan CWsbDateTimeSpan::operator-() const
    { return -this->m_span; }
_WSBDISP_INLINE CWsbDateTimeSpan::operator double() const
    { return m_span; }

#undef _WSBDISP_INLINE

#endif //__WSBDATE_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\inc\wsbgtarg.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    WsbGtArg.h

Abstract:

    Header file for Process command line arguments

Author:

    Greg White          [gregw]          1-Mar-1997

Revision History:

--*/

#if !defined(_WSBGTARG_)                // expand header only once
#define _WSBGTARG_

typedef     struct
{
    int     argType;                    // type of argument
    void    *argValue;                  // argument value ptr
    char    *argString;                 // argument identifier
}   WSB_COMMAND_LINE_ARGS;

typedef     struct
{
    int         argType;                // type of argument
    void        *argValue;              // argument value ptr
    wchar_t     *argString;             // argument identifier
}   WSB_WCOMMAND_LINE_ARGS;

#define WSB_ARG_FLAG        0           // argument is a flag
#define WSB_ARG_IFLAG       1           // argument is an inverted flag
#define WSB_ARG_CHAR        2           // argument has a char value
#define WSB_ARG_NUM         3           // argument has a number value
#define WSB_ARG_STR         4           // argument has a string value
#define WSB_ARG_PROC        5           // argument needs procedure evaluaton

#define EOS             (char) 0x00     // end of string

#define WEOS            (wchar_t) 0x00  // wide end of string



extern  int     WsbGetArgs (int argc, char **argv, WSB_COMMAND_LINE_ARGS *argdefs, int num_argdefs);

extern  void    WsbGetEnvArgs (int *old_argc, char ***old_argv, char *env_var);

extern  void    WsbSetArgUsage (char *msg);

extern  void    WsbBldErrMsg (char  *wOption, char  *wErrMsg);

extern  void    WsbArgUsage (char *msg);

extern  int     WsbWGetArgs (int argc, wchar_t **argv, WSB_WCOMMAND_LINE_ARGS *argdefs, int num_argdefs);

extern  void    WsbWGetEnvArgs (int *old_argc, wchar_t ***old_argv, char *env_var);

extern  void    WsbWSetArgUsage (wchar_t *msg);

extern  void    WsbWBldErrMsg (wchar_t  *wOption, wchar_t  *wErrMsg);

extern  void    WsbWArgUsage (wchar_t *msg);


#endif                                  // end of header expansion
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\inc\wsbfmt.h ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    wsbfmt.h

Abstract:

    Definitions for  file-system formatting support routines

Author:

    Ravisankar Pudipeddi [ravisp] 19, January 2000

Revision History:

--*/

#ifndef _WSBFMT_
#define _WSBFMT_

#ifdef __cplusplus
extern "C" {
#endif

#define FSTYPE_FAT      1
#define FSTYPE_FAT32    2
#define FSTYPE_NTFS     3

//
// Flags definition
//
#define WSBFMT_ENABLE_VOLUME_COMPRESSION 1


WSB_EXPORT HRESULT
FormatPartition(
    IN PWSTR volumeSpec, 
    IN LONG fsType, 
    IN PWSTR label,
    IN ULONG fsflags, 
    IN BOOLEAN quick, 
    IN BOOLEAN force,
    IN ULONG allocationUnitSize
);

#ifdef __cplusplus
}
#endif

#endif // _WSBFMT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\inc\wsbfirst.h ===
#ifndef _WSBFIRST_H
#define _WSBFIRST_H

/*++

Copyright (c) 1996  Microsoft Corporation
 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    wsbfirst.h

Abstract:

    This module defines some absolutely necessary stuff for WSB and other modules. This header is expected
    to be the first one included by Wsb.h

Author:

    Michael Lotz    [lotz]      12-Apr-1997

Revision History:

--*/

//
// Override values in \nt\public\inc\warning.h and other gotcha's
//
#pragma warning(3:4101)   // Unreferenced local variable
#pragma warning(3:4100)   // Unreferenced formal parameter
#pragma warning(3:4701)   // local may be used w/o init
#pragma warning(3:4702)   // Unreachable code
#pragma warning(3:4705)   // Statement has no effect
#pragma warning(3:4706)   // assignment w/i conditional expression
#pragma warning(3:4709)   // command operator w/o index expression
#pragma warning(3:4244)   // 'int' conversion warnings

// Demote warnings about: The string for a title or subtitle pragma exceeded the
// maximum allowable length and was truncated. These show up when generating
// browser info for ATL code.
#pragma warning(4:4786)   // command operator w/o index expression

// This supresses warning messages that come from exporting
// abstract classes derived from CComObjectRoot and that use
// COM templates.
#pragma warning(disable:4251 4275)

#include <atlbase.h>

//
// If you are building a service, make sure your precompiled header defines WSB_ATL_COM_SERVICE. Then _Module
// will be defined correctly for a service. Otherwise it we default to _Module being set correctly for a
// standard module.
//
#ifdef WSB_ATL_COM_SERVICE
// You may derive a class from CComModule and use it if you want to override
// something, but do not change the name of _Module
//

class CServiceModule : public CComModule
{
public:
    HRESULT RegisterServer(BOOL bRegTypeLib);
    HRESULT UnregisterServer();
    void Init(_ATL_OBJMAP_ENTRY* p, HINSTANCE h);
    void Start();
    void ServiceMain(DWORD dwArgc, LPTSTR* lpszArgv);
    DWORD HandlerEx(DWORD dwOpcode, DWORD fdwEventType,
            LPVOID lpEventData, LPVOID lpContext);
    void Run();
    BOOL IsInstalled();
    BOOL Install();
    BOOL Uninstall();
    LONG Unlock();
    void LogEvent(DWORD eventId, ...);
    void SetServiceStatus(DWORD dwState);

//Implementation
private:
    static void WINAPI _ServiceMain(DWORD dwArgc, LPTSTR* lpszArgv);
    static DWORD WINAPI _HandlerEx(DWORD dwOpcode, DWORD fdwEventType,
            LPVOID lpEventData, LPVOID lpContext);

// data members
public:
    TCHAR m_szServiceName[256];
    SERVICE_STATUS_HANDLE m_hServiceStatus;
    SERVICE_STATUS m_status;
    DWORD dwThreadID;
    BOOL m_bService;
};

extern CServiceModule _Module;

#else
//
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
//
extern CComModule _Module;

#endif

//
// Include the basic AtlCom.h file for the rest of the COM definitions
//
#include <atlcom.h>

// Are we defining imports or exports?
#ifdef WSB_IMPL
#define WSB_EXPORT      __declspec(dllexport)
#else
#define WSB_EXPORT      __declspec(dllimport)
#endif

//  Flag values used in HSM_SYSTEM_STATE structure
#define HSM_STATE_NONE        0x00000000
#define HSM_STATE_SHUTDOWN    0x00000001
#define HSM_STATE_SUSPEND     0x00000002
#define HSM_STATE_RESUME      0x00000004

//  Defines for memory alloc/realloc/free functions so we can track
//  memory usage
#if defined(WSB_TRACK_MEMORY)

#define WsbAlloc(_cb)                       WsbMemAlloc(_cb, __FILE__, __LINE__)
#define WsbFree(_pv)                        WsbMemFree(_pv, __FILE__, __LINE__)
#define WsbRealloc(_pv, _cb)                WsbMemRealloc(_pv, _cb, __FILE__, __LINE__)

#define WsbAllocString(_sz)                 WsbSysAllocString(_sz, __FILE__, __LINE__)
#define WsbAllocStringLen(_sz, _cc)         WsbSysAllocStringLen(_sz, _cc, __FILE__, __LINE__)
#define WsbFreeString(_bs)                  WsbSysFreeString(_bs, __FILE__, __LINE__)
#define WsbReallocString(_pb, _sz)          WsbSysReallocString(_pb, _sz, __FILE__, __LINE__)
#define WsbReallocStringLen(_pb, _sz, _cc)  WsbSysReallocStringLen(_pb, _sz, _cc, __FILE__, __LINE__)

#else

#define WsbAlloc(_cb)                       CoTaskMemAlloc(_cb)
#define WsbFree(_pv)                        CoTaskMemFree(_pv)
#define WsbRealloc(_pv, _cb)                CoTaskMemRealloc(_pv, _cb)

#define WsbAllocString(_sz)                 SysAllocString(_sz)
#define WsbAllocStringLen(_sz, _cc)         SysAllocStringLen(_sz, _cc)
#define WsbFreeString(_bs)                  SysFreeString(_bs)
#define WsbReallocString(_pb, _sz)          SysReAllocString(_pb, _sz)
#define WsbReallocStringLen(_pb, _sz, _cc)  SysReAllocStringLen(_pb, _sz, _cc)
#endif

#endif // _WSBFIRST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\inc\wsbgen.h ===
#ifndef _WSBGEN_H
#define _WSBGEN_H

/*++

Copyright (c) 1996  Microsoft Corporation
 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    wsbgen.h

Abstract:

    This module defines very basic WSB functions and defines that are general to WSB

Author:

    Michael Lotz    [lotz]      12-Apr-1997

Revision History:

--*/

// These macros define the module assignments for the error facilities.
// See also Facility Names, below.
#define WSB_FACILITY_PLATFORM           0x100
#define WSB_FACILITY_RMS                0x101
#define WSB_FACILITY_HSMENG             0x103
#define WSB_FACILITY_JOB                0x104
#define WSB_FACILITY_HSMTSKMGR          0x105
#define WSB_FACILITY_FSA                0x106
#define WSB_FACILITY_GUI                0x10a
#define WSB_FACILITY_MOVER              0x10b
#define WSB_FACILITY_LAUNCH             0x10c
#define WSB_FACILITY_TEST               0x10d
#define WSB_FACILITY_USERLINK           0x10e
#define WSB_FACILITY_CLI                0x10f

// Facility Names
#define WSB_FACILITY_PLATFORM_NAME      OLESTR("RsCommon.dll")
#define WSB_FACILITY_RMS_NAME           OLESTR("RsSub.dll")
#define WSB_FACILITY_HSMENG_NAME        OLESTR("RsEng.dll")
#define WSB_FACILITY_JOB_NAME           OLESTR("RsJob.dll")
#define WSB_FACILITY_HSMTSKMGR_NAME     OLESTR("RsTask.dll")
#define WSB_FACILITY_FSA_NAME           OLESTR("RsFsa.dll")
#define WSB_FACILITY_GUI_NAME           OLESTR("RsAdmin.dll")
#define WSB_FACILITY_MOVER_NAME         OLESTR("RsMover.dll")
#define WSB_FACILITY_LAUNCH_NAME        OLESTR("RsLaunch.exe")
#define WSB_FACILITY_TEST_NAME          OLESTR("RsTools.dll")
#define WSB_FACILITY_USERLINK_NAME      OLESTR("RsLnk.exe")
#define WSB_FACILITY_CLI_NAME           OLESTR("RsCli.dll")
#define WSB_FACILITY_NTDLL_NAME         OLESTR("ntdll.dll")

// COM Interface & Library Defintions
#define WSB_COLLECTION_MIN_INDEX        0
#define WSB_COLLECTION_MAX_INDEX        0xfffffffe

#define WSB_MAX_SERVICE_NAME            255

// Guids used to store User and Password for scheduled tasks
// Username {DC2D7CF0-6298-11d1-9F17-00A02488FCDE}
static const GUID GUID_Username = 
{ 0xdc2d7cf0, 0x6298, 0x11d1, { 0x9f, 0x17, 0x0, 0xa0, 0x24, 0x88, 0xfc, 0xde } };
// Password {DC2D7CF1-6298-11d1-9F17-00A02488FCDE}
static const GUID GUID_Password = 
{ 0xdc2d7cf1, 0x6298, 0x11d1, { 0x9f, 0x17, 0x0, 0xa0, 0x24, 0x88, 0xfc, 0xde } };

// Strings used to register event log categories
#define WSB_SVC_BASE         OLESTR("SYSTEM\\CurrentControlSet\\Services")
#define WSB_LOG_BASE         OLESTR("SYSTEM\\CurrentControlSet\\Services\\EventLog")
#define WSB_LOG_APP          OLESTR("Application")
#define WSB_LOG_SYS          OLESTR("System")
#define WSB_LOG_CAT_COUNT    OLESTR("CategoryCount")
#define WSB_LOG_CAT_FILE     OLESTR("CategoryMessageFile")
#define WSB_LOG_MESSAGE_FILE OLESTR("EventMessageFile")
#define WSB_LOG_TYPES        OLESTR("TypesSupported")

#define WSB_LOG_SOURCE_NAME  OLESTR("Remote Storage")
#define WSB_LOG_FILTER_NAME  OLESTR("RsFilter")

#define WSB_LOG_SVC_CATCOUNT 11
#define WSB_LOG_SVC_CATFILE  OLESTR("%SystemRoot%\\System32\\RsCommon.Dll")
#define WSB_LOG_SVC_MSGFILES OLESTR("%SystemRoot%\\System32\\RsCommon.Dll")

//
// Common Functions

// File/Directory
extern WSB_EXPORT HRESULT WsbCreateAllDirectories(OLECHAR* path);
extern WSB_EXPORT HRESULT WsbCreateAllDirectoriesForFile(OLECHAR* path);
extern WSB_EXPORT HRESULT WsbGetWin32PathAsBstr(OLECHAR* path, BSTR* pWin32Path);
extern WSB_EXPORT HRESULT WsbGetPathFromWin32AsBstr(OLECHAR* win32Path, BSTR* pPath);

inline char WsbSign( INT Val ) {
    return( Val > 0 ? (char)1 : ( ( Val < 0 ) ? (char)-1 : (char)0 ) );
}

// String & Buffer Copy
extern "C" {
    extern WSB_EXPORT HRESULT   WsbAllocAndCopyComString(OLECHAR** dest, OLECHAR* src, ULONG bufferSize);
    extern WSB_EXPORT HRESULT   WsbAllocAndCopyComString2(OLECHAR** dest, OLECHAR* src, ULONG bufferSize, BOOL inOrder);
    extern WSB_EXPORT HRESULT   WsbGetComBuffer(OLECHAR** dest, ULONG requestedSize, ULONG neededSize, BOOL* pWasAllocated);
    extern WSB_EXPORT HRESULT   WsbLoadComString(HINSTANCE hInstance, UINT uId, LPOLESTR* pszDest, ULONG ulBufferSize);
    extern WSB_EXPORT HRESULT   WsbMatchComString(OLECHAR* end, UINT uId, USHORT checks, UINT* idMatch);
}



// Filetime Manipulations

// NOTE: TICKS_PER_MONTH and TICKS_PER_YEAR are just approximations.
#define WSB_FT_TYPES_MAX            7
#define WSB_FT_TICKS_PER_SECOND     ((LONGLONG) 10000000)
#define WSB_FT_TICKS_PER_MINUTE     ((LONGLONG) ((LONGLONG) 60  * WSB_FT_TICKS_PER_SECOND))
#define WSB_FT_TICKS_PER_HOUR       ((LONGLONG) ((LONGLONG) 60  * WSB_FT_TICKS_PER_MINUTE))
#define WSB_FT_TICKS_PER_DAY        ((LONGLONG) ((LONGLONG) 24  * WSB_FT_TICKS_PER_HOUR))
#define WSB_FT_TICKS_PER_WEEK       ((LONGLONG) ((LONGLONG) 7   * WSB_FT_TICKS_PER_DAY))
#define WSB_FT_TICKS_PER_MONTH      ((LONGLONG) ((LONGLONG) 31  * WSB_FT_TICKS_PER_DAY))
#define WSB_FT_TICKS_PER_YEAR       ((LONGLONG) ((LONGLONG) 365 * WSB_FT_TICKS_PER_DAY))

extern "C" {
    extern WSB_EXPORT FILETIME  WsbFtSubFt(FILETIME ft1, FILETIME ft2);
    extern WSB_EXPORT SHORT     WsbCompareFileTimes(FILETIME ft1, FILETIME ft2, BOOL isRelative, BOOL isNewer);
}

// File name manipulations
extern WSB_EXPORT HRESULT SquashFilepath(WCHAR* pPath, UCHAR* pKey, ULONG keySize);

// Guid Manipulations

// Constant that can be used to determine necessary buffer size in doing
// GUID string operations. This includes the terminating L'\0'.

#define WSB_GUID_STRING_SIZE \
    (sizeof(L"{00000000-0000-0000-0000-000000000000}")/sizeof(wchar_t))

extern "C" {
    extern WSB_EXPORT int       WsbCompareGuid(REFGUID guid1, REFGUID guid2);
    extern WSB_EXPORT HRESULT   WsbStringFromGuid(REFGUID rguid, OLECHAR* sz);
    extern WSB_EXPORT HRESULT   WsbGuidFromString(const OLECHAR*, GUID * pguid);
}


// Type Conversion
#define WSB_FT_TO_WCS_ABS_STRLEN        20
#define WSB_VDATE_TO_WCS_ABS_STRLEN     20

extern "C" {
    extern WSB_EXPORT HRESULT   WsbWCStoFT(OLECHAR* wcs, BOOL* pIsRelative, FILETIME* pTime);
    extern WSB_EXPORT HRESULT   WsbWCStoLL(OLECHAR* wcs, LONGLONG* pvalue);
    extern WSB_EXPORT LONGLONG  WsbFTtoLL(FILETIME time);
    extern WSB_EXPORT FILETIME  WsbLLtoFT(LONGLONG value);
    extern WSB_EXPORT HRESULT   WsbFTtoWCS(BOOL isRelative, FILETIME time, OLECHAR** wcs, ULONG bufferSize);
    extern WSB_EXPORT HRESULT   WsbLLtoWCS(LONGLONG value, OLECHAR** wcs, ULONG ulBufferSize);
    extern WSB_EXPORT LONGLONG  WsbHLtoLL(LONG high, LONG low);
    extern WSB_EXPORT void      WsbLLtoHL(LONGLONG ll, LONG* pHigh, LONG* pLow);
    extern WSB_EXPORT HRESULT   WsbDatetoFT(DATE date, LONG ticks, FILETIME* pFt);
    extern WSB_EXPORT HRESULT   WsbFTtoDate(FILETIME ft, DATE* pDate, LONG* pTicks);
    extern WSB_EXPORT HRESULT   WsbLocalDateTicktoUTCFT(DATE date, LONG ticks, FILETIME* pFT);
    extern WSB_EXPORT HRESULT   WsbUTCFTtoLocalDateTick(FILETIME ft, DATE* pDate, LONG* pTicks);
    extern WSB_EXPORT HRESULT   WsbDateToString(DATE date, OLECHAR** string);
    extern WSB_EXPORT HRESULT   WsbStringToDate(OLECHAR* string, DATE* date);
}

// Account Helper functions
extern "C" {

extern WSB_EXPORT 
HRESULT
WsbGetAccountDomainName(
    OLECHAR * szDomainName,
    DWORD     cSize
    );

extern WSB_EXPORT
HRESULT
WsbGetServiceInfo(
    IN  GUID            guidApp,
    OUT OLECHAR **      pszServiceName, OPTIONAL
    OUT OLECHAR **      pszAccountName  OPTIONAL
    );

extern WSB_EXPORT
HRESULT
WsbGetServiceTraceDefaults(
    IN  OLECHAR* serviceName,
    IN  OLECHAR* traceName,
    IN  IUnknown* pUnk
    );

extern WSB_EXPORT
HRESULT
WsbGetMetaDataPath(
    OUT CWsbStringPtr & Path
    );


extern WSB_EXPORT
HRESULT
WsbGetComputerName(
    OUT CWsbStringPtr & String
    );

extern WSB_EXPORT
HRESULT
WsbGetLocalSystemName(
    OUT CWsbStringPtr & String
    );

}


// WsbSvc.h

extern WSB_EXPORT
HRESULT
WsbCheckService(
    IN  const OLECHAR * computer,
    IN  GUID            guidApp
    );

extern WSB_EXPORT
HRESULT
WsbGetServiceName(
    IN  const OLECHAR   *computer,
    IN  GUID            guidApp,
    IN  DWORD           cSize,
    OUT OLECHAR         *serviceName
    );

extern WSB_EXPORT
HRESULT
WsbGetServiceStatus(
    IN  const OLECHAR   *computer,
    IN  GUID            guidApp,
    OUT DWORD           *serviceStatus
    );


extern WSB_EXPORT HRESULT
WsbRegisterEventLogSource(
    IN  const WCHAR * LogName,
    IN  const WCHAR * SourceName,
    IN  DWORD         CategoryCount,
    IN  const WCHAR * CategoryMsgFile OPTIONAL,
    IN  const WCHAR * MsgFiles
    );

extern WSB_EXPORT HRESULT
WsbUnregisterEventLogSource(
    IN  const WCHAR * LogName,
    IN  const WCHAR * SourceName
    );

extern WSB_EXPORT HRESULT
WsbUnregisterRsFilter (
    BOOL bDisplay
    );

extern WSB_EXPORT HRESULT
WsbRegisterRsFilter (
    BOOL bDisplay
    );


extern WSB_EXPORT
HRESULT 
WsbGetServiceId(
    OLECHAR* serviceName, 
    GUID* pGuid 
    );

extern WSB_EXPORT
HRESULT 
WsbCreateServiceId(
    OLECHAR* serviceName, 
    GUID* pGuid 
    );

extern WSB_EXPORT
HRESULT 
WsbConfirmServiceId(
    OLECHAR* serviceName, 
    GUID guidConfirm 
    );

extern WSB_EXPORT
HRESULT 
WsbSetServiceId(
    OLECHAR* serviceName, 
    GUID guid 
    );

extern WSB_EXPORT
HRESULT
WsbCheckAccess(
    WSB_ACCESS_TYPE AccessType
    );

extern WSB_EXPORT
HRESULT
WsbCheckUsnJournalForChanges(
    OLECHAR*        volName,
    LONGLONG        FileId,
    LONGLONG        StartUsn,
    LONGLONG        StopUsn,
    BOOL*           pChanged
    );  


extern WSB_EXPORT
HRESULT 
WsbMarkUsnSource(
    HANDLE          changeHandle,
    OLECHAR*        volName
    );

extern WSB_EXPORT
HRESULT 
WsbGetUsnFromFileHandle(
    HANDLE          hFile,
    BOOL            ForceClose,
    LONGLONG*       pFileUsn
    );

extern WSB_EXPORT
HRESULT
WsbCreateUsnJournal(
    OLECHAR*        volName,
    ULONGLONG       usnSize
    );  

extern WSB_EXPORT
HRESULT
WsbGetResourceString(
    ULONG           id,
    WCHAR           **ppString
    );

extern WSB_EXPORT
HRESULT
WsbGetUsnJournalId(
    OLECHAR*        volName,
    ULONGLONG*      usnId
    );

class WSB_EXPORT CWsbSecurityDescriptor : public CSecurityDescriptor
{
public:
    HRESULT AllowRid( DWORD Rid, DWORD dwAccessMask );
};


#endif // _WSBGEN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\inc\wsbpstbl.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    wsbpstbl.h

Abstract:

    Abstract classes that provides persistence methods.

Author:

    Chuck Bardeen   [cbardeen]   29-Oct-1996

Revision History:

--*/

#ifndef _WSBPSTBL_
#define _WSBPSTBL_

#include "wsbpstrg.h"

// The name of the stream that is created when objects are persisted
// to structured storage files.
#define WSB_PERSIST_DEFAULT_STREAM_NAME     OLESTR("WsbStuff")

// The size of the overhead associated with persisting an object.
#define WSB_PERSIST_BASE_SIZE           sizeof(CLSID)

// Times used for autosave functionality
#define DEFAULT_AUTOSAVE_INTERVAL  (5 * 60 * 1000)    // 5 minutes
#define MAX_AUTOSAVE_INTERVAL  (24 * 60 * 60 * 1000)  // 24 hours

// Macros to help determine how much space is needed to persist an
// object or a portion of an object.
#define WsbPersistSize(a)               (WSB_PERSIST_BASE_SIZE + a)
#define WsbPersistSizeOf(a)             (WsbPersistSize(sizeof(a)))

/*++

Enumeration Name:
    WSB_PERSIST_STATE

Description:

 An enumeration that indicates the state of the persistance object. The
 states actually used depend on the type of persistance which is used.

--*/
typedef enum {
    WSB_PERSIST_STATE_UNINIT        = 0,   // Uninitialized
    WSB_PERSIST_STATE_NORMAL        = 1,   // Normal state
    WSB_PERSIST_STATE_NOSCRIBBLE    = 2,   // No scribble state
    WSB_PERSIST_STATE_RELEASED      = 3    // File was released
} WSB_PERSIST_STATE;



/*++

Class Name:
    
    CWsbPersistStream

Class Description:

    An object persistable to/from a stream.

    This is really an abstract class, but is constructable so that
    other class can delegate to it.

--*/

class WSB_EXPORT CWsbPersistStream : 
    public CComObjectRoot,
    public IPersistStream,
    public IWsbPersistStream
{
BEGIN_COM_MAP(CWsbPersistStream)
    COM_INTERFACE_ENTRY(IPersist)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IWsbPersistStream)
END_COM_MAP()

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);
    void FinalRelease(void);

#if defined(WSB_TRACK_MEMORY)
    ULONG InternalAddRef( );
    ULONG InternalRelease( );
#endif

// IPersistStream
public:
    STDMETHOD(IsDirty)(void);

// IWsbPersistStream
public:
    STDMETHOD(SetIsDirty)(BOOL bIsDirty);

protected:
    BOOL                        m_isDirty;
};


/*++

Class Name:
    
    CWsbPersistable 

Class Description:

    A object persistable to/from a stream, storage, or file.

    This is really an abstract class, but is constructable so that
    other class can delegate to it.  CWsbPersistStream should be used
    instead of this class unless storage and/or file persistence is
    absolutely necessary! If the object is persisted as part of a parent
    object, then only the parent object (or its parent) needs to support
    persistence to storage and/or file.

--*/

class WSB_EXPORT CWsbPersistable : 
    public CWsbPersistStream,
    public IPersistFile,
    public IWsbPersistable
{
BEGIN_COM_MAP(CWsbPersistable)
    COM_INTERFACE_ENTRY2(IPersist, CWsbPersistStream)
    COM_INTERFACE_ENTRY2(IPersistStream, CWsbPersistStream)
    COM_INTERFACE_ENTRY2(IWsbPersistStream, CWsbPersistStream)
    COM_INTERFACE_ENTRY(IPersistFile)
    COM_INTERFACE_ENTRY(IWsbPersistable)
END_COM_MAP()

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);
    void FinalRelease(void);

// IPersistFile
public:
    STDMETHOD(GetCurFile)(LPOLESTR* pszFileName);
    STDMETHOD(Load)(LPCOLESTR pszFileName, DWORD dwMode);
    STDMETHOD(Save)(LPCOLESTR pszFileName, BOOL bRemember);
    STDMETHOD(SaveCompleted)(LPCOLESTR pszFileName);

// IWsbPersistStream
    STDMETHOD(IsDirty)(void)
        { return(CWsbPersistStream::IsDirty()); }
    STDMETHOD(SetIsDirty)(BOOL bIsDirty)
        { return(CWsbPersistStream::SetIsDirty(bIsDirty)); }

// IWsbPersistable
public:
    STDMETHOD(GetDefaultFileName)(LPOLESTR* pszFileName, ULONG ulBufferSize);
    STDMETHOD(ReleaseFile)(void);
    STDMETHOD(SetDefaultFileName)(LPOLESTR pszFileName);

protected:
    WSB_PERSIST_STATE           m_persistState;
    CWsbStringPtr               m_persistFileName;
    CWsbStringPtr               m_persistDefaultName;
    CComPtr<IStorage>           m_persistStorage;
    CComPtr<IStream>            m_persistStream;
};


// Persistence Helper Functions
extern WSB_EXPORT HRESULT WsbLoadFromStream(IStream* pStream, BOOL* pValue);
extern WSB_EXPORT HRESULT WsbLoadFromStream(IStream* pStream, GUID* pValue);
extern WSB_EXPORT HRESULT WsbLoadFromStream(IStream* pStream, LONG* pValue);
extern WSB_EXPORT HRESULT WsbLoadFromStream(IStream* pStream, SHORT* pValue);
extern WSB_EXPORT HRESULT WsbLoadFromStream(IStream* pStream, BYTE* pValue);
extern WSB_EXPORT HRESULT WsbLoadFromStream(IStream* pStream, UCHAR* pValue, ULONG bufferSize);
extern WSB_EXPORT HRESULT WsbLoadFromStream(IStream* pStream, OLECHAR** pValue, ULONG bufferSize);
extern WSB_EXPORT HRESULT WsbLoadFromStream(IStream* pStream, ULONG* pValue);
extern WSB_EXPORT HRESULT WsbLoadFromStream(IStream* pStream, USHORT* pValue);
extern WSB_EXPORT HRESULT WsbLoadFromStream(IStream* pStream, LONGLONG* pValue);
extern WSB_EXPORT HRESULT WsbLoadFromStream(IStream* pStream, ULONGLONG* pValue);
extern WSB_EXPORT HRESULT WsbLoadFromStream(IStream* pStream, DATE* pValue);
extern WSB_EXPORT HRESULT WsbLoadFromStream(IStream* pStream, FILETIME* pValue);
extern WSB_EXPORT HRESULT WsbLoadFromStream(IStream* pStream, ULARGE_INTEGER* pValue);

extern WSB_EXPORT HRESULT WsbSaveToStream(IStream* pStream, BOOL value);
extern WSB_EXPORT HRESULT WsbSaveToStream(IStream* pStream, GUID value);
extern WSB_EXPORT HRESULT WsbSaveToStream(IStream* pStream, LONG value);
extern WSB_EXPORT HRESULT WsbSaveToStream(IStream* pStream, SHORT value);
extern WSB_EXPORT HRESULT WsbSaveToStream(IStream* pStream, BYTE value);
extern WSB_EXPORT HRESULT WsbSaveToStream(IStream* pStream, UCHAR* value, ULONG bufferSize);
extern WSB_EXPORT HRESULT WsbSaveToStream(IStream* pStream, OLECHAR* value);
extern WSB_EXPORT HRESULT WsbSaveToStream(IStream* pStream, ULONG value);
extern WSB_EXPORT HRESULT WsbSaveToStream(IStream* pStream, USHORT value);
extern WSB_EXPORT HRESULT WsbSaveToStream(IStream* pStream, LONGLONG value);
extern WSB_EXPORT HRESULT WsbSaveToStream(IStream* pStream, ULONGLONG value);
extern WSB_EXPORT HRESULT WsbSaveToStream(IStream* pStream, DATE value);
extern WSB_EXPORT HRESULT WsbSaveToStream(IStream* pStream, FILETIME value);
extern WSB_EXPORT HRESULT WsbSaveToStream(IStream* pStream, ULARGE_INTEGER value);

extern WSB_EXPORT HRESULT WsbBstrFromStream(IStream* pStream, BSTR* pValue);
extern WSB_EXPORT HRESULT WsbBstrToStream(IStream* pStream, BSTR value);

extern WSB_EXPORT HRESULT WsbPrintfToStream(IStream* pStream, OLECHAR* fmtString, ...);
extern WSB_EXPORT HRESULT WsbStreamToFile(HANDLE hFile, IStream* pStream, BOOL AddCR);

extern WSB_EXPORT HRESULT WsbSafeCreate(OLECHAR *, IPersistFile* pIPFile);
extern WSB_EXPORT HRESULT WsbSafeLoad(OLECHAR *, IPersistFile* pIPFile, BOOL UseBackup);
extern WSB_EXPORT HRESULT WsbSafeSave(IPersistFile* pIPFile);
extern WSB_EXPORT HRESULT WsbMakeBackupName(OLECHAR* pSaveName, OLECHAR* pExtension,
        OLECHAR** ppBackupName);


#endif // _WSBPSTBL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\inc\wsbport.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    WsbPort.h

Abstract:

    Macros, functions, and classes to support portability.

Author:

    Ron White   [ronw]   19-Dec-1996

Revision History:

--*/


#ifndef _WSBPORT_
#define _WSBPORT_

// Portable sizes of standard types
#define WSB_BYTE_SIZE_BOOL           1
#define WSB_BYTE_SIZE_BYTE           1
#define WSB_BYTE_SIZE_DATE           8
#define WSB_BYTE_SIZE_FILETIME       8
#define WSB_BYTE_SIZE_GUID           16
#define WSB_BYTE_SIZE_LONG           4
#define WSB_BYTE_SIZE_LONGLONG       8
#define WSB_BYTE_SIZE_ULONGLONG      8
#define WSB_BYTE_SIZE_SHORT          2
#define WSB_BYTE_SIZE_ULARGE_INTEGER 8
#define WSB_BYTE_SIZE_ULONG          4
#define WSB_BYTE_SIZE_USHORT         2

// Functions for determinining how many bytes the standard types use
// when portably converted
inline size_t WsbByteSize(BOOL value) { value; return(WSB_BYTE_SIZE_BOOL); }
inline size_t WsbByteSize(GUID value) { value; return(WSB_BYTE_SIZE_GUID); }
inline size_t WsbByteSize(LONG value) { value; return(WSB_BYTE_SIZE_LONG); }
inline size_t WsbByteSize(LONGLONG value) { value; return(WSB_BYTE_SIZE_LONGLONG); }
inline size_t WsbByteSize(ULONGLONG value) { value; return(WSB_BYTE_SIZE_ULONGLONG); }
inline size_t WsbByteSize(DATE value) { value; return(WSB_BYTE_SIZE_DATE); }
inline size_t WsbByteSize(FILETIME value) { value; return(WSB_BYTE_SIZE_FILETIME); }
inline size_t WsbByteSize(SHORT value) { value; return(WSB_BYTE_SIZE_SHORT); }
inline size_t WsbByteSize(BYTE value) { value; return(WSB_BYTE_SIZE_BYTE); }
inline size_t WsbByteSize(ULONG value) { value; return(WSB_BYTE_SIZE_ULONG); }
inline size_t WsbByteSize(USHORT value) { value; return(WSB_BYTE_SIZE_USHORT); }
inline size_t WsbByteSize(ULARGE_INTEGER value) { value; return(WSB_BYTE_SIZE_ULARGE_INTEGER); }

// Functions for converting standard types from bytes for portablity and WsbDbKey
extern WSB_EXPORT HRESULT WsbConvertFromBytes(UCHAR* pBytes, BOOL* pValue, ULONG* pSize);
extern WSB_EXPORT HRESULT WsbConvertFromBytes(UCHAR* pBytes, GUID* pValue, ULONG* pSize);
extern WSB_EXPORT HRESULT WsbConvertFromBytes(UCHAR* pBytes, LONG* pValue, ULONG* pSize);
extern WSB_EXPORT HRESULT WsbConvertFromBytes(UCHAR* pBytes, LONGLONG* pValue, ULONG* pSize);
extern WSB_EXPORT HRESULT WsbConvertFromBytes(UCHAR* pBytes, ULONGLONG* pValue, ULONG* pSize);
extern WSB_EXPORT HRESULT WsbConvertFromBytes(UCHAR* pBytes, DATE* pValue, ULONG* pSize);
extern WSB_EXPORT HRESULT WsbConvertFromBytes(UCHAR* pBytes, FILETIME* pValue, ULONG* pSize);
extern WSB_EXPORT HRESULT WsbConvertFromBytes(UCHAR* pBytes, SHORT* pValue, ULONG* pSize);
extern WSB_EXPORT HRESULT WsbConvertFromBytes(UCHAR* pBytes, ULONG* pValue, ULONG* pSize);
extern WSB_EXPORT HRESULT WsbConvertFromBytes(UCHAR* pBytes, USHORT* pValue, ULONG* pSize);
extern WSB_EXPORT HRESULT WsbConvertFromBytes(UCHAR* pBytes, ULARGE_INTEGER* pValue, ULONG* pSize);

extern WSB_EXPORT HRESULT WsbOlestrFromBytes(UCHAR* pBytes, OLECHAR* pValue, ULONG* pSize);

// Functions for converting standard types to bytes for portablity and WsbDbKey
extern WSB_EXPORT HRESULT WsbConvertToBytes(UCHAR* pBytes, BOOL value, ULONG* pSize);
extern WSB_EXPORT HRESULT WsbConvertToBytes(UCHAR* pBytes, GUID value, ULONG* pSize);
extern WSB_EXPORT HRESULT WsbConvertToBytes(UCHAR* pBytes, LONG value, ULONG* pSize);
extern WSB_EXPORT HRESULT WsbConvertToBytes(UCHAR* pBytes, LONGLONG value, ULONG* pSize);
extern WSB_EXPORT HRESULT WsbConvertToBytes(UCHAR* pBytes, ULONGLONG value, ULONG* pSize);
extern WSB_EXPORT HRESULT WsbConvertToBytes(UCHAR* pBytes, DATE value, ULONG* pSize);
extern WSB_EXPORT HRESULT WsbConvertToBytes(UCHAR* pBytes, FILETIME value, ULONG* pSize);
extern WSB_EXPORT HRESULT WsbConvertToBytes(UCHAR* pBytes, SHORT value, ULONG* pSize);
extern WSB_EXPORT HRESULT WsbConvertToBytes(UCHAR* pBytes, ULONG value, ULONG* pSize);
extern WSB_EXPORT HRESULT WsbConvertToBytes(UCHAR* pBytes, USHORT value, ULONG* pSize);
extern WSB_EXPORT HRESULT WsbConvertToBytes(UCHAR* pBytes, ULARGE_INTEGER value, ULONG* pSize);

extern WSB_EXPORT HRESULT WsbOlestrToBytes(UCHAR* pBytes, OLECHAR* value, ULONG* pSize);


#endif // _WSBPORT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\inc\wsbserv.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    wsbpstbl.h

Abstract:

    Abstract classes that provides persistence methods.

Author:

    Cat Brant       [cbrant]    24-Sep-1997

Revision History:

--*/

#ifndef _WSBSERV_
#define _WSBSERV_

extern WSB_EXPORT HRESULT WsbPowerEventNtToHsm(DWORD NtEvent, 
        ULONG * pHsmEvent);
extern WSB_EXPORT HRESULT WsbServiceSafeInitialize(IWsbServer* pServer,
    BOOL bVerifyId, BOOL bPrimaryId, BOOL* pWasCreated);


//
// This macro is used to encapsulate what was a CoCreateInstanceEx call that
// we were dependent on the class factory being on the same thread.
// 
// The macro simply calls the class factory directly. Thus, the class factory
// must be exposed to where this macro is used.
//

#define WsbCreateInstanceDirectly( _Class, _Interface, _pObj, _Hr )                      \
{                                                                                        \
    CComPtr<IClassFactory> pFactory;                                                     \
    _Hr = CComObject<_Class>::_ClassFactoryCreatorClass::CreateInstance(                 \
        _Class::_CreatorClass::CreateInstance, IID_IClassFactory, (void**)static_cast<IClassFactory **>(&pFactory) );        \
    if( SUCCEEDED( _Hr ) ) {                                                              \
                                                                                         \
        _Hr = pFactory->CreateInstance(                                                  \
        0, IID_##_Interface, (void**)static_cast<_Interface **>(&_pObj) );               \
    }                                                                                    \
}


#endif // _WSBSERV_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\inc\wsbpstrg.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    wsbpstrg.h

Abstract:

    This component is C++ object representations a smart string pointer. It
    is similar to the CComPtr, in that it takes care of allocating and
    freeing the memory needed to represent the string automatically. This
    simplifies cleanup of functions in error handling cases and it limits
    the need for FinalConstruct() and FinalRelease() calls in objects that
    derive from CComObjectRoot.

Author:

    Chuck Bardeen   [cbardeen]   11-Dec-1996

Revision History:

--*/

#ifndef _WSBPSTRG_
#define _WSBPSTRG_

/*++

Class Name:
    
    CWsbStringPtr

Class Description:

    This component is C++ object representations a smart string pointer. It
    is similar to the CComPtr, in that it takes care of allocating and
    freeing the memory needed to represent the string automatically. This
    simplifies cleanup of functions in error handling cases and it limits
    the need for FinalConstruct() and FinalRelease() calls in objects that
    derive from CComObjectRoot.

--*/

class WSB_EXPORT CWsbStringPtr
{

// Constructors
public:
    CWsbStringPtr();
    CWsbStringPtr(const CHAR* pChar);
    CWsbStringPtr(const WCHAR* pWchar);
    CWsbStringPtr(const CWsbStringPtr& pString);
    CWsbStringPtr(REFGUID rguid);

// Destructor
public:
    ~CWsbStringPtr();

// Operator Overloading
public:
    operator WCHAR*();
    WCHAR& operator *();
    WCHAR** operator &();
    WCHAR& operator [](const int i);
    CWsbStringPtr& operator =(const CHAR* pChar);
    CWsbStringPtr& operator =(const WCHAR* pWchar);
    CWsbStringPtr& operator =(REFGUID rguid);
    CWsbStringPtr& operator =(const CWsbStringPtr& pString);
    BOOL operator !();
#if 0
    BOOL operator==(LPCWSTR s2);
    BOOL operator!=(LPCWSTR s2);
    BOOL operator==(const CWsbStringPtr& s2);
    BOOL operator!=(const CWsbStringPtr& s2);
#else
    int  Compare( LPCWSTR s2 );
    int  CompareIgnoreCase( LPCWSTR s2 );
    BOOL IsEqual( LPCWSTR s2 );
    BOOL IsNotEqual( LPCWSTR s2 );
#endif


// Memory Allocation
public:
    HRESULT Alloc(ULONG size);
    HRESULT Free(void);
    HRESULT GetSize(ULONG* size);    // Size of allocated buffer
    HRESULT Realloc(ULONG size);

// String Manipulation
public:
    HRESULT Append(const CHAR* pChar);
    HRESULT Append(const WCHAR* pWchar);
    HRESULT Append(const CWsbStringPtr& pString);
    HRESULT CopyTo(CHAR** pChar);
    HRESULT CopyTo(WCHAR** pWchar);
    HRESULT CopyTo(GUID * pguid);
    HRESULT CopyToBstr(BSTR* pBstr);
    HRESULT CopyTo(CHAR** pChar, ULONG bufferSize);
    HRESULT CopyTo(WCHAR** pWchar,ULONG bufferSize);
    HRESULT CopyToBstr(BSTR* pBstr,ULONG bufferSize);
    HRESULT FindInRsc(ULONG startId, ULONG idsToCheck, ULONG* pMatchId);
    HRESULT GetLen(ULONG* size);      // Length, in chars, of string
    HRESULT GiveTo(WCHAR** ppWchar);
    HRESULT LoadFromRsc(HINSTANCE instance, ULONG id);
    HRESULT Prepend(const CHAR* pChar);
    HRESULT Prepend(const WCHAR* pWchar);
    HRESULT Prepend(const CWsbStringPtr& pString);
    HRESULT Printf(const WCHAR* fmtString, ...);
    HRESULT TakeFrom(WCHAR* pWchar, ULONG bufferSize);
    HRESULT VPrintf(const WCHAR* fmtString, va_list vaList);

// Member Data
protected:
    WCHAR*                  m_pString;
    ULONG                   m_givenSize;
    static CComPtr<IMalloc> m_pMalloc;
};


inline
HRESULT CWsbStringPtr::GetLen(ULONG* size)
{
    HRESULT     hr = S_OK;

    if (0 == size) {
        hr = E_POINTER;
    } else if (0 == m_pString) {
        *size = 0;
    } else {
        *size = wcslen(m_pString);
    }
    return(hr);
}

inline
HRESULT CWsbStringPtr::Printf(const WCHAR* fmtString, ...)
{
    HRESULT     hr;
    va_list     vaList;

    va_start(vaList, fmtString);
    hr = VPrintf(fmtString, vaList);
    va_end(vaList);
    return(hr);
}
#if 0
// Compare Operators (allow to be compared when on the right)
BOOL operator==(LPCWSTR s1, const CWsbStringPtr& s2);
BOOL operator!=(LPCWSTR s1, const CWsbStringPtr& s2);

inline
BOOL CWsbStringPtr::operator==(LPCWSTR s2)
{
    return( wcscmp( m_pString, s2 ) == 0 );
}

inline
BOOL CWsbStringPtr::operator!=(LPCWSTR s2)
{
    return( wcscmp( m_pString, s2 ) != 0 );
}

inline
BOOL CWsbStringPtr::operator==(const CWsbStringPtr& s2)
{
    return( wcscmp( m_pString, s2.m_pString ) == 0 );
}

inline
BOOL CWsbStringPtr::operator!=(const CWsbStringPtr& s2)
{
    return( wcscmp( m_pString, s2.m_pString ) != 0 );
}

inline
BOOL operator==(LPCWSTR s1, const CWsbStringPtr& s2)
{
    return( wcscmp( s1, (CWsbStringPtr)s2 ) == 0 );
}

inline
BOOL operator!=(LPCWSTR s1, const CWsbStringPtr& s2)
{
    return( wcscmp( s1, (CWsbStringPtr)s2 ) != 0 );
}
#else

inline
int CWsbStringPtr::Compare( LPCWSTR s2 )
{
    if( m_pString && s2 )   return( wcscmp( m_pString, s2 ) );

    if( !m_pString && s2 )  return( -1 );

    if( m_pString && !s2 )  return( 1 );

    return( 0 );
}

inline
int CWsbStringPtr::CompareIgnoreCase( LPCWSTR s2 )
{
    if( m_pString && s2 )   return( _wcsicmp( m_pString, s2 ) );

    if( !m_pString && s2 )  return( -1 );

    if( m_pString && !s2 )  return( 1 );

    return( 0 );
}

inline
BOOL CWsbStringPtr::IsEqual( LPCWSTR s2 )
{
    return( Compare( s2 ) == 0 );
}

inline
BOOL CWsbStringPtr::IsNotEqual( LPCWSTR s2 )
{
    return( Compare( s2 ) != 0 );
}



#endif


#endif // _WSBPSTRG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\inc\wsbstrg.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    wsbstrg.h

Abstract:

    This component is an object representations of the STRING standard type. It
    is both a persistable and collectable.

Author:

    Chuck Bardeen   [cbardeen]   29-Oct-1996

Revision History:

--*/

#include "resource.h"

#include "wsbcltbl.h"
#include "wsbpstrg.h"

#ifndef _WSBSTRG_
#define _WSBSTRG_

/*++

Class Name:
    
    CWsbString

Class Description:

    An object representations of the STRING standard type. It
    is both persistable and collectable.

--*/

class CWsbString : 
    public CWsbObject,
    public IWsbString,
    public CComCoClass<CWsbString,&CLSID_CWsbString>
{
public:
    CWsbString() {}
BEGIN_COM_MAP(CWsbString)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IWsbString)
    COM_INTERFACE_ENTRY2(IWsbCollectable, IWsbString)
    COM_INTERFACE_ENTRY(IWsbPersistStream)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_CWsbString)

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);

// IPersistStream
public:
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER* pSize);
    STDMETHOD(Load)(IStream* pStream);
    STDMETHOD(Save)(IStream* pStream, BOOL clearDirty);

// IWsbCollectable
public:
    STDMETHOD(CompareTo)(IUnknown* pCollectable, SHORT* pResult);
    WSB_FROM_CWSBOBJECT;

// IWsbString
public:
    STDMETHOD(CompareToString)(OLECHAR* value, SHORT* pResult);
    STDMETHOD(CompareToIString)(IWsbString* pString, SHORT* pResult);
    STDMETHOD(GetString)(OLECHAR** pValue, ULONG bufferSize);
    STDMETHOD(GetStringAndCase)(OLECHAR** pValue, BOOL* pIsCaseDependent, ULONG bufferSize);
    STDMETHOD(IsCaseDependent)(void);
    STDMETHOD(SetIsCaseDependent)(BOOL isCaseDependent);
    STDMETHOD(SetString)(OLECHAR* value);
    STDMETHOD(SetStringAndCase)(OLECHAR* value, BOOL isCaseDependent);

// IWsbTestable
public:
    STDMETHOD(Test)(USHORT *passed, USHORT *failed);

protected:
    CWsbStringPtr   m_value;
    BOOL            m_isCaseDependent;
};

#endif // _WSBSTRG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\inc\wsbregty.h ===
/*++

Copyright (c) 1996  Microsoft Corporation
 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    WsbRegty.h

Abstract:

    This is the header file for registry access functions.

Author:

    Rohde Wakefield    [rohde]   21-Oct-1996

Revision History:

--*/




#ifndef __WSBREG__
#define __WSBREG__

#ifdef __cplusplus
extern "C"
{
#endif

// Defines for common registry keys/values
#define WSB_CURRENT_VERSION_REGISTRY_KEY            WSB_WINDOWSNT_CURRENT_VERSION_REGISTRY_KEY // Backwards compatibility

#define WSB_PROFILELIST_REGISTRY_KEY                OLESTR("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList")
#define WSB_WINDOWSNT_CURRENT_VERSION_REGISTRY_KEY  OLESTR("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion")
#define WSB_WINDOWS_CURRENT_VERSION_REGISTRY_KEY    OLESTR("SOFTWARE\\Microsoft\\Windows\\CurrentVersion")
#define WSB_SYSTEM_ROOT_REGISTRY_VALUE              OLESTR("SystemRoot")
#define WSB_PROFILES_DIR_REGISTRY_VALUE             OLESTR("ProfilesDirectory")


#define WSB_CONTROL_REGISTRY_KEY                    OLESTR("System\\CurrentControlSet\\Control\\RemoteStorage")
#define WSB_METADATA_REGISTRY_VALUE                 OLESTR("RemoteStorageData")


#define WSB_RSM_CONTROL_REGISTRY_KEY                    OLESTR("System\\CurrentControlSet\\Control\\NTMS")
#define WSB_RSM_METADATA_REGISTRY_VALUE                 OLESTR("NtmsData")

WSB_EXPORT HRESULT
WsbOpenRegistryKey (
    IN  const OLECHAR * szMachine OPTIONAL,
    IN  const OLECHAR * szPath,
    IN  REGSAM sam,
    OUT HKEY * phKeyMachine,
    OUT HKEY * phKey
    );

WSB_EXPORT HRESULT
WsbCloseRegistryKey (
    IN OUT HKEY * phKeyMachine,
    IN OUT HKEY * phKey
    );

WSB_EXPORT HRESULT
WsbSetRegistryValueData (
    IN  const OLECHAR * szMachine OPTIONAL,
    IN  const OLECHAR * szPath,
    IN  const OLECHAR * szValue,
    IN  const BYTE *pData,
    IN  DWORD cbData
    );

WSB_EXPORT HRESULT
WsbGetRegistryValueData (
    IN  const OLECHAR * szMachine OPTIONAL,
    IN  const OLECHAR * szPath,
    IN  const OLECHAR * szValue,
    OUT BYTE *pData,
    IN  DWORD cbData,
    OUT DWORD * pcbData OPTIONAL
    );

WSB_EXPORT HRESULT
WsbSetRegistryValueString (
    IN  const OLECHAR * szMachine OPTIONAL,
    IN  const OLECHAR * szPath,
    IN  const OLECHAR * szValue,
    IN  const OLECHAR * szString,
    IN        DWORD     dwType = REG_SZ
    );

WSB_EXPORT HRESULT
WsbGetRegistryValueString (
    IN  const OLECHAR * szMachine OPTIONAL,
    IN  const OLECHAR * szPath,
    IN  const OLECHAR * szValue,
    OUT OLECHAR * szString,
    IN  DWORD cSize,
    OUT DWORD *pcLength OPTIONAL
    );

WSB_EXPORT HRESULT
WsbGetRegistryValueMultiString (
    IN  const OLECHAR * szMachine OPTIONAL,
    IN  const OLECHAR * szPath,
    IN  const OLECHAR * szValue,
    OUT OLECHAR * szMultiString,
    IN  DWORD cSize,
    OUT DWORD *pcLength OPTIONAL
    );

WSB_EXPORT HRESULT
WsbSetRegistryValueDWORD (
    IN  const OLECHAR * szMachine OPTIONAL,
    IN  const OLECHAR * szPath,
    IN  const OLECHAR * szValue,
    IN        DWORD     dw
    );

WSB_EXPORT HRESULT
WsbGetRegistryValueDWORD (
    IN  const OLECHAR * szMachine OPTIONAL,
    IN  const OLECHAR * szPath,
    IN  const OLECHAR * szValue,
    OUT       DWORD *   pdw
    );

WSB_EXPORT HRESULT
WsbAddRegistryValueDWORD (
    IN  const OLECHAR * szMachine OPTIONAL,
    IN  const OLECHAR * szPath,
    IN  const OLECHAR * szValue,
    IN        DWORD     adw
    );

WSB_EXPORT HRESULT
WsbIncRegistryValueDWORD (
    IN  const OLECHAR * szMachine OPTIONAL,
    IN  const OLECHAR * szPath,
    IN  const OLECHAR * szValue
    );

WSB_EXPORT HRESULT
WsbRemoveRegistryValue (
    IN  const OLECHAR * szMachine OPTIONAL,
    IN  const OLECHAR * szPath,
    IN  const OLECHAR * szValue
    );

WSB_EXPORT HRESULT
WsbRemoveRegistryKey (
    IN  const OLECHAR * szMachine OPTIONAL,
    IN  const OLECHAR * szPath,
    IN  const OLECHAR * szKey
    );

WSB_EXPORT HRESULT
WsbCheckIfRegistryKeyExists(
    IN  const OLECHAR * szMachine OPTIONAL,
    IN  const OLECHAR * szPath
    );

WSB_EXPORT HRESULT
WsbEnsureRegistryKeyExists (
    IN  const OLECHAR * szMachine OPTIONAL,
    IN  const OLECHAR * szPath
    );

WSB_EXPORT HRESULT
WsbSetRegistryValueUlongAsString (
    IN  const OLECHAR * szMachine OPTIONAL,
    IN  const OLECHAR * szPath,
    IN  const OLECHAR * szValue,
    IN        ULONG     value
    );

WSB_EXPORT HRESULT
WsbGetRegistryValueUlongAsMultiString (
    IN  const OLECHAR * szMachine OPTIONAL,
    IN  const OLECHAR * szPath,
    IN  const OLECHAR * szValue,
    OUT       ULONG **  ppValues,
    OUT       ULONG *   pNumValues
    );

WSB_EXPORT HRESULT
WsbGetRegistryValueUlongAsString (
    IN  const OLECHAR * szMachine OPTIONAL,
    IN  const OLECHAR * szPath,
    IN  const OLECHAR * szValue,
    OUT       ULONG *   pvalue
    );

WSB_EXPORT HRESULT
WsbRegistryValueUlongAsString (
    IN  const OLECHAR * szMachine OPTIONAL,
    IN  const OLECHAR * szPath,
    IN  const OLECHAR * szValue,
    IN OUT    ULONG *   pvalue
    );

#ifdef __cplusplus
}
#endif

#endif //__WSBREG__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\inc\wsbtrak.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    wsbtrak.h

Abstract:

    Utility functions to keep track of run-time information.

Author:

    Ron White   [ronw]   5-Dec-1997

Revision History:

--*/

#ifndef _WSBTRAK_
#define _WSBTRAK_

//  Flags for WsbObjectTracePointers
#define WSB_OTP_STATISTICS          0x00000001
#define WSB_OTP_SEQUENCE            0x00000002
#define WSB_OTP_ALLOCATED           0x00000004
#define WSB_OTP_ALL                 0x0000000f

//  Define these as macros so we can get rid of them for release code
#if defined(WSB_TRACK_MEMORY)
#define WSB_OBJECT_ADD(guid, addr)   WsbObjectAdd(guid, addr)
#define WSB_OBJECT_SUB(guid, addr)   WsbObjectSub(guid, addr)
#define WSB_OBJECT_TRACE_POINTERS(flags)    WsbObjectTracePointers(flags)
#define WSB_OBJECT_TRACE_TYPES       WsbObjectTraceTypes()

#else
#define WSB_OBJECT_ADD(guid, addr)   
#define WSB_OBJECT_SUB(guid, addr)   
#define WSB_OBJECT_TRACE_POINTERS(flags)
#define WSB_OBJECT_TRACE_TYPES       

#endif

// Tracker functions
#if defined(WSB_TRACK_MEMORY)
extern WSB_EXPORT HRESULT WsbObjectAdd(const GUID& guid, const void* addr);
extern WSB_EXPORT HRESULT WsbObjectSub(const GUID& guid, const void* addr);
extern WSB_EXPORT HRESULT WsbObjectTracePointers(ULONG flags);
extern WSB_EXPORT HRESULT WsbObjectTraceTypes(void);
#endif

// Memory replacement functions
#if defined(WSB_TRACK_MEMORY)
extern WSB_EXPORT LPVOID WsbMemAlloc(ULONG cb, const char * filename, int linenum);
extern WSB_EXPORT void   WsbMemFree(LPVOID pv, const char * filename, int linenum);
extern WSB_EXPORT LPVOID WsbMemRealloc(LPVOID pv, ULONG cb, 
        const char * filename, int linenum);

extern WSB_EXPORT BSTR    WsbSysAllocString(const OLECHAR FAR * sz, 
        const char * filename, int linenum);
extern WSB_EXPORT BSTR    WsbSysAllocStringLen(const OLECHAR FAR * sz, 
        unsigned int cc, const char * filename, int linenum);
extern WSB_EXPORT void    WsbSysFreeString(BSTR bs, const char * filename, int linenum);
extern WSB_EXPORT HRESULT WsbSysReallocString(BSTR FAR * pb, const OLECHAR FAR * sz, 
        const char * filename, int linenum);
extern WSB_EXPORT HRESULT WsbSysReallocStringLen(BSTR FAR * pb, 
        const OLECHAR FAR * sz, unsigned int cc, const char * filename, int linenum);

#endif

#endif // _WSBTRAK_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\inc\wsbtrace.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    WsbTrace.h

Abstract:

    This header file defines the part of the platform code that is
    responsible for function tracing.

Author:

    Chuck Bardeen       [cbardeen]  29-Oct-1996

Revision History:

    Brian Dodd      [brian]      09-May-1996  - Added event logging

--*/

#ifndef _WSBTRACE_
#define _WSBTRACE_

#include "wsb.h"
#include "rsbuild.h"
#include "ntverp.h"

#ifdef __cplusplus
extern "C" {
#endif
// The size of the trace statement buffer including NULL termination
#define WSB_TRACE_BUFF_SIZE  1024

// These define the event log levels
#define     WSB_LOG_LEVEL_NONE              0  // Nothing is written the the event log
#define     WSB_LOG_LEVEL_ERROR             1  // Errors only (severity 3)
#define     WSB_LOG_LEVEL_WARNING           2  // Errors and Warnings (severity 2)
#define     WSB_LOG_LEVEL_INFORMATION       3  // Errors, Warnings, and Information (severity 1)
#define     WSB_LOG_LEVEL_COMMENT           4  // All Message Types (includes severity 0)
#define     WSB_LOG_LEVEL_DEFAULT           3  // Something reasonable.

// These define where the trace output should be written.
#define     WSB_TRACE_OUT_NONE              0x00000000L     // No output
#define     WSB_TRACE_OUT_DEBUG_SCREEN      0x00000001L     // Output to the debug screen
#define     WSB_TRACE_OUT_FILE              0x00000002L     // Output to a file
#define     WSB_TRACE_OUT_STDOUT            0x00000004L     // Output to standard out
#define     WSB_TRACE_OUT_FILE_COPY         0x00000008L     // Save copy of trace file
#define     WSB_TRACE_OUT_MULTIPLE_FILES    0x00000010L     // Output to multiple files
#define     WSB_TRACE_OUT_FLAGS_SET         0x00010000L     // Indicates other flags are set
#define     WSB_TRACE_OUT_ALL               0xffffffffL

// These macros define the module assignments for the bits used to
// control whether tracing is enabled. Each bit should only be used once,
// the granularity will be fairly large.
#define     WSB_TRACE_BIT_NONE              0x0000000000000000L
#define     WSB_TRACE_BIT_PLATFORM          0x0000000000000001L
#define     WSB_TRACE_BIT_RMS               0x0000000000000002L
#define     WSB_TRACE_BIT_SEG               0x0000000000000004L  // Remove when dependencies are gone
#define     WSB_TRACE_BIT_META              0x0000000000000004L
#define     WSB_TRACE_BIT_HSMENG            0x0000000000000008L
#define     WSB_TRACE_BIT_JOB               0x0000000000000010L
#define     WSB_TRACE_BIT_HSMTSKMGR         0x0000000000000020L
#define     WSB_TRACE_BIT_FSA               0x0000000000000040L
#define     WSB_TRACE_BIT_DATAMIGRATER      0x0000000000000080L
#define     WSB_TRACE_BIT_DATARECALLER      0x0000000000000100L
#define     WSB_TRACE_BIT_DATAVERIFIER      0x0000000000000200L
#define     WSB_TRACE_BIT_UI                0x0000000000000400L
#define     WSB_TRACE_BIT_HSMCONN           0x0000000000000800L
#define     WSB_TRACE_BIT_DATAMOVER         0x0000000000001000L
#define     WSB_TRACE_BIT_IDB               0x0000000000002000L
#define     WSB_TRACE_BIT_TEST              0x0000000000004000L
#define     WSB_TRACE_BIT_COPYMEDIA         0x0000000000008000L
#define     WSB_TRACE_BIT_PERSISTENCE       0x0000000000010000L
#define     WSB_TRACE_BIT_HSMSERV           0x0000000000020000L
#define     WSB_TRACE_BIT_ALL               0xffffffffffffffffL


// These macros are used to provide function call trace information into
// the log. Each function (method) that wants to be traceable needs at a
// minimum to use the following three macros. The first macro needs to be
// put at the top of the source code file and defines to which module the
// code in that file belongs.
//
//      #define     WSB_TRACE_IS        WSB_TRACE_BIT_PLATFORM
//
// The next two macros are used once per function. They are variable
// macros, which allows the writer of the function to list the values
// of the input and output parameters.
//
//      HRESULT CWsbSample::Do(BOOL shouldWrite) {
//          HRESULT     hr = S_OK;
//
//          WsbTraceIn("CWsbSample::Do", "shouldWrite = <%ls>", WsbBoolAsString(shouldWrite));
//
//          ... some code ....
//
//          WsbTraceOut("CWsbSample::Do", "hr = <%ls>", WsbHrAsString(hr));
//
//          return(hr);
//      }
//          
// Notice that some helper functions have been defined to help provide an
// a written description for the value of certain types. Additional helper
// helper functions should be created as needed.

/*++

Macro Name:

    WsbTraceIn

Macro Description:

    This macro is used to provide function call trace information into
    the log. It should be put at the start of the function.

Arguments:

    methodName - The name of the function.
    
    argString - A printf type format string. Additional arguments can
        follow.

--*/

#define     WsbTraceIn  if ((g_WsbTraceEntryExit == TRUE) && ((g_WsbTraceModules & WSB_TRACE_IS) != 0)) WsbTraceEnter

/*++

Macro Name:

    WsbTraceOut    

Macro Description:

    This macro is used to provide function call trace information into
    the log. It should be put at the end of the function.

Arguments:

    methodName - The name of the function.
    
    argString - A printf type format string. Additional arguments can
        follow.

--*/

#define     WsbTraceOut if ((g_WsbTraceEntryExit == TRUE) && ((g_WsbTraceModules & WSB_TRACE_IS) != 0)) WsbTraceExit


/*++

Macro Name:

    WsbLogEvent

Macro Description:

    This routine writes a message into the system event log.  The message
    is also written to the application trace file.

Arguments:

    eventId    - The message Id to log.
    dataSize   - Size of arbitrary data.
    data       - Arbitrary data buffer to display with the message.
    Inserts    - Message inserts that are merged with the message description specified by
                   eventId.  The number of inserts must match the number specified by the
                   message description.  The last insert must be NULL to indicate the
                   end of the insert list.

Notes:

    It's a small optimization to check if logging is turned on, first.  Determining if the
    message is actually logged still requires the first parameter.  Unlike trace, log activity
    should be minimal and only when there are problems.  The overhead of the calls seems
    reasonable.

--*/

#define     WsbLogEvent \
                if ( g_WsbLogLevel ) WsbSetEventInfo( __FILE__, __LINE__, VER_PRODUCTBUILD, RS_BUILD_VERSION ); \
                if ( g_WsbLogLevel ) WsbTraceAndLogEvent

/*++

Macro Name:

    WsbLogEventV

Macro Description:

    This macro is used to write a message into the system event log.  The message
    is also written to the application trace file.

    This macro is similar to WsbLogEvent, but takes a va_list as the fourth argument.

Arguments:

    eventId    - The message Id to log.
    dataSize   - Size of arbitrary data.
    data       - Arbitrary data buffer to display with the message.
    inserts    - An array of message inserts that are merged with the message description
                   specified by eventId.  The number of inserts must match the number
                   specified by the message description.  The last insert must be NULL,
                   to indicate the end of the insert list.

Notes:

    It's a small optimization to check if logging is turned on, first.  Determining if the
    message is actually logged still requires the first parameter.  Unlike trace, log activity
    should be minimal and only when there are problems.  The overhead of the calls seems
    reasonable.

--*/

#define     WsbLogEventV \
                if ( g_WsbLogLevel ) WsbSetEventInfo( __FILE__, __LINE__, VER_PRODUCTBUILD, RS_BUILD_VERSION ); \
                if ( g_WsbLogLevel ) WsbTraceAndLogEventV

/*++

Macro Name:

    WsbTrace    

Macro Description:

    This macro is used to provide a printf style message into the trace file.

Arguments:

    argString - A printf type format string. Additional arguments can
        follow.

--*/

#define     WsbTrace if ((g_WsbTraceModules & WSB_TRACE_IS) != 0) WsbTracef


/*++

Macro Name:

    WsbTraceAlways

Macro Description:

    This macro is used to provide a printf style message into the trace file.  
    The trace is printed if tracing has been started regardless of the
    WSB_TRACE_IS settings.

Arguments:

    argString - A printf type format string. Additional arguments can
        follow.

--*/

#define     WsbTraceAlways WsbTracef




/*++

Macro Name:

    WsbTraceBuffer

Macro Description:

    This macro is used to provide buffer dump to the trace file.  

Arguments:

    Same as WsbTraceBufferAsBytes

--*/

#define     WsbTraceBuffer if ((g_WsbTraceModules & WSB_TRACE_IS) != 0) WsbTraceBufferAsBytes


// The following global variable is used to compare against to determine
// the modules for which debugging should be enabled.
extern WSB_EXPORT LONGLONG              g_WsbTraceModules;
extern WSB_EXPORT IWsbTrace             *g_pWsbTrace;
extern WSB_EXPORT LONG                  g_WsbTraceCount;
extern WSB_EXPORT BOOL                  g_WsbTraceEntryExit;
extern WSB_EXPORT WORD                  g_WsbLogLevel;
extern WSB_EXPORT BOOL                  g_WsbLogSnapShotOn;
extern WSB_EXPORT WORD                  g_WsbLogSnapShotLevel;
extern WSB_EXPORT OLECHAR               g_pWsbLogSnapShotPath[];
extern WSB_EXPORT BOOL                  g_WsbLogSnapShotResetTrace;


// Trace functions
extern WSB_EXPORT void WsbSetEventInfo( char *fileName, DWORD lineNo, DWORD ntBuild, DWORD rsBuild );
extern WSB_EXPORT void WsbTraceInit( void );
extern WSB_EXPORT void WsbTraceCleanupThread(void);
extern WSB_EXPORT void WsbTraceEnter(OLECHAR* methodName, OLECHAR* argString,  ...);
extern WSB_EXPORT void WsbTraceExit(OLECHAR* methodName, OLECHAR* argString, ...);
extern WSB_EXPORT void WsbTracef(OLECHAR* argString, ...);
extern WSB_EXPORT void WsbTraceAndLogEvent(DWORD eventId, DWORD dataSize, LPVOID data, ... /* last argument is NULL */);
extern WSB_EXPORT void WsbTraceAndLogEventV(DWORD eventId, DWORD dataSize, LPVOID data, va_list *arguments /* last element is NULL */);
extern WSB_EXPORT void WsbTraceAndPrint(DWORD eventId, ... /* last argument is NULL */);
extern WSB_EXPORT void WsbTraceAndPrintV(DWORD eventId, va_list *arguments /* last element is NULL */);
extern WSB_EXPORT void WsbTraceBufferAsBytes( DWORD size, LPVOID bufferP );
extern WSB_EXPORT void WsbTraceTerminate(void);
extern WSB_EXPORT ULONG WsbTraceThreadOff(void);
extern WSB_EXPORT ULONG WsbTraceThreadOffCount(void);
extern WSB_EXPORT ULONG WsbTraceThreadOn(void);


// Helper Functions
//
// NOTE: Be careful with some of these helper functions, since they
// use static memory and a second call to the function will overwrite
// the results of the first call to the function. Also, some functions
// end up calling each other and sharing memory between them (i.e.
// WsbPtrToGuidAsString() calls WsbGuidAsString()).
extern WSB_EXPORT const OLECHAR* WsbBoolAsString(BOOL boolean);
extern WSB_EXPORT const OLECHAR* WsbFiletimeAsString(BOOL isRelative, FILETIME filetime);
extern WSB_EXPORT const OLECHAR* WsbGuidAsString(GUID guid);
extern WSB_EXPORT const OLECHAR* WsbHrAsString(HRESULT hr);
extern WSB_EXPORT const OLECHAR* WsbLongAsString(LONG inLong);
extern WSB_EXPORT const OLECHAR* WsbLonglongAsString(LONGLONG llong);
extern WSB_EXPORT const OLECHAR* WsbStringAsString(OLECHAR* pStr);

extern WSB_EXPORT const OLECHAR* WsbPtrToBoolAsString(BOOL* pBool);
extern WSB_EXPORT const OLECHAR* WsbPtrToFiletimeAsString(BOOL isRelative, FILETIME *pFiletime);
extern WSB_EXPORT const OLECHAR* WsbPtrToGuidAsString(GUID* pGuid);
extern WSB_EXPORT const OLECHAR* WsbPtrToHrAsString(HRESULT *pHr);
extern WSB_EXPORT const OLECHAR* WsbPtrToLonglongAsString(LONGLONG *pLlong);
extern WSB_EXPORT const OLECHAR* WsbPtrToLongAsString(LONG* pLong);
extern WSB_EXPORT const OLECHAR* WsbPtrToShortAsString(SHORT* pShort);
extern WSB_EXPORT const OLECHAR* WsbPtrToByteAsString(BYTE* pByte);
extern WSB_EXPORT const OLECHAR* WsbPtrToStringAsString(OLECHAR** pString);
extern WSB_EXPORT const OLECHAR* WsbPtrToUliAsString(ULARGE_INTEGER* pUli);
extern WSB_EXPORT const OLECHAR* WsbPtrToUlongAsString(ULONG* pUlong);
extern WSB_EXPORT const OLECHAR* WsbPtrToUshortAsString(USHORT* pUshort);
extern WSB_EXPORT const OLECHAR* WsbPtrToPtrAsString(void** ppVoid);
extern WSB_EXPORT const OLECHAR* WsbAbbreviatePath(const OLECHAR* path, USHORT length);

extern WSB_EXPORT HRESULT WsbShortSizeFormat64(__int64 dw64, LPTSTR szBuf);

#ifdef __cplusplus

/*++

Class Name:
    
    WsbQuickString 

Class Description:

    Quick string storage class

--*/

class WSB_EXPORT WsbQuickString {
public:
    WsbQuickString ( const OLECHAR * sz ) { m_sz = WsbAllocString ( sz ); }
    ~WsbQuickString ( ) { if ( m_sz ) WsbFreeString ( m_sz ); }
    operator OLECHAR * () { return ( m_sz ); }

private:
    BSTR m_sz;
    WsbQuickString ( ) { m_sz = 0; }
};

#define WsbStringCopy( a ) ((OLECHAR *)WsbQuickString ( a ) )

}
#endif
#endif // _WSBTRACE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\inc\wsbvol.h ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    wsbvol.h

Abstract:

    Definitions for volume support routines

Author:

    Ran Kalach [rankala] 27, January 2000

Revision History:

--*/

#ifndef _WSBVOL_
#define _WSBVOL_

#ifdef __cplusplus
extern "C" {
#endif


WSB_EXPORT HRESULT
WsbGetFirstMountPoint(
    IN PWSTR volumeName, 
    OUT PWSTR firstMountPoint, 
    IN ULONG maxSize
);

#ifdef __cplusplus
}
#endif

#endif // _WSBFMT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\inc\wsbtrc.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    WsbTrc.h

Abstract:

    This header file defines the part of the platform code that is
    responsible for function tracing.

Author:

    Chuck Bardeen       [cbardeen]  29-Oct-1996

Revision History:

    Brian Dodd          [brian]     09-May-1996  - Added event logging

--*/

#ifndef _WSBTRC_
#define _WSBTRC_

#include "wsb.h"
#include "resource.h"

//Registry strings for trace settings
#define WSB_TRACE_COUNT                 OLESTR("WsbTraceCount")
#define WSB_TRACE_TIMESTAMP             OLESTR("WsbTraceTimestamp")
#define WSB_TRACE_THREADID              OLESTR("WsbTraceThreadId")
#define WSB_TRACE_ON                    OLESTR("WsbTraceOn")
#define WSB_TRACE_TO_DEBUG              OLESTR("WsbTraceToDebug")
#define WSB_TRACE_TO_STDOUT             OLESTR("WsbTraceToStdOut")
#define WSB_TRACE_TO_FILE               OLESTR("WsbTraceToFile")
#define WSB_TRACE_FILE_NAME             OLESTR("WsbTraceFileName")
#define WSB_TRACE_FILE_MAX_SIZE         OLESTR("WsbTraceFileMaxSize")
#define WSB_TRACE_FILE_COMMIT           OLESTR("WsbTraceFileCommit")
#define WSB_TRACE_ENTRY_EXIT            OLESTR("WsbTraceEntryExit")
#define WSB_TRACE_FILE_COPY_NAME        OLESTR("WsbTraceFileCopyName")

#define WSB_LOG_LEVEL                   OLESTR("WsbLogLevel")
#define WSB_LOG_SNAP_SHOT_ON            OLESTR("WsbLogSnapShotOn")
#define WSB_LOG_SNAP_SHOT_LEVEL         OLESTR("WsbLogSnapShotLevel")
#define WSB_LOG_SNAP_SHOT_PATH          OLESTR("WsbLogSnapShotPath")
#define WSB_LOG_SNAP_SHOT_RESET_TRACE   OLESTR("WsbLogSnapShotResetTrace")
                                        
#define WSB_TRACE_DO_PLATFORM           OLESTR("WsbTraceDoPlatform")
#define WSB_TRACE_DO_RMS                OLESTR("WsbTraceDoRms") 
#define WSB_TRACE_DO_SEG                OLESTR("WsbTraceDoSeg") 
#define WSB_TRACE_DO_META               OLESTR("WsbTraceDoMeta") 
#define WSB_TRACE_DO_HSMENG             OLESTR("WsbTraceDoHsmEng") 
#define WSB_TRACE_DO_JOB                OLESTR("WsbTraceDoJob") 
#define WSB_TRACE_DO_HSMTSKMGR          OLESTR("WsbTraceDoHsmTskMgr")
#define WSB_TRACE_DO_FSA                OLESTR("WsbTraceDoFsa") 
#define WSB_TRACE_DO_DATAMIGRATER       OLESTR("WsbTraceDoDatamigrater")
#define WSB_TRACE_DO_DATARECALLER       OLESTR("WsbTraceDoDataRecaller")
#define WSB_TRACE_DO_DATAVERIFIER       OLESTR("WsbTraceDoDataVerifier")
#define WSB_TRACE_DO_UI                 OLESTR("WsbTraceDoUI")   
#define WSB_TRACE_DO_DATAMOVER          OLESTR("WsbTraceDoDataMover")
#define WSB_TRACE_DO_HSMCONN            OLESTR("WsbTraceDoHsmConn")
#define WSB_TRACE_DO_IDB                OLESTR("WsbTraceDoIDB")
#define WSB_TRACE_DO_COPYMEDIA          OLESTR("WsbTraceDoCopyMedia")
#define WSB_TRACE_DO_PERSISTENCE        OLESTR("WsbTraceDoPersistence")
#define WSB_TRACE_DO_HSMSERV            OLESTR("WsbTraceDoHsmServ") 

class CWsbTrace : 
    public IWsbTrace,
    public CComObjectRoot,
    public CComCoClass<CWsbTrace,&CLSID_CWsbTrace>
{

public:
    CWsbTrace() {}
BEGIN_COM_MAP( CWsbTrace )
    COM_INTERFACE_ENTRY( IWsbTrace )
END_COM_MAP( )


DECLARE_REGISTRY_RESOURCEID( IDR_CWsbTrace )

    HRESULT FinalConstruct( void );
    void FinalRelease( void );

// IWsbTrace
public:
    STDMETHOD( StartTrace )( void );
    STDMETHOD( StopTrace )( void );
    STDMETHOD( SetTraceOn )(  LONGLONG traceElement );
    STDMETHOD( SetTraceOff )( LONGLONG traceElement );
    STDMETHOD( GetTraceSettings )( LONGLONG *pTraceElements );
    STDMETHOD( GetTraceSetting )( LONGLONG traceElement, BOOL *pOn );
    STDMETHOD( SetTraceFileControls )( OLECHAR *pTraceFileName, 
            BOOL commitEachEntry, LONGLONG maxTraceFileSize, 
            OLECHAR *pTraceFileCopyName);
    STDMETHOD( GetTraceFileControls )( OLECHAR **ppTraceFileName, 
            BOOL *pCommitEachEntry, LONGLONG *pMaxTraceFileSize, 
            OLECHAR **ppTraceFileCopyName);
    STDMETHOD( DirectOutput )(ULONG output );
    STDMETHOD( SetOutputFormat )( BOOL timeStamp, BOOL traceCount, BOOL threadId );
    STDMETHOD( GetOutputFormat )( BOOL *pTimeStamp, BOOL *pTraceCount, BOOL *pThreadId );
    STDMETHOD( SetTraceEntryExit )( BOOL traceEntryExit );
    STDMETHOD( GetTraceEntryExit )( BOOL *pTraceEntryExit );
    STDMETHOD( SetLogLevel )( WORD logLevel );
    STDMETHOD( SetLogSnapShot)( BOOL on,    WORD level, OLECHAR *snapShotPath, BOOL resetTrace);
    STDMETHOD( GetLogSnapShot)( BOOL *pOn, WORD *pLevel, OLECHAR **pSnapShotPath, BOOL *pResetTrace);
    STDMETHOD( GetLogLevel )( WORD *pLogLevel );
    STDMETHOD( GetRegistryEntry )( OLECHAR **pTraceRegistrySetting );
    STDMETHOD( SetRegistryEntry )( OLECHAR *traceRegistrySetting );
    STDMETHOD( LoadFromRegistry )( void );
    STDMETHOD( SetTraceSettings )( LONGLONG traceElements );

    STDMETHOD( Print )(OLECHAR* traceString );


protected:
// Helper functions
    STDMETHOD( AdjustFileNames )( void );
    STDMETHOD( WrapTraceFile )( void );
    STDMETHOD( LoadFileSettings )( void );
    STDMETHOD( LoadTraceSettings )( void );
    STDMETHOD( LoadOutputDestinations )( void );
    STDMETHOD( LoadFormat )( void );
    STDMETHOD( LoadStart )( void );
    STDMETHOD( Write )(OLECHAR* pString );

    BOOL                m_TraceOn;
    LONGLONG            m_TraceSettings;
    CWsbStringPtr       m_TraceFileName;
    ULONG               m_TraceOutput;
    BOOL                m_CommitEachEntry;
    BOOL                m_TimeStamp;
    BOOL                m_TraceCount;
    BOOL                m_TraceThreadId;
    BOOL                m_TraceEntryExit;
    WORD                m_LogLevel;
    LONGLONG            m_MaxTraceFileSize;
    HANDLE              m_TraceFilePointer;
    BOOL                m_WrapMode;
    CWsbStringPtr       m_RegistrySetting;
    CWsbStringPtr       m_TraceFileCopyName;
    CWsbStringPtr       m_TraceMultipleFilePattern;  // printf style pattern
    ULONG               m_TraceMultipleFileCount;    // count inserted into pattern
    CWsbStringPtr       m_TraceFileDir;              // directory for trace file
    CWsbStringPtr       m_TraceFileCopyDir;          // directory for trace file copy
    HANDLE              m_TraceCountHandle;
    PLONG               m_pTraceCountGlobal;
};
#endif // _WSBTRC_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\inc\wsbvar.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    wsbvar.h

Abstract:

    This class is a wrapper for the VARIANT structure, providing
    conversion and cleanup automatically. Current supported types
    for conversion are OLECHAR * (BSTR), IUnknown / IDispatch, and
    GUID. GUIDs are represented internally as strings.

Author:

    Rohde Wakefield          [rohde]   21-Jan-1997

Revision History:

--*/

#ifndef _WSBVAR_
#define _WSBVAR_

class WSB_EXPORT CWsbVariant : public tagVARIANT
{
public:
    CWsbVariant ( )  { Init  ( ); }
    ~CWsbVariant ( ) { Clear ( ); }

    HRESULT Clear ( ) { return ( VariantClear ( this ) ); }
    void    Init  ( ) { VariantInit ( this ); }

    BOOL IsEmpty ( )
    {
        return ( VT_EMPTY == vt );
    }

    CWsbVariant & operator = ( const VARIANT & variant )
    {
        VariantCopy ( this, (VARIANT *)&variant );
        return ( *this );
    }


    BOOL IsBstr ( )
    {
        return ( VT_BSTR == vt );
    }

    CWsbVariant ( const OLECHAR * string );
    CWsbVariant & operator = ( const OLECHAR * string );
    operator OLECHAR * ( );


    BOOL IsInterface ( )
    {
        return ( ( VT_UNKNOWN == vt ) || ( VT_DISPATCH == vt ) );
    }

    BOOL IsDispatch ( )
    {
        return ( ( VT_DISPATCH == vt ) );
    }

    CWsbVariant ( IUnknown * );
    CWsbVariant ( IDispatch * );
    operator IUnknown * ( );
    operator IDispatch * ( );
    CWsbVariant & operator = ( IUnknown * pUnk );
    CWsbVariant & operator = ( IDispatch * pDisp );

    CWsbVariant ( REFGUID rguid );
    CWsbVariant & operator = ( REFGUID rguid );
    operator GUID ();

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\inc\wsbver.h ===
/*++

Copyright (c) 1996  Microsoft Corporation
Copyright (c) Seagate Software Inc., 1997-1998

Module Name:

    WsbVer.h

Abstract:

    This module defines the correct copyright information for the Sakkara
    project executables / dlls / services / drivers / etc.

Author:

    Rohde Wakefield [rohde]     7-Dec-1997

Revision History:

--*/

#ifndef _WSBVER_
#define _WSBVER_

/*


In addition to including this file, it is necessary to define the 
following in the module's resource file:


VER_FILETYPE             - One of: VFT_APP, VFT_DLL, VFT_DRV

VER_FILESUBTYPE          - One of: VFT_UNKNOWN, VFT_DRV_SYSTEM, 
                         -         VFT_DRV_INSTALLABLE

VER_FILEDESCRIPTION_STR  - String describing module

VER_INTERNALNAME_STR     - Internal Name (Same as module name)

A Typical section would look like:


#define VER_FILETYPE                VFT_DLL
#define VER_FILESUBTYPE             VFT2_UNKNOWN
#define VER_FILEDESCRIPTION_STR     "Remote Storage Engine"
#define VER_INTERNALNAME_STR        "RsEng.exe"

#include "WsbVer.h"

*/


//
// Include some needed defines
//

#include <winver.h>
#include <ntverp.h>


//
// Overide copyright
//

/*** NOT ANYMORE - use default copyright, which is defined in common.ver    ***/

//
// And finally, define the version resource
//

#include <common.ver>

#endif // _WSBVER_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\job\dlldatax.c ===
// wrapper for dlldata.c

#ifdef _MERGE_PROXYSTUB // merge proxy stub DLL

#define REGISTER_PROXY_DLL //DllRegisterServer, etc.

#define USE_STUBLESS_PROXY  //defined only with MIDL switch /Oicf

#pragma comment(lib, "rpcndr.lib")
#pragma comment(lib, "rpcns4.lib")
#pragma comment(lib, "rpcrt4.lib")

#define DllMain             PrxDllMain
#define DllRegisterServer   PrxDllRegisterServer
#define DllUnregisterServer PrxDllUnregisterServer
#define DllGetClassObject   PrxDllGetClassObject
#define DllCanUnloadNow     PrxDllCanUnloadNow

#include "dlldata.c"
#include "jobint_p.c"

#ifdef _NOPROXY //no midl generated dlldata.c

#define STRICT 1
#include <ole2.h>

BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{return TRUE;}

STDAPI PrxDllCanUnloadNow(void){return S_OK;}

STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{return CLASS_E_CLASSNOTAVAILABLE;}

STDAPI PrxDllRegisterServer(void){return S_OK;}

STDAPI PrxDllUnregisterServer(void){return S_OK;}

#endif //!PROXY_DELEGATION

#endif //_MERGE_PROXYSTUB
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\job\dlldatax.h ===
#ifdef _MERGE_PROXYSTUB

extern "C" 
{
BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, 
    LPVOID lpReserved);
STDAPI PrxDllCanUnloadNow(void);
STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);
STDAPI PrxDllRegisterServer(void);
STDAPI PrxDllUnregisterServer(void);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\job\dlldataz.c ===
// wrapper for dlldata.c

#ifdef _MERGE_PROXYSTUB // merge proxy stub DLL

#define USE_STUBLESS_PROXY  //defined only with MIDL switch /Oicf

#pragma comment(lib, "rpcndr.lib")
#pragma comment(lib, "rpcns4.lib")
#pragma comment(lib, "rpcrt4.lib")

#include "jobprv_p.c"

#endif //_MERGE_PROXYSTUB
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\job\hsmacrsc.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    hsmacrsc.cpp

Abstract:

    This component represents the actions that can be performed by a job
    on a resource either before or after the scan.

Author:

    Ronald G. White [ronw]       14-Aug-1997

Revision History:

--*/

#include "resource.h"       // main symbols

#include "wsb.h"

#ifndef _HSMACRSC_
#define _HSMACRSC_


// Abstract Classes

/*++

Class Name:
    
    CHsmActionOnResource

Class Description:

    An abstract class that represents an action that can be performed
    on a resource. Specific actions are implemented as subclasses
    of this object.

--*/

class CHsmActionOnResource : 
    public CWsbObject,
    public IHsmActionOnResource
{
public:

// IPersistStream
public:
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER* /*pSize*/) {
            return(E_NOTIMPL); }
    STDMETHOD(Load)(IStream* pStream);
    STDMETHOD(Save)(IStream* pStream, BOOL clearDirty);

// IWsbTestable
    STDMETHOD(Test)(USHORT * /*passed*/, USHORT* /*failed*/) {
            return(E_NOTIMPL); }

// IHsmAction
    STDMETHOD(GetName)(OLECHAR** pName, ULONG bufferSize);

protected:
    ULONG       m_nameId;
};

/*++

Class Name:
    
    CHsmActionOnResourcePost

Class Description:

    An abstract class that represents an action that can be performed
    on a resource after a job. Specific actions are implemented as subclasses
    of this object.

--*/

class CHsmActionOnResourcePost : 
    public CHsmActionOnResource,
    public IHsmActionOnResourcePost
{
public:
};

/*++

Class Name:
    
    CHsmActionOnResourcePre

Class Description:

    An abstract class that represents an action that can be performed
    on a resource before a job starts. Specific actions are implemented as subclasses
    of this object.

--*/

class CHsmActionOnResourcePre : 
    public CHsmActionOnResource,
    public IHsmActionOnResourcePre
{
public:
};

/*++

Class Name:
    
    CHsmActionOnResourcePreScan

Class Description:

    An abstract class that represents an action that can be performed
    on a resource before scanning for a job starts. Specific actions are implemented as subclasses
    of this object.

--*/

class CHsmActionOnResourcePreScan : 
    public CHsmActionOnResource,
    public IHsmActionOnResourcePreScan
{
public:
};

// Concrete Classes : Inheriting from CHsmActionOnResource

/*++

Class Name:
    
    CHsmActionOnResourcePostValidate

Class Description:

    A class that represents the action required by the resource after
    a Validate job ends.

--*/

class CHsmActionOnResourcePostValidate :    
    public CHsmActionOnResourcePost,
    public CComCoClass<CHsmActionOnResourcePostValidate,&CLSID_CHsmActionOnResourcePostValidate>
{
public:
    CHsmActionOnResourcePostValidate() {}
BEGIN_COM_MAP(CHsmActionOnResourcePostValidate)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IHsmActionOnResource)
    COM_INTERFACE_ENTRY(IHsmActionOnResourcePost)
    COM_INTERFACE_ENTRY(IWsbCollectable)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_CHsmActionOnResourcePostValidate)

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);

// IHsmActionOnResource
public:
    STDMETHOD(Do)(IHsmJobWorkItem* pWorkItem, HSM_JOB_STATE state);
};

/*++

Class Name:
    
    CHsmActionOnResourcePreValidate

Class Description:

    A class that represents the action required by the resource before
    a Validate job starts.

--*/

class CHsmActionOnResourcePreValidate : 
    public CHsmActionOnResourcePre,
    public CComCoClass<CHsmActionOnResourcePreValidate,&CLSID_CHsmActionOnResourcePreValidate>
{
public:
    CHsmActionOnResourcePreValidate() {}
BEGIN_COM_MAP(CHsmActionOnResourcePreValidate)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IHsmActionOnResource)
    COM_INTERFACE_ENTRY(IHsmActionOnResourcePre)
    COM_INTERFACE_ENTRY(IWsbCollectable)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_CHsmActionOnResourcePreValidate)

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);

// IHsmActionOnResource
public:
    STDMETHOD(Do)(IHsmJobWorkItem* pWorkItem, IHsmJobDef* pJobDef);
};

/*++

Class Name:
    
    CHsmActionOnResourcePostUnmanage

Class Description:

    A class that represents the action required by the resource after
    a Unmanage job ends.

--*/

class CHsmActionOnResourcePostUnmanage :    
    public CHsmActionOnResourcePost,
    public CComCoClass<CHsmActionOnResourcePostUnmanage,&CLSID_CHsmActionOnResourcePostUnmanage>
{
public:
    CHsmActionOnResourcePostUnmanage() {}
BEGIN_COM_MAP(CHsmActionOnResourcePostUnmanage)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IHsmActionOnResource)
    COM_INTERFACE_ENTRY(IHsmActionOnResourcePost)
    COM_INTERFACE_ENTRY(IWsbCollectable)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_CHsmActionOnResourcePostUnmanage)

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);

// IHsmActionOnResource
public:
    STDMETHOD(Do)(IHsmJobWorkItem* pWorkItem, HSM_JOB_STATE state);
};

/*++

Class Name:
    
    CHsmActionOnResourcePreUnmanage

Class Description:

    A class that represents the action required by the resource before
    an Unmanage job ends.

--*/

class CHsmActionOnResourcePreUnmanage : 
    public CHsmActionOnResourcePre,
    public CComCoClass<CHsmActionOnResourcePreUnmanage,&CLSID_CHsmActionOnResourcePreUnmanage>
{
public:
    CHsmActionOnResourcePreUnmanage() {}
BEGIN_COM_MAP(CHsmActionOnResourcePreUnmanage)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IHsmActionOnResource)
    COM_INTERFACE_ENTRY(IHsmActionOnResourcePre)
    COM_INTERFACE_ENTRY(IWsbCollectable)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_CHsmActionOnResourcePreUnmanage)

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);

// IHsmActionOnResource
public:
    STDMETHOD(Do)(IHsmJobWorkItem* pWorkItem, IHsmJobDef* pJobDef);
};

/*++

Class Name:
    
    CHsmActionOnResourcePreScanUnmanage

Class Description:

    A class that represents the action required by the resource before 
    scanning for an Unmanage job ends.

--*/

class CHsmActionOnResourcePreScanUnmanage : 
    public CHsmActionOnResourcePreScan,
    public CComCoClass<CHsmActionOnResourcePreScanUnmanage,&CLSID_CHsmActionOnResourcePreScanUnmanage>
{
public:
    CHsmActionOnResourcePreScanUnmanage() {}
BEGIN_COM_MAP(CHsmActionOnResourcePreScanUnmanage)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IHsmActionOnResource)
    COM_INTERFACE_ENTRY(IHsmActionOnResourcePreScan)
    COM_INTERFACE_ENTRY(IWsbCollectable)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_CHsmActionOnResourcePreScanUnmanage)

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);

// IHsmActionOnResourcePreScan
public:
    STDMETHOD(Do)(IFsaResource* pFsaResource, IHsmSession* pSession);
};

#endif // _HSMACRSC_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\job\hsmactn.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    hsmactn.cpp

Abstract:

    This component represents the actions that can be performed by a policy.

Author:

    Chuck Bardeen   [cbardeen]   29-Oct-1996

Revision History:

--*/

#include "stdafx.h"
#include "stdio.h"

#include "wsb.h"
#include "job.h"
#include "hsmactn.h"

#define WSB_TRACE_IS        WSB_TRACE_BIT_JOB


HRESULT
CHsmAction::GetName(
    OUT OLECHAR** pName,
    IN ULONG bufferSize
    )

/*++

Implements:

  IHsmAction::GetName().

--*/
{
    HRESULT         hr = S_OK;
    CWsbStringPtr   tmpString;

    try {

        WsbAssert(0 != pName, E_POINTER);
        WsbAffirmHr(tmpString.LoadFromRsc(_Module.m_hInst, m_nameId));
        WsbAffirmHr(tmpString.CopyTo(pName, bufferSize));

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmAction::GetSizeMax(
    OUT ULARGE_INTEGER* pSize
    )

/*++

Implements:

  IPersistStream::GetSizeMax().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmAction::GetSizeMax"), OLESTR(""));

    try {
       
        WsbAssert(0 != pSize, E_POINTER);
        pSize->QuadPart = WsbPersistSizeOf(ULONG);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmAction::GetSizeMax"), OLESTR("hr = <%ls>, Size = <%ls>"), WsbHrAsString(hr), WsbPtrToUliAsString(pSize));

    return(hr);
}


HRESULT
CHsmAction::Load(
    IN IStream* pStream
    )

/*++

Implements:

  IPersistStream::Load().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmAction::Load"), OLESTR(""));

    try {

        WsbAssert(0 != pStream, E_POINTER);

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_nameId));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmAction::Load"), OLESTR("hr = <%ls>, nameId = <%lu>"), WsbHrAsString(hr), m_nameId);

    return(hr);
}


HRESULT
CHsmAction::Save(
    IN IStream* pStream,
    IN BOOL clearDirty
    )

/*++

Implements:

  IPersistStream::Save().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmAction::Save"), OLESTR("clearDirty = <%ls>"), WsbBoolAsString(clearDirty));
    
    try {

        WsbAssert(0 != pStream, E_POINTER);

        WsbAffirmHr(WsbSaveToStream(pStream, m_nameId));

        // If we got it saved and we were asked to clear the dirty bit, then
        // do so now.
        if (clearDirty) {
            m_isDirty = FALSE;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmAction::Save"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmAction::Test(
    USHORT* passed,
    USHORT* failed
    )

/*++

Implements:

  IWsbTestable::Test().

--*/
{
    HRESULT     hr = S_OK;

    try {

        WsbAssert(0 != passed, E_POINTER);
        WsbAssert(0 != failed, E_POINTER);

        *passed = 0;
        *failed = 0;

    } WsbCatch(hr);

    return(hr);
}




HRESULT
CHsmDirectedAction::FinalConstruct(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;
    
    try {

        WsbAffirmHr(CWsbObject::FinalConstruct());
        m_storagePoolId = GUID_NULL;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmDirectedAction::GetStoragePoolId(
    OUT GUID* pId
    )

/*++

Implements:

  IHsmDirectedAction::GetStoragePoolId().

--*/
{
    HRESULT     hr = S_OK;

    try {

        WsbAssert(0 != pId, E_POINTER);
        *pId = m_storagePoolId;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmDirectedAction::GetSizeMax(
    OUT ULARGE_INTEGER* pSize
    )

/*++

Implements:

  IPersistStream::GetSizeMax().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmDirectedAction::GetSizeMax"), OLESTR(""));

    try {
       
        WsbAssert(0 != pSize, E_POINTER);
        pSize->QuadPart = WsbPersistSizeOf(ULONG) + WsbPersistSizeOf(GUID);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmDirectedAction::GetSizeMax"), OLESTR("hr = <%ls>, Size = <%ls>"), WsbHrAsString(hr), WsbPtrToUliAsString(pSize));

    return(hr);
}


HRESULT
CHsmDirectedAction::Load(
    IN IStream* pStream
    )

/*++

Implements:

  IPersistStream::Load().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmDirectedAction::Load"), OLESTR(""));

    try {

        WsbAssert(0 != pStream, E_POINTER);

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_nameId));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_storagePoolId));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmDirectedAction::Load"), OLESTR("hr = <%ls>, nameId = <%lu>, storagePoolId = <%ls>"), WsbHrAsString(hr), m_nameId, WsbGuidAsString(m_storagePoolId));

    return(hr);
}


HRESULT
CHsmDirectedAction::Save(
    IN IStream* pStream,
    IN BOOL clearDirty
    )

/*++

Implements:

  IPersistStream::Save().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmDirectedAction::Save"), OLESTR("clearDirty = <%ls>"), WsbBoolAsString(clearDirty));
    
    try {

        WsbAssert(0 != pStream, E_POINTER);

        WsbAffirmHr(WsbSaveToStream(pStream, m_nameId));
        WsbAffirmHr(WsbSaveToStream(pStream, m_storagePoolId));

        // If we got it saved and we were asked to clear the dirty bit, then
        // do so now.
        if (clearDirty) {
            m_isDirty = FALSE;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmDirectedAction::Save"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmDirectedAction::SetStoragePoolId(
    IN GUID id
    )

/*++

Implements:

  IHsmDirectedAction::SetStoragePoolId().

--*/
{
    HRESULT     hr = S_OK;

    try {
        m_storagePoolId = id;
        m_isDirty = TRUE;
    } WsbCatch(hr);

    return(S_OK);
}



HRESULT
CHsmRelocateAction::ExpandPlaceholders(
    void
    )

/*++

Implements:

  IHsmRelocateAction::ExpandPlaceholders().

--*/
{
    return(m_expandPlaceholders ? S_OK : S_FALSE);
}


HRESULT
CHsmRelocateAction::FinalConstruct(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;
    
    try {

        WsbAffirmHr(CWsbObject::FinalConstruct());
        m_retainHierarchy = FALSE;;
        m_expandPlaceholders = FALSE;;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmRelocateAction::GetDestination(
    OUT OLECHAR** pDest,
    IN ULONG bufferSize
    )

/*++

Implements:

  IHsmRelocateAction::GetDestination().

--*/
{
    HRESULT     hr = S_OK;

    try {

        WsbAssert(0 != pDest, E_POINTER);
        WsbAffirmHr(m_dest.CopyTo(pDest, bufferSize));

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmRelocateAction::GetSizeMax(
    OUT ULARGE_INTEGER* pSize
    )

/*++

Implements:

  IPersistStream::GetSizeMax().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmRelocateAction::GetSizeMax"), OLESTR(""));

    try {
       
        WsbAssert(0 != pSize, E_POINTER);
        pSize->QuadPart = WsbPersistSizeOf(ULONG) + WsbPersistSizeOf(BOOL) + WsbPersistSizeOf(BOOL) + WsbPersistSize((wcslen(m_dest) + 1) * sizeof(OLECHAR));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmRelocateAction::GetSizeMax"), OLESTR("hr = <%ls>, Size = <%ls>"), WsbHrAsString(hr), WsbPtrToUliAsString(pSize));

    return(hr);
}


HRESULT
CHsmRelocateAction::Load(
    IN IStream* pStream
    )

/*++

Implements:

  IPersistStream::Load().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmRelocateAction::Load"), OLESTR(""));

    try {

        WsbAssert(0 != pStream, E_POINTER);

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_nameId));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_expandPlaceholders));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_retainHierarchy));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_dest, 0));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmRelocateAction::Load"), OLESTR("hr = <%ls>, expandPlaceholders = <%ls>, retainHierarchy = <%ls>, destination = <%ls>"), WsbHrAsString(hr), m_nameId, WsbBoolAsString(m_expandPlaceholders), WsbBoolAsString(m_retainHierarchy), m_dest);

    return(hr);
}


HRESULT
CHsmRelocateAction::RetainHierarchy(
    void
    )

/*++

Implements:

  IHsmRelocateAction::RetainHierarchy().

--*/
{
    return(m_retainHierarchy ? S_OK : S_FALSE);
}


HRESULT
CHsmRelocateAction::Save(
    IN IStream* pStream,
    IN BOOL clearDirty
    )

/*++

Implements:

  IPersistStream::Save().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmRelocateAction::Save"), OLESTR("clearDirty = <%ls>"), WsbBoolAsString(clearDirty));
    
    try {

        WsbAssert(0 != pStream, E_POINTER);

        WsbAffirmHr(WsbSaveToStream(pStream, m_nameId));
        WsbAffirmHr(WsbSaveToStream(pStream, m_expandPlaceholders));
        WsbAffirmHr(WsbSaveToStream(pStream, m_retainHierarchy));
        WsbAffirmHr(WsbSaveToStream(pStream, m_dest));

        // If we got it saved and we were asked to clear the dirty bit, then
        // do so now.
        if (clearDirty) {
            m_isDirty = FALSE;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmRelocateAction::Save"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmRelocateAction::SetDestination(
    IN OLECHAR* dest
    )

/*++

Implements:

  IHsmRelocateAction::SetDestination().

--*/
{
    HRESULT     hr = S_OK;

    try {

        m_dest = dest;
        m_isDirty = TRUE;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmRelocateAction::SetExpandPlaceholders(
    IN BOOL expandPlaceholders
    )

/*++

Implements:

  IHsmRelocateAction::SetExpandPlaceholders().

--*/
{
    HRESULT     hr = S_OK;

    try {

        m_expandPlaceholders = expandPlaceholders;
        m_isDirty = TRUE;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmRelocateAction::SetRetainHierarchy(
    IN BOOL retainHierarchy
    )

/*++

Implements:

  IHsmRelocateAction::SetRetainHierarchy().

--*/
{
    HRESULT     hr = S_OK;

    try {

        m_retainHierarchy = retainHierarchy;
        m_isDirty = TRUE;

    } WsbCatch(hr);

    return(hr);
}



HRESULT
CHsmActionDelete::Do(
    IFsaScanItem* pScanItem
    )

/*++

Implements:

  IHsmAction::Do().

--*/
{
    HRESULT     hr = S_OK;

    try {

        WsbAssert(0 != pScanItem, E_POINTER);
        WsbAffirmHr(pScanItem->Delete());

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmActionDelete::FinalConstruct(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;
    
    try {

        WsbAffirmHr(CWsbObject::FinalConstruct());
        m_nameId = IDS_HSMACTIONDELETE_ID;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmActionDelete::GetClassID(
    OUT CLSID* pClsid
    )

/*++

Implements:

  IPersist::GetClassID().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmActionDelete::GetClassID"), OLESTR(""));

    try {

        WsbAssert(0 != pClsid, E_POINTER);
        *pClsid = CLSID_CHsmActionDelete;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmActionDelete::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return(hr);
}



HRESULT
CHsmActionRecall::Do(
    IFsaScanItem* pScanItem
    )

/*++

Implements:

  IHsmAction::Do().

--*/
{
    HRESULT             hr = S_OK;
    LONGLONG            offset = 0;
    LONGLONG            size = 0;
    FSA_PLACEHOLDER     placeholder;

    try {

        WsbAssert(0 != pScanItem, E_POINTER);

        // Iterate overall the reparsed areas.
        for (hr = pScanItem->FindFirstPlaceholder(&offset, &size, &placeholder);
            SUCCEEDED(hr);
            hr = pScanItem->FindNextPlaceholder(&offset, &size, &placeholder)) {

            WsbAffirmHr(pScanItem->Recall(offset, size, FALSE));
        }

        if (WSB_E_NOTFOUND == hr) {
            hr = S_OK;
        }

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmActionRecall::FinalConstruct(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;
    
    try {

        WsbAffirmHr(CWsbObject::FinalConstruct());
        m_nameId = IDS_HSMACTIONRECALL_ID;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmActionRecall::GetClassID(
    OUT CLSID* pClsid
    )

/*++

Implements:

  IPersist::GetClassID().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmActionRecall::GetClassID"), OLESTR(""));

    try {

        WsbAssert(0 != pClsid, E_POINTER);
        *pClsid = CLSID_CHsmActionRecall;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmActionRecall::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return(hr);
}



HRESULT
CHsmActionRecycle::Do(
    IFsaScanItem* pScanItem
    )

/*++

Implements:

  IHsmAction::Do().

--*/
{
    HRESULT     hr = S_OK;

    try {

        WsbAssert(0 != pScanItem, E_POINTER);
        WsbAffirmHr(pScanItem->Recycle());

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmActionRecycle::FinalConstruct(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;
    
    try {

        WsbAffirmHr(CWsbObject::FinalConstruct());
        m_nameId = IDS_HSMACTIONRECYCLE_ID;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmActionRecycle::GetClassID(
    OUT CLSID* pClsid
    )

/*++

Implements:

  IPersist::GetClassID().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmActionRecycle::GetClassID"), OLESTR(""));

    try {

        WsbAssert(0 != pClsid, E_POINTER);
        *pClsid = CLSID_CHsmActionRecycle;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmActionRecycle::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return(hr);
}



HRESULT
CHsmActionTruncate::Do(
    IFsaScanItem* pScanItem
    )

/*++

Implements:

  IHsmAction::Do().

--*/
{
    HRESULT     hr = S_OK;
    LONGLONG    size;

    try {

        WsbAssert(0 != pScanItem, E_POINTER);

        WsbAffirmHr(pScanItem->GetLogicalSize(&size));
        WsbAffirmHr(pScanItem->Truncate(0, size));

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmActionTruncate::FinalConstruct(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;
    
    try {

        WsbAffirmHr(CWsbObject::FinalConstruct());
        m_nameId = IDS_HSMACTIONTRUNCATE_ID;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmActionTruncate::GetClassID(
    OUT CLSID* pClsid
    )

/*++

Implements:

  IPersist::GetClassID().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmActionTruncate::GetClassID"), OLESTR(""));

    try {

        WsbAssert(0 != pClsid, E_POINTER);
        *pClsid = CLSID_CHsmActionTruncate;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmActionTruncate::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return(hr);
}



HRESULT
CHsmActionUnmanage::Do(
    IFsaScanItem* pScanItem
    )

/*++

Implements:

  IHsmAction::Do().

--*/
{
    HRESULT             hr = S_OK;
    LONGLONG            offset;
    LONGLONG            size;
    FSA_PLACEHOLDER     placeholder;

    try {

        WsbAssert(0 != pScanItem, E_POINTER);

        // Iterate overall the reparsed areas.
        for (hr = pScanItem->FindFirstPlaceholder(&offset, &size, &placeholder);
            SUCCEEDED(hr);
            hr = pScanItem->FindNextPlaceholder(&offset, &size, &placeholder)) {

            WsbAffirmHr(pScanItem->Unmanage(offset, size));
        }

        if (WSB_E_NOTFOUND == hr) {
            hr = S_OK;
        }

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmActionUnmanage::FinalConstruct(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;
    
    try {

        WsbAffirmHr(CWsbObject::FinalConstruct());
        m_nameId = IDS_HSMACTIONUNMANAGE_ID;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmActionUnmanage::GetClassID(
    OUT CLSID* pClsid
    )

/*++

Implements:

  IPersist::GetClassID().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmActionUnmanage::GetClassID"), OLESTR(""));

    try {

        WsbAssert(0 != pClsid, E_POINTER);
        *pClsid = CLSID_CHsmActionUnmanage;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmActionUnmanage::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return(hr);
}



HRESULT
CHsmActionValidate::Do(
    IFsaScanItem* pScanItem
    )

/*++

Implements:

  IHsmAction::Do().

--*/
{
    HRESULT             hr = S_OK;
    LONGLONG            offset;
    LONGLONG            size;
    FSA_PLACEHOLDER     placeholder;

    try {

        WsbAssert(0 != pScanItem, E_POINTER);

        // Iterate overall the reparsed areas.
        for (hr = pScanItem->FindFirstPlaceholder(&offset, &size, &placeholder);
            SUCCEEDED(hr);
            hr = pScanItem->FindNextPlaceholder(&offset, &size, &placeholder)) {

            WsbAffirmHr(pScanItem->Validate(offset, size));
        }

        if (WSB_E_NOTFOUND == hr) {
            hr = S_OK;
        }

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmActionValidate::FinalConstruct(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;
    
    try {

        WsbAffirmHr(CWsbObject::FinalConstruct());
        m_nameId = IDS_HSMACTIONVALIDATE_ID;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmActionValidate::GetClassID(
    OUT CLSID* pClsid
    )

/*++

Implements:

  IPersist::GetClassID().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmActionValidate::GetClassID"), OLESTR(""));

    try {

        WsbAssert(0 != pClsid, E_POINTER);
        *pClsid = CLSID_CHsmActionValidate;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmActionValidate::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return(hr);
}



HRESULT
CHsmActionManage::Do(
    IFsaScanItem* pScanItem
    )

/*++

Implements:

  IHsmAction::Do().

--*/
{
    HRESULT     hr = S_OK;
    LONGLONG    size;

    WsbTraceIn(OLESTR("CHsmActionManage::Do"), OLESTR(""));

    try {

        WsbAssert(0 != pScanItem, E_POINTER);

        WsbAffirmHr(pScanItem->GetLogicalSize(&size));
        WsbAffirmHr(pScanItem->Manage(0, size, m_storagePoolId, FALSE));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmActionManage::Do"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmActionManage::FinalConstruct(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;
    
    try {

        WsbAffirmHr(CHsmDirectedAction::FinalConstruct());
        m_nameId = IDS_HSMACTIONMANAGE_ID;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmActionManage::GetClassID(
    OUT CLSID* pClsid
    )

/*++

Implements:

  IPersist::GetClassID().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmActionManage::GetClassID"), OLESTR(""));

    try {

        WsbAssert(0 != pClsid, E_POINTER);
        *pClsid = CLSID_CHsmActionManage;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmActionManage::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return(hr);
}



HRESULT
CHsmActionMigrate::Do(
    IFsaScanItem* pScanItem
    )

/*++

Implements:

  IHsmAction::Do().

--*/
{
    HRESULT     hr = S_OK;
    LONGLONG    size;

    try {

        WsbAssert(0 != pScanItem, E_POINTER);

        WsbAffirmHr(pScanItem->GetLogicalSize(&size));
        WsbAffirmHr(pScanItem->Manage(0, size, m_storagePoolId, TRUE));

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmActionMigrate::FinalConstruct(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;
    
    try {

        WsbAffirmHr(CHsmDirectedAction::FinalConstruct());
        m_nameId = IDS_HSMACTIONMIGRATE_ID;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmActionMigrate::GetClassID(
    OUT CLSID* pClsid
    )

/*++

Implements:

  IPersist::GetClassID().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmActionMigrate::GetClassID"), OLESTR(""));

    try {

        WsbAssert(0 != pClsid, E_POINTER);
        *pClsid = CLSID_CHsmActionMigrate;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmActionMigrate::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return(hr);
}



HRESULT
CHsmActionCopy::Do(
    IFsaScanItem* pScanItem
    )

/*++

Implements:

  IHsmAction::Do().

--*/
{
    HRESULT     hr = S_OK;

    try {

        WsbAssert(0 != pScanItem, E_POINTER);
        WsbAffirmHr(pScanItem->Copy(m_dest, m_retainHierarchy, m_expandPlaceholders, TRUE));

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmActionCopy::FinalConstruct(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;
    
    try {

        WsbAffirmHr(CHsmRelocateAction::FinalConstruct());
        m_nameId = IDS_HSMACTIONCOPY_ID;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmActionCopy::GetClassID(
    OUT CLSID* pClsid
    )

/*++

Implements:

  IPersist::GetClassID().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmActionCopy::GetClassID"), OLESTR(""));

    try {

        WsbAssert(0 != pClsid, E_POINTER);
        *pClsid = CLSID_CHsmActionCopy;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmActionCopy::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return(hr);
}



HRESULT
CHsmActionMove::Do(
    IFsaScanItem* pScanItem
    )

/*++

Implements:

  IHsmAction::Do().

--*/
{
    HRESULT     hr = S_OK;

    try {

        WsbAssert(0 != pScanItem, E_POINTER);
        WsbAffirmHr(pScanItem->Move(m_dest, m_retainHierarchy, m_expandPlaceholders, TRUE));

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmActionMove::FinalConstruct(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;
    
    try {

        WsbAffirmHr(CHsmRelocateAction::FinalConstruct());
        m_nameId = IDS_HSMACTIONMOVE_ID;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmActionMove::GetClassID(
    OUT CLSID* pClsid
    )

/*++

Implements:

  IPersist::GetClassID().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmActionMove::GetClassID"), OLESTR(""));

    try {

        WsbAssert(0 != pClsid, E_POINTER);
        *pClsid = CLSID_CHsmActionMove;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmActionMove::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\job\hsmacrsc.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    hsmacrsc.cpp

Abstract:

    This component represents the actions that can be performed by a job
    on a resource either before or after the scan.

Author:

    Ronald G. White [ronw]       14-Aug-1997

Revision History:

--*/

#include "stdafx.h"
#include "stdio.h"

#include "wsb.h"
#include "job.h"
#include "HsmConn.h"
#include "hsmacrsc.h"

#include "fsaprv.h"
#include "fsa.h"

#define WSB_TRACE_IS        WSB_TRACE_BIT_JOB


HRESULT
CHsmActionOnResource::GetName(
    OUT OLECHAR** pName,
    IN ULONG bufferSize
    )

/*++

Implements:

  IHsmActionOnResource::GetName().

--*/
{
    HRESULT         hr = S_OK;
    CWsbStringPtr   tmpString;

    try {

        WsbAssert(0 != pName, E_POINTER);
        WsbAffirmHr(tmpString.LoadFromRsc(_Module.m_hInst, m_nameId));
        WsbAffirmHr(tmpString.CopyTo(pName, bufferSize));

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmActionOnResource::Load(
    IN IStream* pStream
    )

/*++

Implements:

  IPersistStream::Load().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmActionOnResource::Load"), OLESTR(""));

    try {

        WsbAssert(0 != pStream, E_POINTER);

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_nameId));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmActionOnResource::Load"), OLESTR("hr = <%ls>, nameId = <%lu>"), WsbHrAsString(hr), m_nameId);

    return(hr);
}


HRESULT
CHsmActionOnResource::Save(
    IN IStream* pStream,
    IN BOOL clearDirty
    )

/*++

Implements:

  IPersistStream::Save().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmActionOnResource::Save"), OLESTR("clearDirty = <%ls>"), WsbBoolAsString(clearDirty));
    
    try {

        WsbAssert(0 != pStream, E_POINTER);

        WsbAffirmHr(WsbSaveToStream(pStream, m_nameId));

        // If we got it saved and we were asked to clear the dirty bit, then
        // do so now.
        if (clearDirty) {
            m_isDirty = FALSE;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmActionOnResource::Save"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}



HRESULT
CHsmActionOnResourcePostValidate::Do(
    IHsmJobWorkItem* pWorkItem,
    HSM_JOB_STATE state
    )

/*++

Implements:

  IHsmActionOnResource::Do().

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("CHsmActionOnResourcePostValidate::Do"), 
            OLESTR("pWorkItem = %p, state = %ld"), pWorkItem,
            (LONG)state);

    try {
        GUID                      id;
        CComPtr<IFsaResource>     pResource;

        WsbAssertPointer(pWorkItem);

        //  Get resource associated with this work item
        WsbAffirmHr(pWorkItem->GetResourceId(&id));
        WsbAffirmHr(HsmConnectFromId(HSMCONN_TYPE_RESOURCE, id, IID_IFsaResource, (void**) &pResource));

        //  Tell the resource what's happening
        WsbAffirmHr(pResource->EndValidate(state));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmActionOnResourcePostValidate::Do"), 
            OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmActionOnResourcePostValidate::GetClassID(
    OUT CLSID* pClsid
    )

/*++

Implements:

  IPersist::GetClassID().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmActionOnResourcePostValidate::GetClassID"), OLESTR(""));

    try {

        WsbAssert(0 != pClsid, E_POINTER);
        *pClsid = CLSID_CHsmActionOnResourcePostValidate;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmActionOnResourcePostValidate::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return(hr);
}


HRESULT
CHsmActionOnResourcePostValidate::FinalConstruct(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmActionOnResourcePostValidate::FinalConstruct"), OLESTR(""));
    
    try {

        WsbAffirmHr(CHsmActionOnResource::FinalConstruct());
        m_nameId = IDS_HSMACTIONONRESOURCEPOSTVALIDATE_ID;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmActionOnResourcePostValidate::FinalConstruct"), 
            OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}



HRESULT
CHsmActionOnResourcePreValidate::Do(
    IHsmJobWorkItem* pWorkItem,
    IHsmJobDef* pJobDef
    )

/*++

Implements:

  IHsmActionOnResource::Do().

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("CHsmActionOnResourcePreValidate::Do"), 
            OLESTR("pWorkItem = %p, pJobDef=%p"), pWorkItem, pJobDef);

    try {
        GUID                      id;
        CComPtr<IFsaResource>     pResource;

        WsbAssertPointer(pWorkItem);

        //  Get resource associated with this work item
        WsbAffirmHr(pWorkItem->GetResourceId(&id));
        WsbAffirmHr(HsmConnectFromId(HSMCONN_TYPE_RESOURCE, id, IID_IFsaResource, (void**) &pResource));

        //  Tell the resource what's happening
        WsbAffirmHr(pResource->BeginValidate());

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmActionOnResourcePreValidate::Do"), 
            OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmActionOnResourcePreValidate::GetClassID(
    OUT CLSID* pClsid
    )

/*++

Implements:

  IPersist::GetClassID().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmActionOnResourcePreValidate::GetClassID"), OLESTR(""));

    try {

        WsbAssert(0 != pClsid, E_POINTER);
        *pClsid = CLSID_CHsmActionOnResourcePreValidate;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmActionOnResourcePreValidate::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return(hr);
}


HRESULT
CHsmActionOnResourcePreValidate::FinalConstruct(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmActionOnResourcePreValidate::FinalConstruct"), 
            OLESTR(""));
    
    try {

        WsbAffirmHr(CHsmActionOnResource::FinalConstruct());
        m_nameId = IDS_HSMACTIONONRESOURCEPREVALIDATE_ID;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmActionOnResourcePreValidate::FinalConstruct"), 
            OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

HRESULT
CHsmActionOnResourcePostUnmanage::Do(
    IHsmJobWorkItem* pWorkItem,
    HSM_JOB_STATE state
    )

/*++

Implements:

  IHsmActionOnResource::Do().

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("CHsmActionOnResourcePostUnmanage::Do"), 
            OLESTR("pWorkItem = %p, state = %ld"), pWorkItem,
            (LONG)state);

    try {
        GUID                      id, hsmId;
        CComPtr<IFsaResource>     pResource;
        CComPtr<IFsaResourcePriv> pResourcePriv;
        CComPtr<IHsmServer>       pHsm;

        WsbAssertPointer(pWorkItem);

        //  Get resource associated with this work item
        WsbAffirmHr(pWorkItem->GetResourceId(&id));
        WsbAffirmHr(HsmConnectFromId(HSMCONN_TYPE_RESOURCE, id, IID_IFsaResource, (void**) &pResource));

        // Delete the temporary Unmanage database that we use for scanning in the right order (ignore errors)
        hr = pResource->QueryInterface(IID_IFsaResourcePriv, (void**) &pResourcePriv);
        if (SUCCEEDED(hr)) {
            // ignore errors
            (void)pResourcePriv->TerminateUnmanageDb();
        }

        // Get back to the HSM system so we can remove it

        WsbAffirmHr(pResource->GetManagingHsm(&hsmId));
        WsbAffirmHr(HsmConnectFromId(HSMCONN_TYPE_HSM, hsmId, IID_IHsmServer, (void**) &pHsm));

        // Get the collection and find the coresponding object
        CComPtr<IWsbIndexedCollection> pCollection;
        WsbAffirmHr(pHsm->GetManagedResources(&pCollection));

        CComPtr<IWsbCreateLocalObject> pCreate;
        WsbAffirmHr(pHsm->QueryInterface(IID_IWsbCreateLocalObject, (void**) &pCreate));

        CComPtr<IHsmManagedResource> pHsmResourceKey, pHsmResource;
        WsbAffirmHr(pCreate->CreateInstance(CLSID_CHsmManagedResource, IID_IHsmManagedResource, (void**) &pHsmResourceKey));
        WsbAffirmHr(pHsmResourceKey->SetResourceId(id));

        WsbAffirmHr(pCollection->Find(pHsmResourceKey, IID_IHsmManagedResource, (void**) &pHsmResource));

        // Remove the volume from management
        WsbAffirmHr(pCollection->RemoveAndRelease(pHsmResource));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmActionOnResourcePostUnmanage::Do"), 
            OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmActionOnResourcePostUnmanage::GetClassID(
    OUT CLSID* pClsid
    )

/*++

Implements:

  IPersist::GetClassID().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmActionOnResourcePostUnmanage::GetClassID"), OLESTR(""));

    try {

        WsbAssert(0 != pClsid, E_POINTER);
        *pClsid = CLSID_CHsmActionOnResourcePostUnmanage;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmActionOnResourcePostUnmanage::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return(hr);
}


HRESULT
CHsmActionOnResourcePostUnmanage::FinalConstruct(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmActionOnResourcePostUnmanage::FinalConstruct"), OLESTR(""));
    
    try {

        WsbAffirmHr(CHsmActionOnResource::FinalConstruct());
        m_nameId = IDS_HSMACTIONONRESOURCEPOSTUNMANAGE_ID;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmActionOnResourcePostUnmanage::FinalConstruct"), 
            OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmActionOnResourcePreUnmanage::Do(
    IHsmJobWorkItem* pWorkItem,
    IHsmJobDef* pJobDef
    )

/*++

Implements:

  IHsmActionOnResource::Do().

--*/
{
    HRESULT             hr = S_OK;

    WsbTraceIn(OLESTR("CHsmActionOnResourcePreUnmanage::Do"), 
            OLESTR("pWorkItem = %p, pJobDef=%p"), pWorkItem, pJobDef);

    try {
        GUID                                        id;
        CComPtr<IFsaResource>                       pResource;

        CComPtr<IHsmServer>                         pHsm;
        CComPtr<IWsbCreateLocalObject>              pCreateObj;
        CComPtr<IHsmActionOnResourcePreScan>        pActionResourcePreScan;
        GUID                                        hsmId = GUID_NULL;

        WsbAssertPointer(pWorkItem);
        WsbAssertPointer(pJobDef);

        // Create a pre-scan action and assign to the job definition
        // Note: Naturally, creating the pre-scan action would have been done in CHsmJobDef::InitAs
        //       However, since we cannot add new persistent members to JobDef (.col files mismatch on upgrade...),
        //       we let the pre-action to create a pre-scan-action if necessary
        WsbAffirmHr(pJobDef->SetUseDbIndex(TRUE));

        // hsm-id is not used today in HsmConnectFromId for HSMCONN_TYPE_HSM
        // When it does - use IFsaResource::GetManagingHsm to get the hsm-id
        WsbAffirmHr(HsmConnectFromId(HSMCONN_TYPE_HSM, hsmId, IID_IHsmServer, (void**) &pHsm));
        WsbAffirmHr(pHsm->QueryInterface(IID_IWsbCreateLocalObject, (void**) &pCreateObj));
        WsbAffirmHr(pCreateObj->CreateInstance(CLSID_CHsmActionOnResourcePreScanUnmanage,
                        IID_IHsmActionOnResourcePreScan, (void**) &pActionResourcePreScan));
        WsbAffirmHr(pJobDef->SetPreScanActionOnResource(pActionResourcePreScan));

        //  Get resource associated with this work item
        WsbAffirmHr(pWorkItem->GetResourceId(&id));
        WsbAffirmHr(HsmConnectFromId(HSMCONN_TYPE_RESOURCE, id, IID_IFsaResource, (void**) &pResource));

        //  Tell the resource what's happening
        WsbAffirmHr(pResource->SetIsDeletePending( TRUE ));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmActionOnResourcePreUnmanage::Do"), 
            OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmActionOnResourcePreUnmanage::GetClassID(
    OUT CLSID* pClsid
    )

/*++

Implements:

  IPersist::GetClassID().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmActionOnResourcePreUnmanage::GetClassID"), OLESTR(""));

    try {

        WsbAssert(0 != pClsid, E_POINTER);
        *pClsid = CLSID_CHsmActionOnResourcePreUnmanage;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmActionOnResourcePreUnmanage::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return(hr);
}


HRESULT
CHsmActionOnResourcePreUnmanage::FinalConstruct(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmActionOnResourcePreUnmanage::FinalConstruct"), 
            OLESTR(""));
    
    try {

        WsbAffirmHr(CHsmActionOnResource::FinalConstruct());
        m_nameId = IDS_HSMACTIONONRESOURCEPREUNMANAGE_ID;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmActionOnResourcePreUnmanage::FinalConstruct"), 
            OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

HRESULT
CHsmActionOnResourcePreScanUnmanage::Do(
    IFsaResource* pFsaResource,
    IHsmSession* pSession
    )

/*++

Implements:

  IHsmActionOnResource::Do().

--*/
{
    HRESULT                     hr = S_OK;

    CComPtr<IFsaUnmanageDb>    pUnmanageDb;
    CComPtr<IWsbDbSession>      pDbSession;
    CComPtr<IFsaUnmanageRec>    pUnmanageRec;
    BOOL                        bDbOpen = FALSE;

    WsbTraceIn(OLESTR("CHsmActionOnResourcePreScanUnmanage::Do"), OLESTR(""));

    try {
        CComPtr<IFsaResourcePriv>   pResourcePriv;
        CComPtr<IFsaScanItem>       pScanItem;
        CComPtr<IHsmServer>         pHsmServer;
        GUID                        hsmId = GUID_NULL;

        // Scan according to RP index and fill the Db
        // Don't need recursive scanning since we scan the RP index of the volume
        hr = pFsaResource->FindFirstInRPIndex(pSession, &pScanItem);

        if (SUCCEEDED(hr)) {
            // At least one managed file is found...
            // Initialize the Unmanaged Db for this resource
            WsbAffirmHr(pFsaResource->QueryInterface(IID_IFsaResourcePriv, (void**) &pResourcePriv));
            WsbAffirmHr(pResourcePriv->InitializeUnmanageDb());

            // Get and open the database
            WsbAffirmHr(pResourcePriv->GetUnmanageDb(IID_IFsaUnmanageDb, (void**) &pUnmanageDb));
            WsbAffirmHr(pUnmanageDb->Open(&pDbSession));
            bDbOpen = TRUE;

            // Get a record to work with 
            WsbAffirmHr(pUnmanageDb->GetEntity(pDbSession, UNMANAGE_REC_TYPE, IID_IFsaUnmanageRec, (void**) &pUnmanageRec));

            // Get HSM Server
            // Note: hsm-id is not used today in HsmConnectFromId for HSMCONN_TYPE_HSM
            // When it does - use IFsaResource::GetManagingHsm to get the hsm-id
            WsbAffirmHr(HsmConnectFromId(HSMCONN_TYPE_HSM, hsmId, IID_IHsmServer, (void**) &pHsmServer));
        }

        while (SUCCEEDED(hr)) {
            LONGLONG        offset = 0;
            LONGLONG        size = 0;
            FSA_PLACEHOLDER placeholder;

            GUID            mediaId;
            LONGLONG        fileOffset;
            LONGLONG        fileId;  
            LONGLONG        segOffset;

            hr = pScanItem->GetPlaceholder(offset, size, &placeholder);
            if (S_OK == hr) {
                // File must be managed by HSM
                // If the file is truncated, then we need to add to the Db
                if (pScanItem->IsTruncated(offset, size) == S_OK) {

                    // Get segment details from the Engine and calculate absolute offset
                    WsbAffirmHr(pHsmServer->GetSegmentPosition(placeholder.bagId, placeholder.fileStart,
                             placeholder.fileSize, &mediaId, &segOffset));
                    fileOffset = segOffset + placeholder.fileStart + placeholder.dataStart;
                        
                    // Add to the Unmanage database
                    WsbAffirmHr(pScanItem->GetFileId(&fileId));
                    WsbAffirmHr(pUnmanageRec->SetMediaId(mediaId));
                    WsbAffirmHr(pUnmanageRec->SetFileOffset(fileOffset));
                    WsbAffirmHr(pUnmanageRec->SetFileId(fileId));

                    WsbAffirmHr(pUnmanageRec->MarkAsNew());
                    WsbAffirmHr(pUnmanageRec->Write());

                } else {

                    // Note: We will continue here even if we fail to cleanup non-truncated files, because  
                    // the auto-truncator is suspended (so no premigrated files will become truncated while 
                    // the job is running) and this piece of code will be tried again in CFsaScanItem::Unmanage
                    try {

                        //  For disaster recovery, it would be better to delete the placeholder
                        //  and THEN remove this file from the premigration list.  Unfortunately,
                        //  after deleting the placeholder, the RemovePremigrated call fails
                        //  because it needs to get some information from the placeholder (which
                        //  is gone).  So we do it in this order.
                        hr = pFsaResource->RemovePremigrated(pScanItem, offset, size);
                        if (WSB_E_NOTFOUND == hr) {
                            //  It's no tragedy if this file wasn't in the list since we were
                            //  going to delete it anyway (although it shouldn't happen) so
                            //  let's continue anyway
                            hr = S_OK;
                        }
                        WsbAffirmHr(hr);

                        WsbAffirmHr(pScanItem->DeletePlaceholder(offset, size));

                    } WsbCatchAndDo(hr, 
                            WsbTraceAlways(OLESTR("...PreScanUnmanage::Do: failed to handle premigrated file, hr = <%ls>\n"),
                                WsbHrAsString(hr));
                            hr = S_OK;
                    );
                }   
            }

            // Get next file
            hr = pFsaResource->FindNextInRPIndex(pScanItem);
        }

        if (hr == WSB_E_NOTFOUND) {
            hr = S_OK;
        }

    } WsbCatch(hr);

    if (bDbOpen) {
        pUnmanageRec = 0;
        (void)pUnmanageDb->Close(pDbSession);
    }

    if (! SUCCEEDED(hr)) {
        // Log an error message 
        CWsbStringPtr tmpString;
        hr = pFsaResource->GetPath(&tmpString, 0);
        if (hr != S_OK) {
            tmpString = OLESTR("");
        }
        WsbLogEvent(JOB_MESSAGE_UNMANAGE_PRESCAN_FAILED, 0, NULL, (WCHAR *)tmpString, WsbHrAsString(hr), NULL);
    }

    WsbTraceOut(OLESTR("CHsmActionOnResourcePreScanUnmanage::Do"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

HRESULT
CHsmActionOnResourcePreScanUnmanage::GetClassID(
    OUT CLSID* pClsid
    )

/*++

Implements:

  IPersist::GetClassID().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmActionOnResourcePreScanUnmanage::GetClassID"), OLESTR(""));

    try {

        WsbAssert(0 != pClsid, E_POINTER);
        *pClsid = CLSID_CHsmActionOnResourcePreScanUnmanage;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmActionOnResourcePreScanUnmanage::GetClassID"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

HRESULT
CHsmActionOnResourcePreScanUnmanage::FinalConstruct(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmActionOnResourcePreScanUnmanage::FinalConstruct"), OLESTR(""));
    
    try {

        WsbAffirmHr(CHsmActionOnResource::FinalConstruct());
        m_nameId = IDS_HSMACTIONONRESOURCEPRESCANUNMANAGE_ID;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmActionOnResourcePreScanUnmanage::FinalConstruct"), 
            OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\job\hsmactn.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    hsmactn.cpp

Abstract:

    This component represents the actions that can be performed by a policy.

Author:

    Chuck Bardeen   [cbardeen]   29-Oct-1996

Revision History:

--*/

#include "resource.h"       // main symbols

#include "wsb.h"

#ifndef _HSMACTN_
#define _HSMACTN_


// Abstract Classes

/*++

Class Name:
    
    CHsmAction

Class Description:

    An abstract class that represents an action that can be performed
    upon an FsaScanItem. Specific actions are implemented as subclasses
    of this object.

--*/

class CHsmAction : 
    public CWsbObject,
    public IHsmAction
{
public:

// IPersistStream
public:
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER* pSize);
    STDMETHOD(Load)(IStream* pStream);
    STDMETHOD(Save)(IStream* pStream, BOOL clearDirty);

// IHsmAction
    STDMETHOD(GetName)(OLECHAR** pName, ULONG bufferSize);

// IWsbTestable
    STDMETHOD(Test)(USHORT *passed, USHORT* failed);

protected:
    ULONG       m_nameId;
};



/*++

Class Name:
    
    CHsmDirectedAction

Class Description:

    An abstract class that represents an action that can be performed
    upon an FsaScanItem that is directed towards a particular storage pool.

--*/

class CHsmDirectedAction : 
    public CHsmAction,
    public IHsmDirectedAction
{
public:
// CComObjectRoot
    STDMETHOD(FinalConstruct)(void);

// IPersistStream
public:
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER* pSize);
    STDMETHOD(Load)(IStream* pStream);
    STDMETHOD(Save)(IStream* pStream, BOOL clearDirty);

// IHsmDirectedAction
public:
    STDMETHOD(GetStoragePoolId)(GUID* pId);
    STDMETHOD(SetStoragePoolId)(GUID id);

protected:
    GUID    m_storagePoolId;
};

    
/*++

Class Name:
    
    CHsmRelocateAction

Class Description:

    An abstract class that represents an action that can be performed
    upon an FsaScanItem that relocates the item to a particular path.

--*/

class CHsmRelocateAction : 
    public CHsmAction,
    public IHsmRelocateAction
{
public:
// CComObjectRoot
    STDMETHOD(FinalConstruct)(void);

// IPersistStream
public:
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER* pSize);
    STDMETHOD(Load)(IStream* pStream);
    STDMETHOD(Save)(IStream* pStream, BOOL clearDirty);

public:
// IHsmRelocateAction
    STDMETHOD(ExpandPlaceholders)(void);
    STDMETHOD(GetDestination)(OLECHAR** pDest, ULONG bufferSize);
    STDMETHOD(RetainHierarchy)(void);
    STDMETHOD(SetDestination)(OLECHAR* dest);
    STDMETHOD(SetExpandPlaceholders)(BOOL expandPlaceholders);
    STDMETHOD(SetRetainHierarchy)(BOOL retainHierarchy);

protected:
    CWsbStringPtr   m_dest;
    BOOL            m_expandPlaceholders;
    BOOL            m_retainHierarchy;
};


// Concrete Classes : Inheriting from CHsmAction

/*++

Class Name:
    
    CHsmActionDelete

Class Description:

    A class that represents the action of deleting a scan item.

--*/

class CHsmActionDelete :    
    public CHsmAction,
    public CComCoClass<CHsmActionDelete,&CLSID_CHsmActionDelete>
{
public:
    CHsmActionDelete() {}
BEGIN_COM_MAP(CHsmActionDelete)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IHsmAction)
    COM_INTERFACE_ENTRY(IWsbCollectable)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_CHsmActionDelete)

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);

// IHsmAction
public:
    STDMETHOD(Do)(IFsaScanItem* pScanItem);
};


/*++

Class Name:
    
    CHsmActionRecall

Class Description:

    A class that represents the action of recalling an item from
    secondary storage.

--*/

class CHsmActionRecall :    
    public CHsmAction,
    public CComCoClass<CHsmActionRecall,&CLSID_CHsmActionRecall>
{
public:
    CHsmActionRecall() {}
BEGIN_COM_MAP(CHsmActionRecall)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IHsmAction)
    COM_INTERFACE_ENTRY(IWsbCollectable)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_CHsmActionRecall)

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);

// IHsmAction
public:
    STDMETHOD(Do)(IFsaScanItem* pScanItem);
};

    
/*++

Class Name:
    
    CHsmActionRecycle

Class Description:

    A class that represents the action of recycling an item to the recycle
    bin.

--*/

class CHsmActionRecycle :   
    public CHsmAction,
    public CComCoClass<CHsmActionRecycle,&CLSID_CHsmActionRecycle>
{
public:
    CHsmActionRecycle() {}
BEGIN_COM_MAP(CHsmActionRecycle)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IHsmAction)
    COM_INTERFACE_ENTRY(IWsbCollectable)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_CHsmActionRecycle)

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);

// IHsmAction
public:
    STDMETHOD(Do)(IFsaScanItem* pScanItem);
};


/*++

Class Name:
    
    CHsmActionTruncate

Class Description:

    A class that represents the action of truncating an item into a
    placeholder.

--*/

class CHsmActionTruncate :  
    public CHsmAction,
    public CComCoClass<CHsmActionTruncate,&CLSID_CHsmActionTruncate>
{
public:
    CHsmActionTruncate() {}
BEGIN_COM_MAP(CHsmActionTruncate)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IHsmAction)
    COM_INTERFACE_ENTRY(IWsbCollectable)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_CHsmActionTruncate)

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);

// IHsmAction
public:
    STDMETHOD(Do)(IFsaScanItem* pScanItem);
};


/*++

Class Name:
    
    CHsmActionUnmanage

Class Description:

    A class that represents the action of "unmanaging" an item. This
    means recalling truncated files. removing any placeholder information and
    removing the item form any premigration list.

--*/

class CHsmActionUnmanage :  
    public CHsmAction,
    public CComCoClass<CHsmActionUnmanage,&CLSID_CHsmActionUnmanage>
{
public:
    CHsmActionUnmanage() {}
BEGIN_COM_MAP(CHsmActionUnmanage)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IHsmAction)
    COM_INTERFACE_ENTRY(IWsbCollectable)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_CHsmActionUnmanage)

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);

// IHsmAction
public:
    STDMETHOD(Do)(IFsaScanItem* pScanItem);
};


/*++

Class Name:
    
    CHsmActionValidate

Class Description:

    A class that represents the action of checking an item's placeholder
    information to make sure that it is still correct, and correcting or
    deleting any inaccurate information.

--*/

class CHsmActionValidate :  
    public CHsmAction,
    public CComCoClass<CHsmActionValidate,&CLSID_CHsmActionValidate>
{
public:
    CHsmActionValidate() {}
BEGIN_COM_MAP(CHsmActionValidate)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IHsmAction)
    COM_INTERFACE_ENTRY(IWsbCollectable)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_CHsmActionValidate)

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);

// IHsmAction
public:
    STDMETHOD(Do)(IFsaScanItem* pScanItem);
};

    
// Concrete Classes : Inheriting from CHsmDirectedAction

/*++

Class Name:
    
    CHsmActionMigrate

Class Description:

    A class that represents the action of copying the migratable portion
    of an item to secondary storage and then truncating it.

--*/

class CHsmActionMigrate :   
    public CHsmDirectedAction,
    public CComCoClass<CHsmActionMigrate,&CLSID_CHsmActionMigrate>
{
public:
    CHsmActionMigrate() {}
BEGIN_COM_MAP(CHsmActionMigrate)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IHsmAction)
    COM_INTERFACE_ENTRY(IHsmDirectedAction)
    COM_INTERFACE_ENTRY(IWsbCollectable)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_CHsmActionMigrate)

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);

// IHsmAction
public:
    STDMETHOD(Do)(IFsaScanItem* pScanItem);
};


/*++

Class Name:
    
    CHsmActionManage

Class Description:

  A class that represents the action of copying the migratable portion of
  an item to secondary storage and then adding the item to the
  premigration list. This action is also known as the premigration action.

--*/

class CHsmActionManage :    
    public CHsmDirectedAction,
    public CComCoClass<CHsmActionManage,&CLSID_CHsmActionManage>
{
public:
    CHsmActionManage() {}
BEGIN_COM_MAP(CHsmActionManage)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IHsmAction)
    COM_INTERFACE_ENTRY(IHsmDirectedAction)
    COM_INTERFACE_ENTRY(IWsbCollectable)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_CHsmActionManage)

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);

// IHsmAction
public:
    STDMETHOD(Do)(IFsaScanItem* pScanItem);
};


// Concrete Classes : Inheriting from CHsmRelocateAction

/*++

Class Name:
    
    CHsmActionCopy

Class Description:

    A class that represents the action of copying item to another location.

--*/

class CHsmActionCopy :  
    public CHsmRelocateAction,
    public CComCoClass<CHsmActionCopy,&CLSID_CHsmActionCopy>
{
public:
    CHsmActionCopy() {}
BEGIN_COM_MAP(CHsmActionCopy)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IHsmAction)
    COM_INTERFACE_ENTRY(IHsmRelocateAction)
    COM_INTERFACE_ENTRY(IWsbCollectable)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_CHsmActionCopy)

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);

// IHsmAction
public:
    STDMETHOD(Do)(IFsaScanItem* pScanItem);
};

    
/*++

Class Name:
    
    CHsmActionMove

Class Description:

    A class that represents the action of moving an item to another location
    (i.e. copy and delete).

--*/

class CHsmActionMove :  
    public CHsmRelocateAction,
    public CComCoClass<CHsmActionMove,&CLSID_CHsmActionMove>
{
public:
    CHsmActionMove() {}
BEGIN_COM_MAP(CHsmActionMove)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IHsmAction)
    COM_INTERFACE_ENTRY(IHsmRelocateAction)
    COM_INTERFACE_ENTRY(IWsbCollectable)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_CHsmActionMove)

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);

// IHsmAction
public:
    STDMETHOD(Do)(IFsaScanItem* pScanItem);
};

#endif // _HSMACTN
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\job\hsmjob.h ===
#ifndef _HSMJOB_
#define _HSMJOB_

/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    hsmjob.cpp

Abstract:

    This class contains properties that defines the context in which the job
    should be run.

Author:

    Chuck Bardeen   [cbardeen]   29-Oct-1996

Revision History:

--*/

#include "resource.h"       // main symbols

#include "wsb.h"
#include "fsa.h"
#include "job.h"
#include "hsmeng.h"

/*++

Class Name:
    
    CHsmJob

Class Description:


--*/

class CHsmJob : 
    public CWsbObject,
    public IHsmJob,
    public IHsmJobPriv,
    public CComCoClass<CHsmJob,&CLSID_CHsmJob>,
    public IConnectionPointContainerImpl<CHsmJob>,
    public IConnectionPointImpl<CHsmJob, &IID_IHsmJobSinkEverySession, CComDynamicUnkArray>
{
public:
    CHsmJob() {}

BEGIN_COM_MAP(CHsmJob)
    COM_INTERFACE_ENTRY(IHsmJob)
    COM_INTERFACE_ENTRY(IHsmJobPriv)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IWsbCollectable)
    COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()
                        
BEGIN_CONNECTION_POINT_MAP(CHsmJob)
    CONNECTION_POINT_ENTRY(IID_IHsmJobSinkEverySession)
END_CONNECTION_POINT_MAP()
                        
DECLARE_REGISTRY_RESOURCEID(IDR_CHsmJob)

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);
    void FinalRelease(void);

// CHsmJob
    STDMETHOD(Do)();
    STDMETHOD(UpdateWorkItems)(BOOL isRestart);

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);

// IPersistStream
public:
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER* pSize);
    STDMETHOD(Load)(IStream* pStream);
    STDMETHOD(Save)(IStream* pStream, BOOL clearDirty);

// IWsbTestable
public:
    STDMETHOD(Test)(USHORT *passed, USHORT* failed);

// IHsmJobPriv
public:
    STDMETHOD(AdviseOfSessionState)(IHsmSession* pSession, IHsmPhase* pPhase, OLECHAR* currentPath);
    STDMETHOD(DoNext)();

// IHsmJob
public:
    STDMETHOD(Cancel)(HSM_JOB_PHASE phase);
    STDMETHOD(DidFinish)(void);
    STDMETHOD(DidFinishOk)(void);
    STDMETHOD(EnumWorkItems)(IWsbEnum** ppEnum);
    STDMETHOD(FindWorkItem)(IHsmSession* pSession, IHsmJobWorkItem** ppWorkItem);
    STDMETHOD(GetContext)(IHsmJobContext** ppContext);
    STDMETHOD(GetDef)(IHsmJobDef** ppDef);
    STDMETHOD(GetHsmId)(GUID* pId);
    STDMETHOD(GetIdentifier)(GUID* pId);
    STDMETHOD(GetMaxActiveSessions)(ULONG* pMaxActiveSessions);
    STDMETHOD(GetName)(OLECHAR** pName, ULONG bufferSize);
    STDMETHOD(GetRunId)(ULONG* pRunId);
    STDMETHOD(GetState)(HSM_JOB_STATE* pState);
    STDMETHOD(InitAs)(OLECHAR* name, IHsmJobDef* pDef, HSM_JOB_DEF_TYPE type, GUID storagePool, IHsmServer* pServer, BOOL isUserDefined, IFsaResource* pResource);
    STDMETHOD(IsActive)(void);
    STDMETHOD(IsUserDefined)(void);
    STDMETHOD(Pause)(HSM_JOB_PHASE phase);
    STDMETHOD(Restart)(void);
    STDMETHOD(Resume)(HSM_JOB_PHASE phase);
    STDMETHOD(SetContext)(IHsmJobContext* pContext);
    STDMETHOD(SetDef)(IHsmJobDef* pDef);
    STDMETHOD(SetHsmId)(GUID id);
    STDMETHOD(SetIsUserDefined)(BOOL isUserDefined);
    STDMETHOD(SetName)(OLECHAR* name);
    STDMETHOD(Start)(void);
    STDMETHOD(Suspend)(HSM_JOB_PHASE phase);
    STDMETHOD(WaitUntilDone)(void);

// Private functions
    STDMETHOD(CheckResourceNotInUse)(GUID resid);
    STDMETHOD(RestartSuspendedJobs)(void);

protected:
    HSM_JOB_STATE               m_state;
    GUID                        m_hsmId;
    GUID                        m_id;
    BOOL                        m_isUserDefined;
    BOOL                        m_isActive;
    BOOL                        m_isTerminating;
    ULONG                       m_activeSessions;
    ULONG                       m_runId;
    CWsbStringPtr               m_name;
    CComPtr<IHsmJobContext>     m_pContext;
    CComPtr<IHsmJobDef>         m_pDef;
    CComPtr<IWsbCollection>     m_pWorkItems;
};

#endif // _HSMJOB_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\job\hsmcrit.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    hsmcrit.cpp

Abstract:

    This component represents the criteria that can be used to determine
    whether a given scanItem should have a policy applied to it.

Author:

    Chuck Bardeen   [cbardeen]   29-Oct-1996

Revision History:

--*/

#include "stdafx.h"
#include "mapiutil.h"

#include "wsb.h"
#include "job.h"
#include "hsmcrit.h"

#define WSB_TRACE_IS        WSB_TRACE_BIT_JOB


HRESULT
CHsmCriteria::FinalConstruct(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;
    
    try {

        WsbAffirmHr(CWsbObject::FinalConstruct());
        m_isIgnored = FALSE;
        m_isNegated = FALSE;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmCriteria::GetName(
    OUT OLECHAR** pName,
    IN ULONG bufferSize
    )

/*++

Implements:

  IHsmCriteria::GetName().

--*/
{
    HRESULT     hr = S_OK;
    CWsbStringPtr   tmpString;

    try {

        WsbAssert(0 != pName, E_POINTER);
        WsbAffirmHr(tmpString.LoadFromRsc(_Module.m_hInst, m_nameId));
        WsbAffirmHr(tmpString.CopyTo(pName, bufferSize));

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmCriteria::GetSizeMax(
    OUT ULARGE_INTEGER* pSize
    )

/*++

Implements:

  IPersistStream::GetSizeMax().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmCriteria::GetSizeMax"), OLESTR(""));

    try {
       
        WsbAssert(0 != pSize, E_POINTER);
        pSize->QuadPart = WsbPersistSizeOf(GUID) + WsbPersistSizeOf(BOOL) + WsbPersistSizeOf(BOOL);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmCriteria::GetSizeMax"), OLESTR("hr = <%ls>, Size = <%ls>"), WsbHrAsString(hr), WsbPtrToUliAsString(pSize));

    return(hr);
}


HRESULT
CHsmCriteria::IsIgnored(
    void
    )

/*++

Implements:

  IHsmCriteria::IsIgnored().

--*/
{
    return(m_isIgnored ? S_OK : S_FALSE);
}


HRESULT
CHsmCriteria::IsNegated(
    void
    )

/*++

Implements:

  IHsmCriteria::IsNegated().

--*/
{
    return(m_isNegated ? S_OK : S_FALSE);
}


HRESULT
CHsmCriteria::Load(
    IN IStream* pStream
    )

/*++

Implements:

  IPersistStream::Load().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmCriteria::Load"), OLESTR(""));

    try {

        WsbAssert(0 != pStream, E_POINTER);

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_nameId));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_isIgnored));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_isNegated));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmCriteria::Load"), OLESTR("hr = <%ls>, nameId = <%lu>"), WsbHrAsString(hr), m_nameId);

    return(hr);
}


HRESULT
CHsmCriteria::Save(
    IN IStream* pStream,
    IN BOOL clearDirty
    )

/*++

Implements:

  IPersistStream::Save().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmCriteria::Save"), OLESTR("clearDirty = <%ls>"), WsbBoolAsString(clearDirty));
    
    try {

        WsbAssert(0 != pStream, E_POINTER);

        WsbAffirmHr(WsbSaveToStream(pStream, m_nameId));
        WsbAffirmHr(WsbSaveToStream(pStream, m_isIgnored));
        WsbAffirmHr(WsbSaveToStream(pStream, m_isNegated));

        // If we got it saved and we were asked to clear the dirty bit, then
        // do so now.
        if (clearDirty) {
            m_isDirty = FALSE;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmCriteria::Save"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmCriteria::SetIsIgnored(
    IN BOOL isIgnored
    )

/*++

Implements:

  IHsmCriteria::SetIsIgnored().

--*/
{
    m_isIgnored = isIgnored;
    m_isDirty = TRUE;

    return(S_OK);
}


HRESULT
CHsmCriteria::SetIsNegated(
    IN BOOL isNegated
    )

/*++

Implements:

  IHsmCriteria::SetIsNegated().

--*/
{
    m_isNegated = isNegated;
    m_isDirty = TRUE;

    return(S_OK);
}


HRESULT
CHsmCriteria::Test(
    USHORT* passed,
    USHORT* failed
    )

/*++

Implements:

  IWsbTestable::Test().

--*/
{
    HRESULT     hr = S_OK;

    try {

        WsbAssert(0 != passed, E_POINTER);
        WsbAssert(0 != failed, E_POINTER);

        *passed = 0;
        *failed = 0;

    } WsbCatch(hr);

    return(hr);
}




HRESULT
CHsmRelativeCriteria::ComparatorAsString(
    OUT OLECHAR** pComparator,
    IN ULONG bufferSize
    )

/*++

Implements:

  IHsmRelativeCriteria::ComparatorAsString().

--*/
{
    HRESULT         hr = S_OK;

    try {
        
        WsbAssert(0 != pComparator, E_POINTER);
        WsbAffirmHr(WsbLoadComString(_Module.m_hInst, IDS_HSM_CRITERIACOMPARATOR_NOTSET + m_comparator, pComparator, bufferSize));

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmRelativeCriteria::ComparatorIsBinary(
    void
    )

/*++

Implements:

  IHsmRelativeCriteria::ComparatorIsBinary().

--*/
{
    HRESULT         hr = S_FALSE;

    if ((m_comparator == HSM_CRITERIACOMPARATOR_BETWEEN) ||
        (m_comparator == HSM_CRITERIACOMPARATOR_OUTSIDE)) {

        hr = S_OK;
    }

    return(hr);
}


HRESULT
CHsmRelativeCriteria::FinalConstruct(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;
    
    try {

        WsbAffirmHr(CHsmCriteria::FinalConstruct());

        m_comparator = HSM_CRITERIACOMPARATOR_NOTSET;
        m_arg1 = 0;
        m_arg2 = 0;

    } WsbCatch(hr);

    return(hr);
}


void
CHsmRelativeCriteria::FinalRelease(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalRelease().

--*/
{
    
    // Free the memory used by the arg1 string.
    if (0 != m_arg1) {
        WsbFree(m_arg1);
        m_arg1 = 0;
    }

    // Free the memory used by the arg2 string.
    if (0 != m_arg2) {
        WsbFree(m_arg2);
        m_arg2 = 0;
    }

    // Let the parent class do his thing.   
    CWsbObject::FinalRelease();
}


HRESULT
CHsmRelativeCriteria::GetArg1(
    OUT OLECHAR** pArg,
    IN ULONG bufferSize
    )

/*++

Implements:

  IHsmRelativeCriteria::GetArg1().

--*/
{
    HRESULT         hr = S_OK;

    try {
        
        WsbAssert(0 != pArg, E_POINTER);
        WsbAffirmHr(WsbAllocAndCopyComString(pArg, m_arg1, bufferSize));

    } WsbCatch(hr);


    return(hr);
}


HRESULT
CHsmRelativeCriteria::GetArg2(
    OUT OLECHAR** pArg,
    IN ULONG bufferSize
    )

/*++

Implements:

  IHsmRelativeCriteria::GetArg2().

--*/
{
    HRESULT         hr = S_OK;

    try {
        
        WsbAssert(0 != pArg, E_POINTER);
        WsbAffirmHr(WsbAllocAndCopyComString(pArg, m_arg2, bufferSize));

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmRelativeCriteria::GetComparator(
    OUT HSM_CRITERIACOMPARATOR* pComparator
    )

/*++

Implements:

  IHsmRelativeCriteria::GetComparator().

--*/
{
    HRESULT         hr = S_OK;

    try {
        
        WsbAssert(0 != pComparator, E_POINTER);
        *pComparator = m_comparator;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmRelativeCriteria::GetSizeMax(
    OUT ULARGE_INTEGER* pSize
    )

/*++

Implements:

  IPersistStream::GetSizeMax().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmRelativeCriteria::GetSizeMax"), OLESTR(""));

    try {
       
        WsbAssert(0 != pSize, E_POINTER);
        pSize->QuadPart = WsbPersistSizeOf(GUID) + WsbPersistSizeOf(BOOL) + WsbPersistSizeOf(BOOL) + WsbPersistSize((wcslen(m_arg1) + 1) * sizeof(OLECHAR)) + WsbPersistSize((wcslen(m_arg2) + 1) * sizeof(OLECHAR));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmRelativeCriteria::GetSizeMax"), OLESTR("hr = <%ls>, Size = <%ls>"), WsbHrAsString(hr), WsbPtrToUliAsString(pSize));

    return(hr);
}


HRESULT
CHsmRelativeCriteria::Load(
    IN IStream* pStream
    )

/*++

Implements:

  IPersistStream::Load().

--*/
{
    HRESULT         hr = S_OK;
    CWsbStringPtr   tmp;

    WsbTraceIn(OLESTR("CHsmRelativeCriteria::Load"), OLESTR(""));

    try {

        WsbAssert(0 != pStream, E_POINTER);

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_nameId));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_isIgnored));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_isNegated));
        WsbAffirmHr(WsbLoadFromStream(pStream, &tmp, 0));
        WsbAffirmHr(SetArg1(tmp));
        WsbAffirmHr(WsbLoadFromStream(pStream, &tmp, 0));
        WsbAffirmHr(SetArg2(tmp));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmRelativeCriteria::Load"), OLESTR("hr = <%ls>, nameId = <%lu>"), WsbHrAsString(hr), m_nameId);

    return(hr);
}


HRESULT
CHsmRelativeCriteria::Save(
    IN IStream* pStream,
    IN BOOL clearDirty
    )

/*++

Implements:

  IPersistStream::Save().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmRelativeCriteria::Save"), OLESTR("clearDirty = <%ls>"), WsbBoolAsString(clearDirty));
    
    try {

        WsbAssert(0 != pStream, E_POINTER);

        WsbAffirmHr(WsbSaveToStream(pStream, m_nameId));
        WsbAffirmHr(WsbSaveToStream(pStream, m_isIgnored));
        WsbAffirmHr(WsbSaveToStream(pStream, m_isNegated));
        WsbAffirmHr(WsbSaveToStream(pStream, m_arg1));
        WsbAffirmHr(WsbSaveToStream(pStream, m_arg2));

        // If we got it saved and we were asked to clear the dirty bit, then
        // do so now.
        if (clearDirty) {
            m_isDirty = FALSE;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmRelativeCriteria::Save"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmRelativeCriteria::SetArg1(
    IN OLECHAR* arg
    )

/*++

Implements:

  IHsmRelativeCriteria::SetArg1().

--*/
{
    HRESULT         hr = S_OK;

    hr = WsbAllocAndCopyComString(&m_arg1, arg, 0);

    return(hr);
}


HRESULT
CHsmRelativeCriteria::SetArg2(
    IN OLECHAR* arg
    )

/*++

Implements:

  IHsmRelativeCriteria::SetArg2().

--*/
{
    HRESULT         hr = S_OK;

    hr = WsbAllocAndCopyComString(&m_arg2, arg, 0);

    return(hr);
}


HRESULT
CHsmRelativeCriteria::SetComparator(
    IN HSM_CRITERIACOMPARATOR comparator
    )

/*++

Implements:

  IHsmRelativeCriteria::SetComparator().

--*/
{
    m_comparator = comparator;

    return(S_OK);
}





HRESULT
CHsmCritAlways::FinalConstruct(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;
    
    try {

        WsbAffirmHr(CHsmCriteria::FinalConstruct());
        m_nameId = IDS_HSMCRITALWAYS_ID;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmCritAlways::GetClassID(
    OUT CLSID* pClsid
    )

/*++

Implements:

  IPersist::GetClassID().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmCritAlways::GetClassID"), OLESTR(""));

    try {

        WsbAssert(0 != pClsid, E_POINTER);
        *pClsid = CLSID_CHsmCritAlways;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmCritAlways::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return(hr);
}


HRESULT
CHsmCritAlways::ShouldDo(
    IN IFsaScanItem* /*pScanItem*/,
    IN USHORT /*scale*/
    )

/*++

Implements:

  IHsmCriteria::ShouldDo().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmCritAlways::ShouldDo"), OLESTR(""));

    hr = m_isNegated ? S_FALSE : S_OK;

    WsbTraceOut(OLESTR("CHsmCritAlways::ShouldDo"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}


HRESULT
CHsmCritAlways::Test(
    USHORT* passed,
    USHORT* failed
    )

/*++

Implements:

  IWsbTestable::Test().

--*/
{
    HRESULT     hr = S_OK;
    OLECHAR*    name = 0;

    try {

        WsbAssert(0 != passed, E_POINTER);
        WsbAssert(0 != failed, E_POINTER);

        *passed = 0;
        *failed = 0;

        try {
            WsbAssertHr(GetName(&name, 0));
            WsbAssert(wcscmp(name, OLESTR("Always")) == 0, E_FAIL);
            (*passed)++;
        } WsbCatchAndDo(hr, (*failed)++;);

    } WsbCatch(hr);

    if (0 != name) {
        WsbFree(name);
    }

    return(hr);
}


HRESULT
CHsmCritAlways::Value(
    IN IFsaScanItem* pScanItem,
    OUT OLECHAR** pValue,
    IN ULONG bufferSize
    )

/*++

Implements:

  IHsmCriteria::Value().

--*/
{
    HRESULT     hr = S_OK;
    
    try {
        
        WsbAssert(0 != pScanItem, E_POINTER);
        WsbAssert(0 != pValue, E_POINTER);

        hr = WsbLoadComString(_Module.m_hInst, IDS_HSMCRITALWAYS_VALUE_T, pValue, bufferSize);

    } WsbCatch(hr);


    return(hr);
}




HRESULT
CHsmCritCompressed::FinalConstruct(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;
    
    try {

        WsbAffirmHr(CHsmCriteria::FinalConstruct());
        m_nameId = IDS_HSMCRITCOMPRESSED_ID;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmCritCompressed::GetClassID(
    OUT CLSID* pClsid
    )

/*++

Implements:

  IPersist::GetClassID().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmCritCompressed::GetClassID"), OLESTR(""));

    try {

        WsbAssert(0 != pClsid, E_POINTER);
        *pClsid = CLSID_CHsmCritAlways;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmCritCompressed::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return(hr);
}


HRESULT
CHsmCritCompressed::ShouldDo(
    IN IFsaScanItem* pScanItem,
    IN USHORT /*scale*/
    )

/*++

Implements:

  IHsmCriteria::ShouldDo().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmCritCompressed::ShouldDo"), OLESTR(""));

    try {

        WsbAssert(0 != pScanItem, E_POINTER);
        hr = pScanItem->IsCompressed();

        if (SUCCEEDED(hr) && m_isNegated) {
            if (S_OK == hr) {
                hr = S_FALSE;
            } else {
                hr = S_OK;
            }
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmCritCompressed::ShouldDo"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmCritCompressed::Value(
    IN IFsaScanItem* pScanItem,
    OUT OLECHAR** pValue,
    IN ULONG bufferSize
    )

/*++

Implements:

  IHsmCriteria::Value().

--*/
{
    HRESULT     hr = S_OK;
    
    try {
        
        WsbAssert(0 != pScanItem, E_POINTER);
        WsbAssert(0 != pValue, E_POINTER);

        hr = pScanItem->IsCompressed();

        if (S_OK == hr) {
            hr = WsbLoadComString(_Module.m_hInst, IDS_HSMCRITCOMPRESSED_VALUE_T, pValue, bufferSize);
        } else {
            hr = WsbLoadComString(_Module.m_hInst, IDS_HSMCRITCOMPRESSED_VALUE_F, pValue, bufferSize);
        }

    } WsbCatch(hr);

    return(hr);
}




HRESULT
CHsmCritLinked::FinalConstruct(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;
    
    try {

        WsbAffirmHr(CHsmCriteria::FinalConstruct());
        m_nameId = IDS_HSMCRITLINKED_ID;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmCritLinked::GetClassID(
    OUT CLSID* pClsid
    )

/*++

Implements:

  IPersist::GetClassID().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmCritLinked::GetClassID"), OLESTR(""));

    try {

        WsbAssert(0 != pClsid, E_POINTER);
        *pClsid = CLSID_CHsmCritLinked;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmCritLinked::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return(hr);
}


HRESULT
CHsmCritLinked::ShouldDo(
    IN IFsaScanItem* pScanItem,
    IN USHORT /*scale*/
    )

/*++

Implements:

  IHsmCriteria::ShouldDo().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmCritLinked::ShouldDo"), OLESTR(""));

    try {

        WsbAssert(0 != pScanItem, E_POINTER);
        hr = pScanItem->IsALink();

        if (SUCCEEDED(hr) && m_isNegated) {
            if (S_OK == hr) {
                hr = S_FALSE;
            } else {
                hr = S_OK;
            }
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmCritLinked::ShouldDo"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmCritLinked::Value(
    IN IFsaScanItem* pScanItem,
    OUT OLECHAR** pValue,
    IN ULONG bufferSize
    )

/*++

Implements:

  IHsmCriteria::Value().

--*/
{
    HRESULT     hr = S_OK;
    
    try {
        
        WsbAssert(0 != pScanItem, E_POINTER);
        WsbAssert(0 != pValue, E_POINTER);

        hr = pScanItem->IsALink();

        if (S_OK == hr) {
            hr = WsbLoadComString(_Module.m_hInst, IDS_HSMCRITLINKED_VALUE_T, pValue, bufferSize);
        } else {
            hr = WsbLoadComString(_Module.m_hInst, IDS_HSMCRITLINKED_VALUE_F, pValue, bufferSize);
        }

    } WsbCatch(hr);

    return(hr);
}




HRESULT
CHsmCritMbit::FinalConstruct(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;
    
    try {

        WsbAffirmHr(CHsmCriteria::FinalConstruct());
        m_nameId = IDS_HSMCRITMBIT_ID;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmCritMbit::GetClassID(
    OUT CLSID* pClsid
    )

/*++

Implements:

  IPersist::GetClassID().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmCritMbit::GetClassID"), OLESTR(""));

    try {

        WsbAssert(0 != pClsid, E_POINTER);
        *pClsid = CLSID_CHsmCritMbit;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmCritMbit::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return(hr);
}


HRESULT
CHsmCritMbit::ShouldDo(
    IN IFsaScanItem* pScanItem,
    IN USHORT /*scale*/
    )

/*++

Implements:

  IHsmCriteria::ShouldDo().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmCritMbit::ShouldDo"), OLESTR(""));

    try {

        WsbAssert(0 != pScanItem, E_POINTER);
        hr = pScanItem->IsMbit();

        if (SUCCEEDED(hr) && m_isNegated) {
            if (S_OK == hr) {
                hr = S_FALSE;
            } else {
                hr = S_OK;
            }
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmCritMbit::ShouldDo"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmCritMbit::Value(
    IN IFsaScanItem* pScanItem,
    OUT OLECHAR** pValue,
    IN ULONG bufferSize
    )

/*++

Implements:

  IHsmCriteria::Value().

--*/
{
    HRESULT     hr = S_OK;
    
    try {
        
        WsbAssert(0 != pScanItem, E_POINTER);
        WsbAssert(0 != pValue, E_POINTER);

        hr = pScanItem->IsMbit();

        if (S_OK == hr) {
            hr = WsbLoadComString(_Module.m_hInst, IDS_HSMCRITMBIT_VALUE_T, pValue, bufferSize);
        } else {
            hr = WsbLoadComString(_Module.m_hInst, IDS_HSMCRITMBIT_VALUE_F, pValue, bufferSize);
        }

    } WsbCatch(hr);

    return(hr);
}




HRESULT
CHsmCritManageable::FinalConstruct(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;
    
    try {

        WsbAffirmHr(CHsmCriteria::FinalConstruct());
        m_nameId = IDS_HSMCRITMANAGEABLE_ID;

    } WsbCatch(hr);

    return(hr);
}



HRESULT
CHsmCritManageable::GetClassID(
    OUT CLSID* pClsid
    )

/*++

Implements:

  IPersist::GetClassID().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmCritManageable::GetClassID"), OLESTR(""));

    try {

        WsbAssert(0 != pClsid, E_POINTER);
        *pClsid = CLSID_CHsmCritManageable;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmCritManageable::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return(hr);
}


HRESULT
CHsmCritManageable::ShouldDo(
    IN IFsaScanItem* pScanItem,
    IN USHORT /*scale*/
    )

/*++

Implements:

  IHsmCriteria::ShouldDo().

--*/
{
    HRESULT     hr = S_OK;
    LONGLONG    size;

    WsbTraceIn(OLESTR("CHsmCritManageable::ShouldDo"), OLESTR(""));

    try {

        WsbAssert(0 != pScanItem, E_POINTER);

        WsbAffirmHr(pScanItem->GetLogicalSize(&size));
        hr = pScanItem->IsManageable(0, size);

        if (SUCCEEDED(hr) && m_isNegated) {
            if (S_OK == hr) {
                hr = S_FALSE;
            } else {
                hr = S_OK;
            }
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmCritManageable::ShouldDo"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmCritManageable::Value(
    IN IFsaScanItem* pScanItem,
    OUT OLECHAR** pValue,
    IN ULONG bufferSize
    )

/*++

Implements:

  IHsmCriteria::Value().

--*/
{
    HRESULT     hr = S_OK;
    LONGLONG    size;
    
    try {
        
        WsbAssert(0 != pScanItem, E_POINTER);
        WsbAssert(0 != pValue, E_POINTER);

        WsbAffirmHr(pScanItem->GetLogicalSize(&size));
        hr = pScanItem->IsManageable(0, size);

        if (S_OK == hr) {
            hr = WsbLoadComString(_Module.m_hInst, IDS_HSMCRITMANAGEABLE_VALUE_T, pValue, bufferSize);
        } else {
            hr = WsbLoadComString(_Module.m_hInst, IDS_HSMCRITMANAGEABLE_VALUE_F, pValue, bufferSize);
        }

    } WsbCatch(hr);

    return(hr);
}




HRESULT
CHsmCritMigrated::FinalConstruct(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;
    
    try {

        WsbAffirmHr(CHsmCriteria::FinalConstruct());
        m_nameId = IDS_HSMCRITMIGRATED_ID;

    } WsbCatch(hr);

    return(hr);
}



HRESULT
CHsmCritMigrated::GetClassID(
    OUT CLSID* pClsid
    )

/*++

Implements:

  IPersist::GetClassID().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmCritMigrated::GetClassID"), OLESTR(""));

    try {

        WsbAssert(0 != pClsid, E_POINTER);
        *pClsid = CLSID_CHsmCritMigrated;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmCritMigrated::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return(hr);
}


HRESULT
CHsmCritMigrated::ShouldDo(
    IN IFsaScanItem* pScanItem,
    IN USHORT /*scale*/
    )

/*++

Implements:

  IHsmCriteria::ShouldDo().

--*/
{
    HRESULT     hr = S_OK;
    LONGLONG    size;

    WsbTraceIn(OLESTR("CHsmCritMigrated::ShouldDo"), OLESTR(""));

    try {

        WsbAssert(0 != pScanItem, E_POINTER);

        WsbAffirmHr(pScanItem->GetLogicalSize(&size));
        hr = pScanItem->IsTruncated(0, size);

        if (SUCCEEDED(hr) && m_isNegated) {
            if (S_OK == hr) {
                hr = S_FALSE;
            } else {
                hr = S_OK;
            }
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmCritMigrated::ShouldDo"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmCritMigrated::Value(
    IN IFsaScanItem* pScanItem,
    OUT OLECHAR** pValue,
    IN ULONG bufferSize
    )

/*++

Implements:

  IHsmCriteria::Value().

--*/
{
    HRESULT     hr = S_OK;
    LONGLONG    size;
    
    try {
        
        WsbAssert(0 != pScanItem, E_POINTER);
        WsbAssert(0 != pValue, E_POINTER);

        WsbAffirmHr(pScanItem->GetLogicalSize(&size));
        hr = pScanItem->IsTruncated(0, size);

        if (S_OK == hr) {
            hr = WsbLoadComString(_Module.m_hInst, IDS_HSMCRITMIGRATED_VALUE_T, pValue, bufferSize);
        } else {
            hr = WsbLoadComString(_Module.m_hInst, IDS_HSMCRITMIGRATED_VALUE_F, pValue, bufferSize);
        }

    } WsbCatch(hr);

    return(hr);
}




HRESULT
CHsmCritPremigrated::FinalConstruct(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;
    
    try {

        WsbAffirmHr(CHsmCriteria::FinalConstruct());
        m_nameId = IDS_HSMCRITPREMIGRATED_ID;

    } WsbCatch(hr);

    return(hr);
}



HRESULT
CHsmCritPremigrated::GetClassID(
    OUT CLSID* pClsid
    )

/*++

Implements:

  IPersist::GetClassID().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmCritPremigrated::GetClassID"), OLESTR(""));

    try {

        WsbAssert(0 != pClsid, E_POINTER);
        *pClsid = CLSID_CHsmCritPremigrated;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmCritPremigrated::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return(hr);
}


HRESULT
CHsmCritPremigrated::ShouldDo(
    IN IFsaScanItem* pScanItem,
    IN USHORT /*scale*/
    )

/*++

Implements:

  IHsmCriteria::ShouldDo().

--*/
{
    HRESULT     hr = S_OK;
    LONGLONG    size;

    WsbTraceIn(OLESTR("CHsmCritPremigrated::ShouldDo"), OLESTR(""));

    try {

        WsbAssert(0 != pScanItem, E_POINTER);

        WsbAffirmHr(pScanItem->GetLogicalSize(&size));
        hr = pScanItem->IsPremigrated(0, size);

        if (SUCCEEDED(hr) && m_isNegated) {
            if (S_OK == hr) {
                hr = S_FALSE;
            } else {
                hr = S_OK;
            }
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmCritPremigrated::ShouldDo"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmCritPremigrated::Value(
    IN IFsaScanItem* pScanItem,
    OUT OLECHAR** pValue,
    IN ULONG bufferSize
    )

/*++

Implements:

  IHsmCriteria::Value().

--*/
{
    HRESULT     hr = S_OK;
    LONGLONG    size;
    
    try {
        
        WsbAssert(0 != pScanItem, E_POINTER);
        WsbAssert(0 != pValue, E_POINTER);

        WsbAffirmHr(pScanItem->GetLogicalSize(&size));
        hr = pScanItem->IsPremigrated(0, size);

        if (S_OK == hr) {
            hr = WsbLoadComString(_Module.m_hInst, IDS_HSMCRITPREMIGRATED_VALUE_T, pValue, bufferSize);
        } else {
            hr = WsbLoadComString(_Module.m_hInst, IDS_HSMCRITPREMIGRATED_VALUE_F, pValue, bufferSize);
        }

    } WsbCatch(hr);

    return(hr);
}




HRESULT
CHsmCritAccessTime::FinalConstruct(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;
    
    try {

        WsbAffirmHr(CHsmRelativeCriteria::FinalConstruct());
        m_nameId = IDS_HSMCRITACCESSTIME_ID;

    } WsbCatch(hr);

    return(hr);
}



HRESULT
CHsmCritAccessTime::GetClassID(
    OUT CLSID* pClsid
    )

/*++

Implements:

  IPersist::GetClassID().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmCritAccessTime::GetClassID"), OLESTR(""));

    try {

        WsbAssert(0 != pClsid, E_POINTER);
        *pClsid = CLSID_CHsmCritAccessTime;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmCritAccessTime::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return(hr);
}


HRESULT
CHsmCritAccessTime::SetArg1(
    IN OLECHAR* arg
    )

/*++

Implements:

  IHsmCriteria::SetArg1().

--*/
{
    HRESULT     hr = S_OK;
    
    try {

        WsbAffirmHr(WsbWCStoFT(arg, &m_isRelative, &m_value1));
        WsbAffirmHr(CHsmRelativeCriteria::SetArg1(arg));

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmCritAccessTime::SetArg2(
    IN OLECHAR* arg
    )

/*++

Implements:

  IHsmCriteria::SetArg2().

--*/
{
    HRESULT     hr = S_OK;
    
    try {

        WsbAffirmHr(WsbWCStoFT(arg, &m_isRelative, &m_value2));
        WsbAffirmHr(CHsmRelativeCriteria::SetArg2(arg));

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmCritAccessTime::ShouldDo(
    IN IFsaScanItem* pScanItem,
    IN USHORT /*scale*/
    )

/*++

Implements:

  IHsmCriteria::ShouldDo().

--*/
{
    HRESULT     hr = S_OK;
    FILETIME    time;
    FILETIME    value1 = m_value1;
    FILETIME    value2 = m_value2;
    LONG        timeCompare1;
    LONG        timeCompare2;

    WsbTraceIn(OLESTR("CHsmCritAccessTime::ShouldDo"), OLESTR(""));

    try {

        WsbAssert(0 != pScanItem, E_POINTER);
        WsbAssert(0 != m_arg1, E_INVALIDARG);

        // Get the time.
        WsbAffirmHr(pScanItem->GetAccessTime(&time));

        // If this is a relative time (i.e. and age), then we need
        // to know the present time before we can do the comparrison.
        if (m_isRelative) {
            FILETIME    present;

            WsbAffirmHr(CoFileTimeNow(&present));

            value1 = WsbFtSubFt(present, m_value1);
            value2 = WsbFtSubFt(present, m_value2);
        }

        // Compare the first arg.
        timeCompare1 = CompareFileTime(&value1, &time);

        // Now interpret the result based on the type of comparisson.
        hr = S_FALSE;
        switch (m_comparator) {

        default:
        case HSM_CRITERIACOMPARATOR_NOTSET:
            hr = E_INVALIDARG;
            break;

         case HSM_CRITERIACOMPARATOR_LT:
            if (timeCompare1 < 0) {
                hr = S_OK;
            }
            break;

        case HSM_CRITERIACOMPARATOR_LTE:
            if (timeCompare1 <= 0) {
                hr = S_OK;
            }
            break;

        case HSM_CRITERIACOMPARATOR_EQL:
            if (timeCompare1 == 0) {
                hr = S_OK;
            }
            break;

        case HSM_CRITERIACOMPARATOR_NEQL:
            if (timeCompare1 != 0) {
                hr = S_OK;
            }
            break;

        case HSM_CRITERIACOMPARATOR_GTE:
            if (timeCompare1 >= 0) {
                hr = S_OK;
            }
            break;

        case HSM_CRITERIACOMPARATOR_GT:
            if (timeCompare1 > 0) {
                hr = S_OK;
            }
            break;

        case HSM_CRITERIACOMPARATOR_BETWEEN:
            WsbAssert(0 != m_arg2, E_INVALIDARG);

            timeCompare2 = CompareFileTime(&value2, &time);
                
            if ((timeCompare1 >= 0) && (timeCompare2 <= 0)) {
                hr = S_OK;
            }
            break;

        case HSM_CRITERIACOMPARATOR_OUTSIDE:
            WsbAssert(0 != m_arg2, E_INVALIDARG);

            timeCompare2 = CompareFileTime(&value2, &time);
                
            if ((timeCompare1 < 0) || (timeCompare2 > 0)) {
                hr = S_OK;
            }
            break;
        }

        if (SUCCEEDED(hr) && m_isNegated) {
            if (S_OK == hr) {
                hr = S_FALSE;
            } else {
                hr = S_OK;
            }
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmCritAccessTime::ShouldDo"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmCritAccessTime::Value(
    IN IFsaScanItem* pScanItem,
    OUT OLECHAR** pValue,
    IN ULONG bufferSize
    )

/*++

Implements:

  IHsmCriteria::Value().

--*/
{
    HRESULT     hr = S_OK;
    FILETIME    time;
    
    try {
        
        WsbAssert(0 != pScanItem, E_POINTER);
        WsbAssert(0 != pValue, E_POINTER);

        WsbAffirmHr(pScanItem->GetAccessTime(&time));

        // If this is a relative time (i.e. and age), then we need
        // to know the present time before we can do the comparrison.
        if (m_isRelative) {
            FILETIME    present;

            WsbAffirmHr(CoFileTimeNow(&present));
            time = WsbFtSubFt(present, time);
        }

        hr = WsbFTtoWCS(m_isRelative, time, pValue, bufferSize);

    } WsbCatch(hr);

    return(hr);
}





HRESULT
CHsmCritGroup::FinalConstruct(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;
    
    try {

        WsbAffirmHr(CHsmRelativeCriteria::FinalConstruct());
        m_nameId = IDS_HSMCRITGROUP_ID;

    } WsbCatch(hr);

    return(hr);
}



HRESULT
CHsmCritGroup::GetClassID(
    OUT CLSID* pClsid
    )

/*++

Implements:

  IPersist::GetClassID().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmCritGroup::GetClassID"), OLESTR(""));

    try {

        WsbAssert(0 != pClsid, E_POINTER);
        *pClsid = CLSID_CHsmCritGroup;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmCritGroup::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return(hr);
}


HRESULT
CHsmCritGroup::ShouldDo(
    IN IFsaScanItem* pScanItem,
    IN USHORT /*scale*/
    )

/*++

Implements:

  IHsmCriteria::ShouldDo().

--*/
{
    HRESULT     hr = S_OK;
    OLECHAR*    group = 0;
    int         stringCompare1;
    int         stringCompare2;

    WsbTraceIn(OLESTR("CHsmCritGroup::ShouldDo"), OLESTR(""));
    
    try {

        // We at least need one argument to be able to do a comparisson.
        WsbAssert(0 != m_arg1, E_INVALIDARG);

        // Get the Group's name.
        WsbAffirmHr(pScanItem->GetGroup(&group, 0));

        hr = S_FALSE;
        stringCompare1 = wcscmp(m_arg1, group);

        switch (m_comparator) {
        
        default:
        case HSM_CRITERIACOMPARATOR_NOTSET:
            hr = E_INVALIDARG;
            break;

        case HSM_CRITERIACOMPARATOR_LT:
            if (stringCompare1 < 0) {
                hr = S_OK;
            }
            break;

        case HSM_CRITERIACOMPARATOR_LTE:
            if (stringCompare1 <= 0) {
                hr = S_OK;
            }
            break;

        case HSM_CRITERIACOMPARATOR_EQL:
            if (stringCompare1 == 0) {
                hr = S_OK;
            }
            break;

        case HSM_CRITERIACOMPARATOR_NEQL:
            if (stringCompare1 != 0) {
                hr = S_OK;
            }
            break;

        case HSM_CRITERIACOMPARATOR_GTE:
            if (stringCompare1 >= 0) {
                hr = S_OK;
            }
            break;

        case HSM_CRITERIACOMPARATOR_GT:
            if (stringCompare1 > 0) {
                hr = S_OK;
            }
            break;

        case HSM_CRITERIACOMPARATOR_BETWEEN:
            WsbAssert( 0 != m_arg2, E_INVALIDARG);

            stringCompare2 = wcscmp(m_arg2, group);
                
            if ((stringCompare1 >= 0) && (stringCompare2 <= 0)) {
                hr = S_OK;
            }
            break;

        case HSM_CRITERIACOMPARATOR_OUTSIDE:
            WsbAssert( 0 != m_arg2, E_INVALIDARG);

            stringCompare2 = wcscmp(m_arg2, group);
                
            if ((stringCompare1 < 0) || (stringCompare2 > 0)) {
                hr = S_OK;
            }
            break;

        case HSM_CRITERIACOMPARATOR_MEMBEROF:
            hr = pScanItem->IsGroupMemberOf(m_arg1);
            break;
        }

        WsbFree(group);

        if (SUCCEEDED(hr) && m_isNegated) {
            if (S_OK == hr) {
                hr = S_FALSE;
            } else {
                hr = S_OK;
            }
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmCritGroup::ShouldDo"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmCritGroup::Value(
    IN IFsaScanItem* pScanItem,
    OUT OLECHAR** pValue,
    IN ULONG bufferSize
    )

/*++

Implements:

  IHsmCriteria::Value().

--*/
{
    HRESULT     hr = S_OK;
    
    try {
        
        WsbAssert(0 != pScanItem, E_POINTER);
        WsbAssert(0 != pValue, E_POINTER);

        WsbAffirmHr(pScanItem->GetGroup(pValue, bufferSize));

    } WsbCatch(hr);

    return(hr);
}




HRESULT
CHsmCritLogicalSize::FinalConstruct(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;
    
    try {

        WsbAffirmHr(CHsmRelativeCriteria::FinalConstruct());
        m_nameId = IDS_HSMCRITLOGICALSIZE_ID;

    } WsbCatch(hr);

    return(hr);
}



HRESULT
CHsmCritLogicalSize::GetClassID(
    OUT CLSID* pClsid
    )

/*++

Implements:

  IPersist::GetClassID().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmCritLogicalSize::GetClassID"), OLESTR(""));

    try {

        WsbAssert(0 != pClsid, E_POINTER);
        *pClsid = CLSID_CHsmCritLogicalSize;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmCritLogicalSize::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return(hr);
}


HRESULT
CHsmCritLogicalSize::SetArg1(
    IN OLECHAR* arg
    )

/*++

Implements:

  IHsmCriteria::SetArg2().

--*/
{
    HRESULT     hr = S_OK;
    
    try {

        WsbAffirmHr(WsbWCStoLL(arg, &m_value1));
        WsbAffirmHr(CHsmRelativeCriteria::SetArg1(arg));

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmCritLogicalSize::SetArg2(
    IN OLECHAR* arg
    )

/*++

Implements:

  IHsmCriteria::SetArg2().

--*/
{
    HRESULT     hr = S_OK;
    
    try {

        WsbAffirmHr(WsbWCStoLL(arg, &m_value2));
        WsbAffirmHr(CHsmRelativeCriteria::SetArg2(arg));

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmCritLogicalSize::ShouldDo(
    IN IFsaScanItem* pScanItem,
    IN USHORT /*scale*/
    )

/*++

Implements:

  IHsmCriteria::ShouldDo().

--*/
{
    HRESULT     hr = S_OK;
    LONGLONG    size;

    WsbTraceIn(OLESTR("CHsmCritLogicalSize::ShouldDo"), OLESTR(""));
    
    try {

        // We at least need one argument to be able to do a comparisson.
        WsbAssert(0 != m_arg1, E_INVALIDARG);

        // Get the size.
        WsbAffirmHr(pScanItem->GetLogicalSize(&size));

        // See how it compares.
        hr = S_FALSE;

        switch (m_comparator) {

        default:
        case HSM_CRITERIACOMPARATOR_NOTSET:
            hr = E_INVALIDARG;
            break;

        case HSM_CRITERIACOMPARATOR_LT:
            if (size < m_value1) {
                hr = S_OK;
            }
            break;

        case HSM_CRITERIACOMPARATOR_LTE:
            if (size <= m_value1) {
                hr = S_OK;
            }
            break;

        case HSM_CRITERIACOMPARATOR_EQL:
            if (size == m_value1) {
                hr = S_OK;
            }
            break;

        case HSM_CRITERIACOMPARATOR_NEQL:
            if (size != m_value1) {
                hr = S_OK;
            }
            break;

        case HSM_CRITERIACOMPARATOR_GTE:
            if (size >= m_value1) {
                hr = S_OK;
            }
            break;

        case HSM_CRITERIACOMPARATOR_GT:
            if (size > m_value1) {
                hr = S_OK;
            }
            break;

        case HSM_CRITERIACOMPARATOR_BETWEEN:
            WsbAssert(0 != m_arg2, E_INVALIDARG);

            if ((m_value1 <= size) && (size <= m_value2)) {
                hr = S_OK;
            }
            break;

        case HSM_CRITERIACOMPARATOR_OUTSIDE:
            WsbAssert(0 != m_arg2, E_INVALIDARG);

            if ((size < m_value1) || (m_value2 > size)) {
                hr = S_OK;
            }

            break;
        }

        if (SUCCEEDED(hr) && m_isNegated) {
            if (S_OK == hr) {
                hr = S_FALSE;
            } else {
                hr = S_OK;
            }
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmCritLogicalSize::ShouldDo"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

HRESULT
CHsmCritLogicalSize::Value(
    IN IFsaScanItem* pScanItem,
    OUT OLECHAR** pValue,
    IN ULONG bufferSize
    )

/*++

Implements:

  IHsmCriteria::Value().

--*/
{
    HRESULT     hr = S_OK;
    LONGLONG    size;
    
    try {
        
        WsbAssert(0 != pScanItem, E_POINTER);
        WsbAssert(0 != pValue, E_POINTER);

        WsbAffirmHr(pScanItem->GetLogicalSize(&size));
        WsbAffirmHr(WsbLLtoWCS(size, pValue, bufferSize));

    } WsbCatch(hr);

    return(hr);
}




HRESULT
CHsmCritModifyTime::FinalConstruct(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;
    
    try {

        WsbAffirmHr(CHsmRelativeCriteria::FinalConstruct());
        m_nameId = IDS_HSMCRITMODIFYTIME_ID;

    } WsbCatch(hr);

    return(hr);
}



HRESULT
CHsmCritModifyTime::GetClassID(
    OUT CLSID* pClsid
    )

/*++

Implements:

  IPersist::GetClassID().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmCritModifyTime::GetClassID"), OLESTR(""));

    try {

        WsbAssert(0 != pClsid, E_POINTER);
        *pClsid = CLSID_CHsmCritModifyTime;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmCritModifyTime::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return(hr);
}


HRESULT
CHsmCritModifyTime::SetArg1(
    IN OLECHAR* arg
    )

/*++

Implements:

  IHsmCriteria::SetArg1().

--*/
{
    HRESULT     hr = S_OK;
    
    try {

        WsbAffirmHr(WsbWCStoFT(arg, &m_isRelative, &m_value1));
        WsbAffirmHr(CHsmRelativeCriteria::SetArg1(arg));

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmCritModifyTime::SetArg2(
    IN OLECHAR* arg
    )

/*++

Implements:

  IHsmCriteria::SetArg2().

--*/
{
    HRESULT     hr = S_OK;
    
    try {

        WsbAffirmHr(WsbWCStoFT(arg, &m_isRelative, &m_value2));
        WsbAffirmHr(CHsmRelativeCriteria::SetArg2(arg));

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmCritModifyTime::ShouldDo(
    IN IFsaScanItem* pScanItem,
    IN USHORT /*scale*/
    )

/*++

Implements:

  IHsmCriteria::ShouldDo().

--*/
{
    HRESULT     hr = S_OK;
    FILETIME    time;
    FILETIME    value1 = m_value1;
    FILETIME    value2 = m_value2;
    LONG        timeCompare1;
    LONG        timeCompare2;

    WsbTraceIn(OLESTR("CHsmCritModifyTime::ShouldDo"), OLESTR(""));

    try {

        WsbAssert(0 != pScanItem, E_POINTER);
        WsbAssert(0 != m_arg1, E_INVALIDARG);

        // Get the time.
        WsbAffirmHr(pScanItem->GetModifyTime(&time));

        // If this is a relative time (i.e. and age), then we need
        // to know the present time before we can do the comparrison.
        if (m_isRelative) {
            FILETIME    present;

            WsbAffirmHr(CoFileTimeNow(&present));

            value1 = WsbFtSubFt(present, m_value1);
            value2 = WsbFtSubFt(present, m_value2);
        }

        // Compare the first arg.
        timeCompare1 = CompareFileTime(&value1, &time);

        // Now interpret the result based on the type of comparisson.
        hr = S_FALSE;
        switch (m_comparator) {

        default:
        case HSM_CRITERIACOMPARATOR_NOTSET:
            hr = E_INVALIDARG;
            break;

         case HSM_CRITERIACOMPARATOR_LT:
            if (timeCompare1 < 0) {
                hr = S_OK;
            }
            break;

        case HSM_CRITERIACOMPARATOR_LTE:
            if (timeCompare1 <= 0) {
                hr = S_OK;
            }
            break;

        case HSM_CRITERIACOMPARATOR_EQL:
            if (timeCompare1 == 0) {
                hr = S_OK;
            }
            break;

        case HSM_CRITERIACOMPARATOR_NEQL:
            if (timeCompare1 != 0) {
                hr = S_OK;
            }
            break;

        case HSM_CRITERIACOMPARATOR_GTE:
            if (timeCompare1 >= 0) {
                hr = S_OK;
            }
            break;

        case HSM_CRITERIACOMPARATOR_GT:
            if (timeCompare1 > 0) {
                hr = S_OK;
            }
            break;

        case HSM_CRITERIACOMPARATOR_BETWEEN:
            WsbAssert(0 != m_arg2, E_INVALIDARG);

            timeCompare2 = CompareFileTime(&value2, &time);
                
            if ((timeCompare1 >= 0) && (timeCompare2 <= 0)) {
                hr = S_OK;
            }
            break;

        case HSM_CRITERIACOMPARATOR_OUTSIDE:
            WsbAssert(0 != m_arg2, E_INVALIDARG);

            timeCompare2 = CompareFileTime(&value2, &time);
                
            if ((timeCompare1 < 0) || (timeCompare2 > 0)) {
                hr = S_OK;
            }
            break;
        }

        if (SUCCEEDED(hr) && m_isNegated) {
            if (S_OK == hr) {
                hr = S_FALSE;
            } else {
                hr = S_OK;
            }
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmCritModifyTime::ShouldDo"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmCritModifyTime::Value(
    IN IFsaScanItem* pScanItem,
    OUT OLECHAR** pValue,
    IN ULONG bufferSize
    )

/*++

Implements:

  IHsmCriteria::Value().

--*/
{
    HRESULT     hr = S_OK;
    FILETIME    time;
    
    try {
        
        WsbAssert(0 != pScanItem, E_POINTER);
        WsbAssert(0 != pValue, E_POINTER);

        WsbAffirmHr(pScanItem->GetModifyTime(&time));

        // If this is a relative time (i.e. and age), then we need
        // to know the present time before we can do the comparrison.
        if (m_isRelative) {
            FILETIME    present;

            WsbAffirmHr(CoFileTimeNow(&present));
            time = WsbFtSubFt(present, time);
        }

        hr = WsbFTtoWCS(m_isRelative, time, pValue, bufferSize);

    } WsbCatch(hr);

    return(hr);
}




HRESULT
CHsmCritOwner::FinalConstruct(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;
    
    try {

        WsbAffirmHr(CHsmRelativeCriteria::FinalConstruct());
        m_nameId = IDS_HSMCRITOWNER_ID;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmCritOwner::GetClassID(
    OUT CLSID* pClsid
    )

/*++

Implements:

  IPersist::GetClassID().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmCritOwner::GetClassID"), OLESTR(""));

    try {

        WsbAssert(0 != pClsid, E_POINTER);
        *pClsid = CLSID_CHsmCritOwner;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmCritOwner::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return(hr);
}


HRESULT
CHsmCritOwner::ShouldDo(
    IN IFsaScanItem* pScanItem,
    IN USHORT /*scale*/
    )

/*++

Implements:

  IHsmCriteria::ShouldDo().

--*/
{
    HRESULT     hr = S_OK;
    OLECHAR*    owner = 0;
    int         stringCompare1;
    int         stringCompare2;

    WsbTraceIn(OLESTR("CHsmCritOwner::ShouldDo"), OLESTR(""));
    
    try {

        // We at least need one argument to be able to do a comparisson.
        WsbAssert(0 != m_arg1, E_INVALIDARG);

        // Get the Group's name.
        WsbAffirmHr(pScanItem->GetOwner(&owner, 0));

        hr = S_FALSE;
        stringCompare1 = wcscmp(m_arg1, owner);

        switch (m_comparator) {
        
        default:
        case HSM_CRITERIACOMPARATOR_NOTSET:
            hr = E_INVALIDARG;
            break;

        case HSM_CRITERIACOMPARATOR_LT:
            if (stringCompare1 < 0) {
                hr = S_OK;
            }
            break;

        case HSM_CRITERIACOMPARATOR_LTE:
            if (stringCompare1 <= 0) {
                hr = S_OK;
            }
            break;

        case HSM_CRITERIACOMPARATOR_EQL:
            if (stringCompare1 == 0) {
                hr = S_OK;
            }
            break;

        case HSM_CRITERIACOMPARATOR_NEQL:
            if (stringCompare1 != 0) {
                hr = S_OK;
            }
            break;

        case HSM_CRITERIACOMPARATOR_GTE:
            if (stringCompare1 >= 0) {
                hr = S_OK;
            }
            break;

        case HSM_CRITERIACOMPARATOR_GT:
            if (stringCompare1 > 0) {
                hr = S_OK;
            }
            break;

        case HSM_CRITERIACOMPARATOR_BETWEEN:
            WsbAssert( 0 != m_arg2, E_INVALIDARG);

            stringCompare2 = wcscmp(m_arg2, owner);
                
            if ((stringCompare1 >= 0) && (stringCompare2 <= 0)) {
                hr = S_OK;
            }
            break;

        case HSM_CRITERIACOMPARATOR_OUTSIDE:
            WsbAssert( 0 != m_arg2, E_INVALIDARG);

            stringCompare2 = wcscmp(m_arg2, owner);
                
            if ((stringCompare1 < 0) || (stringCompare2 > 0)) {
                hr = S_OK;
            }
            break;

        case HSM_CRITERIACOMPARATOR_MEMBEROF:
            hr = pScanItem->IsOwnerMemberOf(m_arg1);
            break;
        }

        WsbFree(owner);

        if (SUCCEEDED(hr) && m_isNegated) {
            if (S_OK == hr) {
                hr = S_FALSE;
            } else {
                hr = S_OK;
            }
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmCritOwner::ShouldDo"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmCritOwner::Value(
    IN IFsaScanItem* pScanItem,
    OUT OLECHAR** pValue,
    IN ULONG bufferSize
    )

/*++

Implements:

  IHsmCriteria::Value().

--*/
{
    HRESULT     hr = S_OK;
    
    try {
        
        WsbAssert(0 != pScanItem, E_POINTER);
        WsbAssert(0 != pValue, E_POINTER);

        WsbAffirmHr(pScanItem->GetOwner(pValue, bufferSize));

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmCritPhysicalSize::FinalConstruct(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;
    
    try {

        WsbAffirmHr(CHsmRelativeCriteria::FinalConstruct());
        m_nameId = IDS_HSMCRITPHYSICALSIZE_ID;

    } WsbCatch(hr);

    return(hr);
}



HRESULT
CHsmCritPhysicalSize::GetClassID(
    OUT CLSID* pClsid
    )

/*++

Implements:

  IPersist::GetClassID().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmCritPhysicalSize::GetClassID"), OLESTR(""));

    try {

        WsbAssert(0 != pClsid, E_POINTER);
        *pClsid = CLSID_CHsmCritPhysicalSize;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmCritPhysicalSize::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return(hr);
}


HRESULT
CHsmCritPhysicalSize::SetArg1(
    IN OLECHAR* arg
    )

/*++

Implements:

  IHsmCriteria::SetArg2().

--*/
{
    HRESULT     hr = S_OK;
    
    try {

        WsbAffirmHr(WsbWCStoLL(arg, &m_value1));
        WsbAffirmHr(CHsmRelativeCriteria::SetArg1(arg));

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmCritPhysicalSize::SetArg2(
    IN OLECHAR* arg
    )

/*++

Implements:

  IHsmCriteria::SetArg2().

--*/
{
    HRESULT     hr = S_OK;
    
    try {

        WsbAffirmHr(WsbWCStoLL(arg, &m_value2));
        WsbAffirmHr(CHsmRelativeCriteria::SetArg2(arg));

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmCritPhysicalSize::ShouldDo(
    IN IFsaScanItem* pScanItem,
    IN USHORT /*scale*/
    )

/*++

Implements:

  IHsmCriteria::ShouldDo().

--*/
{
    HRESULT     hr = S_OK;
    LONGLONG    size;

    WsbTraceIn(OLESTR("CHsmCritPhysicalSize::ShouldDo"), OLESTR(""));
    
    try {

        // We at least need one argument to be able to do a comparisson.
        WsbAssert(0 != m_arg1, E_INVALIDARG);

        // Get the size.
        WsbAffirmHr(pScanItem->GetPhysicalSize(&size));

        // See how it compares.
        hr = S_FALSE;

        switch (m_comparator) {

        default:
        case HSM_CRITERIACOMPARATOR_NOTSET:
            hr = E_INVALIDARG;
            break;

        case HSM_CRITERIACOMPARATOR_LT:
            if (size < m_value1) {
                hr = S_OK;
            }
            break;

        case HSM_CRITERIACOMPARATOR_LTE:
            if (size <= m_value1) {
                hr = S_OK;
            }
            break;

        case HSM_CRITERIACOMPARATOR_EQL:
            if (size == m_value1) {
                hr = S_OK;
            }
            break;

        case HSM_CRITERIACOMPARATOR_NEQL:
            if (size != m_value1) {
                hr = S_OK;
            }
            break;

        case HSM_CRITERIACOMPARATOR_GTE:
            if (size >= m_value1) {
                hr = S_OK;
            }
            break;

        case HSM_CRITERIACOMPARATOR_GT:
            if (size > m_value1) {
                hr = S_OK;
            }
            break;

        case HSM_CRITERIACOMPARATOR_BETWEEN:
            WsbAssert(0 != m_arg2, E_INVALIDARG);

            if ((m_value1 <= size) && (size <= m_value2)) {
                hr = S_OK;
            }
            break;

        case HSM_CRITERIACOMPARATOR_OUTSIDE:
            WsbAssert(0 != m_arg2, E_INVALIDARG);

            if ((size < m_value1) || (m_value2 > size)) {
                hr = S_OK;
            }

            break;
        }

        if (SUCCEEDED(hr) && m_isNegated) {
            if (S_OK == hr) {
                hr = S_FALSE;
            } else {
                hr = S_OK;
            }
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmCritPhysicalSize::ShouldDo"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

HRESULT
CHsmCritPhysicalSize::Value(
    IN IFsaScanItem* pScanItem,
    OUT OLECHAR** pValue,
    IN ULONG bufferSize
    )

/*++

Implements:

  IHsmCriteria::Value().

--*/
{
    HRESULT     hr = S_OK;
    LONGLONG    size;
    
    try {
        
        WsbAssert(0 != pScanItem, E_POINTER);
        WsbAssert(0 != pValue, E_POINTER);

        WsbAffirmHr(pScanItem->GetPhysicalSize(&size));
        WsbAffirmHr(WsbLLtoWCS(size, pValue, bufferSize));

    } WsbCatch(hr);

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\job\hsmcrit.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    hsmcrit.cpp

Abstract:

    This component represents the criteria that can be used to determine
    whether a given scanItem should have a policy applied to it.

Author:

    Chuck Bardeen   [cbardeen]   29-Oct-1996

Revision History:

--*/

#include "resource.h"       // main symbols

#include "wsb.h"

#ifndef _HSMCRIT_
#define _HSMCRIT_


// Abstract Classes

/*++

Class Name:
    
    CHsmCriteria

Class Description:

    An abstract class that represents the criteria that can be used to determine
    whether a given FsaScanItem should have a policy applied to it. These criteria
    are based upon properties of an FsaScanItem.

--*/

class CHsmCriteria : 
    public CWsbObject,
    public IHsmCriteria
{
// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);

// IPersistStream
public:
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER* pSize);
    STDMETHOD(Load)(IStream* pStream);
    STDMETHOD(Save)(IStream* pStream, BOOL clearDirty);

// IWsbTestable
    STDMETHOD(Test)(USHORT *passed, USHORT* failed);

// IHsmCriteria
public:
    STDMETHOD(GetName)(OLECHAR** pName, ULONG bufferSize);
    STDMETHOD(IsIgnored)(void);
    STDMETHOD(IsNegated)(void);
    STDMETHOD(SetIsIgnored)(BOOL isIgnored);
    STDMETHOD(SetIsNegated)(BOOL isNegated);

protected:
    ULONG       m_nameId;
    BOOL        m_isIgnored;
    BOOL        m_isNegated;
};



/*++

Class Name:
    
    CHsmRelativeCriteria

Class Description:

    An abstract class that represents the criteria that compare the properties
    of the FsaScanItem to another value (or values) to determine whether the
    FsaScanItem matches.

--*/

class CHsmRelativeCriteria : 
    public CHsmCriteria,
    public IHsmRelativeCriteria
{
// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);
    void FinalRelease(void);

// IPersistStream
public:
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER* pSize);
    STDMETHOD(Load)(IStream* pStream);
    STDMETHOD(Save)(IStream* pStream, BOOL clearDirty);

// IHsmRelativeCriteria
public:
    STDMETHOD(ComparatorAsString)(OLECHAR** pComparator, ULONG bufferSize);
    STDMETHOD(ComparatorIsBinary)(void);
    STDMETHOD(GetArg1)(OLECHAR** pArg, ULONG bufferSize);
    STDMETHOD(GetArg2)(OLECHAR** pArg, ULONG bufferSize);
    STDMETHOD(GetComparator)(HSM_CRITERIACOMPARATOR* pComparator);
    STDMETHOD(SetComparator)(HSM_CRITERIACOMPARATOR comparator);
    STDMETHOD(SetArg1)(OLECHAR* arg);
    STDMETHOD(SetArg2)(OLECHAR* arg);

protected:
    HSM_CRITERIACOMPARATOR      m_comparator;
    OLECHAR*                    m_arg1;
    OLECHAR*                    m_arg2;
};


// Concrete Classes : Inheriting from CHsmAction

/*++

Class Name:
    
    CHsmCritAlways

Class Description:

    A criteria that matches all FsaScanItems.

--*/

class CHsmCritAlways : 
    public CHsmCriteria,
    public CComCoClass<CHsmCritAlways,&CLSID_CHsmCritAlways>
{
public:
    CHsmCritAlways() {}
BEGIN_COM_MAP(CHsmCritAlways)
    COM_INTERFACE_ENTRY(IHsmCriteria)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IWsbCollectable)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_CHsmCritAlways)

// CComRootObject
public:
    STDMETHOD(FinalConstruct)(void);

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);

// IWsbTestable
    STDMETHOD(Test)(USHORT *passed, USHORT* failed);

// IHsmCriteria
public:
    STDMETHOD(ShouldDo)(IFsaScanItem* pScanItem, USHORT scale);
    STDMETHOD(Value)(IFsaScanItem* pScanItem, OLECHAR** pName, ULONG bufferSize);
};


/*++

Class Name:
    
    CHsmCritCompressed

Class Description:

    A criteria that matches an FsaScanItems that is compressed.

--*/

class CHsmCritCompressed : 
    public CHsmCriteria,
    public CComCoClass<CHsmCritCompressed,&CLSID_CHsmCritCompressed>
{
public:
    CHsmCritCompressed() {}
BEGIN_COM_MAP(CHsmCritCompressed)
    COM_INTERFACE_ENTRY(IHsmCriteria)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IWsbCollectable)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_CHsmCritCompressed)

// CComRootObject
public:
    STDMETHOD(FinalConstruct)(void);

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);

// IHsmCriteria
public:
    STDMETHOD(ShouldDo)(IFsaScanItem* pScanItem, USHORT scale);
    STDMETHOD(Value)(IFsaScanItem* pScanItem, OLECHAR** pName, ULONG bufferSize);
};


/*++

Class Name:
    
    CHsmCritLinked

Class Description:

    A criteria that matches an FsaScanItem that is a symbolic link or mount
    point.

--*/

class CHsmCritLinked : 
    public CHsmCriteria,
    public CComCoClass<CHsmCritLinked,&CLSID_CHsmCritLinked>
{
public:
    CHsmCritLinked() {}
BEGIN_COM_MAP(CHsmCritLinked)
    COM_INTERFACE_ENTRY(IHsmCriteria)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IWsbCollectable)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_CHsmCritLinked)

// CComRootObject
public:
    STDMETHOD(FinalConstruct)(void);

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);

// IHsmCriteria
public:
    STDMETHOD(ShouldDo)(IFsaScanItem* pScanItem, USHORT scale);
    STDMETHOD(Value)(IFsaScanItem* pScanItem, OLECHAR** pName, ULONG bufferSize);
};

    
/*++

Class Name:
    
    CHsmCritMbit

Class Description:

    A criteria that matches an FsaScanItem whose mbit (modify bit) is set.

--*/

class CHsmCritMbit : 
    public CHsmCriteria,
    public CComCoClass<CHsmCritMbit,&CLSID_CHsmCritMbit>
{
public:
    CHsmCritMbit() {}
BEGIN_COM_MAP(CHsmCritMbit)
    COM_INTERFACE_ENTRY(IHsmCriteria)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IWsbCollectable)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_CHsmCritMbit)

// CComRootObject
public:
    STDMETHOD(FinalConstruct)(void);

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);

// IHsmCriteria
public:
    STDMETHOD(ShouldDo)(IFsaScanItem* pScanItem, USHORT scale);
    STDMETHOD(Value)(IFsaScanItem* pScanItem, OLECHAR** pName, ULONG bufferSize);
};

    

/*++

Class Name:
    
    CHsmCritManageable

Class Description:

    A criteria that matches an FsaScanItem that the Fsa thinks is capable of
    migrated.

--*/

class CHsmCritManageable : 
    public CHsmCriteria,
    public CComCoClass<CHsmCritManageable,&CLSID_CHsmCritManageable>
{
public:
    CHsmCritManageable() {}
BEGIN_COM_MAP(CHsmCritManageable)
    COM_INTERFACE_ENTRY(IHsmCriteria)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IWsbCollectable)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_CHsmCritManageable)

// CComRootObject
public:
    STDMETHOD(FinalConstruct)(void);

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);

// IHsmCriteria
public:
    STDMETHOD(ShouldDo)(IFsaScanItem* pScanItem, USHORT scale);
    STDMETHOD(Value)(IFsaScanItem* pScanItem, OLECHAR** pName, ULONG bufferSize);
};


/*++

Class Name:
    
    CHsmCritMigrated

Class Description:

    A criteria that matches an FsaScanItem that has been migrated.

--*/

class CHsmCritMigrated : 
    public CHsmCriteria,
    public CComCoClass<CHsmCritMigrated,&CLSID_CHsmCritMigrated>
{
public:
    CHsmCritMigrated() {}
BEGIN_COM_MAP(CHsmCritMigrated)
    COM_INTERFACE_ENTRY(IHsmCriteria)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IWsbCollectable)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_CHsmCritMigrated)

// CComRootObject
public:
    STDMETHOD(FinalConstruct)(void);

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);

// IHsmCriteria
public:
    STDMETHOD(ShouldDo)(IFsaScanItem* pScanItem, USHORT scale);
    STDMETHOD(Value)(IFsaScanItem* pScanItem, OLECHAR** pName, ULONG bufferSize);
};


/*++

Class Name:
    
    CHsmCritPremigrated

Class Description:

    A criteria that matches an FsaScanItem that has been premigrated.

--*/

class CHsmCritPremigrated : 
    public CHsmCriteria,
    public CComCoClass<CHsmCritPremigrated,&CLSID_CHsmCritPremigrated>
{
public:
    CHsmCritPremigrated() {}
BEGIN_COM_MAP(CHsmCritPremigrated)
    COM_INTERFACE_ENTRY(IHsmCriteria)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IWsbCollectable)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_CHsmCritPremigrated)

// CComRootObject
public:
    STDMETHOD(FinalConstruct)(void);

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);

// IHsmCriteria
public:
    STDMETHOD(ShouldDo)(IFsaScanItem* pScanItem, USHORT scale);
    STDMETHOD(Value)(IFsaScanItem* pScanItem, OLECHAR** pName, ULONG bufferSize);
};


/*++

Class Name:
    
    CHsmCritAccessTime

Class Description:

    A criteria that compares the configured time (either absolute or relative)
    to the FsaScanItem's last access time to determine if it matches.

--*/

class CHsmCritAccessTime : 
    public CHsmRelativeCriteria,
    public CComCoClass<CHsmCritAccessTime,&CLSID_CHsmCritAccessTime>
{
public:
    CHsmCritAccessTime() {}
BEGIN_COM_MAP(CHsmCritAccessTime)
    COM_INTERFACE_ENTRY(IHsmCriteria)
    COM_INTERFACE_ENTRY(IHsmRelativeCriteria)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IWsbCollectable)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_CHsmCritAccessTime)

// CComRootObject
public:
    STDMETHOD(FinalConstruct)(void);

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);

// IHsmCriteria
public:
    STDMETHOD(SetArg1)(OLECHAR* arg);
    STDMETHOD(SetArg2)(OLECHAR* arg);
    STDMETHOD(ShouldDo)(IFsaScanItem* pScanItem, USHORT scale);
    STDMETHOD(Value)(IFsaScanItem* pScanItem, OLECHAR** pName, ULONG bufferSize);

protected:
    BOOL            m_isRelative;
    FILETIME        m_value1;
    FILETIME        m_value2;
};


/*++

Class Name:
    
    CHsmCritGroup

Class Description:

    A criteria that compares the group specified to the group indicated being
    the owner of the FsaScanItem.

--*/

class CHsmCritGroup : 
    public CHsmRelativeCriteria,
    public CComCoClass<CHsmCritGroup,&CLSID_CHsmCritGroup>
{
public:
    CHsmCritGroup() {}
BEGIN_COM_MAP(CHsmCritGroup)
    COM_INTERFACE_ENTRY(IHsmCriteria)
    COM_INTERFACE_ENTRY(IHsmRelativeCriteria)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IWsbCollectable)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_CHsmCritGroup)

// CComRootObject
public:
    STDMETHOD(FinalConstruct)(void);

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);

// IHsmCriteria
public:
    STDMETHOD(ShouldDo)(IFsaScanItem* pScanItem, USHORT scale);
    STDMETHOD(Value)(IFsaScanItem* pScanItem, OLECHAR** pName, ULONG bufferSize);
};


/*++

Class Name:
    
    CHsmCritLogicalSize

Class Description:

    A criteria that compares the logical size (uncompressed, not migrated, ...)
    of the FsaScanItem to the configured values.

--*/

class CHsmCritLogicalSize : 
    public CHsmRelativeCriteria,
    public CComCoClass<CHsmCritLogicalSize,&CLSID_CHsmCritLogicalSize>
{
public:
    CHsmCritLogicalSize() {}
BEGIN_COM_MAP(CHsmCritLogicalSize)
    COM_INTERFACE_ENTRY(IHsmCriteria)
    COM_INTERFACE_ENTRY(IHsmRelativeCriteria)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IWsbCollectable)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_CHsmCritLogicalSize)

// CComRootObject
public:
    STDMETHOD(FinalConstruct)(void);

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);

// IHsmCriteria
public:
    STDMETHOD(SetArg1)(OLECHAR* arg);
    STDMETHOD(SetArg2)(OLECHAR* arg);
    STDMETHOD(ShouldDo)(IFsaScanItem* pScanItem, USHORT scale);
    STDMETHOD(Value)(IFsaScanItem* pScanItem, OLECHAR** pName, ULONG bufferSize);

protected:
    LONGLONG        m_value1;
    LONGLONG        m_value2;
};


/*++

Class Name:
    
    CHsmCritModifyTime

Class Description:

    A criteria that compares the configured time (either absolute or relative)
    to the FsaScanItem's last modification time to determine if it matches.

--*/

// Class:   CHsmCritModifyTime
class CHsmCritModifyTime : 
    public CHsmRelativeCriteria,
    public CComCoClass<CHsmCritModifyTime,&CLSID_CHsmCritModifyTime>
{
public:
    CHsmCritModifyTime() {}
BEGIN_COM_MAP(CHsmCritModifyTime)
    COM_INTERFACE_ENTRY(IHsmCriteria)
    COM_INTERFACE_ENTRY(IHsmRelativeCriteria)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IWsbCollectable)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_CHsmCritModifyTime)

// CComRootObject
public:
    STDMETHOD(FinalConstruct)(void);

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);

// IHsmCriteria
public:
    STDMETHOD(SetArg1)(OLECHAR* arg);
    STDMETHOD(SetArg2)(OLECHAR* arg);
    STDMETHOD(ShouldDo)(IFsaScanItem* pScanItem, USHORT scale);
    STDMETHOD(Value)(IFsaScanItem* pScanItem, OLECHAR** pName, ULONG bufferSize);

protected:
    BOOL            m_isRelative;
    FILETIME        m_value1;
    FILETIME        m_value2;
};


/*++

Class Name:
    
    CHsmCritOwner

Class Description:

    A criteria that compares the owner specified to the owner of the FsaScanItem.

--*/

class CHsmCritOwner : 
    public CHsmRelativeCriteria,
    public CComCoClass<CHsmCritOwner,&CLSID_CHsmCritOwner>
{
public:
    CHsmCritOwner() {}
BEGIN_COM_MAP(CHsmCritOwner)
    COM_INTERFACE_ENTRY(IHsmCriteria)
    COM_INTERFACE_ENTRY(IHsmRelativeCriteria)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IWsbCollectable)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_CHsmCritOwner)

// CComRootObject
public:
    STDMETHOD(FinalConstruct)(void);

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);

// IHsmCriteria
public:
    STDMETHOD(ShouldDo)(IFsaScanItem* pScanItem, USHORT scale);
    STDMETHOD(Value)(IFsaScanItem* pScanItem, OLECHAR** pName, ULONG bufferSize);
};


/*++

Class Name:
    
    CHsmCritPhysicalSize

Class Description:

    A criteria that compares the physical size (compressed, migrated, ...)
    of the FsaScanItem to the configured values.

--*/

class CHsmCritPhysicalSize : 
    public CHsmRelativeCriteria,
    public CComCoClass<CHsmCritPhysicalSize,&CLSID_CHsmCritPhysicalSize>
{
public:
    CHsmCritPhysicalSize() {}
BEGIN_COM_MAP(CHsmCritPhysicalSize)
    COM_INTERFACE_ENTRY(IHsmCriteria)
    COM_INTERFACE_ENTRY(IHsmRelativeCriteria)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IWsbCollectable)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_CHsmCritPhysicalSize)

// CComRootObject
public:
    STDMETHOD(FinalConstruct)(void);

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);

// IHsmCriteria
public:
    STDMETHOD(SetArg1)(OLECHAR* arg);
    STDMETHOD(SetArg2)(OLECHAR* arg);
    STDMETHOD(ShouldDo)(IFsaScanItem* pScanItem, USHORT scale);
    STDMETHOD(Value)(IFsaScanItem* pScanItem, OLECHAR** pName, ULONG bufferSize);

protected:
    LONGLONG        m_value1;
    LONGLONG        m_value2;
};

#endif // _HSMCRIT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\job\hsmjob.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    hsmjob.cpp

Abstract:

    This class contains represents a job that can be performed by the HSM
    system.

Author:

    Chuck Bardeen   [cbardeen]   29-Oct-1996

Revision History:

--*/

#include "stdafx.h"

#include "wsb.h"
#include "fsa.h"
#include "job.h"
#include "task.h"
#include "engine.h"
#include "HsmConn.h"
#include "hsmjob.h"


#define JOB_PARAMETER_MAX_ACTIVE_JOB    OLESTR("MaximumNumberOfActiveJobs")
#define MAX_ACTIVE_JOBS_DEFAULT         10

#define WSB_TRACE_IS        WSB_TRACE_BIT_JOB

static USHORT iCountJob = 0;  // Count of existing objects


HRESULT
CHsmJob::AdviseOfSessionState(
    IN IHsmSession* pSession,
    IN IHsmPhase* pPhase,
    IN OLECHAR* currentPath
    )

/*++

Implements:

  IHsmJobPriv::AdviseOfSessionState().

--*/
{
    HRESULT                             hr = S_OK;
    CONNECTDATA                         pConnectData;
    CComPtr<IConnectionPoint>           pCP;
    CComPtr<IConnectionPointContainer>  pCPC;
    CComPtr<IEnumConnections>           pConnection;
    CComPtr<IHsmJobSinkEverySession>    pSink;

    try {

        WsbAssert(0 != pSession, E_UNEXPECTED);

        // Tell everyone the new state of the session.
        WsbAffirmHr(((IUnknown*)(IHsmJob*) this)->QueryInterface(IID_IConnectionPointContainer, (void**) &pCPC));
        WsbAffirmHr(pCPC->FindConnectionPoint(IID_IHsmJobSinkEverySession, &pCP));
        WsbAffirmHr(pCP->EnumConnections(&pConnection));

        while(pConnection->Next(1, &pConnectData, 0) == S_OK) {

            // We don't care if the sink has problems (it's their problem).
            try {
                WsbAffirmHr((pConnectData.pUnk)->QueryInterface(IID_IHsmJobSinkEverySession, (void**) &pSink));
                WsbAffirmHr(pSink->ProcessJobSession(pSession, pPhase, currentPath));
            } WsbCatchAndDo(hr, hr = S_OK;);

            WsbAffirmHr((pConnectData.pUnk)->Release());
            pSink=0;
        }

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmJob::Cancel(
    IN HSM_JOB_PHASE phase
    )

/*++

Implements:

  IHsmJob::Cancel().

--*/
{
    HRESULT                             hr = S_OK;
    HRESULT                             hr2;
    CComPtr<IHsmJobWorkItemPriv>        pWorkItem;
    CComPtr<IHsmSession>                pSession;
    CComPtr<IWsbEnum>                   pEnum;

    WsbTraceIn(OLESTR("CHsmJob::Cancel"), OLESTR("Phase = <%d>"), phase);
    try {
        m_state = HSM_JOB_STATE_CANCELLING;
        WsbLogEvent(JOB_MESSAGE_JOB_CANCELLING, 0, NULL, (OLECHAR*) m_name, NULL);

        WsbAffirmHr(EnumWorkItems(&pEnum));

        // Tell all the session we have to cancel the phase(s).
        for (hr = pEnum->First(IID_IHsmJobWorkItemPriv, (void**) &pWorkItem);
             (hr == S_OK);
             hr = pEnum->Next(IID_IHsmJobWorkItemPriv, (void**) &pWorkItem)) {

            WsbAffirmHr(pWorkItem->GetSession(&pSession));
            
            if (pSession != 0) {
                WsbAffirmHr(pSession->Cancel(phase));

                // If we are quiting the entire job, we need to cleanup in case
                // the session refuses to terminate properly (i.e. one of the
                // subordinates to the session is out to lunch).
                if (phase == HSM_JOB_PHASE_ALL) {

                    WsbTrace(OLESTR("CHsmJob::Cancel - Cancelling all.\n"));
                    m_isTerminating = TRUE;
                    // Fake the work item into thinking that the session completed, since we
                    // don't want to rely upon it completing normally
                    try {
                        CComPtr<IHsmPhase>                      pPhase;
                        CComPtr<IHsmPhasePriv>                  pPhasePriv;
                        CComPtr<IHsmSessionSinkEveryState>      pSink;

                        WsbAffirmHr(CoCreateInstance(CLSID_CHsmPhase, 0, CLSCTX_ALL, IID_IHsmPhasePriv, (void**) &pPhasePriv));
                        WsbAffirmHr(pPhasePriv->SetPhase(HSM_JOB_PHASE_ALL));
                        WsbAffirmHr(pPhasePriv->SetState(HSM_JOB_STATE_CANCELLED));
                        WsbAffirmHr(pPhasePriv->QueryInterface(IID_IHsmPhase, (void**) &pPhase));
                        WsbAffirmHr(pWorkItem->QueryInterface(IID_IHsmSessionSinkEveryState, (void**) &pSink));
                        WsbAffirmHr(pSink->ProcessSessionState(pSession, pPhase, OLESTR("")));
                    } WsbCatchAndDo(hr2, pSession->ProcessHr(phase, __FILE__, __LINE__, hr2););
                }
                pSession = 0;
            }

            pWorkItem = 0;
        }

        if (hr == WSB_E_NOTFOUND) {
            hr = S_OK;
        }

        m_state = HSM_JOB_STATE_CANCELLED;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmJob::Cancel"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}


HRESULT
CHsmJob::CheckResourceNotInUse(
    IN GUID resid
    )

/*++

Routine Description:

    Determines if another job is using this resource or if too many jobs
    are already active.

Arguments:

    resid - Id of the resource in question.

Return Value:

    S_OK    - Resource is not in use.

    S_FALSE - Resource is in use.

    E_*     - An error occurred.

--*/
{
    HRESULT                        hr = S_OK;

    WsbTraceIn(OLESTR("CHsmJob::CheckResourceNotInUse"), 
            OLESTR("resource id = <%ls>"), WsbGuidAsString(resid));
    try {
        ULONG                          nJobs;
        ULONG                          nJobsActive = 0;
        CComPtr<IHsmServer>            pHsmServer;
        CComPtr<IWsbIndexedCollection> pJobs;

        // Get list of jobs
        WsbAffirmHr(HsmConnectFromId(HSMCONN_TYPE_HSM, m_hsmId, IID_IHsmServer, (void**) &pHsmServer));
        WsbAffirmHr(pHsmServer->GetJobs(&pJobs));

        // Loop over jobs
        WsbAffirmHr(pJobs->GetEntries(&nJobs));
        for (ULONG i = 0; i < nJobs; i++) {
            CWsbStringPtr                  JobName;
            GUID                           l_guid;
            CComPtr<IHsmJob>               pJob;
            CComPtr<IHsmJobWorkItemPriv>   pWorkItem;
            CComPtr<IWsbEnum>              pEnum;
            HRESULT                        hrEnum;
            HSM_JOB_STATE                  state;

            pJob = 0;
            WsbAffirmHr(pJobs->At(i, IID_IHsmJob, (void**) &pJob));

            // Ignore this job if it's not active
            if (S_OK == pJob->GetName(&JobName, 0)) {
                WsbTrace(OLESTR("CHsmJob::CheckResourceNotInUse: job <%ls>\n"),
                        static_cast<OLECHAR*>(JobName));
                JobName.Free();
            }
            hr = pJob->IsActive();
            if (S_FALSE == hr) {
                hr = S_OK;
                continue;
            } else {
                WsbAffirmHr(hr);
            }

            // Ignore this job if it's suspended
            WsbAffirmHr(pJob->GetState(&state));
            if ((HSM_JOB_STATE_SUSPENDED == state) || (HSM_JOB_STATE_SUSPENDING == state)) {
                continue;
            }

            nJobsActive++;

            // The job is active, check against all of its active work items
            WsbAffirmHr(pJob->EnumWorkItems(&pEnum));
            for (hrEnum = pEnum->First(IID_IHsmJobWorkItemPriv, (void**) &pWorkItem);
                 (hrEnum == S_OK);
                 hrEnum = pEnum->Next(IID_IHsmJobWorkItemPriv, (void**) &pWorkItem)) {

                hr = pWorkItem->IsActiveItem();
                if (S_FALSE == hr) {
                    // work item is not active at all, skip it...
                    hr = S_OK;
                    pWorkItem = 0;
                    continue;
                } else {
                    WsbAffirmHr(hr);
                }

                // Get the resource (volume) id that the active work item is using
                // (or wants to use)
                WsbAffirmHr(pWorkItem->GetResourceId(&l_guid));
                WsbTrace(OLESTR("CHsmJob:: l_guid = <%ls>\n"), WsbGuidAsString(l_guid));
                if (l_guid == resid) {
                    WsbTrace(OLESTR("CHsmJob::CheckResourceNotInUse: resource in use\n"));
                    hr = S_FALSE;
                    break;
                }
                pWorkItem = 0;

            }
            pEnum = 0;

            if (hr == S_FALSE) {
                // resource in use, no need to continue enumerating jobs
                break;
            }

        }

        // Limit the number of active jobs
        WsbTrace(OLESTR("CHsmJob::CheckResourceNotInUse: total jobs = %lu, active jobs = %lu\n"),
                nJobs, nJobsActive);
        DWORD   size;
        OLECHAR tmpString[256];
        DWORD   maxJobs = MAX_ACTIVE_JOBS_DEFAULT;
        if (SUCCEEDED(WsbGetRegistryValueString(NULL, HSM_ENGINE_REGISTRY_STRING, JOB_PARAMETER_MAX_ACTIVE_JOB, tmpString, 256, &size))) {
            maxJobs = wcstol(tmpString, NULL, 10);
            if (0 == maxJobs) {
                // Illegal value, get back to default
                maxJobs = MAX_ACTIVE_JOBS_DEFAULT;
            }
        }
        WsbTrace(OLESTR("CHsmJob::CheckResourceNotInUse: max active jobs = %lu\n"), maxJobs);
        if (nJobsActive >= maxJobs) {
            WsbTrace(OLESTR("CHsmJob::CheckResourceNotInUse: too many active jobs\n"),
                    nJobsActive);
            hr = S_FALSE;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmJob::CheckResourceNotInUse"), OLESTR("hr = <%ls>"), 
            WsbHrAsString(hr));
    return(hr);
}


HRESULT
CHsmJob::DidFinish(
    void
    )

/*++

Implements:

  IHsmJob::DidFinish().

--*/
{
    HRESULT                     hr = S_OK;
    CComPtr<IHsmJobWorkItem>    pWorkItem;
    CComPtr<IWsbEnum>           pEnum;
    HSM_JOB_STATE               state;

    try {

        WsbAffirmHr(EnumWorkItems(&pEnum));

        // If any of the items aren't done then the work wasn't finished. This means
        // that we would want to try again on failed items.
        for (hr = pEnum->First(IID_IHsmJobWorkItem, (void**) &pWorkItem);
             (hr == S_OK);
             hr = pEnum->Next(IID_IHsmJobWorkItem, (void**) &pWorkItem)) {

            WsbAffirmHr(pWorkItem->GetState(&state));

            if ((HSM_JOB_STATE_DONE != state) && (HSM_JOB_STATE_SKIPPED != state) && (HSM_JOB_STATE_FAILED != state)) {
                hr = S_FALSE;
            }

            pWorkItem = 0;
        }

        if (hr == WSB_E_NOTFOUND) {
            hr = S_OK;
        }

    } WsbCatch(hr);


    return(hr);
}



HRESULT
CHsmJob::DidFinishOk(
    void
    )

/*++

Implements:

  IHsmJob::DidFinishOk().

--*/
{
    HRESULT                     hr = S_OK;
    CComPtr<IHsmJobWorkItem>    pWorkItem;
    CComPtr<IWsbEnum>           pEnum;
    HSM_JOB_STATE               state;

    try {

        WsbAffirmHr(EnumWorkItems(&pEnum));

        // If any of the items aren't done then the work wasn't finished. This means
        // that we would want to try again on failed items.
        for (hr = pEnum->First(IID_IHsmJobWorkItem, (void**) &pWorkItem);
             (hr == S_OK);
             hr = pEnum->Next(IID_IHsmJobWorkItem, (void**) &pWorkItem)) {

            WsbAffirmHr(pWorkItem->GetState(&state));

            if ((HSM_JOB_STATE_DONE != state) && (HSM_JOB_STATE_SKIPPED != state)) {
                hr = S_FALSE;
            }

            pWorkItem = 0;
        }

        if (hr == WSB_E_NOTFOUND) {
            hr = S_OK;
        }

    } WsbCatch(hr);


    return(hr);
}


HRESULT
CHsmJob::Do(
    void
    )

/*++

--*/
{
    HRESULT                             hr = S_OK;
    CComPtr<IConnectionPointContainer>  pCPC;
    CComPtr<IConnectionPoint>           pCP;
    CComPtr<IFsaResource>               pResource;
    CComPtr<IHsmSession>                pSession;
    CComPtr<IHsmSessionSinkEveryState>  pSink;
    CComPtr<IHsmJobWorkItemPriv>        pWorkItem;
    CComPtr<IHsmJobWorkItem>            pWorkItemScan;
    CComPtr<IWsbEnum>                   pEnum;
    CComPtr<IHsmServer>                 pHsmServer;
    HSM_JOB_STATE                       state;
    GUID                                managingHsm;
    ULONG                               i = 0;
    FILETIME                            fileTime;
    CWsbStringPtr                       startingPath;
    DWORD                               cookie;
    ULONG                               maxActiveSessions;
    CWsbStringPtr                       resourceName;
    GUID                                ResourceId = GUID_NULL;
    

    WsbTraceIn(OLESTR("CHsmJob::Do"), OLESTR(""));
    try {

        WsbAssert(m_pContext != 0, E_UNEXPECTED);

        // Check if jobs are disabled
        WsbAffirmHr(HsmConnectFromId(HSMCONN_TYPE_HSM, m_hsmId, IID_IHsmServer, (void**) &pHsmServer));
        hr = pHsmServer->AreJobsEnabled();
        if (S_FALSE == hr) {
            // Jobs are disabled; suspend the job
            WsbAffirmHr(Suspend(HSM_JOB_PHASE_ALL));
            WsbThrow(hr);
        } else {
            WsbAffirmHr(hr);
        }

        // The job will enumerate over the work list.
        WsbAffirmHr(EnumWorkItems(&pEnum));

        // Go through the list of work items and start a session for anything that needs
        // work up to the limit of the number of sessions that can be active at one time.
        WsbAffirmHr(GetMaxActiveSessions(&maxActiveSessions));

        for (hr = pEnum->First(IID_IHsmJobWorkItemPriv, (void**) &pWorkItem);
             SUCCEEDED(hr) && (m_activeSessions < maxActiveSessions);
             hr = pEnum->Next(IID_IHsmJobWorkItemPriv, (void**) &pWorkItem)) {

            // If we should do this item, then find it's resource.
            WsbAffirmHr(pWorkItem->GetState(&state));

            // Only do work for items that are currently idle.
            if (HSM_JOB_STATE_IDLE == state) {

                // Check if the required resource is in use by another job
                WsbAffirmHr(pWorkItem->GetResourceId(&ResourceId));
                hr = CheckResourceNotInUse(ResourceId);
                if (S_FALSE == hr) {
                    // Resource is not available; suspend the job
                    WsbAffirmHr(Suspend(HSM_JOB_PHASE_ALL));
                    break;
                } else {
                    WsbAffirmHr(hr);
                }

                // Indicate that we are trying to start a session. This prevents us from trying
                // again.
                WsbAffirmHr(pWorkItem->SetState(HSM_JOB_STATE_STARTING));

                try {

                    fileTime.dwHighDateTime = 0;
                    fileTime.dwLowDateTime = 0;
                    WsbAffirmHr(pWorkItem->SetFinishTime(fileTime));
                    WsbAffirmHr(CoFileTimeNow(&fileTime));
                    WsbAffirmHr(pWorkItem->SetStartTime(fileTime));

                    WsbTrace(OLESTR("CHsmJob::Do, resource id = %ls\n"),
                            WsbGuidAsString(ResourceId));
                    WsbAffirmHr(HsmConnectFromId(HSMCONN_TYPE_RESOURCE, 
                            ResourceId, IID_IFsaResource, (void**) &pResource));
                    //
                    // Get the resource name for event logging
                    try  {
                        WsbAffirmHr(pResource->GetName(&resourceName, 0));
                        WsbTrace(OLESTR("CHsmJob::Do, resource name = <%ls>\n"), resourceName);
                    } WsbCatch( hr );
                    
                
                    // We will only do jobs that come from the managing HSM.
                    WsbAffirmHr(pResource->GetManagingHsm(&managingHsm));
                    if (!IsEqualGUID(managingHsm, m_hsmId))  {
                        WsbTrace(OLESTR("CHsmJob::Do, HSM of resource = %ls\n"),
                                WsbGuidAsString(managingHsm));
                        WsbTrace(OLESTR("CHsmJob::Do, HSM of job = %ls\n"),
                                WsbGuidAsString(m_hsmId));
                         hr = JOB_E_NOTMANAGINGHSM;
                        WsbLogEvent(JOB_MESSAGE_JOB_FAILED_NOTMANAGINGHSM, 0, NULL, (OLECHAR*) m_name, (OLECHAR *)resourceName, WsbHrAsString(hr),NULL);
                    WsbThrow(hr);
                    }
                    m_state = HSM_JOB_STATE_ACTIVE;

                    // Set job item as active (started)
                    WsbAffirmHr(pWorkItem->SetActiveItem(TRUE));

                    // Do the pre-scan action if it exists
                    WsbAffirmHr(pWorkItem->QueryInterface(IID_IHsmJobWorkItem,
                            (void**)&pWorkItemScan));
                    WsbAffirmHr(pWorkItemScan->DoPreScan());

                    // Create a session (owned by the resource) that will do the scan of this
                    // resource.
                    i++;
                    WsbAffirmHr(pResource->StartJobSession((IHsmJob*) this, i, &pSession));
                    
                    // Ask the session to advise of every state changes.
                    WsbAffirmHr(pWorkItem->QueryInterface(IID_IHsmSessionSinkEveryState, (void**) &pSink));
                    WsbAffirmHr(pSession->QueryInterface(IID_IConnectionPointContainer, (void**) &pCPC));
                    WsbAffirmHr(pCPC->FindConnectionPoint(IID_IHsmSessionSinkEveryState, &pCP));
                    WsbAffirmHr(pCP->Advise(pSink, &cookie));

                    // Now start the scanner of the resource
                    WsbAffirmHr(pWorkItem->GetStartingPath(&startingPath, 0));
                    WsbAffirmHr(pResource->StartJob(startingPath, pSession));

                    // Increment the count of active sessions.
                    m_activeSessions++;

                    // Update the information in the work list.
                    WsbAffirmHr(pWorkItem->SetSession(pSession));
                    WsbAffirmHr(pWorkItem->SetCookie(cookie));

                } WsbCatchAndDo(hr, pWorkItem->SetState(HSM_JOB_STATE_FAILED);
                        WsbLogEvent(JOB_MESSAGE_JOB_FAILED, 0, NULL, (OLECHAR*) m_name, (OLECHAR *) resourceName, WsbHrAsString(hr), NULL);
                );

                pCP = 0;
                pCPC = 0;
                pSession = 0;
                pResource = 0;
                pSink = 0;
            }

            pWorkItem = 0;
        }

        if (hr == WSB_E_NOTFOUND) {
            hr = S_OK;

            // If we got to the end of the list and no session are active, then we are done.
            if (m_activeSessions == 0) {
                m_isActive = FALSE;
                m_state = HSM_JOB_STATE_IDLE;
                WsbLogEvent(JOB_MESSAGE_JOB_COMPLETED, 0, NULL, (OLECHAR*) m_name, NULL);
            }
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmJob::Do"), OLESTR("hr = <%ls>, isActive = <%ls>, activeSessions = <%lu>"),
        WsbHrAsString(hr), WsbBoolAsString(m_isActive), m_activeSessions);
    return(hr);
}


HRESULT
CHsmJob::DoNext(
    void
    )

/*++

Implements:

  IHsmJobPriv::DoNext().

--*/
{
    HRESULT         hr = S_OK;

    WsbTraceIn(OLESTR("CHsmJob::DoNext"), OLESTR("Active sessions = <%lu>, Terminating = <%ls>"),
                m_activeSessions, WsbBoolAsString(m_isTerminating));
    try {

        // Decrement the count of active sessions.
        if (m_activeSessions > 0)  {
            m_activeSessions--;
        
            // If we are not terminating look for more work
            if (FALSE == m_isTerminating)  {
                // See if there is anthing else to do.
                WsbAffirmHr(Do());
            } else  {
                m_isActive = FALSE;
                m_state = HSM_JOB_STATE_IDLE;
            }
        } else  {
            m_isActive = FALSE;
            m_state = HSM_JOB_STATE_IDLE;
        }
        
        // If we are done with the work, make sure we
        // clear the terminating flag
        if (0 == m_activeSessions)  {
            m_isTerminating = FALSE;
        }

        // Restart other jobs that may be suspended
        WsbAffirmHr(RestartSuspendedJobs());

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmJob::DoNext"), OLESTR("hr = <%ls>, isActive = <%ls>, activeSessions = <%lu>"),
        WsbHrAsString(hr), WsbBoolAsString(m_isActive), m_activeSessions);
    return(hr);
}


HRESULT
CHsmJob::EnumWorkItems(
    IN IWsbEnum** ppEnum
    )

/*++

Implements:

  IHsmJob::EnumWorkItems().

--*/
{
    HRESULT     hr = S_OK;

    try {

        WsbAssert(0 != ppEnum, E_POINTER);
        WsbAffirmHr(m_pWorkItems->Enum(ppEnum));

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmJob::FinalConstruct(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;
    WsbTraceIn(OLESTR("CHsmJob::FinalConstruct"),OLESTR(""));
    
    try {

        WsbAffirmHr(CWsbObject::FinalConstruct());

        m_state = HSM_JOB_STATE_IDLE;
        m_hsmId = GUID_NULL;
        m_isUserDefined = FALSE;
        m_activeSessions = 0;
        m_runId = 0;
        m_isActive = FALSE;
        m_isTerminating = FALSE;

        // Each instance should have its own unique identifier.
        WsbAffirmHr(CoCreateGuid(&m_id));

        // Create the work list collection.
        WsbAffirmHr(CoCreateInstance(CLSID_CWsbOrderedCollection, 0, CLSCTX_ALL, IID_IWsbCollection, (void**) &m_pWorkItems));

    } WsbCatch(hr);

    iCountJob++;
    WsbTraceOut(OLESTR("CHsmJob::FinalConstruct"), OLESTR("Count is <%d>"), iCountJob);

    return(hr);
}
void
CHsmJob::FinalRelease(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalRelease().

--*/
{
    WsbTraceIn(OLESTR("CHsmJob::FinalRelease"),OLESTR(""));

    // Let the parent class do his thing.   
    CWsbObject::FinalRelease();

    iCountJob--;
    WsbTraceOut(OLESTR("CHsmJob::FinalRelease"), OLESTR("Count is <%d>"), iCountJob);
}


HRESULT
CHsmJob::FindWorkItem(
    IN IHsmSession* pSession,
    OUT IHsmJobWorkItem** ppWorkItem
    )

/*++

Implements:

  IHsmJob::FindWorkItem().

--*/
{
    HRESULT                     hr = S_OK;
    CComPtr<IHsmSession>        pItemSession;
    CComPtr<IHsmJobWorkItem>    pWorkItem;
    CComPtr<IWsbEnum>           pEnum;
    GUID                        id;
    GUID                        id2;

    try {

        WsbAssert(0 != ppWorkItem, E_POINTER);

        // The job will enumerate over the work list.
        WsbAffirmHr(EnumWorkItems(&pEnum));

        // Go through the list of work items and see if we have one with this session interface.
        *ppWorkItem = 0;
        WsbAffirmHr(pSession->GetIdentifier(&id));

        hr = pEnum->First(IID_IHsmJobWorkItem, (void**) &pWorkItem);

        while (SUCCEEDED(hr) && (*ppWorkItem == 0)) {


            // NOTE: Pointer comparisson is probably not going to work, since DCOM may change
            // the value of the pointer. We could cache the sessionId in the workItem to
            // make the loop a little faster, but it doesn't seem like a big performance issue.
            WsbAffirmHr(pWorkItem->GetSession(&pItemSession));

            if (pItemSession != 0) {

                WsbAffirmHr(pItemSession->GetIdentifier(&id2));

                if (memcmp(&id, &id2, sizeof(GUID)) == 0) {
                    *ppWorkItem = pWorkItem;
                    pWorkItem->AddRef();
                } else {
                    pWorkItem = 0;
                    pItemSession = 0;
                    hr = pEnum->Next(IID_IHsmJobWorkItem, (void**) &pWorkItem);
                }
            }
        }

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmJob::GetClassID(
    OUT CLSID* pClsid
    )

/*++

Implements:

  IPersist::GetClassID().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmJob::GetClassID"), OLESTR(""));

    try {

        WsbAssert(0 != pClsid, E_POINTER);
        *pClsid = CLSID_CHsmJob;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmJob::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return(hr);
}


HRESULT
CHsmJob::GetContext(
    OUT IHsmJobContext** ppContext
    )

/*++

Implements:

  IHsmJob::GetContext().

--*/
{
    HRESULT                     hr = S_OK;

    try {

        WsbAssert(0 != ppContext, E_POINTER);
        *ppContext = m_pContext;
        if (m_pContext != 0)  {
            m_pContext->AddRef();
        }

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmJob::GetDef(
    OUT IHsmJobDef** ppDef
    )

/*++

Implements:

  IHsmJob::GetDef().

--*/
{
    HRESULT                     hr = S_OK;

    try {

        WsbAssert(0 != ppDef, E_POINTER);
        *ppDef = m_pDef;
        if (m_pDef != 0)  {
            m_pDef->AddRef();
        }

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmJob::GetIdentifier(
    OUT GUID* pId
    )

/*++

Implements:

  IHsmJob::GetIdentifier().

--*/
{
    HRESULT                     hr = S_OK;

    try {

        WsbAssert(0 != pId, E_POINTER);
        *pId = m_id;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmJob::GetHsmId(
    OUT GUID* pId
    )

/*++

Implements:

  IHsmJob::GetHsmId().

--*/
{
    HRESULT                     hr = S_OK;

    try {

        WsbAssert(0 != pId, E_POINTER);
        *pId = m_hsmId;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmJob::GetMaxActiveSessions(
    OUT ULONG* pMaxActiveSessions
    )

/*++

Implements:

  IHsmJob::GetMaxActiveSessions().

--*/
{
    HRESULT                     hr = S_OK;

    try {
        CComPtr<IHsmServer>            pHsmServer;

        WsbAssert(0 != pMaxActiveSessions, E_POINTER);

        WsbAffirmHr(HsmConnectFromId(HSMCONN_TYPE_HSM, m_hsmId, IID_IHsmServer, (void**) &pHsmServer));

        // Currently, the only job with more than one item is the default Copy Files job.
        //  Therefore, the limit is set according to the Copy Files limit
        WsbAffirmHr(pHsmServer->GetCopyFilesLimit(pMaxActiveSessions));

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmJob::GetName(
    OUT OLECHAR** pName,
    IN ULONG bufferSize
    )

/*++

Implements:

  IHsmJob::GetName().

--*/
{
    HRESULT                     hr = S_OK;

    try {

        WsbAssert(0 != pName, E_POINTER);
        WsbAffirmHr(m_name.CopyTo(pName, bufferSize));

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmJob::GetRunId(
    OUT ULONG* pRunId
    )

/*++

Implements:

  IHsmJob::GetRunId().

--*/
{
    HRESULT                     hr = S_OK;

    try {

        WsbAssert(0 != pRunId, E_POINTER);
        *pRunId = m_runId;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmJob::GetSizeMax(
    OUT ULARGE_INTEGER* pSize
    )

/*++

Implements:

  IPersistStream::GetSizeMax().

--*/
{
    HRESULT                     hr = S_OK;
    CComPtr<IPersistStream>     pPersistStream;
    ULARGE_INTEGER              entrySize;

    WsbTraceIn(OLESTR("CHsmJob::GetSizeMax"), OLESTR(""));

    try {

        pSize->QuadPart = 2 * WsbPersistSizeOf(GUID) + 3 * WsbPersistSizeOf(BOOL) + 2 * WsbPersistSizeOf(ULONG) + WsbPersistSize((wcslen(m_name) + 1) * sizeof(OLECHAR));

        if (m_pContext != 0) {
            WsbAffirmHr(m_pContext->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
            WsbAffirmHr(pPersistStream->GetSizeMax(&entrySize));
            pPersistStream = 0;
            pSize->QuadPart += entrySize.QuadPart;
        }

        if (m_pDef != 0) {
            WsbAffirmHr(m_pDef->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
            WsbAffirmHr(pPersistStream->GetSizeMax(&entrySize));
            pPersistStream = 0;
            pSize->QuadPart += entrySize.QuadPart;
        }

        WsbAffirmHr(m_pWorkItems->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
        WsbAffirmHr(pPersistStream->GetSizeMax(&entrySize));
        pPersistStream = 0;
        pSize->QuadPart += entrySize.QuadPart;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmJob::GetSizeMax"), OLESTR("hr = <%ls>, Size = <%ls>"), WsbHrAsString(hr), WsbPtrToUliAsString(pSize));

    return(hr);
}


HRESULT
CHsmJob::GetState(
    OUT HSM_JOB_STATE* pState
    )
/*++

Implements:

  IHsmJob::GetState().

--*/
{
    HRESULT     hr = S_OK;

    try {

        WsbAssert(0 != pState, E_POINTER);
        *pState = m_state;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmJob::InitAs(
    IN OLECHAR* name,
    IN IHsmJobDef* pDef,
    IN HSM_JOB_DEF_TYPE type,
    IN GUID storagePool,
    IN IHsmServer* pServer,
    IN BOOL isUserDefined,
    IN IFsaResource* pResource
    )
                                                     
/*++

Implements:

  IHsmJob::InitAs().

--*/
{
    HRESULT                         hr = S_OK;
    GUID                            id;
    GUID                            hsmId;
    CComPtr<IHsmJobContext>         pContext;
    CComPtr<IWsbGuid>               pGuid;
    CComPtr<IWsbCollection>         pCollection;
    CComPtr<IWsbCreateLocalObject>  pCreateObj;

    try {

        WsbAssert(0 != pServer, E_POINTER);
        WsbAssert(0 != name, E_POINTER);

        // All objects created need to be owned by the engine, and also get some
        // information about the engine.
        WsbAssertHr(pServer->QueryInterface(IID_IWsbCreateLocalObject, (void**) &pCreateObj));
        WsbAssertHr(pServer->GetID(&hsmId));

        // If a definition was provided we use that one; otherwise, a new one is created.
        if (0 != pDef) {
            m_pDef = pDef;  
        } else {
            m_pDef = 0;
            WsbAssertHr(pCreateObj->CreateInstance(CLSID_CHsmJobDef, IID_IHsmJobDef, (void**) &m_pDef));
            WsbAffirmHr(m_pDef->InitAs(name, type, storagePool, pServer, isUserDefined));
        }

        // Create a job context, fill it out, and then add it to the job.
        WsbAssertHr(pCreateObj->CreateInstance(CLSID_CHsmJobContext, IID_IHsmJobContext, (void**) &pContext));

        // If a specific resource is target, then set up the context appropriately.
        if (0 != pResource) {
            WsbAssertHr(pContext->SetUsesAllManaged(FALSE));
            WsbAssertHr(pCreateObj->CreateInstance(CLSID_CWsbGuid, IID_IWsbGuid, (void**) &pGuid));
            WsbAssertHr(pContext->Resources(&pCollection));
            WsbAssertHr(pResource->GetIdentifier(&id));
            WsbAssertHr(pGuid->SetGuid(id));
            WsbAssertHr(pCollection->Add(pGuid));
        } else {
            WsbAssertHr(pContext->SetUsesAllManaged(TRUE));
        }

        m_pContext = pContext;

        // There are a couple of other fields to fill out in the job.
        m_hsmId = hsmId;
        m_isUserDefined = isUserDefined;
        m_name = name;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmJob::IsActive(
    void
    )

/*++

Implements:

  IHsmJob::IsActive().

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CHsmJob::IsActive"), OLESTR(""));
    
    hr = (m_isActive ? S_OK : S_FALSE);
    
    WsbTraceOut(OLESTR("CHsmJob::IsActive"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return( hr );
}


HRESULT
CHsmJob::IsUserDefined(
    void
    )

/*++

Implements:

  IHsmJob::IsUserDefined().

--*/
{
    return(m_isUserDefined ? S_OK : S_FALSE);
}


HRESULT
CHsmJob::Load(
    IN IStream* pStream
    )

/*++

Implements:

  IPersistStream::Load().

--*/
{
    HRESULT                         hr = S_OK;
    CComPtr<IPersistStream>         pPersistStream;
    BOOL                            hasA;
    CComPtr<IHsmJobWorkItemPriv>    pWorkItem;
    CComPtr<IWsbEnum>               pEnum;
    CComPtr<IWsbCreateLocalObject>  pCreateObj;

    WsbTraceIn(OLESTR("CHsmJob::Load"), OLESTR(""));

    try {
        WsbAssert(0 != pStream, E_POINTER);

        WsbLoadFromStream(pStream, &m_hsmId);
        WsbLoadFromStream(pStream, &m_id);
        WsbLoadFromStream(pStream, &m_isUserDefined);
        WsbLoadFromStream(pStream, &m_runId);
        WsbLoadFromStream(pStream, &m_name, 0);

        WsbAffirm(memcmp(&GUID_NULL, &m_hsmId, sizeof(GUID)) != 0, JOB_E_NOTMANAGINGHSM);
#if 0        
        CComPtr<IHsmServer>             pServer;
        WsbAffirmHr(HsmConnectFromId(HSMCONN_TYPE_HSM, m_hsmId, IID_IHsmServer, (void**) &pServer));
        WsbAssertHr(pServer->QueryInterface(IID_IWsbCreateLocalObject, (void**) &pCreateObj));
#endif
        WsbLoadFromStream(pStream, &hasA);
        if (hasA) {
            m_pContext = 0;
//          WsbAssertHr(pCreateObj->CreateInstance(CLSID_CHsmJobContext, IID_IHsmJobContext, (void**) &m_pContext));
            WsbAssertHr(CoCreateInstance(CLSID_CHsmJobContext, NULL, CLSCTX_SERVER, IID_IHsmJobContext, (void**) &m_pContext));
            WsbAffirmHr(m_pContext->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
            WsbAffirmHr(pPersistStream->Load(pStream));
            pPersistStream = 0;
        }

        WsbLoadFromStream(pStream, &hasA);
        if (hasA) {
            m_pDef = 0;
//          WsbAssertHr(pCreateObj->CreateInstance(CLSID_CHsmJobDef, IID_IHsmJobDef, (void**) &m_pDef));
            WsbAssertHr(CoCreateInstance(CLSID_CHsmJobDef, NULL, CLSCTX_SERVER, IID_IHsmJobDef, (void**) &m_pDef));
            WsbAffirmHr(m_pDef->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
            WsbAffirmHr(pPersistStream->Load(pStream));
            pPersistStream = 0;
        }

        WsbAffirmHr(m_pWorkItems->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
        WsbAffirmHr(pPersistStream->Load(pStream));
        
        pPersistStream = 0;

        // Tie the work items to the job.
        WsbAffirmHr(EnumWorkItems(&pEnum));
        hr = pEnum->First(IID_IHsmJobWorkItemPriv, (void**) &pWorkItem);

        while (SUCCEEDED(hr)) {
            WsbAffirmHr(pWorkItem->Init((IHsmJob*) this));
            pWorkItem = 0;
            
            hr = pEnum->Next(IID_IHsmJobWorkItemPriv, (void**) &pWorkItem);
        }

        if (WSB_E_NOTFOUND == hr) {
            hr = S_OK;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmJob::Load"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmJob::Pause(
    IN HSM_JOB_PHASE phase
    )

/*++

Implements:

  IHsmJob::Pause().

--*/
{
    HRESULT                             hr = S_OK;
    CComPtr<IHsmJobWorkItemPriv>        pWorkItem;
    CComPtr<IHsmSession>                pSession;
    CComPtr<IWsbEnum>                   pEnum;

    try {

        WsbLogEvent(JOB_MESSAGE_JOB_PAUSING, 0, NULL, (OLECHAR*) m_name, NULL);

        WsbAffirmHr(EnumWorkItems(&pEnum));

        // Tell all the session we have to resume the phase(s).
        for (hr = pEnum->First(IID_IHsmJobWorkItemPriv, (void**) &pWorkItem);
             (hr == S_OK);
             hr = pEnum->Next(IID_IHsmJobWorkItemPriv, (void**) &pWorkItem)) {

            WsbAffirmHr(pWorkItem->GetSession(&pSession));

            if (pSession != 0) {
                WsbAffirmHr(pSession->Pause(phase));

                if (phase == HSM_JOB_PHASE_ALL) {
                    WsbAffirmHr(pWorkItem->SetState(HSM_JOB_STATE_PAUSING));
                }

                pSession = 0;
            }

            pWorkItem = 0;
        }

        if (hr == WSB_E_NOTFOUND) {
            hr = S_OK;
        }

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmJob::Restart(
    void
    )

/*++

Implements:

  IHsmJob::Restart().

Note:

  If a job is suspended, it is restarted from where it was otherwise it is
  restarted from the beginning.  This is controlled by the parameter to
  UpdateWorkItems.

--*/
{
    HRESULT                             hr = S_OK;

    WsbTraceIn(OLESTR("CHsmJob::Restart"), OLESTR(""));

    try {
        BOOL RestartFromBeginning = TRUE;

        if (m_state == HSM_JOB_STATE_SUSPENDED) {
            // Verify that none of the active work items (i.e. items that were active when
            // the job was suspended) uses a volume that is in use now by another active job
            CComPtr<IHsmJobWorkItemPriv>   pWorkItem;
            CComPtr<IWsbEnum>              pEnum;
            GUID                           ResourceId;
            HRESULT                        hrEnum;

            WsbAffirmHr(EnumWorkItems(&pEnum));
            for (hrEnum = pEnum->First(IID_IHsmJobWorkItemPriv, (void**) &pWorkItem);
                 (hrEnum == S_OK);
                 hrEnum = pEnum->Next(IID_IHsmJobWorkItemPriv, (void**) &pWorkItem)) {

                hr = pWorkItem->IsActiveItem();
                if (S_FALSE == hr) {
                    // work item is not active at all, skip it...
                    hr = S_OK;
                    pWorkItem = 0;
                    continue;
                } else {
                    WsbAffirmHr(hr);
                }       

                // check specific active item 
                WsbAffirmHr(pWorkItem->GetResourceId(&ResourceId));

                WsbTrace(OLESTR("CHsmJob::Restart: ResourceId = <%ls>\n"), WsbGuidAsString(ResourceId));
                hr = CheckResourceNotInUse(ResourceId);
                if (S_OK != hr) {
                    WsbThrow(hr);
                }

                pWorkItem = 0;
            }
            RestartFromBeginning = FALSE;

        } else {
            WsbAssert(!m_isActive, JOB_E_ALREADYACTIVE);
        }

        m_state = HSM_JOB_STATE_STARTING;
        m_isActive = TRUE;

        WsbLogEvent(JOB_MESSAGE_JOB_RESTARTING, 0, NULL, (OLECHAR*) m_name, NULL);

        // Make sure that information in the work list is up to date.
        WsbAffirmHr(UpdateWorkItems(RestartFromBeginning));

        // Start any sessions that need starting.
        WsbAffirmHr(Do());

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmJob::Restart"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmJob::RestartSuspendedJobs(
    void
    )

/*++

Routine Description:

    Restart suspended jobs (Implementation moved to Engine server...).

Arguments:

    None.

Return Value:

    S_OK    - Resource is not in use.

    E_*     - An error occurred.

--*/
{
    HRESULT                        hr = S_OK;

    WsbTraceIn(OLESTR("CHsmJob::RestartSuspendedJobs"), OLESTR(""));
    try {
        CComPtr<IHsmServer>            pHsmServer;

        WsbAffirmHr(HsmConnectFromId(HSMCONN_TYPE_HSM, m_hsmId, IID_IHsmServer, (void**) &pHsmServer));
        WsbAffirmHr(pHsmServer->RestartSuspendedJobs());

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmJob::RestartSuspendedJobs"), OLESTR("hr = <%ls>"), 
            WsbHrAsString(hr));
    return(hr);
}


HRESULT
CHsmJob::Resume(
    IN HSM_JOB_PHASE phase
    )

/*++

Implements:

  IHsmJob::Resume().

--*/
{
    HRESULT                             hr = S_OK;
    CComPtr<IHsmJobWorkItemPriv>        pWorkItem;
    CComPtr<IHsmSession>                pSession;
    CComPtr<IWsbEnum>                   pEnum;

    try {

        WsbLogEvent(JOB_MESSAGE_JOB_RESUMING, 0, NULL, (OLECHAR*) m_name, NULL);

        WsbAffirmHr(EnumWorkItems(&pEnum));

        // Tell all the session we have to resume the phase(s).
        for (hr = pEnum->First(IID_IHsmJobWorkItemPriv, (void**) &pWorkItem);
             (hr == S_OK);
             hr = pEnum->Next(IID_IHsmJobWorkItemPriv, (void**) &pWorkItem)) {

            WsbAffirmHr(pWorkItem->GetSession(&pSession));

            if (pSession != 0) {
                WsbAffirmHr(pSession->Resume(phase));

                if (phase == HSM_JOB_PHASE_ALL) {
                    WsbAffirmHr(pWorkItem->SetState(HSM_JOB_STATE_RESUMING));
                }

                pSession = 0;
            }

            pWorkItem = 0;
        }

        if (hr == WSB_E_NOTFOUND) {
            hr = S_OK;
        }

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmJob::Save(
    IN IStream* pStream,
    IN BOOL clearDirty
    )

/*++

Implements:

  IPersistStream::Save().

--*/
{
    HRESULT                     hr = S_OK;
    CComPtr<IPersistStream>     pPersistStream;
    BOOL                        hasA;

    WsbTraceIn(OLESTR("CHsmJob::Save"), OLESTR("clearDirty = <%ls>"), WsbBoolAsString(clearDirty));
    
    try {

        WsbAssert(0 != pStream, E_POINTER);

        WsbSaveToStream(pStream, m_hsmId);
        WsbSaveToStream(pStream, m_id);
        WsbSaveToStream(pStream, m_isUserDefined);
        WsbSaveToStream(pStream, m_runId);
        WsbSaveToStream(pStream, m_name);

        if (m_pContext != 0) {
            hasA = TRUE;
            WsbSaveToStream(pStream, hasA);
            WsbAffirmHr(m_pContext->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
            WsbAffirmHr(pPersistStream->Save(pStream, clearDirty));
            pPersistStream = 0;
        } else {
            hasA = FALSE;
            WsbSaveToStream(pStream, hasA);
        }

        if (m_pDef != 0) {
            hasA = TRUE;
            WsbSaveToStream(pStream, hasA);
            WsbAffirmHr(m_pDef->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
            WsbAffirmHr(pPersistStream->Save(pStream, clearDirty));
            pPersistStream = 0;
        } else {
            hasA = FALSE;
            WsbSaveToStream(pStream, hasA);
        }

        WsbAffirmHr(m_pWorkItems->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
        WsbAffirmHr(pPersistStream->Save(pStream, clearDirty));
        pPersistStream = 0;

        // If we got it saved and we were asked to clear the dirty bit, then
        // do so now.
        if (clearDirty) {
            m_isDirty = FALSE;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmJob::Save"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmJob::SetContext(
    IN IHsmJobContext* pContext
    )

/*++

Implements:

  IHsmJob::SetContext().

--*/
{
    m_pContext = pContext;

    return(S_OK);
}


HRESULT
CHsmJob::SetDef(
    IN IHsmJobDef* pDef
    )

/*++

Implements:

  IHsmJob::SetDef().

--*/
{
    m_pDef = pDef;

    return(S_OK);
}


HRESULT
CHsmJob::SetHsmId(
    IN GUID id
    )

/*++

Implements:

  IHsmJob::SetHsmId().

--*/
{
    m_hsmId = id;

    return(S_OK);
}


HRESULT
CHsmJob::SetIsUserDefined(
    IN BOOL isUserDefined
    )

/*++

Implements:

  IHsmJob::SetIsUserDefined().

--*/
{
    m_isUserDefined = isUserDefined;

    return(S_OK);
}


HRESULT
CHsmJob::SetName(
    IN OLECHAR* name
    )

/*++

Implements:

  IHsmJob::SetName().

--*/
{
    HRESULT                     hr = S_OK;

    try {

        m_name = name;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmJob::Start(
    void
    )

/*++

Implements:

  IHsmJob::Start().

--*/
{
    HRESULT                             hr = S_OK;

    WsbTraceIn(OLESTR("CHsmJob::Start"), OLESTR(""));

    try {

        if (m_isActive) {
            WsbLogEvent(JOB_MESSAGE_JOB_ALREADYACTIVE, 0, NULL, (OLECHAR*) m_name, NULL);
            WsbThrow(JOB_E_ALREADYACTIVE);
        }
        m_isActive = TRUE;
        m_state = HSM_JOB_STATE_STARTING;

        WsbLogEvent(JOB_MESSAGE_JOB_STARTING, 0, NULL, (OLECHAR*) m_name, NULL);

        // Make sure that information in the work list is up to date.
        WsbAffirmHr(UpdateWorkItems(FALSE));

        // Start any sessions that need starting.
        WsbAffirmHr(Do());

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmJob::Start"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmJob::Suspend(
    IN HSM_JOB_PHASE    phase
    )

/*++

Implements:

  IHsmJob::Suspend().

Note:

  This module assumes that the only reason this function is called is
  because the resource needed by the job is in use by another job.
  The function RestartSuspendedJobs will restart the job when the resource
  is available.

--*/
{
    HRESULT                             hr = S_OK;
    CComPtr<IHsmJobWorkItemPriv>        pWorkItem;
    CComPtr<IHsmSession>                pSession;
    CComPtr<IWsbEnum>                   pEnum;

    WsbTraceIn(OLESTR("CHsmJob::Suspend"), OLESTR(""));

    try {

        m_state = HSM_JOB_STATE_SUSPENDING;
        WsbLogEvent(JOB_MESSAGE_JOB_SUSPENDING, 0, NULL, (OLECHAR*) m_name, NULL);

        WsbAffirmHr(EnumWorkItems(&pEnum));

        // Tell all the sessions we have to suspend the phase(s).
        for (hr = pEnum->First(IID_IHsmJobWorkItemPriv, (void**) &pWorkItem);
             (hr == S_OK);
             hr = pEnum->Next(IID_IHsmJobWorkItemPriv, (void**) &pWorkItem)) {

            WsbAffirmHr(pWorkItem->GetSession(&pSession));

            if (pSession != 0) {
                WsbAffirmHr(pSession->Suspend(HSM_JOB_PHASE_ALL));

                if (phase == HSM_JOB_PHASE_ALL) {
                    WsbAffirmHr(pWorkItem->SetState(HSM_JOB_STATE_SUSPENDING));
                }

                pSession = 0;
            }

            pWorkItem = 0;
        }

        if (hr == WSB_E_NOTFOUND) {
            hr = S_OK;
        }
        m_state = HSM_JOB_STATE_SUSPENDED;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmJob::Suspend"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmJob::Test(
    OUT USHORT* passed,
    OUT USHORT* failed
    )

/*++

Implements:

  IWsbTestable::Test().

--*/
{
    HRESULT     hr = S_OK;

    try {

        WsbAssert(0 != passed, E_POINTER);
        WsbAssert(0 != failed, E_POINTER);

        *passed = 0;
        *failed = 0;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmJob::UpdateWorkItems(
    BOOL isRestart
    )

/*++

--*/
{
    HRESULT                         hr = S_OK;
    CComPtr<IWsbEnum>               pEnum;
    CComPtr<IWsbEnum>               pEnumContext;
    CComPtr<IWsbEnum>               pEnumManaged;
    CComPtr<IWsbIndexedCollection>  pManagedResources;
    CComPtr<IHsmJobWorkItemPriv>    pWorkItem;
    CComPtr<IHsmJobWorkItemPriv>    pFoundWorkItem;
    CComPtr<IWsbGuid>               pGuid;
    CComPtr<IWsbGuid>               pFoundGuid;
    CComPtr<IHsmManagedResource>    pManagedResource;
    CComPtr<IHsmManagedResource>    pFoundResource;
    CComPtr<IHsmServer>             pHsmServer;
    CComPtr<IWsbCollection>         pCollect;
    CComPtr<IFsaResource>           pResource;
    CComPtr<IUnknown>               pUnk;
    HRESULT                         didFinish;
    CWsbStringPtr                   tmpString;
    CWsbStringPtr                   currentPath;
    HSM_JOB_STATE                   state;
    GUID                            id;

    try {

        // We can't run a job without a context and a definition.
        WsbAssert(m_pContext != 0, E_UNEXPECTED);
        WsbAssert(m_pDef != 0, E_UNEXPECTED);

        // Get an enumerator for the work list.
        WsbAffirmHr(EnumWorkItems(&pEnum));

        // First we need to remove any items from the work list that are no longer listed
        // or have been deactivated.
        if (m_pContext->UsesAllManaged() == S_OK) {

            WsbAffirm(memcmp(&GUID_NULL, &m_hsmId, sizeof(GUID)) != 0, JOB_E_NOTMANAGINGHSM);
            WsbAffirmHr(HsmConnectFromId(HSMCONN_TYPE_HSM, m_hsmId, IID_IHsmServer, (void**) &pHsmServer));

            WsbAffirmHr(pHsmServer->GetManagedResources(&pManagedResources));
            WsbAffirmHr(pManagedResources->Enum(&pEnumManaged));

            WsbAffirmHr(CoCreateInstance(CLSID_CHsmManagedResource, 0,  CLSCTX_ALL, IID_IHsmManagedResource, (void**) &pManagedResource));

            hr = pEnum->First(IID_IHsmJobWorkItemPriv, (void**) &pWorkItem);
            while (SUCCEEDED(hr)) {

                WsbAffirmHr(pWorkItem->GetResourceId(&id));
                WsbAffirmHr(pManagedResource->SetResourceId(id));

                if (pEnumManaged->Find(pManagedResource, IID_IHsmManagedResource, (void**) &pFoundResource) == WSB_E_NOTFOUND) {
                    hr = S_OK;
                    m_pWorkItems->RemoveAndRelease(pWorkItem);
                    pWorkItem = 0;
                    hr = pEnum->This(IID_IHsmJobWorkItemPriv, (void**) &pWorkItem);
                } else {
                    pFoundResource = 0;
                    pWorkItem = 0;
                    hr = pEnum->Next(IID_IHsmJobWorkItemPriv, (void**) &pWorkItem);
                }
            }

            pManagedResource = 0;

            if (hr == WSB_E_NOTFOUND) {
                hr = S_OK;
            }

        } else {

            WsbAffirmHr(m_pContext->EnumResources(&pEnumContext));
            WsbAffirmHr(CoCreateInstance(CLSID_CWsbGuid, 0,  CLSCTX_ALL, IID_IWsbGuid, (void**) &pGuid));

            hr = pEnum->First(IID_IHsmJobWorkItemPriv, (void**) &pWorkItem);
            while (SUCCEEDED(hr)) {

                WsbAffirmHr(pWorkItem->GetResourceId(&id));
                WsbAffirmHr(pGuid->SetGuid(id));

                if (pEnumContext->Find(pGuid, IID_IWsbGuid, (void**) &pFoundGuid) == WSB_E_NOTFOUND) {
                    hr = S_OK;
                    m_pWorkItems->RemoveAndRelease(pWorkItem);
                    pWorkItem = 0;
                    hr = pEnum->This(IID_IHsmJobWorkItemPriv, (void**) &pWorkItem);
                } else {
                    pWorkItem = 0;
                    pFoundGuid = 0;
                    hr = pEnum->Next(IID_IHsmJobWorkItemPriv, (void**) &pWorkItem);
                }
            }

            pGuid = 0;

            if (hr == WSB_E_NOTFOUND) {
                hr = S_OK;
            }
        }

        // Based on the items that remain, determine whether this is a restart or a
        // continuation.
        WsbAffirmHr(didFinish = DidFinish());
        
        if ((didFinish == S_OK) || (isRestart)) {
            isRestart = TRUE;
            m_runId++;
        }

        // Add new work items for any items that are new or reactivated.
        if (m_pContext->UsesAllManaged() == S_OK) {

            // Enumerate all the managed resources, and make sure that they are listed
            // as work items.
            WsbAffirmHr(CoCreateInstance(CLSID_CHsmJobWorkItem, 0, CLSCTX_ALL, IID_IHsmJobWorkItemPriv, (void**) &pWorkItem));

            for (hr = pEnumManaged->First(IID_IHsmManagedResource, (void**) &pManagedResource);
                 (hr == S_OK);
                 pManagedResource = 0, hr = pEnumManaged->Next(IID_IHsmManagedResource, (void**) &pManagedResource)) {

                WsbAffirmHr(pManagedResource->GetFsaResource(&pUnk));
                WsbAffirmHr(pUnk->QueryInterface(IID_IFsaResource, (void**) &pResource));
                WsbAffirmHr(pResource->GetIdentifier(&id));
                WsbAffirmHr(pWorkItem->SetResourceId(id));

                pFoundWorkItem = 0;
                if (pEnum->Find(pWorkItem, IID_IHsmJobWorkItemPriv, (void**) &pFoundWorkItem) == WSB_E_NOTFOUND) {
                    hr = S_OK;
                    WsbAffirmHr(pWorkItem->Init((IHsmJob*) this));

                    WsbAffirmHr(m_pWorkItems->Add(pWorkItem));

                    pWorkItem = 0;
                    WsbAffirmHr(CoCreateInstance(CLSID_CHsmJobWorkItem, 0,  CLSCTX_ALL, IID_IHsmJobWorkItemPriv, (void**) &pWorkItem));
                }
                
                pUnk = 0;
                pResource = 0;
            }

            if (hr == WSB_E_NOTFOUND) {
                hr = S_OK;
            }
        } else {
            
            // Enumerate all the resources in the context, and make sure that they are listed
            // as work items.

            WsbAffirmHr(CoCreateInstance(CLSID_CHsmJobWorkItem, 0, CLSCTX_ALL, IID_IHsmJobWorkItemPriv, (void**) &pWorkItem));
            for (hr = pEnumContext->First(IID_IWsbGuid, (void**) &pGuid);
                 (hr == S_OK);
                 hr = pEnumContext->Next(IID_IWsbGuid, (void**) &pGuid)) {

                WsbAffirmHr(pGuid->GetGuid(&id));
                WsbAffirmHr(pWorkItem->SetResourceId(id));

                pFoundWorkItem = 0;
                if (pEnum->Find(pWorkItem, IID_IHsmJobWorkItemPriv, (void**) &pFoundWorkItem) == WSB_E_NOTFOUND) {
                    hr = S_OK;
                    WsbAffirmHr(pWorkItem->Init((IHsmJob*) this));
                    
                    WsbAffirmHr(m_pWorkItems->Add(pWorkItem));
                    pWorkItem = 0;
                    WsbAffirmHr(CoCreateInstance(CLSID_CHsmJobWorkItem, 0,  CLSCTX_ALL, IID_IHsmJobWorkItemPriv, (void**) &pWorkItem));
                }

                pGuid = 0;
            }

            if (hr == WSB_E_NOTFOUND) {
                hr = S_OK;
            }
        }

        pWorkItem = 0;
        
        // Check each item to see if work needs to be done for it.
        for (hr = pEnum->First(IID_IHsmJobWorkItemPriv, (void**) &pWorkItem);
             (hr == S_OK);
             hr = pEnum->Next(IID_IHsmJobWorkItemPriv, (void**) &pWorkItem)) {

            // Resources should be skipped if they are inactive, unavailable or in need of repair. If they
            // had been skipped but are ok now, then set them back to idle.
            WsbAffirmHr(pWorkItem->GetResourceId(&id));
            WsbAffirmHr(HsmConnectFromId(HSMCONN_TYPE_RESOURCE, id, IID_IFsaResource, (void**) &pResource));
            
            WsbAffirmHr(pWorkItem->GetState(&state));
            
            if (pResource->IsActive() != S_OK) {
                WsbAffirmHr(pResource->GetUserFriendlyName(&tmpString, 0));
                WsbLogEvent(JOB_MESSAGE_RESOURCE_INACTIVE, 0, NULL, (OLECHAR*) tmpString, (OLECHAR*) m_name, NULL);
                WsbAffirmHr(pWorkItem->SetState(HSM_JOB_STATE_SKIPPED));
            } else if (pResource->IsAvailable() != S_OK) {
                WsbAffirmHr(pResource->GetUserFriendlyName(&tmpString, 0));
                WsbLogEvent(JOB_MESSAGE_RESOURCE_UNAVAILABLE, 0, NULL, (OLECHAR*) tmpString, (OLECHAR*) m_name, NULL);
                WsbAffirmHr(pWorkItem->SetState(HSM_JOB_STATE_SKIPPED));
            } else if (pResource->NeedsRepair() == S_OK) {
                WsbAffirmHr(pResource->GetUserFriendlyName(&tmpString, 0));
                WsbLogEvent(JOB_MESSAGE_RESOURCE_NEEDS_REPAIR, 0, NULL, (OLECHAR*) tmpString, (OLECHAR*) m_name, NULL);
                WsbAffirmHr(pWorkItem->SetState(HSM_JOB_STATE_SKIPPED));
            } else if (HSM_JOB_STATE_SKIPPED == state) {
                WsbAffirmHr(pWorkItem->SetState(HSM_JOB_STATE_IDLE));
            }

            WsbAffirmHr(pWorkItem->GetState(&state));
            
            // Don't do anything for inactive resources.
            if (HSM_JOB_STATE_SKIPPED != state) {

                if (isRestart) {

                    // On a restart, all items need work to be done for them.
                    //
                    // NOTE: A null starting path means the root.
                    WsbAffirmHr(pWorkItem->SetState(HSM_JOB_STATE_IDLE));
                    WsbAffirmHr(pWorkItem->SetSubRunId(0));
                    WsbAffirmHr(pWorkItem->SetStartingPath(OLESTR("\\")));
                    WsbAffirmHr(pWorkItem->SetCurrentPath(OLESTR("\\")));

                    // Clear out the phases and session totals.
                    pCollect = 0;
                    WsbAffirmHr(pWorkItem->GetPhases(&pCollect));
                    WsbAffirmHr(pCollect->RemoveAllAndRelease());

                    pCollect = 0;
                    WsbAffirmHr(pWorkItem->GetTotals(&pCollect));
                    WsbAffirmHr(pCollect->RemoveAllAndRelease());

                } else {

                    // If we didn't finish it last time, then try it.
                    if ((HSM_JOB_STATE_DONE != state) && (HSM_JOB_STATE_FAILED != state)) {

                        WsbAffirmHr(pWorkItem->SetState(HSM_JOB_STATE_IDLE));
                        WsbAffirmHr(pWorkItem->SetSubRunId(0));

                        // If it was suspended, then begin where we left off. Otherwise,
                        // start from the beginning.
                        if (HSM_JOB_STATE_SUSPENDED == state) {
                            WsbAffirmHr(pWorkItem->GetCurrentPath(&currentPath, 0));
                        } else {
                            WsbAffirmHr(pWorkItem->SetCurrentPath(OLESTR("\\")));
                        }
                        WsbAffirmHr(pWorkItem->SetStartingPath(currentPath));
                        
                        // Clear out the phases and session totals.
                        pCollect = 0;
                        WsbAffirmHr(pWorkItem->GetPhases(&pCollect));
                        WsbAffirmHr(pCollect->RemoveAllAndRelease());

                        pCollect = 0;
                        WsbAffirmHr(pWorkItem->GetTotals(&pCollect));
                        WsbAffirmHr(pCollect->RemoveAllAndRelease());
                    }
                }
            }

            pResource = 0;
            pWorkItem = 0;
        }

        if (hr == WSB_E_NOTFOUND) {
            hr = S_OK;
        }

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmJob::WaitUntilDone(
    void
    )

/*++

Implements:

  IHsmJob::WaitUntilDone().

--*/
{
    HRESULT                             hr = S_OK;

    WsbTraceIn(OLESTR("CHsmJob::WaitUntilDone"), OLESTR(""));
    try {

        // For now, we are just going to be gross about this, and sit in a sleep loop
        // until the job finishes.
        // 
        // NOTE: We may want to do with events or something.
        while (m_isActive) {
            Sleep(5000);

            // Make sure the job gets restarted if it is suspended
            WsbAffirmHr(RestartSuspendedJobs());
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmJob::WaitUntilDone"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\job\hsmjobcx.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    hsmjobcx.cpp

Abstract:

    This class contains properties that defines the context in which the job
    should be run.

Author:

    Chuck Bardeen   [cbardeen]   29-Oct-1996

Revision History:

--*/

#include "stdafx.h"

#include "wsb.h"
#include "job.h"
#include "hsmjobcx.h"

#define WSB_TRACE_IS        WSB_TRACE_BIT_JOB

static USHORT iCount = 0;


HRESULT
CHsmJobContext::EnumResources(
    IWsbEnum** ppEnum
    )

/*++

Implements:

  IHsmJobContext::EnumResources().

--*/
{
    HRESULT     hr = S_OK;

    try {

        WsbAssert(0 != ppEnum, E_POINTER);
        WsbAffirmHr(m_pResources->Enum(ppEnum));

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmJobContext::FinalConstruct(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;
    
    WsbTraceIn(OLESTR("CHsmJobContext::FinalConstruct"), OLESTR(""));
    try {

        m_usesAllManaged = FALSE;

        //Create the Resources collection (with no items).
        WsbAffirmHr(CWsbObject::FinalConstruct());
        WsbAffirmHr(CoCreateInstance(CLSID_CWsbOrderedCollection, NULL, CLSCTX_ALL, IID_IWsbCollection, (void**) &m_pResources));

    } WsbCatch(hr);

    iCount++;
    WsbTraceOut(OLESTR("CHsmJobContext::FinalConstruct"), OLESTR("hr = <%ls>, Count is <%d>"),
        WsbHrAsString(hr), iCount);
    return(hr);
}


void
CHsmJobContext::FinalRelease(
    void
    )

/*++

Implements:

  CHsmJobContext::FinalRelease().

--*/
{
    
    WsbTraceIn(OLESTR("CHsmJobContext::FinalRelease"), OLESTR(""));
    
    CWsbObject::FinalRelease();
    iCount--;
    
    WsbTraceOut(OLESTR("CHsmJobContext:FinalRelease"), OLESTR("Count is <%d>"), iCount);
}

HRESULT
CHsmJobContext::GetClassID(
    OUT CLSID* pClsid
    )

/*++

Implements:

  IPersist::GetClassID().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmJobContext::GetClassID"), OLESTR(""));

    try {

        WsbAssert(0 != pClsid, E_POINTER);
        *pClsid = CLSID_CHsmJobContext;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmJobContext::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return(hr);
}


HRESULT
CHsmJobContext::GetSizeMax(
    OUT ULARGE_INTEGER* pSize
    )

/*++

Implements:

  IPersistStream::GetSizeMax().

--*/
{
    HRESULT                     hr = S_OK;
    CComPtr<IPersistStream>     pPersistStream;

    WsbTraceIn(OLESTR("CHsmJobContext::GetSizeMax"), OLESTR(""));

    try {

        WsbAffirmHr(m_pResources->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
        WsbAffirmHr(pPersistStream->GetSizeMax(pSize));

        pSize->QuadPart += WsbPersistSizeOf(BOOL);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmJobContext::GetSizeMax"), OLESTR("hr = <%ls>, Size = <%ls>"), WsbHrAsString(hr), WsbPtrToUliAsString(pSize));

    return(hr);
}


HRESULT
CHsmJobContext::Load(
    IN IStream* pStream
    )

/*++

Implements:

  IPersistStream::Load().

--*/
{
    HRESULT                     hr = S_OK;
    CComPtr<IPersistStream>     pPersistStream;

    WsbTraceIn(OLESTR("CHsmJobContext::Load"), OLESTR(""));

    try {

        WsbAssert(0 != pStream, E_POINTER);

        WsbLoadFromStream(pStream, &m_usesAllManaged);

        WsbAffirmHr(m_pResources->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
        WsbAffirmHr(pPersistStream->Load(pStream));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmJobContext::Load"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmJobContext::Resources(
    IWsbCollection** ppResources
    )

/*++

Implements:

  IHsmJobContext::Resources().

--*/
{
    HRESULT     hr = S_OK;

    try {

        WsbAssert(0 != ppResources, E_POINTER);
        *ppResources = m_pResources;
        m_pResources->AddRef();

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmJobContext::Save(
    IN IStream* pStream,
    IN BOOL clearDirty
    )

/*++

Implements:

  IPersistStream::Save().

--*/
{
    HRESULT                     hr = S_OK;
    CComPtr<IPersistStream>     pPersistStream;

    WsbTraceIn(OLESTR("CHsmJobContext::Save"), OLESTR("clearDirty = <%ls>"), WsbBoolAsString(clearDirty));
    
    try {

        WsbAssert(0 != pStream, E_POINTER);

        WsbSaveToStream(pStream, m_usesAllManaged);

        WsbAffirmHr(m_pResources->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
        WsbAffirmHr(pPersistStream->Save(pStream, clearDirty));

        // If we got it saved and we were asked to clear the dirty bit, then
        // do so now.
        if (clearDirty) {
            m_isDirty = FALSE;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmJobContext::Save"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmJobContext::Test(
    USHORT* passed,
    USHORT* failed
    )

/*++

Implements:

  IWsbTestable::Test().

--*/
{
    HRESULT     hr = S_OK;

    try {

        WsbAssert(0 != passed, E_POINTER);
        WsbAssert(0 != failed, E_POINTER);

        *passed = 0;
        *failed = 0;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmJobContext::SetUsesAllManaged(
    IN BOOL usesAllManaged
    )

/*++

Implements:

  IHsmJobContext::SetUsesAllManaged().

--*/
{
    m_usesAllManaged = usesAllManaged;

    return(S_OK);
}


HRESULT
CHsmJobContext::UsesAllManaged(
    void
    )

/*++

Implements:

  IHsmJobContext::UsesAllManaged().

--*/
{
    return(m_usesAllManaged ? S_OK : S_FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\job\hsmjobcx.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    hsmjobcx.cpp

Abstract:

    This class contains properties that defines the context in which the job
    should be run.

Author:

    Chuck Bardeen   [cbardeen]   29-Oct-1996

Revision History:

--*/

#include "resource.h"       // main symbols

#include "wsb.h"

#ifndef _HSMJOBCX_
#define _HSMJOBCX_

/*++

Class Name:
    
    CHsmJobContext

Class Description:

    This class contains properties that defines the context in which the job
    should be run.

--*/

class CHsmJobContext : 
    public CWsbObject,
    public IHsmJobContext,
    public CComCoClass<CHsmJobContext,&CLSID_CHsmJobContext>
{
public:
    CHsmJobContext() {}
BEGIN_COM_MAP(CHsmJobContext)
    COM_INTERFACE_ENTRY(IHsmJobContext)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IWsbCollectable)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_CHsmJobContext)

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);
    void FinalRelease(void);

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);

// IPersistStream
public:
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER* pSize);
    STDMETHOD(Load)(IStream* pStream);
    STDMETHOD(Save)(IStream* pStream, BOOL clearDirty);

// IWsbTestable
    STDMETHOD(Test)(USHORT *passed, USHORT* failed);

// IHsmJobContext
public:
    STDMETHOD(Resources)(IWsbCollection** ppResources);
    STDMETHOD(EnumResources)(IWsbEnum** ppEnum);
    STDMETHOD(SetUsesAllManaged)(BOOL usesAllManaged);
    STDMETHOD(UsesAllManaged)(void);

protected:
    CComPtr<IWsbCollection>     m_pResources;
    BOOL                        m_usesAllManaged;
};

#endif  // _HSMJOBCX_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\job\hsmjobdf.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    hsmjobcx.cpp

Abstract:

    This class contains properties that define the job, mainly the policies
    to be enacted by the job.

Author:

    Chuck Bardeen   [cbardeen]   29-Oct-1996

Revision History:

--*/

#include "stdafx.h"

#include "wsb.h"
#include "job.h"
#include "hsmjobdf.h"

#define WSB_TRACE_IS        WSB_TRACE_BIT_JOB


HRESULT
CHsmJobDef::EnumPolicies(
    IWsbEnum** ppEnum
    )

/*++

Implements:

  IHsmJobDef::EnumPolicies().

--*/
{
    HRESULT     hr = S_OK;

    try {

        WsbAssert(0 != ppEnum, E_POINTER);
        WsbAffirmHr(m_pPolicies->Enum(ppEnum));

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmJobDef::FinalConstruct(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;
    
    try {

        WsbAffirmHr(CWsbObject::FinalConstruct());

        m_skipHiddenItems = TRUE;
        m_skipSystemItems = TRUE;
        m_useRPIndex = FALSE;
        m_useDbIndex = FALSE;

        // Each instance should have its own unique identifier.
        WsbAffirmHr(CoCreateGuid(&m_id));

        //Create the Policies collection (with no items).
        WsbAffirmHr(CoCreateInstance(CLSID_CWsbOrderedCollection, NULL, CLSCTX_ALL, IID_IWsbCollection, (void**) &m_pPolicies));

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmJobDef::GetClassID(
    OUT CLSID* pClsid
    )

/*++

Implements:

  IPersist::GetClassID().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmJobDef::GetClassID"), OLESTR(""));

    try {

        WsbAssert(0 != pClsid, E_POINTER);
        *pClsid = CLSID_CHsmJobDef;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmJobDef::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return(hr);
}


HRESULT
CHsmJobDef::GetIdentifier(
    GUID* pId
    )

/*++

Implements:

  IHsmJobDef::GetIdentifier().

--*/
{
    HRESULT                     hr = S_OK;

    try {

        WsbAssert(0 != pId, E_POINTER);
        *pId = m_id;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmJobDef::GetName(
    OLECHAR** pName,
    ULONG bufferSize
    )

/*++

Implements:

  IHsmJobDef::GetName().

--*/
{
    HRESULT                     hr = S_OK;

    try {

        WsbAssert(0 != pName, E_POINTER);
        WsbAffirmHr(m_name.CopyTo(pName, bufferSize));

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmJobDef::GetPostActionOnResource(
    OUT IHsmActionOnResourcePost** ppAction
    )

/*++

Implements:

  IHsmJobDef::GetPostActionOnResource().

--*/
{
    HRESULT                     hr = S_OK;

    try {

        WsbAssertPointer(ppAction);
        *ppAction = m_pActionResourcePost;
        if (m_pActionResourcePost) {
            m_pActionResourcePost->AddRef();
        }

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmJobDef::GetPreActionOnResource(
    OUT IHsmActionOnResourcePre** ppAction
    )

/*++

Implements:

  IHsmJobDef::GetPreActionOnResource().

--*/
{
    HRESULT                     hr = S_OK;

    try {

        WsbAssertPointer(ppAction);
        *ppAction = m_pActionResourcePre;
        if (m_pActionResourcePre) {
            m_pActionResourcePre->AddRef();
        }

    } WsbCatch(hr);

    return(hr);
}

HRESULT
CHsmJobDef::GetPreScanActionOnResource(
    OUT IHsmActionOnResourcePreScan** ppAction
    )

/*++

Implements:

  IHsmJobDef::GetPreScanActionOnResource().

--*/
{
    HRESULT                     hr = S_OK;

    try {

        WsbAssertPointer(ppAction);
        *ppAction = m_pActionResourcePreScan;
        if (m_pActionResourcePreScan) {
            m_pActionResourcePreScan->AddRef();
        }

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmJobDef::GetSizeMax(
    OUT ULARGE_INTEGER* pSize
    )

/*++

Implements:

  IPersistStream::GetSizeMax().

--*/
{
    HRESULT                     hr = S_OK;
    CComPtr<IPersistStream>     pPersistStream;
    ULARGE_INTEGER              entrySize;

    WsbTraceIn(OLESTR("CHsmJobDef::GetSizeMax"), OLESTR(""));

    try {

        pSize->QuadPart = WsbPersistSizeOf(GUID) + 2 * WsbPersistSizeOf(BOOL) + WsbPersistSizeOf(ULONG) + WsbPersistSize((wcslen(m_name) + 1) * sizeof(OLECHAR));

        WsbAffirmHr(m_pPolicies->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
        WsbAffirmHr(pPersistStream->GetSizeMax(&entrySize));
        pPersistStream = 0;
        pSize->QuadPart += entrySize.QuadPart;

        WsbAffirmHr(m_pPolicies->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
        WsbAffirmHr(pPersistStream->GetSizeMax(&entrySize));
        pPersistStream = 0;
        pSize->QuadPart += entrySize.QuadPart;


    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmJobDef::GetSizeMax"), OLESTR("hr = <%ls>, Size = <%ls>"), WsbHrAsString(hr), WsbPtrToUliAsString(pSize));

    return(hr);
}


HRESULT
CHsmJobDef::InitAs(
    IN OLECHAR* name,
    IN HSM_JOB_DEF_TYPE type,
    IN GUID storagePool,
    IN IHsmServer* pServer,
    IN BOOL isUserDefined
    )

/*++

Implements:

  IHsmJobDef::InitAs().

--*/
{
    HRESULT                         hr = S_OK;
    CComPtr<IHsmJobContext>         pContext;
    CComPtr<IHsmPolicy>             pPolicy;
    CComPtr<IHsmRule>               pRule;
    CComPtr<IHsmCriteria>           pCriteria;
    CComPtr<IHsmAction>             pAction;
    CComPtr<IHsmDirectedAction>     pDirectedAction;
    CComPtr<IWsbGuid>               pGuid;
    CComPtr<IWsbCollection>         pRulesCollection;
    CComPtr<IWsbCollection>         pCriteriaCollection;
    CComPtr<IWsbCreateLocalObject>  pCreateObj;

    WsbTraceIn(OLESTR("CHsmJobDef::InitAs"), OLESTR("name = <%ls>, type = %ld"), 
            name, static_cast<LONG>(type));

    try {

        WsbAssert(0 != name, E_POINTER);

        // All objects created need to be owned by the engine.
        WsbAffirmHr(pServer->QueryInterface(IID_IWsbCreateLocalObject, (void**) &pCreateObj));

        // All types will need a policy and at least one rule.
        WsbAffirmHr(pCreateObj->CreateInstance(CLSID_CHsmPolicy, IID_IHsmPolicy, (void**) &pPolicy));
        WsbAffirmHr(pPolicy->SetName(name));
        WsbAffirmHr(pPolicy->Rules(&pRulesCollection));
        WsbAffirmHr(m_pPolicies->Add(pPolicy));

        WsbAffirmHr(pCreateObj->CreateInstance(CLSID_CHsmRule, IID_IHsmRule, (void**) &pRule));
        WsbAffirmHr(pRule->SetIsInclude(TRUE));
        WsbAffirmHr(pRule->SetIsUserDefined(isUserDefined));
        WsbAffirmHr(pRule->SetIsUsedInSubDirs(TRUE));
        WsbAffirmHr(pRule->SetName(OLESTR("*")));
        WsbAffirmHr(pRule->SetPath(OLESTR("\\")));
        WsbAffirmHr(pRule->Criteria(&pCriteriaCollection));
        WsbAffirmHr(pRulesCollection->Add(pRule));

        // The criteria and the action vary upon the job type.
        switch(type) {
            case HSM_JOB_DEF_TYPE_MANAGE:
                WsbAffirmHr(pCreateObj->CreateInstance(CLSID_CHsmActionManage, IID_IHsmAction, (void**) &pAction));
                WsbAffirmHr(pAction->QueryInterface(IID_IHsmDirectedAction, (void**) &pDirectedAction));
                WsbAffirmHr(pDirectedAction->SetStoragePoolId(storagePool));
                WsbAffirmHr(pPolicy->SetAction(pAction));
                WsbAffirmHr(pPolicy->SetUsesDefaultRules(TRUE));

                WsbAffirmHr(pCreateObj->CreateInstance(CLSID_CHsmCritManageable, IID_IHsmCriteria, (void**) &pCriteria));
                WsbAffirmHr(pCriteria->SetIsNegated(FALSE));
                WsbAffirmHr(pCriteriaCollection->Add(pCriteria));
                break;

            case HSM_JOB_DEF_TYPE_RECALL:
                WsbAffirmHr(pCreateObj->CreateInstance(CLSID_CHsmActionRecall, IID_IHsmAction, (void**) &pAction));
                WsbAffirmHr(pPolicy->SetAction(pAction));
                WsbAffirmHr(pPolicy->SetUsesDefaultRules(FALSE));

                WsbAffirmHr(pCreateObj->CreateInstance(CLSID_CHsmCritMigrated, IID_IHsmCriteria, (void**) &pCriteria));
                WsbAffirmHr(pCriteria->SetIsNegated(FALSE));
                WsbAffirmHr(pCriteriaCollection->Add(pCriteria));
                break;

            case HSM_JOB_DEF_TYPE_TRUNCATE:
                WsbAffirmHr(pCreateObj->CreateInstance(CLSID_CHsmActionTruncate, IID_IHsmAction, (void**) &pAction));
                WsbAffirmHr(pPolicy->SetAction(pAction));
                WsbAffirmHr(pPolicy->SetUsesDefaultRules(FALSE));

                WsbAffirmHr(pCreateObj->CreateInstance(CLSID_CHsmCritPremigrated, IID_IHsmCriteria, (void**) &pCriteria));
                WsbAffirmHr(pCriteria->SetIsNegated(FALSE));
                WsbAffirmHr(pCriteriaCollection->Add(pCriteria));
                break;

            case HSM_JOB_DEF_TYPE_UNMANAGE:
                m_useRPIndex = TRUE;
                WsbAffirmHr(pCreateObj->CreateInstance(CLSID_CHsmActionUnmanage, IID_IHsmAction, (void**) &pAction));
                WsbAffirmHr(pPolicy->SetAction(pAction));
                WsbAffirmHr(pPolicy->SetUsesDefaultRules(FALSE));

                WsbAffirmHr(pCreateObj->CreateInstance(CLSID_CHsmCritPremigrated, IID_IHsmCriteria, (void**) &pCriteria));
                WsbAffirmHr(pCriteria->SetIsNegated(FALSE));
                WsbAffirmHr(pCriteriaCollection->Add(pCriteria));
                pCriteria = 0;
                pCriteriaCollection = 0;
                pRule = 0;

                //  Add an addition rule
                WsbAffirmHr(pCreateObj->CreateInstance(CLSID_CHsmRule, IID_IHsmRule, (void**) &pRule));
                WsbAffirmHr(pRule->SetIsInclude(TRUE));
                WsbAffirmHr(pRule->SetIsUserDefined(isUserDefined));
                WsbAffirmHr(pRule->SetIsUsedInSubDirs(TRUE));
                WsbAffirmHr(pRule->SetName(OLESTR("*")));
                WsbAffirmHr(pRule->SetPath(OLESTR("\\")));
                WsbAffirmHr(pRule->Criteria(&pCriteriaCollection));
                WsbAffirmHr(pRulesCollection->Add(pRule));

                WsbAffirmHr(pCreateObj->CreateInstance(CLSID_CHsmCritMigrated, IID_IHsmCriteria, (void**) &pCriteria));
                WsbAffirmHr(pCriteria->SetIsNegated(FALSE));
                WsbAffirmHr(pCriteriaCollection->Add(pCriteria));
                break;

            case HSM_JOB_DEF_TYPE_FULL_UNMANAGE:
                m_useRPIndex = TRUE;
                WsbAffirmHr(pCreateObj->CreateInstance(CLSID_CHsmActionUnmanage, IID_IHsmAction, (void**) &pAction));
                WsbAffirmHr(pPolicy->SetAction(pAction));
                WsbAffirmHr(pPolicy->SetUsesDefaultRules(FALSE));

                WsbAffirmHr(pCreateObj->CreateInstance(CLSID_CHsmCritPremigrated, IID_IHsmCriteria, (void**) &pCriteria));
                WsbAffirmHr(pCriteria->SetIsNegated(FALSE));
                WsbAffirmHr(pCriteriaCollection->Add(pCriteria));
                pCriteria = 0;
                pCriteriaCollection = 0;
                pRule = 0;

                //  Add an addition rule
                WsbAffirmHr(pCreateObj->CreateInstance(CLSID_CHsmRule, IID_IHsmRule, (void**) &pRule));
                WsbAffirmHr(pRule->SetIsInclude(TRUE));
                WsbAffirmHr(pRule->SetIsUserDefined(isUserDefined));
                WsbAffirmHr(pRule->SetIsUsedInSubDirs(TRUE));
                WsbAffirmHr(pRule->SetName(OLESTR("*")));
                WsbAffirmHr(pRule->SetPath(OLESTR("\\")));
                WsbAffirmHr(pRule->Criteria(&pCriteriaCollection));
                WsbAffirmHr(pRulesCollection->Add(pRule));

                WsbAffirmHr(pCreateObj->CreateInstance(CLSID_CHsmCritMigrated, IID_IHsmCriteria, (void**) &pCriteria));
                WsbAffirmHr(pCriteria->SetIsNegated(FALSE));
                WsbAffirmHr(pCriteriaCollection->Add(pCriteria));

                //  When done, remove the volume from management
                WsbAffirmHr(pCreateObj->CreateInstance(CLSID_CHsmActionOnResourcePostUnmanage,
                        IID_IHsmActionOnResourcePost, (void**) &m_pActionResourcePost));
                //  When starting, mark the resource as DeletePending
                WsbAffirmHr(pCreateObj->CreateInstance(CLSID_CHsmActionOnResourcePreUnmanage,
                        IID_IHsmActionOnResourcePre, (void**) &m_pActionResourcePre));
                break;

            case HSM_JOB_DEF_TYPE_QUICK_UNMANAGE:
                m_useRPIndex = TRUE;
                WsbAffirmHr(pCreateObj->CreateInstance(CLSID_CHsmActionUnmanage, IID_IHsmAction, (void**) &pAction));
                WsbAffirmHr(pPolicy->SetAction(pAction));
                WsbAffirmHr(pPolicy->SetUsesDefaultRules(FALSE));

                WsbAffirmHr(pCreateObj->CreateInstance(CLSID_CHsmCritPremigrated, IID_IHsmCriteria, (void**) &pCriteria));
                WsbAffirmHr(pCriteria->SetIsNegated(FALSE));
                WsbAffirmHr(pCriteriaCollection->Add(pCriteria));

                //  Clean out pointers so we can create more stuff
                pPolicy.Release();
                pAction.Release();
                pRulesCollection.Release();
                pCriteria.Release();
                pCriteriaCollection.Release();
                pRule.Release();


                //  Create a new policy for job to do the delete
                WsbAffirmHr(pCreateObj->CreateInstance(CLSID_CHsmPolicy, IID_IHsmPolicy, (void**) &pPolicy));
                WsbAffirmHr(pPolicy->SetName(name));
                WsbAffirmHr(pPolicy->Rules(&pRulesCollection));
                WsbAffirmHr(m_pPolicies->Add(pPolicy));

                WsbAffirmHr(pCreateObj->CreateInstance(CLSID_CHsmActionDelete, IID_IHsmAction, (void**) &pAction));
                WsbAffirmHr(pPolicy->SetAction(pAction));
                WsbAffirmHr(pPolicy->SetUsesDefaultRules(FALSE));

                //  Add an addition rule
                WsbAffirmHr(pCreateObj->CreateInstance(CLSID_CHsmRule, IID_IHsmRule, (void**) &pRule));
                WsbAffirmHr(pRule->SetIsInclude(TRUE));
                WsbAffirmHr(pRule->SetIsUserDefined(isUserDefined));
                WsbAffirmHr(pRule->SetIsUsedInSubDirs(TRUE));
                WsbAffirmHr(pRule->SetName(OLESTR("*")));
                WsbAffirmHr(pRule->SetPath(OLESTR("\\")));
                WsbAffirmHr(pRule->Criteria(&pCriteriaCollection));
                WsbAffirmHr(pRulesCollection->Add(pRule));

                WsbAffirmHr(pCreateObj->CreateInstance(CLSID_CHsmCritMigrated, IID_IHsmCriteria, (void**) &pCriteria));
                WsbAffirmHr(pCriteria->SetIsNegated(FALSE));
                WsbAffirmHr(pCriteriaCollection->Add(pCriteria));

                //  When done, remove the volume from management
                WsbAffirmHr(pCreateObj->CreateInstance(CLSID_CHsmActionOnResourcePostUnmanage,
                        IID_IHsmActionOnResourcePost, (void**) &m_pActionResourcePost));
                //  When starting, mark the resource as DeletePending
                WsbAffirmHr(pCreateObj->CreateInstance(CLSID_CHsmActionOnResourcePreUnmanage,
                        IID_IHsmActionOnResourcePre, (void**) &m_pActionResourcePre));
                break;

            case HSM_JOB_DEF_TYPE_VALIDATE:
                m_useRPIndex = TRUE;
                WsbAffirmHr(pCreateObj->CreateInstance(CLSID_CHsmActionValidate, IID_IHsmAction, (void**) &pAction));
                WsbAffirmHr(pPolicy->SetAction(pAction));
                WsbAffirmHr(pPolicy->SetUsesDefaultRules(FALSE));

                WsbAffirmHr(pCreateObj->CreateInstance(CLSID_CHsmCritPremigrated, IID_IHsmCriteria, (void**) &pCriteria));
                WsbAffirmHr(pCriteria->SetIsNegated(FALSE));
                WsbAffirmHr(pCriteriaCollection->Add(pCriteria));
                pCriteria = 0;
                pCriteriaCollection = 0;
                pRule = 0;

                //  Add an addition rule
                WsbAffirmHr(pCreateObj->CreateInstance(CLSID_CHsmRule, IID_IHsmRule, (void**) &pRule));
                WsbAffirmHr(pRule->SetIsInclude(TRUE));
                WsbAffirmHr(pRule->SetIsUserDefined(isUserDefined));
                WsbAffirmHr(pRule->SetIsUsedInSubDirs(TRUE));
                WsbAffirmHr(pRule->SetName(OLESTR("*")));
                WsbAffirmHr(pRule->SetPath(OLESTR("\\")));
                WsbAffirmHr(pRule->Criteria(&pCriteriaCollection));
                WsbAffirmHr(pRulesCollection->Add(pRule));

                WsbAffirmHr(pCreateObj->CreateInstance(CLSID_CHsmCritMigrated, IID_IHsmCriteria, (void**) &pCriteria));
                WsbAffirmHr(pCriteria->SetIsNegated(FALSE));
                WsbAffirmHr(pCriteriaCollection->Add(pCriteria));

                //  Add pre & post actions on resources
                WsbAffirmHr(pCreateObj->CreateInstance(CLSID_CHsmActionOnResourcePreValidate,
                        IID_IHsmActionOnResourcePre, (void**) &m_pActionResourcePre));
                WsbAffirmHr(pCreateObj->CreateInstance(CLSID_CHsmActionOnResourcePostValidate,
                        IID_IHsmActionOnResourcePost, (void**) &m_pActionResourcePost));
                WsbTrace(OLESTR("CHsmJobDef::InitAs(Validate): m_pActionResourcePre = %lx, m_pActionResourcePost = %lx\n"),
                    static_cast<void*>(m_pActionResourcePre), static_cast<void*>(m_pActionResourcePost));
        break;


        }

        // There are a couple of other fields to fill out in the job definition
        m_name = name;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmJobDef::InitAs"), OLESTR("hr = <%ls>"), 
            WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmJobDef::Load(
    IN IStream* pStream
    )

/*++

Implements:

  IPersistStream::Load().

--*/
{
    BOOL                        hasA;
    HRESULT                     hr = S_OK;
    CComPtr<IPersistStream>     pPersistStream;

    WsbTraceIn(OLESTR("CHsmJobDef::Load"), OLESTR(""));

    try {

        WsbAssert(0 != pStream, E_POINTER);

        WsbLoadFromStream(pStream, &m_id);
        WsbLoadFromStream(pStream, &m_name, 0);
        WsbLoadFromStream(pStream, &m_skipHiddenItems);
        WsbLoadFromStream(pStream, &m_skipSystemItems);
        WsbLoadFromStream(pStream, &m_useRPIndex);

        WsbAffirmHr(m_pPolicies->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
        WsbAffirmHr(pPersistStream->Load(pStream));

        // Is there a pre-scan resource action?
        WsbAffirmHr(WsbLoadFromStream(pStream, &hasA));
        if (hasA) {
            WsbAffirmHr(OleLoadFromStream(pStream, IID_IHsmActionOnResourcePre, 
                    (void**) &m_pActionResourcePre));
        }

        // Is there a post-scan resource action?
        WsbAffirmHr(WsbLoadFromStream(pStream, &hasA));
        if (hasA) {
            WsbAffirmHr(OleLoadFromStream(pStream, IID_IHsmActionOnResourcePost, 
                    (void**) &m_pActionResourcePost));
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmJobDef::Load"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmJobDef::Policies(
    IWsbCollection** ppPolicies
    )

/*++

Implements:

  IHsmJobDef::Policies().

--*/
{
    HRESULT     hr = S_OK;

    try {

        WsbAssert(0 != ppPolicies, E_POINTER);
        *ppPolicies = m_pPolicies;
        m_pPolicies->AddRef();

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmJobDef::Save(
    IN IStream* pStream,
    IN BOOL clearDirty
    )

/*++

Implements:

  IPersistStream::Save().

--*/
{
    BOOL                        hasA;
    HRESULT                     hr = S_OK;
    CComPtr<IPersistStream>     pPersistStream;

    WsbTraceIn(OLESTR("CHsmJobDef::Save"), OLESTR("clearDirty = <%ls>"), WsbBoolAsString(clearDirty));
    
    try {

        WsbAssert(0 != pStream, E_POINTER);

        WsbSaveToStream(pStream, m_id);
        WsbSaveToStream(pStream, m_name);
        WsbSaveToStream(pStream, m_skipHiddenItems);
        WsbSaveToStream(pStream, m_skipSystemItems);
        WsbSaveToStream(pStream, m_useRPIndex);
        
        WsbAffirmHr(m_pPolicies->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
        WsbAffirmHr(pPersistStream->Save(pStream, clearDirty));
        pPersistStream = 0;

        //  Save pre-scan resource action if present        
        WsbTrace(OLESTR("CHsmJobDef::Save: m_pActionResourcePre = %lx, m_pActionResourcePost = %lx\n"),
                static_cast<void*>(m_pActionResourcePre), static_cast<void*>(m_pActionResourcePost));
        if (m_pActionResourcePre) {
            hasA = TRUE;
            WsbSaveToStream(pStream, hasA);
            WsbAffirmHr(m_pActionResourcePre->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
            WsbAffirmHr(OleSaveToStream(pPersistStream, pStream));
            pPersistStream = 0;
        } else {
            hasA = FALSE;
            WsbSaveToStream(pStream, hasA);
        }

        //  Save post-scan resource action if present       
        if (m_pActionResourcePost) {
            hasA = TRUE;
            WsbSaveToStream(pStream, hasA);
            WsbAffirmHr(m_pActionResourcePost->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
            WsbAffirmHr(OleSaveToStream(pPersistStream, pStream));
            pPersistStream = 0;
        } else {
            hasA = FALSE;
            WsbSaveToStream(pStream, hasA);
        }

        // If we got it saved and we were asked to clear the dirty bit, then
        // do so now.
        if (clearDirty) {
            m_isDirty = FALSE;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmJobDef::Save"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmJobDef::SetName(
    OLECHAR* name
    )

/*++

Implements:

  IHsmJobDef::SetName().

--*/
{
    HRESULT                     hr = S_OK;

    try {

        m_name = name;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmJobDef::SetPostActionOnResource(
    IN IHsmActionOnResourcePost* pAction
    )

/*++

Implements:

  IHsmJobDef::SetPostActionOnResource

--*/
{
    m_pActionResourcePost = pAction;

    return(S_OK);
}


HRESULT
CHsmJobDef::SetPreActionOnResource(
    IN IHsmActionOnResourcePre* pAction
    )

/*++

Implements:

  IHsmJobDef::SetPreActionOnResource

--*/
{
    m_pActionResourcePre = pAction;

    return(S_OK);
}

HRESULT
CHsmJobDef::SetPreScanActionOnResource(
    IN IHsmActionOnResourcePreScan* pAction
    )

/*++

Implements:

  IHsmJobDef::SetPreScanActionOnResource

--*/
{
    m_pActionResourcePreScan = pAction;

    return(S_OK);
}


HRESULT
CHsmJobDef::SkipHiddenItems(
    void
    )

/*++

Implements:

  IHsmJobDef::SkipHiddenItems().

--*/
{
    return(m_skipHiddenItems ? S_OK : S_FALSE);
}


HRESULT
CHsmJobDef::SkipSystemItems(
    void
    )

/*++

Implements:

  IHsmJobDef::SkipSystemItems().

--*/
{
    return(m_skipSystemItems ? S_OK : S_FALSE);
}


HRESULT
CHsmJobDef::SetSkipHiddenItems(
    IN BOOL shouldSkip
    )

/*++

Implements:

  IHsmJobDef::SetSkipHiddenItems().

--*/
{
    m_skipHiddenItems = shouldSkip;

    return(S_OK);
}


HRESULT
CHsmJobDef::SetSkipSystemItems(
    IN BOOL shouldSkip
    )

/*++

Implements:

  IHsmJobDef::SetSkipSytemItems().

--*/
{
    m_skipSystemItems = shouldSkip;

    return(S_OK);
}


HRESULT
CHsmJobDef::SetUseRPIndex(
    IN BOOL useRPIndex
    )

/*++

Implements:

  IHsmJobDef::SetUseRPIndex().

--*/
{
    m_useRPIndex = useRPIndex;

    return(S_OK);
}

HRESULT
CHsmJobDef::SetUseDbIndex(
    IN BOOL useIndex
    )

/*++

Implements:

  IHsmJobDef::SetUseRPIndex().

--*/
{
    m_useDbIndex = useIndex;

    return(S_OK);
}


HRESULT
CHsmJobDef::Test(
    USHORT* passed,
    USHORT* failed
    )

/*++

Implements:

  IWsbTestable::Test().

--*/
{
    HRESULT     hr = S_OK;

    try {

        WsbAssert(0 != passed, E_POINTER);
        WsbAssert(0 != failed, E_POINTER);

        *passed = 0;
        *failed = 0;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmJobDef::UseRPIndex(
    void
    )

/*++

Implements:

  IHsmJobDef::UseRPIndex().

--*/
{
    return(m_useRPIndex ? S_OK : S_FALSE);
}

HRESULT
CHsmJobDef::UseDbIndex(
    void
    )

/*++

Implements:

  IHsmJobDef::UseDbIndex().

--*/
{
    return(m_useDbIndex ? S_OK : S_FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\job\hsmjobdf.h ===
#ifndef _HSMJOBDF_
#define _HSMJOBDF_

/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    hsmjobcx.cpp

Abstract:

    This class contains properties that define the job, mainly the policies
    to be enacted by the job.

Author:

    Chuck Bardeen   [cbardeen]   29-Oct-1996

Revision History:

--*/

#include "resource.h"       // main symbols

#include "wsb.h"
#include "fsa.h"
#include "job.h"
#include "hsmeng.h"


/*++

Class Name:
    
    CHsmJobDef

Class Description:

    This class contains properties that define the job, mainly the policies
    to be enacted by the job.

--*/

class CHsmJobDef : 
    public CWsbObject,
    public IHsmJobDef,
    public CComCoClass<CHsmJobDef,&CLSID_CHsmJobDef>
{
public:
    CHsmJobDef() {}
BEGIN_COM_MAP(CHsmJobDef)
    COM_INTERFACE_ENTRY(IHsmJobDef)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IWsbCollectable)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_CHsmJobDef)

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);

// IPersistStream
public:
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER* pSize);
    STDMETHOD(Load)(IStream* pStream);
    STDMETHOD(Save)(IStream* pStream, BOOL clearDirty);

// IWsbTestable
    STDMETHOD(Test)(USHORT *passed, USHORT* failed);

// IHsmJobDef
public:
    STDMETHOD(EnumPolicies)(IWsbEnum** ppEnum);
    STDMETHOD(GetIdentifier)(GUID* pId);
    STDMETHOD(GetName)(OLECHAR** pName, ULONG bufferSize);
    STDMETHOD(GetPostActionOnResource)(IHsmActionOnResourcePost** ppAction);
    STDMETHOD(GetPreActionOnResource)(IHsmActionOnResourcePre** ppAction);
    STDMETHOD(GetPreScanActionOnResource)(IHsmActionOnResourcePreScan** ppAction);
    STDMETHOD(InitAs)(OLECHAR* name, HSM_JOB_DEF_TYPE type, GUID storagePool, IHsmServer* pServer, BOOL isUserDefined);
    STDMETHOD(Policies)(IWsbCollection** ppPolicies);
    STDMETHOD(SetName)(OLECHAR* szName);
    STDMETHOD(SetPostActionOnResource)(IHsmActionOnResourcePost* pAction);
    STDMETHOD(SetPreActionOnResource)(IHsmActionOnResourcePre* pAction);
    STDMETHOD(SetPreScanActionOnResource)(IHsmActionOnResourcePreScan* pAction);
    STDMETHOD(SetSkipHiddenItems)(BOOL shouldSkip);
    STDMETHOD(SetSkipSystemItems)(BOOL shouldSkip);
    STDMETHOD(SetUseRPIndex)(BOOL useIndex);
    STDMETHOD(SetUseDbIndex)(BOOL useIndex);
    STDMETHOD(SkipHiddenItems)(void);
    STDMETHOD(SkipSystemItems)(void);
    STDMETHOD(UseRPIndex)(void);
    STDMETHOD(UseDbIndex)(void);

protected:
    GUID                    m_id;
    CWsbStringPtr           m_name;
    BOOL                    m_skipHiddenItems;
    BOOL                    m_skipSystemItems;
    BOOL                    m_useRPIndex;                       // Scan should use Reparse Point Index
    BOOL                    m_useDbIndex;                       // Scan should use Db Index
    CComPtr<IWsbCollection> m_pPolicies;
    CComPtr<IHsmActionOnResourcePre>        m_pActionResourcePre;     // Can be NULL
    CComPtr<IHsmActionOnResourcePreScan>    m_pActionResourcePreScan; // Can be NULL
    CComPtr<IHsmActionOnResourcePost>       m_pActionResourcePost;    // Can be NULL
};

#endif // _HSMJOBDF_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\job\hsmjobwi.h ===
#ifndef _HSMJOBWI_
#define _HSMJOBWI_

/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    hsmjobwi.h

Abstract:

    This component represents a resource that will is/was operated on by a job.

Author:

    Chuck Bardeen   [cbardeen]   09-Feb-1996

Revision History:

--*/

#include "resource.h"       // main symbols

#include "wsb.h"


/*++

Class Name:
    
    CHsmJobWorkItem

Class Description:

    This component represents a resource that will is/was operated on by a job.

--*/

class CHsmJobWorkItem : 
    public IHsmJobWorkItem,
    public IHsmJobWorkItemPriv,
    public IHsmSessionSinkEveryState,
    public CWsbObject,
    public CComCoClass<CHsmJobWorkItem,&CLSID_CHsmJobWorkItem>
{
public:
    CHsmJobWorkItem() {}
BEGIN_COM_MAP(CHsmJobWorkItem)
    COM_INTERFACE_ENTRY(IHsmJobWorkItem)
    COM_INTERFACE_ENTRY(IHsmJobWorkItemPriv)
    COM_INTERFACE_ENTRY(IHsmSessionSinkEveryState)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IWsbCollectable)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_CHsmJobWorkItem)

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);
    void FinalRelease(void);

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);

// IPersistStream
public:
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER* pSize);
    STDMETHOD(Load)(IStream* pStream);
    STDMETHOD(Save)(IStream* pStream, BOOL clearDirty);

// IWsbCollectable
public:
    STDMETHOD(CompareTo)(IUnknown* pUnknown, SHORT* pResult);

// IWsbTestable
    STDMETHOD(Test)(USHORT *passed, USHORT* failed);

// IHsmSessionSinkEveryState
public:
    STDMETHOD(ProcessSessionState)(IHsmSession* pSession, IHsmPhase* pPhase, OLECHAR* currentPath);

// IHsmJobWorkItem
public:
    STDMETHOD(CompareToResourceId)(GUID id, SHORT* pResult);
    STDMETHOD(CompareToIWorkItem)(IHsmJobWorkItem* pWorkItem, SHORT* pResult);
    STDMETHOD(DoPostScan)(void);
    STDMETHOD(DoPreScan)(void);
    STDMETHOD(EnumPhases)(IWsbEnum** ppEnum);
    STDMETHOD(EnumTotals)(IWsbEnum** ppEnum);
    STDMETHOD(GetCurrentPath)(OLECHAR** pString, ULONG bufferSize);
    STDMETHOD(GetFinishTime)(FILETIME* pTime);
    STDMETHOD(GetResourceId)(GUID* pId);
    STDMETHOD(GetSession)(IHsmSession** ppSession);
    STDMETHOD(GetStartingPath)(OLECHAR** pString, ULONG bufferSize);
    STDMETHOD(GetStartTime)(FILETIME* pTime);
    STDMETHOD(GetState)(HSM_JOB_STATE* pState);
    STDMETHOD(GetStateAsString)(OLECHAR** pName, ULONG bufferSize);
    STDMETHOD(GetSubRunId)(ULONG* pId);

// IHsmJobWorkItemPriv
public:
    STDMETHOD(GetCookie)(DWORD* pCookie);
    STDMETHOD(GetPhases)(IWsbCollection** pPhases);
    STDMETHOD(GetTotals)(IWsbCollection** pTotals);
    STDMETHOD(Init)(IHsmJob* pJob);
    STDMETHOD(SetCookie)(DWORD cookie);
    STDMETHOD(SetCurrentPath)(OLECHAR* string);
    STDMETHOD(SetFinishTime)(FILETIME time);
    STDMETHOD(SetResourceId)(GUID id);
    STDMETHOD(SetSession)(IHsmSession* pSession);
    STDMETHOD(SetStartingPath)(OLECHAR* string);
    STDMETHOD(SetStartTime)(FILETIME time);
    STDMETHOD(SetState)(HSM_JOB_STATE state);
    STDMETHOD(SetSubRunId)(ULONG id);
    STDMETHOD(IsActiveItem)(void);
    STDMETHOD(SetActiveItem)(BOOL bActive);

protected:
    DWORD                   m_cookie;
    CWsbStringPtr           m_currentPath;
    FILETIME                m_finishTime;
    GUID                    m_resourceId;
    CWsbStringPtr           m_startingPath;
    FILETIME                m_startTime;
    HSM_JOB_STATE           m_state;
    ULONG                   m_subRunId;
    CComPtr<IHsmSession>    m_pSession;
    IHsmJob*                m_pJob;         // Parent Pointer, Weak Reference
    CComPtr<IWsbCollection> m_pPhases;
    CComPtr<IWsbCollection> m_pTotals;
    BOOL                    m_bActive;       // specifies whether this item is active (started)
};

#endif // _HSMJOBWI_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\job\hsmphase.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    hsmsesst.cpp

Abstract:

    This class is the phase component, which keeps track the status/totals for a phase of a
    session.

Author:

    Chuck Bardeen   [cbardeen]   14-Feb-1997

Revision History:

--*/

#include "stdafx.h"

#include "wsb.h"
#include "job.h"
#include "hsmphase.h"

#define WSB_TRACE_IS        WSB_TRACE_BIT_JOB

static USHORT iCount = 0;


HRESULT
CHsmPhase::AddItem(
    IN IFsaScanItem* pItem,
    IN HRESULT hrItem
    )

/*++

Implements:

  IHsmPhasePriv::AddItem().

--*/
{
    HRESULT                 hr = S_OK;
    LONGLONG                size;

    WsbTraceIn(OLESTR("CHsmPhase::AddItem"), OLESTR(""));
    
    try {

        // Did they give us a valid item to compare to?
        WsbAssert(0 != pItem, E_POINTER);

        // Get the size of the file.
        WsbAffirmHr(pItem->GetLogicalSize(&size));

        // Update the appropriate stats.
        switch (hrItem) {
            case S_OK:
                m_items++;
                m_size += size;
                break;
            case S_FALSE:
            case JOB_E_FILEEXCLUDED:
            case JOB_E_DOESNTMATCH:
            case FSA_E_REPARSE_NOT_WRITTEN_FILE_CHANGED:
            case HSM_E_FILE_CHANGED:
                m_skippedItems++;
                m_skippedSize += size;
                break;
            default:
                m_errorItems++;
                m_errorSize += size;
                break;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmPhase::AddItem"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmPhase::Clone(
    OUT IHsmPhase** ppPhase
    )

/*++

Implements:

  IHsmPhase::Clone().

--*/
{
    HRESULT                 hr = S_OK;
    CComPtr<IHsmPhase>      pPhase;

    WsbTraceIn(OLESTR("CHsmPhase::Clone"), OLESTR(""));
    
    try {

        // Did they give us a valid item?
        WsbAssert(0 != ppPhase, E_POINTER);
        *ppPhase = 0;

        // Create the new instance.
        WsbAffirmHr(CoCreateInstance(CLSID_CHsmPhase, 0, CLSCTX_ALL, IID_IHsmPhase, (void**) &pPhase));

        // Fill it in with the new values.
        WsbAffirmHr(CopyTo(pPhase));

        // Return it to the caller.
        *ppPhase = pPhase;
        pPhase->AddRef();

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmPhase::Clone"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmPhase::Clone(
    OUT IHsmPhasePriv** ppPhasePriv
    )

/*++

Implements:

  IHsmPhasePriv::Clone().

--*/
{
    HRESULT                 hr = S_OK;
    CComPtr<IHsmPhasePriv>  pPhasePriv;

    WsbTraceIn(OLESTR("CHsmPhase::Clone"), OLESTR(""));
    
    try {

        // Did they give us a valid item?
        WsbAssert(0 != ppPhasePriv, E_POINTER);
        *ppPhasePriv = 0;

        // Create the new instance.
        WsbAffirmHr(CoCreateInstance(CLSID_CHsmPhase, 0, CLSCTX_ALL, IID_IHsmPhasePriv, (void**) &pPhasePriv));

        // Fill it in with the new values.
        WsbAffirmHr(CopyTo(pPhasePriv));

        // Return it to the caller.
        *ppPhasePriv = pPhasePriv;
        pPhasePriv->AddRef();

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmPhase::Clone"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmPhase::CompareTo(
    IN IUnknown* pUnknown,
    OUT SHORT* pResult
    )

/*++

Implements:

  IWsbCollectable::CompareTo().

--*/
{
    HRESULT                     hr = S_OK;
    CComPtr<IHsmPhase>          pPhase;

    WsbTraceIn(OLESTR("CHsmPhase::CompareTo"), OLESTR(""));
    
    try {

        // Did they give us a valid item to compare to?
        WsbAssert(0 != pUnknown, E_POINTER);

        // We need the IWsbBool interface to get the value of the object.
        WsbAffirmHr(pUnknown->QueryInterface(IID_IHsmPhase, (void**) &pPhase));

        // Compare the rules.
        hr = CompareToIPhase(pPhase, pResult);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmPhase::CompareTo"), OLESTR("hr = <%ls>, result = <%ls>"), WsbHrAsString(hr), WsbPtrToShortAsString(pResult));

    return(hr);
}


HRESULT
CHsmPhase::CompareToPhase(
    IN HSM_JOB_PHASE phase,
    OUT SHORT* pResult
    )

/*++

Implements:

  IHsmPhase::CompareToPhase().

--*/
{
    HRESULT     hr = S_OK;
    SHORT       aResult = 0;

    WsbTraceIn(OLESTR("CHsmPhase::CompareToPhase"), OLESTR(""));

    try {

        // Compare the guids.
        if (m_phase > phase) {
            aResult = 1;
        }
        else if (m_phase < phase) {
            aResult = -1;
        }

        if (0 != aResult) {
            hr = S_FALSE;
        }
        
        if (0 != pResult) {
            *pResult = aResult;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmPhase::CompareToPhase"), OLESTR("hr = <%ls>, result = <%d>"), WsbHrAsString(hr), aResult);

    return(hr);
}


HRESULT
CHsmPhase::CompareToIPhase(
    IN IHsmPhase* pPhase,
    OUT SHORT* pResult
    )

/*++

Implements:

  IHsmPhase::CompareToIPhase().

--*/
{
    HRESULT             hr = S_OK;
    HSM_JOB_PHASE       phase;

    WsbTraceIn(OLESTR("CHsmPhase::CompareToIPhase"), OLESTR(""));

    try {

        // Did they give us a valid item to compare to?
        WsbAssert(0 != pPhase, E_POINTER);

        // Get the identifier.
        WsbAffirmHr(pPhase->GetPhase(&phase));

        // Compare to the identifier.
        hr = CompareToPhase(phase, pResult);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmPhase::CompareToIPhase"), OLESTR("hr = <%ls>, result = <%ls>"), WsbHrAsString(hr), WsbPtrToShortAsString(pResult));

    return(hr);
}


HRESULT
CHsmPhase::CopyTo(
    IN IHsmPhase* pPhase
    )

/*++

Implements:

  IHsmPhase::CopyTo().

--*/
{
    HRESULT                         hr = S_OK;
    CComPtr<IHsmPhasePriv>  pPhasePriv;

    WsbTraceIn(OLESTR("CHsmPhase::CopyTo"), OLESTR(""));
    
    try {

        // Did they give us a valid item?
        WsbAssert(0 != pPhase, E_POINTER);

        // Get the private interface for the destination and copy the values.
        WsbAffirmHr(pPhase->QueryInterface(IID_IHsmPhasePriv, (void**) &pPhasePriv));
        WsbAffirmHr(pPhasePriv->SetInternalStuff(m_mountCount, m_transferCount, m_elapsedTime, m_startTime, m_restartTime, m_stopTime));
        WsbAffirmHr(pPhasePriv->SetMediaState(m_mediaState));
        WsbAffirmHr(pPhasePriv->SetPhase(m_phase));
        WsbAffirmHr(pPhasePriv->SetPriority(m_priority));
        WsbAffirmHr(pPhasePriv->SetState(m_state));
        WsbAffirmHr(pPhasePriv->SetStats(m_items, m_size, m_skippedItems, m_skippedSize, m_errorItems, m_errorSize));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmPhase::CopyTo"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmPhase::CopyTo(
    IN IHsmPhasePriv* pPhasePriv
    )

/*++

Implements:

  IHsmPhase::CopyTo().

--*/
{
    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmPhase::CopyTo"), OLESTR(""));
    
    try {

        // Did they give us a valid item?
        WsbAssert(0 != pPhasePriv, E_POINTER);

        // Get the private interface for the destination and copy the values.
        WsbAffirmHr(pPhasePriv->SetInternalStuff(m_mountCount, m_transferCount, m_elapsedTime, m_startTime, m_restartTime, m_stopTime));
        WsbAffirmHr(pPhasePriv->SetMediaState(m_mediaState));
        WsbAffirmHr(pPhasePriv->SetPhase(m_phase));
        WsbAffirmHr(pPhasePriv->SetPriority(m_priority));
        WsbAffirmHr(pPhasePriv->SetState(m_state));
        WsbAffirmHr(pPhasePriv->SetStats(m_items, m_size, m_skippedItems, m_skippedSize, m_errorItems, m_errorSize));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmPhase::CopyTo"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmPhase::FinalConstruct(
    void
    )
/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;
    
    WsbTraceIn(OLESTR("CHsmPhase::FinalConstruct"), OLESTR(""));
    try {
        
        WsbAffirmHr(CWsbObject::FinalConstruct());

        m_mediaState = HSM_JOB_MEDIA_STATE_IDLE;
        m_mountCount = 0;
        m_transferCount = 0;
        m_phase = HSM_JOB_PHASE_ALL;
        m_priority = HSM_JOB_PRIORITY_NORMAL;
        m_state = HSM_JOB_STATE_IDLE;
        m_items = 0;
        m_size = 0;
        m_skippedItems = 0;
        m_skippedSize = 0;
        m_errorItems = 0;
        m_errorSize = 0;
        m_elapsedTime = 0;
        m_startTime.dwLowDateTime = 0;
        m_startTime.dwHighDateTime = 0;
        m_restartTime.dwLowDateTime = 0;
        m_restartTime.dwHighDateTime = 0;
        m_stopTime.dwLowDateTime = 0;
        m_stopTime.dwHighDateTime = 0;

    } WsbCatch(hr);
    
    iCount++;
    WsbTraceOut(OLESTR("CHsmPhase::FinalConstruct"), OLESTR("hr = <%ls>, count is <%d>"), WsbHrAsString(hr), iCount);
    return(hr);
}


void
CHsmPhase::FinalRelease(
    void
    )

/*++

Implements:

  CHsmPhase::FinalRelease().

--*/
{
    
    WsbTraceIn(OLESTR("CHsmPhase::FinalRelease"), OLESTR(""));
    
    CWsbObject::FinalRelease();
    iCount--;
    
    WsbTraceOut(OLESTR("CHsmPhase::FinalRelease"), OLESTR("Count is <%d>"), iCount);
}


HRESULT
CHsmPhase::GetClassID(
    OUT CLSID* pClsid
    )

/*++

Implements:

  IPersist::GetClassID().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmPhase::GetClassID"), OLESTR(""));

    try {

        WsbAssert(0 != pClsid, E_POINTER);
        *pClsid = CLSID_CHsmPhase;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmPhase::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return(hr);
}


HRESULT
CHsmPhase::GetElapsedTime(
    OUT ULONG* pDays,
    OUT USHORT* pHours,
    OUT USHORT* pMinutes,
    OUT USHORT* pSeconds
    )
/*++

Implements:

  IHsmPhase::GetElapsedTime().

--*/
{
    HRESULT     hr = S_OK;
    LONGLONG    remainingTime = 0;
    FILETIME    currentTime;

    try {

        WsbAssert(0 != pDays, E_POINTER);
        WsbAssert(0 != pHours, E_POINTER);
        WsbAssert(0 != pMinutes, E_POINTER);
        WsbAssert(0 != pSeconds, E_POINTER);

        // If the phase is still active, then add the time since the last start or restart.
        remainingTime = m_elapsedTime;

        if (HSM_JOB_STATE_IS_ACTIVE(m_state)) {
            WsbAffirmHr(CoFileTimeNow(&currentTime));

            if (WsbFTtoLL(m_restartTime) != 0) {
                remainingTime += WsbFTtoLL(currentTime) - WsbFTtoLL(m_restartTime);
            } else {
                remainingTime += WsbFTtoLL(currentTime) - WsbFTtoLL(m_startTime);
            }
        }

        *pDays = (ULONG) (remainingTime / WSB_FT_TICKS_PER_DAY);
        remainingTime = remainingTime % WSB_FT_TICKS_PER_DAY;

        *pHours = (USHORT) (remainingTime / (WSB_FT_TICKS_PER_HOUR));
        remainingTime = remainingTime % WSB_FT_TICKS_PER_HOUR;

        *pMinutes = (USHORT) (remainingTime / WSB_FT_TICKS_PER_MINUTE);
        *pSeconds = (USHORT) ((remainingTime % WSB_FT_TICKS_PER_MINUTE) / WSB_FT_TICKS_PER_SECOND);

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmPhase::GetMediaState(
    OUT HSM_JOB_MEDIA_STATE* pState
    )
/*++

Implements:

  IHsmPhase::GetMediaState().

--*/
{
    HRESULT     hr = S_OK;

    try {

        WsbAssert(0 != pState, E_POINTER);
        *pState = m_mediaState;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmPhase::GetMediaStateAsString(
    OUT OLECHAR** pName,
    IN ULONG bufferSize
    )

/*++

Implements:

  IHsmPhase::GetMediaStateAsString().

--*/
{
    HRESULT         hr = S_OK;
    CWsbStringPtr   tmpString;

    try {

        WsbAssert(0 != pName, E_POINTER);

        WsbAffirmHr(tmpString.LoadFromRsc(_Module.m_hInst, IDS_HSMJOBMEDIASTATEIDLE + m_mediaState));
        WsbAffirmHr(tmpString.CopyTo(pName, bufferSize));

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmPhase::GetName(
    OUT OLECHAR** pName,
    IN ULONG bufferSize
    )

/*++

Implements:

  IHsmPhase::GetName().

--*/
{
    HRESULT         hr = S_OK;
    CWsbStringPtr   tmpString;

    try {

        WsbAssert(0 != pName, E_POINTER);

        WsbAffirmHr(tmpString.LoadFromRsc(_Module.m_hInst, IDS_HSMJOBPHASEALL + m_phase));
        WsbAffirmHr(tmpString.CopyTo(pName, bufferSize));

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmPhase::GetPhase(
    OUT HSM_JOB_PHASE* pPhase
    )
/*++

Implements:

  IHsmPhase::GetPhase().

--*/
{
    HRESULT     hr = S_OK;

    try {

        WsbAssert(0 != pPhase, E_POINTER);
        *pPhase = m_phase;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmPhase::GetPriority(
    OUT HSM_JOB_PRIORITY* pPriority
    )
/*++

Implements:

  IHsmPhase::GetPriority().

--*/
{
    HRESULT     hr = S_OK;

    try {

        WsbAssert(0 != pPriority, E_POINTER);
        *pPriority = m_priority;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmPhase::GetPriorityAsString(
    OUT OLECHAR** pName,
    IN ULONG bufferSize
    )

/*++

Implements:

  IHsmPhase::GetPriorityAsString().

--*/
{
    HRESULT         hr = S_OK;
    CWsbStringPtr   tmpString;

    try {

        WsbAssert(0 != pName, E_POINTER);

        WsbAffirmHr(tmpString.LoadFromRsc(_Module.m_hInst, IDS_HSMJOBPRIORITY_IDLE + m_priority));
        WsbAffirmHr(tmpString.CopyTo(pName, bufferSize));

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmPhase::GetSizeMax(
    OUT ULARGE_INTEGER* pSize
    )

/*++

Implements:

  IPersistStream::GetSizeMax().

--*/
{
    HRESULT                 hr = S_OK;


    WsbTraceIn(OLESTR("CHsmPhase::GetSizeMax"), OLESTR(""));

    try {

        WsbAssert(0 != pSize, E_POINTER);

        // Determine the size for a rule with no criteria.
        pSize->QuadPart = 5 * WsbPersistSizeOf(LONGLONG) + 6 * WsbPersistSizeOf(ULONG) + 3 * WsbPersistSizeOf(FILETIME);

        // In theory we should be saving the errorItems and errorSize, but at the
        // time this was added, we didn't want to force a reinstall because of
        // pSize->QuadPart += 2 * WsbPersistSizeOf(LONGLONG);
        
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmPhase::GetSizeMax"), OLESTR("hr = <%ls>, Size = <%ls>"), WsbHrAsString(hr), WsbPtrToUliAsString(pSize));

    return(hr);
}


HRESULT
CHsmPhase::GetStartTime(
    OUT FILETIME* pTime
    )
/*++

Implements:

  IHsmPhase::GetStartTime().

--*/
{
    HRESULT     hr = S_OK;

    try {

        WsbAssert(0 != pTime, E_POINTER);
        *pTime = m_startTime;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmPhase::GetState(
    OUT HSM_JOB_STATE* pState
    )
/*++

Implements:

  IHsmPhase::GetState().

--*/
{
    HRESULT     hr = S_OK;

    try {

        WsbAssert(0 != pState, E_POINTER);
        *pState = m_state;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmPhase::GetStateAsString(
    OUT OLECHAR** pName,
    IN ULONG bufferSize
    )

/*++

Implements:

  IHsmPhase::GetStateAsString().

--*/
{
    HRESULT         hr = S_OK;
    CWsbStringPtr   tmpString;

    try {

        WsbAssert(0 != pName, E_POINTER);

        WsbAffirmHr(tmpString.LoadFromRsc(_Module.m_hInst, IDS_HSMJOBSTATEACTIVE + m_state));
        WsbAffirmHr(tmpString.CopyTo(pName, bufferSize));

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmPhase::GetStats(
    OUT LONGLONG* pItems,
    OUT LONGLONG* pSize,
    OUT LONGLONG* pSkippedItems,
    OUT LONGLONG* pSkippedSize,
    OUT LONGLONG* pErrorItems,
    OUT LONGLONG* pErrorSize
    )
/*++

Implements:

  IHsmPhase::GetStats().

--*/
{
    HRESULT     hr = S_OK;

    if (0 != pItems) {
        *pItems = m_items;
    }

    if (0 != pSize) {
        *pSize = m_size;
    }

    if (0 != pSkippedItems) {
        *pSkippedItems = m_skippedItems;
    }

    if (0 != pSkippedSize) {
        *pSkippedSize = m_skippedSize;
    }

    if (0 != pErrorItems) {
        *pErrorItems = m_errorItems;
    }

    if (0 != pSize) {
        *pErrorSize = m_errorSize;
    }
    
    return(hr);
}


HRESULT
CHsmPhase::GetStopTime(
    OUT FILETIME* pTime
    )
/*++

Implements:

  IHsmPhase::GetStopTime().

--*/
{
    HRESULT     hr = S_OK;

    try {

        WsbAssert(0 != pTime, E_POINTER);
        *pTime = m_stopTime;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmPhase::Load(
    IN IStream* pStream
    )

/*++

Implements:

  IPersistStream::Load().

--*/
{
    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmPhase::Load"), OLESTR(""));

    try {
        ULONG ul_tmp;

        WsbAssert(0 != pStream, E_POINTER);
        
        // Do the easy stuff, but make sure that this order matches the order
        // in the load method.
        WsbAffirmHr(WsbLoadFromStream(pStream, &ul_tmp));
        m_mediaState = static_cast<HSM_JOB_MEDIA_STATE>(ul_tmp);
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_mountCount));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_transferCount));
        WsbAffirmHr(WsbLoadFromStream(pStream, &ul_tmp));
        m_phase = static_cast<HSM_JOB_PHASE>(ul_tmp);
        WsbAffirmHr(WsbLoadFromStream(pStream, &ul_tmp));
        m_priority = static_cast<HSM_JOB_PRIORITY>(ul_tmp);
        WsbAffirmHr(WsbLoadFromStream(pStream, &ul_tmp));
        m_state = static_cast<HSM_JOB_STATE>(ul_tmp);
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_items));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_size));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_skippedItems));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_skippedSize));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_elapsedTime));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_startTime));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_restartTime));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_stopTime));

        // In theory we should be saving the errorItems and errorSize, but at the
        // time this was added, we didn't want to force a reinstall because of
        // changes in the persistant data.
        // WsbAffirmHr(WsbLoadFromStream(pStream, &m_errorItems));
        // WsbAffirmHr(WsbLoadFromStream(pStream, &m_errorSize));
        
    } WsbCatch(hr);                                        

    WsbTraceOut(OLESTR("CHsmPhase::Load"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmPhase::Save(
    IN IStream* pStream,
    IN BOOL clearDirty
    )

/*++

Implements:

  IPersistStream::Save().

--*/
{
    HRESULT                 hr = S_OK;

    WsbTraceIn(OLESTR("CHsmPhase::Save"), OLESTR("clearDirty = <%ls>"), WsbBoolAsString(clearDirty));
    
    try {
        WsbAssert(0 != pStream, E_POINTER);
        
        // Do the easy stuff, but make sure that this order matches the order
        // in the load method.
        WsbAffirmHr(WsbSaveToStream(pStream, static_cast<ULONG>(m_mediaState)));
        WsbAffirmHr(WsbSaveToStream(pStream, m_mountCount));
        WsbAffirmHr(WsbSaveToStream(pStream, m_transferCount));
        WsbAffirmHr(WsbSaveToStream(pStream, static_cast<ULONG>(m_phase)));
        WsbAffirmHr(WsbSaveToStream(pStream, static_cast<ULONG>(m_priority)));
        WsbAffirmHr(WsbSaveToStream(pStream, static_cast<ULONG>(m_state)));
        WsbAffirmHr(WsbSaveToStream(pStream, m_items));
        WsbAffirmHr(WsbSaveToStream(pStream, m_size));
        WsbAffirmHr(WsbSaveToStream(pStream, m_skippedItems));
        WsbAffirmHr(WsbSaveToStream(pStream, m_skippedSize));
        WsbAffirmHr(WsbSaveToStream(pStream, m_elapsedTime));
        WsbAffirmHr(WsbSaveToStream(pStream, m_startTime));
        WsbAffirmHr(WsbSaveToStream(pStream, m_restartTime));
        WsbAffirmHr(WsbSaveToStream(pStream, m_stopTime));

        // In theory we should be saving the errorItems and errorSize, but at the
        // time this was added, we didn't want to force a reinstall because of
        // changes in the persistant data.
        // WsbAffirmHr(WsbSaveToStream(pStream, m_errorItems));
        // WsbAffirmHr(WsbSaveToStream(pStream, m_errorSize));
        
        // If we got it saved and we were asked to clear the dirty bit, then
        // do so now.
        if (clearDirty) {
            m_isDirty = FALSE;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmPhase::Save"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmPhase::SetInternalStuff(
    IN ULONG mountCount,
    IN ULONG transferCount,
    IN LONGLONG elapsedTime,
    IN FILETIME startTime,
    IN FILETIME restartTime,
    IN FILETIME stopTime
    )
/*++

Implements:

  IHsmPhasePriv::SetInternalStuff().

--*/
{
    m_mountCount = mountCount;
    m_transferCount = transferCount;
    m_elapsedTime = elapsedTime;
    m_startTime = startTime;
    m_restartTime = restartTime;
    m_stopTime = stopTime;

    return(S_OK);
}


HRESULT
CHsmPhase::SetMediaState(
    IN HSM_JOB_MEDIA_STATE state
    )
/*++

Implements:

  IHsmPhasePriv::SetMediaState().

--*/
{
    HRESULT     hr = S_OK;

    // Determine whether the state being reported will cause the overall state to
    // change. The overall state should be mounted/transferring/transferred if any
    // media are mounted.

    switch (state) {
        case HSM_JOB_MEDIA_STATE_BUSY:
        case HSM_JOB_MEDIA_STATE_UNAVAILABLE:
            if ((HSM_JOB_MEDIA_STATE_IDLE == m_mediaState) ||
                (HSM_JOB_MEDIA_STATE_MOUNTING == m_mediaState)) {
                m_mediaState = state;
            }
            break;

        case HSM_JOB_MEDIA_STATE_MOUNTING:
            if ((HSM_JOB_MEDIA_STATE_MOUNTED != m_mediaState) &&
                (HSM_JOB_MEDIA_STATE_TRANSFERRED != m_mediaState) &&
                (HSM_JOB_MEDIA_STATE_TRANSFERRING != m_mediaState)) {
                m_mediaState = state;
            }
            break;

        case HSM_JOB_MEDIA_STATE_MOUNTED:
            if ((HSM_JOB_MEDIA_STATE_MOUNTED != m_mediaState) &&
                (HSM_JOB_MEDIA_STATE_TRANSFERRED != m_mediaState) &&
                (HSM_JOB_MEDIA_STATE_TRANSFERRING != m_mediaState)) {
                m_mediaState = state;
            }
            m_mountCount++;
            break;

        case HSM_JOB_MEDIA_STATE_TRANSFERRING:
            if ((HSM_JOB_MEDIA_STATE_TRANSFERRING != m_mediaState) &&
                (HSM_JOB_MEDIA_STATE_TRANSFERRED != m_mediaState)) {
                m_mediaState = state;
            }
            m_transferCount++;
            break;

        case HSM_JOB_MEDIA_STATE_TRANSFERRED:
            if (m_transferCount <= 1) {
                m_mediaState = state;
            }
            m_transferCount--;
            break;

        case HSM_JOB_MEDIA_STATE_DISMOUNTING:
            if (m_mountCount <= 1) {
                m_mediaState = state;
            }
            break;

        case HSM_JOB_MEDIA_STATE_DISMOUNTED:
            if (m_mountCount <= 1) {
                m_mediaState = state;
            }
            m_mountCount--;
            break;

        case HSM_JOB_MEDIA_STATE_FAILED:
            m_mediaState = state;
            break;

        default:
        case HSM_JOB_MEDIA_STATE_IDLE:
            break;
    }

    return(hr);
}


HRESULT
CHsmPhase::SetPhase(
    IN HSM_JOB_PHASE phase
    )
/*++

Implements:

  IHsmPhase::SetPhase().

--*/
{
    m_phase = phase;

    return(S_OK);
}


HRESULT
CHsmPhase::SetPriority(
    IN HSM_JOB_PRIORITY priority
    )
/*++

Implements:

  IHsmPhasePriv::SetPriority().

--*/
{
    m_priority = priority;

    return(S_OK);
}


HRESULT
CHsmPhase::SetState(
    IN HSM_JOB_STATE state
    )
/*++

Implements:

  IHsmPhasePriv::SetState().

--*/
{
    HRESULT     hr = S_OK;
    FILETIME    currentTime;
    LONGLONG    restartTicks;
    LONGLONG    stopTicks;

    try {

        GetSystemTimeAsFileTime(&currentTime);

        switch(state) {
            case HSM_JOB_STATE_ACTIVE:
                // If this is a resume, then update the restartTime not the startTime.
                if (HSM_JOB_STATE_RESUMING == m_state) {
                    m_restartTime = currentTime;
                } else {
                    m_restartTime = WsbLLtoFT(0);
                    m_startTime = currentTime;
                    m_elapsedTime = 0;
                }
                m_state = state;
                break;

            case HSM_JOB_STATE_CANCELLED:
            case HSM_JOB_STATE_DONE:
            case HSM_JOB_STATE_FAILED:
            case HSM_JOB_STATE_SKIPPED:
            case HSM_JOB_STATE_PAUSED:
            case HSM_JOB_STATE_SUSPENDED:
                // Record the stop time and update the elapsed time.
                m_stopTime = currentTime;
                restartTicks = WsbFTtoLL(m_restartTime);
                stopTicks = WsbFTtoLL(m_stopTime);
                if (restartTicks == 0) {
                    m_elapsedTime = stopTicks - WsbFTtoLL(m_startTime);
                } else {
                    m_elapsedTime += stopTicks - restartTicks;
                }
                m_state = state;
                break;
        
            case HSM_JOB_STATE_CANCELLING:
            case HSM_JOB_STATE_IDLE:
            case HSM_JOB_STATE_PAUSING:
            case HSM_JOB_STATE_RESUMING:
            case HSM_JOB_STATE_STARTING:
            case HSM_JOB_STATE_SUSPENDING:
                // Don't need to do anything for these other than record the state change.
                m_state = state;
                break;

            default:
                WsbAssert(FALSE, E_UNEXPECTED);
                break;
        }

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmPhase::SetStats(
    IN LONGLONG items,
    IN LONGLONG size,
    IN LONGLONG skippedItems,
    IN LONGLONG skippedSize,
    IN LONGLONG errorItems,
    IN LONGLONG errorSize
    )
/*++

Implements:

  IHsmPhasePriv::SetStats().

--*/
{
    m_items = items;
    m_size = size;
    m_skippedItems = skippedItems;
    m_skippedSize = skippedSize;
    m_errorItems = errorItems;
    m_errorSize = errorSize;

    return(S_OK);
}


HRESULT
CHsmPhase::Test(
    USHORT* passed,
    USHORT* failed
    )

/*++

Implements:

  IWsbTestable::Test().

--*/
{
    HRESULT     hr = S_OK;

    try {

        WsbAssert(0 != passed, E_POINTER);
        WsbAssert(0 != failed, E_POINTER);

        *passed = 0;
        *failed = 0;

    } WsbCatch(hr);

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\job\hsmjobwi.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    hsmjobwi.cpp

Abstract:

    This component represents a resource that will is/was operated on by a job.

Author:

    Chuck Bardeen   [cbardeen]   09-Feb-1996

Revision History:

--*/

#include "stdafx.h"

#include "wsb.h"
#include "fsa.h"
#include "job.h"
#include "hsmjobwi.h"

#define WSB_TRACE_IS        WSB_TRACE_BIT_JOB

static USHORT iCountJobwi = 0;


HRESULT
CHsmJobWorkItem::CompareTo(
    IN IUnknown* pUnknown,
    OUT SHORT* pResult
    )

/*++

Implements:

  IWsbCollectable::CompareTo().

--*/
{
    HRESULT                     hr = S_OK;
    CComPtr<IHsmJobWorkItem>    pWorkItem;

    WsbTraceIn(OLESTR("CHsmJobWorkItem::CompareTo"), OLESTR(""));
    
    try {

        // Did they give us a valid item to compare to?
        WsbAssert(0 != pUnknown, E_POINTER);

        // We need the IWsbBool interface to get the value of the object.
        WsbAffirmHr(pUnknown->QueryInterface(IID_IHsmJobWorkItem, (void**) &pWorkItem));

        // Compare the rules.
        hr = CompareToIWorkItem(pWorkItem, pResult);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmJobWorkItem::CompareTo"), OLESTR("hr = <%ls>, result = <%ls>"), WsbHrAsString(hr), WsbPtrToShortAsString(pResult));

    return(hr);
}


HRESULT
CHsmJobWorkItem::CompareToIWorkItem(
    IN IHsmJobWorkItem* pWorkItem,
    OUT SHORT* pResult
    )

/*++

Implements:

  IHsmJobWorkItem::CompareToIWorkItem().

--*/
{
    HRESULT     hr = S_OK;
    GUID        id;

    WsbTraceIn(OLESTR("CHsmJobWorkItem::CompareToIWorkItem"), OLESTR(""));

    try {

        // Did they give us a valid item to compare to?
        WsbAssert(0 != pWorkItem, E_POINTER);

        // Get the identifier.
        WsbAffirmHr(pWorkItem->GetResourceId(&id));

        // Compare to the identifier.
        hr = CompareToResourceId(id, pResult);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmJobWorkItem::CompareToIWorkItem"), OLESTR("hr = <%ls>, result = <%ls>"), WsbHrAsString(hr), WsbPtrToShortAsString(pResult));

    return(hr);
}


HRESULT
CHsmJobWorkItem::CompareToResourceId(
    IN GUID id,
    OUT SHORT* pResult
    )

/*++

Implements:

  IHsmJobWorkItem::CompareToResourceId().

--*/
{
    HRESULT     hr = S_OK;
    SHORT       aResult = 0;

    WsbTraceIn(OLESTR("CHsmJobWorkItem::CompareToResourceId"), OLESTR("resource id = <%ls>"), WsbGuidAsString(id));

    try {

        // Compare the guids.
        aResult = WsbSign( memcmp(&m_resourceId, &id, sizeof(GUID)) );

        if (0 != aResult) {
            hr = S_FALSE;
        }
        
        if (0 != pResult) {
            *pResult = aResult;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmJobWorkItem::CompareToResourceId"), OLESTR("hr = <%ls>, result = <%d>"), WsbHrAsString(hr), aResult);

    return(hr);
}


HRESULT
CHsmJobWorkItem::DoPostScan(
    void
    )

/*++

Implements:

  IPersist::DoPostScan().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmJobWorkItem::DoPostScan"), OLESTR(""));

    try {
        CComPtr<IHsmActionOnResourcePost> pActionPost;
        CComPtr<IHsmJobDef>               pJobDef;

        // Execute any post-scan action
        WsbAffirmHr(m_pJob->GetDef(&pJobDef));
        WsbAffirmHr(pJobDef->GetPostActionOnResource(&pActionPost));
        if (pActionPost) {
            WsbTrace(OLESTR("CHsmJobWorkItem::DoPostScan, doing post-scan action\n"), (void*)pJobDef);
            WsbAffirmHr(pActionPost->Do(static_cast<IHsmJobWorkItem*>(this), m_state));
        }


    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmJobWorkItem::DoPostScan"), OLESTR("hr = <%ls>"), 
            WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmJobWorkItem::DoPreScan(
    void
    )

/*++

Implements:

  IPersist::DoPreScan().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmJobWorkItem::DoPreScan"), OLESTR(""));

    try {
        CComPtr<IHsmActionOnResourcePre>  pActionPre;
        CComPtr<IHsmJobDef>               pJobDef;

        // Execute any pre-scan action
        WsbAffirmHr(m_pJob->GetDef(&pJobDef));
        WsbTrace(OLESTR("CHsmJobWorkItem::DoPreScan, pJobDef = %lx\n"), (void*)pJobDef);
        WsbAffirmHr(pJobDef->GetPreActionOnResource(&pActionPre));
        if (pActionPre) {
            WsbTrace(OLESTR("CHsmJobWorkItem::DoPreScan, doing pre-scan action\n"));
            WsbAffirmHr(pActionPre->Do(static_cast<IHsmJobWorkItem*>(this), pJobDef));
        }


    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmJobWorkItem::DoPreScan"), OLESTR("hr = <%ls>"), 
            WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmJobWorkItem::EnumPhases(
    IN IWsbEnum** ppEnum
    )

/*++

Implements:

  IHsmSession::EnumPhases().

--*/
{
    HRESULT     hr = S_OK;

    try {

        WsbAssert(0 != ppEnum, E_POINTER);
        WsbAffirmHr(m_pPhases->Enum(ppEnum));

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmJobWorkItem::EnumTotals(
    IN IWsbEnum** ppEnum
    )

/*++

Implements:

  IHsmSession::EnumTotals().

--*/
{
    HRESULT     hr = S_OK;

    try {

        WsbAssert(0 != ppEnum, E_POINTER);
        WsbAffirmHr(m_pTotals->Enum(ppEnum));

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmJobWorkItem::FinalConstruct(
    void
    )
/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;
    
    WsbTraceIn(OLESTR("CHsmJobWorkItem::FinalConstruct"), OLESTR(""));
    try {
        
        WsbAffirmHr(CWsbObject::FinalConstruct());

        m_cookie = 0;
        m_resourceId = GUID_NULL;
        m_state = HSM_JOB_STATE_IDLE;
        m_subRunId = 0;
        m_bActive = FALSE;

        // Create the phase and totals collections.
        WsbAffirmHr(CoCreateInstance(CLSID_CWsbOrderedCollection, 0, CLSCTX_ALL, IID_IWsbCollection, (void**) &m_pPhases));
        WsbAffirmHr(CoCreateInstance(CLSID_CWsbOrderedCollection, 0, CLSCTX_ALL, IID_IWsbCollection, (void**) &m_pTotals));

    } WsbCatch(hr);
    
    iCountJobwi++;
    WsbTraceOut(OLESTR("CHsmJobWorkItem::FinalConstruct"), OLESTR("hr = <%ls>, count is <%d>"), WsbHrAsString(hr), iCountJobwi);
    return(hr);
}


void
CHsmJobWorkItem::FinalRelease(
    void
    )

/*++

Implements:

  CHsmJobWorkItem::FinalRelease().

--*/
{
    
    WsbTraceIn(OLESTR("CHsmJobWorkItem::FinalRelease"), OLESTR(""));
    
    CWsbObject::FinalRelease();
    iCountJobwi--;
    
    WsbTraceOut(OLESTR("CHsmJobWorkItem:FinalRelease"), OLESTR("Count is <%d>"), iCountJobwi);
}

HRESULT
CHsmJobWorkItem::GetClassID(
    OUT CLSID* pClsid
    )

/*++

Implements:

  IPersist::GetClassID().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmJobWorkItem::GetClassID"), OLESTR(""));

    try {

        WsbAssert(0 != pClsid, E_POINTER);
        *pClsid = CLSID_CHsmJobWorkItem;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmJobWorkItem::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return(hr);
}


HRESULT
CHsmJobWorkItem::GetCookie(
    OUT DWORD* pCookie
    )
/*++

Implements:

  IHsmJobWorkItem::GetCookie().

--*/
{
    HRESULT     hr = S_OK;

    try {

        WsbAssert(0 != pCookie, E_POINTER);
        *pCookie = m_cookie;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmJobWorkItem::GetCurrentPath(
    OUT OLECHAR** pPath,
    IN ULONG bufferSize
    )
/*++

Implements:

  IHsmJobWorkItem::GetCurrentPath().

--*/
{
    HRESULT     hr = S_OK;

    try {

        WsbAssert(0 != pPath, E_POINTER);
        WsbAffirmHr(m_currentPath.CopyTo(pPath, bufferSize));

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmJobWorkItem::GetFinishTime(
    OUT FILETIME* pTime
    )
/*++

Implements:

  IHsmJobWorkItem::GetFinishTime().

--*/
{
    HRESULT     hr = S_OK;

    try {

        WsbAssert(0 != pTime, E_POINTER);
        *pTime = m_finishTime;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmJobWorkItem::GetPhases(
    IN IWsbCollection** ppCollection
    )

/*++

Implements:

  IHsmJobWorkItemPriv::GetPhases().

--*/
{
    HRESULT     hr = S_OK;

    try {

        WsbAssert(0 != ppCollection, E_POINTER);
        *ppCollection = m_pPhases;
        if (m_pPhases != 0)  {
            m_pPhases->AddRef();
        }

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmJobWorkItem::GetResourceId(
    OUT GUID* pId
    )
/*++

Implements:

  IHsmJobWorkItem::GetResourceId().

--*/
{
    HRESULT     hr = S_OK;

    try {

        WsbAssert(0 != pId, E_POINTER);
        *pId = m_resourceId;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmJobWorkItem::GetSession(
    OUT IHsmSession** ppSession
    )
/*++

Implements:

  IHsmJobWorkItem::GetSession().

--*/
{
    HRESULT     hr = S_OK;

    try {

        WsbAssert(0 != ppSession, E_POINTER);

        *ppSession = m_pSession;
        if (m_pSession != 0)  {
            m_pSession->AddRef();
        } else  {
            WsbTrace(OLESTR("CHsmJobWorkItem::GetSession - session pointer is null. \n"));
        }

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmJobWorkItem::GetStartingPath(
    OUT OLECHAR** pPath,
    IN ULONG bufferSize
    )
/*++

Implements:

  IHsmJobWorkItem::GetStartingPath().

--*/
{
    HRESULT     hr = S_OK;

    try {

        WsbAssert(0 != pPath, E_POINTER);
        WsbAffirmHr(m_startingPath.CopyTo(pPath, bufferSize));

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmJobWorkItem::GetSizeMax(
    OUT ULARGE_INTEGER* pSize
    )

/*++

Implements:

  IPersistStream::GetSizeMax().

--*/
{
    HRESULT                 hr = S_OK;
    CComPtr<IPersistStream> pPersistStream;
    ULARGE_INTEGER          entrySize;


    WsbTraceIn(OLESTR("CHsmJobWorkItem::GetSizeMax"), OLESTR(""));

    try {

        WsbAssert(0 != pSize, E_POINTER);

        // Determine the size for a rule with no criteria.
        pSize->QuadPart = 4 * WsbPersistSizeOf(ULONG) + WsbPersistSize((wcslen(m_currentPath) + 1) * sizeof(OLECHAR)) + WsbPersistSize((wcslen(m_startingPath) + 1) * sizeof(OLECHAR)) + 2 * WsbPersistSizeOf(FILETIME) + WsbPersistSizeOf(GUID);

        // Now allocate space for the phase and totals.
        WsbAffirmHr(m_pPhases->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
        WsbAffirmHr(pPersistStream->GetSizeMax(&entrySize));
        pSize->QuadPart += entrySize.QuadPart;
        pPersistStream = 0;

        WsbAffirmHr(m_pTotals->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
        WsbAffirmHr(pPersistStream->GetSizeMax(&entrySize));
        pSize->QuadPart += entrySize.QuadPart;
        pPersistStream = 0;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmJobWorkItem::GetSizeMax"), OLESTR("hr = <%ls>, Size = <%ls>"), WsbHrAsString(hr), WsbPtrToUliAsString(pSize));

    return(hr);
}


HRESULT
CHsmJobWorkItem::GetStartTime(
    OUT FILETIME* pTime
    )
/*++

Implements:

  IHsmJobWorkItem::GetStartTime().

--*/
{
    HRESULT     hr = S_OK;

    try {

        WsbAssert(0 != pTime, E_POINTER);
        *pTime = m_startTime;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmJobWorkItem::GetState(
    OUT HSM_JOB_STATE* pState
    )
/*++

Implements:

  IHsmJobWorkItem::GetState().

--*/
{
    HRESULT     hr = S_OK;

    try {

        WsbAssert(0 != pState, E_POINTER);
        *pState = m_state;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmJobWorkItem::GetStateAsString(
    OUT OLECHAR** pName,
    IN ULONG bufferSize
    )

/*++

Implements:

  IHsmJobWorkItem::GetStateAsString().

--*/
{
    HRESULT         hr = S_OK;
    CWsbStringPtr   tmpString;

    try {

        WsbAssert(0 != pName, E_POINTER);

        WsbAffirmHr(tmpString.LoadFromRsc(_Module.m_hInst, IDS_HSMJOBSTATEACTIVE + m_state));
        WsbAffirmHr(tmpString.CopyTo(pName, bufferSize));

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmJobWorkItem::GetSubRunId(
    OUT ULONG* pId
    )
/*++

Implements:

  IHsmJobWorkItem::GetSubRunId().

--*/
{
    HRESULT     hr = S_OK;

    try {

        WsbAssert(0 != pId, E_POINTER);
        *pId = m_subRunId;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmJobWorkItem::GetTotals(
    IN IWsbCollection** ppCollection
    )

/*++

Implements:

  IHsmSessionPriv::GetTotals().

--*/
{
    HRESULT     hr = S_OK;

    try {

        WsbAssert(0 != ppCollection, E_POINTER);
        *ppCollection = m_pTotals;
        if (m_pTotals != 0 )  {
            m_pTotals->AddRef();
        }

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmJobWorkItem::Init(
    IN IHsmJob* pJob
    )

/*++

Implements:

  IHsmSessionPriv::Init().

--*/
{
    m_pJob = pJob;

    return(S_OK);
}


HRESULT
CHsmJobWorkItem::Load(
    IN IStream* pStream
    )

/*++

Implements:

  IPersistStream::Load().

--*/
{
    HRESULT                     hr = S_OK;
    CComPtr<IPersistStream>     pPersistStream;

    WsbTraceIn(OLESTR("CHsmJobWorkItem::Load"), OLESTR(""));

    try {
        ULONG ul_tmp;

        WsbAssert(0 != pStream, E_POINTER);
        
        // Do the easy stuff, but make sure that this order matches the order
        // in the load method.
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_currentPath, 0));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_finishTime));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_resourceId));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_startingPath, 0));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_startTime));
        WsbAffirmHr(WsbLoadFromStream(pStream, &ul_tmp));
        m_state = static_cast<HSM_JOB_STATE>(ul_tmp);
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_subRunId));

        WsbAffirmHr(m_pPhases->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
        WsbAffirmHr(pPersistStream->Load(pStream));
        pPersistStream = 0;

        WsbAffirmHr(m_pTotals->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
        WsbAffirmHr(pPersistStream->Load(pStream));
        pPersistStream = 0;

        // The session and cookie are not saved, since it is not likely to be alive on the load.
        m_pSession = 0;
        m_cookie = 0;

    } WsbCatch(hr);                                        

    WsbTraceOut(OLESTR("CHsmJobWorkItem::Load"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmJobWorkItem::ProcessSessionState(
    IN IHsmSession* pSession,
    IN IHsmPhase* pPhase,
    IN OLECHAR* currentPath
    )

/*++

Implements:

  IHsmSessionSinkEveryState::ProcessSessionState().

--*/
{
    HRESULT                             hr = S_OK;
    HRESULT                             hrPhase = S_OK;
    CWsbStringPtr                       tmpString;
    CWsbStringPtr                       tmpString2;
    CComPtr<IConnectionPointContainer>  pCPC;
    CComPtr<IConnectionPoint>           pCP;
    CComPtr<IHsmPhase>                  pFoundPhase;
    CComPtr<IHsmPhase>                  pClonedPhase;
    CComPtr<IHsmSessionTotals>          pSessionTotals;
    CComPtr<IHsmSessionTotals>          pClonedTotals;
    CComPtr<IWsbCollection>             pPhases;
    CComPtr<IWsbEnum>                   pEnum;
    CComPtr<IHsmJobPriv>                pJobPriv;
    HSM_JOB_PHASE                       phase;
    HSM_JOB_STATE                       state;

    WsbTraceIn(OLESTR("CHsmJobWorkItem::ProcessSessionState"), OLESTR(""));
    try {

        WsbAssert(0 != pSession, E_POINTER);

        // Tell everyone the new state of the session.
        try {
            WsbAffirmHr(m_pJob->QueryInterface(IID_IHsmJobPriv, (void**) &pJobPriv));
            WsbAffirmHr(pJobPriv->AdviseOfSessionState(pSession, pPhase, currentPath));
        } WsbCatch(hr);

        // We only keep track of the ones that are for the session as a whole.
        WsbAffirmHr(pPhase->GetPhase(&phase));
        WsbAffirmHr(pPhase->GetState(&state));

        WsbAffirmHr(pPhase->GetName(&tmpString, 0));
        WsbAffirmHr(pPhase->GetStateAsString(&tmpString2, 0));
        WsbTrace(OLESTR("CHsmJobWorkItem::ProcessSessionState - Phase = <%ls>, State = <%ls>\n"), (OLECHAR *)tmpString, (OLECHAR *)tmpString2);

        if (HSM_JOB_PHASE_ALL == phase) {

            m_currentPath = currentPath;
            m_state = state;

            // If the session has finished, then we have some cleanup to do so that it can go
            // away.
            if (HSM_JOB_STATE_IS_DONE(state)) {

                //  Do the post-scan action, if any
                WsbAffirmHr(DoPostScan());
            
                WsbAffirmHr(CoFileTimeNow(&m_finishTime));

                // Collect all the phase and session totals information so that it can be
                // persistsed for later use.
                try {

                    WsbAffirmHr(pSession->EnumPhases(&pEnum));

                    for (hrPhase = pEnum->First(IID_IHsmPhase, (void**) &pFoundPhase);
                         SUCCEEDED(hrPhase);
                         hrPhase = pEnum->Next(IID_IHsmPhase, (void**) &pFoundPhase)) {

                        // Create the new instance.
                        WsbAffirmHr(CoCreateInstance(CLSID_CHsmPhase, 0, CLSCTX_ALL, IID_IHsmPhase, (void**) &pClonedPhase));

                        // Fill it in with the new values.
                        WsbAffirmHr(pFoundPhase->CopyTo(pClonedPhase));
                        WsbAffirmHr(m_pPhases->Add(pClonedPhase));

                        pFoundPhase = 0;
                        pClonedPhase = 0;
                    }

                    WsbAssert(hrPhase == WSB_E_NOTFOUND, hrPhase);
                    pEnum = 0;

                    WsbAffirmHr(pSession->EnumTotals(&pEnum));

                    for (hrPhase = pEnum->First(IID_IHsmSessionTotals, (void**) &pSessionTotals);
                         SUCCEEDED(hrPhase);
                         hrPhase = pEnum->Next(IID_IHsmSessionTotals, (void**) &pSessionTotals)) {

                        WsbAffirmHr(pSessionTotals->GetName(&tmpString, 0));
                        WsbTrace(OLESTR("CHsmJobWorkItem::ProcessSessionState - Copying session totals <%ls>\n"), (OLECHAR *)tmpString);

                        // Create the new instance.
                        WsbAffirmHr(CoCreateInstance(CLSID_CHsmSessionTotals, 0, CLSCTX_ALL, IID_IHsmSessionTotals, (void**) &pClonedTotals));

                        // Fill it in with the new values.
                        WsbAffirmHr(pSessionTotals->CopyTo(pClonedTotals));
                        WsbAffirmHr(m_pTotals->Add(pClonedTotals));

                        pSessionTotals = 0;
                        pClonedTotals = 0;
                    }

                    WsbAssert(hrPhase == WSB_E_NOTFOUND, hrPhase);
                    pEnum = 0;

                } WsbCatch(hr)

                if (0 != m_cookie)  {
                    // Tell the session that we don't want to be advised anymore.
                    WsbAffirmHr(pSession->QueryInterface(IID_IConnectionPointContainer, (void**) &pCPC));
                    WsbAffirmHr(pCPC->FindConnectionPoint(IID_IHsmSessionSinkEveryState, &pCP));
                    WsbAffirmHr(pCP->Unadvise(m_cookie));
                } else  {
                    WsbTrace(OLESTR("CHsmJobWorkItem::ProcessSessionState - cookie was 0 so didn't unadvise.\n"));
                }
                

                // Let the session object go away.
                m_pSession = 0;
                m_cookie = 0;

                m_bActive = FALSE;

                // See if there is anymore work to do for this job.
                WsbAffirmHr(pJobPriv->DoNext());
            }
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmJobWorkItem::ProcessSessionState"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}


HRESULT
CHsmJobWorkItem::Save(
    IN IStream* pStream,
    IN BOOL clearDirty
    )

/*++

Implements:

  IPersistStream::Save().

--*/
{
    HRESULT                 hr = S_OK;
    CComPtr<IWsbEnum>       pEnum;
    CComPtr<IPersistStream> pPersistStream;

    WsbTraceIn(OLESTR("CHsmJobWorkItem::Save"), OLESTR("clearDirty = <%ls>"), WsbBoolAsString(clearDirty));
    
    try {
        WsbAssert(0 != pStream, E_POINTER);
        
        // Do the easy stuff, but make sure that this order matches the order
        // in the load method.
        WsbAffirmHr(WsbSaveToStream(pStream, m_currentPath));
        WsbAffirmHr(WsbSaveToStream(pStream, m_finishTime));
        WsbAffirmHr(WsbSaveToStream(pStream, m_resourceId));
        WsbAffirmHr(WsbSaveToStream(pStream, m_startingPath));
        WsbAffirmHr(WsbSaveToStream(pStream, m_startTime));
        WsbAffirmHr(WsbSaveToStream(pStream, static_cast<ULONG>(m_state)));
        WsbAffirmHr(WsbSaveToStream(pStream, m_subRunId));

        WsbAffirmHr(m_pPhases->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
        WsbAffirmHr(pPersistStream->Save(pStream, clearDirty));
        pPersistStream = 0;

        WsbAffirmHr(m_pTotals->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
        WsbAffirmHr(pPersistStream->Save(pStream, clearDirty));
        pPersistStream = 0;

        // The session and cookie are not saved, since it is not likely to be alive on the load.

        // If we got it saved and we were asked to clear the dirty bit, then
        // do so now.
        if (clearDirty) {
            m_isDirty = FALSE;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmJobWorkItem::Save"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmJobWorkItem::Test(
    USHORT* passed,
    USHORT* failed
    )

/*++

Implements:

  IWsbTestable::Test().

--*/
{
    HRESULT     hr = S_OK;

    try {

        WsbAssert(0 != passed, E_POINTER);
        WsbAssert(0 != failed, E_POINTER);

        *passed = 0;
        *failed = 0;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmJobWorkItem::SetCookie(
    IN DWORD cookie
    )
/*++

Implements:

  IHsmJobWorkItem::SetCookie().

--*/
{
    WsbTraceIn(OLESTR("CHsmJobWorkItem::SetCookie"), OLESTR(""));
    
    HRESULT hr = S_OK;
    m_cookie = cookie;
        
    WsbTraceOut(OLESTR("CHsmJobWorkItem::SetCookie"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}


HRESULT
CHsmJobWorkItem::SetCurrentPath(
    IN OLECHAR* path
    )
/*++

Implements:

  IHsmJobWorkItem::SetCurrentPath().

--*/
{
    m_currentPath = path;

    return(S_OK);
}


HRESULT
CHsmJobWorkItem::SetFinishTime(
    IN FILETIME time
    )
/*++

Implements:

  IHsmJobWorkItem::SetFinishTime().

--*/
{
    m_finishTime = time;

    return(S_OK);
}


HRESULT
CHsmJobWorkItem::SetResourceId(
    IN GUID id
    )
/*++

Implements:

  IHsmJobWorkItem::SetResourceId().

--*/
{
    m_resourceId = id;

    return(S_OK);
}


HRESULT
CHsmJobWorkItem::SetSession(
    IN IHsmSession* pSession
    )
/*++

Implements:

  IHsmJobWorkItem::SetSession().

--*/
{
    HRESULT         hr = S_OK;

    if (m_pSession != 0)  {
        m_pSession = 0;
    }
    m_pSession = pSession;

    return(hr);
}


HRESULT
CHsmJobWorkItem::SetStartingPath(
    IN OLECHAR* path
    )
/*++

Implements:

  IHsmJobWorkItem::SetStartingPath().

--*/
{
    m_startingPath = path;

    return(S_OK);
}


HRESULT
CHsmJobWorkItem::SetStartTime(
    IN FILETIME time
    )
/*++

Implements:

  IHsmJobWorkItem::SetStartTime().

--*/
{
    m_startTime = time;

    return(S_OK);
}


HRESULT
CHsmJobWorkItem::SetState(
    IN HSM_JOB_STATE state
    )
/*++

Implements:

  IHsmJobWorkItem::SetState().

--*/
{
    m_state = state;
    return(S_OK);
}


HRESULT
CHsmJobWorkItem::SetSubRunId(
    IN ULONG id
    )
/*++

Implements:

  IHsmJobWorkItem::SetSubRunId().

--*/
{
    m_subRunId = id;

    return(S_OK);
}

HRESULT
CHsmJobWorkItem::IsActiveItem(
    void
    )

/*++

Implements:

  IHsmJobWorkItemPriv::IsActiveItem().

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CHsmJobWorkItem::IsActiveItem"), OLESTR(""));
    
    hr = (m_bActive ? S_OK : S_FALSE);
    
    WsbTraceOut(OLESTR("CHsmJobWorkItem::IsActiveItem"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return hr;
}

HRESULT
CHsmJobWorkItem::SetActiveItem(
    BOOL bActive
    )

/*++

Implements:

  IHsmJobWorkItemPriv::SetActiveItem().

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn( OLESTR("CHsmJobWorkItem::SetActiveItem"), OLESTR("bActive = %ls"), 
        WsbBoolAsString(bActive) );
    
    m_bActive = bActive;
    
    WsbTraceOut(OLESTR("CHsmJobWorkItem::SetActiveItem"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\job\hsmpolcy.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    hsmpolcy.cpp

Abstract:

    This component represents a job's policy.

Author:

    Chuck Bardeen   [cbardeen]   29-Oct-1996

Revision History:

--*/

#include "stdafx.h"

#include "wsb.h"
#include "job.h"
#include "hsmpolcy.h"

#define WSB_TRACE_IS        WSB_TRACE_BIT_JOB


HRESULT
CHsmPolicy::CompareTo(
    IN IUnknown* pUnknown,
    OUT SHORT* pResult
    )

/*++

Implements:

  IWsbCollectable::CompareTo().

--*/
{
    HRESULT             hr = S_OK;
    CComPtr<IHsmPolicy> pPolicy;

    WsbTraceIn(OLESTR("CHsmPolicy::CompareTo"), OLESTR(""));
    
    try {

        // Did they give us a valid item to compare to?
        WsbAssert(0 != pUnknown, E_POINTER);

        // We need the IWsbBool interface to get the value of the object.
        WsbAffirmHr(pUnknown->QueryInterface(IID_IHsmPolicy, (void**) &pPolicy));

        // Compare the rules.
        hr = CompareToIPolicy(pPolicy, pResult);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmPolicy::CompareTo"), OLESTR("hr = <%ls>, result = <%ls>"), WsbHrAsString(hr), WsbPtrToShortAsString(pResult));

    return(hr);
}


HRESULT
CHsmPolicy::CompareToIPolicy(
    IN IHsmPolicy* pPolicy,
    OUT SHORT* pResult
    )

/*++

Implements:

  IHsmPolicy::CompareToIPolicy().

--*/
{
    HRESULT     hr = S_OK;
    GUID        id;

    WsbTraceIn(OLESTR("CHsmPolicy::CompareToIPolicy"), OLESTR(""));

    try {

        // Did they give us a valid item to compare to?
        WsbAssert(0 != pPolicy, E_POINTER);

        // Get the path and name.
        WsbAffirmHr(pPolicy->GetIdentifier(&id));

        // Compare to the path and name.
        hr = CompareToIdentifier(id, pResult);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmPolicy::CompareToIPolicy"), OLESTR("hr = <%ls>, result = <%ls>"), WsbHrAsString(hr), WsbPtrToShortAsString(pResult));

    return(hr);
}


HRESULT
CHsmPolicy::CompareToIdentifier(
    IN GUID id,
    OUT SHORT* pResult
    )

/*++

Implements:

  IHsmPolicy::CompareToIdentifier().

--*/
{
    HRESULT     hr = S_OK;
    SHORT       aResult = 0;

    WsbTraceIn(OLESTR("CHsmPolicy::CompareToIdentifier"), OLESTR("id = <%ls>"), WsbGuidAsString(id));

    try {

        // Compare the guids.
        aResult = WsbSign( memcmp(&m_id, &id, sizeof(GUID)) );

        if (0 != aResult) {
            hr = S_FALSE;
        }
        
        if (0 != pResult) {
            *pResult = aResult;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmPolicy::CompareToIdentifier"), OLESTR("hr = <%ls>, result = <%d>"), WsbHrAsString(hr), aResult);

    return(hr);
}


HRESULT
CHsmPolicy::EnumRules(
    OUT IWsbEnum** ppEnum
    )

/*++

Implements:

  IHsmPolicy::EnumRules().

--*/
{
    HRESULT     hr = S_OK;

    try {
        WsbAssert(0 != ppEnum, E_POINTER);
        WsbAffirmHr(m_pRules->Enum(ppEnum));
    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmPolicy::FinalConstruct(
    void
    )
/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;
    
    try {
        WsbAffirmHr(CWsbObject::FinalConstruct());

        m_scale = 1000;
        m_usesDefaultRules = FALSE;
    
        //Create the criteria collection.
        WsbAffirmHr(CoCreateInstance(CLSID_CWsbOrderedCollection, NULL, CLSCTX_ALL, IID_IWsbCollection, (void**) &m_pRules));

        // Each instance should have its own unique identifier.
        WsbAffirmHr(CoCreateGuid(&m_id));

    } WsbCatch(hr);
    
    return(hr);
}


HRESULT
CHsmPolicy::GetAction(
    OUT IHsmAction** ppAction
    )
/*++

Implements:

  IHsmPolicy::GetAction().

--*/
{
    HRESULT     hr = S_OK;

    try {

        WsbAssert(0 != ppAction, E_POINTER);
        *ppAction = m_pAction;
        m_pAction->AddRef();

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmPolicy::GetClassID(
    OUT CLSID* pClsid
    )

/*++

Implements:

  IPersist::GetClassID().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmPolicy::GetClassID"), OLESTR(""));

    try {

        WsbAssert(0 != pClsid, E_POINTER);
        *pClsid = CLSID_CHsmPolicy;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmPolicy::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return(hr);
}


HRESULT
CHsmPolicy::GetIdentifier(
    OUT GUID* pId
    )
/*++

Implements:

  IHsmPolicy::GetIdentifier().

--*/
{
    HRESULT     hr = S_OK;

    try {
        WsbAssert(0 != pId, E_POINTER);
        *pId = m_id;
    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmPolicy::GetName(
    OUT OLECHAR** pName,
    IN ULONG bufferSize
    )
/*++

Implements:

  IHsmPolicy::GetName().

--*/
{
    HRESULT     hr = S_OK;

    try {
        WsbAssert(0 != pName, E_POINTER);
        WsbAffirmHr(m_name.CopyTo(pName, bufferSize));
    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmPolicy::GetScale(
    OUT USHORT* pScale
    )
/*++

Implements:

  IHsmPolicy::GetScale().

--*/
{
    HRESULT     hr = S_OK;

    try {
        WsbAssert(0 != pScale, E_POINTER);
        *pScale = m_scale;
    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmPolicy::GetSizeMax(
    OUT ULARGE_INTEGER* pSize
    )

/*++

Implements:

  IPersistStream::GetSizeMax().

--*/
{
    HRESULT                 hr = S_OK;
    CComPtr<IPersistStream> pPersistStream;
    ULARGE_INTEGER          entrySize;


    WsbTraceIn(OLESTR("CHsmPolicy::GetSizeMax"), OLESTR(""));

    try {

        WsbAssert(0 != pSize, E_POINTER);

        // Determine the size for a rule with no criteria.
        pSize->QuadPart = WsbPersistSize((wcslen(m_name) + 1) * sizeof(OLECHAR)) + WsbPersistSizeOf(GUID) + WsbPersistSizeOf(USHORT) + 2 * WsbPersistSizeOf(BOOL);

        // If there is an action, how big is it?
        if (m_pAction != 0) {
            WsbAffirmHr(m_pAction->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
            WsbAffirmHr(pPersistStream->GetSizeMax(&entrySize));
            pSize->QuadPart += entrySize.QuadPart;
            pPersistStream = 0;
        }

        // Now allocate space for the rules (assume they are all the
        // same size).
        WsbAffirmHr(m_pRules->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
        WsbAffirmHr(pPersistStream->GetSizeMax(&entrySize));
        pSize->QuadPart += entrySize.QuadPart;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmPolicy::GetSizeMax"), OLESTR("hr = <%ls>, Size = <%ls>"), WsbHrAsString(hr), WsbPtrToUliAsString(pSize));

    return(hr);
}


HRESULT
CHsmPolicy::Load(
    IN IStream* pStream
    )

/*++

Implements:

  IPersistStream::Load().

--*/
{
    HRESULT                     hr = S_OK;
    CComPtr<IPersistStream>     pPersistStream;
    BOOL                        hasAction;

    WsbTraceIn(OLESTR("CHsmPolicy::Load"), OLESTR(""));

    try {
        WsbAssert(0 != pStream, E_POINTER);
        
        // Do the easy stuff, but make sure that this order matches the order
        // in the save method.
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_id));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_name, 0));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_scale));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_usesDefaultRules));

        // Is there an action?
        WsbAffirmHr(WsbLoadFromStream(pStream, &hasAction));
        if (hasAction) {
            WsbAffirmHr(OleLoadFromStream(pStream, IID_IHsmAction, (void**) &m_pAction));
        }

        WsbAffirmHr(m_pRules->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
        WsbAffirmHr(pPersistStream->Load(pStream));

    } WsbCatch(hr);                                        

    WsbTraceOut(OLESTR("CHsmPolicy::Load"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmPolicy::Rules(
    OUT IWsbCollection** ppRules
    )
/*++

Implements:

  IHsmPolicy::Rules().

--*/
{
    HRESULT     hr = S_OK;

    try {

        WsbAssert(0 != ppRules, E_POINTER);
        *ppRules = m_pRules;
        m_pRules->AddRef();

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmPolicy::Save(
    IN IStream* pStream,
    IN BOOL clearDirty
    )

/*++

Implements:

  IPersistStream::Save().

--*/
{
    HRESULT                 hr = S_OK;
    CComPtr<IWsbEnum>       pEnum;
    CComPtr<IPersistStream> pPersistStream;
    BOOL                    hasAction = FALSE;

    WsbTraceIn(OLESTR("CHsmPolicy::Save"), OLESTR("clearDirty = <%ls>"), WsbBoolAsString(clearDirty));
    
    try {
        WsbAssert(0 != pStream, E_POINTER);
        
        // Do the easy stuff, but make sure that this order matches the order
        // in the save method.
        WsbAffirmHr(WsbSaveToStream(pStream, m_id));
        WsbAffirmHr(WsbSaveToStream(pStream, m_name));
        WsbAffirmHr(WsbSaveToStream(pStream, m_scale));
        WsbAffirmHr(WsbSaveToStream(pStream, m_usesDefaultRules));

        // Is there an action?
        if (m_pAction != 0) {
            hasAction = TRUE;
            WsbAffirmHr(WsbSaveToStream(pStream, hasAction));
            WsbAffirmHr(m_pAction->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
            WsbAffirmHr(OleSaveToStream(pPersistStream, pStream));
            pPersistStream = 0;
        } else {
            hasAction = FALSE;
            WsbAffirmHr(WsbSaveToStream(pStream, hasAction));
        }

        WsbAffirmHr(m_pRules->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
        WsbAffirmHr(pPersistStream->Save(pStream, clearDirty));

        // The loop should terminate with a not found error.
        WsbAffirm(hr == WSB_E_NOTFOUND, hr);
        hr = S_OK;

        // If we got it saved and we were asked to clear the dirty bit, then
        // do so now.
        if (clearDirty) {
            m_isDirty = FALSE;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmPolicy::Save"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmPolicy::SetAction(
    IN IHsmAction* pAction
    )
/*++

Implements:

  IHsmPolicy::SetAction().

--*/
{
    HRESULT     hr = S_OK;

    try {
        m_pAction = pAction;
        m_isDirty = TRUE;
    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmPolicy::SetName(
    IN OLECHAR* name
    )
/*++

Implements:

  IHsmPolicy::SetName().

--*/
{
    HRESULT     hr = S_OK;

    try {
        m_name = name;
        m_isDirty = TRUE;
    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmPolicy::SetScale(
    IN USHORT scale
    )
/*++

Implements:

  IHsmPolicy::SetScale().

--*/
{
    HRESULT     hr = S_OK;

    try {
        m_scale = scale;
        m_isDirty = TRUE;
    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmPolicy::SetUsesDefaultRules(
    IN BOOL usesDefaultRules
    )
/*++

Implements:

  IHsmPolicy::SetUsesDefaultRules().

--*/
{
    m_usesDefaultRules = usesDefaultRules;
    m_isDirty = TRUE;

    return(S_OK);
}


HRESULT
CHsmPolicy::Test(
    USHORT* passed,
    USHORT* failed
    )

/*++

Implements:

  IWsbTestable::Test().

--*/
{
    HRESULT     hr = S_OK;

    try {

        WsbAssert(0 != passed, E_POINTER);
        WsbAssert(0 != failed, E_POINTER);

        *passed = 0;
        *failed = 0;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmPolicy::UsesDefaultRules(
    void
    )
/*++

Implements:

  IHsmPolicy::UsesDefaultRules().

--*/
{
    HRESULT     hr = S_OK;

    if (!m_usesDefaultRules) {
        hr = S_FALSE;
    }

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\job\hsmpolcy.h ===
#ifndef _HSMPOLCY_
#define _HSMPOLCY_

/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    hsmrule.cpp

Abstract:

    This component represents a job's policy.

Author:

    Chuck Bardeen   [cbardeen]   29-Oct-1996

Revision History:

--*/

#include "resource.h"       // main symbols

#include "wsb.h"


/*++

Class Name:
    
    CHsmPolicy

Class Description:

    This component represents a job's policy.

--*/

class CHsmPolicy : 
    public IHsmPolicy,
    public CWsbObject,
    public CComCoClass<CHsmPolicy,&CLSID_CHsmPolicy>
{
public:
    CHsmPolicy() {}
BEGIN_COM_MAP(CHsmPolicy)
    COM_INTERFACE_ENTRY(IHsmPolicy)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IWsbCollectable)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_CHsmPolicy)

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);

// IPersistStream
public:
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER* pSize);
    STDMETHOD(Load)(IStream* pStream);
    STDMETHOD(Save)(IStream* pStream, BOOL clearDirty);

// IWsbCollectable
public:
    STDMETHOD(CompareTo)(IUnknown* pUnknown, SHORT* pResult);

// IWsbTestable
    STDMETHOD(Test)(USHORT *passed, USHORT* failed);

// IHsmPolicy
public:
    STDMETHOD(CompareToIdentifier)(GUID id, SHORT* pResult);
    STDMETHOD(CompareToIPolicy)(IHsmPolicy* pPolicy, SHORT* pResult);
    STDMETHOD(EnumRules)(IWsbEnum** ppEnum);
    STDMETHOD(GetAction)(IHsmAction** ppAction);
    STDMETHOD(GetIdentifier)(GUID* pId);
    STDMETHOD(GetName)(OLECHAR** pName, ULONG bufferSize);
    STDMETHOD(GetScale)(USHORT* pScale);
    STDMETHOD(Rules)(IWsbCollection** ppWsbCollection);
    STDMETHOD(SetAction)(IHsmAction* pAction);
    STDMETHOD(SetName)(OLECHAR* name);
    STDMETHOD(SetScale)(USHORT scale);
    STDMETHOD(SetUsesDefaultRules)(BOOL usesDefaults);
    STDMETHOD(UsesDefaultRules)(void);

protected:
    GUID                        m_id;
    CWsbStringPtr               m_name;
    USHORT                      m_scale;
    BOOL                        m_usesDefaultRules;
    CComPtr<IHsmAction>         m_pAction;
    CComPtr<IWsbCollection>     m_pRules;
};

#endif // _HSMPOLCY_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\job\hsmphase.h ===
#ifndef _HSMPHASE_
#define _HSMPHASE_

/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    hsmsesst.h

Abstract:

    This class is the phase component, which keeps track the status/totals for a phase of a
    session.

Author:

    Chuck Bardeen   [cbardeen]   14-Feb-1997

Revision History:

--*/

#include "resource.h"       // main symbols

#include "wsb.h"
#include "job.h"

/*++

Class Name:
    
    CHsmPhase

    This class is the phase component, which keeps track the status/totals for a phase of a
    session.

Class Description:


--*/

class CHsmPhase : 
    public CWsbObject,
    public IHsmPhase,
    public IHsmPhasePriv,
    public CComCoClass<CHsmPhase,&CLSID_CHsmPhase>
{
public:
    CHsmPhase() {} 

BEGIN_COM_MAP(CHsmPhase)
    COM_INTERFACE_ENTRY(IHsmPhase)
    COM_INTERFACE_ENTRY(IHsmPhasePriv)
    COM_INTERFACE_ENTRY(IWsbCollectable)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()
                        
DECLARE_REGISTRY_RESOURCEID(IDR_CHsmPhase)

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);
    void FinalRelease(void);

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);

// IPersistStream
public:
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER* pSize);
    STDMETHOD(Load)(IStream* pStream);
    STDMETHOD(Save)(IStream* pStream, BOOL clearDirty);

// IWsbCollectable
public:
    STDMETHOD(CompareTo)(IUnknown* pUnknown, SHORT* pResult);

// IWsbTestable
public:
    STDMETHOD(Test)(USHORT *passed, USHORT* failed);

// IHsmPhase
public:
    STDMETHOD(Clone)(IHsmPhase** ppPhase);
    STDMETHOD(CompareToPhase)(HSM_JOB_PHASE phase, SHORT* pResult);
    STDMETHOD(CompareToIPhase)(IHsmPhase* pPhase, SHORT* pResult);
    STDMETHOD(CopyTo)(IHsmPhase* pPhase);
    STDMETHOD(GetElapsedTime)(ULONG* pDays, USHORT* pHours, USHORT* pMinutes, USHORT* pSeconds);
    STDMETHOD(GetMediaState)(HSM_JOB_MEDIA_STATE* pState);
    STDMETHOD(GetMediaStateAsString)(OLECHAR** pName, ULONG bufferSize);
    STDMETHOD(GetName)(OLECHAR** pName, ULONG bufferSize);
    STDMETHOD(GetPhase)(HSM_JOB_PHASE* pPhase);
    STDMETHOD(GetPriority)(HSM_JOB_PRIORITY* pPriority);
    STDMETHOD(GetPriorityAsString)(OLECHAR** pName, ULONG bufferSize);
    STDMETHOD(GetState)(HSM_JOB_STATE* pState);
    STDMETHOD(GetStateAsString)(OLECHAR** pName, ULONG bufferSize);
    STDMETHOD(GetStats)(LONGLONG* pItems, LONGLONG* pSize, LONGLONG* pSkippedItems, LONGLONG* pSkippedSize, LONGLONG* errorItems, LONGLONG* errorSize);
    STDMETHOD(GetStartTime)(FILETIME* pTime);
    STDMETHOD(GetStopTime)(FILETIME* pTime);

// IHsmPhasePriv
    STDMETHOD(AddItem)(IFsaScanItem* pItem, HRESULT hrItem);
    STDMETHOD(Clone)(IHsmPhasePriv** ppPhasePriv);
    STDMETHOD(CopyTo)(IHsmPhasePriv* pPhasePriv);
    STDMETHOD(SetInternalStuff)(ULONG mountCount, ULONG transferCount, LONGLONG elapsedTime, FILETIME startTime, FILETIME restartTime, FILETIME stopTime);
    STDMETHOD(SetPhase)(HSM_JOB_PHASE phase);
    STDMETHOD(SetMediaState)(HSM_JOB_MEDIA_STATE state);
    STDMETHOD(SetPriority)(HSM_JOB_PRIORITY priority);
    STDMETHOD(SetState)(HSM_JOB_STATE state);
    STDMETHOD(SetStats)(LONGLONG items, LONGLONG size, LONGLONG skippedItems, LONGLONG skippedSize, LONGLONG errorItems, LONGLONG errorSize);

protected:
    HSM_JOB_MEDIA_STATE m_mediaState;
    ULONG               m_mountCount;
    ULONG               m_transferCount;
    HSM_JOB_PHASE       m_phase;
    HSM_JOB_PRIORITY    m_priority;
    HSM_JOB_STATE       m_state;
    LONGLONG            m_items;
    LONGLONG            m_size;
    LONGLONG            m_skippedItems;
    LONGLONG            m_skippedSize;
    LONGLONG            m_errorItems;
    LONGLONG            m_errorSize;
    LONGLONG            m_elapsedTime;
    FILETIME            m_startTime;
    FILETIME            m_restartTime;
    FILETIME            m_stopTime;
};

#endif // _HSMPHASE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\job\hsmrlstk.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    hsmrlstk.cpp

Abstract:

    This component represents the set of rules that are in effect for directory currently
    being scanned for one policy.

Author:

    Chuck Bardeen   [cbardeen]   29-Oct-1996

Revision History:

--*/

#include "stdafx.h"

#include "wsb.h"
#include "job.h"
#include "hsmrlstk.h"

#define WSB_TRACE_IS        WSB_TRACE_BIT_JOB


HRESULT
CHsmRuleStack::Do(
    IN IFsaScanItem* pScanItem
    )
/*++

Implements:

  IHsmRuleStack::Do().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmRuleStack::Do"), OLESTR(""));

    try {
        WsbAssert(0 != pScanItem, E_POINTER);
        WsbAssert(m_pAction != 0, E_UNEXPECTED);

        WsbAffirmHr(m_pAction->Do(pScanItem));
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmRuleStack::Do"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmRuleStack::DoesMatch(
    IN IFsaScanItem* pScanItem,
    OUT BOOL* pShouldDo
    )
/*++

Implements:

  IHsmRuleStack::DoesMatch().

--*/
{
    HRESULT                 hr = S_OK;
    HRESULT                 hrNameMatch = S_OK;     // Used for event logging only
    CComPtr<IWsbEnum>       pEnumCriteria;
    CComPtr<IHsmRule>       pRule;
    CComPtr<IHsmCriteria>   pCriteria;
    BOOL                    isMatched = FALSE;
    BOOL                    ruleMatched = FALSE;    // Used for event logging only
    BOOL                    shouldCheck;
    CWsbStringPtr           name;
    CWsbStringPtr           path;
    CWsbStringPtr           rulePath;
    BOOL                    shouldDo = FALSE;

    WsbTraceIn(OLESTR("CHsmRuleStack::DoesMatch"), OLESTR(""));

    try {

        WsbAssert(0 != pScanItem, E_POINTER);
        WsbAssert(0 != pShouldDo, E_POINTER);

        *pShouldDo = FALSE;

        // NOTE: The matching code starts at the bottom of the list and looks for
        // the first rule that matches. This makes it important how the list is organized.
        // Currently, the Push() method does not make any attempts to organize the list, so
        // it is up to whoever configure the rules in the policy definition to have it
        // organized properly. A proper order within a directory would be to have the specific
        // rules (i.e. no wildcards) after the wildcard rules (i.e. specific searched first).

        // Start we the last rule in the collection, and search upwards until a
        // rule is found that matches or all rules have been checked.
        WsbAffirmHr(pScanItem->GetName(&name, 0));
        hr = m_pEnumStackRules->Last(IID_IHsmRule, (void**) &pRule);

        while (SUCCEEDED(hr) && !isMatched) {

            try {

                shouldCheck = TRUE;
            
                // If the rule only applies to the directory it was defined in, then make
                // sure that the item is from that directory.
                if (pRule->IsUsedInSubDirs() == S_FALSE) {

                    // Unfortunately, these two paths differ by an appended \ when they
                    // are otherwise the same, so make them the same.
                    WsbAffirmHr(pScanItem->GetPath(&path, 0));

                    if ((wcslen(path) > 1) && (path[(int) (wcslen(path) - 1)] == L'\\')) {
                        path[(int) (wcslen(path) - 1)] = 0;
                    }

                    rulePath.Free();
                    WsbAffirmHr(pRule->GetPath(&rulePath, 0));

                    if ((wcslen(rulePath) > 1) && (rulePath[(int) (wcslen(rulePath) - 1)] == L'\\')) {
                        rulePath[(int) (wcslen(rulePath) - 1)] = 0;
                    }

                    if (_wcsicmp(path, rulePath) != 0) {
                        shouldCheck = FALSE;
                    }
                }

                if (shouldCheck) {

                    
                    // Does the name of the rule match the name of the file?
                    hrNameMatch = pRule->MatchesName(name);
                    WsbAffirmHrOk(hrNameMatch);
                    
                    ruleMatched = TRUE;
                    // Do the criteria match the attributes of the file?
                    isMatched = TRUE;
                    pEnumCriteria = 0;
                    WsbAffirmHr(pRule->EnumCriteria(&pEnumCriteria));
                    pCriteria = 0;
                    WsbAffirmHr(pEnumCriteria->First(IID_IHsmCriteria, (void**) &pCriteria));
                    
                    while (isMatched) {
                        HRESULT hrShouldDo;

                        hrShouldDo = pCriteria->ShouldDo(pScanItem, m_scale);
                        if (S_FALSE == hrShouldDo) {
                            isMatched = FALSE;
                        } else if (S_OK == hrShouldDo) {
                            pCriteria = 0;
                            WsbAffirmHr(pEnumCriteria->Next(IID_IHsmCriteria, (void**) &pCriteria));
                        } else {
                            WsbThrow(hrShouldDo);
                        }
                    }
                }

            } WsbCatchAndDo(hr, if (WSB_E_NOTFOUND == hr) {hr = S_OK;} else {isMatched = FALSE;});

            // If it didn't match, then try the next rule.
            if (SUCCEEDED(hr) && !isMatched) {
                pRule = 0;
                WsbAffirmHr(m_pEnumStackRules->Previous(IID_IHsmRule, (void**) &pRule));
            }
        }

        // Include rules mean that we should do the operation and exclude rules
        // mean that we should not.
        if (SUCCEEDED(hr)) {
            if (isMatched) {
                hr = S_OK;
                if (pRule->IsInclude() == S_OK) {
                    shouldDo = TRUE;
                }
            } else {
                hr = S_FALSE;
            }
        }
        
        
        if ((FALSE == shouldDo) && (FALSE == ruleMatched))  {
            //
            // Log that we skipped the file because it didn't
            // match a rule
            //
            CWsbStringPtr           jobName;
            CWsbStringPtr           fileName;
            CComPtr<IHsmSession>    pSession;
        
            pScanItem->GetFullPathAndName( 0, 0, &fileName, 0);
            pScanItem->GetSession(&pSession);
            pSession->GetName(&jobName, 0);
        
            WsbLogEvent(JOB_MESSAGE_SCAN_FILESKIPPED_NORULE, 0, NULL, (OLECHAR *)jobName, WsbAbbreviatePath(fileName, 120), WsbHrAsString(hrNameMatch), NULL);
        }
        
        

    *pShouldDo = shouldDo;

    } WsbCatchAndDo(hr, if (WSB_E_NOTFOUND == hr) {hr = S_FALSE;});

    WsbTraceOut(OLESTR("CHsmRuleStack::DoesMatch"), OLESTR("hr = <%ls>, shouldDo = <%ls>"), WsbHrAsString(hr), WsbBoolAsString(shouldDo));

    return(hr);
}


HRESULT
CHsmRuleStack::FinalConstruct(
    void
    )
/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;
    
    try {
        WsbAffirmHr(CWsbObject::FinalConstruct());

        m_scale = HSM_JOBSCALE_100;
        m_usesDefaults = TRUE;

        //Create the criteria collection.
        WsbAffirmHr(CoCreateInstance(CLSID_CWsbOrderedCollection, NULL, CLSCTX_ALL, IID_IWsbCollection, (void**) &m_pRules));
        WsbAffirmHr(m_pRules->Enum(&m_pEnumStackRules));

    } WsbCatch(hr);
    
    return(hr);
}


HRESULT
CHsmRuleStack::GetClassID(
    OUT CLSID* pClsid
    )

/*++

Implements:

  IPersist::GetClassID().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmRuleStack::GetClassID"), OLESTR(""));

    try {

        WsbAssert(0 != pClsid, E_POINTER);
        *pClsid = CLSID_CHsmRuleStack;

    } WsbCatch(hr);
    WsbTraceOut(OLESTR("CHsmRuleStack::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return(hr);
}


HRESULT
CHsmRuleStack::GetSizeMax(
    OUT ULARGE_INTEGER* pSize
    )

/*++

Implements:

  IPersistStream::GetSizeMax().

--*/
{
    HRESULT                 hr = E_NOTIMPL;

    WsbTraceIn(OLESTR("CHsmRuleStack::GetSizeMax"), OLESTR(""));
    WsbTraceOut(OLESTR("CHsmRuleStack::GetSizeMax"), OLESTR("hr = <%ls>, Size = <%ls>"), WsbHrAsString(hr), WsbPtrToUliAsString(pSize));

    return(hr);
}


HRESULT
CHsmRuleStack::Init(
    IN IHsmPolicy* pPolicy,
    IN IFsaResource* pResource
    )
/*++

Implements:

  IHsmRuleStack::Init().

--*/
{
    HRESULT     hr = S_OK;

    try {

        WsbAssert(0 != pPolicy, E_POINTER);

        WsbAffirmHr(pPolicy->GetScale(&m_scale));
        WsbAffirmHr(pPolicy->GetAction(&m_pAction));
        WsbAffirmHr(pPolicy->EnumRules(&m_pEnumPolicyRules));

        if (pPolicy->UsesDefaultRules() == S_OK) {
            m_usesDefaults = TRUE;
        } else {
            m_usesDefaults = FALSE;
        }

        m_pPolicy = pPolicy;

        WsbAffirmHr(pResource->EnumDefaultRules(&m_pEnumDefaultRules));

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmRuleStack::Load(
    IN IStream* /*pStream*/
    )

/*++

Implements:

  IPersistStream::Load().

--*/
{
    HRESULT                     hr = E_NOTIMPL;

    WsbTraceIn(OLESTR("CHsmRuleStack::Load"), OLESTR(""));
    WsbTraceOut(OLESTR("CHsmRuleStack::Load"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmRuleStack::Pop(
    IN OLECHAR* path
    )
/*++

Implements:

  IHsmRuleStack::Pop().

--*/
{
    HRESULT             hr = S_OK;
    CWsbStringPtr       rulePath;
    CComPtr<IHsmRule>   pRule;

    WsbTraceIn(OLESTR("CHsmRuleStack::Pop"), OLESTR(""));

    try {

        WsbAssert(0 != path, E_POINTER);

        // Starting at the end of the list, remove any rules that have the same
        // path as the one specified.
        WsbAffirmHr(m_pEnumStackRules->Last(IID_IHsmRule, (void**) &pRule));
        WsbAffirmHr(pRule->GetPath(&rulePath, 0));

        while(_wcsicmp(path, rulePath) == 0) {
            WsbAffirmHr(m_pRules->RemoveAndRelease(pRule));
            pRule = 0;
            WsbAffirmHr(m_pEnumStackRules->Last(IID_IHsmRule, (void**) &pRule));
            rulePath.Free();
            WsbAffirmHr(pRule->GetPath(&rulePath, 0));
        }

    } WsbCatchAndDo(hr, if (WSB_E_NOTFOUND == hr) {hr = S_OK;});

    WsbTraceOut(OLESTR("CHsmRuleStack::Pop"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmRuleStack::Push(
    IN OLECHAR* path
    )
/*++

Implements:

  IHsmRuleStack::Push().

--*/
{
    HRESULT                         hr = S_OK;
    CWsbStringPtr                   rulePath;
    CComPtr<IHsmRule>               pRule;
    CComPtr<IWsbIndexedCollection>  pCollection;

    WsbTraceIn(OLESTR("CHsmRuleStack::Push"), OLESTR(""));

    try {

        WsbAssert(0 != path, E_POINTER);

        // We need to preserve the order of the rules, so use the indexed collection interface.
        WsbAffirmHr(m_pRules->QueryInterface(IID_IWsbIndexedCollection, (void**) &pCollection));

        // Add any policy rules for this directory to the stack.
        //
        // NOTE: We may want to add some code to check for exclusion rules of the
        // entire directory (with no subdirectory inclusions and return the
        // JOB_E_DIREXCLUDED error to skip scanning of the directory.
        //
        // NOTE: It might be nice if the policy rules were a sorted collection to
        // speed up processing.
        hr = m_pEnumPolicyRules->First(IID_IHsmRule, (void**) &pRule);
        
        while (SUCCEEDED(hr)) {

            rulePath.Free();
            WsbAffirmHr(pRule->GetPath(&rulePath, 0));
            if (_wcsicmp(path, rulePath) == 0) {
                WsbAffirmHr(pCollection->Append(pRule));
                WsbTrace(OLESTR("CHsmRuleStack::Push - Using policy rule <%ls>.\n"), (OLECHAR *)rulePath);
                
            }

            pRule = 0;
            hr = m_pEnumPolicyRules->Next(IID_IHsmRule, (void**) &pRule);
        }

        if (WSB_E_NOTFOUND == hr) {
            hr = S_OK;
        }

        // Add any default rules for this directory to the stack.
        if (m_usesDefaults) {

            hr = m_pEnumDefaultRules->First(IID_IHsmRule, (void**) &pRule);
            
            while (SUCCEEDED(hr)) {

                rulePath.Free();
                WsbAffirmHr(pRule->GetPath(&rulePath, 0));
                if (_wcsicmp(path, rulePath) == 0) {
                    WsbAffirmHr(pCollection->Append(pRule));
                    WsbTrace(OLESTR("CHsmRuleStack::Push -- Using default rule <%ls>.\n"), (OLECHAR *)rulePath);
                }

                pRule = 0;
                hr = m_pEnumDefaultRules->Next(IID_IHsmRule, (void**) &pRule);
            }
        } else  {
            WsbTrace(OLESTR("CHsmRuleStack::Push -- Not using default rules.\n"));
            
        }

        if (WSB_E_NOTFOUND == hr) {
            hr = S_OK;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmRuleStack::Push"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    
    return(hr);
}


HRESULT
CHsmRuleStack::Save(
    IN IStream* /*pStream*/,
    IN BOOL clearDirty
    )

/*++

Implements:

  IPersistStream::Save().

--*/
{
    HRESULT                 hr = E_NOTIMPL;

    WsbTraceIn(OLESTR("CHsmRuleStack::Save"), OLESTR("clearDirty = <%ls>"), WsbBoolAsString(clearDirty));
    WsbTraceOut(OLESTR("CHsmRuleStack::Save"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmRuleStack::Test(
    USHORT* passed,
    USHORT* failed
    )

/*++

Implements:

  IWsbTestable::Test().

--*/
{
    HRESULT     hr = S_OK;

    try {

        WsbAssert(0 != passed, E_POINTER);
        WsbAssert(0 != failed, E_POINTER);

        *passed = 0;
        *failed = 0;

    } WsbCatch(hr);

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\job\hsmrlstk.h ===
#ifndef _HSMRLSTK_
#define _HSMRLSTK_

/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    hsmrlstk.cpp

Abstract:

    This component represents the set of rules that are in effect for directory currently
    being scanned for one policy.

Author:

    Chuck Bardeen   [cbardeen]   29-Oct-1996

Revision History:

--*/

#include "resource.h"       // main symbols

#include "wsb.h"


/*++

Class Name:
    
    CHsmRuleStack

Class Description:

    This component represents the set of rules that are in effect for directory currently
    being scanned for one policy.

--*/

class CHsmRuleStack : 
    public IHsmRuleStack,
    public CWsbObject,
    public CComCoClass<CHsmRuleStack,&CLSID_CHsmRuleStack>
{
public:
    CHsmRuleStack() {}
BEGIN_COM_MAP(CHsmRuleStack)
    COM_INTERFACE_ENTRY(IHsmRuleStack)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IWsbCollectable)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_CHsmRuleStack)

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);

// IPersistStream
public:
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER* pSize);
    STDMETHOD(Load)(IStream* pStream);
    STDMETHOD(Save)(IStream* pStream, BOOL clearDirty);

// IWsbTestable
    STDMETHOD(Test)(USHORT *passed, USHORT* failed);

// IHsmRuleStack
public:
    STDMETHOD(Do)(IFsaScanItem* pScanItem);
    STDMETHOD(DoesMatch)(IFsaScanItem* pScanItem, BOOL* pShouldDo);
    STDMETHOD(Init)(IHsmPolicy* pPolicy, IFsaResource* pResource);
    STDMETHOD(Pop)(OLECHAR* path);
    STDMETHOD(Push)(OLECHAR* path);

protected:
    USHORT                  m_scale;
    BOOL                    m_usesDefaults;
    CComPtr<IHsmAction>     m_pAction;
    CComPtr<IHsmPolicy>     m_pPolicy;
    CComPtr<IWsbEnum>       m_pEnumDefaultRules;
    CComPtr<IWsbEnum>       m_pEnumPolicyRules;
    CComPtr<IWsbEnum>       m_pEnumStackRules;
    CComPtr<IWsbCollection> m_pRules;
};

#endif // _HSMRLSTK_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\job\hsmrule.h ===
#ifndef _HSMRULE_
#define _HSMRULE_

/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    hsmrule.cpp

Abstract:

    This component represents a rule for a job's policy.

Author:

    Chuck Bardeen   [cbardeen]   29-Oct-1996

Revision History:

--*/

#include "resource.h"       // main symbols

#include "wsb.h"


/*++

Class Name:
    
    CHsmRule

Class Description:

    This component represents a rule for a job's policy.

--*/

class CHsmRule : 
    public IHsmRule,
    public CWsbObject,
    public CComCoClass<CHsmRule,&CLSID_CHsmRule>
{
public:
    CHsmRule() {}
BEGIN_COM_MAP(CHsmRule)
    COM_INTERFACE_ENTRY(IHsmRule)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IWsbCollectable)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_CHsmRule)

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);

// IPersistStream
public:
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER* pSize);
    STDMETHOD(Load)(IStream* pStream);
    STDMETHOD(Save)(IStream* pStream, BOOL clearDirty);

// IWsbCollectable
public:
    STDMETHOD(CompareTo)(IUnknown* pUnknown, SHORT* pResult);

// IWsbTestable
    STDMETHOD(Test)(USHORT *passed, USHORT* failed);

// CHsmRule
    STDMETHOD(DoesNameContainWildcards)(OLECHAR* name);
    STDMETHOD(IsNameInExpression)(OLECHAR* expression, OLECHAR* name, BOOL ignoreCase);
    STDMETHOD(IsNameInExpressionGuts)(OLECHAR* expression, USHORT expresionLength, OLECHAR* name, USHORT nameLength, BOOL ignoreCase);
    STDMETHOD(NameToSearchName)(void);

// IHsmRule
public:
    STDMETHOD(CompareToIRule)(IHsmRule* pRule, SHORT* pResult);
    STDMETHOD(CompareToPathAndName)(OLECHAR* path, OLECHAR* name, SHORT* pResult);
    STDMETHOD(Criteria)(IWsbCollection** ppWsbCollection);
    STDMETHOD(EnumCriteria)(IWsbEnum** ppEnum);
    STDMETHOD(GetName)(OLECHAR** pName, ULONG bufferSize);
    STDMETHOD(GetSearchName)(OLECHAR** pName, ULONG bufferSize);
    STDMETHOD(GetPath)(OLECHAR** pPath, ULONG bufferSize);
    STDMETHOD(IsInclude)(void);
    STDMETHOD(IsUsedInSubDirs)(void);
    STDMETHOD(IsUserDefined)(void);
    STDMETHOD(MatchesName)(OLECHAR* name);
    STDMETHOD(SetIsInclude)(BOOL isIncluded);
    STDMETHOD(SetIsUsedInSubDirs)(BOOL isUsed);
    STDMETHOD(SetIsUserDefined)(BOOL isUserDefined);
    STDMETHOD(SetName)(OLECHAR* name);
    STDMETHOD(SetPath)(OLECHAR* path);

protected:
    CWsbStringPtr           m_name;
    CWsbStringPtr           m_searchName;
    CWsbStringPtr           m_path;
    BOOL                    m_isInclude;
    BOOL                    m_isUserDefined;
    BOOL                    m_isUsedInSubDirs;
    CComPtr<IWsbCollection> m_pCriteria;
};

#endif // _HSMRULE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\job\hsmrule.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    hsmrule.cpp

Abstract:

    This component represents a rule for a job's policy.

Author:

    Chuck Bardeen   [cbardeen]   29-Oct-1996

Revision History:

--*/

#include "stdafx.h"

#include "wsb.h"
#include "job.h"
#include "hsmrule.h"

#define WSB_TRACE_IS        WSB_TRACE_BIT_JOB

// These are defined in nt.h, but it takes all sorts of grief to try to include them. Since
// they are just used internally, it isn't even inportant that we have the same definitions.
#if !defined(DOS_STAR)
    #define DOS_STAR        (L'<')
#endif

#if !defined(DOS_QM)
    #define DOS_QM          (L'>')
#endif

#if !defined(DOS_DOT)
    #define DOS_DOT         (L'"')
#endif



HRESULT
CHsmRule::CompareTo(
    IN IUnknown* pUnknown,
    OUT SHORT* pResult
    )

/*++

Implements:

  IWsbCollectable::CompareTo().

--*/
{
    HRESULT             hr = S_OK;
    CComPtr<IHsmRule>   pRule;

    WsbTraceIn(OLESTR("CHsmRule::CompareTo"), OLESTR(""));
    
    try {

        // Did they give us a valid item to compare to?
        WsbAssert(0 != pUnknown, E_POINTER);

        // We need the IWsbBool interface to get the value of the object.
        WsbAffirmHr(pUnknown->QueryInterface(IID_IHsmRule, (void**) &pRule));

        // Compare the rules.
        hr = CompareToIRule(pRule, pResult);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmRule::CompareTo"), OLESTR("hr = <%ls>, result = <%ls>"), WsbHrAsString(hr), WsbPtrToShortAsString(pResult));

    return(hr);
}


HRESULT
CHsmRule::CompareToIRule(
    IN IHsmRule* pRule,
    OUT SHORT* pResult
    )

/*++

Implements:

  IHsmRule::CompareToIRule().

--*/
{
    HRESULT     hr = S_OK;
    OLECHAR*    path = 0;
    OLECHAR*    name = 0;

    WsbTraceIn(OLESTR("CHsmRule::CompareToIRule"), OLESTR(""));

    try {

        // Did they give us a valid item to compare to?
        WsbAssert(0 != pRule, E_POINTER);

        // Get the path and name.
        WsbAffirmHr(pRule->GetPath(&path, 0));
        WsbAffirmHr(pRule->GetName(&name, 0));

        // Compare to the path and name.
        hr = CompareToPathAndName(path, name, pResult);

    } WsbCatch(hr);

    if (0 != path) {
        WsbFree(path);
    }

    if (0 != name) {
        WsbFree(name);
    }

    WsbTraceOut(OLESTR("CHsmRule::CompareToIRule"), OLESTR("hr = <%ls>, result = <%ls>"), WsbHrAsString(hr), WsbPtrToShortAsString(pResult));

    return(hr);
}


HRESULT
CHsmRule::CompareToPathAndName(
    IN OLECHAR* path,
    IN OLECHAR* name,
    OUT SHORT* pResult
    )

/*++

Implements:

  IHsmRule::CompareToPathAndName().

--*/
{
    HRESULT     hr = S_OK;
    SHORT       aResult = 0;

    WsbTraceIn(OLESTR("CHsmRule::CompareToPathAndName"), OLESTR("path = <%ls>, name = <%ls>"), path, name);

    try {

        // Compare the path.
        aResult = (SHORT)_wcsicmp(m_path, path);

        // Compare the name.
        if (0 == aResult) {
            aResult = (SHORT)_wcsicmp(m_name, name);
        }

        if (0 != aResult) {
            hr = S_FALSE;
        }
        
        if (0 != pResult) {
            *pResult = aResult;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmRule::CompareToIRule"), OLESTR("hr = <%ls>, result = <%u>"), WsbHrAsString(hr), aResult);

    return(hr);
}


HRESULT
CHsmRule::Criteria(
    OUT IWsbCollection** ppCriteria
    )
/*++

Implements:

  IHsmRule::Criteria().

--*/
{
    HRESULT     hr = S_OK;

    try {
        WsbAssert(0 != ppCriteria, E_POINTER);
        *ppCriteria = m_pCriteria;
        m_pCriteria->AddRef();
    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmRule::DoesNameContainWildcards(
    OLECHAR* name
    )
/*++

Implements:

  IHsmRule::DoesNameContainWildcards().

--*/
{
    HRESULT     hr = S_FALSE;

    try {
        WsbAssert(0 != name, E_POINTER);

        if (wcscspn(name, OLESTR("*?<>\"")) < wcslen(name)) {
            hr = S_OK;
        }

    } WsbCatch(hr);

    return(hr);
}



HRESULT
CHsmRule::EnumCriteria(
    OUT IWsbEnum** ppEnum
    )
/*++

Implements:

  IHsmRule::EnumCriteria().

--*/
{
    HRESULT     hr = S_OK;

    try {
        WsbAssert(0 != ppEnum, E_POINTER);
        WsbAffirmHr(m_pCriteria->Enum(ppEnum));
    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmRule::FinalConstruct(
    void
    )
/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;
    
    try {
        WsbAffirmHr(CWsbObject::FinalConstruct());

        m_isInclude = TRUE;
        m_isUserDefined = TRUE;
        m_isUsedInSubDirs = TRUE;

        //Create the criteria collection.
        WsbAffirmHr(CoCreateInstance(CLSID_CWsbOrderedCollection, NULL, CLSCTX_ALL, IID_IWsbCollection, (void**) &m_pCriteria));

    } WsbCatch(hr);
    
    return(hr);
}


HRESULT
CHsmRule::GetClassID(
    OUT CLSID* pClsid
    )

/*++

Implements:

  IPersist::GetClassID().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmRule::GetClassID"), OLESTR(""));

    try {

        WsbAssert(0 != pClsid, E_POINTER);
        *pClsid = CLSID_CHsmRule;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmRule::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return(hr);
}


HRESULT
CHsmRule::GetName(
    OUT OLECHAR** pName,
    IN ULONG bufferSize
    )
/*++

Implements:

  IHsmRule::GetName().

--*/
{
    HRESULT     hr = S_OK;

    try {
        WsbAssert(0 != pName, E_POINTER);
        WsbAffirmHr(m_name.CopyTo(pName, bufferSize));
    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmRule::GetPath(
    OUT OLECHAR** pPath,
    IN ULONG bufferSize
    )
/*++

Implements:

  IHsmRule::GetPath().

--*/
{
    HRESULT     hr = S_OK;

    try {
        WsbAssert(0 != pPath, E_POINTER);
        WsbAffirmHr(m_path.CopyTo(pPath, bufferSize));
    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmRule::GetSearchName(
    OUT OLECHAR** pName,
    IN ULONG bufferSize
    )
/*++

Implements:

  IHsmRule::GetSearchName().

--*/
{
    HRESULT     hr = S_OK;

    try {
        WsbAssert(0 != pName, E_POINTER);
        WsbAffirmHr(m_searchName.CopyTo(pName, bufferSize));
    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmRule::GetSizeMax(
    OUT ULARGE_INTEGER* pSize
    )

/*++

Implements:

  IPersistStream::GetSizeMax().

--*/
{
    HRESULT                 hr = S_OK;
    CComPtr<IPersistStream> pPersistStream;
    ULARGE_INTEGER          entrySize;


    WsbTraceIn(OLESTR("CHsmRule::GetSizeMax"), OLESTR(""));

    try {

        WsbAssert(0 != pSize, E_POINTER);

        // Determine the size for a rule with no criteria.
        pSize->QuadPart = WsbPersistSize((wcslen(m_path) + 1) * sizeof(OLECHAR)) + WsbPersistSize((wcslen(m_name) + 1) * sizeof(OLECHAR)) + WsbPersistSize((wcslen(m_searchName) + 1) * sizeof(OLECHAR)) + 3 * WsbPersistSizeOf(BOOL) + WsbPersistSizeOf(ULONG);

        // Now allocate space for the criteria (assume they are all the
        // same size).
        WsbAffirmHr(m_pCriteria->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
        WsbAffirmHr(pPersistStream->GetSizeMax(&entrySize));
        pSize->QuadPart += entrySize.QuadPart;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmRule::GetSizeMax"), OLESTR("hr = <%ls>, Size = <%ls>"), WsbHrAsString(hr), WsbPtrToUliAsString(pSize));

    return(hr);
}


HRESULT
CHsmRule::IsUserDefined(
    void
    )
/*++

Implements:

  IHsmRule::IsUserDefined().

--*/
{
    HRESULT     hr = S_OK;

    if (!m_isUserDefined) {
        hr = S_FALSE;
    }

    return(hr);
}


HRESULT
CHsmRule::IsInclude(
    void
    )
/*++

Implements:

  IHsmRule::IsInclude().

--*/
{
    HRESULT     hr = S_OK;

    if (!m_isInclude) {
        hr = S_FALSE;
    }

    return(hr);
}


HRESULT
CHsmRule::IsNameInExpression(
    IN OLECHAR* expression,
    IN OLECHAR* name,
    IN BOOL ignoreCase
    )

/*++

Implements:

  CHsmRule::IsNameInExpression().

--*/
{
    HRESULT     hr = S_FALSE;
    USHORT      nameLength;
    USHORT      expressionLength;

    WsbTraceIn(OLESTR("CHsmRule::IsNameInExpression"), OLESTR("expression = %ls, name = %ls, ignoreCase = %ls"), expression, name, WsbBoolAsString(ignoreCase));

    try {

        // This is algorithm is from FsRtlIsNameInExpressionPrivate(), but has been rewritten to fit
        // our coding standards, data structures, and to remove other dependencies on Rtl...() code.

        //  The idea behind the algorithm is pretty simple.  We keep track of
        //  all possible locations in the regular expression that are matching
        //  the name.  If when the name has been exhausted one of the locations
        //  in the expression is also just exhausted, the name is in the language
        //  defined by the regular expression.
        WsbAssert(name != 0, E_POINTER);
        WsbAssert(expression != 0, E_POINTER);

        nameLength = (SHORT)wcslen(name);
        expressionLength = (SHORT)wcslen(expression);

        //  If one string is empty return FALSE.  If both are empty return TRUE.
        if ((nameLength == 0) && (expressionLength == 0)) {
            hr = S_OK;
        } else if ((nameLength != 0) && (expressionLength != 0)) {

            //  Special case by far the most common wild card search of *
            if ((expressionLength == 1) && (expression[0] == L'*')) {
                hr = S_OK;
            }
            
            //  Also special case expressions of the form *X.  With this and the prior
            //  case we have covered virtually all normal queries.
            else if (expression[0] == L'*') {

                //  Only special case an expression with a single *
                if (DoesNameContainWildcards(&expression[1]) == S_FALSE) {

                    // If the name is smaller than the expression, than it isn't a match. Otherwise,
                    // we need to check.
                    if (nameLength >= (expressionLength - 1)) {

                        //  Do a simple memory compare if case sensitive, otherwise
                        //  we have got to check this one character at a time.
                        if (ignoreCase) {
                            if (_wcsicmp(&expression[1], &name[nameLength - (expressionLength - 1)]) == 0) {
                                hr = S_OK;
                            }
                        } else {
                            if (wcscmp(&expression[1], &name[nameLength - (expressionLength - 1)]) == 0) {
                                hr = S_OK;
                            }
                        }
                    }
                }
            }

            else {

                // This is the general matching code. Since it is messy, it is put in its
                // own method.
                hr = IsNameInExpressionGuts(expression, expressionLength, name, nameLength, ignoreCase);
            }
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmRule::IsNameInExpression"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmRule::IsNameInExpressionGuts(
    IN OLECHAR* expression,
    IN USHORT expressionLength,
    IN OLECHAR* name,
    IN USHORT nameLength,
    IN BOOL ignoreCase
    )

/*++

Implements:

  CHsmRule::IsNameInExpressionGuts().

--*/
{
    HRESULT     hr = S_FALSE;
    USHORT      nameOffset = 0;
    OLECHAR     nameChar = '0';
    USHORT      exprOffset = 0;
    OLECHAR     exprChar;
    BOOL        nameFinished = FALSE;
    ULONG       srcCount;
    ULONG       destCount;
    ULONG       previousDestCount;
    ULONG       matchesCount;
    USHORT*     previousMatches = 0;
    USHORT*     currentMatches = 0;
    USHORT      maxState;
    USHORT      currentState;

    //  Walk through the name string, picking off characters.  We go one
    //  character beyond the end because some wild cards are able to match
    //  zero characters beyond the end of the string.
    //
    //  With each new name character we determine a new set of states that
    //  match the name so far.  We use two arrays that we swap back and forth
    //  for this purpose.  One array lists the possible expression states for
    //  all name characters up to but not including the current one, and other
    //  array is used to build up the list of states considering the current
    //  name character as well.  The arrays are then switched and the process
    //  repeated.
    //
    //  There is not a one-to-one correspondence between state number and
    //  offset into the expression.  This is evident from the NFAs in the
    //  initial comment to this function.  State numbering is not continuous.
    //  This allows a simple conversion between state number and expression
    //  offset.  Each character in the expression can represent one or two
    //  states.  * and DOS_STAR generate two states: ExprOffset*2 and
    //  ExprOffset*2 + 1.  All other expreesion characters can produce only
    //  a single state.  Thus ExprOffset = State/2.
    //
    //
    //  Here is a short description of the variables involved:
    //
    //      nameOffset  - The offset of the current name char being processed.
    //      exprOffset  - The offset of the current expression char being processed.
    //
    //      srcCount    - Prior match being investigated with current name char
    //      previousDestCount - This is used to prevent entry duplication, see comment
    //      previousMatches   - Holds the previous set of matches (the Src array)
    //
    //      destCount   - Next location to put a match assuming current name char
    //      currentMatches    - Holds the current set of matches (the Dest array)
    //
    //      nameFinished - Allows one more itteration through the Matches array
    //                     after the name is exhusted (to come *s for example)

    try {

        // Since you can get at most two matches per character in the expression, the
        // biggest arrays you will need is twice the expression length.
        currentMatches = (USHORT*)WsbAlloc(nameLength * 2 * expressionLength * sizeof(USHORT));
        WsbAffirm(0 != currentMatches, E_OUTOFMEMORY);
        previousMatches = (USHORT*)WsbAlloc(nameLength * 2 * expressionLength * sizeof(USHORT));
        WsbAffirm(0 != previousMatches, E_OUTOFMEMORY);

        previousMatches[0] = 0;
        matchesCount = 1;
        maxState = (USHORT)( expressionLength * 2 );

        while (!nameFinished) {

            if (nameOffset < nameLength) {
                nameChar = name[nameOffset];
                nameOffset++;
            } else {
                nameFinished = TRUE;

                //  If we have already exhasted the expression, cool.  Don't
                //  continue.
                if (previousMatches[matchesCount - 1] == maxState) {
                    break;
                }
            }

            //  Now, for each of the previous stored expression matches, see what
            //  we can do with this name character.
            srcCount = 0;
            destCount = 0;
            previousDestCount = 0;

            while (srcCount < matchesCount) {
                USHORT length;

                //  We have to carry on our expression analysis as far as possible
                //  for each character of name, so we loop here until the 
                //  expression stops matching.  A clue here is that expression
                //  cases that can match zero or more characters end with a
                //  continue, while those that can accept only a single character
                //  end with a break.
                exprOffset = (USHORT)( ( ( previousMatches[srcCount++] + 1 ) / 2 ) );
                length = 0;

                while (TRUE) {

                    if (exprOffset == expressionLength) {
                        break;
                    }

                    //  The first time through the loop we don't want
                    //  to increment ExprOffset.
                    exprOffset = (USHORT)( exprOffset + length );
                    length = 1;

                    currentState = (USHORT)( exprOffset * 2 );

                    if (exprOffset == expressionLength) {
                        currentMatches[destCount++] = maxState;
                        break;
                    }

                    exprChar = expression[exprOffset];

                    //  * matches any character zero or more times.
                    if (exprChar == L'*') {
                        currentMatches[destCount++] = currentState;
                        currentMatches[destCount++] = (USHORT)( currentState + 1 );
                        continue;
                    }

                    //  DOS_STAR matches any character except . zero or more times.
                    if (exprChar == DOS_STAR) {
                        BOOLEAN iCanEatADot = FALSE;

                        //  If we are at a period, determine if we are allowed to
                        //  consume it, ie. make sure it is not the last one.
                        if (!nameFinished && (nameChar == '.')) {
                            USHORT offset;

                            for (offset = nameOffset; offset < nameLength; offset++) {
                                if (name[offset] == L'.') {
                                    iCanEatADot = TRUE;
                                    break;
                                }
                            }
                        }

                        if (nameFinished || (nameChar != L'.') || iCanEatADot) {
                            currentMatches[destCount++] = currentState;
                            currentMatches[destCount++] = (USHORT)( currentState + 1 );
                            continue;
                        } else {
                            
                            //  We are at a period.  We can only match zero
                            //  characters (ie. the epsilon transition).
                            currentMatches[destCount++] = (USHORT)( currentState + 1 );
                            continue;
                        }
                    }

                    //  The following expreesion characters all match by consuming
                    //  a character, thus force the expression, and thus state
                    //  forward.
                    currentState += 2;

                    //  DOS_QM is the most complicated.  If the name is finished,
                    //  we can match zero characters.  If this name is a '.', we
                    //  don't match, but look at the next expression. Otherwise
                    //  we match a single character.
                    if (exprChar == DOS_QM) {

                        if (nameFinished || (nameChar == L'.')) {
                            continue;
                        }

                        currentMatches[destCount++] = currentState;
                        break;
                    }

                    //  A DOS_DOT can match either a period, or zero characters
                    //  beyond the end of name.
                    if (exprChar == DOS_DOT) {

                        if (nameFinished) {
                            continue;
                        }

                        if (nameChar == L'.') {
                            currentMatches[destCount++] = currentState;
                            break;
                        }
                    }

                    //  From this point on a name character is required to even
                    //  continue, let alone make a match.
                    if (nameFinished) {
                        break;
                    }

                    //  If this expression was a '?' we can match it once.
                    if (exprChar == L'?') {
                        currentMatches[destCount++] = currentState;
                        break;
                    }

                    //  Finally, check if the expression char matches the name char
                    if (ignoreCase) {
                        if (towlower(exprChar) == towlower(nameChar)) {
                            currentMatches[destCount++] = currentState;
                            break;
                        }
                    } else if (exprChar == nameChar) {
                        currentMatches[destCount++] = currentState;
                        break;
                    }

                    //  The expression didn't match so go look at the next
                    //  previous match.
                    break;
                }


                //  Prevent duplication in the destination array.
                //
                //  Each of the arrays is montonically increasing and non-
                //  duplicating, thus we skip over any source element in the src
                //  array if we just added the same element to the destination
                //  array.  This guarentees non-duplication in the dest. array.
                if ((srcCount < matchesCount) && (previousDestCount < destCount) ) {
                    while (previousDestCount < destCount) {
                        while (previousMatches[srcCount] < currentMatches[previousDestCount]) {
                            srcCount += 1;
                        }

                        previousDestCount += 1;
                    }
                }
            }

            //  If we found no matches in the just finished itteration, it's time
            //  to bail.

            if (destCount == 0) {
                WsbThrow(S_FALSE);
            }

            //  Swap the meaning the two arrays
            {
                USHORT*     tmp;

                tmp = previousMatches;
                previousMatches = currentMatches;
                currentMatches = tmp;
            }

            matchesCount = destCount;
        }

        currentState = previousMatches[matchesCount - 1];

        if (currentState == maxState) {
            hr = S_OK;
        }

    } WsbCatch(hr);

    // Free the matches buffers that we allocated previously.
    if (0 != currentMatches) {
        WsbFree(currentMatches);
    }

    if (0 != previousMatches) {
        WsbFree(previousMatches);
    }

    return(hr);
}


HRESULT
CHsmRule::IsUsedInSubDirs(
    void
    )
/*++

Implements:

  IHsmRule::IsUsedInSubDirs().

--*/
{
    HRESULT     hr = S_OK;

    if (!m_isUsedInSubDirs) {
        hr = S_FALSE;
    }

    return(hr);
}


HRESULT
CHsmRule::Load(
    IN IStream* pStream
    )

/*++

Implements:

  IPersistStream::Load().

--*/
{
    HRESULT                     hr = S_OK;
    CComPtr<IPersistStream>     pPersistStream;
    CComPtr<IWsbCollectable>    pCollectable;

    WsbTraceIn(OLESTR("CHsmRule::Load"), OLESTR(""));

    try {
        WsbAssert(0 != pStream, E_POINTER);
        
        // Do the easy stuff, but make sure that this order matches the order
        // in the save method.
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_path, 0));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_name, 0));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_searchName, 0));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_isUserDefined));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_isInclude));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_isUsedInSubDirs));

        // Load all the criteria.
        WsbAffirmHr(m_pCriteria->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
        WsbAffirmHr(pPersistStream->Load(pStream));

    } WsbCatch(hr);                                        

    WsbTraceOut(OLESTR("CHsmRule::Load"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmRule::MatchesName(
    IN OLECHAR* name
    )
/*++

Implements:

  IHsmRule::MatchesName().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmRule::MatchesName"), OLESTR("name = <%ls>"), (OLECHAR *)name);

    try {

        WsbAssert(0 != name, E_POINTER);

        // It is assumed that these names have been converted from they way they
        // might have been input into proper names for IsNameInExpression()
        // function. See NameToSearchName().
        hr = IsNameInExpression(m_searchName, name, TRUE);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmRule::MatchesName"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmRule::NameToSearchName(
    void
    )
/*++

Implements:

  CHsmRule::NameToSearchName().

--*/
{
    HRESULT     hr = S_OK;
    int         length;
    int         i;

    try {

        WsbAssert(m_name != 0, E_POINTER);

        // These name alterations are copied from the NT FindFirstFileExW() code;
        // although the code had to be changed to work with the data structures that
        // are available.
        //
        // *.* -> *
        // ? -> DOS_QM
        // . followed by ? or * -> DOS_DOT
        // * followed by a . -> DOS_STAR

        if (_wcsicmp(m_name, OLESTR("*.*")) == 0) {
            m_searchName = OLESTR("*");
        } else {
            m_searchName = m_name;
            length = wcslen(m_searchName);

            for (i = 0; i < length; i++) {
                if ((i != 0) && (m_searchName[i] == L'.') && (m_searchName[i-1] == L'*')) {
                    m_searchName[i-1] = DOS_STAR;
                }

                if ((m_searchName[i] == L'?') || (m_searchName[i] == L'*')) {
                    if (m_searchName[i] == L'?') {
                        m_searchName[i] = DOS_QM;
                    }

                    if ((i != 0) && (m_searchName[i-1] == L'.')) {
                        m_searchName[i-1] = DOS_DOT;
                    }
                }
            }
        }

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmRule::Save(
    IN IStream* pStream,
    IN BOOL clearDirty
    )

/*++

Implements:

  IPersistStream::Save().

--*/
{
    HRESULT                 hr = S_OK;
    CComPtr<IPersistStream> pPersistStream;

    WsbTraceIn(OLESTR("CHsmRule::Save"), OLESTR("clearDirty = <%ls>"), WsbBoolAsString(clearDirty));
    
    try {
        WsbAssert(0 != pStream, E_POINTER);
        
        // Do the easy stuff, but make sure that this order matches the order
        // in the save method.
        WsbAffirmHr(WsbSaveToStream(pStream, m_path));
        WsbAffirmHr(WsbSaveToStream(pStream, m_name));
        WsbAffirmHr(WsbSaveToStream(pStream, m_searchName));
        WsbAffirmHr(WsbSaveToStream(pStream, m_isUserDefined));
        WsbAffirmHr(WsbSaveToStream(pStream, m_isInclude));
        WsbAffirmHr(WsbSaveToStream(pStream, m_isUsedInSubDirs));

        // Save off all the criteria.
        WsbAffirmHr(m_pCriteria->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
        WsbAffirmHr(pPersistStream->Save(pStream, clearDirty));

        // If we got it saved and we were asked to clear the dirty bit, then
        // do so now.
        if (clearDirty) {
            m_isDirty = FALSE;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmRule::Save"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmRule::SetIsInclude(
    IN BOOL isInclude
    )
/*++

Implements:

  IHsmRule::SetIsInclude().

--*/
{
    m_isInclude = isInclude;
    m_isDirty = TRUE;

    return(S_OK);
}


HRESULT
CHsmRule::SetIsUserDefined(
    IN BOOL isUserDefined
    )
/*++

Implements:

  IHsmRule::SetIsUserDefined().

--*/
{
    m_isUserDefined = isUserDefined;
    m_isDirty = TRUE;

    return(S_OK);
}


HRESULT
CHsmRule::SetIsUsedInSubDirs(
    IN BOOL isUsed
    )
/*++

Implements:

  IHsmRule::SetIsUsedInSubDirs().

--*/
{
    m_isUsedInSubDirs = isUsed;
    m_isDirty = TRUE;

    return(S_OK);
}


HRESULT
CHsmRule::SetName(
    IN OLECHAR* name
    )
/*++

Implements:

  IHsmRule::SetName().

--*/
{
    HRESULT     hr = S_OK;

    try {
        m_name = name;
        WsbAffirmHr(NameToSearchName());
        m_isDirty = TRUE;
    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmRule::SetPath(
    IN OLECHAR* path
    )
/*++

Implements:

  IHsmRule::SetPath().

--*/
{
    HRESULT     hr = S_OK;

    try {
        m_path = path;
        m_isDirty = TRUE;
    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmRule::Test(
    USHORT* passed,
    USHORT* failed
    )

/*++

Implements:

  IWsbTestable::Test().

--*/
{
    HRESULT     hr = S_OK;

    try {

        WsbAssert(0 != passed, E_POINTER);
        WsbAssert(0 != failed, E_POINTER);

        *passed = 0;
        *failed = 0;

    } WsbCatch(hr);

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\job\hsmscan.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    fsascan.cpp

Abstract:

    This class represents a scanning process that is being carried out upon one FsaResource.

Author:

    Chuck Bardeen   [cbardeen]   16-Feb-1997

Revision History:

--*/

#include "stdafx.h"

#include "wsb.h"
#include "fsa.h"
#include "job.h"
#include "hsmscan.h"

#define WSB_TRACE_IS        WSB_TRACE_BIT_JOB



DWORD HsmStartScanner(
    void* pVoid
    )

/*++


--*/
{
    return(((CHsmScanner*) pVoid)->StartScan());
}




HRESULT
CHsmScanner::Cancel(
    HSM_JOB_EVENT       event
    )

/*++

Implements:

  IHsmScanner::Cancel().

--*/
{
    HRESULT                 hr = S_OK;

    try {

        // If we have started, but haven't finished, then change the state of the job. The thread
        // will exit on it's own.
        if ((HSM_JOB_STATE_IDLE != m_state) &&
            (HSM_JOB_STATE_DONE != m_state) &&
            (HSM_JOB_STATE_FAILED != m_state) &&
            (HSM_JOB_STATE_CANCELLED != m_state)) {

            if (HSM_JOB_EVENT_CANCEL == event) {
                WsbAffirmHr(SetState(HSM_JOB_STATE_CANCELLED));
            } else if (HSM_JOB_EVENT_SUSPEND == event) {
                WsbAffirmHr(SetState(HSM_JOB_STATE_SUSPENDED));
            } else if (HSM_JOB_EVENT_FAIL == event) {
                WsbAffirmHr(SetState(HSM_JOB_STATE_FAILED));
            } else {
                WsbAssert(FALSE, E_UNEXPECTED);
            }
        }

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmScanner::DoIfMatches(
    IN IFsaScanItem* pScanItem
    )

/*++

Implements:

  IHsmScanner::DoIfMatches().

--*/
{
    HRESULT                     hr = S_OK;
    HRESULT                     hrDo = S_OK;
    HRESULT                     hrShould = S_OK;
    BOOL                        notMatched = TRUE;
    BOOL                        shouldDo = FALSE;
    CComPtr<IHsmRuleStack>      pRuleStack;

    WsbTraceIn(OLESTR("CFsaScanner::DoIfMatches"), OLESTR(""));

    try {

        // Each policy has it's own rule stack, check each one of until a match is found (if
        // one exists).
        WsbAffirmHr(m_pEnumStacks->First(IID_IHsmRuleStack, (void**) &pRuleStack));
        
        while (notMatched) {

            hr = pRuleStack->DoesMatch(pScanItem, &shouldDo);

            if (S_OK == hr) {
                notMatched = FALSE;
                if (!shouldDo) {
                    hrShould = JOB_E_FILEEXCLUDED;
                }
            } else if (S_FALSE == hr) {
                pRuleStack = 0;
                WsbAffirmHr(m_pEnumStacks->Next(IID_IHsmRuleStack, (void**) &pRuleStack));
            } else {
                //  Something totally unexpected happened so we'd better quit
                WsbThrow(hr);
            }
        }

    } WsbCatchAndDo(hr,

        if (WSB_E_NOTFOUND == hr) {
            hrShould = JOB_E_DOESNTMATCH;
            hr = S_OK;
        } else {
            hrShould = hr;
        }

    );

    // Just Do It!!
    if (SUCCEEDED(hr) && shouldDo) {

        hrDo = pRuleStack->Do(pScanItem);

        // Tell the session if we ended up skipping the file or not.
        m_pSession->ProcessItem(HSM_JOB_PHASE_SCAN, HSM_JOB_ACTION_SCAN, pScanItem, hrDo);  

    } else {

        // Tell the session if we decided to skip the file.
        m_pSession->ProcessItem(HSM_JOB_PHASE_SCAN, HSM_JOB_ACTION_SCAN, pScanItem, hrShould);  
    }

    WsbTraceOut(OLESTR("CFsaScanner::DoIfMatches"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}
#pragma optimize("g", off)

HRESULT
CHsmScanner::FinalConstruct(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
    HRESULT                     hr = S_OK;
    
    try {

        WsbAffirmHr(CComObjectRoot::FinalConstruct());

        m_state = HSM_JOB_STATE_IDLE;
        m_priority = HSM_JOB_PRIORITY_NORMAL;
        m_threadHandle = 0;
        m_threadId = 0;
        m_threadHr = S_OK;
        m_eventCookie = 0;
        m_skipHiddenItems = TRUE;
        m_skipSystemItems = TRUE;
        m_useRPIndex = FALSE;
        m_useDbIndex = FALSE;
        m_event = 0;

        // Create a collection for the rule stacks, and store an enumerator to it.
        WsbAffirmHr(CoCreateInstance(CLSID_CWsbOrderedCollection, NULL, CLSCTX_ALL, IID_IWsbCollection, (void**) &m_pRuleStacks));
        WsbAffirmHr(m_pRuleStacks->Enum(&m_pEnumStacks));

    } WsbCatch(hr);

    return(hr);
}
#pragma optimize("", on)

void
CHsmScanner::FinalRelease(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalRelease().

--*/
{
    HRESULT                     hr = S_OK;
    
    // Cleanup the thread we were using.
    if (m_threadHandle != 0) {
        m_state = HSM_JOB_STATE_DONE;
        
        if (0 != m_event) {
            SetEvent(m_event);
        }

        //  Should we wait for the thread to end?
        CloseHandle(m_threadHandle);
        m_threadHandle = 0;
    }
    if (m_event) {
        CloseHandle(m_event);
        m_event = 0;
    }

    CComObjectRoot::FinalRelease();
}


HRESULT
CHsmScanner::LowerPriority(
    void
    )

/*++


--*/
{
    HRESULT                 hr = S_OK;

    try {

        WsbAssert(0 != m_threadHandle, E_UNEXPECTED);
        WsbAssert(m_pSession != 0, E_UNEXPECTED);

        switch(m_priority) {
            case HSM_JOB_PRIORITY_IDLE:
                WsbAffirm(FALSE, E_UNEXPECTED);
                break;

            case HSM_JOB_PRIORITY_LOWEST:
                WsbAffirmStatus(SetThreadPriority(m_threadHandle, THREAD_PRIORITY_IDLE));
                m_priority = HSM_JOB_PRIORITY_IDLE;
                break;

            case HSM_JOB_PRIORITY_LOW:
                WsbAffirmStatus(SetThreadPriority(m_threadHandle, THREAD_PRIORITY_LOWEST));
                m_priority = HSM_JOB_PRIORITY_LOWEST;
                break;

            case HSM_JOB_PRIORITY_NORMAL:
                WsbAffirmStatus(SetThreadPriority(m_threadHandle, THREAD_PRIORITY_BELOW_NORMAL));
                m_priority = HSM_JOB_PRIORITY_LOW;
                break;

            case HSM_JOB_PRIORITY_HIGH:
                WsbAffirmStatus(SetThreadPriority(m_threadHandle, THREAD_PRIORITY_NORMAL));
                m_priority = HSM_JOB_PRIORITY_NORMAL;
                break;

            case HSM_JOB_PRIORITY_HIGHEST:
                WsbAffirmStatus(SetThreadPriority(m_threadHandle, THREAD_PRIORITY_ABOVE_NORMAL));
                m_priority = HSM_JOB_PRIORITY_HIGH;
                break;

            default:
            case HSM_JOB_PRIORITY_CRITICAL:
                WsbAffirmStatus(SetThreadPriority(m_threadHandle, THREAD_PRIORITY_HIGHEST));
                m_priority = HSM_JOB_PRIORITY_HIGHEST;
                break;
        }

        WsbAffirmHr(m_pSession->ProcessPriority(HSM_JOB_PHASE_SCAN, m_priority));

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmScanner::Pause(
    void
    )

/*++

Implements:

  IHsmScanner::Pause().

--*/
{
    HRESULT                 hr = S_OK;

    WsbTraceIn(OLESTR("CFsaScanner::Pause"), OLESTR(""));

//    Lock();
    try {

        // If we are running, then suspend the thread.
        WsbAssert((HSM_JOB_STATE_STARTING == m_state) || (HSM_JOB_STATE_ACTIVE == m_state) 
                || (HSM_JOB_STATE_RESUMING == m_state), E_UNEXPECTED);

        //  Set state to pausing -- the thread will pause itself when it
        //  sees the state
        WsbAffirmHr(SetState(HSM_JOB_STATE_PAUSING));

    } WsbCatch(hr);
//    Unlock();

    WsbTraceOut(OLESTR("CFsaScanner::Pause"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmScanner::PopRules(
    IN OLECHAR* path
    )

/*++

--*/
{
    HRESULT                 hr = S_OK;
    CComPtr<IHsmRuleStack>  pRuleStack;

    try {

        // Each policy has it's own rule stack, and each of them will need to have rules removed
        // from it for this directory (if any rules were added).
        for (hr =  m_pEnumStacks->First(IID_IHsmRuleStack, (void**) &pRuleStack);
             SUCCEEDED(hr);
             hr =  m_pEnumStacks->Next(IID_IHsmRuleStack, (void**) &pRuleStack)) {

            WsbAffirmHr(pRuleStack->Pop(path));
            pRuleStack = 0;
        }

        if (WSB_E_NOTFOUND == hr) {
            hr = S_OK;
        }

    } WsbCatch(hr);
        
    return(hr);
}


HRESULT
CHsmScanner::ProcessSessionEvent(
    IN IHsmSession* pSession,
    IN HSM_JOB_PHASE phase,
    IN HSM_JOB_EVENT event
    )

/*++

--*/
{
    HRESULT         hr = S_OK;

    try {
        
        WsbAssert(0 != pSession, E_POINTER);

        // If the phase applies to use (SCAN or ALL), then do any work required by the
        // event.
        if ((HSM_JOB_PHASE_ALL == phase) || (HSM_JOB_PHASE_SCAN == phase)) {

            switch(event) {

                case HSM_JOB_EVENT_SUSPEND:
                case HSM_JOB_EVENT_CANCEL:
                case HSM_JOB_EVENT_FAIL:
                    WsbAffirmHr(Cancel(event));
                    break;

                case HSM_JOB_EVENT_PAUSE:
                    WsbAffirmHr(Pause());
                    break;

                case HSM_JOB_EVENT_RESUME:
                    WsbAffirmHr(Resume());
                    break;

                case HSM_JOB_EVENT_RAISE_PRIORITY:
                    WsbAffirmHr(RaisePriority());
                    break;

                case HSM_JOB_EVENT_LOWER_PRIORITY:
                    WsbAffirmHr(LowerPriority());
                    break;

                default:
                case HSM_JOB_EVENT_START:
                    WsbAssert(FALSE, E_UNEXPECTED);
                    break;
            }
        }

    } WsbCatch(hr);

    return(S_OK);
}


HRESULT
CHsmScanner::PushRules(
    IN OLECHAR* path
    )

/*++

--*/
{
    HRESULT                 hr = S_OK;
    CComPtr<IHsmRuleStack>  pRuleStack;

    try {

        // Save an indicator to where we are in the scan, so we can use it if we are interrupted
        // or need to give an indication to the session.
        m_currentPath = path;

        // Each policy has it's own rule stack, and each of them will need to have rules added
        // for this directory (if any rules exist).
        for (hr =  m_pEnumStacks->First(IID_IHsmRuleStack, (void**) &pRuleStack);
             SUCCEEDED(hr);
             hr =  m_pEnumStacks->Next(IID_IHsmRuleStack, (void**) &pRuleStack)) {

            WsbAffirmHr(pRuleStack->Push(path));
            pRuleStack = 0;
        }

        if (WSB_E_NOTFOUND == hr) {
            hr = S_OK;
        }
        
    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmScanner::RaisePriority(
    void
    )

/*++


--*/
{
    HRESULT                 hr = S_OK;

    try {

        WsbAssert(0 != m_threadHandle, E_UNEXPECTED);
        WsbAssert(m_pSession != 0, E_UNEXPECTED);

        switch(m_priority) {

            case HSM_JOB_PRIORITY_IDLE:
                WsbAffirmStatus(SetThreadPriority(m_threadHandle, THREAD_PRIORITY_LOWEST));
                m_priority = HSM_JOB_PRIORITY_LOWEST;
                break;

            case HSM_JOB_PRIORITY_LOWEST:
                WsbAffirmStatus(SetThreadPriority(m_threadHandle, THREAD_PRIORITY_BELOW_NORMAL));
                m_priority = HSM_JOB_PRIORITY_LOW;
                break;

            case HSM_JOB_PRIORITY_LOW:
                WsbAffirmStatus(SetThreadPriority(m_threadHandle, THREAD_PRIORITY_NORMAL));
                m_priority = HSM_JOB_PRIORITY_NORMAL;
                break;

            case HSM_JOB_PRIORITY_NORMAL:
                WsbAffirmStatus(SetThreadPriority(m_threadHandle, THREAD_PRIORITY_ABOVE_NORMAL));
                m_priority = HSM_JOB_PRIORITY_HIGH;
                break;

            case HSM_JOB_PRIORITY_HIGH:
                WsbAffirmStatus(SetThreadPriority(m_threadHandle, THREAD_PRIORITY_HIGHEST));
                m_priority = HSM_JOB_PRIORITY_HIGHEST;
                break;

            case HSM_JOB_PRIORITY_HIGHEST:
                WsbAffirmStatus(SetThreadPriority(m_threadHandle, THREAD_PRIORITY_TIME_CRITICAL));
                m_priority = HSM_JOB_PRIORITY_CRITICAL;
                break;

            default:
            case HSM_JOB_PRIORITY_CRITICAL:
                WsbAffirm(FALSE, E_UNEXPECTED);
                break;
        }

        WsbAffirmHr(m_pSession->ProcessPriority(HSM_JOB_PHASE_SCAN, m_priority));

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmScanner::Resume(
    void
    )

/*++

Implements:

  IHsmScanner::Resume().

--*/
{
    HRESULT                 hr = S_OK;
    HSM_JOB_STATE           oldState;

    WsbTraceIn(OLESTR("CFsaScanner::Resume"), OLESTR(""));

//    Lock();
    try {

        // If we are paused, then suspend the thread.
        WsbAffirm((HSM_JOB_STATE_PAUSING == m_state) || (HSM_JOB_STATE_PAUSED == m_state), E_UNEXPECTED);

        oldState = m_state;
        WsbAffirmHr(SetState(HSM_JOB_STATE_RESUMING));

        // If we are unable to resume, then return to the former state.
        try {
            WsbAffirm(SetEvent(m_event), HRESULT_FROM_WIN32(GetLastError()));
        } WsbCatchAndDo(hr, SetState(oldState););

    } WsbCatch(hr);
//    Unlock();

    WsbTraceOut(OLESTR("CFsaScanner::Resume"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmScanner::ScanPath(
    IN OLECHAR* dirPath
    )

/*++


--*/
{
    HRESULT                 hr = S_OK;
    CComPtr<IFsaScanItem>   pScanItem;
    CWsbStringPtr           searchPath;

    WsbTraceIn(OLESTR("CFsaScanner::ScanPath"), OLESTR("%ls"), WsbAbbreviatePath(dirPath, WSB_TRACE_BUFF_SIZE));

    try {

        WsbAssert(0 != dirPath, E_POINTER);
        WsbAssert(0 != dirPath[0], E_INVALIDARG);

        // Pop the rules for this files. This sets the context for the scan to follow.
        WsbAffirmHr(PushRules(dirPath));

        try {

            // Iterate over all the files and directories in the specified path.
            searchPath = dirPath;
            if (searchPath[(int) (wcslen(searchPath) - 1)] == L'\\') {
                WsbAffirmHr(searchPath.Append("*"));
            } else {
                WsbAffirmHr(searchPath.Append("\\*"));
            }

            if (m_useDbIndex) {
                hr = m_pResource->FindFirstInDbIndex(m_pSession, &pScanItem);
            } else if (m_useRPIndex) {
                hr = m_pResource->FindFirstInRPIndex(m_pSession, &pScanItem);
            } else {
                hr = m_pResource->FindFirst(searchPath, m_pSession, &pScanItem);
            }
            while (SUCCEEDED(hr) && ((HSM_JOB_STATE_ACTIVE == m_state) || 
                    (HSM_JOB_STATE_RESUMING == m_state) ||
                    (HSM_JOB_STATE_PAUSING == m_state))) {
            
                //  Check for a pause request
//                Lock();
                if (HSM_JOB_STATE_PAUSING == m_state) {
                    hr = SetState(HSM_JOB_STATE_PAUSED);
//                    Unlock();
                    WsbAffirmHr(hr);

                    //  Suspend the thread here & wait for resume signal
                    WsbTrace(OLESTR("CHsmScanner::ScanPath: pausing\n"));
                    WaitForSingleObject(m_event, 0xffffffff);
                    WsbTrace(OLESTR("CHsmScanner::ScanPath: woke up, state = %d\n"),
                            (int)m_state);

//                    Lock();
                    if (HSM_JOB_STATE_RESUMING != m_state) {
//                        Unlock();
                        break;
                    }
                    hr = SetState(HSM_JOB_STATE_ACTIVE);
                    if (S_OK != hr) {
//                        Unlock();
                        WsbThrow(hr);
                    }
                }
//                Unlock();

                // Skip hidden and/or system items if so configured.
                if (!((m_skipHiddenItems && (pScanItem->IsHidden() == S_OK)) ||
                      (m_skipSystemItems && (pScanItem->IsSystem() == S_OK)))) {

                    // Ignore ".", "..", symbolic links and mount points.
                    if ((pScanItem->IsARelativeParent() == S_FALSE) &&
                        (pScanItem->IsALink() == S_FALSE))  {

                        // Recursively scan subdirectories.
                        if (pScanItem->IsAParent() == S_OK)  {
                            WsbAffirmHr(pScanItem->GetPathAndName(OLESTR(""), &searchPath, 0));
                            WsbAffirmHr(ScanPath(searchPath));
                        }

                        // If this file matches a policy then perform the action.
                        else {
                            WsbAffirmHr(DoIfMatches(pScanItem));
                        }
                    } else {
                        WsbTrace(OLESTR("CHsmScanner::ScanPath  skipping - symbolic link, '.', or '..'\n"));
                    }
                } else {
                    WsbTrace(OLESTR("CHsmScanner::ScanPath  skipping - hidden/system\n"));
                }
                if (m_useDbIndex) {
                    hr = m_pResource->FindNextInDbIndex(pScanItem);
                } else if (m_useRPIndex) {
                    hr = m_pResource->FindNextInRPIndex(pScanItem);
                } else {
                    hr = m_pResource->FindNext(pScanItem);
                }
            }

            // If we broke out as a result of end of scan or some other error ...
            if (hr != S_OK) {
                WsbAssert(hr == WSB_E_NOTFOUND, hr);
                hr = S_OK;
            }

        } WsbCatch(hr);

        // Pop the rules for this directory. This restores the context as we pop back up the directory
        // structure.
        WsbAffirmHr(PopRules(dirPath));

    } WsbCatchAndDo(hr, if (JOB_E_DIREXCLUDED == hr) {hr = S_OK;});

    WsbTraceOut(OLESTR("CFsaScanner::ScanPath"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmScanner::SetState(
    IN HSM_JOB_STATE state
    )

/*++

--*/
{
    HRESULT         hr = S_OK;
    BOOL            bLog = TRUE;

    WsbTraceIn(OLESTR("CFsaScanner::SetState"), OLESTR("old state = %d, new state = %d"),
            (int)m_state, (int)state);

//    Lock();
    try {

        // Change the state and report the change to the session.
        m_state = state;
        WsbAffirmHr(m_pSession->ProcessState(HSM_JOB_PHASE_SCAN, m_state, m_currentPath, bLog));

    } WsbCatch(hr);
//    Unlock();

    WsbTraceOut(OLESTR("CFsaScanner::SetState"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmScanner::Start(
    IN IHsmSession* pSession,
    IN OLECHAR* path
    )

/*++

Implements:

  IHsmScanner::Start().

--*/
{
    HRESULT                             hr = S_OK;
    CComPtr<IHsmJobDef>                 pDef;
    CComPtr<IHsmPolicy>                 pPolicy;
    CComPtr<IHsmRuleStack>              pRuleStack;
    CComPtr<IWsbEnum>                   pEnumPolicies;
    CComPtr<IConnectionPointContainer>  pCPC;
    CComPtr<IConnectionPoint>           pCP;
    CComPtr<IHsmSessionSinkEveryEvent>  pSink;
    DWORD                               cookie;

    try {

        // Make sure that we were given a session, and that we haven't started already.
        WsbAssert(0 != pSession, E_POINTER);
        WsbAssert(HSM_JOB_STATE_IDLE == m_state, E_UNEXPECTED);

        // Store off the session.
        m_pSession = pSession;

        // If no directory was specified, then start in the root of the resource.
        if ((0 != path) && (0 != *path))  {
            m_startingPath = path;
        } else {
            m_startingPath = OLESTR("\\");
        }

        m_currentPath = m_startingPath;

        // Tell them we are starting.
        WsbAffirmHr(SetState(HSM_JOB_STATE_STARTING));

        // Create an event to control pause/resume for the scan.
        if (0 == m_event) {
            CWsbStringPtr       nameString;
            GUID                id;
            
            WsbAffirmHr(m_pSession->GetIdentifier(&id));
            nameString = id;
            nameString.Prepend(OLESTR("Scanner Pause and Resume Event for session "));
            m_event = CreateEvent(NULL, FALSE, FALSE, nameString);
        }
        
        // Ask the session to advise of every event.
        WsbAffirmHr(pSession->QueryInterface(IID_IConnectionPointContainer, (void**) &pCPC));
        WsbAffirmHr(pCPC->FindConnectionPoint(IID_IHsmSessionSinkEveryEvent, &pCP));
        WsbAffirmHr(((IUnknown*) (IHsmScanner*) this)->QueryInterface(IID_IHsmSessionSinkEveryEvent, (void**) &pSink));
        WsbAffirmHr(pCP->Advise(pSink, &cookie));

        // Store off the information needed to latter unadvise.
        m_eventCookie = cookie;

        try {
            // Locate the resource that is being scanned.
            WsbAffirmHr(m_pSession->GetResource(&m_pResource));

            // Create and initialize a rule stack for each policy.
            WsbAffirmHr(pSession->GetJob(&m_pJob));
            WsbAffirmHr(m_pJob->GetDef(&pDef));
            WsbAffirmHr(pDef->EnumPolicies(&pEnumPolicies));

            for (hr =  pEnumPolicies->First(IID_IHsmPolicy, (void**) &pPolicy);
                 SUCCEEDED(hr);
                 hr =  pEnumPolicies->Next(IID_IHsmPolicy, (void**) &pPolicy)) {

                WsbAffirmHr(CoCreateInstance(CLSID_CHsmRuleStack, NULL, CLSCTX_ALL, IID_IHsmRuleStack, (void**) &pRuleStack));
                WsbAffirmHr(pRuleStack->Init(pPolicy, m_pResource));
                WsbAffirmHr(m_pRuleStacks->Add(pRuleStack));

                pRuleStack = 0;
                pPolicy = 0;
            }

            if (WSB_E_NOTFOUND == hr) {
                hr = S_OK;
            }

            // Determine whether hidden and system items should be skipped?
            if (pDef->SkipHiddenItems() == S_FALSE) {
                m_skipHiddenItems = FALSE;
            }

            if (pDef->SkipSystemItems() == S_FALSE) {
                m_skipSystemItems = FALSE;
            }

            // Determine whether to use the Reparse Point Index for the scan?
            if (pDef->UseRPIndex() == S_OK) {
                m_useRPIndex = TRUE;
            }
            // Determine whether to use the Database Index for the scan?
            if (pDef->UseDbIndex() == S_OK) {
                m_useDbIndex = TRUE;
            }

            try {
            
                // Now that we have prepared, create the thread that will do the scanning!
                WsbAffirm((m_threadHandle = CreateThread(0, 0, HsmStartScanner, (void*) this, 0, &m_threadId)) != 0, HRESULT_FROM_WIN32(GetLastError()));

            } WsbCatchAndDo(hr, SetState(HSM_JOB_STATE_FAILED););

            if (FAILED(hr)) {
                WsbThrow(hr);
            }

        } WsbCatchAndDo(hr,
            pCP->Unadvise(m_eventCookie);
            m_eventCookie = 0;
        );

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmScanner::StartScan(
    void
    )

/*++


--*/
{
    HRESULT                             hr = S_OK;
    HRESULT                             hr2 = S_OK;
    CComPtr<IConnectionPointContainer>  pCPC;
    CComPtr<IConnectionPoint>           pCP;

    WsbTraceIn(OLESTR("CFsaScanner::StartScan"), OLESTR(""));

    try {
        CComPtr<IFsaTruncator>                  pTruncator;
        CComPtr<IHsmSession>                    pTruncatorSession;

        CComPtr<IHsmJobDef>                     pDef;
        CComPtr<IHsmActionOnResourcePreScan>    pActionPreScan;

        // The thread is running.
        WsbAffirmHr(SetState(HSM_JOB_STATE_ACTIVE));

        // To avoid having the RP Index order changed by the truncator,
        // we pause the truncator
        if (m_useRPIndex) {
            WsbAffirmHr(m_pResource->GetTruncator(&pTruncator));
            if (pTruncator) {
                WsbAffirmHr(pTruncator->GetSession(&pTruncatorSession));
                if (pTruncatorSession) {
                    WsbAffirmHr(pTruncatorSession->ProcessEvent(HSM_JOB_PHASE_ALL, 
                        HSM_JOB_EVENT_PAUSE));
                }
            }
        }

        // Get the pre-scan action and do it (if exists)
        WsbAffirmHr(m_pJob->GetDef(&pDef));
        WsbAffirmHr(pDef->GetPreScanActionOnResource(&pActionPreScan));
        if (pActionPreScan) {
            WsbTrace(OLESTR("CHsmScanner::StartScan: doing pre-scan action\n"));

            //Don't throw hr - we need the cleanup code that is done after the scanning
            hr = pActionPreScan->Do(m_pResource, m_pSession);
        }

        // Start with the first path and scan the resource (only if pre-scan succeeded)
        if (SUCCEEDED(hr)) {
            m_threadHr = ScanPath(m_startingPath);
        }

        // Resume the truncator if we paused it
        if (pTruncatorSession) {
            pTruncatorSession->ProcessEvent(HSM_JOB_PHASE_ALL, 
                HSM_JOB_EVENT_RESUME);
        }

        // Clear out the information about the thread;
        WsbAffirmStatus(CloseHandle(m_threadHandle));
        m_threadId = 0;
        m_threadHandle = 0;

    } WsbCatch(hr);

    // The thread is exiting, so record
    if (FAILED(hr) || FAILED(m_threadHr)) {
        hr2 = SetState(HSM_JOB_STATE_FAILED);
        if (FAILED(hr2)) {
            m_pSession->ProcessHr(HSM_JOB_PHASE_ALL, __FILE__, __LINE__, hr2);
        }
    } else {
        hr2 = SetState(HSM_JOB_STATE_DONE);
        if (FAILED(hr2)) {
            m_pSession->ProcessHr(HSM_JOB_PHASE_ALL, __FILE__, __LINE__, hr2);
        }
    }


    // Regardless of how this thread is exiting, we need to unadvise from the session.
    // Indicate that we no longer want to be advised of events.
    if ((m_pSession != 0) && (m_eventCookie != 0)) {
        try {
            WsbAffirmHr(m_pSession->QueryInterface(IID_IConnectionPointContainer, (void**) &pCPC));
            WsbAffirmHr(pCPC->FindConnectionPoint(IID_IHsmSessionSinkEveryEvent, &pCP));
            pCP->Unadvise(m_eventCookie);
        } WsbCatch(hr);
    }

    WsbTraceOut(OLESTR("CFsaScanner::StartScan"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\job\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\job\hsmsess.h ===
#ifndef _HSMSESS_
#define _HSMSESS_

/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    hsmsess.h

Abstract:

    This module contains the session component. The session is the collator of information for the work being done on
    a resource (for a job, demand recall, truncate, ...).

Author:

    Chuck Bardeen   [cbardeen]   18-Feb-1997

Revision History:

--*/

#include "resource.h"       // main symbols

#include "wsb.h"
#include "fsa.h"
#include "job.h"

/*++

Class Name:
    
    CHsmSession

Class Description:

    The session is the collator of information for the work being done on a resource (for a job, demand recall,
    truncate, ...).

--*/

class CHsmSession : 
    public CWsbObject,
    public IHsmSession,
    public CComCoClass<CHsmSession,&CLSID_CHsmSession>,
    public IConnectionPointContainerImpl<CHsmSession>,
    public IConnectionPointImpl<CHsmSession, &IID_IHsmSessionSinkEveryEvent, CComDynamicUnkArray>,
    public IConnectionPointImpl<CHsmSession, &IID_IHsmSessionSinkEveryItem, CComDynamicUnkArray>,
    public IConnectionPointImpl<CHsmSession, &IID_IHsmSessionSinkEveryMediaState, CComDynamicUnkArray>,
    public IConnectionPointImpl<CHsmSession, &IID_IHsmSessionSinkEveryPriority, CComDynamicUnkArray>,
    public IConnectionPointImpl<CHsmSession, &IID_IHsmSessionSinkEveryState, CComDynamicUnkArray>,
    public IConnectionPointImpl<CHsmSession, &IID_IHsmSessionSinkSomeItems, CComDynamicUnkArray>
{
public:
    CHsmSession() {} 

BEGIN_COM_MAP(CHsmSession)
    COM_INTERFACE_ENTRY(IHsmSession)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IWsbCollectable)
    COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()
                        
BEGIN_CONNECTION_POINT_MAP(CHsmSession)
   CONNECTION_POINT_ENTRY(IID_IHsmSessionSinkEveryEvent) 
   CONNECTION_POINT_ENTRY(IID_IHsmSessionSinkEveryItem) 
   CONNECTION_POINT_ENTRY(IID_IHsmSessionSinkEveryMediaState) 
   CONNECTION_POINT_ENTRY(IID_IHsmSessionSinkEveryPriority) 
   CONNECTION_POINT_ENTRY(IID_IHsmSessionSinkEveryState) 
   CONNECTION_POINT_ENTRY(IID_IHsmSessionSinkSomeItems) 
END_CONNECTION_POINT_MAP()
                        
DECLARE_REGISTRY_RESOURCEID(IDR_CHsmSession)

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);
    void FinalRelease(void);

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);

// IPersistStream
public:
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER* pSize);
    STDMETHOD(Load)(IStream* pStream);
    STDMETHOD(Save)(IStream* pStream, BOOL clearDirty);

// CHsmSession
    STDMETHOD(AdviseOfEvent)(HSM_JOB_PHASE phase, HSM_JOB_EVENT event);
    STDMETHOD(AdviseOfItem)(IHsmPhase* pPhase, IFsaScanItem* pScanItem, HRESULT hrItem, IHsmSessionTotals* pSessionTotals);
    STDMETHOD(AdviseOfMediaState)(IHsmPhase* pPhase, HSM_JOB_MEDIA_STATE state, OLECHAR* mediaName, HSM_JOB_MEDIA_TYPE mediaType, ULONG time);
    STDMETHOD(AdviseOfPriority)(IHsmPhase* pPhase);
    STDMETHOD(AdviseOfState)(IHsmPhase* pPhase, OLECHAR* currentPath);

// IWsbTestable
public:
    STDMETHOD(Test)(USHORT *passed, USHORT* failed);

// IHsmSession
public:
    STDMETHOD(Cancel)(HSM_JOB_PHASE phase);
    STDMETHOD(EnumPhases)(IWsbEnum** ppEnum);
    STDMETHOD(EnumTotals)(IWsbEnum** ppEnum);
    STDMETHOD(GetAdviseInterval)(LONGLONG* pFiletimeTicks);
    STDMETHOD(GetHsmId)(GUID* pId);
    STDMETHOD(GetIdentifier)(GUID* pId);
    STDMETHOD(GetJob)(IHsmJob** pJob);
    STDMETHOD(GetName)(OLECHAR** pName, ULONG bufferSize);
    STDMETHOD(GetResource)(IFsaResource** pResource);
    STDMETHOD(GetRunId)(ULONG* pRunId);
    STDMETHOD(GetSubRunId)(ULONG* pRunId);
    STDMETHOD(IsCanceling)(void);
    STDMETHOD(Pause)(HSM_JOB_PHASE phase);
    STDMETHOD(ProcessEvent)(HSM_JOB_PHASE phase, HSM_JOB_EVENT event);
    STDMETHOD(ProcessHr)(HSM_JOB_PHASE phase, CHAR* file, ULONG line, HRESULT hr);
    STDMETHOD(ProcessItem)(HSM_JOB_PHASE phase, HSM_JOB_ACTION action, IFsaScanItem* pScanItem, HRESULT hrItem);  
    STDMETHOD(ProcessMediaState)(HSM_JOB_PHASE phase, HSM_JOB_MEDIA_STATE state, OLECHAR* mediaName, HSM_JOB_MEDIA_TYPE mediaType, ULONG time);
    STDMETHOD(ProcessPriority)(HSM_JOB_PHASE phase, HSM_JOB_PRIORITY priority);
    STDMETHOD(ProcessState)(HSM_JOB_PHASE phase, HSM_JOB_STATE state, OLECHAR* currentPath, BOOL bLog);
    STDMETHOD(ProcessString)(HSM_JOB_PHASE phase, OLECHAR* string);
    STDMETHOD(Resume)(HSM_JOB_PHASE phase);
    STDMETHOD(SetAdviseInterval)(LONGLONG filetimeTicks);
    STDMETHOD(Start)(OLECHAR* name, ULONG logControl, GUID hsmId, IHsmJob* pJob, IFsaResource* pResource, ULONG runId, ULONG subRunId);  
    STDMETHOD(Suspend)(HSM_JOB_PHASE phase);

protected:
    GUID                        m_id;
    CWsbStringPtr               m_name;
    GUID                        m_hsmId;
    LONGLONG                    m_adviseInterval;
    ULONG                       m_runId;
    ULONG                       m_subRunId;
    FILETIME                    m_lastAdviseFile;
    HSM_JOB_STATE               m_state;
    ULONG                       m_activePhases;
    ULONG                       m_logControl;
    CComPtr<IHsmJob>            m_pJob;
    CComPtr<IFsaResource>       m_pResource;
    CComPtr<IWsbCollection>     m_pPhases;
    CComPtr<IWsbCollection>     m_pTotals;
    BOOL                        m_isCanceling;
};

#endif // _HSMSESS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\job\hsmsesst.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    hsmsesst.cpp

Abstract:

    This class is the session totals component, which keeps track of totals for a session
    on a per action basis.

Author:

    Chuck Bardeen   [cbardeen]   14-Feb-1997

Revision History:

--*/

#include "stdafx.h"

#include "wsb.h"
#include "job.h"
#include "hsmsesst.h"

#define WSB_TRACE_IS        WSB_TRACE_BIT_JOB

static USHORT iCount = 0;


HRESULT
CHsmSessionTotals::AddItem(
    IN IFsaScanItem* pItem,
    IN HRESULT hrItem
    )

/*++

Implements:

  IHsmSessionTotalsPriv::AddItem().

--*/
{
    HRESULT                 hr = S_OK;
    LONGLONG                size;

    WsbTraceIn(OLESTR("CHsmSessionTotals::AddItem"), OLESTR(""));
    
    try {

        // Did they give us a valid item to compare to?
        WsbAssert(0 != pItem, E_POINTER);

        // Get the size of the file.
        WsbAffirmHr(pItem->GetLogicalSize(&size));

        // Update the appropriate statistics.
        switch (hrItem) {
            case S_OK:
                m_items++;
                m_size += size;
                break;
            case S_FALSE:
            case JOB_E_FILEEXCLUDED:
            case JOB_E_DOESNTMATCH:
            case FSA_E_REPARSE_NOT_WRITTEN_FILE_CHANGED:
            case HSM_E_FILE_CHANGED:
                m_skippedItems++;
                m_skippedSize += size;
                break;
            default:
                m_errorItems++;
                m_errorSize += size;
                break;
        }
        
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmSessionTotals::AddItem"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmSessionTotals::Clone(
    OUT IHsmSessionTotals** ppSessionTotals
    )

/*++

Implements:

  IHsmSessionTotals::Clone().

--*/
{
    HRESULT                     hr = S_OK;
    CComPtr<IHsmSessionTotals>  pSessionTotals;

    WsbTraceIn(OLESTR("CHsmSessionTotals::Clone"), OLESTR(""));
    
    try {

        // Did they give us a valid item?
        WsbAssert(0 != ppSessionTotals, E_POINTER);
        *ppSessionTotals = 0;

        // Create the new instance.
        WsbAffirmHr(CoCreateInstance(CLSID_CHsmSessionTotals, 0, CLSCTX_ALL, IID_IHsmSessionTotals, (void**) &pSessionTotals));

        // Fill it in with the new values.
        WsbAffirmHr(CopyTo(pSessionTotals));

        // Return it to the caller.
        *ppSessionTotals = pSessionTotals;
        pSessionTotals->AddRef();

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmSessionTotals::Clone"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmSessionTotals::Clone(
    OUT IHsmSessionTotalsPriv** ppSessionTotalsPriv
    )

/*++

Implements:

  IHsmSessionTotalsPriv::Clone().

--*/
{
    HRESULT                         hr = S_OK;
    CComPtr<IHsmSessionTotalsPriv>  pSessionTotalsPriv;

    WsbTraceIn(OLESTR("CHsmSessionTotals::Clone"), OLESTR(""));
    
    try {

        // Did they give us a valid item?
        WsbAssert(0 != ppSessionTotalsPriv, E_POINTER);
        *ppSessionTotalsPriv = 0;

        // Create the new instance.
        WsbAffirmHr(CoCreateInstance(CLSID_CHsmSessionTotals, 0, CLSCTX_ALL, IID_IHsmSessionTotalsPriv, (void**) &pSessionTotalsPriv));

        // Fill it in with the new values.
        WsbAffirmHr(CopyTo(pSessionTotalsPriv));

        // Return it to the caller.
        *ppSessionTotalsPriv = pSessionTotalsPriv;
        pSessionTotalsPriv->AddRef();

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmSessionTotals::Clone"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmSessionTotals::CompareTo(
    IN IUnknown* pUnknown,
    OUT SHORT* pResult
    )

/*++

Implements:

  IWsbCollectable::CompareTo().

--*/
{
    HRESULT                     hr = S_OK;
    CComPtr<IHsmSessionTotals>  pSessionTotals;

    WsbTraceIn(OLESTR("CHsmSessionTotals::CompareTo"), OLESTR(""));
    
    try {

        // Did they give us a valid item to compare to?
        WsbAssert(0 != pUnknown, E_POINTER);

        // We need the IWsbBool interface to get the value of the object.
        WsbAffirmHr(pUnknown->QueryInterface(IID_IHsmSessionTotals, (void**) &pSessionTotals));

        // Compare the rules.
        hr = CompareToISessionTotals(pSessionTotals, pResult);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmSessionTotals::CompareTo"), OLESTR("hr = <%ls>, result = <%ls>"), WsbHrAsString(hr), WsbPtrToShortAsString(pResult));

    return(hr);
}


HRESULT
CHsmSessionTotals::CompareToAction(
    IN HSM_JOB_ACTION action,
    OUT SHORT* pResult
    )

/*++

Implements:

  IHsmSessionTotals::CompareToAction().

--*/
{
    HRESULT     hr = S_OK;
    SHORT       aResult = 0;

    WsbTraceIn(OLESTR("CHsmSessionTotals::CompareToAction"), OLESTR(""));

    try {

        // Compare the guids.
        if (m_action > action) {
            aResult = 1;
        }
        else if (m_action < action) {
            aResult = -1;
        }

        if (0 != aResult) {
            hr = S_FALSE;
        }
        
        if (0 != pResult) {
            *pResult = aResult;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmSessionTotals::CompareToAction"), OLESTR("hr = <%ls>, result = <%d>"), WsbHrAsString(hr), aResult);

    return(hr);
}


HRESULT
CHsmSessionTotals::CompareToISessionTotals(
    IN IHsmSessionTotals* pTotals,
    OUT SHORT* pResult
    )

/*++

Implements:

  IHsmSessionTotals::CompareToISessionTotals().

--*/
{
    HRESULT             hr = S_OK;
    HSM_JOB_ACTION      action;

    WsbTraceIn(OLESTR("CHsmSessionTotals::CompareToISessionTotals"), OLESTR(""));

    try {

        // Did they give us a valid item to compare to?
        WsbAssert(0 != pTotals, E_POINTER);

        // Get the identifier.
        WsbAffirmHr(pTotals->GetAction(&action));

        // Compare to the identifier.
        hr = CompareToAction(action, pResult);

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmSessionTotals::CompareToISessionTotals"), OLESTR("hr = <%ls>, result = <%ls>"), WsbHrAsString(hr), WsbPtrToShortAsString(pResult));

    return(hr);
}


HRESULT
CHsmSessionTotals::CopyTo(
    IN IHsmSessionTotals* pSessionTotals
    )

/*++

Implements:

  IHsmSessionTotals::CopyTo().

--*/
{
    HRESULT                         hr = S_OK;
    CComPtr<IHsmSessionTotalsPriv>  pSessionTotalsPriv;

    WsbTraceIn(OLESTR("CHsmSessionTotals::CopyTo"), OLESTR(""));
    
    try {

        // Did they give us a valid item?
        WsbAssert(0 != pSessionTotals, E_POINTER);

        // Get the private interface for the destination and copy the values.
        WsbAffirmHr(pSessionTotals->QueryInterface(IID_IHsmSessionTotalsPriv, (void**) &pSessionTotalsPriv));
        WsbAffirmHr(pSessionTotalsPriv->SetAction(m_action));
        WsbAffirmHr(pSessionTotalsPriv->SetStats(m_items, m_size, m_skippedItems, m_skippedSize, m_errorItems, m_errorSize));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmSessionTotals::CopyTo"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmSessionTotals::CopyTo(
    IN IHsmSessionTotalsPriv* pSessionTotalsPriv
    )

/*++

Implements:

  IHsmSessionTotals::CopyTo().

--*/
{
    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmSessionTotals::CopyTo"), OLESTR(""));
    
    try {

        // Did they give us a valid item?
        WsbAssert(0 != pSessionTotalsPriv, E_POINTER);

        // Get the private interface for the destination and copy the values.
        WsbAffirmHr(pSessionTotalsPriv->SetAction(m_action));
        WsbAffirmHr(pSessionTotalsPriv->SetStats(m_items, m_size, m_skippedItems, m_skippedSize, m_errorItems, m_errorSize));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmSessionTotals::CopyTo"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmSessionTotals::FinalConstruct(
    void
    )
/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;
    
    WsbTraceIn(OLESTR("CHsmSessionTotals::FinalConstruct"), OLESTR(""));
    try {
        
        WsbAffirmHr(CWsbObject::FinalConstruct());

        m_action = HSM_JOB_ACTION_UNKNOWN;
        m_items = 0;
        m_size = 0;
        m_skippedItems = 0;
        m_skippedSize = 0;
        m_errorItems = 0;
        m_errorSize = 0;

    } WsbCatch(hr);
    
    iCount++;
    WsbTraceOut(OLESTR("CHsmSessionTotals::FinalConstruct"), OLESTR("hr = <%ls>, Count is <%d>"), 
        WsbHrAsString(hr), iCount);
    return(hr);
}


void
CHsmSessionTotals::FinalRelease(
    void
    )

/*++

Implements:

  CHsmSessionTotals::FinalRelease().

--*/
{
    
    WsbTraceIn(OLESTR("CHsmSessionTotals::FinalRelease"), OLESTR(""));
    
    CWsbObject::FinalRelease();
    iCount--;
    
    WsbTraceOut(OLESTR("CHsmSessionTotals:FinalRelease"), OLESTR("Count is <%d>"), iCount);
}


HRESULT
CHsmSessionTotals::GetAction(
    OUT HSM_JOB_ACTION* pAction
    )
/*++

Implements:

  IHsmSessionTotals::GetAction().

--*/
{
    HRESULT     hr = S_OK;

    try {

        WsbAssert(0 != pAction, E_POINTER);
        *pAction = m_action;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmSessionTotals::GetClassID(
    OUT CLSID* pClsid
    )

/*++

Implements:

  IPersist::GetClassID().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmSessionTotals::GetClassID"), OLESTR(""));

    try {

        WsbAssert(0 != pClsid, E_POINTER);
        *pClsid = CLSID_CHsmSessionTotals;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmSessionTotals::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return(hr);
}


HRESULT
CHsmSessionTotals::GetName(
    OUT OLECHAR** pName,
    IN ULONG bufferSize
    )

/*++

Implements:

  IHsmSessionTotals::GetName().

--*/
{
    HRESULT         hr = S_OK;
    CWsbStringPtr   tmpString;

    try {

        WsbAssert(0 != pName, E_POINTER);

        WsbAffirmHr(tmpString.LoadFromRsc(_Module.m_hInst, IDS_HSMJOBACTION_UNKNOWN + m_action));
        WsbAffirmHr(tmpString.CopyTo(pName, bufferSize));

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmSessionTotals::GetSizeMax(
    OUT ULARGE_INTEGER* pSize
    )

/*++

Implements:

  IPersistStream::GetSizeMax().

--*/
{
    HRESULT                 hr = S_OK;


    WsbTraceIn(OLESTR("CHsmSessionTotals::GetSizeMax"), OLESTR(""));

    try {

        WsbAssert(0 != pSize, E_POINTER);

        // Determine the size for a rule with no criteria.
        pSize->QuadPart = 4 * WsbPersistSizeOf(LONGLONG) + WsbPersistSizeOf(ULONG);

        // In theory we should be saving the errorItems and errorSize, but at the
        // time this was added, we didn't want to force a reinstall because of
        // pSize->QuadPart += 2 * WsbPersistSizeOf(LONGLONG);
        
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmSessionTotals::GetSizeMax"), OLESTR("hr = <%ls>, Size = <%ls>"), WsbHrAsString(hr), WsbPtrToUliAsString(pSize));

    return(hr);
}


HRESULT
CHsmSessionTotals::GetStats(
    OUT LONGLONG* pItems,
    OUT LONGLONG* pSize,
    OUT LONGLONG* pSkippedItems,
    OUT LONGLONG* pSkippedSize,
    OUT LONGLONG* pErrorItems,
    OUT LONGLONG* pErrorSize
    )
/*++

Implements:

  IHsmSessionTotals::GetStats().

--*/
{
    HRESULT     hr = S_OK;

    if (0 != pItems) {
        *pItems = m_items;
    }

    if (0 != pSize) {
        *pSize = m_size;
    }

    if (0 != pSkippedItems) {
        *pSkippedItems = m_skippedItems;
    }

    if (0 != pSkippedSize) {
        *pSkippedSize = m_skippedSize;
    }

    if (0 != pErrorItems) {
        *pErrorItems = m_errorItems;
    }

    if (0 != pSize) {
        *pErrorSize = m_errorSize;
    }
    
    return(hr);
}


HRESULT
CHsmSessionTotals::Load(
    IN IStream* pStream
    )

/*++

Implements:

  IPersistStream::Load().

--*/
{
    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmSessionTotals::Load"), OLESTR(""));

    try {
        ULONG ul_tmp;

        WsbAssert(0 != pStream, E_POINTER);
        
        // Do the easy stuff, but make sure that this order matches the order
        // in the load method.
        WsbAffirmHr(WsbLoadFromStream(pStream, &ul_tmp));
        m_action = static_cast<HSM_JOB_ACTION>(ul_tmp);
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_items));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_size));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_skippedItems));
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_skippedSize));
        
        // In theory we should be saving the errorItems and errorSize, but at the
        // time this was added, we didn't want to force a reinstall because of
        // changes in the persistant data.
        // WsbAffirmHr(WsbLoadFromStream(pStream, &m_errorItems));
        // WsbAffirmHr(WsbLoadFromStream(pStream, &m_errorSize));

    } WsbCatch(hr);                                        

    WsbTraceOut(OLESTR("CHsmSessionTotals::Load"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmSessionTotals::Save(
    IN IStream* pStream,
    IN BOOL clearDirty
    )

/*++

Implements:

  IPersistStream::Save().

--*/
{
    HRESULT                 hr = S_OK;

    WsbTraceIn(OLESTR("CHsmSessionTotals::Save"), OLESTR("clearDirty = <%ls>"), WsbBoolAsString(clearDirty));
    
    try {
        WsbAssert(0 != pStream, E_POINTER);
        
        // Do the easy stuff, but make sure that this order matches the order
        // in the load method.
        WsbAffirmHr(WsbSaveToStream(pStream, static_cast<ULONG>(m_action)));
        WsbAffirmHr(WsbSaveToStream(pStream, m_items));
        WsbAffirmHr(WsbSaveToStream(pStream, m_size));
        WsbAffirmHr(WsbSaveToStream(pStream, m_skippedItems));
        WsbAffirmHr(WsbSaveToStream(pStream, m_skippedSize));

        // In theory we should be saving the errorItems and errorSize, but at the
        // time this was added, we didn't want to force a reinstall because of
        // changes in the persistant data.
        // WsbAffirmHr(WsbSaveToStream(pStream, m_errorItems));
        // WsbAffirmHr(WsbSaveToStream(pStream, m_errorSize));
        
        // If we got it saved and we were asked to clear the dirty bit, then
        // do so now.
        if (clearDirty) {
            m_isDirty = FALSE;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmSessionTotals::Save"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmSessionTotals::SetAction(
    IN HSM_JOB_ACTION action
    )
/*++

Implements:

  IHsmSessionTotals::SetAction().

--*/
{
    m_action = action;

    return(S_OK);
}


HRESULT
CHsmSessionTotals::SetStats(
    IN LONGLONG items,
    IN LONGLONG size,
    IN LONGLONG skippedItems,
    IN LONGLONG skippedSize,
    IN LONGLONG errorItems,
    IN LONGLONG errorSize
    )
/*++

Implements:

  IHsmSessionTotals::SetStats().

--*/
{
    m_items = items;
    m_size = size;
    m_skippedItems = skippedItems;
    m_skippedSize = skippedSize;
    m_errorItems = errorItems;
    m_errorSize = errorSize;

    return(S_OK);
}


HRESULT
CHsmSessionTotals::Test(
    USHORT* passed,
    USHORT* failed
    )

/*++

Implements:

  IWsbTestable::Test().

--*/
{
    HRESULT     hr = S_OK;

    try {

        WsbAssert(0 != passed, E_POINTER);
        WsbAssert(0 != failed, E_POINTER);

        *passed = 0;
        *failed = 0;

    } WsbCatch(hr);

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\job\hsmscan.h ===
#ifndef _HSMSCAN_
#define _HSMSCAN_

/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    hsmscan.h

Abstract:

    This class represents a scanning process that is being carried out upon one FsaResource for
    a job.

Author:

    Chuck Bardeen   [cbardeen]   16-Feb-1997

Revision History:

--*/

#include "resource.h"       // main symbols

#include "wsb.h"
#include "job.h"

extern DWORD HsmStartScanner(void* pVoid);


/*++

Class Name:
    
    CHsmScanner

Class Description:

    This class represents a scanning process that is being carried out upon one FsaResource for
    a job.

--*/

class CHsmScanner : 
    public CComObjectRoot,
    public IHsmSessionSinkEveryEvent,
    public IHsmScanner,
    public CComCoClass<CHsmScanner,&CLSID_CHsmScanner>
{
public:
    CHsmScanner() {}
BEGIN_COM_MAP(CHsmScanner)
    COM_INTERFACE_ENTRY(IHsmScanner)
    COM_INTERFACE_ENTRY(IHsmSessionSinkEveryEvent)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_CHsmScanner)

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);
    void FinalRelease(void);

// CHsmScanner
    STDMETHOD(Cancel)(HSM_JOB_EVENT event);
    STDMETHOD(LowerPriority)(void);
    STDMETHOD(DoIfMatches)(IFsaScanItem* pScanItem);
    STDMETHOD(Pause)(void);
    STDMETHOD(PopRules)(OLECHAR* path);
    STDMETHOD(RaisePriority)(void);
    STDMETHOD(PushRules)(OLECHAR* path);
    STDMETHOD(Resume)(void);
    STDMETHOD(ScanPath)(OLECHAR* path);
    STDMETHOD(SetState)(HSM_JOB_STATE state);
    STDMETHOD(StartScan)(void);

// IHsmSessionSinkEveryEvent
    STDMETHOD(ProcessSessionEvent)(IHsmSession* pSession, HSM_JOB_PHASE phase, HSM_JOB_EVENT event);

// IHsmScanner
public:
    STDMETHOD(Start)(IHsmSession* pSession, OLECHAR* path);

protected:
    CWsbStringPtr               m_startingPath;
    CWsbStringPtr               m_stoppingPath;
    CWsbStringPtr               m_currentPath;
    HSM_JOB_STATE               m_state;
    HSM_JOB_PRIORITY            m_priority;
    HANDLE                      m_threadHandle;
    HANDLE                      m_event;        // Event for suspend/resume
    DWORD                       m_threadId;
    HRESULT                     m_threadHr;
    BOOL                        m_skipHiddenItems;
    BOOL                        m_skipSystemItems;
    BOOL                        m_useRPIndex;
    BOOL                        m_useDbIndex;
    DWORD                       m_eventCookie;
    CComPtr<IHsmSession>        m_pSession;
    CComPtr<IFsaResource>       m_pResource;
    CComPtr<IHsmJob>            m_pJob;
    CComPtr<IWsbCollection>     m_pRuleStacks;
    CComPtr<IWsbEnum>           m_pEnumStacks;
};

#endif  // _HSMSCAN_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\job\hsmsesst.h ===
#ifndef _HSMSESST_
#define _HSMSESST_

/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    hsmsesst.h

Abstract:

    This class is the session totals component, which keeps track of totals for a session
    on a per action basis.

Author:

    Chuck Bardeen   [cbardeen]   14-Feb-1997

Revision History:

--*/

#include "resource.h"       // main symbols

#include "wsb.h"
#include "job.h"

/*++

Class Name:
    
    CHsmSessionTotals

    This class is the session totals component, which keeps track of totals for a session
    on a per action basis.

Class Description:


--*/

class CHsmSessionTotals : 
    public CWsbObject,
    public IHsmSessionTotals,
    public IHsmSessionTotalsPriv,
    public CComCoClass<CHsmSessionTotals,&CLSID_CHsmSessionTotals>
{
public:
    CHsmSessionTotals() {} 

BEGIN_COM_MAP(CHsmSessionTotals)
    COM_INTERFACE_ENTRY(IHsmSessionTotals)
    COM_INTERFACE_ENTRY(IHsmSessionTotalsPriv)
    COM_INTERFACE_ENTRY(IWsbCollectable)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()
                        
DECLARE_REGISTRY_RESOURCEID(IDR_CHsmSessionTotals)

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);
    void FinalRelease(void);

// IPersist
public:
    STDMETHOD(GetClassID)(LPCLSID pClsid);

// IPersistStream
public:
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER* pSize);
    STDMETHOD(Load)(IStream* pStream);
    STDMETHOD(Save)(IStream* pStream, BOOL clearDirty);

// IWsbCollectable
public:
    STDMETHOD(CompareTo)(IUnknown* pUnknown, SHORT* pResult);

// IWsbTestable
public:
    STDMETHOD(Test)(USHORT *passed, USHORT* failed);

// IHsmSessionTotals
public:
    STDMETHOD(Clone)(IHsmSessionTotals** ppSessionTotals);
    STDMETHOD(CompareToAction)(HSM_JOB_ACTION action, SHORT* pResult);
    STDMETHOD(CompareToISessionTotals)(IHsmSessionTotals* pTotal, SHORT* pResult);
    STDMETHOD(CopyTo)(IHsmSessionTotals* pSessionTotals);
    STDMETHOD(GetAction)(HSM_JOB_ACTION* pAction);
    STDMETHOD(GetName)(OLECHAR** pName, ULONG bufferSize);
    STDMETHOD(GetStats)(LONGLONG* pItems, LONGLONG* pSize, LONGLONG* pSkippedItems, LONGLONG* pSkippedSize, LONGLONG* errorItems, LONGLONG* errorSize);

// IHsmSessionTotalsPriv
    STDMETHOD(AddItem)(IFsaScanItem* pItem, HRESULT hrItem);
    STDMETHOD(Clone)(IHsmSessionTotalsPriv** ppSessionTotalsPriv);
    STDMETHOD(CopyTo)(IHsmSessionTotalsPriv* pSessionTotalsPriv);
    STDMETHOD(SetAction)(HSM_JOB_ACTION pAction);
    STDMETHOD(SetStats)(LONGLONG items, LONGLONG size, LONGLONG skippedItems, LONGLONG skippedSize, LONGLONG errorItems, LONGLONG errorSize);

protected:
    HSM_JOB_ACTION      m_action;
    LONGLONG            m_items;
    LONGLONG            m_size;
    LONGLONG            m_skippedItems;
    LONGLONG            m_skippedSize;
    LONGLONG            m_errorItems;
    LONGLONG            m_errorSize;
};

#endif // _HSMSESST_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\job\hsmsess.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    hsmsess.cpp

Abstract:

    This module contains the session component. The session is the collator of information for the work being done on
    a resource (for a job, demand recall, truncate, ...).

Author:

    Chuck Bardeen   [cbardeen]   18-Feb-1997

Revision History:

--*/

#include "stdafx.h"

#include "wsb.h"
#include "fsa.h"
#include "job.h"
#include "HsmSess.h"

#define WSB_TRACE_IS        WSB_TRACE_BIT_JOB

static USHORT iCount = 0;


HRESULT
CHsmSession::AdviseOfEvent(
    IN HSM_JOB_PHASE phase,
    IN HSM_JOB_EVENT event
    )

/*++

--*/
{
    HRESULT                                 hr = S_OK;
    HRESULT                                 hr2 = S_OK;
    CONNECTDATA                             pConnectData;
    CComPtr<IConnectionPoint>               pCP;
    CComPtr<IConnectionPointContainer>      pCPC;
    CComPtr<IEnumConnections>               pConnection;
    CComPtr<IHsmSessionSinkEveryEvent>      pSink;

    try {

        // Tell everyone the new state of the session.
        WsbAffirmHr(((IUnknown*)(IHsmSession*) this)->QueryInterface(IID_IConnectionPointContainer, (void**) &pCPC));
        WsbAffirmHr(pCPC->FindConnectionPoint(IID_IHsmSessionSinkEveryEvent, &pCP));
        WsbAffirmHr(pCP->EnumConnections(&pConnection));

        while(pConnection->Next(1, &pConnectData, 0) == S_OK) {

            // We don't care if the sink has problems (it's their problem).
            try {
                WsbAffirmHr((pConnectData.pUnk)->QueryInterface(IID_IHsmSessionSinkEveryEvent, (void**) &pSink));
                WsbAffirmHr(pSink->ProcessSessionEvent(((IHsmSession*) this), phase, event));
            } WsbCatchAndDo(hr2, ProcessHr(phase, __FILE__, __LINE__, hr2););

            WsbAffirmHr((pConnectData.pUnk)->Release());
            pSink=0;
        }

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmSession::AdviseOfItem(
    IN IHsmPhase* pPhase,
    IN IFsaScanItem* pScanItem,
    IN HRESULT hrItem,
    IN IHsmSessionTotals* pSessionTotals
    )

/*++

--*/
{
    HRESULT                                 hr = S_OK;
    HRESULT                                 hr2 = S_OK;
    CONNECTDATA                             pConnectData;
    FILETIME                                currentTime;
    LONGLONG                                advisedInterval;
    CComPtr<IConnectionPoint>               pCP;
    CComPtr<IConnectionPointContainer>      pCPC;
    CComPtr<IEnumConnections>               pConnection;
    CComPtr<IHsmSessionSinkEveryItem>       pSink;
    CComPtr<IHsmSessionSinkSomeItems>       pSink2;
    HSM_JOB_PHASE                           phase;

    try {

        // For the item there are two ways to tell, so both need to be checked.

        // Tell those who want to know about every single file.
        WsbAffirmHr(((IUnknown*)(IHsmSession*) this)->QueryInterface(IID_IConnectionPointContainer, (void**) &pCPC));
        WsbAffirmHr(pCPC->FindConnectionPoint(IID_IHsmSessionSinkEveryItem, &pCP));
        WsbAffirmHr(pCP->EnumConnections(&pConnection));

        while (pConnection->Next(1, &pConnectData, 0) == S_OK) {

            // We don't care if the sink has problems (it's their problem).
            try {
                WsbAffirmHr((pConnectData.pUnk)->QueryInterface(IID_IHsmSessionSinkEveryItem, (void**) &pSink));
                WsbAffirmHr(pSink->ProcessSessionItem(((IHsmSession*) this), pPhase, pScanItem, hrItem, pSessionTotals));
            } WsbCatchAndDo(hr2, pPhase->GetPhase(&phase); ProcessHr(phase, __FILE__, __LINE__, hr2););

            WsbAffirmHr((pConnectData.pUnk)->Release());
            pSink=0;
        }
        pCPC = 0;
        pCP = 0;
        pConnection = 0;


        // If we haven't told them withing the interval, then tell those who want to know about some of the files.
        GetSystemTimeAsFileTime(&currentTime);
        advisedInterval = ((currentTime.dwHighDateTime - m_lastAdviseFile.dwHighDateTime) << 32) + (currentTime.dwLowDateTime - m_lastAdviseFile.dwLowDateTime);

        if ((advisedInterval) > m_adviseInterval) {
            m_lastAdviseFile = currentTime;

            WsbAffirmHr(((IHsmSession*) this)->QueryInterface(IID_IConnectionPointContainer, (void**) &pCPC));
            WsbAffirmHr(pCPC->FindConnectionPoint(IID_IHsmSessionSinkSomeItems, &pCP));
            WsbAffirmHr(pCP->EnumConnections(&pConnection));

            while(pConnection->Next(1, &pConnectData, 0) == S_OK) {

                // We don't care if the sink has problems (it's their problem).
                try {
                    WsbAffirmHr((pConnectData.pUnk)->QueryInterface(IID_IHsmSessionSinkSomeItems, (void**) &pSink2));
                    WsbAffirmHr(pSink2->ProcessSessionItem(((IHsmSession*) this), pPhase, pScanItem, hrItem, pSessionTotals));
                } WsbCatchAndDo(hr2, pPhase->GetPhase(&phase); ProcessHr(phase, __FILE__, __LINE__, hr2););

                WsbAffirmHr((pConnectData.pUnk)->Release());
                pSink2=0;
            }
        }

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmSession::AdviseOfMediaState(
    IN IHsmPhase* pPhase,
    IN HSM_JOB_MEDIA_STATE state,
    IN OLECHAR* mediaName,
    IN HSM_JOB_MEDIA_TYPE mediaType,
    IN ULONG time
    )

/*++

--*/
{
    HRESULT                                 hr = S_OK;
    HRESULT                                 hr2 = S_OK;
    CONNECTDATA                             pConnectData;
    CComPtr<IConnectionPoint>               pCP;
    CComPtr<IConnectionPointContainer>      pCPC;
    CComPtr<IEnumConnections>               pConnection;
    CComPtr<IHsmSessionSinkEveryMediaState> pSink;
    HSM_JOB_PHASE                           phase;

    try {

        // Tell everyone the new media state for the session.
        WsbAffirmHr(((IHsmSession*) this)->QueryInterface(IID_IConnectionPointContainer, (void**) &pCPC));
        WsbAffirmHr(pCPC->FindConnectionPoint(IID_IHsmSessionSinkEveryMediaState, &pCP));
        WsbAffirmHr(pCP->EnumConnections(&pConnection));

        while(pConnection->Next(1, &pConnectData, 0) == S_OK) {

            // We don't care if the sink has problems (it's their problem).
            try {
                WsbAffirmHr((pConnectData.pUnk)->QueryInterface(IID_IHsmSessionSinkEveryMediaState, (void**) &pSink));
                WsbAffirmHr(pSink->ProcessSessionMediaState(((IHsmSession*) this), pPhase, state, mediaName, mediaType, time));
            } WsbCatchAndDo(hr2, pPhase->GetPhase(&phase); ProcessHr(phase, __FILE__, __LINE__, hr2););

            WsbAffirmHr((pConnectData.pUnk)->Release());
            pSink=0;
        }

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmSession::AdviseOfPriority(
    IN IHsmPhase* pPhase
    )

/*++

--*/
{
    HRESULT                                 hr = S_OK;
    HRESULT                                 hr2 = S_OK;
    CONNECTDATA                             pConnectData;
    CComPtr<IConnectionPoint>               pCP;
    CComPtr<IConnectionPointContainer>      pCPC;
    CComPtr<IEnumConnections>               pConnection;
    CComPtr<IHsmSessionSinkEveryPriority>   pSink;
    HSM_JOB_PHASE                           phase;

    try {

        // Tell everyone the new priority of a phase of the session.
        WsbAffirmHr(((IHsmSession*) this)->QueryInterface(IID_IConnectionPointContainer, (void**) &pCPC));
        WsbAffirmHr(pCPC->FindConnectionPoint(IID_IHsmSessionSinkEveryPriority, &pCP));
        WsbAffirmHr(pCP->EnumConnections(&pConnection));

        while(pConnection->Next(1, &pConnectData, 0) == S_OK) {

            // We don't care if the sink has problems (it's their problem).
            try {
                WsbAffirmHr((pConnectData.pUnk)->QueryInterface(IID_IHsmSessionSinkEveryPriority, (void**) &pSink));
                WsbAffirmHr(pSink->ProcessSessionPriority(((IHsmSession*) this), pPhase));
            } WsbCatchAndDo(hr2, pPhase->GetPhase(&phase); ProcessHr(phase, __FILE__, __LINE__, hr2););

            WsbAffirmHr((pConnectData.pUnk)->Release());
            pSink=0;
        }

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmSession::AdviseOfState(
    IN IHsmPhase* pPhase,
    IN OLECHAR* currentPath
    )

/*++

--*/
{
    HRESULT                                 hr = S_OK;
    HRESULT                                 hr2 = S_OK;
    CONNECTDATA                             pConnectData;
    CComPtr<IConnectionPoint>               pCP;
    CComPtr<IConnectionPointContainer>      pCPC;
    CComPtr<IEnumConnections>               pConnection;
    CComPtr<IHsmSessionSinkEveryState>      pSink;
    HSM_JOB_PHASE                           phase;

    try {

        // Tell everyone the new state of the session.
        WsbAffirmHr(((IHsmSession*) this)->QueryInterface(IID_IConnectionPointContainer, (void**) &pCPC));
        WsbAffirmHr(pCPC->FindConnectionPoint(IID_IHsmSessionSinkEveryState, &pCP));
        WsbAffirmHr(pCP->EnumConnections(&pConnection));

        while(pConnection->Next(1, &pConnectData, 0) == S_OK) {

            // We don't care if the sink has problems (it's their problem).
            try {
                WsbAffirmHr((pConnectData.pUnk)->QueryInterface(IID_IHsmSessionSinkEveryState, (void**) &pSink));
                WsbAffirmHr(pSink->ProcessSessionState(((IHsmSession*) this), pPhase, currentPath));
            } WsbCatchAndDo(hr2, pPhase->GetPhase(&phase); ProcessHr(phase, __FILE__, __LINE__, hr2););

            WsbAffirmHr((pConnectData.pUnk)->Release());
            pSink=0;
        }

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmSession::Cancel(
    IN HSM_JOB_PHASE phase
    )

/*++

Implements:

  IHsmSession::Cancel().

--*/
{
    return(AdviseOfEvent(phase, HSM_JOB_EVENT_CANCEL));
}


HRESULT
CHsmSession::EnumPhases(
    IN IWsbEnum** ppEnum
    )

/*++

Implements:

  IHsmSession::EnumPhases().

--*/
{
    HRESULT     hr = S_OK;

    try {

        WsbAssert(0 != ppEnum, E_POINTER);
        WsbAffirmHr(m_pPhases->Enum(ppEnum));

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmSession::EnumTotals(
    IN IWsbEnum** ppEnum
    )

/*++

Implements:

  IHsmSession::EnumTotals().

--*/
{
    HRESULT     hr = S_OK;

    try {

        WsbAssert(0 != ppEnum, E_POINTER);
        WsbAffirmHr(m_pTotals->Enum(ppEnum));

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmSession::FinalConstruct(
    void
    )

/*++

Implements:

  CComObjectRoot::FinalConstruct().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmSession::FinalConstruct"), OLESTR("this = %p"),
               this);
    try {

        WsbAffirmHr(CWsbObject::FinalConstruct());

        m_hsmId = GUID_NULL;
        m_adviseInterval = 10000;
        m_runId = 0;
        m_subRunId = 0;
        m_state = HSM_JOB_STATE_IDLE;
        m_activePhases = 0;
        m_lastAdviseFile.dwHighDateTime = 0;
        m_lastAdviseFile.dwLowDateTime = 0;
        m_logControl = HSM_JOB_LOG_NORMAL;
        m_isCanceling = FALSE;

        // Each instance should have its own unique identifier.
        WsbAffirmHr(CoCreateGuid(&m_id));

        // Create the phase and totals collections.
        WsbAffirmHr(CoCreateInstance(CLSID_CWsbOrderedCollection, 0, CLSCTX_ALL, IID_IWsbCollection, (void**) &m_pPhases));
        WsbAffirmHr(CoCreateInstance(CLSID_CWsbOrderedCollection, 0, CLSCTX_ALL, IID_IWsbCollection, (void**) &m_pTotals));

    } WsbCatch(hr);

    iCount++;
    WsbTraceOut(OLESTR("CHsmSession::FinalConstruct"), OLESTR("hr = <%ls>, count is <%d>"), WsbHrAsString(hr), iCount);
    return(hr);
}


void
CHsmSession::FinalRelease(
    void
    )

/*++

Implements:

  CHsmSession::FinalRelease().

--*/
{

    WsbTraceIn(OLESTR("CHsmSession::FinalRelease"), OLESTR("this = %p"),
               this);

    CWsbObject::FinalRelease();
    iCount--;

    WsbTraceOut(OLESTR("CHsmSession::FinalRelease"), OLESTR("Count is <%d>"), iCount);
}


HRESULT
CHsmSession::GetAdviseInterval(
    OUT LONGLONG* pInterval
    )

/*++

Implements:

  IHsmSession::GetAdviseInterval().

--*/
{
    HRESULT                     hr = S_OK;

    try {

        WsbAssert(0 != pInterval, E_POINTER);
        *pInterval = m_adviseInterval;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmSession::GetClassID(
    OUT CLSID* pClsid
    )

/*++

Implements:

  IPersist::GetClassID().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmSession::GetClassID"), OLESTR(""));

    try {

        WsbAssert(0 != pClsid, E_POINTER);
        *pClsid = CLSID_CHsmSession;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmSession::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return(hr);
}


HRESULT
CHsmSession::GetHsmId(
    OUT GUID* pId
    )

/*++

Implements:

  IHsmSession::GetHsmId().

--*/
{
    HRESULT                     hr = S_OK;

    try {

        WsbAssert(0 != pId, E_POINTER);
        *pId = m_hsmId;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmSession::GetIdentifier(
    OUT GUID* pId
    )

/*++

Implements:

  IHsmSession::GetIdentifier().

--*/
{
    HRESULT                     hr = S_OK;

    try {

        WsbAssert(0 != pId, E_POINTER);
        *pId = m_id;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmSession::GetJob(
    OUT IHsmJob** ppJob
    )

/*++

Implements:

  IHsmSession::GetJob().

--*/
{
    HRESULT                     hr = S_OK;

    try {

        WsbAssert(0 != ppJob, E_POINTER);
        *ppJob = m_pJob;
        if (m_pJob != 0)  {
            m_pJob->AddRef();
        }

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmSession::GetName(
    OLECHAR** pName,
    ULONG bufferSize
    )

/*++

Implements:

  IHsmSession::GetName().

--*/
{
    HRESULT                     hr = S_OK;

    try {

        WsbAssert(0 != pName, E_POINTER);
        WsbAffirmHr(m_name.CopyTo(pName, bufferSize));

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmSession::GetResource(
    OUT IFsaResource** ppResource
    )

/*++

Implements:

  IHsmSession::GetResource().

--*/
{
    HRESULT                     hr = S_OK;

    try {

        WsbAssert(0 != ppResource, E_POINTER);
        *ppResource = m_pResource;
        if (m_pResource != 0)  {
            m_pResource->AddRef();
        }

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmSession::GetRunId(
    OUT ULONG* pId
    )

/*++

Implements:

  IHsmSession::GetRunId().

--*/
{
    HRESULT                     hr = S_OK;

    try {

        WsbAssert(0 != pId, E_POINTER);
        *pId = m_runId;

    } WsbCatch(hr);

    return(hr);
}



HRESULT
CHsmSession::GetSubRunId(
    OUT ULONG* pId
    )

/*++

Implements:

  IHsmSession::GetSubRunId().

--*/
{
    HRESULT                     hr = S_OK;

    try {

        WsbAssert(0 != pId, E_POINTER);
        *pId = m_subRunId;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmSession::GetSizeMax(
    OUT ULARGE_INTEGER* pSize
    )

/*++

Implements:

  IPersistStream::GetSizeMax().

--*/
{
    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmSession::GetSizeMax"), OLESTR(""));

    pSize->QuadPart = 0;
    hr = E_NOTIMPL;

    WsbTraceOut(OLESTR("CHsmSession::GetSizeMax"), OLESTR("hr = <%ls>, Size = <%ls>"), WsbHrAsString(hr), WsbPtrToUliAsString(pSize));

    return(hr);
}


HRESULT
CHsmSession::Load(
    IN IStream* pStream
    )

/*++

Implements:

  IPersistStream::Load().

--*/
{
    HRESULT                     hr = S_OK;

    WsbTraceIn(OLESTR("CHsmSession::Load"), OLESTR(""));

    try {

        WsbAssert(0 != pStream, E_POINTER);
        hr = E_NOTIMPL;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmSession::Load"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmSession::Pause(
    IN HSM_JOB_PHASE phase
    )

/*++

Implements:

  IHsmSession::Pause().

--*/
{
    return(AdviseOfEvent(phase, HSM_JOB_EVENT_PAUSE));
}


HRESULT
CHsmSession::ProcessEvent(
    IN HSM_JOB_PHASE phase,
    IN HSM_JOB_EVENT event
    )

/*++

Implements:

  IHsmSession::ProcessEvent().

--*/
{
    HRESULT                         hr = S_OK;
    HRESULT                         hr2 = S_OK;

    try {

        // Tell everyone about the new event, but don't return an error if this fails.
        try {
            WsbAffirmHr(AdviseOfEvent(phase, event));
        } WsbCatchAndDo(hr2, ProcessHr(phase, __FILE__, __LINE__, hr2););

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmSession::ProcessHr(
    IN HSM_JOB_PHASE phase,
    IN CHAR* file,
    IN ULONG line,
    IN HRESULT inHr
    )

/*++

Implements:

  IHsmSession::ProcessHr().

--*/
{
    HRESULT                     hr = S_OK;
    CComPtr<IWsbEnum>           pEnum;
    CComPtr<IHsmPhasePriv>      pPhasePriv;
    CComPtr<IHsmPhasePriv>      pFoundPhasePriv;
    CWsbStringPtr               phaseName;
    CWsbStringPtr               resourceName;
    CWsbStringPtr               fileName = file;

    UNREFERENCED_PARAMETER(line);

    try {

        if ((m_logControl & HSM_JOB_LOG_HR) != 0) {

            WsbAffirmHr(EnumPhases(&pEnum));
            WsbAffirmHr(CoCreateInstance(CLSID_CHsmPhase, 0, CLSCTX_ALL, IID_IHsmPhasePriv, (void**) &pPhasePriv));
            WsbAffirmHr(pPhasePriv->SetPhase(phase));
            WsbAffirmHr(pEnum->Find(pPhasePriv, IID_IHsmPhasePriv, (void**) &pFoundPhasePriv));
            WsbAffirmHr(pFoundPhasePriv->GetName(&phaseName, 0));

            WsbAffirmHr(m_pResource->GetLogicalName(&resourceName, 0));

            // If no file was specified, then don't display the file and line number.
            if ((0 == file) || (0 == *file)) {
                WsbLogEvent(JOB_MESSAGE_SESSION_ERROR, 0, NULL, (OLECHAR*) m_name, (OLECHAR*) phaseName, (OLECHAR*) resourceName, WsbHrAsString(inHr), NULL);
            } else {
#ifdef DBG
                WsbLogEvent(JOB_MESSAGE_SESSION_INTERNALERROR, 0, NULL, (OLECHAR*) m_name, (OLECHAR*) phaseName, (OLECHAR*) resourceName, (OLECHAR*) fileName, WsbLongAsString(line), WsbHrAsString(inHr), NULL);
#else
                WsbLogEvent(JOB_MESSAGE_SESSION_ERROR, 0, NULL, (OLECHAR*) m_name, (OLECHAR*) phaseName, (OLECHAR*) resourceName, WsbHrAsString(inHr), NULL);
#endif
            }
        }

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmSession::ProcessItem(
    IN HSM_JOB_PHASE phase,
    IN HSM_JOB_ACTION action,
    IN IFsaScanItem* pScanItem,
    IN HRESULT hrItem
    )

/*++

Implements:

  IHsmSession::ProcessItem().

--*/
{
    HRESULT                         hr = S_OK;
    HRESULT                         hr2 = S_OK;
    CWsbStringPtr                   itemPath;
    CWsbStringPtr                   phaseName;
    CWsbStringPtr                   resourceName;
    CComPtr<IWsbEnum>               pEnum;
    CComPtr<IHsmPhasePriv>          pPhasePriv;
    CComPtr<IHsmPhasePriv>          pFoundPhasePriv;
    CComPtr<IHsmPhase>              pFoundPhase;
    CComPtr<IHsmSessionTotalsPriv>  pTotalsPriv;
    CComPtr<IHsmSessionTotalsPriv>  pFoundTotalsPriv;
    CComPtr<IHsmSessionTotals>      pFoundTotals;

    try {

        // Update the phase.
        WsbAffirmHr(EnumPhases(&pEnum));
        WsbAffirmHr(CoCreateInstance(CLSID_CHsmPhase, 0, CLSCTX_ALL, IID_IHsmPhasePriv, (void**) &pPhasePriv));
        WsbAffirmHr(pPhasePriv->SetPhase(phase));
        hr = pEnum->Find(pPhasePriv, IID_IHsmPhasePriv, (void**) &pFoundPhasePriv);

        // If one wasn't found then add it, otherwise, just update the state.
        if (hr == WSB_E_NOTFOUND) {
            hr = S_OK;
            WsbAffirmHr(pPhasePriv->AddItem(pScanItem, hrItem));
            WsbAffirmHr(m_pPhases->Add(pPhasePriv));
            pFoundPhasePriv = pPhasePriv;
        } else if (SUCCEEDED(hr)) {
            WsbAffirmHr(pFoundPhasePriv->AddItem(pScanItem, hrItem));
        }
        pEnum = 0;

        // Update the session totals.
        WsbAffirmHr(EnumTotals(&pEnum));
        WsbAffirmHr(CoCreateInstance(CLSID_CHsmSessionTotals, 0, CLSCTX_ALL, IID_IHsmSessionTotalsPriv, (void**) &pTotalsPriv));
        WsbAffirmHr(pTotalsPriv->SetAction(action));
        hr = pEnum->Find(pTotalsPriv, IID_IHsmSessionTotalsPriv, (void**) &pFoundTotalsPriv);

        // If one wasn't found then add it, otherwise, just update the state.
        if (hr == WSB_E_NOTFOUND) {
            hr = S_OK;
            WsbAffirmHr(pTotalsPriv->AddItem(pScanItem, hrItem));
            WsbAffirmHr(m_pTotals->Add(pTotalsPriv));
            pFoundTotalsPriv = pTotalsPriv;
        } else if (SUCCEEDED(hr)) {
            WsbAffirmHr(pFoundTotalsPriv->AddItem(pScanItem, hrItem));
        }

        // If we had a error (other than just some information ones from the scanner), then
        // log it.
        if (((m_logControl & HSM_JOB_LOG_ITEMALL) != 0) ||
            (((m_logControl & HSM_JOB_LOG_ITEMALLFAIL) != 0) && FAILED(hrItem)) ||
            (((m_logControl & HSM_JOB_LOG_ITEMMOSTFAIL) != 0) &&
             (FAILED(hrItem) && (hrItem != JOB_E_FILEEXCLUDED) && (hrItem != JOB_E_DOESNTMATCH)))) {

            WsbAffirmHr(pFoundPhasePriv->GetName(&phaseName, 0));
            WsbAffirmHr(m_pResource->GetLogicalName(&resourceName, 0));
            WsbAffirmHr(pScanItem->GetPathAndName(0, &itemPath,  0));

            WsbLogEvent(JOB_MESSAGE_SESSION_ITEM_SKIPPED, 0, NULL, (OLECHAR*) m_name, (OLECHAR*) phaseName, (OLECHAR*) resourceName, WsbAbbreviatePath(itemPath, 120), WsbHrAsString(hrItem), NULL);
        }

        // Tell everyone about the item.
        //
        // NOTE: We might want to clone the phase and session totals so that the don't get
        // updated before the called method gets a chance to look at them.
        try {
            WsbAffirmHr(pFoundPhasePriv->QueryInterface(IID_IHsmPhase, (void**) &pFoundPhase));
            WsbAffirmHr(pFoundTotalsPriv->QueryInterface(IID_IHsmSessionTotals, (void**) &pFoundTotals));
            WsbAffirmHr(AdviseOfItem(pFoundPhase, pScanItem, hrItem, pFoundTotals));
        } WsbCatchAndDo(hr2, ((IHsmSession*) this)->ProcessHr(phase, __FILE__, __LINE__, hr2););

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmSession::ProcessMediaState(
    IN HSM_JOB_PHASE phase,
    IN HSM_JOB_MEDIA_STATE state,
    IN OLECHAR* mediaName,
    IN HSM_JOB_MEDIA_TYPE mediaType,
    IN ULONG time
    )

/*++

Implements:

  IHsmSession::ProcessMediaState().

--*/
{
    HRESULT                     hr = S_OK;
    HRESULT                     hr2 = S_OK;
    CComPtr<IWsbEnum>           pEnum;
    CComPtr<IHsmPhasePriv>      pPhasePriv;
    CComPtr<IHsmPhasePriv>      pFoundPhasePriv;
    CComPtr<IHsmPhase>          pFoundPhase;

    try {

        // Record the state change in the phase object.
        WsbAffirmHr(EnumPhases(&pEnum));
        WsbAffirmHr(CoCreateInstance(CLSID_CHsmPhase, 0, CLSCTX_ALL, IID_IHsmPhasePriv, (void**) &pPhasePriv));
        WsbAffirmHr(pPhasePriv->SetPhase(phase));
        hr = pEnum->Find(pPhasePriv, IID_IHsmPhasePriv, (void**) &pFoundPhasePriv);

        // If one wasn't found then add it, otherwise, just update the state.
        if (hr == WSB_E_NOTFOUND) {
            hr = S_OK;
            WsbAffirmHr(pPhasePriv->SetMediaState(state));
            WsbAffirmHr(m_pPhases->Add(pPhasePriv));
            pFoundPhasePriv = pPhasePriv;
        } else {
            WsbAffirmHr(pFoundPhasePriv->SetMediaState(state));
        }

        // Tell everyone about the new state, but don't return an error if this fails.
        try {
            WsbAffirmHr(pFoundPhasePriv->QueryInterface(IID_IHsmPhase, (void**) &pFoundPhase));
            WsbAffirmHr(AdviseOfMediaState(pFoundPhase, state, mediaName, mediaType, time));
        } WsbCatchAndDo(hr2, ((IHsmSession*) this)->ProcessHr(phase, __FILE__, __LINE__, hr2););

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmSession::ProcessPriority(
    IN HSM_JOB_PHASE phase,
    IN HSM_JOB_PRIORITY priority
    )

/*++

Implements:

  IHsmSession::ProcessPriority().

--*/
{
    HRESULT                         hr = S_OK;
    HRESULT                         hr2 = S_OK;
    CComPtr<IWsbEnum>               pEnum;
    CComPtr<IHsmPhasePriv>          pPhasePriv;
    CComPtr<IHsmPhasePriv>          pFoundPhasePriv;
    CComPtr<IHsmPhase>              pFoundPhase;

    try {

        // Record the state change in the phase object.
        WsbAffirmHr(EnumPhases(&pEnum));
        WsbAffirmHr(CoCreateInstance(CLSID_CHsmPhase, 0, CLSCTX_ALL, IID_IHsmPhasePriv, (void**) &pPhasePriv));
        WsbAffirmHr(pPhasePriv->SetPhase(phase));
        hr = pEnum->Find(pPhasePriv, IID_IHsmPhasePriv, (void**) &pFoundPhasePriv);

        // If one wasn't found then add it, otherwise, just update the state.
        if (hr == WSB_E_NOTFOUND) {
            hr = S_OK;
            WsbAffirmHr(pPhasePriv->SetPriority(priority));
            WsbAffirmHr(m_pPhases->Add(pPhasePriv));
            pFoundPhasePriv = pPhasePriv;
        } else {
            WsbAffirmHr(pFoundPhasePriv->SetPriority(priority));
        }

        // Tell everyone about the new state, but don't return an error if this fails.
        try {
            WsbAffirmHr(pFoundPhasePriv->QueryInterface(IID_IHsmPhase, (void**) &pFoundPhase));
            WsbAffirmHr(AdviseOfPriority(pFoundPhase));
        } WsbCatchAndDo(hr2, ((IHsmSession*) this)->ProcessHr(phase, __FILE__, __LINE__, hr2););

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmSession::ProcessState(
    IN HSM_JOB_PHASE phase,
    IN HSM_JOB_STATE state,
    IN OLECHAR* currentPath,
    IN BOOL bLog
    )

/*++

Implements:

  IHsmSession::ProcessState().

--*/
{
    HRESULT                     hr = S_OK;
    HRESULT                     hr2 = S_OK;
    CComPtr<IWsbEnum>           pEnum;
    CComPtr<IHsmPhase>          pPhase;
    CComPtr<IHsmPhasePriv>      pPhasePriv;
    CComPtr<IHsmPhase>          pFoundPhase;
    CComPtr<IHsmPhasePriv>      pFoundPhasePriv;
    CComPtr<IHsmPhase>          pClonedPhase;
    CComPtr<IHsmPhasePriv>      pClonedPhasePriv;
    HSM_JOB_STATE               oldState;
    HSM_JOB_STATE               otherState;
    HSM_JOB_STATE               setState;
    BOOL                        shouldSet;
    LONGLONG                    items;
    LONGLONG                    skippedItems;
    LONGLONG                    errorItems;
    LONGLONG                    size;
    LONGLONG                    skippedSize;
    LONGLONG                    errorSize;
    ULONG                       days;
    USHORT                      hours;
    USHORT                      minutes;
    USHORT                      seconds;
    LONGLONG                    elapsedTime;
    OLECHAR                     itemsString[40];
    OLECHAR                     sizeString[40];
    OLECHAR                     skippedItemsString[40];
    OLECHAR                     skippedSizeString[40];
    OLECHAR                     errorItemsString[40];
    OLECHAR                     errorSizeString[40];
    OLECHAR                     durationString[40];
    OLECHAR                     itemRateString[40];
    OLECHAR                     byteRateString[40];
    CWsbStringPtr               resourceName;
    CWsbStringPtr               phaseName;

    WsbTraceIn(OLESTR("CHsmSession::ProcessState"), OLESTR("Phase = <%d>, State = <%d>, Path = <%ls>, pLog = <%s>"),
            phase, state, WsbAbbreviatePath(currentPath, (WSB_TRACE_BUFF_SIZE - 100)), WsbBoolAsString(bLog));
    try {

        // Record the state change in the phase object.
        WsbAffirmHr(EnumPhases(&pEnum));
        WsbAffirmHr(CoCreateInstance(CLSID_CHsmPhase, 0, CLSCTX_ALL, IID_IHsmPhasePriv, (void**) &pPhasePriv));
        WsbAffirmHr(pPhasePriv->SetPhase(phase));
        hr = pEnum->Find(pPhasePriv, IID_IHsmPhasePriv, (void**) &pFoundPhasePriv);

        // If one wasn't found then add it, otherwise, just update the state.
        if (hr == WSB_E_NOTFOUND) {
            hr = S_OK;
            WsbAffirmHr(pPhasePriv->SetState(state));
            WsbAffirmHr(m_pPhases->Add(pPhasePriv));
            pFoundPhasePriv = pPhasePriv;
        } else {
            WsbAffirmHr(pFoundPhasePriv->SetState(state));
        }

        // Put something in the event log that indicates when is happening with the session.
        if (((m_logControl & HSM_JOB_LOG_STATE) != 0) && (bLog)) {
            WsbAffirmHr(m_pResource->GetLogicalName(&resourceName, 0));
            WsbAffirmHr(pFoundPhasePriv->GetName(&phaseName, 0));
            WsbAffirmHr(pFoundPhasePriv->GetStats(&items, &size, &skippedItems, &skippedSize, &errorItems, &errorSize));
            WsbAffirmHr(pFoundPhasePriv->GetElapsedTime(&days, &hours, &minutes, &seconds));
            elapsedTime = max(1, ((LONGLONG) seconds) + 60 * (((LONGLONG) minutes) + 60 * (((LONGLONG) hours) + (24 * ((LONGLONG) days)))));

            swprintf(itemsString, OLESTR("%I64u"), items);
            swprintf(sizeString, OLESTR("%I64u"), size);
            swprintf(skippedItemsString, OLESTR("%I64u"), skippedItems);
            swprintf(skippedSizeString, OLESTR("%I64u"), skippedSize);
            swprintf(errorItemsString, OLESTR("%I64u"), errorItems);
            swprintf(errorSizeString, OLESTR("%I64u"), errorSize);
            swprintf(durationString, OLESTR("%2.2u:%2.2u:%2.2u"), hours + (24 * days), minutes, seconds);
            swprintf(itemRateString, OLESTR("%I64u"), items / elapsedTime);
            swprintf(byteRateString, OLESTR("%I64u"), size / elapsedTime);

            switch (state) {

                case HSM_JOB_STATE_STARTING:
                    WsbLogEvent(JOB_MESSAGE_SESSION_STARTING, 0, NULL, (OLECHAR*) m_name, (OLECHAR*) phaseName, (OLECHAR*) resourceName, NULL);
                    break;

                case HSM_JOB_STATE_RESUMING:
                    WsbLogEvent(JOB_MESSAGE_SESSION_RESUMING, 0, NULL, (OLECHAR*) m_name, (OLECHAR*) phaseName, (OLECHAR*) resourceName, NULL);
                    break;

                // If one hits this state, then change the overall state to this value
                case HSM_JOB_STATE_ACTIVE:
                    WsbLogEvent(JOB_MESSAGE_SESSION_ACTIVE, 0, NULL, (OLECHAR*) m_name, (OLECHAR*) phaseName, (OLECHAR*) resourceName, NULL);
                    break;

                case HSM_JOB_STATE_CANCELLING:
                    WsbLogEvent(JOB_MESSAGE_SESSION_CANCELLING, 0, NULL, (OLECHAR*) m_name, (OLECHAR*) phaseName, (OLECHAR*) resourceName, NULL);
                    break;

                case HSM_JOB_STATE_PAUSING:
                    WsbLogEvent(JOB_MESSAGE_SESSION_PAUSING, 0, NULL, (OLECHAR*) m_name, (OLECHAR*) phaseName, (OLECHAR*) resourceName, NULL);
                    break;

                case HSM_JOB_STATE_SUSPENDING:
                    WsbLogEvent(JOB_MESSAGE_SESSION_SUSPENDING, 0, NULL, (OLECHAR*) m_name, (OLECHAR*) phaseName, (OLECHAR*) resourceName, NULL);
                    break;

                case HSM_JOB_STATE_CANCELLED:
                    WsbLogEvent(JOB_MESSAGE_SESSION_CANCELLED, 0, NULL, (OLECHAR*) m_name, (OLECHAR*) phaseName, (OLECHAR*) resourceName, itemsString, sizeString, skippedItemsString, skippedSizeString, errorItemsString, errorSizeString, durationString, itemRateString, byteRateString, NULL);
                    break;

                case HSM_JOB_STATE_DONE:
                    WsbLogEvent(JOB_MESSAGE_SESSION_DONE, 0, NULL, (OLECHAR*) m_name, (OLECHAR*) phaseName, (OLECHAR*) resourceName, itemsString, sizeString, skippedItemsString, skippedSizeString, errorItemsString, errorSizeString, durationString, itemRateString, byteRateString, NULL);
                    break;

                case HSM_JOB_STATE_FAILED:
                    WsbLogEvent(JOB_MESSAGE_SESSION_FAILED, 0, NULL, (OLECHAR*) m_name, (OLECHAR*) phaseName, (OLECHAR*) resourceName, itemsString, sizeString, skippedItemsString, skippedSizeString, errorItemsString, errorSizeString, durationString, itemRateString, byteRateString, NULL);
                    break;

                case HSM_JOB_STATE_IDLE:
                    WsbLogEvent(JOB_MESSAGE_SESSION_IDLE, 0, NULL, (OLECHAR*) m_name, (OLECHAR*) phaseName, (OLECHAR*) resourceName, NULL);
                    break;

                case HSM_JOB_STATE_PAUSED:
                    WsbLogEvent(JOB_MESSAGE_SESSION_PAUSED, 0, NULL, (OLECHAR*) m_name, (OLECHAR*) phaseName, (OLECHAR*) resourceName, itemsString, sizeString, skippedItemsString, skippedSizeString, errorItemsString, errorSizeString, durationString, itemRateString, byteRateString, NULL);
                    break;

                case HSM_JOB_STATE_SUSPENDED:
                    WsbLogEvent(JOB_MESSAGE_SESSION_SUSPENDED, 0, NULL, (OLECHAR*) m_name, (OLECHAR*) phaseName, (OLECHAR*) resourceName, itemsString, sizeString, skippedItemsString, skippedSizeString, errorItemsString, errorSizeString, durationString, itemRateString, byteRateString, NULL);
                    break;

                case HSM_JOB_STATE_SKIPPED:
                    WsbLogEvent(JOB_MESSAGE_SESSION_SKIPPED, 0, NULL, (OLECHAR*) m_name, (OLECHAR*) phaseName, (OLECHAR*) resourceName, NULL);
                    break;

                default:
                    break;
            }
        }


        // Tell everyone about the new state, but don't return an error if this fails.
        try {
            WsbAffirmHr(pFoundPhasePriv->QueryInterface(IID_IHsmPhase, (void**) &pFoundPhase));
            WsbAffirmHr(AdviseOfState(pFoundPhase, currentPath));
        } WsbCatchAndDo(hr2, ((IHsmSession*) this)->ProcessHr(phase, __FILE__, __LINE__, hr2););


        // We may need to generate the "HSM_JOB_PHASE_ALL" messages. This is the session
        // summary for all the phases.

        // Remember the state, and only send a message if the state changes. We also need some strings to
        // log messages.
        oldState = m_state;

        switch (state) {

            // If one hits this state, then change the overall state to this value.
            // Also increment the activePhases count.
            case HSM_JOB_STATE_STARTING:
                if (0 == m_activePhases) {
                    m_state = state;
                }
                m_activePhases++;
                break;

            case HSM_JOB_STATE_RESUMING:
                if (0 == m_activePhases) {
                    m_state = state;
                }
                m_activePhases++;
                break;

            // If one hits this state, then change the overall state to this value
            case HSM_JOB_STATE_ACTIVE:
                if ((HSM_JOB_STATE_STARTING == m_state) || (HSM_JOB_STATE_RESUMING == m_state)) {
                    m_state = state;
                }
                break;

            // If all change to this state, then change to this value.
            case HSM_JOB_STATE_CANCELLING:
            case HSM_JOB_STATE_PAUSING:
            case HSM_JOB_STATE_SUSPENDING:
                shouldSet = TRUE;
                for (hr2 = pEnum->First(IID_IHsmPhase, (void**) &pPhase);
                    SUCCEEDED(hr2) && shouldSet;
                    hr2 = pEnum->Next(IID_IHsmPhase, (void**) &pPhase)) {

                    WsbAffirmHr(pPhase->GetState(&otherState));
                    if ((state != otherState) && (HSM_JOB_STATE_SKIPPED != otherState)) {
                        shouldSet = FALSE;
                    }
                    pPhase = 0;
                }

                if (state == HSM_JOB_STATE_CANCELLING) {
                    // Some jobs might need to know that a phase is canceling
                    m_isCanceling = TRUE;
                }

                if (shouldSet) {
                    m_state = state;
                }
                break;

            // Decrement the the activePhases count. If all phases are in one of these states
            // (i.e. activeSessions count goes to 0), then change it to the "worst" state (first
            // in the follwing list) :
            //   1) Cancelled
            //   2) Failed
            //   3) Suspended
            //   4) Paused
            //   5) Idle
            //   6) Done
            case HSM_JOB_STATE_CANCELLED:
            case HSM_JOB_STATE_DONE:
            case HSM_JOB_STATE_FAILED:
            case HSM_JOB_STATE_IDLE:
            case HSM_JOB_STATE_PAUSED:
            case HSM_JOB_STATE_SUSPENDED:
                if (m_activePhases > 0) {
                    m_activePhases--;

                    if (m_activePhases == 0) {

                        shouldSet = FALSE;
                        setState = state;

                        for (hr2 = pEnum->First(IID_IHsmPhase, (void**) &pPhase);
                             SUCCEEDED(hr2);
                             hr2 = pEnum->Next(IID_IHsmPhase, (void**) &pPhase)) {

                            WsbAffirmHr(pPhase->GetState(&otherState));
                            switch (otherState) {
                                case HSM_JOB_STATE_CANCELLED:
                                    shouldSet = TRUE;
                                    setState = otherState;
                                    break;

                                case HSM_JOB_STATE_FAILED:
                                    if (HSM_JOB_STATE_CANCELLED != setState) {
                                        shouldSet = TRUE;
                                        setState = otherState;
                                    }
                                    break;

                                case HSM_JOB_STATE_SUSPENDED:
                                    if ((HSM_JOB_STATE_CANCELLED != setState) &&
                                        (HSM_JOB_STATE_FAILED != setState)) {
                                        shouldSet = TRUE;
                                        setState = otherState;
                                    }
                                    break;

                                case HSM_JOB_STATE_IDLE:
                                    if ((HSM_JOB_STATE_CANCELLED != setState) &&
                                        (HSM_JOB_STATE_FAILED != setState) &&
                                        (HSM_JOB_STATE_SUSPENDED != setState)) {
                                        shouldSet = TRUE;
                                        setState = otherState;
                                    }
                                    break;

                                case HSM_JOB_STATE_PAUSED:
                                    if (HSM_JOB_STATE_DONE == setState) {
                                        shouldSet = TRUE;
                                        setState = otherState;
                                    }
                                    break;

                                case HSM_JOB_STATE_DONE:
                                    if (HSM_JOB_STATE_DONE == setState) {
                                        shouldSet = TRUE;
                                    }
                                    break;

                                case HSM_JOB_STATE_ACTIVE:
                                case HSM_JOB_STATE_CANCELLING:
                                case HSM_JOB_STATE_PAUSING:
                                case HSM_JOB_STATE_RESUMING:
                                case HSM_JOB_STATE_SKIPPED:
                                case HSM_JOB_STATE_STARTING:
                                case HSM_JOB_STATE_SUSPENDING:
                                default:
                                    break;
                            }
                            pPhase = 0;
                        }

                        if (shouldSet) {
                            m_state = setState;
                        }
                    }
                }
                break;

            case HSM_JOB_STATE_SKIPPED:
                break;

            default:
                break;
        }

        if (oldState != m_state) {

            try {
                WsbAffirmHr(pFoundPhasePriv->Clone(&pClonedPhasePriv));
                WsbAffirmHr(pClonedPhasePriv->SetPhase(HSM_JOB_PHASE_ALL));
                WsbAffirmHr(pClonedPhasePriv->QueryInterface(IID_IHsmPhase, (void**) &pClonedPhase));
                WsbAffirmHr(AdviseOfState(pClonedPhase, currentPath));
            } WsbCatchAndDo(hr2, ((IHsmSession*) this)->ProcessHr(phase, __FILE__, __LINE__, hr2););
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmSession::ProcessState"), OLESTR("hr = <%ls>, State = <%d>, ActivePhases = <%lu>"), WsbHrAsString(hr), m_state, m_activePhases);
    return(hr);
}


HRESULT
CHsmSession::ProcessString(
    IN HSM_JOB_PHASE /*phase*/,
    IN OLECHAR* string
    )

/*++

Implements:

  IHsmSession::ProcessString().

--*/
{
    HRESULT                         hr = S_OK;

    try {

        // Don't know what to really do with it, but for now just print it.
        _putts(string);

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmSession::Resume(
    IN HSM_JOB_PHASE phase
    )

/*++

Implements:

  IHsmSession::Resume().

--*/
{
    return(AdviseOfEvent(phase, HSM_JOB_EVENT_RESUME));
}


HRESULT
CHsmSession::Save(
    IN IStream* pStream,
    IN BOOL clearDirty
    )

/*++

Implements:

  IPersistStream::Save().

--*/
{
    HRESULT                     hr = S_OK;
    CComPtr<IPersistStream>     pPersistStream;

    WsbTraceIn(OLESTR("CHsmSession::Save"), OLESTR("clearDirty = <%ls>"), WsbBoolAsString(clearDirty));

    try {

        WsbAssert(0 != pStream, E_POINTER);
        hr = E_NOTIMPL;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CHsmSession::Save"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CHsmSession::SetAdviseInterval(
    IN LONGLONG interval
    )

/*++

Implements:

  IHsmSession::SetAdviseInterval

--*/
{
    m_adviseInterval = interval;
    m_isDirty = TRUE;

    return(S_OK);
}


HRESULT
CHsmSession::Start(
    IN OLECHAR* name,
    IN ULONG logControl,
    IN GUID hsmId,
    IN IHsmJob* pJob,
    IN IFsaResource* pResource,
    IN ULONG runId,
    IN ULONG subRunId
    )

/*++

Implements:

  IHsmSession::Start().

--*/
{
    HRESULT                             hr = S_OK;

    try {

        WsbAssert(0 != pResource, E_POINTER);

        // You can only use a session once (i.e. no restart).
        WsbAssert(m_pResource == 0, E_UNEXPECTED);

        // Store the information that has been provided.
        m_logControl = logControl;
        m_name = name;
        m_hsmId = hsmId;
        m_runId = runId;
        m_subRunId = subRunId;

        m_pJob = pJob;
        m_pResource = pResource;

        m_isDirty = TRUE;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CHsmSession::Suspend(
    IN HSM_JOB_PHASE phase
    )

/*++

Implements:

  IHsmSession::Suspend().

--*/
{
    return(AdviseOfEvent(phase, HSM_JOB_EVENT_SUSPEND));
}


HRESULT
CHsmSession::Test(
    OUT USHORT* passed,
    OUT USHORT* failed
    )

/*++

Implements:

  IWsbTestable::Test().

--*/
{
    HRESULT     hr = S_OK;

    try {

        WsbAssert(0 != passed, E_POINTER);
        WsbAssert(0 != failed, E_POINTER);

        *passed = 0;
        *failed = 0;

    } WsbCatch(hr);

    return(hr);
}

HRESULT
CHsmSession::IsCanceling(
    void
    )

/*++

Implements:

  IHsmSession::IsCanceling().

--*/
{
    HRESULT                     hr = S_FALSE;

    if (m_isCanceling) {
        hr = S_OK;
    }

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\job\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently
#ifndef _STDAFX_H
#define _STDAFX_H

#define WSB_TRACE_IS        WSB_TRACE_BIT_JOB
#include "wsb.h"

#endif // _STDAFX_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\job\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by job.rc
//
#define IDS_HSMACTIONCOPY_DESC          1
#define IDS_HSMACTIONDELETE_DESC        2
#define IDS_HSMACTIONMANAGE_DESC        3
#define IDS_HSMACTIONMIGRATE_DESC       4
#define IDS_HSMACTIONMOVE_DESC          5
#define IDS_HSMACTIONRECALL_DESC        6
#define IDS_HSMACTIONRECYCLE_DESC       7
#define IDS_HSMACTIONTRUNCATE_DESC      8
#define IDS_HSMACTIONUNMANAGE_DESC      9
#define IDS_HSMACTIONVALIDATE_DESC      10
#define IDS_HSMCRITACCESSTIME_DESC      11
#define IDS_HSMCRITALWAYS_DESC          12
#define IDS_HSMCRITCOMPRESSED_DESC      13
#define IDS_HSMCRITGROUP_DESC           14
#define IDS_HSMCRITLINKED_DESC          15
#define IDS_HSMCRITLOGICALSIZE_DESC     16
#define IDS_HSMCRITMBIT_DESC            17
#define IDS_HSMCRITMIGRATED_DESC        18
#define IDS_HSMCRITMANAGEABLE_DESC      19
#define IDS_HSMCRITMODIFYTIME_DESC      20
#define IDS_HSMCRITOWNER_DESC           21
#define IDS_HSMCRITPHYSICALSIZE_DESC    22
#define IDS_HSMCRITPREMIGRATED_DESC     23
#define IDS_HSMJOB_DESC                 24
#define IDS_HSMJOBDEF_DESC              25
#define IDS_HSMJOBCONTEXT_DESC          26
#define IDS_HSMPOLICY_DESC              27
#define IDS_HSMRULE_DESC                28
#define IDS_HSMJOBWORKITEM_DESC         29
#define IDS_HSMSCANNER_DESC             30
#define IDS_HSMSESSION_DESC             31
#define IDS_HSMPHASE_DESC               32
#define IDS_HSMSESSIONTOTALS_DESC       33
#define IDS_HSMRULESTACK_DESC           34

#define IDS_HSMJOBPHASEALL              60
#define IDS_HSMJOBPHASESCAN             61
#define IDS_HSMJOBPHASEFSAACTION        62
#define IDS_HSMJOBPHASEMOVEACTION       63
#define IDS_HSMJOBPHASEPOSTACTION       64

#define IDS_HSMJOBACTION_UNKNOWN        80
#define IDS_HSMJOBACTION_COPY           81
#define IDS_HSMJOBACTION_DELETE         82
#define IDS_HSMJOBACTION_MOVE           83
#define IDS_HSMJOBACTION_NONE           84
#define IDS_HSMJOBACTION_PREMIGRATE     85
#define IDS_HSMJOBACTION_RECALL         86
#define IDS_HSMJOBACTION_RECYCLE        87
#define IDS_HSMJOBACTION_REPAIR         88
#define IDS_HSMJOBACTION_SCAN           89
#define IDS_HSMJOBACTION_TRUNCATE       90
#define IDS_HSMJOBACTION_UNMANAGE       91
#define IDS_HSMJOBACTION_VALIDATE       92

#define IDR_CHsmActionCopy          1
#define IDR_CHsmActionDelete        2
#define IDR_CHsmActionManage        3
#define IDR_CHsmActionMigrate       4
#define IDR_CHsmActionMove          5
#define IDR_CHsmActionRecall        6
#define IDR_CHsmActionRecycle       7
#define IDR_CHsmActionTruncate      8
#define IDR_CHsmActionUnmanage      9
#define IDR_CHsmActionValidate      10
#define IDR_CHsmCritAccessTime      11
#define IDR_CHsmCritAlways          12
#define IDR_CHsmCritCompressed      13
#define IDR_CHsmCritGroup           14
#define IDR_CHsmCritLinked          15
#define IDR_CHsmCritLogicalSize     16
#define IDR_CHsmCritMbit            17
#define IDR_CHsmCritMigrated        18
#define IDR_CHsmCritManageable      19
#define IDR_CHsmCritModifyTime      20
#define IDR_CHsmCritOwner           21
#define IDR_CHsmCritPhysicalSize    22
#define IDR_CHsmCritPremigrated     23
#define IDR_CHsmJob                 24
#define IDR_CHsmJobDef              25
#define IDR_CHsmJobContext          26
#define IDR_CHsmPolicy              27
#define IDR_CHsmRule                28
#define IDR_CHsmJobWorkItem         29
#define IDR_CHsmScanner             30
#define IDR_CHsmSession             31
#define IDR_CHsmPhase               32
#define IDR_CHsmSessionTotals       33
#define IDR_CHsmRuleStack           34
#define IDR_CHsmActionOnResourcePostValidate    35
#define IDR_CHsmActionOnResourcePreValidate     36
#define IDR_CHsmActionOnResourcePostUnmanage    37
#define IDR_CHsmActionOnResourcePreUnmanage     38
#define IDR_CHsmActionOnResourcePreScanUnmanage 39

#define IDS_HSMACTIONCOPY_ID            101
#define IDS_HSMACTIONDELETE_ID          102
#define IDS_HSMACTIONMANAGE_ID          103
#define IDS_HSMACTIONMIGRATE_ID         104
#define IDS_HSMACTIONMOVE_ID            105
#define IDS_HSMACTIONRECALL_ID          106
#define IDS_HSMACTIONRECYCLE_ID         107
#define IDS_HSMACTIONTRUNCATE_ID        108
#define IDS_HSMACTIONUNMANAGE_ID        109
#define IDS_HSMACTIONVALIDATE_ID        110
#define IDS_HSMCRITACCESSTIME_ID        111
#define IDS_HSMCRITALWAYS_ID            112
#define IDS_HSMCRITCOMPRESSED_ID        113
#define IDS_HSMCRITGROUP_ID             114
#define IDS_HSMCRITLINKED_ID            115
#define IDS_HSMCRITLOGICALSIZE_ID       116
#define IDS_HSMCRITMBIT_ID              117
#define IDS_HSMCRITMANAGEABLE_ID        118
#define IDS_HSMCRITMIGRATED_ID          119
#define IDS_HSMCRITMODIFYTIME_ID        120
#define IDS_HSMCRITOWNER_ID             121
#define IDS_HSMCRITPHYSICALSIZE_ID      122
#define IDS_HSMCRITPREMIGRATED_ID       123
#define IDS_HSMACTIONONRESOURCEPOSTVALIDATE_ID      124
#define IDS_HSMACTIONONRESOURCEPREVALIDATE_ID       125
#define IDS_HSMACTIONONRESOURCEPOSTUNMANAGE_ID      126
#define IDS_HSMACTIONONRESOURCEPREUNMANAGE_ID       127
#define IDS_HSMACTIONONRESOURCEPRESCANUNMANAGE_ID   128

#define IDS_HSMJOBSTATEACTIVE           151
#define IDS_HSMJOBSTATECANCELLED        152
#define IDS_HSMJOBSTATECANCELLING       153
#define IDS_HSMJOBSTATEDONE             154
#define IDS_HSMJOBSTATEFAILED           155
#define IDS_HSMJOBSTATEIDLE             156
#define IDS_HSMJOBSTATEPAUSED           157
#define IDS_HSMJOBSTATEPAUSING          158
#define IDS_HSMJOBSTATERESUMING         159
#define IDS_HSMJOBSTATESKIPPED          160
#define IDS_HSMJOBSTATESTARTING         161
#define IDS_HSMJOBSTATESUSPENDED        162
#define IDS_HSMJOBSTATESUSPENDING       163

#define IDS_HSMJOBMEDIASTATEIDLE            170
#define IDS_HSMJOBMEDIASTATEUNAVAILABLE     171
#define IDS_HSMJOBMEDIASTATEMOUNTING        172
#define IDS_HSMJOBMEDIASTATEMOUNTED         173
#define IDS_HSMJOBMEDIASTATETRANSFERRING    174
#define IDS_HSMJOBMEDIASTATETRANSFERRED     175
#define IDS_HSMJOBMEDIASTATEDISMOUNTING     176
#define IDS_HSMJOBMEDIASTATEDISMOUNTED      177

#define IDS_HSMCRITALWAYS_VALUE_T       201
#define IDS_HSMCRITCOMPRESSED_VALUE_T   203
#define IDS_HSMCRITCOMPRESSED_VALUE_F   204
#define IDS_HSMCRITLINKED_VALUE_T       205
#define IDS_HSMCRITLINKED_VALUE_F       206
#define IDS_HSMCRITMBIT_VALUE_T         207
#define IDS_HSMCRITMBIT_VALUE_F         208
#define IDS_HSMCRITMANAGEABLE_VALUE_T   209
#define IDS_HSMCRITMANAGEABLE_VALUE_F   210
#define IDS_HSMCRITMIGRATED_VALUE_T     211
#define IDS_HSMCRITMIGRATED_VALUE_F     212
#define IDS_HSMCRITPREMIGRATED_VALUE_T  213
#define IDS_HSMCRITPREMIGRATED_VALUE_F  214

#define IDS_HSM_CRITERIACOMPARATOR_NOTSET 301
#define IDS_HSM_CRITERIACOMPARATOR_LT   302
#define IDS_HSM_CRITERIACOMPARATOR_LTE  303
#define IDS_HSM_CRITERIACOMPARATOR_EQL  304
#define IDS_HSM_CRITERIACOMPARATOR_NEQL  305
#define IDS_HSM_CRITERIACOMPARATOR_GTE  306
#define IDS_HSM_CRITERIACOMPARATOR_GT   307
#define IDS_HSM_CRITERIACOMPARATOR_BETWEEN 308
#define IDS_HSM_CRITERIACOMPARATOR_OUTSIDE 309
#define IDS_HSM_CRITERIACOMPARATOR_MEMBEROF 310

#define IDS_HSMJOBPRIORITY_IDLE         320
#define IDS_HSMJOBPRIORITY_LOWEST       321
#define IDS_HSMJOBPRIORITY_LOW          322
#define IDS_HSMJOBPRIORITY_NORMAL       323
#define IDS_HSMJOBPRIORITY_HIGH         324
#define IDS_HSMJOBPRIORITY_HIGHEST      325
#define IDS_HSMJOBPRIORITY_CRITICAL     326

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        401
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\job\job.cpp ===
// job.cpp : Implementation of DLL Exports.

// You will need the NT SUR Beta 2 SDK or VC 4.2 in order to build this 
// project.  This is because you will need MIDL 3.00.15 or higher and new
// headers and libs.  If you have VC 4.2 installed, then everything should
// already be configured correctly.

// Note: Proxy/Stub Information
//      To merge the proxy/stub code into the object DLL, add the file 
//      dlldatax.c to the project.  Make sure precompiled headers 
//      are turned off for this file, and add _MERGE_PROXYSTUB to the 
//      defines for the project.  
//
//      Modify the custom build rule for job.idl by adding the following 
//      files to the Outputs.  You can select all of the .IDL files by 
//      expanding each project and holding Ctrl while clicking on each of them.
//          job_p.c
//          dlldata.c
//      To build a separate proxy/stub DLL, 
//      run nmake -f jobps.mak in the project directory.

#include "stdafx.h"
#include "resource.h"
#include "initguid.h"

#include "wsb.h"
#include "fsa.h"
#include "job.h"
#include "task.h"
#include "hsmcrit.h"
#include "hsmactn.h"
#include "hsmacrsc.h"
#include "hsmjob.h"
#include "hsmjobcx.h"
#include "hsmjobdf.h"
#include "hsmjobwi.h"
#include "hsmphase.h"
#include "hsmpolcy.h"
#include "hsmrule.h"
#include "hsmrlstk.h"
#include "hsmscan.h"
#include "hsmsess.h"
#include "hsmsesst.h"

#include "dlldatax.h"

#ifdef _MERGE_PROXYSTUB
extern "C" HINSTANCE hProxyDll;
#endif

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_CHsmActionCopy,  CHsmActionCopy)
    OBJECT_ENTRY(CLSID_CHsmActionDelete, CHsmActionDelete)
    OBJECT_ENTRY(CLSID_CHsmActionManage, CHsmActionManage)
    OBJECT_ENTRY(CLSID_CHsmActionMigrate, CHsmActionMigrate)
    OBJECT_ENTRY(CLSID_CHsmActionMove, CHsmActionMove)
    OBJECT_ENTRY(CLSID_CHsmActionOnResourcePreUnmanage, CHsmActionOnResourcePreUnmanage)
    OBJECT_ENTRY(CLSID_CHsmActionOnResourcePostUnmanage, CHsmActionOnResourcePostUnmanage)
    OBJECT_ENTRY(CLSID_CHsmActionOnResourcePreScanUnmanage, CHsmActionOnResourcePreScanUnmanage)
    OBJECT_ENTRY(CLSID_CHsmActionOnResourcePostValidate, CHsmActionOnResourcePostValidate)
    OBJECT_ENTRY(CLSID_CHsmActionOnResourcePreValidate, CHsmActionOnResourcePreValidate)
    OBJECT_ENTRY(CLSID_CHsmActionRecall, CHsmActionRecall)
    OBJECT_ENTRY(CLSID_CHsmActionRecycle, CHsmActionRecycle)
    OBJECT_ENTRY(CLSID_CHsmActionTruncate, CHsmActionTruncate)
    OBJECT_ENTRY(CLSID_CHsmActionUnmanage, CHsmActionUnmanage)
    OBJECT_ENTRY(CLSID_CHsmActionValidate, CHsmActionValidate)

    OBJECT_ENTRY(CLSID_CHsmCritAccessTime, CHsmCritAccessTime)
    OBJECT_ENTRY(CLSID_CHsmCritAlways, CHsmCritAlways)
    OBJECT_ENTRY(CLSID_CHsmCritCompressed, CHsmCritCompressed)
    OBJECT_ENTRY(CLSID_CHsmCritLinked, CHsmCritLinked)
    OBJECT_ENTRY(CLSID_CHsmCritMbit, CHsmCritMbit)
    OBJECT_ENTRY(CLSID_CHsmCritManageable, CHsmCritManageable)
    OBJECT_ENTRY(CLSID_CHsmCritMigrated, CHsmCritMigrated)
    OBJECT_ENTRY(CLSID_CHsmCritPremigrated, CHsmCritPremigrated)
    OBJECT_ENTRY(CLSID_CHsmCritGroup, CHsmCritGroup)
    OBJECT_ENTRY(CLSID_CHsmCritLogicalSize, CHsmCritLogicalSize)
    OBJECT_ENTRY(CLSID_CHsmCritModifyTime, CHsmCritModifyTime)
    OBJECT_ENTRY(CLSID_CHsmCritOwner, CHsmCritOwner)
    OBJECT_ENTRY(CLSID_CHsmCritPhysicalSize, CHsmCritPhysicalSize)

    OBJECT_ENTRY(CLSID_CHsmJob, CHsmJob)
    OBJECT_ENTRY(CLSID_CHsmJobContext, CHsmJobContext)
    OBJECT_ENTRY(CLSID_CHsmJobDef, CHsmJobDef)
    OBJECT_ENTRY(CLSID_CHsmJobWorkItem, CHsmJobWorkItem)
    OBJECT_ENTRY(CLSID_CHsmPhase, CHsmPhase)
    OBJECT_ENTRY(CLSID_CHsmPolicy, CHsmPolicy)
    OBJECT_ENTRY(CLSID_CHsmRule, CHsmRule)
    OBJECT_ENTRY(CLSID_CHsmRuleStack, CHsmRuleStack)
    OBJECT_ENTRY(CLSID_CHsmScanner, CHsmScanner)
    OBJECT_ENTRY(CLSID_CHsmSession, CHsmSession)
    OBJECT_ENTRY(CLSID_CHsmSessionTotals, CHsmSessionTotals)

END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    lpReserved;
#ifdef _MERGE_PROXYSTUB
    if (!PrxDllMain(hInstance, dwReason, lpReserved))
        return FALSE;
#endif
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllCanUnloadNow() != S_OK)
        return S_FALSE;
#endif
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
        return S_OK;
#endif
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    HRESULT hr;
#ifdef _MERGE_PROXYSTUB
    HRESULT hRes = PrxDllRegisterServer();
    if (FAILED(hRes))
        return hRes;
#endif
    // registers object, typelib and all interfaces in typelib
    // Not registering the Type Library right now
    hr = CoInitialize( 0 );
    if (SUCCEEDED(hr)) {
        hr = _Module.RegisterServer( FALSE );
        CoUninitialize( );
    }
    return( hr );
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    HRESULT hr;

#ifdef _MERGE_PROXYSTUB
    PrxDllUnregisterServer();
#endif
    hr = CoInitialize( 0 );
    if (SUCCEEDED(hr)) {
      _Module.UnregisterServer();
      CoUninitialize( );
      hr = S_OK;
    }

    return( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\job\dll\makefile.inc ===
$(O)\job.res: ..\hsmactcp.rgs  \
              ..\hsmactdl.rgs  \
              ..\hsmactmg.rgs  \
              ..\hsmactmt.rgs  \
              ..\hsmactmv.rgs  \
              ..\hsmactrl.rgs  \
              ..\hsmactrc.rgs  \
              ..\hsmacttr.rgs  \
              ..\hsmactum.rgs  \
              ..\hsmactvl.rgs  \
              ..\hsmcrtat.rgs  \
              ..\hsmcrtal.rgs  \
              ..\hsmcrtcp.rgs  \
              ..\hsmcrtgp.rgs  \
              ..\hsmcrtlk.rgs  \
              ..\hsmcrtls.rgs  \
              ..\hsmcrtmb.rgs  \
              ..\hsmcrtmd.rgs  \
              ..\hsmcrtmg.rgs  \
              ..\hsmcrtmt.rgs  \
              ..\hsmcrtow.rgs  \
              ..\hsmcrtps.rgs  \
              ..\hsmcrtpd.rgs  \
              ..\hsmjob.rgs    \
              ..\hsmjobdf.rgs  \
              ..\hsmjobcx.rgs  \
              ..\hsmpolcy.rgs  \
              ..\hsmrule.rgs   \
              ..\hsmjobwi.rgs  \
              ..\hsmscan.rgs   \
              ..\hsmsess.rgs   \
              ..\hsmphase.rgs  \
              ..\hsmsesst.rgs  \
              ..\hsmrlstk.rgs  \
              ..\$(O)\joblib.tlb
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\kdexts\help.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    help.c

Abstract:

    help for HSM kd extensions
Author:

    Ravisankar Pudipeddi 22 June 1998

Environment:

    User Mode.

Revision History:

--*/

#include "pch.h"


DECLARE_API( help )
{

    dprintf("\nHSM Debugger Extensions\n");
 
    dprintf("rpfilename <filename> [flags]"
            "       - dumps the context for the specified filename\n"
            "           filename: dumps entries matching the filename\n"
            "           flags:    1 - verbose\n");

    dprintf("rpfilecontext <filecontext> [flags]"
            "       -  dumps the specified file context\n"
            "          flags: 1 - verbose\n"
	    "                 2 - dump all entries from <filecontext> (or from queue head if it is 0)\n");

    dprintf("rpfileobj <fileobj>              [flags]  -  dumps the specified RP_FILE_OBJ entry\n");
    dprintf("rpirp     <irp_queue_entry>      [flags]  -  dumps the specified RP_IRP_QUEUE entry\n");
    dprintf("rpmsg     <RP_MSG_ENTRY pointer>          -  dumps the specified RP_MSG_ENTRY\n");
    dprintf("rpbuf     <cache_buffer_entry>   [flags]  -  dumps the specified RP_FILE_BUF entry\n");
    dprintf("rpbucket  <bucket-number>        [flags]  -  dumps the specified cache hash bucket\n");
    dprintf("rplru                            [flags]  -  dumps the list of file buffers on the LRU\n");
    dprintf("rpdata    <rpdata>               [flags]  -  dumps the reparse point data\n");
    dprintf("rpsummary                                 -  dumps assorted counters and variables\n");
    dprintf("rpvalque  <q-head>               [flags]  -  counts the number of entries in the queue optionally dumping entry details\n");
    dprintf("rpioq                            [flags]  -  dumps the queue of Irps for sending requests to the recall engine\n");
    dprintf("\n");
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\kdexts\hsmkd.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    kdexts.c

Abstract:

    This file contains the generic routines and initialization code
    for the kernel debugger extensions dll.

Author:

    Wesley Witt (wesw) 26-Aug-1993

Environment:

    User Mode

--*/

#include "pch.h"
#pragma hdrstop

#include <ntverp.h>
#include <imagehlp.h>

//
// globals
//
EXT_API_VERSION		ApiVersion = { (VER_PRODUCTVERSION_W >> 8), (VER_PRODUCTVERSION_W & 0xff), EXT_API_VERSION_NUMBER64, 0 };
WINDBG_EXTENSION_APIS	ExtensionApis;

USHORT			SavedMajorVersion;
USHORT			SavedMinorVersion;

ULONG			STeip;
ULONG			STebp;
ULONG			STesp;



DllInit(
    HANDLE hModule,
    DWORD  dwReason,
    DWORD  dwReserved
    )
{
    switch (dwReason) {
        case DLL_THREAD_ATTACH:
            break;

        case DLL_THREAD_DETACH:
            break;

        case DLL_PROCESS_DETACH:
            break;

        case DLL_PROCESS_ATTACH:
            break;
    }

    return TRUE;
}


VOID
WinDbgExtensionDllInit(
    PWINDBG_EXTENSION_APIS64 lpExtensionApis,
    USHORT MajorVersion,
    USHORT MinorVersion
    )
{
    ExtensionApis = *lpExtensionApis;

    SavedMajorVersion = MajorVersion;
    SavedMinorVersion = MinorVersion;

    return;
}

DECLARE_API( version )
{
#if DBG
    PCHAR DebuggerType = "Checked";
#else
    PCHAR DebuggerType = "Free";
#endif

    dprintf( "%s Extension dll for Build %d debugging %s kernel for Build %d\n",
             DebuggerType,
             VER_PRODUCTBUILD,
             SavedMajorVersion == 0x0c ? "Checked" : "Free",
             SavedMinorVersion
           );
}

VOID
CheckVersion(
    VOID
    )
{
#if DBG
    if ((SavedMajorVersion != 0x0c) || (SavedMinorVersion != VER_PRODUCTBUILD)) {
        dprintf("\r\n*** Extension DLL(%d Checked) does not match target system(%d %s)\r\n\r\n",
                VER_PRODUCTBUILD, SavedMinorVersion, (SavedMajorVersion==0x0f) ? "Free" : "Checked" );
    }
#else
    if ((SavedMajorVersion != 0x0f) || (SavedMinorVersion != VER_PRODUCTBUILD)) {
        dprintf("\r\n*** Extension DLL(%d Free) does not match target system(%d %s)\r\n\r\n",
                VER_PRODUCTBUILD, SavedMinorVersion, (SavedMajorVersion==0x0f) ? "Free" : "Checked" );
    }
#endif
}

LPEXT_API_VERSION
ExtensionApiVersion(
    VOID
    )
{
    return &ApiVersion;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\kdexts\filter.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    rpfilter.c

Abstract:

    WinDbg Extension Api to dump the HSM filter driver structures.

Author:

    Ravisankar Pudipeddi (ravisp)  22 June, 1998

Environment:

    User Mode.

--*/


#include "pch.h"
#pragma hdrstop

#include "rpdata.h"
#include "rpio.h"
#include "rpfsa.h"
#include "local.h"



typedef struct _ENUM_NAME {
    PUCHAR Name;
} ENUM_NAME, *PENUM_NAME;

typedef struct _FLAG_NAME {
    ULONG  Flag;
    PUCHAR Name;
} FLAG_NAME, *PFLAG_NAME;

#define ENUM_NAME(val)    #val

#define FLAG_NAME(flag)   {flag, #flag}

/*
** Index by command. See inc\rpio.h
*/
ENUM_NAME RpCommands[] = {
    ENUM_NAME(Undefined),		//  0
    ENUM_NAME(RP_GET_REQUEST),		//  1
    ENUM_NAME(Undefined),		//  2
    ENUM_NAME(RP_RECALL_COMPLETE),	//  3
    ENUM_NAME(RP_SUSPEND_NEW_RECALLS),	//  4
    ENUM_NAME(RP_ALLOW_NEW_RECALLS),	//  5
    ENUM_NAME(RP_CANCEL_ALL_RECALLS),	//  6
    ENUM_NAME(RP_CANCEL_ALL_DEVICEIO),	//  7
    ENUM_NAME(RP_GET_RECALL_INFO),	//  8
    ENUM_NAME(RP_SET_ADMIN_SID),	//  9
    ENUM_NAME(RP_PARTIAL_DATA),		// 10
    ENUM_NAME(RP_CHECK_HANDLE),		// 11
    ENUM_NAME(Undefined),		// 12
    ENUM_NAME(Undefined),		// 13
    ENUM_NAME(Undefined),		// 14
    ENUM_NAME(Undefined),		// 15
    ENUM_NAME(Undefined),		// 16
    ENUM_NAME(Undefined),		// 17
    ENUM_NAME(Undefined),		// 18
    ENUM_NAME(Undefined),		// 19
    ENUM_NAME(RP_OPEN_FILE),		// 20
    ENUM_NAME(RP_RECALL_FILE),		// 21
    ENUM_NAME(RP_CLOSE_FILE),		// 22
    ENUM_NAME(RP_CANCEL_RECALL),	// 23
    ENUM_NAME(RP_RUN_VALIDATE),		// 24
    ENUM_NAME(RP_START_NOTIFY),		// 25
    ENUM_NAME(RP_END_NOTIFY)		// 26
};

FLAG_NAME  RpFileContextFlags[] = {
    FLAG_NAME(RP_FILE_WAS_WRITTEN),                  
    FLAG_NAME(RP_FILE_INITIALIZED),                  
    FLAG_NAME(RP_FILE_REPARSE_POINT_DELETED),
    {0,0}    
};

FLAG_NAME  RpFileObjFlags[] = {
    FLAG_NAME(RP_NO_DATA_ACCESS),
    FLAG_NAME(RP_OPEN_BY_ADMIN),
    FLAG_NAME(RP_OPEN_LOCAL),
    FLAG_NAME(RP_NOTIFICATION_SENT),
    {0,0}
};

FLAG_NAME  RpReparsePointFlags[] = {
    FLAG_NAME(RP_FLAG_TRUNCATED),
    FLAG_NAME(RP_FLAG_TRUNCATE_ON_CLOSE),
    FLAG_NAME(RP_FLAG_PREMIGRATE_ON_CLOSE),
    FLAG_NAME(RP_FLAG_ENGINE_ORIGINATED),
    {0,0}
};

FLAG_NAME  RpReparseIrpFlags[] = {
    FLAG_NAME(RP_IRP_NO_RECALL),
    {0,0}
};

//
// Define flags
//

#define RPDBG_VERBOSE       1
#define RPDBG_PRINT_ALL     2



VOID
DumpUnicode (IN UNICODE_STRING unicodeString);

VOID
DumpRpIrp (IN ULONG64 ul64addrIrp, 
	   IN ULONG   flags,
	   IN ULONG   depth);

VOID
DumpRpFileObj (IN ULONG64 ul64addrFileObject,
               IN ULONG   Flags);

VOID
DumpRpFileContext (IN ULONG64 ul64addrFileContext, 
		   IN ULONG   fFlags); 

VOID
DumpRpFileBuf (IN ULONG64 ul64addrFileBuffer,
	       IN ULONG   flags,
	       IN ULONG   depth);

VOID
DumpRpHashBucket (IN LONG  BucketNumber,
		  IN ULONG Flags,
		  IN ULONG Depth);

VOID
DumpRpLru (IN ULONG Flags,
	   IN ULONG Depth);

VOID
DumpRpMsg (IN ULONG64 ul64addrMessage,
	   IN ULONG   Flags,
	   IN ULONG   Depth);

VOID
DumpFlags (IN ULONG Depth,
	   IN LPSTR FlagDescription,
	   IN ULONG Flags,
	   IN PFLAG_NAME FlagTable);

VOID
DumpRpData (IN ULONG64 ul64addrReparsePointData,
	    IN ULONG   fFlags);


/*
********************************************************************
********************************************************************
********************************************************************
********************************************************************
*/


DECLARE_API (rpfilename) 
/*++

Routine Description:

    Finds an RP_FILE_CONTEXT entry of the specified file name
    and dumps it

Arguments:

    args - the location of the entry to dump

Return Value:

    none
--*/
    {
    ULONG64		ul64addrRsFileContextQHead   = 0;
    ULONG64		ul64addrFileContextListQHead = 0;
    ULONG64		ul64addrFileContext          = 0;
    ULONG64		ul64addrFilename             = 0;
    ULONG64		ul64addrFlink                = 0;
    ULONG64		ul64addrFilenameBuffer       = 0;
    ULONG		ulOffsetListFlink            = 0;
    ULONG		fFlags                       = 0;
    const ULONG		fLegalFlags                  = RPDBG_VERBOSE;
    BOOLEAN		fileNameAllocated            = FALSE;
    BOOLEAN		fFound                       = FALSE;
    NTSTATUS		status;
    UNICODE_STRING	fileName;
    ANSI_STRING		ansiString;
    UCHAR		uchBuffer [256];



    RtlZeroMemory (uchBuffer, sizeof (uchBuffer));

    sscanf (args, "%s %lx", uchBuffer, &fFlags);


    if ((0 != fFlags) && ((fFlags & fLegalFlags) == 0))
	{
	dprintf("Illegal flags specified\n");
	return;
	}


    if ('\0' == uchBuffer [0]) 
	{
	dprintf ("Illegal filename specified\n");
	return;
	}
    else
	{
	RtlInitAnsiString (&ansiString,
			   (PCSZ) uchBuffer);

	status = RtlAnsiStringToUnicodeString (&fileName,
					       &ansiString,
					       TRUE);
	if (NT_SUCCESS (status)) 
	    {
	    fileNameAllocated = TRUE;
	    }
        }


    ul64addrRsFileContextQHead = GetExpression ("RsFilter!RsFileContextQHead");

    if (0 == ul64addrRsFileContextQHead) 
	{
	dprintf("Error retrieving address of RsFileContextQHead\n");
	return;
	}


    GetFieldValue (ul64addrRsFileContextQHead, "LIST_ENTRY", "Flink", ul64addrFlink);

    GetFieldOffset ("RP_FILE_CONTEXT", "list.Flink", &ulOffsetListFlink);


    if (ul64addrFlink == ul64addrRsFileContextQHead)
	{
	dprintf ("RsFileContextQ empty, list head @ 0x%I64x\n", ul64addrRsFileContextQHead);
	}

    else
	{
	while (!CheckControlC () && !fFound && (ul64addrFlink != ul64addrRsFileContextQHead))
	    {
	    UNICODE_STRING	ucsFilenameLocalCopy;


	    ul64addrFileContext = ul64addrFlink - ulOffsetListFlink;

	    GetFieldValue (ul64addrFileContext, "RP_FILE_CONTEXT", "uniName", ul64addrFilename);

	    GetFieldValue (ul64addrFilename, "OBJECT_NAME_INFORMATION", "Name.MaximumLength", ucsFilenameLocalCopy.MaximumLength);
	    GetFieldValue (ul64addrFilename, "OBJECT_NAME_INFORMATION", "Name.Length",        ucsFilenameLocalCopy.Length);
	    GetFieldValue (ul64addrFilename, "OBJECT_NAME_INFORMATION", "Name.Buffer",        ul64addrFilenameBuffer);


	    ucsFilenameLocalCopy.Buffer = LocalAlloc (LPTR, ucsFilenameLocalCopy.MaximumLength);

	    if (NULL != ucsFilenameLocalCopy.Buffer)
		{
		fFound = ((xReadMemory (ul64addrFilenameBuffer, ucsFilenameLocalCopy.Buffer, ucsFilenameLocalCopy.Length)) &&
			  (0 == RtlCompareUnicodeString (&fileName, &ucsFilenameLocalCopy, TRUE)));

		if (fFound)
		    {
		    DumpRpFileContext (ul64addrFileContext, fFlags);
		    }

		LocalFree (ucsFilenameLocalCopy.Buffer);
		}

	    GetFieldValue (ul64addrFileContext, "RP_FILE_CONTEXT", "list.Flink", ul64addrFlink);
	    }
	}


    if (fileNameAllocated) RtlFreeUnicodeString (&fileName);
    }


DECLARE_API (rpfilecontext) 
/*++

Routine Description:

    Finds an RP_FILE_CONTEXT entry of the specified file name
    and dumps it

Arguments:

    args - the location of the entry to dump

Return Value:

    none
--*/
    {
    ULONG64	ul64addrRsFileContextQHead   = 0;
    ULONG64	ul64addrFileContextListQHead = 0;
    ULONG64	ul64addrFileContext          = 0;
    ULONG64	ul64addrFileContextRequested = 0;
    ULONG64	ul64addrFlink                = 0;
    ULONG	ulOffsetListFlink            = 0;
    ULONG	fFlags                       = 0;
    const ULONG	fLegalFlags                  = RPDBG_VERBOSE | RPDBG_PRINT_ALL;
    BOOLEAN	fFound                       = FALSE;
    BOOLEAN	fDumpFollowingEntries        = FALSE;
    NTSTATUS	status;



    if (GetExpressionEx (args, &ul64addrFileContextRequested, &args))
	{
	sscanf (args, "%lx", &fFlags);

	if ((0 != fFlags) && ((fFlags & fLegalFlags) == 0))
	    {
	    dprintf("Illegal flags specified\n");
	    return;
	    }

	else
	    {
	    fDumpFollowingEntries = (0 != (fFlags & RPDBG_PRINT_ALL));
	    }
	}
    else
	{
	dprintf ("Trouble parsing the command line for rpfilecontext\n");

	return;
	}



    ul64addrRsFileContextQHead = GetExpression ("RsFilter!RsFileContextQHead");

    if (0 == ul64addrRsFileContextQHead) 
	{
	dprintf("Error retrieving address of RsFileContextQHead\n");
	return;
	}



    GetFieldValue (ul64addrRsFileContextQHead, "LIST_ENTRY", "Flink", ul64addrFlink);

    GetFieldOffset ("RP_FILE_CONTEXT", "list.Flink", &ulOffsetListFlink);


    if (ul64addrFlink == ul64addrRsFileContextQHead)
	{
	dprintf ("RsFileContextQ empty, list head @ 0x%I64x\n", ul64addrRsFileContextQHead);
	}

    else
	{
	while (!CheckControlC () && (!fFound || fDumpFollowingEntries) && (ul64addrFlink != ul64addrRsFileContextQHead))
	    {
	    ul64addrFileContext = ul64addrFlink - ulOffsetListFlink;


	    if (ul64addrFileContext == ul64addrFileContextRequested)
		{
		/*
		** Enable dumping of current and possibly all following entries.
		*/
		fFound = TRUE;
		}


	    if (fFound || (0 == ul64addrFileContextRequested))
		{
		DumpRpFileContext (ul64addrFileContext, fFlags);
		}


	    GetFieldValue (ul64addrFileContext, "RP_FILE_CONTEXT", "list.Flink", ul64addrFlink);
	    }

	if (!fFound && (0 != ul64addrFileContextRequested)) 
	    {
	    dprintf ("Specified context 0x%I64x not found\n", ul64addrFileContextRequested);
	    }
	}
    }


DECLARE_API (rpfileobj) 
/*++

Routine Description:

    Dumnps RP_FILE_OBJ entries 

Arguments:

    args - the location of the entry to dump

Return Value:

    none
--*/
    {
    ULONG64	ul64addrFileObject = 0;
    ULONG	fFlags             = 0;


    if (GetExpressionEx (args, &ul64addrFileObject, &args))
	{
	sscanf (args, "%x", &fFlags);

	DumpRpFileObj (ul64addrFileObject, fFlags);
	}
    else
	{
	dprintf ("Trouble parsing the command line for rpfileobj\n");
	}
    }


DECLARE_API (rpirp)
/*++

Routine Description:

    Dumps a pending IRP (RP_IRP_QUEUE) entry 

Arguments:

    args - the location of the entry to dump

Return Value:

    none
--*/
    {
    ULONG64	ul64addrPendingIrp = 0;
    ULONG	fFlags             = 0;
    ULONG	fLegalFlags        = RPDBG_VERBOSE;


    if (GetExpressionEx (args, &ul64addrPendingIrp, &args))
	{
	sscanf (args, "%lx", &fFlags);

	if ((0 != fFlags) && ((fFlags & fLegalFlags) == 0))
	    {
	    dprintf("Illegal flags specified\n");
	    return;
	    }
	}
    else
	{
	dprintf ("Trouble parsing the command line for rpirp\n");

	return;
	}



    DumpRpIrp (ul64addrPendingIrp, fFlags, 0);

    return;
    }


DECLARE_API (rpbuf)
/*++

Routine Description

    Dumps a specfied cache file buffer

Arguments
    
    Pointer to the file buffer

Return Value

    none
--*/
    {
    ULONG64	ul64addrFileBuffer = 0;
    ULONG	fFlags             = 0;


    if (GetExpressionEx (args, &ul64addrFileBuffer, &args))
	{
	sscanf (args, "%x", &fFlags);

	DumpRpFileBuf (ul64addrFileBuffer, fFlags, 0);
	}
    else
	{
	dprintf ("Trouble parsing the command line for rpbuf\n");
	}
    }


DECLARE_API (rpbucket)
/*++

Routine Description

    Dumps a specfied cache bucket: if the bucket number
    is not supplied or it is -1, dumps all the buckets


Arguments
    
    number of bucket

Return Value

    none
--*/
    {
    ULONG	fFlags                  = 0;
    LONG        bucketNumber            = -1;
    LONG	maxBucket               = 0;
    LONG	i;

    maxBucket = GetUlongValue ("RsFilter!RspCacheMaxBuckets");

    sscanf (args, "%lx %lx", &bucketNumber, &fFlags);

    if (bucketNumber == -1) 
	{
        for (i = 0; i < maxBucket; i++) 
	    {
            DumpRpHashBucket (i, fFlags, 0);
	    }
	}
 
    else if (bucketNumber <= maxBucket)
	{
        DumpRpHashBucket (bucketNumber, fFlags, 0);
	}

    else
	{
	dprintf ("Specified bucket doesn't exist (max bucket = 0x%x)\n");
	}
    }
        

DECLARE_API (rplru)
/*++

Routine Description

    Dumps a specfied cache bucket

Arguments
    
    number of bucket

Return Value

    none
--*/
    {
    ULONG        fFlags = 0;

    sscanf (args, "%lx",  &fFlags);

    DumpRpLru (fFlags, 0);
    }


VOID
DumpRpFileBufWaitQueue (IN ULONG64 ul64addrFileBufferQHead,
			IN ULONG   depth)
    {
    ULONG64	ul64addrFlink;
    ULONG64	ul64addrIrp;
    ULONG	ulOffsetFileBufferWaitQueue;

    PLIST_ENTRY entryAddr;
    LIST_ENTRY  entry;
    PIRP        irp;

    xdprintf (depth, "Queue of IRPs waiting on this block:\n");

    GetFieldValue (ul64addrFileBufferQHead, "LIST_ENTRY", "Flink", ul64addrFlink);


    /*
    ** Need to calculate the offset of Tail.Overlay.DriverContext[2]
    ** or whatever is being used now. Needs to be kept in sync with
    ** the calculation in RsCacheIrpWaitQueueContainingIrp() in
    ** filter\rpcache.c
    **
    ** Currently the required field is Tail.Overlay.DriverContext[2]
    */
    GetFieldOffset ("IRP", "Tail.Overlay.DriverContext", &ulOffsetFileBufferWaitQueue);

    ulOffsetFileBufferWaitQueue += 2 * GetTypeSize ("PVOID");


    while (ul64addrFlink != ul64addrFileBufferQHead)
	{
	ul64addrIrp = ul64addrFlink - ulOffsetFileBufferWaitQueue;

	xdprintf (depth, "0x%I64x ", ul64addrIrp);

	GetFieldValue (ul64addrFlink, "LIST_ENTRY", "Flink", ul64addrFlink);
	}

    dprintf("\n");
    }


VOID
DumpRpFileBuf (IN ULONG64 ul64addrFileBuffer,
	       IN ULONG   fFlags,
	       IN ULONG   depth)
    {
    ULONG	ulState = 0;

    xdprintf (depth, 
	      "RP_FILE_BUF ENTRY @ 0x%I64X\n", 
	      ul64addrFileBuffer);

    xdprintf (depth, 
	      "Volume Serial 0x%X  File Id 0x%I64X  Block 0x%I64X\n", 
	      GetFieldValueUlong32 (ul64addrFileBuffer, "RP_FILE_BUF", "VolumeSerial"),
	      GetFieldValueUlong64 (ul64addrFileBuffer, "RP_FILE_BUF", "FileId"),
	      GetFieldValueUlong64 (ul64addrFileBuffer, "RP_FILE_BUF", "Block"));


    if (!(fFlags & RPDBG_VERBOSE)) 
	{
        return;
	}


    xdprintf(depth, "State         ");

    ulState = GetFieldValueUlong32 (ul64addrFileBuffer, "RP_FILE_BUF", "State");

    switch (ulState)
	{
        case RP_FILE_BUF_INVALID: xdprintf (depth, "RP_FILE_BUF_INVALID");                break;
        case RP_FILE_BUF_IO:      xdprintf (depth, "RP_FILE_BUF_IO");                     break;
        case RP_FILE_BUF_VALID:   xdprintf (depth, "RP_FILE_BUF_VALID");                  break;
        case RP_FILE_BUF_ERROR:   xdprintf (depth, "RP_FILE_BUF_ERROR");                  break;
        default:                  xdprintf (depth, "UNKNOWN STATE 0x%X", ulState);        break;
	}


    dprintf("   ");
    xdprintf (depth, "IoStatus        0x%x\n",    GetFieldValueUlong32 (ul64addrFileBuffer, "RP_FILE_BUF", "IoStatus"));
    xdprintf (depth, "Usn             0x%I64x\n", GetFieldValueUlong64 (ul64addrFileBuffer, "RP_FILE_BUF", "Usn"));
    xdprintf (depth, "Data @          0x%I64x\n", GetFieldValueUlong64 (ul64addrFileBuffer, "RP_FILE_BUF", "Data"));
    xdprintf (depth, "Lru Links @     0x%I64x\n", GetFieldValueUlong64 (ul64addrFileBuffer, "RP_FILE_BUF", "LruLinks"));
    xdprintf (depth, "Bucket Links @  0x%I64x\n", GetFieldValueUlong64 (ul64addrFileBuffer, "RP_FILE_BUF", "BucketLinks"));


    //
    // Dump the wait queue
    //
    DumpRpFileBufWaitQueue (GetFieldValueUlong64 (ul64addrFileBuffer, "RP_FILE_BUF", "WaitQueue"),
			    depth);
    
}


VOID
DumpRpIrp(IN ULONG64 ul64addrIrp, 
	  IN ULONG   flags,
          IN ULONG   depth) 

/*++

Routine Description:

    Dumps  RP_IRP_QUEUE

Arguments:

    rpIrp       - pointer to the RP_IRP_QUEUE structure (local)
    rpIrpAddr   - address of the structure to dump on the target machine
    depth       - indentation

Return Value:

    none
--*/
    {
    xdprintf (depth, "RP_IRP_QUEUE ENTRY @ 0x%I64x\n", ul64addrIrp);
 
    xdprintf (depth, "Lists Entries\n");
    xdprintf (depth, "  Flink              0x%I64x\n",    GetFieldValueUlong64 (ul64addrIrp, "RP_IRP_QUEUE", "list.Flink"));
    xdprintf (depth, "  Blink              0x%I64x\n",    GetFieldValueUlong64 (ul64addrIrp, "RP_IRP_QUEUE", "list.Blink"));
    xdprintf (depth, "Irp                  0x%I64x\n",    GetFieldValueUlong64 (ul64addrIrp, "RP_IRP_QUEUE", "irp"));

    DumpFlags (depth, "Flags               ",             GetFieldValueUlong32 (ul64addrIrp, "RP_IRP_QUEUE", "flags"), RpReparseIrpFlags);

    xdprintf (depth, "ReadId               0x%I64x\n",    GetFieldValueUlong64 (ul64addrIrp, "RP_IRP_QUEUE", "readId"));
    xdprintf (depth, "Recall offset        0x%016I64x\n", GetFieldValueUlong64 (ul64addrIrp, "RP_IRP_QUEUE", "recallOffset"));
    xdprintf (depth, "Recall length        0x%016I64x\n", GetFieldValueUlong64 (ul64addrIrp, "RP_IRP_QUEUE", "recallLength"));
    xdprintf (depth, "UserBuffer           0x%016I64x\n", GetFieldValueUlong64 (ul64addrIrp, "RP_IRP_QUEUE", "userBuffer"));
    xdprintf (depth, "  Offset             0x%016I64x\n", GetFieldValueUlong64 (ul64addrIrp, "RP_IRP_QUEUE", "offset"));
    xdprintf (depth, "  Length             0x%016I64x\n", GetFieldValueUlong64 (ul64addrIrp, "RP_IRP_QUEUE", "length"));
    xdprintf (depth, "CacheBuffer          0x%016I64x\n", GetFieldValueUlong64 (ul64addrIrp, "RP_IRP_QUEUE", "cacheBuffer"));
    xdprintf (depth, "DeviceExtension      0x%I64x\n",    GetFieldValueUlong64 (ul64addrIrp, "RP_IRP_QUEUE", "deviceExtension"));
    }


VOID
DumpRpFileContext (IN ULONG64 ul64addrFileContext, 
		   IN ULONG   fFlags) 
/*++

Routine Description:

    Dumps an RP_FILE_CONTEXT structure

Arguments:

    ul64addrFileContext - specificies the pointer on the target machine to the structure
    fFlags              - flags indicating degree of verbosity

Return Value:

    none

--*/
    {
    ULONG64		ul64addrFilename       = 0;
    ULONG64		ul64addrFilenameBuffer = 0;
    ULONG64		ul64addrQHead          = 0;
    ULONG64		ul64addrFlink          = 0;
    ULONG64		ul64Value;
    ULONG		ulValue;
    ULONG		ulTargetFlags          = 0;
    ULONG		ulTargetState          = 0;
    ULONG		ulOffsetRpData;
    ULONG		ulOffsetQHead;
    UNICODE_STRING	ucsFilenameLocalCopy;


    dprintf("FILE CONTEXT ENTRY @ 0x%I64x\n", ul64addrFileContext);

    GetFieldValue (ul64addrFileContext, "RP_FILE_CONTEXT", "flags", ulTargetFlags);
    GetFieldValue (ul64addrFileContext, "RP_FILE_CONTEXT", "state", ulTargetState);

    if (!(ulTargetFlags & RP_FILE_INITIALIZED)) 
	{
        dprintf("FileContextNotInitialized ");
	}


    if (ulTargetFlags & RP_FILE_WAS_WRITTEN) 
	{
        dprintf("FileWasWritten ");    
	}


    dprintf("State:                    ");

    switch (ulTargetState) 
	{
        case RP_RECALL_COMPLETED:    dprintf ("RecallCompleted"); break;
        case RP_RECALL_NOT_RECALLED: dprintf ("NotRecalled    "); break;
	case RP_RECALL_STARTED:      dprintf ("RecallStarted  "); break;
	default:                     dprintf ("Unknown        "); break;
	}

    dprintf(" (%u)\n", ulTargetState);


    GetFieldValue (ul64addrFileContext, "RP_FILE_CONTEXT", "uniName", ul64addrFilename);

    GetFieldValue (ul64addrFilename, "OBJECT_NAME_INFORMATION", "Name.MaximumLength", ucsFilenameLocalCopy.MaximumLength);
    GetFieldValue (ul64addrFilename, "OBJECT_NAME_INFORMATION", "Name.Length",        ucsFilenameLocalCopy.Length);
    GetFieldValue (ul64addrFilename, "OBJECT_NAME_INFORMATION", "Name.Buffer",        ul64addrFilenameBuffer);

    ucsFilenameLocalCopy.Buffer = LocalAlloc (LPTR, ucsFilenameLocalCopy.MaximumLength);

    if (NULL != ucsFilenameLocalCopy.Buffer)
	{
	if (xReadMemory (ul64addrFilenameBuffer, ucsFilenameLocalCopy.Buffer, ucsFilenameLocalCopy.Length))
	    {
            dprintf ("File name:                %wZ\n", &ucsFilenameLocalCopy);
	    }

	LocalFree (ucsFilenameLocalCopy.Buffer);
	}


    if (!(fFlags & RPDBG_VERBOSE)) 
	{
        dprintf("\n");
        return;
	}



    DumpFlags (0, "Flags                    ", ulTargetFlags, RpFileContextFlags);


    GetFieldOffset ("RP_FILE_CONTEXT", "fileObjects", &ulOffsetQHead);
    ul64addrQHead = ul64addrFileContext + ulOffsetQHead;

    GetFieldValue (ul64addrFileContext, "RP_FILE_CONTEXT", "fileObjects.Flink", ul64addrFlink);

    if (ul64addrFlink == ul64addrQHead)
	{
	dprintf ("FileObjectsQ empty Qhead  0x%I64x\n", ul64addrQHead);
	} 
    else 
	{
	dprintf ("FileObjects QHead         0x%I64x  first entry 0x%I64x\n", ul64addrQHead, ul64addrFlink);
	}


    GetFieldOffset ("RP_FILE_CONTEXT", "rpData", &ulOffsetRpData);

    dprintf ("File Object to write      0x%I64x\n", GetFieldValueUlong64 (ul64addrFileContext, "RP_FILE_CONTEXT", "fileObjectsToWrite"));
    dprintf ("FsContext                 0x%I64x\n", GetFieldValueUlong64 (ul64addrFileContext, "RP_FILE_CONTEXT", "fsContext"));
    dprintf ("Next write buffer         0x%I64x  ", GetFieldValueUlong64 (ul64addrFileContext, "RP_FILE_CONTEXT", "nextWriteBuffer"));
    dprintf ("Size 0x%x\n",                         GetFieldValueUlong32 (ul64addrFileContext, "RP_FILE_CONTEXT", "nextWriteSize"));
    dprintf ("File Id                   0x%I64x\n", GetFieldValueUlong64 (ul64addrFileContext, "RP_FILE_CONTEXT", "fileId"));
    dprintf ("Filter Id                 0x%I64x\n", GetFieldValueUlong64 (ul64addrFileContext, "RP_FILE_CONTEXT", "filterId"));
    dprintf ("Recall size               0x%I64x\n", GetFieldValueUlong64 (ul64addrFileContext, "RP_FILE_CONTEXT", "recallSize"));
    dprintf ("Current recall offset     0x%I64x\n", GetFieldValueUlong64 (ul64addrFileContext, "RP_FILE_CONTEXT", "currentOffset"));
    dprintf ("Recall status             0x%x\n",    GetFieldValueUlong32 (ul64addrFileContext, "RP_FILE_CONTEXT", "recallStatus"));
    dprintf ("Volume serial number      0x%x\n",    GetFieldValueUlong32 (ul64addrFileContext, "RP_FILE_CONTEXT", "serial"));
    dprintf ("Reference count           0x%x\n",    GetFieldValueUlong32 (ul64addrFileContext, "RP_FILE_CONTEXT", "refCount"));
    dprintf ("Usn                       0x%I64x\n", GetFieldValueUlong64 (ul64addrFileContext, "RP_FILE_CONTEXT", "usn"));
    dprintf ("CreateSectionLock         0x%x\n",    GetFieldValueUlong32 (ul64addrFileContext, "RP_FILE_CONTEXT", "createSectionLock"));
    dprintf ("Reparse Data @            0x%I64x\n", ul64addrFileContext + ulOffsetRpData);
    dprintf ("\n");
    }


VOID
DumpRpFileObj (IN ULONG64 ul64addrFileObject,
	       IN ULONG   Flags)
/*++

Routine Description:

    Dumps the supplied RP_FILE_OBJ entry

Arguments:

    FileObj      -    Pointer to contents of file obj entry      
    FileObjAddr  -    Address of this entry on remote machine
    Flags        -    Flags indicating degree of verbosity
                            
Return Value:

    none

--*/
    {
    ULONG64	ul64addrQHead;
    ULONG64	ul64addrFlink;
    ULONG	ulOffsetQHead;


    dprintf ("FILE OBJECT ENTRY @ 0x%I64x\n", ul64addrFileObject);

    dprintf ("Next entry               0x%I64x  Prev entry  0x%I64x\n", GetFieldValueUlong64 (ul64addrFileObject, "RP_FILE_OBJ", "list.Flink"), 
									GetFieldValueUlong64 (ul64addrFileObject, "RP_FILE_OBJ", "list.Blink"));
    dprintf ("File object              0x%I64x\n",			GetFieldValueUlong64 (ul64addrFileObject, "RP_FILE_OBJ", "fileObj"));
    dprintf ("File context entry       0x%I64x\n",			GetFieldValueUlong64 (ul64addrFileObject, "RP_FILE_OBJ", "fsContext"));



    GetFieldOffset ("RP_FILE_OBJ", "readQueue", &ulOffsetQHead);
    ul64addrQHead = ul64addrFileObject + ulOffsetQHead; 

    ul64addrFlink = GetFieldValueUlong64 (ul64addrFileObject, "RP_FILE_OBJ", "readQueue.Flink");

    if (ul64addrFlink == ul64addrQHead)
	{
        dprintf ("Read  IRP Q<empty> Qhead 0x%I64x\n", ul64addrQHead);
	} 
    else 
	{
        dprintf ("Read  IRP Q        QHead 0x%I64x first  entry 0x%I64x\n", ul64addrQHead, ul64addrFlink);
	}



    GetFieldOffset ("RP_FILE_OBJ", "writeQueue", &ulOffsetQHead);
    ul64addrQHead = ul64addrFileObject + ulOffsetQHead; 

    ul64addrFlink = GetFieldValueUlong64 (ul64addrFileObject, "RP_FILE_OBJ", "writeQueue.Flink");

    if (ul64addrFlink == ul64addrQHead)
	{
        dprintf ("Write IRP Q<empty> QHead 0x%I64x\n", ul64addrQHead);
	} 
    else  
	{
	dprintf ("Write IRP Q        QHead 0x%I64x  first entry 0x%I64x\n", ul64addrQHead, ul64addrFlink);
	}



    dprintf ("Open options             0x%x\n", GetFieldValueUlong64 (ul64addrFileObject, "RP_FILE_OBJ", "openOptions"));

    DumpFlags (0, "Flags                   ", GetFieldValueUlong32 (ul64addrFileObject, "RP_FILE_OBJ", "flags"), RpFileObjFlags); 

    dprintf ("ObjId Hi                 %I64x\n", GetFieldValueUlong64 (ul64addrFileObject, "RP_FILE_OBJ", "objIdHi"));
    dprintf ("ObjId Lo                 %I64x\n", GetFieldValueUlong64 (ul64addrFileObject, "RP_FILE_OBJ", "objIdLo"));
    dprintf ("FileId                   %I64x\n", GetFieldValueUlong64 (ul64addrFileObject, "RP_FILE_OBJ", "fileId"));
    dprintf ("FilterId                 %I64x\n", GetFieldValueUlong64 (ul64addrFileObject, "RP_FILE_OBJ", "filterId"));
    dprintf ("User security info @     %I64x\n", GetFieldValueUlong64 (ul64addrFileObject, "RP_FILE_OBJ", "userSecurityInfo"));
    }


VOID
DumpRpHashBucket (IN LONG  BucketNumber,
		  IN ULONG Flags,
		  IN ULONG Depth)
    {
    ULONG64	ul64addrBucketArray;
    ULONG64	ul64addrChainQHead;
    ULONG64	ul64addrFileBuffer;
    ULONG64	ul64addrFlink;
    ULONG	ulOffsetBucketFlink;
    ULONG       ulCount = 0;


    ul64addrBucketArray = GetPointerValue ("RsFilter!RspCacheBuckets");

    ul64addrChainQHead = ul64addrBucketArray + BucketNumber * GetTypeSize ("RP_CACHE_BUCKET");


    xdprintf (Depth, "HASH BUCKET %x @ 0x%I64x\n", BucketNumber, ul64addrChainQHead);

    ul64addrFlink = GetFieldValueUlong64 (ul64addrChainQHead, "RP_CACHE_BUCKET", "FileBufHead.Flink");

    GetFieldOffset ("RP_FILE_BUF", "BucketLinks.Flink", &ulOffsetBucketFlink);


    while (ul64addrFlink != ul64addrChainQHead)
	{
        if (CheckControlC())
	    {
            return;
	    } 



	ul64addrFileBuffer = ul64addrFlink - ulOffsetBucketFlink;

        DumpRpFileBuf (ul64addrFileBuffer, Flags, Depth + 1);         

        dprintf("\n");

	GetFieldValue (ul64addrFileBuffer, "RP_FILE_BUF", "BucketLinks.Flink", ul64addrFlink);

        ulCount++;
	}


    xdprintf (Depth, "%d entries\n", ulCount);
    }
  

VOID
DumpRpLru (IN ULONG Flags,
	   IN ULONG Depth)
    {
    ULONG64	ul64addrCacheLru;
    ULONG64	ul64addrFileBuffer;
    ULONG64	ul64addrQHead;
    ULONG64	ul64addrFlink;
    ULONG	ulOffsetFileBufferFlink;
    ULONG	ulOffsetLruLinksFlink;
    ULONG	ulCount = 0;

    ul64addrCacheLru = GetExpression ("RsFilter!RspCacheLru");

    if (0 == ul64addrCacheLru) 
	{
	return;
	}


    xdprintf (Depth, 
	      "Cache LRU contents (head @ 0x%I64x) TotalCount %d LruCount %d\n",
	      ul64addrCacheLru,
	      GetFieldValueUlong32 (ul64addrCacheLru, "RP_CACHE_LRU", "TotalCount"),
	      GetFieldValueUlong32 (ul64addrCacheLru, "RP_CACHE_LRU", "LruCount"));

    GetFieldOffset ("RP_CACHE_LRU", "FileBufHead.Flink", &ulOffsetFileBufferFlink);
    GetFieldOffset ("RP_FILE_BUF",  "LruLinks.Flink",    &ulOffsetLruLinksFlink);

    ul64addrQHead = ul64addrCacheLru + ulOffsetFileBufferFlink;
    ul64addrFlink = GetFieldValueUlong64 (ul64addrCacheLru, "RP_CACHE_LRU", "FileBufHead.Flink");


    while (ul64addrFlink != ul64addrQHead)
	{
        if (CheckControlC())
	    {
            return;
	    }

	
	ul64addrFileBuffer = ul64addrFlink - ulOffsetLruLinksFlink;

        DumpRpFileBuf (ul64addrFileBuffer, Flags, Depth + 1);

        dprintf ("\n");

	GetFieldValue (ul64addrFileBuffer, "RP_FILE_BUF", "LruLinks.Flink", ul64addrFlink);

        ulCount++;
	}                                   

    xdprintf (Depth, "%d entries\n", ulCount);
    }
  

DECLARE_API (rpmsg)
/*++

Routine Description

    Dumps a specfied RP_MSG

Arguments
    
    Pointer to the msg

Return Value

    none
--*/
    {
    ULONG64	ul64addrMessage;
    ULONG	flags = 0;


    GetExpressionEx (args, &ul64addrMessage, &args);

    sscanf(args, "%lx", &flags);

    if (ul64addrMessage != 0)
	{
        DumpRpMsg (ul64addrMessage, flags, 0);
	}
    }


VOID
DumpRpMsg (IN ULONG64 ul64addrMessage,
	   IN ULONG   Flags,
	   IN ULONG   Depth)
    {
    ULONG	ulCommand = GetFieldValueUlong32 (ul64addrMessage, "RP_MSG", "inout.command");


    xdprintf (Depth, "RP_MSG ENTRY @ 0x%I64x\n", ul64addrMessage);

    xdprintf (Depth,
	      "Command: %s  Status: 0x%x\n", 
	      RpCommands[ulCommand].Name,
	      GetFieldValueUlong32 (ul64addrMessage, "RP_MSG", "inout.status"));

    switch(ulCommand) 
	{
        case RP_PARTIAL_DATA:
            xdprintf (Depth, "FilterId     0x%I64x\n", GetFieldValueUlong64 (ul64addrMessage, "RP_MSG", "msg.pRep.filterId"));
            xdprintf (Depth, "BytesRead    0x%x\n",    GetFieldValueUlong32 (ul64addrMessage, "RP_MSG", "msg.pRep.bytesRead"));
            xdprintf (Depth, "ByteOffset   0x%I64x\n", GetFieldValueUlong64 (ul64addrMessage, "RP_MSG", "msg.pRep.byteOffset"));
            xdprintf (Depth, "OffsetToData 0x%x\n",    GetFieldValueUlong32 (ul64addrMessage, "RP_MSG", "msg.pRep.offsetToData"));
            break;
	}           
    }


VOID
DumpFlags(
    ULONG Depth,
    LPSTR FlagDescription,
    ULONG Flags,
    PFLAG_NAME FlagTable
    )
{
    ULONG i;
    ULONG mask = 0;
    ULONG count = 0;

    UCHAR prolog[64];

    sprintf(prolog, "%s (0x%08x)  ", FlagDescription, Flags);

    xdprintf(Depth, "%s", prolog);

    if (Flags == 0) {
        dprintf("\n");
        return;
    }

    memset(prolog, ' ', strlen(prolog));

    for (i = 0; FlagTable[i].Name != 0; i++) {

        PFLAG_NAME flag = &(FlagTable[i]);

        mask |= flag->Flag;

        if ((Flags & flag->Flag) == flag->Flag) {

            //
            // print trailing comma
            //

            if (count != 0) {

                dprintf(", ");

                //
                // Only print two flags per line.
                //

                if ((count % 2) == 0) {
                    dprintf("\n");
                    xdprintf(Depth, "%s", prolog);
                }
            }

            dprintf("%s", flag->Name);

            count++;
        }
    }

    dprintf("\n");

    if ((Flags & (~mask)) != 0) {
        xdprintf(Depth, "%sUnknown flags %#010lx\n", prolog, (Flags & (~mask)));
    }

    return;
}




/*
**++
**
**  Routine Description:
**
**	Dump a reparse data block
**
**
**  Arguments:
**
**	args - the location of the entry to dump
**
**
**  Return Value:
**
**	none
**--
*/

DECLARE_API (rpdata) 
    {
    ULONG64	ul64addrReparsePointData = 0;
    ULONG	fFlags                   = 0;
    const ULONG	fLegalFlags              = RPDBG_VERBOSE;


    if (GetExpressionEx (args, &ul64addrReparsePointData, &args))
	{
	sscanf (args, "%x", &fFlags);

	if ((0 != fFlags) && ((fFlags & fLegalFlags) == 0))
	    {
	    dprintf("Illegal flags specified\n");
	    return;
	    }
	}

    if (0 != ul64addrReparsePointData)
	{
	DumpRpData (ul64addrReparsePointData, fFlags);
	}

    return;
    }


VOID
DumpRpData (IN ULONG64 ul64addrReparsePointData,
	    IN ULONG   fFlags)
    {
    ULONG64	ul64addrPrivateData = 0;
    ULONG	ulOffsetPrivateData = 0;
    ULONG64	ul64Time;
    CHAR	achFormattedString [200];
    GUID	guidValue;
    




    GetFieldOffset ("RP_DATA", "data", &ulOffsetPrivateData);

    ul64addrPrivateData = ul64addrReparsePointData + ulOffsetPrivateData;


    GetFieldData (ul64addrReparsePointData, "RP_DATA", "vendorId", sizeof (guidValue), &guidValue);
    FormatGUID (guidValue, achFormattedString, sizeof (achFormattedString));

    dprintf ("Vendor ID            %s\n", achFormattedString);


    dprintf ("Qualifier            0x%x\n", GetFieldValueUlong32 (ul64addrReparsePointData, "RP_DATA", "qualifier"));
    dprintf ("Version              0x%x\n", GetFieldValueUlong32 (ul64addrReparsePointData, "RP_DATA", "version"));

    DumpFlags (0, "Global Bit Flags    ",   GetFieldValueUlong32 (ul64addrReparsePointData, "RP_DATA", "globalBitFlags"), RpReparsePointFlags);

    dprintf ("Size of Private Data 0x%x\n", GetFieldValueUlong32 (ul64addrReparsePointData, "RP_DATA", "numPrivateData"));


    GetFieldData (ul64addrReparsePointData, "RP_DATA", "fileIdentifier", sizeof (guidValue), &guidValue);
    FormatGUID (guidValue, achFormattedString, sizeof (achFormattedString));

    dprintf ("File Identifier      %s\n", achFormattedString);


    dprintf ("Private Data @       0x%I64x\n", ul64addrPrivateData);

    if (0 != (fFlags & RPDBG_VERBOSE))
	{
	/*	reserved[RP_RESV_SIZE];        // Must be 0 */

	DumpFlags (1, "Bit Flags           ", GetFieldValueUlong32 (ul64addrPrivateData, "RP_PRIVATE_DATA", "bitFlags"), RpReparsePointFlags);


	dprintf ("\n");

	GetFieldData (ul64addrPrivateData, "RP_PRIVATE_DATA", "hsmId", sizeof (guidValue), &guidValue);
	FormatGUID (guidValue, achFormattedString, sizeof (achFormattedString));

	dprintf ("  Hsm Id               %s\n", achFormattedString);


	GetFieldData (ul64addrPrivateData, "RP_PRIVATE_DATA", "bagId", sizeof (guidValue), &guidValue);
	FormatGUID (guidValue, achFormattedString, sizeof (achFormattedString));

	dprintf ("  Bag Id               %s\n", achFormattedString);


	dprintf ("\n");

	ul64Time = GetFieldValueUlong64 (ul64addrPrivateData, "RP_PRIVATE_DATA", "fileVersionId");
	FormatDateAndTime (ul64Time, achFormattedString, sizeof (achFormattedString));

	dprintf ("  File Version Id      0x%016I64x (%s)\n", ul64Time, achFormattedString);


	ul64Time = GetFieldValueUlong64 (ul64addrPrivateData, "RP_PRIVATE_DATA", "timegrationTime");
	FormatDateAndTime (ul64Time, achFormattedString, sizeof (achFormattedString));

	dprintf ("  Migration Time       0x%016I64x (%s)\n", ul64Time, achFormattedString);


	ul64Time = GetFieldValueUlong64 (ul64addrPrivateData, "RP_PRIVATE_DATA", "recallTime");
	FormatDateAndTime (ul64Time, achFormattedString, sizeof (achFormattedString));

	dprintf ("  Recall Time          0x%016I64x (%s)\n", ul64Time, achFormattedString);


	dprintf ("  File Start           0x%I64x\n", GetFieldValueUlong64 (ul64addrPrivateData, "RP_PRIVATE_DATA", "fileStart"));
	dprintf ("  File Size            0x%I64x\n", GetFieldValueUlong64 (ul64addrPrivateData, "RP_PRIVATE_DATA", "fileSize"));
	dprintf ("  Data Start           0x%I64x\n", GetFieldValueUlong64 (ul64addrPrivateData, "RP_PRIVATE_DATA", "dataStart"));
	dprintf ("  Data Size            0x%I64x\n", GetFieldValueUlong64 (ul64addrPrivateData, "RP_PRIVATE_DATA", "dataSize"));
	dprintf ("  Verification Data    0x%I64x\n", GetFieldValueUlong64 (ul64addrPrivateData, "RP_PRIVATE_DATA", "verificationData"));
	dprintf ("  Verification Type    0x%x\n",    GetFieldValueUlong32 (ul64addrPrivateData, "RP_PRIVATE_DATA", "verificationType"));
	dprintf ("  Recall Count         0x%x\n",    GetFieldValueUlong32 (ul64addrPrivateData, "RP_PRIVATE_DATA", "recallCount"));
	dprintf ("  Data Stream Start    0x%I64x\n", GetFieldValueUlong64 (ul64addrPrivateData, "RP_PRIVATE_DATA", "dataStreamStart"));
	dprintf ("  Data Stream Size     0x%I64x\n", GetFieldValueUlong64 (ul64addrPrivateData, "RP_PRIVATE_DATA", "dataStreamSize"));
	dprintf ("  Data Stream          0x%x\n",    GetFieldValueUlong32 (ul64addrPrivateData, "RP_PRIVATE_DATA", "dataStream"));
	dprintf ("  Data Stream CRC Type 0x%x\n",    GetFieldValueUlong32 (ul64addrPrivateData, "RP_PRIVATE_DATA", "dataStreamCRCType"));
	dprintf ("  Data Stream CRC      0x%I64x\n", GetFieldValueUlong64 (ul64addrPrivateData, "RP_PRIVATE_DATA", "dataStreamCRC"));
	}


    return ;
    }



/*
**++
**
**  Routine Description:
**
**	Dumps some summary information from the filter
**
**
**  Arguments:
**
**	args - the location of the entry to dump
**
**
**  Return Value:
**
**	none
**--
*/

DECLARE_API (rpsummary) 
    {
    dprintf ("ExtendedDebug:              %u\n", GetUlongValue ("RsFilter!ExtendedDebug"));
    dprintf ("RsAllowRecalls:             %u\n", GetUlongValue ("RsFilter!RsAllowRecalls"));
    dprintf ("RsNoRecallDefault:          %u\n", GetUlongValue ("RsFilter!RsNoRecallDefault"));
    dprintf ("RsSkipFilesForLegacyBackup: %u\n", GetUlongValue ("RsFilter!RsSkipFilesForLegacyBackup"));
    dprintf ("RsUseUncachedNoRecall:      %u\n", GetUlongValue ("RsFilter!RsUseUncachedNoRecall"));

    dprintf ("RsFileContextId:            %u\n", GetUlongValue ("RsFilter!RsFileContextId"));
    dprintf ("RsFileObjId:                %u\n", GetUlongValue ("RsFilter!RsFileObjId"));
    dprintf ("RsNoRecallReadId:           %u\n", GetUlongValue ("RsFilter!RsNoRecallReadId"));
    dprintf ("RsFsaRequestCount:          %u\n", GetUlongValue ("RsFilter!RsFsaRequestCount"));

    dprintf ("\n");

    dprintf ("RspCacheBlockSize:          %u\n", GetUlongValue ("RsFilter!RspCacheBlockSize"));
    dprintf ("RspCacheMaxBuffers:         %u\n", GetUlongValue ("RsFilter!RspCacheMaxBuffers"));
    dprintf ("RspCacheMaxBuckets:         %u\n", GetUlongValue ("RsFilter!RspCacheMaxBuckets"));
    dprintf ("RspCachePreAllocate:        %u\n", GetUlongValue ("RsFilter!RspCachePreAllocate"));
    dprintf ("RspCacheInitialized:        %u\n", GetUlongValue ("RsFilter!RspCacheInitialized"));

    dprintf ("\n");

    dprintf ("RspCacheBuckets           @ 0x%I64x\n", GetPointerValue ("RsFilter!RspCacheBuckets"));
    dprintf ("RspCacheLru               @ 0x%I64x\n", GetExpression   ("RsFilter!RspCacheLru"));
    dprintf ("RsValidateQHead           @ 0x%I64x\n", GetExpression   ("RsFilter!RsValidateQHead"));
    dprintf ("RsFileContextQHead        @ 0x%I64x\n", GetExpression   ("RsFilter!RsFileContextQHead"));
    dprintf ("RsIoQHead                 @ 0x%I64x\n", GetExpression   ("RsFilter!RsIoQHead"));

    return ;
    }



/*
**++
**
**  Routine Description:
**
**	Walk a queue and count the number of entries
**
**
**  Arguments:
**
**	args - the location of the queue to walk
**
**
**  Return Value:
**
**	none
**--
*/

DECLARE_API (rpvalque) 
    {
    LIST_ENTRY64	le64ListEntry;
    ULONG64		ul64addrBaseQHead;
    ULONG64		ul64addrItemQHead;
    ULONG		ulEntryCount = 0;
    ULONG		fFlags       = 0;
    ULONG		fLegalFlags  = RPDBG_VERBOSE;
    DWORD		dwStatus     = 0;


    if (GetExpressionEx (args, &ul64addrBaseQHead, &args))
	{
	sscanf (args, "%lx", &fFlags);

	if ((0 != fFlags) && ((fFlags & fLegalFlags) == 0))
	    {
	    dprintf("Illegal flags specified\n");
	    return;
	    }
	}
    else
	{
	dprintf ("Trouble parsing the command line for rpvalque\n");

	return;
	}


    dwStatus = ReadListEntry (ul64addrBaseQHead, &le64ListEntry);

    ul64addrItemQHead = le64ListEntry.Flink;


    while ((dwStatus) && (!CheckControlC ()) && (ul64addrItemQHead != ul64addrBaseQHead))
	{
	dwStatus = ReadListEntry (ul64addrItemQHead, &le64ListEntry);

	if (fFlags & RPDBG_VERBOSE)
	    {
	    dprintf ("  Entry %4u: QHead 0x%016I64x, Flink 0x%016I64x, Blink 0x%016I64x\n", 
		     ulEntryCount, 
		     ul64addrItemQHead,
		     le64ListEntry.Flink, 
		     le64ListEntry.Blink);
	    }

	ulEntryCount++;

	ul64addrItemQHead = le64ListEntry.Flink;
	}


    dprintf ("  Total entries: %u\n", ulEntryCount);
	

    return ;
    }


/*
**++
**
**  Routine Description:
**
**	Walks the RpIoQueue and dumps some interesting fields
**
**
**  Arguments:
**
**	args - flags
**
**
**  Return Value:
**
**	none
**--
*/

DECLARE_API (rpioq) 
    {
    LIST_ENTRY64	le64ListEntry;
    ULONG64		ul64addrRsIoQHead;
    ULONG64		ul64addrItemQHead;
    ULONG64		ul64addrIrp;
    ULONG		ulOffsetIrpListEntryFlink;
    ULONG		ulEntryCount = 0;
    ULONG		fFlags       = 0;
    ULONG		fLegalFlags  = 0x0;
    DWORD		dwStatus     = 0;


    ul64addrRsIoQHead = GetExpression ("RsFilter!RsIoQHead");
    
    if (0 != ul64addrRsIoQHead)
	{
	sscanf (args, "%lx", &fFlags);

	if ((0 != fFlags) && ((fFlags & fLegalFlags) == 0))
	    {
	    dprintf("Illegal flags specified\n");
	    return;
	    }
	}
    else
	{
	dprintf ("Error retrieving address of RsIoQHead\n");

	return;
	}


    GetFieldOffset ("IRP", "Tail.Overlay.ListEntry.Flink", &ulOffsetIrpListEntryFlink);



    dwStatus = ReadListEntry (ul64addrRsIoQHead, &le64ListEntry);

    ul64addrItemQHead = le64ListEntry.Flink;
    

    while ((dwStatus) && (!CheckControlC ()) && (ul64addrItemQHead != ul64addrRsIoQHead))
	{
	dwStatus = ReadListEntry (ul64addrItemQHead, &le64ListEntry);

	ul64addrIrp = ul64addrItemQHead - ulOffsetIrpListEntryFlink;

	dprintf ("  Entry %4u: QHead 0x%016I64x, Flink 0x%016I64x, Blink 0x%016I64x, Irp 0x%016I64x\n", 
		 ulEntryCount,
		 ul64addrItemQHead,
		 le64ListEntry.Flink, 
		 le64ListEntry.Blink, 
		 ul64addrIrp);


	if (fFlags & RPDBG_VERBOSE)
	    {
	    /*
	    ** Can choose to dump some Irp fields here based off ul64addrIrp if we choose.
	    */
//	    dprintf ("  Entry %4u: Flink 0x%016I64x, Blink 0x%016I64x\n", ulEntryCount, le64ListEntry.Flink, le64ListEntry.Blink);
	    }

	ulEntryCount++;


	ul64addrItemQHead = le64ListEntry.Flink;
	}


    dprintf ("  Total entries: %u\n", ulEntryCount);
	

    return ;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\launch\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\kdexts\makefile.inc ===
$(O)\hsmkd.def: hsmkd.src
    $(TARGET_CPP) /EP $(TARGET_DEFINES) $(TARGET_DBG_DEFINES) $(C_DEFINES) hsmkd.src > $(O)\hsmkd.def
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\kdexts\local.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

   local.h

Abstract:

   local header to be included by all source files
   pertaining to the kdext dll

Author:

   Ravisankar Pudipeddi 

Environment:

    User Mode.

Revision History:

--*/



//
// Util functions
//
VOID
xdprintf(
    ULONG  Depth,
    PCCHAR S,
    ...
    );

BOOLEAN
xReadMemory (
            ULONG64 Src,
            PVOID   Dst,
            ULONG   Len
            );

ULONG64 GetPointerValue       (PCHAR   String);
ULONG64 GetPointerFromAddress (ULONG64 Location);
ULONG   GetUlongValue         (PCHAR   String);
ULONG   GetUlongFromAddress   (ULONG64 Location);

ULONG   GetFieldValueUlong32 (ULONG64 ul64addrStructureBase, PCHAR pchStructureType, PCHAR pchFieldname);
ULONG64 GetFieldValueUlong64 (ULONG64 ul64addrStructureBase, PCHAR pchStructureType, PCHAR pchFieldname);

ULONG FormatDateAndTime  (ULONG64 ul64Time,  PCHAR pszFormattedDateAndTime, ULONG ulBufferLength);
ULONG FormatGUID         (GUID    guidValue, PCHAR pszFormattedGUID,        ULONG ulBufferLength);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\launch\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by VERSION.RC
//
#define IDS_APPLICATION_TITLE           1
#define IDS_INVALID_PARAMETER           100

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\kdexts\pch.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       PCH.cxx
//
//  Contents:   Pre-compiled header
//
//  History:    21-Dec-92       BartoszM        Created
//
//--------------------------------------------------------------------------

#define KDEXTMODE

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntos.h>
#include <fsrtl.h>
#include <zwapi.h>

#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#include <windef.h>
#include <windows.h>
#include <imagehlp.h>

#include <memory.h>

// grab the scsi related headers too
#include <scsi.h>
#include <srb.h>


// Stolen from ntrtl.h to override RECOMASSERT
#undef ASSERT
#undef ASSERTMSG

#if DBG
#define ASSERT( exp ) \
    if (!(exp)) \
        RtlAssert( #exp, __FILE__, __LINE__, NULL )

#define ASSERTMSG( msg, exp ) \
    if (!(exp)) \
        RtlAssert( #exp, __FILE__, __LINE__, msg )

#else
#define ASSERT( exp )
#define ASSERTMSG( msg, exp )
#endif // DBG


//
// We're 64 bit aware

#define KDEXT_64BIT

#include <wdbgexts.h>

#define OFFSET(struct, elem)    ((char *) &(struct->elem) - (char *) struct)

#define _DRIVER

#define KDBG_EXT

#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\kdexts\utils.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

   utils.c   

Abstract:

    Various utility routines used by the extensions.

Author:

    Ravisankar Pudipeddi 

Environment:

    User Mode.

Revision History:

--*/

#include "pch.h"
#include "local.h"


VOID
xdprintf(
    ULONG  Depth,
    PCCHAR S,
    ...
    )
{
    va_list ap;
    ULONG i;
    CCHAR DebugBuffer[256];

    for (i=0; i<Depth; i++) {
        dprintf ("  ");
    }

    va_start(ap, S);

    vsprintf(DebugBuffer, S, ap);

    dprintf (DebugBuffer);

    va_end(ap);
}


BOOLEAN
xReadMemory (
            ULONG64 Src,
            PVOID   Dst,
            ULONG   Len
            )
{
   ULONG result;

   return (ReadMemory (Src, Dst, Len, &result) && (result == Len));
}



ULONG GetUlongFromAddress (ULONG64 Location)
    {
    ULONG Value = 0;
    ULONG result;

    if ((!ReadMemory (Location, &Value, sizeof (ULONG), &result)) || (result < sizeof (ULONG))) 
	{
        dprintf ("unable to read from %08x\n", Location);
	}

    return (Value);
    }


ULONG64 GetPointerFromAddress (ULONG64 Location)
    {
    ULONG64 Value = 0;
    ULONG   result;

    if (ReadPointer (Location, &Value))
	{
        dprintf ("unable to read from %016p\n", Location);
	}

    return (Value);
    }


ULONG GetUlongValue (PCHAR String)
    {
    ULONG64 Location;
    ULONG   Value = 0;
    ULONG   result;


    Location = GetExpression (String);

    if (!Location) 
	{
        dprintf ("unable to get %s\n", String);
	}

    return GetUlongFromAddress( Location );
    }


ULONG64 GetPointerValue (PCHAR String)
    {
    ULONG64 Location;
    ULONG64 Value = 0;


    Location = GetExpression (String);

    if (!Location) 
	{
        dprintf ("unable to get %s\n", String);
	}


    ReadPointer (Location, &Value);

    return (Value);
    }




ULONG GetFieldValueUlong32 (ULONG64 ul64addrStructureBase,
			    PCHAR   pchStructureType,
			    PCHAR   pchFieldname)
    {
    ULONG	ulReturnValue = 0;


    GetFieldValue (ul64addrStructureBase, pchStructureType, pchFieldname, ulReturnValue);

    return (ulReturnValue);
    }


ULONG64 GetFieldValueUlong64 (ULONG64 ul64addrStructureBase,
			      PCHAR   pchStructureType,
			      PCHAR   pchFieldname)
    {
    ULONG64	ul64ReturnValue = 0;


    GetFieldValue (ul64addrStructureBase, pchStructureType, pchFieldname, ul64ReturnValue);

    return (ul64ReturnValue);
    }



ULONG FormatDateAndTime (ULONG64 ul64Time, PCHAR pszFormattedDateAndTime, ULONG ulBufferLength)
    {
    FILETIME		ftTimeOriginal;
    FILETIME		ftTimeLocal;
    SYSTEMTIME		stTimeSystem;
    CHAR		achFormattedDateString [200];
    CHAR		achFormattedTimeString [200];
    DWORD		dwStatus   = 0;
    BOOL		bSucceeded = FALSE;
    ULARGE_INTEGER	uliConversionTemp;
    int			iReturnValue;


    uliConversionTemp.QuadPart = ul64Time;

    ftTimeOriginal.dwLowDateTime  = uliConversionTemp.LowPart;
    ftTimeOriginal.dwHighDateTime = uliConversionTemp.HighPart;


    if (0 == dwStatus)
	{
	bSucceeded = FileTimeToLocalFileTime (&ftTimeOriginal, &ftTimeLocal);

	if (!bSucceeded)
	    {
	    dwStatus = GetLastError ();
	    }
	}



    if (0 == dwStatus)
	{
	bSucceeded = FileTimeToSystemTime (&ftTimeLocal, &stTimeSystem);

	if (!bSucceeded)
	    {
	    dwStatus = GetLastError ();
	    }
	}



    if (0 == dwStatus)
	{
	iReturnValue = GetDateFormat (LOCALE_USER_DEFAULT, 
				      0, 
				      &stTimeSystem, 
				      NULL, 
				      achFormattedDateString, 
				      sizeof (achFormattedDateString) / sizeof (CHAR));

	if (0 == iReturnValue)
	    {
	    dwStatus = GetLastError ();
	    }
	}



    if (0 == dwStatus)
	{
	iReturnValue = GetTimeFormat (LOCALE_USER_DEFAULT, 
				      0, 
				      &stTimeSystem, 
				      NULL, 
				      achFormattedTimeString, 
				      sizeof (achFormattedTimeString) / sizeof (CHAR));

	if (0 == iReturnValue)
	    {
	    dwStatus = GetLastError ();
	    }
	}



    if (0 == dwStatus)
	{
	iReturnValue = _snprintf (pszFormattedDateAndTime, 
				  ulBufferLength / sizeof (CHAR), 
				  "%s %s",
				  achFormattedDateString,
				  achFormattedTimeString);

	if (iReturnValue < 0)
	    {
	    dwStatus = ERROR_INSUFFICIENT_BUFFER;
	    }
	else
	    {
	    dwStatus = 0;
	    }
	}



    if (0 != dwStatus)
	{
	if (0 == ul64Time)
	    {
	    _snprintf (pszFormattedDateAndTime, 
		       ulBufferLength / sizeof (CHAR), 
		       "Date/Time not specified");
	    }
	else
	    {
	    _snprintf (pszFormattedDateAndTime, 
		       ulBufferLength / sizeof (CHAR), 
		       "Date/Time invalid");
	    }
	}



    return (dwStatus);
    }




/*
** {XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX} 
*/
ULONG FormatGUID (GUID guidValue, PCHAR pszFormattedGUID, ULONG ulBufferLength)
    {
    DWORD	dwStatus = 0;


    if (sizeof ("{XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX}") > ulBufferLength)
	{
	dwStatus = ERROR_INSUFFICIENT_BUFFER;
	}


    if (0 == dwStatus)
	{
	_snprintf (pszFormattedGUID, ulBufferLength, "{%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}",
		   guidValue.Data1,
		   guidValue.Data2,
		   guidValue.Data3,
		   guidValue.Data4[0],
		   guidValue.Data4[1],
		   guidValue.Data4[2],
		   guidValue.Data4[3],
		   guidValue.Data4[4],
		   guidValue.Data4[5],
		   guidValue.Data4[6],
		   guidValue.Data4[7]);
	}


    return (dwStatus);
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\launch\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently
#ifndef _STDAFX_H
#define _STDAFX_H

#include "wsb.h"
#include "resource.h"

#endif // _STDAFX_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\mover\server\dlldatax.c ===
// wrapper for dlldata.c

#ifdef _MERGE_PROXYSTUB // merge proxy stub DLL

#define REGISTER_PROXY_DLL //DllRegisterServer, etc.

#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0500 //for WinNT 4.0 or Win95 with DCOM
#endif 

#define USE_STUBLESS_PROXY  //defined only with MIDL switch /Oicf

#pragma comment(lib, "rpcndr.lib")
#pragma comment(lib, "rpcns4.lib")
#pragma comment(lib, "rpcrt4.lib")

#define DllMain             PrxDllMain
#define DllRegisterServer   PrxDllRegisterServer
#define DllUnregisterServer PrxDllUnregisterServer
#define DllGetClassObject   PrxDllGetClassObject
#define DllCanUnloadNow     PrxDllCanUnloadNow

#include "dlldata.c"
#include "MvrInt_p.c"

#ifdef _NOPROXY //no midl generated dlldata.c

#define STRICT 1
#include <ole2.h>

BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{return TRUE;}

STDAPI PrxDllCanUnloadNow(void){return S_OK;}

STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{return CLASS_E_CLASSNOTAVAILABLE;}

STDAPI PrxDllRegisterServer(void){return S_OK;}

STDAPI PrxDllUnregisterServer(void){return S_OK;}

#endif //!PROXY_DELEGATION


#endif //_MERGE_PROXYSTUB
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\mover\server\dlldatax.h ===
#if !defined(AFX_DLLDATAX_H__96C4A0BC_A9FD_11D0_8D49_00A0C9190459__INCLUDED_)
#define AFX_DLLDATAX_H__96C4A0BC_A9FD_11D0_8D49_00A0C9190459__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifdef _MERGE_PROXYSTUB

extern "C" 
{
BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, 
    LPVOID lpReserved);
STDAPI PrxDllCanUnloadNow(void);
STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);
STDAPI PrxDllRegisterServer(void);
STDAPI PrxDllUnregisterServer(void);
}

#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLLDATAX_H__96C4A0BC_A9FD_11D0_8D49_00A0C9190459__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\launch\rslaunch.cpp ===
/*++

Copyright (c) 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    rslaunch.cpp

Abstract:

    HSM Remote Storage Job Launch Program.

    This program is used by the HSM Remote Storage system to submit 
    user-requested jobs to the NT Task Scheduler.  This standalone command 
    line program has two primary functions:  to start the HSM job specified 
    and not return until the job has completed; and to call into the HSM 
    Engine to either update secondary storage copy set media, or to 
    re-create a master secondary storage media from its most recent copy.  
    
    NOTE: This program is linked as a windows program, but has no visible
    window.  It  creates an invisible window so it can get the WM_CLOSE
    message from the Task Scheduler if the user wants to cancel the job.
    
    ALSO NOTE: This program has no correspoinding header file.

--*/

#include "stdafx.h"
#include "windows.h"
#include "stdio.h"

#include "wsb.h"
#include "hsmeng.h"
#include "fsa.h"
#include "job.h"
#include "rms.h"
#include "hsmconn.h"

HINSTANCE g_hInstance;

//#define RSL_TRACE
#if defined(RSL_TRACE)
#define LTRACE(x)        WsbTracef x
#else
#define LTRACE(x)
#endif

#define TRACE_FILE    L"RsLaunch.trc"
#define WINDOW_CLASS  L"RsLaunchWin"

//  Typedefs
typedef enum {  // Type of work requested
    WORK_NONE,
    WORK_RUN,
    WORK_RECREATE,
    WORK_SYNCH
} WORK_TYPE;

typedef struct {  // For passing data to/from DoWork
    WCHAR *     pCmdLine;
    WORK_TYPE   wtype;
    HRESULT     hr;
    IHsmJob *   pJob;
} DO_WORK_DATA;

//  Global data
CComModule      _Module;

//  Local data

//  Local functions
static HRESULT CancelWork(DO_WORK_DATA* pWork);
static HRESULT ConnectToServer(IHsmServer** ppServer);
static BOOL    CreateOurWindow(HINSTANCE hInstance);
static DWORD   DoWork(void* pVoid);
static HRESULT RecreateMaster(GUID oldMasterMediaId, 
    OLECHAR* oldMasterMediaName, USHORT copySet);
static void    ReportError(HRESULT hr);
static HRESULT RunJob(OLECHAR* jobName, IHsmJob** ppJob);
static HRESULT SynchronizeMedia(OLECHAR* poolName, USHORT copySet);
static LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam,
            LPARAM lParam);


//******************************   Functions:


static HRESULT 
CancelWork(
    IN DO_WORK_DATA* pWork
    ) 

/*++

Routine Description:

    Try to cancel the current work.

Arguments:

    None.

Return Value:

    S_OK  - Success

--*/
{ 
    HRESULT hr = E_FAIL;

    LTRACE((L"CancelWork: entry\n"));

    try {
        CComPtr<IHsmServer> pServer;

        WsbAffirmHr(ConnectToServer(&pServer));
        
        //  Because of a possible timing problem, we may have to wait
        //  for the operation to start before we can cancel it
        for (int i = 0; i < 60; i++) {
            if (WORK_RUN == pWork->wtype) {
                LTRACE((L"CancelWork: wtype = WORK_RUN, pJob = %p\n",
                        pWork->pJob));
                if (pWork->pJob) {
                    LTRACE((L"CancelWork: cancelling job\n"));
                    hr = pWork->pJob->Cancel(HSM_JOB_PHASE_ALL);
                    break;
                }
            } else {
                LTRACE((L"CancelWork: cancelling copy media operation\n"));
                if (S_OK == pServer->CancelCopyMedia()) {
                    hr = S_OK;
                    break;
                }
            }

            Sleep(1000);
        }
    } WsbCatch(hr);


    LTRACE((L"CancelWork: exit = %ls\n", WsbHrAsString(hr)));
    return(hr);
}


static HRESULT 
ConnectToServer(
    IN OUT IHsmServer** ppServer
    ) 

/*++

Routine Description:

    Connect to the server that will do the work.

Arguments:

    ppServer - Pointer to pointer to server.

Return Value:

    S_OK  - Success

--*/
{ 
    HRESULT hr = S_OK;

    LTRACE((L"ConnectToServer: entry\n"));

    try {
        CWsbStringPtr           tmpString;

        WsbAffirm(ppServer, E_POINTER);
        WsbAffirm(!(*ppServer), E_FAIL);

        // Store of the name of the server.
        WsbAffirmHr( WsbGetComputerName( tmpString ) );

        // Find the Hsm to get it's id.
        WsbAffirmHr(HsmConnectFromName(HSMCONN_TYPE_HSM, tmpString, IID_IHsmServer, 
                (void**) ppServer));
    } WsbCatch(hr);


    LTRACE((L"ConnectToServer: exit = %ls\n", WsbHrAsString(hr)));
    return(hr);
}


static BOOL 
CreateOurWindow(
    HINSTANCE hInstance
    ) 

/*++

Routine Description:

    Create our invisible window.

    NOTE: If the Task Scheduler ever gets smarter and can send the WM_CLOSE
    message to an application without a window, the invisible window may
    not be needed.

Arguments:

    hInstance - Handle for this instance of the program.

Return Value:

    TRUE  - Everything worked.

    FALSE - Something went wrong.


            
--*/
{ 
    BOOL     bRet  = FALSE;
    WNDCLASS wc; 

    //  Register our window type 
    wc.style = 0; 
    wc.lpfnWndProc = &WindowProc; 
    wc.cbClsExtra = 0; 
    wc.cbWndExtra = 0; 
    wc.hInstance = hInstance; 
    wc.hIcon = NULL; 
    wc.hCursor = NULL; 
    wc.hbrBackground = (HBRUSH) GetStockObject(WHITE_BRUSH); 
    wc.lpszMenuName = NULL; 
    wc.lpszClassName = WINDOW_CLASS; 
    if  (RegisterClass(&wc)) {

        //  Create the window (invisible by default)
        if (CreateWindowEx(  0, 
                WINDOW_CLASS, 
                L"RsLaunch", 
                WS_OVERLAPPEDWINDOW, 
                CW_USEDEFAULT, 
                CW_USEDEFAULT, 
                CW_USEDEFAULT, 
                CW_USEDEFAULT, 
                NULL, 
                NULL, 
                hInstance, 
                NULL)) {
            bRet = TRUE;
        } else {
            LTRACE((L"CreateWindowEx failed\n"));
        }
    } else {
        LTRACE((L"RegisterClass failed\n"));
    }
    return(bRet);
}


static DWORD   
DoWork(
    IN void* pVoid
    )

/*++

Routine Description:

    Process the command line and start the processing.

Arguments:

    pVoid - A pointer (cast to void*) to a DO_WORK_DATA structure.

Return Value:

    The return value from the job
            
--*/

{
    HRESULT          hr = S_OK;
    DO_WORK_DATA *   pWork;

    LTRACE((L"DoWork: entry\n"));

    pWork = static_cast<DO_WORK_DATA*>(pVoid);

    try {
        WCHAR            delims[] = L" \r\n\t\"";
        WCHAR            delims2[] = L" \t";
        WCHAR            delims3[] = L"\"";
        WCHAR *          pToken;

        WsbAssert(pWork, E_POINTER);
        WsbAssert(pWork->pCmdLine, E_POINTER);
        LTRACE((L"DoWork: CmdLine = %ls\n", pWork->pCmdLine));

        // Validate we have a parameter
        pToken = wcstok(pWork->pCmdLine, delims);
        WsbAssert(pToken, E_INVALIDARG);

        // What type of request is it?
        if (_wcsicmp(pToken, OLESTR("run")) == 0) {
            CWsbStringPtr       jobName;

            // 'run' option passed in
            pWork->wtype = WORK_RUN;

            //  The job name can have embedded spaces so it may be in quotes.
            //  This means that using wcstok may not work correctly.
            pToken = pToken + wcslen(pToken) + 1; // Skip "run" & NULL
            pToken = pToken + wcsspn(pToken, delims2); // Skip spaces
            if (L'\"' == *pToken) {
                //  Job name is in quotes
                jobName = wcstok(pToken, delims3);
            } else {
                jobName = wcstok(pToken, delims);
            }
            WsbAssert(jobName, E_INVALIDARG);
            LTRACE((L"DoWork: calling RunJob(%ls)\n", jobName));
            WsbAffirmHr(RunJob(jobName, &(pWork->pJob)));

        } else if (_wcsicmp(pToken, OLESTR("sync")) == 0) {
            CWsbStringPtr       poolName;
            USHORT              copySet = 1;
            WCHAR *             pTemp;

            // 'sync' (update a copy set) option passed in
            pWork->wtype = WORK_SYNCH;
            pToken = wcstok(NULL, delims);
            WsbAssert(pToken, E_INVALIDARG);
            pTemp = wcstok(NULL, delims);
            if (!pTemp) {
                // will pass NULL for poolName if no pool name specified
                copySet = (USHORT) _wtoi(pToken);
            } else {
                poolName = pToken;
                copySet = (USHORT) _wtoi(pTemp);
            }

            WsbAffirmHr(SynchronizeMedia(poolName, copySet));

        } else if (_wcsicmp(pToken, OLESTR("recreate")) == 0) {
            USHORT              copySet = 0;
            CWsbStringPtr       mediaName;
            GUID                mediaId = GUID_NULL;

            // 'recreate' (re-create a master media) option passed in
            pWork->wtype = WORK_RECREATE;
            pToken = wcstok(NULL, delims);
            WsbAssert(pToken, E_INVALIDARG);
            if ( _wcsicmp(pToken, OLESTR("-i")) == 0 ) {

                // media id was passed in, convert from string to GUID
                pToken = wcstok(NULL, delims);
                WsbAssert(pToken, E_INVALIDARG);
                WsbAffirmHr(WsbGuidFromString( pToken, &mediaId ));
            } else if ( _wcsicmp(pToken, OLESTR("-n")) == 0 ) {

                // Media description (name) was passed in.
                // The function RecreateMaster() will look up its id (GUID).
                pToken = wcstok(NULL, delims);
                WsbAssert(pToken, E_INVALIDARG);
                mediaName = pToken;
            }

            // Get copySet number
            pToken = wcstok(NULL, delims);
            if (pToken && _wcsicmp(pToken, OLESTR("-c")) == 0) {
                pToken = wcstok(NULL, delims);
                WsbAssert(pToken, E_INVALIDARG);
                copySet = (USHORT) _wtoi(pToken);
            }

            WsbAffirmHr( RecreateMaster( mediaId, mediaName, copySet ));

        } else {
            WsbThrow(E_INVALIDARG);
        }
    } WsbCatch(hr);

    if (pWork) {
        pWork->hr = hr;
    }

    LTRACE((L"DoWork: exit = %ls\n", WsbHrAsString(hr)));
    return(static_cast<DWORD>(hr));
}


static HRESULT 
RecreateMaster(
    IN GUID     oldMasterMediaId, 
    IN OLECHAR* oldMasterMediaName,
    IN USHORT   copySet
    )

/*++

Routine Description:

    This routine implements the method that will cause a Remote Storage master media
    to be re-created by calling the appropraite method on the Remote Storage engine.  
    The master will be re-created from the specified copy or its most recent copy.

Arguments:

    oldMasterMediaId - The GUID of the current master media which is to be re-created.
                    Normally passed, but an option exists where if the master's
                    description is passed, the id (GUID) will be looked up by this
                    method prior to invoking the engine.  See below.

    oldMasterMediaName - A wide character string representing the master media's 
                    description (display name).  If this argument is passed with a valid 
                    string, the string is used to look up the oldMasterMediaId above.

    copySet  - The copyset number of the copy to use for the recreation or zero, which
                    indicates that the Engine should just use the most recent copy

Return Value:

    S_OK - The call succeeded (the specified master was re-created).

    E_FAIL - Could not get host computer's name (highly unexpected error).

    E_UNEXPECTED - The argument 'oldMasterMediaId' equaled GUID_NULL just prior to
            calling the HSM Engine to re-create a media master.  This argument should
            either be received with a valid value (the norm), or it should be set by this
            method if a valid media description was passed in as 'oldMasterMediaName'. 

    Any other value - The call failed because one of the Remote Storage API calls 
            contained internally in this method failed.  The error value returned is
            specific to the API call which failed.
            
--*/

{
    HRESULT                     hr = S_OK;

    try {
        CComPtr<IHsmServer> pServer;

        WsbAffirmHr(ConnectToServer(&pServer));

        // If we were passed a media name, find its id.  Since the name option is
        // presently only used internally and it bypasses the UI, also mark
        // the media record for re-creation (normally done by the UI) otherwise
        // the RecreateMaster() call below will fail.

        // If the string is not null...
        if ( oldMasterMediaName != 0 ) {
            // and if the 1st character of the string is not the null terminator
            if ( *oldMasterMediaName != 0 ) {
                WsbAffirmHr(pServer->FindMediaIdByDescription(oldMasterMediaName, 
                                                                &oldMasterMediaId));
                WsbAffirmHr(pServer->MarkMediaForRecreation(oldMasterMediaId));
            }
        }

        // Ensure we have a non-null media id
        WsbAffirm( oldMasterMediaId != GUID_NULL, E_UNEXPECTED );
        
        // Re-create the master media.
        WsbAffirmHr(pServer->RecreateMaster( oldMasterMediaId, copySet ));

    } WsbCatch(hr);

    return(hr);
}


static void    
ReportError(
    IN HRESULT hr
    )

/*++

Routine Description:

    Report errors.

Arguments:

    hr - The error.

Return Value:

    None.
            
--*/

{
    CWsbStringPtr   BoxTitle;
    CWsbStringPtr   BoxString;
    CWsbStringPtr   BoxString1;
    CWsbStringPtr   BoxString2;
    CWsbStringPtr   BoxString3;
    CWsbStringPtr   BoxString4;
    CWsbStringPtr   BoxString5;
    CWsbStringPtr   BoxString6;
    BOOL            displayMsg = FALSE;
    UINT            style = MB_OK;

#if DBG
    if (E_INVALIDARG == hr) {
         // If this is a Debug build then command line invocation is allowed.
        // (Debug build implies Development/Test usage.) 
        // Tell them the valid command lines.  Since this program, originally 
        // written as a console app, is now linked as a Windows program, pop
        // this up as a message box.
        
        // define the lines of text to appear in the message box
        BoxString  = L"Remote Storage Launch Program\r\n";
        BoxString1 = L"allowable command line options:\r\n\n";
        BoxString2 = L"   RSLAUNCH run <job name>\r\n";
        BoxString3 = L"   RSLAUNCH sync <copyset number>\r\n";
        BoxString4 = L"   RSLAUNCH sync <pool name> <copyset number>\r\n";
        BoxString5 = L"   RSLAUNCH recreate -i <media id> [-c <copyset number>]\r\n";
        BoxString6 = L"   RSLAUNCH recreate -n <media name> [-c <copyset number>]\r\n";

        // display the Help message box
        style =  MB_OK | MB_ICONEXCLAMATION | MB_SETFOREGROUND;
        displayMsg = TRUE;

    } else {

        // message box text lines
        BoxString  = L"An error occurred while Remote Storage Launch was launching a job.\n";
        BoxString1 = WsbHrAsString(hr);

        // display the Error message box
        style = MB_OK | MB_ICONERROR | MB_TOPMOST;
        displayMsg = TRUE;
    }

#else
    if (E_INVALIDARG == hr) {
        // error message box if the Release version:
            
        // message box text lines
        BoxString.LoadFromRsc( g_hInstance, IDS_INVALID_PARAMETER );

        // display the Error message box
        style = MB_OK | MB_ICONERROR | MB_SETFOREGROUND;
        displayMsg = TRUE;
    }
#endif // DBG

    if (displayMsg) {
        // concatenate all text lines
        BoxString.Append( BoxString1 );
        BoxString.Append( BoxString2 );
        BoxString.Append( BoxString3 );
        BoxString.Append( BoxString4 );
        BoxString.Append( BoxString5 );
        BoxString.Append( BoxString6 );
        WsbAffirm(0 != (WCHAR *)BoxString, E_OUTOFMEMORY);

        // message box title line
        WsbAffirmHr(BoxTitle.LoadFromRsc( g_hInstance, IDS_APPLICATION_TITLE ));

        // display the Help message box
        MessageBox( NULL, BoxString, BoxTitle, style);
    }

}


static HRESULT 
RunJob(
    IN  OLECHAR* jobName, 
    OUT IHsmJob** ppJob
    )

/*++

Routine Description:

    This routine implements the method for running a Remote Storage job.

Arguments:

    jobName - A wide character string containing the name of the job to run.

    ppJob   - Pointer to pointer to Job interface obtained from the server

Return Value:

    S_OK - The call succeeded (the specified job ran successfully).

    E_POINTER - Input argument 'jobName' is null.

    E_FAIL - Used to indicate 2 error conditions:
                1. could not get host computer's name (highly unexpected error);
                2. the job run by this method returned an HRESULT other than S_OK.

    Any other value - The call failed because one of the Remote Storage API calls 
            contained internally in this method failed.  The error value returned is
            specific to the API call which failed.
            
--*/

{
    HRESULT                 hr = S_OK;

    try {
        CComPtr<IHsmServer> pServer;

        WsbAssert(0 != jobName, E_POINTER);
        WsbAssert(ppJob, E_POINTER);
        WsbAffirmHr(ConnectToServer(&pServer));

        // Find the job, start the job, wait for the job to complete.
        WsbAffirmHr(pServer->FindJobByName(jobName, ppJob));
        WsbAffirmHr((*ppJob)->Start());
        WsbAffirmHr((*ppJob)->WaitUntilDone());

    } WsbCatch(hr);

    return(hr);
}



static HRESULT 
SynchronizeMedia(
    IN OLECHAR* poolName, 
    IN USHORT copySet
    )

/*++

Routine Description:

    This routine implements the method that will cause the updating (synchronizing) of 
    an entire copy set by calling the appropriate method on the Remote Storage engine.  
    Specifically, this method causes all copy media belonging to a specified copy set 
    to be checked for synchronization (being up to date) with each of their respective
    master media.  Those out of date will be brought up to date.  Running this method
    assumes that Remote Storage has already been configured for a certain number of
    copy sets.

Arguments:

    poolName - A wide character string containing the name of a specific storage pool
                that the user wants the specified copy set synchronized for.  If this 
                argument is passed as NULL then all storage pools will have the specified
                copy set synchronized.

    copySet - A number indicating which copy set is to be synchronized.

Return Value:

    S_OK - The call succeeded (the specified copy set of the specified storage pool was
                updated).

    E_FAIL - Could not get host computer's name (highly unexpected error).

    Any other value - The call failed because one of the Remote Storage API calls 
            contained internally in this method failed.  The error value returned is
            specific to the API call which failed.
            
--*/

{
    HRESULT                     hr = S_OK;
    GUID                        poolId = GUID_NULL;
    CComPtr<IHsmStoragePool>    pPool;

    try {
        CComPtr<IHsmServer> pServer;

        WsbAffirmHr(ConnectToServer(&pServer));

        // If they specified a pool, then find it's id.
        if ( poolName != 0 ) {
            if ( *poolName != 0 ) {
                CWsbStringPtr tmpString;

                WsbAffirmHr(pServer->FindStoragePoolByName(poolName, &pPool));
                WsbAffirmHr(pPool->GetMediaSet(&poolId, &tmpString));
            }
        }

        // Synchronize the media.  Note that if no pool name was passed in, we pass
        // GUID_NULL as the pool id.
        WsbAffirmHr(pServer->SynchronizeMedia(poolId, copySet));

    } WsbCatch(hr);

    return(hr);
}

//  WindowProc - Needed for our invisible window
static LRESULT CALLBACK 
WindowProc(  
    HWND   hwnd,  
    UINT   uMsg,
    WPARAM wParam,
    LPARAM lParam
  )
{
    LTRACE((L"WindowProc: msg = %4.4x\n", uMsg));
    return(DefWindowProc(hwnd, uMsg, wParam, lParam));
}


//******************************   MAIN   *********************************

extern "C"
int WINAPI wWinMain(HINSTANCE hInstance, 
    HINSTANCE /*hPrevInstance*/, 
    LPTSTR lpCmdLine, 
    int /*nShowCmd*/
    )
{
    HRESULT             hr = S_OK;
#if defined(RSL_TRACE)
    CComPtr<IWsbTrace>  pTrace;
#endif

    // Store our instance handle so it can be used by called code.
    g_hInstance = hInstance;

    try {
        HANDLE         hJobThread[1] = { NULL };
        DO_WORK_DATA   workData = { NULL, WORK_NONE, E_FAIL, NULL };

        // Register & create our invisible window
        WsbAssert(CreateOurWindow(hInstance), E_FAIL);

        // Initialize COM
        WsbAffirmHr(CoInitializeEx(NULL, COINIT_MULTITHREADED));

        // This provides a NULL DACL which will allow access to everyone.
        CSecurityDescriptor sd;
        sd.InitializeFromThreadToken();
        WsbAffirmHr(CoInitializeSecurity(sd, -1, NULL, NULL,
            RPC_C_AUTHN_LEVEL_CONNECT, RPC_C_IMP_LEVEL_IMPERSONATE, NULL, 
            EOAC_NONE, NULL));

        try {
            DWORD               ThreadId = 0;

#if defined(RSL_TRACE)
            //  Start tracing
            CoCreateInstance(CLSID_CWsbTrace, 0, CLSCTX_SERVER, IID_IWsbTrace,
                    (void **) &pTrace);
            pTrace->DirectOutput(WSB_TRACE_OUT_DEBUG_SCREEN | WSB_TRACE_OUT_FILE);
            pTrace->SetTraceFileControls(TRACE_FILE, FALSE, 3000000, NULL);
            pTrace->SetOutputFormat(TRUE, TRUE, TRUE);
            pTrace->SetTraceSettings(0xffffffffffffffffL);
            pTrace->StartTrace();
#endif

            LTRACE((L"Main: lpCmdLine = %ls\n", lpCmdLine));
            workData.pCmdLine = lpCmdLine;

            //  Create a thread to start the work and wait for it
            //  to finish
            LTRACE((L"Main: creating thread for DoWork\n"));
            hJobThread[0] = CreateThread(0, 0, DoWork, 
                    static_cast<void*>(&workData), 0, &ThreadId);
            if (!hJobThread[0]) {
                LTRACE((L"Main: CreateThread failed\n"));
                WsbThrow(HRESULT_FROM_WIN32(GetLastError()));
            }

            //  Don't exit if we're waiting for work to complete
            while (TRUE) {
                DWORD exitcode;
                DWORD waitStatus;

                //  Wait for a message or thread to end
                LTRACE((L"Main: waiting for multiple objects\n"));
                waitStatus = MsgWaitForMultipleObjects(1, hJobThread, FALSE, 
                        INFINITE, QS_ALLINPUT);

                //  Find out which event happened
                if (WAIT_OBJECT_0 == waitStatus) {

                    //  The thread ended; get it's exit code
                    LTRACE((L"Main: got event on thread\n"));
                    if (GetExitCodeThread(hJobThread[0], &exitcode)) {
                        if (STILL_ACTIVE == exitcode) {
                            //  This shouldn't happen; don't know what to do!
                        } else {
                            WsbThrow(static_cast<HRESULT>(exitcode));
                        }
                    } else {
                        WsbThrow(HRESULT_FROM_WIN32(GetLastError()));
                    }

                } else if ((WAIT_OBJECT_0 + 1) == waitStatus) {

                    //  Message in queue
                    MSG   msg;

                    while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {
                        LTRACE((L"Main: message = %4.4x\n", msg.message));
                        if (WM_CLOSE == msg.message) {

                            //  Cancel the job since someone cancelled us.
                            //  (Should we kill the thread that is waiting?)
                            LTRACE((L"Main: got WM_CLOSE\n"));
                            WsbThrow(CancelWork(&workData));
                        }
                        DispatchMessage(&msg);
                    }

                } else if (0xFFFFFFFF == waitStatus) {

                    //  Error in MsgWaitForMultipleObjects
                    WsbThrow(HRESULT_FROM_WIN32(GetLastError()));

                } else {

                    //  This shouldn't happend; don't know what to do
                }
            }

        } WsbCatch(hr);

        if (hJobThread[0]) {
            CloseHandle(hJobThread[0]);
        }

        if (workData.pJob) {
            workData.pJob->Release();
        }

        // Cleanup COM
        CoUninitialize();
    
    } WsbCatch(hr);

    LTRACE((L"Main: exit hr = %ls\n", WsbHrAsString(hr)));
    if (FAILED(hr)) {
        ReportError(hr);
    }

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\mover\server\makefile.inc ===
$(O)\mover.res: FilterIo.rgs \
                NtTapeIo.rgs \
                NtFileIo.rgs \
                ..\..\inc\$(O)\MvrLib.tlb 

stdafx.h: ..\..\inc\Mover.h ..\..\inc\Rms.h

clean:
    -del $(O)\*.sbr
    -del $(O)\*.obj
    -del $(O)\*.res
    -del $(O)\*.pch
    -del $(TARGETPATH)\$(TARGET_DIRECTORY)\$(TARGETNAME).*
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\mover\server\filterio.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    FilterIo.cpp

Abstract:

    CFilterIo class

Author:

    Brian Dodd          [brian]         25-Nov-1997

Revision History:

--*/

#include "stdafx.h"
#include "FilterIo.h"
#include "Mll.h"
#include "Mll.h"
#include "rpdata.h"
#include "rpio.h"


int CFilterIo::s_InstanceCount = 0;

////////////////////////////////////////////////////////////////////////////////
//
// CComObjectRoot Implementation
//

#pragma optimize("g", off)

STDMETHODIMP
CFilterIo::FinalConstruct(void) 
/*++

Implements:

    CComObjectRoot::FinalConstruct

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CFilterIo::FinalConstruct"), OLESTR(""));

    try {

        WsbAffirmHr(CComObjectRoot::FinalConstruct());

        (void) CoCreateGuid( &m_ObjectId );

        m_pSession = NULL;
        m_DataSetNumber = 0;

        m_hFile = INVALID_HANDLE_VALUE;
        m_DeviceName = MVR_UNDEFINED_STRING;
        m_Flags = 0;
        m_LastVolume = OLESTR("");
        m_LastPath = OLESTR("");

        m_ValidLabel = TRUE;

        m_StreamName = MVR_UNDEFINED_STRING;
        m_Mode = 0;
        m_StreamOffset.QuadPart = 0;
        m_StreamSize.QuadPart = 0;

        m_isLocalStream = FALSE;
        m_OriginalAttributes = 0;
        m_BlockSize = DefaultBlockSize;
        m_filterId = 0;
        m_ioctlHandle = INVALID_HANDLE_VALUE;
        m_ioctlBuffer = NULL;
        m_bytesInBuffer = 0;
        m_pDataBuffer = NULL;

    } WsbCatch(hr);

    s_InstanceCount++;
    WsbTraceAlways(OLESTR("CFilterIo::s_InstanceCount += %d\n"), s_InstanceCount);

    WsbTraceOut(OLESTR("CFilterIo::FinalConstruct"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP
CFilterIo::FinalRelease(void) 
/*++

Implements:

    CComObjectRoot::FinalRelease

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CFilterIo::FinalRelease"), OLESTR(""));

    try {

        (void) CloseStream();  // in case anything is left open

        CComObjectRoot::FinalRelease();

    } WsbCatch(hr);

    s_InstanceCount--;
    WsbTraceAlways(OLESTR("CFilterIo::s_InstanceCount -= %d\n"), s_InstanceCount);

    WsbTraceOut(OLESTR("CFilterIo::FinalRelease"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}
#pragma optimize("", on)



HRESULT
CFilterIo::CompareTo(
    IN IUnknown *pCollectable,
    OUT SHORT *pResult)
/*++

Implements:

    CRmsComObject::CompareTo

--*/
{
    HRESULT     hr = E_FAIL;
    SHORT       result = 1;

    WsbTraceIn( OLESTR("CFilterIo::CompareTo"), OLESTR("") );

    try {

        // Validate arguments - Okay if pResult is NULL
        WsbAssertPointer( pCollectable );

        // We need the IRmsComObject interface to get the value of the object.
        CComQIPtr<IDataMover, &IID_IDataMover> pObject = pCollectable;
        WsbAssertPointer( pObject );

        GUID objectId;

        // Get objectId.
        WsbAffirmHr( pObject->GetObjectId( &objectId ));

        if ( m_ObjectId == objectId ) {

            // Object IDs match
            hr = S_OK;
            result = 0;

        }
        else {
            hr = S_FALSE;
            result = 1;
        }

    }
    WsbCatch( hr );

    if ( SUCCEEDED(hr) && (0 != pResult) ){
       *pResult = result;
    }

    WsbTraceOut( OLESTR("CFilterIo::CompareTo"),
                 OLESTR("hr = <%ls>, result = <%ls>"),
                 WsbHrAsString( hr ), WsbPtrToShortAsString( pResult ) );

    return hr;
}


HRESULT
CFilterIo::IsEqual(
    IUnknown* pObject
    )

/*++

Implements:

  IWsbCollectable::IsEqual().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CFilterIo::IsEqual"), OLESTR(""));

    hr = CompareTo(pObject, NULL);

    WsbTraceOut(OLESTR("CFilterIo::IsEqual"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

////////////////////////////////////////////////////////////////////////////////
//
// ISupportErrorInfo Implementation
//


STDMETHODIMP
CFilterIo::InterfaceSupportsErrorInfo(
    IN REFIID riid)
/*++

Implements:

    ISupportErrorInfo::InterfaceSupportsErrorInfo

--*/
{
    static const IID* arr[] = 
    {
        &IID_IDataMover,
        &IID_IStream,
    };

    for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
    {
        if (InlineIsEqualGUID(*arr[i],riid))
            return S_OK;
    }
    return S_FALSE;
}

////////////////////////////////////////////////////////////////////////////////
//
// IDataMover Implementation
//


STDMETHODIMP
CFilterIo::GetObjectId(
    OUT GUID *pObjectId)
/*++

Implements:

    IRmsComObject::GetObjectId

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CFilterIo::GetObjectId"), OLESTR(""));

    UNREFERENCED_PARAMETER(pObjectId);

    try {

        WsbThrow( E_NOTIMPL );

    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CFilterIo::GetObjectId"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP
CFilterIo::BeginSession(
    IN BSTR remoteSessionName,
    IN BSTR remoteSessionDescription,
    IN SHORT remoteDataSet,
    IN DWORD options)
/*++

Implements:

    IDataMover::BeginSession

Notes:

    Each session is written as a single MTF file data set.  To create a consistant
    MTF data set we copy the MediaLabel object and use it for the TAPE DBLK for
    each data set generated.

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CFilterIo::BeginSession"), OLESTR("<%ls> <%ls> <%d> <0x%08x>"),
        remoteSessionName, remoteSessionDescription, remoteDataSet, options);

    try {
        WsbThrow( E_NOTIMPL );
    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CFilterIo::BeginSession"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP
CFilterIo::EndSession(void)
/*++

Implements:

    IDataMover::EndSession

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CFilterIo::EndSession"), OLESTR(""));

    try {
        WsbThrow( E_NOTIMPL );
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFilterIo::EndSession"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP
CFilterIo::StoreData(
    IN BSTR localName,
    IN ULARGE_INTEGER localDataStart,
    IN ULARGE_INTEGER localDataSize,
    IN DWORD flags,
    OUT ULARGE_INTEGER *pRemoteDataSetStart,
    OUT ULARGE_INTEGER *pRemoteFileStart,
    OUT ULARGE_INTEGER *pRemoteFileSize,
    OUT ULARGE_INTEGER *pRemoteDataStart,
    OUT ULARGE_INTEGER *pRemoteDataSize,
    OUT DWORD *pRemoteVerificationType,
    OUT ULARGE_INTEGER *pRemoteVerificationData,
    OUT DWORD *pDatastreamCRCType,
    OUT ULARGE_INTEGER *pDatastreamCRC,
    OUT ULARGE_INTEGER *pUsn)
/*++

Implements:

    IDataMover::StoreData

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CFilterIo::StoreData"), OLESTR("<%ls> <%I64u> <%I64u> <0x%08x>"),
        WsbAbbreviatePath((WCHAR *) localName, 120), localDataStart.QuadPart, localDataSize.QuadPart, flags);

    UNREFERENCED_PARAMETER(pRemoteDataSetStart);
    UNREFERENCED_PARAMETER(pRemoteFileStart);
    UNREFERENCED_PARAMETER(pRemoteFileSize);
    UNREFERENCED_PARAMETER(pRemoteDataStart);
    UNREFERENCED_PARAMETER(pRemoteDataSize);
    UNREFERENCED_PARAMETER(pRemoteVerificationType);
    UNREFERENCED_PARAMETER(pDatastreamCRC);
    UNREFERENCED_PARAMETER(pUsn);
    UNREFERENCED_PARAMETER(pRemoteVerificationData);
    UNREFERENCED_PARAMETER(pDatastreamCRCType);
    
    try {
        WsbThrow( E_NOTIMPL );
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFilterIo::StoreData"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP
CFilterIo::RecallData(
    IN BSTR /*localName*/,
    IN ULARGE_INTEGER /*localDataStart*/,
    IN ULARGE_INTEGER /*localDataSize*/,
    IN DWORD /*options*/,
    IN BSTR /*migrateFileName*/,
    IN ULARGE_INTEGER /*remoteDataSetStart*/,
    IN ULARGE_INTEGER /*remoteFileStart*/,
    IN ULARGE_INTEGER /*remoteFileSize*/,
    IN ULARGE_INTEGER /*remoteDataStart*/,
    IN ULARGE_INTEGER /*remoteDataSize*/,
    IN DWORD /*verificationType*/,
    IN ULARGE_INTEGER /*verificationData*/)
/*++

Implements:

    IDataMover::RecallData

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CFilterIo::RecallData"), OLESTR(""));

    try {
        WsbThrow( E_NOTIMPL );
    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CFilterIo::RecallData"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP
CFilterIo::FormatLabel(
    IN BSTR displayName,
    OUT BSTR* pLabel)
/*++

Implements:

    IDataMover::FormatLabel

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CFilterIo::FormatLabel"), OLESTR("<%ls>"), displayName);

    try {
        WsbThrow( E_NOTIMPL );
    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CFilterIo::FormatLabel"), OLESTR("hr = <%ls>, label = <%ls>"), WsbHrAsString(hr), *pLabel);

    return hr;
}


STDMETHODIMP
CFilterIo::WriteLabel(
    IN BSTR label)
/*++

Implements:

    IDataMover::WriteLabel

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CFilterIo::WriteLabel"), OLESTR("<%ls>"), label);

    try {
        WsbThrow( E_NOTIMPL );
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFilterIo::WriteLabel"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP
CFilterIo::ReadLabel(
    IN OUT BSTR* pLabel)
/*++

Implements:

    IDataMover::ReadLabel

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CFilterIo::ReadLabel"), OLESTR(""));


    try {
        WsbThrow( E_NOTIMPL );
    } WsbCatch(hr);
    WsbTraceOut(OLESTR("CFilterIo::ReadLabel"), OLESTR("hr = <%ls>, label = <%ls>"), WsbHrAsString(hr), *pLabel);

    return hr;
}


STDMETHODIMP
CFilterIo::VerifyLabel(
    IN BSTR label)
/*++

Implements:

    IDataMover::VerifyLabel

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CFilterIo::VerifyLabel"), OLESTR("<%ls>"), label);

    try {
        WsbThrow( E_NOTIMPL );
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFilterIo::VerifyLabel"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP
CFilterIo::GetDeviceName(
    OUT BSTR* pName)
/*++

Implements:

    IDataMover::GetDeviceName

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CFilterIo::GetDeviceName"), OLESTR(""));

    UNREFERENCED_PARAMETER(pName);

    try {
        WsbThrow( E_NOTIMPL );
    } WsbCatch(hr);
    WsbTraceOut(OLESTR("CFilterIo::GetDeviceName"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP
CFilterIo::SetDeviceName(
    IN BSTR name,
    IN BSTR volumeName)
/*++

Implements:

    IDataMover::SetDeviceName

--*/
{
    HRESULT     hr = S_OK;
    DWORD       lpSectorsPerCluster;
    DWORD       lpBytesPerSector;
    DWORD       lpNumberOfFreeClusters;
    DWORD       lpTotalNumberOfClusters;
    CWsbBstrPtr volName;

    try {
        WsbAssertPointer(name);

        WsbAssert(wcslen((WCHAR *)name) > 0, E_INVALIDARG);

        m_DeviceName = name;
        
        WsbTraceAlways( OLESTR("CFilterIo: SetDeviceName  Opening %ws.\n"), (PWCHAR) m_DeviceName);
        
        WsbAffirmHandle(m_ioctlHandle = CreateFile(m_DeviceName, FILE_WRITE_DATA | FILE_READ_DATA,
                FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED, NULL));
        
        
        if (volumeName != 0) {
            volName = volumeName;
        } else {
            //
            // Use the supplied device name itself as the vol name
            //
            volName = m_DeviceName;           
        }

        volName.Append(L"\\");

        WsbTraceAlways( OLESTR("CFilterIo: Getdisk free space for %ws.\n"), (PWCHAR) volName);

        if (GetDiskFreeSpace(volName, &lpSectorsPerCluster, &lpBytesPerSector,  &lpNumberOfFreeClusters, &lpTotalNumberOfClusters) != 0) {
            m_secSize = lpBytesPerSector;
        } else {
            WsbThrow(E_FAIL);
        }

    } WsbCatch(hr);

    return S_OK;
}


STDMETHODIMP
CFilterIo::GetLargestFreeSpace(
    OUT LONGLONG* pFreeSpace,
    OUT LONGLONG* pCapacity,
    IN  ULONG    defaultFreeSpaceLow,
    IN  LONG     defaultFreeSpaceHigh
    )
/*++

Implements:

    IDataMover::GetLargestFreeSpace

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CFilterIo::GetLargestFreeSpace"), OLESTR(""));
    
    UNREFERENCED_PARAMETER(pFreeSpace);
    UNREFERENCED_PARAMETER(pCapacity);
    UNREFERENCED_PARAMETER(defaultFreeSpaceLow);
    UNREFERENCED_PARAMETER(defaultFreeSpaceHigh);

    try {
        WsbThrow( E_NOTIMPL );
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFilterIo::GetLargestFreeSpace"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}

STDMETHODIMP
CFilterIo::SetInitialOffset(
    IN ULARGE_INTEGER initialOffset
    )
/*++

Implements:

    IDataMover::SetInitialOffset

Notes:

    Set Initial stream offset (without explicitly seeking the stream to this offset)

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CFilterIo::SetInitialOffset"), OLESTR(""));

    m_StreamOffset.QuadPart = initialOffset.QuadPart;

    WsbTraceOut(OLESTR("CFilterIo::SetInitialOffset"), OLESTR("hr = <%ls> offset = %I64u"), WsbHrAsString(hr), initialOffset.QuadPart);

    return hr;
}


STDMETHODIMP
CFilterIo::GetCartridge(
    OUT IRmsCartridge** ptr
    )
/*++

Implements:

    IDataMover::GetCartridge

--*/
{
    HRESULT hr = S_OK;
    
    UNREFERENCED_PARAMETER(ptr);

    try {
        WsbThrow( E_NOTIMPL );
    } WsbCatch(hr);

    return hr;
}


STDMETHODIMP
CFilterIo::SetCartridge(
    IN IRmsCartridge* ptr
    )
/*++

Implements:

    IDataMover::SetCartridge

--*/
{
    HRESULT hr = S_OK;

    UNREFERENCED_PARAMETER(ptr);

    try {
        WsbThrow( E_NOTIMPL );
    } WsbCatch(hr);

    return hr;
}


STDMETHODIMP
CFilterIo::Cancel(void)
/*++

Implements:

    IDataMover::Cancel

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CFilterIo::Cancel"), OLESTR(""));

    try {
        WsbThrow(E_NOTIMPL);
    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CFilterIo::Cancel"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP
CFilterIo::CreateLocalStream(
    IN BSTR name,
    IN DWORD mode,
    OUT IStream** ppStream)
/*++

Implements:

    IDataMover::CreateLocalStream

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CFilterIo::CreateLocalStream"), OLESTR(""));

    try {
        WsbAffirmPointer( ppStream );
        WsbAffirm( mode & MVR_MODE_WRITE, E_UNEXPECTED ); // Only Recall supported this way.

        m_Mode = mode;
        m_StreamName = name;
        m_isLocalStream = TRUE;


        if ( m_Mode & MVR_FLAG_HSM_SEMANTICS ) {
            //
            // Recall - Filter has the file object
            //
            // Save away the filter ID
            //
            WsbTrace( OLESTR("CFilterIo: ID = %ws\n"), (PWCHAR) name);
            
            swscanf((PWCHAR) name, L"%I64u", &m_filterId);

        } else {
            //
            // Restore - Not supported.
            //
            WsbThrow(E_NOTIMPL);
        }

        WsbTrace( OLESTR("CFilterIo: Query...\n"));
        WsbAssertHrOk(((IUnknown*) (IDataMover*) this)->QueryInterface(IID_IStream, (void **) ppStream));

    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CFilterIo::CreateLocalStream"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}



STDMETHODIMP
CFilterIo::CreateRemoteStream(
    IN BSTR name,
    IN DWORD mode,
    IN BSTR remoteSessionName,
    IN BSTR /*remoteSessionDescription*/,
    IN ULARGE_INTEGER remoteDataSetStart,
    IN ULARGE_INTEGER remoteFileStart,
    IN ULARGE_INTEGER remoteFileSize,
    IN ULARGE_INTEGER remoteDataStart,
    IN ULARGE_INTEGER remoteDataSize,
    IN DWORD remoteVerificationType,
    IN ULARGE_INTEGER remoteVerificationData,
    OUT IStream **ppStream)
/*++

Implements:

    IDataMover::CreateRemoteStream

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CFilterIo::CreateRemoteStream"), OLESTR(""));

    UNREFERENCED_PARAMETER(remoteSessionName);
    UNREFERENCED_PARAMETER(mode);
    UNREFERENCED_PARAMETER(name);
    UNREFERENCED_PARAMETER(ppStream);
    UNREFERENCED_PARAMETER(remoteDataSetStart);
    UNREFERENCED_PARAMETER(remoteFileStart);
    UNREFERENCED_PARAMETER(remoteFileSize);
    UNREFERENCED_PARAMETER(remoteDataStart);
    UNREFERENCED_PARAMETER(remoteDataSize);
    UNREFERENCED_PARAMETER(remoteVerificationType);
    UNREFERENCED_PARAMETER(remoteVerificationData);
    
    try {
        WsbThrow( E_NOTIMPL );
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFilterIo::CreateRemoteStream"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}



STDMETHODIMP
CFilterIo::CloseStream(void)
/*++

Implements:

    IDataMover::CloseStream

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CFilterIo::CloseStream"), OLESTR(""));

    try {
        if (m_ioctlHandle != INVALID_HANDLE_VALUE) {
            CloseHandle(m_ioctlHandle);
            m_ioctlHandle = INVALID_HANDLE_VALUE;
        }
        if (m_ioctlBuffer != NULL) {
            VirtualFree(m_ioctlBuffer, 0, MEM_RELEASE);
            m_ioctlBuffer = NULL;
        }
    
        hr = S_OK;
        
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFilterIo::CloseStream"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP
CFilterIo::Duplicate(
    IN IDataMover* /*pDestination*/,
    IN DWORD /*options*/,
    OUT ULARGE_INTEGER* /*pBytesCopied*/,
    OUT ULARGE_INTEGER* /*pBytesReclaimed*/)
/*++

Implements:

    IDataMover::Duplicate

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CFilterIo::Duplicate"), OLESTR(""));

    try {
        WsbThrow( E_NOTIMPL );
    } WsbCatch(hr);
    WsbTraceOut(OLESTR("CFilterIo::Duplicate"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}



STDMETHODIMP
CFilterIo::FlushBuffers(void)
/*++

Implements:

    IDataMover::FlushBuffers

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CFilterIo::FlushBuffers"), OLESTR(""));

    try {
        WsbThrow( E_NOTIMPL );
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFilterIo::FlushBuffers"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}

STDMETHODIMP
CFilterIo::Recover(OUT BOOL *pDeleteFile)
/*++

Implements:

    IDataMover::Recover

--*/
{
    HRESULT hr = S_OK;
    *pDeleteFile = FALSE;
    WsbTraceIn(OLESTR("CFilterIo::Recover"), OLESTR(""));

    try {
        WsbThrow( E_NOTIMPL );
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFilterIo::Recover"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}

////////////////////////////////////////////////////////////////////////////////
//
// IStream Implementation
//


STDMETHODIMP
CFilterIo::Read(
    OUT void *pv,
    IN ULONG cb,
    OUT ULONG *pcbRead)
/*++

Implements:

    IStream::Read

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CFilterIo::Read"), OLESTR("Bytes Requested = %u, offset = %I64u, mode = 0x%08x"), cb, m_StreamOffset.QuadPart, m_Mode);

    UNREFERENCED_PARAMETER(pcbRead);
    UNREFERENCED_PARAMETER(pv);

    try {
        WsbThrow( E_NOTIMPL );
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFilterIo::Read"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP
CFilterIo::Write(
    IN void const *pv,
    IN ULONG cb,
    OUT ULONG *pcbWritten)
/*++

Implements:

    IStream::Write

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CFilterIo::Write"), OLESTR("Bytes Requested = %u, offset = %I64u, mode = 0x%08x"), 
        cb, m_StreamOffset.QuadPart, m_Mode);

    ULONG bytesWritten = 0;

    try {
        WsbAssert(pv != 0, STG_E_INVALIDPOINTER);


        WsbAffirmHr(WriteBuffer((BYTE *) pv, cb, &bytesWritten));

        if (pcbWritten) {
            *pcbWritten = bytesWritten;
        }

        // NOTE: Stream offset is updated by WriteBuffer

    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CFilterIo::Write"), OLESTR("hr = <%ls>, bytesWritten=%u"), WsbHrAsString(hr), bytesWritten);

    return hr;
}


STDMETHODIMP
CFilterIo::Seek(
    IN LARGE_INTEGER dlibMove,
    IN DWORD dwOrigin,
    OUT ULARGE_INTEGER *plibNewPosition)
/*++

Implements:

    IStream::Seek

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CFilterIo::Seek"), OLESTR("<%I64d> <%d>"), dlibMove.QuadPart, dwOrigin);

    UNREFERENCED_PARAMETER(plibNewPosition);
    
    try {

        //
        // Note: Somewhere it is written that FILE_BEGIN is always and
        //       forever same as STREAM_SEEK_CUR, etc.
        //
        switch ( (STREAM_SEEK)dwOrigin ) {
        case STREAM_SEEK_SET:
            m_StreamOffset.QuadPart = dlibMove.QuadPart;
            break;

        case STREAM_SEEK_CUR:
            m_StreamOffset.QuadPart += dlibMove.QuadPart;
            break;

        case STREAM_SEEK_END:
            WsbThrow( E_NOTIMPL );
            break;

        default:
            WsbThrow(STG_E_INVALIDFUNCTION);
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFilterIo::Seek"), OLESTR("hr = <%ls>, newPosition=%I64u"), WsbHrAsString(hr), m_StreamOffset.QuadPart);

    return hr;
}


STDMETHODIMP
CFilterIo::SetSize(
    IN ULARGE_INTEGER /*libNewSize*/)
/*++

Implements:

    IStream::SetSize

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CFilterIo::SetSize"), OLESTR(""));

    try {
        WsbThrow(E_NOTIMPL);
    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CFilterIo::SetSize"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP
CFilterIo::CopyTo(
    IN IStream *pstm,
    IN ULARGE_INTEGER cb,
    OUT ULARGE_INTEGER *pcbRead,
    OUT ULARGE_INTEGER *pcbWritten)
/*++

Implements:

    IStream::CopyTo

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CFilterIo::CopyTo"), OLESTR("<%I64u>"), cb.QuadPart);

    UNREFERENCED_PARAMETER(pcbWritten);
    UNREFERENCED_PARAMETER(pcbRead);
    UNREFERENCED_PARAMETER(pstm);

    try {
        WsbThrow( E_NOTIMPL );
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFilterIo::CopyTo"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}

STDMETHODIMP
CFilterIo::Commit(
    IN DWORD grfCommitFlags)
/*++

Implements:

    IStream::Commit

--*/
{
    HRESULT     hr = S_OK;
    PRP_MSG     pMsgBuff = (PRP_MSG) NULL;
    DWORD       ioSize, xferSize, retSize, lastError;
    BOOL        code;
    DWORD       offsetFrom;
    

    WsbTraceIn(OLESTR("CFilterIo::Commit"), OLESTR(""));
    
    UNREFERENCED_PARAMETER(grfCommitFlags);

    try {
        WsbAffirmPointer(m_ioctlBuffer);
        //
        // Bail out with a success code if there are no more bytes to write.
        //
        WsbAffirm(m_bytesInBuffer != 0, S_OK);

        ioSize = sizeof(RP_MSG) + m_bytesInBuffer + m_secSize;
        
        offsetFrom = ((sizeof(RP_MSG) / m_secSize) + 1) * m_secSize;
        
        m_pDataBuffer = (PCHAR) m_ioctlBuffer + offsetFrom;
        pMsgBuff = (PRP_MSG) m_ioctlBuffer;
        pMsgBuff->msg.pRep.offsetToData = offsetFrom;
        
        //
        // It seems to work even if the last write is not a sector multiple so we will leave it that way
        // for now.
        //
        xferSize = m_bytesInBuffer;
        
        //if (m_bytesInBuffer % m_secSize == 0) {
        //    xferSize = m_bytesInBuffer;
        //} else {
        //    //
        //    // Round to the next sector size.
        //    //
        //    xferSize = ((m_bytesInBuffer / m_secSize) + 1) * m_secSize;
        //}
        
        
        pMsgBuff->inout.command = RP_PARTIAL_DATA;
        pMsgBuff->inout.status = 0;
        pMsgBuff->msg.pRep.bytesRead = xferSize;
        pMsgBuff->msg.pRep.byteOffset = m_StreamOffset.QuadPart;
        pMsgBuff->msg.pRep.filterId = m_filterId;
        
        code = DeviceIoControl(m_ioctlHandle, FSCTL_HSM_DATA, pMsgBuff, ioSize,
                NULL, 0, &retSize, NULL);
        lastError = GetLastError();
        WsbTrace(OLESTR("CFilterIo::Commit: Final write of %u bytes at offset %I64u for id %I64x Ioctl returned %u  (%x)\n"), 
                xferSize, m_StreamOffset.QuadPart, m_filterId, code, lastError);
        if (!code) {
            //
            // Some kind of error
            //
            WsbAffirm(FALSE, HRESULT_FROM_WIN32(lastError));
        } 
        
        //
        // Reset the output buffer
        //
        m_bytesInBuffer = 0;
        m_StreamOffset.QuadPart += xferSize;
        
        
        WsbTrace(OLESTR("CFilterIo::Commit: Final write for id = %I64x\n"), m_filterId);
    
    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CFilterIo::Commit"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP
CFilterIo::Revert(void)
/*++

Implements:

    IStream::Revert

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CFilterIo::Revert"), OLESTR(""));

    try {
        WsbThrow(E_NOTIMPL);
    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CFilterIo::Revert"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP
CFilterIo::LockRegion(
    IN ULARGE_INTEGER /*libOffset*/,
    IN ULARGE_INTEGER /*cb*/,
    IN DWORD /*dwLockType*/)
/*++

Implements:

    IStream::LockRegion

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CFilterIo::LockRegion"), OLESTR(""));

    try {
        WsbThrow(E_NOTIMPL);
    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CFilterIo::LockRegion"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP
CFilterIo::UnlockRegion(
    IN ULARGE_INTEGER /*libOffset*/,
    IN ULARGE_INTEGER /*cb*/,
    IN DWORD /*dwLockType*/)
/*++

Implements:

    IStream::UnlockRegion

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CFilterIo::UnlockRegion"), OLESTR(""));

    try {
        WsbThrow(E_NOTIMPL);
    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CFilterIo::UnlockRegion"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP
CFilterIo::Stat(
    OUT STATSTG * /*pstatstg*/,
    IN DWORD /*grfStatFlag*/)
/*++

Implements:

    IStream::Stat

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CFilterIo::Stat"), OLESTR(""));

    try {
        WsbThrow(E_NOTIMPL);
    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CFilterIo::Stat"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP
CFilterIo::Clone(
    OUT IStream ** /*ppstm*/)
/*++

Implements:

    IStream::Clone

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CFilterIo::Clone"), OLESTR(""));

    try {
        WsbThrow(E_NOTIMPL);
    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CFilterIo::Clone"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


////////////////////////////////////////////////////////////////////////////////
//
// Local Methods
//


HRESULT
CFilterIo::WriteBuffer(
    IN BYTE *pBuffer,
    IN ULONG nBytesToWrite,
    OUT ULONG *pBytesWritten)
/*++

Routine Description:

    Used to write all MTF data.  Guarantees full blocks are written.

Arguments:

    pBuffer       -  Data buffer.
    nBytesToWrite -  number of bytes to write in buffer.
    pBytesWritten -  Bytes written.

Return Value:

    S_OK        -  Success.

--*/
{
    HRESULT     hr = S_OK;
    PRP_MSG     pMsgBuff = (PRP_MSG) NULL;
    DWORD       ioSize, xferSize, retSize, lastError;
    BOOL        code;
    BYTE        *pInputBuffer;
    DWORD       offsetFrom;
    BOOL        writing = TRUE;
    DWORD       bytesLeft;
    

    WsbTraceIn(OLESTR("CFilterIo::WriteBuffer"), OLESTR(""));


    try {
        if (m_ioctlBuffer == NULL) {
            //
            // We need to allocate an aligned buffer to send the data so that writes can be non-cached
            //
            
            WsbAffirmPointer((m_ioctlBuffer = VirtualAlloc(NULL, sizeof(RP_MSG) + WRITE_SIZE + m_secSize, MEM_COMMIT, PAGE_READWRITE)));
        }

        ioSize = sizeof(RP_MSG) + WRITE_SIZE + m_secSize;
        pInputBuffer = pBuffer;
        offsetFrom = ((sizeof(RP_MSG) / m_secSize) + 1) * m_secSize;
        
        m_pDataBuffer = (PCHAR) m_ioctlBuffer + offsetFrom;
        pMsgBuff = (PRP_MSG) m_ioctlBuffer;
        pMsgBuff->msg.pRep.offsetToData = offsetFrom;
        
        *pBytesWritten = 0;
        bytesLeft = nBytesToWrite;
        while (writing) {
            //
            // Stay in the loop until we have removed all the data from the input buffer
            //
            xferSize = min(bytesLeft, WRITE_SIZE - m_bytesInBuffer);
            //
            // Fill the output buffer with up to WRITE_SIZE of data.
            //
            memcpy(m_pDataBuffer + m_bytesInBuffer, pInputBuffer, xferSize);
            bytesLeft -= xferSize;
            *pBytesWritten += xferSize;
            m_bytesInBuffer += xferSize;
            pInputBuffer += xferSize;
            //
            // If we have a full buffer then write it out.
            //
            if (m_bytesInBuffer == WRITE_SIZE) {
                pMsgBuff->inout.command = RP_PARTIAL_DATA;
                pMsgBuff->inout.status = 0;
                pMsgBuff->msg.pRep.bytesRead = WRITE_SIZE;
                pMsgBuff->msg.pRep.byteOffset = m_StreamOffset.QuadPart;
                pMsgBuff->msg.pRep.filterId = m_filterId;
            
                code = DeviceIoControl(m_ioctlHandle, FSCTL_HSM_DATA, pMsgBuff, ioSize,
                        NULL, 0, &retSize, NULL);
                lastError = GetLastError();
                WsbTrace(OLESTR("CFilterIo::WriteBuffer: Partial write of %u bytes at offset %u Ioctl returned %u  (%x)\n"), 
                        WRITE_SIZE, m_StreamOffset.QuadPart, code, lastError);
                if (!code) {
                    //
                    // Some kind of error
                    //
                    WsbAffirm(FALSE, HRESULT_FROM_WIN32(lastError));
                } 
                //
                // Reset the output buffer
                //
                m_bytesInBuffer = 0;
                m_StreamOffset.QuadPart += WRITE_SIZE;
            }    
            
            if (*pBytesWritten == nBytesToWrite) {
                writing = FALSE;
            }
        }
        //
        // Tell them we have written all they asked.
        // It may not have actually been written out yet but we will get it later.
        //
        *pBytesWritten = nBytesToWrite;
        
        WsbTrace(OLESTR("CFilterIo::WriteBuffer: Partial write for id = %I64x bytes taken = %u\n"), 
            m_filterId, nBytesToWrite);
    
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CFilterIo::WriteBuffer"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


HRESULT
CFilterIo::ReadBuffer (
    IN BYTE *pBuffer,
    IN ULONG nBytesToRead,
    OUT ULONG *pBytesRead)
/*++

Routine Description:

    Used to read all MTF data.  Guarantees full blocks are read.

Arguments:

    pBuffer     -  Data buffer.
    nBytesToRead -  number of bytes to read into buffer.
    pBytesRead  -  Bytes read.

Return Value:

    S_OK        -  Success.

--*/
{
    HRESULT hr = S_OK;

    UNREFERENCED_PARAMETER(pBuffer);
    UNREFERENCED_PARAMETER(nBytesToRead);
    UNREFERENCED_PARAMETER(pBytesRead);

    try {
        WsbThrow( E_NOTIMPL );
    } WsbCatch(hr);

    return hr;
}



HRESULT
CFilterIo::MapFileError(
    IN HRESULT hrToMap)
/*++

Routine Description:

    Maps a WIN32 file error, specified as an HRESULT, to a MVR error.

Arguments:

    hrToMap     -  WIN32 file error to map.

Return Value:

    S_OK                            - Success.
    MVR_E_BEGINNING_OF_MEDIA        - The beginning of the tape or a partition was encountered.
    MVR_E_BUS_RESET                 - The I/O bus was reset.
    MVR_E_END_OF_MEDIA              - The physical end of the tape has been reached.
    MVR_S_FILEMARK_DETECTED         - A tape access reached a filemark.
    MVR_S_SETMARK_DETECTED          - A tape access reached the end of a set of files.
    MVR_S_NO_DATA_DETECTED          - No more data is on the tape.
    MVR_E_PARTITION_FAILURE         - Tape could not be partitioned.
    MVR_E_INVALID_BLOCK_LENGTH      - When accessing a new tape of a multivolume partition, the current blocksize is incorrect.
    MVR_E_DEVICE_NOT_PARTITIONED    - Tape partition information could not be found when loading a tape.
    MVR_E_MEDIA_CHANGED             - The media in the drive may have changed.
    MVR_E_NO_MEDIA_IN_DRIVE         - No media in drive.
    MVR_E_UNABLE_TO_LOCK_MEDIA      - Unable to lock the media eject mechanism.
    MVR_E_UNABLE_TO_UNLOAD_MEDIA    - Unable to unload the media.
    MVR_E_WRITE_PROTECT             - The media is write protected.
    MVR_E_CRC                       - Data error (cyclic redundancy check).
    MVR_E_SHARING_VIOLATION         - The process cannot access the file because it is being used by another process.
    MVR_E_ERROR_IO_DEVICE           - The request could not be performed because of an I/O device error.                          - Unknown error.
    MVR_E_ERROR_DEVICE_NOT_CONNECTED - The device is not connected.
    E_ABORT                         - Unknown error, abort.

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CFilterIo::MapFileError"), OLESTR("<%ls>"), WsbHrAsString(hrToMap));

    try {

        // The valid label flag is knocked down when the media may have changed
        // or device parameters (i.e. block size) may have been reset.
        switch ( hrToMap ) {
        case S_OK:
            break;
        case HRESULT_FROM_WIN32( ERROR_BEGINNING_OF_MEDIA ):
            hr = MVR_E_BEGINNING_OF_MEDIA;
            break;
        case HRESULT_FROM_WIN32( ERROR_BUS_RESET ):
            hr = MVR_E_BUS_RESET;
            m_ValidLabel = FALSE;
            WsbLogEvent(MVR_MESSAGE_MEDIA_NOT_VALID, 0, NULL, WsbHrAsString(hr), NULL);
            break;
        case HRESULT_FROM_WIN32( ERROR_END_OF_MEDIA ):
            hr = MVR_E_END_OF_MEDIA;
            break;
        case HRESULT_FROM_WIN32( ERROR_FILEMARK_DETECTED ):     // Maps to Success
            hr = MVR_S_FILEMARK_DETECTED;
            break;
        case HRESULT_FROM_WIN32( ERROR_SETMARK_DETECTED ):      // Maps to Success
            hr = MVR_S_SETMARK_DETECTED;
            break;
        case HRESULT_FROM_WIN32( ERROR_NO_DATA_DETECTED ):      // Maps to Success
            // EOD
            // This happens on SpaceFilemarks() past end of data.
            hr = MVR_S_NO_DATA_DETECTED;
            break;
        case HRESULT_FROM_WIN32( ERROR_PARTITION_FAILURE ):
            hr = MVR_E_PARTITION_FAILURE;
            break;
        case HRESULT_FROM_WIN32( ERROR_INVALID_BLOCK_LENGTH ):
            hr = MVR_E_INVALID_BLOCK_LENGTH;
            break;
        case HRESULT_FROM_WIN32( ERROR_DEVICE_NOT_PARTITIONED ):
            hr = MVR_E_DEVICE_NOT_PARTITIONED;
            break;
        case HRESULT_FROM_WIN32( ERROR_MEDIA_CHANGED ):
            hr = MVR_E_MEDIA_CHANGED;
            m_ValidLabel = FALSE;
            WsbLogEvent(MVR_MESSAGE_MEDIA_NOT_VALID, 0, NULL, WsbHrAsString(hr), NULL);
            break;
        case HRESULT_FROM_WIN32( ERROR_NO_MEDIA_IN_DRIVE ):
            hr = MVR_E_NO_MEDIA_IN_DRIVE;
            m_ValidLabel = FALSE;
            WsbLogEvent(MVR_MESSAGE_MEDIA_NOT_VALID, 0, NULL, WsbHrAsString(hr), NULL);
            break;
        case HRESULT_FROM_WIN32( ERROR_UNABLE_TO_LOCK_MEDIA ):
            hr = MVR_E_UNABLE_TO_LOCK_MEDIA;
            break;
        case HRESULT_FROM_WIN32( ERROR_UNABLE_TO_UNLOAD_MEDIA ):
            hr = MVR_E_UNABLE_TO_UNLOAD_MEDIA;
            break;
        case HRESULT_FROM_WIN32( ERROR_WRITE_PROTECT ):
            hr = MVR_E_WRITE_PROTECT;
            break;
        case HRESULT_FROM_WIN32( ERROR_CRC ): 
            // This is may indicate that the drive needs cleaning.
            hr = MVR_E_CRC;
            break;
        case HRESULT_FROM_WIN32( ERROR_SHARING_VIOLATION ):
            // This happens when the CreateFile fails because the device is in use by some other app.
            hr = MVR_E_SHARING_VIOLATION;
            break;
        case HRESULT_FROM_WIN32( ERROR_IO_DEVICE ):
            // This happens when the device is turned off during I/O, for example.
            hr = MVR_E_ERROR_IO_DEVICE;
            break;
        case HRESULT_FROM_WIN32( ERROR_DEVICE_NOT_CONNECTED ):
            // This happens when the device is turned off.
            hr = MVR_E_ERROR_DEVICE_NOT_CONNECTED;
            break;
        case HRESULT_FROM_WIN32( ERROR_SEM_TIMEOUT ):
            // This happens when the SCSI command does not return within the timeout period.  A system error is logged for the SCSI controler (adapter).
            hr = MVR_E_ERROR_DEVICE_NOT_CONNECTED;
            break;
        default:
            WsbThrow(hrToMap);
        }

    } WsbCatchAndDo(hr,
            WsbLogEvent(MVR_MESSAGE_UNKNOWN_DEVICE_ERROR, 0, NULL, WsbHrAsString(hr), NULL);
            hr = E_ABORT;
        );


    WsbTraceOut(OLESTR("CFilterIo::MapFileError"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\mover\server\filterio.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    FilterIo.h

Abstract:

    Definition of the CFilterIo class

Author:

    Brian Dodd          [brian]         25-Nov-1997

Revision History:

--*/

#if !defined(FilterIo_H)
#define FilterIo_H

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "resource.h"       // main symbols
#include "MTFSessn.h"       // CMTFSession

/////////////////////////////////////////////////////////////////////////////
// CFilterIo

class CFilterIo : 
    public CComDualImpl<IDataMover, &IID_IDataMover, &LIBID_MOVERLib>,
    public IStream,
    public ISupportErrorInfo,
    public IWsbCollectable,
    public CComObjectRoot,
    public CComCoClass<CFilterIo,&CLSID_CFilterIo>
{
public:
    CFilterIo() {}
BEGIN_COM_MAP(CFilterIo)
    COM_INTERFACE_ENTRY2(IDispatch, IDataMover)
    COM_INTERFACE_ENTRY(IDataMover)
    COM_INTERFACE_ENTRY(IStream)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
    COM_INTERFACE_ENTRY(IWsbCollectable)
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(CFilterIo) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation. 

DECLARE_REGISTRY_RESOURCEID(IDR_CFilterIo)

// ISupportsErrorInfo
    STDMETHOD(InterfaceSupportsErrorInfo)(
        IN REFIID riid);

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);
    STDMETHOD(FinalRelease)(void);

// IWsbCollectable
public:
    STDMETHOD(CompareTo)( IN IUnknown *pCollectable, OUT SHORT *pResult);
    STDMETHOD(IsEqual)(IUnknown* pCollectable);

// IDataMover
public:
    STDMETHOD(GetObjectId)(OUT GUID *pObjectId);

    STDMETHOD( BeginSession )(
        IN BSTR remoteSessionName,
        IN BSTR remoteSessionDescription,
        IN SHORT remoteDataSet,
        IN DWORD options);

    STDMETHOD( EndSession )(void);

    STDMETHOD( StoreData )(
        IN BSTR localName,
        IN ULARGE_INTEGER localDataStart,
        IN ULARGE_INTEGER localDataSize,
        IN DWORD flags,
        OUT ULARGE_INTEGER *pRemoteDataSetStart,
        OUT ULARGE_INTEGER *pRemoteFileStart,
        OUT ULARGE_INTEGER *pRemoteFileSize,
        OUT ULARGE_INTEGER *pRemoteDataStart,
        OUT ULARGE_INTEGER *pRemoteDataSize,
        OUT DWORD *pRemoteVerificationType,
        OUT ULARGE_INTEGER *pRemoteVerificationData,
        OUT DWORD *pDatastreamCRCType,
        OUT ULARGE_INTEGER *pDatastreamCRC,
        OUT ULARGE_INTEGER *pUsn);

    STDMETHOD( RecallData )(
        IN BSTR localName,
        IN ULARGE_INTEGER localDataStart,
        IN ULARGE_INTEGER localDataSize,
        IN DWORD flags,
        IN BSTR migrateSessionName,
        IN ULARGE_INTEGER remoteDataSetStart,
        IN ULARGE_INTEGER remoteFileStart,
        IN ULARGE_INTEGER remoteFileSize,
        IN ULARGE_INTEGER remoteDataStart,
        IN ULARGE_INTEGER remoteDataSize,
        IN DWORD remoteVerificationType,
        IN ULARGE_INTEGER remoteVerificationData);

    STDMETHOD( FormatLabel )(
        IN BSTR displayName,
        OUT BSTR *pLabel);

    STDMETHOD( WriteLabel )(
        IN BSTR label);

    STDMETHOD( ReadLabel )(
        IN OUT BSTR *pLabel );

    STDMETHOD( VerifyLabel )(
        IN BSTR label);

    STDMETHOD( GetDeviceName )(
        OUT BSTR *pName);

    STDMETHOD( SetDeviceName )(
        IN BSTR name,
        IN BSTR volName);

    STDMETHOD( GetLargestFreeSpace )(
        OUT LONGLONG *pFreeSpace,
        OUT LONGLONG *pCapacity,
        IN  ULONG    defaultFreeSpaceLow = 0xFFFFFFFF,
        IN  LONG     defaultFreeSpaceHigh = 0xFFFFFFFF);

    STDMETHOD( SetInitialOffset )(
        IN ULARGE_INTEGER initialOffset);

    STDMETHOD( GetCartridge )(
        OUT IRmsCartridge **ptr);

    STDMETHOD( SetCartridge )(
        IN IRmsCartridge *ptr);

    STDMETHOD( Cancel )(void);

    STDMETHOD( CreateLocalStream )(
        IN BSTR name,
        IN DWORD mode,
        OUT IStream **ppStream);

    STDMETHOD( CreateRemoteStream )(
        IN BSTR name,
        IN DWORD mode,
        IN BSTR remoteSessionName,
        IN BSTR remoteSessionDescription,
        IN ULARGE_INTEGER remoteDataSetStart,
        IN ULARGE_INTEGER remoteFileStart,
        IN ULARGE_INTEGER remoteFileSize,
        IN ULARGE_INTEGER remoteDataStart,
        IN ULARGE_INTEGER remoteDataSize,
        IN DWORD remoteVerificationType,
        IN ULARGE_INTEGER remoteVerificationData,
        OUT IStream **ppStream);

    STDMETHOD( CloseStream )(void);

    STDMETHOD( Duplicate )(
        IN IDataMover *pDestination,
        IN DWORD options,
        OUT ULARGE_INTEGER *pBytesCopied,
        OUT ULARGE_INTEGER *pBytesReclaimed);

    STDMETHOD( FlushBuffers )(void);

    STDMETHOD( Recover )(OUT BOOL *pDeleteFile);

// IStream
public:
    STDMETHOD( Read )(
        OUT void *pv,
        IN ULONG cb,
        OUT ULONG *pcbRead);

    STDMETHOD( Write )(
        IN void const *pv,
        IN ULONG cb,
        OUT ULONG *pcbWritten);

    STDMETHOD( Seek )(
        IN LARGE_INTEGER dlibMove,
        IN DWORD dwOrigin,
        OUT ULARGE_INTEGER *plibNewPosition);

    STDMETHOD( SetSize )(
        IN ULARGE_INTEGER libNewSize);

    STDMETHOD( CopyTo )(
        IN IStream *pstm,
        IN ULARGE_INTEGER cb,
        OUT ULARGE_INTEGER *pcbRead,
        OUT ULARGE_INTEGER *pcbWritten);

    STDMETHOD( Commit )(
        IN DWORD grfCommitFlags);

    STDMETHOD( Revert )(void);

    STDMETHOD( LockRegion )(
        IN ULARGE_INTEGER libOffset,
        IN ULARGE_INTEGER cb,
        IN DWORD dwLockType);

    STDMETHOD( UnlockRegion )(
        IN ULARGE_INTEGER libOffset,
        IN ULARGE_INTEGER cb,
        IN DWORD dwLockType);

    STDMETHOD( Stat )(
        OUT STATSTG *pstatstg,
        IN DWORD grfStatFlag);

    STDMETHOD( Clone )(
        OUT IStream **ppstm);

//
// Writes must be aligned and multiples of the sector size
//

#define WRITE_SIZE  (128 * 1024)


private:
    enum {                                          // Class specific constants:
                                                    //
        Version = 1,                                // Class version, this should be
                                                    //   incremented each time the
                                                    //   the class definition changes.
        DefaultBlockSize = RMS_DEFAULT_BLOCK_SIZE,  // Default block size to use.
        DefaultMinBufferSize = RMS_DEFAULT_BUFFER_SIZE, // Default minimum buffer size.
    };
    GUID                    m_ObjectId;             // Unique ID for this object.
    CMTFSession*            m_pSession;             // Holds all session information.
    SHORT                   m_DataSetNumber;        // Holds the current dataset number.
    HANDLE                  m_hFile;                // Tape drive handle.
    CWsbBstrPtr             m_DeviceName;           // The name of the tape device.
    DWORD                   m_Flags;                // Holds data transfer type flag.
    CWsbBstrPtr             m_LastVolume;           // Name of the last volume backed up.
    CWsbBstrPtr             m_LastPath;             // Name of the last directory backed up.
    BOOL                    m_ValidLabel;           // True if the label is valid, the flag
                                                    //   knocked down on BUS_RESET and Medium
                                                    //   errors, and assumed valid at initialization.

    CWsbBstrPtr             m_StreamName;           // Stream state information...
    ULONG                   m_Mode;                 // The kind of I/O.  See MVR_MODE_*
    ULARGE_INTEGER          m_StreamOffset;         // The Current offset into the data stream
    ULARGE_INTEGER          m_StreamSize;           // The size of the data stream
    CComPtr<IRmsCartridge>  m_pCartridge;           // A reference to the Cartridge in use by the DataMover.

    BOOL                    m_isLocalStream;        // Either local and remote stream is created
    ULONG                   m_OriginalAttributes;   // The original attributes of the local file.

    DWORD                   m_BlockSize;            // The read/write blocking factor.

    static int              s_InstanceCount;        // Counter of the number of object instances.
    
    ULONGLONG               m_filterId;             // ID Filter uses for this file
    HANDLE                  m_ioctlHandle;          // Handle to talk to the filter with
    PVOID                   m_ioctlBuffer;          // Aligned buffer 
    DWORD                   m_secSize;              // Sector size to align on
    PCHAR                   m_pDataBuffer;          // Pointer to the buffer to put the write data
    DWORD                   m_bytesInBuffer;        // Number of unwritten bytes in the buffer

    // File I/O
    HRESULT WriteBuffer(IN BYTE *pBuffer, IN ULONG nBytesToWrite, OUT ULONG *pBytesWritten);
    HRESULT ReadBuffer(IN BYTE *pBuffer, IN ULONG nBytesToRead, OUT ULONG *pBytesRead);


    HRESULT MapFileError(IN HRESULT hrToMap);
};

#endif // !defined(FilterIo_H)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\mover\server\mover.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    Mover.cpp

Abstract:

    Data Mover defines

Author:

    Brian Dodd          [brian]         01-Apr-1997

Revision History:

--*/

// Mover.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To merge the proxy/stub code into the object DLL, add the file 
//      dlldatax.c to the project.  Make sure precompiled headers 
//      are turned off for this file, and add _MERGE_PROXYSTUB to the 
//      defines for the project.  
//
//      If you are not running WinNT4.0 or Win95 with DCOM, then you
//      need to remove the following define from dlldatax.c
//      #define _WIN32_WINNT 0x0400
//
//      Further, if you are running MIDL without /Oicf switch, you also 
//      need to remove the following define from dlldatax.c.
//      #define USE_STUBLESS_PROXY
//
//      Modify the custom build rule for Mover.idl by adding the following 
//      files to the Outputs.
//          Mover_p.c
//          dlldata.c
//      To build a separate proxy/stub DLL, 
//      run nmake -f Moverps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include "initguid.h"
#include "Mover.h"
#include "dlldatax.h"

#include "NtTapeIo.h"
#include "NtFileIo.h"
#include "FilterIo.h"

#ifdef _MERGE_PROXYSTUB
extern "C" HINSTANCE hProxyDll;
#endif

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_CNtTapeIo, CNtTapeIo)
    OBJECT_ENTRY(CLSID_CNtFileIo, CNtFileIo)
    OBJECT_ENTRY(CLSID_CFilterIo, CFilterIo)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    lpReserved;
#ifdef _MERGE_PROXYSTUB
    if (!PrxDllMain(hInstance, dwReason, lpReserved))
        return FALSE;
#endif
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllCanUnloadNow() != S_OK)
        return S_FALSE;
#endif
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
        return S_OK;
#endif
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    HRESULT hr;

#ifdef _MERGE_PROXYSTUB
    HRESULT hRes = PrxDllRegisterServer();
    if (FAILED(hRes))
        return hRes;
#endif

    // registers object, typelib and all interfaces in typelib
    hr = CoInitialize( 0 );

    if (SUCCEEDED(hr)) {
        hr = _Module.RegisterServer( FALSE );
        CoUninitialize( );
    }

    return( hr );
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    HRESULT hr;

#ifdef _MERGE_PROXYSTUB
    PrxDllUnregisterServer();
#endif

    hr = CoInitialize( 0 );

    if (SUCCEEDED(hr)) {
        _Module.UnregisterServer();
        CoUninitialize( );
        hr = S_OK;
    }

    return( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\mover\server\mtfapi.cpp ===
//____________________________________________________________________________
//
// (C) Copyright Seagate Software, Inc. 1994-1996
//  1998 Seagate Software, Inc.  All rights reserved.
//
// All Rights Reserved Worldwide.
//
//____________________________________________________________________________
//
// FILE NAME :          mtf_api.c
//
// DESCRIPTION :        mtf api implementation 
//
// CREATED:             6/20/95
//
//____________________________________________________________________________
//
// $Revision:   1.35  $
//     $Date:   02 Feb 1995 15:47:04  $
//  $Modtime:   02 Feb 1995 15:37:38  $
//  
//____________________________________________________________________________
// *****************************************************************************/

#include <assert.h>
#include <time.h>
#include <string.h>
#include <wchar.h>
#include <stralign.h>

#include "stdafx.h"
#include "mtfapi.h"

static USHORT iCountMTFa = 0;  // Count of existing objects
//
//  Constructor
//
CMTFApi::CMTFApi(void)
{
    m_uAlignmentFactor = 0;

    m_iNumStrings = 0;
    for (int i = 0; i < iNUMSTRINGS; ++i){
        m_aszStrings[i] = 0;
    }

    iCountMTFa++;
}

//
// Destructor
//
CMTFApi::~CMTFApi()
{
    ClearStrings();

    iCountMTFa--;
}


/* ==================================================================================
     String Management
     When reading blocks, the strings are not null terminated -- we would like to 
     pull them out and deliver them back in the ####_INFO structures in a civilized
     (null terminated) way.  Thus, just set up an array of malloc'ec strings.  
     Each call that uses strings should first call "ClearStrings" -- strings returned
     to the user will only be good up until the next call...
================================================================================= */

// - returns the size of a wchar_t string
//   and returns zero for a null pointer
size_t CMTFApi::wstrsize(wchar_t *s)
{
    if (s)
        return wcslen(s) * sizeof(wchar_t);
    else 
        return 0;
}

// - returns the size of a wchar_t unaligned string
//   and returns zero for a null pointer
size_t CMTFApi::ua_wstrsize(wchar_t UNALIGNED *s)
{
    if (s)
        return ua_wcslen(s) * sizeof(wchar_t);
    else 
        return 0;
}


// - frees all allocated pointers in m_aszStrings and sets
//   m_iNumStrings to zero
void CMTFApi::ClearStrings()
{
    int i;
    for (i = 0; i < iNUMSTRINGS; ++i)
    {
        if (m_aszStrings[i])
            free(m_aszStrings[i]);         
        m_aszStrings[i] = 0;
    }

    m_iNumStrings = 0;
}


// - allocates a string in m_aszStrings that is a copy of pString
//   (pString need not be null terminated)
//   (note -- iSize is the size of the string in bytes -- not the length!!!!!
wchar_t * CMTFApi::MakeString(wchar_t UNALIGNED * pString, size_t iSize)
{
    size_t i;
    if (m_iNumStrings >= iNUMSTRINGS) {
        return NULL;
    }
    m_aszStrings[m_iNumStrings] = (wchar_t *)malloc(iSize + sizeof(wchar_t));
    if (!m_aszStrings[m_iNumStrings])
        return NULL;
    
    for (i = 0; i < iSize / sizeof(wchar_t); ++i)
        m_aszStrings[m_iNumStrings][i] = pString[i];
    
    m_aszStrings[m_iNumStrings][i] = L'\0';

    return m_aszStrings[m_iNumStrings++]; 
}


/* ==================================================================================
    Other data structures
================================================================================= */

#pragma pack(1)

/***********************************************************************************
************************************************************************************
************************************************************************************
****  MTF On Tape Structures 
************************************************************************************
************************************************************************************
***********************************************************************************/

/* ==================================================================================
     Common DBLK Header
     - The common dblk header exactly as it appears on tape in the head of the dblks
================================================================================== */
typedef struct { 

     UINT8              acBlockType[4];         /* 00h  Unique identifier, see above            */
     UINT32             uBlockAttributes;       /* 04h  Common attributes for this block        */
     UINT16             uOffsetToFirstStream;   /* 08h  Offset to data associated with this     */
                                                /*      DBLK, or offset to next DBLK or         */
                                                /*      filemark if there is no associated      */
                                                /*      data.                                   */
     UINT8              uOSID;                  /* 0Ah  Machine/OS id where written, low byte   */
     UINT8              uOSVersion;             /* 0Bh  Machine/OS id where written, high byte  */
     UINT64             uDisplayableSize;       /* 0Ch  Displayable data size                   */
     UINT64             uFormatLogicalAddress;  /* 14h  Logical blk address relative to SSET    */
     UINT16             uReservedForMBC;        /* 1Ch  Reserved for Media Based Catalog        */
     UINT16             uSoftwareCompression;   /* 1Eh  Software Compression Algorithm        ***/
     UINT8              acReserved1[4];         /* 20h  reserved                                */
     UINT32             uControlBlockId;        /* 24h  Used for error recovery                 */
     UINT8              acReserved2[4];         /* 28h  reserved                                */
     MTF_TAPE_ADDRESS   sOSSpecificData;        /* 2Ch  Size and offset of OS specific stuff    */
     UINT8              uStringType;            /* 30h  ASCII, Unicode, etc.                    */
     UINT8              uReserved3;             /* 31h  for alignment purposes                  */
     UINT16             uHeaderCheckSum;        /* 32h  Checksum of the block header.  The      */
                                                /*      algorithm is: XOR each word preceeding  */
                                                /*      this one and store the result here.     */
                                                /*      (When the checksum is verified the      */
                                                /*      'block_type' is also checked for a      */
                                                /*      non-zero value.                         */
} MTF_DBLK_HDR;



/* ==================================================================================
     DBLK TAPE Header
     - The TAPE DBLK, exactly as it appears on tape, including the common DBLK header (MTF_DBLK_HDR)
================================================================================== */
typedef struct {    /* MTF_DBLK_TAPE */

     MTF_DBLK_HDR        sBlockHeader;
     UINT32              uTapeFamilyId;
     UINT32              uTapeAttributes;
     UINT16              uTapeSequenceNumber;
     UINT16              uPasswordEncryptionAlgorithm;
     UINT16              uSoftFilemarkBlockSize;         /* Or ECC Algorithm */
     UINT16              uTapeCatalogType;
     MTF_TAPE_ADDRESS    sTapeName;
     MTF_TAPE_ADDRESS    sTapeDescription;
     MTF_TAPE_ADDRESS    sTapePassword;
     MTF_TAPE_ADDRESS    sSoftware_name;
     UINT16              uAlignmentFactor;
     UINT16              uSoftwareVendorId;
     MTF_DATE_TIME       sTapeDate;
     UINT8               uMTFMajorVersion;

} MTF_DBLK_TAPE;



/* ==================================================================================
     Start of Set DBLK (SSET)
     - The SSET DBLK, exactly as it appears on tape, including the common DBLK header (MTF_DBLK_HDR)
================================================================================== */
typedef struct {
     MTF_DBLK_HDR        sBlockHeader;
     UINT32              uSSETAttributes;
     UINT16              uPasswordEncryptionAlgorithm;
     UINT16              uDataEncryptionAlgorithm;  /* Or Software Compression Algorithm      ***/
     UINT16              uSoftwareVendorId;
     UINT16              uDataSetNumber;
     MTF_TAPE_ADDRESS    sDataSetName;
     MTF_TAPE_ADDRESS    sDataSetDescription;
     MTF_TAPE_ADDRESS    sDataSetPassword;
     MTF_TAPE_ADDRESS    sUserName;
     UINT64              uPhysicalBlockAddress;
     MTF_DATE_TIME       sMediaWriteDate;
     UINT8               uSoftwareVerMjr;
     UINT8               uSoftwareVerMnr;
     UINT8               uTimeZone;
     UINT8               uMTFMinorVer;
     UINT8               uTapeCatalogVersion;
} MTF_DBLK_SSET;



/* ==================================================================================
     Volume DBLK (VOLB)
     - The VOLB DBLK, exactly as it appears on tape, including the common DBLK header (MTF_DBLK_HDR)
================================================================================== */
typedef struct {
     MTF_DBLK_HDR        sBlockHeader;
     UINT32              uVolumeAttributes;
     MTF_TAPE_ADDRESS    sDeviceName;
     MTF_TAPE_ADDRESS    sVolumeName;
     MTF_TAPE_ADDRESS    sMachineName;
     MTF_DATE_TIME       sMediaWriteDate;
} MTF_DBLK_VOLB;



/* ==================================================================================
     Directory DBLK (DIRB)
     - The DIRB DBLK, exactly as it appears on tape, including the common DBLK header (MTF_DBLK_HDR)
================================================================================== */
typedef struct {
     MTF_DBLK_HDR        sBlockHeader;
     UINT32              uDirectoryAttributes;
     MTF_DATE_TIME       sLastModificationDate;
     MTF_DATE_TIME       sCreationDate;
     MTF_DATE_TIME       sBackupDate;
     MTF_DATE_TIME       sLastAccessDate;
     UINT32              uDirectoryId;
     MTF_TAPE_ADDRESS    sDirectoryName;
} MTF_DBLK_DIRB;



/* ==================================================================================
     Directory DBLK (FILE)
     - The FILE DBLK, exactly as it appears on tape, including the common DBLK header (MTF_DBLK_HDR)
================================================================================== */
typedef struct {
     MTF_DBLK_HDR        sBlockHeader;
     UINT32              uFileAttributes;
     MTF_DATE_TIME       sLastModificationDate;
     MTF_DATE_TIME       sCreationDate;
     MTF_DATE_TIME       sBackupDate;
     MTF_DATE_TIME       sLastAccessDate;
     UINT32              uDirectoryId;
     UINT32              uFileId;
     MTF_TAPE_ADDRESS    sFileName;
} MTF_DBLK_FILE;


#pragma pack()

/* ==================================================================================
     Corrupt File DBLK (CFIL)
     - use MTF_DBLK_CFIL_INFO -- same structure
================================================================================== */
typedef MTF_DBLK_CFIL_INFO MTF_DBLK_CFIL;

/* ==================================================================================
     End of Set Pad Block (ESPB)
================================================================================== */
// consists only of header

/* ==================================================================================
     End of Set Block (ESET)
     - use MTF_DBLK_ESET_INFO -- same structure
================================================================================== */
typedef MTF_DBLK_ESET_INFO MTF_DBLK_ESET;

/* ==================================================================================
     End of Set Block (EOTM)
     - use MTF_DBLK_EOTM_INFO -- same structure
================================================================================== */
typedef MTF_DBLK_EOTM_INFO MTF_DBLK_EOTM;

/* ==================================================================================
     Soft Filemark (SFMB)
     - use MTF_DBLK_SFMB_INFO -- same structure
================================================================================== */
typedef MTF_DBLK_SFMB_INFO MTF_DBLK_SFMB;

/* ==================================================================================
     StreamHeader
     - use MTF_STREAM_INFO -- same structure
================================================================================== */
typedef MTF_STREAM_INFO MTF_STREAM;


/***********************************************************************************
************************************************************************************
************************************************************************************
****  MTF Misc Data Types
************************************************************************************
************************************************************************************
***********************************************************************************/
/* ==================================================================================
     Alignment Factor
================================================================================== */

/***********************************************************************************
* MTF_SetAlignmentFactor()                                 
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
void CMTFApi::MTF_SetAlignmentFactor(UINT16 uAF)
{
    // store the user's alignment factor in a private member
    m_uAlignmentFactor = uAF;
}




/***********************************************************************************
* MTF_GetAlignmentFactor()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
UINT16 CMTFApi::MTF_GetAlignmentFactor()
{
    return m_uAlignmentFactor;
}




/***********************************************************************************
* MTF_PadToNextAlignmentFactor()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
DWORD CMTFApi::MTF_PadToNextAlignmentFactor(
    BYTE     *pBuffer,    
    size_t    nBufUsed,
    size_t    nBufferSize, 
    size_t   *pnSizeUsed)
{
    size_t i;
    size_t nAlignment;
    MTF_STREAM_INFO sStream;
    
    // figure out what the next alignment value is and then pad out the user's buffer
    // with an SPAD, making sure the buffer is big enough

    nAlignment = Align(nBufUsed + sizeof(MTF_STREAM_INFO), MTF_GetAlignmentFactor());
    *pnSizeUsed = nAlignment;
    if (nBufferSize < nAlignment)
        return MTF_ERROR_BUFFER_TOO_SMALL;

    MTF_SetSTREAMDefaults(&sStream, "SPAD");
    
    sStream.uStreamLength = MTF_CreateUINT64(nAlignment - nBufUsed - sizeof(MTF_STREAM_INFO), 0);

    MTF_WriteStreamHeader(&sStream,
                          pBuffer + nBufUsed,
                          nBufferSize - nBufUsed,
                          0);

    for (i = nBufUsed + sizeof(MTF_STREAM_INFO); i < nAlignment; ++i)
        pBuffer[i] = 0;    

    return MTF_ERROR_NONE;
}     


/***********************************************************************************
* MTF_PadToNextPhysicalBlockBoundary() - (bmd)
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
DWORD CMTFApi::MTF_PadToNextPhysicalBlockBoundary(
    BYTE *pBuffer,
    size_t nBlockSize,
    size_t nBufUsed,
    size_t nBufferSize,
    size_t *pnSizeUsed)
{
    size_t i;
    size_t nAlignment;
    MTF_STREAM_INFO sStream;

    // figure out what the next alignment value is and then pad out the user's buffer
    // with an SPAD, making sure the buffer is big enough

    nAlignment = Align(nBufUsed + sizeof(MTF_STREAM_INFO), nBlockSize);
    *pnSizeUsed = nAlignment;
    if (nBufferSize < nAlignment)
        return MTF_ERROR_BUFFER_TOO_SMALL;

    MTF_SetSTREAMDefaults(&sStream, "SPAD");

    sStream.uStreamLength = MTF_CreateUINT64(nAlignment - nBufUsed - sizeof(MTF_STREAM_INFO), 0);

    MTF_WriteStreamHeader(&sStream, pBuffer + nBufUsed, nBufferSize - nBufUsed, 0);

    for (i = nBufUsed + sizeof(MTF_STREAM_INFO); i < nAlignment; ++i)
        pBuffer[i] = 0;

    return MTF_ERROR_NONE;
}


/***********************************************************************************
* MTF_CreateUINT64()
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
UINT64 CMTFApi::MTF_CreateUINT64(UINT32 uLSB, UINT32 uMSB)
{
    UINT64 uRet;

    uRet = (UINT64) uMSB << 32;
    uRet += uLSB;
    return uRet;
}


/* ==================================================================================
     Compressed date structure for storing dates in minimal space on tape:

     BYTE 0    BYTE 1    BYTE 2    BYTE 3    BYTE 4
    76543210  76543210  76543210  76543210  76543210
    yyyyyyyy  yyyyyymm  mmdddddh  hhhhmmmm  mmssssss
    33333333  33222222  22221111  11111100  00000000
    98765432  10987654  32109876  54321098  76543210
================================================================================== */

/***********************************************************************************
* MTF_CreateDateTime()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
MTF_DATE_TIME CMTFApi::MTF_CreateDateTime(
    int iYear, 
    int iMonth, 
    int iDay, 
    int iHour, 
    int iMinute,
    int iSecond
    )
{
    MTF_DATE_TIME sDateTime = {0};

     UINT16    temp ;


    // pack the date time structure with the arguments as per the diagram above
      temp = (UINT16)iYear << 2 ;
      sDateTime.dt_field[0] = ((UINT8 *)&temp)[1] ;
      sDateTime.dt_field[1] = ((UINT8 *)&temp)[0] ;
      
      temp = (UINT16)iMonth << 6 ;
      sDateTime.dt_field[1] |= ((UINT8 *)&temp)[1] ;
      sDateTime.dt_field[2] = ((UINT8 *)&temp)[0] ;
      
      temp = (UINT16)iDay << 1 ;
      sDateTime.dt_field[2] |= ((UINT8 *)&temp)[0] ;
      
      temp = (UINT16)iHour << 4 ;
      sDateTime.dt_field[2] |= ((UINT8 *)&temp)[1] ;
      sDateTime.dt_field[3] = ((UINT8 *)&temp)[0] ;
      
      temp = (UINT16)iMinute << 6 ;
      sDateTime.dt_field[3] |= ((UINT8 *)&temp)[1] ;
      sDateTime.dt_field[4] = ((UINT8 *)&temp)[0] ;
      
      temp = (UINT16)iSecond ;
      sDateTime.dt_field[4] |= ((UINT8 *)&temp)[0] ;

    return sDateTime;    
}





/***********************************************************************************
* MTF_CreateDateTimeFromTM()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
MTF_DATE_TIME CMTFApi::MTF_CreateDateTimeFromTM(
    struct tm *pT
    )
{
    // translate call to MTF_CreateDateTime
    return MTF_CreateDateTime(pT->tm_year + 1900, pT->tm_mon + 1, pT->tm_mday, pT->tm_hour, pT->tm_min, pT->tm_sec);
}





/***********************************************************************************
* MTF_CreateDateTimeToTM()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
void CMTFApi::MTF_CreateDateTimeToTM(
    MTF_DATE_TIME *pDT, 
    struct tm     *pT
    )
{
     UINT8     temp[2] ;

    // unpack the MTF_DATE_TIME structure and store the results
     temp[0] = pDT->dt_field[1] ;
     temp[1] = pDT->dt_field[0] ;
     pT->tm_year = *((UINT16 *)temp) >> 2 ;

     temp[0] = pDT->dt_field[2] ;
     temp[1] = pDT->dt_field[1] ;
     pT->tm_mon = (*((UINT16 *)temp) >> 6) & 0x000F ;

     pT->tm_mday = (*((UINT16 *)temp) >> 1) & 0x001F ;

     temp[0] = pDT->dt_field[3] ;
     temp[1] = pDT->dt_field[2] ;
     pT->tm_hour = (*((UINT16 *)temp) >> 4) & 0x001F ;

     temp[0] = pDT->dt_field[4] ;
     temp[1] = pDT->dt_field[3] ;
     pT->tm_min = (*((UINT16 *)temp) >> 6) & 0x003F ;

     pT->tm_sec = *((UINT16 *)temp) & 0x003F ;
}




/***********************************************************************************
* MTF_CreateDateNull()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
MTF_DATE_TIME CMTFApi::MTF_CreateDateNull()
{
    MTF_DATE_TIME sDateTime = {0};
    
    return sDateTime;    
}




/***********************************************************************************
* MTF_CreateDateTimeFromFileTime()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
MTF_DATE_TIME CMTFApi::MTF_CreateDateTimeFromFileTime(
    FILETIME sFileTime
    )
{
    SYSTEMTIME sSystemTime;
    FileTimeToSystemTime(&sFileTime, &sSystemTime);

    return MTF_CreateDateTime(sSystemTime.wYear, 
                              sSystemTime.wMonth, 
                              sSystemTime.wDay, 
                              sSystemTime.wHour, 
                              sSystemTime.wMinute, 
                              sSystemTime.wSecond);
}





/***********************************************************************************
************************************************************************************
****  MTF internal HELPER FUNCITONS
************************************************************************************
***********************************************************************************/

/***********************************************************************************
* StringToTapeAddress()
*
* Description:  Used by the MTF_Write#### functions below.  Given a Buffer, an 
*               MTF_TAPE_ADDRESS struct and the current end of the string storage 
*               area in the buffer, this function appends the string to the string
*               storage area, fills in the MTF_TAPE_ADDRESS struct indicating where
*               the string was stored and returns the new end of the string storage
*               area accounting for the added string.
***********************************************************************************/
size_t CMTFApi::StringToTapeAddress(
    MTF_TAPE_ADDRESS *pAd,                  // the mtf tape address structure to fill
    BYTE             *pBuffer,              // the buffer that is being filled
    wchar_t          *str,                  // the string to store MTF style in the buffer
    size_t           uCurrentStorageOffset  // the next available point in the buffer for string storage
    )
{
    // if we have a string, 
    //      - put the size and offset in the MTF_TAPE_ADDRESS structure and then copy 
    //        the string to the pBuffer at the uCurrentStorageOffset'th byte
    // otherwise
    //      - put a zero size and offset in the MTF_TAPE_ADDRESS struct.
    // return the new end of the string storage area
    
    if (str)
    {
        pAd->uSize   = (UINT16)wstrsize(str);
        pAd->uOffset = (UINT16)uCurrentStorageOffset;
        memcpy(pBuffer + uCurrentStorageOffset, str, pAd->uSize);
        uCurrentStorageOffset += pAd->uSize;
    }
    else
    {
        pAd->uSize   = 0;
        pAd->uOffset = 0;
    }
    
    return uCurrentStorageOffset;
}



/***********************************************************************************
* Align()
*
* Description:  Given uSize and an alignment factor, retuns the value
*               of the uSize+ pad, where pad is the value necesary to 
*               get to the next alignment factor.
*               
* Returns       uSize + pad -- not just pad!
***********************************************************************************/
size_t CMTFApi::Align(
    size_t uSize, 
    size_t uAlignment)
{
    if (uSize % uAlignment)    
        return uSize - (uSize  % uAlignment) + uAlignment;
    else
        return uSize;
}




/***********************************************************************************
* CalcChecksum()
*
* Description:  returns the 16bit XOR sum of the nNum bytes starting at the UINT16
*               pointed to by pStartPtr
*               
***********************************************************************************/
UINT16 CMTFApi::CalcChecksum(
     BYTE *      pStartPtr,
     int         nNum )
{
     UINT16 resultSoFar = 0;
     UINT16 UNALIGNED *pCur = (UINT16 *) pStartPtr;
     
     while( nNum-- ) 
          resultSoFar ^= *pCur++ ;

     return( resultSoFar ) ;
}




/***********************************************************************************
* CalcChecksumOfStreamData() - (bmd)
*
* Description:  returns the 32bit XOR sum of the nNum bytes starting at the UINT64
*               pointed to by pStartPtr
*               
***********************************************************************************/
UINT32 CMTFApi::CalcChecksumOfStreamData(
     BYTE *      pStartPtr,
     int         nNum )
{
     UINT32 resultSoFar = 0;
     UINT32 UNALIGNED *pCur = (UINT32 *) pStartPtr;
     
     while( nNum-- ) 
          resultSoFar ^= *pCur++ ;

     return( resultSoFar ) ;
}


     
/***********************************************************************************
************************************************************************************
************************************************************************************
****  MTF API STRUCTURE FUNCTIONS
************************************************************************************
************************************************************************************
***********************************************************************************/

/* ==================================================================================
=====================================================================================
     Common DBLK: MTF_DBLK_HDR_INFO
=====================================================================================
================================================================================== */

// Calculates the room that will be taken up in the DBLK by strings and OS specific data
size_t CMTFApi::MTF_DBLK_HDR_INFO_CalcAddDataSize(
    MTF_DBLK_HDR_INFO *pSTDInfo
    )
{
    return pSTDInfo->uOSDataSize;
}




/***********************************************************************************
* MTF_SetDblkHdrDefaults()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
void CMTFApi::MTF_SetDblkHdrDefaults(
    MTF_DBLK_HDR_INFO * pStdInfo
    )
{
    int i;
    for (i = 0; i < 5; ++i)
        pStdInfo->acBlockType[i] = 0;

    pStdInfo->uBlockAttributes      = 0;
    pStdInfo->uOSID                 = 0;
    pStdInfo->uOSVersion            = 0;
    pStdInfo->uDisplayableSize      = 0;
    pStdInfo->uFormatLogicalAddress = 0;
    pStdInfo->uReservedForMBC       = 0;
    pStdInfo->uSoftwareCompression  = MTF_COMPRESS_NONE;
    pStdInfo->uControlBlockId       = 0;
    pStdInfo->pvOSData              = 0;
    pStdInfo->uOSDataSize           = 0;
    pStdInfo->uStringType           = MTF_STRING_UNICODE_STR; 
}




/***********************************************************************************
* MTF_WriteDblkHdrToBuffer()
*
* Description:  called by the MTF_Write#####() functions to format the common block 
*               header to the buffer
*               - this also calculates the header check sum and fills it in
*
* Pre:  - *puCurrentStorageOffset is the offset at where string and OS Data storage will 
*         begin in the buffer
*       - the size of the buffer has been checked and can hold any info written to it
*
* Post: - *puCurrentStorageOffset is updated to reflect any added strings or storage
*               
***********************************************************************************/
void CMTFApi::MTF_WriteDblkHdrToBuffer(
    UINT8              acID[4],                 // four byte header id to write
    UINT16             uOffsetToFirstStream,    // the size of the DBLK for which this will be a header
    MTF_DBLK_HDR_INFO *psHdrInfo,               // the header info struct to use (filled in by client)
    BYTE              *pBuffer,                 // the buffer to format to
    size_t            *puCurrentStorage)        // the point in the buffer where string and os data stroage begins
                                                // (this will be updated upon return to reflect added data to storage)
{
    MTF_DBLK_HDR *pHDR = 0;
    UINT16 uCurrentStorageOffset = 0;
    int i;

    // - if no *puCurrentStorage, we assume storage starts at 
    //   the end of the on tape MTF_DBLK_HDR structure
    if (puCurrentStorage)
        uCurrentStorageOffset = (UINT16)*puCurrentStorage;
    else
        uCurrentStorageOffset = (UINT16)sizeof(MTF_DBLK_HDR);

    pHDR = (MTF_DBLK_HDR *) pBuffer;
    
    // write in the four byte DBLK ID
    for (i = 0; i < 4; ++i)
        pHDR->acBlockType[i] = acID[i];

    pHDR->uBlockAttributes      = psHdrInfo->uBlockAttributes;
    pHDR->uOffsetToFirstStream  = uOffsetToFirstStream;
    pHDR->uOSID                 = psHdrInfo->uOSID;
    pHDR->uOSVersion            = psHdrInfo->uOSVersion;
    pHDR->uDisplayableSize      = psHdrInfo->uDisplayableSize;
    pHDR->uFormatLogicalAddress = psHdrInfo->uFormatLogicalAddress;
    pHDR->uReservedForMBC       = 0; // must be zero in backup set
    pHDR->uSoftwareCompression  = psHdrInfo->uSoftwareCompression;
    pHDR->uControlBlockId       = psHdrInfo->uControlBlockId;
    pHDR->sOSSpecificData.uSize = psHdrInfo->uOSDataSize;

    // write out the os specific data at the current storage offset and update it
    if (psHdrInfo->uOSDataSize)
    {
        pHDR->sOSSpecificData.uOffset = uCurrentStorageOffset;
        memcpy(pBuffer + uCurrentStorageOffset, psHdrInfo->pvOSData, psHdrInfo->uOSDataSize);
        uCurrentStorageOffset = uCurrentStorageOffset + psHdrInfo->uOSDataSize;
    }
    else
    {
        pHDR->sOSSpecificData.uOffset = 0;
        pHDR->sOSSpecificData.uSize   = 0;
    }

    pHDR->uStringType = psHdrInfo->uStringType;
    
    pHDR->uHeaderCheckSum = CalcChecksum(pBuffer, sizeof(MTF_DBLK_HDR) / sizeof(UINT16) - 1);
    
    if (puCurrentStorage)
        *puCurrentStorage = uCurrentStorageOffset;
}




void CMTFApi::MTF_DBLK_HDR_INFO_ReadFromBuffer(
    MTF_DBLK_HDR_INFO *psHdrInfo, 
    BYTE              *pBuffer)
{
    MTF_DBLK_HDR *pHDR = 0;
    size_t uCurrentStorageOffset = 0;
    int i;

    pHDR = (MTF_DBLK_HDR *) pBuffer;
    
    for (i = 0; i < 4; ++i)
        psHdrInfo->acBlockType[i] = pHDR->acBlockType[i];
    
    psHdrInfo->acBlockType[4] = 0;

    psHdrInfo->uOffsetToFirstStream = pHDR->uOffsetToFirstStream;
    psHdrInfo->uBlockAttributes     = pHDR->uBlockAttributes ;
    psHdrInfo->uOSID                = pHDR->uOSID;
    psHdrInfo->uOSVersion           = pHDR->uOSVersion;
    psHdrInfo->uDisplayableSize     = pHDR->uDisplayableSize;
    psHdrInfo->uFormatLogicalAddress= pHDR->uFormatLogicalAddress;
    psHdrInfo->uSoftwareCompression = pHDR->uSoftwareCompression;
    psHdrInfo->uControlBlockId      = pHDR->uControlBlockId;
    psHdrInfo->uOSDataSize          = pHDR->sOSSpecificData.uSize;
    psHdrInfo->pvOSData             = (pBuffer + pHDR->sOSSpecificData.uOffset);
    psHdrInfo->uStringType          = pHDR->uStringType;
    psHdrInfo->uHeaderCheckSum      = pHDR->uHeaderCheckSum;
}




/* ==================================================================================
=====================================================================================
     TAPE DBLK: MTF_DBLK_TAPE_INFO
=====================================================================================
================================================================================== */
// Calculates the room that will be taken up in the DBLK by strings and OS specific data
// **NOT INCLUDING THE COMMON DBLK HEADER additional info **
size_t CMTFApi::MTF_DBLK_TAPE_INFO_CalcAddDataSize(
    MTF_DBLK_TAPE_INFO *pTapeInfo
    )
{
    return wstrsize(pTapeInfo->szTapeName) +
           wstrsize(pTapeInfo->szTapeDescription) +
           wstrsize(pTapeInfo->szTapePassword) +
           wstrsize(pTapeInfo->szSoftwareName);
}



/***********************************************************************************
* MTF_SetTAPEDefaults()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
void CMTFApi::MTF_SetTAPEDefaults(
    MTF_DBLK_TAPE_INFO *pTapeInfo
    )
{
    time_t tTime;
    time(&tTime);

    pTapeInfo->uTapeFamilyId                = 0;
    pTapeInfo->uTapeAttributes              = 0;
    pTapeInfo->uTapeSequenceNumber          = 0;
    pTapeInfo->uPasswordEncryptionAlgorithm = MTF_PW_ENCRYPT_NONE;
    pTapeInfo->uSoftFilemarkBlockSize       = 0;
    pTapeInfo->uTapeCatalogType             = MTF_OTC_NONE; // MTF_OTC_TYPE
    pTapeInfo->szTapeName                   = 0 ;
    pTapeInfo->szTapeDescription            = 0 ;
    pTapeInfo->szTapePassword               = 0;
    pTapeInfo->szSoftwareName               = 0;
    pTapeInfo->uAlignmentFactor             = MTF_GetAlignmentFactor();
    pTapeInfo->uSoftwareVendorId            = 0;
    pTapeInfo->sTapeDate                    = MTF_CreateDateTimeFromTM(gmtime(&tTime));
    pTapeInfo->uMTFMajorVersion             = MTF_FORMAT_VER_MAJOR;
}



/***********************************************************************************
* MTF_WriteTAPEDblk()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
DWORD CMTFApi::MTF_WriteTAPEDblk( MTF_DBLK_HDR_INFO  *psHdrInfo,
                         MTF_DBLK_TAPE_INFO *psTapeInfo,  
                         BYTE               *pBuffer,     
                         size_t              nBufferSize, 
                         size_t             *pnSizeUsed)  
{
    UINT16 uOffsetToFirstStream;
    
    //
    // Figure the size of the entire DBLK & make sure we have room
    //
    uOffsetToFirstStream = (UINT16) (sizeof(MTF_DBLK_TAPE) + 
                           MTF_DBLK_HDR_INFO_CalcAddDataSize(psHdrInfo) + 
                           MTF_DBLK_TAPE_INFO_CalcAddDataSize(psTapeInfo));

    uOffsetToFirstStream = (UINT16)Align(uOffsetToFirstStream, 4);

    if (nBufferSize < uOffsetToFirstStream)
    {
        if (pnSizeUsed)
            *pnSizeUsed = uOffsetToFirstStream;
        
        return MTF_ERROR_BUFFER_TOO_SMALL;                        
    }    

    memset(pBuffer, 0, uOffsetToFirstStream);
    
    
    // 
    // write the header and then fill in the stuff from this info struct
    //
    {
        MTF_DBLK_TAPE *pTape = 0;
        size_t uCurrentStorageOffset = 0;

        uCurrentStorageOffset = sizeof(MTF_DBLK_TAPE);

        MTF_WriteDblkHdrToBuffer(
            (UINT8 *)(char *)MTF_ID_TAPE, 
            uOffsetToFirstStream,
            psHdrInfo, 
            pBuffer, 
            &uCurrentStorageOffset);
        
        pTape = (MTF_DBLK_TAPE *) pBuffer;
    
        pTape->uTapeFamilyId                = psTapeInfo->uTapeFamilyId;
        pTape->uTapeAttributes              = psTapeInfo->uTapeAttributes;
        pTape->uTapeSequenceNumber          = psTapeInfo->uTapeSequenceNumber;
        pTape->uPasswordEncryptionAlgorithm = psTapeInfo->uPasswordEncryptionAlgorithm;
        pTape->uSoftFilemarkBlockSize       = psTapeInfo->uSoftFilemarkBlockSize;
        pTape->uTapeCatalogType             = psTapeInfo->uTapeCatalogType;

        uCurrentStorageOffset = StringToTapeAddress(&pTape->sTapeName, pBuffer, psTapeInfo->szTapeName, uCurrentStorageOffset);
        uCurrentStorageOffset = StringToTapeAddress(&pTape->sTapeDescription, pBuffer, psTapeInfo->szTapeDescription, uCurrentStorageOffset);
        uCurrentStorageOffset = StringToTapeAddress(&pTape->sTapePassword, pBuffer, psTapeInfo->szTapePassword, uCurrentStorageOffset);
        uCurrentStorageOffset = StringToTapeAddress(&pTape->sSoftware_name, pBuffer, psTapeInfo->szSoftwareName, uCurrentStorageOffset);

        pTape->uAlignmentFactor  = psTapeInfo->uAlignmentFactor;
        pTape->uSoftwareVendorId = psTapeInfo->uSoftwareVendorId;
        pTape->sTapeDate         = psTapeInfo->sTapeDate;
        pTape->uMTFMajorVersion  = psTapeInfo->uMTFMajorVersion;
      
        if (pnSizeUsed)
            *pnSizeUsed = uOffsetToFirstStream;
    }

    return MTF_ERROR_NONE;    
}






/***********************************************************************************
* MTF_ReadTAPEDblk()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
DWORD CMTFApi::MTF_ReadTAPEDblk(  MTF_DBLK_HDR_INFO  *psHdrInfo,
                         MTF_DBLK_TAPE_INFO *psTapeInfo,  
                         BYTE               *pBuffer)     
{
    MTF_DBLK_TAPE *pTape = 0;

    ClearStrings();
    MTF_DBLK_HDR_INFO_ReadFromBuffer(psHdrInfo, pBuffer);

    pTape = (MTF_DBLK_TAPE *) pBuffer;

    psTapeInfo->uTapeFamilyId                = pTape->uTapeFamilyId;
    psTapeInfo->uTapeAttributes              = pTape->uTapeAttributes;
    psTapeInfo->uTapeSequenceNumber          = pTape->uTapeSequenceNumber;
    psTapeInfo->uPasswordEncryptionAlgorithm = pTape->uPasswordEncryptionAlgorithm;
    psTapeInfo->uSoftFilemarkBlockSize       = pTape->uSoftFilemarkBlockSize;
    psTapeInfo->uTapeCatalogType             = pTape->uTapeCatalogType;

    psTapeInfo->uAlignmentFactor  = pTape->uAlignmentFactor;
    psTapeInfo->uSoftwareVendorId = pTape->uSoftwareVendorId;
    psTapeInfo->sTapeDate         = pTape->sTapeDate;
    psTapeInfo->uMTFMajorVersion  = pTape->uMTFMajorVersion;

    psTapeInfo->szTapeName        = MakeString((wchar_t UNALIGNED *) (pBuffer + pTape->sTapeName.uOffset), pTape->sTapeName.uSize);
    psTapeInfo->szTapeDescription = MakeString((wchar_t UNALIGNED *) (pBuffer + pTape->sTapeDescription.uOffset), pTape->sTapeDescription.uSize);
    psTapeInfo->szTapePassword    = MakeString((wchar_t UNALIGNED *) (pBuffer + pTape->sTapePassword.uOffset), pTape->sTapePassword.uSize);
    psTapeInfo->szSoftwareName    = MakeString((wchar_t UNALIGNED *) (pBuffer + pTape->sSoftware_name.uOffset), pTape->sSoftware_name.uSize);

    if ( !psTapeInfo->szTapeName || !psTapeInfo->szTapeDescription || !psTapeInfo->szTapePassword || !psTapeInfo->szSoftwareName)
        return MTF_OUT_OF_MEMORY;

    return MTF_ERROR_NONE;    
}



    
/* ==================================================================================
=====================================================================================
     SSET DBLK: MTF_DBLK_SSET_INFO
=====================================================================================
================================================================================== */

// Calculates the room that will be taken up in the DBLK by strings and OS specific data
// **NOT INCLUDING THE COMMON DBLK HEADER additional info **
size_t CMTFApi::MTF_DBLK_SSET_INFO_CalcAddDataSize(
    MTF_DBLK_SSET_INFO *pSSETInfo
    )
{
    return wstrsize(pSSETInfo->szDataSetName)         
           + wstrsize(pSSETInfo->szDataSetDescription)  
           + wstrsize(pSSETInfo->szDataSetPassword)     
           + wstrsize(pSSETInfo->szUserName);
}




/***********************************************************************************
* MTF_SetSSETDefaults()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
void CMTFApi::MTF_SetSSETDefaults(
    MTF_DBLK_SSET_INFO *pSSETInfo
    )
{
    time_t tTime;
    time(&tTime);

    pSSETInfo->uSSETAttributes              = 0;
    pSSETInfo->uPasswordEncryptionAlgorithm = MTF_PW_ENCRYPT_NONE;
    pSSETInfo->uDataEncryptionAlgorithm     = MTF_DATA_ENCRYPT_NONE;
    pSSETInfo->uSoftwareVendorId            = 0;
    pSSETInfo->uDataSetNumber               = 0;
    pSSETInfo->szDataSetName                = 0 ;
    pSSETInfo->szDataSetDescription         = 0 ;
    pSSETInfo->szDataSetPassword            = 0 ;
    pSSETInfo->szUserName                   = 0 ;
    pSSETInfo->uPhysicalBlockAddress        = 0;
    pSSETInfo->sMediaWriteDate              = MTF_CreateDateTimeFromTM(gmtime(&tTime));
    pSSETInfo->uSoftwareVerMjr              = 0;
    pSSETInfo->uSoftwareVerMnr              = 0;
    pSSETInfo->uTimeZone                    = MTF_LOCAL_TZ;
    pSSETInfo->uMTFMinorVer                 = MTF_FORMAT_VER_MINOR;
    pSSETInfo->uTapeCatalogVersion          = MTF_OTC_NONE;  // MTF_OTC_VERSION
}




/***********************************************************************************
* MTF_WriteSSETDblk()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
DWORD CMTFApi::MTF_WriteSSETDblk( MTF_DBLK_HDR_INFO  *psHdrInfo,
                         MTF_DBLK_SSET_INFO *psSSETInfo,  
                         BYTE               *pBuffer,     
                         size_t              nBufferSize, 
                         size_t             *pnSizeUsed)  
{
    UINT16 uOffsetToFirstStream;
    
    //
    // Figure the size of the entire DBLK & make sure we have room
    //
    uOffsetToFirstStream = (UINT16) (sizeof(MTF_DBLK_SSET) +
                           MTF_DBLK_HDR_INFO_CalcAddDataSize(psHdrInfo) +
                           MTF_DBLK_SSET_INFO_CalcAddDataSize(psSSETInfo));

    uOffsetToFirstStream = (UINT16)Align(uOffsetToFirstStream, 4);

    if (nBufferSize < uOffsetToFirstStream)
    {
        if (pnSizeUsed)
            *pnSizeUsed = uOffsetToFirstStream;
        
        return MTF_ERROR_BUFFER_TOO_SMALL;                        
    }    

    memset(pBuffer, 0, uOffsetToFirstStream);
    
    {
        MTF_DBLK_SSET *psSSET = 0;
        size_t uCurrentStorageOffset = 0;

        uCurrentStorageOffset = sizeof(MTF_DBLK_SSET);

        MTF_WriteDblkHdrToBuffer(
            (UINT8 *)(char *)MTF_ID_SSET, 
            uOffsetToFirstStream,
            psHdrInfo, 
            pBuffer, 
            &uCurrentStorageOffset);
        
        psSSET = (MTF_DBLK_SSET *) pBuffer;

        psSSET->uSSETAttributes              = psSSETInfo->uSSETAttributes;
        psSSET->uPasswordEncryptionAlgorithm = psSSETInfo->uPasswordEncryptionAlgorithm;
        psSSET->uDataEncryptionAlgorithm     = psSSETInfo->uDataEncryptionAlgorithm;
        psSSET->uSoftwareVendorId            = psSSETInfo->uSoftwareVendorId;
        psSSET->uDataSetNumber               = psSSETInfo->uDataSetNumber;

        uCurrentStorageOffset = StringToTapeAddress(&psSSET->sDataSetName, pBuffer, psSSETInfo->szDataSetName, uCurrentStorageOffset);
        uCurrentStorageOffset = StringToTapeAddress(&psSSET->sDataSetDescription, pBuffer, psSSETInfo->szDataSetDescription, uCurrentStorageOffset);
        uCurrentStorageOffset = StringToTapeAddress(&psSSET->sDataSetPassword, pBuffer, psSSETInfo->szDataSetPassword, uCurrentStorageOffset);
        uCurrentStorageOffset = StringToTapeAddress(&psSSET->sUserName, pBuffer, psSSETInfo->szUserName, uCurrentStorageOffset);

        psSSET->uPhysicalBlockAddress = psSSETInfo->uPhysicalBlockAddress;
        psSSET->sMediaWriteDate       = psSSETInfo->sMediaWriteDate;
        psSSET->uSoftwareVerMjr       = psSSETInfo->uSoftwareVerMjr;
        psSSET->uSoftwareVerMnr       = psSSETInfo->uSoftwareVerMnr;
        psSSET->uTimeZone             = psSSETInfo->uTimeZone;
        psSSET->uMTFMinorVer          = psSSETInfo->uMTFMinorVer;
        psSSET->uTapeCatalogVersion   = psSSETInfo->uTapeCatalogVersion;

        if (pnSizeUsed)
            *pnSizeUsed = uOffsetToFirstStream;
    }

    return MTF_ERROR_NONE;    
}




/***********************************************************************************
* MTF_ReadSSETDblk()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
DWORD CMTFApi::MTF_ReadSSETDblk(  MTF_DBLK_HDR_INFO  *psHdrInfo,
                         MTF_DBLK_SSET_INFO *psSSETInfo,  
                         BYTE               *pBuffer)     
{
    MTF_DBLK_SSET *psSSET = 0;

    ClearStrings();
    MTF_DBLK_HDR_INFO_ReadFromBuffer(psHdrInfo, pBuffer);

    psSSET = (MTF_DBLK_SSET *) pBuffer;

    psSSETInfo->uSSETAttributes              = psSSET->uSSETAttributes;
    psSSETInfo->uPasswordEncryptionAlgorithm = psSSET->uPasswordEncryptionAlgorithm;
    psSSETInfo->uDataEncryptionAlgorithm     = psSSET->uDataEncryptionAlgorithm;
    psSSETInfo->uSoftwareVendorId            = psSSET->uSoftwareVendorId;
    psSSETInfo->uDataSetNumber               = psSSET->uDataSetNumber;

    psSSETInfo->uPhysicalBlockAddress   = psSSET->uPhysicalBlockAddress;
    psSSETInfo->sMediaWriteDate         = psSSET->sMediaWriteDate;
    psSSETInfo->uSoftwareVerMjr         = psSSET->uSoftwareVerMjr;
    psSSETInfo->uSoftwareVerMnr         = psSSET->uSoftwareVerMnr;
    psSSETInfo->uTimeZone               = psSSET->uTimeZone;
    psSSETInfo->uMTFMinorVer            = psSSET->uMTFMinorVer;
    psSSETInfo->uTapeCatalogVersion     = psSSET->uTapeCatalogVersion;

    psSSETInfo->szDataSetName = MakeString((wchar_t UNALIGNED *) (pBuffer + psSSET->sDataSetName.uOffset), psSSET->sDataSetName.uSize);
    psSSETInfo->szDataSetDescription = MakeString((wchar_t UNALIGNED *) (pBuffer + psSSET->sDataSetDescription.uOffset), psSSET->sDataSetDescription.uSize);
    psSSETInfo->szDataSetPassword = MakeString((wchar_t UNALIGNED *) (pBuffer + psSSET->sDataSetPassword.uOffset), psSSET->sDataSetPassword.uSize);
    psSSETInfo->szUserName = MakeString((wchar_t UNALIGNED *) (pBuffer + psSSET->sUserName.uOffset), psSSET->sUserName.uSize);

    if ( !psSSETInfo->szDataSetName || !psSSETInfo->szDataSetDescription || !psSSETInfo->szDataSetPassword || !psSSETInfo->szUserName )
        return MTF_OUT_OF_MEMORY;

    return MTF_ERROR_NONE;    
}




/* ==================================================================================
=====================================================================================
     VOLB DBLK: MTF_DBLK_VOLB_INFO
=====================================================================================
================================================================================== */

// Calculates the room that will be taken up in the DBLK by strings and OS specific data
// **NOT INCLUDING THE COMMON DBLK HEADER additional info **
size_t CMTFApi::MTF_DBLK_VOLB_INFO_CalcAddDataSize(
    MTF_DBLK_VOLB_INFO *pVOLBInfo
    )
{
    return wstrsize(pVOLBInfo->szDeviceName) +
           wstrsize(pVOLBInfo->szVolumeName) +
           wstrsize(pVOLBInfo->szMachineName);
}




/***********************************************************************************
* MTF_SetVOLBDefaults()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
void CMTFApi::MTF_SetVOLBDefaults(MTF_DBLK_VOLB_INFO *pVOLBInfo)
{
    time_t tTime;
    time(&tTime);

    pVOLBInfo->uVolumeAttributes = 0;
    pVOLBInfo->szDeviceName      = 0 ;
    pVOLBInfo->szVolumeName      = 0 ;
    pVOLBInfo->szMachineName     = 0 ;
    pVOLBInfo->sMediaWriteDate   = MTF_CreateDateTimeFromTM(gmtime(&tTime));;
}




/***********************************************************************************
* MTF_SetVOLBForDevice()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
void CMTFApi::MTF_SetVOLBForDevice(MTF_DBLK_VOLB_INFO *pVOLBInfo, wchar_t *szDevice)
{
    DWORD dwBufSize = MAX_COMPUTERNAME_LENGTH + 1;
    wchar_t tempDeviceName[MTF_STRLEN+4];

    wcscpy(m_szDeviceName, szDevice);
    MTF_SetVOLBDefaults(pVOLBInfo);  // initialize

    // Determine the format and set the appropriate bit in the VOLB attributes.
    if (*(m_szDeviceName+1) == L':') {
        // drive letter w/colon format
        pVOLBInfo->uVolumeAttributes |= MTF_VOLB_DEV_DRIVE;
    }
    else if (0 == wcsncmp( m_szDeviceName, L"UNC", 3 )) {
        // UNC format
        pVOLBInfo->uVolumeAttributes |= MTF_VOLB_DEV_UNC;
    }
    else {
        // operating system specific format
        pVOLBInfo->uVolumeAttributes |= MTF_VOLB_DEV_OS_SPEC;
    }

    // need to prepend \\?\ for the GetVolumeInformation call
    wcscpy(tempDeviceName, L"\\\\?\\");
    wcscat(tempDeviceName, m_szDeviceName);

    GetVolumeInformationW(tempDeviceName, m_szVolumeName, MTF_STRLEN, 0, 0, 0, 0, 0);
    GetComputerNameW(m_szMachineName, &dwBufSize);
    
    pVOLBInfo->szDeviceName         = m_szDeviceName;
    pVOLBInfo->szVolumeName         = m_szVolumeName;
    pVOLBInfo->szMachineName        = m_szMachineName;
}




/***********************************************************************************
* MTF_WriteVOLBDblk()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
DWORD CMTFApi::MTF_WriteVOLBDblk( MTF_DBLK_HDR_INFO  *psHdrInfo,
                         MTF_DBLK_VOLB_INFO *psVOLBInfo,  
                         BYTE               *pBuffer,     
                         size_t              nBufferSize, 
                         size_t             *pnSizeUsed)  
{
    UINT16 uOffsetToFirstStream;
    
    //
    // Figure the size of the entire DBLK & make sure we have room
    //
    uOffsetToFirstStream = (UINT16) (sizeof(MTF_DBLK_VOLB) + 
                           MTF_DBLK_HDR_INFO_CalcAddDataSize(psHdrInfo) + 
                           MTF_DBLK_VOLB_INFO_CalcAddDataSize(psVOLBInfo));


    uOffsetToFirstStream = (UINT16)Align(uOffsetToFirstStream, 4);

    if (nBufferSize < uOffsetToFirstStream)
    {
        if (pnSizeUsed)
            *pnSizeUsed = uOffsetToFirstStream;
        
        return MTF_ERROR_BUFFER_TOO_SMALL;
    }

    memset(pBuffer, 0, uOffsetToFirstStream);
    
    {
        MTF_DBLK_VOLB *psVOLB = 0;
        size_t uCurrentStorageOffset = 0;

        uCurrentStorageOffset = sizeof(MTF_DBLK_VOLB);

        MTF_WriteDblkHdrToBuffer(
            (UINT8 *)(char *)MTF_ID_VOLB, 
            uOffsetToFirstStream,
            psHdrInfo, 
            pBuffer, 
            &uCurrentStorageOffset);
        
        psVOLB = (MTF_DBLK_VOLB *) pBuffer;

        psVOLB->uVolumeAttributes = psVOLBInfo->uVolumeAttributes;

        uCurrentStorageOffset = StringToTapeAddress(&psVOLB->sDeviceName, pBuffer, psVOLBInfo->szDeviceName, uCurrentStorageOffset);
        uCurrentStorageOffset = StringToTapeAddress(&psVOLB->sVolumeName, pBuffer, psVOLBInfo->szVolumeName, uCurrentStorageOffset);
        uCurrentStorageOffset = StringToTapeAddress(&psVOLB->sMachineName, pBuffer, psVOLBInfo->szMachineName, uCurrentStorageOffset);

        psVOLB->sMediaWriteDate = psVOLBInfo->sMediaWriteDate;

        if (pnSizeUsed)
            *pnSizeUsed = uOffsetToFirstStream;
    }

    return MTF_ERROR_NONE;    
}





/***********************************************************************************
* MTF_ReadVOLBDblk()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
DWORD CMTFApi::MTF_ReadVOLBDblk(  MTF_DBLK_HDR_INFO  *psHdrInfo,
                         MTF_DBLK_VOLB_INFO *psVOLBInfo,  
                         BYTE               *pBuffer)     
{
    MTF_DBLK_VOLB *psVOLB = 0;

    ClearStrings();
    MTF_DBLK_HDR_INFO_ReadFromBuffer(psHdrInfo, pBuffer);

    psVOLB = (MTF_DBLK_VOLB *) pBuffer;

    psVOLBInfo->uVolumeAttributes = psVOLB->uVolumeAttributes;

    psVOLBInfo->sMediaWriteDate = psVOLB->sMediaWriteDate;

    psVOLBInfo->szDeviceName  = MakeString((wchar_t UNALIGNED *) (pBuffer + psVOLB->sDeviceName.uOffset), psVOLB->sDeviceName.uSize);
    psVOLBInfo->szVolumeName  = MakeString((wchar_t UNALIGNED *) (pBuffer + psVOLB->sVolumeName.uOffset), psVOLB->sVolumeName.uSize);
    psVOLBInfo->szMachineName = MakeString((wchar_t UNALIGNED *) (pBuffer + psVOLB->sMachineName.uOffset), psVOLB->sMachineName.uSize);

    if ( !psVOLBInfo->szDeviceName || !psVOLBInfo->szVolumeName || !psVOLBInfo->szMachineName )
        return MTF_OUT_OF_MEMORY;

    return MTF_ERROR_NONE;    
}



/* ==================================================================================
=====================================================================================
     DIRB DBLK: MTF_DBLK_DIRB_INFO
=====================================================================================
================================================================================== */

// Calculates the room that will be taken up in the DBLK by strings and OS specific data
// **NOT INCLUDING THE COMMON DBLK HEADER additional info **
size_t CMTFApi::MTF_DBLK_DIRB_INFO_CalcAddDataSize(MTF_DBLK_DIRB_INFO *pDIRBInfo)
{
    return wstrsize(pDIRBInfo->szDirectoryName);
}




/***********************************************************************************
* MTF_SetDIRBDefaults()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
void CMTFApi::MTF_SetDIRBDefaults(
    MTF_DBLK_DIRB_INFO *pDIRBInfo
    )
{
    pDIRBInfo->uDirectoryAttributes  = 0;
    pDIRBInfo->sLastModificationDate = MTF_CreateDateNull();
    pDIRBInfo->sCreationDate         = MTF_CreateDateNull();
    pDIRBInfo->sBackupDate           = MTF_CreateDateNull();
    pDIRBInfo->sLastAccessDate       = MTF_CreateDateNull();
    pDIRBInfo->uDirectoryId          = 0;
    pDIRBInfo->szDirectoryName       = 0 ;
}




/***********************************************************************************
* MTF_SetDIRBFromFindData()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
void CMTFApi::MTF_SetDIRBFromFindData(
    MTF_DBLK_DIRB_INFO *pDIRBInfo, 
    wchar_t            *szDirectoryName, 
    WIN32_FIND_DATAW   *pFindData
    )
{
    MTF_SetDIRBDefaults(pDIRBInfo); // initialize

    if ( wcslen( szDirectoryName ) < MTF_STRLEN ) {
        wcscpy(m_szDirectoryName, szDirectoryName);
        pDIRBInfo->szDirectoryName  = m_szDirectoryName;
    }
    else {
        pDIRBInfo->uDirectoryAttributes |= MTF_DIRB_PATH_IN_STREAM;
        pDIRBInfo->szDirectoryName  = 0;
    }

    if (pFindData)
    {
        pDIRBInfo->uDirectoryAttributes |= 
            pFindData->dwFileAttributes & FILE_ATTRIBUTE_READONLY ? MTF_DIRB_READ_ONLY : 0 
            | pFindData->dwFileAttributes & FILE_ATTRIBUTE_HIDDEN  ? MTF_DIRB_HIDDEN : 0 
            | pFindData->dwFileAttributes & FILE_ATTRIBUTE_SYSTEM  ? MTF_DIRB_SYSTEM : 0 
            | pFindData->dwFileAttributes & FILE_ATTRIBUTE_ARCHIVE ? MTF_DIRB_MODIFIED : 0; 
    
        pDIRBInfo->sLastModificationDate = MTF_CreateDateTimeFromFileTime(pFindData->ftLastWriteTime);
        pDIRBInfo->sCreationDate         = MTF_CreateDateTimeFromFileTime(pFindData->ftCreationTime);
        pDIRBInfo->sLastAccessDate       = MTF_CreateDateTimeFromFileTime(pFindData->ftLastAccessTime);
    }

    pDIRBInfo->uDirectoryId     = 0;
}


/***********************************************************************************
* MTF_WriteDIRBDblk()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
DWORD CMTFApi::MTF_WriteDIRBDblk( MTF_DBLK_HDR_INFO  *psHdrInfo,
                         MTF_DBLK_DIRB_INFO *psDIRBInfo,  
                         BYTE               *pBuffer,     
                         size_t              nBufferSize, 
                         size_t             *pnSizeUsed)  
{
    UINT16 uOffsetToFirstStream;

    //
    // Figure the size of the entire DBLK & make sure we have room
    //
    uOffsetToFirstStream = (UINT16) (sizeof(MTF_DBLK_DIRB) + 
                           MTF_DBLK_HDR_INFO_CalcAddDataSize(psHdrInfo) + 
                           MTF_DBLK_DIRB_INFO_CalcAddDataSize(psDIRBInfo));

    uOffsetToFirstStream = (UINT16)Align(uOffsetToFirstStream, 4);

    if (nBufferSize < uOffsetToFirstStream)
    {
        if (pnSizeUsed)
            *pnSizeUsed = uOffsetToFirstStream;
        
        return MTF_ERROR_BUFFER_TOO_SMALL;                        
    }    

    memset(pBuffer, 0, uOffsetToFirstStream);
    
    {
        MTF_DBLK_DIRB *psDIRB = 0;
        size_t uCurrentStorageOffset = 0;

        uCurrentStorageOffset = sizeof(MTF_DBLK_DIRB);

        MTF_WriteDblkHdrToBuffer(
            (UINT8 *)(char *)MTF_ID_DIRB, 
            uOffsetToFirstStream,
            psHdrInfo, 
            pBuffer, 
            &uCurrentStorageOffset);
        
        psDIRB = (MTF_DBLK_DIRB *) pBuffer;

        psDIRB->uDirectoryAttributes  = psDIRBInfo->uDirectoryAttributes;
        psDIRB->sLastModificationDate = psDIRBInfo->sLastModificationDate;
        psDIRB->sCreationDate         = psDIRBInfo->sCreationDate;
        psDIRB->sBackupDate           = psDIRBInfo->sBackupDate;
        psDIRB->sLastAccessDate       = psDIRBInfo->sLastAccessDate;
        psDIRB->uDirectoryId          = psDIRBInfo->uDirectoryId;
                              
        //
        // here, we need to turn the slashes (L'\\') to zeros (L'\0')in the directory name string... 
        // 
        {
            int i, iLen;
            wchar_t UNALIGNED *szDirectoryName = (wchar_t UNALIGNED *) (pBuffer + uCurrentStorageOffset);

            uCurrentStorageOffset = StringToTapeAddress(&psDIRB->sDirectoryName, pBuffer, psDIRBInfo->szDirectoryName, uCurrentStorageOffset);
            iLen = wstrsize(psDIRBInfo->szDirectoryName);
            for (i = 0; i < iLen; ++i)
                if (szDirectoryName[i] == L'\\')
                    szDirectoryName[i] = L'\0';
        }
        if (pnSizeUsed)
            *pnSizeUsed = uOffsetToFirstStream;
    }

    return MTF_ERROR_NONE;    
}





/***********************************************************************************
* MTF_ReadDIRBDblk()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
DWORD CMTFApi::MTF_ReadDIRBDblk(  MTF_DBLK_HDR_INFO  *psHdrInfo,
                         MTF_DBLK_DIRB_INFO *psDIRBInfo,  
                         BYTE               *pBuffer)     
{
    MTF_DBLK_DIRB *psDIRB = 0;

    ClearStrings();
    MTF_DBLK_HDR_INFO_ReadFromBuffer(psHdrInfo, pBuffer);

    psDIRB = (MTF_DBLK_DIRB *) pBuffer;

    psDIRBInfo->uDirectoryAttributes  = psDIRB->uDirectoryAttributes;
    psDIRBInfo->sLastModificationDate = psDIRB->sLastModificationDate;
    psDIRBInfo->sCreationDate         = psDIRB->sCreationDate;
    psDIRBInfo->sBackupDate           = psDIRB->sBackupDate;
    psDIRBInfo->sLastAccessDate       = psDIRB->sLastAccessDate;
    psDIRBInfo->uDirectoryId          = psDIRB->uDirectoryId;

    psDIRBInfo->szDirectoryName = NULL;

    // 
    // we need to turn the zeros in the directory name back to slashes
    // (there are no terminating \0's in the string -- all \0's are really \\'s
    // 
    {
        wchar_t *pTmpBuffer;   
        int i;
        pTmpBuffer = (wchar_t *) malloc(psDIRB->sDirectoryName.uSize);

        if (pTmpBuffer) {

            memmove(pTmpBuffer, pBuffer + psDIRB->sDirectoryName.uOffset, psDIRB->sDirectoryName.uSize);
            for (i = 0; i < psDIRB->sDirectoryName.uSize; ++i)
                if (pTmpBuffer[i] == L'\0')
                    pTmpBuffer[i] = L'\\';
    
            psDIRBInfo->szDirectoryName = MakeString(pTmpBuffer, psDIRB->sDirectoryName.uSize);
            free(pTmpBuffer);

        }

    }

    if ( !psDIRBInfo->szDirectoryName )
        return MTF_OUT_OF_MEMORY;

    return MTF_ERROR_NONE;    
}





/* ==================================================================================
=====================================================================================
     FILE DBLK: MTF_DBLK_FILE_INFO
=====================================================================================
================================================================================== */

// Calculates the room that will be taken up in the DBLK by strings and OS specific data
// **NOT INCLUDING THE COMMON DBLK HEADER additional info **
size_t CMTFApi::MTF_DBLK_FILE_INFO_CalcAddDataSize(MTF_DBLK_FILE_INFO *pFILEInfo)
{
    return wstrsize(pFILEInfo->szFileName);
}




/***********************************************************************************
* MTF_SetFILEDefaults()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
void CMTFApi::MTF_SetFILEDefaults(MTF_DBLK_FILE_INFO *pFILEInfo)
{
    pFILEInfo->uFileAttributes       = 0;
    pFILEInfo->sLastModificationDate = MTF_CreateDateNull();
    pFILEInfo->sCreationDate         = MTF_CreateDateNull();
    pFILEInfo->sBackupDate           = MTF_CreateDateNull();
    pFILEInfo->sLastAccessDate       = MTF_CreateDateNull();
    pFILEInfo->uDirectoryId          = 0;
    pFILEInfo->uFileId               = 0;
    pFILEInfo->szFileName            = 0;
}





/***********************************************************************************
* MTF_SetFILEFromFindData()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
void CMTFApi::MTF_SetFILEFromFindData(MTF_DBLK_FILE_INFO *pFILEInfo, WIN32_FIND_DATAW *pFindData)
{
    time_t tTime;
    time(&tTime);

    MTF_SetFILEDefaults(pFILEInfo);  // initialize

    wcscpy(m_szFileName, pFindData->cFileName);

    pFILEInfo->uFileAttributes = 
        (pFindData->dwFileAttributes & FILE_ATTRIBUTE_READONLY ? MTF_FILE_READ_ONLY : 0) 
      | (pFindData->dwFileAttributes & FILE_ATTRIBUTE_HIDDEN  ? MTF_FILE_HIDDEN : 0) 
      | (pFindData->dwFileAttributes & FILE_ATTRIBUTE_SYSTEM  ? MTF_FILE_SYSTEM : 0)
      | (pFindData->dwFileAttributes & FILE_ATTRIBUTE_ARCHIVE ? MTF_FILE_MODIFIED : 0) ;
    
    pFILEInfo->sLastModificationDate = MTF_CreateDateTimeFromFileTime(pFindData->ftLastWriteTime);
    pFILEInfo->sCreationDate         = MTF_CreateDateTimeFromFileTime(pFindData->ftCreationTime);
    pFILEInfo->sLastAccessDate       = MTF_CreateDateTimeFromFileTime(pFindData->ftLastAccessTime);
    pFILEInfo->uDirectoryId          = 0;
    pFILEInfo->uFileId               = 0;
    pFILEInfo->szFileName            = m_szFileName;

    pFILEInfo->uDisplaySize          = MTF_CreateUINT64(pFindData->nFileSizeLow, pFindData->nFileSizeHigh);

}





/***********************************************************************************
* MTF_WriteFILEDblk()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
DWORD CMTFApi::MTF_WriteFILEDblk( MTF_DBLK_HDR_INFO  *psHdrInfo,
                         MTF_DBLK_FILE_INFO *psFILEInfo,  
                         BYTE               *pBuffer,     
                         size_t              nBufferSize, 
                         size_t             *pnSizeUsed)  
{
    UINT16 uOffsetToFirstStream;
    
    //
    // Figure the size of the entire DBLK & make sure we have room
    //
    uOffsetToFirstStream = (UINT16) (sizeof(MTF_DBLK_FILE) + 
                           MTF_DBLK_HDR_INFO_CalcAddDataSize(psHdrInfo) + 
                           MTF_DBLK_FILE_INFO_CalcAddDataSize(psFILEInfo));

    uOffsetToFirstStream = (UINT16)Align(uOffsetToFirstStream, 4);
    if (nBufferSize < uOffsetToFirstStream)
    {
        if (pnSizeUsed)
            *pnSizeUsed = uOffsetToFirstStream;
        
        return MTF_ERROR_BUFFER_TOO_SMALL;                        
    }    

    memset(pBuffer, 0, uOffsetToFirstStream);
    
    {
        MTF_DBLK_FILE *psFILE = 0;
        size_t uCurrentStorageOffset = 0;

        uCurrentStorageOffset = sizeof(MTF_DBLK_FILE);
        psHdrInfo->uDisplayableSize = psFILEInfo->uDisplaySize;

        MTF_WriteDblkHdrToBuffer(
            (UINT8 *)(char *)MTF_ID_FILE, 
            uOffsetToFirstStream,
            psHdrInfo, 
            pBuffer, 
            &uCurrentStorageOffset);
        
        psFILE = (MTF_DBLK_FILE *) pBuffer;

        psFILE->uFileAttributes         = psFILEInfo->uFileAttributes;
        psFILE->sLastModificationDate   = psFILEInfo->sLastModificationDate;
        psFILE->sCreationDate           = psFILEInfo->sCreationDate;
        psFILE->sBackupDate             = psFILEInfo->sBackupDate;
        psFILE->sLastAccessDate         = psFILEInfo->sLastAccessDate;
        psFILE->uDirectoryId            = psFILEInfo->uDirectoryId;
        psFILE->uFileId                 = psFILEInfo->uFileId;

        uCurrentStorageOffset = StringToTapeAddress(&psFILE->sFileName, pBuffer, psFILEInfo->szFileName, uCurrentStorageOffset);

        if (pnSizeUsed)
            *pnSizeUsed = uOffsetToFirstStream;
    }

    return MTF_ERROR_NONE;    
}





/***********************************************************************************
* MTF_ReadFILEDblk()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
DWORD CMTFApi::MTF_ReadFILEDblk(  MTF_DBLK_HDR_INFO  *psHdrInfo,
                         MTF_DBLK_FILE_INFO *psFILEInfo,  
                         BYTE               *pBuffer)     
{
    MTF_DBLK_FILE *psFILE = 0;

    ClearStrings();
    MTF_DBLK_HDR_INFO_ReadFromBuffer(psHdrInfo, pBuffer);

    psFILE = (MTF_DBLK_FILE *) pBuffer;

    psFILEInfo->uFileAttributes         = psFILE->uFileAttributes;
    psFILEInfo->sLastModificationDate   = psFILE->sLastModificationDate;
    psFILEInfo->sCreationDate           = psFILE->sCreationDate;
    psFILEInfo->sBackupDate             = psFILE->sBackupDate;
    psFILEInfo->sLastAccessDate         = psFILE->sLastAccessDate;
    psFILEInfo->uDirectoryId            = psFILE->uDirectoryId;
    psFILEInfo->uFileId                 = psFILE->uFileId;

    psFILEInfo->szFileName              = MakeString((wchar_t UNALIGNED *) (pBuffer + psFILE->sFileName.uOffset), psFILE->sFileName.uSize);

    if ( !psFILEInfo->szFileName )
        return MTF_OUT_OF_MEMORY;

    return MTF_ERROR_NONE;    
}




/* ==================================================================================
=====================================================================================
     CFIL DBLK: MTF_DBLK_CFIL_INFO
=====================================================================================
================================================================================== */

/***********************************************************************************
* MTF_SetCFILDefaults()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
void CMTFApi::MTF_SetCFILDefaults(
    MTF_DBLK_CFIL_INFO *pCFILInfo
    )
{
    pCFILInfo->uCFileAttributes     = MTF_CFIL_UNREADABLE_BLK;
    pCFILInfo->uDirectoryId         = 0;
    pCFILInfo->uFileId              = 0;
    pCFILInfo->uStreamOffset        = 0;
    pCFILInfo->uCorruptStreamNumber = 0;
}




/***********************************************************************************
* MTF_WriteCFILDblk()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
DWORD CMTFApi::MTF_WriteCFILDblk( MTF_DBLK_HDR_INFO  *psHdrInfo,
                         MTF_DBLK_CFIL_INFO *psCFILInfo,  
                         BYTE               *pBuffer,     
                         size_t              nBufferSize, 
                         size_t             *pnSizeUsed)  
{
    UINT16 uOffsetToFirstStream;


    
    //
    // Figure the size of the entire DBLK & make sure we have room
    //
    uOffsetToFirstStream = (UINT16) (sizeof(MTF_DBLK_HDR) + 
                           sizeof(MTF_DBLK_CFIL) +
                           MTF_DBLK_HDR_INFO_CalcAddDataSize(psHdrInfo));

    uOffsetToFirstStream = (UINT16)Align(uOffsetToFirstStream, 4);

    if (nBufferSize < uOffsetToFirstStream)
    {
        if (pnSizeUsed)
            *pnSizeUsed = uOffsetToFirstStream;
        
        return MTF_ERROR_BUFFER_TOO_SMALL;                        
    }    

    memset(pBuffer, 0, uOffsetToFirstStream);
    
    {
        MTF_DBLK_CFIL_INFO *psCFIL = 0;
        size_t uCurrentStorageOffset = 0;

        uCurrentStorageOffset = sizeof(MTF_DBLK_HDR) + sizeof(MTF_DBLK_CFIL);

        MTF_WriteDblkHdrToBuffer(
            (UINT8 *)(char *)MTF_ID_CFIL, 
            uOffsetToFirstStream,
            psHdrInfo, 
            pBuffer, 
            &uCurrentStorageOffset);
        
        psCFIL = (MTF_DBLK_CFIL_INFO *)  (pBuffer + sizeof(MTF_DBLK_HDR));

        *psCFIL = *psCFILInfo;

        if (pnSizeUsed)
            *pnSizeUsed = uOffsetToFirstStream;
    }

    return MTF_ERROR_NONE;    
}




/***********************************************************************************
* MTF_ReadCFILDblk()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
DWORD CMTFApi::MTF_ReadCFILDblk(  MTF_DBLK_HDR_INFO  *psHdrInfo,
                         MTF_DBLK_CFIL_INFO *psCFILInfo,  
                         BYTE               *pBuffer)     
{
    MTF_DBLK_CFIL *psCFIL = 0;

    ClearStrings();
    MTF_DBLK_HDR_INFO_ReadFromBuffer(psHdrInfo, pBuffer);

    psCFIL = (MTF_DBLK_CFIL_INFO *)  (pBuffer + sizeof(MTF_DBLK_HDR));

    *psCFILInfo = *psCFIL;

    return MTF_ERROR_NONE;    
}


/* ==================================================================================
=====================================================================================
     ESPB DBLK
=====================================================================================
================================================================================== */

/***********************************************************************************
* MTF_WriteESPBDblk()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
DWORD CMTFApi::MTF_WriteESPBDblk( MTF_DBLK_HDR_INFO  *psHdrInfo,
                         BYTE               *pBuffer,
                         size_t              nBufferSize,
                         size_t             *pnSizeUsed)

{
    UINT16 uOffsetToFirstStream;

    //
    // Figure the size of the entire DBLK & make sure we have room
    //
    uOffsetToFirstStream = (UINT16) (sizeof(MTF_DBLK_HDR) + 
                           MTF_DBLK_HDR_INFO_CalcAddDataSize(psHdrInfo));

    uOffsetToFirstStream = (UINT16)Align(uOffsetToFirstStream, 4);

    if (nBufferSize < uOffsetToFirstStream) {
        if (pnSizeUsed) {
            *pnSizeUsed = uOffsetToFirstStream;
        }

        return MTF_ERROR_BUFFER_TOO_SMALL;                
    }

    memset(pBuffer, 0, uOffsetToFirstStream);

    MTF_WriteDblkHdrToBuffer(
        (UINT8 *)(char *)MTF_ID_ESPB,
        uOffsetToFirstStream,
        psHdrInfo,
        pBuffer,
        0);

    if (pnSizeUsed)
        *pnSizeUsed = uOffsetToFirstStream;

    return MTF_ERROR_NONE;    
}                                             




/***********************************************************************************
* MTF_ReadESPBDblk()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
DWORD CMTFApi::MTF_ReadESPBDblk(  MTF_DBLK_HDR_INFO  *psHdrInfo,
                         BYTE               *pBuffer)     
{
    MTF_DBLK_HDR_INFO_ReadFromBuffer(psHdrInfo, pBuffer);

    return MTF_ERROR_NONE;    
}                            




/* ==================================================================================
=====================================================================================
     End of Set DBLK (ESET)
=====================================================================================
================================================================================== */

/***********************************************************************************
* MTF_SetESETDefaults()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
void CMTFApi::MTF_SetESETDefaults(MTF_DBLK_ESET_INFO *pESETInfo)
{
    time_t tTime;
    time(&tTime);

    pESETInfo->uESETAttributes          = 0;
    pESETInfo->uNumberOfCorrupFiles     = 0;
    pESETInfo->uSetMapPBA               = 0;
    pESETInfo->uFileDetailPBA           = 0;
    pESETInfo->uFDDTapeSequenceNumber   = 0;
    pESETInfo->uDataSetNumber           = 0;
    pESETInfo->sMediaWriteDate          = MTF_CreateDateTimeFromTM(gmtime(&tTime));
}





/***********************************************************************************
* MTF_WriteESETDblk()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
DWORD CMTFApi::MTF_WriteESETDblk( MTF_DBLK_HDR_INFO  *psHdrInfo,
                         MTF_DBLK_ESET_INFO *psESETInfo,  
                         BYTE               *pBuffer,     
                         size_t              nBufferSize, 
                         size_t             *pnSizeUsed)  
{
    UINT16 uOffsetToFirstStream;
    
    //
    // Figure the size of the entire DBLK & make sure we have room
    //
    uOffsetToFirstStream = (UINT16) (sizeof(MTF_DBLK_ESET) +
                           sizeof(MTF_DBLK_HDR) +  
                           MTF_DBLK_HDR_INFO_CalcAddDataSize(psHdrInfo));
                        
    uOffsetToFirstStream = (UINT16)Align(uOffsetToFirstStream, 4);

    if (nBufferSize < uOffsetToFirstStream)
    {
        if (pnSizeUsed)
            *pnSizeUsed = uOffsetToFirstStream;
        
        return MTF_ERROR_BUFFER_TOO_SMALL;                        
    }    

    memset(pBuffer, 0, uOffsetToFirstStream);
    
    {
        MTF_DBLK_ESET_INFO *psESET = 0;
        size_t uCurrentStorageOffset = 0;

        uCurrentStorageOffset = sizeof(MTF_DBLK_ESET) + sizeof(MTF_DBLK_HDR);

        MTF_WriteDblkHdrToBuffer(
            (UINT8 *)(char *)MTF_ID_ESET, 
            uOffsetToFirstStream,
            psHdrInfo, 
            pBuffer, 
            &uCurrentStorageOffset);
        
        psESET = (MTF_DBLK_ESET_INFO *) (pBuffer + sizeof(MTF_DBLK_HDR));

        *psESET = *psESETInfo;

        if (pnSizeUsed)
            *pnSizeUsed = uOffsetToFirstStream;
    }

    return MTF_ERROR_NONE;    
}





/***********************************************************************************
* MTF_ReadESETDblk()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
DWORD CMTFApi::MTF_ReadESETDblk(  MTF_DBLK_HDR_INFO  *psHdrInfo,
                         MTF_DBLK_ESET_INFO *psESETInfo,  
                         BYTE               *pBuffer)     
{
    MTF_DBLK_ESET *psESET = 0;

    ClearStrings();
    MTF_DBLK_HDR_INFO_ReadFromBuffer(psHdrInfo, pBuffer);

    psESET = (MTF_DBLK_ESET_INFO *) (pBuffer + sizeof(MTF_DBLK_HDR));

    *psESETInfo = *psESET;

    return MTF_ERROR_NONE;    
}




/* ==================================================================================
=====================================================================================
     End of Set DBLK (EOTM)
=====================================================================================
================================================================================== */
/***********************************************************************************
* MTF_SetEOTMDefaults()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
void CMTFApi::MTF_SetEOTMDefaults(MTF_DBLK_EOTM_INFO *pEOTMInfo)
{
    pEOTMInfo->uLastESETPBA = 0;
}





/***********************************************************************************
* MTF_WriteEOTMDblk()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
DWORD CMTFApi::MTF_WriteEOTMDblk( MTF_DBLK_HDR_INFO  *psHdrInfo,
                         MTF_DBLK_EOTM_INFO *psEOTMInfo,  
                         BYTE               *pBuffer,     
                         size_t              nBufferSize, 
                         size_t             *pnSizeUsed)  
{
    UINT16 uOffsetToFirstStream;
    
    //
    // Figure the size of the entire DBLK & make sure we have room
    //
    uOffsetToFirstStream = (UINT16) (sizeof(MTF_DBLK_EOTM_INFO) + 
                           sizeof(MTF_DBLK_HDR) + 
                           MTF_DBLK_HDR_INFO_CalcAddDataSize(psHdrInfo));

    uOffsetToFirstStream = (UINT16)Align(uOffsetToFirstStream, 4);

    if (nBufferSize < uOffsetToFirstStream)
        {
        if (pnSizeUsed)
            *pnSizeUsed = uOffsetToFirstStream;
        
        return MTF_ERROR_BUFFER_TOO_SMALL;                        
        }    

    memset(pBuffer, 0, uOffsetToFirstStream);
    
    {
        MTF_DBLK_EOTM_INFO *psEOTM = 0;
        size_t uCurrentStorageOffset = 0;

        uCurrentStorageOffset = sizeof(MTF_DBLK_HDR) + sizeof(MTF_DBLK_EOTM);

        MTF_WriteDblkHdrToBuffer(
            (UINT8 *)(char *)MTF_ID_EOTM, 
            uOffsetToFirstStream,
            psHdrInfo, 
            pBuffer, 
            &uCurrentStorageOffset);
        
        psEOTM = (MTF_DBLK_EOTM_INFO *) (pBuffer + sizeof(MTF_DBLK_HDR));

        *psEOTM = *psEOTMInfo;

        if (pnSizeUsed)
            *pnSizeUsed = uOffsetToFirstStream;
    }

    return MTF_ERROR_NONE;    
}




/***********************************************************************************
* MTF_ReadEOTMDblk()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
DWORD CMTFApi::MTF_ReadEOTMDblk(  MTF_DBLK_HDR_INFO  *psHdrInfo,
                         MTF_DBLK_EOTM_INFO *psEOTMInfo,  
                         BYTE               *pBuffer)     
{
    MTF_DBLK_EOTM *psEOTM = 0;

    ClearStrings();
    MTF_DBLK_HDR_INFO_ReadFromBuffer(psHdrInfo, pBuffer);

    psEOTM = (MTF_DBLK_EOTM_INFO *) (pBuffer + sizeof(MTF_DBLK_HDR));

    *psEOTMInfo = *psEOTM;

    return MTF_ERROR_NONE;    
}


/* ==================================================================================
=====================================================================================
     Soft Filemark (SFMB)
=====================================================================================
================================================================================== */
/***********************************************************************************
* MTF_CreateSFMB() - (bmd)
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
size_t CMTFApi::MTF_GetMaxSoftFilemarkEntries(size_t nBlockSize)
{
    size_t n;

    if (0 == nBlockSize || nBlockSize % 512) {
        return 0;
    }

    // The SFMB fills the entire block.
    // Calculate the total number of entries that fit within a block
    // such that MTF_DBLK_HDR + MTF_DBLK_SFMB + (n-1 elements) < nBlockSize
    n = (nBlockSize - sizeof(MTF_DBLK_HDR) - sizeof(MTF_DBLK_SFMB) + sizeof(UINT32))/sizeof(UINT32);

    return n;
}

/***********************************************************************************
* MTF_InsertSoftFilemark() - (bmd)
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
void CMTFApi::MTF_InsertSoftFilemark(MTF_DBLK_SFMB_INFO *psSoftInfo,
                            UINT32 pba)
{
    size_t n;
    size_t bytesToShift;

    // We insert a filemark entry by shifting all the entries down.  The one closest BOM
    // eventually drop out of the array.

    if (psSoftInfo) {
        n = psSoftInfo->uNumberOfFilemarkEntries;

        bytesToShift = psSoftInfo->uFilemarkEntriesUsed * sizeof(UINT32);

        // So we don't overwrite memory.
        bytesToShift -= (psSoftInfo->uFilemarkEntriesUsed < psSoftInfo->uNumberOfFilemarkEntries) ? 0 : sizeof(UINT32);
    
        memmove(&psSoftInfo->uFilemarkArray[1], &psSoftInfo->uFilemarkArray[0], bytesToShift);

        psSoftInfo->uFilemarkArray[0] = pba;

        if (psSoftInfo->uFilemarkEntriesUsed < psSoftInfo->uNumberOfFilemarkEntries) {
            psSoftInfo->uFilemarkEntriesUsed++;
        }
    }
}


/***********************************************************************************
* MTF_WriteSFMBDblk() - (bmd)
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
DWORD CMTFApi::MTF_WriteSFMBDblk(MTF_DBLK_HDR_INFO *psHdrInfo,
                        MTF_DBLK_SFMB_INFO *psSoftInfo,
                        BYTE *pBuffer,
                        size_t nBufferSize,
                        size_t *pnSizeUsed)
{
    UINT16 uOffsetToFirstStream;
    size_t sizeOfSFMB;

    if (NULL == psHdrInfo || NULL == psSoftInfo || NULL == pBuffer || NULL == pnSizeUsed || 0 == nBufferSize) {
        return ERROR_INVALID_PARAMETER;
    }
    // Code assumes sizeof(MTF_DBLK_SFMB_INFO) == sizeof(MTF_DBLK_SFMB)
    if (sizeof(MTF_DBLK_SFMB_INFO) != sizeof(MTF_DBLK_SFMB)) {
        return ERROR_INVALID_FUNCTION;
    }

    //
    // Figure the size of the entire DBLK & make sure we have room
    //
    sizeOfSFMB = sizeof(MTF_DBLK_SFMB) + (psSoftInfo->uNumberOfFilemarkEntries-1)*sizeof(UINT32);

    uOffsetToFirstStream = (UINT16) (sizeOfSFMB +
                           sizeof(MTF_DBLK_HDR) +
                           MTF_DBLK_HDR_INFO_CalcAddDataSize(psHdrInfo));

    uOffsetToFirstStream = (UINT16)Align(uOffsetToFirstStream, 4);

    if (nBufferSize < uOffsetToFirstStream)
        {
        if (pnSizeUsed)
            *pnSizeUsed = uOffsetToFirstStream;

        return MTF_ERROR_BUFFER_TOO_SMALL;                        
        }    

    memset(pBuffer, 0, uOffsetToFirstStream);

    {
        MTF_DBLK_SFMB_INFO *psSFMB = 0;
        size_t uCurrentStorageOffset = 0;

        uCurrentStorageOffset = sizeof(MTF_DBLK_HDR) + sizeOfSFMB;

        MTF_WriteDblkHdrToBuffer(
            (UINT8 *)(char *)MTF_ID_SFMB,
            uOffsetToFirstStream,
            psHdrInfo,
            pBuffer,
            &uCurrentStorageOffset);

        psSFMB = (MTF_DBLK_SFMB *) (pBuffer + sizeof(MTF_DBLK_HDR));

        // Need a deep copy since MTF_DBLK_SFMB_INFO holds a placeholder for the array.
        memcpy(psSFMB, psSoftInfo, sizeOfSFMB);

        if (pnSizeUsed) {
            *pnSizeUsed = uOffsetToFirstStream;
        }
    }

    return MTF_ERROR_NONE;
}

/***********************************************************************************
* MTF_ReadSFMBDblk() - (bmd)
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
DWORD CMTFApi::MTF_ReadSFMBDblk(MTF_DBLK_HDR_INFO *psHdrInfo,
                       MTF_DBLK_SFMB_INFO *psSoftInfo,
                       BYTE *pBuffer)
{
    MTF_DBLK_SFMB *psSFMB = 0;
    size_t sizeOfSFMB;

    if (NULL == psHdrInfo || NULL == psSoftInfo || NULL == pBuffer) {
        return ERROR_INVALID_PARAMETER;
    }
    // Code assumes sizeof(MTF_DBLK_SFMB_INFO) == sizeof(MTF_DBLK_SFMB)
    if (sizeof(MTF_DBLK_SFMB_INFO) != sizeof(MTF_DBLK_SFMB)) {
        return ERROR_INVALID_FUNCTION;
    }

    ClearStrings();
    MTF_DBLK_HDR_INFO_ReadFromBuffer(psHdrInfo, pBuffer);

    psSFMB = (MTF_DBLK_SFMB *) (pBuffer + sizeof(MTF_DBLK_HDR));

    // Need a deep copy since MTF_DBLK_SFMB_INFO holds a placeholder for the array.
    sizeOfSFMB = sizeof(MTF_DBLK_SFMB) + (psSFMB->uNumberOfFilemarkEntries-1)*sizeof(UINT32);
    memcpy(psSoftInfo, psSFMB, sizeOfSFMB);

    return MTF_ERROR_NONE;
}

/* ==================================================================================
=====================================================================================
     STREAM HEADER
=====================================================================================
================================================================================== */

/***********************************************************************************
* MTF_SetSTREAMDefaults()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
void CMTFApi::MTF_SetSTREAMDefaults(MTF_STREAM_INFO *pSTREAMInfo, char *szId)
{
    memcpy(pSTREAMInfo->acStreamId, szId, 4);
    pSTREAMInfo->uStreamFileSystemAttributes = 0;
    pSTREAMInfo->uStreamTapeFormatAttributes = 0;
    pSTREAMInfo->uStreamLength               = 0;
    pSTREAMInfo->uDataEncryptionAlgorithm    = 0;
    pSTREAMInfo->uDataCompressionAlgorithm   = 0;
    pSTREAMInfo->uCheckSum                   = 0;
}




/***********************************************************************************
* MTF_SetSTREAMFromStreamId()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
void CMTFApi::MTF_SetSTREAMFromStreamId(
    MTF_STREAM_INFO *pSTREAMInfo, 
    WIN32_STREAM_ID *pStreamId, 
    size_t           nIDHeaderSize
    )
{

// From Steve DeVos, Seagate:
//   > BACKUP_INVALID and BACKUP_LINK will never be returned from BackupRead.
//   >
//   > -Steve
//
// TODO:  MTF_NT_ENCRYPTED_STREAM     "NTED"; These retrieved by NT Encyption APIs
// TODO:  MTF_NT_QUOTA_STREAM         "NTQU"; These retrieved by NT Quota APIs

    MTF_SetSTREAMDefaults(pSTREAMInfo, "UNKN");

    if (pStreamId->dwStreamId == BACKUP_DATA)
        memcpy(pSTREAMInfo->acStreamId, "STAN", 4);
    else if (pStreamId->dwStreamId == BACKUP_EA_DATA)
        memcpy(pSTREAMInfo->acStreamId, "NTEA", 4);
    else if (pStreamId->dwStreamId == BACKUP_SECURITY_DATA)
        memcpy(pSTREAMInfo->acStreamId, "NACL", 4);
    else if (pStreamId->dwStreamId == BACKUP_ALTERNATE_DATA)
        memcpy(pSTREAMInfo->acStreamId, "ADAT", 4);
    else if (pStreamId->dwStreamId == BACKUP_OBJECT_ID)
        memcpy(pSTREAMInfo->acStreamId, "NTOI", 4);
    else if (pStreamId->dwStreamId == BACKUP_REPARSE_DATA)
        memcpy(pSTREAMInfo->acStreamId, "NTRP", 4);
    else if (pStreamId->dwStreamId == BACKUP_SPARSE_BLOCK)
        memcpy(pSTREAMInfo->acStreamId, "SPAR", 4);
    else {
        pSTREAMInfo->uStreamFileSystemAttributes |= MTF_STREAM_IS_NON_PORTABLE;
    }

    if (pStreamId->dwStreamAttributes & STREAM_MODIFIED_WHEN_READ)
        pSTREAMInfo->uStreamFileSystemAttributes |= MTF_STREAM_MODIFIED_BY_READ;
    if (pStreamId->dwStreamAttributes & STREAM_CONTAINS_SECURITY)
        pSTREAMInfo->uStreamFileSystemAttributes |= MTF_STREAM_CONTAINS_SECURITY;
    if (pStreamId->dwStreamAttributes & STREAM_SPARSE_ATTRIBUTE)
        pSTREAMInfo->uStreamFileSystemAttributes |= MTF_STREAM_IS_SPARSE;

    pSTREAMInfo->uStreamTapeFormatAttributes = 0;
    pSTREAMInfo->uStreamLength               = MTF_CreateUINT64(pStreamId->Size.LowPart, pStreamId->Size.HighPart) + nIDHeaderSize;
    pSTREAMInfo->uDataEncryptionAlgorithm    = 0;
    pSTREAMInfo->uDataCompressionAlgorithm   = 0;
    pSTREAMInfo->uCheckSum                   = 0;
}




/***********************************************************************************
* MTF_SetStreamIdFromSTREAM() - (bmd)                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
void CMTFApi::MTF_SetStreamIdFromSTREAM(
    WIN32_STREAM_ID *pStreamId, 
    MTF_STREAM_INFO *pSTREAMInfo, 
    size_t           nIDHeaderSize
    )
{
    UNREFERENCED_PARAMETER(nIDHeaderSize);

    memset( pStreamId, 0, sizeof( WIN32_STREAM_ID ) );

    if (0 == memcmp(pSTREAMInfo->acStreamId, "STAN", 4))
        pStreamId->dwStreamId = BACKUP_DATA;
    else if (0 == memcmp(pSTREAMInfo->acStreamId, "NTEA", 4))
        pStreamId->dwStreamId = BACKUP_EA_DATA;
    else if (0 == memcmp(pSTREAMInfo->acStreamId, "NACL", 4))
        pStreamId->dwStreamId = BACKUP_SECURITY_DATA;
    else if (0 == memcmp(pSTREAMInfo->acStreamId, "ADAT", 4))
        pStreamId->dwStreamId = BACKUP_ALTERNATE_DATA;
    else if (0 == memcmp(pSTREAMInfo->acStreamId, "NTOI", 4))
        pStreamId->dwStreamId = BACKUP_OBJECT_ID;
    else if (0 == memcmp(pSTREAMInfo->acStreamId, "NTRP", 4))
        pStreamId->dwStreamId = BACKUP_REPARSE_DATA;
    else if (0 == memcmp(pSTREAMInfo->acStreamId, "SPAR", 4))
        pStreamId->dwStreamId = BACKUP_SPARSE_BLOCK;
    else {
        pStreamId->dwStreamId = BACKUP_INVALID;
    }

    pStreamId->dwStreamAttributes = STREAM_NORMAL_ATTRIBUTE;
    if (pSTREAMInfo->uStreamFileSystemAttributes & MTF_STREAM_MODIFIED_BY_READ)
        pStreamId->dwStreamAttributes |= STREAM_MODIFIED_WHEN_READ;
    if (pSTREAMInfo->uStreamFileSystemAttributes & MTF_STREAM_CONTAINS_SECURITY)
        pStreamId->dwStreamAttributes |= STREAM_CONTAINS_SECURITY;
    if (pSTREAMInfo->uStreamFileSystemAttributes & MTF_STREAM_IS_SPARSE)
        pStreamId->dwStreamAttributes |= STREAM_SPARSE_ATTRIBUTE;

    // TODO: Handle named data streams (size of name and in MTF stream)
    //       ? How do I know ?

    pStreamId->Size.LowPart  = (DWORD)((pSTREAMInfo->uStreamLength << 32) >>32);
    pStreamId->Size.HighPart = (DWORD)(pSTREAMInfo->uStreamLength >> 32);

}





/***********************************************************************************
* MTF_WriteStreamHeader()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
DWORD CMTFApi::MTF_WriteStreamHeader(MTF_STREAM_INFO *psStreamInfo,  
                            BYTE            *pBuffer,     
                            size_t           nBufferSize, 
                            size_t          *pnSizeUsed) 

{

    psStreamInfo->uCheckSum = CalcChecksum((BYTE *) psStreamInfo, sizeof(MTF_STREAM_INFO) / sizeof(UINT16) - 1);

    if (nBufferSize < sizeof(MTF_STREAM_INFO))
    {
        if (pnSizeUsed)
            *pnSizeUsed = sizeof(MTF_STREAM_INFO);
        
        return MTF_ERROR_BUFFER_TOO_SMALL;                        
    }    

    memset(pBuffer, 0, sizeof(MTF_STREAM_INFO));
    
    
    *((MTF_STREAM_INFO *) pBuffer) = *psStreamInfo;

    if (pnSizeUsed)
        *pnSizeUsed = sizeof(MTF_STREAM_INFO);


    return MTF_ERROR_NONE;    
}




/***********************************************************************************
* MTF_WriteNameStream() - (bmd)
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
DWORD CMTFApi::MTF_WriteNameStream(
    char *szType,
    wchar_t *szName,
    BYTE *pBuffer,
    size_t nBufferSize,
    size_t *pnSizeUsed)
{
    MTF_STREAM_INFO sStream;
    UINT16 uOffsetToCSUMStream;
    UINT16 uOffsetToNextStream;
    size_t nBufUsed;
    UINT16 nameSize;
    UINT32 nameChecksum;

    //
    // Figure the size of the entire Name stream including trailing CSUM and make sure we have room.
    //
    nameSize = (UINT16)wstrsize(szName);  // including terminating '\0'

    uOffsetToCSUMStream = sizeof(MTF_STREAM_INFO) + nameSize;
    uOffsetToCSUMStream = (UINT16)Align(uOffsetToCSUMStream, 4);

    uOffsetToNextStream = uOffsetToCSUMStream;

    uOffsetToNextStream += sizeof(MTF_STREAM_INFO) + 4; // includes 4 byte CSUM data
    uOffsetToNextStream = (UINT16)Align(uOffsetToNextStream, 4);

    if (nBufferSize < uOffsetToNextStream) {
        return MTF_ERROR_BUFFER_TOO_SMALL;
    }

    memset(pBuffer, 0, uOffsetToNextStream);

    MTF_SetSTREAMDefaults(&sStream, szType);
    sStream.uStreamLength = nameSize;
    sStream.uStreamTapeFormatAttributes |= MTF_STREAM_CHECKSUMED;
    MTF_WriteStreamHeader(&sStream, pBuffer, nBufferSize, &nBufUsed);

    memcpy(pBuffer + nBufUsed, szName, nameSize);

    if ( 0 == memcmp(sStream.acStreamId, "PNAM", 4) ) {
        //
        // here, we need to turn the slashes (L'\\') to zeros (L'\0')in the directory name string... 
        //
        int i, iLen;
        wchar_t UNALIGNED *szDirectoryName = (wchar_t UNALIGNED *) (pBuffer + nBufUsed);

        iLen = ua_wstrsize(szDirectoryName);
        for (i = 0; i < iLen; ++i)
            if (szDirectoryName[i] == L'\\')
                szDirectoryName[i] = L'\0';
    }

    // For Name streams, we always tack on a CSUM

    nameChecksum = CalcChecksumOfStreamData(pBuffer + nBufUsed, nameSize / sizeof(UINT32) + 1);

    MTF_SetSTREAMDefaults(&sStream, MTF_CHECKSUM_STREAM);
    sStream.uStreamLength = sizeof(nameChecksum);
    MTF_WriteStreamHeader(&sStream, pBuffer + uOffsetToCSUMStream, nBufferSize, &nBufUsed);

    memcpy(pBuffer + uOffsetToCSUMStream + nBufUsed, &nameChecksum, sizeof(nameChecksum));

    if (pnSizeUsed)
        *pnSizeUsed = uOffsetToNextStream;

    return MTF_ERROR_NONE;
}




/***********************************************************************************
* MTF_ReadStreamHeader()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
DWORD CMTFApi::MTF_ReadStreamHeader(MTF_STREAM_INFO   *psStreamInfo,  
                          BYTE              *pBuffer)    

{
    *psStreamInfo = *((MTF_STREAM_INFO *) pBuffer);
    return MTF_ERROR_NONE;    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\mover\server\mtfapi.h ===
//____________________________________________________________________________
//
//
// FILE NAME :          mtfapi.h
//
// DESCRIPTION :        An object that provides api for creating mtf format structures
//                      (see detail description below)
//
// CREATED:             7/7/00 , based on an old C api sources (mtf_api.h , mtf_api.cpp)
//

/*****************************************************************************
DETAIL DESCRIPTION

NOTE:  See the file MTF_TST.C for an example showing how to use this API

OVERVIEW
========
The MTF API provides a set of structures, each of which corresponds (but is not
identical to) to the structures described in the Microsoft Tape Format reference 
manual.  The client instanciates these structures, fills in the fields and then 
uses an MTF API function to format the information in the structure into a supplied
buffer in MTF format.  The buffer is then padded up to the next alignment factor
using an MTF API call and then  may then be written to tape using WIN32 Write. 

For example, to write an MTF TAPE DBLK,

1) Instanciate the MTF API structures.  The common header structure is used 
separately so that it can be re-used among DBLK writes
    
    MTF_DBLK_HDR_INFO sHdr;
    MTF_DBLK_TAPE_INFO sTape;

2) Use MTF API set default functions to set default values of these

    MTF_SetDblkHdrDefaults(&sHdr);
    MTF_SetTAPEDefaults(&sTape);

3) Override the default values as necessary

    sHdr.uFormatLogicalAddress = ...
    ...
    sTape.szTapeName = L"MY TAPE!"
    ...

4) Use the MTF API calls to format the contents of these structures into a buffer.
   If the API needs more room than BUFSIZE then then ammount needed is stored in 
   nBufUsed.  Otherwise nBufUsed reflects the amount of space in the buffer 
   used by the call.

    MTF_WriteTAPEDblk(&sHdr,
                      &sTape,
                      pBuffer,
                      BUFSIZE,
                      &nBufUsed);

5) NOTE WELL:  The write calls *DO NOT PAD* to the next alignment index.  But this 
   is easily done using the MTF API call:

    MTF_PadToNextAlignmentFactor(pBuffer,     
                                 nBufUsed,
                                 BUFSIZE, 
                                 &nBufUsed);

6) At this point, nBufUsed % MTF_GetAlignmentFactor should == 0.  If our blocksize
   evenly divides our alignment factor, then we can use the WIN32 Write call to

    WriteFile(hTape, pBuffer, nBufUsed, &nBytesWritten, 0);

   Since our blocksize divides our AF, then nBytesWritten should == nBufUsed

*** SEE THE MTF_TST.C FOR A COMPLETE EXAMPLE SHOWING THE USE OF THIS API TO CREATE
    A BACKUP SET


MTF API DATA STRUCTURE AND FUNCTION SUMMARY
===========================================
===========================================
**summary only -- generic detail comments appear below**


LOW LEVEL TYPES
===============
The following are typedefed to the corresponding "unsigned __intxx"

types:
    UINT8
    UINT16
    UINT32
    UINT64

functions:
MTF_CreateUINT64()  -- creates a 64 bit unsigned from two UINT32 values (lsb & msb)


DATE & TIME
===========
MTF_DATE_TIME                    -- structure used by MTF API for holding packed date & time info 
MTF_CreateDateTimeNull()         -- returns a null MTF_DATE_TIME
MTF_CreateDateTime()             -- creates MTF_DATE_TIME from year, month, day, hour, min, sec
MTF_CreateDateTimeFromTM()       -- creates MTF_DATE_TIME from struct tm in <time.h>
MTF_CreateDateTimeFromFileTime() -- creates MTF_DATE_TIME from FILETIME used by FindFirst/FindNext
MTF_CreateDateTimeToTM()         -- fills in a struct tm structure given an MTF_DATE_TIME struct


ALIGNMENT FACTOR
================
MTF_SetAlignmentFactor           -- sets the alignment factor for the MTF API (you must do this)
MTF_GetAlignmentFactor           -- returns the set alignment factor
MTF_PadToNextAlignmentFactor     -- Pads out a buffer using an SPAD to the next alignment factor
MTF_PadToNextPhysicalBlockBoundary -- Pads out a buffer using an SPAD to the next physical block boundary


MTF COMMON HEADER BLOCK
=======================
MTF_DBLK_HDR_INFO                -- common block header (must be supplied to all calls to write dblks
MTF_SetDblkHdrDefaults           -- sets default values (always call this before you set your own)


MTF TAPE DBLK INFO
==================
MTF_DBLK_TAPE_INFO     -- info corresponding to a TAPE dblk   
MTF_SetTAPEDefaults    -- sets defaults (always do this before setting your own)
MTF_WriteTAPEDblk      -- formats info in MTF_DBLK_TAPE_INFO to tape
MTF_ReadTAPEDblk       -- reads info back from a buffer holding MTF FORMATTED TAPE DBLK


MTF SSET DBLK INFO
==================
MTF_DBLK_SSET_INFO     -- all similar to above but for SSET DBLK
MTF_SetSSETDefaults    -- 
MTF_WriteSSETDblk      -- 
MTF_ReadSSETDblk       -- 


MTF VOLB DBLK INFO
==================
MTF_DBLK_VOLB_INFO     -- all similar to above but for VOLB DBLK
MTF_SetVOLBDefaults    -- 
MTF_WriteVOLBDblk      -- 
MTF_ReadVOLBDblk       -- 
MTF_SetVOLBForDevice   -- sets default values given a device name ("C:") using 
                          GetVolumeInformation (WIN32 call)


MTF DIRB DBLK INFO
==================
MTF_DBLK_DIRB_INFO        -- all similar to above but for DIRB DBLK
MTF_SetDIRBDefaults       -- 
MTF_WriteDIRBDblk         -- (dblk only -- no stream)
MTF_ReadDIRBDblk          -- 
MTF_SetDIRBFromFindData   -- sets default values given a WIN32_FIND_DATAW struct (returned
                             from calls to WIN32 FindFirst, FindNext, etc..


MTF FILE DBLK INFO
==================
MTF_DBLK_FILE_INFO        -- all similar to above but for FILE DBLK
MTF_SetFILEDefaults       -- 
MTF_WriteFILEDblk         -- (dblk only -- no stream)
MTF_ReadFILEDblk          -- 
MTF_SetFILEFromFindData   -- sets default values given a WIN32_FIND_DATAW struct (returned
                             from calls to WIN32 FindFirst, FindNext, etc..


MTF CFIL DBLK INFO
==================
MTF_DBLK_CFIL_INFO        -- all similar to above but for CFIL DBLK
MTF_SetCFILDefaults       -- 
MTF_WriteCFILDblk         -- 
MTF_ReadCFILDblk          -- 


MTF ESET DBLK INFO
==================
MTF_DBLK_ESET_INFO        -- all similar to above but for ESET DBLK
MTF_SetESETDefaults       -- 
MTF_WriteESETDblk         -- 
MTF_ReadESETDblk          -- 


MTF EOTM DBLK INFO
==================
MTF_DBLK_EOTM_INFO        -- all similar to above but for EOTM DBLK
MTF_SetEOTMDefaults       -- 
MTF_WriteEOTMDblk         -- 
MTF_ReadEOTMDblk          -- 


MTF STREAM INFO
==================
MTF_STREAM_INFO           -- all similar to above but for EOTM DBLK
MTF_SetSTREAMDefaults     -- 
MTF_WriteSTREAMHeader     -- 
MTF_ReadSTREAMHeader      -- 
MTF_SetSTREAMDefaultsFromStreamId
                          -- sets stream defaults from a WIN32_STREAM_ID struct
                             (returned from the WIN32 BackupRead function)

***********************************************************************************/

#ifndef _MTFAPI_H_
#define _MTFAPI_H_

#include <windows.h>
#include <stdlib.h>
#include <wchar.h>
#include <time.h>


/***********************************************************************************
************************************************************************************
************************************************************************************
****  MTF Constants, defines and bit masks
************************************************************************************
************************************************************************************
***********************************************************************************/

/* ==================================================================================
     MTF ERROR CODES
================================================================================== */

#define MTF_ERROR_NONE              0
#define MTF_ERROR_BUFFER_TOO_SMALL  1000
#define MTF_NO_STREAMS              1001
#define MTF_OUT_OF_MEMORY           1002

/* ==================================================================================
     MTF Misc. Defaults and Constants
================================================================================== */
#define MTF_DEFAULT_ALIGNMENT_FACTOR 1024;

#define MTF_FORMAT_VER_MAJOR      1
#define MTF_FORMAT_VER_MINOR      0 // BMD: This API is verison 5; use 0 for compatibility with NT Backup

#define MTF_PW_ENCRYPT_NONE       0
#define MTF_DATA_ENCRYPT_NONE     0
#define MTF_ECC_NONE              0

#define MTF_COMPRESS_NONE         0

#define MTF_OTC_NONE              0
#define MTF_OTC_TYPE              1
#define MTF_OTC_VERSION           2

#define MTF_LOCAL_TZ              127

#define MTF_STRING_NONE           0
#define MTF_STRING_ANSI_STR       1
#define MTF_STRING_UNICODE_STR    2

#define MTF_OSID_NT               14
#define MTF_OSID_DOS              24

/* ==================================================================================
     MTF Block Types
================================================================================== */

#define  MTF_ID_TAPE     "TAPE"    /* Tape Header ID */
#define  MTF_ID_VOLB     "VOLB"    /* Volume Control Block ID */
#define  MTF_ID_SSET     "SSET"    /* Start of Backup Set Description Block ID */
#define  MTF_ID_ESET     "ESET"    /* End of Backup Set Description Block ID */
#define  MTF_ID_EOTM     "EOTM"    /* End of tape, continuation Block ID */
#define  MTF_ID_DIRB     "DIRB"    /* Directory Descriptor Block ID */
#define  MTF_ID_FILE     "FILE"    /* File Descriptor Block ID */
#define  MTF_ID_CFIL     "CFIL"    /* Corrupt File Descriptor Block ID */
#define  MTF_ID_ESPB     "ESPB"    /* End of Set Pad Block */
#define  MTF_ID_SFMB     "SFMB"    /* Soft Filemark Descriptor Block ID */


/* ==================================================================================
     DBLK Block Attributes

     The lower 16 bits are reserved for general attribute bits (those
     which may appear in more than one type of DBLK), the upper 16 are
     for attributes which are specific to one type of DBLK.

     Note that the block specific bit definitions overlap, and the block
     type is used to determine the meaning of a given bit.
================================================================================== */

/* any : */
#define MTF_CONTINUATION        0x00000001UL
#define MTF_COMPRESSION         0x00000004UL
#define MTF_EOS_AT_EOM          0x00000008UL
#define MTF_VAR_BLKS            0x00000010UL
#define MTF_SESSION             0x00000020UL

/* TAPE : */
#define MTF_SM_EXISTS           0x00010000UL
#define MTF_FDD_ALLOWED         0x00020000UL
#define MTF_SM_ALT_OVERWRITE    0x00040000UL
#define MTF_FDD_ALT_PART        0x00080000UL
#define MTF_SM_ALT_APPEND       0x00200000UL

/* SSET : */
#define MTF_FDD_EXISTS          0x00010000UL
#define MTF_ENCRYPTION          0x00020000UL

/* ESET : */
#define MTF_FDD_ABORTED         0x00010000UL
#define MTF_END_OF_FAMILY       0x00020000UL
#define MTF_ABORTED_SET         0x00040000UL
#define MTF_SET_VERIFIED        0x00080000UL

/* EOTM : */
#define MTF_NO_ESET_PBA         0x00010000UL
#define MTF_INVALID_ESET_PBA    0x00020000UL

/* ==================================================================================
     TAPE Block Attributes
================================================================================== */

#define MTF_TAPE_SOFT_FILEMARK  0x00000001UL
#define MTF_TAPE_MEDIA_LABEL    0x00000002UL

/* ==================================================================================
     SSET Block Attributes
================================================================================== */

#define MTF_SSET_TRANSFER       0x00000001UL
#define MTF_SSET_COPY           0x00000002UL
#define MTF_SSET_NORMAL         0x00000004UL
#define MTF_SSET_DIFFERENTIAL   0x00000008UL
#define MTF_SSET_INCREMENTAL    0x00000010UL
#define MTF_SSET_DAILY          0x00000020UL

/* ==================================================================================
     VOLB Block Attributes
================================================================================== */

#define MTF_VOLB_NO_REDIRECT    0x00000001UL
#define MTF_VOLB_NON_VOLUME     0x00000002UL
#define MTF_VOLB_DEV_DRIVE      0x00000004UL
#define MTF_VOLB_DEV_UNC        0x00000008UL
#define MTF_VOLB_DEV_OS_SPEC    0x00000010UL
#define MTF_VOLB_DEV_VEND_SPEC  0x00000020UL

/* ==================================================================================
     DIRB Block Attributes
================================================================================== */

#define MTF_DIRB_READ_ONLY      0x00000100UL
#define MTF_DIRB_HIDDEN         0x00000200UL
#define MTF_DIRB_SYSTEM         0x00000400UL
#define MTF_DIRB_MODIFIED       0x00000800UL
#define MTF_DIRB_EMPTY          0x00010000UL
#define MTF_DIRB_PATH_IN_STREAM 0x00020000UL
#define MTF_DIRB_CORRUPT        0x00040000UL

/* ==================================================================================
     FILE Block Attributes
================================================================================== */

#define MTF_FILE_READ_ONLY      0x00000100UL
#define MTF_FILE_HIDDEN         0x00000200UL
#define MTF_FILE_SYSTEM         0x00000400UL
#define MTF_FILE_MODIFIED       0x00000800UL
#define MTF_FILE_IN_USE         0x00010000UL
#define MTF_FILE_NAME_IN_STREAM 0x00020000UL
#define MTF_FILE_CORRUPT        0x00040000UL

/* ==================================================================================
     CFIL Block Attributes
================================================================================== */

#define MTF_CFIL_LENGTH_CHANGE  0x00010000UL
#define MTF_CFIL_UNREADABLE_BLK 0x00020000UL
#define MTF_CFIL_DEADLOCK       0x00040000UL

/* ==================================================================================
     ESET Block Attributes
================================================================================== */

#define MTF_ESET_TRANSFER       0x00000001UL
#define MTF_ESET_COPY           0x00000002UL
#define MTF_ESET_NORMAL         0x00000004UL
#define MTF_ESET_DIFFERENTIAL   0x00000008UL
#define MTF_ESET_INCREMENTAL    0x00000010UL
#define MTF_ESET_DAILY          0x00000020UL

/* ==================================================================================
     STREAM File System Attributes
================================================================================== */

#define MTF_STREAM_MODIFIED_BY_READ     0x00000001UL
#define MTF_STREAM_CONTAINS_SECURITY    0x00000002UL
#define MTF_STREAM_IS_NON_PORTABLE      0x00000004UL
#define MTF_STREAM_IS_SPARSE            0x00000008UL

/* ==================================================================================
     STREAM Media Format Attributes
================================================================================== */

#define MTF_STREAM_CONTINUE         0x00000001UL
#define MTF_STREAM_VARIABLE         0x00000002UL
#define MTF_STREAM_VAR_END          0x00000004UL
#define MTF_STREAM_ENCRYPTED        0x00000008UL
#define MTF_STREAM_COMPRESSED       0x00000010UL
#define MTF_STREAM_CHECKSUMED       0x00000020UL
#define MTF_STREAM_EMBEDDED_LENGTH  0x00000040UL

/* ==================================================================================
     STREAM Types (Platform Independent)
================================================================================== */

#define MTF_STANDARD_DATA_STREAM    "STAN"
#define MTF_PATH_NAME_STREAM        "PNAM"
#define MTF_FILE_NAME_STREAM        "FNAM"
#define MTF_CHECKSUM_STREAM         "CSUM"
#define MTF_CORRUPT_STREAM          "CRPT"
#define MTF_PAD_STREAM              "SPAD"
#define MTF_SPARSE_STREAM           "SPAR"
#define MTF_MBC_LMO_SET_MAP_STREAM  "TSMP"
#define MTF_MBC_LMO_FDD_STREAM      "TFDD"
#define MTF_MBC_SLO_SET_MAP_STREAM  "MAP2"
#define MTF_MBC_SLO_FDD_STREAM      "FDD2"

/* ==================================================================================
     STREAM Types (Windows NT specific)
================================================================================== */

#define MTF_NTFS_ALT_STREAM         "ADAT"
#define MTF_NTFS_EA_STREAM          "NTEA"
#define MTF_NT_SECURITY_STREAM      "NACL"
#define MTF_NT_ENCRYPTED_STREAM     "NTED"
#define MTF_NT_QUOTA_STREAM         "NTQU"
#define MTF_NT_PROPERTY_STREAM      "NTPR"
#define MTF_NT_REPARSE_STREAM       "NTRP"
#define MTF_NT_OBJECT_ID_STREAM     "NTOI"

/* ==================================================================================
     STREAM Frame Headers
================================================================================== */

#define MTF_COMPRESSION_HEADER_ID   "FM"
#define MTF_ECRYPTION_HEADER_ID     "EH"

/* ==================================================================================
 * Turn on packing here.  Need to be sure that date is packed. 
================================================================================== */
#pragma pack(1)

/***********************************************************************************
************************************************************************************
************************************************************************************
****  MTF Miscelaneous Data Types (and some handy methods for them)
************************************************************************************
************************************************************************************
***********************************************************************************/

/* ==================================================================================
     General Data Types
================================================================================== */
#ifndef _BASET32_H_
#ifndef _BASETSD_H_
// This one is now in a NT header file but not as __int32
typedef unsigned __int8  UINT8;
typedef unsigned __int16 UINT16;
typedef unsigned __int32 UINT32;
#endif
#endif
typedef unsigned __int64 UINT64;


/* ==================================================================================
     Compressed date structure for storing dates in minimal space on tape:

     BYTE 0    BYTE 1    BYTE 2    BYTE 3    BYTE 4
    76543210  76543210  76543210  76543210  76543210
    yyyyyyyy  yyyyyymm  mmdddddh  hhhhmmmm  mmssssss
================================================================================== */
typedef struct {
     UINT8     dt_field[5] ;
} MTF_DATE_TIME;


/************************************************************************************
* MTF_CreateDataTime#####()
*
* Description:  Given various arguments, this set of functions returns a packed 
*               MTF_DATE_TIME struct which can then be assigned to fields found 
*               in the various info structs found below
* Example:
*               sSetInfo.sBackupDate = MTF_CreateDateTime(1995, 6, 12, 16, 30, 0);
************************************************************************************/


/***********************************************************************************
************************************************************************************
****  MTF Alignment Factor - GENERIC DETAIL COMMENTS FOR METHODS FOUND BELOW
************************************************************************************
***********************************************************************************/

/************************************************************************************
* MTF_SetAlignmentFactor()
*
* Description:  Sets the alignment factor to be used by the MTF API
*               (particularly by MTF_PadToNextAlignmentFactor and MTF_WriteTAPEDblk)
*
* Pre:
* Post: MTF API Alignment Factor == uAF
*
* uAF -- alignment factor value to set
************************************************************************************/

/************************************************************************************
* MTF_GetAlignmentFactor()
*
* Description:  Returns the Alignment Factor set by MTF_SetAlignmentFactor
*
* Pre: MTF_SetAlignmentFactor has been called
************************************************************************************/

/************************************************************************************
* MTF_PadToNextAlignmentFactor()
*
* Description:  Appends an SPAD stream to the buffer so as to pad the buffer out to 
*               the next alignment factor
*               
*
* Pre:  The alignment factor has been set by calling MTF_SetAlignmentFactor,
*       pBuffer points to a buffer whose size is reflected by nBufferSize
*
* Post: return value == MTF_ERROR_NONE
*           => padding was successful, *pnSizeUsed reflects amount of buffer used,
*              AND *pnSizeUsed % MTF_GetAlignmentFactor == 0  is  TRUE
*       return value == MTF_ERROR_BUFFER_TOO_SMALL
*           => The buffer was too small, *pnSizeUsed reflects the amound needed
*
* NOTE: If the space between the end of the buffer and the next alignment factor is 
*       smaller than the size of a stream header, then the spad hogs up the whole 
*       next alignment factor.
*
* pBuffer     -- the buffer to spad out
* nBufUsed    -- the amount of the buffer used so far (position where to append)
* nBufferSize -- the size of the buffer pointed to by pBuffer
* pnSizeUsed  -- points to where to store size used or needed
************************************************************************************/

/************************************************************************************
* MTF_PadToNextPhysicalBlockBoundary() - (bmd)
*
* Description:  Appends an SPAD stream to the buffer so as to pad the buffer out to 
*               the next physical block boundary.
*
************************************************************************************/


/***********************************************************************************
************************************************************************************
************************************************************************************
****  MTF API STRUCTURES
************************************************************************************
************************************************************************************
***********************************************************************************/

/***********************************************************************************
GENERIC DETAIL COMMENTS FOR METHODS FOUND BELOW
=================================================

************************************************************************************
* MTF_Set####Defaults()
*
* Description:  Sets up default values for the structure.  Always call this to
*               avoid garbage values in case you over look a field, 
* Pre:  
* Post: All fields of the referenced structure are filled in with *something*. 
*       Date fields are initialized to current date and time.
*       Strings pointers are set to 0
*       Most other values set to 0
*
* p####Info     -- pointer to structure to be set
************************************************************************************
void MTF_Set####Defaults(
    MTF_####_INFO *p####Info);    


************************************************************************************
* MTF_Write####Dblk()
*
* Description:  Formats the information supplied in psHdrInfo and ps####Info into
*               MTF Format and places the results in pBuffer
*
* Pre:  psHdrInfo and ps####Info contain valid information / default values
*       pBuffer points to a buffer where resulting format is to be stored
*       nBuffer size indicates the size of the buffer
*
*       MTF_WriteTAPEDblk -- MTF_SetAlingmentFactor has been called
*
* Post: return value == MTF_ERROR_NONE
*           => Format was successful, *pnSizeUsed reflects amount of buffer used
*       return value == MTF_ERROR_BUFFER_TOO_SMALL
*           => The buffer was too small, *pnSizeUsed reflects the amound needed
*
* psHdrInfo   -- MTF Common header information 
* ps####Info  -- MTF DBLK info
* pBuffer     -- pointer to buffer which will receive MTF formatted info
* pBufferSize -- the size of the buffer pointed to by pBuffer
* pnSizeUsed  -- pointer to a size_t in which amount of buffer used or needed is stored
************************************************************************************
DWORD MTF_Write####Dblk( MTF_DBLK_HDR_INFO  *psHdrInfo,
                         MTF_DBLK_####_INFO *ps####Info,  
                         BYTE               *pBuffer,     
                         size_t              nBufferSize, 
                         size_t             *pnSizeUsed); 



************************************************************************************
* MTF_Read####Dblk()
*
* Description:  Translates MTF Formatted information from a buffer to MTF API info
*               structures -- the opposite of MTF_Write####Dblk
*               
*
* Pre:  pBuffer contains correct MTF Buffer information 
*
* Post: psHdrInfo and ps####Info contain the de-formatted info.  
*
* NOTE: Strings point to strings stored statically by the API, and will be over 
*       written on the next read call. 
*
* psHdrInfo   -- MTF Common header info struct to receive info
* ps####Info  -- MTF DBLK info struct to receive info
* pBuffer     -- pointer to buffer which holds MTF formatted data
************************************************************************************
DWORD MTF_Read####Dblk(  MTF_DBLK_HDR_INFO  *psHdrInfo,
                         MTF_DBLK_####_INFO *ps####Info,  
                         BYTE               *pBuffer);    



************************************************************************************
* MTF_Set####From?????????()
*
* Description: Similar to MTF_Set####Defaults(), but takes as an argument one or more
*              commonly used structures and sets values from that.  For example, 
*              MTF_SetFILEFromFindData takes as an argument a WIN32_FIND_DATA struct
*              from which it extracts the file name, date, time, etc. 
*               
*
* Pre:  
* Post: As many fields as are reasonable are automatically set.  The rest of the 
*       fields are set to default values.
*
* NOTE: Strings such as file names, directory names are stored statically by the 
*       MTF API and are only good until the next call to an MTF_Set#####From??????
*       function.
*
* NOTE: FILE and DIRB calls automatically set the file and directory attibutes from 
*       the info in the WIN32_FIND_DATA structure.
*
* NOTE: MTF_SetSTREAMFromStreamId will automatically set the stream header id based
*       on the attributes found in the WIN32 stream header
*
************************************************************************************
void MTF_Set####From?????????(MTF_DBLK_####_INFO *p####Info, 
                              SomeType????        Id??? 
                              ....);
***********************************************************************************/



/* ==================================================================================
     Common DBLK: MTF_STD_DBLK_INFO
================================================================================== */
typedef struct { 

    char    acBlockType[5];         /* for reading only -- ignored when writing (includes \0)*/
    UINT32  uBlockAttributes;
    UINT16  uOffsetToFirstStream;   /* for reading only */
    UINT8   uOSID;                  /* Machine/OS id where written, low byte */
    UINT8   uOSVersion;             /* Machine/OS id where written, high byte */
    UINT64  uDisplayableSize;       /* Displayable data size */
    UINT64  uFormatLogicalAddress;
    UINT16  uReservedForMBC;        /* Reserved for Media Based Catalog */
    UINT16  uSoftwareCompression;   /* Software Compression Algorithm */
    UINT32  uControlBlockId;        /* Used for error recovery */
    void *  pvOSData;               /* OS specific Data */
    UINT16  uOSDataSize;            /* the size of the OS data in bytes */
    UINT8   uStringType;            /* String type */   
    UINT16  uHeaderCheckSum;        /* for reading only */

} MTF_DBLK_HDR_INFO;

/* ==================================================================================
     TAPE DBLK: MTF_TAPE_INFO
================================================================================== */
typedef struct { 

    UINT32  uTapeFamilyId;
    UINT32  uTapeAttributes;
    UINT16  uTapeSequenceNumber;
    UINT16  uPasswordEncryptionAlgorithm;
    UINT16  uSoftFilemarkBlockSize;
    UINT16  uTapeCatalogType;
    wchar_t *   szTapeName;
    wchar_t * szTapeDescription;
    wchar_t * szTapePassword;
    wchar_t * szSoftwareName;
    UINT16  uAlignmentFactor;
    UINT16  uSoftwareVendorId;
    MTF_DATE_TIME   sTapeDate;
    UINT8   uMTFMajorVersion;

} MTF_DBLK_TAPE_INFO;

/* ==================================================================================
     Start of Set DBLK (SSET)
================================================================================== */
typedef struct {
     UINT32              uSSETAttributes;
     UINT16              uPasswordEncryptionAlgorithm;
     UINT16              uDataEncryptionAlgorithm;
     UINT16              uSoftwareVendorId;
     UINT16              uDataSetNumber;
     wchar_t *           szDataSetName;
     wchar_t *           szDataSetDescription;
     wchar_t *           szDataSetPassword;
     wchar_t *           szUserName;
     UINT64              uPhysicalBlockAddress;
     MTF_DATE_TIME       sMediaWriteDate;
     UINT8               uSoftwareVerMjr;
     UINT8               uSoftwareVerMnr;
     UINT8               uTimeZone ;
     UINT8               uMTFMinorVer ;
     UINT8               uTapeCatalogVersion;
} MTF_DBLK_SSET_INFO;

/* ==================================================================================
     Volume DBLK (VOLB)
================================================================================== */
typedef struct {
     UINT32              uVolumeAttributes;
     wchar_t *           szDeviceName;
     wchar_t *           szVolumeName;
     wchar_t *           szMachineName;
     MTF_DATE_TIME       sMediaWriteDate;
} MTF_DBLK_VOLB_INFO;

typedef struct {
     UINT32              uFileSystemFlags;
     UINT32              uBackupSetAttributes;
} MTF_VOLB_OS_NT_1;

/* ==================================================================================
     Directory DBLK (DIRB)
================================================================================== */
typedef struct {
     UINT32              uDirectoryAttributes;
     MTF_DATE_TIME       sLastModificationDate;
     MTF_DATE_TIME       sCreationDate;
     MTF_DATE_TIME       sBackupDate;
     MTF_DATE_TIME       sLastAccessDate;
     UINT32              uDirectoryId;
     wchar_t *           szDirectoryName;
} MTF_DBLK_DIRB_INFO;

typedef struct {
     UINT32              uDirectoryAttributes;
} MTF_DIRB_OS_NT_0;

typedef struct {
     UINT32              uDirectoryAttributes;
     UINT16              uShortNameOffset;
     UINT16              uShortNameSize;
} MTF_DIRB_OS_NT_1;

/* ==================================================================================
     File DBLK (FILE)
================================================================================== */
typedef struct {
     UINT32              uFileAttributes;
     MTF_DATE_TIME       sLastModificationDate;
     MTF_DATE_TIME       sCreationDate;
     MTF_DATE_TIME       sBackupDate;
     MTF_DATE_TIME       sLastAccessDate;
     UINT32              uDirectoryId;
     UINT32              uFileId;
     wchar_t *           szFileName;
     UINT64              uDisplaySize;
} MTF_DBLK_FILE_INFO;

typedef struct {
     UINT32              uFileAttributes;
     UINT16              uShortNameOffset;
     UINT16              uShortNameSize;
     UINT16              lLink;
     UINT16              uReserved;
} MTF_FILE_OS_NT_0;

typedef struct {
     UINT32              uFileAttributes;
     UINT16              uShortNameOffset;
     UINT16              uShortNameSize;
     UINT32              uFileFlags;
} MTF_FILE_OS_NT_1;

/* ==================================================================================
     Corrupt File DBLK (CFIL)
================================================================================== */
typedef struct {
     UINT32              uCFileAttributes;
     UINT32              uDirectoryId;      /* Or CFIL Attributes                             ***/
     UINT32              uFileId;           /* Or reserved                                    ***/
     UINT64              uStreamOffset;
     UINT16              uCorruptStreamNumber;
} MTF_DBLK_CFIL_INFO;

/* ==================================================================================
     End of Set DBLK (ESET)
================================================================================== */
typedef struct {
     UINT32              uESETAttributes;
     UINT32              uNumberOfCorrupFiles;
     UINT64              uSetMapPBA;
     UINT64              uFileDetailPBA;
     UINT16              uFDDTapeSequenceNumber;
     UINT16              uDataSetNumber;
     MTF_DATE_TIME       sMediaWriteDate;
} MTF_DBLK_ESET_INFO;

/* ==================================================================================
     End of Tape Media DBLK (EOTM)
================================================================================== */
typedef struct {
     UINT64              uLastESETPBA;
} MTF_DBLK_EOTM_INFO;

/* ==================================================================================
     Soft Filemark DBLK (SFMB) - (bmd)
================================================================================== */
typedef struct {
     UINT32              uNumberOfFilemarkEntries;
     UINT32              uFilemarkEntriesUsed;
     UINT32              uFilemarkArray[1];
} MTF_DBLK_SFMB_INFO;

/* ==================================================================================
     STREAM 
================================================================================== */
typedef struct {
     UINT8               acStreamId[4];
     UINT16              uStreamFileSystemAttributes;
     UINT16              uStreamTapeFormatAttributes;
     UINT64              uStreamLength;
     UINT16              uDataEncryptionAlgorithm;
     UINT16              uDataCompressionAlgorithm;
     UINT16              uCheckSum;

} MTF_STREAM_INFO;


/* ==================================================================================
     Tape Address
================================================================================== */
typedef struct {
     UINT16 uSize;        /* Size of the data */
     UINT16 uOffset;      /* Offset to the data */
} MTF_TAPE_ADDRESS;


#pragma pack()

//
// The CMTFApi class
//
class CMTFApi
{
public:
    // Construction
    CMTFApi();
    ~CMTFApi();

    // General type utilties
    static UINT64 MTF_CreateUINT64(UINT32 uLSB, 
                                   UINT32 uMSB);

    // MTF Date-Time utilities
    MTF_DATE_TIME MTF_CreateDateTimeNull();

    MTF_DATE_TIME MTF_CreateDateTime(int iYear, 
                                     int iMonth, 
                                     int iDay, 
                                     int iHour, 
                                     int iMinute,
                                     int iSecond);

    MTF_DATE_TIME MTF_CreateDateTimeFromTM(struct tm *pT);

    MTF_DATE_TIME MTF_CreateDateTimeFromFileTime(FILETIME sFileTime);

    void MTF_CreateDateTimeToTM(MTF_DATE_TIME *pDT, 
                                struct tm     *pT);

    // MTF Alignment Factor 
    void MTF_SetAlignmentFactor(UINT16 uAF);

    UINT16 MTF_GetAlignmentFactor();

    DWORD MTF_PadToNextAlignmentFactor(BYTE     *pBuffer,    
                                       size_t    nBufUsed,
                                       size_t    nBufferSize, 
                                       size_t   *pnSizeUsed);

    DWORD MTF_PadToNextPhysicalBlockBoundary(BYTE *pBuffer,
                                             size_t nBlockSize,
                                             size_t nBufUsed,
                                             size_t nBufferSize,
                                             size_t *pnSizeUsed);
 
    // Common DBLK
    void MTF_SetDblkHdrDefaults(MTF_DBLK_HDR_INFO *pStdInfo);

    // TAPE DBLK
    void MTF_SetTAPEDefaults(MTF_DBLK_TAPE_INFO *pTapeInfo);
    
    DWORD MTF_WriteTAPEDblk(MTF_DBLK_HDR_INFO  *psHdrInfo,
                            MTF_DBLK_TAPE_INFO *psTapeInfo,  
                            BYTE               *pBuffer,     
                            size_t              nBufferSize, 
                            size_t             *pnSizeUsed); 

    DWORD MTF_ReadTAPEDblk(MTF_DBLK_HDR_INFO  *psHdrInfo,
                           MTF_DBLK_TAPE_INFO *psTapeInfo,  
                           BYTE               *pBuffer);    

    // Start of Set DBLK (SSET)
    void MTF_SetSSETDefaults(MTF_DBLK_SSET_INFO *pSSETInfo);

    DWORD MTF_WriteSSETDblk(MTF_DBLK_HDR_INFO  *psHdrInfo,
                            MTF_DBLK_SSET_INFO *psTapeInfo,  
                            BYTE               *pBuffer,     
                            size_t              nBufferSize, 
                            size_t             *pnSizeUsed); 

    DWORD MTF_ReadSSETDblk(MTF_DBLK_HDR_INFO  *psHdrInfo,
                           MTF_DBLK_SSET_INFO *psTapeInfo,  
                           BYTE               *pBuffer);    

    // Volume DBLK (VOLB)
    void MTF_SetVOLBDefaults(MTF_DBLK_VOLB_INFO *pVOLBInfo);

    void MTF_SetVOLBForDevice(MTF_DBLK_VOLB_INFO *pVOLBInfo, wchar_t *szDevice);

    DWORD MTF_WriteVOLBDblk(MTF_DBLK_HDR_INFO  *psHdrInfo,
                            MTF_DBLK_VOLB_INFO *psTapeInfo,  
                            BYTE               *pBuffer,     
                            size_t              nBufferSize, 
                            size_t             *pnSizeUsed); 

    DWORD MTF_ReadVOLBDblk(MTF_DBLK_HDR_INFO  *psHdrInfo,
                           MTF_DBLK_VOLB_INFO *psTapeInfo,  
                           BYTE               *pBuffer);    

    // Directory DBLK (DIRB)
    void MTF_SetDIRBDefaults(MTF_DBLK_DIRB_INFO *pDIRBInfo);

    void MTF_SetDIRBFromFindData(MTF_DBLK_DIRB_INFO *pDIRBInfo, 
                                 wchar_t            *szFullFileName, 
                                 WIN32_FIND_DATAW   *pFindData);

    DWORD MTF_WriteDIRBDblk(MTF_DBLK_HDR_INFO  *psHdrInfo,
                            MTF_DBLK_DIRB_INFO *psTapeInfo,  
                            BYTE               *pBuffer,     
                            size_t              nBufferSize, 
                            size_t             *pnSizeUsed); 
                                                          
    DWORD MTF_ReadDIRBDblk(MTF_DBLK_HDR_INFO  *psHdrInfo,
                           MTF_DBLK_DIRB_INFO *psTapeInfo,  
                           BYTE               *pBuffer);    

    // File DBLK (FILE)
    void MTF_SetFILEDefaults(MTF_DBLK_FILE_INFO *pFILEInfo);

    void MTF_SetFILEFromFindData(MTF_DBLK_FILE_INFO *pFILEInfo, 
                                 WIN32_FIND_DATAW *pFindData);

    DWORD MTF_WriteFILEDblk(MTF_DBLK_HDR_INFO  *psHdrInfo,
                            MTF_DBLK_FILE_INFO *psTapeInfo,  
                            BYTE               *pBuffer,     
                            size_t              nBufferSize, 
                            size_t             *pnSizeUsed); 
                                                          
    DWORD MTF_ReadFILEDblk(MTF_DBLK_HDR_INFO  *psHdrInfo,
                           MTF_DBLK_FILE_INFO *psTapeInfo,  
                           BYTE               *pBuffer);    

    // Corrupt File DBLK (CFIL)
    void MTF_SetCFILDefaults(MTF_DBLK_CFIL_INFO *pCFILInfo);

    DWORD MTF_WriteCFILDblk(MTF_DBLK_HDR_INFO  *psHdrInfo,
                            MTF_DBLK_CFIL_INFO *psTapeInfo,  
                            BYTE               *pBuffer,     
                            size_t              nBufferSize, 
                            size_t             *pnSizeUsed); 
                                                          
    DWORD MTF_ReadCFILDblk(MTF_DBLK_HDR_INFO  *psHdrInfo,
                           MTF_DBLK_CFIL_INFO *psTapeInfo,  
                           BYTE               *pBuffer);    

    // End of Set Pad DBLK (ESPB)
    DWORD MTF_WriteESPBDblk(MTF_DBLK_HDR_INFO  *psHdrInfo,
                            BYTE               *pBuffer,     
                            size_t              nBufferSize, 
                            size_t             *pnSizeUsed); 
                                                          
    DWORD MTF_ReadESPBDblk(MTF_DBLK_HDR_INFO  *psHdrInfo,
                           BYTE               *pBuffer);    

    // End of Set DBLK (ESET)
    void MTF_SetESETDefaults(MTF_DBLK_ESET_INFO *pESETInfo);

    DWORD MTF_WriteESETDblk(MTF_DBLK_HDR_INFO  *psHdrInfo,
                            MTF_DBLK_ESET_INFO *psTapeInfo,  
                            BYTE               *pBuffer,     
                            size_t              nBufferSize, 
                            size_t             *pnSizeUsed); 
                                                          
    DWORD MTF_ReadESETDblk(MTF_DBLK_HDR_INFO  *psHdrInfo,
                           MTF_DBLK_ESET_INFO *psTapeInfo,  
                           BYTE               *pBuffer);    

    // End of Tape Media DBLK (EOTM)
    void MTF_SetEOTMDefaults(MTF_DBLK_EOTM_INFO *pEOTMInfo);

    DWORD MTF_WriteEOTMDblk(MTF_DBLK_HDR_INFO  *psHdrInfo,
                            MTF_DBLK_EOTM_INFO *psTapeInfo,  
                            BYTE               *pBuffer,     
                            size_t              nBufferSize, 
                            size_t             *pnSizeUsed); 
                                                          
    DWORD MTF_ReadEOTMDblk(MTF_DBLK_HDR_INFO  *psHdrInfo,
                           MTF_DBLK_EOTM_INFO *psTapeInfo,  
                           BYTE               *pBuffer);    

    // Soft Filemark DBLK (SFMB) - (bmd)
    size_t MTF_GetMaxSoftFilemarkEntries(size_t nBlockSize);

    void MTF_InsertSoftFilemark(MTF_DBLK_SFMB_INFO *psSoftInfo,
                                UINT32 pba);

    DWORD MTF_WriteSFMBDblk(MTF_DBLK_HDR_INFO *psHdrInfo,
                            MTF_DBLK_SFMB_INFO *psSoftInfo,
                            BYTE *pBuffer,
                            size_t nBufferSize,
                            size_t *pnSizeUsed);

    DWORD MTF_ReadSFMBDblk(MTF_DBLK_HDR_INFO *psHdrInfo,
                           MTF_DBLK_SFMB_INFO *psSoftInfo,
                           BYTE *pBuffer);

    // STREAM 
    static void MTF_SetSTREAMDefaults(MTF_STREAM_INFO *pSTREAMInfo, 
                                      char            *szId);

    static void MTF_SetSTREAMFromStreamId(MTF_STREAM_INFO *pSTREAMInfo, 
                                          WIN32_STREAM_ID *pStreamId, 
                                          size_t           nIDHeaderSize);

    static void MTF_SetStreamIdFromSTREAM(WIN32_STREAM_ID *pStreamId,
                                          MTF_STREAM_INFO *pSTREAMInfo, 
                                          size_t           nIDHeaderSize);

    static DWORD MTF_WriteStreamHeader(MTF_STREAM_INFO *psStreamInfo,  
                                       BYTE               *pBuffer,     
                                       size_t              nBufferSize, 
                                       size_t             *pnSizeUsed); 

    static DWORD MTF_WriteNameStream(char      *szType,
                                     wchar_t   *szName,
                                     BYTE      *pBuffer,
                                     size_t     nBufferSize,
                                     size_t    *pnSizeUsed);

    static DWORD MTF_ReadStreamHeader(MTF_STREAM_INFO    *psStreamInfo,  
                                      BYTE               *pBuffer);    

    // Utilities 
    void MTF_DBLK_HDR_INFO_ReadFromBuffer(MTF_DBLK_HDR_INFO *psHdrInfo, 
                                          BYTE              *pBuffer);
private:
    // Internal methods
    static size_t Align(size_t uSize, size_t uAlignment);
    static UINT16 CalcChecksum(BYTE * pStartPtr, int nNum);
    static UINT32 CalcChecksumOfStreamData(BYTE * pStartPtr, int nNum);

    static size_t wstrsize(wchar_t *s);
    static size_t ua_wstrsize(wchar_t UNALIGNED *s);
    void ClearStrings();
    wchar_t * MakeString(wchar_t UNALIGNED * pString, size_t iSize);

    size_t StringToTapeAddress(MTF_TAPE_ADDRESS *pAd,
                               BYTE             *pBuffer,
                               wchar_t          *str,
                               size_t           uCurrentStorageOffset);

    void MTF_WriteDblkHdrToBuffer(UINT8              acID[4],
                                  UINT16             uOffsetToFirstStream,  
                                  MTF_DBLK_HDR_INFO *psHdrInfo,             
                                  BYTE              *pBuffer,               
                                  size_t            *puCurrentStorage);
                                  
    size_t MTF_DBLK_HDR_INFO_CalcAddDataSize(MTF_DBLK_HDR_INFO *pSTDInfo);
    size_t MTF_DBLK_TAPE_INFO_CalcAddDataSize(MTF_DBLK_TAPE_INFO *pTapeInfo);
    size_t MTF_DBLK_SSET_INFO_CalcAddDataSize(MTF_DBLK_SSET_INFO *pSSETInfo);
    size_t MTF_DBLK_VOLB_INFO_CalcAddDataSize(MTF_DBLK_VOLB_INFO *pVOLBInfo);
    size_t MTF_DBLK_DIRB_INFO_CalcAddDataSize(MTF_DBLK_DIRB_INFO *pDIRBInfo);
    size_t MTF_DBLK_FILE_INFO_CalcAddDataSize(MTF_DBLK_FILE_INFO *pFILEInfo);

    MTF_DATE_TIME MTF_CreateDateNull(void);

#define MTF_STRLEN 256
#define iNUMSTRINGS 5

    // Data members
    UINT16 m_uAlignmentFactor;          // Alignment factor

    // When the api formats it's own strings (i.e. file names from the WIN32_FIND_DATA,
    // we need to keep those strings somewhere so we can set the pointers to them in 
    // the info structs.  
    wchar_t m_szDeviceName[MTF_STRLEN];                     
    wchar_t m_szVolumeName[MTF_STRLEN];
    wchar_t m_szMachineName[MAX_COMPUTERNAME_LENGTH+1];
    wchar_t m_szDirectoryName[MTF_STRLEN];
    wchar_t m_szFileName[MTF_STRLEN];

    // Internal string management
    wchar_t *m_aszStrings[iNUMSTRINGS]; // we keep an array of pointers to allocated strings
                                        // this managed by ClearStrings() and MakeString()
    int      m_iNumStrings;             // the number of strings currently allocated

};


#endif  // of _MTFAPI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\mover\server\mtfsessn.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    MTFSessn.h

Abstract:

    Definition of the CMTFSession class

Author:

    Brian Dodd          [brian]         25-Nov-1997

Revision History:

--*/

#if !defined(MTFSessn_H)
#define MTFSessn_H

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "resource.h"       // main symbols
#include "mtfapi.h"

//
// REMOTE_STORAGE_MTF_VENDOR_ID       - This is the unique vendor Id assigned for Microsoft Remote Storage.
//                                      Used in Whistler (NT 5.1) and beyond
//
// REMOTE_STORAGE_WIN2K_MTF_VENDOR_ID - This is the unique vendor Id assigned
//                                      to Eastman Software (Spring, 1997), by Seagate.
//                                      Used in Win2K (NT 5.0) Remote Storage
//

#define REMOTE_STORAGE_WIN2K_MTF_VENDOR_ID      0x1300
#define REMOTE_STORAGE_MTF_VENDOR_ID            0x1515 

//
// REMOTE_STORAGE_MTF_VENDOR_NAME -- This is the vendor name used for MTF labels.
//

#define REMOTE_STORAGE_MTF_VENDOR_NAME  OLESTR("Microsoft Corporation")


//
// REMOTE_STORAGE_MTF_SOFTWARE_VERSION_MJ -- This the the major version number
//                                           for Remote Storage
//

#define REMOTE_STORAGE_MTF_SOFTWARE_VERSION_MJ   1

//
// REMOTE_STORAGE_MTF_SOFTWARE_VERSION_MN -- This the the minor version number
//                                           for Remote Storage
//
#define REMOTE_STORAGE_MTF_SOFTWARE_VERSION_MN   0

/*++

Enumeration Name:

    MTFSessionType

Description:

    Specifies a type of data set.

--*/
typedef enum MTFSessionType {
    MTFSessionTypeTransfer = 0,
    MTFSessionTypeCopy,
    MTFSessionTypeNormal,
    MTFSessionTypeDifferential,
    MTFSessionTypeIncremental,
    MTFSessionTypeDaily,
};

//
//  MVR_DEBUG_OUTPUT - Special flag used for outputing extra debug info
//

#ifdef DBG
#define MVR_DEBUG_OUTPUT TRUE
#else
#define MVR_DEBUG_OUTPUT FALSE
#endif

//
//  MrvInjectError - Special macro for allowing test running to inject
//                   device errors at specific location throughout the
//                   data mover.
//
/*++

Macro Name:

    MrvInjectError

Macro Description:

    Special macro for allowing test running to inject device errors
    at specific location throughout the data mover.

Arguments:

    injectPoint - A UNICODE string describing the injection point.

--*/

#ifdef DBG
#define MvrInjectError(injectPoint)                 \
    {                                               \
        DWORD size;                                 \
        OLECHAR tmpString[256];                     \
        if (SUCCEEDED(WsbGetRegistryValueString(NULL, RMS_REGISTRY_STRING, injectPoint, tmpString, 256, &size))) { \
            DWORD injectHr;                         \
            injectHr = wcstoul(tmpString, NULL, 16); \
            if (injectHr) {                         \
                WsbTrace(OLESTR("%ls - Injecting Error <%ls>\n"), injectPoint, WsbHrAsString(injectHr)); \
                if (IDOK == MessageBox(NULL, L"Inject error, then press OK.  Cancel skips over this injection point.", injectPoint, MB_OKCANCEL)) { \
                    if (injectHr != S_FALSE) {      \
                        WsbThrow(injectHr);         \
                    }                               \
                }                                   \
            }                                       \
        }                                           \
    }
#else
#define MvrInjectError(injectPoint)
#endif

/////////////////////////////////////////////////////////////////////////////
// CMTFSession

class CMTFSession
{
public:
    CMTFSession();
    ~CMTFSession();

    // TODO:  Add SetStream() for m_pStream, and replace m_sHints with object that supports IRemoteStorageHint

    CComPtr<IStream>        m_pStream;          // Stream used for I/O.
    MVR_REMOTESTORAGE_HINTS m_sHints;           // We keep the information need for
                                                //  optimized retrieval of the file/data.

    HRESULT SetBlockSize(UINT32 blockSize);
    HRESULT SetUseFlatFileStructure(BOOL val);
    HRESULT SetUseSoftFilemarks(BOOL val);
    HRESULT SetUseCaseSensitiveSearch(BOOL val);
    HRESULT SetCommitFile(BOOL val);

    // MTF Formatting methods
    HRESULT InitCommonHeader(void);
    HRESULT DoTapeDblk(IN WCHAR* szLabel, IN ULONG maxIdSize, IN OUT BYTE* pIdentifier, IN OUT ULONG* pIdSize, IN OUT ULONG* pIdType);
    HRESULT DoSSETDblk(IN WCHAR* szSessionName, IN WCHAR* szSessionDescription, IN MTFSessionType type, IN USHORT nDataSetNumber);
    HRESULT DoVolumeDblk(IN WCHAR* szPath);
    HRESULT DoDataSet(IN WCHAR* szPath);
    HRESULT DoParentDirectories(IN WCHAR* szPath);
    HRESULT DoDirectoryDblk(IN WCHAR* szPath, IN WIN32_FIND_DATAW* pFindData);
    HRESULT DoFileDblk(IN WCHAR* szPath, IN WIN32_FIND_DATAW* pFindData);
    HRESULT DoDataStream(IN HANDLE hStream);
    HRESULT DoEndOfDataSet(IN USHORT nDataSetNumber);
    HRESULT ExtendLastPadToNextPBA(void);

    // Read methods
    HRESULT ReadTapeDblk(OUT WCHAR **pszLabel);

    // Validate methods (for Recovery usage)
    HRESULT SkipOverTapeDblk(void);
    HRESULT SkipOverSSETDblk(OUT USHORT* pDataSetNumber);
    HRESULT SkipToDataSet(void);
    HRESULT SkipOverDataSet(void);
    HRESULT SkipOverEndOfDataSet(void);
    HRESULT PrepareForEndOfDataSet(void);

private:
    HRESULT PadToNextPBA(void);
    HRESULT PadToNextFLA(BOOL flush);

    // For Recovery usage
    HRESULT SkipOverStreams(IN UINT64 uOffsetToFirstStream);

private:

    enum {                                      // Class specific constants:
                                                //
        Version = 1,                            // Class version, this should be
                                                //   incremented each time the
                                                //   the class definition changes.
    };
    // Session data
    UINT32              m_nCurrentBlockId;      // Used for "control_block_id" in common header.
                                                //  We increment this for each dblk written.
    UINT32              m_nDirectoryId;         // Tracks the directory id used in DIRB and FILE
                                                // DBLKs.  We increment this for each directory 
                                                //  written.
    UINT32              m_nFileId;              // Tracks the file id used in FILE dblks.  We 
                                                //  increment this for each file written.
    UINT64              m_nFormatLogicalAddress;// We need to keep track of how many alignment
                                                //  indicies we are away from the SSET, as this
                                                //  info is used in the common block headers.
                                                //  We increment this for each alignment index
                                                //  written, including streams, to the device.
    UINT64              m_nPhysicalBlockAddress;// Hold onto the PBA of the beginning of the SSET.
    UINT32              m_nBlockSize;           // Physical Block Size of the media used.

    MTF_DBLK_SFMB_INFO* m_pSoftFilemarks;       // Holds Soft Filemark information.
    MTF_DBLK_HDR_INFO   m_sHeaderInfo;          // We keep one header info struct here,
                                                //  fill it in once, and then just make 
                                                //  changes as necessary as we supply it
                                                //  to MTF_Write... calls.
    MTF_DBLK_SSET_INFO  m_sSetInfo;             // We keep the data set info struct to handle
                                                //  special case DBLK formatting.
    MTF_DBLK_VOLB_INFO  m_sVolInfo;             // We keep the volume info struct to handle
                                                //  special case DBLK formatting.

    BYTE *              m_pBuffer;              // The buffer used to format data (with virtual address aligend to sectore size)
    BYTE *              m_pRealBuffer;          // The actual buffer
    size_t              m_nBufUsed;             // The number of bytes in the buffer with valid data.
    size_t              m_nBufSize;             // The size of the buffer.
    size_t              m_nStartOfPad;          // Holds the location within the transfer buffer
                                                //  of the last SPAD.

    BOOL                m_bUseFlatFileStructure;// If TRUE, Directory information is not written to
                                                //  the MTF session, and filenames are mangled
                                                //  to preserve uniqueness.
    BOOL                m_bUseSoftFilemarks;    // If TRUE, filemark emulation is turned on.
    BOOL                m_bUseCaseSensitiveSearch; // If TRUE, all filename queries are case sensitve (i.e. Posix Semantics)
    BOOL                m_bCommitFile;          // If TRUE, flushes devices buffers after file is
                                                //  written to the data set.
    BOOL                m_bSetInitialized;       // If TRUE, sSet was initialized (for detecting Recovery)

    FILE_BASIC_INFORMATION m_SaveBasicInformation;  // Basic info for last file/dir (see notes on CloseStream).
    void *              m_pvReadContext;        // Holds BackupRead context info.

    CMTFApi *           m_pMTFApi;              // Object that implements internal MTF details


    // MTF I/O abstracton methods
    HRESULT OpenStream(IN WCHAR* szPath, OUT HANDLE *pStreamHandle);
    HRESULT CloseStream(IN HANDLE hStream);

    HRESULT WriteToDataSet(IN BYTE* pBuffer, IN ULONG nBytesToWrite, OUT ULONG* pBytesWritten);
    HRESULT ReadFromDataSet(IN BYTE* pBuffer, IN ULONG nBytesToRead, OUT ULONG* pBytesRead);
    HRESULT FlushBuffer(IN BYTE* pBuffer, IN OUT size_t* pBufPosition);
    HRESULT WriteFilemarks(IN ULONG count);
    HRESULT GetCurrentPBA(OUT UINT64* pPosition);
    HRESULT SetCurrentPBA(IN UINT64 position);
    HRESULT SpaceToEOD(void);
    HRESULT SpaceToBOD(void);

};

#endif // !defined(MTFSessn_H)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\mover\server\mtfsessn.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    MTFSessn.cpp

Abstract:

    CMTFSession class

Author:

    Brian Dodd          [brian]         25-Nov-1997

Revision History:

--*/

#include "stdafx.h"
#include "engine.h"
#include "MTFSessn.h"

//
// !!!!! VERY IMPORTANT !!!!!
//
// WIN32_STREAM_ID_SIZE -- Size of WIN32_STREAM_ID (20) != sizeof(WIN32_STREAM_ID) (24)
//                         due to WIN32_STREAM_ID being a variable sized structure --
//                         See below.

#define WIN32_STREAM_ID_SIZE 20

/*****************************************************************************
DETAIL DESCRIPTION 

OVERVIEW
========
This class uses MTF API calls to create a data set.  A data set
is created by writing a series of DBLKs which may optionally be followed by
data streams.

For each DBLK, the MTF API defines a corresponding xxxx_DBLK_INFO struct 
which is filled in by the client.  This can be done field by field or by 
using an MTF API function which automatically fills in the structure with 
default information.

The xxxx_DBLK_INFO structs are then passed to MTF_WriteXXXXDblk functions which 
use the information in the struct to format a buffer, which can then be written
to the data set, using the Stream I/O Write function.

DATA SET FORMAT
===============
A data set is created by writing DBLKs and Streams in the following order:

TAPE DBLK  -- describes the media
FILEMARK
SSET DBLK  -- start of set describing the data set
VOLB DBLK  -- describs the volume being stored

for each directory and parent directory 
    DIRB DBLK  -- one for each directory/sub-directory, starting with the root
    STREAM     -- may contain security info for the directory

for each file to backup
    FILE DBLK  -- one for each file, followed by one or more streams, describing
    STREAM        security info, as well as the file data streams themselves
    STREAM 

FILEMARK
ESET DBLK  -- indicates the end of the data set

FILEMARK   -- terminates the data set



FUNCTIONS OVERVIEW
==================
The MTF session maintains various information about the data set being created.
This member data is then used by the following routines.

    InitCommonHeader()      -- Initializes the common header which is used in
                               all DBLKS is stored

    DoTapeDblk()            -- writes the TAPE DBLK 
    DoSSETDblk()            -- writes the SSET DBLK
    DoVolumeDblk()          -- writes the VOLB DBLK

    DoParentDirectories()   -- writes DIRB DBLKs and Streams for the directory
                               to backed up and each of its parent directories

    DoDirectoryDblk()       -- writes a single DIRB DBLK and associated security
                               stream

    DoDataSet()             -- writes FILE and DIRB DBLKs and associated data
                               streams for everything in the directory.
                               Recurses for sub-directories

    DoFileDblk()            -- writes a FILE DBLK

    DoDataStream()          -- writes data stream(s) associated with a file or
                               directory

    DoEndOfDataSet()        -- writes ESET DBLK and surrounding FILEMARKS


NOTES AND WARNINGS
==================
o  Directory names are stored in DIRB DBLKs as "DIR\SUBDIR1\...\SUBDIRn\" 
   (no vol, and with a trailing \) where as filenames are stored in 
   FILE DBLKS just as "FILENAME.EXT"

o  In DIRB's, the backslashes between directory names are covnerted to L'\0'!!!!!
   (the mtf api takes care of this -- give it names with slashes!!!!)

o  All strings are assumed to be WCHAR by the MTF API

o  We assume here that __uint64 is supported by the compiler.

*****************************************************************************/

static USHORT iCountMTFs = 0;  // Count of existing objects


CMTFSession::CMTFSession(void)
{
    WsbTraceIn(OLESTR("CMTFSession::CMTFSession"), OLESTR(""));

    // public
    m_pStream = NULL;
    memset(&m_sHints, 0, sizeof(MVR_REMOTESTORAGE_HINTS));

    // private
    m_nCurrentBlockId = 0;
    m_nDirectoryId = 0;
    m_nFileId = 0;
    m_nFormatLogicalAddress = 0;
    m_nPhysicalBlockAddress = 0;

    m_nBlockSize = 0;

    m_pSoftFilemarks = NULL;

    memset (&m_sHeaderInfo, 0, sizeof(MTF_DBLK_HDR_INFO));
    memset (&m_sSetInfo, 0, sizeof(MTF_DBLK_SSET_INFO));
    memset (&m_sVolInfo, 0, sizeof(MTF_DBLK_VOLB_INFO));

    m_pBuffer = NULL;
    m_pRealBuffer = NULL;
    m_nBufUsed = 0;
    m_nBufSize = 0;
    m_nStartOfPad = 0;

    m_bUseFlatFileStructure = FALSE;
    m_bUseSoftFilemarks = FALSE;
    m_bUseCaseSensitiveSearch = FALSE;
    m_bCommitFile = FALSE;
    m_bSetInitialized = FALSE;

    memset (&m_SaveBasicInformation, 0, sizeof(FILE_BASIC_INFORMATION));

    m_pvReadContext = NULL;

    // Create an MTFApi object 
    m_pMTFApi = new CMTFApi;

    iCountMTFs++;
    WsbTraceOut(OLESTR("CMTFSession::CMTFSession"),OLESTR("Count is <%d>"), iCountMTFs);
}



CMTFSession::~CMTFSession(void)
{
    WsbTraceIn(OLESTR("CMTFSession::~CMTFSession"), OLESTR(""));

    if (m_pMTFApi) {
        delete m_pMTFApi;
        m_pMTFApi = NULL;
    }

    if (m_pSoftFilemarks) {
        WsbFree(m_pSoftFilemarks);
        m_pSoftFilemarks = NULL;
    }

    if (m_pRealBuffer) {
        WsbFree(m_pRealBuffer);
        m_pBuffer = NULL;
        m_pRealBuffer = NULL;
    }

    iCountMTFs--;
    WsbTraceOut(OLESTR("CMTFSession::~CMTFSession"),OLESTR("Count is <%d>"), iCountMTFs);
}

////////////////////////////////////////////////////////////////////////////////
//
// Local Methods
//

HRESULT
CMTFSession::SetBlockSize(
    UINT32 blockSize)
/*++

Routine Description:

    Defines the physical block size for the session.  This is used for various PBA calculations.
    The value should only be set once per session.

Arguments:

    blockSize   -  The new block size for the session.

Return Value:

    S_OK        -  Success.

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CMTFSession::SetBlockSize"), OLESTR("<%d>"), blockSize);

    ULONG bufferSize = 0;

    try {
        WsbAssert(blockSize > 0, E_INVALIDARG);
        WsbAssert(!(blockSize % 512), E_INVALIDARG);

        m_nBlockSize = blockSize;

        // **MTF API CALL**
        // The MTF API needs to know the alignment factor!!!!!!!
        //
        WsbAssert(m_pMTFApi != NULL, E_OUTOFMEMORY);

        if (!(blockSize % 1024)) {
            m_pMTFApi->MTF_SetAlignmentFactor((UINT16) 1024);
        }
        else {
            // We already checked that the block size is a multiple of 512....
            m_pMTFApi->MTF_SetAlignmentFactor((UINT16) 512);
        }

        ULONG defaultBufferSize = RMS_DEFAULT_BUFFER_SIZE;

        DWORD size;
        OLECHAR tmpString[256];
        if (SUCCEEDED(WsbGetRegistryValueString(NULL, RMS_REGISTRY_STRING, RMS_PARAMETER_BUFFER_SIZE, tmpString, 256, &size))) {
            // Get the value.
            LONG val = wcstol(tmpString, NULL, 10);
            if (val > 0) {
                defaultBufferSize = val;
            }
        }

        ULONG nBlocks = defaultBufferSize/m_nBlockSize;
        nBlocks = (nBlocks < 2) ? 2 : nBlocks;
        bufferSize = nBlocks * m_nBlockSize;

        // Make sure we work with a virtual address aligned with sector size
        m_pRealBuffer = (BYTE *)WsbAlloc(bufferSize+m_nBlockSize);
        if (m_pRealBuffer) {
            if ((ULONG_PTR)m_pRealBuffer % m_nBlockSize) {
                m_pBuffer = m_pRealBuffer - ((ULONG_PTR)m_pRealBuffer % m_nBlockSize) + m_nBlockSize;
            } else {
                m_pBuffer = m_pRealBuffer;
            }
        } else {
            m_pBuffer = NULL;
        }

        WsbTrace(OLESTR("CMTFSession::SetBlockSize: Real Buffer Ptr = %I64X , Use Buffer Ptr = %I64X\n"), 
            (UINT64)m_pRealBuffer, (UINT64)m_pBuffer);

        if (m_pBuffer) {
            m_nBufSize = bufferSize;
            m_nBufUsed = 0;
        }
        else {
            m_nBufSize = 0;
            m_nBufUsed = bufferSize;
        }

        WsbAssertPointer(m_pBuffer);

        WsbTraceAlways( OLESTR("Using buffer size of %d bytes for data transfers.\n"), bufferSize);

    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CMTFSession::SetBlockSize"), OLESTR("hr = <%ls>, Alignment = %d, BufferSize = %d"), WsbHrAsString(hr), m_pMTFApi->MTF_GetAlignmentFactor(), bufferSize);

    return hr;
}


HRESULT
CMTFSession::SetUseFlatFileStructure(
    BOOL val)
/*++

Routine Description:

    Unconditionally sets the session flags to the value specified.

Arguments:

    val         -  The new value for the UseFlatFileStructure flag.

Return Value:

    S_OK        -  Success.

--*/
{
    m_bUseFlatFileStructure = val;

    return S_OK;
}



HRESULT
CMTFSession::SetUseCaseSensitiveSearch(
    BOOL val)
/*++

Routine Description:

    Unconditionally sets the session flag to the value specified.

Arguments:

    val         -  The new value for the CaseSensitiveSearch flag.

Return Value:

    S_OK        -  Success.

--*/
{
    m_bUseCaseSensitiveSearch = val;

    return S_OK;
}



HRESULT
CMTFSession::SetCommitFile(
    BOOL val)
/*++

Routine Description:

    Unconditionally sets the session flag to the value specified.

Arguments:

    val         -  The new value for the CommitFile flag.

Return Value:

    S_OK        -  Success.

--*/
{
    m_bCommitFile = val;

    return S_OK;
}


HRESULT
CMTFSession::SetUseSoftFilemarks(
    BOOL val)
/*++

Routine Description:

    Unconditionally sets the session flags to the value specified.

Arguments:

    val         -  The new value for the UseSoftFilemarks flag.

Return Value:

    S_OK        -  Success.

--*/
{
    HRESULT hr = S_OK;

    try {
        m_bUseSoftFilemarks = val;

        if (TRUE == m_bUseSoftFilemarks) {
            WsbAssert(NULL == m_pSoftFilemarks, E_UNEXPECTED);

            // Make sure the block size was initialized.
            WsbAssert(m_nBlockSize > 0, E_UNEXPECTED);

            // Allocate a block of memory for the soft filemark array
            m_pSoftFilemarks = (MTF_DBLK_SFMB_INFO *) WsbAlloc(m_nBlockSize);
            WsbAffirmPointer(m_pSoftFilemarks);
            memset(m_pSoftFilemarks, 0 , m_nBlockSize);

            // **MTF API CALL**
            m_pSoftFilemarks->uNumberOfFilemarkEntries = m_pMTFApi->MTF_GetMaxSoftFilemarkEntries(m_nBlockSize);
            WsbAssert(m_pSoftFilemarks->uNumberOfFilemarkEntries > 0, E_UNEXPECTED);
        }
        else {
            if (m_pSoftFilemarks) {
                WsbFree(m_pSoftFilemarks);
                m_pSoftFilemarks = NULL;
            }
        }

    } WsbCatch(hr);

    return hr;
}


HRESULT
CMTFSession::InitCommonHeader(void)
/*++

Routine Description:

    Sets up the common header.

    m_sHeaderInfo is set for unicode, NT & no block
    attributes

Arguments:

    None.

Return Value:

    S_OK        -  Success.

--*/
{

    // Init Common header
    // **MTF API CALL**
    m_pMTFApi->MTF_SetDblkHdrDefaults(&m_sHeaderInfo);

    m_sHeaderInfo.uBlockAttributes = 0;
    m_sHeaderInfo.uOSID            = MTF_OSID_DOS; // MTF_OSID_NT or MTF_OSID_DOS
    m_sHeaderInfo.uStringType      = MTF_STRING_UNICODE_STR;

    return S_OK;
}


HRESULT
CMTFSession::DoTapeDblk(
    IN WCHAR *szLabel,
    IN ULONG maxIdSize,
    IN OUT BYTE *pIdentifier,
    IN OUT ULONG *pIdSize,
    IN OUT ULONG *pIdType)
/*++

Routine Description:

    Formats and Writes a TAPE DBLK.  TAPE DBLK and
    FILEMARK are written to beginning of tape, disk, or file.
 
Arguments:

    szLabel     -  The media label.

Return Value:

    S_OK        -  Success.

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CMTFSession::DoTapeDblk"), OLESTR("<%ls>"), szLabel);

    try {
        MvrInjectError(L"Inject.CMTFSession::DoTapeDblk.0");

        WsbAssertPointer(m_pBuffer);

        if ( maxIdSize > 0 ) {
            WsbAssertPointer( pIdentifier );
            WsbAssertPointer( pIdSize );
            WsbAssertPointer( pIdType );
        }

        MTF_DBLK_TAPE_INFO  sTapeInfo;           // **MTF API STRUCT ** -- info for TAPE

        (void) InitCommonHeader();

        // **MTF API CALL**
        // First set defaults for the info struct
        //
        // Note: Tthis sets the alignment factor to that set previously by 
        //        MTF_SetAlignmentFactor()
        m_pMTFApi->MTF_SetTAPEDefaults(&sTapeInfo);

        // Set the values of the MTF_DBLK_TAPE_INFO struct to suit our application

        // Set SFMB size, this should be used during restoration on media types that use SFM
        sTapeInfo.uSoftFilemarkBlockSize = (UINT16)(m_nBlockSize / 512);

        // The family id should be a unique value for each piece of media.  Although not
        //  guaranteed to be unique, the time function should provide something close enough.
        time_t tTime;

        sTapeInfo.uTapeFamilyId        = (unsigned int) time(&tTime);
        sTapeInfo.uTapeAttributes     |= MTF_TAPE_MEDIA_LABEL;

        if (TRUE == m_bUseSoftFilemarks) {
            sTapeInfo.uTapeAttributes |= MTF_TAPE_SOFT_FILEMARK;
        }

        sTapeInfo.uTapeSequenceNumber  = 1;
        sTapeInfo.szTapeDescription    = szLabel;
        sTapeInfo.uSoftwareVendorId    = REMOTE_STORAGE_MTF_VENDOR_ID;

        //
        // Get remaining information from the label
        //

        CWsbBstrPtr tempLabel = szLabel;
        WCHAR delim[]   = OLESTR("|");
        WCHAR *token;
        int   index=0;

        token = wcstok( (WCHAR *)tempLabel, delim );
        while( token != NULL ) {

            index++;

            switch ( index ) {
            case 1: // Tag
            case 2: // Version
            case 3: // Vendor
                break;
            case 4: // Vendor Product ID
                sTapeInfo.szSoftwareName = token;
                break;
            case 5: // Creation Time Stamp
                {
                    int iYear, iMonth, iDay, iHour, iMinute, iSecond;
                    swscanf( token, L"%d/%d/%d.%d:%d:%d", &iYear, &iMonth, &iDay, &iHour, &iMinute, &iSecond );
                    // **MTF API CALL**
                    sTapeInfo.sTapeDate = m_pMTFApi->MTF_CreateDateTime( iYear, iMonth, iDay, iHour, iMinute, iSecond );
                }
                break;
            case 6: // Cartridge Label
                sTapeInfo.szTapeName = token;
                break;
            case 7: // Side
            case 8: // Media ID
            case 9: // Media Domain ID
            default: // Vendor specific of the form L"VS:Name=Value"
                break;
            }

            token = wcstok( NULL, delim );

        }

        // These are zero for the tape dblk
        m_sHeaderInfo.uControlBlockId       = 0;
        m_sHeaderInfo.uFormatLogicalAddress = 0;

        WsbTrace(OLESTR("Writing Tape Header (TAPE)\n"));

        // Sets the current position to beginning of data.
        WsbAffirmHr(SpaceToBOD());

        // **MTF API CALL**
        // Provide the MTF_DBLK_HDR_INFO and MTF_DBLK_TAPE_INFO structs to this
        // function.  The result is an MTF formatted TAPE DBLK in m_pBuffer.
        WsbAssert(0 == m_nBufUsed, MVR_E_LOGIC_ERROR);
        WsbAssertNoError(m_pMTFApi->MTF_WriteTAPEDblk(&m_sHeaderInfo, &sTapeInfo, m_pBuffer, m_nBufSize, &m_nBufUsed));

        WsbTrace(OLESTR("Tape Header uses %lu of %lu bytes\n"), (ULONG)m_nBufUsed, (ULONG)m_nBufSize);

        // Save the on media identifier
        if (maxIdSize > 0) {
            *pIdSize = (maxIdSize > (ULONG)m_nBufUsed) ? (ULONG)m_nBufUsed : maxIdSize;
            *pIdType = (LONG) RmsOnMediaIdentifierMTF;
            memcpy(pIdentifier, m_pBuffer, *pIdSize);
        }

        WsbAffirmHr(PadToNextPBA());

        // Write a filemark.  This will flush the device buffer.
        WsbAffirmHr(WriteFilemarks(1));

    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CMTFSession::DoTapeDblk"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


HRESULT
CMTFSession::DoSSETDblk(
    IN WCHAR *szSessionName,
    IN WCHAR *szSessionDescription,
    IN MTFSessionType type,
    IN USHORT nDataSetNumber)
/*++

Routine Description:

    Formats and Writes a SSET DBLK.  The SSET is the first DBLK written
    to a data set.

Arguments:

    szSessionName   -  Session name.
    szSessionDescription - Session description that is displayed by the Backup program
    type            -  Specifies the data set type: Transfer, copy , normal, differential,
                       incremental, daily, etc.
    nDataSetNumber  -  The data set number.

Return Value:

    S_OK        -  Success.

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CMTFSession::DoSSETDblk"), OLESTR("<%ls> <%ls> <%d> <%d>"), szSessionName, szSessionDescription, type, nDataSetNumber);

    try {
        MvrInjectError(L"Inject.CMTFSession::DoSSETDblk.0");

        WsbAssertPointer(m_pBuffer);

        UINT64  curPos;
        size_t  nBufUsed = 0;

        // Reset Control Block info.

        m_nCurrentBlockId = 0;
        m_nDirectoryId = 0;
        m_nFileId = 0;

        (void) InitCommonHeader();

        // Init SSET block
        // **MTF API CALL**
        m_pMTFApi->MTF_SetSSETDefaults(&m_sSetInfo);
        m_bSetInitialized = TRUE;

        //
        // Find out our account information
        //
        CWsbStringPtr accountName;
        WsbAffirmHr(WsbGetServiceInfo(APPID_RemoteStorageEngine, NULL, &accountName));

        //
        // Set the values of the MTF_DBLK_SSET_INFO struct...
        //

        // First select the type of data set we are creating.
        switch (type) {
        case MTFSessionTypeTransfer:
            m_sSetInfo.uSSETAttributes = MTF_SSET_TRANSFER;
            break;

        case MTFSessionTypeCopy:
            m_sSetInfo.uSSETAttributes = MTF_SSET_COPY;
            break;

        case MTFSessionTypeNormal:
            m_sSetInfo.uSSETAttributes = MTF_SSET_NORMAL;
            break;

        case MTFSessionTypeDifferential:
            m_sSetInfo.uSSETAttributes = MTF_SSET_DIFFERENTIAL;
            break;

        case MTFSessionTypeIncremental:
            m_sSetInfo.uSSETAttributes = MTF_SSET_INCREMENTAL;
            break;

        case MTFSessionTypeDaily:
            m_sSetInfo.uSSETAttributes = MTF_SSET_DAILY;
            break;

        default:
            WsbThrow(E_INVALIDARG);
            break;
        }

        m_sSetInfo.uDataSetNumber        = nDataSetNumber;
        m_sSetInfo.uSoftwareVendorId     = REMOTE_STORAGE_MTF_VENDOR_ID;
        m_sSetInfo.szDataSetName         = szSessionName;
        m_sSetInfo.szDataSetDescription  = szSessionDescription;
        m_sSetInfo.szUserName            = accountName;
        WsbAffirmHr(GetCurrentPBA(&curPos)); // utility fn below
        m_sSetInfo.uPhysicalBlockAddress = curPos;
        m_sSetInfo.uPhysicalBlockAddress += 1 ;  // MTF is one based, devices are zero based.
        m_sSetInfo.uSoftwareVerMjr       = REMOTE_STORAGE_MTF_SOFTWARE_VERSION_MJ;
        m_sSetInfo.uSoftwareVerMnr       = REMOTE_STORAGE_MTF_SOFTWARE_VERSION_MN;

        // Save the PBA for the data set
        m_nPhysicalBlockAddress = m_sSetInfo.uPhysicalBlockAddress -1;
        WsbAssert(m_nPhysicalBlockAddress > 0, E_UNEXPECTED);  // Someting went wrong!
        m_nFormatLogicalAddress = 0;

        // The Control Block ID field is used for error recovery.  The 
        // Control Block ID value for an SSET DBLK should be zero.  All 
        // subsequent DBLKs within the Data Set will have a Control Block
        // ID one greater than the previous DBLKs Control Block ID.
        // Values for this field are only defined for DBLKs within a Data
        // Set from the SSET to the last DBLK occurring prior to the ESET.
        WsbAssert(0 == m_nCurrentBlockId, E_UNEXPECTED);
        m_sHeaderInfo.uControlBlockId = m_nCurrentBlockId++;

        // Increment them here after for every dblk we write
        m_sHeaderInfo.uFormatLogicalAddress = 0;

        WsbTrace(OLESTR("Writing Start of Set (SSET) @ PBA %I64u\n"), m_nPhysicalBlockAddress);

        // **MTF API CALL** -- 
        // Provide the MTF_DBLK_HDR_INFO and MTF_DBLK_SSET_INFO structs to
        // this function.  The result is an MTF formatted SSET DBLK in m_pBuffer.
        WsbAssert(0 == m_nBufUsed, MVR_E_LOGIC_ERROR);
        WsbAssertNoError(m_pMTFApi->MTF_WriteSSETDblk(&m_sHeaderInfo, &m_sSetInfo, m_pBuffer, m_nBufSize, &m_nBufUsed));

        // We pass in FALSE to make sure we don't actually touch tape.  The SSET is the
        // first DBLK written in the data set so we have plenty of transfer buffer for
        // the DBLKs to follow.
        //
        // This routine is called when the application starts a new data set, but
        // we don't wan't to fail if we're going to get device errors, that will come
        // later.
        WsbAffirmHr(PadToNextFLA(FALSE));

        m_sHints.DataSetStart.QuadPart = m_nPhysicalBlockAddress * m_nBlockSize;

    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CMTFSession::DoSSETDblk"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


HRESULT
CMTFSession::DoVolumeDblk(
    IN WCHAR *szPath)
/*++

Routine Description:

    Formats and Writes a VOLB DBLK.

Arguments:

    szPath      -  Full pathname containing name of volume.

Return Value:

    S_OK        -  Success.

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CMTFSession::DoVolumeDblk"), OLESTR("<%ls>"), WsbAbbreviatePath(szPath, 120));

    try {
        MvrInjectError(L"Inject.CMTFSession::DoVolumeDblk.0");

        WsbAssertPointer(m_pBuffer);
        WsbAssertPointer(szPath);

        CWsbStringPtr       szVolume;
        size_t              nMoreBufUsed;

        szVolume = szPath;
        WsbAffirm(0 != (WCHAR *)szVolume, E_OUTOFMEMORY);
        WsbAssert(m_nBlockSize > 0, MVR_E_LOGIC_ERROR);
        
        // Make sure we are aligned with a FLA (i.e. the last DBLK was properly padded).
        // It won't be if we are having problems writing to tape.
        UINT16 uAlignmentFactor = m_pMTFApi->MTF_GetAlignmentFactor();
        WsbAffirm(0 == (m_nBufUsed % uAlignmentFactor), E_ABORT);
        UINT64 fla = m_nFormatLogicalAddress + m_nBufUsed/uAlignmentFactor;
        UINT64 pba = m_nPhysicalBlockAddress + (fla*uAlignmentFactor/m_nBlockSize);
        WsbTrace(OLESTR("%ls (VOLB) @ FLA %I64u (%I64u, %I64u)\n"), WsbAbbreviatePath(szPath, 120),
            fla, pba, fla % (m_nBlockSize/uAlignmentFactor));

        // **MTF API CALL**

        // Sets the MTF_VOLB_DBLK_INFO struct using Win32 GetVolumeInformation data
        m_pMTFApi->MTF_SetVOLBForDevice(&m_sVolInfo, szVolume);

        // Increment the blockid and alignment index values that we keep in 
        // our common block header structure.
        m_sHeaderInfo.uControlBlockId       = m_nCurrentBlockId++;
        m_sHeaderInfo.uFormatLogicalAddress = fla;

        WsbAffirmHr(FlushBuffer(m_pBuffer, &m_nBufUsed));

        // **MTF API CALL**
        // Provide the MTF_DBLK_HDR_INFO and MTF_DBLK_VOLB_INFO structs to
        // this function.  The result is an MTF formatted VOLB DBLK in m_pBuffer.
        nMoreBufUsed = 0;
        WsbAssertNoError(m_pMTFApi->MTF_WriteVOLBDblk(&m_sHeaderInfo, &m_sVolInfo, m_pBuffer+m_nBufUsed, m_nBufSize-m_nBufUsed, &nMoreBufUsed));
        m_nBufUsed += nMoreBufUsed;

        // Output VOLB to the data set.
        WsbAffirmHr(PadToNextFLA(TRUE));

    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CMTFSession::DoVolumeDblk"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


HRESULT
CMTFSession::DoParentDirectories(
    IN WCHAR *szPath)
/*++

Routine Description:

    Formats and writes the parent DIRB Dblks for the given pathname.

Arguments:

    szPath      -  Full pathname of directory.

Return Value:

    S_OK        -  Success.


Note:

    In order for both stickyName and driveLetter-colon path formats to work properly, both with and
    without writing separate DIRBs for the parent directories,
    THE EXISTENCE AND PLACEMENT OF THE PATH MANIPULATION CODE (APPEND/PREPEND, ETC.) IS CRUCIAL!!!

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CMTFSession::DoParentDirectories"), OLESTR("<%ls>"), WsbAbbreviatePath(szPath, 120));

    HANDLE hSearchHandle = INVALID_HANDLE_VALUE;

    try {
        MvrInjectError(L"Inject.CMTFSession::DoParentDirectories.0");

        WsbAssertPointer( szPath );

        WIN32_FIND_DATAW    obFindData;

        CWsbStringPtr  path;
        CWsbStringPtr  nameSpace;
        WCHAR *szDirs;
        WCHAR *token;

        DWORD additionalSearchFlags = 0;
        additionalSearchFlags |= (m_bUseCaseSensitiveSearch) ? FIND_FIRST_EX_CASE_SENSITIVE : 0;

        nameSpace = szPath;
        nameSpace.GiveTo(&szDirs);

        // First we need to do a DIRB dblk for the root directory
        nameSpace = wcstok(szDirs, OLESTR("\\"));  // pop off "Volume{......}" or "driveLetter:"
        WsbAffirmHr(nameSpace.Append(OLESTR("\\")));

        // ** WIN32 API Call - gets directory info for the root directory
        // For the root directory only, we need to call GetFileInformationByHandle instead of
        // ..FindFirstFileEx.  FindFirst doesn't return root dir info since the root has no parent 
        path = nameSpace;
        WsbAffirmHr(path.Prepend(OLESTR("\\\\?\\")));
        WsbAffirm(0 != (WCHAR *)path, E_OUTOFMEMORY);
        BY_HANDLE_FILE_INFORMATION obGetFileInfoData;
        memset(&obGetFileInfoData, 0, sizeof(BY_HANDLE_FILE_INFORMATION));
        WsbAffirmHandle(hSearchHandle = CreateFile(path, 0, 0, NULL, OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, NULL));
        WsbAffirmStatus(GetFileInformationByHandle(hSearchHandle, &obGetFileInfoData));
        FindClose(hSearchHandle);
        hSearchHandle = INVALID_HANDLE_VALUE;

        // At time of this writing CreateTime for root dir is bogus.  (bills 10/20/98).
        WsbTrace(OLESTR("Create Time      = <%ls>\n"), WsbFiletimeAsString(FALSE, obGetFileInfoData.ftCreationTime));
        WsbTrace(OLESTR("Last Access Time = <%ls>\n"), WsbFiletimeAsString(FALSE, obGetFileInfoData.ftLastAccessTime));
        WsbTrace(OLESTR("Last Write Time  = <%ls>\n"), WsbFiletimeAsString(FALSE, obGetFileInfoData.ftLastWriteTime));

        // copy info from GetFileInformationByHandle call (BY_HANDLE_FILE_INFORMATION struct)
        // .. into obFindData (WIN32_FIND_DATAW struct) for DoDirectoryDblk call.
        memset(&obFindData, 0, sizeof(WIN32_FIND_DATAW));
        obFindData.dwFileAttributes = obGetFileInfoData.dwFileAttributes;
        obFindData.ftCreationTime   = obGetFileInfoData.ftCreationTime;
        obFindData.ftLastAccessTime = obGetFileInfoData.ftLastAccessTime;
        obFindData.ftLastWriteTime  = obGetFileInfoData.ftLastWriteTime;

        WsbAffirmHr(DoDirectoryDblk(nameSpace, &obFindData));


        // Now do the same for each succeeding directory in the path using strtok

        token = wcstok(0, OLESTR("\\"));            // pop off first subdir

        for ( ; token; token = wcstok(0, OLESTR("\\"))) {

            nameSpace.Append(token);

            path = nameSpace;
            path.Prepend(OLESTR("\\\\?\\"));

            WsbAssertHandle(hSearchHandle = FindFirstFileEx((WCHAR *) path, FindExInfoStandard, &obFindData, FindExSearchLimitToDirectories, 0, additionalSearchFlags));

            if ( obFindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) {

                nameSpace.Append(OLESTR("\\"));     // add in \ to dir
                WsbAffirmHr(DoDirectoryDblk((WCHAR *) nameSpace, &obFindData)); 

            }

            FindClose(hSearchHandle);
            hSearchHandle = INVALID_HANDLE_VALUE;
        }

        nameSpace.TakeFrom(szDirs, 0); // cleanup

    } WsbCatch(hr);

    if (hSearchHandle != INVALID_HANDLE_VALUE) {
        FindClose(hSearchHandle);
    }


    WsbTraceOut(OLESTR("CMTFSession::DoParentDirectories"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


HRESULT
CMTFSession::DoDataSet(
    IN WCHAR *szPath)
/*++

Routine Description:

    Recurses through all the items contained in the directory
    specified by path and backs them up calling DoFileDblk and 
    DoDirectoryDblk

Arguments:

    szPath      -  Full pathname of directory.

Return Value:

    S_OK            -  Success.
    MVR_E_NOT_FOUND -  Object not found.

--*/
{
    HRESULT hr = MVR_E_NOT_FOUND;
    WsbTraceIn(OLESTR("CMTFSession::DoDataSet"), OLESTR("<%ls>"), WsbAbbreviatePath(szPath, 120));

    HANDLE hSearchHandle = INVALID_HANDLE_VALUE;

    try {
        MvrInjectError(L"Inject.CMTFSession::DoDataSet.0");

        WsbAssertPointer( szPath );

        WIN32_FIND_DATAW obFindData;
        BOOL bMoreFiles;

        CWsbStringPtr nameSpace;
        CWsbStringPtr pathname;

        // check if the specification is for file(s):  nameSpace = c:\dir\test*.* or c:\dir\test1.tst
        nameSpace = szPath;
        WsbAffirmHr(nameSpace.Prepend(OLESTR("\\\\?\\")));

        DWORD additionalSearchFlags = 0;
        additionalSearchFlags |= (m_bUseCaseSensitiveSearch) ? FIND_FIRST_EX_CASE_SENSITIVE : 0;

        WsbAssertHandle(hSearchHandle = FindFirstFileEx((WCHAR *) nameSpace, FindExInfoStandard, &obFindData, FindExSearchNameMatch, 0, additionalSearchFlags));

        for (bMoreFiles = TRUE; 
             hSearchHandle != INVALID_HANDLE_VALUE && bMoreFiles; 
             bMoreFiles = FindNextFileW(hSearchHandle, &obFindData)) {

            // Skip all directories
            if ((obFindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0) {  // Not a dir

                CWsbStringPtr path;

                WCHAR *end;
                LONG numChar;

                // use the szPath to get the pathname, then append the filename
                pathname = szPath;
                WsbAffirm(0 != (WCHAR *)pathname, E_OUTOFMEMORY);
                end = wcsrchr((WCHAR *)pathname, L'\\');
                WsbAssert(end != NULL, MVR_E_INVALIDARG);
                numChar = (LONG)(end - (WCHAR *)pathname + 1);
                WsbAssert(numChar > 0, E_UNEXPECTED);
                WsbAffirmHr(path.Alloc(numChar + MAX_PATH));
                wcsncpy((WCHAR *)path, (WCHAR *)pathname, numChar);
                ((WCHAR *)path)[numChar] = L'\0';
                path.Append(obFindData.cFileName);

                WsbAffirmHr(hr = DoFileDblk((WCHAR *)path, &obFindData));
            }
        }

        // close search handle after processing all the files
        FindClose(hSearchHandle);
        hSearchHandle = INVALID_HANDLE_VALUE;

        // process all files for this directory:  nameSpace = c:\dir
        nameSpace = szPath;
        nameSpace.Append(OLESTR("\\*.*"));
        nameSpace.Prepend(OLESTR("\\\\?\\"));
        hSearchHandle = FindFirstFileEx((WCHAR *) nameSpace, FindExInfoStandard, &obFindData, FindExSearchNameMatch, 0, additionalSearchFlags);

        for (bMoreFiles = TRUE; 
             hSearchHandle != INVALID_HANDLE_VALUE && bMoreFiles; 
             bMoreFiles = FindNextFileW(hSearchHandle, &obFindData)) {

            if ((obFindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0) {

                // use the szPath to get the pathname, then append the filename
                pathname = szPath;
                pathname.Append(OLESTR("\\"));
                pathname.Append(obFindData.cFileName);

                WsbAffirmHr(hr = DoFileDblk((WCHAR *)pathname, &obFindData));
            }
        }

        // close search handle after processing all the files
        FindClose(hSearchHandle);
        hSearchHandle = INVALID_HANDLE_VALUE;

        // process all directories in this directory:  nameSpace = c:\dir
        nameSpace = szPath;
        nameSpace.Append(OLESTR("\\*.*"));
        nameSpace.Prepend(OLESTR("\\\\?\\"));
        hSearchHandle = FindFirstFileEx((WCHAR *) nameSpace, FindExInfoStandard, &obFindData, FindExSearchNameMatch, 0, additionalSearchFlags);

        for (bMoreFiles = TRUE; 
             hSearchHandle != INVALID_HANDLE_VALUE && bMoreFiles; 
             bMoreFiles = FindNextFileW(hSearchHandle, &obFindData)) {

            // Recursively handle any directories other than . and ..
            if (((obFindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0) &&
                (wcscmp(obFindData.cFileName, OLESTR(".")) != 0) &&
                (wcscmp(obFindData.cFileName, OLESTR("..")) != 0)) {

                // append the directory name to pathname
                pathname = szPath;
                pathname.Append(OLESTR("\\"));
                pathname.Append(obFindData.cFileName);
                pathname.Append(OLESTR("\\"));

                WsbAffirmHr(hr = DoDirectoryDblk((WCHAR *) pathname, &obFindData));

                // append the directory name to pathname and process
                pathname = szPath;
                pathname.Append(OLESTR("\\"));
                pathname.Append(obFindData.cFileName);

                WsbAffirmHr(DoDataSet((WCHAR *) pathname));
            }
        }
    } WsbCatch(hr);

    // close search handle after processing all the directories
    if (hSearchHandle != INVALID_HANDLE_VALUE) {
        FindClose(hSearchHandle);
    }


    WsbTraceOut(OLESTR("CMTFSession::DoDataSet"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


HRESULT
CMTFSession::DoDirectoryDblk(
    IN WCHAR *szPath,
    IN WIN32_FIND_DATAW *pFindData)
/*++

Routine Description:

    Writes out a DIRB DBLK and calls DoStream to write out
    associated stream data.

Arguments:

    szPath      -  Full pathname of directory.
    pFindData   -  WIN32 information about the directiory.

Return Value:

    S_OK        -  Success.

Note:

    In order for both stickyName and driveLetter-colon path formats to work properly, both with and
    without writing separate DIRBs for the parent directories,
    THE EXISTENCE AND PLACEMENT OF THE PATH MANIPULATION CODE (APPEND/PREPEND, ETC.) IS CRUCIAL!!!

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CMTFSession::DoDirectoryDblk"), OLESTR(""));

    HANDLE hStream = INVALID_HANDLE_VALUE;

    try {
        MvrInjectError(L"Inject.CMTFSession::DoDirectoryDblk.0");

        WsbAssertPointer(m_pBuffer);
        WsbAssertPointer(szPath);

        MTF_DBLK_DIRB_INFO  sDIRB;  // **MTF API STRUCT ** -- info for DIRB
        PWCHAR              pSlash;
        size_t              nMoreBufUsed;

        WCHAR               *end;

        WsbAssert(m_nBlockSize > 0, MVR_E_LOGIC_ERROR);

        // Make sure we are aligned with a FLA (i.e. the last DBLK was properly padded).
        // It won't be if we are having problems writing to tape.
        UINT16 uAlignmentFactor = m_pMTFApi->MTF_GetAlignmentFactor();
        WsbAffirm(0 == (m_nBufUsed % uAlignmentFactor), E_ABORT);
        UINT64 fla = m_nFormatLogicalAddress + m_nBufUsed/uAlignmentFactor;
        UINT64 pba = m_nPhysicalBlockAddress + (fla*uAlignmentFactor/m_nBlockSize);
        WsbTrace(OLESTR("%ls (DIRB) @ FLA %I64u (%I64u, %I64u)\n"), WsbAbbreviatePath(szPath, 120),
            fla, pba, fla % (m_nBlockSize/uAlignmentFactor));

        CWsbStringPtr path = szPath;

        // tack on trailing backslash if not already there
        end = wcsrchr((WCHAR *)path, L'\0');
        WsbAssert(end != NULL, MVR_E_INVALIDARG);  // Something went wrong!
        if(*(end-1) != L'\\') { 
            path.Append(OLESTR("\\"));
        }

        // Get a handle to the directory.  If this fails we need to skip everything else.
        WsbAffirmHr(OpenStream(path, &hStream));

        // **MTF API CALL**
        // automatically fill in the MTF_DIRB_DBLK_INFO structure using
        // information in the pFindData structure
        //
        // if we are getting something in the form of "C:\", 
        //      then we want to send the name along as just "\"
        // otherwise
        //      we want to send the full path, but omit the volume ("C:\")
        //      thus the "+3"

        pSlash = wcschr(path, L'\\');
        WsbAssert(pSlash != NULL, MVR_E_INVALIDARG);  // Something went wrong!
        pSlash++;                       // Look for the second one
        pSlash = wcschr(pSlash, L'\\');
        if (NULL == pSlash) {
            // It's just the volume name and nothing more
            m_pMTFApi->MTF_SetDIRBFromFindData(&sDIRB, OLESTR("\\"), pFindData);
        }
        else {
            pSlash = wcschr(path, L'\\');  // point to first backslash (beginning of path)
            m_pMTFApi->MTF_SetDIRBFromFindData(&sDIRB, pSlash + 1, pFindData);
        }


        // Check if we need to set the Backup Date field for the DIRB
        if (m_sSetInfo.uSSETAttributes & MTF_SSET_NORMAL) {

            time_t tTime;
            time(&tTime);
            
            sDIRB.sBackupDate = m_pMTFApi->MTF_CreateDateTimeFromTM(gmtime(&tTime));
        }


        // make sure to mark and update the directory id as well as the
        // control block id and alignment is already correct
        sDIRB.uDirectoryId                  = ++m_nDirectoryId;
        m_sHeaderInfo.uControlBlockId       = m_nCurrentBlockId++;
        m_sHeaderInfo.uFormatLogicalAddress = fla;

        // Add in OS Specific data
        MTF_DIRB_OS_NT_0 sOSNT;

        switch ( m_sHeaderInfo.uOSID ) {
        case MTF_OSID_NT:
            sOSNT.uDirectoryAttributes = sDIRB.uDirectoryAttributes;
            m_sHeaderInfo.pvOSData = &sOSNT;
            m_sHeaderInfo.uOSDataSize = sizeof(sOSNT);
            break;
        default:
            break;
        }

        WsbAffirmHr(FlushBuffer(m_pBuffer, &m_nBufUsed));

        // **MTF API CALL**
        // provide the MTF_DBLK_HDR_INFO and MTF_DBLK_DIRB_INFO structs
        // to this function.  The result is an MTF formatted DIRB DBLK in
        // m_pBuffer.
        nMoreBufUsed = 0;
        WsbAssertNoError(m_pMTFApi->MTF_WriteDIRBDblk(&m_sHeaderInfo, &sDIRB, m_pBuffer+m_nBufUsed, m_nBufSize-m_nBufUsed, &nMoreBufUsed));
        m_nBufUsed += nMoreBufUsed;

        // **MTF API CALL**
        // output the name stream, if required.
        if ( sDIRB.uDirectoryAttributes & MTF_DIRB_PATH_IN_STREAM ) {
            nMoreBufUsed = 0;
            if ( m_sVolInfo.uVolumeAttributes & MTF_VOLB_DEV_DRIVE ) {
                WsbAssertNoError(m_pMTFApi->MTF_WriteNameStream(MTF_PATH_NAME_STREAM, szPath + 3, m_pBuffer+m_nBufUsed, m_nBufSize-m_nBufUsed, &nMoreBufUsed));
                m_nBufUsed += nMoreBufUsed;
            }
            else if ( m_sVolInfo.uVolumeAttributes & MTF_VOLB_DEV_OS_SPEC ) {

                if ( 0 == _wcsnicmp( m_sVolInfo.szDeviceName, OLESTR("Volume{"), 7 )) {
                    WsbAssertNoError(m_pMTFApi->MTF_WriteNameStream(MTF_PATH_NAME_STREAM, szPath + 45, m_pBuffer+m_nBufUsed, m_nBufSize-m_nBufUsed, &nMoreBufUsed));
                    m_nBufUsed += nMoreBufUsed;
                }
                else {
                    // unrecognized operating system specific format
                    WsbThrow(MVR_E_INVALIDARG);
                }
            }
            else {
                // UNC path - unsupported
                WsbThrow(MVR_E_INVALIDARG);
            }
        }
        // Now, instead of padding this out, we call this funciton to write
        // out the stream which will write out the current contents of the
        // buffer as well.  When this call returns, the current contents of
        // the buffer as well as the associated data stream will have been
        // written to media.

        // Note:  Data may still remain in the device buffer, or the
        //        local m_pBuffer if the file doesn't pad to a block
        //        boundary, and the device buffer is not flushed.

        WsbAffirmHr(DoDataStream(hStream));

    } WsbCatch(hr);

    if (INVALID_HANDLE_VALUE != hStream) {
        CloseStream(hStream);
        hStream = INVALID_HANDLE_VALUE;
    }

    WsbTraceOut(OLESTR("CMTFSession::DoDirectoryDblk"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


HRESULT
CMTFSession::DoFileDblk(
    IN WCHAR *szPath,
    IN WIN32_FIND_DATAW *pFindData)
/*++

Routine Description:

    Writes out a FILE DBLK and calls DoStream to write out
    associated stream data

Arguments:

    szPath      -  Full pathname of file.
    pFindData   -  WIN32 information about the file.

Return Value:

    S_OK        -  Success.

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CMTFSession::DoFileDblk"), OLESTR(""));

    HANDLE hStream = INVALID_HANDLE_VALUE;

    try {
        MvrInjectError(L"Inject.CMTFSession::DoFileDblk.0");

        WsbAssertPointer(m_pBuffer);
        WsbAssertPointer(szPath);

        MTF_DBLK_FILE_INFO  sFILE;     // **MTF API STRUCT ** -- info for FILE
        size_t              nMoreBufUsed;

        UINT16 uAlignmentFactor = m_pMTFApi->MTF_GetAlignmentFactor();

        WsbAssert(m_nBlockSize > 0, MVR_E_LOGIC_ERROR);
        
        // Make sure we are aligned with a FLA (i.e. the last DBLK was properly padded).
        // It won't be if we are having problems writing to tape.
        WsbAffirm(0 == (m_nBufUsed % uAlignmentFactor), E_ABORT);
        UINT64 fla = m_nFormatLogicalAddress + m_nBufUsed/uAlignmentFactor;
        UINT64 pba = m_nPhysicalBlockAddress + (fla*uAlignmentFactor/m_nBlockSize);
        WsbTrace(OLESTR("%ls (FILE) @ FLA %I64u (%I64u, %I64u)\n"), WsbAbbreviatePath(szPath, 120),
            fla, pba, fla % (m_nBlockSize/uAlignmentFactor));

        // Get a handle to the directory.  If this fails we need to skip everything else.
        WsbAffirmHr(OpenStream(szPath, &hStream));

        // Initialize the hints set for each file.
        m_sHints.FileStart.QuadPart = fla * uAlignmentFactor;
        m_sHints.FileSize.QuadPart = 0;
        m_sHints.DataStart.QuadPart = 0;
        m_sHints.DataSize.QuadPart = 0;
        m_sHints.VerificationType = MVR_VERIFICATION_TYPE_NONE;
        m_sHints.VerificationData.QuadPart = 0;
        m_sHints.DatastreamCRCType = WSB_CRC_CALC_NONE;
        m_sHints.DatastreamCRC.QuadPart = 0;
        m_sHints.FileUSN.QuadPart = 0;

        if (m_bUseFlatFileStructure) {

            // For HSM we rename the file to it's logical address

            swprintf( pFindData->cFileName, L"%08x", fla );
        }

        // **MTF API CALL**
        // automatically fill in the MTF_FILE_DBLK_INFO structure using
        // information in the pFindData structure
        m_pMTFApi->MTF_SetFILEFromFindData(&sFILE, pFindData);

        // Check if we need to set the Backup Date field for the FILE DBLK

        if ((m_sSetInfo.uSSETAttributes & MTF_SSET_NORMAL)
            |(m_sSetInfo.uSSETAttributes & MTF_SSET_DIFFERENTIAL)
            |(m_sSetInfo.uSSETAttributes & MTF_SSET_INCREMENTAL)
            |(m_sSetInfo.uSSETAttributes & MTF_SSET_DAILY)){

            time_t tTime;
            time(&tTime);

            sFILE.sBackupDate = m_pMTFApi->MTF_CreateDateTimeFromTM(gmtime(&tTime));
        }

        // make sure to mark and update the file id as well as the control
        // block id and alignment is already correct
        sFILE.uDirectoryId                  = m_nDirectoryId;
        sFILE.uFileId                       = ++m_nFileId;
        m_sHeaderInfo.uControlBlockId       = m_nCurrentBlockId++;
        m_sHeaderInfo.uFormatLogicalAddress = fla;

        // Add in OS Specific data
        MTF_FILE_OS_NT_0 sOSNT;

        switch ( m_sHeaderInfo.uOSID ) {
        case MTF_OSID_NT:
            sOSNT.uFileAttributes = sFILE.uFileAttributes;
            sOSNT.uShortNameOffset = 0;
            sOSNT.uShortNameSize = 0;
            sOSNT.lLink = 0;
            sOSNT.uReserved = 0;
            m_sHeaderInfo.pvOSData = &sOSNT;
            m_sHeaderInfo.uOSDataSize = sizeof(sOSNT);
            break;
        default:
            break;
        }

        WsbAffirmHr(FlushBuffer(m_pBuffer, &m_nBufUsed));

        // **MTF API CALL**
        // Provide the MTF_DBLK_HDR_INFO and MTF_DBLK_FILE_INFO structs
        // to this function.  The result is an MTF formatted FILE DBLK in
        // m_pBuffer.
        nMoreBufUsed = 0;
        WsbAssertNoError(m_pMTFApi->MTF_WriteFILEDblk(&m_sHeaderInfo, &sFILE, m_pBuffer+m_nBufUsed, m_nBufSize-m_nBufUsed, &nMoreBufUsed));
        m_nBufUsed += nMoreBufUsed;

        // Like the directory, instead of padding this out, we call this
        // funciton to write out the stream which will write out the current
        // contents of the buffer as well.  When this call returns, the
        // current contents of the buffer as well as the associated data
        // stream will have been written to media.

        // Note:  Data may still remain in the device buffer, or the
        //        local m_pBuffer if the file doesn't pad to a block
        //        boundary, and the device buffer is not flushed.

        hr = DoDataStream(hStream);
        if ( hr != S_OK) {
            // unable to copy the file to target media.
            WsbTraceAlways( OLESTR("Unable to store file %ls.  reason = %s\n"), WsbAbbreviatePath(szPath, 120), WsbHrAsString(hr));
            WsbThrow(hr);
        }
        else {
            // Make sure we are alinged with a FLA (i.e. the last stream was properly padded).
            WsbAssert(0 == (m_nBufUsed % uAlignmentFactor), MVR_E_LOGIC_ERROR);

            m_sHints.FileSize.QuadPart = 
                m_nFormatLogicalAddress * uAlignmentFactor + m_nBufUsed - m_sHints.FileStart.QuadPart;
        }
    } WsbCatch(hr);

    if (INVALID_HANDLE_VALUE != hStream) {
        CloseStream(hStream);
        hStream = INVALID_HANDLE_VALUE;
    }

    WsbTraceOut(OLESTR("CMTFSession::DoFileDblk"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}



HRESULT
CMTFSession::OpenStream(
    IN WCHAR *szPath,
    OUT HANDLE *pStreamHandle)
/*++

Routine Description:

    Opens the file to backup in "backup read" mode, and returns
    stream handle for the file specified.

Arguments:

    szPath      -  Full pathname of file.
    hStream     -  Returned stream handle.

Return Value:

    S_OK        -  Success.

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CMTFSession::OpenStream"), OLESTR("<%ls>"), WsbAbbreviatePath(szPath, 120));
    
    HANDLE hStream = INVALID_HANDLE_VALUE;

    try {
        MvrInjectError(L"Inject.CMTFSession::OpenStream.0");

        WsbAssertPointer(szPath);
        WsbAssertPointer(pStreamHandle);

        *pStreamHandle = INVALID_HANDLE_VALUE;

        FILE_BASIC_INFORMATION      basicInformation;
        IO_STATUS_BLOCK             IoStatusBlock;
        NTSTATUS                    ccode;

        // ** WIN32 File API Call - open the file for backup read.  This can be more involved if
        // the app needs to be run by someone without the proper authority to
        // backup certain files....
        // We also ask for GENERIC_WRITE so we can set the attributes to prevent the
        // modification of dates.

        DWORD posixFlag = (m_bUseCaseSensitiveSearch) ? FILE_FLAG_POSIX_SEMANTICS : 0;

        CWsbStringPtr name = szPath;
        WsbAffirmHr(name.Prepend(OLESTR("\\\\?\\")));
        WsbAffirm(0 != (WCHAR *)name, E_OUTOFMEMORY);
        WsbAffirmHandle(hStream = CreateFileW((WCHAR *) name,
                                   GENERIC_READ | FILE_WRITE_ATTRIBUTES,
                                   FILE_SHARE_READ,
                                   NULL,
                                   OPEN_EXISTING,
                                   FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_OPEN_REPARSE_POINT | posixFlag, 
                                   NULL));

        //
        // Prevent modification of file dates
        //
        // ** NT System Call - query for file information
        WsbAffirmNtStatus(NtQueryInformationFile(hStream, &IoStatusBlock, (PVOID)&basicInformation,
                            sizeof( basicInformation ), FileBasicInformation));

        m_SaveBasicInformation = basicInformation;
        basicInformation.CreationTime.QuadPart = -1;
        basicInformation.LastAccessTime.QuadPart = -1;
        basicInformation.LastWriteTime.QuadPart = -1;
        basicInformation.ChangeTime.QuadPart = -1;

        // ** NT System Call - set file information
        WsbAffirmNtStatus(ccode = NtSetInformationFile( hStream, &IoStatusBlock, (PVOID)&basicInformation,
                                sizeof( basicInformation ), FileBasicInformation));

        if (pStreamHandle) {
            *pStreamHandle = hStream;
        }

    } WsbCatchAndDo(hr,
            if (INVALID_HANDLE_VALUE != hStream) {
                CloseHandle( hStream );
                hStream = INVALID_HANDLE_VALUE;
            }
        );


    WsbTraceOut(OLESTR("CMTFSession::OpenStream"), OLESTR("hr = <%ls>, handle = <0x%08x>"), WsbHrAsString(hr), hStream);

    return hr;
}


HRESULT
CMTFSession::CloseStream(
    IN HANDLE hStream)
/*++

Routine Description:

    Close stream handle and performs cleanup.

Arguments:

    hStream     -  Stream handle to close

Return Value:

    S_OK        -  Success.

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CMTFSession::CloseStream"), OLESTR("<0x%08x>"), hStream);

    try {

        if (INVALID_HANDLE_VALUE != hStream) {

            //
            // Cleanup from a partial backup read.  We're setting bAbort=TRUE
            // to free resources used by BackupRead()
            //
            if (m_pvReadContext) {
                (void) BackupRead(hStream, NULL, 0, NULL, TRUE, FALSE, &m_pvReadContext);
                m_pvReadContext = NULL;
            }
            (void) CloseHandle( hStream );
            hStream = INVALID_HANDLE_VALUE;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CMTFSession::CloseStream"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


HRESULT
CMTFSession::DoDataStream(
    IN HANDLE hStream)
/*++

Routine Description:

    Uses WIN32 BackupRead to read streams associated with a file 
    and then write them out to the data set.  BackupRead opens a 
    file and successively reads data streams from that file.
    Each data stream is preceeded by a WIN32_STREAM_ID struct.

Arguments:

    hStream      -  File handle.

Return Value:

    S_OK        -  Success.

Algorithm:

    - with buffer, current_buf_position do:

        - while there are more streams loop
            - read next stream header using BackupRead
            - exit loop when no next stream

            - use stream header to append format MTF STREAM HEADER to buffer

            - flush as much of buffer as possible to the data set.

            - while entire stream not read loop
                - read as much of current stream as possible into remainder
                  of buffer 
                - flush as much of buffer as possible to the data set.
            - end loop this stream not read
        - end loop more streams

        - flush as much of the buffer to the data set

        - pad buffer out to next alignment factor

        - flush as much of the buffer to the data set

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CMTFSession::DoDataStream"), OLESTR("<0x%08x>"), hStream);

    try {
        MvrInjectError(L"Inject.CMTFSession::DoDataStream.0");

        UINT16 uAlignmentFactor = m_pMTFApi->MTF_GetAlignmentFactor();
        UINT64 fla = m_nFormatLogicalAddress + m_nBufUsed/uAlignmentFactor;
        WsbTrace(OLESTR("CMTFSession::DoDataStream - Start: FLA = %I64u\n"), fla);

        WIN32_STREAM_ID sStreamHeader;      // comes back from Win32 BackupRead
        ULONG           nThisRead;          // number of bytes to read
        ULONG           nBytesRead;         // number of bytes read
        UINT64          nStreamBytesToRead; // total number bytes that we need to read
        UINT64          nStreamBytesRead;   // total number bytes that have been read
        USHORT          nStreamCount = 0;   // current stream number
        MTF_STREAM_INFO sSTREAM;
        size_t          nMoreBufUsed;
        BOOL            bReadStatus = FALSE;

        // Prepare to calculate the CRC for the unnamed datastream
        BYTE* pCurrent;
        BYTE* pStart;
        ULONG datastreamCRC;
        BOOL doDatastreamCRC;

        memset(&sStreamHeader, 0, sizeof(WIN32_STREAM_ID));
        
        INITIALIZE_CRC(datastreamCRC);
        WsbTrace(OLESTR("CMTFSession::DoDataStream initialzed CRC is <%lu> for <0x%08x>\n"),
            datastreamCRC, hStream);
        m_sHints.DatastreamCRCType = WSB_CRC_CALC_NONE;

        WsbTrace(OLESTR("CMTFSession::DoDataStream - Start While\n"));
        while(1) {
            // We want to do a CRC on the unnamed datastream
            doDatastreamCRC = FALSE;
            nBytesRead = 0;

            try {

                MvrInjectError(L"Inject.CMTFSession::DoDataStream.BackupRead.1.0");
            
                // ** WIN32 File API Call - Backup read returns the file as a sequence of streams each
                // preceed by a WIN32_STREAM_ID struct.  Note that this structure is a
                // variable size -- depending on the length of the name of the stream.
                // In any case, we are guaranteed at least 20 bytes of it
                // (WIN32_STREAM_ID_SIZE)
                nStreamCount++;
                WsbAffirmStatus(BackupRead(hStream,
                            (BYTE *) &sStreamHeader,
                            WIN32_STREAM_ID_SIZE,
                            &nBytesRead,
                            FALSE,
                            TRUE,
                            &m_pvReadContext));

                MvrInjectError(L"Inject.CMTFSession::DoDataStream.BackupRead.1.1");

            } catch (HRESULT catchHr) {

                //
                // CORRUPT FILE PROCESSING for stream header
                //

                hr = catchHr;

                WsbLogEvent(MVR_E_ERROR_IO_DEVICE, 0, NULL, WsbHrAsString(hr), NULL);

                // Write SPAD
                WsbAffirmHr(PadToNextFLA(TRUE));

                // Make sure we are aligned with a FLA (i.e. the last DBLK was properly padded).
                // It won't be if we are having problems writing to tape.
                WsbAssert(0 == (m_nBufUsed % uAlignmentFactor), MVR_E_LOGIC_ERROR);
                UINT64 fla = m_nFormatLogicalAddress + m_nBufUsed/uAlignmentFactor;
                UINT64 pba = m_nPhysicalBlockAddress + (fla*uAlignmentFactor/m_nBlockSize);
                WsbTrace(OLESTR("%ls (CFIL) @ FLA %I64u (%I64u, %I64u)\n"), fla, pba, fla % (m_nBlockSize/uAlignmentFactor));

                // Write a corrupt file (CFIL) DBLK
                MTF_DBLK_CFIL_INFO sCFILInfo;

                m_pMTFApi->MTF_SetCFILDefaults( &sCFILInfo );

                sCFILInfo.uCorruptStreamNumber = nStreamCount;
                sCFILInfo.uStreamOffset = 0;

                m_sHeaderInfo.uControlBlockId       = m_nCurrentBlockId++;
                m_sHeaderInfo.uFormatLogicalAddress = fla;

                WsbAssertNoError(m_pMTFApi->MTF_WriteCFILDblk(&m_sHeaderInfo, &sCFILInfo, m_pBuffer+m_nBufUsed, m_nBufSize-m_nBufUsed, &nMoreBufUsed));
                m_nBufUsed += nMoreBufUsed;

                WsbAffirmHr(FlushBuffer(m_pBuffer, &m_nBufUsed));

                WsbThrow(hr);

            };

            if (nBytesRead < WIN32_STREAM_ID_SIZE)
                break;


            // **MTF API CALL**
            // now use the info in the stream header to fill in an mtf stream
            // header using the mtf call then write the resulting info to the
            // buffer.

            // BMD Note: special conditional code added on third arg for named data streams

            m_pMTFApi->MTF_SetSTREAMFromStreamId( &sSTREAM,
                                       &sStreamHeader,
                                       (sStreamHeader.dwStreamNameSize) ? sStreamHeader.dwStreamNameSize + 4 : 0 );
  
            WsbAffirmHr(FlushBuffer(m_pBuffer, &m_nBufUsed));

            // **MTF API CALL**
            // Write out the stream header.
            nMoreBufUsed = 0;
            WsbAssertNoError(m_pMTFApi->MTF_WriteStreamHeader(&sSTREAM, m_pBuffer+m_nBufUsed, m_nBufSize-m_nBufUsed, &nMoreBufUsed));
            m_nBufUsed += nMoreBufUsed;

            // BMD Note: we need to put the size of the stream name in the MTF stream
            //           right after the header.  We'll write the name itself as part of the stream.
            //
            //           ?? Should this be in MTF_WriteStreamHeader ??

            if ( sStreamHeader.dwStreamNameSize ) {
                *(DWORD UNALIGNED *)(m_pBuffer + m_nBufUsed) = sStreamHeader.dwStreamNameSize;
                m_nBufUsed += sizeof( DWORD );
            }

            // Save away the "STAN" stream start byte address, and size.
            // This is the one we recall.
            if ( 0 == memcmp( sSTREAM.acStreamId, "STAN", 4 ) ) {
                // This is an unnamed data stream, so there's no stream name.
                m_sHints.VerificationData.QuadPart = sSTREAM.uCheckSum;
                m_sHints.VerificationType = MVR_VERIFICATION_TYPE_HEADER_CRC;
                m_sHints.DataStart.QuadPart = m_nFormatLogicalAddress * uAlignmentFactor + m_nBufUsed - m_sHints.FileStart.QuadPart;
                m_sHints.DataSize.QuadPart = sSTREAM.uStreamLength;
                doDatastreamCRC = TRUE;
                m_sHints.DatastreamCRCType = WSB_CRC_CALC_MICROSOFT_32;
            }

            // the above stream should always fit...
            WsbAssert(m_nBufUsed < m_nBufSize, MVR_E_LOGIC_ERROR);

            // try to flush as many BLOCK SIZE chunks out of the buffer as possible
            WsbAffirmHr(FlushBuffer(m_pBuffer, &m_nBufUsed));
            // now, while there is more data in the stream, read the rest of
            // the stream, or how ever much will fit into the buffer
            nStreamBytesToRead = m_pMTFApi->MTF_CreateUINT64(sStreamHeader.Size.LowPart, sStreamHeader.Size.HighPart)
                                 + sStreamHeader.dwStreamNameSize;

            nStreamBytesRead = 0;

            WsbTrace(OLESTR("CMTFSession::DoDataStream - Start Do\n"));
            do
            {
                nThisRead = 0;

                // we read as many bytes as will fit into our buffer, up to
                // the end of the stream min doesn't work well here... 
                if (nStreamBytesToRead < (m_nBufSize - m_nBufUsed))
                    nThisRead = (ULONG) nStreamBytesToRead;
                else
                    nThisRead = (ULONG)(m_nBufSize - m_nBufUsed);

                    try {

                        MvrInjectError(L"Inject.CMTFSession::DoDataStream.BackupRead.2.0");

                        // ** WIN32 File API Call - read nThisRead bytes, bail out if the read failed or
                        // no bytes were read (assume done)
                        bReadStatus = FALSE;
                        bReadStatus = BackupRead(hStream,
                                             m_pBuffer + m_nBufUsed,
                                             nThisRead,
                                             &nBytesRead,
                                             FALSE,
                                             TRUE,
                                             &m_pvReadContext);

                        nStreamBytesRead += nBytesRead;

                        WsbAffirmStatus(bReadStatus);

                        MvrInjectError(L"Inject.CMTFSession::DoDataStream.BackupRead.2.1");

                    } catch (HRESULT catchHr) {

                        //
                        // CORRUPT FILE PROCESSING for stream data
                        //
                        hr = catchHr;

                        WsbLogEvent(MVR_E_ERROR_IO_DEVICE, 0, NULL, WsbHrAsString(hr), NULL);

                        // Go to the last good byte
                        m_nBufUsed += nBytesRead;

                        // Pad to fill up size of file
                        while( nStreamBytesRead < nStreamBytesToRead ) {
                            for( ; (m_nBufUsed < m_nBufSize) && (nStreamBytesRead < nStreamBytesToRead); ++m_nBufUsed, ++nStreamBytesRead ) {
                                m_pBuffer[m_nBufUsed] = 0;
                            }
                            WsbAffirmHr(FlushBuffer(m_pBuffer, &m_nBufUsed));
                        }
                        WsbAffirmHr(FlushBuffer(m_pBuffer, &m_nBufUsed));

                        // Align on 4-byte boundary
                        for( ; m_nBufUsed % 4; ++m_nBufUsed ){
                            m_pBuffer[m_nBufUsed] = 0;
                        }

                        // Write SPAD
                        WsbAffirmHr(PadToNextFLA(TRUE));

                        // Make sure we are aligned with a FLA (i.e. the last DBLK was properly padded).
                        // It won't be if we are having problems writing to tape.
                        WsbAssert(0 == (m_nBufUsed % uAlignmentFactor), MVR_E_LOGIC_ERROR);
                        UINT64 fla = m_nFormatLogicalAddress + m_nBufUsed/uAlignmentFactor;
                        UINT64 pba = m_nPhysicalBlockAddress + (fla*uAlignmentFactor/m_nBlockSize);
                        WsbTrace(OLESTR("%ls (CFIL) @ FLA %I64u (%I64u, %I64u)\n"), fla, pba, fla % (m_nBlockSize/uAlignmentFactor));

                        // Write a corrupt file (CFIL) DBLK
                        MTF_DBLK_CFIL_INFO sCFILInfo;

                        m_pMTFApi->MTF_SetCFILDefaults( &sCFILInfo );

                        sCFILInfo.uCorruptStreamNumber = nStreamCount;
                        sCFILInfo.uStreamOffset = nStreamBytesRead;

                        m_sHeaderInfo.uControlBlockId       = m_nCurrentBlockId++;
                        m_sHeaderInfo.uFormatLogicalAddress = fla;

                        WsbAssertNoError(m_pMTFApi->MTF_WriteCFILDblk(&m_sHeaderInfo, &sCFILInfo, m_pBuffer+m_nBufUsed, m_nBufSize-m_nBufUsed, &nMoreBufUsed));
                        m_nBufUsed += nMoreBufUsed;

                        WsbAffirmHr(FlushBuffer(m_pBuffer, &m_nBufUsed));

                        WsbThrow(hr);

                    };

                if (nBytesRead == 0)
                    break;

                nStreamBytesToRead -= nBytesRead;
                pStart = m_pBuffer + m_nBufUsed;
                m_nBufUsed += nBytesRead;

                HRESULT hrCRC = S_OK;
                if (TRUE == doDatastreamCRC )  {
                    for (pCurrent = pStart; (pCurrent < (pStart + nBytesRead)) && (S_OK == hr); pCurrent++) {
                        hrCRC = WsbCRCReadFile(pCurrent, &datastreamCRC);
                        if (S_OK != hrCRC) {
                            WsbThrow(MVR_E_CANT_CALC_DATASTREAM_CRC);
                        }
                    }
                }

                // At this point we've got stuff in the buffer that might need
                // to be flushed so, try to do that
                WsbAffirmHr(FlushBuffer(m_pBuffer, &m_nBufUsed));

            } while (nStreamBytesToRead > 0);
            WsbTrace(OLESTR("CMTFSession::DoDataStream - End Do\n"));

            // Okay.  At this point we're done with the stream.  As much as
            // possible was actually written out to the data set by FlushBuffer, but
            // some probably still remains in the buffer.  It will get flushed
            // later on...  At this point we need to align on a four byte
            // boundary.  Once we do this, we can start all over again with
            // the next stream (if none, then we bail out of this loop)
            for( ; m_nBufUsed % 4; ++m_nBufUsed )
                m_pBuffer[m_nBufUsed] = 0;
        }
        WsbTrace(OLESTR("CMTFSession::DoDataStream - End While\n"));

        // Finish off the unnamed datastream CRC stuff
        FINIALIZE_CRC(datastreamCRC);
        WsbTrace(OLESTR("CMTFSession::DoDataStream finalized CRC is <%lu>\n"), datastreamCRC);
        if (WSB_CRC_CALC_NONE != m_sHints.DatastreamCRCType)  {
            // We have a CRC that we want to save in the hints.
            m_sHints.DatastreamCRC.QuadPart = datastreamCRC;
        }

        IO_STATUS_BLOCK             IoStatusBlock;
        NTSTATUS                    ccode;

        // ** NT System Call - set file information
        // This call fixes the access time that can be changed by the BackupRead call above
        // When BackupRead is fixed this line should be removed.  RAID 121023.
        //
        // IMPORTANT NOTE:  This changes the USN, and must be done before we save the USN.
        //
        // TODO:  See if we still need this
        HRESULT infoHr = S_OK;
        try {
            WsbAffirmNtStatus(ccode = NtSetInformationFile( hStream, &IoStatusBlock, (PVOID)&m_SaveBasicInformation,
                                sizeof( m_SaveBasicInformation ), FileBasicInformation));
        } WsbCatch(infoHr);

        // Get the USN of the file before we close it
        //
        // Before we close the file, get the USN
        //
        LONGLONG lUsn;
        if (S_OK == WsbGetUsnFromFileHandle(hStream, TRUE, &lUsn)) {
            m_sHints.FileUSN.QuadPart = lUsn;
        } else  {
            // If we can't get the USN, then just set it to 0
            // which is invalid.  Don't stop things.
            m_sHints.FileUSN.QuadPart = 0;
        }

        // Now, were done with all of the streams.  If there is data left
        // in the buffer, we need to pad out to the next alignment block boundary and
        // flush the buffer.

        WsbAffirmHr(FlushBuffer(m_pBuffer, &m_nBufUsed));

        if (m_bCommitFile) {

            WsbTrace(OLESTR("CMTFSession::DoDataStream - Commit\n"));

            // Pad and Flush to next physical block
            WsbAffirmHr(PadToNextPBA());

            // Now flush the device buffer.
            WsbAffirmNoError(WriteFilemarks(0));

        }
        else {

            // Pad and Flush to next format logical block
            WsbAffirmHr(PadToNextFLA(TRUE));

        }

        // Make sure we are aligned with a FLA (i.e. the last DBLK/stream was properly padded).
        WsbAssert(0 == (m_nBufUsed % uAlignmentFactor), MVR_E_LOGIC_ERROR);

        fla = m_nFormatLogicalAddress + m_nBufUsed/uAlignmentFactor;
        WsbTrace(OLESTR("CMTFSession::DoDataStream - End: FLA = %I64u\n"), fla);\

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CMTFSession::DoDataStream"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


HRESULT
CMTFSession::DoEndOfDataSet(
    IN USHORT nDataSetNumber)
/*++

Routine Description:

    Formats and Writes an ESET DBLK.  The end of data set sequence
    starts with a filemark (which terminates the file data), followed
    by an ESET, then a final filemark.

Arguments:

    nDataSetNumber - The data set number.  Used only in error recover. Otherwise
                     The original data set number is used.

Return Value:

    S_OK        -  Success.

--*/
{
    HRESULT hr = S_OK;

    WsbTraceIn(OLESTR("CMTFSession::DoEndOfDataSet"), OLESTR("<%d>"), nDataSetNumber);

    try {
        MvrInjectError(L"Inject.CMTFSession::DoEndOfDataSet.0");

        WsbAssertPointer(m_pBuffer);

        MTF_DBLK_ESET_INFO  sESET;    // **MTF API STRUCT ** -- info for ESET
        size_t              nMoreBufUsed;

        UINT16 uAlignmentFactor = m_pMTFApi->MTF_GetAlignmentFactor();

        WsbAssert(m_nBlockSize > 0, MVR_E_LOGIC_ERROR);

        //
        // We can enter this routine in error recovery mode if
        // we need to write out an ESET at the end of a previously
        // written data set.  In this case the Initialization flag 
        // will be FALSE.
        //
        if (! m_bSetInitialized) {

            // This block of code is special to error recovery.

            (void) InitCommonHeader();

            // Since we use the Init SSET block to retrieve ESET info
            // we need to initialize it.

            // **MTF API CALL**
            m_pMTFApi->MTF_SetSSETDefaults(&m_sSetInfo);

            // Reset the set attributes and DataSetNumber.
            m_sSetInfo.uSSETAttributes = 0;  // TODO: This should match the original set attribute
            m_sSetInfo.uDataSetNumber  = nDataSetNumber;

            // Can't be anyting in the buffer if we are only writing
            // out the ESET.
            WsbAssert(0 == m_nBufUsed, MVR_E_LOGIC_ERROR);
        }

        if (m_nBufUsed > 0) {
            // Write out an ESPB if we have something in the buffer.  This conditional covers
            // the error recovery case where a missing ESET is detected.  In this case we
            // don't have enough info to write an ESBP, and were already on a physical block
            // boundary, so we skip the ESPB.

            // Make sure we are aligned with a FLA (i.e. the last DBLK was properly padded).
            // It won't be if we are having problems writing to tape.
            WsbAffirm(0 == (m_nBufUsed % uAlignmentFactor), E_ABORT);
            UINT64 fla = m_nFormatLogicalAddress + m_nBufUsed/uAlignmentFactor;
            UINT64 pba = m_nPhysicalBlockAddress + (fla*uAlignmentFactor/m_nBlockSize);
            WsbTrace(OLESTR("Writing End of Set Pad (ESPB) @ FLA %I64u (%I64u, %I64u)\n"),
                fla, pba, fla % (m_nBlockSize/uAlignmentFactor));

            // TODO:  Not sure all the error cases are handled, here.  What if we
            //        end the set before completing the last I/O transfer.  May need
            //        to add code to write out CFIL.

            // Increment the BlockId and alignment index values that we keep in 
            // our common block header structure.
            m_sHeaderInfo.uControlBlockId       = m_nCurrentBlockId++;
            m_sHeaderInfo.uFormatLogicalAddress = fla;

            WsbAffirmHr(FlushBuffer(m_pBuffer, &m_nBufUsed));

            // **MTF API CALL**
            // Write ESPB to pad the backup set to a phyical block boundary.
            nMoreBufUsed = 0;
            WsbAssertNoError(m_pMTFApi->MTF_WriteESPBDblk(&m_sHeaderInfo, m_pBuffer+m_nBufUsed, m_nBufSize-m_nBufUsed, &nMoreBufUsed));
            m_nBufUsed += nMoreBufUsed;

            // Write out the ESPB DBLK and SPAD.
            WsbAffirmHr(PadToNextPBA());
        }

        // Write a filemark to begin the end of data set sequence.  This will flush the device buffer.
        WsbAffirmHr(WriteFilemarks(1));

        // **MTF API CALL**
        // First set defaults for the info struct
        m_pMTFApi->MTF_SetESETDefaults(&sESET);

        sESET.uESETAttributes = m_sSetInfo.uSSETAttributes;
        sESET.uDataSetNumber  = m_sSetInfo.uDataSetNumber;

        m_sHeaderInfo.uControlBlockId       = m_nCurrentBlockId++;
        m_sHeaderInfo.uFormatLogicalAddress = 0;

        UINT64 curPos = 0;
        WsbAffirmHr(GetCurrentPBA(&curPos));  // From the stream I/O model
        WsbTrace(OLESTR("Writing End of Set (ESET) @ PBA %I64u\n"), curPos);

        // **MTF API CALL**
        // Provide the MTF_DBLK_HDR_INFO and MTF_DBLK_SSET_INFO structs to
        // this function.  The result is an MTF formatted SSET DBLK in m_pBuffer.

        WsbAssert(0 == m_nBufUsed, MVR_E_LOGIC_ERROR);
        WsbAssertNoError(m_pMTFApi->MTF_WriteESETDblk(&m_sHeaderInfo, &sESET, m_pBuffer, m_nBufSize, &m_nBufUsed));

        // Write out the ESET DBLK and SPAD.
        WsbAffirmHr(PadToNextPBA());

        // NOTE: The PadToNextPBA() is a placeholder.
        //       The On Media Catalog would be generated and written after the ESET DBLK and SPAD.
        //       If we ever implement a catalog, we need to change the previous PadToNextPBA() to
        //       PadToNextPLA();

        // Write a filemark. This will flush the device buffer.
        WsbAffirmHr(WriteFilemarks(1));

    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CMTFSession::DoEndOfDataSet"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}



HRESULT
CMTFSession::ExtendLastPadToNextPBA(void)
/*++

Routine Description:

    Re-writes the last SPAD in the transfer buffer to align with
    the next physical block boundary.  This routine shoud only be
    used before flushing the device buffer to guarantee data is written
    to the physical device.

Arguments:

    None.

Return Value:

    S_OK        -  Success.

Comments:

      !!! Not for CMTFSession internal use !!!

--*/
{
    HRESULT hr = S_OK;

    WsbTraceIn(OLESTR("CMTFSession::ExtendLastPadToNextPBA"), OLESTR(""));

    try {
        MvrInjectError(L"Inject.CMTFSession::ExtendLastPadToNextPBA.0");

        WsbAssertPointer(m_pBuffer);

        //
        // The start of the SPAD could be in last part of a previous
        // block that was flushed.  In this case the transfer buffer
        // contains the remaning portion of the SPAD, and the
        // SPAD cannot be extended so we simply return.
        //
        // If we hit EOM while in the middle of a file transfer, the
        // last thing in the transfer buffer won't be a SPAD.  No SPAD
        // is indicated by m_nStartOfPad == 0.
        //

        if ((m_nBufUsed > 0) && (m_nStartOfPad > 0) && (m_nStartOfPad < m_nBufUsed)) {
            MTF_STREAM_INFO sSTREAM;

            // Verify that there's an SPAD within the valid part of the buffer.
            // Make sure our last pad pointer is at an SPAD.
            WsbAffirmNoError(m_pMTFApi->MTF_ReadStreamHeader(&sSTREAM, &m_pBuffer[m_nStartOfPad]));

            WsbAssert((0 == memcmp(sSTREAM.acStreamId, "SPAD", 4)), MVR_E_LOGIC_ERROR);

            // Now, make sure we aren't going to overwrite anything other than a trailing SPAD.
            WsbAssert(m_nBufUsed == (m_nStartOfPad + sizeof(MTF_STREAM_INFO) + sSTREAM.uStreamLength), MVR_E_LOGIC_ERROR);

            // Reset the amount of buffer used to the start of the current SPAD
            // in preparation for overwrite of SPAD to a physical block boundary.
            m_nBufUsed = m_nStartOfPad;

            WsbAffirmHr(PadToNextPBA());
        }

        // Flush the device buffer.
        WsbAffirmHr(WriteFilemarks(0));

    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CMTFSession::ExtendLastPadToNextPBA"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}

/***

Note:
    "Skip" methods used for Recovery assume that you may read FLA size blocks 
    rather than PBA size block. Therefore, they muse be used only for files opened
    without the FILE_FLAG_NO_BUFFERING flag.
    If we come to the point where we must read only sector-size blocks, then some
    of this code should be enhanced!

***/

HRESULT
CMTFSession::SkipOverTapeDblk(void)
/*++

Routine Description:
    
    Skips over a TAPE DBLK and the following FILEMARK. 
    Expects to find a full or partial TAPE DBLK but no other data.

Arguments:

    None.

Return Value:

    S_OK        -  Success.
    MVR_E_NOT_FOUND - Block is missing or cut in the middle

--*/
{
    HRESULT hr = S_OK;

    WsbTraceIn(OLESTR("CMTFSession::SkipOverTapeDblk"), OLESTR(""));

    try {
        ULONG bytesRead = 0;
        ULONG bytesToRead = m_nBlockSize;
        UINT64  fileMarkPos;

        // Read TAPE DBLK
        WsbAffirmHr(SetCurrentPBA(0));
        WsbAffirmHr(ReadFromDataSet (m_pBuffer, bytesToRead, &bytesRead));
        if (bytesRead < bytesToRead) {
            // incomplete block
            WsbThrow(MVR_E_NOT_FOUND);
        }

        // Check block
        MTF_DBLK_HDR_INFO sHdrInfo;
        m_pMTFApi->MTF_DBLK_HDR_INFO_ReadFromBuffer(&sHdrInfo, m_pBuffer);
        WsbAffirm(0 == memcmp(sHdrInfo.acBlockType, MTF_ID_TAPE, 4), MVR_E_UNKNOWN_MEDIA);

        // Next block should be a FILEMARK
        WsbAffirmHr(GetCurrentPBA(&fileMarkPos));
        bytesRead = 0;
        WsbAffirmHr(ReadFromDataSet (m_pBuffer, bytesToRead, &bytesRead));
        if (bytesRead < bytesToRead) {
            // incomplete block
            WsbThrow(MVR_E_NOT_FOUND);
        }

        // Check block
        m_pMTFApi->MTF_DBLK_HDR_INFO_ReadFromBuffer(&sHdrInfo, m_pBuffer);
        WsbAffirm(0 == memcmp(sHdrInfo.acBlockType, MTF_ID_SFMB, 4), MVR_E_INCONSISTENT_MEDIA_LAYOUT);

        // Keep Soft File Marks array updated
        if (TRUE == m_bUseSoftFilemarks) {
            m_pMTFApi->MTF_InsertSoftFilemark(m_pSoftFilemarks, (UINT32)fileMarkPos);
        }

     } WsbCatch(hr);

    WsbTraceOut(OLESTR("CMTFSession::SkipOverTapeDblk"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}

HRESULT
CMTFSession::SkipOverSSETDblk(OUT USHORT* pDataSetNumber)
/*++

Routine Description:
    
    Skips over a SSET DBLK 
    Expects to find a full or partial SSET DBLK but no other data.

Arguments:

    pDataSetNumber - Data set number taken from the skipped block

Return Value:

    S_OK        -  Success.
    MVR_E_NOT_FOUND - Block is missing or cut in the middle

--*/
{
    HRESULT hr = S_OK;
    LARGE_INTEGER startBlockPosition = {0,0};
    LARGE_INTEGER currentBlockPosition = {0,0};

    WsbTraceIn(OLESTR("CMTFSession::SkipOverSSETDblk"), OLESTR(""));

    try {
        UINT16 uAlignmentFactor = m_pMTFApi->MTF_GetAlignmentFactor();
        ULONG bytesRead = 0;
        ULONG bytesToRead = uAlignmentFactor;

        LARGE_INTEGER zero = {0,0};

        m_nFormatLogicalAddress = 0;

        WsbAffirmHr(m_pStream->Seek(zero, STREAM_SEEK_CUR, (ULARGE_INTEGER *)&startBlockPosition));

        // Read SSET DBLK
        WsbAffirmHr(m_pStream->Read(m_pBuffer, bytesToRead, &bytesRead));
        if (bytesRead < bytesToRead) {
            // incomplete block
            WsbThrow(MVR_E_NOT_FOUND);
        }

        // Check block and get set number
        MTF_DBLK_HDR_INFO sHdrInfo;
        MTF_DBLK_SSET_INFO sSsetInfo;
        m_pMTFApi->MTF_ReadSSETDblk(&sHdrInfo, &sSsetInfo, m_pBuffer);
        WsbAffirm(0 == memcmp(sHdrInfo.acBlockType, MTF_ID_SSET, 4), MVR_E_INCONSISTENT_MEDIA_LAYOUT);
        *pDataSetNumber = m_sSetInfo.uDataSetNumber;

        // Skip over rest of the block
        WsbAffirmHr(SkipOverStreams(startBlockPosition.QuadPart + sHdrInfo.uOffsetToFirstStream));

        WsbAffirmHr(m_pStream->Seek(zero, STREAM_SEEK_CUR, (ULARGE_INTEGER *)&currentBlockPosition));
        m_nFormatLogicalAddress += (currentBlockPosition.QuadPart - startBlockPosition.QuadPart) / uAlignmentFactor;

    } WsbCatchAndDo(hr,
        // Seek back to the beginning of the block
        (void) m_pStream->Seek(startBlockPosition, STREAM_SEEK_SET, NULL);
        );


    WsbTraceOut(OLESTR("CMTFSession::SkipOverSSETDblk"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}

HRESULT
CMTFSession::SkipToDataSet(void)
/*++

Routine Description:
    
    Skips to the beginning of the next FILE DBLK 
    Expects to find 0 to n other blocks such as DIRB DBLK.
    In case of a partial last block, stream pointer is set to the beginning of the partial block

Arguments:

    None.

Return Value:

    S_OK        -  Success.
    MVR_S_SETMARK_DETECTED - No more data sets (i.e. end-of-data-set detected)
    MVR_E_NOT_FOUND - Block is missing or cut in the middle

--*/
{
    HRESULT hr = S_OK;
    LARGE_INTEGER startBlockPosition = {0,0};
    LARGE_INTEGER currentBlockPosition = {0,0};
    BOOL bIdRead = FALSE;

    WsbTraceIn(OLESTR("CMTFSession::SkipToDataSet"), OLESTR(""));

    try {
        UINT16 uAlignmentFactor = m_pMTFApi->MTF_GetAlignmentFactor();
        ULONG bytesRead = 0;
        ULONG bytesToRead = uAlignmentFactor;
        LARGE_INTEGER zero = {0,0};

        while (TRUE) {
            bIdRead = FALSE;

            // keep current position, before block starts
            WsbAffirmHr(m_pStream->Seek(zero, STREAM_SEEK_CUR, (ULARGE_INTEGER *)&startBlockPosition));

            // Read block header
            WsbAffirmHr(m_pStream->Read(m_pBuffer, bytesToRead, &bytesRead));
            if (bytesRead < bytesToRead) {
                // incomplete block
                WsbThrow(MVR_E_NOT_FOUND);
            }

            // Check block
            MTF_DBLK_HDR_INFO sHdrInfo;
            m_pMTFApi->MTF_DBLK_HDR_INFO_ReadFromBuffer(&sHdrInfo, m_pBuffer);

            m_nFormatLogicalAddress = sHdrInfo.uFormatLogicalAddress;
            m_nCurrentBlockId = sHdrInfo.uControlBlockId + 1;
            bIdRead = TRUE;

            if ((0 == memcmp(sHdrInfo.acBlockType, MTF_ID_VOLB, 4)) ||
                (0 == memcmp(sHdrInfo.acBlockType, MTF_ID_DIRB, 4))) {
                // Just skip following streams
                WsbAffirmHr(SkipOverStreams(startBlockPosition.QuadPart + sHdrInfo.uOffsetToFirstStream));

                WsbAffirmHr(m_pStream->Seek(zero, STREAM_SEEK_CUR, (ULARGE_INTEGER *)&currentBlockPosition));
                m_nFormatLogicalAddress += (currentBlockPosition.QuadPart - startBlockPosition.QuadPart) / uAlignmentFactor;

            } else if (0 == memcmp(sHdrInfo.acBlockType, MTF_ID_FILE, 4)) {
                WsbAffirmHr(m_pStream->Seek(startBlockPosition, STREAM_SEEK_SET, NULL));
                break;

            } else if (0 == memcmp(sHdrInfo.acBlockType, MTF_ID_SFMB, 4)) {
                // end of data-set reached, no ESPB block, must be alligned with PBA
                WsbAffirmHr(m_pStream->Seek(startBlockPosition, STREAM_SEEK_SET, NULL));
                WsbAssert(0 == (startBlockPosition.QuadPart % m_nBlockSize), MVR_E_INCONSISTENT_MEDIA_LAYOUT);
                hr = MVR_S_SETMARK_DETECTED;
                break;

            } else if (0 == memcmp(sHdrInfo.acBlockType, MTF_ID_ESPB, 4)) {
                // last block in data-set found. Make sure it is complete
                WsbAffirmHr(SkipOverStreams(startBlockPosition.QuadPart + sHdrInfo.uOffsetToFirstStream));

                WsbAffirmHr(m_pStream->Seek(zero, STREAM_SEEK_CUR, (ULARGE_INTEGER *)&currentBlockPosition));
                WsbAssert(0 == (currentBlockPosition.QuadPart % m_nBlockSize), MVR_E_INCONSISTENT_MEDIA_LAYOUT);
                m_nFormatLogicalAddress += (currentBlockPosition.QuadPart - startBlockPosition.QuadPart) / uAlignmentFactor;

                hr = MVR_S_SETMARK_DETECTED;
                break;

            } else {
                // unexpected data
                WsbThrow(MVR_E_INCONSISTENT_MEDIA_LAYOUT);
            }
        }

    } WsbCatchAndDo(hr,
        // Seek back to the end of the last complete & valid block
        (void) m_pStream->Seek(startBlockPosition, STREAM_SEEK_SET, NULL);
        if (bIdRead) {
            m_nCurrentBlockId--;
        }
        );

    WsbTraceOut(OLESTR("CMTFSession::SkipToDataSet"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}

HRESULT
CMTFSession::SkipOverDataSet(void)
/*++

Routine Description:
    
    Skips over one FILE DBLK, including all of its data streams
    Expects to find a FILE DBLK.
    In case of a partial block, stream pointer is set back to the beginning of the block

Arguments:

    None.

Return Value:

    S_OK        -  Success.
    MVR_E_NOT_FOUND - Block is missing or cut in the middle

--*/
{
    HRESULT hr = S_OK;
    LARGE_INTEGER startBlockPosition = {0,0};
    LARGE_INTEGER currentBlockPosition = {0,0};

    WsbTraceIn(OLESTR("CMTFSession::SkipOverDataSet"), OLESTR(""));

    try {
        UINT16 uAlignmentFactor = m_pMTFApi->MTF_GetAlignmentFactor();
        ULONG bytesRead = 0;
        ULONG bytesToRead = uAlignmentFactor;
        LARGE_INTEGER zero = {0,0};

        // keep current position, before block starts
        WsbAffirmHr(m_pStream->Seek(zero, STREAM_SEEK_CUR, (ULARGE_INTEGER *)&startBlockPosition));

        // Read block header
        WsbAffirmHr(m_pStream->Read(m_pBuffer, bytesToRead, &bytesRead));
        if (bytesRead < bytesToRead) {
            // incomplete block
            WsbThrow(MVR_E_NOT_FOUND);
        }

        // Check block
        MTF_DBLK_HDR_INFO sHdrInfo;
        m_pMTFApi->MTF_DBLK_HDR_INFO_ReadFromBuffer(&sHdrInfo, m_pBuffer);

        if (0 == memcmp(sHdrInfo.acBlockType, MTF_ID_FILE, 4)) {
            WsbAffirmHr(SkipOverStreams(startBlockPosition.QuadPart + sHdrInfo.uOffsetToFirstStream));

            WsbAffirmHr(m_pStream->Seek(zero, STREAM_SEEK_CUR, (ULARGE_INTEGER *)&currentBlockPosition));
            m_nFormatLogicalAddress += (currentBlockPosition.QuadPart - startBlockPosition.QuadPart) / uAlignmentFactor;
        } else {
            // unexpected data
            WsbThrow(MVR_E_INCONSISTENT_MEDIA_LAYOUT);
        }

    } WsbCatchAndDo(hr,
        // Seek back to the beginning of the block
        (void) m_pStream->Seek(startBlockPosition, STREAM_SEEK_SET, NULL);
        m_nCurrentBlockId--;
        );

    WsbTraceOut(OLESTR("CMTFSession::SkipOverDataSet"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}

HRESULT
CMTFSession::SkipOverEndOfDataSet(void)
/*++

Routine Description:
    
    Skips over one the sequence FILEMARK + ESET DBLK + FILEMARK
    Expects to find a FILE MARK, even if ESPB exists, it should have been already skipped.
    In case of a partial sequence, stream pointer is set back to the beginning of the sequence

Arguments:

    None.

Return Value:

    S_OK        -  Success. (It really means that the file is valid & complete)
    MVR_E_NOT_FOUND - Sequence is missing or cut in the middle

--*/
{
    HRESULT hr = S_OK;
    LARGE_INTEGER startBlockPosition = {0,0};
    UINT64 nFormatLogicalAddress = m_nFormatLogicalAddress;

    WsbTraceIn(OLESTR("CMTFSession::SkipOverEndOfDataSet"), OLESTR(""));

    try {
        UINT16 uAlignmentFactor = m_pMTFApi->MTF_GetAlignmentFactor();
        ULONG bytesRead = 0;
        ULONG bytesToRead = m_nBlockSize;

        LARGE_INTEGER zero = {0,0};

        // keep current position, before block starts
        WsbAffirmHr(m_pStream->Seek(zero, STREAM_SEEK_CUR, (ULARGE_INTEGER *)&startBlockPosition));

        // Read block header
        m_nFormatLogicalAddress = startBlockPosition.QuadPart / uAlignmentFactor;
        WsbAffirmHr(ReadFromDataSet (m_pBuffer, bytesToRead, &bytesRead));
        if (bytesRead < bytesToRead) {
            // incomplete block
            WsbThrow(MVR_E_NOT_FOUND);
        }

        // Check block, must be a FILE MARK
        MTF_DBLK_HDR_INFO sHdrInfo;
        m_pMTFApi->MTF_DBLK_HDR_INFO_ReadFromBuffer(&sHdrInfo, m_pBuffer);
        WsbAffirm(0 == memcmp(sHdrInfo.acBlockType, MTF_ID_SFMB, 4), MVR_E_INCONSISTENT_MEDIA_LAYOUT);

        // Read next block
        bytesRead = 0;
        WsbAffirmHr(ReadFromDataSet (m_pBuffer, bytesToRead, &bytesRead));
        if (bytesRead < bytesToRead) {
            // incomplete block
            WsbThrow(MVR_E_NOT_FOUND);
        }

        // Check block, must be a ESET DBLK
        m_pMTFApi->MTF_DBLK_HDR_INFO_ReadFromBuffer(&sHdrInfo, m_pBuffer);
        WsbAffirm(0 == memcmp(sHdrInfo.acBlockType, MTF_ID_ESET, 4), MVR_E_INCONSISTENT_MEDIA_LAYOUT);

        // Read next block
        bytesRead = 0;
        WsbAffirmHr(ReadFromDataSet (m_pBuffer, bytesToRead, &bytesRead));
        if (bytesRead < bytesToRead) {
            // incomplete block
            WsbThrow(MVR_E_NOT_FOUND);
        }

        // Check block, must be a FILEMARK
        m_pMTFApi->MTF_DBLK_HDR_INFO_ReadFromBuffer(&sHdrInfo, m_pBuffer);
        WsbAffirm(0 == memcmp(sHdrInfo.acBlockType, MTF_ID_SFMB, 4), MVR_E_INCONSISTENT_MEDIA_LAYOUT);

    } WsbCatchAndDo(hr,
        // Seek back to the beginning of the block
        (void) m_pStream->Seek(startBlockPosition, STREAM_SEEK_SET, NULL);
        m_nFormatLogicalAddress = nFormatLogicalAddress;
        );

    WsbTraceOut(OLESTR("CMTFSession::SkipOverEndOfDataSet"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}

HRESULT
CMTFSession::PrepareForEndOfDataSet(void)
/*++

Routine Description:
    
    Write an ESPB block in case that last complete fla is NOT aligned with pba
    File position should be aligned with pba after the method ends

Arguments:

    None.

Return Value:

    S_OK        -  Success.

--*/
{
    HRESULT hr = S_OK;
    LARGE_INTEGER startBlockPosition = {0,0};
    LARGE_INTEGER zero = {0,0};
    UINT64 nRemainder;
    UINT64 nFormatLogicalAddress = m_nFormatLogicalAddress;

    WsbTraceIn(OLESTR("CMTFSession::PrepareForEndOfDataSet"), OLESTR(""));

    try {
        // ESPB block should be written only if:
        //  1. Physical Block size is larger than MTF Logical Block size
        //  2. Current location is not aligned with pba (it already must be aligned with fla)
        UINT16 uAlignmentFactor = m_pMTFApi->MTF_GetAlignmentFactor();
        if (m_nBlockSize != uAlignmentFactor) {
            WsbAffirmHr(m_pStream->Seek(zero, STREAM_SEEK_CUR, (ULARGE_INTEGER *)&startBlockPosition));
            nRemainder = startBlockPosition.QuadPart % m_nBlockSize;
            if (0 != nRemainder) {
                size_t nSizeUsed = 0;
                size_t nBufUsed = 0;

                ULONG bytesWritten = 0;
                ULONG bytesToWrite;

                WsbTrace(OLESTR("Writing ESPB for Recovery, completing a remainder of %I64u bytes (%I64u fla) to pba\n"),
                    nRemainder, (nRemainder / uAlignmentFactor));

                (void) InitCommonHeader();
                m_sHeaderInfo.uControlBlockId       = m_nCurrentBlockId++;
                m_sHeaderInfo.uFormatLogicalAddress = m_nFormatLogicalAddress;

                // **MTF API CALL**
                WsbAssertNoError(m_pMTFApi->MTF_WriteESPBDblk(&m_sHeaderInfo, m_pBuffer+m_nBufUsed, m_nBufSize, &nSizeUsed));
                WsbAssertNoError(m_pMTFApi->MTF_PadToNextPhysicalBlockBoundary(m_pBuffer, m_nBlockSize, nSizeUsed, m_nBufSize, &nBufUsed));

                // Write data and flush
                bytesToWrite = (ULONG)(m_nBlockSize - nRemainder);
                WsbAffirmHr(m_pStream->Write(m_pBuffer, bytesToWrite, &bytesWritten));
                WsbAffirm((bytesWritten == bytesToWrite), E_FAIL);
                WsbAffirmHr(m_pStream->Commit(0));  // Flush the device buffers
                m_nFormatLogicalAddress += bytesWritten / uAlignmentFactor;
            }
        }

    } WsbCatchAndDo(hr,
        // Seek back to the beginning of the block
        (void) m_pStream->Seek(startBlockPosition, STREAM_SEEK_SET, NULL);
        m_nCurrentBlockId--;
        );

    WsbTraceOut(OLESTR("CMTFSession::PrepareForEndOfDataSet"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}

HRESULT 
CMTFSession::SkipOverStreams(IN UINT64 uOffsetToFirstStream)
/*++

Routine Description:
    
    Skips over all streams of current block
    Expects to find a SPAD stream as the last one (if data is not truncated)

Arguments:

    uOffsetToFirstStream - Offset to the beginning of the first stream (absolute position)

Return Value:

    S_OK        -  Success.
    MVR_E_NOT_FOUND - Stream is missing or cut in the middle

--*/
{
    HRESULT hr = S_OK;
    LARGE_INTEGER startStreamPosition = {0,0};

    WsbTraceIn(OLESTR("CMTFSession::SkipOverStreams"), OLESTR(""));

    try {
        UINT16 uAlignmentFactor = m_pMTFApi->MTF_GetAlignmentFactor();
        ULONG bytesRead = 0;
        ULONG bytesToRead = (ULONG)sizeof(MTF_STREAM_INFO);

        UINT64   uStreamLength;
        LARGE_INTEGER skipToPosition = {0,0};
        LARGE_INTEGER endPosition = {0,0};
        LARGE_INTEGER zero = {0,0};

        BOOL bMoreStreams = TRUE;

        // Keep end position
        WsbAffirmHr(m_pStream->Seek(zero, STREAM_SEEK_END, (ULARGE_INTEGER *)&endPosition));

        // Seek to begining of first stream
        skipToPosition.QuadPart = uOffsetToFirstStream;
        WsbAffirmHr(m_pStream->Seek(skipToPosition, STREAM_SEEK_SET, NULL));

        while (bMoreStreams) {
            // keep current position, before stream starts
            startStreamPosition.QuadPart = skipToPosition.QuadPart;

            // Read stream header
            WsbAffirmHr(m_pStream->Read(m_pBuffer, bytesToRead, &bytesRead));
            if (bytesRead < bytesToRead) {
                // incomplete stream
                WsbThrow(MVR_E_NOT_FOUND);
            }

            MTF_STREAM_INFO sHdrInfo;
            m_pMTFApi->MTF_ReadStreamHeader(&sHdrInfo, m_pBuffer);

            if (0 == memcmp(sHdrInfo.acStreamId, MTF_PAD_STREAM, 4)) {
                bMoreStreams = FALSE;
            }

            // Skip to the next stream
            uStreamLength = sHdrInfo.uStreamLength + sizeof(MTF_STREAM_INFO);
            if (uStreamLength % 4) {
                uStreamLength = uStreamLength - (uStreamLength % 4) + 4;
            }
            WsbAffirmHr(m_pStream->Seek(zero, STREAM_SEEK_CUR, (ULARGE_INTEGER *)&skipToPosition));
            skipToPosition.QuadPart = skipToPosition.QuadPart + uStreamLength - bytesToRead;
            if (skipToPosition.QuadPart > endPosition.QuadPart) {
                // incomplete block
                WsbThrow(MVR_E_NOT_FOUND);
            }
            WsbAffirmHr(m_pStream->Seek(skipToPosition, STREAM_SEEK_SET, NULL));
        }

        // If we got here, SPAD was found and skipped hence we must be FLA alligned
        WsbAssert(0 == (skipToPosition.QuadPart % uAlignmentFactor), MVR_E_INCONSISTENT_MEDIA_LAYOUT);

    } WsbCatchAndDo(hr,
        // Seek back to the end of the last complete & valid stream
        (void) m_pStream->Seek(startStreamPosition, STREAM_SEEK_SET, NULL);
        );


    WsbTraceOut(OLESTR("CMTFSession::SkipOverStreams"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


HRESULT
CMTFSession::PadToNextPBA(void)
/*++

Routine Description:

    Writes an SPAD to the transfer buffer upto the next physical block boundary.

Arguments:

    None.

Return Value:

    S_OK        -  Success.

--*/
{
    HRESULT hr = S_OK;

    WsbTraceIn(OLESTR("CMTFSession::PadToNextPBA"), OLESTR(""));

    try {
        MvrInjectError(L"Inject.CMTFSession::PadToNextPBA.0");

        WsbAssertPointer(m_pBuffer);

        // **MTF API CALL **
        // Write an SPAD out to the next physical block boundary.
        WsbAssertNoError(m_pMTFApi->MTF_PadToNextPhysicalBlockBoundary(m_pBuffer, m_nBlockSize, m_nBufUsed, m_nBufSize, &m_nBufUsed));

        // At this point our buffer should be padded out to
        // the next physical block boundary, which means it is
        // ready to be written in its entirety to the target
        // media.

        // Write out the data and SPAD stream.
        WsbAffirmHr(FlushBuffer(m_pBuffer, &m_nBufUsed));

        // Everything in the buffer should be written out when
        // the buffer is aligned on a physical block boundary.
        WsbAssert(0 == m_nBufUsed, E_UNEXPECTED);

    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CMTFSession::PadToNextPBA"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


HRESULT
CMTFSession::PadToNextFLA(
    BOOL flush)
/*++

Routine Description:

    Writes an SPAD to the transfer buffer upto format logical block boundary.

Arguments:

    flush - if TRUE, the transfer buffer is flushed.

Return Value:

    S_OK        -  Success.

--*/
{
    HRESULT hr = S_OK;

    WsbTraceIn(OLESTR("CMTFSession::PadToNextFLA"), OLESTR("<%ls>"), WsbBoolAsString(flush));

    try {
        MvrInjectError(L"Inject.CMTFSession::PadToNextFLA.0");

        WsbAssertPointer(m_pBuffer);

        size_t startOfPad;

        // **MTF API CALL **
        // Write an SPAD out to the next alignment block boundary.
        startOfPad = m_nBufUsed;
        WsbAssertNoError(m_pMTFApi->MTF_PadToNextAlignmentFactor(m_pBuffer, m_nBufUsed, m_nBufSize, &m_nBufUsed));

        if (flush) {
            // Write out data and SPAD stream.
            WsbAffirmHr(FlushBuffer(m_pBuffer, &m_nBufUsed));
        }

        // Reset the location of the last SPAD within the buffer.
        // Note:  The value is only valid of m_nStartOfPad < m_nBufUsed.
        m_nStartOfPad = (m_nBufUsed > 0) ? startOfPad % m_nBlockSize : 0;

    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CMTFSession::PadToNextFLA"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


HRESULT
CMTFSession::WriteToDataSet(
    IN BYTE *pBuffer,
    IN ULONG nBytesToWrite,
    OUT ULONG *pBytesWritten)
/*++

Routine Description:

    Used to write all MTF data.
    Format Logical Address is updated to the current offset.

Arguments:

    pBuffer         -  Data buffer.
    nBytesToWrite   -  number of bytes to write in buffer.
    pBytesWritten   -  Bytes written.

Return Value:

    S_OK            -  Success.

--*/
{
    HRESULT hr = S_OK;

    try {
        MvrInjectError(L"Inject.CMTFSession::WriteToDataSet.0");
        WsbAssertPointer(m_pStream);
        WsbAssertPointer(pBuffer);
        WsbAssertPointer(pBytesWritten);

        *pBytesWritten = 0;

        // Make sure that we are asked to write only full blocks
        WsbAssert(!(nBytesToWrite % m_nBlockSize), MVR_E_LOGIC_ERROR);

        try {
            WsbAffirmHr(m_pStream->Write(pBuffer, nBytesToWrite, pBytesWritten));
        } WsbCatch(hr);

        // Making sure that we are writing only full blocks
        if (*pBytesWritten != nBytesToWrite) {
            WsbTraceAlways(OLESTR("Asked to write %lu bytes but wrote only %lu bytes. Write hr = <%ls>\n"),
                nBytesToWrite, *pBytesWritten, WsbHrAsString(hr));
            if (SUCCEEDED(hr)) {
                // Write "succeeded" buy didn't write all the bytes (full disk scenario):
                //  Shouldn't happen since caller is expected to verify that there's enough free space in advance.
                hr = E_FAIL;
            }
        }

        // Update the total number of alignment factors
        m_nFormatLogicalAddress += *pBytesWritten / (m_pMTFApi->MTF_GetAlignmentFactor());

    } WsbCatch(hr);

    return hr;
}


HRESULT
CMTFSession::ReadFromDataSet (
    IN BYTE *pBuffer,
    IN ULONG nBytesToRead,
    OUT ULONG *pBytesRead)
/*++

Routine Description:

    Used to read all MTF data.
    Format Logical Address is updated to the current offset.

Arguments:

    pBuffer     -  Data buffer.
    nBytesToRead -  number of bytes to read into buffer.
    pBytesRead  -  Bytes read.

Return Value:

    S_OK        -  Success.

--*/
{
    HRESULT hr = S_OK;

    try {
        MvrInjectError(L"Inject.CMTFSession::ReadFromDataSet.0");

        WsbAssertPointer(m_pStream);
        WsbAssertPointer(pBuffer);
        WsbAssertPointer(pBytesRead);

        // We need to set hr.  MVR_S_FILEMARK_DETECTED, MVR_S_SETMARK_DETECTED are Okay.
        hr = m_pStream->Read(pBuffer, nBytesToRead, pBytesRead);

        // update the total number of alignment factors
        m_nFormatLogicalAddress += *pBytesRead / (m_pMTFApi->MTF_GetAlignmentFactor());

        // Now test hr
        WsbAffirmHr(hr);

        // Make sure that we read only full blocks
        WsbAssert(!(*pBytesRead % m_nBlockSize), MVR_E_LOGIC_ERROR);


    } WsbCatch(hr);

    return hr;
}


HRESULT
CMTFSession::FlushBuffer(
    IN BYTE *pBuffer,
    IN OUT size_t *pBufPosition)
/*++

Routine Description:

    Writes as much of the buffer as possible out to the device.
    Any remaining data not written out is moved to the front of
    the buffer, and *pBufPosition is updated accordingly

Arguments:

    pBuffer      -  Data buffer.
    pBufPosition -  Number of bytes to write in buffer.  On output
                    holds the number of bytes still in the buffer.

Return Value:

    S_OK         -  Success.

--*/
{
    HRESULT hr = S_OK;

    ULONG   uPosition = (ULONG)(*pBufPosition);

    try {
        MvrInjectError(L"Inject.CMTFSession::FlushBuffer.0");

        // If the buffer has more than a physical block of bytes in it, dump as many as
        // possible to the device, then move the remaining data to the head of the buffer
        if (uPosition >= m_nBlockSize) {
            ULONG nBlocksToWrite;
            ULONG nBytesWritten = 0;

            // Determine the number of physical blocks to write
            nBlocksToWrite = uPosition / m_nBlockSize;

            try {
                // Write the data to the data set
                WsbAffirmHr(WriteToDataSet(pBuffer, nBlocksToWrite * m_nBlockSize, &nBytesWritten));
            } WsbCatch(hr);

            // Adjust the buffer position and slide the unwritten data down in the buffer
            WsbAssert(uPosition >= nBytesWritten, E_UNEXPECTED);
            uPosition -= nBytesWritten;
            memmove(pBuffer, pBuffer + nBytesWritten, uPosition);

            // Invalidate the pad start location after any flush.  This is reset in PadToNextFLA().
            m_nStartOfPad = 0;

        }

    } WsbCatch(hr);

    // Set output
    *pBufPosition = (size_t)uPosition;

    return hr;
}


HRESULT
CMTFSession::WriteFilemarks(
    IN ULONG nCount)
/*++

Routine Description:

    Writes count filemarks at the current location.

Arguments:

    nCount       -  Number of Filemarks to write.

Return Value:

    S_OK        -  Success.

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CMTFSession::WriteFilemarks"), OLESTR("<%u>"), nCount);

    try {
        MvrInjectError(L"Inject.CMTFSession::WriteFilemarks.0");

        WsbAssertPointer(m_pStream);
        WsbAssertPointer(m_pBuffer);

        UINT16 uAlignmentFactor = m_pMTFApi->MTF_GetAlignmentFactor();

        if ( nCount > 0) {
            // Can't write a filemark with data still in the transfer buffer if nCount > 0!
            WsbAssert(0 == m_nBufUsed, MVR_E_LOGIC_ERROR);

            UINT64 pba = 0;
            UINT64 curPos = 0;
            WsbAffirmHr(GetCurrentPBA(&curPos));  // From the stream I/O model

            if ( m_nPhysicalBlockAddress > 0 ) {
                // Make sure the FLA aligns with a PBA!
                WsbAssert(0 == (m_nFormatLogicalAddress*uAlignmentFactor) % m_nBlockSize, MVR_E_LOGIC_ERROR);

                // Provided there's nothing in the transfer buffer, this is an accurate calc.
                pba = m_nPhysicalBlockAddress + ((m_nFormatLogicalAddress*uAlignmentFactor)/m_nBlockSize);

                // Make sure we are where we think we are.
                WsbAssert(curPos == pba, MVR_E_LOGIC_ERROR);
            }
            else {

                //
                // We skip the consistency check for the case were we're writing filemarks
                // through the session model and m_nPhysicalBlockAddress is uninitialzed.
                // This happens we we are writing an ESET sequence in dataset recovery code.
                // 

                pba = curPos;

            }

            if (TRUE == m_bUseSoftFilemarks) {
                LONG n = nCount;

                if (n > 0) {
                    UINT32 pba32 = (UINT32) pba;

                    // Soft Filemark support only handles 2^32 * 1 KByte media (16 TBytes using 1 KByte logical Blocks)
                    // Some day this won't be enough... and we'll know!
                    WsbAssert((UINT64)pba32 == pba, E_UNEXPECTED);

                    // One last check... Can't write out more filemarks, at one time, than can be stored in
                    // the filemark table.
                    WsbAssert(nCount < m_pSoftFilemarks->uNumberOfFilemarkEntries, E_UNEXPECTED);

                    while(n-- > 0) {
                        // **MTF API CALL**
                        m_pMTFApi->MTF_InsertSoftFilemark(m_pSoftFilemarks, pba32++);
                        // **MTF API CALL**
                        WsbAssertNoError(m_pMTFApi->MTF_WriteSFMBDblk(&m_sHeaderInfo, m_pSoftFilemarks, m_pBuffer, m_nBufSize, &m_nBufUsed));

                        // Write out the SFMB DBLK.
                        WsbAffirmHr(FlushBuffer(m_pBuffer, &m_nBufUsed));

                        // Everything should be written to media after a filemark!
                        WsbAssert(0 == m_nBufUsed, MVR_E_LOGIC_ERROR);

                        // PBA counter should never roll over!
                        WsbAssert(pba32 > 0, E_UNEXPECTED);
                    };

                }

                WsbAffirmHr(m_pStream->Commit(0));  // Flush the device buffers

                // NOTE:  The total number of alignment factors is updated via FlushBuffer(),
                //        so we don't need to do it here.

            }
            else {
                // We use the IStream::Commit interface to write out the filemark.
                // This is not a perfect match in that the nCount parameter is supposed to
                // be a commit flag, not filemark count. Zero flushes device buffers
                // without writing a filemark. 
                WsbAffirmHr(m_pStream->Commit(nCount));

                // update the total number of alignment factors
                m_nFormatLogicalAddress += (nCount * m_nBlockSize) / uAlignmentFactor;
            }
        }
        else {
            // 0 == nCount implies flush device buffers.
            //
            // We skip all consistency checks since it is
            // is always safe to flush device buffers.
            //
            WsbAffirmHr(m_pStream->Commit(0));  // Flush the device buffers
        }

    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CMTFSession::WriteFilemarks"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


HRESULT
CMTFSession::GetCurrentPBA(
    OUT UINT64 *pPosition)
/*++

Routine Description:

    Returns the current physical block address relative the current partition.

Arguments:

    pPostion    -  Receives the current physical block address.

Return Value:

    S_OK        -  Success.

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CMTFSession::GetCurrentPBA"), OLESTR(""));

    ULARGE_INTEGER position = {0xffffffff,0xffffffff};

    try {
        MvrInjectError(L"Inject.CMTFSession::GetCurrentPBA.0");

        WsbAssertPointer(m_pStream);
        WsbAssertPointer(pPosition);

        LARGE_INTEGER zero = {0,0};

        // Gets the current position.
        WsbAffirmHr(m_pStream->Seek(zero, STREAM_SEEK_CUR, &position));

        position.QuadPart = position.QuadPart / m_nBlockSize;
        *pPosition = position.QuadPart;


    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CMTFSession::GetCurrentPBA"), OLESTR("hr = <%ls>, pos=%I64u"), WsbHrAsString(hr), position);

    return hr;
}


HRESULT
CMTFSession::SetCurrentPBA(
    IN UINT64 position)
/*++

Routine Description:

    Returns the current physical block address relative the current partition.

Arguments:

    postion     -  The physical block address to position to.

Return Value:

    S_OK        -  Success.

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CMTFSession::SetCurrentPBA"), OLESTR("<%I64u>"), position);

    try {
        WsbAssertPointer(m_pStream);

        LARGE_INTEGER seekTo;
        seekTo.QuadPart = position * m_nBlockSize;

        // Move to the specified position.
        WsbAffirmHr(m_pStream->Seek(seekTo, STREAM_SEEK_SET, NULL));

        m_nPhysicalBlockAddress = position;

    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CMTFSession::SetCurrentPBA"), OLESTR("hr = <%ls>, pos=%I64u"), WsbHrAsString(hr), m_nPhysicalBlockAddress);

    return hr;
}


HRESULT
CMTFSession::SpaceToEOD(void)
/*++

Routine Description:

    Positions the media to the end of data of the current partition.

Arguments:

    None.

Return Value:

    S_OK        -  Success.

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CMTFSession::SpaceToEOD"), OLESTR(""));

    UINT64 curPos = 0xffffffffffffffff;

    try {
        MvrInjectError(L"Inject.CMTFSession::SpaceToEOD.0");

        WsbAssertPointer(m_pStream);

        LARGE_INTEGER zero = {0,0};

        // Sets the current position to the end of data.
        WsbAffirmHr(m_pStream->Seek(zero, STREAM_SEEK_END, NULL));

        WsbAffirmHr(GetCurrentPBA(&curPos));

        m_nPhysicalBlockAddress = curPos;

    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CMTFSession::SpaceToEOD"), OLESTR("hr = <%ls>, pos=%I64u"), WsbHrAsString(hr), curPos);

    return hr;
}


HRESULT
CMTFSession::SpaceToBOD(void)
/*++

Routine Description:

    Posotions the media to the beginnning of the current partition.

Arguments:

    None.

Return Value:

    S_OK        -  Success.

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CMTFSession::SpaceToBOD"), OLESTR(""));

    UINT64 curPos = 0xffffffffffffffff;

    try {
        MvrInjectError(L"Inject.CMTFSession::SpaceToBOD.0");

        WsbAssertPointer(m_pStream);

        LARGE_INTEGER zero = {0,0};

        // Sets the current position to the beginning of data.
        WsbAffirmHr(m_pStream->Seek(zero, STREAM_SEEK_SET, NULL));

        WsbAffirmHr(GetCurrentPBA(&curPos));

        m_nPhysicalBlockAddress = curPos;

    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CMTFSession::SpaceToBOD"), OLESTR("hr = <%ls>, pos=%I64u"), WsbHrAsString(hr), curPos);

    return hr;
}

HRESULT
CMTFSession::ReadTapeDblk(OUT WCHAR **pszLabel)
/*++

Routine Description:
    
    Skips over a SSET DBLK 
    Expects to find a full or partial SSET DBLK but no other data.

Arguments:

    pszLabel - Pointer to a buffer to hold the RSS tape label.
               Reallocated as necessary

Return Value:

    S_OK        -  Success.
    MVR_E_UNKNOWN_MEDIA - No TAPE DBLK or not RSS TAPE

--*/
{
    HRESULT hr = S_OK;
    ULONG bytesRead = 0;

    WsbTraceIn(OLESTR("CMTFSession::ReadTapeDblk"), OLESTR(""));

    try {
        ULARGE_INTEGER position = {0,0};
        LARGE_INTEGER zero = {0,0};

        // The MTF labels are < 1024 bytes.  We need to read 1024 bytes + the filemark
        // (1 block), 3x the min block size covers all cases.
        // The MTFSession work buffer is at least 2 blocks
        ULONG nBlocks = (3*512)/m_nBlockSize;
        nBlocks = (nBlocks < 2) ? 2 : nBlocks;

        ULONG bytesToRead = nBlocks * m_nBlockSize;
        WsbAssertPointer(m_pBuffer);
        memset(m_pBuffer, 0, bytesToRead);

        // Sets the current position to the beginning of data.
        WsbAffirmHr(m_pStream->Seek(zero, STREAM_SEEK_SET, &position));

        // Read upto first Filemark.
        WsbAffirmHr(m_pStream->Read(m_pBuffer, bytesToRead, &bytesRead));

        MTF_DBLK_HDR_INFO sHdrInfo;
        MTF_DBLK_TAPE_INFO sTapeInfo;
        m_pMTFApi->MTF_ReadTAPEDblk(&sHdrInfo, &sTapeInfo, m_pBuffer);

        // Is this a MTF Tape?
        WsbAffirm(0 == memcmp(sHdrInfo.acBlockType, MTF_ID_TAPE, 4), MVR_E_UNKNOWN_MEDIA);

        // Now try to identify it as one of ours,
        // using the following criteria:
        //   1) It has a UNICODE tape name and tape description and software name.
        //   2) It has our Vendor Id (accept both old Win2K id and current id).
        WsbAffirm(sHdrInfo.uStringType == MTF_STRING_UNICODE_STR, MVR_E_UNKNOWN_MEDIA);
        WsbAffirm(sTapeInfo.szTapeName, MVR_E_UNKNOWN_MEDIA);
        WsbAffirm(sTapeInfo.szTapeDescription, MVR_E_UNKNOWN_MEDIA);
        WsbAffirm(sTapeInfo.szSoftwareName, MVR_E_UNKNOWN_MEDIA);

        WsbAffirm((REMOTE_STORAGE_MTF_VENDOR_ID == sTapeInfo.uSoftwareVendorId) ||
                  (REMOTE_STORAGE_WIN2K_MTF_VENDOR_ID == sTapeInfo.uSoftwareVendorId), 
                  MVR_E_UNKNOWN_MEDIA);

        CWsbStringPtr label = sTapeInfo.szTapeDescription;
        *pszLabel = NULL;
        WsbAffirmHr(label.CopyTo(pszLabel));

    } WsbCatchAndDo(hr,
        // Trace the illegal buffer where the RSS TAPE DBLK should reside
        if (m_pBuffer) {
            WsbTraceBuffer(bytesRead, m_pBuffer);
        }
    );

    WsbTraceOut(OLESTR("CMTFSession::ReadTapeDblk"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\mover\server\ntfileio.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    NtFileIo.cpp

Abstract:

    CNtFileIo class

Author:

    Brian Dodd          [brian]         25-Nov-1997

Revision History:

--*/

#include "stdafx.h"
#include "NtFileIo.h"
#include "engine.h"
#include "wsbfmt.h"
#include "Mll.h"
#include "ntmsapi.h"
#include "aclapi.h"

int CNtFileIo::s_InstanceCount = 0;

////////////////////////////////////////////////////////////////////////////////
//
// CComObjectRoot Implementation
//

#pragma optimize("g", off)

STDMETHODIMP
CNtFileIo::FinalConstruct(void) 
/*++

Implements:

    CComObjectRoot::FinalConstruct

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtFileIo::FinalConstruct"), OLESTR(""));

    try {

        WsbAffirmHr(CComObjectRoot::FinalConstruct());

        (void) CoCreateGuid( &m_ObjectId );

        m_pSession = NULL;
        m_DataSetNumber = 0;

        m_hFile = INVALID_HANDLE_VALUE;
        m_DeviceName = MVR_UNDEFINED_STRING;
        m_Flags = 0;
        m_LastVolume = OLESTR("");
        m_LastPath = OLESTR("");

        m_ValidLabel = TRUE;

        m_StreamName = MVR_UNDEFINED_STRING;
        m_Mode = 0;
        m_StreamOffset.QuadPart = 0;
        m_StreamSize.QuadPart = 0;

        m_isLocalStream = FALSE;
        m_OriginalAttributes = 0;
        m_BlockSize = DefaultBlockSize;

    } WsbCatch(hr);

    s_InstanceCount++;
    WsbTraceAlways(OLESTR("CNtFileIo::s_InstanceCount += %d\n"), s_InstanceCount);

    WsbTraceOut(OLESTR("CNtFileIo::FinalConstruct"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP
CNtFileIo::FinalRelease(void) 
/*++

Implements:

    CComObjectRoot::FinalRelease

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtFileIo::FinalRelease"), OLESTR(""));

    try {

        (void) CloseStream();  // in case anything is left open

        CComObjectRoot::FinalRelease();

    } WsbCatch(hr);

    s_InstanceCount--;
    WsbTraceAlways(OLESTR("CNtFileIo::s_InstanceCount -= %d\n"), s_InstanceCount);

    WsbTraceOut(OLESTR("CNtFileIo::FinalRelease"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}
#pragma optimize("", on)


HRESULT
CNtFileIo::CompareTo(
    IN IUnknown *pCollectable,
    OUT SHORT *pResult)
/*++

Implements:

    CRmsComObject::CompareTo

--*/
{
    HRESULT     hr = E_FAIL;
    SHORT       result = 1;

    WsbTraceIn( OLESTR("CNtFileIo::CompareTo"), OLESTR("") );

    try {

        // Validate arguments - Okay if pResult is NULL
        WsbAssertPointer( pCollectable );

        // We need the IRmsComObject interface to get the value of the object.
        CComQIPtr<IDataMover, &IID_IDataMover> pObject = pCollectable;
        WsbAssertPointer( pObject );

        GUID objectId;

        // Get objectId.
        WsbAffirmHr( pObject->GetObjectId( &objectId ));

        if ( m_ObjectId == objectId ) {

            // Object IDs match
            hr = S_OK;
            result = 0;

        }
        else {
            hr = S_FALSE;
            result = 1;
        }

    }
    WsbCatch( hr );

    if ( SUCCEEDED(hr) && (0 != pResult) ){
       *pResult = result;
    }

    WsbTraceOut( OLESTR("CNtFileIo::CompareTo"),
                 OLESTR("hr = <%ls>, result = <%ls>"),
                 WsbHrAsString( hr ), WsbPtrToShortAsString( pResult ) );

    return hr;
}



HRESULT
CNtFileIo::IsEqual(
    IUnknown* pObject
    )

/*++

Implements:

  IWsbCollectable::IsEqual().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CNtFileIo::IsEqual"), OLESTR(""));

    hr = CompareTo(pObject, NULL);

    WsbTraceOut(OLESTR("CNtFileIo::IsEqual"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

////////////////////////////////////////////////////////////////////////////////
//
// ISupportErrorInfo Implementation
//


STDMETHODIMP
CNtFileIo::InterfaceSupportsErrorInfo(
    IN REFIID riid)
/*++

Implements:

    ISupportErrorInfo::InterfaceSupportsErrorInfo

--*/
{
    static const IID* arr[] = 
    {
        &IID_IDataMover,
        &IID_IStream,
    };

    for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
    {
        if (InlineIsEqualGUID(*arr[i],riid))
            return S_OK;
    }
    return S_FALSE;
}

////////////////////////////////////////////////////////////////////////////////
//
// IDataMover Implementation
//



STDMETHODIMP
CNtFileIo::GetObjectId(
    OUT GUID *pObjectId)
/*++

Implements:

    IRmsComObject::GetObjectId

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtFileIo::GetObjectId"), OLESTR(""));

    UNREFERENCED_PARAMETER(pObjectId);

    try {

        WsbAssertPointer( pObjectId );

        *pObjectId = m_ObjectId;

    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CNtFileIo::GetObjectId"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP
CNtFileIo::BeginSession(
    IN BSTR remoteSessionName,
    IN BSTR remoteSessionDescription,
    IN SHORT remoteDataSet,
    IN DWORD options)
/*++

Implements:

    IDataMover::BeginSession

  Notes:

    Each Mover session is written as a single MTF file data set. To create a consistant
    MTF data set we copy the MediaLabel data and use it for the TAPE DBLK for
    each data set generated.

--*/
{
    HRESULT hr = S_OK;
    CComPtr<IStream> pStream;

    WsbTraceIn(OLESTR("CNtFileIo::BeginSession"), OLESTR("<%ls> <%ls> <%d> <0x%08x>"),
        remoteSessionName, remoteSessionDescription, remoteDataSet, options);

    try {
        if (!(options & MVR_SESSION_METADATA)) {
            WsbAssert(remoteDataSet > 0, MVR_E_INVALIDARG);
        }
        WsbAffirm(TRUE == m_ValidLabel, E_ABORT);

        ULARGE_INTEGER nil = {0,0};

        CWsbBstrPtr label, tempLabel;
        const ULONG maxIdSize = 1024;
        BYTE identifier[maxIdSize];
        ULONG idSize;
        ULONG idType;
        DWORD mode;

        // We need to read the label and use this label for each dataset created.
        // One data set per session.  One data set per remote file.
        WsbAffirmHr(ReadLabel(&label));
        tempLabel = label;
        WsbAssertHr(VerifyLabel(tempLabel));

        // Try recovery, that is look for an indication for an incomplete data-set remote files
        // We continue even if Recovery fails since each data-set is kept in a separate file
        // Note: This code should be protected with CS when we support multiple migration to the SAME media
        (void) DoRecovery ();

        // Create the remote stream used for the entire session.
        // Use given remote session name as the remote file name
        mode = MVR_MODE_WRITE;
        if (options & MVR_SESSION_METADATA) {
            mode |= MVR_FLAG_SAFE_STORAGE;
        }
        WsbAffirmHr(CreateRemoteStream(remoteSessionName, mode, L"",L"",nil,nil,nil,nil,nil,0,nil, &pStream));
        WsbAssertPointer(pStream);

        // Create the Recovery indicator (avoid creating for safe-storage files)
        // Note: the Recovery indicator just indicates that a Recovery may be required
        if (! (mode & MVR_FLAG_SAFE_STORAGE)) {
            WsbAssert(m_StreamName != MVR_UNDEFINED_STRING, MVR_E_LOGIC_ERROR);
            WsbAffirmHr(CreateRecoveryIndicator(m_StreamName));
        }

        // Write the TAPE DBLK and filemark
        WsbAffirmHr(m_pSession->DoTapeDblk(label, maxIdSize, identifier, &idSize, &idType));

        m_DataSetNumber = remoteDataSet;

        // Convert session option type bits to MTFSessionType
        MTFSessionType type;

        switch (options & MVR_SESSION_TYPES) {
            case MVR_SESSION_TYPE_TRANSFER:
                type = MTFSessionTypeTransfer;
                break;
            case MVR_SESSION_TYPE_COPY:
                type = MTFSessionTypeCopy;
                break;
            case MVR_SESSION_TYPE_NORMAL:
                type = MTFSessionTypeNormal;
                break;
            case MVR_SESSION_TYPE_DIFFERENTIAL:
                type = MTFSessionTypeDifferential;
                break;
            case MVR_SESSION_TYPE_INCREMENTAL:
                type = MTFSessionTypeIncremental;
                break;
            case MVR_SESSION_TYPE_DAILY:
                type = MTFSessionTypeDaily;
                break;
            default:
                type = MTFSessionTypeCopy;
                break;
        }

        // Write the SSET DBLK
        WsbAffirmHr(m_pSession->DoSSETDblk(remoteSessionName, remoteSessionDescription, type, remoteDataSet));

    } WsbCatchAndDo(hr,
        if (pStream) {    
            (void) CloseStream();
        }
    );

    WsbTraceOut(OLESTR("CNtFileIo::BeginSession"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP
CNtFileIo::EndSession(void)
/*++

Implements:

    IDataMover::EndSession

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtFileIo::EndSession"), OLESTR(""));

    try {

        WsbAffirm(TRUE == m_ValidLabel, E_ABORT);

        // Write the trailing filemark, ESET DBLK, and filemark
        WsbAffirmHr(m_pSession->DoEndOfDataSet(m_DataSetNumber));

    } WsbCatch(hr);

    (void) CloseStream();

    if (! (m_Mode & MVR_FLAG_SAFE_STORAGE)) {
        WsbAssert(m_StreamName != MVR_UNDEFINED_STRING, MVR_E_LOGIC_ERROR);
        (void) DeleteRecoveryIndicator(m_StreamName);
    }

    // If Safe Storage flag is indicated, copy the temporary backup file to the dataset file
    // We copy by delete & rename (instead of copy) so if the dataset file exists, it is consistent
    if ((m_Mode & MVR_FLAG_SAFE_STORAGE) && (m_Mode & MVR_MODE_WRITE || m_Mode & MVR_MODE_APPEND)) {
        CWsbBstrPtr     datasetName;
        int             nLen, nExtLen;
        DWORD           dwStatus;

        // Build dataset name
        nLen = wcslen(m_StreamName);
        nExtLen = wcslen(MVR_SAFE_STORAGE_FILETYPE);
        WsbAffirmHr(datasetName.TakeFrom(NULL, nLen - nExtLen + wcslen(MVR_DATASET_FILETYPE) + 1));
        wcsncpy(datasetName, m_StreamName, nLen-nExtLen);
        wcscpy(&(datasetName[nLen-nExtLen]), MVR_DATASET_FILETYPE);

        // No need to flush bedore Copy since flush-buffers always follows writing FILEMARKs
        if (! DeleteFile(datasetName)) {
            // DeleteFile may fail with NOT_FOUND if the dataset file is created for the first time
            dwStatus = GetLastError();
            if (ERROR_FILE_NOT_FOUND != dwStatus) {
                WsbAffirmNoError(dwStatus);
            }
        }

        WsbAffirmStatus(MoveFile(m_StreamName, datasetName));
    }

    // Clear internal data (such that another Mover Session could be started)
    m_Flags = 0;
    m_LastVolume = OLESTR("");
    m_LastPath = OLESTR("");
    m_ValidLabel = TRUE;
    m_isLocalStream = FALSE;
    m_OriginalAttributes = 0;

    WsbTraceOut(OLESTR("CNtFileIo::EndSession"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP
CNtFileIo::StoreData(
    IN BSTR localName,
    IN ULARGE_INTEGER localDataStart,
    IN ULARGE_INTEGER localDataSize,
    IN DWORD flags,
    OUT ULARGE_INTEGER* pRemoteDataSetStart,
    OUT ULARGE_INTEGER* pRemoteFileStart,
    OUT ULARGE_INTEGER* pRemoteFileSize,
    OUT ULARGE_INTEGER* pRemoteDataStart,
    OUT ULARGE_INTEGER* pRemoteDataSize,
    OUT DWORD* pRemoteVerificationType,
    OUT ULARGE_INTEGER* pRemoteVerificationData,
    OUT DWORD* pDatastreamCRCType,
    OUT ULARGE_INTEGER* pDatastreamCRC,
    OUT ULARGE_INTEGER* pUsn)
/*++

Implements:

    IDataMover::StoreData

--*/
{
    HRESULT hr = S_OK;

    HANDLE hSearchHandle = INVALID_HANDLE_VALUE;
    HANDLE hFile = INVALID_HANDLE_VALUE;

    WsbTraceIn(OLESTR("CNtFileIo::StoreData"), OLESTR("<%ls> <%I64u> <%I64u> <0x%08x>"),
        WsbAbbreviatePath((WCHAR *) localName, 120), localDataStart.QuadPart, localDataSize.QuadPart, flags);

    WsbTraceAlways(OLESTR("CNtFileIo::StoreData - Begin\n"));
    try {
        MvrInjectError(L"Inject.CNtFileIo::StoreData.0");

        WsbAssertPointer(m_pSession);
        WsbAffirm(TRUE == m_ValidLabel, E_ABORT);

        // Default is to perform non-case sensitive searches.
        // So knock down the posix flag.
        m_Flags &= ~MVR_FLAG_POSIX_SEMANTICS;

        // Default is to not commit after each file.
        // So knock down the commit flag.
        m_Flags &= ~MVR_FLAG_COMMIT_FILE;

        // Default is to write one DIRB containing all directory info
        //  instead of writing a DIRB for each directory level.
        // So knock down the write parent dir info flag.
        m_Flags &= ~MVR_FLAG_WRITE_PARENT_DIR_INFO;

        m_Flags |= flags;
        m_Flags |= MVR_MODE_WRITE;

        // Unconditionally set the case sensitive flag for each file.
        // We allow this flag to be set on a per file basis
        WsbTrace(OLESTR("Posix Semantics Flag: <%ls>\n"), WsbBoolAsString(MVR_FLAG_POSIX_SEMANTICS & m_Flags));
        WsbAffirmHr(m_pSession->SetUseCaseSensitiveSearch(MVR_FLAG_POSIX_SEMANTICS & m_Flags));

        // This tells the session object to pad to a block boundary and flush the device
        // after the file is written.
        WsbTrace(OLESTR("Commit Flag: <%ls>\n"), WsbBoolAsString(MVR_FLAG_COMMIT_FILE & m_Flags));
        WsbAffirmHr(m_pSession->SetCommitFile(MVR_FLAG_COMMIT_FILE & m_Flags));

        WsbTrace(OLESTR("ParentDirInfo Flag: <%ls>\n"), WsbBoolAsString(MVR_FLAG_WRITE_PARENT_DIR_INFO & m_Flags));

        if ((MVR_FLAG_BACKUP_SEMANTICS & m_Flags) || (MVR_FLAG_HSM_SEMANTICS & m_Flags)) {

            // Compare the volume and path with the last ones written to tape.

            CWsbStringPtr pathname;

            WCHAR *end;
            LONG numChar;

            pathname = localName;

            // strip off the path and file name
            end = wcschr((WCHAR *)pathname, L'\\');
            WsbAssert(end != NULL, MVR_E_INVALIDARG);
            numChar =(LONG)(end - (WCHAR *)pathname + 1);  // keep the trailing backslash
            WsbAssert(numChar > 0, E_UNEXPECTED);
            ((WCHAR *)pathname)[numChar] = L'\0';

            // We do a case sensitive search if using Posix semantics.
            WsbTrace(OLESTR("Comparing with last volume: <%ls>\n"), WsbAbbreviatePath((WCHAR *) m_LastVolume, 120));

            if ( ((MVR_FLAG_POSIX_SEMANTICS & ~m_Flags)) && (0 != _wcsicmp((WCHAR *) m_LastVolume, (WCHAR *) pathname)) ||
                 ((MVR_FLAG_POSIX_SEMANTICS & m_Flags) && (0 != wcscmp((WCHAR *) m_LastVolume, (WCHAR *) pathname))) ) {
                // write the VOLB DBLK
                WsbAffirmHr(m_pSession->DoVolumeDblk(pathname));
                m_LastVolume = pathname;
            }

            pathname = localName;

            // strip off the file name
            end = wcsrchr((WCHAR *)pathname, L'\\');
            WsbAssert(end != NULL, MVR_E_INVALIDARG);
            numChar = (LONG)(end - (WCHAR *)pathname);
            WsbAssert(numChar > 0, E_UNEXPECTED);
            ((WCHAR *)pathname)[numChar] = L'\0';

            // pathname is now in the form "Volume{guid}\dir1\...\dirn"
            //                      or "<drive letter>:\dir1\...\dirn"

/***
   m_Flags |= MVR_FLAG_WRITE_PARENT_DIR_INFO;
***/
            WsbTrace(OLESTR("Comparing with last path: <%ls>\n"), WsbAbbreviatePath((WCHAR *) m_LastPath, 120));

            // We do a case sensitive search if using Posix semantics.
            if ( ((MVR_FLAG_POSIX_SEMANTICS & ~m_Flags)) && (0 != _wcsicmp((WCHAR *) m_LastPath, (WCHAR *) pathname)) ||
                 ((MVR_FLAG_POSIX_SEMANTICS & m_Flags) && (0 != wcscmp((WCHAR *) m_LastPath, (WCHAR *) pathname))) ) {

                if (MVR_FLAG_HSM_SEMANTICS & m_Flags) {

                    // We're not supporting this anymore!
                    WsbThrow(E_NOTIMPL);

                    WCHAR szRoot[16];
                      
                    // We use a flat file structure for MVR_FLAG_HSM_SEMANTICS
                    WsbAffirmHr(m_pSession->SetUseFlatFileStructure(TRUE));

                    // do DIRB DBLKs for root
                    wcscpy(szRoot, L"X:\\");
                    szRoot[0] = localName[0];
                    WsbAffirmHr(m_pSession->DoParentDirectories(szRoot));

                }
                else if (MVR_FLAG_WRITE_PARENT_DIR_INFO & m_Flags) {
                    // do a DIRB DBLK for each directory level of the file(s) to be backed up.
                    WsbAffirmHr(m_pSession->DoParentDirectories(pathname));
                    m_LastPath = pathname;
                }
                else {
                    // do one DIRB DBLK for the whole directory structure of the file(s) to be backed up.
                    WIN32_FIND_DATAW obFindData;
                    CWsbStringPtr tempPath;

                    DWORD additionalSearchFlags = 0;
                    additionalSearchFlags |= (m_Flags & MVR_FLAG_POSIX_SEMANTICS) ? FIND_FIRST_EX_CASE_SENSITIVE : 0;

                    tempPath = pathname;
                    tempPath.Prepend(OLESTR("\\\\?\\"));

                    if (NULL == wcschr((WCHAR *)tempPath+4, L'\\'))
                    {
                        // no path (i.e. we're at the root)
                        BY_HANDLE_FILE_INFORMATION obGetFileInfoData;
                        memset(&obGetFileInfoData, 0, sizeof(BY_HANDLE_FILE_INFORMATION));
                        tempPath.Append(OLESTR("\\"));
                        // ** WIN32 API Calls
                        WsbAffirmHandle(hFile = CreateFile(tempPath, 0, 0, NULL, OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, NULL));
                        WsbAffirmStatus(GetFileInformationByHandle(hFile, &obGetFileInfoData));
                        // copy info from GetFileInformationByHandle call (BY_HANDLE_FILE_INFORMATION struct)
                        // .. into obFindData (WIN32_FIND_DATAW struct) for DoDirectoryDblk call.
                        memset(&obFindData, 0, sizeof(WIN32_FIND_DATAW));
                        obFindData.dwFileAttributes = obGetFileInfoData.dwFileAttributes;
                        obFindData.ftCreationTime   = obGetFileInfoData.ftCreationTime;
                        obFindData.ftLastAccessTime = obGetFileInfoData.ftLastAccessTime;
                        obFindData.ftLastWriteTime  = obGetFileInfoData.ftLastWriteTime;
                    }
                    else {
                        // ** WIN32 API Call - gets file info
                        WsbAffirmHandle(hSearchHandle = FindFirstFileEx((WCHAR *) tempPath, FindExInfoStandard, &obFindData, FindExSearchLimitToDirectories, 0, additionalSearchFlags));
                    }
                    WsbAffirmHr(m_pSession->DoDirectoryDblk((WCHAR *) pathname, &obFindData)); 
                    if (hSearchHandle != INVALID_HANDLE_VALUE) {
                        FindClose(hSearchHandle);
                        hSearchHandle = INVALID_HANDLE_VALUE;
                    }
                    if (hFile != INVALID_HANDLE_VALUE) {
                        CloseHandle(hFile);
                        hFile = INVALID_HANDLE_VALUE;
                    }
                    m_LastPath = pathname;
                }
            }
        }

        // The following uses code to store multiple files, but the 
        // RS Hints is only valid for the last file.  With the current
        // implementation, the HSM engine sends one file request through
        // StoreData at a time.  The caveat is that Posix is case
        // sensitive, and therefore files created in this fashion could
        // overload the same filename (ignoring case) with multiple files.
        WsbAffirmHr(m_pSession->DoDataSet(localName));

        *pRemoteDataSetStart     = m_pSession->m_sHints.DataSetStart;
        *pRemoteFileStart        = m_pSession->m_sHints.FileStart;
        *pRemoteFileSize         = m_pSession->m_sHints.FileSize;
        *pRemoteDataStart        = m_pSession->m_sHints.DataStart;
        *pRemoteDataSize         = m_pSession->m_sHints.DataSize;
        *pRemoteVerificationType = m_pSession->m_sHints.VerificationType;
        *pRemoteVerificationData = m_pSession->m_sHints.VerificationData;
        *pDatastreamCRCType      = m_pSession->m_sHints.DatastreamCRCType;
        *pDatastreamCRC          = m_pSession->m_sHints.DatastreamCRC;
        *pUsn                    = m_pSession->m_sHints.FileUSN;

    } WsbCatchAndDo(hr,

            if (hSearchHandle != INVALID_HANDLE_VALUE) {
                FindClose(hSearchHandle);
                hSearchHandle = INVALID_HANDLE_VALUE;
            }
            if (hFile != INVALID_HANDLE_VALUE) {
                CloseHandle(hFile);
                hFile = INVALID_HANDLE_VALUE;
            }

            WsbLogEvent(MVR_MESSAGE_DATA_TRANSFER_ERROR, 0, NULL,
                WsbAbbreviatePath((WCHAR *) localName, 120), WsbHrAsString(hr), NULL);

            // All fatal device errors are converted to E_ABORT so the calling code
            // can detect this general class of problem.
            switch(hr) {
            case MVR_E_BUS_RESET:
            case MVR_E_MEDIA_CHANGED:
            case MVR_E_NO_MEDIA_IN_DRIVE:
            case MVR_E_DEVICE_REQUIRES_CLEANING:
            case MVR_E_SHARING_VIOLATION:
            case MVR_E_ERROR_IO_DEVICE:
            case MVR_E_ERROR_DEVICE_NOT_CONNECTED:
            case MVR_E_ERROR_NOT_READY:
                hr = E_ABORT;
                break;

            case MVR_E_INVALID_BLOCK_LENGTH:
            case MVR_E_WRITE_PROTECT:
            case MVR_E_CRC:
                hr = MVR_E_MEDIA_ABORT;
                break;

            default:
                break;
            }

        );

    WsbTraceAlways(OLESTR("CNtFileIo::StoreData - End\n"));


    WsbTraceOut(OLESTR("CNtFileIo::StoreData"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP
CNtFileIo::RecallData (
    IN BSTR /*localName*/,
    IN ULARGE_INTEGER /*localDataStart*/,
    IN ULARGE_INTEGER /*localDataSize*/,
    IN DWORD /*options*/,
    IN BSTR /*migrateFileName*/,
    IN ULARGE_INTEGER /*remoteDataSetStart*/,
    IN ULARGE_INTEGER /*remoteFileStart*/,
    IN ULARGE_INTEGER /*remoteFileSize*/,
    IN ULARGE_INTEGER /*remoteDataStart*/,
    IN ULARGE_INTEGER /*remoteDataSize*/,
    IN DWORD /*verificationType*/,
    IN ULARGE_INTEGER /*verificationData*/)
/*++

Implements:

    IDataMover::RecallData

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtFileIo::RecallData"), OLESTR(""));

    try {

        WsbThrow( E_NOTIMPL );

    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CNtFileIo::RecallData"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP
CNtFileIo::FormatLabel(
    IN BSTR displayName,
    OUT BSTR* pLabel)
/*++

Implements:

    IDataMover::FormatLabel

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtFileIo::FormatLabel"), OLESTR("<%ls>"), displayName);

    try {
        WsbAssertPointer(pLabel);
        WsbAssertPointer(displayName);
        WsbAssert(wcslen((WCHAR *)displayName) > 0, E_INVALIDARG);
        WsbAssertPointer(m_pCartridge);

        // Media Label or Description
        CWsbBstrPtr label;

        // Tag
        label = OLESTR("MTF Media Label"); // Required text per MTF specification.

        // Version
        WsbAffirmHr(label.Append(OLESTR("|")));
        WsbAffirmHr(label.Append(WsbLongAsString(MTF_FORMAT_VER_MAJOR)));
        WsbAffirmHr(label.Append(OLESTR(".")));
        WsbAffirmHr(label.Append(WsbLongAsString(MTF_FORMAT_VER_MINOR)));

        // Vendor
        WsbAffirmHr(label.Append(OLESTR("|")));
        WsbAffirmHr(label.Append(REMOTE_STORAGE_MTF_VENDOR_NAME));

        // Vendor Product ID
        WsbAffirmHr(label.Append(OLESTR("|")));
        WsbAffirmHr(label.Append(REMOTE_STORAGE_MLL_SOFTWARE_NAME));

        // Creation Time Stamp
        WsbAffirmHr(label.Append(OLESTR("|")));
        WCHAR timeStamp[128];
        time_t lTime;
        time(&lTime);
        wcsftime(timeStamp, 128, L"%Y/%m/%d.%H:%M:%S", localtime(&lTime));
        WsbAffirmHr(label.Append(timeStamp));

        // Cartridge Label
        WsbAffirmHr(label.Append(OLESTR("|")));
        if (m_pCartridge) {

            // Use barcode if available
            CWsbBstrPtr barcode;
            if (S_OK == m_pCartridge->GetBarcode(&barcode)) {
                WsbAffirmHr(label.Append(barcode));
            }
            else {
                WsbAffirmHr(label.Append(displayName));
            }
        }
        else {
            WsbAffirmHr(label.Append(displayName));
        }

        // Side
        WsbAffirmHr(label.Append(OLESTR("|")));
        if (m_pCartridge) {

            // TODO: This is broken, we need to know if the cartridge is inverted?
            if (S_OK == m_pCartridge->IsTwoSided()) {
                WsbAffirmHr(label.Append(OLESTR("2")));
            }
            else {
                WsbAffirmHr(label.Append(OLESTR("1")));
            }
        }
        else {
            WsbAffirmHr(label.Append(OLESTR("1")));  // Default
        }

        // Media Id
        GUID cartId;
        WsbAffirmHr(label.Append(OLESTR("|")));

        if (m_pCartridge) {

            // Use cartridge Id
            if (S_OK == m_pCartridge->GetCartridgeId(&cartId)) {
                WsbAffirmHr(label.Append(WsbGuidAsString(cartId)));
            }
            else {
                WsbAffirmHr(label.Append(WsbGuidAsString(GUID_NULL)));
            }
        }
        else {
            WsbAffirmHr(label.Append(WsbGuidAsString(GUID_NULL)));
        }

        // Media Domain Id
        GUID mediaSetId;
        WsbAffirmHr(label.Append(OLESTR("|")));
        if (m_pCartridge) {

            // Use MediaSet Id
            if (S_OK == m_pCartridge->GetMediaSetId(&mediaSetId)) {
                WsbAffirmHr(label.Append(WsbGuidAsString(mediaSetId)));
            }
            else {
                WsbAffirmHr(label.Append(WsbGuidAsString(GUID_NULL)));
            }
        }
        else {
            WsbAffirmHr(label.Append(WsbGuidAsString(GUID_NULL)));
        }

        // Vendor Specific
        WsbAffirmHr(label.Append(OLESTR("|VS:DisplayName=")));
        WsbAffirmHr(label.Append(displayName));

        WsbAffirmHr(label.CopyToBstr(pLabel));

    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CNtFileIo::FormatLabel"), OLESTR("hr = <%ls>, label = <%ls>"), WsbHrAsString(hr), *pLabel);

    return hr;
}


STDMETHODIMP
CNtFileIo::WriteLabel(
    IN BSTR label)
/*++

Implements:

    IDataMover::WriteLabel

--*/
{
    CComPtr<IStream> pStream;
    HRESULT hr = S_OK;

    CWsbBstrPtr DirName;
    PSID pAdminSID = NULL;
    PSID pSystemSID = NULL;
    PACL pACL = NULL;
    PSECURITY_DESCRIPTOR pSD = NULL;
#define     REMOTE_DIR_NUM_ACE      2
    EXPLICIT_ACCESS ea[REMOTE_DIR_NUM_ACE];
    SID_IDENTIFIER_AUTHORITY SIDAuthNT = SECURITY_NT_AUTHORITY;
    SECURITY_ATTRIBUTES sa;

    WsbTraceIn(OLESTR("CNtFileIo::WriteLabel"), OLESTR("<%ls>"), label);

    try {
        WsbAssertPointer(label);
        WsbAssert(wcslen((WCHAR *)label) > 0, E_INVALIDARG);
        WsbAssertPointer(m_pCartridge);

        const ULONG maxIdSize = 1024;
        BYTE identifier[maxIdSize];
        ULONG idSize;
        ULONG idType;
        ULARGE_INTEGER nil = {0,0};

        // WriteLabel should be the first access to the remote media. 
        // Therefore, some media initialization is done here:
        //  1) Formatting the volume
        //  2) Creating RSS directory
        //  (We may consider moving this initialization part to rms unit)

        // Initialize volume (format in case of Removable Disk)
        UINT type = GetDriveType(m_DeviceName);
        switch (type) {
        case DRIVE_REMOVABLE: {
            // Format the volume on the media
            WCHAR *driveName = 0;
            WsbAffirmHr(m_DeviceName.CopyTo(&driveName));

            // Remove trailing backslash from drive name
            int len = wcslen(driveName);
            WsbAffirm(len > 0, E_UNEXPECTED);
            if (driveName[len-1] == OLECHAR('\\')) {
                driveName[len-1] = OLECHAR('\0');
            }

            // If the volume is already formatted to NTFS, perform a quick format
            BOOLEAN bQuickFormat = FALSE;
            BOOLEAN bNoFS = FALSE;
            WCHAR fileSystemType[MAX_PATH];
            if (! GetVolumeInformation((WCHAR *)m_DeviceName, NULL, 0,
                NULL, NULL, NULL, fileSystemType, MAX_PATH) ) {
                DWORD status = GetLastError();
                if (ERROR_UNRECOGNIZED_VOLUME == status) {
                    status = NO_ERROR;
                    bNoFS = TRUE;
                }
                WsbAffirmNoError(status);
            }
            if ( (! bNoFS) && (0 == wcscmp(L"NTFS", fileSystemType)) ) {
                bQuickFormat = TRUE;
                WsbTrace(OLESTR("CNtFileIo::WriteLabel: Quick formatting %ls to NTFS\n"), driveName);
            } else {
                WsbTrace(OLESTR("CNtFileIo::WriteLabel: Full formatting %ls to NTFS\n"), driveName);
            }

            hr = FormatPartition(driveName,                          // drive name
                                        FSTYPE_NTFS,                        // format to NTFS
                                        MVR_VOLUME_LABEL,                   // colume label
                                        WSBFMT_ENABLE_VOLUME_COMPRESSION,   // enable compression
                                        bQuickFormat,                       // Full or Quick format
                                        TRUE,                               // Force format
                                        0);                                // Use default allocation size

            WsbTrace(OLESTR("CNtFileIo::WriteLabel: Finish formatting hr=<%ls>\n"), WsbHrAsString(hr));

            if (! SUCCEEDED(hr)) {
                WsbLogEvent(MVR_MESSAGE_MEDIA_FORMAT_FAILED, 0, NULL, driveName, WsbHrAsString(hr), NULL);
                WsbFree(driveName);
                WsbAffirmHr(hr);
            }

            WsbFree(driveName);

            break;
            }

        case DRIVE_FIXED:
            // Delete files from RS remote directory
            WsbAffirmHr(DeleteAllData());
            break;

        case DRIVE_CDROM:
        case DRIVE_UNKNOWN:
        case DRIVE_REMOTE:
        case DRIVE_RAMDISK:
        default:
            WsbAssertHr(E_UNEXPECTED);
            break;
        }

        // Prepare security attribute for admin only access:
        memset(ea, 0, sizeof(EXPLICIT_ACCESS) * REMOTE_DIR_NUM_ACE);

        // Create a SID for the local system account
        WsbAssertStatus( AllocateAndInitializeSid( &SIDAuthNT, 1,
                             SECURITY_LOCAL_SYSTEM_RID,
                             0, 0, 0, 0, 0, 0, 0,
                             &pSystemSID) );

        // Initialize an EXPLICIT_ACCESS structure for an ACE.
        // The ACE allows the Administrators group full access to the directory
        ea[0].grfAccessPermissions = FILE_ALL_ACCESS;
        ea[0].grfAccessMode = SET_ACCESS;
        ea[0].grfInheritance = SUB_CONTAINERS_AND_OBJECTS_INHERIT;
        ea[0].Trustee.pMultipleTrustee = NULL;
        ea[0].Trustee.MultipleTrusteeOperation  = NO_MULTIPLE_TRUSTEE;
        ea[0].Trustee.TrusteeForm = TRUSTEE_IS_SID;
        ea[0].Trustee.TrusteeType = TRUSTEE_IS_USER;
        ea[0].Trustee.ptstrName  = (LPTSTR) pSystemSID;

        // Create a SID for the Administrators group.
        WsbAssertStatus( AllocateAndInitializeSid( &SIDAuthNT, 2,
                             SECURITY_BUILTIN_DOMAIN_RID,
                             DOMAIN_ALIAS_RID_ADMINS,
                             0, 0, 0, 0, 0, 0,
                             &pAdminSID) );

        // Initialize an EXPLICIT_ACCESS structure for an ACE.
        // The ACE allows the Administrators group full access to the directory
        ea[1].grfAccessPermissions = FILE_ALL_ACCESS;
        ea[1].grfAccessMode = SET_ACCESS;
        ea[1].grfInheritance = SUB_CONTAINERS_AND_OBJECTS_INHERIT;
        ea[1].Trustee.pMultipleTrustee = NULL;
        ea[1].Trustee.MultipleTrusteeOperation  = NO_MULTIPLE_TRUSTEE;
        ea[1].Trustee.TrusteeForm = TRUSTEE_IS_SID;
        ea[1].Trustee.TrusteeType = TRUSTEE_IS_WELL_KNOWN_GROUP;
        ea[1].Trustee.ptstrName  = (LPTSTR) pAdminSID;

        // Create a new ACL that contains the new ACEs.
        WsbAffirmNoError( SetEntriesInAcl(REMOTE_DIR_NUM_ACE, ea, NULL, &pACL));

        // Initialize a security descriptor.  
        pSD = (PSECURITY_DESCRIPTOR) WsbAlloc(SECURITY_DESCRIPTOR_MIN_LENGTH); 
        WsbAffirmPointer(pSD);
        WsbAffirmStatus(InitializeSecurityDescriptor(pSD, SECURITY_DESCRIPTOR_REVISION));
 
        // Add the ACL to the security descriptor. 
        WsbAffirmStatus(SetSecurityDescriptorDacl
                            (pSD, 
                            TRUE,     // fDaclPresent flag   
                            pACL, 
                            FALSE));   // not a default DACL 

        // Initialize a security attributes structure.
        sa.nLength = sizeof (SECURITY_ATTRIBUTES);
        sa.lpSecurityDescriptor = pSD;
        sa.bInheritHandle = FALSE;

        // Create the RSS directory with Admin Only access
        WsbAffirmHr(GetRemotePath(&DirName));

        if (! CreateDirectory(DirName, &sa)) {
            DWORD status = GetLastError();
            if ((status == ERROR_ALREADY_EXISTS) || (status == ERROR_FILE_EXISTS)) {
                // Directory already exists on remote media - ignore it
                status = NO_ERROR;
            }
            WsbAffirmNoError(status);
        }

        // Create the remote stream. Use fixed named for the media label file
        WsbAffirmHr(CreateRemoteStream(MVR_LABEL_FILENAME, MVR_MODE_WRITE, L"",L"",nil,nil,nil,nil,nil,0,nil, &pStream));
        WsbAssertPointer(pStream);

        // Write the TAPE DBLK and filemark
        WsbAssertPointer(m_pSession);
        WsbAffirmHr(m_pSession->DoTapeDblk(label, maxIdSize, identifier, &idSize, &idType));
        WsbAffirmHr(CloseStream());
        pStream = NULL;

        // Now verify the label
        CWsbBstrPtr tempLabel;
        WsbAffirmHr(ReadLabel(&tempLabel));
        WsbAffirmHr(VerifyLabel(tempLabel));

        // Now that the tape header is written, we update the cartridge info.
        if (m_pCartridge) {
            WsbAffirmHr(m_pCartridge->SetOnMediaLabel(label));
            WsbAffirmHr(m_pCartridge->SetBlockSize(m_BlockSize));

            // For files systems we ignore the TAPE DBLK identifier, and use file system info.
            NTMS_FILESYSTEM_INFO fsInfo;
            DWORD filenameLength;
            DWORD fileSystemFlags;

            WsbAffirmStatus(GetVolumeInformation( (WCHAR *)m_DeviceName, fsInfo.VolumeName, 64,
                &fsInfo.SerialNumber, &filenameLength, &fileSystemFlags, fsInfo.FileSystemType, 256));
            WsbAffirmHr(m_pCartridge->SetOnMediaIdentifier((BYTE *)&fsInfo, sizeof(NTMS_FILESYSTEM_INFO), RmsOnMediaIdentifierWIN32));
        }

    } WsbCatchAndDo(hr,
        if (pStream) {
            (void) CloseStream();
        }
    );

    // Cleanup security allocations
    if (pAdminSID) 
        FreeSid(pAdminSID);
    if (pSystemSID) 
        FreeSid(pSystemSID);
    if (pACL) 
        LocalFree(pACL);
    if (pSD) 
        WsbFree(pSD);
    
    WsbTraceOut(OLESTR("CNtFileIo::WriteLabel"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP
CNtFileIo::ReadLabel(
    IN OUT BSTR* pLabel)
/*++

Implements:

    IDataMover::ReadLabel

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtFileIo::ReadLabel"), OLESTR(""));

    CComPtr<IStream> pStream;

    try {
        WsbAssertPointer(pLabel);
        WsbAssert(m_BlockSize > 0, MVR_E_LOGIC_ERROR);

        // Read the MTF TAPE DBLK, and pull out the label.
        ULARGE_INTEGER nil = {0,0};

        // Create remote stream of copy
        WsbAffirmHr(CreateRemoteStream(MVR_LABEL_FILENAME, MVR_MODE_READ | MVR_MODE_UNFORMATTED, L"",L"",nil,nil,nil,nil,nil,0,nil, &pStream));
        WsbAssertPointer(pStream);

        // Read label
        CWsbStringPtr label;
        WsbAffirmHr(m_pSession->ReadTapeDblk(&label));

        WsbAffirmHr(CloseStream());
        pStream = NULL;

        WsbAffirmHr(label.CopyToBstr(pLabel));

    } WsbCatchAndDo(hr,
        if (pStream) {
            (void) CloseStream();
        }
    );

    WsbTraceOut(OLESTR("CNtFileIo::ReadLabel"), OLESTR("hr = <%ls>, label = <%ls>"), WsbHrAsString(hr), *pLabel);

    return hr;
}


STDMETHODIMP
CNtFileIo::VerifyLabel(
    IN BSTR label)
/*++

Implements:

    IDataMover::VerifyLabel

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtFileIo::VerifyLabel"), OLESTR("<%ls>"), label);

    GUID mediaId[2];

    try {
        WsbAssertPointer(label);
        WsbAssert(wcslen((WCHAR *)label) > 0, E_INVALIDARG);
        WsbAssertPointer(m_pCartridge);

        //
        // To verify a label we assert that the on-media Id matches the cartridge Id.
        //
        // From the media label we obtain the on-media Id.
        //
        WCHAR delim[] = OLESTR("|");
        WCHAR *token;
        int index = 0;

        token = wcstok((WCHAR *)label, delim);  // !!! This toasts the string !!!
        while( token != NULL ) {

            index++;

            switch ( index ) {
            case 1:  // Tag
            case 2:  // Version
            case 3:  // Vendor
            case 4:  // Vendor Product ID
            case 5:  // Creation Time Stamp
            case 6:  // Cartridge Label
            case 7:  // Side
                break;
            case 8:  // Media ID
                WsbGuidFromString(token, &mediaId[0]);
                break;
            case 9:  // Media Domain ID
            default: // Vendor specific of the form: L"VS:Name=Value"
                break;
            }

            token = wcstok( NULL, delim );

        }

        if (m_pCartridge) {
            //
            // Now compare on-media Id taken from the label to the cartridge's object Id.
            //
            WsbAffirmHr(m_pCartridge->GetCartridgeId(&mediaId[1]));
            WsbAffirm(mediaId[0] == mediaId[1], MVR_E_UNEXPECTED_MEDIA_ID_DETECTED);
        }

        m_ValidLabel = TRUE;

    } WsbCatchAndDo(hr,
            m_ValidLabel = FALSE;

            CWsbBstrPtr name;
            CWsbBstrPtr desc;
            if ( m_pCartridge ) {
                m_pCartridge->GetName(&name);
                m_pCartridge->GetDescription(&desc);
            }
            WsbLogEvent(MVR_MESSAGE_ON_MEDIA_ID_VERIFY_FAILED, 2*sizeof(GUID), mediaId,
                (WCHAR *) name, (WCHAR *) desc, WsbHrAsString(hr), NULL);
        );


    WsbTraceOut(OLESTR("CNtFileIo::VerifyLabel"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP
CNtFileIo::GetDeviceName(
    OUT BSTR* pName)
/*++

Implements:

    IDataMover::GetDeviceName

--*/
{
    HRESULT hr = S_OK;

    try {
        WsbAssertPointer(pName);

        WsbAffirmHr(m_DeviceName.CopyToBstr(pName));

    } WsbCatch( hr );

    return hr;
}


STDMETHODIMP
CNtFileIo::SetDeviceName(
    IN BSTR name,
    IN BSTR /*unused*/)
/*++

Implements:

    IDataMover::SetDeviceName

--*/
{
    HRESULT hr = S_OK;

    try {
        WsbAssertPointer(name);

        m_DeviceName = name;

    } WsbCatch(hr);

    return S_OK;
}


STDMETHODIMP
CNtFileIo::GetLargestFreeSpace(
    OUT LONGLONG* pFreeSpace,
    OUT LONGLONG* pCapacity,
    IN  ULONG    defaultFreeSpaceLow,
    IN  LONG     defaultFreeSpaceHigh
    )
/*++

Implements:

    IDataMover::GetLargestFreeSpace

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtFileIo::GetLargestFreeSpace"), OLESTR(""));

    UNREFERENCED_PARAMETER(defaultFreeSpaceLow);
    UNREFERENCED_PARAMETER(defaultFreeSpaceHigh);

    LONGLONG capacity = MAXLONGLONG;
    LONGLONG remaining = MAXLONGLONG;

    try {
        // Note: Fot File I/O, we currentlym always go to the file system to query 
        //  for free space and capacity and avoid internal counting like in tape.
        // If we want to use internal counting (IRmsStorageInfo interface of m_pCartridge),
        //  then we need to maintain it by calling IncrementBytesWritten when appropriate

        ULARGE_INTEGER freeSpaceForCaller;
        ULARGE_INTEGER totalCapacity;
        ULARGE_INTEGER totalFreeSpace;

        capacity = MAXLONGLONG;
        remaining = MAXLONGLONG;

        try {
            // WIN32 - get disk free space
            WsbAffirmStatus(GetDiskFreeSpaceEx( m_DeviceName, &freeSpaceForCaller, &totalCapacity, &totalFreeSpace));
            capacity = totalCapacity.QuadPart;
            remaining = freeSpaceForCaller.QuadPart;

        } WsbCatchAndDo(hr,
                hr = MapFileError(hr);
                WsbLogEvent(MVR_MESSAGE_DEVICE_ERROR, 0, NULL, WsbHrAsString(hr), NULL);
                WsbThrow(hr);
            );

    } WsbCatch(hr);

    // Fill in the return parameters
    if ( pCapacity ) {
        *pCapacity = capacity;
    }

    if ( pFreeSpace ) {
        *pFreeSpace = remaining;
    }

    WsbTraceOut(OLESTR("CNtFileIo::GetLargestFreeSpace"), OLESTR("hr = <%ls>, free=%I64u, capacity=%I64u"), WsbHrAsString(hr), remaining, capacity);

    return hr;
}

STDMETHODIMP
CNtFileIo::SetInitialOffset(
    IN ULARGE_INTEGER initialOffset
    )
/*++

Implements:

    IDataMover::SetInitialOffset

Notes:

    Set Initial stream offset (without explicitly seeking the stream to this offset)

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtFileIo::SetInitialOffset"), OLESTR(""));

    m_StreamOffset.QuadPart = initialOffset.QuadPart;

    WsbTraceOut(OLESTR("CNtFileIo::SetInitialOffset"), OLESTR("hr = <%ls> offset = %I64u"), WsbHrAsString(hr), initialOffset.QuadPart);

    return hr;
}


STDMETHODIMP
CNtFileIo::GetCartridge(
    OUT IRmsCartridge** ptr
    )
/*++

Implements:

    IDataMover::GetCartridge

--*/
{
    HRESULT hr = S_OK;

    try {

        WsbAssertPointer( ptr );

        *ptr = m_pCartridge;
        m_pCartridge->AddRef();

    } WsbCatch( hr );

    return hr;
}


STDMETHODIMP
CNtFileIo::SetCartridge(
    IN IRmsCartridge* ptr
    )
/*++

Implements:

    IDataMover::SetCartridge

--*/
{
    HRESULT hr = S_OK;

    try {
        WsbAssertPointer( ptr );

        if ( m_pCartridge )
            m_pCartridge = 0;

        m_pCartridge = ptr;

    } WsbCatch( hr );

    return hr;
}


STDMETHODIMP
CNtFileIo::Cancel(void)
/*++

Implements:

    IDataMover::Cancel

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtFileIo::Cancel"), OLESTR(""));

    try {
        (void) Revert();
        (void) CloseStream();
    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CNtFileIo::Cancel"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}



STDMETHODIMP
CNtFileIo::CreateLocalStream(
    IN BSTR name,
    IN DWORD mode,
    OUT IStream** ppStream)
/*++

Implements:

    IDataMover::CreateLocalStream

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtFileIo::CreateLocalStream"), OLESTR(""));

    try {
        WsbAffirmPointer( ppStream );
        WsbAffirm( mode & MVR_MODE_WRITE, E_UNEXPECTED ); // Only Recall or Restore supported this way.

        FILE_BASIC_INFORMATION      basicInformation;
        IO_STATUS_BLOCK             IoStatusBlock;

        m_Mode = mode;
        m_StreamName = name;
        m_isLocalStream = TRUE;
        m_StreamOffset.QuadPart = 0;
        m_StreamSize.QuadPart = 0;

        m_OriginalAttributes = GetFileAttributes(name);
        if ( 0xffffffff == m_OriginalAttributes ) { 
            WsbAssertNoError(GetLastError());
        } else if ( m_OriginalAttributes & FILE_ATTRIBUTE_READONLY ) {
            //
            // Set it to read/write 
            //
            WsbAssertStatus(SetFileAttributes(m_StreamName, m_OriginalAttributes & ~FILE_ATTRIBUTE_READONLY));
        }

        DWORD posixFlag = (m_Mode & MVR_FLAG_POSIX_SEMANTICS) ? FILE_FLAG_POSIX_SEMANTICS : 0;

        if ( m_Mode & MVR_FLAG_HSM_SEMANTICS ) {
            //
            // Recall - File must already exits!
            //

            WsbAffirmHandle(m_hFile = CreateFile(m_StreamName,
                GENERIC_WRITE,
                0,
                NULL,
                OPEN_EXISTING,
                FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_OPEN_REPARSE_POINT | posixFlag, 
                NULL));

            //
            // Mark the USN source for this handle (So content indexing knows there is no real change)
            //
            WsbAffirmHr(WsbMarkUsnSource(m_hFile, m_DeviceName));

        } else {
            //
            // Restore
            //

            WsbAffirmHandle(m_hFile = CreateFile(m_StreamName,
                GENERIC_WRITE,
                0,
                NULL,
                CREATE_ALWAYS,
                FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_OPEN_REPARSE_POINT | posixFlag, 
                NULL));
        }

        //
        // Set the time flags so that when we close the handle the
        // times are not updated on the file and the FileAttributes 
        // indicate the file is offline
        //
        WsbAffirmNtStatus(NtQueryInformationFile(m_hFile,
            &IoStatusBlock,
            (PVOID)&basicInformation,
            sizeof(basicInformation),
            FileBasicInformation));

        basicInformation.CreationTime.QuadPart = -1;
        basicInformation.LastAccessTime.QuadPart = -1;
        basicInformation.LastWriteTime.QuadPart = -1;
        basicInformation.ChangeTime.QuadPart = -1;

        WsbAffirmNtStatus(NtSetInformationFile(m_hFile,
            &IoStatusBlock,
            (PVOID)&basicInformation,
            sizeof(basicInformation),
            FileBasicInformation));

        WsbAssertHrOk(((IUnknown*) (IDataMover*) this)->QueryInterface(IID_IStream, (void **) ppStream));

    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CNtFileIo::CreateLocalStream"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}



STDMETHODIMP
CNtFileIo::CreateRemoteStream(
    IN BSTR name,
    IN DWORD mode,
    IN BSTR remoteSessionName,
    IN BSTR remoteSessionDescription,
    IN ULARGE_INTEGER remoteDataSetStart,
    IN ULARGE_INTEGER remoteFileStart,
    IN ULARGE_INTEGER remoteFileSize,
    IN ULARGE_INTEGER remoteDataStart,
    IN ULARGE_INTEGER remoteDataSize,
    IN DWORD remoteVerificationType,
    IN ULARGE_INTEGER remoteVerificationData,
    OUT IStream** ppStream)
/*++

Implements:

    IDataMover::CreateRemoteStream

--*/
{
    UNREFERENCED_PARAMETER(remoteSessionName);
    UNREFERENCED_PARAMETER(remoteSessionDescription);

    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtFileIo::CreateRemoteStream"), OLESTR(""));

    try {
        WsbAffirmPointer( ppStream );

        m_Mode = mode;
        WsbAffirmHr(GetRemotePath(&m_StreamName));

        // Use given name as file-name here, use remoteSessionName only if name is NULL
        if (name && (0 < wcslen((WCHAR *)name))) {
            WsbAffirmHr(m_StreamName.Append(name));
        } else {
            WsbAffirmHr(m_StreamName.Append(remoteSessionName));
        }

        // Add file extension
        // Note: In case of safe storage, we write to a temporary file.
        //       After a successful store, we rename the temporary file to the real file name
        if ((m_Mode & MVR_FLAG_SAFE_STORAGE) && (m_Mode & MVR_MODE_WRITE || m_Mode & MVR_MODE_APPEND)) {
            WsbAffirmHr(m_StreamName.Append(MVR_SAFE_STORAGE_FILETYPE));
        } else {
            WsbAffirmHr(m_StreamName.Append(MVR_DATASET_FILETYPE));
        }

        m_StreamOffset.QuadPart = 0;
        m_StreamSize.QuadPart = remoteDataSize.QuadPart;

        WsbTrace(OLESTR("CNtFileIo::CreateRemoteStream: Creating <%ls>\n"), (WCHAR *)m_StreamName);

        if (m_Mode & MVR_FLAG_HSM_SEMANTICS || m_Mode & MVR_MODE_READ) {
            //
            // File must already exists!
            //
            DWORD dwFlags = FILE_ATTRIBUTE_NORMAL;
            if (m_Mode & MVR_FLAG_NO_CACHING) {
                dwFlags |= FILE_FLAG_NO_BUFFERING;
            }

            WsbAffirmHandle(m_hFile = CreateFile(m_StreamName,
                GENERIC_READ,
                FILE_SHARE_READ,
                NULL,
                OPEN_EXISTING,
                dwFlags,
                NULL));

        } else if (m_Mode & MVR_MODE_RECOVER) {
            //
            // Open for R/W an already existsing file
            //
            WsbAffirmHandle(m_hFile = CreateFile(m_StreamName,
                GENERIC_READ | GENERIC_WRITE,
                FILE_SHARE_READ,
                NULL,
                OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL,  // cannot use FILE_FLAG_NO_BUFFERING here !!
                NULL));

        } else {
            //
            // Create Data Set or Media Label
            //
            WsbAffirmHandle(m_hFile = CreateFile(m_StreamName,
                GENERIC_READ | GENERIC_WRITE,
                FILE_SHARE_READ,
                NULL,
                CREATE_ALWAYS,
                FILE_ATTRIBUTE_NORMAL | FILE_FLAG_NO_BUFFERING,
                NULL));

        }

        // Create and initialize an MTF Session object
        CComPtr<IStream> pStream;
        WsbAssertHrOk(((IUnknown*) (IDataMover*) this)->QueryInterface( IID_IStream, (void **) &pStream));

        WsbAssert(NULL == m_pSession, MVR_E_LOGIC_ERROR);
        m_pSession = new CMTFSession();
        WsbAssertPointer(m_pSession);

        m_pSession->m_pStream = pStream;

        m_pSession->m_sHints.DataSetStart.QuadPart = remoteDataSetStart.QuadPart;
        m_pSession->m_sHints.FileStart.QuadPart = remoteFileStart.QuadPart;
        m_pSession->m_sHints.FileSize.QuadPart = remoteFileSize.QuadPart;
        m_pSession->m_sHints.DataStart.QuadPart = remoteDataStart.QuadPart;
        m_pSession->m_sHints.DataSize.QuadPart = remoteDataSize.QuadPart;
        m_pSession->m_sHints.VerificationType = remoteVerificationType;
        m_pSession->m_sHints.VerificationData.QuadPart = remoteVerificationData.QuadPart;

        // Set block size according to device sector size
        //  (On FS-based media, the sector size is fixed, therefore we ignore the cached value in the cartridge record)
        DWORD dummy1, dummy2, dummy3;
        WsbAffirmStatus(GetDiskFreeSpace(m_DeviceName, &dummy1, &m_BlockSize, &dummy2, &dummy3));
        WsbAssert((m_BlockSize % 512) == 0, E_UNEXPECTED);  

        WsbTrace( OLESTR("Setting Block Size to %d bytes/block.\n"), m_BlockSize);

        // Set the Block Size used for the session.
        WsbAffirmHr(m_pSession->SetBlockSize(m_BlockSize));

        // Set the Block Size used for the session.
        WsbAffirmHr(m_pSession->SetUseSoftFilemarks(TRUE));

        if (m_Mode & MVR_MODE_APPEND) {
            // Sets the current position to the end of data.
            LARGE_INTEGER zero = {0,0};
            WsbAffirmHr(pStream->Seek(zero, STREAM_SEEK_END, NULL));
        }

        *ppStream = pStream;
        pStream->AddRef();

    } WsbCatchAndDo(hr,
            (void) CloseStream();
        );

    WsbTraceOut(OLESTR("CNtFileIo::CreateRemoteStream"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}



STDMETHODIMP
CNtFileIo::CloseStream(void)
/*++

Implements:

    IDataMover::CloseStream

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtFileIo::CloseStream"), OLESTR(""));

    try {

        if (m_hFile != INVALID_HANDLE_VALUE) {
            CloseHandle(m_hFile);
            m_hFile = INVALID_HANDLE_VALUE;
        }

        if (m_isLocalStream) {
            if (m_OriginalAttributes & FILE_ATTRIBUTE_READONLY) {
                //
                // Set it back to read only
                WsbAssertStatus(SetFileAttributesW(m_StreamName, m_OriginalAttributes));
            }
        }

        if (m_pSession) {
            delete m_pSession;
            m_pSession = NULL;
        }

    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CNtFileIo::CloseStream"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP
CNtFileIo::Duplicate(
    IN IDataMover* pDestination,
    IN DWORD options,
    OUT ULARGE_INTEGER* pBytesCopied,
    OUT ULARGE_INTEGER* pBytesReclaimed)
/*++

Implements:

    IDataMover::Duplicate

Notes:

      1) The method uses an internal copy method instead of CopyFile since CopyFile makes wrong assumptions on
      whether a copy is feasible based on the file-size and target volume size (ignores compression factor for example).

      2) It is assumed that for RSS data-set files, only the unnamed data stream should be copied.
      Otherwise, the internal copy method that Duplicate calls for each file needs to be changed.

      3) The method uses the MVR_RECOVERY_FILETYPE files to mark (on the copy-media) a file that is
      in the middle of copy. In case of a crash, the next time the function runs it will identify
      such a case and delete the partial file.

--*/
{
    ULARGE_INTEGER bytesCopied = {0,0};
    ULARGE_INTEGER bytesReclaimed = {0,0};

    HANDLE hSearchHandle = INVALID_HANDLE_VALUE;
    HRESULT hr = S_OK;

    WsbTraceIn(OLESTR("CNtFileIo::Duplicate"), OLESTR(""));

    try {
        CWsbBstrPtr dirName;
        CWsbBstrPtr copyDirName;
        CWsbStringPtr nameSpace;
        CWsbStringPtr nameSpacePrefix;
        CWsbStringPtr originalFile;
        CWsbStringPtr copyFile;
        CWsbStringPtr specificFile;
        BOOL bRefresh;

        WIN32_FIND_DATA findData;
        BOOL bMoreFiles = TRUE;

        bRefresh = (options & MVR_DUPLICATE_REFRESH) ? TRUE : FALSE;

        // Check if recovery is needed on the master media before duplicating the media
        // We continue even if Recovery fails
        (void) DoRecovery ();

        // Get remote path of original and copy
        WsbAffirmHr(GetRemotePath(&dirName));
        WsbAffirmHr(pDestination->GetDeviceName(&copyDirName));
        WsbAffirmHr(copyDirName.Append(MVR_RSDATA_PATH));

        // Traverse directory (traverse only MTF files)
        nameSpacePrefix = dirName;
        WsbAffirmHr(nameSpacePrefix.Prepend(OLESTR("\\\\?\\")));
        WsbAffirmHr(nameSpacePrefix.Append(OLESTR("*")));
        nameSpace = nameSpacePrefix;
        WsbAffirmHr(nameSpace.Append(MVR_DATASET_FILETYPE));
        hSearchHandle = FindFirstFile((WCHAR *) nameSpace, &findData);

        // Copy only non-existing data-set (BAG) files
        while ((INVALID_HANDLE_VALUE != hSearchHandle) && bMoreFiles) {
            if ( (0 == (findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) &&
                 (0 != wcsncmp(findData.cFileName, MVR_LABEL_FILENAME, wcslen(MVR_LABEL_FILENAME))) ) {
                originalFile = dirName;
                WsbAffirmHr(originalFile.Append(findData.cFileName));
                copyFile = copyDirName;
                WsbAffirmHr(copyFile.Append(findData.cFileName));

                // Test for an incomplete copy from a previous session
                WsbAffirmHr(TestRecoveryIndicatorAndDeleteFile(copyFile));

                // Create a recovery indicator file for crash consistency on the copy media
                WsbAffirmHr(CreateRecoveryIndicator(copyFile));

                // Copy
                hr = InternalCopyFile(originalFile, copyFile, (! bRefresh));

                // Delete the recovery indicator file
                (void) DeleteRecoveryIndicator(copyFile);

                if (! SUCCEEDED(hr)) {
                    if ( (! bRefresh) &&
                         ((HRESULT_CODE(hr) == ERROR_ALREADY_EXISTS) || (HRESULT_CODE(hr) == ERROR_FILE_EXISTS)) ) {
                        // File already exists on remote media - ignore it
                        hr = S_OK;
                    }
                    WsbAffirmHr(hr);
                } else {
                    // Increase counter only if a file is really copied
                    bytesCopied.HighPart += findData.nFileSizeHigh;
                    bytesCopied.LowPart += findData.nFileSizeLow;
                }

            }

            bMoreFiles = FindNextFile(hSearchHandle, &findData);
        }

        if (INVALID_HANDLE_VALUE != hSearchHandle) {
            FindClose(hSearchHandle);
            hSearchHandle = INVALID_HANDLE_VALUE;
        }

        // Copy safe-storage backup files (if exist, usually they don't)
        bMoreFiles = TRUE;
        nameSpace = nameSpacePrefix;
        WsbAffirmHr(nameSpace.Append(MVR_SAFE_STORAGE_FILETYPE));
        hSearchHandle = FindFirstFile((WCHAR *) nameSpace, &findData);

        while ((INVALID_HANDLE_VALUE != hSearchHandle) && bMoreFiles) {
            if ( (0 == (findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) ) {
                originalFile = dirName;
                WsbAffirmHr(originalFile.Append(findData.cFileName));
                copyFile = copyDirName;
                WsbAffirmHr(copyFile.Append(findData.cFileName));

                WsbAffirmHr(InternalCopyFile(originalFile, copyFile, FALSE));
            }

            bMoreFiles = FindNextFile(hSearchHandle, &findData);
        }

        // Copy specific files (currently, only HSM metadata file)
        specificFile = HSM_METADATA_NAME;
        WsbAffirmHr(specificFile.Append(MVR_DATASET_FILETYPE));
        originalFile = dirName;
        WsbAffirmHr(originalFile.Append(specificFile));
        copyFile = copyDirName;
        WsbAffirmHr(copyFile.Append(specificFile));

        hr = InternalCopyFile(originalFile, copyFile, FALSE);
        if (! SUCCEEDED(hr)) {
            if (HRESULT_CODE(hr) == ERROR_FILE_NOT_FOUND) {
                // Original file may not exist
                hr = S_OK;
            }
            WsbAffirmHr(hr);
        } 

    } WsbCatch(hr);

    if (INVALID_HANDLE_VALUE != hSearchHandle) {
        FindClose(hSearchHandle);
        hSearchHandle = INVALID_HANDLE_VALUE;
    }

    // Set output params
    if ( pBytesCopied ) {
        pBytesCopied->QuadPart = bytesCopied.QuadPart;
    }
    if ( pBytesReclaimed ) {
        pBytesReclaimed->QuadPart = bytesReclaimed.QuadPart;
    }

    WsbTraceOut(OLESTR("CNtFileIo::Duplicate"), OLESTR("hr = <%ls>, bytesCopied=%I64u, bytesReclaimed=%I64u"),
        WsbHrAsString(hr), bytesCopied.QuadPart, bytesReclaimed.QuadPart);

    return hr;
}



STDMETHODIMP
CNtFileIo::FlushBuffers(void)
/*++

Implements:

    IDataMover::FlushBuffers

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtFileIo::FlushBuffers"), OLESTR(""));

    try {

        // Pad to the next physical block boundary and flush the filesystem buffer.
        // Note: The session object calls Commit which flush the data
        WsbAffirmHr(m_pSession->ExtendLastPadToNextPBA());

    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CNtFileIo::FlushBuffers"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}

STDMETHODIMP
CNtFileIo::Recover(OUT BOOL *pDeleteFile)
/*++

Implements:

    IDataMover::Recover

  Notes:

Recovery is done by:
1. Verifying existence of initial blocks
2. Skip to data sets (FILE DNLKs)
3. If a data set is incomplete - delete it and write FILEMARK+ESET+FILEMARK
4. If FILEMARK is found, all the data is there, just verify and complete the FILEMARK+ESET+FILEMARK

--*/
{
    HRESULT hr = S_OK;

    *pDeleteFile = FALSE;

    WsbTraceIn(OLESTR("CNtFileIo::Recover"), OLESTR(""));

    try {
        USHORT nDataSetNumber = 0;
        BOOL bForceEset = FALSE;

        // Check first part of the file
        hr = m_pSession->SkipOverTapeDblk();
        if (hr == S_OK) {
            hr = m_pSession->SkipOverSSETDblk(&nDataSetNumber);
        }
        if (hr == S_OK) {
            hr = m_pSession->SkipToDataSet();
        }
        if (hr == S_OK) {
            hr = m_pSession->SkipOverDataSet();
        }

        if (hr == MVR_E_NOT_FOUND) {
            // File is consistent but no remote data was written or first data written was cut
            // Therefore, indicate that file can be deleted altogether and exit
            *pDeleteFile = TRUE;
            hr = S_OK;
            WsbThrow(hr);
        } else {
            // Verify no other unexpected error
            WsbAffirmHr(hr);
        }

        // Skip over data sets until they are done or we find a problem
        while (TRUE) {
            hr = m_pSession->SkipToDataSet();
            if (hr == S_OK) {
                hr = m_pSession->SkipOverDataSet();
                if (hr != S_OK) {
                    bForceEset = TRUE;
                    break;
                }

            // No more data sets
            } else {
                // force re-marking end-of-set unless end-of-set was detected
                if (hr != MVR_S_SETMARK_DETECTED) {
                    bForceEset = TRUE;
                }

                break;
            }
        }

        // Whatever the error is, since we collected at least one legal data set (one
        //  complete migrated file), continueby terminating the file properly
        // TEMPORARY: in case of an 'inconsistent' error should we ignore, terminate, log event
        hr = S_OK;

        // Handle end of set
        if (! bForceEset) {
            // Verify that end-of-data-set is complete
            hr = m_pSession->SkipOverEndOfDataSet();
            if (hr != S_OK) {
                bForceEset = TRUE;
                hr = S_OK;
            }
        }

        if (bForceEset) {
            // End-of-set is missing or incomplete
            WsbAffirmHr(m_pSession->PrepareForEndOfDataSet());
            WsbAffirmHr(m_pSession->DoEndOfDataSet(nDataSetNumber));
            WsbAffirmStatus(SetEndOfFile(m_hFile));
        } 
        
    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CNtFileIo::Recover"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}

////////////////////////////////////////////////////////////////////////////////
//
// IStream Implementation
//


STDMETHODIMP
CNtFileIo::Read(
    OUT void *pv,
    IN ULONG cb,
    OUT ULONG *pcbRead)
/*++

Implements:

    IStream::Read

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtFileIo::Read"), OLESTR("Bytes Requested = %u, offset = %I64u, mode = 0x%08x"), cb, m_StreamOffset.QuadPart, m_Mode);

    ULONG bytesRead = 0;
    ULONG bytesToRead = 0;

    try {
        WsbAssert(pv != 0, STG_E_INVALIDPOINTER);
        WsbAssert(FALSE == m_isLocalStream, E_UNEXPECTED);

        //
        // Read data from disk
        //

        LARGE_INTEGER  loc = {0,0};

        if ( MVR_MODE_UNFORMATTED & m_Mode ) {
            //
            // Set location according to current stream offset
            //  (m_StreamOffset represents here the absolute location to read from)
            //
            loc.QuadPart = m_StreamOffset.QuadPart;

            bytesToRead = cb;
        }
        else if ( MVR_FLAG_HSM_SEMANTICS & m_Mode ) {
            //
            // Set location according to session parameters
            //  (m_StreamOffset represents here an offset into the actual stream-to-read)
            //
            loc.QuadPart = ( m_pSession->m_sHints.DataSetStart.QuadPart +
                             m_pSession->m_sHints.FileStart.QuadPart +
                             m_pSession->m_sHints.DataStart.QuadPart +
                             m_StreamOffset.QuadPart );
            bytesToRead = cb;
        }
        else {
            WsbThrow( E_UNEXPECTED );
        }

        //
        // Set Position
        //
        WsbAffirmHr(SetPosition(loc.QuadPart));

        hr = ReadBuffer((BYTE *) pv, cb, &bytesRead);

        if ( FAILED(hr) ) {
            WsbThrow(hr)
        }
        else {
            switch (hr) {
            case MVR_S_FILEMARK_DETECTED:
            case MVR_S_SETMARK_DETECTED:
                m_StreamOffset.QuadPart += (unsigned _int64) m_BlockSize;
                break;
            }
        }

        m_StreamOffset.QuadPart += bytesRead;

        if ( pcbRead ) {
            *pcbRead = bytesRead;
        }

    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CNtFileIo::Read"), OLESTR("hr = <%ls> bytes Read = %u, new offset = %I64u"), WsbHrAsString(hr), bytesRead, m_StreamOffset.QuadPart);

    return hr;
}


STDMETHODIMP
CNtFileIo::Write(
    IN void const *pv,
    IN ULONG cb,
    OUT ULONG *pcbWritten)
/*++

Implements:

    IStream::Write

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtFileIo::Write"), OLESTR("Bytes Requested = %u, offset = %I64u, mode = 0x%08x"), 
        cb, m_StreamOffset.QuadPart, m_Mode);

    ULONG bytesWritten = 0;

    try {
        WsbAssert(pv != 0, STG_E_INVALIDPOINTER);

        // Consistency Check
        // UINT64 pos = m_StreamOffset.QuadPart / m_BlockSize;;
        // WsbAffirmHr(EnsurePosition(pos));
        // UINT64 curPos;
        // WsbAffirmHr(GetPosition(&curPos));
        // WsbAssert(curPos == m_StreamOffset.QuadPart / m_BlockSize, E_UNEXPECTED);

        WsbAffirmHr(WriteBuffer((BYTE *) pv, cb, &bytesWritten));

        if (pcbWritten) {
            *pcbWritten = bytesWritten;
        }

        m_StreamOffset.QuadPart += bytesWritten;

    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CNtFileIo::Write"), OLESTR("hr = <%ls>, bytesWritten=%u"), WsbHrAsString(hr), bytesWritten);

    return hr;
}


STDMETHODIMP
CNtFileIo::Seek(
    IN LARGE_INTEGER dlibMove,
    IN DWORD dwOrigin,
    OUT ULARGE_INTEGER *plibNewPosition)
/*++

Implements:

    IStream::Seek

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtFileIo::Seek"), OLESTR("<%I64d> <%d>"), dlibMove.QuadPart, dwOrigin);

    ULARGE_INTEGER newPosition;

    try {

        newPosition.QuadPart = dlibMove.QuadPart;

        //
        // Note: Somewhere it is written that FILE_BEGIN is always and
        //       forever same as STREAM_SEEK_CUR, etc.
        //
        switch ( (STREAM_SEEK)dwOrigin ) {
        case STREAM_SEEK_SET:
            newPosition.LowPart = SetFilePointer(m_hFile, dlibMove.LowPart, (long *)&newPosition.HighPart, FILE_BEGIN);
            if (INVALID_SET_FILE_POINTER == newPosition.LowPart) {
                WsbAffirmNoError(GetLastError());
            }
            m_StreamOffset.QuadPart = dlibMove.QuadPart;
            break;

        case STREAM_SEEK_CUR:
            newPosition.LowPart = SetFilePointer(m_hFile, dlibMove.LowPart, (long *)&newPosition.HighPart, FILE_CURRENT);
            if (INVALID_SET_FILE_POINTER == newPosition.LowPart) {
                WsbAffirmNoError(GetLastError());
            }
            m_StreamOffset.QuadPart += dlibMove.QuadPart;
            break;

        case STREAM_SEEK_END:
            WsbAssert(0 == dlibMove.QuadPart, STG_E_INVALIDPARAMETER);
            newPosition.LowPart = SetFilePointer(m_hFile, 0, (long *)&newPosition.HighPart, FILE_END);
            if (INVALID_SET_FILE_POINTER == newPosition.LowPart) {
                WsbAffirmNoError(GetLastError());
            }
            m_StreamOffset = newPosition;
            break;

        default:
            WsbThrow(STG_E_INVALIDFUNCTION);
        }

        WsbAssert(newPosition.QuadPart == m_StreamOffset.QuadPart, MVR_E_LOGIC_ERROR);

        if (plibNewPosition) {
            plibNewPosition->QuadPart = newPosition.QuadPart;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CNtFileIo::Seek"), OLESTR("hr = <%ls>, newPosition=%I64u"), WsbHrAsString(hr), newPosition.QuadPart);

    return hr;
}


STDMETHODIMP
CNtFileIo::SetSize(
    IN ULARGE_INTEGER /*libNewSize*/)
/*++

Implements:

    IStream::SetSize

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtFileIo::SetSize"), OLESTR(""));

    try {
        WsbThrow(E_NOTIMPL);
    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CNtFileIo::SetSize"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP
CNtFileIo::CopyTo(
    IN IStream *pstm,
    IN ULARGE_INTEGER cb,
    OUT ULARGE_INTEGER *pcbRead,
    OUT ULARGE_INTEGER *pcbWritten)
/*++

Implements:

    IStream::CopyTo

Note:
    A lot of the code that is implemented for Tape I/O in the Read method, is 
    implemented here in CopyTo, the method that alloacte the I/O buffer.
    Otherwise, we would have to alloacte an internal buffer in Read and perform
    double copy. In File I/O we want to avoid this for better performance.

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtFileIo::CopyTo"), OLESTR("<%I64u>"), cb.QuadPart);

    ULARGE_INTEGER totalBytesRead = {0,0};
    ULARGE_INTEGER totalBytesWritten = {0,0};

    BYTE *pBuffer = NULL;
    BYTE *pRealBuffer = NULL;

    try {
        WsbAssert(pstm != 0, STG_E_INVALIDPOINTER);
        WsbAssert(m_BlockSize > 0, MVR_E_LOGIC_ERROR);

        ULONG defaultBufferSize = DefaultMinBufferSize;

        DWORD size;
        OLECHAR tmpString[256];
        if (SUCCEEDED(WsbGetRegistryValueString(NULL, RMS_REGISTRY_STRING, RMS_PARAMETER_BUFFER_SIZE, tmpString, 256, &size))) {
            // Get the value.
            LONG val = wcstol(tmpString, NULL, 10);
            if (val > 0) {
                defaultBufferSize = val;
            }
        }

        ULONG bufferSize;
        ULONG nBlocks = defaultBufferSize/m_BlockSize;
        nBlocks = (nBlocks < 2) ? 2 : nBlocks;
        bufferSize = nBlocks * m_BlockSize;

        // Allocate buffer and make sure its virtual address is aligned with block size
        pRealBuffer = (BYTE *) WsbAlloc(bufferSize+m_BlockSize);
        if (pRealBuffer) {
            if ((ULONG_PTR)pRealBuffer % m_BlockSize) {
                pBuffer = pRealBuffer - ((ULONG_PTR)pRealBuffer % m_BlockSize) + m_BlockSize;
            } else {
                pBuffer = pRealBuffer;
            }
        } else {
            pBuffer = NULL;
        }
        WsbAffirmPointer(pBuffer);
        memset(pBuffer, 0, bufferSize);

        ULONG           bytesToRead;
        ULONG           bytesRead;
        ULONG           bytesWritten;
        ULONG           bytesToSkip;
        ULONG           bytesToCut;
        ULARGE_INTEGER  bytesToCopy;

        bytesToCopy.QuadPart = cb.QuadPart;

        while ((bytesToCopy.QuadPart > 0) && (S_OK == hr)) {
            bytesToRead = 0;
            bytesRead = 0;
            bytesWritten = 0;
            bytesToSkip = 0;
            bytesToCut = 0;

            if ((m_Mode & MVR_FLAG_NO_CACHING) || 
                (MVR_VERIFICATION_TYPE_HEADER_CRC == m_pSession->m_sHints.VerificationType )) {
                // Must read additional data for alignment and/or CRC check
                ULARGE_INTEGER  loc = {0,0};
                ULONG tempMode;
                ULARGE_INTEGER offsetIntoFile;

                // Set absoulte offset to read from
                if ( MVR_VERIFICATION_TYPE_NONE == m_pSession->m_sHints.VerificationType ) {
                    // No verification - no stream header
                    loc.QuadPart = ( m_pSession->m_sHints.DataSetStart.QuadPart +
                                     m_pSession->m_sHints.FileStart.QuadPart +
                                     m_pSession->m_sHints.DataStart.QuadPart +
                                     m_StreamOffset.QuadPart );

                }  else if (MVR_VERIFICATION_TYPE_HEADER_CRC == m_pSession->m_sHints.VerificationType ) {
                    // Currently, we don't support CRC checking if you don't read from the beginning of the stream
                    WsbAssert(m_StreamOffset.QuadPart == 0, MVR_E_INVALIDARG);

                    // Position to the stream header and crc it first.
                    loc.QuadPart = (m_pSession->m_sHints.DataSetStart.QuadPart + 
                                    m_pSession->m_sHints.FileStart.QuadPart + 
                                    m_pSession->m_sHints.DataStart.QuadPart - 
                                    sizeof(MTF_STREAM_INFO));
                    bytesToSkip += sizeof(MTF_STREAM_INFO);
                } else {
                    WsbThrow( E_UNEXPECTED );
                }

                // Set absolute place to read from, how many bytes to read and 
                //  how many bytes for skipping to the actual data
                offsetIntoFile.QuadPart = m_StreamOffset.QuadPart;
                m_StreamOffset.QuadPart = loc.QuadPart - (loc.QuadPart % m_BlockSize);
                bytesToSkip += (ULONG)(loc.QuadPart % m_BlockSize);
                if (bytesToCopy.QuadPart > bufferSize) {
                    bytesToRead = bufferSize;
                } else {
                    bytesToRead = bytesToCopy.LowPart;
                    bytesToRead += bytesToSkip;
                    bytesToRead =  (bytesToRead < bufferSize) ? bytesToRead : bufferSize;
                }
                if (bytesToRead % m_BlockSize) {
                    // Expected only when reading the last chunk
                    bytesToCut = m_BlockSize - (bytesToRead % m_BlockSize);
                    bytesToRead = bytesToRead - (bytesToRead % m_BlockSize) + m_BlockSize;
                }

                // Read the aligned data in an 'unformated' Read
                tempMode = m_Mode;                
                m_Mode |= MVR_MODE_UNFORMATTED;
                hr = Read(pBuffer, bytesToRead, &bytesRead);
                m_Mode = tempMode;
                m_StreamOffset.QuadPart = offsetIntoFile.QuadPart;
                if (FAILED(hr)) {
                    WsbThrow(hr);
                }

                if (MVR_VERIFICATION_TYPE_HEADER_CRC == m_pSession->m_sHints.VerificationType ) {
                    // Peform the CRC check

                    // If for some unexpected reason not enough bytes are read, we skip the CRC check
                    if (bytesToSkip <= bytesRead) {
                        MTF_STREAM_INFO sSTREAM;

                        CMTFApi::MTF_ReadStreamHeader(&sSTREAM, &(pBuffer[bytesToSkip-sizeof(MTF_STREAM_INFO)]));

                        try {
                            // Make sure it is the correct type of header
                            WsbAffirm((0 == memcmp(sSTREAM.acStreamId, MTF_STANDARD_DATA_STREAM, 4)), MVR_E_UNEXPECTED_DATA);
    
                            // Verify the stream header checksum
                            WsbAffirm((m_pSession->m_sHints.VerificationData.QuadPart == sSTREAM.uCheckSum), MVR_E_UNEXPECTED_DATA);

                        } catch (HRESULT catchHr) {
                            hr = catchHr;

                            // Log a detailed error
                            //  Give as attached data the beginning of the buffer which usually contains the FILE DBLK + Stream Info
                            CWsbBstrPtr name;
                            CWsbBstrPtr desc;

                            if (m_pCartridge) {
                                m_pCartridge->GetName(&name);
                                m_pCartridge->GetDescription(&desc);
                            }

                            WCHAR location[32];
                            WCHAR offset[16];
                            WCHAR mark[8];
                            WCHAR found[16];

                            swprintf(found, L"0x%04x", sSTREAM.uCheckSum);
                            swprintf(location, L"%I64u", m_StreamOffset.QuadPart);
                            swprintf(offset, L"%lu", bytesToSkip - sizeof(MTF_STREAM_INFO));
                            swprintf(mark, L"0");

                            WsbLogEvent(MVR_MESSAGE_UNEXPECTED_DATA,
                                bytesToSkip, pBuffer,
                                found, (WCHAR *)name, (WCHAR *)desc,
                                location, offset, mark, NULL);

                            WsbThrow(hr);
                        }
                    }

                    // CRC check is done only once
                    m_pSession->m_sHints.VerificationType = MVR_VERIFICATION_TYPE_NONE;
                }

                // Set file offset, handle unexpected cases where bytesRead<bytesToRead
                if (bytesToCut) {
                    if ((bytesToRead - bytesRead) < bytesToCut) {
                        bytesToCut = bytesToCut - (bytesToRead - bytesRead);
                    } else {
                        bytesToCut = 0;
                    }
                }
                if (bytesRead > bytesToSkip) {
                    m_StreamOffset.QuadPart += (bytesRead - (bytesToSkip+bytesToCut));
                }

            } else {
                // May read only actual data (no alignments) - let default Read to do its job
                bytesToRead =  (bytesToCopy.QuadPart < bufferSize) ? bytesToCopy.LowPart : bufferSize;

                hr = Read(pBuffer, bytesToRead, &bytesRead);
                if (FAILED(hr)) {
                    WsbThrow(hr);
                }
            }

            // Write the data in the output stream and calculate totals
            if (bytesRead > (bytesToSkip+bytesToCut)) {
                totalBytesRead.QuadPart += (bytesRead - (bytesToSkip+bytesToCut));
    
                WsbAffirmHrOk(pstm->Write(pBuffer+bytesToSkip, bytesRead - (bytesToSkip+bytesToCut), &bytesWritten));
                totalBytesWritten.QuadPart += bytesWritten;
    
                bytesToCopy.QuadPart -= (bytesRead - (bytesToSkip+bytesToCut));
            }
        }

        if (pcbRead) {
            pcbRead->QuadPart = totalBytesRead.QuadPart;
        }

        if (pcbWritten) {
            pcbWritten->QuadPart = totalBytesWritten.QuadPart;
        }

    } WsbCatch(hr);

    if (pRealBuffer) {
        WsbFree(pRealBuffer);
        pRealBuffer = NULL;
        pBuffer = NULL;
    }


    WsbTraceOut(OLESTR("CNtFileIo::CopyTo"), OLESTR("hr = <%ls>, bytesRead=%I64u, bytesWritten=%I64u"),
        WsbHrAsString(hr), totalBytesRead.QuadPart, totalBytesWritten.QuadPart);

    return hr;
}

STDMETHODIMP
CNtFileIo::Commit(
    IN DWORD grfCommitFlags)
/*++

Implements:

    IStream::Commit

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtFileIo::Commit"), OLESTR(""));

    try {
        if (STGC_DEFAULT == grfCommitFlags)  {
            WsbAssertStatus(FlushFileBuffers(m_hFile));
        }
        else  {
            WsbThrow(E_NOTIMPL);
        }

    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CNtFileIo::Commit"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP
CNtFileIo::Revert(void)
/*++

Implements:

    IStream::Revert

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtFileIo::Revert"), OLESTR(""));

    try {

        // TEMPORARY: Setting the mode to 0 currently doesn't prevent any write
        //  which is ongoing. We need to re-visit this issue
        m_Mode = 0;

    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CNtFileIo::Revert"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP
CNtFileIo::LockRegion(
    IN ULARGE_INTEGER /*libOffset*/,
    IN ULARGE_INTEGER /*cb*/,
    IN DWORD /*dwLockType*/)
/*++

Implements:

    IStream::LockRegion

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtFileIo::LockRegion"), OLESTR(""));

    try {
        WsbThrow(E_NOTIMPL);
    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CNtFileIo::LockRegion"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP
CNtFileIo::UnlockRegion(
    IN ULARGE_INTEGER /*libOffset*/,
    IN ULARGE_INTEGER /*cb*/,
    IN DWORD /*dwLockType*/)
/*++

Implements:

    IStream::UnlockRegion

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtFileIo::UnlockRegion"), OLESTR(""));

    try {
        WsbThrow(E_NOTIMPL);
    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CNtFileIo::UnlockRegion"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP
CNtFileIo::Stat(
    OUT STATSTG * /*pstatstg*/,
    IN DWORD /*grfStatFlag*/)
/*++

Implements:

    IStream::Stat

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtFileIo::Stat"), OLESTR(""));

    try {
        WsbThrow(E_NOTIMPL);
    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CNtFileIo::Stat"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP
CNtFileIo::Clone(
    OUT IStream ** /*ppstm*/)
/*++

Implements:

    IStream::Clone

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtFileIo::Clone"), OLESTR(""));

    try {
        WsbThrow(E_NOTIMPL);
    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CNtFileIo::Clone"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


////////////////////////////////////////////////////////////////////////////////
//
// Local Methods
//


HRESULT
CNtFileIo::WriteBuffer(
    IN BYTE *pBuffer,
    IN ULONG nBytesToWrite,
    OUT ULONG *pBytesWritten)
/*++

Routine Description:

    Used to write all MTF data.  Guarantees full blocks are written.

Arguments:

    pBuffer       -  Data buffer.
    nBytesToWrite -  number of bytes to write in buffer.
    pBytesWritten -  Bytes written.

Return Value:

    S_OK        -  Success.

--*/
{
    HRESULT hr = S_OK;

    try {
        if (!m_isLocalStream) {
            // Must have a valid label!
            WsbAffirm(TRUE == m_ValidLabel, E_ABORT);

            // Making sure that we are writting only full blocks
            WsbAssert(!(nBytesToWrite % m_BlockSize), MVR_E_LOGIC_ERROR);
        }

        try {

            // ** WIN32 Tape API Call - write the data
            WsbAffirmStatus(WriteFile(m_hFile, pBuffer, nBytesToWrite, pBytesWritten, 0));

        } WsbCatchAndDo(hr,
                hr = MapFileError(hr);
                WsbLogEvent(MVR_MESSAGE_DEVICE_ERROR, 0, NULL, WsbHrAsString(hr), NULL);
            );

        if (!m_isLocalStream) {
            // Making sure that we have written only full blocks
            WsbAssert(!(*pBytesWritten % m_BlockSize), E_UNEXPECTED);
        }

    } WsbCatch(hr);

    return hr;
}


HRESULT
CNtFileIo::ReadBuffer (
    IN BYTE *pBuffer,
    IN ULONG nBytesToRead,
    OUT ULONG *pBytesRead)
/*++

Routine Description:

    Used to read all MTF data.  Guarantees full blocks are read.

Arguments:

    pBuffer     -  Data buffer.
    nBytesToRead -  number of bytes to read into buffer.
    pBytesRead  -  Bytes read.

Return Value:

    S_OK        -  Success.

--*/
{
    HRESULT hr = S_OK;

    try {

        // For FileSystem I/O restrictions on reading only full blocks depends on how 
        // the file is opened. Therefore, we don't enforce it here.

        try {

            // ** WIN32 Tape API Call - read the data
            WsbAffirmStatus(ReadFile(m_hFile, pBuffer, nBytesToRead, pBytesRead, 0));

        } WsbCatchAndDo(hr,
                hr = MapFileError(hr);

                if ( FAILED(hr) ) {
                    WsbLogEvent(MVR_MESSAGE_DEVICE_ERROR, 0, NULL, WsbHrAsString(hr), NULL);
                    WsbThrow(hr);
                }

            );

    } WsbCatch(hr);

    return hr;
}


HRESULT
CNtFileIo::GetPosition(
    OUT UINT64 *pPosition)
/*++

Routine Description:

    Returns the current physical block address relative the current partition.

Arguments:

    pPostion    -  Receives the current physical block address.

Return Value:

    S_OK        -  Success.

--*/
{
    HRESULT     hr = S_OK;
    WsbTraceIn(OLESTR("CNtFileIo::GetPosition"), OLESTR(""));

    try {

        WsbThrow(E_NOTIMPL);

    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CNtFileIo::GetPosition"), OLESTR("hr = <%ls>, pos=%I64u"), WsbHrAsString(hr), *pPosition);

    return hr;
}


HRESULT
CNtFileIo::SetPosition(
    IN UINT64 position)
/*++

Routine Description:

    Mover to the specified physical block address relative the current partition.

Arguments:

    postion     -  The physical block address to position to.

Return Value:

    S_OK        -  Success.

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtFileIo::SetPosition"), OLESTR("<%I64u>"), position);

    ULARGE_INTEGER newPosition;

    try {

        newPosition.QuadPart = position;

        newPosition.LowPart = SetFilePointer(m_hFile, newPosition.LowPart, (long *)&newPosition.HighPart, FILE_BEGIN);
        if (INVALID_SET_FILE_POINTER == newPosition.LowPart) {
            WsbAffirmNoError(GetLastError());
        }

    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CNtFileIo::SetPosition"), OLESTR("hr = <%ls>, pos=%I64u"), WsbHrAsString(hr), newPosition.QuadPart);

    return hr;
}


HRESULT
CNtFileIo::EnsurePosition(
    IN UINT64 position)
/*++

Routine Description:

    Checks that the tape is positioned at the specified current physical block
    address relative to the current partition.  If it is not an attempt is made 
    to recover to the specified position.

Arguments:

    postion     -  The physical block address to verify.

Return Value:

    S_OK        -  Success.

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtFileIo::EnsurePosition"), OLESTR("<%I64u>"), position);

    try {

        WsbThrow(E_NOTIMPL);

    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CNtFileIo::EnsurePosition"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


HRESULT
CNtFileIo::GetRemotePath(
    OUT BSTR *pDestinationString)
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtFileIo::GetRemotePath"), OLESTR(""));

    try {
        CWsbBstrPtr tmpString;

        tmpString = m_DeviceName;
        WsbAffirmHr(tmpString.Append(MVR_RSDATA_PATH));

        WsbTrace(OLESTR("RemotePath is <%ls>\n"), (WCHAR *) tmpString);

        // Hand over the string
        WsbAffirmHr(tmpString.CopyToBstr(pDestinationString));

    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CNtFileIo::GetRemotePath"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}

HRESULT
CNtFileIo::DoRecovery(void)
{
    HANDLE hSearchHandle = INVALID_HANDLE_VALUE;
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtFileIo::DoRecovery"), OLESTR(""));

    try {
        CWsbBstrPtr dirName;
        CWsbStringPtr nameSpace;
        CWsbStringPtr recoveredFile;

        WIN32_FIND_DATA findData;
        BOOL bMoreFiles = TRUE;

        // Traverse remote directory for Recovery Indicator files
        WsbAffirmHr(GetRemotePath(&dirName));
        nameSpace = dirName;
        WsbAffirmHr(nameSpace.Append(OLESTR("*")));
        WsbAffirmHr(nameSpace.Append(MVR_RECOVERY_FILETYPE));
        nameSpace.Prepend(OLESTR("\\\\?\\"));
        hSearchHandle = FindFirstFile((WCHAR *) nameSpace, &findData);

        while ((INVALID_HANDLE_VALUE != hSearchHandle) && bMoreFiles) {
            CComPtr<IDataMover> pMover;
            CComPtr<IStream> pStream;
            CWsbBstrPtr recoveryName;
            ULARGE_INTEGER nil = {0,0};
            int nLen, nExtLen;
            BOOL bDeleteFile = FALSE;

            CWsbBstrPtr name;
            CWsbBstrPtr desc;

            // Prepare file name to recover
            nLen = wcslen(findData.cFileName);
            nExtLen = wcslen(MVR_RECOVERY_FILETYPE);
            WsbAffirmHr(recoveryName.TakeFrom(NULL, nLen - nExtLen + 1));
            wcsncpy(recoveryName, findData.cFileName, nLen-nExtLen);
            recoveryName[nLen-nExtLen] = NULL;

            // Recover - a failure to recover in file doesn't stop from trying to recover others
            try {
                if ( m_pCartridge ) {
                    m_pCartridge->GetName(&name);
                    m_pCartridge->GetDescription(&desc);
                }
                WsbLogEvent(MVR_MESSAGE_INCOMPLETE_DATA_SET_DETECTED, 0, NULL,
                    (WCHAR *)recoveryName, (WCHAR *) name, (WCHAR *) desc, NULL);

                // Create and initializa a data mover
                WsbAssertHr(CoCreateInstance(CLSID_CNtFileIo, 0, CLSCTX_SERVER, IID_IDataMover, (void **)&pMover));

                WsbAffirmHr(pMover->SetDeviceName(m_DeviceName));
                WsbAffirmHr(pMover->SetCartridge(m_pCartridge));

                // Create the stream for Recovery 
                WsbAffirmHr(pMover->CreateRemoteStream(recoveryName, MVR_MODE_RECOVER | MVR_MODE_UNFORMATTED, L"",L"",nil,nil,nil,nil,nil,0,nil, &pStream));

                // Perform the actual recovery over the file
                WsbAffirmHr(pMover->Recover(&bDeleteFile));
                (void) pMover->CloseStream();
                pStream = NULL;
                if (bDeleteFile) {
                    // Delete the remote file itself
                    recoveredFile = dirName;
                    WsbAffirmHr(recoveredFile.Append(recoveryName));
                    WsbAffirmHr(recoveredFile.Append(MVR_DATASET_FILETYPE));
                    WsbTrace(OLESTR("CNtFileIo::DoRecovery: Nothing to recover in <%ls> - Deleting file!\n"), (WCHAR *)recoveredFile);
                    WsbAffirmStatus(DeleteFile(recoveredFile));
                }

                WsbLogEvent(MVR_MESSAGE_DATA_SET_RECOVERED, 0, NULL, NULL);

            } WsbCatchAndDo (hr,
                if (pStream) {    
                    (void) pMover->CloseStream();
                    pStream = NULL;
                }
                WsbLogEvent(MVR_MESSAGE_DATA_SET_NOT_RECOVERABLE, 0, NULL, WsbHrAsString(hr), NULL);
                hr = S_OK;
            );
    
            // Create (for deleting) full name of indicator file
            recoveredFile = dirName;
            WsbAffirmHr(recoveredFile.Append(findData.cFileName));

            // Get next file
            bMoreFiles = FindNextFile(hSearchHandle, &findData);

            // Delete indicator file (independent of the recovery result)
            WsbAffirmStatus(DeleteFile(recoveredFile));
        }

    } WsbCatch(hr);

    if (INVALID_HANDLE_VALUE != hSearchHandle) {
        FindClose(hSearchHandle);
    }

    WsbTraceOut(OLESTR("CNtFileIo::DoRecovery"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}

HRESULT
CNtFileIo::CreateRecoveryIndicator(IN WCHAR *pFileName)
/*++

Implements:

    CNtFileIo::CreateRecoveryIndicator

Notes:

    The method assumes that the input file name ends with MVR_DATASET_FILETYPE !!
    Otherwise, it fails with E_UNEXPECTED

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtFileIo::CreateRecoveryIndicator"), OLESTR(""));

    try {
        CWsbStringPtr recoveryName;
        int nLen, nExtLen;
        HANDLE  hFile;

        // Generate file name 
        nLen = wcslen(pFileName);
        nExtLen = wcslen(MVR_DATASET_FILETYPE);
        WsbAssert(nLen > nExtLen, E_UNEXPECTED);
        WsbAssert(0 == wcscmp(&(pFileName[nLen-nExtLen]), MVR_DATASET_FILETYPE), E_UNEXPECTED);

        WsbAffirmHr(recoveryName.TakeFrom(NULL, nLen - nExtLen + wcslen(MVR_RECOVERY_FILETYPE) + 1));
        wcsncpy(recoveryName, pFileName, nLen-nExtLen);
        wcscpy(&(recoveryName[nLen-nExtLen]), MVR_RECOVERY_FILETYPE);

        //Create and immediately close the file
        WsbAffirmHandle(hFile = CreateFile(recoveryName,
            GENERIC_READ,   
            FILE_SHARE_READ,
            NULL,
            CREATE_ALWAYS,
            FILE_ATTRIBUTE_HIDDEN,
            NULL));

        CloseHandle(hFile);

    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CNtFileIo::CreateRecoveryIndicator"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}

HRESULT
CNtFileIo::DeleteRecoveryIndicator(IN WCHAR *pFileName)
/*++

Implements:

    CNtFileIo::DeleteRecoveryIndicator

Notes:

    The method assumes that the input file name ends with MVR_DATASET_FILETYPE !!
    Otherwise, it fails with E_UNEXPECTED

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtFileIo::DeleteRecoveryIndicator"), OLESTR(""));

    try {
        CWsbStringPtr recoveryName;
        int nLen, nExtLen;

        // Generate file name 
        nLen = wcslen(pFileName);
        nExtLen = wcslen(MVR_DATASET_FILETYPE);
        WsbAssert(nLen > nExtLen, E_UNEXPECTED);
        WsbAssert(0 == wcscmp(&(pFileName[nLen-nExtLen]), MVR_DATASET_FILETYPE), E_UNEXPECTED);

        WsbAffirmHr(recoveryName.TakeFrom(NULL, nLen - nExtLen + wcslen(MVR_RECOVERY_FILETYPE) + 1));
        wcsncpy(recoveryName, pFileName, nLen-nExtLen);
        wcscpy(&(recoveryName[nLen-nExtLen]), MVR_RECOVERY_FILETYPE);

        //Delete the indicator file
        WsbAffirmStatus(DeleteFile(recoveryName));

    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CNtFileIo::DeleteRecoveryIndicator"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}

HRESULT
CNtFileIo::TestRecoveryIndicatorAndDeleteFile(IN WCHAR *pFileName)
/*++

Implements:

    CNtFileIo::TestRecoveryIndicatorAndDeleteFile

Notes:

    The method assumes that the input file name ends with MVR_DATASET_FILETYPE !!
    Otherwise, it fails with E_UNEXPECTED

    The method:
        1) Test if the recovery indicator for the given file exists
        2) If so, it deletes the file
        3) Then, it deleted the recovery indicator

Returns:

    S_OK - If found a recovery indicator and deleted successfully
    S_FALSE - If didn't find a recovery indicator

--*/
{
    HRESULT hr = S_FALSE;
    WsbTraceIn(OLESTR("CNtFileIo::TestRecoveryIndicatorAndDeleteFile"), OLESTR(""));

    try {
        CWsbStringPtr recoveryName;
        int nLen, nExtLen;

        // Generate recovery-indicator file name 
        nLen = wcslen(pFileName);
        nExtLen = wcslen(MVR_DATASET_FILETYPE);
        WsbAssert(nLen > nExtLen, E_UNEXPECTED);
        WsbAssert(0 == wcscmp(&(pFileName[nLen-nExtLen]), MVR_DATASET_FILETYPE), E_UNEXPECTED);

        WsbAffirmHr(recoveryName.TakeFrom(NULL, nLen - nExtLen + wcslen(MVR_RECOVERY_FILETYPE) + 1));
        wcsncpy(recoveryName, pFileName, nLen-nExtLen);
        wcscpy(&(recoveryName[nLen-nExtLen]), MVR_RECOVERY_FILETYPE);

        // Test recovery indicator file existance
        HANDLE hSearchHandle = INVALID_HANDLE_VALUE;
        WIN32_FIND_DATA findData;
        hSearchHandle = FindFirstFile(recoveryName, &findData);

        if (INVALID_HANDLE_VALUE != hSearchHandle) {
            FindClose(hSearchHandle);

            hr = S_OK;

            WsbTrace(OLESTR("CNtFileIo::TestRecoveryIndicator... : Found recovery indicator. Therefore, deleting <%ls>\n"),
                        pFileName);

            //Delete the target file itself
            WsbAffirmStatus(DeleteFile(pFileName));

            //Delete the indicator file
            WsbAffirmStatus(DeleteFile(recoveryName));
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CNtFileIo::TestRecoveryIndicatorAndDeleteFile"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


HRESULT
CNtFileIo::DeleteAllData(void)
{
    HRESULT hr = S_OK;
    HANDLE hSearchHandle = INVALID_HANDLE_VALUE;
    WsbTraceIn(OLESTR("CNtFileIo::DeleteAllData"), OLESTR(""));

    try {
        CWsbStringPtr nameSpace;
        CWsbStringPtr pathname;

        WIN32_FIND_DATAW obFindData;
        BOOL bMoreFiles;

        CWsbBstrPtr remotePath;
        WsbAffirmHr(GetRemotePath(&remotePath));
        nameSpace = remotePath;
        nameSpace.Append(OLESTR("*.*"));
        nameSpace.Prepend(OLESTR("\\\\?\\"));

        hSearchHandle = FindFirstFileEx((WCHAR *) nameSpace, FindExInfoStandard, &obFindData, FindExSearchNameMatch, 0, 0);

        for (bMoreFiles = TRUE;
             hSearchHandle != INVALID_HANDLE_VALUE && bMoreFiles; 
             bMoreFiles = FindNextFileW(hSearchHandle, &obFindData)) {

            if ((obFindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0) {

                // use the remotePath to get the pathname, then append the filename
                pathname = remotePath;
                pathname.Prepend(OLESTR("\\\\?\\"));
                pathname.Append(obFindData.cFileName);

                WsbAffirmStatus(DeleteFile((WCHAR *)pathname));
            }
        }

    } WsbCatch(hr);

    // close search handle after processing all the files
    if (INVALID_HANDLE_VALUE != hSearchHandle) {
        FindClose(hSearchHandle);
        hSearchHandle = INVALID_HANDLE_VALUE;
    }

    WsbTraceOut(OLESTR("CNtFileIo::DeleteAllData"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


HRESULT
CNtFileIo::FormatDrive(
    IN BSTR label)
/*++

Routine Description:

    Formats a unit of media.

Arguments:

    label - The formatted label returned from FormatLabel().

Return Value:

    S_OK                        - Success.
    E_ABORT                     - Operation aborted.

--*/
{
    HRESULT hr = S_OK;

    WsbTraceIn(OLESTR("CNtFileIo::FormatDrive"), OLESTR("<%ls>"), (WCHAR *)label);

    PROCESS_INFORMATION exeInfo;
    STARTUPINFO startupInfo;
    memset(&startupInfo, 0, sizeof(startupInfo));

    startupInfo.cb          = sizeof( startupInfo );
    startupInfo.wShowWindow = SW_HIDE;
    startupInfo.dwFlags     = STARTF_USESHOWWINDOW;

    try {

        //
        // Get volumeLabel for the FS from the label parameter
        //

        CWsbBstrPtr volumeLabel = MVR_UNDEFINED_STRING;

        CWsbBstrPtr tempLabel = label;
        WCHAR delim[]   = OLESTR("|");
        WCHAR *token;
        int   index=0;

        token = wcstok( (WCHAR *)tempLabel, delim );
        while( token != NULL ) {
            index++;
            switch ( index ) {
            case 1: // Tag
            case 2: // Version
            case 3: // Vendor
            case 4: // Vendor Product ID
            case 5: // Creation Time Stamp
            case 6: // Cartridge Label
            case 7: // Side
            case 8: // Media ID
            case 9: // Media Domain ID
            default: // Vendor specific of the form L"VS:Name=Value"
                {
                    WCHAR *name = NULL;
                    int nameLen = 0;

                    // DisplayName
                    name = L"VS:DisplayName=";
                    nameLen = wcslen(name);
                    if( 0 == wcsncmp(token, name, nameLen) ) {
                        volumeLabel = &token[nameLen];
                    }
                }
                break;
            }
            token = wcstok( NULL, delim );
        }


        // Build the format command with options:
        // "Format d: /fs:ntfs /force /q /x /v:ROOT_D  > Null:"

        OLECHAR drive[256];
        (void) wcsncpy((WCHAR *)drive, (WCHAR *)m_DeviceName, 2);
        drive[2] = '\0';  // TODO: Fix for no drive letter support

        // NOTE: It's possible that the format command isn't where we
        //       think it is.  The following registry entry allows
        //       an override.

        CWsbBstrPtr formatCmd = RMS_DEFAULT_FORMAT_COMMAND;

        DWORD size;
        OLECHAR tmpString[256];
        if (SUCCEEDED(WsbGetRegistryValueString(NULL, RMS_REGISTRY_STRING, RMS_PARAMETER_FORMAT_COMMAND, tmpString, 256, &size))) {
            // Get the value.
            formatCmd = tmpString;
        }

        WsbTrace(OLESTR("Using command: <%ls>.\n"), (WCHAR *)formatCmd);

        WsbAffirmHr(formatCmd.Append(L" "));
        WsbAffirmHr(formatCmd.Append(drive));

        CWsbBstrPtr commandLine = formatCmd;

        CWsbBstrPtr formatOpts = RMS_DEFAULT_FORMAT_OPTIONS;

        if (SUCCEEDED(WsbGetRegistryValueString(NULL, RMS_REGISTRY_STRING, RMS_PARAMETER_FORMAT_OPTIONS, tmpString, 256, &size))) {
            // Get the value.
            formatOpts = tmpString;
        }

        WsbTrace(OLESTR("Using options: <%ls>.\n"), (WCHAR *)formatOpts);
        
        DWORD formatWaitTime = RMS_DEFAULT_FORMAT_WAIT_TIME;

        if (SUCCEEDED(WsbGetRegistryValueString(NULL, RMS_REGISTRY_STRING, RMS_PARAMETER_FORMAT_WAIT_TIME, tmpString, 256, &size))) {
            // Get the value.
            formatWaitTime = wcstol(tmpString, NULL, 10);
        }

        WsbTrace(OLESTR("Using wait time: %d.\n"), formatWaitTime);
        
        int retry = 0;

        do {

            try {

                WsbAffirm(0 == wcslen((WCHAR *)formatOpts), E_UNEXPECTED);

                WsbAffirmHr(commandLine.Append(L" "));
                WsbAffirmHr(commandLine.Append(formatOpts));

                WsbAffirmHr(commandLine.Append(L" /v:"));
                WsbAffirmHr(commandLine.Append(volumeLabel));
                WsbAffirmHr(commandLine.Append(L" > Null:"));

                WsbTrace(OLESTR("Using command: <%ls> to format media.\n"), (WCHAR *)commandLine);
                WsbAffirmStatus(CreateProcess(0, (WCHAR *)commandLine, 0, 0, FALSE, 0, 0, 0, &startupInfo, &exeInfo));
                WsbAffirmStatus(WAIT_FAILED != WaitForSingleObject(exeInfo.hProcess, 20*60*1000));
                break;

            } WsbCatchAndDo(hr,

                retry++;
                commandLine = formatCmd;

                if (retry == 1) {
                    formatOpts = RMS_DEFAULT_FORMAT_OPTIONS_ALT1;

                    if (SUCCEEDED(WsbGetRegistryValueString(NULL, RMS_REGISTRY_STRING, RMS_PARAMETER_FORMAT_OPTIONS_ALT1, tmpString, 256, &size))) {
                        // Get the value.
                        formatOpts = tmpString;
                    }
                }
                else if (retry == 2) {
                    formatOpts = RMS_DEFAULT_FORMAT_OPTIONS_ALT2;

                    if (SUCCEEDED(WsbGetRegistryValueString(NULL, RMS_REGISTRY_STRING, RMS_PARAMETER_FORMAT_OPTIONS_ALT2, tmpString, 256, &size))) {
                        // Get the value.
                        formatOpts = tmpString;
                    }
                }
                else {
                    WsbThrow(hr);
                }

                WsbTrace(OLESTR("Retrying with otions: <%ls>.\n"), (WCHAR *)formatOpts);

            );

        } while (retry < 3);


    } WsbCatch(hr);

    if (FAILED(hr)) {
        hr = E_ABORT;
    }

    WsbTraceOut(OLESTR("CNtFileIo::FormatDrive"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


HRESULT
CNtFileIo::MapFileError(
    IN HRESULT hrToMap)
/*++

Routine Description:

    Maps a WIN32 file error, specified as an HRESULT, to a MVR error.

Arguments:

    hrToMap     -  WIN32 file error to map.

Return Value:

    S_OK                            - Success.
    MVR_E_BEGINNING_OF_MEDIA        - The beginning of the tape or a partition was encountered.
    MVR_E_BUS_RESET                 - The I/O bus was reset.
    MVR_E_END_OF_MEDIA              - The physical end of the tape has been reached.
    MVR_S_FILEMARK_DETECTED         - A tape access reached a filemark.
    MVR_S_SETMARK_DETECTED          - A tape access reached the end of a set of files.
    MVR_S_NO_DATA_DETECTED          - No more data is on the tape.
    MVR_E_PARTITION_FAILURE         - Tape could not be partitioned.
    MVR_E_INVALID_BLOCK_LENGTH      - When accessing a new tape of a multivolume partition, the current blocksize is incorrect.
    MVR_E_DEVICE_NOT_PARTITIONED    - Tape partition information could not be found when loading a tape.
    MVR_E_MEDIA_CHANGED             - The media in the drive may have changed.
    MVR_E_NO_MEDIA_IN_DRIVE         - No media in drive.
    MVR_E_UNABLE_TO_LOCK_MEDIA      - Unable to lock the media eject mechanism.
    MVR_E_UNABLE_TO_UNLOAD_MEDIA    - Unable to unload the media.
    MVR_E_WRITE_PROTECT             - The media is write protected.
    MVR_E_CRC                       - Data error (cyclic redundancy check).
    MVR_E_SHARING_VIOLATION         - The process cannot access the file because it is being used by another process.
    MVR_E_ERROR_IO_DEVICE           - The request could not be performed because of an I/O device error.                          - Unknown error.
    MVE_E_ERROR_DEVICE_NOT_CONNECTED - The device is not connected.
    MVR_E_DISK_FULL                 - There is insufficient disk space to complete the operation.
    E_ABORT                         - Unknown error, abort.

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtFileIo::MapFileError"), OLESTR("<%ls>"), WsbHrAsString(hrToMap));

    try {

        // The valid label flag is knocked down when the media may have changed
        // or device parameters (i.e. block size) may have been reset.
        switch ( hrToMap ) {
        case S_OK:
            break;
        case HRESULT_FROM_WIN32( ERROR_BEGINNING_OF_MEDIA ):
            hr = MVR_E_BEGINNING_OF_MEDIA;
            break;
        case HRESULT_FROM_WIN32( ERROR_BUS_RESET ):
            hr = MVR_E_BUS_RESET;
            m_ValidLabel = FALSE;
            WsbLogEvent(MVR_MESSAGE_MEDIA_NOT_VALID, 0, NULL, WsbHrAsString(hr), NULL);
            break;
        case HRESULT_FROM_WIN32( ERROR_END_OF_MEDIA ):
            hr = MVR_E_END_OF_MEDIA;
            break;
        case HRESULT_FROM_WIN32( ERROR_FILEMARK_DETECTED ):     // Maps to Success
            hr = MVR_S_FILEMARK_DETECTED;
            break;
        case HRESULT_FROM_WIN32( ERROR_SETMARK_DETECTED ):      // Maps to Success
            hr = MVR_S_SETMARK_DETECTED;
            break;
        case HRESULT_FROM_WIN32( ERROR_NO_DATA_DETECTED ):      // Maps to Success
            // EOD
            // This happens on SpaceFilemarks() past end of data.
            hr = MVR_S_NO_DATA_DETECTED;
            break;
        case HRESULT_FROM_WIN32( ERROR_PARTITION_FAILURE ):
            hr = MVR_E_PARTITION_FAILURE;
            break;
        case HRESULT_FROM_WIN32( ERROR_INVALID_BLOCK_LENGTH ):
            hr = MVR_E_INVALID_BLOCK_LENGTH;
            break;
        case HRESULT_FROM_WIN32( ERROR_DEVICE_NOT_PARTITIONED ):
            hr = MVR_E_DEVICE_NOT_PARTITIONED;
            break;
        case HRESULT_FROM_WIN32( ERROR_MEDIA_CHANGED ):
            hr = MVR_E_MEDIA_CHANGED;
            m_ValidLabel = FALSE;
            WsbLogEvent(MVR_MESSAGE_MEDIA_NOT_VALID, 0, NULL, WsbHrAsString(hr), NULL);
            break;
        case HRESULT_FROM_WIN32( ERROR_NO_MEDIA_IN_DRIVE ):
            hr = MVR_E_NO_MEDIA_IN_DRIVE;
            m_ValidLabel = FALSE;
            WsbLogEvent(MVR_MESSAGE_MEDIA_NOT_VALID, 0, NULL, WsbHrAsString(hr), NULL);
            break;
        case HRESULT_FROM_WIN32( ERROR_UNABLE_TO_LOCK_MEDIA ):
            hr = MVR_E_UNABLE_TO_LOCK_MEDIA;
            break;
        case HRESULT_FROM_WIN32( ERROR_UNABLE_TO_UNLOAD_MEDIA ):
            hr = MVR_E_UNABLE_TO_UNLOAD_MEDIA;
            break;
        case HRESULT_FROM_WIN32( ERROR_WRITE_PROTECT ):
            hr = MVR_E_WRITE_PROTECT;
            break;
        case HRESULT_FROM_WIN32( ERROR_CRC ): 
            // This is may indicate that the drive needs cleaning.
            hr = MVR_E_CRC;
            break;
        case HRESULT_FROM_WIN32( ERROR_SHARING_VIOLATION ):
            // This happens when the CreateFile fails because the device is in use by some other app.
            hr = MVR_E_SHARING_VIOLATION;
            break;
        case HRESULT_FROM_WIN32( ERROR_IO_DEVICE ):
            // This happens when the device is turned off during I/O, for example.
            hr = MVR_E_ERROR_IO_DEVICE;
            break;
        case HRESULT_FROM_WIN32( ERROR_DEVICE_NOT_CONNECTED ):
            // This happens when the device is turned off.
            hr = MVR_E_ERROR_DEVICE_NOT_CONNECTED;
            break;
        case HRESULT_FROM_WIN32( ERROR_SEM_TIMEOUT ):
            // This happens when the SCSI command does not return within the timeout period.  A system error is logged for the SCSI controler (adapter).
            hr = MVR_E_ERROR_DEVICE_NOT_CONNECTED;
            break;
        case HRESULT_FROM_WIN32( ERROR_DISK_FULL ):
            // There is not enough space on the disk.
            hr = MVR_E_DISK_FULL;
            break;
        case HRESULT_FROM_WIN32( ERROR_UNRECOGNIZED_VOLUME ):
            // This happens when the volume is not formatted to any file system
            hr = MVR_E_UNRECOGNIZED_VOLUME;
            break;
        case HRESULT_FROM_WIN32( ERROR_INVALID_HANDLE ):
            // This happens after a Cancel() operation.
            hr = E_ABORT;
            break;
        default:
            WsbThrow(hrToMap);
        }

    } WsbCatchAndDo(hr,
            WsbLogEvent(MVR_MESSAGE_UNKNOWN_DEVICE_ERROR, 0, NULL, WsbHrAsString(hr), NULL);
            hr = E_ABORT;
        );


    WsbTraceOut(OLESTR("CNtFileIo::MapFileError"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}

HRESULT
CNtFileIo::InternalCopyFile(
    IN WCHAR *pOriginalFileName, 
    IN WCHAR *pCopyFileName, 
    IN BOOL bFailIfExists)
/*++

Implements:

    CNtFileIo::InternalCopyFile

Notes:

    1) The method copies only the unnamed data stream using Read/Write.
       Currently this is sufficient for RSS .bkf files on a media, however, if we ever use
       other-than-default file characteristics like named streams, per-file security attributes,
       special file attributes, etc. - then we should consider using BackupRead & BackupWrite
       for implementing the internal-copy

    2) If caller ask for bFailIfExists=TRUE, then the method returns HRESULT_FROM_WIN32(ERROR_FILE_EXISTS)

    3) In case of a failure half way through, the method deletes the partial file

--*/
{
    HRESULT hr = S_OK;

    HANDLE hOriginal = INVALID_HANDLE_VALUE;
    HANDLE hCopy = INVALID_HANDLE_VALUE;
    BYTE *pBuffer = NULL;

    WsbTraceIn(OLESTR("CNtFileIo::InternalCopyFile"), OLESTR(""));

    try {
		// Create file on the Original media with no write-sharing - upper level should ensure 
        //  that nobody opens the file for write while a copy-media is going on
        WsbAffirmHandle(hOriginal = CreateFile(pOriginalFileName,
                GENERIC_READ,
                FILE_SHARE_READ,
                NULL,
                OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                NULL));

		// Create the file on the Copy media with no sharing at all. Create-disposition 
        //  depends on caller request
        //  Exisitng file would generate ERROR_FILE_EXISTS that should be handled by the caller
        DWORD dwCreationDisposition;
        dwCreationDisposition = bFailIfExists ? CREATE_NEW : CREATE_ALWAYS;
        WsbAffirmHandle(hCopy = CreateFile(pCopyFileName,
                GENERIC_WRITE,
                0,              // no sharing
                NULL,
                dwCreationDisposition,
                FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                NULL));

        // Allocate a buffer for the media copy
        ULONG defaultBufferSize = RMS_DEFAULT_BUFFER_SIZE;
        DWORD size;
        OLECHAR tmpString[256];
        if (SUCCEEDED(WsbGetRegistryValueString(NULL, RMS_REGISTRY_STRING, RMS_PARAMETER_COPY_BUFFER_SIZE, tmpString, 256, &size))) {
            // Get the value.
            LONG val = wcstol(tmpString, NULL, 10);
            if (val > 0) {
                defaultBufferSize = val;
            }
        }
        pBuffer = (BYTE *)WsbAlloc(defaultBufferSize);
        WsbAffirmAlloc(pBuffer);

        // Read and write in chunks
        //  Synchronous ReadFile should signal eof by returning zero bytes read
        BOOL done = FALSE;
        DWORD dwBytesToRead = defaultBufferSize;
        DWORD dwBytesRead, dwBytesWritten;
        while (! done) {
            WsbAffirmStatus(ReadFile(hOriginal, pBuffer, dwBytesToRead, &dwBytesRead, NULL));

            if (dwBytesRead == 0) {
                // eof
                done = TRUE;
            } else {
                // Write to copy-file
                WsbAffirmStatus(WriteFile(hCopy, pBuffer, dwBytesRead, &dwBytesWritten, NULL));

                if (dwBytesWritten != dwBytesRead) {
                    // Fail the copy
                    WsbTraceAlways(OLESTR("CNtFileIo::InternalCopyFile: writing to copy-file is not completed to-write=%lu, written=%lu - Aborting!\n"),
                            dwBytesRead, dwBytesWritten);
                    WsbThrow(E_FAIL);
                }
            }
        }

        // Flush to media
        WsbAffirmStatus(FlushFileBuffers(hCopy));

    } WsbCatch(hr);

    // Close original file
    if (INVALID_HANDLE_VALUE != hOriginal) {
        CloseHandle(hOriginal);
        hOriginal = INVALID_HANDLE_VALUE;
    }

    // Close copy file
    if (INVALID_HANDLE_VALUE != hCopy) {
        if (! CloseHandle(hCopy)) {
            DWORD dwErr = GetLastError();
            WsbTrace(OLESTR("CNtFileIo::InternalCopyFile: CloseHandle for copy-file failed with error=%lu\n"), dwErr);

            // Set hr only if there was a success so far...
            if (SUCCEEDED(hr)) {
                hr = HRESULT_FROM_WIN32(dwErr);
            }
        }

        hCopy = INVALID_HANDLE_VALUE;

        // Delete copy file on any error, including close errors
        if (! SUCCEEDED(hr)) {
            WsbTrace(OLESTR("CNtFileIo::InternalCopyFile: Deleting copy-file <%s> due to an error during the copy\n"),
                        pCopyFileName);

            if (! DeleteFile(pCopyFileName)) {
                DWORD dwErr = GetLastError();
                WsbTrace(OLESTR("CNtFileIo::InternalCopyFile: Failed to delete copy-file, DeleteFile error=%lu\n"), dwErr);
            }
        }

    }

    if (pBuffer) {
        WsbFree(pBuffer);
        pBuffer = NULL;
    }

    WsbTraceOut(OLESTR("CNtFileIo::InternalCopyFile"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\mover\server\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\mover\server\ntfileio.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    NtFileIo.h

Abstract:

    Definition of the CNtFileIo class

Author:

    Brian Dodd          [brian]         25-Nov-1997

Revision History:

--*/

#if !defined(NtFileIo_H)
#define NtFileIo_H

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "resource.h"       // main symbols
#include "MTFSessn.h"       // CMTFSession

/////////////////////////////////////////////////////////////////////////////
// CNtFileIo

class CNtFileIo : 
    public CComDualImpl<IDataMover, &IID_IDataMover, &LIBID_MOVERLib>,
    public IStream,
    public ISupportErrorInfo,
    public IWsbCollectable,
    public CComObjectRoot,
    public CComCoClass<CNtFileIo,&CLSID_CNtFileIo>
{
public:
    CNtFileIo() {}
BEGIN_COM_MAP(CNtFileIo)
    COM_INTERFACE_ENTRY2(IDispatch, IDataMover)
    COM_INTERFACE_ENTRY(IDataMover)
    COM_INTERFACE_ENTRY(IStream)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
    COM_INTERFACE_ENTRY(IWsbCollectable)
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(CNtFileIo) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation. 

DECLARE_REGISTRY_RESOURCEID(IDR_CNtFileIo)

// ISupportsErrorInfo
    STDMETHOD(InterfaceSupportsErrorInfo)(
        IN REFIID riid);

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);
    STDMETHOD(FinalRelease)(void);

// IWsbCollectable
public:
    STDMETHOD(CompareTo)( IN IUnknown *pCollectable, OUT SHORT *pResult);
    STDMETHOD(IsEqual)(IUnknown* pCollectable);

// IDataMover
public:
    STDMETHOD(GetObjectId)(OUT GUID *pObjectId);

    STDMETHOD( BeginSession )(
        IN BSTR remoteSessionName,
        IN BSTR remoteSessionDescription,
        IN SHORT remoteDataSet,
        IN DWORD options);

    STDMETHOD( EndSession )(void);

    STDMETHOD( StoreData )(
        IN BSTR localName,
        IN ULARGE_INTEGER localDataStart,
        IN ULARGE_INTEGER localDataSize,
        IN DWORD flags,
        OUT ULARGE_INTEGER *pRemoteDataSetStart,
        OUT ULARGE_INTEGER *pRemoteFileStart,
        OUT ULARGE_INTEGER *pRemoteFileSize,
        OUT ULARGE_INTEGER *pRemoteDataStart,
        OUT ULARGE_INTEGER *pRemoteDataSize,
        OUT DWORD *pRemoteVerificationType,
        OUT ULARGE_INTEGER *pRemoteVerificationData,
        OUT DWORD *pDatastreamCRCType,
        OUT ULARGE_INTEGER *pDatastreamCRC,
        OUT ULARGE_INTEGER *pUsn);

    STDMETHOD( RecallData )(
        IN BSTR localName,
        IN ULARGE_INTEGER localDataStart,
        IN ULARGE_INTEGER localDataSize,
        IN DWORD flags,
        IN BSTR migrateSessionName,
        IN ULARGE_INTEGER remoteDataSetStart,
        IN ULARGE_INTEGER remoteFileStart,
        IN ULARGE_INTEGER remoteFileSize,
        IN ULARGE_INTEGER remoteDataStart,
        IN ULARGE_INTEGER remoteDataSize,
        IN DWORD remoteVerificationType,
        IN ULARGE_INTEGER remoteVerificationData);

    STDMETHOD( FormatLabel )(
        IN BSTR displayName,
        OUT BSTR *pLabel);

    STDMETHOD( WriteLabel )(
        IN BSTR label);

    STDMETHOD( ReadLabel )(
        IN OUT BSTR *pLabel );

    STDMETHOD( VerifyLabel )(
        IN BSTR label);

    STDMETHOD( GetDeviceName )(
        OUT BSTR *pName);

    STDMETHOD( SetDeviceName )(
        IN BSTR name,
        IN BSTR unused);

    STDMETHOD( GetLargestFreeSpace )(
        OUT LONGLONG *pFreeSpace,
        OUT LONGLONG *pCapacity,
        IN  ULONG    defaultFreeSpaceLow = 0xFFFFFFFF,
        IN  LONG     defaultFreeSpaceHigh = 0xFFFFFFFF);

    STDMETHOD( SetInitialOffset )(
        IN ULARGE_INTEGER initialOffset);

    STDMETHOD( GetCartridge )(
        OUT IRmsCartridge **ptr);

    STDMETHOD( SetCartridge )(
        IN IRmsCartridge *ptr);

    STDMETHOD( Cancel )(void);

    STDMETHOD( CreateLocalStream )(
        IN BSTR name,
        IN DWORD mode,
        OUT IStream **ppStream);

    STDMETHOD( CreateRemoteStream )(
        IN BSTR name,
        IN DWORD mode,
        IN BSTR remoteSessionName,
        IN BSTR remoteSessionDescription,
        IN ULARGE_INTEGER remoteDataSetStart,
        IN ULARGE_INTEGER remoteFileStart,
        IN ULARGE_INTEGER remoteFileSize,
        IN ULARGE_INTEGER remoteDataStart,
        IN ULARGE_INTEGER remoteDataSize,
        IN DWORD remoteVerificationType,
        IN ULARGE_INTEGER remoteVerificationData,
        OUT IStream **ppStream);

    STDMETHOD( CloseStream )(void);

    STDMETHOD( Duplicate )(
        IN IDataMover *pDestination,
        IN DWORD options,
        OUT ULARGE_INTEGER *pBytesCopied,
        OUT ULARGE_INTEGER *pBytesReclaimed);

    STDMETHOD( FlushBuffers )(void);

    STDMETHOD( Recover )(OUT BOOL *pDeleteFile);

// IStream
public:
    STDMETHOD( Read )(
        OUT void *pv,
        IN ULONG cb,
        OUT ULONG *pcbRead);

    STDMETHOD( Write )(
        IN void const *pv,
        IN ULONG cb,
        OUT ULONG *pcbWritten);

    STDMETHOD( Seek )(
        IN LARGE_INTEGER dlibMove,
        IN DWORD dwOrigin,
        OUT ULARGE_INTEGER *plibNewPosition);

    STDMETHOD( SetSize )(
        IN ULARGE_INTEGER libNewSize);

    STDMETHOD( CopyTo )(
        IN IStream *pstm,
        IN ULARGE_INTEGER cb,
        OUT ULARGE_INTEGER *pcbRead,
        OUT ULARGE_INTEGER *pcbWritten);

    STDMETHOD( Commit )(
        IN DWORD grfCommitFlags);

    STDMETHOD( Revert )(void);

    STDMETHOD( LockRegion )(
        IN ULARGE_INTEGER libOffset,
        IN ULARGE_INTEGER cb,
        IN DWORD dwLockType);

    STDMETHOD( UnlockRegion )(
        IN ULARGE_INTEGER libOffset,
        IN ULARGE_INTEGER cb,
        IN DWORD dwLockType);

    STDMETHOD( Stat )(
        OUT STATSTG *pstatstg,
        IN DWORD grfStatFlag);

    STDMETHOD( Clone )(
        OUT IStream **ppstm);

private:
    enum {                                          // Class specific constants:
                                                    //
        Version = 1,                                // Class version, this should be
                                                    //   incremented each time the
                                                    //   the class definition changes.
        DefaultBlockSize = 512,                     // Default block size to use.
        DefaultMinBufferSize = RMS_DEFAULT_BUFFER_SIZE, // Default minimum buffer size.
    };
    GUID                    m_ObjectId;             // Unique ID for this object.
    CMTFSession*            m_pSession;             // Holds all session information.
    SHORT                   m_DataSetNumber;        // Holds the current dataset number.
    HANDLE                  m_hFile;                // Tape drive handle.
    CWsbBstrPtr             m_DeviceName;           // The name of the tape device.
    DWORD                   m_Flags;                // Holds data transfer type flag.
    CWsbBstrPtr             m_LastVolume;           // Name of the last volume backed up.
    CWsbBstrPtr             m_LastPath;             // Name of the last directory backed up.
    BOOL                    m_ValidLabel;           // True if the label is valid, the flag
                                                    //   knocked down on BUS_RESET and Medium
                                                    //   errors, and assumed valid at initialization.

    CWsbBstrPtr             m_StreamName;           // Stream state information...
    ULONG                   m_Mode;                 // The kind of I/O.  See MVR_MODE_*, MVR_FLAG_*
    ULARGE_INTEGER          m_StreamOffset;         // Unformatted mode: The (absolute) current offset into the data stream
                                                    // HSM Semantics mode: The offset into the remote file itself from the beginning of the file
    ULARGE_INTEGER          m_StreamSize;           // The size of the data stream
    CComPtr<IRmsCartridge>  m_pCartridge;           // A reference to the Cartridge in use by the DataMover.

    BOOL                    m_isLocalStream;        // Either local and remote stream is created
    ULONG                   m_OriginalAttributes;   // The original attributes of the local file.

    DWORD                   m_BlockSize;            // The read/write blocking factor.

    static int              s_InstanceCount;        // Counter of the number of object instances.

    // File I/O
    HRESULT WriteBuffer(IN BYTE *pBuffer, IN ULONG nBytesToWrite, OUT ULONG *pBytesWritten);
    HRESULT ReadBuffer(IN BYTE *pBuffer, IN ULONG nBytesToRead, OUT ULONG *pBytesRead);

    HRESULT InternalCopyFile(IN WCHAR *pOriginalFileName, IN WCHAR *pCopyFileName, IN BOOL bFailIfExists);

    // Block Positioning
    HRESULT GetPosition(OUT UINT64 *pPosition);
    HRESULT SetPosition(IN UINT64 position);
    HRESULT EnsurePosition(IN UINT64 position);

    // Utililties
    HRESULT GetRemotePath(OUT BSTR *pDestinationString);
    HRESULT DeleteAllData(void);
    HRESULT FormatDrive(IN BSTR label);
    HRESULT DoRecovery (void);
    HRESULT CreateRecoveryIndicator (IN WCHAR *pFileName);
    HRESULT DeleteRecoveryIndicator (IN WCHAR *pFileName);
    HRESULT TestRecoveryIndicatorAndDeleteFile (IN WCHAR *pFileName);

    HRESULT MapFileError(IN HRESULT hrToMap);
};

#endif // !defined(NtFileIo_H)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\mover\server\mtf_api.h ===
//____________________________________________________________________________
//
// (C) Copyright Seagate Software, Inc. 1994-1996
//  1998 Seagate Software, Inc.  All rights reserved.
//
// All Rights Reserved Worldwide.
//
//____________________________________________________________________________
//
// FILE NAME :          mtf_api.h
//
// DESCRIPTION :        api for creating mtf format structures
//                      (see detail description below)
//
// CREATED:             6/20/95
//
//____________________________________________________________________________
//
// $Revision:   1.35  $
//     $Date:   02 Feb 1995 15:47:04  $
//  $Modtime:   02 Feb 1995 15:37:38  $
//  
//____________________________________________________________________________

/*****************************************************************************
DETAIL DESCRIPTION

NOTE:  See the file MTF_TST.C for an example showing how to use this API

OVERVIEW
========
The MTF API provides a set of structures, each of which corresponds (but is not
identical to) to the structures described in the Microsoft Tape Format reference 
manual.  The client instanciates these structures, fills in the fields and then 
uses an MTF API function to format the information in the structure into a supplied
buffer in MTF format.  The buffer is then padded up to the next alignment factor
using an MTF API call and then  may then be written to tape using WIN32 Write. 

For example, to write an MTF TAPE DBLK,

1) Instanciate the MTF API structures.  The common header structure is used 
separately so that it can be re-used among DBLK writes
    
    MTF_DBLK_HDR_INFO sHdr;
    MTF_DBLK_TAPE_INFO sTape;

2) Use MTF API set default functions to set default values of these

    MTF_SetDblkHdrDefaults(&sHdr);
    MTF_SetTAPEDefaults(&sTape);

3) Override the default values as necessary

    sHdr.uFormatLogicalAddress = ...
    ...
    sTape.szTapeName = L"MY TAPE!"
    ...

4) Use the MTF API calls to format the contents of these structures into a buffer.
   If the API needs more room than BUFSIZE then then ammount needed is stored in 
   nBufUsed.  Otherwise nBufUsed reflects the amount of space in the buffer 
   used by the call.

    MTF_WriteTAPEDblk(&sHdr,
                      &sTape,
                      pBuffer,
                      BUFSIZE,
                      &nBufUsed);

5) NOTE WELL:  The write calls *DO NOT PAD* to the next alignment index.  But this 
   is easily done using the MTF API call:

    MTF_PadToNextAlignmentFactor(pBuffer,     
                                 nBufUsed,
                                 BUFSIZE, 
                                 &nBufUsed);

6) At this point, nBufUsed % MTF_GetAlignmentFactor should == 0.  If our blocksize
   evenly divides our alignment factor, then we can use the WIN32 Write call to

    WriteFile(hTape, pBuffer, nBufUsed, &nBytesWritten, 0);

   Since our blocksize divides our AF, then nBytesWritten should == nBufUsed

*** SEE THE MTF_TST.C FOR A COMPLETE EXAMPLE SHOWING THE USE OF THIS API TO CREATE
    A BACKUP SET


MTF API DATA STRUCTURE AND FUNCTION SUMMARY
===========================================
===========================================
**summary only -- generic detail comments appear below**


LOW LEVEL TYPES
===============
The following are typedefed to the corresponding "unsigned __intxx"

types:
    UINT8
    UINT16
    UINT32
    UINT64

functions:
MTF_CreateUINT64()  -- creates a 64 bit unsigned from two UINT32 values (lsb & msb)


DATE & TIME
===========
MTF_DATE_TIME                    -- structure used by MTF API for holding packed date & time info 
MTF_CreateDateTimeNull()         -- returns a null MTF_DATE_TIME
MTF_CreateDateTime()             -- creates MTF_DATE_TIME from year, month, day, hour, min, sec
MTF_CreateDateTimeFromTM()       -- creates MTF_DATE_TIME from struct tm in <time.h>
MTF_CreateDateTimeFromFileTime() -- creates MTF_DATE_TIME from FILETIME used by FindFirst/FindNext
MTF_CreateDateTimeToTM()         -- fills in a struct tm structure given an MTF_DATE_TIME struct


ALIGNMENT FACTOR
================
MTF_SetAlignmentFactor           -- sets the alignment factor for the MTF API (you must do this)
MTF_GetAlignmentFactor           -- returns the set alignment factor
MTF_PadToNextAlignmentFactor     -- Pads out a buffer using an SPAD to the next alignment factor
MTF_PadToNextPhysicalBlockBoundary -- Pads out a buffer using an SPAD to the next physical block boundary


MTF COMMON HEADER BLOCK
=======================
MTF_DBLK_HDR_INFO                -- common block header (must be supplied to all calls to write dblks
MTF_SetDblkHdrDefaults           -- sets default values (always call this before you set your own)


MTF TAPE DBLK INFO
==================
MTF_DBLK_TAPE_INFO     -- info corresponding to a TAPE dblk   
MTF_SetTAPEDefaults    -- sets defaults (always do this before setting your own)
MTF_WriteTAPEDblk      -- formats info in MTF_DBLK_TAPE_INFO to tape
MTF_ReadTAPEDblk       -- reads info back from a buffer holding MTF FORMATTED TAPE DBLK


MTF SSET DBLK INFO
==================
MTF_DBLK_SSET_INFO     -- all similar to above but for SSET DBLK
MTF_SetSSETDefaults    -- 
MTF_WriteSSETDblk      -- 
MTF_ReadSSETDblk       -- 


MTF VOLB DBLK INFO
==================
MTF_DBLK_VOLB_INFO     -- all similar to above but for VOLB DBLK
MTF_SetVOLBDefaults    -- 
MTF_WriteVOLBDblk      -- 
MTF_ReadVOLBDblk       -- 
MTF_SetVOLBForDevice   -- sets default values given a device name ("C:") using 
                          GetVolumeInformation (WIN32 call)


MTF DIRB DBLK INFO
==================
MTF_DBLK_DIRB_INFO        -- all similar to above but for DIRB DBLK
MTF_SetDIRBDefaults       -- 
MTF_WriteDIRBDblk         -- (dblk only -- no stream)
MTF_ReadDIRBDblk          -- 
MTF_SetDIRBFromFindData   -- sets default values given a WIN32_FIND_DATAW struct (returned
                             from calls to WIN32 FindFirst, FindNext, etc..


MTF FILE DBLK INFO
==================
MTF_DBLK_FILE_INFO        -- all similar to above but for FILE DBLK
MTF_SetFILEDefaults       -- 
MTF_WriteFILEDblk         -- (dblk only -- no stream)
MTF_ReadFILEDblk          -- 
MTF_SetFILEFromFindData   -- sets default values given a WIN32_FIND_DATAW struct (returned
                             from calls to WIN32 FindFirst, FindNext, etc..


MTF CFIL DBLK INFO
==================
MTF_DBLK_CFIL_INFO        -- all similar to above but for CFIL DBLK
MTF_SetCFILDefaults       -- 
MTF_WriteCFILDblk         -- 
MTF_ReadCFILDblk          -- 


MTF ESET DBLK INFO
==================
MTF_DBLK_ESET_INFO        -- all similar to above but for ESET DBLK
MTF_SetESETDefaults       -- 
MTF_WriteESETDblk         -- 
MTF_ReadESETDblk          -- 


MTF EOTM DBLK INFO
==================
MTF_DBLK_EOTM_INFO        -- all similar to above but for EOTM DBLK
MTF_SetEOTMDefaults       -- 
MTF_WriteEOTMDblk         -- 
MTF_ReadEOTMDblk          -- 


MTF STREAM INFO
==================
MTF_STREAM_INFO           -- all similar to above but for EOTM DBLK
MTF_SetSTREAMDefaults     -- 
MTF_WriteSTREAMHeader     -- 
MTF_ReadSTREAMHeader      -- 
MTF_SetSTREAMDefaultsFromStreamId
                          -- sets stream defaults from a WIN32_STREAM_ID struct
                             (returned from the WIN32 BackupRead function)

***********************************************************************************/

#ifndef _MTF_API_H_
#define _MTF_API_H_

#include <windows.h>
#include <stdlib.h>
#include <wchar.h>
#include <time.h>

#ifdef __cplusplus
extern "C" {
#endif

/***********************************************************************************
************************************************************************************
************************************************************************************
****  MTF Constants, defines and bit masks
************************************************************************************
************************************************************************************
***********************************************************************************/

/* ==================================================================================
     MTF ERROR CODES
================================================================================== */

#define MTF_ERROR_NONE              0
#define MTF_ERROR_BUFFER_TOO_SMALL  1000
#define MTF_NO_STREAMS              1001
#define MTF_OUT_OF_MEMORY           1002

/* ==================================================================================
     MTF Misc. Defaults and Constants
================================================================================== */
#define MTF_DEFAULT_ALIGNMENT_FACTOR 1024;

#define MTF_FORMAT_VER_MAJOR      1
#define MTF_FORMAT_VER_MINOR      0 // BMD: This API is verison 5; use 0 for compatibility with NT Backup

#define MTF_PW_ENCRYPT_NONE       0
#define MTF_DATA_ENCRYPT_NONE     0
#define MTF_ECC_NONE              0

#define MTF_COMPRESS_NONE         0

#define MTF_OTC_NONE              0
#define MTF_OTC_TYPE              1
#define MTF_OTC_VERSION           2

#define MTF_LOCAL_TZ              127

#define MTF_STRING_NONE           0
#define MTF_STRING_ANSI_STR       1
#define MTF_STRING_UNICODE_STR    2

#define MTF_OSID_NT               14
#define MTF_OSID_DOS              24

/* ==================================================================================
     MTF Block Types
================================================================================== */

#define  MTF_ID_TAPE     "TAPE"    /* Tape Header ID */
#define  MTF_ID_VOLB     "VOLB"    /* Volume Control Block ID */
#define  MTF_ID_SSET     "SSET"    /* Start of Backup Set Description Block ID */
#define  MTF_ID_ESET     "ESET"    /* End of Backup Set Description Block ID */
#define  MTF_ID_EOTM     "EOTM"    /* End of tape, continuation Block ID */
#define  MTF_ID_DIRB     "DIRB"    /* Directory Descriptor Block ID */
#define  MTF_ID_FILE     "FILE"    /* File Descriptor Block ID */
#define  MTF_ID_CFIL     "CFIL"    /* Corrupt File Descriptor Block ID */
#define  MTF_ID_ESPB     "ESPB"    /* End of Set Pad Block */
#define  MTF_ID_SFMB     "SFMB"    /* Soft Filemark Descriptor Block ID */


/* ==================================================================================
     DBLK Block Attributes

     The lower 16 bits are reserved for general attribute bits (those
     which may appear in more than one type of DBLK), the upper 16 are
     for attributes which are specific to one type of DBLK.

     Note that the block specific bit definitions overlap, and the block
     type is used to determine the meaning of a given bit.
================================================================================== */

/* any : */
#define MTF_CONTINUATION        0x00000001UL
#define MTF_COMPRESSION         0x00000004UL
#define MTF_EOS_AT_EOM          0x00000008UL
#define MTF_VAR_BLKS            0x00000010UL
#define MTF_SESSION             0x00000020UL

/* TAPE : */
#define MTF_SM_EXISTS           0x00010000UL
#define MTF_FDD_ALLOWED         0x00020000UL
#define MTF_SM_ALT_OVERWRITE    0x00040000UL
#define MTF_FDD_ALT_PART        0x00080000UL
#define MTF_SM_ALT_APPEND       0x00200000UL

/* SSET : */
#define MTF_FDD_EXISTS          0x00010000UL
#define MTF_ENCRYPTION          0x00020000UL

/* ESET : */
#define MTF_FDD_ABORTED         0x00010000UL
#define MTF_END_OF_FAMILY       0x00020000UL
#define MTF_ABORTED_SET         0x00040000UL
#define MTF_SET_VERIFIED        0x00080000UL

/* EOTM : */
#define MTF_NO_ESET_PBA         0x00010000UL
#define MTF_INVALID_ESET_PBA    0x00020000UL

/* ==================================================================================
     TAPE Block Attributes
================================================================================== */

#define MTF_TAPE_SOFT_FILEMARK  0x00000001UL
#define MTF_TAPE_MEDIA_LABEL    0x00000002UL

/* ==================================================================================
     SSET Block Attributes
================================================================================== */

#define MTF_SSET_TRANSFER       0x00000001UL
#define MTF_SSET_COPY           0x00000002UL
#define MTF_SSET_NORMAL         0x00000004UL
#define MTF_SSET_DIFFERENTIAL   0x00000008UL
#define MTF_SSET_INCREMENTAL    0x00000010UL
#define MTF_SSET_DAILY          0x00000020UL

/* ==================================================================================
     VOLB Block Attributes
================================================================================== */

#define MTF_VOLB_NO_REDIRECT    0x00000001UL
#define MTF_VOLB_NON_VOLUME     0x00000002UL
#define MTF_VOLB_DEV_DRIVE      0x00000004UL
#define MTF_VOLB_DEV_UNC        0x00000008UL
#define MTF_VOLB_DEV_OS_SPEC    0x00000010UL
#define MTF_VOLB_DEV_VEND_SPEC  0x00000020UL

/* ==================================================================================
     DIRB Block Attributes
================================================================================== */

#define MTF_DIRB_READ_ONLY      0x00000100UL
#define MTF_DIRB_HIDDEN         0x00000200UL
#define MTF_DIRB_SYSTEM         0x00000400UL
#define MTF_DIRB_MODIFIED       0x00000800UL
#define MTF_DIRB_EMPTY          0x00010000UL
#define MTF_DIRB_PATH_IN_STREAM 0x00020000UL
#define MTF_DIRB_CORRUPT        0x00040000UL

/* ==================================================================================
     FILE Block Attributes
================================================================================== */

#define MTF_FILE_READ_ONLY      0x00000100UL
#define MTF_FILE_HIDDEN         0x00000200UL
#define MTF_FILE_SYSTEM         0x00000400UL
#define MTF_FILE_MODIFIED       0x00000800UL
#define MTF_FILE_IN_USE         0x00010000UL
#define MTF_FILE_NAME_IN_STREAM 0x00020000UL
#define MTF_FILE_CORRUPT        0x00040000UL

/* ==================================================================================
     CFIL Block Attributes
================================================================================== */

#define MTF_CFIL_LENGTH_CHANGE  0x00010000UL
#define MTF_CFIL_UNREADABLE_BLK 0x00020000UL
#define MTF_CFIL_DEADLOCK       0x00040000UL

/* ==================================================================================
     ESET Block Attributes
================================================================================== */

#define MTF_ESET_TRANSFER       0x00000001UL
#define MTF_ESET_COPY           0x00000002UL
#define MTF_ESET_NORMAL         0x00000004UL
#define MTF_ESET_DIFFERENTIAL   0x00000008UL
#define MTF_ESET_INCREMENTAL    0x00000010UL
#define MTF_ESET_DAILY          0x00000020UL

/* ==================================================================================
     STREAM File System Attributes
================================================================================== */

#define MTF_STREAM_MODIFIED_BY_READ     0x00000001UL
#define MTF_STREAM_CONTAINS_SECURITY    0x00000002UL
#define MTF_STREAM_IS_NON_PORTABLE      0x00000004UL
#define MTF_STREAM_IS_SPARSE            0x00000008UL

/* ==================================================================================
     STREAM Media Format Attributes
================================================================================== */

#define MTF_STREAM_CONTINUE         0x00000001UL
#define MTF_STREAM_VARIABLE         0x00000002UL
#define MTF_STREAM_VAR_END          0x00000004UL
#define MTF_STREAM_ENCRYPTED        0x00000008UL
#define MTF_STREAM_COMPRESSED       0x00000010UL
#define MTF_STREAM_CHECKSUMED       0x00000020UL
#define MTF_STREAM_EMBEDDED_LENGTH  0x00000040UL

/* ==================================================================================
     STREAM Types (Platform Independent)
================================================================================== */

#define MTF_STANDARD_DATA_STREAM    "STAN"
#define MTF_PATH_NAME_STREAM        "PNAM"
#define MTF_FILE_NAME_STREAM        "FNAM"
#define MTF_CHECKSUM_STREAM         "CSUM"
#define MTF_CORRUPT_STREAM          "CRPT"
#define MTF_PAD_STREAM              "SPAD"
#define MTF_SPARSE_STREAM           "SPAR"
#define MTF_MBC_LMO_SET_MAP_STREAM  "TSMP"
#define MTF_MBC_LMO_FDD_STREAM      "TFDD"
#define MTF_MBC_SLO_SET_MAP_STREAM  "MAP2"
#define MTF_MBC_SLO_FDD_STREAM      "FDD2"

/* ==================================================================================
     STREAM Types (Windows NT specific)
================================================================================== */

#define MTF_NTFS_ALT_STREAM         "ADAT"
#define MTF_NTFS_EA_STREAM          "NTEA"
#define MTF_NT_SECURITY_STREAM      "NACL"
#define MTF_NT_ENCRYPTED_STREAM     "NTED"
#define MTF_NT_QUOTA_STREAM         "NTQU"
#define MTF_NT_PROPERTY_STREAM      "NTPR"
#define MTF_NT_REPARSE_STREAM       "NTRP"
#define MTF_NT_OBJECT_ID_STREAM     "NTOI"

/* ==================================================================================
     STREAM Frame Headers
================================================================================== */

#define MTF_COMPRESSION_HEADER_ID   "FM"
#define MTF_ECRYPTION_HEADER_ID     "EH"

/* ==================================================================================
 * Turn on packing here.  Need to be sure that date is packed. 
================================================================================== */
#pragma pack(1)

/***********************************************************************************
************************************************************************************
************************************************************************************
****  MTF Miscelaneous Data Types (and some handy methods for them)
************************************************************************************
************************************************************************************
***********************************************************************************/

/* ==================================================================================
     General Data Types
================================================================================== */

UINT64 MTF_CreateUINT64(
    UINT32 uLSB, UINT32 uMSB);


/* ==================================================================================
     Compressed date structure for storing dates in minimal space on tape:

     BYTE 0    BYTE 1    BYTE 2    BYTE 3    BYTE 4
    76543210  76543210  76543210  76543210  76543210
    yyyyyyyy  yyyyyymm  mmdddddh  hhhhmmmm  mmssssss
================================================================================== */
typedef struct {
     UINT8     dt_field[5] ;
} MTF_DATE_TIME;


/************************************************************************************
* MTF_CreateDataTime#####()
*
* Description:  Given various arguments, this set of functions returns a packed 
*               MTF_DATE_TIME struct which can then be assigned to fields found 
*               in the various info structs found below
* Example:
*               sSetInfo.sBackupDate = MTF_CreateDateTime(1995, 6, 12, 16, 30, 0);
************************************************************************************/

MTF_DATE_TIME MTF_CreateDateTimeNull();

MTF_DATE_TIME MTF_CreateDateTime(
    int iYear, 
    int iMonth, 
    int iDay, 
    int iHour, 
    int iMinute,
    int iSecond
    );

MTF_DATE_TIME MTF_CreateDateTimeFromTM(
    struct tm *pT);

MTF_DATE_TIME MTF_CreateDateTimeFromFileTime(   
    FILETIME sFileTime);

void MTF_CreateDateTimeToTM(
    MTF_DATE_TIME *pDT, 
    struct tm     *pT);



/***********************************************************************************
************************************************************************************
****  MTF Alignment Factor 
************************************************************************************
***********************************************************************************/

/************************************************************************************
* MTF_SetAlignmentFactor()
*
* Description:  Sets the alignment factor to be used by the MTF API
*               (particularly by MTF_PadToNextAlignmentFactor and MTF_WriteTAPEDblk)
*
* Pre:
* Post: MTF API Alignment Factor == uAF
*
* uAF -- alignment factor value to set
************************************************************************************/
void MTF_SetAlignmentFactor(
    UINT16 uAF);



/************************************************************************************
* MTF_GetAlignmentFactor()
*
* Description:  Returns the Alignment Factor set by MTF_SetAlignmentFactor
*
* Pre: MTF_SetAlignmentFactor has been called
************************************************************************************/
UINT16 MTF_GetAlignmentFactor();



/************************************************************************************
* MTF_PadToNextAlignmentFactor()
*
* Description:  Appends an SPAD stream to the buffer so as to pad the buffer out to 
*               the next alignment factor
*               
*
* Pre:  The alignment factor has been set by calling MTF_SetAlignmentFactor,
*       pBuffer points to a buffer whose size is reflected by nBufferSize
*
* Post: return value == MTF_ERROR_NONE
*           => padding was successful, *pnSizeUsed reflects amount of buffer used,
*              AND *pnSizeUsed % MTF_GetAlignmentFactor == 0  is  TRUE
*       return value == MTF_ERROR_BUFFER_TOO_SMALL
*           => The buffer was too small, *pnSizeUsed reflects the amound needed
*
* NOTE: If the space between the end of the buffer and the next alignment factor is 
*       smaller than the size of a stream header, then the spad hogs up the whole 
*       next alignment factor.
*
* pBuffer     -- the buffer to spad out
* nBufUsed    -- the amount of the buffer used so far (position where to append)
* nBufferSize -- the size of the buffer pointed to by pBuffer
* pnSizeUsed  -- points to where to store size used or needed
************************************************************************************/
DWORD MTF_PadToNextAlignmentFactor(
    BYTE     *pBuffer,    
    size_t    nBufUsed,
    size_t    nBufferSize, 
    size_t   *pnSizeUsed);

/************************************************************************************
* MTF_PadToNextPhysicalBlockBoundary() - (bmd)
*
* Description:  Appends an SPAD stream to the buffer so as to pad the buffer out to 
*               the next physical block boundary.
*
************************************************************************************/
DWORD MTF_PadToNextPhysicalBlockBoundary(
    BYTE *pBuffer,
    size_t nBlockSize,
    size_t nBufUsed,
    size_t nBufferSize,
    size_t *pnSizeUsed);


/***********************************************************************************
************************************************************************************
************************************************************************************
****  MTF API STRUCTURES
************************************************************************************
************************************************************************************
***********************************************************************************/

/***********************************************************************************
GENERIC DETAIL COMMENTS FOR FUNCTIONS FOUND BELOW
=================================================

************************************************************************************
* MTF_Set####Defaults()
*
* Description:  Sets up default values for the structure.  Always call this to
*               avoid garbage values in case you over look a field, 
* Pre:  
* Post: All fields of the referenced structure are filled in with *something*. 
*       Date fields are initialized to current date and time.
*       Strings pointers are set to 0
*       Most other values set to 0
*
* p####Info     -- pointer to structure to be set
************************************************************************************
void MTF_Set####Defaults(
    MTF_####_INFO *p####Info);    


************************************************************************************
* MTF_Write####Dblk()
*
* Description:  Formats the information supplied in psHdrInfo and ps####Info into
*               MTF Format and places the results in pBuffer
*
* Pre:  psHdrInfo and ps####Info contain valid information / default values
*       pBuffer points to a buffer where resulting format is to be stored
*       nBuffer size indicates the size of the buffer
*
*       MTF_WriteTAPEDblk -- MTF_SetAlingmentFactor has been called
*
* Post: return value == MTF_ERROR_NONE
*           => Format was successful, *pnSizeUsed reflects amount of buffer used
*       return value == MTF_ERROR_BUFFER_TOO_SMALL
*           => The buffer was too small, *pnSizeUsed reflects the amound needed
*
* psHdrInfo   -- MTF Common header information 
* ps####Info  -- MTF DBLK info
* pBuffer     -- pointer to buffer which will receive MTF formatted info
* pBufferSize -- the size of the buffer pointed to by pBuffer
* pnSizeUsed  -- pointer to a size_t in which amount of buffer used or needed is stored
************************************************************************************
DWORD MTF_Write####Dblk( MTF_DBLK_HDR_INFO  *psHdrInfo,
                         MTF_DBLK_####_INFO *ps####Info,  
                         BYTE               *pBuffer,     
                         size_t              nBufferSize, 
                         size_t             *pnSizeUsed); 



************************************************************************************
* MTF_Read####Dblk()
*
* Description:  Translates MTF Formatted information from a buffer to MTF API info
*               structures -- the opposite of MTF_Write####Dblk
*               
*
* Pre:  pBuffer contains correct MTF Buffer information 
*
* Post: psHdrInfo and ps####Info contain the de-formatted info.  
*
* NOTE: Strings point to strings stored statically by the API, and will be over 
*       written on the next read call. 
*
* psHdrInfo   -- MTF Common header info struct to receive info
* ps####Info  -- MTF DBLK info struct to receive info
* pBuffer     -- pointer to buffer which holds MTF formatted data
************************************************************************************
DWORD MTF_Read####Dblk(  MTF_DBLK_HDR_INFO  *psHdrInfo,
                         MTF_DBLK_####_INFO *ps####Info,  
                         BYTE               *pBuffer);    



************************************************************************************
* MTF_Set####From?????????()
*
* Description: Similar to MTF_Set####Defaults(), but takes as an argument one or more
*              commonly used structures and sets values from that.  For example, 
*              MTF_SetFILEFromFindData takes as an argument a WIN32_FIND_DATA struct
*              from which it extracts the file name, date, time, etc. 
*               
*
* Pre:  
* Post: As many fields as are reasonable are automatically set.  The rest of the 
*       fields are set to default values.
*
* NOTE: Strings such as file names, directory names are stored statically by the 
*       MTF API and are only good until the next call to an MTF_Set#####From??????
*       function.
*
* NOTE: FILE and DIRB calls automatically set the file and directory attibutes from 
*       the info in the WIN32_FIND_DATA structure.
*
* NOTE: MTF_SetSTREAMFromStreamId will automatically set the stream header id based
*       on the attributes found in the WIN32 stream header
*
************************************************************************************
void MTF_Set####From?????????(MTF_DBLK_####_INFO *p####Info, 
                              SomeType????        Id??? 
                              ....);
***********************************************************************************/



/* ==================================================================================
     Common DBLK: MTF_STD_DBLK_INFO
================================================================================== */
typedef struct { 

    char    acBlockType[5];         /* for reading only -- ignored when writing (includes \0)*/
    UINT32  uBlockAttributes;
    UINT16  uOffsetToFirstStream;   /* for reading only */
    UINT8   uOSID;                  /* Machine/OS id where written, low byte */
    UINT8   uOSVersion;             /* Machine/OS id where written, high byte */
    UINT64  uDisplayableSize;       /* Displayable data size */
    UINT64  uFormatLogicalAddress;
    UINT16  uReservedForMBC;        /* Reserved for Media Based Catalog */
    UINT16  uSoftwareCompression;   /* Software Compression Algorithm */
    UINT32  uControlBlockId;        /* Used for error recovery */
    void *  pvOSData;               /* OS specific Data */
    UINT16  uOSDataSize;            /* the size of the OS data in bytes */
    UINT8   uStringType;            /* String type */   
    UINT16  uHeaderCheckSum;        /* for reading only */

} MTF_DBLK_HDR_INFO;

void MTF_SetDblkHdrDefaults(
    MTF_DBLK_HDR_INFO *pStdInfo);



/* ==================================================================================
     TAPE DBLK: MTF_TAPE_INFO
================================================================================== */
typedef struct { 

    UINT32  uTapeFamilyId;
    UINT32  uTapeAttributes;
    UINT16  uTapeSequenceNumber;
    UINT16  uPasswordEncryptionAlgorithm;
    UINT16  uSoftFilemarkBlockSize;
    UINT16  uTapeCatalogType;
    wchar_t *   szTapeName;
    wchar_t * szTapeDescription;
    wchar_t * szTapePassword;
    wchar_t * szSoftwareName;
    UINT16  uAlignmentFactor;
    UINT16  uSoftwareVendorId;
    MTF_DATE_TIME   sTapeDate;
    UINT8   uMTFMajorVersion;

} MTF_DBLK_TAPE_INFO;

void MTF_SetTAPEDefaults(MTF_DBLK_TAPE_INFO *pTapeInfo);
    
DWORD MTF_WriteTAPEDblk( MTF_DBLK_HDR_INFO  *psHdrInfo,
                         MTF_DBLK_TAPE_INFO *psTapeInfo,  
                         BYTE               *pBuffer,     
                         size_t              nBufferSize, 
                         size_t             *pnSizeUsed); 
                                                          
                                                          
                                                          

DWORD MTF_ReadTAPEDblk(  MTF_DBLK_HDR_INFO  *psHdrInfo,
                         MTF_DBLK_TAPE_INFO *psTapeInfo,  
                         BYTE               *pBuffer);    
                                                          
                                                          
                                                          

/* ==================================================================================
     Start of Set DBLK (SSET)
================================================================================== */
typedef struct {
     UINT32              uSSETAttributes;
     UINT16              uPasswordEncryptionAlgorithm;
     UINT16              uDataEncryptionAlgorithm;
     UINT16              uSoftwareVendorId;
     UINT16              uDataSetNumber;
     wchar_t *           szDataSetName;
     wchar_t *           szDataSetDescription;
     wchar_t *           szDataSetPassword;
     wchar_t *           szUserName;
     UINT64              uPhysicalBlockAddress;
     MTF_DATE_TIME       sMediaWriteDate;
     UINT8               uSoftwareVerMjr;
     UINT8               uSoftwareVerMnr;
     UINT8               uTimeZone ;
     UINT8               uMTFMinorVer ;
     UINT8               uTapeCatalogVersion;
} MTF_DBLK_SSET_INFO;

void MTF_SetSSETDefaults(MTF_DBLK_SSET_INFO *pSSETInfo);

DWORD MTF_WriteSSETDblk( MTF_DBLK_HDR_INFO  *psHdrInfo,
                         MTF_DBLK_SSET_INFO *psTapeInfo,  
                         BYTE               *pBuffer,     
                         size_t              nBufferSize, 
                         size_t             *pnSizeUsed); 

DWORD MTF_ReadSSETDblk(  MTF_DBLK_HDR_INFO  *psHdrInfo,
                         MTF_DBLK_SSET_INFO *psTapeInfo,  
                         BYTE               *pBuffer);    
                                                          
                                                          
                                                          

/* ==================================================================================
     Volume DBLK (VOLB)
================================================================================== */
typedef struct {
     UINT32              uVolumeAttributes;
     wchar_t *           szDeviceName;
     wchar_t *           szVolumeName;
     wchar_t *           szMachineName;
     MTF_DATE_TIME       sMediaWriteDate;
} MTF_DBLK_VOLB_INFO;

typedef struct {
     UINT32              uFileSystemFlags;
     UINT32              uBackupSetAttributes;
} MTF_VOLB_OS_NT_1;

void MTF_SetVOLBDefaults(MTF_DBLK_VOLB_INFO *pVOLBInfo);

void MTF_SetVOLBForDevice(MTF_DBLK_VOLB_INFO *pVOLBInfo, wchar_t *szDevice);

DWORD MTF_WriteVOLBDblk( MTF_DBLK_HDR_INFO  *psHdrInfo,
                         MTF_DBLK_VOLB_INFO *psTapeInfo,  
                         BYTE               *pBuffer,     
                         size_t              nBufferSize, 
                         size_t             *pnSizeUsed); 

DWORD MTF_ReadVOLBDblk(  MTF_DBLK_HDR_INFO  *psHdrInfo,
                         MTF_DBLK_VOLB_INFO *psTapeInfo,  
                         BYTE               *pBuffer);    
                                                          
/* ==================================================================================
     Directory DBLK (DIRB)
================================================================================== */
typedef struct {
     UINT32              uDirectoryAttributes;
     MTF_DATE_TIME       sLastModificationDate;
     MTF_DATE_TIME       sCreationDate;
     MTF_DATE_TIME       sBackupDate;
     MTF_DATE_TIME       sLastAccessDate;
     UINT32              uDirectoryId;
     wchar_t *           szDirectoryName;
} MTF_DBLK_DIRB_INFO;

typedef struct {
     UINT32              uDirectoryAttributes;
} MTF_DIRB_OS_NT_0;

typedef struct {
     UINT32              uDirectoryAttributes;
     UINT16              uShortNameOffset;
     UINT16              uShortNameSize;
} MTF_DIRB_OS_NT_1;

void MTF_SetDIRBDefaults(MTF_DBLK_DIRB_INFO *pDIRBInfo);

void MTF_SetDIRBFromFindData( MTF_DBLK_DIRB_INFO *pDIRBInfo, 
                              wchar_t            *szFullFileName, 
                              WIN32_FIND_DATAW   *pFindData);

DWORD MTF_WriteDIRBDblk( MTF_DBLK_HDR_INFO  *psHdrInfo,
                         MTF_DBLK_DIRB_INFO *psTapeInfo,  
                         BYTE               *pBuffer,     
                         size_t              nBufferSize, 
                         size_t             *pnSizeUsed); 
                                                          
DWORD MTF_ReadDIRBDblk(  MTF_DBLK_HDR_INFO  *psHdrInfo,
                         MTF_DBLK_DIRB_INFO *psTapeInfo,  
                         BYTE               *pBuffer);    
                                                          



/* ==================================================================================
     File DBLK (FILE)
================================================================================== */
typedef struct {
     UINT32              uFileAttributes;
     MTF_DATE_TIME       sLastModificationDate;
     MTF_DATE_TIME       sCreationDate;
     MTF_DATE_TIME       sBackupDate;
     MTF_DATE_TIME       sLastAccessDate;
     UINT32              uDirectoryId;
     UINT32              uFileId;
     wchar_t *           szFileName;
     UINT64              uDisplaySize;
} MTF_DBLK_FILE_INFO;

typedef struct {
     UINT32              uFileAttributes;
     UINT16              uShortNameOffset;
     UINT16              uShortNameSize;
     UINT16              lLink;
     UINT16              uReserved;
} MTF_FILE_OS_NT_0;

typedef struct {
     UINT32              uFileAttributes;
     UINT16              uShortNameOffset;
     UINT16              uShortNameSize;
     UINT32              uFileFlags;
} MTF_FILE_OS_NT_1;

void MTF_SetFILEDefaults(MTF_DBLK_FILE_INFO *pFILEInfo);

void MTF_SetFILEFromFindData( MTF_DBLK_FILE_INFO *pFILEInfo, 
                              WIN32_FIND_DATAW *pFindData);

DWORD MTF_WriteFILEDblk( MTF_DBLK_HDR_INFO  *psHdrInfo,
                         MTF_DBLK_FILE_INFO *psTapeInfo,  
                         BYTE               *pBuffer,     
                         size_t              nBufferSize, 
                         size_t             *pnSizeUsed); 
                                                          
DWORD MTF_ReadFILEDblk(  MTF_DBLK_HDR_INFO  *psHdrInfo,
                         MTF_DBLK_FILE_INFO *psTapeInfo,  
                         BYTE               *pBuffer);    



/* ==================================================================================
     Corrupt File DBLK (CFIL)
================================================================================== */
typedef struct {
     UINT32              uCFileAttributes;
     UINT32              uDirectoryId;      /* Or CFIL Attributes                             ***/
     UINT32              uFileId;           /* Or reserved                                    ***/
     UINT64              uStreamOffset;
     UINT16              uCorruptStreamNumber;
} MTF_DBLK_CFIL_INFO;

void MTF_SetCFILDefaults(MTF_DBLK_CFIL_INFO *pCFILInfo);

DWORD MTF_WriteCFILDblk( MTF_DBLK_HDR_INFO  *psHdrInfo,
                         MTF_DBLK_CFIL_INFO *psTapeInfo,  
                         BYTE               *pBuffer,     
                         size_t              nBufferSize, 
                         size_t             *pnSizeUsed); 
                                                          
DWORD MTF_ReadCFILDblk(  MTF_DBLK_HDR_INFO  *psHdrInfo,
                         MTF_DBLK_CFIL_INFO *psTapeInfo,  
                         BYTE               *pBuffer);    


/* ==================================================================================
     End of Set Pad DBLK (ESPB)
================================================================================== */
DWORD MTF_WriteESPBDblk( MTF_DBLK_HDR_INFO  *psHdrInfo,
                         BYTE               *pBuffer,     
                         size_t              nBufferSize, 
                         size_t             *pnSizeUsed); 
                                                          
DWORD MTF_ReadESPBDblk(  MTF_DBLK_HDR_INFO  *psHdrInfo,
                         BYTE               *pBuffer);    



/* ==================================================================================
     End of Set DBLK (ESET)
================================================================================== */
typedef struct {
     UINT32              uESETAttributes;
     UINT32              uNumberOfCorrupFiles;
     UINT64              uSetMapPBA;
     UINT64              uFileDetailPBA;
     UINT16              uFDDTapeSequenceNumber;
     UINT16              uDataSetNumber;
     MTF_DATE_TIME       sMediaWriteDate;
} MTF_DBLK_ESET_INFO;

void MTF_SetESETDefaults(MTF_DBLK_ESET_INFO *pESETInfo);

DWORD MTF_WriteESETDblk( MTF_DBLK_HDR_INFO  *psHdrInfo,
                         MTF_DBLK_ESET_INFO *psTapeInfo,  
                         BYTE               *pBuffer,     
                         size_t              nBufferSize, 
                         size_t             *pnSizeUsed); 
                                                          
DWORD MTF_ReadESETDblk(  MTF_DBLK_HDR_INFO  *psHdrInfo,
                         MTF_DBLK_ESET_INFO *psTapeInfo,  
                         BYTE               *pBuffer);    


/* ==================================================================================
     End of Tape Media DBLK (EOTM)
================================================================================== */
typedef struct {
     UINT64              uLastESETPBA;
} MTF_DBLK_EOTM_INFO;

void MTF_SetEOTMDefaults(MTF_DBLK_EOTM_INFO *pEOTMInfo);

DWORD MTF_WriteEOTMDblk( MTF_DBLK_HDR_INFO  *psHdrInfo,
                         MTF_DBLK_EOTM_INFO *psTapeInfo,  
                         BYTE               *pBuffer,     
                         size_t              nBufferSize, 
                         size_t             *pnSizeUsed); 
                                                          
DWORD MTF_ReadEOTMDblk(  MTF_DBLK_HDR_INFO  *psHdrInfo,
                         MTF_DBLK_EOTM_INFO *psTapeInfo,  
                         BYTE               *pBuffer);    


/* ==================================================================================
     Soft Filemark DBLK (SFMB) - (bmd)
================================================================================== */
typedef struct {
     UINT32              uNumberOfFilemarkEntries;
     UINT32              uFilemarkEntriesUsed;
     UINT32              uFilemarkArray[1];
} MTF_DBLK_SFMB_INFO;

size_t MTF_GetMaxSoftFilemarkEntries(size_t nBlockSize);

void MTF_InsertSoftFilemark(MTF_DBLK_SFMB_INFO *psSoftInfo,
                            UINT32 pba);

DWORD MTF_WriteSFMBDblk(MTF_DBLK_HDR_INFO *psHdrInfo,
                        MTF_DBLK_SFMB_INFO *psSoftInfo,
                        BYTE *pBuffer,
                        size_t nBufferSize,
                        size_t *pnSizeUsed);

DWORD MTF_ReadSFMBDblk(MTF_DBLK_HDR_INFO *psHdrInfo,
                       MTF_DBLK_SFMB_INFO *psSoftInfo,
                       BYTE *pBuffer);

/* ==================================================================================
     STREAM 
================================================================================== */
typedef struct {
     UINT8               acStreamId[4];
     UINT16              uStreamFileSystemAttributes;
     UINT16              uStreamTapeFormatAttributes;
     UINT64              uStreamLength;
     UINT16              uDataEncryptionAlgorithm;
     UINT16              uDataCompressionAlgorithm;
     UINT16              uCheckSum;

} MTF_STREAM_INFO;

void MTF_SetSTREAMDefaults(MTF_STREAM_INFO *pSTREAMInfo, 
                           char            *szId);

void MTF_SetSTREAMFromStreamId( MTF_STREAM_INFO *pSTREAMInfo, 
                                WIN32_STREAM_ID *pStreamId, 
                                size_t           nIDHeaderSize);

void MTF_SetStreamIdFromSTREAM( WIN32_STREAM_ID *pStreamId,
                                MTF_STREAM_INFO *pSTREAMInfo, 
                                size_t           nIDHeaderSize);

DWORD MTF_WriteStreamHeader(MTF_STREAM_INFO *psStreamInfo,  
                         BYTE               *pBuffer,     
                         size_t              nBufferSize, 
                         size_t             *pnSizeUsed); 

DWORD MTF_WriteNameStream(char      *szType,
                          wchar_t   *szName,
                          BYTE      *pBuffer,
                          size_t     nBufferSize,
                          size_t    *pnSizeUsed);

DWORD MTF_ReadStreamHeader(  MTF_STREAM_INFO    *psStreamInfo,  
                             BYTE               *pBuffer);    

/* ==================================================================================
     Utilities 
================================================================================== */
void MTF_DBLK_HDR_INFO_ReadFromBuffer(
    MTF_DBLK_HDR_INFO *psHdrInfo, 
    BYTE              *pBuffer);

#pragma pack()

#ifdef __cplusplus
}
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\mover\server\mtf_api.c ===
//____________________________________________________________________________
//
// (C) Copyright Seagate Software, Inc. 1994-1996
//  1998 Seagate Software, Inc.  All rights reserved.
//
// All Rights Reserved Worldwide.
//
//____________________________________________________________________________
//
// FILE NAME :          mtf_api.c
//
// DESCRIPTION :        mtf api implementation 
//
// CREATED:             6/20/95
//
//____________________________________________________________________________
//
// $Revision:   1.35  $
//     $Date:   02 Feb 1995 15:47:04  $
//  $Modtime:   02 Feb 1995 15:37:38  $
//  
//____________________________________________________________________________
// *****************************************************************************/

#include <assert.h>
#include <time.h>
#include <string.h>
#include <wchar.h>

#include "mtf_api.h"

/***********************************************************************************
************************************************************************************
************************************************************************************
****  MTF API Static Data Structures and Housekeeping
************************************************************************************
************************************************************************************
***********************************************************************************/
// see below

static UINT16 s_uAlignmentFactor = 0;

static size_t Align(size_t uSize, size_t uAlignment);


// when the api formats it's own strings (i.e. file names from the WIN32_FIND_DATA,
// we need to keep those strings somewhere so we can set the pointers to them in 
// the info structs.  
#define STRLEN 256
static wchar_t s_szDeviceName[STRLEN];                     
static wchar_t s_szVolumeName[STRLEN];
static wchar_t s_szMachineName[MAX_COMPUTERNAME_LENGTH+1];
static wchar_t s_szDirectoryName[STRLEN];
static wchar_t s_szFileName[STRLEN];



/* ==================================================================================
     String Management
     When reading blocks, the strings are not null terminated -- we would like to 
     pull them out and deliver them back in the ####_INFO structures in a civilized
     (null terminated) way.  Thus, just set up an array of malloc'ec strings.  
     Each call that uses strings should first call "ClearStrings" -- strings returned
     to the user will only be good up until the next call...
================================================================================= */
#define iNUMSTRINGS 5

static wchar_t *s_aszStrings[iNUMSTRINGS] = {0};      // we keep an array of pointers to allocated strings
                                                      // this managed by ClearStrings() and MakeString()

static int      s_iNumStrings = 0;                    // the number of strings currently allocated


// - returns the size of a wchar_t string
//   and returns zero for a null pointer
static size_t wstrsize(wchar_t *s)
{
    if (s)
        return wcslen(s) * sizeof(wchar_t);
    else 
        return 0;
}


// - frees all allocated pointers in s_aszStrings and sets
//   s_iNumStrings to zero
static void ClearStrings()
{
    int i;
    for (i = 0; i < iNUMSTRINGS; ++i)
    {
        if (s_aszStrings[i])
            free(s_aszStrings[i]);         
        s_aszStrings[i] = 0;
    }

    s_iNumStrings = 0;
}


// - allocates a string in s_aszStrings that is a copy of pString
//   (pString need not be null terminated)
//   (note -- iSize is the size of the string in bytes -- not the length!!!!!
static wchar_t * MakeString(wchar_t * pString, size_t iSize)
{
    size_t i;
    assert(s_iNumStrings < iNUMSTRINGS);
    s_aszStrings[s_iNumStrings] = malloc(iSize + sizeof(wchar_t));
    if (!s_aszStrings[s_iNumStrings])
        return NULL;
    
    for (i = 0; i < iSize / sizeof(wchar_t); ++i)
        s_aszStrings[s_iNumStrings][i] = pString[i];
    
    s_aszStrings[s_iNumStrings][i] = L'\0';

    return s_aszStrings[s_iNumStrings++]; 
}


/* ==================================================================================
    Other static data structures
================================================================================= */

#pragma pack(1)

/***********************************************************************************
************************************************************************************
************************************************************************************
****  MTF On Tape Structures 
************************************************************************************
************************************************************************************
***********************************************************************************/

/* ==================================================================================
     Tape Address
================================================================================== */
typedef struct {
     UINT16 uSize;        /* Size of the data */
     UINT16 uOffset;      /* Offset to the data */
} MTF_TAPE_ADDRESS;

/* ==================================================================================
     Common DBLK Header
     - The common dblk header exactly as it appears on tape in the head of the dblks
================================================================================== */
typedef struct { 

     UINT8              acBlockType[4];         /* 00h  Unique identifier, see above            */
     UINT32             uBlockAttributes;       /* 04h  Common attributes for this block        */
     UINT16             uOffsetToFirstStream;   /* 08h  Offset to data associated with this     */
                                                /*      DBLK, or offset to next DBLK or         */
                                                /*      filemark if there is no associated      */
                                                /*      data.                                   */
     UINT8              uOSID;                  /* 0Ah  Machine/OS id where written, low byte   */
     UINT8              uOSVersion;             /* 0Bh  Machine/OS id where written, high byte  */
     UINT64             uDisplayableSize;       /* 0Ch  Displayable data size                   */
     UINT64             uFormatLogicalAddress;  /* 14h  Logical blk address relative to SSET    */
     UINT16             uReservedForMBC;        /* 1Ch  Reserved for Media Based Catalog        */
     UINT16             uSoftwareCompression;   /* 1Eh  Software Compression Algorithm        ***/
     UINT8              acReserved1[4];         /* 20h  reserved                                */
     UINT32             uControlBlockId;        /* 24h  Used for error recovery                 */
     UINT8              acReserved2[4];         /* 28h  reserved                                */
     MTF_TAPE_ADDRESS   sOSSpecificData;        /* 2Ch  Size and offset of OS specific stuff    */
     UINT8              uStringType;            /* 30h  ASCII, Unicode, etc.                    */
     UINT8              uReserved3;             /* 31h  for alignment purposes                  */
     UINT16             uHeaderCheckSum;        /* 32h  Checksum of the block header.  The      */
                                                /*      algorithm is: XOR each word preceeding  */
                                                /*      this one and store the result here.     */
                                                /*      (When the checksum is verified the      */
                                                /*      'block_type' is also checked for a      */
                                                /*      non-zero value.                         */
} MTF_DBLK_HDR;



/* ==================================================================================
     DBLK TAPE Header
     - The TAPE DBLK, exactly as it appears on tape, including the common DBLK header (MTF_DBLK_HDR)
================================================================================== */
typedef struct {    /* MTF_DBLK_TAPE */

     MTF_DBLK_HDR        sBlockHeader;
     UINT32              uTapeFamilyId;
     UINT32              uTapeAttributes;
     UINT16              uTapeSequenceNumber;
     UINT16              uPasswordEncryptionAlgorithm;
     UINT16              uSoftFilemarkBlockSize;         /* Or ECC Algorithm */
     UINT16              uTapeCatalogType;
     MTF_TAPE_ADDRESS    sTapeName;
     MTF_TAPE_ADDRESS    sTapeDescription;
     MTF_TAPE_ADDRESS    sTapePassword;
     MTF_TAPE_ADDRESS    sSoftware_name;
     UINT16              uAlignmentFactor;
     UINT16              uSoftwareVendorId;
     MTF_DATE_TIME       sTapeDate;
     UINT8               uMTFMajorVersion;

} MTF_DBLK_TAPE;



/* ==================================================================================
     Start of Set DBLK (SSET)
     - The SSET DBLK, exactly as it appears on tape, including the common DBLK header (MTF_DBLK_HDR)
================================================================================== */
typedef struct {
     MTF_DBLK_HDR        sBlockHeader;
     UINT32              uSSETAttributes;
     UINT16              uPasswordEncryptionAlgorithm;
     UINT16              uDataEncryptionAlgorithm;  /* Or Software Compression Algorithm      ***/
     UINT16              uSoftwareVendorId;
     UINT16              uDataSetNumber;
     MTF_TAPE_ADDRESS    sDataSetName;
     MTF_TAPE_ADDRESS    sDataSetDescription;
     MTF_TAPE_ADDRESS    sDataSetPassword;
     MTF_TAPE_ADDRESS    sUserName;
     UINT64              uPhysicalBlockAddress;
     MTF_DATE_TIME       sMediaWriteDate;
     UINT8               uSoftwareVerMjr;
     UINT8               uSoftwareVerMnr;
     UINT8               uTimeZone;
     UINT8               uMTFMinorVer;
     UINT8               uTapeCatalogVersion;
} MTF_DBLK_SSET;



/* ==================================================================================
     Volume DBLK (VOLB)
     - The VOLB DBLK, exactly as it appears on tape, including the common DBLK header (MTF_DBLK_HDR)
================================================================================== */
typedef struct {
     MTF_DBLK_HDR        sBlockHeader;
     UINT32              uVolumeAttributes;
     MTF_TAPE_ADDRESS    sDeviceName;
     MTF_TAPE_ADDRESS    sVolumeName;
     MTF_TAPE_ADDRESS    sMachineName;
     MTF_DATE_TIME       sMediaWriteDate;
} MTF_DBLK_VOLB;



/* ==================================================================================
     Directory DBLK (DIRB)
     - The DIRB DBLK, exactly as it appears on tape, including the common DBLK header (MTF_DBLK_HDR)
================================================================================== */
typedef struct {
     MTF_DBLK_HDR        sBlockHeader;
     UINT32              uDirectoryAttributes;
     MTF_DATE_TIME       sLastModificationDate;
     MTF_DATE_TIME       sCreationDate;
     MTF_DATE_TIME       sBackupDate;
     MTF_DATE_TIME       sLastAccessDate;
     UINT32              uDirectoryId;
     MTF_TAPE_ADDRESS    sDirectoryName;
} MTF_DBLK_DIRB;



/* ==================================================================================
     Directory DBLK (FILE)
     - The FILE DBLK, exactly as it appears on tape, including the common DBLK header (MTF_DBLK_HDR)
================================================================================== */
typedef struct {
     MTF_DBLK_HDR        sBlockHeader;
     UINT32              uFileAttributes;
     MTF_DATE_TIME       sLastModificationDate;
     MTF_DATE_TIME       sCreationDate;
     MTF_DATE_TIME       sBackupDate;
     MTF_DATE_TIME       sLastAccessDate;
     UINT32              uDirectoryId;
     UINT32              uFileId;
     MTF_TAPE_ADDRESS    sFileName;
} MTF_DBLK_FILE;


#pragma pack()

/* ==================================================================================
     Corrupt File DBLK (CFIL)
     - use MTF_DBLK_CFIL_INFO -- same structure
================================================================================== */
typedef MTF_DBLK_CFIL_INFO MTF_DBLK_CFIL;

/* ==================================================================================
     End of Set Pad Block (ESPB)
================================================================================== */
// consists only of header

/* ==================================================================================
     End of Set Block (ESET)
     - use MTF_DBLK_ESET_INFO -- same structure
================================================================================== */
typedef MTF_DBLK_ESET_INFO MTF_DBLK_ESET;

/* ==================================================================================
     End of Set Block (EOTM)
     - use MTF_DBLK_EOTM_INFO -- same structure
================================================================================== */
typedef MTF_DBLK_EOTM_INFO MTF_DBLK_EOTM;

/* ==================================================================================
     Soft Filemark (SFMB)
     - use MTF_DBLK_SFMB_INFO -- same structure
================================================================================== */
typedef MTF_DBLK_SFMB_INFO MTF_DBLK_SFMB;

/* ==================================================================================
     StreamHeader
     - use MTF_STREAM_INFO -- same structure
================================================================================== */
typedef MTF_STREAM_INFO MTF_STREAM;


/***********************************************************************************
************************************************************************************
************************************************************************************
****  MTF Misc Data Types
************************************************************************************
************************************************************************************
***********************************************************************************/
/* ==================================================================================
     Alignment Factor
================================================================================== */

/***********************************************************************************
* MTF_SetAlignmentFactor()                                 
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
void MTF_SetAlignmentFactor(UINT16 uAF)
{
    // store the user's alignment factor in a static variable
    s_uAlignmentFactor = uAF;
}




/***********************************************************************************
* MTF_GetAlignmentFactor()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
UINT16 MTF_GetAlignmentFactor()
{
    // make sure an alignment factor was stored,
    // and return it
    assert(s_uAlignmentFactor != 0);
    return s_uAlignmentFactor;
}




/***********************************************************************************
* MTF_PadToNextAlignmentFactor()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
DWORD MTF_PadToNextAlignmentFactor(
    BYTE     *pBuffer,    
    size_t    nBufUsed,
    size_t    nBufferSize, 
    size_t   *pnSizeUsed)
{
    size_t i;
    size_t nAlignment;
    MTF_STREAM_INFO sStream;
    
    // figure out what the next alignment value is and then pad out the user's buffer
    // with an SPAD, making sure the buffer is big enough

    nAlignment = Align(nBufUsed + sizeof(MTF_STREAM_INFO), MTF_GetAlignmentFactor());
    *pnSizeUsed = nAlignment;
    if (nBufferSize < nAlignment)
        return MTF_ERROR_BUFFER_TOO_SMALL;

    MTF_SetSTREAMDefaults(&sStream, "SPAD");
    
    sStream.uStreamLength = MTF_CreateUINT64(nAlignment - nBufUsed - sizeof(MTF_STREAM_INFO), 0);

    MTF_WriteStreamHeader(&sStream,
                          pBuffer + nBufUsed,
                          nBufferSize - nBufUsed,
                          0);

    for (i = nBufUsed + sizeof(MTF_STREAM_INFO); i < nAlignment; ++i)
        pBuffer[i] = 0;    

    return MTF_ERROR_NONE;
}     


/***********************************************************************************
* MTF_PadToNextPhysicalBlockBoundary() - (bmd)
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
DWORD MTF_PadToNextPhysicalBlockBoundary(
    BYTE *pBuffer,
    size_t nBlockSize,
    size_t nBufUsed,
    size_t nBufferSize,
    size_t *pnSizeUsed)
{
    size_t i;
    size_t nAlignment;
    MTF_STREAM_INFO sStream;

    // figure out what the next alignment value is and then pad out the user's buffer
    // with an SPAD, making sure the buffer is big enough

    nAlignment = Align(nBufUsed + sizeof(MTF_STREAM_INFO), nBlockSize);
    *pnSizeUsed = nAlignment;
    if (nBufferSize < nAlignment)
        return MTF_ERROR_BUFFER_TOO_SMALL;

    MTF_SetSTREAMDefaults(&sStream, "SPAD");

    sStream.uStreamLength = MTF_CreateUINT64(nAlignment - nBufUsed - sizeof(MTF_STREAM_INFO), 0);

    MTF_WriteStreamHeader(&sStream, pBuffer + nBufUsed, nBufferSize - nBufUsed, 0);

    for (i = nBufUsed + sizeof(MTF_STREAM_INFO); i < nAlignment; ++i)
        pBuffer[i] = 0;

    return MTF_ERROR_NONE;
}


/***********************************************************************************
* MTF_CreateUINT64()
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
UINT64 MTF_CreateUINT64(UINT32 uLSB, UINT32 uMSB)
{
    UINT64 uRet;

    uRet = (UINT64) uMSB << 32;
    uRet += uLSB;
    return uRet;
}


/* ==================================================================================
     Compressed date structure for storing dates in minimal space on tape:

     BYTE 0    BYTE 1    BYTE 2    BYTE 3    BYTE 4
    76543210  76543210  76543210  76543210  76543210
    yyyyyyyy  yyyyyymm  mmdddddh  hhhhmmmm  mmssssss
    33333333  33222222  22221111  11111100  00000000
    98765432  10987654  32109876  54321098  76543210
================================================================================== */

/***********************************************************************************
* MTF_CreateDateTime()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
MTF_DATE_TIME MTF_CreateDateTime(
    int iYear, 
    int iMonth, 
    int iDay, 
    int iHour, 
    int iMinute,
    int iSecond
    )
{
    MTF_DATE_TIME sDateTime = {0};

     UINT16    temp ;


    // pack the date time structure with the arguments as per the diagram above
      temp = iYear << 2 ;
      sDateTime.dt_field[0] = ((UINT8 *)&temp)[1] ;
      sDateTime.dt_field[1] = ((UINT8 *)&temp)[0] ;
      
      temp = iMonth << 6 ;
      sDateTime.dt_field[1] |= ((UINT8 *)&temp)[1] ;
      sDateTime.dt_field[2] = ((UINT8 *)&temp)[0] ;
      
      temp = iDay << 1 ;
      sDateTime.dt_field[2] |= ((UINT8 *)&temp)[0] ;
      
      temp = iHour << 4 ;
      sDateTime.dt_field[2] |= ((UINT8 *)&temp)[1] ;
      sDateTime.dt_field[3] = ((UINT8 *)&temp)[0] ;
      
      temp = iMinute << 6 ;
      sDateTime.dt_field[3] |= ((UINT8 *)&temp)[1] ;
      sDateTime.dt_field[4] = ((UINT8 *)&temp)[0] ;
      
      temp = (UINT16)iSecond ;
      sDateTime.dt_field[4] |= ((UINT8 *)&temp)[0] ;

    return sDateTime;    
}





/***********************************************************************************
* MTF_CreateDateTimeFromTM()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
MTF_DATE_TIME MTF_CreateDateTimeFromTM(
    struct tm *pT
    )
{
    // translate call to MTF_CreateDateTime
    return MTF_CreateDateTime(pT->tm_year + 1900, pT->tm_mon + 1, pT->tm_mday, pT->tm_hour, pT->tm_min, pT->tm_sec);
}





/***********************************************************************************
* MTF_CreateDateTimeToTM()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
void MTF_CreateDateTimeToTM(
    MTF_DATE_TIME *pDT, 
    struct tm     *pT
    )
{
     UINT8     temp[2] ;

    // unpack the MTF_DATE_TIME structure and store the results
     temp[0] = pDT->dt_field[1] ;
     temp[1] = pDT->dt_field[0] ;
     pT->tm_year = *((UINT16 *)temp) >> 2 ;

     temp[0] = pDT->dt_field[2] ;
     temp[1] = pDT->dt_field[1] ;
     pT->tm_mon = (*((UINT16 *)temp) >> 6) & 0x000F ;

     pT->tm_mday = (*((UINT16 *)temp) >> 1) & 0x001F ;

     temp[0] = pDT->dt_field[3] ;
     temp[1] = pDT->dt_field[2] ;
     pT->tm_hour = (*((UINT16 *)temp) >> 4) & 0x001F ;

     temp[0] = pDT->dt_field[4] ;
     temp[1] = pDT->dt_field[3] ;
     pT->tm_min = (*((UINT16 *)temp) >> 6) & 0x003F ;

     pT->tm_sec = *((UINT16 *)temp) & 0x003F ;
}




/***********************************************************************************
* MTF_CreateDateNull()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
MTF_DATE_TIME MTF_CreateDateNull()
{
    MTF_DATE_TIME sDateTime = {0};
    
    return sDateTime;    
}




/***********************************************************************************
* MTF_CreateDateTimeFromFileTime()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
MTF_DATE_TIME MTF_CreateDateTimeFromFileTime(
    FILETIME sFileTime
    )
{
    SYSTEMTIME sSystemTime;
    FileTimeToSystemTime(&sFileTime, &sSystemTime);

    return MTF_CreateDateTime(sSystemTime.wYear, 
                              sSystemTime.wMonth, 
                              sSystemTime.wDay, 
                              sSystemTime.wHour, 
                              sSystemTime.wMinute, 
                              sSystemTime.wSecond);
}





/***********************************************************************************
************************************************************************************
****  MTF static HELPER FUNCITONS
************************************************************************************
***********************************************************************************/

/***********************************************************************************
* StringToTapeAddress()
*
* Description:  Used by the MTF_Write#### functions below.  Given a Buffer, an 
*               MTF_TAPE_ADDRESS struct and the current end of the string storage 
*               area in the buffer, this function appends the string to the string
*               storage area, fills in the MTF_TAPE_ADDRESS struct indicating where
*               the string was stored and returns the new end of the string storage
*               area accounting for the added string.
***********************************************************************************/
static size_t StringToTapeAddress(
    MTF_TAPE_ADDRESS *pAd,                  // the mtf tape address structure to fill
    BYTE             *pBuffer,              // the buffer that is being filled
    wchar_t          *str,                  // the string to store MTF style in the buffer
    size_t           uCurrentStorageOffset  // the next available point in the buffer for string storage
    )
{
    // if we have a string, 
    //      - put the size and offset in the MTF_TAPE_ADDRESS structure and then copy 
    //        the string to the pBuffer at the uCurrentStorageOffset'th byte
    // otherwise
    //      - put a zero size and offset in the MTF_TAPE_ADDRESS struct.
    // return the new end of the string storage area
    
    if (str)
    {
        pAd->uSize   = (UINT16)wstrsize(str);
        pAd->uOffset = (UINT16)uCurrentStorageOffset;
        memcpy(pBuffer + uCurrentStorageOffset, str, pAd->uSize);
        uCurrentStorageOffset += pAd->uSize;
    }
    else
    {
        pAd->uSize   = 0;
        pAd->uOffset = 0;
    }
    
    return uCurrentStorageOffset;
}



/***********************************************************************************
* Align()
*
* Description:  Given uSize and an alignment factor, retuns the value
*               of the uSize+ pad, where pad is the value necesary to 
*               get to the next alignment factor.
*               
* Returns       uSize + pad -- not just pad!
***********************************************************************************/
static size_t Align(
    size_t uSize, 
    size_t uAlignment)
{
    if (uSize % uAlignment)    
        return uSize - (uSize  % uAlignment) + uAlignment;
    else
        return uSize;
}




/***********************************************************************************
* CalcChecksum()
*
* Description:  returns the 16bit XOR sum of the nNum bytes starting at the UINT16
*               pointed to by pStartPtr
*               
***********************************************************************************/
static UINT16 CalcChecksum(
     BYTE *      pStartPtr,
     int         nNum )
{
     UINT16 resultSoFar = 0;
     UINT16 *pCur = (UINT16 *) pStartPtr;
     
     while( nNum-- ) 
          resultSoFar ^= *pCur++ ;

     return( resultSoFar ) ;
}




/***********************************************************************************
* CalcChecksumOfStreamData() - (bmd)
*
* Description:  returns the 32bit XOR sum of the nNum bytes starting at the UINT64
*               pointed to by pStartPtr
*               
***********************************************************************************/
static UINT32 CalcChecksumOfStreamData(
     BYTE *      pStartPtr,
     int         nNum )
{
     UINT32 resultSoFar = 0;
     UINT32 *pCur = (UINT32 *) pStartPtr;
     
     while( nNum-- ) 
          resultSoFar ^= *pCur++ ;

     return( resultSoFar ) ;
}


     
/***********************************************************************************
************************************************************************************
************************************************************************************
****  MTF API STRUCTURE FUNCTIONS
************************************************************************************
************************************************************************************
***********************************************************************************/

/* ==================================================================================
=====================================================================================
     Common DBLK: MTF_DBLK_HDR_INFO
=====================================================================================
================================================================================== */

// Calculates the room that will be taken up in the DBLK by strings and OS specific data
static size_t MTF_DBLK_HDR_INFO_CalcAddDataSize(
    MTF_DBLK_HDR_INFO *pSTDInfo
    )
{
    return pSTDInfo->uOSDataSize;
}




/***********************************************************************************
* MTF_SetDblkHdrDefaults()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
void MTF_SetDblkHdrDefaults(
    MTF_DBLK_HDR_INFO * pStdInfo
    )
{
    int i;
    for (i = 0; i < 5; ++i)
        pStdInfo->acBlockType[i] = 0;

    pStdInfo->uBlockAttributes      = 0;
    pStdInfo->uOSID                 = 0;
    pStdInfo->uOSVersion            = 0;
    pStdInfo->uDisplayableSize      = 0;
    pStdInfo->uFormatLogicalAddress = 0;
    pStdInfo->uReservedForMBC       = 0;
    pStdInfo->uSoftwareCompression  = MTF_COMPRESS_NONE;
    pStdInfo->uControlBlockId       = 0;
    pStdInfo->pvOSData              = 0;
    pStdInfo->uOSDataSize           = 0;
    pStdInfo->uStringType           = MTF_STRING_UNICODE_STR; 
}




/***********************************************************************************
* MTF_WriteDblkHdrToBuffer()
*
* Description:  called by the MTF_Write#####() functions to format the common block 
*               header to the buffer
*               - this also calculates the header check sum and fills it in
*
* Pre:  - *puCurrentStorageOffset is the offset at where string and OS Data storage will 
*         begin in the buffer
*       - the size of the buffer has been checked and can hold any info written to it
*
* Post: - *puCurrentStorageOffset is updated to reflect any added strings or storage
*               
***********************************************************************************/
static void MTF_WriteDblkHdrToBuffer(
    UINT8              acID[4],                 // four byte header id to write
    UINT16             uOffsetToFirstStream,    // the size of the DBLK for which this will be a header
    MTF_DBLK_HDR_INFO *psHdrInfo,               // the header info struct to use (filled in by client)
    BYTE              *pBuffer,                 // the buffer to format to
    size_t            *puCurrentStorage)        // the point in the buffer where string and os data stroage begins
                                                // (this will be updated upon return to reflect added data to storage)
{
    MTF_DBLK_HDR *pHDR = 0;
    UINT16 uCurrentStorageOffset = 0;
    int i;

    // - if no *puCurrentStorage, we assume storage starts at 
    //   the end of the on tape MTF_DBLK_HDR structure
    if (puCurrentStorage)
        uCurrentStorageOffset = (UINT16)*puCurrentStorage;
    else
        uCurrentStorageOffset = (UINT16)sizeof(MTF_DBLK_HDR);

    pHDR = (MTF_DBLK_HDR *) pBuffer;
    
    // write in the four byte DBLK ID
    for (i = 0; i < 4; ++i)
        pHDR->acBlockType[i] = acID[i];

    pHDR->uBlockAttributes      = psHdrInfo->uBlockAttributes;
    pHDR->uOffsetToFirstStream  = uOffsetToFirstStream;
    pHDR->uOSID                 = psHdrInfo->uOSID;
    pHDR->uOSVersion            = psHdrInfo->uOSVersion;
    pHDR->uDisplayableSize      = psHdrInfo->uDisplayableSize;
    pHDR->uFormatLogicalAddress = psHdrInfo->uFormatLogicalAddress;
    pHDR->uReservedForMBC       = 0; // must be zero in backup set
    pHDR->uSoftwareCompression  = psHdrInfo->uSoftwareCompression;
    pHDR->uControlBlockId       = psHdrInfo->uControlBlockId;
    pHDR->sOSSpecificData.uSize = psHdrInfo->uOSDataSize;

    // write out the os specific data at the current storage offset and update it
    if (psHdrInfo->uOSDataSize)
    {
        pHDR->sOSSpecificData.uOffset = uCurrentStorageOffset;
        memcpy(pBuffer + uCurrentStorageOffset, psHdrInfo->pvOSData, psHdrInfo->uOSDataSize);
        uCurrentStorageOffset += psHdrInfo->uOSDataSize;
    }
    else
    {
        pHDR->sOSSpecificData.uOffset = 0;
        pHDR->sOSSpecificData.uSize   = 0;
    }

    pHDR->uStringType = psHdrInfo->uStringType;
    
    pHDR->uHeaderCheckSum = CalcChecksum(pBuffer, sizeof(MTF_DBLK_HDR) / sizeof(UINT16) - 1);
    
    if (puCurrentStorage)
        *puCurrentStorage = uCurrentStorageOffset;
}




void MTF_DBLK_HDR_INFO_ReadFromBuffer(
    MTF_DBLK_HDR_INFO *psHdrInfo, 
    BYTE              *pBuffer)
{
    MTF_DBLK_HDR *pHDR = 0;
    size_t uCurrentStorageOffset = 0;
    int i;

    pHDR = (MTF_DBLK_HDR *) pBuffer;
    
    for (i = 0; i < 4; ++i)
        psHdrInfo->acBlockType[i] = pHDR->acBlockType[i];
    
    psHdrInfo->acBlockType[4] = 0;

    psHdrInfo->uOffsetToFirstStream = pHDR->uOffsetToFirstStream;
    psHdrInfo->uBlockAttributes     = pHDR->uBlockAttributes ;
    psHdrInfo->uOSID                = pHDR->uOSID;
    psHdrInfo->uOSVersion           = pHDR->uOSVersion;
    psHdrInfo->uDisplayableSize     = pHDR->uDisplayableSize;
    psHdrInfo->uFormatLogicalAddress= pHDR->uFormatLogicalAddress;
    psHdrInfo->uSoftwareCompression = pHDR->uSoftwareCompression;
    psHdrInfo->uControlBlockId      = pHDR->uControlBlockId;
    psHdrInfo->uOSDataSize          = pHDR->sOSSpecificData.uSize;
    psHdrInfo->pvOSData             = (pBuffer + pHDR->sOSSpecificData.uOffset);
    psHdrInfo->uStringType          = pHDR->uStringType;
    psHdrInfo->uHeaderCheckSum      = pHDR->uHeaderCheckSum;
}




/* ==================================================================================
=====================================================================================
     TAPE DBLK: MTF_DBLK_TAPE_INFO
=====================================================================================
================================================================================== */
// Calculates the room that will be taken up in the DBLK by strings and OS specific data
// **NOT INCLUDING THE COMMON DBLK HEADER additional info **
static size_t MTF_DBLK_TAPE_INFO_CalcAddDataSize(
    MTF_DBLK_TAPE_INFO *pTapeInfo
    )
{
    return wstrsize(pTapeInfo->szTapeName) +
           wstrsize(pTapeInfo->szTapeDescription) +
           wstrsize(pTapeInfo->szTapePassword) +
           wstrsize(pTapeInfo->szSoftwareName);
}



/***********************************************************************************
* MTF_SetTAPEDefaults()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
void MTF_SetTAPEDefaults(
    MTF_DBLK_TAPE_INFO *pTapeInfo
    )
{
    time_t tTime;
    time(&tTime);

    pTapeInfo->uTapeFamilyId                = 0;
    pTapeInfo->uTapeAttributes              = 0;
    pTapeInfo->uTapeSequenceNumber          = 0;
    pTapeInfo->uPasswordEncryptionAlgorithm = MTF_PW_ENCRYPT_NONE;
    pTapeInfo->uSoftFilemarkBlockSize       = 0;
    pTapeInfo->uTapeCatalogType             = MTF_OTC_NONE; // MTF_OTC_TYPE
    pTapeInfo->szTapeName                   = 0 ;
    pTapeInfo->szTapeDescription            = 0 ;
    pTapeInfo->szTapePassword               = 0;
    pTapeInfo->szSoftwareName               = 0;
    pTapeInfo->uAlignmentFactor             = MTF_GetAlignmentFactor();
    pTapeInfo->uSoftwareVendorId            = 0;
    pTapeInfo->sTapeDate                    = MTF_CreateDateTimeFromTM(gmtime(&tTime));
    pTapeInfo->uMTFMajorVersion             = MTF_FORMAT_VER_MAJOR;
}



/***********************************************************************************
* MTF_WriteTAPEDblk()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
DWORD MTF_WriteTAPEDblk( MTF_DBLK_HDR_INFO  *psHdrInfo,
                         MTF_DBLK_TAPE_INFO *psTapeInfo,  
                         BYTE               *pBuffer,     
                         size_t              nBufferSize, 
                         size_t             *pnSizeUsed)  
{
    UINT16 uOffsetToFirstStream;
    
    //
    // Figure the size of the entire DBLK & make sure we have room
    //
    uOffsetToFirstStream = sizeof(MTF_DBLK_TAPE) + 
                           MTF_DBLK_HDR_INFO_CalcAddDataSize(psHdrInfo) + 
                           MTF_DBLK_TAPE_INFO_CalcAddDataSize(psTapeInfo);

    uOffsetToFirstStream = (UINT16)Align(uOffsetToFirstStream, 4);

    if (nBufferSize < uOffsetToFirstStream)
    {
        if (pnSizeUsed)
            *pnSizeUsed = uOffsetToFirstStream;
        
        return MTF_ERROR_BUFFER_TOO_SMALL;                        
    }    

    memset(pBuffer, 0, uOffsetToFirstStream);
    
    
    // 
    // write the header and then fill in the stuff from this info struct
    //
    {
        MTF_DBLK_TAPE *pTape = 0;
        size_t uCurrentStorageOffset = 0;

        uCurrentStorageOffset = sizeof(MTF_DBLK_TAPE);

        MTF_WriteDblkHdrToBuffer(
            MTF_ID_TAPE, 
            uOffsetToFirstStream,
            psHdrInfo, 
            pBuffer, 
            &uCurrentStorageOffset);
        
        pTape = (MTF_DBLK_TAPE *) pBuffer;
    
        pTape->uTapeFamilyId                = psTapeInfo->uTapeFamilyId;
        pTape->uTapeAttributes              = psTapeInfo->uTapeAttributes;
        pTape->uTapeSequenceNumber          = psTapeInfo->uTapeSequenceNumber;
        pTape->uPasswordEncryptionAlgorithm = psTapeInfo->uPasswordEncryptionAlgorithm;
        pTape->uSoftFilemarkBlockSize       = psTapeInfo->uSoftFilemarkBlockSize;
        pTape->uTapeCatalogType             = psTapeInfo->uTapeCatalogType;

        uCurrentStorageOffset = StringToTapeAddress(&pTape->sTapeName, pBuffer, psTapeInfo->szTapeName, uCurrentStorageOffset);
        uCurrentStorageOffset = StringToTapeAddress(&pTape->sTapeDescription, pBuffer, psTapeInfo->szTapeDescription, uCurrentStorageOffset);
        uCurrentStorageOffset = StringToTapeAddress(&pTape->sTapePassword, pBuffer, psTapeInfo->szTapePassword, uCurrentStorageOffset);
        uCurrentStorageOffset = StringToTapeAddress(&pTape->sSoftware_name, pBuffer, psTapeInfo->szSoftwareName, uCurrentStorageOffset);

        pTape->uAlignmentFactor  = psTapeInfo->uAlignmentFactor;
        pTape->uSoftwareVendorId = psTapeInfo->uSoftwareVendorId;
        pTape->sTapeDate         = psTapeInfo->sTapeDate;
        pTape->uMTFMajorVersion  = psTapeInfo->uMTFMajorVersion;
      
        if (pnSizeUsed)
            *pnSizeUsed = uOffsetToFirstStream;
    }

    return MTF_ERROR_NONE;    
}






/***********************************************************************************
* MTF_ReadTAPEDblk()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
DWORD MTF_ReadTAPEDblk(  MTF_DBLK_HDR_INFO  *psHdrInfo,
                         MTF_DBLK_TAPE_INFO *psTapeInfo,  
                         BYTE               *pBuffer)     
{
    MTF_DBLK_TAPE *pTape = 0;

    ClearStrings();
    MTF_DBLK_HDR_INFO_ReadFromBuffer(psHdrInfo, pBuffer);

    pTape = (MTF_DBLK_TAPE *) pBuffer;

    psTapeInfo->uTapeFamilyId                = pTape->uTapeFamilyId;
    psTapeInfo->uTapeAttributes              = pTape->uTapeAttributes;
    psTapeInfo->uTapeSequenceNumber          = pTape->uTapeSequenceNumber;
    psTapeInfo->uPasswordEncryptionAlgorithm = pTape->uPasswordEncryptionAlgorithm;
    psTapeInfo->uSoftFilemarkBlockSize       = pTape->uSoftFilemarkBlockSize;
    psTapeInfo->uTapeCatalogType             = pTape->uTapeCatalogType;

    psTapeInfo->uAlignmentFactor  = pTape->uAlignmentFactor;
    psTapeInfo->uSoftwareVendorId = pTape->uSoftwareVendorId;
    psTapeInfo->sTapeDate         = pTape->sTapeDate;
    psTapeInfo->uMTFMajorVersion  = pTape->uMTFMajorVersion;

    psTapeInfo->szTapeName        = MakeString((wchar_t *) (pBuffer + pTape->sTapeName.uOffset), pTape->sTapeName.uSize);
    psTapeInfo->szTapeDescription = MakeString((wchar_t *) (pBuffer + pTape->sTapeDescription.uOffset), pTape->sTapeDescription.uSize);
    psTapeInfo->szTapePassword    = MakeString((wchar_t *) (pBuffer + pTape->sTapePassword.uOffset), pTape->sTapePassword.uSize);
    psTapeInfo->szSoftwareName    = MakeString((wchar_t *) (pBuffer + pTape->sSoftware_name.uOffset), pTape->sSoftware_name.uSize);

    if ( !psTapeInfo->szTapeName || !psTapeInfo->szTapeDescription || !psTapeInfo->szTapePassword || !psTapeInfo->szSoftwareName)
        return MTF_OUT_OF_MEMORY;

    return MTF_ERROR_NONE;    
}



    
/* ==================================================================================
=====================================================================================
     SSET DBLK: MTF_DBLK_SSET_INFO
=====================================================================================
================================================================================== */

// Calculates the room that will be taken up in the DBLK by strings and OS specific data
// **NOT INCLUDING THE COMMON DBLK HEADER additional info **
static size_t MTF_DBLK_SSET_INFO_CalcAddDataSize(
    MTF_DBLK_SSET_INFO *pSSETInfo
    )
{
    return wstrsize(pSSETInfo->szDataSetName)         
           + wstrsize(pSSETInfo->szDataSetDescription)  
           + wstrsize(pSSETInfo->szDataSetPassword)     
           + wstrsize(pSSETInfo->szUserName);
}




/***********************************************************************************
* MTF_SetSSETDefaults()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
void MTF_SetSSETDefaults(
    MTF_DBLK_SSET_INFO *pSSETInfo
    )
{
    time_t tTime;
    time(&tTime);

    pSSETInfo->uSSETAttributes              = 0;
    pSSETInfo->uPasswordEncryptionAlgorithm = MTF_PW_ENCRYPT_NONE;
    pSSETInfo->uDataEncryptionAlgorithm     = MTF_DATA_ENCRYPT_NONE;
    pSSETInfo->uSoftwareVendorId            = 0;
    pSSETInfo->uDataSetNumber               = 0;
    pSSETInfo->szDataSetName                = 0 ;
    pSSETInfo->szDataSetDescription         = 0 ;
    pSSETInfo->szDataSetPassword            = 0 ;
    pSSETInfo->szUserName                   = 0 ;
    pSSETInfo->uPhysicalBlockAddress        = 0;
    pSSETInfo->sMediaWriteDate              = MTF_CreateDateTimeFromTM(gmtime(&tTime));
    pSSETInfo->uSoftwareVerMjr              = 0;
    pSSETInfo->uSoftwareVerMnr              = 0;
    pSSETInfo->uTimeZone                    = MTF_LOCAL_TZ;
    pSSETInfo->uMTFMinorVer                 = MTF_FORMAT_VER_MINOR;
    pSSETInfo->uTapeCatalogVersion          = MTF_OTC_NONE;  // MTF_OTC_VERSION
}




/***********************************************************************************
* MTF_WriteSSETDblk()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
DWORD MTF_WriteSSETDblk( MTF_DBLK_HDR_INFO  *psHdrInfo,
                         MTF_DBLK_SSET_INFO *psSSETInfo,  
                         BYTE               *pBuffer,     
                         size_t              nBufferSize, 
                         size_t             *pnSizeUsed)  
{
    UINT16 uOffsetToFirstStream;
    
    //
    // Figure the size of the entire DBLK & make sure we have room
    //
    uOffsetToFirstStream = sizeof(MTF_DBLK_SSET) +
                           MTF_DBLK_HDR_INFO_CalcAddDataSize(psHdrInfo) +
                           MTF_DBLK_SSET_INFO_CalcAddDataSize(psSSETInfo);

    uOffsetToFirstStream = (UINT16)Align(uOffsetToFirstStream, 4);

    if (nBufferSize < uOffsetToFirstStream)
    {
        if (pnSizeUsed)
            *pnSizeUsed = uOffsetToFirstStream;
        
        return MTF_ERROR_BUFFER_TOO_SMALL;                        
    }    

    memset(pBuffer, 0, uOffsetToFirstStream);
    
    {
        MTF_DBLK_SSET *psSSET = 0;
        size_t uCurrentStorageOffset = 0;

        uCurrentStorageOffset = sizeof(MTF_DBLK_SSET);

        MTF_WriteDblkHdrToBuffer(
            MTF_ID_SSET, 
            uOffsetToFirstStream,
            psHdrInfo, 
            pBuffer, 
            &uCurrentStorageOffset);
        
        psSSET = (MTF_DBLK_SSET *) pBuffer;

        psSSET->uSSETAttributes              = psSSETInfo->uSSETAttributes;
        psSSET->uPasswordEncryptionAlgorithm = psSSETInfo->uPasswordEncryptionAlgorithm;
        psSSET->uDataEncryptionAlgorithm     = psSSETInfo->uDataEncryptionAlgorithm;
        psSSET->uSoftwareVendorId            = psSSETInfo->uSoftwareVendorId;
        psSSET->uDataSetNumber               = psSSETInfo->uDataSetNumber;

        uCurrentStorageOffset = StringToTapeAddress(&psSSET->sDataSetName, pBuffer, psSSETInfo->szDataSetName, uCurrentStorageOffset);
        uCurrentStorageOffset = StringToTapeAddress(&psSSET->sDataSetDescription, pBuffer, psSSETInfo->szDataSetDescription, uCurrentStorageOffset);
        uCurrentStorageOffset = StringToTapeAddress(&psSSET->sDataSetPassword, pBuffer, psSSETInfo->szDataSetPassword, uCurrentStorageOffset);
        uCurrentStorageOffset = StringToTapeAddress(&psSSET->sUserName, pBuffer, psSSETInfo->szUserName, uCurrentStorageOffset);

        psSSET->uPhysicalBlockAddress = psSSETInfo->uPhysicalBlockAddress;
        psSSET->sMediaWriteDate       = psSSETInfo->sMediaWriteDate;
        psSSET->uSoftwareVerMjr       = psSSETInfo->uSoftwareVerMjr;
        psSSET->uSoftwareVerMnr       = psSSETInfo->uSoftwareVerMnr;
        psSSET->uTimeZone             = psSSETInfo->uTimeZone;
        psSSET->uMTFMinorVer          = psSSETInfo->uMTFMinorVer;
        psSSET->uTapeCatalogVersion   = psSSETInfo->uTapeCatalogVersion;

        if (pnSizeUsed)
            *pnSizeUsed = uOffsetToFirstStream;
    }

    return MTF_ERROR_NONE;    
}




/***********************************************************************************
* MTF_ReadSSETDblk()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
DWORD MTF_ReadSSETDblk(  MTF_DBLK_HDR_INFO  *psHdrInfo,
                         MTF_DBLK_SSET_INFO *psSSETInfo,  
                         BYTE               *pBuffer)     
{
    MTF_DBLK_SSET *psSSET = 0;

    ClearStrings();
    MTF_DBLK_HDR_INFO_ReadFromBuffer(psHdrInfo, pBuffer);

    psSSET = (MTF_DBLK_SSET *) pBuffer;

    psSSETInfo->uSSETAttributes              = psSSET->uSSETAttributes;
    psSSETInfo->uPasswordEncryptionAlgorithm = psSSET->uPasswordEncryptionAlgorithm;
    psSSETInfo->uDataEncryptionAlgorithm     = psSSET->uDataEncryptionAlgorithm;
    psSSETInfo->uSoftwareVendorId            = psSSET->uSoftwareVendorId;
    psSSETInfo->uDataSetNumber               = psSSET->uDataSetNumber;

    psSSETInfo->uPhysicalBlockAddress   = psSSET->uPhysicalBlockAddress;
    psSSETInfo->sMediaWriteDate         = psSSET->sMediaWriteDate;
    psSSETInfo->uSoftwareVerMjr         = psSSET->uSoftwareVerMjr;
    psSSETInfo->uSoftwareVerMnr         = psSSET->uSoftwareVerMnr;
    psSSETInfo->uTimeZone               = psSSET->uTimeZone;
    psSSETInfo->uMTFMinorVer            = psSSET->uMTFMinorVer;
    psSSETInfo->uTapeCatalogVersion     = psSSET->uTapeCatalogVersion;

    psSSETInfo->szDataSetName = MakeString((wchar_t *) (pBuffer + psSSET->sDataSetName.uOffset), psSSET->sDataSetName.uSize);
    psSSETInfo->szDataSetDescription = MakeString((wchar_t *) (pBuffer + psSSET->sDataSetDescription.uOffset), psSSET->sDataSetDescription.uSize);
    psSSETInfo->szDataSetPassword = MakeString((wchar_t *) (pBuffer + psSSET->sDataSetPassword.uOffset), psSSET->sDataSetPassword.uSize);
    psSSETInfo->szUserName = MakeString((wchar_t *) (pBuffer + psSSET->sUserName.uOffset), psSSET->sUserName.uSize);

    if ( !psSSETInfo->szDataSetName || !psSSETInfo->szDataSetDescription || !psSSETInfo->szDataSetPassword || !psSSETInfo->szUserName )
        return MTF_OUT_OF_MEMORY;

    return MTF_ERROR_NONE;    
}




/* ==================================================================================
=====================================================================================
     VOLB DBLK: MTF_DBLK_VOLB_INFO
=====================================================================================
================================================================================== */

// Calculates the room that will be taken up in the DBLK by strings and OS specific data
// **NOT INCLUDING THE COMMON DBLK HEADER additional info **
static size_t MTF_DBLK_VOLB_INFO_CalcAddDataSize(
    MTF_DBLK_VOLB_INFO *pVOLBInfo
    )
{
    return wstrsize(pVOLBInfo->szDeviceName) +
           wstrsize(pVOLBInfo->szVolumeName) +
           wstrsize(pVOLBInfo->szMachineName);
}




/***********************************************************************************
* MTF_SetVOLBDefaults()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
void MTF_SetVOLBDefaults(MTF_DBLK_VOLB_INFO *pVOLBInfo)
{
    time_t tTime;
    time(&tTime);

    pVOLBInfo->uVolumeAttributes = 0;
    pVOLBInfo->szDeviceName      = 0 ;
    pVOLBInfo->szVolumeName      = 0 ;
    pVOLBInfo->szMachineName     = 0 ;
    pVOLBInfo->sMediaWriteDate   = MTF_CreateDateTimeFromTM(gmtime(&tTime));;
}




/***********************************************************************************
* MTF_SetVOLBForDevice()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
void MTF_SetVOLBForDevice(MTF_DBLK_VOLB_INFO *pVOLBInfo, wchar_t *szDevice)
{
    int nBufSize = MAX_COMPUTERNAME_LENGTH + 1;
    wchar_t tempDeviceName[STRLEN+4];

    wcscpy(s_szDeviceName, szDevice);
    MTF_SetVOLBDefaults(pVOLBInfo);  // initialize

    // Determine the format and set the appropriate bit in the VOLB attributes.
    if (*(s_szDeviceName+1) == L':') {
        // drive letter w/colon format
        pVOLBInfo->uVolumeAttributes |= MTF_VOLB_DEV_DRIVE;
    }
    else if (0 == wcsncmp( s_szDeviceName, L"UNC", 3 )) {
        // UNC format
        pVOLBInfo->uVolumeAttributes |= MTF_VOLB_DEV_UNC;
    }
    else {
        // operating system specific format
        pVOLBInfo->uVolumeAttributes |= MTF_VOLB_DEV_OS_SPEC;
    }

    // need to prepend \\?\ for the GetVolumeInformation call
    wcscpy(tempDeviceName, L"\\\\?\\");
    wcscat(tempDeviceName, s_szDeviceName);

    GetVolumeInformationW(tempDeviceName, s_szVolumeName, STRLEN, 0, 0, 0, 0, 0);
    GetComputerNameW(s_szMachineName, &nBufSize);
    
    pVOLBInfo->szDeviceName         = s_szDeviceName;
    pVOLBInfo->szVolumeName         = s_szVolumeName;
    pVOLBInfo->szMachineName        = s_szMachineName;
}




/***********************************************************************************
* MTF_WriteVOLBDblk()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
DWORD MTF_WriteVOLBDblk( MTF_DBLK_HDR_INFO  *psHdrInfo,
                         MTF_DBLK_VOLB_INFO *psVOLBInfo,  
                         BYTE               *pBuffer,     
                         size_t              nBufferSize, 
                         size_t             *pnSizeUsed)  
{
    UINT16 uOffsetToFirstStream;
    
    //
    // Figure the size of the entire DBLK & make sure we have room
    //
    uOffsetToFirstStream = sizeof(MTF_DBLK_VOLB) + 
                           MTF_DBLK_HDR_INFO_CalcAddDataSize(psHdrInfo) + 
                           MTF_DBLK_VOLB_INFO_CalcAddDataSize(psVOLBInfo);


    uOffsetToFirstStream = (UINT16)Align(uOffsetToFirstStream, 4);

    if (nBufferSize < uOffsetToFirstStream)
    {
        if (pnSizeUsed)
            *pnSizeUsed = uOffsetToFirstStream;
        
        return MTF_ERROR_BUFFER_TOO_SMALL;
    }

    memset(pBuffer, 0, uOffsetToFirstStream);
    
    {
        MTF_DBLK_VOLB *psVOLB = 0;
        size_t uCurrentStorageOffset = 0;

        uCurrentStorageOffset = sizeof(MTF_DBLK_VOLB);

        MTF_WriteDblkHdrToBuffer(
            MTF_ID_VOLB, 
            uOffsetToFirstStream,
            psHdrInfo, 
            pBuffer, 
            &uCurrentStorageOffset);
        
        psVOLB = (MTF_DBLK_VOLB *) pBuffer;

        psVOLB->uVolumeAttributes = psVOLBInfo->uVolumeAttributes;

        uCurrentStorageOffset = StringToTapeAddress(&psVOLB->sDeviceName, pBuffer, psVOLBInfo->szDeviceName, uCurrentStorageOffset);
        uCurrentStorageOffset = StringToTapeAddress(&psVOLB->sVolumeName, pBuffer, psVOLBInfo->szVolumeName, uCurrentStorageOffset);
        uCurrentStorageOffset = StringToTapeAddress(&psVOLB->sMachineName, pBuffer, psVOLBInfo->szMachineName, uCurrentStorageOffset);

        psVOLB->sMediaWriteDate = psVOLBInfo->sMediaWriteDate;

        if (pnSizeUsed)
            *pnSizeUsed = uOffsetToFirstStream;
    }

    return MTF_ERROR_NONE;    
}





/***********************************************************************************
* MTF_ReadVOLBDblk()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
DWORD MTF_ReadVOLBDblk(  MTF_DBLK_HDR_INFO  *psHdrInfo,
                         MTF_DBLK_VOLB_INFO *psVOLBInfo,  
                         BYTE               *pBuffer)     
{
    MTF_DBLK_VOLB *psVOLB = 0;

    ClearStrings();
    MTF_DBLK_HDR_INFO_ReadFromBuffer(psHdrInfo, pBuffer);

    psVOLB = (MTF_DBLK_VOLB *) pBuffer;

    psVOLBInfo->uVolumeAttributes = psVOLB->uVolumeAttributes;

    psVOLBInfo->sMediaWriteDate = psVOLB->sMediaWriteDate;

    psVOLBInfo->szDeviceName  = MakeString((wchar_t *) (pBuffer + psVOLB->sDeviceName.uOffset), psVOLB->sDeviceName.uSize);
    psVOLBInfo->szVolumeName  = MakeString((wchar_t *) (pBuffer + psVOLB->sVolumeName.uOffset), psVOLB->sVolumeName.uSize);
    psVOLBInfo->szMachineName = MakeString((wchar_t *) (pBuffer + psVOLB->sMachineName.uOffset), psVOLB->sMachineName.uSize);

    if ( !psVOLBInfo->szDeviceName || !psVOLBInfo->szVolumeName || !psVOLBInfo->szMachineName )
        return MTF_OUT_OF_MEMORY;

    return MTF_ERROR_NONE;    
}



/* ==================================================================================
=====================================================================================
     DIRB DBLK: MTF_DBLK_DIRB_INFO
=====================================================================================
================================================================================== */

// Calculates the room that will be taken up in the DBLK by strings and OS specific data
// **NOT INCLUDING THE COMMON DBLK HEADER additional info **
static size_t MTF_DBLK_DIRB_INFO_CalcAddDataSize(MTF_DBLK_DIRB_INFO *pDIRBInfo)
{
    return wstrsize(pDIRBInfo->szDirectoryName);
}




/***********************************************************************************
* MTF_SetDIRBDefaults()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
void MTF_SetDIRBDefaults(
    MTF_DBLK_DIRB_INFO *pDIRBInfo
    )
{
    pDIRBInfo->uDirectoryAttributes  = 0;
    pDIRBInfo->sLastModificationDate = MTF_CreateDateNull();
    pDIRBInfo->sCreationDate         = MTF_CreateDateNull();
    pDIRBInfo->sBackupDate           = MTF_CreateDateNull();
    pDIRBInfo->sLastAccessDate       = MTF_CreateDateNull();
    pDIRBInfo->uDirectoryId          = 0;
    pDIRBInfo->szDirectoryName       = 0 ;
}




/***********************************************************************************
* MTF_SetDIRBFromFindData()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
void MTF_SetDIRBFromFindData(
    MTF_DBLK_DIRB_INFO *pDIRBInfo, 
    wchar_t            *szDirectoryName, 
    WIN32_FIND_DATAW   *pFindData
    )
{
    MTF_SetDIRBDefaults(pDIRBInfo); // initialize

    if ( wcslen( szDirectoryName ) < STRLEN ) {
        wcscpy(s_szDirectoryName, szDirectoryName);
        pDIRBInfo->szDirectoryName  = s_szDirectoryName;
    }
    else {
        pDIRBInfo->uDirectoryAttributes |= MTF_DIRB_PATH_IN_STREAM;
        pDIRBInfo->szDirectoryName  = 0;
    }

    if (pFindData)
    {
        pDIRBInfo->uDirectoryAttributes |= 
            pFindData->dwFileAttributes & FILE_ATTRIBUTE_READONLY ? MTF_DIRB_READ_ONLY : 0 
            | pFindData->dwFileAttributes & FILE_ATTRIBUTE_HIDDEN  ? MTF_DIRB_HIDDEN : 0 
            | pFindData->dwFileAttributes & FILE_ATTRIBUTE_SYSTEM  ? MTF_DIRB_SYSTEM : 0 
            | pFindData->dwFileAttributes & FILE_ATTRIBUTE_ARCHIVE ? MTF_DIRB_MODIFIED : 0; 
    
        pDIRBInfo->sLastModificationDate = MTF_CreateDateTimeFromFileTime(pFindData->ftLastWriteTime);
        pDIRBInfo->sCreationDate         = MTF_CreateDateTimeFromFileTime(pFindData->ftCreationTime);
        pDIRBInfo->sLastAccessDate       = MTF_CreateDateTimeFromFileTime(pFindData->ftLastAccessTime);
    }

    pDIRBInfo->uDirectoryId     = 0;
}


/***********************************************************************************
* MTF_WriteDIRBDblk()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
DWORD MTF_WriteDIRBDblk( MTF_DBLK_HDR_INFO  *psHdrInfo,
                         MTF_DBLK_DIRB_INFO *psDIRBInfo,  
                         BYTE               *pBuffer,     
                         size_t              nBufferSize, 
                         size_t             *pnSizeUsed)  
{
    UINT16 uOffsetToFirstStream;

    //
    // Figure the size of the entire DBLK & make sure we have room
    //
    uOffsetToFirstStream = sizeof(MTF_DBLK_DIRB) + 
                           MTF_DBLK_HDR_INFO_CalcAddDataSize(psHdrInfo) + 
                           MTF_DBLK_DIRB_INFO_CalcAddDataSize(psDIRBInfo);

    uOffsetToFirstStream = (UINT16)Align(uOffsetToFirstStream, 4);

    if (nBufferSize < uOffsetToFirstStream)
    {
        if (pnSizeUsed)
            *pnSizeUsed = uOffsetToFirstStream;
        
        return MTF_ERROR_BUFFER_TOO_SMALL;                        
    }    

    memset(pBuffer, 0, uOffsetToFirstStream);
    
    {
        MTF_DBLK_DIRB *psDIRB = 0;
        size_t uCurrentStorageOffset = 0;

        uCurrentStorageOffset = sizeof(MTF_DBLK_DIRB);

        MTF_WriteDblkHdrToBuffer(
            MTF_ID_DIRB, 
            uOffsetToFirstStream,
            psHdrInfo, 
            pBuffer, 
            &uCurrentStorageOffset);
        
        psDIRB = (MTF_DBLK_DIRB *) pBuffer;

        psDIRB->uDirectoryAttributes  = psDIRBInfo->uDirectoryAttributes;
        psDIRB->sLastModificationDate = psDIRBInfo->sLastModificationDate;
        psDIRB->sCreationDate         = psDIRBInfo->sCreationDate;
        psDIRB->sBackupDate           = psDIRBInfo->sBackupDate;
        psDIRB->sLastAccessDate       = psDIRBInfo->sLastAccessDate;
        psDIRB->uDirectoryId          = psDIRBInfo->uDirectoryId;
                              
        //
        // here, we need to turn the slashes (L'\\') to zeros (L'\0')in the directory name string... 
        // 
        {
            int i, iLen;
            wchar_t *szDirectoryName = (wchar_t *) (pBuffer + uCurrentStorageOffset);

            uCurrentStorageOffset = StringToTapeAddress(&psDIRB->sDirectoryName, pBuffer, psDIRBInfo->szDirectoryName, uCurrentStorageOffset);
            iLen = wstrsize(psDIRBInfo->szDirectoryName);
            for (i = 0; i < iLen; ++i)
                if (szDirectoryName[i] == L'\\')
                    szDirectoryName[i] = L'\0';
        }
        if (pnSizeUsed)
            *pnSizeUsed = uOffsetToFirstStream;
    }

    return MTF_ERROR_NONE;    
}





/***********************************************************************************
* MTF_ReadDIRBDblk()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
DWORD MTF_ReadDIRBDblk(  MTF_DBLK_HDR_INFO  *psHdrInfo,
                         MTF_DBLK_DIRB_INFO *psDIRBInfo,  
                         BYTE               *pBuffer)     
{
    MTF_DBLK_DIRB *psDIRB = 0;

    ClearStrings();
    MTF_DBLK_HDR_INFO_ReadFromBuffer(psHdrInfo, pBuffer);

    psDIRB = (MTF_DBLK_DIRB *) pBuffer;

    psDIRBInfo->uDirectoryAttributes  = psDIRB->uDirectoryAttributes;
    psDIRBInfo->sLastModificationDate = psDIRB->sLastModificationDate;
    psDIRBInfo->sCreationDate         = psDIRB->sCreationDate;
    psDIRBInfo->sBackupDate           = psDIRB->sBackupDate;
    psDIRBInfo->sLastAccessDate       = psDIRB->sLastAccessDate;
    psDIRBInfo->uDirectoryId          = psDIRB->uDirectoryId;

    psDIRBInfo->szDirectoryName = NULL;

    // 
    // we need to turn the zeros in the directory name back to slashes
    // (there are no terminating \0's in the string -- all \0's are really \\'s
    // 
    {
        wchar_t *pTmpBuffer;   
        int i;
        pTmpBuffer = (wchar_t *) malloc(psDIRB->sDirectoryName.uSize);

        if (pTmpBuffer) {

            memmove(pTmpBuffer, pBuffer + psDIRB->sDirectoryName.uOffset, psDIRB->sDirectoryName.uSize);
            for (i = 0; i < psDIRB->sDirectoryName.uSize; ++i)
                if (pTmpBuffer[i] == L'\0')
                    pTmpBuffer[i] = L'\\';
    
            psDIRBInfo->szDirectoryName = MakeString(pTmpBuffer, psDIRB->sDirectoryName.uSize);
            free(pTmpBuffer);

        }

    }

    if ( !psDIRBInfo->szDirectoryName )
        return MTF_OUT_OF_MEMORY;

    return MTF_ERROR_NONE;    
}





/* ==================================================================================
=====================================================================================
     FILE DBLK: MTF_DBLK_FILE_INFO
=====================================================================================
================================================================================== */

// Calculates the room that will be taken up in the DBLK by strings and OS specific data
// **NOT INCLUDING THE COMMON DBLK HEADER additional info **
static size_t MTF_DBLK_FILE_INFO_CalcAddDataSize(MTF_DBLK_FILE_INFO *pFILEInfo)
{
    return wstrsize(pFILEInfo->szFileName);
}




/***********************************************************************************
* MTF_SetFILEDefaults()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
void MTF_SetFILEDefaults(MTF_DBLK_FILE_INFO *pFILEInfo)
{
    pFILEInfo->uFileAttributes       = 0;
    pFILEInfo->sLastModificationDate = MTF_CreateDateNull();
    pFILEInfo->sCreationDate         = MTF_CreateDateNull();
    pFILEInfo->sBackupDate           = MTF_CreateDateNull();
    pFILEInfo->sLastAccessDate       = MTF_CreateDateNull();
    pFILEInfo->uDirectoryId          = 0;
    pFILEInfo->uFileId               = 0;
    pFILEInfo->szFileName            = 0;
}





/***********************************************************************************
* MTF_SetFILEFromFindData()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
void MTF_SetFILEFromFindData(MTF_DBLK_FILE_INFO *pFILEInfo, WIN32_FIND_DATAW *pFindData)
{
    time_t tTime;
    time(&tTime);

    MTF_SetFILEDefaults(pFILEInfo);  // initialize

    wcscpy(s_szFileName, pFindData->cFileName);

    pFILEInfo->uFileAttributes = 
        (pFindData->dwFileAttributes & FILE_ATTRIBUTE_READONLY ? MTF_FILE_READ_ONLY : 0) 
      | (pFindData->dwFileAttributes & FILE_ATTRIBUTE_HIDDEN  ? MTF_FILE_HIDDEN : 0) 
      | (pFindData->dwFileAttributes & FILE_ATTRIBUTE_SYSTEM  ? MTF_FILE_SYSTEM : 0)
      | (pFindData->dwFileAttributes & FILE_ATTRIBUTE_ARCHIVE ? MTF_FILE_MODIFIED : 0) ;
    
    pFILEInfo->sLastModificationDate = MTF_CreateDateTimeFromFileTime(pFindData->ftLastWriteTime);
    pFILEInfo->sCreationDate         = MTF_CreateDateTimeFromFileTime(pFindData->ftCreationTime);
    pFILEInfo->sLastAccessDate       = MTF_CreateDateTimeFromFileTime(pFindData->ftLastAccessTime);
    pFILEInfo->uDirectoryId          = 0;
    pFILEInfo->uFileId               = 0;
    pFILEInfo->szFileName            = s_szFileName;

    pFILEInfo->uDisplaySize          = MTF_CreateUINT64(pFindData->nFileSizeLow, pFindData->nFileSizeHigh);

}





/***********************************************************************************
* MTF_WriteFILEDblk()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
DWORD MTF_WriteFILEDblk( MTF_DBLK_HDR_INFO  *psHdrInfo,
                         MTF_DBLK_FILE_INFO *psFILEInfo,  
                         BYTE               *pBuffer,     
                         size_t              nBufferSize, 
                         size_t             *pnSizeUsed)  
{
    UINT16 uOffsetToFirstStream;
    
    //
    // Figure the size of the entire DBLK & make sure we have room
    //
    uOffsetToFirstStream = sizeof(MTF_DBLK_FILE) + 
                           MTF_DBLK_HDR_INFO_CalcAddDataSize(psHdrInfo) + 
                           MTF_DBLK_FILE_INFO_CalcAddDataSize(psFILEInfo);

    uOffsetToFirstStream = (UINT16)Align(uOffsetToFirstStream, 4);
    if (nBufferSize < uOffsetToFirstStream)
    {
        if (pnSizeUsed)
            *pnSizeUsed = uOffsetToFirstStream;
        
        return MTF_ERROR_BUFFER_TOO_SMALL;                        
    }    

    memset(pBuffer, 0, uOffsetToFirstStream);
    
    {
        MTF_DBLK_FILE *psFILE = 0;
        size_t uCurrentStorageOffset = 0;

        uCurrentStorageOffset = sizeof(MTF_DBLK_FILE);
        psHdrInfo->uDisplayableSize = psFILEInfo->uDisplaySize;

        MTF_WriteDblkHdrToBuffer(
            MTF_ID_FILE, 
            uOffsetToFirstStream,
            psHdrInfo, 
            pBuffer, 
            &uCurrentStorageOffset);
        
        psFILE = (MTF_DBLK_FILE *) pBuffer;

        psFILE->uFileAttributes         = psFILEInfo->uFileAttributes;
        psFILE->sLastModificationDate   = psFILEInfo->sLastModificationDate;
        psFILE->sCreationDate           = psFILEInfo->sCreationDate;
        psFILE->sBackupDate             = psFILEInfo->sBackupDate;
        psFILE->sLastAccessDate         = psFILEInfo->sLastAccessDate;
        psFILE->uDirectoryId            = psFILEInfo->uDirectoryId;
        psFILE->uFileId                 = psFILEInfo->uFileId;

        uCurrentStorageOffset = StringToTapeAddress(&psFILE->sFileName, pBuffer, psFILEInfo->szFileName, uCurrentStorageOffset);

        if (pnSizeUsed)
            *pnSizeUsed = uOffsetToFirstStream;
    }

    return MTF_ERROR_NONE;    
}





/***********************************************************************************
* MTF_ReadFILEDblk()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
DWORD MTF_ReadFILEDblk(  MTF_DBLK_HDR_INFO  *psHdrInfo,
                         MTF_DBLK_FILE_INFO *psFILEInfo,  
                         BYTE               *pBuffer)     
{
    MTF_DBLK_FILE *psFILE = 0;

    ClearStrings();
    MTF_DBLK_HDR_INFO_ReadFromBuffer(psHdrInfo, pBuffer);

    psFILE = (MTF_DBLK_FILE *) pBuffer;

    psFILEInfo->uFileAttributes         = psFILE->uFileAttributes;
    psFILEInfo->sLastModificationDate   = psFILE->sLastModificationDate;
    psFILEInfo->sCreationDate           = psFILE->sCreationDate;
    psFILEInfo->sBackupDate             = psFILE->sBackupDate;
    psFILEInfo->sLastAccessDate         = psFILE->sLastAccessDate;
    psFILEInfo->uDirectoryId            = psFILE->uDirectoryId;
    psFILEInfo->uFileId                 = psFILE->uFileId;

    psFILEInfo->szFileName              = MakeString((wchar_t *) (pBuffer + psFILE->sFileName.uOffset), psFILE->sFileName.uSize);

    if ( !psFILEInfo->szFileName )
        return MTF_OUT_OF_MEMORY;

    return MTF_ERROR_NONE;    
}




/* ==================================================================================
=====================================================================================
     CFIL DBLK: MTF_DBLK_CFIL_INFO
=====================================================================================
================================================================================== */

/***********************************************************************************
* MTF_SetCFILDefaults()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
void MTF_SetCFILDefaults(
    MTF_DBLK_CFIL_INFO *pCFILInfo
    )
{
    pCFILInfo->uCFileAttributes     = MTF_CFIL_UNREADABLE_BLK;
    pCFILInfo->uDirectoryId         = 0;
    pCFILInfo->uFileId              = 0;
    pCFILInfo->uStreamOffset        = 0;
    pCFILInfo->uCorruptStreamNumber = 0;
}




/***********************************************************************************
* MTF_WriteCFILDblk()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
DWORD MTF_WriteCFILDblk( MTF_DBLK_HDR_INFO  *psHdrInfo,
                         MTF_DBLK_CFIL_INFO *psCFILInfo,  
                         BYTE               *pBuffer,     
                         size_t              nBufferSize, 
                         size_t             *pnSizeUsed)  
{
    UINT16 uOffsetToFirstStream;


    
    //
    // Figure the size of the entire DBLK & make sure we have room
    //
    uOffsetToFirstStream = sizeof(MTF_DBLK_HDR) + 
                           sizeof(MTF_DBLK_CFIL) +
                           MTF_DBLK_HDR_INFO_CalcAddDataSize(psHdrInfo);

    uOffsetToFirstStream = (UINT16)Align(uOffsetToFirstStream, 4);

    if (nBufferSize < uOffsetToFirstStream)
    {
        if (pnSizeUsed)
            *pnSizeUsed = uOffsetToFirstStream;
        
        return MTF_ERROR_BUFFER_TOO_SMALL;                        
    }    

    memset(pBuffer, 0, uOffsetToFirstStream);
    
    {
        MTF_DBLK_CFIL_INFO *psCFIL = 0;
        size_t uCurrentStorageOffset = 0;

        uCurrentStorageOffset = sizeof(MTF_DBLK_HDR) + sizeof(MTF_DBLK_CFIL);

        MTF_WriteDblkHdrToBuffer(
            MTF_ID_CFIL, 
            uOffsetToFirstStream,
            psHdrInfo, 
            pBuffer, 
            &uCurrentStorageOffset);
        
        psCFIL = (MTF_DBLK_CFIL_INFO *)  (pBuffer + sizeof(MTF_DBLK_HDR));

        *psCFIL = *psCFILInfo;

        if (pnSizeUsed)
            *pnSizeUsed = uOffsetToFirstStream;
    }

    return MTF_ERROR_NONE;    
}




/***********************************************************************************
* MTF_ReadCFILDblk()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
DWORD MTF_ReadCFILDblk(  MTF_DBLK_HDR_INFO  *psHdrInfo,
                         MTF_DBLK_CFIL_INFO *psCFILInfo,  
                         BYTE               *pBuffer)     
{
    MTF_DBLK_CFIL *psCFIL = 0;

    ClearStrings();
    MTF_DBLK_HDR_INFO_ReadFromBuffer(psHdrInfo, pBuffer);

    psCFIL = (MTF_DBLK_CFIL_INFO *)  (pBuffer + sizeof(MTF_DBLK_HDR));

    *psCFILInfo = *psCFIL;

    return MTF_ERROR_NONE;    
}


/* ==================================================================================
=====================================================================================
     ESPB DBLK
=====================================================================================
================================================================================== */

/***********************************************************************************
* MTF_WriteESPBDblk()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
DWORD MTF_WriteESPBDblk( MTF_DBLK_HDR_INFO  *psHdrInfo,
                         BYTE               *pBuffer,
                         size_t              nBufferSize,
                         size_t             *pnSizeUsed)

{
    UINT16 uOffsetToFirstStream;

    //
    // Figure the size of the entire DBLK & make sure we have room
    //
    uOffsetToFirstStream = sizeof(MTF_DBLK_HDR) + 
                           MTF_DBLK_HDR_INFO_CalcAddDataSize(psHdrInfo);

    uOffsetToFirstStream = (UINT16)Align(uOffsetToFirstStream, 4);

    if (nBufferSize < uOffsetToFirstStream) {
        if (pnSizeUsed) {
            *pnSizeUsed = uOffsetToFirstStream;
        }

        return MTF_ERROR_BUFFER_TOO_SMALL;                
    }

    memset(pBuffer, 0, uOffsetToFirstStream);

    MTF_WriteDblkHdrToBuffer(
        MTF_ID_ESPB,
        uOffsetToFirstStream,
        psHdrInfo,
        pBuffer,
        0);

    if (pnSizeUsed)
        *pnSizeUsed = uOffsetToFirstStream;

    return MTF_ERROR_NONE;    
}                                             




/***********************************************************************************
* MTF_ReadESPBDblk()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
DWORD MTF_ReadESPBDblk(  MTF_DBLK_HDR_INFO  *psHdrInfo,
                         BYTE               *pBuffer)     
{
    MTF_DBLK_HDR_INFO_ReadFromBuffer(psHdrInfo, pBuffer);

    return MTF_ERROR_NONE;    
}                            




/* ==================================================================================
=====================================================================================
     End of Set DBLK (ESET)
=====================================================================================
================================================================================== */

/***********************************************************************************
* MTF_SetESETDefaults()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
void MTF_SetESETDefaults(MTF_DBLK_ESET_INFO *pESETInfo)
{
    time_t tTime;
    time(&tTime);

    pESETInfo->uESETAttributes          = 0;
    pESETInfo->uNumberOfCorrupFiles     = 0;
    pESETInfo->uSetMapPBA               = 0;
    pESETInfo->uFileDetailPBA           = 0;
    pESETInfo->uFDDTapeSequenceNumber   = 0;
    pESETInfo->uDataSetNumber           = 0;
    pESETInfo->sMediaWriteDate          = MTF_CreateDateTimeFromTM(gmtime(&tTime));
}





/***********************************************************************************
* MTF_WriteESETDblk()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
DWORD MTF_WriteESETDblk( MTF_DBLK_HDR_INFO  *psHdrInfo,
                         MTF_DBLK_ESET_INFO *psESETInfo,  
                         BYTE               *pBuffer,     
                         size_t              nBufferSize, 
                         size_t             *pnSizeUsed)  
{
    UINT16 uOffsetToFirstStream;
    
    //
    // Figure the size of the entire DBLK & make sure we have room
    //
    uOffsetToFirstStream = sizeof(MTF_DBLK_ESET) +
                           sizeof(MTF_DBLK_HDR) +  
                           MTF_DBLK_HDR_INFO_CalcAddDataSize(psHdrInfo);
                        
    uOffsetToFirstStream = (UINT16)Align(uOffsetToFirstStream, 4);

    if (nBufferSize < uOffsetToFirstStream)
    {
        if (pnSizeUsed)
            *pnSizeUsed = uOffsetToFirstStream;
        
        return MTF_ERROR_BUFFER_TOO_SMALL;                        
    }    

    memset(pBuffer, 0, uOffsetToFirstStream);
    
    {
        MTF_DBLK_ESET_INFO *psESET = 0;
        size_t uCurrentStorageOffset = 0;

        uCurrentStorageOffset = sizeof(MTF_DBLK_ESET) + sizeof(MTF_DBLK_HDR);

        MTF_WriteDblkHdrToBuffer(
            MTF_ID_ESET, 
            uOffsetToFirstStream,
            psHdrInfo, 
            pBuffer, 
            &uCurrentStorageOffset);
        
        psESET = (MTF_DBLK_ESET_INFO *) (pBuffer + sizeof(MTF_DBLK_HDR));

        *psESET = *psESETInfo;

        if (pnSizeUsed)
            *pnSizeUsed = uOffsetToFirstStream;
    }

    return MTF_ERROR_NONE;    
}





/***********************************************************************************
* MTF_ReadESETDblk()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
DWORD MTF_ReadESETDblk(  MTF_DBLK_HDR_INFO  *psHdrInfo,
                         MTF_DBLK_ESET_INFO *psESETInfo,  
                         BYTE               *pBuffer)     
{
    MTF_DBLK_ESET *psESET = 0;

    ClearStrings();
    MTF_DBLK_HDR_INFO_ReadFromBuffer(psHdrInfo, pBuffer);

    psESET = (MTF_DBLK_ESET_INFO *) (pBuffer + sizeof(MTF_DBLK_HDR));

    *psESETInfo = *psESET;

    return MTF_ERROR_NONE;    
}




/* ==================================================================================
=====================================================================================
     End of Set DBLK (EOTM)
=====================================================================================
================================================================================== */
/***********************************************************************************
* MTF_SetEOTMDefaults()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
void MTF_SetEOTMDefaults(MTF_DBLK_EOTM_INFO *pEOTMInfo)
{
    pEOTMInfo->uLastESETPBA = 0;
}





/***********************************************************************************
* MTF_WriteEOTMDblk()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
DWORD MTF_WriteEOTMDblk( MTF_DBLK_HDR_INFO  *psHdrInfo,
                         MTF_DBLK_EOTM_INFO *psEOTMInfo,  
                         BYTE               *pBuffer,     
                         size_t              nBufferSize, 
                         size_t             *pnSizeUsed)  
{
    UINT16 uOffsetToFirstStream;
    
    //
    // Figure the size of the entire DBLK & make sure we have room
    //
    uOffsetToFirstStream = sizeof(MTF_DBLK_EOTM_INFO) + 
                           sizeof(MTF_DBLK_HDR) + 
                           MTF_DBLK_HDR_INFO_CalcAddDataSize(psHdrInfo);

    uOffsetToFirstStream = (UINT16)Align(uOffsetToFirstStream, 4);

    if (nBufferSize < uOffsetToFirstStream)
        {
        if (pnSizeUsed)
            *pnSizeUsed = uOffsetToFirstStream;
        
        return MTF_ERROR_BUFFER_TOO_SMALL;                        
        }    

    memset(pBuffer, 0, uOffsetToFirstStream);
    
    {
        MTF_DBLK_EOTM_INFO *psEOTM = 0;
        size_t uCurrentStorageOffset = 0;

        uCurrentStorageOffset = sizeof(MTF_DBLK_HDR) + sizeof(MTF_DBLK_EOTM);

        MTF_WriteDblkHdrToBuffer(
            MTF_ID_EOTM, 
            uOffsetToFirstStream,
            psHdrInfo, 
            pBuffer, 
            &uCurrentStorageOffset);
        
        psEOTM = (MTF_DBLK_EOTM_INFO *) (pBuffer + sizeof(MTF_DBLK_HDR));

        *psEOTM = *psEOTMInfo;

        if (pnSizeUsed)
            *pnSizeUsed = uOffsetToFirstStream;
    }

    return MTF_ERROR_NONE;    
}




/***********************************************************************************
* MTF_ReadEOTMDblk()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
DWORD MTF_ReadEOTMDblk(  MTF_DBLK_HDR_INFO  *psHdrInfo,
                         MTF_DBLK_EOTM_INFO *psEOTMInfo,  
                         BYTE               *pBuffer)     
{
    MTF_DBLK_EOTM *psEOTM = 0;

    ClearStrings();
    MTF_DBLK_HDR_INFO_ReadFromBuffer(psHdrInfo, pBuffer);

    psEOTM = (MTF_DBLK_EOTM_INFO *) (pBuffer + sizeof(MTF_DBLK_HDR));

    *psEOTMInfo = *psEOTM;

    return MTF_ERROR_NONE;    
}


/* ==================================================================================
=====================================================================================
     Soft Filemark (SFMB)
=====================================================================================
================================================================================== */
/***********************************************************************************
* MTF_CreateSFMB() - (bmd)
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
size_t MTF_GetMaxSoftFilemarkEntries(size_t nBlockSize)
{
    size_t n;

    if (0 == nBlockSize || nBlockSize % 512) {
        return 0;
    }

    // The SFMB fills the entire block.
    // Calculate the total number of entries that fit within a block
    // such that MTF_DBLK_HDR + MTF_DBLK_SFMB + (n-1 elements) < nBlockSize
    n = (nBlockSize - sizeof(MTF_DBLK_HDR) - sizeof(MTF_DBLK_SFMB) + sizeof(UINT32))/sizeof(UINT32);

    return n;
}

/***********************************************************************************
* MTF_InsertSoftFilemark() - (bmd)
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
void MTF_InsertSoftFilemark(MTF_DBLK_SFMB_INFO *psSoftInfo,
                            UINT32 pba)
{
    size_t n;
    size_t bytesToShift;

    // We insert a filemark entry by shifting all the entries down.  The one closest BOM
    // eventually drop out of the array.

    if (psSoftInfo) {
        n = psSoftInfo->uNumberOfFilemarkEntries;

        bytesToShift = psSoftInfo->uFilemarkEntriesUsed * sizeof(UINT32);

        // So we don't overwrite memory.
        bytesToShift -= (psSoftInfo->uFilemarkEntriesUsed < psSoftInfo->uNumberOfFilemarkEntries) ? 0 : sizeof(UINT32);
    
        memmove(&psSoftInfo->uFilemarkArray[1], &psSoftInfo->uFilemarkArray[0], bytesToShift);

        psSoftInfo->uFilemarkArray[0] = pba;

        if (psSoftInfo->uFilemarkEntriesUsed < psSoftInfo->uNumberOfFilemarkEntries) {
            psSoftInfo->uFilemarkEntriesUsed++;
        }
    }
}


/***********************************************************************************
* MTF_WriteSFMBDblk() - (bmd)
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
DWORD MTF_WriteSFMBDblk(MTF_DBLK_HDR_INFO *psHdrInfo,
                        MTF_DBLK_SFMB_INFO *psSoftInfo,
                        BYTE *pBuffer,
                        size_t nBufferSize,
                        size_t *pnSizeUsed)
{
    UINT16 uOffsetToFirstStream;
    size_t sizeOfSFMB;

    if (NULL == psHdrInfo || NULL == psSoftInfo || NULL == pBuffer || NULL == pnSizeUsed || 0 == nBufferSize) {
        return ERROR_INVALID_PARAMETER;
    }
    // Code assumes sizeof(MTF_DBLK_SFMB_INFO) == sizeof(MTF_DBLK_SFMB)
    if (sizeof(MTF_DBLK_SFMB_INFO) != sizeof(MTF_DBLK_SFMB)) {
        return ERROR_INVALID_FUNCTION;
    }

    //
    // Figure the size of the entire DBLK & make sure we have room
    //
    sizeOfSFMB = sizeof(MTF_DBLK_SFMB) + (psSoftInfo->uNumberOfFilemarkEntries-1)*sizeof(UINT32);

    uOffsetToFirstStream = sizeOfSFMB +
                           sizeof(MTF_DBLK_HDR) +
                           MTF_DBLK_HDR_INFO_CalcAddDataSize(psHdrInfo);

    uOffsetToFirstStream = (UINT16)Align(uOffsetToFirstStream, 4);

    if (nBufferSize < uOffsetToFirstStream)
        {
        if (pnSizeUsed)
            *pnSizeUsed = uOffsetToFirstStream;

        return MTF_ERROR_BUFFER_TOO_SMALL;                        
        }    

    memset(pBuffer, 0, uOffsetToFirstStream);

    {
        MTF_DBLK_SFMB_INFO *psSFMB = 0;
        size_t uCurrentStorageOffset = 0;

        uCurrentStorageOffset = sizeof(MTF_DBLK_HDR) + sizeOfSFMB;

        MTF_WriteDblkHdrToBuffer(
            MTF_ID_SFMB,
            uOffsetToFirstStream,
            psHdrInfo,
            pBuffer,
            &uCurrentStorageOffset);

        psSFMB = (MTF_DBLK_SFMB *) (pBuffer + sizeof(MTF_DBLK_HDR));

        // Need a deep copy since MTF_DBLK_SFMB_INFO holds a placeholder for the array.
        memcpy(psSFMB, psSoftInfo, sizeOfSFMB);

        if (pnSizeUsed) {
            *pnSizeUsed = uOffsetToFirstStream;
        }
    }

    return MTF_ERROR_NONE;
}

/***********************************************************************************
* MTF_ReadSFMBDblk() - (bmd)
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
DWORD MTF_ReadSFMBDblk(MTF_DBLK_HDR_INFO *psHdrInfo,
                       MTF_DBLK_SFMB_INFO *psSoftInfo,
                       BYTE *pBuffer)
{
    MTF_DBLK_SFMB *psSFMB = 0;
    size_t sizeOfSFMB;

    if (NULL == psHdrInfo || NULL == psSoftInfo || NULL == pBuffer) {
        return ERROR_INVALID_PARAMETER;
    }
    // Code assumes sizeof(MTF_DBLK_SFMB_INFO) == sizeof(MTF_DBLK_SFMB)
    if (sizeof(MTF_DBLK_SFMB_INFO) != sizeof(MTF_DBLK_SFMB)) {
        return ERROR_INVALID_FUNCTION;
    }

    ClearStrings();
    MTF_DBLK_HDR_INFO_ReadFromBuffer(psHdrInfo, pBuffer);

    psSFMB = (MTF_DBLK_SFMB *) (pBuffer + sizeof(MTF_DBLK_HDR));

    // Need a deep copy since MTF_DBLK_SFMB_INFO holds a placeholder for the array.
    sizeOfSFMB = sizeof(MTF_DBLK_SFMB) + (psSFMB->uNumberOfFilemarkEntries-1)*sizeof(UINT32);
    memcpy(psSoftInfo, psSFMB, sizeOfSFMB);

    return MTF_ERROR_NONE;
}

/* ==================================================================================
=====================================================================================
     STREAM HEADER
=====================================================================================
================================================================================== */

/***********************************************************************************
* MTF_SetSTREAMDefaults()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
void MTF_SetSTREAMDefaults(MTF_STREAM_INFO *pSTREAMInfo, char *szId)
{
    memcpy(pSTREAMInfo->acStreamId, szId, 4);
    pSTREAMInfo->uStreamFileSystemAttributes = 0;
    pSTREAMInfo->uStreamTapeFormatAttributes = 0;
    pSTREAMInfo->uStreamLength               = 0;
    pSTREAMInfo->uDataEncryptionAlgorithm    = 0;
    pSTREAMInfo->uDataCompressionAlgorithm   = 0;
    pSTREAMInfo->uCheckSum                   = 0;
}




/***********************************************************************************
* MTF_SetSTREAMFromStreamId()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
void MTF_SetSTREAMFromStreamId(
    MTF_STREAM_INFO *pSTREAMInfo, 
    WIN32_STREAM_ID *pStreamId, 
    size_t           nIDHeaderSize
    )
{

// From Steve DeVos, Seagate:
//   > BACKUP_INVALID and BACKUP_LINK will never be returned from BackupRead.
//   >
//   > -Steve
//
// TODO:  MTF_NT_ENCRYPTED_STREAM     "NTED"; These retrieved by NT Encyption APIs
// TODO:  MTF_NT_QUOTA_STREAM         "NTQU"; These retrieved by NT Quota APIs

    MTF_SetSTREAMDefaults(pSTREAMInfo, "UNKN");

    if (pStreamId->dwStreamId == BACKUP_DATA)
        memcpy(pSTREAMInfo->acStreamId, "STAN", 4);
    else if (pStreamId->dwStreamId == BACKUP_EA_DATA)
        memcpy(pSTREAMInfo->acStreamId, "NTEA", 4);
    else if (pStreamId->dwStreamId == BACKUP_SECURITY_DATA)
        memcpy(pSTREAMInfo->acStreamId, "NACL", 4);
    else if (pStreamId->dwStreamId == BACKUP_ALTERNATE_DATA)
        memcpy(pSTREAMInfo->acStreamId, "ADAT", 4);
    else if (pStreamId->dwStreamId == BACKUP_OBJECT_ID)
        memcpy(pSTREAMInfo->acStreamId, "NTOI", 4);
    else if (pStreamId->dwStreamId == BACKUP_REPARSE_DATA)
        memcpy(pSTREAMInfo->acStreamId, "NTRP", 4);
    else if (pStreamId->dwStreamId == BACKUP_SPARSE_BLOCK)
        memcpy(pSTREAMInfo->acStreamId, "SPAR", 4);
    else {
        pSTREAMInfo->uStreamFileSystemAttributes |= MTF_STREAM_IS_NON_PORTABLE;
    }

    if (pStreamId->dwStreamAttributes & STREAM_MODIFIED_WHEN_READ)
        pSTREAMInfo->uStreamFileSystemAttributes |= MTF_STREAM_MODIFIED_BY_READ;
    if (pStreamId->dwStreamAttributes & STREAM_CONTAINS_SECURITY)
        pSTREAMInfo->uStreamFileSystemAttributes |= MTF_STREAM_CONTAINS_SECURITY;
    if (pStreamId->dwStreamAttributes & STREAM_SPARSE_ATTRIBUTE)
        pSTREAMInfo->uStreamFileSystemAttributes |= MTF_STREAM_IS_SPARSE;

    pSTREAMInfo->uStreamTapeFormatAttributes = 0;
    pSTREAMInfo->uStreamLength               = MTF_CreateUINT64(pStreamId->Size.LowPart, pStreamId->Size.HighPart) + nIDHeaderSize;
    pSTREAMInfo->uDataEncryptionAlgorithm    = 0;
    pSTREAMInfo->uDataCompressionAlgorithm   = 0;
    pSTREAMInfo->uCheckSum                   = 0;
}




/***********************************************************************************
* MTF_SetStreamIdFromSTREAM() - (bmd)                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
void MTF_SetStreamIdFromSTREAM(
    WIN32_STREAM_ID *pStreamId, 
    MTF_STREAM_INFO *pSTREAMInfo, 
    size_t           nIDHeaderSize
    )
{
    memset( pStreamId, 0, sizeof( WIN32_STREAM_ID ) );

    if (0 == memcmp(pSTREAMInfo->acStreamId, "STAN", 4))
        pStreamId->dwStreamId = BACKUP_DATA;
    else if (0 == memcmp(pSTREAMInfo->acStreamId, "NTEA", 4))
        pStreamId->dwStreamId = BACKUP_EA_DATA;
    else if (0 == memcmp(pSTREAMInfo->acStreamId, "NACL", 4))
        pStreamId->dwStreamId = BACKUP_SECURITY_DATA;
    else if (0 == memcmp(pSTREAMInfo->acStreamId, "ADAT", 4))
        pStreamId->dwStreamId = BACKUP_ALTERNATE_DATA;
    else if (0 == memcmp(pSTREAMInfo->acStreamId, "NTOI", 4))
        pStreamId->dwStreamId = BACKUP_OBJECT_ID;
    else if (0 == memcmp(pSTREAMInfo->acStreamId, "NTRP", 4))
        pStreamId->dwStreamId = BACKUP_REPARSE_DATA;
    else if (0 == memcmp(pSTREAMInfo->acStreamId, "SPAR", 4))
        pStreamId->dwStreamId = BACKUP_SPARSE_BLOCK;
    else {
        pStreamId->dwStreamId = BACKUP_INVALID;
    }

    pStreamId->dwStreamAttributes = STREAM_NORMAL_ATTRIBUTE;
    if (pSTREAMInfo->uStreamFileSystemAttributes & MTF_STREAM_MODIFIED_BY_READ)
        pStreamId->dwStreamAttributes |= STREAM_MODIFIED_WHEN_READ;
    if (pSTREAMInfo->uStreamFileSystemAttributes & MTF_STREAM_CONTAINS_SECURITY)
        pStreamId->dwStreamAttributes |= STREAM_CONTAINS_SECURITY;
    if (pSTREAMInfo->uStreamFileSystemAttributes & MTF_STREAM_IS_SPARSE)
        pStreamId->dwStreamAttributes |= STREAM_SPARSE_ATTRIBUTE;

    // TODO: Handle named data streams (size of name and in MTF stream)
    //       ? How do I know ?

    pStreamId->Size.LowPart  = (DWORD)((pSTREAMInfo->uStreamLength << 32) >>32);
    pStreamId->Size.HighPart = (DWORD)(pSTREAMInfo->uStreamLength >> 32);

}





/***********************************************************************************
* MTF_WriteStreamHeader()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
DWORD MTF_WriteStreamHeader(MTF_STREAM_INFO *psStreamInfo,  
                            BYTE            *pBuffer,     
                            size_t           nBufferSize, 
                            size_t          *pnSizeUsed) 

{

    psStreamInfo->uCheckSum = CalcChecksum((BYTE *) psStreamInfo, sizeof(MTF_STREAM_INFO) / sizeof(UINT16) - 1);

    if (nBufferSize < sizeof(MTF_STREAM_INFO))
    {
        if (pnSizeUsed)
            *pnSizeUsed = sizeof(MTF_STREAM_INFO);
        
        return MTF_ERROR_BUFFER_TOO_SMALL;                        
    }    

    memset(pBuffer, 0, sizeof(MTF_STREAM_INFO));
    
    
    *((MTF_STREAM_INFO *) pBuffer) = *psStreamInfo;

    if (pnSizeUsed)
        *pnSizeUsed = sizeof(MTF_STREAM_INFO);


    return MTF_ERROR_NONE;    
}




/***********************************************************************************
* MTF_WriteNameStream() - (bmd)
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
DWORD MTF_WriteNameStream(
    char *szType,
    wchar_t *szName,
    BYTE *pBuffer,
    size_t nBufferSize,
    size_t *pnSizeUsed)
{
    MTF_STREAM_INFO sStream;
    UINT16 uOffsetToCSUMStream;
    UINT16 uOffsetToNextStream;
    size_t nBufUsed;
    UINT16 nameSize;
    UINT32 nameChecksum;

    //
    // Figure the size of the entire Name stream including trailing CSUM and make sure we have room.
    //
    nameSize = (UINT16)wstrsize(szName);  // including terminating '\0'

    uOffsetToCSUMStream = sizeof(MTF_STREAM_INFO) + nameSize;
    uOffsetToCSUMStream = (UINT16)Align(uOffsetToCSUMStream, 4);

    uOffsetToNextStream = uOffsetToCSUMStream;

    uOffsetToNextStream += sizeof(MTF_STREAM_INFO) + 4; // includes 4 byte CSUM data
    uOffsetToNextStream = (UINT16)Align(uOffsetToNextStream, 4);

    if (nBufferSize < uOffsetToNextStream) {
        return MTF_ERROR_BUFFER_TOO_SMALL;
    }

    memset(pBuffer, 0, uOffsetToNextStream);

    MTF_SetSTREAMDefaults(&sStream, szType);
    sStream.uStreamLength = nameSize;
    sStream.uStreamTapeFormatAttributes |= MTF_STREAM_CHECKSUMED;
    MTF_WriteStreamHeader(&sStream, pBuffer, nBufferSize, &nBufUsed);

    memcpy(pBuffer + nBufUsed, szName, nameSize);

    if ( 0 == memcmp(sStream.acStreamId, "PNAM", 4) ) {
        //
        // here, we need to turn the slashes (L'\\') to zeros (L'\0')in the directory name string... 
        //
        int i, iLen;
        wchar_t *szDirectoryName = (wchar_t *) (pBuffer + nBufUsed);

        iLen = wstrsize(szDirectoryName);
        for (i = 0; i < iLen; ++i)
            if (szDirectoryName[i] == L'\\')
                szDirectoryName[i] = L'\0';
    }

    // For Name streams, we always tack on a CSUM

    nameChecksum = CalcChecksumOfStreamData(pBuffer + nBufUsed, nameSize / sizeof(UINT32) + 1);

    MTF_SetSTREAMDefaults(&sStream, MTF_CHECKSUM_STREAM);
    sStream.uStreamLength = sizeof(nameChecksum);
    MTF_WriteStreamHeader(&sStream, pBuffer + uOffsetToCSUMStream, nBufferSize, &nBufUsed);

    memcpy(pBuffer + uOffsetToCSUMStream + nBufUsed, &nameChecksum, sizeof(nameChecksum));

    if (pnSizeUsed)
        *pnSizeUsed = uOffsetToNextStream;

    return MTF_ERROR_NONE;
}




/***********************************************************************************
* MTF_ReadStreamHeader()                                        
*                                                            ** MTF API FUNCTION ** 
***********************************************************************************/
DWORD MTF_ReadStreamHeader(MTF_STREAM_INFO   *psStreamInfo,  
                          BYTE              *pBuffer)    

{
    *psStreamInfo = *((MTF_STREAM_INFO *) pBuffer);
    return MTF_ERROR_NONE;    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\mover\server\nttapeio.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    NtTapeIo.cpp

Abstract:

    CNtTapeIo class

Author:

    Brian Dodd          [brian]         25-Nov-1997

Revision History:

--*/

#include "stdafx.h"
#include "NtTapeIo.h"
#include "Mll.h"

int CNtTapeIo::s_InstanceCount = 0;

////////////////////////////////////////////////////////////////////////////////
//
// CComObjectRoot Implementation
//

ULONG
CNtTapeIo::InternalAddRef(void) {

    DWORD refs = CComObjectRoot::InternalAddRef();
    WsbTrace(OLESTR("CNtTapeIo::InternalAddRef - Refs=%d\n"), refs);

    return refs;

}

ULONG
CNtTapeIo::InternalRelease(void) {

    DWORD refs = CComObjectRoot::InternalRelease();
    WsbTrace(OLESTR("CNtTapeIo::InternalRelease - Refs=%d\n"), refs);

    return refs;

}


#pragma optimize("g", off)
STDMETHODIMP
CNtTapeIo::FinalConstruct(void) 
/*++

Implements:

    CComObjectRoot::FinalConstruct

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtTapeIo::FinalConstruct"), OLESTR(""));

    try {

        WsbAffirmHr(CComObjectRoot::FinalConstruct());

        (void) CoCreateGuid( &m_ObjectId );

        m_pSession = NULL;
        m_DataSetNumber = 0;

        m_hTape = INVALID_HANDLE_VALUE;
        m_DeviceName = MVR_UNDEFINED_STRING;
        m_Flags = 0;
        m_LastVolume = OLESTR("");
        m_LastPath = OLESTR("");

        m_ValidLabel = TRUE;

        memset(&m_sMediaParameters, 0, sizeof(TAPE_GET_MEDIA_PARAMETERS));
        memset(&m_sDriveParameters, 0, sizeof(TAPE_GET_DRIVE_PARAMETERS));

        m_StreamName = MVR_UNDEFINED_STRING;
        m_Mode = 0;
        m_StreamOffset.QuadPart = 0;
        m_StreamSize.QuadPart = 0;

        m_pStreamBuf = NULL;
        m_StreamBufSize = 0;
        m_StreamBufUsed = 0;
        m_StreamBufPosition = 0;
        m_StreamBufStartPBA.QuadPart = 0;

        try {

            // May raise STATUS_NO_MEMORY exception
            InitializeCriticalSection(&m_CriticalSection);

        } catch(DWORD status) {
            WsbLogEvent(status, 0, NULL, NULL);
            switch (status) {
            case STATUS_NO_MEMORY:
                WsbThrow(E_OUTOFMEMORY);
                break;
            default:
                WsbThrow(E_UNEXPECTED);
                break;
            }
        }



    } WsbCatch(hr);

    s_InstanceCount++;
    WsbTraceAlways(OLESTR("CNtTapeIo::s_InstanceCount += %d\n"), s_InstanceCount);

    WsbTraceOut(OLESTR("CNtTapeIo::FinalConstruct"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP
CNtTapeIo::FinalRelease(void) 
/*++

Implements:

    CComObjectRoot::FinalRelease

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtTapeIo::FinalRelease"),OLESTR(""));

    (void) CloseStream();  // in case anything is left open
    (void) CloseTape();

    CComObjectRoot::FinalRelease();

    s_InstanceCount--;
    WsbTraceAlways(OLESTR("CNtTapeIo::s_InstanceCount -= %d\n"), s_InstanceCount);

    WsbTraceOut(OLESTR("CNtTapeIo::FinalRelease"),OLESTR("hr = <%ls>"),WsbHrAsString(hr));

    try {

        // InitializeCriticalSection raises an exception.  Delete may too.
        DeleteCriticalSection(&m_CriticalSection);

    } catch(DWORD status) {
        WsbLogEvent(status, 0, NULL, NULL);
        }

    return hr;
}
#pragma optimize("", on)


HRESULT
CNtTapeIo::CompareTo(
    IN IUnknown *pCollectable,
    OUT SHORT *pResult)
/*++

Implements:

    CRmsComObject::CompareTo

--*/
{
    HRESULT     hr = E_FAIL;
    SHORT       result = 1;

    WsbTraceIn( OLESTR("CNtTapeIo::CompareTo"), OLESTR("") );

    try {

        // Validate arguments - Okay if pResult is NULL
        WsbAssertPointer( pCollectable );

        // We need the IRmsComObject interface to get the value of the object.
        CComQIPtr<IDataMover, &IID_IDataMover> pObject = pCollectable;
        WsbAssertPointer( pObject );

        GUID objectId;

        // Get objectId.
        WsbAffirmHr( pObject->GetObjectId( &objectId ));

        if ( m_ObjectId == objectId ) {

            // Object IDs match
            hr = S_OK;
            result = 0;

        }
        else {
            hr = S_FALSE;
            result = 1;
        }

    }
    WsbCatch( hr );

    if ( SUCCEEDED(hr) && (0 != pResult) ){
       *pResult = result;
    }

    WsbTraceOut( OLESTR("CNtTapeIo::CompareTo"),
                 OLESTR("hr = <%ls>, result = <%ls>"),
                 WsbHrAsString( hr ), WsbPtrToShortAsString( pResult ) );

    return hr;
}


HRESULT
CNtTapeIo::IsEqual(
    IUnknown* pObject
    )

/*++

Implements:

  IWsbCollectable::IsEqual().

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CNtTapeIo::IsEqual"), OLESTR(""));

    hr = CompareTo(pObject, NULL);

    WsbTraceOut(OLESTR("CNtTapeIo::IsEqual"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

////////////////////////////////////////////////////////////////////////////////
//
// ISupportErrorInfo Implementation
//


STDMETHODIMP
CNtTapeIo::InterfaceSupportsErrorInfo(REFIID riid)
/*++

Implements:

    ISupportsErrorInfo::InterfaceSupportsErrorInfo

--*/
{
    static const IID* arr[] = 
    {
        &IID_IDataMover,
        &IID_IStream,
    };

    for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
    {
        if (InlineIsEqualGUID(*arr[i],riid))
            return S_OK;
    }
    return S_FALSE;
}

////////////////////////////////////////////////////////////////////////////////
//
// IDataMover Implementation
//



STDMETHODIMP
CNtTapeIo::GetObjectId(
    OUT GUID *pObjectId)
/*++

Implements:

    IRmsComObject::GetObjectId

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtTapeIo::GetObjectId"), OLESTR(""));

    try {

        WsbAssertPointer( pObjectId );

        *pObjectId = m_ObjectId;

    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CNtTapeIo::GetObjectId"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP
CNtTapeIo::BeginSession(
    IN BSTR remoteSessionName,
    IN BSTR remoteSessionDescription,
    IN SHORT remoteDataSet,
    IN DWORD options)
/*++

Implements:

    IDataMover::BeginSession

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtTapeIo::BeginSession"), OLESTR("<%ls> <%ls> <%d> <0x%08x>"),
        remoteSessionName, remoteSessionDescription, remoteDataSet, options);

    CComPtr<IStream> pStream;
    ULARGE_INTEGER nil = {0,0};

    try {
        MvrInjectError(L"Inject.CNtTapeIo::BeginSession.0");

        WsbAssert(remoteDataSet > 0, MVR_E_INVALIDARG);
        WsbAffirm(TRUE == m_ValidLabel, E_ABORT);

        // This may be overkill, but just in case we verify we're working with the correct media.
        CWsbBstrPtr label;
        WsbAffirmHr(ReadLabel(&label));
        WsbAssertHr(VerifyLabel(label));

        // Create the remote stream used for the entire session.
        WsbAffirmHr(CreateRemoteStream(L"", MVR_MODE_WRITE, L"",L"",nil,nil,nil,nil,nil,0,nil, &pStream));
        WsbAffirmPointer(pStream);

        SHORT startSet = remoteDataSet;
        UINT64 addr1=0, addr2=0;
        LONG tapeMarks=0;

        //
        // Only allow append at EOD or last data set
        //
        tapeMarks = 1 + (startSet-1)*2;
        if ( MVR_SESSION_APPEND_TO_DATA_SET & options ) {
            tapeMarks += 2;
        }

        int retry = 3;  // We allow a two pass error recovery, one for each possible
                        // missing filemark, we abort on failure of the third attempt.

        do {
            hr = S_OK;

            // Each pass recovers from a single missing filemark (two max).
            // This is the case where a files were recorded to media but the
            // EndSession() method was never called or did not complete (i.e. power failure).
            try {
                WsbAssertPointer(m_pSession);

                // Make sure we have a consistant data set.  We handle a single instance of
                // a partially written data set, including those with a missing EOD marker.

                // NOTE: The MISSING EOD error may eventually be detected by ERROR_NOT_FOUND, per Chuck Parks.

                WsbAffirmHr(RewindTape());

                WsbAffirmHrOk(SpaceFilemarks(tapeMarks, &addr1));
                WsbAffirmHr(SpaceToEndOfData(&addr2));
/*
                hr = SpaceFilemarks(tapeMarks, &addr1);
                if (S_OK != hr) {
                    // TODO: FIX:  Clean this up when missing EOD marker results in ERROR_NOT_FOUND.

                    // We're missing Filemarks or the EOD marker.

                    // If the EOD marker is missing the SpaceToEndOfData will again return same hr.
                    if (hr == SpaceToEndOfData(&addr2)) {
                        WsbAffirm(addr1 == addr2, MVR_E_OVERWRITE_NOT_ALLOWED);
                        WsbThrow(MVR_E_NOT_FOUND); // handled by recovery code!
                    }
                    else {
                        WsbThrow(hr); // Can't recover, just throw the original error
                    }
                }
                else {
                    WsbAffirmHr(SpaceToEndOfData(&addr2));
                }
*/
                //
                // Affirm that we are at the end of tape.
                //
                WsbAffirm(addr1 == addr2, MVR_E_OVERWRITE_NOT_ALLOWED);
                //
                // Affirm that we are starting at a consistent location.
                // Is there at least a TAPE DBLK + filemark.
                //
                WsbAffirm(addr1 > 1, MVR_E_INCONSISTENT_MEDIA_LAYOUT);

                if ( MVR_SESSION_APPEND_TO_DATA_SET & options ) {

                    WsbAffirmHr(SpaceToEndOfData(&addr1));
                    WsbAffirmHrOk(SpaceFilemarks(-2, &addr2));
                    //
                    // Affirm that we are at the end of a data set.
                    //
                    WsbAffirm(addr1-3 == addr2, MVR_E_OVERWRITE_NOT_ALLOWED);

                    // TODO: We need to read ESET/or SSET to esablish state of the
                    //       data set we're appending.

                    m_DataSetNumber = remoteDataSet;

                    // Align the stream I/O model
                    LARGE_INTEGER zero = {0,0};
                    WsbAffirmHr(Seek(zero, STREAM_SEEK_CUR, NULL));
                    break;
                }
                else {
                    // MVR_SESSION_OVERWRITE_DATA_SET
                    // MVR_SESSION_AS_LAST_DATA_SET

                    m_DataSetNumber = remoteDataSet;

                    // Align the stream I/O model
                    LARGE_INTEGER zero = {0,0};
                    WsbAffirmHr(Seek(zero, STREAM_SEEK_CUR, NULL));

                    //
                    // Convert session option type bits to MTFSessionType
                    //
                    MTFSessionType type;

                    switch (options & MVR_SESSION_TYPES) {
                    case MVR_SESSION_TYPE_TRANSFER:
                        type = MTFSessionTypeTransfer;
                        break;

                    case MVR_SESSION_TYPE_COPY:
                        type = MTFSessionTypeCopy;
                        break;

                    case MVR_SESSION_TYPE_NORMAL:
                        type = MTFSessionTypeNormal;
                        break;

                    case MVR_SESSION_TYPE_DIFFERENTIAL:
                        type = MTFSessionTypeDifferential;
                        break;

                    case MVR_SESSION_TYPE_INCREMENTAL:
                        type = MTFSessionTypeIncremental;
                        break;

                    case MVR_SESSION_TYPE_DAILY:
                        type = MTFSessionTypeDaily;
                        break;

                    default:
                        type = MTFSessionTypeCopy;
                        break;
                    }

                    
                    // Write the SSET DBLK
                    // This does not actually write anything to tape; only writes to the transfer buffer
                    WsbAffirmHr(m_pSession->DoSSETDblk(remoteSessionName, remoteSessionDescription, type, remoteDataSet));

                    // After the tape head is in the right place, we want to make sure
                    //  that we ask the driver for free space and not use internal counting
                    CComQIPtr<IRmsStorageInfo, &IID_IRmsStorageInfo> pInfo = m_pCartridge;
                    WsbAffirmPointer(pInfo);
                    WsbAffirmHr(pInfo->SetFreeSpace(-1));
                    WsbAffirmHr(GetLargestFreeSpace(NULL, NULL));
                    break;
                }

            } catch (HRESULT catchHr) {
                hr = catchHr;

                // Only allow two attempts at recovery
                WsbAffirm(retry > 1, MVR_E_INCONSISTENT_MEDIA_LAYOUT);

                if ( MVR_E_NOT_FOUND == hr) {
                    // TODO: FIX: this goes away when missing EOD marker results in ERROR_NOT_FOUND.

                    // Recovery code for missing EOD marker

                    SpaceToEndOfData(NULL);  // Redundant!
                    WsbAffirmHr(WriteFilemarks(1));

                }
                else if ( MVR_S_NO_DATA_DETECTED == hr) {
                    // Recovery code for missing end of data set.

                    try {

                        CWsbBstrPtr name;
                        CWsbBstrPtr desc;
                        if ( m_pCartridge ) {
                            m_pCartridge->GetName(&name);
                            m_pCartridge->GetDescription(&desc);
                        }

                        WsbLogEvent(MVR_MESSAGE_INCOMPLETE_DATA_SET_DETECTED, 0, NULL,
                            WsbLongAsString(startSet-1),
                            (WCHAR *) name, (WCHAR *) desc, NULL);

                        //
                        // Make the end data set conform to: filemark + ESET + filemark,
                        // for the previous session.  This may require two passes.
                        //
                        // Recoverable Exceptions:
                        //   1) Partial data set (no trailing filemark + ESET + filemark).
                        //      This occurs from power-off during Write() of data.  Two pass recovery;
                        //      write filemark, then EndSession().
                        //   2) Partial data set (filemark with no trailing ESET + filemark).
                        //      This occurs from power-off during EndSession() before ESET.
                        //      One pass recovery; EndSession();
                        //   3) Partial data set (ESET with no trailing filemark).
                        //      This occurs from power-off during EndSession() after ESET.
                        //      One pass recovery; write filemark.
                        // Non-Recoverable Exceptions detected:
                        //   a) No filemarks at expected locations.
                        //   b) No data set (no data, no trailing filemark + ESET + filemark).
                        //      This occurs from power-off after BeginSession(), but before device
                        //      buffer is flushed, and no SSET is written to tape, application
                        //      database may have recorded a successfull BeginSession().  For
                        //      this case BeginSession() returns MVR_E_DATA_SET_MISSING.
                        //   c) Blank tape, no label, no filemarks, or inconsistent tape.
                        //
                        // From ntBackup testing this apprears to be enough, in that we do not
                        // need to rebuild complete ESET info from previous SSET.  The last
                        // ControlBlockId is not required to be valid.  (Brian, 9/23/97)
                        //

                        // Detect condition (a) through (c) or some variant.
                        if ( tapeMarks-2 > 0) {
                            // Verify that EOD is not at the beginning of the previous data set.
                            WsbAffirmHr(RewindTape());
                            WsbAffirmHrOk(SpaceFilemarks(tapeMarks-2, &addr1)); // (a)
                            WsbAffirmHr(SpaceToEndOfData(&addr2));
                            if ( addr1 == addr2 ) {
                                WsbThrow(MVR_E_DATA_SET_MISSING); // (b)
                            }
                        }
                        else {
                            WsbThrow(MVR_E_INCONSISTENT_MEDIA_LAYOUT); // (c)
                        }

                        // Check for a Filemark at EOD
                        WsbAffirmHr(SpaceToEndOfData(&addr1));
                        WsbAffirmHrOk(SpaceFilemarks(-1, &addr2));
                        if (addr1-1 == addr2 ) {

                            // Align the stream I/O model to the end of the dataset;
                            // Set the stream pointer to before the Filemark that
                            // terminates the dataset and preceeds the ESET.
                            LARGE_INTEGER zero = {0,0};
                            WsbAffirmHr(Seek(zero, STREAM_SEEK_CUR, NULL));

                            // Write the trailing filemark, ESET DBLK, and filemark
                            WsbAffirmHr(m_pSession->DoEndOfDataSet( (USHORT) ( startSet - 1 ) ));

                        }
                        else {
                            WsbAffirmHr(SpaceToEndOfData(NULL));
                            WsbAffirmHr(WriteFilemarks(1));
                        }

                        WsbLogEvent(MVR_MESSAGE_DATA_SET_RECOVERED, 0, NULL, NULL);

                    } catch (HRESULT catchHr) {
                        hr = catchHr;

                        WsbLogEvent(MVR_MESSAGE_DATA_SET_NOT_RECOVERABLE, 0, NULL, WsbHrAsString(hr), NULL);
                        WsbThrow(hr);
                    } // end catch

                }
                else {
                    WsbThrow(hr);
                }
            } // end catch

        } while (retry-- > 0);


    } WsbCatchAndDo(hr,
            WsbLogEvent(MVR_MESSAGE_DATA_SET_NOT_CREATED, 0, NULL, WsbHrAsString(hr), NULL);
            (void) CloseStream();
        );


    WsbTraceOut(OLESTR("CNtTapeIo::BeginSession"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP
CNtTapeIo::EndSession(void)
/*++

Implements:

    IDataMover::EndSession

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtTapeIo::EndSession"), OLESTR(""));

    try {
        MvrInjectError(L"Inject.CNtTapeIo::EndSession.0");

        WsbAffirm(TRUE == m_ValidLabel, E_ABORT);

        // Write the trailing filemark, ESET DBLK, and filemark
        WsbAffirmHr(m_pSession->DoEndOfDataSet(m_DataSetNumber));

    } WsbCatch(hr);

    (void) CloseStream();


    WsbTraceOut(OLESTR("CNtTapeIo::EndSession"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP
CNtTapeIo::StoreData(
    IN BSTR localName,
    IN ULARGE_INTEGER localDataStart,
    IN ULARGE_INTEGER localDataSize,
    IN DWORD flags,
    OUT ULARGE_INTEGER *pRemoteDataSetStart,
    OUT ULARGE_INTEGER *pRemoteFileStart,
    OUT ULARGE_INTEGER *pRemoteFileSize,
    OUT ULARGE_INTEGER *pRemoteDataStart,
    OUT ULARGE_INTEGER *pRemoteDataSize,
    OUT DWORD *pRemoteVerificationType,
    OUT ULARGE_INTEGER *pRemoteVerificationData,
    OUT DWORD *pDatastreamCRCType,
    OUT ULARGE_INTEGER *pDatastreamCRC,
    OUT ULARGE_INTEGER *pUsn)
/*++

Implements:

    IDataMover::StoreData

--*/
{
    HRESULT hr = S_OK;

    HANDLE hSearchHandle = INVALID_HANDLE_VALUE;
    HANDLE hFile = INVALID_HANDLE_VALUE;

    WsbTraceIn(OLESTR("CNtTapeIo::StoreData"), OLESTR("<%ls> <%I64u> <%I64u> <0x%08x>"),
        WsbAbbreviatePath((WCHAR *) localName, 120), localDataStart.QuadPart, localDataSize.QuadPart, flags);

    WsbTraceAlways(OLESTR("CNtTapeIo::StoreData - Begin\n"));
    try {
        MvrInjectError(L"Inject.CNtTapeIo::StoreData.0");

        WsbAssertPointer(m_pSession);
        WsbAffirm(TRUE == m_ValidLabel, E_ABORT);

        // Default is to perform non-case sensitive searches.
        // So knock down the posix flag.
        m_Flags &= ~MVR_FLAG_POSIX_SEMANTICS;

        // Default is to not commit after each file.
        // So knock down the commit flag.
        m_Flags &= ~MVR_FLAG_COMMIT_FILE;

        // Default is to write one DIRB containing all directory info
        //  instead of writing a DIRB for each directory level.
        // So knock down the write parent dir info flag.
        m_Flags &= ~MVR_FLAG_WRITE_PARENT_DIR_INFO;

        m_Flags |= flags;
        m_Flags |= MVR_MODE_WRITE;

        // Unconditionally set the case sensitive flag for each file.
        // We allow this flag to be set on a per file basis
        WsbTrace(OLESTR("Posix Semantics Flag: <%ls>\n"), WsbBoolAsString(MVR_FLAG_POSIX_SEMANTICS & m_Flags));
        WsbAffirmHr(m_pSession->SetUseCaseSensitiveSearch(MVR_FLAG_POSIX_SEMANTICS & m_Flags));

        // This tells the session object to pad to a block boundary and flush the device
        // after the file is written.
        WsbTrace(OLESTR("Commit Flag: <%ls>\n"), WsbBoolAsString(MVR_FLAG_COMMIT_FILE & m_Flags));
        WsbAffirmHr(m_pSession->SetCommitFile(MVR_FLAG_COMMIT_FILE & m_Flags));

        WsbTrace(OLESTR("ParentDirInfo Flag: <%ls>\n"), WsbBoolAsString(MVR_FLAG_WRITE_PARENT_DIR_INFO & m_Flags));

        if ((MVR_FLAG_BACKUP_SEMANTICS & m_Flags) || (MVR_FLAG_HSM_SEMANTICS & m_Flags)) {

            // Compare the volume and path with the last ones written to tape.

            CWsbStringPtr pathname;

            WCHAR *end;
            LONG numChar;

            pathname = localName;
            WsbAffirm(0 != (WCHAR *)pathname, E_OUTOFMEMORY);

            // strip off the path and file name
            end = wcschr((WCHAR *)pathname, L'\\');
            WsbAssert(end != NULL, MVR_E_INVALIDARG);
            numChar =(LONG)(end - (WCHAR *)pathname + 1);  // keep the trailing backslash
            WsbAssert(numChar > 0, E_UNEXPECTED);
            ((WCHAR *)pathname)[numChar] = L'\0';

            // We do a case sensitive search if using Posix semantics.
            WsbTrace(OLESTR("Comparing with last volume: <%ls>\n"), WsbAbbreviatePath((WCHAR *) m_LastVolume, 120));

            if ( ((MVR_FLAG_POSIX_SEMANTICS & ~m_Flags)) && (0 != _wcsicmp((WCHAR *) m_LastVolume, (WCHAR *) pathname)) ||
                 ((MVR_FLAG_POSIX_SEMANTICS & m_Flags) && (0 != wcscmp((WCHAR *) m_LastVolume, (WCHAR *) pathname))) ) {
                // write the VOLB DBLK
                WsbAffirmHr(m_pSession->DoVolumeDblk(pathname));
                m_LastVolume = pathname;
            }

            pathname = localName;

            // strip off the file name
            end = wcsrchr((WCHAR *)pathname, L'\\');
            WsbAssert(end != NULL, MVR_E_INVALIDARG);
            numChar = (LONG)(end - (WCHAR *)pathname);
            WsbAssert(numChar > 0, E_UNEXPECTED);
            ((WCHAR *)pathname)[numChar] = L'\0';

            // pathname is now in the form "Volume{guid}\dir1\...\dirn"
            //                      or "<drive letter>:\dir1\...\dirn"

/***
   m_Flags |= MVR_FLAG_WRITE_PARENT_DIR_INFO;
***/
            WsbTrace(OLESTR("Comparing with last path: <%ls>\n"), WsbAbbreviatePath((WCHAR *) m_LastPath, 120));

            // We do a case sensitive search if using Posix semantics.
            if ( ((MVR_FLAG_POSIX_SEMANTICS & ~m_Flags)) && (0 != _wcsicmp((WCHAR *) m_LastPath, (WCHAR *) pathname)) ||
                 ((MVR_FLAG_POSIX_SEMANTICS & m_Flags) && (0 != wcscmp((WCHAR *) m_LastPath, (WCHAR *) pathname))) ) {

                if (MVR_FLAG_HSM_SEMANTICS & m_Flags) {

                    // We're not supporting this anymore!
                    WsbThrow(E_NOTIMPL);

                    WCHAR szRoot[16];
                      
                    // We use a flat file structure for MVR_FLAG_HSM_SEMANTICS
                    WsbAffirmHr(m_pSession->SetUseFlatFileStructure(TRUE));

                    // do DIRB DBLKs for root
                    wcscpy(szRoot, L"X:\\");
                    szRoot[0] = localName[0];
                    WsbAffirmHr(m_pSession->DoParentDirectories(szRoot));

                }
                else if (MVR_FLAG_WRITE_PARENT_DIR_INFO & m_Flags) {
                    // do a DIRB DBLK for each directory level of the file(s) to be backed up.
                    WsbAffirmHr(m_pSession->DoParentDirectories(pathname));
                    m_LastPath = pathname;
                }
                else {
                    // do one DIRB DBLK for the whole directory structure of the file(s) to be backed up.
                    WIN32_FIND_DATAW obFindData;
                    CWsbStringPtr tempPath;

                    DWORD additionalSearchFlags = 0;
                    additionalSearchFlags |= (m_Flags & MVR_FLAG_POSIX_SEMANTICS) ? FIND_FIRST_EX_CASE_SENSITIVE : 0;

                    tempPath = pathname;
                    tempPath.Prepend(OLESTR("\\\\?\\"));

                    if (NULL == wcschr((WCHAR *)tempPath+4, L'\\'))
                    {
                        // no path (i.e. we're at the root)
                        BY_HANDLE_FILE_INFORMATION obGetFileInfoData;
                        memset(&obGetFileInfoData, 0, sizeof(BY_HANDLE_FILE_INFORMATION));
                        tempPath.Append(OLESTR("\\"));
                        // ** WIN32 API Calls
                        WsbAffirmHandle(hFile = CreateFile(tempPath, 0, 0, NULL, OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, NULL));
                        WsbAffirmStatus(GetFileInformationByHandle(hFile, &obGetFileInfoData));
                        // copy info from GetFileInformationByHandle call (BY_HANDLE_FILE_INFORMATION struct)
                        // .. into obFindData (WIN32_FIND_DATAW struct) for DoDirectoryDblk call.
                        memset(&obFindData, 0, sizeof(WIN32_FIND_DATAW));
                        obFindData.dwFileAttributes = obGetFileInfoData.dwFileAttributes;
                        obFindData.ftCreationTime   = obGetFileInfoData.ftCreationTime;
                        obFindData.ftLastAccessTime = obGetFileInfoData.ftLastAccessTime;
                        obFindData.ftLastWriteTime  = obGetFileInfoData.ftLastWriteTime;
                    }
                    else {
                        // ** WIN32 API Call - gets file info
                        WsbAffirmHandle(hSearchHandle = FindFirstFileEx((WCHAR *) tempPath, FindExInfoStandard, &obFindData, FindExSearchLimitToDirectories, 0, additionalSearchFlags));
                    }
                    WsbAffirmHr(m_pSession->DoDirectoryDblk((WCHAR *) pathname, &obFindData)); 
                    if (hSearchHandle != INVALID_HANDLE_VALUE) {
                        FindClose(hSearchHandle);
                        hSearchHandle = INVALID_HANDLE_VALUE;
                    }
                    if (hFile != INVALID_HANDLE_VALUE) {
                        CloseHandle(hFile);
                        hFile = INVALID_HANDLE_VALUE;
                    }
                    m_LastPath = pathname;
                }
            }
        }

        // The following uses code to store multiple files, but the 
        // RS Hints is only valid for the last file.  With the current
        // implementation, the HSM engine sends one file request through
        // StoreData at a time.  The caveat is that Posix is case
        // sensitive, and therefore files created in this fashion could
        // overload the same filename (ignoring case) with multiple files.
        WsbAffirmHr(m_pSession->DoDataSet(localName));

        *pRemoteDataSetStart     = m_pSession->m_sHints.DataSetStart;
        *pRemoteFileStart        = m_pSession->m_sHints.FileStart;
        *pRemoteFileSize         = m_pSession->m_sHints.FileSize;
        *pRemoteDataStart        = m_pSession->m_sHints.DataStart;
        *pRemoteDataSize         = m_pSession->m_sHints.DataSize;
        *pRemoteVerificationType = m_pSession->m_sHints.VerificationType;
        *pRemoteVerificationData = m_pSession->m_sHints.VerificationData;
        *pDatastreamCRCType      = m_pSession->m_sHints.DatastreamCRCType;
        *pDatastreamCRC          = m_pSession->m_sHints.DatastreamCRC;
        *pUsn                    = m_pSession->m_sHints.FileUSN;

    } WsbCatchAndDo(hr,

            if (hSearchHandle != INVALID_HANDLE_VALUE) {
                FindClose(hSearchHandle);
                hSearchHandle = INVALID_HANDLE_VALUE;
            }
            if (hFile != INVALID_HANDLE_VALUE) {
                CloseHandle(hFile);
                hFile = INVALID_HANDLE_VALUE;
            }

            WsbLogEvent(MVR_MESSAGE_DATA_TRANSFER_ERROR, 0, NULL,
                WsbAbbreviatePath((WCHAR *) localName, 120), WsbHrAsString(hr), NULL);

            // All fatal device errors are converted to E_ABORT so the calling code
            // can detect this general class of problem.
            // If the device error indicates bad media, convert to a different error code.
            switch(hr) {
            case MVR_E_BUS_RESET:
            case MVR_E_MEDIA_CHANGED:
            case MVR_E_NO_MEDIA_IN_DRIVE:
            case MVR_E_DEVICE_REQUIRES_CLEANING:
            case MVR_E_SHARING_VIOLATION:
            case MVR_E_ERROR_IO_DEVICE:
            case MVR_E_ERROR_DEVICE_NOT_CONNECTED:
            case MVR_E_ERROR_NOT_READY:
                hr = E_ABORT;
                break;

            case MVR_E_INVALID_BLOCK_LENGTH:
            case MVR_E_WRITE_PROTECT:
            case MVR_E_CRC:
                hr = MVR_E_MEDIA_ABORT;
                break;

            default:
                break;
            }

        );

    WsbTraceAlways(OLESTR("CNtTapeIo::StoreData - End\n"));


    WsbTraceOut(OLESTR("CNtTapeIo::StoreData"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP
CNtTapeIo::RecallData(
    IN BSTR /*localName*/,
    IN ULARGE_INTEGER /*localDataStart*/,
    IN ULARGE_INTEGER /*localDataSize*/,
    IN DWORD /*flags*/,
    IN BSTR /*migrateFileName*/,
    IN ULARGE_INTEGER /*remoteDataSetStart*/,
    IN ULARGE_INTEGER /*remoteFileStart*/,
    IN ULARGE_INTEGER /*remoteFileSize*/,
    IN ULARGE_INTEGER /*remoteDataStart*/,
    IN ULARGE_INTEGER /*remoteDataSize*/,
    IN DWORD /*verificationType*/,
    IN ULARGE_INTEGER /*verificationData*/)
/*++

Implements:

    IDataMover::RecallData

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtTapeIo::RecallData"), OLESTR(""));

    try {
        WsbThrow(E_NOTIMPL);
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CNtTapeIo::RecallData"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP
CNtTapeIo::FormatLabel(
    IN BSTR displayName,
    OUT BSTR *pLabel)
/*++

Implements:

    IDataMover::FormatLabel

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtTapeIo::FormatLabel"), OLESTR("<%ls>"), displayName);

    try {
        MvrInjectError(L"Inject.CNtTapeIo::FormatLabel.0");

        WsbAssertPointer(pLabel);
        WsbAssertPointer(displayName);
        WsbAssert(wcslen((WCHAR *)displayName) > 0, E_INVALIDARG);
        WsbAssertPointer(m_pCartridge);

        // Media Label or Description
        CWsbBstrPtr label;

        // Tag
        label = OLESTR("MTF Media Label"); // Required text per MTF specification.

        // Version
        WsbAffirmHr(label.Append(OLESTR("|")));
        WsbAffirmHr(label.Append(WsbLongAsString(MTF_FORMAT_VER_MAJOR)));
        WsbAffirmHr(label.Append(OLESTR(".")));
        WsbAffirmHr(label.Append(WsbLongAsString(MTF_FORMAT_VER_MINOR)));

        // Vendor
        WsbAffirmHr(label.Append(OLESTR("|")));
        WsbAffirmHr(label.Append(REMOTE_STORAGE_MTF_VENDOR_NAME));

        // Vendor Product ID
        WsbAffirmHr(label.Append(OLESTR("|")));
        WsbAffirmHr(label.Append(REMOTE_STORAGE_MLL_SOFTWARE_NAME));

        // Creation Time Stamp
        WsbAffirmHr(label.Append(OLESTR("|")));
        WCHAR timeStamp[128];
        time_t lTime;
        time(&lTime);
        wcsftime(timeStamp, 128, L"%Y/%m/%d.%H:%M:%S", localtime(&lTime));
        WsbAffirmHr(label.Append(timeStamp));

        // Cartridge Label
        WsbAffirmHr(label.Append(OLESTR("|")));
        if (m_pCartridge) {

            // Use barcode if available
            CWsbBstrPtr barcode;
            if (S_OK == m_pCartridge->GetBarcode(&barcode)) {
                WsbAffirmHr(label.Append(barcode));
            }
            else {
                WsbAffirmHr(label.Append(displayName));
            }
        }
        else {
            WsbAffirmHr(label.Append(displayName));
        }

        // Side
        WsbAffirmHr(label.Append(OLESTR("|")));
        if (m_pCartridge) {

            // TODO: This is broken, we need to know if the cartridge is inverted?
            if (S_OK == m_pCartridge->IsTwoSided()) {
                WsbAffirmHr(label.Append(OLESTR("2")));
            }
            else {
                WsbAffirmHr(label.Append(OLESTR("1")));
            }
        }
        else {
            WsbAffirmHr(label.Append(OLESTR("1")));  // Default
        }

        // Media Id
        GUID cartId;
        WsbAffirmHr(label.Append(OLESTR("|")));

        if (m_pCartridge) {

            // Use cartridge Id
            if (S_OK == m_pCartridge->GetCartridgeId(&cartId)) {
                WsbAffirmHr(label.Append(WsbGuidAsString(cartId)));
            }
            else {
                WsbAffirmHr(label.Append(WsbGuidAsString(GUID_NULL)));
            }
        }
        else {
            WsbAffirmHr(label.Append(WsbGuidAsString(GUID_NULL)));
        }

        // Media Domain Id
        GUID mediaSetId;
        WsbAffirmHr(label.Append(OLESTR("|")));
        if (m_pCartridge) {

            // Use MediaSet Id
            if (S_OK == m_pCartridge->GetMediaSetId(&mediaSetId)) {
                WsbAffirmHr(label.Append(WsbGuidAsString(mediaSetId)));
            }
            else {
                WsbAffirmHr(label.Append(WsbGuidAsString(GUID_NULL)));
            }
        }
        else {
            WsbAffirmHr(label.Append(WsbGuidAsString(GUID_NULL)));
        }

        // Vendor Specific
        WsbAffirmHr(label.Append(OLESTR("|VS:DisplayName=")));
        WsbAffirmHr(label.Append(displayName));

        WsbAffirmHr(label.CopyToBstr(pLabel));

    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CNtTapeIo::FormatLabel"), OLESTR("hr = <%ls>, label = <%ls>"), WsbHrAsString(hr), *pLabel);

    return hr;
}


STDMETHODIMP
CNtTapeIo::WriteLabel(
    IN BSTR label)
/*++

Implements:

    IDataMover::WriteLabel

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtTapeIo::WriteLabel"), OLESTR("<%ls>"), label);

    try {
        MvrInjectError(L"Inject.CNtTapeIo::WriteLabel.0");

        WsbAssertPointer(label);
        WsbAssert(wcslen((WCHAR *)label) > 0, E_INVALIDARG);
        WsbAssertPointer(m_pCartridge);

        const ULONG maxIdSize = 1024;
        BYTE identifier[maxIdSize];
        ULONG idSize;
        ULONG idType;

        CComPtr<IStream> pStream;
        ULARGE_INTEGER nil = {0,0};

        // Create the remote stream.
        WsbAffirmHr(CreateRemoteStream(L"", MVR_MODE_WRITE, L"",L"",nil,nil,nil,nil,nil,0,nil, &pStream));
        WsbAssertPointer(pStream);

        // Write the TAPE DBLK and filemark
        WsbAssertPointer(m_pSession);
        WsbAffirmHr(m_pSession->DoTapeDblk(label, maxIdSize, identifier, &idSize, &idType));
        WsbAffirmHr(CloseStream());
        pStream = NULL;

        // Now verify the label
        CWsbBstrPtr tempLabel;
        WsbAffirmHr(ReadLabel(&tempLabel));
        WsbAffirmHr(VerifyLabel(tempLabel));

        // Now that the tape header is written, we update the cartridge info.
        if (m_pCartridge) {
            WsbAffirmHr(m_pCartridge->SetOnMediaLabel(label));
            WsbAffirmHr(m_pCartridge->SetOnMediaIdentifier(identifier, (LONG) idSize, (LONG) idType));
            WsbAffirmHr(m_pCartridge->SetBlockSize(m_sMediaParameters.BlockSize));
        }

    } WsbCatchAndDo(hr,
            (void) CloseStream();
        );


    WsbTraceOut(OLESTR("CNtTapeIo::WriteLabel"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP
CNtTapeIo::ReadLabel(
    IN OUT BSTR *pLabel)
/*++

Implements:

    IDataMover::ReadLabel

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtTapeIo::ReadLabel"), OLESTR(""));

    CComPtr<IStream> pStream;

    try {
        MvrInjectError(L"Inject.CNtTapeIo::ReadLabel.0");

        WsbAssertPointer(pLabel);

        // Read the MTF TAPE DBLK, and pull out the label.
        ULARGE_INTEGER nil = {0,0};

        // Create remote stream of copy
        WsbAffirmHr(CreateRemoteStream(L"", MVR_MODE_READ | MVR_MODE_UNFORMATTED, L"",L"",nil,nil,nil,nil,nil,0,nil, &pStream));
        WsbAssertPointer(pStream);

        // Read label
        CWsbStringPtr label;
        WsbAffirmHr(m_pSession->ReadTapeDblk(&label));

        WsbAffirmHr(CloseStream());
        pStream = NULL;

        WsbAffirmHr(label.CopyToBstr(pLabel));

    } WsbCatchAndDo(hr,
        if (pStream) {
            (void) CloseStream();
        }
    );

    WsbTraceOut(OLESTR("CNtTapeIo::ReadLabel"), OLESTR("hr = <%ls>, label = <%ls>"), WsbHrAsString(hr), *pLabel);

    return hr;
}


STDMETHODIMP
CNtTapeIo::VerifyLabel(
    IN BSTR label)
/*++

Implements:

    IDataMover::VerifyLabel

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtTapeIo::VerifyLabel"), OLESTR("<%ls>"), label);

    GUID mediaId[2];

    try {
        MvrInjectError(L"Inject.CNtTapeIo::VerifyLabel.0");

        WsbAssertPointer(label);
        WsbAssert(wcslen((WCHAR *)label) > 0, E_INVALIDARG);
        WsbAssertPointer(m_pCartridge);

        //
        // To verify a label we assert that the on-media Id matches the cartridge Id.
        //
        // From the media label we obtain the on-media Id.
        //
        WCHAR delim[] = OLESTR("|");
        WCHAR *token;
        int index = 0;

        token = wcstok((WCHAR *)label, delim);  // !!! This toasts the string !!!
        while( token != NULL ) {

            index++;

            switch ( index ) {
            case 1:  // Tag
            case 2:  // Version
            case 3:  // Vendor
            case 4:  // Vendor Product ID
            case 5:  // Creation Time Stamp
            case 6:  // Cartridge Label
            case 7:  // Side
                break;
            case 8:  // Media ID
                WsbGuidFromString(token, &mediaId[0]);
                break;
            case 9:  // Media Domain ID
            default: // Vendor specific of the form: L"VS:Name=Value"
                break;
            }

            token = wcstok( NULL, delim );

        }

        if (m_pCartridge) {
            //
            // Now compare on-media Id taken from the label to the cartridge's object Id.
            //
            WsbAffirmHr(m_pCartridge->GetCartridgeId(&mediaId[1]));
            WsbAffirm(mediaId[0] == mediaId[1], MVR_E_UNEXPECTED_MEDIA_ID_DETECTED);
        }

        m_ValidLabel = TRUE;

    } WsbCatchAndDo(hr,
            m_ValidLabel = FALSE;

            CWsbBstrPtr name;
            CWsbBstrPtr desc;
            if ( m_pCartridge ) {
                m_pCartridge->GetName(&name);
                m_pCartridge->GetDescription(&desc);
            }
            WsbLogEvent(MVR_MESSAGE_ON_MEDIA_ID_VERIFY_FAILED, 2*sizeof(GUID), mediaId,
                (WCHAR *) name, (WCHAR *) desc, WsbHrAsString(hr));
        );


    WsbTraceOut(OLESTR("CNtTapeIo::VerifyLabel"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP
CNtTapeIo::GetDeviceName(
    OUT BSTR *pName)
/*++

Implements:

    IDataMover::GetDeviceName

--*/
{
    HRESULT hr = S_OK;

    try {
        WsbAssertPointer(pName);

        WsbAffirmHr(m_DeviceName.CopyToBstr(pName));

    } WsbCatch( hr );

    return hr;
}


STDMETHODIMP
CNtTapeIo::SetDeviceName(
    IN BSTR name,
    IN BSTR /*unused*/)
/*++

Implements:

    IDataMover::SetDeviceName

--*/
{
    
    m_DeviceName = name;

    return S_OK;
}



STDMETHODIMP
CNtTapeIo::GetLargestFreeSpace(
    OUT LONGLONG *pFreeSpace,
    OUT LONGLONG *pCapacity,
    IN  ULONG    defaultFreeSpaceLow,
    IN  LONG     defaultFreeSpaceHigh)
/*++

Implements:

    IDataMover::GetLargestFreeSpace

Note:
  The defaultFreeSpace parameter is used by the mover to maintain internally 
  media free space in case that the device doesn't provide this information.
  If the device supports reporting on free space, then this parameter has no affect.

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtTapeIo::GetLargestFreeSpace"), OLESTR(""));

    const LONGLONG  MaxBytes = 0x7fffffffffffffff;

    LONGLONG        capacity = MaxBytes;
    LONGLONG        remaining = capacity;

    LARGE_INTEGER   defaultFreeSpace;
    if ((defaultFreeSpaceLow == 0xFFFFFFFF) && (defaultFreeSpaceHigh == 0xFFFFFFFF)) {
        defaultFreeSpace.QuadPart = -1;
    } else {
        defaultFreeSpace.LowPart = defaultFreeSpaceLow;
        defaultFreeSpace.HighPart = defaultFreeSpaceHigh;
    }

    try {
        MvrInjectError(L"Inject.CNtTapeIo::GetLargestFreeSpace.0");

        // Check if we already have valid space info for the cartridge.

        CComQIPtr<IRmsStorageInfo, &IID_IRmsStorageInfo> pInfo = m_pCartridge;

        WsbAffirmHr(pInfo->GetLargestFreeSpace(&remaining));
        WsbAffirmHr(pInfo->GetCapacity(&capacity));

        // Zero or Negative bytes remaining indicate the free space
        // may be stale, so go directly to the device for
        // the value.
        if (remaining <= 0) {

            WsbTrace(OLESTR("CNtTapeIo::GetLargestFreeSpace - Getting capacity and free-space from the device\n"));

            capacity = MaxBytes;
            remaining = capacity;

            if (INVALID_HANDLE_VALUE == m_hTape) {
                WsbAffirmHr(OpenTape());
            }

            TAPE_GET_DRIVE_PARAMETERS sDriveParameters;
            DWORD sizeOfDriveParameters = sizeof(TAPE_GET_DRIVE_PARAMETERS);
            memset(&sDriveParameters, 0, sizeOfDriveParameters);

            WsbAffirmHrOk(IsAccessEnabled());

            try {
                MvrInjectError(L"Inject.CNtTapeIo::GetLargestFreeSpace.GetTapeParameters.1.0");

                // ** WIN32 Tape API Call - get the tape drive parameters
                WsbAffirmNoError(GetTapeParameters(m_hTape, GET_TAPE_DRIVE_INFORMATION, &sizeOfDriveParameters, &sDriveParameters));

                MvrInjectError(L"Inject.CNtTapeIo::GetLargestFreeSpace.GetTapeParameters.1.1");

            } WsbCatchAndDo(hr,
                    hr = MapTapeError(hr);
                    WsbLogEvent(MVR_MESSAGE_DEVICE_ERROR, 0, NULL, WsbHrAsString(hr), NULL);
                    WsbThrow(hr);
                );

            TAPE_GET_MEDIA_PARAMETERS sMediaParameters;
            DWORD sizeOfMediaParameters = sizeof(TAPE_GET_MEDIA_PARAMETERS);
            memset(&sMediaParameters, 0, sizeOfMediaParameters);

            try {
                MvrInjectError(L"Inject.CNtTapeIo::GetLargestFreeSpace.GetTapeParameters.2.0");

                // ** WIN32 Tape API Call - get the media parameters
                WsbAffirmNoError(GetTapeParameters(m_hTape, GET_TAPE_MEDIA_INFORMATION, &sizeOfMediaParameters, &sMediaParameters));

                MvrInjectError(L"Inject.CNtTapeIo::GetLargestFreeSpace.GetTapeParameters.2.1");

            } WsbCatchAndDo(hr,
                    hr = MapTapeError(hr);
                    WsbLogEvent(MVR_MESSAGE_DEVICE_ERROR, 0, NULL, WsbHrAsString(hr), NULL);
                    WsbThrow(hr);
                );

            if ( sDriveParameters.FeaturesLow & TAPE_DRIVE_TAPE_CAPACITY ) {
                capacity = sMediaParameters.Capacity.QuadPart;
                if ( 0 == capacity ) {
                    // Bogus value!
                    capacity = MaxBytes;
                }
            }

            if ( sDriveParameters.FeaturesLow & TAPE_DRIVE_TAPE_REMAINING ) {
                remaining = sMediaParameters.Remaining.QuadPart;
            }
            else {
                // Use default value if given, otherwise, set to capacity
                if (defaultFreeSpace.QuadPart >= 0) {
                    remaining = defaultFreeSpace.QuadPart;
                } else {
                    remaining = capacity;
                }
            }

            WsbAffirmHr(pInfo->SetFreeSpace(remaining));
            WsbAffirmHr(pInfo->SetCapacity(capacity));

        }

    } WsbCatch(hr);

    // Fill in the return parameters
    if ( pCapacity ) {
        *pCapacity = capacity;
    }

    if ( pFreeSpace ) {
        *pFreeSpace = remaining;
    }

    WsbTraceOut(OLESTR("CNtTapeIo::GetLargestFreeSpace"), OLESTR("hr = <%ls>, free=%I64d, capacity=%I64d"), WsbHrAsString(hr), remaining, capacity);

    return hr;
}

STDMETHODIMP
CNtTapeIo::SetInitialOffset(
    IN ULARGE_INTEGER initialOffset
    )
/*++

Implements:

    IDataMover::SetInitialOffset

Notes:

    Set Initial stream offset (without explicitly seeking the stream to this offset)

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtTapeIo::SetInitialOffset"), OLESTR(""));

    m_StreamOffset.QuadPart = initialOffset.QuadPart;

    if (m_StreamOffset.QuadPart > m_StreamSize.QuadPart) {
        m_StreamSize = m_StreamOffset;
    }

    WsbTraceOut(OLESTR("CNtTapeIo::SetInitialOffset"), OLESTR("hr = <%ls> offset = %I64u"), WsbHrAsString(hr), initialOffset.QuadPart);

    return hr;
}


STDMETHODIMP
CNtTapeIo::GetCartridge(
    OUT IRmsCartridge **ptr)
/*++

Implements:

    IDataMover::GetCartridge

--*/
{
    HRESULT hr = S_OK;

    try {

        WsbAssertPointer( ptr );

        *ptr = m_pCartridge;
        m_pCartridge->AddRef();

    } WsbCatch( hr );

    return hr;
}


STDMETHODIMP
CNtTapeIo::SetCartridge(
    IN IRmsCartridge *ptr)
/*++

Implements:

    IDataMover::SetCartridge

--*/
{
    HRESULT hr = S_OK;

    try {
        WsbAssertPointer( ptr );

        if ( m_pCartridge )
            m_pCartridge = 0;

        m_pCartridge = ptr;

    } WsbCatch( hr );

    return hr;
}


STDMETHODIMP
CNtTapeIo::Cancel(void)
/*++

Implements:

    IDataMover::Cancel

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtTapeIo::Cancel"), OLESTR(""));

    try {

        (void) Revert();
        (void) CloseStream();
        (void) CloseTape();

    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CNtTapeIo::Cancel"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP
CNtTapeIo::CreateLocalStream(
    IN BSTR /*name*/,
    IN DWORD /*mode*/,
    OUT IStream ** /*ppStream*/)
/*++

Implements:

    IDataMover::CreateLocalStream

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtTapeIo::CreateLocalStream"), OLESTR(""));

    try {
        WsbThrow(E_NOTIMPL);
    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CNtTapeIo::CreateLocalStream"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP
CNtTapeIo::CreateRemoteStream(
    IN BSTR name,
    IN DWORD mode,
    IN BSTR remoteSessionName,
    IN BSTR remoteSessionDescription,
    IN ULARGE_INTEGER remoteDataSetStart,
    IN ULARGE_INTEGER remoteFileStart,
    IN ULARGE_INTEGER remoteFileSize,
    IN ULARGE_INTEGER remoteDataStart,
    IN ULARGE_INTEGER remoteDataSize,
    IN DWORD remoteVerificationType,
    IN ULARGE_INTEGER remoteVerificationData,
    OUT IStream **ppStream)
/*++

Implements:

    IDataMover::CreateRemoteStream

--*/
{
    UNREFERENCED_PARAMETER(remoteSessionName);
    UNREFERENCED_PARAMETER(remoteSessionDescription);

    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtTapeIo::CreateRemoteStream"),
        OLESTR("<%ls> <0x%08x> <%I64u> <%I64u> <%I64u> <%I64u> <%I64u> <0x%08x> <0x%08x> <0x%08x> <0x%08x>"),
        name, mode, remoteDataSetStart.QuadPart, remoteFileStart.QuadPart, remoteFileSize.QuadPart,
        remoteDataStart.QuadPart, remoteDataSize.QuadPart, remoteVerificationType,
        remoteVerificationData.LowPart, remoteVerificationData.HighPart, ppStream);

    try {
        WsbAssertPointer(ppStream);

        MvrInjectError(L"Inject.CNtTapeIo::CreateRemoteStream.0");

        if (INVALID_HANDLE_VALUE == m_hTape) {
            WsbAffirmHr(OpenTape());
        }
        WsbAffirmHrOk(IsAccessEnabled());

        WsbAssert(m_sMediaParameters.BlockSize > 0, MVR_E_LOGIC_ERROR);

        m_StreamName = name;
        m_Mode = mode;

        m_StreamPBA.QuadPart = 0xffffffffffffffff;
        m_StreamOffset.QuadPart = 0;
        m_StreamSize.QuadPart = remoteDataSize.QuadPart;

        WsbAssert(NULL == m_pStreamBuf, MVR_E_LOGIC_ERROR); // We forgot a CloseStream somewhere

        // We need to allocate memory for the internal buffer used to handle
        // odd byte (non-block) size I/O requests.  At a minumum we make the
        // buffer 2x the block size.

        ULONG bufferSize;
        ULONG nBlocks = DefaultMinBufferSize/m_sMediaParameters.BlockSize;

        nBlocks = (nBlocks < 2) ? 2 : nBlocks;
        bufferSize = nBlocks * m_sMediaParameters.BlockSize;

        WsbTrace( OLESTR("Using %d byte internal buffer.\n"), bufferSize);

        m_pStreamBuf = (BYTE *) WsbAlloc(bufferSize);
        WsbAssertPointer(m_pStreamBuf);
        memset(m_pStreamBuf, 0, bufferSize);
        m_StreamBufSize = bufferSize;
        m_StreamBufUsed = 0;
        m_StreamBufPosition = 0;
        m_StreamBufStartPBA.QuadPart = 0;
       
        if (m_pCartridge) {
            if ( S_OK == m_pCartridge->LoadDataCache(m_pStreamBuf, &m_StreamBufSize, &m_StreamBufUsed, &m_StreamBufStartPBA) ) {
                WsbTrace( OLESTR("DataCache loaded.\n"));
            }
        }

        CComPtr<IStream> pStream;
        WsbAssertHrOk(((IUnknown*) (IDataMover*) this)->QueryInterface( IID_IStream, (void **) &pStream));

        WsbAssert(NULL == m_pSession, MVR_E_LOGIC_ERROR);
        m_pSession = new CMTFSession();
        WsbAssertPointer(m_pSession);

        m_pSession->m_pStream = pStream;

        m_pSession->m_sHints.DataSetStart.QuadPart = remoteDataSetStart.QuadPart;
        m_pSession->m_sHints.FileStart.QuadPart = remoteFileStart.QuadPart;
        m_pSession->m_sHints.FileSize.QuadPart = remoteFileSize.QuadPart;
        m_pSession->m_sHints.DataStart.QuadPart = remoteDataStart.QuadPart;
        m_pSession->m_sHints.DataSize.QuadPart = remoteDataSize.QuadPart;
        m_pSession->m_sHints.VerificationType = remoteVerificationType;
        m_pSession->m_sHints.VerificationData.QuadPart = remoteVerificationData.QuadPart;

        // Set the Block Size used for the session.
        WsbAffirmHr(m_pSession->SetBlockSize(m_sMediaParameters.BlockSize));

        if (m_Mode & MVR_MODE_APPEND) {
            // Sets the current position to the end of data.
            LARGE_INTEGER zero = {0,0};
            WsbAffirmHr(pStream->Seek(zero, STREAM_SEEK_END, NULL));
        }

        *ppStream = pStream;
        pStream->AddRef();

    } WsbCatchAndDo(hr,
            (void) CloseStream();
        );


    WsbTraceOut(OLESTR("CNtTapeIo::CreateRemoteStream"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP
CNtTapeIo::CloseStream(void)
/*++

Implements:

    IDataMover::CloseStream

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtTapeIo::CloseStream"), OLESTR("StreamName=<%ls>"), m_StreamName);

    try {

        //
        // For unformatted I/O we add filemark on close
        //
        if (m_Mode & MVR_MODE_UNFORMATTED) {
            if ((m_Mode & MVR_MODE_WRITE) || (m_Mode & MVR_MODE_APPEND)) {
                try {
                    WsbAffirmHr(WriteFilemarks(1));
                } WsbCatch(hr);
            }
        }

        //
        // If we may have written to tape, sync up the space stats
        // to reflect what device reports.
        //
        if ((m_Mode & MVR_MODE_WRITE) || (m_Mode & MVR_MODE_APPEND)) {
            try {
                CComQIPtr<IRmsStorageInfo, &IID_IRmsStorageInfo> pInfo = m_pCartridge;
                // marking the FreeSpace to -1 gaurantees it's stale for the
                // following GetLargestFreeSpace() call.
                WsbAffirmPointer(pInfo);
                WsbAffirmHr(pInfo->SetFreeSpace(-1));
                WsbAffirmHr(GetLargestFreeSpace(NULL, NULL));
            } WsbCatchAndDo(hr,
                hr = S_OK;
                );

        }

        //
        // Since the stream is closed, we re-init stream member data.
        //
        m_StreamName = MVR_UNDEFINED_STRING;
        m_Mode = 0;

        if (m_pSession) {
            delete m_pSession;
            m_pSession = NULL;
        }

        if (m_pStreamBuf) {

            //
            // Save of the internal buffer to the cartridge.
            //

            if ( S_OK == m_pCartridge->SaveDataCache(m_pStreamBuf, m_StreamBufSize, m_StreamBufUsed, m_StreamBufStartPBA) ) {
                WsbTrace(OLESTR("DataCache saved.\n"));
            }

            // Clear internal buffer state
            WsbFree(m_pStreamBuf);
            m_pStreamBuf = NULL;
            m_StreamBufSize = 0;
            m_StreamBufUsed = 0;
            m_StreamBufPosition = 0;
            m_StreamBufStartPBA.QuadPart = 0;
        }

    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CNtTapeIo::CloseStream"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}



STDMETHODIMP
CNtTapeIo::Duplicate(
    IN IDataMover *pCopy,
    IN DWORD options,
    OUT ULARGE_INTEGER *pBytesCopied,
    OUT ULARGE_INTEGER *pBytesReclaimed)
/*++

Implements:

    IDataMover::Duplicate

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtTapeIo::Duplicate"), OLESTR("<0x%08x>"), options);

    CComPtr<IStream> pOriginalStream;
    CComPtr<IStream> pCopyStream;
    ULARGE_INTEGER bytesCopied = {0,0};
    ULARGE_INTEGER bytesReclaimed = {0,0};

    try {
        MvrInjectError(L"Inject.CNtTapeIo::Duplicate.0");

        ULARGE_INTEGER nil = {0,0};
        ULARGE_INTEGER position = {0,0};
        LARGE_INTEGER zero = {0,0};
        LARGE_INTEGER seekTo = {0,0};

        ULARGE_INTEGER originalEOD = {0,0};
        ULARGE_INTEGER copyEOD = {0,0};

        ULARGE_INTEGER bytesRead = {0,0};
        ULARGE_INTEGER bytesWritten = {0,0};

        BOOL refresh = ( options & MVR_DUPLICATE_REFRESH ) ? TRUE : FALSE;

        BOOL moreToCopy = TRUE;

        // Duplicate the unit of media.
        // MVR_DUPLICATE_UPDATE     - starts from the end of the copy.
        // MVR_DUPLICATE_REFRESH    - starts from the beginning of the original (except tape header)

        while ( moreToCopy ) {
            // We copy the SSET, data, and ESET as individual streams, and continue
            // until there's nothing more to copy.

            if ( refresh ) {
                ULONG bytesRead;

                // Create remote stream of copy
                WsbAffirmHr(pCopy->CreateRemoteStream(L"Copy", MVR_MODE_WRITE | MVR_MODE_UNFORMATTED, L"",L"",nil,nil,nil,nil,nil,0,nil, &pCopyStream));
                WsbAssertPointer(pCopyStream);

                // Sets the current position to beginning of data.
                WsbAffirmHr(pCopyStream->Seek(zero, STREAM_SEEK_SET, &position));

                // The MTF labels are < 1024 bytes.  We need to read 1024 bytes + the filemark
                // (1 block), 3x the min block size covers all cases.
                WsbAssert(m_sMediaParameters.BlockSize > 0, MVR_E_LOGIC_ERROR);

                ULONG nBlocks = (3*512)/m_sMediaParameters.BlockSize;
                nBlocks = (nBlocks < 2) ? 2 : nBlocks;

                ULONG bytesToRead = nBlocks * m_sMediaParameters.BlockSize;

                BYTE *pBuffer = (BYTE *)WsbAlloc(bytesToRead);
                WsbAssertPointer(pBuffer);
                memset(pBuffer, 0, bytesToRead);

                // Read upto first Filemark to skip over header.
                hr = pCopyStream->Read(pBuffer, bytesToRead, &bytesRead);
                WsbFree(pBuffer);
                pBuffer = NULL;
                WsbAssert(hr == MVR_S_FILEMARK_DETECTED, E_UNEXPECTED);

                // Gets the current position... this is the low water mark of the copy.
                WsbAffirmHr(pCopyStream->Seek(zero, STREAM_SEEK_CUR, &position));
                refresh = FALSE;
            }
            else {
                // Create remote stream of copy
                WsbAffirmHr(pCopy->CreateRemoteStream(L"Copy", MVR_MODE_APPEND | MVR_MODE_UNFORMATTED, L"",L"",nil,nil,nil,nil,nil,0,nil, &pCopyStream));
                WsbAssertPointer(pCopyStream);

                // Gets the current position... this is the low water mark of the copy.
                WsbAffirmHr(pCopyStream->Seek(zero, STREAM_SEEK_CUR, &position));
            }

            // Create remote stream or original
            WsbAffirmHr(CreateRemoteStream(L"Master", MVR_MODE_READ | MVR_MODE_UNFORMATTED, L"",L"",nil,nil,nil,nil,nil,0,nil, &pOriginalStream));
            WsbAssertPointer(pOriginalStream);

            // Set the current position to the high water mark.
            seekTo.QuadPart = position.QuadPart;
            WsbAffirmHr(pOriginalStream->Seek( seekTo, STREAM_SEEK_SET, NULL));

            // Now both streams are aligned for the copy.
            ULARGE_INTEGER bytesToCopy = {0xffffffff, 0xffffffff};

            // Copy from original to copy until we don't having anything more to read.
            hr = pOriginalStream->CopyTo(pCopyStream, bytesToCopy, &bytesRead, &bytesWritten);
            bytesCopied.QuadPart += bytesWritten.QuadPart;
            if ( FAILED(hr) ) {
                WsbThrow(hr);
            }

            if ( MVR_S_FILEMARK_DETECTED == hr ) {
                WsbAffirmHr(pCopy->CloseStream());
                pCopyStream = 0;
            }
            else {
                // End of data
                WsbAssert(MVR_S_NO_DATA_DETECTED == hr, E_UNEXPECTED);
                moreToCopy = FALSE;

                //
                // Verify we're where we think we are..
                //
                // We should always have an EOD on the copy. So affirm OK.
                //
                WsbAffirmHrOk(pCopyStream->Seek(zero, STREAM_SEEK_END, &copyEOD));
                //
                // A missing EOD which gets translated to MVR_S_NO_DATA_DETECTED, or MVR_E_CRC,
                // should not cause us to fail on the Seek.
                //
                HRESULT hrSeek = Seek(zero, STREAM_SEEK_END, &originalEOD);
                WsbAffirm(originalEOD.QuadPart == copyEOD.QuadPart, (S_OK == hrSeek) ? E_ABORT : hrSeek);

                // When we get EOD we don't write a FM, so revert RW Mode to prevent
                // Filemarks from being written.  This leaves the copy in an identical
                // state with the master.

                pCopyStream->Revert();
                WsbAffirmHr(pCopy->CloseStream());
                pCopyStream = 0;
                hr = S_OK;  // Normal completion
            }

            WsbAffirmHr(CloseStream());
            pOriginalStream = 0;

        }


    } WsbCatchAndDo(hr,
            // Revert resets the RW Mode to prevent Filemarks from being written
            // after a copy error.
            if (pCopyStream) {
                pCopyStream->Revert();
                pCopy->CloseStream();
            }
            if (pOriginalStream) {
                pOriginalStream->Revert();
            }
            CloseStream();
        );

    if ( pBytesCopied ) {
        pBytesCopied->QuadPart = bytesCopied.QuadPart;
    }
    if ( pBytesReclaimed ) {
        pBytesReclaimed->QuadPart = bytesReclaimed.QuadPart;
    }

    WsbTraceOut(OLESTR("CNtTapeIo::Duplicate"), OLESTR("hr = <%ls>, bytesCopied=%I64u, bytesReclaimed=%I64u"),
        WsbHrAsString(hr), bytesCopied.QuadPart, bytesReclaimed.QuadPart);

    return hr;
}



STDMETHODIMP
CNtTapeIo::FlushBuffers(void)
/*++

Implements:

    IDataMover::FlushBuffers

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtTapeIo::FlushBuffers"), OLESTR(""));

    try {
        MvrInjectError(L"Inject.CNtTapeIo::FlushBuffers.0");

        WsbAffirm(TRUE == m_ValidLabel, E_ABORT);

        // Pad to the next physical block boundary and flush the device bufffer.
        WsbAffirmHr(m_pSession->ExtendLastPadToNextPBA());

    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CNtTapeIo::FlushBuffers"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}

STDMETHODIMP
CNtTapeIo::Recover(OUT BOOL *pDeleteFile)
/*++

Implements:

    IDataMover::Recover

--*/
{
    HRESULT hr = S_OK;
    *pDeleteFile = FALSE;
    WsbTraceIn(OLESTR("CNtTapeIo::Recover"), OLESTR(""));

    try {
        // Note: Recovery of the tape stream is done explicitly in BeginSession
        //  We might consider moving this code over here...
        WsbThrow(E_NOTIMPL);
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CNtTapeIo::Recover"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}

////////////////////////////////////////////////////////////////////////////////
//
// IStream Implementation
//


STDMETHODIMP
CNtTapeIo::Read(
    OUT void *pv,
    IN ULONG cb,
    OUT ULONG *pcbRead
    )
/*++

Implements:

    IStream::Read

Notes:

    Only MVR_FLAG_HSM_SEMANTICS is currently supported.

    Returns S_FALSE when no more data can be read from the stream.  EOD or FILEMARK Detected.

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtTapeIo::Read"), OLESTR("Bytes Requested = %u, offset = %I64u, mode = 0x%08x"), cb, m_StreamOffset.QuadPart, m_Mode);

    ULONG bytesRead = 0;
    ULONG bytesToCopy = 0;
    ULONG bytesToRead = 0;

    try {
        MvrInjectError(L"Inject.CNtTapeIo::Read.0");

        WsbAssert( pv != 0, STG_E_INVALIDPOINTER );

        BOOL bUseInternalBuffer = FALSE;
        ULONG offsetToData = 0;
        ULARGE_INTEGER pba = {0,0};

        if ( MVR_FLAG_HSM_SEMANTICS & m_Mode ) {
            //
            // The m_DataStart field will point to the actual start of the data stream.
            // The MTF stream header will be a few bytes before that.
            //
            if ( MVR_VERIFICATION_TYPE_NONE == m_pSession->m_sHints.VerificationType ) {
                //
                // No verification - no stream header
                //
                pba.QuadPart = ( m_pSession->m_sHints.DataSetStart.QuadPart +
                                 m_pSession->m_sHints.FileStart.QuadPart +
                                 m_pSession->m_sHints.DataStart.QuadPart +
                                 m_StreamOffset.QuadPart )
                                    / m_sMediaParameters.BlockSize;

                offsetToData = (ULONG) (( m_pSession->m_sHints.DataSetStart.QuadPart + 
                                            m_pSession->m_sHints.FileStart.QuadPart + 
                                            m_pSession->m_sHints.DataStart.QuadPart +
                                            m_StreamOffset.QuadPart)
                                        % (unsigned _int64) m_sMediaParameters.BlockSize);
                bytesToRead = cb + offsetToData;
            }
            else if (MVR_VERIFICATION_TYPE_HEADER_CRC == m_pSession->m_sHints.VerificationType ) {
                //
                // Position to the stream header and crc it first.
                //
                pba.QuadPart = (m_pSession->m_sHints.DataSetStart.QuadPart + 
                                m_pSession->m_sHints.FileStart.QuadPart + 
                               (m_pSession->m_sHints.DataStart.QuadPart - sizeof(MTF_STREAM_INFO)) ) 
                               / m_sMediaParameters.BlockSize;

                offsetToData = (ULONG) (( m_pSession->m_sHints.DataSetStart.QuadPart + 
                                            m_pSession->m_sHints.FileStart.QuadPart + 
                                            m_pSession->m_sHints.DataStart.QuadPart +
                                            m_StreamOffset.QuadPart
                                            - sizeof(MTF_STREAM_INFO))
                                        % (unsigned _int64) m_sMediaParameters.BlockSize);
                bytesToRead = cb + offsetToData + sizeof(MTF_STREAM_INFO);
            } 
            else {
                WsbThrow( E_UNEXPECTED );
            }
        }
        else if ( MVR_MODE_UNFORMATTED & m_Mode ) {

            pba.QuadPart = m_StreamOffset.QuadPart
                / m_sMediaParameters.BlockSize;

            offsetToData = (ULONG) ((m_StreamOffset.QuadPart) 
                % (unsigned _int64) m_sMediaParameters.BlockSize);
            bytesToRead = cb + offsetToData;
        }
        else {
            WsbThrow( E_UNEXPECTED );
        }

        //
        // Check if the current read request requires a tape access
        //

        if (// pba starts before the internal buffer, OR
            (pba.QuadPart < m_StreamBufStartPBA.QuadPart) ||
            // pba starts beyond the internal buffer, OR
            (pba.QuadPart >= (m_StreamBufStartPBA.QuadPart + (m_StreamBufUsed / m_sMediaParameters.BlockSize)))  ||
            // the internal buffer is not valid.
            (!m_StreamBufUsed) ) {

            //
            // Then, we must read data from tape
            //

            //
            // Set Position
            //
            if ( pba.QuadPart != m_StreamPBA.QuadPart ) {
                //
                // AffirmOk to fail if EOD reached before desired pba.
                //
                WsbAffirmHrOk(SetPosition(pba.QuadPart));
            }

            // We should now be positioned at the beginning of the block containing
            // the start of the stream OR at the beginning of data.

            //
            // Read data
            //
            // We can use the output buffer if the offset and size are aligned 
            // on block boundaries and there is no verification , otherwise we must use 
            // the internal stream buffer.
            //

            if ( (MVR_VERIFICATION_TYPE_NONE != m_pSession->m_sHints.VerificationType ) ||
                 (offsetToData) ||
                 (cb % m_sMediaParameters.BlockSize) ) {

                /*****************************************
                !!! Old Method !!!
                if ( bytesToRead < m_StreamBufSize ) {
                    //  Round up the number of bytes to read so we read full blocks
                    bytesToRead = bytesToRead + m_sMediaParameters.BlockSize - 
                            (bytesToRead % m_sMediaParameters.BlockSize);
                }
                *****************************************/
                bytesToRead = m_StreamBufSize;

                WsbTrace(OLESTR("Reading %u (%u) bytes...\n"), bytesToRead, m_StreamBufSize);
                m_StreamBufStartPBA = pba;
                hr = ReadBuffer(m_pStreamBuf, bytesToRead, &bytesRead);
                if ( FAILED(hr) ) {
                    m_StreamBufUsed = 0;
                    WsbThrow(hr)
                }
                bUseInternalBuffer = TRUE;
                m_StreamBufUsed = bytesRead;

                //
                // Do the verification here, if needed
                //

                if (MVR_VERIFICATION_TYPE_HEADER_CRC == m_pSession->m_sHints.VerificationType ) {

                    MTF_STREAM_INFO sSTREAM;
                    WIN32_STREAM_ID sStreamHeader;      // comes back from Win32 BackupRead

                    //
                    // If we're positioned before a tapemark, the read will succeed,
                    // but no bytes will have been read.  This shouldn't happen when
                    // recalling data.
                    //
                    WsbAssert(bytesRead > 0, MVR_E_UNEXPECTED_DATA);

                    ///////////////////////////////////////////////////////////////////////////////////////
                    //
                    // TODO: Special code for when:
                    //          offsetToData + sizeof(MTF_STREAM_INFO) > nBytesRead
                    //
                    // IMPORTANT NOTE:  In theory this special case should be possible,
                    //                  but this has never been observed, so we assert
                    //                  to test the special case logic.
                    WsbAssert(offsetToData < bytesRead, MVR_E_UNEXPECTED_DATA);
                    WsbAssert((offsetToData + sizeof(MTF_STREAM_INFO)) <= bytesRead, MVR_E_UNEXPECTED_DATA);
                    //
                    // TODO: Now that we asserted, let's see if the code to handle this case works!
                    //
                    ///////////////////////////////////////////////////////////////////////////////////////
    
    
                    if ( (offsetToData + sizeof(MTF_STREAM_INFO)) <= bytesRead ) {
                        CMTFApi::MTF_ReadStreamHeader(&sSTREAM, &m_pStreamBuf[offsetToData]);
                        offsetToData += sizeof(MTF_STREAM_INFO);
                    }
                    else {
                        LONG nBytes;
    
                        nBytes = bytesRead - offsetToData;
    
                        // if nBytes is negative the FILE DBLK is larger the the buffer
                        // and I don't think this is possible?
                        WsbAssert(nBytes >= 0, MVR_E_LOGIC_ERROR);
    
                        if (nBytes) {
                            memcpy( &sSTREAM, &m_pStreamBuf[offsetToData], nBytes);
                        }
    
                        m_StreamOffset.QuadPart += nBytes;
                        m_StreamBufStartPBA = pba;
                        hr = ReadBuffer(m_pStreamBuf, m_StreamBufSize, &bytesRead);
                        if ( FAILED(hr) ) {
                            m_StreamBufUsed = 0;
                            WsbThrow(hr)
                        }
                        m_StreamBufUsed = bytesRead;
    
                        memcpy( &sSTREAM+nBytes, m_pStreamBuf, sizeof(MTF_STREAM_INFO)-nBytes);
                        offsetToData = sizeof(MTF_STREAM_INFO) - nBytes;
                    }
    

                    // Convert STREAM to WIN32 streamID
                    CMTFApi::MTF_SetStreamIdFromSTREAM(&sStreamHeader, &sSTREAM, 0);

                    try {
                        // Make sure it is the correct type of header
                        WsbAffirm((0 == memcmp(sSTREAM.acStreamId, "STAN", 4)), MVR_E_UNEXPECTED_DATA);

                        // Verify the stream header checksum
                        WsbAffirm((m_pSession->m_sHints.VerificationData.QuadPart == sSTREAM.uCheckSum), MVR_E_UNEXPECTED_DATA);
                    } catch (HRESULT catchHr) {
                        hr = catchHr;

                        //
                        // Log the error.
                        //
                        // This is an unrecoverable recall error.  We need to put as much info
                        // in the event log to handle the probable service call.
                        //
                        // We try to output at least MaxBytes starting with the stream
                        // header to give a clue of what we tried to recall.  If there isn't
                        // enough data through the end of the buffer we back out until we
                        // get upto MaxBytes and record the expected location of the stream
                        // header in the event message.
                        //
                        const int MaxBytes = 4*1024;                        // Max data bytes to log
                        int size = 0;                                       // Size of data to be logged.
                        int loc = 0;                                        // location of start of bogus stream header in log data       
                        int start = offsetToData - sizeof(MTF_STREAM_INFO); // start of log data relativet the data buffer.
                        int nBytes = bytesRead - start;                     // Number of bytes through the end of the data buffer
                        if (nBytes < MaxBytes) {
                            // Adjust the start/location
                            start = bytesRead - MaxBytes;
                            if (start < 0) {
                                start = 0;
                            }
                            nBytes = bytesRead - start;
                            loc = offsetToData - sizeof(MTF_STREAM_INFO) - start;
                        }

                        // Allocate and copy data to log

                        // Only copy user data when building debug code
                        if ( MVR_DEBUG_OUTPUT ) {
                            size = nBytes < MaxBytes ? nBytes : MaxBytes;
                        }

                        unsigned char *data = (unsigned char *) WsbAlloc(size + sizeof(MVR_REMOTESTORAGE_HINTS));

                        if (data) {
                            memset(data, 0, size + sizeof(MVR_REMOTESTORAGE_HINTS));
                            if ( MVR_DEBUG_OUTPUT ) {
                                memcpy(&data[0], &m_pStreamBuf[start], size);
                            }

                            memcpy(&data[size], &m_pSession->m_sHints, sizeof(MVR_REMOTESTORAGE_HINTS));
                            size += sizeof(MVR_REMOTESTORAGE_HINTS);
                        }
                        else {
                            size = 0;
                        }

                        //
                        // Output the message and data to the event log.
                        //
                        CWsbBstrPtr name;
                        CWsbBstrPtr desc;

                        if (m_pCartridge) {
                            m_pCartridge->GetName(&name);
                            m_pCartridge->GetDescription(&desc);
                        }

                        WCHAR location[16];
                        WCHAR offset[16];
                        WCHAR mark[16];
                        WCHAR found[16];

                        swprintf(found, L"0x%04x", sSTREAM.uCheckSum);
                        swprintf(location, L"%I64u", pba.QuadPart);
                        swprintf(offset, L"%d", offsetToData - sizeof(MTF_STREAM_INFO));
                        swprintf(mark, L"0x%04x", loc);

                        WsbLogEvent(MVR_MESSAGE_UNEXPECTED_DATA,
                            size, data,
                            found,
                            (WCHAR *) name,
                            (WCHAR *) desc,
                            location, offset, mark,
                            NULL);

                        if (data) {
                            WsbFree(data);
                            data = NULL;
                        }

                        WsbThrow(hr);
                    }

                    //
                    // Set the verification type to none so we only do this once
                    //
                    m_pSession->m_sHints.VerificationType = MVR_VERIFICATION_TYPE_NONE;
                }
            }
            else {
                WsbTrace(OLESTR("Reading %u bytes.\n"), cb);
                hr = ReadBuffer((BYTE *) pv, cb, &bytesRead);
                if ( FAILED(hr) ) {
                    WsbThrow(hr)
                }
                else {
                    switch (hr) {
                    case MVR_S_FILEMARK_DETECTED:
                    case MVR_S_SETMARK_DETECTED:
                        m_StreamOffset.QuadPart += (unsigned _int64) m_sMediaParameters.BlockSize;
                        break;
                    }
                }
            }
        }
        else {
            bUseInternalBuffer = TRUE;

            // We need to re-calculate the offset relative the internal buffer.
            // The orginal offset is the offset from the beginning of the nearest
            // block.  We need an offset relative the beginning of the internal buffer.

            offsetToData += (ULONG)((pba.QuadPart - m_StreamBufStartPBA.QuadPart)*(unsigned _int64) m_sMediaParameters.BlockSize);
            
            // !!!TEMPORARY 
            if (MVR_VERIFICATION_TYPE_HEADER_CRC == m_pSession->m_sHints.VerificationType ) {
                offsetToData += sizeof(MTF_STREAM_INFO);
            }
            m_pSession->m_sHints.VerificationType = MVR_VERIFICATION_TYPE_NONE;
        }

        if ( bUseInternalBuffer ) {
            //
            // Just copy the previously read data from the internal stream buffer.
            //
            ULONG maxBytesToCopy;
            maxBytesToCopy = m_StreamBufUsed - offsetToData;

            bytesToCopy = ( cb < maxBytesToCopy ) ? cb : maxBytesToCopy;
            memcpy( pv, &m_pStreamBuf[offsetToData], bytesToCopy );
            bytesRead = bytesToCopy;

        }

        m_StreamOffset.QuadPart += bytesRead;

        if ( pcbRead ) {
            *pcbRead = bytesRead;
        }

    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CNtTapeIo::Read"), OLESTR("hr = <%ls> bytes Read = %u, new offset = %I64u"), WsbHrAsString(hr), bytesRead, m_StreamOffset.QuadPart);

    return hr;
}


STDMETHODIMP
CNtTapeIo::Write(
    OUT void const *pv,
    IN ULONG cb,
    OUT ULONG *pcbWritten)
/*++

Implements:

    IStream::Write

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtTapeIo::Write"), OLESTR("Bytes Requested = %u, offset = %I64u, mode = 0x%08x"), cb, m_StreamOffset.QuadPart, m_Mode);

    ULONG bytesWritten = 0;

    try {
        MvrInjectError(L"Inject.CNtTapeIo::Write.0");

        WsbAssert(pv != 0, STG_E_INVALIDPOINTER);
        UINT64 pos = m_StreamOffset.QuadPart / m_sMediaParameters.BlockSize;

        int retry;
        const int delta = 10;
        const int MaxRetry = 0;  // TODO:  This needs work; disabled for now.

        retry = 0;
        do {
            try {
                // Consistency Check
                // WsbAffirmHr(EnsurePosition(pos));

                // UINT64 curPos;
                // WsbAffirmHr(GetPosition(&curPos));  // This kills DLT performance
                // WsbAssert(curPos == m_StreamOffset.QuadPart / m_sMediaParameters.BlockSize, E_UNEXPECTED);

                // Can't retry if part of the buffer has already been written.
                WsbAssert(0 == bytesWritten, E_ABORT);

                WsbAffirmHr(WriteBuffer((BYTE *) pv, cb, &bytesWritten));
                if (retry > 0) {
                    WsbLogEvent(MVR_MESSAGE_RECOVERABLE_DEVICE_ERROR_RECOVERED, sizeof(retry), &retry, NULL);
                }
                break;
            } WsbCatchAndDo(hr,
                    switch (hr) {
                    // Can't recover from these since they indicate the media may have changed,
                    // or device parameters are reset to defaults.
                    /**************************************
                    case MVR_E_BUS_RESET:
                    case MVR_E_MEDIA_CHANGED:
                    case MVR_E_NO_MEDIA_IN_DRIVE:
                    case MVR_E_ERROR_DEVICE_NOT_CONNECTED:
                    case MVR_E_ERROR_IO_DEVICE:
                    **************************************/

                    // This may still be unsafe... not sure if partial i/o completes
                    case MVR_E_CRC:
                        if (retry < MaxRetry) {
                            WsbLogEvent(MVR_MESSAGE_RECOVERABLE_DEVICE_ERROR_DETECTED, sizeof(retry), &retry, NULL);
                            WsbTrace(OLESTR("Waiting for device to come ready - Seconds remaining before timeout: %d\n"), retry*delta);
                            Sleep(delta*1000); // Sleep a few seconds to give the device time to quite down... This may be useless!
                            hr = S_OK;
                        }
                        else {
                            WsbLogEvent(MVR_MESSAGE_UNRECOVERABLE_DEVICE_ERROR, sizeof(retry), &retry, WsbHrAsString(hr), NULL);
                            WsbThrow(hr);
                        }
                        break;

                    // Can't do anything about this one... just quietly fail.
                    case MVR_E_END_OF_MEDIA:
                        WsbThrow(hr);
                        break;

                    default:
                        WsbLogEvent(MVR_MESSAGE_UNRECOVERABLE_DEVICE_ERROR, sizeof(retry), &retry, WsbHrAsString(hr), NULL);
                        WsbThrow(hr);
                        break;
                    }
                );
        } while (++retry < MaxRetry);

    } WsbCatch(hr);

    if (pcbWritten) {
        *pcbWritten = bytesWritten;
    }

    // Now update the storage info stats for the cartridge.
    CComQIPtr<IRmsStorageInfo, &IID_IRmsStorageInfo> pInfo = m_pCartridge;
    if (pInfo) {
        pInfo->IncrementBytesWritten(bytesWritten);
    }

    // Update the stream model
    m_StreamOffset.QuadPart += bytesWritten;
    m_StreamSize = m_StreamOffset; // For tape this is always true

    WsbTraceOut(OLESTR("CNtTapeIo::Write"), OLESTR("hr = <%ls>, bytesWritten=%u"), WsbHrAsString(hr), bytesWritten);

    return hr;
}


STDMETHODIMP
CNtTapeIo::Seek(
    IN LARGE_INTEGER dlibMove,
    IN DWORD dwOrigin,
    OUT ULARGE_INTEGER *plibNewPosition
    )
/*++

Implements:

    IStream::Seek

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtTapeIo::Seek"), OLESTR("<%I64d> <%d>; offset=%I64u"), dlibMove.QuadPart, dwOrigin, m_StreamOffset.QuadPart);

    ULARGE_INTEGER newPosition;
    UINT64 curPos;

    try {
        MvrInjectError(L"Inject.CNtTapeIo::Seek.0");

        WsbAssert(m_sMediaParameters.BlockSize > 0, MVR_E_LOGIC_ERROR);

        newPosition.QuadPart = 0;

        switch ( (STREAM_SEEK)dwOrigin ) {
        case STREAM_SEEK_SET:
            // If reading, defer physical move 'til later...
            if (!(m_Mode & MVR_MODE_READ)) {
                WsbAffirmHr(SetPosition(dlibMove.QuadPart/m_sMediaParameters.BlockSize));
            }
            m_StreamOffset.QuadPart = dlibMove.QuadPart;

            if (m_StreamOffset.QuadPart > m_StreamSize.QuadPart) {
                m_StreamSize = m_StreamOffset;
            }

            break;

        case STREAM_SEEK_CUR:
            if (dlibMove.QuadPart != 0) {
                // If reading, defer physical move 'til later...
                if (!(m_Mode & MVR_MODE_READ)) {
                    WsbAffirmHr(SetPosition((m_StreamOffset.QuadPart + dlibMove.QuadPart)/m_sMediaParameters.BlockSize));
                }
                m_StreamOffset.QuadPart += dlibMove.QuadPart;
            }
            else {
                WsbAffirmHr(GetPosition(&curPos));
                m_StreamOffset.QuadPart = curPos * m_sMediaParameters.BlockSize;
            }

            if (m_StreamOffset.QuadPart > m_StreamSize.QuadPart) {
                m_StreamSize = m_StreamOffset;
            }

            break;

        case STREAM_SEEK_END:
            // TODO: FIX:  We can use WsbAffirmHrOk when missing EOD markers is translated to MVR_S_NO_DATA_DETECTED.
            hr = SpaceToEndOfData(&curPos);
            m_StreamOffset.QuadPart = curPos * m_sMediaParameters.BlockSize;
            m_StreamSize = m_StreamOffset;
            break;

        case 100:
            // dlibMove is a DataSet number.
            WsbAffirmHrOk(RewindTape());
            WsbAffirmHrOk(SpaceFilemarks((LONG)(1+(dlibMove.QuadPart-1)*2), &curPos));
            m_StreamOffset.QuadPart = curPos * m_sMediaParameters.BlockSize;
            m_StreamSize = m_StreamOffset;
            break;

        default:
            WsbThrow( STG_E_INVALIDFUNCTION );
        }

        newPosition.QuadPart = m_StreamOffset.QuadPart;

        if ( plibNewPosition ) {
            plibNewPosition->QuadPart = newPosition.QuadPart;
        }

    } WsbCatch(hr);


    //
    // TODO: Do we need to invalidate the internal stream buffer, or reset the
    //       stream buffer position to correspond to the stream offset?
    //

    WsbTraceOut(OLESTR("CNtTapeIo::Seek"), OLESTR("hr = <%ls>, new offset=%I64u"), WsbHrAsString(hr), m_StreamOffset.QuadPart);

    return hr;
}


STDMETHODIMP
CNtTapeIo::SetSize(
    IN ULARGE_INTEGER /*libNewSize*/)
/*++

Implements:

    IStream::SetSize

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtTapeIo::SetSize"), OLESTR(""));

    try {
        WsbThrow(E_NOTIMPL);
    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CNtTapeIo::SetSize"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP
CNtTapeIo::CopyTo(
    IN IStream *pstm,
    IN ULARGE_INTEGER cb,
    OUT ULARGE_INTEGER *pcbRead,
    OUT ULARGE_INTEGER *pcbWritten)
/*++

Implements:

    IStream::CopyTo

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtTapeIo::CopyTo"), OLESTR("<%I64u>"), cb.QuadPart);

    ULARGE_INTEGER totalBytesRead = {0,0};
    ULARGE_INTEGER totalBytesWritten = {0,0};

    BYTE *pBuffer = NULL;

    try {
        MvrInjectError(L"Inject.CNtTapeIo::CopyTo.0");

        WsbAssert(pstm != 0, STG_E_INVALIDPOINTER);
        WsbAssert(m_sMediaParameters.BlockSize > 0, MVR_E_LOGIC_ERROR);

        ULONG defaultBufferSize = DefaultMinBufferSize;

        DWORD size;
        OLECHAR tmpString[256];
        if (SUCCEEDED(WsbGetRegistryValueString(NULL, RMS_REGISTRY_STRING, RMS_PARAMETER_BUFFER_SIZE, tmpString, 256, &size))) {
            // Get the value.
            LONG val = wcstol(tmpString, NULL, 10);
            if (val > 0) {
                defaultBufferSize = val;
            }
        }

        ULONG bufferSize;
        ULONG nBlocks = defaultBufferSize/m_sMediaParameters.BlockSize;
        nBlocks = (nBlocks < 2) ? 2 : nBlocks;
        bufferSize = nBlocks * m_sMediaParameters.BlockSize;

        pBuffer = (BYTE *) WsbAlloc(bufferSize);
        WsbAssertPointer(pBuffer);
        memset(pBuffer, 0, bufferSize);

        ULONG           bytesToRead;
        ULONG           bytesRead;
        ULONG           bytesWritten;
        ULARGE_INTEGER  bytesToCopy;

        bytesToCopy.QuadPart = cb.QuadPart;

        while ((bytesToCopy.QuadPart > 0) && (S_OK == hr)) {
            bytesRead = 0;
            bytesWritten = 0;

            bytesToRead =  (bytesToCopy.QuadPart < bufferSize) ? bytesToCopy.LowPart : bufferSize;

            hr = Read(pBuffer, bytesToRead, &bytesRead);
            totalBytesRead.QuadPart += bytesRead;

            WsbAffirmHrOk(pstm->Write(pBuffer, bytesRead, &bytesWritten));
            totalBytesWritten.QuadPart += bytesWritten;

            bytesToCopy.QuadPart -= bytesRead;

        }

        if (pcbRead) {
            pcbRead->QuadPart = totalBytesRead.QuadPart;
        }

        if (pcbWritten) {
            pcbWritten->QuadPart = totalBytesWritten.QuadPart;
        }

        // TODO: FIX:  We'll be getting an error if there's a missing EOD marker.
        // This is hacked-up until we get a correct error code from
        // the drivers, at which time we can remove this code.
        if (FAILED(hr)) {
            LARGE_INTEGER   zero = {0,0};
            ULARGE_INTEGER  pos1, pos2;

            WsbAffirmHr(Seek(zero, STREAM_SEEK_CUR, &pos1));
            // We're looking for the same error conditon and
            // verifying position doesn't change.
            if (hr == Seek(zero, STREAM_SEEK_END, &pos2)){
                if (pos1.QuadPart == pos2.QuadPart) {
                    hr = MVR_S_NO_DATA_DETECTED;
                }
            }
            else {
                WsbThrow(hr);
            }
        }

    } WsbCatch(hr);

    if (pBuffer) {
        WsbFree(pBuffer);
        pBuffer = NULL;
    }


    WsbTraceOut(OLESTR("CNtTapeIo::CopyTo"), OLESTR("hr = <%ls>, bytesRead=%I64u, bytesWritten=%I64u"),
        WsbHrAsString(hr), totalBytesRead.QuadPart, totalBytesWritten.QuadPart);

    return hr;
}


STDMETHODIMP
CNtTapeIo::Commit(
    IN DWORD grfCommitFlags)
/*++

Implements:

    IStream::Commit

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtTapeIo::Commit"), OLESTR("0x%08x"), grfCommitFlags);

    try {
        MvrInjectError(L"Inject.CNtTapeIo::Commit.0");

        // Consistency Check
        // UINT64 pos = m_StreamOffset.QuadPart / m_sMediaParameters.BlockSize;;
        // WsbAffirmHr(EnsurePosition(pos));
        UINT64 curPos;
        WsbAffirmHr(GetPosition(&curPos));
        WsbAssert(curPos == m_StreamOffset.QuadPart / m_sMediaParameters.BlockSize, E_UNEXPECTED);

        // This is a real stretch!
        WsbAffirmHr(WriteFilemarks(grfCommitFlags));

        // Now update the storage info stats for the cartridge.
        CComQIPtr<IRmsStorageInfo, &IID_IRmsStorageInfo> pInfo = m_pCartridge;
        pInfo->IncrementBytesWritten(grfCommitFlags*m_sMediaParameters.BlockSize);

        m_StreamOffset.QuadPart += grfCommitFlags*m_sMediaParameters.BlockSize;
        m_StreamSize = m_StreamOffset; // For tape this is always true

    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CNtTapeIo::Commit"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP
CNtTapeIo::Revert(void)
/*++

Implements:

    IStream::Revert

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtTapeIo::Revert"), OLESTR(""));

    try {

        m_Mode = 0;

    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CNtTapeIo::Revert"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP
CNtTapeIo::LockRegion(
    IN ULARGE_INTEGER /*libOffset*/,
    IN ULARGE_INTEGER /*cb*/,
    IN DWORD /*dwLockType*/)
/*++

Implements:

    IStream::LockRegion

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtTapeIo::LockRegion"), OLESTR(""));

    try {
        WsbThrow(E_NOTIMPL);
    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CNtTapeIo::LockRegion"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP
CNtTapeIo::UnlockRegion(
    IN ULARGE_INTEGER /*libOffset*/,
    IN ULARGE_INTEGER /*cb*/,
    IN DWORD /*dwLockType*/)
/*++

Implements:

    IStream::UnlockRegion

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtTapeIo::UnlockRegion"), OLESTR(""));

    try {
        WsbThrow(E_NOTIMPL);
    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CNtTapeIo::UnlockRegion"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP
CNtTapeIo::Stat(
    OUT STATSTG * /*pstatstg*/,
    IN DWORD /*grfStatFlag*/)
/*++

Implements:

    IStream::Stat

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtTapeIo::Stat"), OLESTR(""));

    try {
        WsbThrow(E_NOTIMPL);
    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CNtTapeIo::Stat"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP
CNtTapeIo::Clone(
    OUT IStream ** /*ppstm*/)
/*++

Implements:

    IStream::Clone

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtTapeIo::Clone"), OLESTR(""));

    try {
        WsbThrow(E_NOTIMPL);
    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CNtTapeIo::Clone"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}

////////////////////////////////////////////////////////////////////////////////
//
// Local and Static Methods
//


HRESULT
CNtTapeIo::OpenTape(void)
/*++

Routine Description:

    Opens the tape drive and gets media and drive info

Arguments:

    None.

Return Value:

    None.

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtTapeIo::OpenTape"), OLESTR("<%ls>"), m_DeviceName);

    try {
        WsbAffirmHrOk(IsAccessEnabled());

        MvrInjectError(L"Inject.CNtTapeIo::OpenTape.0");

        WsbAssert(wcscmp((WCHAR *)m_DeviceName, MVR_UNDEFINED_STRING), MVR_E_LOGIC_ERROR);
        WsbAssertPointer(m_pCartridge);

        DWORD nStructSize;

        int retry;
        const int delta = 10;
        const int MaxRetry = 10;

        retry = 0;
        do {
            try {
                MvrInjectError(L"Inject.CNtTapeIo::OpenTape.CreateFile.0");

                // ** WIN32 Tape API Call - open the tape drive for read/write
                WsbAffirmHandle(m_hTape = CreateFile(m_DeviceName, GENERIC_READ|GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL));

                MvrInjectError(L"Inject.CNtTapeIo::OpenTape.CreateFile.1");
                
                if (retry > 0) {
                    WsbLogEvent(MVR_MESSAGE_RECOVERABLE_DEVICE_ERROR_RECOVERED, sizeof(retry), &retry, NULL);
                }
                break;

            } WsbCatchAndDo(hr,
                    hr = MapTapeError(hr);

                    switch (hr) {

                    case MVR_E_ERROR_DEVICE_NOT_CONNECTED:

                        if (retry < MaxRetry){
                            WsbLogEvent(MVR_MESSAGE_RECOVERABLE_DEVICE_ERROR_DETECTED, sizeof(retry), &retry, NULL);
                            WsbTrace(OLESTR("Waiting for device - Seconds remaining before timeout: %d\n"), retry*delta);
                            Sleep(delta*1000);
                            hr = S_OK;
                        }
                        else {
                            //
                            // This is the last try, so log the failure.
                            //
                            WsbLogEvent(MVR_MESSAGE_UNRECOVERABLE_DEVICE_ERROR, sizeof(retry), &retry, WsbHrAsString(hr), NULL);
                            WsbThrow(hr);
                        }
                        break;

                    default:

                        WsbLogEvent(MVR_MESSAGE_UNRECOVERABLE_DEVICE_ERROR, sizeof(retry), &retry, WsbHrAsString(hr), NULL);
                        WsbThrow(hr);
                        break;

                    }

                );

        } while (++retry < MaxRetry);

        retry = 0;
        do {
            try {
                MvrInjectError(L"Inject.CNtTapeIo::OpenTape.GetTapeStatus.0");

                // ** WIN32 Tape API Call - get the tape status
                WsbAffirmNoError(GetTapeStatus(m_hTape));

                MvrInjectError(L"Inject.CNtTapeIo::OpenTape.GetTapeStatus.1");

                if (retry > 0) {
                    WsbLogEvent(MVR_MESSAGE_RECOVERABLE_DEVICE_ERROR_RECOVERED, sizeof(retry), &retry, NULL);
                }
                break;

            } WsbCatchAndDo(hr,
                    hr = MapTapeError(hr);

                    switch (hr) {

                    case MVR_E_BUS_RESET:
                    case MVR_E_MEDIA_CHANGED:
                    case MVR_E_NO_MEDIA_IN_DRIVE:
                    case MVR_E_ERROR_IO_DEVICE:
                    case MVR_E_ERROR_DEVICE_NOT_CONNECTED:
                    case MVR_E_ERROR_NOT_READY:

                        if (retry < MaxRetry){
                            WsbLogEvent(MVR_MESSAGE_RECOVERABLE_DEVICE_ERROR_DETECTED, sizeof(retry), &retry, NULL);
                            WsbTrace(OLESTR("Waiting for device - Seconds remaining before timeout: %d\n"), retry*delta);
                            Sleep(delta*1000);
                            hr = S_OK;
                        }
                        else {
                            //
                            // This is the last try, so log the failure.
                            //
                            WsbLogEvent(MVR_MESSAGE_UNRECOVERABLE_DEVICE_ERROR, sizeof(retry), &retry, WsbHrAsString(hr), NULL);
                            WsbThrow(hr);
                        }
                        break;

                    default:

                        WsbLogEvent(MVR_MESSAGE_UNRECOVERABLE_DEVICE_ERROR, sizeof(retry), &retry, WsbHrAsString(hr), NULL);
                        WsbThrow(hr);
                        break;

                    }

                );

        } while (++retry < MaxRetry);

        nStructSize = sizeof(TAPE_GET_DRIVE_PARAMETERS) ;

        try {
            MvrInjectError(L"Inject.CNtTapeIo::OpenTape.GetTapeParameters.0");

            // ** WIN32 Tape API Call - get the tape drive parameters
            WsbAffirmNoError(GetTapeParameters(m_hTape, GET_TAPE_DRIVE_INFORMATION, &nStructSize, &m_sDriveParameters));

            MvrInjectError(L"Inject.CNtTapeIo::OpenTape.GetTapeParameters.1");

        } WsbCatchAndDo(hr,
                hr = MapTapeError(hr);
                WsbLogEvent(MVR_MESSAGE_DEVICE_ERROR, 0, NULL, WsbHrAsString(hr), NULL);
                WsbThrow(hr);
            );

        // Set the Block Size to the default for the device, or DefaultBlockSize.
        TAPE_SET_MEDIA_PARAMETERS parms;

        LONG nBlockSize = 0;
        if (m_pCartridge) {
            WsbAffirmHr(m_pCartridge->GetBlockSize(&nBlockSize));
        }

        if (0 == nBlockSize) {

            // If the block size is zero, it must be scratch media!
            if (m_pCartridge) {
                LONG status;
                WsbAffirmHr(m_pCartridge->GetStatus(&status));
                WsbAssert(RmsStatusScratch == status, E_UNEXPECTED);
            }

            // Allow registry override!

            DWORD size;
            OLECHAR tmpString[256];
            if (SUCCEEDED(WsbGetRegistryValueString(NULL, RMS_REGISTRY_STRING, RMS_PARAMETER_BLOCK_SIZE, tmpString, 256, &size))) {
                // Get the value.
                nBlockSize = wcstol(tmpString, NULL, 10);

                // BlockSize must be a multiple of 512.
                if (nBlockSize % 512) {
                    // The block size specified is not valid, revert to default setting.
                    nBlockSize = 0;
                }
            }
        }

        if (nBlockSize > 0) {
            parms.BlockSize = nBlockSize;
        }
        else {
            // NOTE:  We can't arbitrarily use the default block size for the device.  It could
            // change between different devices supporting the same media format.  Migrate / Recall
            // operations depend on using the same block size.

            parms.BlockSize = m_sDriveParameters.DefaultBlockSize;
        }

        WsbTrace( OLESTR("Setting Block Size to %d bytes/block.\n"), parms.BlockSize);

        WsbAssert(parms.BlockSize > 0, E_UNEXPECTED);

        try {
            MvrInjectError(L"Inject.CNtTapeIo::OpenTape.SetTapeParameters.1");

            // ** WIN32 Tape API Call - set the tape drive parameters
            WsbAffirmNoError(SetTapeParameters(m_hTape, SET_TAPE_MEDIA_INFORMATION, &parms));

            MvrInjectError(L"Inject.CNtTapeIo::OpenTape.SetTapeParameters.1");

        } WsbCatchAndDo(hr,
                hr = MapTapeError(hr);
                WsbLogEvent(MVR_MESSAGE_DEVICE_ERROR, 0, NULL, WsbHrAsString(hr), NULL);
                WsbThrow(hr);
            );

        nStructSize = sizeof( TAPE_GET_MEDIA_PARAMETERS );

        try {
            MvrInjectError(L"Inject.CNtTapeIo::OpenTape.GetTapeParameters.2.0");

            // ** WIN32 Tape API Call - get the media parameters
            WsbAffirmNoError( GetTapeParameters(m_hTape, GET_TAPE_MEDIA_INFORMATION, &nStructSize, &m_sMediaParameters));

            MvrInjectError(L"Inject.CNtTapeIo::OpenTape.GetTapeParameters.2.1");

        } WsbCatchAndDo(hr,
                hr = MapTapeError(hr);
                WsbLogEvent(MVR_MESSAGE_DEVICE_ERROR, 0, NULL, WsbHrAsString(hr), NULL);
                WsbThrow(hr);
            );

        // Make sure we have a media block size that we can deal with.
        WsbAssert(m_sMediaParameters.BlockSize > 0, E_UNEXPECTED);
        WsbAssert(!(m_sMediaParameters.BlockSize % 512), E_UNEXPECTED);

        WsbTrace( OLESTR("Media Parameters:\n"));
        WsbTrace( OLESTR("  BlockSize           = %d bytes/block.\n"), m_sMediaParameters.BlockSize);
        WsbTrace( OLESTR("  Capacity            = %I64u\n"), m_sMediaParameters.Capacity.QuadPart);
        WsbTrace( OLESTR("  Remaining           = %I64u\n"), m_sMediaParameters.Remaining.QuadPart);
        WsbTrace( OLESTR("  PartitionCount      = %d\n"), m_sMediaParameters.PartitionCount);
        WsbTrace( OLESTR("  WriteProtect        = %ls\n"), WsbBoolAsString(m_sMediaParameters.WriteProtected));

        WsbTrace( OLESTR("Drive Parameters:\n"));
        WsbTrace( OLESTR("  ECC                 = %ls\n"), WsbBoolAsString(m_sDriveParameters.ECC));
        WsbTrace( OLESTR("  Compression         = %ls\n"), WsbBoolAsString(m_sDriveParameters.Compression));
        WsbTrace( OLESTR("  DataPadding         = %ls\n"), WsbBoolAsString(m_sDriveParameters.DataPadding));
        WsbTrace( OLESTR("  ReportSetmarks      = %ls\n"), WsbBoolAsString(m_sDriveParameters.ReportSetmarks));
        WsbTrace( OLESTR("  DefaultBlockSize    = %d (%d, %d)\n"),
            m_sDriveParameters.DefaultBlockSize,
            m_sDriveParameters.MinimumBlockSize,
            m_sDriveParameters.MaximumBlockSize);
        WsbTrace( OLESTR("  MaxPartitionCount   = %d\n"), m_sDriveParameters.MaximumPartitionCount);
        WsbTrace(     OLESTR("  FeaturesLow         = 0x%08x      FIXED(%d)            SELECT(%d)          INITIATOR(%d)\n"),
            m_sDriveParameters.FeaturesLow,
            m_sDriveParameters.FeaturesLow & TAPE_DRIVE_FIXED ? 1 : 0,
            m_sDriveParameters.FeaturesLow & TAPE_DRIVE_SELECT ? 1 : 0,
            m_sDriveParameters.FeaturesLow & TAPE_DRIVE_INITIATOR ? 1 : 0);
        WsbTrace( OLESTR("                                        ERASE_SHORT(%d)      ERASE_LONG(%d)      ERASE_BOP_ONLY(%d)   ERASE_IMMEDIATE(%d)\n"),
            m_sDriveParameters.FeaturesLow & TAPE_DRIVE_ERASE_SHORT ? 1 : 0,
            m_sDriveParameters.FeaturesLow & TAPE_DRIVE_ERASE_LONG ? 1 : 0,
            m_sDriveParameters.FeaturesLow & TAPE_DRIVE_ERASE_BOP_ONLY ? 1 : 0,
            m_sDriveParameters.FeaturesLow & TAPE_DRIVE_ERASE_IMMEDIATE ? 1 : 0);
        WsbTrace( OLESTR("                                        TAPE_CAPACITY(%d)    TAPE_REMAINING(%d)  FIXED_BLOCK(%d)      VARIABLE_BLOCK(%d)\n"),
            m_sDriveParameters.FeaturesLow & TAPE_DRIVE_TAPE_CAPACITY ? 1 : 0,
            m_sDriveParameters.FeaturesLow & TAPE_DRIVE_TAPE_REMAINING ? 1 : 0,
            m_sDriveParameters.FeaturesLow & TAPE_DRIVE_FIXED_BLOCK ? 1 : 0,
            m_sDriveParameters.FeaturesLow & TAPE_DRIVE_VARIABLE_BLOCK ? 1 : 0);
        WsbTrace( OLESTR("                                        WRITE_PROTECT(%d)    EOT_WZ_SIZE(%d)     ECC(%d)              COMPRESSION(%d)      PADDING(%d)        REPORT_SMKS(%d)\n"),
            m_sDriveParameters.FeaturesLow & TAPE_DRIVE_WRITE_PROTECT ? 1 : 0,
            m_sDriveParameters.FeaturesLow & TAPE_DRIVE_EOT_WZ_SIZE ? 1 : 0,
            m_sDriveParameters.FeaturesLow & TAPE_DRIVE_ECC ? 1 : 0,
            m_sDriveParameters.FeaturesLow & TAPE_DRIVE_COMPRESSION ? 1 : 0,
            m_sDriveParameters.FeaturesLow & TAPE_DRIVE_PADDING ? 1 : 0,
            m_sDriveParameters.FeaturesLow & TAPE_DRIVE_REPORT_SMKS ? 1 : 0);
        WsbTrace( OLESTR("                                        GET_ABSOLUTE_BLK(%d) GET_LOGICAL_BLK(%d) SET_EOT_WZ_SIZE(%d)  EJECT_MEDIA(%d)      CLEAN_REQUESTS(%d)\n"),
            m_sDriveParameters.FeaturesLow & TAPE_DRIVE_GET_ABSOLUTE_BLK ? 1 : 0,
            m_sDriveParameters.FeaturesLow & TAPE_DRIVE_GET_LOGICAL_BLK ? 1 : 0,
            m_sDriveParameters.FeaturesLow & TAPE_DRIVE_SET_EOT_WZ_SIZE ? 1 : 0,
            m_sDriveParameters.FeaturesLow & TAPE_DRIVE_EJECT_MEDIA ? 1 : 0,
            m_sDriveParameters.FeaturesLow & TAPE_DRIVE_CLEAN_REQUESTS ? 1 : 0);
        WsbTrace(     OLESTR("  FeaturesHigh        = 0x%08x      LOAD_UNLOAD(%d)      TENSION(%d)         LOCK_UNLOCK(%d)      REWIND_IMMEDIATE(%d)\n"),
            m_sDriveParameters.FeaturesHigh,
            m_sDriveParameters.FeaturesHigh & TAPE_DRIVE_LOAD_UNLOAD ? 1 : 0,
            m_sDriveParameters.FeaturesHigh & TAPE_DRIVE_TENSION ? 1 : 0,
            m_sDriveParameters.FeaturesHigh & TAPE_DRIVE_LOCK_UNLOCK ? 1 : 0,
            m_sDriveParameters.FeaturesHigh & TAPE_DRIVE_REWIND_IMMEDIATE ? 1 : 0);
        WsbTrace( OLESTR("                                        SET_BLOCK_SIZE(%d)   LOAD_UNLD_IMMED(%d) TENSION_IMMED(%d)    LOCK_UNLK_IMMED(%d)\n"),
            m_sDriveParameters.FeaturesHigh & TAPE_DRIVE_SET_BLOCK_SIZE ? 1 : 0,
            m_sDriveParameters.FeaturesHigh & TAPE_DRIVE_LOAD_UNLD_IMMED ? 1 : 0,
            m_sDriveParameters.FeaturesHigh & TAPE_DRIVE_TENSION_IMMED ? 1 : 0,
            m_sDriveParameters.FeaturesHigh & TAPE_DRIVE_LOCK_UNLK_IMMED ? 1 : 0);
        WsbTrace( OLESTR("                                        SET_ECC(%d)          SET_COMPRESSION(%d) SET_PADDING(%d)      SET_REPORT_SMKS(%d)\n"),
            m_sDriveParameters.FeaturesHigh & TAPE_DRIVE_SET_ECC ? 1 : 0,
            m_sDriveParameters.FeaturesHigh & TAPE_DRIVE_SET_COMPRESSION ? 1 : 0,
            m_sDriveParameters.FeaturesHigh & TAPE_DRIVE_SET_PADDING ? 1 : 0,
            m_sDriveParameters.FeaturesHigh & TAPE_DRIVE_SET_REPORT_SMKS ? 1 : 0);
        WsbTrace( OLESTR("                                        ABSOLUTE_BLK(%d)     ABS_BLK_IMMED(%d)   LOGICAL_BLK(%d)      LOG_BLK_IMMED(%d)\n"),
            m_sDriveParameters.FeaturesHigh & TAPE_DRIVE_ABSOLUTE_BLK ? 1 : 0,
            m_sDriveParameters.FeaturesHigh & TAPE_DRIVE_ABS_BLK_IMMED ? 1 : 0,
            m_sDriveParameters.FeaturesHigh & TAPE_DRIVE_LOGICAL_BLK ? 1 : 0,
            m_sDriveParameters.FeaturesHigh & TAPE_DRIVE_LOG_BLK_IMMED ? 1 : 0);
        WsbTrace( OLESTR("                                        END_OF_DATA(%d)      RELATIVE_BLKS(%d)   FILEMARKS(%d)        SEQUENTIAL_FMKS(%d)\n"),
            m_sDriveParameters.FeaturesHigh & TAPE_DRIVE_END_OF_DATA ? 1 : 0,
            m_sDriveParameters.FeaturesHigh & TAPE_DRIVE_RELATIVE_BLKS ? 1 : 0,
            m_sDriveParameters.FeaturesHigh & TAPE_DRIVE_FILEMARKS ? 1 : 0,
            m_sDriveParameters.FeaturesHigh & TAPE_DRIVE_SEQUENTIAL_FMKS ? 1 : 0);
        WsbTrace( OLESTR("                                        SETMARKS(%d)         SEQUENTIAL_SMKS(%d) REVERSE_POSITION(%d) SPACE_IMMEDIATE(%d)\n"),
            m_sDriveParameters.FeaturesHigh & TAPE_DRIVE_SETMARKS ? 1 : 0,
            m_sDriveParameters.FeaturesHigh & TAPE_DRIVE_SEQUENTIAL_SMKS ? 1 : 0,
            m_sDriveParameters.FeaturesHigh & TAPE_DRIVE_REVERSE_POSITION ? 1 : 0,
            m_sDriveParameters.FeaturesHigh & TAPE_DRIVE_SPACE_IMMEDIATE ? 1 : 0);
        WsbTrace( OLESTR("                                        WRITE_SETMARKS(%d)   WRITE_FILEMARKS(%d) WRITE_SHORT_FMKS(%d) WRITE_LONG_FMKS(%d)\n"),
            m_sDriveParameters.FeaturesHigh & TAPE_DRIVE_WRITE_SETMARKS ? 1 : 0,
            m_sDriveParameters.FeaturesHigh & TAPE_DRIVE_WRITE_FILEMARKS ? 1 : 0,
            m_sDriveParameters.FeaturesHigh & TAPE_DRIVE_WRITE_SHORT_FMKS ? 1 : 0,
            m_sDriveParameters.FeaturesHigh & TAPE_DRIVE_WRITE_LONG_FMKS ? 1 : 0);
        WsbTrace( OLESTR("                                        WRITE_MARK_IMMED(%d) FORMAT(%d)          FORMAT_IMMEDIATE(%d)\n"),
            m_sDriveParameters.FeaturesHigh & TAPE_DRIVE_WRITE_MARK_IMMED ? 1 : 0,
            m_sDriveParameters.FeaturesHigh & TAPE_DRIVE_FORMAT ? 1 : 0,
            m_sDriveParameters.FeaturesHigh & TAPE_DRIVE_FORMAT_IMMEDIATE ? 1 : 0);
        WsbTrace( OLESTR("  EOTWarningZoneSize  = %d\n"), m_sDriveParameters.EOTWarningZoneSize);


        //
        // We assume the label is valid unless the flag is knocked down
        // while opening the device.  This could happen if we get a bus
        // reset between the mount the OpenTape call.
        //
        if (!m_ValidLabel) {

            CWsbBstrPtr label;
            WsbAffirmHr(ReadLabel(&label));
            WsbAffirmHr(VerifyLabel(label));

        }

    } WsbCatchAndDo(hr,
            // Clean up...
            (void) CloseTape();
        );

    WsbTraceOut(OLESTR("CNtTapeIo::OpenTape"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


HRESULT
CNtTapeIo::CloseTape(void)
/*++

Routine Description:

    Closes the tape drive.

Arguments:

    None.

Return Value:

    S_OK        -  Success.

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtTapeIo::CloseTape"), OLESTR("DeviceName=<%ls>"), m_DeviceName);

    //
    // CloseTape() can be called from RsSub during dismount, and/or shutdown.
    //
    // <<<<< ENTER SINGLE THREADED SECTION
    WsbAffirmHr(Lock());

    if (INVALID_HANDLE_VALUE != m_hTape) {

        try {

            // ** WIN32 Tape API Call - close the tape drive
            WsbTraceAlways(OLESTR("Closing %ls...\n"), m_DeviceName);
            WsbAffirmStatus(CloseHandle( m_hTape ));
            WsbTraceAlways(OLESTR("%ls was closed.\n"), m_DeviceName);

        } WsbCatchAndDo(hr,
                hr = MapTapeError(hr);
                WsbLogEvent(MVR_MESSAGE_DEVICE_ERROR, 0, NULL, WsbHrAsString(hr), NULL);
            );

        m_hTape = INVALID_HANDLE_VALUE;
        m_ValidLabel = FALSE;
    }

    WsbAffirmHr(Unlock());
    // >>>>> LEAVE SINGLE THREADED SECTION

    WsbTraceOut(OLESTR("CNtTapeIo::CloseTape"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


HRESULT
CNtTapeIo::WriteBuffer(
    IN BYTE *pBuffer,
    IN ULONG nBytesToWrite,
    OUT ULONG *pBytesWritten)
/*++

Routine Description:

    Used to write all MTF data.  Guarantees full blocks are written.

Arguments:

    pBuffer       -  Data buffer.
    nBytesToWrite -  number of bytes to write in buffer.
    pBytesWritten -  Bytes written.

Return Value:

    S_OK        -  Success.

--*/
{
    HRESULT hr = S_OK;

    try {
        WsbAffirmHrOk(IsAccessEnabled());

        WsbAffirm(TRUE == m_ValidLabel, E_ABORT);

        // making sure that we are writting only full blocks
        WsbAssert(!(nBytesToWrite % m_sMediaParameters.BlockSize), E_INVALIDARG);

        try {
            MvrInjectError(L"Inject.CNtTapeIo::WriteBuffer.WriteFile.0");

            // ** WIN32 Tape API Call - write the data
            WsbAffirmStatus(WriteFile(m_hTape, pBuffer, nBytesToWrite, pBytesWritten, 0));

            MvrInjectError(L"Inject.CNtTapeIo::WriteBuffer.WriteFile.1");
        } WsbCatchAndDo(hr,
                hr = MapTapeError(hr);
                WsbLogEvent(MVR_MESSAGE_DEVICE_ERROR, 0, NULL, WsbHrAsString(hr), NULL);
            );

        // making sure that we have written only full blocks
        WsbAssert(!(*pBytesWritten % m_sMediaParameters.BlockSize), E_UNEXPECTED);

    } WsbCatch(hr);

    return hr;
}


HRESULT
CNtTapeIo::ReadBuffer(
    IN BYTE *pBuffer,
    IN ULONG nBytesToRead,
    OUT ULONG *pBytesRead)
/*++

Routine Description:

    Used to read all MTF data.  Guarantees full blocks are read.

Arguments:

    pBuffer     -  Data buffer.
    nBytesToRead -  number of bytes to read into buffer.
    pBytesRead  -  Bytes read.

Return Value:

    S_OK        -  Success.

--*/
{
    HRESULT hr = S_OK;

    try {
        WsbAffirmHrOk(IsAccessEnabled());

        // making sure that we are reading only full blocks
        WsbAssert(!(nBytesToRead % m_sMediaParameters.BlockSize), MVR_E_LOGIC_ERROR);

        try {
            MvrInjectError(L"Inject.CNtTapeIo::ReadBuffer.ReadFile.0");

            // ** WIN32 Tape API Call - read the data
            WsbAffirmStatus(ReadFile(m_hTape, pBuffer, nBytesToRead, pBytesRead, 0));

            MvrInjectError(L"Inject.CNtTapeIo::ReadBuffer.ReadFile.1");

        } WsbCatchAndDo(hr,
                hr = MapTapeError(hr);

                // Errors like filemark detected and end-of-data are Okay!

                if ( FAILED(hr) ) {
                    WsbLogEvent(MVR_MESSAGE_DEVICE_ERROR, 0, NULL, WsbHrAsString(hr), NULL);
                }

            );

        // making sure that we have read only full blocks
        WsbAssert(!(*pBytesRead % m_sMediaParameters.BlockSize), E_UNEXPECTED);

        m_StreamPBA.QuadPart += *pBytesRead / m_sMediaParameters.BlockSize;

    } WsbCatch(hr);

    return hr;
}


HRESULT
CNtTapeIo::WriteFilemarks(
    IN ULONG nCount)
/*++

Routine Description:

    Writes count filemarks at the current location.

Arguments:

    nCount      -  Number of Filemarks to write.

Return Value:

    S_OK        -  Success.

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtTapeIo::WriteFilemarks"), OLESTR("<%u>"), nCount);

    try {
        WsbAffirmHrOk(IsAccessEnabled());

        WsbAffirm(TRUE == m_ValidLabel, E_ABORT);

        UINT64 pos;
        WsbAffirmHr(GetPosition(&pos));

        // Some drives support the default, others require long filemarks.
        if ( m_sDriveParameters.FeaturesHigh & TAPE_DRIVE_WRITE_FILEMARKS ) {
            try {
                MvrInjectError(L"Inject.CNtTapeIo::WriteFilemarks.WriteTapemark.1.0");

                // ** WIN32 Tape API Call - write a filemark
                WsbAffirmNoError(WriteTapemark(m_hTape, TAPE_FILEMARKS, nCount, FALSE));

                MvrInjectError(L"Inject.CNtTapeIo::WriteFilemarks.WriteTapemark.1.1");

            } WsbCatchAndDo(hr,
                    hr = MapTapeError(hr);
                    WsbLogEvent(MVR_MESSAGE_DEVICE_ERROR, 0, NULL, WsbHrAsString(hr), NULL);
                    WsbThrow(hr);
                );

            WsbTrace(OLESTR("  %d Filemark(s) @ PBA %I64u\n"), nCount, pos );

        }
        else if ( m_sDriveParameters.FeaturesHigh & TAPE_DRIVE_WRITE_LONG_FMKS ) {
            try {
                MvrInjectError(L"Inject.CNtTapeIo::WriteFilemarks.WriteTapemark.2.0");

                // ** WIN32 Tape API Call - write a filemark
                WsbAffirmNoError(WriteTapemark(m_hTape, TAPE_LONG_FILEMARKS, nCount, FALSE));

                MvrInjectError(L"Inject.CNtTapeIo::WriteFilemarks.WriteTapemark.2.1");

            } WsbCatchAndDo(hr,
                    hr = MapTapeError(hr);
                    WsbLogEvent(MVR_MESSAGE_DEVICE_ERROR, 0, NULL, WsbHrAsString(hr), NULL);
                    WsbThrow(hr);
                );

            WsbTrace(OLESTR("  %d Long Filemark(s) @ PBA %I64u\n"), nCount, pos );

        }
        else {
            // Short filemark???
            WsbThrow( E_UNEXPECTED );
        }


    } WsbCatchAndDo(hr,
            WsbLogEvent(MVR_MESSAGE_DEVICE_ERROR, 0, NULL, WsbHrAsString(hr), NULL);
        );


    WsbTraceOut(OLESTR("CNtTapeIo::WriteFilemarks"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


HRESULT
CNtTapeIo::GetPosition(
    OUT UINT64 *pPosition)
/*++

Routine Description:

    Returns the current physical block address relative the current partition.

Arguments:

    pPostion    -  Receives the current physical block address.

Return Value:

    S_OK        -  Success.

--*/
{
    HRESULT     hr = S_OK;
    WsbTraceIn(OLESTR("CNtTapeIo::GetPosition"), OLESTR(""));

    UINT64 curPos = 0xffffffffffffffff;

    try {
        WsbAssertPointer(pPosition);
        WsbAffirmHrOk(IsAccessEnabled());

        DWORD uPartition, uLSB, uMSB;
        ULARGE_INTEGER pba;

        try {
            MvrInjectError(L"Inject.CNtTapeIo::GetPosition.GetTapePosition.0");

            // ** WIN32 Tape API Call - get the PBA
            WsbAffirmNoError(GetTapePosition(m_hTape, TAPE_LOGICAL_POSITION, &uPartition, &uLSB, &uMSB));

            MvrInjectError(L"Inject.CNtTapeIo::GetPosition.GetTapePosition.1");

            pba.LowPart = uLSB;
            pba.HighPart = uMSB;

            curPos = pba.QuadPart;

            WsbTrace(OLESTR("CNtTapeIo::GetPosition - <%d> <%I64u>\n"), uPartition, curPos);

        } WsbCatchAndDo(hr,
                hr = MapTapeError(hr);
                WsbLogEvent(MVR_MESSAGE_DEVICE_ERROR, 0, NULL, WsbHrAsString(hr), NULL);
            );

        if (pPosition) {
            *pPosition = curPos;
        }

    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CNtTapeIo::GetPosition"), OLESTR("hr = <%ls>, pos=%I64u"), WsbHrAsString(hr), curPos);

    return hr;
}


HRESULT
CNtTapeIo::SetPosition(
    IN UINT64 position)
/*++

Routine Description:

    Mover to the specified physical block address relative the current partition.

Arguments:

    postion     -  The physical block address to position to.

Return Value:

    S_OK        -  Success.

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtTapeIo::SetPosition"), OLESTR("<%I64u>"), position);

    UINT64 curPos = 0xffffffffffffffff;

    try {
        WsbAffirmHrOk(IsAccessEnabled());

        MvrInjectError(L"Inject.CNtTapeIo::SetPosition.0");

        //
        // NOTE:  By first checking the current block address with the one we want we 
        //        avoid an expensive seek in the case where the tape is already located at
        //        the desired block address (not all devices know where they are, and seeking
        //        to the current block address is expensive).
        //
        // TODO:  It is faster to just read a few thousand blocks rather than seek to a position that
        //        is a few thousand blocks away. If we're within this threshold we could read from
        //        tape into the bit bucket to advance the tape.
        // 

        WsbAffirmHr(GetPosition(&curPos));
        if (curPos != position ) {

            ULARGE_INTEGER PBA;
            PBA.QuadPart = position;

            try {

                if (0 == position) {
                    WsbAffirmHr(RewindTape());
                }
                else {
                    MvrInjectError(L"Inject.CNtTapeIo::SetPosition.SetTapePosition.1");

                    // ** WIN32 Tape API Call - set the PBA
                    WsbAffirmNoError(SetTapePosition(m_hTape, TAPE_LOGICAL_BLOCK, 1, PBA.LowPart, PBA.HighPart, FALSE));

                    MvrInjectError(L"Inject.CNtTapeIo::SetPosition.SetTapePosition.0");
                
                }

            } WsbCatchAndDo(hr,
                    hr = MapTapeError(hr);
                    WsbLogEvent(MVR_MESSAGE_DEVICE_ERROR, 0, NULL, WsbHrAsString(hr), NULL);
                    WsbThrow(hr);
                );

            curPos = position;
        }

        m_StreamPBA.QuadPart = curPos;

    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CNtTapeIo::SetPosition"), OLESTR("hr = <%ls>, pos=%I64u"), WsbHrAsString(hr), curPos);

    return hr;
}



HRESULT
CNtTapeIo::EnsurePosition(
    IN UINT64 position)
/*++

Routine Description:

    Checks that the tape is positioned at the specified current physical block
    address relative to the current partition.  If it is not an attempt is made 
    to recover to the specified position.

Arguments:

    postion     -  The physical block address to verify.

Return Value:

    S_OK        -  Success.

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtTapeIo::EnsurePosition"), OLESTR("<%I64u>"), position);

    UINT64 curPos = 0xffffffffffffffff;

    try {

        // Consistency Check
        WsbAffirmHr(GetPosition(&curPos));
        if (curPos != position) {
            // Houston, we've got a problem here...
            // Most likely a bus reset caused the tape position to change.
            WsbLogEvent(MVR_MESSAGE_UNEXPECTED_DATA_SET_LOCATION_DETECTED, 0, NULL,
                WsbQuickString(WsbLonglongAsString(position)), 
                WsbQuickString(WsbLonglongAsString(curPos)), NULL);

            // Only recover from complete automatic tape rewinds after a bus reset.
            if (curPos == 0) {
                WsbAffirmHr(SpaceToEndOfData(&curPos));

                // If we still don't line up we've got bigger problems... Note that this 
                // can happen if the device's internal buffer had not been flushed prior 
                // to the bus reset.  (The different tape formats tend to have different 
                // rules governing when the drive buffer is flushed/committed.  DLT and 
                // 4mm tend to commit every couple seconds, but 8mm (at least Exabyte 
                // 8505 8mm tape drives) do not commit until the drive buffer is full.)  
                // If the buffer was not committed prior to bus reset then the data 
                // Remote Storage thinks was written to the tape was never actually 
                // written, and is lost.  In such a case, the 'SpaceToEndOfData()' call 
                // above will only position the tape to the end of the last data actually 
                // committed to the tape, which will not match what we are expecting, so 
                // the following branch will be taken.
                if (curPos != position) {
                    WsbLogEvent(MVR_MESSAGE_UNEXPECTED_DATA_SET_LOCATION_DETECTED, 0, NULL,
                        WsbQuickString(WsbLonglongAsString(position)), 
                        WsbQuickString(WsbLonglongAsString(curPos)), NULL);
                    WsbLogEvent(MVR_MESSAGE_DATA_SET_NOT_RECOVERABLE, 0, NULL, 
                        WsbHrAsString(MVR_E_LOGIC_ERROR), NULL);
                    WsbThrow(MVR_E_LOGIC_ERROR);
                }

                WsbLogEvent(MVR_MESSAGE_DATA_SET_RECOVERED, 0, NULL, NULL);
            }
            else {
                WsbLogEvent(MVR_MESSAGE_DATA_SET_NOT_RECOVERABLE, 0, NULL, 
                        WsbHrAsString(E_ABORT), NULL);
                WsbThrow(E_ABORT);
            }
        }

    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CNtTapeIo::EnsurePosition"), OLESTR("hr = <%ls>"), 
                        WsbHrAsString(hr));

    return hr;
}


HRESULT
CNtTapeIo::SpaceFilemarks(
    IN LONG count,
    OUT UINT64 *pPosition)
/*++

Routine Description:

    Spaces the tape forward or backward by the number of filesmarks specified.

Arguments:

    count       - Specifies the number of filemarks to space over from the current position.
                  A positive count spaces the tape forward, and positions after the last filemark.
                  A negative count spaces the tape backward, and positions to the beginning of
                  the last filemark.  If the count is zero, the tape position is not changed.

    pPostion    - Receives the physical block address after positioning.

Return Value:

    S_OK        -  Success.

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtTapeIo::SpaceFilemarks"), OLESTR("<%d>"), count);

    UINT64 curPos = 0xffffffffffffffff;

    try {
        WsbAffirmHrOk(IsAccessEnabled());

        try {
            MvrInjectError(L"Inject.CNtTapeIo::SpaceFilemarks.SetTapePosition.0");

            // ** WIN32 Tape API Call - position to the specified filemark
            WsbAffirmNoError(SetTapePosition(m_hTape, TAPE_SPACE_FILEMARKS, 0, count, 0, FALSE));

            MvrInjectError(L"Inject.CNtTapeIo::SpaceFilemarks.SetTapePosition.1");

        } WsbCatchAndDo(hr,
                hr = MapTapeError(hr);
                WsbLogEvent(MVR_MESSAGE_DEVICE_ERROR, 0, NULL, WsbHrAsString(hr), NULL);
            );

        // We always return current position.
        WsbAffirmHr(GetPosition(&curPos));

        if (pPosition) {
            *pPosition = curPos;
        }

    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CNtTapeIo::SpaceFilemarks"), OLESTR("hr = <%ls>, pos=%I64u"), WsbHrAsString(hr), curPos);

    return hr;
}


HRESULT
CNtTapeIo::SpaceToEndOfData(
    OUT UINT64 *pPosition)
/*++

Routine Description:

    Positions the tape to the end of data of the current partition.

Arguments:

    pPostion    -  Receives the physical block address at end of data.

Return Value:

    S_OK        -  Success.

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtTapeIo::SpaceToEndOfData"), OLESTR(""));

    UINT64 curPos = 0xffffffffffffffff;

    try {
        WsbAffirmHrOk(IsAccessEnabled());

        try {
            MvrInjectError(L"Inject.CNtTapeIo::SpaceToEndOfData.SetTapePosition.0");

            // ** WIN32 Tape API Call - position to end of data
            WsbAffirmNoError(SetTapePosition(m_hTape, TAPE_SPACE_END_OF_DATA, 0, 0, 0, FALSE));

            MvrInjectError(L"Inject.CNtTapeIo::SpaceToEndOfData.SetTapePosition.1");

        } WsbCatchAndDo(hr,
                hr = MapTapeError(hr);
                WsbLogEvent(MVR_MESSAGE_DEVICE_ERROR, 0, NULL, WsbHrAsString(hr), NULL);
            );

        // We always return current position.
        WsbAffirmHr(GetPosition(&curPos));

        if (pPosition) {
            *pPosition = curPos;
        }

    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CNtTapeIo::SpaceToEndOfData"), OLESTR("hr = <%ls>, pos=%I64u"), WsbHrAsString(hr), curPos);

    return hr;
}


HRESULT
CNtTapeIo::RewindTape(void)
/*++

Routine Description:

    Rewinds the tape to the beginnning of the current partition.

Arguments:

    None.

Return Value:

    S_OK        -  Success.

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtTapeIo::RewindTape"), OLESTR(""));

    UINT64 curPos = 0xffffffffffffffff;

    try {
        WsbAffirmHrOk(IsAccessEnabled());

        try {
            MvrInjectError(L"Inject.CNtTapeIo::RewindTape.SetTapePosition.0");

            // ** WIN32 Tape API Call - rewind the tape
            WsbAffirmNoError(SetTapePosition(m_hTape, TAPE_REWIND, 0, 0, 0, FALSE));

            MvrInjectError(L"Inject.CNtTapeIo::RewindTape.SetTapePosition.1");

        } WsbCatchAndDo(hr,
                hr = MapTapeError(hr);
                WsbLogEvent(MVR_MESSAGE_DEVICE_ERROR, 0, NULL, WsbHrAsString(hr), NULL);
            );

        // We always return current position.
        WsbAffirmHr(GetPosition(&curPos));

        WsbAssert(0 == curPos, E_UNEXPECTED);

    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CNtTapeIo::RewindTape"), OLESTR("hr = <%ls>, pos=%I64u"), WsbHrAsString(hr), curPos);

    return hr;
}


HRESULT
CNtTapeIo::IsAccessEnabled(void)
{

    HRESULT hr = S_OK;
    //WsbTraceIn(OLESTR("CNtTapeIo::IsAccessEnabled"), OLESTR(""));

    try {

        if (m_pCartridge) {
            // Check that the cartridge is still enable for access
            CComQIPtr<IRmsComObject, &IID_IRmsComObject> pObject = m_pCartridge;
            try {
                WsbAffirmHrOk(pObject->IsEnabled());
            } WsbCatchAndDo(hr, 
                HRESULT reason = E_ABORT;

                m_ValidLabel = FALSE;

                pObject->GetStatusCode(&reason);
                WsbThrow(reason);
            );
        }
    } WsbCatch(hr);

    //WsbTraceOut(OLESTR("CNtTapeIo::IsAccessEnabled"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;

}



HRESULT
CNtTapeIo::Lock( void )
/*++

Implements:

    IRmsDrive::Lock

--*/
{
    HRESULT hr S_OK;

    WsbTraceIn(OLESTR("CRmsDrive::Lock"), OLESTR(""));

    try {

        try {

            // InitializeCriticalSection raises an exception.  Enter/Leave may too.
            EnterCriticalSection(&m_CriticalSection);

        } catch(DWORD status) {
            WsbLogEvent(status, 0, NULL, NULL);
            WsbThrow(E_UNEXPECTED);
            }

    } WsbCatch(hr)

    WsbTraceOut(OLESTR("CRmsDrive::Lock"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


HRESULT
CNtTapeIo::Unlock( void )
/*++

Implements:

    IRmsDrive::Unlock

--*/
{
    HRESULT hr S_OK;

    WsbTraceIn(OLESTR("CRmsDrive::Unlock"), OLESTR(""));

    try {

        try {

            // InitializeCriticalSection raises an exception.  Enter/Leave may too.
            LeaveCriticalSection(&m_CriticalSection);

        } catch(DWORD status) {
            WsbLogEvent(status, 0, NULL, NULL);
            WsbThrow(E_UNEXPECTED);
            }

    } WsbCatch(hr)

    WsbTraceOut(OLESTR("CRmsDrive::Unlock"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}



HRESULT
CNtTapeIo::MapTapeError(
    IN HRESULT hrToMap)
/*++

Routine Description:

    Maps a WIN32 tape error, specified as an HRESULT, to a MVR error.

Arguments:

    hrToMap     -  WIN32 tape error to map.

Return Value:

    S_OK                            - Success.
    MVR_E_BEGINNING_OF_MEDIA        - The beginning of the tape or a partition was encountered.
    MVR_E_BUS_RESET                 - The I/O bus was reset.
    MVR_E_END_OF_MEDIA              - The physical end of the tape has been reached.
    MVR_S_FILEMARK_DETECTED         - A tape access reached a filemark.
    MVR_S_SETMARK_DETECTED          - A tape access reached the end of a set of files.
    MVR_S_NO_DATA_DETECTED          - No more data is on the tape.
    MVR_E_PARTITION_FAILURE         - Tape could not be partitioned.
    MVR_E_INVALID_BLOCK_LENGTH      - When accessing a new tape of a multivolume partition, the current blocksize is incorrect.
    MVR_E_DEVICE_NOT_PARTITIONED    - Tape partition information could not be found when loading a tape.
    MVR_E_MEDIA_CHANGED             - The media in the drive may have changed.
    MVR_E_NO_MEDIA_IN_DRIVE         - No media in drive.
    MVR_E_UNABLE_TO_LOCK_MEDIA      - Unable to lock the media eject mechanism.
    MVR_E_UNABLE_TO_UNLOAD_MEDIA    - Unable to unload the media.
    MVR_E_WRITE_PROTECT             - The media is write protected.
    MVR_E_CRC                       - Data error (cyclic redundancy check).
    MVR_E_DEVICE_REQUIRES_CLEANING  - The device has indicated that cleaning is required before further operations are attempted.
    MVR_E_SHARING_VIOLATION         - The process cannot access the file because it is being used by another process.
    MVR_E_ERROR_IO_DEVICE           - The request could not be performed because of an I/O device error.                          - Unknown error.
    MVR_E_ERROR_DEVICE_NOT_CONNECTED - The device is not connected.
    MVR_E_ERROR_NOT_READY           - Device is not ready.
    E_ABORT                         - Unknown error, abort.

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CNtTapeIo::MapTapeError"), OLESTR("<%ls>"), WsbHrAsString(hrToMap));

    try {

        // The valid label flag is knocked down when the media may have changed
        // or device parameters (i.e. block size) may have been reset.
        switch ( hrToMap ) {
        case S_OK:
            break;
        case HRESULT_FROM_WIN32( ERROR_BEGINNING_OF_MEDIA ):
            hr = MVR_E_BEGINNING_OF_MEDIA;
            break;
        case HRESULT_FROM_WIN32( ERROR_BUS_RESET ):
            hr = MVR_E_BUS_RESET;
            m_ValidLabel = FALSE;
            WsbLogEvent(MVR_MESSAGE_MEDIA_NOT_VALID, 0, NULL, WsbHrAsString(hr), NULL);
            break;
        case HRESULT_FROM_WIN32( ERROR_END_OF_MEDIA ):
            hr = MVR_E_END_OF_MEDIA;
            break;
        case HRESULT_FROM_WIN32( ERROR_FILEMARK_DETECTED ):     // Maps to Success
            hr = MVR_S_FILEMARK_DETECTED;
            break;
        case HRESULT_FROM_WIN32( ERROR_SETMARK_DETECTED ):      // Maps to Success
            hr = MVR_S_SETMARK_DETECTED;
            break;
        case HRESULT_FROM_WIN32( ERROR_NO_DATA_DETECTED ):      // Maps to Success
            // EOD
            // This happens on SpaceFilemarks() and SetPosition() past end of data.
            hr = MVR_S_NO_DATA_DETECTED;
            break;
        case HRESULT_FROM_WIN32( ERROR_PARTITION_FAILURE ):
            hr = MVR_E_PARTITION_FAILURE;
            break;
        case HRESULT_FROM_WIN32( ERROR_INVALID_BLOCK_LENGTH ):
            hr = MVR_E_INVALID_BLOCK_LENGTH;
            break;
        case HRESULT_FROM_WIN32( ERROR_DEVICE_NOT_PARTITIONED ):
            hr = MVR_E_DEVICE_NOT_PARTITIONED;
            break;
        case HRESULT_FROM_WIN32( ERROR_MEDIA_CHANGED ):
            hr = MVR_E_MEDIA_CHANGED;
            m_ValidLabel = FALSE;
            WsbLogEvent(MVR_MESSAGE_MEDIA_NOT_VALID, 0, NULL, WsbHrAsString(hr), NULL);
            break;
        case HRESULT_FROM_WIN32( ERROR_NO_MEDIA_IN_DRIVE ):
            hr = MVR_E_NO_MEDIA_IN_DRIVE;
            m_ValidLabel = FALSE;
            WsbLogEvent(MVR_MESSAGE_MEDIA_NOT_VALID, 0, NULL, WsbHrAsString(hr), NULL);
            break;
        case HRESULT_FROM_WIN32( ERROR_UNABLE_TO_LOCK_MEDIA ):
            hr = MVR_E_UNABLE_TO_LOCK_MEDIA;
            break;
        case HRESULT_FROM_WIN32( ERROR_UNABLE_TO_UNLOAD_MEDIA ):
            hr = MVR_E_UNABLE_TO_UNLOAD_MEDIA;
            break;
        case HRESULT_FROM_WIN32( ERROR_WRITE_PROTECT ):
            hr = MVR_E_WRITE_PROTECT;
            break;
        case HRESULT_FROM_WIN32( ERROR_CRC ): 
            // This is may indicate that the drive needs cleaning.
            //
            // 8505: This code returned for SpaceFilemarks or SpaceEOD operation
            //       for which no EOD marker exist on tape.  This happens when
            //       after power cycling device during writes.
            
            //       Verfied by bmd on 3/25/98 using new, bulk erased, and used tape.
            //       Look for new error ERROR_NOT_FOUND to replace ERROR_CRC when
            //       there's a misssing EOD marker.
            //
            // DLT:  See 8500 notes.
            //
            hr = MVR_E_CRC;
            m_ValidLabel = FALSE;
            WsbLogEvent(MVR_MESSAGE_MEDIA_NOT_VALID, 0, NULL, WsbHrAsString(hr), NULL);
            break;
        case HRESULT_FROM_WIN32( ERROR_DEVICE_REQUIRES_CLEANING ):
            // This happens on I/O errors that that driver believes may be fixed
            // by cleaning the drive heads.
            hr = MVR_E_DEVICE_REQUIRES_CLEANING;
            m_ValidLabel = FALSE;
            WsbLogEvent(MVR_MESSAGE_MEDIA_NOT_VALID, 0, NULL, WsbHrAsString(hr), NULL);
            break;
        case HRESULT_FROM_WIN32( ERROR_SHARING_VIOLATION ):
            // This happens when the CreateFile fails because the device is in use by some other app.
            hr = MVR_E_SHARING_VIOLATION;
            m_ValidLabel = FALSE;
            WsbLogEvent(MVR_MESSAGE_MEDIA_NOT_VALID, 0, NULL, WsbHrAsString(hr), NULL);
            break;
        case HRESULT_FROM_WIN32( ERROR_IO_DEVICE ):
            // This happens when the device is turned off during I/O, for example.
            hr = MVR_E_ERROR_IO_DEVICE;
            m_ValidLabel = FALSE;
            WsbLogEvent(MVR_MESSAGE_MEDIA_NOT_VALID, 0, NULL, WsbHrAsString(hr), NULL);
            break;
        case HRESULT_FROM_WIN32( ERROR_DEVICE_NOT_CONNECTED ):
            // This happens when the device is turned off.
            hr = MVR_E_ERROR_DEVICE_NOT_CONNECTED;
            m_ValidLabel = FALSE;
            WsbLogEvent(MVR_MESSAGE_MEDIA_NOT_VALID, 0, NULL, WsbHrAsString(hr), NULL);
            break;
        case HRESULT_FROM_WIN32( ERROR_SEM_TIMEOUT ):
            // This happens when the SCSI command does not return within the timeout period.  A system error is logged for the SCSI controler (adapter).
            hr = MVR_E_ERROR_DEVICE_NOT_CONNECTED;
            break;
        case HRESULT_FROM_WIN32( ERROR_NOT_READY ):
            // This happens when the device is coming ready (i.e. after a bus reset).
            hr = MVR_E_ERROR_NOT_READY;
            m_ValidLabel = FALSE;
            WsbLogEvent(MVR_MESSAGE_MEDIA_NOT_VALID, 0, NULL, WsbHrAsString(hr), NULL);
            break;
        case HRESULT_FROM_WIN32( ERROR_NOT_FOUND ):
            // See 8500 notes under ERROR_CRC
            hr = MVR_S_NO_DATA_DETECTED;
            break;
        default:
            WsbThrow(hrToMap);
        }

    } WsbCatchAndDo(hr,
            WsbLogEvent(MVR_MESSAGE_UNKNOWN_DEVICE_ERROR, 0, NULL, WsbHrAsString(hr), NULL);
            hr = E_ABORT;
        );


    WsbTraceOut(OLESTR("CNtTapeIo::MapTapeError"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\mover\server\nttapeio.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved.

Module Name:

    NtTapeIo.h

Abstract:

    Definition of the CNtTapeIo class

Author:

    Brian Dodd          [brian]         01-Apr-1997

Revision History:

--*/

#if !defined(NtTapeIo_H)
#define NtTapeIo_H

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "resource.h"       // main symbols
#include "MTFSessn.h"       // CMTFSession

/////////////////////////////////////////////////////////////////////////////
// CNtTapeIo

class CNtTapeIo : 
    public CComDualImpl<IDataMover, &IID_IDataMover, &LIBID_MOVERLib>,
    public IStream,
    public ISupportErrorInfo,
    public IWsbCollectable,
    public CComObjectRoot,
    public CComCoClass<CNtTapeIo,&CLSID_CNtTapeIo>
{
public:
    CNtTapeIo() {}
BEGIN_COM_MAP(CNtTapeIo)
    COM_INTERFACE_ENTRY2(IDispatch, IDataMover)
    COM_INTERFACE_ENTRY(IDataMover)
    COM_INTERFACE_ENTRY(IStream)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
    COM_INTERFACE_ENTRY(IWsbCollectable)
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(CNtTapeIo) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation. 

DECLARE_REGISTRY_RESOURCEID(IDR_CNtTapeIo)
// ISupportsErrorInfo
    STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// CComObjectRoot
public:
    ULONG InternalAddRef(void);
    ULONG InternalRelease(void);
    STDMETHOD( FinalConstruct )(void);
    STDMETHOD( FinalRelease )(void);

// IWsbCollectable
public:
    STDMETHOD(CompareTo)( IN IUnknown *pCollectable, OUT SHORT *pResult);
    STDMETHOD(IsEqual)(IUnknown* pCollectable);

// IDataMover
public:
    STDMETHOD(GetObjectId)(OUT GUID *pObjectId);

    STDMETHOD( BeginSession )(
        IN BSTR remoteSessionName,
        IN BSTR remoteSessionDescription,
        IN SHORT remoteDataSet,
        IN DWORD options);

    STDMETHOD( EndSession )(void);

    STDMETHOD( StoreData )(
        IN BSTR localName,
        IN ULARGE_INTEGER localDataStart,
        IN ULARGE_INTEGER localDataSize,
        IN DWORD flags,
        OUT ULARGE_INTEGER *pRemoteDataSetStart,
        OUT ULARGE_INTEGER *pRemoteFileStart,
        OUT ULARGE_INTEGER *pRemoteFileSize,
        OUT ULARGE_INTEGER *pRemoteDataStart,
        OUT ULARGE_INTEGER *pRemoteDataSize,
        OUT DWORD *pRemoteVerificationType,
        OUT ULARGE_INTEGER *pRemoteVerificationData,
        OUT DWORD *pDatastreamCRCType,
        OUT ULARGE_INTEGER *pDatastreamCRC,
        OUT ULARGE_INTEGER *pUsn);

    STDMETHOD( RecallData )(
        IN BSTR localName,
        IN ULARGE_INTEGER localDataStart,
        IN ULARGE_INTEGER localDataSize,
        IN DWORD flags,
        IN BSTR migrateSessionName,
        IN ULARGE_INTEGER remoteDataSetStart,
        IN ULARGE_INTEGER remoteFileStart,
        IN ULARGE_INTEGER remoteFileSize,
        IN ULARGE_INTEGER remoteDataStart,
        IN ULARGE_INTEGER remoteDataSize,
        IN DWORD remoteVerificationType,
        IN ULARGE_INTEGER remoteVerificationData);

    STDMETHOD( FormatLabel )(
        IN BSTR displayName,
        OUT BSTR *pLabel);

    STDMETHOD( WriteLabel )(
        IN BSTR label);

    STDMETHOD( ReadLabel )(
        IN OUT BSTR *pLabel );

    STDMETHOD( VerifyLabel )(
        IN BSTR label);

    STDMETHOD( GetDeviceName )(
        OUT BSTR *pName);

    STDMETHOD( SetDeviceName )(
        IN BSTR name,
        IN BSTR unused);

    STDMETHOD( GetLargestFreeSpace )(
        OUT LONGLONG *pFreeSpace,
        OUT LONGLONG *pCapacity,
        IN  ULONG    defaultFreeSpaceLow = 0xFFFFFFFF,
        IN  LONG     defaultFreeSpaceHigh = 0xFFFFFFFF);

    STDMETHOD( SetInitialOffset )(
        IN ULARGE_INTEGER initialOffset);

    STDMETHOD( GetCartridge )(
        OUT IRmsCartridge **ptr);

    STDMETHOD( SetCartridge )(
        IN IRmsCartridge *ptr);

    STDMETHOD( Cancel )(void);

    STDMETHOD( CreateLocalStream )(
        IN BSTR name,
        IN DWORD mode,
        OUT IStream **ppStream);

    STDMETHOD( CreateRemoteStream )(
        IN BSTR name,
        IN DWORD mode,
        IN BSTR remoteSessionName,
        IN BSTR remoteSessionDescription,
        IN ULARGE_INTEGER remoteDataSetStart,
        IN ULARGE_INTEGER remoteFileStart,
        IN ULARGE_INTEGER remoteFileSize,
        IN ULARGE_INTEGER remoteDataStart,
        IN ULARGE_INTEGER remoteDataSize,
        IN DWORD remoteVerificationType,
        IN ULARGE_INTEGER remoteVerificationData,
        OUT IStream **ppStream);

    STDMETHOD( CloseStream )(void);

    STDMETHOD( Duplicate )(
        IN IDataMover *pDestination,
        IN DWORD options,
        OUT ULARGE_INTEGER *pBytesCopied,
        OUT ULARGE_INTEGER *pBytesReclaimed);

    STDMETHOD( FlushBuffers )(void);

    STDMETHOD( Recover )(OUT BOOL *pDeleteFile);

// IStream
public:
    STDMETHOD( Read )(
        OUT void *pv,
        IN ULONG cb,
        OUT ULONG *pcbRead);

    STDMETHOD( Write )(
        OUT void const *pv,
        IN ULONG cb,
        OUT ULONG *pcbWritten);

    STDMETHOD( Seek )(
        IN LARGE_INTEGER dlibMove,
        IN DWORD dwOrigin,
        OUT ULARGE_INTEGER *plibNewPosition);

    STDMETHOD( SetSize )(
        IN ULARGE_INTEGER libNewSize);

    STDMETHOD( CopyTo )(
        IN IStream *pstm,
        IN ULARGE_INTEGER cb,
        OUT ULARGE_INTEGER *pcbRead,
        OUT ULARGE_INTEGER *pcbWritten);

    STDMETHOD( Commit )(
        IN DWORD grfCommitFlags);

    STDMETHOD( Revert )(void);

    STDMETHOD( LockRegion )(
        IN ULARGE_INTEGER libOffset,
        IN ULARGE_INTEGER cb,
        IN DWORD dwLockType);

    STDMETHOD( UnlockRegion )(
        IN ULARGE_INTEGER libOffset,
        IN ULARGE_INTEGER cb,
        IN DWORD dwLockType);

    STDMETHOD( Stat )(
        OUT STATSTG *pstatstg,
        IN DWORD grfStatFlag);

    STDMETHOD( Clone )(
        OUT IStream **ppstm);

private:
    enum {                                          // Class specific constants:
                                                    //
        Version = 1,                                // Class version, this should be
                                                    //   incremented each time the
                                                    //   the class definition changes.
        DefaultBlockSize = RMS_DEFAULT_BLOCK_SIZE,  // Default block size to use.
        DefaultMinBufferSize = RMS_DEFAULT_BUFFER_SIZE, // Default minimum buffer size.
    };
    GUID                    m_ObjectId;             // Unique ID for this object.
    CMTFSession*            m_pSession;             // Holds all session information.
    SHORT                   m_DataSetNumber;        // Holds the current dataset number.
    HANDLE                  m_hTape;                // Tape drive handle.
    CWsbBstrPtr             m_DeviceName;           // The name of the tape device.
    DWORD                   m_Flags;                // Holds data transfer type flag.
    CWsbBstrPtr             m_LastVolume;           // Name of the last volume backed up.
    CWsbBstrPtr             m_LastPath;             // Name of the last directory backed up.
    BOOL                    m_ValidLabel;           // True if the label is valid, the flag
                                                    //   knocked down on BUS_RESET and Medium
                                                    //   errors, and assumed valid at initialization.

    TAPE_GET_MEDIA_PARAMETERS m_sMediaParameters;   // We store media and drive parameters 
                                                    //   here when we open up the tape device...
    TAPE_GET_DRIVE_PARAMETERS m_sDriveParameters;   //

    CWsbBstrPtr             m_StreamName;           // Stream state information...
    ULONG                   m_Mode;                 // The kind of I/O.  See MVR_MODE_*
    ULARGE_INTEGER          m_StreamPBA;            // The PBA for the current Stream.  Used to tell if read ops are aligned with tape.
    ULARGE_INTEGER          m_StreamOffset;         // The Current offset into the data stream
    ULARGE_INTEGER          m_StreamSize;           // The size of the data stream

    BYTE *                  m_pStreamBuf;           // Internal stream buffer used to handle I/O for boundary conditions
    ULONG                   m_StreamBufSize;        // Max size of the internal stream buffer
    ULONG                   m_StreamBufUsed;        // The number of bytes of the internal stream buffer containing valid data
    ULONG                   m_StreamBufPosition;    // The current position of the stream pointer.
    ULARGE_INTEGER          m_StreamBufStartPBA;    // The corresponding starting PBA for the internal stream buffer

    CComPtr<IRmsCartridge>  m_pCartridge;           // A reference to the Cartridge in use by the DataMover.

    CRITICAL_SECTION        m_CriticalSection;      // Object sychronization support
    static int              s_InstanceCount;        // Counter of the number of object instances.
    // Tape I/O
    HRESULT OpenTape(void);
    HRESULT CloseTape(void);
    HRESULT WriteBuffer(IN BYTE *pBuffer, IN ULONG nBytesToWrite, OUT ULONG *pBytesWritten);
    HRESULT ReadBuffer(IN BYTE *pBuffer, IN ULONG nBytesToRead, OUT ULONG *pBytesRead);
    HRESULT WriteFilemarks(IN ULONG count);
    HRESULT GetPosition(OUT UINT64 *pPosition);
    HRESULT SetPosition(IN UINT64 position);
    HRESULT EnsurePosition(IN UINT64 position);
    HRESULT SpaceFilemarks(IN LONG count, OUT UINT64 *pPosition);
    HRESULT SpaceToEndOfData(OUT UINT64 *pPosition);
    HRESULT RewindTape(void);
    HRESULT MapTapeError(IN HRESULT hrToMap);

    HRESULT IsAccessEnabled(void);
    HRESULT Lock(void);
    HRESULT Unlock(void);

};

#endif // !defined(NtTapeIo_H)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\mover\server\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Mover.rc
//
#define IDS_CNTTAPEIO_DESC                4
#define IDR_CNtTapeIo                     4
#define IDS_CNTFILEIO_DESC                5
#define IDR_CNtFileIo                     5
#define IDS_CFILTERIO_DESC                9
#define IDR_CFilterIo                     9
#define IDS_PROJNAME                    100

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        9
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\mover\server\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(_STDAFX_H_)
#define _STDAFX_H_

//
// These NT header files must be included before any Win32 stuff or you
// get lots of compiler errors
//
extern "C" {
#include <nt.h>
}
extern "C" {
#include <ntrtl.h>
}
extern "C" {
#include <nturtl.h>
}

extern "C" {
#include <ntddtape.h>
}

#define WSB_TRACE_IS    WSB_TRACE_BIT_DATAMOVER

#include "Mover.h"

#endif // !defined(_STDAFX_H_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\rms\server\makefile.inc ===
$(O)\rms.res: RmsCartg.rgs \
              RmsChngr.rgs \
              RmsClien.rgs \
              RmsServr.rgs \
              RmsDrCls.rgs \
              RmsDrive.rgs \
              RmsIPort.rgs \
              RmsLibry.rgs \
              RmsMdSet.rgs \
              RmsNTMS.rgs  \
              RmsPartn.rgs \
              RmsReqst.rgs \
              RmsSSlot.rgs \
              RmsTmplt.rgs \
              ..\..\inc\$(O)\RmsLib.tlb   \

stdafx.h: ..\..\inc\rms.h

clean:
    -del $(O)\*.sbr
    -del $(O)\*.obj
    -del $(O)\*.res
    -del $(O)\*.pch
    -del $(TARGETPATH)\$(TARGET_DIRECTORY)\$(TARGETNAME).*
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\rms\server\rms.cpp ===
/*++

 

Module Name:

    Rms.cpp

Abstract:

    DLL main for Rms

Author:

    Ran Kalach          [rankala]         14-June-1999

Revision History:

--*/

// Rms.cpp : Implementation of DLL Exports.

// Note: Currently, Rms proxy/stub is compiled into a different DLL.
//      Below is relevant information if it is decided to merge the two DLLs.
// Note: Proxy/Stub Information
//      To merge the proxy/stub code into the object DLL, add the file 
//      dlldatax.c to the project.  Make sure precompiled headers 
//      are turned off for this file, and add _MERGE_PROXYSTUB to the 
//      defines for the project.  
//
//      If you are not running WinNT4.0 or Win95 with DCOM, then you
//      need to remove the following define from dlldatax.c
//      #define _WIN32_WINNT 0x0400
//
//      Further, if you are running MIDL without /Oicf switch, you also 
//      need to remove the following define from dlldatax.c.
//      #define USE_STUBLESS_PROXY
//
//      Modify the custom build rule for rmsint.idl by adding the following 
//      files to the Outputs.
//          rmsint_p.c
//          dlldata.c
//      To build a separate proxy/stub DLL, 
//      run nmake -f rmsps.mk in the project directory.

#include "stdafx.h"
#include "initguid.h"

#include "RmsServr.h"
#include "RmsLibry.h"
#include "RmsDrCls.h"
#include "RmsCartg.h"
#include "RmsDrive.h"
#include "RmsSSlot.h"
#include "RmsChngr.h"
#include "RmsIPort.h"
#include "RmsMdSet.h"
#include "RmsReqst.h"
#include "RmsPartn.h"
#include "RmsClien.h"
#include "RmsNTMS.h"

#ifdef _MERGE_PROXYSTUB
extern "C" HINSTANCE hProxyDll;
#endif

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_CRmsServer, CRmsServer)
    OBJECT_ENTRY(CLSID_CRmsLibrary, CRmsLibrary)
    OBJECT_ENTRY(CLSID_CRmsDriveClass, CRmsDriveClass)
    OBJECT_ENTRY(CLSID_CRmsCartridge, CRmsCartridge)
    OBJECT_ENTRY(CLSID_CRmsDrive, CRmsDrive)
    OBJECT_ENTRY(CLSID_CRmsStorageSlot, CRmsStorageSlot)
    OBJECT_ENTRY(CLSID_CRmsMediumChanger, CRmsMediumChanger)
    OBJECT_ENTRY(CLSID_CRmsIEPort, CRmsIEPort)
    OBJECT_ENTRY(CLSID_CRmsMediaSet, CRmsMediaSet)
    OBJECT_ENTRY(CLSID_CRmsRequest, CRmsRequest)
    OBJECT_ENTRY(CLSID_CRmsPartition, CRmsPartition)
    OBJECT_ENTRY(CLSID_CRmsClient, CRmsClient)
    OBJECT_ENTRY(CLSID_CRmsNTMS, CRmsNTMS)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    lpReserved;
#ifdef _MERGE_PROXYSTUB
    if (!PrxDllMain(hInstance, dwReason, lpReserved))
        return FALSE;
#endif
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllCanUnloadNow() != S_OK)
        return S_FALSE;
#endif
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
        return S_OK;
#endif
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    HRESULT hRes = PrxDllRegisterServer();
    if (FAILED(hRes))
        return hRes;
#endif
    // registers object, typelib and all interfaces in typelib
    CoInitialize( 0 );
    HRESULT hr = _Module.RegisterServer( FALSE );
    CoUninitialize( );
    return( hr );
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    PrxDllUnregisterServer();
#endif
    CoInitialize( 0 );
    _Module.UnregisterServer();
    CoUninitialize( );
    return( S_OK );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\rms\server\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Rms.rc
//
#define IDS_RMSSERVER_DESC              1
#define IDR_RmsServer                   1
#define IDS_RMSLIBRARY_DESC             2
#define IDR_RmsLibrary                  2
#define IDS_RMSDRIVECLASS_DESC          3
#define IDR_RmsDriveClass               3
#define IDS_RMSCARTRIDGE_DESC           4
#define IDR_RmsCartridge                4
#define IDS_RMSDRIVE_DESC               5
#define IDR_RmsDrive                    5
#define IDS_RMSSTORAGESLOT_DESC         6
#define IDR_RmsStorageSlot              6
#define IDS_RMSMEDIUMCHANGER_DESC       7
#define IDR_RmsMediumChanger            7
#define IDS_RMSIEPORT_DESC              8
#define IDR_RmsIEPort                   8
#define IDS_RMSMEDIASET_DESC            9
#define IDR_RmsMediaSet                 9
#define IDS_RMSREQUEST_DESC             10
#define IDR_RmsRequest                  10
#define IDS_RMSPARTITION_DESC           11
#define IDR_RmsPartition                11
#define IDS_RMSCLIENT_DESC              12
#define IDR_RmsClient                   12
#define IDS_RMSNTMS_DESC                13
#define IDR_RmsNTMS                     13
#define IDS_PRODUCT_NAME                102
#define IDS_RMS_ELEMENT_UNKNOWN         200
#define IDS_RMS_ELEMENT_STAGE           201
#define IDS_RMS_ELEMENT_LIBRARY         202
#define IDS_RMS_ELEMENT_SHELF           203
#define IDS_RMS_ELEMENT_OFFSITE         204
#define IDS_RMS_ELEMENT_DRIVE           205
#define IDS_RMS_ELEMENT_CHANGER         206
#define IDS_RMS_ELEMENT_IEPORT          207
#define IDS_RMS_CHANGER_UNKNOWN         300
#define IDS_RMS_CHANGER_AUTOMATIC       301
#define IDS_RMS_CHANGER_MANUAL          302
#define IDS_RMS_PORT_UNKNOWN            400
#define IDS_RMS_PORT_IMPORT             401
#define IDS_RMS_PORT_EXPORT             402
#define IDS_RMS_PORT_IMPORT_EXPORT      403
#define IDS_RMS_SLOT_SELECT_UNKNOWN     500
#define IDS_RMS_SLOT_SELECT_MINMOUNT    501
#define IDS_RMS_SLOT_SELECT_GROUP       502
#define IDS_RMS_SLOT_SELECT_SORTNAME    503
#define IDS_RMS_SLOT_SELECT_SORTBARCODE 504
#define IDS_RMS_SLOT_SELECT_LABEL       505
#define IDS_RMS_CARTRIDGE_STATUS_UNKNOWN 600
#define IDS_RMS_CARTRIDGE_STATUS_PRIVATE 601
#define IDS_RMS_CARTRIDGE_STATUS_SCRATCH 602
#define IDS_RMS_CARTRIDGE_STATUS_CLEANING 603
#define IDS_RMS_ATTRIBUTE_UNKNOWN       700
#define IDS_RMS_ATTRIBUTE_WRITE         701
#define IDS_RMS_ATTRIBUTE_READ          702
#define IDS_RMS_ATTRIBUTE_FULL          704
#define IDS_RMS_ATTRIBUTE_EMPTY         705
#define IDS_RMS_ATTRIBUTE_INUSE         706
#define IDS_RMS_ATTRIBUTE_BAD           707
#define IDS_RMS_DRIVE_SELECT_UNKNOWN    800
#define IDS_RMS_DRIVE_SELECT_RANDOM     801
#define IDS_RMS_DRIVE_SELECT_LRU        802
#define IDS_RMS_DRIVE_SELECT_ROUND_ROBIN 803
#define IDS_RMS_OBJECT_STATE_UNKNOWN    900
#define IDS_RMS_OBJECT_STATE_ENABLED    901
#define IDS_RMS_OBJECT_STATE_DISABLED   902
#define IDS_RMS_OBJECT_STATE_ERROR      903
#define IDS_RMS_MEDIA_UNKNOWN           1000
#define IDS_RMS_MEDIA_8MM               1001
#define IDS_RMS_MEDIA_4MM               1002
#define IDS_RMS_MEDIA_DLT               1003
#define IDS_RMS_MEDIA_OPTICAL_525       1004
#define IDS_RMS_MEDIA_OPTICAL_35        1005
#define IDS_RMS_MEDIA_WORM_525          1006
#define IDS_RMS_MEDIA_CDR               1007
#define IDS_RMS_MEDIA_CDROM             1008
#define IDS_RMS_MEDIA_DVD               1009
#define IDS_RMS_MEDIA_ZIP_100           1010
#define IDS_RMS_MEDIA_JAZ               1011
#define IDS_RMS_MEDIA_FIXED_DISK        1012
#define IDS_RMS_DEVICE_UNKNOWN          1100
#define IDS_RMS_DEVICE_FIXED            1101
#define IDS_RMS_DEVICE_REMOVABE         1102
#define IDS_RMS_DEVICE_TAPE             1103
#define IDS_RMS_DEVICE_CDROM            1104
#define IDS_RMS_DEVICE_WORM             1105
#define IDS_RMS_DEVICE__OPTICAL         1106
#define IDS_RMS_DEVICE_CHANGER          1107
#define IDS_RMS_MODE_UNKNOWN            1200
#define IDS_RMS_MODE_READ               1201
#define IDS_RMS_MODE_READ_WRITE         1202
#define IDS_RMS_MODE_WRITE              1203
#define IDS_RMS_MEDIA_SET_UNKNOWN       1300
#define IDS_RMS_MEDIA_SET_FOLDER        1301
#define IDS_RMS_MEDIA_SET_LIBRARY       1302
#define IDS_RMS_MEDIA_SET_SHELF         1303
#define IDS_RMS_MEDIA_SET_OFFSITE       1304
#define IDS_RMS_MEDIA_SET_NTMS          1305
#define IDS_RMS_DEFAULT_FIXED_DRIVE_LIBRARY_NAME 2000
#define IDS_RMS_DEFAULT_FIXED_DRIVE_MEDIA_SET_NAME 2001
#define IDS_RMS_DEFAULT_OPTICAL_LIBRARY_NAME 2002
#define IDS_RMS_DEFAULT_OPTICAL_MEDIA_SET_NAME 2003
#define IDS_RMS_DEFAULT_TAPE_LIBRARY_NAME 2004
#define IDS_RMS_DEFAULT_TAPE_MEDIA_SET_NAME 2005

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        14
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\rms\server\rmscartg.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    RmsCartg.cpp

Abstract:

    Implementation of CRmsCartridge

Author:

    Brian Dodd          [brian]         15-Nov-1996

Revision History:

--*/

#include "stdafx.h"
#include "RmsCartg.h"
#include "RmsNTMS.h"
#include "RmsServr.h"

int CRmsCartridge::s_InstanceCount = 0;

#define RMS_USE_ACTIVE_COLLECTION 1
////////////////////////////////////////////////////////////////////////////////
//
// Base class implementations
//


STDMETHODIMP
CRmsCartridge::CompareTo(
    IN  IUnknown    *pCollectable,
    OUT SHORT       *pResult
    )
/*++

Implements:

    IWsbCollectable::CompareTo

--*/
{
    HRESULT     hr = E_FAIL;
    SHORT       result = 1;

    WsbTraceIn( OLESTR("CRmsCartridge::CompareTo"), OLESTR("") );

    try {

        // Validate arguments - Okay if pResult is NULL
        WsbAssertPointer( pCollectable );

        // We need the IRmsCartridge interface to get the value of the object.
        CComQIPtr<IRmsCartridge, &IID_IRmsCartridge> pCartridge = pCollectable;
        WsbAssertPointer( pCartridge );

        // Get find by option
        CComQIPtr<IRmsComObject, &IID_IRmsComObject> pObject = pCollectable;
        WsbAssertPointer( pObject );

        switch ( m_findBy ) {

        case RmsFindByName:
            {

                CWsbBstrPtr name;

                // Get name
                WsbAffirmHr( pCartridge->GetName( &name ) );

                // Compare the names
                result = (USHORT)wcscmp( m_Name, name );
                hr = ( 0 == result ) ? S_OK : S_FALSE;

            }
            break;

        case RmsFindByExternalLabel:
            {

                CWsbBstrPtr externalLabel;
                LONG        externalNumber;

                // Get external label
                WsbAffirmHr( pCartridge->GetTagAndNumber(&externalLabel, &externalNumber) );

                // Compare the label
                result = (SHORT)wcscmp( m_externalLabel, externalLabel );
                hr = ( 0 == result ) ? S_OK : S_FALSE;

            }
            break;

        case RmsFindByExternalNumber:
            {

                CWsbBstrPtr externalLabel;
                LONG        externalNumber;

                // Get external number
                WsbAffirmHr( pCartridge->GetTagAndNumber(&externalLabel, &externalNumber) );

                if( m_externalNumber == externalNumber ) {

                    // External numbers match
                    hr = S_OK;
                    result = 0;

                }
                else {
                    hr = S_FALSE;
                    result = 1;
                }

            }
            break;

        case RmsFindByScratchMediaCriteria:
            {

                RmsStatus status;
                GUID mediaSetIdToFind, mediaSetId;

                WsbAssertHr(pCartridge->GetStatus((LONG *)&status));
                WsbAssertHr(pCartridge->GetMediaSetId(&mediaSetId));
                WsbAssertHr(GetMediaSetId(&mediaSetIdToFind));

                if ( (RmsStatusScratch == status) && (mediaSetIdToFind == mediaSetId)) {

                    // Status is scratch
                    hr = S_OK;
                    result = 0;

                }
                else {
                    hr = S_FALSE;
                    result = 1;
                }

            }
            break;

        case RmsFindByCartridgeId:
        case RmsFindByObjectId:
        default:

            // Do CompareTo for object
            hr = CRmsComObject::CompareTo( pCollectable, &result );
            break;

        }

    }
    WsbCatch( hr );

    if ( SUCCEEDED(hr) && (0 != pResult) ) {
       *pResult = result;
    }

    WsbTraceOut( OLESTR("CRmsCartridge::CompareTo"),
                 OLESTR("hr = <%ls>, result = <%ls>"),
                 WsbHrAsString( hr ), WsbPtrToShortAsString( pResult ) );

    return hr;
}



HRESULT
CRmsCartridge::FinalConstruct(
    void
    )
/*++

Implements:

    CComObjectRoot::FinalConstruct

--*/
{
    HRESULT hr = S_OK;

    WsbTraceIn(OLESTR("CRmsCartridge::FinalConstruct"), OLESTR("this = %p"),
            static_cast<void *>(this));

    try {
        WsbAssertHr(CWsbObject::FinalConstruct());

        // Initialize fields
        m_Name = OLESTR("");
        m_Description = OLESTR("");
        m_externalLabel = OLESTR("");
        m_externalNumber = 0;
        m_sizeofOnMediaId = 0;
        m_typeofOnMediaId = 0;
        m_pOnMediaId = 0;
        m_onMediaLabel = RMS_UNDEFINED_STRING;
        m_status = RmsStatusUnknown;
        m_type   = RmsMediaUnknown;
        m_BlockSize = 0;
        m_isTwoSided = 0;
        m_isMounted = 0;
        m_isInTransit = 0;
        m_isAvailable = 0;
        m_isMountedSerialized = 0;
        m_home.SetLocation(0,GUID_NULL,GUID_NULL,0,0,0,0,0);
        m_location.SetLocation(0,GUID_NULL,GUID_NULL,0,0,0,0,0);
        m_destination.SetLocation(0,GUID_NULL,GUID_NULL,0,0,0,0,0);
        m_mailStop = RMS_UNDEFINED_STRING;
        m_pDrive = 0;
        m_sizeofInfo = 0;
        for (int i = 0; i < RMS_STR_MAX_CARTRIDGE_INFO; i++){
            m_info[i] = 0;
        }

        m_ownerClassId = GUID_NULL;
        m_pParts = 0;
        m_verifierClass = GUID_NULL;
        m_portalClass = GUID_NULL;

        m_pDataCache = NULL;
        m_DataCacheSize = 0;
        m_DataCacheUsed = 0;
        m_DataCacheStartPBA.QuadPart = 0;

        m_ManagedBy = RmsMediaManagerUnknown;

    } WsbCatch(hr);

    s_InstanceCount++;
    WsbTraceAlways(OLESTR("CRmsCartridge::s_InstanceCount += %d\n"), s_InstanceCount);

    WsbTraceOut(OLESTR("CRmsCartridge::FinalConstruct"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


STDMETHODIMP
CRmsCartridge::FinalRelease(void) 
{
    HRESULT hr = S_OK;

    WsbTraceIn(OLESTR("CRmsCartridge::FinalRelease"), OLESTR("this = %p"),
            static_cast<void *>(this));

    try {
        
        if (m_pOnMediaId) {
            WsbFree(m_pOnMediaId);
            m_pOnMediaId = NULL;
            m_sizeofOnMediaId = 0;
            m_typeofOnMediaId = 0;
        }

        if (m_pDataCache) {
            WsbFree(m_pDataCache);
            m_pDataCache = NULL;
            m_DataCacheSize = 0;
            m_DataCacheUsed = 0;
            m_DataCacheStartPBA.QuadPart = 0;
        }

        CWsbObject::FinalRelease();

    } WsbCatch(hr);

    s_InstanceCount--;
    WsbTraceAlways(OLESTR("CRmsCartridge::s_InstanceCount -= %d\n"), s_InstanceCount);

    WsbTraceOut(OLESTR("CRmsCartridge::FinalRelease"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}


STDMETHODIMP
CRmsCartridge::GetClassID(
    OUT CLSID* pClsid
    )
/*++

Implements:

    IPersist::GetClassId

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CRmsCartridge::GetClassID"), OLESTR(""));

    try {

        WsbAssertPointer(pClsid);

        *pClsid = CLSID_CRmsCartridge;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsCartridge::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return(hr);
}

STDMETHODIMP
CRmsCartridge::GetSizeMax(
    OUT ULARGE_INTEGER* pcbSize
    )
/*++

Implements:

    IPersistStream::GetSizeMax

--*/
{
    HRESULT     hr = E_NOTIMPL;

//    ULONG       nameLen;
//    ULONG       externalLabelLen;
//    ULONG       mailStopLen;

//    WsbTraceIn(OLESTR("CRmsCartridge::GetSizeMax"), OLESTR(""));

//    try {
//        WsbAssert(0 != pcbSize, E_POINTER);

//        nameLen = SysStringByteLen(m_name);
//        externalLabelLen = SysStringByteLen(m_externalLabel);
//        mailStopLen = SysStringByteLen(m_mailStop);

//        // set up size of CRmsCartridge
//        pcbSize->QuadPart  = WsbPersistSizeOf(GUID)        +  // m_cartridgeId
//                             WsbPersistSizeOf(ULONG)       +  // length of m_name
//                             nameLen                       +  // m_name
//                             WsbPersistSizeOf(ULONG)       +  // length of m_externalLabel
//                             externalLabelLen              +  // m_externalLabel
//                             WsbPersistSizeOf(LONG)        +  // m_externalNumber
//                             WsbPersistSizeOf(LONG)        +  // m_status
//                             WsbPersistSizeOf(LONG)        +  // m_type
//                             WsbPersistSizeOf(BOOL)        +  // m_isTwoSided
//                             WsbPersistSizeOf(CRmsLocator) +  // m_home
//                             WsbPersistSizeOf(CRmsLocator) +  // m_location
//                             WsbPersistSizeOf(ULONG)       +  // size of m_mailStop
//                             mailStopLen                   +  // m_mailStop
//                             WsbPersistSizeOf(SHORT)       +  // m_sizeofInfo
//                             RMS_STR_MAX_CARTRIDGE_INFO    +  // m_Info
//                             WsbPersistSizeOf(CLSID)       +  // m_ownerClassId
//                                                              // m_pParts
////                           WsbPersistSizeOf(CComPtr<IWsbIndexedCollection>) +
//                             WsbPersistSizeOf(CLSID)       +  // m_verifierClass
//                             WsbPersistSizeOf(CLSID);         // m_portalClass


//    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsCartridge::GetSizeMax"), OLESTR("hr = <%ls>, Size = <%ls>"), WsbHrAsString(hr), WsbPtrToUliAsString(pcbSize));

    return(hr);
}

STDMETHODIMP
CRmsCartridge::Load(
    IN IStream* pStream
    )
/*++

Implements:

    IPersistStream::Load

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CRmsCartridge::Load"), OLESTR(""));

    try {
        ULONG temp;

        WsbAssert(0 != pStream, E_POINTER);

        WsbAffirmHr(CRmsStorageInfo::Load(pStream));

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_objectId));

        m_externalLabel.Free();
        WsbAffirmHr(WsbBstrFromStream(pStream, &m_externalLabel));

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_externalNumber));

        WsbAffirmHr(WsbLoadFromStream(pStream, &temp));
        m_status = (RmsStatus)temp;

        WsbAffirmHr(WsbLoadFromStream(pStream, &temp));
        m_type = (RmsMedia)temp;

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_BlockSize));

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_isTwoSided));

        WsbAffirmHr(m_home.Load(pStream));

        WsbAffirmHr(m_location.Load(pStream));

        m_mailStop.Free();
        WsbAffirmHr(WsbBstrFromStream(pStream, &m_mailStop));

//      WsbAffirmHr(m_pParts->Load(pStream));

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_sizeofInfo));

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_info[0], MaxInfo));

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_ownerClassId));

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_verifierClass));

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_portalClass));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsCartridge::Load"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

STDMETHODIMP
CRmsCartridge::Save(
    IN IStream* pStream,
    IN BOOL clearDirty
    )
/*++

Implements:

    IPersistStream::Save

--*/
{
    HRESULT     hr = S_OK;



    WsbTraceIn(OLESTR("CRmsCartridge::Save"), OLESTR("clearDirty = <%ls>"), WsbBoolAsString(clearDirty));

    try {
        WsbAssert(0 != pStream, E_POINTER);

        WsbAffirmHr(CRmsStorageInfo::Save(pStream, clearDirty));

        WsbAffirmHr(WsbSaveToStream(pStream, m_objectId));

        WsbAffirmHr(WsbBstrToStream(pStream, m_externalLabel));

        WsbAffirmHr(WsbSaveToStream(pStream, m_externalNumber));

        WsbAffirmHr(WsbSaveToStream(pStream, (ULONG) m_status));

        WsbAffirmHr(WsbSaveToStream(pStream, (ULONG) m_type));

        WsbAffirmHr(WsbSaveToStream(pStream, m_BlockSize));

        WsbAffirmHr(WsbSaveToStream(pStream, m_isTwoSided));

        WsbAffirmHr(m_home.Save(pStream, clearDirty));

        WsbAffirmHr(m_location.Save(pStream, clearDirty));

        WsbAffirmHr(WsbBstrToStream(pStream, m_mailStop));

//      WsbAffirmHr(m_pParts->Save(pStream, clearDirty));

        WsbAffirmHr(WsbSaveToStream(pStream, m_sizeofInfo));

        WsbAffirmHr(WsbSaveToStream(pStream, &m_info [0], MaxInfo));

        WsbAffirmHr(WsbSaveToStream(pStream, m_ownerClassId));

        WsbAffirmHr(WsbSaveToStream(pStream, m_verifierClass));

        WsbAffirmHr(WsbSaveToStream(pStream, m_portalClass));

        // Do we need to clear the dirty bit?
        if (clearDirty) {
            m_isDirty = FALSE;
        }
    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CRmsCartridge::Save"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

STDMETHODIMP
CRmsCartridge::Test(
    OUT USHORT *pPassed,
    OUT USHORT *pFailed
    )
/*++

Implements:

    IWsbTestable::Test

--*/
{
    HRESULT                 hr = S_OK;

    CComPtr<IRmsCartridge>  pCartridge1;
    CComPtr<IRmsCartridge>  pCartridge2;
    CComPtr<IPersistFile>   pFile1;
    CComPtr<IPersistFile>   pFile2;

    LONG                    passFail;
    LONG                    i;

    CWsbBstrPtr             bstrVal1 = OLESTR("5A5A5A");
    CWsbBstrPtr             bstrVal2 = OLESTR("A5A5A5");
    CWsbBstrPtr             bstrWork1;
    CWsbBstrPtr             bstrWork2;

    LONG                    longVal1 = 0x11111111;
    LONG                    longVal2 = 0x22222222;
    LONG                    longVal3 = 0x33333333;
    LONG                    longVal4 = 0x44444444;

    LONG                    longWork0;
    LONG                    longWork1;
    LONG                    longWork2;
    LONG                    longWork3;
    LONG                    longWork4;

    LONG                    mediaTable [RMSMAXMEDIATYPES] = { RmsMediaUnknown,
                                                              RmsMedia8mm,
                                                              RmsMedia4mm,
                                                              RmsMediaDLT,
                                                              RmsMediaOptical,
                                                              RmsMediaMO35,
                                                              RmsMediaWORM,
                                                              RmsMediaCDR,
                                                              RmsMediaDVD,
                                                              RmsMediaDisk,
                                                              RmsMediaFixed,
                                                              RmsMediaTape };

    GUID                    guidVal1 = { 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0};
    GUID                    guidVal2 = { 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1};

    GUID                    guidWork1;
    GUID                    guidWork2;

    BOOL                    boolTrue  = TRUE;
    BOOL                    boolFalse = FALSE;

    BOOL                    boolWork1;


    WsbTraceIn(OLESTR("CRmsCartridge::Test"), OLESTR(""));

    try {
        // Get the Cartridge interface.
        hr = S_OK;

        try {
            WsbAssertHr(((IUnknown*) (IRmsCartridge*) this)->QueryInterface(IID_IRmsCartridge, (void**) &pCartridge1));

            // Test SetName & GetName interface
            bstrWork1 = bstrVal1;

            SetName(bstrWork1);

            GetName(&bstrWork2);

            if (bstrWork1 == bstrWork2){
                (*pPassed)++;
            } else {
                (*pFailed)++;
            }

            // Test SetTagAndNumber & GetTagAndNumber
            bstrWork1 = bstrVal2;

            longWork1 = 99;

            SetTagAndNumber(bstrWork1, longWork1);

            GetTagAndNumber(&bstrWork2, &longWork2);

            if ((bstrWork1 == bstrWork2)  && (longWork1 == longWork2)){
                (*pPassed)++;
            } else {
                (*pFailed)++;
            }

            // Test SetIsTwoSided & IsTwoSided to True
            hr = S_OK;

            try{
                WsbAffirmHr(SetIsTwoSided (TRUE));
                WsbAffirmHr(IsTwoSided ());
            } WsbCatch (hr);

            if (hr == S_OK){
                (*pPassed)++;
            } else {
                (*pFailed)++;
            }

            // Test SetTwoSided & IsTwoSided to FALSE
            hr = S_OK;

            try{
                WsbAffirmHr(SetIsTwoSided (FALSE));
                WsbAffirmHr(IsTwoSided ());
            } WsbCatch (hr);

            if (hr == S_OK){
                (*pFailed)++;
            } else {
                (*pPassed)++;
            }

            // Test SetStatus & GetStatus
            for (i = RmsStatusUnknown; i < RmsStatusCleaning; i++){

                longWork1 = i;

                SetStatus (longWork1);

                GetStatus (&longWork2);

                if (longWork1 == longWork2){
                    (*pPassed)++;
                } else {
                    (*pFailed)++;
                }
            }

            // Test SetType & GetType
            for (i = RmsMediaUnknown; i < RMSMAXMEDIATYPES; i++){

                longWork1 = mediaTable[i];

                SetType (longWork1);

                GetType (&longWork2);

                if (longWork1 == longWork2){
                    (*pPassed)++;
                } else {
                    (*pFailed)++;
                }
            }

            // Test SetHome & GetHome
            SetHome (RmsMediaOptical, guidVal1, guidVal2, longVal1, longVal2,
                     longVal3, longVal4, boolTrue);

            GetHome (&longWork0, &guidWork1, &guidWork2, &longWork1, &longWork2,
                     &longWork3, &longWork4, &boolWork1);

            passFail = 0;

            if (longWork0 == RmsMediaOptical){
                passFail++;
            }

            if (guidWork1 == guidVal1){
                passFail++;
            }

            if (guidWork2 == guidVal2){
                passFail++;
            }

            if (longWork1 == longVal1){
                passFail++;
            }

            if (longWork2 == longVal2){
                passFail++;
            }

            if (longWork3 == longVal3){
                passFail++;
            }

            if (longWork4 == longVal4){
                passFail++;
            }

            if (boolWork1 == TRUE){
                passFail++;
            }

            if (passFail == 8){
                (*pPassed)++;
            } else {
                (*pFailed)++;
            }

            // Test SetLocation & GetLocation
            SetLocation (RmsMediaOptical, guidVal1, guidVal2, longVal1, longVal2,
                         longVal3, longVal4, boolTrue);

            GetLocation (&longWork0, &guidWork1, &guidWork2, &longWork1, &longWork2,
                         &longWork3, &longWork4, &boolWork1);

            passFail = 0;

            if (longWork0 == RmsMediaOptical){
                passFail++;
            }

            if (guidWork1 == guidVal1){
                passFail++;
            }

            if (guidWork2 == guidVal2){
                passFail++;
            }

            if (longWork1 == longVal1){
                passFail++;
            }

            if (longWork2 == longVal2){
                passFail++;
            }

            if (longWork3 == longVal3){
                passFail++;
            }

            if (longWork4 == longVal4){
                passFail++;
            }

            if (boolWork1 == TRUE){
                passFail++;
            }

            if (passFail == 8){
                (*pPassed)++;
            } else {
                (*pFailed)++;
            }

            // Test SetMailStop & GetMailStop interface
            SetName(bstrVal1);

            GetName(&bstrWork1);

            if ((bstrWork1 = bstrVal1) == 0){
                (*pPassed)++;
            } else {
                (*pFailed)++;
            }

        } WsbCatch(hr);

        // Tally up the results

        hr = S_OK;

        if (*pFailed) {
            hr = S_FALSE;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsCartridge::Test"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}
////////////////////////////////////////////////////////////////////////////////
//
// IRmsCartridge implementation
//


STDMETHODIMP
CRmsCartridge::GetCartridgeId(
    GUID   *pCartId
    )
/*++

Implements:

    IRmsCartridge::GetCartridgeId

--*/
{
    HRESULT hr = E_FAIL;

    try {
        WsbAssertPointer( pCartId );

        *pCartId = m_objectId;

        hr = S_OK;
    }
    WsbCatch(hr)

    return hr;
}


STDMETHODIMP
CRmsCartridge::SetCartridgeId(
    GUID   cartId
    )
/*++

Implements:

    IRmsCartridge::SetMediaSetId

--*/
{
    m_objectId = cartId;
    m_isDirty = TRUE;

    return S_OK;
}


STDMETHODIMP
CRmsCartridge::GetMediaSetId(
    GUID   *pMediaSetId
    )
/*++

Implements:

    IRmsCartridge::GetMediaSetId

--*/
{
    HRESULT hr = E_FAIL;

    try {
        WsbAssertPointer( pMediaSetId );

        *pMediaSetId = m_location.m_mediaSetId;

        hr = S_OK;
    }
    WsbCatch(hr)

    return hr;
}


STDMETHODIMP
CRmsCartridge::SetMediaSetId(
    GUID   mediaSetId
    )
/*++

Implements:

    IRmsCartridge::SetMediaSetId

--*/
{
    m_location.m_mediaSetId = mediaSetId;
    m_isDirty = TRUE;

    return S_OK;
}


STDMETHODIMP
CRmsCartridge::GetName(
    BSTR  *pName
    )
/*++

Implements:

    IRmsCartridge::GetName

--*/
{
    HRESULT hr = E_FAIL;

    try {
        WsbAssertPointer(pName);

        WsbAffirmHr( m_Name.CopyToBstr(pName) );

        hr = S_OK;
    }
    WsbCatch(hr);

    return hr;
}

STDMETHODIMP
CRmsCartridge::SetName(
    BSTR    name
    )
/*++

Implements:

    IRmsCartridge::SetName

--*/
{
    m_Name = name;
    m_isDirty = TRUE;
    return S_OK;
}


STDMETHODIMP
CRmsCartridge::GetDescription(
    BSTR  *pDescription
    )
/*++

Implements:

    IRmsCartridge::GetDescription

--*/
{
    HRESULT hr = E_FAIL;

    try {
        WsbAssertPointer(pDescription);

        WsbAffirmHr( m_Description.CopyToBstr(pDescription) );

        hr = S_OK;
    }
    WsbCatch(hr);

    return hr;
}

STDMETHODIMP
CRmsCartridge::SetDescription(
    BSTR    description
    )
/*++

Implements:

    IRmsCartridge::SetDescription

--*/
{
    m_Description = description;
    m_isDirty = TRUE;
    return S_OK;
}

STDMETHODIMP
CRmsCartridge::GetTagAndNumber(
    BSTR  *pTag,
    LONG  *pNumber
    )
/*++

Implements:

    IRmsCartridge::GetTagAndNumber

--*/
{
    HRESULT hr = E_FAIL;

    try {
        WsbAssertPointer(pTag);
        WsbAssertPointer(pNumber);

        WsbAffirmHr( m_externalLabel.CopyToBstr(pTag) );
        *pNumber = m_externalNumber;

        hr = S_OK;
    }
    WsbCatch(hr);

    return hr;
}

STDMETHODIMP
CRmsCartridge::SetTagAndNumber(
    BSTR    tag,
    LONG    number
    )
/*++

Implements:

    IRmsCartridge::SetTagAndNumber

--*/
{
    m_externalLabel = tag;
    m_externalNumber = number;
    m_isDirty = TRUE;
    return S_OK;
}

STDMETHODIMP
CRmsCartridge::GetBarcode(
    BSTR  *pBarcode
    )
/*++

Implements:

    IRmsCartridge::GetBarcode

--*/
{
    HRESULT hr = S_OK;

    try {
        WsbAssertPointer(pBarcode);

        WsbAffirm(wcslen((WCHAR*)m_externalLabel) > 0, E_FAIL);
        WsbAffirmHr(m_externalLabel.CopyToBstr(pBarcode));

    } WsbCatch(hr);

    return hr;
}


STDMETHODIMP
CRmsCartridge::GetOnMediaIdentifier(
    BYTE *pIdentifier,
    LONG *pSize,
    LONG *pType
    )
/*++

Implements:

    IRmsCartridge::GetOnMediaIdentifier

--*/
{
    HRESULT hr = E_FAIL;

    try {
        WsbAssertPointer( pIdentifier );
        WsbAssertPointer( pSize );
        WsbAssertPointer( pType );

        memmove (pIdentifier, m_pOnMediaId, m_sizeofOnMediaId);
        *pSize = m_sizeofOnMediaId;
        *pType = m_typeofOnMediaId;

        hr = S_OK;
    }
    WsbCatch(hr);

    return hr;
}

STDMETHODIMP
CRmsCartridge::SetOnMediaIdentifier(
    BYTE *pIdentifier,
    LONG size,
    LONG type
    )
/*++

Implements:

    IRmsCartridge::SetOnMediaIdentifier

--*/
{
    HRESULT hr = E_FAIL;

    try {
        WsbAssertPointer( pIdentifier );

        CComPtr<IRmsNTMS> pNtms;

        if ( m_pOnMediaId ) {
            WsbFree( m_pOnMediaId );
            m_pOnMediaId = 0;
        }
        m_pOnMediaId = (BYTE *)WsbAlloc( size );
        WsbAffirmPointer(m_pOnMediaId);
        memset(m_pOnMediaId, 0, size);

        memmove (m_pOnMediaId, pIdentifier, size);
        m_sizeofOnMediaId = size;
        m_typeofOnMediaId = type;
        m_isDirty = TRUE;

        if (RmsMediaManagerNTMS == m_ManagedBy) {
            // Now update any external database
            CComQIPtr<IRmsServer, &IID_IRmsServer> pServer = g_pServer;
            WsbAffirmHr( pServer->GetNTMS( &pNtms ) );
            WsbAffirmHr( pNtms->UpdateOmidInfo( m_objectId, pIdentifier, size, type ) );
        }

        hr = S_OK;

    } WsbCatch(hr);

    return hr;
}


STDMETHODIMP
CRmsCartridge::GetOnMediaLabel(
    BSTR *pLabel
    )
/*++

Implements:

    IRmsCartridge::GetOnMediaLabel

--*/
{
    HRESULT hr = E_FAIL;

    try {
        WsbAssertPointer(pLabel);

        WsbAffirmHr( m_onMediaLabel.CopyToBstr(pLabel) );

        hr = S_OK;
    }
    WsbCatch(hr);

    return hr;
}


STDMETHODIMP
CRmsCartridge::SetOnMediaLabel(
    BSTR label
    )
/*++

Implements:

    IRmsCartridge::SetOnMediaLabel

--*/
{
    m_onMediaLabel = label;
    m_isDirty = TRUE;
    return S_OK;
}


STDMETHODIMP CRmsCartridge::GetStatus(
    LONG *pStatus
    )
/*++

Implements:

    IRmsCartridge::GetStatus

--*/
{
    *pStatus = m_status;
    return S_OK;
}

STDMETHODIMP CRmsCartridge::SetStatus(
    LONG status
    )
/*++

Implements:

    IRmsCartridge::SetStatus

--*/
{
    m_status = (RmsStatus)status;
    m_isDirty = TRUE;
    return S_OK;
}


STDMETHODIMP
CRmsCartridge::GetType(
    LONG  *pType
    )
/*++

Implements:

    IRmsCartridge::GetType

--*/
{
    *pType = (LONG) m_type;
    return S_OK;
}


STDMETHODIMP
CRmsCartridge::SetType(
    LONG  type
    )
/*++

Implements:

    IRmsCartridge::SetType

--*/
{
    m_type = (RmsMedia) type;
    m_isDirty = TRUE;
    return S_OK;
}



STDMETHODIMP
CRmsCartridge::GetBlockSize(
    LONG  *pBlockSize
    )
/*++

Implements:

    IRmsCartridge::GetBlockSize

--*/
{
    HRESULT hr = S_OK;

    try {

        if (!m_BlockSize) {
            if (RmsMediaManagerNTMS == m_ManagedBy) {
                LONG blockSize;
                CComPtr<IRmsNTMS> pNtms;
                CComQIPtr<IRmsServer, &IID_IRmsServer> pServer = g_pServer;
                WsbAffirmHr(pServer->GetNTMS(&pNtms));
                if (S_OK == pNtms->GetBlockSize(m_objectId, &blockSize)) {
                    m_BlockSize = blockSize;
                }
            }
        }

        *pBlockSize = m_BlockSize;

    } WsbCatch(hr);


    return hr;
}


STDMETHODIMP
CRmsCartridge::SetBlockSize(
    LONG  blockSize
    )
/*++

Implements:

    IRmsCartridge::SetBlockSize

--*/
{
    HRESULT hr = S_OK;

    try {

        if (RmsMediaManagerNTMS == m_ManagedBy) {
            // Update external database
            CComPtr<IRmsNTMS> pNtms;
            CComQIPtr<IRmsServer, &IID_IRmsServer> pServer = g_pServer;
            WsbAffirmHr(pServer->GetNTMS(&pNtms));
            WsbAffirmHr(pNtms->SetBlockSize(m_objectId, blockSize));
        }

        m_BlockSize = blockSize;
        m_isDirty = TRUE;

    } WsbCatch(hr);

    return hr;
}


STDMETHODIMP
CRmsCartridge::SetIsTwoSided(
    BOOL    flag
    )
/*++

Implements:

    IRmsCartridge::SetTwoSided

--*/
{
    m_isTwoSided = flag;
    m_isDirty = TRUE;
    return S_OK;
}


STDMETHODIMP
CRmsCartridge::IsTwoSided(
    VOID
    )
/*++

Implements:

    IRmsCartridge::IsTwoSided

--*/
{
    HRESULT     hr = E_FAIL;

    hr = m_isTwoSided ? S_OK : S_FALSE;

    return (hr);
}

STDMETHODIMP
CRmsCartridge::SetIsMounted(
    BOOL    flag
    )
/*++

Implements:

    IRmsCartridge::SetMounted

--*/
{
    m_isMounted = flag;

    if ( FALSE == m_isMounted ) {

        m_pDrive = 0;

    }

    return S_OK;
}


STDMETHODIMP
CRmsCartridge::IsMounted(
    VOID
    )
/*++

Implements:

    IRmsCartridge::IsMounted

--*/
{
    HRESULT     hr = E_FAIL;

    hr = m_isMounted ? S_OK : S_FALSE;

    return (hr);
}


STDMETHODIMP CRmsCartridge::GetHome(
    LONG *pType,
    GUID *pLibId,
    GUID *pMediaSetId,
    LONG *pPos,
    LONG *pAlt1,
    LONG *pAlt2,
    LONG *pAlt3,
    BOOL *pInvert
    )
/*++

Implements:

    IRmsCartridge::GetHome

--*/
{
    return m_home.GetLocation(pType,
                              pLibId,
                              pMediaSetId,
                              pPos,
                              pAlt1,
                              pAlt2,
                              pAlt3,
                              pInvert);

}


STDMETHODIMP CRmsCartridge::SetHome(
    LONG type,
    GUID libId,
    GUID mediaSetId,
    LONG pos,
    LONG alt1,
    LONG alt2,
    LONG alt3,
    BOOL invert
    )
/*++

Implements:

    IRmsCartridge::SetHome

--*/
{
    return m_home.SetLocation(type,
                              libId,
                              mediaSetId,
                              pos,
                              alt1,
                              alt2,
                              alt3,
                              invert);

}


STDMETHODIMP
CRmsCartridge::GetLocation(
    LONG *pType,
    GUID *pLibId,
    GUID *pMediaSetId,
    LONG *pPos,
    LONG *pAlt1,
    LONG *pAlt2,
    LONG *pAlt3,
    BOOL *pInvert)
/*++

Implements:

    IRmsCartridge::GetLocation

--*/
{
    return m_location.GetLocation(pType,
                                  pLibId,
                                  pMediaSetId,
                                  pPos,
                                  pAlt1,
                                  pAlt2,
                                  pAlt3,
                                  pInvert);
}


STDMETHODIMP
CRmsCartridge::SetLocation(
    LONG type,
    GUID libId,
    GUID mediaSetId,
    LONG pos,
    LONG alt1,
    LONG alt2,
    LONG alt3,
    BOOL invert)
/*++

Implements:

    IRmsCartridge::SetLocation

--*/
{
    return m_location.SetLocation(type,
                                  libId,
                                  mediaSetId,
                                  pos,
                                  alt1,
                                  alt2,
                                  alt3,
                                  invert);

}


STDMETHODIMP
CRmsCartridge::GetMailStop(
    BSTR    *pMailStop
    )
/*++

Implements:

    IRmsCartridge::GetMailStop

--*/
{
    HRESULT hr = E_FAIL;

    try {
        WsbAssertPointer (pMailStop);

        WsbAffirmHr( m_mailStop.CopyToBstr(pMailStop) );

        hr = S_OK;
    }
    WsbCatch(hr);

    return hr;
}


STDMETHODIMP
CRmsCartridge::SetMailStop(
    BSTR  mailStop
    )
/*++

Implements:

    IRmsCartridge::SetMailStop

--*/
{
    m_mailStop = mailStop;
    m_isDirty = TRUE;
    return S_OK;
}


STDMETHODIMP
CRmsCartridge::GetDrive(
    IRmsDrive    **ptr
    )
/*++

Implements:

    IRmsCartridge::GetDrive

--*/
{
    HRESULT hr = E_FAIL;

    try {
        WsbAssertPointer( ptr );

        WsbAffirmPointer(m_pDrive);

        *ptr = m_pDrive;
        m_pDrive->AddRef();

        hr = S_OK;

    } WsbCatch( hr );

    return(hr);
}


STDMETHODIMP
CRmsCartridge::SetDrive(
    IRmsDrive    *ptr
    )
/*++

Implements:

    IRmsChangerElement::SetCartridge

--*/
{
    HRESULT hr = E_FAIL;

    try {
        WsbAssertPointer( ptr );

        CComQIPtr<IRmsChangerElement, &IID_IRmsChangerElement> pElmt = ptr;

        WsbAffirmHr( pElmt->SetCartridge( this ) );

        if ( m_pDrive )
            m_pDrive = 0;

        m_pDrive = ptr;

        m_isMounted = TRUE;

        hr = S_OK;

    } WsbCatch( hr );

    return(hr);
}


STDMETHODIMP
CRmsCartridge::GetInfo(
    UCHAR   *pInfo,
    SHORT   *pSize
    )
/*++

Implements:

    IRmsCartridge::GetInfo

--*/
{
    HRESULT hr = E_FAIL;

    try {
        WsbAssertPointer( pInfo );
        WsbAssertPointer( pSize );

        memmove (pInfo, m_info, m_sizeofInfo);
        *pSize = m_sizeofInfo;

        hr = S_OK;
    }
    WsbCatch(hr);

    return hr;
}


STDMETHODIMP
CRmsCartridge::SetInfo(
    UCHAR  *pInfo,
    SHORT   size
    )
/*++

Implements:

    IRmsCartridge::SetInfo

--*/
{
    HRESULT hr = E_FAIL;

    try {
        WsbAssertPointer( pInfo );

        memmove (m_info, pInfo, size);
        m_sizeofInfo = size;
        m_isDirty = TRUE;

        hr = S_OK;
    }
    WsbCatch(hr);

    return hr;
}


STDMETHODIMP
CRmsCartridge::GetOwnerClassId(
    CLSID   *pClassId
    )
/*++

Implements:

    IRmsCartridge::GetOwnerClassId

--*/
{
    HRESULT hr = E_FAIL;

    try {
        WsbAssertPointer( pClassId );

        *pClassId = m_ownerClassId;

        hr = S_OK;
    }
    WsbCatch(hr);

    return hr;
}


STDMETHODIMP
CRmsCartridge::SetOwnerClassId(
    CLSID classId
    )
/*++

Implements:

    IRmsCartridge::SetOwnerClassId

--*/
{
    m_ownerClassId = classId;
    m_isDirty = TRUE;
    return S_OK;
}


STDMETHODIMP
CRmsCartridge::GetPartitions(
    IWsbIndexedCollection **ptr
    )
/*++

Implements:

    IRmsCartridge::GetPartitions

--*/
{
    HRESULT hr = E_FAIL;

    try {
        WsbAssertPointer( ptr );

        *ptr = m_pParts;
        m_pParts->AddRef();

        hr = S_OK;
    }
    WsbCatch(hr);

    return hr;
}


STDMETHODIMP
CRmsCartridge::GetVerifierClass(
    CLSID   *pClassId
    )
/*++

Implements:

    IRmsCartridge::GetVerifierClass

--*/
{
    HRESULT hr = E_FAIL;

    try {
        WsbAssertPointer( pClassId );

        *pClassId = m_verifierClass;

        hr = S_OK;
    }
    WsbCatch(hr);

    return hr;
}


STDMETHODIMP
CRmsCartridge::SetVerifierClass(
    CLSID   classId
    )
/*++

Implements:

    IRmsCartridge::SetVerifierClass

--*/
{
    m_verifierClass = classId;
    m_isDirty = TRUE;
    return S_OK;
}


STDMETHODIMP
CRmsCartridge::GetPortalClass(
    CLSID    *pClassId
    )
/*++

Implements:

    IRmsCartridge::GetPortalClass

--*/
{
    HRESULT hr = E_FAIL;

    try {
        WsbAssertPointer( pClassId );

        *pClassId = m_portalClass;

        hr = S_OK;
    }
    WsbCatch(hr);

    return hr;
}


STDMETHODIMP
CRmsCartridge::SetPortalClass(
    CLSID  classId
    )
/*++

Implements:

    IRmsCartridge::SetPortalClass

--*/
{
    m_portalClass = classId;
    m_isDirty = TRUE;
    return S_OK;
}


STDMETHODIMP
CRmsCartridge::LoadDataCache(
    OUT BYTE *pCache,
    IN OUT ULONG *pSize,
    OUT ULONG *pUsed,
    OUT ULARGE_INTEGER *pStartPBA)
/*++

Implements:

    IRmsCartridge::LoadDataCache

--*/
{
    HRESULT hr = S_OK;

    try {
        WsbAssertPointer( pCache );
        WsbAssertPointer( pSize );
        WsbAssertPointer( pUsed );
        WsbAssertPointer( pStartPBA );


        if (m_pDataCache) {
            // The saved cache size must match the target
            WsbAssert(*pSize == m_DataCacheSize, E_INVALIDARG);

            memmove (pCache, m_pDataCache, m_DataCacheUsed);
            *pSize = m_DataCacheSize;
            *pUsed = m_DataCacheUsed;
            *pStartPBA = m_DataCacheStartPBA;
        }
        else {
            hr = E_FAIL;
        }

    } WsbCatch(hr);

    return hr;
}


STDMETHODIMP
CRmsCartridge::SaveDataCache(
    IN BYTE *pCache,
    IN ULONG size,
    IN ULONG used,
    IN ULARGE_INTEGER startPBA)
/*++

Implements:

    IRmsCartridge::SaveDataCache

--*/
{
    HRESULT hr = S_OK;

    try {
        WsbAssertPointer( pCache );
        WsbAssert(size > 0, E_INVALIDARG);
        WsbAssert(used <= size, E_INVALIDARG);

        // Check that the current cache is big enough
        // to handle the incomming buffer.
        if (m_pDataCache && used > m_DataCacheSize) {
            WsbFree(m_pDataCache);
            m_pDataCache = NULL;
            m_DataCacheSize = 0;
            m_DataCacheUsed = 0;
            m_DataCacheStartPBA.QuadPart = 0;
        }

        if (!m_pDataCache) {
            m_pDataCache = (BYTE *) WsbAlloc(size);
            WsbAssertPointer(m_pDataCache);
            memset(m_pDataCache, 0, size);
            m_DataCacheSize = size;
        }

        WsbAssert(used <= m_DataCacheSize, E_INVALIDARG);

        memmove (m_pDataCache, pCache, used);
        m_DataCacheUsed = used;
        m_DataCacheStartPBA = startPBA;

        m_isDirty = TRUE;

    } WsbCatch(hr);

    return hr;
}


STDMETHODIMP
CRmsCartridge::GetManagedBy(
    OUT LONG *pManagedBy
    )
/*++

Implements:

    IRmsCartridge::GetManagedBy

--*/
{
    HRESULT hr = S_OK;

    try {
        WsbAssertPointer( pManagedBy );

        *pManagedBy = (LONG) m_ManagedBy;

    } WsbCatch(hr);

    return hr;
}


STDMETHODIMP
CRmsCartridge::SetManagedBy(
    IN LONG managedBy
    )
/*++

Implements:

    IRmsCartridge::SetManagedBy

--*/
{
    m_ManagedBy = (RmsMediaManager) managedBy;
    return S_OK;
}


STDMETHODIMP
CRmsCartridge::Mount(
    OUT IRmsDrive **ppDrive,
    IN DWORD dwOptions,
    IN DWORD threadId)
/*++

Implements:

    IRmsCartridge::Mount

--*/
{
    HRESULT hr = E_FAIL;

    WsbTraceIn(OLESTR("CRmsCartridge::Mount"), OLESTR(""));

    try {

        CComPtr<IRmsDrive> pDrive;

        // first check if the cartridge is already mounted
        if ( S_OK == IsMounted() ) {

            LONG refs;

            WsbAffirmHr( m_pDrive->GetMountReference( &refs ) );

            if ( refs ) {
                // Does media type support concurrent mounts?
                switch ( m_type ) {
                case RmsMedia8mm:
                case RmsMedia4mm:
                case RmsMediaDLT:
                case RmsMediaTape:
                    // Tape doesn't support concurrent access - queue another mount
                    if (RmsMediaManagerNTMS == m_ManagedBy) {

                        CComPtr<IRmsNTMS> pNtms;
                        CComQIPtr<IRmsServer, &IID_IRmsServer> pServer = g_pServer;
                        WsbAffirmHr(pServer->GetNTMS(&pNtms));

                        WsbAffirmHr(pNtms->Mount(this, &pDrive, dwOptions, threadId));

                        // We've successfully mounted the cartridge, so
                        // add it the the active cartridge list.

#if RMS_USE_ACTIVE_COLLECTION
                        CComPtr<IWsbIndexedCollection> pActiveCartridges;
                        WsbAffirmHr(pServer->GetActiveCartridges(&pActiveCartridges));
                        WsbAffirmHr(pActiveCartridges->Add((IRmsCartridge *)this));
#else
                        WsbAffirmHr(pServer->SetActiveCartridge((IRmsCartridge *)this));
#endif
                    } else {

                        WsbAffirmHr( RMS_E_CARTRIDGE_BUSY );

                    }
                    break;
                case RmsMediaWORM:
                    WsbAssertHr( E_NOTIMPL );
                    break;
                case RmsMediaMO35:
                case RmsMediaCDR:
                case RmsMediaDVD:
                case RmsMediaOptical:
                case RmsMediaDisk:
                case RmsMediaFixed:
                    // Optical media and fixed disks supports concurrent access
                    if (m_isMountedSerialized && (dwOptions & RMS_SERIALIZE_MOUNT)) {
                        // If the media is already mounted for serialized operation, then we need
                        // to serialize the mount despite the media supporting concurrent mounts.
                        // For fixed disk (where we cannot serialize by issuing another RSM mount) -
                        // we fail the mount with RMS_E_CARTRIDGE_BUSY
                        if (RmsMediaManagerNTMS == m_ManagedBy) {

                            CComPtr<IRmsNTMS> pNtms;
                            CComQIPtr<IRmsServer, &IID_IRmsServer> pServer = g_pServer;
                            WsbAffirmHr(pServer->GetNTMS(&pNtms));

                            WsbAffirmHr(pNtms->Mount(this, &pDrive, dwOptions, threadId));

                            // We've successfully mounted the cartridge, so
                            // add it the the active cartridge list.

#if RMS_USE_ACTIVE_COLLECTION
                            CComPtr<IWsbIndexedCollection> pActiveCartridges;
                            WsbAffirmHr(pServer->GetActiveCartridges(&pActiveCartridges));
                            WsbAffirmHr(pActiveCartridges->Add((IRmsCartridge *)this));
#else
                            WsbAffirmHr(pServer->SetActiveCartridge((IRmsCartridge *)this));
#endif
                        } else {

                            WsbAffirmHr( RMS_E_CARTRIDGE_BUSY );

                        }
                    }
                    break;
                default:
                    WsbAssertHr( E_UNEXPECTED );
                    break;
                }
            }
        }

        if ( S_FALSE == IsMounted() ) {
            CComQIPtr<IRmsServer, &IID_IRmsServer> pServer = g_pServer;

            if (RmsMediaManagerNTMS == m_ManagedBy) {

                CComPtr<IRmsNTMS> pNtms;
                WsbAffirmHr(pServer->GetNTMS(&pNtms));

                WsbAffirmHr(pNtms->Mount(this, &pDrive, dwOptions, threadId));

            }
            else {

                LONG type;
                GUID libId, mediaSetId;
                LONG pos, alt1, alt2, alt3;
                BOOL invert;
                WsbAssertHr( m_location.GetLocation( &type, &libId, &mediaSetId, &pos, &alt1, &alt2, &alt3, &invert ));

                switch ( (RmsElement) type ) {
                case RmsElementStage:
                case RmsElementStorage:
                    {
                        CComPtr<IRmsLibrary> pLib;
                        CComPtr<IWsbIndexedCollection> pDrives;

                        WsbAffirmHr( pServer->FindLibraryById( libId, &pLib ));

                        // Select a drive
                        // TODO: This code will be added to the the library interface as a drive
                        // slection method.  For now, if one is free we use it.

                        WsbAffirmHr( pLib->GetDrives( &pDrives ));

                        CComPtr<IWsbEnum> pEnumDrives;

                        WsbAffirmHr( pDrives->Enum( &pEnumDrives ));
                        WsbAssertPointer( pEnumDrives );

                        hr = pEnumDrives->First( IID_IRmsDrive, (void **)&pDrive );

                        // Search for a drive to mount to
                        while ( S_OK == hr ) {

                            hr = pDrive->SelectForMount();

                            if ( S_OK == hr ) {

                                CComPtr<IWsbIndexedCollection> pChangers;
                                CComPtr<IRmsMediumChanger> pChanger;
                                CComPtr<IWsbEnum> pEnumChangers;

                                WsbAffirmHr( pLib->GetChangers( &pChangers ));
                                WsbAssertHr( pChangers->Enum( &pEnumChangers ));
                                WsbAssertPointer( pEnumChangers );

                                // we'll just use the first changer for the move.
                                WsbAssertHr( pEnumChangers->First( IID_IRmsMediumChanger, (void **)&pChanger ));

                                WsbAffirmHr( pChanger->MoveCartridge( this, pDrive ));

                                WsbAffirmHr( SetIsMounted( TRUE ));

                                WsbAffirmHr( SetDrive( pDrive ));

                                break;

                            }

                            hr = pEnumDrives->Next( IID_IRmsDrive, (void **)&pDrive );
                        }

                    }
                    break;

                case RmsElementShelf:
                case RmsElementOffSite:
                    WsbAssertHr( E_NOTIMPL );
                    break;

                case RmsElementDrive:
                    WsbAssertHr( E_UNEXPECTED );
                    break;

                case RmsElementChanger:
                case RmsElementIEPort:
                    WsbAssertHr( E_NOTIMPL );
                    break;

                } // switch
            }

            if ( S_OK == IsMounted() ) {

                // We've successfully mounted the cartridge, so
                // add it the the active cartridge list.

#if RMS_USE_ACTIVE_COLLECTION
                CComPtr<IWsbIndexedCollection> pActiveCartridges;
                WsbAffirmHr(pServer->GetActiveCartridges(&pActiveCartridges));
                WsbAffirmHr(pActiveCartridges->Add((IRmsCartridge *)this));
#else
                WsbAffirmHr(pServer->SetActiveCartridge((IRmsCartridge *)this));
#endif
            }

        }

        if ( S_OK == IsMounted() ) {

            // Update serialization flag if needed
            if (dwOptions & RMS_SERIALIZE_MOUNT) {
                // This signals to serialize next mount for the same media
                m_isMountedSerialized = TRUE;
            }

            // Final updates
            switch ( m_type ) {

            case RmsMedia8mm:
            case RmsMedia4mm:
            case RmsMediaDLT:
            case RmsMediaTape:

                // increment the object reference counter.
                *ppDrive = m_pDrive;
                WsbAffirmHr( m_pDrive->AddRef() );

                // increment the mount reference counter.
                WsbAffirmHr( m_pDrive->AddMountReference() );

                // update stats
                WsbAffirmHr( updateMountStats( TRUE, TRUE ) );

                hr = S_OK;

                break;

            case RmsMediaWORM:
                WsbAssertHr( E_NOTIMPL );
                break;

            case RmsMediaMO35:
            case RmsMediaCDR:
            case RmsMediaDVD:
            case RmsMediaOptical:
            case RmsMediaDisk:
            case RmsMediaFixed:

                // increment the object reference counter.
                *ppDrive = m_pDrive;
                WsbAffirmHr( m_pDrive->AddRef() );

                // increment the mount reference counter.
                WsbAffirmHr( m_pDrive->AddMountReference() );

                // update stats
                WsbAffirmHr( updateMountStats( TRUE, TRUE ) );

                hr = S_OK;
                
                break;

            default:
                WsbAssertHr( E_UNEXPECTED );
                break;

            }
        }

    } WsbCatch(hr)

    WsbTraceOut(OLESTR("CRmsCartridge::Mount"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));


    return hr;
}



STDMETHODIMP
CRmsCartridge::Dismount(
    IN DWORD dwOptions
    )
/*++

Implements:

    IRmsCartridge::Dismount

--*/
{
    HRESULT hr = S_OK;

    WsbTraceIn(OLESTR("CRmsCartridge::Dismount"), OLESTR("<%ld>"), dwOptions);

    try {
        // Update stats
        WsbAffirmHr(updateMountStats(FALSE, FALSE));

        // Decrement the mount reference counter.
        //
        // When the reference count for the cartridge goes to zero,
        // and the dismount wait time has expired, we physically
        // move the cartridge back to it's storage location.
        WsbAssert(m_pDrive != 0, RMS_E_CARTRIDGE_NOT_MOUNTED);
        WsbAffirmHr(m_pDrive->ReleaseMountReference(dwOptions));

    } WsbCatch(hr)

    WsbTraceOut(OLESTR("CRmsCartridge::Dismount"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    
    return hr;

}


HRESULT
CRmsCartridge::Home(IN DWORD dwOptions)
/*++

Implements:

    IRmsDrive::Home

--*/
{
    HRESULT hr S_OK;

    WsbTraceIn(OLESTR("CRmsCartridge::Home"), OLESTR(""));

    try {
        CComQIPtr<IRmsServer, &IID_IRmsServer> pServer = g_pServer;

        try {
/*

            Tracking DataMovers is only partially implemented.

    
            //
            // Cleanup...
            // Release all DataMovers that reference this cartridge.
            //
            CComPtr<IWsbEnum>               pEnumDataMovers;
            CComPtr<IWsbIndexedCollection>  pDataMovers;
            CComPtr<IRmsCartridge>          pCart;
            CComPtr<IDataMover>             pMover;

            WsbAffirmHr(pServer->GetDataMovers(&pDataMovers));
            WsbAffirmHr(pDataMovers->Enum(&pEnumDataMovers));
            WsbAssertPointer(pEnumDataMovers);
            hr = pEnumDataMovers->First(IID_IDataMover, (void **)&pMover);
            while (S_OK == hr) {
                try {
                    GUID cartIdOfMover = GUID_NULL;
                    GUID cartId = GUID_NULL;

                    WsbAffirmHr(pMover->GetCartridge(&pCart));
                    WsbAffirmPointer(pCart);
                    WsbAffirmHr(pCart->GetCartridgeId(&cartIdOfMover));
                    WsbAffirmHr(GetCartridgeId(&cartId));
                    WsbAssert(cartId != GUID_NULL, E_UNEXPECTED);

                    //
                    // Does this mover reference this cartridge?
                    //
                    if (cartIdOfMover == cartId) {
                        //
                        // Cancel any outstanding I/O, and remove the mover
                        // from the list of active movers.
                        //
                        WsbAffirmHr(pMover->Cancel());
                        WsbAffirmHr(ReleaseDataMover(pMover));
                    }
                } WsbCatch(hr);

                pCart = 0;
                pMover = 0;
                hr = pEnumDataMovers->Next( IID_IDataMover, (void **)&pMover );
            }
            hr = S_OK;

*/
            LONG type;
            GUID libId, mediaSetId;
            LONG pos, alt1, alt2, alt3;
            BOOL invert;

            // We're physically moving the cartridge back to it's storage
            // location.

            WsbAssertHr( m_location.GetLocation( &type, &libId, &mediaSetId, &pos, &alt1, &alt2, &alt3, &invert ));

            WsbAffirmHr(SetIsMounted(FALSE));

            if (RmsMediaManagerNTMS == m_ManagedBy) {

                CComPtr<IRmsNTMS> pNtms;
                WsbAffirmHr(pServer->GetNTMS(&pNtms));
                WsbAffirmHr(pNtms->Dismount(this, dwOptions));

            }
            else {

                CComPtr<IRmsLibrary>            pLib;
                CComPtr<IWsbIndexedCollection>  pChangers;
                CComPtr<IRmsMediumChanger>      pChanger;
                CComPtr<IWsbEnum>               pEnumChangers;

                WsbAffirmHr(pServer->FindLibraryById(libId, &pLib));
                WsbAffirmHr(pLib->GetChangers(&pChangers));
                WsbAssertHr(pChangers->Enum( &pEnumChangers));
                WsbAssertPointer(pEnumChangers);

                // we'll just use the first changer for the move.
                WsbAffirmHr(pEnumChangers->First(IID_IRmsMediumChanger, (void **)&pChanger));

                WsbAffirmHr(pChanger->HomeCartridge(this));


            }

        } WsbCatch(hr)

#if RMS_USE_ACTIVE_COLLECTION
        CComPtr<IWsbIndexedCollection>  pActiveCartridges;
        WsbAffirmHr(pServer->GetActiveCartridges(&pActiveCartridges));
        WsbAffirmHr(pActiveCartridges->RemoveAndRelease((IRmsCartridge *)this));

        ULONG activeCartridges;
        WsbAffirmHr(pActiveCartridges->GetEntries( &activeCartridges));
        WsbTrace(OLESTR("activeCartridges = <%u>\n"), activeCartridges);
#else
        WsbAffirmHr(pServer->SetActiveCartridge(NULL));
#endif

    } WsbCatch(hr)


    WsbTraceOut(OLESTR("CRmsCartridge::Home"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


HRESULT
CRmsCartridge::updateMountStats(
    IN BOOL bRead,
    IN BOOL bWrite
    )
/*++

Updates storage info for the mounted partition

--*/
{
    HRESULT hr = E_FAIL;

    WsbTraceIn(OLESTR("CRmsCartridge::updateMountStats"), OLESTR(""));

    try {


        // We have not implemented partitions yet, everything
        // is single sided...  eventually the following need to be added to
        // the correct partition.  Should this be in a separate function?.

        // For now we don't distinguish between reads and writes
        if ( bRead ) m_readMountCounter++;
        if ( bWrite ) m_writeMountCounter++;

        // Update the read/write timestamps
        // if ( bRead ) m_lastReadTimestamp;
        // if ( bWrite ) m_lastWriteTimestamp;

        hr = S_OK;

    } WsbCatch(hr)

    WsbTraceOut(OLESTR("CRmsCartridge::updateMountStats"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP
CRmsCartridge::CreateDataMover(
    IDataMover **ptr
    )
/*++

Implements:

    IRmsDrive::CreateDataMover

--*/
{
    HRESULT hr = S_OK;

    try {

        WsbAssertPointer(ptr);

        if ( S_OK == IsMounted() ) {

            WsbAssertPointer(m_pDrive );
            WsbAffirmHr(m_pDrive->CreateDataMover(ptr));

        }
        else {

            hr = RMS_E_RESOURCE_UNAVAILABLE;

        }

    } WsbCatch( hr );

    return hr;
}


STDMETHODIMP
CRmsCartridge::ReleaseDataMover(
    IN IDataMover *ptr
    )
/*++

Implements:

    IRmsCartridge::ReleaseDataMover

--*/
{
    HRESULT hr = S_OK;

    try {
        WsbAssertPointer(ptr);
        WsbAffirmPointer(m_pDrive);

        WsbAffirmHr(m_pDrive->ReleaseDataMover(ptr));

    } WsbCatch(hr);

    return hr;
}

STDMETHODIMP
CRmsCartridge::SetIsAvailable(
    BOOL    flag
    )
/*++

Implements:

    IRmsCartridge::SetIsAvailable

--*/
{
    m_isAvailable = flag;

    return S_OK;
}

STDMETHODIMP
CRmsCartridge::IsAvailable(
    VOID
    )
/*++

Implements:

    IRmsCartridge::IsAvailable

--*/
{
    HRESULT     hr = E_FAIL;

    hr = m_isAvailable ? S_OK : S_FALSE;

    return (hr);
}

STDMETHODIMP
CRmsCartridge::IsFixedBlockSize(void)
/*++

Implements:

    IRmsCartridge::IsFixedBlockSize

--*/
{
    HRESULT hr = S_OK;

    WsbTraceIn(OLESTR("CRmsCartridge::IsFixedBlockSize"), OLESTR(""));

    try {
        switch ( m_type ) {
            case RmsMedia8mm:
            case RmsMedia4mm:
            case RmsMediaDLT:
            case RmsMediaTape:
                hr = S_FALSE;
                break;

            case RmsMediaMO35:
            case RmsMediaCDR:
            case RmsMediaDVD:
            case RmsMediaOptical:
            case RmsMediaDisk:
            case RmsMediaFixed:
                hr = S_OK;
                break;

            default:
                WsbAssertHr( E_UNEXPECTED );
                break;
        }

    } WsbCatch(hr)

    WsbTraceOut(OLESTR("CRmsCartridge::IsFixedBlockSize"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\rms\server\rmscartg.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    RmsCartg.h

Abstract:

    Declaration of the CRmsCartridge class

Author:

    Brian Dodd          [brian]         15-Nov-1996

Revision History:

--*/

#ifndef _RMSCARTG_
#define _RMSCARTG_

#include "resource.h"       // resource symbols

#include "RmsSInfo.h"       // CRmsStorageInfo
#include "RmsLocat.h"       // CRmsLocator

/*++

Class Name:

    CRmsCartridge

Class Description:

    A CRmsCartridge represents a unit of removalble media.  This can be a tape
    cartridge, removable hard disk, optical platter (of various formats),
    Compact Disk, or DVD Optical Disc. A Cartridge is normally designated as
    either scratch or private.  The Cartrige name or GUID is used by an
    application     when referencing a particular unit of removable media.

    Cartridge information is maintained by the Removable Media Service, and
    the Cartriges's properties are recreated or updated by auditing the contents of
    the Library.

--*/

class CRmsCartridge :
    public CComDualImpl<IRmsCartridge, &IID_IRmsCartridge, &LIBID_RMSLib>,
    public CRmsStorageInfo,     // inherits CRmsComObject
    public CWsbObject,          // inherits CComObjectRoot
    public CComCoClass<CRmsCartridge,&CLSID_CRmsCartridge>
{
public:
    CRmsCartridge() {}
BEGIN_COM_MAP(CRmsCartridge)
    COM_INTERFACE_ENTRY2(IDispatch, IRmsCartridge)
    COM_INTERFACE_ENTRY(IRmsCartridge)
    COM_INTERFACE_ENTRY(IRmsComObject)
    COM_INTERFACE_ENTRY(IRmsStorageInfo)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IWsbCollectable)
    COM_INTERFACE_ENTRY(IWsbPersistStream)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_RmsCartridge)

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);
    STDMETHOD(FinalRelease)(void);

// IPersist
public:
    STDMETHOD(GetClassID)(CLSID *pClsid);

// IPersistStream
public:
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER* pSize);
    STDMETHOD(Load)(IStream* pStream);
    STDMETHOD(Save)(IStream* pStream, BOOL clearDirty);

// IWsbCollectable
public:
    STDMETHOD(CompareTo)( IN IUnknown *pCollectable, OUT SHORT *pResult);
    WSB_FROM_CWSBOBJECT;

// IWsbTestable
public:
    STDMETHOD(Test)(USHORT *pPassed, USHORT *pFailed);

// IRmsCartridge
public:
    STDMETHOD(GetCartridgeId)(GUID *pCartId);
    STDMETHOD(SetCartridgeId)(GUID cartId);

    STDMETHOD(GetMediaSetId)(GUID *pMediaSetId);
    STDMETHOD(SetMediaSetId)(GUID mediaSetId);

    STDMETHOD(GetName)(BSTR *pName);
    STDMETHOD(SetName)(BSTR name);

    STDMETHOD(GetDescription)(BSTR *pDescription);
    STDMETHOD(SetDescription)(BSTR description);

    STDMETHOD(GetTagAndNumber)(BSTR *pTag, LONG *pNumber);
    STDMETHOD(SetTagAndNumber)(BSTR tag, LONG number);

    STDMETHOD(GetBarcode)(BSTR *pBarcode);  // Same as Tag

    // OnMediaIdentifier is used by DataMover
    STDMETHOD(GetOnMediaIdentifier)(BYTE *pIdentifier, LONG *pSize, LONG *pType);
    STDMETHOD(SetOnMediaIdentifier)(BYTE *pIdentifier, LONG size, LONG type);

    // OnMediaLabel is used by DataMover
    STDMETHOD(GetOnMediaLabel)(BSTR *pLabel);
    STDMETHOD(SetOnMediaLabel)(BSTR label);

    STDMETHOD(GetStatus)(LONG *pStatus);
    STDMETHOD(SetStatus)(LONG status);

    STDMETHOD(GetType)(LONG *pType);
    STDMETHOD(SetType)(LONG type);

    STDMETHOD(GetBlockSize)(LONG *pBlockSize);
    STDMETHOD(SetBlockSize)(LONG blockSize);

    STDMETHOD(IsTwoSided)(void);
    STDMETHOD(SetIsTwoSided)(BOOL flag);

    STDMETHOD(IsMounted)(void);
    STDMETHOD(SetIsMounted)(BOOL flag);

    STDMETHOD(IsAvailable)(void);
    STDMETHOD(SetIsAvailable)(BOOL flag);

    STDMETHOD(GetHome)(LONG *pType, GUID *pLibId, GUID *pMediaSetId, LONG *pPos, LONG *pAlt1, LONG *pAlt2, LONG *pAlt3, BOOL *pInvert);
    STDMETHOD(SetHome)(LONG type, GUID libId, GUID mediaSetId, LONG pos, LONG alt1, LONG alt2, LONG alt3, BOOL invert);

    STDMETHOD(GetLocation)(LONG *pType, GUID *pLibId, GUID *pMediaSetId, LONG *pPos, LONG *pAlt1, LONG *pAlt2, LONG *pAlt3, BOOL *pInvert);
    STDMETHOD(SetLocation)(LONG type, GUID libId, GUID mediaSetId, LONG pos, LONG alt1, LONG alt2, LONG alt3, BOOL invert);

    STDMETHOD(GetMailStop)(BSTR *pMailStop);
    STDMETHOD(SetMailStop)(BSTR mailStop);

    STDMETHOD(GetDrive)(IRmsDrive **ptr);
    STDMETHOD(SetDrive)(IRmsDrive *ptr);

    STDMETHOD(GetInfo)(UCHAR *pInfo, SHORT *pSize);
    STDMETHOD(SetInfo)(UCHAR *pInfo, SHORT size);

    STDMETHOD(GetOwnerClassId)(CLSID *pClassId);
    STDMETHOD(SetOwnerClassId)(CLSID classId);

    STDMETHOD(GetPartitions)(IWsbIndexedCollection **ptr);

    STDMETHOD(GetVerifierClass)(CLSID *pClassId);
    STDMETHOD(SetVerifierClass)(CLSID classId);

    STDMETHOD(GetPortalClass)(CLSID *pClassId);
    STDMETHOD(SetPortalClass)(CLSID classId);

    STDMETHOD( Mount )( OUT IRmsDrive **ppDrive, IN DWORD dwOptions = RMS_NONE, IN DWORD threadId = 0);
    STDMETHOD( Dismount )( IN DWORD dwOptions = RMS_NONE );
    STDMETHOD( Home )( IN DWORD dwOptions = RMS_NONE );

    STDMETHOD( CreateDataMover )( /*[out]*/ IDataMover **ptr );
    STDMETHOD( ReleaseDataMover )( IN IDataMover *ptr );

    STDMETHOD( LoadDataCache )(OUT BYTE *pCache, IN OUT ULONG *pSize, OUT ULONG *pUsed, OUT ULARGE_INTEGER *pStartPBA);
    STDMETHOD( SaveDataCache )(IN BYTE *pCache, IN ULONG size, IN ULONG used, IN ULARGE_INTEGER startPBA);

    STDMETHOD( GetManagedBy )(OUT LONG *pManagedBy);
    STDMETHOD( SetManagedBy )(IN LONG managedBy);

    STDMETHOD(IsFixedBlockSize)(void);

// CRmsCartridge
private:
    HRESULT updateMountStats( IN BOOL bRead, IN BOOL bWrite );

private:
    enum {                                  // Class specific constants:
                                            //
        Version = 1,                        // Class version, this should be
                                            //   incremented each time the
                                            //   the class definition changes.
        MaxInfo = RMS_STR_MAX_CARTRIDGE_INFO    // Size of the application specific
                                                //   information buffer.  Currently
                                                //   fixed in size.
        };
    CWsbBstrPtr     m_externalLabel;        // A string representing bar code or
                                            //   SCSI volume-tag information.
    LONG            m_externalNumber;       // A numeric value representing
                                            //   SCSI volume-tag sequence number.
    LONG            m_sizeofOnMediaId;      // The size of the on media identification buffer.
    LONG            m_typeofOnMediaId;      // The type of the on media identification.
    BYTE           *m_pOnMediaId;           // Raw on media identification buffer.
                                            //
    CWsbBstrPtr     m_onMediaLabel;         // The UNICODE label written on the media.
                                            //
    RmsStatus       m_status;               // Cartridge status (see RmsStatus).
    RmsMedia        m_type;                 // The type of Cartridge (see RmsMedia).
    LONG            m_BlockSize;            // Media block size.
    BOOL            m_isTwoSided;           // TRUE if the Cartridge represents two-sided media
                                            //   Note: Currently nobody sets this value - 
                                            //         this should be fixed if found to be important                    
    BOOL            m_isMounted;            // TRUE if the Cartridge is mounted in a drive.
    BOOL            m_isInTransit;          // TRUE if the Cartridge is in transit between locations.
    BOOL            m_isAvailable;          // TRUE if the Cartridge is not in use by any application
                                            //  (Note: Available here does not ensure online)
    BOOL            m_isMountedSerialized;  // TRUE if the cartridge has been mounted as serialized
    CRmsLocator     m_home;                 // The preferred storage location
                                            //   for the Cartridge (see CRmsLocator).
    CRmsLocator     m_location;             // The current location of the
                                            //   Cartridge (see CRmsLocator).
    CRmsLocator     m_destination;          // The target destination location of the
                                            //   Cartridge (see CRmsLocator).  Valid when
                                            //   m_isInTransit bit is set.
    CWsbBstrPtr     m_mailStop;             // A string describing the shelf (local)
                                            //   or off-site location of a Cartridge.
                                            //   This is displayed when the Cartridge
                                            //   needs to be mounted with human
                                            //   intervention.  [This field is
                                            //   created by the Import/Export dialog.]
    CComPtr<IRmsDrive> m_pDrive;            // The drive in which the cartridge is mounted.
    SHORT           m_sizeofInfo;           // The size of valid data in the application
                                            //   specific information buffer.
    UCHAR           m_info[MaxInfo];        // Application specific information.
    CLSID           m_ownerClassId;         // The Class ID for the application that
                                            //   owns/created the cartridge resource.
    CComPtr<IWsbIndexedCollection> m_pParts;    // A collection of Partitions.  These
                                            //   represent the partitions on a tape
                                            //   or sides of an optical platter.
    CLSID           m_verifierClass;        // The interface to the on-media
                                            //    ID verification function.
    CLSID           m_portalClass;          // The interface to a site specific import
                                            //   and export storage location
                                            //   specification dialog.

    BYTE *          m_pDataCache;           // Cache used to handle I/O for block boudary conditions
    ULONG           m_DataCacheSize;        // Max size of the cache
    ULONG           m_DataCacheUsed;        // The number of bytes of the cache containing valid data
    ULARGE_INTEGER  m_DataCacheStartPBA;    // The corresponding starting PBA for the cache

    RmsMode         m_MountMode;            // The mount mode specified for the cartridge.

    RmsMediaManager m_ManagedBy;            // The media manager that controls the cartridge.

    static int      s_InstanceCount;        // Counter of the number of object instances.
};

#endif // _RMSCARTG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\rms\server\rmscelmt.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    RmsCElmt.h

Abstract:

    Declaration of the CRmsChangerElement class

Author:

    Brian Dodd          [brian]         15-Nov-1996

Revision History:

--*/

#ifndef _RMSCELMT_
#define _RMSCELMT_

#include "resource.h"       // resource symbols

#include "RmsObjct.h"       // CRmsComObject
#include "RmsLocat.h"       // CRmsLocator

/*++

Class Name:

    CRmsChangerElement

Class Description:

    A CRmsChangerElement represents an element within a library device.  Each
    element can support one or more kinds of media.  An element can be used
    for storage.  Various statistics about an element are kept for an object
    of this type.  These include the number of times a Cartridge has been put
    into the element or taken from (get) the element.  Each element can has
    one owner and is specified by the ClassId of the application that configured
    the element.

    All elements within a library have spacial resolution. This is modeled by a
    triplete (x1, x2, x3) that provides relative physical location to other
    elements.

--*/

class CRmsChangerElement :
    public CComDualImpl<IRmsChangerElement, &IID_IRmsChangerElement, &LIBID_RMSLib>,
    public CRmsComObject
{
public:
    CRmsChangerElement();
    ~CRmsChangerElement();

// CRmsChangerElement
public:

    HRESULT  CompareTo(IUnknown* pCollectable, SHORT* pResult);

    HRESULT  GetSizeMax(ULARGE_INTEGER* pSize);
    HRESULT  Load(IStream* pStream);
    HRESULT  Save(IStream* pStream, BOOL clearDirty);

    HRESULT  Test(USHORT *pPassed, USHORT *pFailed);

// IRmsChangerElement
public:

    STDMETHOD(GetElementNo)(LONG *pElementNo);

    STDMETHOD(GetLocation)(LONG *pType, GUID *pLibId, GUID *pMediaSetId, LONG *pPos, LONG *pAlt1, LONG *pAlt2, LONG *pAlt3, BOOL *pInvert);
    STDMETHOD(SetLocation)(LONG type, GUID libId, GUID mediaSetId, LONG pos, LONG alt1, LONG alt2, LONG alt3, BOOL invert);

    STDMETHOD(GetMediaSupported)(LONG *pType);
    STDMETHOD(SetMediaSupported)(LONG type);

    STDMETHOD(IsStorage)(void);
    STDMETHOD(SetIsStorage)(BOOL flag);

    STDMETHOD(IsOccupied)(void);
    STDMETHOD(SetIsOccupied)(BOOL flag);

    STDMETHOD(GetCartridge)(IRmsCartridge **ptr);
    STDMETHOD(SetCartridge)(IRmsCartridge *ptr);

    STDMETHOD(GetOwnerClassId)(CLSID *pClassId);
    STDMETHOD(SetOwnerClassId)(CLSID classId);

    STDMETHOD(GetAccessCounters)(LONG *pGets, LONG *pPuts);

    STDMETHOD(ResetAccessCounters)(void);

    STDMETHOD(GetResetCounterTimestamp)(DATE *pDate);
    STDMETHOD(GetLastGetTimestamp)(DATE *pDate);
    STDMETHOD(GetLastPutTimestamp)(DATE *pDate);

    STDMETHOD(GetCoordinates)(LONG *pX1, LONG *pX2, LONG *pX3);
    STDMETHOD(SetCoordinates)(LONG x1, LONG x2, LONG x3);

protected:

    enum {                                  // Class specific constants:
                                            //
        Version = 1,                        // Class version, this should be
                                            //   incremented each time the
                                            //   the class definition changes.
        };                                  //
    LONG            m_elementNo;            // The element number.
    CRmsLocator     m_location;             // The address of the element.
    RmsMedia        m_mediaSupported;       // The type of media supported by the
                                            //   element, usually one type, but
                                            //   can be a combination of media
                                            //   types for multi-function devices
                                            //   (i.e. drives that support Optical,
                                            //   WORM, and CDR).
    BOOL            m_isStorage;            // If TRUE, the element can be used to
                                            //   store a unit of media.
    BOOL            m_isOccupied;           // If TRUE, the element contains a unit of media.
    IRmsCartridge * m_pCartridge;           // A pointer to the Cartridge object residing
                                            //   within the changer element.  This is not smart
                                            //   pointer, since a cartridge cannot exist only
                                            //   with in the context of a changer element, and
                                            //   eliminates problems associated with deleting
                                            //   with a backward references to other objects...
    CLSID           m_ownerClassId;         // The Class ID for the application that
                                            //   currently owns the element resource.
    LONG            m_getCounter;           // The number of Cartridge-gets from this element.
    LONG            m_putCounter;           // The number of Cartridge-puts to this element.
    DATE            m_resetCounterTimestamp;    // The time the counters were reset.
    DATE            m_lastGetTimestamp;     // The date of last Cartridge-get.
    DATE            m_lastPutTimestamp;     // The date of last Cartridge-put.
    LONG            m_x1;                   // x1, x2, x3 specify a spacial location
    LONG            m_x2;                   //   relative other elements in the library.
    LONG            m_x3;                   //   These are used for micro-optimizations.
};

#endif // _RMSCELMT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\rms\server\rmscelmt.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    RmsCElmt.cpp

Abstract:

    Implementation of CRmsChangerElement

Author:

    Brian Dodd          [brian]         15-Nov-1996

Revision History:

--*/

#include "stdafx.h"

#include "RmsCElmt.h"
#include "RmsServr.h"

/////////////////////////////////////////////////////////////////////////////
//
// CRmsChangerElement methods
//


CRmsChangerElement::CRmsChangerElement(
    void
    )
/*++

Routine Description:

    CRmsChangerElement constructor

Arguments:

    None

Return Value:

    None

--*/
{
    m_elementNo = 0;

    m_location.SetLocation(RmsElementUnknown, GUID_NULL, GUID_NULL,
                           0, 0, 0, 0, FALSE);

    m_mediaSupported = RmsMediaUnknown;

    m_isStorage = FALSE;

    m_isOccupied = FALSE;

    m_pCartridge = NULL;

    m_ownerClassId = CLSID_NULL;

    m_getCounter = 0;

    m_putCounter = 0;

    m_resetCounterTimestamp = 0;

    m_lastGetTimestamp = 0;

    m_lastPutTimestamp = 0;

    m_x1 = 0;

    m_x2 = 0;

    m_x3 = 0;
}


HRESULT
CRmsChangerElement::CompareTo(
    IN  IUnknown    *pCollectable,
    OUT SHORT       *pResult
    )
/*++

Implements:

    CRmsChangerElement::CompareTo

--*/
{
    HRESULT     hr = E_FAIL;
    SHORT       result = 1;

    WsbTraceIn( OLESTR("CRmsChangerElement::CompareTo"), OLESTR("") );

    try {

        // Validate arguments - Okay if pResult is NULL
        WsbAssertPointer( pCollectable );

        CComQIPtr<IRmsChangerElement, &IID_IRmsChangerElement> pElmt = pCollectable;
        WsbAssertPointer( pElmt );

        switch ( m_findBy ) {

        case RmsFindByElementNumber:
            {

                LONG elementNo;

                WsbAffirmHr( pElmt->GetElementNo( &elementNo ) );

                if( m_elementNo == elementNo ) {

                    // Element numbers match
                    hr = S_OK;
                    result = 0;

                }
                else {
                    hr = S_FALSE;
                    result = 1;
                }

            }
            break;

        case RmsFindByMediaSupported:
            {

                RmsMedia mediaSupported;

                WsbAffirmHr( pElmt->GetMediaSupported( (LONG*) &mediaSupported ) );

                if( m_mediaSupported == mediaSupported ) {

                    // media types supported match
                    hr = S_OK;
                    result = 0;

                }
                else {
                    hr = S_FALSE;
                    result = 1;
                }

            }
            break;

        default:

            // What default makes sense?
            WsbAssertHr( E_UNEXPECTED );
            break;

        }

    }
    WsbCatch( hr );

    if ( SUCCEEDED(hr) && (0 != pResult) ) {
       *pResult = result;
    }

    WsbTraceOut( OLESTR("CRmsChangerElement::CompareTo"),
                 OLESTR("hr = <%ls>, result = <%ls>"),
                 WsbHrAsString( hr ), WsbPtrToShortAsString( pResult ) );

    return hr;
}


HRESULT
CRmsChangerElement::GetSizeMax(
    OUT ULARGE_INTEGER* /*pcbSize*/
    )
/*++

Implements:

    IPersistStream::GetSizeMax

--*/
{
    HRESULT         hr = E_NOTIMPL;

//    ULARGE_INTEGER  cartridgeLen;
//    ULARGE_INTEGER  locationLen;


//    WsbTraceIn(OLESTR("CRmsChangerElement::GetSizeMax"), OLESTR(""));

//    try {
//        WsbAssert(0 != pcbSize, E_POINTER);

//        // We need the IRmsCartridge interface to get the value of the object.
//        CComQIPtr<IPersistStream, &IID_IPersistStream> pPersistCartridge = m_pCartridge;
//        WsbAssertPointer( pPersistCartridge );

//        pPersistCartridge->GetSizeMax(&cartridgeLen);

//        m_location.GetSizeMax(&locationLen);

//        // Get max size
//        pcbSize->QuadPart  = WsbPersistSizeOf(LONG)  +      // m_elementNo
//                             locationLen.QuadPart    +      // m_location
//                             WsbPersistSizeOf(LONG)  +      // m_mediaSupported
//                             WsbPersistSizeOf(BOOL)  +      // m_isStorage
//                             WsbPersistSizeOf(BOOL)  +      // m_isOccupied
//                             cartridgeLen.QuadPart   +      // m_pCartridge
//                             WsbPersistSizeOf(CLSID) +      // m_ownerClassId
//                             WsbPersistSizeOf(LONG)  +      // m_getCounter
//                             WsbPersistSizeOf(LONG)  +      // m_putCounter
//                             sizeof(DATE)            +      // m_resetCounterTimestamp
//                             sizeof(DATE)            +      // m_lastGetTimestamp
//                             sizeof(DATE)            +      // m_lastPutTimestamp
//                             WsbPersistSizeOf(LONG)  +      // m_x1
//                             WsbPersistSizeOf(LONG)  +      // m_x2
//                             WsbPersistSizeOf(LONG);        // m_x3

//    } WsbCatch(hr);

//    WsbTraceOut(OLESTR("CRmsChangerElement::GetSizeMax"), OLESTR("hr = <%ls>, Size = <%ls>"), WsbHrAsString(hr), WsbPtrToUliAsString(pcbSize));

    return(hr);
}


HRESULT
CRmsChangerElement::Load(
    IN IStream* pStream
    )
/*++

Implements:

    IPersistStream::Load

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CRmsChangerElement::Load"), OLESTR(""));

    try {
        CComQIPtr<IRmsServer, &IID_IRmsServer> pServer = g_pServer;
        ULONG     temp;

        WsbAssert(0 != pStream, E_POINTER);
        WsbAssertPointer(pServer);

        WsbAffirmHr(CRmsComObject::Load(pStream));

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_elementNo));

        WsbAffirmHr(m_location.Load(pStream));

        WsbAffirmHr(WsbLoadFromStream(pStream, &temp));
        m_mediaSupported = (RmsMedia)temp;

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_isStorage));

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_isOccupied));

        GUID cartId;
        WsbAffirmHr(WsbLoadFromStream(pStream, &cartId));
        if (0 != memcmp(&GUID_NULL, &cartId, sizeof(GUID))) {
            hr = pServer->FindCartridgeById(cartId, &m_pCartridge);
            if (S_OK == hr) {
                CComQIPtr<IRmsDrive, &IID_IRmsDrive> pDrive = (IRmsChangerElement*)this;

                if (pDrive) {
                      WsbAffirmHr(m_pCartridge->SetDrive(pDrive));
                }
            } else if (RMS_E_NOT_FOUND == hr) {
                // TODO ???
            } else {
                WsbThrow(hr);
            }
        }

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_ownerClassId));

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_getCounter));

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_putCounter));

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_x1));

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_x2));

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_x3));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsChangerElement::Load"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CRmsChangerElement::Save(
    IN IStream* pStream,
    IN BOOL clearDirty
    )
/*++

Implements:

    IPersistStream::Save

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CRmsChangerElement::Save"), OLESTR("clearDirty = <%ls>"), WsbBoolAsString(clearDirty));

    try {
        WsbAssert(0 != pStream, E_POINTER);

        WsbAffirmHr(CRmsComObject::Save(pStream, clearDirty));

        WsbAffirmHr(WsbSaveToStream(pStream, m_elementNo));

        WsbAffirmHr(m_location.Save(pStream, clearDirty));

        WsbAffirmHr(WsbSaveToStream(pStream, (ULONG) m_mediaSupported));

        WsbAffirmHr(WsbSaveToStream(pStream, m_isStorage));

        WsbAffirmHr(WsbSaveToStream(pStream, m_isOccupied));

        //  Save the ID (GUID) for the cartridge
        GUID cartId;
        if (!m_pCartridge) {
            cartId = GUID_NULL;
        } else {
            WsbAffirmHr(m_pCartridge->GetCartridgeId(&cartId));
        }
        WsbAffirmHr(WsbSaveToStream(pStream, cartId));

        WsbAffirmHr(WsbSaveToStream(pStream, m_ownerClassId));

        WsbAffirmHr(WsbSaveToStream(pStream, m_getCounter));

        WsbAffirmHr(WsbSaveToStream(pStream, m_putCounter));

        WsbAffirmHr(WsbSaveToStream(pStream, m_x1));

        WsbAffirmHr(WsbSaveToStream(pStream, m_x2));

        WsbAffirmHr(WsbSaveToStream(pStream, m_x3));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsChangerElement::Save"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CRmsChangerElement::Test(
    OUT USHORT *pPassed,
    OUT USHORT *pFailed
    )
/*++

Implements:

    IWsbTestable::Test

--*/
{
    HRESULT                 hr = S_OK;

    CComPtr<IRmsLibrary>    pLibrary1;
    CComPtr<IRmsLibrary>    pLibrary2;

    CComPtr<IPersistFile>   pFile1;
    CComPtr<IPersistFile>   pFile2;

    LONG                    i;

    LONG                    longVal1 = 11111111;
    LONG                    longWork1;

    LONG                    longVal2 = 22222222;
    LONG                    longWork2;

    LONG                    longVal3 = 33333333;
    LONG                    longWork3;

//  DATE                    dateVal1;
//  DATE                    dateWork1;

    CLSID                   clsidVal1 = { 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0};
    CLSID                   clsidWork1;

    //  CRmsLocator Fields
    LONG                    locVal1 = 11111111;
    GUID                    locVal2 = { 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0};
    GUID                    locVal3 = { 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1};
    LONG                    locVal4 = 44444444;
    LONG                    locVal5 = 55555555;
    LONG                    locVal6 = 66666666;
    LONG                    locVal7 = 77777777;
    BOOL                    locVal8 = TRUE;

    LONG                    locWork1;
    GUID                    locWork2;
    GUID                    locWork3;
    LONG                    locWork4;
    LONG                    locWork5;
    LONG                    locWork6;
    LONG                    locWork7;
    BOOL                    locWork8;


    LONG                    mediaTable [RMSMAXMEDIATYPES] = { RmsMediaUnknown,
                                                              RmsMedia8mm,
                                                              RmsMedia4mm,
                                                              RmsMediaDLT,
                                                              RmsMediaOptical,
                                                              RmsMediaMO35,
                                                              RmsMediaWORM,
                                                              RmsMediaCDR,
                                                              RmsMediaDVD,
                                                              RmsMediaDisk,
                                                              RmsMediaFixed,
                                                              RmsMediaTape };


    WsbTraceIn(OLESTR("CRmsChangerElement::Test"), OLESTR(""));

    try {
        // Get the Library interface.
        hr = S_OK;

        try {
            WsbAssertHr(((IUnknown*) (IRmsLibrary*) this)->QueryInterface(IID_IRmsLibrary, (void**) &pLibrary1));

            // Test GetElementNo
            m_elementNo = longVal1;

            GetElementNo(&longWork1);

            if(longVal1 == longWork1){
                (*pPassed)++;
            } else {
                (*pFailed)++;
            }

            // Test SetLocation & GetLocation
            SetLocation( locVal1, locVal2, locVal3, locVal4,
                         locVal5, locVal6, locVal7, locVal8);

            GetLocation( &locWork1, &locWork2, &locWork3, &locWork4,
                         &locWork5, &locWork6, &locWork7, &locWork8);

            if((locVal1 == locWork1) &&
               (locVal2 == locWork2) &&
               (locVal3 == locWork3) &&
               (locVal4 == locWork4) &&
               (locVal5 == locWork5) &&
               (locVal6 == locWork6) &&
               (locVal7 == locWork7) &&
               (locVal8 == locWork8)){
                (*pPassed)++;
            } else {
                (*pFailed)++;
            }

            // Test SetMediaSupported & GetMediaSupported
            for (i = 0; i < RMSMAXMEDIATYPES; i++){

                longWork1 = mediaTable[i];

                SetMediaSupported (longWork1);

                GetMediaSupported (&longWork2);

                if (longWork1 == longWork2){
                    (*pPassed)++;
                } else {
                    (*pFailed)++;
                }
            }

            // Test SetIsStorage & IsStorage to TRUE
            hr = S_OK;

            try{
                WsbAffirmHr(SetIsStorage (TRUE));
                WsbAffirmHr(IsStorage ());
            } WsbCatch (hr);

            if (hr == S_OK){
                (*pPassed)++;
            } else {
                (*pFailed)++;
            }

            // Test SetIsStorage & IsStorage to FALSE
            hr = S_OK;

            try{
                WsbAffirmHr(SetIsStorage (FALSE));
                WsbAffirmHr(IsStorage ());
            } WsbCatch (hr);

            if (hr == S_OK){
                (*pFailed)++;
            } else {
                (*pPassed)++;
            }

            // Test SetIsOccupied & IsOccupied to TRUE
            hr = S_OK;

            try{
                WsbAffirmHr(SetIsOccupied (TRUE));
                WsbAffirmHr(IsOccupied ());
            } WsbCatch (hr);

            if (hr == S_OK){
                (*pPassed)++;
            } else {
                (*pFailed)++;
            }

            // Test SetIsOccupied & IsOccupied to FALSE
            hr = S_OK;

            try{
                WsbAffirmHr(SetIsOccupied (FALSE));
                WsbAffirmHr(IsOccupied ());
            } WsbCatch (hr);

            if (hr == S_OK){
                (*pFailed)++;
            } else {
                (*pPassed)++;
            }

            // Test SetCartridge & GetCartridge

            // Test SetOwnerClassId & GetOwnerClassId
            SetOwnerClassId(clsidVal1);

            GetOwnerClassId(&clsidWork1);

            if(clsidVal1 == clsidWork1){
                (*pPassed)++;
            } else {
                (*pFailed)++;
            }

            // Test SetAccessCounters & GetAccessCounters & ResetAccessCounters
            m_getCounter = longVal1;

            m_putCounter = longVal2;

            GetAccessCounters(&longWork1, &longWork2);

            if((longVal1 == longWork1) &&
               (longVal2 == longWork2)){
                (*pPassed)++;
            } else {
                (*pFailed)++;
            }

            ResetAccessCounters();

            GetAccessCounters(&longWork1, &longWork2);

            if((0 == longWork1) &&
               (0 == longWork2)){
                (*pPassed)++;
            } else {
                (*pFailed)++;
            }

            // Test GetResetCounterTimestamp

            // Test GetLastGetTimestamp

            // Test GetLastPutTimestamp

            // Test SetCoordinates & GetCoordinates
            SetCoordinates(longVal1, longVal2, longVal3);

            GetCoordinates(&longWork1, &longWork2, &longWork3);

            if((longVal1 == longWork1) &&
               (longVal2 == longWork2) &&
               (longVal3 == longWork3)){
                (*pPassed)++;
            } else {
                (*pFailed)++;
            }

        } WsbCatch(hr);


        // Tally up the results

        hr = S_OK;
        if (*pFailed) {
            hr = S_FALSE;
        }


    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsChangerElement::Test"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


CRmsChangerElement::~CRmsChangerElement(
    void
    )
/*++

Routine Description:

    This is the destructor for the changer element class.

Arguments:

    None.

Return Value:

    None.

--*/
{
    m_pCartridge = NULL;
}


/////////////////////////////////////////////////////////////////////////////
//
// IRmsChangerElement implementation
//



STDMETHODIMP
CRmsChangerElement::GetElementNo(
    LONG   *pElementNo
    )
/*++

Implements:

    IRmsChangerElement::GetElementNo

--*/
{
    *pElementNo = m_elementNo;
    return S_OK;
}



STDMETHODIMP
CRmsChangerElement::GetLocation(
    LONG *pType,
    GUID *pLibId,
    GUID *pMediaSetId,
    LONG *pPos,
    LONG *pAlt1,
    LONG *pAlt2,
    LONG *pAlt3,
    BOOL *pInvert)
/*++

Implements:

    IRmsChangerElement::GetLocation

--*/
{
    return m_location.GetLocation(pType, pLibId, pMediaSetId, pPos, pAlt1, pAlt2, pAlt3, pInvert);;
}

STDMETHODIMP
CRmsChangerElement::SetLocation(
    LONG type,
    GUID libId,
    GUID mediaSetId,
    LONG pos,
    LONG alt1,
    LONG alt2,
    LONG alt3,
    BOOL invert)
/*++

Implements:

    IRmsChangerElement::SetLocation

--*/
{
    m_location.SetLocation( type, libId, mediaSetId, pos,
                            alt1, alt2, alt3, invert );

    // TODO: clean this up: pos, or m_elementNo, not both.
    m_elementNo = pos;

//  m_isDirty = TRUE;
    return S_OK;
}

STDMETHODIMP
CRmsChangerElement::GetMediaSupported(
    LONG    *pType
    )
/*++

Implements:

    IRmsChangerElement::GetMediaSupported

--*/
{
    *pType = m_mediaSupported;
    return S_OK;
}

STDMETHODIMP
CRmsChangerElement::SetMediaSupported(
    LONG    type
    )
/*++

Implements:

    IRmsChangerElement::SetMediaSupported

--*/
{
    m_mediaSupported = (RmsMedia) type;
//  m_isDirty = TRUE;
    return S_OK;
}

STDMETHODIMP
CRmsChangerElement::SetIsStorage(
    BOOL    flag
    )
/*++

Implements:

    IRmsChangerElement::SetIsStorage

--*/
{
    m_isStorage = flag;
//  m_isDirty = TRUE;
    return S_OK;
}

STDMETHODIMP
CRmsChangerElement::IsStorage(
    void
    )
/*++

Implements:

    IRmsChangerElement::IsStorage

--*/
{
    HRESULT    hr = S_FALSE;

    if (m_isStorage){
        hr = S_OK;
        }

    return (hr);
}

STDMETHODIMP
CRmsChangerElement::SetIsOccupied(
    BOOL    flag
    )
/*++

Implements:

    IRmsChangerElement::SetIsOccupied

--*/
{
    m_isOccupied = flag;

    if ( FALSE == m_isOccupied ) {

        m_pCartridge = 0;

    }


//  m_isDirty = TRUE;
    return S_OK;
}

STDMETHODIMP
CRmsChangerElement::IsOccupied(
    void
    )
/*++

Implements:

    IRmsChangerElement::IsOccupied

--*/
{
    HRESULT    hr = S_FALSE;

    if (m_isOccupied){
    hr = S_OK;
    }

    return (hr);
}

STDMETHODIMP
CRmsChangerElement::GetCartridge(
    IRmsCartridge **ptr)
/*++

Implements:

    IRmsChangerElement::GetCartridge

--*/
{
    HRESULT hr = S_OK;

    try {
        WsbAssertPointer(ptr);

        *ptr = m_pCartridge;
        m_pCartridge->AddRef();

    } WsbCatch(hr);

    return(hr);
}


STDMETHODIMP
CRmsChangerElement::SetCartridge(
    IRmsCartridge *ptr)
/*++

Implements:

    IRmsChangerElement::SetCartridge

--*/
{
    HRESULT hr = S_OK;

    try {
        WsbAssertPointer(ptr);

        m_pCartridge = ptr;
        m_isOccupied = TRUE;

    } WsbCatch(hr);

    return(hr);
}


STDMETHODIMP
CRmsChangerElement::GetOwnerClassId(
    CLSID   *pClassId
    )
/*++

Implements:

    IRmsChangerElement::GetOwnerClassId

--*/
{
    *pClassId = m_ownerClassId;
    return S_OK;
}

STDMETHODIMP
CRmsChangerElement::SetOwnerClassId(
    CLSID classId
    )
/*++

Implements:

    IRmsChangerElement::SetOwnerClassId

--*/
{
    m_ownerClassId = classId;
//  m_isDirty = TRUE;
    return S_OK;
}

STDMETHODIMP
CRmsChangerElement::GetAccessCounters(
    LONG    *pGets,
    LONG    *pPuts
    )
/*++

Implements:

    IRmsChangerElement::GetAccessCounters

--*/
{
    *pGets = m_getCounter;
    *pPuts = m_putCounter;
    return S_OK;
}

STDMETHODIMP
CRmsChangerElement::ResetAccessCounters(
    void
    )
/*++

Implements:

    IRmsChangerElement::ResetAccessCounters

--*/
{
    m_getCounter = 0;
    m_putCounter = 0;
//  m_resetCounterTimestamp = COleDatetime::GetCurrentTime();
    return S_OK;
}

STDMETHODIMP
CRmsChangerElement::GetResetCounterTimestamp(
    DATE    *pDate
    )
/*++

Implements:

    IRmsChangerElement::GetResetCounterTimestamp

--*/
{
    *pDate = m_resetCounterTimestamp;
    return S_OK;
}

STDMETHODIMP
CRmsChangerElement::GetLastGetTimestamp(
    DATE    *pDate
    )
/*++

Implements:

    IRmsChangerElement::GetLastGetTimestamp

--*/
{
    *pDate = m_lastGetTimestamp;
    return S_OK;
}

STDMETHODIMP
CRmsChangerElement::GetLastPutTimestamp(
    DATE    *pDate
    )
/*++

Implements:

    IRmsChangerElement::GetLastPutTimestamp

--*/
{
    *pDate = m_lastPutTimestamp;
    return S_OK;
}

STDMETHODIMP
CRmsChangerElement::GetCoordinates(
    LONG    *pX1,
    LONG    *pX2,
    LONG    *pX3
    )
/*++

Implements:

    IRmsChangerElement::GetCoordinates

--*/
{
    *pX1 = m_x1;
    *pX2 = m_x2;
    *pX3 = m_x3;
    return S_OK;
}

STDMETHODIMP
CRmsChangerElement::SetCoordinates(
    LONG  x1,
    LONG  x2,
    LONG  x3
    )
/*++

Implements:

    IRmsChangerElement::SetCoordinates

--*/
{
    m_x1 = x1;
    m_x2 = x2;
    m_x3 = x3;

//  m_isDirty = TRUE;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\rms\server\rmschngr.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    RmsChngr.h

Abstract:

    Declaration of the CRmsMediumChanger class

Author:

    Brian Dodd          [brian]         15-Nov-1996

Revision History:

--*/

#ifndef _RMSCHNGR_
#define _RMSCHNGR_

#include "resource.h"       // resource symbols

#include "RmsDvice.h"       // CRmsDevice
#include "RmsLocat.h"       // CRmsLocator

/*++

Class Name:

    CRmsMediumChanger

Class Description:

    A CRmsMediumChanger represents the robotic or human mechanism that moves media
    between the elements of a library.  The state of in-progress move operations
    is maintained with this object to aid recovery.

--*/

class CRmsMediumChanger :
    public CComDualImpl<IRmsMediumChanger, &IID_IRmsMediumChanger, &LIBID_RMSLib>,
    public CRmsDevice,          // inherits CRmsChangerElement
    public CWsbObject,          // inherits CComObjectRoot
    public IRmsMoveMedia,
    public CComCoClass<CRmsMediumChanger,&CLSID_CRmsMediumChanger>
{
public:
    CRmsMediumChanger() {}
BEGIN_COM_MAP(CRmsMediumChanger)
    COM_INTERFACE_ENTRY2(IDispatch, IRmsMediumChanger)
    COM_INTERFACE_ENTRY(IRmsMediumChanger)
    COM_INTERFACE_ENTRY(IRmsMoveMedia)
    COM_INTERFACE_ENTRY(IRmsComObject)
    COM_INTERFACE_ENTRY(IRmsChangerElement)
    COM_INTERFACE_ENTRY(IRmsDevice)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IWsbCollectable)
    COM_INTERFACE_ENTRY(IWsbPersistStream)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_RmsMediumChanger)

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);
    STDMETHOD(FinalRelease)(void);

// IPersist
public:
    STDMETHOD(GetClassID)(CLSID *pClsid);

// IPersistStream
public:
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER* pSize);
    STDMETHOD(Load)(IStream* pStream);
    STDMETHOD(Save)(IStream* pStream, BOOL clearDirty);

// IWsbCollectable
public:
    STDMETHOD(CompareTo)(IUnknown* pCollectable, SHORT* pResult);
    WSB_FROM_CWSBOBJECT;

// IWsbTestable
public:
    STDMETHOD(Test)( OUT USHORT *pPassed, OUT USHORT *pFailed);

// IRmsMediumChanger
public:
    STDMETHOD( Initialize )( void );

    STDMETHOD( AcquireDevice )( void );
    STDMETHOD( ReleaseDevice )( void );

    STDMETHOD( GetHome )( LONG *pType, LONG *pPos, BOOL *pInvert );
    STDMETHOD( SetHome )( LONG type, LONG pos, BOOL invert );

    STDMETHOD( SetAutomatic )( BOOL flag );
    STDMETHOD( IsAutomatic )( void );

    STDMETHOD( SetCanRotate )( BOOL flag );
    STDMETHOD( CanRotate )( void );

    STDMETHOD( GetOperation )( BSTR *pOperation );
    STDMETHOD( SetOperation )( BSTR pOperation );

    STDMETHOD( GetPercentComplete )(  BYTE *pPercent );
    STDMETHOD( SetPercentComplete )(  BYTE percent );

    STDMETHOD( TestReady )( void );

    STDMETHOD( ImportCartridge )( IRmsCartridge **pCart );
    STDMETHOD( ExportCartridge )( IRmsCartridge **pCart );
    STDMETHOD( MoveCartridge )( IN IRmsCartridge *pSrcCart, IN IUnknown *pDestElmt );
    STDMETHOD( HomeCartridge )( IN IRmsCartridge *pCart );

// IRmsMoveMedia
public:
    STDMETHOD( GetParameters )( IN OUT PDWORD pSize, OUT PGET_CHANGER_PARAMETERS pParms );
    STDMETHOD( GetProductData )( IN OUT PDWORD pSize, OUT PCHANGER_PRODUCT_DATA pData );
    STDMETHOD( RezeroUnit )( void );
    STDMETHOD( InitializeElementStatus )( IN CHANGER_ELEMENT_LIST elementList, IN BOOL barCodeScan );
    STDMETHOD( Status )( void );
    STDMETHOD( SetAccess )( IN CHANGER_ELEMENT element, IN DWORD control );
    STDMETHOD( GetElementStatus )( IN CHANGER_ELEMENT_LIST elementList,
                                   IN BOOL volumeTagInfo,
                                   IN OUT PDWORD pSize,
                                   OUT PREAD_ELEMENT_ADDRESS_INFO  pElementInformation );
    STDMETHOD( ExchangeMedium )( IN CHANGER_ELEMENT source, IN CHANGER_ELEMENT destination1,
                                    IN CHANGER_ELEMENT destination2, IN BOOL flip1, IN BOOL flip2 );
    STDMETHOD( MoveMedium )( IN CHANGER_ELEMENT source, IN CHANGER_ELEMENT destination, IN BOOL flip );
    STDMETHOD( Position )( IN CHANGER_ELEMENT destination, IN BOOL flip );
//    STDMETHOD( GetDisplay )( OUT PCHANGER_DISPLAY pDisplay );
//    STDMETHOD( SetDisplay )( IN PCHANGER_DISPLAY pDisplay );
    STDMETHOD( QueryVolumeTag )( IN CHANGER_ELEMENT startingElement, IN DWORD actionCode,
                                    IN PUCHAR pVolumeIDTemplate, OUT PDWORD pNumberOfElementsReturned,
                                    OUT PREAD_ELEMENT_ADDRESS_INFO  pElementInformation );

// CRmsServer
private:

private:

    enum {                                  // Class specific constants:
                                            //
        Version = 1,                        // Class version, this should be
                                            //   incremented each time the
                                            //   the class definition changes.
        MaxInfo = 64                        // Max size of the device identifier.
        };                                  //

    CRmsLocator     m_home;                 // The position to move to in response to
                                            //   to the Home operation.
    BOOL            m_isAutomatic;          // If TRUE, the changer is a robotic device.
    BOOL            m_canRotate;            // If TRUE, the changer can rotate a
                                            //   unit of media.
    CWsbBstrPtr     m_operation;            // A description of the in-progress operation.
    BYTE            m_percentComplete;      // A value between 0-100 that indicates
                                            //   what portion of the operation is complete.
    HANDLE          m_handle;               // The handle to the changer device.  This is used
                                            //   by the IRmsMoveMedia interface.
    GET_CHANGER_PARAMETERS m_parameters;   // Device specific parameters. See NT DDK.
};

#endif // _RMSCHNGR_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\rms\server\rmsclien.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    RmsClien.cpp

Abstract:

    Implementation of CRmsClient

Author:

    Brian Dodd          [brian]         15-Nov-1996

Revision History:

--*/

#include "stdafx.h"

#include "RmsClien.h"

/////////////////////////////////////////////////////////////////////////////
//


STDMETHODIMP
CRmsClient::CompareTo(
    IN  IUnknown    *pCollectable,
    OUT SHORT       *pResult
    )
/*++

Implements:

    IWsbCollectable::CompareTo

--*/
{
    HRESULT     hr = E_FAIL;
    SHORT       result = 1;

    WsbTraceIn( OLESTR("CRmsClient::CompareTo"), OLESTR("") );

    try {

        // Validate arguments - Okay if pResult is NULL
        WsbAssertPointer( pCollectable );

        CComQIPtr<IRmsClient, &IID_IRmsClient> pClient = pCollectable;
        WsbAssertPointer( pClient );

        CComQIPtr<IRmsComObject, &IID_IRmsComObject> pObject = pCollectable;
        WsbAssertPointer( pObject );

        switch ( m_findBy ) {

        case RmsFindByClassId:
            {

                CLSID   ownerClassId;

                // Get owner class Id
                WsbAffirmHr(pClient->GetOwnerClassId( &ownerClassId ) );

                if ( m_ownerClassId == ownerClassId ) {

                    // Owner ClassId matches
                    hr = S_OK;
                    result = 0;

                }
                else {
                    hr = S_FALSE;
                    result = 1;
                }

            }
            break;

        case RmsFindByName:
            {

                CWsbBstrPtr name;
                CWsbBstrPtr password;

                // Get name
                WsbAffirmHr(pClient->GetName( &name ) );

                if ( m_Name == name ) {

                    // Names match, now try password

                    // Get password
                    WsbAffirmHr(pClient->GetPassword( &password ) );

                    if ( m_password == password ) {

                        // Passwords match
                        hr = S_OK;
                        result = 0;

                    }
                    else {
                        hr = S_FALSE;
                        result = 1;
                    }

                }
                else {
                    hr = S_FALSE;
                    result = 1;
                }

            }
            break;

        case RmsFindByObjectId:
        default:

            // Do CompareTo for object
            hr = CRmsComObject::CompareTo( pCollectable, &result );
            break;

        }

    }
    WsbCatch(hr);

    if ( SUCCEEDED(hr) && (0 != pResult) ){
       *pResult = result;
    }

    WsbTraceOut( OLESTR("CRmsClient::CompareTo"),
                 OLESTR("hr = <%ls>, result = <%ls>"),
                 WsbHrAsString( hr ), WsbPtrToShortAsString( pResult ) );

    return hr;
}


HRESULT
CRmsClient::FinalConstruct(
    void
    )
/*++

Implements:

    CComObjectRoot::FinalConstruct

--*/
{
    HRESULT     hr = S_OK;

    try {
        WsbAssertHr(CWsbObject::FinalConstruct());

        // Initialize data
        m_ownerClassId = GUID_NULL;

        m_password = RMS_UNDEFINED_STRING;

        m_sizeofInfo = 0;

//      memset(m_info, 0, MaxInfo);

        m_verifierClass = GUID_NULL;

        m_portalClass = GUID_NULL;

    } WsbCatch(hr);

    return(hr);
}


STDMETHODIMP
CRmsClient::GetClassID(
    OUT CLSID* pClsid
    )
/*++

Implements:

    IPersist::GetClassID

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CRmsClient::GetClassID"), OLESTR(""));

    try {

        WsbAssert(0 != pClsid, E_POINTER);

        *pClsid = CLSID_CRmsClient;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsClient::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return(hr);
}


STDMETHODIMP
CRmsClient::GetSizeMax(
    OUT ULARGE_INTEGER* pcbSize
    )
/*++

Implements:

    IPersistStream::GetSizeMax

--*/
{
    HRESULT     hr = E_NOTIMPL;

//    ULONG       nameLen;
//    ULONG       passwordLen;

    WsbTraceIn(OLESTR("CRmsClient::GetSizeMax"), OLESTR(""));

//    try {
//        WsbAssert(0 != pcbSize, E_POINTER);

//        nameLen = SysStringByteLen(m_name);
//        passwordLen = SysStringByteLen(m_password);

//        // set up maximum size
//        pcbSize->QuadPart  = WsbPersistSizeOf(CLSID) +      // m_ownerClassId
//                             WsbPersistSizeOf(LONG) +       // length of m_name
//                             nameLen +                      // m_name
//                             WsbPersistSizeOf(LONG) +       // length of m_password
//                             nameLen +                      // m_password
////                           WsbPersistSizeOf(SHORT) +      // m_sizeofInfo
////                           MaxInfo +                      // m_info
//                             WsbPersistSizeOf(CLSID) +      // m_sizeofInfo
//                             WsbPersistSizeOf(CLSID);       // m_sizeofInfo


//    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsClient::GetSizeMax"), OLESTR("hr = <%ls>, Size = <%ls>"), WsbHrAsString(hr), WsbPtrToUliAsString(pcbSize));

    return(hr);
}


STDMETHODIMP
CRmsClient::Load(
    IN IStream* pStream
    )
/*++

Implements:

    IPersistStream::Load

--*/
{
    HRESULT     hr = S_OK;
    ULONG       ulBytes = 0;

    WsbTraceIn(OLESTR("CRmsClient::Load"), OLESTR(""));

    try {

        WsbAssert(0 != pStream, E_POINTER);

        WsbAffirmHr(CRmsComObject::Load(pStream));

        // Read value

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_ownerClassId));

        WsbAffirmHr(WsbBstrFromStream(pStream, &m_password));

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_sizeofInfo));

//      WsbAffirmHr(WsbLoadFromStream(pStream, &m_info));

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_verifierClass));

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_portalClass));


    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsClient::Load"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


STDMETHODIMP
CRmsClient::Save(
    IN IStream* pStream,
    IN BOOL clearDirty
    )
/*++

Implements:

    IPersistStream::Save

--*/
{
    HRESULT     hr = S_OK;
    ULONG       ulBytes = 0;

    WsbTraceIn(OLESTR("CRmsClient::Save"), OLESTR("clearDirty = <%ls>"), WsbBoolAsString(clearDirty));

    try {
        WsbAssert(0 != pStream, E_POINTER);

        WsbAffirmHr(CRmsComObject::Save(pStream, clearDirty));

        // Save value
        WsbAffirmHr(WsbSaveToStream(pStream, m_ownerClassId));

        WsbAffirmHr(WsbBstrToStream(pStream, m_password));

        WsbAffirmHr(WsbSaveToStream(pStream, m_sizeofInfo));

//      WsbAffirmHr(WsbSaveToStream(pStream, m_info));

        WsbAffirmHr(WsbSaveToStream(pStream, m_verifierClass));

        WsbAffirmHr(WsbSaveToStream(pStream, m_portalClass));


        // Do we need to clear the dirty bit?
        if (clearDirty) {
            m_isDirty = FALSE;
        }
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsClient::Save"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


STDMETHODIMP
CRmsClient::Test(
    OUT USHORT *pPassed,
    OUT USHORT *pFailed
    )
/*++

Implements:

    IWsbTestable::Test

--*/
{
    HRESULT                 hr = S_OK;

    CComPtr<IRmsClient>     pClient1;
    CComPtr<IRmsClient>     pClient2;

    CComPtr<IPersistFile>   pFile1;
    CComPtr<IPersistFile>   pFile2;

    CLSID                   clsidWork1;
    CLSID                   clsidWork2;

    CWsbBstrPtr             bstrVal1 = OLESTR("5A5A5A");
    CWsbBstrPtr             bstrWork1;
    CWsbBstrPtr             bstrWork2;


    WsbTraceIn(OLESTR("CRmsClient::Test"), OLESTR(""));

    try {
        // Get the Client interface.
        hr = S_OK;

        try {
            WsbAssertHr(((IUnknown*) (IRmsClient*) this)->QueryInterface(IID_IRmsClient, (void**) &pClient1));

            // Test SetOwnerClassId & GetOwnerClassId
            clsidWork1 = CLSID_NULL;

            SetOwnerClassId(clsidWork1);

            GetOwnerClassId(&clsidWork2);

            if(clsidWork1 == clsidWork2){
                (*pPassed)++;
            } else {
                (*pFailed)++;
            }

            // Test SetName & GetName interface
            bstrWork1 = bstrVal1;

            SetName(bstrWork1);

            GetName(&bstrWork2);

            if (bstrWork1 == bstrWork2){
                (*pPassed)++;
            } else {
                (*pFailed)++;
            }

            // Test SetPassword & GetPassword interface
            bstrWork1 = bstrVal1;

            SetPassword(bstrWork1);

            GetPassword(&bstrWork2);

            if (bstrWork1 == bstrWork2){
                (*pPassed)++;
            } else {
                (*pFailed)++;
            }

            // Test SetVerifierClass & GetVerifierClass
            clsidWork1 = CLSID_NULL;

            SetVerifierClass(clsidWork1);

            GetVerifierClass(&clsidWork2);

            if(clsidWork1 == clsidWork2){
                (*pPassed)++;
            } else {
                (*pFailed)++;
            }

            // Test SetPortalClass & GetPortalClass
            clsidWork1 = CLSID_NULL;

            SetPortalClass(clsidWork1);

            GetPortalClass(&clsidWork2);

            if(clsidWork1 == clsidWork2){
                (*pPassed)++;
            } else {
                (*pFailed)++;
            }

        } WsbCatch(hr);

        // Tally up the results

        hr = S_OK;
        if (*pFailed) {
            hr = S_FALSE;
        }


    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsClient::Test"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


STDMETHODIMP
CRmsClient::GetOwnerClassId(
    CLSID   *pClassId
    )
/*++

Implements:

    IRmsClient::GetOwnerClassId

--*/
{
    *pClassId = m_ownerClassId;
    return S_OK;
}


STDMETHODIMP
CRmsClient::SetOwnerClassId(
    CLSID classId
    )
/*++

Implements:

    IRmsClient::SetOwnerClassId

--*/
{
    m_ownerClassId = classId;
    m_isDirty = TRUE;
    return S_OK;
}


STDMETHODIMP
CRmsClient::GetName(
    BSTR  *pName
    )
/*++

Implements:

    IRmsClient::GetName

--*/
{
    WsbAssertPointer (pName);

    m_Name. CopyToBstr (pName);
    return S_OK;
}


STDMETHODIMP
CRmsClient::SetName(
    BSTR    name
    )
/*++

Implements:

    IRmsClient::SetName

--*/
{
    m_Name = name;
    m_isDirty = TRUE;
    return S_OK;
}


STDMETHODIMP
CRmsClient::GetPassword(
    BSTR  *pPassword
    )
/*++

Implements:

    IRmsClient::GetPassword

--*/
{
    WsbAssertPointer (pPassword);

    m_password. CopyToBstr (pPassword);
    return S_OK;
}


STDMETHODIMP
CRmsClient::SetPassword(
    BSTR    password
    )
/*++

Implements:

    IRmsClient::SetPassword

--*/
{
    m_password = password;
    m_isDirty = TRUE;
    return S_OK;
}


STDMETHODIMP
CRmsClient::GetInfo(
    UCHAR   *pInfo,
    SHORT   *pSize
    )
/*++

Implements:

    IRmsClient::GetInfo

--*/
{
    memmove (pInfo, m_info, m_sizeofInfo);
    *pSize = m_sizeofInfo;
    return S_OK;
}


STDMETHODIMP
CRmsClient::SetInfo(
    UCHAR  *pInfo,
    SHORT   size
    )
/*++

Implements:

    IRmsClient::SetInfo

--*/
{
    memmove (m_info, pInfo, size);
    m_sizeofInfo = size;
    m_isDirty = TRUE;
    return S_OK;
}


STDMETHODIMP
CRmsClient::GetVerifierClass(
    CLSID   *pClassId
    )
/*++

Implements:

    IRmsClient::GetVerifierClass

--*/
{
    *pClassId = m_verifierClass;
    return S_OK;
}


STDMETHODIMP
CRmsClient::SetVerifierClass(
    CLSID   classId
    )
/*++

Implements:

    IRmsClient::GetVerifierClass

--*/
{
    m_verifierClass = classId;
    m_isDirty = TRUE;
    return S_OK;
}


STDMETHODIMP
CRmsClient::GetPortalClass(
    CLSID    *pClassId
    )
/*++

Implements:

    IRmsClient::GetPortalClass

--*/
{
    *pClassId = m_portalClass;
    return S_OK;
}


STDMETHODIMP
CRmsClient::SetPortalClass(
    CLSID  classId
    )
/*++

Implements:

    IRmsClient::SetPortalClass

--*/
{
    m_portalClass = classId;
    m_isDirty = TRUE;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\rms\server\rmschngr.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    RmsChngr.cpp

Abstract:

    Implementation of CRmsMediumChanger

Author:

    Brian Dodd          [brian]         15-Nov-1996

Revision History:

--*/

#include "stdafx.h"

#include "RmsChngr.h"
#include "RmsServr.h"

////////////////////////////////////////////////////////////////////////////////
//

HRESULT
CRmsMediumChanger::FinalConstruct(
    void
    )
/*++

Implements:

    CComObjectRoot::FinalConstruct

--*/
{
    HRESULT     hr = S_OK;

    try {
        WsbAssertHr(CWsbObject::FinalConstruct());

        // Initialize fields
        m_isAutomatic = FALSE;

        m_canRotate = FALSE;

        m_operation = RMS_UNDEFINED_STRING;

        m_percentComplete = 0;

        m_handle = INVALID_HANDLE_VALUE;

    } WsbCatch(hr);

    return(hr);
}


HRESULT
CRmsMediumChanger::FinalRelease(
    void
    )
/*++

Implements:

    CComObjectRoot::FinalRelease

--*/
{
    HRESULT     hr = S_OK;

    try {

        WsbAssertHr( ReleaseDevice() );

    } WsbCatch(hr);

    return(hr);
}


STDMETHODIMP
CRmsMediumChanger::CompareTo(
    IN  IUnknown    *pCollectable,
    OUT SHORT       *pResult
    )
/*++

Implements:

    IWsbCollectable::CompareTo

--*/
{
    HRESULT     hr = E_FAIL;
    SHORT       result = 1;

    WsbTraceIn( OLESTR("CRmsMediumChanger::CompareTo"), OLESTR("") );

    try {

        // Validate arguments - Okay if pResult is NULL
        WsbAssertPointer( pCollectable );

        // !!!!!
        //
        // IMPORTANT: The collectable coming in may not be a CRmsDrive if the collection
        //            is the unconfigured device list.
        //
        // !!!!!

        CComQIPtr<IRmsComObject, &IID_IRmsComObject> pObject = pCollectable;
        WsbAssertPointer( pObject );

        switch ( m_findBy ) {

        case RmsFindByDeviceInfo:
        case RmsFindByDeviceAddress:
        case RmsFindByDeviceName:
        case RmsFindByDeviceType:

            // Do CompareTo for device
            hr = CRmsDevice::CompareTo( pCollectable, &result );
            break;

        case RmsFindByElementNumber:
        case RmsFindByMediaSupported:

            // Do CompareTo for changer element
            hr = CRmsChangerElement::CompareTo( pCollectable, &result );
            break;

        case RmsFindByObjectId:
        default:

            // Do CompareTo for object
            hr = CRmsComObject::CompareTo( pCollectable, &result );
            break;

        }

    }
    WsbCatch( hr );

    if ( SUCCEEDED(hr) && (0 != pResult) ){
       *pResult = result;
    }

    WsbTraceOut( OLESTR("CRmsMediumChanger::CompareTo"),
                 OLESTR("hr = <%ls>, result = <%ls>"),
                 WsbHrAsString( hr ), WsbPtrToShortAsString( pResult ) );

    return hr;
}


STDMETHODIMP
CRmsMediumChanger::GetClassID(
    OUT CLSID* pClsid
    )
/*++

Implements:

    IPersist::GetClassID

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CRmsMediumChanger::GetClassID"), OLESTR(""));

    try {

        WsbAssert(0 != pClsid, E_POINTER);

        *pClsid = CLSID_CRmsMediumChanger;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsMediumChanger::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return(hr);
}

STDMETHODIMP
CRmsMediumChanger::GetSizeMax(
    OUT ULARGE_INTEGER* pcbSize
    )
/*++

Implements:

    IPersistStream::GetSizeMax

--*/
{
    HRESULT     hr = E_NOTIMPL;

//    ULONG       inProcessOperation;


    WsbTraceIn(OLESTR("CRmsMediumChanger::GetSizeMax"), OLESTR(""));

//    try {
//        WsbAssert(0 != pcbSize, E_POINTER);

//        inProcessOperation = SysStringByteLen(m_operation);

//        // Get size
//        pcbSize->QuadPart  = WsbPersistSizeOf(LONG) +       // m_isAutomatic
//                             WsbPersistSizeOf(LONG) +       // m_canRotate
//                             WsbPersistSizeOf(LONG) +       // m_operation length
//                             inProcessOperation;            // m_operation

////                           inProcessOperation +           // m_operation
////                           WsbPersistSizeOf(BYTE);        // m_percentComplete


//    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsMediumChanger::GetSizeMax"), OLESTR("hr = <%ls>, Size = <%ls>"), WsbHrAsString(hr), WsbPtrToUliAsString(pcbSize));

    return(hr);
}

STDMETHODIMP
CRmsMediumChanger::Load(
    IN IStream* pStream
    )
/*++

Implements:

    IPersistStream::Load

--*/
{
    HRESULT     hr = S_OK;
    ULONG       ulBytes = 0;

    WsbTraceIn(OLESTR("CRmsMediumChanger::Load"), OLESTR(""));

    try {

        WsbAssert(0 != pStream, E_POINTER);

        WsbAffirmHr(CRmsDevice::Load(pStream));

        // Load value
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_isAutomatic));

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_canRotate));

        WsbAffirmHr(WsbBstrFromStream(pStream, &m_operation));

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_percentComplete));

        if ( INVALID_HANDLE_VALUE == m_handle ) {

            WsbAffirmHr( AcquireDevice() );

        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsMediumChanger::Load"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

STDMETHODIMP
CRmsMediumChanger::Save(
    IN  IStream *pStream,
    IN  BOOL    clearDirty
    )
/*++

Implements:

    IPersistStream::Save

--*/
{
    HRESULT     hr = S_OK;
    ULONG       ulBytes = 0;

    WsbTraceIn(OLESTR("CRmsMediumChanger::Save"), OLESTR("clearDirty = <%ls>"), WsbBoolAsString(clearDirty));

    try {
        WsbAssert(0 != pStream, E_POINTER);

        WsbAffirmHr(CRmsDevice::Save(pStream, clearDirty));

        // Save value
        WsbAffirmHr(WsbSaveToStream(pStream, m_isAutomatic));

        WsbAffirmHr(WsbSaveToStream(pStream, m_canRotate));

        WsbAffirmHr(WsbBstrToStream(pStream, m_operation));

        WsbAffirmHr(WsbSaveToStream(pStream, m_percentComplete));

        // Do we need to clear the dirty bit?
        if (clearDirty) {
            m_isDirty = FALSE;
        }
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsMediumChanger::Save"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

STDMETHODIMP
CRmsMediumChanger::Test(
    OUT USHORT  *pPassed,
    OUT USHORT  *pFailed
    )
/*++

Implements:

    IWsbTestable::Test

--*/
{
    HRESULT                 hr = S_OK;

    CComPtr<IRmsMediumChanger>      pChanger1;
    CComPtr<IRmsMediumChanger>      pChanger2;

    CComPtr<IPersistFile>   pFile1;
    CComPtr<IPersistFile>   pFile2;

//  CRmsLocator             locWork1;
//  CRmsLocator             locWork2;

    CWsbBstrPtr             bstrVal1 = OLESTR("5A5A5A");
    CWsbBstrPtr             bstrWork1;
    CWsbBstrPtr             bstrWork2;


    WsbTraceIn(OLESTR("CRmsMediumChanger::Test"), OLESTR(""));

    try {
        // Get the Changer interface.
        hr = S_OK;
        try {
            WsbAssertHr(((IUnknown*) (IRmsMediumChanger*) this)->QueryInterface(IID_IRmsMediumChanger, (void**) &pChanger1));

            // Test SetHome & GetHome

            // Test SetAutomatic & IsAutomatic to TRUE
            hr = S_OK;

            try{
                WsbAffirmHr(SetAutomatic (TRUE));
                WsbAffirmHr(IsAutomatic ());
            } WsbCatch (hr);

            if (hr == S_OK){
                (*pPassed)++;
            } else {
                (*pFailed)++;
            }

            // Test SetAutomatic & IsAutomatic to FALSE
            hr = S_OK;

            try{
                WsbAffirmHr(SetAutomatic (FALSE));
                WsbAffirmHr(IsAutomatic ());
            } WsbCatch (hr);

            if (hr == S_OK){
                (*pFailed)++;
            } else {
                (*pPassed)++;
            }

            // Test SetCanRotate & IsCanRotate to TRUE
            hr = S_OK;

            try{
                WsbAffirmHr(SetCanRotate (TRUE));
                WsbAffirmHr(CanRotate ());
            } WsbCatch (hr);

            if (hr == S_OK){
                (*pPassed)++;
            } else {
                (*pFailed)++;
            }

            // Test SetCanRotate & IsCanRotate to FALSE
            hr = S_OK;

            try{
                WsbAffirmHr(SetCanRotate (FALSE));
                WsbAffirmHr(CanRotate ());
            } WsbCatch (hr);

            if (hr == S_OK){
                (*pFailed)++;
            } else {
                (*pPassed)++;
            }

            // Test SetOperation & GetOperation interface
            bstrWork1 = bstrVal1;

            SetOperation(bstrWork1);

            GetOperation(&bstrWork2);

            if (bstrWork1 == bstrWork2){
                (*pPassed)++;
            } else {
                (*pFailed)++;
            }

            // Test SetPercentComplete  & GetPercentComplete

            // Test ExportCartridge & ImportCartridge

            // Test DismountCartridge & MountCartridge

            // Test TestReady

            // Test Home

        } WsbCatch(hr);

        // Tally up the results

        hr = S_OK;
        if (*pFailed) {
            hr = S_FALSE;
        }


    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsMediumChanger::Test"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

/////////////////////////////////////////////////////////////////////////////
//
// IRmsMediumChanger implementation
//


STDMETHODIMP
CRmsMediumChanger::GetHome(
    LONG    *pType,
    LONG    *pPos,
    BOOL    *pInvert
    )
/*++

Implements:

    IRmsMediumChanger::GetHome

--*/
{
    GUID zero = {0,0,0,0,0,0,0,0,0,0,0};
    LONG junk;

    return m_home.GetLocation( pType,
                               &zero,
                               &zero,
                               pPos,
                               &junk,
                               &junk,
                               &junk,
                               pInvert );
}

STDMETHODIMP
CRmsMediumChanger::SetHome(
    LONG    type,
    LONG    pos,
    BOOL    invert
    )
/*++

Implements:

    IRmsMediumChanger::SetHome

--*/
{
    GUID zero = {0,0,0,0,0,0,0,0,0,0,0};
    LONG junk = 0;

    m_isDirty = TRUE;
    return m_home.SetLocation( type, zero, zero, pos, junk, junk, junk, invert );
}

STDMETHODIMP
CRmsMediumChanger::SetAutomatic(
    BOOL    flag
    )
/*++

Implements:

    IRmsMediumChanger::SetAutomatic

--*/
{
    m_isAutomatic = flag;
    m_isDirty = TRUE;
    return S_OK;
}

STDMETHODIMP
CRmsMediumChanger::IsAutomatic(
    void
    )
/*++

Implements:

    IRmsMediumChanger::IsAutomatic

--*/
{
    HRESULT    hr = S_FALSE;

    if (m_isAutomatic){
        hr = S_OK;
        }

    return (hr);
}

STDMETHODIMP
CRmsMediumChanger::SetCanRotate(
    BOOL    flag
    )
/*++

Implements:

    IRmsMediumChanger::SetCanRotate

--*/
{
    m_canRotate = flag;
    m_isDirty = TRUE;
    return S_OK;
}

STDMETHODIMP
CRmsMediumChanger::CanRotate(
    void
    )
/*++

Implements:

    IRmsMediumChanger::CanRotate

--*/
{
    HRESULT    hr = S_FALSE;

    if (m_canRotate){
        hr = S_OK;
        }

    return (hr);
}


STDMETHODIMP
CRmsMediumChanger::GetOperation(
    BSTR    *pOperation
    )
/*++

Implements:

    IRmsMediumChanger::GetOperation

--*/
{
    WsbAssertPointer ( pOperation );

    m_operation.CopyToBstr( pOperation );
    return S_OK;
}


STDMETHODIMP
CRmsMediumChanger::SetOperation(
    BSTR    pOperation
    )
/*++

Implements:

    IRmsMediumChanger::SetOperation

--*/
{
    m_operation = pOperation;
    m_isDirty = TRUE;
    return S_OK;
}

STDMETHODIMP
CRmsMediumChanger::GetPercentComplete(
    BYTE  *pPercent
    )
/*++

Implements:

    IRmsMediumChanger::GetPercentComplete

--*/
{
    *pPercent = m_percentComplete;
    return S_OK;
}

STDMETHODIMP
CRmsMediumChanger::SetPercentComplete(
    BYTE  percent
    )
/*++

Implements:

    IRmsMediumChanger::SetPercentComplete

--*/
{
    m_percentComplete = percent;
    m_isDirty = TRUE;
    return S_OK;
}

STDMETHODIMP
CRmsMediumChanger::TestReady(
    void
    )
/*++

Implements:

    IRmsMediumChanger::TestReady

--*/
{
    return E_NOTIMPL;
}

STDMETHODIMP
CRmsMediumChanger::ImportCartridge(
    IRmsCartridge** /*pCart*/
    )
/*++

Implements:

    IRmsMediumChanger::ImportCartridge

--*/
{
    return E_NOTIMPL;
}

STDMETHODIMP
CRmsMediumChanger::ExportCartridge(
    IRmsCartridge** /*pCart*/
    )
/*++

Implements:

    IRmsMediumChanger::ExportCartridge

--*/
{
    return E_NOTIMPL;
}


STDMETHODIMP
CRmsMediumChanger::MoveCartridge(
    IN IRmsCartridge *pSrcCart,
    IN IUnknown *pDestElmt
    )
/*++

Implements:

    IRmsMediumChanger::MountCartridge

--*/
{
    HRESULT hr = E_FAIL;

    try {

        CComPtr<IRmsCartridge> pCart2;
        CComPtr<IRmsDrive> pDrive2;

        GUID libId=GUID_NULL, mediaSetId=GUID_NULL;
        LONG type=0, pos=0, alt1=0, alt2=0, alt3=0;
        BOOL invert=0;

        GUID destLibId=GUID_NULL, destMediaSetId=GUID_NULL;
        LONG destType=0, destPos=0, destAlt1=0, destAlt2=0, destAlt3=0;
        BOOL destInvert=0;

        GUID dest2LibId=GUID_NULL, dest2MediaSetId=GUID_NULL;
        LONG dest2Type=0, dest2Pos=0, dest2Alt1=0, dest2Alt2=0, dest2Alt3=0;
        BOOL dest2Invert=0;

        CHANGER_ELEMENT src, dest, dest2;

        CComQIPtr<IRmsChangerElement, &IID_IRmsChangerElement> pElmt = pDestElmt;
        WsbAssertPointer( pElmt );

        // TODO:  assert cartridge has same libId as changer

        // Set up for SOURCE
        
        WsbAffirmHr( pSrcCart->GetLocation( &type, &libId, &mediaSetId,
                                            &pos, &alt1, &alt2, &alt3, &invert ));

        src.ElementAddress = pos;

        // Translate the RmsElement type to something the drive understands.

        // TODO: make this a local method

        switch ( (RmsElement) type ) {
        case RmsElementUnknown:
            WsbAssertHr( E_UNEXPECTED );
            break;

        case RmsElementStage:
        case RmsElementStorage:
            src.ElementType = ChangerSlot;
            break;

        case RmsElementShelf:
        case RmsElementOffSite:
            // not supported here!
            WsbAssertHr( E_UNEXPECTED );
            break;

        case RmsElementDrive:
            src.ElementType = ChangerDrive;
            break;

        case RmsElementChanger:
            src.ElementType = ChangerTransport;
            break;

        case RmsElementIEPort:
            src.ElementType = ChangerIEPort;
            break;

        default:
            WsbAssertHr( E_UNEXPECTED );
            break;
        }

        //
        // Set up for DESTINATION
        //
        
        WsbAffirmHr( pElmt->GetLocation( &destType, &destLibId, &destMediaSetId,
                                         &destPos, &destAlt1, &destAlt2, &destAlt3, &destInvert ));

        dest.ElementAddress = destPos;

        // Translate the Rms type to something the drive understands.
        switch ( (RmsElement) destType) {
        case RmsElementUnknown:
            WsbAssertHr( E_UNEXPECTED );
            break;

        case RmsElementStage:
        case RmsElementStorage:
            dest.ElementType = ChangerSlot;
            break;

        case RmsElementShelf:
        case RmsElementOffSite:
            // not supported here!
            WsbAssertHr( E_UNEXPECTED );
            break;

        case RmsElementDrive:
            dest.ElementType = ChangerDrive;
            break;

        case RmsElementChanger:
            dest.ElementType = ChangerTransport;
            break;

        case RmsElementIEPort:
            dest.ElementType = ChangerIEPort;
            break;

        default:
            WsbAssertHr( E_UNEXPECTED );
            break;
        }

        //
        // Do we need to do an exchange or a simple move?
        //

        BOOL destFull;

        hr = pElmt->IsOccupied();

        destFull = ( S_OK == hr ) ? TRUE : FALSE;

        if ( destFull ) {

            //
            // Set up for second destination
            //

            pElmt->GetCartridge( &pCart2 );

            pCart2->GetDrive( &pDrive2 );

            if ( pDrive2 && ( m_parameters.Features0 & CHANGER_PREDISMOUNT_EJECT_REQUIRED ) ) {
                pDrive2->Eject();
            }

            WsbAffirmHr( pCart2->GetHome( &dest2Type, &dest2LibId, &dest2MediaSetId,
                                             &dest2Pos, &dest2Alt1, &dest2Alt2, &dest2Alt3, &dest2Invert ));


            dest2.ElementAddress = dest2Pos;

            // Translate the Rms type to something the drive understands.
            switch ( (RmsElement) dest2Type) {
            case RmsElementUnknown:
                WsbAssertHr( E_UNEXPECTED );
                break;

            case RmsElementStage:
            case RmsElementStorage:
                dest2.ElementType = ChangerSlot;
                break;

            case RmsElementShelf:
            case RmsElementOffSite:
                // not supported here!
                WsbAssertHr( E_UNEXPECTED );
                break;

            case RmsElementDrive:
                WsbAssertHr( E_UNEXPECTED );
                break;

            case RmsElementChanger:
                WsbAssertHr( E_UNEXPECTED );
                break;

            case RmsElementIEPort:
                dest2.ElementType = ChangerIEPort;
                break;

            default:
                WsbAssertHr( E_UNEXPECTED );
                break;
            }


            WsbAffirmHr( ExchangeMedium( src, dest, dest2, FALSE, FALSE ));

            // Update the Cartridge's Locator
            WsbAffirmHr( pSrcCart->SetLocation( destType, libId, mediaSetId,
                                                destPos, alt1, alt2, alt3, invert ));

            WsbAffirmHr( pCart2->SetLocation( dest2Type, dest2LibId, dest2MediaSetId,
                                                dest2Pos, dest2Alt1, dest2Alt2, dest2Alt3, dest2Invert ));

        }
        else {

            // Call through to the medium changer driver to move the cartridge

            // TODO: handle two sided media.

            WsbAffirmHr( MoveMedium( src, dest, FALSE ));

            // Update the Cartridge's Locator
            WsbAffirmHr( pSrcCart->SetLocation( destType, libId, mediaSetId,
                                                destPos, alt1, alt2, alt3, invert ));

        }

        hr = S_OK;

    }
    WsbCatch(hr);

    return hr;
}


STDMETHODIMP
CRmsMediumChanger::HomeCartridge(
    IN IRmsCartridge *pCart
    )
/*++

Implements:

    IRmsMediumChanger::HomeCartridge

--*/
{
    HRESULT hr = E_FAIL;

    try {

        WsbAssertPointer( pCart );

        GUID libId=GUID_NULL, mediaSetId=GUID_NULL;
        LONG type=0, pos=0, alt1=0, alt2=0, alt3=0;
        BOOL invert=0;

        GUID destLibId=GUID_NULL, destMediaSetId=GUID_NULL;
        LONG destType=0, destPos=0, destAlt1=0, destAlt2=0, destAlt3=0;
        BOOL destInvert=0;

        CHANGER_ELEMENT src, dest;

        // TODO:  assert cartridge has same libId as changer

        // Set up for SOURCE
        
        WsbAffirmHr( pCart->GetLocation( &type, &libId, &mediaSetId,
                                         &pos, &alt1, &alt2, &alt3, &invert ));

        src.ElementAddress = pos;

        // Translate the RmsElement type to something the drive understands.

        // TODO: make this a local method

        switch ( (RmsElement) type ) {
        case RmsElementUnknown:
            WsbAssertHr( E_UNEXPECTED );
            break;

        case RmsElementStage:
        case RmsElementStorage:
            src.ElementType = ChangerSlot;
            break;

        case RmsElementShelf:
        case RmsElementOffSite:
            // not supported here!
            WsbAssertHr( E_UNEXPECTED );
            break;

        case RmsElementDrive:
            src.ElementType = ChangerDrive;
            break;

        case RmsElementChanger:
            src.ElementType = ChangerTransport;
            break;

        case RmsElementIEPort:
            src.ElementType = ChangerIEPort;
            break;

        default:
            WsbAssertHr( E_UNEXPECTED );
            break;
        }

        //
        // Set up for DESTINATION
        //
        
        WsbAffirmHr( pCart->GetHome( &destType, &destLibId, &destMediaSetId,
                                     &destPos, &destAlt1, &destAlt2, &destAlt3, &destInvert ));

        dest.ElementAddress = destPos;

        // Translate the Rms type to something the drive understands.
        switch ( (RmsElement) destType) {
        case RmsElementUnknown:
            WsbAssertHr( E_UNEXPECTED );
            break;

        case RmsElementStage:
        case RmsElementStorage:
            dest.ElementType = ChangerSlot;
            break;

        case RmsElementShelf:
        case RmsElementOffSite:
            // not supported here!
            WsbAssertHr( E_UNEXPECTED );
            break;

        case RmsElementDrive:
            dest.ElementType = ChangerDrive;
            break;

        case RmsElementChanger:
            dest.ElementType = ChangerTransport;
            break;

        case RmsElementIEPort:
            dest.ElementType = ChangerIEPort;
            break;

        default:
            WsbAssertHr( E_UNEXPECTED );
            break;
        }

        WsbAffirmHr( MoveMedium( src, dest, FALSE ));

        // Update the Cartridge's Locator
        WsbAffirmHr( pCart->SetLocation( destType, libId, mediaSetId,
                                            destPos, alt1, alt2, alt3, invert ));

        hr = S_OK;

    }
    WsbCatch(hr);
    
    return hr;

}


STDMETHODIMP
CRmsMediumChanger::Initialize(
    void
    )
/*++

Implements:

    IRmsMediumChanger::Initialize

--*/
{

    // TODO: Break this into some smaller methods for initializing slot, drives, ports, etc.

    HRESULT hr = E_FAIL;

    PREAD_ELEMENT_ADDRESS_INFO pElementInformation = 0;

    try {
        DWORD size;

        WsbAffirmHr(AcquireDevice());

        WsbAffirmHr(Status());

        size = sizeof( CHANGER_PRODUCT_DATA );
        CHANGER_PRODUCT_DATA productData;
        WsbAffirmHr(GetProductData( &size, &productData ));

        // Get device specific parameters.
        size = sizeof( GET_CHANGER_PARAMETERS );
        WsbAffirmHr(GetParameters(&size, &m_parameters));

        // save some of the more common parameters
        m_isAutomatic = TRUE;
        if ( m_parameters.Features0 & CHANGER_MEDIUM_FLIP ) m_canRotate = TRUE;

        // Initialize the changer elements
        BOOL scan = TRUE;
        CHANGER_ELEMENT_LIST list;

        if ( m_parameters.Features0 & CHANGER_BAR_CODE_SCANNER_INSTALLED ) scan = TRUE;

        list.NumberOfElements = 1;
        list.Element.ElementType = AllElements;
        list.Element.ElementAddress = 0;

        WsbAffirmHr( InitializeElementStatus( list, scan ) );

        list.NumberOfElements = m_parameters.NumberStorageElements;
        list.Element.ElementType = ChangerSlot;
        list.Element.ElementAddress = 0;

        BOOL tag = ( m_parameters.Features0 & CHANGER_VOLUME_IDENTIFICATION ) ? TRUE : FALSE;

        size = sizeof(READ_ELEMENT_ADDRESS_INFO) + (list.NumberOfElements - 1) * sizeof(CHANGER_ELEMENT_STATUS);
        pElementInformation = (PREAD_ELEMENT_ADDRESS_INFO)WsbAlloc( size );
        WsbAffirmPointer(pElementInformation);
        memset(pElementInformation, 0, size);

        WsbAffirmHr( GetElementStatus( list, tag, &size, pElementInformation ));

        // Create storage slot objects for this changer, if required.
        LONG type;
        GUID libId, mediaSetId;
        LONG pos, alt1, alt2, alt3;
        BOOL invert;

        m_location.GetLocation( &type, &libId, &mediaSetId, &pos, &alt1, &alt2, &alt3, &invert );

        CComQIPtr<IRmsServer, &IID_IRmsServer> pServer = g_pServer;

        CComPtr<IWsbIndexedCollection> pCarts;
        CComPtr<IWsbIndexedCollection> pSlots;

        CComPtr<IRmsLibrary>        pLib;
        CComPtr<IRmsStorageSlot>    pSlot;

        WsbAffirmHr( pServer->FindLibraryById( libId, &pLib ));

        WsbAffirmHr( pLib->GetStorageSlots( &pSlots ));
        WsbAffirmHr( pServer->GetCartridges( &pCarts ));

        ULONG count = 0;
        WsbAffirmHr( pSlots->GetEntries( &count ));

        while ( count < pElementInformation->NumberOfElements ) {

            // Add more slots objects to the library
            WsbAffirmHr( hr = CoCreateInstance( CLSID_CRmsStorageSlot, 0, CLSCTX_SERVER,
                                                IID_IRmsStorageSlot, (void **)&pSlot ));

            WsbAffirmHr( pSlots->Add( pSlot ));

            pSlot = 0;

            count++;
        }

        // Populate the storage slot objects with information reported by the device

        // TODO:  We need to add lots more asserts of various conditions where the
        //        previous slot information is not consistant with what has been detected.

        PCHANGER_ELEMENT_STATUS pElementStatus;
        CComPtr<IWsbEnum> pEnumSlots;

        WsbAffirmHr( pSlots->Enum( &pEnumSlots ));
        WsbAssertPointer( pEnumSlots );

        hr = pEnumSlots->First( IID_IRmsStorageSlot, (void **)&pSlot );

        for ( ULONG i = 0; i < pElementInformation->NumberOfElements; i++ ) {

            pElementStatus = &pElementInformation->ElementStatus[i];

            WsbAssert( ChangerSlot == pElementStatus->Element.ElementType, E_UNEXPECTED );
            WsbAssert( i == pElementStatus->Element.ElementAddress, E_UNEXPECTED );

            CComQIPtr<IRmsChangerElement, &IID_IRmsChangerElement> pSlotElmt = pSlot;

            // Is the unit of media inverted?
            invert = ( ( pElementStatus->Flags & (ULONG)ELEMENT_STATUS_SVALID ) &&
                       ( pElementStatus->Flags & (ULONG)ELEMENT_STATUS_INVERT )    ) ? TRUE : FALSE;
            WsbAffirmHr( pSlotElmt->SetLocation( RmsElementStorage, libId, GUID_NULL, i, 0, 0, 0, invert ));

            // Is the slot Full or Empty?
            BOOL occupied = ( pElementStatus->Flags & (ULONG)ELEMENT_STATUS_FULL ) ? TRUE : FALSE;
            WsbAffirmHr( pSlotElmt->SetIsOccupied( occupied ));

            // Set the media type supported
            WsbAffirmHr( pSlotElmt->SetMediaSupported( m_mediaSupported ));

            // Set the storage flag
            WsbAffirmHr( pSlotElmt->SetIsStorage( TRUE ));

            // If there is a cartridge present fill in cartridge information
            if ( occupied ) {

                CComPtr<IRmsCartridge> pCart;

                WsbAffirmHr( hr = CoCreateInstance( CLSID_CRmsCartridge, 0, CLSCTX_SERVER,
                                                    IID_IRmsCartridge, (void **)&pCart ));


                WsbAffirmHr( pCart->SetLocation( RmsElementStorage, libId, GUID_NULL, i, 0, 0, 0, invert ));
                WsbAffirmHr( pCart->SetLocation( RmsElementStorage, libId, GUID_NULL, i, 0, 0, 0, invert ));
                WsbAffirmHr( pCart->SetHome( RmsElementStorage, libId, GUID_NULL, i, 0, 0, 0, invert ));
                WsbAffirmHr( pCart->SetStatus( RmsStatusScratch ));
                WsbAffirmHr( pCart->SetType( m_mediaSupported ));
                WsbAffirmHr( pSlotElmt->SetCartridge( pCart ));

                // Add cartridge to drive
                WsbAffirmHr( pCarts->Add( pCart ));

                if ( pElementStatus->Flags & (ULONG)ELEMENT_STATUS_PVOLTAG ) {

                    pElementStatus->PrimaryVolumeID[32] = '\0';  // This nulls the reserved byte
                    pElementStatus->PrimaryVolumeID[33] = '\0';  // This nulls the reserved byte
                    CWsbBstrPtr label( (char *)pElementStatus->PrimaryVolumeID );

                    // Fill in external label information
                    WsbAffirmHr( pCart->SetTagAndNumber( label, 0 ));

                }

            }

            // Get the next slot
            hr = pEnumSlots->Next( IID_IRmsStorageSlot, (void **)&pSlot );
        }




        // Now process drives.



        // Read element status

        list.NumberOfElements = m_parameters.NumberDataTransferElements;
        list.Element.ElementType = ChangerDrive;
        list.Element.ElementAddress = 0;

        if ( m_parameters.Features0 & CHANGER_VOLUME_IDENTIFICATION ) tag = TRUE;

        size = sizeof(READ_ELEMENT_ADDRESS_INFO) + (list.NumberOfElements - 1) * sizeof(CHANGER_ELEMENT_STATUS);

        WsbFree( pElementInformation );
        pElementInformation = (PREAD_ELEMENT_ADDRESS_INFO)WsbAlloc( size );
        WsbAffirmPointer(pElementInformation);
        memset(pElementInformation, 0, size);

        WsbAffirmHr( GetElementStatus( list, tag, &size, pElementInformation ));

        CComPtr<IWsbIndexedCollection> pDevices;
        CComPtr<IWsbIndexedCollection> pDrives;
        CComPtr<IRmsDrive> pDrive;
        CComPtr<IRmsDrive> pFindDrive;
        CComPtr<IRmsDevice> pFindDevice;

        WsbAffirmHr( pServer->GetUnconfiguredDevices( &pDevices ));
        WsbAffirmHr( pLib->GetDrives( &pDrives ));

        // For each drive in the element status page, find the drive in the
        // unconfigured list of devices.

        for ( i = 0; i < pElementInformation->NumberOfElements; i++ ) {

            pElementStatus = &pElementInformation->ElementStatus[i];

            WsbAssert( ChangerDrive == pElementStatus->Element.ElementType, E_UNEXPECTED );
            WsbAssert( i == pElementStatus->Element.ElementAddress, E_UNEXPECTED );

            // set up a find template
            WsbAffirmHr( CoCreateInstance( CLSID_CRmsDrive, 0, CLSCTX_SERVER,
                               IID_IRmsDrive, (void **)&pFindDrive ));

            CComQIPtr<IRmsDevice, &IID_IRmsDevice> pFindDevice = pFindDrive;
            CComQIPtr<IRmsComObject, &IID_IRmsComObject> pFindObject = pFindDrive;

            BYTE port=0xff, bus=0xff, id=0xff, lun=0xff;

            if ( pElementStatus->Flags & (ULONG)ELEMENT_STATUS_LUN_VALID )
                lun = pElementStatus->Lun;

            if ( pElementStatus->Flags & (ULONG)ELEMENT_STATUS_ID_VALID )
                id = pElementStatus->TargetId;

            if ( !(pElementStatus->Flags & (ULONG)ELEMENT_STATUS_NOT_BUS) ) {
                bus = m_bus;
                port = m_port;
            }

            WsbAffirmHr( pFindDevice->SetDeviceAddress( port, bus, id, lun ));

            WsbAffirmHr( pFindObject->SetFindBy( RmsFindByDeviceAddress ));

            // Find the drive

            hr = pDevices->Find( pFindDrive, IID_IRmsDrive, (void **)&pDrive );

            if ( S_OK == hr ) {

                // Add the drive to the library
                WsbAffirmHr( pDrives->Add( pDrive ));

                // Remove the drive form the unconfigured list
                WsbAffirmHr( pDevices->RemoveAndRelease( pDrive ));

                // Fill in more drive information
                CComQIPtr<IRmsChangerElement, &IID_IRmsChangerElement> pDriveElmt = pDrive;

                // Is the unit of media inverted?
                invert = ( ( pElementStatus->Flags & (ULONG)ELEMENT_STATUS_SVALID ) &&
                         ( pElementStatus->Flags & (ULONG)ELEMENT_STATUS_INVERT )    ) ? TRUE : FALSE;
                WsbAffirmHr( pDriveElmt->SetLocation( RmsElementDrive, libId, GUID_NULL, i, 0, 0, 0, invert ));

                // Is the slot Full or Empty?
                BOOL occupied = ( pElementStatus->Flags & (ULONG)ELEMENT_STATUS_FULL ) ? TRUE : FALSE;
                WsbAffirmHr( pDriveElmt->SetIsOccupied( occupied ));

                // Set the media type supported
                WsbAffirmHr( pDriveElmt->SetMediaSupported( m_mediaSupported ));

                // Set the storage flag
                WsbAffirmHr( pDriveElmt->SetIsStorage( TRUE ));

                // If there is a cartridge present fill in cartridge information
                if ( occupied ) {

                    CComPtr<IRmsCartridge> pCart;

                    WsbAffirmHr( hr = CoCreateInstance( CLSID_CRmsCartridge, 0, CLSCTX_SERVER,
                                                        IID_IRmsCartridge, (void **)&pCart ));

                    WsbAffirmHr( pCart->SetLocation( RmsElementStorage, libId, GUID_NULL, i, 0, 0, 0, invert ));

                    if ( pElementStatus->Flags & (ULONG)ELEMENT_STATUS_SVALID ) {


                        try {
                            ULONG pos;
                        
//                                pos =  pElementStatus->SourceElementAddress[1];
//                                pos |=  (pElementStatus->SourceElementAddress[0] << 8);
                            pos =  pElementStatus->SrcElementAddress.ElementAddress;


                            //
                            // TODO:  FIX THIS - This code incorrectly assumes source is a slot!!!
                            //
                            // I'll work on trying to get chuck to return element type and position 
                            // in element status page.
                            //

                            WsbAffirm( pos >= m_parameters.FirstSlotNumber, E_UNEXPECTED );

                            pos = pos - m_parameters.FirstSlotNumber;

                            BOOL invert = ( pElementStatus->Flags & (ULONG)ELEMENT_STATUS_INVERT ) ? TRUE : FALSE;

                            WsbAffirmHr( pCart->SetHome( RmsElementStorage, libId, GUID_NULL, pos, 0, 0, 0, invert ));
                        }
                        WsbCatch(hr);

                    }

                    // TODO: if not ELEMENT_STATUS_SVALID we should set the home location to
                    //       some empty slot.  This handles the case where we we come up with
                    //       unknown media in a drive.


                    WsbAffirmHr( pCart->SetStatus( RmsStatusScratch ));
                    WsbAffirmHr( pCart->SetType( m_mediaSupported ));
                    WsbAffirmHr( pCart->SetDrive( pDrive ));

                    // Add cartridge to drive
                    WsbAffirmHr( pCarts->Add( pCart ));

                    if ( pElementStatus->Flags & (ULONG)ELEMENT_STATUS_PVOLTAG ) {

                        pElementStatus->PrimaryVolumeID[32] = '\0';  // This nulls the reserved byte
                        pElementStatus->PrimaryVolumeID[33] = '\0';  // This nulls the reserved byte
                        CWsbBstrPtr label( (char *)pElementStatus->PrimaryVolumeID );

                        // Fill in external label information
                        WsbAffirmHr( pCart->SetTagAndNumber( label, 0 ));

                    }

                }

            }

        }

        // All done
        hr = S_OK;

    }
    WsbCatch(hr);

    if ( pElementInformation ) {
        WsbFree( pElementInformation );
    }

    return hr;

}


STDMETHODIMP
CRmsMediumChanger::AcquireDevice(
    void
    )
/*++

Implements:

    IRmsMediumChanger::AcquireDevice

--*/
{

    HRESULT         hr = E_FAIL;
    HANDLE          hChanger = INVALID_HANDLE_VALUE;
    CWsbBstrPtr     name;

    try {
        // Get the device name for this changer
        GetDeviceName( &name );

        // Create a handle
        hChanger = CreateFile( name,
                             GENERIC_READ | GENERIC_WRITE,
                             0,
                             0,
                             OPEN_EXISTING,
                             0,
                             NULL
                             );

        WsbAffirmHandle( hChanger );

        // Save the handle
        m_handle = hChanger;

        // Do any other initialization here

        hr = S_OK;
    }
    WsbCatchAndDo( hr,
                        WsbTrace( OLESTR("\n\n !!!!! ERROR !!!!! Acquire() failed. name=<%ls>\n\n"), name );
                        if ( hChanger != INVALID_HANDLE_VALUE ) {
                            CloseHandle( hChanger );
                        } );

    return hr;

}


STDMETHODIMP
CRmsMediumChanger::ReleaseDevice(
    void
    )
/*++

Implements:

    IRmsMediumChanger::ReleaseDevice

--*/
{
    HRESULT hr = E_FAIL;

    try {

        if ( INVALID_HANDLE_VALUE != m_handle ) {

            WsbAffirmStatus( CloseHandle( m_handle ));
            m_handle = INVALID_HANDLE_VALUE;

        }
        hr = S_OK;

    }
    WsbCatch( hr );

    return hr;

}

////////////////////////////////////////////////////////////////////////////////
//
// IRmsMoveMedia Interface
//

STDMETHODIMP
CRmsMediumChanger::GetParameters(
    IN OUT PDWORD pSize,
    OUT PGET_CHANGER_PARAMETERS pParms
    )
/*++

Implements:

    IRmsMoveMedia::GetParameters

--*/
{

    HRESULT hr = E_FAIL;

    try
    {
        DWORD dwReturn;

        WsbAssertPointer( pSize );
        WsbAssertPointer( pParms );
        WsbAssertHandle( m_handle );

        pParms->Size = sizeof(GET_CHANGER_PARAMETERS);

        WsbAssertStatus( DeviceIoControl( m_handle,
                         IOCTL_CHANGER_GET_PARAMETERS,
                         pParms,
                         sizeof(GET_CHANGER_PARAMETERS),
                         pParms,
                         sizeof(GET_CHANGER_PARAMETERS),
                         &dwReturn,
                         NULL ));
        hr = S_OK;
    }
    WsbCatch( hr );

    return hr;
}



STDMETHODIMP
CRmsMediumChanger::GetProductData(
    IN OUT PDWORD pSize,
    OUT PCHANGER_PRODUCT_DATA pData
    )
/*++

Implements:

    IRmsMoveMedia::GetProductData

--*/
{

    HRESULT hr = E_FAIL;

    try
    {
        DWORD   dwReturn;

        WsbAssertPointer( pSize );
        WsbAssertPointer( pData );
        WsbAssertHandle( m_handle );

        WsbAssertStatus( DeviceIoControl( m_handle,
                         IOCTL_CHANGER_GET_PRODUCT_DATA,
                         NULL,
                         0,
                         pData,
                         sizeof(CHANGER_PRODUCT_DATA),
                         &dwReturn,
                         NULL ));
        hr = S_OK;
    }
    WsbCatch( hr );

    return hr;
}



STDMETHODIMP
CRmsMediumChanger::Status(
    void
    )
/*++

Implements:

    IRmsMoveMedia::Status

--*/
{

    HRESULT hr = E_FAIL;

    try
    {
        DWORD dwReturn;

        WsbAssertStatus( DeviceIoControl( m_handle,
                         IOCTL_CHANGER_GET_STATUS,
                         NULL,
                         0,
                         NULL,
                         0,
                         &dwReturn,
                         NULL) );
        hr = S_OK;
    }
    WsbCatch( hr );

    return hr;
}



STDMETHODIMP
CRmsMediumChanger::SetAccess(
    IN CHANGER_ELEMENT element,
    IN DWORD control
    )
/*++

Implements:

    IRmsMoveMedia::SetAccess

--*/
{

    HRESULT hr = E_FAIL;

    try
    {
        DWORD dwReturn;
        CHANGER_SET_ACCESS setAccess;

        setAccess.Element = element;
        setAccess.Control = control;

        WsbAssertStatus( DeviceIoControl( m_handle,
                         IOCTL_CHANGER_SET_ACCESS,
                         &setAccess,
                         sizeof(CHANGER_SET_ACCESS),
                         NULL,
                         0,
                         &dwReturn,
                         NULL ));
        hr = S_OK;
    }
    WsbCatch( hr );

    return hr;
}



STDMETHODIMP
CRmsMediumChanger::GetElementStatus(
    IN CHANGER_ELEMENT_LIST elementList,
    IN BOOL volumeTagInfo,
    IN OUT PDWORD pSize,
    OUT PREAD_ELEMENT_ADDRESS_INFO pElementInformation
    )
/*++

Implements:

    IRmsMoveMedia::GetElementStatus

--*/
{

    HRESULT hr = E_FAIL;

    try
    {
        DWORD dwReturn;
        DWORD requiredSize;
        CHANGER_READ_ELEMENT_STATUS readElementStatus;
        PCHANGER_ELEMENT_STATUS pElementStatus = pElementInformation->ElementStatus;

        WsbAssertPointer( pSize );
        WsbAssertPointer( pElementInformation );

        requiredSize = elementList.NumberOfElements * sizeof( CHANGER_ELEMENT_STATUS );
        WsbAssert( *pSize >= requiredSize, E_INVALIDARG );

        readElementStatus.ElementList = elementList;
        readElementStatus.VolumeTagInfo = (BOOLEAN)( volumeTagInfo ? TRUE : FALSE );

        WsbAssertStatus( DeviceIoControl( m_handle,
                         IOCTL_CHANGER_GET_ELEMENT_STATUS,
                         &readElementStatus,
                         sizeof(CHANGER_READ_ELEMENT_STATUS),
                         pElementStatus,
                         requiredSize,
                         &dwReturn,
                         NULL ));

        pElementInformation->NumberOfElements = dwReturn / sizeof( CHANGER_ELEMENT_STATUS );

        hr = S_OK;

    }
    WsbCatch( hr );

    return hr;
}



STDMETHODIMP
CRmsMediumChanger::InitializeElementStatus(
    IN CHANGER_ELEMENT_LIST elementList,
    IN BOOL barCodeScan
    )
/*++

Implements:

    IRmsMoveMedia::InitializeElementStatus

--*/
{

    HRESULT hr = E_FAIL;

    try
    {
        DWORD dwReturn;
        CHANGER_INITIALIZE_ELEMENT_STATUS initElementStatus;

        initElementStatus.ElementList = elementList;
        initElementStatus.BarCodeScan = (BOOLEAN)( barCodeScan ? TRUE : FALSE );

        WsbAssertStatus( DeviceIoControl( m_handle,
                         IOCTL_CHANGER_INITIALIZE_ELEMENT_STATUS,
                         &initElementStatus,
                         sizeof(CHANGER_INITIALIZE_ELEMENT_STATUS),
                         NULL,
                         0,
                         &dwReturn,
                         NULL) );
        hr = S_OK;
    }
    WsbCatch( hr );

    return hr;
}



STDMETHODIMP
CRmsMediumChanger::ExchangeMedium(
    IN CHANGER_ELEMENT source,
    IN CHANGER_ELEMENT destination1,
    IN CHANGER_ELEMENT destination2,
    IN BOOL flip1,
    IN BOOL flip2
    )
/*++

Implements:

    IRmsMoveMedia::ExchangeMedium

--*/
{

    HRESULT hr = E_FAIL;

    try
    {
        DWORD dwReturn;
        CHANGER_EXCHANGE_MEDIUM exchangeMedium;

        exchangeMedium.Transport.ElementType = ChangerTransport;
        exchangeMedium.Transport.ElementAddress = 0; // default arm or thumb
        exchangeMedium.Source = source;
        exchangeMedium.Destination1 = destination1;
        exchangeMedium.Destination2 = destination2;
        exchangeMedium.Flip1 = (BOOLEAN)( flip1 ? TRUE : FALSE );
        exchangeMedium.Flip2 = (BOOLEAN)( flip2 ? TRUE : FALSE );

        WsbAssertStatus( DeviceIoControl( m_handle,
                         IOCTL_CHANGER_EXCHANGE_MEDIUM,
                         &exchangeMedium,
                         sizeof(CHANGER_EXCHANGE_MEDIUM),
                         NULL,
                         0,
                         &dwReturn,
                         NULL ));
        hr = S_OK;
    }
    WsbCatch( hr );

    return hr;
}



STDMETHODIMP
CRmsMediumChanger::MoveMedium(
    IN CHANGER_ELEMENT source,
    IN CHANGER_ELEMENT destination,
    IN BOOL flip
    )
/*++

Implements:

    IRmsMoveMedia::MoveMedium

--*/
{

    HRESULT hr = E_FAIL;

    try
    {
        DWORD dwReturn;
        CHANGER_MOVE_MEDIUM moveMedium;

        moveMedium.Transport.ElementType = ChangerTransport;
        moveMedium.Transport.ElementAddress = 0; // default arm or thumb
        moveMedium.Source = source;
        moveMedium.Destination = destination;
        moveMedium.Flip = (BOOLEAN)( flip ? TRUE : FALSE );

        WsbAssertStatus( DeviceIoControl( m_handle,
                         IOCTL_CHANGER_MOVE_MEDIUM,
                         &moveMedium,
                         sizeof(CHANGER_MOVE_MEDIUM),
                         NULL,
                         0,
                         &dwReturn,
                         NULL ));
        hr = S_OK;
    }
    WsbCatch( hr );

    return hr;
}



STDMETHODIMP
CRmsMediumChanger::Position(
    IN CHANGER_ELEMENT destination,
    IN BOOL flip
    )
/*++

Implements:

    IRmsMoveMedia::Position

--*/
{

    HRESULT hr = E_FAIL;

    try
    {
        DWORD dwReturn;
        CHANGER_SET_POSITION positon;

        positon.Transport.ElementType = ChangerTransport;
        positon.Transport.ElementAddress = 0; // default arm or thumb
        positon.Destination = destination;
        positon.Flip = (BOOLEAN)( flip ? TRUE : FALSE );

        WsbAssertStatus( DeviceIoControl( m_handle,
                         IOCTL_CHANGER_SET_POSITION,
                         &positon,
                         sizeof(CHANGER_SET_POSITION),
                         NULL,
                         0,
                         &dwReturn,
                         NULL ));
        hr = S_OK;
    }
    WsbCatch( hr );

    return hr;
}



STDMETHODIMP
CRmsMediumChanger::RezeroUnit(
    void
    )
/*++

Implements:

    IRmsMoveMedia::RezeroUnit

--*/
{

    HRESULT hr = E_FAIL;

    try
    {
        DWORD dwReturn;

        WsbAssertStatus( DeviceIoControl( m_handle,
                         IOCTL_CHANGER_REINITIALIZE_TRANSPORT,
                         NULL,
                         0,
                         NULL,
                         0,
                         &dwReturn,
                         NULL ));
        hr = S_OK;
    }
    WsbCatch( hr );

    return hr;
}


/*

HRESULT
CRmsMediumChanger::getDisplay(
    OUT PCHANGER_DISPLAY pDisplay
    )
{

    HRESULT hr = E_FAIL;

    try
    {
        DWORD dwReturn;

        WsbAssertStatus( DeviceIoControl( m_handle,
                         IOCTL_CHANGER_GET_DISPLAY,
                         pDisplay,
                         sizeof(CHANGER_DISPLAY) + (pDisplay->LineCount - 1) * sizeof(SET_CHANGER_DISPLAY),
                         pDisplay,
                         sizeof(CHANGER_DISPLAY) + (pDisplay->LineCount - 1) * sizeof(SET_CHANGER_DISPLAY),
                         &dwReturn,
                         NULL ));
        hr = S_OK;
    }
    WsbCatch( hr );

    return hr;
}



HRESULT
CRmsMediumChanger::setDisplay(
    IN PCHANGER_DISPLAY pDisplay
    )
{

    HRESULT hr = E_FAIL;

    try
    {
        DWORD dwReturn;

        WsbAssertStatus( DeviceIoControl( m_handle,
                         IOCTL_CHANGER_SET_DISPLAY,
                         pDisplay,
                         sizeof(CHANGER_DISPLAY) + (pDisplay->LineCount - 1) * sizeof(SET_CHANGER_DISPLAY),
                         NULL,
                         0,
                         &dwReturn,
                         NULL ));
        hr = S_OK;
    }
    WsbCatch( hr );

    return hr;
}
*/



STDMETHODIMP
CRmsMediumChanger::QueryVolumeTag(
    IN CHANGER_ELEMENT startingElement,
    IN DWORD actionCode,
    IN PUCHAR pVolumeIDTemplate,
    OUT PDWORD pNumberOfElementsReturned,
    OUT PREAD_ELEMENT_ADDRESS_INFO pElementInformation
    )
/*++

Implements:

    IRmsMoveMedia::QueryVolumeTag

--*/
{

    HRESULT hr = E_FAIL;

    try
    {
        DWORD dwReturn;
        CHANGER_SEND_VOLUME_TAG_INFORMATION tagInfo;

        tagInfo.StartingElement = startingElement;
        tagInfo.ActionCode = actionCode;
        memcpy( &tagInfo.VolumeIDTemplate, pVolumeIDTemplate, sizeof(MAX_VOLUME_TEMPLATE_SIZE) );

        WsbAssertStatus( DeviceIoControl( m_handle,
                         IOCTL_CHANGER_QUERY_VOLUME_TAGS,
                         &tagInfo,
                         sizeof(CHANGER_SEND_VOLUME_TAG_INFORMATION),
                         pElementInformation,
                         sizeof(READ_ELEMENT_ADDRESS_INFO) + (pElementInformation->NumberOfElements - 1) * sizeof(CHANGER_ELEMENT_STATUS),
                         &dwReturn,
                         NULL ));

        *pNumberOfElementsReturned = pElementInformation->NumberOfElements;

        hr = S_OK;
    }
    WsbCatch( hr );

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\rms\server\rmsclien.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    RmsClien.h

Abstract:

    Declaration of the CRmsClient class

Author:

    Brian Dodd          [brian]         15-Nov-1996

Revision History:

--*/

#ifndef _RMSCLIEN_
#define _RMSCLIEN_

#include "resource.h"       // resource symbols

#include "RmsObjct.h"       // CRmsComObject

/*++

Class Name:

    CRmsClient

Class Description:

    A CRmsClient represents information about a registerered
    Rms client application.

--*/

class CRmsClient :
    public CComDualImpl<IRmsClient, &IID_IRmsClient, &LIBID_RMSLib>,
    public CRmsComObject,
    public CWsbObject,          // inherits CComObjectRoot
    public CComCoClass<CRmsClient,&CLSID_CRmsClient>
{
public:
    CRmsClient() {}
BEGIN_COM_MAP(CRmsClient)
    COM_INTERFACE_ENTRY2(IDispatch, IRmsClient)
    COM_INTERFACE_ENTRY(IRmsClient)
    COM_INTERFACE_ENTRY(IRmsComObject)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IWsbCollectable)
    COM_INTERFACE_ENTRY(IWsbPersistStream)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_RmsClient)

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);

// IPersist
public:
    STDMETHOD(GetClassID)(CLSID *pClsid);

// IPersistStream
public:
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER* pSize);
    STDMETHOD(Load)(IStream* pStream);
    STDMETHOD(Save)(IStream* pStream, BOOL clearDirty);

// IWsbCollectable
public:
    STDMETHOD(CompareTo)(IUnknown* pCollectable, SHORT* pResult);
    WSB_FROM_CWSBOBJECT;

// IWsbTestable
public:
    STDMETHOD(Test)(USHORT *pPassed, USHORT *pFailed);

// IRmsClient
public:
    STDMETHOD(GetOwnerClassId)(CLSID *pClassId);
    STDMETHOD(SetOwnerClassId)(CLSID classId);

    STDMETHOD( GetName )( BSTR *pName );
    STDMETHOD( SetName )( BSTR name );

    STDMETHOD( GetPassword )( BSTR *pName );
    STDMETHOD( SetPassword )( BSTR name );

    STDMETHOD(GetInfo)(UCHAR *pInfo, SHORT *pSize);
    STDMETHOD(SetInfo)(UCHAR *pInfo, SHORT size);

    STDMETHOD(GetVerifierClass)(CLSID *pClassId);
    STDMETHOD(SetVerifierClass)(CLSID classId);

    STDMETHOD(GetPortalClass)(CLSID *pClassId);
    STDMETHOD(SetPortalClass)(CLSID classId);

private:
    enum {                                  // Class specific constants:
                                            //
        Version = 1,                        // Class version, this should be
                                            //   incremented each time the
                                            //   the class definition changes.
        MaxInfo = 128,                      // Size of the application specific
                                            //   infomation buffer.  Currently
                                            //   fixed in size.
        };                                  //
    CLSID           m_ownerClassId;         // The Class ID for the client application.
    CWsbBstrPtr     m_password;             // Client password.
    SHORT           m_sizeofInfo;           // The size of valid data in the application
                                            //   specific information buffer.
    UCHAR           m_info[MaxInfo];        // Application specific information.
    CLSID           m_verifierClass;        // The interface to the on-media
                                            //    ID verification function.
    CLSID           m_portalClass;          // The interface to a site specific import
                                            //   and export storage location
                                            //   specification dialog.

    };

#endif // _RMSCLIEN_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\rms\server\rmsdrcls.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    RmsDrCls.h

Abstract:

    Declaration of the CRmsDriveClass class

Author:

    Brian Dodd          [brian]         15-Nov-1996

Revision History:

--*/

#ifndef _RMSDRCLS_
#define _RMSDRCLS_

#include "resource.h"       // resource symbols

#include "RmsObjct.h"       // CRmsComObject

/*++

Class Name:

    CRmsDriveClass

Class Description:

    A CRmsDriveClass holds administrative properties associated with a drive, more
    typically a grouping of drives that are of equal performance characteristics,
    and capabilities.  These properties include current mount limits, and Cartridge
    idle time specifications that indicate when an inactive Cartridge should be
    returned to its storage location.

    By default a DriveClass object is created for each type of media supported by
    the drives in a library.  Multi-functions drives will be associated with multiple
    drive classes.

    A DriveClass maintains a collection of drives that are associated with the DriveClass.

--*/

class CRmsDriveClass :
    public CComDualImpl<IRmsDriveClass, &IID_IRmsDriveClass, &LIBID_RMSLib>,
    public CRmsComObject,
    public CWsbObject,          // inherits CComObjectRoot
    public CComCoClass<CRmsDriveClass,&CLSID_CRmsDriveClass>
{
public:
    CRmsDriveClass() {}
BEGIN_COM_MAP(CRmsDriveClass)
    COM_INTERFACE_ENTRY2(IDispatch, IRmsDriveClass)
    COM_INTERFACE_ENTRY(IRmsDriveClass)
    COM_INTERFACE_ENTRY(IRmsComObject)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IWsbCollectable)
    COM_INTERFACE_ENTRY(IWsbPersistStream)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_RmsDriveClass)

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);

// IPersist
public:
    STDMETHOD(GetClassID)(CLSID *pClsid);

// IPersistStream
public:
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER* pSize);
    STDMETHOD(Load)(IStream* pStream);
    STDMETHOD(Save)(IStream* pStream, BOOL clearDirty);

// IWsbCollectable
public:
    STDMETHOD(CompareTo)(IUnknown* pCollectable, SHORT* pResult);
    WSB_FROM_CWSBOBJECT;

// IWsbTestable
public:
    STDMETHOD(Test)(USHORT *pPassed, USHORT *pFailed);

// IRmsDriveClass
public:
    STDMETHOD(GetDriveClassId)(GUID *pDriveClassId);

    STDMETHOD(GetName)(BSTR *pName);
    STDMETHOD(SetName)(BSTR name);

    STDMETHOD(GetType)(LONG *pType);
    STDMETHOD(SetType)(LONG type);

    STDMETHOD(GetCapability)(LONG *pCapability);
    STDMETHOD(SetCapability)(LONG capability);

    STDMETHOD(GetIdleTime)(LONG *pTime);
    STDMETHOD(SetIdleTime)(LONG time);

    STDMETHOD(GetMountWaitTime)(LONG *pTime);
    STDMETHOD(SetMountWaitTime)(LONG time);

    STDMETHOD(GetMountLimit)(LONG *pLim);
    STDMETHOD(SetMountLimit)(LONG lim);

    STDMETHOD(GetQueuedRequests)(LONG *pReqs);
    STDMETHOD(SetQueuedRequests)(LONG reqs);

    STDMETHOD(GetUnloadPauseTime)(LONG *pTime);
    STDMETHOD(SetUnloadPauseTime)(LONG time);

    STDMETHOD(GetDriveSelectionPolicy)(LONG *pPolicy);
    STDMETHOD(SetDriveSelectionPolicy)(LONG policy);

    STDMETHOD(GetDrives)(IWsbIndexedCollection **ptr);

private:

    enum {                                  // Class specific constants:
                                            //
        Version = 1,                        // Class version, this should be
                                            //   incremented each time the
                                            //   the class definition changes.
        };                                  //
    RmsMedia        m_type;                 // The type of media (only one type per
                                            //   DriveClass) supported by the
                                            //   DriveClass (see RmsMedia).
    RmsMode         m_capability;           // The capability of the drives
                                            //   associated with a DriveClass
                                            //   (see RmsMode).
    LONG            m_idleTime;             // Elapsed milliseconds before an idle
                                            //   Cartridge is returned to its storage
                                            //   location.
    LONG            m_mountWaitTime;        // Elapsed milliseconds to wait before
                                            //   timming out a mount request for
                                            //   drive in a DriveClass.
    LONG            m_mountLimit;           // The max number of parallel mount requests.
    LONG            m_queuedRequests;       // The number of outstanding requests
                                            //   for drive resources in a
                                            //   DriveClass.
    LONG            m_unloadPauseTime;      // Elapsed milliseconds to wait before
                                            //   moving a Cartridge from a drive
                                            //   associated with a DriveClass.
                                            //   This is required for dumb devices.
    RmsDriveSelect  m_driveSelectionPolicy; // The drive selection policy used
                                            //   when selecting drives associated
                                            //   with a DriveClass (see RmsDriveSelect).
    CComPtr<IWsbIndexedCollection>  m_pDrives;  // The drives associates with a DriveClass.
};

#endif // _RMSDRCLS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\rms\server\rmsdrive.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    RmsDrive.cpp

Abstract:

    Implementation of CRmsDrive

Author:

    Brian Dodd          [brian]         15-Nov-1996

Revision History:

--*/

#include "stdafx.h"
#include "RmsDrive.h"
#include "RmsServr.h"

int CRmsDrive::s_InstanceCount = 0;

#define RMS_CRITICAL_SECTION 1

////////////////////////////////////////////////////////////////////////////////
//


STDMETHODIMP
CRmsDrive::CompareTo(
    IN  IUnknown  *pCollectable,
    OUT SHORT     *pResult
    )
/*++

Implements:

    IWsbCollectable::CompareTo

--*/
{
    HRESULT     hr = E_FAIL;
    SHORT       result = 1;

    WsbTraceIn( OLESTR("CRmsDrive::CompareTo"), OLESTR("") );

    try {

        // Validate arguments - Okay if pResult is NULL
        WsbAssertPointer( pCollectable );

        // !!!!!
        //
        // IMPORTANT: The collectable coming in may not be a CRmsDrive if the collection
        //            is the unconfigured device list.
        //
        // !!!!!

        CComQIPtr<IRmsComObject, &IID_IRmsComObject> pObject = pCollectable;

        // Every collectable should be an CRmsComObject
        WsbAssertPointer( pObject );

        switch ( m_findBy ) {

        case RmsFindByDeviceInfo:
        case RmsFindByDeviceAddress:
        case RmsFindByDeviceName:
        case RmsFindByDeviceType:

            // Do CompareTo for device
            hr = CRmsDevice::CompareTo( pCollectable, &result );
            break;

        case RmsFindByElementNumber:
        case RmsFindByMediaSupported:

            // Do CompareTo for changer element
            hr = CRmsChangerElement::CompareTo( pCollectable, &result );
            break;

        case RmsFindByObjectId:
        default:

            // Do CompareTo for object
            hr = CRmsComObject::CompareTo( pCollectable, &result );
            break;

        }

    }
    WsbCatch( hr );

    if ( SUCCEEDED(hr) && (0 != pResult) ){
       *pResult = result;
    }

    WsbTraceOut( OLESTR("CRmsDrive::CompareTo"),
                 OLESTR("hr = <%ls>, result = <%ls>"),
                 WsbHrAsString( hr ), WsbPtrToShortAsString( pResult ) );

    return hr;
}


STDMETHODIMP
CRmsDrive::FinalConstruct(
    void
    )
/*++

Implements:

    CComObjectRoot::FinalConstruct

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CRmsDrive::FinalConstruct"), OLESTR(""));

    try {
        WsbAssertHr(CWsbObject::FinalConstruct());

        // Initialize values
        m_MountReference = 0;
        m_UnloadNowTime.dwHighDateTime = 0;
        m_UnloadNowTime.dwLowDateTime = 0;
        m_UnloadThreadHandle = NULL;

        try {

            // May raise STATUS_NO_MEMORY exception
            InitializeCriticalSection(&m_CriticalSection);

        } catch(DWORD status) {
            WsbLogEvent(status, 0, NULL, NULL);
            switch (status) {
            case STATUS_NO_MEMORY:
                WsbThrow(E_OUTOFMEMORY);
                break;
            default:
                WsbThrow(E_UNEXPECTED);
                break;
            }
        }

        m_UnloadNowEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
        m_UnloadedEvent = CreateEvent(NULL, TRUE, TRUE, NULL);


    } WsbCatch(hr);

    s_InstanceCount++;
    WsbTraceAlways(OLESTR("CRmsDrive::s_InstanceCount += %d\n"), s_InstanceCount);

    WsbTraceOut(OLESTR("CRmsDrive::FinalConstruct"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


STDMETHODIMP
CRmsDrive::FinalRelease(void) 
{
    HRESULT hr = S_OK;

    WsbTraceIn(OLESTR("CRmsDrive::FinalRelease"), OLESTR(""));

    try {
        
        try {

            // InitializeCriticalSection raises an exception.  Delete may too.
            DeleteCriticalSection(&m_CriticalSection);

        } catch(DWORD status) {
            WsbLogEvent(status, 0, NULL, NULL);
            }

        CloseHandle(m_UnloadNowEvent);
        CloseHandle(m_UnloadedEvent);


        CWsbObject::FinalRelease();

    } WsbCatch(hr);

    s_InstanceCount--;
    WsbTraceAlways(OLESTR("CRmsDrive::s_InstanceCount -= %d\n"), s_InstanceCount);

    WsbTraceOut(OLESTR("CRmsDrive::FinalRelease"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));
    return(hr);
}


STDMETHODIMP
CRmsDrive::GetClassID(
    OUT CLSID* pClsid
    )
/*++

Implements:

    IPersist::GetClassId

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CRmsDrive::GetClassID"), OLESTR(""));

    try {

        WsbAssert(0 != pClsid, E_POINTER);

        *pClsid = CLSID_CRmsDrive;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsDrive::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return(hr);
}


STDMETHODIMP
CRmsDrive::GetSizeMax(
    OUT ULARGE_INTEGER* pcbSize
    )
/*++

Implements:

    IPersistStream::GetSizeMax

--*/
{
    HRESULT     hr = E_NOTIMPL;

    WsbTraceIn(OLESTR("CRmsDrive::GetSizeMax"), OLESTR(""));

//    try {
//        WsbAssert(0 != pcbSize, E_POINTER);

//        // Set up max size
//        pcbSize->QuadPart  = WsbPersistSizeOf(LONG);        // m_MountReference

//    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsDrive::GetSizeMax"), OLESTR("hr = <%ls>, Size = <%ls>"), WsbHrAsString(hr), WsbPtrToUliAsString(pcbSize));

    return(hr);
}


STDMETHODIMP
CRmsDrive::Load(
    IN IStream* pStream
    )
/*++

Implements:

    IPersistStream::Load

--*/
{
    HRESULT     hr = S_OK;
    ULONG       ulBytes = 0;

    WsbTraceIn(OLESTR("CRmsDrive::Load"), OLESTR(""));

    try {

        WsbAssert(0 != pStream, E_POINTER);

        WsbAffirmHr(CRmsDevice::Load(pStream));

        // Read value
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_MountReference));

        // We just reset to zero, one day we could try to reconnect to
        // the process that issued the mount...

        m_MountReference = 0;

    }
    WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsDrive::Load"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


STDMETHODIMP
CRmsDrive::Save(
    IN IStream* pStream,
    IN BOOL clearDirty
    )
/*++

Implements:

    IPersistStream::Save

--*/
{
    HRESULT     hr = S_OK;
    ULONG       ulBytes = 0;

    WsbTraceIn(OLESTR("CRmsDrive::Save"), OLESTR("clearDirty = <%ls>"), WsbBoolAsString(clearDirty));

    try {
        WsbAssert(0 != pStream, E_POINTER);

        WsbAffirmHr(CRmsDevice::Save(pStream, clearDirty));

        // Write value
        WsbAffirmHr(WsbSaveToStream(pStream, m_MountReference));


        // Do we need to clear the dirty bit?
        if (clearDirty) {
            m_isDirty = FALSE;
        }
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsDrive::Save"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


STDMETHODIMP
CRmsDrive::Test(
    OUT USHORT *pPassed,
    OUT USHORT *pFailed
    )
/*++

Implements:

    IWsbTestable::Test

--*/
{
    HRESULT                 hr = S_OK;

    CComPtr<IRmsDrive>      pDrive1;
    CComPtr<IRmsDrive>      pDrive2;

    CComPtr<IPersistFile>   pFile1;
    CComPtr<IPersistFile>   pFile2;

    LONG                    i;

    LONG                    longWork1;



    WsbTraceIn(OLESTR("CRmsDrive::Test"), OLESTR(""));

    try {
        // Get the Drive interface.
        hr = S_OK;
        try {
            WsbAssertHr(((IUnknown*) (IRmsDrive*) this)->QueryInterface(IID_IRmsDrive, (void**) &pDrive1));

            // Test All of MountReference Functions
            ResetMountReference();

            GetMountReference(&longWork1);

            if(longWork1 == 0) {
                (*pPassed)++;
            } else {
                (*pFailed)++;
            }

            for(i = 1; i < 20; i++){
                AddMountReference();

                GetMountReference(&longWork1);

                if(longWork1 == i){
                    (*pPassed)++;
                } else {
                    (*pFailed)++;
                }
            }

            for(i = 19; i == 0; i--){
                ReleaseMountReference();

                GetMountReference(&longWork1);

                if(longWork1 == i){
                    (*pPassed)++;
                } else {
                    (*pFailed)++;
                }
            }

        } WsbCatch(hr);

        // Tally up the results

        hr = S_OK;
        if (*pFailed) {
            hr = S_FALSE;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsDrive::Test"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


STDMETHODIMP
CRmsDrive::GetMountReference(
    OUT LONG *pRefs
    )
/*++

Implements:

    IRmsDrive::GetMountReference

--*/
{
    HRESULT hr = S_OK;

    WsbTraceIn(OLESTR("CRmsDrive::GetMountReference"), OLESTR(""));

    LONG refs = -999;

    try {
        WsbAssertPointer(pRefs);

        refs = m_MountReference;
        *pRefs = refs;

    } WsbCatch(hr)


    WsbTraceOut(OLESTR("CRmsDrive::GetMountReference"), OLESTR("hr = <%ls>, refs = %d"),
        WsbHrAsString(hr), refs);

    return hr;
}


STDMETHODIMP
CRmsDrive::ResetMountReference(
    void
    )
/*++

Implements:

    IRmsDrive::ResetMountReference

--*/
{
    HRESULT hr = S_OK;

    WsbTraceIn(OLESTR("CRmsDrive::ResetMountReference"), OLESTR(""));

#if RMS_CRITICAL_SECTION
    try {
        // <<<<< ENTER SINGLE THREADED SECTION
        WsbAffirmHr(Lock());

        m_MountReference = 0;
        m_isDirty = TRUE;

        WsbAffirmHr(Unlock());
        // >>>>> LEAVE SINGLE THREADED SECTION

    } WsbCatch(hr)
#else
    InterlockedExchange( &m_MountReference, 0);
    m_isDirty = TRUE;
#endif


    WsbTraceOut(OLESTR("CRmsDrive::ResetMountReference"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP
CRmsDrive::AddMountReference(
    void
    )
/*++

Implements:

    IRmsDrive::AddMountReference

--*/
{
    HRESULT hr = S_OK;

    WsbTraceIn(OLESTR("CRmsDrive::AddMountReference"), OLESTR(""));

    LONG refs = -999;

#if RMS_CRITICAL_SECTION
    try {
        // <<<<< ENTER SINGLE THREADED SECTION
        WsbAffirmHr(Lock());

        m_MountReference++;
        m_isDirty = TRUE;
        refs = m_MountReference;

        WsbAffirmStatus(ResetEvent(m_UnloadedEvent));

        WsbAffirmHr(Unlock());
        // >>>>> LEAVE SINGLE THREADED SECTION

    } WsbCatch(hr)
#else
    refs = InterlockedIncrement( &m_MountReference );
    m_isDirty = TRUE;
#endif

    WsbTraceOut(OLESTR("CRmsDrive::AddMountReference"), OLESTR("hr = <%ls>, refs = %d"),
        WsbHrAsString(hr), refs);

    return hr;
}


STDMETHODIMP
CRmsDrive::ReleaseMountReference(
    IN DWORD dwOptions
    )
/*++

Implements:

    IRmsDrive::ReleaseMountReference

--*/
{
    HRESULT hr S_OK;

    WsbTraceIn(OLESTR("CRmsDrive::ReleaseMountReference"), OLESTR("<%ld>"), dwOptions);

    // We need to be sure this object doesn't go away until we're done.
    // This happens when we dismount a NTMS managed cartridge.
    CComPtr<IRmsDrive> thisDrive = this;

    LONG refs = -999;

    BOOL bUnloadNow = 
        ( (dwOptions & RMS_DISMOUNT_IMMEDIATE) || (dwOptions & RMS_DISMOUNT_DEFERRED_ONLY) ) ? TRUE : FALSE;

    try {
#if RMS_CRITICAL_SECTION
        // <<<<< ENTER SINGLE THREADED SECTION
        WsbAffirmHr(Lock());

        m_MountReference--;
        m_isDirty = TRUE;

        refs = m_MountReference;
#else
        refs = InterlockedDecrement( &m_MountReference );
        m_isDirty = TRUE;
#endif

        // Note:
        //  Even if the caller requests immediate dismount, if the ref count is > 0,
        //  the media is not dismounted (only the ref count is decreased).
        //  This is necessary because positive ref count means that some other component
        //  is also using the media (possible for Optical). The media must be dismounted 
        //  only when this other component is done as well.

        if (refs < 0) {
            //
            // This shouldn't happen under normal conditions... if it does,
            // we quiety reset the the reference count and try to recover.
            //
            WsbLogEvent(E_UNEXPECTED, sizeof(refs), &refs, NULL);

            InterlockedExchange( &m_MountReference, 0);
            refs = 0;

            // If we don't have a cartridge in the drive, there's no point
            // in continueing.
            WsbAffirm(S_OK == IsOccupied(), E_ABORT);
        }

        if (0 == refs) {

            //
            // Deferred Dismount Logic:  We wait the specified time before
            // dismounting the media.  Each dismount request resets the dismount
            // now time.  As long as the media is actively used, it will not be
            // dismounted.
            //

            // Retrieve the DeferredDismountWaitTime parameter

            DWORD size;
            OLECHAR tmpString[256];
            DWORD waitTime = RMS_DEFAULT_DISMOUNT_WAIT_TIME;
            if (SUCCEEDED(WsbGetRegistryValueString(NULL, RMS_REGISTRY_STRING, RMS_PARAMETER_DISMOUNT_WAIT_TIME, tmpString, 256, &size))) {
                waitTime = wcstol(tmpString, NULL, 10);
                WsbTrace(OLESTR("DismountWaitTime is %d milliseconds.\n"), waitTime);
            }

            if (waitTime > 0 && !bUnloadNow) {

                // convert waitTime to 100-nanosecond units
                waitTime *= 10000;

                FILETIME now;
                GetSystemTimeAsFileTime(&now);

                ULARGE_INTEGER time;

                time.LowPart = now.dwLowDateTime;
                time.HighPart = now.dwHighDateTime;

                time.QuadPart += waitTime;

                m_UnloadNowTime.dwLowDateTime = time.LowPart;
                m_UnloadNowTime.dwHighDateTime = time.HighPart;

                WsbTrace(OLESTR("Target Unload Time = <%ls>\n"),
                    WsbQuickString(WsbFiletimeAsString(FALSE, m_UnloadNowTime)));

                // If we already have an active unload thread we skip this step.
                if (!m_UnloadThreadHandle) {

                    //
                    // Create a thread to wait for dismount
                    //

                    WsbTrace(OLESTR("Starting thread for deferred dismount.\n"));
                    DWORD threadId;
                    WsbAffirmHandle(m_UnloadThreadHandle = CreateThread(NULL, 1024, CRmsDrive::StartUnloadThread, this, 0, &threadId));
                    CloseHandle(m_UnloadThreadHandle);
                }
            }
            else {

                // Dismount the media now

                // Double check that we still have something to dismount

                if (S_OK == IsOccupied()) {

                    // Best effort - home
                    // Fixed drives are always occupied and we shouldn't call Home for their cartridge

                    FlushBuffers();
                    if (RmsDeviceFixedDisk != m_deviceType) {
                        if (S_OK == m_pCartridge->Home(dwOptions)) {
                            SetIsOccupied(FALSE);
                        }
                    }

                }

                // set event that blocks immediate unload
                SetEvent(m_UnloadedEvent);
            }
        }

#if RMS_CRITICAL_SECTION
        WsbAffirmHr(Unlock());
        // >>>>> LEAVE SINGLE THREADED SECTION

    } WsbCatchAndDo(hr,
            WsbAffirmHr(Unlock());
            // >>>>> LEAVE SINGLE THREADED SECTION
        );
#else
    } WsbCatch(hr)
#endif

    WsbTraceOut(OLESTR("CRmsDrive::ReleaseMountReference"), OLESTR("hr = <%ls>, refs = %d"),
        WsbHrAsString(hr), refs);

    return hr;
}



STDMETHODIMP
CRmsDrive::SelectForMount(
    void
    )
/*++

Implements:

    IRmsDrive::SelectForMount

--*/
{
    HRESULT hr = S_OK;

    WsbTraceIn(OLESTR("CRmsDrive::SelectForMount"), OLESTR(""));

#if RMS_CRITICAL_SECTION
    try {

        // <<<<< ENTER SINGLE THREADED SECTION
        WsbAffirmHr(Lock());

        if (!m_MountReference) {

            m_MountReference++;
            m_isDirty = TRUE;

        } else {
            hr = RMS_E_DRIVE_BUSY;
        }

        WsbAffirmHr(Unlock());
        // >>>>> LEAVE SINGLE THREADED SECTION

    } WsbCatch(hr)
#else
    LONG one = 1;
    LONG zero = 0;

    LONG flag = InterlockedCompareExchange( &m_MountReference, one, zero );

    hr = ( flag > 0 ) ? RMS_E_DRIVE_BUSY : S_OK;
#endif

    WsbTraceOut(OLESTR("CRmsDrive::SelectForMount"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP
CRmsDrive::CreateDataMover(
    IDataMover **ptr)
/*++

Implements:

    IRmsDrive::CreateDataMover

--*/
{
    HRESULT hr = S_OK;

    WsbTraceIn(OLESTR("CRmsDrive::CreateDataMover"), OLESTR(""));

    try {
        WsbAssertPointer(ptr);

        if (m_isOccupied) {

            switch (m_mediaSupported) {

            case RmsMedia8mm:
            case RmsMedia4mm:
            case RmsMediaDLT:
            case RmsMediaTape:
                {
                    //
                    // Create a tape style data mover to the drive
                    //

                    WsbAssertHr(CoCreateInstance(CLSID_CNtTapeIo, 0, CLSCTX_SERVER, IID_IDataMover, (void **)ptr));

                }
                break;

            case RmsMediaWORM:
                break;

            case RmsMediaOptical:
            case RmsMediaMO35:
            case RmsMediaCDR:
            case RmsMediaDVD:
            case RmsMediaDisk:
            case RmsMediaFixed:
                {
                    //
                    // Create a file style data mover to the drive
                    //

                    WsbAssertHr(CoCreateInstance(CLSID_CNtFileIo, 0, CLSCTX_SERVER, IID_IDataMover, (void **)ptr));

                }
                break;
            default:
                WsbThrow(E_UNEXPECTED);
                break;
            }
        }
        else {
            WsbThrow(RMS_E_RESOURCE_UNAVAILABLE);
        }

        // Initialize the data mover
        WsbAffirmHr((*ptr)->SetDeviceName(m_deviceName));
        WsbAffirmHr((*ptr)->SetCartridge(m_pCartridge));

        // Update stroage info for this cartridge.
        // 
        // IMPORTANT NOTE:  This also needs to touch the physical device
        //                  to make sure the device is ready for I/O.
        //                  If we get device errors here, we must fail the
        //                  mount.

        CComQIPtr<IRmsStorageInfo, &IID_IRmsStorageInfo> pInfo = m_pCartridge;

        // marking the FreeSpace to -1 gaurantees it's stale for the
        // following GetLargestFreeSpace() call.
        WsbAffirmHr(pInfo->SetFreeSpace(-1));
        hr = (*ptr)->GetLargestFreeSpace(NULL, NULL);
        if (MVR_E_UNRECOGNIZED_VOLUME == hr) {
            // This is expected if this is an unformatted optical media
            hr = S_OK;
        }
        WsbAffirmHr(hr);

        WsbAssertHrOk(hr);

/*

        Tracking DataMovers is only partially implemented.


        CComQIPtr<IRmsServer, &IID_IRmsServer> pServer = g_pServer;
        CComPtr<IWsbIndexedCollection> pDataMovers;
        WsbAffirmHr(pServer->GetDataMovers(&pDataMovers));
        WsbAffirmHr(pDataMovers->Add((IDataMover *)(*ptr)));
*/

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsDrive::CreateDataMover"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));


    return hr;
}


STDMETHODIMP
CRmsDrive::ReleaseDataMover(
    IN IDataMover *ptr)
/*++

Implements:

    IRmsDrive::ReleaseDataMover

--*/
{
    HRESULT hr = S_OK;

    WsbTraceIn(OLESTR("CRmsDrive::ReleaseDataMover"), OLESTR(""));

    try {
        WsbAssertPointer(ptr);
        WsbThrow(E_NOTIMPL);

/*

        Tracking DataMovers is only partially implemented.


        CComQIPtr<IRmsServer, &IID_IRmsServer> pServer = g_pServer;
        CComPtr<IWsbIndexedCollection>  pDataMovers;
        WsbAffirmHr(pServer->GetDataMovers(&pDataMovers));

        WsbAffirmHr(pDataMovers->RemoveAndRelease((IDataMover *)ptr));

        ULONG activeDataMovers;
        WsbAffirmHr(pDataMovers->GetEntries( &activeDataMovers));
        WsbTrace(OLESTR("activeDataMovers = <%u>\n"), activeDataMovers);
*/

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsDrive::ReleaseDataMover"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));


    return hr;
}

STDMETHODIMP
CRmsDrive::Eject(
    void
    )
/*++

Implements:

    IRmsDrive::Eject

--*/
{
    HRESULT hr = E_FAIL;

    WsbTraceIn(OLESTR("CRmsDrive::Eject"), OLESTR(""));

    HANDLE hDrive = INVALID_HANDLE_VALUE;

    try {

        CWsbBstrPtr drive = "";

        switch ( m_mediaSupported ) {

        case RmsMedia8mm:
        case RmsMedia4mm:
        case RmsMediaDLT:
        case RmsMediaTape:

            drive = m_deviceName;
            break;

        case RmsMediaWORM:
            break;

        case RmsMediaOptical:
        case RmsMediaMO35:
        case RmsMediaCDR:
        case RmsMediaDVD:
        case RmsMediaDisk:
        case RmsMediaFixed:

            // TODO: permanently remove trailing \ from device name ????
            WsbAffirmHr(drive.Realloc(2));
            wcsncpy(drive, m_deviceName, 2);
            drive.Prepend( OLESTR( "\\\\.\\" ) );
            break;

        }

        int retry = 0;

        do {

            hDrive = CreateFile( drive,
                                 GENERIC_READ | GENERIC_WRITE,
                                 0,
                                 0,
                                 OPEN_EXISTING,
                                 0,
                                 NULL
                                 );

            if ( INVALID_HANDLE_VALUE == hDrive )
                Sleep(2000);
            else
                break;

        } while ( retry++ < 10 );

        WsbAssertHandle( hDrive );

        DWORD dwReturn;

        WsbAffirmHr(PrepareTape(hDrive, TAPE_UNLOAD, FALSE));
        WsbAffirmHr(PrepareTape(hDrive, TAPE_UNLOCK, FALSE));

        WsbAssertStatus( DeviceIoControl( hDrive,
                                          IOCTL_STORAGE_EJECT_MEDIA,
                                          NULL,
                                          0,
                                          NULL,
                                          0,
                                          &dwReturn,
                                          NULL ));

        WsbAssertStatus( CloseHandle( hDrive ) );

        hr = S_OK;

    }
    WsbCatchAndDo( hr,
                        if ( INVALID_HANDLE_VALUE != hDrive )
                            CloseHandle( hDrive );
                 );

    WsbTraceOut(OLESTR("CRmsDrive::Eject"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));


    return hr;
}


STDMETHODIMP
CRmsDrive::GetLargestFreeSpace(
    LONGLONG *pFreeSpace,
    LONGLONG *pCapacity
    )
/*++

Implements:

    IRmsDrive::GetLargestFreeSpace

--*/
{
    HRESULT hr = S_OK;

    WsbTraceIn(OLESTR("CRmsDrive::GetLargestFreeSpace"), OLESTR(""));

    try {

        CComPtr<IDataMover> pDataMover;

        WsbAffirmHr(CreateDataMover(&pDataMover));
        WsbAffirmHr(pDataMover->GetLargestFreeSpace(pFreeSpace, pCapacity));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsDrive::GetLargestFreeSpace"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


HRESULT
CRmsDrive::UnloadNow(void)
{
    HRESULT hr = S_OK;

    WsbTraceIn(OLESTR("CRmsDrive::UnloadNow"), OLESTR(""));

    try {

        WsbAffirmHr(Lock());

        WsbAffirmStatus(SetEvent(m_UnloadNowEvent));

        WsbAffirmHr(Unlock());

        switch(WaitForSingleObject(m_UnloadedEvent, INFINITE)) {
        case WAIT_FAILED:
            hr = HRESULT_FROM_WIN32(GetLastError());
            WsbTrace(OLESTR("CRmsDrive::UnloadNow - Wait for Single Object returned error: %ls\n"),
                WsbHrAsString(hr));
            WsbAffirmHr(hr);
            break;
        case WAIT_TIMEOUT:
            WsbTrace(OLESTR("CRmsDrive::UnloadNow - Awakened by timeout.\n"));
            break;
        default:
            WsbTrace(OLESTR("CRmsDrive::UnloadNow - Awakened by external signal.\n"));
            GetSystemTimeAsFileTime(&m_UnloadNowTime);
            break;
                }

    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CRmsDrive::UnloadNow"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}



DWORD WINAPI
CRmsDrive::StartUnloadThread(
    IN LPVOID pv)
{
    return(((CRmsDrive*) pv)->Unload());
}


HRESULT
CRmsDrive::Unload(void)
{
    HRESULT hr = S_OK;

    WsbTraceIn(OLESTR("CRmsDrive::Unload"), OLESTR(""));

    // We need to be sure this object doesn't go away until we're done.
    // This happens when we dismount a NTMS managed cartridge.
    CComPtr<IRmsDrive> thisDrive = this;

    try {

        BOOL waiting = TRUE;
        LARGE_INTEGER delta = {0,0};

        while (waiting) {

            //
            // !!!!! VERY IMPORTANT !!!!
            //
            // no 'break' in this loop, we're entering
            // a critical section!
            //

#if RMS_CRITICAL_SECTION
            // <<<<< ENTER SINGLE THREADED SECTION
            WsbAffirmHr(Lock());
#endif
            WsbTrace(OLESTR("Refs = %d\n"), m_MountReference);

            if (0 == m_MountReference) {

                FILETIME now;
                GetSystemTimeAsFileTime(&now);


                ULARGE_INTEGER time0;
                ULARGE_INTEGER time1;
            
                time0.LowPart = m_UnloadNowTime.dwLowDateTime;
                time0.HighPart = m_UnloadNowTime.dwHighDateTime;

                time1.LowPart = now.dwLowDateTime;
                time1.HighPart = now.dwHighDateTime;


                // time0 is the target time for dismount.
                // When delta goes negative, we've expired our
                // wait time.
                delta.QuadPart = time0.QuadPart-time1.QuadPart;

                // convert delta to 100-ns to milliseconds
                delta.QuadPart /= 10000;

                WsbTrace(OLESTR("Time = <%ls>; Unload Time = <%ls>; delta = %I64d (ms)\n"),
                    WsbQuickString(WsbFiletimeAsString(FALSE, now)),
                    WsbQuickString(WsbFiletimeAsString(FALSE, m_UnloadNowTime)),
                    delta.QuadPart);

                if (delta.QuadPart <= 0) {

                    // Dismount wait time has expired

                    // Double check that we still have something to dismount

                    if (S_OK == IsOccupied()) {

                        // Best effort home
                        // Fixed drives are always occupied and we shouldn't call Home for their cartridge

                        FlushBuffers();
                        if (RmsDeviceFixedDisk != m_deviceType) {
                            if (S_OK == m_pCartridge->Home()) {
                                SetIsOccupied(FALSE);
                            }
                        }

                    }

                    m_UnloadThreadHandle = NULL;
                    waiting = FALSE;

                    SetEvent(m_UnloadedEvent);

                }
            }
            else {
                hr = S_FALSE;

                m_UnloadThreadHandle = NULL;
                waiting = FALSE;
            }

#if RMS_CRITICAL_SECTION
            WsbAffirmHr(Unlock());
            // >>>>> LEAVE SINGLE THREADED SECTION
#endif

            if ( waiting ) {

                switch(WaitForSingleObject(m_UnloadNowEvent, delta.LowPart)) {
                case WAIT_FAILED:
                    WsbTrace(OLESTR("CRmsDrive::Unload - Wait for Single Object returned error: %ls\n"),
                        WsbHrAsString(HRESULT_FROM_WIN32(GetLastError())));
                    break;
                case WAIT_TIMEOUT:
                    WsbTrace(OLESTR("CRmsDrive::Unload - Awakened by timeout.\n"));
                    break;
                default:
                    WsbTrace(OLESTR("CRmsDrive::Unload - Awakened by external signal.\n"));
                    GetSystemTimeAsFileTime(&m_UnloadNowTime);
                    break;
                }
            }

        } // waiting


    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsDrive::Unload"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


HRESULT
CRmsDrive::FlushBuffers( void )
/*++

Implements:

    IRmsDrive::FlushBuffers

--*/
{
    HRESULT hr S_OK;

    WsbTraceIn(OLESTR("CRmsDrive::FlushBuffers"), OLESTR("Device=<%ls>"), (WCHAR *) m_deviceName);

    HANDLE hDrive = INVALID_HANDLE_VALUE;

    try {

        // First flush system buffers

        switch (m_mediaSupported) {

        case RmsMedia8mm:
        case RmsMedia4mm:
        case RmsMediaDLT:
        case RmsMediaTape:
        case RmsMediaWORM:
            break;

        case RmsMediaOptical:
        case RmsMediaMO35:
        case RmsMediaCDR:
        case RmsMediaDVD:
        case RmsMediaDisk:
            // No need to flush for Optical media - RSM should flush the system buffers before dismounting
            break;

        case RmsMediaFixed:
            {
                // This is special code to flush the file system buffers.

                // Create an exclusive handle
                CWsbStringPtr drive;
                WsbAffirmHr(drive.Alloc(10));
                wcsncat( drive, m_deviceName, 2 );
                drive.Prepend( OLESTR( "\\\\.\\" ) );

                hDrive = CreateFile( drive,
                                     GENERIC_READ | GENERIC_WRITE,
                                     FILE_SHARE_READ | FILE_SHARE_WRITE,
                                     0,
                                     OPEN_EXISTING,
                                     0,
                                     NULL
                                     );
                WsbAffirmHandle(hDrive);

                // Flush buffers
                WsbAffirmStatus(FlushFileBuffers(hDrive));

                CloseHandle(hDrive);
                hDrive = INVALID_HANDLE_VALUE;
            }                                              
            break;

        }

    } WsbCatchAndDo(hr,
            if (INVALID_HANDLE_VALUE != hDrive) {
                CloseHandle(hDrive);
            }
        );

    WsbTraceOut(OLESTR("CRmsDrive::FlushBuffers"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


HRESULT
CRmsDrive::Lock( void )
/*++

Implements:

    IRmsDrive::Lock

--*/
{
    HRESULT hr S_OK;

    WsbTraceIn(OLESTR("CRmsDrive::Lock"), OLESTR(""));

    try {

        try {

            // InitializeCriticalSection raises an exception.  Enter/Leave may too.
            EnterCriticalSection(&m_CriticalSection);

        } catch(DWORD status) {
            WsbLogEvent(status, 0, NULL, NULL);
            WsbThrow(E_UNEXPECTED);
            }

    } WsbCatch(hr)

    WsbTraceOut(OLESTR("CRmsDrive::Lock"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


HRESULT
CRmsDrive::Unlock( void )
/*++

Implements:

    IRmsDrive::Unlock

--*/
{
    HRESULT hr S_OK;

    WsbTraceIn(OLESTR("CRmsDrive::Unlock"), OLESTR(""));

    try {

        try {

            // InitializeCriticalSection raises an exception.  Enter/Leave may too.
            LeaveCriticalSection(&m_CriticalSection);

        } catch(DWORD status) {
            WsbLogEvent(status, 0, NULL, NULL);
            WsbThrow(E_UNEXPECTED);
            }

    } WsbCatch(hr)

    WsbTraceOut(OLESTR("CRmsDrive::Unlock"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\rms\server\rmsdrcls.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    RmsDrCls.cpp

Abstract:

    Implementation of CRmsDriveClass

Author:

    Brian Dodd          [brian]         15-Nov-1996

Revision History:

--*/

#include "stdafx.h"

#include "RmsDrCls.h"

////////////////////////////////////////////////////////////////////////////////
//


STDMETHODIMP
CRmsDriveClass::CompareTo(
    IN  IUnknown    *pCollectable,
    OUT SHORT       *pResult
    )
/*++

Implements:

    IWsbCollectable::CompareTo

--*/
{
    HRESULT     hr = E_FAIL;
    SHORT       result = 1;

    WsbTraceIn( OLESTR("CRmsDriveClass::CompareTo"), OLESTR("") );

    try {

        // Validate arguments - Okay if pResult is NULL
        WsbAssertPointer( pCollectable );

        CComQIPtr<IRmsComObject, &IID_IRmsComObject> pObject = pCollectable;
        WsbAssertPointer( pObject );

        switch ( m_findBy ) {

        case RmsFindByDriveClassId:
        case RmsFindByObjectId:
        default:

            // Do CompareTo for object
            hr = CRmsComObject::CompareTo( pCollectable, &result );
            break;

        }

    }
    WsbCatch(hr);

    if ( SUCCEEDED(hr) && (0 != pResult) ){
       *pResult = result;
    }

    WsbTraceOut( OLESTR("CRmsDriveClass::CompareTo"),
                 OLESTR("hr = <%ls>, result = <%ls>"),
                 WsbHrAsString( hr ), WsbPtrToShortAsString( pResult ) );

    return hr;
}


HRESULT
CRmsDriveClass::FinalConstruct(
    void
    )
/*++

Implements:

    CComObjectRoot::FinalConstruct

--*/
{
    HRESULT     hr = S_OK;

    try {
        WsbAssertHr(CWsbObject::FinalConstruct());

        // Initialize values
        m_type   = RmsMediaUnknown;

        m_capability = RmsModeUnknown;

        m_idleTime = 0;

        m_mountWaitTime = 0;

        m_mountLimit = 0;

        m_queuedRequests = 0;

        m_unloadPauseTime = 0;

        m_driveSelectionPolicy = RmsDriveSelectUnknown;

    } WsbCatch(hr);

    return(hr);
}


STDMETHODIMP
CRmsDriveClass::GetClassID(
    OUT CLSID  *pClsid
    )
/*++

Implements:

    IPersist::GetClassId

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CRmsDriveClass::GetClassID"), OLESTR(""));

    try {

        WsbAssert(0 != pClsid, E_POINTER);

        *pClsid = CLSID_CRmsDriveClass;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsDriveClass::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return(hr);
}


STDMETHODIMP
CRmsDriveClass::GetSizeMax(
    OUT ULARGE_INTEGER  *pcbSize
    )
/*++

Implements:

    IPersistStream::GetSizeMax

--*/
{
    HRESULT     hr = E_NOTIMPL;

//    ULONG       nameLen;


    WsbTraceIn(OLESTR("CRmsDriveClass::GetSizeMax"), OLESTR(""));

//    try {
//        WsbAssert(0 != pcbSize, E_POINTER);

//        nameLen = SysStringByteLen(m_name);

//        // Get maximum size
//        pcbSize->QuadPart  = WsbPersistSizeOf(GUID)   +     // m_objectId
//                             WsbPersistSizeOf(LONG)   +     // length of m_name
//                             nameLen +                      // m_name
//                             WsbPersistSizeOf(LONG)   +     // m_type
//                             WsbPersistSizeOf(LONG)   +     // m_capability
//                             WsbPersistSizeOf(LONG)   +     // m_idleTime
//                             WsbPersistSizeOf(LONG)   +     // m_mountWaitTime
//                             WsbPersistSizeOf(LONG)   +     // m_mountLimit
//                             WsbPersistSizeOf(LONG)   +     // m_queuedRequests
//                             WsbPersistSizeOf(LONG)   +     // m_unloadPauseTime
//                             WsbPersistSizeOf(LONG);        // m_driveSelectionPolicy

////                          get m_pDrives length

//    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsDriveClass::GetSizeMax"), OLESTR("hr = <%ls>, Size = <%ls>"), WsbHrAsString(hr), WsbPtrToUliAsString(pcbSize));

    return(hr);
}


STDMETHODIMP
CRmsDriveClass::Load(
    IN IStream  *pStream
    )
/*++

Implements:

    IPersistStream::Load

--*/
{
    HRESULT     hr = S_OK;
    ULONG       ulBytes = 0;

    WsbTraceIn(OLESTR("CRmsDriveClass::Load"), OLESTR(""));

    try {
        ULONG temp;

        WsbAssert(0 != pStream, E_POINTER);

        WsbAffirmHr(CRmsComObject::Load(pStream));

        // Read value
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_objectId));

        WsbAffirmHr(WsbLoadFromStream(pStream, &temp));
        m_type = (RmsMedia)temp;

        WsbAffirmHr(WsbLoadFromStream(pStream, &temp));
        m_capability = (RmsMode)temp;

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_idleTime));

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_mountWaitTime));

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_mountLimit));

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_queuedRequests));

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_unloadPauseTime));

        WsbAffirmHr(WsbLoadFromStream(pStream, &temp));
        m_driveSelectionPolicy = (RmsDriveSelect)temp;

//      do load of m_pDrives

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsDriveClass::Load"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


STDMETHODIMP
CRmsDriveClass::Save(
    IN IStream  *pStream,
    IN BOOL     clearDirty
    )
/*++

Implements:

    IPersistStream::Save

--*/
{
    HRESULT     hr = S_OK;
    ULONG       ulBytes = 0;

    WsbTraceIn(OLESTR("CRmsDriveClass::Save"), OLESTR("clearDirty = <%ls>"), WsbBoolAsString(clearDirty));

    try {
        WsbAssert(0 != pStream, E_POINTER);

        WsbAffirmHr(CRmsComObject::Save(pStream, clearDirty));

        // Write value
        WsbAffirmHr(WsbSaveToStream(pStream, (ULONG) m_type));

        WsbAffirmHr(WsbSaveToStream(pStream, (ULONG) m_capability));

        WsbAffirmHr(WsbSaveToStream(pStream, m_idleTime));

        WsbAffirmHr(WsbSaveToStream(pStream, m_mountWaitTime));

        WsbAffirmHr(WsbSaveToStream(pStream, m_mountLimit));

        WsbAffirmHr(WsbSaveToStream(pStream, m_queuedRequests));

        WsbAffirmHr(WsbSaveToStream(pStream, m_unloadPauseTime));

        WsbAffirmHr(WsbSaveToStream(pStream, (ULONG) m_driveSelectionPolicy));

//      do load of m_pDrives


        // Do we need to clear the dirty bit?
        if (clearDirty) {
            m_isDirty = FALSE;
        }
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsDriveClass::Save"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


STDMETHODIMP
CRmsDriveClass::Test(
    OUT USHORT *pPassed,
    OUT USHORT *pFailed
    )
/*++

Implements:

    IWsbTestable::Test

--*/
{
    HRESULT                 hr = S_OK;

    CComPtr<IRmsDriveClass> pDriveClass1;
    CComPtr<IRmsDriveClass> pDriveClass2;

    CComPtr<IPersistFile>   pFile1;
    CComPtr<IPersistFile>   pFile2;

    LONG                    i;

    CWsbBstrPtr             bstrVal1 = OLESTR("5A5A5A");
    CWsbBstrPtr             bstrVal2 = OLESTR("A5A5A5");
    CWsbBstrPtr             bstrWork1;
    CWsbBstrPtr             bstrWork2;

    LONG                    longWork1;
    LONG                    longWork2;

    LONG                    mediaTable [RMSMAXMEDIATYPES] = { RmsMediaUnknown,
                                                              RmsMedia8mm,
                                                              RmsMedia4mm,
                                                              RmsMediaDLT,
                                                              RmsMediaOptical,
                                                              RmsMediaMO35,
                                                              RmsMediaWORM,
                                                              RmsMediaCDR,
                                                              RmsMediaDVD,
                                                              RmsMediaDisk,
                                                              RmsMediaFixed,
                                                              RmsMediaTape };


    WsbTraceIn(OLESTR("CRmsDriveClass::Test"), OLESTR(""));

    try {
        // Get the DriveClass interface.
        hr = S_OK;
        try {
            WsbAssertHr(((IUnknown*) (IRmsDriveClass*) this)->QueryInterface(IID_IRmsDriveClass, (void**) &pDriveClass1));

            // Test SetName & GetName interface
            bstrWork1 = bstrVal1;

            SetName(bstrWork1);

            GetName(&bstrWork2);

            if (bstrWork1 == bstrWork2){
                (*pPassed)++;
            } else {
                (*pFailed)++;
            }

            // Test SetType & GetType
            for (i = RmsMediaUnknown; i < RMSMAXMEDIATYPES; i++){

                longWork1 = mediaTable[i];

                SetType (longWork1);

                GetType (&longWork2);

                if (longWork1 == longWork2){
                    (*pPassed)++;
                } else {
                    (*pFailed)++;
                }
            }

            // Test SetCapability & GetCapability
            for (i = RmsModeUnknown; i < RmsModeWriteOnly; i++){

                longWork1 = i;

                SetCapability (longWork1);

                GetCapability (&longWork2);

                if (longWork1 == longWork2){
                    (*pPassed)++;
                } else {
                    (*pFailed)++;
                }
            }

            // Test SetIdleTime & GetIdleTime
            longWork1 = 99;

            SetIdleTime(longWork1);

            GetIdleTime(&longWork2);

            if(longWork1 == longWork2){
                (*pPassed)++;
            } else {
                (*pFailed)++;
            }

            // Test SetMountWaitTime & GetMountWaitTime
            longWork1 = 99;

            SetMountWaitTime(longWork1);

            GetMountWaitTime(&longWork2);

            if(longWork1 == longWork2){
                (*pPassed)++;
            } else {
                (*pFailed)++;
            }

            // Test SetMountLimit & GetMountLimit
            longWork1 = 99;

            SetMountLimit(longWork1);

            GetMountLimit(&longWork2);

            if(longWork1 == longWork2){
                (*pPassed)++;
            } else {
                (*pFailed)++;
            }

            // Test SetQueuedRequests & GetQueuedRequests
            longWork1 = 99;

            SetQueuedRequests(longWork1);

            GetQueuedRequests(&longWork2);

            if(longWork1 == longWork2){
                (*pPassed)++;
            } else {
                (*pFailed)++;
            }

            // Test SetUnloadPauseTime & GetUnloadPauseTime
            longWork1 = 99;

            SetUnloadPauseTime(longWork1);

            GetUnloadPauseTime(&longWork2);

            if(longWork1 == longWork2){
                (*pPassed)++;
            } else {
                (*pFailed)++;
            }

            // Test SetDriveSelectionPolicy & GetDriveSelectionPolicy
            longWork1 = 99;

            SetDriveSelectionPolicy(longWork1);

            GetDriveSelectionPolicy(&longWork2);

            if(longWork1 == longWork2){
                (*pPassed)++;
            } else {
                (*pFailed)++;
            }

        } WsbCatch(hr);

        // Tally up the results

        hr = S_OK;
        if (*pFailed) {
            hr = S_FALSE;
        }


    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsDriveClass::Test"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

STDMETHODIMP
CRmsDriveClass::GetDriveClassId(
    GUID *pDriveClassId
    )
/*++

Implements:

    IRmsDriveClass::GetDriveClassId

--*/
{
    *pDriveClassId = m_objectId;
    return S_OK;
}



STDMETHODIMP
CRmsDriveClass::GetName(
    BSTR *pName
    )
/*++

Implements:

    IRmsDriveClass::GetName

--*/
{
    WsbAssertPointer (pName);

    m_Name. CopyToBstr (pName);
    return S_OK;
}

STDMETHODIMP
CRmsDriveClass::SetName(
    BSTR name
    )
/*++

Implements:

    IRmsDriveClass::SetName

--*/
{
    m_Name = name;
    m_isDirty = TRUE;
    return S_OK;
}


STDMETHODIMP
CRmsDriveClass::GetType(
    LONG *pType
    )
/*++

Implements:

    IRmsDriveClass::GetType

--*/
{
    *pType = (LONG) m_type;
    return S_OK;
}

STDMETHODIMP
CRmsDriveClass::SetType(
    LONG type
    )
/*++

Implements:

    IRmsDriveClass::SetType

--*/
{
    m_type = (RmsMedia) type;
    m_isDirty = TRUE;
    return S_OK;
}


STDMETHODIMP
CRmsDriveClass::GetCapability(
    LONG *pCapability
    )
/*++

Implements:

    IRmsDriveClass::GetCapability

--*/
{
    *pCapability = (LONG) m_capability;
    return S_OK;
}

STDMETHODIMP
CRmsDriveClass::SetCapability(
    LONG capability
    )
/*++

Implements:

    IRmsDriveClass::SetCapability

--*/
{
    m_capability = (RmsMode) capability;
    m_isDirty = TRUE;
    return S_OK;
}


STDMETHODIMP
CRmsDriveClass::GetIdleTime(
    LONG *pTime
    )
/*++

Implements:

    IRmsDriveClass::GetIdleTime

--*/
{
    *pTime = m_idleTime;
    return S_OK;
}

STDMETHODIMP
CRmsDriveClass::SetIdleTime(
    LONG time
    )
/*++

Implements:

    IRmsDriveClass::SetIdleTime

--*/
{
    m_idleTime = time;
    m_isDirty = TRUE;
    return S_OK;
}


STDMETHODIMP
CRmsDriveClass::GetMountWaitTime(
    LONG *pTime
    )
/*++

Implements:

    IRmsDriveClass::GetMountWaittime

--*/
{
    *pTime = m_mountWaitTime;
    return S_OK;
}

STDMETHODIMP
CRmsDriveClass::SetMountWaitTime(
    LONG time
    )
/*++

Implements:

    IRmsDriveClass::SetMountWaittime

--*/
{
    m_mountWaitTime = time;
    m_isDirty = TRUE;
    return S_OK;
}


STDMETHODIMP
CRmsDriveClass::GetMountLimit(
    LONG *pLim
    )
/*++

Implements:

    IRmsDriveClass::GetMountLimit

--*/
{
    *pLim = m_mountLimit;
    return S_OK;
}

STDMETHODIMP
CRmsDriveClass::SetMountLimit(
    LONG lim
    )
/*++

Implements:

    IRmsDriveClass::SetMountLimit

--*/
{
    m_mountLimit = lim;
    m_isDirty = TRUE;
    return S_OK;
}


STDMETHODIMP
CRmsDriveClass::GetQueuedRequests(
    LONG *pReqs
    )
/*++

Implements:

    IRmsDriveClass::GetQueuedRequests

--*/
{
    *pReqs = m_queuedRequests;
    return S_OK;
}

STDMETHODIMP
CRmsDriveClass::SetQueuedRequests(
    LONG reqs
    )
/*++

Implements:

    IRmsDriveClass::SetQueuedRequests

--*/
{
    m_queuedRequests = reqs;
    m_isDirty = TRUE;
    return S_OK;
}


STDMETHODIMP
CRmsDriveClass::GetUnloadPauseTime(
    LONG *pTime
    )
/*++

Implements:

    IRmsDriveClass::GetUnloadPauseTime

--*/
{
    *pTime = m_unloadPauseTime;
    return S_OK;
}

STDMETHODIMP
CRmsDriveClass::SetUnloadPauseTime(
    LONG time
    )
/*++

Implements:

    IRmsDriveClass::SetUnloadPauseTime

--*/
{
    m_unloadPauseTime = time;
    m_isDirty = TRUE;
    return S_OK;
}


STDMETHODIMP
CRmsDriveClass::GetDriveSelectionPolicy(
    LONG *pPolicy
    )
/*++

Implements:

    IRmsDriveClass::GetDriveSelectionPolicy

--*/
{
    *pPolicy = (LONG) m_driveSelectionPolicy;
    return S_OK;
}

STDMETHODIMP
CRmsDriveClass::SetDriveSelectionPolicy(
    LONG policy
    )
/*++

Implements:

    IRmsDriveClass::SetDriveSelectionPolicy

--*/
{
    m_driveSelectionPolicy = (RmsDriveSelect) policy;
    m_isDirty = TRUE;
    return S_OK;
}


STDMETHODIMP
CRmsDriveClass::GetDrives(
    IWsbIndexedCollection** /*ptr*/
    )
/*++

Implements:

    IRmsDriveClass::GetDrives

--*/
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\rms\server\rmsdrive.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    RmsDrive.h

Abstract:

    Declaration of the CRmsDrive class

Author:

    Brian Dodd          [brian]         15-Nov-1996

Revision History:

--*/

#ifndef _RMSDRIVE_
#define _RMSDRIVE_

#include "resource.h"       // resource symbols

#include "RmsDvice.h"       // CRmsDevice

/*++

Class Name:

    CRmsDrive

Class Description:

    A CRmsDrive represents a specific data transfer device: a disk, tape,
    or optical drive.

    Each drive is member of at least one DriveClass.  The DriveClass contains
    additional properties that are associated with a Drive (See CRmsDriveClass).

--*/

class CRmsDrive :
    public CComDualImpl<IRmsDrive, &IID_IRmsDrive, &LIBID_RMSLib>,
    public CRmsDevice,          // inherits CRmsChangerElement
    public CWsbObject,          // inherits CComObjectRoot
    public CComCoClass<CRmsDrive,&CLSID_CRmsDrive>
{
public:
    CRmsDrive() {}
BEGIN_COM_MAP(CRmsDrive)
    COM_INTERFACE_ENTRY2(IDispatch, IRmsDrive)
    COM_INTERFACE_ENTRY(IRmsDrive)
    COM_INTERFACE_ENTRY(IRmsComObject)
    COM_INTERFACE_ENTRY(IRmsChangerElement)
    COM_INTERFACE_ENTRY(IRmsDevice)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IWsbCollectable)
    COM_INTERFACE_ENTRY(IWsbPersistStream)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_RmsDrive)

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);
    STDMETHOD(FinalRelease)(void);

// IPersist
public:
    STDMETHOD(GetClassID)(CLSID *pClsid);

// IPersistStream
public:
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER* pSize);
    STDMETHOD(Load)(IStream* pStream);
    STDMETHOD(Save)(IStream* pStream, BOOL clearDirty);

// IWsbCollectable
public:
    STDMETHOD(CompareTo)(IUnknown* pCollectable, SHORT* pResult);
    WSB_FROM_CWSBOBJECT;

// IWsbTestable
public:
    STDMETHOD(Test)(USHORT *pPassed, USHORT *pFailed);

// IRmsDrive
public:
    STDMETHOD(GetMountReference)( OUT LONG *pRefs );
    STDMETHOD(ResetMountReference)();
    STDMETHOD(SelectForMount)();
    STDMETHOD(AddMountReference)();
    STDMETHOD(ReleaseMountReference)(IN DWORD dwOptions = RMS_NONE);

    STDMETHOD(CreateDataMover)( OUT IDataMover **ptr );
    STDMETHOD(ReleaseDataMover)( IN IDataMover *ptr );

    STDMETHOD(Eject)(void);

    STDMETHOD(GetLargestFreeSpace)( OUT LONGLONG *freeSpace, OUT LONGLONG *capacity );

    STDMETHOD(UnloadNow)(void);

// CRmsDrive member functions
public:
    HRESULT FlushBuffers(void);
    HRESULT Unload(void);

private:

    enum {                              // Class specific constants:
                                        //
        Version = 1,                    // Class version, this should be
                                        //   incremented each time the
                                        //   the class definition changes.
        };                              //
    LONG            m_MountReference;   // A reference count for the number
                                        //   concurrent mounts for the mounted
                                        //   Cartridge.  When zero the Cartridge
                                        //   can be safely returned to it's
                                        //   storage location.

    FILETIME        m_UnloadNowTime;    // Indicates the time when the media
                                        //   should be dismounted.

    HANDLE          m_UnloadNowEvent;   // When signal the drive will unload immediately.
    HANDLE          m_UnloadedEvent;    // When signal the drive has been unloaded.

    HANDLE          m_UnloadThreadHandle; // The thread handle to the thread that unloads the drive.

    CRITICAL_SECTION m_CriticalSection; // Object sychronization support

    static int      s_InstanceCount;    // Counter of the number of object instances.

    HRESULT Lock(void);
    HRESULT Unlock(void);


// Thread routines
public:
    static DWORD WINAPI StartUnloadThread(IN LPVOID pv);

};

#endif // _RMSDRIVE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\rms\server\rmsiport.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    RmsIPort.cpp

Abstract:

    Implementation of CRmsIEPort

Author:

    Brian Dodd          [brian]         15-Nov-1996

Revision History:

--*/

#include "stdafx.h"

#include "RmsIPort.h"

////////////////////////////////////////////////////////////////////////////////
//


STDMETHODIMP
CRmsIEPort::CompareTo(
    IN  IUnknown    *pCollectable,
    OUT SHORT       *pResult
    )
/*++

Implements:

    IWsbCollectable::CompareTo

--*/
{
    HRESULT     hr = E_FAIL;
    SHORT       result = 1;

    WsbTraceIn( OLESTR("CRmsIEPort::CompareTo"), OLESTR("") );

    try {

        // Validate arguments - Okay if pResult is NULL
        WsbAssertPointer( pCollectable );

        CComQIPtr<IRmsIEPort, &IID_IRmsIEPort> pIEPort = pCollectable;
        WsbAssertPointer( pIEPort );

        CComQIPtr<IRmsComObject, &IID_IRmsComObject> pObject = pCollectable;
        WsbAssertPointer( pObject );

        switch ( m_findBy ) {

        case RmsFindByDescription:
            {

                CWsbBstrPtr description;

                // Get description to check
                WsbAffirmHr( pIEPort->GetDescription( &description ) );

                // Compare the names
                result = (SHORT)wcscmp( m_description, description );
                hr = ( 0 == result ) ? S_OK : S_FALSE;

            }
            break;

        case RmsFindByElementNumber:
        case RmsFindByMediaSupported:

            // Do CompareTo for changer element
            hr = CRmsChangerElement::CompareTo( pCollectable, &result );
            break;

        default:

            // Do CompareTo for object
            hr = CRmsComObject::CompareTo( pCollectable, &result );
            break;

        }

    }
    WsbCatch( hr );

    if ( SUCCEEDED(hr) && (0 != pResult) ){
       *pResult = result;
    }

    WsbTraceOut( OLESTR("CRmsIEPort::CompareTo"),
                 OLESTR("hr = <%ls>, result = <%ls>"),
                 WsbHrAsString( hr ), WsbPtrToShortAsString( pResult ) );

    return hr;
}


HRESULT
CRmsIEPort::FinalConstruct(
    void
    )
/*++

Implements:

    CComObjectRoot::FinalConstruct

--*/
{
    HRESULT     hr = S_OK;

    try {
        WsbAssertHr(CWsbObject::FinalConstruct());

        // Initialize
        m_description = RMS_UNDEFINED_STRING;

        m_isImport = FALSE;

        m_isExport = FALSE;

        m_waitTime = 0;

    } WsbCatch(hr);

    return(hr);
}


STDMETHODIMP
CRmsIEPort::GetClassID(
    OUT CLSID* pClsid
    )
/*++

Implements:

    IPersist::GetClassID

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CRmsIEPort::GetClassID"), OLESTR(""));

    try {

        WsbAssert(0 != pClsid, E_POINTER);

        *pClsid = CLSID_CRmsIEPort;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsIEPort::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return(hr);
}


STDMETHODIMP
CRmsIEPort::GetSizeMax(
    OUT ULARGE_INTEGER* pcbSize
    )
/*++

Implements:

    IPersistStream::GetSizeMax

--*/
{
    HRESULT     hr = E_NOTIMPL;

//    ULONG       descriptionLen;


    WsbTraceIn(OLESTR("CRmsIEPort::GetSizeMax"), OLESTR(""));

//    try {
//        WsbAssert(0 != pcbSize, E_POINTER);

//        descriptionLen = SysStringByteLen(m_description);

//        // get max size
//        pcbSize->QuadPart  = WsbPersistSizeOf(LONG)   +     // length of m_description
//                             descriptionLen           +     // m_description
//                             WsbPersistSizeOf(BOOL)   +     // m_isImport
//                             WsbPersistSizeOf(BOOL)   +     // m_isExport
//                             WsbPersistSizeOf(LONG);        // m_waitTime

//    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsIEPort::GetSizeMax"), OLESTR("hr = <%ls>, Size = <%ls>"), WsbHrAsString(hr), WsbPtrToUliAsString(pcbSize));

    return(hr);
}


STDMETHODIMP
CRmsIEPort::Load(
    IN IStream* pStream
    )
/*++

Implements:

    IPersistStream::Load

--*/
{
    HRESULT     hr = S_OK;
    ULONG       ulBytes = 0;

    WsbTraceIn(OLESTR("CRmsIEPort::Load"), OLESTR(""));

    try {

        WsbAssert(0 != pStream, E_POINTER);

        WsbAffirmHr(CRmsChangerElement::Load(pStream));

        // Read value
        WsbAffirmHr(WsbBstrFromStream(pStream, &m_description));

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_isImport));

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_isExport));

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_waitTime));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsIEPort::Load"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


STDMETHODIMP
CRmsIEPort::Save(
    IN IStream* pStream,
    IN BOOL clearDirty
    )
/*++

Implements:

    IPersistStream::Save

--*/
{
    HRESULT     hr = S_OK;
    ULONG       ulBytes = 0;

    WsbTraceIn(OLESTR("CRmsIEPort::Save"), OLESTR("clearDirty = <%ls>"), WsbBoolAsString(clearDirty));

    try {
        WsbAssert(0 != pStream, E_POINTER);

        WsbAffirmHr(CRmsChangerElement::Save(pStream, clearDirty));

        // Write value
        WsbAffirmHr(WsbBstrToStream(pStream, m_description));

        WsbAffirmHr(WsbSaveToStream(pStream, m_isImport));

        WsbAffirmHr(WsbSaveToStream(pStream, m_isExport));

        WsbAffirmHr(WsbSaveToStream(pStream, m_waitTime));

        // Do we need to clear the dirty bit?
        if (clearDirty) {
            m_isDirty = FALSE;
        }
    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsIEPort::Save"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


STDMETHODIMP
CRmsIEPort::Test(
    OUT USHORT *pPassed,
    OUT USHORT *pFailed
    )
/*++

Implements:

    IWsbTestable::Test

--*/
{
    HRESULT                 hr = S_OK;

    CComPtr<IRmsIEPort>     pIEPort1;
    CComPtr<IRmsIEPort>     pIEPort2;

    CComPtr<IPersistFile>   pFile1;
    CComPtr<IPersistFile>   pFile2;

    CWsbBstrPtr             bstrVal1 = OLESTR("5A5A5A");

    CWsbBstrPtr             bstrWork1;
    CWsbBstrPtr             bstrWork2;

    LONG                    longWork1;
    LONG                    longWork2;



    WsbTraceIn(OLESTR("CRmsIEPort::Test"), OLESTR(""));

    try {
        // Get the IEPort interface.
        hr = S_OK;
        try {
            WsbAssertHr(((IUnknown*) (IRmsIEPort*) this)->QueryInterface(IID_IRmsIEPort, (void**) &pIEPort1));

            // Test SetDescription & GetDescription interface
            bstrWork1 = bstrVal1;

            SetDescription(bstrWork1);

            GetDescription(&bstrWork2);

            if (bstrWork1 == bstrWork2){
                (*pPassed)++;
            } else {
                (*pFailed)++;
            }

            // Test SetIsImport & IsImport to TRUE
            hr = S_OK;

            try{
                WsbAffirmHr(SetIsImport (TRUE));
                WsbAffirmHr(IsImport ());
            } WsbCatch (hr);

            if (hr == S_OK){
                (*pPassed)++;
            } else {
                (*pFailed)++;
            }

            // Test SetIsImport & IsImport to FALSE
            hr = S_OK;

            try{
                WsbAffirmHr(SetIsImport (FALSE));
                WsbAffirmHr(IsImport ());
            } WsbCatch (hr);

            if (hr == S_OK){
                (*pFailed)++;
            } else {
                (*pPassed)++;
            }

            // Test SetIsExport & IsExport to TRUE
            hr = S_OK;

            try{
                WsbAffirmHr(SetIsExport (TRUE));
                WsbAffirmHr(IsExport ());
            } WsbCatch (hr);

            if (hr == S_OK){
                (*pPassed)++;
            } else {
                (*pFailed)++;
            }

            // Test SetIsExport & IsExport to FALSE
            hr = S_OK;

            try{
                WsbAffirmHr(SetIsExport (FALSE));
                WsbAffirmHr(IsExport ());
            } WsbCatch (hr);

            if (hr == S_OK){
                (*pFailed)++;
            } else {
                (*pPassed)++;
            }

            // Test SetWaitTime & GetWaitTime
            longWork1 = 99;

            SetWaitTime(longWork1);

            GetWaitTime(&longWork2);

            if(longWork1 == longWork2){
                (*pPassed)++;
            } else {
                (*pFailed)++;
            }

        } WsbCatch(hr);

        // Tally up the results

        hr = S_OK;
        if (*pFailed) {
            hr = S_FALSE;
        }


    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsIEPort::Test"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


STDMETHODIMP
CRmsIEPort::GetDescription(
    BSTR    *pDesc
    )
/*++

Implements:

    IRmsIEPort::GetDescription

--*/
{
    WsbAssertPointer (pDesc);

    m_description. CopyToBstr (pDesc);
    return S_OK;
}


STDMETHODIMP
CRmsIEPort::SetDescription(
    BSTR  desc
    )
/*++

Implements:

    IRmsIEPort::SetDescription

--*/
{
    m_description = desc;
    m_isDirty = TRUE;
    return S_OK;
}


STDMETHODIMP
CRmsIEPort::SetIsImport(
    BOOL    flag
    )
/*++

Implements:

    IRmsIEPort::SetIsImport

--*/
{
    m_isImport = flag;
    m_isDirty = TRUE;
    return S_OK;
}


STDMETHODIMP
CRmsIEPort::IsImport(
    void
    )
/*++

Implements:

    IRmsIEPort::IsImport

--*/
{
    HRESULT    hr = S_FALSE;

    if (m_isImport){
    hr = S_OK;
    }

    return (hr);
}


STDMETHODIMP
CRmsIEPort::SetIsExport(
    BOOL    flag
    )
/*++

Implements:

    IRmsIEPort::SetIsExport

--*/
{
    m_isExport = flag;
    m_isDirty = TRUE;
    return S_OK;
}


STDMETHODIMP
CRmsIEPort::IsExport(
    void
    )
/*++

Implements:

    IRmsIEPort::IsExport

--*/
{
    HRESULT    hr = S_FALSE;

    if (m_isExport){
    hr = S_OK;
    }

    return (hr);
}


STDMETHODIMP
CRmsIEPort::GetWaitTime(
    LONG    *pTime
    )
/*++

Implements:

    IRmsIEPort::GetWaitTime

--*/
{
    *pTime = m_waitTime;
    return S_OK;
}


STDMETHODIMP
CRmsIEPort::SetWaitTime(
    LONG    time
    )
/*++

Implements:

    IRmsIEPort::SetWaitTime

--*/
{
    m_waitTime = time;
    m_isDirty = TRUE;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\rms\server\rmsdvice.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    RmsDvice.cpp

Abstract:

    Implementation of CRmsDevice

Author:

    Brian Dodd          [brian]         15-Nov-1996

Revision History:

--*/

#include "stdafx.h"

#include "RmsDvice.h"

/////////////////////////////////////////////////////////////////////////////
//
// IRmsDevice implementation
//


CRmsDevice::CRmsDevice(
    void
    )
/*++

Routine Description:

    CRmsDevice constructor

Arguments:

    None

Return Value:

    None

--*/
{

    // Initialize values
    m_deviceName = RMS_UNDEFINED_STRING;

    m_deviceType = RmsDeviceUnknown;

    m_sizeofDeviceInfo = 0;

    memset(m_deviceInfo, 0, MaxInfo);

    m_port = 0xff;

    m_bus = 0xff;

    m_targetId = 0xff;

    m_lun = 0xff;

}


HRESULT
CRmsDevice::CompareTo(
    IN  IUnknown    *pCollectable,
    OUT SHORT       *pResult
    )
/*++

Implements:

    CRmsDevice::CompareTo

--*/
{
    HRESULT     hr = E_FAIL;
    SHORT       result = 1;

    WsbTraceIn( OLESTR("CRmsDevice::CompareTo"), OLESTR("") );

    try {

        // Validate arguments - Okay if pResult is NULL
        WsbAssertPointer( pCollectable );

        CComQIPtr<IRmsDevice, &IID_IRmsDevice> pDevice = pCollectable;
        WsbAssertPointer( pDevice );

        CComQIPtr<IRmsComObject, &IID_IRmsComObject> pObject = pCollectable;
        WsbAssertPointer( pObject );

        switch ( m_findBy ) {

        case RmsFindByDeviceInfo:
            {
                //
                // What we really want to do here is compare by
                // a unique device identifier like a serial number.
                //
                // However, since we don't have a serial number for
                // all devices, we'll compare using a best effort
                // strategy using for following criteria:
                //
                // 1) DeviceName, this is unique for fixed drives and
                //    floppy drives, and SCSI devices, but may not
                //    survive accross reboot, and may not be the same
                //    for a device if it's SCSI address is changed.
                //
                //    NOTE: We can't tell if the address was changed
                //          a device.
                //
                //    NOTE: We can't tell if the drive letter was
                //          changed for a fixed drive.
                //
                //  TODO: Add serial number support.
                //

                CWsbBstrPtr name;

                // Get the target device name
                pDevice->GetDeviceName( &name );

                // Compare the names
                result = (SHORT)wcscmp( m_deviceName, name );
                hr = ( 0 == result ) ? S_OK : S_FALSE;

            }
            break;

        case RmsFindByDeviceAddress:
            {

                BYTE port, bus, targetId, lun;

                // Get the target device address
                pDevice->GetDeviceAddress(&port, &bus, &targetId, &lun);

                if( (m_port == port) &&
                    (m_bus  == bus) &&
                    (m_targetId   == targetId) &&
                    (m_lun  == lun)                 ) {

                    // Device addresses match
                    hr = S_OK;
                    result = 0;

                }
                else {
                    hr = S_FALSE;
                    result = 1;
                }

            }
            break;

        case RmsFindByDeviceName:
            {

                CWsbBstrPtr name;

                // Get the target device name
                pDevice->GetDeviceName( &name );

                // Compare the names
                result = (SHORT)wcscmp( m_deviceName, name );
                hr = ( 0 == result ) ? S_OK : S_FALSE;

            }
            break;

        case RmsFindByDeviceType:
            {

                RmsDevice type;

                // Get the target device name
                pDevice->GetDeviceType( (LONG *) &type );

                if ( m_deviceType == type ) {

                    // Device types match
                    hr = S_OK;
                    result = 0;

                }
                else {
                    hr = S_FALSE;
                    result = 1;
                }

            }
            break;

        default:

            //
            // Since devices aren't CWsbCollectables, we should
            // never come here.  CRmsDrive, or CRmsChanger will
            // handle the default case.
            //

            WsbAssertHr( E_UNEXPECTED );
            break;
        }

    }
    WsbCatch(hr);

    if (0 != pResult) {
       *pResult = result;
    }

    WsbTraceOut(OLESTR("CRmsDevice::CompareTo"), OLESTR("hr = <%ls>, result = <%ls>"), WsbHrAsString(hr), WsbPtrToShortAsString(pResult));

    return(hr);
}


HRESULT
CRmsDevice::GetSizeMax(
    OUT ULARGE_INTEGER* pcbSize
    )
/*++

Implements:

    IPersistStream::GetSizeMax

--*/
{
    HRESULT     hr = E_NOTIMPL;

//    ULONG       deviceNameLen;

    WsbTraceIn(OLESTR("CRmsDevice::GetSizeMax"), OLESTR(""));

//    try {
//        WsbAssert(0 != pcbSize, E_POINTER);

//        deviceNameLen = SysStringByteLen(m_deviceName);

//        // Get max size
//        pcbSize->QuadPart  = WsbPersistSizeOf(LONG)  +      // length of m_deviceName
//                             deviceNameLen           +      // m_deviceName
//                             WsbPersistSizeOf(LONG)  +      // m_deviceType
//                             WsbPersistSizeOf(SHORT) +      // m_sizeOfDeviceInfo
//                             MaxInfo                 +      // m_deviceInfo
//                             WsbPersistSizeOf(BYTE)  +      // m_port
//                             WsbPersistSizeOf(BYTE)  +      // m_bus
//                             WsbPersistSizeOf(BYTE)  +      // m_targetId
//                             WsbPersistSizeOf(BYTE);        // m_lun

//    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsDevice::GetSizeMax"), OLESTR("hr = <%ls>, Size = <%ls>"), WsbHrAsString(hr), WsbPtrToUliAsString(pcbSize));

    return(hr);
}


HRESULT
CRmsDevice::Load(
    IN IStream* pStream
    )
/*++

Implements:

    IPersistStream::Load

--*/
{
    HRESULT     hr = S_OK;
    ULONG       ulBytes = 0;

    WsbTraceIn(OLESTR("CRmsDevice::Load"), OLESTR(""));

    try {
        ULONG temp;

        WsbAssert(0 != pStream, E_POINTER);

        WsbAffirmHr(CRmsChangerElement::Load(pStream));

        // Read value
        m_deviceName.Free();
        WsbAffirmHr(WsbBstrFromStream(pStream, &m_deviceName));

        WsbAffirmHr(WsbLoadFromStream(pStream, &temp));
        m_deviceType = (RmsDevice)temp;

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_sizeofDeviceInfo));

        WsbAffirmHr(WsbLoadFromStream(pStream, &(m_deviceInfo [0]), MaxInfo));

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_port));

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_bus));

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_targetId));

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_lun));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsDevice::Load"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CRmsDevice::Save(
    IN IStream* pStream,
    IN BOOL clearDirty
    )
/*++

Implements:

    IPersistStream::Save

--*/
{
    HRESULT     hr = S_OK;
    ULONG       ulBytes = 0;

    WsbTraceIn(OLESTR("CRmsDevice::Save"), OLESTR("clearDirty = <%ls>"), WsbBoolAsString(clearDirty));

    try {
        WsbAssert(0 != pStream, E_POINTER);

        WsbAffirmHr(CRmsChangerElement::Save(pStream, clearDirty));

        // Write value
        WsbAffirmHr(WsbBstrToStream(pStream, m_deviceName));

        WsbAffirmHr(WsbSaveToStream(pStream, (ULONG) m_deviceType));

        WsbAffirmHr(WsbSaveToStream(pStream, m_sizeofDeviceInfo));

        WsbAffirmHr(WsbSaveToStream(pStream, &(m_deviceInfo [0]), MaxInfo));

        WsbAffirmHr(WsbSaveToStream(pStream, m_port));

        WsbAffirmHr(WsbSaveToStream(pStream, m_bus));

        WsbAffirmHr(WsbSaveToStream(pStream, m_targetId));

        WsbAffirmHr(WsbSaveToStream(pStream, m_lun));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsDevice::Save"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CRmsDevice::Test(
    OUT USHORT *pPassed,
    OUT USHORT *pFailed
    )
/*++

Implements:

    IWsbTestable::Test

--*/
{
    HRESULT                 hr = S_OK;

    CComPtr<IRmsMediaSet>   pMediaSet1;
    CComPtr<IRmsMediaSet>   pMediaSet2;

    CComPtr<IPersistFile>   pFile1;
    CComPtr<IPersistFile>   pFile2;

    LONG                    i;

    LONG                    passfail = TRUE;

    CWsbBstrPtr             bstrVal1 = OLESTR("5A5A5A");
    CWsbBstrPtr             bstrWork1;
    CWsbBstrPtr             bstrWork2;

    SHORT                   ucharLenVal1 = 10;
    UCHAR                   ucharVal1[MaxInfo] = {1,2,3,4,5,6,7,8,9,10};

    SHORT                   ucharLenWork1;
    UCHAR                   ucharWork1[MaxInfo];

    BYTE                    byteVal1 = 1;
    BYTE                    byteVal2 = 2;
    BYTE                    byteVal3 = 3;
    BYTE                    byteVal4 = 4;

    BYTE                    byteWork1;
    BYTE                    byteWork2;
    BYTE                    byteWork3;
    BYTE                    byteWork4;


    WsbTraceIn(OLESTR("CRmsDevice::Test"), OLESTR(""));

    try {
        // Get the MediaSet interface.
        hr = S_OK;
        try {
            WsbAssertHr(((IUnknown*) (IRmsMediaSet*) this)->QueryInterface(IID_IRmsMediaSet, (void**) &pMediaSet1));

            // Test SetDeviceName & GetDeviceName interface
            bstrWork1 = bstrVal1;

            SetDeviceName(bstrWork1);

            GetDeviceName(&bstrWork2);

            if (bstrWork1 == bstrWork2){
                (*pPassed)++;
            } else {
                (*pFailed)++;
            }

            // Test SetDeviceInfo & GetDeviceInfo interface
            SetDeviceInfo(ucharVal1, ucharLenVal1);

            GetDeviceInfo(ucharWork1, &ucharLenWork1);

            if (ucharLenVal1 == ucharLenWork1){
                (*pPassed)++;
            } else {
                (*pFailed)++;
            }

            passfail = TRUE;

            for(i = 0; i < ucharLenVal1; i++){
                if(ucharVal1[i] != ucharWork1[i]){
                    passfail = FALSE;
                    break;
                }
            }

            if (passfail == TRUE){
                (*pPassed)++;
            } else {
                (*pFailed)++;
            }

            // Test SetDeviceAddress & GetDeviceAddress
            SetDeviceAddress(byteVal1, byteVal2, byteVal3, byteVal4);

            GetDeviceAddress(&byteWork1, &byteWork2, &byteWork3, &byteWork4);

            if ((byteVal1 == byteWork1) &&
                (byteVal2 == byteWork2) &&
                (byteVal3 == byteWork3) &&
                (byteVal4 == byteWork4)){
                (*pPassed)++;
            } else {
                (*pFailed)++;
            }

        } WsbCatch(hr);

        // Tally up the results

        hr = S_OK;

        if (*pFailed) {
            hr = S_FALSE;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsDevice::Test"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


STDMETHODIMP
CRmsDevice::GetDeviceName(
    BSTR *pName
    )
/*++

Implements:

    IRmsDevice::GetDeviceName

--*/
{
    WsbAssertPointer (pName);

    m_deviceName. CopyToBstr (pName);
    return S_OK;
}


STDMETHODIMP
CRmsDevice::SetDeviceName(
    BSTR name
    )
/*++

Implements:

    IRmsDevice::SetDeviceName

--*/
{
    m_deviceName = name;
//  m_isDirty = TRUE;
    return S_OK;
}


STDMETHODIMP
CRmsDevice::GetDeviceType(
    LONG *pType
    )
/*++

Implements:

    IRmsDevice::GetDeviceType

--*/
{
    *pType = m_deviceType;
    return S_OK;
}


STDMETHODIMP
CRmsDevice::SetDeviceType(
    LONG type
    )
/*++

Implements:

    IRmsDevice::SetDeviceType

--*/
{
    m_deviceType = (RmsDevice)type;
//  m_isDirty = TRUE;
    return S_OK;
}


STDMETHODIMP
CRmsDevice::GetDeviceInfo(
    UCHAR   *pId,
    SHORT   *pSize
    )
/*++

Implements:

    IRmsDevice::GetDeviceInfo

--*/
{
    memmove (pId, m_deviceInfo, m_sizeofDeviceInfo);
    *pSize = m_sizeofDeviceInfo;
    return S_OK;
}


STDMETHODIMP
CRmsDevice::SetDeviceInfo(
    UCHAR   *pId,
    SHORT   size
    )
/*++

Implements:

    IRmsDevice::SetDeviceInfo

--*/
{
    memmove (m_deviceInfo, pId, size);
    m_sizeofDeviceInfo = size;
//  m_isDirty = TRUE;
    return S_OK;
}


STDMETHODIMP
CRmsDevice::GetDeviceAddress(
    LPBYTE  pPort,
    LPBYTE  pBus,
    LPBYTE  pId,
    LPBYTE  pLun
    )
/*++

Implements:

    IRmsDevice::GetDeviceAddress

--*/
{
    *pPort = m_port;
    *pBus  = m_bus;
    *pId   = m_targetId;
    *pLun  = m_lun;
    return S_OK;
}


STDMETHODIMP
CRmsDevice::SetDeviceAddress(
    BYTE    port,
    BYTE    bus,
    BYTE    id,
    BYTE    lun
    )
/*++

Implements:

    IRmsDevice::SetDeviceAddress

--*/
{
    m_port          = port;
    m_bus           = bus;
    m_targetId      = id;
    m_lun           = lun;

//  m_isDirty = TRUE;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\rms\server\rmsdvice.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    RmsDvice.h

Abstract:

    Declaration of the CRmsDevice class

Author:

    Brian Dodd          [brian]         15-Nov-1996

Revision History:

--*/

#ifndef _RMSDVICE_
#define _RMSDVICE_

#include "resource.h"       // resource symbols

#include "RmsCElmt.h"       // CRmsChangerElement

/*++

Class Name:

    CRmsDevice

Class Description:

    A CRmsDevice represents a physical device connected to a SCSI bus.

--*/

class CRmsDevice :
    public CComDualImpl<IRmsDevice, &IID_IRmsDevice, &LIBID_RMSLib>,
    public CRmsChangerElement   // inherits CRmsComObject
{
public:
    CRmsDevice();

// CRmsDevice
public:

    HRESULT GetSizeMax( ULARGE_INTEGER* pSize );
    HRESULT Load( IStream* pStream );
    HRESULT Save( IStream* pStream, BOOL clearDirty );

    HRESULT CompareTo( IUnknown* pCollectable, SHORT* pResult);

    HRESULT Test( USHORT *pPassed, USHORT *pFailed );

// IRmsDevice
public:

    STDMETHOD( GetDeviceName )( BSTR *pName );
    STDMETHOD( SetDeviceName )( BSTR name );

    STDMETHOD( GetDeviceInfo )( UCHAR *pId, SHORT *pSize );
    STDMETHOD( SetDeviceInfo )( UCHAR *pId, SHORT size );

    STDMETHOD( GetDeviceType )( LONG *pType );
    STDMETHOD( SetDeviceType )( LONG type );

    //STDMETHOD( GetVendorId )( BSTR *pVendorId);
    //STDMETHOD( GetProductId )( BSTR *pProductId);
    //STDMETHOD( GetFirmwareLevel )( BSTR *pFirmwareLevel);
    //STDMETHOD( GetSerialNumber )( UCHAR *pNo, SHORT *pSize );

    STDMETHOD( GetDeviceAddress )( BYTE *pPort, BYTE *pBus, BYTE *pId, BYTE *pLun );
    STDMETHOD( SetDeviceAddress )( BYTE port, BYTE bus, BYTE id, BYTE lun );

protected:
    enum {                                  // Class specific constants:
                                            //
        Version = 1,                        // Class version, this should be
                                            //   incremented each time the
                                            //   the class definition changes.
        MaxInfo = 36                        // Max size of the device identifier.
        };                                  //
    CWsbBstrPtr     m_deviceName;           // The name used to create a handle to
                                            //   the device.
    RmsDevice       m_deviceType;           // The device type that best describes
                                            //   the device.  Some devices are multi-
                                            //   function.
    SHORT           m_sizeofDeviceInfo;     // The size of valid data in the
                                            //   device information buffer.
    UCHAR           m_deviceInfo[MaxInfo];  // An array of bytes which can uniquely
                                            //   identify the device.  Usually
                                            //   this information is returned
                                            //   directly by the device and
                                            //   represents SCSI inquiry information.
//    CWsbBstrPtr     m_SerialNumber;         // The serial number obtained directly
//                                            //   from the device.
    BYTE            m_port;                 // Adapter port number.
    BYTE            m_bus;                  // The path/bus id; the bus number on
                                            //   the port.
    BYTE            m_targetId;             // Target ID.
    BYTE            m_lun;                  // Logical unit number.
};

#endif // _RMSDVICE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\rms\server\rmslibry.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    RmsLibry.cpp

Abstract:

    Implementation of CRmsLibrary

Author:

    Brian Dodd          [brian]         15-Nov-1996

Revision History:

--*/

#include "stdafx.h"

#include "RmsLibry.h"
#include "RmsServr.h"

//////////////////////////////////////////////////////////////////////////////////


STDMETHODIMP
CRmsLibrary::CompareTo(
    IN  IUnknown    *pCollectable,
    OUT SHORT       *pResult
    )
/*++

Implements:

    IWsbCollectable::CompareTo

--*/
{
    HRESULT     hr = E_FAIL;
    SHORT       result = 1;

    WsbTraceIn( OLESTR("CRmsLibrary::CompareTo"), OLESTR("") );

    try {

        // Validate arguments - Okay if pResult is NULL
        WsbAssertPointer( pCollectable );

        // We need the IRmsLibrary interface to get the value of the object.
        CComQIPtr<IRmsLibrary, &IID_IRmsLibrary> pLibrary = pCollectable;
        WsbAssertPointer( pLibrary );

        CComQIPtr<IRmsComObject, &IID_IRmsComObject> pObject = pCollectable;
        WsbAssertPointer( pObject );

        switch ( m_findBy ) {

        case RmsFindByName:
            {

                CWsbBstrPtr name;

                // Get the target device name
                pLibrary->GetName( &name );

                // Compare the names
                result = (SHORT)wcscmp( m_Name, name );
                hr = ( 0 == result ) ? S_OK : S_FALSE;

            }
            break;

        case RmsFindByMediaSupported:
            {

                RmsMedia mediaSupported;

                WsbAffirmHr(pLibrary->GetMediaSupported((LONG*) &mediaSupported));

                if( m_mediaSupported == mediaSupported ){

                    // media types supported match
                    hr = S_OK;
                    result = 0;

                }
                else{

                    hr = S_FALSE;
                    result = 1;

                }

            }
            break;

        case RmsFindByDeviceInfo:
            {

                //
                // We're looking for a device in a library.
                // The template has one changer device OR one drive device.
                //

                try {

                    WsbAssertHr( E_UNEXPECTED );  // Dead code now

                    if ( m_maxDrives > 0 ) {

                        CComPtr<IWsbEnum>               pEnumDrives;

                        CComPtr<IWsbIndexedCollection>  pFindDrives;
                        CComPtr<IRmsMediumChanger>      pFindDrive;
                        CComPtr<IWsbIndexedCollection>  pDrives;

                        WsbAffirmHr( pLibrary->GetDrives( &pDrives ) );
                        WsbAssertPointer( pDrives );

                        WsbAffirmHr( m_pDrives->Enum( &pEnumDrives ) );
                        WsbAssertPointer( pEnumDrives );
                        WsbAssertHr( pEnumDrives->First( IID_IRmsDrive, (void **)&pFindDrive ) );
                        WsbAssertPointer( pFindDrive );
                        hr = pDrives->Contains( pFindDrive );
                        result = (SHORT) ( ( S_OK == hr ) ? 0 : 1 );

                    }
                    else if ( m_maxChangers > 0 ) {

                        CComPtr<IWsbEnum>               pEnumChangers;

                        CComPtr<IWsbIndexedCollection>  pFindChangers;
                        CComPtr<IRmsMediumChanger>      pFindChanger;
                        CComPtr<IWsbIndexedCollection>  pChangers;

                        WsbAffirmHr( pLibrary->GetChangers( &pChangers ) );
                        WsbAssertPointer( pChangers );

                        WsbAffirmHr( m_pChangers->Enum( &pEnumChangers ) );
                        WsbAssertPointer( pEnumChangers );
                        WsbAssertHr( pEnumChangers->First( IID_IRmsMediumChanger, (void **)&pFindChanger ) );
                        WsbAssertPointer( pFindChanger );
                        hr = pChangers->Contains( pFindChanger );
                        result = (SHORT)( ( S_OK == hr ) ? 0 : 1 );

                    }
                    else {

                        // has to be one or the other
                        WsbAssertHr( E_UNEXPECTED );

                    }

                }
                WsbCatch( hr );

            }
            break;

        default:

            // Do CompareTo for object
            hr = CRmsComObject::CompareTo( pCollectable, &result );
            break;

        }

    }
    WsbCatch( hr );

    if ( SUCCEEDED(hr) && (0 != pResult) ){
       *pResult = result;
    }

    WsbTraceOut( OLESTR("CRmsLibrary::CompareTo"),
                 OLESTR("hr = <%ls>, result = <%ls>"),
                 WsbHrAsString( hr ), WsbPtrToShortAsString( pResult ) );

    return hr;
}


HRESULT
CRmsLibrary::FinalConstruct(
    void
    )
/*++

Implements:

    CComObjectRoot::FinalConstruct

--*/
{
    HRESULT     hr = S_OK;

    try {
        WsbAssertHr(CWsbObject::FinalConstruct());

        m_mediaSupported = RmsMediaUnknown;

        m_maxChangers = 0;

        m_maxDrives = 0;

        m_maxPorts = 0;

        m_maxSlots = 0;

        m_NumUsedSlots = 0;

        m_NumStagingSlots = 0;

        m_NumScratchCarts = 0;

        m_NumUnknownCarts = 0;

        m_isMagazineSupported = FALSE;

        m_maxCleaningMounts = 0;

        WsbAssertHr(CoCreateInstance( CLSID_CWsbOrderedCollection,
                                      0,
                                      CLSCTX_SERVER,
                                      IID_IWsbIndexedCollection,
                                      (void **)&m_pChangers ));

        WsbAssertHr(CoCreateInstance( CLSID_CWsbOrderedCollection,
                                      0,
                                      CLSCTX_SERVER,
                                      IID_IWsbIndexedCollection,
                                      (void **)&m_pDriveClasses ));

        WsbAssertHr(CoCreateInstance( CLSID_CWsbOrderedCollection,
                                      0,
                                      CLSCTX_SERVER,
                                      IID_IWsbIndexedCollection,
                                      (void **)&m_pDrives ));

        WsbAssertHr(CoCreateInstance( CLSID_CWsbOrderedCollection,
                                      0,
                                      CLSCTX_SERVER,
                                      IID_IWsbIndexedCollection,
                                      (void **)&m_pStorageSlots ));

        WsbAssertHr(CoCreateInstance( CLSID_CWsbOrderedCollection,
                                      0,
                                      CLSCTX_SERVER,
                                      IID_IWsbIndexedCollection,
                                      (void **)&m_pStagingSlots ));

        WsbAssertHr(CoCreateInstance( CLSID_CWsbOrderedCollection,
                                      0,
                                      CLSCTX_SERVER,
                                      IID_IWsbIndexedCollection,
                                      (void **)&m_pPorts ));

        WsbAssertHr(CoCreateInstance( CLSID_CWsbOrderedCollection,
                                      0,
                                      CLSCTX_SERVER,
                                      IID_IWsbIndexedCollection,
                                      (void **)&m_pCleaningCartridges ));

        WsbAssertHr(CoCreateInstance( CLSID_CWsbOrderedCollection,
                                      0,
                                      CLSCTX_SERVER,
                                      IID_IWsbIndexedCollection,
                                      (void **)&m_pScratchCartridges ));

        WsbAssertHr(CoCreateInstance( CLSID_CWsbOrderedCollection,
                                      0,
                                      CLSCTX_SERVER,
                                      IID_IWsbIndexedCollection,
                                      (void **)&m_pMediaSets ));


    } WsbCatch(hr);

    return(hr);
}


STDMETHODIMP
CRmsLibrary::GetClassID(
    OUT CLSID* pClsid
    )
/*++

Implements:

    IPersist::GetClassId

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CRmsLibrary::GetClassID"), OLESTR(""));

    try {

        WsbAssert(0 != pClsid, E_POINTER);

        *pClsid = CLSID_CRmsLibrary;

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsLibrary::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return(hr);
}


STDMETHODIMP
CRmsLibrary::GetSizeMax(
    OUT ULARGE_INTEGER* pcbSize
    )
/*++

Implements:

    IPersistStream::GetSizeMax

--*/
{
    HRESULT     hr = E_NOTIMPL;

//    ULONG       nameLen;

    WsbTraceIn(OLESTR("CRmsLibrary::GetSizeMax"), OLESTR(""));

//    try {
//        WsbAssert(0 != pcbSize, E_POINTER);

//        // Get max size
//        nameLen = SysStringByteLen(m_name);

//        pcbSize->QuadPart  = WsbPersistSizeOf(GUID) +       // m_objectId
//                             WsbPersistSizeOf(LONG) +       // m_name length
//                             nameLen +                      // m_name data
//                             WsbPersistSizeOf(LONG) +       // m_mediaSupported
//                             WsbPersistSizeOf(LONG) +       // m_maxChangers
//                             WsbPersistSizeOf(LONG) +       // m_maxDrives
//                             WsbPersistSizeOf(LONG) +       // m_maxPorts
//                             WsbPersistSizeOf(LONG) +       // m_maxSlots
//                             WsbPersistSizeOf(LONG) +       // m_NumUsedSlots
//                             WsbPersistSizeOf(LONG) +       // m_NumStagingSlots
//                             WsbPersistSizeOf(LONG) +       // m_NumScratchCarts
//                             WsbPersistSizeOf(LONG) +       // m_NumUnknownCarts
//                             WsbPersistSizeOf(LONG) +       // m_isMagazineSupported
//                             WsbPersistSizeOf(LONG) +       // m_maxCleaningMounts
//                             WsbPersistSizeOf(LONG);        // m_slotSelectionPolicy

//    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsLibrary::GetSizeMax"), OLESTR("hr = <%ls>, Size = <%ls>"), WsbHrAsString(hr), WsbPtrToUliAsString(pcbSize));

    return(hr);
}


STDMETHODIMP
CRmsLibrary::Load(
    IN IStream* pStream
    )
/*++

Implements:

    IPersistStream::Load

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CRmsLibrary::Load"), OLESTR(""));

    try {
        CComPtr<IPersistStream>   pPersistStream;
        CComQIPtr<IRmsServer, &IID_IRmsServer> pServer = g_pServer;
        ULONG temp;

        WsbAssert(0 != pStream, E_POINTER);

        WsbAffirmHr(CRmsComObject::Load(pStream));

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_objectId));

        WsbAffirmHr(WsbLoadFromStream(pStream, &temp));
        m_mediaSupported = (RmsMedia)temp;

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_maxChangers));

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_maxDrives));

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_maxPorts));

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_maxSlots));

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_NumUsedSlots));

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_NumStagingSlots));

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_NumScratchCarts));

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_NumUnknownCarts));

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_isMagazineSupported));

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_maxCleaningMounts));

        WsbAffirmHr(WsbLoadFromStream(pStream, &temp));
        m_slotSelectionPolicy = (RmsSlotSelect)temp;

        WsbAffirmHr(m_pChangers->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
        WsbAffirmHr(pPersistStream->Load(pStream));
        pPersistStream = 0;

        WsbAffirmHr(m_pDriveClasses->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
        WsbAffirmHr(pPersistStream->Load(pStream));
        pPersistStream = 0;

        WsbAffirmHr(m_pDrives->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
        WsbAffirmHr(pPersistStream->Load(pStream));
        pPersistStream = 0;

        WsbAffirmHr(m_pStorageSlots->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
        WsbAffirmHr(pPersistStream->Load(pStream));
        pPersistStream = 0;

        WsbAffirmHr(m_pStagingSlots->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
        WsbAffirmHr(pPersistStream->Load(pStream));
        pPersistStream = 0;

        WsbAffirmHr(m_pPorts->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
        WsbAffirmHr(pPersistStream->Load(pStream));
        pPersistStream = 0;

        WsbAffirmHr(m_pCleaningCartridges->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
        WsbAffirmHr(pPersistStream->Load(pStream));
        pPersistStream = 0;

        WsbAffirmHr(m_pScratchCartridges->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
        WsbAffirmHr(pPersistStream->Load(pStream));
        pPersistStream = 0;

        GUID mediaSetId;
        CComPtr<IRmsMediaSet> pMediaSet;

        WsbAffirmHr( WsbLoadFromStream(pStream, &mediaSetId) );

        while ( 0 != memcmp(&GUID_NULL, &mediaSetId, sizeof(GUID))) {
            hr = pServer->CreateObject( mediaSetId, CLSID_CRmsMediaSet, IID_IRmsMediaSet, RmsOpenExisting, (void **)&pMediaSet );
            if (S_OK == hr) {

                WsbAffirmHr( m_pMediaSets->Add( pMediaSet ) );

            } else if (RMS_E_NOT_FOUND == hr) {
                WsbThrow(hr);
            } else {
                WsbThrow(hr);
            }
            WsbAffirmHr( WsbLoadFromStream(pStream, &mediaSetId) );
        }

    }
    WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsLibrary::Load"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP
CRmsLibrary::Save(
    IN IStream* pStream,
    IN BOOL clearDirty
    )
/*++

Implements:

    IPersistStream::Save

--*/
{
    HRESULT     hr = S_OK;

    WsbTraceIn(OLESTR("CRmsLibrary::Save"), OLESTR("clearDirty = <%ls>"), WsbBoolAsString(clearDirty));

    try {
        CComPtr<IPersistStream>   pPersistStream;

        WsbAssertPointer( pStream );

        WsbAffirmHr(CRmsComObject::Save(pStream, clearDirty));

        WsbAffirmHr(WsbSaveToStream(pStream, m_objectId));

        WsbAffirmHr(WsbSaveToStream(pStream, (ULONG) m_mediaSupported));

        WsbAffirmHr(WsbSaveToStream(pStream, m_maxChangers));

        WsbAffirmHr(WsbSaveToStream(pStream, m_maxDrives));

        WsbAffirmHr(WsbSaveToStream(pStream, m_maxPorts));

        WsbAffirmHr(WsbSaveToStream(pStream, m_maxSlots));

        WsbAffirmHr(WsbSaveToStream(pStream, m_NumUsedSlots));

        WsbAffirmHr(WsbSaveToStream(pStream, m_NumStagingSlots));

        WsbAffirmHr(WsbSaveToStream(pStream, m_NumScratchCarts));

        WsbAffirmHr(WsbSaveToStream(pStream, m_NumUnknownCarts));

        WsbAffirmHr(WsbSaveToStream(pStream, m_isMagazineSupported));

        WsbAffirmHr(WsbSaveToStream(pStream, m_maxCleaningMounts));

        WsbAffirmHr(WsbSaveToStream(pStream, (ULONG) m_slotSelectionPolicy));

        WsbAffirmHr(m_pChangers->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
        WsbAffirmHr(pPersistStream->Save(pStream, clearDirty));
        pPersistStream = 0;

        WsbAffirmHr(m_pDriveClasses->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
        WsbAffirmHr(pPersistStream->Save(pStream, clearDirty));
        pPersistStream = 0;

        WsbAffirmHr(m_pDrives->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
        WsbAffirmHr(pPersistStream->Save(pStream, clearDirty));
        pPersistStream = 0;

        WsbAffirmHr(m_pStorageSlots->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
        WsbAffirmHr(pPersistStream->Save(pStream, clearDirty));
        pPersistStream = 0;

        WsbAffirmHr(m_pStagingSlots->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
        WsbAffirmHr(pPersistStream->Save(pStream, clearDirty));
        pPersistStream = 0;

        WsbAffirmHr(m_pPorts->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
        WsbAffirmHr(pPersistStream->Save(pStream, clearDirty));
        pPersistStream = 0;

        WsbAffirmHr(m_pCleaningCartridges->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
        WsbAffirmHr(pPersistStream->Save(pStream, clearDirty));
        pPersistStream = 0;

        WsbAffirmHr(m_pScratchCartridges->QueryInterface(IID_IPersistStream, (void**) &pPersistStream));
        WsbAffirmHr(pPersistStream->Save(pStream, clearDirty));
        pPersistStream = 0;

        //  Save the ID (GUID) for the media sets.
        GUID objectId;
        CComPtr<IRmsComObject> pMediaSet;
        CComPtr<IWsbEnum> pEnum;

        WsbAffirmHr( m_pMediaSets->Enum( &pEnum ) );

        hr = pEnum->First( IID_IRmsComObject, (void **)&pMediaSet );
        while ( S_OK == hr ) {

            WsbAffirmHr( pMediaSet->GetObjectId( &objectId ) );
            WsbAffirmHr( WsbSaveToStream(pStream, objectId) );
            pMediaSet = 0;

            hr = pEnum->Next( IID_IRmsComObject, (void **)&pMediaSet );
        }

        objectId = GUID_NULL;
        WsbAffirmHr( WsbSaveToStream(pStream, objectId) );  // This marks the last one!

        // Do we need to clear the dirty bit?
        if (clearDirty) {
            m_isDirty = FALSE;
        }

    }
    WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsLibrary::Save"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP
CRmsLibrary::Test(
    OUT USHORT *pPassed,
    OUT USHORT *pFailed
    )
/*++

Implements:

    IWsbTestable::Test

--*/
{
    HRESULT                 hr = S_OK;

    CComPtr<IRmsLibrary>    pLibrary1;
    CComPtr<IRmsLibrary>    pLibrary2;
    CComPtr<IPersistFile>   pFile1;
    CComPtr<IPersistFile>   pFile2;

    LONG                    i;

    CWsbBstrPtr             bstrVal1 = OLESTR("5A5A5A");
    CWsbBstrPtr             bstrWork1;
    CWsbBstrPtr             bstrWork2;

    LONG                    longWork1;
    LONG                    longWork2;

    LONG                    mediaTable [RMSMAXMEDIATYPES] = { RmsMediaUnknown,
                                                              RmsMedia8mm,
                                                              RmsMedia4mm,
                                                              RmsMediaDLT,
                                                              RmsMediaOptical,
                                                              RmsMediaMO35,
                                                              RmsMediaWORM,
                                                              RmsMediaCDR,
                                                              RmsMediaDVD,
                                                              RmsMediaDisk,
                                                              RmsMediaFixed,
                                                              RmsMediaTape };


    WsbTraceIn(OLESTR("CRmsLibrary::Test"), OLESTR(""));

    try {
        // Get the Library interface.
        hr = S_OK;

        try {
            WsbAssertHr(((IUnknown*) (IRmsLibrary*) this)->QueryInterface(IID_IRmsLibrary, (void**) &pLibrary1));

            // Test SetName & GetName interface
            bstrWork1 = bstrVal1;

            SetName(bstrWork1);

            GetName(&bstrWork2);

            if (bstrWork1 == bstrWork2){
                (*pPassed)++;
            } else {
                (*pFailed)++;
            }

            // Test SetMediaSupported & GetMediaSupported
            for (i = 0; i < RMSMAXMEDIATYPES; i++){

                longWork1 = mediaTable[i];

                SetMediaSupported (longWork1);

                GetMediaSupported (&longWork2);

                if (longWork1 == longWork2){
                    (*pPassed)++;
                } else {
                    (*pFailed)++;
                }
            }

            // Test SetMaxChangers & GetMaxChangers
            longWork1 = 99;

            SetMaxChangers(longWork1);

            GetMaxChangers(&longWork2);

            if(longWork1 == longWork2){
                (*pPassed)++;
            } else {
                (*pFailed)++;
            }

            // Test SetMaxDrives & GetMaxDrives
            longWork1 = 99;

            SetMaxDrives(longWork1);

            GetMaxDrives(&longWork2);

            if(longWork1 == longWork2){
                (*pPassed)++;
            } else {
                (*pFailed)++;
            }

            // Test SetMaxPorts & GetMaxPorts
            longWork1 = 99;

            SetMaxPorts(longWork1);

            GetMaxPorts(&longWork2);

            if(longWork1 == longWork2){
                (*pPassed)++;
            } else {
                (*pFailed)++;
            }

            // Test SetMaxSlots & GetMaxSlots
            longWork1 = 99;

            SetMaxSlots(longWork1);

            GetMaxSlots(&longWork2);

            if(longWork1 == longWork2){
                (*pPassed)++;
            } else {
                (*pFailed)++;
            }

            // Test GetNumUsedSlots
            m_NumUsedSlots = 99;
            longWork1 = m_NumUsedSlots;

            GetNumUsedSlots(&longWork2);

            if(longWork1 == longWork2){
                (*pPassed)++;
            } else {
                (*pFailed)++;
            }

            // Test SetNumStagingSlots & GetNumStagingSlots
            longWork1 = 99;

            SetNumStagingSlots(longWork1);

            GetNumStagingSlots(&longWork2);

            if(longWork1 == longWork2){
                (*pPassed)++;
            } else {
                (*pFailed)++;
            }

            // Test SetNumScratchCarts & GetNumScratchCarts
            longWork1 = 99;

            SetNumScratchCarts(longWork1);

            GetNumScratchCarts(&longWork2);

            if(longWork1 == longWork2){
                (*pPassed)++;
            } else {
                (*pFailed)++;
            }

            // Test SetNumUnknownCarts & GetNumUnknownCarts
            longWork1 = 99;

            SetNumUnknownCarts(longWork1);

            GetNumUnknownCarts(&longWork2);

            if(longWork1 == longWork2){
                (*pPassed)++;
            } else {
                (*pFailed)++;
            }

            // Test SetIsMagazineSupported & IsMagazineSupported to TRUE
            hr = S_OK;

            try{
                WsbAffirmHr(SetIsMagazineSupported (TRUE));
                WsbAffirmHr(IsMagazineSupported ());
            } WsbCatch (hr);

            if (hr == S_OK){
                (*pPassed)++;
            } else {
                (*pFailed)++;
            }

            // Test SetIsMagazineSupported & IsMagazineSupported to FALSE
            hr = S_OK;

            try{
                WsbAffirmHr(SetIsMagazineSupported (FALSE));
                WsbAffirmHr(IsMagazineSupported ());
            } WsbCatch (hr);

            if (hr == S_OK){
                (*pFailed)++;
            } else {
                (*pPassed)++;
            }

            // Test SetMaxCleaningMounts & GetMaxCleaningMounts
            longWork1 = 99;

            SetMaxCleaningMounts(longWork1);

            GetMaxCleaningMounts(&longWork2);

            if(longWork1 == longWork2){
                (*pPassed)++;
            } else {
                (*pFailed)++;
            }

            // Test SetSlotSelectionPolicy & GetSlotSelectionPolicy
            for (i = RmsSlotSelectUnknown; i < RmsSlotSelectSortLabel; i++){

                longWork1 = i;

                SetSlotSelectionPolicy (longWork1);

                GetSlotSelectionPolicy (&longWork2);

                if (longWork1 == longWork2){
                    (*pPassed)++;
                } else {
                    (*pFailed)++;
                }
            }


        } WsbCatch(hr);


        // Tally up the results

        hr = S_OK;
        if (*pFailed) {
            hr = S_FALSE;
        }


    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsLibrary::Test"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}

////////////////////////////////////////////////////////////////////////////////
//
// IRmsLibrary
//


STDMETHODIMP
CRmsLibrary::GetLibraryId(
    GUID    *pLibraryId
    )
/*++

Implements:

    IRmsLibrary::GetLibraryId

--*/
{
    *pLibraryId = m_objectId;
    return (S_OK);
}


STDMETHODIMP
CRmsLibrary::SetLibraryId(
    GUID    objectId
    )
/*++

Implements:

    IRmsLibrary::SetLibraryId

--*/
{
    m_objectId = objectId;
    m_isDirty = TRUE;
    return (S_OK);
}


STDMETHODIMP
CRmsLibrary::GetName(
    BSTR *pName
    )
/*++

Implements:

    IRmsLibrary::GetName

--*/
{
    WsbAssertPointer (pName);

    m_Name. CopyToBstr (pName);
    return S_OK;
}


STDMETHODIMP
CRmsLibrary::SetName(
    BSTR name
    )
/*++

Implements:

    IRmsLibrary::SetName

--*/
{
    m_Name = name;
    m_isDirty = TRUE;
    return S_OK;
}


STDMETHODIMP
CRmsLibrary::GetMediaSupported(
    LONG    *pType
    )
/*++

Implements:

    IRmsLibrary::GetMediaSupported

--*/
{
    *pType = m_mediaSupported;
    return S_OK;
}


STDMETHODIMP
CRmsLibrary::SetMediaSupported(
    LONG    type
    )
/*++

Implements:

    IRmsLibrary::SetMediaSupported

--*/
{
    m_mediaSupported = (RmsMedia) type;
    m_isDirty = TRUE;
    return S_OK;
}


STDMETHODIMP
CRmsLibrary::GetMaxChangers(
    LONG    *pNum
    )
/*++

Implements:

    IRmsLibrary::GetMaxChangers

--*/
{
    *pNum = m_maxChangers;
    return S_OK;
}


STDMETHODIMP
CRmsLibrary::SetMaxChangers(
    LONG    num
    )
/*++

Implements:

    IRmsLibrary::SetMaxChangers

--*/
{
    m_maxChangers = num;
    m_isDirty = TRUE;
    return S_OK;
}


STDMETHODIMP
CRmsLibrary::GetMaxDrives(
    LONG    *pNum
    )
/*++

Implements:

    IRmsLibrary::GetMaxDrives

--*/
{
    *pNum = m_maxDrives;
    return S_OK;
}


STDMETHODIMP
CRmsLibrary::SetMaxDrives(
    LONG    num
    )
/*++

Implements:

    IRmsLibrary::SetMaxDrives

--*/
{
    m_maxDrives = num;
    m_isDirty = TRUE;
    return S_OK;
}


STDMETHODIMP
CRmsLibrary::GetMaxPorts(
    LONG    *pNum
    )
/*++

Implements:

    IRmsLibrary::GetMaxPorts

--*/
{
    *pNum = m_maxPorts;
    return S_OK;
}


STDMETHODIMP
CRmsLibrary::SetMaxPorts(
    LONG    num
    )
/*++

Implements:

    IRmsLibrary::SetMaxPorts

--*/
{
    m_maxPorts = num;
    m_isDirty = TRUE;
    return S_OK;
}


STDMETHODIMP
CRmsLibrary::GetMaxSlots(
    LONG    *pNum
    )
/*++

Implements:

    IRmsLibrary::GetMaxSlots

--*/
{
    *pNum = m_maxSlots;
    return S_OK;
}


STDMETHODIMP
CRmsLibrary::SetMaxSlots(
    LONG    num
    )
/*++

Implements:

    IRmsLibrary::SetMaxSlots

--*/
{
    m_maxSlots = num;
    m_isDirty = TRUE;
    return S_OK;
}


STDMETHODIMP
CRmsLibrary::GetNumUsedSlots(
    LONG    *pNum
    )
/*++

Implements:

    IRmsLibrary::GetNumUsedSlots

--*/
{
    *pNum = m_NumUsedSlots;
    return S_OK;
}


STDMETHODIMP
CRmsLibrary::GetNumStagingSlots(
    LONG    *pNum
    )
/*++

Implements:

    IRmsLibrary::GetNumStagingSlots

--*/
{
    *pNum = m_NumStagingSlots;
    return S_OK;
}


STDMETHODIMP
CRmsLibrary::SetNumStagingSlots(
    LONG    num
    )
/*++

Implements:

    IRmsLibrary::SetNumStagingSlots

--*/
{
    m_NumStagingSlots = num;
    m_isDirty = TRUE;
    return S_OK;
}


STDMETHODIMP
CRmsLibrary::GetNumScratchCarts(
    LONG    *pNum
    )
/*++

Implements:

    IRmsLibrary::SetNumScratchCarts

--*/
{
    *pNum = m_NumScratchCarts;
    m_isDirty = TRUE;
    return S_OK;
}


STDMETHODIMP
CRmsLibrary::SetNumScratchCarts(
    LONG    num
    )
/*++

Implements:

    IRmsLibrary::SetNumScratchCarts

--*/
{
    m_NumScratchCarts = num;
    m_isDirty = TRUE;
    return S_OK;
}


STDMETHODIMP
CRmsLibrary::GetNumUnknownCarts(
    LONG    *pNum
    )
/*++

Implements:

    IRmsLibrary::GetNumUnknownCarts

--*/
{
    *pNum = m_NumUnknownCarts;
    return S_OK;
}


STDMETHODIMP
CRmsLibrary::SetNumUnknownCarts(
    LONG    num
    )
/*++

Implements:

    IRmsLibrary::SetNumUnknownCarts

--*/
{
    m_NumUnknownCarts = num;
    m_isDirty = TRUE;
    return S_OK;
}


STDMETHODIMP
CRmsLibrary::SetIsMagazineSupported(
    BOOL    flag
    )
/*++

Implements:

    IRmsLibrary::SetIsMagazineSupported

--*/
{
    m_isMagazineSupported = flag;
    m_isDirty = TRUE;
    return S_OK;
}


STDMETHODIMP
CRmsLibrary::IsMagazineSupported(
    void
    )
/*++

Implements:

    IRmsLibrary::IsMagazineSupported

--*/
{
    HRESULT    hr = S_FALSE;

    if (m_isMagazineSupported){
        hr = S_OK;
    }

    return (hr);
}


STDMETHODIMP
CRmsLibrary::GetMaxCleaningMounts(
    LONG    *pNum
    )
/*++

Implements:

    IRmsLibrary::GetMaxCleaningMounts

--*/
{
    *pNum = m_maxCleaningMounts;
    return S_OK;
}


STDMETHODIMP
CRmsLibrary::SetMaxCleaningMounts(
    LONG    num
    )
/*++

Implements:

    IRmsLibrary::SetMaxCleanMounts

--*/
{
    m_maxCleaningMounts = num;
    m_isDirty = TRUE;
    return S_OK;
}


STDMETHODIMP
CRmsLibrary::GetSlotSelectionPolicy(
    LONG    *pNum
    )
/*++

Implements:

    IRmsLibrary::GetSlotSelectionPolicy

--*/
{
    *pNum = m_slotSelectionPolicy;
    return S_OK;
}


STDMETHODIMP
CRmsLibrary::SetSlotSelectionPolicy(
    LONG    num
    )
/*++

Implements:

    IRmsLibrary::SetSlotSelectionPolicy

--*/
{
    m_slotSelectionPolicy = (RmsSlotSelect) num;
    m_isDirty = TRUE;
    return S_OK;
}


STDMETHODIMP
CRmsLibrary::GetChangers(
    IWsbIndexedCollection  **ptr
    )
/*++

Implements:

    IRmsLibrary::GetChangers

--*/
{
    *ptr = m_pChangers;
    m_pChangers->AddRef();
    return S_OK;
}


STDMETHODIMP
CRmsLibrary::GetDriveClasses(
    IWsbIndexedCollection  **ptr
    )
/*++

Implements:

    IRmsLibrary::GetDriveClasses

--*/
{
    *ptr = m_pDriveClasses;
    m_pDriveClasses->AddRef();
    return S_OK;
}


STDMETHODIMP
CRmsLibrary::GetDrives(
    IWsbIndexedCollection  **ptr
    )
/*++

Implements:

    IRmsLibrary::GetDrives

--*/
{
    *ptr = m_pDrives;
    m_pDrives->AddRef();
    return S_OK;
}


STDMETHODIMP
CRmsLibrary::GetStorageSlots(
    IWsbIndexedCollection  **ptr
    )
/*++

Implements:

    IRmsLibrary::GetStorageSlots

--*/
{
    *ptr = m_pStorageSlots;
    m_pStorageSlots->AddRef();
    return S_OK;
}


STDMETHODIMP
CRmsLibrary::GetStagingSlots(
    IWsbIndexedCollection  **ptr
    )
/*++

Implements:

    IRmsLibrary::GetStagingSlots

--*/
{
    *ptr = m_pStagingSlots;
    m_pStagingSlots->AddRef();
    return S_OK;
}


STDMETHODIMP
CRmsLibrary::GetPorts(
    IWsbIndexedCollection  **ptr
    )
/*++

Implements:

    IRmsLibrary::GetPorts

--*/
{
    *ptr = m_pPorts;
    m_pPorts->AddRef();
    return S_OK;
}


STDMETHODIMP
CRmsLibrary::GetCleaningCartridges(
    IWsbIndexedCollection  **ptr
    )
/*++

Implements:

    IRmsLibrary::GetCleaningCartridges

--*/
{
    *ptr = m_pCleaningCartridges;
    m_pCleaningCartridges->AddRef();
    return S_OK;
}


STDMETHODIMP
CRmsLibrary::GetScratchCartridges(
    IWsbIndexedCollection  **ptr
    )
/*++

Implements:

    IRmsLibrary::GetScratchCartridges

--*/
{
    *ptr = m_pScratchCartridges;
    m_pScratchCartridges->AddRef();
    return S_OK;
}


STDMETHODIMP
CRmsLibrary::GetMediaSets(
    IWsbIndexedCollection **ptr
    )
/*++

Implements:

    IRmsLibrary::GetMediaSets

--*/
{
    *ptr = m_pMediaSets;
    m_pMediaSets->AddRef();
    m_isDirty = TRUE;
    return S_OK;
}



STDMETHODIMP
CRmsLibrary::Audit(
    LONG /*start*/,
    LONG /*count*/,
    BOOL /*verify*/,
    BOOL /*unknownOnly*/,
    BOOL /*mountWait*/,
    LPOVERLAPPED /*pOverlapped*/,
    LONG* /*pRequest*/
    )
/*++

Implements:

    IRmsLibrary::Audit

--*/
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\rms\server\rmslibry.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    RmsLibry.h

Abstract:

    Declaration of the CRmsLibrary class

Author:

    Brian Dodd          [brian]         15-Nov-1996

Revision History:

--*/

#ifndef _RMSLIBRY_
#define _RMSLIBRY_

#include "resource.h"       // resource symbols

#include "RmsObjct.h"       // CRmsComObject

/*++

Class Name:

    CRmsLibrary

Class Description:

    A CRmsLibrary represents the multi-device complex that includes:

        zero or more medium changers,

        zero or more drive classes,

        zero or more drives,

        zero or more storage slots,

        zero or more staging slots,

        zero or more I/E ports,

        zero or more cleaning cartridges,

        zero or more scratch cartridges,

        zero or more media sets.

        But, at least one.

--*/

class CRmsLibrary :
    public CComDualImpl<IRmsLibrary, &IID_IRmsLibrary, &LIBID_RMSLib>,
    public CRmsComObject,
    public CWsbObject,        // inherits CComObjectRoot
    public CComCoClass<CRmsLibrary,&CLSID_CRmsLibrary>
{
public:
    CRmsLibrary() {}
BEGIN_COM_MAP(CRmsLibrary)
    COM_INTERFACE_ENTRY2(IDispatch, IRmsLibrary)
    COM_INTERFACE_ENTRY(IRmsLibrary)
    COM_INTERFACE_ENTRY(IRmsComObject)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IWsbCollectable)
    COM_INTERFACE_ENTRY(IWsbPersistStream)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_RmsLibrary)

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);

// IPersist
public:
    STDMETHOD(GetClassID)(CLSID *pClsid);

// IPersistStream
public:
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER* pSize);
    STDMETHOD(Load)(IStream* pStream);
    STDMETHOD(Save)(IStream* pStream, BOOL clearDirty);

// IWsbCollectable
public:
    STDMETHOD(CompareTo)(IUnknown* pCollectable, SHORT* pResult);
    WSB_FROM_CWSBOBJECT;

// IWsbTestable
public:
    STDMETHOD(Test)(USHORT *pPassed, USHORT *pFailed);

// IRmsLibrary
public:
    STDMETHOD(GetLibraryId)(GUID *pLibraryId);
    STDMETHOD(SetLibraryId)(GUID libraryId);

    STDMETHOD( GetName )( BSTR *pName );
    STDMETHOD( SetName )( BSTR name );

    STDMETHOD(GetMediaSupported)(LONG *pType);
    STDMETHOD(SetMediaSupported)(LONG type);

    STDMETHOD(GetMaxChangers)(LONG *pNum);
    STDMETHOD(SetMaxChangers)(LONG num);

    STDMETHOD(GetMaxDrives)(LONG *pNum);
    STDMETHOD(SetMaxDrives)(LONG num);

    STDMETHOD(GetMaxPorts)(LONG *pNum);
    STDMETHOD(SetMaxPorts)(LONG num);

    STDMETHOD(GetMaxSlots)(LONG *pNum);
    STDMETHOD(SetMaxSlots)(LONG num);

    STDMETHOD(GetNumUsedSlots)(LONG *pNum);

    STDMETHOD(GetNumStagingSlots)(LONG *pNum);
    STDMETHOD(SetNumStagingSlots)(LONG num);

    STDMETHOD(GetNumScratchCarts)(LONG *pNum);
    STDMETHOD(SetNumScratchCarts)(LONG num);

    STDMETHOD(GetNumUnknownCarts)(LONG *pNum);
    STDMETHOD(SetNumUnknownCarts)(LONG num);

    STDMETHOD(SetIsMagazineSupported)(BOOL flag);
    STDMETHOD(IsMagazineSupported)(void);

    STDMETHOD(GetMaxCleaningMounts)(LONG *pNum);
    STDMETHOD(SetMaxCleaningMounts)(LONG num);

    STDMETHOD(GetSlotSelectionPolicy)(LONG *pNum);
    STDMETHOD(SetSlotSelectionPolicy)(LONG num);

    STDMETHOD(GetChangers)(IWsbIndexedCollection **ptr);
    STDMETHOD(GetDriveClasses)(IWsbIndexedCollection **ptr);
    STDMETHOD(GetDrives)(IWsbIndexedCollection **ptr);
    STDMETHOD(GetStorageSlots)(IWsbIndexedCollection **ptr);
    STDMETHOD(GetStagingSlots)(IWsbIndexedCollection **ptr);
    STDMETHOD(GetPorts)(IWsbIndexedCollection **ptr);
    STDMETHOD(GetCleaningCartridges)(IWsbIndexedCollection **ptr);
    STDMETHOD(GetScratchCartridges)(IWsbIndexedCollection **ptr);
    STDMETHOD(GetMediaSets)(IWsbIndexedCollection **ptr);

    STDMETHOD( Audit )( LONG start, LONG count, BOOL verify, BOOL unknownOnly, BOOL mountWait, LPOVERLAPPED pOverlapped, LONG *pRequest );


protected:

    enum {                                  // Class specific constants:
                                            //
        Version = 1,                        // Class version, this should be
                                            //   incremented each time the
                                            //   the class definition changes.
        };                                  //
    RmsMedia        m_mediaSupported;       // The type of media supported by a
                                            //   a Drive, usually one type, but
                                            //   can be a combination of media
                                            //   types for multi-function devices
                                            //   (i.e. drives that support Optical,
                                            //   WORM, and CDR).
    LONG            m_maxChangers;          // The total number of medium changers contained
                                            //   within the Library.
    LONG            m_maxDrives;            // The total number of drives contained
                                            //   within the Library.
    LONG            m_maxPorts;             // The total number of I/E ports contained
                                            //   within the Library.
    LONG            m_maxSlots;             // The total number of storage slots
                                            //   contained within the library.
    LONG            m_NumUsedSlots;         // The number of occupied storage slots.
    LONG            m_NumStagingSlots;      // The number of slots used for staging area.
    LONG            m_NumScratchCarts;      // The amount of scratch media available.
    LONG            m_NumUnknownCarts;      // The number of units of media
                                            //   having unknown status.
    BOOL            m_isMagazineSupported;  // If TRUE, the library supports magazines.
    LONG            m_maxCleaningMounts;    // The max number of mounts per cleaning
                                            //   cartridge.
    RmsSlotSelect   m_slotSelectionPolicy;  // The storage slot selection policy
                                            //   to use (see RmsSlotSelect).
    CComPtr<IWsbIndexedCollection> m_pChangers;            // The changers associates with the Library.
    CComPtr<IWsbIndexedCollection> m_pDriveClasses;        // The drive classes associates with the Library.
    CComPtr<IWsbIndexedCollection> m_pDrives;              // The drives associates with the Library.
    CComPtr<IWsbIndexedCollection> m_pStorageSlots;        // The storage slots associates with the Library.
    CComPtr<IWsbIndexedCollection> m_pStagingSlots;        // The staging slots associates with the Library.
    CComPtr<IWsbIndexedCollection> m_pPorts;               // The I/E ports associated with the Library.
    CComPtr<IWsbIndexedCollection> m_pCleaningCartridges;  // The cleaning cartridges associated with the Library.
    CComPtr<IWsbIndexedCollection> m_pScratchCartridges;   // The scratch cartridges associated with the Library.
    CComPtr<IWsbIndexedCollection> m_pMediaSets;           // The media sets associated with the Library.
};

#endif // _RMSLIBRY_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\rms\server\rmsiport.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    RmsIPort.h

Abstract:

    Declaration of the CRmsIEPort class

Author:

    Brian Dodd          [brian]         15-Nov-1996

Revision History:

--*/

#ifndef _RMSIPORT_
#define _RMSIPORT_

#include "resource.h"       // resource symbols

#include "RmsObjct.h"       // CRmsComObject
#include "RmsCElmt.h"       // CRmsChangerElement

/*++

Class Name:

    CRmsIPort

Class Description:

    A CRmsIPort represents an element in a library through which media are
    imported and/or exported.

--*/

class CRmsIEPort :
    public CComDualImpl<IRmsIEPort, &IID_IRmsIEPort, &LIBID_RMSLib>,
    public CRmsChangerElement,
    public CWsbObject,          // inherits CComObjectRoot
    public CComCoClass<CRmsIEPort,&CLSID_CRmsIEPort>
{
public:
    CRmsIEPort() {}
BEGIN_COM_MAP(CRmsIEPort)
    COM_INTERFACE_ENTRY2(IDispatch, IRmsIEPort)
    COM_INTERFACE_ENTRY(IRmsIEPort)
    COM_INTERFACE_ENTRY(IRmsComObject)
    COM_INTERFACE_ENTRY(IRmsChangerElement)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStream)
    COM_INTERFACE_ENTRY(IPersistStream)
    COM_INTERFACE_ENTRY(IWsbCollectable)
//    COM_INTERFACE_ENTRY(IWsbPersistable)
    COM_INTERFACE_ENTRY(IWsbTestable)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_RmsIEPort)

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);

// IPersist
public:
    STDMETHOD(GetClassID)(CLSID *pClsid);

// IPersistStream
public:
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER* pSize);
    STDMETHOD(Load)(IStream* pStream);
    STDMETHOD(Save)(IStream* pStream, BOOL clearDirty);

// IWsbCollectable
public:
    STDMETHOD(CompareTo)(IUnknown* pCollectable, SHORT* pResult);
    WSB_FROM_CWSBOBJECT;

// IWsbTestable
public:
    STDMETHOD(Test)(USHORT *pPassed, USHORT *pFailed);

// IRmsIEPort
public:
    STDMETHOD(GetDescription)(BSTR *pDesc);
    STDMETHOD(SetDescription)(BSTR desc);

    STDMETHOD(SetIsImport)(BOOL flag);
    STDMETHOD(IsImport)(void);

    STDMETHOD(SetIsExport)(BOOL flag);
    STDMETHOD(IsExport)(void);

    STDMETHOD(GetWaitTime)(LONG *pTime);
    STDMETHOD(SetWaitTime)(LONG time);

private:

    enum {                                  // Class specific constants:
                                            //
        Version = 1,                        // Class version, this should be
                                            //   incremented each time the
                                            //   the class definition changes.
        };                                  //
    CWsbBstrPtr     m_description;          // This is the description used to
                                            //   identify the port to an operator.
    BOOL            m_isImport;             // If TRUE, the portal can be used for importing media.
    BOOL            m_isExport;             // If TRUE, the portal can be used for exporting media.
    LONG            m_waitTime;             // Elapsed milliseconds to wait before
                                            //   timming out an import/export request.
};

#endif // _RMSIPORT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\rms\server\rmslocat.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    RmsLocat.cpp

Abstract:

    Implementation of CRmsLocator

Author:

    Brian Dodd          [brian]         15-Nov-1996

Revision History:

--*/

#include "stdafx.h"

#include "RmsLocat.h"

///////////////////////////////////////////////////////////////////////////////
//


CRmsLocator::CRmsLocator(
    void
    )
/*++

Routine Description:

    CRmsLocator constructor

Arguments:

    None

Return Value:

    None

--*/
{
    // Initialize values
    m_type = RmsElementUnknown;

    m_libraryId = GUID_NULL;

    m_mediaSetId = GUID_NULL;

    m_position = 0;

    m_alternate1 = 0;

    m_alternate2 = 0;

    m_alternate3 = 0;

    m_invert = FALSE;
}


HRESULT
CRmsLocator::CompareTo(
    IN  IUnknown    *pCollectable,
    OUT SHORT       *pResult
    )
/*++

Implements:

    CRmsLocator::CompareTo

--*/
{
    HRESULT     hr = E_FAIL;
    SHORT       result = 1;

    WsbTraceIn( OLESTR("CRmsLocator::CompareTo"), OLESTR("") );

    try {

        // Validate arguments - Okay if pResult is NULL
        WsbAssertPointer( pCollectable );

        CRmsLocator     pLocator;
        RmsElement      type;
        GUID            libraryId;
        GUID            mediaSetId;
        LONG            position;
        LONG            alternate1;
        LONG            alternate2;
        LONG            alternate3;
        BOOL            invert;

        // Get Locator to check
        GetLocation((LONG *) &type, &libraryId, &mediaSetId, &position,
                    &alternate1, &alternate2, &alternate3,
                    &invert);

        // See if we have the location requested
        if ( (m_type       == type       ) &&
             (m_libraryId  == libraryId  ) &&
             (m_mediaSetId == mediaSetId ) &&
             (m_position   == position   ) &&
             (m_alternate1 == alternate1 ) &&
             (m_alternate2 == alternate2 ) &&
             (m_alternate3 == alternate3 ) &&
             (m_invert     == invert     )    ) {

            // Locators match
            hr = S_OK;
            result = 0;

        }
        else {
            hr = S_FALSE;
            result = 1;
        }

    }
    WsbCatch( hr );

    if ( SUCCEEDED(hr) && (0 != pResult) ){
       *pResult = result;
    }

    WsbTraceOut( OLESTR("CRmsLocator::CompareTo"),
                 OLESTR("hr = <%ls>, result = <%ls>"),
                 WsbHrAsString( hr ), WsbPtrToShortAsString( pResult ) );

    return hr;
}


HRESULT
CRmsLocator::GetSizeMax(
    OUT ULARGE_INTEGER* pcbSize
    )
/*++

Implements:

    IPersistStream::GetSizeMax

--*/
{
    HRESULT     hr = E_NOTIMPL;

    WsbTraceIn(OLESTR("CRmsLocator::GetSizeMax"), OLESTR(""));

//    try {
//        WsbAssert(0 != pcbSize, E_POINTER);

//        // Get max size
//        pcbSize->QuadPart  = WsbPersistSizeOf(LONG) +           // m_type
//                             WsbPersistSizeOf(GUID) +           // m_libraryId
//                             WsbPersistSizeOf(GUID) +           // m_mediaSetId
//                             WsbPersistSizeOf(LONG) +           // m_position
//                             WsbPersistSizeOf(LONG) +           // m_alternate1
//                             WsbPersistSizeOf(LONG) +           // m_alternate2
//                             WsbPersistSizeOf(LONG) +           // m_alternate3
//                             WsbPersistSizeOf(BOOL);            // m_invert

//    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsLocator::GetSizeMax"), OLESTR("hr = <%ls>, Size = <%ls>"), WsbHrAsString(hr), WsbPtrToUliAsString(pcbSize));

    return(hr);
}


HRESULT
CRmsLocator::Load(
    IN IStream* pStream
    )
/*++

Implements:

    IPersistStream::Load

--*/
{
    HRESULT     hr = S_OK;
    ULONG       ulBytes = 0;

    WsbTraceIn(OLESTR("CRmsLocator::Load"), OLESTR(""));

    try {
        ULONG temp;

        WsbAssert(0 != pStream, E_POINTER);

        // Read value
        WsbAffirmHr(WsbLoadFromStream(pStream, &temp));
        m_type = (RmsElement)temp;

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_libraryId));

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_mediaSetId));

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_position));

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_alternate1));

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_alternate2));

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_alternate3));

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_invert));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsLocator::Load"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CRmsLocator::Save(
    IN IStream* pStream,
    IN BOOL clearDirty
    )
/*++

Implements:

    IPersistStream::Save

--*/
{
    HRESULT     hr = S_OK;
    ULONG       ulBytes = 0;

    WsbTraceIn(OLESTR("CRmsLocator::Save"), OLESTR("clearDirty = <%ls>"), WsbBoolAsString(clearDirty));

    try {
        WsbAssert(0 != pStream, E_POINTER);

        // Write value
        WsbAffirmHr(WsbSaveToStream(pStream, (ULONG) m_type));

        WsbAffirmHr(WsbSaveToStream(pStream, m_libraryId));

        WsbAffirmHr(WsbSaveToStream(pStream, m_mediaSetId));

        WsbAffirmHr(WsbSaveToStream(pStream, m_position));

        WsbAffirmHr(WsbSaveToStream(pStream, m_alternate1));

        WsbAffirmHr(WsbSaveToStream(pStream, m_alternate2));

        WsbAffirmHr(WsbSaveToStream(pStream, m_alternate3));

        WsbAffirmHr(WsbSaveToStream(pStream, m_invert));

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsLocator::Save"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


HRESULT
CRmsLocator::Test(
    OUT USHORT *pPassed,
    OUT USHORT *pFailed
    )
/*++

Implements:

    IWsbTestable::Test

--*/
{
    HRESULT                 hr = S_OK;

    CComPtr<IRmsMediaSet>   pMediaSet1;
    CComPtr<IRmsMediaSet>   pMediaSet2;

    CComPtr<IPersistFile>   pFile1;
    CComPtr<IPersistFile>   pFile2;

    LONG                    i;

    GUID                    guidVal1 = { 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0};
    GUID                    guidVal2 = { 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1};

    GUID                    guidWork1;
    GUID                    guidWork2;

    LONG                    longVal1 = 11111111;
    LONG                    longVal2 = 22222222;
    LONG                    longVal3 = 33333333;
    LONG                    longVal4 = 44444444;

    LONG                    longWork0;
    LONG                    longWork1;
    LONG                    longWork2;
    LONG                    longWork3;
    LONG                    longWork4;

    BOOL                    boolWork1;
    BOOL                    boolWork2;


    WsbTraceIn(OLESTR("CRmsLocator::Test"), OLESTR(""));

    try {
        // Get the MediaSet interface.
        hr = S_OK;
        try {
            WsbAssertHr(((IUnknown*) (IRmsMediaSet*) this)->QueryInterface(IID_IRmsMediaSet, (void**) &pMediaSet1));

            boolWork1 = FALSE;

            // Test SetLocation & GetLocation
            for(i = RmsElementUnknown; i < RmsElementIEPort; i++){
                SetLocation(i,
                            guidVal1,
                            guidVal2,
                            longVal1,
                            longVal2,
                            longVal3,
                            longVal4,
                            boolWork1);

                GetLocation(&longWork0,
                            &guidWork1,
                            &guidWork2,
                            &longWork1,
                            &longWork2,
                            &longWork3,
                            &longWork4,
                            &boolWork2);

                if((i == longWork0) &&
                   (guidVal1 == guidWork1) &&
                   (guidVal2 == guidWork2) &&
                   (longVal1 == longWork1) &&
                   (longVal2 == longWork2) &&
                   (longVal3 == longWork3) &&
                   (longVal4 == longWork4) &&
                   (boolWork1 == boolWork2)){
                   (*pPassed)++;
                }  else {
                    (*pFailed)++;
                }

                if(boolWork1 == TRUE){
                    boolWork1 = FALSE;
                } else {
                    boolWork1 = TRUE;
                }
            }

        } WsbCatch(hr);

        // Tally up the results

        hr = S_OK;

        if (*pFailed) {
            hr = S_FALSE;
        }

    } WsbCatch(hr);

    WsbTraceOut(OLESTR("CRmsLocator::Test"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return(hr);
}


STDMETHODIMP
CRmsLocator::GetLocation(
    LONG *pType,
    GUID *pLibId,
    GUID *pMediaSetId,
    LONG *pPos,
    LONG *pAlt1,
    LONG *pAlt2,
    LONG *pAlt3,
    BOOL *pInvert)
/*++

Routine Description:

    Get location values.

Arguments:

    pType           - pointer to cartridge type
    pLibId          - pointer to library id
    pMediaSetId     - pointer to media set id
    pPos            - pointer to current position
    pAlt1           - pointer to alternate data field 1
    pAlt2           - pointer to alternate data field 2
    pAlt3           - pointer to alternate data field 3
    pInvert         - pointer to invert flag

Return Value:

    S_OK            - successful

--*/
{
    if (pType) {
        *pType = m_type;
    }
    if (pLibId) {
        *pLibId = m_libraryId;
    }
    if (pMediaSetId) {
        *pMediaSetId = m_mediaSetId;
    }
    if (pPos) {
        *pPos = m_position;
    }
    if (pAlt1) {
        *pAlt1 = m_alternate1;
    }
    if (pAlt2) {
        *pAlt2 = m_alternate2;
    }
    if (pAlt3) {
        *pAlt3 = m_alternate3;
    }
    if (pInvert) {
        *pInvert = m_invert;
    }

    return S_OK;
}

STDMETHODIMP
CRmsLocator::SetLocation(
    LONG type,
    GUID libId,
    GUID mediaSetId,
    LONG pos,
    LONG alt1,
    LONG alt2,
    LONG alt3,
    BOOL invert
    )
/*++

Routine Description:

    Set location values.

Arguments:

    type           - new value of cartridge type
    libId          - new value of library id
    mediaSetId     - new value of media set id
    pos            - new value of current position
    alt1           - new value of alternate data field 1
    alt2           - new value of alternate data field 2
    alt3           - new value of alternate data field 3
    invert         - new value of invert flag

Return Value:

    S_OK            - successful

--*/
{
    m_type = (RmsElement) type;
    m_libraryId = libId;
    m_mediaSetId = mediaSetId;
    m_position = pos;
    m_alternate1 = alt1;
    m_alternate2 = alt2;
    m_alternate3 = alt3;
    m_invert = invert;

//  m_isDirty = TRUE;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\rms\server\rmsmdset.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    RmsMdSet.cpp

Abstract:

    Implementation of CRmsMediaSet

Author:

    Brian Dodd          [brian]         15-Nov-1996

Revision History:

--*/

#include "stdafx.h"

#include "RmsServr.h"
#include "RmsMdSet.h"

////////////////////////////////////////////////////////////////////////////////
//


STDMETHODIMP
CRmsMediaSet::CompareTo(
    IN IUnknown *pCollectable,
    OUT SHORT *pResult)
/*++

Implements:

    IWsbCollectable::CompareTo

--*/
{
    HRESULT hr = E_FAIL;
    SHORT   result = 1;

    WsbTraceIn( OLESTR("CRmsMediaSet::CompareTo"), OLESTR("") );

    try {

        // Validate arguments - Okay if pResult is NULL
        WsbAssertPointer( pCollectable );

        // We need the IRmsMediaSet interface to get the value of the object.
        CComQIPtr<IRmsMediaSet, &IID_IRmsMediaSet> pMediaSet = pCollectable;
        WsbAssertPointer( pMediaSet );

        CComQIPtr<IRmsComObject, &IID_IRmsComObject> pObject = pCollectable;
        WsbAssertPointer( pObject );

        switch ( m_findBy ) {

        case RmsFindByName:
            {

                CWsbBstrPtr name;

                WsbAffirmHr( pMediaSet->GetName( &name ) );

                // Compare the names
                result = (SHORT)wcscmp( m_Name, name );
                hr = ( 0 == result ) ? S_OK : S_FALSE;

            }
            break;

        case RmsFindByMediaSupported:
            {

                RmsMedia mediaSupported;

                WsbAffirmHr(pMediaSet->GetMediaSupported( (LONG*) &mediaSupported ) );

                if ( m_MediaSupported == mediaSupported ) {

                    // media types supported match
                    hr = S_OK;
                    result = 0;

                }
                else {
                    hr = S_FALSE;
                    result = 1;
                }

            }
            break;

        case RmsFindByMediaSetId:
        default:

            // Do CompareTo for object
            hr = CRmsComObject::CompareTo( pCollectable, &result );
            break;

        }

    }
    WsbCatch( hr );

    if ( SUCCEEDED(hr) && (0 != pResult) ){
       *pResult = result;
    }


    WsbTraceOut( OLESTR("CRmsMediaSet::CompareTo"),
                 OLESTR("hr = <%ls>, result = <%ls>"),
                 WsbHrAsString( hr ), WsbPtrToShortAsString( pResult ) );

    return hr;
}


HRESULT
CRmsMediaSet::FinalConstruct(void)
/*++

Implements:

    CComObjectRoot::FinalConstruct

--*/
{
    HRESULT hr = S_OK;

    try {

        WsbAssertHr(CWsbObject::FinalConstruct());

        // Initialize values

        m_Name = RMS_UNDEFINED_STRING;

        m_MediaSupported   = RmsMediaUnknown;

        m_SizeOfInfo = 0;

        memset(m_Info, 0, MaxInfo);

        m_OwnerId = CLSID_NULL;

        m_MediaSetType = RmsMediaSetUnknown;

        m_MaxCartridges = 0;

        m_Occupancy = 0;

        m_IsMediaCopySupported = FALSE;

    } WsbCatch(hr);

    return hr;
}


STDMETHODIMP
CRmsMediaSet::GetClassID(
    OUT CLSID* pClsid)
/*++

Implements:

    IPersist::GetClassID

--*/
{
    HRESULT hr = S_OK;
    WsbTraceIn(OLESTR("CRmsMediaSet::GetClassID"), OLESTR(""));

    try {

        WsbAssertPointer(pClsid);

        *pClsid = CLSID_CRmsMediaSet;

    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CRmsMediaSet::GetClassID"), OLESTR("hr = <%ls>, CLSID = <%ls>"), WsbHrAsString(hr), WsbGuidAsString(*pClsid));

    return hr;
}


STDMETHODIMP
CRmsMediaSet::GetSizeMax(
    OUT ULARGE_INTEGER* pcbSize)
/*++

Implements:

    IPersistStream::GetSizeMax

--*/
{
    HRESULT     hr = E_NOTIMPL;

//    ULONG       nameLen;

    WsbTraceIn(OLESTR("CRmsMediaSet::GetSizeMax"), OLESTR(""));

//    try {
//        WsbAssert(0 != pcbSize, E_POINTER);

//        nameLen = SysStringByteLen(m_name);

//        // Get max size
//        pcbSize->QuadPart  = WsbPersistSizeOf(LONG)  +      // m_objectId
//                             WsbPersistSizeOf(LONG)  +      // length of m_name
//                             nameLen                 +      // m_name
//                             WsbPersistSizeOf(LONG)  +      // m_mediaSupported
//                             WsbPersistSizeOf(SHORT) +      // m_sizeofInfo
//                             MaxInfo                 +      // m_info
//                             WsbPersistSizeOf(CLSID) +      // m_ownerId
//                             WsbPersistSizeOf(LONG)  +      // m_mediaSetType
//                             WsbPersistSizeOf(LONG)  +      // m_maxCartridges
//                             WsbPersistSizeOf(LONG);        // m_occupancy



//    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CRmsMediaSet::GetSizeMax"), OLESTR("hr = <%ls>, Size = <%ls>"), WsbHrAsString(hr), WsbPtrToUliAsString(pcbSize));

    return hr;
}


STDMETHODIMP
CRmsMediaSet::Load(
    IN IStream* pStream)
/*++

Implements:

    IPersistStream::Load

--*/
{
    HRESULT hr = S_OK;
    ULONG   ulBytes = 0;

    WsbTraceIn(OLESTR("CRmsMediaSet::Load"), OLESTR(""));

    try {
        ULONG temp;

        WsbAssertPointer(pStream);

        WsbAffirmHr(CRmsStorageInfo::Load(pStream));

        // Read value
        WsbAffirmHr(WsbLoadFromStream(pStream, &m_objectId));

        WsbAffirmHr(WsbLoadFromStream(pStream, &temp));
        m_MediaSupported = (RmsMedia)temp;

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_SizeOfInfo));

        WsbAffirmHr(WsbLoadFromStream(pStream, &(m_Info [0]), MaxInfo));

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_OwnerId));

        WsbAffirmHr(WsbLoadFromStream(pStream, &temp));
        m_MediaSetType = (RmsMediaSet)temp;

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_MaxCartridges));

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_Occupancy));

        WsbAffirmHr(WsbLoadFromStream(pStream, &m_IsMediaCopySupported));

    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CRmsMediaSet::Load"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP
CRmsMediaSet::Save(
    IN IStream* pStream,
    IN BOOL clearDirty)
/*++

Implements:

    IPersistStream::Save

--*/
{
    HRESULT hr = S_OK;
    ULONG   ulBytes = 0;

    WsbTraceIn(OLESTR("CRmsMediaSet::Save"), OLESTR("clearDirty = <%ls>"), WsbBoolAsString(clearDirty));

    try {
        WsbAssertPointer(pStream);

        WsbAffirmHr(CRmsStorageInfo::Save(pStream, clearDirty));

        // Write value
        WsbAffirmHr(WsbSaveToStream(pStream, m_objectId));

        WsbAffirmHr(WsbSaveToStream(pStream, (ULONG) m_MediaSupported));

        WsbAffirmHr(WsbSaveToStream(pStream, m_SizeOfInfo));

        WsbAffirmHr(WsbSaveToStream(pStream, &(m_Info [0]), MaxInfo));

        WsbAffirmHr(WsbSaveToStream(pStream, m_OwnerId));

        WsbAffirmHr(WsbSaveToStream(pStream, (ULONG) m_MediaSetType));

        WsbAffirmHr(WsbSaveToStream(pStream, m_MaxCartridges));

        WsbAffirmHr(WsbSaveToStream(pStream, m_Occupancy));

        WsbAffirmHr(WsbSaveToStream(pStream, m_IsMediaCopySupported));

        // Do we need to clear the dirty bit?
        if (clearDirty) {
            m_isDirty = FALSE;
        }
    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CRmsMediaSet::Save"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP
CRmsMediaSet::Test(
    OUT USHORT *pPassed,
    OUT USHORT *pFailed)
/*++

Implements:

    IWsbTestable::Test

--*/
{
    HRESULT                 hr = S_OK;

    CComPtr<IRmsMediaSet>   pMediaSet1;
    CComPtr<IRmsMediaSet>   pMediaSet2;

    CComPtr<IPersistFile>   pFile1;
    CComPtr<IPersistFile>   pFile2;

    GUID                    guidVal1 = { 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0};

    GUID                    guidWork1;
    GUID                    guidWork2;

    CLSID                   clsidWork1;
    CLSID                   clsidWork2;

    LONG                    i;
    LONG                    longWork1;
    LONG                    longWork2;

    CWsbBstrPtr             bstrVal1 = OLESTR("5A5A5A");

    CWsbBstrPtr             bstrWork1;
    CWsbBstrPtr             bstrWork2;

    LONG                    mediaTable [RMSMAXMEDIATYPES] = { RmsMediaUnknown,
                                                              RmsMedia8mm,
                                                              RmsMedia4mm,
                                                              RmsMediaDLT,
                                                              RmsMediaOptical,
                                                              RmsMediaMO35,
                                                              RmsMediaWORM,
                                                              RmsMediaCDR,
                                                              RmsMediaDVD,
                                                              RmsMediaDisk,
                                                              RmsMediaFixed,
                                                              RmsMediaTape };


    WsbTraceIn(OLESTR("CRmsMediaSet::Test"), OLESTR(""));

    try {
        // Get the MediaSet interface.
        hr = S_OK;
        try {
            WsbAssertHr(((IUnknown*) (IRmsMediaSet*) this)->QueryInterface(IID_IRmsMediaSet, (void**) &pMediaSet1));

            // Test SetMediaSetId & GetMediaSetId
            m_objectId = guidVal1;

            guidWork1 = m_objectId;

            GetMediaSetId(&guidWork2);

            if(guidWork1 == guidWork2){
                (*pPassed)++;
            } else {
                (*pFailed)++;
            }

            // Test SetName & GetName interface
            bstrWork1 = bstrVal1;

            SetName(bstrWork1);

            GetName(&bstrWork2);

            if (bstrWork1 == bstrWork2){
                (*pPassed)++;
            } else {
                (*pFailed)++;
            }

            // Test SetMediaSupported & GetMediaSupported
            for (i = RmsMediaUnknown; i < RMSMAXMEDIATYPES; i++){

                longWork1 = mediaTable[i];

                SetMediaSupported (longWork1);

                GetMediaSupported (&longWork2);

                if (longWork1 == longWork2){
                    (*pPassed)++;
                } else {
                    (*pFailed)++;
                }
            }

            // Test SetInfo & GetInfo

            // Test SetOwnerClassId & GetOwnerClassId
            clsidWork1 = CLSID_NULL;

            SetOwnerClassId(clsidWork1);

            GetOwnerClassId(&clsidWork2);

            if(clsidWork1 == clsidWork2){
                (*pPassed)++;
            } else {
                (*pFailed)++;
            }

            // Test SetMediaSetType & GetMediaSetType
            for (i = RmsMediaSetUnknown; i < RmsMediaSetNTMS; i++){

                longWork1 = i;

                SetMediaSetType (longWork1);

                GetMediaSetType (&longWork2);

                if (longWork1 == longWork2){
                    (*pPassed)++;
                } else {
                    (*pFailed)++;
                }
            }

            // Test SetMaxCartridges & GetMaxCartridges
            longWork1 = 99;

            SetMaxCartridges(longWork1);

            GetMaxCartridges(&longWork2);

            if(longWork1 == longWork2){
                (*pPassed)++;
            } else {
                (*pFailed)++;
            }

            // Test SetOccupancy & GetOccupancy
            longWork1 = 99;

            SetOccupancy(longWork1);

            GetOccupancy(&longWork2);

            if(longWork1 == longWork2){
                (*pPassed)++;
            } else {
                (*pFailed)++;
            }



        } WsbCatch(hr);

        // Tally up the results

        hr = S_OK;
        if (*pFailed) {
            hr = S_FALSE;
        }


    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CRmsMediaSet::Test"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP
CRmsMediaSet::GetMediaSetId(
    OUT GUID *pMediaSetId)
/*++

Implements:

    IRmsMediaSet::GetMediaSetId

--*/
{
    HRESULT hr = S_OK;

    try {
        WsbAssertPointer (pMediaSetId);

        *pMediaSetId = m_objectId;

    } WsbCatch(hr);

    return hr;
}



STDMETHODIMP
CRmsMediaSet::GetName(
    OUT BSTR *pName)
/*++

Implements:

    IRmsMediaSet::GetName

--*/
{
    HRESULT hr = S_OK;

    try {
        WsbAssertPointer (pName);

        m_Name. CopyToBstr (pName);

    } WsbCatch(hr);

    return hr;
}


STDMETHODIMP
CRmsMediaSet::SetName(
    IN BSTR name)
/*++

Implements:

    IRmsMediaSet::SetName

--*/
{
    m_Name = name;
    m_isDirty = TRUE;
    return S_OK;
}


STDMETHODIMP
CRmsMediaSet::GetMediaSupported(
    OUT LONG *pType)
/*++

Implements:

    IRmsMediaSet::GetMediaSupported

--*/
{
    HRESULT hr = S_OK;

    try {
        WsbAssertPointer (pType);

        *pType = m_MediaSupported;

    } WsbCatch(hr);

    return hr;
}


STDMETHODIMP
CRmsMediaSet::SetMediaSupported(
    IN LONG type)
/*++

Implements:

    IRmsMediaSet::SetMediaSupported

--*/
{
    m_MediaSupported = (RmsMedia) type;
    m_isDirty = TRUE;
    return S_OK;
}


STDMETHODIMP
CRmsMediaSet::GetInfo(
    OUT UCHAR *pInfo,
    OUT SHORT *pSize)
/*++

Implements:

    IRmsMediaSet::GetInfo

--*/
{
    HRESULT hr = S_OK;

    try {
        WsbAssertPointer (pInfo);
        WsbAssertPointer (pSize);

        memmove (pInfo, m_Info, m_SizeOfInfo );
        *pSize = m_SizeOfInfo;

    } WsbCatch(hr);

    return hr;
}


STDMETHODIMP
CRmsMediaSet::SetInfo(
    IN UCHAR *pInfo,
    IN SHORT size)
/*++

Implements:

    IRmsMediaSet::SetInfo

--*/
{
    HRESULT hr = S_OK;

    try {
        WsbAssertPointer (pInfo);

        memmove (m_Info, pInfo, size);
        m_SizeOfInfo = size;
        m_isDirty = TRUE;

    } WsbCatch(hr);

    return hr;
}


STDMETHODIMP
CRmsMediaSet::GetOwnerClassId(
    OUT CLSID *pClassId)
/*++

Implements:

    IRmsMediaSet::GetOwnerClassId

--*/
{
    HRESULT hr = S_OK;

    try {
        WsbAssertPointer (pClassId);

        *pClassId = m_OwnerId;

    } WsbCatch(hr);

    return hr;
}


STDMETHODIMP
CRmsMediaSet::SetOwnerClassId(
    IN CLSID classId)
/*++

Implements:

    IRmsMediaSet::SetOwnerClassId

--*/
{
    m_OwnerId = classId;
    m_isDirty = TRUE;
    return S_OK;
}


STDMETHODIMP
CRmsMediaSet::GetMediaSetType(
    OUT LONG *pType)
/*++

Implements:

    IRmsMediaSet::GetMediaSetType

--*/
{
    HRESULT hr = S_OK;

    try {
        WsbAssertPointer (pType);

        *pType = m_MediaSetType;

    } WsbCatch(hr);

    return hr;
}


STDMETHODIMP
CRmsMediaSet::SetMediaSetType(
    IN LONG type)
/*++

Implements:

    IRmsMediaSet::SetMediaSetType

--*/
{
    m_MediaSetType = (RmsMediaSet) type;
    m_isDirty = TRUE;
    return S_OK;
}


STDMETHODIMP
CRmsMediaSet::GetMaxCartridges(
    OUT LONG *pNum)
/*++

Implements:

    IRmsMediaSet::GetMaxCartridges

--*/
{
    HRESULT hr = S_OK;

    try {
        WsbAssertPointer (pNum);

        *pNum = m_MaxCartridges;

    } WsbCatch(hr);

    return hr;
}


STDMETHODIMP
CRmsMediaSet::SetMaxCartridges(
    IN LONG num)
/*++

Implements:

    IRmsMediaSet::SetMaxCartridges

--*/
{
    m_MaxCartridges = num;
    m_isDirty = TRUE;
    return S_OK;
}


STDMETHODIMP
CRmsMediaSet::GetOccupancy(
    OUT LONG *pNum)
/*++

Implements:

    IRmsMediaSet::GetOccupancy

--*/
{
    HRESULT hr = S_OK;

    try {
        WsbAssertPointer (pNum);

        *pNum = m_Occupancy;

    } WsbCatch(hr);

    return hr;
}


STDMETHODIMP
CRmsMediaSet::SetOccupancy(
    IN LONG num)
/*++

Implements:

    IRmsMediaSet::SetOccupancy

--*/
{
    m_Occupancy = num;
    m_isDirty = TRUE;
    return S_OK;
}



STDMETHODIMP
CRmsMediaSet::IsMediaCopySupported(void)
/*++

Implements:

    IRmsMediaSet::IsMediaCopySupported

--*/
{
    HRESULT hr = S_OK;

    WsbTraceIn(OLESTR("CRmsMediaSet::IsMediaCopySupported"), OLESTR(""));

    try {

        if (RmsMediaSetNTMS == m_MediaSetType) {

            CComQIPtr<IRmsServer, &IID_IRmsServer> pServer = g_pServer;
            CComPtr<IRmsNTMS> pNtms;
            WsbAffirmHr(pServer->GetNTMS(&pNtms));
            WsbAffirmPointer(pNtms);

            m_IsMediaCopySupported = (S_OK == pNtms->IsMediaCopySupported(m_objectId)) ? TRUE : FALSE;
            
        }

        hr = ( m_IsMediaCopySupported ) ? S_OK : S_FALSE;

    } WsbCatch(hr)



    WsbTraceOut(OLESTR("CRmsMediaSet::IsMediaCopySupported"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP
CRmsMediaSet::SetIsMediaCopySupported(
    IN BOOL flag)
/*++

Implements:

    IRmsMediaSet::SetIsMediaCopySupported

--*/
{
    m_IsMediaCopySupported = flag;
    m_isDirty = TRUE;
    return S_OK;
}


STDMETHODIMP
CRmsMediaSet::Allocate(
    IN REFGUID prevSideId,
    IN OUT LONGLONG *pFreeSpace,
    IN BSTR displayName,
    IN DWORD dwOptions,
    OUT IRmsCartridge **ppCart)
/*++

Implements:

    IRmsMediaSet::Allocate

--*/
{

    HRESULT hr = S_OK;

    WsbTraceIn(OLESTR("CRmsMediaSet::Allocate"), OLESTR("<%ls> <%ls> <0x%08x>"),
        WsbQuickString(WsbPtrToStringAsString((WCHAR **)&displayName)),
        WsbQuickString(WsbPtrToLonglongAsString(pFreeSpace)),
        dwOptions );

    try {
        WsbAssertPointer(ppCart);

        CComQIPtr<IRmsServer, &IID_IRmsServer> pServer = g_pServer;

        switch (m_MediaSetType) {
        case RmsMediaSetLibrary:
            {
                CComPtr<IWsbIndexedCollection>  pCarts;
                CComPtr<IRmsCartridge>          pFindCart;

                // Get the cartridge collection
                WsbAffirmHr(pServer->GetCartridges(&pCarts));

                // Create a cartridge template
                WsbAffirmHr(CoCreateInstance(CLSID_CRmsCartridge, 0, CLSCTX_SERVER, IID_IRmsCartridge, (void **)&pFindCart));

                // Fill in the find template

                // Using FindByScratchMediaCriteria
                CComQIPtr<IRmsComObject, &IID_IRmsComObject> pObject = pFindCart;
                WsbAssertHr(pObject->SetFindBy(RmsFindByScratchMediaCriteria));

                // Scratch selection criteria
                WsbAssertHr(pFindCart->SetStatus(RmsStatusScratch));
                WsbAssertHr(pFindCart->SetLocation(RmsElementUnknown, GUID_NULL, m_objectId, 0, 0, 0, 0, FALSE));

                // Now find the cartridge
                hr = pCarts->Find(pFindCart, IID_IRmsCartridge, (void **)ppCart);
                if (WSB_E_NOTFOUND == hr) {
                    WsbThrow(RMS_E_SCRATCH_NOT_FOUND_FINAL);
                }
                WsbAffirmHr(hr);

                // Set media name and description to display name
                WsbAffirmPointer(*ppCart);
                WsbAffirmHr((*ppCart)->SetName(displayName));
                WsbAffirmHr((*ppCart)->SetDescription(displayName));
            }
            break;
        case RmsMediaSetNTMS:
            {
                CComPtr<IRmsNTMS> pNtms;
                WsbAffirmHr(pServer->GetNTMS(&pNtms));
                WsbAffirmHr(pNtms->Allocate(m_objectId, prevSideId, pFreeSpace, displayName, dwOptions, ppCart));
            }
            break;
        case RmsMediaSetShelf:
        case RmsMediaSetOffSite:
        case RmsMediaSetFolder:
        case RmsMediaSetUnknown:
        default:
            WsbThrow(E_UNEXPECTED);
            break;
        }

        (void) InterlockedIncrement(&m_Occupancy);

    } WsbCatch(hr)


    WsbTraceOut(OLESTR("CRmsMediaSet::Allocate"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;

}


STDMETHODIMP
CRmsMediaSet::Deallocate(
        IN IRmsCartridge *pCart)
/*++

Implements:

    IRmsMediaSet::Deallocate

--*/
{

    HRESULT hr = S_OK;

    WsbTraceIn(OLESTR("CRmsMediaSet::Deallocate"), OLESTR(""));

    try {
        WsbAssertPointer (pCart);

        CComQIPtr<IRmsServer, &IID_IRmsServer> pServer = g_pServer;

        switch (m_MediaSetType) {
        case RmsMediaSetLibrary:
            {
                WsbAffirmHr(pCart->SetStatus(RmsStatusScratch));
            }
            break;
        case RmsMediaSetNTMS:
            {
                CComPtr<IRmsNTMS> pNtms;
                WsbAffirmHr(pServer->GetNTMS(&pNtms));
                WsbAffirmHr(pNtms->Deallocate(pCart));
            }
            break;
        case RmsMediaSetShelf:
        case RmsMediaSetOffSite:
        case RmsMediaSetFolder:
        case RmsMediaSetUnknown:
        default:
            WsbThrow(E_UNEXPECTED);
            break;
        }

        (void) InterlockedDecrement(&m_Occupancy);

    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CRmsMediaSet::Deallocate"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\rms\server\rmslocat.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    RmsLocat.h

Abstract:

    Declaration of the CRmsLocator class

Author:

    Brian Dodd          [brian]         15-Nov-1996

Revision History:

--*/

#ifndef _RMSLOCAT_
#define _RMSLOCAT_

#include "resource.h"       // resource symbols

/*++

Class Name:

    CRmsLocator

Class Description:

    A CRmsLocator specifies a physical location for a cartridge or
    chanager element.

--*/

class CRmsLocator
{
public:
    CRmsLocator();

// CRmsLocator
public:
    HRESULT GetSizeMax(ULARGE_INTEGER* pSize);
    HRESULT Load(IStream* pStream);
    HRESULT Save(IStream* pStream, BOOL clearDirty);

    HRESULT CompareTo(IUnknown* pCollectable, SHORT* pResult);

    HRESULT Test(USHORT *pPassed, USHORT *pFailed);

// IRmsLocator
public:
    STDMETHOD(GetLocation)(LONG *pType, GUID *pLibId, GUID *pMediaSetId, LONG *pPos, LONG *pAlt1, LONG *pAlt2, LONG *pAlt3, BOOL *pInvert);
    STDMETHOD(SetLocation)(LONG type, GUID libId, GUID mediaSetId, LONG pos, LONG alt1, LONG alt2, LONG alt3, BOOL invert);

public:

    enum {                                  // Class specific constants:
                                            //
        Version = 1,                        // Class version, this should be
                                            //   incremented each time the
                                            //   the class definition changes.
    };                                      //
    RmsElement      m_type;                 // The type of element this location
                                            //   refers to (i.e. storage, drive).
    GUID            m_libraryId;            // The guid for the Library housing
                                            //   the Cartridge.
    GUID            m_mediaSetId;           // The guid for the MediaSet housing
                                            //   the Cartridge.
    LONG            m_position;             // The ordinal number of the storage location.
    LONG            m_alternate1;           // First alternate position specifier
                                            //   (i.e. building number).
    LONG            m_alternate2;           // Second alternate position specifier
                                            //   (i.e. room number).
    LONG            m_alternate3;           // Third alternate position specifier
                                            //   (i.e. shelf number).
    BOOL            m_invert;               // If TRUE, the medium is inverted in this
                                            //   storage location.
};

#endif // _RMSLOCAT_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\rms\server\rmsntms.h ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    RmsNTMS.h

Abstract:

    Declaration of the CRmsNTMS class

Author:

    Brian Dodd          [brian]         15-Nov-1996

Revision History:

--*/

#ifndef _RMSNTMS_
#define _RMSNTMS_

#include "ntmsapi.h"

#include "resource.h"       // main symbols

#include "RmsObjct.h"       // CRmsComObject

/*++

Class Name:

    CRmsNTMS

Class Description:

    A CRmsNTMS represents...

--*/


class CRmsNTMS :
    public CComDualImpl<IRmsNTMS, &IID_IRmsNTMS, &LIBID_RMSLib>,
    public CRmsComObject,
    public CComObjectRoot,
    public IConnectionPointContainerImpl<CRmsNTMS>,
    public IConnectionPointImpl<CRmsNTMS, &IID_IRmsSinkEveryEvent, CComDynamicUnkArray>,
    public CComCoClass<CRmsNTMS,&CLSID_CRmsNTMS>
{
public:
    CRmsNTMS() {}
BEGIN_COM_MAP(CRmsNTMS)
    COM_INTERFACE_ENTRY2(IDispatch, IRmsNTMS)
    COM_INTERFACE_ENTRY(IRmsNTMS)
    COM_INTERFACE_ENTRY(IRmsComObject)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
    COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_RmsNTMS)
DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_CONNECTION_POINT_MAP(CRmsNTMS)
    CONNECTION_POINT_ENTRY(IID_IRmsSinkEveryEvent)
END_CONNECTION_POINT_MAP()

// CComObjectRoot
public:
    STDMETHOD(FinalConstruct)(void);
    STDMETHOD(FinalRelease)(void);

// IRmsNTMS
public:
    STDMETHOD(IsInstalled)(void);
    STDMETHOD(Initialize)(void);

    STDMETHOD(Allocate)(
        IN REFGUID fromMediaSet,
        IN REFGUID prevSideId,
        IN OUT LONGLONG *pFreeSpace,
        IN BSTR displayName,
        IN DWORD dwOptions,
        OUT IRmsCartridge **ppCartridge);

    STDMETHOD(Mount)(
        IN IRmsCartridge *pCart,
        OUT IRmsDrive **ppDrive,
		IN DWORD dwOptions = RMS_NONE,
        IN DWORD threadId = 0);

    STDMETHOD(Dismount)(
        IN IRmsCartridge *pCart, 
		IN DWORD dwOptions = RMS_NONE);

    STDMETHOD(Deallocate)(
        IN IRmsCartridge *pCart);

    STDMETHOD(UpdateOmidInfo)(
        IN REFGUID cartId,
        IN BYTE *pBuffer,
        IN LONG size,
        IN LONG type);

    STDMETHOD(GetBlockSize)(
        IN REFGUID cartId,
        OUT LONG *pBlockSize);

    STDMETHOD(SetBlockSize)(
        IN REFGUID cartId,
        IN LONG blockSize);

    STDMETHOD(ExportDatabase)(void);

    STDMETHOD(FindCartridge)(
        IN REFGUID cartId,
        OUT IRmsCartridge **ppCartridge);

    STDMETHOD(Suspend)(void);
    STDMETHOD(Resume)(void);

    STDMETHOD(IsMediaCopySupported)(
        IN REFGUID mediaPoolId);

    STDMETHOD(UpdateDrive)(
        IN IRmsDrive *pDrive);

    STDMETHOD(GetNofAvailableDrives)( 
        OUT DWORD *pdwNofDrives 
    );

    STDMETHOD(CheckSecondSide)( 
        IN REFGUID firstSideId,
        OUT BOOL *pbValid,
        OUT GUID *pSecondSideId
    );

    STDMETHOD(DismountAll)(
        IN REFGUID fromMediaSet,
		IN DWORD dwOptions = RMS_NONE);

// CRmsNTMS - these may go public
private:
    HRESULT findFirstNtmsObject(
        IN DWORD objectType,
        IN REFGUID containerId,
        IN WCHAR *objectName,
        IN REFGUID objectId,
        OUT HANDLE *hFindObject,
        OUT LPNTMS_OBJECTINFORMATION pFindObjectData);

    HRESULT findNextNtmsObject(
        IN HANDLE hFindObject,
        OUT LPNTMS_OBJECTINFORMATION pFindObjectData);

    HRESULT findCloseNtmsObject(
        IN HANDLE hFindObject);

    HRESULT getNtmsSupportFromRegistry(
        OUT DWORD *pNtmsSupport);

    HRESULT reportNtmsObjectInformation(
        IN LPNTMS_OBJECTINFORMATION pObjectInfo);

    HRESULT beginSession(void);
    HRESULT endSession(void);
    HRESULT waitUntilReady(void);
    HRESULT waitForScratchPool(void);
    HRESULT createMediaPools(void);
    HRESULT replicateScratchMediaPool(IN REFGUID rootPoolId);
    HRESULT createMediaPoolForEveryMediaType(IN REFGUID rootPoolId);
    HRESULT isReady(void);
    HRESULT setPoolDACL(
        IN OUT NTMS_GUID *pPoolId,
        IN DWORD subAuthority,
        IN DWORD action,
        IN DWORD mask);

    HRESULT EnsureAllSidesNotAllocated(
        IN REFGUID physicalMediaId);

private:
    enum {                                  // Class specific constants:
                                            //
        Version = 1,                        // Class version, this should be
                                            //   incremented each time the
                                            //   the class definition changes.
        };
    HANDLE      m_SessionHandle;
    BOOL        m_IsRmsConfiguredForNTMS;
    BOOL        m_IsNTMSRegistered;

    DWORD       m_NotificationWaitTime;     // Milliseconds to wait for an object notification
    DWORD       m_AllocateWaitTime;         // Milliseconds to wait for a media allocation
    DWORD       m_MountWaitTime;            // Milliseconds to wait for a mount
    DWORD       m_RequestWaitTime;          // Milliseconds to wait for a request

    LPNTMS_GUID m_pLibGuids;               // Libraries which may have HSM medias (collected during initialization)
    DWORD       m_dwNofLibs;

    static HRESULT storageMediaTypeToRmsMedia(
        IN NTMS_MEDIATYPEINFORMATION *pMediaTypeInfo,
        OUT RmsMedia *pTranslatedMediaType);

    HRESULT changeState( IN LONG newState );

// Thread routines
public:
    static DWORD WINAPI InitializationThread(
        IN LPVOID pv);

    HRESULT InitializeInAnotherThread(void);

};

#endif // _RMSNTMS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\hsm\rms\server\rmsntms.cpp ===
/*++

 1998 Seagate Software, Inc.  All rights reserved

Module Name:

    RmsNTMS.cpp

Abstract:

    Implementation of CRmsNTMS

Author:

    Brian Dodd          [brian]         14-May-1997

Revision History:

--*/

#include "stdafx.h"

#include "RmsServr.h"
#include "RmsNTMS.h"

typedef struct RmsNTMSSearchHandle {
    WCHAR       FindName[NTMS_OBJECTNAME_LENGTH];
    NTMS_GUID   FindId;
    DWORD       FindType;
    LPNTMS_GUID Objects;
    DWORD       NumberOfObjects;
    DWORD       MaxObjects;
    DWORD       Next;
    DWORD       LastError;
} RMS_NTMS_SEARCH_HANDLE, *LPRMS_NTMS_SEARCH_HANDLE;

#define ADD_ACE_MASK_BITS 1
#define REMOVE_ACE_MASK_BITS 2

//
// We use application name in RSM interface for media pool name.
//  Media pool name is an identifier of the media pool in RSM, therefore, we cannot allow 
//  this string to be localized. Localizing this string would create another pool after 
//  installing a foreign language MUI.
//
#define REMOTE_STORAGE_APP_NAME     OLESTR("Remote Storage")



/////////////////////////////////////////////////////////////////////////////
// IRmsNTMS implementation

/*
    HINSTANCE       hInstDll;
    typedef DWORD (*FunctionName)( void );
    FunctionName    FunctionNameFn;
    hInstDll = LoadLibrary( "dll" );
    FunctionNameFn = (FunctionName) GetProcAddress( hInstDll, "FunctionName" );
    result = (FunctionNameFn)();
*/


STDMETHODIMP
CRmsNTMS::FinalConstruct(void)
/*++

Implements:

    CComObjectRoot::FinalConstruct

--*/
{
    HRESULT     hr = S_OK;
    CComQIPtr<IRmsComObject, &IID_IRmsComObject> pObject = this;

    WsbTraceIn(OLESTR("CRmsNTMS::FinalConstruct"), OLESTR(""));

    m_pLibGuids = NULL;
    m_dwNofLibs = 0;

    try {
        WsbAffirmHr(CComObjectRoot::FinalConstruct());

        WsbAffirmHr( changeState( RmsNtmsStateStarting ));

        m_SessionHandle = INVALID_HANDLE_VALUE;
        m_IsRmsConfiguredForNTMS = FALSE;
        m_IsNTMSRegistered = FALSE;
        m_Name = RMS_NTMS_OBJECT_NAME;
        m_Description = RMS_NTMS_OBJECT_DESCRIPTION;

        if ( S_OK == getNtmsSupportFromRegistry(NULL) ) {
            m_IsRmsConfiguredForNTMS = TRUE;
        }

        HKEY hKeyMachine = 0;
        HKEY hKey        = 0;

        if ( S_OK == WsbOpenRegistryKey(NULL, RMS_NTMS_REGISTRY_STRING, KEY_QUERY_VALUE, &hKeyMachine, &hKey) ) {
            WsbCloseRegistryKey (&hKeyMachine, &hKey);
            m_IsNTMSRegistered = TRUE;
        }

        // Failure precedence.
        WsbAffirm(m_IsRmsConfiguredForNTMS, RMS_E_NOT_CONFIGURED_FOR_NTMS);
        WsbAffirm(m_IsNTMSRegistered, RMS_E_NTMS_NOT_REGISTERED);

        WsbAffirmHr( changeState( RmsNtmsStateStarted ));

    } WsbCatchAndDo(hr,
            pObject->Disable( hr );
            WsbLogEvent(RMS_MESSAGE_NTMS_CONNECTION_NOT_ESABLISHED, 0, NULL, WsbHrAsString(hr), NULL);

            // Always construct!
            hr = S_OK;
        );

    WsbTraceOut(OLESTR("CRmsNTMS::FinalConstruct"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP
CRmsNTMS::FinalRelease(void)
/*++

Implements:

    CComObjectRoot::FinalRelease

--*/
{
    HRESULT hr = S_OK;

    WsbTraceIn(OLESTR("CRmsNTMS::FinalRelease"), OLESTR(""));

    try {

        WsbAffirmHr( changeState( RmsNtmsStateStopping ));

        endSession();

        if (m_pLibGuids) {
            WsbFree(m_pLibGuids);
        }

        CComObjectRoot::FinalRelease();

        WsbAffirmHr( changeState( RmsNtmsStateStopped ));

    } WsbCatch(hr);


    WsbTraceOut(OLESTR("CRmsNTMS::FinalRelease"), OLESTR("hr = <%ls>"), WsbHrAsString(hr));

    return hr;
}


STDMETHODIMP 
CRmsNTMS::IsInstalled(void)
{
    HRESULT hr = S_OK;

    try {

        if ( !m_IsEnabled ) {

            if ( !m_IsNTMSRegistered ) {
                // check again... NTMS can get registered at anytime.
                HKEY hKeyMachine = 0;
                HKEY hKey        = 0;

                WsbAffirm(S_OK == WsbOpenRegistryKey(NULL, RMS_NTMS_REGISTRY_STRING, KEY_QUERY_VALUE, &hKeyMachine, &hKey), RMS_E_NTMS_NOT_REGISTERED);
                WsbCloseRegistryKey (&hKeyMachine, &hKey);

                m_IsNTMSRegistered = TRUE;

                CComQIPtr<IRmsComObject, &IID_IRmsComObject> pObject = this;
                pObject->Enable();

                // now need to initialize
                WsbAffirmHr(InitializeInAnotherThread());
            }

            WsbAffirm(m_IsRmsConfiguredForNTMS, RMS_E_NOT_CONFIGURED_FOR_NTMS);
            WsbAffirm(m_IsNTMSRegistered, RMS_E_NTMS_NOT_REGISTERED);

        }

    } WsbCatch(hr);

    return hr;
}


STDMETHODIMP
CRmsNTMS::Initialize(void)
{
    HRESULT hr = E_FAIL;
    CComQIPtr<IRmsComObject, &IID_IRmsComObject> pObject = this;

    WsbTraceIn(OLESTR("CRmsNTMS::Initialize"), OLESTR(""));

    try {

        WsbAffirmHr( changeState( RmsNtmsStateInitializing ));

        if ( INVALID_HANDLE_VALUE == m_SessionHandle ) {
            WsbAffirmHr(beginSession());
        }

        HANDLE hSession = m_SessionHandle;

        //
        // Create Remote Storage specific NTMS media pools
        //

        WsbAffirmHr( createMediaPools() );

        //
        // Report on other NTMS objects of interest
        //

        HANDLE hFind = NULL;
        NTMS_OBJECTINFORMATION  objectInfo;

        hr = findFirstNtmsObject( NTMS_MEDIA_TYPE, GUID_NULL, NULL, GUID_NULL, &hFind, &objectInfo);
        while( S_OK == hr ) {
            reportNtmsObjectInformation( &objectInfo );
            hr = findNextNtmsObject( hFind, &objectInfo );
        }
        findCloseNtmsObject( hFind );

        hr = findFirstNtmsObject( NTMS_CHANGER, GUID_NULL, NULL, GUID_NULL, &hFind, &objectInfo);
        while( S_OK == hr ) {
            reportNtmsObjectInformation( &objectInfo );
            hr = findNextNtmsObject( hFind, &objectInfo );
        }
        findCloseNtmsObject( hFind );

        hr = findFirstNtmsObject( NTMS_CHANGER_TYPE, GUID_NULL, NULL, GUID_NULL, &hFind, &objectInfo);
        while( S_OK == hr ) {
            reportNtmsObjectInformation( &objectInfo );
            hr = findNextNtmsObject( hFind, &objectInfo );
        }
        findCloseNtmsObject( hFind );

        hr = findFirstNtmsObject( NTMS_DRIVE, GUID_NULL, NULL, GUID_NULL, &hFind, &objectInfo);
        while( S_OK == hr ) {
            reportNtmsObjectInformation( &objectInfo );
            hr = findNextNtmsObject( hFind, &objectInfo );
        }
        findCloseNtmsObject( hFind );

        hr = findFirstNtmsObject( NTMS_DRIVE_TYPE, GUID_NULL, NULL, GUID_NULL, &hFind, &objectInfo);
        while( S_OK == hr ) {
            reportNtmsObjectInformation( &objectInfo );
            hr = findNextNtmsObject( hFind, &objectInfo );
        }
        findCloseNtmsObject( hFind );

        WsbAffirmHr( changeState( RmsNtmsStateReady ));
        hr = S_OK;

    } WsbCatchAndDo(hr,
            pObject->Disable( hr );
            WsbLogEvent( RMS_MESSAGE_NTMS_INITIALIZATION_FAILED, 0, NULL, WsbHrAsString(hr), NULL );
        );


    WsbTraceOut( OLESTR("CRmsNTMS::Initialize"), OLESTR("hr = <%ls>"), WsbHrAsString(hr) );

    return hr;
}


HRESULT 
CRmsNTMS::findFirstNtmsObject(
    IN DWORD objectType,
    IN REFGUID containerId,
    IN WCHAR *objectName,
    IN REFGUID objectId,
    OUT HANDLE *hFindObject,
    OUT LPNTMS_OBJECTINFORMATION pFindObjectData
    )
{

    HRESULT hr = E_FAIL;

    try {
        int maxObjects = 16;  // Initial size of object id array to allocate
        
        LPRMS_NTMS_SEARCH_HANDLE pFind;

        HANDLE hSession = m_SessionHandle;
        DWORD errCode;
        DWORD numberOfObjects = maxObjects;
        LPNTMS_GUID pId = ( containerId == GUID_NULL ) ? NULL : (GUID *)&containerId;
        LPNTMS_GUID  pObjects = NULL;
        NTMS_OBJECTINFORMATION objectInfo;

        WsbAssertPointer( hFindObject );


        if ( INVALID_HANDLE_VALUE == hSession ) {
            WsbThrow( E_UNEXPECTED );
        }

        *hFindObject = NULL;

        memset( &objectInfo, 0, sizeof( NTMS_OBJECTINFORMATION ) );

        pObjects = (LPNTMS_GUID)WsbAlloc( maxObjects*sizeof(NTMS_GUID) );
        WsbAffirmPointer( pObjects );

        // NTMS - enumerate all objects of the given type
        WsbTraceAlways(OLESTR("EnumerateNtmsObject()\n"));
        errCode = EnumerateNtmsObject( hSession, pId, pObjects, &numberOfObjects, objectType, 0 );

        if ( (ERROR_OBJECT_NOT_FOUND == errCode) || (0 == numberOfObjects) ) {  // Don't count on NTMS returning the correct errCode
            WsbThrow( RMS_E_NTMS_OBJECT_NOT_FOUND );
        }
        else if ( ERROR_INSUFFICIENT_BUFFER == errCode ) {

            while ( ERROR_INSUFFICIENT_BUFFER == errCode ) {
                // Allocate a new buffer, and retry.
                WsbTrace(OLESTR("CRmsNTMS::findFirstNtmsObject - Reallocating for %d objects @1.\n"), numberOfObjects);
                maxObjects = numberOfObjects;
                LPVOID pTemp = WsbRealloc( pObjects, maxObjects*sizeof(NTMS_GUID) );
                if( !pTemp ) {
                    WsbFree( pObjects );
                    WsbThrow( E_OUTOFMEMORY );
                }
                pObjects = (LPNTMS_GUID)pTemp;

                // NTMS - enumerate all objects of the given type
                WsbTraceAlways(OLESTR("EnumerateNtmsObject()\n"));
                errCode = EnumerateNtmsObject( hSession, pId, pObjects, &numberOfObjects, objectType, 0 );
            }
        }
        WsbAffirmNoError( errCode );

        HANDLE hTemp = (HANDLE)WsbAlloc( sizeof( RMS_NTMS_SEARCH_HANDLE) );
        *hFindObject = hTemp;
        WsbAffirmPointer( *hFindObject );

        pFind = (LPRMS_NTMS_SEARCH_HANDLE)*hFindObject;

        // Initialize the search handle
        if ( objectName ) {
            wcscpy( pFind->FindName, objectName );
        }
        else {
            wcscpy( pFind->FindName, OLESTR("") );
        }

        pFind->FindId           = objectId;
        pFind->FindType         = objectType;
        pFind->Objects          = pObjects;
        pFind->NumberOfObjects  = numberOfObjects;
        pFind->MaxObjects       = maxObjects;
        pFind->Next             = 0;
        pFind->LastError        = NO_ERROR;

        BOOL bFound = FALSE;

        while( pFind->Next < pFind->NumberOfObjects ) {

            objectInfo.dwType = pFind->FindType;
            objectInfo.dwSize = sizeof( NTMS_OBJECTINFORMATION );

            // NTMS - Get object information
            WsbTraceAlways(OLESTR("GetNtmsObjectInformation()\n"));
            errCode = GetNtmsObjectInformation( hSession, &pObjects[pFind->Next++], &objectInfo );
            pFind->LastError = errCode;

            // Media Pools require special handling because they contain other Media Pools
            if ( (NTMS_MEDIA_POOL == pFind->FindType) &&
                (objectInfo.Info.MediaPool.dwNumberOfMediaPools > 0) ) {

                DWORD numberToAdd = objectInfo.Info.MediaPool.dwNumberOfMediaPools;
                do {
                    numberOfObjects = pFind->NumberOfObjects + numberToAdd;

                    // Allocate a new buffer, and retry.
                    WsbTrace(OLESTR("CRmsNTMS::findFirstNtmsObject - Reallocating for %d objects @2.\n"), numberOfObjects);
                    maxObjects = numberOfObjects;
                    pObjects = (LPNTMS_GUID)WsbRealloc( pFind->Objects, maxObjects*sizeof(NTMS_GUID) );
                    WsbAffirmAlloc( pObjects );
                    pFind->Objects = pObjects;

                    // NTMS - enumerate all objects of the given type
                    WsbTraceAlways(OLESTR("EnumerateNtmsObject()\n"));
                    errCode = EnumerateNtmsObject( hSession,
                        &objectInfo.ObjectGuid, &pObjects[pFind->NumberOfObjects],
                        &numberToAdd, pFind->FindType, 0 );
                } while ( ERROR_INSUFFICIENT_BUFFER == errCode ) ;

                if ( NO_ERROR == errCode ) {
                    pFind->NumberOfObjects += numberToAdd;
                    pFind->MaxObjects = maxObjects;
                }
                else {
                    WsbLogEvent( RMS_MESSAGE_NTMS_FAILURE, 0, NULL,
                        OLESTR("EnumerateNtmsObject"),
                        WsbHrAsString(HRESULT_FROM_WIN32(errCode)),
                        NULL );
                    WsbAffirmNoError(errCode);
                }
            }

            if ( NO_ERROR == pFind->LastError ) {

                // Now see if it is the one we're looking for

                if ( GUID_NULL != pFind->FindId ) {

                    if ( pFind->FindId == objectInfo.ObjectGuid ) {     // Match the GUID

                        bFound = TRUE;
                        if ( pFindObjectData != NULL ) {
                            memcpy( pFindObjectData, &objectInfo, sizeof( NTMS_OBJECTINFORMATION ) );
                        }
                        break;

                    }
                }
                else if ( wcslen( pFind->FindName ) > 0 ) {             // Match the Name

                    if ( 0 == wcscmp( pFind->FindName, objectInfo.szName ) ) {

                        bFound = TRUE;
                        if ( pFindObjectData != NULL ) {
                            memcpy( pFindObjectData, &objectInfo, sizeof( NTMS_OBJECTINFORMATION ) );
                        }

                        break;

                    }

                }
                else {                                                  // Any GUID or Name

                    bFound = TRUE;
                    if ( pFindObjectData != NULL ) {
                        memcpy( pFindObjectData, &objectInfo, sizeof( NTMS_OBJECTINFORMATION ) );
                    }
                    break;

                }

            }
            else {
                WsbLogEvent( RMS_MESSAGE_NTMS_FAILURE, 0, NULL,
                    OLESTR("GetNTMSObjectInformation"),
                    WsbHrAsString(HRESULT_FROM_WIN32(errCode)),
                    NULL );
                WsbThrow( RMS_E_NTMS_OBJECT_NOT_FOUND );
            }

        }

        hr = ( bFound ) ? S_OK : RMS_E_NTMS_OBJECT_NOT_FOUND;

    } WsbCatch(hr);

    return hr;
}


HRESULT 
CRmsNTMS::findNextNtmsObject(
    IN HANDLE hFindObject,
    OUT LPNTMS_OBJECTINFORMATION pFindObjectData
    )
{
    HRESULT hr = E_FAIL;

    try {

        HANDLE hSession = m_SessionHandle;
        DWORD errCode;

        LPRMS_NTMS_SEARCH_HANDLE pFind = (LPRMS_NTMS_SEARCH_HANDLE)hFindObject;

        LPNTMS_GUID pObjects = pFind->Objects;

        NTMS_OBJECTINFORMATION objectInfo;

        if ( INVALID_HANDLE_VALUE == hSession ) {
            WsbThrow( E_UNEXPECTED );
        }

        BOOL bFound = FALSE;

        while( pFind->Next < pFind->NumberOfObjects ) {

            objectInfo.dwType = pFind->FindType;
            objectInfo.dwSize = sizeof( NTMS_OBJECTINFORMATION );

            // NTMS - get object information of next object
            WsbTraceAlways(OLESTR("GetNtmsObjectInformation()\n"));
            errCode = GetNtmsObjectInformation( hSession, &pObjects[pFind->Next++], &objectInfo );
            pFind->LastError = errCode;

            // Media Pools require special handling because they contain other Media Pools
            if ( (NTMS_MEDIA_POOL == pFind->FindType) &&
                (objectInfo.Info.MediaPool.dwNumberOfMediaPools > 0) ) {

                DWORD maxObjects;
                DWORD numberOfObjects;
                DWORD numberToAdd = objectInfo.Info.MediaPool.dwNumberOfMediaPools;
                do {
                    numberOfObjects = pFind->NumberOfObjects + numberToAdd;

                    // Allocate a new buffer, and retry.
                    WsbTrace(OLESTR("CRmsNTMS::findNextNtmsObject - Reallocating for %d objects.\n"), numberOfObjects);
                    maxObjects = numberOfObjects;
                    pObjects = (LPNTMS_GUID)WsbRealloc( pFind->Objects, maxObjects*sizeof(NTMS_GUID) );
                    WsbAffirmAlloc( pObjects );
                    pFind->Objects = pObjects;

                    // NTMS - enumerate all objects of the given type
                    WsbTraceAlways(OLESTR("EnumerateNtmsObject()\n"));
                    errCode = EnumerateNtmsObject( hSession,
                        &objectInfo.ObjectGuid, &pObjects[pFind->NumberOfObjects],
                        &numberToAdd, pFind->FindType, 0 );
                } while ( ERROR_INSUFFICIENT_BUFFER == errCode ) ;

                if ( NO_ERROR == errCode ) {
                    pFind->NumberOfObjects += numberToAdd;
                    pFind->MaxObjects = maxObjects;
                }
                else {
                    WsbLogEvent( RMS_MESSAGE_NTMS_FAILURE, 0, NULL,
                        OLESTR("EnumerateNtmsObject"),
                        WsbHrAsString(HRESULT_FROM_WIN32(errCode)),
                        NULL );
                    WsbAffirmNoError(errCode);
                }
            }

            if ( NO_ERROR == pFind->LastError ) {

                // Now see if it is the one we're looking for

                if ( GUID_NULL != pFind->FindId ) {

                    if ( pFind->FindId == objectInfo.ObjectGuid ) {     // Match the GUID

                        bFound = TRUE;
                        if ( pFindObjectData != NULL ) {
                            memcpy( pFindObjectData, &objectInfo, sizeof( NTMS_OBJECTINFORMATION ) );
                        }
                        break;

                    }
                }
                else if ( wcslen( pFind->FindName ) > 0 ) {             // Match the Name

                    if ( 0 == wcscmp( pFind->FindName, objectInfo.szName ) ) {

                        bFound = TRUE;
                        if ( pFindObjectData != NULL ) {
                            memcpy( pFindObjectData, &objectInfo, sizeof( NTMS_OBJECTINFORMATION ) );
                        }
                        break;

                    }

                }
                else {                                                  // Any GUID or Name

                    bFound = TRUE;
                    if ( pFindObjectData != NULL ) {
                        memcpy( pFindObjectData, &objectInfo, sizeof( NTMS_OBJECTINFORMATION ) );
                    }
                    break;

                }

            }
            else {
                WsbLogEvent( RMS_MESSAGE_NTMS_FAILURE, 0, NULL,
                    OLESTR("GetNTMSObjectInformation"),
                    WsbHrAsString(HRESULT_FROM_WIN32(errCode)),
                    NULL );
                WsbThrow( RMS_E_NTMS_OBJECT_NOT_FOUND );
            }
        }

        hr = (bFound) ? S_OK : RMS_E_NTMS_OBJECT_NOT_FOUND;

    } WsbCatch(hr);

    return hr;
}


HRESULT 
CRmsNTMS::findCloseNtmsObject(
    IN HANDLE hFindObject)
{
    HRESULT hr = S_OK;

    try {

        WsbAffirmPointer(hFindObject); // We don't need to assert here... It's possible to call
                                       // findCloseNtmsObject even if nothing was found with
                                       // findFirstNtmsObject.  Skip the free step.
        WsbFree(((LPRMS_NTMS_SEARCH_HANDLE)hFindObject)->Objects);
        WsbFree(hFindObject);

    } WsbCatch(hr);


    return hr;
}


HRESULT 
CRmsNTMS::reportNtmsObjectInformation(
    IN LPNTMS_OBJECTINFORMATION pObjectInfo)
{

    HRESULT hr = S_OK;

    static DWORD lastTypeReported = 0;

    try {
        WsbAssertPointer( pObjectInfo );

        BOOL bHeaders = (lastTypeReported == pObjectInfo->dwType) ? FALSE : TRUE;

        lastTypeReported = pObjectInfo->dwType;

        // Output a header to trace file

        if ( bHeaders ) {
            switch ( pObjectInfo->dwType ) {

            case NTMS_UNKNOWN:
            case NTMS_OBJECT:
                WsbTrace( OLESTR("!!! WARNING !!! - CRmsServer::reportNtmsObjectInformation: report for NTMS object type: %d is not available.\n") );
                break;

            case NTMS_CHANGER:
                break;

            case NTMS_CHANGER_TYPE:
                break;

            case NTMS_COMPUTER:
                WsbTrace( OLESTR("!!! WARNING !!! - CRmsServer::reportNtmsObjectInformation: report for NTMS object type: %d is not available.\n") );
                break;

            case NTMS_DRIVE:
            case NTMS_DRIVE_TYPE:
                break;

            case NTMS_IEDOOR:
            case NTMS_IEPORT:
                WsbTrace( OLESTR("!!! WARNING !!! - CRmsServer::reportNtmsObjectInformation: report for NTMS object type: %d is not available.\n") );
                break;

            case NTMS_LIBRARY:
                break;

            case NTMS_LIBREQUEST:
            case NTMS_LOGICAL_MEDIA:
                WsbTrace( OLESTR("!!! WARNING !!! - CRmsServer::reportNtmsObjectInformation: report for NTMS object type: %d is not available.\n") );
                break;

            case NTMS_MEDIA_POOL:
                WsbTrace( OLESTR("GUID                                   Enabl Type Media Type GUID                        Parent GUID                            A-Pol D-Pol Allocate Physical  Logical Pools Name / Description\n") );
                WsbTrace( OLESTR("====================================== ===== ==== ====================================== ====================================== ===== ===== ======== ======== ======== ===== ========================================\n") );
                break;

            case NTMS_MEDIA_TYPE:

                WsbTrace( OLESTR("GUID                                   Enabl Type Sides RW Name / Description\n") );
                WsbTrace( OLESTR("====================================== ===== ==== ===== == ========================================\n") );
                break;

            case NTMS_PARTITION:
                 break;

            case NTMS_PHYSICAL_MEDIA:
            case NTMS_STORAGESLOT:
            case NTMS_OPREQUEST:
            default:
                WsbTrace( OLESTR("!!! WARNING !!! - CRmsServer::reportNtmsObjectInformation: report for object type: %d is not supported\n") );
                break;
            }
        }

        // Convert SYSTEMTIME to FILETIME for output.

        SYSTEMTIME sCreated, sModified;
        FILETIME fCreated, fModified;

        sCreated = pObjectInfo->Created;
        sModified = pObjectInfo->Modified;

        SystemTimeToFileTime(&sCreated, &fCreated);
        SystemTimeToFileTime(&sModified, &fModified);


        switch ( pObjectInfo->dwType ) {

        case NTMS_UNKNOWN:
        case NTMS_OBJECT:
            break;

        case NTMS_CHANGER:

            WsbTrace(OLESTR("Changer %d Information:\n"), pObjectInfo->Info.Changer.Number );
            WsbTrace(OLESTR("  GUID...........  %-ls\n"), WsbGuidAsString(pObjectInfo->ObjectGuid) );
            WsbTrace(OLESTR("  Name...........  <%-ls>\n"), pObjectInfo->szName );
            WsbTrace(OLESTR("  Description....  <%-ls>\n"), pObjectInfo->szDescription );
            WsbTrace(OLESTR("  Enabled........  %-ls\n"), WsbBoolAsString(pObjectInfo->Enabled) );
            WsbTrace(OLESTR("  Op State.......  %-ls\n"), WsbLongAsString(pObjectInfo->dwOperationalState) );
            WsbTrace(OLESTR("  Created........  %-ls\n"), WsbFiletimeAsString(FALSE, fCreated) );
            WsbTrace(OLESTR("  Modified.......  %-ls\n"), WsbFiletimeAsString(FALSE, fModified) );
            WsbTrace(OLESTR("  Number.........  %-d\n"), pObjectInfo->Info.Changer.Number );
            WsbTrace(OLESTR("  Changer Type...  %-ls\n"), WsbGuidAsString(pObjectInfo->Info.Changer.ChangerType) );
            WsbTrace(OLESTR("  Serial Number..  <%-ls>\n"), pObjectInfo->Info.Changer.szSerialNumber );
            WsbTrace(OLESTR("  Revision.......  <%-ls>\n"), pObjectInfo->Info.Changer.szRevision );
            WsbTrace(OLESTR("  Device Name....  <%-ls>\n"), pObjectInfo->Info.Changer.szDeviceName );
            WsbTrace(OLESTR("  SCSI Port......  %-d\n"), pObjectInfo->Info.Changer.ScsiPort );
            WsbTrace(OLESTR("  SCSI Bus.......  %-d\n"), pObjectInfo->Info.Changer.ScsiBus );
            WsbTrace(OLESTR("  SCSI Target....  %-d\n"), pObjectInfo->Info.Changer.ScsiTarget );
            WsbTrace(OLESTR("  SCSI Lun.......  %-d\n"), pObjectInfo->Info.Changer.ScsiLun );
            WsbTrace(OLESTR("  Library.......   %-ls\n"), WsbGuidAsString(pObjectInfo->Info.Changer.Library) );

            break;

        case NTMS_CHANGER_TYPE:
            WsbTrace(OLESTR("Changer Type Information:\n") );
            WsbTrace(OLESTR("  GUID...........  %-ls\n"), WsbGuidAsString(pObjectInfo->ObjectGuid) );
            WsbTrace(OLESTR("  Name...........  <%-ls>\n"), pObjectInfo->szName );
            WsbTrace(OLESTR("  Description....  <%-ls>\n"), pObjectInfo->szDescription );
            WsbTrace(OLESTR("  Enabled........  %-ls\n"), WsbBoolAsString(pObjectInfo->Enabled) );
            WsbTrace(OLESTR("  Op State.......  %-ls\n"), WsbLongAsString(pObjectInfo->dwOperationalState) );
            WsbTrace(OLESTR("  Created........  %-ls\n"), WsbFiletimeAsString(FALSE, fCreated) );
            WsbTrace(OLESTR("  Modified.......  %-ls\n"), WsbFiletimeAsString(FALSE, fModified) );
            WsbTrace(OLESTR("  Vendor.........  <%-ls>\n"), pObjectInfo->Info.ChangerType.szVendor );
            WsbTrace(OLESTR("  Product........  <%-ls>\n"), pObjectInfo->Info.ChangerType.szProduct );
            WsbTrace(OLESTR("  Device Type....  %-d\n"), pObjectInfo->Info.ChangerType.DeviceType );
            break;

        case NTMS_COMPUTER:
            break;

        case NTMS_DRIVE:
            WsbTrace(OLESTR("Drive %d Information:\n"), pObjectInfo->Info.Drive.Number );
            WsbTrace(OLESTR("  GUID...........  %-ls\n"), WsbGuidAsString(pObjectInfo->ObjectGuid) );
            WsbTrace(OLESTR("  Name...........  <%-ls>\n"), pObjectInfo->szName );
            WsbTrace(OLESTR("  Description....  <%-ls>\n"), pObjectInfo->szDescription );
            WsbTrace(OLESTR("  Enabled........  %-ls\n"), WsbBoolAsString(pObjectInfo->Enabled) );
            WsbTrace(OLESTR("  Op State.......  %-ls\n"), WsbLongAsString(pObjectInfo->dwOperationalState) );
            WsbTrace(OLESTR("  Created........  %-ls\n"), WsbFiletimeAsString(FALSE, fCreated) );
            WsbTrace(OLESTR("  Modified.......  %-ls\n"), WsbFiletimeAsString(FALSE, fModified) );
            WsbTrace(OLESTR("  Number.........  %-d\n"), pObjectInfo->Info.Drive.Number );
            WsbTrace(OLESTR("  State..........  %-d\n"), pObjectInfo->Info.Drive.State );
            WsbTrace(OLESTR("  Drive Type.....  %-ls\n"), WsbGuidAsString(pObjectInfo->Info.Drive.DriveType) );
            WsbTrace(OLESTR("  Device Name....  <%-ls>\n"), pObjectInfo->Info.Drive.szDeviceName );
            WsbTrace(OLESTR("  Serial Number..  <%-ls>\n"), pObjectInfo->Info.Drive.szSerialNumber );
            WsbTrace(OLESTR("  Revision.......  <%-ls>\n"), pObjectInfo->Info.Drive.szRevision );
            WsbTrace(OLESTR("  SCSI Port......  %-d\n"), pObjectInfo->Info.Drive.ScsiPort );
            WsbTrace(OLESTR("  SCSI Bus.......  %-d\n"), pObjectInfo->Info.Drive.ScsiBus );
            WsbTrace(OLESTR("  SCSI Target....  %-d\n"), pObjectInfo->Info.Drive.ScsiTarget );
            WsbTrace(OLESTR("  SCSI Lun.......  %-d\n"), pObjectInfo->Info.Drive.ScsiLun );
            WsbTrace(OLESTR("  Mount Count....  %-d\n"), pObjectInfo->Info.Drive.dwMountCount );
            WsbTrace(OLESTR("  Last Cleaned...  %02d/%02d/%02d %02d:%02d:%02d.%03d\n"),
                pObjectInfo->Info.Drive.LastCleanedTs.wMonth,
                pObjectInfo->Info.Drive.LastCleanedTs.wDay,
                pObjectInfo->Info.Drive.LastCleanedTs.wYear,
                pObjectInfo->Info.Drive.LastCleanedTs.wHour,
                pObjectInfo->Info.Drive.LastCleanedTs.wMinute,
                pObjectInfo->Info.Drive.LastCleanedTs.wSecond,
                pObjectInfo->Info.Drive.LastCleanedTs.wMilliseconds );
            WsbTrace(OLESTR("  Partition......  %-ls\n"), WsbGuidAsString(pObjectInfo->Info.Drive.SavedPartitionId) );
            WsbTrace(OLESTR("  Library........  %-ls\n"), WsbGuidAsString(pObjectInfo->Info.Drive.Library) );
            break;

        case NTMS_DRIVE_TYPE:
            WsbTrace(OLESTR("Drive Type Information:\n") );
            WsbTrace(OLESTR("  GUID...........  %-ls\n"), WsbGuidAsString(pObjectInfo->ObjectGuid) );
            WsbTrace(OLESTR("  Name...........  <%-ls>\n"), pObjectInfo->szName );
            WsbTrace(OLESTR("  Description....  <%-ls>\n"), pObjectInfo->szDescription );
            WsbTrace(OLESTR("  Enabled........  %-ls\n"), WsbBoolAsString(pObjectInfo->Enabled) );
            WsbTrace(OLESTR("  Op State.......  %-ls\n"), WsbLongAsString(pObjectInfo->dwOperationalState) );
            WsbTrace(OLESTR("  Created........  %-ls\n"), WsbFiletimeAsString(FALSE, fCreated) );
            WsbTrace(OLESTR("  Modified.......  %-ls\n"), WsbFiletimeAsString(FALSE, fModified) );
            WsbTrace(OLESTR("  Vendor.........  <%-ls>\n"), pObjectInfo->Info.DriveType.szVendor );
            WsbTrace(OLESTR("  Product........  <%-ls>\n"), pObjectInfo->Info.DriveType.szProduct );
            WsbTrace(OLESTR("  Number of Heads  %-d\n"), pObjectInfo->Info.DriveType.NumberOfHeads );
            WsbTrace(OLESTR("  Device Type....  %-d\n"), pObjectInfo->Info.DriveType.DeviceType );
            break;

        case NTMS_IEDOOR:
        case NTMS_IEPORT:
            break;

        case NTMS_LIBRARY:
            