DEBUG
#define IFDEBUG(Statement) Statement
#else //DEBUG
#define IFDEBUG(Statement)
#endif //DEBUG

//////////////////////////////////////////////////////////////////////////
//
// COUNTOF
//
// Returns the number of elements in an array
//

#define COUNTOF(array)  ( sizeof(array) / sizeof(array[0]) )

//////////////////////////////////////////////////////////////////////////
//
// STRING
//
// Stringizing operator
//

#define STRING(arg)	#arg

//////////////////////////////////////////////////////////////////////////
//
// DISABLE_COPY_CONTRUCTION
//
// Declares copy construction operators as private to prevent outside access
//

#define DISABLE_COPY_CONTRUCTION(Class)						    \
	private:													\
        Class(const Class&) { }							        \
        Class& operator =(const Class&)	{ return *this;	}       \

//////////////////////////////////////////////////////////////////////////
//
// IS_NT
//
// Returns true on an NT based OS
//

#define IS_NT  ( GetVersion() < 0x80000000 )

//////////////////////////////////////////////////////////////////////////
//
// LONG_PATH
//
// Returns the \\?\ string (that can be used in file APIs) in UNICODE builds
//

#ifdef UNICODE
#define LONG_PATH L"\\\\?\\"
#else //UNICODE
#define LONG_PATH
#endif //UNICODE

//////////////////////////////////////////////////////////////////////////
//
// AW, _AW
//
// Append a 'W' or 'A' depending on UNICODE or ANSI builds 
//

#ifdef UNICODE
#define AW(name) name##W
#define _AW "W"
#else //UNICODE
#define AW(name) name##A
#define _AW "A"
#endif //UNICODE

//////////////////////////////////////////////////////////////////////////
//
// IGNORE_EXCEPTIONS
//
// Ignores any exceptions thrown from the code block
//

#define IGNORE_EXCEPTIONS(Statement) try { Statement; } catch (...) {}

//////////////////////////////////////////////////////////////////////////
//
// WAIT_AND_RETRY_ON_EXCEPTION
//
// Pauses and retries if an exception is thrown from the code block
//

#define WAIT_AND_RETRY_ON_EXCEPTION(func, nRetries, nWaitTime)	\
	{															\
		int nTrials = nRetries;									\
                                                                \
		while (1)                                               \
        {				                                        \
			try                                                 \
            {												    \
				func;											\
				break;          								\
			}                                                   \
            catch (...)                                         \
            {			            							\
				if (nTrials-- == 0)                             \
                {					                            \
					throw;										\
				}												\
                                                                \
				Sleep(nWaitTime);								\
			}													\
		}														\
	}															\

//////////////////////////////////////////////////////////////////////////
//
// Abs
//
// Returns the absolute value of the variable
//

template <class T>
inline const T Abs(const T& x)
{
	return x < 0 ? -x : x;
}

//////////////////////////////////////////////////////////////////////////
//
// Sqr
//
// Returns x^2
//

template <class T>
inline const T Sqr(const T& x)
{
	return x * x;
}

//////////////////////////////////////////////////////////////////////////
//
// Cube
//
// Returns x^3
//

template <class T>
inline const T Cube(const T& x)
{
	return x * x * x;
}

//////////////////////////////////////////////////////////////////////////
//
// Swap
//
// Swaps the values of two variables
//

template <class T>
inline void Swap(T& x, T& y)
{
	T temp = x;
	x = y;
	y = temp;
}

//////////////////////////////////////////////////////////////////////////
//
// Min
//
// Returns the smaller of the two variables (based on "<" operator)
//

template <class T>
inline const T Min(const T& x, const T& y)
{
	return x < y ? x : y;
}

//////////////////////////////////////////////////////////////////////////
//
// Max
//
// Returns the larger of the two variables (based on "<" operator)
//

template <class T>
inline const T Max(const T& x, const T& y)
{
	return x < y ? y : x;
}

//////////////////////////////////////////////////////////////////////////
//
// Cmp
//
// Compares two variables (based on "==" and "<" operators)
//

template <class T>
inline int Cmp(const T& x, const T& y)
{
    return x == y ? 0 : x < y ? -1 : 1;
}

//////////////////////////////////////////////////////////////////////////
//
// StructCmp
//
// Compares two structs byte by byte
//

template <class T>
inline int StructCmp(const T *x, const T *y)
{
    return memcmp(x, y, sizeof(T));
}

//////////////////////////////////////////////////////////////////////////
//
// CopyData
//
// Copies a number of data structures memory from one location to another 
// Source and destination blocks should not overlap
//

template <class T>
inline void CopyData(T *x, const T *y, int n)
{
    CopyMemory(x, y, n * sizeof(T));
}

//////////////////////////////////////////////////////////////////////////
//
// MoveData
//
// Copies a number of data structures memory from one location to another 
// Source and destination blocks may overlap
//

template <class T>
inline void MoveData(T *x, const T *y, int n)
{
    MoveMemory(x, y, n * sizeof(T));
}

//////////////////////////////////////////////////////////////////////////
//
// IsEqual
//
// Returns true if the two comperands are equal
//

template <class T>
inline BOOL IsEqual(T lhs, T rhs)
{
    return lhs == rhs;
}

template <class T>
inline BOOL IsEqual(const T *lhs, const T *rhs)
{
    return *lhs == *rhs;
}

template <>
inline BOOL IsEqual(const CHAR *lhs, const CHAR *rhs)
{
    return strcmp(lhs, rhs) == 0;
}

template <>
inline BOOL IsEqual(const WCHAR *lhs, const WCHAR *rhs)
{
    return wcscmp(lhs, rhs) == 0;
}

//////////////////////////////////////////////////////////////////////////
//
// CharLower
//
// Converts a single character to lowercase
//

inline TCHAR CharLower(TCHAR c)
{
    return (TCHAR) CharLower((PTSTR) c);
}

//////////////////////////////////////////////////////////////////////////
//
// CharUpper
//
// Converts a single character to uppercase
//

inline TCHAR CharUpper(TCHAR c)
{
    return (TCHAR) CharUpper((PTSTR) c);
}

//////////////////////////////////////////////////////////////////////////
//
// _tcssafecmp
//
// Compares two strings (that can be null)
//

inline int strsafecmp(PCSTR psz1, PCSTR psz2)
{
    return psz1 != 0 ? (psz2 != 0 ? strcmp(psz1, psz2) : 1) : (psz2 != 0 ? -1 : 0);
}

inline int wcssafecmp(PCWSTR psz1, PCWSTR psz2)
{
    return psz1 != 0 ? (psz2 != 0 ? wcscmp(psz1, psz2) : 1) : (psz2 != 0 ? -1 : 0);
}

#ifdef UNICODE
#define _tcssafecmp wcssafecmp
#else //UNICODE
#define _tcssafecmp strsafecmp
#endif //UNICODE

//////////////////////////////////////////////////////////////////////////
//
// multiszlen
//
// Returns the length of a null terminated list of null terminated strings
//

inline size_t multiszlenA(PCSTR pszzStr)
{
    PCSTR pszStr = pszzStr; 

    if (pszStr) 
    {
        while (*pszStr) 
        {
            pszStr += strlen(pszStr) + 1;
        }
    }

    return pszStr - pszzStr;
}

inline size_t multiszlenW(PCWSTR pwszzStr)
{
    PCWSTR pwszStr = pwszzStr; 

    if (pwszStr) 
    {
        while (*pwszStr) 
        {
            pwszStr += wcslen(pwszStr) + 1;
        }
    }

    return pwszStr - pwszzStr;
}

#ifdef UNICODE
#define multiszlen multiszlenW
#else //UNICODE
#define multiszlen multiszlenA
#endif //UNICODE

//////////////////////////////////////////////////////////////////////////
//
// FindFileNamePortion
//
// Returns a pointer to the file name portion of a full path name
//

inline PSTR FindFileNamePortionA(PCSTR pPathName)
{
    PCSTR pFileName = pPathName ? strrchr(pPathName, '\\') : 0;
	return const_cast<PSTR>(pFileName ? pFileName + 1 : pPathName);
}

inline PWSTR FindFileNamePortionW(PCWSTR pPathName)
{
    PCWSTR pFileName = pPathName ? wcsrchr(pPathName, '\\') : 0;
	return const_cast<PWSTR>(pFileName ? pFileName + 1 : pPathName);
}

#ifdef UNICODE
#define FindFileNamePortion FindFileNamePortionW
#else //UNICODE
#define FindFileNamePortion FindFileNamePortionA
#endif //UNICODE

//////////////////////////////////////////////////////////////////////////
//
// FindEol
//
// Finds the first end-of-line character in a string
//

inline PTSTR FindEol(PCTSTR pStr)
{
    while (*pStr != '\0' && *pStr != '\r' && *pStr != '\n') 
    {
        pStr = CharNext(pStr);
    }

    return const_cast<PTSTR>(pStr);
}


#ifdef _SHLOBJ_H_

//////////////////////////////////////////////////////////////////////////
//
// SHFree
//
// Frees a block of memory allocated through shell's IMalloc interface
//

inline void SHFree(PVOID pVoid)
{
    LPMALLOC pMalloc;
    SHGetMalloc(&pMalloc); 
    pMalloc->Free(pVoid); 
    pMalloc->Release();  
}

#endif //_SHLOBJ_H_

//////////////////////////////////////////////////////////////////////////
//
// WriteConsole
//
// Writes a character string to a console screen 
//

inline BOOL WriteConsole(PCTSTR pStr, DWORD nStdHandle = STD_OUTPUT_HANDLE)
{
	DWORD dwNumWritten;

	return WriteConsole(
		GetStdHandle(nStdHandle),
		pStr,
		_tcslen(pStr),
		&dwNumWritten,
		0
	);
}

#ifdef _INC_STDLIB

//////////////////////////////////////////////////////////////////////////
//
// GetEnvironmentInt
//
// Retrieves the value of the specified variable from the environment block
//

inline BOOL GetEnvironmentInt(PCTSTR pName, PINT piValue)
{
    TCHAR szValue[48];

    DWORD dwResult = GetEnvironmentVariable(pName, szValue, COUNTOF(szValue));
    
    if (dwResult > 0 && dwResult < COUNTOF(szValue)) 
    {
        if (piValue == 0)
        {
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            return FALSE;
        }

        *piValue = _ttoi(szValue);
        return TRUE;
    }

    return FALSE;
}

#endif //_INC_STDLIB

#ifdef _INC_STDIO

//////////////////////////////////////////////////////////////////////////
//
// _tcsdupc
//
// Duplicates a string to a buffer allocated by new []
//

inline PTSTR _tcsdupc(PCTSTR pStrSource)
{
    if (!pStrSource) 
    {
        pStrSource = _T("");
    }

    PTSTR pStrDest = new TCHAR[_tcslen(pStrSource) + 1];

    if (pStrDest) 
    {
        _tcscpy(pStrDest, pStrSource);
    }

    return pStrDest;
}

//////////////////////////////////////////////////////////////////////////
//
// bufvprintf, bufprintf
//
// Writes a printf style formatted string to a buffer allocated by new []
//

inline PTSTR bufvprintf(PCTSTR format, va_list arglist)
{
    PTSTR pBuffer = 0;

    for (
        size_t nBufferSize = 1024;  
        (pBuffer = new TCHAR[nBufferSize]) != 0 && 
        _vsntprintf(pBuffer, nBufferSize, format, arglist) < 0;
        delete [] pBuffer, nBufferSize *= 2
    ) 
    {
        // start with a 1KB buffer size
        // if buffer allocation fails, exit
        // if _vsntprintf succeeds, exit
        // otherwise, delete the buffer and retry with double size
    }

    return pBuffer;
}

inline PTSTR __cdecl bufprintf(PCTSTR format, ...)
{
    va_list arglist;
    va_start(arglist, format);

    return bufvprintf(format, arglist);
}

//////////////////////////////////////////////////////////////////////////
//
// TextOutF
//
// Writes a printf style formatted string to the DC
//

inline BOOL __cdecl TextOutF(HDC hDC, int nX, int nY, PCTSTR format, ...)
{
    va_list arglist;
    va_start(arglist, format);

    BOOL bResult = FALSE;

    PTSTR pStr = bufvprintf(format, arglist);

    if (pStr) 
    {
        bResult = TextOut(hDC, nX, nY, pStr, _tcslen(pStr));
        delete [] pStr;
    }

    return bResult;
}

//////////////////////////////////////////////////////////////////////////
//
// OutputDebugStringF
//
// Outputs a printf style formatted string to the debug console
//

inline void __cdecl OutputDebugStringF(PCTSTR format, ...)
{
    va_list arglist;
    va_start(arglist, format);

    PTSTR pStr = bufvprintf(format, arglist);

    if (pStr) 
    {
        OutputDebugString(pStr);
        delete [] pStr;
    }

    va_end(arglist);
}

#ifdef DEBUG
#define DEBUGMSG(x) OutputDebugString(x)
#define DEBUGMSGF(x) OutputDebugStringF x
#else //DEBUG
#define DEBUGMSG(x) 
#define DEBUGMSGF(x) 
#endif //DEBUG

//////////////////////////////////////////////////////////////////////////
//
// IsChildWindow
//
// Determines whether the second hWnd is a child of the first
//

inline BOOL IsChildWindow(HWND hWndParent, HWND hWnd)
{
    while (hWnd)
    {
        hWnd = GetParent(hWnd);

        if (hWnd == hWndParent)
        {
            return TRUE;
        }
    }

    return FALSE;
}

#endif //_INC_STDIO

#if defined(_INC_IO) && defined(_INC_FCNTL)

//////////////////////////////////////////////////////////////////////////
//
// OpenOSHandle
//
// Associates a stream with an operating-system file handle
//

inline FILE *OpenOSHandle(HANDLE osfhandle, int flags, PCTSTR mode)
{
    int hCrt = _open_osfhandle((intptr_t) osfhandle, flags);
    return hCrt ? _tfdopen(hCrt, mode) : 0;
}

//////////////////////////////////////////////////////////////////////////
//
// OpenStdHandle
//
// Assigns a stream to an operating-system file handle for standard I/O
//

inline void OpenStdHandle(HANDLE osfhandle, FILE *stream, PCTSTR mode)
{
    *stream = *OpenOSHandle(osfhandle, _O_TEXT, mode);
    setvbuf(stream, 0, _IONBF, 0);
}

//////////////////////////////////////////////////////////////////////////
//
// AllocCRTConsole
//
// Allocates a new console and associates standard handles with this console
//

inline void AllocCRTConsole()
{
    if (AllocConsole()) 
    {
        OpenStdHandle(GetStdHandle(STD_INPUT_HANDLE),  stdin,  _T("r"));
        OpenStdHandle(GetStdHandle(STD_OUTPUT_HANDLE), stdout, _T("w"));
        OpenStdHandle(GetStdHandle(STD_ERROR_HANDLE),  stderr, _T("w"));
    }
}

#endif //defined(_INC_IO) && defined(_INC_FCNTL)

#ifdef _INC_COMMCTRL

//////////////////////////////////////////////////////////////////////////
//
// ListView_InsertColumn2
//
// Inserts a new column in a list view control
//

inline 
int
ListView_InsertColumn2(
    HWND   hWnd,
    int    nCol, 
    PCTSTR pszColumnHeading, 
    int    nFormat,
	int    nWidth, 
    int    nSubItem
)
{
	LVCOLUMN column;
	column.mask     = LVCF_TEXT|LVCF_FMT|LVCF_WIDTH|LVCF_SUBITEM;
	column.pszText  = (PTSTR) pszColumnHeading;
	column.fmt      = nFormat;
	column.cx       = nWidth;
    column.iSubItem = nSubItem;

	return ListView_InsertColumn(hWnd, nCol, &column);
}

//////////////////////////////////////////////////////////////////////////
//
// ListView_GetItemData
//
// Returns the lParam value associated with a list view item
//

inline
LPARAM
ListView_GetItemData(HWND hWnd, int nItem)
{
    LVITEM item;
	item.mask     = LVIF_PARAM;
	item.iItem    = nItem;
	item.iSubItem = 0;
    item.lParam   = 0;

    ListView_GetItem(hWnd, &item);

    return item.lParam;
}

//////////////////////////////////////////////////////////////////////////
//
// ListView_GetItemData
//
// Sets the lParam value associated with a list view item
//

inline
BOOL
ListView_SetItemData(HWND hWnd, int nItem, LPARAM lParam)
{
    LVITEM item;
	item.mask     = LVIF_PARAM;
	item.iItem    = nItem;
	item.iSubItem = 0;
    item.lParam   = lParam;

    return ListView_SetItem(hWnd, &item);
}

//////////////////////////////////////////////////////////////////////////
//
// operator ==, operator !=
//
// Compares two TVITEM structs based on their contents
//

inline bool operator ==(const TVITEM &lhs, const TVITEM &rhs)
{
    UINT mask = lhs.mask;

    return
        mask == rhs.mask &&
        (!(mask & TVIF_HANDLE)        || lhs.hItem == rhs.hItem) &&
        (!(mask & TVIF_STATE)         || (lhs.state == rhs.state && lhs.stateMask == rhs.stateMask)) &&
        (!(mask & TVIF_TEXT)          || (lhs.pszText == rhs.pszText && lhs.cchTextMax == rhs.cchTextMax)) &&        
        (!(mask & TVIF_IMAGE)         || lhs.iImage == rhs.iImage) &&
        (!(mask & TVIF_SELECTEDIMAGE) || lhs.iSelectedImage == rhs.iSelectedImage) &&
        (!(mask & TVIF_CHILDREN)      || lhs.cChildren == rhs.cChildren) &&
        (!(mask & TVIF_PARAM)         || lhs.lParam == rhs.lParam);
}

inline bool operator !=(const TVITEM &lhs, const TVITEM &rhs)
{
    return !(lhs == rhs);
}

#endif //_INC_COMMCTRL

//////////////////////////////////////////////////////////////////////////
//
// ResizeDlgItem
//
// Changes the relative position and size of a dialog item
//

inline
BOOL 
ResizeDlgItem(
    HWND hWnd, 
    HWND hDlgItem, 
    int  dX, 
    int  dY, 
    int  dW, 
    int  dH, 
    BOOL bRepaint = TRUE
)
{
    RECT r;
    return 
        GetWindowRect(hDlgItem, &r) &&
        ScreenToClient(hWnd, (PPOINT) &r.left) &&
        ScreenToClient(hWnd, (PPOINT) &r.right) &&
        MoveWindow(
            hDlgItem, 
            r.left + dX, 
            r.top  + dY,
            r.right - r.left + dW,
            r.bottom - r.top + dH,
            bRepaint
        );
}

//////////////////////////////////////////////////////////////////////////
//
// CLargeInteger
//

class CLargeInteger // union cannot be used as a base class
{
public:
    CLargeInteger(
        DWORD LowPart,
        LONG  HighPart
    )
    {
        m_Int.LowPart  = LowPart;
        m_Int.HighPart = HighPart;
    }

    CLargeInteger(
        LONGLONG QuadPart
    )
    {
        m_Int.QuadPart = QuadPart;
    }

    CLargeInteger(
        const LARGE_INTEGER& rhs
    )
    {
        m_Int.QuadPart = rhs.QuadPart;
    }

    LARGE_INTEGER * operator &()
    {
        return &m_Int;
    }

    const LARGE_INTEGER * operator &() const
    {
        return &m_Int;
    }

    operator LONGLONG&()
    {
        return m_Int.QuadPart;
    }

    operator const LONGLONG&() const
    {
        return m_Int.QuadPart;
    }

private:
    LARGE_INTEGER m_Int;
};

//////////////////////////////////////////////////////////////////////////
//
// CULargeInteger
//

class CULargeInteger // union cannot be used as a base class
{
public:
    CULargeInteger(
        DWORD LowPart,
        DWORD HighPart
    )
    {
        m_Int.LowPart = LowPart;
        m_Int.HighPart = HighPart;
    }

    CULargeInteger(
        ULONGLONG QuadPart
    )
    {
        m_Int.QuadPart = QuadPart;
    }

    CULargeInteger(
        const ULARGE_INTEGER& rhs
    )
    {
        m_Int.QuadPart = rhs.QuadPart;
    }

    ULARGE_INTEGER * operator &()
    {
        return &m_Int;
    }

    const ULARGE_INTEGER * operator &() const
    {
        return &m_Int;
    }

    operator ULONGLONG&()
    {
        return m_Int.QuadPart;
    }

    operator const ULONGLONG&() const
    {
        return m_Int.QuadPart;
    }

private:
    ULARGE_INTEGER m_Int;
};

//////////////////////////////////////////////////////////////////////////
//
// CFileTime
//

class CFileTime : public FILETIME
{
public:
    CFileTime()
    {
    }

    CFileTime(ULONGLONG Value)
    {
        ((ULARGE_INTEGER *)this)->QuadPart = Value;
    }
};

//////////////////////////////////////////////////////////////////////////
//
// CHandle
//
// Base class that handles reference counting
//

template <class T, class Child>
class CHandle 
{
public:
	CHandle()
	{
		m_pNext = 0;
	}

	explicit CHandle(const T &Value)
	{
		m_pNext = 0;
		Attach(Value);
	}

	CHandle(CHandle &rhs)
	{
		m_pNext = 0;
		Attach(rhs);
	}

	CHandle & operator =(const T &Value)
    {
		Detach();
		Attach(Value);

		return *this;
    }

	CHandle & operator =(CHandle &rhs)
	{
		if (&rhs != this) 
        {
			Detach();
			Attach(rhs);
		}

		return *this;
	}

	~CHandle()
	{
		Detach();
	}

	operator const T &() const
	{
		return m_Value;
	}

//	void Destroy()
//	{
//		must be defined in the derived class 
//	}

//	bool IsValid() 
//	{
//		must be defined in the derived class 
//	}

	void Attach(const T &Value) 
	{
		ASSERT(!IsAttached());

		m_Value = Value;

		CHECK(((Child *)this)->IsValid());

		m_pNext = this;
		m_pPrev = this;
	}

	void Attach(CHandle &rhs)
	{
		ASSERT(!IsAttached());

		if (rhs.IsAttached()) 
        {
			m_Value = rhs.m_Value;

			m_pPrev = &rhs;
			m_pNext = rhs.m_pNext;

			m_pPrev->m_pNext = this;
			m_pNext->m_pPrev = this;
		}
	}

	void Detach() 
	{
		if (IsLastReference()) 
        {
			((Child *)this)->Destroy();

    		m_pNext = 0;
		} 
        else 
        {
			Unlink();
		}
	}

	void Unlink() 
	{
		if (IsAttached()) 
        {
			m_pPrev->m_pNext = m_pNext;
			m_pNext->m_pPrev = m_pPrev;

            m_pNext = 0;
		}
	}

	bool IsLastReference() const
	{
		return m_pNext == this;
	}

	bool IsAttached() const
	{
		return m_pNext != 0;
	}

private:
	T        m_Value;
	CHandle *m_pNext;
	CHandle *m_pPrev;
};

//////////////////////////////////////////////////////////////////////////
//
// CKernelObject
//
// Base class for kernel objects that can be destroyed with CloseHandle()
//

template <class Child>
class CKernelObject : public CHandle<HANDLE, Child>
{
	typedef CHandle<HANDLE, Child> parent_type;

protected:
	CKernelObject()
	{
	}

	explicit
	CKernelObject(
		HANDLE hHandle
	) :
		parent_type(hHandle)
	{
	}

public:
	void Destroy()
	{
		::CloseHandle(*this);
	}

	bool IsValid()
	{
		return *this != 0;
	}

	DWORD
	WaitForSingleObject(
		DWORD dwMilliseconds = INFINITE,
        BOOL  bAlertable = FALSE
	) const
	{
		return ::WaitForSingleObjectEx(
			*this,
			dwMilliseconds,
            bAlertable
		);
	}

    bool IsSignaled() const
    {
        return WaitForSingleObject(0) == WAIT_OBJECT_0;
    }
};

//////////////////////////////////////////////////////////////////////////
//
// File
//
// Wrapper class for Win32 file handles
//

class File : public CKernelObject<File>
{
public:
	File()
	{
	}

	File(  
		PCTSTR	pFileName,
		DWORD	dwDesiredAccess,
		DWORD	dwShareMode,
		LPSECURITY_ATTRIBUTES pSecurityAttributes,
		DWORD	dwCreationDisposition,
		DWORD	dwFlagsAndAttributes = FILE_ATTRIBUTE_NORMAL,
		HANDLE	hTemplateFile = 0
	) :
		CKernelObject<File>(::CreateFile(
			pFileName,          
			dwDesiredAccess,
			dwShareMode,
			pSecurityAttributes,
			dwCreationDisposition,
			dwFlagsAndAttributes,
			hTemplateFile
		))
	{
	}

    bool IsValid()
	{
		return (HANDLE) *this != INVALID_HANDLE_VALUE;
	}

	LARGE_INTEGER
	GetFileSize() const
	{
		LARGE_INTEGER Result;
		
		Result.LowPart = ::GetFileSize(
			*this, 
			(PDWORD) &Result.HighPart
		);

		return Result;
	}

	DWORD
	WriteFile(
		CONST VOID *pBuffer,
		DWORD nNumberOfBytesToWrite,
		LPOVERLAPPED pOverlapped = 0
	) const
	{
		DWORD dwNumberOfBytesWritten;

		CHECK(::WriteFile(
			*this,
			pBuffer,
			nNumberOfBytesToWrite,
			&dwNumberOfBytesWritten,
			pOverlapped
		));

		return dwNumberOfBytesWritten;
	}

	DWORD
	ReadFile(
		PVOID pBuffer,
		DWORD nNumberOfBytesToRead,
		LPOVERLAPPED pOverlapped = 0
	) const
	{
		DWORD dwNumberOfBytesRead;

		CHECK(::ReadFile(
			*this,
			pBuffer,
			nNumberOfBytesToRead,
			&dwNumberOfBytesRead,
			pOverlapped
		));

		return dwNumberOfBytesRead;
	}
};

//////////////////////////////////////////////////////////////////////////
//
// CInFile
//
// Read only file
//

class CInFile : public File
{
public:
	CInFile()
	{
	}

    explicit
	CInFile(  
		PCTSTR	pFileName,
		DWORD	dwDesiredAccess       = GENERIC_READ,
		DWORD	dwShareMode           = FILE_SHARE_READ,
		LPSECURITY_ATTRIBUTES pSecurityAttributes = 0,
		DWORD	dwCreationDisposition = OPEN_EXISTING,
		DWORD	dwFlagsAndAttributes  = FILE_ATTRIBUTE_NORMAL,
		HANDLE	hTemplateFile         = 0
	) :
		File(
			pFileName,          
			dwDesiredAccess,
			dwShareMode,
			pSecurityAttributes,
			dwCreationDisposition,
			dwFlagsAndAttributes,
			hTemplateFile
		)
	{
	}
};


//////////////////////////////////////////////////////////////////////////
//
// COutFile
//
// Write only file
//

class COutFile : public File
{
public:
	COutFile()
	{
	}

    explicit
	COutFile(  
		PCTSTR	pFileName,
		DWORD	dwDesiredAccess       = GENERIC_WRITE,
		DWORD	dwShareMode           = FILE_SHARE_READ,
		LPSECURITY_ATTRIBUTES pSecurityAttributes = 0,
		DWORD	dwCreationDisposition = CREATE_ALWAYS,
		DWORD	dwFlagsAndAttributes  = FILE_ATTRIBUTE_NORMAL,
		HANDLE	hTemplateFile         = 0
	) :
		File(
			pFileName,          
			dwDesiredAccess,
			dwShareMode,
			pSecurityAttributes,
			dwCreationDisposition,
			dwFlagsAndAttributes,
			hTemplateFile
		)
	{
	}
};

//////////////////////////////////////////////////////////////////////////
//
// CopyFileContents
//
// Copies the contents of one file to another
//

inline void CopyFileContents(const File &InFile, const File &OutFile)
{
    BYTE  Buffer[32*1024];
    DWORD nNumRead;

    do
    {
        nNumRead = InFile.ReadFile(Buffer, sizeof(Buffer));
        OutFile.WriteFile(Buffer, nNumRead);
    }
    while (nNumRead == sizeof(Buffer));
}

#ifdef _INC_STDIO

#include <share.h>

//////////////////////////////////////////////////////////////////////////
//
// CCFile
//
// Wrapper class for C-runtime stream based file handles
//

class CCFile : public CHandle<FILE *, CCFile>
{
	typedef CHandle<FILE *, CCFile> parent_type;

public:
	CCFile()
	{
	}

    CCFile(
        PCTSTR filename, 
        PCTSTR mode,
        int    shflag = _SH_DENYNO
	) :
		parent_type(::_tfsopen(
            filename, 
            mode,
            shflag
		))
	{
	}

	void Destroy()
	{
		::fclose(*this);
	}

    bool IsValid()
	{
		return *this != 0;
	}
};

#endif _INC_STDIO

//////////////////////////////////////////////////////////////////////////
//
// CNamedPipe
//
// Wrapper class for named pipes
//

class CNamedPipe : public File
{
public:
	CNamedPipe()
	{
	}

	CNamedPipe(  
        PCTSTR pName,
        DWORD  dwOpenMode,
        DWORD  dwPipeMode = PIPE_TYPE_BYTE | PIPE_READMODE_BYTE | PIPE_WAIT,
        DWORD  nMaxInstances = PIPE_UNLIMITED_INSTANCES,
        DWORD  nOutBufferSize = 0,
        DWORD  nInBufferSize = 0,
        DWORD  nDefaultTimeOut = INFINITE,
        LPSECURITY_ATTRIBUTES pSecurityAttributes = 0
	)
	{
		Attach(::CreateNamedPipe(
            pName,
            dwOpenMode,
            dwPipeMode,
            nMaxInstances,
            nOutBufferSize,
            nInBufferSize,
            nDefaultTimeOut,
            pSecurityAttributes
		));
	}    
};

//////////////////////////////////////////////////////////////////////////
//
// CFileMapping
//
// Wrapper class for file mapping objects
//

class CFileMapping : public CKernelObject<CFileMapping>
{
public:
	CFileMapping()
	{
	}

	CFileMapping(  
		HANDLE hFile,
		LPSECURITY_ATTRIBUTES pFileMappingAttributes,
		DWORD  flProtect,
		DWORD  dwMaximumSizeHigh = 0,
		DWORD  dwMaximumSizeLow = 0,
		PCTSTR pName = 0
	) :
		CKernelObject<CFileMapping>(::CreateFileMapping(
			hFile,
			pFileMappingAttributes,
			flProtect,
			dwMaximumSizeHigh,
			dwMaximumSizeLow,
			pName
		))
	{
	}
};


#ifdef _LZEXPAND_

//////////////////////////////////////////////////////////////////////////
//
// CLZFile
//
// Wrapper class for LZ compressed files
//

class CLZFile : public CHandle<INT, CLZFile>
{
	typedef CHandle<INT, CLZFile> parent_type;

public:
	CLZFile(
		PTSTR pFileName,
		WORD wStyle              
	) :
		parent_type(::LZOpenFile(
			pFileName,
			&m_of,
			wStyle
		)) 
	{
	}
	
	void Destroy()
	{
		::LZClose(*this);
	}

    bool IsValid()
	{
		return *this >= 0;
	}

private:
	OFSTRUCT m_of;
};

#endif _LZEXPAND_

//////////////////////////////////////////////////////////////////////////
//
// CStartupInfo
//
// Wrapper class for the STARTUPINFO struct
//

class CStartupInfo : public STARTUPINFO 
{
public:
    CStartupInfo()
    {
        ZeroMemory(this, sizeof(STARTUPINFO));
	    cb = sizeof(STARTUPINFO);
    }

    void 
    UseStdHandles(
	    HANDLE _hStdInput  = GetStdHandle(STD_INPUT_HANDLE),
        HANDLE _hStdOutput = GetStdHandle(STD_OUTPUT_HANDLE),
	    HANDLE _hStdError  = GetStdHandle(STD_ERROR_HANDLE)
    )
    {
        dwFlags     |= STARTF_USESTDHANDLES;
	    hStdInput   = _hStdInput;
        hStdOutput  = _hStdOutput;
	    hStdError   = _hStdError;
    }

    void 
    UseShowWindow(WORD _wShowWindow)
    {
        dwFlags     |= STARTF_USESHOWWINDOW;
        wShowWindow = _wShowWindow;
    }
};

//////////////////////////////////////////////////////////////////////////
//
// CProcess
//
// Wrapper class for process handles
//

class CProcess : public CHandle<PROCESS_INFORMATION, CProcess>
{
public:
	CProcess()
	{
	}

	explicit
	CProcess(  
		PTSTR                pCommandLine,  
		PSECURITY_ATTRIBUTES pProcessAttributes = 0,
		PSECURITY_ATTRIBUTES pThreadAttributes = 0,
		BOOL                 bInheritHandles = FALSE,
		DWORD                dwCreationFlags = 0, 
		PVOID                pEnvironment = 0,
		PCTSTR               pCurrentDirectory = 0,
        LPSTARTUPINFO        psi = &CStartupInfo()
	)
	{
        PROCESS_INFORMATION pi;

		CHECK(::CreateProcess(
			0,
			pCommandLine,  
			pProcessAttributes,
			pThreadAttributes,
			bInheritHandles,
			dwCreationFlags, 
			pEnvironment,
			pCurrentDirectory,
            psi,
			&pi
		));

        Attach(pi);
	}

	CProcess(
		HANDLE               hToken,
		PTSTR                pCommandLine,  
		PSECURITY_ATTRIBUTES pProcessAttributes = 0,
		PSECURITY_ATTRIBUTES pThreadAttributes = 0,
		BOOL                 bInheritHandles = FALSE,
		DWORD                dwCreationFlags = 0, 
		PVOID                pEnvironment = 0,
		PCTSTR               pCurrentDirectory = 0,
        LPSTARTUPINFO        psi = &CStartupInfo()
	)
	{
        PROCESS_INFORMATION pi;

		CHECK(::CreateProcessAsUser(
			hToken,
			0,
			pCommandLine,  
			pProcessAttributes,
			pThreadAttributes,
			bInheritHandles,
			dwCreationFlags, 
			pEnvironment,
			pCurrentDirectory,
			psi,
			&pi
		));

        Attach(pi);
	}

#if (_WIN32_WINNT >= 0x0500) && defined(UNICODE)

	CProcess(
        PCWSTR               pUsername,
        PCWSTR               pDomain,
        PCWSTR               pPassword,
        DWORD                dwLogonFlags,
        PWSTR                pCommandLine,  
		DWORD                dwCreationFlags = 0, 
		PVOID                pEnvironment = 0,
		PCWSTR               pCurrentDirectory = 0,
        LPSTARTUPINFO        psi = &CStartupInfo()
	)
	{
        PROCESS_INFORMATION pi;

		CHECK(::CreateProcessWithLogonW(
			pUsername,
            pDomain,
            pPassword,
            dwLogonFlags,
			0,
			pCommandLine,  
			dwCreationFlags, 
			pEnvironment,
			pCurrentDirectory,
			psi,
			&pi
		));

        Attach(pi);
	}

#endif

    void Destroy()
	{
		::CloseHandle(((PROCESS_INFORMATION &)(*this)).hThread);
		::CloseHandle(((PROCESS_INFORMATION &)(*this)).hProcess);
	}

    bool IsValid()
	{
		return ((PROCESS_INFORMATION &)(*this)).hProcess != 0;
	}

    DWORD
	WaitForInputIdle(
		DWORD dwMilliseconds = INFINITE
	) const
	{
		return ::WaitForInputIdle(
			((PROCESS_INFORMATION &)(*this)).hProcess,
			dwMilliseconds
		); 
	}

	DWORD
	WaitForSingleObject(
		DWORD dwMilliseconds = INFINITE
	) const
	{
		return ::WaitForSingleObject(
			((PROCESS_INFORMATION &)(*this)).hProcess,
			dwMilliseconds
		);
	}

	VOID
	Terminate(
		DWORD dwExitCode = 0
	) const
	{
		CHECK(::TerminateProcess(
			((PROCESS_INFORMATION &)(*this)).hProcess,
			dwExitCode
		));
	}

    DWORD
	GetExitCode() const
    {
        DWORD dwExitCode;

        CHECK(::GetExitCodeProcess(
			((PROCESS_INFORMATION &)(*this)).hProcess,
			&dwExitCode
		));

        return dwExitCode;
    }
};

//////////////////////////////////////////////////////////////////////////
//
// CThreadBase
//
// Base class for Win32 and CRT library style thread objects
//

class CThreadBase : public CKernelObject<CThreadBase>
{
protected:
	CThreadBase()
	{
	}
	
	explicit
	CThreadBase(
		HANDLE hHandle
	) :
		CKernelObject<CThreadBase>(hHandle)
	{
	}

public:
	operator DWORD() const
	{
		return m_dwThreadId;
	}

	VOID
	Terminate(
		DWORD dwExitCode = 0
	) const
	{
		CHECK(::TerminateThread(
			*this,
			dwExitCode
		));
	}

	DWORD
	GetExitCode() const
    {
        DWORD dwExitCode;

        CHECK(::GetExitCodeThread(
			*this,
			&dwExitCode
		));

        return dwExitCode;
    }

protected:
	DWORD m_dwThreadId;
};

//////////////////////////////////////////////////////////////////////////
//
// CThread
//
// Wrapper class for Win32 thread handles
//

class CThread : public CThreadBase
{
public:
	CThread()
	{
	}
	
	explicit
	CThread(
		PTHREAD_START_ROUTINE pStartAddress,
        PVOID pParameter = 0,
		PSECURITY_ATTRIBUTES pThreadAttributes = 0,
        DWORD dwStackSize = 0,
		DWORD dwCreationFlags = 0
	) :
		CThreadBase(::CreateThread(
			pThreadAttributes,
			dwStackSize,
			pStartAddress,
			pParameter,
			dwCreationFlags,
			&m_dwThreadId
		))
	{
	}
};

#ifdef _INC_PROCESS

//////////////////////////////////////////////////////////////////////////
//
// CCThread
//
// Wrapper class for C-runtime threads
//

class CCThread : public CThreadBase
{
public:
	CCThread()
	{
	}
	
	explicit
	CCThread(
		unsigned ( __stdcall *start_address )( void * ),
		void *arglist = 0, 
		void *security = 0,
		unsigned stack_size = 0,
		unsigned initflag = 0
	) :
		CThreadBase((HANDLE)(LONG_PTR) _beginthreadex(
			security,
			stack_size,
			start_address,
			arglist,
			initflag,
			(unsigned int *) &m_dwThreadId
		))
	{
	}
};

#endif //_INC_PROCESS

//////////////////////////////////////////////////////////////////////////
//
// Event
//
// Wrapper class for event handles
//

class Event : public CKernelObject<Event>
{
public:
	Event()
	{
	}

	Event(
		BOOL bManualReset,
		BOOL bInitialState,
		LPCTSTR lpName = 0,
		LPSECURITY_ATTRIBUTES lpEventAttributes = 0
	) :
		CKernelObject<Event>(::CreateEvent(
			lpEventAttributes,
			bManualReset,
			bInitialState,
			lpName
		))
	{
	}

public:
	VOID
	Set() const
	{
		CHECK(::SetEvent(*this));
	}

	VOID
	Reset() const
	{
		CHECK(::ResetEvent(*this));
	}
};

//////////////////////////////////////////////////////////////////////////
//
// Mutex
//
// Wrapper class for mutex handles
//

class Mutex : public CKernelObject<Mutex>
{
public:
	Mutex()
	{
	}

	explicit
	Mutex(
		BOOL                 bInitialOwner,
		PCTSTR               pName  = 0,
		PSECURITY_ATTRIBUTES pMutexAttributes = 0
	) :
		CKernelObject<Mutex>(::CreateMutex(
			pMutexAttributes,
			bInitialOwner,
			pName
		))
	{
	}

public:
	VOID
	Release() const
	{
		CHECK(::ReleaseMutex(*this));
	}
};

//////////////////////////////////////////////////////////////////////////
//
// Semaphore
//
// Wrapper class for semaphore handles
//

class Semaphore : public CKernelObject<Semaphore>
{
public:
	Semaphore()
	{
	}

	Semaphore(
        LONG lInitialCount,
        LONG lMaximumCount,
		LPCTSTR lpName = 0,
		LPSECURITY_ATTRIBUTES lpEventAttributes = 0
	) :
		CKernelObject<Semaphore>(::CreateSemaphore(
			lpEventAttributes,
			lInitialCount,
			lMaximumCount,
			lpName
		))
	{
	}

public:
	VOID
	Release(
        LONG  lReleaseCount = 1,
        PLONG pPreviousCount = 0
    ) const
	{
		CHECK(::ReleaseSemaphore(*this, lReleaseCount, pPreviousCount));
	}

    VOID
    WaitFor(
        LONG lCount
    ) const 
    {
        for (int i = 0; i < lCount; ++i) 
        {
            WaitForSingleObject();
        }

        Release(lCount);
    }
};


#if (_WIN32_WINNT >= 0x0400) || (_WIN32_WINDOWS > 0x0400)

//////////////////////////////////////////////////////////////////////////
//
// CWaitableTimer
//
// Wrapper class for waitable timer handles
//

class CWaitableTimer : public CKernelObject<CWaitableTimer>
{
public:
	CWaitableTimer()
	{
	}

	explicit
	CWaitableTimer(
		BOOL bManualReset,
		PCTSTR pTimerName = 0,
		PSECURITY_ATTRIBUTES pTimerAttributes = 0
	) :
		CKernelObject<CWaitableTimer>(::CreateWaitableTimer(
			pTimerAttributes,
			bManualReset,
			pTimerName
		))
	{
	}

public:
	VOID
	Set(
		const CLargeInteger &DueTime,
		LONG                 lPeriod = 0,
		PTIMERAPCROUTINE     pfnCompletionRoutine = 0,
		LPVOID               lpArgToCompletionRoutine = 0,
		BOOL                 fResume = FALSE
	) const
	{
		CHECK(::SetWaitableTimer(
			*this,
			&DueTime,
			lPeriod,
			pfnCompletionRoutine,
			lpArgToCompletionRoutine,
			fResume
		));
	}

	VOID
	Cancel() const
	{
		CHECK(::CancelWaitableTimer(*this));
	}
};

#endif

//////////////////////////////////////////////////////////////////////////
//
// CriticalSection
//
// Wrapper class for critical sections
//

class CriticalSection : private CRITICAL_SECTION
{
public:
	CriticalSection()
	{
		::InitializeCriticalSection(this);
	}

	~CriticalSection()
	{
		::DeleteCriticalSection(this);
	}

#if _WIN32_WINNT >= 0x0400

	BOOL
	TryEnter()
	{
        return ::TryEnterCriticalSection(this);
	}

#endif //_WIN32_WINNT >= 0x0400

	VOID
	Enter()
	{
		::EnterCriticalSection(this);
	}

	VOID
	Leave()
	{
		::LeaveCriticalSection(this);
	}
};

//////////////////////////////////////////////////////////////////////////
//
// CLibrary
//
// Wrapper class for loading DLL's
//

class CLibrary : public CHandle<HINSTANCE, CLibrary>
{
	typedef CHandle<HINSTANCE, CLibrary> parent_type;

public:
	CLibrary()
	{
	}
	
	explicit
	CLibrary(
		PCTSTR pLibFileName,
        DWORD  dwFlags = 0
	) :
		parent_type(::LoadLibraryEx(pLibFileName, 0, dwFlags))
	{
	}

	void Destroy()
	{
		::FreeLibrary(*this);
	}

    bool IsValid()
	{
		return *this != 0;
	}
};

//////////////////////////////////////////////////////////////////////////
//
// CPointer
//
// Base class for pointer wrappers
//

#pragma warning(4: 4284) // return type for 'identifier::operator ->()' is not a UDT or reference to a UDT. Will produce errors if applied using infix notation

template <class T, class Child>
class CPointer : public CHandle<T *, Child >
{
	typedef CHandle<T *, Child> parent_type;
	typedef T *pointer_type;

public:
	CPointer()
	{
	}

	CPointer(
		const T *pPointer
	) :
		parent_type((pointer_type) pPointer)
	{
	}

	CPointer & operator =(const T *pPointer)
	{
        return (CPointer &) parent_type::operator =((pointer_type) pPointer);
	}

	T * operator ->()
	{
		return *this;
	}

    bool IsValid()
	{
		return *this != 0;
	}
};

//////////////////////////////////////////////////////////////////////////
//
// CCppMem
//
// Wrapper class for allocations through C++ new[] and delete[] operators
//

template <class T>
class CCppMem : public CPointer<T, CCppMem<T> >
{
	typedef CPointer<T, CCppMem<T> > parent_type;

public:
	CCppMem()
	{
	}

	CCppMem(
		const T *pPointer
	) :
		parent_type(pPointer)
	{
	}

	explicit
	CCppMem(
		size_t nSize,
        BOOL   bZeroInit = FALSE
	) : 
		parent_type(new T[nSize])
    {
        if (bZeroInit) 
        {
            ZeroMemory(*this, sizeof(T) * nSize);
        }
    }

    // bugbug: why isn't this inherited?
    CCppMem & operator =(const T *pPointer)
	{
        return (CCppMem &) parent_type::operator =(pPointer);
	}

	void Destroy()
	{
		delete [] *this;
	}
};


//////////////////////////////////////////////////////////////////////////
//
// CGlobalMem
//
// Wrapper class for allocations through GlobalAlloc() GlobalFree() APIs
//

template <class T>
class CGlobalMem : public CPointer<T, CGlobalMem<T> >
{
	typedef CPointer<T, CGlobalMem<T> > parent_type;

public:
	CGlobalMem()
	{
	}

	CGlobalMem(
		const T *pPointer
	) : 
		parent_type(pPointer)
	{
	}

	explicit
	CGlobalMem(
		DWORD dwBytes,
		UINT  uFlags = GMEM_FIXED
	) : 
		parent_type((T *) ::GlobalAlloc(uFlags, dwBytes))
	{
	}

    // bugbug: why isn't this inherited?
    CGlobalMem & operator =(const T *pPointer)
	{
        return (CGlobalMem &) parent_type::operator =(pPointer);
	}

	void Destroy()
	{
		::GlobalFree(*this);
	}
};

//////////////////////////////////////////////////////////////////////////
//
// CLocalMem
//
// Wrapper class for allocations through LocalAlloc() LocalFree() APIs
//

template <class T>
class CLocalMem : public CPointer<T, CLocalMem<T> >
{
	typedef CPointer<T, CLocalMem<T> > parent_type;

public:
	CLocalMem()
	{
	}

	CLocalMem(
		const T *pPointer
	) : 
		parent_type(pPointer)
	{
	}

	explicit
	CLocalMem(
		DWORD dwBytes,
		UINT  uFlags = LMEM_FIXED
	) : 
		parent_type((T *) ::LocalAlloc(uFlags, dwBytes))
	{
	}

    // bugbug: why isn't this inherited?
    CLocalMem & operator =(const T *pPointer)
	{
        return (CLocalMem &) parent_type::operator =(pPointer);
	}

	void Destroy()
	{
		::LocalFree(*this);
	}
};

//////////////////////////////////////////////////////////////////////////
//
// CMapViewOfFile
//
// Wrapper class for memory mapped file objects
//

template <class T>
class CMapViewOfFile : public CPointer<T, CMapViewOfFile<T> >
{
public:
	CMapViewOfFile()
	{
	}

	CMapViewOfFile(  
		HANDLE hFileMappingObject,
		DWORD dwDesiredAccess,
		DWORD dwFileOffsetHigh = 0,
		DWORD dwFileOffsetLow = 0,
		DWORD dwNumberOfBytesToMap = 0,
		PVOID pBaseAddress = 0
	) :
		CPointer<T, CMapViewOfFile<T> >((T *) ::MapViewOfFileEx(
			hFileMappingObject,
			dwDesiredAccess,
			dwFileOffsetHigh,
			dwFileOffsetLow,
			dwNumberOfBytesToMap,
			pBaseAddress
		))
	{
	}

	void Destroy()
	{
		::UnmapViewOfFile(*this);
	}
};

//////////////////////////////////////////////////////////////////////////
//
// CMapFile
//
// Helper class for CreateFile(), CreateNamedPipe() and MapViewOfFileEx() APIs
//

// bugbug: these should be defined in class scope, but vc5 doesn't let me...

template <int> struct mapping_traits { };

template <> struct mapping_traits<FILE_MAP_READ> 
{ 
    enum 
    { 
        dwDesiredAccess    = GENERIC_READ, 
        dwShareMode        = FILE_SHARE_READ,
        flProtect          = PAGE_READONLY,
        dwDesiredMapAccess = FILE_MAP_READ
    }; 
};

template <> struct mapping_traits<FILE_MAP_WRITE> 
{ 
    enum 
    { 
        dwDesiredAccess    = GENERIC_READ | GENERIC_WRITE, 
        dwShareMode        = 0,
        flProtect          = PAGE_READWRITE,
        dwDesiredMapAccess = FILE_MAP_WRITE
    }; 
};

template <> struct mapping_traits<FILE_MAP_COPY> 
{ 
    enum 
    { 
        dwDesiredAccess    = GENERIC_READ | GENERIC_WRITE, 
        dwShareMode        = FILE_SHARE_READ,
        flProtect          = PAGE_WRITECOPY,
        dwDesiredMapAccess = FILE_MAP_COPY
    }; 
};

template <class T, int Access>
class CMapFile
{
public:
    CMapFile(
		PCTSTR pFileName
    ) :
        m_File(
		    pFileName,                                  // PCTSTR  pFileName
		    mapping_traits<Access>::dwDesiredAccess,    // DWORD	dwDesiredAccess
		    mapping_traits<Access>::dwShareMode,        // DWORD	dwShareMode
		    0,                                          // LPSECURITY_ATTRIBUTES 
		    OPEN_EXISTING,                              // DWORD	dwCreationDisposition
		    FILE_ATTRIBUTE_NORMAL,                      // DWORD	dwFlagsAndAttributes
		    0                                           // HANDLE  hTemplateFile
        ),

        m_Mapping(
		    m_File,                                     // HANDLE hFile
		    0,                                          // LPSECURITY_ATTRIBUTES 
		    mapping_traits<Access>::flProtect,          // DWORD  flProtect
		    0,                                          // DWORD  dwMaximumSizeHigh
		    0,                                          // DWORD  dwMaximumSizeLow
		    0                                           // PCTSTR pName
        ),

        m_ViewOfFile(
            m_Mapping,                                  // HANDLE hFileMappingObject
            mapping_traits<Access>::dwDesiredMapAccess, // DWORD  dwDesiredAccess
		    0,                                          // DWORD  dwFileOffsetHigh
		    0,                                          // DWORD  dwFileOffsetLow
		    0,                                          // DWORD  dwNumberOfBytesToMap
		    0                                           // PVOID  pBaseAddress
        )
    {
    }

    operator T *()
    {
        return m_ViewOfFile;
    }

private:
    File              m_File;
    CFileMapping      m_Mapping;
    CMapViewOfFile<T> m_ViewOfFile;
};

//////////////////////////////////////////////////////////////////////////
//
// CSecurityDescriptor
//
// Wrapper class for SECURITY_DESCRIPTOR struct
//

class CSecurityDescriptor : public CCppMem<SECURITY_DESCRIPTOR>
{
public:
	explicit
	CSecurityDescriptor(
		BOOL bDaclPresent = TRUE,
		PACL pDacl = 0,
		BOOL bDaclDefaulted = FALSE  
	) :
		CCppMem<SECURITY_DESCRIPTOR>(SECURITY_DESCRIPTOR_MIN_LENGTH)
	{
		CHECK(::InitializeSecurityDescriptor(
			*this,
			SECURITY_DESCRIPTOR_REVISION
		));

		CHECK(::SetSecurityDescriptorDacl(
			*this,
			bDaclPresent,
			pDacl,
			bDaclDefaulted
		));
	}
};

//////////////////////////////////////////////////////////////////////////
//
// CSecurityAttributes
//
// Wrapper class for the SECURITY_ATTRIBUTES struct
//

class CSecurityAttributes : public SECURITY_ATTRIBUTES
{
public:
	explicit
	CSecurityAttributes(
		PSECURITY_DESCRIPTOR pSD,
		BOOL bInheritHandle = TRUE
	)
	{
		nLength					= sizeof(SECURITY_ATTRIBUTES);
		lpSecurityDescriptor	= pSD;
		bInheritHandle			= bInheritHandle;
	}
};

//////////////////////////////////////////////////////////////////////////
//
// CTokenPrivileges
//
// Wrapper class for the TOKEN_PRIVILEGES struct
//

#include <pshpack1.h>

template <int N>
struct CTokenPrivileges : public TOKEN_PRIVILEGES
{
    CTokenPrivileges()
    {
        PrivilegeCount = N;
    }

	LUID_AND_ATTRIBUTES & operator [](int i)
	{
		ASSERT(i < N);
		return Privileges[i];
	}

private:
	LUID_AND_ATTRIBUTES RemainingPrivileges[N - ANYSIZE_ARRAY];
};

#include <poppack.h>

//////////////////////////////////////////////////////////////////////////
//
// CLuid
//
// Wrapper class for the LUID struct
//

struct CLuid : public LUID
{
	CLuid(
		LPCTSTR lpSystemName,
		LPCTSTR lpName
	)
	{
		CHECK(::LookupPrivilegeValue(
			lpSystemName,
			lpName,
			this
		));
	}
};

//////////////////////////////////////////////////////////////////////////
//
// CLuidAndAttributes
//
// Wrapper class for the LUID_AND_ATTRIBUTES struct
//

struct CLuidAndAttributes : public LUID_AND_ATTRIBUTES 
{
	CLuidAndAttributes(
		const LUID& _Luid,
		DWORD _Attributes
	)
	{
		Luid = _Luid;
		Attributes = _Attributes;
	}
};

//////////////////////////////////////////////////////////////////////////
//
// CProcessToken
//
// Wrapper class for the process token object
//

class CProcessToken : public CKernelObject<CProcessToken>
{
public:
	CProcessToken()
	{
	}

	CProcessToken(
		HANDLE ProcessHandle, 
		DWORD DesiredAccess
	) 
	{
		HANDLE hHandle;

		CHECK(::OpenProcessToken(
			ProcessHandle,
			DesiredAccess,
			&hHandle
		));

		Attach(hHandle);
	}

	VOID
	AdjustTokenPrivileges(
		BOOL DisableAllPrivileges,
		PTOKEN_PRIVILEGES NewState,
		DWORD BufferLength = 0,  
		PTOKEN_PRIVILEGES PreviousState = 0,
		PDWORD ReturnLength = 0
	) const
	{
		CHECK(::AdjustTokenPrivileges(
			*this,
			DisableAllPrivileges,
			NewState,
			BufferLength,  
			PreviousState,
			ReturnLength
		));
		 
		CHECK(GetLastError() == ERROR_SUCCESS);
	}
};

//////////////////////////////////////////////////////////////////////////
//
// CLoggedOnUser
//
// Wrapper class for the logged on user object
//

class CLoggedOnUser : public CKernelObject<CLoggedOnUser>
{
public:
	CLoggedOnUser()
	{
	}

	CLoggedOnUser(
		LPTSTR lpszUsername,
		LPTSTR lpszDomain,
		LPTSTR lpszPassword,
		DWORD  dwLogonType = LOGON32_LOGON_INTERACTIVE,
		DWORD  dwLogonProvider = LOGON32_PROVIDER_DEFAULT
	)
	{
		HANDLE hHandle;

		CHECK(::LogonUser(
			lpszUsername,
			lpszDomain,
			lpszPassword,
			dwLogonType,
			dwLogonProvider,
			&hHandle
		));

		Attach(hHandle);
	}

	VOID
	Impersonate() const
	{
		CHECK(::ImpersonateLoggedOnUser(*this));
	}
};


//////////////////////////////////////////////////////////////////////////
//
// CEventSource
//
// Wrapper class for the event source object
//

class CEventSource : public CHandle<HANDLE, CEventSource>
{
	typedef CHandle<HANDLE, CEventSource> parent_type;

public:
	CEventSource()
	{
	}

	CEventSource(
		PCTSTR pUNCServerName,
		PCTSTR pSourceName
	) :
		parent_type(::RegisterEventSource(
			pUNCServerName,
			pSourceName
		))
	{
	}

	void Destroy()
	{
		::DeregisterEventSource(*this);
	}

    bool IsValid()
	{
		return *this != 0;
	}

	VOID
	ReportEvent(
		WORD wType,
		WORD wCategory,
		DWORD dwEventID,
		PSID lpUserSid,
		WORD wNumStrings,
		DWORD dwDataSize,
		PCTSTR *pStrings,
		PVOID pRawData
	) const
	{
		CHECK(::ReportEvent(
			*this,
			wType,
			wCategory,
			dwEventID,
			lpUserSid,
			wNumStrings,
			dwDataSize,
			pStrings,
			pRawData
		));
	}

	VOID
	ReportEventText(
		WORD wType,
		PCTSTR pString,
		DWORD dwEventID
	) const
	{
		PCTSTR pStrings[] = { pString };

		ReportEvent(
			wType,
			0,
			dwEventID,
			0,
			1,
			0,
			pStrings,
			0
		);
	}
};

//////////////////////////////////////////////////////////////////////////
//
// CKey
//
// Wrapper class for registry key objects and registry APIs
//

class CKey : public CHandle<HKEY, CKey>
{
public:
	CKey()
	{
	}

	CKey(
		HKEY hKey
    )
    {
		Attach(hKey);
    }

	CKey(
		HKEY hKey,
		PCTSTR pSubKey,
		REGSAM samDesired = KEY_ALL_ACCESS
	)
	{
		HKEY hHandle;

		CHECK_REG(::RegOpenKeyEx(
			hKey,
			pSubKey,
			0,
			samDesired,
			&hHandle
		));

		Attach(hHandle);
	}


	CKey(
		PCTSTR pMachineName,
		HKEY hKey
	)
	{
		HKEY hHandle;

		CHECK_REG(::RegConnectRegistry(
			pMachineName,
			hKey,
			&hHandle
		));

		Attach(hHandle);
	}


	CKey(
		HKEY hKey,
		PCTSTR pSubKey,
		PTSTR pClass,
		DWORD dwOptions,
		REGSAM samDesired = KEY_ALL_ACCESS,
		PSECURITY_ATTRIBUTES pSecurityAttributes = 0
	) 
	{
		HKEY hHandle;
		DWORD dwDisposition;

		CHECK_REG(::RegCreateKeyEx(
			hKey,
			pSubKey,
			0,
			pClass,
			dwOptions,
			samDesired,
			pSecurityAttributes,
			&hHandle,
			&dwDisposition
		));

		Attach(hHandle);
	}

	void Destroy()
	{
		::RegCloseKey(*this);
	}

    bool IsValid()
	{
		return *this != 0;
	}

	VOID 
	RegQueryValueEx(  
		PTSTR  pValueName,
		PDWORD pType,
		PVOID  pData,
		PDWORD pcbData
	) const
	{
		CHECK_REG(::RegQueryValueEx(
			*this,
			pValueName,
			0,
			pType,
			(PBYTE) pData,
			pcbData
		));
	}

	VOID 
	RegSetValueEx(  
		PTSTR pValueName,
		DWORD dwType,
		CONST VOID *pData,
		DWORD cbData
	) const
	{
		CHECK_REG(::RegSetValueEx(
			*this,
			pValueName,
			0,
			dwType,
			(PBYTE) pData,
			cbData
		));
	}

	BOOL
	RegEnumKeyEx(
		DWORD dwIndex,
		PTSTR pName,
		PDWORD pcbName,
		PTSTR pClass = 0,
		PDWORD pcbClass = 0,
		PFILETIME pftLastWriteTime = 0
	) const
	{
		LONG bResult = ::RegEnumKeyEx(
			*this,
			dwIndex,
			pName,
			pcbName,
			0,
			pClass,
			pcbClass,
			pftLastWriteTime 
		);

		if (bResult == ERROR_NO_MORE_ITEMS) 
        {
			return FALSE;
		} 

		CHECK_REG(bResult);

		return TRUE;
	}

	BOOL
	RegEnumValue(  
		DWORD dwIndex,
		PTSTR pValueName,
		PDWORD pcbValueName,
		PDWORD pType,
		PBYTE pData,
		PDWORD pcbData
	) const
	{
		LONG bResult = ::RegEnumValue(
			*this,
			dwIndex,
			pValueName,
			pcbValueName,
			0,
			pType,
			pData,
			pcbData 
		);

		if (bResult == ERROR_NO_MORE_ITEMS) 
        {
			return FALSE;
		} 

		CHECK_REG(bResult);

		return TRUE;
	}

    typedef struct _REG_INFO_KEY 
    {
        DWORD    cSubKeys;
        DWORD    cbMaxSubKeyLen;
        DWORD    cbMaxClassLen;
        DWORD    cValues;
        DWORD    cbMaxValueNameLen;
        DWORD    cbMaxValueLen;
        DWORD    cbSecurityDescriptor;
        FILETIME ftLastWriteTime;

    } REG_INFO_KEY, *PREG_INFO_KEY;

    REG_INFO_KEY 
    RegQueryInfoKey()
    {
        REG_INFO_KEY rik;

		CHECK_REG(::RegQueryInfoKey(
			*this,
            0,
            0,
            0,
            &rik.cSubKeys,
            &rik.cbMaxSubKeyLen,
            &rik.cbMaxClassLen,
            &rik.cValues,
            &rik.cbMaxValueNameLen,
            &rik.cbMaxValueLen,
            &rik.cbSecurityDescriptor,
            &rik.ftLastWriteTime
		));

        return rik;
    }
};

//////////////////////////////////////////////////////////////////////////
//
// CFindFile
//
// Wrapper class for directory search objects
//

class CFindFile : public WIN32_FIND_DATA, public CHandle<HANDLE, CFindFile>
{
public:
	CFindFile(
		PCTSTR pFileName
	)
	{
		HANDLE hHandle = ::FindFirstFile(
			pFileName, 
			this
		);

		if (hHandle == INVALID_HANDLE_VALUE) 
        {
			m_bFound = FALSE;
		} 
        else 
        {
			m_bFound = TRUE;
			Attach(hHandle);
		}
	}

	void Destroy()
	{
		::FindClose(*this);
	}

    bool IsValid()
	{
		return (HANDLE) *this != INVALID_HANDLE_VALUE;
	}

	VOID
	FindNextFile()
	{
		m_bFound = ::FindNextFile(
			*this, 
			this
		);

		CHECK(m_bFound || GetLastError() == ERROR_NO_MORE_FILES);
	}

	BOOL
	Found() const
	{
		return m_bFound;
	}

private:
	BOOL m_bFound;
};

//////////////////////////////////////////////////////////////////////////
//
// FileExists
//
// Returns TRUE if the specified file exists
//

inline BOOL FileExists(PCTSTR pName)
{
    CFindFile ff(pName);
    return ff.Found();
}

//////////////////////////////////////////////////////////////////////////
//
// DirectoryExists
//
// Returns TRUE if the specified directory exists
//

inline BOOL DirectoryExists(PCTSTR pName)
{
    TCHAR pRootDir[3];

    // change "X:\" to "X:"

    if (pName && pName[1] == _T(':') && pName[2] == _T('\\') && pName[3] == _T('\0'))
    {
        pRootDir[0] = pName[0];
        pRootDir[1] = _T(':');
        pRootDir[2] = _T('\0');

        pName = pRootDir;
    }

    CFindFile ff(pName);

    return ff.Found() && (ff.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY);
}

//////////////////////////////////////////////////////////////////////////
//
// GetFileSize
//
// Returns the size of the specified file
//

inline ULARGE_INTEGER GetFileSize(PCTSTR pFileName)
{
    CFindFile ff(pFileName);

    CHECK(ff.Found());

    ULARGE_INTEGER nSize = 
    {
        ff.nFileSizeLow, 
        ff.nFileSizeHigh
    };

    return nSize;
}

#ifdef _INC_TOOLHELP32

//////////////////////////////////////////////////////////////////////////
//
// CToolhelp32Snapshot
//
// Wrapper class for the toolhelp snapshot objects
//

class CToolhelp32Snapshot : public CKernelObject<CToolhelp32Snapshot>
{
	typedef CKernelObject<CToolhelp32Snapshot> parent_type;

public:
    explicit
	CToolhelp32Snapshot(
		DWORD dwFlags = TH32CS_SNAPALL,         
		DWORD th32ProcessID = 0
	) : 
		parent_type(CreateToolhelp32Snapshot(
			dwFlags, 
			th32ProcessID
		))
	{
	}
};

//////////////////////////////////////////////////////////////////////////
//
// CFindHeapList, CFindModule, CFindProcess, CFindThread
//
// Wrapper classes for toolhelp find functions
//

// bugbug: this template declaration is better, but VC compiler cannot resolve it yet
//template <class T, BOOL (WINAPI *fnFindFirst)(HANDLE, T *), BOOL (WINAPI *fnFindNext)(HANDLE, T *)>

#define DECLARE_TOOLHELP32_FIND(CLASSNAME, STRUCT, FINDFIRST, FINDNEXT) \
                                                                        \
class CLASSNAME : public STRUCT                                         \
{                                                                       \
public:                                                                 \
	CLASSNAME(                                                          \
		HANDLE hSnapShot                                                \
	)                                                                   \
    {                                                                   \
		m_hSnapShot = hSnapShot;                                        \
		dwSize = sizeof(STRUCT);                                        \
        m_bFound = FINDFIRST(m_hSnapShot, this);                        \
	}                                                                   \
                                                                        \
	VOID                                                                \
	FindNext()                                                          \
	{                                                                   \
		m_bFound = FINDNEXT(m_hSnapShot, this);                         \
	}                                                                   \
                                                                        \
	BOOL                                                                \
	IsFound() const                                                     \
	{                                                                   \
		return m_bFound;                                                \
	}                                                                   \
                                                                        \
private:                                                                \
	HANDLE m_hSnapShot;                                                 \
	BOOL   m_bFound;                                                    \
};                                                                      \

DECLARE_TOOLHELP32_FIND(CFindHeapList, HEAPLIST32,     Heap32ListFirst, Heap32ListNext);
DECLARE_TOOLHELP32_FIND(CFindModule,   MODULEENTRY32,  Module32First,   Module32Next);
DECLARE_TOOLHELP32_FIND(CFindProcess,  PROCESSENTRY32, Process32First,  Process32Next);
DECLARE_TOOLHELP32_FIND(CFindThread,   THREADENTRY32,  Thread32First,   Thread32Next);

//////////////////////////////////////////////////////////////////////////
//
// FindProcessId
//
// Returns the id of the process specified by name
//

inline DWORD FindProcessId(PCTSTR pProcessName)
{
    CToolhelp32Snapshot Snapshot(TH32CS_SNAPPROCESS);

    for (CFindProcess pe32(Snapshot); pe32.IsFound(); pe32.FindNext()) 
    {
   		if (_tcsicmp(FindFileNamePortion(pe32.szExeFile), pProcessName) == 0) 
        {
            return pe32.th32ProcessID;
        }
    }
    
    return 0;
}

#endif //_INC_TOOLHELP32


//////////////////////////////////////////////////////////////////////////
//
// CFindWindow
//
// Wrapper class for finding child windows
//

class CFindWindow
{
public:
	CFindWindow(
		HWND hWnd
	)
	{
		m_hChild = ::GetTopWindow(hWnd);
	}

	VOID
	FindNext()
	{
		m_hChild = ::GetNextWindow(
			m_hChild, 
			GW_HWNDNEXT
		);
	}

	operator HWND() const
	{
		return m_hChild;
	}

	BOOL
	IsFound() const
	{
		return m_hChild != 0;
	}

private:
	HWND m_hChild;
};

#ifdef _WINSVC_

//////////////////////////////////////////////////////////////////////////
//
// CService
//
// Wrapper class for service objects
//

class CService : public CHandle<SC_HANDLE, CService>
{
	typedef CHandle<SC_HANDLE, CService> parent_type;

public:
	CService()
	{
	}

	CService(
		SC_HANDLE hHandle
	) :
		parent_type(hHandle)
	{
	}

	void Destroy()
	{
		::CloseServiceHandle(*this);
	}

    bool IsValid()
	{
		return *this != 0;
	}

	VOID 
	StartService(
		DWORD dwNumServiceArgs = 0,
		LPCTSTR *lpServiceArgVectors = 0
	)
	{
        if (QueryServiceStatus().dwCurrentState != SERVICE_RUNNING) 
        {
		    CHECK(::StartService(
			    *this,
			    dwNumServiceArgs,           
			    lpServiceArgVectors
		    ));

            while (QueryServiceStatus().dwCurrentState != SERVICE_RUNNING)
            {
                //bugbug: this might cause a hang
            }
        }
    }

	SERVICE_STATUS & 
	QueryServiceStatus()
	{
		CHECK(::QueryServiceStatus(*this, &m_ss));
        return m_ss;
    }

	VOID 
	DeleteService() const
	{
		CHECK(::DeleteService(*this));
	}

	VOID 
	ControlService(
        DWORD dwControl
    )
	{
		CHECK(::ControlService(*this, dwControl, &m_ss));
    }

	VOID 
	ChangeServiceState(
        DWORD dwControl, 
        DWORD dwNewState
    )
	{
        if (QueryServiceStatus().dwCurrentState != dwNewState) 
        {
		    ControlService(dwControl);

            while (QueryServiceStatus().dwCurrentState != dwNewState)
            {
                //bugbug: this might cause a hang
            }
        }
    }

	VOID 
	StopService()
	{
        ChangeServiceState(SERVICE_CONTROL_STOP, SERVICE_STOPPED);
    }

	VOID 
	PauseService()
	{
        ChangeServiceState(SERVICE_CONTROL_PAUSE, SERVICE_PAUSED);
    }

	VOID 
	ContinueService()
	{
        ChangeServiceState(SERVICE_CONTROL_CONTINUE, SERVICE_RUNNING);
    }

	friend class CSCManager;

private:
    SERVICE_STATUS m_ss;
};

//////////////////////////////////////////////////////////////////////////
//
// CSCManager
//
// Wrapper class for service control manager
//

class CSCManager : public CHandle<SC_HANDLE, CSCManager>
{
	typedef CHandle<SC_HANDLE, CSCManager> parent_type;

public:
	explicit
	CSCManager(
		PCTSTR pRemoteComputerName = 0, 
		PCTSTR pDatabaseName = SERVICES_ACTIVE_DATABASE,
		DWORD dwDesiredAccess = SC_MANAGER_ALL_ACCESS
	) :
		parent_type(OpenSCManager(
			pRemoteComputerName, 
			pDatabaseName,
			dwDesiredAccess
		))
	{
	}

	void Destroy()
	{
		CloseServiceHandle(*this);
	}

    bool IsValid()
	{
		return *this != 0;
	}

public:
	SC_HANDLE
	CreateService(
		PCTSTR pServiceName,
		PCTSTR pDisplayName,
		DWORD  dwDesiredAccess,
		DWORD  dwServiceType,
		DWORD  dwStartType,
		DWORD  dwErrorControl,
		PCTSTR pBinaryPathName,
		PCTSTR pLoadOrderGroup = 0,
		PDWORD pdwTagId = 0,
		PCTSTR pDependencies = 0,
		PCTSTR pServiceStartName = 0,
		PCTSTR pPassword = 0
	) const
	{
		return ::CreateService(
			*this,         
			pServiceName,       
			pDisplayName,       
			dwDesiredAccess,    
			dwServiceType,      
			dwStartType,       
			dwErrorControl,		
			pBinaryPathName,   
			pLoadOrderGroup,   
			pdwTagId,           
			pDependencies,      
			pServiceStartName,  
			pPassword           
		);
	}

	SC_HANDLE
	OpenService(
		PCTSTR pServiceName,
		DWORD  dwDesiredAccess = SERVICE_ALL_ACCESS
	) const
	{
		return ::OpenService(
			*this,
			pServiceName,
			dwDesiredAccess
		);
	}
};

#endif //_WINSVC_

//////////////////////////////////////////////////////////////////////////
//
// CPath
//
// Base class for wrapper classes that deal with path names
//

#ifdef _IOSTREAM_
template <int N> class CPath;
template <int N> std::ostream &operator <<(std::ostream &os, const CPath<N> &rhs);
#endif //_IOSTREAM_

template <int N = MAX_PATH>
class CPath
{
public:
	CPath()
	{
        m_szName[0] = _T('\0');
        m_szName[1] = _T('\0');
        m_dwLength = 0;
	}

	CPath(PCTSTR pName)
	{
        assign(pName);
	}

	CPath & operator =(PCTSTR pName)
	{
        return assign(pName);
	}

    CPath & assign(PCTSTR pName)
    {
		_tcsncpy(m_szName, pName, N);
		FindLength();
		return *this;
    }

	DWORD length() const
	{
		return m_dwLength;
	}

	bool empty() const
	{
		return m_szName[0] == _T('\0');
	}

    operator PCTSTR() const
	{
		return m_szName;
	}

	PCTSTR FileName() const
	{
		return m_szName + m_dwLength + 1;
	}

	CPath & operator +=(PCTSTR pName)
	{
		SetFileName(pName);
        FindLength();
		return *this;
	}

	CPath & SetFileName(PCTSTR pName)
	{
		m_szName[m_dwLength] = _T('\\');
		_tcsncpy(m_szName + m_dwLength + 1, pName, N - m_dwLength - 1);
		return *this;
	}

	CPath & StripFileName()
	{
		m_szName[m_dwLength] = _T('\0');
		return *this;
	}

	void FindLength()
	{
		m_dwLength = _tcslen(m_szName);

		while (m_dwLength && m_szName[m_dwLength-1] == _T('\\')) 
        {
			m_szName[--m_dwLength] = _T('\0');
		}
	}

    //bugbug: just to please the VC5 compiler, drop templates

    //template <int M>
    bool operator ==(const CPath/*<M>*/ &rhs) const
    {
        return 
            m_dwLength == rhs.m_dwLength && 
            _tcscmp(m_szName, rhs.m_szName) == 0;
    }

    //template <int M>
    bool operator !=(const CPath/*<M>*/ &rhs) const
    {
        return !(*this == rhs);
    }

    //template <int M>
    bool operator >(const CPath/*<M>*/ &rhs) const
    {
        return 
            m_dwLength > rhs.m_dwLength ||
            _tcscmp(m_szName, rhs.m_szName) > 0;
    }

    //template <int M>
    bool operator <=(const CPath/*<M>*/ &rhs) const
    {
        return !(*this > rhs);
    }

    //template <int M>
    bool operator <(const CPath/*<M>*/ &rhs) const
    {
        return 
            m_dwLength < rhs.m_dwLength ||
            _tcscmp(m_szName, rhs.m_szName) < 0;
    }

    //template <int M>
    bool operator >=(const CPath/*<M>*/ &rhs) const
    {
        return !(*this < rhs);
    }

#ifdef _IOSTREAM_

    friend std::ostream &operator <<(std::ostream &os, const CPath<N> &rhs)
    {
        return os << m_szName;
    }

#endif //_IOSTREAM_

protected:
	TCHAR m_szName[N];
	DWORD m_dwLength;
};

//////////////////////////////////////////////////////////////////////////
//
// CWindowsDirectory
//
// Wrapper class for the GetWindowsDirectory() API
//

class CWindowsDirectory : public CPath<>
{
public:
	CWindowsDirectory()
	{
		CHECK(::GetWindowsDirectory(
			m_szName, 
			COUNTOF(m_szName)
		));

		FindLength();
	}
};

//////////////////////////////////////////////////////////////////////////
//
// CSystemWindowsDirectory
//
// Wrapper class for the GetSystemWindowsDirectory() API
//

class CSystemWindowsDirectory : public CPath<>
{
public:
	CSystemWindowsDirectory()
	{
        typedef UINT (WINAPI *PFN)(LPTSTR lpBuffer, UINT uSize);

        static PFN pfn = (PFN) GetProcAddress(
            ::GetModuleHandle(_T("kernel32.dll")), 
            "GetSystemWindowsDirectory"_AW
        );

        if (pfn) 
        {
	        CHECK((*pfn)(
		        m_szName, 
		        COUNTOF(m_szName)
	        ));
        } 
        else 
        {
		    CHECK(::GetWindowsDirectory(
			    m_szName, 
			    COUNTOF(m_szName)
		    ));
        }

		FindLength();
	}
};


//////////////////////////////////////////////////////////////////////////
//
// CSystemDirectory
//
// Wrapper class for the GetSystemDirectory() API
//

class CSystemDirectory : public CPath<>
{
public:
	CSystemDirectory()
	{
		CHECK(::GetSystemDirectory(
			m_szName, 
			COUNTOF(m_szName)
		));

		FindLength();
	}
};

//////////////////////////////////////////////////////////////////////////
//
// CCurrentDirectory
//
// Wrapper class for the GetCurrentDirectory() API
//

class CCurrentDirectory : public CPath<>
{
public:
	CCurrentDirectory()
	{
		CHECK(::GetCurrentDirectory(
			COUNTOF(m_szName), 
			m_szName
		));
	
		FindLength();
	}
};

//////////////////////////////////////////////////////////////////////////
//
// CModuleFileName
//
// Wrapper class for the GetModuleFileName() API
//

class CModuleFileName : public CPath<>
{
public:
	CModuleFileName(
        HMODULE hModule = 0
    )
	{
		CHECK(::GetModuleFileName(
            hModule,
			m_szName, 
			COUNTOF(m_szName)
		));

		FindLength();
	}
};

#ifdef _ICM_H_

//////////////////////////////////////////////////////////////////////////
//
// CColorDirectory
//
// Wrapper class for the GetColorDirectory() API
//

class CColorDirectory : public CPath<>
{
public:
	explicit
	CColorDirectory(
		PCTSTR pMachineName = 0
	)
	{
		m_dwLength = sizeof(m_szName);

		CHECK(GetColorDirectory(
			pMachineName,
			m_szName,
			&m_dwLength
		));
	
		FindLength();
	}
};

#endif //_ICM_H_

//////////////////////////////////////////////////////////////////////////
//
// CComputerName
//
// Wrapper class for the GetComputerName() API
//

class CComputerName : public CPath<2 + MAX_COMPUTERNAME_LENGTH + 1>
{
public:
	CComputerName(
		BOOL bUNC = FALSE
	)
	{
		if (bUNC) 
        {
			m_dwLength = COUNTOF(m_szName) - 2;

			CHECK(::GetComputerName(
				m_szName + 2, 
				&m_dwLength
			));

			m_szName[0] = '\\';
			m_szName[1] = '\\';
		} 
        else 
        {
			m_dwLength = COUNTOF(m_szName);

			CHECK(::GetComputerName(
				m_szName, 
				&m_dwLength
			));
		}

		FindLength();
	}
};

//////////////////////////////////////////////////////////////////////////
//
// CFullPathName
//
// Wrapper class for the GetFullPathName() API
//

class CFullPathName : public CPath<>
{
public:
	CFullPathName(
		PCTSTR pFileName
	)
	{
        if (pFileName && *pFileName) 
        {
		    PTSTR pFilePart;

		    CHECK(::GetFullPathName(
			    pFileName,
			    COUNTOF(m_szName),
			    m_szName,
			    &pFilePart
		    ));

		    m_dwLength = (DWORD)(pFilePart - m_szName - 1);
        }
	}
};

//////////////////////////////////////////////////////////////////////////
//
// CTempFileName
//
// Wrapper class for the GetTempPath() API
//

class CTempPath : public CPath<>
{
public:
	CTempPath()
	{
		CHECK(::GetTempPath(
			COUNTOF(m_szName),
			m_szName
		));

		FindLength();
	}
};

//////////////////////////////////////////////////////////////////////////
//
// CTempFileName
//
// Wrapper class for the GetTempFileName() API
//

class CTempFileName : public CPath<>
{
public:
	CTempFileName(
		PCTSTR pPathName,
		PCTSTR pPrefixString,
		UINT   uUnique = 0
	)
	{
		CHECK(::GetTempFileName(
			pPathName,
			pPrefixString,
			uUnique,
			m_szName
		));

		FindLength();
	}
};

//////////////////////////////////////////////////////////////////////////
//
// CWindowText
//
// Wrapper class for the GetWindowText() API
//

class CWindowText : public CPath<1024> //bugbug
{
public:
	CWindowText(
		HWND hWnd
	)
	{
        ::SetLastError(0);

		CHECK(
            ::GetWindowText(hWnd, m_szName, COUNTOF(m_szName)) || 
            ::GetLastError() == 0
        );
	}
};

//////////////////////////////////////////////////////////////////////////
//
// CSafeWindowText
//
// Helper class for the GetClassName() API (that works better on Win9x)
//

class CSafeWindowText : public CPath<1024> //bugbug
{
public:
    CSafeWindowText(
	    HWND hWnd
    )
    {
        WNDPROC pfnWndProc = (WNDPROC) GetWindowLongPtr(
            hWnd, 
            GWLP_WNDPROC
        );

        CallWindowProc(
            pfnWndProc, 
            hWnd, 
            WM_GETTEXT, 
            COUNTOF(m_szName), 
            (LPARAM) m_szName
        );
    }
};

//////////////////////////////////////////////////////////////////////////
//
// CClassName
//
// Wrapper class for the GetClassName() API
//

class CClassName : public CPath<1024> //bugbug
{
public:
	CClassName(
		HWND hWnd
	)
	{
		CHECK(::GetClassName(
			hWnd,
			m_szName,
			COUNTOF(m_szName)
		));
	}
};

//////////////////////////////////////////////////////////////////////////
//
// CConsoleTitle
//
// Wrapper class for the GetConsoleTitle() API
//

class CConsoleTitle : public CPath<1024> //bugbug
{
public:
	CConsoleTitle()
	{
		CHECK(::GetConsoleTitle(
			m_szName,
			COUNTOF(m_szName)
		));
	}
};

//////////////////////////////////////////////////////////////////////////
//
// CUserName
//
// Returns a handle to the console window
//

inline HWND GetConsoleHwnd()
{
    HWND hConsoleWnd = 0;

    try 
    {
        // read the current console title

        CConsoleTitle OldTitle;

        // change the title to a supposedly random value

        TCHAR szNewTitle[17];

        wsprintf(
            szNewTitle, 
            _T("%08x%08x"), 
            GetTickCount(), 
            GetCurrentProcessId()
        );

        SetConsoleTitle(szNewTitle);

        Sleep(50);

        // try find the window based on this new title

        HWND hWnd = FindWindow(0, szNewTitle);

        // restore the title

        SetConsoleTitle(OldTitle);

        Sleep(50);

        // compare the title of the window we found against the console title

        CWindowText HWndTitle(hWnd);

        if (_tcscmp(OldTitle, HWndTitle) == 0) 
        {
            hConsoleWnd = hWnd;
        }
    } 
    catch (const CError &) 
    {
    }

    return hConsoleWnd;
}


//////////////////////////////////////////////////////////////////////////
//
// CUserName
//
// Wrapper class for the GetUserName API
//

#ifndef UNLEN 
#define UNLEN  256
#endif //UNLEN

class CUserName : public CPath<UNLEN + 1>
{
public:
	CUserName()
	{
		m_dwLength = COUNTOF(m_szName);

		CHECK(::GetUserName(
			m_szName,
			&m_dwLength
		));
	}
};


//////////////////////////////////////////////////////////////////////////
//
// CRegString
//
// Helper class for reading a string with the RegQueryValueEx() API
//

template <int N>
class CRegString : public CPath<N>
{
public:
    CRegString()
    {
    }

	CRegString(
		HKEY   hKey,
		PCTSTR pSubKey,
		PTSTR  pValueName,
        BOOL   bExpandEnvironmentStrings = TRUE
	)
	{
		CKey Key(
			hKey,
			pSubKey,
			KEY_READ
		);

        DWORD dwType;

		m_dwLength = sizeof(m_szName);

		Key.RegQueryValueEx(
			pValueName,
			&dwType,
			m_szName,
			&m_dwLength
		);

        if (dwType == REG_EXPAND_SZ && bExpandEnvironmentStrings) 
        {
            TCHAR szExpanded[N];
        
            CHECK(ExpandEnvironmentStrings(
                m_szName, 
                szExpanded, 
                COUNTOF(szExpanded)
            ));

            _tcscpy(m_szName, szExpanded);
        }

   		FindLength();
	}

    // bugbug: Aren't we supposed to inherit this?

    CPath<N> & 
	operator =(
		PCTSTR pName
	)
	{
        return CPath<N>::operator =(pName);
	}
};

//////////////////////////////////////////////////////////////////////////
//
// CResourceString
//
// Wrapper class for the LoadString() API
//

template <int N>
class CResourceString : public CPath<N>
{
public:
    CResourceString()
    {
    }

    explicit
	CResourceString(
		UINT      uID,
		HINSTANCE hInstance = 0
	)
	{
        CHECK(m_dwLength = LoadString(
            hInstance,
            uID,
            m_szName,
            COUNTOF(m_szName)
        ));
	}   

	CResourceString(
		UINT      uID,
		HINSTANCE hInstance,
        PCTSTR    pszDefault
	)
	{
        m_dwLength = LoadString(
            hInstance,
            uID,
            m_szName,
            COUNTOF(m_szName)
        );

        if (m_dwLength == 0) 
        {
            assign(pszDefault);
        }
	}   
};

#ifdef _WINSPOOL_

//////////////////////////////////////////////////////////////////////////
//
// CPrinterDriverDirectory
//
// Wrapper class for the GetPrinterDriverDirectory() API
//

class CPrinterDriverDirectory : public CPath<>
{
public:
	explicit
	CPrinterDriverDirectory(
		PTSTR pName = 0,
		PTSTR pEnvironment = 0
	)
	{
		m_dwLength = sizeof(m_szName);

		CHECK(::GetPrinterDriverDirectory(
			pName,
			pEnvironment,
			1,
			(PBYTE) m_szName,
			m_dwLength,
			&m_dwLength
		));

		FindLength();
	}
};

//////////////////////////////////////////////////////////////////////////
//
// CPrintProcessorDirectory
//
// Wrapper class for the GetPrintProcessorDirectory() API
//

class CPrintProcessorDirectory : public CPath<>
{
public:
	explicit
	CPrintProcessorDirectory(
		PTSTR pName = 0,
		PTSTR pEnvironment = 0
	)
	{
		m_dwLength = sizeof(m_szName);

		CHECK(::GetPrintProcessorDirectory(
			pName,
			pEnvironment,
			1,
			(PBYTE) m_szName,
			m_dwLength,
			&m_dwLength
		));

		FindLength();
	}
};
		
//////////////////////////////////////////////////////////////////////////
//
// CDefaultPrinter
//
// Wrapper class for the GetDefaultPrinter() API
//

#ifndef INTERNET_MAX_HOST_NAME_LENGTH
#define INTERNET_MAX_HOST_NAME_LENGTH   256
#endif 

class CDefaultPrinter : public CPath<2 + INTERNET_MAX_HOST_NAME_LENGTH + 1 + MAX_PATH + 1>
{
public:
	CDefaultPrinter()
	{
        typedef BOOL (WINAPI *PFN)(LPTSTR, LPDWORD);
    
        static PFN pfnGetDefaultPrinter = (PFN) GetProcAddress(
            ::GetModuleHandle(_T("winspool.drv")), 
            "GetDefaultPrinter"_AW
        );

		m_dwLength = sizeof(m_szName);

        if (pfnGetDefaultPrinter) 
        {
		    pfnGetDefaultPrinter(
			    m_szName,
			    &m_dwLength
		    );
        } 
        else 
        {
            GetProfileString( 
                _T("windows"), 
                _T("device"), 
                _T(",,,"), 
                m_szName, 
                COUNTOF(m_szName)
            );

            PTSTR pComma = _tcschr(m_szName, ',');

            if (pComma) 
            {    
                *pComma = _T('\0');
            }
        }

		FindLength();
	}
};

		
//////////////////////////////////////////////////////////////////////////
//
// CPrinterDefaults
//
// Wrapper class for PRINTER_DEFAULTS struct
//

struct CPrinterDefaults : public PRINTER_DEFAULTS
{
	CPrinterDefaults(
		PTSTR		_pDatatype     = 0,
		PDEVMODE	_pDevMode      = 0,
		ACCESS_MASK _DesiredAccess = PRINTER_ALL_ACCESS
	)
	{
		pDatatype     = _pDatatype;
		pDevMode      = _pDevMode;
		DesiredAccess = _DesiredAccess;
	}
};

//////////////////////////////////////////////////////////////////////////
//
// printer_info_to_level, level_to_printer_info
//
// Traits classes to map PRINTER_INFO_XXX to level numbers and vice versa
//

template<class T> struct printer_info_to_level { };
template<> struct printer_info_to_level<PRINTER_INFO_1> { enum { level = 1 }; };
template<> struct printer_info_to_level<PRINTER_INFO_2> { enum { level = 2 }; };
template<> struct printer_info_to_level<PRINTER_INFO_3> { enum { level = 3 }; };
template<> struct printer_info_to_level<PRINTER_INFO_4> { enum { level = 4 }; };
template<> struct printer_info_to_level<PRINTER_INFO_5> { enum { level = 5 }; };
template<> struct printer_info_to_level<PRINTER_INFO_6> { enum { level = 6 }; };
template<> struct printer_info_to_level<PRINTER_INFO_7> { enum { level = 7 }; };
template<> struct printer_info_to_level<PRINTER_INFO_8> { enum { level = 8 }; };
template<> struct printer_info_to_level<PRINTER_INFO_9> { enum { level = 9 }; };

template<int N> struct level_to_printer_info { };
template<> struct level_to_printer_info<1> { typedef PRINTER_INFO_1 struct_type; };
template<> struct level_to_printer_info<2> { typedef PRINTER_INFO_2 struct_type; };
template<> struct level_to_printer_info<3> { typedef PRINTER_INFO_3 struct_type; };
template<> struct level_to_printer_info<4> { typedef PRINTER_INFO_4 struct_type; };
template<> struct level_to_printer_info<5> { typedef PRINTER_INFO_5 struct_type; };
template<> struct level_to_printer_info<6> { typedef PRINTER_INFO_6 struct_type; };
template<> struct level_to_printer_info<7> { typedef PRINTER_INFO_7 struct_type; };
template<> struct level_to_printer_info<8> { typedef PRINTER_INFO_8 struct_type; };
template<> struct level_to_printer_info<9> { typedef PRINTER_INFO_9 struct_type; };

//////////////////////////////////////////////////////////////////////////
//
// CPrinter
//
// Wrapper class for printer objects
//

class CPrinter : public CHandle<HANDLE, CPrinter>
{
	typedef CHandle<HANDLE, CPrinter> parent_type;

public:
	explicit
	CPrinter(
		PCTSTR pPrinterName,
		const PRINTER_DEFAULTS *pDefault = &CPrinterDefaults()
	)
	{
		HANDLE hHandle;

		CHECK(::OpenPrinter(
			const_cast<PTSTR>(pPrinterName),
			&hHandle,
			const_cast<PPRINTER_DEFAULTS>(pDefault)
		));

		Attach(hHandle);
	}

	CPrinter(
		PTSTR pServerName,
		const PRINTER_INFO_2 *pPrinter
	) :
		parent_type(::AddPrinter(
			pServerName,
			2,
			(PBYTE) pPrinter
		))
	{
	}

	void Destroy()
	{
		::ClosePrinter(*this);
	}

    bool IsValid()
	{
		return *this != 0;
	}

	VOID
	Delete() const
	{
		CHECK(::DeletePrinter(*this));
	}

    template <class T>
    VOID
    SetPrinter(T *pPrinterInfo)
    {
        CHECK(::SetPrinter(
            *this, 
            printer_info_to_level<T>::level, 
            (PBYTE) pPrinterInfo, 
            0
        ));
    }
};

//////////////////////////////////////////////////////////////////////////
//
// DeletePrinterDriverExRetry
//
// Helper for DeletePrinterDriverEx() API that implements wait & retry
//

inline 
BOOL
DeletePrinterDriverExRetry(
    PTSTR  pName,
    PTSTR  pEnvironment,
    PTSTR  pDriverName,
    DWORD  dwDeleteFlag,
    DWORD  dwVersionFlag,      
    int    nMaxRetries = 3,
    DWORD  dwSleepMilliseconds = 1000
)
{
    BOOL bResult = FALSE;

    for (
        int nRetries = 0; 
        (bResult = DeletePrinterDriverEx(
            pName, 
            pEnvironment, 
            pDriverName, 
            dwDeleteFlag, 
            dwVersionFlag
        )) == FALSE &&
        GetLastError() == ERROR_PRINTER_DRIVER_IN_USE &&
        nRetries < nMaxRetries; 
        ++nRetries
    ) 
    {
        Sleep(dwSleepMilliseconds);
    }

    return bResult;
}
 
//////////////////////////////////////////////////////////////////////////
//
// AddMonitor
//
// Helper for AddMonitor() API that infers the struct level at compile time
//

template<class T> struct monitor_info_to_level { };
template<> struct monitor_info_to_level<MONITOR_INFO_1> { enum { level = 1 }; };
template<> struct monitor_info_to_level<MONITOR_INFO_2> { enum { level = 2 }; };

template <class T>
inline 
BOOL 
AddMonitor(
    PTSTR pName,
    T    *pMonitors
)
{
    return ::AddMonitor(
        pName,
        monitor_info_to_level<T>::level, 
        (PBYTE) pMonitors
    );
}

//////////////////////////////////////////////////////////////////////////
//
// CPrinterChangeNotification
//
// Wrapper class for printer change notifications
//

class CPrinterChangeNotification : public CHandle<HANDLE, CPrinter>
{
  	typedef CHandle<HANDLE, CPrinter> parent_type;

public:
    CPrinterChangeNotification(
        HANDLE                  hPrinter,
        DWORD                   fdwFlags,
        PPRINTER_NOTIFY_OPTIONS pPrinterNotifyOptions = 0
    ) :
        parent_type(::FindFirstPrinterChangeNotification(
            hPrinter,
            fdwFlags,
            0,
            pPrinterNotifyOptions
        ))
    {
    }

	void Destroy()
	{
		::FindClosePrinterChangeNotification(*this);
	}

    bool IsValid()
	{
		return (HANDLE) *this != INVALID_HANDLE_VALUE;
	}

    DWORD
	FindNext(
        PPRINTER_NOTIFY_OPTIONS pPrinterNotifyOptions = 0,
        PPRINTER_NOTIFY_INFO   *ppPrinterNotifyInfo = 0
    )
	{
        DWORD dwChange;

		CHECK(::FindNextPrinterChangeNotification(
			*this, 
            &dwChange,
            pPrinterNotifyOptions,
            (PVOID *) ppPrinterNotifyInfo
		));

		return dwChange;
	}
};
				
#endif //_WINSPOOL_

//////////////////////////////////////////////////////////////////////////
//
// CStringFileInfo
//
// Helper class for creating \StringFileInfo\lang-codepage\name type strings
//

class CStringFileInfo : public CPath<80>
{
public:
    CStringFileInfo(
        WORD wLang,
        WORD wCodePage
    )
    {
        _stprintf(
            m_szName,
            _T("\\StringFileInfo\\%04X%04X"),
            wLang,
            wCodePage
        );

		FindLength();
    }

    CStringFileInfo(
        DWORD dwLangCodePage
    )
    {
        _stprintf(
            m_szName,
            _T("\\StringFileInfo\\%04X%04X"),
            LOWORD(dwLangCodePage),
            HIWORD(dwLangCodePage)
        );

		FindLength();
    }
};

//////////////////////////////////////////////////////////////////////////
//
// CVersionInfo
//
// Helper class for parsing version resource information
//

class CVersionInfo
{
public:
    CVersionInfo(
		PCTSTR pFileName = 0
	) 
	{
        CModuleFileName ModuleFileName;

		if (!pFileName) 
        {
			pFileName = ModuleFileName;
		}

		DWORD dwVerInfoSize;
		DWORD dwHandle;

        CHECK(dwVerInfoSize = GetFileVersionInfoSize(
			const_cast<PTSTR>(pFileName), 
			&dwHandle
		));

		CCppMem<BYTE> VerInfo(dwVerInfoSize);

        CHECK(::GetFileVersionInfo(
			const_cast<PTSTR>(pFileName), 
			dwHandle, 
			dwVerInfoSize, 
			VerInfo
		));

		m_VerInfo = VerInfo;
	}

  	PVOID 
    VerQueryValue(
        PCTSTR pSubBlock
    ) const 
    {
		PVOID pBuffer;
		UINT  uLen;

        CHECK(::VerQueryValue(
			m_VerInfo,
			const_cast<PTSTR>(pSubBlock),
			&pBuffer,
			&uLen
		));

		return pBuffer;
    }

    VS_FIXEDFILEINFO *GetFixedFileInfo() const 
    {
		return (VS_FIXEDFILEINFO *) VerQueryValue(_T("\\"));
    }

  	PDWORD GetTranslation() const 
    {
		return (PDWORD) VerQueryValue(_T("\\VarFileInfo\\Translation"));
    }

    PCTSTR
    GetStringFileInfo(
        WORD   wLang,
        WORD   wCodePage,
        PCTSTR pSubBlock
    ) const
    {
        return (PCTSTR) VerQueryValue(CStringFileInfo(wLang, wCodePage).SetFileName(pSubBlock));
    }

    ULARGE_INTEGER
    GetFileVersion() const
    {
        VS_FIXEDFILEINFO *pFixedFileInfo = GetFixedFileInfo();

        ULARGE_INTEGER nVersion = 
        {
            pFixedFileInfo->dwFileVersionLS, 
            pFixedFileInfo->dwFileVersionMS
        };

        return nVersion;
    }

    ULARGE_INTEGER
    GetProductVersion() const
    {
        VS_FIXEDFILEINFO *pFixedFileInfo = GetFixedFileInfo();

        ULARGE_INTEGER nVersion = 
        {
            pFixedFileInfo->dwProductVersionLS, 
            pFixedFileInfo->dwProductVersionMS
        };

        return nVersion;
    }

private:
	CCppMem<BYTE> m_VerInfo;
};


//////////////////////////////////////////////////////////////////////////
//
// CResource
//
// Wrapper class for FindResourceEx(), LoadResource() and LockResource() APIs
//

class CResource
{
public:
    CResource(
        HMODULE hModule,
        PCTSTR  pType,
        PCTSTR  pName,
        WORD    wLanguage = MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL)
    )
    {
	    HRSRC hResInfo;

	    CHECK(hResInfo = FindResourceEx(hModule, pType, pName, wLanguage));

	    HGLOBAL hResData;

	    CHECK(hResData = LoadResource(hModule, hResInfo));

        CHECK(m_pData = LockResource(hResData));

        CHECK(m_nSize = SizeofResource(hModule, hResInfo));
    }

    PVOID Data() 
    {
        return m_pData;
    }

    DWORD Size() 
    {
        return m_nSize;
    }

private:
    PVOID m_pData;
    DWORD m_nSize;
};

//////////////////////////////////////////////////////////////////////////
//
// CDialogResource
//
// Helper class for parsing a dialog resource
//

class CDialogResource
{
public:
    CDialogResource(
        HMODULE hModule,
        PCTSTR  pName,
        WORD    wLanguage = MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL)
    ) 
    {
        CResource Dlg(hModule, RT_DIALOG, pName, wLanguage);
        ParseDlgResource(Dlg.Data());
    }

    CDialogResource(
        PVOID pDlgResource
    ) 
    {
        ParseDlgResource(pDlgResource);
    }

private:
    class CParseDlgResource
    {
    public:
        CParseDlgResource(
            PVOID pDlgResource
        )
        {
            Goto(pDlgResource);
        }

        void
        Goto(PVOID pDlgResource)
        {
            m_pNextValue = (PBYTE) pDlgResource;
        }

        template <class T>
        void Read(T &Value)
        {
            Value = *(T *) m_pNextValue;
            m_pNextValue += sizeof(T);
        }

        template <>
        void Read(PWSTR &pStr)
        {
            pStr = (PWSTR) m_pNextValue;

            if (*pStr == MAXWORD)
            {
                pStr = (PWSTR) pStr[1];
                m_pNextValue += 2 * sizeof(WCHAR);
            }
            else
            {
                m_pNextValue += (wcslen(pStr) + 1) * sizeof(WCHAR);
            }
        }

    private:
        PBYTE m_pNextValue;
    };

private:
    void ParseDlgResource(PVOID pDlgResource)
    {
        ZeroMemory(this, sizeof(*this));

        CParseDlgResource Parser(pDlgResource);

        Parser.Read(dlgVer);
        Parser.Read(signature);
        
        BOOL bIsExTemplate = dlgVer == 1 && signature == MAXWORD;

        if (bIsExTemplate)
        {
            Parser.Read(helpID);
            Parser.Read(exStyle);
            Parser.Read(style);
        }
        else
        {
            Parser.Goto(pDlgResource);
            Parser.Read(style);
            Parser.Read(exStyle);
        }

        Parser.Read(cDlgItems);

        Parser.Read(x);
        Parser.Read(y);
        Parser.Read(cx);
        Parser.Read(cy);

        Parser.Read(menu);
        Parser.Read(windowClass);
        Parser.Read(title);

        if (style & DS_SHELLFONT) 
        {
            if (bIsExTemplate)
            {
                Parser.Read(pointsize);
                Parser.Read(weight);
                Parser.Read(italic);
                Parser.Read(charset);
                Parser.Read(typeface);
            }
            else
            {
                Parser.Read(pointsize);
                Parser.Read(typeface);
            }
        } 
    }

public:
    WORD   dlgVer;
    WORD   signature;
    DWORD  helpID;
    DWORD  exStyle;
    DWORD  style;
    WORD   cDlgItems;
    short  x;
    short  y;
    short  cx;
    short  cy;
    PWSTR  menu;
    PWSTR  windowClass;
    PWSTR  title;
    WORD   pointsize;
    WORD   weight; 
    BYTE   italic;
    BYTE   charset;
    PWSTR  typeface;
};


//////////////////////////////////////////////////////////////////////////
//
// CStringTable
//

template <int nFirstId, int nLastId>
class CStringTable
{
public:
	CStringTable(
		HINSTANCE hInstance = GetModuleHandle(0)
	)
	{
		TCHAR szBuffer[4098]; // max length of a resource string

		for (int i = 0; i < m_nStrings; ++i) 
        {
			int nLength = LoadString(
				hInstance,
				i + nFirstId,
				szBuffer,
				COUNTOF(szBuffer)
			);

			m_pTable[i] = new TCHAR[nLength + 1];

			if (nLength && m_pTable[i]) 
            {
				CopyMemory(
					m_pTable[i],
					szBuffer,
					nLength * sizeof(TCHAR)
				);
			}
		}
	}

	~CStringTable()
	{
		for (int i = 0; i < m_nStrings; ++i) 
        {
			if (m_pTable[i]) 
            {
				delete [] m_pTable[i];
			}
		}
	}

	PCTSTR operator[](int i)
	{
		ASSERT(nFirstId <= i && i <= nLastId);
		return m_pTable[i - nFirstId];
	}

private:
	enum { m_nStrings = nLastId - nFirstId + 1 };

	PTSTR m_pTable[m_nStrings];
};

#ifdef _NTSECAPI_

//////////////////////////////////////////////////////////////////////////
//
// CLsaUnicodeString
//
// Wrapper class for LSA_UNICODE_STRING struct
//

class CLsaUnicodeString : public LSA_UNICODE_STRING
{
public:
	CLsaUnicodeString(
		PWSTR pStr
	)
	{
		if (pStr)
        {
			Buffer        = pStr; 
			Length        = (USHORT) (wcslen(pStr) * sizeof(WCHAR));
			MaximumLength = (USHORT) (Length + sizeof(WCHAR));
		} 
        else 
        {
			Buffer        = 0; 
			Length        = 0;
			MaximumLength = 0;
		}
	}
};

#endif //_NTSECAPI_

//////////////////////////////////////////////////////////////////////////
//
// COSVersionInfo
//
// Wrapper class for GetVersion() API
//

class COSVersionInfo : public OSVERSIONINFO
{
public:
    COSVersionInfo()
    {
        dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

        CHECK(GetVersionEx(this));
    }
};

//////////////////////////////////////////////////////////////////////////
//
// COSVersionInfoEx
//
// Wrapper class for GetVersionEx() API
//

class COSVersionInfoEx : public OSVERSIONINFOEX
{
public:
    COSVersionInfoEx()
    {
        dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);

        CHECK(GetVersionEx((POSVERSIONINFO)this));
    }
};

#ifdef _INC_CDERR

//////////////////////////////////////////////////////////////////////////
//
// COpenFileName
//
// Wrapper class for GetOpenFileName() and GetSaveFileName() APIs
//

template <int nFileNameLen = MAX_PATH, int nFileTitleSize = MAX_PATH, int nCustomFilterSize = MAX_PATH>
class COpenFileName : public OPENFILENAME
{
public:
    COpenFileName(
        HWND   hWndOwner   = 0,
        PCTSTR pFilter     = 0,
        PCTSTR pInitialDir = 0,
        PCTSTR pTitle      = 0,
        PCTSTR pDefExt     = 0,
        DWORD  dwFlags     = 0
    )
    {
	    ZeroMemory(this, sizeof(*this));

        lStructSize       = sizeof(OPENFILENAME);
        hwndOwner         = hWndOwner;
        hInstance         = 0;
        lpstrFilter       = pFilter;
        lpstrCustomFilter = m_szCustomFilter;
        nMaxCustFilter    = COUNTOF(m_szCustomFilter);
        nFilterIndex      = 1;
        lpstrFile         = m_szFileName;
        nMaxFile          = COUNTOF(m_szFileName);
        lpstrFileTitle    = m_szFileTitle;
        nMaxFileTitle     = COUNTOF(m_szFileTitle);
        lpstrInitialDir   = pInitialDir;
        lpstrTitle        = pTitle;
        Flags             = 
            dwFlags |
            OFN_EXPLORER | 
            OFN_HIDEREADONLY |
            OFN_OVERWRITEPROMPT | 
            OFN_FILEMUSTEXIST;
        lpstrDefExt       = pDefExt;
    }

    BOOL
    GetOpenFileName()
    {
        BOOL bResult = ::GetOpenFileName(this);

        if (!bResult && CommDlgExtendedError() == CDERR_STRUCTSIZE) 
        {
            lStructSize = OPENFILENAME_SIZE_VERSION_400;

            bResult = ::GetOpenFileName(this);
        }

        return bResult;
    }

    BOOL
    GetSaveFileName()
    {
        BOOL bResult = ::GetSaveFileName(this);

        if (!bResult && CommDlgExtendedError() == CDERR_STRUCTSIZE) 
        {
            lStructSize = OPENFILENAME_SIZE_VERSION_400;

            bResult = ::GetSaveFileName(this);
        }

        return bResult;
    }

private:
    TCHAR m_szFileName[nFileNameLen];
    TCHAR m_szFileTitle[nFileTitleSize];
    TCHAR m_szCustomFilter[nCustomFilterSize];
};

#endif //_INC_CDERR

#ifdef _SHLOBJ_H_

//////////////////////////////////////////////////////////////////////////
//
// CBrowseInfo
//
// Wrapper class for SHBrowseForFolder() API
//

template <int nPathNameLen = MAX_PATH>
class CBrowseInfo : public BROWSEINFO
{
public:
    CBrowseInfo(
        HWND  _hWndOwner = 0,
        UINT  _ulFlags    = 0
    )
    {
	    ZeroMemory(this, sizeof(*this));

        hwndOwner      = _hWndOwner; 
        pszDisplayName = m_szPath;
        ulFlags        = _ulFlags;
    }

    BOOL
    BrowseForFolder()
    {
        LPITEMIDLIST pidl = SHBrowseForFolder(this); 

        if (pidl) 
        {
            TCHAR szPath[nPathNameLen];

            if (SHGetPathFromIDList(pidl, szPath)) 
            {
                _tcscpy(m_szPath, szPath);
            }

            SHFree(pidl); 

            return TRUE;
        }

        return FALSE;
    }

private:
    TCHAR m_szPath[nPathNameLen];
};

#endif //_SHLOBJ_H_

#ifdef _INC_SETUPAPI

//////////////////////////////////////////////////////////////////////////
//
// CInf
//
// Wrapper class for Inf file parsing object and APIs
//

class CInf : public CHandle<HINF, CInf>
{
	typedef CHandle<HINF, CInf> parent_type;

public:
	CInf()
	{
	}

	explicit
	CInf(
        PCTSTR FileName,
        PCTSTR InfClass = 0,
        DWORD  InfStyle = INF_STYLE_WIN4,
        PUINT  ErrorLine = 0
	) :
        parent_type(::SetupOpenInfFile(
            FileName,
            InfClass,
            InfStyle,
            ErrorLine
        ))
	{
	}

public:
	void Destroy()
	{
		::SetupCloseInfFile(*this);
	}

	bool IsValid()
	{
		return *this != 0;
	}
};

#endif //_INC_SETUPAPI

//////////////////////////////////////////////////////////////////////////
//
// CDisplayWaitCursor
//
// Helper class that displays the wait cursor
//

class CDisplayWaitCursor
{
    DISABLE_COPY_CONTRUCTION(CDisplayWaitCursor)

public:
    CDisplayWaitCursor()
    {
        m_hOldCursor = SetCursor(LoadCursor(0, IDC_WAIT));
    }

	~CDisplayWaitCursor()
	{
        SetCursor(m_hOldCursor);
	}

private:
    HCURSOR m_hOldCursor;
};

//////////////////////////////////////////////////////////////////////////
//
// CSystemInfo
//
// Wrapper class for the GetSystemInfo() API
//

class CSystemInfo : public SYSTEM_INFO
{
public:
    CSystemInfo()
    {
        GetSystemInfo(this);
    }
};

//////////////////////////////////////////////////////////////////////////
//
// CProc
//
// Wrapper class for the GetProcAddress() API
//

template <class prototype>
class CProc
{
public:
	CProc(
        prototype pfnDefault = 0
    ) :
		m_pfnProc(pfnDefault)
	{
	}

	CProc(
		HMODULE   hModule,
		PCSTR     pProcName
	)
	{
		CHECK(m_pfnProc = (prototype) ::GetProcAddress(
			hModule, 
			pProcName
		));
	}

	CProc(
		HMODULE   hModule,
		PCSTR     pProcName,
        prototype pfnDefault
	)
	{
		m_pfnProc = (prototype) ::GetProcAddress(
			hModule, 
			pProcName
		);

        if (m_pfnProc == 0) 
        {    
            m_pfnProc = pfnDefault;
        }
	}

	operator prototype() const
	{
		return m_pfnProc;
	}

private:
	prototype m_pfnProc;
};

//////////////////////////////////////////////////////////////////////////
//
// DECL_CWINAPI
//
// Creates wrapper classes for fail-safe API address loading
//

#define DECL_CWINAPI(return_type, decl_spec, func_name, args)       \
                                                                    \
class C##func_name : public CProc<return_type (decl_spec *) args>   \
{                                                                   \
public:                                                             \
    typedef return_type (decl_spec *prototype) args;                \
                                                                    \
    C##func_name() :                                                \
        CProc<prototype>(DefaultAPI)                                \
	{                                                               \
	}                                                               \
                                                                    \
	C##func_name(                                                   \
		HMODULE hModule,                                            \
		PCSTR pProcName = #func_name                                \
    ) :                                                             \
        CProc<prototype>(                                           \
            hModule,                                                \
            pProcName,                                              \
            DefaultAPI                                              \
        )                                                           \
    {                                                               \
    }                                                               \
                                                                    \
protected:                                                          \
	static return_type decl_spec DefaultAPI args                    \
    {                                                               \
        ::SetLastError(ERROR_CALL_NOT_IMPLEMENTED);                 \
        return 0;                                                   \
    }                                                               \
                                                                    \
} func_name                                                         \

//////////////////////////////////////////////////////////////////////////
//
// CBlob
//
// Contains a binary block of data specified by its start address and size
//

struct CBlob
{
    const void *pData;
    SIZE_T      cbData;

    CBlob()
    {
    }

    CBlob(const void *_pData, SIZE_T _cbData)
    {
        pData  = _pData;
        cbData = _cbData;
    }
};

//////////////////////////////////////////////////////////////////////////
//
// CStrBlob
//
// Contains an ANSI or UNICODE string without a terminating NULL
//

struct CStrBlob : public CBlob
{
    explicit CStrBlob(PCSTR pStr)
    {
        if (pStr) 
        {
            pData  = pStr;
            cbData = strlen(pStr) * sizeof(CHAR);
        } 
        else 
        {
            pData  = "";
            cbData = 0;
        }
    }

    explicit CStrBlob(PCWSTR pStr)
    {
        if (pStr) 
        {
            pData  = pStr;
            cbData = wcslen(pStr) * sizeof(WCHAR);
        } 
        else 
        {
            pData  = "";
            cbData = 0;
        }
    }
};

//////////////////////////////////////////////////////////////////////////
//
// CSzBlob
//
// Contains an ANSI or UNICODE string with a terminating NULL
//

struct CSzBlob : public CStrBlob
{
    explicit CSzBlob(PCSTR pStr) : CStrBlob(pStr)
    {
        cbData += sizeof(CHAR);
    }

    explicit CSzBlob(PCWSTR pStr) : CStrBlob(pStr)
    {
        cbData += sizeof(WCHAR);
    }
};

//////////////////////////////////////////////////////////////////////////
//
// CMultiSzBlob
//
// Contains a NULL terminated list of ANSI or UNICODE NULL terminated strings
//

struct CMultiSzBlob : public CBlob
{
    explicit CMultiSzBlob(PCSTR pStr)
    {
        if (pStr) 
        {
            pData  = pStr;
            cbData = (multiszlenA(pStr) + 1) * sizeof(CHAR);
        } 
        else 
        {
            pData  = "\0";
            cbData = 2 * sizeof(CHAR);
        }
    }

    explicit CMultiSzBlob(PCWSTR pStr)
    {
        if (pStr) 
        {
            pData  = pStr;
            cbData = (multiszlenW(pStr) + 1) * sizeof(WCHAR);
        } 
        else 
        {
            pData  = L"\0";
            cbData = 2 * sizeof(WCHAR);
        }
    }
};

//////////////////////////////////////////////////////////////////////////
//
// CBufferFill
//
// Helper class for filling in a block of memory in an overflow safe way
//

class CBufferFill
{
public:
    CBufferFill(PVOID pBuffer, SIZE_T cbBuffer)
    {
        m_pTop = (PBYTE) pBuffer;
        m_pEnd = (PBYTE) pBuffer + cbBuffer;
    }

    INT_PTR BytesLeft() const
    {
        return m_pEnd - m_pTop;
    }

    PVOID AddTop(const CBlob &Blob)
    {
        PVOID pDest = m_pTop;

        m_pTop += Blob.cbData;

        if (BytesLeft() >= 0) 
        {
            CopyMemory(pDest, Blob.pData, Blob.cbData);
        }

        return pDest;
    }

    PVOID AddEnd(const CBlob &Blob)
    {
        m_pEnd -= Blob.cbData;

        if (BytesLeft() >= 0) 
        {
            CopyMemory(m_pEnd, Blob.pData, Blob.cbData);
        }

        return m_pEnd;
    }

private:
    PBYTE m_pTop;
    PBYTE m_pEnd;
};

#if 0 //bugbug: not ready for prime time yet

//////////////////////////////////////////////////////////////////////////
//
// _tstring
//
// Helper class that handles UNICODE to ANSI conversions
//

_STD_BEGIN

class _tstring : public basic_string<TCHAR>
{
public:
    _tstring(PCOSTR pStr)
    {
        ostr = pStr;
    }

    _tstring &operator =(PCOSTR pStr)
    {
        ostr = pStr;
        return *this;
    }

    operator PCTSTR() const
    {
        if (empty()) 
        {
            USES_CONVERSION;
            assign(T2O(ostr.c_str()));
        }

        return c_str();
    }

    operator PCOSTR() const
    {
        if (ostr.empty()) 
        {
            USES_CONVERSION;
            ostr = T2O(c_str());
        }

        return ostr.c_str();
    }

private:
    basic_string<OCHAR> ostr;
};

_STD_END

#endif

//////////////////////////////////////////////////////////////////////////
//
// CMySimpleCriticalSection
//
// Implementation for a simple critical section class that does not
// handle recursions
//

class CMySimpleCriticalSection
{
public:
	CMySimpleCriticalSection()
	{
        m_lLockCount  = -1;
        m_hLockHandle = 0;
	}

	~CMySimpleCriticalSection()
	{
        if (m_hLockHandle)
        {
		    CloseHandle(m_hLockHandle);
        }
	}

	VOID
	Enter()
	{
        if (InterlockedIncrement(&m_lLockCount) != 0)
        {
            CheckLockHandle();
            WaitForSingleObject(m_hLockHandle, INFINITE);
        }
	}

	VOID
	Leave()
	{
        if (InterlockedDecrement(&m_lLockCount) >= 0)
        {
            CheckLockHandle();
            SetEvent(m_hLockHandle);
        }
	}

	BOOL
	TryEnter()
	{
        return InterlockedCompareExchange(&m_lLockCount, 0, -1) == -1;
	}

protected:
    VOID 
	CheckLockHandle()
    {
        if (!m_hLockHandle) 
        {
            HANDLE hLockHandle;
            
            CHECK(hLockHandle = CreateEvent(0, FALSE, FALSE, 0));

            if (InterlockedCompareExchangePointer(&m_hLockHandle, hLockHandle, 0) != 0)
            {
                // another thread initialized and stored an hLockHandle
                // before us, better close ours

                CloseHandle(hLockHandle);
            }
        }
    }

protected:
    LONG   m_lLockCount;
    HANDLE m_hLockHandle;
};

//////////////////////////////////////////////////////////////////////////
//
// CMyCriticalSection
//
// Implementation for a full blown critical section class
//

class CMyCriticalSection : public CMySimpleCriticalSection
{
public:
	CMyCriticalSection()
	{
        m_lRecursionCount  = 0;
        m_dwOwningThreadId = 0;
	}

	BOOL
	Enter(
        DWORD dwMilliseconds = INFINITE,
        BOOL  bAlertable = FALSE
    )
	{
        DWORD dwCurrentThreadId = GetCurrentThreadId();

        if (InterlockedIncrement(&m_lLockCount) == 0)
        {
            m_dwOwningThreadId = dwCurrentThreadId;
            m_lRecursionCount = 1;

            return TRUE;
        }
        else
        {
            if (m_dwOwningThreadId == dwCurrentThreadId)
            {
                ++m_lRecursionCount;

                return TRUE;
            }
            else
            {
                CheckLockHandle();

                DWORD dwWaitResult = WaitForSingleObjectEx(
                    m_hLockHandle, 
                    dwMilliseconds, 
                    bAlertable
                );
                
                if (dwWaitResult == WAIT_OBJECT_0)
                {
                    m_dwOwningThreadId = dwCurrentThreadId;
                    m_lRecursionCount = 1;

                    return TRUE;
                }
                else
                {
                    return FALSE;
                }
            }
        }
	}

	VOID
	Leave()
	{
        if (--m_lRecursionCount != 0)
        {
            InterlockedDecrement(&m_lLockCount);
        }
        else
        {
            m_dwOwningThreadId = 0;

            if (InterlockedDecrement(&m_lLockCount) >= 0)
            {
                CheckLockHandle();

                SetEvent(m_hLockHandle);
            }
        }
	}

	BOOL
	TryEnter()
	{
        DWORD dwCurrentThreadId = GetCurrentThreadId();

        if (InterlockedCompareExchange(&m_lLockCount, 0, -1) == -1)
        {
            m_dwOwningThreadId = dwCurrentThreadId;
            m_lRecursionCount = 1;

            return TRUE;
        }
        else
        {
            if (m_dwOwningThreadId == dwCurrentThreadId)
            {
                InterlockedIncrement(&m_lLockCount);
                ++m_lRecursionCount;

                return TRUE;
            }
            else
            {
                return FALSE;
            }
        }
	}

protected:
    LONG   m_lRecursionCount;
    DWORD  m_dwOwningThreadId;
};

//////////////////////////////////////////////////////////////////////////
//
// CMultipleWait
//
// Wrapper class for the WaitForMultipleObjectsEx() API
//

class CMultipleWait : public CCppMem<HANDLE>
{
public:
    CMultipleWait(
        int nCount
    ) :
        m_nCount(nCount),
        CCppMem<HANDLE>(nCount)
    {
    }

    DWORD 
    WaitFor(
        BOOL  bWaitAll = TRUE,
        DWORD dwMilliseconds = INFINITE,
        BOOL  bAlertable = FALSE
    )
    {
        return WaitForMultipleObjectsEx(
            m_nCount,
            *this,
            bWaitAll,
            dwMilliseconds,
            bAlertable
        );
    }

    void 
    Erase(
        int nFirstHandle,
        int nNumHandles = 1
    )
    {
        m_nCount -= nNumHandles;

        MoveData(
            *this + nFirstHandle, 
            *this + nFirstHandle + nNumHandles, 
            m_nCount - nFirstHandle
        );
    }

private:
    int m_nCount;
};


//////////////////////////////////////////////////////////////////////////

#endif //_WRAPPERS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiatest\cwia.h ===
// WIA.h: interface for the CWIA class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_WIA_H__D5024620_FCB4_11D2_B819_009027226441__INCLUDED_)
#define AFX_WIA_H__D5024620_FCB4_11D2_B819_009027226441__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <afxtempl.h>       // needed for CTypePtrList
#define DEFINE_IMAGE_FORMATS
#include "wia.h"       // WIA device manager
#include "callback.h"       // needed for registering callbacks
#include "cdib.h"           // needed for DIB data
#include "datacallback.h"   // needed for data callback
#include "sti.h"            // needed for STI stuff
#include "eventcallback.h"  // needed for event callback

#define MIN_PROPID 2
#define IDT_GETDATA         0
#define IDT_GETBANDEDDATA   1


// Item tree struct def
typedef struct WIAITEMTREENODEtag
{
    IWiaItem* pIWiaItem;
    long ParentID;
}WIAITEMTREENODE;

typedef struct WIADEVICENODEtag
{
    BSTR bstrDeviceID;
    BSTR bstrDeviceName;
    BSTR bstrServerName;
}WIADEVICENODE;

typedef struct WIAITEMINFONODEtag
{
    BSTR bstrPropertyName;
    PROPSPEC PropSpec;
    PROPVARIANT PropVar;
    unsigned long AccessFlags;
}WIAITEMINFONODE;

class CWIA  
{
public:

    CWIA();
    virtual ~CWIA();
    HRESULT Initialize();
    void Shutdown();
    void Restart();
    //
    // helpers
    //

    HRESULT ReadPropStr(PROPID  propid, IWiaPropertyStorage  *pIWiaPropStg,  BSTR *pbstr);
    HRESULT WritePropStr(PROPID propid, IWiaPropertyStorage  *pIWiaPropStg,  BSTR bstr);

    HRESULT ReadPropLong(PROPID  propid, IWiaPropertyStorage  *pIWiaPropStg, LONG *plval);
    HRESULT WritePropLong(PROPID propid, IWiaPropertyStorage     *pIWiaPropStg, LONG lVal);

    HRESULT WritePropGUID(PROPID propid, IWiaPropertyStorage *pIWiaPropStg, GUID guidVal);

    BOOL MoveTempFile(LPWSTR pwszTempFileName, LPCTSTR TargetFileName);
    void EnableMessageBoxErrorReport(BOOL bEnable);
    BOOL IsValidItem(IWiaItem   *pIWiaItem);
    
    //
    // Image Acquistion
    //

    HRESULT DoIWiaDataGetDataTransfer(IWiaItem *pIWiaItem, 
                                DWORD Tymed, 
                                GUID ClipboardFormat);

    HRESULT DoIWiaDataBandedTransfer(IWiaItem *pIWiaItem, 
                                DWORD Tymed, 
                                GUID ClipboardFormat);

    HRESULT DoGetImageDlg(HWND hParentWnd,
                            long DeviceType,
                            long Flags,
                            long Intent,
                            long Tymed,
                            GUID ClipboardFormat);
    
    void SetFileName(CString Filename);
    void SetPreviewWindow(HWND hWnd);
    CDib* GetDIB();
    HWND m_hPreviewWnd;
    
    //
    // Item operations
    //
    HRESULT SavePropStreamToFile(char* pFileName, IWiaItem* pIWiaItem);
    HRESULT ReadPropStreamFromFile(char* pFileName, IWiaItem* pIWiaItem);
    HRESULT GetSetPropStreamTest(IWiaItem* pIWiaItem);

    HRESULT CreateWIADevice(BSTR bstrDeviceID);
    HRESULT ReEnumerateItems();
    HRESULT EnumerateAllWIADevices();
    HRESULT EnumerateSupportedFormats(IWiaItem* pIRootItem);
    HRESULT CreateItemPropertyInformationList(IWiaItem* pIWiaItem);

    HRESULT AnalyzeItem(IWiaItem* pIWiaItem);
	HRESULT CreateChildItem(IWiaItem *pIWiaItem);
    
    CPtrList* GetItemTreeList();
    CPtrList* GetSupportedFormatList();
    IWiaItem* GetRootIWiaItem();
    long GetMinBufferSize(IWiaItem *pIWiaItem);
    
    BOOL IsRoot(POSITION Position);
    BOOL IsFolder(POSITION Position);
    WIAITEMTREENODE* GetAt(POSITION Position);
    void RemoveAt(POSITION Position);
    int GetRootItemType();
    
    //
    // event registration
    //
    HRESULT RegisterForConnectEvents(CEventCallback* pConnectEventCB);
    HRESULT UnRegisterForConnectEvents(CEventCallback* pConnectEventCB);
    HRESULT RegisterForDisConnectEvents(CEventCallback* pDisConnectEventCB);
    HRESULT UnRegisterForDisConnectEvents(CEventCallback* pDisConnectEventCB);

    //
    // Automation and UI initialization only
    //
    
    //
    // Device ID Enumerators
    //
    void Auto_ResetDeviceEnumerator();
    WIADEVICENODE* Auto_GetNextDevice();
    
    long GetWIADeviceCount();

    //
    // IWIAItem Enumerators
    //
    IWiaItem* Auto_GetNextItem();
    void Auto_ResetItemEnumerator();

    long GetWIAItemCount();

    //
    // Item Property Info Enumerators
    //
    WIAITEMINFONODE* Auto_GetNextItemPropertyInfo();
    void Auto_ResetItemPropertyInfoEnumerator();

    long GetWIAItemProperyInfoCount();

    //
    // Supported WIAFormatInfo Enumerators
    //
    WIA_FORMAT_INFO* Auto_GetNextFormatEtc();
    void Auto_ResetFormatEtcEnumerator();       

private:
    //
    // Cleanup
    //

    void Cleanup();
    void DeleteWIADeviceList();
    void DeleteActiveTreeList();
    void DeleteSupportedFormatList();
    void DeleteItemPropertyInfoList();

    //
    // Enumeration / Initialization
    //
     
    HRESULT EnumerateAllItems(IWiaItem *pIRootItem);
    HRESULT EnumNextLevel(IEnumWiaItem *pEnumItem,int ParentID);
    
    
    HRESULT CreateWIADeviceManager();
    
    //
    // private member variables
    //

    CTypedPtrList<CPtrList, WIAITEMTREENODE*> m_ActiveTreeList;
    CTypedPtrList<CPtrList, WIADEVICENODE*> m_WIADeviceList;
    CTypedPtrList<CPtrList, WIA_FORMAT_INFO*> m_SupportedFormatList;
    CTypedPtrList<CPtrList, WIAITEMINFONODE*> m_ItemPropertyInfoList;

    IWiaDevMgr* m_pIWiaDevMgr;
    IWiaItem* m_pRootIWiaItem;
    CDib* m_pDIB;
    CString m_FileName;
    CString m_ApplicationName;
    
    POSITION m_CurrentActiveTreeListPosition;
    POSITION m_CurrentDeviceListPosition;
    POSITION m_CurrentFormatEtcListPosition;
    POSITION m_CurrentItemProperyInfoListPosition;

    BOOL m_bMessageBoxReport;

    //
    // logging
    //

    void StressStatus(CString status);
    void StressStatus(CString status,HRESULT hResult);
};

#endif // !defined(AFX_WIA_H__D5024620_FCB4_11D2_B819_009027226441__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiatest\devicecmddlg.cpp ===
// DeviceCmdDlg.cpp : implementation file
//

#include "stdafx.h"
#include "wiatest.h"
#include "DeviceCmdDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// #define _REED // added for debugload of all commands

/////////////////////////////////////////////////////////////////////////////
// CDeviceCmdDlg dialog

/**************************************************************************\
* CDeviceCmdDlg::CDeviceCmdDlg()
*   
*   Constructor for the Device Command Dialog
*	
*   
* Arguments:
*   
*   pParent - Parent Window
*	
*
* Return Value:
*
*    none
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
CDeviceCmdDlg::CDeviceCmdDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CDeviceCmdDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CDeviceCmdDlg)
	m_Flags = 0;
	m_FunctionCallText = _T("");
	//}}AFX_DATA_INIT
}

/**************************************************************************\
* CDeviceCmdDlg::DoDataExchange()
*   
*   Handles control message maps to the correct member variables
*	
*   
* Arguments:
*   
*   pDX - DataExchange object
*
* Return Value:
*
*    none
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
void CDeviceCmdDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDeviceCmdDlg)
	DDX_Control(pDX, IDC_LIST_ITEMPROP, m_ItemPropertyListControl);
	DDX_Control(pDX, IDC_COMMAND_LISTBOX, m_CommandListBox);
	DDX_Text(pDX, IDC_FLAGS_EDITBOX, m_Flags);
	DDX_Text(pDX, IDC_FUNCTIONCALLTEXT, m_FunctionCallText);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CDeviceCmdDlg, CDialog)
	//{{AFX_MSG_MAP(CDeviceCmdDlg)
	ON_BN_CLICKED(IDC_SEND_COMMAND, OnSendCommand)
	ON_EN_KILLFOCUS(IDC_FLAGS_EDITBOX, OnKillfocusFlagsEditbox)
	ON_LBN_SELCHANGE(IDC_COMMAND_LISTBOX, OnSelchangeCommandListbox)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDeviceCmdDlg message handlers
/**************************************************************************\
* CDeviceCmdDlg::Initialize()
*   
*   Sets the current item to operate commands on
*	
*   
* Arguments:
*   
*   pIWiaItem - Item to use for command operations
*
* Return Value:
*
*    void
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
void CDeviceCmdDlg::Initialize(IWiaItem *pIWiaItem)
{
	m_pIWiaItem = pIWiaItem;
}
/**************************************************************************\
* CDeviceCmdDlg::OnInitDialog()
*   
*   Initializes the Command dialog's controls/display
*	
*   
* Arguments:
*   
*   none
*
* Return Value:
*
*    status
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
BOOL CDeviceCmdDlg::OnInitDialog() 
{
	CDialog::OnInitDialog();
	
	HFONT hFixedFont = (HFONT)GetStockObject(ANSI_FIXED_FONT);
	if(hFixedFont != NULL)
		m_CommandListBox.SendMessage(WM_SETFONT,(WPARAM)hFixedFont,0);

	//
	// initialize headers for Property list control
	//
	m_ItemPropertyListControl.InitHeaders();
	m_ItemPropertyListControl.DisplayItemPropData(m_pIWiaItem);
	m_Flags = 0;
	m_pOptionalItem = NULL;
	
	EnumerateDeviceCapsToListBox();
	m_CommandListBox.SetCurSel(0);
	OnSelchangeCommandListbox();
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}
/**************************************************************************\
* CDeviceCmdDlg::FormatFunctionCallText()
*   
*   Formats the Command call into a readable/displayed CString
*	
*   
* Arguments:
*   
*   none
*
* Return Value:
*
*    void
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
void CDeviceCmdDlg::FormatFunctionCallText()
{
	// format flags param
	CString strFlag;
	strFlag.Format("%d",m_Flags);

	// format GUID param
	CString strGUID;
	strGUID = ConvertGUIDToKnownCString(GetCommandFromListBox());

	// format pIWiaItem param
	CString strOptionalItem;
	strOptionalItem.Format("%p",m_pOptionalItem);

	m_FunctionCallText = "Flags =  "+strFlag+",  Command = "+strGUID+",  pIWiaItem = "+strOptionalItem+"\nhResult = " + m_strhResult;
	UpdateData(FALSE);
}
/**************************************************************************\
* CDeviceCmdDlg::EnumerateDeviceCapsToListBox()
*   
*   Enumerates all supported device commands, and events to the command selection
*	listbox
*	
*   
* Arguments:
*   
*   none
*
* Return Value:
*
*    status
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
BOOL CDeviceCmdDlg::EnumerateDeviceCapsToListBox()
{
#ifdef _REED
	// false loading of commands for debugging
	DebugLoadCommands();
#else
	WIA_DEV_CAP* pDevCap = NULL;
	IEnumWIA_DEV_CAPS* pIEnumWiaDevCaps;
	HRESULT hResult = S_OK;
	
	hResult = m_pIWiaItem->EnumDeviceCapabilities(WIA_DEVICE_COMMANDS | WIA_DEVICE_EVENTS,&pIEnumWiaDevCaps);
	if(hResult != S_OK)
	{
		AfxMessageBox("m_pIWiaItem->EnumDeviceCapabilities() Failed.." + hResultToCString(hResult));
		return FALSE;
	}
	else
	{
		int CapIndex = 0;
		do {
            pDevCap = (WIA_DEV_CAP*) LocalAlloc(LPTR, sizeof(WIA_DEV_CAP));
            if (pDevCap) {
                hResult = pIEnumWiaDevCaps->Next(1,pDevCap,NULL);
                if (hResult == S_OK)
                {
                    AddDevCapToListBox(CapIndex,pDevCap);
                    CapIndex++;
                    if(pDevCap)
                    {
                        if(pDevCap->bstrName)
                            SysFreeString(pDevCap->bstrName);
                        if(pDevCap->bstrDescription)
                            SysFreeString(pDevCap->bstrDescription);
                        CoTaskMemFree(pDevCap);
                    }
                }
            } else {
                hResult = E_OUTOFMEMORY;
                AfxMessageBox("m_pIWiaItem->EnumDeviceCapabilities() Failed.." + hResultToCString(hResult));
                return FALSE;
            }
		}while(hResult == S_OK);

		pIEnumWiaDevCaps->Release();
	}
#endif
	return TRUE;
}
/**************************************************************************\
* CDeviceCmdDlg::OnSendCommand()
*   
*   Sends the selected command
*	
*   
* Arguments:
*   
*   none
*
* Return Value:
*
*    void
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
void CDeviceCmdDlg::OnSendCommand() 
{
    // get command from list box
	GUID Command = GetCommandFromListBox();
    // get flags flags from edit box
	LONG Flags = m_Flags;
	// send command
	// set m_pOptionalItem pointer to NULL (don't release it, the app will do this later)
	m_pOptionalItem = NULL;
	
	HRESULT hResult = m_pIWiaItem->DeviceCommand(Flags,&Command,&m_pOptionalItem);
    if (hResult != S_OK)
	{
		//WIA_ERROR(("*CWIACameraPg()* m_pIWiaItem->DeviceCommand() failed hResult = 0x%lx\n",hResult));
	}
    else
	{
		if(m_pOptionalItem != NULL)
			m_ItemPropertyListControl.DisplayItemPropData(m_pOptionalItem);
	}
	m_strhResult = hResultToCString(hResult);
	UpdateData(TRUE);
	FormatFunctionCallText();
}
/**************************************************************************\
* CDeviceCmdDlg::GetCommandFromListBox()
*   
*   Returns the selected command GUID from the command list box
*	
*   
* Arguments:
*   
*   none
*
* Return Value:
*
*    GUID - selected command
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
GUID CDeviceCmdDlg::GetCommandFromListBox()
{
	// get current listbox selection
	int CurSel = m_CommandListBox.GetCurSel();
	GUID* pGUID = NULL;
	if(CurSel != -1)
	{
		// get GUID from current selection
		pGUID = (GUID*)m_CommandListBox.GetItemDataPtr(CurSel);
		if(pGUID != NULL)
			return *pGUID;
		else
		{
			AfxMessageBox("GUID is NULL");
			return WIA_CMD_SYNCHRONIZE;
		}
	}
	else
	{
		// just send back synchronize for fun.. ?/ DEBUG
		return WIA_CMD_SYNCHRONIZE;
	}
}
/**************************************************************************\
* CDeviceCmdDlg::GUIDToCString()
*   
*   Formats a GUID into a CString (There is a better way to do this..I will fix
*	this later)
*	
*   
* Arguments:
*   
*   guid - GUID to format
*
* Return Value:
*
*    CString - Formatted GUID in CString format
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
CString CDeviceCmdDlg::GUIDToCString(GUID guid)
{
	CString strGUID;
	strGUID.Format("GUID = %8x-%lx-%lx-%2x%2x%2x%2x%2x%2x%2x%2x",
		guid.Data1,
		guid.Data2,
		guid.Data3,
		guid.Data4[0],
		guid.Data4[1],
		guid.Data4[2],
		guid.Data4[3],
		guid.Data4[4],
		guid.Data4[5],
		guid.Data4[6],
		guid.Data4[7]);

	return strGUID;
}
/**************************************************************************\
* CDeviceCmdDlg::AddDevCapToListBox()
*   
*   Adds a Device capability to the command listbox
*	
*   
* Arguments:
*   
*   CapIndex - Position for the command to be placed into the command list box
*	pDevCapStruct - Device capability structure containing the supported device command info.
*
* Return Value:
*
*    status
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
BOOL CDeviceCmdDlg::AddDevCapToListBox(int CapIndex,WIA_DEV_CAP *pDevCapStruct)
{
	m_CommandListBox.InsertString(CapIndex,GUIDToCString(pDevCapStruct->guid)+"    "+(CString)pDevCapStruct->bstrDescription);
	// alloc data pointer for list box.  
	// the list box will free this memory on destruction..
	GUID* pGUID = (GUID*)LocalAlloc(LPTR,sizeof(GUID));

	memcpy(pGUID,&pDevCapStruct->guid,sizeof(GUID));
	m_CommandListBox.SetItemDataPtr(CapIndex,(LPVOID)pGUID);
	return TRUE;
}
/**************************************************************************\
* CDeviceCmdDlg::OnKillfocusFlagsbox()
*   
*   Handles the window's message when the focus has left the flags edit box
*	When focus has left the control, it updates the formatted function call text.
*	
*   
* Arguments:
*   
*   none
*
* Return Value:
*
*    void
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
void CDeviceCmdDlg::OnKillfocusFlagsEditbox() 
{
	UpdateData(TRUE);
	FormatFunctionCallText();	
}
/**************************************************************************\
* CDeviceCmdDlg::ConvertGUIDToKnownCString()
*   
*   Converts a command GUID into a readable CString for display only
*	
*   
* Arguments:
*   
*   guid - Command GUID to convert
*
* Return Value:
*
*    CString - converted GUID
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
CString CDeviceCmdDlg::ConvertGUIDToKnownCString(GUID guid)
{
	// big nasty way to convert a known command into a string..
	// no points for speed. :)
	if(guid == WIA_CMD_SYNCHRONIZE)
		return "WIA_CMD_SYNCHRONIZE";
	else if(guid == WIA_CMD_TAKE_PICTURE)
		return "WIA_CMD_TAKE_PICTURE";
	else if(guid == WIA_CMD_DELETE_ALL_ITEMS)
		return "WIA_CMD_DELETE_ALL_ITEMS";
	else if(guid == WIA_CMD_CHANGE_DOCUMENT)
		return "WIA_CMD_CHANGE_DOCUMENT";
	else if(guid == WIA_CMD_UNLOAD_DOCUMENT)
		return "WIA_CMD_UNLOAD_DOCUMENT";
	else if(guid == WIA_EVENT_DEVICE_DISCONNECTED)
		return "WIA_EVENT_DEVICE_DISCONNECTED";
	else if(guid == WIA_EVENT_DEVICE_CONNECTED)
		return "WIA_EVENT_DEVICE_CONNECTED";
	else if(guid == WIA_CMD_DELETE_DEVICE_TREE)
		return "WIA_CMD_DELETE_DEVICE_TREE";
	else if(guid == WIA_CMD_BUILD_DEVICE_TREE)
		return "WIA_CMD_BUILD_DEVICE_TREE";
	else
		return "WIA_CMD_USERDEFINED";
}

/**************************************************************************\
* CDeviceCmdDlg::DebugLoadCommands()
*   
*   Loads a set of pre-loaded commands for debugging only
*	
*   
* Arguments:
*   
*   none
*
* Return Value:
*
*    void
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
void CDeviceCmdDlg::DebugLoadCommands()
{	
	BSTR bstrCapName;
	BSTR bstrCapFriendlyName;
	WIA_DEV_CAP pDevCap[9];
		
	// load WIA_CMD_SYNCHRONIZE
	bstrCapName = ::SysAllocString(L"Syncronize");
	bstrCapFriendlyName = ::SysAllocString(L"WIA_CMD_SYNCHRONIZE");
	pDevCap[0].guid = WIA_CMD_SYNCHRONIZE;
	pDevCap[0].bstrName = bstrCapName;
	pDevCap[0].bstrDescription = bstrCapFriendlyName;
	AddDevCapToListBox(0,pDevCap);	

	// load WIA_CMD_TAKE_PICTURE
	bstrCapName = ::SysAllocString(L"Take Picture");
	bstrCapFriendlyName = ::SysAllocString(L"WIA_CMD_TAKE_PICTURE");
	pDevCap[1].guid = WIA_CMD_TAKE_PICTURE;
	pDevCap[1].bstrName = bstrCapName;
	pDevCap[1].bstrDescription = bstrCapFriendlyName;
	AddDevCapToListBox(1,&pDevCap[1]);
	
	// load WIA_CMD_DELETE_ALL_ITEMS
	bstrCapName = ::SysAllocString(L"Delete all items");
	bstrCapFriendlyName = ::SysAllocString(L"WIA_CMD_DELETE_ALL_ITEMS");
	pDevCap[2].guid = WIA_CMD_DELETE_ALL_ITEMS;
	pDevCap[2].bstrName = bstrCapName;
	pDevCap[2].bstrDescription = bstrCapFriendlyName;
	AddDevCapToListBox(2,&pDevCap[2]);
	
	// load WIA_CMD_CHANGE_DOCUMENT
	bstrCapName = ::SysAllocString(L"Change Document");
	bstrCapFriendlyName = ::SysAllocString(L"WIA_CMD_CHANGE_DOCUMENT");
	pDevCap[3].guid = WIA_CMD_CHANGE_DOCUMENT;
	pDevCap[3].bstrName = bstrCapName;
	pDevCap[3].bstrDescription = bstrCapFriendlyName;
	AddDevCapToListBox(3,&pDevCap[3]);
	
	// load WIA_CMD_UNLOAD_DOCUMENT
	bstrCapName = ::SysAllocString(L"Unload Document");
	bstrCapFriendlyName = ::SysAllocString(L"WIA_CMD_UNLOAD_DOCUMENT");
	pDevCap[4].guid = WIA_CMD_UNLOAD_DOCUMENT;
	pDevCap[4].bstrName = bstrCapName;
	pDevCap[4].bstrDescription = bstrCapFriendlyName;
	AddDevCapToListBox(4,&pDevCap[4]);

	// load WIA_EVENT_DEVICE_DISCONNECTED
	bstrCapName = ::SysAllocString(L"Disconnect Event");
	bstrCapFriendlyName = ::SysAllocString(L"WIA_EVENT_DEVICE_DISCONNECTED");
	pDevCap[5].guid = WIA_EVENT_DEVICE_DISCONNECTED;
	pDevCap[5].bstrName = bstrCapName;
	pDevCap[5].bstrDescription = bstrCapFriendlyName;
	AddDevCapToListBox(5,&pDevCap[5]);

	// load WIA_EVENT_DEVICE_CONNECTED
	bstrCapName = ::SysAllocString(L"Connect Event");
	bstrCapFriendlyName = ::SysAllocString(L"WIA_EVENT_DEVICE_CONNECTED");
	pDevCap[6].guid = WIA_EVENT_DEVICE_CONNECTED;
	pDevCap[6].bstrName = bstrCapName;
	pDevCap[6].bstrDescription = bstrCapFriendlyName;
	AddDevCapToListBox(6,&pDevCap[6]);

	// load WIA_CMD_DELETE_DEVICE_TREE
	bstrCapName = ::SysAllocString(L"Delete Device Tree");
	bstrCapFriendlyName = ::SysAllocString(L"WIA_CMD_DELETE_DEVICE_TREE");
	pDevCap[7].guid = WIA_CMD_DELETE_DEVICE_TREE;
	pDevCap[7].bstrName = bstrCapName;
	pDevCap[7].bstrDescription = bstrCapFriendlyName;
	AddDevCapToListBox(7,&pDevCap[7]);	

	// load WIA_CMD_BUILD_DEVICE_TREE
	bstrCapName = ::SysAllocString(L"Build Device Tree");
	bstrCapFriendlyName = ::SysAllocString(L"WIA_CMD_BUILD_DEVICE_TREE");
	pDevCap[8].guid = WIA_CMD_BUILD_DEVICE_TREE;
	pDevCap[8].bstrName = bstrCapName;
	pDevCap[8].bstrDescription = bstrCapFriendlyName;
	AddDevCapToListBox(8,&pDevCap[8]);	
}

/**************************************************************************\
* CDeviceCmdDlg::OnSelchangeCommandListbox()
*   
*   Handles the window's message when a user changes the selection in the 
*	command listbox
*	
*   
* Arguments:
*   
*   none
*
* Return Value:
*
*    void
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
void CDeviceCmdDlg::OnSelchangeCommandListbox() 
{
	UpdateData(TRUE);
	FormatFunctionCallText();	
}
/**************************************************************************\
* CDeviceCmdDlg::hResultToCString()
*   
*   Converts a hResult value into a readable CString for display only
*	
*   
* Arguments:
*   
*   hResult - some HRESULT
*
* Return Value:
*
*    CString - readable error return
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
CString CDeviceCmdDlg::hResultToCString(HRESULT hResult)
{
	CString strhResult = "";
	ULONG ulLen = 0;
	LPTSTR  pMsgBuf;
	ulLen = ::FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
                            NULL, hResult, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                            (LPTSTR)&pMsgBuf, 0, NULL);
    if (ulLen)
    {
        strhResult = pMsgBuf;
		strhResult.TrimRight();
		LocalFree(pMsgBuf);
    }
    else
	{
		// use sprintf to write to buffer instead of .Format member of
		// CString.  This conversion works better for HEX
		char buffer[255];
		sprintf(buffer," 0x%08X",hResult);
		strhResult = buffer;
	}
	
	return strhResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiatest\datacallback.h ===
// DataCallback.h: interface for the CDataCallback class.
//
//////////////////////////////////////////////////////////////////////

#ifndef _INC_DATACALLBACK
#define _INC_DATACALLBACK

#include "resource.h"
#include "cwia.h"
#include "Mainfrm.h"

#define WM_STATUS WM_USER+5
// IWiaDataCallback
class CWiaDataCallback : public IWiaDataCallback
{
private:
   ULONG                    m_cRef;         // Object reference count.  
   PBYTE                    m_pBuffer;      // complete data buffer
   LONG                     m_MemBlockSize;
   LONG                     m_BytesTransfered;
   GUID                     m_cFormat;  
   CMainFrame*              m_pMainFrm;
   HWND                     m_hPreviewWnd;
   long                     m_lPageCount;
public:

    CWiaDataCallback();
    ~CWiaDataCallback();

    // IUnknown members that delegate to m_pUnkRef.
    HRESULT _stdcall QueryInterface(const IID&,void**);
    ULONG   _stdcall AddRef();
    ULONG   _stdcall Release();
    HRESULT _stdcall Initialize(HWND hPreviewWnd = NULL);
    HRESULT _stdcall BandedDataCallback(
       LONG                            lMessage,
       LONG                            lStatus,
       LONG                            lPercentComplete,
       LONG                            lOffset,
       LONG                            lLength,
       LONG                            lReserved,
       LONG                            lResLength,
       BYTE*                           pbBuffer);

    //
    // helpers
    //
    
    BYTE* _stdcall GetDataPtr();

private:

    void PaintPreviewWindow(long lOffset);
    void ScaleBitmapToDC(HDC hDC, HDC hDCM, LPRECT lpDCRect, LPRECT lpDIBRect);
    void ScreenRectToClientRect(HWND hWnd,LPRECT pRect);
    
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiatest\datacallback.cpp ===
// DataCallback.cpp: implementation of the CDataCallback class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "WIATest.h"
#include "DataCallback.h"

#define IT_MSG_DATA_HEADER                      0x0001
#define IT_MSG_DATA                             0x0002
#define IT_MSG_STATUS                           0x0003
#define IT_MSG_TERMINATION                      0x0004

// #define _DEBUGCALLBACK

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

/**************************************************************************\
* CWiaDataCallback::QueryInterface()
*
*   QI for IWiadataCallback Interface
*
*
* Arguments:
*
*   iid - Interface ID
*   ppv - Callback Interface pointer
*
* Return Value:
*
*    none
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
HRESULT _stdcall CWiaDataCallback::QueryInterface(const IID& iid, void** ppv)
{
    *ppv = NULL;
    if (iid == IID_IUnknown || iid == IID_IWiaDataCallback)
        *ppv = (IWiaDataCallback*) this;
    else
        return E_NOINTERFACE;
    AddRef();
    return S_OK;
}

/**************************************************************************\
* CWiaDataCallback::AddRef()
*
*   Increment the Ref count
*
*
* Arguments:
*
*   none
*
* Return Value:
*
*    ULONG - current ref count
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
ULONG   _stdcall CWiaDataCallback::AddRef()
{
    InterlockedIncrement((long*) &m_cRef);
    return m_cRef;
}

/**************************************************************************\
* CWiaDataCallback::Release()
*
*   Release the callback Interface
*
*
* Arguments:
*
*   none
*
* Return Value:
*
*   ULONG - Current Ref count
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
ULONG   _stdcall CWiaDataCallback::Release()
{
    ULONG ulRefCount = m_cRef - 1;
    if (InterlockedDecrement((long*) &m_cRef) == 0)
    {
        delete this;
        return 0;
    }
    return ulRefCount;
}

/**************************************************************************\
* CWiaDataCallback::CWiaDataCallback()
*
*   Constructor for callback class
*
*
* Arguments:
*
*   none
*
* Return Value:
*
*    none
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
CWiaDataCallback::CWiaDataCallback()
{
    m_cRef              = 0;
    m_pBuffer           = NULL;
    m_BytesTransfered   = 0;
    m_hPreviewWnd       = NULL;
}

/**************************************************************************\
* CWiaDataCallback::~CWiaDataCallback()
*
*   Destructor for Callback class
*
*
* Arguments:
*
*   none
*
* Return Value:
*
*    none
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
CWiaDataCallback::~CWiaDataCallback()
{
    if (m_pBuffer != NULL)
    {
        LocalFree(m_pBuffer);
        m_pBuffer = NULL;
    }
    // destroy progress dlg
    m_pMainFrm->SetProgressText(TEXT("Ready"));
    m_pMainFrm->UpdateProgress(50);
    m_pMainFrm->DestroyProgressCtrl();
}

/**************************************************************************\
* CWiaDataCallback::Initialize()
*
*   Initializes Progress control.
*
*
* Arguments:
*
*   none
*
* Return Value:
*
*    none
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
HRESULT _stdcall CWiaDataCallback::Initialize(HWND hPreviewWnd)
{
    CWIATestApp* pApp = (CWIATestApp*)AfxGetApp();
    m_pMainFrm = (CMainFrame*)pApp->GetMainWnd();

    if (m_pMainFrm != NULL)
    {
        m_pMainFrm->InitializeProgressCtrl("Starting Transfer");
    }

    m_hPreviewWnd = hPreviewWnd;
    m_lPageCount = 0;
    return S_OK;
}

/**************************************************************************\
* CWiaDataCallback::BandedDataCallback()
*
*   Callback member which handles Banded Data transfers
*
*
* Arguments:
*
*   lMessage - callback message
*   lStatus - additional message information
*   lPercentComplete - current percent complete status
*   lOffset - amount of data offset (bytes)
*   lLength - amount of data read (bytes)
*   lReserved - not used
*   lResLength - not used
*   pbBuffer - Data header information
*
* Return Value:
*
*    status
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
HRESULT _stdcall CWiaDataCallback::BandedDataCallback(
       LONG                            lMessage,
       LONG                            lStatus,
       LONG                            lPercentComplete,
       LONG                            lOffset,
       LONG                            lLength,
       LONG                            lReserved,
       LONG                            lResLength,
       BYTE*                           pbBuffer)
{

    char szDBG[MAX_PATH];
    static BOOL bMorePages = FALSE;
    switch (lMessage)
    {
    case IT_MSG_DATA_HEADER:
        {
            PWIA_DATA_CALLBACK_HEADER pHeader = (PWIA_DATA_CALLBACK_HEADER)pbBuffer;
            m_MemBlockSize      = pHeader->lBufferSize;

            //
            // If the Buffer is 0, then alloc a 64k chunk (default)
            //

            if(m_MemBlockSize <= 0)
                m_MemBlockSize = 65535;

            m_pBuffer           = (PBYTE)LocalAlloc(LPTR,m_MemBlockSize);
            m_BytesTransfered   = 0;
            m_cFormat           = pHeader->guidFormatID;

            #ifdef _DEBUGCALLBACK

            sprintf(szDBG,"Reading Header information\n");
            OutputDebugString(szDBG);
            sprintf(szDBG,"Header info:\n");
            OutputDebugString(szDBG);
            sprintf(szDBG,"   lBufferSize = %li\n",pHeader->lBufferSize);
            OutputDebugString(szDBG);
            sprintf(szDBG,"   lFormat = %li\n",pHeader->lFormat);
            OutputDebugString(szDBG);
            sprintf(szDBG,"   BytesTransferred = %li\n",m_BytesTransfered);
            OutputDebugString(szDBG);

            #endif
        }
        break;

    case IT_MSG_DATA:
        {

            if (m_pBuffer != NULL)
            {
                if(bMorePages/*m_cFormat == CF_MULTI_TIFF*/){

                    //
                    // Display current page count + 1, because Page count is zero based.
                    //

                    sprintf(szDBG,"Page(%d)  %d%% Complete..",(m_lPageCount + 1), lPercentComplete);
                }
                else
                    sprintf(szDBG,"%d%% Complete..",lPercentComplete);
                m_pMainFrm->SetProgressText(szDBG);
                m_pMainFrm->UpdateProgress(lPercentComplete);

                m_BytesTransfered += lLength;
                if(m_BytesTransfered >= m_MemBlockSize){

                    //
                    // Alloc more memory for transfer buffer
                    //
                    m_MemBlockSize += (lLength * 2);
                    m_pBuffer = (PBYTE)LocalReAlloc(m_pBuffer,m_MemBlockSize,LMEM_MOVEABLE);
                }

                #ifdef _DEBUGCALLBACK

                sprintf(szDBG," Memory BLOCK size = %li\n",m_MemBlockSize);
                OutputDebugString(szDBG);
                sprintf(szDBG," writing %li\n",lLength);
                OutputDebugString(szDBG);
                sprintf(szDBG," lOffset = %li, lLength = %li, BytesTransferred = %li\n",lOffset,lLength,m_BytesTransfered);
                OutputDebugString(szDBG);

                #endif

                memcpy(m_pBuffer + lOffset, pbBuffer, lLength);

                //
                // Paint preview window during callback
                //

                // WiaImgFmt_UNDEFINED

                // ???? m_cFormat == WiaImgFmt_BMP)

                if(m_cFormat == WiaImgFmt_MEMORYBMP)
                    PaintPreviewWindow(lOffset);
                else if (m_cFormat == WiaImgFmt_TIFF) {
                    if (lPercentComplete == 100) {
                        OutputDebugString("----------------------------------> Paint a Page\n");
                    }
                }
           }
        }
        break;

    case IT_MSG_STATUS:
        {
            if (lStatus & IT_STATUS_TRANSFER_FROM_DEVICE)
            {
                m_pMainFrm->SetProgressText(TEXT("Transfer from device"));
                m_pMainFrm->UpdateProgress(lPercentComplete);

            }
            else if (lStatus & IT_STATUS_PROCESSING_DATA)
            {
                m_pMainFrm->SetProgressText(TEXT("Processing Data"));
                m_pMainFrm->UpdateProgress(lPercentComplete);

            }
            else if (lStatus & IT_STATUS_TRANSFER_TO_CLIENT)
            {
                m_pMainFrm->SetProgressText(TEXT("Transfer to Client"));
                m_pMainFrm->UpdateProgress(lPercentComplete);
            }
        }
        break;

    case IT_MSG_NEW_PAGE:
        bMorePages = TRUE;
        PWIA_DATA_CALLBACK_HEADER pHeader = (PWIA_DATA_CALLBACK_HEADER)pbBuffer;
        m_lPageCount =  pHeader->lPageCount;
        sprintf(szDBG,"IT_MSG_NEW_PAGE, page count: %d\n", pHeader->lPageCount);
        OutputDebugString(szDBG);
        break;
    }
   return S_OK;
}

/**************************************************************************\
* CWiaDataCallback::PaintPreviewWindow()
*
*   Paint buffer to preview window
*
*
* Arguments:
*
*   lOffset - Data offset
*
* Return Value:
*
*    void
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
void CWiaDataCallback::PaintPreviewWindow(long lOffset)
{
    if (m_hPreviewWnd != NULL) {

        HDC hdc             = NULL;
        HDC hdcm            = NULL;
        LPBITMAPINFO pbmi   = NULL;
        LPBITMAPINFO pbmih  = NULL;
        PBYTE pDib          = NULL;
        HBITMAP hBitmap     = NULL;
        BITMAP  bm;

        hdc = GetDC(m_hPreviewWnd);
        if(hdc != NULL){
           hdcm = CreateCompatibleDC(hdc);
           if(hdcm != NULL){
               pbmi   = (LPBITMAPINFO)m_pBuffer;
                if (pbmi != NULL) {
                    hBitmap = CreateDIBSection(hdc,pbmi,DIB_RGB_COLORS,(void **)&pDib,NULL,0);

                    if (hBitmap != NULL) {
                        memset(pDib,255,pbmi->bmiHeader.biSizeImage); // white preview backgound..
                        memcpy(pDib,m_pBuffer + sizeof(BITMAPINFOHEADER) + (sizeof(RGBQUAD) * pbmi->bmiHeader.biClrUsed),lOffset);


                        GetObject(hBitmap,sizeof(BITMAP),(LPSTR)&bm);
                        SelectObject(hdcm,hBitmap);

                        RECT ImageRect;
                        RECT WindowRect;

                        ImageRect.top = 0;
                        ImageRect.left = 0;
                        ImageRect.right = bm.bmWidth;
                        ImageRect.bottom = bm.bmHeight;

                        GetWindowRect(m_hPreviewWnd,&WindowRect);
                        ScreenRectToClientRect(m_hPreviewWnd,&WindowRect);
                        ScaleBitmapToDC(hdc,hdcm,&WindowRect,&ImageRect);

                        DeleteObject(hBitmap);
                    }
                }
               DeleteDC(hdcm);
           }
           DeleteDC(hdc);
        }
    }
}
/**************************************************************************\
* CWiaDataCallback::ScreenRectToClientRect()
*
*   Converts a RECT into Client coordinates
*
*
* Arguments:
*
*   hWnd - Client Window handle
*   pRect - converted LPRECT
*
* Return Value:
*
*    void
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
void CWiaDataCallback::ScreenRectToClientRect(HWND hWnd,LPRECT pRect)
{
    POINT PtConvert;

    PtConvert.x = pRect->left;
    PtConvert.y = pRect->top;

    //
    // convert upper left point
    //

    ScreenToClient(hWnd,&PtConvert);

    pRect->left = PtConvert.x;
    pRect->top = PtConvert.y;

    PtConvert.x = pRect->right;
    PtConvert.y = pRect->bottom;

    //
    // convert lower right point
    //

    ScreenToClient(hWnd,&PtConvert);

    pRect->right = PtConvert.x;
    pRect->bottom = PtConvert.y;

    pRect->bottom-=1;
    pRect->left+=1;
    pRect->right-=1;
    pRect->top+=1;
}

/**************************************************************************\
* CWiaDataCallback::ScaleBitmapToDC()
*
*   Draws a BITMAP to the target DC
*
*
* Arguments:
*
*   hDC - Target DC
*   hDCM - Source DC
*   lpDCRect - DC window rect
*   lpDIBRect - DIB's rect
*
* Return Value:
*
*    void
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
void CWiaDataCallback::ScaleBitmapToDC(HDC hDC, HDC hDCM, LPRECT lpDCRect, LPRECT lpDIBRect)
{
    // BitBlt(hDC,0,0,lpDIBRect->right,lpDIBRect->bottom,hDCM,0,0,SRCCOPY);

    float lWidthVal  = 1;
    float lHeightVal = 1;

    // Make sure to use the stretching mode best for color pictures
    ::SetStretchBltMode(hDC, COLORONCOLOR);

    // Determine whether to call StretchDIBits() or SetDIBitsToDevice()
    BOOL bSuccess;
    if ((RECTWIDTH(lpDCRect)  == RECTWIDTH(lpDIBRect)) &&
        (RECTHEIGHT(lpDCRect) == RECTHEIGHT(lpDIBRect)))
        bSuccess = ::BitBlt (hDC,                   // hDC
                             lpDCRect->left,        // DestX
                             lpDCRect->top,         // DestY
                             RECTWIDTH(lpDCRect),   // nDestWidth
                             RECTHEIGHT(lpDCRect),  // nDestHeight
                             hDCM,
                             0,
                             0,
                             SRCCOPY);
    else {
        //Window width becomes smaller than original image width
        if (RECTWIDTH(lpDIBRect) > lpDCRect->right - lpDCRect->left) {
            lWidthVal = (float)(lpDCRect->right - lpDCRect->left)/RECTWIDTH(lpDIBRect);
        }
        //Window height becomes smaller than original image height
        if (RECTHEIGHT(lpDIBRect) > lpDCRect->bottom - lpDCRect->top) {
            lHeightVal = (float)(lpDCRect->bottom - lpDCRect->top)/RECTHEIGHT(lpDIBRect);
        }
        long ScaledWidth = (int)(RECTWIDTH(lpDIBRect) * min(lWidthVal,lHeightVal));
        long ScaledHeight = (int)(RECTHEIGHT(lpDIBRect) * min(lWidthVal,lHeightVal));
        bSuccess = ::StretchBlt(hDC,            // hDC
                                lpDCRect->left,               // DestX
                                lpDCRect->top,                // DestY
                                ScaledWidth,                  // nDestWidth
                                ScaledHeight,                 // nDestHeight
                                hDCM,
                                /*lpDIBRect->left*/0,              // SrcX
                                /*lpDIBRect->top*/0,               // SrcY
                                RECTWIDTH(lpDIBRect),         // wSrcWidth
                                RECTHEIGHT(lpDIBRect),        // wSrcHeight
                                SRCCOPY);                     // dwROP

        // update outline areas
        // Invalidated right side rect
        RECT WindowRect;
        WindowRect.top = lpDCRect->top;
        WindowRect.left = lpDCRect->left + ScaledWidth;
        WindowRect.right = lpDCRect->right;
        WindowRect.bottom = lpDCRect->bottom;

        HBRUSH hBrush = CreateSolidBrush(GetBkColor(hDC));
        FillRect(hDC,&WindowRect,hBrush);

        // Invalidated bottom rect
        WindowRect.top = lpDCRect->top + ScaledHeight;
        WindowRect.left = lpDCRect->left;
        WindowRect.right = lpDCRect->left + ScaledWidth;
        WindowRect.bottom = lpDCRect->bottom;

        FillRect(hDC,&WindowRect,hBrush);
        DeleteObject(hBrush);
    }
}

/**************************************************************************\
* CWiaDataCallback::GetDataPtr()
*
*   Returns the memory acquired during a transfer
*
*
* Arguments:
*
*   none
*
* Return Value:
*
*    BYTE* pBuffer - memory block
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
// GetDataPtr
BYTE* _stdcall CWiaDataCallback::GetDataPtr()
{
    return m_pBuffer;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiatest\eventcallback.h ===
// eventcallback.h
#ifndef _INC_EVENT_CALLBACK
#define _INC_EVENT_CALLBACK

#define ID_WIAEVENT_CONNECT		0
#define ID_WIAEVENT_DISCONNECT	1


/////////////////////////////////////////////////////////////////////////////
// CEventCallback

class CEventCallback : public IWiaEventCallback
{
private:
   ULONG	m_cRef;		// Object reference count.
   int		m_EventID;	// What kind of event is this callback for?
public:
   IUnknown *m_pIUnkRelease; // release server registration
public:
    // Constructor, initialization and destructor methods.
    CEventCallback();
    ~CEventCallback();

    // IUnknown members that delegate to m_pUnkRef.
    HRESULT _stdcall QueryInterface(const IID&,void**);
    ULONG   _stdcall AddRef();
    ULONG   _stdcall Release();
    HRESULT _stdcall Initialize(int EventID);

    HRESULT _stdcall ImageEventCallback(
        const GUID      *pEventGUID,
        BSTR            bstrEventDescription,
        BSTR            bstrDeviceID,
        BSTR            bstrDeviceDescription,
        DWORD           dwDeviceType,
        BSTR            bstrFullItemName,
        ULONG           *plEventType,
        ULONG           ulReserved);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiatest\devicecmddlg.h ===
#if !defined(AFX_DEVICECMDDLG_H__9C06742C_DBF4_11D2_B1CD_009027226441__INCLUDED_)
#define AFX_DEVICECMDDLG_H__9C06742C_DBF4_11D2_B1CD_009027226441__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// DeviceCmdDlg.h : header file
//
#include "WIATestUI.h"
/////////////////////////////////////////////////////////////////////////////
// CDeviceCmdDlg dialog

class CDeviceCmdDlg : public CDialog
{
// Construction
public:
	CString m_strhResult;
	CString hResultToCString(HRESULT hResult);
	void DebugLoadCommands();
	CString ConvertGUIDToKnownCString(GUID guid);
	BOOL AddDevCapToListBox(int CapIndex,WIA_DEV_CAP* pDevCapStruct);
	CString GUIDToCString(GUID guid);
	GUID GetCommandFromListBox();
	IWiaItem* m_pOptionalItem;
	BOOL EnumerateDeviceCapsToListBox();
	void FormatFunctionCallText();
	IWiaItem* m_pIWiaItem;
	void Initialize(IWiaItem *pIWiaItem);
	
	CDeviceCmdDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CDeviceCmdDlg)
	enum { IDD = IDD_DEVICE_COMMAND_DIALOG };
	CWIAPropListCtrl	m_ItemPropertyListControl;
	CListBox	m_CommandListBox;
	long	m_Flags;
	CString	m_FunctionCallText;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDeviceCmdDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CDeviceCmdDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnSendCommand();
	afx_msg void OnKillfocusFlagsEditbox();
	afx_msg void OnSelchangeCommandListbox();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DEVICECMDDLG_H__9C06742C_DBF4_11D2_B1CD_009027226441__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiatest\eventcallback.cpp ===
//EventCallBack.cpp

#include "stdafx.h"
#include "wiatest.h"
#include "eventcallback.h"
#include "mainfrm.h"
#include "WIATestView.h"

/////////////////////////////////////////////////////////////////////////////
// CEventCallback message handlers

/**************************************************************************\
* CEventCallback::QueryInterface()
*   
*   QI for IWiaEventCallback Interface
*	
*   
* Arguments:
*   
*   iid - Interface ID
*	ppv - Callback Interface pointer
*
* Return Value:
*
*    none
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
HRESULT _stdcall CEventCallback::QueryInterface(const IID& iid, void** ppv)
{
    *ppv = NULL;
    if (iid == IID_IUnknown || iid == IID_IWiaEventCallback)
        *ppv = (IWiaEventCallback*) this;
    else
        return E_NOINTERFACE;
    AddRef();
    return S_OK;
}

/**************************************************************************\
* CEventCallback::AddRef()
*   
*   Increment the Ref count
*	
*   
* Arguments:
*   
*   none
*
* Return Value:
*
*    ULONG - current ref count
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
ULONG   _stdcall CEventCallback::AddRef()
{
    InterlockedIncrement((long*)&m_cRef);
    return m_cRef;
}

/**************************************************************************\
* CEventCallback::Release()
*   
*   Release the callback Interface
*	
*   
* Arguments:
*   
*   none
*
* Return Value:
*
*   ULONG - Current Ref count
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
ULONG   _stdcall CEventCallback::Release()
{
	ULONG ulRefCount = m_cRef - 1;
    if (InterlockedDecrement((long*) &m_cRef) == 0)
	{
        delete this;
        return 0;
    }
    return ulRefCount;
}

/**************************************************************************\
* CEventCallback::CEventCallback()
*   
*   Constructor for callback class
*	
*   
* Arguments:
*   
*   none
*
* Return Value:
*
*    none
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
CEventCallback::CEventCallback()
{
    m_cRef = 0;
    m_pIUnkRelease = NULL;
}

/**************************************************************************\
* CEventCallback::~CEventCallback()
*   
*   Destructor for Callback class
*	
*   
* Arguments:
*   
*   none
*
* Return Value:
*
*    none
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
CEventCallback::~CEventCallback()
{
}

/**************************************************************************\
* CEventCallback::Initialize()
*   
*   Initializes Callback event type
*	
*   
* Arguments:
*   
*   none
*
* Return Value:
*
*    none
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
HRESULT _stdcall CEventCallback::Initialize(int EventID)
{
	if((EventID > 1)||(EventID < 0))
		return S_FALSE;

	m_EventID = EventID;
	return S_OK;
}

/**************************************************************************\
* CEventCallback::ImageEventCallback()
*   
*   Handles the event trapping
*	
*   
* Arguments:
*   
*   lReason - not used
*	lStatus - not used
*	lPercentComplete - not used
*	pEventGUID - not used
*	bstrDeviceID - not used
*	lReserved - not used
*
* Return Value:
*
*    status
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
HRESULT _stdcall CEventCallback::ImageEventCallback(
    const GUID                      *pEventGUID,
    BSTR                            bstrEventDescription,
    BSTR                            bstrDeviceID,
    BSTR                            bstrDeviceDescription,
    DWORD                           dwDeviceType,
    BSTR                            bstrFullItemName,
    ULONG                           *plEventType,
    ULONG                           ulReserved)
{
	CWIATestApp* pApp = (CWIATestApp*)AfxGetApp();
    CMainFrame* pFrame = (CMainFrame*)pApp->GetMainWnd();
    CWIATestView* pView = (CWIATestView*)pFrame->GetActiveView();
	switch(m_EventID)
	{
	case ID_WIAEVENT_CONNECT:
		MessageBox(NULL,"a connect event has been trapped...","WIATest Event Notice",MB_OK);
		if(pView != NULL)
		{
			pView->RefreshDeviceList();
			pView->EnumerateWIADevices();
			pView->UpdateUI();
		}
		break;
	case ID_WIAEVENT_DISCONNECT:
		MessageBox(NULL,"a disconnect event has been trapped...","WIATest Event Notice",MB_OK);
		if(pView != NULL)
		{
			pView->RefreshDeviceList();
			pView->EnumerateWIADevices();
			pView->UpdateUI();
		}
		break;
	default:
		AfxMessageBox("Ah HA!..an event just happened!!!!\n and...I have no clue what is was..");
		break;
	}
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiatest\iteminfodlg.h ===
#if !defined(AFX_ITEMINFODLG_H__7638C6C4_DB01_11D2_B1CC_009027226441__INCLUDED_)
#define AFX_ITEMINFODLG_H__7638C6C4_DB01_11D2_B1CC_009027226441__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// ItemInfoDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CItemInfoDlg dialog

class CItemInfoDlg : public CDialog
{
// Construction
public:
	void SetWindowTextToItemName(IWiaItem* pIWiaItem);
	IWiaItem* m_pIWiaItem;
	BOOL m_bAppItem;
	void Initialize(IWiaItem* pIWiaItem, BOOL bFlag = TRUE);
	CItemInfoDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CItemInfoDlg)
	enum { IDD = IDD_ITEMINFO_DIALOG };
	CEdit	m_ItemInfoEditBox;
	CString	m_ItemAddress;
	CString	m_strItemInfoEditBox;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CItemInfoDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CItemInfoDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnRefreshIteminfoButton();
	afx_msg void OnResetbackButton();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ITEMINFODLG_H__7638C6C4_DB01_11D2_B1CC_009027226441__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiatest\iteminfodlg.cpp ===
// ItemInfoDlg.cpp : implementation file
//

#include "stdafx.h"
#include "wiatest.h"
#include "ItemInfoDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CItemInfoDlg dialog

/**************************************************************************\
* CItemInfoDlg::CItemInfoDlg()
*   
*   Constructor for Item information Dialog
*	
*   
* Arguments:
*   
*   pParent - Parent Window
*
* Return Value:
*
*    none
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
CItemInfoDlg::CItemInfoDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CItemInfoDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CItemInfoDlg)
	m_ItemAddress = _T("");
	m_strItemInfoEditBox = _T("");
	//}}AFX_DATA_INIT
}

/**************************************************************************\
* CItemInfoDlg::DoDataExchange()
*   
*   Handles control message maps to the correct member variables
*	
*   
* Arguments:
*   
*   pDX - DataExchange object
*
* Return Value:
*
*    none
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
void CItemInfoDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CItemInfoDlg)
	DDX_Control(pDX, IDC_ITEMINFO_EDITBOX, m_ItemInfoEditBox);
	DDX_Text(pDX, IDC_ITEMADDRESS_EDITBOX, m_ItemAddress);
	DDX_Text(pDX, IDC_ITEMINFO_EDITBOX, m_strItemInfoEditBox);
	//}}AFX_DATA_MAP
}
/**************************************************************************\
* CItemInfoDlg::Initialize()
*   
*   Initializes Item information dialog to the correct mode
*	
*   
* Arguments:
*   
*   pIWiaItem - Item to view information about
*	bFlag -		TRUE - Application Item
*				FALSE - Driver item
*
* Return Value:
*
*    none
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
void CItemInfoDlg::Initialize(IWiaItem* pIWiaItem, BOOL bFlag)
{
	m_pIWiaItem = pIWiaItem;
	m_bAppItem = bFlag;
}

BEGIN_MESSAGE_MAP(CItemInfoDlg, CDialog)
	//{{AFX_MSG_MAP(CItemInfoDlg)
	ON_BN_CLICKED(IDC_REFRESH_ITEMINFO_BUTTON, OnRefreshIteminfoButton)
	ON_BN_CLICKED(IDC_RESETBACK_BUTTON, OnResetbackButton)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CItemInfoDlg message handlers
/**************************************************************************\
* CItemInfoDlg::OnInitDialog()
*   
*   Initializes the Item Information dialog's controls/display
*	
*   
* Arguments:
*   
*   none
*
* Return Value:
*
*    none
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
BOOL CItemInfoDlg::OnInitDialog() 
{
	CDialog::OnInitDialog();
	HRESULT hResult = S_OK;
	HFONT hFixedFont = (HFONT)GetStockObject(ANSI_FIXED_FONT);
	
	if(hFixedFont != NULL)
		m_ItemInfoEditBox.SendMessage(WM_SETFONT,(WPARAM)hFixedFont,0);
	if(m_pIWiaItem == NULL)
		AfxMessageBox("Bad item detected...");
	else
		OnResetbackButton();
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}
/**************************************************************************\
* CItemInfoDlg::OnrefreshIteminfoButton()
*   
*   Refreshes the current Item's information display
*	
*   
* Arguments:
*   
*   none
*
* Return Value:
*
*    none
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
void CItemInfoDlg::OnRefreshIteminfoButton() 
{
	int iret = 0;
	HRESULT hResult = S_OK;
	BSTR bstrItemDump;
	IWiaItem* pIWiaItem = NULL;
	// refresh information with current item Address
	// write new address to member variable
	UpdateData(TRUE);
	// read string into a pointer (conversion)
	sscanf(m_ItemAddress.GetBuffer(20),"%p",&pIWiaItem);
	m_ItemAddress.Format("%p",pIWiaItem);
	
	// clean old data from edit box
	m_strItemInfoEditBox = "";
	// read Dump
	if(m_bAppItem)
	{
		if (IsBadCodePtr((FARPROC)pIWiaItem)) 
			m_strItemInfoEditBox = "Bad Address";
		else
		{
			hResult = pIWiaItem->DumpItemData(&bstrItemDump);
			if(hResult == S_OK)
			{
				// write data to CString
				m_strItemInfoEditBox = bstrItemDump;
				// free BSTR
				SysFreeString(bstrItemDump);
				// update window text to show new item name
				SetWindowTextToItemName(pIWiaItem);
			}
			else
			{
				//WIA_ERROR(("*CItemInfoDlg()* pIWiaItem->DumpItemData() failed hResult = 0x%lx\n",hResult));
				m_strItemInfoEditBox = "<No Dump Item Data.. Check the Debugger..>";
			}
		}
	}
	else
	{
		if (IsBadCodePtr((FARPROC)pIWiaItem)) 
			m_strItemInfoEditBox = "Bad Address";
		else
		{
			hResult = pIWiaItem->DumpDrvItemData(&bstrItemDump);
			if(hResult == S_OK)
			{
				// write data to CString
				m_strItemInfoEditBox = bstrItemDump;
				// free BSTR
				SysFreeString(bstrItemDump);
				// update window text to show new item name
				SetWindowTextToItemName(pIWiaItem);
			}
			else
			{
				//WIA_ERROR(("*CItemInfoDlg()* pIWiaItem->DumpDrvItemData() failed hResult = 0x%lx\n",hResult));
				m_strItemInfoEditBox = "<No Dump Item Data.. Check the Debugger..>";
			}
		}
	}
	
	// write data to members, and update UI
	UpdateData(FALSE);
}
/**************************************************************************\
* CItemInfoDlg::SetWindowtextToItemName()
*   
*   Sets the Window's caption to display the current item's name.
*	
*   
* Arguments:
*   
*   pIWiaItem - Item to get name from
*
* Return Value:
*
*    none
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
void CItemInfoDlg::SetWindowTextToItemName(IWiaItem *pIWiaItem)
{
	HRESULT hResult = S_OK;
	CString ItemName = "Item name not found";
	IWiaPropertyStorage *pIWiaPropStg;
	CHAR  szPropName[ MAX_PATH ];
	BSTR bstrFullItemName = NULL;
    hResult = pIWiaItem->QueryInterface(IID_IWiaPropertyStorage,(void **)&pIWiaPropStg);
    if (hResult == S_OK)
    {
        hResult = ReadPropStr(WIA_IPA_FULL_ITEM_NAME, pIWiaPropStg, &bstrFullItemName);
        if (hResult != S_OK)
        {
            //WIA_ERROR(("ReadPropStr(WIA_IPA_FULL_ITEM_NAME) Failed", hResult));
            bstrFullItemName = ::SysAllocString(L"Uninitialized");
        }
		ItemName = "";
		// write property name
		WideCharToMultiByte(CP_ACP, 0,bstrFullItemName,-1,szPropName,MAX_PATH,NULL,NULL);
		ItemName.Format("%s",szPropName);
	}
	if(m_bAppItem)
		SetWindowText("Application Item Information for ["+ItemName+"]");
	else
		SetWindowText("Driver Item Information for ["+ItemName+"]");
}
/**************************************************************************\
* CItemInfoDlg::OnResetbackButton()
*   
*   Reset the status of the dialog's display, and data to the 
*	startup state.
*	
*   
* Arguments:
*   
*   none
*
* Return Value:
*
*    none
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
void CItemInfoDlg::OnResetbackButton() 
{
	m_ItemAddress.Format("%p",m_pIWiaItem);
	UpdateData(FALSE);
	BSTR bstrItemDump;
	HRESULT hResult = S_OK;
	if(m_bAppItem)
	{
		// check if item pointer is valid item before call?
		hResult = m_pIWiaItem->DumpItemData(&bstrItemDump);
	}
	else
	{
		// check if item pointer is valid item before call?
		hResult = m_pIWiaItem->DumpDrvItemData(&bstrItemDump);
	}
	if(hResult == S_OK)
	{
		// write data to CString
		m_strItemInfoEditBox = bstrItemDump;
		// free BSTR
		SysFreeString(bstrItemDump);
	}
	else
	{
		//WIA_ERROR(("*CItemInfoDlg()* pIWiaItem->DumpItemData() failed hResult = 0x%lx\n",hResult));
		m_strItemInfoEditBox = "<No Dump Item Data.. Check the Debugger..>";
	}
	
	UpdateData(FALSE);
	SetWindowTextToItemName(m_pIWiaItem);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiatest\progressbar.cpp ===
// ProgressBar.cpp : implementation file
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "ProgressBar.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNCREATE(CProgressBar, CProgressCtrl)

BEGIN_MESSAGE_MAP(CProgressBar, CProgressCtrl)
    //{{AFX_MSG_MAP(CProgressBar)
    ON_WM_ERASEBKGND()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/**************************************************************************\
* CProgressBar::CProgressBar()
*
*   Constructor for the progress control
*
*
* Arguments:
*
*   none
*
* Return Value:
*
*    none
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
CProgressBar::CProgressBar()
{
    m_Rect.SetRect(0,0,0,0);
}
/**************************************************************************\
* CProgressBar::
*
*   Constructor for the Progress control
*
*
* Arguments:
*
*   strMessage - Status message to display
*   nSize - Max range of Progress control
*   MaxValue - Max range of Progress control
*   bSmooth - Smooth/Normal mode of progress display
*   nPane - which pane to display the progress control
*
* Return Value:
*
*    none
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
CProgressBar::CProgressBar(LPCTSTR strMessage, int nSize /*=100*/,
                           int MaxValue /*=100*/, BOOL bSmooth /*=FALSE*/,
                           int nPane/*=0*/)
{
    Create(strMessage, nSize, MaxValue, bSmooth, nPane);
}
/**************************************************************************\
* CProgressBar::~CProgressBar()
*
*   Destruction
*
*
* Arguments:
*
*   none
*
* Return Value:
*
*    none
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
CProgressBar::~CProgressBar()
{
    Clear();
}
/**************************************************************************\
* CProgressBar::GetStatusBar()
*
*   Returns the Status bar
*
*
* Arguments:
*
*   none
*
* Return Value:
*
*    CStatusBar* - Status bar to be returned
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
CStatusBar* CProgressBar::GetStatusBar()
{
    CWnd *pMainWnd = AfxGetMainWnd();
    if (!pMainWnd)
        return NULL;

    // If main window is a frame window, use normal methods...
    if (pMainWnd->IsKindOf(RUNTIME_CLASS(CFrameWnd)))
    {
        CWnd* pMessageBar = ((CFrameWnd*)pMainWnd)->GetMessageBar();
        return DYNAMIC_DOWNCAST(CStatusBar, pMessageBar);
    }
    // otherwise traverse children to try and find the status bar...
    else
        return DYNAMIC_DOWNCAST(CStatusBar,
                                pMainWnd->GetDescendantWindow(AFX_IDW_STATUS_BAR));
}

/**************************************************************************\
* CProgressBar::Create()
*
*   Creates a new progress control
*   Create the CProgressCtrl as a child of the status bar positioned
*   over the first pane, extending "nSize" percentage across pane.
*   Sets the range to be 0 to MaxValue, with a step of 1.
*
*
* Arguments:
*
*   strMessage - Status message to display
*   nSize - Max range of Progress control
*   MaxValue - Max range of Progress control
*   bSmooth - Smooth/Normal mode of progress display
*   nPane - which pane to display the progress control
*
* Return Value:
*
*    none
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
BOOL CProgressBar::Create(LPCTSTR strMessage, int nSize /*=100*/,
                          int MaxValue /*=100*/, BOOL bSmooth /*=FALSE*/, int nPane/*=0*/)
{
    BOOL bSuccess = FALSE;

    CStatusBar *pStatusBar = GetStatusBar();
    if (!pStatusBar)
        return FALSE;

    DWORD dwStyle = WS_CHILD|WS_VISIBLE;
#ifdef PBS_SMOOTH
    if (bSmooth)
        dwStyle |= PBS_SMOOTH;
#endif

    // Get CRect coordinates for requested status bar pane
    CRect PaneRect;
    pStatusBar->GetItemRect(nPane, &PaneRect);

    // Create the progress bar
    bSuccess = CProgressCtrl::Create(dwStyle, PaneRect, pStatusBar, 1);
    ASSERT(bSuccess);
    if (!bSuccess)
        return FALSE;

    // Set range and step
    SetRange(0, MaxValue);
    SetStep(1);

    m_strMessage  = strMessage;
    m_nSize       = nSize;
    m_nPane       = nPane;
    m_strPrevText = pStatusBar->GetPaneText(m_nPane);

    // Resize the control to its desired width
    Resize();

    return TRUE;
}
/**************************************************************************\
* CProgressBar::Clear()
*
*   Destroy the progress control
*
*
* Arguments:
*
*   none
*
* Return Value:
*
*    none
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
void CProgressBar::Clear()
{
    if (!IsWindow(GetSafeHwnd()))
        return;

    // Hide the window. This is necessary so that a cleared
    // window is not redrawn if "Resize" is called
    ModifyStyle(WS_VISIBLE, 0);

    CString str;
    if (m_nPane == 0)
        str.LoadString(AFX_IDS_IDLEMESSAGE);   // Get the IDLE_MESSAGE
      else
        str = m_strPrevText;                   // Restore previous text

    // Place the IDLE_MESSAGE in the status bar
    CStatusBar *pStatusBar = GetStatusBar();
    if (pStatusBar)
    {
        pStatusBar->SetPaneText(m_nPane, str);
        pStatusBar->UpdateWindow();
    }
}
/**************************************************************************\
* CProgressBar::SetText()
*
*   Set the display text for the progress control
*
*
* Arguments:
*
*   none
*
* Return Value:
*
*    none
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
BOOL CProgressBar::SetText(LPCTSTR strMessage)
{
    m_strMessage = strMessage;
    SetPaneText(m_nPane,m_strMessage);
    return Resize();
}
/**************************************************************************\
* CProgressBar::SetSize()
*
*   Set the size for the progress control
*
*
* Arguments:
*
*   nSize - New size for the progress control
*
* Return Value:
*
*    none
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
BOOL CProgressBar::SetSize(int nSize)
{
    m_nSize = nSize;
    return Resize();
}
/**************************************************************************\
* CProgressBar::SetBarColour()
*
*   Sets the color for the progress control
*
*
* Arguments:
*
*   clrBar - Color for progress control
*
* Return Value:
*
*    COLORREF last color of progress control
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
COLORREF CProgressBar::SetBarColour(COLORREF clrBar)
{
#ifdef PBM_SETBKCOLOR
    if (!IsWindow(GetSafeHwnd()))
          return CLR_DEFAULT;

    return (COLORREF )SendMessage(PBM_SETBARCOLOR, 0, (LPARAM) clrBar);
#else
    UNUSED(clrBar);
    return CLR_DEFAULT;
#endif
}
/**************************************************************************\
* CProgressBar::SetBkColour()
*
*   Sets the background color for the progress control
*
*
* Arguments:
*
*   none
*
* Return Value:
*
*    COLORREF last color of progress control background
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
COLORREF CProgressBar::SetBkColour(COLORREF clrBk)
{
#ifdef PBM_SETBKCOLOR
    if (!IsWindow(GetSafeHwnd()))
        return CLR_DEFAULT;

    return (COLORREF) SendMessage(PBM_SETBKCOLOR, 0, (LPARAM) clrBk);
#else
    UNUSED(clrBk);
    return CLR_DEFAULT;
#endif
}
/**************************************************************************\
* CProgressBar::SetRange()
*
*   Set the range limits for the progress control
*
*
* Arguments:
*
*   nLower - Lower limit
*   nUpper - Upper limit
*   nStep - Step value
*
* Return Value:
*
*    status
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
BOOL CProgressBar::SetRange(int nLower, int nUpper, int nStep /* = 1 */)
{
    if (!IsWindow(GetSafeHwnd()))
        return FALSE;

    // To take advantage of the Extended Range Values we use the PBM_SETRANGE32
    // message intead of calling CProgressCtrl::SetRange directly. If this is
    // being compiled under something less than VC 5.0, the necessary defines
    // may not be available.

#ifdef PBM_SETRANGE32
    ASSERT(-0x7FFFFFFF <= nLower && nLower <= 0x7FFFFFFF);
    ASSERT(-0x7FFFFFFF <= nUpper && nUpper <= 0x7FFFFFFF);
    SendMessage(PBM_SETRANGE32, (WPARAM) nLower, (LPARAM) nUpper);
#else
    ASSERT(0 <= nLower && nLower <= 65535);
    ASSERT(0 <= nUpper && nUpper <= 65535);
    CProgressCtrl::SetRange(nLower, nUpper);
#endif

    CProgressCtrl::SetStep(nStep);
    return TRUE;
}
/**************************************************************************\
* CProgressBar::SetPos()
*
*   Sets the current position for the progress control
*
*
* Arguments:
*
*   nPos - new Postion to be set
*
* Return Value:
*
*    status
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
int CProgressBar::SetPos(int nPos)
{
    if (!IsWindow(GetSafeHwnd()))
        return 0;

#ifdef PBM_SETRANGE32
    ASSERT(-0x7FFFFFFF <= nPos && nPos <= 0x7FFFFFFF);
#else
    ASSERT(0 <= nPos && nPos <= 65535);
#endif

    ModifyStyle(0,WS_VISIBLE);
    return CProgressCtrl::SetPos(nPos);
}
/**************************************************************************\
* CProgressBar::OffestPos()
*
*   Set the progress control's offset
*
*
* Arguments:
*
*   nPos - Position offset
*
* Return Value:
*
*    status
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
int CProgressBar::OffsetPos(int nPos)
{
    if (!IsWindow(GetSafeHwnd()))
        return 0;

    ModifyStyle(0,WS_VISIBLE);
    return CProgressCtrl::OffsetPos(nPos);
}
/**************************************************************************\
* CProgressBar::SetStep()
*
*   Set progress control's step value
*
*
* Arguments:
*
*   nStep - Step value to be set
*
* Return Value:
*
*    none
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
int CProgressBar::SetStep(int nStep)
{
    if (!IsWindow(GetSafeHwnd()))
        return 0;

    ModifyStyle(0,WS_VISIBLE);
    return CProgressCtrl::SetStep(nStep);
}
/**************************************************************************\
* CProgressBar::StepIt()
*
*   Step the progress control standard step value
*
*
* Arguments:
*
*   none
*
* Return Value:
*
*    none
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
int CProgressBar::StepIt()
{
    if (!IsWindow(GetSafeHwnd()))
        return 0;

    ModifyStyle(0,WS_VISIBLE);
    return CProgressCtrl::StepIt();
}
/**************************************************************************\
* CProgressBar::Resize()
*
*   Resize the progress control to fit
*
*
* Arguments:
*
*   none
*
* Return Value:
*
*    status
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
BOOL CProgressBar::Resize()
{
    if (!IsWindow(GetSafeHwnd()))
        return FALSE;

    CStatusBar *pStatusBar = GetStatusBar();
    if (!pStatusBar)
        return FALSE;

    // Redraw the window text
    if (IsWindowVisible())
    {
        pStatusBar->SetPaneText(m_nPane, m_strMessage);
        pStatusBar->UpdateWindow();
    }

    // Calculate how much space the text takes up
    CClientDC dc(pStatusBar);
    CFont *pOldFont = dc.SelectObject(pStatusBar->GetFont());
    CSize size = dc.GetTextExtent(m_strMessage);        // Length of text
    int margin = dc.GetTextExtent(_T(" ")).cx * 2;      // Text margin
    dc.SelectObject(pOldFont);

    // Now calculate the rectangle in which we will draw the progress bar
    CRect rc;
    pStatusBar->GetItemRect(m_nPane, rc);

    // Position left of progress bar after text and right of progress bar
    // to requested percentage of status bar pane
    if (!m_strMessage.IsEmpty())
        rc.left += (size.cx + 2*margin);
    rc.right -= (rc.right - rc.left) * (100 - m_nSize) / 100;

    if (rc.right < rc.left) rc.right = rc.left;

    // Leave a litle vertical margin (10%) between the top and bottom of the bar
    int Height = rc.bottom - rc.top;
    rc.bottom -= Height/10;
    rc.top    += Height/10;

    // If the window size has changed, resize the window
    if (rc != m_Rect)
    {
        MoveWindow(&rc);
        m_Rect = rc;
    }

    return TRUE;
}
/**************************************************************************\
* CProgressBar::OnEraseBkgnd()
*
*   Resize, progress control
*
*
* Arguments:
*
*   none
*
* Return Value:
*
*    status
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
BOOL CProgressBar::OnEraseBkgnd(CDC* pDC)
{
    Resize();
    return CProgressCtrl::OnEraseBkgnd(pDC);
}
/**************************************************************************\
* CProgressBar::SetPaneText()
*
*   Set the text for the Pane (Status text for progress control)
*
*
* Arguments:
*
*   nPane - pane number
*   strText - Text to add to the status pane
*
* Return Value:
*
*    status
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
BOOL CProgressBar::SetPaneText(int nPane, LPCTSTR strText)
{
    CStatusBar* pStatusBar = GetStatusBar();
    if(pStatusBar != NULL)
    {
        pStatusBar->SetPaneText(nPane,strText);
        pStatusBar->UpdateWindow();
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiatest\mainfrm.h ===
// MainFrm.h : interface of the CMainFrame class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_MAINFRM_H__48214BAA_E863_11D2_ABDA_009027226441__INCLUDED_)
#define AFX_MAINFRM_H__48214BAA_E863_11D2_ABDA_009027226441__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
#include "ProgressBar.h"

//
// Transfer Tool bar
//
class CTransferToolBar : public CToolBar
{
public:
	CComboBox m_ClipboardFormatComboBox;
};


class CMainFrame : public CFrameWnd
{
	
protected: // create from serialization only
	CMainFrame();
	DECLARE_DYNCREATE(CMainFrame)

// Attributes
public:

// Operations
public:
    void DockControlBarLeftOf(CToolBar* Bar, CToolBar* LeftOf);
    BOOL IsToolBarVisible(DWORD ToolBarID);
    BOOL HideToolBarButton(DWORD ToolBarID, DWORD ButtonID, BOOL bEnable = TRUE);
	void DisplayImage(PBYTE pDIB);
	void DestroyProgressCtrl();
	void SetProgressText(LPCTSTR strText);
	void UpdateProgress(int iProgress);
	void InitializeProgressCtrl(LPCTSTR strMessage);
	CProgressBar* m_pProgressBar;
	CWnd* m_pMessageBar;
// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMainFrame)
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	//}}AFX_VIRTUAL

// Implementation
public:
	void ActivateSizing(BOOL bSizeON);
	void ShowToolBar(int ToolBarID,BOOL bShow);
	virtual ~CMainFrame();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:  // control bar embedded members
	CStatusBar  m_wndStatusBar;
	CToolBar    m_wndToolBar;
	CToolBar	m_wndTransferToolBar;
	int m_oldcx;
	int m_oldcy;
	int m_MinWidth;
	int m_MinHeight;
	BOOL m_bSizeON;
// Generated message map functions
protected:
	//{{AFX_MSG(CMainFrame)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnSize(UINT nType, int cx, int cy);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MAINFRM_H__48214BAA_E863_11D2_ABDA_009027226441__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiatest\mainfrm.cpp ===
// MainFrm.cpp : implementation of the CMainFrame class
//

#include "stdafx.h"
#include "WIATest.h"

#include "WIATestView.h"
#include "Progressbar.h"

#include "MainFrm.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMainFrame

IMPLEMENT_DYNCREATE(CMainFrame, CFrameWnd)

BEGIN_MESSAGE_MAP(CMainFrame, CFrameWnd)
	//{{AFX_MSG_MAP(CMainFrame)
	ON_WM_CREATE()
	ON_WM_SIZE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

static UINT indicators[] =
{
	ID_SEPARATOR,           // status line indicator
	ID_INDICATOR_CAPS,
	ID_INDICATOR_NUM,
	ID_INDICATOR_SCRL,
};

/////////////////////////////////////////////////////////////////////////////
// CMainFrame construction/destruction
/**************************************************************************\
* CMainFrame::CMainFrame()
*   
*   Constructor for mainframe window class
*	
*   
* Arguments:
*   
*   none
*
* Return Value:
*
*    none
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
CMainFrame::CMainFrame()
{
	m_pProgressBar = NULL;
	m_bSizeON = FALSE;
}
/**************************************************************************\
* CMainFrame::~MainFrame()
*   
*   Destructor for mainframe window class
*	
*   
* Arguments:
*   
*   none
*
* Return Value:
*
*    none
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
CMainFrame::~CMainFrame()
{
	if(m_pProgressBar != NULL)
		delete m_pProgressBar;
	m_pProgressBar = NULL;
}
/**************************************************************************\
* CMainFrame::OnCreate()
*   
*   Creates the Main Frame window, adding toolbars, and controls
*	
*   
* Arguments:
*   
*   lpCreateStruct - Creation struct containing window params
*
* Return Value:
*
*    status
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
    if (CFrameWnd::OnCreate(lpCreateStruct) == -1)
        return -1;

    if (!m_wndToolBar.Create(this)) {
        TRACE0("Failed to create toolbar\n");
        return -1;      // fail to create
    }

    if (!m_wndToolBar.LoadToolBar(IDR_MAINFRAME)) {
        TRACE0("Failed to create toolbar\n");
        return -1;      // fail to create
    }

    if (!m_wndTransferToolBar.Create(this)) {
        TRACE0("Failed to create toolbar\n");
        return -1;      // fail to create
    }

    if (!m_wndTransferToolBar.LoadToolBar(IDR_TRANSFER_TOOLBAR)) {
        TRACE0("Failed to create toolbar\n");
        return -1;      // fail to create
    }

    if (!m_wndStatusBar.Create(this) ||
        !m_wndStatusBar.SetIndicators(indicators,
                                      sizeof(indicators)/sizeof(UINT))) {
        TRACE0("Failed to create status bar\n");
        return -1;      // fail to create
    }

    m_wndToolBar.SetBarStyle(m_wndToolBar.GetBarStyle() | CBRS_TOOLTIPS | CBRS_FLYBY | CBRS_SIZE_DYNAMIC);
    
    
    // enable Toolbar docking
    m_wndToolBar.EnableDocking(CBRS_ALIGN_ANY);

    m_wndTransferToolBar.SetBarStyle(m_wndTransferToolBar.GetBarStyle() | CBRS_TOOLTIPS | CBRS_FLYBY | CBRS_SIZE_DYNAMIC);
    
    
    // enable Toolbar docking
    m_wndTransferToolBar.EnableDocking(CBRS_ALIGN_ANY);

    // window Docking
    EnableDocking(CBRS_ALIGN_ANY);
    
    
    m_wndTransferToolBar.SetWindowText("TRANSFER");
    DockControlBar(&m_wndTransferToolBar,AFX_IDW_DOCKBAR_TOP);
    m_wndToolBar.SetWindowText("WIATEST TOOLS");
    
    DockControlBarLeftOf(&m_wndToolBar,&m_wndTransferToolBar);
    ShowToolBar(IDR_MAINFRAME,FALSE);
    return 0;
}

void CMainFrame::DockControlBarLeftOf(CToolBar* Bar, CToolBar* LeftOf)
{
	CRect rect;
	DWORD dw;
	UINT n;
	
	// get MFC to adjust the dimensions of all docked ToolBars
	// so that GetWindowRect will be accurate
	RecalcLayout(TRUE);
	
	LeftOf->GetWindowRect(&rect);
	rect.OffsetRect(1,0);
	dw=LeftOf->GetBarStyle();
	n = 0;
	n = (dw&CBRS_ALIGN_TOP) ? AFX_IDW_DOCKBAR_TOP : n;
	n = (dw&CBRS_ALIGN_BOTTOM && n==0) ? AFX_IDW_DOCKBAR_BOTTOM : n;
	n = (dw&CBRS_ALIGN_LEFT && n==0) ? AFX_IDW_DOCKBAR_LEFT : n;
	n = (dw&CBRS_ALIGN_RIGHT && n==0) ? AFX_IDW_DOCKBAR_RIGHT : n;
	
	// When we take the default parameters on rect, DockControlBar will dock
	// each Toolbar on a seperate line. By calculating a rectangle, we
	// are simulating a Toolbar being dragged to that location and docked.
	DockControlBar(Bar,n,&rect);
}


/**************************************************************************\
* CMainFrame::EnableToolBarButton()
*   
*   Enables/Disables a requested toolbar button
*	
*   
* Arguments:
*   
*   ToolBarID - Tool bar ID to use
*   ButtonID - Button to enable/disable
*   bEnable - TRUE (Enable) FALSE (Disable)
*
* Return Value:
*
*    status
*
* History:
*
*    4/23/1999 Original Version
*
\**************************************************************************/
BOOL CMainFrame::HideToolBarButton(DWORD ToolBarID, DWORD ButtonID, BOOL bEnable)
{
    BOOL bResult = FALSE;
    if(ToolBarID == IDR_MAINFRAME){
        bResult = (m_wndToolBar.GetToolBarCtrl()).HideButton(ButtonID,bEnable);
        (m_wndToolBar.GetToolBarCtrl()).AutoSize();
        ShowControlBar(&m_wndToolBar,TRUE,FALSE);
        return bResult;
    }
    else if(ToolBarID == IDR_TRANSFER_TOOLBAR){
        bResult = (m_wndTransferToolBar.GetToolBarCtrl()).HideButton(ButtonID,bEnable);
        (m_wndTransferToolBar.GetToolBarCtrl()).AutoSize();
        ShowControlBar(&m_wndTransferToolBar,TRUE,FALSE);
        return bResult;
    }
    else
        return FALSE;
}
/**************************************************************************\
* CMainFrame::PreCreateWindow()
*   
*   Handles precreation initialization for the window
*	
*   
* Arguments:
*   
*   cs - Create struct containing window param settings
*
* Return Value:
*
*    none
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
BOOL CMainFrame::PreCreateWindow(CREATESTRUCT& cs)
{
	if( !CFrameWnd::PreCreateWindow(cs) )
		return FALSE;
	return TRUE;
}
/**************************************************************************\
* CMainFrame::InitializationProgressCtrl()
*   
*   Handles progress control initialization
*	
*   
* Arguments:
*   
*   strMessage - Status display for the progress text
*
* Return Value:
*
*    none
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
void CMainFrame::InitializeProgressCtrl(LPCTSTR strMessage)
{
	if(m_pProgressBar == NULL)
		m_pProgressBar = new CProgressBar("Processing..",40,100);

	if(m_pProgressBar != NULL)
	{
		m_pProgressBar->ShowWindow(SW_SHOW);
		m_pProgressBar->SetText(strMessage);
		m_pProgressBar->SetRange(0,100);
		m_pProgressBar->SetPos(0);
		m_pProgressBar->SetStep(100);
        //m_pProgressBar->SetBarColour(RGB(0,200,0));
	}
}
/**************************************************************************\
* CMainFrame::UpdateProgress()
*   
*   updates the progress control status
*	
*   
* Arguments:
*   
*   iProgress - Current Progress to move progress control
*
* Return Value:
*
*    none
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
void CMainFrame::UpdateProgress(int iProgress)
{
	m_pProgressBar->SetPos(iProgress);
}
/**************************************************************************\
* CMainFrame::SetProgressText()
*   
*   Sets the progress control's text status
*	
*   
* Arguments:
*   
*   strText - Text to set in display for status output
*
* Return Value:
*
*    none
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
void CMainFrame::SetProgressText(LPCTSTR strText)
{
	if(m_pProgressBar != NULL)
	{
		m_pProgressBar->SetText(strText);
		//m_wndStatusBar.Invalidate();
	}
}
/**************************************************************************\
* CMainFrame::DestroyProgressCtrl()
*   
*   Hides the progress control in a simulated destruction
*	
*   
* Arguments:
*   
*   none
*
* Return Value:
*
*    none
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
void CMainFrame::DestroyProgressCtrl()
{
	m_pProgressBar->ShowWindow(SW_HIDE);
}
/**************************************************************************\
* CMainFrame::DisplayImage()
*   
*   not used at this time
*	
*   
* Arguments:
*   
*   pDIB - DIB to paint
*
* Return Value:
*
*    none
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
void CMainFrame::DisplayImage(PBYTE pDIB)
{
	CWIATestView* pView = (CWIATestView*)GetActiveView();
	//pView->PaintThis(pDIB);
}
/////////////////////////////////////////////////////////////////////////////
// CMainFrame diagnostics

#ifdef _DEBUG
void CMainFrame::AssertValid() const
{
	CFrameWnd::AssertValid();
}

void CMainFrame::Dump(CDumpContext& dc) const
{
	CFrameWnd::Dump(dc);
}

#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CMainFrame message handlers

/**************************************************************************\
* CMainFrame::ShowToolBar()
*   
*   Show's a hidden toolbar..possible closed by the user
*	
*   
* Arguments:
*   
*   ToolBarID - Toolbar Resource ID
*
* Return Value:
*
*    none
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
void CMainFrame::ShowToolBar(int ToolBarID,BOOL bShow)
{
	switch(ToolBarID)
	{
	case IDR_TRANSFER_TOOLBAR:
		ShowControlBar(&m_wndTransferToolBar,bShow,FALSE);
		break;
	case IDR_MAINFRAME:
		ShowControlBar(&m_wndToolBar,bShow,FALSE);
		break;
	default:
		break;
	}
}

/**************************************************************************\
* CMainFrame::IsToolBarVisible()
*   
*   Determine's if the requested Toolbar is visible
*	
*   
* Arguments:
*   
*   ToolBarID - Toolbar Resource ID
*
* Return Value:
*
*    status
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
BOOL CMainFrame::IsToolBarVisible(DWORD ToolBarID)
{
    switch(ToolBarID)
	{
	case IDR_TRANSFER_TOOLBAR:
		return m_wndTransferToolBar.IsWindowVisible();
		break;
	case IDR_MAINFRAME:
		return m_wndToolBar.IsWindowVisible();
		break;
	default:
		break;
	}
    return FALSE;
}
/**************************************************************************\
* CMainFrame::OnSize()
*   
*   Handles windows message for Mainframe resizing
*	
*   
* Arguments:
*   
*   cx - change in width of mainframe window
*	cy - change in height of the mainframe window
*
* Return Value:
*
*    none
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
void CMainFrame::OnSize(UINT nType, int cx, int cy) 
{
	CFrameWnd::OnSize(nType, cx, cy);
	if(m_bSizeON)
	{
		CWIATestView* pView = (CWIATestView*)GetActiveView();
		if(cx > m_MinWidth)
		{
			if(pView != NULL)	
				pView->ResizeControls(cx - m_oldcx,cy - m_oldcy);
			m_oldcx = cx;
			m_oldcy = cy;
		}
		if(cy > m_MinHeight)
		{
			if(pView != NULL)	
				pView->ResizeControls(cx - m_oldcx,cy - m_oldcy);
			m_oldcx = cx;
			m_oldcy = cy;
		}
	}
}
/**************************************************************************\
* CMainFrame::ActivateSizing()
*   
*   Starts the sizing funtionality of the mainframe
*	
*   
* Arguments:
*   
*   bSizeON - Sizing activated, ON/OFF
*
* Return Value:
*
*    none
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
void CMainFrame::ActivateSizing(BOOL bSizeON)
{
	m_bSizeON = bSizeON;
	RECT MainFrmRect;
	GetClientRect(&MainFrmRect);
	m_MinWidth = MainFrmRect.right;
	m_MinHeight = MainFrmRect.bottom;
	m_oldcx = m_MinWidth;
	m_oldcy = m_MinHeight;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiatest\progressbar.h ===
// ProgressBar.h : header file
/////////////////////////////////////////////////////////////////////////////

#ifndef _INCLUDE_PROGRESSBAR_H_
#define _INCLUDE_PROGRESSBAR_H_


/////////////////////////////////////////////////////////////////////////////
// CProgressBar -  status bar progress control
//
// Copyright (c) Chris Maunder, 1997
// Please feel free to use and distribute.

class CProgressBar: public CProgressCtrl
// Creates a ProgressBar in the status bar
{
public:
	CProgressBar();
	CProgressBar(LPCTSTR strMessage, int nSize=100, int MaxValue=100, 
                 BOOL bSmooth=FALSE, int nPane=0);
	~CProgressBar();
	BOOL Create(LPCTSTR strMessage, int nSize=100, int MaxValue=100, 
                BOOL bSmooth=FALSE, int nPane=0);

	DECLARE_DYNCREATE(CProgressBar)

// operations
public:
	BOOL SetRange(int nLower, int nUpper, int nStep = 1);
	BOOL SetText(LPCTSTR strMessage);
	BOOL SetSize(int nSize);
	COLORREF SetBarColour(COLORREF clrBar);
	COLORREF SetBkColour(COLORREF clrBk);
	int  SetPos(int nPos);
	int  OffsetPos(int nPos);
	int  SetStep(int nStep);
	int  StepIt();
	void Clear();
	BOOL SetPaneText(int nPane, LPCTSTR strText);

// Overrides
	//{{AFX_VIRTUAL(CProgressBar)
	//}}AFX_VIRTUAL

// implementation
protected:
	int		m_nSize;		// Percentage size of control
	int		m_nPane;		// ID of status bar pane progress bar is to appear in
	CString	m_strMessage;	// Message to display to left of control
    CString m_strPrevText;  // Previous text in status bar
	CRect	m_Rect;			// Dimensions of the whole thing

	CStatusBar *GetStatusBar();
	BOOL Resize();

// Generated message map functions
protected:
	//{{AFX_MSG(CProgressBar)
	afx_msg BOOL OnEraseBkgnd(CDC* pDC);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

#endif
/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiatest\sources.inc ===
!include $(PROJECT_ROOT)\wia\wiaenv.inc

TARGETNAME=wiatest
TARGETPATH=$(OBJ_DIR)
TARGETTYPE=PROGRAM

INCLUDES=;..;..\res;$(INCLUDES)

SOURCES= \
        ..\wiatest.cpp \
        ..\mainfrm.cpp \
        ..\wiatestdoc.cpp \
        ..\wiatestview.cpp \
        ..\wiatest.rc\
        ..\cdib.cpp\
        ..\datacallback.cpp\
        ..\progressbar.cpp\
        ..\waitdlg.cpp\
        ..\wiatestui.cpp\
        ..\propedit.cpp\
        ..\datacallback.cpp\
        ..\eventcallback.cpp\
        ..\devicecmddlg.cpp\
        ..\iteminfodlg.cpp\
        ..\wiapreview.cpp\
        ..\cwia.cpp

# Add interlac.cpp if the PNG support is ever fixed

USE_NATIVE_EH=1

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\stdafx.h
PRECOMPILED_PCH=stdafx.pch
PRECOMPILED_OBJ=stdafx.obj

TARGETLIBS= \
        $(TARGETLIBS)                   \
        $(SDK_LIB_PATH)\winmm.lib       \
        $(SDK_LIB_PATH)\sti.lib         \
        $(SDK_LIB_PATH)\irnotif.lib     \
        $(SDK_LIB_PATH)\\userenv.lib    \
        $(SDK_LIB_PATH)\comdlg32.lib    \
        $(SDK_LIB_PATH)\wiaguid.lib     \
        $(WIA_LIB_PATH)\stirt.lib       \
        $(SDK_LIB_PATH)\atl.lib         \
        $(SDK_LIB_PATH)\mscms.lib
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiatest\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by WIATest.rc
//
#define IDD_ABOUTBOX                    100
#define IDD_WIATEST_FORM                101
#define IDR_MAINFRAME                   128
#define IDR_WIATESTYPE                  129
#define IDD_WAIT_DIALOG                 130
#define IDR_TRANSFER_TOOLBAR            131
#define IDD_STATUS_DIALOG               133
#define IDD_PROPEDIT_DIALOG             134
#define IDD_PROPEDIT_LIST_DIALOG        135
#define IDD_PROPEDIT_RANGE_DIALOG       136
#define IDD_DEVICE_COMMAND_DIALOG       137
#define IDD_ITEMINFO_DIALOG             138
#define IDD_PROPEDIT_FLAGS_DIALOG       139
#define IDC_STATUS_LISTBOX              1000
#define IDC_PAINTMODE_CHECKBOX          1001
#define IDC_WIA_UI_BUTTON               1002
#define IDC_THUMBNAILMODE               1002
#define IDC_DEVICELIST_COMBO            1003
#define IDC_THUMBNAIL                   1004
#define IDC_FILENAME_EDITBOX            1005
#define IDC_CURRENTFLAGSTR              1005
#define IDC_LIST_LISTCTRL               1006
#define IDC_FLAGS_LISTCTRL              1008
#define IDC_DEVICE_ITEM_TREE            1009
#define IDC_TYMED_COMBOBOX              1010
#define IDC_PLAYAUDIO_BUTTON            1011
#define IDC_TOMEMORY                    1012
#define IDC_TOFILE                      1013
#define IDC_LIST_ITEMPROP               1020
#define IDC_PREVIEW                     1026
#define IDC_CLIPBOARDFORMAT_COMBOBOX    1028
#define IDC_WAIT_MESSAGE                1031
#define IDC_EDITPROP                    1032
#define IDC_PROP_NAME                   1033
#define IDC_MIN                         1034
#define IDC_MAX                         1035
#define IDC_NOM                         1036
#define IDC_INC                         1037
#define IDC_LIST_LISTBOX                1038
#define IDC_NUMLISTVALUES               1039
#define IDC_CLIPBOARD_FORMAT_COMBO      1040
#define IDC_COMMAND_LISTBOX             1041
#define IDC_SEND_COMMAND                1042
#define IDC_FUNCTIONCALLTEXT            1043
#define IDC_FLAGS_EDITBOX               1044
#define IDC_ITEMADDRESS_EDITBOX         1045
#define IDC_GUID                        1046
#define IDC_ITEMINFO_EDITBOX            1047
#define IDC_REFRESH_ITEMINFO_BUTTON     1048
#define IDC_RESETBACK_BUTTON            1049
#define ID_GETIMAGEDLG                  32771
#define ID_WIADATA                      32772
#define ID_IDTGETBANDED                 32773
#define ID_VIEW_TRANSFER_TOOLBAR        32774
#define ID_ADDDEVICE                    32775
#define ID_REFRESH                      32776
#define ID_COMBOBOX_PLACEHOLDER         32777
#define ID_EXECUTECOMMAND               32778
#define ID_DUMPDRVITEM_INFO             32779
#define ID_DUMPAPPITEM_INFO             32780
#define ID_RESETSTI                     32781
#define ID_FULLPREVIEW                  32782
#define ID_DELETEITEM                   32783
#define ID_GETROOTITEMTEST              32785
#define ID_REENUMITEMS                  32786
#define ID_SAVEPROPSTREAM               32787
#define ID_LOADPROPSTREAM               32788
#define ID_GET_SET_PROPSTREAM_TEST      32789
#define ID_ANALYZE                      32790
#define ID_CreateChildItem              32791
#define ID_CREATE_CHILD_ITEM            32791

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_3D_CONTROLS                     1
#define _APS_NEXT_RESOURCE_VALUE        140
#define _APS_NEXT_COMMAND_VALUE         32792
#define _APS_NEXT_CONTROL_VALUE         1012
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiatest\propedit.cpp ===
// PropEdit.cpp : implementation file
//

#include "stdafx.h"
#include "WIATest.h"
#include "PropEdit.h"

#include "wtdb.h"                       // WIATEST Database of flags and constants

#ifdef _DEBUG
    #define new DEBUG_NEW
    #undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CPropEdit dialog
/**************************************************************************\
* CPropEdit::CPropEdit()
*
*   Constructor for Property Edit dialog - Default type
*
*
* Arguments:
*
*   pParent - Parent Window
*
* Return Value:
*
*    none
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
CPropEdit::CPropEdit(CWnd* pParent /*=NULL*/)
: CDialog(CPropEdit::IDD, pParent)
{
    //{{AFX_DATA_INIT(CPropEdit)
    m_EditString = _T("");
    m_strPropName = _T("");
    //}}AFX_DATA_INIT
}

/**************************************************************************\
* CPropEdit::DoDataExchange()
*
*   Handles control message maps to the correct member variables
*
*
* Arguments:
*
*   pDX - DataExchange object
*
* Return Value:
*
*    none
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
void CPropEdit::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CPropEdit)
    DDX_Control(pDX, IDOK, m_ButtonOk);
    DDX_Control(pDX, IDCANCEL, m_ButtonCancel);
    DDX_Text(pDX, IDC_EDITPROP, m_EditString);
    DDX_Text(pDX, IDC_PROP_NAME, m_strPropName);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CPropEdit, CDialog)
//{{AFX_MSG_MAP(CPropEdit)
//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPropEdit message handlers
/**************************************************************************\
* CPropEdit::SetPropertyName()
*
*   Sets the property name string
*
*
* Arguments:
*
*   PropName - Property Name
*
* Return Value:
*
*    none
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
void CPropEdit::SetPropertyName(CString PropName)
{
    m_strPropName = PropName;
}
/**************************************************************************\
* CPropEdit::SetPropertyValue()
*
*   Sets the property value string
*
*
* Arguments:
*
*   PropValue - Property Value
*
* Return Value:
*
*    none
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
void CPropEdit::SetPropertyValue(CString PropValue)
{
    m_EditString = PropValue;
}
/**************************************************************************\
* CPropEdit::SetPropertyType()
*
*   Sets the property Type
*
*
* Arguments:
*
*   PropType - Property type
*
* Return Value:
*
*    none
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
void CPropEdit::SetPropertyType(USHORT PropType)
{
    m_VT = PropType;
}

/////////////////////////////////////////////////////////////////////////////
// CPropEditRange dialog
/**************************************************************************\
* CPropEditRange::CPropEditRange()
*
*   Constructor for Property Edit dialog - RANGE type
*
*
* Arguments:
*
*   pParent - Parent Window
*
* Return Value:
*
*    none
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
CPropEditRange::CPropEditRange(CWnd* pParent /*=NULL*/)
: CDialog(CPropEditRange::IDD, pParent)
{
    //{{AFX_DATA_INIT(CPropEditRange)
    m_EditString = _T("");
    m_strPropName = _T("");
    m_Increment = _T("none");
    m_Maximum = _T("none");
    m_Minimum = _T("none");
    m_Nominal = _T("none");
    //}}AFX_DATA_INIT
}
/**************************************************************************\
* CPropEditRange::DoDataExchange()
*
*   Handles control message maps to the correct member variables
*
*
* Arguments:
*
*   pDX - DataExchange object
*
* Return Value:
*
*    none
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
void CPropEditRange::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CPropEditRange)
    DDX_Control(pDX, IDOK, m_ButtonOk);
    DDX_Control(pDX, IDCANCEL, m_ButtonCancel);
    DDX_Text(pDX, IDC_EDITPROP, m_EditString);
    DDX_Text(pDX, IDC_PROP_NAME, m_strPropName);
    DDX_Text(pDX, IDC_INC, m_Increment);
    DDX_Text(pDX, IDC_MAX, m_Maximum);
    DDX_Text(pDX, IDC_MIN, m_Minimum);
    DDX_Text(pDX, IDC_NOM, m_Nominal);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CPropEditRange, CDialog)
//{{AFX_MSG_MAP(CPropEditRange)
ON_WM_CLOSE()
ON_WM_DESTROY()
//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPropEditRange message handlers
/**************************************************************************\
* CPropEdit::SetRangeValues()
*
*   Sets the property Range Values
*
*
* Arguments:
*
*   Min - Minimum value
*       Max - Maximum value
*       Nom - Nominal value
*       Inc - Increment Value
*
* Return Value:
*
*    none
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
BOOL CPropEditRange::SetRangeValues(int Min, int Max, int Nom, int Inc)
{
    m_Minimum.Format("%d",Min);
    m_Maximum.Format("%d",Max);
    m_Nominal.Format("%d",Nom);
    m_Increment.Format("%d",Inc);

    return TRUE;
}

/**************************************************************************\
* CPropEdit::SetRangeValues()
*
*   Sets the property Range Values
*
*
* Arguments:
*
*   Min - Minimum value
*       Max - Maximum value
*       Nom - Nominal value
*       Inc - Increment Value
*
* Return Value:
*
*    none
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
BOOL CPropEditRange::SetRangeValues(float Min, float Max, float Nom, float Inc)
{
    m_Minimum.Format("%3.5f",Min);
    m_Maximum.Format("%3.5f",Max);
    m_Nominal.Format("%3.5f",Nom);
    m_Increment.Format("%3.5f",Inc);

    return TRUE;
}
/**************************************************************************\
* CPropEditRange::SetPropertyName()
*
*   Sets the property name string
*
*
* Arguments:
*
*   PropName - Property Name
*
* Return Value:
*
*    none
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
void CPropEditRange::SetPropertyName(CString PropName)
{
    m_strPropName = PropName;
}
/**************************************************************************\
* CPropEditRange::SetPropertyValue()
*
*   Sets the property value string
*
*
* Arguments:
*
*   PropValue - Property Value
*
* Return Value:
*
*    none
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
void CPropEditRange::SetPropertyValue(CString PropValue)
{
    m_EditString = PropValue;
}
/**************************************************************************\
* CPropEditRange::SetPropertyType()
*
*   Sets the property Type
*
*
* Arguments:
*
*   PropType - Property type
*
* Return Value:
*
*    none
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
void CPropEditRange::SetPropertyType(USHORT PropType)
{
    m_VT = PropType;
}

/////////////////////////////////////////////////////////////////////////////
// CPropEditList dialog

/**************************************************************************\
* CPropEditList::CPropEditList()
*
*   Constructor for Property Edit dialog - LIST type
*
*
* Arguments:
*
*   pParent - Parent Window
*
* Return Value:
*
*    none
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
CPropEditList::CPropEditList(CWnd* pParent /*=NULL*/)
: CDialog(CPropEditList::IDD, pParent)
{
    //{{AFX_DATA_INIT(CPropEditList)
    m_EditString = _T("");
    m_strPropName = _T("");
    m_CurrentElementNum = 0;
    m_nElements = 0;
    m_pArray = NULL;
    //}}AFX_DATA_INIT
}

/**************************************************************************\
* CPropEditList::DoDataExchange()
*
*   Handles control message maps to the correct member variables
*
*
* Arguments:
*
*   pDX - DataExchange object
*
* Return Value:
*
*    none
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
void CPropEditList::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CPropEditList)
    DDX_Control(pDX, IDC_LIST_LISTCTRL, m_ListValueListBox);
    DDX_Control(pDX, IDC_NUMLISTVALUES, m_NumListValueDisplay);
    DDX_Control(pDX, IDOK, m_ButtonOk);
    DDX_Control(pDX, IDCANCEL, m_ButtonCancel);
    DDX_Text(pDX, IDC_EDITPROP, m_EditString);
    DDX_Text(pDX, IDC_PROP_NAME, m_strPropName);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CPropEditList, CDialog)
//{{AFX_MSG_MAP(CPropEditList)
ON_WM_CLOSE()
ON_WM_DESTROY()
ON_NOTIFY(NM_DBLCLK, IDC_LIST_LISTCTRL, OnDblclkListListctrl)
ON_NOTIFY(NM_CLICK, IDC_LIST_LISTCTRL, OnClickListListctrl)
//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPropEditList message handlers
/**************************************************************************\
* CPropEditList::SetListValue()
*
*   Sets the current list value in UINT array
*
*
* Arguments:
*
*   ListValue - List value to enter into UINT array
*
* Return Value:
*
*    none
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
BOOL CPropEditList::SetListValue(int ListValue)
{
    //m_pUINTArray[m_CurrentElementNum] = ListValue;
    //m_CurrentElementNum++;
    return TRUE;
}
/**************************************************************************\
* CPropEditList::SetArray()
*
*   Sets the array bounds for the list data
*
*
* Arguments:
*
*    pArray - pointer to Array
*    nElements - Number of elements in the array
*
* Return Value:
*
*    none
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
BOOL CPropEditList::SetArray(BYTE  *pArray, int nElements)
{
    m_nElements = nElements;
    m_pArray = pArray;
    return TRUE;
}
/**************************************************************************\
* CPropEditList::DisplayListValues()
*
*   Displays list values to dialog listbox
*
*
* Arguments:
*
*   none
*
* Return Value:
*
*    status
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
BOOL CPropEditList::DisplayListValues()
{
    CString Value = "";
    Value.Format("Total List Values = %d",m_nElements);
    m_NumListValueDisplay.SetWindowText(Value);

    int NumEntries = WiatestDatabase[0].nItems;
    BOOL bFoundName = FALSE;

    //
    // Search for known property in data base
    //

    for (int CurrentEntry = 1;CurrentEntry <= NumEntries;CurrentEntry++) {
        if (m_strPropName == (CString)(WiatestDatabase[CurrentEntry].pName)) {
            bFoundName = TRUE;
            int Index = 0;
            CString outStr = "";
            m_CurrentEntry = CurrentEntry;
        }
    }
    if (!bFoundName) {

        //
        // Name was not found..so display the actual values in the list
        //

        // AfxMessageBox(m_strPropName + " was not found in wtdb.h data base file...");
        for (UINT nElem = 0;nElem < (UINT)m_nElements; nElem++) {
            Value = "";

            switch (m_VT) {
            case VT_I1:
            case VT_I2:
            case VT_I4:
            case VT_I8:
            case VT_UI1:
            case VT_UI2:
            case VT_UI4:
            case VT_UI8:
            case VT_INT:
                Value.Format("%d",((INT*)m_pArray)[WIA_LIST_VALUES + nElem]);
                break;
            case VT_R4:
            case VT_R8:
                Value.Format("%3.3f",((float*)m_pArray)[WIA_LIST_VALUES + nElem]);
                break;
            case VT_BSTR:
                Value.Format("%ws",((BSTR*)m_pArray)[WIA_LIST_VALUES + nElem]);
                break;
            case VT_CLSID:
                {
                    /*UCHAR *pwszUUID = NULL;
                    UuidToStringA(&((GUID*)(m_pArray))[WIA_LIST_VALUES + nElem],&pwszUUID);
                    Value.Format(ConvertGUIDListValueToCString(((GUID*)(m_pArray))[WIA_LIST_VALUES + nElem])+" %s",pwszUUID);
                    RpcStringFree(&pwszUUID);*/
                    //_asm int 3;
                    //Value = ConvertGUIDListValueToCString((GUID*)(m_pArray)[WIA_LIST_VALUES + nElem]);
                    Value = ConvertGUIDListValueToCString(((GUID*)(m_pArray))[WIA_LIST_VALUES + nElem]);
                }
                break;
            case VT_UINT:
            default:
                Value.Format("%d",((UINT*)m_pArray)[WIA_LIST_VALUES + nElem]);
                break;
            }

            LV_ITEM         lvitem;

            lvitem.mask     = LVIF_TEXT | LVIF_PARAM;
            lvitem.iItem    = nElem;
            lvitem.iSubItem = 0;
            lvitem.pszText  = Value.GetBuffer(Value.GetLength());
            lvitem.iImage   = NULL;
            lvitem.lParam   = 0;

            m_ListValueListBox.InsertItem(&lvitem);
        }
    } else {
        Value = "";
        for (UINT nElem = 0;nElem < (UINT)m_nElements; nElem++) {
            Value = "";
            Value.Format("%d",((UINT*)m_pArray)[WIA_LIST_VALUES + nElem]);
            LV_ITEM         lvitem;
            CString InValue = ConvertListValueToCString(((UINT*)m_pArray)[WIA_LIST_VALUES + nElem]);
            lvitem.mask     = LVIF_TEXT | LVIF_PARAM;
            lvitem.iItem    = nElem;
            lvitem.iSubItem = 0;
            lvitem.pszText  = InValue.GetBuffer(InValue.GetLength());
            lvitem.iImage   = NULL;
            lvitem.lParam   = 0;

            m_ListValueListBox.InsertItem(&lvitem);

            lvitem.iSubItem = 1;
            lvitem.mask     = LVIF_TEXT;
            lvitem.pszText  = Value.GetBuffer(Value.GetLength());
            m_ListValueListBox.SetItem(&lvitem);
        }
    }
    m_ListValueListBox.SetColumnWidth(0, LVSCW_AUTOSIZE);
    return TRUE;
}
/**************************************************************************\
* CPropEditList::OnInitDialog()
*
*   Initializes the Command dialog's controls/display
*
*
* Arguments:
*
*   none
*
* Return Value:
*
*    status
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
BOOL CPropEditList::OnInitDialog()
{
    CDialog::OnInitDialog();
    LVCOLUMN lv;
    int i = 0;
    // initialize item property list control column headers

    // Property name
    lv.mask         = LVCF_FMT | LVCF_TEXT | LVCF_WIDTH;
    lv.fmt          = LVCFMT_LEFT ;
    lv.cx           = 100;
    lv.pszText      = "Constant";
    lv.cchTextMax   = 0;
    lv.iSubItem     = 0;
    lv.iImage       = 0;
    lv.iOrder       = 0;
    i = m_ListValueListBox.InsertColumn(0,&lv);

    // Property Value (current)
    lv.cx           = 125;
    lv.iOrder       = 1;
    lv.iSubItem     = 1;
    lv.pszText      = "Value";
    i = m_ListValueListBox.InsertColumn(1,&lv);

    HFONT hFixedFont = (HFONT)GetStockObject(ANSI_FIXED_FONT);
    if (hFixedFont != NULL)
        m_ListValueListBox.SendMessage(WM_SETFONT,(WPARAM)hFixedFont,0);

    if (m_nElements > 0)
        DisplayListValues();
    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}
/**************************************************************************\
* CPropEditList::OnClose()
*
*   Handles closing of the Property LIST edit dialog
*
*
* Arguments:
*
*   none
*
* Return Value:
*
*    void
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
void CPropEditList::OnClose()
{
    CDialog::OnClose();
}
/**************************************************************************\
* CPropEditList::OnDestroy()
*
*   Handles the destruction of the dialog data arrays
*
*
* Arguments:
*
*   none
*
* Return Value:
*
*    void
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
void CPropEditList::OnDestroy()
{
    CDialog::OnDestroy();
}
/**************************************************************************\
* CPropEditList::OnDblclkListListctrl()
*
*   Handles Double click message from List control
*
*
* Arguments:
*
*   pNMHDR - Header info
*       pResult - Operation result
*
* Return Value:
*
*    void
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
void CPropEditList::OnDblclkListListctrl(NMHDR* pNMHDR, LRESULT* pResult)
{
    int SelIndex = m_ListValueListBox.GetNextItem( -1, LVNI_ALL | LVNI_SELECTED);
    if ( SelIndex != -1 ) {

        switch (m_VT) {
        case VT_I1:
        case VT_I2:
        case VT_I4:
        case VT_I8:
        case VT_UI1:
        case VT_UI2:
        case VT_UI4:
        case VT_UI8:
        case VT_INT:
            m_EditString.Format("%d",((INT*)m_pArray)[WIA_LIST_VALUES + SelIndex]);
            break;
        case VT_R4:
        case VT_R8:
            m_EditString.Format("%3.3f",((float*)m_pArray)[WIA_LIST_VALUES + SelIndex]);
            break;
        case VT_BSTR:
            m_EditString.Format("%ws",((BSTR*)m_pArray)[WIA_LIST_VALUES + SelIndex]);
            break;
        case VT_CLSID:
                {
                    UCHAR *pwszUUID = NULL;
                    UuidToStringA(&((GUID*)(m_pArray))[WIA_LIST_VALUES + SelIndex],&pwszUUID);
                    m_EditString.Format("%s",pwszUUID);
                    RpcStringFree(&pwszUUID);
                }
                break;
        case VT_UINT:
        default:
            m_EditString.Format("%d",((UINT*)m_pArray)[WIA_LIST_VALUES + SelIndex]);
            break;
        }

        //m_EditString.Format("%d",m_pUINTArray[SelIndex]);
        UpdateData(FALSE);
    }
    OnOK();
    *pResult = 0;
}
/**************************************************************************\
* CPropEditList::OnClickListListctrl()
*
*   Handles Double click message from List control
*
*
* Arguments:
*
*   pNMHDR - Header info
*       pResult - Operation result
*
* Return Value:
*
*    void
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
void CPropEditList::OnClickListListctrl(NMHDR* pNMHDR, LRESULT* pResult)
{
    int SelIndex = m_ListValueListBox.GetNextItem( -1, LVNI_ALL | LVNI_SELECTED);
    if ( SelIndex != -1 ) {
        switch (m_VT) {
        case VT_I1:
        case VT_I2:
        case VT_I4:
        case VT_I8:
        case VT_UI1:
        case VT_UI2:
        case VT_UI4:
        case VT_UI8:
        case VT_INT:
            m_EditString.Format("%d",((INT*)m_pArray)[WIA_LIST_VALUES + SelIndex]);
            break;
        case VT_R4:
        case VT_R8:
            m_EditString.Format("%3.3f",((float*)m_pArray)[WIA_LIST_VALUES + SelIndex]);
            break;
        case VT_BSTR:
            m_EditString.Format("%ws",((BSTR*)m_pArray)[WIA_LIST_VALUES + SelIndex]);
            break;
        case VT_CLSID:
                {
                    UCHAR *pwszUUID = NULL;
                    UuidToStringA(&((GUID*)(m_pArray))[WIA_LIST_VALUES + SelIndex],&pwszUUID);
                    m_EditString.Format("%s",pwszUUID);
                    RpcStringFree(&pwszUUID);
                }
                break;
        case VT_UINT:
        default:
            m_EditString.Format("%d",((UINT*)m_pArray)[WIA_LIST_VALUES + SelIndex]);
            break;
        }
        //m_EditString.Format("%d",m_pUINTArray[SelIndex]);
        UpdateData(FALSE);
    }
    *pResult = 0;
}

/**************************************************************************\
* CPropEditList::SetPropertyName()
*
*   Sets the property name string
*
*
* Arguments:
*
*   PropName - Property Name
*
* Return Value:
*
*    none
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
void CPropEditList::SetPropertyName(CString PropName)
{
    m_strPropName = PropName;
}
/**************************************************************************\
* CPropEditList::SetPropertyValue()
*
*   Sets the property value string
*
*
* Arguments:
*
*   PropValue - Property Value
*
* Return Value:
*
*    none
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
void CPropEditList::SetPropertyValue(CString PropValue)
{
    m_EditString = PropValue;
}
/**************************************************************************\
* CPropEditList::SetPropertyType()
*
*   Sets the property Type
*
*
* Arguments:
*
*   PropType - Property type
*
* Return Value:
*
*    none
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
void CPropEditList::SetPropertyType(USHORT PropType)
{
    m_VT = PropType;
}
/**************************************************************************\
* CPropEditList::ConvertListValueToCString()
*
*   Converts a list value to a CString for display
*
*
* Arguments:
*
*   Value - List Value to convert
*
* Return Value:
*
*    CString - converted List value in CString format
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
CString CPropEditList::ConvertListValueToCString(UINT Value)
{
    CString sFlag = "";
    for (int i = 0;i<WiatestDatabase[m_CurrentEntry].nItems;i++) {
        if (Value == WiatestDatabase[m_CurrentEntry].pData[i])
            sFlag = (CString)WiatestDatabase[m_CurrentEntry].pDataNames[i];
    }
    return sFlag;
}

/**************************************************************************\
* CPropEditList::ConvertGUIDListValueToCString()
*
*   Converts a list value to a CString for display
*
*
* Arguments:
*
*   Value - List Value to convert
*
* Return Value:
*
*    CString - converted List value in CString format
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
CString CPropEditList::ConvertGUIDListValueToCString(GUID guidValue)
{
    if (guidValue == WiaImgFmt_UNDEFINED)
        return "WiaImgFmt_UNDEFINED";
    else if (guidValue == WiaImgFmt_MEMORYBMP)
        return "WiaImgFmt_MEMORYBMP";
    else if (guidValue == WiaImgFmt_BMP)
        return "WiaImgFmt_BMP";
    else if (guidValue == WiaImgFmt_EMF)
        return "WiaImgFmt_EMF";
    else if (guidValue == WiaImgFmt_WMF)
        return "WiaImgFmt_WMF";
    else if (guidValue == WiaImgFmt_JPEG)
        return "WiaImgFmt_JPEG";
    else if (guidValue == WiaImgFmt_PNG)
        return "WiaImgFmt_PNG";
    else if (guidValue == WiaImgFmt_GIF)
        return "WiaImgFmt_GIF";
    else if (guidValue == WiaImgFmt_TIFF)
        return "WiaImgFmt_TIFF";
    else if (guidValue == WiaImgFmt_EXIF)
        return "WiaImgFmt_EXIF";
    else if (guidValue == WiaImgFmt_PHOTOCD)
        return "WiaImgFmt_PHOTOCD";
    else if (guidValue == WiaImgFmt_FLASHPIX)
        return "WiaImgFmt_FLASHPIX";
    else
        return "** UNKNOWN **";
}


/////////////////////////////////////////////////////////////////////////////
// CPropEditFlags dialog

/**************************************************************************\
* CPropEditFlags::CPropEditFlags()
*
*   Constructor for Property Edit dialog - FLAGS type
*
*
* Arguments:
*
*   pParent - Parent Window
*
* Return Value:
*
*    none
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
CPropEditFlags::CPropEditFlags(CWnd* pParent /*=NULL*/)
: CDialog(CPropEditFlags::IDD, pParent)
{
    //{{AFX_DATA_INIT(CPropEditFlags)
    m_EditString = _T("");
    m_strPropName = _T("");
    //}}AFX_DATA_INIT
}
/**************************************************************************\
* CPropEditFlags::DoDataExchange()
*
*   Handles control message maps to the correct member variables
*
*
* Arguments:
*
*   pDX - DataExchange object
*
* Return Value:
*
*    none
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
void CPropEditFlags::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CPropEditFlags)
    DDX_Control(pDX, IDC_FLAGS_LISTCTRL, m_FlagValueListBox);
    DDX_Control(pDX, IDC_CURRENTFLAGSTR, m_CurrentFlagValue);
    DDX_Control(pDX, IDOK, m_ButtonOk);
    DDX_Control(pDX, IDCANCEL, m_ButtonCancel);
    DDX_Text(pDX, IDC_EDITPROP, m_EditString);
    DDX_Text(pDX, IDC_PROP_NAME, m_strPropName);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CPropEditFlags, CDialog)
//{{AFX_MSG_MAP(CPropEditFlags)
ON_WM_CLOSE()
ON_WM_DESTROY()
ON_NOTIFY(NM_CLICK, IDC_FLAGS_LISTCTRL, OnClickFlagsListctrl)
//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPropEditFlags message handlers
/**************************************************************************\
* CPropEditFlags::OnInitDialog()
*
*   Initializes the Command dialog's controls/display
*
*
* Arguments:
*
*   none
*
* Return Value:
*
*    status
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
BOOL CPropEditFlags::OnInitDialog()
{
    CDialog::OnInitDialog();
    LVCOLUMN lv;
    int i = 0;
    // initialize item property list control column headers

    // Property name
    lv.mask         = LVCF_FMT | LVCF_TEXT | LVCF_WIDTH;
    lv.fmt          = LVCFMT_LEFT ;
    lv.cx           = 100;
    lv.pszText      = "Constant";
    lv.cchTextMax   = 0;
    lv.iSubItem     = 0;
    lv.iImage       = 0;
    lv.iOrder       = 0;
    i = m_FlagValueListBox.InsertColumn(0,&lv);

    // Property Value (current)
    lv.cx           = 125;
    lv.iOrder       = 1;
    lv.iSubItem     = 1;
    lv.pszText      = "Value";
    i = m_FlagValueListBox.InsertColumn(1,&lv);

    HFONT hFixedFont = (HFONT)GetStockObject(ANSI_FIXED_FONT);
    if (hFixedFont != NULL)
        m_FlagValueListBox.SendMessage(WM_SETFONT,(WPARAM)hFixedFont,0);

    InitPossibleFlagValues();
    m_CurrentFlagValue.SetWindowText(ConvertFlagToCString(m_CurrentValue));
    m_EditString.Format("0x%08X",m_CurrentValue);
    UpdateData(FALSE);
    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}
/**************************************************************************\
* CPropEditFlags::OnClose()
*
*   Handles closing of the Property FLAGS edit dialog
*
*
* Arguments:
*
*   none
*
* Return Value:
*
*    void
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
void CPropEditFlags::OnClose()
{
    CDialog::OnClose();
}
/**************************************************************************\
* CPropEditFlags::OnDestroy()
*
*   Handles the destruction of the dialog data arrays
*
*
* Arguments:
*
*   none
*
* Return Value:
*
*    void
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
void CPropEditFlags::OnDestroy()
{
    CDialog::OnDestroy();
}
/**************************************************************************\
* CPropEditFlags::SetPropertyName()
*
*   Sets the property name string
*
*
* Arguments:
*
*   PropName - Property Name
*
* Return Value:
*
*    none
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
void CPropEditFlags::SetPropertyName(CString PropName)
{
    m_strPropName = PropName;
}
/**************************************************************************\
* CPropEditFlags::SetPropertyValue()
*
*   Sets the property value string
*
*
* Arguments:
*
*   PropValue - Property Value
*
* Return Value:
*
*    none
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
void CPropEditFlags::SetPropertyValue(CString PropValue)
{
    m_EditString = PropValue;
    sscanf(m_EditString.GetBuffer(20),"%li",&m_CurrentValue);
}
/**************************************************************************\
* CPropEditFlags::SetPropertyType()
*
*   Sets the property Type
*
*
* Arguments:
*
*   PropType - Property type
*
* Return Value:
*
*    none
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
void CPropEditFlags::SetPropertyType(USHORT PropType)
{
    m_VT = PropType;
}
/**************************************************************************\
* CPropEditFlags::SetPropID()
*
*   Sets the property ID
*
*
* Arguments:
*
*   iProp - Property ID
*
* Return Value:
*
*    none
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
void CPropEditFlags::SetPropID(USHORT iProp)
{
    m_PropID = iProp;
}
/**************************************************************************\
* CPropEditFlags::InitPossibleFlagsValues()
*
*   Displays the Possible flag values to be used for setting
*
*
* Arguments:
*
*   none
*
* Return Value:
*
*    none
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
void CPropEditFlags::InitPossibleFlagValues()
{
    int NumEntries = WiatestDatabase[0].nItems;
    BOOL bFoundName = FALSE;
    for (int CurrentEntry = 1;CurrentEntry <= NumEntries;CurrentEntry++) {
        if (m_strPropName == (CString)(WiatestDatabase[CurrentEntry].pName)) {
            bFoundName = TRUE;
            int Index = 0;
            CString InValue = "";
            CString Value = "";
            m_CurrentEntry = CurrentEntry;
            while (Index <= WiatestDatabase[CurrentEntry].nItems-1) {
                InValue = ConvertFlagToCString(WiatestDatabase[CurrentEntry].pData[Index]);
                Value = "";
                Value.Format("0x%08X",WiatestDatabase[CurrentEntry].pData[Index]);
                LV_ITEM         lvitem;

                lvitem.mask     = LVIF_TEXT | LVIF_PARAM;
                lvitem.iItem    = Index;
                lvitem.iSubItem = 0;
                lvitem.pszText  = InValue.GetBuffer(InValue.GetLength());
                lvitem.iImage   = NULL;
                lvitem.lParam   = 0;

                m_FlagValueListBox.InsertItem(&lvitem);

                lvitem.iSubItem = 1;
                lvitem.mask     = LVIF_TEXT;
                lvitem.pszText  = Value.GetBuffer(Value.GetLength());
                m_FlagValueListBox.SetItem(&lvitem);

                Index++;
            }
        }
    }
    if (!bFoundName)
        AfxMessageBox(m_strPropName + " was not found in wtdb.h data base file...");
    m_FlagValueListBox.SetColumnWidth(0, LVSCW_AUTOSIZE);
}
/**************************************************************************\
* CPropEditFlags::ConvertFlagToCString()
*
*   Converts a Flag value to a CString for display
*
*
* Arguments:
*
*   flag - Flag Value to convert
*
* Return Value:
*
*    CString - converted Flag value in CString format
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
CString CPropEditFlags::ConvertFlagToCString(DWORD flag)
{
    CString sFlag = "";
    for (int i = 0;i<WiatestDatabase[m_CurrentEntry].nItems;i++) {
        if (flag & WiatestDatabase[m_CurrentEntry].pData[i])
            sFlag += (CString)WiatestDatabase[m_CurrentEntry].pDataNames[i] + " | ";
    }
    //
    // check for unknown flags
    //
    if (sFlag.GetLength() == 0) {
        //
        // last check...since 0 can be counted as FALSE causing the
        // if() to fail, this is a check for the first entry (just in case
        // the flag's value is 0)
        //
        if (flag == WiatestDatabase[m_CurrentEntry].pData[0])
            sFlag = (CString)WiatestDatabase[m_CurrentEntry].pDataNames[0] + " | ";
        else
            sFlag.Format("UNKNOWN Flag = %d    ",flag);
    }

    sFlag = sFlag.Left(sFlag.GetLength()-3);
    return sFlag;
}
/**************************************************************************\
* CPropEditFlags::OnClickFlagsListctrl()
*
*   Handles click message to list control, selecting a flag to be used
*
*
* Arguments:
*
*   pNMHDR - Header information
*       pResult - Result value
*
* Return Value:
*
*    none
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
void CPropEditFlags::OnClickFlagsListctrl(NMHDR* pNMHDR, LRESULT* pResult)
{
    m_CurrentValue = 0;
    int i = m_FlagValueListBox.GetNextItem( -1, LVNI_ALL | LVNI_SELECTED);
    while ( i != -1 ) {
        m_CurrentValue = m_CurrentValue | WiatestDatabase[m_CurrentEntry].pData[i];
        i = m_FlagValueListBox.GetNextItem( i, LVNI_ALL | LVNI_SELECTED);
    }
    m_CurrentFlagValue.SetWindowText(ConvertFlagToCString(m_CurrentValue));
    m_EditString.Format("0x%08X",m_CurrentValue);
    UpdateData(FALSE);
    *pResult = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiatest\statusdlg.cpp ===
// StatusDlg.cpp : implementation file
//

#include "stdafx.h"
#include "WIATest.h"
#include "StatusDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CStatusDlg dialog


CStatusDlg::CStatusDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CStatusDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CStatusDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


void CStatusDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CStatusDlg)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CStatusDlg, CDialog)
	//{{AFX_MSG_MAP(CStatusDlg)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CStatusDlg message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiatest\statusdlg.h ===
#if !defined(AFX_STATUSDLG_H__AE0F2190_E877_11D2_ABDB_009027226441__INCLUDED_)
#define AFX_STATUSDLG_H__AE0F2190_E877_11D2_ABDB_009027226441__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// StatusDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CStatusDlg dialog

class CStatusDlg : public CDialog
{
// Construction
public:
	CStatusDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CStatusDlg)
	enum { IDD = IDD_STATUS_DIALOG };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CStatusDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CStatusDlg)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STATUSDLG_H__AE0F2190_E877_11D2_ABDB_009027226441__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiatest\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	WIATest.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiatest\propedit.h ===
#if !defined(AFX_PROPEDIT_H__28023930_BFAE_11D2_A4F8_00105A192534__INCLUDED_)
#define AFX_PROPEDIT_H__28023930_BFAE_11D2_A4F8_00105A192534__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// PropEdit.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CPropEdit dialog

class CPropEdit : public CDialog
{
// Construction
public:
    void SetPropertyName(CString PropName);
    void SetPropertyValue(CString PropValue);
    void SetPropertyType (USHORT PropType);

    USHORT m_VT;
    CPropEdit(CWnd* pParent = NULL);   // standard constructor
// Dialog Data
    //{{AFX_DATA(CPropEdit)
    enum { IDD = IDD_PROPEDIT_DIALOG };
    CButton m_ButtonOk;
    CButton m_ButtonCancel;
    CString m_EditString;
    CString m_strPropName;
    //}}AFX_DATA


// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CPropEdit)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(CPropEdit)
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// CPropEditList dialog

class CPropEditList : public CDialog
{
// Construction
public:
    CString ConvertListValueToCString(UINT Value);
    CString ConvertGUIDListValueToCString(GUID guidValue);
    void SetPropertyName(CString PropName);
    void SetPropertyValue(CString PropValue);
    void SetPropertyType (USHORT PropType);

    CPropEditList(CWnd* pParent = NULL);   // standard constructor
    BOOL SetListValue(int ListValue);
    BOOL SetArray(BYTE* pArray,int nElements);
    BOOL DisplayListValues();
    BYTE* m_pArray;

    int m_nElements;
    int m_CurrentElementNum;
    int m_CurrentEntry;
    USHORT m_VT;
// Dialog Data
    //{{AFX_DATA(CPropEditList)
    enum { IDD = IDD_PROPEDIT_LIST_DIALOG };
    CListCtrl   m_ListValueListBox;
    CButton m_NumListValueDisplay;
    CButton m_ButtonOk;
    CButton m_ButtonCancel;
    CString m_EditString;
    CString m_strPropName;
    //}}AFX_DATA


// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CPropEditList)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(CPropEditList)
    virtual BOOL OnInitDialog();
    afx_msg void OnClose();
    afx_msg void OnDestroy();
    afx_msg void OnDblclkListListctrl(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnClickListListctrl(NMHDR* pNMHDR, LRESULT* pResult);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// CPropEditFlags dialog

class CPropEditFlags : public CDialog
{
// Construction
public:
    CString ConvertFlagToCString(DWORD flag);
    void InitPossibleFlagValues();
    void SetPropID(USHORT iProp);
    void SetPropertyName(CString PropName);
    void SetPropertyValue(CString PropValue);
    void SetPropertyType (USHORT PropType);

    CPropEditFlags(CWnd* pParent = NULL);   // standard constructor
    USHORT m_VT;
    USHORT m_PropID;
    DWORD  m_CurrentValue;
    int m_CurrentEntry;
// Dialog Data
    //{{AFX_DATA(CPropEditFlags)
    enum { IDD = IDD_PROPEDIT_FLAGS_DIALOG };
    CListCtrl   m_FlagValueListBox;
    CButton m_CurrentFlagValue;
    CButton m_ButtonOk;
    CButton m_ButtonCancel;
    CString m_EditString;
    CString m_strPropName;
    //}}AFX_DATA


// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CPropEditFlags)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(CPropEditFlags)
    virtual BOOL OnInitDialog();
    afx_msg void OnClose();
    afx_msg void OnDestroy();
    afx_msg void OnClickFlagsListctrl(NMHDR* pNMHDR, LRESULT* pResult);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};
/////////////////////////////////////////////////////////////////////////////
// CPropEditRange dialog

class CPropEditRange : public CDialog
{
// Construction
public:
    void SetPropertyName(CString PropName);
    void SetPropertyValue(CString PropValue);
    void SetPropertyType (USHORT PropType);

    CPropEditRange(CWnd* pParent = NULL);   // standard constructor
    BOOL SetRangeValues(int Min, int Max, int Nom, int Inc);
    BOOL SetRangeValues(float Min, float Max, float Nom, float Inc);
    USHORT m_VT;
// Dialog Data
    //{{AFX_DATA(CPropEditRange)
    enum { IDD = IDD_PROPEDIT_RANGE_DIALOG };
    CButton m_ButtonOk;
    CButton m_ButtonCancel;
    CString m_EditString;
    CString m_strPropName;
    CString m_Increment;
    CString m_Maximum;
    CString m_Minimum;
    CString m_Nominal;
    //}}AFX_DATA

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CPropEditRange)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(CPropEditRange)
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PROPEDIT_H__28023930_BFAE_11D2_A4F8_00105A192534__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiatest\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__48214BA8_E863_11D2_ABDA_009027226441__INCLUDED_)
#define AFX_STDAFX_H__48214BA8_E863_11D2_ABDA_009027226441__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxdisp.h>        // MFC Automation classes
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__48214BA8_E863_11D2_ABDA_009027226441__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiatest\waitdlg.cpp ===
// WaitDlg.cpp : implementation file
//

#include "stdafx.h"
#include "WIATest.h"
#include "WaitDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CWaitDlg dialog


CWaitDlg::CWaitDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CWaitDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CWaitDlg)
	m_WaitMessage = _T("");
	//}}AFX_DATA_INIT
}


void CWaitDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CWaitDlg)
	DDX_Text(pDX, IDC_WAIT_MESSAGE, m_WaitMessage);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CWaitDlg, CDialog)
	//{{AFX_MSG_MAP(CWaitDlg)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWaitDlg message handlers

void CWaitDlg::SetMSG(CString Message)
{
	m_WaitMessage = Message;
	UpdateData(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiatest\waitdlg.h ===
#if !defined(AFX_WAITDLG_H__C0A530A0_D255_11D2_B1C1_009027226441__INCLUDED_)
#define AFX_WAITDLG_H__C0A530A0_D255_11D2_B1C1_009027226441__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// WaitDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CWaitDlg dialog

class CWaitDlg : public CDialog
{
// Construction
public:
	void SetMSG(CString Message);
	CWaitDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CWaitDlg)
	enum { IDD = IDD_WAIT_DIALOG };
	CString	m_WaitMessage;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CWaitDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CWaitDlg)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_WAITDLG_H__C0A530A0_D255_11D2_B1C1_009027226441__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiatest\wiapreview.cpp ===
// WIAPreview.cpp : implementation file
//

#include "stdafx.h"
#include "wiatest.h"
#include "WIAPreview.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CWIAPreview
/**************************************************************************\
* CWIAPreview::CWIAPreview()
*   
*   Constructor for the CWIAPreview class
*   
*   
* Arguments:
*   
*   none
*
* Return Value:
*
*    none
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
CWIAPreview::CWIAPreview()
{
    m_PaintMode = PAINT_TOFIT;
    m_pDIB = NULL;
    m_Scrollpt.x = 0;
    m_Scrollpt.y = 0;
}
/**************************************************************************\
* CWIAPreview::~CWIAPreview()
*   
*   Destructor for the CWIAPreview class
*   
*   
* Arguments:
*   
*   none
*
* Return Value:
*
*    none
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
CWIAPreview::~CWIAPreview()
{
}


BEGIN_MESSAGE_MAP(CWIAPreview, CWnd)
    //{{AFX_MSG_MAP(CWIAPreview)
    ON_WM_PAINT()
    ON_WM_HSCROLL()
    ON_WM_VSCROLL()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CWIAPreview message handlers
/**************************************************************************\
* CWIAPreview::OnPaint()
*   
*   Handles painting of the DIB
*   
*   
* Arguments:
*   
*   none
*
* Return Value:
*
*    none
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
void CWIAPreview::OnPaint() 
{
    CPaintDC dc(this); // device context for painting
    CleanBackground();
    PaintImage();
    // Do not call CWnd::OnPaint() for painting messages
}
/**************************************************************************\
* CWIAPreview::SetDIB()
*   
*   Initializes Preview window with a DIB pointer to data display.
*   
*   
* Arguments:
*   
*   pDib - DIB data to display
*
* Return Value:
*
*    none
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
void CWIAPreview::SetDIB(CDib *pDib)
{
    m_pDIB = pDib;
    if(pDib != NULL)
    {
        //
        // Set Scroll sizes according to DIB data size
        //
        SetScrollRange(SB_HORZ,0,pDib->Width(),TRUE);
        SetScrollRange(SB_VERT,0,pDib->Height(),TRUE);
    }
}
/**************************************************************************\
* CWIAPreview::SetPaintMode()
*   
*   Toggle the preview mode.  
*   
*   
* Arguments:
*   
*   modeflag - Toggle flag for setting display modes
*   PAINT_ACTUAL - actual size of image (1 to 1)
*   PAINT_TOFIT - scales image to fit window frame
*
* Return Value:
*
*    none
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
void CWIAPreview::SetPaintMode(int modeflag)
{
    m_PaintMode = modeflag;
    
}
/**************************************************************************\
* CWIAPreview::OnHScroll()
*   
*   Handles Horizontal scroll messages
*   
*   
* Arguments:
*   
*   nSBCode - Scroll bar code
*   nPos - Scroll position (valid only is SB_THUMBTRACK,SB_THUMBPOSITION)
*   pScrollBar - pointer to Scrollbar control
*
* Return Value:
*
*    none
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
void CWIAPreview::OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar) 
{   
    switch(nSBCode)
    {
    case SB_LINELEFT:
        m_Scrollpt.x +=1;
        if(m_Scrollpt.x >0)
            m_Scrollpt.x = 0;
        SetScrollPos(SB_HORZ,-m_Scrollpt.x,TRUE);
        break;
    case SB_LINERIGHT:
        m_Scrollpt.x -=1;
        SetScrollPos(SB_HORZ,-m_Scrollpt.x,TRUE);
        break;
    case SB_PAGERIGHT:
        m_Scrollpt.x -=5;
        SetScrollPos(SB_HORZ,-m_Scrollpt.x,TRUE);
        break;
    case SB_PAGELEFT:
        m_Scrollpt.x +=5;
        if(m_Scrollpt.x >0)
            m_Scrollpt.x = 0;
        SetScrollPos(SB_HORZ,-m_Scrollpt.x,TRUE);
        break;
    case SB_THUMBPOSITION:
    case SB_THUMBTRACK:
        m_Scrollpt.x = (nPos * -1);
        SetScrollPos(SB_HORZ,nPos,TRUE);
        break;
    case SB_ENDSCROLL:
        // OutputDebugString("END SCROLL\n");
        break;
    default:
        // OutputDebugString("Default????\n");
        break;
    }
    PaintImage();
    CWnd::OnHScroll(nSBCode, nPos, pScrollBar);
}
/**************************************************************************\
* CWIAPreview::OnVScroll()
*   
*   Handles Vertical scroll messages
*   
*   
* Arguments:
*   
*   nSBCode - Scroll bar code
*   nPos - Scroll position (valid only is SB_THUMBTRACK,SB_THUMBPOSITION)
*   pScrollBar - pointer to Scrollbar control
*
* Return Value:
*
*    none
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
void CWIAPreview::OnVScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar) 
{
    switch(nSBCode)
    {
    case SB_LINEUP:
        m_Scrollpt.y +=1;
        if(m_Scrollpt.y >0)
            m_Scrollpt.y = 0;
        SetScrollPos(SB_VERT,-m_Scrollpt.y,TRUE);
        break;
    case SB_LINEDOWN:
        m_Scrollpt.y -=1;
        SetScrollPos(SB_VERT,-m_Scrollpt.y,TRUE);
        break;
    case SB_PAGEUP:
        m_Scrollpt.y +=5;
        if(m_Scrollpt.y >0)
            m_Scrollpt.y = 0;
        SetScrollPos(SB_VERT,-m_Scrollpt.y,TRUE);
        break;
    case SB_PAGEDOWN:
        
        m_Scrollpt.y -=5;
        SetScrollPos(SB_VERT,-m_Scrollpt.y,TRUE);
        break;
    case SB_THUMBPOSITION:
    case SB_THUMBTRACK:
        m_Scrollpt.y = (nPos * -1);
        SetScrollPos(SB_VERT,nPos,TRUE);
        break;
    case SB_ENDSCROLL:
        // OutputDebugString("END SCROLL\n");
        break;
    default:
        // OutputDebugString("Default????\n");
        break;
    }
    PaintImage();
    CWnd::OnVScroll(nSBCode, nPos, pScrollBar);
}
/**************************************************************************\
* CWIAPreview::PaintImage()
*   
*   Handles image painting according to set mode
*   
*   
* Arguments:
*   
*   none
*
* Return Value:
*
*    none
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
void CWIAPreview::PaintImage()
{
    if(m_pDIB != NULL)
    {
        RECT ImageRect;
        RECT WindowRect;
        DWORD ScaleFactor = 0;
        CDC* pDC = NULL;
        pDC = GetDC();
        if(m_pDIB->GotImage())
        {
            if(m_PaintMode == PAINT_TOFIT)
            {
                ImageRect.top = 0;
                ImageRect.left = 0;
                ImageRect.right = m_pDIB->Width();
                ImageRect.bottom = m_pDIB->Height();
                
                GetWindowRect(&WindowRect);
                ScreenToClient(&WindowRect);
                WindowRect.bottom-=1;
                WindowRect.left+=1;
                WindowRect.right-=1;
                WindowRect.top+=1;
                m_pDIB->Paint(pDC->m_hDC,&WindowRect,&ImageRect);
                ShowScrollBar(SB_BOTH,FALSE);
            }
            else
            {
                ImageRect.top = 0;
                ImageRect.left = 0;
                ImageRect.right = m_pDIB->Width();
                ImageRect.bottom = m_pDIB->Height();

                WindowRect.bottom   = ImageRect.bottom;
                WindowRect.left     = m_Scrollpt.x;
                WindowRect.right    = ImageRect.right;
                WindowRect.top      = m_Scrollpt.y;

                m_pDIB->Paint(pDC->m_hDC,&WindowRect,&ImageRect);
                ShowScrollBar(SB_BOTH,TRUE);
            }
        }
        else
        {
            GetWindowRect(&WindowRect);
            ScreenToClient(&WindowRect);
            WindowRect.bottom-=1;
            WindowRect.left+=1;
            WindowRect.right-=1;
            WindowRect.top+=1;
            
            HBRUSH hBrush = CreateSolidBrush(GetBkColor(pDC->m_hDC));
            FillRect(pDC->m_hDC,&WindowRect,hBrush);
            DeleteObject(hBrush);
        }
    }
}
/**************************************************************************\
* CWIAPreview::CleanBackground()
*   
*   Wipes the surface for a repaint to take place (WHITE)
*   
*   
* Arguments:
*   
*   none
*
* Return Value:
*
*    none
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
void CWIAPreview::CleanBackground()
{
    RECT WindowRect;
    CDC* pDC = NULL;
    pDC = GetDC();

    GetWindowRect(&WindowRect);
    ScreenToClient(&WindowRect);
    WindowRect.bottom-=1;
    WindowRect.left+=1;
    WindowRect.right-=1;
    WindowRect.top+=1;
    
    HBRUSH hBrush = CreateSolidBrush(GetBkColor(pDC->m_hDC));
    FillRect(pDC->m_hDC,&WindowRect,hBrush);
    DeleteObject(hBrush);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiatest\wiatest.cpp ===
// WIATest.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "WIATest.h"

#include "MainFrm.h"
#include "WIATestDoc.h"
#include "WIATestView.h"

//
// enable/disable MessageBox Error reporting
//
#define _MESSAGEBOX_DEBUG
#define MIN_PROPID 2

#ifdef _DEBUG
    #define new DEBUG_NEW
    #undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

class CWiaTestCmdLineInfo : public CCommandLineInfo {
public:
    virtual void ParseParam(const char* pszParam, BOOL bFlag, BOOL bLast);
};

void CWiaTestCmdLineInfo::ParseParam(const char* pszParam, BOOL bFlag, BOOL bLast)
{
    TRACE("CWiaTestCmdLineInfo::ParseParam(%s)\n",pszParam);
}
/////////////////////////////////////////////////////////////////////////////
// CWIATestApp

BEGIN_MESSAGE_MAP(CWIATestApp, CWinApp)
//{{AFX_MSG_MAP(CWIATestApp)
ON_COMMAND(ID_APP_ABOUT, OnAppAbout)
// NOTE - the ClassWizard will add and remove mapping macros here.
//    DO NOT EDIT what you see in these blocks of generated code!
//}}AFX_MSG_MAP
// Standard file based document commands
ON_COMMAND(ID_FILE_NEW, CWinApp::OnFileNew)
ON_COMMAND(ID_FILE_OPEN, CWinApp::OnFileOpen)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWIATestApp construction

CWIATestApp::CWIATestApp()
{
    // TODO: add construction code here,
    // Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CWIATestApp object

CWIATestApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CWIATestApp initialization
/**************************************************************************\
* CWIATestApp::InitInstance()
*
*   Initializes Instance of the WIATEST application
*
*
* Arguments:
*
*       none
*
* Return Value:
*
*    status
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
BOOL CWIATestApp::InitInstance()
{
    AfxEnableControlContainer();

    // Standard initialization

#ifdef _AFXDLL
    Enable3dControls();         // Call this when using MFC in a shared DLL
#else
    Enable3dControlsStatic();   // Call this when linking to MFC statically
#endif

    //SetRegistryKey(_T("WIATest"));

    //LoadStdProfileSettings(0);  // Load standard INI file options (including MRU)

    // Register the application's document templates.  Document templates
    //  serve as the connection between documents, frame windows and views.

    //
    // Save Command line
    //
    m_CmdLine = m_lpCmdLine;

    CSingleDocTemplate* pDocTemplate;
    pDocTemplate = new CSingleDocTemplate(
                                         IDR_MAINFRAME,
                                         RUNTIME_CLASS(CWIATestDoc),
                                         RUNTIME_CLASS(CMainFrame),       // main SDI frame window
                                         RUNTIME_CLASS(CWIATestView));
    AddDocTemplate(pDocTemplate);

    // Parse command line for standard shell commands, DDE, file open
    CWiaTestCmdLineInfo cmdInfo;
    ParseCommandLine(cmdInfo);

    // Dispatch commands specified on the command line
    if (!ProcessShellCommand(cmdInfo))
        return FALSE;

    // The one and only window has been initialized, so show and update it.
    m_pMainWnd->ShowWindow(SW_SHOW);
    m_pMainWnd->UpdateWindow();

    return TRUE;
}

/**************************************************************************\
* CWIATestApp::ExitInstance()
*
*   Exit routine for cleanup on WIATEST application
*
*
* Arguments:
*
*       none
*
* Return Value:
*
*    status
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
int CWIATestApp::ExitInstance()
{
    return CWinApp::ExitInstance();
}

/////////////////////////////////////////////////////////////////////////////
// CWIATestApp message handlers

/**************************************************************************\
* CWIATestApp::GetDeviceIDCommandLine()
*
*   Retrieves Command line
*
*
* Arguments:
*
*       none
*
* Return Value:
*
*    CString - Command line
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
CString CWIATestApp::GetDeviceIDCommandLine()
{
    return m_CmdLine;
}
/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog {
public:
    CAboutDlg();

// Dialog Data
    //{{AFX_DATA(CAboutDlg)
    enum {IDD = IDD_ABOUTBOX};
    //}}AFX_DATA

    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CAboutDlg)
protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    //{{AFX_MSG(CAboutDlg)
    // No message handlers
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
    //{{AFX_DATA_INIT(CAboutDlg)
    //}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CAboutDlg)
    //}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
//{{AFX_MSG_MAP(CAboutDlg)
// No message handlers
//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/**************************************************************************\
* CWIATestApp::OnAppAbout()
*
*   Activates the About Dialog!
*
*
* Arguments:
*
*       none
*
* Return Value:
*
*   none
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
void CWIATestApp::OnAppAbout()
{
    CAboutDlg aboutDlg;
    aboutDlg.DoModal();
}

//////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////// UTILS SECTION ////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////

/**************************************************************************\
* ::ReadPropStr
*
*   Reads a BSTR value of a target property
*
*
* Arguments:
*
*   propid - property ID
*       pIWiaPropStg - property storage
*       pbstr - returned BSTR read from property
*
* Return Value:
*
*    status
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
HRESULT ReadPropStr(PROPID propid,IWiaPropertyStorage  *pIWiaPropStg,BSTR *pbstr)
{
    HRESULT     hResult = S_OK;
    PROPSPEC    PropSpec[1];
    PROPVARIANT PropVar[1];
    UINT        cbSize = 0;

    *pbstr = NULL;
    memset(PropVar, 0, sizeof(PropVar));
    PropSpec[0].ulKind = PRSPEC_PROPID;
    PropSpec[0].propid = propid;
    hResult = pIWiaPropStg->ReadMultiple(1, PropSpec, PropVar);
    if (SUCCEEDED(hResult)) {
        if (PropVar[0].pwszVal) {
            *pbstr = SysAllocString(PropVar[0].pwszVal);
        } else {
            *pbstr = SysAllocString(L"");
        }
        if (*pbstr == NULL) {
            //StressStatus("* ReadPropStr, SysAllocString failed");
            hResult = E_OUTOFMEMORY;
        }
        PropVariantClear(PropVar);
    } else {
        //CString msg;
        //msg.Format("* ReadPropStr, ReadMultiple of propid: %d, Failed", propid);
        //StressStatus(msg);
    }
    return hResult;
}
/**************************************************************************\
* ::WritePropStr
*
*   Writes a BSTR value to a target property
*
*
* Arguments:
*
*   propid - property ID
*       pIWiaPropStg - property storage
*       pbstr - BSTR to write to target property
*
* Return Value:
*
*    status
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
HRESULT WritePropStr(PROPID propid, IWiaPropertyStorage  *pIWiaPropStg, BSTR bstr)
{
    HRESULT     hResult = S_OK;
    PROPSPEC    propspec[1];
    PROPVARIANT propvar[1];

    propspec[0].ulKind = PRSPEC_PROPID;
    propspec[0].propid = propid;

    propvar[0].vt      = VT_BSTR;
    propvar[0].pwszVal = bstr;

    hResult = pIWiaPropStg->WriteMultiple(1, propspec, propvar, MIN_PROPID);
    return hResult;
}

/**************************************************************************\
* ::WritePropLong
*
*   Writes a LONG value of a target property
*
*
* Arguments:
*
*   propid - property ID
*       pIWiaPropStg - property storage
*       lVal - LONG to be written to target property
*
* Return Value:
*
*    status
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
HRESULT WritePropLong(PROPID propid, IWiaPropertyStorage *pIWiaPropStg, LONG lVal)
{
    HRESULT     hResult;
    PROPSPEC    propspec[1];
    PROPVARIANT propvar[1];

    propspec[0].ulKind = PRSPEC_PROPID;
    propspec[0].propid = propid;

    propvar[0].vt   = VT_I4;
    propvar[0].lVal = lVal;

    hResult = pIWiaPropStg->WriteMultiple(1, propspec, propvar, MIN_PROPID);
    return hResult;
}

/**************************************************************************\
* ::WritePropGUID
*
*   Writes a GUID value of a target property
*
*
* Arguments:
*
*   propid - property ID
*   pIWiaPropStg - property storage
*   guidVal - GUID to be written to target property
*
* Return Value:
*
*    status
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
HRESULT WritePropGUID(PROPID propid, IWiaPropertyStorage *pIWiaPropStg, GUID guidVal)
{
    HRESULT     hResult;
    PROPSPEC    propspec[1];
    PROPVARIANT propvar[1];

    propspec[0].ulKind = PRSPEC_PROPID;
    propspec[0].propid = propid;

    propvar[0].vt   = VT_CLSID;
    propvar[0].puuid = &guidVal;

    hResult = pIWiaPropStg->WriteMultiple(1, propspec, propvar, MIN_PROPID);
    return hResult;
}

/**************************************************************************\
* ::WriteProp
*
*   Writes a value of a target property
*
*
* Arguments:
*
*   VarType - Varient Type
*   propid - property ID
*   pIWiaPropStg - property storage
*   pVal - value to be written to target property (in string form)
*
* Return Value:
*
*    status
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
HRESULT WriteProp(unsigned int VarType,PROPID propid, IWiaPropertyStorage *pIWiaPropStg, LPCTSTR pVal)
{
    HRESULT     hResult;
    WCHAR wsbuffer[MAX_PATH];
    PROPSPEC    propspec[1];
    PROPVARIANT propvar[1];
    propspec[0].ulKind = PRSPEC_PROPID;
    propspec[0].propid = propid;
    propvar[0].vt   = (VARTYPE)VarType;
    propvar[0].puuid = (GUID *)& GUID_NULL;

    switch (VarType) {
    case VT_I1:
        sscanf(pVal,"%li",&propvar[0].cVal);
        break;
    case VT_I2:
        sscanf(pVal,"%li",&propvar[0].bVal);
        break;
    case VT_I4:
        sscanf(pVal,"%li",&propvar[0].lVal);
        break;
    case VT_I8:
        sscanf(pVal,"%li",&propvar[0].hVal);
        break;
    case VT_UI1:
        sscanf(pVal,"%li",&propvar[0].bVal);
        break;
    case VT_UI2:
        sscanf(pVal,"%li",&propvar[0].uiVal);
        break;
    case VT_UI4:
        sscanf(pVal,"%li",&propvar[0].ulVal);
        break;
    case VT_UI8:
        sscanf(pVal,"%li",&propvar[0].lVal);
        break;
    case VT_INT:
        sscanf(pVal,"%li",&propvar[0].intVal);
        break;
    case VT_R4:
        sscanf(pVal,"%f",&propvar[0].fltVal);
        break;
    case VT_R8:
        sscanf(pVal,"%f",&propvar[0].fltVal);
        break;
    case VT_BSTR:
        MultiByteToWideChar(CP_ACP, 0,pVal,-1,wsbuffer,MAX_PATH);
        propvar[0].bstrVal = SysAllocString(wsbuffer);
        break;
    case VT_CLSID:
        UuidFromString((UCHAR*)pVal,propvar[0].puuid);
        break;
    case VT_UINT:
        sscanf(pVal,"%li",&propvar[0].uintVal);
        break;
    default:
        sscanf(pVal,"%li",&propvar[0].lVal);
        break;
    }

    hResult = pIWiaPropStg->WriteMultiple(1, propspec, propvar, MIN_PROPID);

    return hResult;
}

/**************************************************************************\
* ::ReadPropLong
*
*   Reads a long value from a target property
*
*
* Arguments:
*
*   propid - property ID
*       pIWiaPropStg - property storage
*       plval - returned long read from property
*
* Return Value:
*
*    status
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
HRESULT ReadPropLong(PROPID propid, IWiaPropertyStorage  *pIWiaPropStg, LONG *plval)
{
    HRESULT           hResult = S_OK;
    PROPSPEC          PropSpec[1];
    PROPVARIANT       PropVar[1];
    UINT              cbSize = 0;

    memset(PropVar, 0, sizeof(PropVar));
    PropSpec[0].ulKind = PRSPEC_PROPID;
    PropSpec[0].propid = propid;
    hResult = pIWiaPropStg->ReadMultiple(1, PropSpec, PropVar);
    if (SUCCEEDED(hResult)) {
        *plval = PropVar[0].lVal;
    }
    return hResult;
}


/**************************************************************************\
* ::StressStatus
*
*   Reports status to user via status list box
*
* Arguments:
*
*   status - CString value to be displayed in the list box
*
* Return Value:
*
*    void
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
void StressStatus(CString status)
{
    /*
    int iLine = m_StressStatusListBox.AddString(status);
    m_StressStatusListBox.SetTopIndex(iLine);
    if(m_bLoggingEnabled)
    {
        if(m_LogFile)
        {
            m_LogFile.Write(status.GetBuffer(256),status.GetLength());
            m_LogFile.Write("\r\n",2);
        }

    }
    */
    OutputDebugString(status + "\n");
#ifdef _DEBUG
    //OutputDebugString(status + "\n");
#endif
}
/**************************************************************************\
* ::StressStatus
*
*   Reports status, and hResult to user via status list box
*
* Arguments:
*
*   status - CString value to be displayed in the list box
*       hResult - hResult to be translated
*
* Return Value:
*
*    void
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
void StressStatus(CString status, HRESULT hResult)
{
    CString msg;
    ULONG ulLen = MAX_PATH;
    LPTSTR  pMsgBuf = (char*)LocalAlloc(LPTR,MAX_PATH);

    //
    // attempt to handle WIA custom errors first
    //

    switch (hResult) {
    case WIA_ERROR_GENERAL_ERROR:
        sprintf(pMsgBuf,"There was a general device failure.");
        break;
    case WIA_ERROR_PAPER_JAM:
        sprintf(pMsgBuf,"The paper path is jammed.");
        break;
    case WIA_ERROR_PAPER_EMPTY:
        sprintf(pMsgBuf,"There are no documents in the input tray to scan.");
        break;
    case WIA_ERROR_PAPER_PROBLEM:
        sprintf(pMsgBuf,"There is a general problem with an input document.");
        break;
    case WIA_ERROR_OFFLINE:
        sprintf(pMsgBuf,"The device is offline.");
        break;
    case WIA_ERROR_BUSY:
        sprintf(pMsgBuf,"The device is busy.");
        break;
    case WIA_ERROR_WARMING_UP:
        sprintf(pMsgBuf,"The device is warming up.");
        break;
    case WIA_ERROR_USER_INTERVENTION:
        sprintf(pMsgBuf,"The user has paused or stopped the device.");
        break;
    default:

        //
        // free temp buffer, because FormatMessage() will allocate it for me
        //

        LocalFree(pMsgBuf);
        ulLen = 0;
        ulLen = ::FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
                                NULL, hResult, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                                (LPTSTR)&pMsgBuf, 0, NULL);
        break;
    }

    if (ulLen) {
        msg = pMsgBuf;
        msg.TrimRight();
        LocalFree(pMsgBuf);
    } else {
        // use sprintf to write to buffer instead of .Format member of
        // CString.  This conversion works better for HEX
        char buffer[255];
        sprintf(buffer,"hResult = 0x%08X",hResult);
        msg = buffer;
    }
    StressStatus(status + ", " + msg);

#ifdef _MESSAGEBOX_DEBUG
    MessageBox(NULL,status+ ", " + msg,"WIATest Debug Report",MB_OK|MB_ICONERROR);
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiatest\wiapreview.h ===
#if !defined(AFX_WIAPREVIEW_H__0733B4F0_EC81_11D2_B800_009027226441__INCLUDED_)
#define AFX_WIAPREVIEW_H__0733B4F0_EC81_11D2_B800_009027226441__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// WIAPreview.h : header file
//
#include "cdib.h"
/////////////////////////////////////////////////////////////////////////////
// CWIAPreview window

class CWIAPreview : public CWnd
{
// Construction
public:
	CWIAPreview();

// Attributes
public:

// Operations
public:
	CDib* m_pDIB;
	

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CWIAPreview)
	//}}AFX_VIRTUAL

// Implementation
public:
	void CleanBackground();
	void PaintImage();
	POINT m_Scrollpt;
	void SetPaintMode(int modeflag);
	void SetDIB(CDib* pDib);
	virtual ~CWIAPreview();

	// Generated message map functions
protected:
	int m_PaintMode;
	//{{AFX_MSG(CWIAPreview)
	afx_msg void OnPaint();
	afx_msg void OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);
	afx_msg void OnVScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_WIAPREVIEW_H__0733B4F0_EC81_11D2_B800_009027226441__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiatest\wiatest.h ===
// WIATest.h : main header file for the WIATEST application
//

#if !defined(AFX_WIATEST_H__48214BA6_E863_11D2_ABDA_009027226441__INCLUDED_)
#define AFX_WIATEST_H__48214BA6_E863_11D2_ABDA_009027226441__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef __AFXWIN_H__
    #error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"       // main symbols
#include "cwia.h"           // wia obj
#include "WaitDlg.h"        // WAIT... dialog for in process status

#define _SMARTUI // enables SMARTUI features, Toolbars hiding themselves, and auto adjusting

// bigggg nasty sti.lib link here
#pragma comment(lib, "..\\..\\..\\..\\..\\public\\sdk\\lib\\i386\\sti.lib")
// guid lib link here
#pragma comment(lib, "..\\..\\lib\\winnt\\i386\\wiaguid.lib")
#pragma comment(lib,"winmm.lib")

#define TRANSFER_TO_MEMORY  0
#define TRANSFER_TO_FILE    1

#define EDIT_LIST           0
#define EDIT_RANGE          1
#define EDIT_FLAGS          2
#define EDIT_NONE           3

#define PAINT_TOFIT         0
#define PAINT_ACTUAL        1

// these need to be moved into another place
// temp utils..
HRESULT ReadPropStr(PROPID propid,IWiaPropertyStorage    *pIPropStg, BSTR *pbstr);
HRESULT ReadPropLong(PROPID propid, IWiaPropertyStorage  *pIPropStg, LONG *plval);
HRESULT WritePropLong(PROPID propid, IWiaPropertyStorage *pIPropStg, LONG lVal);
HRESULT WritePropStr(PROPID propid, IWiaPropertyStorage  *pIPropStg, BSTR bstr);
HRESULT WritePropGUID(PROPID propid, IWiaPropertyStorage *pIWiaPropStg, GUID guidVal);
HRESULT WriteProp(unsigned int VarType,PROPID propid, IWiaPropertyStorage *pIWiaPropStg, LPCTSTR pVal);

// logging utils
void StressStatus(CString status, HRESULT hResult);
void StressStatus(CString status);

/////////////////////////////////////////////////////////////////////////////
// CWIATestApp:
// See WIATest.cpp for the implementation of this class
//

class CWIATestApp : public CWinApp
{
public:
    CString GetDeviceIDCommandLine();

    CString m_CmdLine;
    CWIATestApp();

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CWIATestApp)
    public:
    virtual BOOL InitInstance();
    virtual int ExitInstance();
    //}}AFX_VIRTUAL

// Implementation
    //{{AFX_MSG(CWIATestApp)
    afx_msg void OnAppAbout();
        // NOTE - the ClassWizard will add and remove member functions here.
        //    DO NOT EDIT what you see in these blocks of generated code !
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_WIATEST_H__48214BA6_E863_11D2_ABDA_009027226441__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiatest\wiatestdoc.cpp ===
// WIATestDoc.cpp : implementation of the CWIATestDoc class
//

#include "stdafx.h"
#include "WIATest.h"

#include "WIATestDoc.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CWIATestDoc

IMPLEMENT_DYNCREATE(CWIATestDoc, CDocument)

BEGIN_MESSAGE_MAP(CWIATestDoc, CDocument)
	//{{AFX_MSG_MAP(CWIATestDoc)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWIATestDoc construction/destruction
/**************************************************************************\
* CWIATestDoc::CWIATestDoc()
*   
*   Constructor for the CWIATestDoc class
*	
*   
* Arguments:
*   
*   none
*
* Return Value:
*
*    none
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
CWIATestDoc::CWIATestDoc()
{
	
}
/**************************************************************************\
* CWIATestDoc::~CWIATestDoc()
*   
*   Destructor for the CWIATestDoc class
*	
*   
* Arguments:
*   
*   none
*
* Return Value:
*
*    none
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
CWIATestDoc::~CWIATestDoc()
{
}
/**************************************************************************\
* CWIATestDoc::OnNewDocument()
*   
*   Creates a new document (not used at this time)
*	
*   
* Arguments:
*   
*   none
*
* Return Value:
*
*    none
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
BOOL CWIATestDoc::OnNewDocument()
{
	if (!CDocument::OnNewDocument())
		return FALSE;
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CWIATestDoc serialization
/**************************************************************************\
* CWIATestDoc::Serialize()
*   
*   saves/loads a WIATest Document (not used at this time)
*	
*   
* Arguments:
*   
*   ar - CArchive Object
*
* Return Value:
*
*    none
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
void CWIATestDoc::Serialize(CArchive& ar)
{
	if (ar.IsStoring())
	{
		// TODO: add storing code here
	}
	else
	{
		// TODO: add loading code here
	}
}

/////////////////////////////////////////////////////////////////////////////
// CWIATestDoc diagnostics

#ifdef _DEBUG
void CWIATestDoc::AssertValid() const
{
	CDocument::AssertValid();
}

void CWIATestDoc::Dump(CDumpContext& dc) const
{
	CDocument::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CWIATestDoc commands
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiatest\wiatestui.cpp ===
// WIATestUI.cpp : implementation file
//

#include "stdafx.h"
#include "WIATest.h"
#include "WIATestUI.h"


#ifdef _DEBUG
    #define new DEBUG_NEW
    #undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CWIAPropListCtrl
/**************************************************************************\
* CWIAPropListCtrl::CWIAPropListCtrl()
*
*   Constructor for the CWIAPropListCtrl class
*
*
* Arguments:
*
*   none
*
* Return Value:
*
*    none
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
CWIAPropListCtrl::CWIAPropListCtrl()
{
}
/**************************************************************************\
* CWIAPropListCtrl::~CWIAPropListCtrl()
*
*   Destructor for the CWIAPropListCtrl class
*
*
* Arguments:
*
*   none
*
* Return Value:
*
*    none
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
CWIAPropListCtrl::~CWIAPropListCtrl()
{
}


BEGIN_MESSAGE_MAP(CWIAPropListCtrl, CListCtrl)
//{{AFX_MSG_MAP(CWIAPropListCtrl)
ON_WM_SHOWWINDOW()
//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWIAPropListCtrl message handlers
/**************************************************************************\
* CWIAPropListCtrl::InitHeaders()
*
*   Constructs the headers / colums for the list control
*
*
* Arguments:
*
*   none
*
* Return Value:
*
*    none
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
void CWIAPropListCtrl::InitHeaders()
{
    LVCOLUMN lv;
    int i = 0;
    // initialize item property list control column headers

    // Property name
    lv.mask         = LVCF_FMT | LVCF_TEXT | LVCF_WIDTH;
    lv.fmt          = LVCFMT_LEFT ;
    lv.cx           = 100;
    lv.pszText      = "Property";
    lv.cchTextMax   = 0;
    lv.iSubItem     = 0;
    lv.iImage       = 0;
    lv.iOrder       = 0;
    i = InsertColumn(0,&lv);

    // Property Value (current)
    lv.cx           = 125;
    lv.iOrder       = 1;
    lv.iSubItem     = 1;
    lv.pszText      = "Value";
    i = InsertColumn(1,&lv);

    // VT_???
    lv.cx           = 85;
    lv.iOrder       = 2;
    lv.iSubItem     = 2;
    lv.pszText      = "Var Type";
    i = InsertColumn(2,&lv);

    // Property access Flags
    lv.cx           = 500;
    lv.iOrder       = 3;
    lv.iSubItem     = 3;
    lv.pszText      = "Access Flags";
    i = InsertColumn(3,&lv);
}

/**************************************************************************\
* CWIAPropListCtrl::ConvertPropVarToString()
*
*   Converts the Property value to a string for display only
*
*
* Arguments:
*
*   pPropVar - Target Property Variant
*   pszVal - String value converted
*
* Return Value:
*
*    none
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
void CWIAPropListCtrl::ConvertPropVarToString(PROPVARIANT  *pPropVar,LPSTR szVal)
{
    char szValue[MAX_PATH];

    switch (pPropVar->vt) {
    case VT_I1:
        {
            sprintf(szValue,"%d",pPropVar->cVal);
            strcpy(szVal,szValue);
        }
        break;
    case VT_UI1:
        {
            sprintf(szValue,"%d",pPropVar->bVal);
            strcpy(szVal,szValue);
        }
        break;
    case VT_I2:
        {
            sprintf(szValue,"%d",pPropVar->iVal);
            strcpy(szVal,szValue);
        }
        break;
    case VT_UI2:
        {
            sprintf(szValue,"%d",pPropVar->uiVal);
            strcpy(szVal,szValue);
        }
        break;
    case VT_UI4:
        {
            sprintf(szValue,"%d",pPropVar->ulVal);
            strcpy(szVal,szValue);
        }
        break;
    case VT_UI8:
        {
            sprintf(szValue,"%d",pPropVar->lVal);
            strcpy(szVal,szValue);
        }
        break;
    case VT_INT:
        {
            sprintf(szValue,"%d",pPropVar->intVal);
            strcpy(szVal,szValue);
        }
        break;
    case VT_I4:
        {
            sprintf(szValue,"%d",pPropVar->lVal);
            strcpy(szVal,szValue);
        }
        break;
    case VT_I8:
        {
            sprintf(szValue,"%d",pPropVar->hVal);
            strcpy(szVal,szValue);
        }
        break;
    case VT_R4:
        {
            sprintf(szValue,"%2.5f",pPropVar->fltVal);
            strcpy(szVal,szValue);
        }
        break;
    case VT_R8:
        {
            sprintf(szValue,"%2.5f",pPropVar->dblVal);
            strcpy(szVal,szValue);
        }
        break;
    case VT_BSTR:
        {
            if (WideCharToMultiByte(CP_ACP, 0,pPropVar->bstrVal, -1,
                                    szValue, MAX_PATH,NULL,NULL) > 0) {
                strcpy(szVal,szValue);

            } else
                strcpy(szVal,"");
        }
        break;
    case VT_LPSTR:
        {
            strcpy(szVal,pPropVar->pszVal);
        }
        break;
    case VT_LPWSTR:
        {
            sprintf(szValue,"%ws",pPropVar->pwszVal);
            strcpy(szVal,szValue);
        }
        break;
    case VT_UINT:
        {
            sprintf(szValue,"%d",pPropVar->uintVal);
            strcpy(szVal,szValue);
        }
        break;
    case VT_CLSID:
        {
            UCHAR *pwszUUID = NULL;
            UuidToStringA(pPropVar->puuid,&pwszUUID);
            sprintf(szValue,"%s",pwszUUID);
            strcpy(szVal,szValue);
            RpcStringFree(&pwszUUID);
        }
        break;
    default:
        {
            sprintf(szValue,"%d",pPropVar->lVal);
            strcpy(szVal,szValue);
        }
        break;
    }
}

/**************************************************************************\
* CWIAPropListCtrl::DisplayItemPropData()
*
*   Displays formatted property data from the specified item
*
*
* Arguments:
*
*   pIWiaItem - Target item
*
* Return Value:
*
*    none
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
void CWIAPropListCtrl::DisplayItemPropData(IWiaItem *pIWiaItem,BOOL bAccessFlags)
{
    HRESULT hResult = S_OK;
    IWiaPropertyStorage *pIWiaPropStg = NULL;
    BSTR bstrFullItemName = NULL;
    BOOL bSuccess = FALSE;
    int ItemNumber = 0;

    //
    // if the IWiaItem is NULL, Clean the display and exit
    //

    if (pIWiaItem == NULL) {
        DeleteAllItems();
        return;
    }

    //
    // Delete all Items (Possible others)
    //

    DeleteAllItems();

    hResult = pIWiaItem->QueryInterface(IID_IWiaPropertyStorage,(void **)&pIWiaPropStg);
    if (hResult == S_OK) {

        //
        // Start Enumeration
        //

        IEnumSTATPROPSTG    *pIPropEnum;
        hResult = pIWiaPropStg->Enum(&pIPropEnum);
        if (hResult == S_OK) {
            STATPROPSTG StatPropStg;
            do {
                hResult = pIPropEnum->Next(1,&StatPropStg,NULL);
                if (hResult == S_OK) {
                    if (StatPropStg.lpwstrName != NULL) {

                        //
                        // read property value
                        //

                        PROPSPEC        PropSpec;
                        PROPVARIANT     PropVar;

                        PropSpec.ulKind = PRSPEC_PROPID;
                        PropSpec.propid = StatPropStg.propid;

                        hResult = pIWiaPropStg->ReadMultiple(1,&PropSpec,&PropVar);
                        if (hResult == S_OK) {
                            CHAR  szPropName[MAX_PATH];
                            CHAR  szValue[MAX_PATH];
                            CHAR  szText[MAX_PATH];

                            LV_ITEM         lvitem;

                            lvitem.mask     = LVIF_TEXT | LVIF_PARAM;
                            lvitem.iItem    = ItemNumber;
                            lvitem.iSubItem = 0;
                            lvitem.pszText  = szText;
                            lvitem.iImage   = NULL;
                            lvitem.lParam   = StatPropStg.propid;

                            //
                            // Write property name to list control
                            //

                            if (WideCharToMultiByte(CP_ACP, 0,StatPropStg.lpwstrName,-1,
                                                    szPropName, MAX_PATH,NULL,NULL) > 0) {
                                strcpy(szText,szPropName);
                                InsertItem(&lvitem);

                                //
                                // move to next column for setting the value
                                //

                                lvitem.mask     = LVIF_TEXT;
                                lvitem.iSubItem = 1;
                            } else
                                strcpy(szPropName,"");


                            //
                            // Write propery value to list control
                            //

                            ConvertPropVarToString(&PropVar,szText);
                            SetItem(&lvitem);
                            ItemNumber++;

                            //
                            // Display output to the debugger
                            //

                            CString msg;
                            msg.Format("Property: %s = %s",szPropName,szText);
                            StressStatus(msg);
                            if (bAccessFlags) {

                                //
                                // display access flags and var type
                                //

                                ULONG AccessFlags = 0;
                                ULONG VarType = 0;
                                PROPVARIANT     AttrPropVar; // not used at this time
                                hResult = pIWiaPropStg->GetPropertyAttributes(1, &PropSpec,&AccessFlags,&AttrPropVar);
                                if (hResult != S_OK) {
                                    StressStatus("* pIWiaItem->GetPropertyAttributes() Failed",hResult);
                                    hResult = S_OK; // do this to continue property traversal
                                } else {
                                    //
                                    // display access flags
                                    //
                                    lvitem.mask     = LVIF_TEXT;
                                    lvitem.iSubItem = 3;
                                    if (ConvertAccessFlagsToString(lvitem.pszText,AccessFlags))
                                        SetItem(&lvitem);
                                }
                            }

                            //
                            // display var type
                            //

                            lvitem.mask     = LVIF_TEXT;
                            lvitem.iSubItem = 2;

                            if (ConvertVarTypeToString(lvitem.pszText,PropVar.vt))
                                SetItem(&lvitem);
                        }
                    } else {
                        CString msg;
                        msg.Format("* Property with NULL name, propid = %li\n",StatPropStg.propid);
                        StressStatus(msg);
                    }
                }
                //
                // clean up property name
                //
                CoTaskMemFree(StatPropStg.lpwstrName);
            } while (hResult == S_OK);
        }
        pIPropEnum->Release();
        pIWiaPropStg->Release();
    }
    //
    // auto resize columns to fit data
    //
    for (int Col = 0; Col <4;Col++)
        SetColumnWidth(Col, LVSCW_AUTOSIZE );
}
/**************************************************************************\
* CWIAPropListCtrl::ConvertAccessFlagsToString()
*
*   Converts the accessflag into a readable string for display only
*
*
* Arguments:
*
*   pszText - target string pointer for formatted string
*   AccessFlag - Flag to convert
*
* Return Value:
*
*    none
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
BOOL CWIAPropListCtrl::ConvertAccessFlagsToString(char* pszText,ULONG AccessFlags)
{
    if (pszText == NULL)
        return FALSE;
    CString sFlag = "";
    if ((AccessFlags & WIA_PROP_READ) == WIA_PROP_READ)
        sFlag += "WIA_PROP_READ | ";

    if ((AccessFlags & WIA_PROP_WRITE) == WIA_PROP_WRITE)
        sFlag += "WIA_PROP_WRITE | ";

    if (sFlag == "WIA_PROP_READ | WIA_PROP_WRITE | ")
        sFlag = "WIA_PROP_RW | ";

    if ((AccessFlags & WIA_PROP_NONE) == WIA_PROP_NONE)
        sFlag += "WIA_PROP_NONE | ";

    if ((AccessFlags & WIA_PROP_RANGE) == WIA_PROP_RANGE)
        sFlag += "WIA_PROP_RANGE | ";

    if ((AccessFlags & WIA_PROP_LIST) == WIA_PROP_LIST)
        sFlag += "WIA_PROP_LIST | ";

    if ((AccessFlags & WIA_PROP_FLAG) == WIA_PROP_FLAG)
        sFlag += "WIA_PROP_FLAG | ";

    // check for unknown access flags
    if (sFlag.GetLength() == 0)
        sFlag.Format("WIA_PROP_UNKNOWN = %d    ",AccessFlags);

    sFlag = sFlag.Left(sFlag.GetLength()-3);
    strcpy(pszText,sFlag.GetBuffer(256));
    return TRUE;
}
/**************************************************************************\
* CWIAPropListCtrl::ConvertVarTypeToString()
*
*   Converts Var Type to a readable string for display only
*
*
* Arguments:
*
*   pszText - Target string pointer for formatted string data
*   VarType - Var type to convert
*
* Return Value:
*
*    none
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
BOOL CWIAPropListCtrl::ConvertVarTypeToString(char* pszText,ULONG VarType)
{
    if (pszText == NULL)
        return FALSE;
    switch (VarType) {
    case VT_EMPTY:              // nothing
        strcpy(pszText,TEXT("VT_EMPTY"));
        break;
    case VT_NULL:               // SQL style Null
        strcpy(pszText,TEXT("VT_NULL"));
        break;
    case VT_I2:                 // 2 byte signed int
        strcpy(pszText,TEXT("VT_I2"));
        break;
    case VT_I4:                 // 4 byte signed int
        strcpy(pszText,TEXT("VT_I4"));
        break;
    case VT_R4:                 // 4 byte real
        strcpy(pszText,TEXT("VT_R4"));
        break;
    case VT_R8:                 // 8 byte real
        strcpy(pszText,TEXT("VT_R8"));
        break;
    case VT_CY:                 // currency
        strcpy(pszText,TEXT("VT_CY"));
        break;
    case VT_DATE:               // date
        strcpy(pszText,TEXT("VT_DATE"));
        break;
    case VT_BSTR:               // OLE Automation string
        strcpy(pszText,TEXT("VT_BSTR"));
        break;
    case VT_DISPATCH:           // IDispatch *
        strcpy(pszText,TEXT("VT_DISPATCH"));
        break;
    case VT_ERROR:              // SCODE
        strcpy(pszText,TEXT("VT_ERROR"));
        break;
    case VT_BOOL:               // True=-1, False=0
        strcpy(pszText,TEXT("VT_BOOL"));
        break;
    case VT_VARIANT:            // VARIANT *
        strcpy(pszText,TEXT("VT_VARIANT"));
        break;
    case VT_UNKNOWN:            // IUnknown *
        strcpy(pszText,TEXT("VT_UNKNOWN"));
        break;
    case VT_DECIMAL:            // 16 byte fixed point
        strcpy(pszText,TEXT("VT_DECIMAL"));
        break;
    case VT_RECORD:             // user defined type
        strcpy(pszText,TEXT("VT_RECORD"));
        break;
    case VT_I1:                 // signed char
        strcpy(pszText,TEXT("VT_I1"));
        break;
    case VT_UI1:                // unsigned char
        strcpy(pszText,TEXT("VT_UI1"));
        break;
    case VT_UI2:                // unsigned short
        strcpy(pszText,TEXT("VT_UI2"));
        break;
    case VT_UI4:                // unsigned short
        strcpy(pszText,TEXT("VT_UI4"));
        break;
    case VT_I8:                 // signed 64-bit int
        strcpy(pszText,TEXT("VT_I8"));
        break;
    case VT_UI8:                // unsigned 64-bit int
        strcpy(pszText,TEXT("VT_UI8"));
        break;
    case VT_INT:                // signed machine int
        strcpy(pszText,TEXT("VT_INT"));
        break;
    case VT_UINT:               // unsigned machine int
        strcpy(pszText,TEXT("VT_UINT"));
        break;
    case VT_VOID:               // C style void
        strcpy(pszText,TEXT("VT_VOID"));
        break;
    case VT_HRESULT:            // Standard return type
        strcpy(pszText,TEXT("VT_HRESULT"));
        break;
    case VT_PTR:                // pointer type
        strcpy(pszText,TEXT("VT_PTR"));
        break;
    case VT_SAFEARRAY:          // (use VT_ARRAY in VARIANT)
        strcpy(pszText,TEXT("VT_SAFEARRAY"));
        break;
    case VT_CARRAY:             // C style array
        strcpy(pszText,TEXT("VT_CARRAY"));
        break;
    case VT_USERDEFINED:        // user defined type
        strcpy(pszText,TEXT("VT_USERDEFINED"));
        break;
    case VT_LPSTR:              // null terminated string
        strcpy(pszText,TEXT("VT_LPSTR"));
        break;
    case VT_LPWSTR:             // wide null terminated string
        strcpy(pszText,TEXT("VT_LPWSTR"));
        break;
    case VT_FILETIME:           // FILETIME
        strcpy(pszText,TEXT("VT_FILETIME"));
        break;
    case VT_BLOB:               // Length prefixed bytes
        strcpy(pszText,TEXT("VT_BLOB"));
        break;
    case VT_STREAM:             // Name of the stream follows
        strcpy(pszText,TEXT("VT_STREAM"));
        break;
    case VT_STORAGE:            // Name of the storage follows
        strcpy(pszText,TEXT("VT_STORAGE"));
        break;
    case VT_STREAMED_OBJECT:    // Stream contains an object
        strcpy(pszText,TEXT("VT_STREAMED_OBJECT"));
        break;
    case VT_STORED_OBJECT:      // Storage contains an object
        strcpy(pszText,TEXT("VT_STORED_OBJECT"));
        break;
    case VT_VERSIONED_STREAM:   // Stream with a GUID version
        strcpy(pszText,TEXT("VT_VERSIONED_STREAM"));
        break;
    case VT_BLOB_OBJECT:        // Blob contains an object
        strcpy(pszText,TEXT("VT_BLOB_OBJECT"));
        break;
    case VT_CF:                 // Clipboard format
        strcpy(pszText,TEXT("VT_CF"));
        break;
    case VT_CLSID:              // A Class ID
        strcpy(pszText,TEXT("VT_CLSID"));
        break;
    case VT_VECTOR:             // simple counted array
        strcpy(pszText,TEXT("VT_VECTOR"));
        break;
    case VT_ARRAY:              // SAFEARRAY*
        strcpy(pszText,TEXT("VT_ARRAY"));
        break;
    case VT_BYREF:              // void* for local use
        strcpy(pszText,TEXT("VT_BYREF"));
        break;
    case VT_BSTR_BLOB:          // Reserved for system use
        strcpy(pszText,TEXT("VT_BSTR_BLOB"));
        break;
    case VT_VECTOR|VT_I4:
        strcpy(pszText,TEXT("VT_VECTOR | VT_I4"));
        break;
    case VT_VECTOR | VT_UI1:
        strcpy(pszText,TEXT("VT_VECTOR | VT_UI1"));
        break;
    default:                    // unknown type detected!!
        strcpy(pszText,TEXT("VT_UNKNOWNTYPE"));
        break;
    }
    return TRUE;
}
/**************************************************************************\
* CWIAPropListCtrl::Resize()
*
*   Resizes the list control to specified changes in dx, and dy values
*
*
* Arguments:
*
*   dx - change in Width of parent frame
*   dy - change in Height of parent frame
*
* Return Value:
*
*    none
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
void CWIAPropListCtrl::Resize(int dx, int dy)
{
    RECT ListBoxRect;
    GetWindowRect(&ListBoxRect);
    CWnd* pFrm = GetParent();
    if (pFrm != NULL)
        pFrm->ScreenToClient(&ListBoxRect);

    ListBoxRect.right += dx;
    ListBoxRect.bottom += dy;
    MoveWindow(&ListBoxRect);
}
/////////////////////////////////////////////////////////////////////////////
// CWIATreeCtrl
/**************************************************************************\
* CWIATreeCtrl::CWIATreeCtrl()
*
*   Constructor for CWIATreeCtrl class
*
*
* Arguments:
*
*   none
*
* Return Value:
*
*    none
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
CWIATreeCtrl::CWIATreeCtrl()
{
}
/**************************************************************************\
* CWIATreeCtrl::~CWIATreeCtrl()
*
*   Destructor for the CWIATreeCtrl class
*
*
* Arguments:
*
*   none
*
* Return Value:
*
*    none
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
CWIATreeCtrl::~CWIATreeCtrl()
{
}


BEGIN_MESSAGE_MAP(CWIATreeCtrl, CTreeCtrl)
//{{AFX_MSG_MAP(CWIATreeCtrl)
// NOTE - the ClassWizard will add and remove mapping macros here.
//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CWIATreeCtrl message handlers


void CWIATreeCtrl::InitHeaders()
{
    // initialize the tree control
    //m_ItemTree.SetImageList(((CWIATestApp*)pApp)->GetApplicationImageList(),TVSIL_NORMAL);
}
/**************************************************************************\
* CWIATreeCtrl::BuildItemTree()
*
*   Constructs a Tree display of the Active Tree list which contains, Item pointers
*
*
* Arguments:
*
*   pActiveTreeList - list of IWiaItem* pointers
*
* Return Value:
*
*    none
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
BOOL CWIATreeCtrl::BuildItemTree(CPtrList *pActiveTreeList)
{
    DeleteAllItems();
    //
    // Start at head of the ActiveTree list
    //
    m_CurrentPosition = pActiveTreeList->GetHeadPosition();
    Construct(pActiveTreeList, TVI_ROOT,0);
    //
    // select the Root item
    //
    SelectItem(GetRootItem());
    return TRUE;
}
/**************************************************************************\
* CWIATreeCtrl::Construct()
*
*   Build the actual tree in display form
*
*
* Arguments:
*
*   pActiveTreeList - list of IWiaItem* pointers
*   hParent - handle of Parent tree item
*   ParentID - Parent's ID...which level does the item belong to???
*
* Return Value:
*
*    none
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
BOOL CWIATreeCtrl::Construct(CPtrList *pActiveTreeList, HTREEITEM hParent, int ParentID)
{
    IWiaItem* pIWiaItem = NULL;
    WIAITEMTREENODE* pWiaItemTreeNode = NULL;
    IWiaPropertyStorage *pIWiaPropStg;
    HRESULT hResult = S_OK;
    HTREEITEM hTree = NULL;
    IEnumWiaItem* pEnumItem = NULL;
    TV_INSERTSTRUCT tv;

    tv.hParent              = hParent;
    tv.hInsertAfter         = TVI_LAST;
    tv.item.mask            = TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_TEXT | TVIF_PARAM;
    tv.item.hItem           = NULL;
    tv.item.state           = TVIS_EXPANDED;
    tv.item.stateMask       = TVIS_STATEIMAGEMASK;
    tv.item.cchTextMax      = 6;
    tv.item.cChildren       = 0;
    tv.item.lParam          = 0;

    //
    // save current position in list
    //

    tv.item.lParam  = (LPARAM)m_CurrentPosition;

    pWiaItemTreeNode = (WIAITEMTREENODE*)pActiveTreeList->GetNext(m_CurrentPosition);
    pIWiaItem = pWiaItemTreeNode->pIWiaItem;
    ParentID = pWiaItemTreeNode->ParentID;

    if (pIWiaItem == NULL)
        return FALSE;

    CHAR szTemp[ MAX_PATH ];
    BSTR bstrFullItemName = NULL;

    //
    // get item's name and add it to the tree
    //

    hResult = pIWiaItem->QueryInterface(IID_IWiaPropertyStorage,(void **)&pIWiaPropStg);
    if (hResult == S_OK) {
        hResult = ReadPropStr(WIA_IPA_FULL_ITEM_NAME, pIWiaPropStg, &bstrFullItemName);
        if (hResult != S_OK) {
            StressStatus("* ReadPropStr(WIA_IPA_FULL_ITEM_NAME) Failed",hResult);
            bstrFullItemName = ::SysAllocString(L"Uninitialized");
        }
        pIWiaPropStg->Release();
    } else {
        StressStatus("* QueryInterface(IDD_IWiaPropertyStorage) Failed",hResult);
        return FALSE;
    }

    WideCharToMultiByte(CP_ACP,0,bstrFullItemName,-1,szTemp,MAX_PATH,NULL,NULL);
    tv.item.pszText = szTemp;

    hTree = InsertItem(&tv);

    HTREEITEM ParentLevel[50];
    ParentLevel[ParentID] = hTree;
    while (m_CurrentPosition) {
        //
        // save current position in list
        //

        tv.item.lParam  = (LPARAM)m_CurrentPosition;

        pWiaItemTreeNode = (WIAITEMTREENODE*)pActiveTreeList->GetNext(m_CurrentPosition);
        pIWiaItem = pWiaItemTreeNode->pIWiaItem;
        ParentID = pWiaItemTreeNode->ParentID;

        if (pIWiaItem == NULL)
            return FALSE;

        CHAR szTemp[ MAX_PATH ];
        BSTR bstrFullItemName = NULL;

        //
        // get item's name and add it to the tree
        //

        hResult = pIWiaItem->QueryInterface(IID_IWiaPropertyStorage,(void **)&pIWiaPropStg);
        if (hResult == S_OK) {
            hResult = ReadPropStr(WIA_IPA_FULL_ITEM_NAME, pIWiaPropStg, &bstrFullItemName);
            if (hResult != S_OK) {
                StressStatus("* ReadPropStr(WIA_IPA_FULL_ITEM_NAME) Failed",hResult);
                bstrFullItemName = ::SysAllocString(L"Uninitialized");
            }
            pIWiaPropStg->Release();
        } else {
            StressStatus("* QueryInterface(IDD_IWiaPropertyStorage) Failed",hResult);
            return FALSE;
        }

        WideCharToMultiByte(CP_ACP,0,bstrFullItemName,-1,szTemp,MAX_PATH,NULL,NULL);
        tv.item.pszText = szTemp;

        tv.hParent = ParentLevel[ParentID];

        hTree = InsertItem(&tv);

        // find out if the item is a folder, if it is,
        // ask for child items...
        long lType = 0;
        pIWiaItem->GetItemType(&lType);
        if (lType & WiaItemTypeFolder) {
            if (pIWiaItem->EnumChildItems(&pEnumItem) == S_OK) {
                ParentLevel[ParentID+1] = hTree;
            }
        }
    }
    return FALSE;
}
/**************************************************************************\
* CWIATreeCtrl::DestroyItemTree()
*
*   Destroys the display, and Active Tree list
*
*
* Arguments:
*
*   pActiveTreeList - list of IWiaItem* pointers
*
* Return Value:
*
*    none
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
void CWIATreeCtrl::DestroyItemTree(CPtrList* pActiveTreeList)
{
    if (pActiveTreeList->GetCount() == 0)
        return;

    SelectItem(GetRootItem());
    POSITION Position = pActiveTreeList->GetHeadPosition();
    IWiaItem* pIWiaItem = NULL;
    while (Position) {
        WIAITEMTREENODE* pWiaItemTreeNode = (WIAITEMTREENODE*)pActiveTreeList->GetNext(Position);
        pIWiaItem = pWiaItemTreeNode->pIWiaItem;
        pIWiaItem->Release();
    }
    pActiveTreeList->RemoveAll();
    DeleteAllItems( );
}
/**************************************************************************\
* CWIATreeCtrl::GetSelectedIWiaItem()
*
*   returns the selected IWiaItem* pointer in the tree
*
*
* Arguments:
*
*   pActiveTreeList - list of IWiaItem* pointers
*
* Return Value:
*
*    none
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
IWiaItem* CWIATreeCtrl::GetSelectedIWiaItem(CPtrList* pActiveTreeList)
{
    HTREEITEM hTreeItem = GetSelectedItem();
    if (hTreeItem != NULL) {
        //
        // we have a valid hTreeItem
        //
        POSITION Position = (POSITION)GetItemData(hTreeItem);
        if (Position) {
            //
            // we have a POSITION
            //
            IWiaItem* pIWiaItem = NULL;
            if (Position) {
                WIAITEMTREENODE* pWiaItemTreeNode = (WIAITEMTREENODE*)pActiveTreeList->GetAt(Position);
                if (pWiaItemTreeNode != NULL) {
                    pIWiaItem = pWiaItemTreeNode->pIWiaItem;
                    if (pIWiaItem != NULL) {
                        //
                        // a valid item is found
                        //
                        return pIWiaItem;
                    }
                } else
                    return NULL;
            } else
                return NULL;
        }
    } else
        MessageBox("Please select an Item","WIATest Status",MB_OK);
    return NULL;
}
/**************************************************************************\
* CWIATreeCtrl::GetRootIWiaItem()
*
*   Returns the ROOT item from the pActiveTreeList
*
*
* Arguments:
*
*   pActiveTreeList - list of IWiaItem* pointers
*
* Return Value:
*
*    none
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
IWiaItem* CWIATreeCtrl::GetRootIWiaItem(CPtrList* pActiveTreeList)
{
    HTREEITEM hTreeItem = GetRootItem();
    if (hTreeItem != NULL) {
        //
        // we have a valid hTreeItem
        //
        POSITION Position = (POSITION)GetItemData(hTreeItem);
        if (Position) {
            //
            // we have a POSITION
            //
            IWiaItem* pIWiaItem = NULL;
            if (Position) {
                WIAITEMTREENODE* pWiaItemTreeNode = (WIAITEMTREENODE*)pActiveTreeList->GetAt(Position);
                if (pWiaItemTreeNode != NULL) {
                    pIWiaItem = pWiaItemTreeNode->pIWiaItem;
                    if (pIWiaItem != NULL) {
                        //
                        // a valid item is found
                        //
                        return pIWiaItem;
                    }
                } else
                    return NULL;
            } else
                return NULL;
        }
    }
    return NULL;
}

/////////////////////////////////////////////////////////////////////////////
// CWIADeviceComboBox
/**************************************************************************\
* CWIADeviceComboBox::CWIADeviceComboBox
*
*   Constructor for the CWIADeviceComboBox class
*
*
* Arguments:
*
*   none
*
* Return Value:
*
*    none
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
CWIADeviceComboBox::CWIADeviceComboBox()
{
}
/**************************************************************************\
* CWIADeviceComboBox::~CWIADeviceComboBox()
*
*   Destructor for the CWIAPropListCtrl class
*
*
* Arguments:
*
*   none
*
* Return Value:
*
*    none
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
CWIADeviceComboBox::~CWIADeviceComboBox()
{
}
/**************************************************************************\
* CWIADeviceComboBox::AddDevice()
*
*   Add a Device ID to the Device ComboBox
*
*
* Arguments:
*
*   DeviceIndex -  position to place the Device ID in the combo box
*   DeviceName - Name of the Device
*   ServerName - Name of the server, (local or other) of the device
*   bstrDeviceID - Device ID
*
* Return Value:
*
*    none
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
void CWIADeviceComboBox::AddDeviceID(int DeviceIndex, BSTR DeviceName, BSTR ServerName,BSTR bstrDeviceID)
{
    //
    // report no WIA devices found if -1 is passed as the DeviceIndex param
    //
    if (DeviceIndex == -1)
        InsertString(0,"< No WIA Devices Found >");
    else {
        //
        // add WIA device name, and ID to combobox
        //
        InsertString(DeviceIndex,(CString)DeviceName + "  ( " + (CString)ServerName + " )");
        SetItemDataPtr(DeviceIndex,(LPVOID)bstrDeviceID);
    }
}

BEGIN_MESSAGE_MAP(CWIADeviceComboBox, CComboBox)
//{{AFX_MSG_MAP(CWIADeviceComboBox)
// NOTE - the ClassWizard will add and remove mapping macros here.
//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWIADeviceComboBox message handlers
/**************************************************************************\
* CWIADeviceComboBox::GetCurrentDeviceID()
*
*   Returns the currently selected device ID from the combo box
*
*
* Arguments:
*
*   none
*
* Return Value:
*
*    BSTR - DeviceID
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
BSTR CWIADeviceComboBox::GetCurrentDeviceID()
{
    int ComboIndex = GetCurSel();
    return(BSTR)GetItemDataPtr(ComboIndex);
}
/**************************************************************************\
* CWIADeviceComboBox::GetCurrentDeviceName()
*
*   Returns the currently selected device's Name
*
*
* Arguments:
*
*   none
*
* Return Value:
*
*    CString - device name in CString format
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
CString CWIADeviceComboBox::GetCurrentDeviceName()
{
    int ComboIndex = GetCurSel();
    return GetDeviceName(ComboIndex);
}
/**************************************************************************\
* CWIADeviceComboBox::GetDeviceName()
*
*   Returns the target device's Name
*
*
* Arguments:
*
*   Comboindex - Position in the combo box of the target device
*
* Return Value:
*
*    CString - device name in CString format
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
CString CWIADeviceComboBox::GetDeviceName(int ComboIndex)
{
    CString DeviceName;
    GetLBText(ComboIndex,DeviceName);
    return DeviceName;
}
/**************************************************************************\
* CWIADeviceComboBox::SetCurrentSelFromID()
*
*   Sets the combo selection based on the target ID
*   note: this is used for command line only
*
*
* Arguments:
*
*   CmdLine - Command Line containing Device ID
*
* Return Value:
*
*    none
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
void CWIADeviceComboBox::SetCurrentSelFromID(CString CmdLine)
{
    //
    // find the specified Device ID
    //
    int DeviceCount = GetCount();
    int ComboIndex = 0;
    BSTR bstrDeviceID;
    CString DeviceID;
    if (DeviceCount > 0) {
        for (int i = 0;i<DeviceCount;i++) {

            bstrDeviceID = (BSTR)GetItemDataPtr(i);
            DeviceID = bstrDeviceID;
            if (DeviceID == CmdLine)
                ComboIndex = i;
        }
        //
        // ComboIndex will be zero if none of
        // the DeviceIDs match
        // Zero is the first Device in the combo box
        //
        SetCurSel(ComboIndex);
    }
}

/////////////////////////////////////////////////////////////////////////////
// CWIAClipboardFormatComboBox
/**************************************************************************\
* CWIAClipboardFormatComboBox::CWIAClipboardFormatComboBox()
*
*   Constructor for the CWIAClipboardFormatComboBox class
*
* Arguments:
*
*   none
*
* Return Value:
*
*    none
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
CWIAClipboardFormatComboBox::CWIAClipboardFormatComboBox()
{
}
/**************************************************************************\
* CWIAClipboardFormatComboBox::~CWIAClipboardFormatComboBox()
*
*   Destructor for the CWIAClipboardFormatComboBox class
*
* Arguments:
*
*   none
*
* Return Value:
*
*    none
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
CWIAClipboardFormatComboBox::~CWIAClipboardFormatComboBox()
{
}

BEGIN_MESSAGE_MAP(CWIAClipboardFormatComboBox, CComboBox)
//{{AFX_MSG_MAP(CWIAClipboardFormatComboBox)
// NOTE - the ClassWizard will add and remove mapping macros here.
//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWIAClipboardFormatComboBox message handlers
/**************************************************************************\
* CWIAClipboardFormatComboBox::InitClipboardFormats()
*
*   Enumerates the supported clipboard formats, and populates the combo
*   box with these values. (filtering is based on the Tymed param)
*
* Arguments:
*
*   pWIAFormatInfo -
*   Tymed - Filter TYMED_ value
*
* Return Value:
*
*    none
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
void CWIAClipboardFormatComboBox::InitClipboardFormats(CPtrList* pSupportedFormatList,LONG Tymed)
{

    //
    // save current format
    //
    GUID CurrentClipboardFormat;

    if (pSupportedFormatList != NULL)
        CurrentClipboardFormat = GetCurrentClipboardFormat();

    int i = 0;

    //
    // nuke all entries
    //

    ResetContent( );
    if (pSupportedFormatList == NULL) {

        //
        // Add WiaImgFmt_BMP some default value
        //

        InsertString(0,TEXT("WiaImgFmt_BMP(default)"));
        SetItemDataPtr(0,(void*)&WiaImgFmt_BMP);
    } else {
        POSITION Position = pSupportedFormatList->GetHeadPosition();
        while (Position) {
            WIA_FORMAT_INFO* pfe = (WIA_FORMAT_INFO*)pSupportedFormatList->GetNext(Position);
            if (Tymed == pfe->lTymed) {
                InsertString(i,ConvertClipboardFormatToCString(pfe->guidFormatID));
                SetItemDataPtr(i,(void*)GetGUIDPtr(pfe->guidFormatID));
                i++;
            }
        }
    }
    SetClipboardFormat(CurrentClipboardFormat);
}
/**************************************************************************\
* CWIAClipboardFormatComboBox::GetCurrentClipboardFormat()
*
*   Returns the currently selected clipboard format from the combo box
*
* Arguments:
*
*   none
*
* Return Value:
*
*    USHORT - Currently selected clipboard format
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
GUID CWIAClipboardFormatComboBox::GetCurrentClipboardFormat()
{
    int ComboIndex = GetCurSel();
    return *((GUID*)GetItemDataPtr(ComboIndex));
}
/**************************************************************************\
* CWIAClipboardFormatComboBox::ConvertClipboardFormatToCString()
*
*   Converts a Clipboard format to a CString value for display only
*
* Arguments:
*
*   ClipboardFormat - Clipboardformat to convert
*
* Return Value:
*
*    CString - converted Clipboardformat in CString format
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
CString CWIAClipboardFormatComboBox::ConvertClipboardFormatToCString(GUID ClipboardFormat)
{
    if(ClipboardFormat == WiaImgFmt_UNDEFINED)
        return "WiaImgFmt_UNDEFINED";
    else if(ClipboardFormat == WiaImgFmt_MEMORYBMP)
        return "WiaImgFmt_MEMORYBMP";
    else if(ClipboardFormat == WiaImgFmt_BMP)
        return "WiaImgFmt_BMP";
    else if(ClipboardFormat == WiaImgFmt_EMF)
        return "WiaImgFmt_EMF";
    else if(ClipboardFormat == WiaImgFmt_WMF)
        return "WiaImgFmt_WMF";
    else if(ClipboardFormat == WiaImgFmt_JPEG)
        return "WiaImgFmt_JPEG";
    else if(ClipboardFormat == WiaImgFmt_PNG)
        return "WiaImgFmt_PNG";
    else if(ClipboardFormat == WiaImgFmt_GIF)
        return "WiaImgFmt_GIF";
    else if(ClipboardFormat == WiaImgFmt_TIFF)
        return "WiaImgFmt_TIFF";
    else if(ClipboardFormat == WiaImgFmt_EXIF)
        return "WiaImgFmt_EXIF";
    else if(ClipboardFormat == WiaImgFmt_PHOTOCD)
        return "WiaImgFmt_PHOTOCD";
    else if(ClipboardFormat == WiaImgFmt_FLASHPIX)
        return "WiaImgFmt_FLASHPIX";
    else
        return "** UNKNOWN **";

}
/**************************************************************************\
* CWIAClipboardFormatComboBox::GetGUIDPtr()
*
*   Converts a GUID format to a pointer to the constant
*
* Arguments:
*
*   guidIn - GUID to convert
*
* Return Value:
*
*    GUID* - pointer to a GUID constant
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
const GUID* CWIAClipboardFormatComboBox::GetGUIDPtr(GUID guidIn)
{
    if(guidIn == WiaImgFmt_UNDEFINED)
        return &WiaImgFmt_UNDEFINED;
    else if(guidIn == WiaImgFmt_MEMORYBMP)
        return &WiaImgFmt_MEMORYBMP;
    else if(guidIn == WiaImgFmt_BMP)
        return &WiaImgFmt_BMP;
    else if(guidIn == WiaImgFmt_EMF)
        return &WiaImgFmt_EMF;
    else if(guidIn == WiaImgFmt_WMF)
        return &WiaImgFmt_WMF;
    else if(guidIn == WiaImgFmt_JPEG)
        return &WiaImgFmt_JPEG;
    else if(guidIn == WiaImgFmt_PNG)
        return &WiaImgFmt_PNG;
    else if(guidIn == WiaImgFmt_GIF)
        return &WiaImgFmt_GIF;
    else if(guidIn == WiaImgFmt_TIFF)
        return &WiaImgFmt_TIFF;
    else if(guidIn == WiaImgFmt_EXIF)
        return &WiaImgFmt_EXIF;
    else if(guidIn == WiaImgFmt_PHOTOCD)
        return &WiaImgFmt_PHOTOCD;
    else if(guidIn == WiaImgFmt_FLASHPIX)
        return &WiaImgFmt_FLASHPIX;
    return (GUID*)&GUID_NULL;
}
/**************************************************************************\
* CWIAClipboardFormatComboBox::SetClipboardFormat()
*
*   Attempts to set the current clipboard format value in the combo box,
*   if it can't be found the first item is set to default (index 0)
*
* Arguments:
*
*   CF_VALUE - Clipboard format to set
*
* Return Value:
*
*    none
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
void CWIAClipboardFormatComboBox::SetClipboardFormat(GUID CF_VALUE)
{
    int NumItems = GetCount();
    int Index = 0;
    BOOL bFound = FALSE;
    if (NumItems >0) {
        while (Index < NumItems) {
            if (CF_VALUE == *(GUID*)GetItemDataPtr(Index)) {
                SetCurSel(Index);
                bFound = TRUE;
            }
            Index++;
        }
        if (!bFound)
            SetCurSel(0);
    } else
        StressStatus("* No WIA Supported Formats in format listbox");
}

/////////////////////////////////////////////////////////////////////////////
// CWIATymedComboBox
/**************************************************************************\
* CWIATymedComboBox::CWIATymedComboBox()
*
*   Constructor for the CWIATymedComboBox class
*
* Arguments:
*
*   none
*
* Return Value:
*
*    none
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
CWIATymedComboBox::CWIATymedComboBox()
{
}
/**************************************************************************\
* CWIATymedComboBox::~CWIATymedComboBox()
*
*   Destructor for the CWIATymedComboBox class
*
* Arguments:
*
*   none
*
* Return Value:
*
*    none
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
CWIATymedComboBox::~CWIATymedComboBox()
{
}

BEGIN_MESSAGE_MAP(CWIATymedComboBox, CComboBox)
//{{AFX_MSG_MAP(CWIATymedComboBox)
// NOTE - the ClassWizard will add and remove mapping macros here.
//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWIATymedComboBox message handlers

/**************************************************************************\
* CWIATymedComboBox::GetCurrentTymed()
*
*   Returns the currently selected TYMED value in the combo box
*
* Arguments:
*
*   none
*
* Return Value:
*
*    DWORD - selected TYMED value
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
DWORD CWIATymedComboBox::GetCurrentTymed()
{
    int ComboIndex = GetCurSel();
    return(DWORD)GetItemData(ComboIndex);
}
/**************************************************************************\
* CWIATymedComboBox::InitTymedComboBox()
*
*   Initialize the TymedComboBox with supported values
*
* Arguments:
*
*   none
*
* Return Value:
*
*    none
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
void CWIATymedComboBox::InitTymedComboBox()
{
    //
    // initialize the combo box with possible
    // tymed combinations
    //
    InsertString(0,"TYMED_FILE");
    SetItemData(0,TYMED_FILE);

    InsertString(1,"TYMED_CALLBACK");
    SetItemData(1,TYMED_CALLBACK);

    //
    // Set Default selection to first entry
    //
    SetCurSel(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiatest2\childfrm.cpp ===
// ChildFrm.cpp : implementation of the CChildFrame class
//

#include "stdafx.h"
#include "wiatest.h"

#include "ChildFrm.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CChildFrame

IMPLEMENT_DYNCREATE(CChildFrame, CMDIChildWnd)

BEGIN_MESSAGE_MAP(CChildFrame, CMDIChildWnd)
	//{{AFX_MSG_MAP(CChildFrame)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CChildFrame construction/destruction

CChildFrame::CChildFrame()
{
	
}

CChildFrame::~CChildFrame()
{    
        
}

BOOL CChildFrame::PreCreateWindow(CREATESTRUCT& cs)
{
	// TODO: Modify the Window class or styles here by modifying
	//  the CREATESTRUCT cs

	if( !CMDIChildWnd::PreCreateWindow(cs) )
		return FALSE;

	return TRUE;
}



/////////////////////////////////////////////////////////////////////////////
// CChildFrame diagnostics

#ifdef _DEBUG
void CChildFrame::AssertValid() const
{
	CMDIChildWnd::AssertValid();
}

void CChildFrame::Dump(CDumpContext& dc) const
{
	CMDIChildWnd::Dump(dc);
}

#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CChildFrame message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiatest\wiatestview.cpp ===
// WIATestView.cpp : implementation of the CWIATestView class
//

#include "stdafx.h"
#include "WIATest.h"

#include "WIATestDoc.h"
#include "WIATestView.h"
#include "Mainfrm.h"
#include "PropEdit.h"
#include "datacallback.h"
#include "devicecmddlg.h"
#include "iteminfodlg.h"

#include "mmsystem.h"

#ifdef _DEBUG
    #define new DEBUG_NEW
    #undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CWIATestView

IMPLEMENT_DYNCREATE(CWIATestView, CFormView)

BEGIN_MESSAGE_MAP(CWIATestView, CFormView)
//{{AFX_MSG_MAP(CWIATestView)
    ON_NOTIFY(TVN_SELCHANGED, IDC_DEVICE_ITEM_TREE, OnSelchangedDeviceItemTree)
    ON_CBN_SELCHANGE(IDC_DEVICELIST_COMBO, OnSelchangeDevicelistCombo)
    ON_NOTIFY(NM_DBLCLK, IDC_LIST_ITEMPROP, OnDblclkListItemprop)
    ON_COMMAND(ID_GETIMAGEDLG, OnGetimagedlg)
    ON_COMMAND(ID_IDTGETBANDED, OnIdtgetbanded)
    ON_COMMAND(ID_WIADATA, OnWiadata)
    ON_COMMAND(ID_ADDDEVICE, OnAdddevice)
    ON_COMMAND(ID_REFRESH, OnRefresh)
    ON_COMMAND(ID_VIEW_TRANSFER_TOOLBAR, OnViewTransferToolbar)
    ON_COMMAND(ID_EXECUTECOMMAND, OnExecutecommand)
    ON_COMMAND(ID_DUMPDRVITEM_INFO, OnDumpdrvitemInfo)
    ON_COMMAND(ID_DUMPAPPITEM_INFO, OnDumpappitemInfo)
    ON_WM_PAINT()
    ON_BN_CLICKED(IDC_PAINTMODE_CHECKBOX, OnPaintmodeCheckbox)
    ON_COMMAND(ID_RESETSTI, OnResetsti)
    ON_COMMAND(ID_FULLPREVIEW, OnFullpreview)
    ON_BN_CLICKED(IDC_THUMBNAILMODE, OnThumbnailmode)
    ON_COMMAND(ID_DELETEITEM, OnDeleteitem)
    ON_CBN_SELCHANGE(IDC_TYMED_COMBOBOX, OnSelchangeTymedCombobox)
    ON_CBN_SELCHANGE(IDC_CLIPBOARDFORMAT_COMBOBOX, OnSelchangeClipboardFormatCombobox)
    ON_UPDATE_COMMAND_UI(ID_VIEW_TRANSFER_TOOLBAR, OnUpdateViewTransferToolbar)
    ON_BN_CLICKED(IDC_PLAYAUDIO_BUTTON, OnPlayaudioButton)
    ON_COMMAND(ID_GETROOTITEMTEST, OnGetrootitemtest)
    ON_COMMAND(ID_REENUMITEMS, OnReenumitems)
    ON_COMMAND(ID_SAVEPROPSTREAM, OnSavepropstream)
    ON_COMMAND(ID_LOADPROPSTREAM, OnLoadpropstream)
    ON_COMMAND(ID_GET_SET_PROPSTREAM_TEST, OnGetSetPropstreamTest)
    ON_COMMAND(ID_ANALYZE, OnAnalyzeItem)
    ON_COMMAND(ID_CREATE_CHILD_ITEM, OnCreateChildItem)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWIATestView construction/destruction

CWIATestView::CWIATestView()
: CFormView(CWIATestView::IDD)
{
    //{{AFX_DATA_INIT(CWIATestView)
    m_FileName = _T("");
    m_GUIDDisplay = _T("");
    //}}AFX_DATA_INIT
    m_pIWiaDevMgr = NULL;
    m_pDIB = NULL;
    m_pPreviewWindow = NULL;
    m_pFullPreviewWindow = NULL;
    m_PaintMode = PAINT_TOFIT;
    m_bThumbnailMode = FALSE;
    m_pThumbNail = NULL;
    m_hBitmap = NULL;
}

/**************************************************************************\
* CWIATestView::~CWIATestView()
*
*   Destructor for WIA object:
*   Deletes WIA preview window
*   Deletes FULL preview window
*   unregisters for Events
*
*
* Arguments:
*
*   none
*
*
*
* Return Value:
*
*    status
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
CWIATestView::~CWIATestView()
{

    //
    // delete preview window pointer, if exists
    //

    if (m_pPreviewWindow != NULL)
        delete m_pPreviewWindow;

    //
    // delete FULL preview window pointer, if exists
    //

    if (m_pFullPreviewWindow != NULL) {
        m_pFullPreviewWindow->DestroyWindow();
        delete m_pFullPreviewWindow;
    }

    //
    // unregister from events
    //

    UnRegisterForAllEventsByInterface();
}

/**************************************************************************\
* CWIATestView::DoDataExchange()
*
*   Maps messages from controls to member variables
*
*
* Arguments:
*
*   pDX - CDataExchange object
*
* Return Value:
*
*   void
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
void CWIATestView::DoDataExchange(CDataExchange* pDX)
{
    CFormView::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CWIATestView)
    DDX_Control(pDX, IDC_PLAYAUDIO_BUTTON, m_PlayAudioButton);
        DDX_Control(pDX, IDC_TYMED_COMBOBOX, m_TymedComboBox);
        DDX_Control(pDX, IDC_THUMBNAIL, m_ThumbnailImage);
        DDX_Control(pDX, IDC_PREVIEW, m_PreviewFrame);
        DDX_Control(pDX, IDC_LIST_ITEMPROP, m_ItemPropertyListControl);
        DDX_Control(pDX, IDC_DEVICELIST_COMBO, m_DeviceListComboBox);
        DDX_Control(pDX, IDC_DEVICE_ITEM_TREE, m_ItemTree);
        DDX_Control(pDX, IDC_CLIPBOARDFORMAT_COMBOBOX, m_ClipboardFormatComboBox);
        DDX_Text(pDX, IDC_FILENAME_EDITBOX, m_FileName);
    //}}AFX_DATA_MAP
}
/**************************************************************************\
* CWIATestView::PreCreateWindow()
*
* Sets window creation parameters.
*
*
* Arguments:
*
*   cs - CREATESTRUCT, window construction params
*
* Return Value:
*
*   status
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
BOOL CWIATestView::PreCreateWindow(CREATESTRUCT& cs)
{
    return CFormView::PreCreateWindow(cs);
}
/**************************************************************************\
* CWIATestView::OnInitialUpdate()
*
*   Initialization routine for FORM
*
*
* Arguments:
*
*   none
*
* Return Value:
*
*   void
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
void CWIATestView::OnInitialUpdate()
{
    CFormView::OnInitialUpdate();

    //
    // Set default file name
    //

    m_AudioFileName = "test.wav";
    m_FileName = "c:\\test";
    UpdateData(FALSE);

    //
    // hide audio play button
    //

    m_PlayAudioButton.ShowWindow(SW_HIDE);

    //
    // resize mainframe to fit resource template
    //

    GetParentFrame()->RecalcLayout();
    ResizeParentToFit(FALSE);

    //
    // set transfer type radio button
    //

    CButton* pRadioButton = (CButton*)GetDlgItem(IDC_TOMEMORY);
    if (pRadioButton != NULL)
        pRadioButton->SetCheck(1);

    //
    // initialize clipboard type combo box
    //

    m_ClipboardFormatComboBox.InitClipboardFormats(NULL,NULL);

    //
    // initialize tymed combo box
    //

    m_TymedComboBox.InitTymedComboBox();

    //
    // initialize headers for Property list control
    //

    m_ItemPropertyListControl.InitHeaders();

    //
    // initialize headers for Item tree control
    //

    m_ItemTree.InitHeaders();

    if(FAILED(m_WIA.Initialize())){
        AfxMessageBox("WIA did not initialize correctly..");
        exit(0);
    }

    HRESULT hResult = S_OK;
    hResult = EnumerateWIADevices();
    if (SUCCEEDED(hResult))
         StressStatus("Device Enumeration Successful");
    else
         StressStatus("* EnumerateWIADevices() Failed",hResult);

    if (((CWIATestApp*)AfxGetApp())->GetDeviceIDCommandLine() == "") {
        if (m_WIA.GetWIADeviceCount() > 0) {

            if (!DoDefaultUIInit()) {
                StressStatus("* WIATest UI Failed attempting to do DEFAULT UI setup");
                exit(0);
            }
        } else {
            AfxMessageBox("There are no WIA devices on this system..WIATEST will now exit");
            exit(0);
        }
    } else
        if (!DoCmdLineUIInit(((CWIATestApp*)AfxGetApp())->GetDeviceIDCommandLine()))
            StressStatus("* WIATest UI Failed attempting to do CommandLine UI setup");

    if (m_pPreviewWindow == NULL) {
        m_pPreviewWindow = new CWIAPreview;
        if (m_pPreviewWindow != NULL) {
            RECT PreviewFrameRect;
            m_PreviewFrame.GetWindowRect(&PreviewFrameRect);
            ScreenToClient(&PreviewFrameRect);
            if (!m_pPreviewWindow->Create(NULL,"WIA Preview Window",WS_CHILD|WS_BORDER|WS_VSCROLL|WS_HSCROLL|WS_VISIBLE,PreviewFrameRect,this,NULL)) {
                StressStatus("Preview Window Failed to create..",0);
            } else {

                //
                // hide the place holder frame
                //

                m_PreviewFrame.ShowWindow(SW_HIDE);

                //
                // hide both scroll bars
                //

                m_pPreviewWindow->ShowScrollBar(SB_BOTH,FALSE);

                //
                // paint NULL image (white background)
                //

                DisplayImage();
            }
        }
    }

    //
    // Register for Connect / Disconnect Events
    //

    RegisterForAllEventsByInterface();

    GetDocument()->SetTitle(m_DeviceListComboBox.GetCurrentDeviceName());
    ((CMainFrame*)GetParent())->ActivateSizing(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// CWIATestView diagnostics

#ifdef _DEBUG
void CWIATestView::AssertValid() const
{
    CFormView::AssertValid();
}

void CWIATestView::Dump(CDumpContext& dc) const
{
    CFormView::Dump(dc);
}

CWIATestDoc* CWIATestView::GetDocument() // non-debug version is inline
{
    ASSERT(m_pDocument->IsKindOf(RUNTIME_CLASS(CWIATestDoc)));
    return(CWIATestDoc*)m_pDocument;
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CWIATestView message handlers

/**************************************************************************\
* CWIATestView::EnumerateWIADevices()
*
*   Enumerates all WIA devices on the system
*
*
* Arguments:
*
*   none
*
* Return Value:
*
*   status
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
HRESULT CWIATestView::EnumerateWIADevices()
{
    HRESULT hResult = S_OK;
    LONG cItemRoot = 0;
    BOOL bRet = FALSE;

    int DeviceIndex = 0;
    m_DeviceListComboBox.ResetContent();

    //
    // attempt to enumerate WIA devices
    //

    m_WIA.Auto_ResetDeviceEnumerator();
    WIADEVICENODE* pDeviceNode = NULL;

    do {
        pDeviceNode = m_WIA.Auto_GetNextDevice();
        if (pDeviceNode != NULL) {
            BSTR bstrDeviceID = ::SysAllocString(pDeviceNode->bstrDeviceID);
            BSTR bstrDeviceName = ::SysAllocString(pDeviceNode->bstrDeviceName);
            BSTR bstrServerName = ::SysAllocString(pDeviceNode->bstrServerName);

            m_DeviceListComboBox.AddDeviceID(DeviceIndex, bstrDeviceName, bstrServerName, bstrDeviceID);
            StressStatus((CString)bstrDeviceName + " Found..");

            //
            // Free BSTRs allocated
            //

            ::SysFreeString(bstrDeviceName);
            ::SysFreeString(bstrServerName);

            DeviceIndex++;
        }
    } while (pDeviceNode != NULL);

    //
    // No devices found during enumeration?
    //

    if (DeviceIndex == 0) {
        m_DeviceListComboBox.AddDeviceID(-1, NULL, NULL, NULL);
        StressStatus("* No WIA Devices Found");
    }

    //
    // set the default combo box settings
    //

    m_DeviceListComboBox.SetCurSel(0);

    return  hResult;
}
/**************************************************************************\
* CWIATestView::DoDefaultUIInit()
*
*   Handles default launch initialization of parameters
*
*
* Arguments:
*
*   none
*
* Return Value:
*
*   status
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
BOOL CWIATestView::DoDefaultUIInit()
{
    int nDeviceNum = 0;
    HRESULT hResult = S_OK;
    if (SUCCEEDED(m_WIA.CreateWIADevice(m_DeviceListComboBox.GetCurrentDeviceID()))){
        if (!m_ItemTree.BuildItemTree(m_WIA.GetItemTreeList()))
        StressStatus("* BuildItemTree Failed");
       else{
       OnSelchangeTymedCombobox();
       m_ItemPropertyListControl.DisplayItemPropData(m_WIA.GetRootIWiaItem());
       }
    }else{
        if(IsWindow(m_ItemPropertyListControl.m_hWnd))
            m_ItemPropertyListControl.DeleteAllItems();
        if(IsWindow(m_ItemTree.m_hWnd))
            m_ItemTree.DeleteAllItems();
        return FALSE;
    }
    return TRUE;
}
/**************************************************************************\
* CWIATestView::DoCmdLineUIInit()
*
*   Handles command line launch initialization
*
*
* Arguments:
*
*   CmdLine - Device ID used to set the default device
*
*
* Return Value:
*
*   status
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
BOOL CWIATestView::DoCmdLineUIInit(CString CmdLine)
{
    int nDeviceNum = 0;
    HRESULT hResult = S_OK;
    m_DeviceListComboBox.SetCurrentSelFromID(CmdLine);
    if (SUCCEEDED(m_WIA.CreateWIADevice(m_DeviceListComboBox.GetCurrentDeviceID()))) {
        if (!m_ItemTree.BuildItemTree(m_WIA.GetItemTreeList()))
            StressStatus("* BuildItemTree Failed");
        else {
            OnSelchangeTymedCombobox();
            m_ItemPropertyListControl.DisplayItemPropData(m_WIA.GetRootIWiaItem());
        }
    }else{
        m_ItemPropertyListControl.DeleteAllItems();
        m_ItemTree.DeleteAllItems();
    }
    return TRUE;
}
/**************************************************************************\
* CWIATestView::OnSelchangedDeviceItemTree()
*
*   Handles the message for changing item selection in the device Item tree
*
*
* Arguments:
*
*   pNMHDR - Notification handler
*   pResult - result after notification is handled
*
* Return Value:
*
*   void
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
void CWIATestView::OnSelchangedDeviceItemTree(NMHDR* pNMHDR, LRESULT* pResult)
{
    NM_TREEVIEW* pNMTreeView = (NM_TREEVIEW*)pNMHDR;
    IWiaItem* pIWiaItem = NULL;
    WIAITEMTREENODE* pWiaItemTreeNode = NULL;
    if (m_ItemTree.GetCount() > 1) {
        POSITION Position = (POSITION)pNMTreeView->itemNew.lParam;
        if (Position) {
#ifdef _SMARTUI
            if (m_WIA.IsRoot(Position)) {

                //
                // enable GetImageDlg button
                //

                CMainFrame* pMainFrm = (CMainFrame*)GetParent();
                if(!pMainFrm->HideToolBarButton(IDR_TRANSFER_TOOLBAR,ID_GETIMAGEDLG,FALSE))
                    StressStatus("* GetImageDlg Button failed to be unhidden..");
            } else {

                //
                // disable GetImageDlg button
                //

                CMainFrame* pMainFrm = (CMainFrame*)GetParent();
                if(!pMainFrm->HideToolBarButton(IDR_TRANSFER_TOOLBAR,ID_GETIMAGEDLG,TRUE))
                    StressStatus("* GetImageDlg Button failed to be hidden..");
            }
#endif
            pWiaItemTreeNode = m_WIA.GetAt(Position);
            if (pWiaItemTreeNode!= NULL) {
                pIWiaItem = pWiaItemTreeNode->pIWiaItem;
                if (pIWiaItem != NULL) {

                    //
                    // display Item information
                    //

                    m_ItemPropertyListControl.DisplayItemPropData(pIWiaItem,TRUE);

                    if (m_bThumbnailMode) {

                        //
                        // display item's thumbnail only if it's a child item, and
                        // only if it's a camera child item
                        //

                        if ( (m_WIA.GetRootItemType() == StiDeviceTypeDigitalCamera) ||
                             (m_WIA.GetRootItemType() == StiDeviceTypeStreamingVideo) ) {
                            if (!m_WIA.IsRoot(Position) && !m_WIA.IsFolder(Position))
                                DisplayItemThumbnail(pIWiaItem);
                        }
                    }
                    if ((m_WIA.GetRootItemType() == StiDeviceTypeDigitalCamera) ||
                        (m_WIA.GetRootItemType() == StiDeviceTypeStreamingVideo)) {
                        if (!m_WIA.IsRoot(Position) && !m_WIA.IsFolder(Position)) {
                            if (ItemHasAudio(pIWiaItem))
                                m_PlayAudioButton.ShowWindow(SW_SHOW);
                            else
                                m_PlayAudioButton.ShowWindow(SW_HIDE);
                        }
                        else
                            m_PlayAudioButton.ShowWindow(SW_HIDE);
                    }

                    OnSelchangeTymedCombobox();
                }
            }
        }
    }
    *pResult = 0;
}
/**************************************************************************\
* CWIATestView::OnSelchangeDevicelistCombo()
*
*   Handles the message for changing current devices in the device combo box
*
*
* Arguments:
*
*   none
*
* Return Value:
*
*   void
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
void CWIATestView::OnSelchangeDevicelistCombo()
{
    DoDefaultUIInit();
    GetDocument()->SetTitle(m_DeviceListComboBox.GetCurrentDeviceName());
}
/**************************************************************************\
* CWIATestView::OnDblclkListItemprop()
*
* Handles the message for double-clicking on an item in the list control
*
* Arguments:
*
*   pNMHDR - Notification handler
*   pResult - result after notification is handled
*
*
* Return Value:
*
*    status
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
void CWIATestView::OnDblclkListItemprop(NMHDR* pNMHDR, LRESULT* pResult)
{
    CPropEdit       Edit;
    CPropEditRange  EditRange;
    CPropEditList   EditList;
    CPropEditFlags  EditFlags;

    int EditType = EDIT_NONE;
    ULONG AccessFlags = 0;
    PROPVARIANT     AttrPropVar;
    PROPSPEC PropSpec;

    HRESULT             hResult = S_OK;
    IWiaPropertyStorage *pIWiaPropStg;

    int nResponse = 0;

    //
    // find out what property is selected
    //

    HD_NOTIFY*  phdn = (HD_NOTIFY *) pNMHDR;
    LV_ITEM     lvitem;
    LONG iProp = 0;
    int item = phdn->iItem;

    //
    // is it a valid item?
    //

    if (item < 0)
        return;

    //
    // set property values to null ("")
    //

    CString strProp = "";
    CString strValue = "";

    //
    // Get selected values
    //

    strProp = m_ItemPropertyListControl.GetItemText(item,0);
    strValue = m_ItemPropertyListControl.GetItemText(item,1);
    lvitem.mask     = LVIF_PARAM;
    lvitem.iItem    = item;
    lvitem.iSubItem = 0;

    m_ItemPropertyListControl.GetItem(&lvitem);

    //
    // Assign Prop ID
    //

    iProp = (LONG)lvitem.lParam;

    //
    // setup dialogs with selected values (any one could be the selected type)
    //

    Edit.SetPropertyValue(strValue);
    Edit.SetPropertyName(strProp);

    EditRange.SetPropertyValue(strValue);
    EditRange.SetPropertyName(strProp);

    EditList.SetPropertyValue(strValue);
    EditList.SetPropertyName(strProp);

    EditFlags.SetPropertyValue(strValue);
    EditFlags.SetPropertyName(strProp);

    //
    // get access flags and var type
    //

    PropSpec.ulKind = PRSPEC_PROPID;
    PropSpec.propid = iProp;

    IWiaItem* pCurrentItem = m_ItemTree.GetSelectedIWiaItem(m_WIA.GetItemTreeList());
    if (pCurrentItem != NULL && m_WIA.IsValidItem(pCurrentItem)) {
        hResult = pCurrentItem->QueryInterface(IID_IWiaPropertyStorage,(void **)&pIWiaPropStg);
        if (FAILED(hResult)) {
            StressStatus("* pCurrentItem->QueryInterface() Failed",hResult);
            return;
        } else {

            //
            // read property value for type only
            //

            PROPVARIANT     PropVar;
            hResult = pIWiaPropStg->ReadMultiple(1,&PropSpec,&PropVar);
            if (hResult == S_OK) {

                //
                // write TYPE to Dialogs
                //

                Edit.SetPropertyType(PropVar.vt);
                EditRange.SetPropertyType(PropVar.vt);
                EditList.SetPropertyType(PropVar.vt);
                EditFlags.SetPropertyType(PropVar.vt);
                EditFlags.SetPropID((USHORT)iProp);
            } else
                StressStatus("* pIWiaPropStg->ReadMultiple() Failed",hResult);
        }
        hResult = pIWiaPropStg->GetPropertyAttributes(1, &PropSpec,&AccessFlags,&AttrPropVar);
        if (FAILED(hResult)) {
            StressStatus("* pCurrentItem->GetPropertyAttributes() Failed",hResult);
            hResult = S_OK; // do this to continue property traversal
        } else {

            //
            // check access flags
            //

            if ((AccessFlags & WIA_PROP_NONE)) {
                EditType = EDIT_NONE;
            }

            else if ((AccessFlags & WIA_PROP_RANGE)) {
                EditType = EDIT_RANGE;
                if (AttrPropVar.caul.cElems == 4) {
                    if (EditRange.m_VT == VT_R4) {

                        EditRange.SetRangeValues(
                                                (float)AttrPropVar.caflt.pElems[WIA_RANGE_MIN],
                                                (float)AttrPropVar.caflt.pElems[WIA_RANGE_MAX],
                                                (float)AttrPropVar.caflt.pElems[WIA_RANGE_NOM],
                                                (float)AttrPropVar.caflt.pElems[WIA_RANGE_STEP]);
                    } else {

                        EditRange.SetRangeValues(
                                                (int)AttrPropVar.caul.pElems[WIA_RANGE_MIN],
                                                (int)AttrPropVar.caul.pElems[WIA_RANGE_MAX],
                                                (int)AttrPropVar.caul.pElems[WIA_RANGE_NOM],
                                                (int)AttrPropVar.caul.pElems[WIA_RANGE_STEP]);
                    }
                } else {

                    //
                    // elements does not equal 4
                    //

                    StressStatus("Range does not contain 4 elements");
                }
            }

            else if ((AccessFlags & WIA_PROP_LIST)) {
                UINT nElem = 0;
                EditType = EDIT_LIST;
                if(EditList.m_VT == VT_CLSID)
                    EditList.SetArray((BYTE*)AttrPropVar.cauuid.pElems, WIA_PROP_LIST_COUNT(&AttrPropVar));
                else
                    EditList.SetArray((BYTE*)AttrPropVar.caul.pElems, WIA_PROP_LIST_COUNT(&AttrPropVar));

            } else if ((AccessFlags & WIA_PROP_FLAG) == WIA_PROP_FLAG) {

                //
                // do flag dialog initialization here...
                //

                EditType = EDIT_FLAGS;
            }
        }

        //
        // determine which dialog to display
        //

        switch (EditType) {
        case EDIT_LIST:
            nResponse = (int) (INT_PTR)EditList.DoModal();
            break;
        case EDIT_RANGE:
            nResponse = (int) (INT_PTR)EditRange.DoModal();
            break;
        case EDIT_FLAGS:
            nResponse = (int) (INT_PTR)EditFlags.DoModal();
            break;
        default:
            nResponse = (int) (INT_PTR)Edit.DoModal();
            break;
        }
        if ((nResponse == IDOK) && (pCurrentItem != NULL)) {
            LONG lVal = 0;
            int iret = 0;

            if (EditType == EDIT_FLAGS) {
                hResult = WriteProp(EditFlags.m_VT, iProp, pIWiaPropStg, EditFlags.m_EditString.GetBuffer(20));
                if (hResult != S_OK)
                     StressStatus("* WriteProp Failed Writing FLAG values",hResult);
            } else if (EditType == EDIT_LIST) {
                hResult = WriteProp(EditList.m_VT, iProp, pIWiaPropStg, EditList.m_EditString.GetBuffer(20));
                if (hResult != S_OK)
                     StressStatus("* WriteProp Failed Writing LIST values",hResult);
            } else if (EditType == EDIT_RANGE) {
                hResult = WriteProp(EditRange.m_VT, iProp, pIWiaPropStg, EditRange.m_EditString.GetBuffer(20));
                if (hResult != S_OK)
                     StressStatus("* WriteProp Failed Writing RANGE values",hResult);
            } else {
                hResult = WriteProp(Edit.m_VT, iProp, pIWiaPropStg, Edit.m_EditString.GetBuffer(20));
                if (hResult != S_OK)
                     StressStatus("* WriteProp Failed Writing values",hResult);
            }

            //
            // release IPropStg and IWiaItem
            //

            pIWiaPropStg->Release();
            OnRefresh();
        }
    }
    *pResult = 0;
}

/**************************************************************************\
* CWIATestView::OnGetimagedlg()
*
*   Executes the GetImageDlg() call setting the intent
*
*
* Arguments:
*
*   none
*
* Return Value:
*
*   void
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
void CWIATestView::OnGetimagedlg()
{
    UpdateData(TRUE);
    m_WIA.SetFileName(m_FileName);
    HRESULT hResult = S_OK;
    hResult = m_WIA.DoGetImageDlg(m_hWnd, 0,0,WIA_INTENT_IMAGE_TYPE_GRAYSCALE|WIA_INTENT_MINIMIZE_SIZE,m_TymedComboBox.GetCurrentTymed(),m_ClipboardFormatComboBox.GetCurrentClipboardFormat());
    DisplayImage();
}
/**************************************************************************\
* CWIATestView::OnIdtgetbanded
*
*   Initiates a banded transfer using the currently selected item
*
*
* Arguments:
*
*   none
*
* Return Value:
*
*   void
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
void CWIATestView::OnIdtgetbanded()
{
    UpdateData(TRUE);
    m_WIA.SetFileName(m_FileName);
    HRESULT hResult = S_OK;
    IWiaItem* pIWiaItem = m_ItemTree.GetSelectedIWiaItem(m_WIA.GetItemTreeList());
    if (pIWiaItem != NULL){
        m_WIA.SetPreviewWindow(m_pPreviewWindow->m_hWnd);
        hResult = m_WIA.DoIWiaDataBandedTransfer(pIWiaItem,m_TymedComboBox.GetCurrentTymed(),m_ClipboardFormatComboBox.GetCurrentClipboardFormat());
        DisplayImage();
    }
}
/**************************************************************************\
* CWIATestView::
*
*   Initiates a IWiaDataTransfer, using the currently selected item
*
*
* Arguments:
*
*   none
*
* Return Value:
*
*   void
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
void CWIATestView::OnWiadata()
{
    UpdateData(TRUE);
    m_WIA.SetFileName(m_FileName);
    HRESULT hResult = S_OK;
    IWiaItem* pIWiaItem = m_ItemTree.GetSelectedIWiaItem(m_WIA.GetItemTreeList());
    if (pIWiaItem != NULL && m_WIA.IsValidItem(pIWiaItem)){
        hResult = m_WIA.DoIWiaDataGetDataTransfer(pIWiaItem,m_TymedComboBox.GetCurrentTymed(),m_ClipboardFormatComboBox.GetCurrentClipboardFormat());
        DisplayImage();
    }
}
/**************************************************************************\
* CWIATestView::OnAdddevice()
*
*   Creates a thread to add a device to the Device list combo box
*
*
* Arguments:
*
*   none
*
* Return Value:
*
*   void
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
void CWIATestView::OnAdddevice()
{
    static HANDLE   hAddDeviceThread;
    static DWORD    dwAddDeviceThreadId;
    hAddDeviceThread = CreateThread(NULL,0, &AddDeviceThread,0,0,&dwAddDeviceThreadId);
    if (!hAddDeviceThread)
        StressStatus("* CreateThread failed");
}
/**************************************************************************\
* CWIATestView::OnRefresh()
*
*   Forces a refresh of the selected items property data
*
*
* Arguments:
*
*   none
*
* Return Value:
*
*   void
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
void CWIATestView::OnRefresh()
{
    IWiaItem* pIWiaItem = m_ItemTree.GetSelectedIWiaItem(m_WIA.GetItemTreeList());
    if (pIWiaItem != NULL && m_WIA.IsValidItem(pIWiaItem))
        m_ItemPropertyListControl.DisplayItemPropData(pIWiaItem);
}

/**************************************************************************\
* AddDeviceThread
*
*   This is a thread that controls adding a device to the device combo box
*
*
* Arguments:
*
*   pParam - not used at this time (extra information)
*
* Return Value:
*
*    status
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
ULONG _stdcall AddDeviceThread(LPVOID pParam)
{
    HRESULT hResult = S_OK;
    CWIATestApp* pApp = (CWIATestApp*)AfxGetApp();
    CMainFrame* pFrame = (CMainFrame*)pApp->GetMainWnd();
    CWIATestView* pView = (CWIATestView*)pFrame->GetActiveView();
    IWiaItem* pIWiaItem = NULL;
    IWiaDevMgr* pIWiaDevMgr = NULL;

    //
    // initlialize OLE libs
    //

    hResult = ::OleInitialize(NULL);
    if (hResult != S_OK)
        StressStatus("* OleInitialize failed!");

    //
    // if OleInitialize is successful call CoCreateInstance for IWiaDevMgr
    //

    if (hResult == S_OK) {

        //
        // initialize IWiaDevMgr
        //

        hResult = CoCreateInstance(CLSID_WiaDevMgr, NULL, CLSCTX_LOCAL_SERVER,
                                   IID_IWiaDevMgr,(void**)&pIWiaDevMgr);
        if (hResult != S_OK)
            StressStatus("* CoCreateInstance failed - pIWiaDevMgr not created");
        else {
            StressStatus("CoCreateInstance Successful - pIWiaDevMgr created");

            hResult = pIWiaDevMgr->AddDeviceDlg(pFrame->m_hWnd,0);
            if (SUCCEEDED(hResult)){

                //
                // refresh device list
                //

                pView->RefreshDeviceList();
                pView->EnumerateWIADevices();

                //
                // set the default combo box settings
                //

                pView->m_DeviceListComboBox.SetCurSel(0);
            }
            else
                StressStatus("* No Device added ");

            pIWiaDevMgr->Release();
        }
    }
    ::OleUninitialize();
    return 0;
}
/**************************************************************************\
* CWIATestView::OnViewTransferToolbar()
*
*   Enables/Disables the Transfer toolbar
*
*
* Arguments:
*
*   none
*
* Return Value:
*
*   void
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
void CWIATestView::OnViewTransferToolbar()
{
    CMainFrame* pMainFrame = (CMainFrame*)GetParent();
    if (pMainFrame != NULL) {
        if (pMainFrame->IsToolBarVisible(IDR_TRANSFER_TOOLBAR)) {

            //
            // hide toolbar
            //

            pMainFrame->ShowToolBar(IDR_TRANSFER_TOOLBAR,FALSE);
        } else {

            //
            // show toolbar
            //

            pMainFrame->ShowToolBar(IDR_TRANSFER_TOOLBAR,TRUE);
        }
    }
}

/**************************************************************************\
* CWIATestView::DisplayImage
*
*   paints the current DIB to the preview area
*
*
* Arguments:
*
*   none
*
* Return Value:
*
*    void
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
void CWIATestView::DisplayImage()
{
    m_pDIB = m_WIA.GetDIB();
    m_pPreviewWindow->SetPaintMode(m_PaintMode);
    m_pPreviewWindow->SetDIB(m_pDIB);
    m_pPreviewWindow->Invalidate();

    if (m_pFullPreviewWindow != NULL) {
        if (m_pFullPreviewWindow->m_hWnd != NULL) {
            m_pFullPreviewWindow->SetPaintMode(PAINT_ACTUAL);
            m_pFullPreviewWindow->SetDIB(m_pDIB);
            m_pFullPreviewWindow->CleanBackground();
            m_pFullPreviewWindow->Invalidate();
        }
    }
}
/**************************************************************************\
* CWIATestView::OnExecutecommand()
*
*   Calls the DeviceCommand dialog, to execute device commands
*
*
* Arguments:
*
*   none
*
* Return Value:
*
*   void
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
void CWIATestView::OnExecutecommand()
{
    IWiaItem* pIWiaItem = m_ItemTree.GetSelectedIWiaItem(m_WIA.GetItemTreeList());
    if (pIWiaItem != NULL && m_WIA.IsValidItem(pIWiaItem)) {
        CDeviceCmdDlg DeviceCommandDlg;
        DeviceCommandDlg.Initialize(pIWiaItem);
        DeviceCommandDlg.DoModal();
        OnSelchangeDevicelistCombo();
    }
}
/**************************************************************************\
* CWIATestView::RegisterForAllEventsByInterface()
*
*   Register this application for CONNECT/DISCONNECT events
*
*
* Arguments:
*
*   none
*
* Return Value:
*
*   void
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
void CWIATestView::RegisterForAllEventsByInterface()
{
    //
    // register connected event
    //

    m_pConnectEventCB = new CEventCallback;
    m_pDisConnectEventCB = new CEventCallback;
    m_WIA.RegisterForConnectEvents(m_pConnectEventCB);
    m_WIA.RegisterForDisConnectEvents(m_pDisConnectEventCB);
}
/**************************************************************************\
* CWIATestView::UnRegisterForAllEventsByInterface()
*
*   Unregister this application from CONNECT/DISCONNECT events
*
*
* Arguments:
*
*   none
*
* Return Value:
*
*   void
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
void CWIATestView::UnRegisterForAllEventsByInterface()
{
    m_WIA.UnRegisterForConnectEvents(m_pConnectEventCB);
    m_WIA.UnRegisterForDisConnectEvents(m_pDisConnectEventCB);
}
/**************************************************************************\
* CWIATestView::UpdateUI()
*
*   Updates the UI by posting a selection change message on the Device list
*   combo box.
*   note: this is called externally, after a CONNECT/DISCONNECT event is trapped
*
*
* Arguments:
*
*
* Return Value:
*
*   void
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
void CWIATestView::UpdateUI()
{
    OnSelchangeDevicelistCombo();
}
/**************************************************************************\
* CWIATestView::OnDumpdrvitemInfo()
*
*   Dump Driver item information for DEBUGGING ONLY
*
*
* Arguments:
*
*   none
*
* Return Value:
*
*   void
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
void CWIATestView::OnDumpdrvitemInfo()
{
    IWiaItem* pIWiaItem = m_ItemTree.GetSelectedIWiaItem(m_WIA.GetItemTreeList());
    if (pIWiaItem != NULL && m_WIA.IsValidItem(pIWiaItem)) {
        CItemInfoDlg ItemInfoDlg;
        ItemInfoDlg.Initialize(pIWiaItem,FALSE);
        ItemInfoDlg.DoModal();
    }
}
/**************************************************************************\
* CWIATestView::OnDumpappitemInfo()
*
*   Dump Application item information for DEBUGGING ONLY
*
*
* Arguments:
*
*   none
*
* Return Value:
*
*   void
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
void CWIATestView::OnDumpappitemInfo()
{
    IWiaItem* pIWiaItem = m_ItemTree.GetSelectedIWiaItem(m_WIA.GetItemTreeList());
    if (pIWiaItem != NULL && m_WIA.IsValidItem(pIWiaItem)) {
        CItemInfoDlg ItemInfoDlg;
        ItemInfoDlg.Initialize(pIWiaItem,TRUE);
        ItemInfoDlg.DoModal();
    }
}
/**************************************************************************\
* CWIATestView::OnPaint()
*
*   Handles the painting of the application window
*
*
* Arguments:
*
*   none
*
* Return Value:
*
*   void
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
void CWIATestView::OnPaint()
{
    CPaintDC dc(this); // device context for painting
}
/**************************************************************************\
* CWIATestView::OnPaintmodeCheckbox()
*
*   Enables/Disables 1 to 1 painting setting for the preview window
*
*
* Arguments:
*
*   none
*
* Return Value:
*
*   void
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
void CWIATestView::OnPaintmodeCheckbox()
{
    if (m_PaintMode == PAINT_TOFIT)
        m_PaintMode = PAINT_ACTUAL;
    else
        m_PaintMode = PAINT_TOFIT;
    DisplayImage();
}
/**************************************************************************\
* CWIATestView::OnResetsti()
*
*   Force STI to reset the current selected device.
*
*
* Arguments:
*
*   none
*
* Return Value:
*
*   void
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
void CWIATestView::OnResetsti()
{
    //
    // UnRegister from Connect / Disconnect Events
    //

    UnRegisterForAllEventsByInterface();

    //
    // cleanup all WIA devices
    //

    m_WIA.Shutdown();

    PSTI pSti;
    IStiDevice  *pIStiDevice;
    HRESULT     hResult = S_OK;

    hResult = StiCreateInstance(GetModuleHandle(NULL), STI_VERSION, &pSti, NULL);
    if (hResult != S_OK)
        StressStatus("* StiCreateInstance() Failed",hResult);
    else {
        hResult = pSti->CreateDevice(m_DeviceListComboBox.GetCurrentDeviceID(), STI_DEVICE_CREATE_STATUS, &pIStiDevice, NULL);
        if (hResult != S_OK)
            StressStatus("* pSti->CreateDevice() Failed",hResult);
        else {
            hResult = pIStiDevice->LockDevice(2000);
            if (hResult != S_OK)
                StressStatus("* pIStiDevice->LockDevice(2000) Failed",hResult);
            else {
                StressStatus("STI device is locked");
                pIStiDevice->DeviceReset();
                StressStatus("STI device is reset");
                pIStiDevice->UnLockDevice();
                StressStatus("STI device is unlocked");
                pIStiDevice->Release();
                pSti->Release();
            }
        }
    }

    m_WIA.Restart();

    //
    // Reform UI
    //

    DoDefaultUIInit();

    //
    // Register for Connect / Disconnect Events
    //

    RegisterForAllEventsByInterface();
}
/**************************************************************************\
* CWIATestView::OnFullpreview()
*
*   Initiate a full preview window (scrolling enabled for larger pictures)
*
*
* Arguments:
*
*   none
*
* Return Value:
*
*   void
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
void CWIATestView::OnFullpreview()
{
    if (m_pFullPreviewWindow == NULL) {
        m_pFullPreviewWindow = new CWIAPreview;
        if (m_pFullPreviewWindow != NULL) {
            RECT PreviewFrameRect;
            PreviewFrameRect.left = 0;
            PreviewFrameRect.top = 0;
            PreviewFrameRect.right = 400;
            PreviewFrameRect.bottom = 400;
            if (!m_pFullPreviewWindow->CreateEx(NULL,AfxRegisterWndClass(NULL),"WIA Preview Window",WS_OVERLAPPEDWINDOW|WS_VSCROLL|WS_HSCROLL|WS_VISIBLE,PreviewFrameRect,NULL,NULL,NULL)) {
                StressStatus("FULL Preview Window Failed to create..",0);
            } else {

                //
                // paint NULL image (white background)
                //

                DisplayImage();
            }
        }
    } else {
        if (m_pFullPreviewWindow->m_hWnd == NULL) {
            RECT PreviewFrameRect;
            PreviewFrameRect.left = 0;
            PreviewFrameRect.top = 0;
            PreviewFrameRect.right = 400;
            PreviewFrameRect.bottom = 400;
            if (!m_pFullPreviewWindow->CreateEx(NULL,AfxRegisterWndClass(NULL),"WIA Preview Window",WS_OVERLAPPEDWINDOW|WS_VSCROLL|WS_HSCROLL|WS_VISIBLE,PreviewFrameRect,NULL,NULL,NULL)) {
                StressStatus("FULL Preview Window Failed to create..",0);
            } else {

                //
                // paint NULL image (white background)
                //

                DisplayImage();
            }
        }
        m_pFullPreviewWindow->ShowWindow(SW_SHOW);
    }
}
/**************************************************************************\
* CWIATestView::ResizeControls()
*
*   Resize the controls along with the main frame window
*
*
* Arguments:
*
*   dx - change in width of main window
*   dy - change in height on main window
*
*
* Return Value:
*
*   void
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
void CWIATestView::ResizeControls(int dx, int dy)
{
    m_ItemPropertyListControl.Resize(dx,dy);
}
/**************************************************************************\
* CWIATestView::OnThumbnailmode()
*
*   Enables/Disables thumbnailing for picture items on digitial cameras
*
*
* Arguments:
*
*   none
*
* Return Value:
*
*   void
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
void CWIATestView::OnThumbnailmode()
{
    POSITION Position = NULL;
    HTREEITEM hTreeItem = NULL;
    if (m_bThumbnailMode)
        m_bThumbnailMode = FALSE;
    else {
        IWiaItem* pIWiaItem = m_ItemTree.GetSelectedIWiaItem(m_WIA.GetItemTreeList());
        if (pIWiaItem != NULL && m_WIA.IsValidItem(pIWiaItem)) {
            if ((m_WIA.GetRootItemType() == StiDeviceTypeDigitalCamera) ||
                (m_WIA.GetRootItemType() == StiDeviceTypeStreamingVideo)) {
                hTreeItem = m_ItemTree.GetSelectedItem();
                if (hTreeItem != NULL) {
                    Position = (POSITION)m_ItemTree.GetItemData(hTreeItem);
                    if (!m_WIA.IsRoot(Position) && !m_WIA.IsFolder(Position))
                        DisplayItemThumbnail(pIWiaItem);
                }
            }
        }
        m_bThumbnailMode = TRUE;
    }
}
/**************************************************************************\
* CWIATestView::DisplayItemThumbnail()
*
*   Display thumbnail for the target item
*
*
* Arguments:
*
*   pIWiaItem - Target item to thumbnail
*
* Return Value:
*
*   void
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
void CWIATestView::DisplayItemThumbnail(IWiaItem *pIWiaItem)
{
    long ThumbNailHeight = 0;
    long ThumbNailWidth = 0;
    long ThumbNailSize = 0;

    if (m_pThumbNail != NULL) {
        LocalFree(m_pThumbNail);
        m_pThumbNail = NULL;
    }

    if (m_hBitmap != NULL) {
        DeleteObject(m_hBitmap);
        m_hBitmap = NULL;
    }

    m_pThumbNail = NULL;
    IWiaPropertyStorage *pIWiaPropStg;
    HRESULT hResult = S_OK;
    HBITMAP hBitmap = NULL;

    // get item's thumbnail height & width and create thumbnail
    hResult = pIWiaItem->QueryInterface(IID_IWiaPropertyStorage,(void **)&pIWiaPropStg);
    if (hResult == S_OK) {

        //
        // read height
        //

        hResult = ReadPropLong(WIA_IPC_THUMB_HEIGHT, pIWiaPropStg, &ThumbNailHeight);
        if (hResult != S_OK) {
            StressStatus("* ReadPropLong(WIA_IPC_THUMB_HEIGHT) Failed",hResult);
            ThumbNailHeight = 0;
        }

        //
        // read width
        //

        hResult = ReadPropLong(WIA_IPC_THUMB_WIDTH, pIWiaPropStg, &ThumbNailWidth);
        if (hResult != S_OK) {
            StressStatus("* ReadPropLong(WIA_IPC_THUMB_WIDTH) Failed",hResult);
            ThumbNailWidth = 0;
        }

        //
        // read thumbnail data
        //

        PROPVARIANT  PropVar[1];
        PROPSPEC PropSpec[1];
        memset(PropVar, 0, sizeof(PropVar));
        PropSpec[0].ulKind = PRSPEC_PROPID;
        PropSpec[0].propid = WIA_IPC_THUMBNAIL;

        hResult = pIWiaPropStg->ReadMultiple(1, PropSpec, PropVar);
        if (hResult != S_OK) {
            StressStatus("* ReadMultiple()  asking for WIA_IPC_THUMBNAIL Failed",hResult);
            m_pThumbNail = NULL;
        } else {
            ThumbNailSize   = ThumbNailWidth * ThumbNailHeight * 3;
            if (ThumbNailSize != (LONG)PropVar[0].caub.cElems) {

                //
                // force size to thumbnail's suggested size
                //

                ThumbNailSize = PropVar[0].caub.cElems;
            }
            m_pThumbNail = (PBYTE)LocalAlloc(LPTR,ThumbNailSize);
            if (m_pThumbNail != NULL) {
                memcpy(m_pThumbNail,PropVar[0].caub.pElems,ThumbNailSize);

                HDC hdc = ::GetDC(NULL);
                HDC hdcm = CreateCompatibleDC(hdc);

                BITMAPINFO bmi;
                bmi.bmiHeader.biSize            = sizeof(BITMAPINFOHEADER);
                bmi.bmiHeader.biWidth           = ThumbNailWidth;
                bmi.bmiHeader.biHeight          = ThumbNailHeight;
                bmi.bmiHeader.biPlanes          = 1;
                bmi.bmiHeader.biBitCount        = 24;
                bmi.bmiHeader.biCompression     = BI_RGB;
                bmi.bmiHeader.biSizeImage       = 0;
                bmi.bmiHeader.biXPelsPerMeter   = 0;
                bmi.bmiHeader.biYPelsPerMeter   = 0;
                bmi.bmiHeader.biClrUsed         = 0;
                bmi.bmiHeader.biClrImportant    = 0;

                PBYTE pDib = NULL;
                m_hBitmap = CreateDIBSection(hdc,&bmi,DIB_RGB_COLORS,(void **)&pDib,NULL,0);
                memcpy(pDib,m_pThumbNail,ThumbNailSize);
                m_ThumbnailImage.SetBitmap(m_hBitmap);
                m_ThumbnailImage.Invalidate();
            }
        }

        //
        // release propstg
        //

        pIWiaPropStg->Release();
    }
}
/**************************************************************************\
* CWIATestView::OnDeleteitem()
*
*   Deletes the selected item
*
*
* Arguments:
*
*   none
*
* Return Value:
*
*   void
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
void CWIATestView::OnDeleteitem()
{
    HRESULT hResult = S_OK;
    POSITION TestPosition = NULL;
    POSITION Position = NULL;
    HTREEITEM hTreeItem = NULL;
    IWiaItem* pIWiaItem = m_ItemTree.GetSelectedIWiaItem(m_WIA.GetItemTreeList());
    if (pIWiaItem == NULL) {
        StressStatus("* Item selected for deletion is NULL!!!");
        return;
    }
    if ((m_WIA.GetRootItemType() == StiDeviceTypeDigitalCamera) ||
        (m_WIA.GetRootItemType() == StiDeviceTypeStreamingVideo)) {

        //
        // Get selected item (to be deleted)
        //

        hTreeItem = m_ItemTree.GetSelectedItem();
        if (hTreeItem != NULL) {

            //
            // What's the selected item's position in the
            // m_ActiveTreeList??
            //

            Position = (POSITION)m_ItemTree.GetItemData(hTreeItem);
        }

        //
        // test to make sure it's not a root item
        //

        if (!m_WIA.IsRoot(Position)) {

            if (pIWiaItem != NULL) {
                hResult = pIWiaItem->DeleteItem(0);
                if (hResult == S_OK) {

                    //
                    // release selected item
                    //

                    pIWiaItem->Release();

                    //
                    // kill item from m_ActiveTreeList
                    //

                    m_WIA.RemoveAt(Position);

                    //
                    // kill item from tree control (visual delete)
                    //

                    m_ItemTree.DeleteItem(hTreeItem);
                }
            }
        } else
            AfxMessageBox("You can not delete the Root Item");
    } else {

        //
        // Get selected item (to be deleted)
        //

        hTreeItem = m_ItemTree.GetSelectedItem();
        if (hTreeItem != NULL) {

            //
            // What's the selected item's position in the
            // m_ActiveTreeList??
            //

            Position = (POSITION)m_ItemTree.GetItemData(hTreeItem);
        }

        //
        // test to make sure it's not a root item
        //

        if (!m_WIA.IsRoot(Position)) {

            if (pIWiaItem != NULL) {
                if (MessageBox("You just attempted to delete a scanner item..\nDo you really want to execute a DeleteItem()\ncall on this scanner item to see what happens?","WIATest Testing Question",MB_YESNO|MB_ICONQUESTION) == IDYES) {
                    hResult = pIWiaItem->DeleteItem(0);
                    if (hResult == S_OK) {
                        OnReenumitems();
                    } else
                        StressStatus("* pIWiaItem->DeleteItem() called on a scanner item Failed",hResult);
                }
            }
        } else
            AfxMessageBox("You can not delete the Root Item");

    }
}
/**************************************************************************\
* CWIATestView::OnSelchangeTymedCombobox()
*
*   Handles the message for a selection change in the TYMED combo box
*
*
* Arguments:
*
*   none
*
* Return Value:
*
*   void
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
void CWIATestView::OnSelchangeTymedCombobox()
{
    if (m_TymedComboBox.GetCurrentTymed() != TYMED_FILE) {

        //
        // disable File Edit box
        //

        CWnd* pWnd = GetDlgItem(IDC_FILENAME_EDITBOX);
        if (pWnd != NULL)
            pWnd->EnableWindow(FALSE);
    } else {

        //
        // enable  File Edit box
        //

        CWnd* pWnd = GetDlgItem(IDC_FILENAME_EDITBOX);
        if (pWnd != NULL)
            pWnd->EnableWindow(TRUE);
    }

#ifdef _SMARTUI
    if (m_TymedComboBox.GetCurrentTymed() == TYMED_CALLBACK) {

        //
        // hide IWiaData Toolbar button and
        // unhide idtGetBanded Toolbar button
        //

        CMainFrame* pMainFrm = (CMainFrame*)GetParent();
        if(!pMainFrm->HideToolBarButton(IDR_TRANSFER_TOOLBAR,ID_IDTGETBANDED,FALSE))
            StressStatus("* idtGetBanded Button failed to be unhidden..");

        if(!pMainFrm->HideToolBarButton(IDR_TRANSFER_TOOLBAR,ID_WIADATA,TRUE))
            StressStatus("* IWiaData Button failed to be hidden..");

    } else {

        //
        // hide idtGetBanded Toolbar button and
        // unhide IWiaData Toolbar button
        //

        CMainFrame* pMainFrm = (CMainFrame*)GetParent();
        if(!pMainFrm->HideToolBarButton(IDR_TRANSFER_TOOLBAR,ID_IDTGETBANDED,TRUE))
            StressStatus("* idtGetBanded Button failed to be hidden..");

        if(!pMainFrm->HideToolBarButton(IDR_TRANSFER_TOOLBAR,ID_WIADATA,FALSE))
            StressStatus("* IWiaData Button failed to be unhidden..");
    }

#endif

    IWiaItem* pIWiaItem = m_ItemTree.GetSelectedIWiaItem(m_WIA.GetItemTreeList());

    if (pIWiaItem != NULL) {
        m_WIA.EnumerateSupportedFormats(pIWiaItem);
        m_ClipboardFormatComboBox.InitClipboardFormats(m_WIA.GetSupportedFormatList(),m_TymedComboBox.GetCurrentTymed());
    }
    //
    // Force update and change..
    //

    OnSelchangeClipboardFormatCombobox();
}
/**************************************************************************\
* CWIATestView::OnSelchangeClipboardFormatCombobox()
*
*   Handles the message for a selection change in the clipboard format combo box
*
*
* Arguments:
*
*   -
*   -
*   -
*
* Return Value:
*
*    status
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
void CWIATestView::OnSelchangeClipboardFormatCombobox()
{
    HRESULT hResult = S_OK;
    POSITION Position = NULL;
    HTREEITEM hTreeItem = NULL;
    IWiaPropertyStorage *pIWiaPropStg;
    IWiaItem* pIWiaItem = m_ItemTree.GetSelectedIWiaItem(m_WIA.GetItemTreeList());
    if (pIWiaItem == NULL) {
        StressStatus("* Item selected for setting is NULL!!!");
        return;
    }

    //
    // Get selected item
    //

    hTreeItem = m_ItemTree.GetSelectedItem();
    if (hTreeItem != NULL) {

        //
        // What's the selected item's position in the
        // m_ActiveTreeList??
        //

        Position = (POSITION)m_ItemTree.GetItemData(hTreeItem);
    }

    //
    // test to make sure it's not a root item
    //

    if (!m_WIA.IsRoot(Position)) {
        hResult = pIWiaItem->QueryInterface(IID_IWiaPropertyStorage,(void **)&pIWiaPropStg);
        if (hResult != S_OK) {
            StressStatus("* pCurrentItem->QueryInterface() Failed",hResult);
            return;
        } else {

            //
            // Write property value for TYMED
            //

            hResult = WritePropLong(WIA_IPA_TYMED,pIWiaPropStg,m_TymedComboBox.GetCurrentTymed());
            if (hResult == S_OK)
                StressStatus("tymed Successfully written");
            else
                StressStatus("* WritePropLong(WIA_IPA_TYMED) Failed",hResult);

            //
            // Write property value for SUPPORTED WIA FORMAT
            //

            hResult = WritePropGUID(WIA_IPA_FORMAT,pIWiaPropStg,m_ClipboardFormatComboBox.GetCurrentClipboardFormat());
            if (hResult == S_OK)
                StressStatus("Format Successfully written");
            else
                StressStatus("* WritePropLong(WIA_IPA_FORMAT) Failed",hResult);

            OnRefresh();
        }
    }
}
/**************************************************************************\
* CWIATestView::OnUpdateViewTransferToolbar()
*
*   Updates the Check/uncheck display on the menu for toolbar display status
*
*
* Arguments:
*
*   pCmdUI - CommandUI handler
*
* Return Value:
*
*    status
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
void CWIATestView::OnUpdateViewTransferToolbar(CCmdUI* pCmdUI)
{
    CMainFrame* pMainFrm = (CMainFrame*)GetParent();
    if(pMainFrm != NULL)
        pCmdUI->SetCheck(pMainFrm->IsToolBarVisible(IDR_TRANSFER_TOOLBAR));
}
/**************************************************************************\
* CWIATestView::OnPlayaudioButton()
*
*   Plays .WAV data from an item that supports audio
*
*
* Arguments:
*
*   none
*
* Return Value:
*
*   void
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
void CWIATestView::OnPlayaudioButton()
{
    IWiaItem* pIWiaItem = m_ItemTree.GetSelectedIWiaItem(m_WIA.GetItemTreeList());
    if(pIWiaItem != NULL){
        IWiaPropertyStorage *pIWiaPropStg;
        PROPSPEC PropSpec[1];
        PROPVARIANT       PropVar[1];
        PropSpec[0].ulKind = PRSPEC_PROPID;
        PropSpec[0].propid = WIA_IPC_AUDIO_DATA;
        memset(PropVar, 0, sizeof(PropVar));

        HRESULT hResult = S_OK;
        hResult = pIWiaItem->QueryInterface(IID_IWiaPropertyStorage,(void **)&pIWiaPropStg);
        if (hResult == S_OK) {
            hResult = pIWiaPropStg->ReadMultiple(1, PropSpec, PropVar);
            if(hResult == S_OK){
                DWORD dwAudioSize = PropVar->caub.cElems;
                BYTE* pAudioData = PropVar->caub.pElems;
                if(pAudioData != NULL){
                    CFile AudioFile;

                    //
                    // open & write audio file
                    //

                    AudioFile.Open(m_AudioFileName,CFile::modeCreate|CFile::modeWrite,NULL);
                    AudioFile.Write(pAudioData,dwAudioSize);
                    AudioFile.Close();
                    PlaySound(m_AudioFileName,NULL,SND_FILENAME);
                    DeleteFile(m_AudioFileName);
                }
            }
            else
                StressStatus("* ReadMultiple(WIA_IPC_AUDIO_DATA) Failed",hResult);
        }
    }
}
/**************************************************************************\
* CWIATestView::ItemHasAudio()
*
*   Determines if an item supports audio data, or contains data to be accessed.
*
*
* Arguments:
*
*   pIWiaData - Target item to check for audio data
*
* Return Value:
*
*    status
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
BOOL CWIATestView::ItemHasAudio(IWiaItem* pIWiaItem)
{
    long lVal = 0;
    if (pIWiaItem != NULL) {
        IWiaPropertyStorage *pIWiaPropStg;
        HRESULT hResult = S_OK;
        hResult = pIWiaItem->QueryInterface(IID_IWiaPropertyStorage,(void **)&pIWiaPropStg);
        if (hResult == S_OK) {

            //
            // read Item's Audio flag
            //

            hResult = ReadPropLong(WIA_IPC_AUDIO_AVAILABLE, pIWiaPropStg, &lVal);
            if (hResult != S_OK){
                if(hResult != S_FALSE){
                    StressStatus("* ReadPropLong(WIA_IPC_AUDIO_AVAILABLE) Failed",hResult);
                }
                pIWiaPropStg->Release();
            }

            else
                pIWiaPropStg->Release();
            if(lVal)
                return TRUE;
            else
                return FALSE;
        }
    }
return FALSE;
}
/**************************************************************************\
* CWIATestView::RefreshDeviceList()
*
*   Called externally to force a reenumeration of WIA devices on the system
*
*
* Arguments:
*
*   none
*
* Return Value:
*
*   void
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
void CWIATestView::RefreshDeviceList()
{
    m_WIA.EnumerateAllWIADevices();
}
/**************************************************************************\
* CWIATestView::OnGetrootitemtest()
*
*   Gets the selected item, and gets the root item from it.
*   Driver and application item information are dumped.
*   DEBUGGING ONLY
*
* Arguments:
*
*   none
*
* Return Value:
*
*   void
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
void CWIATestView::OnGetrootitemtest()
{
    HRESULT hr = S_OK;
    IWiaItem* pIWiaItem = NULL;
    IWiaItem* pNewRootItem = NULL;
    pIWiaItem = m_ItemTree.GetSelectedIWiaItem(m_WIA.GetItemTreeList());
    if(pIWiaItem != NULL && m_WIA.IsValidItem(pIWiaItem)){
         hr = pIWiaItem->GetRootItem(&pNewRootItem);
         if(hr == S_OK){
                CItemInfoDlg ItemInfoDlg;
                ItemInfoDlg.Initialize(pNewRootItem,TRUE);
                ItemInfoDlg.DoModal();

                CItemInfoDlg ItemInfoDlg2;
                ItemInfoDlg2.Initialize(pNewRootItem,FALSE);
                ItemInfoDlg2.DoModal();
                pNewRootItem->Release();
         }
    }
}
/**************************************************************************\
* CWIATestView::OnReenumitems()
*
*   Force a rennumeration of all child items, preserving the ROOT item
*
*
* Arguments:
*
*   none
*
* Return Value:
*
*   void
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
void CWIATestView::OnReenumitems()
{
    HRESULT hResult = S_OK;
    if (SUCCEEDED(m_WIA.ReEnumerateItems())){
        if (!m_ItemTree.BuildItemTree(m_WIA.GetItemTreeList()))
        StressStatus("* BuildItemTree Failed");
       else{
       OnSelchangeTymedCombobox();
       m_ItemPropertyListControl.DisplayItemPropData(m_WIA.GetRootIWiaItem());
       }
    }else{
        m_ItemPropertyListControl.DeleteAllItems();
        m_ItemTree.DeleteAllItems();
    }

}
/**************************************************************************\
* CWIATestView::OnSavepropstream()
*
*   Writes the currently selected item's property stream to a data file
*   "propstrm.wia"
*
*
* Arguments:
*
*   none
*
* Return Value:
*
*   void
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
void CWIATestView::OnSavepropstream()
{
    HRESULT hResult = S_OK;
    IWiaItem* pIWiaItem = m_ItemTree.GetSelectedIWiaItem(m_WIA.GetItemTreeList());
    if(pIWiaItem != NULL && m_WIA.IsValidItem(pIWiaItem)){
        hResult = m_WIA.SavePropStreamToFile("propstrm.wia", pIWiaItem);
        if (SUCCEEDED(hResult))
            StressStatus("Stream was saved successfully...");
        else
            StressStatus("* Stream Failed to be saved...",hResult);
    }
    else
        StressStatus("* Target Item is NULL");
}
/**************************************************************************\
* CWIATestView::OnLoadpropstream()
*
*   Reads a previously saved property stream file, and creates a property
*   stream.  This stream is then set to the currently selected item.
*
*
* Arguments:
*
*   none
*
* Return Value:
*
*   void
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
void CWIATestView::OnLoadpropstream()
{
    HRESULT hResult = S_OK;
    IWiaItem* pIWiaItem = m_ItemTree.GetSelectedIWiaItem(m_WIA.GetItemTreeList());
    if(pIWiaItem != NULL && m_WIA.IsValidItem(pIWiaItem)){
        hResult = m_WIA.ReadPropStreamFromFile("propstrm.wia", pIWiaItem);
        if (SUCCEEDED(hResult))
            StressStatus("Stream was restored successfully...");
        else
            StressStatus("* Stream Failed to be saved...",hResult);
    }
    else
        StressStatus("* Target Item is NULL");

    //
    // Refresh property display
    //

    OnRefresh();
}
/**************************************************************************\
* CWIATestView::OnGetSetPropstreamTest()
*
*   Gets a property stream from the currently selected item, and then
*   Sets the same stream back to it.
*
*
* Arguments:
*
*   none
*
* Return Value:
*
*   void
*
* History:
*
*    2/14/1999 Original Version
*
\**************************************************************************/
void CWIATestView::OnGetSetPropstreamTest()
{
    HRESULT hResult = S_OK;
    IWiaItem* pIWiaItem = m_ItemTree.GetSelectedIWiaItem(m_WIA.GetItemTreeList());
    if(pIWiaItem != NULL && m_WIA.IsValidItem(pIWiaItem)){
        hResult = m_WIA.GetSetPropStreamTest(pIWiaItem);
        if (SUCCEEDED(hResult))
            StressStatus("GET / SET Test was successful ");
        else
            StressStatus("* GET / SET Test Failed...",hResult);
    }
    else
        StressStatus("* Target Item is NULL");

    //
    // Refresh property display
    //

    OnRefresh();
}

/**************************************************************************\
* CWIATestView::OnAnalyzeItem()
*
*   Runs the AnalyzeItem method of the currently selected item.
*
*
* Arguments:
*
*   none
*
* Return Value:
*
*   void
*
* History:
*
*   01/13/2000 Original Version
*
\**************************************************************************/
void CWIATestView::OnAnalyzeItem()
{
    HRESULT hResult = S_OK;
    IWiaItem* pIWiaItem = m_ItemTree.GetSelectedIWiaItem(m_WIA.GetItemTreeList());
    if(pIWiaItem != NULL && m_WIA.IsValidItem(pIWiaItem)){
        hResult = m_WIA.AnalyzeItem(pIWiaItem);
        if (SUCCEEDED(hResult)) {
            StressStatus("AnalyzeItem run successfully...");

            OnReenumitems();
        }
        else
            StressStatus("* AnalyzeItem failed...",hResult);
    }
    else
        StressStatus("* Target Item is NULL");
}

/**************************************************************************\
* CWIATestView::OnCreateChildItem()
*
*   Runs the AnalyzeItem method of the currently selected item.
*
*
* Arguments:
*
*   none
*
* Return Value:
*
*   void
*
* History:
*
*   01/13/2000 Original Version
*
\**************************************************************************/
void CWIATestView::OnCreateChildItem()
{
    HRESULT hResult = S_OK;
    IWiaItem* pIWiaItem = m_ItemTree.GetSelectedIWiaItem(m_WIA.GetItemTreeList());
    if(pIWiaItem != NULL && m_WIA.IsValidItem(pIWiaItem)){
        hResult = m_WIA.CreateChildItem(pIWiaItem);
        if (SUCCEEDED(hResult)) {
            StressStatus("Successfully created a new child item...");

            OnReenumitems();
        }
        else
            StressStatus("* CreateChildItem failed...",hResult);
    }
    else
        StressStatus("* Target Item is NULL");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiatest\wtdb.h ===
// wtdb.h

#ifndef _INC_WTDB
#define _INC_WTDB

//
// WIATEST DATABASE
//

#define NUM_ENTRIES 7

// WTDB struct
typedef struct WTDBtag
{
    char* pName;
    int nItems;
    DWORD* pData;
    char** pDataNames;
}WTDB;

// MediaType
DWORD MediaType[]={
TYMED_CALLBACK,
TYMED_FILE
};

char* MediaTypestr[]={
"TYMED_CALLBACK",
"TYMED_FILE"
};

// CurrentIntent
DWORD CurrentIntent[]={
WIA_INTENT_NONE,
WIA_INTENT_IMAGE_TYPE_COLOR,
WIA_INTENT_IMAGE_TYPE_GRAYSCALE,
WIA_INTENT_IMAGE_TYPE_TEXT,
WIA_INTENT_MINIMIZE_SIZE,
WIA_INTENT_MAXIMIZE_QUALITY
};

char* CurrentIntentstr[]={
"WIA_INTENT_NONE",
"WIA_INTENT_IMAGE_TYPE_COLOR",
"WIA_INTENT_IMAGE_TYPE_GRAYSCALE",
"WIA_INTENT_IMAGE_TYPE_TEXT",
"WIA_INTENT_MINIMIZE_SIZE",
"WIA_INTENT_MAXIMIZE_QUALITY"
};

// Data Type
DWORD DataType[]={
WIA_DATA_THRESHOLD,
WIA_DATA_DITHER,
WIA_DATA_GRAYSCALE,
WIA_DATA_COLOR,
WIA_DATA_COLOR_THRESHOLD,
WIA_DATA_COLOR_DITHER,
};

char* DataTypestr[]={
"WIA_DATA_THRESHOLD",
"WIA_DATA_DITHER",
"WIA_DATA_GRAYSCALE",
"WIA_DATA_COLOR",
"WIA_DATA_COLOR_THRESHOLD",
"WIA_DATA_COLOR_DITHER",
};

// Document Handling Select
DWORD DocHandlingSelect[]={
FEEDER,
FLATBED,
DUPLEX,
FRONT_FIRST,
BACK_FIRST,
FRONT_ONLY,
BACK_ONLY,
NEXT_PAGE,
PREFEED,
AUTO_ADVANCE
};

char* DocHandlingSelectstr[]={
"FEEDER",
"FLATBED",
"DUPLEX",
"FRONT_FIRST",
"BACK_FIRST",
"FRONT_ONLY",
"BACK_ONLY",
"NEXT_PAGE",
"PREFEED",
"AUTO_ADVANCE"
};

// Compression constants
DWORD Compression[]={
WIA_COMPRESSION_NONE,
WIA_COMPRESSION_BI_RLE4,
WIA_COMPRESSION_BI_RLE8,
WIA_COMPRESSION_G3
};

char* Compressionstr[]={
"WIA_COMPRESSION_NONE",
"WIA_COMPRESSION_BI_RLE4",
"WIA_COMPRESSION_BI_RLE8",
"WIA_COMPRESSION_G3"
};

// Preview constants
DWORD Preview[]={
WIA_FINAL_SCAN,
WIA_PREVIEW_SCAN
};

char* Previewstr[]={
"WIA_FINAL_SCAN",
"WIA_PREVIEW_SCAN"
};

// WiatestDatabase
WTDB WiatestDatabase[NUM_ENTRIES]={

{NULL,(NUM_ENTRIES - 1),NULL,NULL},
{"Current Intent",6,CurrentIntent,CurrentIntentstr},
{"Data Type",6,DataType,DataTypestr},
{"Document Handling Select",10,DocHandlingSelect,DocHandlingSelectstr},
{"Compression",4,Compression,Compressionstr},
{"Media Type",2,MediaType,MediaTypestr},
{"Preview",2,Preview,Previewstr}

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiatest2\childfrm.h ===
// ChildFrm.h : interface of the CChildFrame class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_CHILDFRM_H__C423679D_E14B_4EFB_BF3D_F9E796F1BA03__INCLUDED_)
#define AFX_CHILDFRM_H__C423679D_E14B_4EFB_BF3D_F9E796F1BA03__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


class CChildFrame : public CMDIChildWnd
{
	DECLARE_DYNCREATE(CChildFrame)
public:
	CChildFrame();

// Attributes
public:
    
// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CChildFrame)
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	//}}AFX_VIRTUAL

// Implementation
public:	
	virtual ~CChildFrame();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

// Generated message map functions
protected:
	//{{AFX_MSG(CChildFrame)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CHILDFRM_H__C423679D_E14B_4EFB_BF3D_F9E796F1BA03__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiatest\wiatestdoc.h ===
// WIATestDoc.h : interface of the CWIATestDoc class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_WIATESTDOC_H__48214BAC_E863_11D2_ABDA_009027226441__INCLUDED_)
#define AFX_WIATESTDOC_H__48214BAC_E863_11D2_ABDA_009027226441__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


class CWIATestDoc : public CDocument
{
protected: // create from serialization only
	CWIATestDoc();
	DECLARE_DYNCREATE(CWIATestDoc)

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CWIATestDoc)
	public:
	virtual BOOL OnNewDocument();
	virtual void Serialize(CArchive& ar);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CWIATestDoc();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:

// Generated message map functions
protected:
	//{{AFX_MSG(CWIATestDoc)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_WIATESTDOC_H__48214BAC_E863_11D2_ABDA_009027226441__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiatest\wiatestview.h ===
// WIATestView.h : interface of the CWIATestView class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_WIATESTVIEW_H__48214BAE_E863_11D2_ABDA_009027226441__INCLUDED_)
#define AFX_WIATESTVIEW_H__48214BAE_E863_11D2_ABDA_009027226441__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "cdib.h"
#include "WIATestDoc.h"
#include "WIATestUI.h"
#include "eventcallback.h"
#include "wiapreview.h"

#ifndef StiDeviceTypeStreamingVideo
#define StiDeviceTypeStreamingVideo 3
#endif

//
// Operation threads section
//
ULONG _stdcall AddDeviceThread(LPVOID pParam);
class CWIATestView : public CFormView
{
protected: // create from serialization only
    CWIATestView();
    DECLARE_DYNCREATE(CWIATestView)
    CWIA m_WIA;

    //CTypedPtrList<CPtrList, WIAITEMTREENODE*> m_ActiveTreeList;
    IWiaDevMgr* m_pIWiaDevMgr;
public:
    //{{AFX_DATA(CWIATestView)
    enum { IDD = IDD_WIATEST_FORM };
    CButton m_PlayAudioButton;
    CWIATymedComboBox   m_TymedComboBox;
    CStatic m_ThumbnailImage;
    CStatic m_PreviewFrame;
    CWIAPropListCtrl m_ItemPropertyListControl;
    CWIADeviceComboBox  m_DeviceListComboBox;
    CWIATreeCtrl    m_ItemTree;
    CWIAClipboardFormatComboBox m_ClipboardFormatComboBox;
    CString m_FileName;
    CString m_GUIDDisplay;
    CString m_AudioFileName;
    //}}AFX_DATA

// Attributes
public:
    CWIATestDoc* GetDocument();

// Operations
public:

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CWIATestView)
    public:
    virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    virtual void OnInitialUpdate(); // called first time after construct
    //}}AFX_VIRTUAL

// Implementation
public:
    BOOL ItemHasAudio(IWiaItem* pIWiaItem);
    void DisplayItemThumbnail(IWiaItem* pIWiaItem);
    void ResizeControls(int dx,int dy);
    void UpdateUI();

    //
    // WIA UI specific
    //

    BOOL DoDefaultUIInit();
    BOOL DoCmdLineUIInit(CString CmdLine);
    //
    // DIB display
    //

    CDib* m_pDIB;
    void DisplayImage();
    HBITMAP  m_hBitmap;
    PBYTE m_pThumbNail;

    //
    // WIA helper functions
    //

    HRESULT EnumerateWIADevices();
    void RefreshDeviceList();
    void RegisterForAllEventsByInterface();
    void UnRegisterForAllEventsByInterface();

    //
    // member variables
    //

    CEventCallback* m_pConnectEventCB;      // connect callback
    CEventCallback* m_pDisConnectEventCB;   // disconnect callback
    CWIAPreview* m_pPreviewWindow;          // image preview window
    CWIAPreview* m_pFullPreviewWindow;      // image preview window (FULL)
    int m_PaintMode;                        // Paint mode (PAINT_TOFIT, PAINT_ACTUAL)
    BOOL m_bThumbnailMode;                  // Thumbnail mode ON/OFF (camera only)

    //
    // destruction
    //

    virtual ~CWIATestView();
#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext& dc) const;
#endif

protected:

// Generated message map functions
protected:
    //{{AFX_MSG(CWIATestView)
    afx_msg void OnSelchangedDeviceItemTree(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnSelchangeDevicelistCombo();
    afx_msg void OnDblclkListItemprop(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnGetimagedlg();
    afx_msg void OnIdtgetbanded();
    afx_msg void OnWiadata();
    afx_msg void OnAdddevice();
    afx_msg void OnRefresh();
    afx_msg void OnViewTransferToolbar();
    afx_msg void OnExecutecommand();
    afx_msg void OnDumpdrvitemInfo();
    afx_msg void OnDumpappitemInfo();
    afx_msg void OnPaint();
    afx_msg void OnPaintmodeCheckbox();
    afx_msg void OnResetsti();
    afx_msg void OnFullpreview();
    afx_msg void OnThumbnailmode();
    afx_msg void OnDeleteitem();
    afx_msg void OnSelchangeTymedCombobox();
    afx_msg void OnSelchangeClipboardFormatCombobox();
    afx_msg void OnUpdateViewTransferToolbar(CCmdUI* pCmdUI);
    afx_msg void OnPlayaudioButton();
    afx_msg void OnGetrootitemtest();
    afx_msg void OnReenumitems();
    afx_msg void OnSavepropstream();
    afx_msg void OnLoadpropstream();
    afx_msg void OnGetSetPropstreamTest();
    afx_msg void OnAnalyzeItem();
	afx_msg void OnCreateChildItem();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

#ifndef _DEBUG  // debug version in WIATestView.cpp
inline CWIATestDoc* CWIATestView::GetDocument()
   { return (CWIATestDoc*)m_pDocument; }
#endif

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_WIATESTVIEW_H__48214BAE_E863_11D2_ABDA_009027226441__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiatest\wiatestui.h ===
//
// WIATestUI.h - handles controls for WIATest
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(WIATESTUI_H)
#define WIATESTUI_H
/////////////////////////////////////////////////////////////////////////////
// CWIAPropListCtrl window

class CWIAPropListCtrl : public CListCtrl
{
// Construction
public:
    CWIAPropListCtrl();

// Attributes
public:

// Operations
public:

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CWIAPropListCtrl)
    //}}AFX_VIRTUAL
protected:

// Implementation
public:
    void Resize(int dx, int dy);
    void DisplayItemPropData(IWiaItem* pIWiaItem,BOOL bAccessFlags = TRUE);
    void ConvertPropVarToString(PROPVARIANT  *pPropVar,LPSTR szVal);
    void InitHeaders();
    BOOL ConvertAccessFlagsToString(char* pszText,ULONG AccessFlags);
    BOOL ConvertVarTypeToString(char* pszText,ULONG VarType);
    virtual ~CWIAPropListCtrl();

    // Generated message map functions
protected:
    //{{AFX_MSG(CWIAPropListCtrl)
    //}}AFX_MSG

    DECLARE_MESSAGE_MAP()
};



/////////////////////////////////////////////////////////////////////////////
// CWIATreeCtrl window

class CWIATreeCtrl : public CTreeCtrl
{
// Construction
public:
    CWIATreeCtrl();


// Attributes
public:

// Operations
public:

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CWIATreeCtrl)
    //}}AFX_VIRTUAL

// Implementation
public:
    POSITION m_CurrentPosition;
    BOOL Construct(CPtrList* pActiveTreeList,HTREEITEM hParent,int ParentID);
    IWiaItem* GetRootIWiaItem(CPtrList* pActiveTreeList);
    IWiaItem* GetSelectedIWiaItem(CPtrList* pActiveTreeList);
    void InitHeaders();
    BOOL BuildItemTree(CPtrList* pActiveTreeList);
    void DestroyItemTree(CPtrList* pActiveTreeList);
    virtual ~CWIATreeCtrl();

    // Generated message map functions
protected:
    //{{AFX_MSG(CWIATreeCtrl)
        // NOTE - the ClassWizard will add and remove member functions here.
    //}}AFX_MSG

    DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CWIADeviceComboBox window

class CWIADeviceComboBox : public CComboBox
{
// Construction
public:
    CWIADeviceComboBox();
    void AddDeviceID(int DeviceIndex, BSTR DeviceName, BSTR ServerName,BSTR bstrDeviceID);

// Attributes
public:

// Operations
public:

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CWIADeviceComboBox)
    //}}AFX_VIRTUAL

// Implementation
public:
    void SetCurrentSelFromID(CString CmdLine);
    CString GetDeviceName(int ComboIndex);
    CString GetCurrentDeviceName();
    BSTR GetCurrentDeviceID();
    virtual ~CWIADeviceComboBox();

    // Generated message map functions
protected:
    //{{AFX_MSG(CWIADeviceComboBox)
        // NOTE - the ClassWizard will add and remove member functions here.
    //}}AFX_MSG

    DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CWIAClipboardFormatComboBox window

class CWIAClipboardFormatComboBox : public CComboBox
{
// Construction
public:
    CString ConvertClipboardFormatToCString(GUID ClipboardFormat);
    GUID GetCurrentClipboardFormat();
    void InitClipboardFormats(CPtrList* pSupportedFormatList,LONG Tymed);
    CWIAClipboardFormatComboBox();
    const GUID* GetGUIDPtr(GUID guidIn);

// Attributes
public:

// Operations
public:

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CWIAClipboardFormatComboBox)
    //}}AFX_VIRTUAL

// Implementation
public:
    void SetClipboardFormat(GUID CF_VALUE);
    virtual ~CWIAClipboardFormatComboBox();

    // Generated message map functions
protected:
    //{{AFX_MSG(CWIAClipboardFormatComboBox)
        // NOTE - the ClassWizard will add and remove member functions here.
    //}}AFX_MSG

    DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
// CWIATymedComboBox window

class CWIATymedComboBox : public CComboBox
{
// Construction
public:
    CWIATymedComboBox();

// Attributes
public:

// Operations
public:

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CWIATymedComboBox)
    //}}AFX_VIRTUAL

// Implementation
public:
    void InitTymedComboBox();
    DWORD GetCurrentTymed();
    virtual ~CWIATymedComboBox();

    // Generated message map functions
protected:
    //{{AFX_MSG(CWIATymedComboBox)
        // NOTE - the ClassWizard will add and remove member functions here.
    //}}AFX_MSG

    DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiatest2\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__7EF78373_2E5A_45D4_9D59_BB98B576A9D4__INCLUDED_)
#define AFX_STDAFX_H__7EF78373_2E5A_45D4_9D59_BB98B576A9D4__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define VC_EXTRALEAN        // Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxdisp.h>        // MFC Automation classes
#include <afxdtctl.h>       // MFC support for Internet Explorer 4 Common Controls
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>         // MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT

#include <wia.h>            // WIA support for applications
#include "wiahelper.h"      // WIA helper class for reading/writing properties
#include "wiadbg.h"         // WIA debug logging

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__7EF78373_2E5A_45D4_9D59_BB98B576A9D4__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiatest2\wiaacquiredlg.h ===
#if !defined(AFX_CWiaAcquireDlg_H__A979FA0F_19E4_4F85_978A_97460C29FB7D__INCLUDED_)
#define AFX_CWiaAcquireDlg_H__A979FA0F_19E4_4F85_978A_97460C29FB7D__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// CWiaAcquireDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CWiaAcquireDlg dialog

class CWiaAcquireDlg : public CDialog
{
// Construction
public:
	void SetPercentComplete(LONG lPercentComplete);
	void SetCallbackMessage(TCHAR *szCallbackMessage);
	BOOL CheckCancelButton();
	BOOL m_bCanceled;
    CWiaAcquireDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CWiaAcquireDlg)
	enum { IDD = IDD_DATA_ACQUISITION_DIALOG };
	CProgressCtrl	m_AcquireProgressCtrl;
	CString	m_szAcquisitionCallbackMessage;
	CString	m_szPercentComplete;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CWiaAcquireDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CWiaAcquireDlg)
	virtual void OnCancel();
	virtual BOOL OnInitDialog();	
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CWiaAcquireDlg_H__A979FA0F_19E4_4F85_978A_97460C29FB7D__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiatest2\mainfrm.h ===
// MainFrm.h : interface of the CMainFrame class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_MAINFRM_H__3DF4B6B7_A4D0_4DFE_B19C_EA398731B312__INCLUDED_)
#define AFX_MAINFRM_H__3DF4B6B7_A4D0_4DFE_B19C_EA398731B312__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "wiaeventcallback.h"

class CMainFrame : public CMDIFrameWnd
{
	DECLARE_DYNAMIC(CMainFrame)
public:
	CMainFrame();

// Attributes
public:

// Operations
public:
    void RegisterForEvents();
    CWiaEventCallback m_WiaEventCallback;
// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMainFrame)
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CMainFrame();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:  // control bar embedded members
	CStatusBar  m_wndStatusBar;
	CToolBar    m_wndToolBar;

// Generated message map functions
protected:
	//{{AFX_MSG(CMainFrame)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MAINFRM_H__3DF4B6B7_A4D0_4DFE_B19C_EA398731B312__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiatest2\sources.inc ===
!include $(PROJECT_ROOT)\wia\wiaenv.inc

TARGETNAME=wiatest
TARGETPATH=$(OBJ_DIR)
TARGETTYPE=PROGRAM

INCLUDES=;..;..\res;$(INCLUDES)

SOURCES= \
        ..\ChildFrm.cpp \
        ..\MainFrm.cpp \
        ..\WiaAcquireDlg.cpp \
        ..\WiacapDlg.cpp \
        ..\WiaDataCallback.cpp \
        ..\WiaEventCallback.cpp \
        ..\WiaeditpropDlg.cpp \
        ..\Wiaeditpropflags.cpp \
        ..\Wiaeditproplist.cpp \
        ..\Wiaeditpropnone.cpp \
        ..\Wiaeditproprange.cpp \
        ..\wiahelper.cpp \
        ..\WiaitemListCtrl.cpp \
        ..\Wiaselect.cpp \
        ..\wiatest.cpp \
        ..\wiatestDoc.cpp \
        ..\wiatestView.cpp \
        ..\WiaDocAcqSettings.cpp \
        ..\WiaSimpleDocPg.cpp \
        ..\WiaAdvancedDocPg.cpp \
        ..\wiadbg.cpp \
        ..\wiatest.rc

# Add interlac.cpp if the PNG support is ever fixed

MISCFILES = ..\wiatest.htm

USE_NATIVE_EH=1

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\stdafx.h
PRECOMPILED_PCH=stdafx.pch
PRECOMPILED_OBJ=stdafx.obj

TARGETLIBS= \
        $(TARGETLIBS)                   \
        $(SDK_LIB_PATH)\winmm.lib       \
        $(SDK_LIB_PATH)\irnotif.lib     \
        $(SDK_LIB_PATH)\userenv.lib     \
        $(SDK_LIB_PATH)\comdlg32.lib    \
        $(SDK_LIB_PATH)\wiaguid.lib     \
        $(SDK_LIB_PATH)\atl.lib         \
        $(SDK_LIB_PATH)\mscms.lib       \
        $(SDK_LIB_PATH)\shell32.lib
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiatest2\wiaacquiredlg.cpp ===
// CWiaAcquireDlg.cpp : implementation file
//

#include "stdafx.h"
#include "wiatest.h"
#include "wiaacquiredlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CWiaAcquireDlg dialog


CWiaAcquireDlg::CWiaAcquireDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CWiaAcquireDlg::IDD, pParent)
{
	m_bCanceled = FALSE;
    //{{AFX_DATA_INIT(CWiaAcquireDlg)
	m_szAcquisitionCallbackMessage = _T("");
	m_szPercentComplete = _T("");
	//}}AFX_DATA_INIT
}


void CWiaAcquireDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CWiaAcquireDlg)
	DDX_Control(pDX, IDC_ACQUIRE_PROGRESS, m_AcquireProgressCtrl);
	DDX_Text(pDX, IDC_DATA_ACQUISITION_MESSAGE, m_szAcquisitionCallbackMessage);
	DDX_Text(pDX, IDC_DATA_ACQUSITION_PERCENTCOMPLETE, m_szPercentComplete);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CWiaAcquireDlg, CDialog)
	//{{AFX_MSG_MAP(CWiaAcquireDlg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWiaAcquireDlg message handlers

void CWiaAcquireDlg::OnCancel() 
{	
    m_bCanceled = TRUE;
}

BOOL CWiaAcquireDlg::OnInitDialog() 
{
	CDialog::OnInitDialog();
	m_AcquireProgressCtrl.SetPos(0);
    m_AcquireProgressCtrl.SetRange(0,100); 
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

BOOL CWiaAcquireDlg::CheckCancelButton()
{

    MSG msg;

    while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {
        if (!m_hWnd || !IsDialogMessage(&msg)) {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }
    return m_bCanceled;    
}

void CWiaAcquireDlg::SetCallbackMessage(TCHAR *szCallbackMessage)
{
    m_szAcquisitionCallbackMessage = szCallbackMessage;
    UpdateData(FALSE);
}

void CWiaAcquireDlg::SetPercentComplete(LONG lPercentComplete)
{
    m_szPercentComplete.Format(TEXT("%d%%"),lPercentComplete);
    UpdateData(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiatest2\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	wiatest.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiatest2\mainfrm.cpp ===
// MainFrm.cpp : implementation of the CMainFrame class
//

#include "stdafx.h"
#include "wiatest.h"

#include "MainFrm.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMainFrame

IMPLEMENT_DYNAMIC(CMainFrame, CMDIFrameWnd)

BEGIN_MESSAGE_MAP(CMainFrame, CMDIFrameWnd)
	//{{AFX_MSG_MAP(CMainFrame)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	ON_WM_CREATE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

static UINT indicators[] =
{
	ID_SEPARATOR,           // status line indicator
	ID_INDICATOR_CAPS,
	ID_INDICATOR_NUM,
	ID_INDICATOR_SCRL,
};

/////////////////////////////////////////////////////////////////////////////
// CMainFrame construction/destruction

CMainFrame::CMainFrame()
{    
}

CMainFrame::~CMainFrame()
{
}

int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CMDIFrameWnd::OnCreate(lpCreateStruct) == -1)
		return -1;
	
	if (!m_wndToolBar.CreateEx(this, TBSTYLE_FLAT, WS_CHILD | WS_VISIBLE | CBRS_TOP
		| CBRS_GRIPPER | CBRS_TOOLTIPS | CBRS_FLYBY | CBRS_SIZE_DYNAMIC) ||
		!m_wndToolBar.LoadToolBar(IDR_MAINFRAME))
	{
		TRACE0("Failed to create toolbar\n");
		return -1;      // fail to create
	}

	if (!m_wndStatusBar.Create(this) ||
		!m_wndStatusBar.SetIndicators(indicators,
		  sizeof(indicators)/sizeof(UINT)))
	{
		TRACE0("Failed to create status bar\n");
		return -1;      // fail to create
	}

	// TODO: Delete these three lines if you don't want the toolbar to
	//  be dockable
	m_wndToolBar.EnableDocking(CBRS_ALIGN_ANY);
	EnableDocking(CBRS_ALIGN_ANY);
	DockControlBar(&m_wndToolBar);
    
    // register for events
    RegisterForEvents();
	return 0;
}

BOOL CMainFrame::PreCreateWindow(CREATESTRUCT& cs)
{
	if( !CMDIFrameWnd::PreCreateWindow(cs) )
		return FALSE;
	// TODO: Modify the Window class or styles here by modifying
	//  the CREATESTRUCT cs

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CMainFrame diagnostics

#ifdef _DEBUG
void CMainFrame::AssertValid() const
{
	CMDIFrameWnd::AssertValid();
}

void CMainFrame::Dump(CDumpContext& dc) const
{
	CMDIFrameWnd::Dump(dc);
}

#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CMainFrame message handlers

void CMainFrame::RegisterForEvents()
{    
    HRESULT hr = S_OK;
    
    IWiaDevMgr *pIWiaDevMgr = NULL;
    hr = CoCreateInstance(CLSID_WiaDevMgr, NULL, CLSCTX_LOCAL_SERVER, IID_IWiaDevMgr,(void**)&pIWiaDevMgr);
    if(FAILED(hr)){
        // creation of device manager failed, so we can not continue        
        ErrorMessageBox(IDS_WIATESTERROR_COCREATEWIADEVMGR,hr);        
        return;
    }

    IWiaEventCallback* pIWiaEventCallback = NULL;
    
    hr = m_WiaEventCallback.QueryInterface(IID_IWiaEventCallback,(void **)&pIWiaEventCallback);
    if (SUCCEEDED(hr)) {
        GUID guidEvent = WIA_EVENT_DEVICE_CONNECTED;

        BOOL bFailedOnce = FALSE;
        hr = pIWiaDevMgr->RegisterEventCallbackInterface(0,
                                                         NULL,
                                                         &guidEvent,
                                                         pIWiaEventCallback,
                                                         &m_WiaEventCallback.m_pIUnkRelease[0]);
        if (FAILED(hr)) {
            // display one error message... instead of one for each event.
            if (!bFailedOnce) {
                ErrorMessageBox(IDS_WIATESTERROR_REGISTER_EVENT_CALLBACK,hr);
            }
            bFailedOnce = TRUE;            
        }
        
        guidEvent = WIA_EVENT_DEVICE_DISCONNECTED;

        hr = pIWiaDevMgr->RegisterEventCallbackInterface(0,
                                                         NULL,
                                                         &guidEvent,
                                                         pIWiaEventCallback,
                                                         &m_WiaEventCallback.m_pIUnkRelease[1]);
        if (FAILED(hr)) {
            // display one error message... instead of one for each event.
            if (!bFailedOnce) {
                ErrorMessageBox(IDS_WIATESTERROR_REGISTER_EVENT_CALLBACK,hr);
            }
            bFailedOnce = TRUE;            
        }
    }

    m_WiaEventCallback.SetViewWindowHandle(m_hWnd);

    //
    // register for action events by command-line
    //

    WCHAR szMyApplicationLaunchPath[MAX_PATH];
    memset(szMyApplicationLaunchPath,0,sizeof(szMyApplicationLaunchPath));
    GetModuleFileNameW(NULL,szMyApplicationLaunchPath,sizeof(szMyApplicationLaunchPath));
    BSTR bstrMyApplicationLaunchPath = SysAllocString(szMyApplicationLaunchPath);

    WCHAR szMyApplicationName[MAX_PATH];
    memset(szMyApplicationName,0,sizeof(szMyApplicationName));                                                                    
    HINSTANCE hInst = AfxGetInstanceHandle();
    if (hInst) {        
        LoadStringW(hInst, IDS_MYAPPLICATION_NAME, szMyApplicationName, (sizeof(szMyApplicationName)/sizeof(WCHAR)));

        BSTR bstrMyApplicationName = SysAllocString(szMyApplicationName);
        
        GUID guidScanButtonEvent = WIA_EVENT_SCAN_IMAGE;
        hr = pIWiaDevMgr->RegisterEventCallbackProgram(
                                                        WIA_REGISTER_EVENT_CALLBACK,
                                                        NULL,
                                                        &guidScanButtonEvent,
                                                        bstrMyApplicationLaunchPath,
                                                        bstrMyApplicationName,
                                                        bstrMyApplicationName,
                                                        bstrMyApplicationLaunchPath);
        if (FAILED(hr)) {            
        }

        SysFreeString(bstrMyApplicationName);
        bstrMyApplicationName = NULL;

    }
    SysFreeString(bstrMyApplicationLaunchPath);
    bstrMyApplicationLaunchPath = NULL; 

    // release DevMgr
    pIWiaDevMgr->Release();
    pIWiaDevMgr = NULL;    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiatest2\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by wiatest.rc
//
#define IDD_ABOUTBOX                    100
#define IDD_WIATEST_FORM                101
#define IDD_PROPPAGE_SIMPLE_DOCUMENT_SCANNERS_SETTINGS 102
#define IDR_MAINFRAME                   128
#define IDR_WIATESTYPE                  129
#define IDD_SELECTDEVICE_DIALOG         130
#define IDD_EDIT_WIAPROP_NONE_DIALOG    131
#define IDD_EDIT_WIAPROP_LIST_DIALOG    132
#define IDD_EDIT_WIAPROP_FLAGS_DIALOG   133
#define IDD_EDIT_WIAPROP_RANGE_DIALOG   134
#define IDD_EDIT_WIAPROP_NONE_SYSTEMTIME_DIALOG 135
#define IDR_PROPERTY_EDIT_POPUPMENU     136
#define IDD_CAPABILITIES_DIALOG         137
#define IDR_ITEMTREE_POPUPMENU          138
#define IDD_DATA_ACQUISITION_DIALOG     139
#define IDD_DOCUMENT_ACQUISITION_SETTINGS_DIALOG 140
#define IDD_PROPPAGE_HIGHSPEED_DOCUMENT_SCANNERS_SETTINGS 141
#define IDD_PROPPAGE_ADVANCED_DOCUMENT_SCANNERS_SETTINGS 141
#define IDB_THUMBNAIL_MISSING_BITMAP    142
#define IDC_ITEM_TREECTRL               1000
#define IDC_ITEMPROPERTIES_LISTCTRL     1001
#define IDC_SUPPORTEDTYMED_LISTBOX      1002
#define IDC_SUPPORTEDFORMATS_LISTBOX    1003
#define IDC_THUMBNAIL_PREVIEW           1004
#define IDC_THUMNAIL_PREVIEW_CHECKBOX   1005
#define IDC_WIADEVICE_LISTBOX           1007
#define IDC_NONE_PROPERTYVALUE_EDITBOX  1008
#define IDC_NONE_PROPERTY_NAME          1009
#define IDC_LIST_PROPERTY_NAME          1010
#define IDC_LIST_PROPERTYVALUE_EDITBOX  1011
#define IDC_FLAGS_PROPERTYVALUE_LISTBOX 1012
#define IDC_LIST_PROPERTYVALUE_NUMITEMSTEXT 1013
#define IDC_FLAGS_PROPERTY_NAME         1014
#define IDC_FLAGS_PROPERTYVALUE_EDITBOX 1015
#define IDC_LIST_PROPERTYVALUE_LISTBOX  1016
#define IDC_RANGE_PROPERTY_NAME         1017
#define IDC_RANGE_PROPERTYVALUE_EDITBOX 1018
#define RANGE_PROPERTY_MINVALUE         1019
#define RANGE_PROPERTY_MAXVALUE         1020
#define RANGE_PROPERTY_NOMVALUE         1021
#define RANGE_PROPERTY_INCVALUE         1022
#define IDC_NONE_SYSTEMTIME_PROPERTY_NAME 1023
#define IDC_NONE_SYSTEMTIME_PROPERTYVALUE_EDITBOX 1024
#define IDC_NONE_PROPERTY_FORMATTING_TEXT 1025
#define IDC_CAPABILITIES_LISTCTRL       1027
#define IDC_SEND_COMMAND_BUTTON         1028
#define IDC_ACQUIRE_PROGRESS            1029
#define IDC_DATA_ACQUSITION_PERCENTCOMPLETE 1030
#define IDC_DATA_ACQUISITION_MESSAGE    1031
#define IDC_APPLY_SETTINGS              1034
#define IDC_NUMBEROF_PAGES_EDITBOX      1036
#define IDC_DUPLEX_CHECKBOX             1037
#define IDC_DOCUMENT_SOURCE_COMBOBOX    1038
#define IDC_NUMBEROF_PAGES_EDITBOX_TEXT 1039
#define IDC_SUPPORTED_TYMED_AND_FORMAT_LISTBOX 1040
#define IDM_ACQUIREIMAGE                32771
#define IDM_LOAD_WIAPROPERTYSTREAM      32772
#define IDM_SAVE_WIAPROPERTYSTREAM      32773
#define ID_PROPERTYEDITPOPUPMENU_EDITPROPERTYVALUE 32775
#define IDM_VIEW_CAPABILITIES           32776
#define IDM_VIEW_DISPLAYIMAGE           32777
#define IDM_DELETE_ITEM                 32779
#define IDM_ACQUIREIMAGE_COMMONUI       32780
#define IDM_EDIT_DEBUGOUT               32781
#define IDM_DOCUMENT_ACQUISITION_SETTINGS 32782
#define IDM_SHOWTHUMBNAIL_ACTUALSIZE    32784
#define IDS_WIAERROR_DEVICEBUSY         61446
#define IDS_WIAERROR_GENERAL            61447
#define IDS_WIAERROR_PAPERJAM           61448
#define IDS_WIAERROR_PAPEREMPTY         61449
#define IDS_WIAERROR_PAPERPROBLEM       61450
#define IDS_WIAERROR_DEVICEOFFLINE      61451
#define IDS_WIAERROR_WARMINGUP          61452
#define IDS_WIAERROR_USERINTERVENTION   61453
#define IDS_WIAERROR_ITEMDELETED        61454
#define IDS_WIAERROR_DEVICECOMMUNICATION 61455
#define IDS_WIAERROR_INVALIDCOMMAND     61456
#define IDS_WIAERROR_DIALOGTITLE        61457
#define IDS_WIATESTERROR_COCREATEWIADEVMGR 61458
#define IDS_WIATESTERROR_CREATEDEVICE   61459
#define IDS_WIATESTCOLUMN_PROPERTY      61460
#define IDS_WIATESTCOLUMN_VARTYPE       61461
#define IDS_WIATESTCOLUMN_VALUE         61462
#define IDS_WIATESTCOLUMN_ACCESSFLAGS   61463
#define IDS_WIATESTERROR_ITEMNOTFOUND   61464
#define IDS_WIATESTERROR_WRITING_PROPERTY 61465
#define IDS_WIATESTWARNING_ADDITIONAL_PROPERTY 61466
#define IDS_WIATESTERROR_ENUMFORMATS    61467
#define IDS_WIATESTERROR_IWIADATATRANSFER 61468
#define IDS_WIATESTERROR_NOTIMPLEMENTED 61469
#define IDS_WIATESTINFO_SYSTEMTIME_FORMATTING 61470
#define IDS_WIATESTCOLUMN_CAPABILITYNAME 61471
#define IDS_WIATESTCOLUMN_CAPABILITYDESCRIPTION 61472
#define IDS_WIATESTCOLUMN_CAPABILITYTYPE 61473
#define IDS_WIATESTCOLUMN_CAPABILITYVALUE 61474
#define IDS_WIATESTEVENT                61475
#define IDS_WIATESTCOMMAND              61476
#define IDS_WIATESTERROR_ACQUISITION    61477
#define IDS_WIATESTERROR_CANCEL_ACQUISITION 61478
#define IDS_WIATESTERROR_WRITINGTYMED   61479
#define IDS_WIATESTERROR_WRITINGFORMAT  61480
#define IDS_WIATESTERROR_UNSUPPORTEDTYMED 61481
#define IDS_WIATESTERROR_READINGTYMED   61482
#define IDS_WIATESTERROR_READINGMINBUFFERSIZE 61483
#define IDS_WIATEST_MEMORYTRANSFER_FILENAME 61484
#define IDS_WIATEST_FILETRANSFER_FILENAME 61485
#define IDS_WIATESTERROR_UNKNOWN_IMAGEFORMAT 61486
#define IDS_WIATESTERROR_SYSTEMTIMEFORMATTING 61487
#define IDS_WIATESTERROR_DEVICECOMMAND  61488
#define IDS_WIATESTERROR_NOCOMMANDGUID  61489
#define IDS_WIATESTSUCCESS_COMMAND      61490
#define IDS_WIATESTERROR_DELETEROOTITEM 61491
#define IDS_WIATESTERROR_READINGFORMAT  61492
#define IDS_WIATESTERROR_THUMBNAILHEIGHT 61493
#define IDS_WIATESTERROR_THUMBNAILWIDTH 61494
#define IDS_WIATESTERROR_THUMBNAILDATA  61495
#define IDS_WIATESTERROR_REGISTER_EVENT_CALLBACK 61496
#define IDS_WIATESTSTATUS_REGISTER_EVENT_DEVICE_CONNECTED 61497
#define IDS_WIATESTSTATUS_REGISTER_EVENT_DEVICE_DISCONNECTED 61498
#define IDS_WIATESTSTATUS_REGISTER_EVENT_ITEM_CREATED 61499
#define IDS_WIATESTSTATUS_REGISTER_EVENT_ITEM_DELETED 61500
#define IDS_WIATESTSTATUS_REGISTER_EVENT_STORAGE_CREATED 61501
#define IDS_WIATESTSTATUS_REGISTER_EVENT_STORAGE_DELETED 61502
#define IDS_WIATESTSTATUS_REGISTER_EVENT_TREE_UPDATED 61503
#define IDS_WIATESTSTATUS_REGISTER_EVENT_UNKNOWN 61504
#define IDS_MYAPPLICATION_NAME          61507
#define IDS_WIATESTERROR_ENUMERATE_PROPERTIES 61509
#define IDS_WIATESTERROR_READINGTYMED_EXIST 61510
#define IDS_WIATESTWARNING_NEGATIVE_HEIGHTBITMAP 61511
#define IDS_WIATESTSAVEPROPSTREAM_DIALOGTITLE 61512
#define IDS_WIATESTLOADPROPSTREAM_DIALOGTITLE 61513
#define IDS_WIATESTERROR_READPROPERTYSTREAMFILE 61514
#define IDS_WIATESTERROR_WRITEPROPERTYSTREAMFILE 61515
#define IDS_WIASTATUS_DIALOGTITLE       61516
#define IDS_WIATESTERROR_DEVICEID       61517
#define IDS_WIATESTERROR_WIAPROPERTYSTORAGE 61518
#define IDS_WIATEST_DOCUMENT_SETTINGS_TITLE 61519
#define IDS_WIATESTERROR_WRITINGDOCHANDLINGSELECT 61520
#define IDS_WIATESTERROR_WRITINGPAGES   61521
#define IDS_WIATESTERROR_READINGDOCHANDLINGSELECT 61522
#define IDS_WIATESTERROR_READINGPAGES   61523
#define IDS_WIATESTWARNING_ZERO_HEIGHTBITMAP 61524
#define IDS_WIATESTERROR_PROCESSING_THUMBNAILDATA 61525

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_3D_CONTROLS                     1
#define _APS_NEXT_RESOURCE_VALUE        143
#define _APS_NEXT_COMMAND_VALUE         32785
#define _APS_NEXT_CONTROL_VALUE         1041
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiatest2\wiaadvanceddocpg.cpp ===
// WiaAdvancedDocPg.cpp : implementation file
//

#include "stdafx.h"
#include "wiatest.h"
#include "WiaAdvancedDocPg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CWiaAdvancedDocPg property page

IMPLEMENT_DYNCREATE(CWiaAdvancedDocPg, CPropertyPage)

CWiaAdvancedDocPg::CWiaAdvancedDocPg() : CPropertyPage(CWiaAdvancedDocPg::IDD)
{
	//{{AFX_DATA_INIT(CWiaHighSpeedDocPg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

CWiaAdvancedDocPg::~CWiaAdvancedDocPg()
{
}

void CWiaAdvancedDocPg::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CWiaAdvancedDocPg)
	DDX_Control(pDX, IDC_DUPLEX_CHECKBOX, m_DuplexSetting);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CWiaAdvancedDocPg, CPropertyPage)
	//{{AFX_MSG_MAP(CWiaAdvancedDocPg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWiaAdvancedDocPg message handlers

BOOL CWiaAdvancedDocPg::OnInitDialog() 
{
	CPropertyPage::OnInitDialog();
    
    // disable Duplex setting
	m_DuplexSetting.EnableWindow(FALSE);
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiatest2\wiacapdlg.cpp ===
// WiacapDlg.cpp : implementation file
//

#include "stdafx.h"
#include "wiatest.h"
#include "WiacapDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CWiacapDlg dialog


CWiacapDlg::CWiacapDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CWiacapDlg::IDD, pParent)
{
    m_pIWiaItem = NULL;
    m_NumCaps = 0;
    m_bCommandSent = FALSE;
	//{{AFX_DATA_INIT(CWiacapDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


void CWiacapDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CWiacapDlg)
	DDX_Control(pDX, IDC_SEND_COMMAND_BUTTON, m_SendCommandButton);
	DDX_Control(pDX, IDC_CAPABILITIES_LISTCTRL, m_CapablitiesListCtrl);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CWiacapDlg, CDialog)
	//{{AFX_MSG_MAP(CWiacapDlg)
	ON_WM_CLOSE()
	ON_BN_CLICKED(IDC_SEND_COMMAND_BUTTON, OnSendCommandButton)
	ON_NOTIFY(NM_CLICK, IDC_CAPABILITIES_LISTCTRL, OnClickCapabilitiesListctrl)
	ON_NOTIFY(LVN_ITEMCHANGED, IDC_CAPABILITIES_LISTCTRL, OnItemchangedCapabilitiesListctrl)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWiacapDlg message handlers

BOOL CWiacapDlg::OnInitDialog() 
{
	CDialog::OnInitDialog();	
	SetupColumnHeaders();
    AddCapabilitiesToListBox(WIA_DEVICE_EVENTS);
    AddCapabilitiesToListBox(WIA_DEVICE_COMMANDS);    
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CWiacapDlg::SetupColumnHeaders()
{
    LVCOLUMN lv;
    TCHAR szColumnName[MAX_PATH];
    memset(szColumnName,0,sizeof(szColumnName));
    HINSTANCE hInstance = NULL;
    hInstance = AfxGetInstanceHandle();
    if(hInstance){
        int i = 0;
        // initialize item property list control column headers
        
        // Capability name
        
        LoadString(hInstance,IDS_WIATESTCOLUMN_CAPABILITYNAME,szColumnName,MAX_PATH);
        
        lv.mask         = LVCF_FMT | LVCF_TEXT | LVCF_WIDTH;
        lv.fmt          = LVCFMT_LEFT ;
        lv.cx           = 100;
        lv.pszText      = szColumnName;
        lv.cchTextMax   = 0;
        lv.iSubItem     = ITEMPROPERTYLISTCTRL_COLUMN_CAPABILITYNAME;
        lv.iImage       = 0;
        lv.iOrder       = ITEMPROPERTYLISTCTRL_COLUMN_CAPABILITYNAME;
        i = m_CapablitiesListCtrl.InsertColumn(ITEMPROPERTYLISTCTRL_COLUMN_CAPABILITYNAME,&lv);
        
        // Capability description
        LoadString(hInstance,IDS_WIATESTCOLUMN_CAPABILITYDESCRIPTION,szColumnName,MAX_PATH);
        lv.cx           = 125;
        lv.iOrder       = ITEMPROPERTYLISTCTRL_COLUMN_CAPABILITYDESCRIPTION;
        lv.iSubItem     = ITEMPROPERTYLISTCTRL_COLUMN_CAPABILITYDESCRIPTION;
        lv.pszText      = szColumnName;
        i = m_CapablitiesListCtrl.InsertColumn(ITEMPROPERTYLISTCTRL_COLUMN_CAPABILITYDESCRIPTION,&lv);

        // Capability Value
        LoadString(hInstance,IDS_WIATESTCOLUMN_CAPABILITYVALUE,szColumnName,MAX_PATH);
        lv.cx           = 125;
        lv.iOrder       = ITEMPROPERTYLISTCTRL_COLUMN_CAPABILITYVALUE;
        lv.iSubItem     = ITEMPROPERTYLISTCTRL_COLUMN_CAPABILITYVALUE;
        lv.pszText      = szColumnName;
        i = m_CapablitiesListCtrl.InsertColumn(ITEMPROPERTYLISTCTRL_COLUMN_CAPABILITYVALUE,&lv);
        
        // Capability type (event or command)
        LoadString(hInstance,IDS_WIATESTCOLUMN_CAPABILITYTYPE,szColumnName,MAX_PATH);
        lv.cx           = 85;
        lv.iOrder       = ITEMPROPERTYLISTCTRL_COLUMN_CAPABILITYTYPE;
        lv.iSubItem     = ITEMPROPERTYLISTCTRL_COLUMN_CAPABILITYTYPE;
        lv.pszText      = szColumnName;
        i = m_CapablitiesListCtrl.InsertColumn(ITEMPROPERTYLISTCTRL_COLUMN_CAPABILITYTYPE,&lv);                
    }
}

void CWiacapDlg::AddCapabilitiesToListBox(LONG lType)
{
	WIA_DEV_CAP DevCap;
	IEnumWIA_DEV_CAPS* pIEnumWiaDevCaps = NULL;
	HRESULT hr = S_OK;
    INT ItemNumber = m_NumCaps;
	hr = m_pIWiaItem->EnumDeviceCapabilities(lType,&pIEnumWiaDevCaps);
	if(S_OK == hr){				
        do {
            memset(&DevCap,0,sizeof(DevCap));
            hr = pIEnumWiaDevCaps->Next(1,&DevCap,NULL);
            if (S_OK == hr){
                // DevCap.ulFlags;
                // DevCap.bstrIcon;
                // DevCap.bstrCommanline;

                //DevCap.guid;
                                    
                TCHAR  szText[MAX_PATH];
                memset(szText,0,sizeof(szText));
                
                LV_ITEM         lvitem;
                
                lvitem.mask     = LVIF_TEXT;
                lvitem.iItem    = ItemNumber;
                lvitem.iSubItem = ITEMPROPERTYLISTCTRL_COLUMN_CAPABILITYNAME;
                lvitem.pszText  = szText;
                lvitem.iImage   = NULL;                            
                
                // Write capability name to list control                
#ifndef UNICODE                
                WideCharToMultiByte(CP_ACP,0,DevCap.bstrName,-1,szText,MAX_PATH,NULL,NULL);
#else
                lstrcpy(szText,DevCap.bstrName);
#endif
                m_CapablitiesListCtrl.InsertItem(&lvitem);                                    
                
                // Write capability description to list control
                memset(szText,0,sizeof(szText));
                lvitem.iSubItem = ITEMPROPERTYLISTCTRL_COLUMN_CAPABILITYDESCRIPTION;
#ifndef UNICODE                
                WideCharToMultiByte(CP_ACP,0,DevCap.bstrDescription,-1,szText,MAX_PATH,NULL,NULL);
#else
                lstrcpy(szText,DevCap.bstrDescription);
#endif
                m_CapablitiesListCtrl.SetItem(&lvitem);
                
                // Write capability value
                memset(szText,0,sizeof(szText));
                lvitem.iSubItem = ITEMPROPERTYLISTCTRL_COLUMN_CAPABILITYVALUE;
                UCHAR *pwszUUID = NULL;
                UuidToString(&DevCap.guid,&pwszUUID);            
                TSPRINTF(szText,"%s",pwszUUID);
                // free allocated string
                RpcStringFree(&pwszUUID);
                m_CapablitiesListCtrl.SetItem(&lvitem);

                // Write capability type
                memset(szText,0,sizeof(szText));
                lvitem.iSubItem = ITEMPROPERTYLISTCTRL_COLUMN_CAPABILITYTYPE;
                if(lType == WIA_DEVICE_COMMANDS){
                    RC2TSTR(IDS_WIATESTCOMMAND,szText, sizeof(szText));
                } else {
                    RC2TSTR(IDS_WIATESTEVENT,szText, sizeof(szText));
                }
                m_CapablitiesListCtrl.SetItem(&lvitem);

                // increment Row counter
                ItemNumber++;

                // free allocated strings
                if(DevCap.bstrName){
                    SysFreeString(DevCap.bstrName);
                }
                if(DevCap.bstrDescription){
                    SysFreeString(DevCap.bstrDescription);
                }                    
            }            
        }while(hr == S_OK);
		pIEnumWiaDevCaps->Release();
        pIEnumWiaDevCaps = NULL;
	}

    // auto resize columns    
    for (int Col = 0; Col <4;Col++){
        m_CapablitiesListCtrl.SetColumnWidth(Col, LVSCW_AUTOSIZE);
    }

    m_NumCaps = ItemNumber;
}

void CWiacapDlg::SetIWiaItem(IWiaItem *pIWiaItem)
{
    pIWiaItem->AddRef();
    m_pIWiaItem = pIWiaItem;
}

void CWiacapDlg::OnClose() 
{
    if(m_pIWiaItem){
        m_pIWiaItem->Release();
        m_pIWiaItem = NULL;
    }	
	CDialog::OnClose();
}

void CWiacapDlg::OnSendCommandButton() 
{
	HRESULT hr = S_OK;
    GUID guidCommand;
    memset(&guidCommand,0,sizeof(GUID));
    IWiaItem *pIWiaItem = NULL;    
    GetCommandGUID(GetSelectedCapability(),&guidCommand);
    if(guidCommand != GUID_NULL){
        hr = m_pIWiaItem->DeviceCommand(0,&guidCommand,&pIWiaItem);
        if(FAILED(hr)){
            ErrorMessageBox(IDS_WIATESTERROR_DEVICECOMMAND,hr);
        } else {
            //m_bCommandSent = TRUE;
            if(pIWiaItem){
                pIWiaItem->Release();
                pIWiaItem = NULL;
            }
            TCHAR szCommandSuccess[MAX_PATH];
            memset(szCommandSuccess,0,sizeof(szCommandSuccess));
            RC2TSTR(IDS_WIATESTSUCCESS_COMMAND,szCommandSuccess,sizeof(szCommandSuccess));
            MessageBox(szCommandSuccess);
        }
    } else {
        ErrorMessageBox(IDS_WIATESTERROR_NOCOMMANDGUID);
    }
}

void CWiacapDlg::OnClickCapabilitiesListctrl(NMHDR* pNMHDR, LRESULT* pResult) 
{
	HD_NOTIFY*  phdn = (HD_NOTIFY *) pNMHDR;
    if(IsCommand(phdn->iItem)){
        m_SendCommandButton.EnableWindow(TRUE);
    } else {
        m_SendCommandButton.EnableWindow(FALSE);
    }
    *pResult = 0;
}

BOOL CWiacapDlg::IsCommand(INT iItem)
{
    // is an item selected?
    if (iItem < ITEMPROPERTYLISTCTRL_COLUMN_CAPABILITYNAME)
        return FALSE;

    TCHAR pszCapabilityType[MAX_PATH];
    TCHAR szCapTypeText[MAX_PATH];    
    memset(pszCapabilityType,0,sizeof(pszCapabilityType));        
    memset(szCapTypeText,0,sizeof(szCapTypeText));

    // load "Command" text label
    RC2TSTR(IDS_WIATESTCOMMAND,szCapTypeText,sizeof(szCapTypeText));
    m_CapablitiesListCtrl.GetItemText(iItem, ITEMPROPERTYLISTCTRL_COLUMN_CAPABILITYTYPE,
                                      pszCapabilityType, sizeof(pszCapabilityType));

    return (lstrcmpi(pszCapabilityType,szCapTypeText) == 0);
}

void CWiacapDlg::GetCommandGUID(INT iItem, GUID *pguid)
{
    memset(pguid,0,sizeof(GUID));
    TCHAR szGUID[MAX_PATH];
    memset(szGUID,0,sizeof(szGUID));    
    m_CapablitiesListCtrl.GetItemText(iItem, ITEMPROPERTYLISTCTRL_COLUMN_CAPABILITYVALUE,
                                      szGUID, sizeof(szGUID));
#ifndef UNICODE        
        UuidFromString((UCHAR*)szGUID,pguid);
#else        
        WideCharToMultiByte(CP_ACP, 0,szGUID,-1,szbuffer,MAX_PATH,NULL,NULL);
        UuidFromString((UCHAR*)szbuffer,pguid);
#endif

}

void CWiacapDlg::OnItemchangedCapabilitiesListctrl(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;	
    if(IsCommand(GetSelectedCapability())){
        m_SendCommandButton.EnableWindow(TRUE);
    } else {
        m_SendCommandButton.EnableWindow(FALSE);
    }
	*pResult = 0;
}

INT CWiacapDlg::GetSelectedCapability()
{
    INT iItem = 0;
    POSITION pos = NULL;
    pos = m_CapablitiesListCtrl.GetFirstSelectedItemPosition();
    if (NULL != pos){        
        iItem = m_CapablitiesListCtrl.GetNextSelectedItem(pos);        
    }
    return iItem;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiatest2\wiaadvanceddocpg.h ===
#if !defined(AFX_WIAADVANCEDDOCPG_H__8BC620B1_DA03_4000_BB52_F960BC270B06__INCLUDED_)
#define AFX_WIAADVANCEDDOCPG_H__8BC620B1_DA03_4000_BB52_F960BC270B06__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// WiaAdvancedDocPg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CWiaAdvancedDocPg dialog

class CWiaAdvancedDocPg : public CPropertyPage
{
	DECLARE_DYNCREATE(CWiaAdvancedDocPg)

// Construction
public:
	IWiaItem *m_pIRootItem;
	CWiaAdvancedDocPg();
	~CWiaAdvancedDocPg();

// Dialog Data
	//{{AFX_DATA(CWiaAdvancedDocPg)
	enum { IDD = IDD_PROPPAGE_ADVANCED_DOCUMENT_SCANNERS_SETTINGS };
	CButton	m_DuplexSetting;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CWiaAdvancedDocPg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CWiaAdvancedDocPg)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_WIAADVANCEDDOCPG_H__8BC620B1_DA03_4000_BB52_F960BC270B06__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiatest2\wiacapdlg.h ===
#if !defined(AFX_WIACAPDLG_H__914888B1_84BF_4F3E_894F_DC6B67A568B1__INCLUDED_)
#define AFX_WIACAPDLG_H__914888B1_84BF_4F3E_894F_DC6B67A568B1__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// WiacapDlg.h : header file
//

#define ITEMPROPERTYLISTCTRL_COLUMN_CAPABILITYNAME        0
#define ITEMPROPERTYLISTCTRL_COLUMN_CAPABILITYDESCRIPTION 1
#define ITEMPROPERTYLISTCTRL_COLUMN_CAPABILITYTYPE        2
#define ITEMPROPERTYLISTCTRL_COLUMN_CAPABILITYVALUE       3

/////////////////////////////////////////////////////////////////////////////
// CWiacapDlg dialog

class CWiacapDlg : public CDialog
{
// Construction
public:
	BOOL m_bCommandSent;
	INT GetSelectedCapability();
	void GetCommandGUID(INT iItem, GUID *pguid);
	BOOL IsCommand(INT iItem);
	void SetIWiaItem(IWiaItem *pIWiaItem);
	CWiacapDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CWiacapDlg)
	enum { IDD = IDD_CAPABILITIES_DIALOG };
	CButton	m_SendCommandButton;
	CListCtrl	m_CapablitiesListCtrl;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CWiacapDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CWiacapDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnClose();
	afx_msg void OnSendCommandButton();
	afx_msg void OnClickCapabilitiesListctrl(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnItemchangedCapabilitiesListctrl(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
private:
	LONG m_NumCaps;
	IWiaItem *m_pIWiaItem;
	void AddCapabilitiesToListBox(LONG lType);
	void SetupColumnHeaders();
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_WIACAPDLG_H__914888B1_84BF_4F3E_894F_DC6B67A568B1__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiatest2\wiadbg.h ===
#pragma once
// this is incompatible with stidebug.h, so don't include stidebug.h
#define _STIDEBUG_H_ 
#undef ASSERT
#undef REQUIRE
#undef DPRINTF
#undef DPRINTF2
#undef DPRINTF_NOINFO

//
// predefined bits in debug flags
//

// something is really wrong, should not go unnoticed
#define COREDBG_ERRORS                  0x00000001

// something that may be of interest to debugging person
#define COREDBG_WARNINGS                0x00000002

// trace random low-priority things with DBG_TRC
#define COREDBG_TRACES                  0x00000004

// trace function entries, exits (if so equipped) 
// with DBG_FN
#define COREDBG_FNS                     0x00000008

// break on errors
#define COREDBG_BREAK_ON_ERRORS         0x80000000

// log to file (default) 
#define COREDBG_DONT_LOG_TO_FILE        0x40000000

// log to debugger (default)
#define COREDBG_DONT_LOG_TO_DEBUGGER    0x20000000


// debug log is saved to this file 
#define COREDBG_FILE_NAME "%systemroot%\\wiatest.log"
// registry key location
#define COREDBG_FLAGS_REGKEY "System\\CurrentControlSet\\Control\\StillImage\\Debug"
// registry DWORD value name
#define COREDBG_FLAGS_REGVAL "DebugFlags"
// registry DWORD for max log file size
#define COREDBG_REGVAL_FILE_SIZE_LIMIT "DebugFileSizeLimit"
#define COREDBG_FILE_SIZE_LIMIT (512 * 1024) // bytes

#ifdef DEBUG
// by default, log errors only in debug builds
#define COREDBG_DEFAULT_FLAGS COREDBG_ERRORS
#else
// by default log nothing in free builds
#define COREDBG_DEFAULT_FLAGS 0
#endif

/****************************************************************************

HOW TO USE WIA CORE DEBUG (main macros)
======================================

- DBG_INIT(hInstance)
  Call from WinMain or DllMain to enable debug flags on a per module
  basis.  If you don't call it, all DLLs will inherit the debug flags
  of the process that creates them.

- DBG_ERR(("Something happened, hr = 0x%x", hr));
  Use when an error condition occurred.
  
- DBG_WRN(("Warning, something happening, Value=%d", iValue));
  Use in a situation warranting a warning.
  
- DBG_TRC(("Random trace statement, Value=%s", szValue));
  Use sparingly to trace certain parts of your code.  Minimize spew!!!
  
- DBG_PRT(("Output without standard File,Line,ThreadID info, Value=%d", iValue));
  Same as DBG_TRC, but doesn't output the File,Line,ThreadID line.  
  ***Use this only if you are doing some special formatting (use sparingly)***
  
- DBG_FN(FnName)
  Tracks entry and exits from a given scope.
  
- CHECK_NOERR   (VarName)
  CHECK_NOERR2  (VarName, (YourMsg,...))
  Does GetLastError and if not 0, outputs error.
    
- CHECK_S_OK    (hr)
  CHECK_S_OK2   (hr, (YourMsg,...))
  Checks if hr == S_OK, if not, outputs error.
    
- CHECK_SUCCESS (lResult)
  CHECK_SUCCESS2(lResult, (YourMsg,...))
  Checks if lResult == ERROR_SUCCESS, if not, outputs error.
    
- REQUIRE_NOERR   (VarName)
  REQUIRE_NOERR2  (VarName, (YourMsg,...))
  Same as equivalent CHECK_* macros above, but calls "goto Cleanup" as well
  
- REQUIRE_S_OK    (hr)
  REQUIRE_S_OK2   (hr, (YourMsg,...))
  Same as equivalent CHECK_* macros above, but calls "goto Cleanup" as well
  
- REQUIRE_SUCCESS (lResult)
  REQUIRE_SUCCESS2(lResult, (YourMsg,...))
  Same as equivalent CHECK_* macros above, but calls "goto Cleanup" as well    
  
HOW TO TURN ON WIA CORE DEBUG (3 ways)
======================================

1) Set registry HKLM\System\CurrentControlSet\Control\StillImage\Debug\<ModuleName>, 
   DWORD value "DebugFlags" to an OR'd value of above COREDBG_* flags.  
   Need to restart app to pick up new settings. Key is auto created the first time
   the app is run.  (Note: <ModuleName> above is the name 
   of your DLL or EXE.  e.g. wiavusd.dll has a registry key of 
   "HKLM\System\CurrentControlSet\Control\StillImage\Debug\wiavusd.dll")

                            OR

2) In the debugger, set g_dwDebugFlags to OR'd value of COREDBG_* flags above.
   You can do this anytime during the debug session.
   
                            OR

3) Call in your code WIA_SET_FLAGS(COREDBG_ERRORS | COREDBG_WARNINGS | COREDBG_TRACES);
   or any combo of the COREDBG_* flags.
   
*****************************************************************************/


#define DBG_INIT(x) DINIT(x)
#define DBG_ERR(x)  DPRINTF(COREDBG_ERRORS, x)
#define DBG_WRN(x)  DPRINTF(COREDBG_WARNINGS, x)
#define DBG_TRC(x)  DPRINTF(COREDBG_TRACES, x)
#define DBG_PRT(x)  DPRINTF_NOINFO(COREDBG_TRACES, x)
#define DBG_SET_FLAGS(x) g_dwDebugFlags = (x)

#ifdef __cplusplus
extern "C" {
#endif

    //
    // accessible to your startup code and at runtime in debugger
    // defined in wia\common\stirt\coredbg.cpp
    //
    extern DWORD  g_dwDebugFlags; 
    extern HANDLE g_hDebugFile;
    extern DWORD  g_dwDebugFileSizeLimit;
    extern BOOL   g_bDebugInited;
    void CoreDbgTrace(LPCSTR fmt, ...);
    void CoreDbgTraceWithTab(LPCSTR fmt, ...);
    void CoreDbgInit(HINSTANCE hInstance);


#ifdef DEBUG

#define DINIT(x) CoreDbgInit(x)

#define ASSERT(x) \
    if(!(x)) { \
        DWORD threadId = GetCurrentThreadId(); \
        CoreDbgTrace("WIA: [%s(%d): Thread 0x%X (%d)]", __FILE__, __LINE__, threadId, threadId, #x); \
        CoreDbgTraceWithTab("ASSERT FAILED. '%s'", #x); \
        DebugBreak(); \
    }

    
#undef VERIFY
#define VERIFY(x) ASSERT(x)
#define REQUIRE(x) ASSERT(x)
    
#define DPRINTF(flags, x) \
    if(!g_bDebugInited) \
    { \
        CoreDbgInit(NULL); \
    } \
    if(flags & g_dwDebugFlags) { \
        DWORD threadId = GetCurrentThreadId(); \
        CoreDbgTrace("WIA: [%s(%d): Thread 0x%X (%d)]", __FILE__, __LINE__, threadId, threadId); \
        CoreDbgTraceWithTab x; \
        if((flags & COREDBG_ERRORS) && (g_dwDebugFlags & COREDBG_BREAK_ON_ERRORS)) { \
            DebugBreak(); \
        } \
    }
    
#define DPRINTF2(flags, x, y) \
    if(!g_bDebugInited) \
    { \
        CoreDbgInit(NULL); \
    } \
    if (flags & g_dwDebugFlags) { \
        DWORD threadId = GetCurrentThreadId(); \
        CoreDbgTrace("WIA: [%s(%d): Thread 0x%X (%d)]", __FILE__, __LINE__, threadId, threadId); \
        CoreDbgTraceWithTab x; \
        CoreDbgTraceWithTab y; \
        if((flags & COREDBG_ERRORS) && (g_dwDebugFlags & COREDBG_BREAK_ON_ERRORS)) { \
            DebugBreak(); \
        } \
    }
    
#define DPRINTF_NOINFO(flags, x) \
    if(!g_bDebugInited) \
    { \
        CoreDbgInit(NULL); \
    } \
    if (flags & g_dwDebugFlags) { \
        CoreDbgTraceWithTab x; \
        if((flags & COREDBG_ERRORS) && (g_dwDebugFlags & COREDBG_BREAK_ON_ERRORS)) { \
            DebugBreak(); \
        } \
    }

#ifdef __cplusplus
#define DBG_FN(x) CoreDbgFn __CoreDbgFnObject(#x)
#else
#define DBG_FN(x) 
#endif
        

#else // begin NODEBUG

#define DINIT(x)    
#define ASSERT(x)
#undef VERIFY
#define VERIFY(x) x
#define REQUIRE(x) x    

#define DPRINTF(flags, x) \
    if(flags & g_dwDebugFlags) { \
        CoreDbgTraceWithTab x; \
    }
    
#define DPRINTF2(flags, x, y) \
    if(flags & g_dwDebugFlags) { \
        CoreDbgTraceWithTab x; \
        CoreDbgTraceWithTab y; \
    }

#define DPRINTF_NOINFO(flags, x) \
    if(flags & g_dwDebugFlags) { \
        CoreDbgTraceWithTab x; \
    }

#ifdef __cplusplus
#define DBG_FN(x) CoreDbgFn __CoreDbgFnObject(#x)
#else
#define DBG_FN(x) 
#endif

#endif // end NODEBUG

#define COREDBG_MFMT_FLAGS (FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_FROM_SYSTEM | \
    FORMAT_MESSAGE_MAX_WIDTH_MASK)

#define REQUIRE_NOERR(x) \
    if(!(x)) { \
        DWORD __dwCoreDbgLastError = GetLastError(); \
        CHAR szError[80]; \
        if(!FormatMessageA(COREDBG_MFMT_FLAGS, NULL, __dwCoreDbgLastError, 0, szError, 80, NULL)) \
        { \
            wsprintfA(szError, "Unknown error"); \
        } \
        DBG_ERR(("ERROR: %s = %d (0x%08X), '%s'", #x, __dwCoreDbgLastError, __dwCoreDbgLastError, szError)); \
        goto Cleanup; \
    }

#define REQUIRE_NOERR2(x, y) \
    if(!(x)) { \
        DWORD __dwCoreDbgLastError = GetLastError(); \
        CHAR szError[80]; \
        if(!FormatMessageA(COREDBG_MFMT_FLAGS, NULL, __dwCoreDbgLastError, 0, szError, 80, NULL)) \
        { \
            wsprintfA(szError, "Unknown error"); \
        } \
        DPRINTF2(COREDBG_ERRORS, ("ERROR: %s = %d (0x%08X), '%s'", #x, __dwCoreDbgLastError, __dwCoreDbgLastError, szError), y); \
        goto Cleanup; \
    }
    
#define REQUIRE_S_OK(x) { \
    HRESULT __hrCoreDbg = S_OK; \
    __hrCoreDbg = (x); \
    if(__hrCoreDbg != S_OK) { \
        CHAR szError[80]; \
        if(!FormatMessageA(COREDBG_MFMT_FLAGS, NULL, __hrCoreDbg, 0, szError, 80, NULL)) \
        { \
            wsprintfA(szError, "Unknown hr"); \
        } \
        DBG_ERR(("ERROR: %s = 0x%08X, '%s'", #x, __hrCoreDbg, szError)); \
        goto Cleanup; \
    } \
}

#define REQUIRE_S_OK2(x,y) { \
    HRESULT __hrCoreDbg = S_OK; \
    __hrCoreDbg = (x); \
    if(__hrCoreDbg != S_OK) { \
        CHAR szError[80]; \
        if(!FormatMessageA(COREDBG_MFMT_FLAGS, NULL, __hrCoreDbg, 0, szError, 80, NULL)) \
        { \
            wsprintfA(szError, "Unknown hr"); \
        } \
        DPRINTF2(COREDBG_ERRORS, ("ERROR: %s = 0x%08X, '%s'", #x, __hrCoreDbg, szError), y); \
        goto Cleanup; \
    } \
} 

#define REQUIRE_SUCCESS(x) { \
    UINT __resultCoreDbg = (x); \
    if(__resultCoreDbg != ERROR_SUCCESS) { \
        CHAR szError[80]; \
        if(!FormatMessageA(COREDBG_MFMT_FLAGS, NULL, __resultCoreDbg, 0, szError, 80, NULL)) \
        { \
            wsprintfA(szError, "Unknown error"); \
        } \
        DBG_ERR(("ERROR: %s = 0x%08X, '%s'", #x, __resultCoreDbg, szError)); \
        goto Cleanup; \
    } \
} 

#define REQUIRE_SUCCESS2(x, y) { \
    UINT __resultCoreDbg = (x); \
    if(__resultCoreDbg != ERROR_SUCCESS) { \
        CHAR szError[80]; \
        if(!FormatMessageA(COREDBG_MFMT_FLAGS, NULL, __resultCoreDbg, 0, szError, 80, NULL)) \
        { \
            wsprintfA(szError, "Unknown error"); \
        } \
        DPRINTF2(COREDBG_ERRORS, ("ERROR: %s = 0x%08X, '%s'", #x, __resultCoreDbg, szError), y); \
        goto Cleanup; \
    } \
} 

#define CHECK_NOERR(x) \
    if(!(x)) { \
        DWORD __dwCoreDbgLastError = GetLastError(); \
        CHAR szError[80]; \
        if(!FormatMessageA(COREDBG_MFMT_FLAGS, NULL, __dwCoreDbgLastError, 0, szError, 80, NULL)) \
        { \
            wsprintfA(szError, "Unknown error"); \
        } \
        DBG_ERR(("ERROR: %s = %d (0x%08X), '%s'", #x, __dwCoreDbgLastError, __dwCoreDbgLastError, szError)); \
    }

#define CHECK_NOERR2(x, y) \
    if(!(x)) { \
        DWORD dwCoreDbgLastError = GetLastError(); \
        CHAR szError[80]; \
        if(!FormatMessageA(COREDBG_MFMT_FLAGS, NULL, __dwCoreDbgLastError, 0, szError, 80, NULL)) \
        { \
            wsprintfA(szError, "Unknown error", __dwCoreDbgLastError, __dwCoreDbgLastError); \
        } \
        DPRINTF2(COREDBG_ERRORS, ("ERROR: %s = %d (0x%08X), '%s'", #x, __dwCoreDbgLastError, szError), y); \
    }

#define CHECK_S_OK(x) { \
    HRESULT __hrCoreDbg = S_OK; \
    __hrCoreDbg = (x); \
    if(__hrCoreDbg != S_OK) { \
        CHAR szError[80]; \
        if(!FormatMessageA(COREDBG_MFMT_FLAGS, NULL, __hrCoreDbg, 0, szError, 80, NULL)) \
        { \
            wsprintfA(szError, "Unknown hr"); \
        } \
        DBG_ERR(("ERROR: %s = 0x%08X, '%s'", #x, __hrCoreDbg, szError)); \
    } \
}

#define CHECK_S_OK2(x,y) { \
    HRESULT __hrCoreDbg = S_OK; \
    __hrCoreDbg = (x); \
    if(__hrCoreDbg != S_OK) { \
        CHAR szError[80]; \
        if(!FormatMessageA(COREDBG_MFMT_FLAGS, NULL, __hrCoreDbg, 0, szError, 80, NULL)) \
        { \
            wsprintfA(szError, "Unknown hr"); \
        } \
        DPRINTF2(COREDBG_ERRORS, ("ERROR: %s = 0x%08X, '%s'", #x, __hrCoreDbg, szError), y); \
    } \
}

#define CHECK_SUCCESS(x) { \
    UINT __resultCoreDbg = (x); \
    if(__resultCoreDbg != ERROR_SUCCESS) { \
        CHAR szError[80]; \
        if(!FormatMessageA(COREDBG_MFMT_FLAGS, NULL, __resultCoreDbg, 0, szError, 80, NULL)) \
        { \
            wsprintfA(szError, "Unknown error"); \
        } \
        DBG_ERR(("ERROR: %s = 0x%08X, '%s'", #x, __resultCoreDbg, szError)); \
    } \
} 

#define CHECK_SUCCESS2(x, y) { \
    UINT __resultCoreDbg = (x); \
    if(__resultCoreDbg != ERROR_SUCCESS) { \
        CHAR szError[80]; \
        if(!FormatMessageA(COREDBG_MFMT_FLAGS, NULL, __resultCoreDbg, 0, szError, 80, NULL)) \
        { \
            wsprintfA(szError, "Unknown error"); \
        } \
        DPRINTF2(COREDBG_ERRORS, ("ERROR: %s = 0x%08X, '%s'", #x, __resultCoreDbg, szError), y); \
    } \
} 

#ifdef __cplusplus
    class CoreDbgFn {
    private:
        LPCSTR m_fn;
        DWORD m_threadId;
    public:

        CoreDbgFn(LPCSTR fn)
        { 
            m_fn = fn;
            m_threadId = GetCurrentThreadId();
            if(!g_bDebugInited) 
            {
                CoreDbgInit(NULL);
            }
            if(g_dwDebugFlags & COREDBG_FNS) 
            {
                CoreDbgTraceWithTab("WIA: Thread 0x%X (%d) Entering %s", m_threadId, m_threadId, m_fn);
            }
        } 
        
        ~CoreDbgFn() 
        { 
            if(g_dwDebugFlags & COREDBG_FNS) 
            {
                CoreDbgTraceWithTab("WIA: Thread 0x%X (%d) Leaving  %s", m_threadId, m_threadId, m_fn); 
            }
        }
    };
#endif



#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiatest2\wiadbg.cpp ===
#include "stdafx.h"

// don't log at all
#define COREDBG_DONT_LOG (COREDBG_DONT_LOG_TO_FILE | COREDBG_DONT_LOG_TO_DEBUGGER)

// globals
DWORD  g_dwDebugFlags         = COREDBG_DEFAULT_FLAGS;
HANDLE g_hDebugFile           = INVALID_HANDLE_VALUE;
DWORD  g_dwDebugFileSizeLimit = COREDBG_FILE_SIZE_LIMIT;
BOOL   g_bDebugInited         = FALSE;

static CHAR   g_szDebugFileName[MAX_PATH] = { 0 };
static CHAR   g_szModuleName[MAX_PATH]    = { 0 };
static HANDLE g_hDebugFileMutex           = NULL;
static BOOL   g_bInited                   = FALSE;
static BOOL   g_bBannerPrinted            = FALSE;

#undef TRACE
#ifdef DEBUG
#define TRACE(x) InternalTrace x
#else
#define TRACE(x)
#endif

////////////////////////////////////////////////
// InternalTrace
//
// Internal tracing for problems in CoreDbgWrite
//
static void InternalTrace(LPCSTR fmt, ...)
{
    char buffer[1024];
    size_t len = 0;
    va_list marker;

    va_start(marker, fmt);

    _vsnprintf(buffer, 1024, fmt, marker);
    len = strlen(buffer);
    if(len > 0) 
    {
        // make sure the line has terminating "\n"
        if(buffer[len - 1] != '\n') {
            buffer[len++] = '\n';
            buffer[len] = '\0';
        }
        OutputDebugStringA(buffer);
    }

    va_end(marker);
}

////////////////////////////////////////////////
// CoreDbgWrite
//
// Writes specified number of bytes to a debug 
// file, creating it if needed. Thread-safe. 
// Registers any failure and from that point returns 
// immediately.
//
static void 
CoreDbgWrite(LPCSTR buffer, DWORD n)
{
#undef CHECK
#define CHECK(x) if(!(x)) { \
    TRACE(("%s(%d): %s failed (%d)", __FILE__, __LINE__, #x, GetLastError())); \
    bCatastrophicFailure = TRUE; goto Cleanup; } 
#undef CHECK2
#define CHECK2(x, y) if(!(x)) { \
    TRACE(("%s(%d): %s failed (%d)", __FILE__, __LINE__, #x, GetLastError())); \
    TRACE(y); bCatastrophicFailure = TRUE; goto Cleanup; } 

    DWORD cbWritten;
    LARGE_INTEGER newPos = { 0, 0 };
    static BOOL bCatastrophicFailure = FALSE;
    BOOL bMutexAcquired = FALSE;

    // if something is broken, return immediately
    if(bCatastrophicFailure) return;

    // make sure we have file mutex
    if(!g_hDebugFileMutex) 
    {
        CHECK((g_hDebugFileMutex = CreateMutexA(NULL, FALSE, "Global\\WiaDebugFileMut")) != NULL);
    }

    // acquire mutex
    CHECK(WaitForSingleObject(g_hDebugFileMutex, INFINITE) != WAIT_FAILED);

    bMutexAcquired = TRUE;

    // make sure we have open file
    if(g_hDebugFile == INVALID_HANDLE_VALUE)
    {
        // attempt to open file
        CHECK(ExpandEnvironmentStringsA(COREDBG_FILE_NAME, g_szDebugFileName, MAX_PATH));

        g_hDebugFile = CreateFileA(g_szDebugFileName, GENERIC_WRITE, 
            FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

        CHECK2(g_hDebugFile != INVALID_HANDLE_VALUE, 
            ("g_szDebugFileName = '%s'", g_szDebugFileName)); 
    }

    // seek to the end of file
    CHECK(SetFilePointerEx(g_hDebugFile, newPos, &newPos, SEEK_END));

    // check the file size
    if(newPos.HighPart != 0 || newPos.LowPart > g_dwDebugFileSizeLimit)
    {
        static CHAR LogFullMessage[128];

        TRACE(("Reached log file maximum size of %d", g_dwDebugFileSizeLimit));

        sprintf(LogFullMessage, "Log file reached maximum size of %d, logging stopped.", g_dwDebugFileSizeLimit);
        CHECK2(WriteFile(g_hDebugFile, LogFullMessage, strlen(LogFullMessage), &cbWritten, NULL), ("%d", cbWritten));
        bCatastrophicFailure = TRUE;
    }

    // write data
    CHECK2(WriteFile(g_hDebugFile, buffer, n, &cbWritten, NULL),
        ("%d %d", cbWritten, n));

    // make sure we write to the disk now.
    FlushFileBuffers(g_hDebugFile);

    CHECK2(cbWritten == n, ("%d %d", n, cbWritten))

Cleanup:
    if(bMutexAcquired) ReleaseMutex(g_hDebugFileMutex);
    return;
}

////////////////////////////////////////////////
// PrintBanner
//
// Since we append to the log file, we need a 
// seperator of some sort so we know when a 
// new execution has started.
//
void PrintBanner(void)
{
    char buffer[1024];
    size_t len = 0;

    SYSTEMTIME SysTime;
    GetLocalTime(&SysTime);

    if (g_dwDebugFlags)
    {
        _snprintf(buffer, sizeof(buffer), 
                  "====================Start '%s' Debug - Time: %d/%02d/%02d %02d:%02d:%02d:%02d====================",
                  g_szModuleName,
                  SysTime.wYear,
                  SysTime.wMonth,
                  SysTime.wDay,
                  SysTime.wHour,
                  SysTime.wMinute,
                  SysTime.wSecond,
                  SysTime.wMilliseconds);
    }

    len = strlen(buffer);
    if(len > 0) 
    {
        // make sure the line has terminating "\n"
        if(buffer[len - 1] != '\n') 
        {
            buffer[len++] = '\r';
            buffer[len++] = '\n';
            buffer[len] = '\0';
        }

        if(!(g_dwDebugFlags & COREDBG_DONT_LOG_TO_FILE))
        {
            CoreDbgWrite(buffer, len);
        }

#ifdef DEBUG
        if(!(g_dwDebugFlags & COREDBG_DONT_LOG_TO_DEBUGGER))
        {
            OutputDebugStringA(buffer);
        }
#endif
    }

    return;
}


////////////////////////////////////////////////
// CoreDbgGenericTrace
//
// Formats message and writes it into log file 
// and/or debugger;
//
void CoreDbgGenericTrace(LPCSTR     fmt, 
                         va_list    marker,
                         BOOL       bIndent)
{
    char buffer[1024];
    size_t len = 0;

    //
    // The first time we ever print a debug statement, lets 
    // output a seperator line since when we output to file
    // we append, this way we can seperate different execution
    // sessions.
    //
    if (!g_bBannerPrinted)
    {
        PrintBanner();
        g_bBannerPrinted = TRUE;
    }

    if (bIndent)
    {
        buffer[0] = '\t';
        _vsnprintf(&buffer[1], 1023, fmt, marker);
    }
    else
    {
        _vsnprintf(buffer, 1024, fmt, marker);
    }

    len = strlen(buffer);
    if(len > 0) 
    {
        // make sure the line has terminating "\n"
        if(buffer[len - 1] != '\n') 
        {
            buffer[len++] = '\r';
            buffer[len++] = '\n';
            buffer[len] = '\0';
        }

        if(!(g_dwDebugFlags & COREDBG_DONT_LOG_TO_FILE))
        {
            CoreDbgWrite(buffer, len);
        }

#ifdef DEBUG
        if(!(g_dwDebugFlags & COREDBG_DONT_LOG_TO_DEBUGGER))
        {
            OutputDebugStringA(buffer);
        }
#endif
    }
}


////////////////////////////////////////////////
// CoreDbgTrace
//
// Formats message and writes it into log file 
// and/or debugger;
//
void CoreDbgTrace(LPCSTR fmt, ...)
{
    va_list marker;

    // get out if we don't have to log
#ifdef DEBUG
    if((g_dwDebugFlags & COREDBG_DONT_LOG) == COREDBG_DONT_LOG)
#else
    if(g_dwDebugFlags & COREDBG_DONT_LOG_TO_FILE)
#endif
    {
        return;
    }

    va_start(marker, fmt);

    CoreDbgGenericTrace(fmt, marker, FALSE);

    va_end(marker);
}

////////////////////////////////////////////////
// CoreDbgTraceWithTab
//
// Formats message and writes it into log file 
// and/or debugger;
//
void CoreDbgTraceWithTab(LPCSTR fmt, ...)
{
    va_list marker;

    // get out if we don't have to log
#ifdef DEBUG
    if((g_dwDebugFlags & COREDBG_DONT_LOG) == COREDBG_DONT_LOG)
#else
    if(g_dwDebugFlags & COREDBG_DONT_LOG_TO_FILE)
#endif
    {
        return;
    }

    va_start(marker, fmt);

    CoreDbgGenericTrace(fmt, marker, TRUE);

    va_end(marker);
}

////////////////////////////////////////////////
// GetRegDWORD
//
// Attempts to get a DWORD from the specified
// location.  If bSetIfNotExist is set, it 
// writes the registry setting to the current
// value in pdwValue.
//
LRESULT GetRegDWORD(HKEY        hKey,
                    const CHAR  *pszRegValName,
                    DWORD       *pdwValue,
                    BOOL        bSetIfNotExist)
{
    LRESULT lResult = ERROR_SUCCESS;
    DWORD   dwSize  = 0;
    DWORD   dwType  = REG_DWORD;

    if ((hKey          == NULL) ||
        (pszRegValName == NULL) ||
        (pdwValue      == NULL))
    {
        return ERROR_INVALID_HANDLE;
    }

    dwSize = sizeof(DWORD);

    lResult = RegQueryValueExA(hKey, 
                               pszRegValName, 
                               NULL, 
                               &dwType,
                               (BYTE*) pdwValue, 
                               &dwSize);

    // if we didn't find the key, create it.
    if (bSetIfNotExist)
    {
        if ((lResult != ERROR_SUCCESS) || 
            (dwType  != REG_DWORD))
        {
            lResult = RegSetValueExA(hKey, 
                                     pszRegValName, 
                                     0, 
                                     REG_DWORD, 
                                     (BYTE*) pdwValue, 
                                     dwSize);
        }
    }

    return lResult;
}

////////////////////////////////////////////////
// CoreDbgInit
//
// Overwrite g_dwDebugFlags and g_dwDebugFileSizeLimit 
// from registry
//
void CoreDbgInit(HINSTANCE  hInstance)
{
    HKEY        hKey         = NULL;
    DWORD       dwDispositon = 0;
    DWORD       dwData;
    SYSTEMTIME  SysTime;
    DWORD       dwDisposition               = 0;
    CHAR        szModulePath[MAX_PATH + 1]  = {0};
    CHAR        szDebugKey[1023 + 1]        = {0};
    CHAR        *pszFileName                = NULL;

    GetModuleFileNameA(hInstance, szModulePath, sizeof(szModulePath));
    pszFileName = strrchr(szModulePath, '\\');

    if (pszFileName == NULL) 
    {
        pszFileName = szModulePath;
    } 
    else 
    {
        pszFileName++;
    }

    //
    // build the registry key.
    //
    _snprintf(szDebugKey, sizeof(szDebugKey), "%s\\%s", COREDBG_FLAGS_REGKEY, pszFileName);
    lstrcpynA(g_szModuleName, pszFileName, sizeof(g_szModuleName));

    //
    // get/set the debug subkey.  The DebugValues value is stored on a per module
    // basis
    //
    if(RegCreateKeyExA(HKEY_LOCAL_MACHINE,
        szDebugKey,
        0,
        NULL,
        0,
        KEY_READ | KEY_WRITE,
        NULL,
        &hKey,
        &dwDisposition) == ERROR_SUCCESS) 
    {
        dwData = g_dwDebugFlags;

        if (GetRegDWORD(hKey, COREDBG_FLAGS_REGVAL, &dwData, TRUE) == ERROR_SUCCESS)
        {
            g_dwDebugFlags = dwData;
        }

        RegCloseKey(hKey);
        hKey = NULL;
    }

    //
    // get/set the Max File Size value.  This is global to all debug modules since
    // the all write to the same file.
    //
    if(RegCreateKeyExA(HKEY_LOCAL_MACHINE,
        COREDBG_FLAGS_REGKEY,
        0,
        NULL,
        0,
        KEY_READ | KEY_WRITE,
        NULL,
        &hKey,
        &dwDisposition) == ERROR_SUCCESS) 
    {
        dwData = g_dwDebugFileSizeLimit;

        if (GetRegDWORD(hKey, COREDBG_REGVAL_FILE_SIZE_LIMIT, &dwData, TRUE) == ERROR_SUCCESS)
        {
            g_dwDebugFileSizeLimit = dwData;
        }

        RegCloseKey(hKey);
        hKey = NULL;
    }

    g_bDebugInited = TRUE;

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiatest2\wiadatacallback.cpp ===
// WiaDataCallback.cpp: implementation of the CWiaDataCallback class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "wiatest.h"
#include "WiaDataCallback.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CWiaDataCallback::CWiaDataCallback()
{
    m_cRef              = 0;
    m_pBuffer           = NULL;
    m_BytesTransferred  = 0;    
    m_pAcquireDlg       = NULL;    
    m_lBufferSize       = 65535; // default
    m_bBitmapData       = FALSE;
    m_bNewPageArrived   = TRUE;

    // initialize progress dialog
    m_pAcquireDlg = new CWiaAcquireDlg();
    if(m_pAcquireDlg){
        m_pAcquireDlg->Create(IDD_DATA_ACQUISITION_DIALOG,NULL);
        m_pAcquireDlg->ShowWindow(TRUE);
    }
}

CWiaDataCallback::~CWiaDataCallback()
{
    if (m_pBuffer != NULL){
        LocalFree(m_pBuffer);
        m_pBuffer = NULL;
    }
    if(m_pAcquireDlg){
        m_pAcquireDlg->DestroyWindow();
        delete m_pAcquireDlg;
        m_pAcquireDlg = NULL;
    }
}

HRESULT _stdcall CWiaDataCallback::QueryInterface(const IID& iid, void** ppv)
{
    *ppv = NULL;
    if (iid == IID_IUnknown || iid == IID_IWiaDataCallback)
        *ppv = (IWiaDataCallback*) this;
    else
        return E_NOINTERFACE;
    AddRef();
    return S_OK;
}

ULONG   _stdcall CWiaDataCallback::AddRef()
{
    InterlockedIncrement((long*) &m_cRef);
    return m_cRef;
}

ULONG   _stdcall CWiaDataCallback::Release()
{
    ULONG ulRefCount = m_cRef - 1;
    if (InterlockedDecrement((long*) &m_cRef) == 0)
    {
        delete this;
        return 0;
    }
    return ulRefCount;
}

HRESULT _stdcall CWiaDataCallback::BandedDataCallback(LONG lMessage, LONG lStatus,
                                                      LONG lPercentComplete, LONG  lOffset,
                                                      LONG lLength, LONG lReserved, LONG lResLength, BYTE* pbBuffer)
{
    // check for cancel button presses
    if(m_pAcquireDlg->CheckCancelButton()){
        return S_FALSE;
    }

    PWIA_DATA_CALLBACK_HEADER pHeader = NULL;
    switch (lMessage) {
    case IT_MSG_DATA_HEADER:
        pHeader = (PWIA_DATA_CALLBACK_HEADER)pbBuffer;
        if(pHeader->guidFormatID == WiaImgFmt_MEMORYBMP){
            m_bBitmapData = TRUE;
        }
        m_MemBlockSize      = pHeader->lBufferSize;                
        if(m_MemBlockSize <= 0)
            m_MemBlockSize = m_lBufferSize;
        
        m_pBuffer           = (PBYTE)LocalAlloc(LPTR,m_MemBlockSize);
        m_BytesTransferred  = 0;
        UpdateAcqusitionDialog(TEXT("IT_MSG_DATA_HEADER"),lPercentComplete);
        break;        
    case IT_MSG_DATA:
        if(m_bNewPageArrived){
            m_BytesTransferred = 0;
            m_bNewPageArrived = FALSE;
        }
        if (m_pBuffer != NULL) {                
            m_BytesTransferred += lLength;
            if(m_BytesTransferred >= m_MemBlockSize){                
                m_MemBlockSize += (lLength * MEMORY_BLOCK_FACTOR);
                m_pBuffer = (PBYTE)LocalReAlloc(m_pBuffer,m_MemBlockSize,LMEM_MOVEABLE);
            }                
            memcpy(m_pBuffer + lOffset, pbBuffer, lLength);
        }                
        UpdateAcqusitionDialog(TEXT("IT_MSG_DATA"),lPercentComplete);        
        break;
    case IT_MSG_STATUS:
        if (lStatus & IT_STATUS_TRANSFER_FROM_DEVICE){
            UpdateAcqusitionDialog(TEXT("IT_MSG_STATUS\n(IT_STATUS_TRANSFER_FROM_DEVICE)"),lPercentComplete);
        } else if (lStatus & IT_STATUS_PROCESSING_DATA){
            UpdateAcqusitionDialog(TEXT("IT_MSG_STATUS\n(IT_STATUS_PROCESSING_DATA)"),lPercentComplete);
        } else if (lStatus & IT_STATUS_TRANSFER_TO_CLIENT) {
            UpdateAcqusitionDialog(TEXT("IT_MSG_STATUS\n(IT_STATUS_TRANSFER_TO_CLIENT)"),lPercentComplete);
        }
        break;        
    case IT_MSG_NEW_PAGE:
        UpdateAcqusitionDialog(TEXT("IT_MSG_NEWPAGE"),0);
        pHeader = (PWIA_DATA_CALLBACK_HEADER)pbBuffer;
        m_lPageCount =  pHeader->lPageCount;        
        m_bNewPageArrived = TRUE;
        break;
    case IT_MSG_FILE_PREVIEW_DATA:
        UpdateAcqusitionDialog(TEXT("IT_MSG_FILE_PREVIEW_DATA"),-1);
        break;
    case IT_MSG_FILE_PREVIEW_DATA_HEADER:
        UpdateAcqusitionDialog(TEXT("IT_MSG_FILE_PREVIEW_DATA_HEADER"),-1);
        break;
    case IT_MSG_TERMINATION:
        UpdateAcqusitionDialog(TEXT("IT_MSG_TERMINATION"),-1);
        break;
    default:
        break;
    }
    return S_OK;
}

void CWiaDataCallback::UpdateAcqusitionDialog(TCHAR *szMessage, LONG lPercentComplete)
{
    m_pAcquireDlg->SetCallbackMessage(szMessage);    
    if(lPercentComplete > -1){
        m_pAcquireDlg->SetPercentComplete(lPercentComplete);
        m_pAcquireDlg->m_AcquireProgressCtrl.SetPos(lPercentComplete);
    }
}

void CWiaDataCallback::SetBufferSizeRequest(LONG lBufferSize)
{
    m_lBufferSize = lBufferSize;
}

BYTE* CWiaDataCallback::GetCallbackMemoryPtr(LONG *plDataSize)
{
    *plDataSize = m_BytesTransferred;
    return m_pBuffer;    
}

BOOL CWiaDataCallback::IsBITMAPDATA()
{
    return m_bBitmapData;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiatest2\wiadatacallback.h ===
// WiaDataCallback.h: interface for the CWiaDataCallback class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_WIADATACALLBACK_H__5125F8A0_29CF_4E4D_9D39_53DF7C29BD88__INCLUDED_)
#define AFX_WIADATACALLBACK_H__5125F8A0_29CF_4E4D_9D39_53DF7C29BD88__INCLUDED_

#include "WiaAcquireDlg.h"	// Added by ClassView
#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define MEMORY_BLOCK_FACTOR 2

class CWiaDataCallback : public IWiaDataCallback
{
public:
	BOOL IsBITMAPDATA();
	BYTE* GetCallbackMemoryPtr(LONG *plDataSize);
	void SetBufferSizeRequest(LONG lBufferSize);
	void SetDialog(CWiaAcquireDlg *pAcquireDlg);
	CWiaAcquireDlg *m_pAcquireDlg;
	CWiaDataCallback();
	virtual ~CWiaDataCallback();
    // IUnknown members that delegate to m_pUnkRef.
    HRESULT _stdcall QueryInterface(const IID&,void**);
    ULONG   _stdcall AddRef();
    ULONG   _stdcall Release();
    HRESULT _stdcall Initialize(HWND hPreviewWnd = NULL);
    HRESULT _stdcall BandedDataCallback(LONG lMessage, LONG lStatus, LONG lPercentComplete,
                                        LONG lOffset, LONG lLength, LONG lReserved,
                                        LONG lResLength, BYTE* pbBuffer);
private:
	void UpdateAcqusitionDialog(TCHAR *szMessage, LONG lPercentComplete);
   ULONG m_cRef;         // Object reference count.  
   PBYTE m_pBuffer;      // complete data buffer
   LONG  m_MemBlockSize;
   LONG  m_BytesTransferred;   
   long  m_lPageCount;
   LONG  m_lBufferSize;
   BOOL  m_bBitmapData;
   BOOL  m_bNewPageArrived;
};

#endif // !defined(AFX_WIADATACALLBACK_H__5125F8A0_29CF_4E4D_9D39_53DF7C29BD88__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiatest2\wiadocacqsettings.cpp ===
// WiaDocAcqSettings.cpp : implementation file
//

#include "stdafx.h"
#include "wiatest.h"
#include "WiaDocAcqSettings.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CWiaDocAcqSettings

IMPLEMENT_DYNAMIC(CWiaDocAcqSettings, CPropertySheet)

CWiaDocAcqSettings::CWiaDocAcqSettings(UINT nIDCaption, CWnd* pParentWnd, UINT iSelectPage)
	:CPropertySheet(nIDCaption, pParentWnd, iSelectPage)
{
    AddPage(&m_SimpleDocumentScannerSettings);
    AddPage(&m_AdvancedDocumentScannerSettings);
}

CWiaDocAcqSettings::CWiaDocAcqSettings(LPCTSTR pszCaption, CWnd* pParentWnd, UINT iSelectPage)
	:CPropertySheet(pszCaption, pParentWnd, iSelectPage)
{
    AddPage(&m_SimpleDocumentScannerSettings);
    AddPage(&m_AdvancedDocumentScannerSettings);
}

CWiaDocAcqSettings::CWiaDocAcqSettings(UINT nIDCaption, IWiaItem *pIRootItem, CWnd* pParentWnd, UINT iSelectPage)
	:CPropertySheet(nIDCaption, pParentWnd, iSelectPage)
{
    AddPage(&m_SimpleDocumentScannerSettings);
    AddPage(&m_AdvancedDocumentScannerSettings);
    m_pIRootItem = pIRootItem;
    m_SimpleDocumentScannerSettings.m_pIRootItem = pIRootItem;
    m_AdvancedDocumentScannerSettings.m_pIRootItem = pIRootItem;
}

CWiaDocAcqSettings::~CWiaDocAcqSettings()
{
}


BEGIN_MESSAGE_MAP(CWiaDocAcqSettings, CPropertySheet)
	//{{AFX_MSG_MAP(CWiaDocAcqSettings)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWiaDocAcqSettings message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiatest2\wiaeditpropdlg.cpp ===
// WiaeditpropDlg.cpp: implementation of the CWiaeditpropDlg class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "wiatest.h"
#include "WiaeditpropDlg.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CWiaeditpropDlg::CWiaeditpropDlg()
{

}

CWiaeditpropDlg::~CWiaeditpropDlg()
{

}

UINT CWiaeditpropDlg::DoModal(TCHAR *szPropertyName, TCHAR *szPropertyValue)
{
    UINT nResponse = 0;
    if(m_ulAttributes & WIA_PROP_NONE){
        CWiaeditpropnone EditPropDlg;
        EditPropDlg.SetPropertyName(szPropertyName);
        EditPropDlg.SetPropertyValue(szPropertyValue);
        TCHAR szFormatting[MAX_PATH];
        memset(szFormatting,0,sizeof(szFormatting));
        if(lstrcmpi(szPropertyName,TEXT("Device Time")) == 0){
            RC2TSTR(IDS_WIATESTINFO_SYSTEMTIME_FORMATTING,szFormatting,sizeof(szFormatting));
        }
        EditPropDlg.SetPropertyFormattingInstructions(szFormatting);
        nResponse = (UINT)EditPropDlg.DoModal();
        m_szPropertyValue = EditPropDlg.m_szPropertyValue;
    } else if(m_ulAttributes & WIA_PROP_LIST){
        CWiaeditproplist EditPropDlg;
        EditPropDlg.SetPropertyName(szPropertyName);
        EditPropDlg.SetPropertyValue(szPropertyValue);
        VALID_LIST_VALUES ValidValues;
        
        ValidValues.vt = m_vt;
        ValidValues.lNumElements = WIA_PROP_LIST_COUNT(m_pPropVar);
        if(ValidValues.vt == VT_CLSID){
            ValidValues.pList = (BYTE*)m_pPropVar->cauuid.pElems;            
        } else {
            ValidValues.pList = (BYTE*)m_pPropVar->caul.pElems;
        }

        EditPropDlg.SetPropertyValidValues(&ValidValues);

        nResponse = (UINT)EditPropDlg.DoModal();
        m_szPropertyValue = EditPropDlg.m_szPropertyValue;
    } else if(m_ulAttributes & WIA_PROP_FLAG){
        CWiaeditpropflags EditPropDlg;
        EditPropDlg.SetPropertyName(szPropertyName);
        EditPropDlg.SetPropertyValue(szPropertyValue);
        if(m_ulAttributes & WIA_PROP_WRITE){
            EditPropDlg.SetPropertyValidValues(m_pPropVar->caul.pElems[WIA_FLAG_VALUES]);
        } else {
            LONG lCurrentValue = 0;            
            TSSCANF(szPropertyValue,"%d",&lCurrentValue);
            EditPropDlg.SetPropertyValidValues(lCurrentValue);
        }
        nResponse = (UINT)EditPropDlg.DoModal();
        m_szPropertyValue = EditPropDlg.m_szPropertyValue;
    } else if(m_ulAttributes & WIA_PROP_RANGE){
        CWiaeditproprange EditPropDlg;        
        EditPropDlg.SetPropertyName(szPropertyName);
        EditPropDlg.SetPropertyValue(szPropertyValue);                
        VALID_RANGE_VALUES ValidValues;        
                                      
        ValidValues.lMin = m_pPropVar->caul.pElems[WIA_RANGE_MIN];
        ValidValues.lMax = m_pPropVar->caul.pElems[WIA_RANGE_MAX];
        ValidValues.lNom = m_pPropVar->caul.pElems[WIA_RANGE_NOM];
        ValidValues.lInc = m_pPropVar->caul.pElems[WIA_RANGE_STEP];

        EditPropDlg.SetPropertyValidValues(&ValidValues);
        nResponse = (UINT)EditPropDlg.DoModal();
        m_szPropertyValue = EditPropDlg.m_szPropertyValue;
    }
    return nResponse;
}

void CWiaeditpropDlg::SetAttributes(ULONG ulAttributes, PROPVARIANT *pPropVar)
{
    m_pPropVar     = pPropVar;
    m_ulAttributes = ulAttributes;
}

void CWiaeditpropDlg::GetPropertyValue(TCHAR *szPropertyValue)
{
    lstrcpy(szPropertyValue,m_szPropertyValue.GetBuffer(MAX_PATH));
}

void CWiaeditpropDlg::SetVarType(VARTYPE vt)
{
    m_vt = vt;
}

VARTYPE CWiaeditpropDlg::GetVarType()
{
    return m_vt;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiatest2\wiadocacqsettings.h ===
#if !defined(AFX_WIADOCACQSETTINGS_H__9A20BD24_5D53_483E_83B3_ABDC2ACB48AE__INCLUDED_)
#define AFX_WIADOCACQSETTINGS_H__9A20BD24_5D53_483E_83B3_ABDC2ACB48AE__INCLUDED_

#include "WiaSimpleDocPg.h"	// Added by ClassView
#include "WiaAdvancedDocPg.h"	// Added by ClassView
#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// WiaDocAcqSettings.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CWiaDocAcqSettings

class CWiaDocAcqSettings : public CPropertySheet
{
	DECLARE_DYNAMIC(CWiaDocAcqSettings)

// Construction
public:
	CWiaDocAcqSettings(UINT nIDCaption, CWnd* pParentWnd = NULL, UINT iSelectPage = 0);
	CWiaDocAcqSettings(LPCTSTR pszCaption, CWnd* pParentWnd = NULL, UINT iSelectPage = 0);
    CWiaDocAcqSettings(UINT nIDCaption, IWiaItem *pIRootItem, CWnd* pParentWnd = NULL, UINT iSelectPage = 0);

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CWiaDocAcqSettings)
	//}}AFX_VIRTUAL

// Implementation
public:
	IWiaItem *m_pIRootItem;
	CWiaAdvancedDocPg m_AdvancedDocumentScannerSettings;
	CWiaSimpleDocPg m_SimpleDocumentScannerSettings;
	virtual ~CWiaDocAcqSettings();

	// Generated message map functions
protected:
	//{{AFX_MSG(CWiaDocAcqSettings)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_WIADOCACQSETTINGS_H__9A20BD24_5D53_483E_83B3_ABDC2ACB48AE__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiatest2\wiaeditpropdlg.h ===
// WiaeditpropDlg.h: interface for the CWiaeditpropDlg class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_WIAEDITPROPDLG_H__680CD709_25B9_495E_9FAA_BECB0F97A333__INCLUDED_)
#define AFX_WIAEDITPROPDLG_H__680CD709_25B9_495E_9FAA_BECB0F97A333__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "wiaeditpropflags.h"
#include "wiaeditpropnone.h"
#include "wiaeditproplist.h"
#include "wiaeditproprange.h"

class CWiaeditpropDlg  
{
public:	
	void SetAttributes(ULONG ulAttributes,  PROPVARIANT *pPropVar);
    void SetVarType(VARTYPE vt);
    VARTYPE GetVarType();
    void GetPropertyValue(TCHAR *szPropertyValue);
	UINT DoModal(TCHAR *szPropertyName, TCHAR *szPropertyValue);
	CWiaeditpropDlg();
	virtual ~CWiaeditpropDlg();

private:
    VARTYPE m_vt;               // variant type
	PROPVARIANT *m_pPropVar;    // valid values propvariant( IN )
    ULONG m_ulAttributes;       // attributes
    CString m_szPropertyValue;  // property value
};

#endif // !defined(AFX_WIAEDITPROPDLG_H__680CD709_25B9_495E_9FAA_BECB0F97A333__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiatest2\wiaeditpropflags.h ===
#if !defined(AFX_WIAEDITPROPFLAGS_H__4A3D69F0_06C3_490F_8467_AFB74772B6C3__INCLUDED_)
#define AFX_WIAEDITPROPFLAGS_H__4A3D69F0_06C3_490F_8467_AFB74772B6C3__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// Wiaeditpropflags.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CWiaeditpropflags dialog

class CWiaeditpropflags : public CDialog
{
// Construction
public:
    void AddValidValuesToListBox();
    void SelectCurrentValue();
    void SetPropertyName(TCHAR *szPropertyName);
    void SetPropertyValue(TCHAR *szPropertyValue);
    void SetPropertyValidValues(LONG lPropertyValidValues);
    CWiaeditpropflags(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
    //{{AFX_DATA(CWiaeditpropflags)
    enum { IDD = IDD_EDIT_WIAPROP_FLAGS_DIALOG };
    CListBox    m_PropertyValidValuesListBox;
    CString m_szPropertyName;
    CString m_szPropertyValue;
    LONG m_lValidValues;
    LONG m_lCurrentValue;
    //}}AFX_DATA


// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CWiaeditpropflags)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(CWiaeditpropflags)
    afx_msg void OnSelchangeFlagsPropertyvalueListbox();
    virtual BOOL OnInitDialog();
	virtual void OnOK();
	//}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_WIAEDITPROPFLAGS_H__4A3D69F0_06C3_490F_8467_AFB74772B6C3__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiatest2\wiaeditproplist.cpp ===
// Wiaeditproplist.cpp : implementation file
//

#include "stdafx.h"
#include "wiatest.h"
#include "Wiaeditproplist.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CWiaeditproplist dialog


CWiaeditproplist::CWiaeditproplist(CWnd* pParent /*=NULL*/)
    : CDialog(CWiaeditproplist::IDD, pParent)
{
    //{{AFX_DATA_INIT(CWiaeditproplist)
    m_szPropertyName = _T("");
    m_szPropertyValue = _T("");
    m_szNumListValues = _T("");
    //}}AFX_DATA_INIT
}


void CWiaeditproplist::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CWiaeditproplist)
    DDX_Control(pDX, IDC_LIST_PROPERTYVALUE_LISTBOX, m_PropertyValidValuesListBox);
    DDX_Text(pDX, IDC_LIST_PROPERTY_NAME, m_szPropertyName);
    DDX_Text(pDX, IDC_LIST_PROPERTYVALUE_EDITBOX, m_szPropertyValue);
    DDX_Text(pDX, IDC_LIST_PROPERTYVALUE_NUMITEMSTEXT, m_szNumListValues);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CWiaeditproplist, CDialog)
    //{{AFX_MSG_MAP(CWiaeditproplist)
    ON_LBN_SELCHANGE(IDC_LIST_PROPERTYVALUE_LISTBOX, OnSelchangeListPropertyvalueListbox)
    ON_LBN_DBLCLK(IDC_LIST_PROPERTYVALUE_LISTBOX, OnDblclkListPropertyvalueListbox)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWiaeditproplist message handlers

void CWiaeditproplist::SetPropertyName(TCHAR *szPropertyName)
{
    m_szPropertyName = szPropertyName;
}

void CWiaeditproplist::SetPropertyValue(TCHAR *szPropertyValue)
{
    m_szPropertyValue = szPropertyValue;
}

void CWiaeditproplist::SetPropertyValidValues(PVALID_LIST_VALUES pValidListValues)
{
    m_pValidListValues = pValidListValues;
    m_szNumListValues.Format(TEXT("%d item(s) in List"),pValidListValues->lNumElements);
}

void CWiaeditproplist::AddValidValuesToListBox()
{
    TCHAR szValidValue[MAX_PATH];        

    for (LONG i = 0;i < m_pValidListValues->lNumElements ; i++) {
        memset(szValidValue,0,sizeof(szValidValue));        

        switch (m_pValidListValues->vt) {
        case VT_I1:
        case VT_I2:
        case VT_I4:
        case VT_I8:
        case VT_UI1:
        case VT_UI2:
        case VT_UI4:
        case VT_UI8:
        case VT_INT:
            if (!WIACONSTANT2TSTR(m_szPropertyName.GetBuffer(m_szPropertyName.GetLength()),((LONG*)m_pValidListValues->pList)[WIA_LIST_VALUES + i],szValidValue)) {
                TSPRINTF(szValidValue,TEXT("%d"),((INT*)m_pValidListValues->pList)[WIA_LIST_VALUES + i]);
            }
            break;
        case VT_R4:
        case VT_R8:            
            TSPRINTF(szValidValue,TEXT("%3.3f"),((float*)m_pValidListValues->pList)[WIA_LIST_VALUES + i]);
            break;
        case VT_BSTR:            
            TSPRINTF(szValidValue,TEXT("%ws"),((BSTR*)m_pValidListValues->pList)[WIA_LIST_VALUES + i]);
            break;
        case VT_CLSID:            
            GUID2TSTR(&((GUID*)m_pValidListValues->pList)[WIA_LIST_VALUES + i],szValidValue);
            break;
        case VT_UINT:
        default:
            TSPRINTF(szValidValue,TEXT("%d"),((UINT*)m_pValidListValues->pList)[WIA_LIST_VALUES + i]);            
            break;
        }        
        // add value to listbox
        m_PropertyValidValuesListBox.AddString(szValidValue);
    }
}

BOOL CWiaeditproplist::OnInitDialog() 
{
    CDialog::OnInitDialog();    
    AddValidValuesToListBox();
    SelectCurrentValue();
    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

void CWiaeditproplist::OnSelchangeListPropertyvalueListbox() 
{
    INT iCurrentSelection = 0;
    iCurrentSelection = m_PropertyValidValuesListBox.GetCurSel();
    TCHAR szCurrentValue[MAX_PATH];
    memset(szCurrentValue,0,sizeof(szCurrentValue));
    m_PropertyValidValuesListBox.GetText(iCurrentSelection,szCurrentValue);
    
    LONG lVal = 0;
    if(TSTR2WIACONSTANT(m_szPropertyName.GetBuffer(m_szPropertyName.GetLength()),szCurrentValue,&lVal)){
        TSPRINTF(szCurrentValue,TEXT("%d"),lVal);
    }

    m_szPropertyValue = szCurrentValue;
    UpdateData(FALSE);
}

void CWiaeditproplist::SelectCurrentValue()
{
    TCHAR szCurrentValue[MAX_PATH];
    memset(szCurrentValue,0,sizeof(szCurrentValue));
    lstrcpy(szCurrentValue,m_szPropertyValue);
    INT iSelection = m_PropertyValidValuesListBox.FindString(-1,szCurrentValue);
    if(iSelection >= 0){
        m_PropertyValidValuesListBox.SetCurSel(iSelection);
    } else {
        LONG lVal = 0;
        TCHAR szTempValue[MAX_PATH];
        memset(szTempValue,0,sizeof(szTempValue));
        switch (m_pValidListValues->vt) {
        case VT_I1:
        case VT_I2:
        case VT_I4:
        case VT_I8:
        case VT_UI1:
        case VT_UI2:
        case VT_UI4:
        case VT_UI8:
        case VT_INT:
            // try to select a converted type
            TSSCANF(szCurrentValue,TEXT("%d"),&lVal);
            if (!WIACONSTANT2TSTR(m_szPropertyName.GetBuffer(m_szPropertyName.GetLength()),lVal,szTempValue)) {
                m_PropertyValidValuesListBox.SetCurSel(0);
            } else {
                iSelection = m_PropertyValidValuesListBox.FindString(-1,szTempValue);
                if(iSelection >= 0){
                    m_PropertyValidValuesListBox.SetCurSel(iSelection);
                } else {
                    m_PropertyValidValuesListBox.SetCurSel(0);
                }
            }
            break;
        default:
            m_PropertyValidValuesListBox.SetCurSel(0);
            break;                        
        }        
    }
}

void CWiaeditproplist::OnDblclkListPropertyvalueListbox() 
{
    CDialog::OnOK();    
}

void CWiaeditproplist::GUID2TSTR(GUID *pGUID, TCHAR *szValue)
{
    UCHAR *pwszUUID = NULL;
    UuidToString(pGUID,&pwszUUID);            
    TSPRINTF(szValue,"%s",pwszUUID);
    // free allocated string
    RpcStringFree(&pwszUUID);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiatest2\wiaeditproplist.h ===
#if !defined(AFX_WIAEDITPROPLIST_H__7B348364_E122_4F5E_A7F1_D9205CDF5713__INCLUDED_)
#define AFX_WIAEDITPROPLIST_H__7B348364_E122_4F5E_A7F1_D9205CDF5713__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// Wiaeditproplist.h : header file
//

typedef struct _VALID_LIST_VALUES {
    VARTYPE vt;
    LONG lNumElements;
    BYTE *pList;
}VALID_LIST_VALUES, *PVALID_LIST_VALUES;

/////////////////////////////////////////////////////////////////////////////
// CWiaeditproplist dialog

class CWiaeditproplist : public CDialog
{
// Construction
public:
	void GUID2TSTR(GUID *pGUID, TCHAR *szValue);
	void SelectCurrentValue();
	void AddValidValuesToListBox();
	void SetPropertyName(TCHAR *szPropertyName);
    void SetPropertyValue(TCHAR *szPropertyValue);
    void SetPropertyValidValues(PVALID_LIST_VALUES pValidListValues);
	CWiaeditproplist(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CWiaeditproplist)
	enum { IDD = IDD_EDIT_WIAPROP_LIST_DIALOG };
	CListBox	m_PropertyValidValuesListBox;
	CString	m_szPropertyName;
	CString	m_szPropertyValue;
	CString	m_szNumListValues;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CWiaeditproplist)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	PVALID_LIST_VALUES m_pValidListValues;

	// Generated message map functions
	//{{AFX_MSG(CWiaeditproplist)
	virtual BOOL OnInitDialog();
	afx_msg void OnSelchangeListPropertyvalueListbox();
	afx_msg void OnDblclkListPropertyvalueListbox();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_WIAEDITPROPLIST_H__7B348364_E122_4F5E_A7F1_D9205CDF5713__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiatest2\wiaeditpropflags.cpp ===
// Wiaeditpropflags.cpp : implementation file
//

#include "stdafx.h"
#include "wiatest.h"
#include "Wiaeditpropflags.h"

#ifdef _DEBUG
    #define new DEBUG_NEW
    #undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CWiaeditpropflags dialog


CWiaeditpropflags::CWiaeditpropflags(CWnd* pParent /*=NULL*/)
: CDialog(CWiaeditpropflags::IDD, pParent)
{
    //{{AFX_DATA_INIT(CWiaeditpropflags)
    m_szPropertyName = _T("");
    m_szPropertyValue = _T("");
    m_lValidValues = 0;
    m_lCurrentValue = 0;
    //}}AFX_DATA_INIT
}


void CWiaeditpropflags::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CWiaeditpropflags)
    DDX_Control(pDX, IDC_FLAGS_PROPERTYVALUE_LISTBOX, m_PropertyValidValuesListBox);
    DDX_Text(pDX, IDC_FLAGS_PROPERTY_NAME, m_szPropertyName);
    DDX_Text(pDX, IDC_FLAGS_PROPERTYVALUE_EDITBOX, m_szPropertyValue);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CWiaeditpropflags, CDialog)
//{{AFX_MSG_MAP(CWiaeditpropflags)
ON_LBN_SELCHANGE(IDC_FLAGS_PROPERTYVALUE_LISTBOX, OnSelchangeFlagsPropertyvalueListbox)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWiaeditpropflags message handlers

void CWiaeditpropflags::SetPropertyName(TCHAR *szPropertyName)
{
    m_szPropertyName = szPropertyName;
}

void CWiaeditpropflags::SetPropertyValue(TCHAR *szPropertyValue)
{
    m_szPropertyValue = szPropertyValue;
    TSSCANF(szPropertyValue,TEXT("%d"),&m_lCurrentValue);
    m_szPropertyValue.Format("0x%08X",m_lCurrentValue);    
}

void CWiaeditpropflags::SetPropertyValidValues(LONG lPropertyValidValues)
{
    m_lValidValues = lPropertyValidValues;
}

void CWiaeditpropflags::OnSelchangeFlagsPropertyvalueListbox() 
{
    m_lCurrentValue = 0;
    TCHAR szListBoxValue[MAX_PATH];
    LONG lListBoxValue = 0;
    int indexArray[100];

    memset(indexArray,0,sizeof(indexArray));
    int iNumItemsSelected = m_PropertyValidValuesListBox.GetSelItems(100,indexArray);
    for(int i = 0; i < iNumItemsSelected; i++){
        memset(szListBoxValue,0,sizeof(szListBoxValue));
        m_PropertyValidValuesListBox.GetText(indexArray[i],szListBoxValue);
        if(TSTR2WIACONSTANT(m_szPropertyName.GetBuffer(m_szPropertyName.GetLength()),szListBoxValue,&lListBoxValue)){
            m_lCurrentValue |= lListBoxValue;
        } else {
            LONG lVal = 0;
            TSSCANF(szListBoxValue, TEXT("0x%08X"),&lVal);
            m_lCurrentValue |= lVal;
        }
    }

    m_szPropertyValue.Format("0x%08X",m_lCurrentValue);
    UpdateData(FALSE);
}

BOOL CWiaeditpropflags::OnInitDialog() 
{
    CDialog::OnInitDialog();

    AddValidValuesToListBox();
    SelectCurrentValue();

    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

void CWiaeditpropflags::SelectCurrentValue()
{
    //
    // TO DO: Fix this code to make the current value match
    //        the current selection.
    //

    /*
    TCHAR szCurrentValue[MAX_PATH];
    memset(szCurrentValue,0,sizeof(szCurrentValue));
    lstrcpy(szCurrentValue,m_szPropertyValue);
    LONG lVal = 0;            
    TSSCANF(szCurrentValue,TEXT("%d"),&lVal);
    INT iNumItemsInListBox = m_PropertyValidValuesListBox.GetCount();    
    while(iNumItemsInListBox > 0){        
        TCHAR szListBoxValue[MAX_PATH];
        LONG lListBoxValue = 0;
        memset(szListBoxValue,0,sizeof(szListBoxValue));
        m_PropertyValidValuesListBox.GetText((iNumItemsInListBox-1),szListBoxValue);
        if(TSTR2WIACONSTANT(m_szPropertyName.GetBuffer(m_szPropertyName.GetLength()),szListBoxValue,&lListBoxValue)){
            if(lListBoxValue & lVal){
                m_PropertyValidValuesListBox.SetSel(iNumItemsInListBox-1);
            }
        }
        iNumItemsInListBox--;   
    }
    */            
}

void CWiaeditpropflags::AddValidValuesToListBox()
{
    int iStartIndex = FindStartIndexInTable(m_szPropertyName.GetBuffer(m_szPropertyName.GetLength()));
    int iEndIndex = FindEndIndexInTable(m_szPropertyName.GetBuffer(m_szPropertyName.GetLength()));    
    TCHAR szListBoxValue[MAX_PATH];
    LONG x = 1;
    for (LONG bit = 0; bit<32; bit++) {
        memset(szListBoxValue,0,sizeof(szListBoxValue));
        // check to see if the bit is set
        if (m_lValidValues & x) {
            // the bit is set, so find it in the table
            if (iStartIndex >= 0) {
                // we have a table for this property, use it
                TCHAR *pszListBoxValue = NULL;
                for (int index = iStartIndex; index <= iEndIndex;index++) {
                    if (x == WIACONSTANT_VALUE_FROMINDEX(index)) {
                        pszListBoxValue = WIACONSTANT_TSTR_FROMINDEX(index);                        
                    }
                }
                if(pszListBoxValue != NULL){
                    // we found the item in the table
                    lstrcpy(szListBoxValue,pszListBoxValue);
                } else {
                    // we could not find the item in the table, so use
                    // the actual value
                    TSPRINTF(szListBoxValue,TEXT("0x%08X"),x);
                }
            } else {
                // we have no items in the table for this property, so use
                // the actual value
                TSPRINTF(szListBoxValue,TEXT("0x%08X"),x);
            }
            // add the string to the list box            
            m_PropertyValidValuesListBox.AddString(szListBoxValue);
        }
        x <<= 1;
    }                    
}

void CWiaeditpropflags::OnOK() 
{
    m_szPropertyValue.Format(TEXT("%d"),m_lCurrentValue);
    CDialog::OnOK();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiatest2\wiaeditproprange.cpp ===
// Wiaeditproprange.cpp : implementation file
//

#include "stdafx.h"
#include "wiatest.h"
#include "Wiaeditproprange.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CWiaeditproprange dialog


CWiaeditproprange::CWiaeditproprange(CWnd* pParent /*=NULL*/)
	: CDialog(CWiaeditproprange::IDD, pParent)
{
	//{{AFX_DATA_INIT(CWiaeditproprange)
	m_szPropertyName = _T("");
	m_szPropertyValue = _T("");
	m_szPropertyIncValue = _T("");
	m_szPropertyMaxValue = _T("");
	m_szPropertyMinValue = _T("");
	m_szPropertyNomValue = _T("");
	//}}AFX_DATA_INIT
}


void CWiaeditproprange::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CWiaeditproprange)
	DDX_Text(pDX, IDC_RANGE_PROPERTY_NAME, m_szPropertyName);
	DDX_Text(pDX, IDC_RANGE_PROPERTYVALUE_EDITBOX, m_szPropertyValue);
	DDX_Text(pDX, RANGE_PROPERTY_INCVALUE, m_szPropertyIncValue);
	DDX_Text(pDX, RANGE_PROPERTY_MAXVALUE, m_szPropertyMaxValue);
	DDX_Text(pDX, RANGE_PROPERTY_MINVALUE, m_szPropertyMinValue);
	DDX_Text(pDX, RANGE_PROPERTY_NOMVALUE, m_szPropertyNomValue);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CWiaeditproprange, CDialog)
	//{{AFX_MSG_MAP(CWiaeditproprange)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWiaeditproprange message handlers

void CWiaeditproprange::SetPropertyName(TCHAR *szPropertyName)
{
    m_szPropertyName = szPropertyName;
}

void CWiaeditproprange::SetPropertyValue(TCHAR *szPropertyValue)
{
    m_szPropertyValue = szPropertyValue;
}

void CWiaeditproprange::SetPropertyValidValues(PVALID_RANGE_VALUES pValidRangeValues)
{
    m_szPropertyMinValue.Format(TEXT("%d"),pValidRangeValues->lMin);
    m_szPropertyMaxValue.Format(TEXT("%d"),pValidRangeValues->lMax);
    m_szPropertyNomValue.Format(TEXT("%d"),pValidRangeValues->lNom);
    m_szPropertyIncValue.Format(TEXT("%d"),pValidRangeValues->lInc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiatest2\wiaeditpropnone.cpp ===
// Wiaeditpropnone.cpp : implementation file
//

#include "stdafx.h"
#include "wiatest.h"
#include "Wiaeditpropnone.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CWiaeditpropnone dialog


CWiaeditpropnone::CWiaeditpropnone(CWnd* pParent /*=NULL*/)
	: CDialog(CWiaeditpropnone::IDD, pParent)
{
	//{{AFX_DATA_INIT(CWiaeditpropnone)
	m_szPropertyName = _T("");
	m_szPropertyValue = _T("");
	m_szFormattingInstructions = _T("");
	//}}AFX_DATA_INIT
}


void CWiaeditpropnone::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CWiaeditpropnone)
	DDX_Text(pDX, IDC_NONE_PROPERTY_NAME, m_szPropertyName);
	DDX_Text(pDX, IDC_NONE_PROPERTYVALUE_EDITBOX, m_szPropertyValue);
	DDX_Text(pDX, IDC_NONE_PROPERTY_FORMATTING_TEXT, m_szFormattingInstructions);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CWiaeditpropnone, CDialog)
	//{{AFX_MSG_MAP(CWiaeditpropnone)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWiaeditpropnone message handlers

void CWiaeditpropnone::SetPropertyName(TCHAR *szPropertyName)
{
    m_szPropertyName = szPropertyName;
}

void CWiaeditpropnone::SetPropertyValue(TCHAR *szPropertyValue)
{
    m_szPropertyValue = szPropertyValue;
}

void CWiaeditpropnone::SetPropertyFormattingInstructions(TCHAR *szFormatting)
{
    m_szFormattingInstructions = szFormatting;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiatest2\wiaeditproptable.h ===
#ifndef _WIAEDITPROPTABLE_H
#define _WIAEDITPROPTABLE_H

typedef struct _WIA_EDIT_PROPERTY_TABLE_ENTRY {
    LONG lVal;
    TCHAR *pszValName;
    TCHAR *pszPropertyName;
}WIA_EDIT_PROPERTY_TABLE_ENTRY,*PWIA_EDIT_PROPERTY_TABLE_ENTRY;

/////////////////////////////////////////////////////////////////////////////////////////////////
// { [Property Value],               [Property Value contant name],         [Property Name] }
/////////////////////////////////////////////////////////////////////////////////////////////////
// Template: {,TEXT(""),TEXT("")},

WIA_EDIT_PROPERTY_TABLE_ENTRY g_EditPropTable[] = 
{
    {WIA_INTENT_NONE,                TEXT("WIA_INTENT_NONE"),                TEXT("Current Intent")},
    {WIA_INTENT_IMAGE_TYPE_COLOR,    TEXT("WIA_INTENT_IMAGE_TYPE_COLOR"),    TEXT("Current Intent")},
    {WIA_INTENT_IMAGE_TYPE_GRAYSCALE,TEXT("WIA_INTENT_IMAGE_TYPE_GRAYSCALE"),TEXT("Current Intent")},
    {WIA_INTENT_IMAGE_TYPE_TEXT,     TEXT("WIA_INTENT_IMAGE_TYPE_TEXT"),     TEXT("Current Intent")},
    {WIA_INTENT_MINIMIZE_SIZE,       TEXT("WIA_INTENT_MINIMIZE_SIZE"),       TEXT("Current Intent")},
    {WIA_INTENT_MAXIMIZE_QUALITY,    TEXT("WIA_INTENT_MAXIMIZE_QUALITY"),    TEXT("Current Intent")},
    {TYMED_CALLBACK,                 TEXT("TYMED_CALLBACK"),                 TEXT("Media Type")},
    {TYMED_FILE,                     TEXT("TYMED_FILE"),                     TEXT("Media Type")},
    {TYMED_MULTIPAGE_CALLBACK,       TEXT("TYMED_MULTIPAGE_CALLBACK"),       TEXT("Media Type")},
    {TYMED_MULTIPAGE_FILE,           TEXT("TYMED_MULTIPAGE_FILE"),           TEXT("Media Type")},
    {WIA_COMPRESSION_NONE,           TEXT("WIA_COMPRESSION_NONE"),           TEXT("Compression")},
    {WIA_COMPRESSION_BI_RLE4,        TEXT("WIA_COMPRESSION_BI_RLE4"),        TEXT("Compression")},
    {WIA_COMPRESSION_BI_RLE8,        TEXT("WIA_COMPRESSION_BI_RLE8"),        TEXT("Compression")},
    {WIA_COMPRESSION_G3,             TEXT("WIA_COMPRESSION_G3"),             TEXT("Compression")},
    {WIA_FINAL_SCAN,                 TEXT("WIA_FINAL_SCAN"),                 TEXT("Preview")},
    {WIA_PREVIEW_SCAN,               TEXT("WIA_PREVIEW_SCAN"),               TEXT("Preview")},
    {FEEDER,                         TEXT("FEEDER"),                         TEXT("Document Handling Select")},
    {FLATBED,                        TEXT("FLATBED"),                        TEXT("Document Handling Select")},
    {DUPLEX,                         TEXT("DUPLEX"),                         TEXT("Document Handling Select")},
    {FRONT_FIRST,                    TEXT("FRONT_FIRST"),                    TEXT("Document Handling Select")},
    {BACK_FIRST,                     TEXT("BACK_FIRST"),                     TEXT("Document Handling Select")},
    {FRONT_ONLY,                     TEXT("FRONT_ONLY"),                     TEXT("Document Handling Select")},
    {BACK_ONLY,                      TEXT("BACK_ONLY"),                      TEXT("Document Handling Select")},
    {NEXT_PAGE,                      TEXT("NEXT_PAGE"),                      TEXT("Document Handling Select")},
    {PREFEED,                        TEXT("PREFEED"),                        TEXT("Document Handling Select")},
    {AUTO_ADVANCE,                   TEXT("AUTO_ADVANCE"),                   TEXT("Document Handling Select")},    
    {FEED,                           TEXT("FEED"),                           TEXT("Document Handling Capabilities")},
    {FLAT,                           TEXT("FLAT"),                           TEXT("Document Handling Capabilities")},
    {DUP,                            TEXT("DUP"),                            TEXT("Document Handling Capabilities")},
    {DETECT_FLAT,                    TEXT("DETECT_FLAT"),                    TEXT("Document Handling Capabilities")},
    {DETECT_SCAN,                    TEXT("DETECT_SCAN"),                    TEXT("Document Handling Capabilities")},
    {DETECT_FEED,                    TEXT("DETECT_FEED"),                    TEXT("Document Handling Capabilities")},
    {DETECT_DUP,                     TEXT("DETECT_DUP"),                     TEXT("Document Handling Capabilities")},
    {DETECT_FEED_AVAIL,              TEXT("DETECT_FEED_AVAIL"),              TEXT("Document Handling Capabilities")},
    {DETECT_DUP_AVAIL,               TEXT("DETECT_DUP_AVAIL"),               TEXT("Document Handling Capabilities")},
    {FEED_READY,                     TEXT("FEED_READY"),                     TEXT("Document Handling Status")},
    {FLAT_READY,                     TEXT("FLAT_READY"),                     TEXT("Document Handling Status")},
    {DUP_READY,                      TEXT("DUP_READY"),                      TEXT("Document Handling Status")},
    {FLAT_COVER_UP,                  TEXT("FLAT_COVER_UP"),                  TEXT("Document Handling Status")},
    {PATH_COVER_UP,                  TEXT("PATH_COVER_UP"),                  TEXT("Document Handling Status")},
    {PAPER_JAM,                      TEXT("PAPER_JAM"),                      TEXT("Document Handling Status")},
    {WIA_DATA_THRESHOLD,             TEXT("WIA_DATA_THRESHOLD"),             TEXT("Data Type")},
    {WIA_DATA_DITHER,                TEXT("WIA_DATA_DITHER"),                TEXT("Data Type")},
    {WIA_DATA_GRAYSCALE,             TEXT("WIA_DATA_GRAYSCALE"),             TEXT("Data Type")},
    {WIA_DATA_COLOR,                 TEXT("WIA_DATA_COLOR"),                 TEXT("Data Type")},
    {WIA_DATA_COLOR_THRESHOLD,       TEXT("WIA_DATA_COLOR_THRESHOLD"),       TEXT("Data Type")},
    {WIA_DATA_COLOR_DITHER,          TEXT("WIA_DATA_COLOR_DITHER"),          TEXT("Data Type")},
    {WiaItemTypeFree,                TEXT("WiaItemTypeFree"),                TEXT("Item Flags")},
    {WiaItemTypeImage,               TEXT("WiaItemTypeImage"),               TEXT("Item Flags")},
    {WiaItemTypeFile,                TEXT("WiaItemTypeFile"),                TEXT("Item Flags")},
    {WiaItemTypeFolder,              TEXT("WiaItemTypeFolder"),              TEXT("Item Flags")},
    {WiaItemTypeRoot,                TEXT("WiaItemTypeRoot"),                TEXT("Item Flags")},
    {WiaItemTypeAnalyze,             TEXT("WiaItemTypeAnalyze"),             TEXT("Item Flags")},
    {WiaItemTypeAudio,               TEXT("WiaItemTypeAudio"),               TEXT("Item Flags")},
    {WiaItemTypeDevice,              TEXT("WiaItemTypeDevice"),              TEXT("Item Flags")},
    {WiaItemTypeDeleted,             TEXT("WiaItemTypeDeleted"),             TEXT("Item Flags")},
    {WiaItemTypeDisconnected,        TEXT("WiaItemTypeDisconnected"),        TEXT("Item Flags")},
    {WiaItemTypeHPanorama,           TEXT("WiaItemTypeHPanorama"),           TEXT("Item Flags")},
    {WiaItemTypeVPanorama,           TEXT("WiaItemTypeVPanorama"),           TEXT("Item Flags")},
    {WiaItemTypeBurst,               TEXT("WiaItemTypeBurst"),               TEXT("Item Flags")},
    {WiaItemTypeStorage,             TEXT("WiaItemTypeStorage"),             TEXT("Item Flags")},
    {WiaItemTypeTransfer,            TEXT("WiaItemTypeTransfer"),            TEXT("Item Flags")},
    {WiaItemTypeGenerated,           TEXT("WiaItemTypeGenerated"),           TEXT("Item Flags")},
    {WiaItemTypeHasAttachments,      TEXT("WiaItemTypeHasAttachments"),      TEXT("Item Flags")},    
    {WIA_ITEM_READ,                  TEXT("WIA_ITEM_READ"),                  TEXT("Access Rights")},
    {WIA_ITEM_WRITE,                 TEXT("WIA_ITEM_WRITE"),                 TEXT("Access Rights")},
    {WIA_ITEM_CAN_BE_DELETED,        TEXT("WIA_ITEM_CAN_BE_DELETED"),        TEXT("Access Rights")},    
    {0,                              NULL,                                   NULL}
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiatest2\wiaeditpropnone.h ===
#if !defined(AFX_WIAEDITPROPNONE_H__E42B1713_3E01_4185_B5E1_C576CD3C126E__INCLUDED_)
#define AFX_WIAEDITPROPNONE_H__E42B1713_3E01_4185_B5E1_C576CD3C126E__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// Wiaeditpropnone.h : header file
//

/*
typedef struct _SYSTEMTIME
    {
    WORD wYear;
    WORD wMonth;
    WORD wDayOfWeek;
    WORD wDay;
    WORD wHour;
    WORD wMinute;
    WORD wSecond;
    WORD wMilliseconds;
    } 	SYSTEMTIME;
*/

/////////////////////////////////////////////////////////////////////////////
// CWiaeditpropnone dialog

class CWiaeditpropnone : public CDialog
{
// Construction
public:
	void SetPropertyFormattingInstructions(TCHAR *szFormatting);
	void SetPropertyName(TCHAR *szPropertyName);
    void SetPropertyValue(TCHAR *szPropertyValue);
	CWiaeditpropnone(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CWiaeditpropnone)
	enum { IDD = IDD_EDIT_WIAPROP_NONE_DIALOG };
	CString	m_szPropertyName;
	CString	m_szPropertyValue;
	CString	m_szFormattingInstructions;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CWiaeditpropnone)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CWiaeditpropnone)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_WIAEDITPROPNONE_H__E42B1713_3E01_4185_B5E1_C576CD3C126E__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiatest2\wiaeventcallback.cpp ===
// WiaDataCallback.cpp: implementation of the CWiaEventCallback class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "wiatest.h"
#include "WiaEventCallback.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CWiaEventCallback::CWiaEventCallback()
{
    m_cRef = 0;
    for(LONG lEventIndex = 0; lEventIndex < MAX_REGISTERED_EVENTS; lEventIndex++){
        if(m_pIUnkRelease[lEventIndex]){            
            m_pIUnkRelease[lEventIndex] = NULL;
        }
    }

    memset(m_szWindowText,0,sizeof(m_szWindowText));
}

CWiaEventCallback::~CWiaEventCallback()
{    
    for(LONG lEventIndex = 0; lEventIndex < MAX_REGISTERED_EVENTS; lEventIndex++){
        if(m_pIUnkRelease[lEventIndex]){
            m_pIUnkRelease[lEventIndex]->Release();
            m_pIUnkRelease[lEventIndex] = NULL;
        }
    }
    
}

HRESULT _stdcall CWiaEventCallback::QueryInterface(const IID& iid, void** ppv)
{
    *ppv = NULL;
    if (iid == IID_IUnknown || iid == IID_IWiaEventCallback)
        *ppv = (IWiaEventCallback*) this;
    else
        return E_NOINTERFACE;
    AddRef();
    return S_OK;
}

ULONG   _stdcall CWiaEventCallback::AddRef()
{
    InterlockedIncrement((long*) &m_cRef);
    return m_cRef;
}

ULONG   _stdcall CWiaEventCallback::Release()
{
    ULONG ulRefCount = m_cRef - 1;
    if (InterlockedDecrement((long*) &m_cRef) == 0)
    {
        delete this;
        return 0;
    }
    return ulRefCount;
}

HRESULT _stdcall CWiaEventCallback::ImageEventCallback(
    const GUID                      *pEventGUID,
    BSTR                            bstrEventDescription,
    BSTR                            bstrDeviceID,
    BSTR                            bstrDeviceDescription,
    DWORD                           dwDeviceType,
    BSTR                            bstrFullItemName,
    ULONG                           *plEventType,
    ULONG                           ulReserved)
{

    TCHAR szStatusText[255];
    memset(szStatusText,0,sizeof(szStatusText));

    TSPRINTF(szStatusText,TEXT("Description: %ws\nDeviceID: %ws\nDevice Description: %ws\nDevice Type: %d\nFull Item Name: %ws"),
             bstrEventDescription, 
             bstrDeviceID,         
             bstrDeviceDescription,
             dwDeviceType,         
             bstrFullItemName);
    
    if(lstrlen(m_szWindowText) == 0){
        SetViewWindowHandle(m_hViewWindow);
    }

    ::MessageBox(m_hViewWindow,szStatusText, m_szWindowText, MB_ICONINFORMATION);
    
    if (NULL != m_hViewWindow) {
        BSTR bstrTargetDevice = SysAllocString(bstrDeviceID);
        // handle known events    
        if (*pEventGUID == WIA_EVENT_DEVICE_DISCONNECTED) {
            ::PostMessage(m_hViewWindow,WM_DEVICE_DISCONNECTED,0,(LPARAM)bstrTargetDevice);
        } else if (*pEventGUID == WIA_EVENT_DEVICE_CONNECTED) {
            ::PostMessage(m_hViewWindow,WM_DEVICE_CONNECTED,0,0);
        } else if (*pEventGUID == WIA_EVENT_ITEM_DELETED) {
            ::PostMessage(m_hViewWindow,WM_ITEM_DELETED,0,0);
        } else if (*pEventGUID == WIA_EVENT_ITEM_CREATED) {
            ::PostMessage(m_hViewWindow,WM_ITEM_CREATED,0,0);
        } else if (*pEventGUID == WIA_EVENT_TREE_UPDATED) {
            ::PostMessage(m_hViewWindow,WM_TREE_UPDATED,0,0);
        } else if (*pEventGUID == WIA_EVENT_STORAGE_CREATED) {
            ::PostMessage(m_hViewWindow,WM_STORAGE_CREATED,0,0);
        } else if (*pEventGUID == WIA_EVENT_STORAGE_DELETED) {
            ::PostMessage(m_hViewWindow,WM_STORAGE_DELETED,0,0);
        }
    }
    return S_OK;
}

void CWiaEventCallback::SetViewWindowHandle(HWND hWnd)
{
    m_hViewWindow = hWnd;
    TCHAR szWindowText[MAX_PATH];
    memset(szWindowText,0,sizeof(szWindowText));
    GetWindowText(hWnd,szWindowText,(sizeof(szWindowText)/sizeof(TCHAR)));
    TSPRINTF(m_szWindowText,TEXT("Event Notification [%s]"),szWindowText);    
}

void CWiaEventCallback::SetNumberOfEventsRegistered(LONG lEventsRegistered)
{
    m_lNumEventsRegistered = lEventsRegistered;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiatest2\wiaeventcallback.h ===
// WiaEventCallback.h: interface for the CWiaEventCallback class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_WIAEVENTCALLBACK_H__5125F8A0_29CF_4E4D_9D39_53DF7C29BD88__INCLUDED_)
#define AFX_WIAEVENTCALLBACK_H__5125F8A0_29CF_4E4D_9D39_53DF7C29BD88__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define MAX_REGISTERED_EVENTS   50

class CWiaEventCallback : public IWiaEventCallback
{
public:	
	CWiaEventCallback();
	virtual ~CWiaEventCallback();
    // IUnknown members that delegate to m_pUnkRef.
    HRESULT _stdcall QueryInterface(const IID&,void**);
    ULONG   _stdcall AddRef();
    ULONG   _stdcall Release();
    HRESULT _stdcall ImageEventCallback(
                                        const GUID *pEventGUID,
                                        BSTR       bstrEventDescription,
                                        BSTR       bstrDeviceID,
                                        BSTR       bstrDeviceDescription,
                                        DWORD      dwDeviceType,
                                        BSTR       bstrFullItemName,
                                        ULONG      *plEventType,
                                        ULONG      ulReserved);
    IUnknown* m_pIUnkRelease[MAX_REGISTERED_EVENTS];
    void SetViewWindowHandle(HWND hWnd);
    void SetNumberOfEventsRegistered(LONG lEventsRegistered);
private:
   ULONG m_cRef;         // Object reference count.  
   HWND m_hViewWindow;
   LONG m_lNumEventsRegistered;
   TCHAR m_szWindowText[MAX_PATH];
};

#endif // !defined(AFX_WIAEVENTCALLBACK_H__5125F8A0_29CF_4E4D_9D39_53DF7C29BD88__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiatest2\wiaeditproprange.h ===
#if !defined(AFX_WIAEDITPROPRANGE_H__E1FDE159_C7B7_40B6_AF67_7D5CCE9E09DA__INCLUDED_)
#define AFX_WIAEDITPROPRANGE_H__E1FDE159_C7B7_40B6_AF67_7D5CCE9E09DA__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// Wiaeditproprange.h : header file
//

typedef struct _VALID_RANGE_VALUES {
    LONG lMin;
    LONG lMax;
    LONG lNom;
    LONG lInc;
}VALID_RANGE_VALUES, *PVALID_RANGE_VALUES;

/////////////////////////////////////////////////////////////////////////////
// CWiaeditproprange dialog

class CWiaeditproprange : public CDialog
{
// Construction
public:    
    void SetPropertyName(TCHAR *szPropertyName);
    void SetPropertyValue(TCHAR *szPropertyValue);
    void SetPropertyValidValues(PVALID_RANGE_VALUES pValidRangeValues);
	CWiaeditproprange(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CWiaeditproprange)
	enum { IDD = IDD_EDIT_WIAPROP_RANGE_DIALOG };
	CString	m_szPropertyName;
	CString	m_szPropertyValue;
	CString	m_szPropertyIncValue;
	CString	m_szPropertyMaxValue;
	CString	m_szPropertyMinValue;
	CString	m_szPropertyNomValue;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CWiaeditproprange)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CWiaeditproprange)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_WIAEDITPROPRANGE_H__E1FDE159_C7B7_40B6_AF67_7D5CCE9E09DA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiatest2\wiahelper.cpp ===
// CWiahelper.cpp: implementation of the CWiahelper class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "wiatest.h"
#include "wiahelper.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CWiahelper::CWiahelper()
{
    m_pIWiaItem = NULL;    
    m_pIWiaPropStg = NULL;
}

CWiahelper::~CWiahelper()
{
    
    // release property storage
    if(m_pIWiaPropStg){
        m_pIWiaPropStg->Release();
        m_pIWiaPropStg = NULL;
    }

    // release item
    if(m_pIWiaItem){
        m_pIWiaItem->Release();
        m_pIWiaItem = NULL;
    }
}

HRESULT CWiahelper::SetIWiaItem(IWiaItem *pIWiaItem)
{
    HRESULT hr = S_OK;
    
    // release old property storage
    if(m_pIWiaPropStg){
        m_pIWiaPropStg->Release();
        m_pIWiaPropStg = NULL;
    }

    // release old item pointer
    if(m_pIWiaItem){
        m_pIWiaItem->Release();
        m_pIWiaItem = NULL;
    }

    // add ref item pointer (because we are storing it in this object)
    if(pIWiaItem){
        // get property storage interface
        hr = pIWiaItem->QueryInterface(IID_IWiaPropertyStorage,(VOID**)&m_pIWiaPropStg);
        if(SUCCEEDED(hr)){
            pIWiaItem->AddRef();
            m_pIWiaItem = pIWiaItem;
        }        
    } else {
        hr = E_POINTER;
    }
    return hr;
}

HRESULT CWiahelper::ReadPropertyString(PROPID PropertyID, LPTSTR szPropertyValue)
{
    HRESULT hr = S_OK;
    
    if (m_pIWiaPropStg) {

        // initialize propspecs
        PROPSPEC          PropSpec[1];
        PROPVARIANT       PropVar[1];
        
        memset(PropVar, 0, sizeof(PropVar));
        PropSpec[0].ulKind = PRSPEC_PROPID;
        PropSpec[0].propid = PropertyID;

        hr = m_pIWiaPropStg->ReadMultiple(1, PropSpec, PropVar);
        if (SUCCEEDED(hr)) {

#ifndef UNICODE
            WideCharToMultiByte(CP_ACP, 0,PropVar[0].bstrVal,-1,szPropertyValue,MAX_PATH,NULL,NULL);
#else            
            lstrcpy(szPropertyValue,PropVar[0].bstrVal);
#endif
            PropVariantClear(PropVar);
        }
        
    } else {
        hr = E_POINTER;
    }
    return hr;
}

HRESULT CWiahelper::ReadPropertyLong(PROPID PropertyID, LONG *plPropertyValue)
{
    HRESULT hr = S_OK;    
    if (m_pIWiaPropStg) {
    
        // initialize propspecs
        PROPSPEC          PropSpec[1];
        PROPVARIANT       PropVar[1];
        
        memset(PropVar, 0, sizeof(PropVar));
        PropSpec[0].ulKind = PRSPEC_PROPID;
        PropSpec[0].propid = PropertyID;

        hr = m_pIWiaPropStg->ReadMultiple(1, PropSpec, PropVar);
        if (SUCCEEDED(hr)) {
            *plPropertyValue = PropVar[0].lVal;
            PropVariantClear(PropVar);
        }

    } else {
        hr = E_POINTER;
    }
    return hr;
}

HRESULT CWiahelper::ReadPropertyFloat(PROPID PropertyID, FLOAT *pfPropertyValue)
{
    HRESULT hr = S_OK;
    if (m_pIWiaPropStg) {

        // initialize propspecs
        PROPSPEC          PropSpec[1];
        PROPVARIANT       PropVar[1];
        
        memset(PropVar, 0, sizeof(PropVar));
        PropSpec[0].ulKind = PRSPEC_PROPID;
        PropSpec[0].propid = PropertyID;

        hr = m_pIWiaPropStg->ReadMultiple(1, PropSpec, PropVar);
        if (SUCCEEDED(hr)) {
            *pfPropertyValue = PropVar[0].fltVal;
            PropVariantClear(PropVar);
        }

    } else {
        hr = E_POINTER;
    }
    return hr;
}

HRESULT CWiahelper::ReadPropertyGUID(PROPID PropertyID, GUID *pguidPropertyValue)
{
    HRESULT hr = S_OK;
    if (m_pIWiaPropStg) {

        // initialize propspecs
        PROPSPEC          PropSpec[1];
        PROPVARIANT       PropVar[1];
        
        memset(PropVar, 0, sizeof(PropVar));
        PropSpec[0].ulKind = PRSPEC_PROPID;
        PropSpec[0].propid = PropertyID;

        hr = m_pIWiaPropStg->ReadMultiple(1, PropSpec, PropVar);
        if (SUCCEEDED(hr)) {
            memcpy(pguidPropertyValue,PropVar[0].puuid,sizeof(GUID));            
            PropVariantClear(PropVar);
        }

    } else {
        hr = E_POINTER;
    }
    return hr;
}

HRESULT CWiahelper::ReadPropertyData(PROPID PropertyID, BYTE **ppData, LONG *pDataSize)
{
    HRESULT hr = S_OK;
    if (m_pIWiaPropStg) {

        // initialize propspecs
        PROPSPEC          PropSpec[1];
        PROPVARIANT       PropVar[1];
        
        memset(PropVar, 0, sizeof(PropVar));
        PropSpec[0].ulKind = PRSPEC_PROPID;
        PropSpec[0].propid = PropertyID;

        hr = m_pIWiaPropStg->ReadMultiple(1, PropSpec, PropVar);
        if (SUCCEEDED(hr)) {
            *pDataSize = PropVar[0].caub.cElems;
            *ppData = (BYTE*)GlobalAlloc(GPTR,PropVar[0].caub.cElems);
            memcpy(*ppData,PropVar[0].caub.pElems,PropVar[0].caub.cElems);
            PropVariantClear(PropVar);
        }

    } else {
        hr = E_POINTER;
    }
    return hr;    
}

HRESULT CWiahelper::ReadPropertyBSTR(PROPID PropertyID, BSTR *pbstrPropertyValue)
{
    HRESULT hr = S_OK;
    if (m_pIWiaPropStg) {

        // initialize propspecs
        PROPSPEC          PropSpec[1];
        PROPVARIANT       PropVar[1];
        
        memset(PropVar, 0, sizeof(PropVar));
        PropSpec[0].ulKind = PRSPEC_PROPID;
        PropSpec[0].propid = PropertyID;

        hr = m_pIWiaPropStg->ReadMultiple(1, PropSpec, PropVar);
        if (SUCCEEDED(hr)) {
            *pbstrPropertyValue = SysAllocString(PropVar[0].bstrVal);
            PropVariantClear(PropVar);
        }

    } else {
        hr = E_POINTER;
    }
    return hr;
}

HRESULT CWiahelper::ReadPropertyStreamFile(TCHAR *szPropertyStreamFile)
{
    HRESULT hr = S_OK;
    if (m_pIWiaPropStg) {

        HGLOBAL hMem = NULL;
        LPSTREAM pstmProp = NULL;
        LPBYTE pStreamData = NULL;
        CFile StreamFile;
        CFileException Exception;

        if (StreamFile.Open(szPropertyStreamFile,CFile::modeRead,&Exception)) {                        
            DWORD dwSize = 0;
            StreamFile.Read(&dwSize,sizeof(DWORD));
            if (dwSize) {
                hMem = GlobalAlloc(GMEM_MOVEABLE, dwSize);
                if (hMem) {
                    pStreamData = (LPBYTE)GlobalLock(hMem);
                    if (pStreamData != NULL) {
                        DWORD dwReadSize = 0;
                        dwReadSize = StreamFile.Read(pStreamData,dwSize);
                        GlobalUnlock(hMem);
                        if(dwSize == dwReadSize){
                            hr = CreateStreamOnHGlobal(hMem, TRUE, &pstmProp);
                            if (SUCCEEDED(hr)) {
                                hr = m_pIWiaPropStg->SetPropertyStream((GUID*) &GUID_NULL, pstmProp);                                
                                pstmProp->Release();
                            }
                        } else {
                            hr = E_INVALIDARG;
                        }
                    } else {
                        hr = E_OUTOFMEMORY;
                    }
                    GlobalFree(hMem);
                } else {
                    hr = E_OUTOFMEMORY;
                }
            }            
            StreamFile.Close();
        } else {
            AfxThrowFileException(Exception.m_cause);
        }        
    } else {
        hr = E_POINTER;
    }
    return hr;
}

HRESULT CWiahelper::WritePropertyString(PROPID PropertyID, LPTSTR szPropertyValue)
{
    HRESULT hr = S_OK;
    if (m_pIWiaPropStg) {
        
        PROPSPEC    propspec[1];
        PROPVARIANT propvar[1];
        
        memset(propvar, 0, sizeof(propvar));
        propspec[0].ulKind = PRSPEC_PROPID;
        propspec[0].propid = PropertyID;
        
        propvar[0].vt      = VT_BSTR;
        
#ifndef UNICODE
        WCHAR wszPropertyValue[MAX_PATH];
        memset(wszPropertyValue,0,sizeof(wszPropertyValue));
        MultiByteToWideChar(CP_ACP, 0,szPropertyValue,-1,wszPropertyValue,MAX_PATH);
        // allocate BSTR
        propvar[0].bstrVal = SysAllocString(wszPropertyValue);
#else
        // allocate BSTR
        propvar[0].bstrVal = SysAllocString(szPropertyValue);
#endif    
        
        hr = m_pIWiaPropStg->WriteMultiple(1, propspec, propvar, MIN_PROPID);
        
        // free allocated BSTR
        SysFreeString(propvar[0].bstrVal);
    } else {
        hr = E_POINTER;
    }
    return hr;
}

HRESULT CWiahelper::WritePropertyLong(PROPID PropertyID, LONG lPropertyValue)
{
    HRESULT hr = S_OK;
    if (m_pIWiaPropStg) {
        
        PROPSPEC    propspec[1];
        PROPVARIANT propvar[1];
        
        memset(propvar, 0, sizeof(propvar));
        propspec[0].ulKind = PRSPEC_PROPID;
        propspec[0].propid = PropertyID;
        
        propvar[0].vt   = VT_I4;
        propvar[0].lVal = lPropertyValue;
        
        hr = m_pIWiaPropStg->WriteMultiple(1, propspec, propvar, MIN_PROPID);
    } else {
        hr = E_POINTER;
    }
    return hr;
}

HRESULT CWiahelper::WritePropertyFloat(PROPID PropertyID, FLOAT fPropertyValue)
{
    HRESULT hr = S_OK;
    if (m_pIWiaPropStg) {
        
        PROPSPEC    propspec[1];
        PROPVARIANT propvar[1];
        
        memset(propvar, 0, sizeof(propvar));
        propspec[0].ulKind = PRSPEC_PROPID;
        propspec[0].propid = PropertyID;
        
        propvar[0].vt     = VT_R4;
        propvar[0].fltVal = fPropertyValue;
        
        hr = m_pIWiaPropStg->WriteMultiple(1, propspec, propvar, MIN_PROPID);
    } else {
        hr = E_POINTER;
    }
    return hr;
}

HRESULT CWiahelper::WritePropertyGUID(PROPID PropertyID, GUID guidPropertyValue)
{
    HRESULT hr = S_OK;
    if (m_pIWiaPropStg) {
        
        PROPSPEC    propspec[1];
        PROPVARIANT propvar[1];
        
        memset(propvar, 0, sizeof(propvar));
        propspec[0].ulKind = PRSPEC_PROPID;
        propspec[0].propid = PropertyID;
        
        propvar[0].vt     = VT_CLSID;
        propvar[0].puuid  = &guidPropertyValue;
        
        hr = m_pIWiaPropStg->WriteMultiple(1, propspec, propvar, MIN_PROPID);
    } else {
        hr = E_POINTER;
    }
    return hr;
}

HRESULT CWiahelper::WritePropertyBSTR(PROPID PropertyID, BSTR bstrPropertyValue)
{
    HRESULT hr = S_OK;
    if (m_pIWiaPropStg) {
        
        PROPSPEC    propspec[1];
        PROPVARIANT propvar[1];
        
        memset(propvar, 0, sizeof(propvar));
        propspec[0].ulKind = PRSPEC_PROPID;
        propspec[0].propid = PropertyID;
        
        propvar[0].vt      = VT_BSTR;
        
        // allocate BSTR
        propvar[0].bstrVal = SysAllocString(bstrPropertyValue);
        
        hr = m_pIWiaPropStg->WriteMultiple(1, propspec, propvar, MIN_PROPID);
        
        // free allocated BSTR
        SysFreeString(propvar[0].bstrVal);
    } else {
        hr = E_POINTER;
    }
    return hr;
}

HRESULT CWiahelper::WritePropertyStreamFile(TCHAR *szPropertyStreamFile)
{
    HRESULT hr = S_OK;
    if (m_pIWiaPropStg) {

        IStream *pIStrm  = NULL;
        CFile StreamFile;
        CFileException Exception;                
        GUID guidCompatId = GUID_NULL;

        hr = m_pIWiaPropStg->GetPropertyStream(&guidCompatId, &pIStrm);
        if (S_OK == hr) {
            if (StreamFile.Open(szPropertyStreamFile,CFile::modeCreate|CFile::modeWrite,&Exception)) {
                ULARGE_INTEGER uliSize  = {0,0};
                LARGE_INTEGER  liOrigin = {0,0};
                pIStrm->Seek(liOrigin, STREAM_SEEK_END, &uliSize);
                DWORD dwSize = uliSize.u.LowPart;
                if (dwSize) {
                    StreamFile.Write(&dwSize, sizeof(DWORD));
                    PBYTE pBuf = (PBYTE) LocalAlloc(LPTR, dwSize);
                    if (pBuf) {
                        pIStrm->Seek(liOrigin, STREAM_SEEK_SET, NULL);
                        ULONG ulRead = 0;
                        pIStrm->Read(pBuf, dwSize, &ulRead);
                        StreamFile.Write(pBuf, ulRead);
                        LocalFree(pBuf);
                    }
                }
                StreamFile.Close();
            } else {
                AfxThrowFileException(Exception.m_cause);
            }
            pIStrm->Release();
        }
    } else {
        hr = E_POINTER;
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiatest2\wiaselect.cpp ===
// Wiaselect.cpp : implementation file
//

#include "stdafx.h"
#include "wiatest.h"
#include "Wiaselect.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CWiaselect dialog


CWiaselect::CWiaselect(CWnd* pParent /*=NULL*/)
	: CDialog(CWiaselect::IDD, pParent)
{
	m_bstrSelectedDeviceID = NULL;
    m_lDeviceCount = 0;
    //{{AFX_DATA_INIT(CWiaselect)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


void CWiaselect::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CWiaselect)
	DDX_Control(pDX, IDC_WIADEVICE_LISTBOX, m_WiaDeviceListBox);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CWiaselect, CDialog)
	//{{AFX_MSG_MAP(CWiaselect)
	ON_LBN_DBLCLK(IDC_WIADEVICE_LISTBOX, OnDblclkWiadeviceListbox)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWiaselect message handlers

BOOL CWiaselect::OnInitDialog() 
{
	CDialog::OnInitDialog();
	
	// a WIA device was selected, so continue
    HRESULT hr = S_OK;
    IWiaDevMgr *pIWiaDevMgr = NULL;
    hr = CoCreateInstance(CLSID_WiaDevMgr, NULL, CLSCTX_LOCAL_SERVER, IID_IWiaDevMgr,(void**)&pIWiaDevMgr);    
    if(FAILED(hr)){
        // creation of device manager failed, so we can not continue
        ErrorMessageBox(TEXT("CoCreateInstance failed trying to create the WIA device manager"),hr);
        return FALSE;        
    } else {
        
        // enumerate devices, and fill WIA Device listbox
        m_lDeviceCount = 0;
        ULONG ulFetched   = 0;
        
        IWiaPropertyStorage *pIWiaPropStg = NULL;
        IEnumWIA_DEV_INFO *pWiaEnumDevInfo = NULL;
        hr = pIWiaDevMgr->EnumDeviceInfo(WIA_DEVINFO_ENUM_LOCAL,&pWiaEnumDevInfo);
        if (SUCCEEDED(hr)){
            hr = pWiaEnumDevInfo->Reset();
            if (SUCCEEDED(hr)) {
                do {
                    hr = pWiaEnumDevInfo->Next(1,&pIWiaPropStg,&ulFetched);
                    if (hr == S_OK) {
                        
                        PROPSPEC    PropSpec[2];
                        PROPVARIANT PropVar [2];
                               
                        memset(PropVar,0,sizeof(PropVar));
                                
                        PropSpec[0].ulKind = PRSPEC_PROPID;
                        PropSpec[0].propid = WIA_DIP_DEV_ID;
                               
                        PropSpec[1].ulKind = PRSPEC_PROPID;
                        PropSpec[1].propid = WIA_DIP_DEV_NAME;
                                                                             
                        hr = pIWiaPropStg->ReadMultiple(sizeof(PropSpec)/sizeof(PROPSPEC), PropSpec, PropVar);                                
                        if (hr == S_OK) {                                    
                            
                            // Device ID
                            // PropVar[0].bstrVal

                            // Device Name
                            // PropVar[1].bstrVal

                            TCHAR szDeviceName[MAX_PATH];
                            memset(szDeviceName,0,sizeof(szDeviceName));

                            TSPRINTF(szDeviceName,TEXT("%ws"),PropVar[1].bstrVal);

                            // add name to listbox
                            m_WiaDeviceListBox.AddString(szDeviceName);
                            
                            // add device ID to array
                            m_bstrDeviceIDArray[m_lDeviceCount] = SysAllocString(PropVar[0].bstrVal);
                            
                            FreePropVariantArray(sizeof(PropSpec)/sizeof(PROPSPEC),PropVar);
                        }
                        // release property storage interface
                        pIWiaPropStg->Release();

                        // increment device counter
                        m_lDeviceCount++;
                    }
                } while (hr == S_OK);
            }
        }

        if(m_lDeviceCount <= 0){
            // no devices found?... 
            // disable OK button
            CWnd *pOKButton = NULL;
            pOKButton = GetDlgItem(IDOK);
            if(NULL != pOKButton){
                pOKButton->EnableWindow(FALSE);
            }
            
            // add no device message
            m_WiaDeviceListBox.AddString(TEXT("<No WIA Devices Detected>"));
        }

        if(pIWiaDevMgr){
            pIWiaDevMgr->Release();
            pIWiaDevMgr = NULL;
        }
    }
	
    m_WiaDeviceListBox.SetCurSel(0);

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CWiaselect::OnOK() 
{
	INT SelectedDeviceIndex = m_WiaDeviceListBox.GetCurSel();
    if(SelectedDeviceIndex >= 0){
        m_bstrSelectedDeviceID = SysAllocString(m_bstrDeviceIDArray[SelectedDeviceIndex]);    
    }
	
    FreebstrDeviceIDArray();
	CDialog::OnOK();
}

void CWiaselect::FreebstrDeviceIDArray()
{
    for(LONG i = 0; i < m_lDeviceCount; i++){
        if(NULL != m_bstrDeviceIDArray[i]){
            SysFreeString(m_bstrDeviceIDArray[i]);
            m_bstrDeviceIDArray[i] = NULL;
        }
    }
}

void CWiaselect::OnCancel() 
{
	FreebstrDeviceIDArray();	
	CDialog::OnCancel();
}

void CWiaselect::OnDblclkWiadeviceListbox() 
{
    OnOK();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiatest2\wiasimpledocpg.cpp ===
// WiaSimpleDocPg.cpp : implementation file
//

#include "stdafx.h"
#include "wiatest.h"
#include "WiaSimpleDocPg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CWiaSimpleDocPg property page

IMPLEMENT_DYNCREATE(CWiaSimpleDocPg, CPropertyPage)

CWiaSimpleDocPg::CWiaSimpleDocPg() : CPropertyPage(CWiaSimpleDocPg::IDD)
{
        //{{AFX_DATA_INIT(CWiaSimpleDocPg)
        //}}AFX_DATA_INIT
}

CWiaSimpleDocPg::~CWiaSimpleDocPg()
{
}

void CWiaSimpleDocPg::DoDataExchange(CDataExchange* pDX)
{
        CPropertyPage::DoDataExchange(pDX);
        //{{AFX_DATA_MAP(CWiaSimpleDocPg)
        DDX_Control(pDX, IDC_NUMBEROF_PAGES_EDITBOX, m_lPages);
        DDX_Control(pDX, IDC_NUMBEROF_PAGES_EDITBOX_TEXT, m_lPagesText);
        DDX_Control(pDX, IDC_DOCUMENT_SOURCE_COMBOBOX, m_DocumentSourceComboBox);
        //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CWiaSimpleDocPg, CPropertyPage)
        //{{AFX_MSG_MAP(CWiaSimpleDocPg)
        ON_CBN_SELCHANGE(IDC_DOCUMENT_SOURCE_COMBOBOX, OnSelchangeDocumentSourceCombobox)
        ON_EN_UPDATE(IDC_NUMBEROF_PAGES_EDITBOX, OnUpdateNumberofPagesEditbox)
        //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWiaSimpleDocPg message handlers

BOOL CWiaSimpleDocPg::OnInitDialog() 
{
    CPropertyPage::OnInitDialog();
    m_bFirstInit = TRUE;
    CWiahelper WIA;
    WIA.SetIWiaItem(m_pIRootItem);
    HRESULT hr = S_OK;

    // set current settings
    LONG lDocumentHandlingSelect = 0;    
    hr = WIA.ReadPropertyLong(WIA_DPS_DOCUMENT_HANDLING_SELECT,&lDocumentHandlingSelect);
    if(FAILED(hr)){
        ErrorMessageBox(IDS_WIATESTERROR_READINGDOCHANDLINGSELECT,hr);
    }

    if(lDocumentHandlingSelect & FEEDER){
        // default to feeder settings
        m_DocumentSourceComboBox.SetCurSel(DOCUMENT_SOURCE_FEEDER);
    } else {
        // default to flatbed settings
        m_DocumentSourceComboBox.SetCurSel(DOCUMENT_SOURCE_FLATBED);
    }
        
    LONG lPages = 0;
    hr = WIA.ReadPropertyLong(WIA_DPS_PAGES,&lPages);
    if(FAILED(hr)){
        ErrorMessageBox(IDS_WIATESTERROR_READINGPAGES,hr);
    }

    TCHAR szPages[MAX_PATH];
    memset(szPages,0,sizeof(szPages));
    TSPRINTF(szPages,TEXT("%d"),lPages);
    m_lPages.SetWindowText(szPages);
    
    // adjust UI
    OnSelchangeDocumentSourceCombobox();
    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

void CWiaSimpleDocPg::OnSelchangeDocumentSourceCombobox() 
{
    if(m_bFirstInit){
        m_bFirstInit = FALSE;
    } else {
        SetModified();
    }
    if (m_pIRootItem) {        
        INT iCurSel = DOCUMENT_SOURCE_FLATBED;
        iCurSel = m_DocumentSourceComboBox.GetCurSel();
        switch (iCurSel) {
        case DOCUMENT_SOURCE_FLATBED:
            m_lPagesText.EnableWindow(FALSE);
            m_lPages.EnableWindow(FALSE);            
            break;
        case DOCUMENT_SOURCE_FEEDER:
            m_lPagesText.EnableWindow(TRUE);
            m_lPages.EnableWindow(TRUE);            
            break;
        default:
            break;
        }
    }
}

BOOL CWiaSimpleDocPg::OnApply() 
{
    HRESULT hr = S_OK;
    CWiahelper WIA;
    WIA.SetIWiaItem(m_pIRootItem);

    // set pages property
    LONG lPages = 0;
    lPages = (LONG)GetNumberOfPagesToAcquire();    
    hr = WIA.WritePropertyLong(WIA_DPS_PAGES,lPages);
    if (FAILED(hr)) {
        ErrorMessageBox(IDS_WIATESTERROR_WRITINGPAGES,hr);
    }    

    // set Document Handling Select property
    if(GetSelectedDocumentSource() == DOCUMENT_SOURCE_FLATBED){        
        hr = WIA.WritePropertyLong(WIA_DPS_DOCUMENT_HANDLING_SELECT,FLATBED);
    } else {
        hr = WIA.WritePropertyLong(WIA_DPS_DOCUMENT_HANDLING_SELECT,FEEDER);
    }
    
    if (FAILED(hr)) {
        ErrorMessageBox(IDS_WIATESTERROR_WRITINGDOCHANDLINGSELECT,hr);
    }

    return CPropertyPage::OnApply();
}

int CWiaSimpleDocPg::GetSelectedDocumentSource()
{    
    return m_DocumentSourceComboBox.GetCurSel();
}

int CWiaSimpleDocPg::GetNumberOfPagesToAcquire()
{
    int iPagesToAcquire = 1;
    TCHAR szPages[MAX_PATH];
    memset(szPages,0,sizeof(szPages));
    UpdateData();
    m_lPages.GetWindowText(szPages,(sizeof(szPages)/sizeof(TCHAR)));
    TSSCANF(szPages,TEXT("%d"),&iPagesToAcquire);
    return iPagesToAcquire;
}

void CWiaSimpleDocPg::OnUpdateNumberofPagesEditbox() 
{
    SetModified();        
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiatest2\wiaselect.h ===
#if !defined(AFX_WIASELECT_H__B8718725_9CA2_404F_A1D3_18BC0CADB3CE__INCLUDED_)
#define AFX_WIASELECT_H__B8718725_9CA2_404F_A1D3_18BC0CADB3CE__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// Wiaselect.h : header file
//

#define MAX_WIA_DEVICES 50

/////////////////////////////////////////////////////////////////////////////
// CWiaselect dialog

class CWiaselect : public CDialog
{
// Construction
public:
	CWiaselect(CWnd* pParent = NULL);   // standard constructor
    BSTR m_bstrSelectedDeviceID;

// Dialog Data
	//{{AFX_DATA(CWiaselect)
	enum { IDD = IDD_SELECTDEVICE_DIALOG };
	CListBox	m_WiaDeviceListBox;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CWiaselect)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
    LONG m_lDeviceCount;
    BSTR m_bstrDeviceIDArray[MAX_WIA_DEVICES];
    void FreebstrDeviceIDArray();
	// Generated message map functions
	//{{AFX_MSG(CWiaselect)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	virtual void OnCancel();
	afx_msg void OnDblclkWiadeviceListbox();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_WIASELECT_H__B8718725_9CA2_404F_A1D3_18BC0CADB3CE__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiatest2\wiahelper.h ===
// CWiahelper.h: interface for the cwiahelper class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_CWIAHELPER_H__840CF989_FE02_4C81_B38F_361914E1CBC7__INCLUDED_)
#define AFX_CWIAHELPER_H__840CF989_FE02_4C81_B38F_361914E1CBC7__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define MIN_PROPID 2

class CWiahelper  
{
public:
	CWiahelper();
	virtual ~CWiahelper();
    
    HRESULT SetIWiaItem(IWiaItem *pIWiaItem);

    HRESULT ReadPropertyString(PROPID PropertyID, LPTSTR szPropertyValue);
    HRESULT ReadPropertyLong(PROPID PropertyID, LONG *plPropertyValue);
    HRESULT ReadPropertyFloat(PROPID PropertyID, FLOAT *pfPropertyValue);
    HRESULT ReadPropertyGUID(PROPID PropertyID, GUID *pguidPropertyValue);
    HRESULT ReadPropertyData(PROPID PropertyID, BYTE **ppData, LONG *pDataSize);
    HRESULT ReadPropertyBSTR(PROPID PropertyID, BSTR *pbstrPropertyValue);
    HRESULT ReadPropertyStreamFile(TCHAR *szPropertyStreamFile);

    HRESULT WritePropertyString(PROPID PropertyID, LPTSTR szPropertyValue);
    HRESULT WritePropertyLong(PROPID PropertyID, LONG lPropertyValue);
    HRESULT WritePropertyFloat(PROPID PropertyID, FLOAT fPropertyValue);
    HRESULT WritePropertyGUID(PROPID PropertyID, GUID guidPropertyValue);
    HRESULT WritePropertyBSTR(PROPID PropertyID, BSTR bstrPropertyValue);
    HRESULT WritePropertyStreamFile(TCHAR *szPropertyStreamFile);


private:
    IWiaItem *m_pIWiaItem;
    IWiaPropertyStorage *m_pIWiaPropStg;
};

#endif // !defined(AFX_CWIAHELPER_H__840CF989_FE02_4C81_B38F_361914E1CBC7__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiatest2\wiaitemlistctrl.cpp ===
// WiaitemListCtrl.cpp : implementation file
//

#include "stdafx.h"
#include "wiatest.h"
#include "WiaitemListCtrl.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CWiaitemListCtrl

CWiaitemListCtrl::CWiaitemListCtrl()
{
}

CWiaitemListCtrl::~CWiaitemListCtrl()
{
}


BEGIN_MESSAGE_MAP(CWiaitemListCtrl, CListCtrl)
	//{{AFX_MSG_MAP(CWiaitemListCtrl)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWiaitemListCtrl message handlers

void CWiaitemListCtrl::SetupColumnHeaders()
{
    LVCOLUMN lv;
    TCHAR szColumnName[MAX_PATH];
    memset(szColumnName,0,sizeof(szColumnName));
    HINSTANCE hInstance = NULL;
    hInstance = AfxGetInstanceHandle();
    if(hInstance){
        int i = 0;
        // initialize item property list control column headers
        
        // Property name
        
        LoadString(hInstance,IDS_WIATESTCOLUMN_PROPERTY,szColumnName,MAX_PATH);
        
        lv.mask         = LVCF_FMT | LVCF_TEXT | LVCF_WIDTH;
        lv.fmt          = LVCFMT_LEFT ;
        lv.cx           = 100;
        lv.pszText      = szColumnName;
        lv.cchTextMax   = 0;
        lv.iSubItem     = ITEMPROPERTYLISTCTRL_COLUMN_PROPERTYNAME;
        lv.iImage       = 0;
        lv.iOrder       = ITEMPROPERTYLISTCTRL_COLUMN_PROPERTYNAME;
        i = InsertColumn(ITEMPROPERTYLISTCTRL_COLUMN_PROPERTYNAME,&lv);
        
        // Property Value (current)
        LoadString(hInstance,IDS_WIATESTCOLUMN_VALUE,szColumnName,MAX_PATH);
        lv.cx           = 125;
        lv.iOrder       = ITEMPROPERTYLISTCTRL_COLUMN_PROPERTYVALUE;
        lv.iSubItem     = ITEMPROPERTYLISTCTRL_COLUMN_PROPERTYVALUE;
        lv.pszText      = szColumnName;
        i = InsertColumn(ITEMPROPERTYLISTCTRL_COLUMN_PROPERTYVALUE,&lv);
        
        // VT_???
        LoadString(hInstance,IDS_WIATESTCOLUMN_VARTYPE,szColumnName,MAX_PATH);
        lv.cx           = 85;
        lv.iOrder       = ITEMPROPERTYLISTCTRL_COLUMN_PROPERTYVARTYPE;
        lv.iSubItem     = ITEMPROPERTYLISTCTRL_COLUMN_PROPERTYVARTYPE;
        lv.pszText      = szColumnName;
        i = InsertColumn(ITEMPROPERTYLISTCTRL_COLUMN_PROPERTYVARTYPE,&lv);
        
        // Property access Flags
        LoadString(hInstance,IDS_WIATESTCOLUMN_ACCESSFLAGS,szColumnName,MAX_PATH);
        lv.cx           = 500;
        lv.iOrder       = ITEMPROPERTYLISTCTRL_COLUMN_PROPERTYACCESS;
        lv.iSubItem     = ITEMPROPERTYLISTCTRL_COLUMN_PROPERTYACCESS;
        lv.pszText      = szColumnName;
        i = InsertColumn(ITEMPROPERTYLISTCTRL_COLUMN_PROPERTYACCESS,&lv);
    }    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiatest2\wiaitemlistctrl.h ===
#if !defined(AFX_WIAITEMLISTCTRL_H__576B6687_37FB_4EF8_A9A7_D309F3806530__INCLUDED_)
#define AFX_WIAITEMLISTCTRL_H__576B6687_37FB_4EF8_A9A7_D309F3806530__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// WiaitemListCtrl.h : header file
//

#define ITEMPROPERTYLISTCTRL_COLUMN_PROPERTYNAME    0
#define ITEMPROPERTYLISTCTRL_COLUMN_PROPERTYVALUE   1
#define ITEMPROPERTYLISTCTRL_COLUMN_PROPERTYVARTYPE 2
#define ITEMPROPERTYLISTCTRL_COLUMN_PROPERTYACCESS  3

/////////////////////////////////////////////////////////////////////////////
// CWiaitemListCtrl window

class CWiaitemListCtrl : public CListCtrl
{
// Construction
public:
	CWiaitemListCtrl();

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CWiaitemListCtrl)
	//}}AFX_VIRTUAL

// Implementation
public:	
	void SetupColumnHeaders();
	virtual ~CWiaitemListCtrl();

	// Generated message map functions
protected:
	//{{AFX_MSG(CWiaitemListCtrl)
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_WIAITEMLISTCTRL_H__576B6687_37FB_4EF8_A9A7_D309F3806530__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiatest2\wiasimpledocpg.h ===
#if !defined(AFX_WIASIMPLEDOCPG_H__B381D147_AF77_49A4_9DC1_4E8F9F28C8BD__INCLUDED_)
#define AFX_WIASIMPLEDOCPG_H__B381D147_AF77_49A4_9DC1_4E8F9F28C8BD__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// WiaSimpleDocPg.h : header file
//

#define DOCUMENT_SOURCE_FLATBED 0
#define DOCUMENT_SOURCE_FEEDER  1

/////////////////////////////////////////////////////////////////////////////
// CWiaSimpleDocPg dialog

class CWiaSimpleDocPg : public CPropertyPage
{
    DECLARE_DYNCREATE(CWiaSimpleDocPg)

// Construction
public:
    IWiaItem *m_pIRootItem;
    CWiaSimpleDocPg();
    ~CWiaSimpleDocPg();

// Dialog Data
    //{{AFX_DATA(CWiaSimpleDocPg)
    enum { IDD = IDD_PROPPAGE_SIMPLE_DOCUMENT_SCANNERS_SETTINGS };
    CEdit   m_lPages;
    CStatic m_lPagesText;
    CComboBox   m_DocumentSourceComboBox;
    //}}AFX_DATA


// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CWiaSimpleDocPg)
    public:
    virtual BOOL OnApply();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    BOOL m_bFirstInit;
    int GetSelectedDocumentSource();
    int GetNumberOfPagesToAcquire();
    // Generated message map functions
    //{{AFX_MSG(CWiaSimpleDocPg)
    virtual BOOL OnInitDialog();
    afx_msg void OnSelchangeDocumentSourceCombobox();
    afx_msg void OnUpdateNumberofPagesEditbox();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_WIASIMPLEDOCPG_H__B381D147_AF77_49A4_9DC1_4E8F9F28C8BD__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiatest2\wiatest.cpp ===
// wiatest.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "wiatest.h"

#include "MainFrm.h"
#include "ChildFrm.h"
#include "wiatestDoc.h"
#include "wiatestView.h"
#include "WiaeditpropTable.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

LONG WIACONSTANT_VALUE_FROMINDEX(int index)
{
    return g_EditPropTable[index].lVal;
}

TCHAR *WIACONSTANT_TSTR_FROMINDEX(int index)
{
    return g_EditPropTable[index].pszValName;
}

INT FindEndIndexInTable(TCHAR *pszPropertyName)
{
    int index = FindStartIndexInTable(pszPropertyName);
    if(index >=0){
        while((g_EditPropTable[index].pszPropertyName != NULL) && (lstrcmpi(pszPropertyName,g_EditPropTable[index].pszPropertyName) == 0)){
            index++;
        }
    }
    return (index - 1);
}

INT FindStartIndexInTable(TCHAR *pszPropertyName)
{
    int index = 0;
    BOOL bFound = FALSE;    
    while((g_EditPropTable[index].pszPropertyName != NULL) && (bFound == FALSE) ){
        // check for property name
        if(lstrcmpi(pszPropertyName,g_EditPropTable[index].pszPropertyName) == 0){
            // we found property name
            bFound = TRUE;
        } else {
            index++;
        }               
    }
    if(!bFound){
        index = -1;
    }
    return index;
}

BOOL WIACONSTANT2TSTR(TCHAR *pszPropertyName, LONG lValue, TCHAR *pszValName)
{
    BOOL bFound = FALSE;
    if(pszValName){
        int index = 0;        
        while((g_EditPropTable[index].pszPropertyName != NULL) && (bFound == FALSE) ){
            // check for property name
            if(lstrcmpi(pszPropertyName,g_EditPropTable[index].pszPropertyName) == 0){
                // we found property name
                if(g_EditPropTable[index].lVal == lValue){
                    lstrcpy(pszValName,g_EditPropTable[index].pszValName);
                    bFound = TRUE;
                }
            }
            index++;
        }        
    }
    return bFound;
}

BOOL TSTR2WIACONSTANT(TCHAR *pszPropertyName, TCHAR *pszValName, LONG *plVal)
{
    BOOL bFound = FALSE;
    if(pszValName){
        int index = 0;        
        while((g_EditPropTable[index].pszPropertyName != NULL) && (bFound == FALSE)){
            // check for property name
            if(lstrcmpi(pszPropertyName,g_EditPropTable[index].pszPropertyName) == 0){
                // we found property name                
                if(lstrcmpi(g_EditPropTable[index].pszValName,pszValName) == 0){
                    *plVal = g_EditPropTable[index].lVal;
                    bFound = TRUE;
                }
            }
            index++;
        }        
    }
    return bFound;
}

void RC2TSTR(UINT uResourceID, TCHAR *szString, LONG size)
{    
    memset(szString,0,size);
    INT iNumTCHARSWritten = 0;

    HINSTANCE hInstance = NULL;
    hInstance = AfxGetInstanceHandle();
    if(!hInstance){
        MessageBox(NULL,TEXT("Could not get WIATEST's HINSTANCE for string loading."),TEXT("WIATEST Error"),MB_ICONERROR);
        return;
    }

    iNumTCHARSWritten = LoadString(hInstance,uResourceID,szString,(size / (sizeof(TCHAR))));
}

void StatusMessageBox(HWND hWnd, UINT uResourceID)
{
    TCHAR szResourceString[MAX_PATH];
    memset(szResourceString,0,sizeof(szResourceString));    
    RC2TSTR(uResourceID,szResourceString,sizeof(szResourceString));                
    StatusMessageBox(hWnd,szResourceString);
}

void StatusMessageBox(HWND hWnd, LPTSTR szStatusText)
{
    TCHAR Title[MAX_PATH];
    memset(Title,0,sizeof(Title));    
        
    // load status dialog title
    RC2TSTR(IDS_WIASTATUS_DIALOGTITLE,Title,sizeof(Title));
    MessageBox(hWnd,szStatusText,Title, MB_ICONINFORMATION);        
}

void StatusMessageBox(UINT uResourceID)
{
    TCHAR szResourceString[MAX_PATH];
    memset(szResourceString,0,sizeof(szResourceString));    
    RC2TSTR(uResourceID,szResourceString,sizeof(szResourceString));                
    StatusMessageBox(szResourceString);
}

void StatusMessageBox(LPTSTR szStatusText)
{
    TCHAR Title[MAX_PATH];
    memset(Title,0,sizeof(Title));    
        
    // load status dialog title
    RC2TSTR(IDS_WIASTATUS_DIALOGTITLE,Title,sizeof(Title));
    MessageBox(NULL,szStatusText,Title, MB_ICONINFORMATION);
}

void ErrorMessageBox(UINT uResourceID, HRESULT hrError)
{
    TCHAR szResourceString[MAX_PATH];
    memset(szResourceString,0,sizeof(szResourceString));    
    RC2TSTR(uResourceID,szResourceString,sizeof(szResourceString));
    ErrorMessageBox(szResourceString,hrError);
}

void ErrorMessageBox(LPTSTR szErrorText, HRESULT hrError)
{
    ULONG ulLen = MAX_PATH;
    TCHAR MsgBuf[MAX_PATH];
    TCHAR *pAllocMsgBuf = NULL;
    TCHAR Title[MAX_PATH];
    memset(Title,0,sizeof(Title));
    memset(MsgBuf,0,sizeof(MsgBuf));
        
    // load error dialog title    
    RC2TSTR(IDS_WIAERROR_DIALOGTITLE,Title,sizeof(Title));

    // attempt to handle WIA custom errors first
    switch (hrError) {
    case WIA_ERROR_GENERAL_ERROR:
        RC2TSTR(IDS_WIAERROR_GENERAL,MsgBuf,sizeof(MsgBuf));
        break;
    case WIA_ERROR_PAPER_JAM:
        RC2TSTR(IDS_WIAERROR_PAPERJAM ,MsgBuf,sizeof(MsgBuf));
        break;
    case WIA_ERROR_PAPER_EMPTY:
        RC2TSTR(IDS_WIAERROR_PAPEREMPTY ,MsgBuf,sizeof(MsgBuf));
        break;
    case WIA_ERROR_PAPER_PROBLEM:
        RC2TSTR(IDS_WIAERROR_PAPERPROBLEM ,MsgBuf,sizeof(MsgBuf));
        break;
    case WIA_ERROR_OFFLINE:
        RC2TSTR(IDS_WIAERROR_DEVICEOFFLINE ,MsgBuf,sizeof(MsgBuf));        
        break;
    case WIA_ERROR_BUSY:
        RC2TSTR(IDS_WIAERROR_DEVICEBUSY,MsgBuf,sizeof(MsgBuf));
        break;
    case WIA_ERROR_WARMING_UP:
        RC2TSTR(IDS_WIAERROR_WARMINGUP,MsgBuf,sizeof(MsgBuf));        
        break;
    case WIA_ERROR_USER_INTERVENTION:
        RC2TSTR(IDS_WIAERROR_USERINTERVENTION,MsgBuf,sizeof(MsgBuf));        
        break;
    case WIA_ERROR_ITEM_DELETED:
        RC2TSTR(IDS_WIAERROR_ITEMDELETED,MsgBuf,sizeof(MsgBuf));        
        break;
    case WIA_ERROR_DEVICE_COMMUNICATION:
        RC2TSTR(IDS_WIAERROR_DEVICECOMMUNICATION,MsgBuf,sizeof(MsgBuf));        
        break;
    case WIA_ERROR_INVALID_COMMAND:
        RC2TSTR(IDS_WIAERROR_INVALIDCOMMAND,MsgBuf,sizeof(MsgBuf));        
        break;
    case S_OK:
        lstrcpy(MsgBuf,szErrorText);
        break;
    default:

        ulLen = 0;
        ulLen = ::FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
                                NULL, hrError, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                                (LPTSTR)&pAllocMsgBuf, 0, NULL);
        break;
    }

    if (ulLen <= 0) {
        // just use the HRESULT as a formatted string
        TSPRINTF(MsgBuf,TEXT("HRESULT = 0x%08X"),hrError);
    } else {
        if(pAllocMsgBuf){
            // trim right (remove \r\n from formatted string)
            pAllocMsgBuf[ulLen - (2 * sizeof(TCHAR))] = 0;  // reterminate the string
            // copy string into message buffer
            lstrcpy(MsgBuf,pAllocMsgBuf);
            // FormatMessage allocated a buffer to display        
            LocalFree(pAllocMsgBuf);
        }
    }

    if(S_OK != hrError){
        TCHAR szFinalText[MAX_PATH];
        memset(szFinalText,0,sizeof(szFinalText));
        
#ifndef UNICODE    
        TSPRINTF(szFinalText,TEXT("%s\n(%s)"),szErrorText,MsgBuf);
#else
        TSPRINTF(szFinalText,TEXT("%ws\n(%ws)"),szErrorText,MsgBuf);
#endif
        MessageBox(NULL,szFinalText,Title,MB_ICONERROR);
    } else {
        MessageBox(NULL,szErrorText,Title,MB_ICONWARNING);
    }            
}

/////////////////////////////////////////////////////////////////////////////
// CWiatestApp

BEGIN_MESSAGE_MAP(CWiatestApp, CWinApp)
    //{{AFX_MSG_MAP(CWiatestApp)
    ON_COMMAND(ID_APP_ABOUT, OnAppAbout)
        // NOTE - the ClassWizard will add and remove mapping macros here.
        //    DO NOT EDIT what you see in these blocks of generated code!
    //}}AFX_MSG_MAP
    // Standard file based document commands
    ON_COMMAND(ID_FILE_NEW, CWinApp::OnFileNew)
    ON_COMMAND(ID_FILE_OPEN, CWinApp::OnFileOpen)
    // Standard print setup command
    ON_COMMAND(ID_FILE_PRINT_SETUP, CWinApp::OnFilePrintSetup)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWiatestApp construction

CWiatestApp::CWiatestApp()
{
    // TODO: add construction code here,
    // Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CWiatestApp object

CWiatestApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CWiatestApp initialization

BOOL CWiatestApp::InitInstance()
{
    // initialize DEBUG library    
    DBG_INIT(m_hInstance);
        
    // initialize COM
    CoInitialize(NULL);
    
    AfxEnableControlContainer();

    // Standard initialization
    // If you are not using these features and wish to reduce the size
    //  of your final executable, you should remove from the following
    //  the specific initialization routines you do not need.

#ifdef _AFXDLL
    Enable3dControls();         // Call this when using MFC in a shared DLL
#else
    Enable3dControlsStatic();   // Call this when linking to MFC statically
#endif

    SetRegistryKey(_T("Microsoft"));

    LoadStdProfileSettings();  // Load standard INI file options (including MRU)

    // Register the application's document templates.  Document templates
    //  serve as the connection between documents, frame windows and views.

    CMultiDocTemplate* pDocTemplate;
    pDocTemplate = new CMultiDocTemplate(
        IDR_WIATESTYPE,
        RUNTIME_CLASS(CWiatestDoc),
        RUNTIME_CLASS(CChildFrame), // custom MDI child frame
        RUNTIME_CLASS(CWiatestView));
    AddDocTemplate(pDocTemplate);

    // create main MDI Frame window
    CMainFrame* pMainFrame = new CMainFrame;
    if (!pMainFrame->LoadFrame(IDR_MAINFRAME))
        return FALSE;
    m_pMainWnd = pMainFrame;

    // Parse command line for standard shell commands, DDE, file open
    CCommandLineInfo cmdInfo;
    ParseCommandLine(cmdInfo);

#ifdef _OPEN_NEW_DEVICE_ON_STARTUP
    // Dispatch commands specified on the command line
    if (!ProcessShellCommand(cmdInfo))
        return FALSE;
#endif

    // The main window has been initialized, so show and update it.
    pMainFrame->ShowWindow(m_nCmdShow);
    pMainFrame->UpdateWindow();

    return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
    CAboutDlg();

// Dialog Data
    //{{AFX_DATA(CAboutDlg)
    enum { IDD = IDD_ABOUTBOX };
    //}}AFX_DATA

    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CAboutDlg)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    //{{AFX_MSG(CAboutDlg)
        // No message handlers
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
    //{{AFX_DATA_INIT(CAboutDlg)
    //}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CAboutDlg)
    //}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
    //{{AFX_MSG_MAP(CAboutDlg)
        // No message handlers
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

// App command to run the dialog
void CWiatestApp::OnAppAbout()
{
    CAboutDlg aboutDlg;
    aboutDlg.DoModal();
}

/////////////////////////////////////////////////////////////////////////////
// CWiatestApp message handlers


int CWiatestApp::ExitInstance() 
{    
    // uninitialize COM
    CoUninitialize();
    return CWinApp::ExitInstance();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiatest2\wiatest.h ===
// wiatest.h : main header file for the WIATEST application
//

#if !defined(AFX_WIATEST_H__EAC38623_6251_45A9_9A2B_C1CF0A92673E__INCLUDED_)
#define AFX_WIATEST_H__EAC38623_6251_45A9_9A2B_C1CF0A92673E__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef __AFXWIN_H__
    #error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"       // main symbols

#ifdef UNICODE
    #define TSTRSTR wcsstr
    #define TSSCANF swscanf
    #define TSPRINTF swprintf
#else
    #define TSTRSTR strstr
    #define TSSCANF sscanf
    #define TSPRINTF sprintf
#endif

#define WM_DEVICE_DISCONNECTED WM_USER + 900
#define WM_DEVICE_CONNECTED    WM_USER + 901
#define WM_ITEM_DELETED        WM_USER + 902
#define WM_ITEM_CREATED        WM_USER + 903
#define WM_TREE_UPDATED        WM_USER + 904
#define WM_STORAGE_CREATED     WM_USER + 905
#define WM_STORAGE_DELETED     WM_USER + 906

void Trace(LPCTSTR format,...);
LONG WIACONSTANT_VALUE_FROMINDEX(int index);
TCHAR *WIACONSTANT_TSTR_FROMINDEX(int index);
INT FindEndIndexInTable(TCHAR *pszPropertyName);
INT FindStartIndexInTable(TCHAR *pszPropertyName);
BOOL WIACONSTANT2TSTR(TCHAR *pszPropertyName, LONG lValue, TCHAR *pszValName);
BOOL TSTR2WIACONSTANT(TCHAR *pszPropertyName, TCHAR *pszValName, LONG *plVal);
void RC2TSTR(UINT uResourceID, TCHAR *szString, LONG size);
void StatusMessageBox(HWND hWnd, UINT uResourceID);
void StatusMessageBox(HWND hWnd, LPTSTR szStatusText);
void StatusMessageBox(UINT uResourceID);
void StatusMessageBox(LPTSTR szStatusText);
void ErrorMessageBox(UINT uResourceID, HRESULT hrError = S_OK);
void ErrorMessageBox(LPTSTR szErrorText, HRESULT hrError = S_OK);

/////////////////////////////////////////////////////////////////////////////
// CWiatestApp:
// See wiatest.cpp for the implementation of this class
//

class CWiatestApp : public CWinApp
{
public:
    CWiatestApp();

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CWiatestApp)
    public:
    virtual BOOL InitInstance();
    virtual int ExitInstance();
    //}}AFX_VIRTUAL

// Implementation
    //{{AFX_MSG(CWiatestApp)
    afx_msg void OnAppAbout();
        // NOTE - the ClassWizard will add and remove member functions here.
        //    DO NOT EDIT what you see in these blocks of generated code !
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_WIATEST_H__EAC38623_6251_45A9_9A2B_C1CF0A92673E__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiatest2\wiatestdoc.h ===
// wiatestDoc.h : interface of the CWiatestDoc class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_WIATESTDOC_H__67C27B39_655D_4B44_863B_9E460A93DDE5__INCLUDED_)
#define AFX_WIATESTDOC_H__67C27B39_655D_4B44_863B_9E460A93DDE5__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


class CWiatestDoc : public CDocument
{
protected: // create from serialization only
	CWiatestDoc();
	DECLARE_DYNCREATE(CWiatestDoc)

// Attributes
public:
    IWiaItem *m_pIRootItem;     // WIA Root Item
    IWiaItem *m_pICurrentItem;  // WIA Active Item (used for property manipulation)
// Operations
public:
    void ReleaseItems();
// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CWiatestDoc)
	public:
	virtual BOOL OnNewDocument();
	virtual void Serialize(CArchive& ar);
	//}}AFX_VIRTUAL

// Implementation
public:
	HRESULT SetCurrentIWiaItem(IWiaItem *pIWiaItem);
	HRESULT GetDeviceName(LPTSTR szDeviceName);
	virtual ~CWiatestDoc();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:

// Generated message map functions
protected:
	//{{AFX_MSG(CWiatestDoc)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_WIATESTDOC_H__67C27B39_655D_4B44_863B_9E460A93DDE5__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiatest2\wiatestdoc.cpp ===
// wiatestDoc.cpp : implementation of the CWiatestDoc class
//

#include "stdafx.h"
#include "wiatest.h"

#include "wiatestDoc.h"
#include "wiaselect.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CWiatestDoc

IMPLEMENT_DYNCREATE(CWiatestDoc, CDocument)

BEGIN_MESSAGE_MAP(CWiatestDoc, CDocument)
	//{{AFX_MSG_MAP(CWiatestDoc)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWiatestDoc construction/destruction

CWiatestDoc::CWiatestDoc()
{
	m_pIRootItem    = NULL;
    m_pICurrentItem = NULL;
}

CWiatestDoc::~CWiatestDoc()
{
    ReleaseItems();
}

BOOL CWiatestDoc::OnNewDocument()
{
	BOOL bSuccess = FALSE;

    if (!CDocument::OnNewDocument())
		return bSuccess;
    
    // select a WIA device
    CWiaselect SelectDeviceDlg;
    if(SelectDeviceDlg.DoModal() != IDOK){
        // no device was selected, so do not create a new document
        return bSuccess;
    }

    // a WIA device was selected, so continue
    HRESULT hr = S_OK;
    IWiaDevMgr *pIWiaDevMgr = NULL;
    hr = CoCreateInstance(CLSID_WiaDevMgr, NULL, CLSCTX_LOCAL_SERVER, IID_IWiaDevMgr,(void**)&pIWiaDevMgr);
    if(FAILED(hr)){
        // creation of device manager failed, so we can not continue        
        ErrorMessageBox(IDS_WIATESTERROR_COCREATEWIADEVMGR,hr);        
        return bSuccess;
    }
    
    // create WIA device   
    hr = pIWiaDevMgr->CreateDevice(SelectDeviceDlg.m_bstrSelectedDeviceID, &m_pIRootItem);
    if(FAILED(hr)){
    
        bSuccess = FALSE;        
        // creation of device failed, so we can not continue
        ErrorMessageBox(IDS_WIATESTERROR_CREATEDEVICE,hr);
    } else {
        bSuccess = TRUE;
    }

    // release WIA device manager
    pIWiaDevMgr->Release();
    
    // set document's title to be the WIA device's name
    TCHAR szDeviceName[MAX_PATH];
    GetDeviceName(szDeviceName);
    SetTitle(szDeviceName);
    
	return bSuccess;
}



/////////////////////////////////////////////////////////////////////////////
// CWiatestDoc serialization

void CWiatestDoc::Serialize(CArchive& ar)
{
	if (ar.IsStoring())
	{
		// TODO: add storing code here
	}
	else
	{
		// TODO: add loading code here
	}
}

/////////////////////////////////////////////////////////////////////////////
// CWiatestDoc diagnostics

#ifdef _DEBUG
void CWiatestDoc::AssertValid() const
{
	CDocument::AssertValid();
}

void CWiatestDoc::Dump(CDumpContext& dc) const
{
	CDocument::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CWiatestDoc commands

void CWiatestDoc::ReleaseItems()
{
    // is CurrentItem different from RootItem?
    if(m_pICurrentItem != m_pIRootItem){
        
        // release CurrentItem
        if(m_pICurrentItem){
            m_pICurrentItem->Release();            
        }

        // release RootItem
        if(m_pIRootItem){
            m_pIRootItem->Release();            
        }

    } else {
        // CurrentItem is the RootItem
        // release RootItem and set CurrentItem to NULL
        if(m_pIRootItem){
            m_pIRootItem->Release();            
        }
    }

    m_pIRootItem    = NULL;
    m_pICurrentItem = NULL;
}

HRESULT CWiatestDoc::GetDeviceName(LPTSTR szDeviceName)
{
    HRESULT hr = S_OK;
        
    if(NULL == m_pIRootItem){
        return E_FAIL;
    }
    
    CWiahelper WIA;
    hr = WIA.SetIWiaItem(m_pIRootItem);
    if(SUCCEEDED(hr)){
        hr = WIA.ReadPropertyString(WIA_DIP_DEV_NAME,szDeviceName);
    }
    
    return hr;
}

HRESULT CWiatestDoc::SetCurrentIWiaItem(IWiaItem *pIWiaItem)
{
    HRESULT hr = S_OK;
    if(m_pICurrentItem){
        m_pICurrentItem->Release();
        m_pICurrentItem = NULL;
    }

    // AddRef the item, becuase we are storing it
    pIWiaItem->AddRef();
    // set the current item
    m_pICurrentItem = pIWiaItem;
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiatest2\wiatestview.cpp ===
// wiatestView.cpp : implementation of the CWiatestView class
//

#include "stdafx.h"
#include "wiatest.h"

#include "wiatestDoc.h"
#include "wiatestView.h"
#include "wiaeditpropdlg.h"
#include "wiacapdlg.h"
#include "wiaacquiredlg.h"
#include "wiadatacallback.h"

#include "wiadocacqsettings.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CWiatestView

IMPLEMENT_DYNCREATE(CWiatestView, CFormView)

BEGIN_MESSAGE_MAP(CWiatestView, CFormView)
    //{{AFX_MSG_MAP(CWiatestView)
    ON_NOTIFY(TVN_SELCHANGED, IDC_ITEM_TREECTRL, OnSelchangedItemTreectrl)
    ON_WM_SIZE()
    ON_NOTIFY(NM_DBLCLK, IDC_ITEMPROPERTIES_LISTCTRL, OnDblclkItempropertiesListctrl)
    ON_COMMAND(IDM_ACQUIREIMAGE, OnAcquireimage)
    ON_COMMAND(IDM_LOAD_WIAPROPERTYSTREAM, OnLoadWiapropertystream)
    ON_COMMAND(IDM_SAVE_WIAPROPERTYSTREAM, OnSaveWiapropertystream)
    ON_NOTIFY(NM_RCLICK, IDC_ITEMPROPERTIES_LISTCTRL, OnRclickItempropertiesListctrl)
    ON_COMMAND(ID_PROPERTYEDITPOPUPMENU_EDITPROPERTYVALUE, OnPropertyeditpopupmenuEditpropertyvalue)
    ON_COMMAND(IDM_VIEW_CAPABILITIES, OnViewCapabilities)
    ON_NOTIFY(NM_RCLICK, IDC_ITEM_TREECTRL, OnRclickItemTreectrl)
    ON_COMMAND(IDM_DELETE_ITEM, OnDeleteItem)
    ON_COMMAND(IDM_ACQUIREIMAGE_COMMONUI, OnAcquireimageCommonui)
    ON_COMMAND(IDM_EDIT_DEBUGOUT, OnEditDebugout)
    ON_UPDATE_COMMAND_UI(IDM_EDIT_DEBUGOUT, OnUpdateEditDebugout)
    ON_WM_SHOWWINDOW()
    ON_COMMAND(IDM_DOCUMENT_ACQUISITION_SETTINGS, OnDocumentAcquisitionSettings)
    ON_UPDATE_COMMAND_UI(IDM_DOCUMENT_ACQUISITION_SETTINGS, OnUpdateDocumentAcquisitionSettings)
    ON_LBN_SELCHANGE(IDC_SUPPORTED_TYMED_AND_FORMAT_LISTBOX, OnSelchangeSupportedTymedAndFormatListbox)
    ON_BN_CLICKED(IDC_THUMBNAIL_PREVIEW, OnThumbnailPreview)
    //}}AFX_MSG_MAP
    // Standard printing commands
    ON_COMMAND(ID_FILE_PRINT, CFormView::OnFilePrint)
    ON_COMMAND(ID_FILE_PRINT_DIRECT, CFormView::OnFilePrint)
    ON_COMMAND(ID_FILE_PRINT_PREVIEW, CFormView::OnFilePrintPreview)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWiatestView construction/destruction

CWiatestView::CWiatestView()
    : CFormView(CWiatestView::IDD)
{
    m_bOutputToDebuggerON = FALSE;
    m_hThumbNailBitmap = NULL;
    m_bHasDocumentFeeder = FALSE;
    //{{AFX_DATA_INIT(CWiatestView)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT
    // TODO: add construction code here

}

CWiatestView::~CWiatestView()
{
}

void CWiatestView::DoDataExchange(CDataExchange* pDX)
{
    CFormView::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CWiatestView)
    DDX_Control(pDX, IDC_SUPPORTED_TYMED_AND_FORMAT_LISTBOX, m_SupportedTymedAndFormatsListBox);
    DDX_Control(pDX, IDC_THUMBNAIL_PREVIEW, m_ThumbnailPreviewWindow);
    DDX_Control(pDX, IDC_ITEMPROPERTIES_LISTCTRL, m_ItemPropertiesListCtrl);
    DDX_Control(pDX, IDC_ITEM_TREECTRL, m_ItemTreeCtrl);
    //}}AFX_DATA_MAP
}

BOOL CWiatestView::PreCreateWindow(CREATESTRUCT& cs)
{
    return CFormView::PreCreateWindow(cs);
}

void CWiatestView::OnInitialUpdate()
{
    CFormView::OnInitialUpdate();
    GetParentFrame()->RecalcLayout();
    ResizeParentToFit(FALSE);

    // get associated document
    CWiatestDoc* pDocument = NULL;
    pDocument = (CWiatestDoc*)m_pDocument;
    if(pDocument){
        // initialize item tree control
        AddWiaItemsToTreeControl(TVI_ROOT, pDocument->m_pIRootItem);
        // initialize property list control
        m_ItemPropertiesListCtrl.SetupColumnHeaders();
        // initialize supported TYMED and formats list box
        AddSupportedTYMEDAndFormatsToListBox(pDocument->m_pIRootItem);
        // initialize device type specifics for UI
        AdjustViewForDeviceType();
        // register for events
        RegisterForEvents();
        // maximize window
        CWnd* Parent = GetParent();
        Parent->ShowWindow(SW_SHOWMAXIMIZED);
    }
}

/////////////////////////////////////////////////////////////////////////////
// CWiatestView printing

BOOL CWiatestView::OnPreparePrinting(CPrintInfo* pInfo)
{
    // default preparation
    return DoPreparePrinting(pInfo);
}

void CWiatestView::OnBeginPrinting(CDC* /*pDC*/, CPrintInfo* /*pInfo*/)
{
    // TODO: add extra initialization before printing
}

void CWiatestView::OnEndPrinting(CDC* /*pDC*/, CPrintInfo* /*pInfo*/)
{
    // TODO: add cleanup after printing
}

void CWiatestView::OnPrint(CDC* pDC, CPrintInfo* /*pInfo*/)
{
    // TODO: add customized printing code here
}

/////////////////////////////////////////////////////////////////////////////
// CWiatestView diagnostics

#ifdef _DEBUG
void CWiatestView::AssertValid() const
{
    CFormView::AssertValid();
}

void CWiatestView::Dump(CDumpContext& dc) const
{
    CFormView::Dump(dc);
}

CWiatestDoc* CWiatestView::GetDocument() // non-debug version is inline
{
    ASSERT(m_pDocument->IsKindOf(RUNTIME_CLASS(CWiatestDoc)));
    return (CWiatestDoc*)m_pDocument;
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CWiatestView message handlers

void CWiatestView::AddWiaItemsToTreeControl(HTREEITEM hParent, IWiaItem *pIWiaItem)
{
    if(hParent == TVI_ROOT){
        // delete any old items in tree
        m_ItemTreeCtrl.DeleteAllItems();
    }

    TV_INSERTSTRUCT tv;
    HRESULT hr = S_OK;
    IEnumWiaItem* pIEnumWiaItem = NULL;
    LONG lItemType              = 0;
    HTREEITEM hNewParent = NULL;
    TCHAR szItemName[MAX_PATH];
    CWiahelper WIA;
    memset(szItemName,0,sizeof(szItemName));

    tv.hParent              = hParent;
    tv.hInsertAfter         = TVI_LAST;
    tv.item.mask            = TVIF_IMAGE | TVIF_SELECTEDIMAGE | TVIF_TEXT | TVIF_PARAM;
    tv.item.hItem           = NULL;
    tv.item.state           = TVIS_EXPANDED;
    tv.item.stateMask       = TVIS_STATEIMAGEMASK;
    tv.item.cchTextMax      = 6;
    tv.item.cChildren       = 0;
    tv.item.lParam          = 0;

    // get item's full name
    WIA.SetIWiaItem(pIWiaItem);
    WIA.ReadPropertyString(WIA_IPA_FULL_ITEM_NAME,szItemName);
    tv.item.pszText = szItemName;

    // insert item into tree
    hNewParent = m_ItemTreeCtrl.InsertItem(&tv);

    // check item type to see if it is a parent
    hr = pIWiaItem->GetItemType(&lItemType);
    if(SUCCEEDED(hr)){
        if(lItemType & (WiaItemTypeFolder | WiaItemTypeHasAttachments)){
            // we have a potential parent
            hr = pIWiaItem->EnumChildItems(&pIEnumWiaItem);
            if(S_OK == hr){
                ULONG ulFetched = 0;
                IWiaItem *pFoundIWiaItem = NULL;
                // we have a parent with children
                hr = pIEnumWiaItem->Next(1,&pFoundIWiaItem,&ulFetched);
                while(S_OK == hr){
                    // add item to tree
                    AddWiaItemsToTreeControl(hNewParent,pFoundIWiaItem);
                    // release enumerated item
                    pFoundIWiaItem->Release();
                    hr = pIEnumWiaItem->Next(1,&pFoundIWiaItem,&ulFetched);
                }
            }
        }
    }
}

void CWiatestView::OnSelchangedItemTreectrl(NMHDR* pNMHDR, LRESULT* pResult)
{
    NM_TREEVIEW* pNMTreeView = (NM_TREEVIEW*)pNMHDR;
    HTREEITEM hTreeItem = NULL;
    hTreeItem = m_ItemTreeCtrl.GetSelectedItem();
    if(hTreeItem){
        CString cszItemName = m_ItemTreeCtrl.GetItemText(hTreeItem);
        if(cszItemName.GetLength() > 0){
            CWiatestDoc* pDocument = NULL;
            pDocument = (CWiatestDoc*)m_pDocument;
            if(pDocument){
                BSTR bstrFullItemName = NULL;
                bstrFullItemName = cszItemName.AllocSysString();
                if(bstrFullItemName){
                    HRESULT hr = S_OK;
                    IWiaItem *pFoundIWiaItem = NULL;
                    hr = pDocument->m_pIRootItem->FindItemByName(0,bstrFullItemName,&pFoundIWiaItem);
                    if(SUCCEEDED(hr)){
                        if(NULL != pFoundIWiaItem){
                            hr = pDocument->SetCurrentIWiaItem(pFoundIWiaItem);
                            if(SUCCEEDED(hr)){
                                // update list control with properties of the selected (found) item
                                AddWiaItemPropertiesToListControl(pDocument->m_pICurrentItem);
                                // update valid TYMED/Formats listbox selections
                                AddSupportedTYMEDAndFormatsToListBox(pDocument->m_pICurrentItem);
                                // disable supported TYMED and format selection if the item selected
                                // is a root item.
                                if(pDocument->m_pICurrentItem == pDocument->m_pIRootItem){
                                    m_SupportedTymedAndFormatsListBox.SetCurSel(-1);
                                    m_SupportedTymedAndFormatsListBox.EnableWindow(FALSE);
                                } else {
                                    m_SupportedTymedAndFormatsListBox.EnableWindow(TRUE);
                                    // set current selection for TYMED and format listbox
                                    SetCurrentSelectionForTYMEDAndFormat();
                                }
                                // display thumbnail if one exists
                                DisplayThumbnail(pDocument->m_pICurrentItem);
                                // release IWiaItem
                                pFoundIWiaItem->Release();
                                pFoundIWiaItem = NULL;
                            }
                        } else {
                            ErrorMessageBox(IDS_WIATESTERROR_ITEMNOTFOUND,hr);
                        }
                    } else {
                        ErrorMessageBox(IDS_WIATESTERROR_ITEMNOTFOUND,hr);
                    }
                    SysFreeString(bstrFullItemName);
                    bstrFullItemName = NULL;
                }
            }
        }
    }
    *pResult = 0;
}

void CWiatestView::AddWiaItemPropertiesToListControl(IWiaItem *pIWiaItem)
{
    // erase any old properties
    m_ItemPropertiesListCtrl.DeleteAllItems();
    // insert new properties
    HRESULT hr = S_OK;
    IWiaPropertyStorage *pIWiaPropStg = NULL;
    INT ItemNumber = 0;

    hr = pIWiaItem->QueryInterface(IID_IWiaPropertyStorage,(void **)&pIWiaPropStg);
    if(hr == S_OK) {
        IEnumSTATPROPSTG  *pIPropEnum = NULL;
        hr = pIWiaPropStg->Enum(&pIPropEnum);
        if(hr == S_OK) {
            STATPROPSTG StatPropStg;
            memset(&StatPropStg,0,sizeof(StatPropStg));
            do {
                hr = pIPropEnum->Next(1,&StatPropStg,NULL);
                if (hr == S_OK) {
                    if (StatPropStg.lpwstrName != NULL) {
                        // read property value
                        PROPSPEC        PropSpec;
                        PROPVARIANT     PropVar;

                        PropSpec.ulKind = PRSPEC_PROPID;
                        PropSpec.propid = StatPropStg.propid;

                        hr = pIWiaPropStg->ReadMultiple(1,&PropSpec,&PropVar);
                        if (hr == S_OK) {

                            TCHAR  szPropName[MAX_PATH];
                            memset(szPropName,0,sizeof(szPropName));
                            TCHAR  szValue[MAX_PATH];
                            memset(szValue,0,sizeof(szValue));
                            TCHAR  szText[MAX_PATH];
                            memset(szText,0,sizeof(szText));

                            LV_ITEM         lvitem;

                            lvitem.mask     = LVIF_TEXT | LVIF_PARAM;
                            lvitem.iItem    = ItemNumber;
                            lvitem.iSubItem = 0;
                            lvitem.pszText  = szText;
                            lvitem.iImage   = NULL;
                            lvitem.lParam   = StatPropStg.propid;

                            // Write property name to list control
                            if (WideCharToMultiByte(CP_ACP, 0,StatPropStg.lpwstrName,-1,
                                                    szPropName, MAX_PATH,NULL,NULL) > 0) {
                                lstrcpy(szText,szPropName);

                                // insert name into list control
                                m_ItemPropertiesListCtrl.InsertItem(&lvitem);

                                // move to next column for setting the value
                                lvitem.mask     = LVIF_TEXT;
                                lvitem.iSubItem = 1;
                            } else {
                                lstrcpy(szPropName,TEXT("<MISSING NAME>"));
                            }

                            // Write property value to list control
                            PROPVAR2TSTR(&PropVar,szText);
                            m_ItemPropertiesListCtrl.SetItem(&lvitem);

                            // display access flags and var type
                            ULONG AccessFlags = 0;
                            ULONG VarType     = 0;
                            PROPVARIANT AttrPropVar; // not used at this time
                            hr = pIWiaPropStg->GetPropertyAttributes(1, &PropSpec,&AccessFlags,&AttrPropVar);
                            if (hr != S_OK) {
                                hr = S_OK; // do this to continue property traversal
                            } else {
                                // display access flags
                                lvitem.mask     = LVIF_TEXT;
                                lvitem.iSubItem = 3;
                                memset(lvitem.pszText,0,sizeof(szText));
                                AccessFlags2TSTR(lvitem.pszText,AccessFlags);
                                m_ItemPropertiesListCtrl.SetItem(&lvitem);
                            }

                            // display var type
                            lvitem.mask     = LVIF_TEXT;
                            lvitem.iSubItem = 2;

                            VT2TSTR(lvitem.pszText,PropVar.vt);
                            m_ItemPropertiesListCtrl.SetItem(&lvitem);

                            // increment Row counter
                            ItemNumber++;
                        }
                    } else {

                    }
                }

                // clean up property name
                CoTaskMemFree(StatPropStg.lpwstrName);
            } while (hr == S_OK);
            pIPropEnum->Release();
        } else {
            ErrorMessageBox(IDS_WIATESTERROR_ENUMERATE_PROPERTIES,hr);
        }
        pIWiaPropStg->Release();
    } else {
        ErrorMessageBox(IDS_WIATESTERROR_WIAPROPERTYSTORAGE,hr);
    }

    // auto resize columns
    for (int Col = 0; Col <4;Col++){
        m_ItemPropertiesListCtrl.SetColumnWidth(Col, LVSCW_AUTOSIZE);
    }
}

void CWiatestView::VT2TSTR(TCHAR *pszText,ULONG VarType)
{
    if (pszText == NULL)
        return;
    switch (VarType) {
    case VT_EMPTY:              // nothing
        lstrcpy(pszText,TEXT("VT_EMPTY"));
        break;
    case VT_NULL:               // SQL style Null
        lstrcpy(pszText,TEXT("VT_NULL"));
        break;
    case VT_I2:                 // 2 byte signed int
        lstrcpy(pszText,TEXT("VT_I2"));
        break;
    case VT_I4:                 // 4 byte signed int
        lstrcpy(pszText,TEXT("VT_I4"));
        break;
    case VT_R4:                 // 4 byte real
        lstrcpy(pszText,TEXT("VT_R4"));
        break;
    case VT_R8:                 // 8 byte real
        lstrcpy(pszText,TEXT("VT_R8"));
        break;
    case VT_CY:                 // currency
        lstrcpy(pszText,TEXT("VT_CY"));
        break;
    case VT_DATE:               // date
        lstrcpy(pszText,TEXT("VT_DATE"));
        break;
    case VT_BSTR:               // OLE Automation string
        lstrcpy(pszText,TEXT("VT_BSTR"));
        break;
    case VT_DISPATCH:           // IDispatch *
        lstrcpy(pszText,TEXT("VT_DISPATCH"));
        break;
    case VT_ERROR:              // SCODE
        lstrcpy(pszText,TEXT("VT_ERROR"));
        break;
    case VT_BOOL:               // True=-1, False=0
        lstrcpy(pszText,TEXT("VT_BOOL"));
        break;
    case VT_VARIANT:            // VARIANT *
        lstrcpy(pszText,TEXT("VT_VARIANT"));
        break;
    case VT_UNKNOWN:            // IUnknown *
        lstrcpy(pszText,TEXT("VT_UNKNOWN"));
        break;
    case VT_DECIMAL:            // 16 byte fixed point
        lstrcpy(pszText,TEXT("VT_DECIMAL"));
        break;
    case VT_RECORD:             // user defined type
        lstrcpy(pszText,TEXT("VT_RECORD"));
        break;
    case VT_I1:                 // signed char
        lstrcpy(pszText,TEXT("VT_I1"));
        break;
    case VT_UI1:                // unsigned char
        lstrcpy(pszText,TEXT("VT_UI1"));
        break;
    case VT_UI2:                // unsigned short
        lstrcpy(pszText,TEXT("VT_UI2"));
        break;
    case VT_UI4:                // unsigned short
        lstrcpy(pszText,TEXT("VT_UI4"));
        break;
    case VT_I8:                 // signed 64-bit int
        lstrcpy(pszText,TEXT("VT_I8"));
        break;
    case VT_UI8:                // unsigned 64-bit int
        lstrcpy(pszText,TEXT("VT_UI8"));
        break;
    case VT_INT:                // signed machine int
        lstrcpy(pszText,TEXT("VT_INT"));
        break;
    case VT_UINT:               // unsigned machine int
        lstrcpy(pszText,TEXT("VT_UINT"));
        break;
    case VT_VOID:               // C style void
        lstrcpy(pszText,TEXT("VT_VOID"));
        break;
    case VT_HRESULT:            // Standard return type
        lstrcpy(pszText,TEXT("VT_HRESULT"));
        break;
    case VT_PTR:                // pointer type
        lstrcpy(pszText,TEXT("VT_PTR"));
        break;
    case VT_SAFEARRAY:          // (use VT_ARRAY in VARIANT)
        lstrcpy(pszText,TEXT("VT_SAFEARRAY"));
        break;
    case VT_CARRAY:             // C style array
        lstrcpy(pszText,TEXT("VT_CARRAY"));
        break;
    case VT_USERDEFINED:        // user defined type
        lstrcpy(pszText,TEXT("VT_USERDEFINED"));
        break;
    case VT_LPSTR:              // null terminated string
        lstrcpy(pszText,TEXT("VT_LPSTR"));
        break;
    case VT_LPWSTR:             // wide null terminated string
        lstrcpy(pszText,TEXT("VT_LPWSTR"));
        break;
    case VT_FILETIME:           // FILETIME
        lstrcpy(pszText,TEXT("VT_FILETIME"));
        break;
    case VT_BLOB:               // Length prefixed bytes
        lstrcpy(pszText,TEXT("VT_BLOB"));
        break;
    case VT_STREAM:             // Name of the stream follows
        lstrcpy(pszText,TEXT("VT_STREAM"));
        break;
    case VT_STORAGE:            // Name of the storage follows
        lstrcpy(pszText,TEXT("VT_STORAGE"));
        break;
    case VT_STREAMED_OBJECT:    // Stream contains an object
        lstrcpy(pszText,TEXT("VT_STREAMED_OBJECT"));
        break;
    case VT_STORED_OBJECT:      // Storage contains an object
        lstrcpy(pszText,TEXT("VT_STORED_OBJECT"));
        break;
    case VT_VERSIONED_STREAM:   // Stream with a GUID version
        lstrcpy(pszText,TEXT("VT_VERSIONED_STREAM"));
        break;
    case VT_BLOB_OBJECT:        // Blob contains an object
        lstrcpy(pszText,TEXT("VT_BLOB_OBJECT"));
        break;
    case VT_CF:                 // Clipboard format
        lstrcpy(pszText,TEXT("VT_CF"));
        break;
    case VT_CLSID:              // A Class ID
        lstrcpy(pszText,TEXT("VT_CLSID"));
        break;
    case VT_VECTOR:             // simple counted array
        lstrcpy(pszText,TEXT("VT_VECTOR"));
        break;
    case VT_ARRAY:              // SAFEARRAY*
        lstrcpy(pszText,TEXT("VT_ARRAY"));
        break;
    case VT_BYREF:              // void* for local use
        lstrcpy(pszText,TEXT("VT_BYREF"));
        break;
    case VT_BSTR_BLOB:          // Reserved for system use
        lstrcpy(pszText,TEXT("VT_BSTR_BLOB"));
        break;
    case VT_VECTOR|VT_I4:
        lstrcpy(pszText,TEXT("VT_VECTOR | VT_I4"));
        break;
    case VT_VECTOR | VT_UI1:
        lstrcpy(pszText,TEXT("VT_VECTOR | VT_UI1"));
        break;
    case VT_VECTOR | VT_UI2:
        lstrcpy(pszText,TEXT("VT_VECTOR | VT_UI2"));
        break;
    case VT_VECTOR | VT_UI4:
        lstrcpy(pszText,TEXT("VT_VECTOR | VT_UI4"));
        break;
    default:                    // unknown type detected!!
        lstrcpy(pszText,TEXT("VT_UNKNOWNTYPE"));
        break;
    }
}

void CWiatestView::AccessFlags2TSTR(TCHAR *pszText,ULONG AccessFlags)
{
    if (pszText == NULL)
        return;

    if ((AccessFlags & WIA_PROP_READ) == WIA_PROP_READ){
        lstrcat(pszText,TEXT("WIA_PROP_READ | "));
    }

    if ((AccessFlags & WIA_PROP_WRITE) == WIA_PROP_WRITE){
        lstrcat(pszText,TEXT("WIA_PROP_WRITE | "));
    }

    if (lstrcmp(pszText,TEXT("WIA_PROP_READ | WIA_PROP_WRITE | ")) == 0){
        lstrcpy(pszText,TEXT("WIA_PROP_RW | "));
    }

    if ((AccessFlags & WIA_PROP_NONE) == WIA_PROP_NONE){
        lstrcat(pszText,TEXT("WIA_PROP_NONE | "));
    }

    if ((AccessFlags & WIA_PROP_RANGE) == WIA_PROP_RANGE){
        lstrcat(pszText,TEXT("WIA_PROP_RANGE | "));
    }

    if ((AccessFlags & WIA_PROP_LIST) == WIA_PROP_LIST){
        lstrcat(pszText,TEXT("WIA_PROP_LIST | "));
    }

    if ((AccessFlags & WIA_PROP_FLAG) == WIA_PROP_FLAG){
        lstrcat(pszText,TEXT("WIA_PROP_FLAG | "));
    }

    LONG lLen = 0;
    lLen = lstrlen(pszText);

    // check for unknown access flags
    if (lLen == 0){
        TSPRINTF(pszText,TEXT("WIA_PROP_UNKNOWN = %d "),AccessFlags);
        return;
    }

    pszText[lLen - (2 * sizeof(TCHAR))] = 0;
}

void CWiatestView::PROPVAR2TSTR(PROPVARIANT *pPropVar,TCHAR *szValue)
{
    SYSTEMTIME *pSystemTime = NULL;

    switch (pPropVar->vt) {
    case VT_I1:
        TSPRINTF(szValue,TEXT("%d"),pPropVar->cVal);
        break;
    case VT_UI1:
        TSPRINTF(szValue,TEXT("%d"),pPropVar->bVal);
        break;
    case VT_I2:
        TSPRINTF(szValue,TEXT("%d"),pPropVar->iVal);
        break;
    case VT_UI2:
        TSPRINTF(szValue,TEXT("%d"),pPropVar->uiVal);
        break;
    case VT_UI4:
        TSPRINTF(szValue,TEXT("%d"),pPropVar->ulVal);
        break;
    case VT_UI8:
        TSPRINTF(szValue,TEXT("%d"),pPropVar->lVal);
        break;
    case VT_INT:
        TSPRINTF(szValue,TEXT("%d"),pPropVar->intVal);
        break;
    case VT_I4:
        TSPRINTF(szValue,TEXT("%d"),pPropVar->lVal);
        break;
    case VT_I8:
        TSPRINTF(szValue,TEXT("%d"),pPropVar->hVal);
        break;
    case VT_R4:
        TSPRINTF(szValue,TEXT("%2.5f"),pPropVar->fltVal);
        break;
    case VT_R8:
        TSPRINTF(szValue,TEXT("%2.5f"),pPropVar->dblVal);
        break;
    case VT_BSTR:
#ifndef UNICODE
        WideCharToMultiByte(CP_ACP, 0,pPropVar->bstrVal, -1, szValue, MAX_PATH,NULL,NULL);
#else
        TSPRINTF(szValue,TEXT("%ws"),pPropVar->bstrVal);
#endif
        break;
    case VT_LPSTR:
        TSPRINTF(szValue,TEXT("%s"),pPropVar->pwszVal);
        break;
    case VT_LPWSTR:
        TSPRINTF(szValue,TEXT("%ws"),pPropVar->pwszVal);
        break;
    case VT_UINT:
        TSPRINTF(szValue,TEXT("%d"),pPropVar->uintVal);
        break;
    case VT_CLSID:
        {
            UCHAR *pwszUUID = NULL;
            UuidToString(pPropVar->puuid,&pwszUUID);
            if(NULL != pwszUUID){
                TSPRINTF(szValue,TEXT("%s"),pwszUUID);
                // free allocated string
                RpcStringFree(&pwszUUID);
            }
        }
        break;
    case VT_VECTOR | VT_UI2:
        pSystemTime = (SYSTEMTIME*)pPropVar->caui.pElems;
        if(NULL != pSystemTime){
        // ( YYYY:MM:W:DD:HH:MM:SS:ms )
        TSPRINTF(szValue,TEXT("%d:%d:%d:%d:%d:%d:%d:%d"),pSystemTime->wYear,
                                                         pSystemTime->wMonth,
                                                         pSystemTime->wDay,
                                                         pSystemTime->wDayOfWeek,
                                                         pSystemTime->wHour,
                                                         pSystemTime->wMinute,
                                                         pSystemTime->wSecond,
                                                         pSystemTime->wMilliseconds);
        }
        break;
    default:
        TSPRINTF(szValue,TEXT("%d"),pPropVar->lVal);
        break;
    }
}

void CWiatestView::TSTR2PROPVAR(TCHAR *szValue, PROPVARIANT *pPropVar)
{
    WCHAR wszbuffer[MAX_PATH];
    CHAR szbuffer[MAX_PATH];
    memset(wszbuffer,0,sizeof(wszbuffer));
    memset(szbuffer,0,sizeof(szbuffer));

    switch (pPropVar->vt) {
    case VT_I1:
        TSSCANF(szValue,TEXT("%li"),&pPropVar->cVal);
        break;
    case VT_I2:
        TSSCANF(szValue,TEXT("%li"),&pPropVar->bVal);
        break;
    case VT_I4:
        TSSCANF(szValue,TEXT("%li"),&pPropVar->lVal);
        break;
    case VT_I8:
        TSSCANF(szValue,TEXT("%li"),&pPropVar->hVal);
        break;
    case VT_UI1:
        TSSCANF(szValue,TEXT("%li"),&pPropVar->bVal);
        break;
    case VT_UI2:
        TSSCANF(szValue,TEXT("%li"),&pPropVar->uiVal);
        break;
    case VT_UI4:
        TSSCANF(szValue,TEXT("%li"),&pPropVar->ulVal);
        break;
    case VT_UI8:
        TSSCANF(szValue,TEXT("%li"),&pPropVar->lVal);
        break;
    case VT_INT:
        TSSCANF(szValue,TEXT("%li"),&pPropVar->intVal);
        break;
    case VT_R4:
        TSSCANF(szValue,TEXT("%f"),&pPropVar->fltVal);
        break;
    case VT_R8:
        TSSCANF(szValue,TEXT("%f"),&pPropVar->fltVal);
        break;
    case VT_BSTR:
#ifndef UNICODE
        MultiByteToWideChar(CP_ACP, 0,szValue,-1,wszbuffer,MAX_PATH);
        pPropVar->bstrVal = SysAllocString(wszbuffer);
#else
        pPropVar->bstrVal = SysAllocString(szValue);
#endif
        break;
    case VT_CLSID:
#ifndef UNICODE
        pPropVar->puuid = (GUID*)CoTaskMemAlloc(sizeof(UUID));
        UuidFromString((UCHAR*)szValue,pPropVar->puuid);
#else
        pPropVar->puuid = CoTaskMemAlloc(sizeof(UUID));
        WideCharToMultiByte(CP_ACP, 0,szValue,-1,szbuffer,MAX_PATH,NULL,NULL);
        UuidFromString((UCHAR*)szbuffer,pPropVar->puuid);
#endif
        break;
    case VT_UINT:
        TSSCANF(szValue,TEXT("%li"),&pPropVar->uintVal);
        break;
    case VT_VECTOR | VT_UI2:
        {
            TCHAR *psz = NULL;
            // is this a SYSTEMTIME formatted string?
            psz = TSTRSTR(szValue,TEXT(":"));
            if(NULL != psz){
                SYSTEMTIME *pSystemTime = NULL;
                pSystemTime = (SYSTEMTIME*)CoTaskMemAlloc(sizeof(SYSTEMTIME));
                if(pSystemTime){
                    memset(pSystemTime,0,sizeof(SYSTEMTIME));
                    // fill out SYSTEMTIME structure
                    TSSCANF(szValue,TEXT("%hd:%hd:%hd:%hd:%hd:%hd:%hd:%hd"),&pSystemTime->wYear,
                                                                            &pSystemTime->wMonth,
                                                                            &pSystemTime->wDay,
                                                                            &pSystemTime->wDayOfWeek,
                                                                            &pSystemTime->wHour,
                                                                            &pSystemTime->wMinute,
                                                                            &pSystemTime->wSecond,
                                                                            &pSystemTime->wMilliseconds);
                    // set count
                    pPropVar->caui.cElems = (sizeof(SYSTEMTIME) / sizeof(WORD));
                    // set pointer (array of WORD values)
                    pPropVar->caui.pElems = (WORD*)pSystemTime;
                }
            }
        }
        break;
    default:
        TSSCANF(szValue,"%li",&pPropVar->lVal);
        break;
    }
}

void CWiatestView::OnSize(UINT nType, int cx, int cy)
{
    CFormView::OnSize(nType, cx, cy);

    CRect ParentWindowRect;
    LONG lOffset = 0;
    // get parent window rect
    GetWindowRect(ParentWindowRect);
    ScreenToClient(ParentWindowRect);

    // resize property list control
    if(NULL != m_ItemPropertiesListCtrl.m_hWnd){
        CRect ListBoxRect;

        // get list control rect
        m_ItemPropertiesListCtrl.GetWindowRect(ListBoxRect);
        ScreenToClient(ListBoxRect);

        // adjust width

        ListBoxRect.right  = ParentWindowRect.right - 10;
        lOffset = ListBoxRect.right;

        // adjust height
        ListBoxRect.bottom = ParentWindowRect.bottom - 10;
        m_ItemPropertiesListCtrl.MoveWindow(ListBoxRect);
    }

    if(GET_STIDEVICE_TYPE(m_lDeviceType) == StiDeviceTypeDigitalCamera){

        // move thumbnail control
        if(NULL != m_ThumbnailPreviewWindow.m_hWnd){
            CRect ThumbnailRect;

            // get thumbnail rect
            m_ThumbnailPreviewWindow.GetWindowRect(ThumbnailRect);
            ScreenToClient(ThumbnailRect);

            // adjust position
            INT iWidth = ThumbnailRect.Width();
            ThumbnailRect.right = lOffset;
            ThumbnailRect.left  = (ThumbnailRect.right - iWidth);

            m_ThumbnailPreviewWindow.MoveWindow(ThumbnailRect);
        }

        // resize supported TYMED and Format listbox
        if(NULL != m_SupportedTymedAndFormatsListBox.m_hWnd){
            CRect ListBoxRect;
            CRect ThumbnailRect;

            // get list box rect
            m_SupportedTymedAndFormatsListBox.GetWindowRect(ListBoxRect);
            ScreenToClient(ListBoxRect);

            // get thumbnail rect
            m_ThumbnailPreviewWindow.GetWindowRect(ThumbnailRect);
            ScreenToClient(ThumbnailRect);

            // adjust width
            ListBoxRect.right  = ThumbnailRect.left - 10;

            m_SupportedTymedAndFormatsListBox.MoveWindow(ListBoxRect);
        }

    } else {
        // resize supported TYMED listbox
        if(NULL != m_SupportedTymedAndFormatsListBox.m_hWnd){
            CRect ListBoxRect;
            CRect ThumbnailRect;

            // get list box rect
            m_SupportedTymedAndFormatsListBox.GetWindowRect(ListBoxRect);
            ScreenToClient(ListBoxRect);

            // adjust width
            ListBoxRect.right  = lOffset;

            m_SupportedTymedAndFormatsListBox.MoveWindow(ListBoxRect);
        }
    }
}

void CWiatestView::OnDblclkItempropertiesListctrl(NMHDR* pNMHDR, LRESULT* pResult)
{
    // find out what property is selected
    HD_NOTIFY*  phdn = (HD_NOTIFY *) pNMHDR;
    TCHAR pszPropertyName[MAX_PATH];
    memset(pszPropertyName,0,sizeof(pszPropertyName));
    TCHAR pszPropertyValue[MAX_PATH];
    memset(pszPropertyValue,0,sizeof(pszPropertyValue));

    LV_ITEM lvitem;
    lvitem.mask     = LVIF_PARAM;
    lvitem.iItem    = phdn->iItem;
    lvitem.iSubItem = ITEMPROPERTYLISTCTRL_COLUMN_PROPERTYNAME;
    lvitem.pszText  = NULL;

    // is an item selected?
    if (phdn->iItem < ITEMPROPERTYLISTCTRL_COLUMN_PROPERTYNAME)
        return;

    m_ItemPropertiesListCtrl.GetItem(&lvitem);
    // get stored property ID
    LONG iProp = 0;
    iProp = (LONG)lvitem.lParam;

    m_ItemPropertiesListCtrl.GetItemText(phdn->iItem,
                                         ITEMPROPERTYLISTCTRL_COLUMN_PROPERTYNAME,
                                         pszPropertyName,
                                         sizeof(pszPropertyName));

    m_ItemPropertiesListCtrl.GetItemText(phdn->iItem,
                                         ITEMPROPERTYLISTCTRL_COLUMN_PROPERTYVALUE,
                                         pszPropertyValue,
                                         sizeof(pszPropertyValue));

    // get document
    CWiatestDoc* pDocument = NULL;
    pDocument = (CWiatestDoc*)m_pDocument;
    if(pDocument){
        IWiaPropertyStorage *pIWiaPropStg = NULL;
        HRESULT hr = S_OK;
        hr = pDocument->m_pICurrentItem->QueryInterface(IID_IWiaPropertyStorage,(void **)&pIWiaPropStg);
        if(SUCCEEDED(hr)) {
            // read property value for type and current value
            PROPVARIANT PropVar[1];
            PROPVARIANT AttrPropVar[1];
            PROPSPEC PropSpec[1];
            PropSpec[0].ulKind = PRSPEC_PROPID;
            PropSpec[0].propid = iProp;

            ULONG ulAttributes = 0;
            CWiaeditpropDlg PropertyEditDlg;
            hr = pIWiaPropStg->ReadMultiple(1,PropSpec,PropVar);
            if (S_OK == hr) {
                PropertyEditDlg.SetVarType(PropVar[0].vt);
                // clear variant
                PropVariantClear(PropVar);
                hr = pIWiaPropStg->GetPropertyAttributes(1, PropSpec,&ulAttributes,AttrPropVar);
                if(S_OK == hr){
                    PropertyEditDlg.SetAttributes(ulAttributes, (PROPVARIANT*)AttrPropVar);
                    BOOL bRefreshCurrentTYMEDAndFormatSelection = FALSE;
                    if((lstrcmpi(pszPropertyName,TEXT("Format")) == 0) || (lstrcmpi(pszPropertyName,TEXT("Media Type")) == 0)){
                        bRefreshCurrentTYMEDAndFormatSelection = TRUE;
                    }
                    if(PropertyEditDlg.DoModal(pszPropertyName,pszPropertyValue) == IDOK){
                        memset(pszPropertyValue,0,sizeof(pszPropertyValue));
                        PropertyEditDlg.GetPropertyValue(pszPropertyValue);
                        PropVar[0].vt = PropertyEditDlg.GetVarType();
                        TSTR2PROPVAR(pszPropertyValue,(PROPVARIANT*)PropVar);
                        hr = pIWiaPropStg->WriteMultiple(1,PropSpec,PropVar,MIN_PROPID);
                        if(S_OK == hr){
                            // get current document, and refresh the property list with the current
                            // selected item
                            CWiatestDoc* pDocument = NULL;
                            pDocument = (CWiatestDoc*)m_pDocument;
                            if(pDocument){
                                // update list control with properties
                                AddWiaItemPropertiesToListControl(pDocument->m_pICurrentItem);
                                if(bRefreshCurrentTYMEDAndFormatSelection){
                                    SetCurrentSelectionForTYMEDAndFormat();
                                }
                            }
                        } else if FAILED(hr){
                            // failure
                            ErrorMessageBox(IDS_WIATESTERROR_WRITING_PROPERTY,hr);
                        } else {
                            // S_FALSE
                            ErrorMessageBox(IDS_WIATESTWARNING_ADDITIONAL_PROPERTY);
                        }
                        // clear variant
                        PropVariantClear(PropVar);
                    } else {
                        // user decided not to write the property
                    }
                }
            }
            // release property storage
            pIWiaPropStg->Release();
            pIWiaPropStg = NULL;
        }
    }
    *pResult = 0;
}

void CWiatestView::AddSupportedTYMEDAndFormatsToListBox(IWiaItem *pIWiaItem)
{
    m_SupportedTymedAndFormatsListBox.ResetContent();
    HRESULT hr = S_OK;
    IWiaDataTransfer *pIWiaDataTransfer = NULL;
    hr = pIWiaItem->QueryInterface(IID_IWiaDataTransfer, (void **)&pIWiaDataTransfer);
    if (S_OK == hr) {
        IEnumWIA_FORMAT_INFO *pIEnumWIA_FORMAT_INFO = NULL;
        WIA_FORMAT_INFO pfe;
        hr = pIWiaDataTransfer->idtEnumWIA_FORMAT_INFO(&pIEnumWIA_FORMAT_INFO);
        if (SUCCEEDED(hr)) {
            do {
                memset(&pfe,0,sizeof(pfe));
                hr = pIEnumWIA_FORMAT_INFO->Next(1, &pfe, NULL);
                if (hr == S_OK) {
                    TCHAR szFormat[MAX_PATH];
                    TCHAR szGuid[MAX_PATH];
                    TCHAR szTYMED[MAX_PATH];
                    memset(szFormat,0,sizeof(szFormat));
                    memset(szGuid,0,sizeof(szGuid));
                    memset(szTYMED,0,sizeof(szTYMED));
                    if(!WIACONSTANT2TSTR(TEXT("Media Type"),(LONG)pfe.lTymed,szTYMED)){
                        lstrcpy(szTYMED,TEXT("TYMED_UNKNOWN"));
                    }
                    FORMAT2TSTR(pfe.guidFormatID,szGuid);
                    TSPRINTF(szFormat,TEXT("%s - %s"),szTYMED,szGuid);
                    m_SupportedTymedAndFormatsListBox.AddString(szFormat);
                } else {
                    if (FAILED(hr)) {
                        ErrorMessageBox(IDS_WIATESTERROR_ENUMFORMATS,hr);
                    }
                }
            } while (hr == S_OK);
            pIEnumWIA_FORMAT_INFO->Release();
            pIEnumWIA_FORMAT_INFO = NULL;
        } else {
            ErrorMessageBox(IDS_WIATESTERROR_ENUMFORMATS,hr);
        }
        pIWiaDataTransfer->Release();
        pIWiaDataTransfer = NULL;
    } else {
        ErrorMessageBox(IDS_WIATESTERROR_IWIADATATRANSFER,hr);
    }
}

void CWiatestView::FORMAT2TSTR(GUID guidFormat, TCHAR *pszFormat)
{
    if(guidFormat == WiaImgFmt_UNDEFINED)
        lstrcpy(pszFormat,TEXT("WiaImgFmt_UNDEFINED:"));
    else if(guidFormat == WiaImgFmt_MEMORYBMP)
        lstrcpy(pszFormat,TEXT("WiaImgFmt_MEMORYBMP:"));
    else if(guidFormat == WiaImgFmt_BMP)
        lstrcpy(pszFormat,TEXT("WiaImgFmt_BMP:"));
    else if(guidFormat == WiaImgFmt_EMF)
        lstrcpy(pszFormat,TEXT("WiaImgFmt_EMF:"));
    else if(guidFormat == WiaImgFmt_WMF)
        lstrcpy(pszFormat,TEXT("WiaImgFmt_WMF:"));
    else if(guidFormat == WiaImgFmt_JPEG)
        lstrcpy(pszFormat,TEXT("WiaImgFmt_JPEG:"));
    else if(guidFormat == WiaImgFmt_PNG)
        lstrcpy(pszFormat,TEXT("WiaImgFmt_PNG:"));
    else if(guidFormat == WiaImgFmt_GIF)
        lstrcpy(pszFormat,TEXT("WiaImgFmt_GIF:"));
    else if(guidFormat == WiaImgFmt_TIFF)
        lstrcpy(pszFormat,TEXT("WiaImgFmt_TIFF:"));
    else if(guidFormat == WiaImgFmt_EXIF)
        lstrcpy(pszFormat,TEXT("WiaImgFmt_EXIF:"));
    else if(guidFormat == WiaImgFmt_PHOTOCD)
        lstrcpy(pszFormat,TEXT("WiaImgFmt_PHOTOCD:"));
    else if(guidFormat == WiaImgFmt_FLASHPIX)
        lstrcpy(pszFormat,TEXT("WiaImgFmt_FLASHPIX:"));
    else {
        lstrcpy(pszFormat,TEXT("Custom Format:"));
    }

    TCHAR szGUID[MAX_PATH];
    memset(szGUID,0,sizeof(szGUID));
    UCHAR *pwszUUID = NULL;
    UuidToString(&guidFormat,&pwszUUID);
    TSPRINTF(szGUID," (%s)",pwszUUID);
    lstrcat(pszFormat,szGUID);
    // free allocated string
    RpcStringFree(&pwszUUID);
}

void CWiatestView::OnAcquireimage()
{
    // delete old temp image files
    DeleteTempDataTransferFiles();

    CWiatestDoc* pDocument = NULL;
    pDocument = (CWiatestDoc*)m_pDocument;
    if(pDocument){
        if(pDocument->m_pICurrentItem == pDocument->m_pIRootItem){
            // use the common UI, because we can not transfer from the root item
            OnAcquireimageCommonui();
            return;
        }
        TCHAR szFileName[MAX_PATH];
        TCHAR szTempFile[MAX_PATH];
        memset(szFileName,0,sizeof(szFileName));
        memset(szTempFile,0,sizeof(szTempFile));
        CWiahelper WIA;
        HRESULT hr = S_OK;
        LONG lTymed = 0;
        hr = WIA.SetIWiaItem(pDocument->m_pICurrentItem);
        if (SUCCEEDED(hr)) {
            hr = WIA.ReadPropertyLong(WIA_IPA_TYMED,&lTymed);
            if (S_OK == hr) {
                switch (lTymed) {
                case TYMED_CALLBACK:
                case TYMED_MULTIPAGE_CALLBACK:
                    GetTempPath(sizeof(szFileName),szFileName);
                    RC2TSTR(IDS_WIATEST_MEMORYTRANSFER_FILENAME,szTempFile,sizeof(szTempFile));
                    lstrcat(szFileName,szTempFile);
                    hr = TransferToMemory(szFileName, pDocument->m_pICurrentItem);
                    break;
                case TYMED_FILE:
                case TYMED_MULTIPAGE_FILE:
                    GetTempPath(sizeof(szFileName),szFileName);
                    RC2TSTR(IDS_WIATEST_FILETRANSFER_FILENAME,szTempFile,sizeof(szTempFile));
                    lstrcat(szFileName,szTempFile);
                    hr = TransferToFile(szFileName,pDocument->m_pICurrentItem);
                    break;
                default:
                    ErrorMessageBox(IDS_WIATESTERROR_UNSUPPORTEDTYMED);
                    break;
                }
            } else if (S_FALSE == hr) {
                ErrorMessageBox(IDS_WIATESTERROR_READINGTYMED_EXIST,hr);
            } else {
                ErrorMessageBox(IDS_WIATESTERROR_READINGTYMED,hr);
            }
        } else {
            ErrorMessageBox(IDS_WIATESTERROR_READINGTYMED,hr);
        }

        if ((hr == S_OK)||(WIA_STATUS_END_OF_MEDIA == hr)) {
            CWiahelper WIA;
            WIA.SetIWiaItem(pDocument->m_pICurrentItem);
            GUID guidFormat;
            memset(&guidFormat,0,sizeof(guidFormat));
            hr = WIA.ReadPropertyGUID(WIA_IPA_FORMAT,&guidFormat);
            if(S_OK == hr){
                RenameTempDataTransferFilesAndLaunchViewer(guidFormat,lTymed);
            }
        }
    }
}

HRESULT CWiatestView::TransferToFile(TCHAR *szFileName, IWiaItem *pIWiaItem)
{
    STGMEDIUM StgMedium;

    HRESULT hr = S_OK;
    // get IWiaDatatransfer interface
    IWiaDataTransfer *pIWiaDataTransfer = NULL;
    hr = pIWiaItem->QueryInterface(IID_IWiaDataTransfer, (void **)&pIWiaDataTransfer);
    if (SUCCEEDED(hr)) {
        WCHAR wszFileName[MAX_PATH];
        memset(wszFileName,0,sizeof(wszFileName));
#ifndef UNICODE
        MultiByteToWideChar(CP_ACP, 0,szFileName,-1,wszFileName,MAX_PATH);
#else
        lstrcpy(wszFileName,szFileName);
#endif
        CWiahelper  WIA;
        LONG lTymed = TYMED_FILE;

        WIA.SetIWiaItem(pIWiaItem);
        hr = WIA.ReadPropertyLong(WIA_IPA_TYMED, &lTymed);
        if (SUCCEEDED(hr)) {

            StgMedium.tymed          = lTymed;
            StgMedium.pUnkForRelease = NULL;
            StgMedium.hGlobal        = NULL;
            StgMedium.lpszFileName   = wszFileName;

            IWiaDataCallback* pIWiaDataCallback = NULL;
            CWiaDataCallback WiaDataCallback;
            hr = WiaDataCallback.QueryInterface(IID_IWiaDataCallback,(void **)&pIWiaDataCallback);
            if (hr == S_OK) {
                hr = pIWiaDataTransfer->idtGetData(&StgMedium,pIWiaDataCallback);
                if ((hr == S_OK)||(WIA_STATUS_END_OF_MEDIA == hr)) {
                    // successful transfer
                } else if (S_FALSE == hr) {
                    ErrorMessageBox(IDS_WIATESTERROR_CANCEL_ACQUISITION);
                } else {
                    ErrorMessageBox(IDS_WIATESTERROR_ACQUISITION,hr);
                }
                pIWiaDataTransfer->Release();
                //WiaDataCallback.Release();
            }
        }
    }
    return hr;
}

HRESULT CWiatestView::TransferToMemory(TCHAR *szFileName, IWiaItem *pIWiaItem)
{
    HRESULT hr = S_OK;
    // get IWiaDatatransfer interface
    IWiaDataTransfer *pIWiaDataTransfer = NULL;
    hr = pIWiaItem->QueryInterface(IID_IWiaDataTransfer, (void **)&pIWiaDataTransfer);
    if (SUCCEEDED(hr)) {
        WIA_DATA_TRANSFER_INFO WiaDataTransferInformation;
        memset(&WiaDataTransferInformation,0,sizeof(WiaDataTransferInformation));
        WiaDataTransferInformation.ulSize       = sizeof(WiaDataTransferInformation);
        WiaDataTransferInformation.ulBufferSize = (ReadMinBufferSizeProperty(pIWiaItem) * MIN_BUFFER_FACTOR);
        IWiaDataCallback* pIWiaDataCallback = NULL;
        CWiaDataCallback WiaDataCallback;
        hr = WiaDataCallback.QueryInterface(IID_IWiaDataCallback,(void **)&pIWiaDataCallback);
        if (hr == S_OK) {
            hr = pIWiaDataTransfer->idtGetBandedData(&WiaDataTransferInformation,pIWiaDataCallback);
            if ((hr == S_OK)||(WIA_STATUS_END_OF_MEDIA == hr)) {
                HANDLE hMemoryDataFile = NULL;
                hMemoryDataFile = CreateFile(szFileName,
                                             GENERIC_WRITE,FILE_SHARE_READ,NULL,
                                             CREATE_ALWAYS,FILE_ATTRIBUTE_NORMAL,NULL);
                if (hMemoryDataFile != INVALID_HANDLE_VALUE && hMemoryDataFile != NULL) {
                    LONG lDataSize = 0;
                    BYTE *pData    = WiaDataCallback.GetCallbackMemoryPtr(&lDataSize);
                    DWORD dwBytesWritten = 0;
                    if (lDataSize > 0) {
                        // handle BITMAP DATA (special case)
                        if (WiaDataCallback.IsBITMAPDATA()) {
                            // we need to adjust any headers, because the height and image size information
                            // could be incorrect. (this will handle infinite page length devices)

                            BITMAPFILEHEADER bmfh;
                            BITMAPINFOHEADER *pbmh = NULL;
                            pbmh = (BITMAPINFOHEADER*)pData;
                            if(pbmh->biHeight < 0){
                                StatusMessageBox(IDS_WIATESTWARNING_NEGATIVE_HEIGHTBITMAP);
                                pbmh->biHeight = abs(pbmh->biHeight);
                            }
                            LONG lPaletteSize = pbmh->biClrUsed * sizeof(RGBQUAD);
                            bmfh.bfType       = BMPFILE_HEADER_MARKER;
                            bmfh.bfOffBits    = sizeof(BITMAPFILEHEADER) + sizeof(BITMAPINFOHEADER) + lPaletteSize;
                            bmfh.bfSize       = sizeof(BITMAPFILEHEADER) + lDataSize;
                            bmfh.bfReserved1  = 0;
                            bmfh.bfReserved2  = 0;

                            // only fix the BITMAPINFOHEADER if height needs to be calculated
                            if (pbmh->biHeight == 0) {
                                StatusMessageBox(IDS_WIATESTWARNING_ZERO_HEIGHTBITMAP);
                                LONG lWidthBytes      = CalculateWidthBytes(pbmh->biWidth,pbmh->biBitCount);
                                pbmh->biSizeImage     = lDataSize - lPaletteSize - sizeof(BITMAPINFOHEADER);
                                pbmh->biHeight        = LONG(pbmh->biSizeImage/lWidthBytes);
                                pbmh->biXPelsPerMeter = 0;  // zero out
                                pbmh->biYPelsPerMeter = 0;  // zero out
                            }

                            WriteFile(hMemoryDataFile,&bmfh,sizeof(bmfh),&dwBytesWritten,NULL);
                        }

                        // write data to disk
                        WriteFile(hMemoryDataFile,pData,lDataSize,&dwBytesWritten,NULL);
                    }
                    // flush and close
                    FlushFileBuffers(hMemoryDataFile);
                    CloseHandle(hMemoryDataFile);
                }
            } else if (S_FALSE == hr) {
                ErrorMessageBox(IDS_WIATESTERROR_CANCEL_ACQUISITION);
            } else {
                ErrorMessageBox(IDS_WIATESTERROR_ACQUISITION,hr);
            }
            pIWiaDataTransfer->Release();
            //WiaDataCallback.Release();
        }
    }
    return hr;
}

void CWiatestView::OnLoadWiapropertystream()
{
    CWiatestDoc* pDocument = NULL;
    pDocument = (CWiatestDoc*)m_pDocument;
    if(pDocument){
        CWiahelper WIA;
        WIA.SetIWiaItem(pDocument->m_pICurrentItem);
        HRESULT hr = S_OK;
        TCHAR szPropertyStreamFile[MAX_PATH];
        memset(szPropertyStreamFile,0,sizeof(szPropertyStreamFile));

        // select saving location

        OPENFILENAME ofn;      // common dialog box structure
        TCHAR szLoadPropStreamTitle[MAX_PATH];
        memset(szLoadPropStreamTitle,0,sizeof(szLoadPropStreamTitle));
        RC2TSTR(IDS_WIATESTLOADPROPSTREAM_DIALOGTITLE,szLoadPropStreamTitle,sizeof(szLoadPropStreamTitle));

        memset(&ofn,0,sizeof(OPENFILENAME));
        ofn.lStructSize     = sizeof(OPENFILENAME);
        ofn.hwndOwner       = m_hWnd;
        ofn.lpstrFile       = szPropertyStreamFile;
        ofn.nMaxFile        = sizeof(szPropertyStreamFile);
        ofn.lpstrFilter     = "*.wia\0*.wia\0";
        ofn.nFilterIndex    = 1;
        ofn.lpstrFileTitle  = NULL;
        ofn.nMaxFileTitle   = 0;
        ofn.lpstrInitialDir = NULL;
        ofn.lpstrTitle      = szLoadPropStreamTitle;
        ofn.Flags           = 0;
        ofn.lpstrDefExt     = "wia";

        if (!GetOpenFileName(&ofn)) {
            return;
        }

        hr = WIA.ReadPropertyStreamFile(szPropertyStreamFile);
        if(FAILED(hr)){
            ErrorMessageBox(IDS_WIATESTERROR_READPROPERTYSTREAMFILE,hr);
        } else {
            // refresh the item tree
            AddWiaItemsToTreeControl(TVI_ROOT,pDocument->m_pIRootItem);
            // refresh the properties
            AddWiaItemPropertiesToListControl(pDocument->m_pIRootItem);
        }
    }
}

void CWiatestView::OnSaveWiapropertystream()
{
    CWiatestDoc* pDocument = NULL;
    pDocument = (CWiatestDoc*)m_pDocument;
    if(pDocument){
        CWiahelper WIA;
        WIA.SetIWiaItem(pDocument->m_pICurrentItem);
        HRESULT hr = S_OK;
        TCHAR szPropertyStreamFile[MAX_PATH];
        memset(szPropertyStreamFile,0,sizeof(szPropertyStreamFile));

        // select saving location

        OPENFILENAME ofn;      // common dialog box structure
        TCHAR szSavePropStreamTitle[MAX_PATH];
        memset(szSavePropStreamTitle,0,sizeof(szSavePropStreamTitle));
        RC2TSTR(IDS_WIATESTSAVEPROPSTREAM_DIALOGTITLE,szSavePropStreamTitle,sizeof(szSavePropStreamTitle));

        memset(&ofn,0,sizeof(OPENFILENAME));
        ofn.lStructSize     = sizeof(OPENFILENAME);
        ofn.hwndOwner       = m_hWnd;
        ofn.lpstrFile       = szPropertyStreamFile;
        ofn.nMaxFile        = sizeof(szPropertyStreamFile);
        ofn.lpstrFilter     = "*.wia\0*.wia\0";
        ofn.nFilterIndex    = 1;
        ofn.lpstrFileTitle  = NULL;
        ofn.nMaxFileTitle   = 0;
        ofn.lpstrInitialDir = NULL;
        ofn.lpstrTitle      = szSavePropStreamTitle;
        ofn.Flags           = 0;
        ofn.lpstrDefExt     = "wia";

        if (!GetSaveFileName(&ofn)) {
            return;
        }

        hr = WIA.WritePropertyStreamFile(szPropertyStreamFile);
        if(FAILED(hr)){
            ErrorMessageBox(IDS_WIATESTERROR_WRITEPROPERTYSTREAMFILE,hr);
        }
    }
}

void CWiatestView::OnRclickItempropertiesListctrl(NMHDR* pNMHDR, LRESULT* pResult)
{
    POINT MousePos;
    CMenu PopupMenu;
    CMenu *pEditMenu = NULL;
    if(PopupMenu.LoadMenu(IDR_PROPERTY_EDIT_POPUPMENU)){
        GetCursorPos(&MousePos);
        pEditMenu = PopupMenu.GetSubMenu(0);
        if(pEditMenu){
            pEditMenu->TrackPopupMenu(TPM_LEFTALIGN|TPM_LEFTBUTTON, MousePos.x, MousePos.y, this);
        }
    }
    *pResult = 0;
}


void CWiatestView::OnPropertyeditpopupmenuEditpropertyvalue()
{
    PROPVARIANT *pPropertyVariants = NULL;
    PROPSPEC *pPropertySpecs = NULL;
    UINT uiNumProperties = m_ItemPropertiesListCtrl.GetSelectedCount();
    if(uiNumProperties <=0){
        return;
    }
    BOOL bWriteProperties = TRUE;
    IWiaPropertyStorage *pIWiaPropStg = NULL;
    HRESULT hr = S_OK;
    UINT iPropertyIndex = 0;
    pPropertyVariants = new PROPVARIANT[uiNumProperties];
    if(pPropertyVariants){
        pPropertySpecs = new PROPSPEC[uiNumProperties];
        if(pPropertySpecs){
            POSITION pos = NULL;
            pos = m_ItemPropertiesListCtrl.GetFirstSelectedItemPosition();
            if (NULL != pos){
                while (pos && bWriteProperties){
                    int iItem = m_ItemPropertiesListCtrl.GetNextSelectedItem(pos);

                    // find out what property is selected
                    TCHAR pszPropertyName[MAX_PATH];
                    memset(pszPropertyName,0,sizeof(pszPropertyName));
                    TCHAR pszPropertyValue[MAX_PATH];
                    memset(pszPropertyValue,0,sizeof(pszPropertyValue));

                    LV_ITEM lvitem;
                    lvitem.mask     = LVIF_PARAM;
                    lvitem.iItem    = iItem;
                    lvitem.iSubItem = ITEMPROPERTYLISTCTRL_COLUMN_PROPERTYNAME;
                    lvitem.pszText  = NULL;

                    // is an item selected?
                    if (iItem < ITEMPROPERTYLISTCTRL_COLUMN_PROPERTYNAME)
                        return;

                    m_ItemPropertiesListCtrl.GetItem(&lvitem);
                    // get stored property ID
                    LONG iProp = 0;
                    iProp = (LONG)lvitem.lParam;

                    m_ItemPropertiesListCtrl.GetItemText(iItem,
                        ITEMPROPERTYLISTCTRL_COLUMN_PROPERTYNAME,
                        pszPropertyName,
                        sizeof(pszPropertyName));

                    m_ItemPropertiesListCtrl.GetItemText(iItem,
                        ITEMPROPERTYLISTCTRL_COLUMN_PROPERTYVALUE,
                        pszPropertyValue,
                        sizeof(pszPropertyValue));

                    // get document
                    CWiatestDoc* pDocument = NULL;
                    pDocument = (CWiatestDoc*)m_pDocument;
                    if(pDocument){
                        hr = pDocument->m_pICurrentItem->QueryInterface(IID_IWiaPropertyStorage,(void **)&pIWiaPropStg);
                        if(SUCCEEDED(hr)) {
                            // read property value for type and current value
                            PROPVARIANT PropVar[1];
                            PROPVARIANT AttrPropVar[1];
                            PROPSPEC PropSpec[1];
                            PropSpec[0].ulKind = PRSPEC_PROPID;
                            PropSpec[0].propid = iProp;

                            // set propspec
                            pPropertySpecs[iPropertyIndex].ulKind = PRSPEC_PROPID;
                            pPropertySpecs[iPropertyIndex].propid = iProp;

                            ULONG ulAttributes = 0;
                            CWiaeditpropDlg PropertyEditDlg;
                            hr = pIWiaPropStg->ReadMultiple(1,PropSpec,PropVar);
                            if (S_OK == hr) {
                                PropertyEditDlg.SetVarType(PropVar[0].vt);
                                // clear variant
                                PropVariantClear(PropVar);
                                hr = pIWiaPropStg->GetPropertyAttributes(1, PropSpec,&ulAttributes,AttrPropVar);
                                if(S_OK == hr){
                                    PropertyEditDlg.SetAttributes(ulAttributes, (PROPVARIANT*)AttrPropVar);
                                    if(PropertyEditDlg.DoModal(pszPropertyName,pszPropertyValue) == IDOK){
                                        memset(pszPropertyValue,0,sizeof(pszPropertyValue));
                                        PropertyEditDlg.GetPropertyValue(pszPropertyValue);
                                        // set variant
                                        pPropertyVariants[iPropertyIndex].vt = PropertyEditDlg.GetVarType();
                                        TSTR2PROPVAR(pszPropertyValue,(PROPVARIANT*)&pPropertyVariants[iPropertyIndex]);
                                        iPropertyIndex++;
                                    } else {
                                        // user decided not to write the property
                                        bWriteProperties = FALSE;
                                    }
                                }
                            }
                            // release property storage
                            pIWiaPropStg->Release();
                            pIWiaPropStg = NULL;
                        }
                    }
                }
            }
        }

        if(bWriteProperties){
            // get current document, and refresh the property list with the current
            // selected item
            CWiatestDoc* pDocument = NULL;
            pDocument = (CWiatestDoc*)m_pDocument;
            if(pDocument){
                hr = pDocument->m_pICurrentItem->QueryInterface(IID_IWiaPropertyStorage,(void **)&pIWiaPropStg);
                if(SUCCEEDED(hr)) {
                    hr = pIWiaPropStg->WriteMultiple(uiNumProperties,pPropertySpecs,pPropertyVariants,MIN_PROPID);
                    if(S_OK == hr){
                        // success
                    } else if FAILED(hr){
                        // failure
                        ErrorMessageBox(IDS_WIATESTERROR_WRITING_PROPERTY,hr);
                    } else {
                        // S_FALSE
                        ErrorMessageBox(IDS_WIATESTWARNING_ADDITIONAL_PROPERTY);
                    }
                    pIWiaPropStg->Release();
                    pIWiaPropStg = NULL;
                }
                // update list control with properties
                AddWiaItemPropertiesToListControl(pDocument->m_pICurrentItem);
                // update TYMED and format selection listbox
                SetCurrentSelectionForTYMEDAndFormat();
            }
        }

        if(pPropertyVariants){
            PropVariantClear(pPropertyVariants);
            delete [] pPropertyVariants;
            pPropertyVariants = NULL;
        }

        if(pPropertySpecs){
            delete [] pPropertySpecs;
            pPropertySpecs = NULL;
        }
    }
}

void CWiatestView::OnViewCapabilities()
{
    CWiacapDlg CapabilitiesDlg;
    CWiatestDoc* pDocument = NULL;
    pDocument = (CWiatestDoc*)m_pDocument;
    if(pDocument){
        CapabilitiesDlg.SetIWiaItem(pDocument->m_pIRootItem);
        CapabilitiesDlg.DoModal();

#ifdef FORCE_UPDATE
        if(CapabilitiesDlg.m_bCommandSent){
            // refresh the item tree
            AddWiaItemsToTreeControl(TVI_ROOT,pDocument->m_pIRootItem);
            // refresh the properties
            AddWiaItemPropertiesToListControl(pDocument->m_pIRootItem);
        }
#endif

    }
}

void CWiatestView::OnRclickItemTreectrl(NMHDR* pNMHDR, LRESULT* pResult)
{
    POINT MousePos;
    CMenu PopupMenu;
    CMenu *pEditMenu = NULL;
    if(PopupMenu.LoadMenu(IDR_ITEMTREE_POPUPMENU)){
        GetCursorPos(&MousePos);
        pEditMenu = PopupMenu.GetSubMenu(0);
        if(pEditMenu){
            CWiatestDoc* pDocument = NULL;
            pDocument = (CWiatestDoc*)m_pDocument;
            if(pDocument){
                if(pDocument->m_pICurrentItem == pDocument->m_pIRootItem){
                    pEditMenu->EnableMenuItem(IDM_DELETE_ITEM,MF_BYCOMMAND|MF_GRAYED);
                    pEditMenu->RemoveMenu(IDM_ACQUIREIMAGE,MF_BYCOMMAND);
                } else {
                    pEditMenu->RemoveMenu(IDM_ACQUIREIMAGE_COMMONUI,MF_BYCOMMAND);
                }
                pEditMenu->TrackPopupMenu(TPM_LEFTALIGN|TPM_LEFTBUTTON, MousePos.x, MousePos.y, this);
            }
        }
    }
    *pResult = 0;
}

ULONG CWiatestView::ReadMinBufferSizeProperty(IWiaItem *pIWiaItem)
{
    LONG lMinBufferSize = 0;
    CWiahelper WIA;
    WIA.SetIWiaItem(pIWiaItem);
    HRESULT hr = S_OK;
    hr = WIA.ReadPropertyLong(WIA_IPA_MIN_BUFFER_SIZE,&lMinBufferSize);
    if(FAILED(hr)){
        ErrorMessageBox(IDS_WIATESTERROR_READINGMINBUFFERSIZE,hr);
    }
    return lMinBufferSize;
}

void CWiatestView::SetCurrentSelectionForTYMEDAndFormat()
{
    TCHAR szTymed[MAX_PATH];
    memset(szTymed,0,sizeof(szTymed));
    TCHAR szFormat[MAX_PATH];
    memset(szFormat,0,sizeof(szFormat));

    INT iItem = 0;
    LVFINDINFO info;
    info.flags = LVFI_PARTIAL|LVFI_STRING;

    // find current TYMED setting
    info.psz = TEXT("Media Type");
    iItem = m_ItemPropertiesListCtrl.FindItem(&info,-1);
    if(iItem != -1){
        // item Found
        // get current value from control
        m_ItemPropertiesListCtrl.GetItemText(iItem,ITEMPROPERTYLISTCTRL_COLUMN_PROPERTYVALUE,
            szTymed, sizeof(szTymed));
        LONG lTymed = 0;
        TSSCANF(szTymed,"%d",&lTymed);
        WIACONSTANT2TSTR(TEXT("Media Type"), lTymed, szTymed);
    }

    // find current Format setting
    info.psz = TEXT("Format");
    iItem = m_ItemPropertiesListCtrl.FindItem(&info,-1);
    if(iItem != -1){
        // item Found
        // get current value from control
        m_ItemPropertiesListCtrl.GetItemText(iItem,ITEMPROPERTYLISTCTRL_COLUMN_PROPERTYVALUE,
            szFormat, sizeof(szFormat));
    }

    // find and select the current TYMED / format pair in the selection control.
    INT iNumListBoxItems = 0;
    iNumListBoxItems = m_SupportedTymedAndFormatsListBox.GetCount();
    if(iNumListBoxItems > 0){
        for(INT i = 0; i < iNumListBoxItems; i++){
            TCHAR szText[MAX_PATH];
            memset(szText,0,sizeof(szText));
            m_SupportedTymedAndFormatsListBox.GetText(i,szText);
            if(TSTRSTR(szText,szTymed) != NULL){
                // found TYMED
                if(TSTRSTR(szText,szFormat) != NULL){
                    // found format
                    m_SupportedTymedAndFormatsListBox.SetCurSel(i);
                    // exit loop
                    i = iNumListBoxItems;
                }
            }
        }
    }
}

void CWiatestView::DeleteTempDataTransferFiles()
{

}

void CWiatestView::RenameTempDataTransferFilesAndLaunchViewer(GUID guidFormat, LONG lTymed)
{
    TCHAR *pszFileExt = NULL;
    TCHAR szOriginalFileName[MAX_PATH];
    TCHAR szFileName[MAX_PATH];
    TCHAR szTempPath[MAX_PATH];
    TCHAR szFullLaunchPath[MAX_PATH];
    TCHAR szOriginalFullLaunchPath[MAX_PATH];
    memset(szFileName,0,sizeof(szFileName));
    memset(szTempPath,0,sizeof(szTempPath));
    memset(szFullLaunchPath,0,sizeof(szFullLaunchPath));
    memset(szOriginalFileName,0,sizeof(szOriginalFileName));
    memset(szOriginalFullLaunchPath,0,sizeof(szOriginalFullLaunchPath));

    GetTempPath(sizeof(szTempPath),szTempPath);
    BOOL bKnownFormat = TRUE;

    switch(lTymed){
    case TYMED_CALLBACK:
    case TYMED_MULTIPAGE_CALLBACK:
        RC2TSTR(IDS_WIATEST_MEMORYTRANSFER_FILENAME,szOriginalFileName,sizeof(szOriginalFileName));
        lstrcpy(szFileName,szOriginalFileName);
        pszFileExt = TSTRSTR(szFileName,TEXT("mem"));
        break;
    case TYMED_FILE:
    case TYMED_MULTIPAGE_FILE:
        RC2TSTR(IDS_WIATEST_FILETRANSFER_FILENAME,szOriginalFileName,sizeof(szOriginalFileName));
        lstrcpy(szFileName,szOriginalFileName);
        pszFileExt = TSTRSTR(szFileName,TEXT("fil"));
        break;
    default:
        break;
    }

    if(lstrlen(szFileName) > 0){
        if(pszFileExt){
            // rename to known image formats
            if(guidFormat == WiaImgFmt_UNDEFINED)
                lstrcpy(pszFileExt,TEXT("bmp"));
            else if(guidFormat == WiaImgFmt_MEMORYBMP)
                lstrcpy(pszFileExt,TEXT("bmp"));
            else if(guidFormat == WiaImgFmt_BMP)
                lstrcpy(pszFileExt,TEXT("bmp"));
            else if(guidFormat == WiaImgFmt_EMF)
                lstrcpy(pszFileExt,TEXT("emf"));
            else if(guidFormat == WiaImgFmt_WMF)
                lstrcpy(pszFileExt,TEXT("wmf"));
            else if(guidFormat == WiaImgFmt_JPEG)
                lstrcpy(pszFileExt,TEXT("jpg"));
            else if(guidFormat == WiaImgFmt_PNG)
                lstrcpy(pszFileExt,TEXT("png"));
            else if(guidFormat == WiaImgFmt_GIF)
                lstrcpy(pszFileExt,TEXT("gif"));
            else if(guidFormat == WiaImgFmt_TIFF)
                lstrcpy(pszFileExt,TEXT("tif"));
            else if(guidFormat == WiaImgFmt_EXIF)
                lstrcpy(pszFileExt,TEXT("jpg"));
            else if(guidFormat == WiaImgFmt_PHOTOCD)
                lstrcpy(pszFileExt,TEXT("pcd"));
            else if(guidFormat == WiaImgFmt_FLASHPIX)
                lstrcpy(pszFileExt,TEXT("fpx"));
            else {
                TCHAR szValue[MAX_PATH];
                memset(szValue,0,sizeof(szValue));
                UCHAR *pwszUUID = NULL;
                UuidToString(&guidFormat,&pwszUUID);
                TSPRINTF(szValue,TEXT("%s"),pwszUUID);
                //  (TEXT("(Unknown Image type) GUID: %s"),pwszUUID);
                // free allocated string
                RpcStringFree(&pwszUUID);
                bKnownFormat = FALSE;
            }
        }
    }

    if(bKnownFormat){
        // launch viewer
        lstrcpy(szFullLaunchPath,szTempPath);
        lstrcat(szFullLaunchPath,szFileName);

        lstrcpy(szOriginalFullLaunchPath,szTempPath);
        lstrcat(szOriginalFullLaunchPath,szOriginalFileName);
        // delete any duplicates
        DeleteFile(szFullLaunchPath);
        // rename file
        MoveFile(szOriginalFullLaunchPath,szFullLaunchPath);
        HINSTANCE hInst = NULL;
        hInst = ShellExecute(m_hWnd,NULL,szFullLaunchPath,NULL,szTempPath,SW_SHOW);
    } else {
        ErrorMessageBox(IDS_WIATESTERROR_UNKNOWN_IMAGEFORMAT);
    }
}

LONG CWiatestView::CalculateWidthBytes(LONG lWidthPixels, LONG lbpp)
{
    LONG lWidthBytes = 0;
    lWidthBytes = (lWidthPixels * lbpp) + 31;
    lWidthBytes = ((lWidthBytes/8) & 0xfffffffc);
    return lWidthBytes;
}

void CWiatestView::OnDeleteItem()
{
    HRESULT hr = S_OK;
    CWiatestDoc* pDocument = NULL;
    pDocument = (CWiatestDoc*)m_pDocument;
    if(pDocument){
        if(pDocument->m_pICurrentItem != pDocument->m_pIRootItem){
            pDocument->m_pICurrentItem->DeleteItem(0);
            pDocument->m_pICurrentItem->Release();
            pDocument->m_pICurrentItem = NULL;
            // refresh the item tree
            AddWiaItemsToTreeControl(TVI_ROOT,pDocument->m_pIRootItem);
            // refresh the properties
            AddWiaItemPropertiesToListControl(pDocument->m_pIRootItem);
        } else {
            ErrorMessageBox(IDS_WIATESTERROR_DELETEROOTITEM);
        }
    }
}

void CWiatestView::OnAcquireimageCommonui()
{
    // delete old temp image files
    DeleteTempDataTransferFiles();

    HRESULT hr = S_OK;
    IWiaItem **pIWiaItemArray = NULL;
    LONG lItemCount = 0;
    CWiatestDoc* pDocument = NULL;
    pDocument = (CWiatestDoc*)m_pDocument;
    if(pDocument){
        hr = pDocument->m_pIRootItem->DeviceDlg(m_hWnd,0,WIA_INTENT_MINIMIZE_SIZE,&lItemCount,&pIWiaItemArray);
        if(S_OK == hr){
            // get temp file name
            TCHAR szTempFile[MAX_PATH];
            memset(szTempFile,0,sizeof(szTempFile));
            RC2TSTR(IDS_WIATEST_FILETRANSFER_FILENAME,szTempFile,sizeof(szTempFile));
            for(LONG lItem = 0; lItem < lItemCount; lItem++){
                // get temp path
                TCHAR szFileName[MAX_PATH];
                memset(szFileName,0,sizeof(szFileName));
                GetTempPath(sizeof(szFileName),szFileName);
                // create new temp file with image index number
                TCHAR szFinalFileName[MAX_PATH];
                memset(szFinalFileName,0,sizeof(szFinalFileName));
                TSPRINTF(szFinalFileName,TEXT("%d%s"),lItem,szTempFile);
                // add new temp file to temp path
                lstrcat(szFileName,szFinalFileName);
                // set TYMED_FILE
                CWiahelper WIA;
                WIA.SetIWiaItem(pIWiaItemArray[lItem]);
                hr = WIA.WritePropertyLong(WIA_IPA_TYMED,TYMED_FILE);
                if (S_OK == hr) {
                    // transfer to this file
                    hr = TransferToFile(szFileName,pIWiaItemArray[lItem]);
                    if ((hr == S_OK)||(WIA_STATUS_END_OF_MEDIA == hr)) {
                        GUID guidFormat;
                        memset(&guidFormat,0,sizeof(guidFormat));
                        hr = WIA.ReadPropertyGUID(WIA_IPA_FORMAT,&guidFormat);
                        if (S_OK == hr) {
                            RenameTempDataTransferFilesAndLaunchViewer(szFileName,guidFormat,TYMED_FILE);
                        } else {
                            ErrorMessageBox(IDS_WIATESTERROR_READINGFORMAT,hr);
                        }
                    } else if (FAILED(hr)) {
                        ErrorMessageBox(IDS_WIATESTERROR_ACQUISITION,hr);
                    }
                } else {
                    ErrorMessageBox(IDS_WIATESTERROR_WRITINGTYMED,hr);
                }
                // release item after acquisition
                pIWiaItemArray[lItem]->Release();
            }
        }
    }
}

void CWiatestView::OnEditDebugout()
{
    if(m_bOutputToDebuggerON){
        m_bOutputToDebuggerON = FALSE;
        DBG_SET_FLAGS(COREDBG_ERRORS);
    } else {
        m_bOutputToDebuggerON = TRUE;
        DBG_SET_FLAGS(COREDBG_ERRORS | COREDBG_WARNINGS | COREDBG_TRACES);
    }
}

void CWiatestView::OnUpdateEditDebugout(CCmdUI* pCmdUI)
{
    pCmdUI->SetCheck(m_bOutputToDebuggerON);
}

void CWiatestView::RenameTempDataTransferFilesAndLaunchViewer(TCHAR *szFileName, GUID guidFormat, LONG lTymed)
{
    TCHAR *pszFileExt = NULL;
    TCHAR szOriginalFileName[MAX_PATH];
    TCHAR szTempPath[MAX_PATH];
    memset(szTempPath,0,sizeof(szTempPath));
    memset(szOriginalFileName,0,sizeof(szOriginalFileName));

    // copy original filename
    lstrcpy(szOriginalFileName,szFileName);

    // get temp launch path
    GetTempPath(sizeof(szTempPath),szTempPath);
    BOOL bKnownFormat = TRUE;

    switch(lTymed){
    case TYMED_CALLBACK:
    case TYMED_MULTIPAGE_CALLBACK:
        pszFileExt = TSTRSTR(szFileName,TEXT("mem"));
        break;
    case TYMED_FILE:
    case TYMED_MULTIPAGE_FILE:
        pszFileExt = TSTRSTR(szFileName,TEXT("fil"));
        break;
    default:
        break;
    }

    if(lstrlen(szFileName) > 0){
        if(pszFileExt){
            // rename to known image formats
            if(guidFormat == WiaImgFmt_UNDEFINED)
                lstrcpy(pszFileExt,TEXT("bmp"));
            else if(guidFormat == WiaImgFmt_MEMORYBMP)
                lstrcpy(pszFileExt,TEXT("bmp"));
            else if(guidFormat == WiaImgFmt_BMP)
                lstrcpy(pszFileExt,TEXT("bmp"));
            else if(guidFormat == WiaImgFmt_EMF)
                lstrcpy(pszFileExt,TEXT("emf"));
            else if(guidFormat == WiaImgFmt_WMF)
                lstrcpy(pszFileExt,TEXT("wmf"));
            else if(guidFormat == WiaImgFmt_JPEG)
                lstrcpy(pszFileExt,TEXT("jpg"));
            else if(guidFormat == WiaImgFmt_PNG)
                lstrcpy(pszFileExt,TEXT("png"));
            else if(guidFormat == WiaImgFmt_GIF)
                lstrcpy(pszFileExt,TEXT("gif"));
            else if(guidFormat == WiaImgFmt_TIFF)
                lstrcpy(pszFileExt,TEXT("tif"));
            else if(guidFormat == WiaImgFmt_EXIF)
                lstrcpy(pszFileExt,TEXT("jpg"));
            else if(guidFormat == WiaImgFmt_PHOTOCD)
                lstrcpy(pszFileExt,TEXT("pcd"));
            else if(guidFormat == WiaImgFmt_FLASHPIX)
                lstrcpy(pszFileExt,TEXT("fpx"));
            else {
                TCHAR szValue[MAX_PATH];
                memset(szValue,0,sizeof(szValue));
                UCHAR *pwszUUID = NULL;
                UuidToString(&guidFormat,&pwszUUID);
                TSPRINTF(szValue,TEXT("%s"),pwszUUID);
                //  (TEXT("(Unknown Image type) GUID: %s"),pwszUUID);
                // free allocated string
                RpcStringFree(&pwszUUID);
                bKnownFormat = FALSE;
            }
        }
    }

    if(bKnownFormat){
        // delete any duplicates
        DeleteFile(szFileName);
        // rename file
        MoveFile(szOriginalFileName,szFileName);
        HINSTANCE hInst = NULL;
        hInst = ShellExecute(m_hWnd,NULL,szFileName,NULL,szTempPath,SW_SHOW);
    } else {
        ErrorMessageBox(IDS_WIATESTERROR_UNKNOWN_IMAGEFORMAT);
    }
}

void CWiatestView::DisplayMissingThumbnail()
{
    //m_hThumbNailBitmap = ::LoadBitmap(AfxGetInstanceHandle(), MAKEINTRESOURCE(IDB_THUMBNAIL_MISSING_BITMAP));
    //if(m_hThumbNailBitmap){
        // display thumbnail(deleting any old one)
        HBITMAP hPreviousBitmap = NULL;
        //hPreviousBitmap = m_ThumbnailPreviewWindow.SetBitmap(m_hThumbNailBitmap);
        hPreviousBitmap = m_ThumbnailPreviewWindow.GetBitmap();
        if(hPreviousBitmap){
            DeleteObject(hPreviousBitmap);
            hPreviousBitmap = NULL;
        }
        m_ThumbnailPreviewWindow.Invalidate();
        Invalidate();
    //}
}

void CWiatestView::DisplayThumbnail(IWiaItem *pIWiaItem)
{

    if(GET_STIDEVICE_TYPE(m_lDeviceType) == StiDeviceTypeDigitalCamera){
        HRESULT hr = S_OK;
        BYTE *pThumbNail = NULL;
        CWiahelper WIA;
        WIA.SetIWiaItem(pIWiaItem);

        long lThumbNailHeight = 0;
        long lThumbNailWidth  = 0;
        long lThumbNailSize   = 0;

        //
        // read thumbnail height
        //

        hr = WIA.ReadPropertyLong(WIA_IPC_THUMB_HEIGHT,&lThumbNailHeight);
        if(hr != S_OK){
            if(FAILED(hr)){
                ErrorMessageBox(IDS_WIATESTERROR_THUMBNAILHEIGHT,hr);
            }
            DisplayMissingThumbnail();
            return;
        }

        //
        // read thumbnail width
        //

        hr = WIA.ReadPropertyLong(WIA_IPC_THUMB_WIDTH,&lThumbNailWidth);
        if(hr != S_OK){
            if(FAILED(hr)){
                ErrorMessageBox(IDS_WIATESTERROR_THUMBNAILWIDTH,hr);
            }
            DisplayMissingThumbnail();
            return;
        }

        //
        // read thumbnail data
        //

        LONG lDataSize = 0;
        BYTE *pData = NULL;
        hr = WIA.ReadPropertyData(WIA_IPC_THUMBNAIL,&pData,&lDataSize);
        if (hr == S_OK) {
            lThumbNailSize = lThumbNailWidth * lThumbNailHeight * 3;
            if (lThumbNailSize != lDataSize) {
                TCHAR szErrorResourceText[MAX_PATH];
                memset(szErrorResourceText,0,sizeof(szErrorResourceText));
                TCHAR szErrorText[MAX_PATH];
                memset(szErrorText,0,sizeof(szErrorText));

                RC2TSTR(IDS_WIATESTERROR_PROCESSING_THUMBNAILDATA,szErrorResourceText,sizeof(szErrorResourceText));
                TSPRINTF(szErrorText,szErrorResourceText,lThumbNailSize,lDataSize);
                ErrorMessageBox(szErrorText);
                // free temp memory
                if(pData){
                    GlobalFree(pData);
                    pData = NULL;
                }
                DisplayMissingThumbnail();
                return;
            }

            BITMAPINFO bmi;
            memset(&bmi,0,sizeof(bmi));
            bmi.bmiHeader.biSize            = sizeof(BITMAPINFOHEADER);
            bmi.bmiHeader.biWidth           = lThumbNailWidth;
            bmi.bmiHeader.biHeight          = lThumbNailHeight;
            bmi.bmiHeader.biPlanes          = 1;
            bmi.bmiHeader.biBitCount        = 24;
            bmi.bmiHeader.biCompression     = BI_RGB;
            bmi.bmiHeader.biSizeImage       = 0;
            bmi.bmiHeader.biXPelsPerMeter   = 0;
            bmi.bmiHeader.biYPelsPerMeter   = 0;
            bmi.bmiHeader.biClrUsed         = 0;
            bmi.bmiHeader.biClrImportant    = 0;

            PBYTE pThumbNailData = NULL;

            HDC hdc  = ::GetDC(NULL);
            if(hdc){
                HDC hdcm = CreateCompatibleDC(hdc);
            }
            m_hThumbNailBitmap = CreateDIBSection(hdc,&bmi,DIB_RGB_COLORS,(void **)&pThumbNailData,NULL,0);
            if(m_hThumbNailBitmap){
                memcpy(pThumbNailData,pData,lDataSize);
            }

            // free temp memory
            if(pData){
                GlobalFree(pData);
                pData = NULL;
            }

            // display thumbnail(deleting any old one)
            HBITMAP hPreviousBitmap = NULL;
            hPreviousBitmap = m_ThumbnailPreviewWindow.SetBitmap(m_hThumbNailBitmap);
            if(hPreviousBitmap){
                DeleteObject(hPreviousBitmap);
                hPreviousBitmap = NULL;
            }
            m_ThumbnailPreviewWindow.Invalidate();

        } else if(hr != S_OK){
            if(FAILED(hr)){
                ErrorMessageBox(IDS_WIATESTERROR_THUMBNAILDATA,hr);
            }
            DisplayMissingThumbnail();
            return;
        }
    }
}

void CWiatestView::AdjustViewForDeviceType()
{
    // get associated document
    CWiatestDoc* pDocument = NULL;
    pDocument = (CWiatestDoc*)m_pDocument;
    if(pDocument){
        m_lDeviceType = 0;
        CWiahelper WIA;
        HRESULT hr = S_OK;
        WIA.SetIWiaItem(pDocument->m_pIRootItem);
        hr = WIA.ReadPropertyLong(WIA_DIP_DEV_TYPE,&m_lDeviceType);
        if(S_OK == hr){
            if(GET_STIDEVICE_TYPE(m_lDeviceType) == StiDeviceTypeScanner){
                // disable thumbnail preview window
                m_ThumbnailPreviewWindow.ShowWindow(SW_HIDE);
                LONG lDocHandlingSelect = 0;
                hr = WIA.ReadPropertyLong(WIA_DPS_DOCUMENT_HANDLING_SELECT,&lDocHandlingSelect);
                if(S_OK == hr){
                    // enable Document Acquisition settings menu option, and toolbar
                    m_bHasDocumentFeeder = TRUE;
                }
            }
        } else {
            // error?
        }
    }
}

void CWiatestView::RegisterForEvents()
{

    HRESULT hr = S_OK;
    IWiaDevMgr *pIWiaDevMgr = NULL;
    hr = CoCreateInstance(CLSID_WiaDevMgr, NULL, CLSCTX_LOCAL_SERVER, IID_IWiaDevMgr,(void**)&pIWiaDevMgr);
    if(FAILED(hr)){
        // creation of device manager failed, so we can not continue
        ErrorMessageBox(IDS_WIATESTERROR_COCREATEWIADEVMGR,hr);
        return;
    }

    CWiatestDoc* pDocument = NULL;
    pDocument = (CWiatestDoc*)m_pDocument;
    if (pDocument) {

        // read device ID
        CWiahelper WIA;
        WIA.SetIWiaItem(pDocument->m_pIRootItem);
        BSTR bstrDeviceID = NULL;
        hr = WIA.ReadPropertyBSTR(WIA_DIP_DEV_ID,&bstrDeviceID);
        if (FAILED(hr)) {
            ErrorMessageBox(IDS_WIATESTERROR_DEVICEID,hr);
            return;
        }

        WIA_DEV_CAP DevCap;
        IEnumWIA_DEV_CAPS* pIEnumWiaDevCaps = NULL;

        // enumerate all device events supported
        hr = pDocument->m_pIRootItem->EnumDeviceCapabilities(WIA_DEVICE_EVENTS,&pIEnumWiaDevCaps);
        if (S_OK == hr) {
            LONG lEventIndex = 0;
            IWiaEventCallback* pIWiaEventCallback = NULL;
            hr = m_WiaEventCallback.QueryInterface(IID_IWiaEventCallback,(void **)&pIWiaEventCallback);
            if (SUCCEEDED(hr)) {
                do {
                    memset(&DevCap,0,sizeof(DevCap));
                    hr = pIEnumWiaDevCaps->Next(1,&DevCap,NULL);
                    if (S_OK == hr) {

                        // DevCap.ulFlags;
                        // DevCap.bstrIcon;
                        // DevCap.bstrCommanline;
                        // DevCap.guid;

                        hr = pIWiaDevMgr->RegisterEventCallbackInterface(0,
                                                                         bstrDeviceID,
                                                                         &DevCap.guid,
                                                                         pIWiaEventCallback,
                                                                         &m_WiaEventCallback.m_pIUnkRelease[lEventIndex]);
                        if (FAILED(hr)) {
                            ErrorMessageBox(IDS_WIATESTERROR_REGISTER_EVENT_CALLBACK,hr);
                        } else {
                            // increment index
                            lEventIndex++;
                        }

                        // free allocated strings
                        if (DevCap.bstrName) {
                            SysFreeString(DevCap.bstrName);
                        }
                        if (DevCap.bstrDescription) {
                            SysFreeString(DevCap.bstrDescription);
                        }
                    }
                }while (hr == S_OK);
            }
            pIEnumWiaDevCaps->Release();
            pIEnumWiaDevCaps = NULL;
        }
    }
    pIWiaDevMgr->Release();
    pIWiaDevMgr = NULL;

    //CWnd* pParent = GetParent();
    m_WiaEventCallback.SetViewWindowHandle(m_hWnd);
}


LRESULT CWiatestView::WindowProc(UINT message, WPARAM wParam, LPARAM lParam)
{
    BOOL bProcessMessage = FALSE;

    // is it one of the user defined messages??

    switch (message) {
    case WM_DEVICE_DISCONNECTED:
    case WM_DEVICE_CONNECTED:
    case WM_ITEM_DELETED:
    case WM_ITEM_CREATED:
    case WM_TREE_UPDATED:
    case WM_STORAGE_CREATED:
    case WM_STORAGE_DELETED:
        bProcessMessage = TRUE;
        break;
    default:
        break;
    }

    // if it is process it...
    if (bProcessMessage) {
        HRESULT hr = S_OK;
        CWnd *pParent = GetParent();
        if (pParent) {
            CWiatestDoc* pDocument = NULL;
            pDocument = (CWiatestDoc*)m_pDocument;
            if (pDocument) {
                switch (message) {
                case WM_DEVICE_DISCONNECTED:
                    return pParent->PostMessage(WM_CLOSE,0,0);
                    break;
                case WM_DEVICE_CONNECTED:
                    break;
                case WM_ITEM_DELETED:
                case WM_ITEM_CREATED:
                case WM_TREE_UPDATED:
                case WM_STORAGE_CREATED:
                case WM_STORAGE_DELETED:
                    // refresh the item tree
                    AddWiaItemsToTreeControl(TVI_ROOT,pDocument->m_pIRootItem);
                    // refresh the properties
                    AddWiaItemPropertiesToListControl(pDocument->m_pIRootItem);
                    break;
                default:
                    break;
                }
            }
        }
    }

    // do default processing
    return CFormView::WindowProc(message, wParam, lParam);
}

void CWiatestView::OnShowWindow(BOOL bShow, UINT nStatus)
{
    CFormView::OnShowWindow(bShow, nStatus);
}

void CWiatestView::OnDocumentAcquisitionSettings()
{
    CWiatestDoc* pDocument = NULL;
    pDocument = (CWiatestDoc*)m_pDocument;
    if (pDocument) {
        CWiaDocAcqSettings DocumentAcquisitionSettingsDlg(IDS_WIATEST_DOCUMENT_SETTINGS_TITLE, pDocument->m_pIRootItem);
        if (DocumentAcquisitionSettingsDlg.DoModal() != IDCANCEL) {
            // refresh the item tree
            AddWiaItemsToTreeControl(TVI_ROOT,pDocument->m_pIRootItem);
            // refresh the properties
            AddWiaItemPropertiesToListControl(pDocument->m_pIRootItem);
        }
    }
}

void CWiatestView::OnUpdateDocumentAcquisitionSettings(CCmdUI* pCmdUI)
{
    pCmdUI->Enable(m_bHasDocumentFeeder);
}

void CWiatestView::OnSelchangeSupportedTymedAndFormatListbox()
{
    CWiatestDoc* pDocument = NULL;
    pDocument = (CWiatestDoc*)m_pDocument;
    if(pDocument){
        TCHAR szTymedAndFormat[MAX_PATH];
        memset(szTymedAndFormat,0,sizeof(szTymedAndFormat));
        INT iCurrentSelection = 0;
        iCurrentSelection = m_SupportedTymedAndFormatsListBox.GetCurSel();
        if(iCurrentSelection != -1){
            m_SupportedTymedAndFormatsListBox.GetText(iCurrentSelection,szTymedAndFormat);

            // find current TYMED selection (located in selected string)
            LONG lTymed = TYMED_CALLBACK;

            if(TSTRSTR(szTymedAndFormat,TEXT("TYMED_CALLBACK")) != NULL){
                lTymed = TYMED_CALLBACK;
            }
            if(TSTRSTR(szTymedAndFormat,TEXT("TYMED_FILE")) != NULL){
                lTymed = TYMED_FILE;
            }
            if(TSTRSTR(szTymedAndFormat,TEXT("TYMED_MULTIPAGE_CALLBACK")) != NULL){
                lTymed = TYMED_MULTIPAGE_CALLBACK;
            }
            if(TSTRSTR(szTymedAndFormat,TEXT("TYMED_MULTIPAGE_FILE")) != NULL){
                lTymed = TYMED_MULTIPAGE_FILE;
            }

            HRESULT hr = S_OK;
            CWiahelper WIA;
            WIA.SetIWiaItem(pDocument->m_pICurrentItem);

            // write TYMED to device

            hr = WIA.WritePropertyLong(WIA_IPA_TYMED,lTymed);
            if (FAILED(hr)){
                ErrorMessageBox(IDS_WIATESTERROR_WRITINGTYMED,hr);
                return;
            }

            // find current format selection
            TCHAR *pszGUID = NULL;
            // trim off trailing ')' on guid string
            LONG lLen = 0;
            lLen = lstrlen(szTymedAndFormat);
            szTymedAndFormat[(lLen * sizeof(TCHAR)) - sizeof(TCHAR)] = 0;
            pszGUID = TSTRSTR(szTymedAndFormat,TEXT("("));
            if(pszGUID){
                pszGUID+=sizeof(TCHAR);
                // we are on the GUID
                GUID guidFormat = GUID_NULL;
                memset(&guidFormat,0,sizeof(guidFormat));
#ifndef UNICODE
                UuidFromString((UCHAR*)pszGUID,&guidFormat);
#else
                WideCharToMultiByte(CP_ACP, 0,pszGUID,-1,szbuffer,MAX_PATH,NULL,NULL);
                UuidFromString((UCHAR*)szbuffer,&guidFormat);
#endif
                if(guidFormat != GUID_NULL){
                    hr = WIA.WritePropertyGUID(WIA_IPA_FORMAT,guidFormat);
                    if(SUCCEEDED(hr)){
                        AddWiaItemPropertiesToListControl(pDocument->m_pICurrentItem);
                    } else {
                        ErrorMessageBox(IDS_WIATESTERROR_WRITINGFORMAT,hr);
                    }
                }
            }

        }
    }
}

void CWiatestView::OnThumbnailPreview()
{

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiatest2\wiatestview.h ===
// wiatestView.h : interface of the CWiatestView class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_WIATESTVIEW_H__B547F708_A160_4238_9D68_CC9C7B8511D4__INCLUDED_)
#define AFX_WIATESTVIEW_H__B547F708_A160_4238_9D68_CC9C7B8511D4__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "wiaitemlistctrl.h"
#include "wiaacquiredlg.h"
#include "wiaeventcallback.h"

#define MIN_BUFFER_FACTOR 4
#define BMPFILE_HEADER_MARKER   ((WORD) ('M' << 8) | 'B')
#define WIDTHBYTES(bits) (((bits) + 31) / 32 * 4)
#define NUMSYSTEMTIME_COLONS 7
#define MIN_CLIENT_WINDOW_WIDTH 580

////////////////////////////////////////////////////////////
// from sti.h
#define GET_STIDEVICE_TYPE(dwDevType)    HIWORD(dwDevType)
#define GET_STIDEVICE_SUBTYPE(dwDevType) LOWORD(dwDevType)

#define StiDeviceTypeDefault        0
#define StiDeviceTypeScanner        1
#define StiDeviceTypeDigitalCamera  2
#define StiDeviceTypeStreamingVideo 3

//
////////////////////////////////////////////////////////////

class CWiatestView : public CFormView
{
protected: // create from serialization only
    CWiatestView();
    DECLARE_DYNCREATE(CWiatestView)

public:
    //{{AFX_DATA(CWiatestView)
	enum { IDD = IDD_WIATEST_FORM };
	CListBox	m_SupportedTymedAndFormatsListBox;    
    CStatic m_ThumbnailPreviewWindow;    
    CWiaitemListCtrl    m_ItemPropertiesListCtrl;
    CTreeCtrl   m_ItemTreeCtrl;
	//}}AFX_DATA

// Attributes
public:
    CWiatestDoc* GetDocument();

// Operations
public:

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CWiatestView)
    public:
    virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    virtual void OnInitialUpdate(); // called first time after construct
    virtual BOOL OnPreparePrinting(CPrintInfo* pInfo);
    virtual void OnBeginPrinting(CDC* pDC, CPrintInfo* pInfo);
    virtual void OnEndPrinting(CDC* pDC, CPrintInfo* pInfo);
    virtual void OnPrint(CDC* pDC, CPrintInfo* pInfo);
    virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);
    //}}AFX_VIRTUAL

// Implementation
public:
    BOOL m_bHasDocumentFeeder;
    LONG m_lDeviceType;
    
    // Event helpers
    void RegisterForEvents();
    CWiaEventCallback m_WiaEventCallback;

    // Thumbnailing helpers
    HBITMAP m_hThumbNailBitmap;    
    void DisplayThumbnail(IWiaItem *pIWiaItem);
    void DisplayMissingThumbnail();

    // User interface
    void AdjustViewForDeviceType();
    void SetCurrentSelectionForTYMEDAndFormat();    
    
    void AddSupportedTYMEDAndFormatsToListBox(IWiaItem *pIWiaItem);    
    void AddWiaItemPropertiesToListControl(IWiaItem *pIWiaItem);
    void AddWiaItemsToTreeControl(HTREEITEM hParent, IWiaItem *pIWiaItem);
    
    // converison helpers
    void FORMAT2TSTR(GUID guidFormat, TCHAR* pszFormat);
    void VT2TSTR(TCHAR *pszText,ULONG VarType);
    void AccessFlags2TSTR(TCHAR *pszText,ULONG AccessFlags);
    void PROPVAR2TSTR(PROPVARIANT *pPropVar,TCHAR *szValue);
    void TSTR2PROPVAR(TCHAR *szValue, PROPVARIANT *pPropVar);

    // data acquisition helpers
    void RenameTempDataTransferFilesAndLaunchViewer(TCHAR *szFileName, GUID guidFormat, LONG lTymed);   
    void RenameTempDataTransferFilesAndLaunchViewer(GUID guidFormat, LONG lTymed);
    void DeleteTempDataTransferFiles(); 
    ULONG ReadMinBufferSizeProperty(IWiaItem *pIWiaItem);
    HRESULT TransferToMemory(TCHAR *szFileName, IWiaItem *pIWiaItem);
    HRESULT TransferToFile(TCHAR *szFileName, IWiaItem *pIWiaItem);
    LONG CalculateWidthBytes(LONG lWidthPixels, LONG lbpp);

    // debugging helpers    
    BOOL m_bOutputToDebuggerON;         
                
    virtual ~CWiatestView();
#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext& dc) const;
#endif

protected:

// Generated message map functions
protected:
    //{{AFX_MSG(CWiatestView)
    afx_msg void OnSelchangedItemTreectrl(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnSize(UINT nType, int cx, int cy);
    afx_msg void OnDblclkItempropertiesListctrl(NMHDR* pNMHDR, LRESULT* pResult);    
    afx_msg void OnAcquireimage();
    afx_msg void OnLoadWiapropertystream();
    afx_msg void OnSaveWiapropertystream();
    afx_msg void OnRclickItempropertiesListctrl(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnPropertyeditpopupmenuEditpropertyvalue();
    afx_msg void OnViewCapabilities();
    afx_msg void OnRclickItemTreectrl(NMHDR* pNMHDR, LRESULT* pResult);    
    afx_msg void OnDeleteItem();
    afx_msg void OnAcquireimageCommonui();
    afx_msg void OnEditDebugout();
    afx_msg void OnUpdateEditDebugout(CCmdUI* pCmdUI);
    afx_msg void OnShowWindow(BOOL bShow, UINT nStatus);
    afx_msg void OnDocumentAcquisitionSettings();
    afx_msg void OnUpdateDocumentAcquisitionSettings(CCmdUI* pCmdUI);
	afx_msg void OnSelchangeSupportedTymedAndFormatListbox();
	afx_msg void OnThumbnailPreview();
	//}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

#ifndef _DEBUG  // debug version in wiatestView.cpp
inline CWiatestDoc* CWiatestView::GetDocument()
   { return (CWiatestDoc*)m_pDocument; }
#endif

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_WIATESTVIEW_H__B547F708_A160_4238_9D68_CC9C7B8511D4__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiavideotest\apputil.cpp ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2000
 *
 *  TITLE:       AppUtil.cpp
 *
 *  VERSION:     1.0
 *
 *  DATE:        2000/11/14
 *
 *  DESCRIPTION: Misc application utilities
 *
 *****************************************************************************/
#include <stdafx.h>

#include "wiavideotest.h"


/****************************Local Function Prototypes********************/


///////////////////////////////
// AppUtil_ConvertToWideString
//
HRESULT AppUtil_ConvertToWideString(const TCHAR   *pszStringToConvert,
                                    WCHAR         *pwszString,
                                    UINT          cchString)
{
    HRESULT hr = S_OK;

    if ((pszStringToConvert == NULL) ||
        (pwszString         == NULL))
    {
        return E_POINTER;
    }

#ifdef UNICODE
    wcsncpy(pwszString, pszStringToConvert, cchString);
#else
        
    MultiByteToWideChar(CP_ACP, 0, pszStringToConvert, -1, 
                        pwszString, cchString);
#endif

    return hr;            
}

///////////////////////////////
// AppUtil_ConvertToTCHAR
//
HRESULT AppUtil_ConvertToTCHAR(const WCHAR   *pwszStringToConvert,
                               TCHAR         *pszString,
                               UINT          cchString)
{
    HRESULT hr = S_OK;

    if ((pwszStringToConvert == NULL) ||
        (pszString          == NULL))
    {
        return E_POINTER;
    }

#ifdef UNICODE
    wcsncpy(pszString, pwszStringToConvert, cchString);
#else
    WideCharToMultiByte(CP_ACP, 0, pwszStringToConvert,
                        -1, pszString, cchString * sizeof(TCHAR), NULL, NULL);
#endif

    return hr;            
}

///////////////////////////////
// AppUtil_MsgBox
//
int AppUtil_MsgBox(UINT     uiCaption,
                   UINT     uiTextResID,
                   UINT     uiStyle,
                   ...)
{
    HRESULT hr                 = S_OK;
    TCHAR   szCaption[255 + 1] = {0};
    TCHAR   szFmt[511 + 1]     = {0};
    TCHAR   szMsg[1023 + 1]    = {0};
    int     iResult            = 0;
    va_list vArgs;

    if (uiCaption != 0)
    {
        iResult = LoadString(APP_GVAR.hInstance, uiCaption, szCaption,
                             sizeof(szCaption) / sizeof(TCHAR));
    }

    if (uiTextResID != 0)
    {
        iResult = LoadString(APP_GVAR.hInstance, uiTextResID, szFmt,
                             sizeof(szFmt) / sizeof(TCHAR));
    }

    va_start(vArgs, uiStyle);
    _vsntprintf(szMsg, sizeof(szMsg) / sizeof(TCHAR), szFmt, vArgs);
    va_end(vArgs);

    return MessageBox(APP_GVAR.hwndMainDlg, szMsg, szCaption, uiStyle); 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiavideotest\imagelst.h ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2000
 *
 *  TITLE:       ImageLst.h
 *
 *  VERSION:     1.0
 *
 *  DATE:        2000/11/14
 *
 *  DESCRIPTION: Handles WIA side of things
 *
 *****************************************************************************/
#ifndef _IMAGELST_H_
#define _IMAGELST_H_

HRESULT ImageLst_PostAddImageRequest(BSTR bstrNewImage);
HRESULT ImageLst_AddImageToList(BSTR bstrNewImage);
HRESULT ImageLst_PopulateWiaItemList(IGlobalInterfaceTable *pGIT,
                                     DWORD                 dwCookie);
HRESULT ImageLst_PopulateDShowItemList(const TCHAR *pszImagesDirectory);
HRESULT ImageLst_Clear();
HRESULT ImageLst_CancelLoadAndWait(DWORD dwTimeout);



#endif // _IMAGELST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiavideotest\sources.inc ===
!include $(PROJECT_ROOT)\wia\wiaenv.inc

TARGETNAME=wiavideotest
TARGETPATH=$(OBJ_DIR)
TARGETTYPE=PROGRAM

UMENTRY=winmain

INCLUDES=$(INCLUDES); \
        $(BASEDIR)\public\sdk\amovie\inc;

SOURCES= \
        ..\wiavideotest.cpp \
        ..\wiaproc.cpp      \
        ..\videoproc.cpp    \
	..\imagelst.cpp     \
        ..\apputil.cpp      \
        ..\wiaevent.cpp     \
        ..\wiavideotest.rc


PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\stdafx.h
PRECOMPILED_PCH=stdafx.pch
PRECOMPILED_OBJ=stdafx.obj

!if ("$(NTDEBUG)" == "") || ("$(NTDEBUG)" == "ntsdnodbg")
LINKLIBS=$(BASEDIR)\public\sdk\lib\*\strmbase.lib
!ELSE
LINKLIBS=$(BASEDIR)\public\sdk\lib\*\strmbasd.lib
!ENDIF

TARGETLIBS= \
        $(TARGETLIBS)                   \
        $(SDK_LIB_PATH)\winmm.lib       \
        $(SDK_LIB_PATH)\userenv.lib     \
        $(SDK_LIB_PATH)\comdlg32.lib    \
        $(SDK_LIB_PATH)\comctl32.lib    \
        $(SDK_LIB_PATH)\wiaguid.lib
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiavideotest\apputil.h ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2000
 *
 *  TITLE:       AppUtil.h
 *
 *  VERSION:     1.0
 *
 *  DATE:        2000/11/14
 *
 *  DESCRIPTION: Misc application utilities
 *
 *****************************************************************************/
#ifndef _APPUTIL_H_
#define _APPUTIL_H_

HRESULT AppUtil_ConvertToWideString(const TCHAR   *pszStringToConvert,
                                    WCHAR         *pwszString,
                                    UINT          cchString);

HRESULT AppUtil_ConvertToTCHAR(const WCHAR   *pwszStringToConvert,
                               TCHAR         *pszString,
                               UINT          cchString);

int AppUtil_MsgBox(UINT     uiCaption,
                   UINT     uiTextResID,
                   UINT     uiStyle,
                   ...);
                           



#endif // _APPUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiavideotest\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	ClientApp.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiavideotest\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by WiaVideoTest.rc
//
#define IDD_MAIN_DLG                    101
#define IDD_STRESSDLG                   102
#define IDD_DIALOG_TAKE_PICTURE_MULTIPLE 103
#define IDC_VIDEO_PREVIEW_WINDOW        1000
#define IDC_LIST_WIA_DEVICES            1001
#define IDC_BUTTON_CREATE_VIDEO_WIA     1002
#define IDC_BUTTON_DESTROY_VIDEO        1003
#define IDC_BUTTON_PLAY                 1004
#define IDC_BUTTON_PAUSE                1005
#define IDC_BUTTON_TAKE_PICTURE         1006
#define IDC_BUTTON_TAKE_PICTURE_DRIVER  1007
#define IDC_BUTTON_SHOW_VIDEO_TOGGLE    1008
#define IDC_BUTTON_RESIZE_TOGGLE        1009
#define IDC_BUTTON_TAKE_PICTURE_STRESS  1011
#define IDC_LIST_NEW_IMAGES             1012
#define IDC_EDIT_IMAGES_DIR             1013
#define IDC_EDIT_CURRENT_STATE          1014
#define IDC_BUTTON_TAKE_PICTURE_MULTIPLE 1015
#define IDC_EDIT_NUM_THREADS            1016
#define IDC_EDIT_NUM_STRESS_THREADS     1016
#define IDC_EDIT_NUM_IMAGES_PER_THREAD  1017
#define IDC_EDIT_NUM_PICTURES_TAKEN     1017
#define IDC_EDIT_NUM_PICTURES_TO_TAKE   1018
#define IDC_EDIT_GRAPH_BUILD_TIME       1018
#define IDC_EDIT_TAKE_PICTURE_FREQUENCY 1019
#define IDC_EDIT_LIST_LOAD_TIME         1019
#define IDC_BUTTON_CREATE_VIDEO_ENUM_POS 1020
#define IDC_BUTTON_CREATE_VIDEO_FRIENDLY_NAME 1021
#define IDC_RADIO_WIA_DEVICE_LIST       1022
#define IDC_RADIO_DSHOW_DEVICE_LIST     1023
#define IDS_ERROR                       2000
#define IDS_FAILED_TO_CREATE_VIDEO      2001
#define IDS_DISCONNECTED                2002
#define IDS_VIDEO_STREAM_SHUTDOWN       2003
#define IDS_NO_VIDEO                    2004
#define IDS_CREATING_VIDEO              2005
#define IDS_VIDEO_CREATED               2006
#define IDS_PLAYING_VIDEO               2007
#define IDS_VIDEO_PAUSED                2008
#define IDS_DESTROYING_VIDEO            2009
#define IDS_STATE_UNKNOWN               2010
#define IDS_VIDEO_STILL_ACTIVE          2011
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        104
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1023
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiavideotest\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_)
#define AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define WIN32_LEAN_AND_MEAN     // Exclude rarely-used stuff from Windows headers

#include <windows.h>
#include <commctrl.h>
#include <stdio.h>
#include <tchar.h>
#include "wia.h"
#include "wiavideo.h"
#include "resource.h"
#include "apputil.h"
#include "WiaProc.h"
#include "ImageLst.h"
#include "VideoProc.h"
#include "wiaevent.h"
#include "vcamprop.h"


// TODO: reference additional headers your program requires here

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiavideotest\imagelst.cpp ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2000
 *
 *  TITLE:       ImageLst.cpp
 *
 *  VERSION:     1.0
 *
 *  DATE:        2000/11/14
 *
 *  DESCRIPTION: Manages Images Item List
 *
 *****************************************************************************/
#include <stdafx.h>
#include <mmsystem.h>
#include "wiavideotest.h"

static struct 
{
    UINT                    uiNumPicturesInList;
    BOOL                    bExitThread;
    HANDLE                  hItemListThread;
} LOCAL_GVAR = 
{
    0,
    FALSE,
    NULL
};

typedef struct tagThreadArgs_t
{
    BOOL bWiaDeviceListMode;

    union
    {
        struct
        {
            DWORD                   dwWiaCookie;
            IGlobalInterfaceTable   *pGIT;
        } WiaItemList;

        struct 
        {
            TCHAR szImagesDirectory[255 + 1];
        } DShowItemList;
    };
} ThreadArgs_t;


/****************************Local Function Prototypes********************/
void IncNumPicsInList();
DWORD WINAPI LoadListWithWiaItems(IGlobalInterfaceTable *pGIT,
                                  DWORD                 dwCookie);

DWORD WINAPI LoadListWithFileItems(const TCHAR *pszImagesDirectory);
DWORD WINAPI ItemListThreadProc(void *pArgs);

///////////////////////////////
// IncNumPicsInList
//
void IncNumPicsInList()
{
    InterlockedIncrement((LONG*) &LOCAL_GVAR.uiNumPicturesInList);

    SetDlgItemInt(APP_GVAR.hwndMainDlg, IDC_EDIT_NUM_PICTURES_TAKEN,
                  LOCAL_GVAR.uiNumPicturesInList, FALSE);

    return;
}

///////////////////////////////
// ImageLst_PostAddImageRequest
//
HRESULT ImageLst_PostAddImageRequest(BSTR bstrNewImage)
{
    HRESULT hr = S_OK;

    if (bstrNewImage == NULL)
    {
        return E_POINTER;
    }

    //
    // This will be freed by the AddImageToList function below.
    //
    BSTR bstrPosted = ::SysAllocString(bstrNewImage);

    PostMessage(APP_GVAR.hwndMainDlg, WM_CUSTOM_ADD_IMAGE, 0,
                (LPARAM)bstrPosted);

    return hr;
}


///////////////////////////////
// ImageLst_AddImageToList
//
HRESULT ImageLst_AddImageToList(BSTR bstrNewImage)
{
    HRESULT hr = S_OK;
    TCHAR   szNewImage[MAX_PATH] = {0};

    if (bstrNewImage == NULL)
    {
        return E_POINTER;
    }

    if (hr == S_OK)
    {
        hr = AppUtil_ConvertToTCHAR((WCHAR*) bstrNewImage, 
                                    szNewImage,
                                    sizeof(szNewImage) / sizeof(TCHAR));
    }
    
    if (hr == S_OK)
    {
        //
        // Insert at the top of the list.
        //
        LRESULT lResult = 0;

        lResult = SendDlgItemMessage(APP_GVAR.hwndMainDlg,
                                          IDC_LIST_NEW_IMAGES,
                                          LB_ADDSTRING,
                                          0,
                                          (LPARAM) szNewImage);

        WPARAM Index = (WPARAM) lResult;
    
        IncNumPicsInList();

        SendDlgItemMessage(APP_GVAR.hwndMainDlg,
                           IDC_LIST_NEW_IMAGES,
                           LB_SETCURSEL,
                           Index,
                           0);
    }

    if (bstrNewImage)
    {
        ::SysFreeString(bstrNewImage);
    }

    return hr;
}

///////////////////////////////
// LoadListWithWiaItems
//

DWORD WINAPI LoadListWithWiaItems(IGlobalInterfaceTable *pGIT,
                                  DWORD                 dwCookie)
{
    HRESULT         hr                     = S_OK;
    IWiaItem        *pSelectedDevice       = NULL;
    IEnumWiaItem    *pIEnumItem            = NULL;

    if ((pGIT == NULL) || (dwCookie == 0))
    {
        return -1;
    }

    hr = pGIT->GetInterfaceFromGlobal(dwCookie,
                                      IID_IWiaItem,
                                      (void**)&pSelectedDevice);

    if (pSelectedDevice == NULL)
    {
        return -1;
    }

    hr = pSelectedDevice->EnumChildItems(&pIEnumItem);

    if (hr == S_OK)
    {
        hr = pIEnumItem->Reset();
    }

    DWORD dwStartTime = 0;
    DWORD dwEndTime   = 0;

    dwStartTime = timeGetTime();

    if (hr == S_OK)
    {
        BOOL bDone = LOCAL_GVAR.bExitThread;

        while (!bDone)
        {
            IWiaItem            *pIWiaItem = NULL;
            IWiaPropertyStorage *pStorage  = NULL;
            TCHAR               szItemName[MAX_PATH] = {0};

            hr = pIEnumItem->Next(1, &pIWiaItem, NULL);

            if (LOCAL_GVAR.bExitThread)
            {
                //
                // Exit the thread
                //
                hr = E_FAIL;
            }

            if (hr == S_OK)
            {
                hr = pIWiaItem->QueryInterface(IID_IWiaPropertyStorage, (void**) &pStorage);
            }

            if (hr == S_OK)
            {
                PROPVARIANT pv;
                PropVariantInit(&pv);

                hr = WiaProc_GetProperty(pStorage, WIA_IPA_FULL_ITEM_NAME, &pv);

                if (pv.vt == VT_BSTR)
                {
                    ImageLst_PostAddImageRequest(pv.bstrVal);
                }

                PropVariantClear(&pv);
            }

            if (pIWiaItem)
            {
                pIWiaItem->Release();
                pIWiaItem = NULL;
            }

            if (pStorage)
            {
                pStorage->Release();
                pStorage = NULL;
            }
            
            if (hr != S_OK)
            {
                bDone = TRUE;
            }
            else if (LOCAL_GVAR.bExitThread)
            {
                bDone = TRUE;
            }
        }
    }

    dwEndTime = timeGetTime();

    SetDlgItemInt(APP_GVAR.hwndMainDlg,
                  IDC_EDIT_LIST_LOAD_TIME,
                  (UINT) abs(dwEndTime - dwStartTime),
                  FALSE);

    if (pIEnumItem)
    {
        pIEnumItem->Release();
        pIEnumItem = NULL;
    }

    return 0;
}

///////////////////////////////
// LoadListWithFileItems
//

DWORD WINAPI LoadListWithFileItems(const TCHAR *pszImagesDirectory)
{
    HRESULT         hr                         = S_OK;
    TCHAR           szSearchPath[MAX_PATH + 1] = {0};
    HANDLE          hFindHandle                = NULL;
    BOOL            bDone                      = FALSE;
    WIN32_FIND_DATA FindData;


    if (pszImagesDirectory == NULL)
    {
        return -1;
    }

    _sntprintf(szSearchPath, sizeof(szSearchPath) / sizeof(TCHAR),
               TEXT("%s\\*.jpg"), pszImagesDirectory);


    hFindHandle = FindFirstFile(szSearchPath, &FindData);

    if (hFindHandle == INVALID_HANDLE_VALUE)
    {
        bDone = TRUE;
    }

    DWORD dwStartTime = 0;
    DWORD dwEndTime   = 0;

    dwStartTime = timeGetTime();

    while ((!bDone) && (!LOCAL_GVAR.bExitThread))
    {
        BOOL  bSuccess     = FALSE;
        BSTR  bstrFileName = NULL;
        TCHAR szFileName[_MAX_FNAME + MAX_PATH + 1] = {0};
        WCHAR wszFileName[_MAX_FNAME + MAX_PATH + 1] = {0};

        _sntprintf(szFileName, sizeof(szFileName) / sizeof(TCHAR),
                   TEXT("%s\\%s"), pszImagesDirectory, FindData.cFileName);

        AppUtil_ConvertToWideString(szFileName,
                                    wszFileName,
                                    sizeof(wszFileName) / sizeof(WCHAR));

        //
        // This is relased by the post processor function
        //
        bstrFileName = ::SysAllocString(wszFileName);

        ImageLst_PostAddImageRequest(bstrFileName);

        bSuccess = FindNextFile(hFindHandle, &FindData);

        if (!bSuccess)
        {
            bDone = TRUE;
        }
    }

    dwEndTime = timeGetTime();

    SetDlgItemInt(APP_GVAR.hwndMainDlg,
                  IDC_EDIT_LIST_LOAD_TIME,
                  (UINT) abs(dwEndTime - dwStartTime),
                  FALSE);

    if (hFindHandle)
    {
        FindClose(hFindHandle);
        hFindHandle = NULL;
    }

    return 0;
}


///////////////////////////////
// ItemListThreadProc
//
DWORD WINAPI ItemListThreadProc(void *pArgs)
{
    HRESULT         hr                     = S_OK;
    ThreadArgs_t    *pThreadArgs           = (ThreadArgs_t*) pArgs;

    if (pThreadArgs == NULL)
    {
        return -1;
    }

    if (pThreadArgs->bWiaDeviceListMode == TRUE)
    {
        LoadListWithWiaItems(pThreadArgs->WiaItemList.pGIT,
                             pThreadArgs->WiaItemList.dwWiaCookie);

        if (pThreadArgs->WiaItemList.pGIT)
        {
            pThreadArgs->WiaItemList.pGIT->Release();
            pThreadArgs->WiaItemList.pGIT = NULL;
        }
    }
    else
    {
        LoadListWithFileItems(pThreadArgs->DShowItemList.szImagesDirectory);
    }

    delete pThreadArgs;
    pThreadArgs = NULL;

    return 0;
}

///////////////////////////////
// ImageLst_PopulateWiaItemList
//
HRESULT ImageLst_PopulateWiaItemList(IGlobalInterfaceTable *pGIT,
                                     DWORD                 dwCookie)
{
    HRESULT         hr         = S_OK;
    DWORD           dwThreadID = 0;
    ThreadArgs_t    *pArgs     = NULL;

    if ((pGIT     == NULL) ||
        (dwCookie == 0))
    {
        return E_POINTER;
    }

    LOCAL_GVAR.uiNumPicturesInList = 0;
    SetDlgItemInt(APP_GVAR.hwndMainDlg, IDC_EDIT_NUM_PICTURES_TAKEN,
                  LOCAL_GVAR.uiNumPicturesInList, FALSE);

    SetDlgItemInt(APP_GVAR.hwndMainDlg,
                  IDC_EDIT_LIST_LOAD_TIME,
                  0,
                  FALSE);

    pArgs = new ThreadArgs_t;

    if (pArgs == NULL)
    {
        return E_OUTOFMEMORY;
    }

    ZeroMemory(pArgs, sizeof(*pArgs));

    pGIT->AddRef();
    pArgs->bWiaDeviceListMode       = TRUE;
    pArgs->WiaItemList.pGIT         = pGIT;
    pArgs->WiaItemList.dwWiaCookie  = dwCookie;

    LOCAL_GVAR.bExitThread = FALSE;
    LOCAL_GVAR.hItemListThread = CreateThread(NULL, 0, ItemListThreadProc,
                                              (void*) pArgs,
                                              0, &dwThreadID);

    return hr;
}

///////////////////////////////
// ImageLst_PopulateDShowItemList
//
HRESULT ImageLst_PopulateDShowItemList(const TCHAR *pszImagesDirectory)
{
    HRESULT         hr         = S_OK;
    DWORD           dwThreadID = 0;
    ThreadArgs_t    *pArgs     = NULL;

    if (pszImagesDirectory == NULL)
    {
        return E_POINTER;
    }

    LOCAL_GVAR.uiNumPicturesInList = 0;
    SetDlgItemInt(APP_GVAR.hwndMainDlg, IDC_EDIT_NUM_PICTURES_TAKEN,
                  LOCAL_GVAR.uiNumPicturesInList, FALSE);

    SetDlgItemInt(APP_GVAR.hwndMainDlg,
                  IDC_EDIT_LIST_LOAD_TIME,
                  0,
                  FALSE);

    pArgs = new ThreadArgs_t;

    if (pArgs == NULL)
    {
        return E_OUTOFMEMORY;
    }

    ZeroMemory(pArgs, sizeof(*pArgs));

    pArgs->bWiaDeviceListMode       = FALSE;
    _tcsncpy(pArgs->DShowItemList.szImagesDirectory,
             pszImagesDirectory,
             sizeof(pArgs->DShowItemList.szImagesDirectory) / sizeof(TCHAR));

    LOCAL_GVAR.bExitThread = FALSE;
    LOCAL_GVAR.hItemListThread = CreateThread(NULL, 0, ItemListThreadProc,
                                              (void*) pArgs,
                                              0, &dwThreadID);

    return hr;
}


///////////////////////////////
// ImageLst_Clear
//
HRESULT ImageLst_Clear()
{
    HRESULT hr = S_OK;

    //
    // Clear the New Image List
    //
    SendDlgItemMessage(APP_GVAR.hwndMainDlg,
                       IDC_LIST_NEW_IMAGES,
                       LB_RESETCONTENT,
                       0,
                       0);

    LOCAL_GVAR.uiNumPicturesInList = 0;
    SetDlgItemInt(APP_GVAR.hwndMainDlg, IDC_EDIT_NUM_PICTURES_TAKEN,
                  LOCAL_GVAR.uiNumPicturesInList, FALSE);

    return hr;
}

///////////////////////////////
// ImageLst_CancelLoadAndWait
//
HRESULT ImageLst_CancelLoadAndWait(DWORD dwTimeout)
{
    HRESULT hr = S_OK;

    if (LOCAL_GVAR.hItemListThread)
    {
        LOCAL_GVAR.bExitThread = TRUE;
        WaitForSingleObject(LOCAL_GVAR.hItemListThread, dwTimeout);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiavideotest\wiaevent.cpp ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2000
 *
 *  TITLE:       WiaEvent.cpp
 *
 *  VERSION:     1.0
 *
 *  DATE:        2000/11/14
 *
 *  DESCRIPTION: Implements callback for receiving WIA events.
 *
 *****************************************************************************/
#include <stdafx.h>

#include "wiavideotest.h"

///////////////////////////////
// Constructor
//
CWiaEvent::CWiaEvent(void) :
    m_cRef(0)
{
}

///////////////////////////////
// Destructor
//
CWiaEvent::~CWiaEvent(void)
{
}

///////////////////////////////
// QueryInterface
//
STDMETHODIMP CWiaEvent::QueryInterface(REFIID riid, 
                                       LPVOID *ppvObject )
{
    if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObject = static_cast<IWiaEventCallback*>(this);
    }
    else if (IsEqualIID(riid, IID_IWiaEventCallback))
    {
        *ppvObject = static_cast<IWiaEventCallback*>(this);
    }
    else
    {
        *ppvObject = NULL;
        return E_NOINTERFACE;
    }
    reinterpret_cast<IUnknown*>(*ppvObject)->AddRef();

    return S_OK;
}


///////////////////////////////
// AddRef
//
STDMETHODIMP_(ULONG) CWiaEvent::AddRef(void)
{
    return InterlockedIncrement(&m_cRef);
}

///////////////////////////////
// Release
//
STDMETHODIMP_(ULONG) CWiaEvent::Release(void)
{
    LONG nRefCount = InterlockedDecrement(&m_cRef);

    if (!nRefCount)
    {
        delete this;
    }

    return nRefCount;
}

///////////////////////////////
// ImageEventCallback
//
STDMETHODIMP CWiaEvent::ImageEventCallback(const GUID   *pEventGUID, 
                                           BSTR         bstrEventDescription, 
                                           BSTR         bstrDeviceID, 
                                           BSTR         bstrDeviceDescription, 
                                           DWORD        dwDeviceType, 
                                           BSTR         bstrFullItemName, 
                                           ULONG        *pulEventType, 
                                           ULONG        ulReserved)
{
    HRESULT hr = S_OK;

    if (pEventGUID == NULL)
    {
        return E_POINTER;
    }

    if (IsEqualIID(*pEventGUID, WIA_EVENT_ITEM_CREATED))
    {
        hr = ImageLst_PostAddImageRequest(bstrFullItemName);
    }
    else if (IsEqualIID(*pEventGUID, WIA_EVENT_ITEM_DELETED))
    {
        // do nothing for now.
    }
    else if (IsEqualIID(*pEventGUID, WIA_EVENT_DEVICE_CONNECTED))
    {
        WiaProc_PopulateDeviceList();
    }
    else if (IsEqualIID(*pEventGUID, WIA_EVENT_DEVICE_DISCONNECTED))
    {
        //
        // Simulate a push of the DestroyVideo Button.
        //
        VideoProc_ProcessMsg(IDC_BUTTON_DESTROY_VIDEO);

        AppUtil_MsgBox(IDS_DISCONNECTED, IDS_VIDEO_STREAM_SHUTDOWN,
                       MB_OK | MB_ICONINFORMATION);

        WiaProc_PopulateDeviceList();
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiavideotest\wiaevent.h ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2000
 *
 *  TITLE:       WiaEvent.h
 *
 *  VERSION:     1.0
 *
 *  DATE:        2000/11/14
 *
 *  DESCRIPTION: Implements callback for receiving WIA events.
 *
 *****************************************************************************/
#ifndef _WIAEVENT_H_
#define _WIAEVENT_H_

class CWiaEvent : public IWiaEventCallback
{
public:
    CWiaEvent();
    ~CWiaEvent();

    // IUnknown
    STDMETHODIMP QueryInterface( REFIID riid, LPVOID *ppvObject );
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //IWiaEventCallback
    STDMETHODIMP ImageEventCallback(const GUID  *pEventGUID, 
                                    BSTR        bstrEventDescription, 
                                    BSTR        bstrDeviceID, 
                                    BSTR        bstrDeviceDescription, 
                                    DWORD       dwDeviceType, 
                                    BSTR        bstrFullItemName, 
                                    ULONG       *pulEventType, 
                                    ULONG       ulReserved);

    static HRESULT RegisterForWiaEvent(LPCWSTR pwszDeviceId, 
                                       const GUID &guidEvent, 
                                       IUnknown **ppUnknown);

private:
    LONG m_cRef;

};

#endif //_WIAEVENT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiavideotest\videoproc.h ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2000
 *
 *  TITLE:       VideoProc.h
 *
 *  VERSION:     1.0
 *
 *  DATE:        2000/11/14
 *
 *  DESCRIPTION: Maintains the WiaVideo object
 *
 *****************************************************************************/
#ifndef _VIDEOPROC_H_
#define _VIDEOPROC_H_

HRESULT     VideoProc_Init();
HRESULT     VideoProc_Term();
HRESULT VideoProc_DShowListInit();
HRESULT VideoProc_DShowListTerm();
UINT_PTR    VideoProc_ProcessMsg(UINT   uiControlID);
HRESULT     VideoProc_TakePicture();
void        VideoProc_IncNumPicsTaken();



#endif // _VIDEOPROC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiavideotest\wiaproc.h ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2000
 *
 *  TITLE:       WiaProc.h
 *
 *  VERSION:     1.0
 *
 *  DATE:        2000/11/14
 *
 *  DESCRIPTION: Handles WIA side of things
 *
 *****************************************************************************/
#ifndef _WIAPROC_H_
#define _WIAPROC_H_

#define WM_CUSTOM_ADD_IMAGE     WM_USER + 101

HRESULT WiaProc_Init();
HRESULT WiaProc_Term();

HRESULT WiaProc_CreateSelectedDevice(TCHAR  *pszDeviceID,
                                     UINT   cchDeviceID);

HRESULT WiaProc_PopulateDeviceList();
HRESULT WiaProc_PopulateItemList();

HRESULT WiaProc_DestroySelectedDevice();

HRESULT WiaProc_GetImageDirectory(TCHAR *pszImageDirectory,
                                  UINT  cchImageDirectory);

HRESULT WiaProc_DeviceTakePicture();

HRESULT WiaProc_SetLastSavedImage(BSTR bstrLastSavedImage);

HRESULT WiaProc_GetProperty(IWiaPropertyStorage *pPropStorage, 
                            PROPID              nPropID,
                            PROPVARIANT         *pPropVar);



#endif // _WIAPROC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiavideotest\videoproc.cpp ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2000
 *
 *  TITLE:       VideoProc.cpp
 *
 *  VERSION:     1.0
 *
 *  DATE:        2000/11/14
 *
 *  DESCRIPTION: Manages WiaVideo object.
 *
 *****************************************************************************/
#include <stdafx.h>
#include <mmsystem.h>
#include <streams.h>
#include <mmreg.h>
#include "wiavideotest.h"

///////////////////////////////
// LOCAL_GVAR
//
static struct
{
    IWiaVideo           *pWiaVideo;
    BOOL                bPreviewVisible;
    INT                 iNumThreads;
    UINT                uiNumImagesPerThread;
    UINT                uiTakePictureInterval;
    BOOL                bExitThreads;
    BOOL                bVideoStretched;
} LOCAL_GVAR = 
{
    NULL,
    TRUE,
    0,
    0,
    0,
    FALSE,
    FALSE
};

///////////////////////////////
// ThreadArgs_t
//
typedef struct ThreadArgs_t
{
    UINT uiNumPicturesToTake;
    UINT uiThreadSleepTime;     // if 0, calc'd as a random number.
} ThreadArgs_t;


/****************************Local Function Prototypes********************/
HRESULT CreateWiaVideoObject();
HRESULT CreateVideoEnumPos();
HRESULT CreateVideoFriendlyName();
HRESULT CreateVideoWia();
HRESULT DestroyVideo();
HRESULT Play();
HRESULT Pause();
HRESULT TakePicture(BOOL bTakePictureThroughDriver);
HRESULT ShowVideo();
HRESULT ResizeVideo(BOOL bStretchToFitWindow);
HRESULT ShowCurrentState();
HRESULT TakePictureMultiple();
HRESULT TakePictureStress();
DWORD WINAPI TakePictureThreadProc(void *pArgs);
LRESULT CALLBACK MultipleDlgProc(HWND     hDlg,
                                 UINT     message,
                                 WPARAM   wParam,
                                 LPARAM   lParam);
LRESULT CALLBACK StressDlgProc(HWND     hDlg,
                               UINT     message,
                               WPARAM   wParam,
                               LPARAM   lParam);

BOOL GetDeviceProperty(IPropertyBag         *pPropertyBag,
                       LPCWSTR              pwszProperty,
                       TCHAR                *pszProperty,
                       DWORD                cchProperty);


///////////////////////////////
// VideoProc_Init
//
HRESULT VideoProc_Init()
{
    HRESULT hr = S_OK;

    hr = CreateWiaVideoObject();

    return hr;
}

///////////////////////////////
// VideoProc_Term
//
HRESULT VideoProc_Term()
{
    HRESULT hr = S_OK;

    LOCAL_GVAR.bExitThreads = TRUE;

    //
    // Crude, but for a test app, it is easier than creating an
    // array of thread handles and waiting for each one to finish.
    //
    INT iLoops = 0;
    while ((LOCAL_GVAR.iNumThreads > 0) && (iLoops < 50))
    {
        ++iLoops;
        Sleep(100);
    }

    DestroyVideo();

    if (LOCAL_GVAR.pWiaVideo)
    {
        LOCAL_GVAR.pWiaVideo->Release();
        LOCAL_GVAR.pWiaVideo = NULL;
    }

    return hr;
}

///////////////////////////////
// VideoProc_DShowListInit
//
HRESULT VideoProc_DShowListInit()
{
    HRESULT                 hr = S_OK;
    LONG                    lPosNum = 0;
    ICreateDevEnum          *pCreateDevEnum = NULL;
    IEnumMoniker            *pEnumMoniker   = NULL;

    //
    // Empty the list
    //
    SendDlgItemMessage(APP_GVAR.hwndMainDlg, 
                       IDC_LIST_WIA_DEVICES,
                       LB_RESETCONTENT,
                       0,
                       0);

    if (hr == S_OK)
    {
    
        // 
        // Create the device enumerator
        //
        hr = CoCreateInstance(CLSID_SystemDeviceEnum,
                              NULL,
                              CLSCTX_INPROC_SERVER,
                              IID_ICreateDevEnum,
                              (void**)&pCreateDevEnum);
    }

    if (hr == S_OK)
    {
        hr = pCreateDevEnum->CreateClassEnumerator(
                                            CLSID_VideoInputDeviceCategory,
                                            &pEnumMoniker,
                                            0);
    }

    //
    // Loop through all the devices
    //

    while (hr == S_OK)
    {
        TCHAR                   szFriendlyName[255 + 1] = {0};
        IMoniker                *pMoniker       = NULL;
        IPropertyBag            *pPropertyBag   = NULL;

        hr = pEnumMoniker->Next(1, &pMoniker, NULL);

        if (hr == S_OK)
        {
            //
            // Get property storage for this DS device so we can get it's
            // device id...
            //
    
            hr = pMoniker->BindToStorage(0, 
                                         0,
                                         IID_IPropertyBag,
                                         (void **)&pPropertyBag);
        }

        if (hr == S_OK)
        {
            hr = GetDeviceProperty(pPropertyBag, 
                                   L"FriendlyName",
                                   szFriendlyName,
                                   sizeof(szFriendlyName) / sizeof(TCHAR));
        }

        if (hr == S_OK)
        {
            SendDlgItemMessage(APP_GVAR.hwndMainDlg, 
                               IDC_LIST_WIA_DEVICES,
                               LB_ADDSTRING,
                               0, 
                               (LPARAM) szFriendlyName);
        }

        if (pMoniker)
        {
            pMoniker->Release();
            pMoniker = NULL;
        }

        if (pPropertyBag)
        {
            pPropertyBag->Release();
            pPropertyBag = NULL;
        }
    }

    SendDlgItemMessage(APP_GVAR.hwndMainDlg,
                       IDC_LIST_WIA_DEVICES,
                       LB_SETCURSEL,
                       0,
                       0);

    if (pEnumMoniker)
    {
        pEnumMoniker->Release();
        pEnumMoniker = NULL;
    }

    if (pCreateDevEnum)
    {
        pCreateDevEnum->Release();
        pCreateDevEnum = NULL;
    }

    return hr;
}

///////////////////////////////
// VideoProc_DShowListTerm
//
HRESULT VideoProc_DShowListTerm()
{
    HRESULT hr = S_OK;

    //
    // Empty the list
    //
    SendDlgItemMessage(APP_GVAR.hwndMainDlg, 
                       IDC_LIST_WIA_DEVICES,
                       LB_RESETCONTENT,
                       0,
                       0);

    return hr;
}



///////////////////////////////
// VideoProc_TakePicture
//
HRESULT VideoProc_TakePicture()
{
    HRESULT hr = S_OK;

    hr = TakePicture(FALSE);

    return hr;
}


///////////////////////////////
// VideoProc_ProcessMsg
//
UINT_PTR VideoProc_ProcessMsg(UINT   uiControlID)
{
    HRESULT     hr = S_OK;
    UINT_PTR    uiReturn = 0;

    switch (uiControlID)
    {
        case IDC_BUTTON_CREATE_VIDEO_WIA:
            hr = CreateVideoWia();

            EnableWindow(GetDlgItem(APP_GVAR.hwndMainDlg, IDC_RADIO_WIA_DEVICE_LIST), FALSE);
            EnableWindow(GetDlgItem(APP_GVAR.hwndMainDlg, IDC_RADIO_DSHOW_DEVICE_LIST), FALSE);

        break;

        case IDC_BUTTON_CREATE_VIDEO_ENUM_POS:
            hr = CreateVideoEnumPos();

            EnableWindow(GetDlgItem(APP_GVAR.hwndMainDlg, IDC_RADIO_WIA_DEVICE_LIST), FALSE);
            EnableWindow(GetDlgItem(APP_GVAR.hwndMainDlg, IDC_RADIO_DSHOW_DEVICE_LIST), FALSE);

        break;

        case IDC_BUTTON_CREATE_VIDEO_FRIENDLY_NAME:
            hr = CreateVideoFriendlyName();

            EnableWindow(GetDlgItem(APP_GVAR.hwndMainDlg, IDC_RADIO_WIA_DEVICE_LIST), FALSE);
            EnableWindow(GetDlgItem(APP_GVAR.hwndMainDlg, IDC_RADIO_DSHOW_DEVICE_LIST), FALSE);

        break;

        case IDC_BUTTON_TAKE_PICTURE_STRESS:
            TakePictureStress();
        break;

        case IDC_BUTTON_TAKE_PICTURE_MULTIPLE:
            TakePictureMultiple();
        break;

        case IDC_BUTTON_DESTROY_VIDEO:
            SetCursor( LoadCursor(NULL, IDC_WAIT));

            DestroyVideo();

            EnableWindow(GetDlgItem(APP_GVAR.hwndMainDlg, IDC_RADIO_WIA_DEVICE_LIST), TRUE);
            EnableWindow(GetDlgItem(APP_GVAR.hwndMainDlg, IDC_RADIO_DSHOW_DEVICE_LIST), TRUE);

            SetCursor( LoadCursor(NULL, IDC_ARROW));
        break;

        case IDC_BUTTON_PLAY:
            Play();
        break;

        case IDC_BUTTON_PAUSE:
            Pause();
        break;

        case IDC_BUTTON_TAKE_PICTURE:
            TakePicture(FALSE);
        break;

        case IDC_BUTTON_TAKE_PICTURE_DRIVER:
            TakePicture(TRUE);
        break;

        case IDC_BUTTON_SHOW_VIDEO_TOGGLE:
            ShowVideo();
        break;

        case IDC_BUTTON_RESIZE_TOGGLE:
            LOCAL_GVAR.bVideoStretched = (LOCAL_GVAR.bVideoStretched ? FALSE : TRUE);
            ResizeVideo(LOCAL_GVAR.bVideoStretched);
        break;

        default:
        break;

    }

    ShowCurrentState();

    return uiReturn;
}

///////////////////////////////
// CreateVideoWia
//
HRESULT CreateVideoWia()
{
    HRESULT         hr                          = S_OK;
    TCHAR           szDeviceID[MAX_PATH]        = {0};
    TCHAR           szImagesDirectory[MAX_PATH] = {0};
    BSTR            bstrImagesDir               = NULL;
    BSTR            bstrDeviceID                = NULL;
    WIAVIDEO_STATE  VideoState                  = WIAVIDEO_NO_VIDEO;
    DWORD           dwStartTime                 = 0;
    DWORD           dwEndTime                   = 0;

    if (LOCAL_GVAR.pWiaVideo == NULL)
    {
        return E_POINTER;
    }

    hr = LOCAL_GVAR.pWiaVideo->GetCurrentState(&VideoState);

    if (VideoState != WIAVIDEO_NO_VIDEO)
    {
        AppUtil_MsgBox(IDS_ERROR,
                       IDS_VIDEO_STILL_ACTIVE,
                       MB_OK | MB_ICONSTOP);

        return hr;
    }

    SetCursor( LoadCursor(NULL, IDC_WAIT));

    //
    // We need to do this first, otherwise the driver is not loaded yet,
    // and therefore the images directory property will have not been set
    //
    if (hr == S_OK)
    {
        hr = WiaProc_CreateSelectedDevice(szDeviceID,
                                          sizeof(szDeviceID) / sizeof(TCHAR));
    }

    dwStartTime = timeGetTime();

    //
    // Get the images directory stored in the driver.  We don't have to do this
    // we can come up with our own, but the driver will generate a default temp
    // location, which is good enough for our purposes.
    //
    if (hr == S_OK)
    {
        hr = WiaProc_GetImageDirectory(szImagesDirectory,
                                       sizeof(szImagesDirectory) / sizeof(TCHAR));
    }

    if (hr == S_OK)
    {
        WCHAR wszDeviceID[MAX_PATH] = {0};

        AppUtil_ConvertToWideString(szDeviceID, wszDeviceID,
                                    sizeof(wszDeviceID) / sizeof(WCHAR));


        bstrDeviceID = ::SysAllocString(wszDeviceID);
    }

    //
    // Set the images directory on the WiaVideo object
    //
    if (hr == S_OK)
    {
        WCHAR wszImagesDir[MAX_PATH] = {0};

        AppUtil_ConvertToWideString(szImagesDirectory, wszImagesDir,
                                    sizeof(wszImagesDir) / sizeof(WCHAR));


        bstrImagesDir = ::SysAllocString(wszImagesDir);

        hr = LOCAL_GVAR.pWiaVideo->put_ImagesDirectory(bstrImagesDir);
    }

    //
    // Create Video.
    //
    if (hr == S_OK)
    {
        hr = LOCAL_GVAR.pWiaVideo->CreateVideoByWiaDevID(bstrDeviceID,
                                                         GetDlgItem(APP_GVAR.hwndMainDlg,
                                                                    IDC_VIDEO_PREVIEW_WINDOW),
                                                         FALSE,
                                                         TRUE);
    }

    dwEndTime = timeGetTime();

    SetDlgItemInt(APP_GVAR.hwndMainDlg,
                  IDC_EDIT_GRAPH_BUILD_TIME,
                  (UINT) abs(dwEndTime - dwStartTime),
                  FALSE);

    if (hr == S_OK)
    {
        SetDlgItemText(APP_GVAR.hwndMainDlg,
                       IDC_EDIT_IMAGES_DIR,
                       szImagesDirectory);
    }

    //
    // Populate our list of items for this device
    //
    if (hr == S_OK)
    {
        hr = WiaProc_PopulateItemList();
    }

    if (bstrImagesDir)
    {
        ::SysFreeString(bstrImagesDir);
        bstrImagesDir = NULL;
    }

    if (bstrDeviceID)
    {
        ::SysFreeString(bstrDeviceID);
        bstrDeviceID = NULL;
    }

    SetCursor( LoadCursor(NULL, IDC_ARROW));

    if (hr != S_OK)
    {
        AppUtil_MsgBox(IDS_ERROR,
                       IDS_FAILED_TO_CREATE_VIDEO,
                       MB_OK | MB_ICONSTOP,
                       hr);
    }

    return hr;
}

///////////////////////////////
// CreateVideoEnumPos
//
HRESULT CreateVideoEnumPos()
{
    HRESULT         hr                          = S_OK;
    TCHAR           szImagesDirectory[MAX_PATH] = {0};
    TCHAR           szFriendlyName[255 + 1]     = {0};
    BSTR            bstrImagesDir               = NULL;
    WIAVIDEO_STATE  VideoState                  = WIAVIDEO_NO_VIDEO;
    DWORD           dwStartTime                 = 0;
    DWORD           dwEndTime                   = 0;

    if (LOCAL_GVAR.pWiaVideo == NULL)
    {
        return E_POINTER;
    }

    hr = LOCAL_GVAR.pWiaVideo->GetCurrentState(&VideoState);

    if (VideoState != WIAVIDEO_NO_VIDEO)
    {
        AppUtil_MsgBox(IDS_ERROR, 
                       IDS_VIDEO_STILL_ACTIVE,
                       MB_OK | MB_ICONSTOP);

        return hr;
    }

    SetCursor( LoadCursor(NULL, IDC_WAIT));

    LRESULT lResult = 0;
    lResult = SendDlgItemMessage(APP_GVAR.hwndMainDlg, 
                                 IDC_LIST_WIA_DEVICES,
                                 LB_GETCURSEL,
                                 0,
                                 0);

    WPARAM Index = (WPARAM) lResult;

    lResult = SendDlgItemMessage(APP_GVAR.hwndMainDlg, 
                                 IDC_LIST_WIA_DEVICES,
                                 LB_GETTEXT,
                                 Index,
                                 (LPARAM) szFriendlyName);

    dwStartTime = timeGetTime();

    //
    // Get the images directory stored in the driver.  We don't have to do this
    // we can come up with our own, but the driver will generate a default temp
    // location, which is good enough for our purposes.
    //

    TCHAR szTempPath[MAX_PATH] = {0};

    if (hr == S_OK)
    {
        GetTempPath(MAX_PATH, szTempPath);
        _sntprintf(szImagesDirectory, sizeof(szImagesDirectory) / sizeof(TCHAR),
                   TEXT("%s\\WiaVideoTest\\%s"), szTempPath, szFriendlyName);
                   
    }

    //
    // Set the images directory on the WiaVideo object
    //
    if (hr == S_OK)
    {
        WCHAR wszImagesDir[MAX_PATH] = {0};

        AppUtil_ConvertToWideString(szImagesDirectory, wszImagesDir, 
                                    sizeof(wszImagesDir) / sizeof(WCHAR));


        bstrImagesDir = ::SysAllocString(wszImagesDir);

        hr = LOCAL_GVAR.pWiaVideo->put_ImagesDirectory(bstrImagesDir);
    }

    //
    // Create Video.
    // 
    if (hr == S_OK)
    {
        UINT uiDeviceNumber = (UINT) Index;

        hr = LOCAL_GVAR.pWiaVideo->CreateVideoByDevNum(uiDeviceNumber,
                                                       GetDlgItem(APP_GVAR.hwndMainDlg,
                                                                  IDC_VIDEO_PREVIEW_WINDOW),
                                                       FALSE,
                                                       TRUE);
    }

    dwEndTime = timeGetTime();

    SetDlgItemInt(APP_GVAR.hwndMainDlg,
                  IDC_EDIT_GRAPH_BUILD_TIME,
                  (UINT) abs(dwEndTime - dwStartTime),
                  FALSE);

    if (hr == S_OK)
    {
        SetDlgItemText(APP_GVAR.hwndMainDlg,
                       IDC_EDIT_IMAGES_DIR,
                       szImagesDirectory);
    }

    //
    // Populate our list of items for this device
    //
    if (hr == S_OK)
    {
        hr = ImageLst_PopulateDShowItemList(szImagesDirectory);
    }

    if (bstrImagesDir)
    {
        ::SysFreeString(bstrImagesDir);
        bstrImagesDir = NULL;
    }

    SetCursor( LoadCursor(NULL, IDC_ARROW));

    if (hr != S_OK)
    {
        AppUtil_MsgBox(IDS_ERROR, 
                       IDS_FAILED_TO_CREATE_VIDEO,
                       MB_OK | MB_ICONSTOP,
                       hr);
    }

    return hr;
}

///////////////////////////////
// CreateVideoFriendlyName
//
HRESULT CreateVideoFriendlyName()
{
    HRESULT         hr                          = S_OK;
    TCHAR           szImagesDirectory[MAX_PATH] = {0};
    TCHAR           szFriendlyName[255 + 1]     = {0};
    BSTR            bstrFriendlyName            = NULL;
    BSTR            bstrImagesDir               = NULL;
    WIAVIDEO_STATE  VideoState                  = WIAVIDEO_NO_VIDEO;
    DWORD           dwStartTime                 = 0;
    DWORD           dwEndTime                   = 0;

    if (LOCAL_GVAR.pWiaVideo == NULL)
    {
        return E_POINTER;
    }

    hr = LOCAL_GVAR.pWiaVideo->GetCurrentState(&VideoState);

    if (VideoState != WIAVIDEO_NO_VIDEO)
    {
        AppUtil_MsgBox(IDS_ERROR, 
                       IDS_VIDEO_STILL_ACTIVE,
                       MB_OK | MB_ICONSTOP);

        return hr;
    }

    SetCursor( LoadCursor(NULL, IDC_WAIT));

    LRESULT lResult = 0;
    lResult = SendDlgItemMessage(APP_GVAR.hwndMainDlg, 
                                 IDC_LIST_WIA_DEVICES,
                                 LB_GETCURSEL,
                                 0,
                                 0);

    WPARAM Index = (WPARAM) lResult;

    lResult = SendDlgItemMessage(APP_GVAR.hwndMainDlg, 
                                 IDC_LIST_WIA_DEVICES,
                                 LB_GETTEXT,
                                 Index,
                                 (LPARAM) szFriendlyName);

    dwStartTime = timeGetTime();

    //
    // Get the images directory stored in the driver.  We don't have to do this
    // we can come up with our own, but the driver will generate a default temp
    // location, which is good enough for our purposes.
    //

    TCHAR szTempPath[MAX_PATH] = {0};

    if (hr == S_OK)
    {
        GetTempPath(MAX_PATH, szTempPath);
        _sntprintf(szImagesDirectory, sizeof(szImagesDirectory) / sizeof(TCHAR),
                   TEXT("%s\\WiaVideoTest\\%s"), szTempPath, szFriendlyName);
                   
    }

    //
    // Set the images directory on the WiaVideo object
    //
    if (hr == S_OK)
    {
        WCHAR wszImagesDir[MAX_PATH] = {0};

        AppUtil_ConvertToWideString(szImagesDirectory, wszImagesDir, 
                                    sizeof(wszImagesDir) / sizeof(WCHAR));


        bstrImagesDir = ::SysAllocString(wszImagesDir);

        hr = LOCAL_GVAR.pWiaVideo->put_ImagesDirectory(bstrImagesDir);
    }

    //
    // Set the images directory on the WiaVideo object
    //
    if (hr == S_OK)
    {
        WCHAR wszFriendlyName[255 + 1] = {0};

        AppUtil_ConvertToWideString(szFriendlyName, wszFriendlyName, 
                                    sizeof(wszFriendlyName) / sizeof(WCHAR));

        bstrFriendlyName = ::SysAllocString(wszFriendlyName);
    }

    //
    // Create Video.
    // 
    if (hr == S_OK)
    {
        UINT uiDeviceNumber = (UINT) lResult;

        hr = LOCAL_GVAR.pWiaVideo->CreateVideoByName(bstrFriendlyName,
                                                     GetDlgItem(APP_GVAR.hwndMainDlg,
                                                                IDC_VIDEO_PREVIEW_WINDOW),
                                                     FALSE,
                                                     TRUE);
    }

    dwEndTime = timeGetTime();

    SetDlgItemInt(APP_GVAR.hwndMainDlg,
                  IDC_EDIT_GRAPH_BUILD_TIME,
                  (UINT) abs(dwEndTime - dwStartTime),
                  FALSE);

    if (hr == S_OK)
    {
        SetDlgItemText(APP_GVAR.hwndMainDlg,
                       IDC_EDIT_IMAGES_DIR,
                       szImagesDirectory);
    }

    //
    // Populate our list of items for this device
    //
    if (hr == S_OK)
    {
        hr = ImageLst_PopulateDShowItemList(szImagesDirectory);
    }

    if (bstrImagesDir)
    {
        ::SysFreeString(bstrImagesDir);
        bstrImagesDir = NULL;
    }

    if (bstrFriendlyName)
    {
        ::SysFreeString(bstrFriendlyName);
        bstrFriendlyName = NULL;
    }


    SetCursor( LoadCursor(NULL, IDC_ARROW));

    if (hr != S_OK)
    {
        AppUtil_MsgBox(IDS_ERROR, 
                       IDS_FAILED_TO_CREATE_VIDEO,
                       MB_OK | MB_ICONSTOP,
                       hr);
    }

    return hr;
}

///////////////////////////////
// DestroyVideo
//
HRESULT DestroyVideo()
{
    HRESULT hr = S_OK;
    if (LOCAL_GVAR.pWiaVideo == NULL)
    {
        return E_POINTER;
    }

    hr = LOCAL_GVAR.pWiaVideo->DestroyVideo();

    if (APP_GVAR.bWiaDeviceListMode)
    {
        hr = WiaProc_DestroySelectedDevice();
        ImageLst_Clear();
    }
    else
    {
        ImageLst_Clear();
    }

    SetDlgItemInt(APP_GVAR.hwndMainDlg,
                  IDC_EDIT_GRAPH_BUILD_TIME,
                  0,
                  FALSE);

    SetDlgItemInt(APP_GVAR.hwndMainDlg,
                  IDC_EDIT_LIST_LOAD_TIME,
                  0,
                  FALSE);


    return hr;
}

///////////////////////////////
// Play
//
HRESULT Play()
{
    HRESULT hr = S_OK;

    if (LOCAL_GVAR.pWiaVideo == NULL)
    {
        return E_POINTER;
    }

    LOCAL_GVAR.pWiaVideo->Play();

    return hr;
}

///////////////////////////////
// Pause
//
HRESULT Pause()
{
    HRESULT hr = S_OK;

    if (LOCAL_GVAR.pWiaVideo == NULL)
    {
        return E_POINTER;
    }

    LOCAL_GVAR.pWiaVideo->Pause();

    return hr;
}

///////////////////////////////
// TakePicture
//
HRESULT TakePicture(BOOL bTakePictureThroughDriver)
{
    HRESULT hr = S_OK;

    if (APP_GVAR.bWiaDeviceListMode)
    {
        if (bTakePictureThroughDriver)
        {
            //
            // send DeviceCommand to driver.  This is an async call for
            // the Wia Video Driver which means we will NOT receive a 
            // WiaItem object back.
            //
    
            hr = WiaProc_DeviceTakePicture();
        }
        else
        {
            if (LOCAL_GVAR.pWiaVideo)
            {
                BSTR bstrNewImage = NULL;
    
                hr = LOCAL_GVAR.pWiaVideo->TakePicture(&bstrNewImage);
    
                if (hr == S_OK)
                {
                    WiaProc_SetLastSavedImage(bstrNewImage);
                }
    
                if (bstrNewImage)
                {
                    ::SysFreeString(bstrNewImage);
                    bstrNewImage = NULL;
                }
            }
            else
            {
                hr = E_POINTER;
            }
    
        }
    }
    else
    {
        if (LOCAL_GVAR.pWiaVideo)
        {
            BSTR bstrNewImage = NULL;

            hr = LOCAL_GVAR.pWiaVideo->TakePicture(&bstrNewImage);

            if (hr == S_OK)
            {
                ImageLst_PostAddImageRequest(bstrNewImage);

                if (bstrNewImage)
                {
                    ::SysFreeString(bstrNewImage);
                    bstrNewImage = NULL;
                }
            }
        }
    }

    return hr;
}

///////////////////////////////
// ShowVideo
//
HRESULT ShowVideo()
{
    HRESULT hr = S_OK;

    if (LOCAL_GVAR.pWiaVideo == NULL)
    {
        return E_POINTER;
    }

    if (LOCAL_GVAR.bPreviewVisible)
    {
        LOCAL_GVAR.bPreviewVisible = FALSE;
    }
    else
    {
        LOCAL_GVAR.bPreviewVisible = TRUE;
    }

    hr = LOCAL_GVAR.pWiaVideo->put_PreviewVisible(LOCAL_GVAR.bPreviewVisible);

    return hr;
}

///////////////////////////////
// ResizeVideo
//
HRESULT ResizeVideo(BOOL bStretchToFitWindow)
{
    HRESULT hr = S_OK;

    if (LOCAL_GVAR.pWiaVideo == NULL)
    {
        return E_POINTER;
    }

    hr = LOCAL_GVAR.pWiaVideo->ResizeVideo(bStretchToFitWindow);

    return hr;
}

///////////////////////////////
// ShowCurrentState
//
HRESULT ShowCurrentState()
{
    HRESULT         hr         = S_OK;
    WIAVIDEO_STATE  VideoState = WIAVIDEO_NO_VIDEO;

    if (LOCAL_GVAR.pWiaVideo == NULL)
    {
        return E_POINTER;
    }

    hr = LOCAL_GVAR.pWiaVideo->GetCurrentState(&VideoState);

    if (hr == S_OK)
    {
        UINT  uiResID = 0;
        TCHAR szState[63 + 1] = {0};

        switch (VideoState)
        {
            case WIAVIDEO_NO_VIDEO:
                uiResID = IDS_NO_VIDEO;
            break;

            case WIAVIDEO_CREATING_VIDEO:
                uiResID = IDS_CREATING_VIDEO;
            break;

            case WIAVIDEO_VIDEO_CREATED:
                uiResID = IDS_VIDEO_CREATED;
            break;

            case WIAVIDEO_VIDEO_PLAYING:
                uiResID = IDS_PLAYING_VIDEO;
            break;

            case WIAVIDEO_VIDEO_PAUSED:
                uiResID = IDS_VIDEO_PAUSED;
            break;

            case WIAVIDEO_DESTROYING_VIDEO:
                uiResID = IDS_DESTROYING_VIDEO;
            break;

            default:
                uiResID = IDS_STATE_UNKNOWN;
            break;
        }

        LoadString(APP_GVAR.hInstance,
                   uiResID,
                   szState,
                   sizeof(szState) / sizeof(TCHAR));

        if (szState[0] != 0)
        {
            SetDlgItemText(APP_GVAR.hwndMainDlg,
                           IDC_EDIT_CURRENT_STATE,
                           szState);
        }
    }

    return hr;
}

///////////////////////////////
// CreateWiaVideoObject
//
HRESULT CreateWiaVideoObject()
{
    HRESULT hr = S_OK;

    if (hr == S_OK)
    {
        // Create the WiaVideo object
        hr = CoCreateInstance(CLSID_WiaVideo, NULL, CLSCTX_INPROC_SERVER,
                              IID_IWiaVideo, (LPVOID *)&LOCAL_GVAR.pWiaVideo);
    }

    return hr;
}

///////////////////////////////
// TakePictureStress
//
HRESULT TakePictureStress()
{
    HRESULT hr      = S_OK;
    INT_PTR iReturn = 0;

    //
    // Ask user how many threads to use and how many
    // pictures each thread should take.
    //

    LOCAL_GVAR.iNumThreads         = 0;
    LOCAL_GVAR.uiNumImagesPerThread = 0;

    iReturn = DialogBox(APP_GVAR.hInstance,
                        MAKEINTRESOURCE(IDD_STRESSDLG),
                        APP_GVAR.hwndMainDlg,
                        (DLGPROC) StressDlgProc);


    if (iReturn == IDOK)
    {
        SetDlgItemInt(APP_GVAR.hwndMainDlg, IDC_EDIT_NUM_STRESS_THREADS,
                      LOCAL_GVAR.iNumThreads, FALSE);

        UINT uiNumThreads = (UINT) LOCAL_GVAR.iNumThreads;

        for (UINT i = 0; (i < uiNumThreads) && (hr == S_OK); i++)
        {
            ThreadArgs_t *pArgs = new ThreadArgs_t;

            if (pArgs)
            {
                DWORD dwThreadID = 0;

                ZeroMemory(pArgs, sizeof(ThreadArgs_t));

                pArgs->uiNumPicturesToTake = LOCAL_GVAR.uiNumImagesPerThread;
                pArgs->uiThreadSleepTime   = (rand() % 100) + 25;    // 25 - 125 ms sleeptime.

                CreateThread(NULL,
                             0,
                             TakePictureThreadProc,
                             (void*) pArgs,
                             0,
                             &dwThreadID);
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }

    return hr;

}


///////////////////////////////
// StressDlgProc
//
// Mesage handler for Stress Dialog Box
//
LRESULT CALLBACK StressDlgProc(HWND     hDlg,
                               UINT     message,
                               WPARAM   wParam,
                               LPARAM   lParam)
{
    switch (message)
    {
        case WM_INITDIALOG:
            return TRUE;
        break;

        case WM_COMMAND:
            if (LOWORD(wParam) == IDOK)
            {
                BOOL bTranslated = TRUE;

                LOCAL_GVAR.iNumThreads = GetDlgItemInt(hDlg,
                                                        IDC_EDIT_NUM_THREADS,
                                                        &bTranslated,
                                                        FALSE);

                LOCAL_GVAR.uiNumImagesPerThread = GetDlgItemInt(hDlg,
                                                        IDC_EDIT_NUM_IMAGES_PER_THREAD,
                                                        &bTranslated,
                                                        FALSE);
                EndDialog(hDlg, LOWORD(wParam));
                return TRUE;
            }
            else if (LOWORD(wParam) == IDCANCEL)
            {
                EndDialog(hDlg, LOWORD(wParam));
                return TRUE;
            }

        break;
    }

    return FALSE;
}

///////////////////////////////
// TakePictureMultiple
//
HRESULT TakePictureMultiple()
{
    HRESULT hr      = S_OK;
    INT_PTR iReturn = 0;

    //
    // Ask user how many threads to use and how many
    // pictures each thread should take.
    //

    LOCAL_GVAR.iNumThreads         = 0;
    LOCAL_GVAR.uiNumImagesPerThread = 0;

    iReturn = DialogBox(APP_GVAR.hInstance,
                        MAKEINTRESOURCE(IDD_DIALOG_TAKE_PICTURE_MULTIPLE),
                        APP_GVAR.hwndMainDlg,
                        (DLGPROC) MultipleDlgProc);


    if (iReturn == IDOK)
    {
        SetDlgItemInt(APP_GVAR.hwndMainDlg, IDC_EDIT_NUM_STRESS_THREADS,
                      1, FALSE);

        //
        // uiNumThreads should be 1.
        //
        UINT uiNumThreads = 1;

        for (UINT i = 0; i < uiNumThreads; i++)
        {
            ThreadArgs_t *pArgs = new ThreadArgs_t;

            if (pArgs)
            {
                ZeroMemory(pArgs, sizeof(ThreadArgs_t));
                pArgs->uiNumPicturesToTake = LOCAL_GVAR.uiNumImagesPerThread;
                pArgs->uiThreadSleepTime   = LOCAL_GVAR.uiTakePictureInterval;

                DWORD dwThreadID = 0;
    
                CreateThread(NULL, 
                             0, 
                             TakePictureThreadProc, 
                             (void*) pArgs,
                             0, 
                             &dwThreadID);
            }
        }
    }

    return hr;

}


///////////////////////////////
// MultipleDlgProc
//
// Mesage handler for Stress Dialog Box
//
LRESULT CALLBACK MultipleDlgProc(HWND     hDlg,
                                 UINT     message,
                                 WPARAM   wParam,
                                 LPARAM   lParam)
{
    switch (message)
    {
        case WM_INITDIALOG:
            return TRUE;
        break;

        case WM_COMMAND:
            if (LOWORD(wParam) == IDOK)
            {
                BOOL bTranslated = TRUE;

                LOCAL_GVAR.iNumThreads = 1;

                LOCAL_GVAR.uiNumImagesPerThread = GetDlgItemInt(hDlg,
                                                        IDC_EDIT_NUM_PICTURES_TO_TAKE,
                                                        &bTranslated,
                                                        FALSE);

                LOCAL_GVAR.uiTakePictureInterval = GetDlgItemInt(hDlg,
                                                        IDC_EDIT_TAKE_PICTURE_FREQUENCY,
                                                        &bTranslated,
                                                        FALSE);

                EndDialog(hDlg, LOWORD(wParam));
                return TRUE;
            }
            else if (LOWORD(wParam) == IDCANCEL)
            {
                EndDialog(hDlg, LOWORD(wParam));
                return TRUE;
            }

        break;
    }

    return FALSE;
}

///////////////////////////////
// TakePictureThreadProc
//
DWORD WINAPI TakePictureThreadProc(void *pArgs)
{
    HRESULT hr                = S_OK;
    BOOL bDone                = FALSE;
    ThreadArgs_t *pThreadArgs = (ThreadArgs_t*) pArgs;

    if (pThreadArgs == NULL)
    {
        return E_POINTER;
    }

    UINT uiNumPicturesToTake = pThreadArgs->uiNumPicturesToTake;
    UINT uiSleepTime         = pThreadArgs->uiThreadSleepTime;
    UINT uiNumPicturesTaken  = 0;

    delete pThreadArgs;
    pThreadArgs = NULL;

    while (!bDone)
    {
        if ((LOCAL_GVAR.pWiaVideo    == NULL) ||
            (LOCAL_GVAR.bExitThreads == TRUE))
        {
            bDone = TRUE;
        }

        if (!bDone)
        {
            hr = TakePicture(FALSE);

            if (hr != S_OK)
            {
                bDone = TRUE;
            }

            Sleep(uiSleepTime);

            ++uiNumPicturesTaken;

            if (uiNumPicturesTaken >= uiNumPicturesToTake)
            {
                bDone = TRUE;
            }
        }
    }

    InterlockedDecrement((LONG*) &LOCAL_GVAR.iNumThreads);

    SetDlgItemInt(APP_GVAR.hwndMainDlg, IDC_EDIT_NUM_STRESS_THREADS,
                  LOCAL_GVAR.iNumThreads, FALSE);

    return 0;
}

///////////////////////////////
// GetDeviceProperty
//
// Static Fn
//
BOOL GetDeviceProperty(IPropertyBag         *pPropertyBag,
                       LPCWSTR              pwszProperty,
                       TCHAR                *pszProperty,
                       DWORD                cchProperty)
{
    HRESULT hr = S_OK;

    VARIANT VarName;

    if ((pPropertyBag == NULL) || 
        (pwszProperty == NULL) ||
        (pszProperty  == NULL))
    {
        hr = E_POINTER;
    }
    
    if (SUCCEEDED(hr))
    {
        VariantInit(&VarName);
        VarName.vt = VT_BSTR;
        hr = pPropertyBag->Read(pwszProperty, &VarName, 0);
    }

    if (SUCCEEDED(hr))
    {
        hr = AppUtil_ConvertToTCHAR(VarName.bstrVal,
                                    pszProperty,
                                    cchProperty);

        VariantClear(&VarName);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiavideotest\wiaproc.cpp ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2000
 *
 *  TITLE:       WiaProc.cpp
 *
 *  VERSION:     1.0
 *
 *  DATE:        2000/11/14
 *
 *  DESCRIPTION: Manages Wia side of things
 *
 *****************************************************************************/
#include <stdafx.h>
#include <mmsystem.h>

#include "wiavideotest.h"

static struct 
{
    DWORD                   dwWiaDevMgrCookie;
    DWORD                   dwSelectedDeviceCookie;
    IUnknown                *pCreateCallback;
    IUnknown                *pDeleteCallback;
    IUnknown                *pDisconnectedCallback;
    IUnknown                *pConnectedCallback;
    IGlobalInterfaceTable   *pGIT;
    CRITICAL_SECTION        CritSec;
} LOCAL_GVAR = 
{
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    0,
    FALSE,
    NULL
};


/****************************Local Function Prototypes********************/
HRESULT ClearDeviceList();
HRESULT AddItemToList(IWiaPropertyStorage *pItem,
                      TCHAR               *pszFriendlyName,
                      TCHAR               *pszDeviceID);

WPARAM GetNumDevicesInList();

IWiaPropertyStorage* GetWiaStorage(WPARAM uiIndex);

HRESULT CreateWiaDevMgr(IWiaDevMgr **ppDevMgr);

HRESULT GetProperty(IWiaPropertyStorage *pPropStorage, 
                    PROPID              nPropID, 
                    LONG                *pnValue);

HRESULT GetProperty(IWiaPropertyStorage *pPropStorage, 
                    PROPID              nPropID, 
                    TCHAR               *pszBuffer,
                    UINT                cbBuffer);

HRESULT SetProperty(IWiaPropertyStorage *pPropStorage, 
                    PROPID              nPropID,
                    const PROPVARIANT   *ppv, 
                    PROPID              nNameFirst);


HRESULT AppUtil_ConvertToWideString(const TCHAR   *pszStringToConvert,
                            WCHAR         *pwszString,
                            UINT          cchString);

HRESULT AppUtil_ConvertToTCHAR(const WCHAR   *pwszStringToConvert,
                       TCHAR         *pszString,
                       UINT          cchString);

HRESULT CreateRootItem(IWiaDevMgr          *pDevMgr,
                       const TCHAR         *pszWiaDeviceID,
                       IWiaItem            **ppRootItem);

HRESULT RegisterForEvents(IWiaDevMgr *pDevMgr);



///////////////////////////////
// WiaProc_Init
//
HRESULT WiaProc_Init()
{
    HRESULT     hr          = S_OK;
    IWiaDevMgr  *pWiaDevMgr = NULL;

    if (LOCAL_GVAR.dwWiaDevMgrCookie != 0)
    {
        return S_OK;
    }

    __try 
    {
        if (!InitializeCriticalSectionAndSpinCount(&LOCAL_GVAR.CritSec, MINLONG))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER) 
    {
        hr = E_OUTOFMEMORY;
    }

    if (hr == S_OK)
    {
        hr = CreateWiaDevMgr(&pWiaDevMgr);
    }

    if (hr == S_OK)
    {
        hr = CoCreateInstance(CLSID_StdGlobalInterfaceTable,
                              NULL,
                              CLSCTX_INPROC_SERVER,
                              IID_IGlobalInterfaceTable,
                              (void **)&LOCAL_GVAR.pGIT);
    }

    if (hr == S_OK)
    {
        LOCAL_GVAR.pGIT->RegisterInterfaceInGlobal(pWiaDevMgr, 
                                                   IID_IWiaDevMgr,
                                                   &LOCAL_GVAR.dwWiaDevMgrCookie);
    }

    if (hr == S_OK)
    {
        hr = RegisterForEvents(pWiaDevMgr);
    }

    if (hr == S_OK)
    {
        WiaProc_PopulateDeviceList();
    }

    if (pWiaDevMgr)
    {
        pWiaDevMgr->Release();
        pWiaDevMgr = NULL;
    }

    return hr;
}

///////////////////////////////
// WiaProc_Term
//
HRESULT WiaProc_Term()
{
    HRESULT hr = S_OK;

    ClearDeviceList();

    if (LOCAL_GVAR.dwSelectedDeviceCookie != 0)
    {
        LOCAL_GVAR.pGIT->RevokeInterfaceFromGlobal(LOCAL_GVAR.dwSelectedDeviceCookie);
        LOCAL_GVAR.dwSelectedDeviceCookie = 0;
    }

    if (LOCAL_GVAR.dwWiaDevMgrCookie != 0)
    {
        LOCAL_GVAR.pGIT->RevokeInterfaceFromGlobal(LOCAL_GVAR.dwWiaDevMgrCookie);
        LOCAL_GVAR.dwWiaDevMgrCookie = 0;

        DeleteCriticalSection(&LOCAL_GVAR.CritSec);
    }

    if (LOCAL_GVAR.pCreateCallback)
    {
        LOCAL_GVAR.pCreateCallback->Release();
        LOCAL_GVAR.pCreateCallback = NULL;
    }

    if (LOCAL_GVAR.pDeleteCallback)
    {
        LOCAL_GVAR.pDeleteCallback->Release();
        LOCAL_GVAR.pDeleteCallback = NULL;
    }

    if (LOCAL_GVAR.pConnectedCallback)
    {
        LOCAL_GVAR.pConnectedCallback->Release();
        LOCAL_GVAR.pConnectedCallback = NULL;
    }

    if (LOCAL_GVAR.pDisconnectedCallback)
    {
        LOCAL_GVAR.pDisconnectedCallback->Release();
        LOCAL_GVAR.pDisconnectedCallback = NULL;
    }

    if (LOCAL_GVAR.pGIT)
    {
        LOCAL_GVAR.pGIT->Release();
        LOCAL_GVAR.pGIT = NULL;
    }

    return hr;
}

///////////////////////////////
// WiaProc_CreateSelectedDevice
//
HRESULT WiaProc_CreateSelectedDevice(TCHAR  *pszDeviceID,
                                     UINT   cchDeviceID)
{
    HRESULT             hr                   = S_OK;
    WPARAM              Index                = 0;
    TCHAR               szDeviceID[MAX_PATH] = {0};
    IWiaDevMgr          *pWiaDevMgr          = NULL;

    if ((LOCAL_GVAR.dwWiaDevMgrCookie == 0) ||
        (LOCAL_GVAR.pGIT              == NULL))
    {
        return E_POINTER;
    }

    hr = LOCAL_GVAR.pGIT->GetInterfaceFromGlobal(LOCAL_GVAR.dwWiaDevMgrCookie,
                                                 IID_IWiaDevMgr,
                                                 (void**)&pWiaDevMgr);

    if (pWiaDevMgr == NULL)
    {
        return E_POINTER;
    }

    LRESULT lResult = 0;
    lResult = SendDlgItemMessage(APP_GVAR.hwndMainDlg, 
                                 IDC_LIST_WIA_DEVICES,
                                 LB_GETCURSEL,
                                 0,
                                 0);

    Index = (WPARAM) lResult;

    if (Index == LB_ERR)
    {
        hr = E_FAIL;
    }

    if (hr == S_OK)
    {
        IWiaItem    *pSelectedDevice = NULL;
        LPARAM      lParam           = 0;

        lParam = SendDlgItemMessage(APP_GVAR.hwndMainDlg, 
                                    IDC_LIST_WIA_DEVICES,
                                    LB_GETITEMDATA,
                                    Index,
                                    0);

        IWiaPropertyStorage *pItem = (IWiaPropertyStorage*)lParam;

        if (pItem)
        {

            hr = GetProperty(pItem, WIA_DIP_DEV_ID, szDeviceID, 
                             sizeof(szDeviceID)/sizeof(TCHAR));

            if (hr == S_OK)
            {
                hr = CreateRootItem(pWiaDevMgr,
                                    szDeviceID,
                                    &pSelectedDevice);
            }

            if (hr == S_OK)
            {
                hr = LOCAL_GVAR.pGIT->RegisterInterfaceInGlobal(pSelectedDevice,
                                                                IID_IWiaItem,
                                                                &LOCAL_GVAR.dwSelectedDeviceCookie);
            }

            if (pszDeviceID)
            {
                _tcsncpy(pszDeviceID, szDeviceID, cchDeviceID);
            }

            if (pSelectedDevice)
            {
                pSelectedDevice->Release();
                pSelectedDevice = NULL;
            }
        }
    }

    if (pWiaDevMgr)
    {
        pWiaDevMgr->Release();
        pWiaDevMgr = NULL;
    }

    return hr;
}

///////////////////////////////
// WiaProc_GetImageDirectory
//
HRESULT WiaProc_GetImageDirectory(TCHAR *pszImageDirectory,
                                  UINT  cchImageDirectory)
{
    HRESULT             hr               = S_OK;
    IWiaPropertyStorage *pStorage        = NULL;
    IWiaItem            *pSelectedDevice = NULL;

    if ((LOCAL_GVAR.dwSelectedDeviceCookie == 0)    ||
        (LOCAL_GVAR.pGIT                   == NULL) ||
        (pszImageDirectory                 == NULL))
    {
        return E_POINTER;
    }

    if (hr == S_OK)
    {
        hr = LOCAL_GVAR.pGIT->GetInterfaceFromGlobal(LOCAL_GVAR.dwSelectedDeviceCookie,
                                                     IID_IWiaItem,
                                                     (void**)&pSelectedDevice);
    }

    if (pSelectedDevice == NULL)
    {
        hr = E_POINTER;
    }

    if (hr == S_OK)
    {
        hr = pSelectedDevice->QueryInterface(IID_IWiaPropertyStorage,
                                             (void**) &pStorage);
    }

    if (hr == S_OK)
    {
        hr = GetProperty(pStorage, WIA_DPV_IMAGES_DIRECTORY, pszImageDirectory, 
                         cchImageDirectory);
    }

    if (pStorage)
    {
        pStorage->Release();
        pStorage = NULL;
    }

    if (pSelectedDevice)
    {
        pSelectedDevice->Release();
        pSelectedDevice = NULL;
    }

    return hr;
}

///////////////////////////////
// WiaProc_DeviceTakePicture
//
HRESULT WiaProc_DeviceTakePicture()
{
    HRESULT     hr               = S_OK;
    IWiaItem    *pSelectedDevice = NULL;

    if ((LOCAL_GVAR.dwSelectedDeviceCookie == 0) ||
        (LOCAL_GVAR.pGIT                   == NULL))
    {
        return E_POINTER;
    }

    if (hr == S_OK)
    {
        hr = LOCAL_GVAR.pGIT->GetInterfaceFromGlobal(LOCAL_GVAR.dwSelectedDeviceCookie,
                                                     IID_IWiaItem,
                                                     (void**)&pSelectedDevice);
    }

    if (pSelectedDevice == NULL)
    {
        hr = E_POINTER;
    }

    if (hr == S_OK)
    {
        IWiaItem    *pUnused = NULL;
        hr = pSelectedDevice->DeviceCommand(0,
                                            &WIA_CMD_TAKE_PICTURE,
                                            &pUnused);

        if (pUnused)
        {
            pUnused->Release();
            pUnused = NULL;
        }
    }

    if (pSelectedDevice)
    {
        pSelectedDevice->Release();
        pSelectedDevice = NULL;
    }

    return hr;
}


///////////////////////////////
// ClearDeviceList
//
HRESULT ClearDeviceList()
{
    HRESULT hr = S_OK;
    WPARAM  NumDevices = 0;

    NumDevices = GetNumDevicesInList();

    //
    // Free all the IWiaItem pointers we saved in our 
    // list box.
    //
    if (NumDevices != LB_ERR)
    {
        for (WPARAM i = 0; i < NumDevices; i++)
        {
            IWiaPropertyStorage *pItem = NULL;

            pItem = GetWiaStorage(i);

            if (pItem)
            {
                pItem->Release();
            }
        }
    }

    //
    // Empty the list
    //
    SendDlgItemMessage(APP_GVAR.hwndMainDlg, 
                       IDC_LIST_WIA_DEVICES,
                       LB_RESETCONTENT,
                       0,
                       0);

    return hr;
}

///////////////////////////////
// WiaProc_PopulateDeviceList
//
HRESULT WiaProc_PopulateDeviceList()
{
    HRESULT           hr            = S_OK;
    IEnumWIA_DEV_INFO *pEnum        = NULL;
    IWiaDevMgr        *pWiaDevMgr   = NULL;

    hr = LOCAL_GVAR.pGIT->GetInterfaceFromGlobal(LOCAL_GVAR.dwWiaDevMgrCookie,
                                                 IID_IWiaDevMgr,
                                                 (void**)&pWiaDevMgr);

    if (pWiaDevMgr == NULL)
    {
        return E_POINTER;
    }

    //
    // Clear out the device list if it has any items in it.
    //
    ClearDeviceList();

    if (hr == S_OK)
    {
        hr = pWiaDevMgr->EnumDeviceInfo(0, &pEnum);
    }

    while (hr == S_OK) 
    {
        IWiaItem             *pRootItem    = NULL;
        IWiaPropertyStorage  *pPropStorage = NULL;
        TCHAR                szFriendlyName[MAX_PATH + 1] = {0};
        TCHAR                szWiaDeviceID[MAX_PATH + 1]  = {0};

        //
        // Get the next device in the enumeration.
        //
        hr = pEnum->Next(1, &pPropStorage, NULL);

        //
        // Get the device's Wia Device ID
        //
        if (hr == S_OK)
        {
            hr = GetProperty(pPropStorage, WIA_DIP_DEV_ID, szWiaDeviceID, 
                             sizeof(szWiaDeviceID)/sizeof(TCHAR));
        }

        //
        // Get the device's Wia Device Name
        //
        if (hr == S_OK)
        {
            hr = GetProperty(pPropStorage, WIA_DIP_DEV_NAME, szFriendlyName, 
                             sizeof(szFriendlyName)/sizeof(TCHAR));
        }

        //
        // We do not relesae the propstorage item because we store the pointer
        // in our list until we shutdown the app.
        //

        if (hr == S_OK)
        {
            AddItemToList(pPropStorage, szFriendlyName, szWiaDeviceID);
        }
    }

    SendDlgItemMessage(APP_GVAR.hwndMainDlg,
                       IDC_LIST_WIA_DEVICES,
                       LB_SETCURSEL,
                       0,
                       0);

    return hr;
}

///////////////////////////////
// RegisterForEvents
//
HRESULT RegisterForEvents(IWiaDevMgr    *pWiaDevMgr)
{
    HRESULT             hr          = S_OK;
    CWiaEvent           *pWiaEvent  = NULL;
    IWiaEventCallback   *pIWiaEvent = NULL;

    if (pWiaDevMgr == NULL)
    {
        return E_POINTER;
    }

    //
    // Register our callback events
    //
    if (hr == S_OK)
    {
        // create the WiaEvent
        pWiaEvent = new CWiaEvent();

        if (pWiaEvent == NULL)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (hr == S_OK)
    {
        hr = pWiaEvent->QueryInterface(IID_IWiaEventCallback, 
                                       (void**)&pIWiaEvent);
    }

    if (hr == S_OK)
    {
        hr = pWiaDevMgr->RegisterEventCallbackInterface(WIA_REGISTER_EVENT_CALLBACK,
                                                       NULL,
                                                       &WIA_EVENT_DEVICE_CONNECTED,
                                                       pIWiaEvent,
                                                       &LOCAL_GVAR.pConnectedCallback);

        hr = pWiaDevMgr->RegisterEventCallbackInterface(WIA_REGISTER_EVENT_CALLBACK,
                                                       NULL,
                                                       &WIA_EVENT_DEVICE_DISCONNECTED,
                                                       pIWiaEvent,
                                                       &LOCAL_GVAR.pDisconnectedCallback);

        hr = pWiaDevMgr->RegisterEventCallbackInterface(WIA_REGISTER_EVENT_CALLBACK,
                                                       NULL,
                                                       &WIA_EVENT_ITEM_CREATED,
                                                       pIWiaEvent,
                                                       &LOCAL_GVAR.pCreateCallback);

        hr = pWiaDevMgr->RegisterEventCallbackInterface(WIA_REGISTER_EVENT_CALLBACK,
                                                       NULL,
                                                       &WIA_EVENT_ITEM_DELETED,
                                                       pIWiaEvent,
                                                       &LOCAL_GVAR.pDeleteCallback);
    }

    //
    // We don't need to delete pWiaEvent since we are releasing it.
    //
    if (pIWiaEvent)
    {
        pIWiaEvent->Release();
        pIWiaEvent = NULL;
    }

    return hr;
}


///////////////////////////////
// AddItemToList
//
HRESULT AddItemToList(IWiaPropertyStorage *pItem,
                      TCHAR               *pszFriendlyName,
                      TCHAR               *pszDeviceID)
{
    HRESULT hr = S_OK;
    WPARAM  Index = 0;

    if ((pItem           == NULL) ||
        (pszFriendlyName == NULL) ||
        (pszDeviceID     == NULL))
    {
        hr = E_POINTER;
        return hr;
    }

    TCHAR szNewItem[MAX_PATH * 2] = {0};

    _sntprintf(szNewItem, sizeof(szNewItem)/sizeof(TCHAR),
               TEXT("%s (%s)"), pszFriendlyName, pszDeviceID);

    LRESULT lResult = 0;

    lResult = SendDlgItemMessage(APP_GVAR.hwndMainDlg, 
                                 IDC_LIST_WIA_DEVICES,
                                 LB_ADDSTRING,
                                 0, 
                                 (LPARAM) szNewItem);

    Index = (WPARAM) lResult;
    
    //
    // pItem already has an AddRef on it.
    //
    SendDlgItemMessage(APP_GVAR.hwndMainDlg, 
                       IDC_LIST_WIA_DEVICES,
                       LB_SETITEMDATA,
                       Index, 
                       (LPARAM) pItem);

    return hr;
}


///////////////////////////////
// GetNumDevicesInList
//
WPARAM GetNumDevicesInList()
{
    LRESULT lResult = 0;
    WPARAM  NumItems = 0;

    lResult = SendDlgItemMessage(APP_GVAR.hwndMainDlg, 
                                 IDC_LIST_WIA_DEVICES,
                                 LB_GETCOUNT,
                                 0, 
                                 0);

    NumItems = (WPARAM) lResult;

    return NumItems;
}

///////////////////////////////
// GetWiaStorage
//
IWiaPropertyStorage* GetWiaStorage(WPARAM Index)
{
    LPARAM                  lParam     = 0;
    IWiaPropertyStorage     *pItem     = NULL;

    lParam = SendDlgItemMessage(APP_GVAR.hwndMainDlg, 
                                IDC_LIST_WIA_DEVICES,
                                LB_GETITEMDATA,
                                Index, 
                                0);

    pItem = (IWiaPropertyStorage*)lParam;

    return pItem;
}

///////////////////////////////
// CreateWiaDevMgr
//
HRESULT CreateWiaDevMgr(IWiaDevMgr **ppDevMgr)
{
    HRESULT hr = S_OK;

    if (ppDevMgr == NULL)
    {
        hr = E_POINTER;

        return hr;
    }

    hr = CoCreateInstance(CLSID_WiaDevMgr, 
                          NULL, 
                          CLSCTX_LOCAL_SERVER,
                          IID_IWiaDevMgr,
                          (void**) ppDevMgr);

    return hr;
}

///////////////////////////////
// WiaProc_GetProperty
//
// Generic
//
HRESULT WiaProc_GetProperty(IWiaPropertyStorage *pPropStorage, 
                            PROPID              nPropID,
                            PROPVARIANT         *pPropVar)
{
    HRESULT hr = S_OK;

    if ((pPropStorage == NULL) ||
        (pPropVar     == NULL))
    {
        hr = E_POINTER;
        return hr;
    }

    PropVariantInit(pPropVar);

    PROPSPEC ps = {0};

    ps.ulKind = PRSPEC_PROPID;
    ps.propid = nPropID;

    if (SUCCEEDED(hr))
    {
        hr = pPropStorage->ReadMultiple(1, &ps, pPropVar);
    }

    return hr;
}

///////////////////////////////
// GetProperty
//
// For 'long' properties
//
HRESULT GetProperty(IWiaPropertyStorage *pPropStorage, 
                    PROPID              nPropID, 
                    LONG                *pnValue)
{
    HRESULT hr = S_OK;

    if ((pPropStorage == NULL) ||
        (pnValue      == NULL))
    {
        hr = E_POINTER;
        return hr;
    }
    
    PROPVARIANT pvPropValue;

    *pnValue = 0;

    PropVariantInit(&pvPropValue);

    hr = WiaProc_GetProperty(pPropStorage, nPropID, &pvPropValue);

    if (hr == S_OK)
    {
        if ((pvPropValue.vt == VT_I4) || 
            (pvPropValue.vt == VT_UI4))
        {
            *pnValue = pvPropValue.lVal;
        }
    }

    PropVariantClear(&pvPropValue);

    return hr;
}

///////////////////////////////
// GetProperty
//
// For 'string' properties
//
HRESULT GetProperty(IWiaPropertyStorage *pPropStorage, 
                    PROPID              nPropID, 
                    TCHAR               *pszBuffer,
                    UINT                cbBuffer)
{
    HRESULT hr = S_OK;

    if ((pPropStorage      == NULL) ||
        (pszBuffer         == NULL))
    {
        hr = E_POINTER;
        return hr;
    }
    
    PROPVARIANT pvPropValue;

    PropVariantInit(&pvPropValue);

    hr = WiaProc_GetProperty(pPropStorage, nPropID, &pvPropValue);

    if (hr == S_OK)
    {
        if ((pvPropValue.vt == VT_LPWSTR) || 
            (pvPropValue.vt == VT_BSTR))
        {
            AppUtil_ConvertToTCHAR(pvPropValue.pwszVal, pszBuffer, cbBuffer);
        }
    }

    //
    // This frees the BSTR
    //
    PropVariantClear(&pvPropValue);

    return hr;
}



///////////////////////////////
// CreateRootItem
//
HRESULT CreateRootItem(IWiaDevMgr          *pDevMgr,
                       const TCHAR         *pszWiaDeviceID,
                       IWiaItem            **ppRootItem)
{
    HRESULT hr = S_OK;

    if ((pDevMgr         == NULL) ||
        (pszWiaDeviceID  == NULL) ||
        (ppRootItem      == NULL))
    {
        hr = E_POINTER;

        return hr;
    }

    if (hr == S_OK)
    {
        BOOL bRetry = TRUE;

        BSTR bstrDeviceID = NULL;
        WCHAR wszWiaDeviceID[MAX_PATH] = {0};

        AppUtil_ConvertToWideString(pszWiaDeviceID, wszWiaDeviceID,
                            sizeof(wszWiaDeviceID) / sizeof(WCHAR));

        bstrDeviceID = SysAllocString(wszWiaDeviceID);

        for (UINT uiRetryCount = 0;
             (uiRetryCount < 5) && (bRetry);
             ++uiRetryCount)
        {

            hr = pDevMgr->CreateDevice(bstrDeviceID,
                                       ppRootItem);

            if (SUCCEEDED(hr))
            {
                //
                // Break out of loop
                //
                bRetry = FALSE;
            }
            else if (hr == WIA_ERROR_BUSY)
            {
                //
                // Wait a little while before retrying
                //
                Sleep(200);
            }
            else
            {
                //
                // All other errors are considered fatal
                //
                bRetry = FALSE;
            }
        }

        if (bstrDeviceID)
        {
            SysFreeString(bstrDeviceID);
            bstrDeviceID = NULL;
        }
    }

    return hr;
}

///////////////////////////////
// SetProperty
//
// Generic
//
HRESULT SetProperty(IWiaPropertyStorage *pPropStorage, 
                    PROPID              nPropID,
                    const PROPVARIANT   *ppv, 
                    PROPID              nNameFirst)
{
    HRESULT  hr = 0;
    PROPSPEC ps = {0};

    if ((pPropStorage == NULL) ||
        (ppv          == NULL))
    {
        return E_POINTER;
    }

    ps.ulKind = PRSPEC_PROPID;
    ps.propid = nPropID;

    if (hr == S_OK)
    {
        hr = pPropStorage->WriteMultiple(1, &ps, ppv, nNameFirst);
    }

    return hr;
}

///////////////////////////////
// WiaProc_SetLastSavedImage
//
// For 'string' properties
//
HRESULT WiaProc_SetLastSavedImage(BSTR bstrLastSavedImage)
{
    HRESULT             hr               = S_OK;
    IWiaItem            *pSelectedDevice = NULL;
    IWiaPropertyStorage *pStorage        = NULL;
    PROPVARIANT         pv = {0};

    if ((LOCAL_GVAR.dwSelectedDeviceCookie == 0) ||
        (LOCAL_GVAR.pGIT                   == NULL))
    {
        return E_POINTER;
    }

    EnterCriticalSection(&LOCAL_GVAR.CritSec);

    if (hr == S_OK)
    {
        hr = LOCAL_GVAR.pGIT->GetInterfaceFromGlobal(LOCAL_GVAR.dwSelectedDeviceCookie,
                                                     IID_IWiaItem,
                                                     (void**)&pSelectedDevice);
    }

    if (pSelectedDevice == NULL)
    {
        hr = E_POINTER;
    }

    if (hr == S_OK)
    {
        hr = pSelectedDevice->QueryInterface(IID_IWiaPropertyStorage, 
                                             (void**)&pStorage);
    }

    if (hr == S_OK)
    {
        PropVariantInit(&pv);

        pv.vt        = VT_BSTR;
        pv.bstrVal   = bstrLastSavedImage;

        hr = SetProperty(pStorage, WIA_DPV_LAST_PICTURE_TAKEN, &pv, 2);
    }

    if (pStorage)
    {
        pStorage->Release();
        pStorage = NULL;
    }

    if (pSelectedDevice)
    {
        pSelectedDevice->Release();
        pSelectedDevice = NULL;
    }

    LeaveCriticalSection(&LOCAL_GVAR.CritSec);

    return hr;
}

///////////////////////////////
// WiaProc_PopulateItemList
//
HRESULT WiaProc_PopulateItemList()
{
    HRESULT hr = S_OK;

    if (LOCAL_GVAR.dwSelectedDeviceCookie == 0)
    {
        return E_POINTER;
    }

    hr = ImageLst_PopulateWiaItemList(LOCAL_GVAR.pGIT,
                                      LOCAL_GVAR.dwSelectedDeviceCookie);

    return hr;
}

///////////////////////////////
// WiaProc_DestroySelectedDevice
//
HRESULT WiaProc_DestroySelectedDevice()
{
    HRESULT hr = S_OK;

    if (LOCAL_GVAR.dwSelectedDeviceCookie == 0)
    {
        return E_POINTER;
    }

    ImageLst_CancelLoadAndWait(5000);

    if ((LOCAL_GVAR.dwSelectedDeviceCookie != 0) &&
        (LOCAL_GVAR.pGIT                   != NULL))
    {
        LOCAL_GVAR.pGIT->RevokeInterfaceFromGlobal(LOCAL_GVAR.dwSelectedDeviceCookie);
        LOCAL_GVAR.dwSelectedDeviceCookie = 0;
    }

    ImageLst_Clear();

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiavideotest\wiavideotest.cpp ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2000
 *
 *  TITLE:       WiaVideoTest.cpp
 *
 *  VERSION:     1.0
 *
 *  DATE:        2000/11/14
 *
 *  DESCRIPTION: Creates the dialog used by the app
 *
 *****************************************************************************/
 
#include <stdafx.h>

#define INCL_APP_GVAR_OWNERSHIP 
#include "WiaVideoTest.h"

///////////////////////////////
// Constants
//
const UINT WM_CUSTOM_INIT = WM_USER + 100;


/****************************Local Function Prototypes********************/

INT_PTR CALLBACK MainDlgProc(HWND   hDlg, 
                             UINT   uiMessage, 
                             WPARAM wParam, 
                             LPARAM lParam);

INT_PTR  ProcessWMCommand(HWND   hWnd,
                          UINT   uiMessage, 
                          WPARAM wParam,
                          LPARAM lParam);

INT_PTR  ProcessWMNotify(HWND   hWnd,
                         UINT   uiMessage, 
                         WPARAM wParam,
                         LPARAM lParam);

BOOL InitApp(HINSTANCE hInstance);
void TermApp(void);
BOOL InitInstance(HINSTANCE    hInstance, 
                  int          nCmdShow);

void InitDlg(HWND hwndDlg);
void TermDlg(HWND hwndDlg);


int WINAPI WinMain(HINSTANCE hInstance,
                   HINSTANCE hPrevInstance,
                   LPSTR     lpCmdLine,
                   int       nCmdShow);

///////////////////////////////
// WinMain
//
int WINAPI WinMain(HINSTANCE  hInstance,
                   HINSTANCE  hPrevInstance,
                   LPSTR      lpCmdLine,
                   int        nCmdShow)
{
    MSG          msg;
    BOOL         bSuccess       = TRUE;
    TCHAR        *pszBaseDir    = NULL;
    INITCOMMONCONTROLSEX    CommonControls = {0};

    lpCmdLine     = lpCmdLine; 
    hPrevInstance = hPrevInstance;

    CoInitializeEx(NULL, COINIT_MULTITHREADED);
    
    CommonControls.dwSize = sizeof(CommonControls);
    CommonControls.dwICC  = ICC_WIN95_CLASSES;

    bSuccess = InitCommonControlsEx(&CommonControls);

    if (bSuccess)
    {
        bSuccess =InitApp(hInstance);
    }

    if (bSuccess)
    {
         // create the window
        bSuccess = InitInstance(hInstance, nCmdShow);
    }

    if (bSuccess)
    {
        while (GetMessage(&msg, NULL, 0, 0)) 
        {    
            if ((APP_GVAR.hwndMainDlg == NULL) || 
                (!IsDialogMessage(APP_GVAR.hwndMainDlg, &msg)))
            {
                 TranslateMessage(&msg);
                 DispatchMessage(&msg);
            }
        }    
    }

   // Terminate the application.
   TermApp();

   CoUninitialize();

   return 0;
}


///////////////////////////////
//  InitApp(HANDLE)
//
//  Initializes window data and 
//  registers window class
//
BOOL InitApp(HINSTANCE hInstance)
{
    BOOL       bSuccess = TRUE;
    HWND       hPrevWnd = NULL;
    WNDCLASSEX wc;

    if (bSuccess)
    {
        // Fill in window class structure with parameters that describe
        // the main window.

        wc.style         = 0;
        wc.cbSize        = sizeof(wc);
        wc.lpfnWndProc   = (WNDPROC)MainDlgProc;
        wc.cbClsExtra    = 0;
        wc.cbWndExtra    = DLGWINDOWEXTRA;
        wc.hInstance     = hInstance;
        wc.hIcon         = NULL;
        wc.hIconSm       = NULL;
        wc.hCursor       = 0;
        wc.hbrBackground = (HBRUSH)(COLOR_WINDOW+1);
        wc.lpszMenuName  = 0;
        wc.lpszClassName = TEXT("WIAVIDEOTEST");
    }

    if (bSuccess)
    {
        RegisterClassEx(&wc);
    }

    return bSuccess;
}

///////////////////////////////
// InitInstance(HANDLE, int)
//
// Saves instance handle and
// creates main window
//
BOOL InitInstance(HINSTANCE hInstance, 
                  int       nCmdShow)
{
    BOOL    bSuccess  = TRUE;
    HWND    hwnd      = NULL;

    // create the window and all its controls.

    if (bSuccess)
    {
        // create a modeless dialog box.
        hwnd  = CreateDialog(hInstance,
                             MAKEINTRESOURCE(IDD_MAIN_DLG),
                             HWND_DESKTOP,
                             NULL);

        if (!hwnd) 
        {
            bSuccess = FALSE;
        }
    }

    if (bSuccess)
    {
        APP_GVAR.hwndMainDlg = hwnd;

        ShowWindow(hwnd, nCmdShow);
    }

    return bSuccess;
}

///////////////////////////////
//  InitDlg(HWND)
//
//  Initializes the main dlg 
//
void InitDlg(HWND hwndDlg)
{
    SetCursor( LoadCursor(NULL, IDC_WAIT));

    SetDlgItemInt(APP_GVAR.hwndMainDlg, IDC_EDIT_NUM_STRESS_THREADS, 
                  0, FALSE);

    SetDlgItemInt(APP_GVAR.hwndMainDlg, IDC_EDIT_NUM_PICTURES_TAKEN, 
                  0, FALSE);

    //
    // Set the WIA Device List Radio box to checked and the DShow 
    // Device List Radio box to unchecked.
    //
    SendDlgItemMessage(APP_GVAR.hwndMainDlg, IDC_RADIO_WIA_DEVICE_LIST,
                       BM_SETCHECK, BST_CHECKED, 0);

    SendDlgItemMessage(APP_GVAR.hwndMainDlg, IDC_RADIO_DSHOW_DEVICE_LIST,
                       BM_SETCHECK, BST_UNCHECKED, 0);

    EnableWindow(GetDlgItem(APP_GVAR.hwndMainDlg, IDC_BUTTON_CREATE_VIDEO_WIA), TRUE);
    EnableWindow(GetDlgItem(APP_GVAR.hwndMainDlg, IDC_BUTTON_CREATE_VIDEO_ENUM_POS), FALSE);
    EnableWindow(GetDlgItem(APP_GVAR.hwndMainDlg, IDC_BUTTON_CREATE_VIDEO_FRIENDLY_NAME), FALSE);

    //
    // initialize WiaProc_Init because by default we are in WIA Device List
    // Mode.
    //
    APP_GVAR.bWiaDeviceListMode = TRUE;

    WiaProc_Init();
    VideoProc_Init();

    SetCursor( LoadCursor(NULL, IDC_ARROW));

    return;
}

///////////////////////////////
//  TermDlg(HWND)
//
void TermDlg(HWND hwndDlg)
{
    SetCursor( LoadCursor(NULL, IDC_WAIT));

    VideoProc_Term();
    WiaProc_Term();

    SetCursor( LoadCursor(NULL, IDC_ARROW));
}

///////////////////////////////
// TermApp
//
void TermApp(void)
{
}

//////////////////////////////////////////////////////////////////////
//  MainDlgProc
//
INT_PTR CALLBACK MainDlgProc(HWND   hDlg, 
                             UINT   uiMessage, 
                             WPARAM wParam, 
                             LPARAM lParam)
{
    INT_PTR     iReturn         = 0;

    switch (uiMessage) 
    {
        case WM_CREATE:
            PostMessage(hDlg,
                        WM_CUSTOM_INIT,
                        0,
                        0);
            return 0;
        break;

        case WM_CUSTOM_INIT:
            InitDlg(hDlg);
        break;

        //
        // Defined in WiaProc.h
        //
        case WM_CUSTOM_ADD_IMAGE:
            ImageLst_AddImageToList((BSTR)lParam);
        break;
    
        case WM_CLOSE:
            // terminate the dialog subsystems
            TermDlg(hDlg); 

            DestroyWindow(hDlg);
        break;
        
        case WM_DESTROY:
            // terminate the application
            PostQuitMessage(0);
        break;
       
        case WM_COMMAND:
            iReturn = ProcessWMCommand(hDlg,
                                       uiMessage,
                                       wParam,
                                       lParam);
        break;
  
        case WM_NOTIFY:
            iReturn = ProcessWMNotify(hDlg,
                                      uiMessage,
                                      wParam,
                                      lParam);
        break;

        default:
            iReturn = DefDlgProc(hDlg,
                                 uiMessage,
                                 wParam,
                                 lParam);
        break;
    }

    return iReturn;
}

///////////////////////////////
// ProcessWMCommand
//
//
INT_PTR ProcessWMCommand(HWND hWnd,
                         UINT uiMessage, 
                         WPARAM wParam,
                         LPARAM lParam)
{
   int      iId;
   int      iEvent;
   INT_PTR  iReturn = 0;

   iId    = LOWORD(wParam); 
   iEvent = HIWORD(wParam); 

   //Parse the menu selections:
   switch (iId) 
   {
       case IDC_BUTTON_CREATE_VIDEO_WIA:
       case IDC_BUTTON_CREATE_VIDEO_ENUM_POS:
       case IDC_BUTTON_CREATE_VIDEO_FRIENDLY_NAME:
       case IDC_BUTTON_DESTROY_VIDEO:
       case IDC_BUTTON_PLAY:
       case IDC_BUTTON_PAUSE:
       case IDC_BUTTON_TAKE_PICTURE:
       case IDC_BUTTON_TAKE_PICTURE_DRIVER:
       case IDC_BUTTON_SHOW_VIDEO_TOGGLE:
       case IDC_BUTTON_RESIZE_TOGGLE:
       case IDC_BUTTON_TAKE_PICTURE_STRESS:
       case IDC_BUTTON_TAKE_PICTURE_MULTIPLE:

           VideoProc_ProcessMsg(iId);

       break;

       case IDC_RADIO_WIA_DEVICE_LIST:

           EnableWindow(GetDlgItem(APP_GVAR.hwndMainDlg, IDC_BUTTON_CREATE_VIDEO_WIA), TRUE);
           EnableWindow(GetDlgItem(APP_GVAR.hwndMainDlg, IDC_BUTTON_CREATE_VIDEO_ENUM_POS), FALSE);
           EnableWindow(GetDlgItem(APP_GVAR.hwndMainDlg, IDC_BUTTON_CREATE_VIDEO_FRIENDLY_NAME), FALSE);

           SendDlgItemMessage(APP_GVAR.hwndMainDlg, IDC_RADIO_WIA_DEVICE_LIST,
                              BM_SETCHECK, BST_CHECKED, 0);

           SendDlgItemMessage(APP_GVAR.hwndMainDlg, IDC_RADIO_DSHOW_DEVICE_LIST,
                              BM_SETCHECK, BST_UNCHECKED, 0);

           APP_GVAR.bWiaDeviceListMode = TRUE;
           VideoProc_DShowListTerm();
           WiaProc_Init();
       break;

       case IDC_RADIO_DSHOW_DEVICE_LIST:

           EnableWindow(GetDlgItem(APP_GVAR.hwndMainDlg, IDC_BUTTON_CREATE_VIDEO_WIA), FALSE);
           EnableWindow(GetDlgItem(APP_GVAR.hwndMainDlg, IDC_BUTTON_CREATE_VIDEO_ENUM_POS), TRUE);
           EnableWindow(GetDlgItem(APP_GVAR.hwndMainDlg, IDC_BUTTON_CREATE_VIDEO_FRIENDLY_NAME), TRUE);

           SendDlgItemMessage(APP_GVAR.hwndMainDlg, IDC_RADIO_WIA_DEVICE_LIST,
                              BM_SETCHECK, BST_UNCHECKED, 0);

           SendDlgItemMessage(APP_GVAR.hwndMainDlg, IDC_RADIO_DSHOW_DEVICE_LIST,
                              BM_SETCHECK, BST_CHECKED, 0);

           APP_GVAR.bWiaDeviceListMode = FALSE;
           WiaProc_Term();
           VideoProc_DShowListInit();
       break;

       default:
       break;
   }

   UNREFERENCED_PARAMETER(hWnd);
   UNREFERENCED_PARAMETER(uiMessage);
   UNREFERENCED_PARAMETER(lParam);

   return iReturn;
}

///////////////////////////////
// ProcessWMNotify
//
INT_PTR ProcessWMNotify(HWND    hWnd,
                        UINT    uiMessage, 
                        WPARAM  wParam,
                        LPARAM  lParam)
{
    INT_PTR              iReturn          = 0;
    NMHDR                *pNotifyHdr      = NULL;
    UINT                 uiNotifyCode     = 0;
    int                  iIDCtrl          = 0;

//    iIDCtrl = wParam;
//                                
//    pNotifyHdr   = (LPNMHDR) lParam;
//    uiNotifyCode = pNotifyHdr->code;

//    switch (uiNotifyCode) 
//    {
//        default:
//        break;
//    }


    UNREFERENCED_PARAMETER(hWnd);
    UNREFERENCED_PARAMETER(uiMessage);

    return iReturn;   
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\test\wiavideotest\wiavideotest.h ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2000
 *
 *  TITLE:       WiaVideoTest.h
 *
 *  VERSION:     1.0
 *
 *  DATE:        2000/11/14
 *
 *  DESCRIPTION: Creates the dialog used by the app
 *
 *****************************************************************************/
#ifndef _WIAVIDEOTEST_H_
#define _WIAVIDEOTEST_H_

///////////////////////////////
// APP_GVAR
//
// Global variables used across
// the application.
//
// If INCL_APP_GVAR_OWNERSHIP is NOT defined 
// by the CPP file including this header, then 
// this struct will be "extern" to them. WiaVideoTest.cpp 
// defines INCL_APP_GVAR_OWNERSHIP, in which case it will not
// be extern'd to it.
//
#ifndef INCL_APP_GVAR_OWNERSHIP
extern
#endif
struct
{
    HINSTANCE   hInstance;
    HWND        hwndMainDlg;
    BOOL        bWiaDeviceListMode; // TRUE if WIA Device List radio button is selected, FALSE otherwise
} APP_GVAR;

#endif // _WIAVIDEOTEST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\ddk\inc\amtvuids.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1995  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//

//
//  We want to use this list for generating strings for debugging too
//  so we redefine OUR_GUID_ENTRY depending on what we want to do
//
//  It is imperative that all entries in this file are declared using
//  OUR_GUID_ENTRY as that macro might have been defined in advance of
//  including this file.  See wxdebug.cpp in sdk\classes\base.
//

#ifndef OUR_GUID_ENTRY
	#define OUR_GUID_ENTRY(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
	DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8);
#endif

// -------------------------------------------------------------------------
// TVTuner GUIDS
// -------------------------------------------------------------------------

// {266EEE40-6C63-11cf-8A03-00AA006ECB65}
OUR_GUID_ENTRY(CLSID_CTVTunerFilter, 
0x266eee40, 0x6c63, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65);

// {266EEE41-6C63-11cf-8A03-00AA006ECB65}
OUR_GUID_ENTRY(CLSID_CTVTunerFilterPropertyPage, 
0x266eee41, 0x6c63, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65);

// {266EEE44-6C63-11cf-8A03-00AA006ECB65}
OUR_GUID_ENTRY(IID_AnalogVideoStandard, 
0x266eee44, 0x6c63, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65);

// {266EEE46-6C63-11cf-8A03-00AA006ECB65}
OUR_GUID_ENTRY(IID_TunerInputType, 
0x266eee46, 0x6c63, 0x11cf, 0x8a, 0x3, 0x0, 0xaa, 0x0, 0x6e, 0xcb, 0x65);


// -------------------------------------------------------------------------
// Crossbar (XBar) GUIDS
// -------------------------------------------------------------------------

// {71F96460-78F3-11d0-A18C-00A0C9118956}
OUR_GUID_ENTRY(CLSID_CrossbarFilter,
0x71f96460, 0x78f3, 0x11d0, 0xa1, 0x8c, 0x0, 0xa0, 0xc9, 0x11, 0x89, 0x56);

// {71F96461-78F3-11d0-A18C-00A0C9118956}
OUR_GUID_ENTRY(CLSID_CrossbarFilterPropertyPage,
0x71f96461, 0x78f3, 0x11d0, 0xa1, 0x8c, 0x0, 0xa0, 0xc9, 0x11, 0x89, 0x56);

// {71F96462-78F3-11d0-A18C-00A0C9118956}
OUR_GUID_ENTRY(CLSID_TVAudioFilter,
0x71f96462, 0x78f3, 0x11d0, 0xa1, 0x8c, 0x0, 0xa0, 0xc9, 0x11, 0x89, 0x56);

// {71F96463-78F3-11d0-A18C-00A0C9118956}
OUR_GUID_ENTRY(CLSID_TVAudioFilterPropertyPage,
0x71f96463, 0x78f3, 0x11d0, 0xa1, 0x8c, 0x0, 0xa0, 0xc9, 0x11, 0x89, 0x56);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\ddk\inc\afilter.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    afilter.h

Abstract:

    Header file for the address filtering library for NDIS MAC's.

Author:

    Alireza Dabagh creation-date 3-22-1993, mostly borrowed from efilter.h

Revision History:

--*/

#ifndef _ARC_FILTER_DEFS_
#define _ARC_FILTER_DEFS_

//
// Number of Ndis buffers in the buffer pool
//
#define ARC_RECEIVE_BUFFERS 64

//
// Linked list Structure for keeping track of allocated memory so we can free them later
//
typedef struct _ARC_BUFFER_LIST
{
    PVOID                   Buffer;
    UINT                    Size;
    UINT                    BytesLeft;
    struct _ARC_BUFFER_LIST *Next;
} ARC_BUFFER_LIST, *PARC_BUFFER_LIST;

//
// This is the structure that is passed to the protocol as the packet
// header during receive indication. It is also the header expected from the protocol.
// This header is NOT the same as the header passed to the mac driver
//

#define ARCNET_ADDRESS_LEN                   1

typedef struct _ARC_PROTOCOL_HEADER
{
    UCHAR                   SourceId[ARCNET_ADDRESS_LEN];   // Source Address
    UCHAR                   DestId[ARCNET_ADDRESS_LEN];     // Destination Address
    UCHAR                   ProtId;                         // Protocol ID
} ARC_PROTOCOL_HEADER, *PARC_PROTOCOL_HEADER;

//
// This structure keeps track of information about a received packet
//
typedef struct _ARC_PACKET_HEADER
{
    ARC_PROTOCOL_HEADER     ProtHeader;         // Protocol header
    USHORT                  FrameSequence;      // Frame sequence Number
    UCHAR                   SplitFlag;          // Split flag
    UCHAR                   LastSplitFlag;      // Split Flag for the last frame
    UCHAR                   FramesReceived;     // Frames in This Packet
} ARC_PACKET_HEADER, * PARC_PACKET_HEADER;

//
// Arcnet specific packet header
//
typedef struct _ARC_PACKET
{
    ARC_PACKET_HEADER       Header;             // Information about the packet
    struct _ARC_PACKET *    Next;               // Next packet in use by filter
    ULONG                   TotalLength;
    BOOLEAN                 LastFrame;
    PARC_BUFFER_LIST        FirstBuffer;
    PARC_BUFFER_LIST        LastBuffer;
    NDIS_PACKET             TmpNdisPacket;
} ARC_PACKET, * PARC_PACKET;


#define ARC_PROTOCOL_HEADER_SIZE        (sizeof(ARC_PROTOCOL_HEADER))
#define ARC_MAX_FRAME_SIZE              504
#define ARC_MAX_ADDRESS_IDS             256
#define ARC_MAX_FRAME_HEADER_SIZE       6
#define ARC_MAX_PACKET_SIZE             576


//
// Check whether an address is broadcast.
//

#define ARC_IS_BROADCAST(Address) \
    (BOOLEAN)(!(Address))


typedef ULONG MASK,*PMASK;

//
// Maximum number of opens the filter package will support.  This is
// the max so that bit masks can be used instead of a spaghetti of
// pointers.
//
#define ARC_FILTER_MAX_OPENS (sizeof(ULONG) * 8)


//
// The binding info is threaded on two lists.  When
// the binding is free it is on a single freelist.
//
// When the binding is being used it is on an index list.
//
typedef struct _ARC_BINDING_INFO
{
    PNDIS_OPEN_BLOCK            NdisBindingHandle;
    PVOID                       Reserved;
    UINT                        PacketFilters;
    ULONG                       References;
    struct _ARC_BINDING_INFO *  NextOpen;
    BOOLEAN                     ReceivedAPacket;
    UINT                        OldPacketFilters;
} ARC_BINDING_INFO,*PARC_BINDING_INFO;

//
// An opaque type that contains a filter database.
// The MAC need not know how it is structured.
//
typedef struct _ARC_FILTER
{
    struct _NDIS_MINIPORT_BLOCK *Miniport;

    //
    // Combination of all the filters of all the open bindings.
    //
    UINT                CombinedPacketFilter;

    //
    // Pointer for traversing the open list.
    //
    PARC_BINDING_INFO   OpenList;

    //
    // Bit mask of opens that are available.
    //
    // ULONG FreeBindingMask;

    NDIS_HANDLE ReceiveBufferPool;

    PARC_BUFFER_LIST FreeBufferList;
    PARC_PACKET FreePackets;

    PARC_PACKET OutstandingPackets;

    //
    // Address of the adapter.
    //
    UCHAR   AdapterAddress;

    UINT    OldCombinedPacketFilter;

} ARC_FILTER,*PARC_FILTER;




//
//UINT
//ARC_QUERY_FILTER_CLASSES(
//  IN  PARC_FILTER             Filter
//  )
//
// This macro returns the currently enabled filter classes.
//
// NOTE: THIS MACRO ASSUMES THAT THE FILTER LOCK IS HELD.
//
#define ARC_QUERY_FILTER_CLASSES(Filter) ((Filter)->CombinedPacketFilter)


//
//UINT
//ARC_QUERY_PACKET_FILTER(
//  IN  ARC_FILTER              Filter,
//  IN  NDIS_HANDLE             NdisFilterHandle
//  )
//
// This macro returns the currently enabled filter classes for a specific
// open instance.
//
// NOTE: THIS MACRO ASSUMES THAT THE FILTER LOCK IS HELD.
//
#define ARC_QUERY_PACKET_FILTER(Filter, NdisFilterHandle) \
        (((PARC_BINDING_INFO)(NdisFilterHandle))->PacketFilters)

//
// Exported routines
//

BOOLEAN
ArcCreateFilter(
    IN  struct _NDIS_MINIPORT_BLOCK *Miniport,
    IN  UCHAR                   AdapterAddress,
    OUT PARC_FILTER *           Filter
    );

VOID
ArcDeleteFilter(
    IN  PARC_FILTER Filter
    );

BOOLEAN
ArcNoteFilterOpenAdapter(
    IN  PARC_FILTER             Filter,
    IN  NDIS_HANDLE             NdisBindingHandle,
    OUT PNDIS_HANDLE            NdisFilterHandle
    );

NDIS_STATUS
ArcDeleteFilterOpenAdapter(
    IN  PARC_FILTER             Filter,
    IN  NDIS_HANDLE             NdisFilterHandle,
    IN  PNDIS_REQUEST           NdisRequest
    );

NDIS_STATUS
ArcFilterAdjust(
    IN  PARC_FILTER             Filter,
    IN  NDIS_HANDLE             NdisFilterHandle,
    IN  PNDIS_REQUEST           NdisRequest,
    IN  UINT                    FilterClasses,
    IN  BOOLEAN                 Set
    );

VOID
ArcFilterDprIndicateReceiveComplete(
    IN  PARC_FILTER             Filter
    );

VOID
ArcFilterDprIndicateReceive(
    IN  PARC_FILTER             Filter,
    IN  PUCHAR                  pRawHeader,
    IN  PUCHAR                  pData,
    IN  UINT                    Length
    );

NDIS_STATUS
ArcFilterTransferData(
    IN  PARC_FILTER             Filter,
    IN  NDIS_HANDLE             MacReceiveContext,
    IN  UINT                    ByteOffset,
    IN  UINT                    BytesToTransfer,
    OUT PNDIS_PACKET            Packet,
    OUT PUINT                   BytesTransfered
    );

VOID
ArcFreeNdisPacket(
    IN  PARC_PACKET             Packet
    );

VOID
ArcFilterDoIndication(
    IN  PARC_FILTER             Filter,
    IN  PARC_PACKET             Packet
    );

VOID
ArcDestroyPacket(
    IN  PARC_FILTER             Filter,
    IN  PARC_PACKET             Packet
    );

#endif // _ARC_FILTER_DEFS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\ddk\inc\cfg.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    cfg.h

Abstract:

    This module contains the common Configuration Manager definitions for
    both user mode and kernel mode code.

Author:

    Paula Tomlinson (paulat) 06/19/1995

Revision History:

--*/

#ifndef _CFG_INCLUDED_
#define _CFG_INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif

//
// The following definitions are also used by kernel mode code to
// set up the registry.
//
//
// VetoType used in
//      CM_Disable_DevNode
//      CM_Uninstall_DevNode
//      CM_Query_And_Remove_SubTree
//
typedef enum    _PNP_VETO_TYPE {
    PNP_VetoTypeUnknown,            // Name is unspecified
    PNP_VetoLegacyDevice,           // Name is an Instance Path
    PNP_VetoPendingClose,           // Name is an Instance Path
    PNP_VetoWindowsApp,             // Name is a Module
    PNP_VetoWindowsService,         // Name is a Service
    PNP_VetoOutstandingOpen,        // Name is an Instance Path
    PNP_VetoDevice,                 // Name is an Instance Path
    PNP_VetoDriver,                 // Name is a Driver Service Name
    PNP_VetoIllegalDeviceRequest,   // Name is an Instance Path
    PNP_VetoInsufficientPower,      // Name is unspecified
    PNP_VetoNonDisableable,         // Name is an Instance Path
    PNP_VetoLegacyDriver,           // Name is a Service
    PNP_VetoInsufficientRights      // Name is unspecified
}   PNP_VETO_TYPE, *PPNP_VETO_TYPE;


//
// DevInst problem values, returned by call to CM_Get_DevInst_Status
//
#define CM_PROB_NOT_CONFIGURED             (0x00000001)   // no config for device
#define CM_PROB_DEVLOADER_FAILED           (0x00000002)   // service load failed
#define CM_PROB_OUT_OF_MEMORY              (0x00000003)   // out of memory
#define CM_PROB_ENTRY_IS_WRONG_TYPE        (0x00000004)   //
#define CM_PROB_LACKED_ARBITRATOR          (0x00000005)   //
#define CM_PROB_BOOT_CONFIG_CONFLICT       (0x00000006)   // boot config conflict
#define CM_PROB_FAILED_FILTER              (0x00000007)   //
#define CM_PROB_DEVLOADER_NOT_FOUND        (0x00000008)   // Devloader not found
#define CM_PROB_INVALID_DATA               (0x00000009)   //
#define CM_PROB_FAILED_START               (0x0000000A)   //
#define CM_PROB_LIAR                       (0x0000000B)   //
#define CM_PROB_NORMAL_CONFLICT            (0x0000000C)   // config conflict
#define CM_PROB_NOT_VERIFIED               (0x0000000D)   //
#define CM_PROB_NEED_RESTART               (0x0000000E)   // requires restart
#define CM_PROB_REENUMERATION              (0x0000000F)   //
#define CM_PROB_PARTIAL_LOG_CONF           (0x00000010)   //
#define CM_PROB_UNKNOWN_RESOURCE           (0x00000011)   // unknown res type
#define CM_PROB_REINSTALL                  (0x00000012)   //
#define CM_PROB_REGISTRY                   (0x00000013)   //
#define CM_PROB_VXDLDR                     (0x00000014)   // WINDOWS 95 ONLY
#define CM_PROB_WILL_BE_REMOVED            (0x00000015)   // devinst will remove
#define CM_PROB_DISABLED                   (0x00000016)   // devinst is disabled
#define CM_PROB_DEVLOADER_NOT_READY        (0x00000017)   // Devloader not ready
#define CM_PROB_DEVICE_NOT_THERE           (0x00000018)   // device doesn't exist
#define CM_PROB_MOVED                      (0x00000019)   //
#define CM_PROB_TOO_EARLY                  (0x0000001A)   //
#define CM_PROB_NO_VALID_LOG_CONF          (0x0000001B)   // no valid log config
#define CM_PROB_FAILED_INSTALL             (0x0000001C)   // install failed
#define CM_PROB_HARDWARE_DISABLED          (0x0000001D)   // device disabled
#define CM_PROB_CANT_SHARE_IRQ             (0x0000001E)   // can't share IRQ
#define CM_PROB_FAILED_ADD                 (0x0000001F)   // driver failed add
#define CM_PROB_DISABLED_SERVICE           (0x00000020)   // service's Start = 4
#define CM_PROB_TRANSLATION_FAILED         (0x00000021)   // resource translation failed
#define CM_PROB_NO_SOFTCONFIG              (0x00000022)   // no soft config
#define CM_PROB_BIOS_TABLE                 (0x00000023)   // device missing in BIOS table
#define CM_PROB_IRQ_TRANSLATION_FAILED     (0x00000024)   // IRQ translator failed
#define CM_PROB_FAILED_DRIVER_ENTRY        (0x00000025)   // DriverEntry() failed.
#define CM_PROB_DRIVER_FAILED_PRIOR_UNLOAD (0x00000026)   // Driver should have unloaded.
#define CM_PROB_DRIVER_FAILED_LOAD         (0x00000027)   // Driver load unsuccessful.
#define CM_PROB_DRIVER_SERVICE_KEY_INVALID (0x00000028)   // Error accessing driver's service key
#define CM_PROB_LEGACY_SERVICE_NO_DEVICES  (0x00000029)   // Loaded legacy service created no devices
#define CM_PROB_DUPLICATE_DEVICE           (0x0000002A)   // Two devices were discovered with the same name
#define CM_PROB_FAILED_POST_START          (0x0000002B)   // The drivers set the device state to failed
#define CM_PROB_HALTED                     (0x0000002C)   // This device was failed post start via usermode
#define CM_PROB_PHANTOM                    (0x0000002D)   // The devinst currently exists only in the registry
#define CM_PROB_SYSTEM_SHUTDOWN            (0x0000002E)   // The system is shutting down
#define CM_PROB_HELD_FOR_EJECT             (0x0000002F)   // The device is offline awaiting removal
#define CM_PROB_DRIVER_BLOCKED             (0x00000030)   // One or more drivers is blocked from loading
#define CM_PROB_REGISTRY_TOO_LARGE         (0x00000031)   // System hive has grown too large
#define NUM_CM_PROB                        (0x00000032)

//
// Configuration Manager Global State Flags (returned by CM_Get_Global_State)
//
#define CM_GLOBAL_STATE_CAN_DO_UI            (0x00000001) // Can  do UI?
#define CM_GLOBAL_STATE_ON_BIG_STACK         (0x00000002) // WINDOWS 95 ONLY
#define CM_GLOBAL_STATE_SERVICES_AVAILABLE   (0x00000004) // CM APIs available?
#define CM_GLOBAL_STATE_SHUTTING_DOWN        (0x00000008) // CM shutting down
#define CM_GLOBAL_STATE_DETECTION_PENDING    (0x00000010) // detection pending

//
// Device Instance status flags, returned by call to CM_Get_DevInst_Status
//
#define DN_ROOT_ENUMERATED (0x00000001) // Was enumerated by ROOT
#define DN_DRIVER_LOADED   (0x00000002) // Has Register_Device_Driver
#define DN_ENUM_LOADED     (0x00000004) // Has Register_Enumerator
#define DN_STARTED         (0x00000008) // Is currently configured
#define DN_MANUAL          (0x00000010) // Manually installed
#define DN_NEED_TO_ENUM    (0x00000020) // May need reenumeration
#define DN_NOT_FIRST_TIME  (0x00000040) // Has received a config
#define DN_HARDWARE_ENUM   (0x00000080) // Enum generates hardware ID
#define DN_LIAR            (0x00000100) // Lied about can reconfig once
#define DN_HAS_MARK        (0x00000200) // Not CM_Create_DevInst lately
#define DN_HAS_PROBLEM     (0x00000400) // Need device installer
#define DN_FILTERED        (0x00000800) // Is filtered
#define DN_MOVED           (0x00001000) // Has been moved
#define DN_DISABLEABLE     (0x00002000) // Can be rebalanced
#define DN_REMOVABLE       (0x00004000) // Can be removed
#define DN_PRIVATE_PROBLEM (0x00008000) // Has a private problem
#define DN_MF_PARENT       (0x00010000) // Multi function parent
#define DN_MF_CHILD        (0x00020000) // Multi function child
#define DN_WILL_BE_REMOVED (0x00040000) // DevInst is being removed

//
// Windows 4 OPK2 Flags
//
#define DN_NOT_FIRST_TIMEE  0x00080000  // S: Has received a config enumerate
#define DN_STOP_FREE_RES    0x00100000  // S: When child is stopped, free resources
#define DN_REBAL_CANDIDATE  0x00200000  // S: Don't skip during rebalance
#define DN_BAD_PARTIAL      0x00400000  // S: This devnode's log_confs do not have same resources
#define DN_NT_ENUMERATOR    0x00800000  // S: This devnode's is an NT enumerator
#define DN_NT_DRIVER        0x01000000  // S: This devnode's is an NT driver
//
// Windows 4.1 Flags
//
#define DN_NEEDS_LOCKING    0x02000000  // S: Devnode need lock resume processing
#define DN_ARM_WAKEUP       0x04000000  // S: Devnode can be the wakeup device
#define DN_APM_ENUMERATOR   0x08000000  // S: APM aware enumerator
#define DN_APM_DRIVER       0x10000000  // S: APM aware driver
#define DN_SILENT_INSTALL   0x20000000  // S: Silent install
#define DN_NO_SHOW_IN_DM    0x40000000  // S: No show in device manager
#define DN_BOOT_LOG_PROB    0x80000000  // S: Had a problem during preassignment of boot log conf

//
// Windows NT Flags
//
// These are overloaded on top of unused Win 9X flags
//
//#define DN_LIAR               (0x00000100)        // Lied about can reconfig once
#define DN_NEED_RESTART         DN_LIAR             // System needs to be restarted for this Devnode to work properly
// #define DN_NOT_FIRST_TIME    (0x00000040)        // Has Register_Enumerator
#define DN_DRIVER_BLOCKED       DN_NOT_FIRST_TIME   // One or more drivers are blocked from loading for this Devnode
//#define DN_MOVED              (0x00001000)        // Has been moved
#define DN_LEGACY_DRIVER        DN_MOVED            // This device is using a legacy driver
//#define DN_HAS_MARK                   (0x00000200)            // Not CM_Create_DevInst lately
#define DN_CHILD_WITH_INVALID_ID        DN_HAS_MARK             // One or more children have invalid ID(s)

#define DN_CHANGEABLE_FLAGS (DN_NOT_FIRST_TIME+\
                DN_HARDWARE_ENUM+\
                DN_HAS_MARK+\
                DN_DISABLEABLE+\
                DN_REMOVABLE+\
                DN_MF_CHILD+\
                DN_MF_PARENT+\
                DN_NOT_FIRST_TIMEE+\
                DN_STOP_FREE_RES+\
                DN_REBAL_CANDIDATE+\
                DN_NT_ENUMERATOR+\
                DN_NT_DRIVER+\
                DN_SILENT_INSTALL+\
                DN_NO_SHOW_IN_DM)

//
// Logical configuration Priority values
//
// These priority values are used in user-mode calls to CM_Add_Empty_Log_Conf.
// Drivers may also specify priority values for a given IO_RESOURCE_LIST
// structure by including a ConfigData member union as the first
// IO_RESOURCE_DESCRIPTOR in the IO_RESOURCE_LIST. In this case, the descriptor
// type would be CmResourceTypeConfigData.
//
#define LCPRI_FORCECONFIG     (0x00000000) // Coming from a forced config
#define LCPRI_BOOTCONFIG      (0x00000001) // Coming from a boot config
#define LCPRI_DESIRED         (0x00002000) // Preferable (better performance)
#define LCPRI_NORMAL          (0x00003000) // Workable (acceptable performance)
#define LCPRI_LASTBESTCONFIG  (0x00003FFF) // CM only--do not use
#define LCPRI_SUBOPTIMAL      (0x00005000) // Not desired, but will work
#define LCPRI_LASTSOFTCONFIG  (0x00007FFF) // CM only--do not use
#define LCPRI_RESTART         (0x00008000) // Need to restart
#define LCPRI_REBOOT          (0x00009000) // Need to reboot
#define LCPRI_POWEROFF        (0x0000A000) // Need to shutdown/power-off
#define LCPRI_HARDRECONFIG    (0x0000C000) // Need to change a jumper
#define LCPRI_HARDWIRED       (0x0000E000) // Cannot be changed
#define LCPRI_IMPOSSIBLE      (0x0000F000) // Impossible configuration
#define LCPRI_DISABLED        (0x0000FFFF) // Disabled configuration
#define MAX_LCPRI             (0x0000FFFF) // Maximum known LC Priority

#endif // _CFG_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\ddk\inc\atm.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

	atm.h

Abstract:

	This module defines the structures, macros, and manifests available
	to ATM aware components.

Author:

	NDIS/ATM Development Team
	

Revision History:

	Initial Version - March 1996

--*/

#ifndef	_ATM_H_
#define	_ATM_H_

//
// Address type
//
typedef ULONG	ATM_ADDRESSTYPE;

#define	ATM_NSAP				0
#define	ATM_E164				1

//
// ATM Address
//
#define	ATM_MAC_ADDRESS_LENGTH	6		// Same as 802.x
#define	ATM_ADDRESS_LENGTH		20

//
//  Special characters in ATM address string used in textual representations
//
#define ATM_ADDR_BLANK_CHAR				L' '
#define ATM_ADDR_PUNCTUATION_CHAR		L'.'
#define ATM_ADDR_E164_START_CHAR		L'+'

typedef struct _ATM_ADDRESS
{
	ATM_ADDRESSTYPE				AddressType;
	ULONG						NumberOfDigits;
	UCHAR						Address[ATM_ADDRESS_LENGTH];
} ATM_ADDRESS, *PATM_ADDRESS;



//
// AAL types that the miniport supports
//
#define	AAL_TYPE_AAL0			1
#define	AAL_TYPE_AAL1			2
#define	AAL_TYPE_AAL34			4
#define	AAL_TYPE_AAL5			8

typedef ULONG	ATM_AAL_TYPE, *PATM_AAL_TYPE;


//
// Types of Information Elements
//
typedef enum
{
	IE_AALParameters,
	IE_TrafficDescriptor,
	IE_BroadbandBearerCapability,
	IE_BHLI,
	IE_BLLI,
	IE_CalledPartyNumber,
	IE_CalledPartySubaddress,
	IE_CallingPartyNumber,
	IE_CallingPartySubaddress,
	IE_Cause,
	IE_QOSClass,
	IE_TransitNetworkSelection,
	IE_BroadbandSendingComplete,
	IE_LIJCallId,
	IE_Raw
} Q2931_IE_TYPE;


//
// Common header for each Information Element
//
typedef struct _Q2931_IE
{
	Q2931_IE_TYPE				IEType;
	ULONG						IELength;	// Bytes, including IEType and IELength fields
	UCHAR						IE[1];
} Q2931_IE, *PQ2931_IE;


//
// Definitions for SapType in CO_SAP
//
#define SAP_TYPE_NSAP			0x00000001
#define SAP_TYPE_E164			0x00000002

//
// Values used for the Mode field in AAL5_PARAMETERS
//
#define AAL5_MODE_MESSAGE			0x01
#define AAL5_MODE_STREAMING			0x02

//
// Values used for the SSCSType field in AAL5_PARAMETERS
//
#define AAL5_SSCS_NULL				0x00
#define AAL5_SSCS_SSCOP_ASSURED		0x01
#define AAL5_SSCS_SSCOP_NON_ASSURED	0x02
#define AAL5_SSCS_FRAME_RELAY		0x04


//
// AAL Parameters
//
typedef struct _AAL1_PARAMETERS
{
	UCHAR						Subtype;
	UCHAR						CBRRate;
	USHORT						Multiplier;
	UCHAR						SourceClockRecoveryMethod;
	UCHAR						ErrorCorrectionMethod;
	USHORT						StructuredDataTransferBlocksize;
	UCHAR						PartiallyFilledCellsMethod;
} AAL1_PARAMETERS, *PAAL1_PARAMETERS;

typedef struct _AAL34_PARAMETERS
{
	USHORT						ForwardMaxCPCSSDUSize;
	USHORT						BackwardMaxCPCSSDUSize;
	USHORT						LowestMID;
	USHORT						HighestMID;
	UCHAR						SSCSType;
} AAL34_PARAMETERS, *PAAL34_PARAMETERS;

typedef struct _AAL5_PARAMETERS
{
	ULONG						ForwardMaxCPCSSDUSize;
	ULONG						BackwardMaxCPCSSDUSize;
	UCHAR						Mode;
	UCHAR						SSCSType;
} AAL5_PARAMETERS, *PAAL5_PARAMETERS;

typedef struct _AALUSER_PARAMETERS
{
	ULONG						UserDefined;
} AALUSER_PARAMETERS, *PAALUSER_PARAMETERS;

typedef struct _AAL_PARAMETERS_IE
{
	ATM_AAL_TYPE				AALType;
	union
	{
		AAL1_PARAMETERS			AAL1Parameters;
		AAL34_PARAMETERS		AAL34Parameters;
		AAL5_PARAMETERS			AAL5Parameters;
		AALUSER_PARAMETERS		AALUserParameters;
	} AALSpecificParameters;

} AAL_PARAMETERS_IE, *PAAL_PARAMETERS_IE;

//
// ATM Traffic Descriptor
//
typedef struct _ATM_TRAFFIC_DESCRIPTOR	// For one direction
{
	ULONG						PeakCellRateCLP0;
	ULONG						PeakCellRateCLP01;
	ULONG						SustainableCellRateCLP0;
	ULONG						SustainableCellRateCLP01;
	ULONG						MaximumBurstSizeCLP0;
	ULONG						MaximumBurstSizeCLP01;
	BOOLEAN						Tagging;
} ATM_TRAFFIC_DESCRIPTOR, *PATM_TRAFFIC_DESCRIPTOR;


typedef struct _ATM_TRAFFIC_DESCRIPTOR_IE
{
	ATM_TRAFFIC_DESCRIPTOR		ForwardTD;
	ATM_TRAFFIC_DESCRIPTOR		BackwardTD;
	BOOLEAN						BestEffort;
} ATM_TRAFFIC_DESCRIPTOR_IE, *PATM_TRAFFIC_DESCRIPTOR_IE;


//
// values used for the BearerClass field in the Broadband Bearer Capability IE
//


#define BCOB_A					0x00	// Bearer class A
#define BCOB_C					0x01	// Bearer class C
#define BCOB_X					0x02	// Bearer class X

//
// values used for the TrafficType field in the Broadband Bearer Capability IE
//
#define TT_NOIND				0x00	// No indication of traffic type
#define TT_CBR					0x04	// Constant bit rate
#define TT_VBR					0x08	// Variable bit rate

//
// values used for the TimingRequirements field in the Broadband Bearer Capability IE
//
#define TR_NOIND				0x00	// No timing requirement indication
#define TR_END_TO_END			0x01	// End-to-end timing required
#define TR_NO_END_TO_END		0x02	// End-to-end timing not required

//
// values used for the ClippingSusceptability field in the Broadband Bearer Capability IE
//
#define CLIP_NOT				0x00	// Not susceptible to clipping
#define CLIP_SUS				0x20	// Susceptible to clipping

//
// values used for the UserPlaneConnectionConfig field in
// the Broadband Bearer Capability IE
//
#define UP_P2P					0x00	// Point-to-point connection
#define UP_P2MP					0x01	// Point-to-multipoint connection

//
// Broadband Bearer Capability
//
typedef struct _ATM_BROADBAND_BEARER_CAPABILITY_IE
{
	UCHAR			BearerClass;
	UCHAR			TrafficType;
	UCHAR			TimingRequirements;
	UCHAR			ClippingSusceptability;
	UCHAR			UserPlaneConnectionConfig;
} ATM_BROADBAND_BEARER_CAPABILITY_IE, *PATM_BROADBAND_BEARER_CAPABILITY_IE;

//
// values used for the HighLayerInfoType field in ATM_BHLI
//
#define BHLI_ISO				0x00	// ISO
#define BHLI_UserSpecific		0x01	// User Specific
#define BHLI_HighLayerProfile	0x02	// High layer profile (only in UNI3.0)
#define BHLI_VendorSpecificAppId 0x03	// Vendor-Specific Application ID

//
// Broadband High layer Information
//
typedef struct _ATM_BHLI_IE
{
	ULONG			HighLayerInfoType;		// High Layer Information Type
	ULONG			HighLayerInfoLength;	// number of bytes in HighLayerInfo
	UCHAR			HighLayerInfo[8];		// The value dependent on the
											// HighLayerInfoType field
} ATM_BHLI_IE, *PATM_BHLI_IE;

//
// values used for Layer2Protocol in B-LLI
//
#define BLLI_L2_ISO_1745		0x01	// Basic mode ISO 1745
#define BLLI_L2_Q921			0x02	// CCITT Rec. Q.921
#define BLLI_L2_X25L			0x06	// CCITT Rec. X.25, link layer
#define BLLI_L2_X25M			0x07	// CCITT Rec. X.25, multilink
#define BLLI_L2_ELAPB			0x08	// Extended LAPB; for half duplex operation
#define BLLI_L2_HDLC_ARM		0x09	// HDLC ARM (ISO 4335)
#define BLLI_L2_HDLC_NRM		0x0A	// HDLC NRM (ISO 4335)
#define BLLI_L2_HDLC_ABM		0x0B	// HDLC ABM (ISO 4335)
#define BLLI_L2_LLC				0x0C	// LAN logical link control (ISO 8802/2)
#define BLLI_L2_X75				0x0D	// CCITT Rec. X.75, single link procedure
#define BLLI_L2_Q922			0x0E	// CCITT Rec. Q.922
#define BLLI_L2_USER_SPECIFIED	0x10	// User Specified
#define BLLI_L2_ISO_7776		0x11	// ISO 7776 DTE-DTE operation

//
// values used for Layer3Protocol in B-LLI
//
#define BLLI_L3_X25				0x06	// CCITT Rec. X.25, packet layer
#define BLLI_L3_ISO_8208		0x07	// ISO/IEC 8208 (X.25 packet layer for DTE
#define BLLI_L3_X223			0x08	// X.223/ISO 8878
#define BLLI_L3_SIO_8473		0x09	// ISO/IEC 8473 (OSI connectionless)
#define BLLI_L3_T70				0x0A	// CCITT Rec. T.70 min. network layer
#define BLLI_L3_ISO_TR9577		0x0B	// ISO/IEC TR 9577 Network Layer Protocol ID
#define BLLI_L3_USER_SPECIFIED	0x10	// User Specified

//
// values used for Layer3IPI in struct B-LLI
//
#define BLLI_L3_IPI_SNAP		0x80	// IEEE 802.1 SNAP identifier
#define BLLI_L3_IPI_IP			0xCC	// Internet Protocol (IP) identifier

//
// Broadband Lower Layer Information
//
typedef struct _ATM_BLLI_IE
{
	ULONG						Layer2Protocol;
	UCHAR						Layer2Mode;
	UCHAR						Layer2WindowSize;
	ULONG						Layer2UserSpecifiedProtocol;
	ULONG						Layer3Protocol;
	UCHAR						Layer3Mode;
	UCHAR						Layer3DefaultPacketSize;
	UCHAR						Layer3PacketWindowSize;
	ULONG						Layer3UserSpecifiedProtocol;
	ULONG						Layer3IPI;
	UCHAR						SnapId[5];
} ATM_BLLI_IE, *PATM_BLLI_IE;


//
// Called Party Number
//
// If present, this IE overrides the Called Address specified in
// the main parameter block.
//
typedef ATM_ADDRESS	ATM_CALLED_PARTY_NUMBER_IE;


//
// Called Party Subaddress
//
typedef ATM_ADDRESS	ATM_CALLED_PARTY_SUBADDRESS_IE;



//
// Calling Party Number
//
typedef struct _ATM_CALLING_PARTY_NUMBER_IE
{
	ATM_ADDRESS					Number;
	UCHAR						PresentationIndication;
	UCHAR						ScreeningIndicator;
} ATM_CALLING_PARTY_NUMBER_IE, *PATM_CALLING_PARTY_NUMBER_IE;


//
// Calling Party Subaddress
//
typedef ATM_ADDRESS	ATM_CALLING_PARTY_SUBADDRESS_IE;


//
// Values used for the QOSClassForward and QOSClassBackward
// fields in ATM_QOS_CLASS_IE
//
#define QOS_CLASS0				0x00
#define QOS_CLASS1				0x01
#define QOS_CLASS2				0x02
#define QOS_CLASS3				0x03
#define QOS_CLASS4				0x04

//
// QOS Class
//
typedef struct _ATM_QOS_CLASS_IE
{
	UCHAR						QOSClassForward;
	UCHAR						QOSClassBackward;
} ATM_QOS_CLASS_IE, *PATM_QOS_CLASS_IE;

//
// Broadband Sending Complete
//
typedef struct _ATM_BROADBAND_SENDING_COMPLETE_IE
{
	UCHAR						SendingComplete;
} ATM_BROADBAND_SENDING_COMPLETE_IE, *PATM_BROADBAND_SENDING_COMPLETE_IE;


//
// Values used for the TypeOfNetworkId field in ATM_TRANSIT_NETWORK_SELECTION_IE
//
#define TNS_TYPE_NATIONAL			0x40

//
// Values used for the NetworkIdPlan field in ATM_TRANSIT_NETWORK_SELECTION_IE
//
#define TNS_PLAN_CARRIER_ID_CODE	0x01

//
// Transit Network Selection
//
typedef struct _ATM_TRANSIT_NETWORK_SELECTION_IE
{
	UCHAR						TypeOfNetworkId;
	UCHAR						NetworkIdPlan;
	UCHAR						NetworkIdLength;
	UCHAR						NetworkId[1];
} ATM_TRANSIT_NETWORK_SELECTION_IE, *PATM_TRANSIT_NETWORK_SELECTION_IE;


// 
// Values used for the Location field in struct ATM_CAUSE_IE
//
#define ATM_CAUSE_LOC_USER							0x00
#define ATM_CAUSE_LOC_PRIVATE_LOCAL					0x01
#define ATM_CAUSE_LOC_PUBLIC_LOCAL					0x02
#define ATM_CAUSE_LOC_TRANSIT_NETWORK				0x03
#define ATM_CAUSE_LOC_PUBLIC_REMOTE					0x04
#define ATM_CAUSE_LOC_PRIVATE_REMOTE				0x05
#define ATM_CAUSE_LOC_INTERNATIONAL_NETWORK			0x07
#define ATM_CAUSE_LOC_BEYOND_INTERWORKING			0x0A

// 
// Values used for the Cause field in struct ATM_CAUSE_IE
//
#define ATM_CAUSE_UNALLOCATED_NUMBER				0x01
#define ATM_CAUSE_NO_ROUTE_TO_TRANSIT_NETWORK		0x02
#define ATM_CAUSE_NO_ROUTE_TO_DESTINATION			0x03
#define ATM_CAUSE_VPI_VCI_UNACCEPTABLE				0x0A
#define ATM_CAUSE_NORMAL_CALL_CLEARING				0x10
#define ATM_CAUSE_USER_BUSY							0x11
#define ATM_CAUSE_NO_USER_RESPONDING				0x12
#define ATM_CAUSE_CALL_REJECTED						0x15
#define ATM_CAUSE_NUMBER_CHANGED					0x16
#define ATM_CAUSE_USER_REJECTS_CLIR					0x17
#define ATM_CAUSE_DESTINATION_OUT_OF_ORDER			0x1B
#define ATM_CAUSE_INVALID_NUMBER_FORMAT				0x1C
#define ATM_CAUSE_STATUS_ENQUIRY_RESPONSE			0x1E
#define ATM_CAUSE_NORMAL_UNSPECIFIED				0x1F
#define ATM_CAUSE_VPI_VCI_UNAVAILABLE				0x23
#define ATM_CAUSE_NETWORK_OUT_OF_ORDER				0x26
#define ATM_CAUSE_TEMPORARY_FAILURE					0x29
#define ATM_CAUSE_ACCESS_INFORMAION_DISCARDED		0x2B
#define ATM_CAUSE_NO_VPI_VCI_AVAILABLE				0x2D
#define ATM_CAUSE_RESOURCE_UNAVAILABLE				0x2F
#define ATM_CAUSE_QOS_UNAVAILABLE					0x31
#define ATM_CAUSE_USER_CELL_RATE_UNAVAILABLE		0x33
#define ATM_CAUSE_BEARER_CAPABILITY_UNAUTHORIZED	0x39
#define ATM_CAUSE_BEARER_CAPABILITY_UNAVAILABLE		0x3A
#define ATM_CAUSE_OPTION_UNAVAILABLE				0x3F
#define ATM_CAUSE_BEARER_CAPABILITY_UNIMPLEMENTED	0x41
#define ATM_CAUSE_UNSUPPORTED_TRAFFIC_PARAMETERS	0x49
#define ATM_CAUSE_INVALID_CALL_REFERENCE			0x51
#define ATM_CAUSE_CHANNEL_NONEXISTENT				0x52
#define ATM_CAUSE_INCOMPATIBLE_DESTINATION			0x58
#define ATM_CAUSE_INVALID_ENDPOINT_REFERENCE		0x59
#define ATM_CAUSE_INVALID_TRANSIT_NETWORK_SELECTION	0x5B
#define ATM_CAUSE_TOO_MANY_PENDING_ADD_PARTY		0x5C
#define ATM_CAUSE_AAL_PARAMETERS_UNSUPPORTED		0x5D
#define ATM_CAUSE_MANDATORY_IE_MISSING				0x60
#define ATM_CAUSE_UNIMPLEMENTED_MESSAGE_TYPE		0x61
#define ATM_CAUSE_UNIMPLEMENTED_IE					0x63
#define ATM_CAUSE_INVALID_IE_CONTENTS				0x64
#define ATM_CAUSE_INVALID_STATE_FOR_MESSAGE			0x65
#define ATM_CAUSE_RECOVERY_ON_TIMEOUT				0x66
#define ATM_CAUSE_INCORRECT_MESSAGE_LENGTH			0x68
#define ATM_CAUSE_PROTOCOL_ERROR					0x6F

//
// Values used for the Condition portion of the Diagnostics field
// in struct ATM_CAUSE_IE, for certain Cause values
//
#define ATM_CAUSE_COND_UNKNOWN						0x00
#define ATM_CAUSE_COND_PERMANENT					0x01
#define ATM_CAUSE_COND_TRANSIENT					0x02

//
// Values used for the Rejection Reason portion of the Diagnostics field
// in struct ATM_CAUSE_IE, for certain Cause values
//
#define ATM_CAUSE_REASON_USER						0x00
#define ATM_CAUSE_REASON_IE_MISSING					0x04
#define ATM_CAUSE_REASON_IE_INSUFFICIENT			0x08

//
// Values used for the P-U flag of the Diagnostics field
// in struct ATM_CAUSE_IE, for certain Cause values
//
#define ATM_CAUSE_PU_PROVIDER						0x00
#define ATM_CAUSE_PU_USER							0x08

//
// Values used for the N-A flag of the Diagnostics field
// in struct ATM_CAUSE_IE, for certain Cause values
//
#define ATM_CAUSE_NA_NORMAL							0x00
#define ATM_CAUSE_NA_ABNORMAL						0x04

//
// Cause
//
typedef struct _ATM_CAUSE_IE
{
	UCHAR						Location;
	UCHAR						Cause;
	UCHAR						DiagnosticsLength;
	UCHAR						Diagnostics[4];
} ATM_CAUSE_IE, *PATM_CAUSE_IE;


//
// Leaf Initiated Join (LIJ) Identifier
//
typedef struct _ATM_LIJ_CALLID_IE
{
	ULONG						Identifier;
} ATM_LIJ_CALLID_IE, *PATM_LIJ_CALLID_IE;


//
// Raw Information Element - the user can fill in whatever he wants
//
typedef struct _ATM_RAW_IE
{
	ULONG						RawIELength;
	ULONG						RawIEType;
	UCHAR						RawIEValue[1];
} ATM_RAW_IE, *PATM_RAW_IE;


//
// This is the value of the ParamType field in the CO_SPECIFIC_PARAMETERS structure
// when the Parameters[] field contains ATM media specific values in the structure
// ATM_MEDIA_PARAMETERS.
//
#define ATM_MEDIA_SPECIFIC		0x00000001

//
// The Q2931 Call Manager Specific parameters that goes into the
// CallMgrParameters->CallMgrSpecific.Parameters
//
typedef struct _Q2931_CALLMGR_PARAMETERS
{
	ATM_ADDRESS					CalledParty;
	ATM_ADDRESS					CallingParty;
	ULONG						InfoElementCount;
	UCHAR						InfoElements[1];	// one or more info elements
} Q2931_CALLMGR_PARAMETERS, *PQ2931_CALLMGR_PARAMETERS;


//
// This is the specific portion of either the Media parameters or the CallMgr
// Parameters. The following two defines are used in the ParamType field
// depending on the signaling type.
//
#define CALLMGR_SPECIFIC_Q2931	0x00000001

typedef struct _ATM_VPIVCI
{
	ULONG						Vpi;
	ULONG						Vci;
} ATM_VPIVCI, *PATM_VPIVCI;

//
// ATM Service Category
//
#define	ATM_SERVICE_CATEGORY_CBR	1	// Constant Bit Rate
#define	ATM_SERVICE_CATEGORY_VBR	2	// Variable Bit Rate
#define	ATM_SERVICE_CATEGORY_UBR	4	// Unspecified Bit Rate
#define	ATM_SERVICE_CATEGORY_ABR	8	// Available Bit Rate

typedef ULONG	ATM_SERVICE_CATEGORY, *PATM_SERVICE_CATEGORY;


//
// ATM flow parameters for use in specifying Media parameters
//
typedef struct _ATM_FLOW_PARAMETERS
{
	ATM_SERVICE_CATEGORY		ServiceCategory;
	ULONG						AverageCellRate;			// in cells/sec
	ULONG						PeakCellRate;				// in cells/sec
	ULONG						MinimumCellRate;			// in cells/sec (ABR MCR)
	ULONG						InitialCellRate;			// in cells/sec (ABR ICR)
	ULONG						BurstLengthCells;			// in cells
	ULONG						MaxSduSize;					// MTU in bytes
	ULONG						TransientBufferExposure;	// in cells (ABR TBE)
	ULONG						CumulativeRMFixedRTT;		// in microseconds (ABR FRTT)
	UCHAR						RateIncreaseFactor;			// UNI 4.0 coding (ABR RIF)
	UCHAR						RateDecreaseFactor;			// UNI 4.0 coding (ABR RDF)
	USHORT						ACRDecreaseTimeFactor;		// UNI 4.0 coding (ABR ADTF)
	UCHAR						MaximumCellsPerForwardRMCell; // UNI 4.0 coding (ABR Nrm)
	UCHAR						MaximumForwardRMCellInterval; // UNI 4.0 coding (ABR Trm)
	UCHAR						CutoffDecreaseFactor;		// UNI 4.0 coding (ABR CDF)
	UCHAR						Reserved1;					// padding
	ULONG						MissingRMCellCount;			// (ABR CRM)
	ULONG						Reserved2;
	ULONG						Reserved3;
} ATM_FLOW_PARAMETERS, *PATM_FLOW_PARAMETERS;




//
// ATM Specific Media parameters - this is the Media specific structure for ATM
// that goes into MediaParameters->MediaSpecific.Parameters.
//
typedef struct _ATM_MEDIA_PARAMETERS
{
	ATM_VPIVCI					ConnectionId;
	ATM_AAL_TYPE				AALType;
	ULONG						CellDelayVariationCLP0;
	ULONG						CellDelayVariationCLP1;
	ULONG						CellLossRatioCLP0;
	ULONG						CellLossRatioCLP1;
	ULONG						CellTransferDelayCLP0;
	ULONG						CellTransferDelayCLP1;
	ULONG						DefaultCLP;
	ATM_FLOW_PARAMETERS			Transmit;
	ATM_FLOW_PARAMETERS			Receive;
} ATM_MEDIA_PARAMETERS, *PATM_MEDIA_PARAMETERS;


//  Bit 0 in Reserved1 in ATM_FLOW_PARAMETERS is reserved.
#define ATM_FLOW_PARAMS_RSVD1_MPP	0x01

#ifndef SAP_FIELD_ABSENT
#define SAP_FIELD_ABSENT		((ULONG)0xfffffffe)
#endif

#ifndef SAP_FIELD_ANY
#define SAP_FIELD_ANY			((ULONG)0xffffffff)
#endif

#define SAP_FIELD_ANY_AESA_SEL	((ULONG)0xfffffffa)	// SEL is wild-carded
#define SAP_FIELD_ANY_AESA_REST	((ULONG)0xfffffffb)	// All of the address
													// except SEL, is wild-carded

//
// The ATM Specific SAP definition
//
typedef struct _ATM_SAP
{
	ATM_BLLI_IE					Blli;
	ATM_BHLI_IE					Bhli;
	ULONG						NumberOfAddresses;
	UCHAR						Addresses[1];	// each of type ATM_ADDRESS
} ATM_SAP, *PATM_SAP;

//
// The ATM Specific SAP definition when adding PVCs
//
typedef struct _ATM_PVC_SAP
{
	ATM_BLLI_IE					Blli;
	ATM_BHLI_IE					Bhli;
} ATM_PVC_SAP, *PATM_PVC_SAP;

//
// The structure passed in the Parameters field of the CO_SPECIFIC_PARAMETERS
// structure passed in an ADD PVC request for Q.2931
//
typedef struct _Q2931_ADD_PVC
{
	ATM_ADDRESS					CalledParty;
	ATM_ADDRESS					CallingParty;
	ATM_VPIVCI					ConnectionId;
	ATM_AAL_TYPE				AALType;
	ATM_FLOW_PARAMETERS			ForwardFP;
	ATM_FLOW_PARAMETERS			BackwardFP;
	ULONG						Flags;
	ATM_PVC_SAP					LocalSap;
	ATM_PVC_SAP					DestinationSap;
	BOOLEAN						LIJIdPresent;
	ATM_LIJ_CALLID_IE			LIJId;
} Q2931_ADD_PVC, *PQ2931_ADD_PVC;

//
// These flags are defined to be used with Q2931_ADD_PVC above
//
// this VC should be used by the CallMgr as the signaling VC now
#define CO_FLAG_SIGNALING_VC	0x00000001

//
// Use this flag for a PVC that cannot be used for a MakeCall - incoming call only
// the call mgr can then be optimized not to search these PVCs during make call
// processing.
#define CO_FLAG_NO_DEST_SAP		0x00000002

//
//  Use this flag for a PVC that cannot be used to indicate an incoming call.
//
#define CO_FLAG_NO_LOCAL_SAP	0x00000004

//
// the structure passed in the Parameters field of the CO_SPECIFIC_PARAMETERS
// structure passed in an NDIS_CO_PVC request for Q2931
//
typedef struct _Q2931_DELETE_PVC
{
	ATM_VPIVCI					ConnectionId;
} Q2931_DELETE_PVC, *PQ2931_DELETE_PVC;

typedef struct _CO_GET_CALL_INFORMATION
{
	ULONG						CallInfoType;
	ULONG						CallInfoLength;
	PVOID						CallInfoBuffer;
} CO_GET_CALL_INFORMATION, *PCO_GET_CALL_INFORMATION;

//
// the structure for returning the supported VC rates from the miniport,
// returned in response to OID_ATM_SUPPORTED_VC_RATES
//
typedef struct _ATM_VC_RATES_SUPPORTED
{
	ULONG						MinCellRate;
	ULONG						MaxCellRate;
} ATM_VC_RATES_SUPPORTED, *PATM_VC_RATES_SUPPORTED;

//
//	NDIS_PACKET out of band information for ATM.
//
typedef struct _ATM_AAL_OOB_INFO
{
	ATM_AAL_TYPE		AalType;
	union
	{
		struct _ATM_AAL5_INFO
		{
			BOOLEAN		CellLossPriority;
			UCHAR		UserToUserIndication;
			UCHAR		CommonPartIndicator;
		} ATM_AAL5_INFO;

		struct _ATM_AAL0_INFO
		{
			BOOLEAN		CellLossPriority;
			UCHAR		PayLoadTypeIdentifier;
		} ATM_AAL0_INFO;
	};
} ATM_AAL_OOB_INFO, *PATM_AAL_OOB_INFO;


//
//  Physical Line Speeds in bits/sec.
//
#define ATM_PHYS_RATE_SONET_STS3C						155520000
#define ATM_PHYS_RATE_IBM_25						 	 25600000

//
//  ATM cell layer transfer capacities in bits/sec. This is the throughput
//  available for ATM cells, after allowing for physical framing overhead.
//
#define ATM_CELL_TRANSFER_CAPACITY_SONET_STS3C			149760000
#define ATM_CELL_TRANSFER_CAPACITY_IBM_25			 	 25125926



//
//  User data rate in units of 100 bits/sec. This is returned in response to
//  the OID_GEN_CO_LINK_SPEED query. This is the effective rate of
//  transfer of data available to the ATM layer user, after allowing for
//  the ATM cell header.
//
#define ATM_USER_DATA_RATE_SONET_155					  1356317
#define ATM_USER_DATA_RATE_IBM_25			               227556



//
//  The ATM Service Registry MIB Table is used to locate ATM network
//  services. OID_ATM_GET_SERVICE_ADDRESS is used by clients to access
//  this table.
//

typedef ULONG		ATM_SERVICE_REGISTRY_TYPE;

#define ATM_SERVICE_REGISTRY_LECS		1	// LAN Emulation Configuration Server
#define ATM_SERVICE_REGISTRY_ANS		2	// ATM Name Server

//
//  Structure passed to OID_ATM_GET_SERVICE_ADDRESS.
//
typedef struct _ATM_SERVICE_ADDRESS_LIST
{
	ATM_SERVICE_REGISTRY_TYPE	ServiceRegistryType;
	ULONG						NumberOfAddressesAvailable;
	ULONG						NumberOfAddressesReturned;
	ATM_ADDRESS					Address[1];
} ATM_SERVICE_ADDRESS_LIST, *PATM_SERVICE_ADDRESS_LIST;

#endif	//	_ATM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\ddk\inc\cfgmgr32.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    cfgmgr32.h

Abstract:

    This module contains the user APIs for the Configuration Manager,
    along with any public data structures needed to call these APIs.

--*/

#ifndef _CFGMGR32_H_
#define _CFGMGR32_H_

#if _MSC_VER > 1000
#pragma once
#endif

#include <cfg.h>

#ifndef GUID_DEFINED
#include <guiddef.h>
#endif /* GUID_DEFINED */

#ifdef __cplusplus
extern "C" {
#endif

#if !defined (_CFGMGR32_)
#define CMAPI     DECLSPEC_IMPORT
#else
#define CMAPI
#endif

typedef  CONST VOID *PCVOID;



//--------------------------------------------------------------
// General size definitions
//--------------------------------------------------------------

#define MAX_DEVICE_ID_LEN     200
#define MAX_DEVNODE_ID_LEN    MAX_DEVICE_ID_LEN

#define MAX_GUID_STRING_LEN   39          // 38 chars + terminator null
#define MAX_CLASS_NAME_LEN    32
#define MAX_PROFILE_LEN       80

#define MAX_CONFIG_VALUE      9999
#define MAX_INSTANCE_VALUE    9999

#define MAX_MEM_REGISTERS     9     // Win95 compatibility--not applicable to 32-bit ConfigMgr
#define MAX_IO_PORTS          20    // Win95 compatibility--not applicable to 32-bit ConfigMgr
#define MAX_IRQS              7     // Win95 compatibility--not applicable to 32-bit ConfigMgr
#define MAX_DMA_CHANNELS      7     // Win95 compatibility--not applicable to 32-bit ConfigMgr

#define DWORD_MAX             0xFFFFFFFF
#define DWORDLONG_MAX         0xFFFFFFFFFFFFFFFF

#define CONFIGMG_VERSION      0x0400


//--------------------------------------------------------------
// Data types
//--------------------------------------------------------------


//
// Work around weirdness with Win32 typedef...
//
#ifdef NT_INCLUDED

//
// __int64 is only supported by 2.0 and later midl.
// __midl is set by the 2.0 midl and not by 1.0 midl.
//
#if (!defined(MIDL_PASS) || defined(__midl)) && (!defined(_M_IX86) || (defined(_INTEGRAL_MAX_BITS) && _INTEGRAL_MAX_BITS >= 64))
typedef unsigned __int64 DWORDLONG;
#else
typedef double DWORDLONG;
#endif
typedef DWORDLONG *PDWORDLONG;

#endif /* NT_INCLUDED */


//
// Standardized Return Value data type
//
typedef DWORD        RETURN_TYPE;
typedef RETURN_TYPE  CONFIGRET;

//
// Device Instance Handle data type
//
typedef DWORD       DEVNODE, DEVINST;
typedef DEVNODE    *PDEVNODE, *PDEVINST;

//
// Device Instance Identifier data type
// The device instance ID specifies the registry path, relative to the
// Enum key , for a device instance.  For example:  \Root\*PNP0500\0000.
//
typedef CHAR          *DEVNODEID_A, *DEVINSTID_A; // Device ID ANSI name.
typedef WCHAR         *DEVNODEID_W, *DEVINSTID_W; // Device ID Unicode name.
#ifdef UNICODE
typedef DEVNODEID_W DEVNODEID;
typedef DEVINSTID_W DEVINSTID;
#else
typedef DEVNODEID_A DEVNODEID;
typedef DEVINSTID_A DEVINSTID;
#endif

//
// Logical Configuration Handle data type
//
typedef DWORD_PTR    LOG_CONF;
typedef LOG_CONF    *PLOG_CONF;

//
// Resource Descriptor Handle data type
//
typedef DWORD_PTR    RES_DES;
typedef RES_DES     *PRES_DES;

//
// Resource ID data type (may take any of the ResType_* values)
//
typedef ULONG        RESOURCEID;
typedef RESOURCEID  *PRESOURCEID;

//
// Priority data type (may take any of the LCPRI_* values)
//
typedef ULONG        PRIORITY;
typedef PRIORITY     *PPRIORITY;

//
// Range List Handle data type
//
typedef DWORD_PTR          RANGE_LIST;
typedef RANGE_LIST        *PRANGE_LIST;

//
// Range Element Handle data type
//
typedef DWORD_PTR          RANGE_ELEMENT;
typedef RANGE_ELEMENT     *PRANGE_ELEMENT;

//
// Machine Handle data type
//
typedef  HANDLE             HMACHINE;
typedef  HMACHINE          *PHMACHINE;

//
// Conflict List data types
//
typedef ULONG_PTR           CONFLICT_LIST;
typedef CONFLICT_LIST      *PCONFLICT_LIST;

typedef struct _CONFLICT_DETAILS_A {
    ULONG       CD_ulSize;                   // size of structure, ie: sizeof(CONFLICT_DETAILS)
    ULONG       CD_ulMask;                   // indicates what information is required/valid
    DEVINST     CD_dnDevInst;                // filled with DevInst of conflicting device if CM_CDMASK_DEVINST set
    RES_DES     CD_rdResDes;                 // filled with a ResDes of conflict if CM_CDMASK_RESDES set
    ULONG       CD_ulFlags;                  // various flags regarding conflict
    CHAR        CD_szDescription[MAX_PATH];  // description of conflicting device
} CONFLICT_DETAILS_A , *PCONFLICT_DETAILS_A;

typedef struct _CONFLICT_DETAILS_W {
    ULONG       CD_ulSize;                   // size of structure, ie: sizeof(CONFLICT_DETAILS)
    ULONG       CD_ulMask;                   // indicates what information is required/valid
    DEVINST     CD_dnDevInst;                // filled with DevInst of conflicting device if CM_CDMASK_DEVINST set
    RES_DES     CD_rdResDes;                 // filled with a ResDes of conflict if CM_CDMASK_RESDES set
    ULONG       CD_ulFlags;                  // various flags regarding conflict
    WCHAR       CD_szDescription[MAX_PATH];  // description of conflicting device
} CONFLICT_DETAILS_W , *PCONFLICT_DETAILS_W;

#ifdef UNICODE
typedef CONFLICT_DETAILS_W CONFLICT_DETAILS;
typedef PCONFLICT_DETAILS_W PCONFLICT_DETAILS;
#else
typedef CONFLICT_DETAILS_A CONFLICT_DETAILS;
typedef PCONFLICT_DETAILS_A PCONFLICT_DETAILS;
#endif

#define CM_CDMASK_DEVINST      (0x00000001)   // mask to retrieve CD_dnDevInst attribute for conflict
#define CM_CDMASK_RESDES       (0x00000002)   // mask to retrieve CD_rdResDes attribute for conflict
#define CM_CDMASK_FLAGS        (0x00000004)   // mask to retrieve CD_ulFlags attribute for conflict
#define CM_CDMASK_DESCRIPTION  (0x00000008)   // mask to retrieve CD_szDescription attribute for conflict
#define CM_CDMASK_VALID        (0x0000000F)   // valid bits

#define CM_CDFLAGS_DRIVER      (0x00000001)     // CD_ulFlags: CD_szDescription reports back legacy driver name
#define CM_CDFLAGS_ROOT_OWNED  (0x00000002)     // CD_ulFlags: Root owned device
#define CM_CDFLAGS_RESERVED    (0x00000004)     // CD_ulFlags: Specified range is not available for use

typedef  ULONG             REGDISPOSITION;



//
// use 1 byte packing for the data structures
//
#include "pshpack1.h"



//--------------------------------------------------------------
// Memory resource
//--------------------------------------------------------------

//
// Define the attribute flags for memory ranges.  Each bit flag is
// identified by a constant bitmask.  Following the bitmask definition,
// are the two possible values.
//
#define mMD_MemoryType              (0x1) // Bitmask, whether memory is writable
#define fMD_MemoryType              mMD_MemoryType // compatibility
#define fMD_ROM                     (0x0) // Memory range is read-only
#define fMD_RAM                     (0x1) // Memory range may be written to

#define mMD_32_24                   (0x2) // Bitmask, memory is 24 or 32-bit
#define fMD_32_24                   mMD_32_24 // compatibility
#define fMD_24                      (0x0) // Memory range is 24-bit
#define fMD_32                      (0x2) // Memory range is 32-bit

#define mMD_Prefetchable            (0x4) // Bitmask,whether memory prefetchable
#define fMD_Prefetchable            mMD_Prefetchable // compatibility
#define fMD_Pref                    mMD_Prefetchable // compatibility
#define fMD_PrefetchDisallowed      (0x0) // Memory range is not prefetchable
#define fMD_PrefetchAllowed         (0x4) // Memory range is prefetchable

#define mMD_Readable                (0x8) // Bitmask,whether memory is readable
#define fMD_Readable                mMD_Readable // compatibility
#define fMD_ReadAllowed             (0x0) // Memory range is readable
#define fMD_ReadDisallowed          (0x8) // Memory range is write-only

#define mMD_CombinedWrite           (0x10) // Bitmask,supports write-behind
#define fMD_CombinedWrite           mMD_CombinedWrite // compatibility
#define fMD_CombinedWriteDisallowed (0x0)  // no combined-write caching
#define fMD_CombinedWriteAllowed    (0x10) // supports combined-write caching

#define mMD_Cacheable               (0x20) // Bitmask,whether memory is cacheable
#define fMD_NonCacheable            (0x0)  // Memory range is non-cacheable
#define fMD_Cacheable               (0x20) // Memory range is cacheable

//
// MEM_RANGE Structure
//
typedef struct Mem_Range_s {
   DWORDLONG MR_Align;     // specifies mask for base alignment
   ULONG     MR_nBytes;    // specifies number of bytes required
   DWORDLONG MR_Min;       // specifies minimum address of the range
   DWORDLONG MR_Max;       // specifies maximum address of the range
   DWORD     MR_Flags;     // specifies flags describing range (fMD flags)
   DWORD     MR_Reserved;
} MEM_RANGE, *PMEM_RANGE;

//
// MEM_DES structure
//
typedef struct Mem_Des_s {
   DWORD     MD_Count;        // number of MEM_RANGE structs in MEM_RESOURCE
   DWORD     MD_Type;         // size (in bytes) of MEM_RANGE (MType_Range)
   DWORDLONG MD_Alloc_Base;   // base memory address of range allocated
   DWORDLONG MD_Alloc_End;    // end of allocated range
   DWORD     MD_Flags;        // flags describing allocated range (fMD flags)
   DWORD     MD_Reserved;
} MEM_DES, *PMEM_DES;

//
// MEM_RESOURCE structure
//
typedef struct Mem_Resource_s {
   MEM_DES   MEM_Header;               // info about memory range list
   MEM_RANGE MEM_Data[ANYSIZE_ARRAY];  // list of memory ranges
} MEM_RESOURCE, *PMEM_RESOURCE;

//
// Define the size of each range structure
//
#define MType_Range     sizeof(struct Mem_Range_s)



//--------------------------------------------------------------
// I/O Port Resource
//--------------------------------------------------------------

//
// Define the attribute flags for port resources.  Each bit flag is
// identified by a constant bitmask.  Following the bitmask definition,
// are the two possible values.
//
#define fIOD_PortType   (0x1) // Bitmask,whether port is IO or memory
#define fIOD_Memory     (0x0) // Port resource really uses memory
#define fIOD_IO         (0x1) // Port resource uses IO ports
#define fIOD_DECODE     (0x00fc) // decode flags
#define fIOD_10_BIT_DECODE    (0x0004)
#define fIOD_12_BIT_DECODE    (0x0008)
#define fIOD_16_BIT_DECODE    (0x0010)
#define fIOD_POSITIVE_DECODE  (0x0020)
#define fIOD_PASSIVE_DECODE   (0x0040)
#define fIOD_WINDOW_DECODE    (0x0080)

//
// these are for compatiblity
//
#define IO_ALIAS_10_BIT_DECODE      (0x00000004)
#define IO_ALIAS_12_BIT_DECODE      (0x00000010)
#define IO_ALIAS_16_BIT_DECODE      (0x00000000)
#define IO_ALIAS_POSITIVE_DECODE    (0x000000FF)

//
// IO_RANGE structure
//
typedef struct IO_Range_s {
   DWORDLONG IOR_Align;      // mask for base alignment
   DWORD     IOR_nPorts;     // number of ports
   DWORDLONG IOR_Min;        // minimum port address
   DWORDLONG IOR_Max;        // maximum port address
   DWORD     IOR_RangeFlags; // flags for this port range
   DWORDLONG IOR_Alias;      // multiplier that generates aliases for port(s)
} IO_RANGE, *PIO_RANGE;

//
// IO_DES structure
//
typedef struct IO_Des_s {
   DWORD     IOD_Count;          // number of IO_RANGE structs in IO_RESOURCE
   DWORD     IOD_Type;           // size (in bytes) of IO_RANGE (IOType_Range)
   DWORDLONG IOD_Alloc_Base;     // base of allocated port range
   DWORDLONG IOD_Alloc_End;      // end of allocated port range
   DWORD     IOD_DesFlags;       // flags relating to allocated port range
} IO_DES, *PIO_DES;

//
// IO_RESOURCE
//
typedef struct IO_Resource_s {
   IO_DES   IO_Header;                 // info about I/O port range list
   IO_RANGE IO_Data[ANYSIZE_ARRAY];    // list of I/O port ranges
} IO_RESOURCE, *PIO_RESOURCE;

#define IOA_Local       0xff

//
// Define the size of each range structure
//
#define IOType_Range    sizeof(struct IO_Range_s)



//--------------------------------------------------------------
// DMA Resource
//--------------------------------------------------------------

//
// Define the attribute flags for a DMA resource range.  Each bit flag is
// identified with a constant bitmask.  Following the bitmask definition
// are the possible values.
//
#define mDD_Width         (0x3)    // Bitmask, width of the DMA channel:
#define fDD_BYTE          (0x0)    //   8-bit DMA channel
#define fDD_WORD          (0x1)    //   16-bit DMA channel
#define fDD_DWORD         (0x2)    //   32-bit DMA channel
#define fDD_BYTE_AND_WORD (0x3)    //   8-bit and 16-bit DMA channel

#define mDD_BusMaster     (0x4)    // Bitmask, whether bus mastering is supported
#define fDD_NoBusMaster   (0x0)    //   no bus mastering
#define fDD_BusMaster     (0x4)    //   bus mastering

#define mDD_Type         (0x18)    // Bitmask, specifies type of DMA
#define fDD_TypeStandard (0x00)    //   standard DMA
#define fDD_TypeA        (0x08)    //   Type-A DMA
#define fDD_TypeB        (0x10)    //   Type-B DMA
#define fDD_TypeF        (0x18)    //   Type-F DMA


//
// DMA_RANGE structure
//
typedef struct DMA_Range_s {
   ULONG DR_Min;     // minimum DMA port in the range
   ULONG DR_Max;     // maximum DMA port in the range
   ULONG DR_Flags;   // flags describing the range (fDD flags)
} DMA_RANGE, *PDMA_RANGE;

//
// DMA_DES structure
//
typedef struct DMA_Des_s {
   DWORD  DD_Count;       // number of DMA_RANGE structs in DMA_RESOURCE
   DWORD  DD_Type;        // size (in bytes) of DMA_RANGE struct (DType_Range)
   DWORD  DD_Flags;       // Flags describing DMA channel (fDD flags)
   ULONG  DD_Alloc_Chan;  // Specifies the DMA channel that was allocated
} DMA_DES, *PDMA_DES;

//
// DMA_RESOURCE
//
typedef struct DMA_Resource_s {
   DMA_DES   DMA_Header;               // info about DMA channel range list
   DMA_RANGE DMA_Data[ANYSIZE_ARRAY];  // list of DMA ranges
} DMA_RESOURCE, *PDMA_RESOURCE;

//
// Define the size of each range structure
//
#define DType_Range     sizeof(struct DMA_Range_s)



//--------------------------------------------------------------
// Interrupt Resource
//--------------------------------------------------------------

//
// Define the attribute flags for an interrupt resource range.  Each bit flag
// is identified with a constant bitmask.  Following the bitmask definition
// are the possible values.
//
#define mIRQD_Share        (0x1) // Bitmask,whether the IRQ may be shared:
#define fIRQD_Exclusive    (0x0) //   The IRQ may not be shared
#define fIRQD_Share        (0x1) //   The IRQ may be shared

#define fIRQD_Share_Bit    0     // compatibility
#define fIRQD_Level_Bit    1     // compatibility

//
// ** NOTE: 16-bit ConfigMgr uses fIRQD_Level_Bit being set to indicate that the
// ** interrupt is _level-sensitive_.  For 32-bit ConfigMgr, if this bit is set,
// ** then the interrupt is _edge-sensitive_.
//
#define mIRQD_Edge_Level   (0x2) // Bitmask,whether edge or level triggered:
#define fIRQD_Level        (0x0) //   The IRQ is level-sensitive
#define fIRQD_Edge         (0x2) //   The IRQ is edge-sensitive

//
// IRQ_RANGE
//
typedef struct IRQ_Range_s {
   ULONG IRQR_Min;      // minimum IRQ in the range
   ULONG IRQR_Max;      // maximum IRQ in the range
   ULONG IRQR_Flags;    // flags describing the range (fIRQD flags)
} IRQ_RANGE, *PIRQ_RANGE;

//
// IRQ_DES structure
//
typedef struct IRQ_Des_32_s {
   DWORD   IRQD_Count;       // number of IRQ_RANGE structs in IRQ_RESOURCE
   DWORD   IRQD_Type;        // size (in bytes) of IRQ_RANGE (IRQType_Range)
   DWORD   IRQD_Flags;       // flags describing the IRQ (fIRQD flags)
   ULONG   IRQD_Alloc_Num;   // specifies the IRQ that was allocated
   ULONG32 IRQD_Affinity;
} IRQ_DES_32, *PIRQ_DES_32;

typedef struct IRQ_Des_64_s {
   DWORD   IRQD_Count;       // number of IRQ_RANGE structs in IRQ_RESOURCE
   DWORD   IRQD_Type;        // size (in bytes) of IRQ_RANGE (IRQType_Range)
   DWORD   IRQD_Flags;       // flags describing the IRQ (fIRQD flags)
   ULONG   IRQD_Alloc_Num;   // specifies the IRQ that was allocated
   ULONG64 IRQD_Affinity;
} IRQ_DES_64, *PIRQ_DES_64;

#ifdef _WIN64
typedef IRQ_DES_64   IRQ_DES;
typedef PIRQ_DES_64  PIRQ_DES;
#else
typedef IRQ_DES_32   IRQ_DES;
typedef PIRQ_DES_32  PIRQ_DES;
#endif

//
// IRQ_RESOURCE structure
//
typedef struct IRQ_Resource_32_s {
   IRQ_DES_32   IRQ_Header;               // info about IRQ range list
   IRQ_RANGE    IRQ_Data[ANYSIZE_ARRAY];  // list of IRQ ranges
} IRQ_RESOURCE_32, *PIRQ_RESOURCE_32;

typedef struct IRQ_Resource_64_s {
   IRQ_DES_64   IRQ_Header;               // info about IRQ range list
   IRQ_RANGE    IRQ_Data[ANYSIZE_ARRAY];  // list of IRQ ranges
} IRQ_RESOURCE_64, *PIRQ_RESOURCE_64;

#ifdef _WIN64
typedef IRQ_RESOURCE_64  IRQ_RESOURCE;
typedef PIRQ_RESOURCE_64 PIRQ_RESOURCE;
#else
typedef IRQ_RESOURCE_32  IRQ_RESOURCE;
typedef PIRQ_RESOURCE_32 PIRQ_RESOURCE;
#endif

//
// Define the size of each range structure
//
#define IRQType_Range   sizeof(struct IRQ_Range_s)

//
// Flags for resource descriptor APIs indicating the width of certain
// variable-size resource descriptor structure fields, where applicable.
//
#define CM_RESDES_WIDTH_DEFAULT (0x00000000)  // 32 or 64-bit IRQ_RESOURCE / IRQ_DES, based on client
#define CM_RESDES_WIDTH_32      (0x00000001)  // 32-bit IRQ_RESOURCE / IRQ_DES
#define CM_RESDES_WIDTH_64      (0x00000002)  // 64-bit IRQ_RESOURCE / IRQ_DES
#define CM_RESDES_WIDTH_BITS    (0x00000003)

//--------------------------------------------------------------
// Device Private Resource
//--------------------------------------------------------------

//
// DEVICEPRIVATE_RANGE structure
//

typedef struct DevPrivate_Range_s {
   DWORD    PR_Data1;     // mask for base alignment
   DWORD    PR_Data2;     // number of bytes
   DWORD    PR_Data3;     // minimum address
} DEVPRIVATE_RANGE, *PDEVPRIVATE_RANGE;

//
// DEVPRIVATE_DES structure
//
typedef struct DevPrivate_Des_s {
   DWORD     PD_Count;
   DWORD     PD_Type;
   DWORD     PD_Data1;
   DWORD     PD_Data2;
   DWORD     PD_Data3;
   DWORD     PD_Flags;
} DEVPRIVATE_DES, *PDEVPRIVATE_DES;

//
// DEVPRIVATE_RESOURCE
//
typedef struct DevPrivate_Resource_s {
   DEVPRIVATE_DES   PRV_Header;
   DEVPRIVATE_RANGE PRV_Data[ANYSIZE_ARRAY];
} DEVPRIVATE_RESOURCE, *PDEVPRIVATE_RESOURCE;

//
// Define the size of each range structure
//
#define PType_Range    sizeof(struct DevPrivate_Range_s)



//--------------------------------------------------------------
// Class-Specific Resource
//--------------------------------------------------------------

typedef struct CS_Des_s {
   DWORD    CSD_SignatureLength;
   DWORD    CSD_LegacyDataOffset;
   DWORD    CSD_LegacyDataSize;
   DWORD    CSD_Flags;
   GUID     CSD_ClassGuid;
   BYTE     CSD_Signature[ANYSIZE_ARRAY];
} CS_DES, *PCS_DES;

typedef struct CS_Resource_s {
   CS_DES   CS_Header;
} CS_RESOURCE, *PCS_RESOURCE;



//--------------------------------------------------------------
// PC Card Configuration Resource
//--------------------------------------------------------------

//
// Define the attribute flags for a PC Card configuration resource descriptor.
// Each bit flag is identified with a constant bitmask.  Following the bitmask
// definition are the possible values.
//
#define mPCD_IO_8_16        (0x1)   // Bitmask, whether I/O is 8 or 16 bits
#define fPCD_IO_8           (0x0)   // I/O is 8-bit
#define fPCD_IO_16          (0x1)   // I/O is 16-bit
#define mPCD_MEM_8_16       (0x2)   // Bitmask, whether MEM is 8 or 16 bits
#define fPCD_MEM_8          (0x0)   // MEM is 8-bit
#define fPCD_MEM_16         (0x2)   // MEM is 16-bit
#define mPCD_MEM_A_C        (0xC)   // Bitmask, whether MEMx is Attribute or Common
#define fPCD_MEM1_A         (0x4)   // MEM1 is Attribute
#define fPCD_MEM2_A         (0x8)   // MEM2 is Attribute
#define fPCD_IO_ZW_8        (0x10)  // zero wait on 8 bit I/O
#define fPCD_IO_SRC_16      (0x20)  // iosrc 16
#define fPCD_IO_WS_16       (0x40)  // wait states on 16 bit io
#define mPCD_MEM_WS         (0x300) // Bitmask, for additional wait states on memory windows
#define fPCD_MEM_WS_ONE     (0x100) // 1 wait state
#define fPCD_MEM_WS_TWO     (0x200) // 2 wait states
#define fPCD_MEM_WS_THREE   (0x300) // 3 wait states

#define fPCD_MEM_A          (0x4)   // MEM is Attribute

#define fPCD_ATTRIBUTES_PER_WINDOW (0x8000)

#define fPCD_IO1_16         (0x00010000)  // I/O window 1 is 16-bit
#define fPCD_IO1_ZW_8       (0x00020000)  // I/O window 1 zero wait on 8 bit I/O
#define fPCD_IO1_SRC_16     (0x00040000)  // I/O window 1 iosrc 16
#define fPCD_IO1_WS_16      (0x00080000)  // I/O window 1 wait states on 16 bit io

#define fPCD_IO2_16         (0x00100000)  // I/O window 2 is 16-bit
#define fPCD_IO2_ZW_8       (0x00200000)  // I/O window 2 zero wait on 8 bit I/O
#define fPCD_IO2_SRC_16     (0x00400000)  // I/O window 2 iosrc 16
#define fPCD_IO2_WS_16      (0x00800000)  // I/O window 2 wait states on 16 bit io

#define mPCD_MEM1_WS        (0x03000000)  // MEM window 1 Bitmask, for additional wait states on memory windows
#define fPCD_MEM1_WS_ONE    (0x01000000)  // MEM window 1, 1 wait state
#define fPCD_MEM1_WS_TWO    (0x02000000)  // MEM window 1, 2 wait states
#define fPCD_MEM1_WS_THREE  (0x03000000)  // MEM window 1, 3 wait states
#define fPCD_MEM1_16        (0x04000000)  // MEM window 1 is 16-bit

#define mPCD_MEM2_WS        (0x30000000)  // MEM window 2 Bitmask, for additional wait states on memory windows
#define fPCD_MEM2_WS_ONE    (0x10000000)  // MEM window 2, 1 wait state
#define fPCD_MEM2_WS_TWO    (0x20000000)  // MEM window 2, 2 wait states
#define fPCD_MEM2_WS_THREE  (0x30000000)  // MEM window 2, 3 wait states
#define fPCD_MEM2_16        (0x40000000)  // MEM window 2 is 16-bit

#define PCD_MAX_MEMORY   2
#define PCD_MAX_IO       2


typedef struct PcCard_Des_s {
    DWORD    PCD_Count;
    DWORD    PCD_Type;
    DWORD    PCD_Flags;
    BYTE     PCD_ConfigIndex;
    BYTE     PCD_Reserved[3];
    DWORD    PCD_MemoryCardBase1;
    DWORD    PCD_MemoryCardBase2;
    DWORD    PCD_MemoryCardBase[PCD_MAX_MEMORY];            // will soon be removed
    WORD     PCD_MemoryFlags[PCD_MAX_MEMORY];               // will soon be removed
    BYTE     PCD_IoFlags[PCD_MAX_IO];                       // will soon be removed
} PCCARD_DES, *PPCCARD_DES;

typedef struct PcCard_Resource_s {
   PCCARD_DES   PcCard_Header;
} PCCARD_RESOURCE, *PPCCARD_RESOURCE;

//--------------------------------------------------------------
// MF (multifunction) PCCard Configuration Resource
//--------------------------------------------------------------

#define mPMF_AUDIO_ENABLE   (0x8)   // Bitmask, whether audio is enabled or not
#define fPMF_AUDIO_ENABLE   (0x8)   // Audio is enabled

typedef struct MfCard_Des_s {
    DWORD    PMF_Count;
    DWORD    PMF_Type;
    DWORD    PMF_Flags;
    BYTE     PMF_ConfigOptions;
    BYTE     PMF_IoResourceIndex;
    BYTE     PMF_Reserved[2];
    DWORD    PMF_ConfigRegisterBase;
} MFCARD_DES, *PMFCARD_DES;

typedef struct MfCard_Resource_s {
   MFCARD_DES   MfCard_Header;
} MFCARD_RESOURCE, *PMFCARD_RESOURCE;


//--------------------------------------------------------------
// Bus Number Resource
//--------------------------------------------------------------

//
// Define the attribute flags for a Bus Number resource descriptor.
// Each bit flag is identified with a constant bitmask.  Following the bitmask
// definition are the possible values.
//
// Currently unused.
//

//
// BUSNUMBER_RANGE
//
typedef struct BusNumber_Range_s {
   ULONG BUSR_Min;          // minimum Bus Number in the range
   ULONG BUSR_Max;          // maximum Bus Number in the range
   ULONG BUSR_nBusNumbers;  // specifies number of buses required
   ULONG BUSR_Flags;        // flags describing the range (currently unused)
} BUSNUMBER_RANGE, *PBUSNUMBER_RANGE;

//
// BUSNUMBER_DES structure
//
typedef struct BusNumber_Des_s {
   DWORD BUSD_Count;       // number of BUSNUMBER_RANGE structs in BUSNUMBER_RESOURCE
   DWORD BUSD_Type;        // size (in bytes) of BUSNUMBER_RANGE (BusNumberType_Range)
   DWORD BUSD_Flags;       // flags describing the range (currently unused)
   ULONG BUSD_Alloc_Base;  // specifies the first Bus that was allocated
   ULONG BUSD_Alloc_End;   // specifies the last Bus number that was allocated
} BUSNUMBER_DES, *PBUSNUMBER_DES;

//
// BUSNUMBER_RESOURCE structure
//
typedef struct BusNumber_Resource_s {
   BUSNUMBER_DES   BusNumber_Header;               // info about Bus Number range list
   BUSNUMBER_RANGE BusNumber_Data[ANYSIZE_ARRAY];  // list of Bus Number ranges
} BUSNUMBER_RESOURCE, *PBUSNUMBER_RESOURCE;

//
// Define the size of each range structure
//
#define BusNumberType_Range   sizeof(struct BusNumber_Range_s)



//--------------------------------------------------------------
// Hardware Profile Information
//--------------------------------------------------------------

//
// Define flags relating to hardware profiles
//
#define CM_HWPI_NOT_DOCKABLE  (0x00000000)   // machine is not dockable
#define CM_HWPI_UNDOCKED      (0x00000001)   // hw profile for docked config
#define CM_HWPI_DOCKED        (0x00000002)   // hw profile for undocked config

//
// HWPROFILEINFO structure
//
typedef struct HWProfileInfo_sA {
   ULONG  HWPI_ulHWProfile;                      // handle of hw profile
   CHAR   HWPI_szFriendlyName[MAX_PROFILE_LEN];  // friendly name of hw profile
   DWORD  HWPI_dwFlags;                          // profile flags (CM_HWPI_*)
} HWPROFILEINFO_A, *PHWPROFILEINFO_A;

typedef struct HWProfileInfo_sW {
   ULONG  HWPI_ulHWProfile;                      // handle of hw profile
   WCHAR  HWPI_szFriendlyName[MAX_PROFILE_LEN];  // friendly name of hw profile
   DWORD  HWPI_dwFlags;                          // profile flags (CM_HWPI_*)
} HWPROFILEINFO_W, *PHWPROFILEINFO_W;

#ifdef UNICODE
typedef HWPROFILEINFO_W   HWPROFILEINFO;
typedef PHWPROFILEINFO_W  PHWPROFILEINFO;
#else
typedef HWPROFILEINFO_A   HWPROFILEINFO;
typedef PHWPROFILEINFO_A  PHWPROFILEINFO;
#endif


//
// revert back to normal default packing
//
#include "poppack.h"



//--------------------------------------------------------------
// Miscellaneous
//--------------------------------------------------------------


//
// Resource types
//
#define ResType_All           (0x00000000)   // Return all resource types
#define ResType_None          (0x00000000)   // Arbitration always succeeded
#define ResType_Mem           (0x00000001)   // Physical address resource
#define ResType_IO            (0x00000002)   // Physical I/O address resource
#define ResType_DMA           (0x00000003)   // DMA channels resource
#define ResType_IRQ           (0x00000004)   // IRQ resource
#define ResType_DoNotUse      (0x00000005)   // Used as spacer to sync subsequent ResTypes w/NT
#define ResType_BusNumber     (0x00000006)   // bus number resource
#define ResType_MAX           (0x00000006)   // Maximum known (arbitrated) ResType
#define ResType_Ignored_Bit   (0x00008000)   // Ignore this resource
#define ResType_ClassSpecific (0x0000FFFF)   // class-specific resource
#define ResType_Reserved      (0x00008000)   // reserved for internal use
#define ResType_DevicePrivate (0x00008001)   // device private data
#define ResType_PcCardConfig  (0x00008002)   // PC Card configuration data
#define ResType_MfCardConfig  (0x00008003)   // MF Card configuration data


//
// Flags specifying options for ranges that conflict with ranges already in
// the range list (CM_Add_Range)
//
#define CM_ADD_RANGE_ADDIFCONFLICT        (0x00000000) // merg with conflicting range
#define CM_ADD_RANGE_DONOTADDIFCONFLICT   (0x00000001) // error if range conflicts
#define CM_ADD_RANGE_BITS                 (0x00000001)


//
// Logical Config Flags (specified in call to CM_Get_First_Log_Conf
//
#define BASIC_LOG_CONF    0x00000000  // Specifies the req list.
#define FILTERED_LOG_CONF 0x00000001  // Specifies the filtered req list.
#define ALLOC_LOG_CONF    0x00000002  // Specifies the Alloc Element.
#define BOOT_LOG_CONF     0x00000003  // Specifies the RM Alloc Element.
#define FORCED_LOG_CONF   0x00000004  // Specifies the Forced Log Conf
#define OVERRIDE_LOG_CONF 0x00000005  // Specifies the Override req list.
#define NUM_LOG_CONF      0x00000006  // Number of Log Conf type
#define LOG_CONF_BITS     0x00000007  // The bits of the log conf type.

#define PRIORITY_EQUAL_FIRST  (0x00000008) // Same priority, new one first
#define PRIORITY_EQUAL_LAST   (0x00000000) // Same priority, new one last
#define PRIORITY_BIT          (0x00000008)

//
// Registry disposition values
// (specified in call to CM_Open_DevNode_Key and CM_Open_Class_Key)
//
#define RegDisposition_OpenAlways   (0x00000000)   // open if exists else create
#define RegDisposition_OpenExisting (0x00000001)   // open key only if exists
#define RegDisposition_Bits         (0x00000001)

//
// ulFlags values for CM API routines
//

//
// Flags for CM_Add_ID
//
#define CM_ADD_ID_HARDWARE                (0x00000000)
#define CM_ADD_ID_COMPATIBLE              (0x00000001)
#define CM_ADD_ID_BITS                    (0x00000001)


//
// Device Node creation flags
//
#define CM_CREATE_DEVNODE_NORMAL          (0x00000000)   // install later
#define CM_CREATE_DEVNODE_NO_WAIT_INSTALL (0x00000001)   // NOT SUPPORTED ON NT
#define CM_CREATE_DEVNODE_PHANTOM         (0x00000002)
#define CM_CREATE_DEVNODE_GENERATE_ID     (0x00000004)
#define CM_CREATE_DEVNODE_DO_NOT_INSTALL  (0x00000008)
#define CM_CREATE_DEVNODE_BITS            (0x0000000F)

#define CM_CREATE_DEVINST_NORMAL          CM_CREATE_DEVNODE_NORMAL
#define CM_CREATE_DEVINST_NO_WAIT_INSTALL CM_CREATE_DEVNODE_NO_WAIT_INSTALL
#define CM_CREATE_DEVINST_PHANTOM         CM_CREATE_DEVNODE_PHANTOM
#define CM_CREATE_DEVINST_GENERATE_ID     CM_CREATE_DEVNODE_GENERATE_ID
#define CM_CREATE_DEVINST_DO_NOT_INSTALL  CM_CREATE_DEVNODE_DO_NOT_INSTALL
#define CM_CREATE_DEVINST_BITS            CM_CREATE_DEVNODE_BITS


//
// Flags for CM_Delete_Class_Key
//
#define CM_DELETE_CLASS_ONLY        (0x00000000)
#define CM_DELETE_CLASS_SUBKEYS     (0x00000001)
#define CM_DELETE_CLASS_BITS        (0x00000001)


//
// Detection reason flags (specified in call to CM_Run_Detection)
//
#define CM_DETECT_NEW_PROFILE       (0x00000001) // detection for new hw profile
#define CM_DETECT_CRASHED           (0x00000002) // Previous detection crashed
#define CM_DETECT_HWPROF_FIRST_BOOT (0x00000004)
#define CM_DETECT_RUN               (0x80000000)
#define CM_DETECT_BITS              (0x80000007)

#define CM_DISABLE_POLITE           (0x00000000)    // Ask the driver
#define CM_DISABLE_ABSOLUTE         (0x00000001)    // Don't ask the driver
#define CM_DISABLE_HARDWARE         (0x00000002)    // Don't ask the driver, and won't be restarteable
#define CM_DISABLE_UI_NOT_OK        (0x00000004)    // Don't popup any veto API
#define CM_DISABLE_BITS             (0x00000007)    // The bits for the disable function


//
// Flags for CM_Get_Device_ID_List, CM_Get_Device_ID_List_Size
//
#define CM_GETIDLIST_FILTER_NONE                (0x00000000)
#define CM_GETIDLIST_FILTER_ENUMERATOR          (0x00000001)
#define CM_GETIDLIST_FILTER_SERVICE             (0x00000002)
#define CM_GETIDLIST_FILTER_EJECTRELATIONS      (0x00000004)
#define CM_GETIDLIST_FILTER_REMOVALRELATIONS    (0x00000008)
#define CM_GETIDLIST_FILTER_POWERRELATIONS      (0x00000010)
#define CM_GETIDLIST_FILTER_BUSRELATIONS        (0x00000020)
#define CM_GETIDLIST_DONOTGENERATE              (0x10000040)
#define CM_GETIDLIST_FILTER_BITS                (0x1000007F)

//
// Flags for CM_Get_Device_Interface_List, CM_Get_Device_Interface_List_Size
//
#define CM_GET_DEVICE_INTERFACE_LIST_PRESENT     (0x00000000)  // only currently 'live' device interfaces
#define CM_GET_DEVICE_INTERFACE_LIST_ALL_DEVICES (0x00000001)  // all registered device interfaces, live or not
#define CM_GET_DEVICE_INTERFACE_LIST_BITS        (0x00000001)

//
// Registry properties (specified in call to CM_Get_DevInst_Registry_Property or CM_Get_Class_Registry_Property,
// some are allowed in calls to CM_Set_DevInst_Registry_Property and CM_Set_Class_Registry_Property)
// CM_DRP_xxxx values should be used for CM_Get_DevInst_Registry_Property / CM_Set_DevInst_Registry_Property
// CM_CRP_xxxx values should be used for CM_Get_Class_Registry_Property / CM_Set_Class_Registry_Property
// DRP/CRP values that overlap must have a 1:1 correspondence with each other
//
#define CM_DRP_DEVICEDESC                  (0x00000001) // DeviceDesc REG_SZ property (RW)
#define CM_DRP_HARDWAREID                  (0x00000002) // HardwareID REG_MULTI_SZ property (RW)
#define CM_DRP_COMPATIBLEIDS               (0x00000003) // CompatibleIDs REG_MULTI_SZ property (RW)
#define CM_DRP_UNUSED0                     (0x00000004) // unused
#define CM_DRP_SERVICE                     (0x00000005) // Service REG_SZ property (RW)
#define CM_DRP_UNUSED1                     (0x00000006) // unused
#define CM_DRP_UNUSED2                     (0x00000007) // unused
#define CM_DRP_CLASS                       (0x00000008) // Class REG_SZ property (RW)
#define CM_DRP_CLASSGUID                   (0x00000009) // ClassGUID REG_SZ property (RW)
#define CM_DRP_DRIVER                      (0x0000000A) // Driver REG_SZ property (RW)
#define CM_DRP_CONFIGFLAGS                 (0x0000000B) // ConfigFlags REG_DWORD property (RW)
#define CM_DRP_MFG                         (0x0000000C) // Mfg REG_SZ property (RW)
#define CM_DRP_FRIENDLYNAME                (0x0000000D) // FriendlyName REG_SZ property (RW)
#define CM_DRP_LOCATION_INFORMATION        (0x0000000E) // LocationInformation REG_SZ property (RW)
#define CM_DRP_PHYSICAL_DEVICE_OBJECT_NAME (0x0000000F) // PhysicalDeviceObjectName REG_SZ property (R)
#define CM_DRP_CAPABILITIES                (0x00000010) // Capabilities REG_DWORD property (R)
#define CM_DRP_UI_NUMBER                   (0x00000011) // UiNumber REG_DWORD property (R)
#define CM_DRP_UPPERFILTERS                (0x00000012) // UpperFilters REG_MULTI_SZ property (RW)
#define CM_DRP_LOWERFILTERS                (0x00000013) // LowerFilters REG_MULTI_SZ property (RW)
#define CM_DRP_BUSTYPEGUID                 (0x00000014) // Bus Type Guid, GUID, (R)
#define CM_DRP_LEGACYBUSTYPE               (0x00000015) // Legacy bus type, INTERFACE_TYPE, (R)
#define CM_DRP_BUSNUMBER                   (0x00000016) // Bus Number, DWORD, (R)
#define CM_DRP_ENUMERATOR_NAME             (0x00000017) // Enumerator Name REG_SZ property (R)
#define CM_DRP_SECURITY                    (0x00000018) // Security - Device override (RW)
#define CM_CRP_SECURITY                    CM_DRP_SECURITY   // Class default security (RW)
#define CM_DRP_SECURITY_SDS                (0x00000019) // Security - Device override (RW)
#define CM_CRP_SECURITY_SDS                CM_DRP_SECURITY_SDS // Class default security (RW)
#define CM_DRP_DEVTYPE                     (0x0000001A) // Device Type - Device override (RW)
#define CM_CRP_DEVTYPE                     CM_DRP_DEVTYPE    // Class default Device-type (RW)
#define CM_DRP_EXCLUSIVE                   (0x0000001B) // Exclusivity - Device override (RW)
#define CM_CRP_EXCLUSIVE                   CM_DRP_EXCLUSIVE  // Class default (RW)
#define CM_DRP_CHARACTERISTICS             (0x0000001C) // Characteristics - Device Override (RW)
#define CM_CRP_CHARACTERISTICS             CM_DRP_CHARACTERISTICS  // Class default (RW)
#define CM_DRP_ADDRESS                     (0x0000001D) // Device Address (R)
#define CM_DRP_UI_NUMBER_DESC_FORMAT       (0x0000001E) // UINumberDescFormat REG_SZ property (RW)
#define CM_DRP_DEVICE_POWER_DATA           (0x0000001F) // CM_POWER_DATA REG_BINARY property (R)
#define CM_DRP_REMOVAL_POLICY              (0x00000020) // CM_DEVICE_REMOVAL_POLICY REG_DWORD (R)
#define CM_DRP_REMOVAL_POLICY_HW_DEFAULT   (0x00000021) // CM_DRP_REMOVAL_POLICY_HW_DEFAULT REG_DWORD (R)
#define CM_DRP_REMOVAL_POLICY_OVERRIDE     (0x00000022) // CM_DRP_REMOVAL_POLICY_OVERRIDE REG_DWORD (RW)
#define CM_DRP_INSTALL_STATE               (0x00000023) // CM_DRP_INSTALL_STATE REG_DWORD (R)

#define CM_DRP_MIN                         (0x00000001) // First device register
#define CM_CRP_MIN                         CM_DRP_MIN   // First class register
#define CM_DRP_MAX                         (0x00000023) // Last device register
#define CM_CRP_MAX                         CM_DRP_MAX   // Last class register

//
// Capabilities bits (the capability value is returned from calling
// CM_Get_DevInst_Registry_Property with CM_DRP_CAPABILITIES property)
//
#define CM_DEVCAP_LOCKSUPPORTED     (0x00000001)
#define CM_DEVCAP_EJECTSUPPORTED    (0x00000002)
#define CM_DEVCAP_REMOVABLE         (0x00000004)
#define CM_DEVCAP_DOCKDEVICE        (0x00000008)
#define CM_DEVCAP_UNIQUEID          (0x00000010)
#define CM_DEVCAP_SILENTINSTALL     (0x00000020)
#define CM_DEVCAP_RAWDEVICEOK       (0x00000040)
#define CM_DEVCAP_SURPRISEREMOVALOK (0x00000080)
#define CM_DEVCAP_HARDWAREDISABLED  (0x00000100)
#define CM_DEVCAP_NONDYNAMIC        (0x00000200)

//
// Removal policies (retrievable via CM_Get_DevInst_Registry_Property with
// the CM_DRP_REMOVAL_POLICY, CM_DRP_REMOVAL_POLICY_OVERRIDE, or
// CM_DRP_REMOVAL_POLICY_HW_DEFAULT properties)
//
#define CM_REMOVAL_POLICY_EXPECT_NO_REMOVAL             1
#define CM_REMOVAL_POLICY_EXPECT_ORDERLY_REMOVAL        2
#define CM_REMOVAL_POLICY_EXPECT_SURPRISE_REMOVAL       3

//
// Device install states (retrievable via CM_Get_DevInst_Registry_Property with
// the CM_DRP_INSTALL_STATE properties)
//
#define CM_INSTALL_STATE_INSTALLED                      0
#define CM_INSTALL_STATE_NEEDS_REINSTALL                1
#define CM_INSTALL_STATE_FAILED_INSTALL                 2
#define CM_INSTALL_STATE_FINISH_INSTALL                 3

//
// Flags for CM_Locate_DevNode
//
#define CM_LOCATE_DEVNODE_NORMAL       0x00000000
#define CM_LOCATE_DEVNODE_PHANTOM      0x00000001
#define CM_LOCATE_DEVNODE_CANCELREMOVE 0x00000002
#define CM_LOCATE_DEVNODE_NOVALIDATION 0x00000004
#define CM_LOCATE_DEVNODE_BITS         0x00000007

#define CM_LOCATE_DEVINST_NORMAL       CM_LOCATE_DEVNODE_NORMAL
#define CM_LOCATE_DEVINST_PHANTOM      CM_LOCATE_DEVNODE_PHANTOM
#define CM_LOCATE_DEVINST_CANCELREMOVE CM_LOCATE_DEVNODE_CANCELREMOVE
#define CM_LOCATE_DEVINST_NOVALIDATION CM_LOCATE_DEVNODE_NOVALIDATION
#define CM_LOCATE_DEVINST_BITS         CM_LOCATE_DEVNODE_BITS

//
// Flags for CM_Open_Class_Key
//
#define CM_OPEN_CLASS_KEY_INSTALLER        (0x00000000)
#define CM_OPEN_CLASS_KEY_INTERFACE        (0x00000001)
#define CM_OPEN_CLASS_KEY_BITS             (0x00000001)

//
// Flags for CM_Query_And_Remove_SubTree
//
#define CM_REMOVE_UI_OK             0x00000000
#define CM_REMOVE_UI_NOT_OK         0x00000001
#define CM_REMOVE_NO_RESTART        0x00000002
#define CM_REMOVE_BITS              0x00000003

//
// Backward compatibility--do not use
// (use above CM_REMOVE_* flags instead)
//
#define CM_QUERY_REMOVE_UI_OK       (CM_REMOVE_UI_OK)
#define CM_QUERY_REMOVE_UI_NOT_OK   (CM_REMOVE_UI_NOT_OK)
#define CM_QUERY_REMOVE_BITS        (CM_QUERY_REMOVE_UI_OK|CM_QUERY_REMOVE_UI_NOT_OK)

//
// Flags for CM_Reenumerate_DevNode
//
#define CM_REENUMERATE_NORMAL                   0x00000000
#define CM_REENUMERATE_SYNCHRONOUS              0x00000001
#define CM_REENUMERATE_RETRY_INSTALLATION       0x00000002
#define CM_REENUMERATE_ASYNCHRONOUS             0x00000004
#define CM_REENUMERATE_BITS                     0x00000007

//
// Flags for CM_Register_Device_Driver
//
#define CM_REGISTER_DEVICE_DRIVER_STATIC        (0x00000000)
#define CM_REGISTER_DEVICE_DRIVER_DISABLEABLE   (0x00000001)
#define CM_REGISTER_DEVICE_DRIVER_REMOVABLE     (0x00000002)
#define CM_REGISTER_DEVICE_DRIVER_BITS          (0x00000003)

//
// Registry Branch Locations (for CM_Open_DevNode_Key)
//
#define CM_REGISTRY_HARDWARE        (0x00000000)
#define CM_REGISTRY_SOFTWARE        (0x00000001)
#define CM_REGISTRY_USER            (0x00000100)
#define CM_REGISTRY_CONFIG          (0x00000200)
#define CM_REGISTRY_BITS            (0x00000301)

//
// Flags for CM_Set_DevNode_Problem
//
#define CM_SET_DEVNODE_PROBLEM_NORMAL    (0x00000000)  // only set problem if currently no problem
#define CM_SET_DEVNODE_PROBLEM_OVERRIDE  (0x00000001)  // override current problem with new problem
#define CM_SET_DEVNODE_PROBLEM_BITS      (0x00000001)

#define CM_SET_DEVINST_PROBLEM_NORMAL    CM_SET_DEVNODE_PROBLEM_NORMAL
#define CM_SET_DEVINST_PROBLEM_OVERRIDE  CM_SET_DEVNODE_PROBLEM_OVERRIDE
#define CM_SET_DEVINST_PROBLEM_BITS      CM_SET_DEVNODE_PROBLEM_BITS

//
// Flags for CM_Set_HW_Prof_Flags
//
#define CM_SET_HW_PROF_FLAGS_UI_NOT_OK  (0x00000001)    // Don't popup any veto UI
#define CM_SET_HW_PROF_FLAGS_BITS       (0x00000001)

//
// Re-enable and configuration actions (specified in call to CM_Setup_DevInst)
//
#define CM_SETUP_DEVNODE_READY   (0x00000000) // Reenable problem devinst
#define CM_SETUP_DEVINST_READY   CM_SETUP_DEVNODE_READY
#define CM_SETUP_DOWNLOAD        (0x00000001) // Get info about devinst
#define CM_SETUP_WRITE_LOG_CONFS (0x00000002)
#define CM_SETUP_PROP_CHANGE     (0x00000003)
#define CM_SETUP_DEVNODE_RESET   (0x00000004) // Reset problem devinst without starting
#define CM_SETUP_DEVINST_RESET   CM_SETUP_DEVNODE_RESET
#define CM_SETUP_BITS            (0x00000007)

//
// Flags for CM_Query_Arbitrator_Free_Data and
// CM_Query_Arbitrator_Free_Data_Size.
//
#define CM_QUERY_ARBITRATOR_RAW         (0x00000000)
#define CM_QUERY_ARBITRATOR_TRANSLATED  (0x00000001)
#define CM_QUERY_ARBITRATOR_BITS        (0x00000001)

//
// Flags for CM_Get_DevNode_Custom_Property
//
#define CM_CUSTOMDEVPROP_MERGE_MULTISZ  (0x00000001)
#define CM_CUSTOMDEVPROP_BITS           (0x00000001)


//--------------------------------------------------------------
// Function prototypes
//--------------------------------------------------------------



CMAPI
CONFIGRET
WINAPI
CM_Add_Empty_Log_Conf(
             OUT PLOG_CONF plcLogConf,
             IN  DEVINST   dnDevInst,
             IN  PRIORITY  Priority,
             IN  ULONG     ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Add_Empty_Log_Conf_Ex(
             OUT PLOG_CONF plcLogConf,
             IN  DEVINST   dnDevInst,
             IN  PRIORITY  Priority,
             IN  ULONG     ulFlags,
             IN  HMACHINE  hMachine
             );


CMAPI
CONFIGRET
WINAPI
CM_Add_IDA(
             IN DEVINST dnDevInst,
             IN PSTR    pszID,
             IN ULONG   ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Add_IDW(
             IN DEVINST dnDevInst,
             IN PWSTR   pszID,
             IN ULONG   ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Add_ID_ExA(
             IN DEVINST  dnDevInst,
             IN PSTR     pszID,
             IN ULONG    ulFlags,
             IN HMACHINE hMachine
             );
CMAPI
CONFIGRET
WINAPI
CM_Add_ID_ExW(
             IN DEVINST  dnDevInst,
             IN PWSTR    pszID,
             IN ULONG    ulFlags,
             IN HMACHINE hMachine
             );
#ifdef UNICODE
#define CM_Add_ID             CM_Add_IDW
#define CM_Add_ID_Ex          CM_Add_ID_ExW
#else
#define CM_Add_ID             CM_Add_IDA
#define CM_Add_ID_Ex          CM_Add_ID_ExA
#endif // UNICODE


CMAPI
CONFIGRET
WINAPI
CM_Add_Range(
             IN DWORDLONG  ullStartValue,
             IN DWORDLONG  ullEndValue,
             IN RANGE_LIST rlh,
             IN ULONG      ulFlags
             );


CMAPI
CONFIGRET
WINAPI
CM_Add_Res_Des(
             OUT PRES_DES  prdResDes,
             IN LOG_CONF   lcLogConf,
             IN RESOURCEID ResourceID,
             IN PCVOID     ResourceData,
             IN ULONG      ResourceLen,
             IN ULONG      ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Add_Res_Des_Ex(
             OUT PRES_DES  prdResDes,
             IN LOG_CONF   lcLogConf,
             IN RESOURCEID ResourceID,
             IN PCVOID     ResourceData,
             IN ULONG      ResourceLen,
             IN ULONG      ulFlags,
             IN HMACHINE   hMachine
             );


CMAPI
CONFIGRET
WINAPI
CM_Connect_MachineA(
             IN  PCSTR     UNCServerName,
             OUT PHMACHINE phMachine
             );
CMAPI
CONFIGRET
WINAPI
CM_Connect_MachineW(
             IN  PCWSTR    UNCServerName,
             OUT PHMACHINE phMachine
             );
#ifdef UNICODE
#define CM_Connect_Machine       CM_Connect_MachineW
#else
#define CM_Connect_Machine       CM_Connect_MachineA
#endif // UNICODE



CMAPI
CONFIGRET
WINAPI
CM_Create_DevNodeA(
             OUT PDEVINST    pdnDevInst,
             IN  DEVINSTID_A pDeviceID,
             IN  DEVINST     dnParent,
             IN  ULONG       ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Create_DevNodeW(
             OUT PDEVINST    pdnDevInst,
             IN  DEVINSTID_W pDeviceID,
             IN  DEVINST     dnParent,
             IN  ULONG       ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Create_DevNode_ExA(
             OUT PDEVINST    pdnDevInst,
             IN  DEVINSTID_A pDeviceID,
             IN  DEVINST     dnParent,
             IN  ULONG       ulFlags,
             IN  HANDLE      hMachine
             );
CMAPI
CONFIGRET
WINAPI
CM_Create_DevNode_ExW(
             OUT PDEVINST    pdnDevInst,
             IN  DEVINSTID_W pDeviceID,
             IN  DEVINST     dnParent,
             IN  ULONG       ulFlags,
             IN  HANDLE      hMachine
             );
#define CM_Create_DevInstW       CM_Create_DevNodeW
#define CM_Create_DevInstA       CM_Create_DevNodeA
#define CM_Create_DevInst_ExW    CM_Create_DevNode_ExW
#define CM_Create_DevInst_ExA    CM_Create_DevNode_ExA
#ifdef UNICODE
#define CM_Create_DevNode        CM_Create_DevNodeW
#define CM_Create_DevInst        CM_Create_DevNodeW
#define CM_Create_DevNode_Ex     CM_Create_DevNode_ExW
#define CM_Create_DevInst_Ex     CM_Create_DevInst_ExW
#else
#define CM_Create_DevNode        CM_Create_DevNodeA
#define CM_Create_DevInst        CM_Create_DevNodeA
#define CM_Create_DevNode_Ex     CM_Create_DevNode_ExA
#define CM_Create_DevInst_Ex     CM_Create_DevNode_ExA
#endif // UNICODE


CMAPI
CONFIGRET
WINAPI
CM_Create_Range_List(
             OUT PRANGE_LIST prlh,
             IN  ULONG       ulFlags
             );


CMAPI
CONFIGRET
WINAPI
CM_Delete_Class_Key(
             IN  LPGUID     ClassGuid,
             IN  ULONG      ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Delete_Class_Key_Ex(
             IN  LPGUID     ClassGuid,
             IN  ULONG      ulFlags,
             IN  HANDLE     hMachine
             );

CMAPI
CONFIGRET
WINAPI
CM_Delete_DevNode_Key(
             IN DEVNODE dnDevNode,
             IN ULONG   ulHardwareProfile,
             IN ULONG   ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Delete_DevNode_Key_Ex(
             IN DEVNODE dnDevNode,
             IN ULONG   ulHardwareProfile,
             IN ULONG   ulFlags,
             IN HANDLE  hMachine
             );
#define CM_Delete_DevInst_Key       CM_Delete_DevNode_Key
#define CM_Delete_DevInst_Key_Ex    CM_Delete_DevNode_Key_Ex


CMAPI
CONFIGRET
WINAPI
CM_Delete_Range(
             IN DWORDLONG  ullStartValue,
             IN DWORDLONG  ullEndValue,
             IN RANGE_LIST rlh,
             IN ULONG      ulFlags
             );


CMAPI
CONFIGRET
WINAPI
CM_Detect_Resource_Conflict(
             IN  DEVINST    dnDevInst,
             IN  RESOURCEID ResourceID,
             IN  PCVOID     ResourceData,
             IN  ULONG      ResourceLen,
             OUT PBOOL      pbConflictDetected,
             IN  ULONG      ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Detect_Resource_Conflict_Ex(
             IN  DEVINST    dnDevInst,
             IN  RESOURCEID ResourceID,
             IN  PCVOID     ResourceData,
             IN  ULONG      ResourceLen,
             OUT PBOOL      pbConflictDetected,
             IN  ULONG      ulFlags,
             IN  HMACHINE   hMachine
             );


CMAPI
CONFIGRET
WINAPI
CM_Disable_DevNode(
             IN DEVINST  dnDevInst,
             IN ULONG    ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Disable_DevNode_Ex(
             IN DEVINST  dnDevInst,
             IN ULONG    ulFlags,
             IN HMACHINE hMachine
             );
#define CM_Disable_DevInst       CM_Disable_DevNode
#define CM_Disable_DevInst_Ex    CM_Disable_DevNode_Ex



CMAPI
CONFIGRET
WINAPI
CM_Disconnect_Machine(
             IN HMACHINE   hMachine
             );


CMAPI
CONFIGRET
WINAPI
CM_Dup_Range_List(
             IN RANGE_LIST rlhOld,
             IN RANGE_LIST rlhNew,
             IN ULONG      ulFlags
             );


CMAPI
CONFIGRET
WINAPI
CM_Enable_DevNode(
             IN DEVINST  dnDevInst,
             IN ULONG    ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Enable_DevNode_Ex(
             IN DEVINST  dnDevInst,
             IN ULONG    ulFlags,
             IN HMACHINE hMachine
             );
#define CM_Enable_DevInst        CM_Enable_DevNode
#define CM_Enable_DevInst_Ex     CM_Enable_DevNode_Ex



CMAPI
CONFIGRET
WINAPI
CM_Enumerate_Classes(
             IN  ULONG      ulClassIndex,
             OUT LPGUID     ClassGuid,
             IN  ULONG      ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Enumerate_Classes_Ex(
             IN  ULONG      ulClassIndex,
             OUT LPGUID     ClassGuid,
             IN  ULONG      ulFlags,
             IN  HMACHINE   hMachine
             );


CMAPI
CONFIGRET
WINAPI
CM_Enumerate_EnumeratorsA(
             IN ULONG      ulEnumIndex,
             OUT PCHAR     Buffer,
             IN OUT PULONG pulLength,
             IN ULONG      ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Enumerate_EnumeratorsW(
             IN ULONG      ulEnumIndex,
             OUT PWCHAR    Buffer,
             IN OUT PULONG pulLength,
             IN ULONG      ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Enumerate_Enumerators_ExA(
             IN ULONG      ulEnumIndex,
             OUT PCHAR     Buffer,
             IN OUT PULONG pulLength,
             IN ULONG      ulFlags,
             IN HMACHINE   hMachine
             );
CMAPI
CONFIGRET
WINAPI
CM_Enumerate_Enumerators_ExW(
             IN ULONG      ulEnumIndex,
             OUT PWCHAR    Buffer,
             IN OUT PULONG pulLength,
             IN ULONG      ulFlags,
             IN HMACHINE   hMachine
             );
#ifdef UNICODE
#define CM_Enumerate_Enumerators       CM_Enumerate_EnumeratorsW
#define CM_Enumerate_Enumerators_Ex    CM_Enumerate_Enumerators_ExW
#else
#define CM_Enumerate_Enumerators       CM_Enumerate_EnumeratorsA
#define CM_Enumerate_Enumerators_Ex    CM_Enumerate_Enumerators_ExA
#endif // UNICODE


CMAPI
CONFIGRET
WINAPI
CM_Find_Range(
             OUT PDWORDLONG pullStart,
             IN  DWORDLONG  ullStart,
             IN  ULONG      ulLength,
             IN  DWORDLONG  ullAlignment,
             IN  DWORDLONG  ullEnd,
             IN  RANGE_LIST rlh,
             IN  ULONG      ulFlags
             );


CMAPI
CONFIGRET
WINAPI
CM_First_Range(
             IN  RANGE_LIST     rlh,
             OUT PDWORDLONG     pullStart,
             OUT PDWORDLONG     pullEnd,
             OUT PRANGE_ELEMENT preElement,
             IN  ULONG          ulFlags
             );


CMAPI
CONFIGRET
WINAPI
CM_Free_Log_Conf(
             IN LOG_CONF lcLogConfToBeFreed,
             IN ULONG    ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Free_Log_Conf_Ex(
             IN LOG_CONF lcLogConfToBeFreed,
             IN ULONG    ulFlags,
             IN HMACHINE hMachine
             );


CMAPI
CONFIGRET
WINAPI
CM_Free_Log_Conf_Handle(
            IN  LOG_CONF  lcLogConf
            );


CMAPI
CONFIGRET
WINAPI
CM_Free_Range_List(
             IN RANGE_LIST rlh,
             IN ULONG      ulFlags
             );


CMAPI
CONFIGRET
WINAPI
CM_Free_Res_Des(
             OUT PRES_DES prdResDes,
             IN  RES_DES  rdResDes,
             IN  ULONG    ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Free_Res_Des_Ex(
             OUT PRES_DES prdResDes,
             IN  RES_DES  rdResDes,
             IN  ULONG    ulFlags,
             IN  HMACHINE hMachine
             );


CMAPI
CONFIGRET
WINAPI
CM_Free_Res_Des_Handle(
            IN  RES_DES    rdResDes
            );


CMAPI
CONFIGRET
WINAPI
CM_Get_Child(
             OUT PDEVINST pdnDevInst,
             IN  DEVINST  dnDevInst,
             IN  ULONG    ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Get_Child_Ex(
             OUT PDEVINST pdnDevInst,
             IN  DEVINST  dnDevInst,
             IN  ULONG    ulFlags,
             IN  HMACHINE hMachine
             );


CMAPI
CONFIGRET
WINAPI
CM_Get_Class_NameA(
             IN  LPGUID     ClassGuid,
             OUT PCHAR      Buffer,
             IN OUT PULONG  pulLength,
             IN  ULONG      ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Get_Class_NameW(
             IN  LPGUID     ClassGuid,
             OUT PWCHAR     Buffer,
             IN OUT PULONG  pulLength,
             IN  ULONG      ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Get_Class_Name_ExA(
             IN  LPGUID     ClassGuid,
             OUT PCHAR      Buffer,
             IN OUT PULONG  pulLength,
             IN  ULONG      ulFlags,
             IN  HMACHINE   hMachine
             );
CMAPI
CONFIGRET
WINAPI
CM_Get_Class_Name_ExW(
             IN  LPGUID     ClassGuid,
             OUT PWCHAR     Buffer,
             IN OUT PULONG  pulLength,
             IN  ULONG      ulFlags,
             IN  HMACHINE   hMachine
             );
#ifdef UNICODE
#define CM_Get_Class_Name        CM_Get_Class_NameW
#define CM_Get_Class_Name_Ex     CM_Get_Class_Name_ExW
#else
#define CM_Get_Class_Name        CM_Get_Class_NameA
#define CM_Get_Class_Name_Ex     CM_Get_Class_Name_ExA
#endif // UNICODE


CMAPI
CONFIGRET
WINAPI
CM_Get_Class_Key_NameA(
             IN  LPGUID     ClassGuid,
             OUT LPSTR      pszKeyName,
             IN OUT PULONG  pulLength,
             IN  ULONG      ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Get_Class_Key_NameW(
             IN  LPGUID     ClassGuid,
             OUT LPWSTR     pszKeyName,
             IN OUT PULONG  pulLength,
             IN  ULONG      ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Get_Class_Key_Name_ExA(
             IN  LPGUID     ClassGuid,
             OUT LPSTR      pszKeyName,
             IN OUT PULONG  pulLength,
             IN  ULONG      ulFlags,
             IN  HMACHINE   hMachine
             );
CMAPI
CONFIGRET
WINAPI
CM_Get_Class_Key_Name_ExW(
             IN  LPGUID     ClassGuid,
             OUT LPWSTR     pszKeyName,
             IN OUT PULONG  pulLength,
             IN  ULONG      ulFlags,
             IN  HMACHINE   hMachine
             );
#ifdef UNICODE
#define CM_Get_Class_Key_Name        CM_Get_Class_Key_NameW
#define CM_Get_Class_Key_Name_Ex     CM_Get_Class_Key_Name_ExW
#else
#define CM_Get_Class_Key_Name        CM_Get_Class_Key_NameA
#define CM_Get_Class_Key_Name_Ex     CM_Get_Class_Key_Name_ExA
#endif // UNICODE


CMAPI
CONFIGRET
WINAPI
CM_Get_Depth(
             OUT PULONG  pulDepth,
             IN  DEVINST dnDevInst,
             IN  ULONG   ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Get_Depth_Ex(
             OUT PULONG   pulDepth,
             IN  DEVINST  dnDevInst,
             IN  ULONG    ulFlags,
             IN  HMACHINE hMachine
             );


CMAPI
CONFIGRET
WINAPI
CM_Get_Device_IDA(
             IN  DEVINST  dnDevInst,
             OUT PCHAR    Buffer,
             IN  ULONG    BufferLen,
             IN  ULONG    ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Get_Device_IDW(
             IN  DEVINST  dnDevInst,
             OUT PWCHAR   Buffer,
             IN  ULONG    BufferLen,
             IN  ULONG    ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Get_Device_ID_ExA(
             IN  DEVINST  dnDevInst,
             OUT PCHAR    Buffer,
             IN  ULONG    BufferLen,
             IN  ULONG    ulFlags,
             IN  HMACHINE hMachine
             );
CMAPI
CONFIGRET
WINAPI
CM_Get_Device_ID_ExW(
             IN  DEVINST  dnDevInst,
             OUT PWCHAR   Buffer,
             IN  ULONG    BufferLen,
             IN  ULONG    ulFlags,
             IN  HMACHINE hMachine
             );
#ifdef UNICODE
#define CM_Get_Device_ID         CM_Get_Device_IDW
#define CM_Get_Device_ID_Ex      CM_Get_Device_ID_ExW
#else
#define CM_Get_Device_ID         CM_Get_Device_IDA
#define CM_Get_Device_ID_Ex      CM_Get_Device_ID_ExA
#endif // UNICODE



CMAPI
CONFIGRET
WINAPI
CM_Get_Device_ID_ListA(
             IN PCSTR    pszFilter,    OPTIONAL
             OUT PCHAR   Buffer,
             IN ULONG    BufferLen,
             IN ULONG    ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Get_Device_ID_ListW(
             IN PCWSTR   pszFilter,    OPTIONAL
             OUT PWCHAR  Buffer,
             IN ULONG    BufferLen,
             IN ULONG    ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Get_Device_ID_List_ExA(
             IN PCSTR    pszFilter,    OPTIONAL
             OUT PCHAR   Buffer,
             IN ULONG    BufferLen,
             IN ULONG    ulFlags,
             IN HMACHINE hMachine
             );
CMAPI
CONFIGRET
WINAPI
CM_Get_Device_ID_List_ExW(
             IN PCWSTR   pszFilter,    OPTIONAL
             OUT PWCHAR  Buffer,
             IN ULONG    BufferLen,
             IN ULONG    ulFlags,
             IN HMACHINE hMachine
             );
#ifdef UNICODE
#define CM_Get_Device_ID_List       CM_Get_Device_ID_ListW
#define CM_Get_Device_ID_List_Ex    CM_Get_Device_ID_List_ExW
#else
#define CM_Get_Device_ID_List       CM_Get_Device_ID_ListA
#define CM_Get_Device_ID_List_Ex    CM_Get_Device_ID_List_ExA
#endif // UNICODE



CMAPI
CONFIGRET
WINAPI
CM_Get_Device_ID_List_SizeA(
             OUT PULONG  pulLen,
             IN PCSTR    pszFilter,   OPTIONAL
             IN ULONG    ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Get_Device_ID_List_SizeW(
             OUT PULONG  pulLen,
             IN PCWSTR   pszFilter,   OPTIONAL
             IN ULONG    ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Get_Device_ID_List_Size_ExA(
             OUT PULONG  pulLen,
             IN PCSTR    pszFilter,   OPTIONAL
             IN ULONG    ulFlags,
             IN HMACHINE hMachine
             );
CMAPI
CONFIGRET
WINAPI
CM_Get_Device_ID_List_Size_ExW(
             OUT PULONG  pulLen,
             IN PCWSTR   pszFilter,   OPTIONAL
             IN ULONG    ulFlags,
             IN HMACHINE hMachine
             );
#ifdef UNICODE
#define CM_Get_Device_ID_List_Size    CM_Get_Device_ID_List_SizeW
#define CM_Get_Device_ID_List_Size_Ex CM_Get_Device_ID_List_Size_ExW
#else
#define CM_Get_Device_ID_List_Size    CM_Get_Device_ID_List_SizeA
#define CM_Get_Device_ID_List_Size_Ex CM_Get_Device_ID_List_Size_ExA
#endif // UNICODE



CMAPI
CONFIGRET
WINAPI
CM_Get_Device_ID_Size(
             OUT PULONG   pulLen,
             IN  DEVINST  dnDevInst,
             IN  ULONG    ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Get_Device_ID_Size_Ex(
             OUT PULONG   pulLen,
             IN  DEVINST  dnDevInst,
             IN  ULONG    ulFlags,
             IN  HMACHINE hMachine
             );



CMAPI
CONFIGRET
WINAPI
CM_Get_DevNode_Registry_PropertyA(
             IN  DEVINST     dnDevInst,
             IN  ULONG       ulProperty,
             OUT PULONG      pulRegDataType,   OPTIONAL
             OUT PVOID       Buffer,           OPTIONAL
             IN  OUT PULONG  pulLength,
             IN  ULONG       ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Get_DevNode_Registry_PropertyW(
             IN  DEVINST     dnDevInst,
             IN  ULONG       ulProperty,
             OUT PULONG      pulRegDataType,   OPTIONAL
             OUT PVOID       Buffer,           OPTIONAL
             IN  OUT PULONG  pulLength,
             IN  ULONG       ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Get_DevNode_Registry_Property_ExA(
             IN  DEVINST     dnDevInst,
             IN  ULONG       ulProperty,
             OUT PULONG      pulRegDataType,   OPTIONAL
             OUT PVOID       Buffer,           OPTIONAL
             IN  OUT PULONG  pulLength,
             IN  ULONG       ulFlags,
             IN  HMACHINE    hMachine
             );
CMAPI
CONFIGRET
WINAPI
CM_Get_DevNode_Registry_Property_ExW(
             IN  DEVINST     dnDevInst,
             IN  ULONG       ulProperty,
             OUT PULONG      pulRegDataType,   OPTIONAL
             OUT PVOID       Buffer,           OPTIONAL
             IN  OUT PULONG  pulLength,
             IN  ULONG       ulFlags,
             IN  HMACHINE    hMachine
             );
#define CM_Get_DevInst_Registry_PropertyW     CM_Get_DevNode_Registry_PropertyW
#define CM_Get_DevInst_Registry_PropertyA     CM_Get_DevNode_Registry_PropertyA
#define CM_Get_DevInst_Registry_Property_ExW  CM_Get_DevNode_Registry_Property_ExW
#define CM_Get_DevInst_Registry_Property_ExA  CM_Get_DevNode_Registry_Property_ExA
#ifdef UNICODE
#define CM_Get_DevInst_Registry_Property      CM_Get_DevNode_Registry_PropertyW
#define CM_Get_DevInst_Registry_Property_Ex   CM_Get_DevNode_Registry_Property_ExW
#define CM_Get_DevNode_Registry_Property      CM_Get_DevNode_Registry_PropertyW
#define CM_Get_DevNode_Registry_Property_Ex   CM_Get_DevNode_Registry_Property_ExW
#else
#define CM_Get_DevInst_Registry_Property      CM_Get_DevNode_Registry_PropertyA
#define CM_Get_DevInst_Registry_Property_Ex   CM_Get_DevNode_Registry_Property_ExA
#define CM_Get_DevNode_Registry_Property      CM_Get_DevNode_Registry_PropertyA
#define CM_Get_DevNode_Registry_Property_Ex   CM_Get_DevNode_Registry_Property_ExA
#endif // UNICODE


CMAPI
CONFIGRET
WINAPI
CM_Get_DevNode_Custom_PropertyA(
             IN  DEVINST     dnDevInst,
             IN  PCSTR       pszCustomPropertyName,
             OUT PULONG      pulRegDataType,        OPTIONAL
             OUT PVOID       Buffer,                OPTIONAL
             IN  OUT PULONG  pulLength,
             IN  ULONG       ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Get_DevNode_Custom_PropertyW(
             IN  DEVINST     dnDevInst,
             IN  PCWSTR      pszCustomPropertyName,
             OUT PULONG      pulRegDataType,        OPTIONAL
             OUT PVOID       Buffer,                OPTIONAL
             IN  OUT PULONG  pulLength,
             IN  ULONG       ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Get_DevNode_Custom_Property_ExA(
             IN  DEVINST     dnDevInst,
             IN  PCSTR       pszCustomPropertyName,
             OUT PULONG      pulRegDataType,        OPTIONAL
             OUT PVOID       Buffer,                OPTIONAL
             IN  OUT PULONG  pulLength,
             IN  ULONG       ulFlags,
             IN  HMACHINE    hMachine
             );
CMAPI
CONFIGRET
WINAPI
CM_Get_DevNode_Custom_Property_ExW(
             IN  DEVINST     dnDevInst,
             IN  PCWSTR      pszCustomPropertyName,
             OUT PULONG      pulRegDataType,        OPTIONAL
             OUT PVOID       Buffer,                OPTIONAL
             IN  OUT PULONG  pulLength,
             IN  ULONG       ulFlags,
             IN  HMACHINE    hMachine
             );
#define CM_Get_DevInst_Custom_PropertyW     CM_Get_DevNode_Custom_PropertyW
#define CM_Get_DevInst_Custom_PropertyA     CM_Get_DevNode_Custom_PropertyA
#define CM_Get_DevInst_Custom_Property_ExW  CM_Get_DevNode_Custom_Property_ExW
#define CM_Get_DevInst_Custom_Property_ExA  CM_Get_DevNode_Custom_Property_ExA
#ifdef UNICODE
#define CM_Get_DevInst_Custom_Property      CM_Get_DevNode_Custom_PropertyW
#define CM_Get_DevInst_Custom_Property_Ex   CM_Get_DevNode_Custom_Property_ExW
#define CM_Get_DevNode_Custom_Property      CM_Get_DevNode_Custom_PropertyW
#define CM_Get_DevNode_Custom_Property_Ex   CM_Get_DevNode_Custom_Property_ExW
#else
#define CM_Get_DevInst_Custom_Property      CM_Get_DevNode_Custom_PropertyA
#define CM_Get_DevInst_Custom_Property_Ex   CM_Get_DevNode_Custom_Property_ExA
#define CM_Get_DevNode_Custom_Property      CM_Get_DevNode_Custom_PropertyA
#define CM_Get_DevNode_Custom_Property_Ex   CM_Get_DevNode_Custom_Property_ExA
#endif // UNICODE


CMAPI
CONFIGRET
WINAPI
CM_Get_DevNode_Status(
             OUT PULONG   pulStatus,
             OUT PULONG   pulProblemNumber,
             IN  DEVINST  dnDevInst,
             IN  ULONG    ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Get_DevNode_Status_Ex(
             OUT PULONG   pulStatus,
             OUT PULONG   pulProblemNumber,
             IN  DEVINST  dnDevInst,
             IN  ULONG    ulFlags,
             IN  HMACHINE hMachine
             );
#define CM_Get_DevInst_Status    CM_Get_DevNode_Status
#define CM_Get_DevInst_Status_Ex CM_Get_DevNode_Status_Ex


CMAPI
CONFIGRET
WINAPI
CM_Get_First_Log_Conf(
             OUT PLOG_CONF plcLogConf,          OPTIONAL
             IN  DEVINST   dnDevInst,
             IN  ULONG     ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Get_First_Log_Conf_Ex(
             OUT PLOG_CONF plcLogConf,          OPTIONAL
             IN  DEVINST   dnDevInst,
             IN  ULONG     ulFlags,
             IN  HMACHINE  hMachine
             );


CMAPI
CONFIGRET
WINAPI
CM_Get_Global_State(
             OUT PULONG pulState,
             IN  ULONG  ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Get_Global_State_Ex(
             OUT PULONG   pulState,
             IN  ULONG    ulFlags,
             IN  HMACHINE hMachine
             );


CMAPI
CONFIGRET
WINAPI
CM_Get_Hardware_Profile_InfoA(
             IN  ULONG            ulIndex,
             OUT PHWPROFILEINFO_A pHWProfileInfo,
             IN  ULONG            ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Get_Hardware_Profile_Info_ExA(
             IN  ULONG            ulIndex,
             OUT PHWPROFILEINFO_A pHWProfileInfo,
             IN  ULONG            ulFlags,
             IN  HMACHINE         hMachine
             );
CMAPI
CONFIGRET
WINAPI
CM_Get_Hardware_Profile_InfoW(
             IN  ULONG            ulIndex,
             OUT PHWPROFILEINFO_W pHWProfileInfo,
             IN  ULONG            ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Get_Hardware_Profile_Info_ExW(
             IN  ULONG            ulIndex,
             OUT PHWPROFILEINFO_W pHWProfileInfo,
             IN  ULONG            ulFlags,
             IN  HMACHINE         hMachine
             );
#ifdef UNICODE
#define CM_Get_Hardware_Profile_Info      CM_Get_Hardware_Profile_InfoW
#define CM_Get_Hardware_Profile_Info_Ex   CM_Get_Hardware_Profile_Info_ExW
#else
#define CM_Get_Hardware_Profile_Info      CM_Get_Hardware_Profile_InfoA
#define CM_Get_Hardware_Profile_Info_Ex   CM_Get_Hardware_Profile_Info_ExA
#endif // UNICODE



CMAPI
CONFIGRET
WINAPI
CM_Get_HW_Prof_FlagsA(
             IN  DEVINSTID_A szDevInstName,
             IN  ULONG       ulHardwareProfile,
             OUT PULONG      pulValue,
             IN  ULONG       ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Get_HW_Prof_FlagsW(
             IN  DEVINSTID_W szDevInstName,
             IN  ULONG       ulHardwareProfile,
             OUT PULONG      pulValue,
             IN  ULONG       ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Get_HW_Prof_Flags_ExA(
             IN  DEVINSTID_A szDevInstName,
             IN  ULONG       ulHardwareProfile,
             OUT PULONG      pulValue,
             IN  ULONG       ulFlags,
             IN  HMACHINE    hMachine
             );
CMAPI
CONFIGRET
WINAPI
CM_Get_HW_Prof_Flags_ExW(
             IN  DEVINSTID_W szDevInstName,
             IN  ULONG       ulHardwareProfile,
             OUT PULONG      pulValue,
             IN  ULONG       ulFlags,
             IN  HMACHINE    hMachine
             );
#ifdef UNICODE
#define CM_Get_HW_Prof_Flags     CM_Get_HW_Prof_FlagsW
#define CM_Get_HW_Prof_Flags_Ex  CM_Get_HW_Prof_Flags_ExW
#else
#define CM_Get_HW_Prof_Flags     CM_Get_HW_Prof_FlagsA
#define CM_Get_HW_Prof_Flags_Ex  CM_Get_HW_Prof_Flags_ExA
#endif // UNICODE


CMAPI
CONFIGRET
WINAPI
CM_Get_Device_Interface_AliasA(
    IN     LPCSTR  pszDeviceInterface,
    IN     LPGUID  AliasInterfaceGuid,
    OUT    LPSTR   pszAliasDeviceInterface,
    IN OUT PULONG  pulLength,
    IN     ULONG   ulFlags
    );
CMAPI
CONFIGRET
WINAPI
CM_Get_Device_Interface_AliasW(
    IN     LPCWSTR pszDeviceInterface,
    IN     LPGUID  AliasInterfaceGuid,
    OUT    LPWSTR  pszAliasDeviceInterface,
    IN OUT PULONG  pulLength,
    IN     ULONG   ulFlags
    );
CMAPI
CONFIGRET
WINAPI
CM_Get_Device_Interface_Alias_ExA(
    IN     LPCSTR   pszDeviceInterface,
    IN     LPGUID   AliasInterfaceGuid,
    OUT    LPSTR    pszAliasDeviceInterface,
    IN OUT PULONG   pulLength,
    IN     ULONG    ulFlags,
    IN     HMACHINE hMachine
    );
CMAPI
CONFIGRET
WINAPI
CM_Get_Device_Interface_Alias_ExW(
    IN     LPCWSTR  pszDeviceInterface,
    IN     LPGUID   AliasInterfaceGuid,
    OUT    LPWSTR   pszAliasDeviceInterface,
    IN OUT PULONG   pulLength,
    IN     ULONG    ulFlags,
    IN     HMACHINE hMachine
    );
#ifdef UNICODE
#define CM_Get_Device_Interface_Alias     CM_Get_Device_Interface_AliasW
#define CM_Get_Device_Interface_Alias_Ex  CM_Get_Device_Interface_Alias_ExW
#else
#define CM_Get_Device_Interface_Alias     CM_Get_Device_Interface_AliasA
#define CM_Get_Device_Interface_Alias_Ex  CM_Get_Device_Interface_Alias_ExA
#endif // UNICODE



CMAPI
CONFIGRET
WINAPI
CM_Get_Device_Interface_ListA(
             IN  LPGUID      InterfaceClassGuid,
             IN  DEVINSTID_A pDeviceID,      OPTIONAL
             OUT PCHAR       Buffer,
             IN  ULONG       BufferLen,
             IN  ULONG       ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Get_Device_Interface_ListW(
             IN  LPGUID      InterfaceClassGuid,
             IN  DEVINSTID_W pDeviceID,      OPTIONAL
             OUT PWCHAR      Buffer,
             IN  ULONG       BufferLen,
             IN  ULONG       ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Get_Device_Interface_List_ExA(
             IN  LPGUID      InterfaceClassGuid,
             IN  DEVINSTID_A pDeviceID,      OPTIONAL
             OUT PCHAR       Buffer,
             IN  ULONG       BufferLen,
             IN  ULONG       ulFlags,
             IN  HMACHINE    hMachine
             );
CMAPI
CONFIGRET
WINAPI
CM_Get_Device_Interface_List_ExW(
             IN  LPGUID      InterfaceClassGuid,
             IN  DEVINSTID_W pDeviceID,      OPTIONAL
             OUT PWCHAR      Buffer,
             IN  ULONG       BufferLen,
             IN  ULONG       ulFlags,
             IN  HMACHINE    hMachine
             );
#ifdef UNICODE
#define CM_Get_Device_Interface_List     CM_Get_Device_Interface_ListW
#define CM_Get_Device_Interface_List_Ex  CM_Get_Device_Interface_List_ExW
#else
#define CM_Get_Device_Interface_List     CM_Get_Device_Interface_ListA
#define CM_Get_Device_Interface_List_Ex  CM_Get_Device_Interface_List_ExA
#endif // UNICODE


CMAPI
CONFIGRET
WINAPI
CM_Get_Device_Interface_List_SizeA(
             IN  PULONG      pulLen,
             IN  LPGUID      InterfaceClassGuid,
             IN  DEVINSTID_A pDeviceID,      OPTIONAL
             IN  ULONG       ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Get_Device_Interface_List_SizeW(
             IN  PULONG      pulLen,
             IN  LPGUID      InterfaceClassGuid,
             IN  DEVINSTID_W pDeviceID,      OPTIONAL
             IN  ULONG       ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Get_Device_Interface_List_Size_ExA(
             IN  PULONG      pulLen,
             IN  LPGUID      InterfaceClassGuid,
             IN  DEVINSTID_A pDeviceID,      OPTIONAL
             IN  ULONG       ulFlags,
             IN  HMACHINE    hMachine
             );
CMAPI
CONFIGRET
WINAPI
CM_Get_Device_Interface_List_Size_ExW(
             IN  PULONG      pulLen,
             IN  LPGUID      InterfaceClassGuid,
             IN  DEVINSTID_W pDeviceID,      OPTIONAL
             IN  ULONG       ulFlags,
             IN  HMACHINE    hMachine
             );
#ifdef UNICODE
#define CM_Get_Device_Interface_List_Size     CM_Get_Device_Interface_List_SizeW
#define CM_Get_Device_Interface_List_Size_Ex  CM_Get_Device_Interface_List_Size_ExW
#else
#define CM_Get_Device_Interface_List_Size     CM_Get_Device_Interface_List_SizeA
#define CM_Get_Device_Interface_List_Size_Ex  CM_Get_Device_Interface_List_Size_ExA
#endif // UNICODE


CMAPI
CONFIGRET
WINAPI
CM_Get_Log_Conf_Priority(
        IN  LOG_CONF  lcLogConf,
        OUT PPRIORITY pPriority,
        IN  ULONG     ulFlags
        );
CMAPI
CONFIGRET
WINAPI
CM_Get_Log_Conf_Priority_Ex(
        IN  LOG_CONF  lcLogConf,
        OUT PPRIORITY pPriority,
        IN  ULONG     ulFlags,
        IN  HMACHINE  hMachine
        );


CMAPI
CONFIGRET
WINAPI
CM_Get_Next_Log_Conf(
             OUT PLOG_CONF plcLogConf,  OPTIONAL
             IN  LOG_CONF  lcLogConf,
             IN  ULONG     ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Get_Next_Log_Conf_Ex(
             OUT PLOG_CONF plcLogConf,          OPTIONAL
             IN  LOG_CONF  lcLogConf,
             IN  ULONG     ulFlags,
             IN  HMACHINE  hMachine
             );


CMAPI
CONFIGRET
WINAPI
CM_Get_Parent(
             OUT PDEVINST pdnDevInst,
             IN  DEVINST  dnDevInst,
             IN  ULONG    ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Get_Parent_Ex(
             OUT PDEVINST pdnDevInst,
             IN  DEVINST  dnDevInst,
             IN  ULONG    ulFlags,
             IN  HMACHINE hMachine
             );

CMAPI
CONFIGRET
WINAPI
CM_Get_Res_Des_Data(
             IN  RES_DES  rdResDes,
             OUT PVOID    Buffer,
             IN  ULONG    BufferLen,
             IN  ULONG    ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Get_Res_Des_Data_Ex(
             IN  RES_DES  rdResDes,
             OUT PVOID    Buffer,
             IN  ULONG    BufferLen,
             IN  ULONG    ulFlags,
             IN  HMACHINE hMachine
             );


CMAPI
CONFIGRET
WINAPI
CM_Get_Res_Des_Data_Size(
             OUT PULONG   pulSize,
             IN  RES_DES  rdResDes,
             IN  ULONG    ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Get_Res_Des_Data_Size_Ex(
             OUT PULONG   pulSize,
             IN  RES_DES  rdResDes,
             IN  ULONG    ulFlags,
             IN  HMACHINE hMachine
             );


CMAPI
CONFIGRET
WINAPI
CM_Get_Sibling(
             OUT PDEVINST pdnDevInst,
             IN  DEVINST  DevInst,
             IN  ULONG    ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Get_Sibling_Ex(
             OUT PDEVINST pdnDevInst,
             IN  DEVINST  DevInst,
             IN  ULONG    ulFlags,
             IN  HMACHINE hMachine
             );



CMAPI
WORD
WINAPI
CM_Get_Version(
             VOID
             );
CMAPI
WORD
WINAPI
CM_Get_Version_Ex(
             IN  HMACHINE    hMachine
             );



CMAPI
BOOL
WINAPI
CM_Is_Version_Available(
             IN  WORD       wVersion
             );
CMAPI
BOOL
WINAPI
CM_Is_Version_Available_Ex(
             IN  WORD       wVersion,
             IN  HMACHINE   hMachine
             );



CMAPI
CONFIGRET
WINAPI
CM_Intersect_Range_List(
             IN RANGE_LIST rlhOld1,
             IN RANGE_LIST rlhOld2,
             IN RANGE_LIST rlhNew,
             IN ULONG      ulFlags
             );


CMAPI
CONFIGRET
WINAPI
CM_Invert_Range_List(
             IN RANGE_LIST rlhOld,
             IN RANGE_LIST rlhNew,
             IN DWORDLONG  ullMaxValue,
             IN ULONG      ulFlags
             );


CMAPI
CONFIGRET
WINAPI
CM_Locate_DevNodeA(
             OUT PDEVINST    pdnDevInst,
             IN  DEVINSTID_A pDeviceID,    OPTIONAL
             IN  ULONG       ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Locate_DevNodeW(
             OUT PDEVINST    pdnDevInst,
             IN  DEVINSTID_W pDeviceID,   OPTIONAL
             IN  ULONG       ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Locate_DevNode_ExA(
             OUT PDEVINST    pdnDevInst,
             IN  DEVINSTID_A pDeviceID,    OPTIONAL
             IN  ULONG       ulFlags,
             IN  HMACHINE    hMachine
             );
CMAPI
CONFIGRET
WINAPI
CM_Locate_DevNode_ExW(
             OUT PDEVINST    pdnDevInst,
             IN  DEVINSTID_W pDeviceID,   OPTIONAL
             IN  ULONG       ulFlags,
             IN  HMACHINE    hMachine
             );
#define CM_Locate_DevInstA       CM_Locate_DevNodeA
#define CM_Locate_DevInstW       CM_Locate_DevNodeW
#define CM_Locate_DevInst_ExA    CM_Locate_DevNode_ExA
#define CM_Locate_DevInst_ExW    CM_Locate_DevNode_ExW
#ifdef UNICODE
#define CM_Locate_DevNode        CM_Locate_DevNodeW
#define CM_Locate_DevInst        CM_Locate_DevNodeW
#define CM_Locate_DevNode_Ex     CM_Locate_DevNode_ExW
#define CM_Locate_DevInst_Ex     CM_Locate_DevNode_ExW
#else
#define CM_Locate_DevNode        CM_Locate_DevNodeA
#define CM_Locate_DevInst        CM_Locate_DevNodeA
#define CM_Locate_DevNode_Ex     CM_Locate_DevNode_ExA
#define CM_Locate_DevInst_Ex     CM_Locate_DevNode_ExA
#endif // UNICODE


CMAPI
CONFIGRET
WINAPI
CM_Merge_Range_List(
             IN RANGE_LIST rlhOld1,
             IN RANGE_LIST rlhOld2,
             IN RANGE_LIST rlhNew,
             IN ULONG      ulFlags
             );


CMAPI
CONFIGRET
WINAPI
CM_Modify_Res_Des(
             OUT PRES_DES   prdResDes,
             IN  RES_DES    rdResDes,
             IN  RESOURCEID ResourceID,
             IN  PCVOID     ResourceData,
             IN  ULONG      ResourceLen,
             IN  ULONG      ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Modify_Res_Des_Ex(
             OUT PRES_DES   prdResDes,
             IN  RES_DES    rdResDes,
             IN  RESOURCEID ResourceID,
             IN  PCVOID     ResourceData,
             IN  ULONG      ResourceLen,
             IN  ULONG      ulFlags,
             IN  HMACHINE   hMachine
             );


CMAPI
CONFIGRET
WINAPI
CM_Move_DevNode(
             IN DEVINST  dnFromDevInst,
             IN DEVINST  dnToDevInst,
             IN ULONG    ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Move_DevNode_Ex(
             IN DEVINST  dnFromDevInst,
             IN DEVINST  dnToDevInst,
             IN ULONG    ulFlags,
             IN HMACHINE hMachine
             );
#define CM_Move_DevInst          CM_Move_DevNode
#define CM_Move_DevInst_Ex       CM_Move_DevNode_Ex


CMAPI
CONFIGRET
WINAPI
CM_Next_Range(
             IN OUT PRANGE_ELEMENT preElement,
             OUT PDWORDLONG        pullStart,
             OUT PDWORDLONG        pullEnd,
             IN  ULONG             ulFlags
             );


CMAPI
CONFIGRET
WINAPI
CM_Get_Next_Res_Des(
             OUT PRES_DES    prdResDes,
             IN  RES_DES     rdResDes,
             IN  RESOURCEID  ForResource,
             OUT PRESOURCEID pResourceID,
             IN  ULONG       ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Get_Next_Res_Des_Ex(
             OUT PRES_DES    prdResDes,
             IN  RES_DES     rdResDes,
             IN  RESOURCEID  ForResource,
             OUT PRESOURCEID pResourceID,
             IN  ULONG       ulFlags,
             IN  HMACHINE    hMachine
             );


CMAPI
CONFIGRET
WINAPI
CM_Open_Class_KeyA(
             IN  LPGUID         ClassGuid,      OPTIONAL
             IN  LPCSTR         pszClassName,   OPTIONAL
             IN  REGSAM         samDesired,
             IN  REGDISPOSITION Disposition,
             OUT PHKEY          phkClass,
             IN  ULONG          ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Open_Class_KeyW(
             IN  LPGUID         ClassGuid,      OPTIONAL
             IN  LPCWSTR        pszClassName,   OPTIONAL
             IN  REGSAM         samDesired,
             IN  REGDISPOSITION Disposition,
             OUT PHKEY          phkClass,
             IN  ULONG          ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Open_Class_Key_ExA(
             IN  LPGUID         pszClassGuid,      OPTIONAL
             IN  LPCSTR         pszClassName,      OPTIONAL
             IN  REGSAM         samDesired,
             IN  REGDISPOSITION Disposition,
             OUT PHKEY          phkClass,
             IN  ULONG          ulFlags,
             IN  HMACHINE       hMachine
             );
CMAPI
CONFIGRET
WINAPI
CM_Open_Class_Key_ExW(
             IN  LPGUID         pszClassGuid,      OPTIONAL
             IN  LPCWSTR        pszClassName,      OPTIONAL
             IN  REGSAM         samDesired,
             IN  REGDISPOSITION Disposition,
             OUT PHKEY          phkClass,
             IN  ULONG          ulFlags,
             IN  HMACHINE       hMachine
             );

#ifdef UNICODE
#define CM_Open_Class_Key        CM_Open_Class_KeyW
#define CM_Open_Class_Key_Ex     CM_Open_Class_Key_ExW
#else
#define CM_Open_Class_Key        CM_Open_Class_KeyA
#define CM_Open_Class_Key_Ex     CM_Open_Class_Key_ExA
#endif // UNICODE



CMAPI
CONFIGRET
WINAPI
CM_Open_DevNode_Key(
             IN  DEVINST        dnDevNode,
             IN  REGSAM         samDesired,
             IN  ULONG          ulHardwareProfile,
             IN  REGDISPOSITION Disposition,
             OUT PHKEY          phkDevice,
             IN  ULONG          ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Open_DevNode_Key_Ex(
             IN  DEVINST        dnDevNode,
             IN  REGSAM         samDesired,
             IN  ULONG          ulHardwareProfile,
             IN  REGDISPOSITION Disposition,
             OUT PHKEY          phkDevice,
             IN  ULONG          ulFlags,
             IN  HMACHINE       hMachine
             );
#define CM_Open_DevInst_Key      CM_Open_DevNode_Key
#define CM_Open_DevInst_Key_Ex   CM_Open_DevNode_Key_Ex


CMAPI
CONFIGRET
WINAPI
CM_Query_Arbitrator_Free_Data(
             OUT PVOID      pData,
             IN  ULONG      DataLen,
             IN  DEVINST    dnDevInst,
             IN  RESOURCEID ResourceID,
             IN  ULONG      ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Query_Arbitrator_Free_Data_Ex(
             OUT PVOID      pData,
             IN  ULONG      DataLen,
             IN  DEVINST    dnDevInst,
             IN  RESOURCEID ResourceID,
             IN  ULONG      ulFlags,
             IN  HMACHINE   hMachine
             );


CMAPI
CONFIGRET
WINAPI
CM_Query_Arbitrator_Free_Size(
             OUT PULONG     pulSize,
             IN  DEVINST    dnDevInst,
             IN  RESOURCEID ResourceID,
             IN  ULONG      ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Query_Arbitrator_Free_Size_Ex(
             OUT PULONG     pulSize,
             IN  DEVINST    dnDevInst,
             IN  RESOURCEID ResourceID,
             IN  ULONG      ulFlags,
             IN  HMACHINE   hMachine
             );


CMAPI
CONFIGRET
WINAPI
CM_Query_Remove_SubTree(
             IN DEVINST  dnAncestor,
             IN ULONG    ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Query_Remove_SubTree_Ex(
             IN DEVINST  dnAncestor,
             IN ULONG    ulFlags,
             IN HMACHINE hMachine
             );


CMAPI
CONFIGRET
WINAPI
CM_Query_And_Remove_SubTreeA(
             IN  DEVINST        dnAncestor,
             OUT PPNP_VETO_TYPE pVetoType,
             OUT LPSTR          pszVetoName,
             IN  ULONG          ulNameLength,
             IN  ULONG          ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Query_And_Remove_SubTree_ExA(
             IN  DEVINST        dnAncestor,
             OUT PPNP_VETO_TYPE pVetoType,
             OUT LPSTR          pszVetoName,
             IN  ULONG          ulNameLength,
             IN  ULONG          ulFlags,
             IN  HMACHINE       hMachine
             );

CMAPI
CONFIGRET
WINAPI
CM_Query_And_Remove_SubTreeW(
             IN  DEVINST        dnAncestor,
             OUT PPNP_VETO_TYPE pVetoType,
             OUT LPWSTR         pszVetoName,
             IN  ULONG          ulNameLength,
             IN  ULONG          ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Query_And_Remove_SubTree_ExW(
             IN  DEVINST        dnAncestor,
             OUT PPNP_VETO_TYPE pVetoType,
             OUT LPWSTR         pszVetoName,
             IN  ULONG          ulNameLength,
             IN  ULONG          ulFlags,
             IN  HMACHINE       hMachine
             );

#ifdef UNICODE
#define CM_Query_And_Remove_SubTree     CM_Query_And_Remove_SubTreeW
#define CM_Query_And_Remove_SubTree_Ex  CM_Query_And_Remove_SubTree_ExW
#else
#define CM_Query_And_Remove_SubTree     CM_Query_And_Remove_SubTreeA
#define CM_Query_And_Remove_SubTree_Ex  CM_Query_And_Remove_SubTree_ExA
#endif // UNICODE

CMAPI
CONFIGRET
WINAPI
CM_Request_Device_EjectA(
            IN  DEVINST         dnDevInst,
            OUT PPNP_VETO_TYPE  pVetoType,
            OUT LPSTR           pszVetoName,
            IN  ULONG           ulNameLength,
            IN  ULONG           ulFlags
            );

CMAPI
CONFIGRET
WINAPI
CM_Request_Device_Eject_ExA(
             IN  DEVINST        dnDevInst,
             OUT PPNP_VETO_TYPE pVetoType,
             OUT LPSTR          pszVetoName,
             IN  ULONG          ulNameLength,
             IN  ULONG          ulFlags,
             IN  HMACHINE       hMachine
             );

CMAPI
CONFIGRET
WINAPI
CM_Request_Device_EjectW(
            IN  DEVINST         dnDevInst,
            OUT PPNP_VETO_TYPE  pVetoType,
            OUT LPWSTR          pszVetoName,
            IN  ULONG           ulNameLength,
            IN  ULONG           ulFlags
            );

CMAPI
CONFIGRET
WINAPI
CM_Request_Device_Eject_ExW(
             IN  DEVINST        dnDevInst,
             OUT PPNP_VETO_TYPE pVetoType,
             OUT LPWSTR         pszVetoName,
             IN  ULONG          ulNameLength,
             IN  ULONG          ulFlags,
             IN  HMACHINE       hMachine
             );

#ifdef UNICODE
#define CM_Request_Device_Eject         CM_Request_Device_EjectW
#define CM_Request_Device_Eject_Ex      CM_Request_Device_Eject_ExW
#else
#define CM_Request_Device_Eject         CM_Request_Device_EjectA
#define CM_Request_Device_Eject_Ex      CM_Request_Device_Eject_ExA
#endif // UNICODE

CMAPI
CONFIGRET
WINAPI
CM_Reenumerate_DevNode(
             IN DEVINST  dnDevInst,
             IN ULONG    ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Reenumerate_DevNode_Ex(
             IN DEVINST  dnDevInst,
             IN ULONG    ulFlags,
             IN HMACHINE hMachine
             );
#define CM_Reenumerate_DevInst      CM_Reenumerate_DevNode
#define CM_Reenumerate_DevInst_Ex   CM_Reenumerate_DevNode_Ex


CMAPI
CONFIGRET
WINAPI
CM_Register_Device_InterfaceA(
             IN  DEVINST   dnDevInst,
             IN  LPGUID    InterfaceClassGuid,
             IN  LPCSTR    pszReference,         OPTIONAL
             OUT LPSTR     pszDeviceInterface,
             IN OUT PULONG pulLength,
             IN  ULONG     ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Register_Device_InterfaceW(
             IN  DEVINST   dnDevInst,
             IN  LPGUID    InterfaceClassGuid,
             IN  LPCWSTR   pszReference,         OPTIONAL
             OUT LPWSTR    pszDeviceInterface,
             IN OUT PULONG pulLength,
             IN  ULONG     ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Register_Device_Interface_ExA(
             IN  DEVINST   dnDevInst,
             IN  LPGUID    InterfaceClassGuid,
             IN  LPCSTR    pszReference,         OPTIONAL
             OUT LPSTR     pszDeviceInterface,
             IN OUT PULONG pulLength,
             IN  ULONG     ulFlags,
             IN  HMACHINE  hMachine
             );
CMAPI
CONFIGRET
WINAPI
CM_Register_Device_Interface_ExW(
             IN  DEVINST   dnDevInst,
             IN  LPGUID    InterfaceClassGuid,
             IN  LPCWSTR   pszReference,         OPTIONAL
             OUT LPWSTR    pszDeviceInterface,
             IN OUT PULONG pulLength,
             IN  ULONG     ulFlags,
             IN  HMACHINE  hMachine
             );
#ifdef UNICODE
#define CM_Register_Device_Interface    CM_Register_Device_InterfaceW
#define CM_Register_Device_Interface_Ex CM_Register_Device_Interface_ExW
#else
#define CM_Register_Device_Interface    CM_Register_Device_InterfaceA
#define CM_Register_Device_Interface_Ex CM_Register_Device_Interface_ExA
#endif // UNICODE


CMAPI
CONFIGRET
WINAPI
CM_Set_DevNode_Problem_Ex(
    IN DEVINST   dnDevInst,
    IN ULONG     ulProblem,
    IN  ULONG    ulFlags,
    IN  HMACHINE hMachine
    );
CMAPI
CONFIGRET
WINAPI
CM_Set_DevNode_Problem(
    IN DEVINST   dnDevInst,
    IN ULONG     ulProblem,
    IN  ULONG    ulFlags
    );
#define CM_Set_DevInst_Problem      CM_Set_DevNode_Problem
#define CM_Set_DevInst_Problem_Ex   CM_Set_DevNode_Problem_Ex


CMAPI
CONFIGRET
WINAPI
CM_Unregister_Device_InterfaceA(
             IN LPCSTR pszDeviceInterface,
             IN ULONG  ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Unregister_Device_InterfaceW(
             IN LPCWSTR pszDeviceInterface,
             IN ULONG   ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Unregister_Device_Interface_ExA(
             IN LPCSTR   pszDeviceInterface,
             IN ULONG    ulFlags,
             IN HMACHINE hMachine
             );
CMAPI
CONFIGRET
WINAPI
CM_Unregister_Device_Interface_ExW(
             IN LPCWSTR  pszDeviceInterface,
             IN ULONG    ulFlags,
             IN HMACHINE hMachine
             );
#ifdef UNICODE
#define CM_Unregister_Device_Interface    CM_Unregister_Device_InterfaceW
#define CM_Unregister_Device_Interface_Ex CM_Unregister_Device_Interface_ExW
#else
#define CM_Unregister_Device_Interface    CM_Unregister_Device_InterfaceA
#define CM_Unregister_Device_Interface_Ex CM_Unregister_Device_Interface_ExA
#endif // UNICODE


CMAPI
CONFIGRET
WINAPI
CM_Register_Device_Driver(
            IN DEVINST  dnDevInst,
            IN ULONG    ulFlags
            );
CMAPI
CONFIGRET
WINAPI
CM_Register_Device_Driver_Ex(
            IN DEVINST  dnDevInst,
            IN ULONG    ulFlags,
            IN HMACHINE hMachine
            );

CMAPI
CONFIGRET
WINAPI
CM_Remove_SubTree(
             IN DEVINST  dnAncestor,
             IN ULONG    ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Remove_SubTree_Ex(
             IN DEVINST  dnAncestor,
             IN ULONG    ulFlags,
             IN HMACHINE hMachine
             );



CMAPI
CONFIGRET
WINAPI
CM_Set_DevNode_Registry_PropertyA(
             IN  DEVINST     dnDevInst,
             IN  ULONG       ulProperty,
             IN  PCVOID      Buffer,           OPTIONAL
             IN  ULONG       ulLength,
             IN  ULONG       ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Set_DevNode_Registry_PropertyW(
             IN  DEVINST     dnDevInst,
             IN  ULONG       ulProperty,
             IN  PCVOID      Buffer,           OPTIONAL
             IN  ULONG       ulLength,
             IN  ULONG       ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Set_DevNode_Registry_Property_ExA(
             IN  DEVINST     dnDevInst,
             IN  ULONG       ulProperty,
             IN  PCVOID      Buffer,           OPTIONAL
             IN  ULONG       ulLength,
             IN  ULONG       ulFlags,
             IN  HMACHINE    hMachine
             );
CMAPI
CONFIGRET
WINAPI
CM_Set_DevNode_Registry_Property_ExW(
             IN  DEVINST     dnDevInst,
             IN  ULONG       ulProperty,
             IN  PCVOID      Buffer,           OPTIONAL
             IN  ULONG       ulLength,
             IN  ULONG       ulFlags,
             IN  HMACHINE    hMachine
             );
#define CM_Set_DevInst_Registry_PropertyW     CM_Set_DevNode_Registry_PropertyW
#define CM_Set_DevInst_Registry_PropertyA     CM_Set_DevNode_Registry_PropertyA
#define CM_Set_DevInst_Registry_Property_ExW  CM_Set_DevNode_Registry_Property_ExW
#define CM_Set_DevInst_Registry_Property_ExA  CM_Set_DevNode_Registry_Property_ExA
#ifdef UNICODE
#define CM_Set_DevInst_Registry_Property      CM_Set_DevNode_Registry_PropertyW
#define CM_Set_DevInst_Registry_Property_Ex   CM_Set_DevNode_Registry_Property_ExW
#define CM_Set_DevNode_Registry_Property      CM_Set_DevNode_Registry_PropertyW
#define CM_Set_DevNode_Registry_Property_Ex   CM_Set_DevNode_Registry_Property_ExW
#else
#define CM_Set_DevInst_Registry_Property      CM_Set_DevNode_Registry_PropertyA
#define CM_Set_DevInst_Registry_Property_Ex   CM_Set_DevNode_Registry_Property_ExA
#define CM_Set_DevNode_Registry_Property      CM_Set_DevNode_Registry_PropertyA
#define CM_Set_DevNode_Registry_Property_Ex   CM_Set_DevNode_Registry_Property_ExA
#endif // UNICODE


CMAPI
CONFIGRET
WINAPI
CM_Is_Dock_Station_Present(
             OUT PBOOL pbPresent
             );

CMAPI
CONFIGRET
WINAPI
CM_Is_Dock_Station_Present_Ex(
             OUT PBOOL pbPresent,
             IN HMACHINE    hMachine
             );

CMAPI
CONFIGRET
WINAPI
CM_Request_Eject_PC(
             VOID
             );

CMAPI
CONFIGRET
WINAPI
CM_Request_Eject_PC_Ex(
             IN HMACHINE    hMachine
             );

CMAPI
CONFIGRET
WINAPI
CM_Set_HW_Prof_FlagsA(
             IN DEVINSTID_A szDevInstName,
             IN ULONG       ulConfig,
             IN ULONG       ulValue,
             IN ULONG       ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Set_HW_Prof_FlagsW(
             IN DEVINSTID_W szDevInstName,
             IN ULONG       ulConfig,
             IN ULONG       ulValue,
             IN ULONG       ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Set_HW_Prof_Flags_ExA(
             IN DEVINSTID_A szDevInstName,
             IN ULONG       ulConfig,
             IN ULONG       ulValue,
             IN ULONG       ulFlags,
             IN HMACHINE    hMachine
             );
CMAPI
CONFIGRET
WINAPI
CM_Set_HW_Prof_Flags_ExW(
             IN DEVINSTID_W szDevInstName,
             IN ULONG       ulConfig,
             IN ULONG       ulValue,
             IN ULONG       ulFlags,
             IN HMACHINE    hMachine
             );
#ifdef UNICODE
#define CM_Set_HW_Prof_Flags     CM_Set_HW_Prof_FlagsW
#define CM_Set_HW_Prof_Flags_Ex  CM_Set_HW_Prof_Flags_ExW
#else
#define CM_Set_HW_Prof_Flags     CM_Set_HW_Prof_FlagsA
#define CM_Set_HW_Prof_Flags_Ex  CM_Set_HW_Prof_Flags_ExA
#endif // UNICODE



CMAPI
CONFIGRET
WINAPI
CM_Setup_DevNode(
             IN DEVINST  dnDevInst,
             IN ULONG    ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Setup_DevNode_Ex(
             IN DEVINST  dnDevInst,
             IN ULONG    ulFlags,
             IN HMACHINE hMachine
             );
#define CM_Setup_DevInst         CM_Setup_DevNode
#define CM_Setup_DevInst_Ex      CM_Setup_DevNode_Ex


CMAPI
CONFIGRET
WINAPI
CM_Test_Range_Available(
             IN DWORDLONG  ullStartValue,
             IN DWORDLONG  ullEndValue,
             IN RANGE_LIST rlh,
             IN ULONG      ulFlags
             );


CMAPI
CONFIGRET
WINAPI
CM_Uninstall_DevNode(
             IN DEVNODE dnPhantom,
             IN ULONG   ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Uninstall_DevNode_Ex(
             IN DEVNODE dnPhantom,
             IN ULONG   ulFlags,
             IN HANDLE  hMachine
             );
#define CM_Uninstall_DevInst     CM_Uninstall_DevNode
#define CM_Uninstall_DevInst_Ex  CM_Uninstall_DevNode_Ex


CMAPI
CONFIGRET
WINAPI
CM_Run_Detection(
             IN ULONG    ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Run_Detection_Ex(
             IN ULONG    ulFlags,
             IN HMACHINE hMachine
             );


CMAPI
CONFIGRET
WINAPI
CM_Set_HW_Prof(
             IN ULONG    ulHardwareProfile,
             IN ULONG    ulFlags
             );
CMAPI
CONFIGRET
WINAPI
CM_Set_HW_Prof_Ex(
             IN ULONG    ulHardwareProfile,
             IN ULONG    ulFlags,
             IN HMACHINE hMachine
             );

CMAPI
CONFIGRET
WINAPI
CM_Query_Resource_Conflict_List(
             OUT PCONFLICT_LIST pclConflictList,
             IN  DEVINST        dnDevInst,
             IN  RESOURCEID     ResourceID,
             IN  PCVOID         ResourceData,
             IN  ULONG          ResourceLen,
             IN  ULONG          ulFlags,
             IN  HMACHINE       hMachine
             );

CMAPI
CONFIGRET
WINAPI
CM_Free_Resource_Conflict_Handle(
             IN CONFLICT_LIST   clConflictList
             );

CMAPI
CONFIGRET
WINAPI
CM_Get_Resource_Conflict_Count(
             IN CONFLICT_LIST   clConflictList,
             OUT PULONG         pulCount
             );

CMAPI
CONFIGRET
WINAPI
CM_Get_Resource_Conflict_DetailsA(
             IN CONFLICT_LIST         clConflictList,
             IN ULONG                 ulIndex,
             IN OUT PCONFLICT_DETAILS_A pConflictDetails
             );

CMAPI
CONFIGRET
WINAPI
CM_Get_Resource_Conflict_DetailsW(
             IN CONFLICT_LIST         clConflictList,
             IN ULONG                 ulIndex,
             IN OUT PCONFLICT_DETAILS_W pConflictDetails
             );

#ifdef UNICODE
#define CM_Get_Resource_Conflict_Details CM_Get_Resource_Conflict_DetailsW
#else
#define CM_Get_Resource_Conflict_Details CM_Get_Resource_Conflict_DetailsA
#endif // UNICODE

CMAPI
CONFIGRET
WINAPI
CM_Get_Class_Registry_PropertyW(
    IN  LPGUID      ClassGUID,
    IN  ULONG       ulProperty,
    OUT PULONG      pulRegDataType,    OPTIONAL
    OUT PVOID       Buffer,            OPTIONAL
    IN  OUT PULONG  pulLength,
    IN  ULONG       ulFlags,
    IN  HMACHINE    hMachine
    );

CMAPI
CONFIGRET
WINAPI
CM_Set_Class_Registry_PropertyW(
    IN LPGUID      ClassGUID,
    IN ULONG       ulProperty,
    IN PCVOID      Buffer,       OPTIONAL
    IN ULONG       ulLength,
    IN ULONG       ulFlags,
    IN HMACHINE    hMachine
    );

CMAPI
CONFIGRET
WINAPI
CM_Get_Class_Registry_PropertyA(
    IN  LPGUID      ClassGUID,
    IN  ULONG       ulProperty,
    OUT PULONG      pulRegDataType,    OPTIONAL
    OUT PVOID       Buffer,            OPTIONAL
    IN  OUT PULONG  pulLength,
    IN  ULONG       ulFlags,
    IN  HMACHINE    hMachine
    );

CMAPI
CONFIGRET
WINAPI
CM_Set_Class_Registry_PropertyA(
    IN LPGUID      ClassGUID,
    IN ULONG       ulProperty,
    IN PCVOID      Buffer,       OPTIONAL
    IN ULONG       ulLength,
    IN ULONG       ulFlags,
    IN HMACHINE    hMachine
    );

#ifdef UNICODE
#define CM_Get_Class_Registry_Property CM_Get_Class_Registry_PropertyW
#define CM_Set_Class_Registry_Property CM_Set_Class_Registry_PropertyW
#else
#define CM_Get_Class_Registry_Property CM_Get_Class_Registry_PropertyA
#define CM_Set_Class_Registry_Property CM_Set_Class_Registry_PropertyA
#endif // UNICODE

#define CM_WaitNoPendingInstallEvents CMP_WaitNoPendingInstallEvents

DWORD
WINAPI
CM_WaitNoPendingInstallEvents(
    IN DWORD dwTimeout
    );

//--------------------------------------------------------------
// Configuration Manager return status codes
//--------------------------------------------------------------

#define CR_SUCCESS                  (0x00000000)
#define CR_DEFAULT                  (0x00000001)
#define CR_OUT_OF_MEMORY            (0x00000002)
#define CR_INVALID_POINTER          (0x00000003)
#define CR_INVALID_FLAG             (0x00000004)
#define CR_INVALID_DEVNODE          (0x00000005)
#define CR_INVALID_DEVINST          CR_INVALID_DEVNODE
#define CR_INVALID_RES_DES          (0x00000006)
#define CR_INVALID_LOG_CONF         (0x00000007)
#define CR_INVALID_ARBITRATOR       (0x00000008)
#define CR_INVALID_NODELIST         (0x00000009)
#define CR_DEVNODE_HAS_REQS         (0x0000000A)
#define CR_DEVINST_HAS_REQS         CR_DEVNODE_HAS_REQS
#define CR_INVALID_RESOURCEID       (0x0000000B)
#define CR_DLVXD_NOT_FOUND          (0x0000000C)   // WIN 95 ONLY
#define CR_NO_SUCH_DEVNODE          (0x0000000D)
#define CR_NO_SUCH_DEVINST          CR_NO_SUCH_DEVNODE
#define CR_NO_MORE_LOG_CONF         (0x0000000E)
#define CR_NO_MORE_RES_DES          (0x0000000F)
#define CR_ALREADY_SUCH_DEVNODE     (0x00000010)
#define CR_ALREADY_SUCH_DEVINST     CR_ALREADY_SUCH_DEVNODE
#define CR_INVALID_RANGE_LIST       (0x00000011)
#define CR_INVALID_RANGE            (0x00000012)
#define CR_FAILURE                  (0x00000013)
#define CR_NO_SUCH_LOGICAL_DEV      (0x00000014)
#define CR_CREATE_BLOCKED           (0x00000015)
#define CR_NOT_SYSTEM_VM            (0x00000016)   // WIN 95 ONLY
#define CR_REMOVE_VETOED            (0x00000017)
#define CR_APM_VETOED               (0x00000018)
#define CR_INVALID_LOAD_TYPE        (0x00000019)
#define CR_BUFFER_SMALL             (0x0000001A)
#define CR_NO_ARBITRATOR            (0x0000001B)
#define CR_NO_REGISTRY_HANDLE       (0x0000001C)
#define CR_REGISTRY_ERROR           (0x0000001D)
#define CR_INVALID_DEVICE_ID        (0x0000001E)
#define CR_INVALID_DATA             (0x0000001F)
#define CR_INVALID_API              (0x00000020)
#define CR_DEVLOADER_NOT_READY      (0x00000021)
#define CR_NEED_RESTART             (0x00000022)
#define CR_NO_MORE_HW_PROFILES      (0x00000023)
#define CR_DEVICE_NOT_THERE         (0x00000024)
#define CR_NO_SUCH_VALUE            (0x00000025)
#define CR_WRONG_TYPE               (0x00000026)
#define CR_INVALID_PRIORITY         (0x00000027)
#define CR_NOT_DISABLEABLE          (0x00000028)
#define CR_FREE_RESOURCES           (0x00000029)
#define CR_QUERY_VETOED             (0x0000002A)
#define CR_CANT_SHARE_IRQ           (0x0000002B)
#define CR_NO_DEPENDENT             (0x0000002C)
#define CR_SAME_RESOURCES           (0x0000002D)
#define CR_NO_SUCH_REGISTRY_KEY     (0x0000002E)
#define CR_INVALID_MACHINENAME      (0x0000002F)   // NT ONLY
#define CR_REMOTE_COMM_FAILURE      (0x00000030)   // NT ONLY
#define CR_MACHINE_UNAVAILABLE      (0x00000031)   // NT ONLY
#define CR_NO_CM_SERVICES           (0x00000032)   // NT ONLY
#define CR_ACCESS_DENIED            (0x00000033)   // NT ONLY
#define CR_CALL_NOT_IMPLEMENTED     (0x00000034)
#define CR_INVALID_PROPERTY         (0x00000035)
#define CR_DEVICE_INTERFACE_ACTIVE  (0x00000036)
#define CR_NO_SUCH_DEVICE_INTERFACE (0x00000037)
#define CR_INVALID_REFERENCE_STRING (0x00000038)
#define CR_INVALID_CONFLICT_LIST    (0x00000039)
#define CR_INVALID_INDEX            (0x0000003A)
#define CR_INVALID_STRUCTURE_SIZE   (0x0000003B)
#define NUM_CR_RESULTS              (0x0000003C)

#ifdef __cplusplus
}
#endif


#endif // _CFGMGR32_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\ddk\inc\classpnp.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    classpnp.h

Abstract:

    These are the structures and defines that are used in the
    SCSI class drivers.

Author:

    Mike Glass (mglass)
    Jeff Havens (jhavens)

Revision History:

--*/

#ifndef _CLASS_
#define _CLASS_

#include <ntdddisk.h>
#include <ntddcdrm.h>
#include <ntddtape.h>
#include <ntddscsi.h>
#include "ntddstor.h"

#include <stdio.h>

#include <scsi.h>

#if defined DebugPrint
    #undef DebugPrint
#endif

#ifdef TRY
    #undef TRY
#endif
#ifdef LEAVE
    #undef LEAVE
#endif
#ifdef FINALLY
    #undef FINALLY
#endif

#define TRY
#define LEAVE   goto __tryLabel;
#define FINALLY __tryLabel:

// #define ALLOCATE_SRB_FROM_POOL

//
// describes the well-known bit masks for ClassDebug, and describes the bits
// to enable in the debugger to view just those messages.  ClassDebugExternalX
// are reserved for third-party components' debugging use.  Anything above
// 16 will only be printed if the lower two bytes of ClassDebug are higher
// than the given level (no masking will be available).
//

typedef enum _CLASS_DEBUG_LEVEL {
    ClassDebugError        = 0,  // always printed
    ClassDebugWarning      = 1,  // set bit 0x00010000 in ClassDebug
    ClassDebugTrace        = 2,  // set bit 0x00020000 in ClassDebug
    ClassDebugInfo         = 3,  // set bit 0x00040000 in ClassDebug
#if 0
    ClassDebug Internal    = 4,  // set bit 0x00080000 in ClassDebug

    ClassDebug Internal    = 5,  // set bit 0x00100000 in ClassDebug
    ClassDebug Internal    = 6,  // set bit 0x00200000 in ClassDebug
    ClassDebug Internal    = 7,  // set bit 0x00400000 in ClassDebug
#endif // 0
    ClassDebugMediaLocks   = 8,  // set bit 0x00800000 in ClassDebug

    ClassDebugMCN          = 9,  // set bit 0x01000000 in ClassDebug
    ClassDebugDelayedRetry = 10, // set bit 0x02000000 in ClassDebug
    ClassDebugSenseInfo    = 11, // set bit 0x04000000 in ClassDebug
    ClassDebugRemoveLock   = 12, // set bit 0x08000000 in ClassDebug

    ClassDebugExternal4    = 13, // set bit 0x10000000 in ClassDebug
    ClassDebugExternal3    = 14, // set bit 0x20000000 in ClassDebug
    ClassDebugExternal2    = 15, // set bit 0x40000000 in ClassDebug
    ClassDebugExternal1    = 16  // set bit 0x80000000 in ClassDebug
} CLASS_DEBUG_LEVEL, *PCLASS_DEBUG_LEVEL;

#if DBG

#define DebugPrint(x) ClassDebugPrint x

#else

#define DebugPrint(x)

#endif // DBG

#define DEBUG_BUFFER_LENGTH 256

//
// Define our private SRB flags.  The high nibble of the flag field is
// reserved for class drivers's private use.
//

//
// Used to indicate that this request shouldn't invoke any power type operations
// like spinning up the drive.
//

#define SRB_CLASS_FLAGS_LOW_PRIORITY      0x10000000

//
// Used to indicate that the completion routine should not free the srb.
//

#define SRB_CLASS_FLAGS_PERSISTANT        0x20000000

//
// Used to indicate that an SRB is the result of a paging operation.
//

#define SRB_CLASS_FLAGS_PAGING            0x40000000

//
// Random macros which should probably be in the system header files
// somewhere.
//

#define max(a,b) (((a) > (b)) ? (a) : (b))
#define min(a,b) (((a) < (b)) ? (a) : (b))

//
// Bit Flag Macros
//

#define SET_FLAG(Flags, Bit)    ((Flags) |= (Bit))
#define CLEAR_FLAG(Flags, Bit)  ((Flags) &= ~(Bit))
#define TEST_FLAG(Flags, Bit)   (((Flags) & (Bit)) != 0)

//
// neat little hacks to count number of bits set efficiently
//
__inline ULONG CountOfSetBitsUChar(UCHAR _X)
{ ULONG i = 0; while (_X) { _X &= _X - 1; i++; } return i; }
__inline ULONG CountOfSetBitsULong(ULONG _X)
{ ULONG i = 0; while (_X) { _X &= _X - 1; i++; } return i; }
__inline ULONG CountOfSetBitsULong32(ULONG32 _X)
{ ULONG i = 0; while (_X) { _X &= _X - 1; i++; } return i; }
__inline ULONG CountOfSetBitsULong64(ULONG64 _X)
{ ULONG i = 0; while (_X) { _X &= _X - 1; i++; } return i; }
__inline ULONG CountOfSetBitsUlongPtr(ULONG_PTR _X)
{ ULONG i = 0; while (_X) { _X &= _X - 1; i++; } return i; }


//
// Helper macros to verify data types and cleanup the code.
//

#define ASSERT_FDO(x) \
    ASSERT(((PCOMMON_DEVICE_EXTENSION) (x)->DeviceExtension)->IsFdo)

#define ASSERT_PDO(x) \
    ASSERT(!(((PCOMMON_DEVICE_EXTENSION) (x)->DeviceExtension)->IsFdo))

#define IS_CLEANUP_REQUEST(majorFunction)   \
        ((majorFunction == IRP_MJ_CLOSE) ||     \
         (majorFunction == IRP_MJ_CLEANUP) ||   \
         (majorFunction == IRP_MJ_SHUTDOWN))

#define DO_MCD(fdoExtension)                                        \
    (((fdoExtension)->MediaChangeDetectionInfo != NULL) &&          \
     ((fdoExtension)->MediaChangeDetectionInfo->MediaChangeDetectionDisableCount == 0))

#ifdef POOL_TAGGING
#undef ExAllocatePool
#undef ExAllocatePoolWithQuota
#define ExAllocatePool(a,b) ExAllocatePoolWithTag(a,b,'nUcS')
//#define ExAllocatePool(a,b) #assert(0)
#define ExAllocatePoolWithQuota(a,b) ExAllocatePoolWithQuotaTag(a,b,'nUcS')
#endif

#define CLASS_TAG_AUTORUN_DISABLE           'ALcS'
#define CLASS_TAG_FILE_OBJECT_EXTENSION     'FLcS'
#define CLASS_TAG_MEDIA_CHANGE_DETECTION    'MLcS'
#define CLASS_TAG_MOUNT                     'mLcS'
#define CLASS_TAG_RELEASE_QUEUE             'qLcS'
#define CLASS_TAG_POWER                     'WLcS'
#define CLASS_TAG_WMI                       'wLcS'
#define CLASS_TAG_FAILURE_PREDICT           'fLcS'
#define CLASS_TAG_DEVICE_CONTROL            'OIcS'

#define MAXIMUM_RETRIES 4

#define CLASS_DRIVER_EXTENSION_KEY ((PVOID) ClassInitialize)

struct _CLASS_INIT_DATA;
typedef struct _CLASS_INIT_DATA
                CLASS_INIT_DATA,
                *PCLASS_INIT_DATA;

//
// our first attempt at keeping private data actually private....
//

struct _CLASS_PRIVATE_FDO_DATA;
typedef struct _CLASS_PRIVATE_FDO_DATA
                CLASS_PRIVATE_FDO_DATA,
              *PCLASS_PRIVATE_FDO_DATA;

struct _CLASS_PRIVATE_PDO_DATA;
typedef struct _CLASS_PRIVATE_PDO_DATA
                CLASS_PRIVATE_PDO_DATA,
              *PCLASS_PRIVATE_PDO_DATA;

struct _CLASS_PRIVATE_COMMON_DATA;
typedef struct _CLASS_PRIVATE_COMMON_DATA
                CLASS_PRIVATE_COMMON_DATA,
              *PCLASS_PRIVATE_COMMON_DATA;

//
// Possible values for the IsRemoved flag
//

#define NO_REMOVE 0
#define REMOVE_PENDING 1
#define REMOVE_COMPLETE 2


#define ClassAcquireRemoveLock(devobj, tag) \
    ClassAcquireRemoveLockEx(devobj, tag, __FILE__, __LINE__)

//
// Define start unit timeout to be 4 minutes.
//

#define START_UNIT_TIMEOUT  (60 * 4)

//
// Define media change test time to be 1 second for quicker response

#define MEDIA_CHANGE_DEFAULT_TIME    1

#ifdef DBG

//
// Used to detect the loss of the autorun irp.  The driver prints out a message
// (debug level 0) if this timeout ever occurs
//
#define MEDIA_CHANGE_TIMEOUT_TIME  300

#endif

//
// Define the various states that media can be in for autorun.
//

typedef enum _MEDIA_CHANGE_DETECTION_STATE {
    MediaUnknown,
    MediaPresent,
    MediaNotPresent
} MEDIA_CHANGE_DETECTION_STATE, *PMEDIA_CHANGE_DETECTION_STATE;

struct _MEDIA_CHANGE_DETECTION_INFO;
typedef struct _MEDIA_CHANGE_DETECTION_INFO
    MEDIA_CHANGE_DETECTION_INFO, *PMEDIA_CHANGE_DETECTION_INFO;

//
// Structures for maintaining a dictionary list (list of objects
// referenced by a key value)
//

struct _DICTIONARY_HEADER;
typedef struct _DICTIONARY_HEADER DICTIONARY_HEADER, *PDICTIONARY_HEADER;

typedef struct _DICTIONARY {
    ULONGLONG Signature;
    PDICTIONARY_HEADER List;
    KSPIN_LOCK SpinLock;
} DICTIONARY, *PDICTIONARY;


//
// structures to simplify matching devices, ids, and hacks required for
// these ids.
//

typedef struct _CLASSPNP_SCAN_FOR_SPECIAL_INFO {

    //
    // * NULL pointers indicates that no match is required.
    // * empty string will only match an empty string.  non-existant strings
    //   in the device descriptor are considered empty strings for this match.
    //   (ie. "" will only match "")
    // * all other strings will do partial matches, based upon
    //   string provided (ie. "hi" will match "hitazen" and "higazui")
    // * array must end with all three PCHARs being set to NULL.
    //

    PCHAR      VendorId;
    PCHAR      ProductId;
    PCHAR      ProductRevision;

    //
    // marked as a ULONG_PTR to allow use as either a ptr to a data block
    // or 32 bits worth of flags. (64 bits on 64 bit systems)  no longer a
    // const so that it may be dynamically built.
    //

    ULONG_PTR  Data;

} CLASSPNP_SCAN_FOR_SPECIAL_INFO, *PCLASSPNP_SCAN_FOR_SPECIAL_INFO;




#ifdef ALLOCATE_SRB_FROM_POOL

#define ClasspAllocateSrb(ext)
    ExAllocatePoolWithTag(NonPagedPool,                 \
                          sizeof(SCSI_REQUEST_BLOCK),   \
                          'sBRS')

#define ClasspFreeSrb(ext, srb)     ExFreePool((srb));

#else

#define ClasspAllocateSrb(ext)                      \
    ExAllocateFromNPagedLookasideList(              \
        &((ext)->CommonExtension.SrbLookasideList))

#define ClasspFreeSrb(ext, srb)                     \
    ExFreeToNPagedLookasideList(                    \
        &((ext)->CommonExtension.SrbLookasideList), \
        (srb))

#endif


/*++////////////////////////////////////////////////////////////////////////////

PCLASS_ERROR()

Routine Description:

    This routine is a callback into the driver to handle errors.  The queue
    shall not be unfrozen when this error handler is called, even though the
    SRB flags may mark the queue as having been frozen due to this SRB.

Irql:

    This routine will be called at KIRQL <= DISPATCH_LEVEL

Arguments:

    DeviceObject is the device object the error occurred on.

    Srb is the Srb that was being processed when the error occurred.

    Status may be overwritten by the routine if it decides that the error
        was benign, or otherwise wishes to change the returned status code
        for this command

    Retry may be overwritten to specify that this command should or should
        not be retried (if the callee supports retrying commands)

Return Value:

    status

--*/
typedef
VOID
(*PCLASS_ERROR) (
    IN PDEVICE_OBJECT DeviceObject,
    IN PSCSI_REQUEST_BLOCK Srb,
    OUT NTSTATUS *Status,
    IN OUT BOOLEAN *Retry
    );


/*++////////////////////////////////////////////////////////////////////////////

PCLASS_ADD_DEVICE()

Routine Description:

    This routine is a callback into the driver to create and initialize a new
    FDO for the corresponding PDO.  It may perform property queries on the PDO
    but cannot do any media access operations.

Irql:

    This routine will be called at PASSIVE_LEVEL.
    Its code may be safely paged.

Arguments:

    DriverObject is the class driver object this callback is registered for.

    PDO is the physical device object being added to.

Return Value:

    status

--*/
typedef
NTSTATUS
(*PCLASS_ADD_DEVICE) (
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT Pdo
    );


/*++////////////////////////////////////////////////////////////////////////////

CLASS_POWER_DEVICE()

Routine Description:

    This routine is a callback into the driver to handle power up and
    power down requests.  Most drivers can set this to ClassPowerHandler,
    which will send a STOP_UNIT on powerdown, and a START_UNIT on powerup.
    ClassMinimalPowerHandler() may also be used to do nothing for power
    operations (except succeed them).  Please see the DDK for proper handling
    of IRP_MN_DEVICE_USAGE_NOTIFICATION for details regarding interaction
    of paging device notifications and the IRQL at which this routine will
    be called.

Irql:

    This routine will be called at PASSIVE_LEVEL if DO_POWER_PAGABLE is set.
    This code should NOT be pagable to prevent race conditions during the
    setting and clearing of the DO_POWER_PAGABLE bit.

Arguments:

    DeviceObject is the device that has the pending power request

    Irp is the power irp that needs to be handled

Return Value:

    status

--*/
typedef
NTSTATUS
(*PCLASS_POWER_DEVICE) (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

/*++////////////////////////////////////////////////////////////////////////////

CLASS_START_DEVICE()

Routine Description:

    This routine is a callback into the driver to initialize the FDO or PDO for
    all requests, typically due to a IRP_MN_START_DEVICE.

Irql:

    This routine will be called at PASSIVE_LEVEL.
    Its code may be safely paged.

Arguments:

    DeviceObject is the device object being started

Return Value:

    status

--*/
typedef
NTSTATUS
(*PCLASS_START_DEVICE) (
    IN PDEVICE_OBJECT DeviceObject
    );


/*++////////////////////////////////////////////////////////////////////////////

CLASS_STOP_DEVICE()

Routine Description:

    This routine is a callback into the driver to stop the device.
    For the storage stack, unless there are known issues, this routine
    need only return.  All queueing shall be handled by the lower device
    drivers.

Irql:

    This routine will be called at PASSIVE_LEVEL.
    Its code may be safely paged.

Arguments:

    DeviceObject is the device object being stopped/query stopped.

    Type is the IRP_MN_ type that must be handled.

Return Value:

    status

--*/
typedef
NTSTATUS
(*PCLASS_STOP_DEVICE) (
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR Type
    );


/*++////////////////////////////////////////////////////////////////////////////

CLASS_INIT_DEVICE()

Routine Description:

    This routine is a callback into the driver to do one-time initialization
    of new device objects.  It shall be called exactly once per device object,
    and it shall be called prior to CLASS_START_DEVICE() routine.

Irql:

    This routine will be called at PASSIVE_LEVEL.
    Its code may be safely paged.

Arguments:

    DeviceObject is the device object to be initialized

Return Value:

    status

--*/
typedef
NTSTATUS
(*PCLASS_INIT_DEVICE) (
    IN PDEVICE_OBJECT DeviceObject
    );


/*++////////////////////////////////////////////////////////////////////////////

CLASS_ENUM_DEVICE()

Routine Description:

    This routine is a callback into the driver to update the list of PDOs for
    a given FDO.  See DISK.SYS's DiskEnumerateDevice for an example of use.

Irql:

    This routine will be called at PASSIVE_LEVEL.
    Its code may be safely paged.

Arguments:

    DeviceObject is the FDO which is being enumerated.

Return Value:

    status

--*/
typedef
NTSTATUS
(*PCLASS_ENUM_DEVICE) (
    IN PDEVICE_OBJECT DeviceObject
    );


/*++////////////////////////////////////////////////////////////////////////////

PCLASS_READ_WRITE()

Routine Description:

    This routine is a callback into the driver to verify READ and WRITE irps.
    If the READ or WRITE request is failed, this routine shall set the Irp's
    IoStatus.Status to the returned error code and the IoStatus.Information
    field as appropriate for the given error.

Irql:

    This routine will be called at KIRQL <= DISPATCH_LEVEL

Arguments:

    DeviceObject is the device object being read from or written to

    Irp is the read or write request being processed

Return Value:

    status

--*/
typedef
NTSTATUS
(*PCLASS_READ_WRITE) (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );


/*++////////////////////////////////////////////////////////////////////////////

PCLASS_DEVICE_CONTROL()

Routine Description:

    This routine is a callback into the driver to

Irql:

    This routine will only be called at PASSIVE_LEVEL for storage IOCTLs.
    The code must therefore not be paged, but may call paged code for those
    ioctls which have been defined to be sent at PASSIVE_LEVEL, such as the
    storage IOCTLS.  Otherwise KIRQL <= DISPATCH_LEVEL.

Arguments:

    DeviceObject is the device object the IOCTL may be for

    Irp is the IOCTL request currently being processed

Return Value:

    status

--*/
typedef
NTSTATUS
(*PCLASS_DEVICE_CONTROL) (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );


/*++////////////////////////////////////////////////////////////////////////////

PCLASS_SHUTDOWN_FLUSH()

Routine Description:

    This routine is a callback into the driver to handle shutdown and flush
    irps.  These are sent by the system before it actually shuts down or when
    the file system does a flush.

    This routine may synchronize the device's media / cache and ensure the
    device is not locked if the system is in the process of shutting down.

Irql:

    This routine will be called at KIRQL <= DISPATCH_LEVEL

Arguments:

    DeviceObject is the device object that needs to be flushed

    Irp is the shutdown or flush request currently being processed

Return Value:

    status

--*/
typedef
NTSTATUS
(*PCLASS_SHUTDOWN_FLUSH) (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );


/*++////////////////////////////////////////////////////////////////////////////

PCLASS_CREATE_CLOSE()

Routine Description:

    This routine is a callback into the driver when the device is opened or
    closed.

Irql:

    This routine will be called at PASSIVE_LEVEL.
    Its code may be safely paged.

Arguments:

    DeviceObject that is handling the request

    Irp is the create or close request currently being processed

Return Value:

    status

--*/
typedef
NTSTATUS
(*PCLASS_CREATE_CLOSE) (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );


/*++////////////////////////////////////////////////////////////////////////////

PCLASS_QUERY_ID()

Routine Description:

    This routine generates the PNP id's for the device's enumerated PDOs.
    If the specified ID is one that cannot be generated, then the return
    status shall be STATUS_NOT_IMPLEMENTED so that classpnp shall not
    handle the request.  This routine shall allocate the buffer in the unicode
    string "IdString" upon success; it is the caller's responsibility to free
    this buffer when it is done.

Irql:

    This routine will be called at PASSIVE_LEVEL.
    Its code may be safely paged.

Arguments:

    DeviceObject is the PDO to generate an ID for

    IdType is the type of ID to be generated

    UnicodeIdString is the string to place the results into

Return Value:

    status

--*/
typedef
NTSTATUS
(*PCLASS_QUERY_ID) (
    IN PDEVICE_OBJECT DeviceObject,
    IN BUS_QUERY_ID_TYPE IdType,
    IN PUNICODE_STRING IdString
    );


/*++////////////////////////////////////////////////////////////////////////////

PCLASS_REMOVE_DEVICE()

Routine Description:

    This routine is a callback into the driver to release any resources the
    device may have allocated for the device object.

Irql:

    This routine will be called at PASSIVE_LEVEL.
    Its code may be safely paged.

Arguments:

    DeviceObject is the device object being removed/query removed/etc.

Return Value:

    status

--*/
typedef
NTSTATUS
(*PCLASS_REMOVE_DEVICE) (
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR Type
    );


/*++////////////////////////////////////////////////////////////////////////////

PCLASS_UNLOAD()

Routine Description:

    This routine is a callback into the driver to unload itself.  It must free
    any resources allocated in the DriverEntry portion of the driver.

Irql:

    This routine will be called at PASSIVE_LEVEL.
    Its code may be safely paged.

Arguments:

    X

    Irp is the IOCTL request currently being processed

Return Value:

    status

--*/
typedef
VOID
(*PCLASS_UNLOAD) (
    IN PDRIVER_OBJECT DriverObject
    );


/*++////////////////////////////////////////////////////////////////////////////

PCLASS_QUERY_PNP_CAPABILITIES()

Routine Description:

    ISSUE-2000/02/18-henrygab - description required

Irql:

    This routine will be called at PASSIVE_LEVEL.
    Its code may be safely paged.

Arguments:

    PhysicalDeviceObject is the PDO for which this query shall occur

    Capabilities is a structure that shall be modified by this routine
        to report the device's capabilities.

Return Value:

    status

--*/
typedef
NTSTATUS
(*PCLASS_QUERY_PNP_CAPABILITIES) (
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    IN PDEVICE_CAPABILITIES Capabilities
    );


/*++////////////////////////////////////////////////////////////////////////////

PCLASS_TICK()

Routine Description:

    This routine is a callback into the driver that is called once per second.

Irql:

    This routine will be called at DISPATCH_LEVEL

Arguments:

    DeviceObject is the device object for which the timer has fired

Return Value:

    status

--*/
typedef
VOID
(*PCLASS_TICK) (
    IN PDEVICE_OBJECT DeviceObject
    );


/*++////////////////////////////////////////////////////////////////////////////

PCLASS_QUERY_WMI_REGINFO_EX()

Routine Description:

    This routine is a callback into the driver to retrieve information about
    the guids being registered.

Irql:

    This routine will be called at PASSIVE_LEVEL.
    Its code may be safely paged.

Arguments:

    DeviceObject is the device whose registration information is needed

    *RegFlags returns with a set of flags that describe the guids being
        registered for this device. If the device wants enable and disable
        collection callbacks before receiving queries for the registered
        guids then it should return the WMIREG_FLAG_EXPENSIVE flag. Also the
        returned flags may specify WMIREG_FLAG_INSTANCE_PDO in which case
        the instance name is determined from the PDO associated with the
        device object. Note that the PDO must have an associated devnode. If
        WMIREG_FLAG_INSTANCE_PDO is not set then Name must return a unique
        name for the device.

    Name returns with the instance name for the guids if
        WMIREG_FLAG_INSTANCE_PDO is not set in the returned *RegFlags. The
        caller will call ExFreePool with the buffer returned.

    MofResourceName returns filled with a static string that contains
        the name of the MOF resource attached to the drivers image. The
        caller does not free the buffer as it is expected that the
        caller will use RtlInitializeUnicodeString to populate it.

Return Value:

    status

--*/
typedef
NTSTATUS
(*PCLASS_QUERY_WMI_REGINFO_EX) (
    IN PDEVICE_OBJECT DeviceObject,
    OUT ULONG *RegFlags,
    OUT PUNICODE_STRING Name,
    OUT PUNICODE_STRING MofResouceName
    );

/*++////////////////////////////////////////////////////////////////////////////

PCLASS_QUERY_WMI_REGINFO()

Routine Description:

    This routine is a callback into the driver to retrieve information about
    the guids being registered.

Irql:

    This routine will be called at PASSIVE_LEVEL.
    Its code may be safely paged.

Arguments:

    DeviceObject is the device whose registration information is needed

    *RegFlags returns with a set of flags that describe the guids being
        registered for this device. If the device wants enable and disable
        collection callbacks before receiving queries for the registered
        guids then it should return the WMIREG_FLAG_EXPENSIVE flag. Also the
        returned flags may specify WMIREG_FLAG_INSTANCE_PDO in which case
        the instance name is determined from the PDO associated with the
        device object. Note that the PDO must have an associated devnode. If
        WMIREG_FLAG_INSTANCE_PDO is not set then Name must return a unique
        name for the device.

    Name returns with the instance name for the guids if
        WMIREG_FLAG_INSTANCE_PDO is not set in the returned *RegFlags. The
        caller will call ExFreePool with the buffer returned.


Return Value:

    status

--*/
typedef
NTSTATUS
(*PCLASS_QUERY_WMI_REGINFO) (
    IN PDEVICE_OBJECT DeviceObject,
    OUT ULONG *RegFlags,
    OUT PUNICODE_STRING Name
    );

/*++////////////////////////////////////////////////////////////////////////////

PCLASS_QUERY_WMI_DATABLOCK()

Routine Description:

    This routine is a callback into the driver to query for the contents of
    a data block. When the driver has finished filling the data block it
    must call ClassWmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Irql:

    This routine will be called at PASSIVE_LEVEL.
    Its code may be safely paged.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    BufferAvail on has the maximum size available to write the data
        block.

    Buffer on return is filled with the returned data block


Return Value:

    status

--*/
typedef
NTSTATUS
(*PCLASS_QUERY_WMI_DATABLOCK) (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG BufferAvail,
    OUT PUCHAR Buffer
    );


/*++////////////////////////////////////////////////////////////////////////////

PCLASS_SET_WMI_DATABLOCK()

Routine Description:

    This routine is a callback into the driver to query for the contents of
    a data block. When the driver has finished filling the data block it
    must call ClassWmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Irql:

    This routine will be called at PASSIVE_LEVEL.
    Its code may be safely paged.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    BufferSize has the size of the data block passed

    Buffer has the new values for the data block


Return Value:

    status

--*/
typedef
NTSTATUS
(*PCLASS_SET_WMI_DATABLOCK) (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG BufferSize,
    IN PUCHAR Buffer
    );


/*++////////////////////////////////////////////////////////////////////////////

PCLASS_SET_WMI_DATAITEM()

Routine Description:

    This routine is a callback into the driver to query for the contents of
    a data block. When the driver has finished filling the data block it
    must call ClassWmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Irql:

    This routine will be called at PASSIVE_LEVEL.
    Its code may be safely paged.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    DataItemId has the id of the data item being set

    BufferSize has the size of the data item passed

    Buffer has the new values for the data item


Return Value:

    status

--*/
typedef
NTSTATUS
(*PCLASS_SET_WMI_DATAITEM) (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG DataItemId,
    IN ULONG BufferSize,
    IN PUCHAR Buffer
    );


/*++////////////////////////////////////////////////////////////////////////////

PCLASS_EXECUTE_WMI_METHOD()

Routine Description:

    This routine is a callback into the driver to execute a method. When the
    driver has finished filling the data block it must call
    ClassWmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Irql:

    This routine will be called at PASSIVE_LEVEL.
    Its code may be safely paged.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    MethodId has the id of the method being called

    InBufferSize has the size of the data block passed in as the input to
        the method.

    OutBufferSize on entry has the maximum size available to write the
        returned data block.

    Buffer is filled with the returned data block


Return Value:

    status

--*/
typedef
NTSTATUS
(*PCLASS_EXECUTE_WMI_METHOD) (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG MethodId,
    IN ULONG InBufferSize,
    IN ULONG OutBufferSize,
    IN PUCHAR Buffer
    );



//
// used by PCLASS_WMI_FUNCTION_CONTROL
//
typedef enum {
    EventGeneration,
    DataBlockCollection
} CLASSENABLEDISABLEFUNCTION;

/*++////////////////////////////////////////////////////////////////////////////

PCLASS_WMI_FUNCTION_CONTROL()

Routine Description:

    This routine is a callback into the driver to enabled or disable event
    generation or data block collection. A device should only expect a
    single enable when the first event or data consumer enables events or
    data collection and a single disable when the last event or data
    consumer disables events or data collection. Data blocks will only
    receive collection enable/disable if they were registered as requiring
    it.

Irql:

    This routine will be called at PASSIVE_LEVEL.
    Its code may be safely paged.

Arguments:

    DeviceObject is the device whose data block is being queried

    GuidIndex is the index into the list of guids provided when the
        device registered

    Function specifies which functionality is being enabled or disabled

    Enable is TRUE then the function is being enabled else disabled

Return Value:

    status

--*/
typedef
NTSTATUS
(*PCLASS_WMI_FUNCTION_CONTROL) (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN CLASSENABLEDISABLEFUNCTION Function,
    IN BOOLEAN Enable
    );



//
// Restricted - May only append to this structure for backwards compatibility
//
typedef struct {
    GUID Guid;               // Guid to registered
    ULONG InstanceCount;     // Count of Instances of Datablock
    ULONG Flags;             // Additional flags (see WMIREGINFO in wmistr.h)
} GUIDREGINFO, *PGUIDREGINFO;


//
// Restricted - May only append to this structure for backwards compatibility
//
typedef struct _CLASS_WMI_INFO {
    ULONG GuidCount;
    PGUIDREGINFO GuidRegInfo;

    PCLASS_QUERY_WMI_REGINFO      ClassQueryWmiRegInfo;
    PCLASS_QUERY_WMI_DATABLOCK    ClassQueryWmiDataBlock;
    PCLASS_SET_WMI_DATABLOCK      ClassSetWmiDataBlock;
    PCLASS_SET_WMI_DATAITEM       ClassSetWmiDataItem;
    PCLASS_EXECUTE_WMI_METHOD     ClassExecuteWmiMethod;
    PCLASS_WMI_FUNCTION_CONTROL   ClassWmiFunctionControl;
} CLASS_WMI_INFO, *PCLASS_WMI_INFO;


//
// Restricted - May only append to this structure for backwards compatibility
//
typedef struct _CLASS_DEV_INFO {

    //
    // Bytes needed by the class driver
    // for it's extension.
    // If this is zero, the driver does not expect to have any PDO's
    //

    ULONG DeviceExtensionSize;

    DEVICE_TYPE DeviceType;

    UCHAR StackSize;

    //
    // Device Characteristics flags
    //  eg.:
    //
    //  FILE_REMOVABLE_MEDIA
    //  FILE_READ_ONLY_DEVICE
    //  FILE_FLOPPY_DISKETTE
    //  FILE_WRITE_ONCE_MEDIA
    //  FILE_REMOTE_DEVICE
    //  FILE_DEVICE_IS_MOUNTED
    //  FILE_VIRTUAL_VOLUME
    //

    ULONG DeviceCharacteristics;

    PCLASS_ERROR                    ClassError;
    PCLASS_READ_WRITE               ClassReadWriteVerification;
    PCLASS_DEVICE_CONTROL           ClassDeviceControl;
    PCLASS_SHUTDOWN_FLUSH           ClassShutdownFlush;
    PCLASS_CREATE_CLOSE             ClassCreateClose;

    PCLASS_INIT_DEVICE              ClassInitDevice;
    PCLASS_START_DEVICE             ClassStartDevice;
    PCLASS_POWER_DEVICE             ClassPowerDevice;
    PCLASS_STOP_DEVICE              ClassStopDevice;
    PCLASS_REMOVE_DEVICE            ClassRemoveDevice;

    PCLASS_QUERY_PNP_CAPABILITIES   ClassQueryPnpCapabilities;

    //
    // Registered Data Block info for wmi
    //
    CLASS_WMI_INFO                  ClassWmiInfo;

} CLASS_DEV_INFO, *PCLASS_DEV_INFO;

//
// Restricted - May only append to this structure for backwards compatibility
//
struct _CLASS_INIT_DATA {

    //
    // This structure size - version checking.
    //

    ULONG InitializationDataSize;

    //
    // Specific init data for functional and physical device objects.
    //

    CLASS_DEV_INFO FdoData;
    CLASS_DEV_INFO PdoData;

    //
    // Device-specific driver routines
    //

    PCLASS_ADD_DEVICE             ClassAddDevice;
    PCLASS_ENUM_DEVICE            ClassEnumerateDevice;

    PCLASS_QUERY_ID               ClassQueryId;

    PDRIVER_STARTIO               ClassStartIo;
    PCLASS_UNLOAD                 ClassUnload;

    PCLASS_TICK                   ClassTick;
};

//
// this is a private structure, but must be kept here
// to properly compile size of FUNCTIONAL_DEVICE_EXTENSION
//
typedef struct _FILE_OBJECT_EXTENSION {
    PFILE_OBJECT FileObject;
    PDEVICE_OBJECT DeviceObject;
    ULONG LockCount;
    ULONG McnDisableCount;
} FILE_OBJECT_EXTENSION, *PFILE_OBJECT_EXTENSION;


//
// Restricted - May only append to this structure for backwards compatibility
//
typedef struct _CLASS_DRIVER_EXTENSION {

    UNICODE_STRING RegistryPath;

    CLASS_INIT_DATA InitData;

    ULONG DeviceCount;

    PCLASS_QUERY_WMI_REGINFO_EX   ClassFdoQueryWmiRegInfoEx;
    PCLASS_QUERY_WMI_REGINFO_EX   ClassPdoQueryWmiRegInfoEx;

} CLASS_DRIVER_EXTENSION, *PCLASS_DRIVER_EXTENSION;

typedef struct _COMMON_DEVICE_EXTENSION COMMON_DEVICE_EXTENSION, *PCOMMON_DEVICE_EXTENSION;
typedef struct _FUNCTIONAL_DEVICE_EXTENSION FUNCTIONAL_DEVICE_EXTENSION, *PFUNCTIONAL_DEVICE_EXTENSION;
typedef struct _PHYSICAL_DEVICE_EXTENSION PHYSICAL_DEVICE_EXTENSION, *PPHYSICAL_DEVICE_EXTENSION;

//
// Restricted - May only append to this structure for backwards compatibility
//
typedef struct _COMMON_DEVICE_EXTENSION {

    //
    // Version control field
    //
    // Note - this MUST be the first thing in the device extension
    // for any class driver using classpnp or a later version.
    //

    ULONG Version;

    //
    // Back pointer to device object
    //
    // NOTE - this MUST be the second field in the common device extension.
    // Users of this structure will include it in a union with the DeviceObject
    // pointer so they can reference this with a bit of syntactic sugar.
    //

    PDEVICE_OBJECT DeviceObject;

    //
    // Pointer to lower device object - send all requests through this
    //

    PDEVICE_OBJECT LowerDeviceObject;

    //
    // Pointer to the partition zero device extension.
    // There are several flags stored there that pdo
    // routines need to access
    //

    PFUNCTIONAL_DEVICE_EXTENSION PartitionZeroExtension;

    //
    // Pointer to the initialization data for this driver.  This is more
    // efficient than constantly getting the driver extension.
    //

    PCLASS_DRIVER_EXTENSION DriverExtension;

    //
    // INTERLOCKED counter of the number of requests/function calls outstanding
    // which will need to use this device object.  When this count goes to
    // zero the RemoveEvent will be set.
    //
    // This variable is only manipulated by ClassIncrementRemoveLock and
    // ClassDecrementRemoveLock.
    //

    LONG RemoveLock;

    //
    // This event will be signalled when it is safe to remove the device object
    //

    KEVENT RemoveEvent;

    //
    // The spinlock and the list are only used in checked builds to track
    // who has acquired the remove lock.  Free systems will leave these
    // initialized to ff
    //

    KSPIN_LOCK RemoveTrackingSpinlock;

    PVOID RemoveTrackingList;

    LONG RemoveTrackingUntrackedCount;

    //
    // Pointer to the driver specific data area
    //

    PVOID DriverData;

    //
    // Flag indicates whether this device object is
    // an FDO or a PDO
    //

    struct {
        BOOLEAN IsFdo : 1;
        BOOLEAN IsInitialized : 1;

        //
        // Flag indicating whether the lookaside listhead for srbs has been
        // initialized.
        //

        BOOLEAN IsSrbLookasideListInitialized : 1;
    };

    //
    // Contains the IRP_MN_CODE of the last state-changing pnp irps we
    // recieved (XXX_STOP, XXX_REMOVE, START, etc...).  Used in concert
    // with IsRemoved.
    //

    UCHAR PreviousState;
    UCHAR CurrentState;

    //
    // interlocked flag indicating that the device has been removed.
    //

    ULONG IsRemoved;

    //
    // The name of the object
    //
    UNICODE_STRING DeviceName;

    //
    // The next child device (or if this is an FDO, the first child device).
    //

    PPHYSICAL_DEVICE_EXTENSION ChildList;

    //
    // Number of the partition or -1L if not partitionable.
    //

    ULONG PartitionNumber;

    //
    // Length of partition in bytes
    //

    LARGE_INTEGER PartitionLength;

    //
    // Number of bytes before start of partition
    //

    LARGE_INTEGER StartingOffset;

    //
    // Dev-Info structure for this type of device object
    // Contains call-out routines for the class driver.
    //

    PCLASS_DEV_INFO DevInfo;

    //
    // Count of page files going through this device object
    // and event to synchronize them with.
    //

    ULONG PagingPathCount;
    ULONG DumpPathCount;
    ULONG HibernationPathCount;
    KEVENT PathCountEvent;

#ifndef ALLOCATE_SRB_FROM_POOL
    //
    // Lookaside listhead for srbs.
    //

    NPAGED_LOOKASIDE_LIST SrbLookasideList;
#endif

    //
    // Interface name string returned by IoRegisterDeviceInterface.
    //

    UNICODE_STRING MountedDeviceInterfaceName;


    //
    // Registered Data Block info for wmi
    //
    ULONG GuidCount;
    PGUIDREGINFO GuidRegInfo;

    //
    // File object dictionary for this device object.  Extensions are stored
    // in here rather than off the actual file object.
    //

    DICTIONARY FileObjectDictionary;

    //
    // The following will be in the released product as reserved.
    // Leave these at the end of the structure.
    //

    PCLASS_PRIVATE_COMMON_DATA PrivateCommonData;

    ULONG_PTR Reserved2;
    ULONG_PTR Reserved3;
    ULONG_PTR Reserved4;

} COMMON_DEVICE_EXTENSION, *PCOMMON_DEVICE_EXTENSION;

typedef enum {
    FailurePredictionNone = 0,     // No failure detection polling needed
    FailurePredictionIoctl,        // Do failure detection via IOCTL
    FailurePredictionSmart,        // Do failure detection via SMART
    FailurePredictionSense         // Do failure detection via sense data
} FAILURE_PREDICTION_METHOD, *PFAILURE_PREDICTION_METHOD;

//
// Default failure prediction polling interval is every hour
//

#define DEFAULT_FAILURE_PREDICTION_PERIOD 60 * 60 * 1

//
// The failure prediction structure is internal to classpnp - drivers do not
// need to know what it contains.
//

struct _FAILURE_PREDICTION_INFO;
typedef struct _FAILURE_PREDICTION_INFO *PFAILURE_PREDICTION_INFO;

//
// this is to allow for common code to handle
// every option.
//

typedef struct _CLASS_POWER_OPTIONS {
    ULONG PowerDown              :  1;
    ULONG LockQueue              :  1;
    ULONG HandleSpinDown         :  1;
    ULONG HandleSpinUp           :  1;
    ULONG Reserved               : 27;
} CLASS_POWER_OPTIONS, *PCLASS_POWER_OPTIONS;

//
// this is a private structure, but must be kept here
// to properly compile size of FUNCTIONAL_DEVICE_EXTENSION
//
typedef enum {
    PowerDownDeviceInitial,
    PowerDownDeviceLocked,
    PowerDownDeviceStopped,
    PowerDownDeviceOff,
    PowerDownDeviceUnlocked
} CLASS_POWER_DOWN_STATE;

//
// same as above, but with an extra state for whistler
// should be ok to change the above structure, but that
// would break someone somewhere who ignore the PRIVATE
// nature of the structure.
//

typedef enum {
    PowerDownDeviceInitial2,
    PowerDownDeviceLocked2,
    PowerDownDeviceFlushed2,
    PowerDownDeviceStopped2,
    PowerDownDeviceOff2,
    PowerDownDeviceUnlocked2
} CLASS_POWER_DOWN_STATE2;

//
// this is a private enum, but must be kept here
// to properly compile size of FUNCTIONAL_DEVICE_EXTENSION
//
typedef enum {
    PowerUpDeviceInitial,
    PowerUpDeviceLocked,
    PowerUpDeviceOn,
    PowerUpDeviceStarted,
    PowerUpDeviceUnlocked
} CLASS_POWER_UP_STATE;

//
// this is a private structure, but must be kept here
// to properly compile size of FUNCTIONAL_DEVICE_EXTENSION
//
typedef struct _CLASS_POWER_CONTEXT {

    union {
        CLASS_POWER_DOWN_STATE PowerDown;
        CLASS_POWER_DOWN_STATE2 PowerDown2; // whistler
        CLASS_POWER_UP_STATE PowerUp;
    } PowerChangeState;

    CLASS_POWER_OPTIONS Options;

    BOOLEAN InUse;
    BOOLEAN QueueLocked;

    NTSTATUS FinalStatus;

    ULONG RetryCount;
    ULONG RetryInterval;

    PIO_COMPLETION_ROUTINE CompletionRoutine;
    PDEVICE_OBJECT DeviceObject;
    PIRP Irp;

    SCSI_REQUEST_BLOCK Srb;

} CLASS_POWER_CONTEXT, *PCLASS_POWER_CONTEXT;

//
// Restricted - May only append to this structure for backwards compatibility
//
typedef struct _FUNCTIONAL_DEVICE_EXTENSION {

    //
    // Common device extension header
    //

    union {
        struct {
            ULONG Version;
            PDEVICE_OBJECT DeviceObject;
        };
        COMMON_DEVICE_EXTENSION CommonExtension;
    };

    //
    // Pointer to the physical device object we attached to - use this
    // for Pnp calls which need a PDO
    //

    PDEVICE_OBJECT LowerPdo;

    //
    // Device capabilities
    //

    PSTORAGE_DEVICE_DESCRIPTOR DeviceDescriptor;

    //
    // SCSI port driver capabilities
    //

    PSTORAGE_ADAPTER_DESCRIPTOR AdapterDescriptor;

    //
    // Current Power state of the device
    //

    DEVICE_POWER_STATE DevicePowerState;

    //
    // DM Driver for IDE drives hack (ie. OnTrack)
    // Bytes to skew all requests
    //

    ULONG DMByteSkew;

    //
    // DM Driver for IDE drives hack (ie. OnTrack)
    // Sectors to skew all requests.
    //

    ULONG DMSkew;

    //
    // DM Driver for IDE drives hack (ie. OnTrack)
    // Flag to indicate whether DM driver has been located on an IDE drive.
    //

    BOOLEAN DMActive;

    //
    // Buffer for drive parameters returned in IO device control.
    //

    DISK_GEOMETRY DiskGeometry;

    //
    // Request Sense Buffer
    //

    PSENSE_DATA SenseData;

    //
    // Request timeout in seconds;
    //

    ULONG TimeOutValue;

    //
    // System device number
    //

    ULONG DeviceNumber;

    //
    // Add default Srb Flags.
    //

    ULONG SrbFlags;

    //
    // Total number of SCSI protocol errors on the device.
    //

    ULONG ErrorCount;

    //
    // Lock count for removable media.
    //

    LONG LockCount;
    LONG ProtectedLockCount;
    LONG InternalLockCount;

    KEVENT EjectSynchronizationEvent;

    //
    // Values for the flags are below.
    //

    USHORT  DeviceFlags;

    //
    // Log2 of sector size
    //

    UCHAR SectorShift;

    UCHAR ReservedByte;

    //
    // Indicates that the necessary data structures for media change
    // detection have been initialized.
    //

    PMEDIA_CHANGE_DETECTION_INFO MediaChangeDetectionInfo;

    PKEVENT Unused1;
    HANDLE  Unused2;

    //
    // File system context. Used for kernel-mode requests to disable autorun.
    //

    FILE_OBJECT_EXTENSION KernelModeMcnContext;

    //
    // Count of media changes.  This field is only valid for the root partition
    // (ie. if PhysicalDevice == NULL).
    //

    ULONG MediaChangeCount;

    //
    // Storage for a handle to the directory the PDO's are placed in
    //

    HANDLE DeviceDirectory;

    //
    // Storage for a release queue request.
    //

    KSPIN_LOCK ReleaseQueueSpinLock;

    PIRP ReleaseQueueIrp;

    SCSI_REQUEST_BLOCK ReleaseQueueSrb;

    BOOLEAN ReleaseQueueNeeded;

    BOOLEAN ReleaseQueueInProgress;

    BOOLEAN ReleaseQueueIrpFromPool;
    //
    // Failure detection storage
    //

    BOOLEAN FailurePredicted;

    ULONG FailureReason;
    PFAILURE_PREDICTION_INFO FailurePredictionInfo;

    BOOLEAN PowerDownInProgress;

    //
    // Interlock for ensuring we don't recurse during enumeration.
    //

    ULONG EnumerationInterlock;

    //
    // Synchronization object for manipulating the child list.
    //

    KEVENT ChildLock;

    //
    // The thread which currently owns the ChildLock.  This is used to
    // avoid recursive acquisition.
    //

    PKTHREAD ChildLockOwner;

    //
    // The number of times this event has been acquired.
    //

    ULONG ChildLockAcquisitionCount;

    //
    // Flags for special behaviour required by
    // different hardware, such as never spinning down
    // or disabling advanced features such as write cache
    //

    ULONG ScanForSpecialFlags;

    //
    // For delayed retry of power requests at DPC level
    //

    KDPC PowerRetryDpc;
    KTIMER PowerRetryTimer;

    //
    // Context structure for power operations.  Since we can only have
    // one D irp at any time in the stack we don't need to worry about
    // allocating multiple of these structures.
    //

    CLASS_POWER_CONTEXT PowerContext;

    //
    // Hold new private data that only classpnp should modify
    // in this structure.
    //

    PCLASS_PRIVATE_FDO_DATA PrivateFdoData;

    //
    // For future expandability
    // leave these at the end of the structure.
    //

    ULONG_PTR Reserved2;
    ULONG_PTR Reserved3;
    ULONG_PTR Reserved4;

} FUNCTIONAL_DEVICE_EXTENSION, *PFUNCTIONAL_DEVICE_EXTENSION;

//
// The following CLASS_SPECIAL_ flags are set in ScanForSpecialFlags
// in the FdoExtension
//

// Never Spin Up/Down the drive (may not handle properly)
#define CLASS_SPECIAL_DISABLE_SPIN_DOWN                 0x00000001
#define CLASS_SPECIAL_DISABLE_SPIN_UP                   0x00000002

// Don't bother to lock the queue when powering down
// (used mostly to send a quick stop to a cdrom to abort audio playback)
#define CLASS_SPECIAL_NO_QUEUE_LOCK                     0x00000008

// Disable write cache due to known bugs
#define CLASS_SPECIAL_DISABLE_WRITE_CACHE               0x00000010

//
// Special interpretation of "device not ready / cause not reportable" for
// devices which don't tell us they need to be spun up manually after they
// spin themselves down behind our back.
//
// The down side of this is that if the drive chooses to report
// "device not ready / cause not reportable" to mean "no media in device"
// or any other error which really does require user intervention NT will
// waste a large amount of time trying to spin up a disk which can't be spun
// up.
//

#define CLASS_SPECIAL_CAUSE_NOT_REPORTABLE_HACK         0x00000020

// Disabling the write cache is not supported on this device
#define CLASS_SPECIAL_DISABLE_WRITE_CACHE_NOT_SUPPORTED 0x00000040

#define CLASS_SPECIAL_VALID_MASK                        0x0000007B
#define CLASS_SPECIAL_RESERVED         (~CLASS_SPECIAL_VALID_MASK)


//
// Restricted - May only append to this structure for backwards compatibility
//
typedef struct _PHYSICAL_DEVICE_EXTENSION {

    //
    // Common extension data
    //

    union {
        struct {
            ULONG Version;
            PDEVICE_OBJECT DeviceObject;
        };
        COMMON_DEVICE_EXTENSION CommonExtension;
    };

    //
    // Indicates that the pdo no longer physically exits.
    //

    BOOLEAN IsMissing;

    //
    // Indicates that the PDO has been handed out to the PNP system.
    //

    BOOLEAN IsEnumerated;

    //
    // Hold new private data that only classpnp should modify
    // in this structure.
    //

    PCLASS_PRIVATE_PDO_DATA PrivatePdoData;

    //
    // for future expandability
    // leave these at the end of the structure.
    //

    ULONG_PTR Reserved2;
    ULONG_PTR Reserved3;
    ULONG_PTR Reserved4;

} PHYSICAL_DEVICE_EXTENSION, *PPHYSICAL_DEVICE_EXTENSION;

//
// Indicates that the device has write caching enabled.
//

#define DEV_WRITE_CACHE     0x00000001

//
// Build SCSI 1 or SCSI 2 CDBs
//

#define DEV_USE_SCSI1       0x00000002

//
// Indicates whether is is safe to send StartUnit commands
// to this device. It will only be off for some removeable devices.
//

#define DEV_SAFE_START_UNIT 0x00000004

//
// Indicates whether it is unsafe to send SCSIOP_MECHANISM_STATUS commands to
// this device.  Some devices don't like these 12 byte commands
//

#define DEV_NO_12BYTE_CDB   0x00000008

//
// Define context structure for asynchronous completions.
//

typedef struct _COMPLETION_CONTEXT {
    PDEVICE_OBJECT DeviceObject;
    SCSI_REQUEST_BLOCK Srb;
}COMPLETION_CONTEXT, *PCOMPLETION_CONTEXT;


/*++

Internal function - described in classpnp\class.c in ddk sources

--*/
SCSIPORT_API
ULONG
ClassInitialize(
    IN  PVOID            Argument1,
    IN  PVOID            Argument2,
    IN  PCLASS_INIT_DATA InitializationData
    );


/*++

Internal function - described in classpnp\class.c in ddk sources

--*/

//
// The Data Parameter contains a pointer to a CLASS_QUERY_WMI_REGINFO_EX_LIST
// structure that specifies callbacks that are used instead of the
// PCLASS_QUERY_WMI_REGINFO callbacks.
//
// {00E34B11-2444-4745-A53D-620100CD82F7}
#define GUID_CLASSPNP_QUERY_REGINFOEX { 0xe34b11, 0x2444, 0x4745, { 0xa5, 0x3d, 0x62, 0x1, 0x0, 0xcd, 0x82, 0xf7 } }

typedef struct _CLASS_QUERY_WMI_REGINFO_EX_LIST
{
    ULONG Size;          // Should be sizeof(CLASS_QUERY_REGINFO_EX_LIST)

    PCLASS_QUERY_WMI_REGINFO_EX   ClassFdoQueryWmiRegInfoEx;
    PCLASS_QUERY_WMI_REGINFO_EX   ClassPdoQueryWmiRegInfoEx;

} CLASS_QUERY_WMI_REGINFO_EX_LIST, *PCLASS_QUERY_WMI_REGINFO_EX_LIST;



SCSIPORT_API
ULONG
ClassInitializeEx(
    IN  PDRIVER_OBJECT   DriverObject,
    IN  LPGUID           Guid,
    IN  PVOID            Data
    );


/*++

Internal function - described in classpnp\class.c in ddk sources

--*/
SCSIPORT_API
NTSTATUS
ClassCreateDeviceObject(
    IN PDRIVER_OBJECT          DriverObject,
    IN PCCHAR                  ObjectNameBuffer,
    IN PDEVICE_OBJECT          LowerDeviceObject,
    IN BOOLEAN                 IsFdo,
    IN OUT PDEVICE_OBJECT      *DeviceObject
    );

/*++

Internal function - described in classpnp\class.c in ddk sources

--*/
SCSIPORT_API
NTSTATUS
ClassReadDriveCapacity(
    IN PDEVICE_OBJECT DeviceObject
    );


/*++

Internal function - described in classpnp\class.c in ddk sources

--*/
SCSIPORT_API
VOID
ClassReleaseQueue(
    IN PDEVICE_OBJECT DeviceObject
    );


/*++

Internal function - described in classpnp\class.c in ddk sources

--*/
SCSIPORT_API
VOID
ClassSplitRequest(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG MaximumBytes
    );


/*++

Internal function - described in classpnp\class.c in ddk sources

--*/
SCSIPORT_API
NTSTATUS
ClassDeviceControl(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    );


/*++

Internal function - described in classpnp\class.c in ddk sources

--*/
SCSIPORT_API
NTSTATUS
ClassIoComplete(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );


/*++

Internal function - described in classpnp\class.c in ddk sources

--*/
SCSIPORT_API
NTSTATUS
ClassIoCompleteAssociated(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );


/*++

Internal function - described in classpnp\class.c in ddk sources

--*/
SCSIPORT_API
BOOLEAN
ClassInterpretSenseInfo(
    IN PDEVICE_OBJECT DeviceObject,
    IN PSCSI_REQUEST_BLOCK Srb,
    IN UCHAR MajorFunctionCode,
    IN ULONG IoDeviceCode,
    IN ULONG RetryCount,
    OUT NTSTATUS *Status,
    OUT ULONG *RetryInterval
    );


/*++

Internal function - described in classpnp\class.c in ddk sources

--*/
VOID
ClassSendDeviceIoControlSynchronous(
    IN ULONG IoControlCode,
    IN PDEVICE_OBJECT TargetDeviceObject,
    IN OUT PVOID Buffer OPTIONAL,
    IN ULONG InputBufferLength,
    IN ULONG OutputBufferLength,
    IN BOOLEAN InternalDeviceIoControl,
    OUT PIO_STATUS_BLOCK IoStatus
    );


/*++

Internal function - described in classpnp\class.c in ddk sources

--*/
SCSIPORT_API
NTSTATUS
ClassSendIrpSynchronous(
    IN PDEVICE_OBJECT TargetDeviceObject,
    IN PIRP Irp
    );


/*++

Internal function - described in classpnp\class.c in ddk sources

--*/
SCSIPORT_API
NTSTATUS
ClassForwardIrpSynchronous(
    IN PCOMMON_DEVICE_EXTENSION CommonExtension,
    IN PIRP Irp
    );

/*++

Internal function - described in classpnp\class.c in ddk sources

--*/
SCSIPORT_API
NTSTATUS
ClassSendSrbSynchronous(
    PDEVICE_OBJECT DeviceObject,
    PSCSI_REQUEST_BLOCK Srb,
    PVOID BufferAddress,
    ULONG BufferLength,
    BOOLEAN WriteToDevice
    );


/*++

Internal function - described in classpnp\class.c in ddk sources

--*/
SCSIPORT_API
NTSTATUS
ClassSendSrbAsynchronous(
    PDEVICE_OBJECT DeviceObject,
    PSCSI_REQUEST_BLOCK Srb,
    PIRP Irp,
    PVOID BufferAddress,
    ULONG BufferLength,
    BOOLEAN WriteToDevice
    );

/*++

Internal function - described in classpnp\class.c in ddk sources

--*/
SCSIPORT_API
NTSTATUS
ClassBuildRequest(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    );


/*++

Internal function - described in classpnp\class.c in ddk sources

--*/
SCSIPORT_API
ULONG
ClassModeSense(
    IN PDEVICE_OBJECT DeviceObject,
    IN PCHAR ModeSenseBuffer,
    IN ULONG Length,
    IN UCHAR PageMode
    );


/*++

Internal function - described in classpnp\class.c in ddk sources

--*/
SCSIPORT_API
PVOID
ClassFindModePage(
    IN PCHAR ModeSenseBuffer,
    IN ULONG Length,
    IN UCHAR PageMode,
    IN BOOLEAN Use6Byte
    );


/*++

Internal function - described in classpnp\class.c in ddk sources

--*/
SCSIPORT_API
NTSTATUS
ClassClaimDevice(
    IN PDEVICE_OBJECT LowerDeviceObject,
    IN BOOLEAN Release
    );


/*++

Internal function - described in classpnp\class.c in ddk sources

--*/
SCSIPORT_API
NTSTATUS
ClassInternalIoControl (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );


/*++

Internal function - described in classpnp\utils.c in ddk sources

--*/
SCSIPORT_API
VOID
ClassInitializeSrbLookasideList(
    IN PCOMMON_DEVICE_EXTENSION CommonExtension,
    IN ULONG NumberElements
    );

/*++

Internal function - described in classpnp\utils.c in ddk sources

--*/
SCSIPORT_API
VOID
ClassDeleteSrbLookasideList(
    IN PCOMMON_DEVICE_EXTENSION CommonExtension
    );

/*++

Internal function - described in classpnp\class.c in ddk sources

--*/
SCSIPORT_API
ULONG
ClassQueryTimeOutRegistryValue(
    IN PDEVICE_OBJECT DeviceObject
    );


/*++

Internal function - described in classpnp\class.c in ddk sources

--*/
SCSIPORT_API
NTSTATUS
ClassGetDescriptor(
    IN PDEVICE_OBJECT DeviceObject,
    IN PSTORAGE_PROPERTY_ID PropertyId,
    OUT PVOID *Descriptor
    );


/*++

Internal function - described in classpnp\class.c in ddk sources

--*/
SCSIPORT_API
VOID
ClassInvalidateBusRelations(
    IN PDEVICE_OBJECT Fdo
    );


/*++

Internal function - described in classpnp\class.c in ddk sources

--*/
SCSIPORT_API
VOID
ClassMarkChildrenMissing(
    IN PFUNCTIONAL_DEVICE_EXTENSION Fdo
    );


/*++

Internal function - described in classpnp\class.c in ddk sources

--*/
SCSIPORT_API
BOOLEAN
ClassMarkChildMissing(
    IN PPHYSICAL_DEVICE_EXTENSION PdoExtension,
    IN BOOLEAN AcquireChildLock
    );


/*++

Internal function - described in classpnp\class.c in ddk sources

--*/
SCSIPORT_API
VOID
ClassDebugPrint(
    CLASS_DEBUG_LEVEL DebugPrintLevel,
    PCCHAR DebugMessage,
    ...
    );


/*++

Internal function - described in classpnp\class.c in ddk sources

--*/
SCSIPORT_API
PCLASS_DRIVER_EXTENSION
ClassGetDriverExtension(
    IN PDRIVER_OBJECT DriverObject
    );


/*++

Internal function - described in classpnp\lock.c in ddk sources

--*/
SCSIPORT_API
VOID
ClassCompleteRequest(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN CCHAR PriorityBoost
    );


/*++

Internal function - described in classpnp\lock.c in ddk sources

--*/
SCSIPORT_API
VOID
ClassReleaseRemoveLock(
    IN PDEVICE_OBJECT DeviceObject,
    IN OPTIONAL PIRP Irp
    );


/*++

Internal function - described in classpnp\lock.c in ddk sources

--*/
SCSIPORT_API
ULONG
ClassAcquireRemoveLockEx(
    IN PDEVICE_OBJECT DeviceObject,
    IN OPTIONAL PVOID Tag,
    IN PCSTR File,
    IN ULONG Line
    );




/*++

Internal function - described in classpnp\class.c in ddk sources

--*/
SCSIPORT_API
VOID
ClassUpdateInformationInRegistry(
    IN PDEVICE_OBJECT     Fdo,
    IN PCHAR              DeviceName,
    IN ULONG              DeviceNumber,
    IN PINQUIRYDATA       InquiryData,
    IN ULONG              InquiryDataLength
    );


/*++

Internal function - described in classpnp\classwmi.c in ddk sources

--*/
SCSIPORT_API
NTSTATUS
ClassWmiCompleteRequest(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN NTSTATUS Status,
    IN ULONG BufferUsed,
    IN CCHAR PriorityBoost
    );


/*++

Internal function - described in classpnp\classwmi.c in ddk sources

--*/
SCSIPORT_API
NTSTATUS
ClassWmiFireEvent(
    IN PDEVICE_OBJECT DeviceObject,
    IN LPGUID Guid,
    IN ULONG InstanceIndex,
    IN ULONG EventDataSize,
    IN PVOID EventData
    );


/*++

Internal function - described in classpnp\autorun.c in ddk sources

--*/
SCSIPORT_API
VOID
ClassResetMediaChangeTimer(
    IN PFUNCTIONAL_DEVICE_EXTENSION FdoExtension
    );


/*++

Internal function - described in classpnp\autorun.c in ddk sources

--*/
SCSIPORT_API
VOID
ClassInitializeMediaChangeDetection(
    IN PFUNCTIONAL_DEVICE_EXTENSION FdoExtension,
    IN PUCHAR EventPrefix
    );


/*++

Internal function - described in classpnp\autorun.c in ddk sources

--*/
SCSIPORT_API
NTSTATUS
ClassInitializeTestUnitPolling(
    IN PFUNCTIONAL_DEVICE_EXTENSION FdoExtension,
    IN BOOLEAN AllowDriveToSleep
    );


/*++

Internal function - described in classpnp\class.c in ddk sources

--*/
SCSIPORT_API
PVPB
ClassGetVpb(
    IN PDEVICE_OBJECT DeviceObject
    );


/*++

Internal function - described in classpnp\power.c in ddk sources

--*/
SCSIPORT_API
NTSTATUS
ClassSpinDownPowerHandler(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );


/*++

Internal function - described in classpnp\power.c in ddk sources

--*/
NTSTATUS
ClassStopUnitPowerHandler(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );


/*++

Internal function - described in classpnp\autorun.c in ddk sources

--*/
NTSTATUS
ClassSetFailurePredictionPoll(
    PFUNCTIONAL_DEVICE_EXTENSION FdoExtension,
    FAILURE_PREDICTION_METHOD FailurePredictionMethod,
    ULONG PollingPeriod
    );


/*++

Internal function - described in classpnp\autorun.c in ddk sources

--*/
VOID
ClassNotifyFailurePredicted(
    PFUNCTIONAL_DEVICE_EXTENSION FdoExtension,
    PUCHAR Buffer,
    ULONG BufferSize,
    BOOLEAN LogError,
    ULONG UniqueErrorValue,
    UCHAR PathId,
    UCHAR TargetId,
    UCHAR Lun
    );


/*++

Internal function - described in classpnp\class.c in ddk sources

--*/
SCSIPORT_API
VOID
ClassAcquireChildLock(
    IN PFUNCTIONAL_DEVICE_EXTENSION FdoExtension
    );


/*++

Internal function - described in classpnp\class.c in ddk sources

--*/
SCSIPORT_API
VOID
ClassReleaseChildLock(
    IN PFUNCTIONAL_DEVICE_EXTENSION FdoExtension
    );


/*++

Internal function - described in classpnp\class.c in ddk sources

--*/
NTSTATUS
ClassSignalCompletion(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PKEVENT Event
    );

/*++

Internal function - described in classpnp\class.c in ddk sources

--*/
VOID
ClassSendStartUnit(
    IN PDEVICE_OBJECT DeviceObject
    );


/*++

Internal function - described in classpnp\class.c in ddk sources

--*/
SCSIPORT_API
NTSTATUS
ClassRemoveDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR RemoveType
    );


/*++

Internal function - described in classpnp\class.c in ddk sources

--*/
SCSIPORT_API
NTSTATUS
ClassAsynchronousCompletion(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp,
    PVOID Context
    );


/*++

Internal function - described in classpnp\autorun.c in ddk sources

--*/
SCSIPORT_API
VOID
ClassCheckMediaState(
    IN PFUNCTIONAL_DEVICE_EXTENSION FdoExtension
    );


/*++

Internal function - described in classpnp\class.c in ddk sources

--*/
SCSIPORT_API
NTSTATUS
ClassCheckVerifyComplete(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );


/*++

Internal function - described in classpnp\autorun.c in ddk sources

--*/
SCSIPORT_API
VOID
ClassSetMediaChangeState(
    IN PFUNCTIONAL_DEVICE_EXTENSION FdoExtension,
    IN MEDIA_CHANGE_DETECTION_STATE State,
    IN BOOLEAN Wait
    );


/*++

Internal function - described in classpnp\autorun.c in ddk sources

--*/
SCSIPORT_API
VOID
ClassEnableMediaChangeDetection(
    IN PFUNCTIONAL_DEVICE_EXTENSION FdoExtension
    );


/*++

Internal function - described in classpnp\autorun.c in ddk sources

--*/
SCSIPORT_API
VOID
ClassDisableMediaChangeDetection(
    IN PFUNCTIONAL_DEVICE_EXTENSION FdoExtension
    );


/*++

Internal function - described in classpnp\autorun.c in ddk sources

--*/
SCSIPORT_API
VOID
ClassCleanupMediaChangeDetection(
    IN PFUNCTIONAL_DEVICE_EXTENSION FdoExtension
    );


/*++

Internal function - described in classpnp\utils.c in ddk sources

--*/
VOID
ClassGetDeviceParameter(
    IN PFUNCTIONAL_DEVICE_EXTENSION FdoExtension,
    IN PWSTR SubkeyName OPTIONAL,
    IN PWSTR ParameterName,
    IN OUT PULONG ParameterValue
    );


/*++

Internal function - described in classpnp\utils.c in ddk sources

--*/
NTSTATUS
ClassSetDeviceParameter(
    IN PFUNCTIONAL_DEVICE_EXTENSION FdoExtension,
    IN PWSTR SubkeyName OPTIONAL,
    IN PWSTR ParameterName,
    IN ULONG ParameterValue
    );


//
// could be #define, but this allows typechecking
//

__inline
BOOLEAN
PORT_ALLOCATED_SENSE(
    IN PFUNCTIONAL_DEVICE_EXTENSION FdoExtension,
    IN PSCSI_REQUEST_BLOCK Srb
    )
{
    return ((TEST_FLAG(Srb->SrbFlags, SRB_FLAGS_PORT_DRIVER_ALLOCSENSE) &&
             TEST_FLAG(Srb->SrbFlags, SRB_FLAGS_FREE_SENSE_BUFFER)) &&
            (Srb->SenseInfoBuffer != FdoExtension->SenseData)
            );
}

__inline
VOID
FREE_PORT_ALLOCATED_SENSE_BUFFER(
    IN PFUNCTIONAL_DEVICE_EXTENSION FdoExtension,
    IN PSCSI_REQUEST_BLOCK Srb
    )
{
    ASSERT(TEST_FLAG(Srb->SrbFlags, SRB_FLAGS_PORT_DRIVER_ALLOCSENSE));
    ASSERT(TEST_FLAG(Srb->SrbFlags, SRB_FLAGS_FREE_SENSE_BUFFER));
    ASSERT(Srb->SenseInfoBuffer != FdoExtension->SenseData);

    ExFreePool(Srb->SenseInfoBuffer);
    Srb->SenseInfoBuffer = FdoExtension->SenseData;
    Srb->SenseInfoBufferLength = SENSE_BUFFER_SIZE; // should be variable?
    CLEAR_FLAG(Srb->SrbFlags, SRB_FLAGS_FREE_SENSE_BUFFER);
    return;
}



/*++////////////////////////////////////////////////////////////////////////////

PCLASS_SCAN_FOR_SPECIAL_HANDLER()

Routine Description:

    This routine is a callback into the driver to set device-specific
    flags based upon matches made to the device's inquiry data.  Drivers
    register for this callback using ClassRegisterScanForSpecial().

Irql:

    This routine will be called at KIRQL == PASSIVE_LEVEL

Arguments:

    DeviceObject is the device object the error occurred on.

    Srb is the Srb that was being processed when the error occurred.

    Status may be overwritten by the routine if it decides that the error
        was benign, or otherwise wishes to change the returned status code
        for this command

    Retry may be overwritten to specify that this command should or should
        not be retried (if the callee supports retrying commands)

Return Value:

    status

--*/
typedef
VOID
(*PCLASS_SCAN_FOR_SPECIAL_HANDLER) (
    IN PFUNCTIONAL_DEVICE_EXTENSION FdoExtension,
    IN ULONG_PTR Data
    );

VOID
ClassScanForSpecial(
    IN PFUNCTIONAL_DEVICE_EXTENSION FdoExtension,
    IN CLASSPNP_SCAN_FOR_SPECIAL_INFO DeviceList[],
    IN PCLASS_SCAN_FOR_SPECIAL_HANDLER Function
    );


#endif /* _CLASS_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\ddk\inc\d3dhalex.h ===
#ifndef _D3DHALEX_H
#define _D3DHALEX_H

//-----------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation.  All Rights Reserved.
//
//  File:       d3dhalex.h
//  Content:    Direct3D HAL Extensions and Helpers include file
//              This file contains definitions and macros which although not
//              essential for building a driver are useful helpers and
//              utilities.
//
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
//
// Macros to help with handling the new GetDriverInfo2 mechanism. The following
// macros assist with handling the GetDriverInfo2 sub-call of GetDriverInfo.
// Two of the macros are simplified ways of differentiating between
// GetDriverInfo2 calls and DDStereoMode calls. The others are simplified ways
// of getting the data structures associated with those two calls.
//
// The following code fragment demonstrates how to handle GetDriverInfo2 using
// these macros. Compare this with the code fragment in d3dhal.h
//
// D3DCAPS8 myD3DCaps8;
//
// DWORD CALLBACK 
// DdGetDriverInfo(LPDDHAL_GETDRIVERINFODATA lpData)
// {
//     if (MATCH_GUID((lpData->guidInfo), GUID_GetDriverInfo2) )
//     {
//         ASSERT(NULL != lpData);
//         ASSERT(NULL != lpData->lpvData);
//
//         // Is this a call to GetDriverInfo2 or DDStereoMode?
//         if (D3DGDI_IS_GDI2(lpData))
//         {
//             // Yes, its a call to GetDriverInfo2, fetch the
//             // DD_GETDRIVERINFO2DATA data structure.
//             DD_GETDRIVERINFO2DATA* pgdi2 = D3DGDI_GET_GDI2_DATA(lpData);
//             ASSERT(NULL != pgdi2);
//
//             // What type of request is this?
//             switch (pgdi2->dwType)
//             {
//             case D3DGDI2_TYPE_GETD3DCAPS8:
//                 {
//                     // The runtime is requesting the DX8 D3D caps so
//                     // copy them over now.
//
//                     // It should be noted that the dwExpectedSize field
//                     // of DD_GETDRIVERINFODATA is not used for
//                     // GetDriverInfo2 calls and should be ignored.
//                     size_t copySize = min(sizeof(myD3DCaps8), pgdi2->dwExpectedSize);
//                     memcpy(lpData->lpvData, &myD3DCaps8, copySize);
//                     lpData->dwActualSize = copySize;
//                     lpData->ddRVal       = DD_OK;
//                     return DDHAL_DRIVER_HANDLED;
//                 }
//             default:
//                 // For any other GetDriverInfo2 types not handled
//                 // or understood by the driver set an ddRVal of
//                 // DDERR_CURRENTLYNOTAVAIL and return
//                 // DDHAL_DRIVER_HANDLED.
//                 return DDHAL_DRIVER_HANDLED;
//             }
//         }
//         else
//         {
//             // It must be a call a request for stereo mode support.
//             // Fetch the stereo mode data
//             DD_STEREOMODE* pStereoMode = D3DGDI_GET_STEREOMODE_DATA(pData);
//             ASSERT(NULL != pStereoMode);
//
//             // Process the stereo mode request...
//             lpData->dwActualSize = sizeof(DD_STEREOMODE);
//             lpData->ddRVal       = DD_OK;
//             return DDHAL_DRIVER_HANDLED;
//         }
//     }
//
//     // Handle any other device GUIDs...
//
// } // DdGetDriverInfo
//
//-----------------------------------------------------------------------------

//
// Macros to determine what type of call a call to GetDriverInfo with the
// GUID GUID_GetDriverInfo2/GUID_DDStereoMode. A GetDriverInfo2 call or
// a DDStereoMode call.
//
#define D3DGDI_IS_GDI2(pData) \
    ((((DD_GETDRIVERINFO2DATA*)(pData->lpvData))->dwMagic)  == D3DGDI2_MAGIC)

#define D3DGDI_IS_STEREOMODE(pData) \
    ((((DD_STEREOMODE*)        (pData->lpvData))->dwHeight) != D3DGDI2_MAGIC)

//
// Macros to return the appropriate GetDriverInfo data structure for a
// call to GetDriverInfo with the GUID GUID_GetDriverInfo2/GUID_DDStereoMode.
//
#define D3DGDI_GET_GDI2_DATA(pData) \
    (D3DGDI_IS_GDI2(pData) ? (((DD_GETDRIVERINFO2DATA*)(pData->lpvData))) : NULL)

#define D3DGDI_GET_STEREOMODE_DATA(pData) \
    (D3DGDI_IS_STEREOMODE(pData) ? (((DD_STEREOMODE*)(pData->lpvData)))   : NULL)

#endif /* _D3DHALEX_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\ddk\inc\d3dhal.h ===
/*==========================================================================;
 *
 *  Copyright (C) Microsoft Corporation.  All Rights Reserved.
 *
 *  File:   d3dhal.h
 *  Content:    Direct3D HAL include file
 *
 ***************************************************************************/

#ifndef _D3DHAL_H_
#define _D3DHAL_H_
#include "ddraw.h"
#include "d3dtypes.h"
#include "d3dcaps.h"
#include "d3d.h"
#include "d3d8.h"

struct _D3DHAL_CALLBACKS;
typedef struct _D3DHAL_CALLBACKS D3DHAL_CALLBACKS, *LPD3DHAL_CALLBACKS;

struct _D3DHAL_CALLBACKS2;
typedef struct _D3DHAL_CALLBACKS2 D3DHAL_CALLBACKS2, *LPD3DHAL_CALLBACKS2;

struct _D3DHAL_CALLBACKS3;
typedef struct _D3DHAL_CALLBACKS3 D3DHAL_CALLBACKS3, *LPD3DHAL_CALLBACKS3;

typedef struct _DDRAWI_DIRECTDRAW_GBL FAR *LPDDRAWI_DIRECTDRAW_GBL;
typedef struct _DDRAWI_DIRECTDRAW_LCL FAR *LPDDRAWI_DIRECTDRAW_LCL;
struct _DDRAWI_DDRAWSURFACE_LCL;
typedef struct _DDRAWI_DDRAWSURFACE_LCL FAR *LPDDRAWI_DDRAWSURFACE_LCL;

/*
 * If the HAL driver does not implement clipping, it must reserve at least
 * this much space at the end of the LocalVertexBuffer for use by the HEL
 * clipping.  I.e. the vertex buffer contain dwNumVertices+dwNumClipVertices
 * vertices.  No extra space is needed by the HEL clipping in the
 * LocalHVertexBuffer.
 */
#define D3DHAL_NUMCLIPVERTICES  20

/*
 * These are a few special internal renderstates etc. that would
 * logically be in d3dtypes.h, but that file is external, so they are
 * here.
 */
#define D3DTSS_MAX ((D3DTEXTURESTAGESTATETYPE)29)

/*
 * If DX8 driver wants to support pre-DX8 applications, it should use these
 * definitions for pre-DX8 world matrices
*/
#define D3DTRANSFORMSTATE_WORLD_DX7  1
#define D3DTRANSFORMSTATE_WORLD1_DX7 4
#define D3DTRANSFORMSTATE_WORLD2_DX7 5
#define D3DTRANSFORMSTATE_WORLD3_DX7 6

/*
 * Generally needed maximum state structure sizes.  Note that the copy of
 * these in refrasti.hpp must be kept in sync with these.
 */

#define D3DHAL_MAX_RSTATES (D3DRENDERSTATE_WRAPBIAS + 128)
/* Last state offset for combined render state and texture stage array + 1 */
#define D3DHAL_MAX_RSTATES_AND_STAGES \
    (D3DHAL_TSS_RENDERSTATEBASE + \
     D3DHAL_TSS_MAXSTAGES * D3DHAL_TSS_STATESPERSTAGE)
/* Last texture state ID */
#define D3DHAL_MAX_TEXTURESTATES (13)
/* Last texture state ID + 1 */
#define D3DHAL_TEXTURESTATEBUF_SIZE (D3DHAL_MAX_TEXTURESTATES+1)

/*
 * If no dwNumVertices is given, this is what will be used.
 */
#define D3DHAL_DEFAULT_TL_NUM   ((32 * 1024) / sizeof (D3DTLVERTEX))
#define D3DHAL_DEFAULT_H_NUM    ((32 * 1024) / sizeof (D3DHVERTEX))

/*
 * Description for a device.
 * This is used to describe a device that is to be created or to query
 * the current device.
 *
 * For DX5 and subsequent runtimes, D3DDEVICEDESC is a user-visible
 * structure that is not seen by the device drivers. The runtime
 * stitches a D3DDEVICEDESC together using the D3DDEVICEDESC_V1
 * embedded in the GLOBALDRIVERDATA and the extended caps queried
 * from the driver using GetDriverInfo.
 */

typedef struct _D3DDeviceDesc_V1 {
    DWORD        dwSize;             /* Size of D3DDEVICEDESC structure */
    DWORD        dwFlags;                /* Indicates which fields have valid data */
    D3DCOLORMODEL    dcmColorModel;      /* Color model of device */
    DWORD        dwDevCaps;              /* Capabilities of device */
    D3DTRANSFORMCAPS dtcTransformCaps;       /* Capabilities of transform */
    BOOL         bClipping;              /* Device can do 3D clipping */
    D3DLIGHTINGCAPS  dlcLightingCaps;        /* Capabilities of lighting */
    D3DPRIMCAPS      dpcLineCaps;
    D3DPRIMCAPS      dpcTriCaps;
    DWORD            dwDeviceRenderBitDepth; /* One of DDBD_16, etc.. */
    DWORD        dwDeviceZBufferBitDepth;/* One of DDBD_16, 32, etc.. */
    DWORD        dwMaxBufferSize;        /* Maximum execute buffer size */
    DWORD        dwMaxVertexCount;       /* Maximum vertex count */
} D3DDEVICEDESC_V1, *LPD3DDEVICEDESC_V1;

#define D3DDEVICEDESCSIZE_V1 (sizeof(D3DDEVICEDESC_V1))

/*
 * This is equivalent to the D3DDEVICEDESC understood by DX5, available only
 * from DX6. It is the same as D3DDEVICEDESC structure in DX5.
 * D3DDEVICEDESC is still the user-visible structure that is not seen by the
 * device drivers. The runtime stitches a D3DDEVICEDESC together using the
 * D3DDEVICEDESC_V1 embedded in the GLOBALDRIVERDATA and the extended caps
 * queried from the driver using GetDriverInfo.
 */

typedef struct _D3DDeviceDesc_V2 {
    DWORD        dwSize;             /* Size of D3DDEVICEDESC structure */
    DWORD        dwFlags;                /* Indicates which fields have valid data */
    D3DCOLORMODEL    dcmColorModel;      /* Color model of device */
    DWORD        dwDevCaps;              /* Capabilities of device */
    D3DTRANSFORMCAPS dtcTransformCaps;       /* Capabilities of transform */
    BOOL         bClipping;              /* Device can do 3D clipping */
    D3DLIGHTINGCAPS  dlcLightingCaps;        /* Capabilities of lighting */
    D3DPRIMCAPS      dpcLineCaps;
    D3DPRIMCAPS      dpcTriCaps;
    DWORD            dwDeviceRenderBitDepth; /* One of DDBD_16, etc.. */
    DWORD        dwDeviceZBufferBitDepth;/* One of DDBD_16, 32, etc.. */
    DWORD        dwMaxBufferSize;        /* Maximum execute buffer size */
    DWORD        dwMaxVertexCount;       /* Maximum vertex count */

    DWORD        dwMinTextureWidth, dwMinTextureHeight;
    DWORD        dwMaxTextureWidth, dwMaxTextureHeight;
    DWORD        dwMinStippleWidth, dwMaxStippleWidth;
    DWORD        dwMinStippleHeight, dwMaxStippleHeight;

} D3DDEVICEDESC_V2, *LPD3DDEVICEDESC_V2;

#define D3DDEVICEDESCSIZE_V2 (sizeof(D3DDEVICEDESC_V2))

#if(DIRECT3D_VERSION >= 0x0700)
/*
 * This is equivalent to the D3DDEVICEDESC understood by DX6, available only
 * from DX6. It is the same as D3DDEVICEDESC structure in DX6.
 * D3DDEVICEDESC is still the user-visible structure that is not seen by the
 * device drivers. The runtime stitches a D3DDEVICEDESC together using the
 * D3DDEVICEDESC_V1 embedded in the GLOBALDRIVERDATA and the extended caps
 * queried from the driver using GetDriverInfo.
 */

typedef struct _D3DDeviceDesc_V3 {
    DWORD        dwSize;             /* Size of D3DDEVICEDESC structure */
    DWORD        dwFlags;                /* Indicates which fields have valid data */
    D3DCOLORMODEL    dcmColorModel;      /* Color model of device */
    DWORD        dwDevCaps;              /* Capabilities of device */
    D3DTRANSFORMCAPS dtcTransformCaps;       /* Capabilities of transform */
    BOOL         bClipping;              /* Device can do 3D clipping */
    D3DLIGHTINGCAPS  dlcLightingCaps;        /* Capabilities of lighting */
    D3DPRIMCAPS      dpcLineCaps;
    D3DPRIMCAPS      dpcTriCaps;
    DWORD            dwDeviceRenderBitDepth; /* One of DDBD_16, etc.. */
    DWORD        dwDeviceZBufferBitDepth;/* One of DDBD_16, 32, etc.. */
    DWORD        dwMaxBufferSize;        /* Maximum execute buffer size */
    DWORD        dwMaxVertexCount;       /* Maximum vertex count */

    DWORD        dwMinTextureWidth, dwMinTextureHeight;
    DWORD        dwMaxTextureWidth, dwMaxTextureHeight;
    DWORD        dwMinStippleWidth, dwMaxStippleWidth;
    DWORD        dwMinStippleHeight, dwMaxStippleHeight;

    DWORD       dwMaxTextureRepeat;
    DWORD       dwMaxTextureAspectRatio;
    DWORD       dwMaxAnisotropy;
    D3DVALUE    dvGuardBandLeft;
    D3DVALUE    dvGuardBandTop;
    D3DVALUE    dvGuardBandRight;
    D3DVALUE    dvGuardBandBottom;
    D3DVALUE    dvExtentsAdjust;
    DWORD       dwStencilCaps;
    DWORD       dwFVFCaps;  /* low 4 bits: 0 implies TLVERTEX only, 1..8 imply FVF aware */
    DWORD       dwTextureOpCaps;
    WORD        wMaxTextureBlendStages;
    WORD        wMaxSimultaneousTextures;
} D3DDEVICEDESC_V3, *LPD3DDEVICEDESC_V3;

#define D3DDEVICEDESCSIZE_V3 (sizeof(D3DDEVICEDESC_V3))
#endif /* DIRECT3D_VERSION >= 0x0700 */

/* --------------------------------------------------------------
 * Instantiated by the HAL driver on driver connection.
 */
typedef struct _D3DHAL_GLOBALDRIVERDATA {
    DWORD       dwSize;         // Size of this structure
    D3DDEVICEDESC_V1    hwCaps;                 // Capabilities of the hardware
    DWORD       dwNumVertices;      // see following comment
    DWORD       dwNumClipVertices;  // see following comment
    DWORD       dwNumTextureFormats;    // Number of texture formats
    LPDDSURFACEDESC lpTextureFormats;   // Pointer to texture formats
} D3DHAL_GLOBALDRIVERDATA;

typedef D3DHAL_GLOBALDRIVERDATA *LPD3DHAL_GLOBALDRIVERDATA;

#define D3DHAL_GLOBALDRIVERDATASIZE (sizeof(D3DHAL_GLOBALDRIVERDATA))

#if(DIRECT3D_VERSION >= 0x0700)
/* --------------------------------------------------------------
 * Extended caps introduced with DX5 and queried with
 * GetDriverInfo (GUID_D3DExtendedCaps).
 */
typedef struct _D3DHAL_D3DDX6EXTENDEDCAPS {
    DWORD       dwSize;         // Size of this structure

    DWORD       dwMinTextureWidth, dwMaxTextureWidth;
    DWORD       dwMinTextureHeight, dwMaxTextureHeight;
    DWORD       dwMinStippleWidth, dwMaxStippleWidth;
    DWORD       dwMinStippleHeight, dwMaxStippleHeight;

    /* fields added for DX6 */
    DWORD       dwMaxTextureRepeat;
    DWORD       dwMaxTextureAspectRatio;
    DWORD       dwMaxAnisotropy;
    D3DVALUE    dvGuardBandLeft;
    D3DVALUE    dvGuardBandTop;
    D3DVALUE    dvGuardBandRight;
    D3DVALUE    dvGuardBandBottom;
    D3DVALUE    dvExtentsAdjust;
    DWORD       dwStencilCaps;
    DWORD       dwFVFCaps;  /* low 4 bits: 0 implies TLVERTEX only, 1..8 imply FVF aware */
    DWORD       dwTextureOpCaps;
    WORD        wMaxTextureBlendStages;
    WORD        wMaxSimultaneousTextures;

} D3DHAL_D3DDX6EXTENDEDCAPS;
#endif /* DIRECT3D_VERSION >= 0x0700 */

/* --------------------------------------------------------------
 * Extended caps introduced with DX5 and queried with
 * GetDriverInfo (GUID_D3DExtendedCaps).
 */
typedef struct _D3DHAL_D3DEXTENDEDCAPS {
    DWORD       dwSize;         // Size of this structure

    DWORD       dwMinTextureWidth, dwMaxTextureWidth;
    DWORD       dwMinTextureHeight, dwMaxTextureHeight;
    DWORD       dwMinStippleWidth, dwMaxStippleWidth;
    DWORD       dwMinStippleHeight, dwMaxStippleHeight;

    /* fields added for DX6 */
    DWORD       dwMaxTextureRepeat;
    DWORD       dwMaxTextureAspectRatio;
    DWORD       dwMaxAnisotropy;
    D3DVALUE    dvGuardBandLeft;
    D3DVALUE    dvGuardBandTop;
    D3DVALUE    dvGuardBandRight;
    D3DVALUE    dvGuardBandBottom;
    D3DVALUE    dvExtentsAdjust;
    DWORD       dwStencilCaps;
    DWORD       dwFVFCaps;  /* low 4 bits: 0 implies TLVERTEX only, 1..8 imply FVF aware */
    DWORD       dwTextureOpCaps;
    WORD        wMaxTextureBlendStages;
    WORD        wMaxSimultaneousTextures;

#if(DIRECT3D_VERSION >= 0x0700)
    /* fields added for DX7 */
    DWORD       dwMaxActiveLights;
    D3DVALUE    dvMaxVertexW;

    WORD        wMaxUserClipPlanes;
    WORD        wMaxVertexBlendMatrices;

    DWORD       dwVertexProcessingCaps;

    DWORD       dwReserved1;
    DWORD       dwReserved2;
    DWORD       dwReserved3;
    DWORD       dwReserved4;
#endif /* DIRECT3D_VERSION >= 0x0700 */
} D3DHAL_D3DEXTENDEDCAPS;

typedef D3DHAL_D3DEXTENDEDCAPS *LPD3DHAL_D3DEXTENDEDCAPS;
#define D3DHAL_D3DEXTENDEDCAPSSIZE (sizeof(D3DHAL_D3DEXTENDEDCAPS))

#if(DIRECT3D_VERSION >= 0x0700)
typedef D3DHAL_D3DDX6EXTENDEDCAPS *LPD3DHAL_D3DDX6EXTENDEDCAPS;
#define D3DHAL_D3DDX6EXTENDEDCAPSSIZE (sizeof(D3DHAL_D3DDX6EXTENDEDCAPS))
#endif /* DIRECT3D_VERSION >= 0x0700 */

/* --------------------------------------------------------------
 * Argument to the HAL functions.
 *
 * !!! When this structure is changed, D3DHAL_CONTEXTCREATEDATA in 
 *  windows\published\ntgdistr.h also must be changed to be the same size !!!
 *
 */

typedef struct _D3DHAL_CONTEXTCREATEDATA
{
    union
    {
        LPDDRAWI_DIRECTDRAW_GBL lpDDGbl;    // in:  Driver struct (legacy)
        LPDDRAWI_DIRECTDRAW_LCL lpDDLcl;    // in:  For DX7 driver onwards
    };

    union
    {
        LPDIRECTDRAWSURFACE lpDDS;      // in:  Surface to be used as target
        LPDDRAWI_DDRAWSURFACE_LCL lpDDSLcl; // For DX7 onwards
    };

    union
    {
        LPDIRECTDRAWSURFACE lpDDSZ;     // in:  Surface to be used as Z
        LPDDRAWI_DDRAWSURFACE_LCL lpDDSZLcl; // For DX7 onwards
    };

    union
    {
        DWORD       dwPID;      // in:  Current process id
        ULONG_PTR dwrstates;  // Must be larger enough to hold a pointer as
                              // we can return a pointer in this field
    };
    ULONG_PTR       dwhContext; // out: Context handle
    HRESULT     ddrval;     // out: Return value
} D3DHAL_CONTEXTCREATEDATA;
typedef D3DHAL_CONTEXTCREATEDATA *LPD3DHAL_CONTEXTCREATEDATA;

typedef struct _D3DHAL_CONTEXTDESTROYDATA
{
    ULONG_PTR       dwhContext; // in:  Context handle
    HRESULT     ddrval;     // out: Return value
} D3DHAL_CONTEXTDESTROYDATA;
typedef D3DHAL_CONTEXTDESTROYDATA *LPD3DHAL_CONTEXTDESTROYDATA;

typedef struct _D3DHAL_CONTEXTDESTROYALLDATA
{
    DWORD       dwPID;      // in:  Process id to destroy contexts for
    HRESULT     ddrval;     // out: Return value
} D3DHAL_CONTEXTDESTROYALLDATA;
typedef D3DHAL_CONTEXTDESTROYALLDATA *LPD3DHAL_CONTEXTDESTROYALLDATA;

typedef struct _D3DHAL_SCENECAPTUREDATA
{
    ULONG_PTR       dwhContext; // in:  Context handle
    DWORD       dwFlag;     // in:  Indicates beginning or end
    HRESULT     ddrval;     // out: Return value
} D3DHAL_SCENECAPTUREDATA;
typedef D3DHAL_SCENECAPTUREDATA *LPD3DHAL_SCENECAPTUREDATA;

typedef struct _D3DHAL_RENDERSTATEDATA
{
    ULONG_PTR       dwhContext; // in:  Context handle
    DWORD       dwOffset;   // in:  Where to find states in buffer
    DWORD       dwCount;    // in:  How many states to process
    LPDIRECTDRAWSURFACE lpExeBuf;   // in:  Execute buffer containing data
    HRESULT     ddrval;     // out: Return value
} D3DHAL_RENDERSTATEDATA;
typedef D3DHAL_RENDERSTATEDATA *LPD3DHAL_RENDERSTATEDATA;

typedef struct _D3DHAL_RENDERPRIMITIVEDATA
{
    ULONG_PTR       dwhContext; // in:  Context handle
    DWORD       dwOffset;   // in:  Where to find primitive data in buffer
    DWORD       dwStatus;   // in/out: Condition branch status
    LPDIRECTDRAWSURFACE lpExeBuf;   // in:  Execute buffer containing data
    DWORD       dwTLOffset; // in:  Byte offset in lpTLBuf for start of vertex data
    LPDIRECTDRAWSURFACE lpTLBuf;    // in:  Execute buffer containing TLVertex data
    D3DINSTRUCTION  diInstruction;  // in:  Primitive instruction
    HRESULT     ddrval;     // out: Return value
} D3DHAL_RENDERPRIMITIVEDATA;
typedef D3DHAL_RENDERPRIMITIVEDATA *LPD3DHAL_RENDERPRIMITIVEDATA;

typedef struct _D3DHAL_TEXTURECREATEDATA
{
    ULONG_PTR       dwhContext; // in:  Context handle
    LPDIRECTDRAWSURFACE lpDDS;      // in:  Pointer to surface object
    DWORD       dwHandle;   // out: Handle to texture
    HRESULT     ddrval;     // out: Return value
} D3DHAL_TEXTURECREATEDATA;
typedef D3DHAL_TEXTURECREATEDATA *LPD3DHAL_TEXTURECREATEDATA;

typedef struct _D3DHAL_TEXTUREDESTROYDATA
{
    ULONG_PTR       dwhContext; // in:  Context handle
    DWORD       dwHandle;   // in:  Handle to texture
    HRESULT     ddrval;     // out: Return value
} D3DHAL_TEXTUREDESTROYDATA;
typedef D3DHAL_TEXTUREDESTROYDATA *LPD3DHAL_TEXTUREDESTROYDATA;

typedef struct _D3DHAL_TEXTURESWAPDATA
{
    ULONG_PTR       dwhContext; // in:  Context handle
    DWORD       dwHandle1;  // in:  Handle to texture 1
    DWORD       dwHandle2;  // in:  Handle to texture 2
    HRESULT     ddrval;     // out: Return value
} D3DHAL_TEXTURESWAPDATA;
typedef D3DHAL_TEXTURESWAPDATA *LPD3DHAL_TEXTURESWAPDATA;

typedef struct _D3DHAL_TEXTUREGETSURFDATA
{
    ULONG_PTR       dwhContext; // in:  Context handle
    ULONG_PTR    lpDDS;      // out: Pointer to surface object
    DWORD       dwHandle;   // in:  Handle to texture
    HRESULT     ddrval;     // out: Return value
} D3DHAL_TEXTUREGETSURFDATA;
typedef D3DHAL_TEXTUREGETSURFDATA *LPD3DHAL_TEXTUREGETSURFDATA;

typedef struct _D3DHAL_GETSTATEDATA
{
    ULONG_PTR       dwhContext; // in:  Context handle
    DWORD       dwWhich;    // in:  Transform, lighting or render?
    D3DSTATE        ddState;    // in/out: State.
    HRESULT     ddrval;     // out: Return value
} D3DHAL_GETSTATEDATA;
typedef D3DHAL_GETSTATEDATA *LPD3DHAL_GETSTATEDATA;


/* --------------------------------------------------------------
 * Direct3D HAL Table.
 * Instantiated by the HAL driver on connection.
 *
 * Calls take the form of:
 *  retcode = HalCall(HalCallData* lpData);
 */

typedef DWORD   (__stdcall *LPD3DHAL_CONTEXTCREATECB)   (LPD3DHAL_CONTEXTCREATEDATA);
typedef DWORD   (__stdcall *LPD3DHAL_CONTEXTDESTROYCB)  (LPD3DHAL_CONTEXTDESTROYDATA);
typedef DWORD   (__stdcall *LPD3DHAL_CONTEXTDESTROYALLCB) (LPD3DHAL_CONTEXTDESTROYALLDATA);
typedef DWORD   (__stdcall *LPD3DHAL_SCENECAPTURECB)    (LPD3DHAL_SCENECAPTUREDATA);
typedef DWORD   (__stdcall *LPD3DHAL_RENDERSTATECB) (LPD3DHAL_RENDERSTATEDATA);
typedef DWORD   (__stdcall *LPD3DHAL_RENDERPRIMITIVECB) (LPD3DHAL_RENDERPRIMITIVEDATA);
typedef DWORD   (__stdcall *LPD3DHAL_TEXTURECREATECB)   (LPD3DHAL_TEXTURECREATEDATA);
typedef DWORD   (__stdcall *LPD3DHAL_TEXTUREDESTROYCB)  (LPD3DHAL_TEXTUREDESTROYDATA);
typedef DWORD   (__stdcall *LPD3DHAL_TEXTURESWAPCB) (LPD3DHAL_TEXTURESWAPDATA);
typedef DWORD   (__stdcall *LPD3DHAL_TEXTUREGETSURFCB)  (LPD3DHAL_TEXTUREGETSURFDATA);
typedef DWORD   (__stdcall *LPD3DHAL_GETSTATECB)    (LPD3DHAL_GETSTATEDATA);


/*
 * Regarding dwNumVertices, specify 0 if you are relying on the HEL to do
 * everything and you do not need the resultant TLVertex buffer to reside
 * in device memory.
 * The HAL driver will be asked to allocate dwNumVertices + dwNumClipVertices
 * in the case described above.
 */

typedef struct _D3DHAL_CALLBACKS
{
    DWORD           dwSize;

    // Device context
    LPD3DHAL_CONTEXTCREATECB    ContextCreate;
    LPD3DHAL_CONTEXTDESTROYCB   ContextDestroy;
    LPD3DHAL_CONTEXTDESTROYALLCB ContextDestroyAll;

    // Scene Capture
    LPD3DHAL_SCENECAPTURECB SceneCapture;

    LPVOID                      lpReserved10;           // Must be zero
    LPVOID                      lpReserved11;           // Must be zero

    // Execution
    LPD3DHAL_RENDERSTATECB  RenderState;
    LPD3DHAL_RENDERPRIMITIVECB  RenderPrimitive;

    DWORD           dwReserved;     // Must be zero

    // Textures
    LPD3DHAL_TEXTURECREATECB    TextureCreate;
    LPD3DHAL_TEXTUREDESTROYCB   TextureDestroy;
    LPD3DHAL_TEXTURESWAPCB  TextureSwap;
    LPD3DHAL_TEXTUREGETSURFCB   TextureGetSurf;

    LPVOID                      lpReserved12;           // Must be zero
    LPVOID                      lpReserved13;           // Must be zero
    LPVOID                      lpReserved14;           // Must be zero
    LPVOID                      lpReserved15;           // Must be zero
    LPVOID                      lpReserved16;           // Must be zero
    LPVOID                      lpReserved17;           // Must be zero
    LPVOID                      lpReserved18;           // Must be zero
    LPVOID                      lpReserved19;           // Must be zero
    LPVOID                      lpReserved20;           // Must be zero
    LPVOID                      lpReserved21;           // Must be zero

    // Pipeline state
    LPD3DHAL_GETSTATECB     GetState;

    DWORD           dwReserved0;        // Must be zero
    DWORD           dwReserved1;        // Must be zero
    DWORD           dwReserved2;        // Must be zero
    DWORD           dwReserved3;        // Must be zero
    DWORD           dwReserved4;        // Must be zero
    DWORD           dwReserved5;        // Must be zero
    DWORD           dwReserved6;        // Must be zero
    DWORD           dwReserved7;        // Must be zero
    DWORD           dwReserved8;        // Must be zero
    DWORD           dwReserved9;        // Must be zero

} D3DHAL_CALLBACKS;
typedef D3DHAL_CALLBACKS *LPD3DHAL_CALLBACKS;

#define D3DHAL_SIZE_V1 sizeof( D3DHAL_CALLBACKS )


typedef struct _D3DHAL_SETRENDERTARGETDATA
{
    ULONG_PTR               dwhContext;     // in:  Context handle
    union
    {
        LPDIRECTDRAWSURFACE lpDDS;          // in:  new render target
        LPDDRAWI_DDRAWSURFACE_LCL lpDDSLcl;
    };

    union
    {
        LPDIRECTDRAWSURFACE lpDDSZ;         // in:  new Z buffer
        LPDDRAWI_DDRAWSURFACE_LCL lpDDSZLcl;
    };

    HRESULT             ddrval;         // out: Return value
} D3DHAL_SETRENDERTARGETDATA;
typedef D3DHAL_SETRENDERTARGETDATA FAR *LPD3DHAL_SETRENDERTARGETDATA;

// This bit is the same as D3DCLEAR_RESERVED0 in d3d8types.h
// When set it means that driver has to cull rects against current viewport.
// The bit is set only for pure devices
//
#define D3DCLEAR_COMPUTERECTS   0x00000008l  

typedef struct _D3DHAL_CLEARDATA
{
    ULONG_PTR               dwhContext;     // in:  Context handle

    // dwFlags can contain D3DCLEAR_TARGET or D3DCLEAR_ZBUFFER
    DWORD               dwFlags;        // in:  surfaces to clear

    DWORD               dwFillColor;    // in:  Color value for rtarget
    DWORD               dwFillDepth;    // in:  Depth value for Z buffer

    LPD3DRECT           lpRects;        // in:  Rectangles to clear
    DWORD               dwNumRects;     // in:  Number of rectangles

    HRESULT             ddrval;         // out: Return value
} D3DHAL_CLEARDATA;
typedef D3DHAL_CLEARDATA FAR *LPD3DHAL_CLEARDATA;

typedef struct _D3DHAL_DRAWONEPRIMITIVEDATA
{
    ULONG_PTR               dwhContext;     // in:  Context handle

    DWORD               dwFlags;        // in:  flags

    D3DPRIMITIVETYPE    PrimitiveType;  // in:  type of primitive to draw
    union{
    D3DVERTEXTYPE       VertexType;     // in:  type of vertices
    DWORD               dwFVFControl;   // in:  FVF control DWORD
    };
    LPVOID              lpvVertices;    // in:  pointer to vertices
    DWORD               dwNumVertices;  // in:  number of vertices

    DWORD               dwReserved;     // in:  reserved

    HRESULT             ddrval;         // out: Return value

} D3DHAL_DRAWONEPRIMITIVEDATA;
typedef D3DHAL_DRAWONEPRIMITIVEDATA *LPD3DHAL_DRAWONEPRIMITIVEDATA;


typedef struct _D3DHAL_DRAWONEINDEXEDPRIMITIVEDATA
{
    ULONG_PTR               dwhContext;     // in: Context handle

    DWORD               dwFlags;        // in: flags word

    // Primitive and vertex type
    D3DPRIMITIVETYPE    PrimitiveType;  // in: primitive type
    union{
    D3DVERTEXTYPE       VertexType;     // in: vertex type
    DWORD               dwFVFControl;   // in:  FVF control DWORD
    };

    // Vertices
    LPVOID              lpvVertices;    // in: vertex data
    DWORD               dwNumVertices;  // in: vertex count

    // Indices
    LPWORD              lpwIndices;     // in: index data
    DWORD               dwNumIndices;   // in: index count

    HRESULT             ddrval;         // out: Return value
} D3DHAL_DRAWONEINDEXEDPRIMITIVEDATA;
typedef D3DHAL_DRAWONEINDEXEDPRIMITIVEDATA *LPD3DHAL_DRAWONEINDEXEDPRIMITIVEDATA;


typedef struct _D3DHAL_DRAWPRIMCOUNTS
{
    WORD wNumStateChanges;
    WORD wPrimitiveType;
    WORD wVertexType;
    WORD wNumVertices;
} D3DHAL_DRAWPRIMCOUNTS, *LPD3DHAL_DRAWPRIMCOUNTS;

typedef struct _D3DHAL_DRAWPRIMITIVESDATA
{
    ULONG_PTR               dwhContext;     // in:  Context handle

    DWORD               dwFlags;

    //
    // Data block:
    //
    // Consists of interleaved D3DHAL_DRAWPRIMCOUNTS, state change pairs,
    // and primitive drawing commands.
    //
    //  D3DHAL_DRAWPRIMCOUNTS: gives number of state change pairs and
    //          the information on the primitive to draw.
    //          wPrimitiveType is of type D3DPRIMITIVETYPE. Drivers
    //              must support all 7 of the primitive types specified
    //              in the DrawPrimitive API.
    //          Currently, wVertexType will always be D3DVT_TLVERTEX.
    //          If the wNumVertices member is 0, then the driver should
    //              return after doing the state changing. This is the
    //              terminator for the command stream.
    // state change pairs: DWORD pairs specify the state changes that
    //          the driver should effect before drawing the primitive.
    //          wNumStateChanges can be 0, in which case the next primitive
    //          should be drawn without any state changes in between.
    //          If present, the state change pairs are NOT aligned, they
    //          immediately follow the PRIMCOUNTS structure.
    // vertex data (if any): is 32-byte aligned.
    //
    // If a primcounts structure follows (i.e. if wNumVertices was nonzero
    // in the previous one), then it will immediately follow the state
    // changes or vertex data with no alignment padding.
    //

    LPVOID              lpvData;

    DWORD               dwFVFControl;   // in:  FVF control DWORD

    HRESULT             ddrval;         // out: Return value
} D3DHAL_DRAWPRIMITIVESDATA;
typedef D3DHAL_DRAWPRIMITIVESDATA *LPD3DHAL_DRAWPRIMITIVESDATA;

typedef DWORD (CALLBACK *LPD3DHAL_SETRENDERTARGETCB) (LPD3DHAL_SETRENDERTARGETDATA);
typedef DWORD (CALLBACK *LPD3DHAL_CLEARCB)           (LPD3DHAL_CLEARDATA);
typedef DWORD (CALLBACK *LPD3DHAL_DRAWONEPRIMITIVECB)   (LPD3DHAL_DRAWONEPRIMITIVEDATA);
typedef DWORD (CALLBACK *LPD3DHAL_DRAWONEINDEXEDPRIMITIVECB) (LPD3DHAL_DRAWONEINDEXEDPRIMITIVEDATA);
typedef DWORD (CALLBACK *LPD3DHAL_DRAWPRIMITIVESCB)   (LPD3DHAL_DRAWPRIMITIVESDATA);

typedef struct _D3DHAL_CALLBACKS2
{
    DWORD                       dwSize;                 // size of struct
    DWORD                       dwFlags;                // flags for callbacks
    LPD3DHAL_SETRENDERTARGETCB  SetRenderTarget;
    LPD3DHAL_CLEARCB            Clear;
    LPD3DHAL_DRAWONEPRIMITIVECB DrawOnePrimitive;
    LPD3DHAL_DRAWONEINDEXEDPRIMITIVECB DrawOneIndexedPrimitive;
    LPD3DHAL_DRAWPRIMITIVESCB    DrawPrimitives;
} D3DHAL_CALLBACKS2;
typedef D3DHAL_CALLBACKS2 *LPD3DHAL_CALLBACKS2;

#define D3DHAL_CALLBACKS2SIZE       sizeof(D3DHAL_CALLBACKS2)

#define D3DHAL2_CB32_SETRENDERTARGET    0x00000001L
#define D3DHAL2_CB32_CLEAR              0x00000002L
#define D3DHAL2_CB32_DRAWONEPRIMITIVE   0x00000004L
#define D3DHAL2_CB32_DRAWONEINDEXEDPRIMITIVE 0x00000008L
#define D3DHAL2_CB32_DRAWPRIMITIVES     0x00000010L

/* --------------------------------------------------------------
 * D3DCallbacks3 - queried with GetDriverInfo (GUID_D3DCallbacks3).
 *
 * Clear2 - enables stencil clears (exposed to the API in
 *      IDirect3DViewport3::Clear2
 * ValidateTextureStageState - evaluates the context's current state (including
 *      multitexture) and returns an error if the hardware cannot
 *      accelerate the current state vector.
 * DrawPrimitives2 - Renders primitives, and changes device state specified
 *                   in the command buffer.
 *
 * Multitexture-aware drivers must implement both ValidateTextureStageState.
 */

typedef struct _D3DHAL_CLEAR2DATA
{
    ULONG_PTR               dwhContext;     // in:  Context handle

  // dwFlags can contain D3DCLEAR_TARGET, D3DCLEAR_ZBUFFER, and/or D3DCLEAR_STENCIL
    DWORD               dwFlags;        // in:  surfaces to clear

    DWORD               dwFillColor;    // in:  Color value for rtarget
    D3DVALUE            dvFillDepth;    // in:  Depth value for Z buffer (0.0-1.0)
    DWORD               dwFillStencil;  // in:  value used to clear stencil buffer

    LPD3DRECT           lpRects;        // in:  Rectangles to clear
    DWORD               dwNumRects;     // in:  Number of rectangles

    HRESULT             ddrval;         // out: Return value
} D3DHAL_CLEAR2DATA;
typedef D3DHAL_CLEAR2DATA FAR *LPD3DHAL_CLEAR2DATA;

typedef struct _D3DHAL_VALIDATETEXTURESTAGESTATEDATA
{
    ULONG_PTR           dwhContext;     // in:  Context handle
    DWORD               dwFlags;        // in:  Flags, currently set to 0
    ULONG_PTR           dwReserved;     //
    DWORD               dwNumPasses;    // out: Number of passes the hardware
                                        //      can perform the operation in
    HRESULT             ddrval;         // out: return value
} D3DHAL_VALIDATETEXTURESTAGESTATEDATA;
typedef D3DHAL_VALIDATETEXTURESTAGESTATEDATA *LPD3DHAL_VALIDATETEXTURESTAGESTATEDATA;

//-----------------------------------------------------------------------------
// DrawPrimitives2 DDI
//-----------------------------------------------------------------------------

//
// Command structure for vertex buffer rendering
//

typedef struct _D3DHAL_DP2COMMAND
{
    BYTE bCommand;           // vertex command
    BYTE bReserved;
    union
    {
        WORD wPrimitiveCount;   // primitive count for unconnected primitives
        WORD wStateCount;     // count of render states to follow
    };
} D3DHAL_DP2COMMAND, *LPD3DHAL_DP2COMMAND;

//
// DrawPrimitives2 commands:
//

typedef enum _D3DHAL_DP2OPERATION
{
    D3DDP2OP_POINTS               = 1,
    D3DDP2OP_INDEXEDLINELIST      = 2,
    D3DDP2OP_INDEXEDTRIANGLELIST  = 3,
    D3DDP2OP_RESERVED0            = 4,      // Used by the front-end only
    D3DDP2OP_RENDERSTATE          = 8,
    D3DDP2OP_LINELIST             = 15,
    D3DDP2OP_LINESTRIP            = 16,
    D3DDP2OP_INDEXEDLINESTRIP     = 17,
    D3DDP2OP_TRIANGLELIST         = 18,
    D3DDP2OP_TRIANGLESTRIP        = 19,
    D3DDP2OP_INDEXEDTRIANGLESTRIP = 20,
    D3DDP2OP_TRIANGLEFAN          = 21,
    D3DDP2OP_INDEXEDTRIANGLEFAN   = 22,
    D3DDP2OP_TRIANGLEFAN_IMM      = 23,
    D3DDP2OP_LINELIST_IMM         = 24,
    D3DDP2OP_TEXTURESTAGESTATE    = 25,     // Has edge flags and called from Execute
    D3DDP2OP_INDEXEDTRIANGLELIST2 = 26,
    D3DDP2OP_INDEXEDLINELIST2     = 27,
    D3DDP2OP_VIEWPORTINFO         = 28,
    D3DDP2OP_WINFO                = 29,
// two below are for pre-DX7 interface apps running DX7 driver
    D3DDP2OP_SETPALETTE           = 30,
    D3DDP2OP_UPDATEPALETTE        = 31,
#if(DIRECT3D_VERSION >= 0x0700)
    // New for DX7
    D3DDP2OP_ZRANGE               = 32,
    D3DDP2OP_SETMATERIAL          = 33,
    D3DDP2OP_SETLIGHT             = 34,
    D3DDP2OP_CREATELIGHT          = 35,
    D3DDP2OP_SETTRANSFORM         = 36,
    D3DDP2OP_EXT                  = 37,
    D3DDP2OP_TEXBLT               = 38,
    D3DDP2OP_STATESET             = 39,
    D3DDP2OP_SETPRIORITY          = 40,
#endif /* DIRECT3D_VERSION >= 0x0700 */
    D3DDP2OP_SETRENDERTARGET      = 41,
    D3DDP2OP_CLEAR                = 42,
#if(DIRECT3D_VERSION >= 0x0700)
    D3DDP2OP_SETTEXLOD            = 43,
    D3DDP2OP_SETCLIPPLANE         = 44,
#endif /* DIRECT3D_VERSION >= 0x0700 */
#if(DIRECT3D_VERSION >= 0x0800)
    D3DDP2OP_CREATEVERTEXSHADER   = 45,
    D3DDP2OP_DELETEVERTEXSHADER   = 46,
    D3DDP2OP_SETVERTEXSHADER      = 47,
    D3DDP2OP_SETVERTEXSHADERCONST = 48,
    D3DDP2OP_SETSTREAMSOURCE      = 49,
    D3DDP2OP_SETSTREAMSOURCEUM    = 50,
    D3DDP2OP_SETINDICES           = 51,
    D3DDP2OP_DRAWPRIMITIVE        = 52,
    D3DDP2OP_DRAWINDEXEDPRIMITIVE = 53,
    D3DDP2OP_CREATEPIXELSHADER    = 54,
    D3DDP2OP_DELETEPIXELSHADER    = 55,
    D3DDP2OP_SETPIXELSHADER       = 56,
    D3DDP2OP_SETPIXELSHADERCONST  = 57,
    D3DDP2OP_CLIPPEDTRIANGLEFAN   = 58,
    D3DDP2OP_DRAWPRIMITIVE2       = 59,
    D3DDP2OP_DRAWINDEXEDPRIMITIVE2= 60,
    D3DDP2OP_DRAWRECTPATCH        = 61,
    D3DDP2OP_DRAWTRIPATCH         = 62,
    D3DDP2OP_VOLUMEBLT            = 63,
    D3DDP2OP_BUFFERBLT            = 64,
    D3DDP2OP_MULTIPLYTRANSFORM    = 65,
    D3DDP2OP_ADDDIRTYRECT         = 66,
    D3DDP2OP_ADDDIRTYBOX          = 67
#endif /* DIRECT3D_VERSION >= 0x0800 */
} D3DHAL_DP2OPERATION;

//
// DrawPrimitives2 point primitives
//

typedef struct _D3DHAL_DP2POINTS
{
    WORD wCount;
    WORD wVStart;
} D3DHAL_DP2POINTS, *LPD3DHAL_DP2POINTS;

//
// DrawPrimitives2 line primitives
//

typedef struct _D3DHAL_DP2STARTVERTEX
{
    WORD wVStart;
} D3DHAL_DP2STARTVERTEX, *LPD3DHAL_DP2STARTVERTEX;

typedef struct _D3DHAL_DP2LINELIST
{
    WORD wVStart;
} D3DHAL_DP2LINELIST, *LPD3DHAL_DP2LINELIST;

typedef struct _D3DHAL_DP2INDEXEDLINELIST
{
    WORD wV1;
    WORD wV2;
} D3DHAL_DP2INDEXEDLINELIST, *LPD3DHAL_DP2INDEXEDLINELIST;

typedef struct _D3DHAL_DP2LINESTRIP
{
    WORD wVStart;
} D3DHAL_DP2LINESTRIP, *LPD3DHAL_DP2LINESTRIP;

typedef struct _D3DHAL_DP2INDEXEDLINESTRIP
{
    WORD wV[2];
} D3DHAL_DP2INDEXEDLINESTRIP, *LPD3DHAL_DP2INDEXEDLINESTRIP;

//
// DrawPrimitives2 triangle primitives
//

typedef struct _D3DHAL_DP2TRIANGLELIST
{
    WORD wVStart;
} D3DHAL_DP2TRIANGLELIST, *LPD3DHAL_DP2TRIANGLELIST;

typedef struct _D3DHAL_DP2INDEXEDTRIANGLELIST
{
    WORD wV1;
    WORD wV2;
    WORD wV3;
    WORD wFlags;
} D3DHAL_DP2INDEXEDTRIANGLELIST, *LPD3DHAL_DP2INDEXEDTRIANGLELIST;

typedef struct _D3DHAL_DP2INDEXEDTRIANGLELIST2
{
    WORD wV1;
    WORD wV2;
    WORD wV3;
} D3DHAL_DP2INDEXEDTRIANGLELIST2, *LPD3DHAL_DP2INDEXEDTRIANGLELIST2;

typedef struct _D3DHAL_DP2TRIANGLESTRIP
{
    WORD wVStart;
} D3DHAL_DP2TRIANGLESTRIP, *LPD3DHAL_DP2TRIANGLESTRIP;

typedef struct _D3DHAL_DP2INDEXEDTRIANGLESTRIP
{
    WORD wV[3];
} D3DHAL_DP2INDEXEDTRIANGLESTRIP, *LPD3DHAL_DP2INDEXEDTRIANGLESTRIP;

typedef struct _D3DHAL_DP2TRIANGLEFAN
{
    WORD wVStart;
} D3DHAL_DP2TRIANGLEFAN, *LPD3DHAL_DP2TRIANGLEFAN;

typedef struct _D3DHAL_DP2INDEXEDTRIANGLEFAN
{
    WORD wV[3];
} D3DHAL_DP2INDEXEDTRIANGLEFAN, *LPD3DHAL_DP2INDEXEDTRIANGLEFAN;

typedef struct _D3DHAL_DP2TRIANGLEFAN_IMM
{
    DWORD dwEdgeFlags;
} D3DHAL_DP2TRIANGLEFAN_IMM;

typedef D3DHAL_DP2TRIANGLEFAN_IMM  *LPD3DHAL_DP2TRIANGLEFAN_IMM;

//
// DrawPrimitives2 Renderstate changes
//

typedef struct _D3DHAL_DP2RENDERSTATE
{
    D3DRENDERSTATETYPE RenderState;
    union
    {
        D3DVALUE dvState;
        DWORD dwState;
    };
} D3DHAL_DP2RENDERSTATE;
typedef D3DHAL_DP2RENDERSTATE  * LPD3DHAL_DP2RENDERSTATE;

typedef struct _D3DHAL_DP2TEXTURESTAGESTATE
{
    WORD wStage;
    WORD TSState;
    DWORD dwValue;
} D3DHAL_DP2TEXTURESTAGESTATE;
typedef D3DHAL_DP2TEXTURESTAGESTATE  *LPD3DHAL_DP2TEXTURESTAGESTATE;

typedef struct _D3DHAL_DP2VIEWPORTINFO
{
    DWORD dwX;
    DWORD dwY;
    DWORD dwWidth;
    DWORD dwHeight;
} D3DHAL_DP2VIEWPORTINFO;
typedef D3DHAL_DP2VIEWPORTINFO  *LPD3DHAL_DP2VIEWPORTINFO;

typedef struct _D3DHAL_DP2WINFO
{
    D3DVALUE        dvWNear;
    D3DVALUE        dvWFar;
} D3DHAL_DP2WINFO;
typedef D3DHAL_DP2WINFO  *LPD3DHAL_DP2WINFO;

typedef struct _D3DHAL_DP2SETPALETTE
{
    DWORD dwPaletteHandle;
    DWORD dwPaletteFlags;
    DWORD dwSurfaceHandle;
} D3DHAL_DP2SETPALETTE;
typedef D3DHAL_DP2SETPALETTE  *LPD3DHAL_DP2SETPALETTE;

typedef struct _D3DHAL_DP2UPDATEPALETTE
{
    DWORD dwPaletteHandle;
    WORD  wStartIndex;
    WORD  wNumEntries;
} D3DHAL_DP2UPDATEPALETTE;
typedef D3DHAL_DP2UPDATEPALETTE  *LPD3DHAL_DP2UPDATEPALETTE;

typedef struct _D3DHAL_DP2SETRENDERTARGET
{
    DWORD hRenderTarget;
    DWORD hZBuffer;
} D3DHAL_DP2SETRENDERTARGET;
typedef D3DHAL_DP2SETRENDERTARGET  *LPD3DHAL_DP2SETRENDERTARGET;

#if(DIRECT3D_VERSION >= 0x0700)
// Values for dwOperations in the D3DHAL_DP2STATESET
#define D3DHAL_STATESETBEGIN     0
#define D3DHAL_STATESETEND       1
#define D3DHAL_STATESETDELETE    2
#define D3DHAL_STATESETEXECUTE   3
#define D3DHAL_STATESETCAPTURE   4
#endif /* DIRECT3D_VERSION >= 0x0700 */
#if(DIRECT3D_VERSION >= 0x0800)
#define D3DHAL_STATESETCREATE    5
#endif /* DIRECT3D_VERSION >= 0x0800 */
#if(DIRECT3D_VERSION >= 0x0700)

typedef struct _D3DHAL_DP2STATESET
{
    DWORD               dwOperation;
    DWORD               dwParam;  // State set handle passed with D3DHAL_STATESETBEGIN,
                                  // D3DHAL_STATESETEXECUTE, D3DHAL_STATESETDELETE
                                  // D3DHAL_STATESETCAPTURE
    D3DSTATEBLOCKTYPE   sbType;   // Type use with D3DHAL_STATESETBEGIN/END
} D3DHAL_DP2STATESET;
typedef D3DHAL_DP2STATESET  *LPD3DHAL_DP2STATESET;
//
// T&L Hal specific stuff
//
typedef struct _D3DHAL_DP2ZRANGE
{
    D3DVALUE    dvMinZ;
    D3DVALUE    dvMaxZ;
} D3DHAL_DP2ZRANGE;
typedef D3DHAL_DP2ZRANGE  *LPD3DHAL_DP2ZRANGE;

typedef D3DMATERIAL7 D3DHAL_DP2SETMATERIAL, *LPD3DHAL_DP2SETMATERIAL;

// Values for dwDataType in D3DHAL_DP2SETLIGHT
#define D3DHAL_SETLIGHT_ENABLE   0
#define D3DHAL_SETLIGHT_DISABLE  1
// If this is set, light data will be passed in after the
// D3DLIGHT7 structure
#define D3DHAL_SETLIGHT_DATA     2

typedef struct _D3DHAL_DP2SETLIGHT
{
    DWORD     dwIndex;
    DWORD     dwDataType;
} D3DHAL_DP2SETLIGHT;
typedef D3DHAL_DP2SETLIGHT  *LPD3DHAL_DP2SETLIGHT;

typedef struct _D3DHAL_DP2SETCLIPPLANE
{
    DWORD     dwIndex;
    D3DVALUE  plane[4];
} D3DHAL_DP2SETCLIPPLANE;
typedef D3DHAL_DP2SETCLIPPLANE  *LPD3DHAL_DP2SETCLIPPLANE;

typedef struct _D3DHAL_DP2CREATELIGHT
{
    DWORD dwIndex;
} D3DHAL_DP2CREATELIGHT;
typedef D3DHAL_DP2CREATELIGHT  *LPD3DHAL_DP2CREATELIGHT;

typedef struct _D3DHAL_DP2SETTRANSFORM
{
    D3DTRANSFORMSTATETYPE xfrmType;
    D3DMATRIX matrix;
} D3DHAL_DP2SETTRANSFORM;
typedef D3DHAL_DP2SETTRANSFORM  *LPD3DHAL_DP2SETTRANSFORM;

typedef struct _D3DHAL_DP2MULTIPLYTRANSFORM
{
    D3DTRANSFORMSTATETYPE xfrmType;
    D3DMATRIX matrix;
} D3DHAL_DP2MULTIPLYTRANSFORM;
typedef D3DHAL_DP2MULTIPLYTRANSFORM  *LPD3DHAL_DP2MULTIPLYTRANSFORM;

typedef struct _D3DHAL_DP2EXT
{
    DWORD dwExtToken;
    DWORD dwSize;
} D3DHAL_DP2EXT;
typedef D3DHAL_DP2EXT  *LPD3DHAL_DP2EXT;

typedef struct _D3DHAL_DP2TEXBLT
{
    DWORD   dwDDDestSurface;// dest surface
    DWORD   dwDDSrcSurface; // src surface
    POINT   pDest;
    RECTL   rSrc;       // src rect
    DWORD   dwFlags;    // blt flags
} D3DHAL_DP2TEXBLT;
typedef D3DHAL_DP2TEXBLT  *LPD3DHAL_DP2TEXBLT;

typedef struct _D3DHAL_DP2SETPRIORITY
{
    DWORD dwDDSurface;
    DWORD dwPriority;
} D3DHAL_DP2SETPRIORITY;
typedef D3DHAL_DP2SETPRIORITY  *LPD3DHAL_DP2SETPRIORITY;
#endif /* DIRECT3D_VERSION >= 0x0700 */

typedef struct _D3DHAL_DP2CLEAR
{
  // dwFlags can contain D3DCLEAR_TARGET, D3DCLEAR_ZBUFFER, and/or D3DCLEAR_STENCIL
    DWORD               dwFlags;        // in:  surfaces to clear
    DWORD               dwFillColor;    // in:  Color value for rtarget
    D3DVALUE            dvFillDepth;    // in:  Depth value for Z buffer (0.0-1.0)
    DWORD               dwFillStencil;  // in:  value used to clear stencil buffer
    RECT                Rects[1];       // in:  Rectangles to clear
} D3DHAL_DP2CLEAR;
typedef D3DHAL_DP2CLEAR  *LPD3DHAL_DP2CLEAR;


#if(DIRECT3D_VERSION >= 0x0700)
typedef struct _D3DHAL_DP2SETTEXLOD
{
    DWORD dwDDSurface;
    DWORD dwLOD;
} D3DHAL_DP2SETTEXLOD;
typedef D3DHAL_DP2SETTEXLOD  *LPD3DHAL_DP2SETTEXLOD;
#endif /* DIRECT3D_VERSION >= 0x0700 */

#if(DIRECT3D_VERSION >= 0x0800)

// Used by SetVertexShader and DeleteVertexShader
typedef struct _D3DHAL_DP2VERTEXSHADER
{
    // Vertex shader handle.
    // The handle could be 0, meaning that the current vertex shader is invalid
    // (not set). When driver recieves handle 0, it should invalidate all
    // streams pointer
    DWORD dwHandle;
} D3DHAL_DP2VERTEXSHADER;
typedef D3DHAL_DP2VERTEXSHADER  *LPD3DHAL_DP2VERTEXSHADER;

typedef struct _D3DHAL_DP2CREATEVERTEXSHADER
{
    DWORD dwHandle;     // Shader handle
    DWORD dwDeclSize;   // Shader declaration size in bytes
    DWORD dwCodeSize;   // Shader code size in bytes
    // Declaration follows
    // Shader code follows
} D3DHAL_DP2CREATEVERTEXSHADER;
typedef D3DHAL_DP2CREATEVERTEXSHADER  *LPD3DHAL_DP2CREATEVERTEXSHADER;

typedef struct _D3DHAL_DP2SETVERTEXSHADERCONST
{
    DWORD dwRegister;   // Const register to start copying
    DWORD dwCount;      // Number of 4-float vectors to copy
    // Data follows
} D3DHAL_DP2SETVERTEXSHADERCONST;
typedef D3DHAL_DP2SETVERTEXSHADERCONST  *LPD3DHAL_DP2SETVERTEXSHADERCONST;

typedef struct _D3DHAL_DP2SETSTREAMSOURCE
{
    DWORD dwStream;     // Stream index, starting from zero
    DWORD dwVBHandle;   // Vertex buffer handle
    DWORD dwStride;     // Vertex size in bytes
} D3DHAL_DP2SETSTREAMSOURCE;
typedef D3DHAL_DP2SETSTREAMSOURCE  *LPD3DHAL_DP2SETSTREAMSOURCE;

typedef struct _D3DHAL_DP2SETSTREAMSOURCEUM
{
    DWORD dwStream;     // Stream index, starting from zero
    DWORD dwStride;     // Vertex size in bytes
} D3DHAL_DP2SETSTREAMSOURCEUM;
typedef D3DHAL_DP2SETSTREAMSOURCEUM  *LPD3DHAL_DP2SETSTREAMSOURCEUM;

typedef struct _D3DHAL_DP2SETINDICES
{
    DWORD dwVBHandle;           // Index buffer handle
    DWORD dwStride;             // Index size in bytes (2 or 4)
} D3DHAL_DP2SETINDICES;
typedef D3DHAL_DP2SETINDICES  *LPD3DHAL_DP2SETINDICES;

typedef struct _D3DHAL_DP2DRAWPRIMITIVE
{
    D3DPRIMITIVETYPE primType;
    DWORD VStart;
    DWORD PrimitiveCount;
} D3DHAL_DP2DRAWPRIMITIVE;
typedef D3DHAL_DP2DRAWPRIMITIVE  *LPD3DHAL_DP2DRAWPRIMITIVE;

typedef struct _D3DHAL_DP2DRAWINDEXEDPRIMITIVE
{
    D3DPRIMITIVETYPE primType;
    INT   BaseVertexIndex;          // Vertex which corresponds to index 0
    DWORD MinIndex;                 // Min vertex index in the vertex buffer
    DWORD NumVertices;              // Number of vertices starting from MinIndex
    DWORD StartIndex;               // Start index in the index buffer
    DWORD PrimitiveCount;
} D3DHAL_DP2DRAWINDEXEDPRIMITIVE;
typedef D3DHAL_DP2DRAWINDEXEDPRIMITIVE  *LPD3DHAL_DP2DRAWINDEXEDPRIMITIVE;

typedef struct _D3DHAL_CLIPPEDTRIANGLEFAN
{
    DWORD FirstVertexOffset;            // Offset in bytes in the current stream 0
    DWORD dwEdgeFlags;
    DWORD PrimitiveCount;
} D3DHAL_CLIPPEDTRIANGLEFAN;
typedef D3DHAL_CLIPPEDTRIANGLEFAN  *LPD3DHAL_CLIPPEDTRIANGLEFAN;

typedef struct _D3DHAL_DP2DRAWPRIMITIVE2
{
    D3DPRIMITIVETYPE primType;
    DWORD FirstVertexOffset;            // Offset in bytes in the stream 0
    DWORD PrimitiveCount;
} D3DHAL_DP2DRAWPRIMITIVE2;
typedef D3DHAL_DP2DRAWPRIMITIVE2  *LPD3DHAL_DP2DRAWPRIMITIVE2;

typedef struct _D3DHAL_DP2DRAWINDEXEDPRIMITIVE2
{
    D3DPRIMITIVETYPE primType;
    INT   BaseVertexOffset;     // Stream 0 offset of the vertex which
                                // corresponds to index 0. This offset could be
                                // negative, but when an index is added to the
                                // offset the result is positive
    DWORD MinIndex;             // Min vertex index in the vertex buffer
    DWORD NumVertices;          // Number of vertices starting from MinIndex
    DWORD StartIndexOffset;     // Offset of the start index in the index buffer
    DWORD PrimitiveCount;       // Number of triangles (points, lines)
} D3DHAL_DP2DRAWINDEXEDPRIMITIVE2;
typedef D3DHAL_DP2DRAWINDEXEDPRIMITIVE2  *LPD3DHAL_DP2DRAWINDEXEDPRIMITIVE2;

// Used by SetPixelShader and DeletePixelShader
typedef struct _D3DHAL_DP2PIXELSHADER
{
    // Pixel shader handle.
    // The handle could be 0, meaning that the current pixel shader is invalid
    // (not set).
    DWORD dwHandle;
} D3DHAL_DP2PIXELSHADER;
typedef D3DHAL_DP2PIXELSHADER  *LPD3DHAL_DP2PIXELSHADER;

typedef struct _D3DHAL_DP2CREATEPIXELSHADER
{
    DWORD dwHandle;     // Shader handle
    DWORD dwCodeSize;   // Shader code size in bytes
    // Shader code follows
} D3DHAL_DP2CREATEPIXELSHADER;
typedef D3DHAL_DP2CREATEPIXELSHADER  *LPD3DHAL_DP2CREATEPIXELSHADER;

typedef struct _D3DHAL_DP2SETPIXELSHADERCONST
{
    DWORD dwRegister;   // Const register to start copying
    DWORD dwCount;      // Number of 4-float vectors to copy
    // Data follows
} D3DHAL_DP2SETPIXELSHADERCONST;
typedef D3DHAL_DP2SETPIXELSHADERCONST  *LPD3DHAL_DP2SETPIXELSHADERCONST;

// Flags that can be supplied to DRAWRECTPATCH and DRAWTRIPATCH
#define RTPATCHFLAG_HASSEGS  0x00000001L
#define RTPATCHFLAG_HASINFO  0x00000002L

typedef struct _D3DHAL_DP2DRAWRECTPATCH
{
    DWORD Handle;
    DWORD Flags;
    // Optionally followed by D3DFLOAT[4] NumSegments and/or D3DRECTPATCH_INFO
} D3DHAL_DP2DRAWRECTPATCH;
typedef D3DHAL_DP2DRAWRECTPATCH  *LPD3DHAL_DP2DRAWRECTPATCH;

typedef struct _D3DHAL_DP2DRAWTRIPATCH
{
    DWORD Handle;
    DWORD Flags;
    // Optionally followed by D3DFLOAT[3] NumSegments and/or D3DTRIPATCH_INFO
} D3DHAL_DP2DRAWTRIPATCH;
typedef D3DHAL_DP2DRAWTRIPATCH  *LPD3DHAL_DP2DRAWTRIPATCH;

typedef struct _D3DHAL_DP2VOLUMEBLT
{
    DWORD   dwDDDestSurface;// dest surface
    DWORD   dwDDSrcSurface; // src surface
    DWORD   dwDestX;        // dest X (width)
    DWORD   dwDestY;        // dest Y (height)
    DWORD   dwDestZ;        // dest Z (depth)
    D3DBOX  srcBox;         // src box
    DWORD   dwFlags;        // blt flags
} D3DHAL_DP2VOLUMEBLT;
typedef D3DHAL_DP2VOLUMEBLT  *LPD3DHAL_DP2VOLUMEBLT;

typedef struct _D3DHAL_DP2BUFFERBLT
{
    DWORD     dwDDDestSurface; // dest surface
    DWORD     dwDDSrcSurface;  // src surface
    DWORD     dwOffset;        // Offset in the dest surface (in BYTES)
    D3DRANGE  rSrc;            // src range
    DWORD     dwFlags;         // blt flags
} D3DHAL_DP2BUFFERBLT;
typedef D3DHAL_DP2BUFFERBLT  *LPD3DHAL_DP2BUFFERBLT;

typedef struct _D3DHAL_DP2ADDDIRTYRECT
{
    DWORD     dwSurface;      // Driver managed surface
    RECTL     rDirtyArea;     // Area marked dirty
} D3DHAL_DP2ADDDIRTYRECT;
typedef D3DHAL_DP2ADDDIRTYRECT  *LPD3DHAL_DP2ADDDIRTYRECT;

typedef struct _D3DHAL_DP2ADDDIRTYBOX
{
    DWORD     dwSurface;      // Driver managed volume
    D3DBOX    DirtyBox;       // Box marked dirty
} D3DHAL_DP2ADDDIRTYBOX;
typedef D3DHAL_DP2ADDDIRTYBOX  *LPD3DHAL_DP2ADDDIRTYBOX;

#endif /* DIRECT3D_VERSION >= 0x0800 */

typedef struct _D3DHAL_DRAWPRIMITIVES2DATA {
    ULONG_PTR             dwhContext;           // in: Context handle
    DWORD             dwFlags;              // in: flags
    DWORD             dwVertexType;         // in: vertex type
    LPDDRAWI_DDRAWSURFACE_LCL lpDDCommands; // in: vertex buffer command data
    DWORD             dwCommandOffset;      // in: offset to start of vertex buffer commands
    DWORD             dwCommandLength;      // in: number of bytes of command data
    union
    { // based on D3DHALDP2_USERMEMVERTICES flag
       LPDDRAWI_DDRAWSURFACE_LCL lpDDVertex;// in: surface containing vertex data
       LPVOID lpVertices;                   // in: User mode pointer to vertices
    };
    DWORD             dwVertexOffset;       // in: offset to start of vertex data
    DWORD             dwVertexLength;       // in: number of vertices of vertex data
    DWORD             dwReqVertexBufSize;   // in: number of bytes required for the next vertex buffer
    DWORD             dwReqCommandBufSize;  // in: number of bytes required for the next commnand buffer
    LPDWORD           lpdwRStates;          // in: Pointer to the array where render states are updated
    union
    {
       DWORD          dwVertexSize;         // in: Size of each vertex in bytes
       HRESULT        ddrval;               // out: return value
    };
    DWORD             dwErrorOffset;        // out: offset in lpDDCommands to
                                            //      first D3DHAL_COMMAND not handled
} D3DHAL_DRAWPRIMITIVES2DATA;
typedef D3DHAL_DRAWPRIMITIVES2DATA  *LPD3DHAL_DRAWPRIMITIVES2DATA;

// Macros to access vertex shader binary code

#define D3DSI_GETREGTYPE(token) (token & D3DSP_REGTYPE_MASK)
#define D3DSI_GETREGNUM(token)  (token & D3DSP_REGNUM_MASK)
#define D3DSI_GETOPCODE(command) (command & D3DSI_OPCODE_MASK)
#define D3DSI_GETWRITEMASK(token) (token & D3DSP_WRITEMASK_ALL)
#define D3DVS_GETSWIZZLECOMP(source, component)  (source >> ((component << 1) + 16) & 0x3)
#define D3DVS_GETSWIZZLE(token)  (token & D3DVS_SWIZZLE_MASK)
#define D3DVS_GETSRCMODIFIER(token) (token & D3DSP_SRCMOD_MASK)
#define D3DVS_GETADDRESSMODE(token) (token & D3DVS_ADDRESSMODE_MASK)

// Indicates that the lpVertices field in the DrawPrimitives2 data is
// valid, i.e. user allocated memory.
#define D3DHALDP2_USERMEMVERTICES   0x00000001L
// Indicates that the command buffer and vertex buffer are a system memory execute buffer
// resulting from the use of the Execute buffer API.
#define D3DHALDP2_EXECUTEBUFFER     0x00000002L
// The swap flags indicate if it is OK for the driver to swap the submitted buffers with new
// buffers and asyncronously work on the submitted buffers.
#define D3DHALDP2_SWAPVERTEXBUFFER  0x00000004L
#define D3DHALDP2_SWAPCOMMANDBUFFER 0x00000008L
// The requested flags are present if the new buffers which the driver can allocate need to be
// of atleast a given size. If any of these flags are set, the corresponding dwReq* field in
// D3DHAL_DRAWPRIMITIVES2DATA will also be set with the requested size in bytes.
#define D3DHALDP2_REQVERTEXBUFSIZE  0x00000010L
#define D3DHALDP2_REQCOMMANDBUFSIZE 0x00000020L
// These flags are set by the driver upon return from DrawPrimitives2 indicating if the new
// buffers are not in system memory.
#define D3DHALDP2_VIDMEMVERTEXBUF   0x00000040L
#define D3DHALDP2_VIDMEMCOMMANDBUF  0x00000080L


// Used by the driver to ask runtime to parse the execute buffer
#define D3DERR_COMMAND_UNPARSED              MAKE_DDHRESULT(3000)

typedef DWORD (CALLBACK *LPD3DHAL_CLEAR2CB)        (LPD3DHAL_CLEAR2DATA);
typedef DWORD (CALLBACK *LPD3DHAL_VALIDATETEXTURESTAGESTATECB)(LPD3DHAL_VALIDATETEXTURESTAGESTATEDATA);
typedef DWORD (CALLBACK *LPD3DHAL_DRAWPRIMITIVES2CB)  (LPD3DHAL_DRAWPRIMITIVES2DATA);

typedef struct _D3DHAL_CALLBACKS3
{
    DWORD   dwSize;         // size of struct
    DWORD   dwFlags;        // flags for callbacks
    LPD3DHAL_CLEAR2CB                       Clear2;
    LPVOID                                  lpvReserved;
    LPD3DHAL_VALIDATETEXTURESTAGESTATECB    ValidateTextureStageState;
    LPD3DHAL_DRAWPRIMITIVES2CB              DrawPrimitives2;
} D3DHAL_CALLBACKS3;
typedef D3DHAL_CALLBACKS3 *LPD3DHAL_CALLBACKS3;
#define D3DHAL_CALLBACKS3SIZE       sizeof(D3DHAL_CALLBACKS3)

//  bit definitions for D3DHAL
#define D3DHAL3_CB32_CLEAR2                      0x00000001L
#define D3DHAL3_CB32_RESERVED                    0x00000002L
#define D3DHAL3_CB32_VALIDATETEXTURESTAGESTATE   0x00000004L
#define D3DHAL3_CB32_DRAWPRIMITIVES2             0x00000008L

/* --------------------------------------------------------------
 * Texture stage renderstate mapping definitions.
 *
 * 256 renderstate slots [256, 511] are reserved for texture processing
 * stage controls, which provides for 8 texture processing stages each
 * with 32 DWORD controls.
 *
 * The renderstates within each stage are indexed by the
 * D3DTEXTURESTAGESTATETYPE enumerants by adding the appropriate
 * enumerant to the base for a given texture stage.
 *
 * Note, "state overrides" bias the renderstate by 256, so the two
 * ranges overlap.  Overrides are enabled for exebufs only, so all
 * this means is that Texture3 cannot be used with exebufs.
 */

/*
 * Base of all texture stage state values in renderstate array.
 */
#define D3DHAL_TSS_RENDERSTATEBASE 256UL

/*
 * Maximum number of stages allowed.
 */
#define D3DHAL_TSS_MAXSTAGES 8

/*
 * Number of state DWORDS per stage.
 */
#define D3DHAL_TSS_STATESPERSTAGE 64

/*
 * Texture handle's offset into the 32-DWORD cascade state vector
 */
#define D3DTSS_TEXTUREMAP 0

/* --------------------------------------------------------------
 * Flags for the data parameters.
 */

/*
 * SceneCapture()
 * This is used as an indication to the driver that a scene is about to
 * start or end, and that it should capture data if required.
 */
#define D3DHAL_SCENE_CAPTURE_START  0x00000000L
#define D3DHAL_SCENE_CAPTURE_END    0x00000001L

/*
 * Execute()
 */

/*
 * Use the instruction stream starting at dwOffset.
 */
#define D3DHAL_EXECUTE_NORMAL       0x00000000L

/*
 * Use the optional instruction override (diInstruction) and return
 * after completion.  dwOffset is the offset to the first primitive.
 */
#define D3DHAL_EXECUTE_OVERRIDE     0x00000001L

/*
 * GetState()
 * The driver will get passed a flag in dwWhich specifying which module
 * the state must come from.  The driver then fills in ulArg[1] with the
 * appropriate value depending on the state type given in ddState.
 */

/*
 * The following are used to get the state of a particular stage of the
 * pipeline.
 */
#define D3DHALSTATE_GET_TRANSFORM   0x00000001L
#define D3DHALSTATE_GET_LIGHT       0x00000002L
#define D3DHALSTATE_GET_RENDER      0x00000004L


/* --------------------------------------------------------------
 * Return values from HAL functions.
 */

/*
 * The context passed in was bad.
 */
#define D3DHAL_CONTEXT_BAD      0x000000200L

/*
 * No more contexts left.
 */
#define D3DHAL_OUTOFCONTEXTS        0x000000201L

/*
 * Execute() and ExecuteClipped()
 */

/*
 * Executed to completion via early out.
 *  (e.g. totally clipped)
 */
#define D3DHAL_EXECUTE_ABORT        0x00000210L

/*
 * An unhandled instruction code was found (e.g. D3DOP_TRANSFORM).
 * The dwOffset parameter must be set to the offset of the unhandled
 * instruction.
 *
 * Only valid from Execute()
 */
#define D3DHAL_EXECUTE_UNHANDLED    0x00000211L

// typedef for the Callback that the drivers can use to parse unknown commands
// passed to them via the DrawPrimitives2 callback. The driver obtains this
// callback thru a GetDriverInfo call with GUID_D3DParseUnknownCommandCallback
// made by ddraw somewhere around the initialization time.
typedef HRESULT (CALLBACK *PFND3DPARSEUNKNOWNCOMMAND) (LPVOID lpvCommands,
                                         LPVOID *lplpvReturnedCommand);

#define D3DRENDERSTATE_EVICTMANAGEDTEXTURES 61  // DDI render state only to Evict textures
#define D3DRENDERSTATE_SCENECAPTURE     62      // DDI only to replace SceneCapture
#define D3DRS_DELETERTPATCH       169     // DDI only to delete high order patch

//-----------------------------------------------------------------------------
//
// DirectX 8.0's new driver info querying mechanism.
//
// How to handle the new driver info query mechanism.
//
// DirectX 8.0 utilizes an extension to GetDriverInfo() to query for
// additional information from the driver. Currently this mechanism is only
// used for querying for DX8 style D3D caps but it may be used for other
// information over time.
//
// This extension to GetDriverInfo takes the form of a GetDriverInfo call
// with the GUID GUID_GetDriverInfo2. When a GetDriverInfo call with this
// GUID is received by the driver the driver must check the data passed
// in the lpvData field of the DD_GETDRIVERINFODATA data structure to see
// what information is being requested.
//
// It is important to note that the GUID GUID_GetDriverInfo2 is, in fact,
// the same as the GUID_DDStereoMode. If you driver doesn't handle
// GUID_DDStereoMode this is not an issue. However, if you wish your driver
// to handle GUID_DDStereoMode as well as GUID_GetDriverInfo2 special action
// must be taken. When a call tp GetDriverInfo with the GUID
// GUID_GetDriverInfo2/GUID_DDStereoMode is made the runtime sets the
// dwHeight field of the DD_STEREOMODE structure to the special value
// D3DGDI2_MAGIC. In this way you can determine when the request is a
// stereo mode call or a GetDriverInfo2 call. The dwHeight field of
// DD_STEREOMODE corresponds to the dwMagic field of the
// DD_GETDRIVERINFO2DATA structure.
//
// The dwExpectedSize field of the DD_GETDRIVERINFODATA structure is not
// used by when a GetDriverInfo2 request is being made and should be
// ignored. The actual expected size of the data is found in the
// dwExpectedSize of the DD_GETDRIVERINFO2DATA structure.
//
// Once the driver has determined that this is a call to
// GetDriverInfo2 it must then determine the type of information being
// requested by the runtime. This type is contained in the dwType field
// of the DD_GETDRIVERINFO2DATA data structure.
//
// Finally, once the driver knows this is a GetDriverInfo2 request of a
// particular type it can copy the requested data into the data buffer.
// It is important to note that the lpvData field of the DD_GETDRIVERINFODATA
// data structure points to data buffer in which to copy your data. lpvData
// also points to the DD_GETDRIVERINFO2DATA structure. This means that the
// data returned by the driver will overwrite the DD_GETDRIVERINFO2DATA
// structure and, hence, the DD_GETDRIVERINFO2DATA structure occupies the
// first few DWORDs of the buffer.
//
// The following code fragment demonstrates how to handle GetDriverInfo2.
//
// D3DCAPS8 myD3DCaps8;
//
// DWORD CALLBACK
// DdGetDriverInfo(LPDDHAL_GETDRIVERINFODATA lpData)
// {
//     if (MATCH_GUID((lpData->guidInfo), GUID_GetDriverInfo2) )
//     {
//         ASSERT(NULL != lpData);
//         ASSERT(NULL != lpData->lpvData);
//
//         // Is this a call to GetDriverInfo2 or DDStereoMode?
//         if (((DD_GETDRIVERINFO2DATA*)(lpData->lpvData))->dwMagic == D3DGDI2_MAGIC)
//         {
//             // Yes, its a call to GetDriverInfo2, fetch the
//             // DD_GETDRIVERINFO2DATA data structure.
//             DD_GETDRIVERINFO2DATA* pgdi2 = lpData->lpvData;
//             ASSERT(NULL != pgdi2);
//
//             // What type of request is this?
//             switch (pgdi2->dwType)
//             {
//             case D3DGDI2_TYPE_GETD3DCAPS8:
//                 {
//                     // The runtime is requesting the DX8 D3D caps so
//                     // copy them over now.
//
//                     // It should be noted that the dwExpectedSize field
//                     // of DD_GETDRIVERINFODATA is not used for
//                     // GetDriverInfo2 calls and should be ignored.
//                     size_t copySize = min(sizeof(myD3DCaps8), pgdi2->dwExpectedSize);
//                     memcpy(lpData->lpvData, &myD3DCaps8, copySize);
//                     lpData->dwActualSize = copySize;
//                     lpData->ddRVal       = DD_OK;
//                     return DDHAL_DRIVER_HANDLED;
//                 }
//             default:
//                 // For any other GetDriverInfo2 types not handled
//                 // or understood by the driver set an ddRVal of
//                 // DDERR_CURRENTLYNOTAVAIL and return
//                 // DDHAL_DRIVER_HANDLED.
//                 return DDHAL_DRIVER_HANDLED;
//             }
//         }
//         else
//         {
//             // It must be a call a request for stereo mode support.
//             // Fetch the stereo mode data
//             DD_STEREOMODE* pStereoMode = lpData->lpvData;
//             ASSERT(NULL != pStereoMode);
//
//             // Process the stereo mode request...
//             lpData->dwActualSize = sizeof(DD_STEREOMODE);
//             lpData->ddRVal       = DD_OK;
//             return DDHAL_DRIVER_HANDLED;
//         }
//     }
//
//     // Handle any other device GUIDs...
//
// } // DdGetDriverInfo
//
//-----------------------------------------------------------------------------

//
// The data structure which is passed to the driver when GetDriverInfo is
// called with a GUID of GUID_GetDriverInfo2.
//
// NOTE: Although the fields listed below are all read only this data
// structure is actually the first four DWORDs of the data buffer into
// which the driver writes the requested infomation. As such, these fields
// (and the entire data structure) are overwritten by the data returned by
// the driver.
//
typedef struct _DD_GETDRIVERINFO2DATA
{
    DWORD       dwReserved;     // Reserved Field.
                                // Driver should not read or write this field.

    DWORD       dwMagic;        // Magic Number. Has the value D3DGDI2_MAGIC if
                                // this is a GetDriverInfo2 call. Otherwise
                                // this structure is, in fact, a DD_STEREOMODE
                                // call.
                                // Driver should only read this field.

    DWORD       dwType;         // Type of information requested. This field
                                // contains one of the DDGDI2_TYPE_ #defines
                                // listed below.
                                // Driver should only read (not write) this
                                // field.

    DWORD       dwExpectedSize; // Expected size of the information requested.
                                // Driver should only read (not write) this
                                // field.

    // The remainder of the data buffer (beyond the first four DWORDs)
    // follows here.
} DD_GETDRIVERINFO2DATA;

//
// IMPORTANT NOTE: This GUID has exactly the same value as GUID_DDStereoMode
// and as such you must be very careful when using it. If your driver needs
// to handle both GetDriverInfo2 and DDStereoMode it must have a single
// check for the shared GUID and then distinguish between which use of that
// GUID is being requested.
//
#define GUID_GetDriverInfo2 (GUID_DDStereoMode)

//
// Magic value used to determine whether a GetDriverInfo call with the
// GUID GUID_GetDriverInfo2/GUID_DDStereoMode is a GetDriverInfo2 request
// or a query about stereo capabilities. This magic number is stored in
// the dwHeight field of the DD_STEREOMODE data structure.
//
#define D3DGDI2_MAGIC       (0xFFFFFFFFul)

//
// The types of information which can be requested from the driver via
// GetDriverInfo2.
//

#define D3DGDI2_TYPE_GETD3DCAPS8    (0x00000001ul)  // Return the D3DCAPS8 data
#define D3DGDI2_TYPE_GETFORMATCOUNT (0x00000002ul)  // Return the number of supported formats
#define D3DGDI2_TYPE_GETFORMAT      (0x00000003ul)  // Return a particular format
#define D3DGDI2_TYPE_DXVERSION      (0x00000004ul)  // Notify driver of current DX Version
#define D3DGDI2_TYPE_DEFERRED_AGP_AWARE     (0x00000018ul) // Runtime is aware of deferred AGP frees, and will send following (NT only)
#define D3DGDI2_TYPE_FREE_DEFERRED_AGP      (0x00000019ul) // Free any deferred-freed AGP allocations for this process (NT only)
#define D3DGDI2_TYPE_DEFER_AGP_FREES        (0x00000020ul) // Start defering AGP frees for this process

//
// This data structure is returned by the driver in response to a
// GetDriverInfo2 query with the type D3DGDI2_TYPE_GETFORMATCOUNT. It simply
// gives the number of surface formats supported by the driver. Currently this
// structure consists of a single member giving the number of supported
// surface formats.
//
typedef struct _DD_GETFORMATCOUNTDATA
{
    DD_GETDRIVERINFO2DATA gdi2;          // [in/out] GetDriverInfo2 data
    DWORD                 dwFormatCount; // [out]    Number of supported surface formats
    DWORD                 dwReserved;    // Reserved
} DD_GETFORMATCOUNTDATA;

//
// This data structure is used to request a specific surface format from the
// driver. It is guaranteed that the requested format will be greater than or
// equal to zero and less that the format count reported by the driver from
// the preceeding D3DGDI2_TYPE_GETFORMATCOUNT request.
//
typedef struct _DD_GETFORMATDATA
{
    DD_GETDRIVERINFO2DATA gdi2;             // [in/out] GetDriverInfo2 data
    DWORD                 dwFormatIndex;    // [in]     The format to return
    DDPIXELFORMAT         format;           // [out]    The actual format
} DD_GETFORMATDATA;

//
// This data structure is used to notify drivers about the DirectX version
// number. This is the value that is denoted as DD_RUNTIME_VERSION in the
// DDK headers.
//
typedef struct _DD_DXVERSION
{
    DD_GETDRIVERINFO2DATA gdi2;             // [in/out] GetDriverInfo2 data
    DWORD                 dwDXVersion;      // [in]     The Version of DX
    DWORD                 dwReserved;       // Reserved
} DD_DXVERSION;

// Informs driver that runtime will send a notification after last outstanding AGP
// lock has been released. 
typedef struct _DD_DEFERRED_AGP_AWARE_DATA
{
    DD_GETDRIVERINFO2DATA gdi2;        // [in/out] GetDriverInfo2 data
} DD_DEFERRED_AGP_AWARE_DATA;

// Notification that the last AGP lock has been released. Driver can free all deferred AGP 
// allocations for this process.
typedef struct _DD_FREE_DEFERRED_AGP_DATA
{
    DD_GETDRIVERINFO2DATA gdi2;        // [in/out] GetDriverInfo2 data
    DWORD dwProcessId;                   // [in] Process ID for whom to free deferred AGP
} DD_FREE_DEFERRED_AGP_DATA;

// New Caps that are not API visible that the driver exposes.
#define D3DDEVCAPS_HWVERTEXBUFFER       0x02000000L /* Device supports Driver Allocated Vertex Buffers*/
#define D3DDEVCAPS_HWINDEXBUFFER        0x04000000L /* Device supports Driver Allocated Index Buffers*/
#define D3DDEVCAPS_SUBVOLUMELOCK        0x08000000L /* Device supports locking a part of volume texture*/
#ifndef D3DPMISCCAPS_FOGINFVF
#define D3DPMISCCAPS_FOGINFVF           0x00002000L /* Device supports separate fog value in the FVF */
#endif
#ifndef D3DFVF_FOG
#define D3DFVF_FOG                      0x00002000L /* There is a separate fog value in the FVF vertex */
#endif

//
// This stuff is not API visible but should be DDI visible.
// Should be in Sync with d3d8types.h
//
#define D3DFMT_D32    (D3DFORMAT)71
#define D3DFMT_S1D15  (D3DFORMAT)72
#define D3DFMT_D15S1  (D3DFORMAT)73
#define D3DFMT_S8D24  (D3DFORMAT)74
#define D3DFMT_D24S8  (D3DFORMAT)75
#define D3DFMT_X8D24  (D3DFORMAT)76
#define D3DFMT_D24X8 (D3DFORMAT)77
#define D3DFMT_X4S4D24 (D3DFORMAT)78
#define D3DFMT_D24X4S4 (D3DFORMAT)79

// Vertex Shader 1.1 register limits. D3D device must provide at least
// specified number of registers
//
#define D3DVS_INPUTREG_MAX_V1_1         16
#define D3DVS_TEMPREG_MAX_V1_1          12
// This max required number. Device could have more registers. Check caps.
#define D3DVS_CONSTREG_MAX_V1_1         96
#define D3DVS_TCRDOUTREG_MAX_V1_1       8
#define D3DVS_ADDRREG_MAX_V1_1          1
#define D3DVS_ATTROUTREG_MAX_V1_1       2
#define D3DVS_MAXINSTRUCTIONCOUNT_V1_1  128

// Pixel Shader DX8 register limits. D3D device will have at most these
// specified number of registers
//
#define D3DPS_INPUTREG_MAX_DX8         8
#define D3DPS_TEMPREG_MAX_DX8          8
#define D3DPS_CONSTREG_MAX_DX8         16
#define D3DPS_TEXTUREREG_MAX_DX8       8


#endif /* _D3DHAL_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\ddk\inc\csq.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    csq.h

Abstract:

    This header exposes the cancel safe queue DDIs for use on Win2K at later.
    Drivers that use this header should link to csq.lib. If a driver only needs
    to work on XP or later, neither this header or the lib are required (the
    XP kernel supports the cancel safe queue DDIs natively.)

Author:

    Nar Ganapathy (narg) 1-Jan-1999

Revision History:

--*/

// Cancel SAFE DDI set start
//
// The following DDIs are to help ease the pain of writing queue packages that
// handle the cancellation race well. The idea of this set of DDIs is to not
// force a single queue data structure but allow the cancel logic to be hidden
// from the drivers. A driver implements a queue and as part of its header
// includes the IO_CSQ structure. In its initialization routine it calls
// IoInitializeCsq. Then in the dispatch routine when the driver wants to
// insert an IRP into the queue it calls IoCsqInsertIrp. When the driver wants
// to remove something from the queue it calls IoCsqRemoveIrp. Note that Insert
// can fail if the IRP was cancelled in the meantime. Remove can also fail if
// the IRP was already cancelled.
//
// There are typically two modes where drivers queue IRPs. These two modes are
// covered by the cancel safe queue DDI set.
//
// Mode 1:
// One is where the driver queues the IRP and at some later
// point in time dequeues an IRP and issues the IO request.
// For this mode the driver should use IoCsqInsertIrp and IoCsqRemoveNextIrp.
// The driver in this case is expected to pass NULL to the irp context
// parameter in IoInsertIrp.
//
// Mode 2:
// In this the driver queues theIRP, issues the IO request (like issuing a DMA
// request or writing to a register) and when the IO request completes (either
// using a DPC or timer) the driver dequeues the IRP and completes it. For this
// mode the driver should use IoCsqInsertIrp and IoCsqRemoveIrp. In this case
// the driver should allocate an IRP context and pass it in to IoCsqInsertIrp.
// The cancel DDI code creates an association between the IRP and the context
// and thus ensures that when the time comes to remove the IRP it can ascertain
// correctly.
//
// Note that the cancel DDI set assumes that the field DriverContext[3] is
// always available for use and that the driver does not use it.
//

#ifndef _CSQ_H_
#define _CSQ_H_
#pragma once

#ifdef __cplusplus
extern "C" {
#endif

//
// If the wdm.h/ntddk.h we're including already defines cancel safe DDIs, we
// can skip the structure definitions. Otherwise, we do the rest here:
//
#ifndef IO_TYPE_CSQ_IRP_CONTEXT

//
// Bookkeeping structure. This should be opaque to drivers.
// Drivers typically include this as part of their queue headers.
// Given a CSQ pointer the driver should be able to get its
// queue header using CONTAINING_RECORD macro
//

typedef struct _IO_CSQ IO_CSQ, *PIO_CSQ;

#define IO_TYPE_CSQ_IRP_CONTEXT 1
#define IO_TYPE_CSQ             2

//
// IRP context structure. This structure is necessary if the driver is using
// the second mode.
//


typedef struct _IO_CSQ_IRP_CONTEXT {
    ULONG   Type;
    PIRP    Irp;
    PIO_CSQ Csq;
} IO_CSQ_IRP_CONTEXT, *PIO_CSQ_IRP_CONTEXT;

//
// Routines that insert/remove IRP
//

typedef VOID
(*PIO_CSQ_INSERT_IRP)(
    IN struct _IO_CSQ    *Csq,
    IN PIRP              Irp
    );

typedef VOID
(*PIO_CSQ_REMOVE_IRP)(
    IN  PIO_CSQ Csq,
    IN  PIRP    Irp
    );

//
// Retrieves next entry after Irp from the queue.
// Returns NULL if there are no entries in the queue.
// If Irp is NUL, returns the entry in the head of the queue.
// This routine does not remove the IRP from the queue.
//


typedef PIRP
(*PIO_CSQ_PEEK_NEXT_IRP)(
    IN  PIO_CSQ Csq,
    IN  PIRP    Irp,
    IN  PVOID   PeekContext
    );

//
// Lock routine that protects the cancel safe queue.
//

typedef VOID
(*PIO_CSQ_ACQUIRE_LOCK)(
     IN  PIO_CSQ Csq,
     OUT PKIRQL  Irql
     );

typedef VOID
(*PIO_CSQ_RELEASE_LOCK)(
     IN PIO_CSQ Csq,
     IN KIRQL   Irql
     );


//
// Completes the IRP with STATUS_CANCELLED. IRP is guaranteed to be valid
// In most cases this routine just calls IoCompleteRequest(Irp, STATUS_CANCELLED);
//

typedef VOID
(*PIO_CSQ_COMPLETE_CANCELED_IRP)(
    IN  PIO_CSQ    Csq,
    IN  PIRP       Irp
    );

//
// Bookkeeping structure. This should be opaque to drivers.
// Drivers typically include this as part of their queue headers.
// Given a CSQ pointer the driver should be able to get its
// queue header using CONTAINING_RECORD macro
//

typedef struct _IO_CSQ {
    ULONG                            Type;
    PIO_CSQ_INSERT_IRP               CsqInsertIrp;
    PIO_CSQ_REMOVE_IRP               CsqRemoveIrp;
    PIO_CSQ_PEEK_NEXT_IRP            CsqPeekNextIrp;
    PIO_CSQ_ACQUIRE_LOCK             CsqAcquireLock;
    PIO_CSQ_RELEASE_LOCK             CsqReleaseLock;
    PIO_CSQ_COMPLETE_CANCELED_IRP    CsqCompleteCanceledIrp;
    PVOID                            ReservePointer;    // Future expansion
} IO_CSQ, *PIO_CSQ;

#endif // IO_TYPE_CSQ_IRP_CONTEXT

//
// These defines ensure the backward compatible CSQ library can be used within
// the XP build environment in which the kernel supports the functions natively.
//

#define CSQLIB_DDI(x)   Wdmlib##x
#undef IoCsqInitialize
#undef IoCsqInsertIrp
#undef IoCsqRemoveNextIrp
#undef IoCsqRemoveIrp
#define IoCsqInitialize     WdmlibIoCsqInitialize
#define IoCsqInsertIrp      WdmlibIoCsqInsertIrp
#define IoCsqRemoveNextIrp  WdmlibIoCsqRemoveNextIrp
#define IoCsqRemoveIrp      WdmlibIoCsqRemoveIrp


//
// Initializes the cancel queue structure.
//

NTSTATUS
CSQLIB_DDI(IoCsqInitialize)(
    IN PIO_CSQ                          Csq,
    IN PIO_CSQ_INSERT_IRP               CsqInsertIrp,
    IN PIO_CSQ_REMOVE_IRP               CsqRemoveIrp,
    IN PIO_CSQ_PEEK_NEXT_IRP            CsqPeekNextIrp,
    IN PIO_CSQ_ACQUIRE_LOCK             CsqAcquireLock,
    IN PIO_CSQ_RELEASE_LOCK             CsqReleaseLock,
    IN PIO_CSQ_COMPLETE_CANCELED_IRP    CsqCompleteCanceledIrp
    );


//
// The caller calls this routine to insert the IRP and return STATUS_PENDING.
//

VOID
CSQLIB_DDI(IoCsqInsertIrp)(
    IN  PIO_CSQ             Csq,
    IN  PIRP                Irp,
    IN  PIO_CSQ_IRP_CONTEXT Context
    );

//
// Returns an IRP if one can be found. NULL otherwise.
//

PIRP
CSQLIB_DDI(IoCsqRemoveNextIrp)(
    IN  PIO_CSQ   Csq,
    IN  PVOID     PeekContext
    );

//
// This routine is called from timeout or DPCs.
// The context is presumably part of the DPC or timer context.
// If succesfull returns the IRP associated with context.
//

PIRP
CSQLIB_DDI(IoCsqRemoveIrp)(
    IN  PIO_CSQ             Csq,
    IN  PIO_CSQ_IRP_CONTEXT Context
    );

#ifdef __cplusplus
} // extern "C"
#endif

#endif // _CSQ_H_

// Cancel SAFE DDI set end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\ddk\inc\d4iface.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    D4iface.h

Abstract:

    DOT4 Interface


--*/

#ifndef _DOT4_IFACE_H
#define _DOT4_IFACE_H

#ifdef __cplusplus
extern "C" {      
#endif
//////////////////////////////////////////////////////////////////////////////
// Includes
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Defines
//////////////////////////////////////////////////////////////////////////////
#define DOT4_MAX_CHANNELS            128

#define NO_TIMEOUT                  0


//
// DOT4 Channel types
//
#define STREAM_TYPE_CHANNEL         1
#define PACKET_TYPE_CHANNEL         2


//
// DOT4 broadcast Activity messages
//
#define DOT4_STREAM_RECEIVED    0x100
#define DOT4_STREAM_CREDITS     0x101
#define DOT4_MESSAGE_RECEIVED   0x102       // Message is received
#define DOT4_DISCONNECT         0x103       // The link was disconnected
#define DOT4_CHANNEL_CLOSED     0x105       // A channel was closed

//
// DOT4 Channels
//
#define DOT4_CHANNEL                 0
#define HP_MESSAGE_PROCESSOR        1
#define PRINTER_CHANNEL             2
// As of revision 3.7 of the DOT4 specification, socket 3 had no assignment
#define SCANNER_CHANNEL             4
#define MIO_COMMAND_PROCESSOR       5
#define ECHO_CHANNEL                6
#define FAX_SEND_CHANNEL            7
#define FAX_RECV_CHANNEL            8
#define DIAGNOSTIC_CHANNEL          9
#define HP_RESERVED                 10
#define IMAGE_DOWNLOAD              11
#define HOST_DATASTORE_UPLOAD       12
#define HOST_DATASTORE_DOWNLOAD     13
#define CONFIG_UPLOAD               14
#define CONFIG_DOWNLOAD             15


//////////////////////////////////////////////////////////////////////////////
// Types
//////////////////////////////////////////////////////////////////////////////
typedef unsigned long CHANNEL_HANDLE;

typedef CHANNEL_HANDLE *PCHANNEL_HANDLE;


typedef struct _DOT4_ACTIVITY
{
    ULONG ulMessage;

    ULONG ulByteCount;

    CHANNEL_HANDLE hChannel;

} DOT4_ACTIVITY, *PDOT4_ACTIVITY;


//////////////////////////////////////////////////////////////////////////////
// Prototypes
//////////////////////////////////////////////////////////////////////////////

#ifdef __cplusplus
// end of extern "C"
}
#endif

#endif // _DOT4_IFACE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\ddk\inc\d4drvif.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    D4drvif.h

Abstract:

    DOT4 Driver Interface


--*/

#ifndef _DOT4DRVIF_H
#define _DOT4DRVIF_H

//////////////////////////////////////////////////////////////////////////////
// Includes
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// Defines
//////////////////////////////////////////////////////////////////////////////
#define MAX_SERVICE_LENGTH      40


#ifndef CTL_CODE

  //
// Macro definition for defining IOCTL and FSCTL function control codes.  Note
// that function codes 0-2047 are reserved for Microsoft Corporation, and
// 2048-4095 are reserved for customers.
//

#define CTL_CODE( DeviceType, Function, Method, Access ) (                 \
    ((DeviceType) << 16) | ((Access) << 14) | ((Function) << 2) | (Method) \
)

//
// Define the method codes for how buffers are passed for I/O and FS controls
//

#define METHOD_BUFFERED                 0
#define METHOD_IN_DIRECT                1
#define METHOD_OUT_DIRECT               2
#define METHOD_NEITHER                  3

//
// Define the access check value for any access
//
//
// The FILE_READ_ACCESS and FILE_WRITE_ACCESS constants are also defined in
// ntioapi.h as FILE_READ_DATA and FILE_WRITE_DATA. The values for these
// constants *MUST* always be in sync.
//


#define FILE_ANY_ACCESS                 0
#define FILE_READ_ACCESS          ( 0x0001 )    // file & pipe
#define FILE_WRITE_ACCESS         ( 0x0002 )    // file & pipe

#endif

#define FILE_DEVICE_DOT4         0x3a
#define IOCTL_DOT4_USER_BASE     2049
#define IOCTL_DOT4_LAST          IOCTL_DOT4_USER_BASE + 9

#define IOCTL_DOT4_CREATE_SOCKET                 CTL_CODE(FILE_DEVICE_DOT4, IOCTL_DOT4_USER_BASE +  7, METHOD_OUT_DIRECT, FILE_ANY_ACCESS)
#define IOCTL_DOT4_DESTROY_SOCKET                CTL_CODE(FILE_DEVICE_DOT4, IOCTL_DOT4_USER_BASE +  9, METHOD_OUT_DIRECT, FILE_ANY_ACCESS)
#define IOCTL_DOT4_WAIT_FOR_CHANNEL              CTL_CODE(FILE_DEVICE_DOT4, IOCTL_DOT4_USER_BASE +  8, METHOD_OUT_DIRECT, FILE_ANY_ACCESS)
#define IOCTL_DOT4_OPEN_CHANNEL                  CTL_CODE(FILE_DEVICE_DOT4, IOCTL_DOT4_USER_BASE +  0, METHOD_OUT_DIRECT, FILE_ANY_ACCESS)
#define IOCTL_DOT4_CLOSE_CHANNEL                 CTL_CODE(FILE_DEVICE_DOT4, IOCTL_DOT4_USER_BASE +  1, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_DOT4_READ                          CTL_CODE(FILE_DEVICE_DOT4, IOCTL_DOT4_USER_BASE +  2, METHOD_OUT_DIRECT, FILE_ANY_ACCESS)
#define IOCTL_DOT4_WRITE                         CTL_CODE(FILE_DEVICE_DOT4, IOCTL_DOT4_USER_BASE +  3, METHOD_IN_DIRECT, FILE_ANY_ACCESS)
#define IOCTL_DOT4_ADD_ACTIVITY_BROADCAST        CTL_CODE(FILE_DEVICE_DOT4, IOCTL_DOT4_USER_BASE +  4, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_DOT4_REMOVE_ACTIVITY_BROADCAST     CTL_CODE(FILE_DEVICE_DOT4, IOCTL_DOT4_USER_BASE +  5, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_DOT4_WAIT_ACTIVITY_BROADCAST       CTL_CODE(FILE_DEVICE_DOT4, IOCTL_DOT4_USER_BASE +  6, METHOD_OUT_DIRECT, FILE_ANY_ACCESS)


//////////////////////////////////////////////////////////////////////////////
// Types
//////////////////////////////////////////////////////////////////////////////

typedef struct _DOT4_DRIVER_CMD
{
    // Handle to channel
    CHANNEL_HANDLE hChannelHandle;

    // Length of request
    ULONG ulSize;

    // Offset into buffer
    ULONG ulOffset;

    // Timeout of operation. Can be INFINITE.
    ULONG ulTimeout;

} DOT4_DRIVER_CMD, *PDOT4_DRIVER_CMD;


typedef struct _DOT4_DC_OPEN_DATA
{
    // Host socket created by CREATE_SOCKET
    unsigned char bHsid;

    // TRUE to immediately add activity broadcast upon creation
    unsigned char fAddActivity;

    // Handle to channel returned
    CHANNEL_HANDLE hChannelHandle;

} DOT4_DC_OPEN_DATA, *PDOT4_DC_OPEN_DATA;


typedef struct _DOT4_DC_CREATE_DATA
{
    // This or service name sent
    unsigned char bPsid;

    CHAR pServiceName[MAX_SERVICE_LENGTH + 1];

    // Type (stream or packet) of channels on socket
    unsigned char bType;

    // Size of read buffer for channels on socket
    ULONG ulBufferSize;

    USHORT usMaxHtoPPacketSize;

    USHORT usMaxPtoHPacketSize;

    // Host socket id returned
    unsigned char bHsid;

} DOT4_DC_CREATE_DATA, *PDOT4_DC_CREATE_DATA;


typedef struct _DOT4_DC_DESTROY_DATA
{
    // Host socket created by CREATE_SOCKET
    unsigned char bHsid;

} DOT4_DC_DESTROY_DATA, *PDOT4_DC_DESTROY_DATA;


//////////////////////////////////////////////////////////////////////////////
// Prototypes
//////////////////////////////////////////////////////////////////////////////


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\ddk\inc\dciman.h ===
/****************************************************************************

 DCIMAN.H

 Copyright (C) 1993-1999 Microsoft Corporation.  All Rights Reserved.

 DCIMAN 1.0 client interface definitions

 ***************************************************************************/

#ifndef _INC_DCIMAN
#define _INC_DCIMAN

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
    #define __inline inline
    extern "C" {
#endif

/****************************************************************************
 ***************************************************************************/

#include "dciddi.h"         // interface to the DCI provider

/****************************************************************************
 ***************************************************************************/

DECLARE_HANDLE(HWINWATCH);  // context handle for WinWatch instance

/****************************************************************************
 ***************************************************************************/

extern HDC WINAPI DCIOpenProvider(void);
extern void WINAPI DCICloseProvider(HDC hdc);

extern int WINAPI DCICreatePrimary(HDC hdc, LPDCISURFACEINFO FAR *lplpSurface);
extern int WINAPI DCICreateOffscreen(HDC hdc, DWORD dwCompression, DWORD dwRedMask,
    DWORD dwGreenMask, DWORD dwBlueMask, DWORD dwWidth, DWORD dwHeight,
    DWORD dwDCICaps, DWORD dwBitCount, LPDCIOFFSCREEN FAR *lplpSurface);
extern int WINAPI DCICreateOverlay(HDC hdc, LPVOID lpOffscreenSurf,
    LPDCIOVERLAY FAR *lplpSurface);
extern int WINAPI DCIEnum(HDC hdc, LPRECT lprDst, LPRECT lprSrc, LPVOID lpFnCallback,
    LPVOID lpContext);
extern DCIRVAL WINAPI DCISetSrcDestClip(LPDCIOFFSCREEN pdci, LPRECT srcrc,
			LPRECT destrc, LPRGNDATA prd );

extern HWINWATCH WINAPI WinWatchOpen(HWND hwnd);
extern void      WINAPI WinWatchClose(HWINWATCH hWW);

// API changed to copy region data instead of return pointer to it
extern UINT	 WINAPI WinWatchGetClipList(HWINWATCH hWW, LPRECT prc,
				UINT size,  LPRGNDATA prd);
extern BOOL      WINAPI WinWatchDidStatusChange(HWINWATCH hWW);

extern DWORD     WINAPI GetWindowRegionData(HWND hwnd, DWORD size, LPRGNDATA prd);
extern DWORD     WINAPI GetDCRegionData(HDC hdc, DWORD size, LPRGNDATA prd);


#define WINWATCHNOTIFY_START        0
#define WINWATCHNOTIFY_STOP         1
#define WINWATCHNOTIFY_DESTROY      2
#define WINWATCHNOTIFY_CHANGING     3
#define WINWATCHNOTIFY_CHANGED      4
typedef void (CALLBACK *WINWATCHNOTIFYPROC)(HWINWATCH hww, HWND hwnd, DWORD code, LPARAM lParam);

extern BOOL WINAPI WinWatchNotify(HWINWATCH hWW, WINWATCHNOTIFYPROC NotifyCallback,
						LPARAM NotifyParam );

#ifdef WIN32
/****************************************************************************
 helper functions to call DCIMAN16.DLL
 ***************************************************************************/
extern void WINAPI DCIEndAccess(LPDCISURFACEINFO pdci);
extern DCIRVAL WINAPI DCIBeginAccess(LPDCISURFACEINFO pdci, int x, int y, int dx, int dy);
extern void WINAPI DCIDestroy(LPDCISURFACEINFO pdci);
extern DCIRVAL WINAPI DCIDraw(LPDCIOFFSCREEN pdci);
extern DCIRVAL WINAPI DCISetClipList(LPDCIOFFSCREEN pdci, LPRGNDATA prd);
extern DCIRVAL WINAPI DCISetDestination(LPDCIOFFSCREEN pdci, LPRECT dst, LPRECT src);


#else

extern int WINAPI DCISendCommand(HDC hdc, VOID FAR *pcmd, int nSize, VOID FAR * FAR * lplpOut);

/****************************************************************************
 helper macros to call DCI callbacks
 ***************************************************************************/
__inline void DCIDestroy(LPDCISURFACEINFO pdci)
{
	if( pdci->DestroySurface != NULL ) {
		pdci->DestroySurface(pdci);
	}
}

__inline void DCIEndAccess(LPDCISURFACEINFO pdci)
{
	if( pdci->EndAccess != NULL ) {
		pdci->EndAccess(pdci);
	}
}

__inline DCIRVAL DCIBeginAccess(LPDCISURFACEINFO pdci, int x, int y, int dx, int dy)
{
    RECT rc;

	if( pdci->BeginAccess != NULL ) {
		rc.left=x;
		rc.top=y;
		rc.right = rc.left+dx;
		rc.bottom = rc.top+dy;
		return pdci->BeginAccess(pdci, &rc);
	} else {
		return DCI_OK;
	}
}

__inline DCIRVAL DCIDraw(LPDCIOFFSCREEN pdci)
{
	if( pdci->Draw != NULL ) {
		return pdci->Draw(pdci);
	} else {
		return DCI_OK;
	}
}

__inline DCIRVAL DCISetClipList(LPDCIOFFSCREEN pdci, LPRGNDATA prd)
{
	if( pdci->SetClipList != NULL ) {
		return pdci->SetClipList(pdci, prd);
	} else {
		return DCI_OK;
	}
}

__inline DCIRVAL DCISetDestination(LPDCIOFFSCREEN pdci, LPRECT dst, LPRECT src)
{
	if( pdci->SetDestination != NULL ) {
		return pdci->SetDestination(pdci, dst, src);
	} else {
		return DCI_OK;
	}
}
#endif

/****************************************************************************
 ***************************************************************************/

#ifdef __cplusplus
    }
#endif

#endif // _INC_DCIMAN
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\ddk\inc\dciddi.h ===
/*******************************************************************
 *
 *      FILE:           dciddi.h
 *
 *      DESCRIPTION:    definitions for MS/Intel-defined DCI interface
 *
 *      Copyright (C) 1994-1999 Intel/Microsoft Corporation.  All Rights Reserved.
 *
 *******************************************************************/

#ifndef _INC_DCIDDI
#define _INC_DCIDDI

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

/* DCI Command Escapes */
#define DCICOMMAND                      3075
#define DCI_VERSION                     0x0100

#define DCICREATEPRIMARYSURFACE         1
#define DCICREATEOFFSCREENSURFACE       2
#define DCICREATEOVERLAYSURFACE         3
#define DCIENUMSURFACE                  4
#define DCIESCAPE                       5

/* DCI-Defined error codes */
#define DCI_OK                                  0 /* success */

/* Hard errors -- DCI will be unavailable */
#define DCI_FAIL_GENERIC                     -1
#define DCI_FAIL_UNSUPPORTEDVERSION          -2
#define DCI_FAIL_INVALIDSURFACE              -3
#define DCI_FAIL_UNSUPPORTED                 -4

/* Soft errors -- DCI may be available later */
#define DCI_ERR_CURRENTLYNOTAVAIL           -5
#define DCI_ERR_INVALIDRECT                 -6
#define DCI_ERR_UNSUPPORTEDFORMAT           -7
#define DCI_ERR_UNSUPPORTEDMASK             -8
#define DCI_ERR_TOOBIGHEIGHT                -9
#define DCI_ERR_TOOBIGWIDTH                 -10
#define DCI_ERR_TOOBIGSIZE                  -11
#define DCI_ERR_OUTOFMEMORY                 -12
#define DCI_ERR_INVALIDPOSITION             -13
#define DCI_ERR_INVALIDSTRETCH              -14
#define DCI_ERR_INVALIDCLIPLIST             -15
#define DCI_ERR_SURFACEISOBSCURED           -16
#define DCI_ERR_XALIGN                      -17
#define DCI_ERR_YALIGN                      -18
#define DCI_ERR_XYALIGN                     -19
#define DCI_ERR_WIDTHALIGN                  -20
#define DCI_ERR_HEIGHTALIGN                 -21

/* success messages -- DCI call succeeded, but specified item changed */
#define DCI_STATUS_POINTERCHANGED           1
#define DCI_STATUS_STRIDECHANGED            2
#define DCI_STATUS_FORMATCHANGED            4
#define DCI_STATUS_SURFACEINFOCHANGED       8
#define DCI_STATUS_CHROMAKEYCHANGED        16
#define DCI_STATUS_WASSTILLDRAWING         32

#define DCI_SUCCESS(error)  (((DCIRVAL)error) >= 0)

/* DCI Capability Flags */
#define DCI_SURFACE_TYPE                        0x0000000F
#define DCI_PRIMARY                             0x00000000
#define DCI_OFFSCREEN                           0x00000001
#define DCI_OVERLAY                             0x00000002

#define DCI_VISIBLE                             0x00000010
#define DCI_CHROMAKEY                           0x00000020
#define DCI_1632_ACCESS                         0x00000040
#define DCI_DWORDSIZE                           0x00000080
#define DCI_DWORDALIGN                          0x00000100
#define DCI_WRITEONLY                           0x00000200
#define DCI_ASYNC                               0x00000400

#define DCI_CAN_STRETCHX                        0x00001000
#define DCI_CAN_STRETCHY                        0x00002000
#define DCI_CAN_STRETCHXY                       (DCI_CAN_STRETCHX | DCI_CAN_STRETCHY)

#define DCI_CAN_STRETCHXN                       0x00004000
#define DCI_CAN_STRETCHYN                       0x00008000
#define DCI_CAN_STRETCHXYN                      (DCI_CAN_STRETCHXN | DCI_CAN_STRETCHYN)


#define DCI_CANOVERLAY                          0x00010000

/*
 * Win32 RGNDATA structure.  This will be used for  cliplist info. passing.
 */
#if (WINVER < 0x0400)

#ifndef RDH_RECTANGLES

typedef struct tagRECTL
{
   LONG     left;
   LONG     top;
   LONG     right;
   LONG     bottom;
} RECTL;
typedef RECTL*       PRECTL;
typedef RECTL NEAR*  NPRECTL;
typedef RECTL FAR*   LPRECTL;
typedef const RECTL FAR* LPCRECTL;

#define RDH_RECTANGLES  0

typedef struct tagRGNDATAHEADER {
   DWORD   dwSize;                              /* size of structure             */
   DWORD   iType;                               /* Will be RDH_RECTANGLES        */
   DWORD   nCount;                              /* # of clipping rectangles      */
   DWORD   nRgnSize;                            /* size of buffer -- can be zero */
   RECTL   rcBound;                             /* bounding  rectangle for region*/
} RGNDATAHEADER;
typedef RGNDATAHEADER*       PRGNDATAHEADER;
typedef RGNDATAHEADER NEAR*  NPRGNDATAHEADER;
typedef RGNDATAHEADER FAR*   LPRGNDATAHEADER;
typedef const RGNDATAHEADER FAR* LPCRGNDATAHEADER;

typedef struct tagRGNDATA {
   RGNDATAHEADER   rdh;
   char            Buffer[1];
} RGNDATA;
typedef RGNDATA*       PRGNDATA;
typedef RGNDATA NEAR*  NPRGNDATA;
typedef RGNDATA FAR*   LPRGNDATA;
typedef const RGNDATA FAR* LPCRGNDATA;

#endif
#endif

typedef int     DCIRVAL;                /* return for callbacks */

/**************************************************************************
 *      input structures
 **************************************************************************/

/*
 * Used by a DCI client to provide input parameters for the
 * DCICREATEPRIMARYSURFACE escape.
 */
typedef struct _DCICMD {
        DWORD   dwCommand;
        DWORD   dwParam1;
        DWORD   dwParam2;
        DWORD   dwVersion;
        DWORD   dwReserved;
} DCICMD;

/*
 * This structure is used by a DCI client to provide input parameters for
 * the DCICREATE... calls.  The fields that are actually relevant differ for
 * each of the three calls.  Details are in the DCI Spec chapter providing
 * the function specifications.
 */
typedef struct _DCICREATEINPUT {
        DCICMD  cmd;                                                    /* common header structure */
        DWORD   dwCompression;                          /* format of surface to be created                      */
        DWORD   dwMask[3];                      /* for  nonstandard RGB (e.g. 5-6-5, RGB32) */
        DWORD   dwWidth;                        /* height of the surface to be created          */
        DWORD   dwHeight;                       /* width of input surfaces                                      */
        DWORD   dwDCICaps;                                              /* capabilities of surface wanted */
        DWORD   dwBitCount;                                     /* bit depth of format to be created */
        LPVOID  lpSurface;                      /* pointer to an associated surface             */
} DCICREATEINPUT, FAR *LPDCICREATEINPUT;


/**************************************************************************
 *      surface info. structures
 **************************************************************************/

/*
 * This structure is used to return information about available support
 * during a DCIEnumSurface call.  It is also used to create a primary
 * surface, and as a member of the larger structures returned by the
 * offscreen and overlay calls.
 */
 typedef struct _DCISURFACEINFO {
        DWORD   dwSize;                         /* size of structure                                            */
        DWORD   dwDCICaps;                  /* capability flags (stretch, etc.)             */
        DWORD   dwCompression;                  /* format of surface to be created                      */
        DWORD   dwMask[3];                  /* for BI_BITMASK surfaces                                      */

        DWORD   dwWidth;                    /* width of surface                                             */
        DWORD   dwHeight;                   /* height of surface                                            */
        LONG    lStride;                    /* distance in bytes betw. one pixel            */
                                                                                /* and the pixel directly below it                      */
        DWORD   dwBitCount;                 /* Bits per pixel for this dwCompression    */
        ULONG_PTR dwOffSurface;             /* offset of surface pointer                            */
        WORD    wSelSurface;                /* selector of surface pointer                          */
        WORD    wReserved;

        DWORD   dwReserved1;                /* reserved for provider */
        DWORD   dwReserved2;                /* reserved for DCIMAN */
        DWORD   dwReserved3;                /* reserved for future */
        DCIRVAL (CALLBACK *BeginAccess) (LPVOID, LPRECT);    /* BeginAccess callback         */
        void (CALLBACK *EndAccess) (LPVOID);                   /* EndAcess callback            */
        void (CALLBACK *DestroySurface) (LPVOID);               /* Destroy surface callback     */
} DCISURFACEINFO, FAR *LPDCISURFACEINFO;


/*
 * This structure is used by a DCI client to provide input parameters for the
 * DCIEnumSurface call.
 */

typedef
void
(*ENUM_CALLBACK) (
    LPDCISURFACEINFO lpSurfaceInfo,
    LPVOID lpContext
    );

typedef struct _DCIENUMINPUT {
        DCICMD  cmd;                                                    /* common header structure */
        RECT    rSrc;                           /* source rect. for stretch  */
        RECT    rDst;                           /* dest. rect. for stretch       */
        void    (CALLBACK *EnumCallback)(LPDCISURFACEINFO, LPVOID);        /* callback for supported formats */
        LPVOID  lpContext;
} DCIENUMINPUT, FAR *LPDCIENUMINPUT;


/*
 * This structure must be allocated and returned by the DCI provider in
 * response to a DCICREATEPRIMARYSURFACE call.
 */
 typedef DCISURFACEINFO DCIPRIMARY, FAR *LPDCIPRIMARY;

/*
 * This structure must be allocated and returned by the DCI provider in
 * response to a DCICREATEOFFSCREENSURFACE call.
 */
 typedef struct _DCIOFFSCREEN {

        DCISURFACEINFO  dciInfo;                                                           /* surface info                  */
        DCIRVAL (CALLBACK *Draw) (LPVOID);                                            /* copy to onscreen buffer   */
        DCIRVAL (CALLBACK *SetClipList) (LPVOID, LPRGNDATA);          /* SetCliplist callback              */
        DCIRVAL (CALLBACK *SetDestination) (LPVOID, LPRECT, LPRECT);  /* SetDestination callback       */
} DCIOFFSCREEN, FAR *LPDCIOFFSCREEN;


/*
 * This structure must be allocated and returned by the DCI provider in response
 * to a DCICREATEOVERLAYSURFACE call.
 */
 typedef struct _DCIOVERLAY{

        DCISURFACEINFO  dciInfo;                                                /* surface info                  */
        DWORD   dwChromakeyValue;                                               /* chromakey color value                 */
        DWORD   dwChromakeyMask;                                                /* specifies valid bits of value */
} DCIOVERLAY, FAR *LPDCIOVERLAY;


/* DCI FOURCC def.s for extended DIB formats */

#ifndef YVU9
#define YVU9                        mmioFOURCC('Y','V','U','9')
#endif
#ifndef Y411
#define Y411                        mmioFOURCC('Y','4','1','1')
#endif
#ifndef YUY2
#define YUY2                        mmioFOURCC('Y','U','Y','2')
#endif
#ifndef YVYU
#define YVYU                        mmioFOURCC('Y','V','Y','U')
#endif
#ifndef UYVY
#define UYVY                        mmioFOURCC('U','Y','V','Y')
#endif
#ifndef Y211
#define Y211                        mmioFOURCC('Y','2','1','1')
#endif

#ifdef __cplusplus
}
#endif

#endif // _INC_DCIDDI
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\ddk\inc\dderror.h ===
/*++ BUILD Version: ????     Increment this if a change has global effects

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    dderror.h

Abstract:

    This module defines the 32-Bit Windows error codes that are useable by
    portable kernel drivers.

Revision History:

--*/

#ifndef _DDERROR_
#define _DDERROR_

/*
 * This file is a subset of Win32 error codes. Other win32 error codes
 * are not supported by portable drivers and should not beused.
 * This #define removes the definitions of all other error codes.
 */

#define _WINERROR_

#define NO_ERROR 0L                                                 
#define ERROR_INVALID_FUNCTION           1L    
#define ERROR_NOT_ENOUGH_MEMORY          8L    
#define ERROR_DEV_NOT_EXIST              55L    
#define ERROR_INVALID_PARAMETER          87L    
#define ERROR_INSUFFICIENT_BUFFER        122L    
#define ERROR_INVALID_NAME               123L    
#define ERROR_BUSY                       170L    
#define ERROR_MORE_DATA                  234L    
#define WAIT_TIMEOUT                     258L    
#define ERROR_IO_PENDING                 997L    
#define ERROR_DEVICE_REINITIALIZATION_NEEDED 1164L    
#define ERROR_CONTINUE                   1246L    
#define ERROR_NO_MORE_DEVICES            1248L    

#endif /* _DDERROR_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\ddk\inc\diskguid.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    diskguid.h

Abstract:

    GPT disk GUIDs.

Revision History:

--*/

//
// GPT Partition Type GUIDs
//
// need these GUIDs outside conditional includes so that user can
//   #include <ntdddisk.h> in precompiled header
//   #include <initguid.h> in a single source file
//   #include <ntdddisk.h> in that source file a second time to instantiate the GUIDs
//

#ifdef DEFINE_GUID

//
// Make sure FAR is defined...
//
#ifndef FAR
#ifdef _WIN32
#define FAR
#else
#define FAR _far
#endif
#endif


//
// Define the GPT partition guids known by disk drivers and volume managers.
//

DEFINE_GUID(PARTITION_ENTRY_UNUSED_GUID,   0x00000000L, 0x0000, 0x0000, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00);    // Entry unused
DEFINE_GUID(PARTITION_SYSTEM_GUID,         0xC12A7328L, 0xF81F, 0x11D2, 0xBA, 0x4B, 0x00, 0xA0, 0xC9, 0x3E, 0xC9, 0x3B);    // EFI system partition
DEFINE_GUID(PARTITION_MSFT_RESERVED_GUID,  0xE3C9E316L, 0x0B5C, 0x4DB8, 0x81, 0x7D, 0xF9, 0x2D, 0xF0, 0x02, 0x15, 0xAE);    // Microsoft reserved space                                        
DEFINE_GUID(PARTITION_BASIC_DATA_GUID,     0xEBD0A0A2L, 0xB9E5, 0x4433, 0x87, 0xC0, 0x68, 0xB6, 0xB7, 0x26, 0x99, 0xC7);    // Basic data partition
DEFINE_GUID(PARTITION_LDM_METADATA_GUID,   0x5808C8AAL, 0x7E8F, 0x42E0, 0x85, 0xD2, 0xE1, 0xE9, 0x04, 0x34, 0xCF, 0xB3);    // Logical Disk Manager metadata partition
DEFINE_GUID(PARTITION_LDM_DATA_GUID,       0xAF9B60A0L, 0x1431, 0x4F62, 0xBC, 0x68, 0x33, 0x11, 0x71, 0x4A, 0x69, 0xAD);    // Logical Disk Manager data partition
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\ddk\inc\dmusicks.h ===
/***************************************************************************
*                                                                          *
*   DMusicKS.h -- This module defines the the DirectMusic WDM interface.   *
*                                                                          *
*   Copyright (c) Microsoft Corp. All rights reserved.                     *
*                                                                          *
***************************************************************************/

#ifndef _DMUSICKS_
#define _DMUSICKS_

#include <dmusprop.h>

#define DONT_HOLD_FOR_SEQUENCING 0x8000000000000000

typedef struct _DMUS_KERNEL_EVENT
{                                           //  this    offset
    BYTE            bReserved;              //  1       0
    BYTE            cbStruct;               //  1       1
    USHORT          cbEvent;                //  2       2
    USHORT          usChannelGroup;         //  2       4
    USHORT          usFlags;                //  2       6
    REFERENCE_TIME  ullPresTime100ns;       //  8       8
    ULONGLONG       ullBytePosition;        //  8      16
    _DMUS_KERNEL_EVENT *pNextEvt;           //  4 (8)  24
    union
    {
        BYTE        abData[sizeof(PBYTE)];  //  4 (8)  28 (32)
        PBYTE       pbData;
        _DMUS_KERNEL_EVENT *pPackageEvt;
    } uData;
} DMUS_KERNEL_EVENT, *PDMUS_KERNEL_EVENT;   //         32 (40)

#define DMUS_KEF_EVENT_COMPLETE     0x0000
#define DMUS_KEF_EVENT_INCOMPLETE   0x0001  //  This event is an incomplete package or sysex.
                                            //  Do not use this data.

#define DMUS_KEF_PACKAGE_EVENT      0x0002  //  This event is a package. The uData.pPackageEvt
                                            //  field contains a pointer to a chain of events.

#define kBytePositionNone   (~(ULONGLONG)0) //  This message has no meaningful byte position

#define SHORT_EVT(evt)       ((evt)->cbEvent <= sizeof(PBYTE))
#define PACKAGE_EVT(evt)     ((evt)->usFlags & DMUS_KEF_PACKAGE_EVENT)
#define INCOMPLETE_EVT(evt)  ((evt)->usFlags & DMUS_KEF_EVENT_INCOMPLETE)
#define COMPLETE_EVT(evt)    (((evt)->usFlags & DMUS_KEF_EVENT_INCOMPLETE) == 0)

#define SET_INCOMPLETE_EVT(evt) ((evt)->usFlags |= DMUS_KEF_EVENT_INCOMPLETE)
#define SET_COMPLETE_EVT(evt)   ((evt)->usFlags &= (~DMUS_KEF_EVENT_INCOMPLETE))
#define SET_PACKAGE_EVT(evt)    ((evt)->usFlags |= DMUS_KEF_PACKAGE_EVENT)
#define CLEAR_PACKAGE_EVT(evt)  ((evt)->usFlags &= (~DMUS_KEF_PACKAGE_EVENT))


#define STATIC_CLSID_PortDMus\
    0xb7902fe9, 0xfb0a, 0x11d1, 0x81, 0xb0, 0x00, 0x60, 0x08, 0x33, 0x16, 0xc1
DEFINE_GUIDSTRUCT("b7902fe9-fb0a-11d1-81b0-0060083316c1", CLSID_PortDMus);
#define CLSID_PortDMus DEFINE_GUIDNAMED(CLSID_PortDMus)

#define STATIC_CLSID_MiniportDriverDMusUART\
    0xd3f0ce1c, 0xfffc, 0x11d1, 0x81, 0xb0, 0x00, 0x60, 0x08, 0x33, 0x16, 0xc1
DEFINE_GUIDSTRUCT("d3f0ce1c-fffc-11d1-81b0-0060083316c1", CLSID_MiniportDriverDMusUART);
#define CLSID_MiniportDriverDMusUART DEFINE_GUIDNAMED(CLSID_MiniportDriverDMusUART)

#define STATIC_CLSID_MiniportDriverDMusUARTCapture\
    0xd3f0ce1d, 0xfffc, 0x11d1, 0x81, 0xb0, 0x00, 0x60, 0x08, 0x33, 0x16, 0xc1
DEFINE_GUIDSTRUCT("d3f0ce1d-fffc-11d1-81b0-0060083316c1", CLSID_MiniportDriverDMusUARTCapture);
#define CLSID_MiniportDriverDMusUARTCapture DEFINE_GUIDNAMED(CLSID_MiniportDriverDMusUARTCapture)

#define STATIC_IID_IPortDMus\
    0xc096df9c, 0xfb09, 0x11d1, 0x81, 0xb0, 0x00, 0x60, 0x08, 0x33, 0x16, 0xc1
DEFINE_GUIDSTRUCT("c096df9c-fb09-11d1-81b0-0060083316c1", IID_IPortDMus);
#define IID_IPortDMus DEFINE_GUIDNAMED(IID_IPortDMus)

#define STATIC_IID_IMiniportDMus\
    0xc096df9d, 0xfb09, 0x11d1, 0x81, 0xb0, 0x00, 0x60, 0x08, 0x33, 0x16, 0xc1
DEFINE_GUIDSTRUCT("c096df9d-fb09-11d1-81b0-0060083316c1", IID_IMiniportDMus);
#define IID_IMiniportDMus DEFINE_GUIDNAMED(IID_IMiniportDMus)

#define STATIC_IID_IMXF\
    0xc096df9e, 0xfb09, 0x11d1, 0x81, 0xb0, 0x00, 0x60, 0x08, 0x33, 0x16, 0xc1
DEFINE_GUIDSTRUCT("c096df9e-fb09-11d1-81b0-0060083316c1", IID_IMXF);
#define IID_IMXF DEFINE_GUIDNAMED(IID_IMXF)

#define STATIC_IID_IAllocatorMXF\
    0xa5f0d62c, 0xb30f, 0x11d2, 0xb7, 0xa3, 0x00, 0x60, 0x08, 0x33, 0x16, 0xc1
DEFINE_GUIDSTRUCT("a5f0d62c-b30f-11d2-b7a3-0060083316c1", IID_IAllocatorMXF);
#define IID_IAllocatorMXF DEFINE_GUIDNAMED(IID_IAllocatorMXF)

#define STATIC_IID_ISynthSinkDMus\
    0x1f476974, 0x679b, 0x11d2, 0x8f, 0x7d, 0x00, 0xc0, 0x4f, 0xbf, 0x8f, 0xef
DEFINE_GUIDSTRUCT("1f476974-679b-11d2-8f7d-00c04fbf8fef", IID_ISynthSinkDMus);
#define IID_ISynthSinkDMus DEFINE_GUIDNAMED(IID_ISynthSinkDMus)

#define STATIC_KSAUDFNAME_DMUSIC_MPU_OUT\
    0xA4DF0EB5, 0xBAC9, 0x11d2, 0xB7, 0xA8, 0x00, 0x60, 0x08, 0x33, 0x16, 0xC1
DEFINE_GUIDSTRUCT("A4DF0EB5-BAC9-11d2-B7A8-0060083316C1", KSAUDFNAME_DMUSIC_MPU_OUT);
#define KSAUDFNAME_DMUSIC_MPU_OUT DEFINE_GUIDNAMED(KSAUDFNAME_DMUSIC_MPU_OUT)

#define STATIC_KSAUDFNAME_DMUSIC_MPU_IN\
    0xB2EC0A7D, 0xBAC9, 0x11d2, 0xB7, 0xA8, 0x00, 0x60, 0x08, 0x33, 0x16, 0xC1
DEFINE_GUIDSTRUCT("B2EC0A7D-BAC9-11d2-B7A8-0060083316C1", KSAUDFNAME_DMUSIC_MPU_IN);
#define KSAUDFNAME_DMUSIC_MPU_IN DEFINE_GUIDNAMED(KSAUDFNAME_DMUSIC_MPU_IN)


/*****************************************************************************
 * IPortDMus
 *****************************************************************************
 * Interface for DMusic port lower edge.
 */
DECLARE_INTERFACE_(IPortDMus,IPort)
{
    DEFINE_ABSTRACT_UNKNOWN()   //  For IUnknown

    DEFINE_ABSTRACT_PORT()      //  For IPort

    //  For IPortDMus
    STDMETHOD_(void,Notify)
    (   THIS_
        IN      PSERVICEGROUP   ServiceGroup    OPTIONAL
    )   PURE;

    STDMETHOD_(void,RegisterServiceGroup)
    (   THIS_
        IN      PSERVICEGROUP   ServiceGroup
    )   PURE;
};

typedef IPortDMus *PPORTDMUS;

#ifdef PC_IMPLEMENTATION
#define IMP_IPortDMus\
    IMP_IPort;\
    STDMETHODIMP_(void) Notify\
    (   IN      PSERVICEGROUP   ServiceGroup    OPTIONAL\
    );\
    STDMETHODIMP_(void) RegisterServiceGroup\
    (   IN      PSERVICEGROUP   ServiceGroup\
    )
#endif  /* PC_IMPLEMENTATION */


/*****************************************************************************
 * IMXF
 *****************************************************************************
 * Interface for DMusic miniport streams.
 */
struct  IMXF;
typedef IMXF *PMXF;

#if !defined(DEFINE_ABSTRACT_MXF)

#define DEFINE_ABSTRACT_MXF()                                   \
    STDMETHOD_(NTSTATUS,SetState)                               \
    (   THIS_                                                   \
        IN      KSSTATE State                                   \
    )   PURE;                                                   \
    STDMETHOD_(NTSTATUS,PutMessage)                             \
    (   THIS_                                                   \
        IN      PDMUS_KERNEL_EVENT  pDMKEvt                     \
    )   PURE;                                                   \
    STDMETHOD_(NTSTATUS,ConnectOutput)                          \
    (   THIS_                                                   \
        IN      PMXF    sinkMXF                                 \
    )   PURE;                                                   \
    STDMETHOD_(NTSTATUS,DisconnectOutput)                       \
    (   THIS_                                                   \
        IN      PMXF    sinkMXF                                 \
    )   PURE;

#endif //!defined(DEFINE_ABSTRACT_MXF)

DECLARE_INTERFACE_(IMXF,IUnknown)
{
    DEFINE_ABSTRACT_UNKNOWN()   //  For IUnknown

    DEFINE_ABSTRACT_MXF()       //  For IMXF
};

#define IMP_IMXF\
    STDMETHODIMP_(NTSTATUS) SetState\
    (   IN      KSSTATE State\
    );\
    STDMETHODIMP_(NTSTATUS) PutMessage\
    (   IN      PDMUS_KERNEL_EVENT  pDMKEvt\
    );\
    STDMETHODIMP_(NTSTATUS) ConnectOutput\
    (   IN      PMXF    sinkMXF\
    );\
    STDMETHODIMP_(NTSTATUS) DisconnectOutput\
    (   IN      PMXF    sinkMXF\
    );\

/*****************************************************************************
 * IAllocatorMXF
 *****************************************************************************
 * Interface for DMusic miniport streams.
 */
struct  IAllocatorMXF;
typedef IAllocatorMXF *PAllocatorMXF;

DECLARE_INTERFACE_(IAllocatorMXF,IMXF)
{
    DEFINE_ABSTRACT_UNKNOWN()   //  For IUnknown

    DEFINE_ABSTRACT_MXF()       //  For IMXF

    //  For IAllocatorMXF
    STDMETHOD_(NTSTATUS,GetMessage)
    (   THIS_
        OUT     PDMUS_KERNEL_EVENT * ppDMKEvt
    )   PURE;

    STDMETHOD_(USHORT,GetBufferSize)
    (   THIS
    )   PURE;

    STDMETHOD_(NTSTATUS,GetBuffer)
    (   THIS_
        OUT     PBYTE * ppBuffer
    )   PURE;

    STDMETHOD_(NTSTATUS,PutBuffer)
    (   THIS_
        IN      PBYTE   pBuffer
    )   PURE;
};

#define IMP_IAllocatorMXF\
    IMP_IMXF;\
    STDMETHODIMP_(NTSTATUS) GetMessage\
    (   OUT     PDMUS_KERNEL_EVENT * ppDMKEvt\
    );\
    STDMETHODIMP_(USHORT) GetBufferSize\
    (   void\
    );\
    STDMETHODIMP_(NTSTATUS) GetBuffer\
    (   OUT     PBYTE * ppBuffer\
    );\
    STDMETHODIMP_(NTSTATUS) PutBuffer\
    (   IN      PBYTE   pBuffer\
    );\


typedef enum
{
    DMUS_STREAM_MIDI_INVALID = -1,
    DMUS_STREAM_MIDI_RENDER = 0,
    DMUS_STREAM_MIDI_CAPTURE,
    DMUS_STREAM_WAVE_SINK
} DMUS_STREAM_TYPE;

/*****************************************************************************
 * ISynthSinkDMus
 *****************************************************************************
 * Interface for synth wave out.
 */
DECLARE_INTERFACE_(ISynthSinkDMus,IMXF)
{
    DEFINE_ABSTRACT_UNKNOWN()   //  For IUnknown

    DEFINE_ABSTRACT_MXF()       //  For IMXF

    //  For ISynthSinkDMus
    STDMETHOD_(void,Render)
    (   THIS_
        IN      PBYTE       pBuffer,
        IN      DWORD       dwLength,
        IN      LONGLONG    llPosition
    )   PURE;

    STDMETHOD_(NTSTATUS,SyncToMaster)
    (   THIS_
        IN      REFERENCE_TIME  rfTime,
        IN      BOOL            fStart
    )   PURE;

    STDMETHOD_(NTSTATUS,SampleToRefTime)
    (   THIS_
        IN      LONGLONG         llSampleTime,
        OUT     REFERENCE_TIME * prfTime
    )   PURE;

    STDMETHOD_(NTSTATUS,RefTimeToSample)
    (   THIS_
        IN      REFERENCE_TIME  rfTime,
        OUT     LONGLONG *      pllSampleTime
    )   PURE;
};

typedef ISynthSinkDMus * PSYNTHSINKDMUS;

#define IMP_ISynthSinkDMus\
    IMP_IMXF;\
    STDMETHODIMP_(void) Render\
    (   IN      PBYTE       pBuffer,\
        IN      DWORD       dwLength,\
        IN      LONGLONG    llPosition\
    );\
    STDMETHODIMP_(NTSTATUS) SyncToMaster\
    (   IN      REFERENCE_TIME  rfTime,\
        IN      BOOL            fStart\
    );\
    STDMETHODIMP_(NTSTATUS) SampleToRefTime\
    (   IN      LONGLONG         llSampleTime,\
        OUT     REFERENCE_TIME * prfTime\
    );\
    STDMETHODIMP_(NTSTATUS) RefTimeToSample\
    (   IN      REFERENCE_TIME  rfTime,\
        OUT     LONGLONG *      pllSampleTime\
    )


/*****************************************************************************
 * IMasterClock
 *****************************************************************************
 * Master clock for MXF graph
 */
DECLARE_INTERFACE_(IMasterClock,IUnknown)
{
    DEFINE_ABSTRACT_UNKNOWN()   //  For IUnknown

    STDMETHOD_(NTSTATUS,GetTime)
    (   THIS_
        OUT     REFERENCE_TIME  * pTime
    )   PURE;
};

typedef IMasterClock *PMASTERCLOCK;

#define IMP_IMasterClock               \
    STDMETHODIMP_(NTSTATUS) GetTime               \
    (   THIS_                          \
        OUT     REFERENCE_TIME * pTime \
    );                                 \


/*****************************************************************************
 * IMiniportDMus
 *****************************************************************************
 * Interface for DMusic miniports.
 */
DECLARE_INTERFACE_(IMiniportDMus,IMiniport)
{
    DEFINE_ABSTRACT_UNKNOWN()   //  For IUnknown

    DEFINE_ABSTRACT_MINIPORT()  //  For IMiniport

    //  For IMiniportDMus
    STDMETHOD_(NTSTATUS,Init)
    (   THIS_
        IN      PUNKNOWN        UnknownAdapter,
        IN      PRESOURCELIST   ResourceList,
        IN      PPORTDMUS       Port,
        OUT     PSERVICEGROUP * ServiceGroup
    )   PURE;

    STDMETHOD_(void,Service)
    (   THIS
    )   PURE;

    STDMETHOD_(NTSTATUS,NewStream)
    (   THIS_
        OUT     PMXF                  * MXF,
        IN      PUNKNOWN                OuterUnknown    OPTIONAL,
        IN      POOL_TYPE               PoolType,
        IN      ULONG                   PinID,
        IN      DMUS_STREAM_TYPE        StreamType,
        IN      PKSDATAFORMAT           DataFormat,
        OUT     PSERVICEGROUP         * ServiceGroup,
        IN      PAllocatorMXF           AllocatorMXF,
        IN      PMASTERCLOCK            MasterClock,
        OUT     PULONGLONG              SchedulePreFetch
    )   PURE;
};

typedef IMiniportDMus *PMINIPORTDMUS;

#define IMP_IMiniportDMus\
    IMP_IMiniport;\
    STDMETHODIMP_(NTSTATUS) Init\
    (   IN      PUNKNOWN        UnknownAdapter,\
        IN      PRESOURCELIST   ResourceList,\
        IN      PPORTDMUS       Port,\
        OUT     PSERVICEGROUP * ServiceGroup\
    );\
    STDMETHODIMP_(void) Service\
    (   void\
    );\
    STDMETHODIMP_(NTSTATUS) NewStream\
    (   OUT     PMXF                  * MXF,                        \
        IN      PUNKNOWN                OuterUnknown    OPTIONAL,   \
        IN      POOL_TYPE               PoolType,                   \
        IN      ULONG                   PinID,                      \
        IN      DMUS_STREAM_TYPE        StreamType,                 \
        IN      PKSDATAFORMAT           DataFormat,                 \
        OUT     PSERVICEGROUP         * ServiceGroup,               \
        IN      PAllocatorMXF           AllocatorMXF,               \
        IN      PMASTERCLOCK            MasterClock,                \
        OUT     PULONGLONG              SchedulePreFetch            \
    )

DEFINE_GUID(GUID_DMUS_PROP_GM_Hardware, 0x178f2f24, 0xc364, 0x11d1, 0xa7, 0x60, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);
DEFINE_GUID(GUID_DMUS_PROP_GS_Hardware, 0x178f2f25, 0xc364, 0x11d1, 0xa7, 0x60, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);
DEFINE_GUID(GUID_DMUS_PROP_XG_Hardware, 0x178f2f26, 0xc364, 0x11d1, 0xa7, 0x60, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);
DEFINE_GUID(GUID_DMUS_PROP_XG_Capable,  0x6496aba1, 0x61b0, 0x11d2, 0xaf, 0xa6, 0x00, 0xaa, 0x00, 0x24, 0xd8, 0xb6);
DEFINE_GUID(GUID_DMUS_PROP_GS_Capable,  0x6496aba2, 0x61b0, 0x11d2, 0xaf, 0xa6, 0x00, 0xaa, 0x00, 0x24, 0xd8, 0xb6);
DEFINE_GUID(GUID_DMUS_PROP_DLS1,        0x178f2f27, 0xc364, 0x11d1, 0xa7, 0x60, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);
DEFINE_GUID(GUID_DMUS_PROP_WavesReverb, 0x04cb5622, 0x32e5, 0x11d2, 0xaf, 0xa6, 0x00, 0xaa, 0x00, 0x24, 0xd8, 0xb6);
DEFINE_GUID(GUID_DMUS_PROP_Effects,     0xcda8d611, 0x684a, 0x11d2, 0x87, 0x1e, 0x00, 0x60, 0x08, 0x93, 0xb1, 0xbd);

#ifndef DMUS_EFFECT_NONE
#define DMUS_EFFECT_NONE    0x00000000
#endif

#ifndef DMUS_EFFECT_REVERB
#define DMUS_EFFECT_REVERB  0x00000001
#endif

#ifndef DMUS_EFFECT_CHORUS
#define DMUS_EFFECT_CHORUS  0x00000002
#endif


#endif  /* _DMUSICKS_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\ddk\inc\dmusprop.h ===
/***************************************************************************
*                                                                          *
*   DMusProp.h -- This module defines property items for DirectMusic WDM   *
*                                                                          *
*   Copyright (c) 1998, Microsoft Corp. All rights reserved.               *
*                                                                          *
***************************************************************************/

#ifndef _DMusProp_
#define _DMusProp_

#include "dmusbuff.h"

/*
    Formats
*/
#define STATIC_KSDATAFORMAT_SUBTYPE_DIRECTMUSIC\
    0x1a82f8bc,  0x3f8b, 0x11d2, 0xb7, 0x74, 0x00, 0x60, 0x08, 0x33, 0x16, 0xc1
DEFINE_GUIDSTRUCT("1a82f8bc-3f8b-11d2-b774-0060083316c1", KSDATAFORMAT_SUBTYPE_DIRECTMUSIC);
#define KSDATAFORMAT_SUBTYPE_DIRECTMUSIC DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_DIRECTMUSIC)


/*
    Topology
*/
#define STATIC_KSNODETYPE_DMSYNTH\
    0x94824f88, 0x6183, 0x11d2, 0x8f, 0x7a, 0x0, 0xc0, 0x4f, 0xbf, 0x8f, 0xef
DEFINE_GUIDSTRUCT("94824F88-6183-11d2-8F7A-00C04FBF8FEF", KSNODETYPE_DMSYNTH);
#define KSNODETYPE_DMSYNTH DEFINE_GUIDNAMED(KSNODETYPE_DMSYNTH)

/*
    Caps node (per pin)
*/
#define STATIC_KSNODETYPE_DMSYNTH_CAPS\
    0xbca2a2f1, 0x93c6, 0x11d2, 0xba, 0x1d, 0x0, 0x0, 0xf8, 0x75, 0xac, 0x12
DEFINE_GUIDSTRUCT("bca2a2f1-93c6-11d2-ba1d-0000f875ac12", KSNODETYPE_DMSYNTH_CAPS);
#define KSNODETYPE_DMSYNTH_CAPS DEFINE_GUIDNAMED(KSNODETYPE_DMSYNTH_CAPS)

/*
    DDK Property sets and items
*/
#define STATIC_KSPROPSETID_Synth_Dls\
    0xd523fa2c, 0xdee3, 0x11d1, 0xa7, 0x89, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12
DEFINE_GUIDSTRUCT("d523fa2c-dee3-11d1-a789-0000f875ac12", KSPROPSETID_Synth_Dls);
#define KSPROPSETID_Synth_Dls DEFINE_GUIDNAMED(KSPROPSETID_Synth_Dls)

typedef enum
{
    KSPROPERTY_SYNTH_DLS_DOWNLOAD = 0,
    KSPROPERTY_SYNTH_DLS_UNLOAD,
    KSPROPERTY_SYNTH_DLS_COMPACT,
    KSPROPERTY_SYNTH_DLS_APPEND,
    KSPROPERTY_SYNTH_DLS_WAVEFORMAT
} KSPROPERTY_SYNTH_DLS;

typedef struct _SYNTH_BUFFER
{
    ULONG   BufferSize;
    PVOID   BufferAddress;
} SYNTH_BUFFER, *PSYNTH_BUFFER;

typedef struct _SYNTHDOWNLOAD
{
    HANDLE  DownloadHandle;
    BOOL    Free;               /* the client buffer can be freed */
} SYNTHDOWNLOAD, *PSYNTHDOWNLOAD;


#define STATIC_KSPROPSETID_Synth\
    0xfedfae25L, 0xe46e, 0x11d1, 0xaa, 0xce, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12
DEFINE_GUIDSTRUCT("fedfae25-e46e-11d1-aace-0000f875ac12", KSPROPSETID_Synth);
#define KSPROPSETID_Synth DEFINE_GUIDNAMED(KSPROPSETID_Synth)

typedef enum
{
    KSPROPERTY_SYNTH_VOLUME = 0,  /* must be first */
    KSPROPERTY_SYNTH_VOLUMEBOOST,
    KSPROPERTY_SYNTH_CAPS,
    KSPROPERTY_SYNTH_PORTPARAMETERS,
    KSPROPERTY_SYNTH_CHANNELGROUPS,
    KSPROPERTY_SYNTH_VOICEPRIORITY,
    KSPROPERTY_SYNTH_LATENCYCLOCK,
    KSPROPERTY_SYNTH_RUNNINGSTATS
} KSPROPERTY_SYNTH;

#define SYNTH_PC_DLS                (0x00000001)
#define SYNTH_PC_EXTERNAL           (0x00000002)
#define SYNTH_PC_SOFTWARESYNTH      (0x00000004)
#define SYNTH_PC_MEMORYSIZEFIXED    (0x00000008)
#define SYNTH_PC_GMINHARDWARE       (0x00000010)
#define SYNTH_PC_GSINHARDWARE       (0x00000020)
#define SYNTH_PC_XGINHARDWARE       (0x00000040)
// 0x80 used in user mode
// 0x100 used in user mode
#define SYNTH_PC_DLS2               (0x00000200)
// 0x400 used in user mode
// 0x800 used in user mode
#define SYNTH_PC_REVERB             (0x40000000)

#define SYNTH_PC_SYSTEMMEMORY       (0x7fffffff)

typedef struct _SYNTHCAPS
{
    GUID    Guid;
    DWORD   Flags;
    DWORD   MemorySize;
    DWORD   MaxChannelGroups;
    DWORD   MaxVoices;
    DWORD   MaxAudioChannels;
    DWORD   EffectFlags;
    WCHAR   Description[128];
} SYNTHCAPS, *PSYNTHCAPS;


typedef struct _SYNTH_PORTPARAMS
{
    DWORD   ValidParams;
    DWORD   Voices;
    DWORD   ChannelGroups;
    DWORD   AudioChannels;
    DWORD   SampleRate;
    DWORD   EffectsFlags;
    DWORD   Share;
} SYNTH_PORTPARAMS, *PSYNTH_PORTPARAMS;

/*  These flags (set in ValidParams) indicate which
 *  other members of the SYNTH_PORTPARAMS are valid
 */
#define SYNTH_PORTPARAMS_VOICES           0x00000001
#define SYNTH_PORTPARAMS_CHANNELGROUPS    0x00000002
#define SYNTH_PORTPARAMS_AUDIOCHANNELS    0x00000004
#define SYNTH_PORTPARAMS_SAMPLERATE       0x00000008
#define SYNTH_PORTPARAMS_EFFECTS          0x00000020
#define SYNTH_PORTPARAMS_SHARE            0x00000040

/* SYNTH_EFFECT_ flags are used in the
 * EffectFlags fields of SYNTH_PORTPARAMS.
 */

#define SYNTH_EFFECT_NONE             0x00000000
#define SYNTH_EFFECT_REVERB           0x00000001
#define SYNTH_EFFECT_CHORUS           0x00000002
#define SYNTH_EFFECT_DELAY            0x00000004

/*
 * Instance data for KSPROPERTY_ITEM_SynthVoicePriority
 */
typedef struct _SYNTHVOICEPRIORITY_INSTANCE
{
    DWORD   ChannelGroup;
    DWORD   Channel;
} SYNTHVOICEPRIORITY_INSTANCE, *PSYNTHVOICEPRIORITY_INSTANCE;

/*
 * Data returned by KSPROPERTY_SYNTH_RUNNINGSTATS
 */
typedef struct _SYNTH_STATS
{
    DWORD   ValidStats;       /* Flags indicating which fields below are valid. */
    DWORD   Voices;           /* Average number of voices playing. */
    DWORD   TotalCPU;         /* Total CPU usage as percent * 100. */
    DWORD   CPUPerVoice;      /* CPU per voice as percent * 100. */
    DWORD   LostNotes;        /* Number of notes lost in 1 second. */
    DWORD   FreeMemory;       /* Free memory in bytes */
    LONG    PeakVolume;       /* Decibel level * 100. */
} SYNTH_STATS, *PSYNTH_STATS;


#define SYNTH_STATS_VOICES          (1 << 0)
#define SYNTH_STATS_TOTAL_CPU       (1 << 1)
#define SYNTH_STATS_CPU_PER_VOICE   (1 << 2)
#define SYNTH_STATS_LOST_NOTES      (1 << 3)
#define SYNTH_STATS_PEAK_VOLUME     (1 << 4)
#define SYNTH_STATS_FREE_MEMORY     (1 << 5)

#ifndef _DIRECTAUDIO_PRIORITIES_DEFINED_
#define _DIRECTAUDIO_PRIORITIES_DEFINED_

#define DAUD_CRITICAL_VOICE_PRIORITY    (0xF0000000)
#define DAUD_HIGH_VOICE_PRIORITY        (0xC0000000)
#define DAUD_STANDARD_VOICE_PRIORITY    (0x80000000)
#define DAUD_LOW_VOICE_PRIORITY         (0x40000000)
#define DAUD_PERSIST_VOICE_PRIORITY     (0x10000000)

/* These are the default priorities assigned if not overridden. By default priorities are
 * equal across channel groups (e.g. channel 5 on channel group 1 has the same priority as
 * channel 5 on channel group 2).
 *
 * In accordance with DLS level 1, channel 10 has the highest priority, followed by 1 through 16
 * except for 10.
 */
#define DAUD_CHAN1_VOICE_PRIORITY_OFFSET    (0x0000000E)
#define DAUD_CHAN2_VOICE_PRIORITY_OFFSET    (0x0000000D)
#define DAUD_CHAN3_VOICE_PRIORITY_OFFSET    (0x0000000C)
#define DAUD_CHAN4_VOICE_PRIORITY_OFFSET    (0x0000000B)
#define DAUD_CHAN5_VOICE_PRIORITY_OFFSET    (0x0000000A)
#define DAUD_CHAN6_VOICE_PRIORITY_OFFSET    (0x00000009)
#define DAUD_CHAN7_VOICE_PRIORITY_OFFSET    (0x00000008)
#define DAUD_CHAN8_VOICE_PRIORITY_OFFSET    (0x00000007)
#define DAUD_CHAN9_VOICE_PRIORITY_OFFSET    (0x00000006)
#define DAUD_CHAN10_VOICE_PRIORITY_OFFSET   (0x0000000F)
#define DAUD_CHAN11_VOICE_PRIORITY_OFFSET   (0x00000005)
#define DAUD_CHAN12_VOICE_PRIORITY_OFFSET   (0x00000004)
#define DAUD_CHAN13_VOICE_PRIORITY_OFFSET   (0x00000003)
#define DAUD_CHAN14_VOICE_PRIORITY_OFFSET   (0x00000002)
#define DAUD_CHAN15_VOICE_PRIORITY_OFFSET   (0x00000001)
#define DAUD_CHAN16_VOICE_PRIORITY_OFFSET   (0x00000000)


#define DAUD_CHAN1_DEF_VOICE_PRIORITY   (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN1_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN2_DEF_VOICE_PRIORITY   (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN2_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN3_DEF_VOICE_PRIORITY   (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN3_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN4_DEF_VOICE_PRIORITY   (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN4_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN5_DEF_VOICE_PRIORITY   (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN5_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN6_DEF_VOICE_PRIORITY   (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN6_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN7_DEF_VOICE_PRIORITY   (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN7_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN8_DEF_VOICE_PRIORITY   (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN8_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN9_DEF_VOICE_PRIORITY   (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN9_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN10_DEF_VOICE_PRIORITY  (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN10_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN11_DEF_VOICE_PRIORITY  (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN11_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN12_DEF_VOICE_PRIORITY  (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN12_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN13_DEF_VOICE_PRIORITY  (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN13_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN14_DEF_VOICE_PRIORITY  (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN14_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN15_DEF_VOICE_PRIORITY  (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN15_VOICE_PRIORITY_OFFSET)
#define DAUD_CHAN16_DEF_VOICE_PRIORITY  (DAUD_STANDARD_VOICE_PRIORITY | DAUD_CHAN16_VOICE_PRIORITY_OFFSET)

#endif  /* _DIRECTAUDIO_PRIORITIES_DEFINED_ */

/*
    SDK Property sets and items
*/
typedef struct _SYNTH_REVERB_PARAMS
{
    float   fInGain;            /* Input gain in dB (to avoid output overflows) */
    float   fReverbMix;         /* Reverb mix in dB. 0dB means 100% wet reverb (no direct signal).
                                   Negative values gives less wet signal.  The coeficients are
                                   calculated so that the overall output level stays (approximately)
                                   constant regardless of the ammount of reverb mix. */
    float   fReverbTime;        /* The reverb decay time, in milliseconds. */
    float   fHighFreqRTRatio;   /* The ratio of the high frequencies to the global reverb time.
                                   Unless very 'splashy-bright' reverbs are wanted, this should be set to
                                   a value < 1.0.  For example if dRevTime==1000ms and dHighFreqRTRatio=0.1
                                   than the decay time for high frequencies will be 100ms.*/
} SYNTH_REVERB_PARAMS, *PSYNTH_REVERB_PARAMS;


#define STATIC_KSPROPSETID_SynthClock \
    0xfedfae26L, 0xe46e, 0x11d1, 0xaa, 0xce, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12
DEFINE_GUIDSTRUCT("fedfae26-e46e-11d1-aace-0000f875ac12", KSPROPSETID_SynthClock);
#define KSPROPSETID_SynthClock DEFINE_GUIDNAMED(KSPROPSETID_SynthClock)

typedef enum
{
    KSPROPERTY_SYNTH_MASTERCLOCK
} KSPROPERTY_SYNTHCLOCK;
#endif /* _DMusProp_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\ddk\inc\devioctl.h ===
/*++ BUILD Version: 0004    // Increment this if a change has global effects

Copyright (c) 1992-1999  Microsoft Corporation

Module Name:

    devioctl.h

Abstract:

    This module contains

Author:

    Andre Vachon (andreva) 21-Feb-1992


Revision History:


--*/

// begin_winioctl

#ifndef _DEVIOCTL_
#define _DEVIOCTL_

// begin_ntddk begin_wdm begin_nthal begin_ntifs
//
// Define the various device type values.  Note that values used by Microsoft
// Corporation are in the range 0-32767, and 32768-65535 are reserved for use
// by customers.
//

#define DEVICE_TYPE ULONG

#define FILE_DEVICE_BEEP                0x00000001
#define FILE_DEVICE_CD_ROM              0x00000002
#define FILE_DEVICE_CD_ROM_FILE_SYSTEM  0x00000003
#define FILE_DEVICE_CONTROLLER          0x00000004
#define FILE_DEVICE_DATALINK            0x00000005
#define FILE_DEVICE_DFS                 0x00000006
#define FILE_DEVICE_DISK                0x00000007
#define FILE_DEVICE_DISK_FILE_SYSTEM    0x00000008
#define FILE_DEVICE_FILE_SYSTEM         0x00000009
#define FILE_DEVICE_INPORT_PORT         0x0000000a
#define FILE_DEVICE_KEYBOARD            0x0000000b
#define FILE_DEVICE_MAILSLOT            0x0000000c
#define FILE_DEVICE_MIDI_IN             0x0000000d
#define FILE_DEVICE_MIDI_OUT            0x0000000e
#define FILE_DEVICE_MOUSE               0x0000000f
#define FILE_DEVICE_MULTI_UNC_PROVIDER  0x00000010
#define FILE_DEVICE_NAMED_PIPE          0x00000011
#define FILE_DEVICE_NETWORK             0x00000012
#define FILE_DEVICE_NETWORK_BROWSER     0x00000013
#define FILE_DEVICE_NETWORK_FILE_SYSTEM 0x00000014
#define FILE_DEVICE_NULL                0x00000015
#define FILE_DEVICE_PARALLEL_PORT       0x00000016
#define FILE_DEVICE_PHYSICAL_NETCARD    0x00000017
#define FILE_DEVICE_PRINTER             0x00000018
#define FILE_DEVICE_SCANNER             0x00000019
#define FILE_DEVICE_SERIAL_MOUSE_PORT   0x0000001a
#define FILE_DEVICE_SERIAL_PORT         0x0000001b
#define FILE_DEVICE_SCREEN              0x0000001c
#define FILE_DEVICE_SOUND               0x0000001d
#define FILE_DEVICE_STREAMS             0x0000001e
#define FILE_DEVICE_TAPE                0x0000001f
#define FILE_DEVICE_TAPE_FILE_SYSTEM    0x00000020
#define FILE_DEVICE_TRANSPORT           0x00000021
#define FILE_DEVICE_UNKNOWN             0x00000022
#define FILE_DEVICE_VIDEO               0x00000023
#define FILE_DEVICE_VIRTUAL_DISK        0x00000024
#define FILE_DEVICE_WAVE_IN             0x00000025
#define FILE_DEVICE_WAVE_OUT            0x00000026
#define FILE_DEVICE_8042_PORT           0x00000027
#define FILE_DEVICE_NETWORK_REDIRECTOR  0x00000028
#define FILE_DEVICE_BATTERY             0x00000029
#define FILE_DEVICE_BUS_EXTENDER        0x0000002a
#define FILE_DEVICE_MODEM               0x0000002b
#define FILE_DEVICE_VDM                 0x0000002c
#define FILE_DEVICE_MASS_STORAGE        0x0000002d
#define FILE_DEVICE_SMB                 0x0000002e
#define FILE_DEVICE_KS                  0x0000002f
#define FILE_DEVICE_CHANGER             0x00000030
#define FILE_DEVICE_SMARTCARD           0x00000031
#define FILE_DEVICE_ACPI                0x00000032
#define FILE_DEVICE_DVD                 0x00000033
#define FILE_DEVICE_FULLSCREEN_VIDEO    0x00000034
#define FILE_DEVICE_DFS_FILE_SYSTEM     0x00000035
#define FILE_DEVICE_DFS_VOLUME          0x00000036
#define FILE_DEVICE_SERENUM             0x00000037
#define FILE_DEVICE_TERMSRV             0x00000038
#define FILE_DEVICE_KSEC                0x00000039
#define FILE_DEVICE_FIPS		0x0000003A

//
// Macro definition for defining IOCTL and FSCTL function control codes.  Note
// that function codes 0-2047 are reserved for Microsoft Corporation, and
// 2048-4095 are reserved for customers.
//

#define CTL_CODE( DeviceType, Function, Method, Access ) (                 \
    ((DeviceType) << 16) | ((Access) << 14) | ((Function) << 2) | (Method) \
)

//
// Macro to extract device type out of the device io control code
//
#define DEVICE_TYPE_FROM_CTL_CODE(ctrlCode)     (((ULONG)(ctrlCode & 0xffff0000)) >> 16)

//
// Define the method codes for how buffers are passed for I/O and FS controls
//

#define METHOD_BUFFERED                 0
#define METHOD_IN_DIRECT                1
#define METHOD_OUT_DIRECT               2
#define METHOD_NEITHER                  3

//
// Define the access check value for any access
//
//
// The FILE_READ_ACCESS and FILE_WRITE_ACCESS constants are also defined in
// ntioapi.h as FILE_READ_DATA and FILE_WRITE_DATA. The values for these
// constants *MUST* always be in sync.
//
//
// FILE_SPECIAL_ACCESS is checked by the NT I/O system the same as FILE_ANY_ACCESS.
// The file systems, however, may add additional access checks for I/O and FS controls
// that use this value.
//


#define FILE_ANY_ACCESS                 0
#define FILE_SPECIAL_ACCESS    (FILE_ANY_ACCESS)
#define FILE_READ_ACCESS          ( 0x0001 )    // file & pipe
#define FILE_WRITE_ACCESS         ( 0x0002 )    // file & pipe

// end_ntddk end_wdm end_nthal end_ntifs

#endif // _DEVIOCTL_

// end_winioctl
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\ddk\inc\drivinit.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992-1999.
//
//  File:       drivinit.h
//
//----------------------------------------------------------------------------

// All items moved to wingdi.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\ddk\inc\drmk.h ===
#ifndef _DRMK_H_
#define _DRMK_H_

#ifdef __cplusplus
extern "C"
{
#endif
    
	
typedef struct tagDRMRIGHTS {
    BOOL  CopyProtect;
    ULONG Reserved;
    BOOL  DigitalOutputDisable;
} DRMRIGHTS , *PDRMRIGHTS;
typedef const DRMRIGHTS *PCDRMRIGHTS;

#define DEFINE_DRMRIGHTS_DEFAULT(DrmRights) const DRMRIGHTS DrmRights = {FALSE, 0, FALSE}


// {1915C967-3299-48cb-A3E4-69FD1D1B306E}
DEFINE_GUID(IID_IDrmAudioStream,
	    0x1915c967, 0x3299, 0x48cb, 0xa3, 0xe4, 0x69, 0xfd, 0x1d, 0x1b, 0x30, 0x6e);

DECLARE_INTERFACE_(IDrmAudioStream, IUnknown)
{
    // IUnknown methods
    STDMETHOD_(NTSTATUS, QueryInterface)(THIS_
        REFIID InterfaceId,
        PVOID* Interface
        ) PURE;
        
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    
    STDMETHOD_(ULONG,Release)(THIS) PURE;
    
    // IDrmAudioStream methods                       
    STDMETHOD_(NTSTATUS,SetContentId)(THIS_
	IN ULONG ContentId,
        IN PCDRMRIGHTS DrmRights
        ) PURE;
};

typedef IDrmAudioStream *PDRMAUDIOSTREAM;

#define IMP_IDrmAudioStream\
    STDMETHODIMP_(NTSTATUS) SetContentId\
    (   IN      ULONG	    ContentId,\
        IN      PCDRMRIGHTS DrmRights\
    );

typedef struct tagDRMFORWARD {
    DWORD          Flags;
    PDEVICE_OBJECT DeviceObject;
    PFILE_OBJECT   FileObject;
    PVOID          Context;
} DRMFORWARD, *PDRMFORWARD;
typedef const DRMFORWARD *PCDRMFORWARD;

NTSTATUS
NTAPI
DrmAddContentHandlers(
    IN ULONG ContentId,
    IN PVOID* paHandlers,
    IN ULONG NumHandlers
    );

typedef
NTSTATUS
(NTAPI *PFNDRMADDCONTENTHANDLERS)(
    IN ULONG ContentId,
    IN PVOID* paHandlers,
    IN ULONG NumHandlers
    );

NTSTATUS
NTAPI
DrmCreateContentMixed(
    IN PULONG paContentId,
    IN ULONG cContentId,
    OUT PULONG pMixedContentId
    );

typedef
NTSTATUS
(NTAPI *PFNDRMCREATECONTENTMIXED)(
    IN PULONG paContentId,
    IN ULONG cContentId,
    OUT PULONG pMixedContentId
    );

NTSTATUS
NTAPI
DrmDestroyContent(
    IN ULONG ContentId
    );

typedef
NTSTATUS
(NTAPI *PFNDRMDESTROYCONTENT)(
    IN ULONG ContentId
    );

NTSTATUS
NTAPI
DrmForwardContentToDeviceObject(
    IN ULONG ContentId,
    IN PVOID Reserved,
    IN PCDRMFORWARD DrmForward
    );

typedef
NTSTATUS
(NTAPI *PFNDRMFORWARDCONTENTTODEVICEOBJECT)(
    IN ULONG ContentId,
    IN PVOID Reserved,
    IN PCDRMFORWARD DrmForward
    );


NTSTATUS
NTAPI
DrmForwardContentToFileObject(
    IN ULONG ContentId,
    IN PFILE_OBJECT FileObject
    );

typedef
NTSTATUS
(NTAPI *PFNDRMFORWARDCONTENTTOFILEOBJECT)(
    IN ULONG ContentId,
    IN PFILE_OBJECT FileObject
    );

NTSTATUS
NTAPI
DrmForwardContentToInterface(
    ULONG ContentId,
    PUNKNOWN pUnknown,
    ULONG NumMethods);

typedef
NTSTATUS
(NTAPI *PFNDRMFORWARDCONTENTTOINTERFACE)(
    ULONG ContentId,
    PUNKNOWN pUnknown,
    ULONG NumMethods);

NTSTATUS
NTAPI
DrmGetContentRights(
    IN ULONG ContentId,
    OUT PDRMRIGHTS DrmRights
    );

typedef
NTSTATUS
(NTAPI *PFNDRMGETCONTENTRIGHTS)(
    IN ULONG ContentId,
    OUT PDRMRIGHTS DrmRights
    );


//
// Structures for use with KSPROPERY_DRMAUDIOSTREAM_CONTENTID
//

typedef struct {
    ULONG     ContentId;
    DRMRIGHTS DrmRights;
} KSDRMAUDIOSTREAM_CONTENTID, *PKSDRMAUDIOSTREAM_CONTENTID;

typedef struct {
    KSPROPERTY                         Property;
    PVOID                              Context;
    // DRM API callback functions
    PFNDRMADDCONTENTHANDLERS            DrmAddContentHandlers;
    PFNDRMCREATECONTENTMIXED            DrmCreateContentMixed;
    PFNDRMDESTROYCONTENT                DrmDestroyContent;
    PFNDRMFORWARDCONTENTTODEVICEOBJECT  DrmForwardContentToDeviceObject;
    PFNDRMFORWARDCONTENTTOFILEOBJECT    DrmForwardContentToFileObject;
    PFNDRMFORWARDCONTENTTOINTERFACE     DrmForwardContentToInterface;
    PFNDRMGETCONTENTRIGHTS              DrmGetContentRights;
} KSP_DRMAUDIOSTREAM_CONTENTID, *PKSP_DRMAUDIOSTREAM_CONTENTID;


#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\ddk\inc\dmusics.h ===
/************************************************************************
*                                                                       *
*   dmusics.h -- Definitions for created a DirectMusic software synth   *
*                                                                       *
*   Copyright (c) 1998-1999 Microsoft Corporation
*                                                                       *
************************************************************************/

#ifndef _DMUSICS_
#define _DMUSICS_

#include "dmusicc.h"

/* Software synths are enumerated from under this registry key.
 */
#define REGSTR_PATH_SOFTWARESYNTHS  "Software\\Microsoft\\DirectMusic\\SoftwareSynths"

interface IDirectMusicSynth;
interface IDirectMusicSynthSink;

#ifndef __cplusplus 
typedef interface IDirectMusicSynth IDirectMusicSynth;
typedef interface IDirectMusicSynthSink IDirectMusicSynthSink;
#endif

#ifndef _DMUS_VOICE_STATE_DEFINED
#define _DMUS_VOICE_STATE_DEFINED

typedef struct _DMUS_VOICE_STATE
{
    BOOL                bExists;
    SAMPLE_POSITION     spPosition;
} DMUS_VOICE_STATE; 

#endif /* _DMUS_VOICE_STATE_DEFINED */

/* IDirectMusicSynth::Refresh
 *
 * This is the last buffer of the stream. It may be a partial block.
 */
#define REFRESH_F_LASTBUFFER        0x00000001

#undef  INTERFACE
#define INTERFACE  IDirectMusicSynth
DECLARE_INTERFACE_(IDirectMusicSynth, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /* IDirectMusicSynth */
    STDMETHOD(Open)                 (THIS_ LPDMUS_PORTPARAMS pPortParams) PURE;
    STDMETHOD(Close)                (THIS) PURE;
    STDMETHOD(SetNumChannelGroups)  (THIS_ DWORD dwGroups) PURE;
    STDMETHOD(Download)             (THIS_ LPHANDLE phDownload, 
                                           LPVOID pvData, 
                                           LPBOOL pbFree ) PURE;
    STDMETHOD(Unload)               (THIS_ HANDLE hDownload, 
                                           HRESULT ( CALLBACK *lpFreeHandle)(HANDLE,HANDLE), 
                                           HANDLE hUserData ) PURE; 
    STDMETHOD(PlayBuffer)           (THIS_ REFERENCE_TIME rt, 
                                           LPBYTE pbBuffer, 
                                           DWORD cbBuffer) PURE;
    STDMETHOD(GetRunningStats)      (THIS_ LPDMUS_SYNTHSTATS pStats) PURE;
    STDMETHOD(GetPortCaps)          (THIS_ LPDMUS_PORTCAPS pCaps) PURE;
    STDMETHOD(SetMasterClock)       (THIS_ IReferenceClock *pClock) PURE;
    STDMETHOD(GetLatencyClock)      (THIS_ IReferenceClock **ppClock) PURE;
    STDMETHOD(Activate)             (THIS_ BOOL fEnable) PURE;
    STDMETHOD(SetSynthSink)         (THIS_ IDirectMusicSynthSink *pSynthSink) PURE;
    STDMETHOD(Render)               (THIS_ short *pBuffer, 
                                           DWORD dwLength, 
                                           LONGLONG llPosition) PURE;
    STDMETHOD(SetChannelPriority)   (THIS_ DWORD dwChannelGroup,
                                           DWORD dwChannel,
                                           DWORD dwPriority) PURE;
    STDMETHOD(GetChannelPriority)   (THIS_ DWORD dwChannelGroup,
                                           DWORD dwChannel,
                                           LPDWORD pdwPriority) PURE;
    STDMETHOD(GetFormat)            (THIS_ LPWAVEFORMATEX pWaveFormatEx,
                                           LPDWORD pdwWaveFormatExSize) PURE;
    STDMETHOD(GetAppend)            (THIS_ DWORD* pdwAppend) PURE;
};

#undef  INTERFACE

#define INTERFACE  IDirectMusicSynth8
DECLARE_INTERFACE_(IDirectMusicSynth8, IDirectMusicSynth)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /* IDirectMusicSynth */
    STDMETHOD(Open)                 (THIS_ LPDMUS_PORTPARAMS pPortParams) PURE;
    STDMETHOD(Close)                (THIS) PURE;
    STDMETHOD(SetNumChannelGroups)  (THIS_ DWORD dwGroups) PURE;
    STDMETHOD(Download)             (THIS_ LPHANDLE phDownload, 
                                           LPVOID pvData, 
                                           LPBOOL pbFree ) PURE;
    STDMETHOD(Unload)               (THIS_ HANDLE hDownload, 
                                           HRESULT ( CALLBACK *lpFreeHandle)(HANDLE,HANDLE), 
                                           HANDLE hUserData ) PURE; 
    STDMETHOD(PlayBuffer)           (THIS_ REFERENCE_TIME rt, 
                                           LPBYTE pbBuffer, 
                                           DWORD cbBuffer) PURE;
    STDMETHOD(GetRunningStats)      (THIS_ LPDMUS_SYNTHSTATS pStats) PURE;
    STDMETHOD(GetPortCaps)          (THIS_ LPDMUS_PORTCAPS pCaps) PURE;
    STDMETHOD(SetMasterClock)       (THIS_ IReferenceClock *pClock) PURE;
    STDMETHOD(GetLatencyClock)      (THIS_ IReferenceClock **ppClock) PURE;
    STDMETHOD(Activate)             (THIS_ BOOL fEnable) PURE;
    STDMETHOD(SetSynthSink)         (THIS_ IDirectMusicSynthSink *pSynthSink) PURE;
    STDMETHOD(Render)               (THIS_ short *pBuffer, 
                                           DWORD dwLength, 
                                           LONGLONG llPosition) PURE;
    STDMETHOD(SetChannelPriority)   (THIS_ DWORD dwChannelGroup,
                                           DWORD dwChannel,
                                           DWORD dwPriority) PURE;
    STDMETHOD(GetChannelPriority)   (THIS_ DWORD dwChannelGroup,
                                           DWORD dwChannel,
                                           LPDWORD pdwPriority) PURE;
    STDMETHOD(GetFormat)            (THIS_ LPWAVEFORMATEX pWaveFormatEx,
                                           LPDWORD pdwWaveFormatExSize) PURE;
    STDMETHOD(GetAppend)            (THIS_ DWORD* pdwAppend) PURE;

	/* IDirectMusicSynth8 */
    STDMETHOD(PlayVoice)            (THIS_ REFERENCE_TIME rt, 
										   DWORD dwVoiceId, 
										   DWORD dwChannelGroup, 
										   DWORD dwChannel, 
										   DWORD dwDLId, 
										   long	 prPitch,			/* PREL not defined here */
										   long  vrVolume,          /* VREL not defined here */
                                           SAMPLE_TIME stVoiceStart,
                                           SAMPLE_TIME stLoopStart,
                                           SAMPLE_TIME stLoopEnd) PURE;

    STDMETHOD(StopVoice)            (THIS_ REFERENCE_TIME rt, 
										   DWORD dwVoiceId ) PURE;

    STDMETHOD(GetVoiceState)        (THIS_ DWORD dwVoice[], 
										   DWORD cbVoice,
										   DMUS_VOICE_STATE dwVoiceState[] ) PURE;
    STDMETHOD(Refresh)              (THIS_ DWORD dwDownloadID,
                                           DWORD dwFlags) PURE;
    STDMETHOD(AssignChannelToBuses) (THIS_ DWORD dwChannelGroup,
                                           DWORD dwChannel,
                                           LPDWORD pdwBuses,
                                           DWORD cBuses) PURE;                                           
};

#undef  INTERFACE
#define INTERFACE  IDirectMusicSynthSink
DECLARE_INTERFACE_(IDirectMusicSynthSink, IUnknown)
{
    /* IUnknown */
    STDMETHOD(QueryInterface)       (THIS_ REFIID, LPVOID FAR *) PURE;
    STDMETHOD_(ULONG,AddRef)        (THIS) PURE;
    STDMETHOD_(ULONG,Release)       (THIS) PURE;

    /* IDirectMusicSynthSink */
    STDMETHOD(Init)                 (THIS_ IDirectMusicSynth *pSynth) PURE;
    STDMETHOD(SetMasterClock)       (THIS_ IReferenceClock *pClock) PURE;
    STDMETHOD(GetLatencyClock)      (THIS_ IReferenceClock **ppClock) PURE;
    STDMETHOD(Activate)             (THIS_ BOOL fEnable) PURE;
    STDMETHOD(SampleToRefTime)      (THIS_ LONGLONG llSampleTime,
                                           REFERENCE_TIME *prfTime) PURE;
    STDMETHOD(RefTimeToSample)      (THIS_ REFERENCE_TIME rfTime, 
                                           LONGLONG *pllSampleTime) PURE;
    STDMETHOD(SetDirectSound)       (THIS_ LPDIRECTSOUND pDirectSound,
                                           LPDIRECTSOUNDBUFFER pDirectSoundBuffer) PURE;                                           
    STDMETHOD(GetDesiredBufferSize) (THIS_ LPDWORD pdwBufferSizeInSamples) PURE;                                           
};

DEFINE_GUID(IID_IDirectMusicSynth, 0x9823661,  0x5c85, 0x11d2, 0xaf, 0xa6, 0x0, 0xaa, 0x0, 0x24, 0xd8, 0xb6);
DEFINE_GUID(IID_IDirectMusicSynth8,0x53cab625, 0x2711, 0x4c9f, 0x9d, 0xe7, 0x1b, 0x7f, 0x92, 0x5f, 0x6f, 0xc8);
DEFINE_GUID(IID_IDirectMusicSynthSink,0x9823663, 0x5c85, 0x11d2, 0xaf, 0xa6, 0x0, 0xaa, 0x0, 0x24, 0xd8, 0xb6);

/* Property Set GUID_DMUS_PROP_SetSynthSink
 *
 * Item 0: An IUnknown on which the port can QueryInterface for a user-mode synth sink.
 */
DEFINE_GUID(GUID_DMUS_PROP_SetSynthSink,0x0a3a5ba5, 0x37b6, 0x11d2, 0xb9, 0xf9, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12);

/* Property Set GUID_DMUS_PROP_SinkUsesDSound
 *
 * Item 0: A DWORD boolean indicating whether or not the sink requires an IDirectSound interface. The
 * default is FALSE if this property item is not implemented by the sink.
 */
DEFINE_GUID(GUID_DMUS_PROP_SinkUsesDSound, 0xbe208857, 0x8952, 0x11d2, 0xba, 0x1c, 0x00, 0x00, 0xf8, 0x75, 0xac, 0x12); 

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\ddk\inc\hbapiwmi.h ===
#ifndef _hbapiwmi_h_
#define _hbapiwmi_h_

// MSFC_FibrePortHBAStatistics - MSFC_FibrePortHBAStatistics
// This class exposes statistical information associated with a Fibre Channel port. There should be one instance of this class for each port.
#define MSFC_FibrePortHBAStatisticsGuid \
    { 0x27efaba4,0x362a,0x4f20, { 0x92,0x0b,0xed,0x66,0xe2,0x80,0xfc,0xf5 } }

DEFINE_GUID(MSFC_FibrePortHBAStatistics_GUID, \
            0x27efaba4,0x362a,0x4f20,0x92,0x0b,0xed,0x66,0xe2,0x80,0xfc,0xf5);


typedef struct _MSFC_FibrePortHBAStatistics
{
    // Unique identifier for the port. This idenitifer must be unique among all ports on all adapters. The same value for the identifier must be used for the same port in other classes that expose port information
    ULONGLONG UniquePortId;
    #define MSFC_FibrePortHBAStatistics_UniquePortId_SIZE sizeof(ULONGLONG)
    #define MSFC_FibrePortHBAStatistics_UniquePortId_ID 1

    // HBA Status result for the query operation
    ULONG HBAStatus;
    #define MSFC_FibrePortHBAStatistics_HBAStatus_SIZE sizeof(ULONG)
    #define MSFC_FibrePortHBAStatistics_HBAStatus_ID 2

    // 
    LONGLONG SecondsSinceLastReset;
    #define MSFC_FibrePortHBAStatistics_SecondsSinceLastReset_SIZE sizeof(LONGLONG)
    #define MSFC_FibrePortHBAStatistics_SecondsSinceLastReset_ID 3

    // 
    LONGLONG TxFrames;
    #define MSFC_FibrePortHBAStatistics_TxFrames_SIZE sizeof(LONGLONG)
    #define MSFC_FibrePortHBAStatistics_TxFrames_ID 4

    // 
    LONGLONG TxWords;
    #define MSFC_FibrePortHBAStatistics_TxWords_SIZE sizeof(LONGLONG)
    #define MSFC_FibrePortHBAStatistics_TxWords_ID 5

    // 
    LONGLONG RxFrames;
    #define MSFC_FibrePortHBAStatistics_RxFrames_SIZE sizeof(LONGLONG)
    #define MSFC_FibrePortHBAStatistics_RxFrames_ID 6

    // 
    LONGLONG RxWords;
    #define MSFC_FibrePortHBAStatistics_RxWords_SIZE sizeof(LONGLONG)
    #define MSFC_FibrePortHBAStatistics_RxWords_ID 7

    // 
    LONGLONG LIPCount;
    #define MSFC_FibrePortHBAStatistics_LIPCount_SIZE sizeof(LONGLONG)
    #define MSFC_FibrePortHBAStatistics_LIPCount_ID 8

    // 
    LONGLONG NOSCount;
    #define MSFC_FibrePortHBAStatistics_NOSCount_SIZE sizeof(LONGLONG)
    #define MSFC_FibrePortHBAStatistics_NOSCount_ID 9

    // 
    LONGLONG ErrorFrames;
    #define MSFC_FibrePortHBAStatistics_ErrorFrames_SIZE sizeof(LONGLONG)
    #define MSFC_FibrePortHBAStatistics_ErrorFrames_ID 10

    // 
    LONGLONG DumpedFrames;
    #define MSFC_FibrePortHBAStatistics_DumpedFrames_SIZE sizeof(LONGLONG)
    #define MSFC_FibrePortHBAStatistics_DumpedFrames_ID 11

    // 
    LONGLONG LinkFailureCount;
    #define MSFC_FibrePortHBAStatistics_LinkFailureCount_SIZE sizeof(LONGLONG)
    #define MSFC_FibrePortHBAStatistics_LinkFailureCount_ID 12

    // 
    LONGLONG LossOfSyncCount;
    #define MSFC_FibrePortHBAStatistics_LossOfSyncCount_SIZE sizeof(LONGLONG)
    #define MSFC_FibrePortHBAStatistics_LossOfSyncCount_ID 13

    // 
    LONGLONG LossOfSignalCount;
    #define MSFC_FibrePortHBAStatistics_LossOfSignalCount_SIZE sizeof(LONGLONG)
    #define MSFC_FibrePortHBAStatistics_LossOfSignalCount_ID 14

    // 
    LONGLONG PrimitiveSeqProtocolErrCount;
    #define MSFC_FibrePortHBAStatistics_PrimitiveSeqProtocolErrCount_SIZE sizeof(LONGLONG)
    #define MSFC_FibrePortHBAStatistics_PrimitiveSeqProtocolErrCount_ID 15

    // 
    LONGLONG InvalidTxWordCount;
    #define MSFC_FibrePortHBAStatistics_InvalidTxWordCount_SIZE sizeof(LONGLONG)
    #define MSFC_FibrePortHBAStatistics_InvalidTxWordCount_ID 16

    // 
    LONGLONG InvalidCRCCount;
    #define MSFC_FibrePortHBAStatistics_InvalidCRCCount_SIZE sizeof(LONGLONG)
    #define MSFC_FibrePortHBAStatistics_InvalidCRCCount_ID 17

} MSFC_FibrePortHBAStatistics, *PMSFC_FibrePortHBAStatistics;

// MSFC_HBAPortAttributesResults - MSFC_HBAPortAttributesResults
#define MSFC_HBAPortAttributesResultsGuid \
    { 0xa76bd4e3,0x9961,0x4d9b, { 0xb6,0xbe,0x86,0xe6,0x98,0x26,0x0f,0x68 } }

DEFINE_GUID(MSFC_HBAPortAttributesResults_GUID, \
            0xa76bd4e3,0x9961,0x4d9b,0xb6,0xbe,0x86,0xe6,0x98,0x26,0x0f,0x68);


typedef struct _MSFC_HBAPortAttributesResults
{
    // 
    UCHAR NodeWWN[8];
    #define MSFC_HBAPortAttributesResults_NodeWWN_SIZE sizeof(UCHAR[8])
    #define MSFC_HBAPortAttributesResults_NodeWWN_ID 1

    // 
    UCHAR PortWWN[8];
    #define MSFC_HBAPortAttributesResults_PortWWN_SIZE sizeof(UCHAR[8])
    #define MSFC_HBAPortAttributesResults_PortWWN_ID 2

    // 
    ULONG PortFcId;
    #define MSFC_HBAPortAttributesResults_PortFcId_SIZE sizeof(ULONG)
    #define MSFC_HBAPortAttributesResults_PortFcId_ID 3

    // 
    ULONG PortType;
    #define MSFC_HBAPortAttributesResults_PortType_SIZE sizeof(ULONG)
    #define MSFC_HBAPortAttributesResults_PortType_ID 4

    // 
    ULONG PortState;
    #define MSFC_HBAPortAttributesResults_PortState_SIZE sizeof(ULONG)
    #define MSFC_HBAPortAttributesResults_PortState_ID 5

    // 
    ULONG PortSupportedClassofService;
    #define MSFC_HBAPortAttributesResults_PortSupportedClassofService_SIZE sizeof(ULONG)
    #define MSFC_HBAPortAttributesResults_PortSupportedClassofService_ID 6

    // 
    UCHAR PortSupportedFc4Types[32];
    #define MSFC_HBAPortAttributesResults_PortSupportedFc4Types_SIZE sizeof(UCHAR[32])
    #define MSFC_HBAPortAttributesResults_PortSupportedFc4Types_ID 7

    // 
    UCHAR PortActiveFc4Types[32];
    #define MSFC_HBAPortAttributesResults_PortActiveFc4Types_SIZE sizeof(UCHAR[32])
    #define MSFC_HBAPortAttributesResults_PortActiveFc4Types_ID 8

    // 
    ULONG PortSupportedSpeed;
    #define MSFC_HBAPortAttributesResults_PortSupportedSpeed_SIZE sizeof(ULONG)
    #define MSFC_HBAPortAttributesResults_PortSupportedSpeed_ID 9

    // 
    ULONG PortSpeed;
    #define MSFC_HBAPortAttributesResults_PortSpeed_SIZE sizeof(ULONG)
    #define MSFC_HBAPortAttributesResults_PortSpeed_ID 10

    // 
    ULONG PortMaxFrameSize;
    #define MSFC_HBAPortAttributesResults_PortMaxFrameSize_SIZE sizeof(ULONG)
    #define MSFC_HBAPortAttributesResults_PortMaxFrameSize_ID 11

    // 
    UCHAR FabricName[8];
    #define MSFC_HBAPortAttributesResults_FabricName_SIZE sizeof(UCHAR[8])
    #define MSFC_HBAPortAttributesResults_FabricName_ID 12

    // 
    ULONG NumberofDiscoveredPorts;
    #define MSFC_HBAPortAttributesResults_NumberofDiscoveredPorts_SIZE sizeof(ULONG)
    #define MSFC_HBAPortAttributesResults_NumberofDiscoveredPorts_ID 13

    // 
    WCHAR PortSymbolicName[256 + 1];
    #define MSFC_HBAPortAttributesResults_PortSymbolicName_ID 14

    // 
    WCHAR OSDeviceName[256 + 1];
    #define MSFC_HBAPortAttributesResults_OSDeviceName_ID 15

} MSFC_HBAPortAttributesResults, *PMSFC_HBAPortAttributesResults;

// MSFC_FibrePortHBAAttributes - MSFC_FibrePortHBAAttributes
// This class exposes attribute information associated with a Fibre Channel port. There should be one instance of this class for each port.
#define MSFC_FibrePortHBAAttributesGuid \
    { 0x61b397fd,0xf5ae,0x4950, { 0x97,0x58,0x0e,0xe5,0x98,0xe3,0xc6,0xe6 } }

DEFINE_GUID(MSFC_FibrePortHBAAttributes_GUID, \
            0x61b397fd,0xf5ae,0x4950,0x97,0x58,0x0e,0xe5,0x98,0xe3,0xc6,0xe6);


typedef struct _MSFC_FibrePortHBAAttributes
{
    // Unique identifier for the port. This idenitifer must be unique among all ports on all adapters. The same value for the identifier must be used for the same port in other classes that expose port information
    ULONGLONG UniquePortId;
    #define MSFC_FibrePortHBAAttributes_UniquePortId_SIZE sizeof(ULONGLONG)
    #define MSFC_FibrePortHBAAttributes_UniquePortId_ID 1

    // HBA Status result for the query operation
    ULONG HBAStatus;
    #define MSFC_FibrePortHBAAttributes_HBAStatus_SIZE sizeof(ULONG)
    #define MSFC_FibrePortHBAAttributes_HBAStatus_ID 2

    // 
    MSFC_HBAPortAttributesResults Attributes;
    #define MSFC_FibrePortHBAAttributes_Attributes_SIZE sizeof(MSFC_HBAPortAttributesResults)
    #define MSFC_FibrePortHBAAttributes_Attributes_ID 3

} MSFC_FibrePortHBAAttributes, *PMSFC_FibrePortHBAAttributes;

// MSFC_FibrePortHBAMethods - MSFC_FibrePortHBAMethods
// This class exposes operations that can be performed on a Fibre Channel port. There should be one instance of this class for each port.
#define MSFC_FibrePortHBAMethodsGuid \
    { 0xe693553e,0xedf6,0x4d57, { 0xbf,0x08,0xef,0xca,0xae,0x1a,0x2e,0x1c } }

DEFINE_GUID(MSFC_FibrePortHBAMethods_GUID, \
            0xe693553e,0xedf6,0x4d57,0xbf,0x08,0xef,0xca,0xae,0x1a,0x2e,0x1c);

//
// Method id definitions for MSFC_FibrePortHBAMethods
#define ResetStatistics     1

// MSFC_FCAdapterHBAAttributes - MSFC_FCAdapterHBAAttributes
// This class exposes attribute information associated with a fibre channel adapter. There should be one instance of this class for each adapter
#define MSFC_FCAdapterHBAAttributesGuid \
    { 0xf8f3ea26,0xab2c,0x4593, { 0x8b,0x84,0xc5,0x64,0x28,0xe6,0xbe,0xdb } }

DEFINE_GUID(MSFC_FCAdapterHBAAttributes_GUID, \
            0xf8f3ea26,0xab2c,0x4593,0x8b,0x84,0xc5,0x64,0x28,0xe6,0xbe,0xdb);


typedef struct _MSFC_FCAdapterHBAAttributes
{
    // Unique identifier for the adapter. This idenitifer must be unique among all adapters. The same value for the identifier must be used for the same adapter in other classes that expose adapter information
    ULONGLONG UniqueAdapterId;
    #define MSFC_FCAdapterHBAAttributes_UniqueAdapterId_SIZE sizeof(ULONGLONG)
    #define MSFC_FCAdapterHBAAttributes_UniqueAdapterId_ID 1

    // HBA Status result for the query operation
    ULONG HBAStatus;
    #define MSFC_FCAdapterHBAAttributes_HBAStatus_SIZE sizeof(ULONG)
    #define MSFC_FCAdapterHBAAttributes_HBAStatus_ID 2

    // 
    UCHAR NodeWWN[8];
    #define MSFC_FCAdapterHBAAttributes_NodeWWN_SIZE sizeof(UCHAR[8])
    #define MSFC_FCAdapterHBAAttributes_NodeWWN_ID 3

    // 
    ULONG VendorSpecificID;
    #define MSFC_FCAdapterHBAAttributes_VendorSpecificID_SIZE sizeof(ULONG)
    #define MSFC_FCAdapterHBAAttributes_VendorSpecificID_ID 4

    // 
    ULONG NumberOfPorts;
    #define MSFC_FCAdapterHBAAttributes_NumberOfPorts_SIZE sizeof(ULONG)
    #define MSFC_FCAdapterHBAAttributes_NumberOfPorts_ID 5

    // 
    WCHAR Manufacturer[64 + 1];
    #define MSFC_FCAdapterHBAAttributes_Manufacturer_ID 6

    // 
    WCHAR SerialNumber[64 + 1];
    #define MSFC_FCAdapterHBAAttributes_SerialNumber_ID 7

    // 
    WCHAR Model[256 + 1];
    #define MSFC_FCAdapterHBAAttributes_Model_ID 8

    // 
    WCHAR ModelDescription[256 + 1];
    #define MSFC_FCAdapterHBAAttributes_ModelDescription_ID 9

    // 
    WCHAR NodeSymbolicName[256 + 1];
    #define MSFC_FCAdapterHBAAttributes_NodeSymbolicName_ID 10

    // 
    WCHAR HardwareVersion[256 + 1];
    #define MSFC_FCAdapterHBAAttributes_HardwareVersion_ID 11

    // 
    WCHAR DriverVersion[256 + 1];
    #define MSFC_FCAdapterHBAAttributes_DriverVersion_ID 12

    // 
    WCHAR OptionROMVersion[256 + 1];
    #define MSFC_FCAdapterHBAAttributes_OptionROMVersion_ID 13

    // 
    WCHAR FirmwareVersion[256 + 1];
    #define MSFC_FCAdapterHBAAttributes_FirmwareVersion_ID 14

    // 
    WCHAR DriverName[256 + 1];
    #define MSFC_FCAdapterHBAAttributes_DriverName_ID 15

} MSFC_FCAdapterHBAAttributes, *PMSFC_FCAdapterHBAAttributes;

// HBAFC3MgmtInfo - HBAFC3MgmtInfo
// This class exposes FC3 Management information associated with a fibre channel adapter. There should be one instance of this class for each adapter
#define HBAFC3MgmtInfoGuid \
    { 0x5966a24f,0x6aa5,0x418e, { 0xb7,0x5c,0x2f,0x21,0x4d,0xfb,0x4b,0x18 } }

DEFINE_GUID(HBAFC3MgmtInfo_GUID, \
            0x5966a24f,0x6aa5,0x418e,0xb7,0x5c,0x2f,0x21,0x4d,0xfb,0x4b,0x18);


typedef struct _HBAFC3MgmtInfo
{
    // Unique identifier for the adapter. This idenitifer must be unique among all adapters. The same value for the identifier must be used for the same adapter in other classes that expose adapter information
    ULONGLONG UniqueAdapterId;
    #define HBAFC3MgmtInfo_UniqueAdapterId_SIZE sizeof(ULONGLONG)
    #define HBAFC3MgmtInfo_UniqueAdapterId_ID 1

    // 
    UCHAR wwn[8];
    #define HBAFC3MgmtInfo_wwn_SIZE sizeof(UCHAR[8])
    #define HBAFC3MgmtInfo_wwn_ID 2

    // 
    ULONG unittype;
    #define HBAFC3MgmtInfo_unittype_SIZE sizeof(ULONG)
    #define HBAFC3MgmtInfo_unittype_ID 3

    // 
    ULONG PortId;
    #define HBAFC3MgmtInfo_PortId_SIZE sizeof(ULONG)
    #define HBAFC3MgmtInfo_PortId_ID 4

    // 
    ULONG NumberOfAttachedNodes;
    #define HBAFC3MgmtInfo_NumberOfAttachedNodes_SIZE sizeof(ULONG)
    #define HBAFC3MgmtInfo_NumberOfAttachedNodes_ID 5

    // 
    USHORT IPVersion;
    #define HBAFC3MgmtInfo_IPVersion_SIZE sizeof(USHORT)
    #define HBAFC3MgmtInfo_IPVersion_ID 6

    // 
    USHORT UDPPort;
    #define HBAFC3MgmtInfo_UDPPort_SIZE sizeof(USHORT)
    #define HBAFC3MgmtInfo_UDPPort_ID 7

    // 
    UCHAR IPAddress[16];
    #define HBAFC3MgmtInfo_IPAddress_SIZE sizeof(UCHAR[16])
    #define HBAFC3MgmtInfo_IPAddress_ID 8

    // 
    USHORT reserved;
    #define HBAFC3MgmtInfo_reserved_SIZE sizeof(USHORT)
    #define HBAFC3MgmtInfo_reserved_ID 9

    // 
    USHORT TopologyDiscoveryFlags;
    #define HBAFC3MgmtInfo_TopologyDiscoveryFlags_SIZE sizeof(USHORT)
    #define HBAFC3MgmtInfo_TopologyDiscoveryFlags_ID 10

} HBAFC3MgmtInfo, *PHBAFC3MgmtInfo;

// MSFC_HBAPortMethods - MSFC_HBAPortMethods
// This class exposes port discovery operations that can be by a fibre channel adapter. There should be one instance of this class for each adapter
#define MSFC_HBAPortMethodsGuid \
    { 0xdf87d4ed,0x4612,0x4d12, { 0x85,0xfb,0x83,0x57,0x4e,0xc3,0x4b,0x7c } }

DEFINE_GUID(MSFC_HBAPortMethods_GUID, \
            0xdf87d4ed,0x4612,0x4d12,0x85,0xfb,0x83,0x57,0x4e,0xc3,0x4b,0x7c);

//
// Method id definitions for MSFC_HBAPortMethods
#define GetDiscoveredPortAttributes     1
typedef struct _GetDiscoveredPortAttributes_IN
{
    // 
    ULONG PortIndex;
    #define GetDiscoveredPortAttributes_IN_PortIndex_SIZE sizeof(ULONG)
    #define GetDiscoveredPortAttributes_IN_PortIndex_ID 1

    // 
    ULONG DiscoveredPortIndex;
    #define GetDiscoveredPortAttributes_IN_DiscoveredPortIndex_SIZE sizeof(ULONG)
    #define GetDiscoveredPortAttributes_IN_DiscoveredPortIndex_ID 2

} GetDiscoveredPortAttributes_IN, *PGetDiscoveredPortAttributes_IN;

typedef struct _GetDiscoveredPortAttributes_OUT
{
    // HBA Status result for the operation
    ULONG HBAStatus;
    #define GetDiscoveredPortAttributes_OUT_HBAStatus_SIZE sizeof(ULONG)
    #define GetDiscoveredPortAttributes_OUT_HBAStatus_ID 3

    // 
    MSFC_HBAPortAttributesResults PortAttributes;
    #define GetDiscoveredPortAttributes_OUT_PortAttributes_SIZE sizeof(MSFC_HBAPortAttributesResults)
    #define GetDiscoveredPortAttributes_OUT_PortAttributes_ID 4

} GetDiscoveredPortAttributes_OUT, *PGetDiscoveredPortAttributes_OUT;

#define GetPortAttributesByWWN     2
typedef struct _GetPortAttributesByWWN_IN
{
    // 
    UCHAR wwn[8];
    #define GetPortAttributesByWWN_IN_wwn_SIZE sizeof(UCHAR[8])
    #define GetPortAttributesByWWN_IN_wwn_ID 1

} GetPortAttributesByWWN_IN, *PGetPortAttributesByWWN_IN;

typedef struct _GetPortAttributesByWWN_OUT
{
    // HBA Status result for the operation
    ULONG HBAStatus;
    #define GetPortAttributesByWWN_OUT_HBAStatus_SIZE sizeof(ULONG)
    #define GetPortAttributesByWWN_OUT_HBAStatus_ID 2

    // 
    MSFC_HBAPortAttributesResults PortAttributes;
    #define GetPortAttributesByWWN_OUT_PortAttributes_SIZE sizeof(MSFC_HBAPortAttributesResults)
    #define GetPortAttributesByWWN_OUT_PortAttributes_ID 3

} GetPortAttributesByWWN_OUT, *PGetPortAttributesByWWN_OUT;

#define RefreshInformation     3

// MSFC_HBAFc3MgmtMethods - MSFC_HBAFc3MgmtMethods
// This class exposes FC3 management operations that can be done by a fibre channel adapter. There should be one instance of this class for each adapter
#define MSFC_HBAFc3MgmtMethodsGuid \
    { 0x5f339b02,0x881b,0x454c, { 0xb6,0xa0,0xd7,0x34,0x49,0xa6,0x6f,0x0c } }

DEFINE_GUID(MSFC_HBAFc3MgmtMethods_GUID, \
            0x5f339b02,0x881b,0x454c,0xb6,0xa0,0xd7,0x34,0x49,0xa6,0x6f,0x0c);

//
// Method id definitions for MSFC_HBAFc3MgmtMethods
#define SendCTPassThru     1
typedef struct _SendCTPassThru_IN
{
    // 
    ULONG RequestBufferCount;
    #define SendCTPassThru_IN_RequestBufferCount_SIZE sizeof(ULONG)
    #define SendCTPassThru_IN_RequestBufferCount_ID 1

    // 
    UCHAR RequestBuffer[1];
    #define SendCTPassThru_IN_RequestBuffer_ID 2

} SendCTPassThru_IN, *PSendCTPassThru_IN;

typedef struct _SendCTPassThru_OUT
{
    // HBA Status result for the operation
    ULONG HBAStatus;
    #define SendCTPassThru_OUT_HBAStatus_SIZE sizeof(ULONG)
    #define SendCTPassThru_OUT_HBAStatus_ID 3

    // 
    ULONG ResponseBufferCount;
    #define SendCTPassThru_OUT_ResponseBufferCount_SIZE sizeof(ULONG)
    #define SendCTPassThru_OUT_ResponseBufferCount_ID 4

    // 
    UCHAR ResponseBuffer[1];
    #define SendCTPassThru_OUT_ResponseBuffer_ID 5

} SendCTPassThru_OUT, *PSendCTPassThru_OUT;

#define SendRNID     2
typedef struct _SendRNID_IN
{
    // 
    UCHAR wwn[8];
    #define SendRNID_IN_wwn_SIZE sizeof(UCHAR[8])
    #define SendRNID_IN_wwn_ID 1

    // 
    ULONG wwntype;
    #define SendRNID_IN_wwntype_SIZE sizeof(ULONG)
    #define SendRNID_IN_wwntype_ID 2

} SendRNID_IN, *PSendRNID_IN;

typedef struct _SendRNID_OUT
{
    // HBA Status result for the operation
    ULONG HBAStatus;
    #define SendRNID_OUT_HBAStatus_SIZE sizeof(ULONG)
    #define SendRNID_OUT_HBAStatus_ID 3

    // 
    ULONG ResponseBufferCount;
    #define SendRNID_OUT_ResponseBufferCount_SIZE sizeof(ULONG)
    #define SendRNID_OUT_ResponseBufferCount_ID 4

    // 
    UCHAR ResponseBuffer[1];
    #define SendRNID_OUT_ResponseBuffer_ID 5

} SendRNID_OUT, *PSendRNID_OUT;

#define GetFC3MgmtInfo     3
typedef struct _GetFC3MgmtInfo_OUT
{
    // HBA Status result for the operation
    ULONG HBAStatus;
    #define GetFC3MgmtInfo_OUT_HBAStatus_SIZE sizeof(ULONG)
    #define GetFC3MgmtInfo_OUT_HBAStatus_ID 1

    // 
    HBAFC3MgmtInfo MgmtInfo;
    #define GetFC3MgmtInfo_OUT_MgmtInfo_SIZE sizeof(HBAFC3MgmtInfo)
    #define GetFC3MgmtInfo_OUT_MgmtInfo_ID 2

} GetFC3MgmtInfo_OUT, *PGetFC3MgmtInfo_OUT;

#define SetFC3MgmtInfo     4
typedef struct _SetFC3MgmtInfo_IN
{
    // 
    HBAFC3MgmtInfo MgmtInfo;
    #define SetFC3MgmtInfo_IN_MgmtInfo_SIZE sizeof(HBAFC3MgmtInfo)
    #define SetFC3MgmtInfo_IN_MgmtInfo_ID 2

} SetFC3MgmtInfo_IN, *PSetFC3MgmtInfo_IN;

typedef struct _SetFC3MgmtInfo_OUT
{
    // HBA Status result for the operation
    ULONG HBAStatus;
    #define SetFC3MgmtInfo_OUT_HBAStatus_SIZE sizeof(ULONG)
    #define SetFC3MgmtInfo_OUT_HBAStatus_ID 1

} SetFC3MgmtInfo_OUT, *PSetFC3MgmtInfo_OUT;


// HBAScsiID - HBAScsiID
#define HBAScsiIDGuid \
    { 0xa76f5058,0xb1f0,0x4622, { 0x9e,0x88,0x5c,0xc4,0x1e,0x34,0x45,0x4a } }

DEFINE_GUID(HBAScsiID_GUID, \
            0xa76f5058,0xb1f0,0x4622,0x9e,0x88,0x5c,0xc4,0x1e,0x34,0x45,0x4a);


typedef struct _HBAScsiID
{
    // 
    WCHAR OSDeviceName[256 + 1];
    #define HBAScsiID_OSDeviceName_ID 1

    // 
    ULONG ScsiBusNumber;
    #define HBAScsiID_ScsiBusNumber_SIZE sizeof(ULONG)
    #define HBAScsiID_ScsiBusNumber_ID 2

    // 
    ULONG ScsiTargetNumber;
    #define HBAScsiID_ScsiTargetNumber_SIZE sizeof(ULONG)
    #define HBAScsiID_ScsiTargetNumber_ID 3

    // 
    ULONG ScsiOSLun;
    #define HBAScsiID_ScsiOSLun_SIZE sizeof(ULONG)
    #define HBAScsiID_ScsiOSLun_ID 4

} HBAScsiID, *PHBAScsiID;

// HBAFCPID - HBAFCPID
#define HBAFCPIDGuid \
    { 0xff02bc96,0x7fb0,0x4bac, { 0x8f,0x97,0xc7,0x1e,0x49,0x5f,0xa6,0x98 } }

DEFINE_GUID(HBAFCPID_GUID, \
            0xff02bc96,0x7fb0,0x4bac,0x8f,0x97,0xc7,0x1e,0x49,0x5f,0xa6,0x98);


typedef struct _HBAFCPID
{
    // 
    ULONG Fcid;
    #define HBAFCPID_Fcid_SIZE sizeof(ULONG)
    #define HBAFCPID_Fcid_ID 1

    // 
    UCHAR NodeWWN[8];
    #define HBAFCPID_NodeWWN_SIZE sizeof(UCHAR[8])
    #define HBAFCPID_NodeWWN_ID 2

    // 
    UCHAR PortWWN[8];
    #define HBAFCPID_PortWWN_SIZE sizeof(UCHAR[8])
    #define HBAFCPID_PortWWN_ID 3

    // 
    ULONGLONG FcpLun;
    #define HBAFCPID_FcpLun_SIZE sizeof(ULONGLONG)
    #define HBAFCPID_FcpLun_ID 4

} HBAFCPID, *PHBAFCPID;

// HBAFCPScsiEntry - HBAFCPScsiEntry
#define HBAFCPScsiEntryGuid \
    { 0x77ca1248,0x1505,0x4221, { 0x8e,0xb6,0xbb,0xb6,0xec,0x77,0x1a,0x87 } }

DEFINE_GUID(HBAFCPScsiEntry_GUID, \
            0x77ca1248,0x1505,0x4221,0x8e,0xb6,0xbb,0xb6,0xec,0x77,0x1a,0x87);


typedef struct _HBAFCPScsiEntry
{
    // 
    HBAScsiID ScsiId;
    #define HBAFCPScsiEntry_ScsiId_SIZE sizeof(HBAScsiID)
    #define HBAFCPScsiEntry_ScsiId_ID 1

    // 
    HBAFCPID FCPId;
    #define HBAFCPScsiEntry_FCPId_SIZE sizeof(HBAFCPID)
    #define HBAFCPScsiEntry_FCPId_ID 2

} HBAFCPScsiEntry, *PHBAFCPScsiEntry;

// HBAFCPBindingEntry - HBAFCPBindingEntry
#define HBAFCPBindingEntryGuid \
    { 0xfceff8b7,0x9d6b,0x4115, { 0x84,0x22,0x05,0x99,0x24,0x51,0xa6,0x29 } }

DEFINE_GUID(HBAFCPBindingEntry_GUID, \
            0xfceff8b7,0x9d6b,0x4115,0x84,0x22,0x05,0x99,0x24,0x51,0xa6,0x29);


typedef struct _HBAFCPBindingEntry
{
    // 
    ULONG Type;
    #define HBAFCPBindingEntry_Type_SIZE sizeof(ULONG)
    #define HBAFCPBindingEntry_Type_ID 1

    // 
    HBAScsiID ScsiId;
    #define HBAFCPBindingEntry_ScsiId_SIZE sizeof(HBAScsiID)
    #define HBAFCPBindingEntry_ScsiId_ID 2

    // 
    HBAFCPID FCPId;
    #define HBAFCPBindingEntry_FCPId_SIZE sizeof(HBAFCPID)
    #define HBAFCPBindingEntry_FCPId_ID 3

} HBAFCPBindingEntry, *PHBAFCPBindingEntry;

// MSFC_HBAFCPInfo - MSFC_HBAFCPInfo
// This class exposes operations associated with FCP on a Fibre Channel adapter. There should be one instance of this class for each adapter.
#define MSFC_HBAFCPInfoGuid \
    { 0x7a1fc391,0x5b23,0x4c19, { 0xb0,0xeb,0xb1,0xae,0xf5,0x90,0x50,0xc3 } }

DEFINE_GUID(MSFC_HBAFCPInfo_GUID, \
            0x7a1fc391,0x5b23,0x4c19,0xb0,0xeb,0xb1,0xae,0xf5,0x90,0x50,0xc3);

//
// Method id definitions for MSFC_HBAFCPInfo
#define GetFcpTargetMapping     1
typedef struct _GetFcpTargetMapping_OUT
{
    // HBA Status result for the operation
    ULONG HBAStatus;
    #define GetFcpTargetMapping_OUT_HBAStatus_SIZE sizeof(ULONG)
    #define GetFcpTargetMapping_OUT_HBAStatus_ID 1

    // 
    ULONG EntryCount;
    #define GetFcpTargetMapping_OUT_EntryCount_SIZE sizeof(ULONG)
    #define GetFcpTargetMapping_OUT_EntryCount_ID 2

    // 
    HBAFCPScsiEntry Entry[1];
    #define GetFcpTargetMapping_OUT_Entry_ID 3

} GetFcpTargetMapping_OUT, *PGetFcpTargetMapping_OUT;

#define GetFcpPersistentBinding     2
typedef struct _GetFcpPersistentBinding_OUT
{
    // HBA Status result for the operation
    ULONG HBAStatus;
    #define GetFcpPersistentBinding_OUT_HBAStatus_SIZE sizeof(ULONG)
    #define GetFcpPersistentBinding_OUT_HBAStatus_ID 1

    // 
    ULONG EntryCount;
    #define GetFcpPersistentBinding_OUT_EntryCount_SIZE sizeof(ULONG)
    #define GetFcpPersistentBinding_OUT_EntryCount_ID 2

    // 
    HBAFCPBindingEntry Entry[1];
    #define GetFcpPersistentBinding_OUT_Entry_ID 3

} GetFcpPersistentBinding_OUT, *PGetFcpPersistentBinding_OUT;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\ddk\inc\dxapi.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    dxapi.h

Abstract:

    This file defines the necessary structures, defines, and functions for
    the DXAPI class driver.

Author:
    Bill Parry (billpa)

Environment:

   Kernel mode only

Revision History:

--*/

ULONG
DxApi(
            IN ULONG	dwFunctionNum,
            IN PVOID	lpvInBuffer,
            IN ULONG	cbInBuffer,
            IN PVOID	lpvOutBuffer,
            IN ULONG	cbOutBuffer
);

ULONG
DxApiGetVersion(
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\ddk\inc\fltsafe.h ===
// fltsafe.h
//
//      Copyright (c) Microsoft Corporation. All rights reserved.
//

// FLOATSAFE
//
// Saves floating point state on construction and restores on destruction.
//
struct FLOATSAFE
{
    KFLOATING_SAVE     FloatSave;
    NTSTATUS           ntStatus;

    FLOATSAFE::FLOATSAFE(void)
    {
        ntStatus = KeSaveFloatingPointState(&FloatSave);
    }

    FLOATSAFE::~FLOATSAFE(void)
    {
        if (NT_SUCCESS(ntStatus))
        {
            KeRestoreFloatingPointState(&FloatSave);
        }
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\ddk\inc\i2cgpio.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1996 - 1997  Microsoft Corporation.  All Rights Reserved.
//
//@@BEGIN_DDKSPLIT 
//
// WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING 
//
//  The files 
//      \wdm10\ddk\inc\i2cgpio.h
//      \dev\ddk\inc\i2cgpio.h
//  Are the same.
//
//  When changing either file, be sure to update the other file in the other
//  directory. This has been done to ensure that the DirectX DDK can pull
//  I2CGPIO.H into its DDK from \dev\ddk\inc, and not have to enlist in the
//  \wdm10 ddk.
//
//@@END_DDKSPLIT
//==========================================================================;

#if 0
To access the IO functionality in a WDM driver or the VDD, WDM driver sends 
the following IRP to its parent.

MajorFunction = IRP_MJ_PNP;
MinorFunction = IRP_MN_QUERY_INTERFACE;

Guid = DEFINE_GUID( GUID_GPIO_INTERFACE, 
        0x02295e87L, 0xbb3f, 0x11d0, 0x80, 0xce, 0x0, 0x20, 0xaf, 0xf7, 0x49, 0x1e);

The QUERY_INTERFACE Irp will return an interface (set of function pointers)
of the type xxxxINTERFACE, defined below. This is essentially a table of
function pointers.

#endif

#ifndef __I2CGPIO_H__
#define __I2CGPIO_H__

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

// Guids
//
// DEFINE_GUID requires that you include wdm.h before this file.
// #define INITGUID to actually initialize the guid in memory.
//
DEFINE_GUID( GUID_I2C_INTERFACE, 0x02295e86L, 0xbb3f, 0x11d0, 0x80, 0xce, 0x0, 0x20, 0xaf, 0xf7, 0x49, 0x1e);
DEFINE_GUID( GUID_GPIO_INTERFACE,0x02295e87L, 0xbb3f, 0x11d0, 0x80, 0xce, 0x0, 0x20, 0xaf, 0xf7, 0x49, 0x1e);
DEFINE_GUID( GUID_COPYPROTECTION_INTERFACE, 0x02295e88L, 0xbb3f, 0x11d0, 0x80, 0xce, 0x0, 0x20, 0xaf, 0xf7, 0x49, 0x1e);

//==========================================================================;
// used below if neccessary
#ifndef BYTE
#define BYTE UCHAR
#endif
#ifndef DWORD
#define DWORD ULONG
#endif
//==========================================================================;
//
// I2C section
//
// I2C Commands
#define I2C_COMMAND_NULL         0X0000
#define I2C_COMMAND_READ         0X0001
#define I2C_COMMAND_WRITE        0X0002
#define I2C_COMMAND_STATUS       0X0004
#define I2C_COMMAND_RESET        0X0008

// The following flags are provided on a READ or WRITE command
#define I2C_FLAGS_START          0X0001 // START + addx
#define I2C_FLAGS_STOP           0X0002 // STOP
#define I2C_FLAGS_DATACHAINING   0X0004 // STOP, START + addx 
#define I2C_FLAGS_ACK            0X0010 // ACKNOWLEDGE (normally set)

// The following status flags are returned on completion of the operation
#define I2C_STATUS_NOERROR       0X0000  
#define I2C_STATUS_BUSY          0X0001
#define I2C_STATUS_ERROR         0X0002

typedef struct _I2CControl {
        ULONG Command;          // I2C_COMMAND_*
        DWORD dwCookie;         // Context identifier returned on Open
        BYTE  Data;             // Data to write, or returned byte
        BYTE  Reserved[3];      // Filler
        ULONG Flags;            // I2C_FLAGS_*
        ULONG Status;           // I2C_STATUS_*
        ULONG ClockRate;        // Bus clockrate in Hz.
} I2CControl, *PI2CControl;

// this is the Interface definition for I2C
//
typedef NTSTATUS (STDMETHODCALLTYPE *I2COPEN)(PDEVICE_OBJECT, ULONG, PI2CControl);
typedef NTSTATUS (STDMETHODCALLTYPE *I2CACCESS)(PDEVICE_OBJECT, PI2CControl);

typedef struct {
    INTERFACE _vddInterface;
    I2COPEN   i2cOpen;
    I2CACCESS i2cAccess;
} I2CINTERFACE;

//==========================================================================;
//
// GPIO section
//
// GPIO Commands

#define GPIO_COMMAND_QUERY          0X0001      // get #pins and nBufferSize
#define GPIO_COMMAND_OPEN           0X0001      // old open
#define GPIO_COMMAND_OPEN_PINS      0X0002      // get dwCookie
#define GPIO_COMMAND_CLOSE_PINS     0X0004      // invalidate cookie
#define GPIO_COMMAND_READ_BUFFER    0X0008
#define GPIO_COMMAND_WRITE_BUFFER   0X0010

// The following flags are provided on a READ_BUFFER or WRITE_BUFFER command
// lpPins bits set MUST have contiguous bits set for a read/write command.
//
// On a READ, if the number of pins set in the bitmask does not fill a 
// byte/word/dword, then zeros are returned for those positions. 
// on a WRITE, if the number of pins set in the bitmask does not fill a 
// byte/word/dword, a read/modify/write is done on the port/mmio position
// that represents those bits.

#define GPIO_FLAGS_BYTE             0x0001  // do byte read/write
#define GPIO_FLAGS_WORD             0x0002  // do word read/write
#define GPIO_FLAGS_DWORD            0x0004  // do dword read/write

// The following status flags are returned on completion of the operation
#define GPIO_STATUS_NOERROR     0X0000  
#define GPIO_STATUS_BUSY        0X0001
#define GPIO_STATUS_ERROR       0X0002
#define GPIO_STATUS_NO_ASYNCH   0X0004  // gpio provider does not do asynch xfer

typedef struct _GPIOControl {
    ULONG Command;          // GPIO_COMMAND_*
    ULONG Flags;            // GPIO_FLAGS_*
    DWORD dwCookie;         // Context identifier returned on Open
    ULONG Status;           // GPIO_STATUS_*
    ULONG nBytes;           // # of bytes to send or recieved
    ULONG nBufferSize;      // max size of buffer
    ULONG nPins;            // number of GPIO pins returned by Open
    UCHAR *Pins;            // pointer to bitmask of pins to read/write
    UCHAR *Buffer;          // pointer to GPIO data to send/recieve
    void  (*AsynchCompleteCallback)(UCHAR *Buffer);
                            // NULL if synchronous xfer, valid ptr if asynch.
    GUID  PrivateInterfaceType;
    void  (*PrivateInterface)();
    
} GPIOControl, *PGPIOControl;

// This is the GPIO interface
//
typedef NTSTATUS (STDMETHODCALLTYPE *GPIOOPEN)(PDEVICE_OBJECT, ULONG, PGPIOControl);
typedef NTSTATUS (STDMETHODCALLTYPE *GPIOACCESS)(PDEVICE_OBJECT, PGPIOControl);

typedef struct {
    INTERFACE _vddInterface;
    GPIOOPEN   gpioOpen;
    GPIOACCESS gpioAccess;
} GPIOINTERFACE;

//==========================================================================;
#ifdef    __cplusplus
}
#endif // __cplusplus

#endif //__I2CGPIO_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\ddk\inc\ia64reg.h ===
#ifndef _IA64REG_
#define _IA64REG_
#if _MSC_VER > 1000
#pragma once
#endif


typedef enum IA64_REG_INDEX {              // Intel-IA64-Filler

    //
    // Register set for Intel IA64              // Intel-IA64-Filler
    //


    // Branch Registers              // Intel-IA64-Filler

    CV_IA64_BrRp     =   512,              // Intel-IA64-Filler
    CV_IA64_BrS0     =   513,              // Intel-IA64-Filler
    CV_IA64_BrS1     =   514,              // Intel-IA64-Filler
    CV_IA64_BrS2     =   515,              // Intel-IA64-Filler
    CV_IA64_BrS3     =   516,              // Intel-IA64-Filler
    CV_IA64_BrS4     =   517,              // Intel-IA64-Filler
    CV_IA64_BrT0     =   518,              // Intel-IA64-Filler
    CV_IA64_BrT1     =   519,              // Intel-IA64-Filler

    // Predicate Registers              // Intel-IA64-Filler

    CV_IA64_Preds     =   768,              // Intel-IA64-Filler

    // Banked General Registers              // Intel-IA64-Filler

    CV_IA64_IntH0    =   832,              // Intel-IA64-Filler
    CV_IA64_IntH1    =   833,              // Intel-IA64-Filler
    CV_IA64_IntH2    =   834,              // Intel-IA64-Filler
    CV_IA64_IntH3    =   835,              // Intel-IA64-Filler
    CV_IA64_IntH4    =   836,              // Intel-IA64-Filler
    CV_IA64_IntH5    =   837,              // Intel-IA64-Filler
    CV_IA64_IntH6    =   838,              // Intel-IA64-Filler
    CV_IA64_IntH7    =   839,              // Intel-IA64-Filler
    CV_IA64_IntH8    =   840,              // Intel-IA64-Filler
    CV_IA64_IntH9    =   841,              // Intel-IA64-Filler
    CV_IA64_IntH10    =   842,              // Intel-IA64-Filler
    CV_IA64_IntH11    =   843,              // Intel-IA64-Filler
    CV_IA64_IntH12    =   844,              // Intel-IA64-Filler
    CV_IA64_IntH13    =   845,              // Intel-IA64-Filler
    CV_IA64_IntH14    =   846,              // Intel-IA64-Filler
    CV_IA64_IntH15    =   847,              // Intel-IA64-Filler

    // Special Registers              // Intel-IA64-Filler

    CV_IA64_Ip     =   1016,              // Intel-IA64-Filler
    CV_IA64_Umask  =   1017,              // Intel-IA64-Filler
    CV_IA64_Cfm    =   1018,              // Intel-IA64-Filler
    CV_IA64_Psr    =   1019,              // Intel-IA64-Filler

    // Banked General Registers              // Intel-IA64-Filler

    CV_IA64_Nats     =   1020,              // Intel-IA64-Filler
    CV_IA64_Nats2    =   1021,              // Intel-IA64-Filler
    CV_IA64_Nats3    =   1022,              // Intel-IA64-Filler

    // General-Purpose Registers              // Intel-IA64-Filler

    // INTEGER REGISTER              // Intel-IA64-Filler
    CV_IA64_IntZero  =   1024,              // Intel-IA64-Filler
    CV_IA64_IntGp    =   1025,              // Intel-IA64-Filler
    CV_IA64_IntT0    =   1026,              // Intel-IA64-Filler
    CV_IA64_IntT1    =   1027,              // Intel-IA64-Filler
    CV_IA64_IntS0    =   1028,              // Intel-IA64-Filler
    CV_IA64_IntS1    =   1029,              // Intel-IA64-Filler
    CV_IA64_IntS2    =   1030,              // Intel-IA64-Filler
    CV_IA64_IntS3    =   1031,              // Intel-IA64-Filler
    CV_IA64_IntV0    =   1032,              // Intel-IA64-Filler
    CV_IA64_IntAp    =   1033,              // Intel-IA64-Filler
    CV_IA64_IntT2    =   1034,              // Intel-IA64-Filler
    CV_IA64_IntT3    =   1035,              // Intel-IA64-Filler
    CV_IA64_IntSp    =   1036,              // Intel-IA64-Filler
    CV_IA64_IntT4    =   1037,              // Intel-IA64-Filler
    CV_IA64_IntT5    =   1038,              // Intel-IA64-Filler
    CV_IA64_IntT6    =   1039,              // Intel-IA64-Filler
    CV_IA64_IntT7    =   1040,              // Intel-IA64-Filler
    CV_IA64_IntT8    =   1041,              // Intel-IA64-Filler
    CV_IA64_IntT9    =   1042,              // Intel-IA64-Filler
    CV_IA64_IntT10   =   1043,              // Intel-IA64-Filler
    CV_IA64_IntT11   =   1044,              // Intel-IA64-Filler
    CV_IA64_IntT12   =   1045,              // Intel-IA64-Filler
    CV_IA64_IntT13   =   1046,              // Intel-IA64-Filler
    CV_IA64_IntT14   =   1047,              // Intel-IA64-Filler
    CV_IA64_IntT15   =   1048,              // Intel-IA64-Filler
    CV_IA64_IntT16   =   1049,              // Intel-IA64-Filler
    CV_IA64_IntT17   =   1050,              // Intel-IA64-Filler
    CV_IA64_IntT18   =   1051,              // Intel-IA64-Filler
    CV_IA64_IntT19   =   1052,              // Intel-IA64-Filler
    CV_IA64_IntT20   =   1053,              // Intel-IA64-Filler
    CV_IA64_IntT21   =   1054,              // Intel-IA64-Filler
    CV_IA64_IntT22   =   1055,              // Intel-IA64-Filler

    // Register Stack              // Intel-IA64-Filler
    CV_IA64_IntR32   =   1056,              // Intel-IA64-Filler
    CV_IA64_IntR33   =   1057,              // Intel-IA64-Filler
    CV_IA64_IntR34   =   1058,              // Intel-IA64-Filler
    CV_IA64_IntR35   =   1059,              // Intel-IA64-Filler
    CV_IA64_IntR36   =   1060,              // Intel-IA64-Filler
    CV_IA64_IntR37   =   1061,              // Intel-IA64-Filler
    CV_IA64_IntR38   =   1062,              // Intel-IA64-Filler
    CV_IA64_IntR39   =   1063,              // Intel-IA64-Filler
    CV_IA64_IntR40   =   1064,              // Intel-IA64-Filler
    CV_IA64_IntR41   =   1065,              // Intel-IA64-Filler
    CV_IA64_IntR42   =   1066,              // Intel-IA64-Filler
    CV_IA64_IntR43   =   1067,              // Intel-IA64-Filler
    CV_IA64_IntR44   =   1068,              // Intel-IA64-Filler
    CV_IA64_IntR45   =   1069,              // Intel-IA64-Filler
    CV_IA64_IntR46   =   1070,              // Intel-IA64-Filler
    CV_IA64_IntR47   =   1071,              // Intel-IA64-Filler
    CV_IA64_IntR48   =   1072,              // Intel-IA64-Filler
    CV_IA64_IntR49   =   1073,              // Intel-IA64-Filler
    CV_IA64_IntR50   =   1074,              // Intel-IA64-Filler
    CV_IA64_IntR51   =   1075,              // Intel-IA64-Filler
    CV_IA64_IntR52   =   1076,              // Intel-IA64-Filler
    CV_IA64_IntR53   =   1077,              // Intel-IA64-Filler
    CV_IA64_IntR54   =   1078,              // Intel-IA64-Filler
    CV_IA64_IntR55   =   1079,              // Intel-IA64-Filler
    CV_IA64_IntR56   =   1080,              // Intel-IA64-Filler
    CV_IA64_IntR57   =   1081,              // Intel-IA64-Filler
    CV_IA64_IntR58   =   1082,              // Intel-IA64-Filler
    CV_IA64_IntR59   =   1083,              // Intel-IA64-Filler
    CV_IA64_IntR60   =   1084,              // Intel-IA64-Filler
    CV_IA64_IntR61   =   1085,              // Intel-IA64-Filler
    CV_IA64_IntR62   =   1086,              // Intel-IA64-Filler
    CV_IA64_IntR63   =   1087,              // Intel-IA64-Filler
    CV_IA64_IntR64   =   1088,              // Intel-IA64-Filler
    CV_IA64_IntR65   =   1089,              // Intel-IA64-Filler
    CV_IA64_IntR66   =   1090,              // Intel-IA64-Filler
    CV_IA64_IntR67   =   1091,              // Intel-IA64-Filler
    CV_IA64_IntR68   =   1092,              // Intel-IA64-Filler
    CV_IA64_IntR69   =   1093,              // Intel-IA64-Filler
    CV_IA64_IntR70   =   1094,              // Intel-IA64-Filler
    CV_IA64_IntR71   =   1095,              // Intel-IA64-Filler
    CV_IA64_IntR72   =   1096,              // Intel-IA64-Filler
    CV_IA64_IntR73   =   1097,              // Intel-IA64-Filler
    CV_IA64_IntR74   =   1098,              // Intel-IA64-Filler
    CV_IA64_IntR75   =   1099,              // Intel-IA64-Filler
    CV_IA64_IntR76   =   1100,              // Intel-IA64-Filler
    CV_IA64_IntR77   =   1101,              // Intel-IA64-Filler
    CV_IA64_IntR78   =   1102,              // Intel-IA64-Filler
    CV_IA64_IntR79   =   1103,              // Intel-IA64-Filler
    CV_IA64_IntR80   =   1104,              // Intel-IA64-Filler
    CV_IA64_IntR81   =   1105,              // Intel-IA64-Filler
    CV_IA64_IntR82   =   1106,              // Intel-IA64-Filler
    CV_IA64_IntR83   =   1107,              // Intel-IA64-Filler
    CV_IA64_IntR84   =   1108,              // Intel-IA64-Filler
    CV_IA64_IntR85   =   1109,              // Intel-IA64-Filler
    CV_IA64_IntR86   =   1110,              // Intel-IA64-Filler
    CV_IA64_IntR87   =   1111,              // Intel-IA64-Filler
    CV_IA64_IntR88   =   1112,              // Intel-IA64-Filler
    CV_IA64_IntR89   =   1113,              // Intel-IA64-Filler
    CV_IA64_IntR90   =   1114,              // Intel-IA64-Filler
    CV_IA64_IntR91   =   1115,              // Intel-IA64-Filler
    CV_IA64_IntR92   =   1116,              // Intel-IA64-Filler
    CV_IA64_IntR93   =   1117,              // Intel-IA64-Filler
    CV_IA64_IntR94   =   1118,              // Intel-IA64-Filler
    CV_IA64_IntR95   =   1119,              // Intel-IA64-Filler
    CV_IA64_IntR96   =   1120,              // Intel-IA64-Filler
    CV_IA64_IntR97   =   1121,              // Intel-IA64-Filler
    CV_IA64_IntR98   =   1122,              // Intel-IA64-Filler
    CV_IA64_IntR99   =   1123,              // Intel-IA64-Filler
    CV_IA64_IntR100   =   1124,              // Intel-IA64-Filler
    CV_IA64_IntR101   =   1125,              // Intel-IA64-Filler
    CV_IA64_IntR102   =   1126,              // Intel-IA64-Filler
    CV_IA64_IntR103   =   1127,              // Intel-IA64-Filler
    CV_IA64_IntR104   =   1128,              // Intel-IA64-Filler
    CV_IA64_IntR105   =   1129,              // Intel-IA64-Filler
    CV_IA64_IntR106   =   1130,              // Intel-IA64-Filler
    CV_IA64_IntR107   =   1131,              // Intel-IA64-Filler
    CV_IA64_IntR108   =   1132,              // Intel-IA64-Filler
    CV_IA64_IntR109   =   1133,              // Intel-IA64-Filler
    CV_IA64_IntR110   =   1134,              // Intel-IA64-Filler
    CV_IA64_IntR111   =   1135,              // Intel-IA64-Filler
    CV_IA64_IntR112   =   1136,              // Intel-IA64-Filler
    CV_IA64_IntR113   =   1137,              // Intel-IA64-Filler
    CV_IA64_IntR114   =   1138,              // Intel-IA64-Filler
    CV_IA64_IntR115   =   1139,              // Intel-IA64-Filler
    CV_IA64_IntR116   =   1140,              // Intel-IA64-Filler
    CV_IA64_IntR117   =   1141,              // Intel-IA64-Filler
    CV_IA64_IntR118   =   1142,              // Intel-IA64-Filler
    CV_IA64_IntR119   =   1143,              // Intel-IA64-Filler
    CV_IA64_IntR120   =   1144,              // Intel-IA64-Filler
    CV_IA64_IntR121   =   1145,              // Intel-IA64-Filler
    CV_IA64_IntR122   =   1146,              // Intel-IA64-Filler
    CV_IA64_IntR123   =   1147,              // Intel-IA64-Filler
    CV_IA64_IntR124   =   1148,              // Intel-IA64-Filler
    CV_IA64_IntR125   =   1149,              // Intel-IA64-Filler
    CV_IA64_IntR126   =   1150,              // Intel-IA64-Filler
    CV_IA64_IntR127   =   1151,              // Intel-IA64-Filler

    // Floating-Point Registers              // Intel-IA64-Filler

    // Low Floating Point Registers              // Intel-IA64-Filler
    CV_IA64_FltZero  =   2048,              // Intel-IA64-Filler
    CV_IA64_FltOne   =   2049,              // Intel-IA64-Filler
    CV_IA64_FltS0    =   2050,              // Intel-IA64-Filler
    CV_IA64_FltS1    =   2051,              // Intel-IA64-Filler
    CV_IA64_FltS2    =   2052,              // Intel-IA64-Filler
    CV_IA64_FltS3    =   2053,              // Intel-IA64-Filler
    CV_IA64_FltT0    =   2054,              // Intel-IA64-Filler
    CV_IA64_FltT1    =   2055,              // Intel-IA64-Filler
    CV_IA64_FltT2    =   2056,              // Intel-IA64-Filler
    CV_IA64_FltT3    =   2057,              // Intel-IA64-Filler
    CV_IA64_FltT4    =   2058,              // Intel-IA64-Filler
    CV_IA64_FltT5    =   2059,              // Intel-IA64-Filler
    CV_IA64_FltT6    =   2060,              // Intel-IA64-Filler
    CV_IA64_FltT7    =   2061,              // Intel-IA64-Filler
    CV_IA64_FltT8    =   2062,              // Intel-IA64-Filler
    CV_IA64_FltT9    =   2063,              // Intel-IA64-Filler
    CV_IA64_FltS4    =   2064,              // Intel-IA64-Filler
    CV_IA64_FltS5    =   2065,              // Intel-IA64-Filler
    CV_IA64_FltS6    =   2066,              // Intel-IA64-Filler
    CV_IA64_FltS7    =   2067,              // Intel-IA64-Filler
    CV_IA64_FltS8    =   2068,              // Intel-IA64-Filler
    CV_IA64_FltS9    =   2069,              // Intel-IA64-Filler
    CV_IA64_FltS10   =   2070,              // Intel-IA64-Filler
    CV_IA64_FltS11   =   2071,              // Intel-IA64-Filler
    CV_IA64_FltS12   =   2072,              // Intel-IA64-Filler
    CV_IA64_FltS13   =   2073,              // Intel-IA64-Filler
    CV_IA64_FltS14   =   2074,              // Intel-IA64-Filler
    CV_IA64_FltS15   =   2075,              // Intel-IA64-Filler
    CV_IA64_FltS16   =   2076,              // Intel-IA64-Filler
    CV_IA64_FltS17   =   2077,              // Intel-IA64-Filler
    CV_IA64_FltS18   =   2078,              // Intel-IA64-Filler
    CV_IA64_FltS19   =   2079,              // Intel-IA64-Filler

    // High Floating Point Registers              // Intel-IA64-Filler
    CV_IA64_FltF32   =   2080,              // Intel-IA64-Filler
    CV_IA64_FltF33   =   2081,              // Intel-IA64-Filler
    CV_IA64_FltF34   =   2082,              // Intel-IA64-Filler
    CV_IA64_FltF35   =   2083,              // Intel-IA64-Filler
    CV_IA64_FltF36   =   2084,              // Intel-IA64-Filler
    CV_IA64_FltF37   =   2085,              // Intel-IA64-Filler
    CV_IA64_FltF38   =   2086,              // Intel-IA64-Filler
    CV_IA64_FltF39   =   2087,              // Intel-IA64-Filler
    CV_IA64_FltF40   =   2088,              // Intel-IA64-Filler
    CV_IA64_FltF41   =   2089,              // Intel-IA64-Filler
    CV_IA64_FltF42   =   2090,              // Intel-IA64-Filler
    CV_IA64_FltF43   =   2091,              // Intel-IA64-Filler
    CV_IA64_FltF44   =   2092,              // Intel-IA64-Filler
    CV_IA64_FltF45   =   2093,              // Intel-IA64-Filler
    CV_IA64_FltF46   =   2094,              // Intel-IA64-Filler
    CV_IA64_FltF47   =   2095,              // Intel-IA64-Filler
    CV_IA64_FltF48   =   2096,              // Intel-IA64-Filler
    CV_IA64_FltF49   =   2097,              // Intel-IA64-Filler
    CV_IA64_FltF50   =   2098,              // Intel-IA64-Filler
    CV_IA64_FltF51   =   2099,              // Intel-IA64-Filler
    CV_IA64_FltF52   =   2100,              // Intel-IA64-Filler
    CV_IA64_FltF53   =   2101,              // Intel-IA64-Filler
    CV_IA64_FltF54   =   2102,              // Intel-IA64-Filler
    CV_IA64_FltF55   =   2103,              // Intel-IA64-Filler
    CV_IA64_FltF56   =   2104,              // Intel-IA64-Filler
    CV_IA64_FltF57   =   2105,              // Intel-IA64-Filler
    CV_IA64_FltF58   =   2106,              // Intel-IA64-Filler
    CV_IA64_FltF59   =   2107,              // Intel-IA64-Filler
    CV_IA64_FltF60   =   2108,              // Intel-IA64-Filler
    CV_IA64_FltF61   =   2109,              // Intel-IA64-Filler
    CV_IA64_FltF62   =   2110,              // Intel-IA64-Filler
    CV_IA64_FltF63   =   2111,              // Intel-IA64-Filler
    CV_IA64_FltF64   =   2112,              // Intel-IA64-Filler
    CV_IA64_FltF65   =   2113,              // Intel-IA64-Filler
    CV_IA64_FltF66   =   2114,              // Intel-IA64-Filler
    CV_IA64_FltF67   =   2115,              // Intel-IA64-Filler
    CV_IA64_FltF68   =   2116,              // Intel-IA64-Filler
    CV_IA64_FltF69   =   2117,              // Intel-IA64-Filler
    CV_IA64_FltF70   =   2118,              // Intel-IA64-Filler
    CV_IA64_FltF71   =   2119,              // Intel-IA64-Filler
    CV_IA64_FltF72   =   2120,              // Intel-IA64-Filler
    CV_IA64_FltF73   =   2121,              // Intel-IA64-Filler
    CV_IA64_FltF74   =   2122,              // Intel-IA64-Filler
    CV_IA64_FltF75   =   2123,              // Intel-IA64-Filler
    CV_IA64_FltF76   =   2124,              // Intel-IA64-Filler
    CV_IA64_FltF77   =   2125,              // Intel-IA64-Filler
    CV_IA64_FltF78   =   2126,              // Intel-IA64-Filler
    CV_IA64_FltF79   =   2127,              // Intel-IA64-Filler
    CV_IA64_FltF80   =   2128,              // Intel-IA64-Filler
    CV_IA64_FltF81   =   2129,              // Intel-IA64-Filler
    CV_IA64_FltF82   =   2130,              // Intel-IA64-Filler
    CV_IA64_FltF83   =   2131,              // Intel-IA64-Filler
    CV_IA64_FltF84   =   2132,              // Intel-IA64-Filler
    CV_IA64_FltF85   =   2133,              // Intel-IA64-Filler
    CV_IA64_FltF86   =   2134,              // Intel-IA64-Filler
    CV_IA64_FltF87   =   2135,              // Intel-IA64-Filler
    CV_IA64_FltF88   =   2136,              // Intel-IA64-Filler
    CV_IA64_FltF89   =   2137,              // Intel-IA64-Filler
    CV_IA64_FltF90   =   2138,              // Intel-IA64-Filler
    CV_IA64_FltF91   =   2139,              // Intel-IA64-Filler
    CV_IA64_FltF92   =   2140,              // Intel-IA64-Filler
    CV_IA64_FltF93   =   2141,              // Intel-IA64-Filler
    CV_IA64_FltF94   =   2142,              // Intel-IA64-Filler
    CV_IA64_FltF95   =   2143,              // Intel-IA64-Filler
    CV_IA64_FltF96   =   2144,              // Intel-IA64-Filler
    CV_IA64_FltF97   =   2145,              // Intel-IA64-Filler
    CV_IA64_FltF98   =   2146,              // Intel-IA64-Filler
    CV_IA64_FltF99   =   2147,              // Intel-IA64-Filler
    CV_IA64_FltF100   =   2148,              // Intel-IA64-Filler
    CV_IA64_FltF101   =   2149,              // Intel-IA64-Filler
    CV_IA64_FltF102   =   2150,              // Intel-IA64-Filler
    CV_IA64_FltF103   =   2151,              // Intel-IA64-Filler
    CV_IA64_FltF104   =   2152,              // Intel-IA64-Filler
    CV_IA64_FltF105   =   2153,              // Intel-IA64-Filler
    CV_IA64_FltF106   =   2154,              // Intel-IA64-Filler
    CV_IA64_FltF107   =   2155,              // Intel-IA64-Filler
    CV_IA64_FltF108   =   2156,              // Intel-IA64-Filler
    CV_IA64_FltF109   =   2157,              // Intel-IA64-Filler
    CV_IA64_FltF110   =   2158,              // Intel-IA64-Filler
    CV_IA64_FltF111   =   2159,              // Intel-IA64-Filler
    CV_IA64_FltF112   =   2160,              // Intel-IA64-Filler
    CV_IA64_FltF113   =   2161,              // Intel-IA64-Filler
    CV_IA64_FltF114   =   2162,              // Intel-IA64-Filler
    CV_IA64_FltF115   =   2163,              // Intel-IA64-Filler
    CV_IA64_FltF116   =   2164,              // Intel-IA64-Filler
    CV_IA64_FltF117   =   2165,              // Intel-IA64-Filler
    CV_IA64_FltF118   =   2166,              // Intel-IA64-Filler
    CV_IA64_FltF119   =   2167,              // Intel-IA64-Filler
    CV_IA64_FltF120   =   2168,              // Intel-IA64-Filler
    CV_IA64_FltF121   =   2169,              // Intel-IA64-Filler
    CV_IA64_FltF122   =   2170,              // Intel-IA64-Filler
    CV_IA64_FltF123   =   2171,              // Intel-IA64-Filler
    CV_IA64_FltF124   =   2172,              // Intel-IA64-Filler
    CV_IA64_FltF125   =   2173,              // Intel-IA64-Filler
    CV_IA64_FltF126   =   2174,              // Intel-IA64-Filler
    CV_IA64_FltF127   =   2175,              // Intel-IA64-Filler

    // Application Registers              // Intel-IA64-Filler

    CV_IA64_ApKR0    =   3072,              // Intel-IA64-Filler
    CV_IA64_ApKR1    =   3073,              // Intel-IA64-Filler
    CV_IA64_ApKR2    =   3074,              // Intel-IA64-Filler
    CV_IA64_ApKR3    =   3075,              // Intel-IA64-Filler
    CV_IA64_ApKR4    =   3076,              // Intel-IA64-Filler
    CV_IA64_ApKR5    =   3077,              // Intel-IA64-Filler
    CV_IA64_ApKR6    =   3078,              // Intel-IA64-Filler
    CV_IA64_ApKR7    =   3079,              // Intel-IA64-Filler
    CV_IA64_AR8      =   3080,              // Intel-IA64-Filler
    CV_IA64_AR9      =   3081,              // Intel-IA64-Filler
    CV_IA64_AR10     =   3082,              // Intel-IA64-Filler
    CV_IA64_AR11     =   3083,              // Intel-IA64-Filler
    CV_IA64_AR12     =   3084,              // Intel-IA64-Filler
    CV_IA64_AR13     =   3085,              // Intel-IA64-Filler
    CV_IA64_AR14     =   3086,              // Intel-IA64-Filler
    CV_IA64_AR15     =   3087,              // Intel-IA64-Filler
    CV_IA64_RsRSC    =   3088,              // Intel-IA64-Filler
    CV_IA64_RsBSP    =   3089,              // Intel-IA64-Filler
    CV_IA64_RsBSPSTORE =   3090,              // Intel-IA64-Filler
    CV_IA64_RsRNAT   =   3091,              // Intel-IA64-Filler
    CV_IA64_AR20     =   3092,              // Intel-IA64-Filler
    CV_IA64_AR21     =   3093,              // Intel-IA64-Filler
    CV_IA64_AR22     =   3094,              // Intel-IA64-Filler
    CV_IA64_AR23     =   3095,              // Intel-IA64-Filler
    CV_IA64_AR24     =   3096,              // Intel-IA64-Filler
    CV_IA64_AR25     =   3097,              // Intel-IA64-Filler
    CV_IA64_AR26     =   3098,              // Intel-IA64-Filler
    CV_IA64_AR27     =   3099,              // Intel-IA64-Filler
    CV_IA64_AR28     =   3100,              // Intel-IA64-Filler
    CV_IA64_AR29     =   3101,              // Intel-IA64-Filler
    CV_IA64_AR30     =   3102,              // Intel-IA64-Filler
    CV_IA64_AR31     =   3103,              // Intel-IA64-Filler
    CV_IA64_ApCCV    =   3104,              // Intel-IA64-Filler
    CV_IA64_AR33     =   3105,              // Intel-IA64-Filler
    CV_IA64_AR34     =   3106,              // Intel-IA64-Filler
    CV_IA64_AR35     =   3107,              // Intel-IA64-Filler
    CV_IA64_ApUNAT   =   3108,              // Intel-IA64-Filler
    CV_IA64_AR37     =   3109,              // Intel-IA64-Filler
    CV_IA64_AR38     =   3110,              // Intel-IA64-Filler
    CV_IA64_AR39     =   3111,              // Intel-IA64-Filler
    CV_IA64_StFPSR   =   3112,              // Intel-IA64-Filler
    CV_IA64_AR41     =   3113,              // Intel-IA64-Filler
    CV_IA64_AR42     =   3114,              // Intel-IA64-Filler
    CV_IA64_AR43     =   3115,              // Intel-IA64-Filler
    CV_IA64_ApITC    =   3116,              // Intel-IA64-Filler
    CV_IA64_AR45     =   3117,              // Intel-IA64-Filler
    CV_IA64_AR46     =   3118,              // Intel-IA64-Filler
    CV_IA64_AR47     =   3119,              // Intel-IA64-Filler
    CV_IA64_AR48     =   3120,              // Intel-IA64-Filler
    CV_IA64_AR49     =   3121,              // Intel-IA64-Filler
    CV_IA64_AR50     =   3122,              // Intel-IA64-Filler
    CV_IA64_AR51     =   3123,              // Intel-IA64-Filler
    CV_IA64_AR52     =   3124,              // Intel-IA64-Filler
    CV_IA64_AR53     =   3125,              // Intel-IA64-Filler
    CV_IA64_AR54     =   3126,              // Intel-IA64-Filler
    CV_IA64_AR55     =   3127,              // Intel-IA64-Filler
    CV_IA64_AR56     =   3128,              // Intel-IA64-Filler
    CV_IA64_AR57     =   3129,              // Intel-IA64-Filler
    CV_IA64_AR58     =   3130,              // Intel-IA64-Filler
    CV_IA64_AR59     =   3131,              // Intel-IA64-Filler
    CV_IA64_AR60     =   3132,              // Intel-IA64-Filler
    CV_IA64_AR61     =   3133,              // Intel-IA64-Filler
    CV_IA64_AR62     =   3134,              // Intel-IA64-Filler
    CV_IA64_AR63     =   3135,              // Intel-IA64-Filler
    CV_IA64_RsPFS    =   3136,              // Intel-IA64-Filler
    CV_IA64_ApLC     =   3137,              // Intel-IA64-Filler
    CV_IA64_ApEC     =   3138,              // Intel-IA64-Filler
    CV_IA64_AR67   =   3139,              // Intel-IA64-Filler
    CV_IA64_AR68   =   3140,              // Intel-IA64-Filler
    CV_IA64_AR69   =   3141,              // Intel-IA64-Filler
    CV_IA64_AR70   =   3142,              // Intel-IA64-Filler
    CV_IA64_AR71   =   3143,              // Intel-IA64-Filler
    CV_IA64_AR72   =   3144,              // Intel-IA64-Filler
    CV_IA64_AR73   =   3145,              // Intel-IA64-Filler
    CV_IA64_AR74   =   3146,              // Intel-IA64-Filler
    CV_IA64_AR75   =   3147,              // Intel-IA64-Filler
    CV_IA64_AR76   =   3148,              // Intel-IA64-Filler
    CV_IA64_AR77   =   3149,              // Intel-IA64-Filler
    CV_IA64_AR78   =   3150,              // Intel-IA64-Filler
    CV_IA64_AR79   =   3151,              // Intel-IA64-Filler
    CV_IA64_AR80   =   3152,              // Intel-IA64-Filler
    CV_IA64_AR81   =   3153,              // Intel-IA64-Filler
    CV_IA64_AR82   =   3154,              // Intel-IA64-Filler
    CV_IA64_AR83   =   3155,              // Intel-IA64-Filler
    CV_IA64_AR84   =   3156,              // Intel-IA64-Filler
    CV_IA64_AR85   =   3157,              // Intel-IA64-Filler
    CV_IA64_AR86   =   3158,              // Intel-IA64-Filler
    CV_IA64_AR87   =   3159,              // Intel-IA64-Filler
    CV_IA64_AR88   =   3160,              // Intel-IA64-Filler
    CV_IA64_AR89   =   3161,              // Intel-IA64-Filler
    CV_IA64_AR90   =   3162,              // Intel-IA64-Filler
    CV_IA64_AR91   =   3163,              // Intel-IA64-Filler
    CV_IA64_AR92   =   3164,              // Intel-IA64-Filler
    CV_IA64_AR93   =   3165,              // Intel-IA64-Filler
    CV_IA64_AR94   =   3166,              // Intel-IA64-Filler
    CV_IA64_AR95   =   3167,              // Intel-IA64-Filler
    CV_IA64_AR96   =   3168,              // Intel-IA64-Filler
    CV_IA64_AR97   =   3169,              // Intel-IA64-Filler
    CV_IA64_AR98   =   3170,              // Intel-IA64-Filler
    CV_IA64_AR99   =   3171,              // Intel-IA64-Filler
    CV_IA64_AR100   =   3172,              // Intel-IA64-Filler
    CV_IA64_AR101   =   3173,              // Intel-IA64-Filler
    CV_IA64_AR102   =   3174,              // Intel-IA64-Filler
    CV_IA64_AR103   =   3175,              // Intel-IA64-Filler
    CV_IA64_AR104   =   3176,              // Intel-IA64-Filler
    CV_IA64_AR105   =   3177,              // Intel-IA64-Filler
    CV_IA64_AR106   =   3178,              // Intel-IA64-Filler
    CV_IA64_AR107   =   3179,              // Intel-IA64-Filler
    CV_IA64_AR108   =   3180,              // Intel-IA64-Filler
    CV_IA64_AR109   =   3181,              // Intel-IA64-Filler
    CV_IA64_AR110   =   3182,              // Intel-IA64-Filler
    CV_IA64_AR111   =   3183,              // Intel-IA64-Filler
    CV_IA64_AR112   =   3184,              // Intel-IA64-Filler
    CV_IA64_AR113   =   3185,              // Intel-IA64-Filler
    CV_IA64_AR114   =   3186,              // Intel-IA64-Filler
    CV_IA64_AR115   =   3187,              // Intel-IA64-Filler
    CV_IA64_AR116   =   3188,              // Intel-IA64-Filler
    CV_IA64_AR117   =   3189,              // Intel-IA64-Filler
    CV_IA64_AR118   =   3190,              // Intel-IA64-Filler
    CV_IA64_AR119   =   3191,              // Intel-IA64-Filler
    CV_IA64_AR120   =   3192,              // Intel-IA64-Filler
    CV_IA64_AR121   =   3193,              // Intel-IA64-Filler
    CV_IA64_AR122   =   3194,              // Intel-IA64-Filler
    CV_IA64_AR123   =   3195,              // Intel-IA64-Filler
    CV_IA64_AR124   =   3196,              // Intel-IA64-Filler
    CV_IA64_AR125   =   3197,              // Intel-IA64-Filler
    CV_IA64_AR126   =   3198,              // Intel-IA64-Filler
    CV_IA64_AR127   =   3199,              // Intel-IA64-Filler

    // CPUID Registers                // Intel-IA64-Filler
    CV_IA64_CPUID0  =   3328,              // Intel-IA64-Filler
    CV_IA64_CPUID1  =   3329,              // Intel-IA64-Filler
    CV_IA64_CPUID2  =   3330,              // Intel-IA64-Filler
    CV_IA64_CPUID3  =   3331,              // Intel-IA64-Filler
    CV_IA64_CPUID4  =   3332,              // Intel-IA64-Filler

    // Control Registers              // Intel-IA64-Filler

    CV_IA64_ApDCR    =   4096,              // Intel-IA64-Filler
    CV_IA64_ApITM    =   4097,              // Intel-IA64-Filler
    CV_IA64_ApIVA    =   4098,              // Intel-IA64-Filler
    CV_IA64_CR3      =   4099,              // Intel-IA64-Filler
    CV_IA64_CR4      =   4100,              // Intel-IA64-Filler
    CV_IA64_CR5      =   4101,              // Intel-IA64-Filler
    CV_IA64_CR6      =   4102,              // Intel-IA64-Filler
    CV_IA64_CR7      =   4103,              // Intel-IA64-Filler
    CV_IA64_ApPTA    =   4104,              // Intel-IA64-Filler
    CV_IA64_ApGPTA   =   4105,              // Intel-IA64-Filler
    CV_IA64_CR10     =   4106,              // Intel-IA64-Filler
    CV_IA64_CR11     =   4107,              // Intel-IA64-Filler
    CV_IA64_CR12     =   4108,              // Intel-IA64-Filler
    CV_IA64_CR13     =   4109,              // Intel-IA64-Filler
    CV_IA64_CR14     =   4110,              // Intel-IA64-Filler
    CV_IA64_CR15     =   4111,              // Intel-IA64-Filler
    CV_IA64_StIPSR   =   4112,              // Intel-IA64-Filler
    CV_IA64_StISR    =   4113,              // Intel-IA64-Filler
    CV_IA64_CR18     =   4114,              // Intel-IA64-Filler
    CV_IA64_StIIP    =   4115,              // Intel-IA64-Filler
    CV_IA64_StIFA    =   4116,              // Intel-IA64-Filler
    CV_IA64_StITIR   =   4117,              // Intel-IA64-Filler
    CV_IA64_StIIPA   =   4118,              // Intel-IA64-Filler
    CV_IA64_StIFS    =   4119,              // Intel-IA64-Filler
    CV_IA64_StIIM    =   4120,              // Intel-IA64-Filler
    CV_IA64_StIHA    =   4121,              // Intel-IA64-Filler
    CV_IA64_CR26     =   4122,              // Intel-IA64-Filler
    CV_IA64_CR27     =   4123,              // Intel-IA64-Filler
    CV_IA64_CR28     =   4124,              // Intel-IA64-Filler
    CV_IA64_CR29     =   4125,              // Intel-IA64-Filler
    CV_IA64_CR30     =   4126,              // Intel-IA64-Filler
    CV_IA64_CR31     =   4127,              // Intel-IA64-Filler
    CV_IA64_CR32     =   4128,              // Intel-IA64-Filler
    CV_IA64_CR33     =   4129,              // Intel-IA64-Filler
    CV_IA64_CR34     =   4130,              // Intel-IA64-Filler
    CV_IA64_CR35     =   4131,              // Intel-IA64-Filler
    CV_IA64_CR36     =   4132,              // Intel-IA64-Filler
    CV_IA64_CR37     =   4133,              // Intel-IA64-Filler
    CV_IA64_CR38     =   4134,              // Intel-IA64-Filler
    CV_IA64_CR39     =   4135,              // Intel-IA64-Filler
    CV_IA64_CR40     =   4136,              // Intel-IA64-Filler
    CV_IA64_CR41     =   4137,              // Intel-IA64-Filler
    CV_IA64_CR42     =   4138,              // Intel-IA64-Filler
    CV_IA64_CR43     =   4139,              // Intel-IA64-Filler
    CV_IA64_CR44     =   4140,              // Intel-IA64-Filler
    CV_IA64_CR45     =   4141,              // Intel-IA64-Filler
    CV_IA64_CR46     =   4142,              // Intel-IA64-Filler
    CV_IA64_CR47     =   4143,              // Intel-IA64-Filler
    CV_IA64_CR48     =   4144,              // Intel-IA64-Filler
    CV_IA64_CR49     =   4145,              // Intel-IA64-Filler
    CV_IA64_CR50     =   4146,              // Intel-IA64-Filler
    CV_IA64_CR51     =   4147,              // Intel-IA64-Filler
    CV_IA64_CR52     =   4148,              // Intel-IA64-Filler
    CV_IA64_CR53     =   4149,              // Intel-IA64-Filler
    CV_IA64_CR54     =   4150,              // Intel-IA64-Filler
    CV_IA64_CR55     =   4151,              // Intel-IA64-Filler
    CV_IA64_CR56     =   4152,              // Intel-IA64-Filler
    CV_IA64_CR57     =   4153,              // Intel-IA64-Filler
    CV_IA64_CR58     =   4154,              // Intel-IA64-Filler
    CV_IA64_CR59     =   4155,              // Intel-IA64-Filler
    CV_IA64_CR60     =   4156,              // Intel-IA64-Filler
    CV_IA64_CR61     =   4157,              // Intel-IA64-Filler
    CV_IA64_CR62     =   4158,              // Intel-IA64-Filler
    CV_IA64_CR63     =   4159,              // Intel-IA64-Filler
    CV_IA64_SaLID    =   4160,              // Intel-IA64-Filler
    CV_IA64_SaIVR    =   4161,              // Intel-IA64-Filler
    CV_IA64_SaTPR    =   4162,              // Intel-IA64-Filler
    CV_IA64_SaEOI    =   4163,              // Intel-IA64-Filler
    CV_IA64_SaIRR0   =   4164,              // Intel-IA64-Filler
    CV_IA64_SaIRR1   =   4165,              // Intel-IA64-Filler
    CV_IA64_SaIRR2   =   4166,              // Intel-IA64-Filler
    CV_IA64_SaIIR3   =   4167,              // Intel-IA64-Filler
    CV_IA64_SaITV    =   4168,              // Intel-IA64-Filler
    CV_IA64_SaPMV    =   4169,              // Intel-IA64-Filler
    CV_IA64_SaCMCV   =   4170,              // Intel-IA64-Filler
    CV_IA64_CR75     =   4171,              // Intel-IA64-Filler
    CV_IA64_CR76     =   4172,              // Intel-IA64-Filler
    CV_IA64_CR77     =   4173,              // Intel-IA64-Filler
    CV_IA64_CR78     =   4174,              // Intel-IA64-Filler
    CV_IA64_CR79     =   4175,              // Intel-IA64-Filler
    CV_IA64_SaLRR0   =   4176,              // Intel-IA64-Filler
    CV_IA64_SaLRR1   =   4177,              // Intel-IA64-Filler
    CV_IA64_CR82     =   4178,              // Intel-IA64-Filler
    CV_IA64_CR83     =   4179,              // Intel-IA64-Filler
    CV_IA64_CR84     =   4180,              // Intel-IA64-Filler
    CV_IA64_CR85     =   4181,              // Intel-IA64-Filler
    CV_IA64_CR86     =   4182,              // Intel-IA64-Filler
    CV_IA64_CR87     =   4183,              // Intel-IA64-Filler
    CV_IA64_CR88     =   4184,              // Intel-IA64-Filler
    CV_IA64_CR89     =   4185,              // Intel-IA64-Filler
    CV_IA64_CR90     =   4186,              // Intel-IA64-Filler
    CV_IA64_CR91     =   4187,              // Intel-IA64-Filler
    CV_IA64_CR92     =   4188,              // Intel-IA64-Filler
    CV_IA64_CR93     =   4189,              // Intel-IA64-Filler
    CV_IA64_CR94     =   4190,              // Intel-IA64-Filler
    CV_IA64_CR95     =   4191,              // Intel-IA64-Filler
    CV_IA64_CR96     =   4192,              // Intel-IA64-Filler
    CV_IA64_CR97     =   4193,              // Intel-IA64-Filler
    CV_IA64_CR98     =   4194,              // Intel-IA64-Filler
    CV_IA64_CR99     =   4195,              // Intel-IA64-Filler
    CV_IA64_CR100    =   4196,              // Intel-IA64-Filler
    CV_IA64_CR101    =   4197,              // Intel-IA64-Filler
    CV_IA64_CR102    =   4198,              // Intel-IA64-Filler
    CV_IA64_CR103    =   4199,              // Intel-IA64-Filler
    CV_IA64_CR104    =   4200,              // Intel-IA64-Filler
    CV_IA64_CR105    =   4201,              // Intel-IA64-Filler
    CV_IA64_CR106    =   4202,              // Intel-IA64-Filler
    CV_IA64_CR107    =   4203,              // Intel-IA64-Filler
    CV_IA64_CR108    =   4204,              // Intel-IA64-Filler
    CV_IA64_CR109    =   4205,              // Intel-IA64-Filler
    CV_IA64_CR110    =   4206,              // Intel-IA64-Filler
    CV_IA64_CR111    =   4207,              // Intel-IA64-Filler
    CV_IA64_CR112    =   4208,              // Intel-IA64-Filler
    CV_IA64_CR113    =   4209,              // Intel-IA64-Filler
    CV_IA64_CR114    =   4210,              // Intel-IA64-Filler
    CV_IA64_CR115    =   4211,              // Intel-IA64-Filler
    CV_IA64_CR116    =   4212,              // Intel-IA64-Filler
    CV_IA64_CR117    =   4213,              // Intel-IA64-Filler
    CV_IA64_CR118    =   4214,              // Intel-IA64-Filler
    CV_IA64_CR119    =   4215,              // Intel-IA64-Filler
    CV_IA64_CR120    =   4216,              // Intel-IA64-Filler
    CV_IA64_CR121    =   4217,              // Intel-IA64-Filler
    CV_IA64_CR122    =   4218,              // Intel-IA64-Filler
    CV_IA64_CR123    =   4219,              // Intel-IA64-Filler
    CV_IA64_CR124    =   4220,              // Intel-IA64-Filler
    CV_IA64_CR125    =   4221,              // Intel-IA64-Filler
    CV_IA64_CR126    =   4222,              // Intel-IA64-Filler
    CV_IA64_CR127    =   4223,              // Intel-IA64-Filler

    // Protection Key Registers              // Intel-IA64-Filler

    CV_IA64_Pkr0     =   5120,              // Intel-IA64-Filler
    CV_IA64_Pkr1     =   5121,              // Intel-IA64-Filler
    CV_IA64_Pkr2     =   5122,              // Intel-IA64-Filler
    CV_IA64_Pkr3     =   5123,              // Intel-IA64-Filler
    CV_IA64_Pkr4     =   5124,              // Intel-IA64-Filler
    CV_IA64_Pkr5     =   5125,              // Intel-IA64-Filler
    CV_IA64_Pkr6     =   5126,              // Intel-IA64-Filler
    CV_IA64_Pkr7     =   5127,              // Intel-IA64-Filler
    CV_IA64_Pkr8     =   5128,              // Intel-IA64-Filler
    CV_IA64_Pkr9     =   5129,              // Intel-IA64-Filler
    CV_IA64_Pkr10    =   5130,              // Intel-IA64-Filler
    CV_IA64_Pkr11    =   5131,              // Intel-IA64-Filler
    CV_IA64_Pkr12    =   5132,              // Intel-IA64-Filler
    CV_IA64_Pkr13    =   5133,              // Intel-IA64-Filler
    CV_IA64_Pkr14    =   5134,              // Intel-IA64-Filler
    CV_IA64_Pkr15    =   5135,              // Intel-IA64-Filler

    // Region Registers

    CV_IA64_Rr0      =   6144,              // Intel-IA64-Filler
    CV_IA64_Rr1      =   6145,              // Intel-IA64-Filler
    CV_IA64_Rr2      =   6146,              // Intel-IA64-Filler
    CV_IA64_Rr3      =   6147,              // Intel-IA64-Filler
    CV_IA64_Rr4      =   6148,              // Intel-IA64-Filler
    CV_IA64_Rr5      =   6149,              // Intel-IA64-Filler
    CV_IA64_Rr6      =   6150,              // Intel-IA64-Filler
    CV_IA64_Rr7      =   6151,              // Intel-IA64-Filler

    // Performance Monitor Data Registers              // Intel-IA64-Filler

    CV_IA64_PFD0     =   7168,              // Intel-IA64-Filler
    CV_IA64_PFD1     =   7169,              // Intel-IA64-Filler
    CV_IA64_PFD2     =   7170,              // Intel-IA64-Filler
    CV_IA64_PFD3     =   7171,              // Intel-IA64-Filler
    CV_IA64_PFD4     =   7172,              // Intel-IA64-Filler
    CV_IA64_PFD5     =   7173,              // Intel-IA64-Filler
    CV_IA64_PFD6     =   7174,              // Intel-IA64-Filler
    CV_IA64_PFD7     =   7175,              // Intel-IA64-Filler

    // Performance Monitor Config Registers              // Intel-IA64-Filler

    CV_IA64_PFC0     =   7424,              // Intel-IA64-Filler
    CV_IA64_PFC1     =   7425,              // Intel-IA64-Filler
    CV_IA64_PFC2     =   7426,              // Intel-IA64-Filler
    CV_IA64_PFC3     =   7427,              // Intel-IA64-Filler
    CV_IA64_PFC4     =   7428,              // Intel-IA64-Filler
    CV_IA64_PFC5     =   7429,              // Intel-IA64-Filler
    CV_IA64_PFC6     =   7430,              // Intel-IA64-Filler
    CV_IA64_PFC7     =   7431,              // Intel-IA64-Filler

    // Instruction Translation Registers              // Intel-IA64-Filler

    CV_IA64_TrI0     =   8192,              // Intel-IA64-Filler
    CV_IA64_TrI1     =   8193,              // Intel-IA64-Filler
    CV_IA64_TrI2     =   8194,              // Intel-IA64-Filler
    CV_IA64_TrI3     =   8195,              // Intel-IA64-Filler
    CV_IA64_TrI4     =   8196,              // Intel-IA64-Filler
    CV_IA64_TrI5     =   8197,              // Intel-IA64-Filler
    CV_IA64_TrI6     =   8198,              // Intel-IA64-Filler
    CV_IA64_TrI7     =   8199,              // Intel-IA64-Filler

    // Data Translation Registers              // Intel-IA64-Filler

    CV_IA64_TrD0     =   8320,              // Intel-IA64-Filler
    CV_IA64_TrD1     =   8321,              // Intel-IA64-Filler
    CV_IA64_TrD2     =   8322,              // Intel-IA64-Filler
    CV_IA64_TrD3     =   8323,              // Intel-IA64-Filler
    CV_IA64_TrD4     =   8324,              // Intel-IA64-Filler
    CV_IA64_TrD5     =   8325,              // Intel-IA64-Filler
    CV_IA64_TrD6     =   8326,              // Intel-IA64-Filler
    CV_IA64_TrD7     =   8327,              // Intel-IA64-Filler

    // Instruction Breakpoint Registers              // Intel-IA64-Filler

    CV_IA64_DbI0     =   8448,              // Intel-IA64-Filler
    CV_IA64_DbI1     =   8449,              // Intel-IA64-Filler
    CV_IA64_DbI2     =   8450,              // Intel-IA64-Filler
    CV_IA64_DbI3     =   8451,              // Intel-IA64-Filler
    CV_IA64_DbI4     =   8452,              // Intel-IA64-Filler
    CV_IA64_DbI5     =   8453,              // Intel-IA64-Filler
    CV_IA64_DbI6     =   8454,              // Intel-IA64-Filler
    CV_IA64_DbI7     =   8455,              // Intel-IA64-Filler

    // Data Breakpoint Registers              // Intel-IA64-Filler

    CV_IA64_DbD0     =   8576,              // Intel-IA64-Filler
    CV_IA64_DbD1     =   8577,              // Intel-IA64-Filler
    CV_IA64_DbD2     =   8578,              // Intel-IA64-Filler
    CV_IA64_DbD3     =   8579,              // Intel-IA64-Filler
    CV_IA64_DbD4     =   8580,              // Intel-IA64-Filler
    CV_IA64_DbD5     =   8581,              // Intel-IA64-Filler
    CV_IA64_DbD6     =   8582,              // Intel-IA64-Filler
    CV_IA64_DbD7     =   8583,              // Intel-IA64-Filler

} IA64_REG_INDEX;              // Intel-IA64-Filler


#endif // _IA64REG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\ddk\inc\ioaccess.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    ioaccess.h

Abstract:

    Definitions of function prototypes for accessing I/O ports and
    memory on I/O adapters from display drivers.

    Cloned from parts of nti386.h.

Author:


--*/

//
// Note: IA64 is for 64 bits Merced. Under Merced compiler option, we don't have
// _X86_, instead, we use _IA64_. Same thing, _AXP64_ is for 64 bits compiler
// option for ALPHA
//
#if defined(_MIPS_) || defined(_X86_) || defined(_AMD64_)

//
// Memory barriers on X86 and MIPS are not required since the Io
// Operations are always garanteed to be executed in order
//

#define MEMORY_BARRIER()    0


#elif defined(_IA64_)

//
// Itanium requires memory barriers
//

void __mf();

#define MEMORY_BARRIER()    __mf()

#elif defined(_PPC_)

//
// A memory barrier function is provided by the PowerPC Enforce
// In-order Execution of I/O instruction (eieio).
//

#if defined(_M_PPC) && defined(_MSC_VER) && (_MSC_VER>=1000)
void __emit( unsigned const __int32 );
#define __builtin_eieio() __emit( 0x7C0006AC )
#else
void __builtin_eieio(void);
#endif

#define MEMORY_BARRIER()        __builtin_eieio()


#elif defined(_ALPHA_) || (_AXP64_)

//
// ALPHA requires memory barriers
//

#define MEMORY_BARRIER()  __MB()



#endif

#ifndef NO_PORT_MACROS



//
// I/O space read and write macros.
//
//  The READ/WRITE_REGISTER_* calls manipulate MEMORY registers.
//  (Use x86 move instructions, with LOCK prefix to force correct behavior
//   w.r.t. caches and write buffers.)
//
//  The READ/WRITE_PORT_* calls manipulate I/O ports.
//  (Use x86 in/out instructions.)
//


//
// inp(),inpw(), inpd(), outp(), outpw(), outpd() are X86 specific intrinsic
// inline functions. So for IA64, we have to put READ_PORT_USHORT() etc. back
// to it's supposed to be, defined in sdk\inc\wdm.h
//
#if defined(_IA64_)
#define READ_REGISTER_UCHAR(Register)          (*(volatile UCHAR *)(Register))
#define READ_REGISTER_USHORT(Register)         (*(volatile USHORT *)(Register))
#define READ_REGISTER_ULONG(Register)          (*(volatile ULONG *)(Register))
#define WRITE_REGISTER_UCHAR(Register, Value)  (*(volatile UCHAR *)(Register) = (Value))
#define WRITE_REGISTER_USHORT(Register, Value) (*(volatile USHORT *)(Register) = (Value))
#define WRITE_REGISTER_ULONG(Register, Value)  (*(volatile ULONG *)(Register) = (Value))

__declspec(dllimport)
UCHAR
READ_PORT_UCHAR(
    PVOID Port
    );

__declspec(dllimport)
USHORT
READ_PORT_USHORT(
    PVOID Port
    );

__declspec(dllimport)
ULONG
READ_PORT_ULONG(
    PVOID Port
    );

//
// All these function prototypes take a ULONG as a parameter so that
// we don't force an extra typecast in the code (which will cause
// the X86 to generate bad code).
//

__declspec(dllimport)
VOID
WRITE_PORT_UCHAR(
    PVOID Port,
    ULONG Value
    );

__declspec(dllimport)
VOID
WRITE_PORT_USHORT(
    PVOID  Port,
    ULONG Value
    );

__declspec(dllimport)
VOID
WRITE_PORT_ULONG(
    PVOID Port,
    ULONG Value
    );

#elif defined(_X86_)
#define READ_REGISTER_UCHAR(Register)          (*(volatile UCHAR *)(Register))
#define READ_REGISTER_USHORT(Register)         (*(volatile USHORT *)(Register))
#define READ_REGISTER_ULONG(Register)          (*(volatile ULONG *)(Register))
#define WRITE_REGISTER_UCHAR(Register, Value)  (*(volatile UCHAR *)(Register) = (Value))
#define WRITE_REGISTER_USHORT(Register, Value) (*(volatile USHORT *)(Register) = (Value))
#define WRITE_REGISTER_ULONG(Register, Value)  (*(volatile ULONG *)(Register) = (Value))
#define READ_PORT_UCHAR(Port)                  (UCHAR)(inp (Port))
#define READ_PORT_USHORT(Port)                 (USHORT)(inpw (Port))
#define READ_PORT_ULONG(Port)                  (ULONG)(inpd (Port))
#define WRITE_PORT_UCHAR(Port, Value)          outp ((Port), (Value))
#define WRITE_PORT_USHORT(Port, Value)         outpw ((Port), (Value))
#define WRITE_PORT_ULONG(Port, Value)          outpd ((Port), (Value))

#elif defined(_PPC_) || defined(_MIPS_)

#define READ_REGISTER_UCHAR(x)      (*(volatile UCHAR * const)(x))
#define READ_REGISTER_USHORT(x)     (*(volatile USHORT * const)(x))
#define READ_REGISTER_ULONG(x)      (*(volatile ULONG * const)(x))
#define WRITE_REGISTER_UCHAR(x, y)  (*(volatile UCHAR * const)(x) = (y))
#define WRITE_REGISTER_USHORT(x, y) (*(volatile USHORT * const)(x) = (y))
#define WRITE_REGISTER_ULONG(x, y)  (*(volatile ULONG * const)(x) = (y))
#define READ_PORT_UCHAR(x)          READ_REGISTER_UCHAR(x)
#define READ_PORT_USHORT(x)         READ_REGISTER_USHORT(x)
#define READ_PORT_ULONG(x)          READ_REGISTER_ULONG(x)

//
// All these macros take a ULONG as a parameter so that we don't
// force an extra typecast in the code (which will cause the X86 to
// generate bad code).
//

#define WRITE_PORT_UCHAR(x, y)      WRITE_REGISTER_UCHAR(x, (UCHAR) (y))
#define WRITE_PORT_USHORT(x, y)     WRITE_REGISTER_USHORT(x, (USHORT) (y))
#define WRITE_PORT_ULONG(x, y)      WRITE_REGISTER_ULONG(x, (ULONG) (y))


#elif defined(_ALPHA_) || (_AXP64_)

//
// READ/WRITE_PORT/REGISTER_UCHAR_USHORT_ULONG are all functions that
// go to the HAL on ALPHA
//
// So we only put the prototypes here
//

__declspec(dllimport)
UCHAR
READ_REGISTER_UCHAR(
    PVOID Register
    );

__declspec(dllimport)
USHORT
READ_REGISTER_USHORT(
    PVOID Register
    );

__declspec(dllimport)
ULONG
READ_REGISTER_ULONG(
    PVOID Register
    );

__declspec(dllimport)
VOID
WRITE_REGISTER_UCHAR(
    PVOID Register,
    UCHAR Value
    );

__declspec(dllimport)
VOID
WRITE_REGISTER_USHORT(
    PVOID  Register,
    USHORT Value
    );

__declspec(dllimport)
VOID
WRITE_REGISTER_ULONG(
    PVOID Register,
    ULONG Value
    );

__declspec(dllimport)
UCHAR
READ_PORT_UCHAR(
    PVOID Port
    );

__declspec(dllimport)
USHORT
READ_PORT_USHORT(
    PVOID Port
    );

__declspec(dllimport)
ULONG
READ_PORT_ULONG(
    PVOID Port
    );

//
// All these function prototypes take a ULONG as a parameter so that
// we don't force an extra typecast in the code (which will cause
// the X86 to generate bad code).
//

__declspec(dllimport)
VOID
WRITE_PORT_UCHAR(
    PVOID Port,
    ULONG Value
    );

__declspec(dllimport)
VOID
WRITE_PORT_USHORT(
    PVOID  Port,
    ULONG Value
    );

__declspec(dllimport)
VOID
WRITE_PORT_ULONG(
    PVOID Port,
    ULONG Value
    );

#elif defined(_AMD64_)

UCHAR
__inbyte (
    IN USHORT Port
    );

USHORT
__inword (
    IN USHORT Port
    );

ULONG
__indword (
    IN USHORT Port
    );

VOID
__outbyte (
    IN USHORT Port,
    IN UCHAR Data
    );

VOID
__outword (
    IN USHORT Port,
    IN USHORT Data
    );

VOID
__outdword (
    IN USHORT Port,
    IN ULONG Data
    );

#pragma intrinsic(__inbyte)
#pragma intrinsic(__inword)
#pragma intrinsic(__indword)
#pragma intrinsic(__outbyte)
#pragma intrinsic(__outword)
#pragma intrinsic(__outdword)

LONG
_InterlockedOr (
    IN OUT LONG volatile *Target,
    IN LONG Set
    );

#pragma intrinsic(_InterlockedOr)


__inline
UCHAR
READ_REGISTER_UCHAR (
    PVOID Register
    )
{
    return *(UCHAR volatile *)Register;
}

__inline
USHORT
READ_REGISTER_USHORT (
    PVOID Register
    )
{
    return *(USHORT volatile *)Register;
}

__inline
ULONG
READ_REGISTER_ULONG (
    PVOID Register
    )
{
    return *(ULONG volatile *)Register;
}

__inline
VOID
WRITE_REGISTER_UCHAR (
    PVOID Register,
    UCHAR Value
    )
{
    LONG Synch;

    *(UCHAR volatile *)Register = Value;
    _InterlockedOr(&Synch, 1);
    return;
}

__inline
VOID
WRITE_REGISTER_USHORT (
    PVOID Register,
    USHORT Value
    )
{
    LONG Synch;

    *(USHORT volatile *)Register = Value;
    _InterlockedOr(&Synch, 1);
    return;
}

__inline
VOID
WRITE_REGISTER_ULONG (
    PVOID Register,
    ULONG Value
    )
{
    LONG Synch;

    *(ULONG volatile *)Register = Value;
    _InterlockedOr(&Synch, 1);
    return;
}

__inline
UCHAR
READ_PORT_UCHAR (
    PVOID Port
    )

{
    return __inbyte((USHORT)((ULONG64)Port));
}

__inline
USHORT
READ_PORT_USHORT (
    PVOID Port
    )

{
    return __inword((USHORT)((ULONG64)Port));
}

__inline
ULONG
READ_PORT_ULONG (
    PVOID Port
    )

{
    return __indword((USHORT)((ULONG64)Port));
}

__inline
VOID
WRITE_PORT_UCHAR (
    PVOID Port,
    UCHAR Value
    )

{
    __outbyte((USHORT)((ULONG64)Port), Value);
    return;
}

__inline
VOID
WRITE_PORT_USHORT (
    PVOID Port,
    USHORT Value
    )

{
    __outword((USHORT)((ULONG64)Port), Value);
    return;
}

__inline
VOID
WRITE_PORT_ULONG (
    PVOID Port,
    ULONG Value
    )

{
    __outdword((USHORT)((ULONG64)Port), Value);
    return;
}

#endif      // NO_PORT_MACROS

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\ddk\inc\gameport.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    gameport.h

Abstract:

    This module contains the common public declarations for the game port
    enumerator.

@@BEGIN_DDKSPLIT

Author:

    Kenneth Ray

@@END_DDKSPLIT

Environment:

    kernel mode only

Notes:


Revision History:


--*/


#ifndef __GAMEPORT_H
#define __GAMEPORT_H

#define FILE_DEVICE_GAMEENUM         FILE_DEVICE_BUS_EXTENDER

// ***************************************************************************
// IOCTL interface to the bus (fdo)
//
// Clients use this to tell the enumerator what gaming devices on legacy ports
// exist.  (like for instance a control panel)
// ***************************************************************************

//
// Define an Interface Guid to access the game port enumerator
//

#undef FAR
#define FAR
#undef PHYSICAL_ADDRESS
#define PHYSICAL_ADDRESS LARGE_INTEGER

DEFINE_GUID (GUID_GAMEENUM_BUS_ENUMERATOR, 0xcae56030, 0x684a, 0x11d0, 0xd6, 0xf6, 0x00, 0xa0, 0xc9, 0x0f, 0x57, 0xda);
//  cae56030-684a-11d0-b6f6-00a0c90f57da

#define GAMEENUM_IOCTL(_index_) \
    CTL_CODE (FILE_DEVICE_GAMEENUM, _index_, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define GAMEENUM_INTERNAL_IOCTL(_index_) \
    CTL_CODE (FILE_DEVICE_GAMEENUM, _index_, METHOD_NEITHER, FILE_ANY_ACCESS)

#define IOCTL_GAMEENUM_EXPOSE_HARDWARE  GAMEENUM_IOCTL (0x0)
#define IOCTL_GAMEENUM_REMOVE_HARDWARE  GAMEENUM_IOCTL (0x1)
#define IOCTL_GAMEENUM_PORT_DESC        GAMEENUM_IOCTL (0x2)

//
//      Private data storage area for OEM devices. Values preserved if supplied to
// IOCTL_GAMEENUM_EXPOSE_HARDWARE and GAMEENUM_INTERNAL_IOCTL_EXPOSE_SIBLING,
//      and set to zero otherwise on initial mini-driver invocation (DriverEntry).
//

#define SIZE_GAMEENUM_OEM_DATA                  8
typedef ULONG   GAMEENUM_OEM_DATA[SIZE_GAMEENUM_OEM_DATA];

#if _MSC_VER >= 1200
#pragma warning(push)
#endif

#pragma warning(disable:4200)

typedef struct _GAMEENUM_EXPOSE_HARDWARE
{
    //
    // sizeof (struct _GAMEENUM_HARDWARE)
    //
    IN ULONG Size;

    //
    // The handle of the port found in the port desc
    //
    IN PVOID PortHandle;

    //
    // A handle to the exposed PDO
    //
    OUT PVOID HardwareHandle;

    //
    // For legacy joysticks only
    //
    IN USHORT NumberJoysticks;

    //
    // legacy joysticks only (joysticks * axis <= 4).
    //
    IN USHORT NumberAxis;

    //
    // Unique ID
    //
    IN USHORT UnitID;

    //
    // Number of buttons present on the device
    //
    IN USHORT NumberButtons;

    //
    // Bit flags controlling the behavior of the device
    //
    USHORT Flags;

    //
    // Reserved for future use
    //
    USHORT Reserved[5];

    //
    // Specific OEM Data
    //
    IN GAMEENUM_OEM_DATA OemData;

    //
    // An array of (zero terminated wide character strings). The array itself
    //  also null terminated (ie, MULTI_SZ)
    //
    IN  WCHAR                                   HardwareIDs[];

} GAMEENUM_EXPOSE_HARDWARE, *PGAMEENUM_EXPOSE_HARDWARE;


//
// Bit values defined for the Flags field
//     GAMEENUM_FLAG_NOCOMPATID the default compatibility hardware ID should 
//     not be exposed for this device.
//     GAMEENUM_FLAG_COMPATIDCTRL if this is zero GAMEENUM_FLAG_NOCOMPATID is 
//     ignored
//     GAMEENUM_FLAG_RESERVED reserved bits, should be set to zero
//
#define GAMEENUM_FLAG_NOCOMPATID    0x0001
#define GAMEENUM_FLAG_COMPATIDCTRL  0x0002
#define GAMEENUM_FLAG_RESERVED      0xFFFC


#if _MSC_VER >= 1200
#pragma warning(pop)
#endif

typedef struct _GAMEENUM_REMOVE_HARDWARE
{
    //
    // sizeof (struct _REMOVE_HARDWARE)
    //
    IN ULONG Size;

    //
    // Same value as HardwareHandle in GAMEENUM_EXPOSE_HARDWARE
    //
    IN PVOID HardwareHandle;

} GAMEENUM_REMOVE_HARDWARE, *PGAMEENUM_REMOVE_HARDWARE;

typedef struct _GAMEENUM_PORT_DESC
{
    IN  ULONG               Size;       // sizeof (struct _PORT_DESC)
    OUT PVOID               PortHandle;
    OUT PHYSICAL_ADDRESS    PortAddress;
        ULONG               Reserved [5];
} GAMEENUM_PORT_DESC, *PGAMEENUM_PORT_DESC;

// **************************************************************************
// Internal IOCTL interface for (pdo)
// The HID to legacy game port minidriver uses this interface to
// find the address of the device.
// **************************************************************************

#define IOCTL_GAMEENUM_PORT_PARAMETERS          GAMEENUM_INTERNAL_IOCTL (0x100)
#define IOCTL_GAMEENUM_EXPOSE_SIBLING           GAMEENUM_INTERNAL_IOCTL (0x101)
#define IOCTL_GAMEENUM_REMOVE_SELF              GAMEENUM_INTERNAL_IOCTL (0x102)
#define IOCTL_GAMEENUM_ACQUIRE_ACCESSORS        GAMEENUM_INTERNAL_IOCTL (0x103)

// Of which IO_STACK_LOCATION->Parameters.Others.Argument1 is set to
// a pointer to struct _GAMEENUM_GAME_PARAMETERS

typedef
UCHAR
(*PGAMEENUM_READPORT) (
    PVOID  GameContext
    );

typedef
VOID
(*PGAMEENUM_WRITEPORT) (
    PVOID  GameContext,
    UCHAR   Value
    );

#define GAMEENUM_BUTTON_1   0x01
#define GAMEENUM_BUTTON_2   0x02
#define GAMEENUM_BUTTON_3   0x04
#define GAMEENUM_BUTTON_4   0x08

#define GAMEENUM_AXIS_X     0x10
#define GAMEENUM_AXIS_Y     0x20
#define GAMEENUM_AXIS_R     0x40
#define GAMEENUM_AXIS_Z     0x80

#ifndef NTSTATUS
typedef LONG NTSTATUS;
#endif

typedef
NTSTATUS
(*PGAMEENUM_READPORT_DIGITAL) (
    IN     PVOID   Context,
    IN     UCHAR   ButtonAxisMask,
    IN     BOOLEAN Approximate,
    IN OUT ULONG   AxisState[4],
       OUT UCHAR   ButtonState[4]
    );
/*++
Routine Description.

    Will read from the gameport digitally.

Arguments:

    Context        -    value passed in GAME_PORT_PARAMETERS.GameContext

    ButtonAxisMask -    Mask indicating which axis  and buttons are expected to
                        have valid data

    Approximate    -    OK to approximate (if polling times out, etc)

    AxisState      -    IN  = Last valid axis state
                        OUT = Current Axis state

                        Index       Maps to Axis
                        0           X
                        1           Y
                        2           R
                        3           Z

    ButtonState    -    OUT =  Current button state.

--*/

typedef
NTSTATUS
(*PGAMEENUM_ACQUIRE_PORT) (
    PVOID  GameContext
    );

typedef
VOID
(*PGAMEENUM_RELEASE_PORT) (
    PVOID  GameContext
    );

typedef enum _GAMEENUM_PORTION
{
        GameenumFirstHalf,
        GameenumSecondHalf,
        GameenumWhole
} GAMEENUM_PORTION;

typedef struct _GAMEENUM_PORT_PARAMETERS
{
    //
    // sizeof (GAMEENUM_GET_PORT_PARAMETERS)
    //
    IN  ULONG Size;

    //
    // read the game port (analog)
    //
    OUT PGAMEENUM_READPORT ReadAccessor;

    //
    // write the game port (analog)
    //
    OUT PGAMEENUM_WRITEPORT WriteAccessor;

    //
    // token to read/write this game port
    //
    OUT PVOID GameContext;

    //
    // Which joystick is it?
    //
    OUT GAMEENUM_PORTION Portion;

    //
    // legacy joysticks only
    //
    OUT USHORT NumberAxis;

    //
    // unique id
    //
    IN USHORT UnitID;

    //
    // OEM specific data
    //
    IN GAMEENUM_OEM_DATA OemData;

    //
    // Number of buttons
    //
    OUT USHORT NumberButtons;

    //
    // Reserved for future use
    //
    USHORT Reserved2;

    //
    // Read the game port (digital)
    //
    OUT PGAMEENUM_READPORT_DIGITAL  ReadAccessorDigital;

    //
    // Function to call before reading/writing to the port
    //
    OUT PGAMEENUM_ACQUIRE_PORT AcquirePort;

    //
    // Function to call when done reading/writing to the port
    //
    OUT PGAMEENUM_RELEASE_PORT ReleasePort;

    //
    // Context to pass to AcquirePort and ReleasePort
    //
    OUT PVOID PortContext;

    ULONG Reserved[3];

} GAMEENUM_PORT_PARAMETERS, *PGAMEENUM_PORT_PARAMETERS;

typedef struct _GAMEENUM_EXPOSE_SIBLING
{
    //
    // sizeof (struct _GAMEENUM_EXPOSE_SIBLING)
    //
    IN ULONG Size;

    //
    // A handle to the exposed PDO
    //
    OUT PVOID HardwareHandle;

    //
    // OEM specific data
    //
    IN GAMEENUM_OEM_DATA OemData;

    //
    // The id of this device object
    //
    IN USHORT UnitID;

    USHORT Reserved[3];

    //
    // An array of (zero terminated wide character strings). The array itself
    //  also null terminated (ie, MULTI_SZ),
    //
    IN PWCHAR HardwareIDs OPTIONAL;

} GAMEENUM_EXPOSE_SIBLING, *PGAMEENUM_EXPOSE_SIBLING;

//
// This struct is sent down to the PDO/lower filters of gameenum via
// the internal IOCTL  IOCTL_GAMEENUM_ACQUIRE_ACCESSORS.  If this IOCTL is
// handled, GameContext, ReadAccessor, and WriteAccessor must be filled in.
// ReadAccessorDigital is optional
//
typedef struct _GAMEENUM_ACQUIRE_ACCESSORS
{
    //
    // sizeof (struct _GAMEENUM_ACQUIRE_ACCESSORS)
    //
    IN ULONG                        Size;

    //
    // token to read/write this game port
    //
    OUT PVOID                       GameContext;

    //
    // read the game port (analog)
    //
    OUT PGAMEENUM_READPORT          ReadAccessor;

    //
    // write the game port (analog)
    //
    OUT PGAMEENUM_WRITEPORT         WriteAccessor;

    //
    // Read the game port (digital)
    //
    OUT PGAMEENUM_READPORT_DIGITAL  ReadAccessorDigital;

    //
    // Function to call before reading/writing to the port
    //
    OUT PGAMEENUM_ACQUIRE_PORT AcquirePort;

    //
    // Function to call when done reading/writing to the port
    //
    OUT PGAMEENUM_RELEASE_PORT ReleasePort;

    //
    // Context to pass to AcquirePort and ReleasePort
    //
    OUT PVOID PortContext;

    OUT ULONG                       Reserved[3];

} GAMEENUM_ACQUIRE_ACCESSORS, *PGAMEENUM_ACQUIRE_ACCESSORS;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\ddk\inc\isvbop.inc ===
; This is the inc file for isvbop.h.
; Please refer to isvbop.h for comments and notes on these interfaces
;
BOP_3RDPARTY	EQU	58H
BOP_UNSIMULATE	EQU	0FEH

RegisterModule macro
    db  0C4h, 0C4h, BOP_3RDPARTY, 0
        endm

UnRegisterModule macro
    db  0C4h, 0C4h, BOP_3RDPARTY, 1
        endm

DispatchCall macro
    db  0C4h, 0C4h, BOP_3RDPARTY, 2
        endm
 
VDDUnSimulate16 macro
    db	0C4h, 0C4h, BOP_UNSIMULATE
	endm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\ddk\inc\isvbop.h ===
/*++ BUILD Version: 0001

Copyright (c) 1990-1999 Microsoft Corporation

Module Name:

    ISVBOP.H

Abstract:

    This is the header file supporting third party bops.
    isvbop.inc is the inc file for this h file.

Note:
    Following include file uses 'DB' to define assembly macros. Some
    assemblers use 'emit' instead. If you are using such a compiler,
    you will have to change db's to emit's.

--*/


#if _MSC_VER > 1000
#pragma once
#endif

#define BOP_3RDPARTY 0x58
#define BOP_UNSIMULATE 0xFE

/* XLATOFF */

/** RegisterModule - This Bop call is made from the 16 bit module
 *		     to register a third party DLL with the bop
 *		     manager. This call returns a handle to the
 *		     16bit caller which is to be used later to
 *		     dispatch a call to the DLL.
 *
 *  INPUT:
 *	Client DS:SI - asciiz string of DLL name.
 *      Client ES:DI - asciiz string of Init Routine in the DLL. (Optional)
 *	Client DS:BX - asciiz string to Dispatch routine in the DLL.
 *
 *  OUTPUT:
 *	SUCCESS:
 *	    Client Carry Clear
 *	    Client AX = Handle (non Zero)
 *	FAILURE:
 *	    Client Carry Set
 *	    Client AX = Error Code
 *		    AX = 1 - DLL not found
 *		    AX = 2 - Dispacth routine not found.
 *		    AX = 3 - Init Routine Not Found
 *		    AX = 4 - Insufficient Memory
 *
 *  NOTES:
 *	RegisterModule results in loading the DLL (specified in DS:SI).
 *      Its Init routine (specified in ES:DI) is called. Its Dispatch
 *	routine (specified in DS:BX) is stored away and all the calls
 *      made from DispatchCall are dispacthed to this routine.
 *      If ES and DI both are null than the caller did'nt supply the init
 *      routine.
 */

#define RegisterModule() _asm _emit 0xC4 _asm _emit 0xC4 _asm _emit BOP_3RDPARTY _asm _emit 0x0

/** UnRegisterModule - This Bop call is made from the 16 bit module
 *		       to unregister a third party DLL with the bop
 *		       manager.
 *
 *  INPUT:
 *	Client AX - Handle returned by RegisterModule Call.
 *
 *  OUTPUT:
 *	None (VDM Is terminated with a debug message if Handle is invalid)
 *
 *  NOTES:
 *	Use it if initialization of 16bit app fails after registering the
 *	Bop.
 */

#define UnRegisterModule() _asm _emit 0xC4 _asm _emit 0xC4 _asm _emit BOP_3RDPARTY _asm _emit 0x1

/** DispacthCall - This Bop call is made from the 16 bit module
 *		   to pass a request to its DLL.
 *
 *  INPUT:
 *	Client AX - Handle returned by RegisterModule Call.
 *
 *  OUTPUT:
 *	None (DLL should set the proper output registers etc.)
 *	(VDM Is terminated with a debug message if Handle is invalid)
 *
 *  NOTES:
 *	Use it to pass a request to 32bit DLL. The request index and the
 *	parameters are passed in different registers. These register settings
 *	are private to the 16bit module and its associated VDD. Bop manager
 *	does'nt know anything about these registers.
 */
#define DispatchCall()	 _asm _emit 0xC4 _asm _emit 0xC4 _asm _emit BOP_3RDPARTY _asm _emit 0x2

/*** VDDUnSimulate16
 *
 *   This service causes the simulation of intel instructions to stop and
 *   control to return to VDD.
 *
 *   INPUT
 *      None
 *
 *   OUTPUT
 *      None
 *
 *   NOTES
 *      This service is a macro intended for 16bit stub-drivers. At the
 *      end of worker routine stub-driver should use it.
 */

#define VDDUnSimulate16() _asm _emit 0xC4 _asm _emit 0xC4 _asm _emit BOP_UNSIMULATE

/* XLATON */


/* ASM
RegisterModule macro
    db	0C4h, 0C4h, BOP_3RDPARTY, 0
        endm

UnRegisterModule macro
    db	0C4h, 0C4h, BOP_3RDPARTY, 1
	endm

DispatchCall macro
    db	0C4h, 0C4h, BOP_3RDPARTY, 2
	endm

VDDUnSimulate16 macro
    db	0C4h, 0C4h, BOP_UNSIMULATE
	endm

 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\ddk\inc\ipfirewall.h ===
/*++

Copyright (c) 1999-2001  Microsoft Corporation

Module Name:

    ipfirewall.h

Abstract:

    Header file for IP firewall hook clients.

--*/

#define INVALID_IF_INDEX        0xffffffff
#define LOCAL_IF_INDEX          0

//
// Indicates whether it is a transmitted or received packet.
//

typedef enum _IP_DIRECTION_E {
    IP_TRANSMIT,
    IP_RECEIVE
} DIRECTION_E, *PDIRECTION_E;

typedef struct _FIREWALL_CONTEXT_T {
    DIRECTION_E Direction;
    void        *NTE;
    void        *LinkCtxt;
    NDIS_HANDLE LContext1;
    UINT        LContext2;
} FIREWALL_CONTEXT_T, *PFIREWALL_CONTEXT_T;

//  Definition of an IP receive buffer chain.
typedef struct IPRcvBuf {
    struct IPRcvBuf *ipr_next;          // Next buffer descriptor in chain.
    UINT            ipr_owner;          // Owner of buffer.
    UCHAR           *ipr_buffer;        // Pointer to buffer.
    UINT            ipr_size;           // Buffer size.
    PMDL            ipr_pMdl;
    UINT            *ipr_pClientCnt;
    UCHAR           *ipr_RcvContext;
    UINT            ipr_RcvOffset;
    ULONG           ipr_flags;
} IPRcvBuf;

#define IPR_FLAG_CHECKSUM_OFFLOAD   0x00000002

//
// Enum for values that may be returned from filter routine.
//

typedef enum _FORWARD_ACTION {
    FORWARD         = 0,
    DROP            = 1,
    ICMP_ON_DROP    = 2
} FORWARD_ACTION;


// Definiton for a firewall routine callout.
typedef FORWARD_ACTION
(*IPPacketFirewallPtr)(
    VOID        **pData,
    UINT        RecvInterfaceIndex,
    UINT        *pSendInterfaceIndex,
    UCHAR       *pDestinationType,
    VOID        *pContext,
    UINT        ContextLength,
    IPRcvBuf    **ppRcvBuf
    );

extern
int
IPAllocBuff(
    IPRcvBuf    *pRcvBuf,
    UINT        Size
    );

extern
VOID
IPFreeBuff(
    IPRcvBuf    *pRcvBuf
    );

extern
VOID
FreeIprBuff(
    IPRcvBuf    *pRcvBuf
    );

typedef enum _IPROUTEINFOCLASS {
    IPRouteNoInformation,
    IPRouteOutgoingFirewallContext,
    IPRouteOutgoingFilterContext,
    MaxIPRouteInfoClass
} IPROUTEINFOCLASS;

extern
NTSTATUS
LookupRouteInformation(
    IN      VOID*               RouteLookupData,
    OUT     VOID*               RouteEntry OPTIONAL,
    IN      IPROUTEINFOCLASS    RouteInfoClass OPTIONAL,
    OUT     VOID*               RouteInformation OPTIONAL,
    IN OUT  UINT*               RouteInfoLength OPTIONAL
    );

// Structure passed to the IPSetFirewallHook call

typedef struct _IP_SET_FIREWALL_HOOK_INFO {
    IPPacketFirewallPtr FirewallPtr;    // Packet filter callout.
    UINT                Priority;       // Priority of the hook
    BOOLEAN             Add;            // if TRUE then ADD else DELETE
} IP_SET_FIREWALL_HOOK_INFO, *PIP_SET_FIREWALL_HOOK_INFO;


#define DEST_LOCAL          0           // Destination is local.
#define DEST_BCAST          0x01        // Destination is net or local bcast.
#define DEST_SN_BCAST       0x03        // A subnet bcast.
#define DEST_MCAST          0x05        // A local mcast.
#define DEST_REMOTE         0x08        // Destination is remote.
#define DEST_REM_BCAST      0x0b        // Destination is a remote broadcast
#define DEST_REM_MCAST      0x0d        // Destination is a remote mcast.
#define DEST_INVALID        0xff        // Invalid destination

#define DEST_PROMIS         0x20        // Dest is promiscuous

#define DEST_BCAST_BIT      0x01
#define DEST_OFFNET_BIT     0x10        // Destination is offnet -
                                        // used only by upper layer
                                        // callers.
#define DEST_MCAST_BIT      0x05

#define DD_IP_DEVICE_NAME   L"\\Device\\Ip"

#define FSCTL_IP_BASE       FILE_DEVICE_NETWORK

#define _IP_CTL_CODE(function, method, access) \
            CTL_CODE(FSCTL_IP_BASE, function, method, access)

#define IOCTL_IP_SET_FIREWALL_HOOK  \
            _IP_CTL_CODE(12, METHOD_BUFFERED, FILE_WRITE_ACCESS)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\ddk\inc\ioevent.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    ioevent.h

Abstract:

    This module contains the GUIDS and event structures for io system
    initiated events.  These events are reported in kernel mode and are
    available to both user mode and kernel mode clients.

Author:

    Mark Zbikowski (markz) 3/18/98


Revision History:


--*/

//
//  Label change event.  This event is signalled upon successful completion
//  of a label change.  There is no additional data.
//

DEFINE_GUID( GUID_IO_VOLUME_CHANGE, 0x7373654aL, 0x812a, 0x11d0, 0xbe, 0xc7, 0x08, 0x00, 0x2b, 0xe2, 0x09, 0x2f );

//
//  Volume dismount event.  This event is signalled when an attempt is made to
//  dismount a volume.  There is no additional data.  Note that this will not
//  necessarily be preceded by a GUID_IO_VOLUME_LOCK notification.
//

DEFINE_GUID( GUID_IO_VOLUME_DISMOUNT, 0xd16a55e8L, 0x1059, 0x11d2, 0x8f, 0xfd, 0x00, 0xa0, 0xc9, 0xa0, 0x6d, 0x32 );

//
//  Volume dismount failed event.  This event is signalled when a volume dismount fails.
//  There is no additional data.
//

DEFINE_GUID( GUID_IO_VOLUME_DISMOUNT_FAILED, 0xe3c5b178L, 0x105d, 0x11d2, 0x8f, 0xfd, 0x00, 0xa0, 0xc9, 0xa0, 0x6d, 0x32 );

//
//  Volume mount event.  This event is signalled when a volume mount occurs.
//  There is no additional data.
//

DEFINE_GUID( GUID_IO_VOLUME_MOUNT, 0xb5804878L, 0x1a96, 0x11d2, 0x8f, 0xfd, 0x00, 0xa0, 0xc9, 0xa0, 0x6d, 0x32 );

//
//  Volume lock event.  This event is signalled when an attempt is made to
//  lock a volume.  There is no additional data.
//

DEFINE_GUID( GUID_IO_VOLUME_LOCK, 0x50708874L, 0xc9af, 0x11d1, 0x8f, 0xef, 0x00, 0xa0, 0xc9, 0xa0, 0x6d, 0x32 );

//
//  Volume lock failed event.  This event is signalled when an attempt is made to
//  lock a volume, but it fails.  There is no additional data.
//

DEFINE_GUID( GUID_IO_VOLUME_LOCK_FAILED, 0xae2eed10L, 0x0ba8, 0x11d2, 0x8f, 0xfb, 0x00, 0xa0, 0xc9, 0xa0, 0x6d, 0x32 );


//
//  Volume unlock event.  This event is signalled when an attempt is made to
//  unlock a volume.  There is no additional data.
//

DEFINE_GUID( GUID_IO_VOLUME_UNLOCK, 0x9a8c3d68L, 0xd0cb, 0x11d1, 0x8f, 0xef, 0x00, 0xa0, 0xc9, 0xa0, 0x6d, 0x32 );


//
//  Volume name change.  This event is signalled when the list of persistent
//  names (like drive letters) for a volume changes.  There is no additional
//  data.
//

DEFINE_GUID( GUID_IO_VOLUME_NAME_CHANGE, 0x2de97f83, 0x4c06, 0x11d2, 0xa5, 0x32, 0x0, 0x60, 0x97, 0x13, 0x5, 0x5a);


//
//  Volume physical configuration change.  This event is signalled when the
//  physical makeup or current physical state of the volume changes.
//

DEFINE_GUID( GUID_IO_VOLUME_PHYSICAL_CONFIGURATION_CHANGE, 0x2de97f84, 0x4c06, 0x11d2, 0xa5, 0x32, 0x0, 0x60, 0x97, 0x13, 0x5, 0x5a);


//
//  Volume device interface.  This is a device interface GUID that appears
//  when the device object associated with a volume is created and disappears
//  when the device object associated with the volume is destroyed.
//

DEFINE_GUID( GUID_IO_VOLUME_DEVICE_INTERFACE, 0x53f5630d, 0xb6bf, 0x11d0, 0x94, 0xf2, 0x00, 0xa0, 0xc9, 0x1e, 0xfb, 0x8b);



//
//  Sent when the removable media is changed (added, removed) from a device
//  (such as a CDROM, tape, changer, etc).
//
//  The additional data is a DWORD representing the data event.
//

DEFINE_GUID( GUID_IO_MEDIA_ARRIVAL,         0xd07433c0, 0xa98e, 0x11d2, 0x91, 0x7a, 0x00, 0xa0, 0xc9, 0x06, 0x8f, 0xf3);
DEFINE_GUID( GUID_IO_MEDIA_REMOVAL,         0xd07433c1, 0xa98e, 0x11d2, 0x91, 0x7a, 0x00, 0xa0, 0xc9, 0x06, 0x8f, 0xf3);

//
// Sent when the media is returning that it is not ready right now, but will
// be ready soon. This can be because the drive has spun down to save power
// or because new media has been inserted but is not ready for access yet.
//

DEFINE_GUID( GUID_IO_DEVICE_BECOMING_READY, 0xd07433f0, 0xa98e, 0x11d2, 0x91, 0x7a, 0x00, 0xa0, 0xc9, 0x06, 0x8f, 0xf3);

typedef struct _DEVICE_EVENT_BECOMING_READY {
    ULONG Version;
    ULONG Reason;
    ULONG Estimated100msToReady;
} DEVICE_EVENT_BECOMING_READY, *PDEVICE_EVENT_BECOMING_READY;

//
// Sent when the user presses the eject button on the front of the drive,
// or when other buttons on the front are pressed via GESN command polling
// (GESN support to be added)
//

DEFINE_GUID( GUID_IO_DEVICE_EXTERNAL_REQUEST, 0xd07433d0, 0xa98e, 0x11d2, 0x91, 0x7a, 0x00, 0xa0, 0xc9, 0x06, 0x8f, 0xf3);
DEFINE_GUID( GUID_IO_MEDIA_EJECT_REQUEST,     0xd07433d1, 0xa98e, 0x11d2, 0x91, 0x7a, 0x00, 0xa0, 0xc9, 0x06, 0x8f, 0xf3);

typedef struct _DEVICE_EVENT_EXTERNAL_REQUEST {
    ULONG  Version;
    ULONG  DeviceClass;       // 0 == MMC Storage Devices
    USHORT ButtonStatus;      // 1 == down, 2 == up
    USHORT Request;
    LARGE_INTEGER SystemTime; // for time-related info
} DEVICE_EVENT_EXTERNAL_REQUEST, *PDEVICE_EVENT_EXTERNAL_REQUEST;

//
// Sent when a tape drive requires cleaning
//
DEFINE_GUID(GUID_IO_DRIVE_REQUIRES_CLEANING, 0x7207877c, 0x90ed, 0x44e5, 0xa0, 0x0, 0x81, 0x42, 0x8d, 0x4c, 0x79, 0xbb);

//
// Sent when a tape is erased
//
DEFINE_GUID(GUID_IO_TAPE_ERASE, 0x852d11eb, 0x4bb8, 0x4507, 0x9d, 0x9b, 0x41, 0x7c, 0xc2, 0xb1, 0xb4, 0x38);

typedef struct _DEVICE_EVENT_GENERIC_DATA {
    ULONG EventNumber;
} DEVICE_EVENT_GENERIC_DATA, *PDEVICE_EVENT_GENERIC_DATA;


//
//  Represents any asynchronous notification coming from a device driver whose
//  notification protocol is RBC
//  Additional data is provided

DEFINE_GUID( GUID_DEVICE_EVENT_RBC, 0xd0744792, 0xa98e, 0x11d2, 0x91, 0x7a, 0x00, 0xa0, 0xc9, 0x06, 0x8f, 0xf3);

typedef struct _DEVICE_EVENT_RBC_DATA {
    ULONG EventNumber;
    UCHAR SenseQualifier;
    UCHAR SenseCode;
    UCHAR SenseKey;
    UCHAR Reserved;
    ULONG Information;
} DEVICE_EVENT_RBC_DATA, *PDEVICE_EVENT_RBC_DATA;

//
//  A clone of this disk has just arrived in the system.
//

DEFINE_GUID( GUID_IO_DISK_CLONE_ARRIVAL, 0x6a61885b, 0x7c39, 0x43dd, 0x9b, 0x56, 0xb8, 0xac, 0x22, 0xa5, 0x49, 0xaa);

typedef struct _GUID_IO_DISK_CLONE_ARRIVAL_INFORMATION {
    ULONG DiskNumber;   // The disk number of the new disk arriving in the system.
} GUID_IO_DISK_CLONE_ARRIVAL_INFORMATION, *PGUID_IO_DISK_CLONE_ARRIVAL_INFORMATION;

//
// The disk layout has changed
//

DEFINE_GUID( GUID_IO_DISK_LAYOUT_CHANGE, 0x11dff54c, 0x8469, 0x41f9, 0xb3, 0xde, 0xef, 0x83, 0x64, 0x87, 0xc5, 0x4a);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\ddk\inc\kcom.h ===
/*++

Copyright (c) 1997-1998 Microsoft Corporation.

Module Name:

    kcom.h

Abstract:

    Kernel COM

--*/

#if !defined(_KS_)
#error KS.H must be included before KCOM.H
#endif // !defined(_KS_)

#if !defined(_KCOM_)
#define _KCOM_

#if defined(__cplusplus)
extern "C" {
#endif // defined(__cplusplus)

#define STATIC_KoCreateObject \
    0x72CF721CL, 0x525A, 0x11D1, 0x9A, 0xA1, 0x00, 0xa0, 0xc9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("72CF721C-525A-11D1-9AA1-00A0C9223196", KoCreateObject);

#define KOSTRING_CreateObject L"{72CF721C-525A-11D1-9AA1-00A0C9223196}"

#ifndef CLSCTX_KERNEL_SERVER
#define CLSCTX_KERNEL_SERVER    0x00000200
#endif

typedef
NTSTATUS
(*KoCreateObjectHandler)(
    IN REFCLSID ClassId,
    IN IUnknown* UnkOuter OPTIONAL,
    IN REFIID InterfaceId,
    OUT PVOID* Interface
    );

#undef INTERFACE
#define INTERFACE INonDelegatedUnknown
DECLARE_INTERFACE(INonDelegatedUnknown) {
    STDMETHOD(NonDelegatedQueryInterface)(
        THIS_
        IN REFIID InterfaceId,
        OUT PVOID* Interface
        ) PURE;

    STDMETHOD_(ULONG,NonDelegatedAddRef)(
        THIS
        ) PURE;

    STDMETHOD_(ULONG,NonDelegatedRelease)(
        THIS
        ) PURE;
};

#undef INTERFACE
#define INTERFACE IIndirectedUnknown
DECLARE_INTERFACE(IIndirectedUnknown) {
    STDMETHOD(IndirectedQueryInterface)(
        THIS_
        IN REFIID InterfaceId,
        OUT PVOID* Interface
        ) PURE;

    STDMETHOD_(ULONG,IndirectedAddRef)(
        THIS
        ) PURE;

    STDMETHOD_(ULONG,IndirectedRelease)(
        THIS
        ) PURE;
};

#if !defined(__cplusplus) || _MSC_VER < 1100
#define STATIC_IID_IKoInitializeParentDeviceObject\
    0x21B36996L, 0x8DE3, 0x11D1, 0x8A, 0xE0, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDEX(IID_IKoInitializeParentDeviceObject);
#else
interface __declspec(uuid("21B36996-8DE3-11D1-8AE0-00A0C9223196")) IKoInitializeParentDeviceObject;
#endif
#undef INTERFACE
#define INTERFACE IKoInitializeParentDeviceObject
DECLARE_INTERFACE_(IKoInitializeParentDeviceObject, IUnknown) {
    STDMETHOD(SetParentDeviceObject)(
        THIS_
        IN PDEVICE_OBJECT ParentDeviceObject
        ) PURE;
};

#ifndef COMDDKMETHOD
#ifdef _COMDDK_
#define COMDDKMETHOD
#else // !_COMDDK_
#define COMDDKMETHOD DECLSPEC_IMPORT
#endif // _COMDDK_
#endif // !COMDDKMETHOD

#ifdef _COMDDK_
#define COMDDKAPI
#else // !_COMDDK_
#define COMDDKAPI DECLSPEC_IMPORT
#endif // _COMDDK_

#if defined(__cplusplus)
class CBaseUnknown : public INonDelegatedUnknown, public IIndirectedUnknown {

protected:
    LONG m_RefCount;

private:
    BOOLEAN m_UsingClassId;
    CLSID m_ClassId;

protected:
    IUnknown* m_UnknownOuter;

public:
    COMDDKMETHOD CBaseUnknown(
        IN REFCLSID ClassId,
        IN IUnknown* UnknownOuter OPTIONAL = NULL
        );
    COMDDKMETHOD CBaseUnknown(
        IN IUnknown* UnknownOuter OPTIONAL = NULL
        );
    COMDDKMETHOD virtual ~CBaseUnknown();

    // INonDelegatedUnknown
    COMDDKMETHOD STDMETHODIMP_(ULONG) NonDelegatedAddRef();
    COMDDKMETHOD STDMETHODIMP_(ULONG) NonDelegatedRelease();
    COMDDKMETHOD STDMETHODIMP NonDelegatedQueryInterface(
        IN REFIID InterfaceId,
        OUT PVOID* Interface
        );

    //IIndirectedUnknown
    COMDDKMETHOD STDMETHODIMP_(ULONG) IndirectedAddRef();
    COMDDKMETHOD STDMETHODIMP_(ULONG) IndirectedRelease();
    COMDDKMETHOD STDMETHODIMP IndirectedQueryInterface(
        IN REFIID InterfaceId,
        OUT PVOID* Interface
        );
};

#if !defined(DEFINE_ABSTRACT_UNKNOWN)

#define DEFINE_ABSTRACT_UNKNOWN()                               \
    STDMETHOD(QueryInterface)(THIS_                             \
        REFIID InterfaceId,                                     \
        PVOID* Interface                                        \
        ) PURE;                                                 \
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;                        \
    STDMETHOD_(ULONG,Release)(THIS) PURE;

#endif //!defined(DEFINE_ABSTRACT_UNKNOWN)

#define DEFINE_STD_UNKNOWN()                                    \
    STDMETHODIMP NonDelegatedQueryInterface(                    \
        REFIID InterfaceId,                                     \
        PVOID* Interface                                        \
    );                                                          \
    STDMETHODIMP QueryInterface(                                \
        REFIID InterfaceId,                                     \
        PVOID* Interface                                        \
        );                                                      \
    STDMETHODIMP_(ULONG) AddRef();                              \
    STDMETHODIMP_(ULONG) Release();

#define IMPLEMENT_STD_UNKNOWN(Class)                            \
    STDMETHODIMP Class::QueryInterface(                         \
        REFIID InterfaceId,                                     \
        PVOID* Interface                                        \
        )                                                       \
    {                                                           \
        return m_UnknownOuter->QueryInterface(InterfaceId, Interface);\
    }                                                           \
    STDMETHODIMP_(ULONG) Class::AddRef()                        \
    {                                                           \
        return m_UnknownOuter->AddRef();                        \
    }                                                           \
    STDMETHODIMP_(ULONG) Class::Release()                       \
    {                                                           \
        return m_UnknownOuter->Release();                       \
    }
#else // !__cplusplus
COMDDKAPI
void
NTAPI
KoRelease(
    IN REFCLSID ClassId
    );
#endif // !__cplusplus

COMDDKAPI
NTSTATUS
NTAPI
KoCreateInstance(
    IN REFCLSID ClassId,
    IN IUnknown* UnkOuter OPTIONAL,
    IN ULONG ClsContext,
    IN REFIID InterfaceId,
    OUT PVOID* Interface
    );
COMDDKAPI
NTSTATUS
NTAPI
KoDriverInitialize(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPathName,
    IN KoCreateObjectHandler CreateObjectHandler
    );
COMDDKAPI
NTSTATUS
NTAPI
KoDeviceInitialize(
    IN PDEVICE_OBJECT DeviceObject
    );

#if defined(__cplusplus)
}
#endif // defined(__cplusplus)

#ifdef __cplusplus

#ifndef _NEW_DELETE_OPERATORS_
#define _NEW_DELETE_OPERATORS_

inline PVOID operator new
(
    size_t          iSize,
    POOL_TYPE       poolType
)
{
    PVOID result = ExAllocatePoolWithTag(poolType,iSize,'wNCK');

    if (result) {
        RtlZeroMemory(result,iSize);
    }

    return result;
}

inline PVOID operator new
(
    size_t          iSize,
    POOL_TYPE       poolType,
    ULONG           tag
)
{
    PVOID result = ExAllocatePoolWithTag(poolType,iSize,tag);

    if (result) {
        RtlZeroMemory(result,iSize);
    }

    return result;
}

inline void __cdecl operator delete
(
    PVOID pVoid
)
{
    ExFreePool(pVoid);
}

#endif //!_NEW_DELETE_OPERATORS_

#if defined(_SYS_GUID_OPERATOR_EQ_)
// Define _SYS_GUID_OPERATOR_EQ_ before including guiddef.h to get the aligned guid test.
#define _GUID_OPERATORS_
#pragma message("WARNING: Using system operator==/!= for GUIDs")
#endif

#ifndef _GUID_OPERATORS_
#define _GUID_OPERATORS_

__inline BOOL operator==(const GUID& guidOne, const GUID& guidOther)
{
    return IsEqualGUIDAligned(guidOne,guidOther);
}
__inline BOOL operator!=(const GUID& guidOne, const GUID& guidOther)
{
    return !(guidOne == guidOther);
}

#endif // _GUID_OPERATORS_

#endif // __cplusplus

#endif // !_KCOM_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\ddk\inc\ksdebug.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    ksdebug.h

Abstract:

    Debug header.

--*/

#if !defined(_KSDEBUG_)
#define _KSDEBUG_

#if !defined(REMIND)

#define QUOTE(x) #x
#define QQUOTE(y) QUOTE(y)
#define REMIND(str) __FILE__ "(" QQUOTE(__LINE__) ") : " str

#endif // !defined(REMIND)

#if defined(__cplusplus)
extern "C" {
#endif // defined(__cplusplus)

#if defined(_NTDDK_)

#define DEBUGLVL_BLAB    3
#define DEBUGLVL_VERBOSE 2
#define DEBUGLVL_TERSE   1
#define DEBUGLVL_ERROR   0

#if (DBG)
   #if !defined( DEBUG_LEVEL )
        #if defined( DEBUG_VARIABLE )
            #if defined( KSDEBUG_INIT )
                ULONG DEBUG_VARIABLE = DEBUGLVL_TERSE;
            #else
                extern ULONG DEBUG_VARIABLE;
            #endif
        #else
            #define DEBUG_VARIABLE DEBUGLVL_TERSE
        #endif
   #else
        #if defined( DEBUG_VARIABLE )
            #if defined( KSDEBUG_INIT )
                ULONG DEBUG_VARIABLE = DEBUG_LEVEL;
            #else
                extern ULONG DEBUG_VARIABLE;
            #endif
        #else
            #define DEBUG_VARIABLE DEBUG_LEVEL
        #endif
   #endif

   #define _DbgPrintF(lvl, strings) \
{ \
    if (((lvl)==DEBUG_VARIABLE) || (lvl < DEBUG_VARIABLE)) {\
        DbgPrint(STR_MODULENAME);\
        DbgPrint##strings;\
        DbgPrint("\n");\
        if ((lvl) == DEBUGLVL_ERROR) {\
            DbgBreakPoint();\
        } \
    } \
}

   #define _DbgPrintFEx(component, lvl, strings) \
{ \
    if ((lvl) <= DEBUG_VARIABLE) {\
        DbgPrintEx(component, lvl, STR_MODULENAME);\
        DbgPrintEx(component, lvl, strings);\
        DbgPrintEx(component, lvl, "\n");\
        if ((lvl) == DEBUGLVL_ERROR) {\
            DbgBreakPoint();\
        } \
    } \
}
#else // !DBG
   #define _DbgPrintF(lvl, strings)
   #define _DbgPrintFEx(component, lvl, strings)
#endif // !DBG

#endif // !defined(_NTDDK_)

//
// macros
//

#if defined(__cplusplus)
}
#endif // defined(__cplusplus)

//
// constants
//

#if (DBG)

#if defined(IRPMJFUNCDESC)
static const PCHAR IrpMjFuncDesc[] =
{
   "IRP_MJ_CREATE",
   "IRP_MJ_CREATE_NAMED_PIPE",
   "IRP_MJ_CLOSE",
   "IRP_MJ_READ",
   "IRP_MJ_WRITE",
   "IRP_MJ_QUERY_INFORMATION",
   "IRP_MJ_SET_INFORMATION",
   "IRP_MJ_QUERY_EA",
   "IRP_MJ_SET_EA",
   "IRP_MJ_FLUSH_BUFFERS",
   "IRP_MJ_QUERY_VOLUME_INFORMATION",
   "IRP_MJ_SET_VOLUME_INFORMATION",
   "IRP_MJ_DIRECTORY_CONTROL",
   "IRP_MJ_FILE_SYSTEM_CONTROL",
   "IRP_MJ_DEVICE_CONTROL",
   "IRP_MJ_INTERNAL_DEVICE_CONTROL",
   "IRP_MJ_SHUTDOWN",
   "IRP_MJ_LOCK_CONTROL",
   "IRP_MJ_CLEANUP",
   "IRP_MJ_CREATE_MAILSLOT",
   "IRP_MJ_QUERY_SECURITY",
   "IRP_MJ_SET_SECURITY",
   "IRP_MJ_SET_POWER",
   "IRP_MJ_QUERY_POWER"
};
#endif // defined(IRPMJFUNCDESC)

#endif // DBG

#endif // !_KSDEBUG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\ddk\inc\kbdmou.h ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    kbdmou.h

Abstract:

    These are the structures and defines that are used in the
    keyboard class driver, mouse class driver, and keyboard/mouse port
    driver.

Author:

    lees

Revision History:

--*/

#ifndef _KBDMOU_
#define _KBDMOU_

#include <ntddkbd.h>
#include <ntddmou.h>

//
// Define the keyboard/mouse port device name strings.
//

#define DD_KEYBOARD_PORT_DEVICE_NAME    "\\Device\\KeyboardPort"
#define DD_KEYBOARD_PORT_DEVICE_NAME_U L"\\Device\\KeyboardPort"
#define DD_KEYBOARD_PORT_BASE_NAME_U   L"KeyboardPort"
#define DD_POINTER_PORT_DEVICE_NAME     "\\Device\\PointerPort"
#define DD_POINTER_PORT_DEVICE_NAME_U  L"\\Device\\PointerPort"
#define DD_POINTER_PORT_BASE_NAME_U    L"PointerPort"

//
// Define the keyboard/mouse class device name strings.
//

#define DD_KEYBOARD_CLASS_BASE_NAME_U   L"KeyboardClass"
#define DD_POINTER_CLASS_BASE_NAME_U    L"PointerClass"

//
// Define the keyboard/mouse resource class names.
//

#define DD_KEYBOARD_RESOURCE_CLASS_NAME_U             L"Keyboard"
#define DD_POINTER_RESOURCE_CLASS_NAME_U              L"Pointer"
#define DD_KEYBOARD_MOUSE_COMBO_RESOURCE_CLASS_NAME_U L"Keyboard/Pointer"

//
// Define the maximum number of pointer/keyboard port names the port driver
// will use in an attempt to IoCreateDevice.
//

#define POINTER_PORTS_MAXIMUM  8
#define KEYBOARD_PORTS_MAXIMUM 8

//
// Define the port connection data structure.
//

typedef struct _CONNECT_DATA {
    IN PDEVICE_OBJECT ClassDeviceObject;
    IN PVOID ClassService;
} CONNECT_DATA, *PCONNECT_DATA;

//
// Define the service callback routine's structure.
//

typedef
VOID
(*PSERVICE_CALLBACK_ROUTINE) (
    IN PVOID NormalContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2,
    IN OUT PVOID SystemArgument3
    );

//
// WMI structures returned by port drivers
//
#include <wmidata.h>

//
// NtDeviceIoControlFile internal IoControlCode values for keyboard device.
//

#define IOCTL_INTERNAL_KEYBOARD_CONNECT CTL_CODE(FILE_DEVICE_KEYBOARD, 0x0080, METHOD_NEITHER, FILE_ANY_ACCESS)
#define IOCTL_INTERNAL_KEYBOARD_DISCONNECT CTL_CODE(FILE_DEVICE_KEYBOARD,0x0100, METHOD_NEITHER, FILE_ANY_ACCESS)
#define IOCTL_INTERNAL_KEYBOARD_ENABLE  CTL_CODE(FILE_DEVICE_KEYBOARD, 0x0200, METHOD_NEITHER, FILE_ANY_ACCESS)
#define IOCTL_INTERNAL_KEYBOARD_DISABLE CTL_CODE(FILE_DEVICE_KEYBOARD, 0x0400, METHOD_NEITHER, FILE_ANY_ACCESS)

//
// NtDeviceIoControlFile internal IoControlCode values for mouse device.
//


#define IOCTL_INTERNAL_MOUSE_CONNECT    CTL_CODE(FILE_DEVICE_MOUSE, 0x0080, METHOD_NEITHER, FILE_ANY_ACCESS)
#define IOCTL_INTERNAL_MOUSE_DISCONNECT CTL_CODE(FILE_DEVICE_MOUSE, 0x0100, METHOD_NEITHER, FILE_ANY_ACCESS)
#define IOCTL_INTERNAL_MOUSE_ENABLE     CTL_CODE(FILE_DEVICE_MOUSE, 0x0200, METHOD_NEITHER, FILE_ANY_ACCESS)
#define IOCTL_INTERNAL_MOUSE_DISABLE    CTL_CODE(FILE_DEVICE_MOUSE, 0x0400, METHOD_NEITHER, FILE_ANY_ACCESS)

//
// Error log definitions (specific to the keyboard/mouse) for DumpData[0]
// in the IO_ERROR_LOG_PACKET.
//
//     DumpData[1] <= hardware port/register
//     DumpData[2] <= {command byte || expected response byte}
//     DumpData[3] <= {command's parameter byte || actual response byte}
//
//

#define KBDMOU_COULD_NOT_SEND_COMMAND  0x0000
#define KBDMOU_COULD_NOT_SEND_PARAM    0x0001
#define KBDMOU_NO_RESPONSE             0x0002
#define KBDMOU_INCORRECT_RESPONSE      0x0004

//
// Define the base values for the error log packet's UniqueErrorValue field.
//

#define I8042_ERROR_VALUE_BASE        1000
#define INPORT_ERROR_VALUE_BASE       2000
#define SERIAL_MOUSE_ERROR_VALUE_BASE 3000

#endif // _KBDMOU_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\ddk\inc\ksi.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    ksi.h

Abstract:

    Windows Driver Model/Connection and Streaming Architecture (WDM-CSA)
    core internal definitions.

--*/

#if !defined(_KSI_)
#define _KSI_

#if defined(__cplusplus)
extern "C" {
#endif // defined(__cplusplus)

#if defined(_NTDDK_)

typedef struct {
    LONGLONG Frequency;
    LONGLONG LastDueTime;
    LONGLONG RunningTimeDelta;
    LONGLONG LastRunningTime;
    KSPIN_LOCK TimeAccessLock;
    LIST_ENTRY EventQueue;
    KSPIN_LOCK EventQueueLock;
    KTIMER QueueTimer;
    KDPC QueueDpc;
    LONG ReferenceCount;
    KSSTATE State;
    LONGLONG SuspendDelta;
    LONGLONG SuspendTime;
    PFNKSSETTIMER SetTimer;
    PFNKSCANCELTIMER CancelTimer;
    PFNKSCLOCK_CORRELATEDTIME CorrelatedTime;
    PVOID Context;
    KSRESOLUTION Resolution;
    KEVENT FreeEvent;
    LONG ExternalTimeReferenceCount;
    BOOLEAN ExternalTimeValid;
    LONGLONG LastStreamTime;
} KSIDEFAULTCLOCK, *PKSIDEFAULTCLOCK;

typedef struct {
    KSOBJECT_HEADER Header;
    PKSIDEFAULTCLOCK DefaultClock;
    ULONG Reserved;
} KSCLOCKINSTANCE, *PKSCLOCKINSTANCE;

KSDDKAPI
NTSTATUS
NTAPI
KsiPropertyDefaultClockGetTime(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    OUT PLONGLONG Time
    );

KSDDKAPI
NTSTATUS
NTAPI
KsiPropertyDefaultClockGetPhysicalTime(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    OUT PLONGLONG Time
    );

KSDDKAPI
NTSTATUS
NTAPI
KsiPropertyDefaultClockGetCorrelatedTime(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    OUT PKSCORRELATED_TIME Time
    );

KSDDKAPI
NTSTATUS
NTAPI
KsiPropertyDefaultClockGetCorrelatedPhysicalTime(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    OUT PKSCORRELATED_TIME Time
    );

KSDDKAPI
NTSTATUS
NTAPI
KsiPropertyDefaultClockGetResolution(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    OUT PKSRESOLUTION Resolution
    );

KSDDKAPI
NTSTATUS
NTAPI
KsiPropertyDefaultClockGetState(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    OUT PKSSTATE State
    );

KSDDKAPI
NTSTATUS
NTAPI
KsiPropertyDefaultClockGetFunctionTable(
    IN PIRP Irp,
    IN PKSPROPERTY Property,
    OUT PKSCLOCK_FUNCTIONTABLE FunctionTable
    );

KSDDKAPI
NTSTATUS
NTAPI
KsiDefaultClockAddMarkEvent(
    IN PIRP Irp,
    IN PKSEVENT_TIME_INTERVAL EventTime,
    IN PKSEVENT_ENTRY EventEntry
    );

KSDDKAPI
BOOLEAN
NTAPI
KsiQueryObjectCreateItemsPresent(
    IN KSDEVICE_HEADER Header
    );

#endif // !defined(_NTDDK_)

#define STATIC_KSNAME_Server\
    0x3C0D501AL, 0x140B, 0x11D1, 0xB4, 0x0F, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("3C0D501A-140B-11D1-B40F-00A0C9223196", KSNAME_Server);
#define KSNAME_Server DEFINE_GUIDNAMED(KSNAME_Server)

#define KSSTRING_Server L"{3C0D501A-140B-11D1-B40F-00A0C9223196}"

#define STATIC_KSPROPSETID_Service \
    0x3C0D501BL, 0x140B, 0x11D1, 0xB4, 0x0F, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("3C0D501B-140B-11D1-B40F-00A0C9223196", KSPROPSETID_Service);
#define KSPROPSETID_Service DEFINE_GUIDNAMED(KSPROPSETID_Service)

typedef enum {
    KSPROPERTY_SERVICE_BUILDCACHE,
    KSPROPERTY_SERVICE_MERIT
} KSPROPERTY_SERVICE;

#define DEFINE_KSPROPERTY_ITEM_SERVICE_BUILDCACHE(SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_SERVICE_BUILDCACHE,\
        NULL,\
        sizeof(KSPROPERTY),\
        sizeof(L"\\\\?\\"),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_SERVICE_MERIT(SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_SERVICE_MERIT,\
        NULL,\
        sizeof(KSPROPERTY),\
        sizeof(ULONG) + sizeof(L"\\\\?\\"),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

#if defined(__cplusplus)
}
#endif // defined(__cplusplus)

#endif // !_KSI_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\ddk\inc\mcd.h ===
/*++

Copyright (C) Microsoft Corporation, 1996 - 1998

Module Name:

    mcd.h

Abstract:

    These are the structures and defines that are used in the
    changer class drivers. The changer class driver is separated
    into two modules. Mcd.c contains code common to all medium
    changer drivers including the driver's major entry points.

Author:

    chuckp (Chuck Park)

Environment:

    Kernel mode

Revision History :

--*/


#include "scsi.h"
#include "ntddchgr.h"
#include <classpnp.h>

#include <wmidata.h>
#include <wmistr.h>

#ifdef DebugPrint
#undef DebugPrint
#endif

#if DBG
#define DebugPrint(x) ChangerClassDebugPrint x
#else
#define DebugPrint(x)
#endif

#define MAXIMUM_CHANGER_INQUIRY_DATA 252

typedef
NTSTATUS
(*CHANGER_COMMAND_ROUTINE)(
    IN PDEVICE_OBJECT  DeviceObject,
    IN PIRP            Irp
    );

typedef 
ULONG
(*CHANGER_EXTENSION_SIZE)(
    IN VOID
    );

typedef 
NTSTATUS
(*CHANGER_INITIALIZE)(
    IN PDEVICE_OBJECT DeviceObject
    );

typedef 
NTSTATUS
(*CHANGER_PERFORM_DIAGNOSTICS)(
    IN PDEVICE_OBJECT DeviceObject,
    OUT PWMI_CHANGER_PROBLEM_DEVICE_ERROR changerDeviceError
    );

typedef
VOID
(*CHANGER_ERROR_ROUTINE)(
    IN PDEVICE_OBJECT DeviceObject,
    IN PSCSI_REQUEST_BLOCK Srb,
    IN NTSTATUS *Status,
    IN BOOLEAN *Retry
    );

typedef struct _MCD_INIT_DATA {

    //
    // Size of this structure.
    //

    ULONG InitDataSize;

    //
    // To return the size of the minidriver extension
    //

    CHANGER_EXTENSION_SIZE ChangerAdditionalExtensionSize;

    //
    // To perform minidriver specific initialization
    //

    CHANGER_INITIALIZE     ChangerInitialize;

    //
    // To perform minidriver specific error processing
    //

    CHANGER_ERROR_ROUTINE  ChangerError;

    //
    // To perform diagnostic tests on the device
    //

    CHANGER_PERFORM_DIAGNOSTICS ChangerPerformDiagnostics;

    //
    // Minidriver dispatch routines
    //

    CHANGER_COMMAND_ROUTINE   ChangerGetParameters;

    CHANGER_COMMAND_ROUTINE   ChangerGetStatus;

    CHANGER_COMMAND_ROUTINE   ChangerGetProductData;

    CHANGER_COMMAND_ROUTINE   ChangerSetAccess;

    CHANGER_COMMAND_ROUTINE   ChangerGetElementStatus;

    CHANGER_COMMAND_ROUTINE   ChangerInitializeElementStatus;

    CHANGER_COMMAND_ROUTINE   ChangerSetPosition;

    CHANGER_COMMAND_ROUTINE   ChangerExchangeMedium;

    CHANGER_COMMAND_ROUTINE   ChangerMoveMedium;

    CHANGER_COMMAND_ROUTINE   ChangerReinitializeUnit;

    CHANGER_COMMAND_ROUTINE   ChangerQueryVolumeTags;

} MCD_INIT_DATA, *PMCD_INIT_DATA;

typedef struct _MODE_ELEMENT_ADDRESS_PAGE {

    UCHAR PageCode : 6;
    UCHAR Reserved1 : 1;
    UCHAR PS : 1;
    UCHAR PageLength;
    UCHAR MediumTransportElementAddress[2];
    UCHAR NumberTransportElements[2];
    UCHAR FirstStorageElementAddress[2];
    UCHAR NumberStorageElements[2];
    UCHAR FirstIEPortElementAddress[2];
    UCHAR NumberIEPortElements[2];
    UCHAR FirstDataXFerElementAddress[2];
    UCHAR NumberDataXFerElements[2];
    UCHAR Reserved2[2];

} MODE_ELEMENT_ADDRESS_PAGE, *PMODE_ELEMENT_ADDRESS_PAGE;

typedef struct _MODE_TRANSPORT_GEOMETRY_PAGE {

    UCHAR PageCode : 6;
    UCHAR Reserved1 : 1;
    UCHAR PS : 1;
    UCHAR PageLength;
    UCHAR Flip : 1;
    UCHAR Reserved2: 7;
    UCHAR TransportElementNumber;

} MODE_TRANSPORT_GEOMETRY_PAGE, *PMODE_TRANSPORT_GEOMETRY_PAGE;

//
// Capabilities page decribes the various functions that the device
// supports. Used in GetParameters.
//

typedef struct _MODE_DEVICE_CAPABILITIES_PAGE {

    UCHAR PageCode : 6;
    UCHAR Reserved1 : 1;
    UCHAR PS : 1;
    UCHAR PageLength;
    UCHAR MediumTransport : 1;
    UCHAR StorageLocation : 1;
    UCHAR IEPort : 1;
    UCHAR DataXFer : 1;
    UCHAR Reserved2 : 4;
    UCHAR Reserved3;
    UCHAR MTtoMT : 1;
    UCHAR MTtoST : 1;
    UCHAR MTtoIE : 1;
    UCHAR MTtoDT : 1;
    UCHAR Reserved4 : 4;
    UCHAR STtoMT : 1;
    UCHAR STtoST : 1;
    UCHAR STtoIE : 1;
    UCHAR STtoDT : 1;
    UCHAR Reserved5 : 4;
    UCHAR IEtoMT : 1;
    UCHAR IEtoST : 1;
    UCHAR IEtoIE : 1;
    UCHAR IEtoDT : 1;
    UCHAR Reserved6 : 4;
    UCHAR DTtoMT : 1;
    UCHAR DTtoST : 1;
    UCHAR DTtoIE : 1;
    UCHAR DTtoDT : 1;
    UCHAR Reserved7 : 4;
    UCHAR Reserved8[4];
    UCHAR XMTtoMT : 1;
    UCHAR XMTtoST : 1;
    UCHAR XMTtoIE : 1;
    UCHAR XMTtoDT : 1;
    UCHAR Reserved9 : 4;
    UCHAR XSTtoMT : 1;
    UCHAR XSTtoST : 1;
    UCHAR XSTtoIE : 1;
    UCHAR XSTtoDT : 1;
    UCHAR Reserved10 : 4;
    UCHAR XIEtoMT : 1;
    UCHAR XIEtoST : 1;
    UCHAR XIEtoIE : 1;
    UCHAR XIEtoDT : 1;
    UCHAR Reserved11 : 4;
    UCHAR XDTtoMT : 1;
    UCHAR XDTtoST : 1;
    UCHAR XDTtoIE : 1;
    UCHAR XDTtoDT : 1;
    UCHAR Reserved12 : 4;

} MODE_DEVICE_CAPABILITIES_PAGE, *PMODE_DEVICE_CAPABILITIES_PAGE;

#define MODE_PAGE_DISPLAY 0x22

//
// Structures describing return data from READ_ELEMENT_STATUS
//

typedef struct _ELEMENT_STATUS_HEADER {
    UCHAR FirstElementAddress[2];
    UCHAR NumberOfElements[2];
    UCHAR Reserved1;
    UCHAR ReportByteCount[3];
} ELEMENT_STATUS_HEADER, *PELEMENT_STATUS_HEADER;

typedef struct _ELEMENT_STATUS_PAGE {
    UCHAR ElementType;
    UCHAR Reserved1 : 6;
    UCHAR AVolTag : 1;
    UCHAR PVolTag : 1;
    UCHAR ElementDescriptorLength[2];
    UCHAR Reserved2;
    UCHAR DescriptorByteCount[3];
} ELEMENT_STATUS_PAGE, *PELEMENT_STATUS_PAGE;


typedef struct _ELEMENT_DESCRIPTOR {
        UCHAR ElementAddress[2];
        UCHAR Full : 1;
        UCHAR Reserved1 : 1;
        UCHAR Exception : 1;
        UCHAR Accessible : 1;
        UCHAR Reserved2 : 4;
        UCHAR Reserved3;
        UCHAR AdditionalSenseCode;
        UCHAR AddSenseCodeQualifier;
        UCHAR Lun : 3;
        UCHAR Reserved4 : 1;
        UCHAR LunValid : 1;
        UCHAR IdValid : 1;
        UCHAR Reserved5 : 1;
        UCHAR NotThisBus : 1;
        UCHAR BusAddress;
        UCHAR Reserved6;
        UCHAR Reserved7 : 6;
        UCHAR Invert : 1;
        UCHAR SValid : 1;
        UCHAR SourceStorageElementAddress[2];
} ELEMENT_DESCRIPTOR, *PELEMENT_DESCRIPTOR;


//
// The following routines are the exported entry points for
// all changer class drivers.
//

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

NTSTATUS
ChangerClassInitialize(
    IN  PDRIVER_OBJECT  DriverObject,
    IN  PUNICODE_STRING RegistryPath,
    IN  PMCD_INIT_DATA ChangerInitData
    );

NTSTATUS
ChangerClassCreate (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
ChangerClassDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

PVOID
ChangerClassAllocatePool(
    IN POOL_TYPE PoolType,
    IN ULONG NumberOfBytes
    );

VOID
ChangerClassFreePool(
    IN PVOID PoolToFree
    );

NTSTATUS
ChangerClassSendSrbSynchronous(
    IN PDEVICE_OBJECT DeviceObject,
    IN PSCSI_REQUEST_BLOCK Srb,
    IN PVOID Buffer,
    IN ULONG BufferSize,
    IN BOOLEAN WriteToDevice
    );

VOID
ChangerClassDebugPrint(
    ULONG DebugPrintLevel,
    PCCHAR DebugMessage,
    ...
    );


//
// The following routines are provided by the changer
// device-specific module. Each routine name is
// prefixed with 'Changer.'


ULONG
ChangerAdditionalExtensionSize(
    VOID
    );

NTSTATUS
ChangerInitialize(
    IN PDEVICE_OBJECT DeviceObject
    );

VOID
ChangerError(
    PDEVICE_OBJECT DeviceObject,
    PSCSI_REQUEST_BLOCK Srb,
    NTSTATUS *Status,
    BOOLEAN *Retry
    );

NTSTATUS
ChangerGetParameters(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
ChangerGetStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
ChangerGetProductData(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
ChangerSetAccess(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
ChangerGetElementStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );


NTSTATUS
ChangerInitializeElementStatus(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
ChangerSetPosition(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
ChangerExchangeMedium(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
ChangerMoveMedium(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
ChangerReinitializeUnit(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
ChangerQueryVolumeTags(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
ChangerPerformDiagnostics(
    IN PDEVICE_OBJECT DeviceObject,
    OUT PWMI_CHANGER_PROBLEM_DEVICE_ERROR changerDeviceError
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\ddk\inc\mce.h ===
/*++ BUILD Version: 0011    // Increment this if a change has global effects

Copyright (c) 1991-2001  Microsoft Corporation

Module Name:

    mce.h

Abstract:

    This header file defines the Machine Check Errors definitions.

Author:

    David N. Cutler (davec) 


Revision History:

    Creation: 04-Apr-2001

--*/

#ifndef _MCE_
#define _MCE_

//
// HalMcaLogInformation
//

#if defined(_X86_) || defined(_IA64_) || defined(_AMD64_)

//
// ADDR register for each MCA bank
//

typedef union _MCI_ADDR{
    struct {
        ULONG Address;
        ULONG Reserved;
    };

    ULONGLONG   QuadPart;
} MCI_ADDR, *PMCI_ADDR;


typedef enum {
    HAL_MCE_RECORD,
    HAL_MCA_RECORD
} MCA_EXCEPTION_TYPE;


#if defined(_AMD64_)

//
// STATUS register for each MCA bank.
//

typedef union _MCI_STATS {
    struct {
        USHORT  McaCod;
        USHORT  MsCod;
        ULONG   OtherInfo : 25;
        ULONG   Damage : 1;
        ULONG   AddressValid : 1;
        ULONG   MiscValid : 1;
        ULONG   Enabled : 1;
        ULONG   UnCorrected : 1;
        ULONG   OverFlow : 1;
        ULONG   Valid : 1;
    } MciStats;

    ULONG64 QuadPart;
} MCI_STATS, *PMCI_STATS;

#endif // _AMD64_

#if defined(_X86_)

//
// STATUS register for each MCA bank.
//

typedef union _MCI_STATS {
    struct {
        USHORT  McaCod;
        USHORT  MsCod;
        ULONG   OtherInfo : 25;
        ULONG   Damage : 1;
        ULONG   AddressValid : 1;
        ULONG   MiscValid : 1;
        ULONG   Enabled : 1;
        ULONG   UnCorrected : 1;
        ULONG   OverFlow : 1;
        ULONG   Valid : 1;
    } MciStats;

    ULONGLONG QuadPart;

} MCI_STATS, *PMCI_STATS;

#endif // _X86_

//
// MCA exception log entry
// Defined as a union to contain MCA specific log or Pentium style MCE info.
//

#define MCA_EXTREG_V2MAX       24  // X86: Max. Number of extended registers

#if defined(_X86_) || defined(_AMD64_)

typedef struct _MCA_EXCEPTION {

    // Begin Version 1 stuff
    ULONG               VersionNumber;      // Version number of this record type
    MCA_EXCEPTION_TYPE  ExceptionType;      // MCA or MCE
    LARGE_INTEGER       TimeStamp;          // exception recording timestamp
    ULONG               ProcessorNumber;
    ULONG               Reserved1;

    union {
        struct {
            UCHAR           BankNumber;
            UCHAR           Reserved2[7];
            MCI_STATS       Status;
            MCI_ADDR        Address;
            ULONGLONG       Misc;
        } Mca;

        struct {
            ULONGLONG       Address;        // physical addr of cycle causing the error
            ULONGLONG       Type;           // cycle specification causing the error
        } Mce;
    } u;
    // End   Version 1 stuff
    // Begin Version 2 stuff
    ULONG                   ExtCnt;
    ULONG                   Reserved3;
    ULONGLONG               ExtReg[MCA_EXTREG_V2MAX];
    // End   Version 2 stuff

} MCA_EXCEPTION, *PMCA_EXCEPTION;

typedef MCA_EXCEPTION CMC_EXCEPTION, *PCMC_EXCEPTION;    // Corrected Machine Check
typedef MCA_EXCEPTION CPE_EXCEPTION, *PCPE_EXCEPTION;    // Corrected Platform Error

#define MCA_EXCEPTION_V1_SIZE FIELD_OFFSET(MCA_EXCEPTION, ExtCnt)
#define MCA_EXCEPTION_V2_SIZE sizeof(struct _MCA_EXCEPTION)

#endif // _X86_ || _AMD64_

#if defined(_IA64_)

#if 0
// FIXFIX: This should not be required for IA64.
//
// STATUS register for each MCA bank.
//

typedef union _MCI_STATS {
    struct {
        USHORT  McaCod;
        USHORT  MsCod;
        ULONG   OtherInfo : 25;
        ULONG   Damage : 1;
        ULONG   AddressValid : 1;
        ULONG   MiscValid : 1;
        ULONG   Enabled : 1;
        ULONG   UnCorrected : 1;
        ULONG   OverFlow : 1;
        ULONG   Valid : 1;
    } MciStats;

    ULONGLONG QuadPart;

} MCI_STATS, *PMCI_STATS;

#endif // 0

//
// IA64 ERRORS: ERROR_REVISION definitions
//

typedef union _ERROR_REVISION {
    USHORT      Revision;           // Major and Minor revision number of the record:
    struct {
        UCHAR   Minor;              //  Byte0: Minor.
        UCHAR   Major;              //  Byte1: Major.
    };
} ERROR_REVISION, *PERROR_REVISION;

// For Info:
#define ERROR_REVISION_SAL_03_00 { 2, 0 }

//
// IA64 ERRORS: ERROR_SEVERITY definitions
//
// One day the MS compiler will support typed enums with type != int so this
// type of enums (UCHAR, __int64) could be defined...
//

typedef UCHAR ERROR_SEVERITY, *PERROR_SEVERITY;

typedef enum _ERROR_SEVERITY_VALUE  {
    ErrorRecoverable = 0,
    ErrorFatal       = 1,
    ErrorCorrected   = 2,
    ErrorOthers      = 3,   // [3,...] values are reserved
} ERROR_SEVERITY_VALUE;

//
// IA64 ERRORS: ERROR_TIMESTAMP definitions
//

typedef union _ERROR_TIMESTAMP  {
    ULONGLONG   TimeStamp;
    struct  {
        UCHAR   Seconds;  // Byte0: Seconds
        UCHAR   Minutes;  // Byte1: Minutes
        UCHAR   Hours;    // Byte2: Hours
        UCHAR   Reserved; // Byte3: Reserved
        UCHAR   Day;      // Byte4: Day
        UCHAR   Month;    // Byte5: Month
        UCHAR   Year;     // Byte6: Year
        UCHAR   Century;  // Byte7: Century
    };
} ERROR_TIMESTAMP, *PERROR_TIMESTAMP;

//
// IA64 ERRORS: ERROR_GUID definitions
//

typedef struct _ERROR_GUID   {
    ULONG   Data1;
    USHORT  Data2;
    USHORT  Data3;
    UCHAR   Data4[8];
} ERROR_GUID, *PERROR_GUID;

//
// IA64 ERRORS: ERROR GUIDs definitions
//

typedef ERROR_GUID            _ERROR_DEVICE_GUID;
typedef _ERROR_DEVICE_GUID    ERROR_DEVICE_GUID, *PERROR_DEVICE_GUID;

typedef ERROR_GUID            _ERROR_PLATFORM_GUID;
typedef _ERROR_PLATFORM_GUID  ERROR_PLATFORM_GUID, *PERROR_PLATFORM_GUID;

//
// IA64 ERRORS: ERROR_RECORD_HEADER definitions
//

typedef union _ERROR_RECORD_VALID   {
    UCHAR     Valid;
    struct {                        // Bits
        UCHAR OemPlatformID:1;      //    0: OEM Platform Id is present in the record header
        UCHAR Reserved:7;           //  1-7: Reserved 
    };
} ERROR_RECORD_VALID, *PERROR_RECORD_VALID;

typedef struct _ERROR_RECORD_HEADER { // Offsets:
    ULONGLONG          Id;                //   0: Unique identifier
    ERROR_REVISION     Revision;          //   8: Major and Minor revision number of the record
    ERROR_SEVERITY     ErrorSeverity;     //  10: Error Severity
    ERROR_RECORD_VALID Valid;             //  11: Validation bits
    ULONG              Length;            //  12: Length of this record in bytes, including the header
    ERROR_TIMESTAMP    TimeStamp;         //  16: Timestamp recorded when event occured
    UCHAR              OemPlatformId[16]; //  24: Unique platform identifier. OEM defined.
} ERROR_RECORD_HEADER, *PERROR_RECORD_HEADER;

//
// IA64 ERRORS: ERROR_SECTION_HEADER definitions
//

typedef union _ERROR_RECOVERY_INFO  {
    UCHAR RecoveryInfo;
    struct  {                 // Bits:
        UCHAR Corrected:1;    //    0: Corrected
        UCHAR NotContained:1; //    1: Containment Warning
        UCHAR Reset:1;        //    2: Reset
        UCHAR Reserved:4;     //  6-3: Reserved
        UCHAR Valid:1;        //    7: Valid Recovery Information
    };
} ERROR_RECOVERY_INFO, *PERROR_RECOVERY_INFO;

typedef struct _ERROR_SECTION_HEADER    {
    ERROR_DEVICE_GUID   Guid;         // Unique identifier
    ERROR_REVISION      Revision;     // Major and Minor revision number of the section
    ERROR_RECOVERY_INFO RecoveryInfo; // Recovery Information
    UCHAR               Reserved;
    ULONG               Length;       // Length of this error device section in bytes, 
                                      // including the header.
} ERROR_SECTION_HEADER, *PERROR_SECTION_HEADER;

//
// IA64 Machine Check Error Logs:
//      WMI requires processor LID being stored in the Log.
//      This LID corresponds to the processor on which the SAL_PROC was executed on.
//
// TEMPTEMP: Implementation is temporary, until we implement HAL SW Error Section.
//           Note that the current FW builds do not update the _ERROR_PROCESSOR.CRLid field,
//           assuming there is a _ERROR_PROCESSOR section in the record.
//

#if !defined(__midl)
__inline
USHORT
GetFwMceLogProcessorNumber(
    PERROR_RECORD_HEADER Log
    )
{
    PERROR_SECTION_HEADER section = (PERROR_SECTION_HEADER)((ULONG64)Log + sizeof(*Log));
    USHORT lid = (USHORT)((UCHAR)(section->Reserved));
    lid |= (USHORT)((UCHAR)(Log->TimeStamp.Reserved) << 8);
    return( lid );
} // GetFwMceLogProcessorNumber()
#endif // !__midl

//
// IA64 ERRORS: ERROR_PROCESSOR device definitions
//
// The MCA architecture supports five different types of error reporting functional units
// with the associated error records and its error severity. 
// At any point in time, a processor could encounter an MCA/CMC event due to errors detected 
// in one or more of the following units:
//  - Cache Check
//  - TLB   Check
//  - Bus   Check
//  - Register File
//  - Micro Architectural
//
// Terminology:
//
//  - Target Address:
//      64-bit integer containing the physical address where the data was to be delivered or
//      obtained. This could also be the incoming address for external snoops and TLB shoot-downs.
//
//  - Requestor Identifier:
//      64-bit integer specifying the bus agent that generated the transaction responsible for
//      the Machine Check event.
//                    
//  - Responder Identifier:
//      64-bit integer specifying the bus agent that responded to a transaction responsible for
//      the Machine Check event.
//                    
//  - Precise Instruction Pointer:
//      64-bit integer specifying the virtual address that points to the IA-64 bundle that 
//      contained the instruction responsible for the Machine Check event.
//                    

#define ERROR_PROCESSOR_GUID \
    { 0xe429faf1, 0x3cb7, 0x11d4, { 0xbc, 0xa7, 0x0, 0x80, 0xc7, 0x3c, 0x88, 0x81 }}

typedef union _ERROR_MODINFO_VALID  {
    ULONGLONG     Valid;
    struct {                                // Bits
        ULONGLONG CheckInfo: 1;             //       0:
        ULONGLONG RequestorIdentifier: 1;   //       1:
        ULONGLONG ResponderIdentifier: 1;   //       2:
        ULONGLONG TargetIdentifier: 1;      //       3:
        ULONGLONG PreciseIP: 1;             //       4:
        ULONGLONG Reserved: 59;             //    5-63:
    };
} ERROR_MODINFO_VALID, *PERROR_MODINFO_VALID;

typedef enum _ERROR_CHECK_IS    {
    isIA64 = 0,
    isIA32 = 1,
} ERROR_CHECK_IS;

typedef enum _ERROR_CACHE_CHECK_OPERATION   {
    CacheUnknownOp = 0,
    CacheLoad  = 1,
    CacheStore = 2,
    CacheInstructionFetch = 3,
    CacheDataPrefetch = 4,
    CacheSnoop = 5,
    CacheCastOut = 6,
    CacheMoveIn = 7,
} ERROR_CACHE_CHECK_OPERATION;

typedef enum _ERROR_CACHE_CHECK_MESI    {
    CacheInvalid = 0,
    CacheHeldShared = 1,
    CacheHeldExclusive = 2,
    CacheModified = 3,
} ERROR_CACHE_CHECK_MESI;

typedef union _ERROR_CACHE_CHECK    {
    ULONGLONG CacheCheck;
    struct
    {
        ULONGLONG Operation:4;             // bits  0- 3: Cache operation
        ULONGLONG Level:2;                 //       4- 5: Cache Level
        ULONGLONG Reserved1:2;             //       6- 7
        ULONGLONG DataLine:1;              //       8   : Failure data part of cache line
        ULONGLONG TagLine:1;               //       9   : Failure tag part of cache line
        ULONGLONG DataCache:1;             //      10   : Failure in data cache
        ULONGLONG InstructionCache:1;      //      11   : Failure in instruction cache
        ULONGLONG MESI:3;                  //      12-14:
        ULONGLONG MESIValid:1;             //      15   : MESI field is valid
        ULONGLONG Way:5;                   //      16-20: Failure in Way of Cache
        ULONGLONG WayIndexValid:1;         //      21   : Way and Index fields valid
        ULONGLONG Reserved2:10;            //      22-31
        ULONGLONG Index:20;                //      32-51: Index of cache line
        ULONGLONG Reserved3:2;             //      52-53
        ULONGLONG InstructionSet:1;        //      54   : 0 - IA64 instruction, 1- IA32 instruction
        ULONGLONG InstructionSetValid:1;   //      55   : InstructionSet field is valid
        ULONGLONG PrivilegeLevel:2;        //      56-57: Privlege level of instrustion
        ULONGLONG PrivilegeLevelValid:1;   //      58   : PrivilegeLevel field is Valid
        ULONGLONG MachineCheckCorrected:1; //      59   : 1 - Machine Check Corrected
        ULONGLONG TargetAddressValid:1;    //      60   : Target Address is valid
        ULONGLONG RequestIdValid:1;        //      61   : RequestId is valid
        ULONGLONG ResponderIdValid:1;      //      62   : ResponderId is valid
        ULONGLONG PreciseIPValid:1;        //      63   : Precise Inststruction Pointer is Valid
    };
} ERROR_CACHE_CHECK, *PERROR_CACHE_CHECK;

typedef enum _ERROR_TLB_CHECK_OPERATION   {
    TlbUnknownOp = 0,
    TlbAccessWithLoad  = 1,
    TlbAccessWithStore = 2,
    TlbAccessWithInstructionFetch = 3,
    TlbAccessWithDataPrefetch = 4,
    TlbShootDown = 5,
    TlbProbe = 6,
    TlbVhptFill = 7,
} ERROR_TLB_CHECK_OPERATION;

typedef union _ERROR_TLB_CHECK  {
    ULONGLONG TlbCheck;
    struct
    {
        ULONGLONG TRSlot:8;                // bits  0- 7: Slot number of Translation Register
        ULONGLONG TRSlotValid:1;           //       8   : TRSlot field is valid
        ULONGLONG Reserved1:1;             //       9
        ULONGLONG Level:2;                 //      10-11: TLB Level
        ULONGLONG Reserved2:4;             //      12-15
        ULONGLONG DataTransReg:1;          //      16   : Error in data translation register
        ULONGLONG InstructionTransReg:1;   //      17   : Error in instruction translation register
        ULONGLONG DataTransCache:1;        //      18   : Error in data translation cache
        ULONGLONG InstructionTransCache:1; //      19   : Error in instruction translation cache
        ULONGLONG Operation:4;             //      20-23: Operation
        ULONGLONG Reserved3:30;            //      24-53
        ULONGLONG InstructionSet:1;        //      54   : 0 - IA64 instruction, 1- IA32 instruction
        ULONGLONG InstructionSetValid:1;   //      55   : InstructionSet field is valid
        ULONGLONG PrivilegeLevel:2;        //      56-57: Privlege level of instrustion
        ULONGLONG PrivilegeLevelValid:1;   //      58   : PrivilegeLevel field is Valid
        ULONGLONG MachineCheckCorrected:1; //      59   : 1 - Machine Check Corrected
        ULONGLONG TargetAddressValid:1;    //      60   : Target Address is valid
        ULONGLONG RequestIdValid:1;        //      61   : RequestId is valid
        ULONGLONG ResponderIdValid:1;      //      62   : ResponderId is valid
        ULONGLONG PreciseIPValid:1;        //      63   : Precise Inststruction Pointer is Valid
    };
} ERROR_TLB_CHECK, *PERROR_TLB_CHECK;

typedef enum _ERROR_BUS_CHECK_OPERATION   {
    BusUnknownOp = 0,
    BusPartialRead  = 1,
    BusPartialWrite = 2,
    BusFullLineRead = 3,
    BusFullLineWrite = 4,
    BusWriteBack = 5,
    BusSnoopProbe = 6,
    BusIncomingPtcG = 7,
    BusWriteCoalescing = 8,
} ERROR_BUS_CHECK_OPERATION;

typedef union _ERROR_BUS_CHECK  {
    ULONGLONG BusCheck;
    struct
    {
        ULONGLONG Size:5;                  // bits  0- 4: Transaction size
        ULONGLONG Internal:1;              //       5   : Internal bus error
        ULONGLONG External:1;              //       6   : External bus error
        ULONGLONG CacheTransfer:1;         //       7   : Error occured in Cache to Cache Transfer 
        ULONGLONG Type:8;                  //       8-15: Transaction type
        ULONGLONG Severity:5;              //      16-20: Error severity - platform specific
        ULONGLONG Hierarchy:2;             //      21-22: Level or Bus hierarchy
        ULONGLONG Reserved1:1;             //      23
        ULONGLONG Status:8;                //      24-31: Bus error status - processor bus specific
        ULONGLONG Reserved2:22;            //      32-53
        ULONGLONG InstructionSet:1;        //      54   : 0 - IA64 instruction, 1- IA32 instruction
        ULONGLONG InstructionSetValid:1;   //      55   : InstructionSet field is valid
        ULONGLONG PrivilegeLevel:2;        //      56-57: Privlege level of instrustion
        ULONGLONG PrivilegeLevelValid:1;   //      58   : PrivilegeLevel field is Valid
        ULONGLONG MachineCheckCorrected:1; //      59   : 1 - Machine Check Corrected
        ULONGLONG TargetAddressValid:1;    //      60   : Target Address is valid
        ULONGLONG RequestIdValid:1;        //      61   : RequestId is valid
        ULONGLONG ResponderIdValid:1;      //      62   : ResponderId is valid
        ULONGLONG PreciseIPValid:1;        //      63   : Precise Inststruction Pointer is Valid
    };
} ERROR_BUS_CHECK, *PERROR_BUS_CHECK;

typedef enum _ERROR_REGFILE_CHECK_IDENTIFIER   {
    RegFileUnknownId = 0,
    GeneralRegisterBank1 = 1,
    GeneralRegisterBank0 = 2,
    FloatingPointRegister = 3,
    BranchRegister = 4,
    PredicateRegister = 5,
    ApplicationRegister = 6,
    ControlRegister = 7,
    RegionRegister = 8,
    ProtectionKeyRegister = 9,
    DataBreakPointRegister = 10,
    InstructionBreakPointRegister = 11,
    PerformanceMonitorControlRegister = 12,
    PerformanceMonitorDataRegister = 13,
} ERROR_REGFILE_CHECK_IDENTIFIER;

typedef enum _ERROR_REGFILE_CHECK_OPERATION   {
    RegFileUnknownOp = 0,
    RegFileRead = 1,
    RegFileWrite = 2,
} ERROR_REGFILE_CHECK_OPERATION;

typedef union _ERROR_REGFILE_CHECK  {
    ULONGLONG RegFileCheck;
    struct
    {
        ULONGLONG Identifier:4;            // bits  0- 3: Register file identifier
        ULONGLONG Operation:4;             //       4- 7: Operation that causes the MC event
        ULONGLONG RegisterNumber:7;        //       8-14: Register number responsible for MC event
        ULONGLONG RegisterNumberValid:1;   //      15   : Register number field is valid
        ULONGLONG Reserved1:38;            //      16-53
        ULONGLONG InstructionSet:1;        //      54   : 0 - IA64 instruction, 1- IA32 instruction
        ULONGLONG InstructionSetValid:1;   //      55   : InstructionSet field is valid
        ULONGLONG PrivilegeLevel:2;        //      56-57: Privlege level of instrustion
        ULONGLONG PrivilegeLevelValid:1;   //      58   : PrivilegeLevel field is Valid
        ULONGLONG MachineCheckCorrected:1; //      59   : 1 - Machine Check Corrected
        ULONGLONG Reserved2:3;             //      60-62
        ULONGLONG PreciseIPValid:1;        //      63   : Precise Inststruction Pointer is Valid
    };
} ERROR_REGFILE_CHECK, *PERROR_REGFILE_CHECK;

typedef enum _ERROR_MS_CHECK_OPERATION   {
    MsUnknownOp = 0,
    MsReadOrLoad = 1,
    MsWriteOrStore = 2,
} ERROR_MS_CHECK_OPERATION;

typedef union _ERROR_MS_CHECK  {
    ULONGLONG MsCheck;
    struct
    {
        ULONGLONG StructureIdentifier:5;   // bits  0- 4: Structure Identifier - impl. specific
        ULONGLONG Level:3;                 //       5- 7: Structure Level where error was generated
        ULONGLONG ArrayId:4;               //       8-11: Identification of the array 
        ULONGLONG Operation:4;             //      12-15: Operation
        ULONGLONG Way:6;                   //      16-21: Way where the error was located
        ULONGLONG WayValid:1;              //      22   : Way field is valid
        ULONGLONG IndexValid:1;            //      23   : Index field is valid
        ULONGLONG Reserved1:8;             //      24-31
        ULONGLONG Index:8;                 //      32-39: Index where the error was located
        ULONGLONG Reserved2:14;            //      40-53
        ULONGLONG InstructionSet:1;        //      54   : 0 - IA64 instruction, 1- IA32 instruction
        ULONGLONG InstructionSetValid:1;   //      55   : InstructionSet field is valid
        ULONGLONG PrivilegeLevel:2;        //      56-57: Privlege level of instrustion
        ULONGLONG PrivilegeLevelValid:1;   //      58   : PrivilegeLevel field is Valid
        ULONGLONG MachineCheckCorrected:1; //      59   : 1 - Machine Check Corrected
        ULONGLONG TargetAddressValid:1;    //      60   : Target Address is valid
        ULONGLONG RequestIdValid:1;        //      61   : RequestId is valid
        ULONGLONG ResponderIdValid:1;      //      62   : ResponderId is valid
        ULONGLONG PreciseIPValid:1;        //      63   : Precise Inststruction Pointer is Valid
    };
} ERROR_MS_CHECK, *PERROR_MS_CHECK;

typedef union _ERROR_CHECK_INFO   {
    ULONGLONG             CheckInfo;
    ERROR_CACHE_CHECK     CacheCheck;
    ERROR_TLB_CHECK       TlbCheck;
    ERROR_BUS_CHECK       BusCheck;
    ERROR_REGFILE_CHECK   RegFileCheck;
    ERROR_MS_CHECK        MsCheck;
} ERROR_CHECK_INFO, *PERROR_CHECK_INFO;

// SAL Specs July 2000: The size of _ERROR_MODINFO will always be 48 Bytes.

typedef struct _ERROR_MODINFO   {
    ERROR_MODINFO_VALID Valid;
    ERROR_CHECK_INFO    CheckInfo;
    ULONGLONG           RequestorId;
    ULONGLONG           ResponderId;
    ULONGLONG           TargetId;
    ULONGLONG           PreciseIP;
} ERROR_MODINFO, *PERROR_MODINFO;

typedef union _ERROR_PROCESSOR_VALID    {
    ULONGLONG     Valid;
    struct {                                // Bits
        ULONGLONG ErrorMap: 1;              //       0:
        ULONGLONG StateParameter: 1;        //       1:
        ULONGLONG CRLid: 1;                 //       2:
        ULONGLONG StaticStruct:1;           //       3: Processor Static Info error.
        ULONGLONG CacheCheckNum:4;          //     4-7: Cache errors.
        ULONGLONG TlbCheckNum:4;            //    8-11: Tlb errors.
        ULONGLONG BusCheckNum:4;            //   12-15: Bus errors.
        ULONGLONG RegFileCheckNum:4;        //   16-19: Registers file errors.
        ULONGLONG MsCheckNum:4;             //   20-23: Micro-Architecture errors.
        ULONGLONG CpuIdInfo:1;              //      24: CPUID Info.
        ULONGLONG Reserved:39;              //   25-63: Reserved.
    };
} ERROR_PROCESSOR_VALID, *PERROR_PROCESSOR_VALID;

typedef union _ERROR_PROCESSOR_ERROR_MAP {
    ULONGLONG   ErrorMap;
    struct  {
        ULONGLONG   Cid:4;                 // bits  0- 3: Processor Core Identifier
        ULONGLONG   Tid:4;                 //       4- 7: Logical Thread Identifier
        ULONGLONG   Eic:4;                 //       8-11: Instruction Caches Level Information
        ULONGLONG   Edc:4;                 //      12-15: Data        Caches Level Information
        ULONGLONG   Eit:4;                 //      16-19: Instruction TLB    Level Information
        ULONGLONG   Edt:4;                 //      20-23: Data        TLB    Level Information
        ULONGLONG   Ebh:4;                 //      24-27: Processor   Bus    Level Information
        ULONGLONG   Erf:4;                 //      28-31: Register    File   Level Information
        ULONGLONG   Ems:16;                //      32-47: MicroArchitecture  Level Information
        ULONGLONG   Reserved:16;      
    };
} ERROR_PROCESSOR_ERROR_MAP, *PERROR_PROCESSOR_ERROR_MAP;

typedef ERROR_PROCESSOR_ERROR_MAP    _ERROR_PROCESSOR_LEVEL_INDEX;
typedef _ERROR_PROCESSOR_LEVEL_INDEX ERROR_PROCESSOR_LEVEL_INDEX, *PERROR_PROCESSOR_LEVEL_INDEX;

typedef union _ERROR_PROCESSOR_STATE_PARAMETER {
    ULONGLONG   StateParameter;
    struct {
        ULONGLONG reserved0:2;  //   0-1 : reserved
        ULONGLONG rz:1;         //     2 : Rendez-vous successful
        ULONGLONG ra:1;         //     3 : Rendez-vous attempted
        ULONGLONG me:1;         //     4 : Distinct Multiple errors
        ULONGLONG mn:1;         //     5 : Min-state Save Area registered
        ULONGLONG sy:1;         //     6 : Storage integrity synchronized
        ULONGLONG co:1;         //     7 : Continuable
        ULONGLONG ci:1;         //     8 : Machine Check isolated
        ULONGLONG us:1;         //     9 : Uncontained Storage damage
        ULONGLONG hd:1;         //    10 : Hardware damage
        ULONGLONG tl:1;         //    11 : Trap lost
        ULONGLONG mi:1;         //    12 : More Information
        ULONGLONG pi:1;         //    13 : Precise Instruction pointer
        ULONGLONG pm:1;         //    14 : Precise Min-state Save Area
        ULONGLONG dy:1;         //    15 : Processor Dynamic State valid
        ULONGLONG in:1;         //    16 : INIT interruption
        ULONGLONG rs:1;         //    17 : RSE valid
        ULONGLONG cm:1;         //    18 : Machine Check corrected
        ULONGLONG ex:1;         //    19 : Machine Check expected
        ULONGLONG cr:1;         //    20 : Control Registers valid
        ULONGLONG pc:1;         //    21 : Performance Counters valid
        ULONGLONG dr:1;         //    22 : Debug Registers valid
        ULONGLONG tr:1;         //    23 : Translation Registers valid
        ULONGLONG rr:1;         //    24 : Region Registers valid
        ULONGLONG ar:1;         //    25 : Application Registers valid
        ULONGLONG br:1;         //    26 : Branch Registers valid
        ULONGLONG pr:1;         //    27 : Predicate Registers valid
        ULONGLONG fp:1;         //    28 : Floating-Point Registers valid
        ULONGLONG b1:1;         //    29 : Preserved Bank 1 General Registers valid
        ULONGLONG b0:1;         //    30 : Preserved Bank 0 General Registers valid
        ULONGLONG gr:1;         //    31 : General Registers valid
        ULONGLONG dsize:16;     // 47-32 : Processor Dynamic State size
        ULONGLONG reserved1:11; // 48-58 : reserved
        ULONGLONG cc:1;         //    49 : Cache Check
        ULONGLONG tc:1;         //    60 : TLB   Check
        ULONGLONG bc:1;         //    61 : Bus   Check
        ULONGLONG rc:1;         //    62 : Register File Check
        ULONGLONG uc:1;         //    63 : Micro-Architectural Check
    };
} ERROR_PROCESSOR_STATE_PARAMETER, *PERROR_PROCESSOR_STATE_PARAMETER;
    
typedef union _PROCESSOR_LOCAL_ID  {
    ULONGLONG LocalId;
    struct {
        ULONGLONG reserved:16;  //  0-16 : reserved
        ULONGLONG eid:8;        // 16-23 : Extended Id 
        ULONGLONG id:8;         // 24-31 : Id
        ULONGLONG ignored:32;   // 32-63 : ignored
    };
} PROCESSOR_LOCAL_ID, *PPROCESSOR_LOCAL_ID;

typedef struct _ERROR_PROCESSOR_MS {
    ULONGLONG      MsError   [ /* Valid.MsCheckNum      */ 1]; // 0 -> 15 registers file errors.
} ERROR_PROCESSOR_MS, *PERROR_PROCESSOR_MS;

typedef struct _ERROR_PROCESSOR_CPUID_INFO {   // Must be 48 bytes.
    ULONGLONG CpuId0;
    ULONGLONG CpuId1;
    ULONGLONG CpuId2;
    ULONGLONG CpuId3;
    ULONGLONG CpuId4;
    ULONGLONG Reserved;
} ERROR_PROCESSOR_CPUID_INFO, *PERROR_PROCESSOR_CPUID_INFO;                                       

typedef union _ERROR_PROCESSOR_STATIC_INFO_VALID {
    ULONGLONG     Valid;
    struct {                                // Bits
        // Warning: Match the VALID fields with the _ERROR_PROCESSOR_STATIC_INFO members.
        //          KD extensions use the field names to access the PSI structure.
        ULONGLONG MinState: 1;              //       0: MinState              valid.
        ULONGLONG BR: 1;                    //       1: Branch      Registers valid.
        ULONGLONG CR: 1;                    //       2: Control     Registers valid.
        ULONGLONG AR: 1;                    //       3: Application Registers valid.
        ULONGLONG RR: 1;                    //       4:             Registers valid.
        ULONGLONG FR: 1;                    //       5:             Registers valid.
        ULONGLONG Reserved: 58;             //    6-63: Reserved.
    };
} ERROR_PROCESSOR_STATIC_INFO_VALID, *PERROR_PROCESSOR_STATIC_INFO_VALID;

typedef struct _ERROR_PROCESSOR_STATIC_INFO  {
    ERROR_PROCESSOR_STATIC_INFO_VALID Valid;
    UCHAR      MinState[ /* SAL Specs, July 2000 and Jan 2001 state approximatively: */ 1024];
    ULONGLONG  BR      [ 8 ];
    ULONGLONG  CR      [ /* SAL Specs, July 2000 states that it is processor dependent */ 128 ];
    ULONGLONG  AR      [ /* SAL Specs, July 2000 states that it is processor dependent */ 128 ];
    ULONGLONG  RR      [ 8 ];
    ULONGLONG  FR      [ 2 * 128 ];
} ERROR_PROCESSOR_STATIC_INFO, *PERROR_PROCESSOR_STATIC_INFO;

typedef struct _ERROR_PROCESSOR {
    ERROR_SECTION_HEADER              Header;
    ERROR_PROCESSOR_VALID             Valid;
    ERROR_PROCESSOR_ERROR_MAP         ErrorMap;
    ERROR_PROCESSOR_STATE_PARAMETER   StateParameter;
    PROCESSOR_LOCAL_ID                CRLid;
#if 0
// The presence of the following data depends on the valid bits
// from ERROR_PROCESSOR.Valid.
//
    ERROR_MODINFO               CacheErrorInfo   [ /* Valid.CacheCheckNum   */ ]; // 0->15 cache error modinfo structs.
    ERROR_MODINFO               TlbErrorInfo     [ /* Valid.TlbCheckNum     */ ]; // 0->15 tlb   error modinfo structs.
    ERROR_MODINFO               BusErrorInfo     [ /* Valid.BusCheckNum     */ ]; // 0->15 bus   error modinfo structs.
    ERROR_MODINFO               RegFileCheckInfo [ /* Valid.RegFileCheckNum */ ]; // 0->15 registers file errors.
    ERROR_MODINFO               MsCheckInfo      [ /* Valid.MsCheckNum      */ ]; // 0->15 registers file errors.
    ERROR_PROCESSOR_CPUID_INFO  CpuIdInfo;       // field will always be there but could be zero-padded.
    ERROR_PROCESSOR_STATIC_INFO StaticInfo;      // field will always be there but could be zero-padded.
#endif // 0
} ERROR_PROCESSOR, *PERROR_PROCESSOR;

//
// IA64 ERROR PROCESSOR State Parameter - GR18 - definitions.
//

#define ERROR_PROCESSOR_STATE_PARAMETER_CACHE_CHECK_SHIFT     60
#define ERROR_PROCESSOR_STATE_PARAMETER_CACHE_CHECK_MASK      0x1
#define ERROR_PROCESSOR_STATE_PARAMETER_TLB_CHECK_SHIFT       61
#define ERROR_PROCESSOR_STATE_PARAMETER_TLB_CHECK_MASK        0x1
#define ERROR_PROCESSOR_STATE_PARAMETER_BUS_CHECK_SHIFT       62
#define ERROR_PROCESSOR_STATE_PARAMETER_BUS_CHECK_MASK        0x1
#define ERROR_PROCESSOR_STATE_PARAMETER_UNKNOWN_CHECK_SHIFT   63
#define ERROR_PROCESSOR_STATE_PARAMETER_UNKNOWN_CHECK_MASK    0x1

////////////////////////////////////////////////////////////////////
//
// IA64 PLATFORM ERRORS Definitions
//
// We tried to respect the order in which these error devices are 
// presented in the SAL specs.

//
// IA64 ERRORS: _ERR_TYPE definitions
//
// Warning 04/01/01: "ERR_TYPE" or "ERROR_TYPE" are already used in the NT namespace.
//

typedef enum _ERR_TYPES    {
// Generic error types:
    ERR_INTERNAL = 1,         // Error detected internal to the component
    ERR_BUS      = 16,        // Error detected in the bus
// Detailed Internal Error Types:
    ERR_MEM      = 4,         // Storage error in memory (DRAM)
    ERR_TLB      = 5,         // Storage error in TLB
    ERR_CACHE    = 6,         // Storage error in cache
    ERR_FUNCTION = 7,         // Error in one or more functional units
    ERR_SELFTEST = 8,         // Component failed self test
    ERR_FLOW     = 9,         // Overflow or Undervalue of internal queue
// Detailed Bus Error Types:
    ERR_MAP      = 17,        // Virtual address not found on IO-TLB or IO-PDIR
    ERR_IMPROPER = 18,        // Improper access error
    ERR_UNIMPL   = 19,        // Access to a memory address which is not mapped to any component
    ERR_LOL      = 20,        // Loss Of Lockstep
    ERR_RESPONSE = 21,        // Response to which there is no associated request
    ERR_PARITY   = 22,        // Bus parity error
    ERR_PROTOCOL = 23,        // Detection of a protocol error
    ERR_ERROR    = 24,        // Detection of PATH_ERROR
    ERR_TIMEOUT  = 25,        // Bus operation time-out
    ERR_POISONED = 26,        // A read was issued to data which has been poisoned
} _ERR_TYPE;

//
// IA64 ERRORS: ERROR_STATUS definitions
//

typedef union _ERROR_STATUS {
    ULONGLONG Status;
    struct  {                 //  Bits:
        ULONGLONG Reserved0:8;  //   7-0: Reserved
        ULONGLONG Type:8;       //  15-8: Error Type - See _ERR_TYPE definitions.
        ULONGLONG Address:1;    //    16: Error was detected on address signals or on address portion of transaction
        ULONGLONG Control:1;    //    17: Error was detected on control signals or in control portion of transaction
        ULONGLONG Data:1;       //    18: Error was detected on data signals or in data portion of transaction
        ULONGLONG Responder:1;  //    19: Error was detected by responder of transaction
        ULONGLONG Requestor:1;  //    20: Error was detected by requestor of transaction
        ULONGLONG FirstError:1; //    21: If multiple errors, this is the first error of the highest severity that occurred
        ULONGLONG Overflow:1;   //    22: Additional errors occurred which were not logged because registers overflow 
        ULONGLONG Reserved1:41; // 63-23: Reserved
    };
} ERROR_STATUS, *PERROR_STATUS;

//
// IA64 ERRORS: Platform OEM_DATA definitions
//

typedef struct _ERROR_OEM_DATA {
    USHORT Length;
#if 0
    UCHAR  Data[/* ERROR_OEM_DATA.Length */];
#endif // 0
} ERROR_OEM_DATA, *PERROR_OEM_DATA;

//
// IA64 ERRORS: Platform BUS_SPECIFIC_DATA definitions
//

typedef union _ERROR_BUS_SPECIFIC_DATA {
    ULONGLONG BusSpecificData;
    struct {                                         // Bits :
        ULONGLONG LockAsserted:1;                    //     0: LOCK# Asserted during request phase
        ULONGLONG DeferLogged:1;                     //     1: Defer phase is logged
        ULONGLONG IOQEmpty:1;                        //     2: IOQ is empty
        ULONGLONG DeferredTransaction:1;             //     3: Component interface deferred transaction
        ULONGLONG RetriedTransaction:1;              //     4: Component interface retried transaction
        ULONGLONG MemoryClaimedTransaction:1;        //     5: memory claimed the transaction
        ULONGLONG IOClaimedTransaction:1;            //     6: IO controller claimed the transaction
        ULONGLONG ResponseParitySignal:1;            //     7: Response parity signal
        ULONGLONG DeferSignal:1;                     //     8: DEFER# signal
        ULONGLONG HitMSignal:1;                      //     9: HITM# signal
        ULONGLONG HitSignal:1;                       //    10: HIT# signal
        ULONGLONG RequestBusFirstCycle:6;            // 16-11: First cycle of request bus
        ULONGLONG RequestBusSecondCycle:6;           // 22-17: Second cycle of request bus
        ULONGLONG AddressParityBusFirstCycle:2;      // 24-23: First cycle of address parity bus
        ULONGLONG AddressParityBusSecondCycle:2;     // 26-25: Second cycle of address parity
        ULONGLONG ResponseBus:3;                     // 29-27: Response bus
        ULONGLONG RequestParitySignalFirstCycle:1;   //    30: First cycle of request parity signal
        ULONGLONG RequestParitySignalSecondCycle:1;  //    31: Second cycle of request parity signal
        ULONGLONG Reserved:32;                       // 63-32: Reserved
    };
} ERROR_BUS_SPECIFIC_DATA, *PERROR_BUS_SPECIFIC_DATA;

//
// IA64 ERRORS: Platform ERROR_MEMORY device definitions
//
// With reference to the ACPI Memory Device.
//

#define ERROR_MEMORY_GUID \
    { 0xe429faf2, 0x3cb7, 0x11d4, { 0xbc, 0xa7, 0x0, 0x80, 0xc7, 0x3c, 0x88, 0x81 }}

typedef union _ERROR_MEMORY_VALID    {
    ULONGLONG     Valid;
    struct {                                 // Bits
        ULONGLONG ErrorStatus:1;             //       0: Error Status valid bit
        ULONGLONG PhysicalAddress:1;         //       1: Physical Address valid bit
        ULONGLONG AddressMask:1;             //       2: Address Mask bit
        ULONGLONG Node:1;                    //       3: Node valid bit
        ULONGLONG Card:1;                    //       4: Card valid bit
        ULONGLONG Module:1;                  //       5: Module valid bit
        ULONGLONG Bank:1;                    //       6: Bank valid bit
        ULONGLONG Device:1;                  //       7: Device valid bit
        ULONGLONG Row:1;                     //       8: Row valid bit
        ULONGLONG Column:1;                  //       9: Column valid bit
        ULONGLONG BitPosition:1;             //      10: Bit Position valid bit
        ULONGLONG RequestorId:1;             //      11: Platform Requestor Id valid bit
        ULONGLONG ResponderId:1;             //      12: Platform Respinder Id valid bit
        ULONGLONG TargetId:1;                //      13: Platform Target    Id valid bit
        ULONGLONG BusSpecificData:1;         //      14: Platform Bus specific data valid bit
        ULONGLONG OemId:1;                   //      15: Platform OEM id   valid bit
        ULONGLONG OemData:1;                 //      16: Platform OEM data valid bit
        ULONGLONG Reserved:47;               //   63-17: Reserved
    };
} ERROR_MEMORY_VALID, *PERROR_MEMORY_VALID;

typedef struct _ERROR_MEMORY    {
    ERROR_SECTION_HEADER  Header;
    ERROR_MEMORY_VALID    Valid;
    ERROR_STATUS          ErrorStatus;         // Memory device error status fields - See ERROR_STATUS defs.
    ULONGLONG             PhysicalAddress;     // Physical Address of the memory error
    ULONGLONG             PhysicalAddressMask; // Valid bits for Physical Address
    USHORT                Node;                // Node identifier in a multi-node system
    USHORT                Card;                // Card   number of the memory error location
    USHORT                Module;              // Module number of the memory error location
    USHORT                Bank;                // Bank   number of the memory error location
    USHORT                Device;              // Device number of the memory error location
    USHORT                Row;                 // Row    number of the memory error location
    USHORT                Column;              // Column number of the memory error location
    USHORT                BitPosition;         // Bit within the word that is in error
    ULONGLONG             RequestorId;         // Hardware address of the device or component initiating transaction
    ULONGLONG             ResponderId;         // Hardware address of the responder to transaction
    ULONGLONG             TargetId;            // Hardware address of intended target of transaction       
    ULONGLONG             BusSpecificData;     // Bus dependent data of the on-board processor. It is a OEM specific field.
    UCHAR                 OemId[16];           // OEM defined identification for memory controller
    ERROR_OEM_DATA        OemData;     // OEM platform specific data. 
} ERROR_MEMORY, *PERROR_MEMORY;

//
// IA64 ERRORS: Platform ERROR_PCI_BUS device definitions
//
// With reference to the PCI Specifications.
//

#define ERROR_PCI_BUS_GUID \
    { 0xe429faf4, 0x3cb7, 0x11d4, { 0xbc, 0xa7, 0x0, 0x80, 0xc7, 0x3c, 0x88, 0x81 }}

typedef union _ERROR_PCI_BUS_VALID    {
    ULONGLONG     Valid;
    struct {                                // Bits
        ULONGLONG ErrorStatus:1;            //       0: Error Status             valid bit
        ULONGLONG ErrorType:1;              //       1: Error Type               valid bit
        ULONGLONG Id:1;                     //       2: Identifier               valid bit
        ULONGLONG Address:1;                //       3: Address                  valid bit
        ULONGLONG Data:1;                   //       4: Data                     valid bit
        ULONGLONG CmdType:1;                //       5: Command Type             valid bit
        ULONGLONG RequestorId:1;            //       6: Requestor Identifier     valid bit
        ULONGLONG ResponderId:1;            //       7: Responder Identifier     valid bit
        ULONGLONG TargetId:1;               //       8: Target    Identifer      valid bit
        ULONGLONG OemId:1;                  //       9: OEM Identification       valid bit
        ULONGLONG OemData:1;                //      10: OEM Data                 valid bit
        ULONGLONG Reserved:57;              //   11-63: Reserved
    };
} ERROR_PCI_BUS_VALID, *PERROR_PCI_BUS_VALID;

typedef struct _ERROR_PCI_BUS_TYPE {
    UCHAR Type;
    UCHAR Reserved;
} ERROR_PCI_BUS_TYPE, *PERROR_PCI_BUS_TYPE;

#define PciBusUnknownError       ((UCHAR)0)
#define PciBusDataParityError    ((UCHAR)1)
#define PciBusSystemError        ((UCHAR)2)
#define PciBusMasterAbort        ((UCHAR)3)
#define PciBusTimeOut            ((UCHAR)4)
#define PciMasterDataParityError ((UCHAR)5)
#define PciAddressParityError    ((UCHAR)6)
#define PciCommandParityError    ((UCHAR)7)
//      PciOtherErrors           Reserved

typedef struct _ERROR_PCI_BUS_ID    {
    UCHAR BusNumber;         // Bus     Number
    UCHAR SegmentNumber;     // Segment Number
} ERROR_PCI_BUS_ID, *PERROR_PCI_BUS_ID;

typedef struct _ERROR_PCI_BUS    {
    ERROR_SECTION_HEADER  Header;
    ERROR_PCI_BUS_VALID   Valid;
    ERROR_STATUS          ErrorStatus;    // PCI Bus Error Status - See ERROR_STATUS definitions.
    ERROR_PCI_BUS_TYPE    Type;           // PCI Bus Error Type 
    ERROR_PCI_BUS_ID      Id;             // PCI Bus Identifier      
    UCHAR                 Reserved[4];    // Reserved
    ULONGLONG             Address;        // Memory or IO Address on the PCI bus at
                                          // the time of the event
    ULONGLONG             Data;           // Data on the PCI bus at time of the event
    ULONGLONG             CmdType;        // Bus Command or Operation at time of the event
    ULONGLONG             RequestorId;    // Bus Requestor Identifier at time of the event
    ULONGLONG             ResponderId;    // Bus Responder Identifier at time of the event
    ULONGLONG             TargetId;       // Intended Bus Target Identifier at time of the event
    UCHAR                 OemId[16];      // OEM defined identification for pci bus
    ERROR_OEM_DATA        OemData;        // OEM specific data. 
} ERROR_PCI_BUS, *PERROR_PCI_BUS;

//
// IA64 ERRORS: Platform ERROR_PCI_COMPONENT device definitions
//
// With reference to the PCI Specifications.
//

#define ERROR_PCI_COMPONENT_GUID \
    { 0xe429faf6, 0x3cb7, 0x11d4, { 0xbc, 0xa7, 0x0, 0x80, 0xc7, 0x3c, 0x88, 0x81 }}

typedef union _ERROR_PCI_COMPONENT_VALID   {
    ULONGLONG Valid;
    struct {                                       // Bits:
        ULONGLONG ErrorStatus:1;                   //    0: Error Status valid bit
        ULONGLONG Info:1;                          //    1: Information  valid bit
        ULONGLONG MemoryMappedRegistersPairs:1;    //    2: Number of Memory Mapped Registers Pairs valid bit
        ULONGLONG ProgrammedIORegistersPairs:1;    //    3: Number of Programmed IO Registers Pairs valid bit
        ULONGLONG RegistersDataPairs:1;            //    4: Memory Mapped Registers Pairs valid bit
        ULONGLONG OemData:1;                       //    5: OEM Data valid bit.
        ULONGLONG Reserved:58;                     // 63-6: Reserved
    };
} ERROR_PCI_COMPONENT_VALID, *PERROR_PCI_COMPONENT_VALID;

typedef struct _ERROR_PCI_COMPONENT_INFO {  // Bytes:
   USHORT VendorId;                         //   0-1: Vendor Identifier
   USHORT DeviceId;                         //   2-3: Device Identifier
   UCHAR  ClassCodeInterface;               //     4: Class Code.Interface field
   UCHAR  ClassCodeSubClass;                //     5: Class Code.SubClass  field
   UCHAR  ClassCodeBaseClass;               //     6: Class Code.BaseClass field
   UCHAR  FunctionNumber;                   //     7: Function Number
   UCHAR  DeviceNumber;                     //     8: Device Number
   UCHAR  BusNumber;                        //     9: Bus Number
   UCHAR  SegmentNumber;                    //    10: Segment Number
   UCHAR  Reserved0;    
   ULONG  Reserved1;
} ERROR_PCI_COMPONENT_INFO, *PERROR_PCI_COMPONENT_INFO;

typedef struct _ERROR_PCI_COMPONENT  {
     ERROR_SECTION_HEADER        Header;
     ERROR_PCI_COMPONENT_VALID   Valid;
     ERROR_STATUS                ErrorStatus;                 // Component Error Status
     ERROR_PCI_COMPONENT_INFO    Info;                        // Component Information
     ULONG                       MemoryMappedRegistersPairs;  // Number of Memory Mapped Registers Pairs
     ULONG                       ProgrammedIORegistersPairs;  // Number of Programmed IO Registers Pairs
#if 0
     ULONGLONG                   RegistersPairs[/* 2 * (MemoryMappedRegistersPairs + ProgrammedIORegistersPairs) */];
     ERROR_OEM_DATA              OemData;
#endif // 0
 } ERROR_PCI_COMPONENT, *PERROR_PCI_COMPONENT;

//
// IA64 ERRORS: Platform ERROR_SYSTEM_EVENT_LOG device definitions
//
// With reference to the IPMI System Event Log.
//

#define ERROR_SYSTEM_EVENT_LOG_GUID \
    { 0xe429faf3, 0x3cb7, 0x11d4, { 0xbc, 0xa7, 0x0, 0x80, 0xc7, 0x3c, 0x88, 0x81 }}

typedef union _ERROR_SYSTEM_EVENT_LOG_VALID    {
    ULONGLONG     Valid;
    struct {                                // Bits
        ULONGLONG RecordId:1;               //       0: Record Identifier     valid bit
        ULONGLONG RecordType:1;             //       1: Record Type           valid bit
        ULONGLONG GeneratorId:1;            //       2: Generator Identifier  valid bit
        ULONGLONG EVMRev:1;                 //       3: Event Format Revision valid bit
        ULONGLONG SensorType:1;             //       4: Sensor Type           valid bit
        ULONGLONG SensorNum:1;              //       5: Sensor Number         valid bit
        ULONGLONG EventDirType:1;           //       6: Event Dir             valid bit
        ULONGLONG EventData1:1;             //       7: Event Data1           valid bit
        ULONGLONG EventData2:1;             //       8: Event Data2           valid bit
        ULONGLONG EventData3:1;             //       9: Event Data3           valid bit
        ULONGLONG Reserved:54;              //   10-63:
    };
} ERROR_SYSTEM_EVENT_LOG_VALID, *PSYSTEM_EVENT_LOG_VALID;

typedef struct _ERROR_SYSTEM_EVENT_LOG    {
    ERROR_SECTION_HEADER         Header;
    ERROR_SYSTEM_EVENT_LOG_VALID Valid;
    USHORT                       RecordId;     // Record Identifier used for SEL record access
    UCHAR                        RecordType;   // Record Type:
                                               //   0x02 - System Event Record
                                               //   0xC0 - 0xDF OEM     time stamped, bytes 8-16 OEM defined
                                               //   0xE0 - 0xFF OEM non-time stamped, bytes 4-16 OEM defined
    ULONG                        TimeStamp;    // Time stamp of the event log
    USHORT                       GeneratorId;  // Software ID if event was generated by software
                                               //   Byte 1:
                                               //       Bit 0   - set to 1 when using system software
                                               //       Bit 7:1 - 7-bit system ID
                                               //   Byte 2:
                                               //       Bit 1:0 - IPMB device LUN if byte 1 holds slave
                                               //                 address, 0x0 otherwise
                                               //       Bit 7:2 - Reserved.
    UCHAR                        EVMRevision;  // Error message format version
    UCHAR                        SensorType;   // Sensor Type code of the sensor that generated event
    UCHAR                        SensorNumber; // Number of the sensor that generated event
    UCHAR                        EventDir;     // Event Dir
                                               //   Bit 7 - 0: asserted, 1: desasserted
                                               // Event Type
                                               //   Bit 6:0 - Event Type code
    UCHAR                        Data1;        // Event data field
    UCHAR                        Data2;        // Event data field
    UCHAR                        Data3;        // Event data field
} ERROR_SYSTEM_EVENT_LOG, *PERROR_SYSTEM_EVENT_LOG;

//
// IA64 ERRORS: Platform ERROR_SMBIOS device definitions
//
// With reference to the SMBIOS Specifications.
//

#define ERROR_SMBIOS_GUID \
    { 0xe429faf5, 0x3cb7, 0x11d4, { 0xbc, 0xa7, 0x0, 0x80, 0xc7, 0x3c, 0x88, 0x81 }}

typedef union _ERROR_SMBIOS_VALID    {
    ULONGLONG     Valid;
    struct {                                // Bits
        ULONGLONG EventType:1;              //       0: Event Type valid bit
        ULONGLONG Length:1;                 //       1: Length     valid bit
        ULONGLONG TimeStamp:1;              //       2: Time Stamp valid bit
        ULONGLONG OemData:1;                //       3: Data       valid bit
        ULONGLONG Reserved:60;              //    4-63:
    };
} ERROR_SMBIOS_VALID, *PERROR_SMBIOS_VALID;

//
// ERROR_SMBIOS.Type definitions
//

typedef UCHAR ERROR_SMBIOS_EVENT_TYPE, *PERROR_SMBIOS_EVENT_TYPE;
// enum values defined in SMBIOS 2.3 - 3.3.16.6.1

typedef struct _ERROR_SMBIOS    {
    ERROR_SECTION_HEADER     Header;
    ERROR_SMBIOS_VALID       Valid;
    ERROR_SMBIOS_EVENT_TYPE  EventType;   // Event Type
    UCHAR                    Length;      // Length of the error information in bytes
    ERROR_TIMESTAMP          TimeStamp;   // Event Time Stamp
    ERROR_OEM_DATA           OemData;     // Optional data validated by SMBIOS.Valid.Data.
} ERROR_SMBIOS, *PERROR_SMBIOS;

//
// IA64 ERRORS: Platform Specific error device definitions
//

#define ERROR_PLATFORM_SPECIFIC_GUID \
    { 0xe429faf7, 0x3cb7, 0x11d4, { 0xbc, 0xa7, 0x0, 0x80, 0xc7, 0x3c, 0x88, 0x81 }}

typedef union _ERROR_PLATFORM_SPECIFIC_VALID   {
    ULONGLONG Valid;
    struct {                               // Bits:
        ULONGLONG ErrorStatus:1;          //    0: Error Status         valid bit
        ULONGLONG RequestorId:1;          //    1: Requestor Identifier valid bit
        ULONGLONG ResponderId:1;          //    2: Responder Identifier valid bit
        ULONGLONG TargetId:1;             //    3: Target    Identifier valid bit
        ULONGLONG BusSpecificData:1;      //    4: Bus Specific Data    valid bit
        ULONGLONG OemId:1;                //    5: OEM Identification   valid bit
        ULONGLONG OemData:1;              //    6: OEM Data             valid bit
        ULONGLONG OemDevicePath:1;        //    7: OEM Device Path      valid bit
        ULONGLONG Reserved:56;            // 63-8: Reserved
    };
} ERROR_PLATFORM_SPECIFIC_VALID, *PERROR_PLATFORM_SPECIFIC_VALID;

typedef struct _ERROR_PLATFORM_SPECIFIC  {
     ERROR_SECTION_HEADER           Header;
     ERROR_PLATFORM_SPECIFIC_VALID  Valid;
     ERROR_STATUS                   ErrorStatus; // Platform Generic Error Status
     ULONGLONG                      RequestorId; // Bus Requestor ID at the time of the event
     ULONGLONG                      ResponderId; // Bus Responder ID at the time of the event
     ULONGLONG                      TargetId;    // Bus intended Target ID at the time of the event
     ERROR_BUS_SPECIFIC_DATA        BusSpecificData; // OEM specific Bus dependent data
     UCHAR                          OemId[16];       // OEM specific data for bus identification
     ERROR_OEM_DATA                 OemData;         // OEM specific data 
#if 0
     UCHAR                          OemDevicePath[/* 16 ? */]; // OEM specific vendor device path.
#endif // 0
 } ERROR_PLATFORM_SPECIFIC, *PERROR_PLATFORM_SPECIFIC;

//
// IA64 ERRORS: Platform Bus error device definitions
//

#define ERROR_PLATFORM_BUS_GUID \
    { 0xe429faf9, 0x3cb7, 0x11d4, { 0xbc, 0xa7, 0x0, 0x80, 0xc7, 0x3c, 0x88, 0x81 }}

typedef union _ERROR_PLATFORM_BUS_VALID   {
    ULONGLONG Valid;
    struct {                               // Bits:
        ULONGLONG ErrorStatus:1;          //    0: Error Status         valid bit
        ULONGLONG RequestorId:1;          //    1: Requestor Identifier valid bit
        ULONGLONG ResponderId:1;          //    2: Responder Identifier valid bit
        ULONGLONG TargetId:1;             //    3: Target    Identifier valid bit
        ULONGLONG BusSpecificData:1;      //    4: Bus Specific Data    valid bit
        ULONGLONG OemId:1;                //    5: OEM Identification   valid bit
        ULONGLONG OemData:1;              //    6: OEM Data             valid bit
        ULONGLONG OemDevicePath:1;        //    7: OEM Device Path      valid bit
        ULONGLONG Reserved:56;            // 63-8: Reserved
    };
} ERROR_PLATFORM_BUS_VALID, *PERROR_PLATFORM_BUS_VALID;

typedef struct _ERROR_PLATFORM_BUS {
     ERROR_SECTION_HEADER        Header;
     ERROR_PLATFORM_BUS_VALID    Valid;
     ERROR_STATUS                ErrorStatus;       // Bus Error Status
     ULONGLONG                   RequestorId;       // Bus Requestor ID at the time of the event
     ULONGLONG                   ResponderId;       // Bus Responder ID at the time of the event
     ULONGLONG                   TargetId;          // Bus intended Target ID at the time of the event
     ERROR_BUS_SPECIFIC_DATA     BusSpecificData;   // OEM specific Bus dependent data
     UCHAR                       OemId[16];         // OEM specific data for bus identification
     ERROR_OEM_DATA              OemData;           // OEM specific data 
#if 0
     UCHAR                       OemDevicePath[/* 16 ? */]; // OEM specific vendor device path.
#endif // 0
 } ERROR_PLATFORM_BUS, *PERROR_PLATFORM_BUS;

//
// IA64 ERRORS: Platform Host Controller error device definitions
//

#define ERROR_PLATFORM_HOST_CONTROLLER_GUID \
    { 0xe429faf8, 0x3cb7, 0x11d4, { 0xbc, 0xa7, 0x0, 0x80, 0xc7, 0x3c, 0x88, 0x81 }}
    

typedef union _ERROR_PLATFORM_HOST_CONTROLLER_VALID   {
    ULONGLONG Valid;
    struct {                               // Bits:
        ULONGLONG ErrorStatus:1;          //    0: Error Status         valid bit
        ULONGLONG RequestorId:1;          //    1: Requestor Identifier valid bit
        ULONGLONG ResponderId:1;          //    2: Responder Identifier valid bit
        ULONGLONG TargetId:1;             //    3: Target    Identifier valid bit
        ULONGLONG BusSpecificData:1;      //    4: Bus Specific Data    valid bit
        ULONGLONG OemId:1;                //    5: OEM Identification   valid bit
        ULONGLONG OemData:1;              //    6: OEM Data             valid bit
        ULONGLONG OemDevicePath:1;        //    7: OEM Device Path      valid bit
        ULONGLONG Reserved:56;            // 63-8: Reserved
    };
} ERROR_PLATFORM_HOST_CONTROLLER_VALID, *PERROR_PLATFORM_HOST_CONTROLLER_VALID;

typedef struct _ERROR_PLATFORM_HOST_CONTROLLER {
     ERROR_SECTION_HEADER        Header;
     ERROR_PCI_COMPONENT_VALID   Valid;
     ERROR_STATUS                ErrorStatus;       // Host Controller Error Status
     ULONGLONG                   RequestorId;       // Host controller Requestor ID at the time of the event
     ULONGLONG                   ResponderId;       // Host controller Responder ID at the time of the event
     ULONGLONG                   TargetId;          // Host controller intended Target ID at the time of the event
     ERROR_BUS_SPECIFIC_DATA     BusSpecificData;   // OEM specific Bus dependent data
     UCHAR                       OemId[16];         // OEM specific data for bus identification
     ERROR_OEM_DATA              OemData;           // OEM specific data 
#if 0
     UCHAR                       OemDevicePath[/* 16 ? */]; // OEM specific vendor device path.
#endif // 0
} ERROR_PLATFORM_HOST_CONTROLLER, *PERROR_PLATFORM_HOST_CONTROLLER;

//
// IA64 ERROR_LOGRECORDS definitions
//
//  MCA_EXCEPTION,
//  CMC_EXCEPTION,
//  CPE_EXCEPTION.
//

// For compatibility with previous versions of the definitions:
typedef ERROR_RECORD_HEADER ERROR_LOGRECORD, *PERROR_LOGRECORD;

typedef ERROR_RECORD_HEADER MCA_EXCEPTION, *PMCA_EXCEPTION;    // Machine Check Abort
typedef ERROR_RECORD_HEADER CMC_EXCEPTION, *PCMC_EXCEPTION;    // Corrected Machine Check
typedef ERROR_RECORD_HEADER CPE_EXCEPTION, *PCPE_EXCEPTION;    // Corrected Platform Error

#endif // _IA64_

#endif // defined(_X86_) || defined(_IA64_) || defined(_AMD64_)

#endif // _MCE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\ddk\inc\mf.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    mf.h

Abstract:

    This header describes the structures and interfaces required to interact
    with the multifunction enumerator.

Author:

    Andy Thornton (andrewth) 20-Oct-97

Revision History:

--*/


#if !defined(_MF_)
#define _MF_

//
// MfFlags value
//

#define MF_FLAGS_EVEN_IF_NO_RESOURCE            0x00000001
#define MF_FLAGS_NO_CREATE_IF_NO_RESOURCE       0x00000002
#define MF_FLAGS_FILL_IN_UNKNOWN_RESOURCE       0x00000004
#define MF_FLAGS_CREATE_BUT_NO_SHOW_DISABLED    0x00000008

typedef struct _MF_RESOURCE_MAP {

    ULONG Count;
    UCHAR Resources[ANYSIZE_ARRAY];

} MF_RESOURCE_MAP, *PMF_RESOURCE_MAP;


typedef struct _MF_VARYING_RESOURCE_ENTRY {

    UCHAR ResourceIndex;
    UCHAR Reserved[3];      // Packing
    ULONG Offset;
    ULONG Size;
    ULONG MaxCount;

} MF_VARYING_RESOURCE_ENTRY, *PMF_VARYING_RESOURCE_ENTRY;


typedef struct _MF_VARYING_RESOURCE_MAP {

    ULONG Count;
    MF_VARYING_RESOURCE_ENTRY Resources[ANYSIZE_ARRAY];

} MF_VARYING_RESOURCE_MAP, *PMF_VARYING_RESOURCE_MAP;


typedef struct _MF_DEVICE_INFO *PMF_DEVICE_INFO;

typedef struct _MF_DEVICE_INFO {

    //
    // Name for this child, unique with respect to the other children
    //
    UNICODE_STRING Name;

    //
    // A REG_MULTI_SZ style list of hardware IDs
    //
    UNICODE_STRING HardwareID;

    //
    // A REG_MULTI_SZ style list of compatible IDs
    //
    UNICODE_STRING CompatibleID;

    //
    // Map of resource that we totally consume
    //
    PMF_RESOURCE_MAP ResourceMap;

    //
    // Map of resource that we partially consume
    //
    PMF_VARYING_RESOURCE_MAP VaryingResourceMap;

    //
    // Flags -
    //      MF_FLAGS_FILL_IN_UNKNOWN_RESOURCE - if the parent resource doesn't
    //          contain a descriptor referenced in the ResourceMap use a
    //          null (CmResourceTypeNull) descriptor instead.
    //
    ULONG MfFlags;

} MF_DEVICE_INFO;

typedef
NTSTATUS
(*PMF_ENUMERATE_CHILD)(
    IN PVOID Context,
    IN ULONG Index,
    OUT PMF_DEVICE_INFO ChildInfo
    );

/*++


Routine Description:

    This returns information about children to be enumerated by a multifunction
    driver.

Arguments:

    Context - Context from the MF_ENUMERATION_INTERFACE

    Index - Zero based index of the children

    ChildInfo - Pointer to a caller allocated buffer that should be filled in
        by the callee.  This will involve allocation of extra buffers for each
        piece of information.  These will be freed by calling ExFreePool when
        they are no longer required.

Return Value:

    Status code that indicates whether or not the function was successful.

    STATUS_NO_MORE_ENTRIES indicates that the are no more children to enumerate

--*/

typedef struct _MF_ENUMERATION_INTERFACE {

    //
    // Generic interface header
    //
    USHORT Size;
    USHORT Version;
    PVOID Context;
    PINTERFACE_REFERENCE InterfaceReference;
    PINTERFACE_DEREFERENCE InterfaceDereference;

    //
    // Multi-function enumeration data
    //
    PMF_ENUMERATE_CHILD EnumerateChild;

} MF_ENUMERATION_INTERFACE, *PMF_ENUMERATION_INTERFACE;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\ddk\inc\miniport.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    miniport.h

Abstract:

    Type definitions for miniport drivers.

Revision History:

--*/

#ifndef _MINIPORT_
#define _MINIPORT_

#include "stddef.h"

#define ASSERT( exp )

#ifndef FAR
#define FAR
#endif


#ifndef IN
#define IN
#endif

#ifndef OUT
#define OUT
#endif

#ifndef OPTIONAL
#define OPTIONAL
#endif

#ifndef NOTHING
#define NOTHING
#endif

#ifndef CRITICAL
#define CRITICAL
#endif

#ifndef ANYSIZE_ARRAY
#define ANYSIZE_ARRAY 1       // winnt
#endif

// begin_winnt

#if defined(_M_MRX000) && !(defined(MIDL_PASS) || defined(RC_INVOKED)) && defined(ENABLE_RESTRICTED)
#define RESTRICTED_POINTER __restrict
#else
#define RESTRICTED_POINTER
#endif

#if defined(_M_MRX000) || defined(_M_ALPHA) || defined(_M_PPC) || defined(_M_IA64) || defined(_M_AMD64)
#define UNALIGNED __unaligned
#if defined(_WIN64)
#define UNALIGNED64 __unaligned
#else
#define UNALIGNED64
#endif
#else
#define UNALIGNED
#define UNALIGNED64
#endif


#if defined(_WIN64) || defined(_M_ALPHA)
#define MAX_NATURAL_ALIGNMENT sizeof(ULONGLONG)
#define MEMORY_ALLOCATION_ALIGNMENT 16
#else
#define MAX_NATURAL_ALIGNMENT sizeof(ULONG)
#define MEMORY_ALLOCATION_ALIGNMENT 8
#endif

//
// TYPE_ALIGNMENT will return the alignment requirements of a given type for
// the current platform.
//

#ifdef __cplusplus
#if _MSC_VER >= 1300
#define TYPE_ALIGNMENT( t ) __alignof(t)
#endif
#else
#define TYPE_ALIGNMENT( t ) \
    FIELD_OFFSET( struct { char x; t test; }, test )
#endif

#if defined(_WIN64)

#define PROBE_ALIGNMENT( _s ) (TYPE_ALIGNMENT( _s ) > TYPE_ALIGNMENT( ULONG ) ? \
                               TYPE_ALIGNMENT( _s ) : TYPE_ALIGNMENT( ULONG ))

#define PROBE_ALIGNMENT32( _s ) TYPE_ALIGNMENT( ULONG )

#else

#define PROBE_ALIGNMENT( _s ) TYPE_ALIGNMENT( ULONG )

#endif

//
// C_ASSERT() can be used to perform many compile-time assertions:
//            type sizes, field offsets, etc.
//
// An assertion failure results in error C2118: negative subscript.
//

#define C_ASSERT(e) typedef char __C_ASSERT__[(e)?1:-1]

#if !defined(_MAC) && (defined(_M_MRX000) || defined(_M_AMD64) || defined(_M_IA64)) && (_MSC_VER >= 1100) && !(defined(MIDL_PASS) || defined(RC_INVOKED))
#define POINTER_64 __ptr64
typedef unsigned __int64 POINTER_64_INT;
#if defined(_WIN64)
#define POINTER_32 __ptr32
#else
#define POINTER_32
#endif
#else
#if defined(_MAC) && defined(_MAC_INT_64)
#define POINTER_64 __ptr64
typedef unsigned __int64 POINTER_64_INT;
#else
#define POINTER_64
typedef unsigned long POINTER_64_INT;
#endif
#define POINTER_32
#endif

#if defined(_IA64_) || defined(_AMD64_)
#define FIRMWARE_PTR
#else
#define FIRMWARE_PTR POINTER_32
#endif

#include <basetsd.h>

// end_winnt

#ifndef CONST
#define CONST               const
#endif

// begin_winnt

#if (defined(_M_IX86) || defined(_M_IA64) || defined(_M_AMD64)) && !defined(MIDL_PASS)
#define DECLSPEC_IMPORT __declspec(dllimport)
#else
#define DECLSPEC_IMPORT
#endif

#ifndef DECLSPEC_NORETURN
#if (_MSC_VER >= 1200) && !defined(MIDL_PASS)
#define DECLSPEC_NORETURN   __declspec(noreturn)
#else
#define DECLSPEC_NORETURN
#endif
#endif

#ifndef DECLSPEC_ALIGN
#if (_MSC_VER >= 1300) && !defined(MIDL_PASS)
#define DECLSPEC_ALIGN(x)   __declspec(align(x))
#else
#define DECLSPEC_ALIGN(x)
#endif
#endif

#ifndef DECLSPEC_CACHEALIGN
#define DECLSPEC_CACHEALIGN DECLSPEC_ALIGN(128)
#endif

#ifndef DECLSPEC_UUID
#if (_MSC_VER >= 1100) && defined (__cplusplus)
#define DECLSPEC_UUID(x)    __declspec(uuid(x))
#else
#define DECLSPEC_UUID(x)
#endif
#endif

#ifndef DECLSPEC_NOVTABLE
#if (_MSC_VER >= 1100) && defined(__cplusplus)
#define DECLSPEC_NOVTABLE   __declspec(novtable)
#else
#define DECLSPEC_NOVTABLE
#endif
#endif

#ifndef DECLSPEC_SELECTANY
#if (_MSC_VER >= 1100)
#define DECLSPEC_SELECTANY  __declspec(selectany)
#else
#define DECLSPEC_SELECTANY
#endif
#endif

#ifndef NOP_FUNCTION
#if (_MSC_VER >= 1210)
#define NOP_FUNCTION __noop
#else
#define NOP_FUNCTION (void)0
#endif
#endif

#ifndef DECLSPEC_ADDRSAFE
#if (_MSC_VER >= 1200) && (defined(_M_ALPHA) || defined(_M_AXP64))
#define DECLSPEC_ADDRSAFE  __declspec(address_safe)
#else
#define DECLSPEC_ADDRSAFE
#endif
#endif

#ifndef FORCEINLINE
#if (_MSC_VER >= 1200)
#define FORCEINLINE __forceinline
#else
#define FORCEINLINE __inline
#endif
#endif

#ifndef DECLSPEC_DEPRECATED
#if (_MSC_VER >= 1300) && !defined(MIDL_PASS)
#define DECLSPEC_DEPRECATED   __declspec(deprecated)
#define DEPRECATE_SUPPORTED
#else
#define DECLSPEC_DEPRECATED
#undef  DEPRECATE_SUPPORTED
#endif
#endif

// end_winnt

#ifdef DEPRECATE_DDK_FUNCTIONS
#ifdef _NTDDK_
#define DECLSPEC_DEPRECATED_DDK DECLSPEC_DEPRECATED
#ifdef DEPRECATE_SUPPORTED
#define PRAGMA_DEPRECATED_DDK 1
#endif
#else
#define DECLSPEC_DEPRECATED_DDK
#define PRAGMA_DEPRECATED_DDK 1
#endif
#else
#define DECLSPEC_DEPRECATED_DDK
#define PRAGMA_DEPRECATED_DDK 0
#endif

//
// Void
//
// begin_winnt

typedef void *PVOID;
typedef void * POINTER_64 PVOID64;

// end_winnt

#if defined(_M_IX86)
#define FASTCALL _fastcall
#else
#define FASTCALL
#endif


//
// Basics
//

#ifndef VOID
#define VOID void
typedef char CHAR;
typedef short SHORT;
typedef long LONG;
#endif

//
// UNICODE (Wide Character) types
//

#ifndef _MAC
typedef wchar_t WCHAR;    // wc,   16-bit UNICODE character
#else
// some Macintosh compilers don't define wchar_t in a convenient location, or define it as a char
typedef unsigned short WCHAR;    // wc,   16-bit UNICODE character
#endif

typedef WCHAR *PWCHAR;
typedef WCHAR *LPWCH, *PWCH;
typedef CONST WCHAR *LPCWCH, *PCWCH;
typedef WCHAR *NWPSTR;
typedef WCHAR *LPWSTR, *PWSTR;
typedef WCHAR UNALIGNED *LPUWSTR, *PUWSTR;

typedef CONST WCHAR *LPCWSTR, *PCWSTR;
typedef CONST WCHAR UNALIGNED *LPCUWSTR, *PCUWSTR;

//
// ANSI (Multi-byte Character) types
//
typedef CHAR *PCHAR;
typedef CHAR *LPCH, *PCH;

typedef CONST CHAR *LPCCH, *PCCH;
typedef CHAR *NPSTR;
typedef CHAR *LPSTR, *PSTR;
typedef CONST CHAR *LPCSTR, *PCSTR;

//
// Neutral ANSI/UNICODE types and macros
//
#ifdef  UNICODE                     // r_winnt

#ifndef _TCHAR_DEFINED
typedef WCHAR TCHAR, *PTCHAR;
typedef WCHAR TUCHAR, *PTUCHAR;
#define _TCHAR_DEFINED
#endif /* !_TCHAR_DEFINED */

typedef LPWSTR LPTCH, PTCH;
typedef LPWSTR PTSTR, LPTSTR;
typedef LPCWSTR PCTSTR, LPCTSTR;
typedef LPUWSTR PUTSTR, LPUTSTR;
typedef LPCUWSTR PCUTSTR, LPCUTSTR;
typedef LPWSTR LP;
#define __TEXT(quote) L##quote      // r_winnt

#else   /* UNICODE */               // r_winnt

#ifndef _TCHAR_DEFINED
typedef char TCHAR, *PTCHAR;
typedef unsigned char TUCHAR, *PTUCHAR;
#define _TCHAR_DEFINED
#endif /* !_TCHAR_DEFINED */

typedef LPSTR LPTCH, PTCH;
typedef LPSTR PTSTR, LPTSTR, PUTSTR, LPUTSTR;
typedef LPCSTR PCTSTR, LPCTSTR, PCUTSTR, LPCUTSTR;
#define __TEXT(quote) quote         // r_winnt

#endif /* UNICODE */                // r_winnt
#define TEXT(quote) __TEXT(quote)   // r_winnt


// end_winnt

typedef double DOUBLE;

typedef struct _QUAD {              // QUAD is for those times we want
    double  DoNotUseThisField;      // an 8 byte aligned 8 byte long structure
} QUAD;                             // which is NOT really a floating point
                                    // number.  Use DOUBLE if you want an FP
                                    // number.

//
// Pointer to Basics
//

typedef SHORT *PSHORT;  // winnt
typedef LONG *PLONG;    // winnt
typedef QUAD *PQUAD;

//
// Unsigned Basics
//

// Tell windef.h that some types are already defined.
#define BASETYPES

typedef unsigned char UCHAR;
typedef unsigned short USHORT;
typedef unsigned long ULONG;
typedef QUAD UQUAD;

//
// Pointer to Unsigned Basics
//

typedef UCHAR *PUCHAR;
typedef USHORT *PUSHORT;
typedef ULONG *PULONG;
typedef UQUAD *PUQUAD;

//
// Signed characters
//

typedef signed char SCHAR;
typedef SCHAR *PSCHAR;

#ifndef NO_STRICT
#ifndef STRICT
#define STRICT 1
#endif
#endif

//
// Handle to an Object
//

// begin_winnt

#ifdef STRICT
typedef void *HANDLE;
#define DECLARE_HANDLE(name) struct name##__ { int unused; }; typedef struct name##__ *name
#else
typedef PVOID HANDLE;
#define DECLARE_HANDLE(name) typedef HANDLE name
#endif
typedef HANDLE *PHANDLE;

//
// Flag (bit) fields
//

typedef UCHAR  FCHAR;
typedef USHORT FSHORT;
typedef ULONG  FLONG;

// Component Object Model defines, and macros

#ifndef _HRESULT_DEFINED
#define _HRESULT_DEFINED
typedef LONG HRESULT;

#endif // !_HRESULT_DEFINED

#ifdef __cplusplus
    #define EXTERN_C    extern "C"
#else
    #define EXTERN_C    extern
#endif

#if defined(_WIN32) || defined(_MPPC_)

// Win32 doesn't support __export

#ifdef _68K_
#define STDMETHODCALLTYPE       __cdecl
#else
#define STDMETHODCALLTYPE       __stdcall
#endif
#define STDMETHODVCALLTYPE      __cdecl

#define STDAPICALLTYPE          __stdcall
#define STDAPIVCALLTYPE         __cdecl

#else

#define STDMETHODCALLTYPE       __export __stdcall
#define STDMETHODVCALLTYPE      __export __cdecl

#define STDAPICALLTYPE          __export __stdcall
#define STDAPIVCALLTYPE         __export __cdecl

#endif


#define STDAPI                  EXTERN_C HRESULT STDAPICALLTYPE
#define STDAPI_(type)           EXTERN_C type STDAPICALLTYPE

#define STDMETHODIMP            HRESULT STDMETHODCALLTYPE
#define STDMETHODIMP_(type)     type STDMETHODCALLTYPE

// The 'V' versions allow Variable Argument lists.

#define STDAPIV                 EXTERN_C HRESULT STDAPIVCALLTYPE
#define STDAPIV_(type)          EXTERN_C type STDAPIVCALLTYPE

#define STDMETHODIMPV           HRESULT STDMETHODVCALLTYPE
#define STDMETHODIMPV_(type)    type STDMETHODVCALLTYPE

// end_winnt


//
// Low order two bits of a handle are ignored by the system and available
// for use by application code as tag bits.  The remaining bits are opaque
// and used to store a serial number and table index.
//

#define OBJ_HANDLE_TAGBITS  0x00000003L

//
// Cardinal Data Types [0 - 2**N-2)
//

typedef char CCHAR;          // winnt
typedef short CSHORT;
typedef ULONG CLONG;

typedef CCHAR *PCCHAR;
typedef CSHORT *PCSHORT;
typedef CLONG *PCLONG;


//
// __int64 is only supported by 2.0 and later midl.
// __midl is set by the 2.0 midl and not by 1.0 midl.
//

#define _ULONGLONG_
#if (!defined (_MAC) && (!defined(MIDL_PASS) || defined(__midl)) && (!defined(_M_IX86) || (defined(_INTEGRAL_MAX_BITS) && _INTEGRAL_MAX_BITS >= 64)))
typedef __int64 LONGLONG;
typedef unsigned __int64 ULONGLONG;

#define MAXLONGLONG                      (0x7fffffffffffffff)
#else

#if defined(_MAC) && defined(_MAC_INT_64)
typedef __int64 LONGLONG;
typedef unsigned __int64 ULONGLONG;

#define MAXLONGLONG                      (0x7fffffffffffffff)
#else
typedef double LONGLONG;
typedef double ULONGLONG;
#endif //_MAC and int64

#endif

typedef LONGLONG *PLONGLONG;
typedef ULONGLONG *PULONGLONG;

// Update Sequence Number

typedef LONGLONG USN;

#if defined(MIDL_PASS)
typedef struct _LARGE_INTEGER {
#else // MIDL_PASS
typedef union _LARGE_INTEGER {
    struct {
        ULONG LowPart;
        LONG HighPart;
    };
    struct {
        ULONG LowPart;
        LONG HighPart;
    } u;
#endif //MIDL_PASS
    LONGLONG QuadPart;
} LARGE_INTEGER;

typedef LARGE_INTEGER *PLARGE_INTEGER;

#if defined(MIDL_PASS)
typedef struct _ULARGE_INTEGER {
#else // MIDL_PASS
typedef union _ULARGE_INTEGER {
    struct {
        ULONG LowPart;
        ULONG HighPart;
    };
    struct {
        ULONG LowPart;
        ULONG HighPart;
    } u;
#endif //MIDL_PASS
    ULONGLONG QuadPart;
} ULARGE_INTEGER;

typedef ULARGE_INTEGER *PULARGE_INTEGER;


//
// Physical address.
//

typedef LARGE_INTEGER PHYSICAL_ADDRESS, *PPHYSICAL_ADDRESS;


//
// Boolean
//

typedef UCHAR BOOLEAN;           // winnt
typedef BOOLEAN *PBOOLEAN;       // winnt


//
// Constants
//

#define FALSE   0
#define TRUE    1

#ifndef NULL
#ifdef __cplusplus
#define NULL    0
#define NULL64  0
#else
#define NULL    ((void *)0)
#define NULL64  ((void * POINTER_64)0)
#endif
#endif // NULL

//
// Calculate the byte offset of a field in a structure of type type.
//

#define FIELD_OFFSET(type, field)    ((LONG)(LONG_PTR)&(((type *)0)->field))

#if(_WIN32_WINNT > 0x0500)

//
// Calculate the size of a field in a structure of type type, without
// knowing or stating the type of the field.
//
#define RTL_FIELD_SIZE(type, field) (sizeof(((type *)0)->field))

//
// Calculate the size of a structure of type type up through and
// including a field.
//
#define RTL_SIZEOF_THROUGH_FIELD(type, field) \
    (FIELD_OFFSET(type, field) + RTL_FIELD_SIZE(type, field))

//
//  RTL_CONTAINS_FIELD usage:
//
//      if (RTL_CONTAINS_FIELD(pBlock, pBlock->cbSize, dwMumble)) { // safe to use pBlock->dwMumble
//
#define RTL_CONTAINS_FIELD(Struct, Size, Field) \
    ( (((PCHAR)(&(Struct)->Field)) + sizeof((Struct)->Field)) <= (((PCHAR)(Struct))+(Size)) )

//
// Return the number of elements in a statically sized array.
//   ULONG Buffer[100];
//   RTL_NUMBER_OF(Buffer) == 100
// This is also popularly known as: NUMBER_OF, ARRSIZE, _countof, NELEM, etc.
//
#define RTL_NUMBER_OF(A) (sizeof(A)/sizeof((A)[0]))

//
// An expression that yields the type of a field in a struct.
//
#define RTL_FIELD_TYPE(type, field) (((type*)0)->field)

// RTL_ to avoid collisions in the global namespace.
//
// Given typedef struct _FOO { BYTE Bar[123]; } FOO;
// RTL_NUMBER_OF_FIELD(FOO, Bar) == 123
//
#define RTL_NUMBER_OF_FIELD(type, field) (RTL_NUMBER_OF(RTL_FIELD_TYPE(type, field)))

//
// eg:
// typedef struct FOO {
//   ULONG Integer;
//   PVOID Pointer;
// } FOO;
//
// RTL_PADDING_BETWEEN_FIELDS(FOO, Integer, Pointer) == 0 for Win32, 4 for Win64
//
#define RTL_PADDING_BETWEEN_FIELDS(T, F1, F2) \
    ((FIELD_OFFSET(T, F2) > FIELD_OFFSET(T, F1)) \
        ? (FIELD_OFFSET(T, F2) - FIELD_OFFSET(T, F1) - RTL_FIELD_SIZE(T, F1)) \
        : (FIELD_OFFSET(T, F1) - FIELD_OFFSET(T, F2) - RTL_FIELD_SIZE(T, F2)))

// RTL_ to avoid collisions in the global namespace.
#if defined(__cplusplus)
#define RTL_CONST_CAST(type) const_cast<type>
#else
#define RTL_CONST_CAST(type) (type)
#endif

// end_winnt
//
// This works "generically" for Unicode and Ansi/Oem strings.
// Usage:
//   const static UNICODE_STRING FooU = RTL_CONSTANT_STRING(L"Foo");
//   const static         STRING Foo  = RTL_CONSTANT_STRING( "Foo");
// instead of the slower:
//   UNICODE_STRING FooU;
//           STRING Foo;
//   RtlInitUnicodeString(&FooU, L"Foo");
//          RtlInitString(&Foo ,  "Foo");
//
#define RTL_CONSTANT_STRING(s) { sizeof( s ) - sizeof( (s)[0] ), sizeof( s ), s }
// begin_winnt

// like sizeof
// usually this would be * CHAR_BIT, but we don't necessarily have #include <limits.h>
#define RTL_BITS_OF(sizeOfArg) (sizeof(sizeOfArg) * 8)

#define RTL_BITS_OF_FIELD(type, field) (RTL_BITS_OF(RTL_FIELD_TYPE(type, field)))

#endif /* _WIN32_WINNT > 0x0500 */

//
// Calculate the address of the base of the structure given its type, and an
// address of a field within the structure.
//

#define CONTAINING_RECORD(address, type, field) ((type *)( \
                                                  (PCHAR)(address) - \
                                                  (ULONG_PTR)(&((type *)0)->field)))


//
// Interrupt Request Level (IRQL)
//

typedef UCHAR KIRQL;

typedef KIRQL *PKIRQL;


//
// Macros used to eliminate compiler warning generated when formal
// parameters or local variables are not declared.
//
// Use DBG_UNREFERENCED_PARAMETER() when a parameter is not yet
// referenced but will be once the module is completely developed.
//
// Use DBG_UNREFERENCED_LOCAL_VARIABLE() when a local variable is not yet
// referenced but will be once the module is completely developed.
//
// Use UNREFERENCED_PARAMETER() if a parameter will never be referenced.
//
// DBG_UNREFERENCED_PARAMETER and DBG_UNREFERENCED_LOCAL_VARIABLE will
// eventually be made into a null macro to help determine whether there
// is unfinished work.
//

#if ! defined(lint)
#define UNREFERENCED_PARAMETER(P)          (P)
#define DBG_UNREFERENCED_PARAMETER(P)      (P)
#define DBG_UNREFERENCED_LOCAL_VARIABLE(V) (V)

#else // lint

// Note: lint -e530 says don't complain about uninitialized variables for
// this varible.  Error 527 has to do with unreachable code.
// -restore restores checking to the -save state

#define UNREFERENCED_PARAMETER(P)          \
    /*lint -save -e527 -e530 */ \
    { \
        (P) = (P); \
    } \
    /*lint -restore */
#define DBG_UNREFERENCED_PARAMETER(P)      \
    /*lint -save -e527 -e530 */ \
    { \
        (P) = (P); \
    } \
    /*lint -restore */
#define DBG_UNREFERENCED_LOCAL_VARIABLE(V) \
    /*lint -save -e527 -e530 */ \
    { \
        (V) = (V); \
    } \
    /*lint -restore */

#endif // lint

//
// Macro used to eliminate compiler warning 4715 within a switch statement
// when all possible cases have already been accounted for.
//
// switch (a & 3) {
//     case 0: return 1;
//     case 1: return Foo();
//     case 2: return Bar();
//     case 3: return 1;
//     DEFAULT_UNREACHABLE;
//

#if (_MSC_VER > 1200)
#define DEFAULT_UNREACHABLE default: __assume(0)
#else

//
// Older compilers do not support __assume(), and there is no other free
// method of eliminating the warning.
//

#define DEFAULT_UNREACHABLE

#endif

// end_winnt

//
//  Define standard min and max macros
//

#ifndef NOMINMAX

#ifndef min
#define min(a,b) (((a) < (b)) ? (a) : (b))
#endif

#ifndef max
#define max(a,b) (((a) > (b)) ? (a) : (b))
#endif

#endif  // NOMINMAX


#ifdef _X86_

//
// Disable these two pragmas that evaluate to "sti" "cli" on x86 so that driver
// writers to not leave them inadvertantly in their code.
//

#if !defined(MIDL_PASS)
#if !defined(RC_INVOKED)

#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4164)   // disable C4164 warning so that apps that
                                // build with /Od don't get weird errors !
#ifdef _M_IX86
#pragma function(_enable)
#pragma function(_disable)
#endif

#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning(default:4164)   // reenable C4164 warning
#endif

#endif
#endif


#endif //_X86_

//
// Define the I/O bus interface types.
//

typedef enum _INTERFACE_TYPE {
    InterfaceTypeUndefined = -1,
    Internal,
    Isa,
    Eisa,
    MicroChannel,
    TurboChannel,
    PCIBus,
    VMEBus,
    NuBus,
    PCMCIABus,
    CBus,
    MPIBus,
    MPSABus,
    ProcessorInternal,
    InternalPowerBus,
    PNPISABus,
    PNPBus,
    MaximumInterfaceType
}INTERFACE_TYPE, *PINTERFACE_TYPE;

//
// Define the DMA transfer widths.
//

typedef enum _DMA_WIDTH {
    Width8Bits,
    Width16Bits,
    Width32Bits,
    MaximumDmaWidth
}DMA_WIDTH, *PDMA_WIDTH;

//
// Define DMA transfer speeds.
//

typedef enum _DMA_SPEED {
    Compatible,
    TypeA,
    TypeB,
    TypeC,
    TypeF,
    MaximumDmaSpeed
}DMA_SPEED, *PDMA_SPEED;

//
// Define Interface reference/dereference routines for
//  Interfaces exported by IRP_MN_QUERY_INTERFACE
//

typedef VOID (*PINTERFACE_REFERENCE)(PVOID Context);
typedef VOID (*PINTERFACE_DEREFERENCE)(PVOID Context);

// end_wdm

//
// Define types of bus information.
//

typedef enum _BUS_DATA_TYPE {
    ConfigurationSpaceUndefined = -1,
    Cmos,
    EisaConfiguration,
    Pos,
    CbusConfiguration,
    PCIConfiguration,
    VMEConfiguration,
    NuBusConfiguration,
    PCMCIAConfiguration,
    MPIConfiguration,
    MPSAConfiguration,
    PNPISAConfiguration,
    SgiInternalConfiguration,
    MaximumBusDataType
} BUS_DATA_TYPE, *PBUS_DATA_TYPE;


#include <guiddef.h>


//
// Interrupt modes.
//

typedef enum _KINTERRUPT_MODE {
    LevelSensitive,
    Latched
    } KINTERRUPT_MODE;


//
// Structures used by the kernel drivers to describe which ports must be
// hooked out directly from the V86 emulator to the driver.
//

typedef enum _EMULATOR_PORT_ACCESS_TYPE {
    Uchar,
    Ushort,
    Ulong
} EMULATOR_PORT_ACCESS_TYPE, *PEMULATOR_PORT_ACCESS_TYPE;

//
// Access Modes
//

#define EMULATOR_READ_ACCESS    0x01
#define EMULATOR_WRITE_ACCESS   0x02

typedef struct _EMULATOR_ACCESS_ENTRY {
    ULONG BasePort;
    ULONG NumConsecutivePorts;
    EMULATOR_PORT_ACCESS_TYPE AccessType;
    UCHAR AccessMode;
    UCHAR StringSupport;
    PVOID Routine;
} EMULATOR_ACCESS_ENTRY, *PEMULATOR_ACCESS_ENTRY;


typedef struct _PCI_SLOT_NUMBER {
    union {
        struct {
            ULONG   DeviceNumber:5;
            ULONG   FunctionNumber:3;
            ULONG   Reserved:24;
        } bits;
        ULONG   AsULONG;
    } u;
} PCI_SLOT_NUMBER, *PPCI_SLOT_NUMBER;


#define PCI_TYPE0_ADDRESSES             6
#define PCI_TYPE1_ADDRESSES             2
#define PCI_TYPE2_ADDRESSES             5

typedef struct _PCI_COMMON_CONFIG {
    USHORT  VendorID;                   // (ro)
    USHORT  DeviceID;                   // (ro)
    USHORT  Command;                    // Device control
    USHORT  Status;
    UCHAR   RevisionID;                 // (ro)
    UCHAR   ProgIf;                     // (ro)
    UCHAR   SubClass;                   // (ro)
    UCHAR   BaseClass;                  // (ro)
    UCHAR   CacheLineSize;              // (ro+)
    UCHAR   LatencyTimer;               // (ro+)
    UCHAR   HeaderType;                 // (ro)
    UCHAR   BIST;                       // Built in self test

    union {
        struct _PCI_HEADER_TYPE_0 {
            ULONG   BaseAddresses[PCI_TYPE0_ADDRESSES];
            ULONG   CIS;
            USHORT  SubVendorID;
            USHORT  SubSystemID;
            ULONG   ROMBaseAddress;
            UCHAR   CapabilitiesPtr;
            UCHAR   Reserved1[3];
            ULONG   Reserved2;
            UCHAR   InterruptLine;      //
            UCHAR   InterruptPin;       // (ro)
            UCHAR   MinimumGrant;       // (ro)
            UCHAR   MaximumLatency;     // (ro)
        } type0;


    } u;

    UCHAR   DeviceSpecific[192];

} PCI_COMMON_CONFIG, *PPCI_COMMON_CONFIG;


#define PCI_COMMON_HDR_LENGTH (FIELD_OFFSET (PCI_COMMON_CONFIG, DeviceSpecific))

#define PCI_MAX_DEVICES                     32
#define PCI_MAX_FUNCTION                    8
#define PCI_MAX_BRIDGE_NUMBER               0xFF

#define PCI_INVALID_VENDORID                0xFFFF

//
// Bit encodings for  PCI_COMMON_CONFIG.HeaderType
//

#define PCI_MULTIFUNCTION                   0x80
#define PCI_DEVICE_TYPE                     0x00
#define PCI_BRIDGE_TYPE                     0x01
#define PCI_CARDBUS_BRIDGE_TYPE             0x02

#define PCI_CONFIGURATION_TYPE(PciData) \
    (((PPCI_COMMON_CONFIG)(PciData))->HeaderType & ~PCI_MULTIFUNCTION)

#define PCI_MULTIFUNCTION_DEVICE(PciData) \
    ((((PPCI_COMMON_CONFIG)(PciData))->HeaderType & PCI_MULTIFUNCTION) != 0)

//
// Bit encodings for PCI_COMMON_CONFIG.Command
//

#define PCI_ENABLE_IO_SPACE                 0x0001
#define PCI_ENABLE_MEMORY_SPACE             0x0002
#define PCI_ENABLE_BUS_MASTER               0x0004
#define PCI_ENABLE_SPECIAL_CYCLES           0x0008
#define PCI_ENABLE_WRITE_AND_INVALIDATE     0x0010
#define PCI_ENABLE_VGA_COMPATIBLE_PALETTE   0x0020
#define PCI_ENABLE_PARITY                   0x0040  // (ro+)
#define PCI_ENABLE_WAIT_CYCLE               0x0080  // (ro+)
#define PCI_ENABLE_SERR                     0x0100  // (ro+)
#define PCI_ENABLE_FAST_BACK_TO_BACK        0x0200  // (ro)

//
// Bit encodings for PCI_COMMON_CONFIG.Status
//

#define PCI_STATUS_CAPABILITIES_LIST        0x0010  // (ro)
#define PCI_STATUS_66MHZ_CAPABLE            0x0020  // (ro)
#define PCI_STATUS_UDF_SUPPORTED            0x0040  // (ro)
#define PCI_STATUS_FAST_BACK_TO_BACK        0x0080  // (ro)
#define PCI_STATUS_DATA_PARITY_DETECTED     0x0100
#define PCI_STATUS_DEVSEL                   0x0600  // 2 bits wide
#define PCI_STATUS_SIGNALED_TARGET_ABORT    0x0800
#define PCI_STATUS_RECEIVED_TARGET_ABORT    0x1000
#define PCI_STATUS_RECEIVED_MASTER_ABORT    0x2000
#define PCI_STATUS_SIGNALED_SYSTEM_ERROR    0x4000
#define PCI_STATUS_DETECTED_PARITY_ERROR    0x8000

//
// The NT PCI Driver uses a WhichSpace parameter on its CONFIG_READ/WRITE
// routines.   The following values are defined-
//

#define PCI_WHICHSPACE_CONFIG               0x0
#define PCI_WHICHSPACE_ROM                  0x52696350

// end_wdm
//
// PCI Capability IDs
//

#define PCI_CAPABILITY_ID_POWER_MANAGEMENT  0x01
#define PCI_CAPABILITY_ID_AGP               0x02
#define PCI_CAPABILITY_ID_MSI               0x05

//
// All PCI Capability structures have the following header.
//
// CapabilityID is used to identify the type of the structure (is
// one of the PCI_CAPABILITY_ID values above.
//
// Next is the offset in PCI Configuration space (0x40 - 0xfc) of the
// next capability structure in the list, or 0x00 if there are no more
// entries.
//
typedef struct _PCI_CAPABILITIES_HEADER {
    UCHAR   CapabilityID;
    UCHAR   Next;
} PCI_CAPABILITIES_HEADER, *PPCI_CAPABILITIES_HEADER;

//
// Power Management Capability
//

typedef struct _PCI_PMC {
    UCHAR       Version:3;
    UCHAR       PMEClock:1;
    UCHAR       Rsvd1:1;
    UCHAR       DeviceSpecificInitialization:1;
    UCHAR       Rsvd2:2;
    struct _PM_SUPPORT {
        UCHAR   Rsvd2:1;
        UCHAR   D1:1;
        UCHAR   D2:1;
        UCHAR   PMED0:1;
        UCHAR   PMED1:1;
        UCHAR   PMED2:1;
        UCHAR   PMED3Hot:1;
        UCHAR   PMED3Cold:1;
    } Support;
} PCI_PMC, *PPCI_PMC;

typedef struct _PCI_PMCSR {
    USHORT      PowerState:2;
    USHORT      Rsvd1:6;
    USHORT      PMEEnable:1;
    USHORT      DataSelect:4;
    USHORT      DataScale:2;
    USHORT      PMEStatus:1;
} PCI_PMCSR, *PPCI_PMCSR;


typedef struct _PCI_PMCSR_BSE {
    UCHAR       Rsvd1:6;
    UCHAR       D3HotSupportsStopClock:1;       // B2_B3#
    UCHAR       BusPowerClockControlEnabled:1;  // BPCC_EN
} PCI_PMCSR_BSE, *PPCI_PMCSR_BSE;


typedef struct _PCI_PM_CAPABILITY {

    PCI_CAPABILITIES_HEADER Header;

    //
    // Power Management Capabilities (Offset = 2)
    //

    union {
        PCI_PMC         Capabilities;
        USHORT          AsUSHORT;
    } PMC;

    //
    // Power Management Control/Status (Offset = 4)
    //

    union {
        PCI_PMCSR       ControlStatus;
        USHORT          AsUSHORT;
    } PMCSR;

    //
    // PMCSR PCI-PCI Bridge Support Extensions
    //

    union {
        PCI_PMCSR_BSE   BridgeSupport;
        UCHAR           AsUCHAR;
    } PMCSR_BSE;

    //
    // Optional read only 8 bit Data register.  Contents controlled by
    // DataSelect and DataScale in ControlStatus.
    //

    UCHAR   Data;

} PCI_PM_CAPABILITY, *PPCI_PM_CAPABILITY;

//
// AGP Capability
//

typedef struct _PCI_AGP_CAPABILITY {

    PCI_CAPABILITIES_HEADER Header;

    USHORT  Minor:4;
    USHORT  Major:4;
    USHORT  Rsvd1:8;

    struct  _PCI_AGP_STATUS {
        ULONG   Rate:3;
        ULONG   Rsvd1:1;
        ULONG   FastWrite:1;
        ULONG   FourGB:1;
        ULONG   Rsvd2:3;
        ULONG   SideBandAddressing:1;                   // SBA
        ULONG   Rsvd3:14;
        ULONG   RequestQueueDepthMaximum:8;             // RQ
    } AGPStatus;

    struct  _PCI_AGP_COMMAND {
        ULONG   Rate:3;
        ULONG   Rsvd1:1;
        ULONG   FastWriteEnable:1;
        ULONG   FourGBEnable:1;
        ULONG   Rsvd2:2;
        ULONG   AGPEnable:1;
        ULONG   SBAEnable:1;
        ULONG   Rsvd3:14;
        ULONG   RequestQueueDepth:8;
    } AGPCommand;

} PCI_AGP_CAPABILITY, *PPCI_AGP_CAPABILITY;

#define PCI_AGP_RATE_1X     0x1
#define PCI_AGP_RATE_2X     0x2
#define PCI_AGP_RATE_4X     0x4

//
// MSI (Message Signalled Interrupts) Capability
//

typedef struct _PCI_MSI_CAPABILITY {

      PCI_CAPABILITIES_HEADER Header;

      struct _PCI_MSI_MESSAGE_CONTROL {
         USHORT  MSIEnable:1;
         USHORT  MultipleMessageCapable:3;
         USHORT  MultipleMessageEnable:3;
         USHORT  CapableOf64Bits:1;
         USHORT  Reserved:8;
      } MessageControl;

      union {
            struct _PCI_MSI_MESSAGE_ADDRESS {
               ULONG_PTR Reserved:2;              // always zero, DWORD aligned address
               ULONG_PTR Address:30;
            } Register;
            ULONG_PTR Raw;
      } MessageAddress;

      //
      // The rest of the Capability structure differs depending on whether
      // 32bit or 64bit addressing is being used.
      //
      // (The CapableOf64Bits bit above determines this)
      //

      union {

         // For 64 bit devices

         struct _PCI_MSI_64BIT_DATA {
            ULONG MessageUpperAddress;
            USHORT MessageData;
         } Bit64;

         // For 32 bit devices

         struct _PCI_MSI_32BIT_DATA {
            USHORT MessageData;
            ULONG Unused;
         } Bit32;
      } Data;

} PCI_MSI_CAPABILITY, *PPCI_PCI_CAPABILITY;

// begin_wdm
//
// Base Class Code encodings for Base Class (from PCI spec rev 2.1).
//

#define PCI_CLASS_PRE_20                    0x00
#define PCI_CLASS_MASS_STORAGE_CTLR         0x01
#define PCI_CLASS_NETWORK_CTLR              0x02
#define PCI_CLASS_DISPLAY_CTLR              0x03
#define PCI_CLASS_MULTIMEDIA_DEV            0x04
#define PCI_CLASS_MEMORY_CTLR               0x05
#define PCI_CLASS_BRIDGE_DEV                0x06
#define PCI_CLASS_SIMPLE_COMMS_CTLR         0x07
#define PCI_CLASS_BASE_SYSTEM_DEV           0x08
#define PCI_CLASS_INPUT_DEV                 0x09
#define PCI_CLASS_DOCKING_STATION           0x0a
#define PCI_CLASS_PROCESSOR                 0x0b
#define PCI_CLASS_SERIAL_BUS_CTLR           0x0c
#define PCI_CLASS_WIRELESS_CTLR             0x0d
#define PCI_CLASS_INTELLIGENT_IO_CTLR       0x0e
#define PCI_CLASS_SATELLITE_COMMS_CTLR      0x0f
#define PCI_CLASS_ENCRYPTION_DECRYPTION     0x10
#define PCI_CLASS_DATA_ACQ_SIGNAL_PROC      0x11

// 0d thru fe reserved

#define PCI_CLASS_NOT_DEFINED               0xff

//
// Sub Class Code encodings (PCI rev 2.1).
//

// Class 00 - PCI_CLASS_PRE_20

#define PCI_SUBCLASS_PRE_20_NON_VGA         0x00
#define PCI_SUBCLASS_PRE_20_VGA             0x01

// Class 01 - PCI_CLASS_MASS_STORAGE_CTLR

#define PCI_SUBCLASS_MSC_SCSI_BUS_CTLR      0x00
#define PCI_SUBCLASS_MSC_IDE_CTLR           0x01
#define PCI_SUBCLASS_MSC_FLOPPY_CTLR        0x02
#define PCI_SUBCLASS_MSC_IPI_CTLR           0x03
#define PCI_SUBCLASS_MSC_RAID_CTLR          0x04
#define PCI_SUBCLASS_MSC_OTHER              0x80

// Class 02 - PCI_CLASS_NETWORK_CTLR

#define PCI_SUBCLASS_NET_ETHERNET_CTLR      0x00
#define PCI_SUBCLASS_NET_TOKEN_RING_CTLR    0x01
#define PCI_SUBCLASS_NET_FDDI_CTLR          0x02
#define PCI_SUBCLASS_NET_ATM_CTLR           0x03
#define PCI_SUBCLASS_NET_ISDN_CTLR          0x04
#define PCI_SUBCLASS_NET_OTHER              0x80

// Class 03 - PCI_CLASS_DISPLAY_CTLR

// N.B. Sub Class 00 could be VGA or 8514 depending on Interface byte

#define PCI_SUBCLASS_VID_VGA_CTLR           0x00
#define PCI_SUBCLASS_VID_XGA_CTLR           0x01
#define PCI_SUBLCASS_VID_3D_CTLR            0x02
#define PCI_SUBCLASS_VID_OTHER              0x80

// Class 04 - PCI_CLASS_MULTIMEDIA_DEV

#define PCI_SUBCLASS_MM_VIDEO_DEV           0x00
#define PCI_SUBCLASS_MM_AUDIO_DEV           0x01
#define PCI_SUBCLASS_MM_TELEPHONY_DEV       0x02
#define PCI_SUBCLASS_MM_OTHER               0x80

// Class 05 - PCI_CLASS_MEMORY_CTLR

#define PCI_SUBCLASS_MEM_RAM                0x00
#define PCI_SUBCLASS_MEM_FLASH              0x01
#define PCI_SUBCLASS_MEM_OTHER              0x80

// Class 06 - PCI_CLASS_BRIDGE_DEV

#define PCI_SUBCLASS_BR_HOST                0x00
#define PCI_SUBCLASS_BR_ISA                 0x01
#define PCI_SUBCLASS_BR_EISA                0x02
#define PCI_SUBCLASS_BR_MCA                 0x03
#define PCI_SUBCLASS_BR_PCI_TO_PCI          0x04
#define PCI_SUBCLASS_BR_PCMCIA              0x05
#define PCI_SUBCLASS_BR_NUBUS               0x06
#define PCI_SUBCLASS_BR_CARDBUS             0x07
#define PCI_SUBCLASS_BR_RACEWAY             0x08
#define PCI_SUBCLASS_BR_OTHER               0x80

// Class 07 - PCI_CLASS_SIMPLE_COMMS_CTLR

// N.B. Sub Class 00 and 01 additional info in Interface byte

#define PCI_SUBCLASS_COM_SERIAL             0x00
#define PCI_SUBCLASS_COM_PARALLEL           0x01
#define PCI_SUBCLASS_COM_MULTIPORT          0x02
#define PCI_SUBCLASS_COM_MODEM              0x03
#define PCI_SUBCLASS_COM_OTHER              0x80

// Class 08 - PCI_CLASS_BASE_SYSTEM_DEV

// N.B. See Interface byte for additional info.

#define PCI_SUBCLASS_SYS_INTERRUPT_CTLR     0x00
#define PCI_SUBCLASS_SYS_DMA_CTLR           0x01
#define PCI_SUBCLASS_SYS_SYSTEM_TIMER       0x02
#define PCI_SUBCLASS_SYS_REAL_TIME_CLOCK    0x03
#define PCI_SUBCLASS_SYS_GEN_HOTPLUG_CTLR   0x04
#define PCI_SUBCLASS_SYS_OTHER              0x80

// Class 09 - PCI_CLASS_INPUT_DEV

#define PCI_SUBCLASS_INP_KEYBOARD           0x00
#define PCI_SUBCLASS_INP_DIGITIZER          0x01
#define PCI_SUBCLASS_INP_MOUSE              0x02
#define PCI_SUBCLASS_INP_SCANNER            0x03
#define PCI_SUBCLASS_INP_GAMEPORT           0x04
#define PCI_SUBCLASS_INP_OTHER              0x80

// Class 0a - PCI_CLASS_DOCKING_STATION

#define PCI_SUBCLASS_DOC_GENERIC            0x00
#define PCI_SUBCLASS_DOC_OTHER              0x80

// Class 0b - PCI_CLASS_PROCESSOR

#define PCI_SUBCLASS_PROC_386               0x00
#define PCI_SUBCLASS_PROC_486               0x01
#define PCI_SUBCLASS_PROC_PENTIUM           0x02
#define PCI_SUBCLASS_PROC_ALPHA             0x10
#define PCI_SUBCLASS_PROC_POWERPC           0x20
#define PCI_SUBCLASS_PROC_COPROCESSOR       0x40

// Class 0c - PCI_CLASS_SERIAL_BUS_CTLR

#define PCI_SUBCLASS_SB_IEEE1394            0x00
#define PCI_SUBCLASS_SB_ACCESS              0x01
#define PCI_SUBCLASS_SB_SSA                 0x02
#define PCI_SUBCLASS_SB_USB                 0x03
#define PCI_SUBCLASS_SB_FIBRE_CHANNEL       0x04
#define PCI_SUBCLASS_SB_SMBUS               0x05

// Class 0d - PCI_CLASS_WIRELESS_CTLR

#define PCI_SUBCLASS_WIRELESS_IRDA          0x00
#define PCI_SUBCLASS_WIRELESS_CON_IR        0x01
#define PCI_SUBCLASS_WIRELESS_RF            0x10
#define PCI_SUBCLASS_WIRELESS_OTHER         0x80

// Class 0e - PCI_CLASS_INTELLIGENT_IO_CTLR

#define PCI_SUBCLASS_INTIO_I2O              0x00

// Class 0f - PCI_CLASS_SATELLITE_CTLR

#define PCI_SUBCLASS_SAT_TV                 0x01
#define PCI_SUBCLASS_SAT_AUDIO              0x02
#define PCI_SUBCLASS_SAT_VOICE              0x03
#define PCI_SUBCLASS_SAT_DATA               0x04

// Class 10 - PCI_CLASS_ENCRYPTION_DECRYPTION

#define PCI_SUBCLASS_CRYPTO_NET_COMP        0x00
#define PCI_SUBCLASS_CRYPTO_ENTERTAINMENT   0x10
#define PCI_SUBCLASS_CRYPTO_OTHER           0x80

// Class 11 - PCI_CLASS_DATA_ACQ_SIGNAL_PROC

#define PCI_SUBCLASS_DASP_DPIO              0x00
#define PCI_SUBCLASS_DASP_OTHER             0x80



// end_ntndis

//
// Bit encodes for PCI_COMMON_CONFIG.u.type0.BaseAddresses
//

#define PCI_ADDRESS_IO_SPACE                0x00000001  // (ro)
#define PCI_ADDRESS_MEMORY_TYPE_MASK        0x00000006  // (ro)
#define PCI_ADDRESS_MEMORY_PREFETCHABLE     0x00000008  // (ro)

#define PCI_ADDRESS_IO_ADDRESS_MASK         0xfffffffc
#define PCI_ADDRESS_MEMORY_ADDRESS_MASK     0xfffffff0
#define PCI_ADDRESS_ROM_ADDRESS_MASK        0xfffff800

#define PCI_TYPE_32BIT      0
#define PCI_TYPE_20BIT      2
#define PCI_TYPE_64BIT      4

//
// Bit encodes for PCI_COMMON_CONFIG.u.type0.ROMBaseAddresses
//

#define PCI_ROMADDRESS_ENABLED              0x00000001


//
// Reference notes for PCI configuration fields:
//
// ro   these field are read only.  changes to these fields are ignored
//
// ro+  these field are intended to be read only and should be initialized
//      by the system to their proper values.  However, driver may change
//      these settings.
//
// ---
//
//      All resources comsumed by a PCI device start as unitialized
//      under NT.  An uninitialized memory or I/O base address can be
//      determined by checking it's corrisponding enabled bit in the
//      PCI_COMMON_CONFIG.Command value.  An InterruptLine is unitialized
//      if it contains the value of -1.
//


//
// Graphics support routines.
//

typedef
VOID
(*PBANKED_SECTION_ROUTINE) (
    IN ULONG ReadBank,
    IN ULONG WriteBank,
    IN PVOID Context
    );

//
// WMI minor function codes under IRP_MJ_SYSTEM_CONTROL
//

#define IRP_MN_QUERY_ALL_DATA               0x00
#define IRP_MN_QUERY_SINGLE_INSTANCE        0x01
#define IRP_MN_CHANGE_SINGLE_INSTANCE       0x02
#define IRP_MN_CHANGE_SINGLE_ITEM           0x03
#define IRP_MN_ENABLE_EVENTS                0x04
#define IRP_MN_DISABLE_EVENTS               0x05
#define IRP_MN_ENABLE_COLLECTION            0x06
#define IRP_MN_DISABLE_COLLECTION           0x07
#define IRP_MN_REGINFO                      0x08
#define IRP_MN_EXECUTE_METHOD               0x09
// Minor code 0x0a is reserved
#define IRP_MN_REGINFO_EX                   0x0b


// workaround overloaded definition (rpc generated headers all define INTERFACE
// to match the class name).
#undef INTERFACE

typedef struct _INTERFACE {
    USHORT Size;
    USHORT Version;
    PVOID Context;
    PINTERFACE_REFERENCE InterfaceReference;
    PINTERFACE_DEREFERENCE InterfaceDereference;
    // interface specific entries go here
} INTERFACE, *PINTERFACE;


//
// Defines the Type in the RESOURCE_DESCRIPTOR
//
// NOTE:  For all CM_RESOURCE_TYPE values, there must be a
// corresponding ResType value in the 32-bit ConfigMgr headerfile
// (cfgmgr32.h).  Values in the range [0x6,0x80) use the same values
// as their ConfigMgr counterparts.  CM_RESOURCE_TYPE values with
// the high bit set (i.e., in the range [0x80,0xFF]), are
// non-arbitrated resources.  These correspond to the same values
// in cfgmgr32.h that have their high bit set (however, since
// cfgmgr32.h uses 16 bits for ResType values, these values are in
// the range [0x8000,0x807F).  Note that ConfigMgr ResType values
// cannot be in the range [0x8080,0xFFFF), because they would not
// be able to map into CM_RESOURCE_TYPE values.  (0xFFFF itself is
// a special value, because it maps to CmResourceTypeDeviceSpecific.)
//

typedef int CM_RESOURCE_TYPE;

// CmResourceTypeNull is reserved

#define CmResourceTypeNull                0   // ResType_All or ResType_None (0x0000)
#define CmResourceTypePort                1   // ResType_IO (0x0002)
#define CmResourceTypeInterrupt           2   // ResType_IRQ (0x0004)
#define CmResourceTypeMemory              3   // ResType_Mem (0x0001)
#define CmResourceTypeDma                 4   // ResType_DMA (0x0003)
#define CmResourceTypeDeviceSpecific      5   // ResType_ClassSpecific (0xFFFF)
#define CmResourceTypeBusNumber           6   // ResType_BusNumber (0x0006)
// end_wdm
#define CmResourceTypeMaximum             7
// begin_wdm
#define CmResourceTypeNonArbitrated     128   // Not arbitrated if 0x80 bit set
#define CmResourceTypeConfigData        128   // ResType_Reserved (0x8000)
#define CmResourceTypeDevicePrivate     129   // ResType_DevicePrivate (0x8001)
#define CmResourceTypePcCardConfig      130   // ResType_PcCardConfig (0x8002)
#define CmResourceTypeMfCardConfig      131   // ResType_MfCardConfig (0x8003)

//
// Defines the ShareDisposition in the RESOURCE_DESCRIPTOR
//

typedef enum _CM_SHARE_DISPOSITION {
    CmResourceShareUndetermined = 0,    // Reserved
    CmResourceShareDeviceExclusive,
    CmResourceShareDriverExclusive,
    CmResourceShareShared
} CM_SHARE_DISPOSITION;

//
// Define the bit masks for Flags when type is CmResourceTypeInterrupt
//

#define CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE 0
#define CM_RESOURCE_INTERRUPT_LATCHED         1

//
// Define the bit masks for Flags when type is CmResourceTypeMemory
//

#define CM_RESOURCE_MEMORY_READ_WRITE       0x0000
#define CM_RESOURCE_MEMORY_READ_ONLY        0x0001
#define CM_RESOURCE_MEMORY_WRITE_ONLY       0x0002
#define CM_RESOURCE_MEMORY_PREFETCHABLE     0x0004

#define CM_RESOURCE_MEMORY_COMBINEDWRITE    0x0008
#define CM_RESOURCE_MEMORY_24               0x0010
#define CM_RESOURCE_MEMORY_CACHEABLE        0x0020

//
// Define the bit masks for Flags when type is CmResourceTypePort
//

#define CM_RESOURCE_PORT_MEMORY                             0x0000
#define CM_RESOURCE_PORT_IO                                 0x0001
#define CM_RESOURCE_PORT_10_BIT_DECODE                      0x0004
#define CM_RESOURCE_PORT_12_BIT_DECODE                      0x0008
#define CM_RESOURCE_PORT_16_BIT_DECODE                      0x0010
#define CM_RESOURCE_PORT_POSITIVE_DECODE                    0x0020
#define CM_RESOURCE_PORT_PASSIVE_DECODE                     0x0040
#define CM_RESOURCE_PORT_WINDOW_DECODE                      0x0080

//
// Define the bit masks for Flags when type is CmResourceTypeDma
//

#define CM_RESOURCE_DMA_8                   0x0000
#define CM_RESOURCE_DMA_16                  0x0001
#define CM_RESOURCE_DMA_32                  0x0002
#define CM_RESOURCE_DMA_8_AND_16            0x0004
#define CM_RESOURCE_DMA_BUS_MASTER          0x0008
#define CM_RESOURCE_DMA_TYPE_A              0x0010
#define CM_RESOURCE_DMA_TYPE_B              0x0020
#define CM_RESOURCE_DMA_TYPE_F              0x0040


#include "pshpack1.h"


//
// Define Mca POS data block for slot
//

typedef struct _CM_MCA_POS_DATA {
    USHORT AdapterId;
    UCHAR PosData1;
    UCHAR PosData2;
    UCHAR PosData3;
    UCHAR PosData4;
} CM_MCA_POS_DATA, *PCM_MCA_POS_DATA;

//
// Memory configuration of eisa data block structure
//

typedef struct _EISA_MEMORY_TYPE {
    UCHAR ReadWrite: 1;
    UCHAR Cached : 1;
    UCHAR Reserved0 :1;
    UCHAR Type:2;
    UCHAR Shared:1;
    UCHAR Reserved1 :1;
    UCHAR MoreEntries : 1;
} EISA_MEMORY_TYPE, *PEISA_MEMORY_TYPE;

typedef struct _EISA_MEMORY_CONFIGURATION {
    EISA_MEMORY_TYPE ConfigurationByte;
    UCHAR DataSize;
    USHORT AddressLowWord;
    UCHAR AddressHighByte;
    USHORT MemorySize;
} EISA_MEMORY_CONFIGURATION, *PEISA_MEMORY_CONFIGURATION;


//
// Interrupt configurationn of eisa data block structure
//

typedef struct _EISA_IRQ_DESCRIPTOR {
    UCHAR Interrupt : 4;
    UCHAR Reserved :1;
    UCHAR LevelTriggered :1;
    UCHAR Shared : 1;
    UCHAR MoreEntries : 1;
} EISA_IRQ_DESCRIPTOR, *PEISA_IRQ_DESCRIPTOR;

typedef struct _EISA_IRQ_CONFIGURATION {
    EISA_IRQ_DESCRIPTOR ConfigurationByte;
    UCHAR Reserved;
} EISA_IRQ_CONFIGURATION, *PEISA_IRQ_CONFIGURATION;


//
// DMA description of eisa data block structure
//

typedef struct _DMA_CONFIGURATION_BYTE0 {
    UCHAR Channel : 3;
    UCHAR Reserved : 3;
    UCHAR Shared :1;
    UCHAR MoreEntries :1;
} DMA_CONFIGURATION_BYTE0;

typedef struct _DMA_CONFIGURATION_BYTE1 {
    UCHAR Reserved0 : 2;
    UCHAR TransferSize : 2;
    UCHAR Timing : 2;
    UCHAR Reserved1 : 2;
} DMA_CONFIGURATION_BYTE1;

typedef struct _EISA_DMA_CONFIGURATION {
    DMA_CONFIGURATION_BYTE0 ConfigurationByte0;
    DMA_CONFIGURATION_BYTE1 ConfigurationByte1;
} EISA_DMA_CONFIGURATION, *PEISA_DMA_CONFIGURATION;


//
// Port description of eisa data block structure
//

typedef struct _EISA_PORT_DESCRIPTOR {
    UCHAR NumberPorts : 5;
    UCHAR Reserved :1;
    UCHAR Shared :1;
    UCHAR MoreEntries : 1;
} EISA_PORT_DESCRIPTOR, *PEISA_PORT_DESCRIPTOR;

typedef struct _EISA_PORT_CONFIGURATION {
    EISA_PORT_DESCRIPTOR Configuration;
    USHORT PortAddress;
} EISA_PORT_CONFIGURATION, *PEISA_PORT_CONFIGURATION;


//
// Eisa slot information definition
// N.B. This structure is different from the one defined
//      in ARC eisa addendum.
//

typedef struct _CM_EISA_SLOT_INFORMATION {
    UCHAR ReturnCode;
    UCHAR ReturnFlags;
    UCHAR MajorRevision;
    UCHAR MinorRevision;
    USHORT Checksum;
    UCHAR NumberFunctions;
    UCHAR FunctionInformation;
    ULONG CompressedId;
} CM_EISA_SLOT_INFORMATION, *PCM_EISA_SLOT_INFORMATION;


//
// Eisa function information definition
//

typedef struct _CM_EISA_FUNCTION_INFORMATION {
    ULONG CompressedId;
    UCHAR IdSlotFlags1;
    UCHAR IdSlotFlags2;
    UCHAR MinorRevision;
    UCHAR MajorRevision;
    UCHAR Selections[26];
    UCHAR FunctionFlags;
    UCHAR TypeString[80];
    EISA_MEMORY_CONFIGURATION EisaMemory[9];
    EISA_IRQ_CONFIGURATION EisaIrq[7];
    EISA_DMA_CONFIGURATION EisaDma[4];
    EISA_PORT_CONFIGURATION EisaPort[20];
    UCHAR InitializationData[60];
} CM_EISA_FUNCTION_INFORMATION, *PCM_EISA_FUNCTION_INFORMATION;

//
// The following defines the way pnp bios information is stored in
// the registry \\HKEY_LOCAL_MACHINE\HARDWARE\Description\System\MultifunctionAdapter\x
// key, where x is an integer number indicating adapter instance. The
// "Identifier" of the key must equal to "PNP BIOS" and the
// "ConfigurationData" is organized as follow:
//
//      CM_PNP_BIOS_INSTALLATION_CHECK        +
//      CM_PNP_BIOS_DEVICE_NODE for device 1  +
//      CM_PNP_BIOS_DEVICE_NODE for device 2  +
//                ...
//      CM_PNP_BIOS_DEVICE_NODE for device n
//

//
// Pnp BIOS device node structure
//

typedef struct _CM_PNP_BIOS_DEVICE_NODE {
    USHORT Size;
    UCHAR Node;
    ULONG ProductId;
    UCHAR DeviceType[3];
    USHORT DeviceAttributes;
    // followed by AllocatedResourceBlock, PossibleResourceBlock
    // and CompatibleDeviceId
} CM_PNP_BIOS_DEVICE_NODE,*PCM_PNP_BIOS_DEVICE_NODE;

//
// Pnp BIOS Installation check
//

typedef struct _CM_PNP_BIOS_INSTALLATION_CHECK {
    UCHAR Signature[4];             // $PnP (ascii)
    UCHAR Revision;
    UCHAR Length;
    USHORT ControlField;
    UCHAR Checksum;
    ULONG EventFlagAddress;         // Physical address
    USHORT RealModeEntryOffset;
    USHORT RealModeEntrySegment;
    USHORT ProtectedModeEntryOffset;
    ULONG ProtectedModeCodeBaseAddress;
    ULONG OemDeviceId;
    USHORT RealModeDataBaseAddress;
    ULONG ProtectedModeDataBaseAddress;
} CM_PNP_BIOS_INSTALLATION_CHECK, *PCM_PNP_BIOS_INSTALLATION_CHECK;

#include "poppack.h"

//
// Masks for EISA function information
//

#define EISA_FUNCTION_ENABLED                   0x80
#define EISA_FREE_FORM_DATA                     0x40
#define EISA_HAS_PORT_INIT_ENTRY                0x20
#define EISA_HAS_PORT_RANGE                     0x10
#define EISA_HAS_DMA_ENTRY                      0x08
#define EISA_HAS_IRQ_ENTRY                      0x04
#define EISA_HAS_MEMORY_ENTRY                   0x02
#define EISA_HAS_TYPE_ENTRY                     0x01
#define EISA_HAS_INFORMATION                    EISA_HAS_PORT_RANGE + \
                                                EISA_HAS_DMA_ENTRY + \
                                                EISA_HAS_IRQ_ENTRY + \
                                                EISA_HAS_MEMORY_ENTRY + \
                                                EISA_HAS_TYPE_ENTRY

//
// Masks for EISA memory configuration
//

#define EISA_MORE_ENTRIES                       0x80
#define EISA_SYSTEM_MEMORY                      0x00
#define EISA_MEMORY_TYPE_RAM                    0x01

//
// Returned error code for EISA bios call
//

#define EISA_INVALID_SLOT                       0x80
#define EISA_INVALID_FUNCTION                   0x81
#define EISA_INVALID_CONFIGURATION              0x82
#define EISA_EMPTY_SLOT                         0x83
#define EISA_INVALID_BIOS_CALL                  0x86


//
// Defines Resource Options
//

#define IO_RESOURCE_PREFERRED       0x01
#define IO_RESOURCE_DEFAULT         0x02
#define IO_RESOURCE_ALTERNATIVE     0x08


//
// This structure defines one type of resource requested by the driver
//

typedef struct _IO_RESOURCE_DESCRIPTOR {
    UCHAR Option;
    UCHAR Type;                         // use CM_RESOURCE_TYPE
    UCHAR ShareDisposition;             // use CM_SHARE_DISPOSITION
    UCHAR Spare1;
    USHORT Flags;                       // use CM resource flag defines
    USHORT Spare2;                      // align

    union {
        struct {
            ULONG Length;
            ULONG Alignment;
            PHYSICAL_ADDRESS MinimumAddress;
            PHYSICAL_ADDRESS MaximumAddress;
        } Port;

        struct {
            ULONG Length;
            ULONG Alignment;
            PHYSICAL_ADDRESS MinimumAddress;
            PHYSICAL_ADDRESS MaximumAddress;
        } Memory;

        struct {
            ULONG MinimumVector;
            ULONG MaximumVector;
        } Interrupt;

        struct {
            ULONG MinimumChannel;
            ULONG MaximumChannel;
        } Dma;

        struct {
            ULONG Length;
            ULONG Alignment;
            PHYSICAL_ADDRESS MinimumAddress;
            PHYSICAL_ADDRESS MaximumAddress;
        } Generic;

        struct {
            ULONG Data[3];
        } DevicePrivate;

        //
        // Bus Number information.
        //

        struct {
            ULONG Length;
            ULONG MinBusNumber;
            ULONG MaxBusNumber;
            ULONG Reserved;
        } BusNumber;

        struct {
            ULONG Priority;   // use LCPRI_Xxx values in cfg.h
            ULONG Reserved1;
            ULONG Reserved2;
        } ConfigData;

    } u;

} IO_RESOURCE_DESCRIPTOR, *PIO_RESOURCE_DESCRIPTOR;


#endif /* _MINIPORT_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\ddk\inc\minitape.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    minitape.h

Abstract:

    Type definitions for minitape drivers.

Revision History:

--*/

#ifndef _MINITAPE_
#define _MINITAPE_

#include "stddef.h"

#define ASSERT( exp )

#if DBG

#define DebugPrint(x) ScsiDebugPrint x

#else

#define DebugPrint(x)

#endif // DBG

#ifndef IN
#define IN
#endif

#ifndef OUT
#define OUT
#endif

#ifndef OPTIONAL
#define OPTIONAL
#endif

#ifndef NOTHING
#define NOTHING
#endif

#ifndef CRITICAL
#define CRITICAL
#endif

#ifndef ANYSIZE_ARRAY
#define ANYSIZE_ARRAY 1       // winnt
#endif

// begin_winnt

#if defined(_M_MRX000) && !(defined(MIDL_PASS) || defined(RC_INVOKED)) && defined(ENABLE_RESTRICTED)
#define RESTRICTED_POINTER __restrict
#else
#define RESTRICTED_POINTER
#endif

#if defined(_M_MRX000) || defined(_M_ALPHA) || defined(_M_PPC) || defined(_M_IA64) || defined(_M_AMD64)
#define UNALIGNED __unaligned
#if defined(_WIN64)
#define UNALIGNED64 __unaligned
#else
#define UNALIGNED64
#endif
#else
#define UNALIGNED
#define UNALIGNED64
#endif


#if defined(_WIN64) || defined(_M_ALPHA)
#define MAX_NATURAL_ALIGNMENT sizeof(ULONGLONG)
#define MEMORY_ALLOCATION_ALIGNMENT 16
#else
#define MAX_NATURAL_ALIGNMENT sizeof(ULONG)
#define MEMORY_ALLOCATION_ALIGNMENT 8
#endif

//
// TYPE_ALIGNMENT will return the alignment requirements of a given type for
// the current platform.
//

#ifdef __cplusplus
#if _MSC_VER >= 1300
#define TYPE_ALIGNMENT( t ) __alignof(t)
#endif
#else
#define TYPE_ALIGNMENT( t ) \
    FIELD_OFFSET( struct { char x; t test; }, test )
#endif

#if defined(_WIN64)

#define PROBE_ALIGNMENT( _s ) (TYPE_ALIGNMENT( _s ) > TYPE_ALIGNMENT( ULONG ) ? \
                               TYPE_ALIGNMENT( _s ) : TYPE_ALIGNMENT( ULONG ))

#define PROBE_ALIGNMENT32( _s ) TYPE_ALIGNMENT( ULONG )

#else

#define PROBE_ALIGNMENT( _s ) TYPE_ALIGNMENT( ULONG )

#endif

//
// C_ASSERT() can be used to perform many compile-time assertions:
//            type sizes, field offsets, etc.
//
// An assertion failure results in error C2118: negative subscript.
//

#define C_ASSERT(e) typedef char __C_ASSERT__[(e)?1:-1]

#if !defined(_MAC) && (defined(_M_MRX000) || defined(_M_AMD64) || defined(_M_IA64)) && (_MSC_VER >= 1100) && !(defined(MIDL_PASS) || defined(RC_INVOKED))
#define POINTER_64 __ptr64
typedef unsigned __int64 POINTER_64_INT;
#if defined(_WIN64)
#define POINTER_32 __ptr32
#else
#define POINTER_32
#endif
#else
#if defined(_MAC) && defined(_MAC_INT_64)
#define POINTER_64 __ptr64
typedef unsigned __int64 POINTER_64_INT;
#else
#define POINTER_64
typedef unsigned long POINTER_64_INT;
#endif
#define POINTER_32
#endif

#if defined(_IA64_) || defined(_AMD64_)
#define FIRMWARE_PTR
#else
#define FIRMWARE_PTR POINTER_32
#endif

#include <basetsd.h>

// end_winnt

#ifndef CONST
#define CONST               const
#endif

// begin_winnt

#if (defined(_M_IX86) || defined(_M_IA64) || defined(_M_AMD64)) && !defined(MIDL_PASS)
#define DECLSPEC_IMPORT __declspec(dllimport)
#else
#define DECLSPEC_IMPORT
#endif

#ifndef DECLSPEC_NORETURN
#if (_MSC_VER >= 1200) && !defined(MIDL_PASS)
#define DECLSPEC_NORETURN   __declspec(noreturn)
#else
#define DECLSPEC_NORETURN
#endif
#endif

#ifndef DECLSPEC_ALIGN
#if (_MSC_VER >= 1300) && !defined(MIDL_PASS)
#define DECLSPEC_ALIGN(x)   __declspec(align(x))
#else
#define DECLSPEC_ALIGN(x)
#endif
#endif

#ifndef DECLSPEC_CACHEALIGN
#define DECLSPEC_CACHEALIGN DECLSPEC_ALIGN(128)
#endif

#ifndef DECLSPEC_UUID
#if (_MSC_VER >= 1100) && defined (__cplusplus)
#define DECLSPEC_UUID(x)    __declspec(uuid(x))
#else
#define DECLSPEC_UUID(x)
#endif
#endif

#ifndef DECLSPEC_NOVTABLE
#if (_MSC_VER >= 1100) && defined(__cplusplus)
#define DECLSPEC_NOVTABLE   __declspec(novtable)
#else
#define DECLSPEC_NOVTABLE
#endif
#endif

#ifndef DECLSPEC_SELECTANY
#if (_MSC_VER >= 1100)
#define DECLSPEC_SELECTANY  __declspec(selectany)
#else
#define DECLSPEC_SELECTANY
#endif
#endif

#ifndef NOP_FUNCTION
#if (_MSC_VER >= 1210)
#define NOP_FUNCTION __noop
#else
#define NOP_FUNCTION (void)0
#endif
#endif

#ifndef DECLSPEC_ADDRSAFE
#if (_MSC_VER >= 1200) && (defined(_M_ALPHA) || defined(_M_AXP64))
#define DECLSPEC_ADDRSAFE  __declspec(address_safe)
#else
#define DECLSPEC_ADDRSAFE
#endif
#endif

#ifndef FORCEINLINE
#if (_MSC_VER >= 1200)
#define FORCEINLINE __forceinline
#else
#define FORCEINLINE __inline
#endif
#endif

#ifndef DECLSPEC_DEPRECATED
#if (_MSC_VER >= 1300) && !defined(MIDL_PASS)
#define DECLSPEC_DEPRECATED   __declspec(deprecated)
#define DEPRECATE_SUPPORTED
#else
#define DECLSPEC_DEPRECATED
#undef  DEPRECATE_SUPPORTED
#endif
#endif

// end_winnt

#ifdef DEPRECATE_DDK_FUNCTIONS
#ifdef _NTDDK_
#define DECLSPEC_DEPRECATED_DDK DECLSPEC_DEPRECATED
#ifdef DEPRECATE_SUPPORTED
#define PRAGMA_DEPRECATED_DDK 1
#endif
#else
#define DECLSPEC_DEPRECATED_DDK
#define PRAGMA_DEPRECATED_DDK 1
#endif
#else
#define DECLSPEC_DEPRECATED_DDK
#define PRAGMA_DEPRECATED_DDK 0
#endif

//
// Void
//
// begin_winnt

typedef void *PVOID;
typedef void * POINTER_64 PVOID64;

// end_winnt

#if defined(_M_IX86)
#define FASTCALL _fastcall
#else
#define FASTCALL
#endif


//
// Basics
//

#ifndef VOID
#define VOID void
typedef char CHAR;
typedef short SHORT;
typedef long LONG;
#endif

//
// UNICODE (Wide Character) types
//

#ifndef _MAC
typedef wchar_t WCHAR;    // wc,   16-bit UNICODE character
#else
// some Macintosh compilers don't define wchar_t in a convenient location, or define it as a char
typedef unsigned short WCHAR;    // wc,   16-bit UNICODE character
#endif

typedef WCHAR *PWCHAR;
typedef WCHAR *LPWCH, *PWCH;
typedef CONST WCHAR *LPCWCH, *PCWCH;
typedef WCHAR *NWPSTR;
typedef WCHAR *LPWSTR, *PWSTR;
typedef WCHAR UNALIGNED *LPUWSTR, *PUWSTR;

typedef CONST WCHAR *LPCWSTR, *PCWSTR;
typedef CONST WCHAR UNALIGNED *LPCUWSTR, *PCUWSTR;

//
// ANSI (Multi-byte Character) types
//
typedef CHAR *PCHAR;
typedef CHAR *LPCH, *PCH;

typedef CONST CHAR *LPCCH, *PCCH;
typedef CHAR *NPSTR;
typedef CHAR *LPSTR, *PSTR;
typedef CONST CHAR *LPCSTR, *PCSTR;

//
// Neutral ANSI/UNICODE types and macros
//
#ifdef  UNICODE                     // r_winnt

#ifndef _TCHAR_DEFINED
typedef WCHAR TCHAR, *PTCHAR;
typedef WCHAR TUCHAR, *PTUCHAR;
#define _TCHAR_DEFINED
#endif /* !_TCHAR_DEFINED */

typedef LPWSTR LPTCH, PTCH;
typedef LPWSTR PTSTR, LPTSTR;
typedef LPCWSTR PCTSTR, LPCTSTR;
typedef LPUWSTR PUTSTR, LPUTSTR;
typedef LPCUWSTR PCUTSTR, LPCUTSTR;
typedef LPWSTR LP;
#define __TEXT(quote) L##quote      // r_winnt

#else   /* UNICODE */               // r_winnt

#ifndef _TCHAR_DEFINED
typedef char TCHAR, *PTCHAR;
typedef unsigned char TUCHAR, *PTUCHAR;
#define _TCHAR_DEFINED
#endif /* !_TCHAR_DEFINED */

typedef LPSTR LPTCH, PTCH;
typedef LPSTR PTSTR, LPTSTR, PUTSTR, LPUTSTR;
typedef LPCSTR PCTSTR, LPCTSTR, PCUTSTR, LPCUTSTR;
#define __TEXT(quote) quote         // r_winnt

#endif /* UNICODE */                // r_winnt
#define TEXT(quote) __TEXT(quote)   // r_winnt


// end_winnt

typedef double DOUBLE;

typedef struct _QUAD {              // QUAD is for those times we want
    double  DoNotUseThisField;      // an 8 byte aligned 8 byte long structure
} QUAD;                             // which is NOT really a floating point
                                    // number.  Use DOUBLE if you want an FP
                                    // number.

//
// Pointer to Basics
//

typedef SHORT *PSHORT;  // winnt
typedef LONG *PLONG;    // winnt
typedef QUAD *PQUAD;

//
// Unsigned Basics
//

// Tell windef.h that some types are already defined.
#define BASETYPES

typedef unsigned char UCHAR;
typedef unsigned short USHORT;
typedef unsigned long ULONG;
typedef QUAD UQUAD;

//
// Pointer to Unsigned Basics
//

typedef UCHAR *PUCHAR;
typedef USHORT *PUSHORT;
typedef ULONG *PULONG;
typedef UQUAD *PUQUAD;

//
// Signed characters
//

typedef signed char SCHAR;
typedef SCHAR *PSCHAR;

#ifndef NO_STRICT
#ifndef STRICT
#define STRICT 1
#endif
#endif

//
// Handle to an Object
//

// begin_winnt

#ifdef STRICT
typedef void *HANDLE;
#define DECLARE_HANDLE(name) struct name##__ { int unused; }; typedef struct name##__ *name
#else
typedef PVOID HANDLE;
#define DECLARE_HANDLE(name) typedef HANDLE name
#endif
typedef HANDLE *PHANDLE;

//
// Flag (bit) fields
//

typedef UCHAR  FCHAR;
typedef USHORT FSHORT;
typedef ULONG  FLONG;

// Component Object Model defines, and macros

#ifndef _HRESULT_DEFINED
#define _HRESULT_DEFINED
typedef LONG HRESULT;

#endif // !_HRESULT_DEFINED

#ifdef __cplusplus
    #define EXTERN_C    extern "C"
#else
    #define EXTERN_C    extern
#endif

#if defined(_WIN32) || defined(_MPPC_)

// Win32 doesn't support __export

#ifdef _68K_
#define STDMETHODCALLTYPE       __cdecl
#else
#define STDMETHODCALLTYPE       __stdcall
#endif
#define STDMETHODVCALLTYPE      __cdecl

#define STDAPICALLTYPE          __stdcall
#define STDAPIVCALLTYPE         __cdecl

#else

#define STDMETHODCALLTYPE       __export __stdcall
#define STDMETHODVCALLTYPE      __export __cdecl

#define STDAPICALLTYPE          __export __stdcall
#define STDAPIVCALLTYPE         __export __cdecl

#endif


#define STDAPI                  EXTERN_C HRESULT STDAPICALLTYPE
#define STDAPI_(type)           EXTERN_C type STDAPICALLTYPE

#define STDMETHODIMP            HRESULT STDMETHODCALLTYPE
#define STDMETHODIMP_(type)     type STDMETHODCALLTYPE

// The 'V' versions allow Variable Argument lists.

#define STDAPIV                 EXTERN_C HRESULT STDAPIVCALLTYPE
#define STDAPIV_(type)          EXTERN_C type STDAPIVCALLTYPE

#define STDMETHODIMPV           HRESULT STDMETHODVCALLTYPE
#define STDMETHODIMPV_(type)    type STDMETHODVCALLTYPE

// end_winnt


//
// Low order two bits of a handle are ignored by the system and available
// for use by application code as tag bits.  The remaining bits are opaque
// and used to store a serial number and table index.
//

#define OBJ_HANDLE_TAGBITS  0x00000003L

//
// Cardinal Data Types [0 - 2**N-2)
//

typedef char CCHAR;          // winnt
typedef short CSHORT;
typedef ULONG CLONG;

typedef CCHAR *PCCHAR;
typedef CSHORT *PCSHORT;
typedef CLONG *PCLONG;


//
// __int64 is only supported by 2.0 and later midl.
// __midl is set by the 2.0 midl and not by 1.0 midl.
//

#define _ULONGLONG_
#if (!defined (_MAC) && (!defined(MIDL_PASS) || defined(__midl)) && (!defined(_M_IX86) || (defined(_INTEGRAL_MAX_BITS) && _INTEGRAL_MAX_BITS >= 64)))
typedef __int64 LONGLONG;
typedef unsigned __int64 ULONGLONG;

#define MAXLONGLONG                      (0x7fffffffffffffff)
#else

#if defined(_MAC) && defined(_MAC_INT_64)
typedef __int64 LONGLONG;
typedef unsigned __int64 ULONGLONG;

#define MAXLONGLONG                      (0x7fffffffffffffff)
#else
typedef double LONGLONG;
typedef double ULONGLONG;
#endif //_MAC and int64

#endif

typedef LONGLONG *PLONGLONG;
typedef ULONGLONG *PULONGLONG;

// Update Sequence Number

typedef LONGLONG USN;

#if defined(MIDL_PASS)
typedef struct _LARGE_INTEGER {
#else // MIDL_PASS
typedef union _LARGE_INTEGER {
    struct {
        ULONG LowPart;
        LONG HighPart;
    };
    struct {
        ULONG LowPart;
        LONG HighPart;
    } u;
#endif //MIDL_PASS
    LONGLONG QuadPart;
} LARGE_INTEGER;

typedef LARGE_INTEGER *PLARGE_INTEGER;

#if defined(MIDL_PASS)
typedef struct _ULARGE_INTEGER {
#else // MIDL_PASS
typedef union _ULARGE_INTEGER {
    struct {
        ULONG LowPart;
        ULONG HighPart;
    };
    struct {
        ULONG LowPart;
        ULONG HighPart;
    } u;
#endif //MIDL_PASS
    ULONGLONG QuadPart;
} ULARGE_INTEGER;

typedef ULARGE_INTEGER *PULARGE_INTEGER;


//
// Boolean
//

typedef UCHAR BOOLEAN;           // winnt
typedef BOOLEAN *PBOOLEAN;       // winnt


//
// Constants
//

#define FALSE   0
#define TRUE    1

#ifndef NULL
#ifdef __cplusplus
#define NULL    0
#define NULL64  0
#else
#define NULL    ((void *)0)
#define NULL64  ((void * POINTER_64)0)
#endif
#endif // NULL


//
// Macros used to eliminate compiler warning generated when formal
// parameters or local variables are not declared.
//
// Use DBG_UNREFERENCED_PARAMETER() when a parameter is not yet
// referenced but will be once the module is completely developed.
//
// Use DBG_UNREFERENCED_LOCAL_VARIABLE() when a local variable is not yet
// referenced but will be once the module is completely developed.
//
// Use UNREFERENCED_PARAMETER() if a parameter will never be referenced.
//
// DBG_UNREFERENCED_PARAMETER and DBG_UNREFERENCED_LOCAL_VARIABLE will
// eventually be made into a null macro to help determine whether there
// is unfinished work.
//

#if ! defined(lint)
#define UNREFERENCED_PARAMETER(P)          (P)
#define DBG_UNREFERENCED_PARAMETER(P)      (P)
#define DBG_UNREFERENCED_LOCAL_VARIABLE(V) (V)

#else // lint

// Note: lint -e530 says don't complain about uninitialized variables for
// this varible.  Error 527 has to do with unreachable code.
// -restore restores checking to the -save state

#define UNREFERENCED_PARAMETER(P)          \
    /*lint -save -e527 -e530 */ \
    { \
        (P) = (P); \
    } \
    /*lint -restore */
#define DBG_UNREFERENCED_PARAMETER(P)      \
    /*lint -save -e527 -e530 */ \
    { \
        (P) = (P); \
    } \
    /*lint -restore */
#define DBG_UNREFERENCED_LOCAL_VARIABLE(V) \
    /*lint -save -e527 -e530 */ \
    { \
        (V) = (V); \
    } \
    /*lint -restore */

#endif // lint

//
// Macro used to eliminate compiler warning 4715 within a switch statement
// when all possible cases have already been accounted for.
//
// switch (a & 3) {
//     case 0: return 1;
//     case 1: return Foo();
//     case 2: return Bar();
//     case 3: return 1;
//     DEFAULT_UNREACHABLE;
//

#if (_MSC_VER > 1200)
#define DEFAULT_UNREACHABLE default: __assume(0)
#else

//
// Older compilers do not support __assume(), and there is no other free
// method of eliminating the warning.
//

#define DEFAULT_UNREACHABLE

#endif

// end_winnt

//
//  Define standard min and max macros
//

#ifndef NOMINMAX

#ifndef min
#define min(a,b) (((a) < (b)) ? (a) : (b))
#endif

#ifndef max
#define max(a,b) (((a) > (b)) ? (a) : (b))
#endif

#endif  // NOMINMAX



//
// IOCTL_TAPE_ERASE definitions
//

#define TAPE_ERASE_SHORT            0L
#define TAPE_ERASE_LONG             1L

typedef struct _TAPE_ERASE {
    ULONG Type;
    BOOLEAN Immediate;
} TAPE_ERASE, *PTAPE_ERASE;

//
// IOCTL_TAPE_PREPARE definitions
//

#define TAPE_LOAD                   0L
#define TAPE_UNLOAD                 1L
#define TAPE_TENSION                2L
#define TAPE_LOCK                   3L
#define TAPE_UNLOCK                 4L
#define TAPE_FORMAT                 5L

typedef struct _TAPE_PREPARE {
    ULONG Operation;
    BOOLEAN Immediate;
} TAPE_PREPARE, *PTAPE_PREPARE;

//
// IOCTL_TAPE_WRITE_MARKS definitions
//

#define TAPE_SETMARKS               0L
#define TAPE_FILEMARKS              1L
#define TAPE_SHORT_FILEMARKS        2L
#define TAPE_LONG_FILEMARKS         3L

typedef struct _TAPE_WRITE_MARKS {
    ULONG Type;
    ULONG Count;
    BOOLEAN Immediate;
} TAPE_WRITE_MARKS, *PTAPE_WRITE_MARKS;

//
// IOCTL_TAPE_GET_POSITION definitions
//

#define TAPE_ABSOLUTE_POSITION       0L
#define TAPE_LOGICAL_POSITION        1L
#define TAPE_PSEUDO_LOGICAL_POSITION 2L

typedef struct _TAPE_GET_POSITION {
    ULONG Type;
    ULONG Partition;
    LARGE_INTEGER Offset;
} TAPE_GET_POSITION, *PTAPE_GET_POSITION;

//
// IOCTL_TAPE_SET_POSITION definitions
//

#define TAPE_REWIND                 0L
#define TAPE_ABSOLUTE_BLOCK         1L
#define TAPE_LOGICAL_BLOCK          2L
#define TAPE_PSEUDO_LOGICAL_BLOCK   3L
#define TAPE_SPACE_END_OF_DATA      4L
#define TAPE_SPACE_RELATIVE_BLOCKS  5L
#define TAPE_SPACE_FILEMARKS        6L
#define TAPE_SPACE_SEQUENTIAL_FMKS  7L
#define TAPE_SPACE_SETMARKS         8L
#define TAPE_SPACE_SEQUENTIAL_SMKS  9L

typedef struct _TAPE_SET_POSITION {
    ULONG Method;
    ULONG Partition;
    LARGE_INTEGER Offset;
    BOOLEAN Immediate;
} TAPE_SET_POSITION, *PTAPE_SET_POSITION;

//
// IOCTL_TAPE_GET_DRIVE_PARAMS definitions
//

//
// Definitions for FeaturesLow parameter
//

#define TAPE_DRIVE_FIXED            0x00000001
#define TAPE_DRIVE_SELECT           0x00000002
#define TAPE_DRIVE_INITIATOR        0x00000004

#define TAPE_DRIVE_ERASE_SHORT      0x00000010
#define TAPE_DRIVE_ERASE_LONG       0x00000020
#define TAPE_DRIVE_ERASE_BOP_ONLY   0x00000040
#define TAPE_DRIVE_ERASE_IMMEDIATE  0x00000080

#define TAPE_DRIVE_TAPE_CAPACITY    0x00000100
#define TAPE_DRIVE_TAPE_REMAINING   0x00000200
#define TAPE_DRIVE_FIXED_BLOCK      0x00000400
#define TAPE_DRIVE_VARIABLE_BLOCK   0x00000800

#define TAPE_DRIVE_WRITE_PROTECT    0x00001000
#define TAPE_DRIVE_EOT_WZ_SIZE      0x00002000

#define TAPE_DRIVE_ECC              0x00010000
#define TAPE_DRIVE_COMPRESSION      0x00020000
#define TAPE_DRIVE_PADDING          0x00040000
#define TAPE_DRIVE_REPORT_SMKS      0x00080000

#define TAPE_DRIVE_GET_ABSOLUTE_BLK 0x00100000
#define TAPE_DRIVE_GET_LOGICAL_BLK  0x00200000
#define TAPE_DRIVE_SET_EOT_WZ_SIZE  0x00400000

#define TAPE_DRIVE_EJECT_MEDIA      0x01000000
#define TAPE_DRIVE_CLEAN_REQUESTS   0x02000000
#define TAPE_DRIVE_SET_CMP_BOP_ONLY 0x04000000

#define TAPE_DRIVE_RESERVED_BIT     0x80000000  //don't use this bit!
//                                              //can't be a low features bit!
//                                              //reserved; high features only

//
// Definitions for FeaturesHigh parameter
//

#define TAPE_DRIVE_LOAD_UNLOAD      0x80000001
#define TAPE_DRIVE_TENSION          0x80000002
#define TAPE_DRIVE_LOCK_UNLOCK      0x80000004
#define TAPE_DRIVE_REWIND_IMMEDIATE 0x80000008

#define TAPE_DRIVE_SET_BLOCK_SIZE   0x80000010
#define TAPE_DRIVE_LOAD_UNLD_IMMED  0x80000020
#define TAPE_DRIVE_TENSION_IMMED    0x80000040
#define TAPE_DRIVE_LOCK_UNLK_IMMED  0x80000080

#define TAPE_DRIVE_SET_ECC          0x80000100
#define TAPE_DRIVE_SET_COMPRESSION  0x80000200
#define TAPE_DRIVE_SET_PADDING      0x80000400
#define TAPE_DRIVE_SET_REPORT_SMKS  0x80000800

#define TAPE_DRIVE_ABSOLUTE_BLK     0x80001000
#define TAPE_DRIVE_ABS_BLK_IMMED    0x80002000
#define TAPE_DRIVE_LOGICAL_BLK      0x80004000
#define TAPE_DRIVE_LOG_BLK_IMMED    0x80008000

#define TAPE_DRIVE_END_OF_DATA      0x80010000
#define TAPE_DRIVE_RELATIVE_BLKS    0x80020000
#define TAPE_DRIVE_FILEMARKS        0x80040000
#define TAPE_DRIVE_SEQUENTIAL_FMKS  0x80080000

#define TAPE_DRIVE_SETMARKS         0x80100000
#define TAPE_DRIVE_SEQUENTIAL_SMKS  0x80200000
#define TAPE_DRIVE_REVERSE_POSITION 0x80400000
#define TAPE_DRIVE_SPACE_IMMEDIATE  0x80800000

#define TAPE_DRIVE_WRITE_SETMARKS   0x81000000
#define TAPE_DRIVE_WRITE_FILEMARKS  0x82000000
#define TAPE_DRIVE_WRITE_SHORT_FMKS 0x84000000
#define TAPE_DRIVE_WRITE_LONG_FMKS  0x88000000

#define TAPE_DRIVE_WRITE_MARK_IMMED 0x90000000
#define TAPE_DRIVE_FORMAT           0xA0000000
#define TAPE_DRIVE_FORMAT_IMMEDIATE 0xC0000000
#define TAPE_DRIVE_HIGH_FEATURES    0x80000000  //mask for high features flag

typedef struct _TAPE_GET_DRIVE_PARAMETERS {
    BOOLEAN ECC;
    BOOLEAN Compression;
    BOOLEAN DataPadding;
    BOOLEAN ReportSetmarks;
    ULONG DefaultBlockSize;
    ULONG MaximumBlockSize;
    ULONG MinimumBlockSize;
    ULONG MaximumPartitionCount;
    ULONG FeaturesLow;
    ULONG FeaturesHigh;
    ULONG EOTWarningZoneSize;
} TAPE_GET_DRIVE_PARAMETERS, *PTAPE_GET_DRIVE_PARAMETERS;

//
// IOCTL_TAPE_SET_DRIVE_PARAMETERS definitions
//

typedef struct _TAPE_SET_DRIVE_PARAMETERS {
    BOOLEAN ECC;
    BOOLEAN Compression;
    BOOLEAN DataPadding;
    BOOLEAN ReportSetmarks;
    ULONG EOTWarningZoneSize;
} TAPE_SET_DRIVE_PARAMETERS, *PTAPE_SET_DRIVE_PARAMETERS;

//
// IOCTL_TAPE_GET_MEDIA_PARAMETERS definitions
//

typedef struct _TAPE_GET_MEDIA_PARAMETERS {
    LARGE_INTEGER Capacity;
    LARGE_INTEGER Remaining;
    ULONG BlockSize;
    ULONG PartitionCount;
    BOOLEAN WriteProtected;
} TAPE_GET_MEDIA_PARAMETERS, *PTAPE_GET_MEDIA_PARAMETERS;

//
// IOCTL_TAPE_SET_MEDIA_PARAMETERS definitions
//

typedef struct _TAPE_SET_MEDIA_PARAMETERS {
    ULONG BlockSize;
} TAPE_SET_MEDIA_PARAMETERS, *PTAPE_SET_MEDIA_PARAMETERS;

//
// IOCTL_TAPE_CREATE_PARTITION definitions
//

#define TAPE_FIXED_PARTITIONS       0L
#define TAPE_SELECT_PARTITIONS      1L
#define TAPE_INITIATOR_PARTITIONS   2L

typedef struct _TAPE_CREATE_PARTITION {
    ULONG Method;
    ULONG Count;
    ULONG Size;
} TAPE_CREATE_PARTITION, *PTAPE_CREATE_PARTITION;


//
// WMI Methods
//
#define TAPE_QUERY_DRIVE_PARAMETERS       0L
#define TAPE_QUERY_MEDIA_CAPACITY         1L
#define TAPE_CHECK_FOR_DRIVE_PROBLEM      2L
#define TAPE_QUERY_IO_ERROR_DATA          3L
#define TAPE_QUERY_DEVICE_ERROR_DATA      4L

typedef struct _TAPE_WMI_OPERATIONS {
   ULONG Method;
   ULONG DataBufferSize;
   PVOID DataBuffer;
} TAPE_WMI_OPERATIONS, *PTAPE_WMI_OPERATIONS;

//
// Type of drive errors
//
typedef enum _TAPE_DRIVE_PROBLEM_TYPE {
   TapeDriveProblemNone, TapeDriveReadWriteWarning,
   TapeDriveReadWriteError, TapeDriveReadWarning,
   TapeDriveWriteWarning, TapeDriveReadError,
   TapeDriveWriteError, TapeDriveHardwareError,
   TapeDriveUnsupportedMedia, TapeDriveScsiConnectionError,
   TapeDriveTimetoClean, TapeDriveCleanDriveNow,
   TapeDriveMediaLifeExpired, TapeDriveSnappedTape
} TAPE_DRIVE_PROBLEM_TYPE;



typedef struct _TAPE_STATISTICS {
    ULONG Version;
    ULONG Flags;
    LARGE_INTEGER RecoveredWrites;
    LARGE_INTEGER UnrecoveredWrites;
    LARGE_INTEGER RecoveredReads;
    LARGE_INTEGER UnrecoveredReads;
    UCHAR         CompressionRatioReads;
    UCHAR         CompressionRatioWrites;
} TAPE_STATISTICS, *PTAPE_STATISTICS;

#define RECOVERED_WRITES_VALID   0x00000001
#define UNRECOVERED_WRITES_VALID 0x00000002
#define RECOVERED_READS_VALID    0x00000004
#define UNRECOVERED_READS_VALID  0x00000008
#define WRITE_COMPRESSION_INFO_VALID  0x00000010
#define READ_COMPRESSION_INFO_VALID   0x00000020

typedef struct _TAPE_GET_STATISTICS {
    ULONG Operation;
} TAPE_GET_STATISTICS, *PTAPE_GET_STATISTICS;

#define TAPE_RETURN_STATISTICS 0L
#define TAPE_RETURN_ENV_INFO   1L
#define TAPE_RESET_STATISTICS  2L

//
// IOCTL_STORAGE_GET_MEDIA_TYPES_EX will return an array of DEVICE_MEDIA_INFO
// structures, one per supported type, embedded in the GET_MEDIA_TYPES struct.
//

typedef enum _STORAGE_MEDIA_TYPE {
    //
    // Following are defined in ntdddisk.h in the MEDIA_TYPE enum
    //
    // Unknown,                // Format is unknown
    // F5_1Pt2_512,            // 5.25", 1.2MB,  512 bytes/sector
    // F3_1Pt44_512,           // 3.5",  1.44MB, 512 bytes/sector
    // F3_2Pt88_512,           // 3.5",  2.88MB, 512 bytes/sector
    // F3_20Pt8_512,           // 3.5",  20.8MB, 512 bytes/sector
    // F3_720_512,             // 3.5",  720KB,  512 bytes/sector
    // F5_360_512,             // 5.25", 360KB,  512 bytes/sector
    // F5_320_512,             // 5.25", 320KB,  512 bytes/sector
    // F5_320_1024,            // 5.25", 320KB,  1024 bytes/sector
    // F5_180_512,             // 5.25", 180KB,  512 bytes/sector
    // F5_160_512,             // 5.25", 160KB,  512 bytes/sector
    // RemovableMedia,         // Removable media other than floppy
    // FixedMedia,             // Fixed hard disk media
    // F3_120M_512,            // 3.5", 120M Floppy
    // F3_640_512,             // 3.5" ,  640KB,  512 bytes/sector
    // F5_640_512,             // 5.25",  640KB,  512 bytes/sector
    // F5_720_512,             // 5.25",  720KB,  512 bytes/sector
    // F3_1Pt2_512,            // 3.5" ,  1.2Mb,  512 bytes/sector
    // F3_1Pt23_1024,          // 3.5" ,  1.23Mb, 1024 bytes/sector
    // F5_1Pt23_1024,          // 5.25",  1.23MB, 1024 bytes/sector
    // F3_128Mb_512,           // 3.5" MO 128Mb   512 bytes/sector
    // F3_230Mb_512,           // 3.5" MO 230Mb   512 bytes/sector
    // F8_256_128,             // 8",     256KB,  128 bytes/sector
    // F3_200Mb_512,           // 3.5",   200M Floppy (HiFD)
    //

    DDS_4mm = 0x20,            // Tape - DAT DDS1,2,... (all vendors)
    MiniQic,                   // Tape - miniQIC Tape
    Travan,                    // Tape - Travan TR-1,2,3,...
    QIC,                       // Tape - QIC
    MP_8mm,                    // Tape - 8mm Exabyte Metal Particle
    AME_8mm,                   // Tape - 8mm Exabyte Advanced Metal Evap
    AIT1_8mm,                  // Tape - 8mm Sony AIT
    DLT,                       // Tape - DLT Compact IIIxt, IV
    NCTP,                      // Tape - Philips NCTP
    IBM_3480,                  // Tape - IBM 3480
    IBM_3490E,                 // Tape - IBM 3490E
    IBM_Magstar_3590,          // Tape - IBM Magstar 3590
    IBM_Magstar_MP,            // Tape - IBM Magstar MP
    STK_DATA_D3,               // Tape - STK Data D3
    SONY_DTF,                  // Tape - Sony DTF
    DV_6mm,                    // Tape - 6mm Digital Video
    DMI,                       // Tape - Exabyte DMI and compatibles
    SONY_D2,                   // Tape - Sony D2S and D2L
    CLEANER_CARTRIDGE,         // Cleaner - All Drive types that support Drive Cleaners
    CD_ROM,                    // Opt_Disk - CD
    CD_R,                      // Opt_Disk - CD-Recordable (Write Once)
    CD_RW,                     // Opt_Disk - CD-Rewriteable
    DVD_ROM,                   // Opt_Disk - DVD-ROM
    DVD_R,                     // Opt_Disk - DVD-Recordable (Write Once)
    DVD_RW,                    // Opt_Disk - DVD-Rewriteable
    MO_3_RW,                   // Opt_Disk - 3.5" Rewriteable MO Disk
    MO_5_WO,                   // Opt_Disk - MO 5.25" Write Once
    MO_5_RW,                   // Opt_Disk - MO 5.25" Rewriteable (not LIMDOW)
    MO_5_LIMDOW,               // Opt_Disk - MO 5.25" Rewriteable (LIMDOW)
    PC_5_WO,                   // Opt_Disk - Phase Change 5.25" Write Once Optical
    PC_5_RW,                   // Opt_Disk - Phase Change 5.25" Rewriteable
    PD_5_RW,                   // Opt_Disk - PhaseChange Dual Rewriteable
    ABL_5_WO,                  // Opt_Disk - Ablative 5.25" Write Once Optical
    PINNACLE_APEX_5_RW,        // Opt_Disk - Pinnacle Apex 4.6GB Rewriteable Optical
    SONY_12_WO,                // Opt_Disk - Sony 12" Write Once
    PHILIPS_12_WO,             // Opt_Disk - Philips/LMS 12" Write Once
    HITACHI_12_WO,             // Opt_Disk - Hitachi 12" Write Once
    CYGNET_12_WO,              // Opt_Disk - Cygnet/ATG 12" Write Once
    KODAK_14_WO,               // Opt_Disk - Kodak 14" Write Once
    MO_NFR_525,                // Opt_Disk - Near Field Recording (Terastor)
    NIKON_12_RW,               // Opt_Disk - Nikon 12" Rewriteable
    IOMEGA_ZIP,                // Mag_Disk - Iomega Zip
    IOMEGA_JAZ,                // Mag_Disk - Iomega Jaz
    SYQUEST_EZ135,             // Mag_Disk - Syquest EZ135
    SYQUEST_EZFLYER,           // Mag_Disk - Syquest EzFlyer
    SYQUEST_SYJET,             // Mag_Disk - Syquest SyJet
    AVATAR_F2,                 // Mag_Disk - 2.5" Floppy
    MP2_8mm,                   // Tape - 8mm Hitachi
    DST_S,                     // Ampex DST Small Tapes
    DST_M,                     // Ampex DST Medium Tapes
    DST_L,                     // Ampex DST Large Tapes
    VXATape_1,                 // Ecrix 8mm Tape
    VXATape_2,                 // Ecrix 8mm Tape
    STK_9840,                  // STK 9840
    LTO_Ultrium,               // IBM, HP, Seagate LTO Ultrium
    LTO_Accelis,               // IBM, HP, Seagate LTO Accelis
    DVD_RAM,                   // Opt_Disk - DVD-RAM
    AIT_8mm,                   // AIT2 or higher
    ADR_1,                     // OnStream ADR Mediatypes
    ADR_2
} STORAGE_MEDIA_TYPE, *PSTORAGE_MEDIA_TYPE;

#define MEDIA_ERASEABLE         0x00000001
#define MEDIA_WRITE_ONCE        0x00000002
#define MEDIA_READ_ONLY         0x00000004
#define MEDIA_READ_WRITE        0x00000008

#define MEDIA_WRITE_PROTECTED   0x00000100
#define MEDIA_CURRENTLY_MOUNTED 0x80000000

//
// Define the different storage bus types
// Bus types below 128 (0x80) are reserved for Microsoft use
//

typedef enum _STORAGE_BUS_TYPE {
    BusTypeUnknown = 0x00,
    BusTypeScsi,
    BusTypeAtapi,
    BusTypeAta,
    BusType1394,
    BusTypeSsa,
    BusTypeFibre,
    BusTypeUsb,
    BusTypeRAID,
    BusTypeMaxReserved = 0x7F
} STORAGE_BUS_TYPE, *PSTORAGE_BUS_TYPE;

typedef struct _DEVICE_MEDIA_INFO {
    union {
        struct {
            LARGE_INTEGER Cylinders;
            STORAGE_MEDIA_TYPE MediaType;
            ULONG TracksPerCylinder;
            ULONG SectorsPerTrack;
            ULONG BytesPerSector;
            ULONG NumberMediaSides;
            ULONG MediaCharacteristics; // Bitmask of MEDIA_XXX values.
        } DiskInfo;

        struct {
            LARGE_INTEGER Cylinders;
            STORAGE_MEDIA_TYPE MediaType;
            ULONG TracksPerCylinder;
            ULONG SectorsPerTrack;
            ULONG BytesPerSector;
            ULONG NumberMediaSides;
            ULONG MediaCharacteristics; // Bitmask of MEDIA_XXX values.
        } RemovableDiskInfo;

        struct {
            STORAGE_MEDIA_TYPE MediaType;
            ULONG   MediaCharacteristics; // Bitmask of MEDIA_XXX values.
            ULONG   CurrentBlockSize;
            STORAGE_BUS_TYPE BusType;

            //
            // Bus specific information describing the medium supported.
            //

            union {
                struct {
                    UCHAR MediumType;
                    UCHAR DensityCode;
                } ScsiInformation;
            } BusSpecificData;

        } TapeInfo;
    } DeviceSpecific;
} DEVICE_MEDIA_INFO, *PDEVICE_MEDIA_INFO;

typedef struct _GET_MEDIA_TYPES {
    ULONG DeviceType;              // FILE_DEVICE_XXX values
    ULONG MediaInfoCount;
    DEVICE_MEDIA_INFO MediaInfo[1];
} GET_MEDIA_TYPES, *PGET_MEDIA_TYPES;


//
// IOCTL_STORAGE_PREDICT_FAILURE
//
// input - none
//
// output - STORAGE_PREDICT_FAILURE structure
//          PredictFailure returns zero if no failure predicted and non zero
//                         if a failure is predicted.
//
//          VendorSpecific returns 512 bytes of vendor specific information
//                         if a failure is predicted
//
typedef struct _STORAGE_PREDICT_FAILURE
{
    ULONG PredictFailure;
    UCHAR VendorSpecific[512];
} STORAGE_PREDICT_FAILURE, *PSTORAGE_PREDICT_FAILURE;


#define MAXIMUM_CDB_SIZE 12

//
// SCSI I/O Request Block
//

typedef struct _SCSI_REQUEST_BLOCK {
    USHORT Length;                  // offset 0
    UCHAR Function;                 // offset 2
    UCHAR SrbStatus;                // offset 3
    UCHAR ScsiStatus;               // offset 4
    UCHAR PathId;                   // offset 5
    UCHAR TargetId;                 // offset 6
    UCHAR Lun;                      // offset 7
    UCHAR QueueTag;                 // offset 8
    UCHAR QueueAction;              // offset 9
    UCHAR CdbLength;                // offset a
    UCHAR SenseInfoBufferLength;    // offset b
    ULONG SrbFlags;                 // offset c
    ULONG DataTransferLength;       // offset 10
    ULONG TimeOutValue;             // offset 14
    PVOID DataBuffer;               // offset 18
    PVOID SenseInfoBuffer;          // offset 1c
    struct _SCSI_REQUEST_BLOCK *NextSrb; // offset 20
    PVOID OriginalRequest;          // offset 24
    PVOID SrbExtension;             // offset 28
    union {
        ULONG InternalStatus;       // offset 2c
        ULONG QueueSortKey;         // offset 2c
    };

#if defined(_WIN64)

    //
    // Force PVOID alignment of Cdb
    //

    ULONG Reserved;

#endif

    UCHAR Cdb[16];                  // offset 30
} SCSI_REQUEST_BLOCK, *PSCSI_REQUEST_BLOCK;

#define SCSI_REQUEST_BLOCK_SIZE sizeof(SCSI_REQUEST_BLOCK)

//
// SCSI I/O Request Block for WMI Requests
//

typedef struct _SCSI_WMI_REQUEST_BLOCK {
    USHORT Length;
    UCHAR Function;        // SRB_FUNCTION_WMI
    UCHAR SrbStatus;
    UCHAR WMISubFunction;
    UCHAR PathId;          // If SRB_WMI_FLAGS_ADAPTER_REQUEST is set in
    UCHAR TargetId;        // WMIFlags then PathId, TargetId and Lun are
    UCHAR Lun;             // reserved fields.
    UCHAR Reserved1;
    UCHAR WMIFlags;
    UCHAR Reserved2[2];
    ULONG SrbFlags;
    ULONG DataTransferLength;
    ULONG TimeOutValue;
    PVOID DataBuffer;
    PVOID DataPath;
    PVOID Reserved3;
    PVOID OriginalRequest;
    PVOID SrbExtension;
    ULONG Reserved4;
    UCHAR Reserved5[16];
} SCSI_WMI_REQUEST_BLOCK, *PSCSI_WMI_REQUEST_BLOCK;

//
// SRB Functions
//

#define SRB_FUNCTION_EXECUTE_SCSI           0x00
#define SRB_FUNCTION_CLAIM_DEVICE           0x01
#define SRB_FUNCTION_IO_CONTROL             0x02
#define SRB_FUNCTION_RECEIVE_EVENT          0x03
#define SRB_FUNCTION_RELEASE_QUEUE          0x04
#define SRB_FUNCTION_ATTACH_DEVICE          0x05
#define SRB_FUNCTION_RELEASE_DEVICE         0x06
#define SRB_FUNCTION_SHUTDOWN               0x07
#define SRB_FUNCTION_FLUSH                  0x08
#define SRB_FUNCTION_ABORT_COMMAND          0x10
#define SRB_FUNCTION_RELEASE_RECOVERY       0x11
#define SRB_FUNCTION_RESET_BUS              0x12
#define SRB_FUNCTION_RESET_DEVICE           0x13
#define SRB_FUNCTION_TERMINATE_IO           0x14
#define SRB_FUNCTION_FLUSH_QUEUE            0x15
#define SRB_FUNCTION_REMOVE_DEVICE          0x16
#define SRB_FUNCTION_WMI                    0x17
#define SRB_FUNCTION_LOCK_QUEUE             0x18
#define SRB_FUNCTION_UNLOCK_QUEUE           0x19
#define SRB_FUNCTION_RESET_LOGICAL_UNIT     0x20

//
// SRB Status
//

#define SRB_STATUS_PENDING                  0x00
#define SRB_STATUS_SUCCESS                  0x01
#define SRB_STATUS_ABORTED                  0x02
#define SRB_STATUS_ABORT_FAILED             0x03
#define SRB_STATUS_ERROR                    0x04
#define SRB_STATUS_BUSY                     0x05
#define SRB_STATUS_INVALID_REQUEST          0x06
#define SRB_STATUS_INVALID_PATH_ID          0x07
#define SRB_STATUS_NO_DEVICE                0x08
#define SRB_STATUS_TIMEOUT                  0x09
#define SRB_STATUS_SELECTION_TIMEOUT        0x0A
#define SRB_STATUS_COMMAND_TIMEOUT          0x0B
#define SRB_STATUS_MESSAGE_REJECTED         0x0D
#define SRB_STATUS_BUS_RESET                0x0E
#define SRB_STATUS_PARITY_ERROR             0x0F
#define SRB_STATUS_REQUEST_SENSE_FAILED     0x10
#define SRB_STATUS_NO_HBA                   0x11
#define SRB_STATUS_DATA_OVERRUN             0x12
#define SRB_STATUS_UNEXPECTED_BUS_FREE      0x13
#define SRB_STATUS_PHASE_SEQUENCE_FAILURE   0x14
#define SRB_STATUS_BAD_SRB_BLOCK_LENGTH     0x15
#define SRB_STATUS_REQUEST_FLUSHED          0x16
#define SRB_STATUS_INVALID_LUN              0x20
#define SRB_STATUS_INVALID_TARGET_ID        0x21
#define SRB_STATUS_BAD_FUNCTION             0x22
#define SRB_STATUS_ERROR_RECOVERY           0x23
#define SRB_STATUS_NOT_POWERED              0x24

//
// This value is used by the port driver to indicate that a non-scsi-related
// error occured.  Miniports must never return this status.
//

#define SRB_STATUS_INTERNAL_ERROR           0x30

//
// Srb status values 0x38 through 0x3f are reserved for internal port driver 
// use.
// 



//
// SRB Status Masks
//

#define SRB_STATUS_QUEUE_FROZEN             0x40
#define SRB_STATUS_AUTOSENSE_VALID          0x80

#define SRB_STATUS(Status) (Status & ~(SRB_STATUS_AUTOSENSE_VALID | SRB_STATUS_QUEUE_FROZEN))

//
// SRB Flag Bits
//

#define SRB_FLAGS_QUEUE_ACTION_ENABLE       0x00000002
#define SRB_FLAGS_DISABLE_DISCONNECT        0x00000004
#define SRB_FLAGS_DISABLE_SYNCH_TRANSFER    0x00000008

#define SRB_FLAGS_BYPASS_FROZEN_QUEUE       0x00000010
#define SRB_FLAGS_DISABLE_AUTOSENSE         0x00000020
#define SRB_FLAGS_DATA_IN                   0x00000040
#define SRB_FLAGS_DATA_OUT                  0x00000080
#define SRB_FLAGS_NO_DATA_TRANSFER          0x00000000
#define SRB_FLAGS_UNSPECIFIED_DIRECTION      (SRB_FLAGS_DATA_IN | SRB_FLAGS_DATA_OUT)

#define SRB_FLAGS_NO_QUEUE_FREEZE           0x00000100
#define SRB_FLAGS_ADAPTER_CACHE_ENABLE      0x00000200
#define SRB_FLAGS_FREE_SENSE_BUFFER         0x00000400

#define SRB_FLAGS_IS_ACTIVE                 0x00010000
#define SRB_FLAGS_ALLOCATED_FROM_ZONE       0x00020000
#define SRB_FLAGS_SGLIST_FROM_POOL          0x00040000
#define SRB_FLAGS_BYPASS_LOCKED_QUEUE       0x00080000

#define SRB_FLAGS_NO_KEEP_AWAKE             0x00100000
#define SRB_FLAGS_PORT_DRIVER_ALLOCSENSE    0x00200000
#define SRB_FLAGS_PORT_DRIVER_SENSEHASPORT  0x00400000
#define SRB_FLAGS_DONT_START_NEXT_PACKET    0x00800000

#define SRB_FLAGS_PORT_DRIVER_RESERVED      0x0F000000
#define SRB_FLAGS_CLASS_DRIVER_RESERVED     0xF0000000

#if DBG==1
//
// A signature used to validate the scsi port number
// at the end of a sense buffer.
//
#define SCSI_PORT_SIGNATURE                 0x54524f50
#endif

//
// Queue Action
//

#define SRB_SIMPLE_TAG_REQUEST              0x20
#define SRB_HEAD_OF_QUEUE_TAG_REQUEST       0x21
#define SRB_ORDERED_QUEUE_TAG_REQUEST       0x22

#define SRB_WMI_FLAGS_ADAPTER_REQUEST       0x01


#ifndef _NTDDK_
#define SCSIPORT_API DECLSPEC_IMPORT
#else
#define SCSIPORT_API
#endif


SCSIPORT_API
VOID
ScsiDebugPrint(
    ULONG DebugPrintLevel,
    PCCHAR DebugMessage,
    ...
    );


//
// Command Descriptor Block. Passed by SCSI controller chip over the SCSI bus
//

typedef union _CDB {

    //
    // Generic 6-Byte CDB
    //

    struct _CDB6GENERIC {
       UCHAR  OperationCode;
       UCHAR  Immediate : 1;
       UCHAR  CommandUniqueBits : 4;
       UCHAR  LogicalUnitNumber : 3;
       UCHAR  CommandUniqueBytes[3];
       UCHAR  Link : 1;
       UCHAR  Flag : 1;
       UCHAR  Reserved : 4;
       UCHAR  VendorUnique : 2;
    } CDB6GENERIC, *PCDB6GENERIC;

    //
    // Standard 6-byte CDB
    //

    struct _CDB6READWRITE {
        UCHAR OperationCode;    // 0x08, 0x0A - SCSIOP_READ, SCSIOP_WRITE
        UCHAR LogicalBlockMsb1 : 5;
        UCHAR LogicalUnitNumber : 3;
        UCHAR LogicalBlockMsb0;
        UCHAR LogicalBlockLsb;
        UCHAR TransferBlocks;
        UCHAR Control;
    } CDB6READWRITE, *PCDB6READWRITE;

    //
    // SCSI-1 Inquiry CDB
    //

    struct _CDB6INQUIRY {
        UCHAR OperationCode;    // 0x12 - SCSIOP_INQUIRY
        UCHAR Reserved1 : 5;
        UCHAR LogicalUnitNumber : 3;
        UCHAR PageCode;
        UCHAR IReserved;
        UCHAR AllocationLength;
        UCHAR Control;
    } CDB6INQUIRY, *PCDB6INQUIRY;

    //
    // SCSI-3 Inquiry CDB
    //

    struct _CDB6INQUIRY3 {
        UCHAR OperationCode;    // 0x12 - SCSIOP_INQUIRY
        UCHAR EnableVitalProductData : 1;
        UCHAR CommandSupportData : 1;
        UCHAR Reserved1 : 6;
        UCHAR PageCode;
        UCHAR Reserved2;
        UCHAR AllocationLength;
        UCHAR Control;
    } CDB6INQUIRY3, *PCDB6INQUIRY3;

    struct _CDB6VERIFY {
        UCHAR OperationCode;    // 0x13 - SCSIOP_VERIFY
        UCHAR Fixed : 1;
        UCHAR ByteCompare : 1;
        UCHAR Immediate : 1;
        UCHAR Reserved : 2;
        UCHAR LogicalUnitNumber : 3;
        UCHAR VerificationLength[3];
        UCHAR Control;
    } CDB6VERIFY, *PCDB6VERIFY;

    //
    // SCSI Format CDB
    //

    struct _CDB6FORMAT {
        UCHAR OperationCode;    // 0x04 - SCSIOP_FORMAT_UNIT
        UCHAR FormatControl : 5;
        UCHAR LogicalUnitNumber : 3;
        UCHAR FReserved1;
        UCHAR InterleaveMsb;
        UCHAR InterleaveLsb;
        UCHAR FReserved2;
    } CDB6FORMAT, *PCDB6FORMAT;

    //
    // Standard 10-byte CDB

    struct _CDB10 {
        UCHAR OperationCode;
        UCHAR RelativeAddress : 1;
        UCHAR Reserved1 : 2;
        UCHAR ForceUnitAccess : 1;
        UCHAR DisablePageOut : 1;
        UCHAR LogicalUnitNumber : 3;
        UCHAR LogicalBlockByte0;
        UCHAR LogicalBlockByte1;
        UCHAR LogicalBlockByte2;
        UCHAR LogicalBlockByte3;
        UCHAR Reserved2;
        UCHAR TransferBlocksMsb;
        UCHAR TransferBlocksLsb;
        UCHAR Control;
    } CDB10, *PCDB10;

    //
    // Standard 12-byte CDB
    //

    struct _CDB12 {
        UCHAR OperationCode;
        UCHAR RelativeAddress : 1;
        UCHAR Reserved1 : 2;
        UCHAR ForceUnitAccess : 1;
        UCHAR DisablePageOut : 1;
        UCHAR LogicalUnitNumber : 3;
        UCHAR LogicalBlock[4];
        UCHAR TransferLength[4];
        UCHAR Reserved2;
        UCHAR Control;
    } CDB12, *PCDB12;



    //
    // CD Rom Audio CDBs
    //

    struct _PAUSE_RESUME {
        UCHAR OperationCode;    // 0x4B - SCSIOP_PAUSE_RESUME
        UCHAR Reserved1 : 5;
        UCHAR LogicalUnitNumber : 3;
        UCHAR Reserved2[6];
        UCHAR Action;
        UCHAR Control;
    } PAUSE_RESUME, *PPAUSE_RESUME;

    //
    // Read Table of Contents
    //

    struct _READ_TOC {
        UCHAR OperationCode;    // 0x43 - SCSIOP_READ_TOC
        UCHAR Reserved0 : 1;
        UCHAR Msf : 1;
        UCHAR Reserved1 : 3;
        UCHAR LogicalUnitNumber : 3;
        UCHAR Format2 : 4;
        UCHAR Reserved2 : 4;
        UCHAR Reserved3[3];
        UCHAR StartingTrack;
        UCHAR AllocationLength[2];
        UCHAR Control : 6;
        UCHAR Format : 2;
    } READ_TOC, *PREAD_TOC;

    struct _READ_DISK_INFORMATION {
        UCHAR OperationCode;    // 0x51 - SCSIOP_READ_DISC_INFORMATION
        UCHAR Reserved1 : 5;
        UCHAR Lun : 3;
        UCHAR Reserved2[5];
        UCHAR AllocationLength[2];
        UCHAR Control;
    } READ_DISK_INFORMATION, *PREAD_DISK_INFORMATION;

    struct _READ_TRACK_INFORMATION {
        UCHAR OperationCode;    // 0x52 - SCSIOP_READ_TRACK_INFORMATION
        UCHAR Track : 1;
        UCHAR Reserved1 : 3;
        UCHAR Reserved2 : 1;
        UCHAR Lun : 3;
        UCHAR BlockAddress[4];  // or Track Number
        UCHAR Reserved3;
        UCHAR AllocationLength[2];
        UCHAR Control;
    } READ_TRACK_INFORMATION, *PREAD_TRACK_INFORMATION;

    struct _RESERVE_TRACK_RZONE {
        UCHAR OperationCode;    // 0x53 - SCSIOP_RESERVE_TRACK_RZONE
        UCHAR Reserved1[4];
        UCHAR ReservationSize[4];
        UCHAR Control;
    } RESERVE_TRACK_RZONE, *PRESERVE_TRACK_RZONE;

    struct _SEND_OPC_INFORMATION {
        UCHAR OperationCode;    // 0x54 - SCSIOP_SEND_OPC_INFORMATION
        UCHAR DoOpc    : 1;     // perform OPC
        UCHAR Reserved : 7;
        UCHAR Reserved1[5];
        UCHAR ParameterListLength[2];
        UCHAR Reserved2;
    } SEND_OPC_INFORMATION, *PSEND_OPC_INFORMATION;

    struct _CLOSE_TRACK {
        UCHAR OperationCode;    // 0x5B - SCSIOP_CLOSE_TRACK_SESSION
        UCHAR Immediate : 1;
        UCHAR Reserved1 : 7;
        UCHAR Track     : 1;
        UCHAR Session   : 1;
        UCHAR Reserved2 : 6;
        UCHAR Reserved3;
        UCHAR TrackNumber[2];
        UCHAR Reserved4[3];
        UCHAR Control;
    } CLOSE_TRACK, *PCLOSE_TRACK;

    struct _SEND_CUE_SHEET {
        UCHAR OperationCode;    // 0x5D - SCSIOP_SEND_CUE_SHEET
        UCHAR Reserved[5];
        UCHAR CueSheetSize[3];
        UCHAR Control;
    } SEND_CUE_SHEET, *PSEND_CUE_SHEET;

    struct _READ_HEADER {
        UCHAR OperationCode;    // 0x44 - SCSIOP_READ_HEADER
        UCHAR Reserved1 : 1;
        UCHAR Msf : 1;
        UCHAR Reserved2 : 3;
        UCHAR Lun : 3;
        UCHAR LogicalBlockAddress[4];
        UCHAR Reserved3;
        UCHAR AllocationLength[2];
        UCHAR Control;
    } READ_HEADER, *PREAD_HEADER;

    struct _PLAY_AUDIO {
        UCHAR OperationCode;    // 0x45 - SCSIOP_PLAY_AUDIO
        UCHAR Reserved1 : 5;
        UCHAR LogicalUnitNumber : 3;
        UCHAR StartingBlockAddress[4];
        UCHAR Reserved2;
        UCHAR PlayLength[2];
        UCHAR Control;
    } PLAY_AUDIO, *PPLAY_AUDIO;

    struct _PLAY_AUDIO_MSF { 
        UCHAR OperationCode;    // 0x47 - SCSIOP_PLAY_AUDIO_MSF
        UCHAR Reserved1 : 5;
        UCHAR LogicalUnitNumber : 3;
        UCHAR Reserved2;
        UCHAR StartingM;
        UCHAR StartingS;
        UCHAR StartingF;
        UCHAR EndingM;
        UCHAR EndingS;
        UCHAR EndingF;
        UCHAR Control;
    } PLAY_AUDIO_MSF, *PPLAY_AUDIO_MSF;

    struct _PLAY_CD {
        UCHAR OperationCode;    // 0xBC - SCSIOP_PLAY_CD
        UCHAR Reserved1 : 1;
        UCHAR CMSF : 1;         // LBA = 0, MSF = 1
        UCHAR ExpectedSectorType : 3;
        UCHAR Lun : 3;

        union {
            struct _LBA {
                UCHAR StartingBlockAddress[4];
                UCHAR PlayLength[4];
            } LBA;

            struct _MSF {
                UCHAR Reserved1;
                UCHAR StartingM;
                UCHAR StartingS;
                UCHAR StartingF;
                UCHAR EndingM;
                UCHAR EndingS;
                UCHAR EndingF;
                UCHAR Reserved2;
            } MSF;
        };

        UCHAR Audio : 1;
        UCHAR Composite : 1;
        UCHAR Port1 : 1;
        UCHAR Port2 : 1;
        UCHAR Reserved2 : 3;
        UCHAR Speed : 1;
        UCHAR Control;
    } PLAY_CD, *PPLAY_CD;

    struct _SCAN_CD {
        UCHAR OperationCode;    // 0xBA - SCSIOP_SCAN_CD
        UCHAR RelativeAddress : 1;
        UCHAR Reserved1 : 3;
        UCHAR Direct : 1;
        UCHAR Lun : 3;
        UCHAR StartingAddress[4];
        UCHAR Reserved2[3];
        UCHAR Reserved3 : 6;
        UCHAR Type : 2;
        UCHAR Reserved4;
        UCHAR Control;
    } SCAN_CD, *PSCAN_CD;

    struct _STOP_PLAY_SCAN {
        UCHAR OperationCode;    // 0x4E - SCSIOP_STOP_PLAY_SCAN
        UCHAR Reserved1 : 5;
        UCHAR Lun : 3;
        UCHAR Reserved2[7];
        UCHAR Control;
    } STOP_PLAY_SCAN, *PSTOP_PLAY_SCAN;


    //
    // Read SubChannel Data
    //

    struct _SUBCHANNEL {
        UCHAR OperationCode;    // 0x42 - SCSIOP_READ_SUB_CHANNEL
        UCHAR Reserved0 : 1;
        UCHAR Msf : 1;
        UCHAR Reserved1 : 3;
        UCHAR LogicalUnitNumber : 3;
        UCHAR Reserved2 : 6;
        UCHAR SubQ : 1;
        UCHAR Reserved3 : 1;
        UCHAR Format;
        UCHAR Reserved4[2];
        UCHAR TrackNumber;
        UCHAR AllocationLength[2];
        UCHAR Control;
    } SUBCHANNEL, *PSUBCHANNEL;

    //
    // Read CD. Used by Atapi for raw sector reads.
    //

    struct _READ_CD { 
        UCHAR OperationCode;    // 0xBE - SCSIOP_READ_CD
        UCHAR RelativeAddress : 1;
        UCHAR Reserved0 : 1;
        UCHAR ExpectedSectorType : 3;
        UCHAR Lun : 3;
        UCHAR StartingLBA[4];
        UCHAR TransferBlocks[3];
        UCHAR Reserved2 : 1;
        UCHAR ErrorFlags : 2;
        UCHAR IncludeEDC : 1;
        UCHAR IncludeUserData : 1;
        UCHAR HeaderCode : 2;
        UCHAR IncludeSyncData : 1;
        UCHAR SubChannelSelection : 3;
        UCHAR Reserved3 : 5;
        UCHAR Control;
    } READ_CD, *PREAD_CD;

    struct _READ_CD_MSF {
        UCHAR OperationCode;    // 0xB9 - SCSIOP_READ_CD_MSF
        UCHAR RelativeAddress : 1;
        UCHAR Reserved1 : 1;
        UCHAR ExpectedSectorType : 3;
        UCHAR Lun : 3;
        UCHAR Reserved2;
        UCHAR StartingM;
        UCHAR StartingS;
        UCHAR StartingF;
        UCHAR EndingM;
        UCHAR EndingS;
        UCHAR EndingF;
        UCHAR Reserved3;
        UCHAR Reserved4 : 1;
        UCHAR ErrorFlags : 2;
        UCHAR IncludeEDC : 1;
        UCHAR IncludeUserData : 1;
        UCHAR HeaderCode : 2;
        UCHAR IncludeSyncData : 1;
        UCHAR SubChannelSelection : 3;
        UCHAR Reserved5 : 5;
        UCHAR Control;
    } READ_CD_MSF, *PREAD_CD_MSF;

    //
    // Plextor Read CD-DA
    //

    struct _PLXTR_READ_CDDA {
        UCHAR OperationCode;    // Unknown -- vendor-unique?
        UCHAR Reserved0 : 5;
        UCHAR LogicalUnitNumber :3;
        UCHAR LogicalBlockByte0;
        UCHAR LogicalBlockByte1;
        UCHAR LogicalBlockByte2;
        UCHAR LogicalBlockByte3;
        UCHAR TransferBlockByte0;
        UCHAR TransferBlockByte1;
        UCHAR TransferBlockByte2;
        UCHAR TransferBlockByte3;
        UCHAR SubCode;
        UCHAR Control;
    } PLXTR_READ_CDDA, *PPLXTR_READ_CDDA;

    //
    // NEC Read CD-DA
    //

    struct _NEC_READ_CDDA {
        UCHAR OperationCode;    // Unknown -- vendor-unique?
        UCHAR Reserved0;
        UCHAR LogicalBlockByte0;
        UCHAR LogicalBlockByte1;
        UCHAR LogicalBlockByte2;
        UCHAR LogicalBlockByte3;
        UCHAR Reserved1;
        UCHAR TransferBlockByte0;
        UCHAR TransferBlockByte1;
        UCHAR Control;
    } NEC_READ_CDDA, *PNEC_READ_CDDA;

    //
    // Mode sense
    //

    struct _MODE_SENSE {
        UCHAR OperationCode;    // 0x1A - SCSIOP_MODE_SENSE
        UCHAR Reserved1 : 3;
        UCHAR Dbd : 1;
        UCHAR Reserved2 : 1;
        UCHAR LogicalUnitNumber : 3;
        UCHAR PageCode : 6;
        UCHAR Pc : 2;
        UCHAR Reserved3;
        UCHAR AllocationLength;
        UCHAR Control;
    } MODE_SENSE, *PMODE_SENSE;

    struct _MODE_SENSE10 {
        UCHAR OperationCode;    // 0x5A - SCSIOP_MODE_SENSE10
        UCHAR Reserved1 : 3;
        UCHAR Dbd : 1;
        UCHAR Reserved2 : 1;
        UCHAR LogicalUnitNumber : 3;
        UCHAR PageCode : 6;
        UCHAR Pc : 2;
        UCHAR Reserved3[4];
        UCHAR AllocationLength[2];
        UCHAR Control;
    } MODE_SENSE10, *PMODE_SENSE10;

    //
    // Mode select
    //

    struct _MODE_SELECT {
        UCHAR OperationCode;    // 0x15 - SCSIOP_MODE_SELECT
        UCHAR SPBit : 1;
        UCHAR Reserved1 : 3;
        UCHAR PFBit : 1;
        UCHAR LogicalUnitNumber : 3;
        UCHAR Reserved2[2];
        UCHAR ParameterListLength;
        UCHAR Control;
    } MODE_SELECT, *PMODE_SELECT;

    struct _MODE_SELECT10 {
        UCHAR OperationCode;    // 0x55 - SCSIOP_MODE_SELECT10
        UCHAR SPBit : 1;
        UCHAR Reserved1 : 3;
        UCHAR PFBit : 1;
        UCHAR LogicalUnitNumber : 3;
        UCHAR Reserved2[5];
        UCHAR ParameterListLength[2];
        UCHAR Control;
    } MODE_SELECT10, *PMODE_SELECT10;

    struct _LOCATE {
        UCHAR OperationCode;    // 0x2B - SCSIOP_LOCATE
        UCHAR Immediate : 1;
        UCHAR CPBit : 1;
        UCHAR BTBit : 1;
        UCHAR Reserved1 : 2;
        UCHAR LogicalUnitNumber : 3;
        UCHAR Reserved3;
        UCHAR LogicalBlockAddress[4];
        UCHAR Reserved4;
        UCHAR Partition;
        UCHAR Control;
    } LOCATE, *PLOCATE;

    struct _LOGSENSE {
        UCHAR OperationCode;    // 0x4D - SCSIOP_LOG_SENSE
        UCHAR SPBit : 1;
        UCHAR PPCBit : 1;
        UCHAR Reserved1 : 3;
        UCHAR LogicalUnitNumber : 3;
        UCHAR PageCode : 6;
        UCHAR PCBit : 2;
        UCHAR Reserved2;
        UCHAR Reserved3;
        UCHAR ParameterPointer[2];
        UCHAR AllocationLength[2];
        UCHAR Control;
    } LOGSENSE, *PLOGSENSE;

    struct _LOGSELECT {
        UCHAR OperationCode;    // 0x4C - SCSIOP_LOG_SELECT
        UCHAR SPBit : 1;
        UCHAR PCRBit : 1;
        UCHAR Reserved1 : 3;
        UCHAR LogicalUnitNumber : 3;
        UCHAR Reserved : 6;
        UCHAR PCBit : 2;
        UCHAR Reserved2[4];
        UCHAR ParameterListLength[2];
        UCHAR Control;
    } LOGSELECT, *PLOGSELECT;

    struct _PRINT {
        UCHAR OperationCode;    // 0x0A - SCSIOP_PRINT
        UCHAR Reserved : 5;
        UCHAR LogicalUnitNumber : 3;
        UCHAR TransferLength[3];
        UCHAR Control;
    } PRINT, *PPRINT;

    struct _SEEK {
        UCHAR OperationCode;    // 0x2B - SCSIOP_SEEK
        UCHAR Reserved1 : 5;
        UCHAR LogicalUnitNumber : 3;
        UCHAR LogicalBlockAddress[4];
        UCHAR Reserved2[3];
        UCHAR Control;
    } SEEK, *PSEEK;

    struct _ERASE {
        UCHAR OperationCode;    // 0x19 - SCSIOP_ERASE
        UCHAR Long : 1;
        UCHAR Immediate : 1;
        UCHAR Reserved1 : 3;
        UCHAR LogicalUnitNumber : 3;
        UCHAR Reserved2[3];
        UCHAR Control;
    } ERASE, *PERASE;

    struct _START_STOP {
        UCHAR OperationCode;    // 0x1B - SCSIOP_START_STOP_UNIT
        UCHAR Immediate: 1;
        UCHAR Reserved1 : 4;
        UCHAR LogicalUnitNumber : 3;
        UCHAR Reserved2[2];
        UCHAR Start : 1;
        UCHAR LoadEject : 1;
        UCHAR Reserved3 : 6;
        UCHAR Control;
    } START_STOP, *PSTART_STOP;

    struct _MEDIA_REMOVAL {
        UCHAR OperationCode;    // 0x1E - SCSIOP_MEDIUM_REMOVAL
        UCHAR Reserved1 : 5;
        UCHAR LogicalUnitNumber : 3;
        UCHAR Reserved2[2];

        UCHAR Prevent : 1;
        UCHAR Persistant : 1;
        UCHAR Reserved3 : 6;

        UCHAR Control;
    } MEDIA_REMOVAL, *PMEDIA_REMOVAL;

    //
    // Tape CDBs
    //

    struct _SEEK_BLOCK {
        UCHAR OperationCode;    // 0x0C - SCSIOP_SEEK_BLOCK
        UCHAR Immediate : 1;
        UCHAR Reserved1 : 7;
        UCHAR BlockAddress[3];
        UCHAR Link : 1;
        UCHAR Flag : 1;
        UCHAR Reserved2 : 4;
        UCHAR VendorUnique : 2;
    } SEEK_BLOCK, *PSEEK_BLOCK;

    struct _REQUEST_BLOCK_ADDRESS {
        UCHAR OperationCode;    // 0x02 - SCSIOP_REQUEST_BLOCK_ADDR
        UCHAR Reserved1[3];
        UCHAR AllocationLength;
        UCHAR Link : 1;
        UCHAR Flag : 1;
        UCHAR Reserved2 : 4;
        UCHAR VendorUnique : 2;
    } REQUEST_BLOCK_ADDRESS, *PREQUEST_BLOCK_ADDRESS;

    struct _PARTITION {
        UCHAR OperationCode;    // 0x0D - SCSIOP_PARTITION
        UCHAR Immediate : 1;
        UCHAR Sel: 1;
        UCHAR PartitionSelect : 6;
        UCHAR Reserved1[3];
        UCHAR Control;
    } PARTITION, *PPARTITION;

    struct _WRITE_TAPE_MARKS {
        UCHAR OperationCode;    // Unknown -- vendor-unique?
        UCHAR Immediate : 1;
        UCHAR WriteSetMarks: 1;
        UCHAR Reserved : 3;
        UCHAR LogicalUnitNumber : 3;
        UCHAR TransferLength[3];
        UCHAR Control;
    } WRITE_TAPE_MARKS, *PWRITE_TAPE_MARKS;

    struct _SPACE_TAPE_MARKS {
        UCHAR OperationCode;    // Unknown -- vendor-unique?
        UCHAR Code : 3;
        UCHAR Reserved : 2;
        UCHAR LogicalUnitNumber : 3;
        UCHAR NumMarksMSB ;
        UCHAR NumMarks;
        UCHAR NumMarksLSB;
        union {
            UCHAR value;
            struct {
                UCHAR Link : 1;
                UCHAR Flag : 1;
                UCHAR Reserved : 4;
                UCHAR VendorUnique : 2;
            } Fields;
        } Byte6;
    } SPACE_TAPE_MARKS, *PSPACE_TAPE_MARKS;

    //
    // Read tape position
    //

    struct _READ_POSITION {
        UCHAR Operation;        // 0x43 - SCSIOP_READ_POSITION
        UCHAR BlockType:1;
        UCHAR Reserved1:4;
        UCHAR Lun:3;
        UCHAR Reserved2[7];
        UCHAR Control;
    } READ_POSITION, *PREAD_POSITION;

    //
    // ReadWrite for Tape
    //

    struct _CDB6READWRITETAPE {
        UCHAR OperationCode;    // Unknown -- vendor-unique?
        UCHAR VendorSpecific : 5;
        UCHAR Reserved : 3;
        UCHAR TransferLenMSB;
        UCHAR TransferLen;
        UCHAR TransferLenLSB;
        UCHAR Link : 1;
        UCHAR Flag : 1;
        UCHAR Reserved1 : 4;
        UCHAR VendorUnique : 2;
    } CDB6READWRITETAPE, *PCDB6READWRITETAPE;

    //
    // Medium changer CDB's
    //

    struct _INIT_ELEMENT_STATUS {
        UCHAR OperationCode;    // 0x07 - SCSIOP_INIT_ELEMENT_STATUS
        UCHAR Reserved1 : 5;
        UCHAR LogicalUnitNubmer : 3;
        UCHAR Reserved2[3];
        UCHAR Reserved3 : 7;
        UCHAR NoBarCode : 1;
    } INIT_ELEMENT_STATUS, *PINIT_ELEMENT_STATUS;

    struct _INITIALIZE_ELEMENT_RANGE {
        UCHAR OperationCode;    // 0xE7 - SCSIOP_INIT_ELEMENT_RANGE
        UCHAR Range : 1;
        UCHAR Reserved1 : 4;
        UCHAR LogicalUnitNubmer : 3;
        UCHAR FirstElementAddress[2];
        UCHAR Reserved2[2];
        UCHAR NumberOfElements[2];
        UCHAR Reserved3;
        UCHAR Reserved4 : 7;
        UCHAR NoBarCode : 1;
    } INITIALIZE_ELEMENT_RANGE, *PINITIALIZE_ELEMENT_RANGE;

    struct _POSITION_TO_ELEMENT {
        UCHAR OperationCode;    // 0x2B - SCSIOP_POSITION_TO_ELEMENT
        UCHAR Reserved1 : 5;
        UCHAR LogicalUnitNumber : 3;
        UCHAR TransportElementAddress[2];
        UCHAR DestinationElementAddress[2];
        UCHAR Reserved2[2];
        UCHAR Flip : 1;
        UCHAR Reserved3 : 7;
        UCHAR Control;
    } POSITION_TO_ELEMENT, *PPOSITION_TO_ELEMENT;

    struct _MOVE_MEDIUM {
        UCHAR OperationCode;    // 0xA5 - SCSIOP_MOVE_MEDIUM
        UCHAR Reserved1 : 5;
        UCHAR LogicalUnitNumber : 3;
        UCHAR TransportElementAddress[2];
        UCHAR SourceElementAddress[2];
        UCHAR DestinationElementAddress[2];
        UCHAR Reserved2[2];
        UCHAR Flip : 1;
        UCHAR Reserved3 : 7;
        UCHAR Control;
    } MOVE_MEDIUM, *PMOVE_MEDIUM;

    struct _EXCHANGE_MEDIUM {
        UCHAR OperationCode;    // 0xA6 - SCSIOP_EXCHANGE_MEDIUM
        UCHAR Reserved1 : 5;
        UCHAR LogicalUnitNumber : 3;
        UCHAR TransportElementAddress[2];
        UCHAR SourceElementAddress[2];
        UCHAR Destination1ElementAddress[2];
        UCHAR Destination2ElementAddress[2];
        UCHAR Flip1 : 1;
        UCHAR Flip2 : 1;
        UCHAR Reserved3 : 6;
        UCHAR Control;
    } EXCHANGE_MEDIUM, *PEXCHANGE_MEDIUM;

    struct _READ_ELEMENT_STATUS {
        UCHAR OperationCode;    // 0xB8 - SCSIOP_READ_ELEMENT_STATUS
        UCHAR ElementType : 4;
        UCHAR VolTag : 1;
        UCHAR LogicalUnitNumber : 3;
        UCHAR StartingElementAddress[2];
        UCHAR NumberOfElements[2];
        UCHAR Reserved1;
        UCHAR AllocationLength[3];
        UCHAR Reserved2;
        UCHAR Control;
    } READ_ELEMENT_STATUS, *PREAD_ELEMENT_STATUS;

    struct _SEND_VOLUME_TAG {
        UCHAR OperationCode;    // 0xB6 - SCSIOP_SEND_VOLUME_TAG
        UCHAR ElementType : 4;
        UCHAR Reserved1 : 1;
        UCHAR LogicalUnitNumber : 3;
        UCHAR StartingElementAddress[2];
        UCHAR Reserved2;
        UCHAR ActionCode : 5;
        UCHAR Reserved3 : 3;
        UCHAR Reserved4[2];
        UCHAR ParameterListLength[2];
        UCHAR Reserved5;
        UCHAR Control;
    } SEND_VOLUME_TAG, *PSEND_VOLUME_TAG;

    struct _REQUEST_VOLUME_ELEMENT_ADDRESS {
        UCHAR OperationCode;    // Unknown -- vendor-unique?
        UCHAR ElementType : 4;
        UCHAR VolTag : 1;
        UCHAR LogicalUnitNumber : 3;
        UCHAR StartingElementAddress[2];
        UCHAR NumberElements[2];
        UCHAR Reserved1;
        UCHAR AllocationLength[3];
        UCHAR Reserved2;
        UCHAR Control;
    } REQUEST_VOLUME_ELEMENT_ADDRESS, *PREQUEST_VOLUME_ELEMENT_ADDRESS;

    //
    // Atapi 2.5 Changer 12-byte CDBs
    //

    struct _LOAD_UNLOAD {
        UCHAR OperationCode;    // 0xA6 - SCSIOP_LOAD_UNLOAD_SLOT
        UCHAR Immediate : 1;
        UCHAR Reserved1 : 4;
        UCHAR Lun : 3;
        UCHAR Reserved2[2];
        UCHAR Start : 1;
        UCHAR LoadEject : 1;
        UCHAR Reserved3: 6;
        UCHAR Reserved4[3];
        UCHAR Slot;
        UCHAR Reserved5[3];
    } LOAD_UNLOAD, *PLOAD_UNLOAD;

    struct _MECH_STATUS {
        UCHAR OperationCode;    // 0xBD - SCSIOP_MECHANISM_STATUS
        UCHAR Reserved : 5;
        UCHAR Lun : 3;
        UCHAR Reserved1[6];
        UCHAR AllocationLength[2];
        UCHAR Reserved2[1];
        UCHAR Control;
    } MECH_STATUS, *PMECH_STATUS;

    //
    // C/DVD 0.9 CDBs
    //

    struct _SYNCHRONIZE_CACHE10 {

        UCHAR OperationCode;    // 0x35 - SCSIOP_SYNCHRONIZE_CACHE

        UCHAR RelAddr : 1;
        UCHAR Immediate : 1;
        UCHAR Reserved : 3;
        UCHAR Lun : 3;

        UCHAR LogicalBlockAddress[4];   // Unused - set to zero
        UCHAR Reserved2;
        UCHAR BlockCount[2];            // Unused - set to zero
        UCHAR Control;
    } SYNCHRONIZE_CACHE10, *PSYNCHRONIZE_CACHE10;

    struct _GET_EVENT_STATUS_NOTIFICATION {
        UCHAR OperationCode;    // 0x4A - SCSIOP_GET_EVENT_STATUS_NOTIFICATION

        UCHAR Immediate : 1;
        UCHAR Reserved : 4;
        UCHAR Lun : 3;

        UCHAR Reserved2[2];
        UCHAR NotificationClassRequest;
        UCHAR Reserved3[2];
        UCHAR EventListLength[2];

        UCHAR Control;
    } GET_EVENT_STATUS_NOTIFICATION, *PGET_EVENT_STATUS_NOTIFICATION;

    struct _READ_DVD_STRUCTURE {
        UCHAR OperationCode;    // 0xAD - SCSIOP_READ_DVD_STRUCTURE
        UCHAR Reserved1 : 5;
        UCHAR Lun : 3;
        UCHAR RMDBlockNumber[4];
        UCHAR LayerNumber;
        UCHAR Format;
        UCHAR AllocationLength[2];
        UCHAR Reserved3 : 6;
        UCHAR AGID : 2;
        UCHAR Control;
    } READ_DVD_STRUCTURE, *PREAD_DVD_STRUCTURE;

    struct _SEND_DVD_STRUCTURE {
        UCHAR OperationCode;    // 0xBF - SCSIOP_SEND_DVD_STRUCTURE
        UCHAR Reserved1 : 5;
        UCHAR Lun : 3;
        UCHAR Reserved2[5];
        UCHAR Format;
        UCHAR ParameterListLength[2];
        UCHAR Reserved3;
        UCHAR Control;
    } SEND_DVD_STRUCTURE, *PSEND_DVD_STRUCTURE;

    struct _SEND_KEY {
        UCHAR OperationCode;    // 0xA3 - SCSIOP_SEND_KEY
        UCHAR Reserved1 : 5;
        UCHAR Lun : 3;
        UCHAR Reserved2[6];
        UCHAR ParameterListLength[2];
        UCHAR KeyFormat : 6;
        UCHAR AGID : 2;
        UCHAR Control;
    } SEND_KEY, *PSEND_KEY;

    struct _REPORT_KEY {
        UCHAR OperationCode;    // 0xA4 - SCSIOP_REPORT_KEY
        UCHAR Reserved1 : 5;
        UCHAR Lun : 3;
        UCHAR LogicalBlockAddress[4];   // for title key
        UCHAR Reserved2[2];
        UCHAR AllocationLength[2];
        UCHAR KeyFormat : 6;
        UCHAR AGID : 2;
        UCHAR Control;
    } REPORT_KEY, *PREPORT_KEY;

    struct _SET_READ_AHEAD {
        UCHAR OperationCode;    // 0xA7 - SCSIOP_SET_READ_AHEAD
        UCHAR Reserved1 : 5;
        UCHAR Lun : 3;
        UCHAR TriggerLBA[4];
        UCHAR ReadAheadLBA[4];
        UCHAR Reserved2;
        UCHAR Control;
    } SET_READ_AHEAD, *PSET_READ_AHEAD;

    struct _READ_FORMATTED_CAPACITIES {
        UCHAR OperationCode;    // 0x23 - SCSIOP_READ_FORMATTED_CAPACITY
        UCHAR Reserved1 : 5;
        UCHAR Lun : 3;
        UCHAR Reserved2[5];
        UCHAR AllocationLength[2];
        UCHAR Control;
    } READ_FORMATTED_CAPACITIES, *PREAD_FORMATTED_CAPACITIES;

    //
    // SCSI-3
    //

    struct _REPORT_LUNS {
        UCHAR OperationCode;    // 0xA0 - SCSIOP_REPORT_LUNS
        UCHAR Reserved1[5];
        UCHAR AllocationLength[4];
        UCHAR Reserved2[1];
        UCHAR Control;
    } REPORT_LUNS, *PREPORT_LUNS;

    struct _PERSISTENT_RESERVE_IN {
        UCHAR OperationCode;    // 0x5E - SCSIOP_PERSISTENT_RESERVE_IN
        UCHAR ServiceAction : 5;
        UCHAR Reserved1 : 3;
        UCHAR Reserved2[5];
        UCHAR AllocationLength[2];
        UCHAR Control;
    } PERSISTENT_RESERVE_IN, *PPERSISTENT_RESERVE_IN;

    struct _PERSISTENT_RESERVE_OUT {
        UCHAR OperationCode;    // 0x5F - SCSIOP_PERSISTENT_RESERVE_OUT
        UCHAR ServiceAction : 5;
        UCHAR Reserved1 : 3;
        UCHAR Type : 4;
        UCHAR Scope : 4;
        UCHAR Reserved2[4];
        UCHAR ParameterListLength[2]; // 0x18
        UCHAR Control;
    } PERSISTENT_RESERVE_OUT, *PPERSISTENT_RESERVE_OUT;

    //
    // MMC / SFF-8090 commands
    //

    struct _GET_CONFIGURATION {
        UCHAR OperationCode;       // 0x46 - SCSIOP_GET_CONFIGURATION
        UCHAR RequestType : 1;     // SCSI_GET_CONFIGURATION_REQUEST_TYPE_*
        UCHAR Reserved1   : 7;     // includes obsolete LUN field
        UCHAR StartingFeature[2];
        UCHAR Reserved2[3];
        UCHAR AllocationLength[2];
        UCHAR Control;
    } GET_CONFIGURATION, *PGET_CONFIGURATION;

    struct _SET_CD_SPEED {
        UCHAR OperationCode;       // 0xB8 - SCSIOP_SET_CD_SPEED
        UCHAR Reserved1;
        UCHAR ReadSpeed[2];        // 1x == (75 * 2352)
        UCHAR WriteSpeed[2];       // 1x == (75 * 2352)
        UCHAR Reserved2[5];
        UCHAR Control;
    } SET_CD_SPEED, *PSET_CD_SPEED;

    ULONG AsUlong[4];
    UCHAR AsByte[16];

} CDB, *PCDB;

////////////////////////////////////////////////////////////////////////////////
//
// GET_EVENT_STATUS_NOTIFICATION
//


#define NOTIFICATION_OPERATIONAL_CHANGE_CLASS_MASK  0x02
#define NOTIFICATION_POWER_MANAGEMENT_CLASS_MASK    0x04
#define NOTIFICATION_EXTERNAL_REQUEST_CLASS_MASK    0x08
#define NOTIFICATION_MEDIA_STATUS_CLASS_MASK        0x10
#define NOTIFICATION_MULTI_HOST_CLASS_MASK          0x20
#define NOTIFICATION_DEVICE_BUSY_CLASS_MASK         0x40


#define NOTIFICATION_NO_CLASS_EVENTS                  0x0
#define NOTIFICATION_OPERATIONAL_CHANGE_CLASS_EVENTS  0x1
#define NOTIFICATION_POWER_MANAGEMENT_CLASS_EVENTS    0x2
#define NOTIFICATION_EXTERNAL_REQUEST_CLASS_EVENTS    0x3
#define NOTIFICATION_MEDIA_STATUS_CLASS_EVENTS        0x4
#define NOTIFICATION_MULTI_HOST_CLASS_EVENTS          0x5
#define NOTIFICATION_DEVICE_BUSY_CLASS_EVENTS         0x6

typedef struct _NOTIFICATION_EVENT_STATUS_HEADER {
    UCHAR EventDataLength[2];

    UCHAR NotificationClass : 3;
    UCHAR Reserved : 4;
    UCHAR NEA : 1;

    UCHAR SupportedEventClasses;
    UCHAR ClassEventData[0];
} NOTIFICATION_EVENT_STATUS_HEADER, *PNOTIFICATION_EVENT_STATUS_HEADER;

#define NOTIFICATION_OPERATIONAL_EVENT_NO_CHANGE         0x0
#define NOTIFICATION_OPERATIONAL_EVENT_CHANGE_REQUESTED  0x1
#define NOTIFICATION_OPERATIONAL_EVENT_CHANGE_OCCURRED   0x2

#define NOTIFICATION_OPERATIONAL_STATUS_AVAILABLE        0x0
#define NOTIFICATION_OPERATIONAL_STATUS_TEMPORARY_BUSY   0x1
#define NOTIFICATION_OPERATIONAL_STATUS_EXTENDED_BUSY    0x2

#define NOTIFICATION_OPERATIONAL_OPCODE_NONE
#define NOTIFICATION_OPERATIONAL_OPCODE_FEATURE_CHANGE   0x1
#define NOTIFICATION_OPERATIONAL_OPCODE_FEATURE_ADDED    0x2
#define NOTIFICATION_OPERATIONAL_OPCODE_UNIT_RESET       0x3
#define NOTIFICATION_OPERATIONAL_OPCODE_FIRMWARE_CHANGED 0x4
#define NOTIFICATION_OPERATIONAL_OPCODE_INQUIRY_CHANGED  0x5

//
// Class event data may be one (or none) of the following:
//

typedef struct _NOTIFICATION_OPERATIONAL_STATUS { // event class == 0x1
    UCHAR OperationalEvent : 4;
    UCHAR Reserved1 : 4;
    UCHAR OperationalStatus : 4;
    UCHAR Reserved2 : 3;
    UCHAR PersistentPrevented : 1;
    UCHAR Operation[2];
} NOTIFICATION_OPERATIONAL_STATUS, *PNOTIFICATION_OPERATIONAL_STATUS;


#define NOTIFICATION_POWER_EVENT_NO_CHANGE          0x0
#define NOTIFICATION_POWER_EVENT_CHANGE_SUCCEEDED   0x1
#define NOTIFICATION_POWER_EVENT_CHANGE_FAILED      0x2

#define NOTIFICATION_POWER_STATUS_ACTIVE            0x1
#define NOTIFICATION_POWER_STATUS_IDLE              0x2
#define NOTIFICATION_POWER_STATUS_STANDBY           0x3
#define NOTIFICATION_POWER_STATUS_SLEEP             0x4

typedef struct _NOTIFICATION_POWER_STATUS { // event class == 0x2
    UCHAR PowerEvent : 4;
    UCHAR Reserved : 4;
    UCHAR PowerStatus;
    UCHAR Reserved2[2];
} NOTIFICATION_POWER_STATUS, *PNOTIFICATION_POWER_STATUS;

#define NOTIFICATION_EXTERNAL_EVENT_NO_CHANGE       0x0
#define NOTIFICATION_EXTERNAL_EVENT_BUTTON_DOWN     0x1
#define NOTIFICATION_EXTERNAL_EVENT_BUTTON_UP       0x2
#define NOTIFICATION_EXTERNAL_EVENT_EXTERNAL        0x3 // respond with GET_CONFIGURATION?

#define NOTIFICATION_EXTERNAL_STATUS_READY          0x0
#define NOTIFICATION_EXTERNAL_STATUS_PREVENT        0x1

#define NOTIFICATION_EXTERNAL_REQUEST_NONE          0x0000
#define NOTIFICATION_EXTERNAL_REQUEST_QUEUE_OVERRUN 0x0001
#define NOTIFICATION_EXTERNAL_REQUEST_PLAY          0x0101
#define NOTIFICATION_EXTERNAL_REQUEST_REWIND_BACK   0x0102
#define NOTIFICATION_EXTERNAL_REQUEST_FAST_FORWARD  0x0103
#define NOTIFICATION_EXTERNAL_REQUEST_PAUSE         0x0104
#define NOTIFICATION_EXTERNAL_REQUEST_STOP          0x0106
#define NOTIFICATION_EXTERNAL_REQUEST_ASCII_LOW     0x0200
#define NOTIFICATION_EXTERNAL_REQUEST_ASCII_HIGH    0x02ff

typedef struct _NOTIFICATION_EXTERNAL_STATUS { // event class == 0x3
    UCHAR ExternalEvent : 4;
    UCHAR Reserved1 : 4;
    UCHAR ExternalStatus : 4;
    UCHAR Reserved2 : 3;
    UCHAR PersistentPrevented : 1;
    UCHAR Request[2];
} NOTIFICATION_EXTERNAL_STATUS, *PNOTIFICATION_EXTERNAL_STATUS;

#define NOTIFICATION_MEDIA_EVENT_NO_CHANGE          0x0
#define NOTIFICATION_MEDIA_EVENT_EJECT_REQUEST      0x1
#define NOTIFICATION_MEDIA_EVENT_NEW_MEDIA          0x2
#define NOTIFICATION_MEDIA_EVENT_MEDIA_REMOVAL      0x3
#define NOTIFICATION_MEDIA_EVENT_MEDIA_CHANGE       0x4

typedef struct _NOTIFICATION_MEDIA_STATUS { // event class == 0x4
    UCHAR MediaEvent : 4;
    UCHAR Reserved : 4;

    union {
        UCHAR PowerStatus; // OBSOLETE -- was improperly named in NT5 headers
        UCHAR MediaStatus; // Use this for currently reserved fields
        struct {
            UCHAR DoorTrayOpen : 1;
            UCHAR MediaPresent : 1;
            UCHAR ReservedX    : 6; // do not reference this directly!
        };
    };
    UCHAR StartSlot;
    UCHAR EndSlot;
} NOTIFICATION_MEDIA_STATUS, *PNOTIFICATION_MEDIA_STATUS;

#define NOTIFICATION_MULTI_HOST_EVENT_NO_CHANGE        0x0
#define NOTIFICATION_MULTI_HOST_EVENT_CONTROL_REQUEST  0x1
#define NOTIFICATION_MULTI_HOST_EVENT_CONTROL_GRANT    0x2
#define NOTIFICATION_MULTI_HOST_EVENT_CONTROL_RELEASE  0x3

#define NOTIFICATION_MULTI_HOST_STATUS_READY           0x0
#define NOTIFICATION_MULTI_HOST_STATUS_PREVENT         0x1

#define NOTIFICATION_MULTI_HOST_PRIORITY_NO_REQUESTS   0x0
#define NOTIFICATION_MULTI_HOST_PRIORITY_LOW           0x1
#define NOTIFICATION_MULTI_HOST_PRIORITY_MEDIUM        0x2
#define NOTIFICATION_MULTI_HOST_PRIORITY_HIGH          0x3

typedef struct _NOTIFICATION_MULTI_HOST_STATUS { // event class == 0x5
    UCHAR MultiHostEvent : 4;
    UCHAR Reserved1 : 4;
    UCHAR MultiHostStatus : 4;
    UCHAR Reserved2 : 3;
    UCHAR PersistentPrevented : 1;
    UCHAR Priority[2];
} NOTIFICATION_MULTI_HOST_STATUS, *PNOTIFICATION_MULTI_HOST_STATUS;

#define NOTIFICATION_BUSY_EVENT_NO_CHANGE           0x0
#define NOTIFICATION_BUSY_EVENT_BUSY                0x1

#define NOTIFICATION_BUSY_STATUS_NO_EVENT           0x0
#define NOTIFICATION_BUSY_STATUS_POWER              0x1
#define NOTIFICATION_BUSY_STATUS_IMMEDIATE          0x2
#define NOTIFICATION_BUSY_STATUS_DEFERRED           0x3

typedef struct _NOTIFICATION_BUSY_STATUS { // event class == 0x6
    UCHAR DeviceBusyEvent : 4;
    UCHAR Reserved : 4;

    UCHAR DeviceBusyStatus;
    UCHAR Time[2];
} NOTIFICATION_BUSY_STATUS, *PNOTIFICATION_BUSY_STATUS;
////////////////////////////////////////////////////////////////////////////////

//
// Read DVD Structure Definitions and Constants
//

#define DVD_FORMAT_LEAD_IN          0x00
#define DVD_FORMAT_COPYRIGHT        0x01
#define DVD_FORMAT_DISK_KEY         0x02
#define DVD_FORMAT_BCA              0x03
#define DVD_FORMAT_MANUFACTURING    0x04

typedef struct _READ_DVD_STRUCTURES_HEADER {
    UCHAR Length[2];
    UCHAR Reserved[2];

    UCHAR Data[0];
} READ_DVD_STRUCTURES_HEADER, *PREAD_DVD_STRUCTURES_HEADER;

//
// DiskKey, BCA & Manufacturer information will provide byte arrays as their
// data.
//

//
// CDVD 0.9 Send & Report Key Definitions and Structures
//

#define DVD_REPORT_AGID            0x00
#define DVD_CHALLENGE_KEY          0x01
#define DVD_KEY_1                  0x02
#define DVD_KEY_2                  0x03
#define DVD_TITLE_KEY              0x04
#define DVD_REPORT_ASF             0x05
#define DVD_INVALIDATE_AGID        0x3F

typedef struct _CDVD_KEY_HEADER {
    UCHAR DataLength[2];
    UCHAR Reserved[2];
    UCHAR Data[0];
} CDVD_KEY_HEADER, *PCDVD_KEY_HEADER;

typedef struct _CDVD_REPORT_AGID_DATA {
    UCHAR Reserved1[3];
    UCHAR Reserved2 : 6;
    UCHAR AGID : 2;
} CDVD_REPORT_AGID_DATA, *PCDVD_REPORT_AGID_DATA;

typedef struct _CDVD_CHALLENGE_KEY_DATA {
    UCHAR ChallengeKeyValue[10];
    UCHAR Reserved[2];
} CDVD_CHALLENGE_KEY_DATA, *PCDVD_CHALLENGE_KEY_DATA;

typedef struct _CDVD_KEY_DATA {
    UCHAR Key[5];
    UCHAR Reserved[3];
} CDVD_KEY_DATA, *PCDVD_KEY_DATA;

typedef struct _CDVD_REPORT_ASF_DATA {
    UCHAR Reserved1[3];
    UCHAR Success : 1;
    UCHAR Reserved2 : 7;
} CDVD_REPORT_ASF_DATA, *PCDVD_REPORT_ASF_DATA;

typedef struct _CDVD_TITLE_KEY_HEADER {
    UCHAR DataLength[2];
    UCHAR Reserved1[1];
    UCHAR Reserved2 : 3;
    UCHAR CGMS : 2;
    UCHAR CP_SEC : 1;
    UCHAR CPM : 1;
    UCHAR Zero : 1;
    CDVD_KEY_DATA TitleKey;
} CDVD_TITLE_KEY_HEADER, *PCDVD_TITLE_KEY_HEADER;

//
// Read Formatted Capacity Data - returned in Big Endian Format
//

typedef struct _FORMATTED_CAPACITY_DESCRIPTOR {
    UCHAR NumberOfBlocks[4];
    UCHAR Maximum : 1;
    UCHAR Valid : 1;
    UCHAR BlockLength[3];
} FORMATTED_CAPACITY_DESCRIPTOR, *PFORMATTED_CAPACITY_DESCRIPTOR;

typedef struct _FORMATTED_CAPACITY_LIST {
    UCHAR Reserved[3];
    UCHAR CapacityListLength;
    FORMATTED_CAPACITY_DESCRIPTOR Descriptors[0];
} FORMATTED_CAPACITY_LIST, *PFORMATTED_CAPACITY_LIST;

//
// PLAY_CD definitions and constants
//

#define CD_EXPECTED_SECTOR_ANY          0x0
#define CD_EXPECTED_SECTOR_CDDA         0x1
#define CD_EXPECTED_SECTOR_MODE1        0x2
#define CD_EXPECTED_SECTOR_MODE2        0x3
#define CD_EXPECTED_SECTOR_MODE2_FORM1  0x4
#define CD_EXPECTED_SECTOR_MODE2_FORM2  0x5

//
// Read Disk Information Definitions and Capabilities
//

#define DISK_STATUS_EMPTY       0x00
#define DISK_STATUS_INCOMPLETE  0x01
#define DISK_STATUS_COMPLETE    0x02

#define LAST_SESSION_EMPTY      0x00
#define LAST_SESSION_INCOMPLETE 0x01
#define LAST_SESSION_COMPLETE   0x03

#define DISK_TYPE_CDDA          0x01
#define DISK_TYPE_CDI           0x10
#define DISK_TYPE_XA            0x20
#define DISK_TYPE_UNDEFINED     0xFF

typedef struct _OPC_TABLE_ENTRY {
    UCHAR Speed[2];
    UCHAR OPCValue[6];
} OPC_TABLE_ENTRY, *POPC_TABLE_ENTRY;

typedef struct _DISK_INFORMATION {
    UCHAR Length[2];

    UCHAR DiskStatus : 2;
    UCHAR LastSessionStatus : 2;
    UCHAR Erasable : 1;
    UCHAR Reserved1 : 3;

    UCHAR FirstTrackNumber;
    UCHAR NumberOfSessions;
    UCHAR LastSessionFirstTrack;
    UCHAR LastSessionLastTrack;

    UCHAR Reserved2 : 5;
    UCHAR GEN : 1;
    UCHAR DBC_V : 1;
    UCHAR DID_V : 1;

    UCHAR DiskType;
    UCHAR Reserved3[3];

    UCHAR DiskIdentification[4];
    UCHAR LastSessionLeadIn[4];     // MSF
    UCHAR LastPossibleStartTime[4]; // MSF
    UCHAR DiskBarCode[8];

    UCHAR Reserved4;
    UCHAR NumberOPCEntries;
    OPC_TABLE_ENTRY OPCTable[0];
} DISK_INFORMATION, *PDISK_INFORMATION;

//
// Read Header definitions and structures
//

typedef struct _DATA_BLOCK_HEADER {
    UCHAR DataMode;
    UCHAR Reserved[4];
    union {
        UCHAR LogicalBlockAddress[4];
        struct {
            UCHAR Reserved;
            UCHAR M;
            UCHAR S;
            UCHAR F;
        } MSF;
    };
} DATA_BLOCK_HEADER, *PDATA_BLOCK_HEADER;

#define DATA_BLOCK_MODE0    0x0
#define DATA_BLOCK_MODE1    0x1
#define DATA_BLOCK_MODE2    0x2

//
// Read TOC Format Codes
//

#define READ_TOC_FORMAT_TOC         0x00
#define READ_TOC_FORMAT_SESSION     0x01
#define READ_TOC_FORMAT_FULL_TOC    0x02
#define READ_TOC_FORMAT_PMA         0x03
#define READ_TOC_FORMAT_ATIP        0x04

typedef struct _TRACK_INFORMATION {
    UCHAR Length[2];
    UCHAR TrackNumber;
    UCHAR SessionNumber;
    UCHAR Reserved1;
    UCHAR TrackMode : 4;
    UCHAR Copy : 1;
    UCHAR Damage : 1;
    UCHAR Reserved2 : 2;
    UCHAR DataMode : 4;
    UCHAR FP : 1;
    UCHAR Packet : 1;
    UCHAR Blank : 1;
    UCHAR RT : 1;
    UCHAR NWA_V : 1;
    UCHAR Reserved3 : 7;
    UCHAR TrackStartAddress[4];
    UCHAR NextWritableAddress[4];
    UCHAR FreeBlocks[4];
    UCHAR FixedPacketSize[4];
} TRACK_INFORMATION, *PTRACK_INFORMATION;



//
// Command Descriptor Block constants.
//

#define CDB6GENERIC_LENGTH                   6
#define CDB10GENERIC_LENGTH                  10
#define CDB12GENERIC_LENGTH                  12

#define SETBITON                             1
#define SETBITOFF                            0

//
// Mode Sense/Select page constants.
//

#define MODE_PAGE_ERROR_RECOVERY        0x01
#define MODE_PAGE_DISCONNECT            0x02
#define MODE_PAGE_FORMAT_DEVICE         0x03
#define MODE_PAGE_RIGID_GEOMETRY        0x04
#define MODE_PAGE_FLEXIBILE             0x05 // disk
#define MODE_PAGE_WRITE_PARAMETERS      0x05 // cdrom
#define MODE_PAGE_VERIFY_ERROR          0x07
#define MODE_PAGE_CACHING               0x08
#define MODE_PAGE_PERIPHERAL            0x09
#define MODE_PAGE_CONTROL               0x0A
#define MODE_PAGE_MEDIUM_TYPES          0x0B
#define MODE_PAGE_NOTCH_PARTITION       0x0C
#define MODE_PAGE_CD_AUDIO_CONTROL      0x0E
#define MODE_PAGE_DATA_COMPRESS         0x0F
#define MODE_PAGE_DEVICE_CONFIG         0x10
#define MODE_PAGE_MEDIUM_PARTITION      0x11
#define MODE_PAGE_CDVD_FEATURE_SET      0x18
#define MODE_PAGE_POWER_CONDITION       0x1A
#define MODE_PAGE_FAULT_REPORTING       0x1C
#define MODE_PAGE_CDVD_INACTIVITY       0x1D // cdrom
#define MODE_PAGE_ELEMENT_ADDRESS       0x1D
#define MODE_PAGE_TRANSPORT_GEOMETRY    0x1E
#define MODE_PAGE_DEVICE_CAPABILITIES   0x1F
#define MODE_PAGE_CAPABILITIES          0x2A // cdrom

#define MODE_SENSE_RETURN_ALL           0x3f

#define MODE_SENSE_CURRENT_VALUES       0x00
#define MODE_SENSE_CHANGEABLE_VALUES    0x40
#define MODE_SENSE_DEFAULT_VAULES       0x80
#define MODE_SENSE_SAVED_VALUES         0xc0


//
// SCSI CDB operation codes
//

// 6-byte commands:
#define SCSIOP_TEST_UNIT_READY     0x00
#define SCSIOP_REZERO_UNIT         0x01
#define SCSIOP_REWIND              0x01
#define SCSIOP_REQUEST_BLOCK_ADDR  0x02
#define SCSIOP_REQUEST_SENSE       0x03
#define SCSIOP_FORMAT_UNIT         0x04
#define SCSIOP_READ_BLOCK_LIMITS   0x05
#define SCSIOP_REASSIGN_BLOCKS     0x07
#define SCSIOP_INIT_ELEMENT_STATUS 0x07
#define SCSIOP_READ6               0x08
#define SCSIOP_RECEIVE             0x08
#define SCSIOP_WRITE6              0x0A
#define SCSIOP_PRINT               0x0A
#define SCSIOP_SEND                0x0A
#define SCSIOP_SEEK6               0x0B
#define SCSIOP_TRACK_SELECT        0x0B
#define SCSIOP_SLEW_PRINT          0x0B
#define SCSIOP_SEEK_BLOCK          0x0C
#define SCSIOP_PARTITION           0x0D
#define SCSIOP_READ_REVERSE        0x0F
#define SCSIOP_WRITE_FILEMARKS     0x10
#define SCSIOP_FLUSH_BUFFER        0x10
#define SCSIOP_SPACE               0x11
#define SCSIOP_INQUIRY             0x12
#define SCSIOP_VERIFY6             0x13
#define SCSIOP_RECOVER_BUF_DATA    0x14
#define SCSIOP_MODE_SELECT         0x15
#define SCSIOP_RESERVE_UNIT        0x16
#define SCSIOP_RELEASE_UNIT        0x17
#define SCSIOP_COPY                0x18
#define SCSIOP_ERASE               0x19
#define SCSIOP_MODE_SENSE          0x1A
#define SCSIOP_START_STOP_UNIT     0x1B
#define SCSIOP_STOP_PRINT          0x1B
#define SCSIOP_LOAD_UNLOAD         0x1B
#define SCSIOP_RECEIVE_DIAGNOSTIC  0x1C
#define SCSIOP_SEND_DIAGNOSTIC     0x1D
#define SCSIOP_MEDIUM_REMOVAL      0x1E

// 10-byte commands
#define SCSIOP_READ_FORMATTED_CAPACITY 0x23
#define SCSIOP_READ_CAPACITY       0x25
#define SCSIOP_READ                0x28
#define SCSIOP_WRITE               0x2A
#define SCSIOP_SEEK                0x2B
#define SCSIOP_LOCATE              0x2B
#define SCSIOP_POSITION_TO_ELEMENT 0x2B
#define SCSIOP_WRITE_VERIFY        0x2E
#define SCSIOP_VERIFY              0x2F
#define SCSIOP_SEARCH_DATA_HIGH    0x30
#define SCSIOP_SEARCH_DATA_EQUAL   0x31
#define SCSIOP_SEARCH_DATA_LOW     0x32
#define SCSIOP_SET_LIMITS          0x33
#define SCSIOP_READ_POSITION       0x34
#define SCSIOP_SYNCHRONIZE_CACHE   0x35
#define SCSIOP_COMPARE             0x39
#define SCSIOP_COPY_COMPARE        0x3A
#define SCSIOP_WRITE_DATA_BUFF     0x3B
#define SCSIOP_READ_DATA_BUFF      0x3C
#define SCSIOP_CHANGE_DEFINITION   0x40
#define SCSIOP_READ_SUB_CHANNEL    0x42
#define SCSIOP_READ_TOC            0x43
#define SCSIOP_READ_HEADER         0x44
#define SCSIOP_PLAY_AUDIO          0x45
#define SCSIOP_GET_CONFIGURATION   0x46
#define SCSIOP_PLAY_AUDIO_MSF      0x47
#define SCSIOP_PLAY_TRACK_INDEX    0x48
#define SCSIOP_PLAY_TRACK_RELATIVE 0x49
#define SCSIOP_GET_EVENT_STATUS    0x4A
#define SCSIOP_PAUSE_RESUME        0x4B
#define SCSIOP_LOG_SELECT          0x4C
#define SCSIOP_LOG_SENSE           0x4D
#define SCSIOP_STOP_PLAY_SCAN      0x4E
#define SCSIOP_READ_DISK_INFORMATION    0x51
#define SCSIOP_READ_TRACK_INFORMATION   0x52
#define SCSIOP_RESERVE_TRACK_RZONE      0x53
#define SCSIOP_SEND_OPC_INFORMATION     0x54  // optimum power calibration
#define SCSIOP_MODE_SELECT10            0x55
#define SCSIOP_MODE_SENSE10             0x5A
#define SCSIOP_CLOSE_TRACK_SESSION      0x5B
#define SCSIOP_READ_BUFFER_CAPACITY     0x5C
#define SCSIOP_SEND_CUE_SHEET           0x5D
#define SCSIOP_PERSISTENT_RESERVE_IN    0x5E
#define SCSIOP_PERSISTENT_RESERVE_OUT   0x5F

// 12-byte commands
#define SCSIOP_REPORT_LUNS              0xA0
#define SCSIOP_BLANK                    0xA1
#define SCSIOP_SEND_KEY                 0xA3
#define SCSIOP_REPORT_KEY               0xA4
#define SCSIOP_MOVE_MEDIUM              0xA5
#define SCSIOP_LOAD_UNLOAD_SLOT         0xA6
#define SCSIOP_EXCHANGE_MEDIUM          0xA6
#define SCSIOP_SET_READ_AHEAD           0xA7
#define SCSIOP_READ_DVD_STRUCTURE       0xAD
#define SCSIOP_REQUEST_VOL_ELEMENT      0xB5
#define SCSIOP_SEND_VOLUME_TAG          0xB6
#define SCSIOP_READ_ELEMENT_STATUS      0xB8
#define SCSIOP_READ_CD_MSF              0xB9
#define SCSIOP_SCAN_CD                  0xBA
#define SCSIOP_SET_CD_SPEED             0xBB
#define SCSIOP_PLAY_CD                  0xBC
#define SCSIOP_MECHANISM_STATUS         0xBD
#define SCSIOP_READ_CD                  0xBE
#define SCSIOP_SEND_DVD_STRUCTURE       0xBF
#define SCSIOP_INIT_ELEMENT_RANGE       0xE7

//
// If the IMMED bit is 1, status is returned as soon
// as the operation is initiated. If the IMMED bit
// is 0, status is not returned until the operation
// is completed.
//

#define CDB_RETURN_ON_COMPLETION   0
#define CDB_RETURN_IMMEDIATE       1


//
// Inquiry buffer structure. This is the data returned from the target
// after it receives an inquiry.
//
// This structure may be extended by the number of bytes specified
// in the field AdditionalLength. The defined size constant only
// includes fields through ProductRevisionLevel.
//
// The NT SCSI drivers are only interested in the first 36 bytes of data.
//

#define INQUIRYDATABUFFERSIZE 36

typedef struct _INQUIRYDATA {
    UCHAR DeviceType : 5;
    UCHAR DeviceTypeQualifier : 3;
    UCHAR DeviceTypeModifier : 7;
    UCHAR RemovableMedia : 1;
    union {
        UCHAR Versions;
        struct {
            UCHAR ANSIVersion : 3;
            UCHAR ECMAVersion : 3;
            UCHAR ISOVersion : 2;
        };
    };
    UCHAR ResponseDataFormat : 4;
    UCHAR HiSupport : 1;
    UCHAR NormACA : 1;
    UCHAR TerminateTask : 1;
    UCHAR AERC : 1;
    UCHAR AdditionalLength;
    UCHAR Reserved;
    UCHAR Addr16 : 1;               // defined only for SIP devices.
    UCHAR Addr32 : 1;               // defined only for SIP devices.
    UCHAR AckReqQ: 1;               // defined only for SIP devices.
    UCHAR MediumChanger : 1;
    UCHAR MultiPort : 1;
    UCHAR ReservedBit2 : 1;
    UCHAR EnclosureServices : 1;
    UCHAR ReservedBit3 : 1;
    UCHAR SoftReset : 1;
    UCHAR CommandQueue : 1;
    UCHAR TransferDisable : 1;      // defined only for SIP devices.
    UCHAR LinkedCommands : 1;
    UCHAR Synchronous : 1;          // defined only for SIP devices.
    UCHAR Wide16Bit : 1;            // defined only for SIP devices.
    UCHAR Wide32Bit : 1;            // defined only for SIP devices.
    UCHAR RelativeAddressing : 1;
    UCHAR VendorId[8];
    UCHAR ProductId[16];
    UCHAR ProductRevisionLevel[4];
    UCHAR VendorSpecific[20];
    UCHAR Reserved3[40];
} INQUIRYDATA, *PINQUIRYDATA;

//
// Inquiry defines. Used to interpret data returned from target as result
// of inquiry command.
//
// DeviceType field
//

#define DIRECT_ACCESS_DEVICE            0x00    // disks
#define SEQUENTIAL_ACCESS_DEVICE        0x01    // tapes
#define PRINTER_DEVICE                  0x02    // printers
#define PROCESSOR_DEVICE                0x03    // scanners, printers, etc
#define WRITE_ONCE_READ_MULTIPLE_DEVICE 0x04    // worms
#define READ_ONLY_DIRECT_ACCESS_DEVICE  0x05    // cdroms
#define SCANNER_DEVICE                  0x06    // scanners
#define OPTICAL_DEVICE                  0x07    // optical disks
#define MEDIUM_CHANGER                  0x08    // jukebox
#define COMMUNICATION_DEVICE            0x09    // network
#define LOGICAL_UNIT_NOT_PRESENT_DEVICE 0x7F

#define DEVICE_QUALIFIER_ACTIVE         0x00
#define DEVICE_QUALIFIER_NOT_ACTIVE     0x01
#define DEVICE_QUALIFIER_NOT_SUPPORTED  0x03

//
// DeviceTypeQualifier field
//

#define DEVICE_CONNECTED 0x00

//
// Vital Product Data Pages
//

//
// Unit Serial Number Page (page code 0x80)
//
// Provides a product serial number for the target or the logical unit.
//

typedef struct _VPD_MEDIA_SERIAL_NUMBER_PAGE {
    UCHAR DeviceType : 5;
    UCHAR DeviceTypeQualifier : 3;
    UCHAR PageCode;
    UCHAR Reserved;
    UCHAR PageLength;
    UCHAR SerialNumber[0];
} VPD_MEDIA_SERIAL_NUMBER_PAGE, *PVPD_MEDIA_SERIAL_NUMBER_PAGE;

typedef struct _VPD_SERIAL_NUMBER_PAGE {
    UCHAR DeviceType : 5;
    UCHAR DeviceTypeQualifier : 3;
    UCHAR PageCode;
    UCHAR Reserved;
    UCHAR PageLength;
    UCHAR SerialNumber[0];
} VPD_SERIAL_NUMBER_PAGE, *PVPD_SERIAL_NUMBER_PAGE;

//
// Device Identification Page (page code 0x83)
// Provides the means to retrieve zero or more identification descriptors
// applying to the logical unit.
//

typedef enum _VPD_CODE_SET {
    VpdCodeSetReserved = 0,
    VpdCodeSetBinary = 1,
    VpdCodeSetAscii = 2
} VPD_CODE_SET, *PVPD_CODE_SET;

typedef enum _VPD_ASSOCIATION {
    VpdAssocDevice = 0,
    VpdAssocPort = 1,
    VpdAssocReserved1 = 3,
    VpdAssocReserved2 = 4
} VPD_ASSOCIATION, *PVPD_ASSOCIATION;

typedef enum _VPD_IDENTIFIER_TYPE {
    VpdIdentifierTypeVendorSpecific = 0,
    VpdIdentifierTypeVendorId = 1,
    VpdIdentifierTypeEUI64 = 2,
    VpdIdentifierTypeFCPHName = 3,
    VpdIdentifierTypePortRelative = 4
} VPD_IDENTIFIER_TYPE, *PVPD_IDENTIFIER_TYPE;

typedef struct _VPD_IDENTIFICATION_DESCRIPTOR {
    UCHAR CodeSet : 4;          // VPD_CODE_SET
    UCHAR Reserved : 4;
    UCHAR IdentifierType : 4;   // VPD_IDENTIFIER_TYPE
    UCHAR Association : 2;
    UCHAR Reserved2 : 2;
    UCHAR Reserved3;
    UCHAR IdentifierLength;
    UCHAR Identifier[0];
} VPD_IDENTIFICATION_DESCRIPTOR, *PVPD_IDENTIFICATION_DESCRIPTOR;

typedef struct _VPD_IDENTIFICATION_PAGE {
    UCHAR DeviceType : 5;
    UCHAR DeviceTypeQualifier : 3;
    UCHAR PageCode;
    UCHAR Reserved;
    UCHAR PageLength;


    //
    // The following field is actually a variable length array of identification
    // descriptors.  Unfortunately there's no C notation for an array of
    // variable length structures so we're forced to just pretend.
    //

    // VPD_IDENTIFICATION_DESCRIPTOR Descriptors[0];
    UCHAR Descriptors[0];
} VPD_IDENTIFICATION_PAGE, *PVPD_IDENTIFICATION_PAGE;

//
// Supported Vital Product Data Pages Page (page code 0x00)
// Contains a list of the vital product data page cods supported by the target
// or logical unit.
//

typedef struct _VPD_SUPPORTED_PAGES_PAGE {
    UCHAR DeviceType : 5;
    UCHAR DeviceTypeQualifier : 3;
    UCHAR PageCode;
    UCHAR Reserved;
    UCHAR PageLength;
    UCHAR SupportedPageList[0];
} VPD_SUPPORTED_PAGES_PAGE, *PVPD_SUPPORTED_PAGES_PAGE;


#define VPD_MAX_BUFFER_SIZE         0xff

#define VPD_SUPPORTED_PAGES         0x00
#define VPD_SERIAL_NUMBER           0x80
#define VPD_DEVICE_IDENTIFIERS      0x83
#define VPD_MEDIA_SERIAL_NUMBER     0x84

//
// Persistent Reservation Definitions.
//

//
// PERSISTENT_RESERVE_* definitions
//

#define RESERVATION_ACTION_READ_KEYS                    0x00
#define RESERVATION_ACTION_READ_RESERVATIONS            0x01

#define RESERVATION_ACTION_REGISTER                     0x00
#define RESERVATION_ACTION_RESERVE                      0x01
#define RESERVATION_ACTION_RELEASE                      0x02
#define RESERVATION_ACTION_CLEAR                        0x03
#define RESERVATION_ACTION_PREEMPT                      0x04
#define RESERVATION_ACTION_PREEMPT_ABORT                0x05
#define RESERVATION_ACTION_REGISTER_IGNORE_EXISTING     0x06

#define RESERVATION_SCOPE_LU                            0x00
#define RESERVATION_SCOPE_ELEMENT                       0x02

#define RESERVATION_TYPE_WRITE_EXCLUSIVE                0x01
#define RESERVATION_TYPE_EXCLUSIVE                      0x03
#define RESERVATION_TYPE_WRITE_EXCLUSIVE_REGISTRANTS    0x05
#define RESERVATION_TYPE_EXCLUSIVE_REGISTRANTS          0x06

//
// Structures for reserve in command.
//

typedef struct {
    UCHAR Generation[4];
    UCHAR AdditionalLength[4];
    UCHAR ReservationKeyList[0][8];
} PRI_REGISTRATION_LIST, *PPRI_REGISTRATION_LIST;

typedef struct {
    UCHAR ReservationKey[8];
    UCHAR ScopeSpecificAddress[4];
    UCHAR Reserved;
    UCHAR Type : 4;
    UCHAR Scope : 4;
    UCHAR Obsolete[2];
} PRI_RESERVATION_DESCRIPTOR, *PPRI_RESERVATION_DESCRIPTOR;

typedef struct {
    UCHAR Generation[4];
    UCHAR AdditionalLength[4];
    PRI_RESERVATION_DESCRIPTOR Reservations[0];
} PRI_RESERVATION_LIST, *PPRI_RESERVATION_LIST;

//
// Structures for reserve out command.
//

typedef struct {
    UCHAR ReservationKey[8];
    UCHAR ServiceActionReservationKey[8];
    UCHAR ScopeSpecificAddress[4];
    UCHAR ActivatePersistThroughPowerLoss : 1;
    UCHAR Reserved1 : 7;
    UCHAR Reserved2;
    UCHAR Obsolete[2];
} PRO_PARAMETER_LIST, *PPRO_PARAMETER_LIST;


//
// Sense Data Format
//

typedef struct _SENSE_DATA {
    UCHAR ErrorCode:7;
    UCHAR Valid:1;
    UCHAR SegmentNumber;
    UCHAR SenseKey:4;
    UCHAR Reserved:1;
    UCHAR IncorrectLength:1;
    UCHAR EndOfMedia:1;
    UCHAR FileMark:1;
    UCHAR Information[4];
    UCHAR AdditionalSenseLength;
    UCHAR CommandSpecificInformation[4];
    UCHAR AdditionalSenseCode;
    UCHAR AdditionalSenseCodeQualifier;
    UCHAR FieldReplaceableUnitCode;
    UCHAR SenseKeySpecific[3];
} SENSE_DATA, *PSENSE_DATA;

//
// Default request sense buffer size
//

#define SENSE_BUFFER_SIZE 18

//
// Maximum request sense buffer size
//

#define MAX_SENSE_BUFFER_SIZE 255

//
// Maximum number of additional sense bytes.
//

#define MAX_ADDITIONAL_SENSE_BYTES (MAX_SENSE_BUFFER_SIZE - SENSE_BUFFER_SIZE)

//
// Sense codes
//

#define SCSI_SENSE_NO_SENSE         0x00
#define SCSI_SENSE_RECOVERED_ERROR  0x01
#define SCSI_SENSE_NOT_READY        0x02
#define SCSI_SENSE_MEDIUM_ERROR     0x03
#define SCSI_SENSE_HARDWARE_ERROR   0x04
#define SCSI_SENSE_ILLEGAL_REQUEST  0x05
#define SCSI_SENSE_UNIT_ATTENTION   0x06
#define SCSI_SENSE_DATA_PROTECT     0x07
#define SCSI_SENSE_BLANK_CHECK      0x08
#define SCSI_SENSE_UNIQUE           0x09
#define SCSI_SENSE_COPY_ABORTED     0x0A
#define SCSI_SENSE_ABORTED_COMMAND  0x0B
#define SCSI_SENSE_EQUAL            0x0C
#define SCSI_SENSE_VOL_OVERFLOW     0x0D
#define SCSI_SENSE_MISCOMPARE       0x0E
#define SCSI_SENSE_RESERVED         0x0F

//
// Additional tape bit
//

#define SCSI_ILLEGAL_LENGTH         0x20
#define SCSI_EOM                    0x40
#define SCSI_FILE_MARK              0x80

//
// Additional Sense codes
//

#define SCSI_ADSENSE_NO_SENSE                              0x00
#define SCSI_ADSENSE_NO_SEEK_COMPLETE                      0x02
#define SCSI_ADSENSE_LUN_NOT_READY                         0x04
#define SCSI_ADSENSE_WRITE_ERROR                           0x0C
#define SCSI_ADSENSE_TRACK_ERROR                           0x14
#define SCSI_ADSENSE_SEEK_ERROR                            0x15
#define SCSI_ADSENSE_REC_DATA_NOECC                        0x17
#define SCSI_ADSENSE_REC_DATA_ECC                          0x18
#define SCSI_ADSENSE_ILLEGAL_COMMAND                       0x20
#define SCSI_ADSENSE_ILLEGAL_BLOCK                         0x21
#define SCSI_ADSENSE_INVALID_CDB                           0x24
#define SCSI_ADSENSE_INVALID_LUN                           0x25
#define SCSI_ADSENSE_WRITE_PROTECT                         0x27
#define SCSI_ADSENSE_MEDIUM_CHANGED                        0x28
#define SCSI_ADSENSE_BUS_RESET                             0x29
#define SCSI_ADSENSE_INSUFFICIENT_TIME_FOR_OPERATION       0x2E
#define SCSI_ADSENSE_INVALID_MEDIA                         0x30
#define SCSI_ADSENSE_NO_MEDIA_IN_DEVICE                    0x3a
#define SCSI_ADSENSE_POSITION_ERROR                        0x3b
#define SCSI_ADSENSE_OPERATOR_REQUEST                      0x5a // see below
#define SCSI_ADSENSE_FAILURE_PREDICTION_THRESHOLD_EXCEEDED 0x5d
#define SCSI_ADSENSE_ILLEGAL_MODE_FOR_THIS_TRACK           0x64
#define SCSI_ADSENSE_COPY_PROTECTION_FAILURE               0x6f
#define SCSI_ADSENSE_POWER_CALIBRATION_ERROR               0x73
#define SCSI_ADSENSE_VENDOR_UNIQUE                         0x80 // and higher
#define SCSI_ADSENSE_MUSIC_AREA                            0xA0
#define SCSI_ADSENSE_DATA_AREA                             0xA1
#define SCSI_ADSENSE_VOLUME_OVERFLOW                       0xA7

// for legacy apps:
#define SCSI_ADWRITE_PROTECT                        SCSI_ADSENSE_WRITE_PROTECT
#define SCSI_FAILURE_PREDICTION_THRESHOLD_EXCEEDED  SCSI_ADSENSE_FAILURE_PREDICTION_THRESHOLD_EXCEEDED


//
// SCSI_ADSENSE_LUN_NOT_READY (0x04) qualifiers
//

#define SCSI_SENSEQ_CAUSE_NOT_REPORTABLE         0x00
#define SCSI_SENSEQ_BECOMING_READY               0x01
#define SCSI_SENSEQ_INIT_COMMAND_REQUIRED        0x02
#define SCSI_SENSEQ_MANUAL_INTERVENTION_REQUIRED 0x03
#define SCSI_SENSEQ_FORMAT_IN_PROGRESS           0x04
#define SCSI_SENSEQ_REBUILD_IN_PROGRESS          0x05
#define SCSI_SENSEQ_RECALCULATION_IN_PROGRESS    0x06
#define SCSI_SENSEQ_OPERATION_IN_PROGRESS        0x07
#define SCSI_SENSEQ_LONG_WRITE_IN_PROGRESS       0x08

//
// SCSI_ADSENSE_WRITE_ERROR (0x0C) qualifiers
//
#define SCSI_SENSEQ_LOSS_OF_STREAMING            0x09
#define SCSI_SENSEQ_PADDING_BLOCKS_ADDED         0x0A


//
// SCSI_ADSENSE_NO_SENSE (0x00) qualifiers
//

#define SCSI_SENSEQ_FILEMARK_DETECTED 0x01
#define SCSI_SENSEQ_END_OF_MEDIA_DETECTED 0x02
#define SCSI_SENSEQ_SETMARK_DETECTED 0x03
#define SCSI_SENSEQ_BEGINNING_OF_MEDIA_DETECTED 0x04

//
// SCSI_ADSENSE_ILLEGAL_BLOCK (0x21) qualifiers
//

#define SCSI_SENSEQ_ILLEGAL_ELEMENT_ADDR 0x01

//
// SCSI_ADSENSE_POSITION_ERROR (0x3b) qualifiers
//

#define SCSI_SENSEQ_DESTINATION_FULL 0x0d
#define SCSI_SENSEQ_SOURCE_EMPTY     0x0e

//
// SCSI_ADSENSE_INVALID_MEDIA (0x30) qualifiers
//

#define SCSI_SENSEQ_INCOMPATIBLE_MEDIA_INSTALLED 0x00
#define SCSI_SENSEQ_UNKNOWN_FORMAT 0x01
#define SCSI_SENSEQ_INCOMPATIBLE_FORMAT 0x02
#define SCSI_SENSEQ_CLEANING_CARTRIDGE_INSTALLED 0x03

//
// SCSI_ADSENSE_OPERATOR_REQUEST (0x5a) qualifiers
//

#define SCSI_SENSEQ_STATE_CHANGE_INPUT     0x00 // generic request
#define SCSI_SENSEQ_MEDIUM_REMOVAL         0x01
#define SCSI_SENSEQ_WRITE_PROTECT_ENABLE   0x02
#define SCSI_SENSEQ_WRITE_PROTECT_DISABLE  0x03

//
// SCSI_ADSENSE_COPY_PROTECTION_FAILURE (0x6f) qualifiers
//
#define SCSI_SENSEQ_AUTHENTICATION_FAILURE                          0x00
#define SCSI_SENSEQ_KEY_NOT_PRESENT                                 0x01
#define SCSI_SENSEQ_KEY_NOT_ESTABLISHED                             0x02
#define SCSI_SENSEQ_READ_OF_SCRAMBLED_SECTOR_WITHOUT_AUTHENTICATION 0x03
#define SCSI_SENSEQ_MEDIA_CODE_MISMATCHED_TO_LOGICAL_UNIT           0x04
#define SCSI_SENSEQ_LOGICAL_UNIT_RESET_COUNT_ERROR                  0x05

//
// SCSI_ADSENSE_POWER_CALIBRATION_ERROR (0x73) qualifiers
//

#define SCSI_SENSEQ_POWER_CALIBRATION_AREA_ALMOST_FULL 0x01
#define SCSI_SENSEQ_POWER_CALIBRATION_AREA_FULL        0x02
#define SCSI_SENSEQ_POWER_CALIBRATION_AREA_ERROR       0x03
#define SCSI_SENSEQ_PMA_RMA_UPDATE_FAILURE             0x04
#define SCSI_SENSEQ_PMA_RMA_IS_FULL                    0x05
#define SCSI_SENSEQ_PMA_RMA_ALMOST_FULL                0x06



//
// Read Capacity Data - returned in Big Endian format
//

typedef struct _READ_CAPACITY_DATA {
    ULONG LogicalBlockAddress;
    ULONG BytesPerBlock;
} READ_CAPACITY_DATA, *PREAD_CAPACITY_DATA;

//
// Read Block Limits Data - returned in Big Endian format
// This structure returns the maximum and minimum block
// size for a TAPE device.
//

typedef struct _READ_BLOCK_LIMITS {
    UCHAR Reserved;
    UCHAR BlockMaximumSize[3];
    UCHAR BlockMinimumSize[2];
} READ_BLOCK_LIMITS_DATA, *PREAD_BLOCK_LIMITS_DATA;


//
// Mode data structures.
//

//
// Define Mode parameter header.
//

typedef struct _MODE_PARAMETER_HEADER {
    UCHAR ModeDataLength;
    UCHAR MediumType;
    UCHAR DeviceSpecificParameter;
    UCHAR BlockDescriptorLength;
}MODE_PARAMETER_HEADER, *PMODE_PARAMETER_HEADER;

typedef struct _MODE_PARAMETER_HEADER10 {
    UCHAR ModeDataLength[2];
    UCHAR MediumType;
    UCHAR DeviceSpecificParameter;
    UCHAR Reserved[2];
    UCHAR BlockDescriptorLength[2];
}MODE_PARAMETER_HEADER10, *PMODE_PARAMETER_HEADER10;

#define MODE_FD_SINGLE_SIDE     0x01
#define MODE_FD_DOUBLE_SIDE     0x02
#define MODE_FD_MAXIMUM_TYPE    0x1E
#define MODE_DSP_FUA_SUPPORTED  0x10
#define MODE_DSP_WRITE_PROTECT  0x80

//
// Define the mode parameter block.
//

typedef struct _MODE_PARAMETER_BLOCK {
    UCHAR DensityCode;
    UCHAR NumberOfBlocks[3];
    UCHAR Reserved;
    UCHAR BlockLength[3];
}MODE_PARAMETER_BLOCK, *PMODE_PARAMETER_BLOCK;

//
// Define Disconnect-Reconnect page.
//

typedef struct _MODE_DISCONNECT_PAGE {
    UCHAR PageCode : 6;
    UCHAR Reserved : 1;
    UCHAR PageSavable : 1;
    UCHAR PageLength;
    UCHAR BufferFullRatio;
    UCHAR BufferEmptyRatio;
    UCHAR BusInactivityLimit[2];
    UCHAR BusDisconnectTime[2];
    UCHAR BusConnectTime[2];
    UCHAR MaximumBurstSize[2];
    UCHAR DataTransferDisconnect : 2;
    UCHAR Reserved2[3];
}MODE_DISCONNECT_PAGE, *PMODE_DISCONNECT_PAGE;

//
// Define mode caching page.
//

typedef struct _MODE_CACHING_PAGE {
    UCHAR PageCode : 6;
    UCHAR Reserved : 1;
    UCHAR PageSavable : 1;
    UCHAR PageLength;
    UCHAR ReadDisableCache : 1;
    UCHAR MultiplicationFactor : 1;
    UCHAR WriteCacheEnable : 1;
    UCHAR Reserved2 : 5;
    UCHAR WriteRetensionPriority : 4;
    UCHAR ReadRetensionPriority : 4;
    UCHAR DisablePrefetchTransfer[2];
    UCHAR MinimumPrefetch[2];
    UCHAR MaximumPrefetch[2];
    UCHAR MaximumPrefetchCeiling[2];
}MODE_CACHING_PAGE, *PMODE_CACHING_PAGE;

//
// Define write parameters cdrom page
//
typedef struct _MODE_CDROM_WRITE_PARAMETERS_PAGE {
    UCHAR PageLength;               // 0x32 ??
    UCHAR WriteType                 : 4;
    UCHAR TestWrite                 : 1;
    UCHAR LinkSizeValid             : 1;
    UCHAR BufferUnderrunFreeEnabled : 1;
    UCHAR Reserved2                 : 1;
    UCHAR TrackMode                 : 4;
    UCHAR Copy                      : 1;
    UCHAR FixedPacket               : 1;
    UCHAR MultiSession              : 2;
    UCHAR DataBlockType             : 4;
    UCHAR Reserved3                 : 4;    
    UCHAR LinkSize;
    UCHAR Reserved4;
    UCHAR HostApplicationCode       : 6;
    UCHAR Reserved5                 : 2;    
    UCHAR SessionFormat;
    UCHAR Reserved6;
    UCHAR PacketSize[4];
    UCHAR AudioPauseLength[2];
    UCHAR Reserved7                 : 7;
    UCHAR MediaCatalogNumberValid   : 1;
    UCHAR MediaCatalogNumber[13];
    UCHAR MediaCatalogNumberZero;
    UCHAR MediaCatalogNumberAFrame;
    UCHAR Reserved8                 : 7;
    UCHAR ISRCValid                 : 1;
    UCHAR ISRCCountry[2];
    UCHAR ISRCOwner[3];
    UCHAR ISRCRecordingYear[2];
    UCHAR ISRCSerialNumber[5];
    UCHAR ISRCZero;
    UCHAR ISRCAFrame;
    UCHAR ISRCReserved;
    UCHAR SubHeaderData[4];
} MODE_CDROM_WRITE_PARAMETERS_PAGE, *PMODE_CDROM_WRITE_PARAMETERS_PAGE;

//
// Define mode flexible disk page.
//

typedef struct _MODE_FLEXIBLE_DISK_PAGE {
    UCHAR PageCode : 6;
    UCHAR Reserved : 1;
    UCHAR PageSavable : 1;
    UCHAR PageLength;
    UCHAR TransferRate[2];
    UCHAR NumberOfHeads;
    UCHAR SectorsPerTrack;
    UCHAR BytesPerSector[2];
    UCHAR NumberOfCylinders[2];
    UCHAR StartWritePrecom[2];
    UCHAR StartReducedCurrent[2];
    UCHAR StepRate[2];
    UCHAR StepPluseWidth;
    UCHAR HeadSettleDelay[2];
    UCHAR MotorOnDelay;
    UCHAR MotorOffDelay;
    UCHAR Reserved2 : 5;
    UCHAR MotorOnAsserted : 1;
    UCHAR StartSectorNumber : 1;
    UCHAR TrueReadySignal : 1;
    UCHAR StepPlusePerCyclynder : 4;
    UCHAR Reserved3 : 4;
    UCHAR WriteCompenstation;
    UCHAR HeadLoadDelay;
    UCHAR HeadUnloadDelay;
    UCHAR Pin2Usage : 4;
    UCHAR Pin34Usage : 4;
    UCHAR Pin1Usage : 4;
    UCHAR Pin4Usage : 4;
    UCHAR MediumRotationRate[2];
    UCHAR Reserved4[2];
}MODE_FLEXIBLE_DISK_PAGE, *PMODE_FLEXIBLE_DISK_PAGE;

//
// Define mode format page.
//

typedef struct _MODE_FORMAT_PAGE {
    UCHAR PageCode : 6;
    UCHAR Reserved : 1;
    UCHAR PageSavable : 1;
    UCHAR PageLength;
    UCHAR TracksPerZone[2];
    UCHAR AlternateSectorsPerZone[2];
    UCHAR AlternateTracksPerZone[2];
    UCHAR AlternateTracksPerLogicalUnit[2];
    UCHAR SectorsPerTrack[2];
    UCHAR BytesPerPhysicalSector[2];
    UCHAR Interleave[2];
    UCHAR TrackSkewFactor[2];
    UCHAR CylinderSkewFactor[2];
    UCHAR Reserved2 : 4;
    UCHAR SurfaceFirst : 1;
    UCHAR RemovableMedia : 1;
    UCHAR HardSectorFormating : 1;
    UCHAR SoftSectorFormating : 1;
    UCHAR Reserved3[3];
}MODE_FORMAT_PAGE, *PMODE_FORMAT_PAGE;

//
// Define rigid disk driver geometry page.
//

typedef struct _MODE_RIGID_GEOMETRY_PAGE {
    UCHAR PageCode : 6;
    UCHAR Reserved : 1;
    UCHAR PageSavable : 1;
    UCHAR PageLength;
    UCHAR NumberOfCylinders[3];
    UCHAR NumberOfHeads;
    UCHAR StartWritePrecom[3];
    UCHAR StartReducedCurrent[3];
    UCHAR DriveStepRate[2];
    UCHAR LandZoneCyclinder[3];
    UCHAR RotationalPositionLock : 2;
    UCHAR Reserved2 : 6;
    UCHAR RotationOffset;
    UCHAR Reserved3;
    UCHAR RoataionRate[2];
    UCHAR Reserved4[2];
}MODE_RIGID_GEOMETRY_PAGE, *PMODE_RIGID_GEOMETRY_PAGE;

//
// Define read write recovery page
//

typedef struct _MODE_READ_WRITE_RECOVERY_PAGE {

    UCHAR PageCode : 6;
    UCHAR Reserved1 : 1;
    UCHAR PSBit : 1;
    UCHAR PageLength;
    UCHAR DCRBit : 1;
    UCHAR DTEBit : 1;
    UCHAR PERBit : 1;
    UCHAR EERBit : 1;
    UCHAR RCBit : 1;
    UCHAR TBBit : 1;
    UCHAR ARRE : 1;
    UCHAR AWRE : 1;
    UCHAR ReadRetryCount;
    UCHAR Reserved4[4];
    UCHAR WriteRetryCount;
    UCHAR Reserved5[3];

} MODE_READ_WRITE_RECOVERY_PAGE, *PMODE_READ_WRITE_RECOVERY_PAGE;

//
// Define read recovery page - cdrom
//

typedef struct _MODE_READ_RECOVERY_PAGE {

    UCHAR PageCode : 6;
    UCHAR Reserved1 : 1;
    UCHAR PSBit : 1;
    UCHAR PageLength;
    UCHAR DCRBit : 1;
    UCHAR DTEBit : 1;
    UCHAR PERBit : 1;
    UCHAR Reserved2 : 1;
    UCHAR RCBit : 1;
    UCHAR TBBit : 1;
    UCHAR Reserved3 : 2;
    UCHAR ReadRetryCount;
    UCHAR Reserved4[4];

} MODE_READ_RECOVERY_PAGE, *PMODE_READ_RECOVERY_PAGE;


//
// Define Informational Exception Control Page. Used for failure prediction
//

typedef struct _MODE_INFO_EXCEPTIONS
{
    UCHAR PageCode : 6;
    UCHAR Reserved1 : 1;
    UCHAR PSBit : 1;

    UCHAR PageLength;

    union
    {
        UCHAR Flags;
        struct
        {
            UCHAR LogErr : 1;
            UCHAR Reserved2 : 1;
            UCHAR Test : 1;
            UCHAR Dexcpt : 1;
            UCHAR Reserved3 : 3;
            UCHAR Perf : 1;
        };
    };
        
    UCHAR ReportMethod : 4;
    UCHAR Reserved4 : 4;

    UCHAR IntervalTimer[4];
    UCHAR ReportCount[4];

} MODE_INFO_EXCEPTIONS, *PMODE_INFO_EXCEPTIONS;

//
// Begin C/DVD 0.9 definitions
//

//
// Power Condition Mode Page Format
//

typedef struct _POWER_CONDITION_PAGE {
    UCHAR PageCode : 6;         // 0x1A
    UCHAR Reserved : 1;
    UCHAR PSBit : 1;
    UCHAR PageLength;           // 0x0A
    UCHAR Reserved2;

    UCHAR Standby : 1;
    UCHAR Idle : 1;
    UCHAR Reserved3 : 6;

    UCHAR IdleTimer[4];
    UCHAR StandbyTimer[4];
} POWER_CONDITION_PAGE, *PPOWER_CONDITION_PAGE;

//
// CD-Audio Control Mode Page Format
//

typedef struct _CDDA_OUTPUT_PORT {
    UCHAR ChannelSelection : 4;
    UCHAR Reserved : 4;
    UCHAR Volume;
} CDDA_OUTPUT_PORT, *PCDDA_OUTPUT_PORT;


typedef struct _CDAUDIO_CONTROL_PAGE {
    UCHAR PageCode : 6;     // 0x0E
    UCHAR Reserved : 1;
    UCHAR PSBit : 1;

    UCHAR PageLength;       // 0x0E

    UCHAR Reserved2 : 1;
    UCHAR StopOnTrackCrossing : 1;         // Default 0
    UCHAR Immediate : 1;    // Always 1
    UCHAR Reserved3 : 5;

    UCHAR Reserved4[3];
    UCHAR Obsolete[2];

    CDDA_OUTPUT_PORT CDDAOutputPorts[4];

} CDAUDIO_CONTROL_PAGE, *PCDAUDIO_CONTROL_PAGE;

#define CDDA_CHANNEL_MUTED      0x0
#define CDDA_CHANNEL_ZERO       0x1
#define CDDA_CHANNEL_ONE        0x2
#define CDDA_CHANNEL_TWO        0x4
#define CDDA_CHANNEL_THREE      0x8

//
// C/DVD Feature Set Support & Version Page
//

typedef struct _CDVD_FEATURE_SET_PAGE {
    UCHAR PageCode : 6;     // 0x18
    UCHAR Reserved : 1;
    UCHAR PSBit : 1;

    UCHAR PageLength;       // 0x16

    UCHAR CDAudio[2];
    UCHAR EmbeddedChanger[2];
    UCHAR PacketSMART[2];
    UCHAR PersistantPrevent[2];
    UCHAR EventStatusNotification[2];
    UCHAR DigitalOutput[2];
    UCHAR CDSequentialRecordable[2];
    UCHAR DVDSequentialRecordable[2];
    UCHAR RandomRecordable[2];
    UCHAR KeyExchange[2];
    UCHAR Reserved2[2];
} CDVD_FEATURE_SET_PAGE, *PCDVD_FEATURE_SET_PAGE;

//
// CDVD Inactivity Time-out Page Format
//

typedef struct _CDVD_INACTIVITY_TIMEOUT_PAGE {
    UCHAR PageCode : 6;     // 0x1D
    UCHAR Reserved : 1;
    UCHAR PSBit : 1;

    UCHAR PageLength;       // 0x08
    UCHAR Reserved2[2];

    UCHAR SWPP : 1;
    UCHAR DISP : 1;
    UCHAR Reserved3 : 6;

    UCHAR Reserved4;
    UCHAR GroupOneMinimumTimeout[2];
    UCHAR GroupTwoMinimumTimeout[2];
} CDVD_INACTIVITY_TIMEOUT_PAGE, *PCDVD_INACTIVITY_TIMEOUT_PAGE;

//
// CDVD Capabilities & Mechanism Status Page
//

#define CDVD_LMT_CADDY              0
#define CDVD_LMT_TRAY               1
#define CDVD_LMT_POPUP              2
#define CDVD_LMT_RESERVED1          3
#define CDVD_LMT_CHANGER_INDIVIDUAL 4
#define CDVD_LMT_CHANGER_CARTRIDGE  5
#define CDVD_LMT_RESERVED2          6
#define CDVD_LMT_RESERVED3          7


typedef struct _CDVD_CAPABILITIES_PAGE {
    UCHAR PageCode : 6;     // 0x2A
    UCHAR Reserved : 1;
    UCHAR PSBit : 1;                        // offset 0

    UCHAR PageLength;       // 0x18         // offset 1

    UCHAR CDRRead : 1;
    UCHAR CDERead : 1;
    UCHAR Method2 : 1;
    UCHAR DVDROMRead : 1;
    UCHAR DVDRRead : 1;
    UCHAR DVDRAMRead : 1;
    UCHAR Reserved2 : 2;                    // offset 2

    UCHAR CDRWrite : 1;
    UCHAR CDEWrite : 1;
    UCHAR TestWrite : 1;
    UCHAR Reserved3 : 1;
    UCHAR DVDRWrite : 1;
    UCHAR DVDRAMWrite : 1;
    UCHAR Reserved4 : 2;                    // offset 3

    UCHAR AudioPlay : 1;
    UCHAR Composite : 1;
    UCHAR DigitalPortOne : 1;
    UCHAR DigitalPortTwo : 1;
    UCHAR Mode2Form1 : 1;
    UCHAR Mode2Form2 : 1;
    UCHAR MultiSession : 1;
    UCHAR Reserved5 : 1;                    // offset 4

    UCHAR CDDA : 1;
    UCHAR CDDAAccurate : 1;
    UCHAR RWSupported : 1;
    UCHAR RWDeinterleaved : 1;
    UCHAR C2Pointers : 1;
    UCHAR ISRC : 1;
    UCHAR UPC : 1;
    UCHAR ReadBarCodeCapable : 1;           // offset 5

    UCHAR Lock : 1;
    UCHAR LockState : 1;
    UCHAR PreventJumper : 1;
    UCHAR Eject : 1;
    UCHAR Reserved6 : 1;
    UCHAR LoadingMechanismType : 3;         // offset 6

    UCHAR SeparateVolume : 1;
    UCHAR SeperateChannelMute : 1;
    UCHAR SupportsDiskPresent : 1;
    UCHAR SWSlotSelection : 1;
    UCHAR SideChangeCapable : 1;
    UCHAR RWInLeadInReadable : 1;
    UCHAR Reserved7 : 2;                    // offset 7

    UCHAR ObsoleteReserved[2];              // offset 8
    UCHAR NumberVolumeLevels[2];            // offset 10
    UCHAR BufferSize[2];                    // offset 12
    UCHAR ObsoleteReserved2[2];             // offset 14
    UCHAR ObsoleteReserved3;                // offset 16

    UCHAR Reserved8 : 1;
    UCHAR BCK : 1;
    UCHAR RCK : 1;
    UCHAR LSBF : 1;
    UCHAR Length : 2;
    UCHAR Reserved9 : 2;                    // offset 17

    UCHAR ObsoleteReserved4[2];             // offset 18
    UCHAR ObsoleteReserved11[2];            // offset 20

    //
    // NOTE: This mode page is two bytes too small in the release
    //       version of the Windows2000 DDK.  it also incorrectly
    //       put the CopyManagementRevision at offset 20 instead
    //       of offset 22, so fix that with a nameless union (for
    //       backwards-compatibility with those who "fixed" it on
    //       their own by looking at Reserved10[]).
    //

    union {
        UCHAR CopyManagementRevision[2];    // offset 22
        UCHAR Reserved10[2];
    };
    //UCHAR Reserved12[2];                    // offset 24

} CDVD_CAPABILITIES_PAGE, *PCDVD_CAPABILITIES_PAGE;


typedef struct _LUN_LIST {
    UCHAR LunListLength[4]; // sizeof LunSize * 8
    UCHAR Reserved[4];
    UCHAR Lun[0][8];        // 4 level of addressing.  2 bytes each.
} LUN_LIST, *PLUN_LIST;


#define LOADING_MECHANISM_CADDY                 0x00
#define LOADING_MECHANISM_TRAY                  0x01
#define LOADING_MECHANISM_POPUP                 0x02
#define LOADING_MECHANISM_INDIVIDUAL_CHANGER    0x04
#define LOADING_MECHANISM_CARTRIDGE_CHANGER     0x05

//
// end C/DVD 0.9 mode page definitions

//
// Mode parameter list block descriptor -
// set the block length for reading/writing
//
//

#define MODE_BLOCK_DESC_LENGTH               8
#define MODE_HEADER_LENGTH                   4
#define MODE_HEADER_LENGTH10                 8

typedef struct _MODE_PARM_READ_WRITE {

   MODE_PARAMETER_HEADER  ParameterListHeader;  // List Header Format
   MODE_PARAMETER_BLOCK   ParameterListBlock;   // List Block Descriptor

} MODE_PARM_READ_WRITE_DATA, *PMODE_PARM_READ_WRITE_DATA;


//
// Tape definitions
//

typedef struct _TAPE_POSITION_DATA {
    UCHAR Reserved1:2;
    UCHAR BlockPositionUnsupported:1;
    UCHAR Reserved2:3;
    UCHAR EndOfPartition:1;
    UCHAR BeginningOfPartition:1;
    UCHAR PartitionNumber;
    USHORT Reserved3;
    UCHAR FirstBlock[4];
    UCHAR LastBlock[4];
    UCHAR Reserved4;
    UCHAR NumberOfBlocks[3];
    UCHAR NumberOfBytes[4];
} TAPE_POSITION_DATA, *PTAPE_POSITION_DATA;

//
// This structure is used to convert little endian
// ULONGs to SCSI CDB big endians values.
//

typedef union _EIGHT_BYTE {

    struct {
        UCHAR Byte0;
        UCHAR Byte1;
        UCHAR Byte2;
        UCHAR Byte3;
        UCHAR Byte4;
        UCHAR Byte5;
        UCHAR Byte6;
        UCHAR Byte7;
    };

    ULONGLONG AsULongLong;
} EIGHT_BYTE, *PEIGHT_BYTE;

typedef union _FOUR_BYTE {

    struct {
        UCHAR Byte0;
        UCHAR Byte1;
        UCHAR Byte2;
        UCHAR Byte3;
    };

    ULONG AsULong;
} FOUR_BYTE, *PFOUR_BYTE;

typedef union _TWO_BYTE {

    struct {
        UCHAR Byte0;
        UCHAR Byte1;
    };

    USHORT AsUShort;
} TWO_BYTE, *PTWO_BYTE;

//
// Byte reversing macro for converting
// between big- and little-endian formats
//

#define REVERSE_BYTES_QUAD(Destination, Source) {           \
    PEIGHT_BYTE d = (PEIGHT_BYTE)(Destination);             \
    PEIGHT_BYTE s = (PEIGHT_BYTE)(Source);                  \
    d->Byte7 = s->Byte0;                                    \
    d->Byte6 = s->Byte1;                                    \
    d->Byte5 = s->Byte2;                                    \
    d->Byte4 = s->Byte3;                                    \
    d->Byte3 = s->Byte4;                                    \
    d->Byte2 = s->Byte5;                                    \
    d->Byte1 = s->Byte6;                                    \
    d->Byte0 = s->Byte7;                                    \
}

#define REVERSE_BYTES(Destination, Source) {                \
    PFOUR_BYTE d = (PFOUR_BYTE)(Destination);               \
    PFOUR_BYTE s = (PFOUR_BYTE)(Source);                    \
    d->Byte3 = s->Byte0;                                    \
    d->Byte2 = s->Byte1;                                    \
    d->Byte1 = s->Byte2;                                    \
    d->Byte0 = s->Byte3;                                    \
}

#define REVERSE_BYTES_SHORT(Destination, Source) {          \
    PTWO_BYTE d = (PTWO_BYTE)(Destination);                 \
    PTWO_BYTE s = (PTWO_BYTE)(Source);                      \
    d->Byte1 = s->Byte0;                                    \
    d->Byte0 = s->Byte1;                                    \
}

//
// Byte reversing macro for converting
// USHORTS from big to little endian in place
//

#define REVERSE_SHORT(Short) {          \
    UCHAR tmp;                          \
    PTWO_BYTE w = (PTWO_BYTE)(Short);   \
    tmp = w->Byte0;                     \
    w->Byte0 = w->Byte1;                \
    w->Byte1 = tmp;                     \
    }

//
// Byte reversing macro for convering
// ULONGS between big & little endian in place
//

#define REVERSE_LONG(Long) {            \
    UCHAR tmp;                          \
    PFOUR_BYTE l = (PFOUR_BYTE)(Long);  \
    tmp = l->Byte3;                     \
    l->Byte3 = l->Byte0;                \
    l->Byte0 = tmp;                     \
    tmp = l->Byte2;                     \
    l->Byte2 = l->Byte1;                \
    l->Byte1 = tmp;                     \
    }

//
// This macro has the effect of Bit = log2(Data)
//

#define WHICH_BIT(Data, Bit) {                      \
    UCHAR tmp;                                      \
    for (tmp = 0; tmp < 32; tmp++) {                \
        if (((Data) >> tmp) == 1) {                 \
            break;                                  \
        }                                           \
    }                                               \
    ASSERT(tmp != 32);                              \
    (Bit) = tmp;                                    \
}


#if defined DebugPrint
   #undef DebugPrint
#endif

#if DBG

#define DebugPrint(x) TapeDebugPrint x

#else

#define DebugPrint(x)

#endif // DBG

//
// Define Device Configuration Page
//

typedef struct _MODE_DEVICE_CONFIGURATION_PAGE {

    UCHAR PageCode : 6;
    UCHAR Reserved1 : 1;
    UCHAR PS : 1;
    UCHAR PageLength;
    UCHAR ActiveFormat : 5;
    UCHAR CAFBit : 1;
    UCHAR CAPBit : 1;
    UCHAR Reserved2 : 1;
    UCHAR ActivePartition;
    UCHAR WriteBufferFullRatio;
    UCHAR ReadBufferEmptyRatio;
    UCHAR WriteDelayTime[2];
    UCHAR REW : 1;
    UCHAR RBO : 1;
    UCHAR SOCF : 2;
    UCHAR AVC : 1;
    UCHAR RSmk : 1;
    UCHAR BIS : 1;
    UCHAR DBR : 1;
    UCHAR GapSize;
    UCHAR Reserved3 : 3;
    UCHAR SEW : 1;
    UCHAR EEG : 1;
    UCHAR EODdefined : 3;
    UCHAR BufferSize[3];
    UCHAR DCAlgorithm;
    UCHAR Reserved4;

} MODE_DEVICE_CONFIGURATION_PAGE, *PMODE_DEVICE_CONFIGURATION_PAGE;

//
// Define Medium Partition Page
//

typedef struct _MODE_MEDIUM_PARTITION_PAGE {

    UCHAR PageCode : 6;
    UCHAR Reserved1 : 1;
    UCHAR PSBit : 1;
    UCHAR PageLength;
    UCHAR MaximumAdditionalPartitions;
    UCHAR AdditionalPartitionDefined;
    UCHAR Reserved2 : 3;
    UCHAR PSUMBit : 2;
    UCHAR IDPBit : 1;
    UCHAR SDPBit : 1;
    UCHAR FDPBit : 1;
    UCHAR MediumFormatRecognition;
    UCHAR Reserved3[2];
    UCHAR Partition0Size[2];
    UCHAR Partition1Size[2];

} MODE_MEDIUM_PARTITION_PAGE, *PMODE_MEDIUM_PARTITION_PAGE;

//
// Define Data Compression Page
//

typedef struct _MODE_DATA_COMPRESSION_PAGE {

    UCHAR PageCode : 6;
    UCHAR Reserved1 : 2;
    UCHAR PageLength;
    UCHAR Reserved2 : 6;
    UCHAR DCC : 1;
    UCHAR DCE : 1;
    UCHAR Reserved3 : 5;
    UCHAR RED : 2;
    UCHAR DDE : 1;
    UCHAR CompressionAlgorithm[4];
    UCHAR DecompressionAlgorithm[4];
    UCHAR Reserved4[4];

} MODE_DATA_COMPRESSION_PAGE, *PMODE_DATA_COMPRESSION_PAGE;

//
// Define capabilites and mechanical status page.
//

typedef struct _MODE_CAPABILITIES_PAGE {

    UCHAR PageCode : 6;
    UCHAR Reserved1 : 2;
    UCHAR PageLength;
    UCHAR Reserved2[2];
    UCHAR RO : 1;
    UCHAR Reserved3 : 4;
    UCHAR SPREV : 1;
    UCHAR Reserved4 : 2;
    UCHAR Reserved5 : 3;
    UCHAR EFMT : 1;
    UCHAR Reserved6 : 1;
    UCHAR QFA : 1;
    UCHAR Reserved7 : 2;
    UCHAR LOCK : 1;
    UCHAR LOCKED : 1;
    UCHAR PREVENT : 1;
    UCHAR UNLOAD : 1;
    UCHAR Reserved8 : 2;
    UCHAR ECC : 1;
    UCHAR CMPRS : 1;
    UCHAR Reserved9 : 1;
    UCHAR BLK512 : 1;
    UCHAR BLK1024 : 1;
    UCHAR Reserved10 : 4;
    UCHAR SLOWB : 1;
    UCHAR MaximumSpeedSupported[2];
    UCHAR MaximumStoredDefectedListEntries[2];
    UCHAR ContinuousTransferLimit[2];
    UCHAR CurrentSpeedSelected[2];
    UCHAR BufferSize[2];
    UCHAR Reserved11[2];

} MODE_CAPABILITIES_PAGE, *PMODE_CAPABILITIES_PAGE;

typedef struct _MODE_CAP_PAGE {

    MODE_PARAMETER_HEADER   ParameterListHeader;
    MODE_PARAMETER_BLOCK    ParameterListBlock;
    MODE_CAPABILITIES_PAGE  CapabilitiesPage;

} MODE_CAP_PAGE, *PMODE_CAP_PAGE;



//
// Mode parameter list header and medium partition page -
// used in creating partitions
//

typedef struct _MODE_MEDIUM_PART_PAGE {

   MODE_PARAMETER_HEADER       ParameterListHeader;
   MODE_MEDIUM_PARTITION_PAGE  MediumPartPage;

} MODE_MEDIUM_PART_PAGE, *PMODE_MEDIUM_PART_PAGE;

typedef struct _MODE_MEDIUM_PART_PAGE_PLUS {

    MODE_PARAMETER_HEADER       ParameterListHeader;
    MODE_PARAMETER_BLOCK        ParameterListBlock;
    MODE_MEDIUM_PARTITION_PAGE  MediumPartPage;

} MODE_MEDIUM_PART_PAGE_PLUS, *PMODE_MEDIUM_PART_PAGE_PLUS;



//
// Mode parameters for retrieving tape or media information
//

typedef struct _MODE_TAPE_MEDIA_INFORMATION {

   MODE_PARAMETER_HEADER       ParameterListHeader;
   MODE_PARAMETER_BLOCK        ParameterListBlock;
   MODE_MEDIUM_PARTITION_PAGE  MediumPartPage;

} MODE_TAPE_MEDIA_INFORMATION, *PMODE_TAPE_MEDIA_INFORMATION;

//
// Mode parameter list header and device configuration page -
// used in retrieving device configuration information
//

typedef struct _MODE_DEVICE_CONFIG_PAGE {

   MODE_PARAMETER_HEADER       ParameterListHeader;
   MODE_DEVICE_CONFIGURATION_PAGE  DeviceConfigPage;

} MODE_DEVICE_CONFIG_PAGE, *PMODE_DEVICE_CONFIG_PAGE;

typedef struct _MODE_DEVICE_CONFIG_PAGE_PLUS {

   MODE_PARAMETER_HEADER       ParameterListHeader;
   MODE_PARAMETER_BLOCK        ParameterListBlock;
   MODE_DEVICE_CONFIGURATION_PAGE  DeviceConfigPage;

} MODE_DEVICE_CONFIG_PAGE_PLUS, *PMODE_DEVICE_CONFIG_PAGE_PLUS ;

//
// Mode parameter list header and data compression page -
// used in retrieving data compression information
//

typedef struct _MODE_DATA_COMPRESS_PAGE {

   MODE_PARAMETER_HEADER       ParameterListHeader;
   MODE_DATA_COMPRESSION_PAGE  DataCompressPage;

} MODE_DATA_COMPRESS_PAGE, *PMODE_DATA_COMPRESS_PAGE;

typedef struct _MODE_DATA_COMPRESS_PAGE_PLUS {

   MODE_PARAMETER_HEADER       ParameterListHeader;
   MODE_PARAMETER_BLOCK        ParameterListBlock;
   MODE_DATA_COMPRESSION_PAGE  DataCompressPage;

} MODE_DATA_COMPRESS_PAGE_PLUS, *PMODE_DATA_COMPRESS_PAGE_PLUS;



//
// Tape/Minitape definition.
//

typedef
BOOLEAN
(*TAPE_VERIFY_INQUIRY_ROUTINE)(
    IN  PINQUIRYDATA            InquiryData,
    IN  PMODE_CAPABILITIES_PAGE ModeCapabilitiesPage
    );

typedef
VOID
(*TAPE_EXTENSION_INIT_ROUTINE)(
    IN  PVOID                   MinitapeExtension,
    IN  PINQUIRYDATA            InquiryData,
    IN  PMODE_CAPABILITIES_PAGE ModeCapabilitiesPage
    );

typedef enum _TAPE_STATUS {
    TAPE_STATUS_SEND_SRB_AND_CALLBACK,
    TAPE_STATUS_CALLBACK,
    TAPE_STATUS_CHECK_TEST_UNIT_READY,

    TAPE_STATUS_SUCCESS,
    TAPE_STATUS_INSUFFICIENT_RESOURCES,
    TAPE_STATUS_NOT_IMPLEMENTED,
    TAPE_STATUS_INVALID_DEVICE_REQUEST,
    TAPE_STATUS_INVALID_PARAMETER,

    TAPE_STATUS_MEDIA_CHANGED,
    TAPE_STATUS_BUS_RESET,
    TAPE_STATUS_SETMARK_DETECTED,
    TAPE_STATUS_FILEMARK_DETECTED,
    TAPE_STATUS_BEGINNING_OF_MEDIA,
    TAPE_STATUS_END_OF_MEDIA,
    TAPE_STATUS_BUFFER_OVERFLOW,
    TAPE_STATUS_NO_DATA_DETECTED,
    TAPE_STATUS_EOM_OVERFLOW,
    TAPE_STATUS_NO_MEDIA,
    TAPE_STATUS_IO_DEVICE_ERROR,
    TAPE_STATUS_UNRECOGNIZED_MEDIA,

    TAPE_STATUS_DEVICE_NOT_READY,
    TAPE_STATUS_MEDIA_WRITE_PROTECTED,
    TAPE_STATUS_DEVICE_DATA_ERROR,
    TAPE_STATUS_NO_SUCH_DEVICE,
    TAPE_STATUS_INVALID_BLOCK_LENGTH,
    TAPE_STATUS_IO_TIMEOUT,
    TAPE_STATUS_DEVICE_NOT_CONNECTED,
    TAPE_STATUS_DATA_OVERRUN,
    TAPE_STATUS_DEVICE_BUSY,
    TAPE_STATUS_REQUIRES_CLEANING,
    TAPE_STATUS_CLEANER_CARTRIDGE_INSTALLED

} TAPE_STATUS, *PTAPE_STATUS;

typedef
VOID
(*TAPE_ERROR_ROUTINE)(
    IN      PVOID               MinitapeExtension,
    IN      PSCSI_REQUEST_BLOCK Srb,
    IN OUT  PTAPE_STATUS        TapeStatus
    );

#define TAPE_RETRY_MASK 0x0000FFFF
#define IGNORE_ERRORS   0x00010000
#define RETURN_ERRORS   0x00020000

typedef
TAPE_STATUS
(*TAPE_PROCESS_COMMAND_ROUTINE)(
    IN OUT  PVOID               MinitapeExtension,
    IN OUT  PVOID               CommandExtension,
    IN OUT  PVOID               CommandParameters,
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               CallNumber,
    IN      TAPE_STATUS         StatusOfLastCommand,
    IN OUT  PULONG              RetryFlags
    );

//
// NT 4.0 miniclass drivers will be using this.
//

typedef struct _TAPE_INIT_DATA {
    TAPE_VERIFY_INQUIRY_ROUTINE     VerifyInquiry;
    BOOLEAN                         QueryModeCapabilitiesPage ;
    ULONG                           MinitapeExtensionSize;
    TAPE_EXTENSION_INIT_ROUTINE     ExtensionInit;          /* OPTIONAL */
    ULONG                           DefaultTimeOutValue;    /* OPTIONAL */
    TAPE_ERROR_ROUTINE              TapeError;              /* OPTIONAL */
    ULONG                           CommandExtensionSize;
    TAPE_PROCESS_COMMAND_ROUTINE    CreatePartition;
    TAPE_PROCESS_COMMAND_ROUTINE    Erase;
    TAPE_PROCESS_COMMAND_ROUTINE    GetDriveParameters;
    TAPE_PROCESS_COMMAND_ROUTINE    GetMediaParameters;
    TAPE_PROCESS_COMMAND_ROUTINE    GetPosition;
    TAPE_PROCESS_COMMAND_ROUTINE    GetStatus;
    TAPE_PROCESS_COMMAND_ROUTINE    Prepare;
    TAPE_PROCESS_COMMAND_ROUTINE    SetDriveParameters;
    TAPE_PROCESS_COMMAND_ROUTINE    SetMediaParameters;
    TAPE_PROCESS_COMMAND_ROUTINE    SetPosition;
    TAPE_PROCESS_COMMAND_ROUTINE    WriteMarks;
    TAPE_PROCESS_COMMAND_ROUTINE    PreProcessReadWrite;
} TAPE_INIT_DATA, *PTAPE_INIT_DATA;

typedef struct _TAPE_INIT_DATA_EX {

    //
    // Size of this structure.
    //

    ULONG InitDataSize;

    //
    // Keep the 4.0 init data as is, so support of these
    // drivers can be as seamless as possible.
    //

    TAPE_VERIFY_INQUIRY_ROUTINE     VerifyInquiry;
    BOOLEAN                         QueryModeCapabilitiesPage ;
    ULONG                           MinitapeExtensionSize;
    TAPE_EXTENSION_INIT_ROUTINE     ExtensionInit;          /* OPTIONAL */
    ULONG                           DefaultTimeOutValue;    /* OPTIONAL */
    TAPE_ERROR_ROUTINE              TapeError;              /* OPTIONAL */
    ULONG                           CommandExtensionSize;
    TAPE_PROCESS_COMMAND_ROUTINE    CreatePartition;
    TAPE_PROCESS_COMMAND_ROUTINE    Erase;
    TAPE_PROCESS_COMMAND_ROUTINE    GetDriveParameters;
    TAPE_PROCESS_COMMAND_ROUTINE    GetMediaParameters;
    TAPE_PROCESS_COMMAND_ROUTINE    GetPosition;
    TAPE_PROCESS_COMMAND_ROUTINE    GetStatus;
    TAPE_PROCESS_COMMAND_ROUTINE    Prepare;
    TAPE_PROCESS_COMMAND_ROUTINE    SetDriveParameters;
    TAPE_PROCESS_COMMAND_ROUTINE    SetMediaParameters;
    TAPE_PROCESS_COMMAND_ROUTINE    SetPosition;
    TAPE_PROCESS_COMMAND_ROUTINE    WriteMarks;
    TAPE_PROCESS_COMMAND_ROUTINE    PreProcessReadWrite;

    //
    // New entry points / information for 5.0
    //
    // Returns supported media types for the device.
    //

    TAPE_PROCESS_COMMAND_ROUTINE    TapeGetMediaTypes;

    //
    // Indicates the number of different types the drive supports.
    //

    ULONG                           MediaTypesSupported;

    //
    // Entry point for all WMI operations that the driver/device supports.
    //

    TAPE_PROCESS_COMMAND_ROUTINE    TapeWMIOperations;
    ULONG                           Reserved[2];
} TAPE_INIT_DATA_EX, *PTAPE_INIT_DATA_EX;

SCSIPORT_API
ULONG
TapeClassInitialize(
    IN  PVOID           Argument1,
    IN  PVOID           Argument2,
    IN  PTAPE_INIT_DATA_EX TapeInitData
    );

SCSIPORT_API
BOOLEAN
TapeClassAllocateSrbBuffer(
    IN OUT  PSCSI_REQUEST_BLOCK Srb,
    IN      ULONG               SrbBufferSize
    );

SCSIPORT_API
VOID
TapeClassZeroMemory(
    IN OUT  PVOID   Buffer,
    IN      ULONG   BufferSize
    );

SCSIPORT_API
ULONG
TapeClassCompareMemory(
    IN OUT  PVOID   Source1,
    IN OUT  PVOID   Source2,
    IN      ULONG   Length
    );

SCSIPORT_API
LARGE_INTEGER
TapeClassLiDiv(
    IN LARGE_INTEGER Dividend,
    IN LARGE_INTEGER Divisor
    );

SCSIPORT_API
VOID
TapeDebugPrint(
    ULONG DebugPrintLevel,
    PCCHAR DebugMessage,
    ...
    );


//
// defines for QIC tape density codes
//

#define QIC_XX     0   // ????
#define QIC_24     5   // 0x05
#define QIC_120    15  // 0x0F
#define QIC_150    16  // 0x10
#define QIC_525    17  // 0x11
#define QIC_1350   18  // 0x12
#define QIC_1000   21  // 0x15
#define QIC_1000C  30  // 0x1E
#define QIC_2100   31  // 0x1F
#define QIC_2GB    34  // 0x22
#define QIC_5GB    40  // 0x28

//
// defines for QIC tape media codes
//

#define DCXXXX   0
#define DC300    1
#define DC300XLP 2
#define DC615    3
#define DC600    4
#define DC6037   5
#define DC6150   6
#define DC6250   7
#define DC6320   8
#define DC6525   9
#define DC9135SL 33  //0x21
#define DC9210   34  //0x22
#define DC9135   35  //0x23
#define DC9100   36  //0x24
#define DC9120   37  //0x25
#define DC9120SL 38  //0x26
#define DC9164   39  //0x27
#define DCXXXXFW 48  //0x30
#define DC9200SL 49  //0x31
#define DC9210XL 50  //0x32
#define DC10GB   51  //0x33
#define DC9200   52  //0x34
#define DC9120XL 53  //0x35
#define DC9210SL 54  //0x36
#define DC9164XL 55  //0x37
#define DC9200XL 64  //0x40
#define DC9400   65  //0x41
#define DC9500   66  //0x42
#define DC9500SL 70  //0x46

//
// defines for translation reference point
//

#define NOT_FROM_BOT 0
#define FROM_BOT 1

//
// info/structure returned by/from
// TapeLogicalBlockToPhysicalBlock( )
//

typedef struct _TAPE_PHYS_POSITION {
    ULONG SeekBlockAddress;
    ULONG SpaceBlockCount;
} TAPE_PHYS_POSITION, PTAPE_PHYS_POSITION;

//
// function prototypes
//

TAPE_PHYS_POSITION
TapeClassLogicalBlockToPhysicalBlock(
    IN UCHAR DensityCode,
    IN ULONG LogicalBlockAddress,
    IN ULONG BlockLength,
    IN BOOLEAN FromBOT
    );

ULONG
TapeClassPhysicalBlockToLogicalBlock(
    IN UCHAR DensityCode,
    IN ULONG PhysicalBlockAddress,
    IN ULONG BlockLength,
    IN BOOLEAN FromBOT
    );


//
// LOG SENSE Page codes
//
#define TapeAlertLogPage  0x2E

//
// Type of tape drive alert information
// supported by the drive.
// For example, if the type is TapeAlertInfoNone, the drive doesn't
// support any alert info. Need to use read\write error counters
// to predict drive problems. If the type is TapeAlertInfoRequestSense,
// request sense command can be used to determine drive problems.
//
typedef enum _TAPE_ALERT_INFO_TYPE { 
   TapeAlertInfoNone,        
   TapeAlertInfoRequestSense,
   TapeAlertInfoLogPage   
} TAPE_ALERT_INFO_TYPE;

//
// Tape alert information
//
#define READ_WARNING            1
#define WRITE_WARNING           2
#define HARD_ERROR              3 
#define MEDIA_ERROR             4
#define READ_FAILURE            5
#define WRITE_FAILURE           6
#define MEDIA_LIFE              7
#define NOT_DATA_GRADE          8
#define WRITE_PROTECT           9
#define NO_REMOVAL              10
#define CLEANING_MEDIA          11
#define UNSUPPORTED_FORMAT      12
#define SNAPPED_TAPE            13
#define CLEAN_NOW               20
#define CLEAN_PERIODIC          21
#define EXPIRED_CLEANING_MEDIA  22
#define HARDWARE_A              30
#define HARDWARE_B              31
#define INTERFACE_ERROR         32
#define EJECT_MEDIA             33
#define DOWNLOAD_FAIL           34

//
// The following structs are duplicated from wmidata.h
// wmidata.h is generated from wmicore.mof file. Should
// the MOF file change for these structs, the corresponding
// change should be made in these structs also. 
// Since minidrivers do not have access wmidata.h, we need
// to duplicate it here.
//
// ISSUE : 02/28/2000 - nramas : Should find a better way to
// handle the above. Duplication will cause problems in keeping
// these definitions in sync.
//
typedef struct _WMI_TAPE_DRIVE_PARAMETERS
{
    // Maximum block size supported
    ULONG MaximumBlockSize;

    // Minimum block size supported
    ULONG MinimumBlockSize;
    
    // Default block size supported
    ULONG DefaultBlockSize;

    // Maximum number of partitions allowed.
    ULONG MaximumPartitionCount;

    // TRUE if drive supports compression.
    BOOLEAN CompressionCapable;

    // TRUE if compression is enabled.
    BOOLEAN CompressionEnabled;

    // TRUE if drive reports setmarks
    BOOLEAN ReportSetmarks;

    // TRUE if drive supports hardware error correction
    BOOLEAN HardwareErrorCorrection;
} WMI_TAPE_DRIVE_PARAMETERS, *PWMI_TAPE_DRIVE_PARAMETERS;

typedef struct _WMI_TAPE_MEDIA_PARAMETERS
{
    // Maximum capacity of the media
    ULONGLONG MaximumCapacity;

    // Available capacity of the media
    ULONGLONG AvailableCapacity;

    // Current blocksize
    ULONG BlockSize;

    // Current number of partitions
    ULONG PartitionCount;

    // TRUEif media is write protected
    BOOLEAN MediaWriteProtected;
} WMI_TAPE_MEDIA_PARAMETERS, *PWMI_TAPE_MEDIA_PARAMETERS;


typedef struct _WMI_TAPE_PROBLEM_WARNING
{
    // Tape drive problem warning event
    ULONG DriveProblemType;

    // Tape drive problem data
    UCHAR TapeData[512];
} WMI_TAPE_PROBLEM_WARNING, *PWMI_TAPE_PROBLEM_WARNING;

typedef struct _WMI_TAPE_PROBLEM_IO_ERROR
{
    // Read errors corrected without much delay
    ULONG ReadCorrectedWithoutDelay;

    // Read errors corrected with substantial delay
    ULONG ReadCorrectedWithDelay;

    // Total number of Read errors
    ULONG ReadTotalErrors;

    // Total number of read errors that were corrected
    ULONG ReadTotalCorrectedErrors;

    // Total number of uncorrected read errors
    ULONG ReadTotalUncorrectedErrors;

    // Number of times correction algorithm was processed for read
    ULONG ReadCorrectionAlgorithmProcessed;

    // Write errors corrected without much delay
    ULONG WriteCorrectedWithoutDelay;

    // Write errors corrected with substantial delay
    ULONG WriteCorrectedWithDelay;

    // Total number of Read errors
    ULONG WriteTotalErrors;

    // Total number of write errors that were corrected
    ULONG WriteTotalCorrectedErrors;

    // Total number of uncorrected write errors
    ULONG WriteTotalUncorrectedErrors;

    // Number of times correction algorithm was processed for write
    ULONG WriteCorrectionAlgorithmProcessed;

    // Errors not related to medium
    ULONG NonMediumErrors;
} WMI_TAPE_PROBLEM_IO_ERROR, *PWMI_TAPE_PROBLEM_IO_ERROR;

typedef struct _WMI_TAPE_PROBLEM_DEVICE_ERROR
{

   // WARNING : Drive is experiencing read problem.
   BOOLEAN ReadWarning;
   
   // WARNING : Drive is experiencing write problem.
   BOOLEAN WriteWarning;

   // Drive hardware problem
   BOOLEAN HardError;

   // Critical Error : Too many read errors.
   BOOLEAN ReadFailure;

   // Critical Error : Too many write errors.
   BOOLEAN WriteFailure;

   // Tape format not supported
   BOOLEAN UnsupportedFormat;

   // Tape is snapped. Replace media
   BOOLEAN TapeSnapped;

   // Drive Requires Cleaning
   BOOLEAN DriveRequiresCleaning;

   // It's time to clean the drive
   BOOLEAN TimetoCleanDrive;

   // Hardware error. Check drive
   BOOLEAN DriveHardwareError;

   // Some error in cabling, or connection.
   BOOLEAN ScsiInterfaceError;

   // Critical Error : Media life expired. 
   BOOLEAN MediaLife;
} WMI_TAPE_PROBLEM_DEVICE_ERROR, *PWMI_TAPE_PROBLEM_DEVICE_ERROR;


#endif /* _MINITAPE_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\ddk\inc\mountdev.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    mountdev.h

Abstract:

    This file defines the private interfaces between the mount point manager
    and the mounted devices.

Author:

    norbertk

Revision History:

--*/

#ifndef _MOUNTDEV_
#define _MOUNTDEV_

#include <mountmgr.h>

#define IOCTL_MOUNTDEV_QUERY_UNIQUE_ID              CTL_CODE(MOUNTDEVCONTROLTYPE, 0, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_MOUNTDEV_UNIQUE_ID_CHANGE_NOTIFY      CTL_CODE(MOUNTDEVCONTROLTYPE, 1, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_MOUNTDEV_QUERY_SUGGESTED_LINK_NAME    CTL_CODE(MOUNTDEVCONTROLTYPE, 3, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_MOUNTDEV_LINK_CREATED                 CTL_CODE(MOUNTDEVCONTROLTYPE, 4, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_MOUNTDEV_LINK_DELETED                 CTL_CODE(MOUNTDEVCONTROLTYPE, 5, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_MOUNTDEV_QUERY_STABLE_GUID            CTL_CODE(MOUNTDEVCONTROLTYPE, 6, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
// Output structure for IOCTL_MOUNTDEV_QUERY_UNIQUE_ID.
// Input structure for IOCTL_MOUNTDEV_UNIQUE_ID_CHANGE_NOTIFY.
//

typedef struct _MOUNTDEV_UNIQUE_ID {
    USHORT  UniqueIdLength;
    UCHAR   UniqueId[1];
} MOUNTDEV_UNIQUE_ID, *PMOUNTDEV_UNIQUE_ID;

//
// Output structure for IOCTL_MOUNTDEV_UNIQUE_ID_CHANGE_NOTIFY.
//

typedef struct _MOUNTDEV_UNIQUE_ID_CHANGE_NOTIFY_OUTPUT {
    ULONG   Size;
    USHORT  OldUniqueIdOffset;
    USHORT  OldUniqueIdLength;
    USHORT  NewUniqueIdOffset;
    USHORT  NewUniqueIdLength;
} MOUNTDEV_UNIQUE_ID_CHANGE_NOTIFY_OUTPUT, *PMOUNTDEV_UNIQUE_ID_CHANGE_NOTIFY_OUTPUT;

//
// MOUNTDEV_NAME
//
// Input structure for IOCTL_MOUNTDEV_LINK_CREATED.
// Input structure for IOCTL_MOUNTDEV_LINK_DELETED.
//

//
// Output structure for IOCTL_MOUNTDEV_QUERY_SUGGESTED_LINK_NAME
//

typedef struct _MOUNTDEV_SUGGESTED_LINK_NAME {
    BOOLEAN UseOnlyIfThereAreNoOtherLinks;
    USHORT  NameLength;
    WCHAR   Name[1];
} MOUNTDEV_SUGGESTED_LINK_NAME, *PMOUNTDEV_SUGGESTED_LINK_NAME;

//
// Output structure for IOCTL_MOUNTDEV_QUERY_STABLE_GUID.
//

typedef struct _MOUNTDEV_STABLE_GUID {
    GUID    StableGuid;
} MOUNTDEV_STABLE_GUID, *PMOUNTDEV_STABLE_GUID;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\ddk\inc\msacmdrv.h ===
//==========================================================================;
//
//  msacmdrv.h
//
//  Copyright (c) 1992-1999 Microsoft Corporation.  All Rights Reserved.
//
//  Description:
//      Audio Compression Manager Public Header File for Drivers
//
//  History:
//
//==========================================================================;

#ifndef _INC_ACMDRV
#define _INC_ACMDRV         /* #defined if msacmdrv.h has been included */

#if _MSC_VER > 1000
#pragma once
#endif

#if !defined(_INC_ACM)
#ifndef RC_INVOKED
#error MSACM.H to be included first
#endif
#endif

#include "pshpack1.h"   /* Assume byte packing throughout */

#ifdef __cplusplus
extern "C" {                /* Assume C declarations for C++ */
#endif  /* __cplusplus */


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  ACM Driver Version:
//
//  the version is a 32 bit number that is broken into three parts as
//  follows:
//
//      bits 24 - 31:   8 bit _major_ version number
//      bits 16 - 23:   8 bit _minor_ version number
//      bits  0 - 15:   16 bit build number
//
//  this is then displayed as follows:
//
//      bMajor = (BYTE)(dwVersion >> 24)
//      bMinor = (BYTE)(dwVersion >> 16) &
//      wBuild = LOWORD(dwVersion)
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#define MAKE_ACM_VERSION(mjr, mnr, bld) (((long)(mjr)<<24)| \
                                         ((long)(mnr)<<16)| \
                                         ((long)bld))


#ifdef WIN32
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  under WIN32 all drivers use unicode structures.  these have already
//  been #defined in MSACM.H.  however, regardless of whether UNICODE is
//  defined, we will define these structures as unicode structures for use
//  in 32-bit drivers.
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#undef ACMDRIVERDETAILS
#undef PACMDRIVERDETAILS
#undef LPACMDRIVERDETAILS

#undef ACMFORMATTAGDETAILS
#undef PACMFORMATTAGDETAILS
#undef LPACMFORMATTAGDETAILS

#undef ACMFORMATDETAILS
#undef PACMFORMATDETAILS
#undef LPACMFORMATDETAILS

#undef ACMFORMATCHOOSE
#undef PACMFORMATCHOOSE
#undef LPACMFORMATCHOOSE

#undef ACMFILTERTAGDETAILS
#undef PACMFILTERTAGDETAILS
#undef LPACMFILTERTAGDETAILS

#undef ACMFILTERDETAILS
#undef PACMFILTERDETAILS
#undef LPACMFILTERDETAILS

#undef ACMFILTERCHOOSE
#undef PACMFILTERCHOOSE
#undef LPACMFILTERCHOOSE

#define ACMDRIVERDETAILS        ACMDRIVERDETAILSW
#define PACMDRIVERDETAILS       PACMDRIVERDETAILSW
#define LPACMDRIVERDETAILS      LPACMDRIVERDETAILSW

#define ACMFORMATTAGDETAILS     ACMFORMATTAGDETAILSW
#define PACMFORMATTAGDETAILS    PACMFORMATTAGDETAILSW
#define LPACMFORMATTAGDETAILS   LPACMFORMATTAGDETAILSW

#define ACMFORMATDETAILS	ACMFORMATDETAILSW
#define PACMFORMATDETAILS	PACMFORMATDETAILSW
#define LPACMFORMATDETAILS	LPACMFORMATDETAILSW

#define ACMFORMATCHOOSE		ACMFORMATCHOOSEW
#define PACMFORMATCHOOSE	PACMFORMATCHOOSEW
#define LPACMFORMATCHOOSE	LPACMFORMATCHOOSEW

#define ACMFILTERTAGDETAILS     ACMFILTERTAGDETAILSW
#define PACMFILTERTAGDETAILS    PACMFILTERTAGDETAILSW
#define LPACMFILTERTAGDETAILS   LPACMFILTERTAGDETAILSW

#define ACMFILTERDETAILS	ACMFILTERDETAILSW
#define PACMFILTERDETAILS	PACMFILTERDETAILSW
#define LPACMFILTERDETAILS	LPACMFILTERDETAILSW

#define ACMFILTERCHOOSE		ACMFILTERCHOOSEW
#define PACMFILTERCHOOSE	PACMFILTERCHOOSEW
#define LPACMFILTERCHOOSE	LPACMFILTERCHOOSEW

#endif

//
//
//
//
//
#define ACMDRVOPENDESC_SECTIONNAME_CHARS

#ifdef _WIN32
typedef struct tACMDRVOPENDESCA
{
    DWORD           cbStruct;       // sizeof(ACMDRVOPENDESC)
    FOURCC          fccType;        // 'audc'
    FOURCC          fccComp;        // sub-type (not used--must be 0)
    DWORD           dwVersion;      // current version of ACM opening you
    DWORD           dwFlags;        //
    DWORD           dwError;        // result from DRV_OPEN request
    LPCSTR          pszSectionName; // see DRVCONFIGINFO.lpszDCISectionName
    LPCSTR          pszAliasName;   // see DRVCONFIGINFO.lpszDCIAliasName
    DWORD	    dnDevNode;	    // devnode id for pnp drivers.

} ACMDRVOPENDESCA, *PACMDRVOPENDESCA, FAR *LPACMDRVOPENDESCA;

typedef struct tACMDRVOPENDESCW
{
    DWORD           cbStruct;       // sizeof(ACMDRVOPENDESC)
    FOURCC          fccType;        // 'audc'
    FOURCC          fccComp;        // sub-type (not used--must be 0)
    DWORD           dwVersion;      // current version of ACM opening you
    DWORD           dwFlags;        //
    DWORD           dwError;        // result from DRV_OPEN request
    LPCWSTR         pszSectionName; // see DRVCONFIGINFO.lpszDCISectionName
    LPCWSTR         pszAliasName;   // see DRVCONFIGINFO.lpszDCIAliasName
    DWORD	    dnDevNode;	    // devnode id for pnp drivers.

} ACMDRVOPENDESCW, *PACMDRVOPENDESCW, FAR *LPACMDRVOPENDESCW;

#define ACMDRVOPENDESC      ACMDRVOPENDESCW
#define PACMDRVOPENDESC     PACMDRVOPENDESCW
#define LPACMDRVOPENDESC    LPACMDRVOPENDESCW
#else
typedef struct tACMDRVOPENDESC
{
    DWORD           cbStruct;       // sizeof(ACMDRVOPENDESC)
    FOURCC          fccType;        // 'audc'
    FOURCC          fccComp;        // sub-type (not used--must be 0)
    DWORD           dwVersion;      // current version of ACM opening you
    DWORD           dwFlags;        //
    DWORD           dwError;        // result from DRV_OPEN request
    LPCSTR          pszSectionName; // see DRVCONFIGINFO.lpszDCISectionName
    LPCSTR          pszAliasName;   // see DRVCONFIGINFO.lpszDCIAliasName
    DWORD	    dnDevNode;	    // devnode id for pnp drivers.

} ACMDRVOPENDESC, *PACMDRVOPENDESC, FAR *LPACMDRVOPENDESC;
#endif


//
//
//
//
//
typedef struct tACMDRVSTREAMINSTANCE
{
    DWORD               cbStruct;
    LPWAVEFORMATEX      pwfxSrc;
    LPWAVEFORMATEX      pwfxDst;
    LPWAVEFILTER        pwfltr;
    DWORD_PTR           dwCallback;
    DWORD_PTR           dwInstance;
    DWORD               fdwOpen;
    DWORD               fdwDriver;
    DWORD_PTR           dwDriver;
    HACMSTREAM          has;

} ACMDRVSTREAMINSTANCE, *PACMDRVSTREAMINSTANCE, FAR *LPACMDRVSTREAMINSTANCE;


//
//  NOTE! this structure must match the ACMSTREAMHEADER in msacm.h but
//  defines more information for the driver writing convenience
//
typedef struct tACMDRVSTREAMHEADER FAR *LPACMDRVSTREAMHEADER;
typedef struct tACMDRVSTREAMHEADER
{
    DWORD                   cbStruct;
    DWORD                   fdwStatus;
    DWORD_PTR               dwUser;
    LPBYTE                  pbSrc;
    DWORD                   cbSrcLength;
    DWORD                   cbSrcLengthUsed;
    DWORD_PTR               dwSrcUser;
    LPBYTE                  pbDst;
    DWORD                   cbDstLength;
    DWORD                   cbDstLengthUsed;
    DWORD_PTR               dwDstUser;

    DWORD                   fdwConvert;     // flags passed from convert func
    LPACMDRVSTREAMHEADER    padshNext;      // for async driver queueing
    DWORD                   fdwDriver;      // driver instance flags
    DWORD_PTR               dwDriver;       // driver instance data

    //
    //  all remaining fields are used by the ACM for bookkeeping purposes.
    //  an ACM driver should never use these fields (though than can be
    //  helpful for debugging)--note that the meaning of these fields
    //  may change, so do NOT rely on them in shipping code.
    //
    DWORD                   fdwPrepared;
    DWORD_PTR               dwPrepared;
    LPBYTE                  pbPreparedSrc;
    DWORD                   cbPreparedSrcLength;
    LPBYTE                  pbPreparedDst;
    DWORD                   cbPreparedDstLength;

} ACMDRVSTREAMHEADER, *PACMDRVSTREAMHEADER;


//
//  structure for ACMDM_STREAM_SIZE message
//
//
typedef struct tACMDRVSTREAMSIZE
{
    DWORD               cbStruct;
    DWORD               fdwSize;
    DWORD               cbSrcLength;
    DWORD               cbDstLength;

} ACMDRVSTREAMSIZE, *PACMDRVSTREAMSIZE, FAR *LPACMDRVSTREAMSIZE;



//
//  structure containing the information for the ACMDM_FORMAT_SUGGEST message
//
//
typedef struct tACMDRVFORMATSUGGEST
{
    DWORD               cbStruct;           // sizeof(ACMDRVFORMATSUGGEST)
    DWORD               fdwSuggest;         // Suggest flags
    LPWAVEFORMATEX      pwfxSrc;            // Source Format
    DWORD               cbwfxSrc;           // Source Size
    LPWAVEFORMATEX      pwfxDst;            // Dest format
    DWORD               cbwfxDst;           // Dest Size

} ACMDRVFORMATSUGGEST, *PACMDRVFORMATSUGGEST, FAR *LPACMDRVFORMATSUGGEST;

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  ACM Driver Messages
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#define ACMDM_DRIVER_NOTIFY             (ACMDM_BASE + 1)
#define ACMDM_DRIVER_DETAILS            (ACMDM_BASE + 10)

#define ACMDM_HARDWARE_WAVE_CAPS_INPUT  (ACMDM_BASE + 20)
#define ACMDM_HARDWARE_WAVE_CAPS_OUTPUT (ACMDM_BASE + 21)

#define ACMDM_FORMATTAG_DETAILS         (ACMDM_BASE + 25)
#define ACMDM_FORMAT_DETAILS            (ACMDM_BASE + 26)
#define ACMDM_FORMAT_SUGGEST            (ACMDM_BASE + 27)

#define ACMDM_FILTERTAG_DETAILS         (ACMDM_BASE + 50)
#define ACMDM_FILTER_DETAILS            (ACMDM_BASE + 51)

#define ACMDM_STREAM_OPEN               (ACMDM_BASE + 76)
#define ACMDM_STREAM_CLOSE              (ACMDM_BASE + 77)
#define ACMDM_STREAM_SIZE               (ACMDM_BASE + 78)
#define ACMDM_STREAM_CONVERT            (ACMDM_BASE + 79)
#define ACMDM_STREAM_RESET              (ACMDM_BASE + 80)
#define ACMDM_STREAM_PREPARE            (ACMDM_BASE + 81)
#define ACMDM_STREAM_UNPREPARE          (ACMDM_BASE + 82)
#define ACMDM_STREAM_UPDATE	        (ACMDM_BASE + 83)


#include "poppack.h"    /* Revert to default packing */

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif  /* __cplusplus */

#endif  /* _INC_ACMDRV */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\ddk\inc\mountmgr.h ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    mountmgr.h

Abstract:

    This file defines the external mount point interface for administering
    mount points.

Author:

    norbertk

Revision History:

--*/

#ifndef _MOUNTMGR_
#define _MOUNTMGR_

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef FAR
#define FAR
#endif


#define MOUNTMGR_DEVICE_NAME        L"\\Device\\MountPointManager"
#define MOUNTMGR_DOS_DEVICE_NAME    L"\\\\.\\MountPointManager"

#define MOUNTMGRCONTROLTYPE  ((ULONG) 'm')
#define MOUNTDEVCONTROLTYPE  ((ULONG) 'M')

//
// These are the IOCTLs supported by the mount point manager.
//

#define IOCTL_MOUNTMGR_CREATE_POINT                 CTL_CODE(MOUNTMGRCONTROLTYPE, 0, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_MOUNTMGR_DELETE_POINTS                CTL_CODE(MOUNTMGRCONTROLTYPE, 1, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_MOUNTMGR_QUERY_POINTS                 CTL_CODE(MOUNTMGRCONTROLTYPE, 2, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_MOUNTMGR_DELETE_POINTS_DBONLY         CTL_CODE(MOUNTMGRCONTROLTYPE, 3, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_MOUNTMGR_NEXT_DRIVE_LETTER            CTL_CODE(MOUNTMGRCONTROLTYPE, 4, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_MOUNTMGR_AUTO_DL_ASSIGNMENTS          CTL_CODE(MOUNTMGRCONTROLTYPE, 5, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_MOUNTMGR_VOLUME_MOUNT_POINT_CREATED   CTL_CODE(MOUNTMGRCONTROLTYPE, 6, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_MOUNTMGR_VOLUME_MOUNT_POINT_DELETED   CTL_CODE(MOUNTMGRCONTROLTYPE, 7, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_MOUNTMGR_CHANGE_NOTIFY                CTL_CODE(MOUNTMGRCONTROLTYPE, 8, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_MOUNTMGR_KEEP_LINKS_WHEN_OFFLINE      CTL_CODE(MOUNTMGRCONTROLTYPE, 9, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_MOUNTMGR_CHECK_UNPROCESSED_VOLUMES    CTL_CODE(MOUNTMGRCONTROLTYPE, 10, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_MOUNTMGR_VOLUME_ARRIVAL_NOTIFICATION  CTL_CODE(MOUNTMGRCONTROLTYPE, 11, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_MOUNTMGR_QUERY_DOS_VOLUME_PATH        CTL_CODE(MOUNTMGRCONTROLTYPE, 12, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_MOUNTMGR_QUERY_DOS_VOLUME_PATHS       CTL_CODE(MOUNTMGRCONTROLTYPE, 13, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
// Input structure for IOCTL_MOUNTMGR_CREATE_POINT.
//

typedef struct _MOUNTMGR_CREATE_POINT_INPUT {
    USHORT  SymbolicLinkNameOffset;
    USHORT  SymbolicLinkNameLength;
    USHORT  DeviceNameOffset;
    USHORT  DeviceNameLength;
} MOUNTMGR_CREATE_POINT_INPUT, *PMOUNTMGR_CREATE_POINT_INPUT;

//
// Input structure for IOCTL_MOUNTMGR_DELETE_POINTS,
// IOCTL_MOUNTMGR_QUERY_POINTS, and IOCTL_MOUNTMGR_DELETE_POINTS_DBONLY.
//

typedef struct _MOUNTMGR_MOUNT_POINT {
    ULONG   SymbolicLinkNameOffset;
    USHORT  SymbolicLinkNameLength;
    ULONG   UniqueIdOffset;
    USHORT  UniqueIdLength;
    ULONG   DeviceNameOffset;
    USHORT  DeviceNameLength;
} MOUNTMGR_MOUNT_POINT, *PMOUNTMGR_MOUNT_POINT;

//
// Output structure for IOCTL_MOUNTMGR_DELETE_POINTS,
// IOCTL_MOUNTMGR_QUERY_POINTS, and IOCTL_MOUNTMGR_DELETE_POINTS_DBONLY.
//

typedef struct _MOUNTMGR_MOUNT_POINTS {
    ULONG                   Size;
    ULONG                   NumberOfMountPoints;
    MOUNTMGR_MOUNT_POINT    MountPoints[1];
} MOUNTMGR_MOUNT_POINTS, *PMOUNTMGR_MOUNT_POINTS;

//
// Input structure for IOCTL_MOUNTMGR_NEXT_DRIVE_LETTER.
//

typedef struct _MOUNTMGR_DRIVE_LETTER_TARGET {
    USHORT  DeviceNameLength;
    WCHAR   DeviceName[1];
} MOUNTMGR_DRIVE_LETTER_TARGET, *PMOUNTMGR_DRIVE_LETTER_TARGET;

//
// Output structure for IOCTL_MOUNTMGR_NEXT_DRIVE_LETTER.
//

typedef struct _MOUNTMGR_DRIVE_LETTER_INFORMATION {
    BOOLEAN DriveLetterWasAssigned;
    UCHAR   CurrentDriveLetter;
} MOUNTMGR_DRIVE_LETTER_INFORMATION, *PMOUNTMGR_DRIVE_LETTER_INFORMATION;

//
// Input structure for IOCTL_MOUNTMGR_VOLUME_MOUNT_POINT_CREATED and
// IOCTL_MOUNTMGR_VOLUME_MOUNT_POINT_DELETED.
//

typedef struct _MOUNTMGR_VOLUME_MOUNT_POINT {
    USHORT  SourceVolumeNameOffset;
    USHORT  SourceVolumeNameLength;
    USHORT  TargetVolumeNameOffset;
    USHORT  TargetVolumeNameLength;
} MOUNTMGR_VOLUME_MOUNT_POINT, *PMOUNTMGR_VOLUME_MOUNT_POINT;

//
// Input structure for IOCTL_MOUNTMGR_CHANGE_NOTIFY.
// Output structure for IOCTL_MOUNTMGR_CHANGE_NOTIFY.
//

typedef struct _MOUNTMGR_CHANGE_NOTIFY_INFO {
    ULONG   EpicNumber;
} MOUNTMGR_CHANGE_NOTIFY_INFO, *PMOUNTMGR_CHANGE_NOTIFY_INFO;

//
// Input structure for IOCTL_MOUNTMGR_KEEP_LINKS_WHEN_OFFLINE,
// IOCTL_MOUNTMGR_VOLUME_ARRIVAL_NOTIFICATION,
// IOCTL_MOUNTMGR_QUERY_DOS_VOLUME_PATH, and
// IOCTL_MOUNTMGR_QUERY_DOS_VOLUME_PATHS.
//

typedef struct _MOUNTMGR_TARGET_NAME {
    USHORT  DeviceNameLength;
    WCHAR   DeviceName[1];
} MOUNTMGR_TARGET_NAME, *PMOUNTMGR_TARGET_NAME;

//
// Output structure for IOCTL_MOUNTMGR_QUERY_DOS_VOLUME_PATH and
// IOCTL_MOUNTMGR_QUERY_DOS_VOLUME_PATHS.
//

typedef struct _MOUNTMGR_VOLUME_PATHS {
    ULONG   MultiSzLength;
    WCHAR   MultiSz[1];
} MOUNTMGR_VOLUME_PATHS, *PMOUNTMGR_VOLUME_PATHS;

//
// Macro that defines what a "drive letter" mount point is.  This macro can
// be used to scan the result from QUERY_POINTS to discover which mount points
// are find "drive letter" mount points.
//

#define MOUNTMGR_IS_DRIVE_LETTER(s) (   \
    (s)->Length == 28 &&                \
    (s)->Buffer[0] == '\\' &&           \
    (s)->Buffer[1] == 'D' &&            \
    (s)->Buffer[2] == 'o' &&            \
    (s)->Buffer[3] == 's' &&            \
    (s)->Buffer[4] == 'D' &&            \
    (s)->Buffer[5] == 'e' &&            \
    (s)->Buffer[6] == 'v' &&            \
    (s)->Buffer[7] == 'i' &&            \
    (s)->Buffer[8] == 'c' &&            \
    (s)->Buffer[9] == 'e' &&            \
    (s)->Buffer[10] == 's' &&           \
    (s)->Buffer[11] == '\\' &&          \
    (s)->Buffer[12] >= 'A' &&           \
    (s)->Buffer[12] <= 'Z' &&           \
    (s)->Buffer[13] == ':')

//
// Macro that defines what a "volume name" mount point is.  This macro can
// be used to scan the result from QUERY_POINTS to discover which mount points
// are "volume name" mount points.
//

#define MOUNTMGR_IS_VOLUME_NAME(s) (                                          \
     ((s)->Length == 96 || ((s)->Length == 98 && (s)->Buffer[48] == '\\')) && \
     (s)->Buffer[0] == '\\' &&                                                \
     ((s)->Buffer[1] == '?' || (s)->Buffer[1] == '\\') &&                     \
     (s)->Buffer[2] == '?' &&                                                 \
     (s)->Buffer[3] == '\\' &&                                                \
     (s)->Buffer[4] == 'V' &&                                                 \
     (s)->Buffer[5] == 'o' &&                                                 \
     (s)->Buffer[6] == 'l' &&                                                 \
     (s)->Buffer[7] == 'u' &&                                                 \
     (s)->Buffer[8] == 'm' &&                                                 \
     (s)->Buffer[9] == 'e' &&                                                 \
     (s)->Buffer[10] == '{' &&                                                \
     (s)->Buffer[19] == '-' &&                                                \
     (s)->Buffer[24] == '-' &&                                                \
     (s)->Buffer[29] == '-' &&                                                \
     (s)->Buffer[34] == '-' &&                                                \
     (s)->Buffer[47] == '}'                                                   \
    )

#define MOUNTMGR_IS_DOS_VOLUME_NAME(s) (    \
     MOUNTMGR_IS_VOLUME_NAME(s) &&          \
     (s)->Length == 96 &&                   \
     (s)->Buffer[1] == '\\'                 \
    )

#define MOUNTMGR_IS_DOS_VOLUME_NAME_WB(s) ( \
     MOUNTMGR_IS_VOLUME_NAME(s) &&          \
     (s)->Length == 98 &&                   \
     (s)->Buffer[1] == '\\'                 \
    )

#define MOUNTMGR_IS_NT_VOLUME_NAME(s) (     \
     MOUNTMGR_IS_VOLUME_NAME(s) &&          \
     (s)->Length == 96 &&                   \
     (s)->Buffer[1] == '?'                  \
    )

#define MOUNTMGR_IS_NT_VOLUME_NAME_WB(s) (  \
     MOUNTMGR_IS_VOLUME_NAME(s) &&          \
     (s)->Length == 98 &&                   \
     (s)->Buffer[1] == '?'                  \
    )

//
// The following IOCTL is supported by mounted devices.
//

#define IOCTL_MOUNTDEV_QUERY_DEVICE_NAME    CTL_CODE(MOUNTDEVCONTROLTYPE, 2, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
// Output structure for IOCTL_MOUNTDEV_QUERY_DEVICE_NAME.
//

typedef struct _MOUNTDEV_NAME {
    USHORT  NameLength;
    WCHAR   Name[1];
} MOUNTDEV_NAME, *PMOUNTDEV_NAME;

//
// Devices that wish to be mounted should report this GUID in
// IoRegisterDeviceInterface.
//

DEFINE_GUID(MOUNTDEV_MOUNTED_DEVICE_GUID, 0x53f5630d, 0xb6bf, 0x11d0, 0x94, 0xf2, 0x00, 0xa0, 0xc9, 0x1e, 0xfb, 0x8b);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\ddk\inc\mmddk.h ===
/****************************************************************************/
/*                                                                          */
/*      MMDDK.H - Include file for Multimedia Device Development Kit        */
/*                                                                          */
/*      Note: You must include the WINDOWS.H and MMSYSTEM.H header files    */
/*            before including this file.                                   */
/*                                                                          */
/*      Copyright (c) 1990-1998, Microsoft Corp.  All rights reserved.      */
/*                                                                          */
/****************************************************************************/

#ifndef _INC_MMDDK
#define _INC_MMDDK

#include "pshpack1.h"   // Assume byte packing throughout

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

/*    If defined, the following flags inhibit inclusion
 *    of the indicated items:
 *
 *        MMNOMIDIDEV         - MIDI support
 *        MMNOWAVEDEV         - Waveform support
 *        MMNOAUXDEV          - Auxiliary output support
 *        MMNOMIXERDEV        - Mixer support
 *        MMNOTIMERDEV        - Timer support
 *        MMNOJOYDEV          - Joystick support
 *        MMNOMCIDEV          - MCI support
 *        MMNOTASKDEV         - Task support
 */
#ifdef MMNOTIMER
  #define MMNOTIMERDEV
#endif
#ifdef MMNOWAVE
  #define MMNOWAVEDEV
#endif
#ifdef MMNOMIDI
  #define MMNOMIDIDEV
#endif
#ifdef MMNOAUX
  #define MMNOAUXDEV
#endif
#ifdef MMNOJOY
  #define MMNOJOYDEV
#endif
#ifdef MMNOMMIO
  #define MMNOMMIODEV
#endif
#ifdef MMNOMCI
  #define MMNOMCIDEV
#endif


/***************************************************************************

                       Helper functions for drivers

***************************************************************************/

#ifndef NODRIVERS
#define DRV_LOAD               0x0001
#define DRV_ENABLE             0x0002
#define DRV_OPEN               0x0003
#define DRV_CLOSE              0x0004
#define DRV_DISABLE            0x0005
#define DRV_FREE               0x0006
#define DRV_CONFIGURE          0x0007
#define DRV_QUERYCONFIGURE     0x0008
#define DRV_INSTALL            0x0009
#define DRV_REMOVE             0x000A

#define DRV_RESERVED           0x0800
#define DRV_USER               0x4000

#define DRIVERS_SECTION  TEXT("DRIVERS32")     // Section name for installed drivers
#define MCI_SECTION      TEXT("MCI32")         // Section name for installed MCI drivers

#endif /* !NODRIVERS */

#define DCB_NOSWITCH   0x0008           // don't switch stacks for callback
#define DCB_TYPEMASK   0x0007           // callback type mask
#define DCB_NULL       0x0000           // unknown callback type

// flags for wFlags parameter of DriverCallback()
#define DCB_WINDOW     0x0001           // dwCallback is a HWND
#define DCB_TASK       0x0002           // dwCallback is a HTASK
#define DCB_FUNCTION   0x0003           // dwCallback is a FARPROC
#define DCB_EVENT      0x0005           // dwCallback is an EVENT

BOOL APIENTRY DriverCallback(DWORD_PTR dwCallback, DWORD dwFlags,
    HDRVR hDevice, DWORD dwMsg, DWORD_PTR dwUser, DWORD_PTR dwParam1, DWORD_PTR dwParam2);

// generic prototype for audio device driver entry-point functions
// midMessage(), modMessage(), widMessage(), wodMessage(), auxMessage()
//typedef DWORD (SOUNDDEVMSGPROC)(WORD, WORD, DWORD, DWORD, DWORD);
//typedef SOUNDDEVMSGPROC FAR *LPSOUNDDEVMSGPROC;

#define DRVM_INIT               100
#define DRVM_EXIT               101
#define DRVM_DISABLE            102
#define DRVM_ENABLE             103


// message base for driver specific messages.
//
#define DRVM_MAPPER             0x2000
#define DRVM_USER               0x4000
#define DRVM_MAPPER_STATUS      (DRVM_MAPPER+0)
#define DRVM_MAPPER_RECONFIGURE (DRVM_MAPPER+1)
#define DRVM_MAPPER_PREFERRED_GET                 (DRVM_MAPPER+21)
#define DRVM_MAPPER_CONSOLEVOICECOM_GET           (DRVM_MAPPER+23)
#define DRV_QUERYDEVNODE             (DRV_RESERVED + 2)
#define DRV_QUERYMAPPABLE            (DRV_RESERVED + 5)
#define DRV_QUERYMODULE              (DRV_RESERVED + 9)
#define DRV_PNPINSTALL               (DRV_RESERVED + 11)
#define DRV_QUERYDEVICEINTERFACE     (DRV_RESERVED + 12)
#define DRV_QUERYDEVICEINTERFACESIZE (DRV_RESERVED + 13)
#define DRV_QUERYSTRINGID            (DRV_RESERVED + 14)
#define DRV_QUERYSTRINGIDSIZE        (DRV_RESERVED + 15)
#define DRV_QUERYIDFROMSTRINGID      (DRV_RESERVED + 16)

//
// DRVM_MAPPER_PREFERRED_GET flags
//
#define DRVM_MAPPER_PREFERRED_FLAGS_PREFERREDONLY   0x00000001



//
// messages that have IOCTL format
//    dw1 = NULL or handle
//    dw2 = NULL or ptr to DRVM_IOCTL_DATA
//    return is MMRESULT
//
#define DRVM_IOCTL                0x100
#define DRVM_ADD_THRU             (DRVM_IOCTL+1)
#define DRVM_REMOVE_THRU          (DRVM_IOCTL+2)
#define DRVM_IOCTL_LAST           (DRVM_IOCTL+5)

typedef struct {
    DWORD  dwSize; // size of this structure (inclusive)
    DWORD  dwCmd;  // IOCTL command code, 0x80000000 and above reserved for system
    } DRVM_IOCTL_DATA, FAR * LPDRVM_IOCTL_DATA;

// command code ranges for dwCmd field of DRVM_IOCTL message
// codes from 0 to 0x7FFFFFFF are user defined
// codes from 0x80000000 to 0xFFFFFFFF are reserved for future
// definition by microsoft
//
#define DRVM_IOCTL_CMD_USER   0x00000000L
#define DRVM_IOCTL_CMD_SYSTEM 0x80000000L

// device ID for 386 AUTODMA VxD
#define VADMAD_Device_ID    0X0444

/* PnP version of media device caps */
typedef struct {
    DWORD	cbSize;
    LPVOID	pCaps;
} MDEVICECAPSEX;

#ifndef MMNOWAVEDEV
/****************************************************************************

                       Waveform device driver support

****************************************************************************/

#define WODM_INIT      DRVM_INIT
#define WIDM_INIT      DRVM_INIT

// waveform input and output device open information structure
typedef struct waveopendesc_tag {
    HWAVE          hWave;             // handle
    LPWAVEFORMAT   lpFormat;          // format of wave data
    DWORD_PTR      dwCallback;        // callback
    DWORD_PTR      dwInstance;        // app's private instance information
    UINT           uMappedDeviceID;   // device to map to if WAVE_MAPPED set
    DWORD_PTR      dnDevNode;         /* if device is PnP */
} WAVEOPENDESC;
typedef WAVEOPENDESC FAR *LPWAVEOPENDESC;

// messages sent to wodMessage() entry-point function
#define WODM_GETNUMDEVS       3
#define WODM_GETDEVCAPS       4
#define WODM_OPEN             5
#define WODM_CLOSE            6
#define WODM_PREPARE          7
#define WODM_UNPREPARE        8
#define WODM_WRITE            9
#define WODM_PAUSE            10
#define WODM_RESTART          11
#define WODM_RESET            12
#define WODM_GETPOS           13
#define WODM_GETPITCH         14
#define WODM_SETPITCH         15
#define WODM_GETVOLUME        16
#define WODM_SETVOLUME        17
#define WODM_GETPLAYBACKRATE  18
#define WODM_SETPLAYBACKRATE  19
#define WODM_BREAKLOOP        20
#define WODM_PREFERRED        21
// #if (WINVER >= 0x030B)
#define WODM_MAPPER_STATUS              (DRVM_MAPPER_STATUS + 0)
#define WAVEOUT_MAPPER_STATUS_DEVICE    0
#define WAVEOUT_MAPPER_STATUS_MAPPED    1
#define WAVEOUT_MAPPER_STATUS_FORMAT    2
// #endif /* WINVER >= 0x030B */
#define WODM_BUSY             21

// messages sent to widMessage() entry-point function
#define WIDM_GETNUMDEVS  50
#define WIDM_GETDEVCAPS  51
#define WIDM_OPEN        52
#define WIDM_CLOSE       53
#define WIDM_PREPARE     54
#define WIDM_UNPREPARE   55
#define WIDM_ADDBUFFER   56
#define WIDM_START       57
#define WIDM_STOP        58
#define WIDM_RESET       59
#define WIDM_GETPOS      60
#define WIDM_PREFERRED   61
// #if (WINVER >= 0x030B)
#define WIDM_MAPPER_STATUS              (DRVM_MAPPER_STATUS + 0)
#define WAVEIN_MAPPER_STATUS_DEVICE     0
#define WAVEIN_MAPPER_STATUS_MAPPED     1
#define WAVEIN_MAPPER_STATUS_FORMAT     2
// #endif /* WINVER >= 0x30B */

#endif // ifndef MMNOWAVEDEV


#ifndef MMNOMIDIDEV
/****************************************************************************

                          MIDI device driver support

****************************************************************************/

#define MODM_USER      DRVM_USER
#define MIDM_USER      DRVM_USER
#define MODM_MAPPER    DRVM_MAPPER
#define MIDM_MAPPER    DRVM_MAPPER

#define MODM_INIT      DRVM_INIT
#define MIDM_INIT      DRVM_INIT

#ifndef MMNOMIDI   // This protects the definition of HMIDI in WINMM.H
                   // Win 3.1 works the same way
typedef struct midiopenstrmid_tag {
    DWORD          dwStreamID;
    UINT           uDeviceID;
} MIDIOPENSTRMID;
// MIDI input and output device open information structure
typedef struct midiopendesc_tag {
    HMIDI          hMidi;             // handle
    DWORD_PTR      dwCallback;        // callback
    DWORD_PTR      dwInstance;        // app's private instance information
    DWORD_PTR      dnDevNode;         // DevNode
    DWORD          cIds;              // If stream open, # stream ids
    MIDIOPENSTRMID rgIds[1];          // Array of device ID's (actually [cIds])
} MIDIOPENDESC;
typedef MIDIOPENDESC FAR *LPMIDIOPENDESC;
#endif // MMNOMIDI


/* Flags for MODM_OPEN */
#define MIDI_IO_PACKED      0x00000000L     /* Compatibility mode */
#define MIDI_IO_COOKED      0x00000002L

// messages sent to modMessage() entry-point function
#define MODM_GETNUMDEVS     1
#define MODM_GETDEVCAPS     2
#define MODM_OPEN           3
#define MODM_CLOSE          4
#define MODM_PREPARE        5
#define MODM_UNPREPARE      6
#define MODM_DATA           7
#define MODM_LONGDATA       8
#define MODM_RESET          9
#define MODM_GETVOLUME      10
#define MODM_SETVOLUME      11
#define MODM_CACHEPATCHES       12
#define MODM_CACHEDRUMPATCHES   13

#if (WINVER >= 0x400)
#define MODM_STRMDATA               14
#define MODM_GETPOS                 17
#define MODM_PAUSE                  18
#define MODM_RESTART                19
#define MODM_STOP                   20
#define MODM_PROPERTIES             21
#define MODM_PREFERRED              22
#define MODM_RECONFIGURE            (MODM_USER+0x0768)
#endif


// messages sent to midMessage() entry-point function
#define MIDM_GETNUMDEVS  53
#define MIDM_GETDEVCAPS  54
#define MIDM_OPEN        55
#define MIDM_CLOSE       56
#define MIDM_PREPARE     57
#define MIDM_UNPREPARE   58
#define MIDM_ADDBUFFER   59
#define MIDM_START       60
#define MIDM_STOP        61
#define MIDM_RESET       62

#endif // ifndef MMNOMIDIDEV


#ifndef MMNOAUXDEV
/****************************************************************************

                    Auxiliary audio device driver support

****************************************************************************/

#define AUXM_INIT      DRVM_INIT

// messages sent to auxMessage() entry-point function
#define AUXDM_GETNUMDEVS    3
#define AUXDM_GETDEVCAPS    4
#define AUXDM_GETVOLUME     5
#define AUXDM_SETVOLUME     6

#endif // ifndef MMNOAUXDEV

// #if (WINVER >= 0x030B)
#ifndef MMNOMIXERDEV

//
//  mixer device open information structure
//
//
typedef struct tMIXEROPENDESC
{
    HMIXER          hmx;            // handle that will be used
    LPVOID          pReserved0;     // reserved--driver should ignore
    DWORD_PTR       dwCallback;     // callback
    DWORD_PTR       dwInstance;     // app's private instance information
    DWORD_PTR       dnDevNode;      // if device is PnP

} MIXEROPENDESC, *PMIXEROPENDESC, FAR *LPMIXEROPENDESC;



//
//
//
//
#define MXDM_INIT                   100
#define MXDM_USER                   DRV_USER

#define MXDM_BASE                   (1)
#define MXDM_GETNUMDEVS             (MXDM_BASE + 0)
#define MXDM_GETDEVCAPS             (MXDM_BASE + 1)
#define MXDM_OPEN                   (MXDM_BASE + 2)
#define MXDM_CLOSE                  (MXDM_BASE + 3)
#define MXDM_GETLINEINFO            (MXDM_BASE + 4)
#define MXDM_GETLINECONTROLS        (MXDM_BASE + 5)
#define MXDM_GETCONTROLDETAILS      (MXDM_BASE + 6)
#define MXDM_SETCONTROLDETAILS      (MXDM_BASE + 7)

#endif // MMNOMIXERDEV
// #endif /* ifdef WINVER >= 0x030B */

#if !defined(MMNOTIMERDEV)
/****************************************************************************

                        Timer device driver support

****************************************************************************/

typedef struct timerevent_tag {
    WORD                wDelay;         // delay required
    WORD                wResolution;    // resolution required
    LPTIMECALLBACK      lpFunction;     // ptr to callback function
    DWORD               dwUser;         // user DWORD
    WORD                wFlags;         // defines how to program event
    WORD                wReserved1;     // structure packing
} TIMEREVENT;
typedef TIMEREVENT FAR *LPTIMEREVENT;

// messages sent to tddMessage() function
#define TDD_KILLTIMEREVENT  (DRV_RESERVED+0)  // indices into a table of
#define TDD_SETTIMEREVENT   (DRV_RESERVED+4)  // functions; thus offset by
#define TDD_GETSYSTEMTIME   (DRV_RESERVED+8)  // four each time...
#define TDD_GETDEVCAPS      (DRV_RESERVED+12) // room for future expansion
#define TDD_BEGINMINPERIOD  (DRV_RESERVED+16) // room for future expansion
#define TDD_ENDMINPERIOD    (DRV_RESERVED+20) // room for future expansion

#endif // ifndef MMNOTIMERDEV


#ifndef MMNOJOYDEV
/****************************************************************************

                       Joystick device driver support

****************************************************************************/

/* RegisterWindowMessage with this to get msg id of config changes */
#define JOY_CONFIGCHANGED_MSGSTRING     "MSJSTICK_VJOYD_MSGSTR"

/* pre-defined joystick types */
#define JOY_HW_NONE                     0
#define JOY_HW_CUSTOM                   1
#define JOY_HW_2A_2B_GENERIC            2
#define JOY_HW_2A_4B_GENERIC            3
#define JOY_HW_2B_GAMEPAD               4
#define JOY_HW_2B_FLIGHTYOKE            5
#define JOY_HW_2B_FLIGHTYOKETHROTTLE    6
#define JOY_HW_3A_2B_GENERIC            7
#define JOY_HW_3A_4B_GENERIC            8
#define JOY_HW_4B_GAMEPAD               9
#define JOY_HW_4B_FLIGHTYOKE            10
#define JOY_HW_4B_FLIGHTYOKETHROTTLE    11
#define JOY_HW_LASTENTRY                12

/* calibration flags */
#define JOY_ISCAL_XY            0x00000001l     /* XY are calibrated */
#define JOY_ISCAL_Z             0x00000002l     /* Z is calibrated */
#define JOY_ISCAL_R             0x00000004l     /* R is calibrated */
#define JOY_ISCAL_U             0x00000008l     /* U is calibrated */
#define JOY_ISCAL_V             0x00000010l     /* V is calibrated */
#define JOY_ISCAL_POV           0x00000020l     /* POV is calibrated */

/* point of view constants */
#define JOY_POV_NUMDIRS          4
#define JOY_POVVAL_FORWARD       0
#define JOY_POVVAL_BACKWARD      1
#define JOY_POVVAL_LEFT          2
#define JOY_POVVAL_RIGHT         3

/* Specific settings for joystick hardware */
#define JOY_HWS_HASZ            0x00000001l     /* has Z info? */
#define JOY_HWS_HASPOV          0x00000002l     /* point of view hat present */
#define JOY_HWS_POVISBUTTONCOMBOS 0x00000004l   /* pov done through combo of buttons */
#define JOY_HWS_POVISPOLL       0x00000008l     /* pov done through polling */
#define JOY_HWS_ISYOKE          0x00000010l     /* joystick is a flight yoke */
#define JOY_HWS_ISGAMEPAD       0x00000020l     /* joystick is a game pad */
#define JOY_HWS_ISCARCTRL       0x00000040l     /* joystick is a car controller */
/* X defaults to J1 X axis */
#define JOY_HWS_XISJ1Y          0x00000080l     /* X is on J1 Y axis */
#define JOY_HWS_XISJ2X          0x00000100l     /* X is on J2 X axis */
#define JOY_HWS_XISJ2Y          0x00000200l     /* X is on J2 Y axis */
/* Y defaults to J1 Y axis */
#define JOY_HWS_YISJ1X          0x00000400l     /* Y is on J1 X axis */
#define JOY_HWS_YISJ2X          0x00000800l     /* Y is on J2 X axis */
#define JOY_HWS_YISJ2Y          0x00001000l     /* Y is on J2 Y axis */
/* Z defaults to J2 Y axis */
#define JOY_HWS_ZISJ1X          0x00002000l     /* Z is on J1 X axis */
#define JOY_HWS_ZISJ1Y          0x00004000l     /* Z is on J1 Y axis */
#define JOY_HWS_ZISJ2X          0x00008000l     /* Z is on J2 X axis */
/* POV defaults to J2 Y axis, if it is not button based */
#define JOY_HWS_POVISJ1X        0x00010000l     /* pov done through J1 X axis */
#define JOY_HWS_POVISJ1Y        0x00020000l     /* pov done through J1 Y axis */
#define JOY_HWS_POVISJ2X        0x00040000l     /* pov done through J2 X axis */
/* R defaults to J2 X axis */
#define JOY_HWS_HASR            0x00080000l     /* has R (4th axis) info */
#define JOY_HWS_RISJ1X          0x00100000l     /* R done through J1 X axis */
#define JOY_HWS_RISJ1Y          0x00200000l     /* R done through J1 Y axis */
#define JOY_HWS_RISJ2Y          0x00400000l     /* R done through J2 X axis */
/* U & V for future hardware */
#define JOY_HWS_HASU            0x00800000l     /* has U (5th axis) info */
#define JOY_HWS_HASV            0x01000000l     /* has V (6th axis) info */

/* Usage settings */
#define JOY_US_HASRUDDER        0x00000001l     /* joystick configured with rudder */
#define JOY_US_PRESENT          0x00000002l     /* is joystick actually present? */
#define JOY_US_ISOEM            0x00000004l     /* joystick is an OEM defined type */

/* struct for storing x,y, z, and rudder values */
typedef struct joypos_tag {
    DWORD       dwX;
    DWORD       dwY;
    DWORD       dwZ;
    DWORD       dwR;
    DWORD       dwU;
    DWORD       dwV;
} JOYPOS, FAR *LPJOYPOS;

/* struct for storing ranges */
typedef struct joyrange_tag {
    JOYPOS      jpMin;
    JOYPOS      jpMax;
    JOYPOS      jpCenter;
} JOYRANGE,FAR *LPJOYRANGE;

typedef struct joyreguservalues_tag {
    DWORD       dwTimeOut;      /* value at which to timeout joystick polling */
    JOYRANGE    jrvRanges;      /* range of values app wants returned for axes */
    JOYPOS      jpDeadZone;     /* area around center to be considered
                                   as "dead". specified as a percentage
                                   (0-100). Only X & Y handled by system driver */
} JOYREGUSERVALUES, FAR *LPJOYREGUSERVALUES;

typedef struct joyreghwsettings_tag {
    DWORD       dwFlags;
    DWORD       dwNumButtons;           /* number of buttons */
} JOYREGHWSETTINGS, FAR *LPJOYHWSETTINGS;

/* range of values returned by the hardware (filled in by calibration) */
typedef struct joyreghwvalues_tag {
    JOYRANGE    jrvHardware;            /* values returned by hardware */
    DWORD       dwPOVValues[JOY_POV_NUMDIRS];/* POV values returned by hardware */
    DWORD       dwCalFlags;             /* what has been calibrated */
} JOYREGHWVALUES, FAR *LPJOYREGHWVALUES;

/* hardware configuration */
typedef struct joyreghwconfig_tag {
    JOYREGHWSETTINGS    hws;            /* hardware settings */
    DWORD               dwUsageSettings;/* usage settings */
    JOYREGHWVALUES      hwv;            /* values returned by hardware */
    DWORD               dwType;         /* type of joystick */
    DWORD               dwReserved;     /* reserved for OEM drivers */
} JOYREGHWCONFIG, FAR *LPJOYREGHWCONFIG;

// joystick calibration info structure
typedef struct joycalibrate_tag {
    WORD    wXbase;
    WORD    wXdelta;
    WORD    wYbase;
    WORD    wYdelta;
    WORD    wZbase;
    WORD    wZdelta;
} JOYCALIBRATE;
typedef JOYCALIBRATE FAR *LPJOYCALIBRATE;

// prototype for joystick message function
typedef DWORD (JOYDEVMSGPROC)(DWORD, UINT, LONG, LONG);
typedef JOYDEVMSGPROC FAR *LPJOYDEVMSGPROC;

// messages sent to joystick driver's DriverProc() function
#define JDD_GETNUMDEVS          (DRV_RESERVED + 0x0001)
#define JDD_GETDEVCAPS          (DRV_RESERVED + 0x0002)
#define JDD_GETPOS              (DRV_RESERVED + 0x0101)
#define JDD_SETCALIBRATION      (DRV_RESERVED + 0x0102)
#define JDD_CONFIGCHANGED       (DRV_RESERVED + 0x0103)
#define JDD_GETPOSEX            (DRV_RESERVED + 0x0104)

#endif // ifndef MMNOJOYDEV

#ifndef MAKELRESULT
#define MAKELRESULT(low, high)   ((LRESULT)MAKELONG(low, high))
#endif//MAKELRESULT


#ifndef MMNOMCIDEV
/****************************************************************************

                        MCI device driver support

****************************************************************************/


// internal MCI messages
#define MCI_OPEN_DRIVER             0x0801
#define MCI_CLOSE_DRIVER            0x0802

#define MAKEMCIRESOURCE(wRet, wRes) MAKELRESULT((wRet), (wRes))

// string return values only used with MAKEMCIRESOURCE
#define MCI_FALSE                       (MCI_STRING_OFFSET + 19)
#define MCI_TRUE                        (MCI_STRING_OFFSET + 20)

// resource string return values
#define MCI_FORMAT_RETURN_BASE          MCI_FORMAT_MILLISECONDS_S
#define MCI_FORMAT_MILLISECONDS_S       (MCI_STRING_OFFSET + 21)
#define MCI_FORMAT_HMS_S                (MCI_STRING_OFFSET + 22)
#define MCI_FORMAT_MSF_S                (MCI_STRING_OFFSET + 23)
#define MCI_FORMAT_FRAMES_S             (MCI_STRING_OFFSET + 24)
#define MCI_FORMAT_SMPTE_24_S           (MCI_STRING_OFFSET + 25)
#define MCI_FORMAT_SMPTE_25_S           (MCI_STRING_OFFSET + 26)
#define MCI_FORMAT_SMPTE_30_S           (MCI_STRING_OFFSET + 27)
#define MCI_FORMAT_SMPTE_30DROP_S       (MCI_STRING_OFFSET + 28)
#define MCI_FORMAT_BYTES_S              (MCI_STRING_OFFSET + 29)
#define MCI_FORMAT_SAMPLES_S            (MCI_STRING_OFFSET + 30)
#define MCI_FORMAT_TMSF_S               (MCI_STRING_OFFSET + 31)

#define MCI_VD_FORMAT_TRACK_S           (MCI_VD_OFFSET + 5)

#define WAVE_FORMAT_PCM_S               (MCI_WAVE_OFFSET + 0)
#define WAVE_MAPPER_S                   (MCI_WAVE_OFFSET + 1)

#define MCI_SEQ_MAPPER_S                (MCI_SEQ_OFFSET + 5)
#define MCI_SEQ_FILE_S                  (MCI_SEQ_OFFSET + 6)
#define MCI_SEQ_MIDI_S                  (MCI_SEQ_OFFSET + 7)
#define MCI_SEQ_SMPTE_S                 (MCI_SEQ_OFFSET + 8)
#define MCI_SEQ_FORMAT_SONGPTR_S        (MCI_SEQ_OFFSET + 9)
#define MCI_SEQ_NONE_S                  (MCI_SEQ_OFFSET + 10)
#define MIDIMAPPER_S                    (MCI_SEQ_OFFSET + 11)

#define MCI_TABLE_NOT_PRESENT   ((UINT)-1)
// parameters for internal version of MCI_OPEN message sent from
// mciOpenDevice() to the driver
typedef struct {
    MCIDEVICEID wDeviceID;             // device ID
    LPCWSTR     lpstrParams;           // parameter string for entry in SYSTEM.INI
    UINT        wCustomCommandTable;   // custom command table ((-1) if none)
                                       // filled in by the driver
    UINT        wType;                 // driver type
                                       // filled in by the driver
} MCI_OPEN_DRIVER_PARMS;
typedef MCI_OPEN_DRIVER_PARMS FAR * LPMCI_OPEN_DRIVER_PARMS;

// maximum length of an MCI device type
#define MCI_MAX_DEVICE_TYPE_LENGTH 80

// flags for mciSendCommandInternal() which direct mciSendString() how to
// interpret the return value
#define MCI_RESOURCE_RETURNED       0x00010000  // resource ID
#define MCI_COLONIZED3_RETURN       0x00020000  // colonized ID, 3 bytes data
#define MCI_COLONIZED4_RETURN       0x00040000  // colonized ID, 4 bytes data
#define MCI_INTEGER_RETURNED        0x00080000  // integer conversion needed
#define MCI_RESOURCE_DRIVER         0x00100000  // driver owns returned resource

// invalid command table ID
#define MCI_NO_COMMAND_TABLE    ((UINT)(-1))

// command table information type tags
#define MCI_COMMAND_HEAD        0
#define MCI_STRING              1
#define MCI_INTEGER             2
#define MCI_END_COMMAND         3
#define MCI_RETURN              4
#define MCI_FLAG                5
#define MCI_END_COMMAND_LIST    6
#define MCI_RECT                7
#define MCI_CONSTANT            8
#define MCI_END_CONSTANT        9
#define MCI_HWND               10
#define MCI_HPAL               11
#define MCI_HDC                12

// function prototypes for MCI driver functions
DWORD_PTR APIENTRY mciGetDriverData(MCIDEVICEID wDeviceID);
BOOL      APIENTRY mciSetDriverData(MCIDEVICEID wDeviceID, DWORD_PTR dwData);
UINT      APIENTRY mciDriverYield (MCIDEVICEID wDeviceID);
BOOL      APIENTRY mciDriverNotify (HANDLE hwndCallback, MCIDEVICEID wDeviceID,
    UINT uStatus);
UINT  APIENTRY mciLoadCommandResource(HANDLE hInstance,
    LPCWSTR lpResName, UINT wType);
BOOL  APIENTRY mciFreeCommandResource(UINT wTable);

#endif // ifndef MMNOMCIDEV


#ifndef MMNOTASKDEV
/*****************************************************************************

                               Task support

*****************************************************************************/

// error return values
#define TASKERR_NOTASKSUPPORT 1
#define TASKERR_OUTOFMEMORY   2

// task support function prototypes
typedef VOID (TASKCALLBACK) (DWORD_PTR dwInst);

typedef TASKCALLBACK FAR *LPTASKCALLBACK;

UINT    APIENTRY mmTaskCreate(LPTASKCALLBACK lpfn, HANDLE FAR * lph, DWORD_PTR dwInst);
VOID    APIENTRY mmTaskBlock(DWORD h);
BOOL    APIENTRY mmTaskSignal(DWORD h);
VOID    APIENTRY mmTaskYield(VOID);
DWORD   APIENTRY mmGetCurrentTask(VOID);

#endif // endif MMNOTASKDEV

#define MMDDKINC

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#include "poppack.h"        /* Revert to default packing */

#endif /* _INC_MMDDK */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\ddk\inc\msviddrv.h ===
/****************************************************************************/
/*                                                                          */
/*        MSVIDDRV.H - Include file for messages to video capture drivers   */
/*                                                                          */
/*        Note: You must include WINDOWS.H before including this file.      */
/*                                                                          */
/*        Copyright (c) 1990-1999, Microsoft Corp.  All rights reserved.    */
/*                                                                          */
/****************************************************************************/

#ifndef _INC_MSVIDDRV
#define _INC_MSVIDDRV	50	/* version number */

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

/****************************************************************************

                 Digital Video Messages (DVM_)

****************************************************************************/

// General messages
#define DVM_START                         DRV_USER
#define DVM_GETERRORTEXT                  (DVM_START + 0)
#define DVM_GETVIDEOAPIVER                (DVM_START + 1)

// This value increments each time the API changes
// It is passed to the driver in the DRV_OPEN message.
#define VIDEOAPIVERSION 		4

// General messages applicable to all channel types
#define DVM_DIALOG			(DVM_START + 100)
#define DVM_CONFIGURESTORAGE		(DVM_START + 101)
#define DVM_GET_CHANNEL_CAPS         	(DVM_START + 102)
#define DVM_UPDATE         		(DVM_START + 103)

// Single frame msg
#define DVM_FRAME			(DVM_START + 200)

// stream messages
#define DVM_STREAM_MSG_START            (DVM_START + 300)
#define DVM_STREAM_MSG_END              (DVM_START + 399)

#define DVM_STREAM_ADDBUFFER            (DVM_START + 300)
#define DVM_STREAM_FINI                 (DVM_START + 301)
#define DVM_STREAM_GETERROR             (DVM_START + 302)
#define DVM_STREAM_GETPOSITION          (DVM_START + 303)
#define DVM_STREAM_INIT                 (DVM_START + 304)
#define DVM_STREAM_PREPAREHEADER        (DVM_START + 305)
#define DVM_STREAM_RESET                (DVM_START + 306)
#define DVM_STREAM_START                (DVM_START + 307)
#define DVM_STREAM_STOP                 (DVM_START + 308)
#define DVM_STREAM_UNPREPAREHEADER      (DVM_START + 309)

// Following added post VFW1.1a, but are now obsolete
#define DVM_STREAM_ALLOCHDRANDBUFFER    (DVM_START + 310)
#define DVM_STREAM_FREEHDRANDBUFFER     (DVM_START + 311)
// The 2 messages above will be removed once the ALLOCBUFFER code is ready

// Following added for Win95 and NTPPC
#define DVM_STREAM_ALLOCBUFFER          (DVM_START + 312)
#define DVM_STREAM_FREEBUFFER           (DVM_START + 313)

// NOTE that DVM_CONFIGURE numbers will start at 0x1000 (for configure API)


/****************************************************************************

                            Open Definitions

****************************************************************************/
#define OPEN_TYPE_VCAP mmioFOURCC('v', 'c', 'a', 'p')

// The following structure is the same as IC_OPEN
// to allow compressors and capture devices to share
// the same DriverProc.

typedef struct tag_video_open_parms {
    DWORD               dwSize;         // sizeof(VIDEO_OPEN_PARMS)
    FOURCC              fccType;        // 'vcap'
    FOURCC              fccComp;        // unused
    DWORD               dwVersion;      // version of msvideo opening you
    DWORD               dwFlags;        // channel type
    DWORD               dwError;        // if open fails, this is why
    LPVOID              pV1Reserved;    // Reserved
    LPVOID              pV2Reserved;    // Reserved
    DWORD               dnDevNode;      // Devnode for PnP devices
} VIDEO_OPEN_PARMS, FAR * LPVIDEO_OPEN_PARMS;

typedef struct tag_video_geterrortext_parms {
       DWORD  dwError;          // The error number to identify
#ifdef _WIN32
       LPWSTR lpText;		// Text buffer to fill
#else
       LPSTR lpText;		// Text buffer to fill
#endif
       DWORD  dwLength;		// Size of text buffer in characters
} VIDEO_GETERRORTEXT_PARMS, FAR * LPVIDEO_GETERRORTEXT_PARMS;

typedef struct tag_video_stream_init_parms {
       DWORD  dwMicroSecPerFrame;
       DWORD  dwCallback;
       DWORD  dwCallbackInst;
       DWORD  dwFlags;
       HANDLE hVideo;
} VIDEO_STREAM_INIT_PARMS, FAR * LPVIDEO_STREAM_INIT_PARMS;

typedef struct tag_video_configure_parms {
       LPDWORD  lpdwReturn;	// Return parameter from configure MSG.
       LPVOID	lpData1;	// Pointer to data 1.
       DWORD	dwSize1;	// size of data buffer 1.
       LPVOID	lpData2;	// Pointer to data 2.
       DWORD	dwSize2;	// size of data buffer 2.
} VIDEOCONFIGPARMS, FAR * LPVIDEOCONFIGPARMS;

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif	/* __cplusplus */

#endif  /* _INC_MSVIDDRV */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\ddk\inc\msports.h ===
//+-------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993-1999.
//
//  File:        msports.h
//
//  Contents:    public header file for COM name arbitration database
//               and Advanced dialog override and invocation
//
//--------------------------------------------------------------------

#ifndef _MSPORTS_H
#define _MSPORTS_H

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

#ifdef SERIAL_ADVANCED_SETTINGS

/*++

Routine Description:

    Displays the advanced properties dialog for the COM port specified by
    DeviceInfoSet and DeviceInfoData.

Arguments:

    ParentHwnd  - the parent window of the window to be displayed

    DeviceInfoSet, DeviceInfoData - SetupDi structures representing the COM port

Return Value:

    ERROR_SUCCESS if the dialog was shown

  --*/
LONG
SerialDisplayAdvancedSettings(IN HWND             ParentHwnd,
                              IN HDEVINFO         DeviceInfoSet,
                              IN PSP_DEVINFO_DATA DeviceInfoData
                              );

/*++

Routine Description:

    Prototype to allow serial port vendors to override the advanced dialog
    represented by the COM port specified by DeviceInfoSet and DeviceInfoData.

    To override the advanced page, place a value named EnumAdvancedDialog under
    the same key in which you would put your EnumPropPages32 value.  The format
    of the value is exactly the same as Enum...32 as well.

Arguments:

    ParentHwnd  - the parent window of the window to be displayed

    HidePollingUI - If TRUE, hide all UI that deals with polling.

    DeviceInfoSet, DeviceInfoData - SetupDi structures representing the COM port

    Reserved - Unused

Return Value:

    TRUE if the user pressed OK, FALSE if Cancel was pressed
--*/

typedef
BOOL
(*PPORT_ADVANCED_DIALOG) (
    IN HWND             ParentHwnd,
    IN BOOL             HidePollingUI,
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData,
    IN PVOID            Reserved
    );

#endif

DECLARE_HANDLE(HCOMDB);
typedef HCOMDB *PHCOMDB;
#define HCOMDB_INVALID_HANDLE_VALUE ((HCOMDB) INVALID_HANDLE_VALUE)

//
// Minimum through maximum number of COM names arbitered
//
#define COMDB_MIN_PORTS_ARBITRATED 256
#define COMDB_MAX_PORTS_ARBITRATED 4096

LONG
WINAPI
ComDBOpen (
    PHCOMDB PHComDB
    );
/*++

Routine Description:

    Opens name data base, and returns a handle to be used in future calls.

Arguments:

    None.

Return Value:

    INVALID_HANDLE_VALUE if the call fails, otherwise a valid handle

    If INVALID_HANDLE_VALUE, call GetLastError() to get details (??)

--*/

LONG
WINAPI
ComDBClose (
    HCOMDB HComDB
    );
/*++

Routine Description:

    frees a handle to the database returned from OpenComPortDataBase

Arguments:

    Handle returned from OpenComPortDataBase.

Return Value:

    None

--*/

#define CDB_REPORT_BITS      0x0
#define CDB_REPORT_BYTES     0x1

LONG
WINAPI
ComDBGetCurrentPortUsage (
    HCOMDB   HComDB,
    PBYTE    Buffer,
    DWORD    BufferSize,
    ULONG    ReportType, // CDB_REPORT value
    LPDWORD  MaxPortsReported
    );
/*++

Routine Description:

    if Buffer is NULL, than MaxPortsReported will contain the max number of ports
        the DB will report (this value is NOT the number of bytes need for Buffer).
        ReportType is ignored in this case.

    if ReportType == CDB_REPORT_BITS
        returns a bit array indicating if a comX name is claimed.
        ie, Bit 0 of Byte 0 is com1, bit 1 of byte 0 is com2 and so on.

        BufferSize >= MaxPortsReported / 8


    if ReportType == CDB_REPORT_BYTES
        returns a byte array indicating if a comX name is claimed.  Zero unused, non zero
        used, ie, byte 0 is com1, byte 1 is com2, etc

        BufferSize >= MaxPortsReported

Arguments:

    Handle returned from OpenComPortDataBase.

    Buffer pointes to memory to place bit array

    BufferSize   Size of buffer in bytes

    MaxPortsReported    Pointer to DWORD that holds the number of bytes in buffer filled in

Return Value:

    returns ERROR_SUCCESS if successful.
            ERROR_NOT_CONNECTED cannot connect to DB
            ERROR_MORE_DATA if buffer not large enough

--*/


LONG
WINAPI
ComDBClaimNextFreePort (
    HCOMDB   HComDB,
    LPDWORD  ComNumber
    );
/*++

Routine Description:

    returns the first free COMx value

Arguments:

    Handle returned from OpenComPortDataBase.

Return Value:


    returns ERROR_SUCCESS if successful. or other ERROR_ if not

    if successful, then ComNumber will be that next free com value and claims it in the database


--*/



LONG
WINAPI
ComDBClaimPort (
    HCOMDB   HComDB,
    DWORD    ComNumber,
    BOOL     ForceClaim,
    PBOOL    Forced /* optional */
    );
/*++

Routine Description:

    Attempts to claim a com name in the database

Arguments:

    DataBaseHandle - returned from OpenComPortDataBase.

    ComNumber      - The port value to be claimed

    Force          - If TRUE, will force the port to be claimed even if in use already

    Forced         - will reflect the event that the claim was forced

Return Value:


    returns ERROR_SUCCESS if port name was not already claimed, or if it was claimed
                          and Force was TRUE.

            ERROR_SHARING_VIOLATION if port name is use and Force is false


--*/

LONG
WINAPI
ComDBReleasePort (
    HCOMDB   HComDB,
    DWORD    ComNumber
    );
/*++

Routine Description:

    Releases the port in the database

Arguments:

    DatabaseHandle - returned from OpenComPortDataBase.

    ComNumber      - port to be unclaimed in database

Return Value:


    returns ERROR_SUCCESS if successful
            ERROR_CANTWRITE if the changes cannot be committed
            ERROR_INVALID_PARAMETER if ComNumber is greater than the number of
                                    ports arbitrated


--*/

LONG
WINAPI
ComDBResizeDatabase (
    HCOMDB   HComDB,
    DWORD    NewSize
    );
/*++

Routine Description:

    Resizes the database to the new size.  To get the current size, call
    ComDBGetCurrentPortUsage with a Buffer == NULL.

Arguments:

    DatabaseHandle - returned from OpenComPortDataBase.

    NewSize        - must be a multiple of 1024, with a max of 4096

Return Value:


    returns ERROR_SUCCESS if successful
            ERROR_CANTWRITE if the changes cannot be committed
            ERROR_BAD_LENGTH if NewSize is not greater than the current size or
                             NewSize is greater than COMDB_MAX_PORTS_ARBITRATED

--*/


#ifdef __cplusplus
}
#endif


#endif // _MSPORTS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\ddk\inc\ndistapi.h ===
/*++ BUILD Version: 0000    // Increment this if a change has global effects

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    ndiswan.h

Abstract:

    Main header file for the TAPI wrapper

Author:

    Dan Knudson (DanKn)    20-Feb-1994

Revision History:

--*/

#ifndef _NDIS_TAPI_
#define _NDIS_TAPI_

//
//
//
//
// Begin definitions for TAPI
//
//
//
//

#ifndef NDIS_TAPI_CURRENT_VERSION
#define NDIS_TAPI_CURRENT_VERSION 0x00010003
#endif
//
// Symbolic constants
//


#define NDIS_STATUS_TAPI_ADDRESSBLOCKED           ((NDIS_STATUS)0xC0012000L)
#define NDIS_STATUS_TAPI_BEARERMODEUNAVAIL        ((NDIS_STATUS)0xC0012001L)
#define NDIS_STATUS_TAPI_CALLUNAVAIL              ((NDIS_STATUS)0xC0012002L)
#define NDIS_STATUS_TAPI_DIALBILLING              ((NDIS_STATUS)0xC0012003L)
#define NDIS_STATUS_TAPI_DIALDIALTONE             ((NDIS_STATUS)0xC0012004L)
#define NDIS_STATUS_TAPI_DIALPROMPT               ((NDIS_STATUS)0xC0012005L)
#define NDIS_STATUS_TAPI_DIALQUIET                ((NDIS_STATUS)0xC0012006L)
#define NDIS_STATUS_TAPI_INCOMPATIBLEEXTVERSION   ((NDIS_STATUS)0xC0012007L)
#define NDIS_STATUS_TAPI_INUSE                    ((NDIS_STATUS)0xC0012008L)
#define NDIS_STATUS_TAPI_INVALADDRESS             ((NDIS_STATUS)0xC0012009L)
#define NDIS_STATUS_TAPI_INVALADDRESSID           ((NDIS_STATUS)0xC001200AL)
#define NDIS_STATUS_TAPI_INVALADDRESSMODE         ((NDIS_STATUS)0xC001200BL)
#define NDIS_STATUS_TAPI_INVALBEARERMODE          ((NDIS_STATUS)0xC001200CL)
#define NDIS_STATUS_TAPI_INVALCALLHANDLE          ((NDIS_STATUS)0xC001200DL)
#define NDIS_STATUS_TAPI_INVALCALLPARAMS          ((NDIS_STATUS)0xC001200EL)
#define NDIS_STATUS_TAPI_INVALCALLSTATE           ((NDIS_STATUS)0xC001200FL)
#define NDIS_STATUS_TAPI_INVALDEVICECLASS         ((NDIS_STATUS)0xC0012010L)
#define NDIS_STATUS_TAPI_INVALLINEHANDLE          ((NDIS_STATUS)0xC0012011L)
#define NDIS_STATUS_TAPI_INVALLINESTATE           ((NDIS_STATUS)0xC0012012L)
#define NDIS_STATUS_TAPI_INVALMEDIAMODE           ((NDIS_STATUS)0xC0012013L)
#define NDIS_STATUS_TAPI_INVALRATE                ((NDIS_STATUS)0xC0012014L)
#define NDIS_STATUS_TAPI_NODRIVER                 ((NDIS_STATUS)0xC0012015L)
#define NDIS_STATUS_TAPI_OPERATIONUNAVAIL         ((NDIS_STATUS)0xC0012016L)
#define NDIS_STATUS_TAPI_RATEUNAVAIL              ((NDIS_STATUS)0xC0012017L)
#define NDIS_STATUS_TAPI_RESOURCEUNAVAIL          ((NDIS_STATUS)0xC0012018L)
#define NDIS_STATUS_TAPI_STRUCTURETOOSMALL        ((NDIS_STATUS)0xC0012019L)
#define NDIS_STATUS_TAPI_USERUSERINFOTOOBIG       ((NDIS_STATUS)0xC001201AL)
#define NDIS_STATUS_TAPI_ALLOCATED                ((NDIS_STATUS)0xC001201BL)
#define NDIS_STATUS_TAPI_INVALADDRESSSTATE        ((NDIS_STATUS)0xC001201CL)
#define NDIS_STATUS_TAPI_INVALPARAM               ((NDIS_STATUS)0xC001201DL)
#define NDIS_STATUS_TAPI_NODEVICE                 ((NDIS_STATUS)0xC001201EL)

//
//  The following DISCONNECTMODE status codes are used by CO_ADDRESS_FAMILY_TAPI
//  NDIS Call Managers as the NDIS status passed to:
//
//  - Ndis[M]CmMakeCallComplete
//  - Ndis[M]CmDispatchIncomingCloseCall
//
#define NDIS_STATUS_TAPI_DISCONNECTMODE_NORMAL    ((NDIS_STATUS)0xC0012020L)
#define NDIS_STATUS_TAPI_DISCONNECTMODE_UNKNOWN   ((NDIS_STATUS)0xC0012021L)
#define NDIS_STATUS_TAPI_DISCONNECTMODE_REJECT    ((NDIS_STATUS)0xC0012022L)
#define NDIS_STATUS_TAPI_DISCONNECTMODE_PICKUP    ((NDIS_STATUS)0xC0012023L)
#define NDIS_STATUS_TAPI_DISCONNECTMODE_FORWARDED ((NDIS_STATUS)0xC0012024L)
#define NDIS_STATUS_TAPI_DISCONNECTMODE_BUSY      ((NDIS_STATUS)0xC0012025L)
#define NDIS_STATUS_TAPI_DISCONNECTMODE_NOANSWER  ((NDIS_STATUS)0xC0012026L)
#define NDIS_STATUS_TAPI_DISCONNECTMODE_BADADDRESS   ((NDIS_STATUS)0xC0012027L)
#define NDIS_STATUS_TAPI_DISCONNECTMODE_UNREACHABLE  ((NDIS_STATUS)0xC0012028L)
#define NDIS_STATUS_TAPI_DISCONNECTMODE_CONGESTION   ((NDIS_STATUS)0xC0012029L)
#define NDIS_STATUS_TAPI_DISCONNECTMODE_INCOMPATIBLE ((NDIS_STATUS)0xC001202AL)
#define NDIS_STATUS_TAPI_DISCONNECTMODE_UNAVAIL    ((NDIS_STATUS)0xC001202BL)


#define NDIS_STATUS_TAPI_RECV_DIGIT					((NDIS_STATUS)0x40010020L) // FIXME: Should this be in ndis.h?

#define LINE_ADDRESSSTATE                           0L
#define LINE_CALLINFO                               1L
#define LINE_CALLSTATE                              2L
#define LINE_CLOSE                                  3L
#define LINE_DEVSPECIFIC                            4L
#define LINE_DEVSPECIFICFEATURE                     5L  // not used
#define LINE_GATHERDIGITS                           6L  // not used
#define LINE_GENERATE                               7L  // not used
#define LINE_LINEDEVSTATE                           8L
#define LINE_MONITORDIGITS                          9L  // not used
#define LINE_MONITORMEDIA                           10L // not used
#define LINE_MONITORTONE                            11L // not used
#define LINE_REPLY                                  12L // not used
#define LINE_REQUEST                                13L // not used
#define LINE_CREATE                             	19L // TAPI v1.4

#if (NDIS_TAPI_CURRENT_VERSION >= 0x00020000)
#define LINE_AGENTSPECIFIC                      21L             // TAPI v2.0
#define LINE_AGENTSTATUS                        22L             // TAPI v2.0
#define LINE_APPNEWCALL                         23L             // TAPI v2.0
#define LINE_PROXYREQUEST                       24L             // TAPI v2.0
#define LINE_REMOVE                             25L             // TAPI v2.0
#endif


#if (NDIS_TAPI_CURRENT_VERSION >= 0x00020002)
#define LINE_AGENTSESSIONSTATUS                 27L             // TAPI v2.2
#define LINE_QUEUESTATUS                        28L             // TAPI v2.2
#define LINE_AGENTSTATUSEX                      29L             // TAPI v2.2
#define LINE_GROUPSTATUS                        30L             // TAPI v2.2
#define LINE_PROXYSTATUS                        31L             // TAPI v2.2
#endif


#if (TAPI_CURRENT_VERSION >= 0x00030000)
#define LINE_APPNEWCALLHUB                      32L             // TAPI v3.0
#define LINE_CALLHUBCLOSE                       33L             // TAPI v3.0
#define LINE_DEVSPECIFICEX                      34L             // TAPI v3.0
#endif


#define TSPI_MESSAGE_BASE                           500L

#define LINE_NEWCALL                                TSPI_MESSAGE_BASE
#define LINE_CALLDEVSPECIFIC                        (TSPI_MESSAGE_BASE + 1L)

#ifndef __NDISTAPI_STRINGFORMATS_DEFINED
#define __NDISTAPI_STRINGFORMATS_DEFINED

#define STRINGFORMAT_ASCII                          0x00000001
#define STRINGFORMAT_DBCS                           0x00000002
#define STRINGFORMAT_UNICODE                        0x00000003
#define STRINGFORMAT_BINARY                         0x00000004

#endif	// __NDISTAPI_STRINGFORMATS_DEFINED

#define LINEADDRCAPFLAGS_FWDNUMRINGS                0x00000001
#define LINEADDRCAPFLAGS_PICKUPGROUPID              0x00000002
#define LINEADDRCAPFLAGS_SECURE                     0x00000004
#define LINEADDRCAPFLAGS_BLOCKIDDEFAULT             0x00000008
#define LINEADDRCAPFLAGS_BLOCKIDOVERRIDE            0x00000010
#define LINEADDRCAPFLAGS_DIALED                     0x00000020
#define LINEADDRCAPFLAGS_ORIGOFFHOOK                0x00000040
#define LINEADDRCAPFLAGS_DESTOFFHOOK                0x00000080
#define LINEADDRCAPFLAGS_FWDCONSULT                 0x00000100
#define LINEADDRCAPFLAGS_SETUPCONFNULL              0x00000200
#define LINEADDRCAPFLAGS_AUTORECONNECT              0x00000400
#define LINEADDRCAPFLAGS_COMPLETIONID               0x00000800
#define LINEADDRCAPFLAGS_TRANSFERHELD               0x00001000
#define LINEADDRCAPFLAGS_TRANSFERMAKE               0x00002000
#define LINEADDRCAPFLAGS_CONFERENCEHELD             0x00004000
#define LINEADDRCAPFLAGS_CONFERENCEMAKE             0x00008000
#define LINEADDRCAPFLAGS_PARTIALDIAL                0x00010000
#define LINEADDRCAPFLAGS_FWDSTATUSVALID             0x00020000
#define LINEADDRCAPFLAGS_FWDINTEXTADDR              0x00040000
#define LINEADDRCAPFLAGS_FWDBUSYNAADDR              0x00080000
#define LINEADDRCAPFLAGS_ACCEPTTOALERT              0x00100000
#define LINEADDRCAPFLAGS_CONFDROP                   0x00200000
#define LINEADDRCAPFLAGS_PICKUPCALLWAIT             0x00400000
#if (NDIS_TAPI_CURRENT_VERSION >= 0x00020000)
#define LINEADDRCAPFLAGS_PREDICTIVEDIALER      		0x00800000      // TAPI v2.0
#define LINEADDRCAPFLAGS_QUEUE                  	0x01000000      // TAPI v2.0
#define LINEADDRCAPFLAGS_ROUTEPOINT             	0x02000000      // TAPI v2.0
#define LINEADDRCAPFLAGS_HOLDMAKESNEW           	0x04000000      // TAPI v2.0
#define LINEADDRCAPFLAGS_NOINTERNALCALLS        	0x08000000      // TAPI v2.0
#define LINEADDRCAPFLAGS_NOEXTERNALCALLS        	0x10000000      // TAPI v2.0
#define LINEADDRCAPFLAGS_SETCALLINGID           	0x20000000      // TAPI v2.0
#endif
#if (NDIS_TAPI_CURRENT_VERSION >= 0x00030000)
#define LINEADDRCAPFLAGS_ACDGROUP               	0x40000000      // TAPI v3.0
#define LINEADDRCAPFLAGS_NOPSTNADDRESSTRANSLATION 	0x80000000    // TAPI v3.0
#endif


#define LINEADDRESSMODE_ADDRESSID                   0x00000001
#define LINEADDRESSMODE_DIALABLEADDR                0x00000002

#define LINEADDRESSSHARING_PRIVATE                  0x00000001
#define LINEADDRESSSHARING_BRIDGEDEXCL              0x00000002
#define LINEADDRESSSHARING_BRIDGEDNEW               0x00000004
#define LINEADDRESSSHARING_BRIDGEDSHARED            0x00000008
#define LINEADDRESSSHARING_MONITORED                0x00000010

#define LINEADDRESSSTATE_OTHER                      0x00000001
#define LINEADDRESSSTATE_DEVSPECIFIC                0x00000002
#define LINEADDRESSSTATE_INUSEZERO                  0x00000004
#define LINEADDRESSSTATE_INUSEONE                   0x00000008
#define LINEADDRESSSTATE_INUSEMANY                  0x00000010
#define LINEADDRESSSTATE_NUMCALLS                   0x00000020
#define LINEADDRESSSTATE_FORWARD                    0x00000040
#define LINEADDRESSSTATE_TERMINALS                  0x00000080

#if (NDIS_TAPI_CURRENT_VERSION >= 0x00030000)
#define LINEADDRESSTYPE_PHONENUMBER             0x00000001
#define LINEADDRESSTYPE_SDP                     0x00000002
#define LINEADDRESSTYPE_EMAILNAME               0x00000004
#define LINEADDRESSTYPE_DOMAINNAME              0x00000008
#define LINEADDRESSTYPE_IPADDRESS               0x00000010
#endif

#define LINEADDRFEATURE_FORWARD                     0x00000001
#define LINEADDRFEATURE_MAKECALL                    0x00000002
#define LINEADDRFEATURE_PICKUP                      0x00000004
#define LINEADDRFEATURE_SETMEDIACONTROL             0x00000008
#define LINEADDRFEATURE_SETTERMINAL                 0x00000010
#define LINEADDRFEATURE_SETUPCONF                   0x00000020
#define LINEADDRFEATURE_UNCOMPLETECALL              0x00000040
#define LINEADDRFEATURE_UNPARK                      0x00000080
#if (NDIS_TAPI_CURRENT_VERSION >= 0x00020000)
#define LINEADDRFEATURE_PICKUPHELD              0x00000100      // TAPI v2.0
#define LINEADDRFEATURE_PICKUPGROUP             0x00000200      // TAPI v2.0
#define LINEADDRFEATURE_PICKUPDIRECT            0x00000400      // TAPI v2.0
#define LINEADDRFEATURE_PICKUPWAITING           0x00000800      // TAPI v2.0
#define LINEADDRFEATURE_FORWARDFWD              0x00001000      // TAPI v2.0
#define LINEADDRFEATURE_FORWARDDND              0x00002000      // TAPI v2.0
#endif


#define LINEANSWERMODE_NONE                         0x00000001
#define LINEANSWERMODE_DROP                         0x00000002
#define LINEANSWERMODE_HOLD                         0x00000004

#define LINEBEARERMODE_VOICE                        0x00000001
#define LINEBEARERMODE_SPEECH                       0x00000002
#define LINEBEARERMODE_MULTIUSE                     0x00000004
#define LINEBEARERMODE_DATA                         0x00000008
#define LINEBEARERMODE_ALTSPEECHDATA                0x00000010
#define LINEBEARERMODE_NONCALLSIGNALING             0x00000020
#define LINEBEARERMODE_PASSTHROUGH              0x00000040      // TAPI v1.4
#if (NDIS_TAPI_CURRENT_VERSION >= 0x00020000)
#define LINEBEARERMODE_RESTRICTEDDATA           0x00000080      // TAPI v2.0
#endif

#define LINEBUSYMODE_STATION                        0x00000001
#define LINEBUSYMODE_TRUNK                          0x00000002
#define LINEBUSYMODE_UNKNOWN                        0x00000004
#define LINEBUSYMODE_UNAVAIL                        0x00000008

#define LINECALLCOMPLCOND_BUSY                      0x00000001
#define LINECALLCOMPLCOND_NOANSWER                  0x00000002

#define LINECALLCOMPLMODE_CAMPON                    0x00000001
#define LINECALLCOMPLMODE_CALLBACK                  0x00000002
#define LINECALLCOMPLMODE_INTRUDE                   0x00000004
#define LINECALLCOMPLMODE_MESSAGE                   0x00000008

#define LINECALLFEATURE_ACCEPT                      0x00000001
#define LINECALLFEATURE_ADDTOCONF                   0x00000002
#define LINECALLFEATURE_ANSWER                      0x00000004
#define LINECALLFEATURE_BLINDTRANSFER               0x00000008
#define LINECALLFEATURE_COMPLETECALL                0x00000010
#define LINECALLFEATURE_COMPLETETRANSF              0x00000020
#define LINECALLFEATURE_DIAL                        0x00000040
#define LINECALLFEATURE_DROP                        0x00000080
#define LINECALLFEATURE_GATHERDIGITS                0x00000100
#define LINECALLFEATURE_GENERATEDIGITS              0x00000200
#define LINECALLFEATURE_GENERATETONE                0x00000400
#define LINECALLFEATURE_HOLD                        0x00000800
#define LINECALLFEATURE_MONITORDIGITS               0x00001000
#define LINECALLFEATURE_MONITORMEDIA                0x00002000
#define LINECALLFEATURE_MONITORTONES                0x00004000
#define LINECALLFEATURE_PARK                        0x00008000
#define LINECALLFEATURE_PREPAREADDCONF              0x00010000
#define LINECALLFEATURE_REDIRECT                    0x00020000
#define LINECALLFEATURE_REMOVEFROMCONF              0x00040000
#define LINECALLFEATURE_SECURECALL                  0x00080000
#define LINECALLFEATURE_SENDUSERUSER                0x00100000
#define LINECALLFEATURE_SETCALLPARAMS               0x00200000
#define LINECALLFEATURE_SETMEDIACONTROL             0x00400000
#define LINECALLFEATURE_SETTERMINAL                 0x00800000
#define LINECALLFEATURE_SETUPCONF                   0x01000000
#define LINECALLFEATURE_SETUPTRANSFER               0x02000000
#define LINECALLFEATURE_SWAPHOLD                    0x04000000
#define LINECALLFEATURE_UNHOLD                      0x08000000
#define LINECALLFEATURE_RELEASEUSERUSERINFO     0x10000000      // TAPI v1.4
#if (NDIS_TAPI_CURRENT_VERSION >= 0x00020000)
#define LINECALLFEATURE_SETTREATMENT            0x20000000      // TAPI v2.0
#define LINECALLFEATURE_SETQOS                  0x40000000      // TAPI v2.0
#define LINECALLFEATURE_SETCALLDATA             0x80000000      // TAPI v2.0
#endif


#define LINECALLINFOSTATE_OTHER                     0x00000001
#define LINECALLINFOSTATE_DEVSPECIFIC               0x00000002
#define LINECALLINFOSTATE_BEARERMODE                0x00000004
#define LINECALLINFOSTATE_RATE                      0x00000008
#define LINECALLINFOSTATE_MEDIAMODE                 0x00000010
#define LINECALLINFOSTATE_APPSPECIFIC               0x00000020
#define LINECALLINFOSTATE_CALLID                    0x00000040
#define LINECALLINFOSTATE_RELATEDCALLID             0x00000080
#define LINECALLINFOSTATE_ORIGIN                    0x00000100
#define LINECALLINFOSTATE_REASON                    0x00000200
#define LINECALLINFOSTATE_COMPLETIONID              0x00000400
#define LINECALLINFOSTATE_NUMOWNERINCR              0x00000800
#define LINECALLINFOSTATE_NUMOWNERDECR              0x00001000
#define LINECALLINFOSTATE_NUMMONITORS               0x00002000
#define LINECALLINFOSTATE_TRUNK                     0x00004000
#define LINECALLINFOSTATE_CALLERID                  0x00008000
#define LINECALLINFOSTATE_CALLEDID                  0x00010000
#define LINECALLINFOSTATE_CONNECTEDID               0x00020000
#define LINECALLINFOSTATE_REDIRECTIONID             0x00040000
#define LINECALLINFOSTATE_REDIRECTINGID             0x00080000
#define LINECALLINFOSTATE_DISPLAY                   0x00100000
#define LINECALLINFOSTATE_USERUSERINFO              0x00200000
#define LINECALLINFOSTATE_HIGHLEVELCOMP             0x00400000
#define LINECALLINFOSTATE_LOWLEVELCOMP              0x00800000
#define LINECALLINFOSTATE_CHARGINGINFO              0x01000000
#define LINECALLINFOSTATE_TERMINAL                  0x02000000
#define LINECALLINFOSTATE_DIALPARAMS                0x04000000
#define LINECALLINFOSTATE_MONITORMODES              0x08000000
#if (NDIS_TAPI_CURRENT_VERSION >= 0x00020000)
#define LINECALLINFOSTATE_TREATMENT             0x10000000      // TAPI v2.0
#define LINECALLINFOSTATE_QOS                   0x20000000      // TAPI v2.0
#define LINECALLINFOSTATE_CALLDATA              0x40000000      // TAPI v2.0
#endif


#define LINECALLORIGIN_OUTBOUND                     0x00000001
#define LINECALLORIGIN_INTERNAL                     0x00000002
#define LINECALLORIGIN_EXTERNAL                     0x00000004
#define LINECALLORIGIN_UNKNOWN                      0x00000010
#define LINECALLORIGIN_UNAVAIL                      0x00000020
#define LINECALLORIGIN_CONFERENCE                   0x00000040
#define LINECALLORIGIN_INBOUND                      0x00000080

#define LINECALLPARAMFLAGS_SECURE                   0x00000001
#define LINECALLPARAMFLAGS_IDLE                     0x00000002
#define LINECALLPARAMFLAGS_BLOCKID                  0x00000004
#define LINECALLPARAMFLAGS_ORIGOFFHOOK              0x00000008
#define LINECALLPARAMFLAGS_DESTOFFHOOK              0x00000010
#if (NDIS_TAPI_CURRENT_VERSION >= 0x00020000)
#define LINECALLPARAMFLAGS_NOHOLDCONFERENCE     0x00000020      // TAPI v2.0
#define LINECALLPARAMFLAGS_PREDICTIVEDIAL       0x00000040      // TAPI v2.0
#define LINECALLPARAMFLAGS_ONESTEPTRANSFER      0x00000080      // TAPI v2.0
#endif


#define LINECALLPARTYID_BLOCKED                     0x00000001
#define LINECALLPARTYID_OUTOFAREA                   0x00000002
#define LINECALLPARTYID_NAME                        0x00000004
#define LINECALLPARTYID_ADDRESS                     0x00000008
#define LINECALLPARTYID_PARTIAL                     0x00000010
#define LINECALLPARTYID_UNKNOWN                     0x00000020
#define LINECALLPARTYID_UNAVAIL                     0x00000040

#define LINECALLPRIVILEGE_NONE                      0x00000001
#define LINECALLPRIVILEGE_MONITOR                   0x00000002
#define LINECALLPRIVILEGE_OWNER                     0x00000004

#define LINECALLREASON_DIRECT                       0x00000001
#define LINECALLREASON_FWDBUSY                      0x00000002
#define LINECALLREASON_FWDNOANSWER                  0x00000004
#define LINECALLREASON_FWDUNCOND                    0x00000008
#define LINECALLREASON_PICKUP                       0x00000010
#define LINECALLREASON_UNPARK                       0x00000020
#define LINECALLREASON_REDIRECT                     0x00000040
#define LINECALLREASON_CALLCOMPLETION               0x00000080
#define LINECALLREASON_TRANSFER                     0x00000100
#define LINECALLREASON_REMINDER                     0x00000200
#define LINECALLREASON_UNKNOWN                      0x00000400
#define LINECALLREASON_UNAVAIL                      0x00000800
#define LINECALLREASON_INTRUDE                  0x00001000      // TAPI v1.4
#define LINECALLREASON_PARKED                   0x00002000      // TAPI v1.4
#if (NDIS_TAPI_CURRENT_VERSION >= 0x00020000)
#define LINECALLREASON_CAMPEDON                 0x00004000      // TAPI v2.0
#define LINECALLREASON_ROUTEREQUEST             0x00008000      // TAPI v2.0
#endif


#define LINECALLSELECT_LINE                         0x00000001
#define LINECALLSELECT_ADDRESS                      0x00000002
#define LINECALLSELECT_CALL                         0x00000004
#if (NDIS_TAPI_CURRENT_VERSION > 0x00020000)
#define LINECALLSELECT_DEVICEID                 0x00000008
#endif
#if (NDIS_TAPI_CURRENT_VERSION >= 0x00030000)
#define LINECALLSELECT_CALLID                   0x00000010
#endif


#define LINECALLSTATE_IDLE                          0x00000001
#define LINECALLSTATE_OFFERING                      0x00000002
#define LINECALLSTATE_ACCEPTED                      0x00000004
#define LINECALLSTATE_DIALTONE                      0x00000008
#define LINECALLSTATE_DIALING                       0x00000010
#define LINECALLSTATE_RINGBACK                      0x00000020
#define LINECALLSTATE_BUSY                          0x00000040
#define LINECALLSTATE_SPECIALINFO                   0x00000080
#define LINECALLSTATE_CONNECTED                     0x00000100
#define LINECALLSTATE_PROCEEDING                    0x00000200
#define LINECALLSTATE_ONHOLD                        0x00000400
#define LINECALLSTATE_CONFERENCED                   0x00000800
#define LINECALLSTATE_ONHOLDPENDCONF                0x00001000
#define LINECALLSTATE_ONHOLDPENDTRANSFER            0x00002000
#define LINECALLSTATE_DISCONNECTED                  0x00004000
#define LINECALLSTATE_UNKNOWN                       0x00008000

#define LINEDEVCAPFLAGS_CROSSADDRCONF               0x00000001
#define LINEDEVCAPFLAGS_HIGHLEVCOMP                 0x00000002
#define LINEDEVCAPFLAGS_LOWLEVCOMP                  0x00000004
#define LINEDEVCAPFLAGS_MEDIACONTROL                0x00000008
#define LINEDEVCAPFLAGS_MULTIPLEADDR                0x00000010
#define LINEDEVCAPFLAGS_CLOSEDROP                   0x00000020
#define LINEDEVCAPFLAGS_DIALBILLING                 0x00000040
#define LINEDEVCAPFLAGS_DIALQUIET                   0x00000080
#define LINEDEVCAPFLAGS_DIALDIALTONE                0x00000100
#if (NDIS_TAPI_CURRENT_VERSION >= 0x00030000)
#define LINEDEVCAPFLAGS_MSP                     0x00000200      // TAPI v3.0
#define LINEDEVCAPFLAGS_CALLHUB                 0x00000400      // TAPI v3.0
#define LINEDEVCAPFLAGS_CALLHUBTRACKING         0x00000800      // TAPI v3.0
#define LINEDEVCAPFLAGS_PRIVATEOBJECTS          0x00001000      // TAPI v3.0
#endif


#define LINEDEVSTATE_OTHER                          0x00000001
#define LINEDEVSTATE_RINGING                        0x00000002
#define LINEDEVSTATE_CONNECTED                      0x00000004
#define LINEDEVSTATE_DISCONNECTED                   0x00000008
#define LINEDEVSTATE_MSGWAITON                      0x00000010
#define LINEDEVSTATE_MSGWAITOFF                     0x00000020
#define LINEDEVSTATE_INSERVICE                      0x00000040
#define LINEDEVSTATE_OUTOFSERVICE                   0x00000080
#define LINEDEVSTATE_MAINTENANCE                    0x00000100
#define LINEDEVSTATE_OPEN                           0x00000200
#define LINEDEVSTATE_CLOSE                          0x00000400
#define LINEDEVSTATE_NUMCALLS                       0x00000800
#define LINEDEVSTATE_NUMCOMPLETIONS                 0x00001000
#define LINEDEVSTATE_TERMINALS                      0x00002000
#define LINEDEVSTATE_ROAMMODE                       0x00004000
#define LINEDEVSTATE_BATTERY                        0x00008000
#define LINEDEVSTATE_SIGNAL                         0x00010000
#define LINEDEVSTATE_DEVSPECIFIC                    0x00020000
#define LINEDEVSTATE_REINIT                         0x00040000
#define LINEDEVSTATE_LOCK                           0x00080000

#define LINEDEVSTATUSFLAGS_CONNECTED                0x00000001
#define LINEDEVSTATUSFLAGS_MSGWAIT                  0x00000002
#define LINEDEVSTATUSFLAGS_INSERVICE                0x00000004
#define LINEDEVSTATUSFLAGS_LOCKED                   0x00000008

#define LINEDIALTONEMODE_NORMAL                     0x00000001
#define LINEDIALTONEMODE_SPECIAL                    0x00000002
#define LINEDIALTONEMODE_INTERNAL                   0x00000004
#define LINEDIALTONEMODE_EXTERNAL                   0x00000008
#define LINEDIALTONEMODE_UNKNOWN                    0x00000010
#define LINEDIALTONEMODE_UNAVAIL                    0x00000020

#define LINEDIGITMODE_PULSE                         0x00000001
#define LINEDIGITMODE_DTMF                          0x00000002
#define LINEDIGITMODE_DTMFEND                       0x00000004

#define LINEDISCONNECTMODE_NORMAL                   0x00000001
#define LINEDISCONNECTMODE_UNKNOWN                  0x00000002
#define LINEDISCONNECTMODE_REJECT                   0x00000004
#define LINEDISCONNECTMODE_PICKUP                   0x00000008
#define LINEDISCONNECTMODE_FORWARDED                0x00000010
#define LINEDISCONNECTMODE_BUSY                     0x00000020
#define LINEDISCONNECTMODE_NOANSWER                 0x00000040
#define LINEDISCONNECTMODE_BADADDRESS               0x00000080
#define LINEDISCONNECTMODE_UNREACHABLE              0x00000100
#define LINEDISCONNECTMODE_CONGESTION               0x00000200
#define LINEDISCONNECTMODE_INCOMPATIBLE             0x00000400
#define LINEDISCONNECTMODE_UNAVAIL                  0x00000800
#define LINEDISCONNECTMODE_NODIALTONE           0x00001000      // TAPI v1.4
#if (NDIS_TAPI_CURRENT_VERSION >= 0x00020000)
#define LINEDISCONNECTMODE_NUMBERCHANGED        0x00002000      // TAPI v2.0
#define LINEDISCONNECTMODE_OUTOFORDER           0x00004000      // TAPI v2.0
#define LINEDISCONNECTMODE_TEMPFAILURE          0x00008000      // TAPI v2.0
#define LINEDISCONNECTMODE_QOSUNAVAIL           0x00010000      // TAPI v2.0
#define LINEDISCONNECTMODE_BLOCKED              0x00020000      // TAPI v2.0
#define LINEDISCONNECTMODE_DONOTDISTURB         0x00040000      // TAPI v2.0
#define LINEDISCONNECTMODE_CANCELLED            0x00080000      // TAPI v2.0
#endif


#define LINEFEATURE_DEVSPECIFIC                     0x00000001
#define LINEFEATURE_DEVSPECIFICFEAT                 0x00000002
#define LINEFEATURE_FORWARD                         0x00000004
#define LINEFEATURE_MAKECALL                        0x00000008
#define LINEFEATURE_SETMEDIACONTROL                 0x00000010
#define LINEFEATURE_SETTERMINAL                     0x00000020
#if (NDIS_TAPI_CURRENT_VERSION >= 0x00020000)
#define LINEFEATURE_SETDEVSTATUS                0x00000040      // TAPI v2.0
#define LINEFEATURE_FORWARDFWD                  0x00000080      // TAPI v2.0
#define LINEFEATURE_FORWARDDND                  0x00000100      // TAPI v2.0
#endif


#define LINEFORWARDMODE_UNCOND                      0x00000001
#define LINEFORWARDMODE_UNCONDINTERNAL              0x00000002
#define LINEFORWARDMODE_UNCONDEXTERNAL              0x00000004
#define LINEFORWARDMODE_UNCONDSPECIFIC              0x00000008
#define LINEFORWARDMODE_BUSY                        0x00000010
#define LINEFORWARDMODE_BUSYINTERNAL                0x00000020
#define LINEFORWARDMODE_BUSYEXTERNAL                0x00000040
#define LINEFORWARDMODE_BUSYSPECIFIC                0x00000080
#define LINEFORWARDMODE_NOANSW                      0x00000100
#define LINEFORWARDMODE_NOANSWINTERNAL              0x00000200
#define LINEFORWARDMODE_NOANSWEXTERNAL              0x00000400
#define LINEFORWARDMODE_NOANSWSPECIFIC              0x00000800
#define LINEFORWARDMODE_BUSYNA                      0x00001000
#define LINEFORWARDMODE_BUSYNAINTERNAL              0x00002000
#define LINEFORWARDMODE_BUSYNAEXTERNAL              0x00004000
#define LINEFORWARDMODE_BUSYNASPECIFIC              0x00008000

#define LINEGATHERTERM_BUFFERFULL                   0x00000001
#define LINEGATHERTERM_TERMDIGIT                    0x00000002
#define LINEGATHERTERM_FIRSTTIMEOUT                 0x00000004
#define LINEGATHERTERM_INTERTIMEOUT                 0x00000008
#define LINEGATHERTERM_CANCEL                       0x00000010

#define LINEGENERATETERM_DONE                       0x00000001
#define LINEGENERATETERM_CANCEL                     0x00000002

#define LINEMEDIACONTROL_NONE                       0x00000001
#define LINEMEDIACONTROL_START                      0x00000002
#define LINEMEDIACONTROL_RESET                      0x00000004
#define LINEMEDIACONTROL_PAUSE                      0x00000008
#define LINEMEDIACONTROL_RESUME                     0x00000010
#define LINEMEDIACONTROL_RATEUP                     0x00000020
#define LINEMEDIACONTROL_RATEDOWN                   0x00000040
#define LINEMEDIACONTROL_RATENORMAL                 0x00000080
#define LINEMEDIACONTROL_VOLUMEUP                   0x00000100
#define LINEMEDIACONTROL_VOLUMEDOWN                 0x00000200
#define LINEMEDIACONTROL_VOLUMENORMAL               0x00000400

#define LINEMEDIAMODE_UNKNOWN                       0x00000002
#define LINEMEDIAMODE_INTERACTIVEVOICE              0x00000004
#define LINEMEDIAMODE_AUTOMATEDVOICE                0x00000008
#define LINEMEDIAMODE_DATAMODEM                     0x00000010
#define LINEMEDIAMODE_G3FAX                         0x00000020
#define LINEMEDIAMODE_TDD                           0x00000040
#define LINEMEDIAMODE_G4FAX                         0x00000080
#define LINEMEDIAMODE_DIGITALDATA                   0x00000100
#define LINEMEDIAMODE_TELETEX                       0x00000200
#define LINEMEDIAMODE_VIDEOTEX                      0x00000400
#define LINEMEDIAMODE_TELEX                         0x00000800
#define LINEMEDIAMODE_MIXED                         0x00001000
#define LINEMEDIAMODE_ADSI                          0x00002000

#define LINEMEDIAMODE_VOICEVIEW                 0x00004000      // TAPI v1.4
#define LAST_LINEMEDIAMODE                          0x00004000
#if (NDIS_TAPI_CURRENT_VERSION >= 0x00020001)
#define LINEMEDIAMODE_VIDEO                     0x00008000      // TAPI v2.1
#undef LAST_LINEMEDIAMODE
#define LAST_LINEMEDIAMODE                      0x00008000		// Should override last definition.
#endif




#define LINEPARKMODE_DIRECTED                       0x00000001
#define LINEPARKMODE_NONDIRECTED                    0x00000002

#define LINEREMOVEFROMCONF_NONE                     0x00000001
#define LINEREMOVEFROMCONF_LAST                     0x00000002
#define LINEREMOVEFROMCONF_ANY                      0x00000003

#define LINEREQUESTMODE_MAKECALL                    0x00000001
#define LINEREQUESTMODE_MEDIACALL                   0x00000002
#define LINEREQUESTMODE_DROP                        0x00000004

#define LAST_LINEREQUESTMODE                        LINEREQUESTMODE_MEDIACALL

#define LINEROAMMODE_UNKNOWN                        0x00000001
#define LINEROAMMODE_UNAVAIL                        0x00000002
#define LINEROAMMODE_HOME                           0x00000004
#define LINEROAMMODE_ROAMA                          0x00000008
#define LINEROAMMODE_ROAMB                          0x00000010

#define LINESPECIALINFO_NOCIRCUIT                   0x00000001
#define LINESPECIALINFO_CUSTIRREG                   0x00000002
#define LINESPECIALINFO_REORDER                     0x00000004
#define LINESPECIALINFO_UNKNOWN                     0x00000008
#define LINESPECIALINFO_UNAVAIL                     0x00000010

#define LINETERMDEV_PHONE                           0x00000001
#define LINETERMDEV_HEADSET                         0x00000002
#define LINETERMDEV_SPEAKER                         0x00000004

#define LINETERMMODE_BUTTONS                        0x00000001
#define LINETERMMODE_LAMPS                          0x00000002
#define LINETERMMODE_DISPLAY                        0x00000004
#define LINETERMMODE_RINGER                         0x00000008
#define LINETERMMODE_HOOKSWITCH                     0x00000010
#define LINETERMMODE_MEDIATOLINE                    0x00000020
#define LINETERMMODE_MEDIAFROMLINE                  0x00000040
#define LINETERMMODE_MEDIABIDIRECT                  0x00000080

#define LINETERMSHARING_PRIVATE                     0x00000001
#define LINETERMSHARING_SHAREDEXCL                  0x00000002
#define LINETERMSHARING_SHAREDCONF                  0x00000004

#define LINETONEMODE_CUSTOM                         0x00000001
#define LINETONEMODE_RINGBACK                       0x00000002
#define LINETONEMODE_BUSY                           0x00000004
#define LINETONEMODE_BEEP                           0x00000008
#define LINETONEMODE_BILLING                        0x00000010

#define LINETRANSFERMODE_TRANSFER                   0x00000001
#define LINETRANSFERMODE_CONFERENCE                 0x00000002

#define LINETOLLLISTOPTION_ADD                      0x00000001
#define LINETOLLLISTOPTION_REMOVE                   0x00000002

#define LINETRANSLATEOPTION_CARDOVERRIDE            0x00000001

#define LINETRANSLATERESULT_CANONICAL               0x00000001
#define LINETRANSLATERESULT_INTERNATIONAL           0x00000002
#define LINETRANSLATERESULT_LONGDISTANCE            0x00000004
#define LINETRANSLATERESULT_LOCAL                   0x00000008
#define LINETRANSLATERESULT_INTOLLLIST              0x00000010
#define LINETRANSLATERESULT_NOTINTOLLLIST           0x00000020
#define LINETRANSLATERESULT_DIALBILLING             0x00000040
#define LINETRANSLATERESULT_DIALQUIET               0x00000080
#define LINETRANSLATERESULT_DIALDIALTONE            0x00000100
#define LINETRANSLATERESULT_DIALPROMPT              0x00000200
#if (NDIS_TAPI_CURRENT_VERSION >= 0x00020000)
#define LINETRANSLATERESULT_VOICEDETECT      		0x00000400      // TAPI v2.0
#endif

#if (NDIS_TAPI_CURRENT_VERSION >= 0x00030000)                                           
#define LINETRANSLATERESULT_NOTRANSLATION       	0x00000800      // TAPI v3.0       
#endif              

//
// Type definitions
//

typedef ULONG_PTR HTAPI_LINE;
typedef ULONG_PTR HDRV_LINE;
typedef ULONG_PTR HTAPI_CALL;
typedef ULONG_PTR HDRV_CALL;

typedef struct _LINE_ADDRESS_CAPS
{
    ULONG   ulTotalSize;
    ULONG   ulNeededSize;
    ULONG   ulUsedSize;

    ULONG   ulLineDeviceID;

    ULONG   ulAddressSize;
    ULONG   ulAddressOffset;

    ULONG   ulDevSpecificSize;
    ULONG   ulDevSpecificOffset;

    ULONG   ulAddressSharing;
    ULONG   ulAddressStates;
    ULONG   ulCallInfoStates;
    ULONG   ulCallerIDFlags;
    ULONG   ulCalledIDFlags;
    ULONG   ulConnectedIDFlags;
    ULONG   ulRedirectionIDFlags;
    ULONG   ulRedirectingIDFlags;
    ULONG   ulCallStates;
    ULONG   ulDialToneModes;
    ULONG   ulBusyModes;
    ULONG   ulSpecialInfo;
    ULONG   ulDisconnectModes;

    ULONG   ulMaxNumActiveCalls;
    ULONG   ulMaxNumOnHoldCalls;
    ULONG   ulMaxNumOnHoldPendingCalls;
    ULONG   ulMaxNumConference;
    ULONG   ulMaxNumTransConf;

    ULONG   ulAddrCapFlags;
    ULONG   ulCallFeatures;
    ULONG   ulRemoveFromConfCaps;
    ULONG   ulRemoveFromConfState;
    ULONG   ulTransferModes;
    ULONG   ulParkModes;

    ULONG   ulForwardModes;
    ULONG   ulMaxForwardEntries;
    ULONG   ulMaxSpecificEntries;
    ULONG   ulMinFwdNumRings;
    ULONG   ulMaxFwdNumRings;

    ULONG   ulMaxCallCompletions;
    ULONG   ulCallCompletionConds;
    ULONG   ulCallCompletionModes;
    ULONG   ulNumCompletionMessages;
    ULONG   ulCompletionMsgTextEntrySize;
    ULONG   ulCompletionMsgTextSize;
    ULONG   ulCompletionMsgTextOffset;

#if (NDIS_TAPI_CURRENT_VERSION >= 0x00010004)
    ULONG   ulAddressFeatures;                              // TAPI v1.4

#if (NDIS_TAPI_CURRENT_VERSION >= 0x00020000)
    ULONG   ulPredictiveAutoTransferStates;                 // TAPI v2.0
    ULONG   ulNumCallTreatments;                            // TAPI v2.0
    ULONG   ulCallTreatmentListSize;                        // TAPI v2.0
    ULONG   ulCallTreatmentListOffset;                      // TAPI v2.0
    ULONG   ulDeviceClassesSize;                            // TAPI v2.0
    ULONG   ulDeviceClassesOffset;                          // TAPI v2.0
    ULONG   ulMaxCallDataSize;                              // TAPI v2.0
    ULONG   ulCallFeatures2;                                // TAPI v2.0
    ULONG   ulMaxNoAnswerTimeout;                           // TAPI v2.0
    ULONG   ulConnectedModes;                               // TAPI v2.0
    ULONG   ulOfferingModes;                                // TAPI v2.0
    ULONG   ulAvailableMediaModes;                          // TAPI v2.0
#endif
#endif

} LINE_ADDRESS_CAPS, *PLINE_ADDRESS_CAPS;


typedef struct _LINE_ADDRESS_STATUS
{
    ULONG   ulTotalSize;
    ULONG   ulNeededSize;
    ULONG   ulUsedSize;

    ULONG   ulNumInUse;
    ULONG   ulNumActiveCalls;
    ULONG   ulNumOnHoldCalls;
    ULONG   ulNumOnHoldPendCalls;
    ULONG   ulAddressFeatures;

    ULONG   ulNumRingsNoAnswer;
    ULONG   ulForwardNumEntries;
    ULONG   ulForwardSize;
    ULONG   ulForwardOffset;

    ULONG   ulTerminalModesSize;
    ULONG   ulTerminalModesOffset;

    ULONG   ulDevSpecificSize;
    ULONG   ulDevSpecificOffset;

} LINE_ADDRESS_STATUS, *PLINE_ADDRESS_STATUS;


typedef struct _LINE_DIAL_PARAMS
{
    ULONG   ulDialPause;
    ULONG   ulDialSpeed;
    ULONG   ulDigitDuration;
    ULONG   ulWaitForDialtone;

} LINE_DIAL_PARAMS, *PLINE_DIAL_PARAMS;


typedef struct _LINE_CALL_INFO
{
    ULONG   ulTotalSize;
    ULONG   ulNeededSize;
    ULONG   ulUsedSize;

    ULONG   hLine;
    ULONG   ulLineDeviceID;
    ULONG   ulAddressID;

    ULONG   ulBearerMode;
    ULONG   ulRate;
    ULONG   ulMediaMode;

    ULONG   ulAppSpecific;
    ULONG   ulCallID;
    ULONG   ulRelatedCallID;
    ULONG   ulCallParamFlags;
    ULONG   ulCallStates;

    ULONG   ulMonitorDigitModes;
    ULONG   ulMonitorMediaModes;
    LINE_DIAL_PARAMS    DialParams;

    ULONG   ulOrigin;
    ULONG   ulReason;
    ULONG   ulCompletionID;
    ULONG   ulNumOwners;
    ULONG   ulNumMonitors;

    ULONG   ulCountryCode;
    ULONG   ulTrunk;

    ULONG   ulCallerIDFlags;
    ULONG   ulCallerIDSize;
    ULONG   ulCallerIDOffset;
    ULONG   ulCallerIDNameSize;
    ULONG   ulCallerIDNameOffset;

    ULONG   ulCalledIDFlags;
    ULONG   ulCalledIDSize;
    ULONG   ulCalledIDOffset;
    ULONG   ulCalledIDNameSize;
    ULONG   ulCalledIDNameOffset;

    ULONG   ulConnectedIDFlags;
    ULONG   ulConnectedIDSize;
    ULONG   ulConnectedIDOffset;
    ULONG   ulConnectedIDNameSize;
    ULONG   ulConnectedIDNameOffset;

    ULONG   ulRedirectionIDFlags;
    ULONG   ulRedirectionIDSize;
    ULONG   ulRedirectionIDOffset;
    ULONG   ulRedirectionIDNameSize;
    ULONG   ulRedirectionIDNameOffset;

    ULONG   ulRedirectingIDFlags;
    ULONG   ulRedirectingIDSize;
    ULONG   ulRedirectingIDOffset;
    ULONG   ulRedirectingIDNameSize;
    ULONG   ulRedirectingIDNameOffset;

    ULONG   ulAppNameSize;
    ULONG   ulAppNameOffset;

    ULONG   ulDisplayableAddressSize;
    ULONG   ulDisplayableAddressOffset;

    ULONG   ulCalledPartySize;
    ULONG   ulCalledPartyOffset;

    ULONG   ulCommentSize;
    ULONG   ulCommentOffset;

    ULONG   ulDisplaySize;
    ULONG   ulDisplayOffset;

    ULONG   ulUserUserInfoSize;
    ULONG   ulUserUserInfoOffset;

    ULONG   ulHighLevelCompSize;
    ULONG   ulHighLevelCompOffset;

    ULONG   ulLowLevelCompSize;
    ULONG   ulLowLevelCompOffset;

    ULONG   ulChargingInfoSize;
    ULONG   ulChargingInfoOffset;

    ULONG   ulTerminalModesSize;
    ULONG   ulTerminalModesOffset;

    ULONG   ulDevSpecificSize;
    ULONG   ulDevSpecificOffset;

#if (NDIS_TAPI_CURRENT_VERSION >= 0x00020000)
    ULONG       ulCallTreatment;                                // TAPI v2.0
    ULONG       ulCallDataSize;                                 // TAPI v2.0
    ULONG       ulCallDataOffset;                               // TAPI v2.0
    ULONG       ulSendingFlowspecSize;                          // TAPI v2.0
    ULONG       ulSendingFlowspecOffset;                        // TAPI v2.0
    ULONG       ulReceivingFlowspecSize;                        // TAPI v2.0
    ULONG       ulReceivingFlowspecOffset;                      // TAPI v2.0
#endif

#if (NDIS_TAPI_CURRENT_VERSION >= 0x00030000)
    ULONG       ulCallerIDAddressType;                          // TAPI v3.0
    ULONG       ulCalledIDAddressType;                          // TAPI v3.0
    ULONG       ulConnectedIDAddressType;                       // TAPI v3.0
    ULONG       ulRedirectionIDAddressType;                     // TAPI v3.0
    ULONG       ulRedirectingIDAddressType;                     // TAPI v3.0
#endif

} LINE_CALL_INFO, *PLINE_CALL_INFO;


typedef struct _LINE_CALL_PARAMS        // Defaults:
{
    ULONG   ulTotalSize;                // ---------

    ULONG   ulBearerMode;               // voice
    ULONG   ulMinRate;                  // (3.1kHz)
    ULONG   ulMaxRate;                  // (3.1kHz)
    ULONG   ulMediaMode;                // interactiveVoice

    ULONG   ulCallParamFlags;           // 0
    ULONG   ulAddressMode;              // addressID
    ULONG   ulAddressID;                // (any available)

    LINE_DIAL_PARAMS DialParams;        // (0, 0, 0, 0)

    ULONG   ulOrigAddressSize;          // 0
    ULONG   ulOrigAddressOffset;
    ULONG   ulDisplayableAddressSize;
    ULONG   ulDisplayableAddressOffset;

    ULONG   ulCalledPartySize;          // 0
    ULONG   ulCalledPartyOffset;

    ULONG   ulCommentSize;              // 0
    ULONG   ulCommentOffset;

    ULONG   ulUserUserInfoSize;         // 0
    ULONG   ulUserUserInfoOffset;

    ULONG   ulHighLevelCompSize;        // 0
    ULONG   ulHighLevelCompOffset;

    ULONG   ulLowLevelCompSize;         // 0
    ULONG   ulLowLevelCompOffset;

    ULONG   ulDevSpecificSize;          // 0
    ULONG   ulDevSpecificOffset;

#if (NDIS_TAPI_CURRENT_VERSION >= 0x00020000)
    ULONG       ulPredictiveAutoTransferStates;                 // TAPI v2.0
    ULONG       ulTargetAddressSize;                            // TAPI v2.0
    ULONG       ulTargetAddressOffset;                          // TAPI v2.0
    ULONG       ulSendingFlowspecSize;                          // TAPI v2.0
    ULONG       ulSendingFlowspecOffset;                        // TAPI v2.0
    ULONG       ulReceivingFlowspecSize;                        // TAPI v2.0
    ULONG       ulReceivingFlowspecOffset;                      // TAPI v2.0
    ULONG       ulDeviceClassSize;                              // TAPI v2.0
    ULONG       ulDeviceClassOffset;                            // TAPI v2.0
    ULONG       ulDeviceConfigSize;                             // TAPI v2.0
    ULONG       ulDeviceConfigOffset;                           // TAPI v2.0
    ULONG       ulCallDataSize;                                 // TAPI v2.0
    ULONG       ulCallDataOffset;                               // TAPI v2.0
    ULONG       ulNoAnswerTimeout;                              // TAPI v2.0
    ULONG       ulCallingPartyIDSize;                           // TAPI v2.0
    ULONG       ulCallingPartyIDOffset;                         // TAPI v2.0
#endif

#if (NDIS_TAPI_CURRENT_VERSION >= 0x00030000)
    ULONG       ulAddressType;                                  // TAPI v3.0
#endif

} LINE_CALL_PARAMS, *PLINE_CALL_PARAMS;


typedef struct _LINE_CALL_STATUS
{
    ULONG   ulTotalSize;
    ULONG   ulNeededSize;
    ULONG   ulUsedSize;

    ULONG   ulCallState;
    ULONG   ulCallStateMode;
    ULONG   ulCallPrivilege;
    ULONG   ulCallFeatures;

    ULONG   ulDevSpecificSize;
    ULONG   ulDevSpecificOffset;

} LINE_CALL_STATUS, *PLINE_CALL_STATUS;


typedef struct _LINE_EXTENSION_ID
{
    ULONG   ulExtensionID0;
    ULONG   ulExtensionID1;
    ULONG   ulExtensionID2;
    ULONG   ulExtensionID3;

} LINE_EXTENSION_ID, *PLINE_EXTENSION_ID;


typedef struct _LINE_DEV_CAPS
{
    ULONG   ulTotalSize;
    ULONG   ulNeededSize;
    ULONG   ulUsedSize;

    ULONG   ulProviderInfoSize;
    ULONG   ulProviderInfoOffset;

    ULONG   ulSwitchInfoSize;
    ULONG   ulSwitchInfoOffset;

    ULONG   ulPermanentLineID;
    ULONG   ulLineNameSize;
    ULONG   ulLineNameOffset;
    ULONG   ulStringFormat;

    ULONG   ulAddressModes;
    ULONG   ulNumAddresses;
    ULONG   ulBearerModes;
    ULONG   ulMaxRate;
    ULONG   ulMediaModes;

    ULONG   ulGenerateToneModes;
    ULONG   ulGenerateToneMaxNumFreq;
    ULONG   ulGenerateDigitModes;
    ULONG   ulMonitorToneMaxNumFreq;
    ULONG   ulMonitorToneMaxNumEntries;
    ULONG   ulMonitorDigitModes;
    ULONG   ulGatherDigitsMinTimeout;
    ULONG   ulGatherDigitsMaxTimeout;

    ULONG   ulMedCtlDigitMaxListSize;
    ULONG   ulMedCtlMediaMaxListSize;
    ULONG   ulMedCtlToneMaxListSize;
    ULONG   ulMedCtlCallStateMaxListSize;

    ULONG   ulDevCapFlags;
    ULONG   ulMaxNumActiveCalls;
    ULONG   ulAnswerMode;
    ULONG   ulRingModes;
    ULONG   ulLineStates;

    ULONG   ulUUIAcceptSize;
    ULONG   ulUUIAnswerSize;
    ULONG   ulUUIMakeCallSize;
    ULONG   ulUUIDropSize;
    ULONG   ulUUISendUserUserInfoSize;
    ULONG   ulUUICallInfoSize;

    LINE_DIAL_PARAMS    MinDialParams;
    LINE_DIAL_PARAMS    MaxDialParams;
    LINE_DIAL_PARAMS    DefaultDialParams;

    ULONG   ulNumTerminals;
    ULONG   ulTerminalCapsSize;
    ULONG   ulTerminalCapsOffset;
    ULONG   ulTerminalTextEntrySize;
    ULONG   ulTerminalTextSize;
    ULONG   ulTerminalTextOffset;

    ULONG   ulDevSpecificSize;
    ULONG   ulDevSpecificOffset;

#if (NDIS_TAPI_CURRENT_VERSION >= 0x00010004)
    ULONG   ulLineFeatures;                                 // TAPI v1.4
#endif

#if (NDIS_TAPI_CURRENT_VERSION >= 0x00020000)
    ULONG       ulSettableDevStatus;                            // TAPI v2.0
    ULONG       ulDeviceClassesSize;                            // TAPI v2.0
    ULONG       ulDeviceClassesOffset;                          // TAPI v2.0
#endif

#if (NDIS_TAPI_CURRENT_VERSION >= 0x00020002)
	GUID        PermanentLineGuid;                              // TAPI v3.0
#endif

#if (NDIS_TAPI_CURRENT_VERSION >= 0x00030000)
    ULONG       ulAddressTypes;                                 // TAPI v3.0
    GUID        ProtocolGuid;                                   // TAPI v3.0
    ULONG       ulAvailableTracking;                            // TAPI v3.0    
#endif

} LINE_DEV_CAPS, *PLINE_DEV_CAPS;


typedef struct _LINE_DEV_STATUS
{
    ULONG   ulTotalSize;
    ULONG   ulNeededSize;
    ULONG   ulUsedSize;

    ULONG   ulNumOpens;
    ULONG   ulOpenMediaModes;
    ULONG   ulNumActiveCalls;
    ULONG   ulNumOnHoldCalls;
    ULONG   ulNumOnHoldPendCalls;
    ULONG   ulLineFeatures;
    ULONG   ulNumCallCompletions;
    ULONG   ulRingMode;
    ULONG   ulSignalLevel;
    ULONG   ulBatteryLevel;
    ULONG   ulRoamMode;

    ULONG   ulDevStatusFlags;

    ULONG   ulTerminalModesSize;
    ULONG   ulTerminalModesOffset;

    ULONG   ulDevSpecificSize;
    ULONG   ulDevSpecificOffset;

} LINE_DEV_STATUS, *PLINE_DEV_STATUS;


#ifndef __NDISTAPI_VAR_STRING_DECLARED
#define __NDISTAPI_VAR_STRING_DECLARED

typedef struct _VAR_STRING
{
    ULONG   ulTotalSize;
    ULONG   ulNeededSize;
    ULONG   ulUsedSize;

    ULONG   ulStringFormat;
    ULONG   ulStringSize;
    ULONG   ulStringOffset;

} VAR_STRING, *PVAR_STRING;

#endif // __NDISTAPI_VAR_STRING_DECLARED

typedef struct _NDIS_TAPI_ACCEPT
{
    IN  ULONG       ulRequestID;
    IN  HDRV_CALL   hdCall;
    IN  ULONG       ulUserUserInfoSize;
    IN  UCHAR       UserUserInfo[1];

} NDIS_TAPI_ACCEPT, *PNDIS_TAPI_ACCEPT;


typedef struct _NDIS_TAPI_ANSWER
{
    IN  ULONG       ulRequestID;
    IN  HDRV_CALL   hdCall;
    IN  ULONG       ulUserUserInfoSize;
    IN  UCHAR       UserUserInfo[1];

} NDIS_TAPI_ANSWER, *PNDIS_TAPI_ANSWER;


typedef struct _NDIS_TAPI_CLOSE
{
    IN  ULONG       ulRequestID;
    IN  HDRV_LINE   hdLine;

} NDIS_TAPI_CLOSE, *PNDIS_TAPI_CLOSE;


typedef struct _NDIS_TAPI_CLOSE_CALL
{
    IN  ULONG       ulRequestID;
    IN  HDRV_CALL   hdCall;

} NDIS_TAPI_CLOSE_CALL, *PNDIS_TAPI_CLOSE_CALL;


typedef struct _NDIS_TAPI_CONDITIONAL_MEDIA_DETECTION
{
    IN  ULONG       ulRequestID;
    IN  HDRV_LINE   hdLine;
    IN  ULONG       ulMediaModes;
    IN  LINE_CALL_PARAMS    LineCallParams;

} NDIS_TAPI_CONDITIONAL_MEDIA_DETECTION,
*PNDIS_TAPI_CONDITIONAL_MEDIA_DETECTION;


typedef struct _NDIS_TAPI_CONFIG_DIALOG
{
    IN  ULONG       ulRequestID;
    IN  ULONG       ulDeviceID;
    IN  ULONG       ulDeviceClassSize;
    IN  ULONG       ulDeviceClassOffset;
    IN  ULONG       ulLibraryNameTotalSize;
    OUT ULONG       ulLibraryNameNeededSize;
    OUT CHAR        szLibraryName[1];

} NDIS_TAPI_CONFIG_DIALOG, *PNDIS_TAPI_CONFIG_DIALOG;


typedef struct _NDIS_TAPI_DEV_SPECIFIC
{
    IN  ULONG       ulRequestID;
    IN  HDRV_LINE   hdLine;
    IN  ULONG       ulAddressID;
    IN  HDRV_CALL   hdCall;
    IN OUT  ULONG   ulParamsSize;
    IN OUT  UCHAR   Params[1];

} NDIS_TAPI_DEV_SPECIFIC, *PNDIS_TAPI_DEV_SPECIFIC;


typedef struct _NDIS_TAPI_DIAL
{
    IN  ULONG       ulRequestID;
    IN  HDRV_CALL   hdCall;
    IN  ULONG       ulDestAddressSize;
    IN  CHAR        szDestAddress[1];

} NDIS_TAPI_DIAL, *PNDIS_TAPI_DIAL;


typedef struct _NDIS_TAPI_DROP
{
    IN  ULONG       ulRequestID;
    IN  HDRV_CALL   hdCall;
    IN  ULONG       ulUserUserInfoSize;
    IN  UCHAR       UserUserInfo[1];

} NDIS_TAPI_DROP, *PNDIS_TAPI_DROP;


typedef struct _NDIS_TAPI_GET_ADDRESS_CAPS
{
    IN  ULONG       ulRequestID;
    IN  ULONG       ulDeviceID;
    IN  ULONG       ulAddressID;
    IN  ULONG       ulExtVersion;
    OUT LINE_ADDRESS_CAPS   LineAddressCaps;

} NDIS_TAPI_GET_ADDRESS_CAPS, *PNDIS_TAPI_GET_ADDRESS_CAPS;


typedef struct _NDIS_TAPI_GET_ADDRESS_ID
{
    IN  ULONG       ulRequestID;
    IN  HDRV_LINE   hdLine;
    OUT ULONG       ulAddressID;
    IN  ULONG       ulAddressMode;
    IN  ULONG       ulAddressSize;
    IN  CHAR        szAddress[1];

} NDIS_TAPI_GET_ADDRESS_ID, *PNDIS_TAPI_GET_ADDRESS_ID;


typedef struct _NDIS_TAPI_GET_ADDRESS_STATUS
{
    IN  ULONG       ulRequestID;
    IN  HDRV_LINE   hdLine;
    IN  ULONG       ulAddressID;
    OUT LINE_ADDRESS_STATUS LineAddressStatus;

} NDIS_TAPI_GET_ADDRESS_STATUS, *PNDIS_TAPI_GET_ADDRESS_STATUS;


typedef struct _NDIS_TAPI_GET_CALL_ADDRESS_ID
{
    IN  ULONG       ulRequestID;
    IN  HDRV_CALL   hdCall;
    OUT ULONG       ulAddressID;

} NDIS_TAPI_GET_CALL_ADDRESS_ID, *PNDIS_TAPI_GET_CALL_ADDRESS_ID;


typedef struct _NDIS_TAPI_GET_CALL_INFO
{
    IN  ULONG       ulRequestID;
    IN  HDRV_CALL   hdCall;
    OUT LINE_CALL_INFO  LineCallInfo;

} NDIS_TAPI_GET_CALL_INFO, *PNDIS_TAPI_GET_CALL_INFO;


typedef struct _NDIS_TAPI_GET_CALL_STATUS
{
    IN  ULONG       ulRequestID;
    IN  HDRV_CALL   hdCall;
    OUT LINE_CALL_STATUS    LineCallStatus;

} NDIS_TAPI_GET_CALL_STATUS, *PNDIS_TAPI_GET_CALL_STATUS;


typedef struct _NDIS_TAPI_GET_DEV_CAPS
{
    IN  ULONG       ulRequestID;
    IN  ULONG       ulDeviceID;
    IN  ULONG       ulExtVersion;
    OUT LINE_DEV_CAPS   LineDevCaps;

} NDIS_TAPI_GET_DEV_CAPS, *PNDIS_TAPI_GET_DEV_CAPS;


typedef struct _NDIS_TAPI_GET_DEV_CONFIG
{
    IN  ULONG       ulRequestID;
    IN  ULONG       ulDeviceID;
    IN  ULONG       ulDeviceClassSize;
    IN  ULONG       ulDeviceClassOffset;
    OUT VAR_STRING  DeviceConfig;

} NDIS_TAPI_GET_DEV_CONFIG, *PNDIS_TAPI_GET_DEV_CONFIG;


typedef struct _NDIS_TAPI_GET_EXTENSION_ID
{
    IN  ULONG       ulRequestID;
    IN  ULONG       ulDeviceID;
    OUT LINE_EXTENSION_ID   LineExtensionID;

} NDIS_TAPI_GET_EXTENSION_ID, *PNDIS_TAPI_GET_EXTENSION_ID;


typedef struct _NDIS_TAPI_GET_ID
{
    IN  ULONG       ulRequestID;
    IN  HDRV_LINE   hdLine;
    IN  ULONG       ulAddressID;
    IN  HDRV_CALL   hdCall;
    IN  ULONG       ulSelect;
    IN  ULONG       ulDeviceClassSize;
    IN  ULONG       ulDeviceClassOffset;
    OUT VAR_STRING  DeviceID;

} NDIS_TAPI_GET_ID, *PNDIS_TAPI_GET_ID;


typedef struct _NDIS_TAPI_GET_LINE_DEV_STATUS
{
    IN  ULONG       ulRequestID;
    IN  HDRV_LINE   hdLine;
    OUT LINE_DEV_STATUS LineDevStatus;

} NDIS_TAPI_GET_LINE_DEV_STATUS, *PNDIS_TAPI_GET_LINE_DEV_STATUS;


typedef struct _NDIS_TAPI_MAKE_CALL
{
    IN  ULONG       ulRequestID;
    IN  HDRV_LINE   hdLine;
    IN  HTAPI_CALL  htCall;
    OUT HDRV_CALL   hdCall;
    IN  ULONG       ulDestAddressSize;
    IN  ULONG       ulDestAddressOffset;
    IN  BOOLEAN     bUseDefaultLineCallParams;
    IN  LINE_CALL_PARAMS    LineCallParams;

} NDIS_TAPI_MAKE_CALL, *PNDIS_TAPI_MAKE_CALL;


typedef struct _NDIS_TAPI_NEGOTIATE_EXT_VERSION
{
    IN  ULONG       ulRequestID;
    IN  ULONG       ulDeviceID;
    IN  ULONG       ulLowVersion;
    IN  ULONG       ulHighVersion;
    OUT ULONG       ulExtVersion;

} NDIS_TAPI_NEGOTIATE_EXT_VERSION, *PNDIS_TAPI_NEGOTIATE_EXT_VERSION;


typedef struct _NDIS_TAPI_OPEN
{
    IN  ULONG       ulRequestID;
    IN  ULONG       ulDeviceID;
    IN  HTAPI_LINE  htLine;
    OUT HDRV_LINE   hdLine;

} NDIS_TAPI_OPEN, *PNDIS_TAPI_OPEN;


typedef struct _NDIS_TAPI_PROVIDER_INITIALIZE
{
    IN  ULONG       ulRequestID;
    IN  ULONG       ulDeviceIDBase;
    OUT ULONG       ulNumLineDevs;
    OUT ULONG_PTR   ulProviderID;

} NDIS_TAPI_PROVIDER_INITIALIZE, *PNDIS_TAPI_PROVIDER_INITIALIZE;


typedef struct _NDIS_TAPI_PROVIDER_SHUTDOWN
{
    IN  ULONG       ulRequestID;

} NDIS_TAPI_PROVIDER_SHUTDOWN, *PNDIS_TAPI_PROVIDER_SHUTDOWN;


typedef struct _NDIS_TAPI_SECURE_CALL
{
    IN  ULONG       ulRequestID;
    IN  HDRV_CALL   hdCall;

} NDIS_TAPI_SECURE_CALL, *PNDIS_TAPI_SECURE_CALL;


typedef struct _NDIS_TAPI_SELECT_EXT_VERSION
{
    IN  ULONG       ulRequestID;
    IN  HDRV_LINE   hdLine;
    IN  ULONG       ulExtVersion;

} NDIS_TAPI_SELECT_EXT_VERSION, *PNDIS_TAPI_SELECT_EXT_VERSION;


typedef struct _NDIS_TAPI_SEND_USER_USER_INFO
{
    IN  ULONG       ulRequestID;
    IN  HDRV_CALL   hdCall;
    IN  ULONG       ulUserUserInfoSize;
    IN  UCHAR       UserUserInfo[1];

} NDIS_TAPI_SEND_USER_USER_INFO, *PNDIS_TAPI_SEND_USER_USER_INFO;


typedef struct _NDIS_TAPI_SET_APP_SPECIFIC
{
    IN  ULONG       ulRequestID;
    IN  HDRV_CALL   hdCall;
    IN  ULONG       ulAppSpecific;

} NDIS_TAPI_SET_APP_SPECIFIC, *PNDIS_TAPI_SET_APP_SPECIFIC;


typedef struct _NDIS_TAPI_SET_CALL_PARAMS
{
    IN  ULONG       ulRequestID;
    IN  HDRV_CALL   hdCall;
    IN  ULONG       ulBearerMode;
    IN  ULONG       ulMinRate;
    IN  ULONG       ulMaxRate;
    IN  BOOLEAN     bSetLineDialParams;
    IN  LINE_DIAL_PARAMS    LineDialParams;

} NDIS_TAPI_SET_CALL_PARAMS, *PNDIS_TAPI_SET_CALL_PARAMS;


typedef struct _NDIS_TAPI_SET_DEFAULT_MEDIA_DETECTION
{
    IN  ULONG       ulRequestID;
    IN  HDRV_LINE   hdLine;
    IN  ULONG       ulMediaModes;

} NDIS_TAPI_SET_DEFAULT_MEDIA_DETECTION,
*PNDIS_TAPI_SET_DEFAULT_MEDIA_DETECTION;


typedef struct _NDIS_TAPI_SET_DEV_CONFIG
{
    IN  ULONG       ulRequestID;
    IN  ULONG       ulDeviceID;
    IN  ULONG       ulDeviceClassSize;
    IN  ULONG       ulDeviceClassOffset;
    IN  ULONG       ulDeviceConfigSize;
    IN  UCHAR       DeviceConfig[1];

} NDIS_TAPI_SET_DEV_CONFIG, *PNDIS_TAPI_SET_DEV_CONFIG;


typedef struct _NDIS_TAPI_SET_MEDIA_MODE
{
    IN  ULONG       ulRequestID;
    IN  HDRV_CALL   hdCall;
    IN  ULONG       ulMediaMode;

} NDIS_TAPI_SET_MEDIA_MODE, *PNDIS_TAPI_SET_MEDIA_MODE;


typedef struct _NDIS_TAPI_SET_STATUS_MESSAGES
{
    IN  ULONG       ulRequestID;
    IN  HDRV_LINE   hdLine;
    IN  ULONG       ulLineStates;
    IN  ULONG       ulAddressStates;

} NDIS_TAPI_SET_STATUS_MESSAGES, *PNDIS_TAPI_SET_STATUS_MESSAGES;


typedef struct _NDIS_TAPI_EVENT
{
    IN  HTAPI_LINE  htLine;
    IN  HTAPI_CALL  htCall;
    IN  ULONG       ulMsg;
    IN  ULONG_PTR   ulParam1;
    IN  ULONG_PTR   ulParam2;
    IN  ULONG_PTR   ulParam3;

} NDIS_TAPI_EVENT, *PNDIS_TAPI_EVENT;

typedef struct _NDISTAPI_CHARACTERISTICS {
	PVOID	RequestProc;
	GUID	Guid;
	NDIS_WAN_MEDIUM_SUBTYPE	MediaType;
} NDISTAPI_CHARACTERISTICS, *PNDISTAPI_CHARACTERISTICS;


typedef struct _NDIS_TAPI_GATHER_DIGITS
{
    IN  ULONG       ulRequestID;
	IN 	HDRV_CALL   hdCall;
	IN	ULONG		ulEndToEndID;
	IN	ULONG		ulDigitModes;
	IN	LPWSTR		lpsOrigDigitsBuffer;
	IN	ULONG		ulDigitsBufferOffset;
	IN	ULONG		ulNumDigitsNeeded;
	OUT	ULONG		ulNumDigitsRead;
	OUT	ULONG		ulTickCount;
	OUT	ULONG		ulTerminationReason;
	IN 	ULONG		ulTerminationDigitsMask;
	IN 	ULONG		ulFirstDigitTimeout;
	IN	ULONG		ulInterDigitTimeout;
} NDIS_TAPI_GATHER_DIGITS, *PNDIS_TAPI_GATHER_DIGITS;

typedef struct _NDIS_TAPI_MONITOR_DIGITS
{
	IN	HDRV_CALL	hdCall;
	IN	ULONG		ulDigitModes;
} NDIS_TAPI_MONITOR_DIGITS, *PNDIS_TAPI_MONITOR_DIGITS;

#define CO_TAPI_VERSION                         NDIS_TAPI_CURRENT_VERSION

//
//  The CO_TAPI structures below are meant for TAPI support
//  over CONDIS Call Managers and Miniport Call Managers.
//

//  Structure associated with OID_CO_TAPI_CM_CAPS
//
typedef struct _CO_TAPI_CM_CAPS
{
    OUT ULONG                 ulCoTapiVersion;
    OUT ULONG                 ulNumLines;
    OUT ULONG                 ulFlags;

} CO_TAPI_CM_CAPS, *PCO_TAPI_CM_CAPS;

//
//  Bit definitions for Flags in CO_TAPI_CM_CAPS
//
#define CO_TAPI_FLAG_PER_LINE_CAPS              0x00000001

//
//  Structure associated with OID_CO_TAPI_LINE_CAPS.
//
typedef struct _CO_TAPI_LINE_CAPS
{
    IN  ULONG                 ulLineID;
    OUT ULONG                 ulFlags;
    OUT LINE_DEV_CAPS         LineDevCaps;

} CO_TAPI_LINE_CAPS, *PCO_TAPI_LINE_CAPS;

//
//  Bit definitions for Flags in CO_TAPI_LINE_CAPS
//
#define CO_TAPI_FLAG_PER_ADDRESS_CAPS           0x00000001

//
//  Structure associated with OID_CO_TAPI_ADDRESS_CAPS.
//
typedef struct _CO_TAPI_ADDRESS_CAPS
{
    IN  ULONG                 ulLineID;
    IN  ULONG                 ulAddressID;
    OUT ULONG                 ulFlags;
    OUT LINE_ADDRESS_CAPS     LineAddressCaps;

} CO_TAPI_ADDRESS_CAPS, *PCO_TAPI_ADDRESS_CAPS;


//
//  Special values for Line and Address ID fields:
//
#define CO_TAPI_LINE_ID_UNSPECIFIED             0xFFFFFFFF
#define CO_TAPI_ADDRESS_ID_UNSPECIFIED          0xFFFFFFFF

//
//  Structure associated with OID_CO_TAPI_TRANSLATE_TAPI_CALLPARAMS.
//
typedef struct _CO_TAPI_TRANSLATE_TAPI_CALLPARAMS
{
    IN  ULONG                 ulLineID;
    IN  ULONG                 ulAddressID;
    IN  ULONG                 ulFlags;         // see below
    IN  NDIS_VAR_DATA_DESC    DestAddress;
    IN  NDIS_VAR_DATA_DESC    LineCallParams;  // LINE_CALL_PARAMS
    OUT NDIS_VAR_DATA_DESC    NdisCallParams;  // CO_CALL_PARAMETERS

} CO_TAPI_TRANSLATE_TAPI_CALLPARAMS, *PCO_TAPI_TRANSLATE_TAPI_CALLPARAMS;

//
//  Bit definitions for Flags in CO_TAPI_TRANSLATE_TAPI_CALLPARAMS
//  and CO_TAPI_TRANSLATE_NDIS_CALLPARAMS.
//
#define CO_TAPI_FLAG_OUTGOING_CALL              0x00000001
#define CO_TAPI_FLAG_INCOMING_CALL              0x00000002
#define CO_TAPI_FLAG_USE_DEFAULT_CALLPARAMS		0x00000004


//
//  Structure associated with OID_CO_TAPI_TRANSLATE_NDIS_CALLPARAMS.
//
typedef struct _CO_TAPI_TRANSLATE_NDIS_CALLPARAMS
{
    IN  ULONG                 ulFlags;         // see above
    IN  NDIS_VAR_DATA_DESC    NdisCallParams;  // CO_CALL_PARAMETERS
    OUT NDIS_VAR_DATA_DESC    LineCallInfo;    // LINE_CALL_INFO

} CO_TAPI_TRANSLATE_NDIS_CALLPARAMS, *PCO_TAPI_TRANSLATE_NDIS_CALLPARAMS;


//
//  Structure associated with OID_CO_TAPI_TRANSLATE_SAP.
//
typedef struct _CO_TAPI_TRANSLATE_SAP
{
    IN  ULONG                 ulLineID;
    IN  ULONG                 ulAddressID;
    IN  ULONG                 ulMediaModes;
    IN  ULONG                 Reserved;
    OUT ULONG                 NumberOfSaps;
    OUT NDIS_VAR_DATA_DESC    NdisSapParams[1];   // CO_SAP

} CO_TAPI_TRANSLATE_SAP, *PCO_TAPI_TRANSLATE_SAP;


//
//  Structure associated with OID_CO_TAPI_GET_CALL_DIAGNOSTICS.
//
typedef struct _CO_TAPI_CALL_DIAGNOSTICS
{
    OUT ULONG                 ulOrigin;
    OUT ULONG                 ulReason;
    OUT NDIS_VAR_DATA_DESC    DiagInfo;

} CO_TAPI_CALL_DIAGNOSTICS, *PCO_TAPI_CALL_DIAGNOSTICS;


//
//  Structure used in the Media-specific part of CO_CALL_PARAMETERS
//  for an outgoing call for the CO_ADDRESS_FAMILY_TAPI address family.
//  This is used in NdisClMakeCall/Ndis[M]CmActivateVc, and
//  completion routines.
//
//  This overlays:
//     CO_CALL_PARAMETERS.MediaParameters->MediaSpecific.Parameters[]
//
typedef struct _CO_AF_TAPI_MAKE_CALL_PARAMETERS
{
    IN  ULONG                 ulLineID;
    IN  ULONG                 ulAddressID;
    IN  ULONG                 ulFlags;         // see CO_TAPI_TRANSLATE_TAPI_CALLPARAMS
    IN  NDIS_VAR_DATA_DESC    DestAddress;
    IN  NDIS_VAR_DATA_DESC    LineCallParams;  // LINE_CALL_PARAMS

} CO_AF_TAPI_MAKE_CALL_PARAMETERS, *PCO_AF_TAPI_MAKE_CALL_PARAMETERS;



//
//  Structure used in the Media-specific part of CO_CALL_PARAMETERS
//  for an incoming call for the CO_ADDRESS_FAMILY_TAPI address family.
//  This is used in Ndis[M]CmDispatchIncomingCall/Ndis[M]CmActivateVc
//  and completion routines.
//
//  This overlays:
//     CO_CALL_PARAMETERS.MediaParameters->MediaSpecific.Parameters[]
//
typedef struct _CO_AF_TAPI_INCOMING_CALL_PARAMETERS
{
    IN  ULONG                 ulLineID;
    IN  ULONG                 ulAddressID;
    IN  ULONG                 ulFlags;         // see CO_TAPI_TRANSLATE_TAPI_CALLPARAMS
    IN  NDIS_VAR_DATA_DESC    LineCallInfo;    // LINE_CALL_INFO

} CO_AF_TAPI_INCOMING_CALL_PARAMETERS, *PCO_AF_TAPI_INCOMING_CALL_PARAMETERS;



//
//  Value of SapType in CO_SAP for a Service Access Point on the
//  CO_ADDRESS_FAMILY_TAPI address family.
//
#define AF_TAPI_SAP_TYPE      0x00008000

//
//  Structure used to convey TAPI-style SAP information in the NDIS CO_SAP
//  structure.
//
//  This overlays:
//     CO_SAP.Sap[]
//
typedef struct _CO_AF_TAPI_SAP
{
    IN  ULONG                 ulLineID;
    IN  ULONG                 ulAddressID;
    IN  ULONG                 ulMediaModes;

} CO_AF_TAPI_SAP, *PCO_AF_TAPI_SAP;



#endif // _NDIS_TAPI_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\ddk\inc\ndisguid.h ===
/*++

Copyright (c) 1990-1999  Microsoft Corporation

Module Name:

    ndisguid.h

Abstract:

    GUID definitions for NDIS objects.

Environment:

    User/Kernel mode

Revision History:

--*/



//
//  Guid for Lan Class.
//
DEFINE_GUID(GUID_NDIS_LAN_CLASS,                    0xad498944, 0x762f, 0x11d0, 0x8d, 0xcb, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);

//
//  NDIS global GUIDs
//
DEFINE_GUID(GUID_NDIS_ENUMERATE_ADAPTER,            0x981f2d7f, 0xb1f3, 0x11d0, 0x8d, 0xd7, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_NOTIFY_ADAPTER_REMOVAL,       0x981f2d80, 0xb1f3, 0x11d0, 0x8d, 0xd7, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_NOTIFY_ADAPTER_ARRIVAL,       0x981f2d81, 0xb1f3, 0x11d0, 0x8d, 0xd7, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_ENUMERATE_VC,                 0x981f2d82, 0xb1f3, 0x11d0, 0x8d, 0xd7, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_NOTIFY_VC_REMOVAL,            0x981f2d79, 0xb1f3, 0x11d0, 0x8d, 0xd7, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_NOTIFY_VC_ARRIVAL,            0x182f9e0c, 0xb1f3, 0x11d0, 0x8d, 0xd7, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_NOTIFY_BIND,                  0x5413531c, 0xb1f3, 0x11d0, 0x8d, 0xd7, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_NOTIFY_UNBIND,                0x6e3ce1ec, 0xb1f3, 0x11d0, 0x8d, 0xd7, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_WAKE_ON_MAGIC_PACKET_ONLY,    0xa14f1c97, 0x8839, 0x4f8a, 0x99, 0x96, 0xa2, 0x89, 0x96, 0xeb, 0xbf, 0x1d);


//
//  GUIDs for General Required OIDs
//
DEFINE_GUID(GUID_NDIS_GEN_HARDWARE_STATUS,          0x5ec10354, 0xa61a, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_GEN_MEDIA_SUPPORTED,          0x5ec10355, 0xa61a, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_GEN_MEDIA_IN_USE,             0x5ec10356, 0xa61a, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_GEN_MAXIMUM_LOOKAHEAD,        0x5ec10357, 0xa61a, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_GEN_MAXIMUM_FRAME_SIZE,       0x5ec10358, 0xa61a, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_GEN_LINK_SPEED,               0x5ec10359, 0xa61a, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_GEN_TRANSMIT_BUFFER_SPACE,    0x5ec1035a, 0xa61a, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_GEN_RECEIVE_BUFFER_SPACE,     0x5ec1035b, 0xa61a, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_GEN_TRANSMIT_BLOCK_SIZE,      0x5ec1035c, 0xa61a, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_GEN_RECEIVE_BLOCK_SIZE,       0x5ec1035d, 0xa61a, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_GEN_VENDOR_ID,                0x5ec1035e, 0xa61a, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_GEN_VENDOR_DESCRIPTION,       0x5ec1035f, 0xa61a, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_GEN_CURRENT_PACKET_FILTER,    0x5ec10360, 0xa61a, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_GEN_CURRENT_LOOKAHEAD,        0x5ec10361, 0xa61a, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_GEN_DRIVER_VERSION,           0x5ec10362, 0xa61a, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_GEN_MAXIMUM_TOTAL_SIZE,       0x5ec10363, 0xa61a, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_GEN_MAC_OPTIONS,              0x5ec10365, 0xa61a, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_GEN_MEDIA_CONNECT_STATUS,     0x5ec10366, 0xa61a, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_GEN_MAXIMUM_SEND_PACKETS,     0x5ec10367, 0xa61a, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_GEN_VENDOR_DRIVER_VERSION,    0x447956f9, 0xa61b, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);

//
//  GUIDs for General Required Statistics OIDs
//
DEFINE_GUID(GUID_NDIS_GEN_XMIT_OK,                  0x447956fa, 0xa61b, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_GEN_RCV_OK,                   0x447956fb, 0xa61b, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_GEN_XMIT_ERROR,               0x447956fc, 0xa61b, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_GEN_RCV_ERROR,                0x447956fd, 0xa61b, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_GEN_RCV_NO_BUFFER,            0x447956fe, 0xa61b, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);

//
//  GUIDs for General Required CO-NDIS OIDs
//
DEFINE_GUID(GUID_NDIS_GEN_CO_HARDWARE_STATUS,       0x791ad192, 0xe35c, 0x11d0, 0x96, 0x92, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_GEN_CO_MEDIA_SUPPORTED,       0x791ad193, 0xe35c, 0x11d0, 0x96, 0x92, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_GEN_CO_MEDIA_IN_USE,          0x791ad194, 0xe35c, 0x11d0, 0x96, 0x92, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_GEN_CO_LINK_SPEED,                0x791ad195, 0xe35c, 0x11d0, 0x96, 0x92, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_GEN_CO_VENDOR_ID,             0x791ad196, 0xe35c, 0x11d0, 0x96, 0x92, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_GEN_CO_VENDOR_DESCRIPTION,        0x791ad197, 0xe35c, 0x11d0, 0x96, 0x92, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_GEN_CO_DRIVER_VERSION,            0x791ad198, 0xe35c, 0x11d0, 0x96, 0x92, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_GEN_CO_MAC_OPTIONS,           0x791ad19a, 0xe35c, 0x11d0, 0x96, 0x92, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_GEN_CO_MEDIA_CONNECT_STATUS,  0x791ad19b, 0xe35c, 0x11d0, 0x96, 0x92, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_GEN_CO_VENDOR_DRIVER_VERSION, 0x791ad19c, 0xe35c, 0x11d0, 0x96, 0x92, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_GEN_CO_MINIMUM_LINK_SPEED,    0x791ad19d, 0xe35c, 0x11d0, 0x96, 0x92, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);

//
//  GUIDs for General Required CO-NDIS Statistics OIDs
//
DEFINE_GUID(GUID_NDIS_GEN_CO_XMIT_PDUS_OK,          0x0a214805, 0xe35f, 0x11d0, 0x96, 0x92, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_GEN_CO_RCV_PDUS_OK,           0x0a214806, 0xe35f, 0x11d0, 0x96, 0x92, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_GEN_CO_XMIT_PDUS_ERROR,       0x0a214807, 0xe35f, 0x11d0, 0x96, 0x92, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_GEN_CO_RCV_PDUS_ERROR,        0x0a214808, 0xe35f, 0x11d0, 0x96, 0x92, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_GEN_CO_RCV_PDUS_NO_BUFFER,    0x0a214809, 0xe35f, 0x11d0, 0x96, 0x92, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);

//
//  GUIDs for Required Ethernet OIDs
//
DEFINE_GUID(GUID_NDIS_802_3_PERMANENT_ADDRESS,      0x447956ff, 0xa61b, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_802_3_CURRENT_ADDRESS,        0x44795700, 0xa61b, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_802_3_MULTICAST_LIST,         0x44795701, 0xa61b, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_802_3_MAXIMUM_LIST_SIZE,      0x44795702, 0xa61b, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_802_3_MAC_OPTIONS,            0x44795703, 0xa61b, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);

//
//  GUIDs for Required Ethernet Statistics OIDs
//
DEFINE_GUID(GUID_NDIS_802_3_RCV_ERROR_ALIGNMENT,    0x44795704, 0xa61b, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_802_3_XMIT_ONE_COLLISION,     0x44795705, 0xa61b, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_802_3_XMIT_MORE_COLLISIONS,   0x44795706, 0xa61b, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);

//
//  GUIDs for Required Token-Ring OIDs
//
DEFINE_GUID(GUID_NDIS_802_5_PERMANENT_ADDRESS,      0x44795707, 0xa61b, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_802_5_CURRENT_ADDRESS,        0x44795708, 0xa61b, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_802_5_CURRENT_FUNCTIONAL,     0x44795709, 0xa61b, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_802_5_CURRENT_GROUP,          0x4479570a, 0xa61b, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_802_5_LAST_OPEN_STATUS,       0x4479570b, 0xa61b, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_802_5_CURRENT_RING_STATUS,    0x890a36ec, 0xa61c, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_802_5_CURRENT_RING_STATE,     0xacf14032, 0xa61c, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);

//
//  GUIDs for Required Token-Ring Statistics OIDs
//
DEFINE_GUID(GUID_NDIS_802_5_LINE_ERRORS,            0xacf14033, 0xa61c, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_802_5_LOST_FRAMES,            0xacf14034, 0xa61c, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);

//
//  GUIDs for Required FDDI OIDs
//
DEFINE_GUID(GUID_NDIS_FDDI_LONG_PERMANENT_ADDR,     0xacf14035, 0xa61c, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_FDDI_LONG_CURRENT_ADDR,       0xacf14036, 0xa61c, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_FDDI_LONG_MULTICAST_LIST,     0xacf14037, 0xa61c, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_FDDI_LONG_MAX_LIST_SIZE,      0xacf14038, 0xa61c, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_FDDI_SHORT_PERMANENT_ADDR,    0xacf14039, 0xa61c, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_FDDI_SHORT_CURRENT_ADDR,      0xacf1403a, 0xa61c, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_FDDI_SHORT_MULTICAST_LIST,    0xacf1403b, 0xa61c, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_FDDI_SHORT_MAX_LIST_SIZE,     0xacf1403c, 0xa61c, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);

//
//  GUIDs for Required FDDI Statistics OIDs
//
DEFINE_GUID(GUID_NDIS_FDDI_ATTACHMENT_TYPE,         0xacf1403d, 0xa61c, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_FDDI_UPSTREAM_NODE_LONG,      0xacf1403e, 0xa61c, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_FDDI_DOWNSTREAM_NODE_LONG,    0xacf1403f, 0xa61c, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_FDDI_FRAME_ERRORS,            0xacf14040, 0xa61c, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_FDDI_FRAMES_LOST,             0xacf14041, 0xa61c, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_FDDI_RING_MGT_STATE,          0xacf14042, 0xa61c, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_FDDI_LCT_FAILURES,            0xacf14043, 0xa61c, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_FDDI_LEM_REJECTS,             0xacf14044, 0xa61c, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_FDDI_LCONNECTION_STATE,       0xacf14045, 0xa61c, 0x11d0, 0x8d, 0xd4, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);

//
//  GUIDs for required and optional 802.11 Wireless LAN OIDs
//
DEFINE_GUID(GUID_NDIS_802_11_BSSID,                 0x2504b6c2, 0x1fa5, 0x11d4, 0x97, 0xeb, 0x00, 0xc0, 0x4f, 0x79, 0xc4, 0x03);
DEFINE_GUID(GUID_NDIS_802_11_SSID,                  0x7d2a90ea, 0x2041, 0x11d4, 0x97, 0xeb, 0x00, 0xc0, 0x4f, 0x79, 0xc4, 0x03);
DEFINE_GUID(GUID_NDIS_802_11_NETWORK_TYPES_SUPPORTED,   0x8531d6e6, 0x2041, 0x11d4, 0x97, 0xeb, 0x00, 0xc0, 0x4f, 0x79, 0xc4, 0x03);
DEFINE_GUID(GUID_NDIS_802_11_NETWORK_TYPE_IN_USE,   0x857e2326, 0x2041, 0x11d4, 0x97, 0xeb, 0x00, 0xc0, 0x4f, 0x79, 0xc4, 0x03);
DEFINE_GUID(GUID_NDIS_802_11_POWER_MODE,            0x85be837c, 0x2041, 0x11d4, 0x97, 0xeb, 0x00, 0xc0, 0x4f, 0x79, 0xc4, 0x03);
DEFINE_GUID(GUID_NDIS_802_11_TX_POWER_LEVEL,        0x11e6ba76, 0x2053, 0x11d4, 0x97, 0xeb, 0x00, 0xc0, 0x4f, 0x79, 0xc4, 0x03);
DEFINE_GUID(GUID_NDIS_802_11_RSSI,                  0x1507db16, 0x2053, 0x11d4, 0x97, 0xeb, 0x00, 0xc0, 0x4f, 0x79, 0xc4, 0x03);
DEFINE_GUID(GUID_NDIS_802_11_RSSI_TRIGGER,          0x155689b8, 0x2053, 0x11d4, 0x97, 0xeb, 0x00, 0xc0, 0x4f, 0x79, 0xc4, 0x03);
DEFINE_GUID(GUID_NDIS_802_11_BSSID_LIST,            0x69526f9a, 0x2062, 0x11d4, 0x97, 0xeb, 0x00, 0xc0, 0x4f, 0x79, 0xc4, 0x03);
DEFINE_GUID(GUID_NDIS_802_11_INFRASTRUCTURE_MODE,   0x697d5a7e, 0x2062, 0x11d4, 0x97, 0xeb, 0x00, 0xc0, 0x4f, 0x79, 0xc4, 0x03);
DEFINE_GUID(GUID_NDIS_802_11_FRAGMENTATION_THRESHOLD,   0x69aaa7c4, 0x2062, 0x11d4, 0x97, 0xeb, 0x00, 0xc0, 0x4f, 0x79, 0xc4, 0x03);
DEFINE_GUID(GUID_NDIS_802_11_RTS_THRESHOLD,         0x0134d07e, 0x2064, 0x11d4, 0x97, 0xeb, 0x00, 0xc0, 0x4f, 0x79, 0xc4, 0x03);
DEFINE_GUID(GUID_NDIS_802_11_NUMBER_OF_ANTENNAS,    0x01779336, 0x2064, 0x11d4, 0x97, 0xeb, 0x00, 0xc0, 0x4f, 0x79, 0xc4, 0x03);
DEFINE_GUID(GUID_NDIS_802_11_RX_ANTENNA_SELECTED,   0x01ac07a2, 0x2064, 0x11d4, 0x97, 0xeb, 0x00, 0xc0, 0x4f, 0x79, 0xc4, 0x03);
DEFINE_GUID(GUID_NDIS_802_11_TX_ANTENNA_SELECTED,   0x01dbb74a, 0x2064, 0x11d4, 0x97, 0xeb, 0x00, 0xc0, 0x4f, 0x79, 0xc4, 0x03);
DEFINE_GUID(GUID_NDIS_802_11_RATES_SUPPORTED,       0x49db8722, 0x2068, 0x11d4, 0x97, 0xeb, 0x00, 0xc0, 0x4f, 0x79, 0xc4, 0x03);
DEFINE_GUID(GUID_NDIS_802_11_BASIC_RATES,           0x4a198516, 0x2068, 0x11d4, 0x97, 0xeb, 0x00, 0xc0, 0x4f, 0x79, 0xc4, 0x03);
DEFINE_GUID(GUID_NDIS_802_11_DESIRED_RATES,         0x452ee08e, 0x2536, 0x11d4, 0x97, 0xeb, 0x00, 0xc0, 0x4f, 0x79, 0xc4, 0x03);
DEFINE_GUID(GUID_NDIS_802_11_CONFIGURATION,         0x4a4df982, 0x2068, 0x11d4, 0x97, 0xeb, 0x00, 0xc0, 0x4f, 0x79, 0xc4, 0x03);
DEFINE_GUID(GUID_NDIS_802_11_STATISTICS,            0x42bb73b0, 0x2129, 0x11d4, 0x97, 0xeb, 0x00, 0xc0, 0x4f, 0x79, 0xc4, 0x03);
DEFINE_GUID(GUID_NDIS_802_11_ADD_WEP,               0x4307bff0, 0x2129, 0x11d4, 0x97, 0xeb, 0x00, 0xc0, 0x4f, 0x79, 0xc4, 0x03);
DEFINE_GUID(GUID_NDIS_802_11_REMOVE_WEP,            0x433c345c, 0x2129, 0x11d4, 0x97, 0xeb, 0x00, 0xc0, 0x4f, 0x79, 0xc4, 0x03);
DEFINE_GUID(GUID_NDIS_802_11_DISASSOCIATE,          0x43671f40, 0x2129, 0x11d4, 0x97, 0xeb, 0x00, 0xc0, 0x4f, 0x79, 0xc4, 0x03);
DEFINE_GUID(GUID_NDIS_802_11_AUTHENTICATION_MODE,   0x43920a24, 0x2129, 0x11d4, 0x97, 0xeb, 0x00, 0xc0, 0x4f, 0x79, 0xc4, 0x03);
DEFINE_GUID(GUID_NDIS_802_11_PRIVACY_FILTER,        0x6733c4e9, 0x4792, 0x11d4, 0x97, 0xf1, 0x00, 0xc0, 0x4f, 0x79, 0xc4, 0x03);


//
//  GUIDs for Required ATM OIDs
//
DEFINE_GUID(GUID_NDIS_ATM_SUPPORTED_VC_RATES,       0x791ad19e, 0xe35c, 0x11d0, 0x96, 0x92, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_ATM_SUPPORTED_SERVICE_CATEGORY, 0x791ad19f, 0xe35c, 0x11d0, 0x96, 0x92, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_ATM_SUPPORTED_AAL_TYPES,      0x791ad1a0, 0xe35c, 0x11d0, 0x96, 0x92, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_ATM_HW_CURRENT_ADDRESS,       0x791ad1a1, 0xe35c, 0x11d0, 0x96, 0x92, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_ATM_MAX_ACTIVE_VCS,           0x791ad1a2, 0xe35c, 0x11d0, 0x96, 0x92, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_ATM_MAX_ACTIVE_VCI_BITS,      0x791ad1a3, 0xe35c, 0x11d0, 0x96, 0x92, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_ATM_MAX_ACTIVE_VPI_BITS,      0x791ad1a4, 0xe35c, 0x11d0, 0x96, 0x92, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_ATM_MAX_AAL0_PACKET_SIZE,     0x791ad1a5, 0xe35c, 0x11d0, 0x96, 0x92, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_ATM_MAX_AAL1_PACKET_SIZE,     0x791ad1a6, 0xe35c, 0x11d0, 0x96, 0x92, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_ATM_MAX_AAL34_PACKET_SIZE,    0x791ad1a7, 0xe35c, 0x11d0, 0x96, 0x92, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_ATM_MAX_AAL5_PACKET_SIZE,     0x791ad191, 0xe35c, 0x11d0, 0x96, 0x92, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);

//
//  GUIDs for Required ATM OIDs
//
DEFINE_GUID(GUID_NDIS_ATM_RCV_CELLS_OK,             0x0a21480a, 0xe35f, 0x11d0, 0x96, 0x92, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_ATM_XMIT_CELLS_OK,            0x0a21480b, 0xe35f, 0x11d0, 0x96, 0x92, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_ATM_RCV_CELLS_DROPPED,        0x0a21480c, 0xe35f, 0x11d0, 0x96, 0x92, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);

//
//  GUIDs for NDIS status indications
//

DEFINE_GUID(GUID_NDIS_STATUS_RESET_START,           0x981f2d76, 0xb1f3, 0x11d0, 0x8d, 0xd7, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_STATUS_RESET_END,             0x981f2d77, 0xb1f3, 0x11d0, 0x8d, 0xd7, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_STATUS_MEDIA_CONNECT,         0x981f2d7d, 0xb1f3, 0x11d0, 0x8d, 0xd7, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_STATUS_MEDIA_DISCONNECT,      0x981f2d7e, 0xb1f3, 0x11d0, 0x8d, 0xd7, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_STATUS_MEDIA_SPECIFIC_INDICATION, 0x981f2d84, 0xb1f3, 0x11d0, 0x8d, 0xd7, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
DEFINE_GUID(GUID_NDIS_STATUS_LINK_SPEED_CHANGE,     0x981f2d85, 0xb1f3, 0x11d0, 0x8d, 0xd7, 0x00, 0xc0, 0x4f, 0xc3, 0x35, 0x8c);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\ddk\inc\netpnp.h ===
#ifndef __NET_PNP__
#define __NET_PNP__

//
//  PnP and PM event codes that can be indicated up to transports
//  and clients.
//
typedef enum _NET_PNP_EVENT_CODE
{
    NetEventSetPower,
    NetEventQueryPower,
    NetEventQueryRemoveDevice,
    NetEventCancelRemoveDevice,
    NetEventReconfigure,
    NetEventBindList,
    NetEventBindsComplete,
    NetEventPnPCapabilities,
    NetEventMaximum
} NET_PNP_EVENT_CODE, *PNET_PNP_EVENT_CODE;

//
//  Networking PnP event indication structure.
//
typedef struct _NET_PNP_EVENT
{
    //
    //  Event code describing action to take.
    //
    NET_PNP_EVENT_CODE  NetEvent;

    //
    //  Event specific data.
    //
    PVOID               Buffer;

    //
    //  Length of event specific data.
    //
    ULONG               BufferLength;

    //
    //  Reserved values are for use by respective components only.
    //
    //  Note: these reserved areas must be pointer aligned.
    //  

    ULONG_PTR           NdisReserved[4];
    ULONG_PTR           TransportReserved[4];
    ULONG_PTR           TdiReserved[4];
    ULONG_PTR           TdiClientReserved[4];
} NET_PNP_EVENT, *PNET_PNP_EVENT;

//
//  The following structure defines the device power states.
//
typedef enum _NET_DEVICE_POWER_STATE
{
    NetDeviceStateUnspecified = 0,
    NetDeviceStateD0,
    NetDeviceStateD1,
    NetDeviceStateD2,
    NetDeviceStateD3,
    NetDeviceStateMaximum
} NET_DEVICE_POWER_STATE, *PNET_DEVICE_POWER_STATE;

#endif // __NET_PNP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\ddk\inc\ndiswan.h ===
/*++ BUILD Version: 0000    // Increment this if a change has global effects

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    ndiswan.h

Abstract:

    Main header file for the wan wrapper

Author:

    Thomas J. Dimitri (TommyD)  20-Feb-1994

Revision History:

--*/


#ifndef _NDIS_WAN_
#define _NDIS_WAN_

//
// Begin definitions for WANs
//

//
// Bit field set int he Reserved field for
// NdisRegisterMiniport or passed in NdisRegisterSpecial
//

#define NDIS_USE_WAN_WRAPPER            0x00000001

#define NDIS_STATUS_TAPI_INDICATION ((NDIS_STATUS)0x40010080L)


//
// NDIS WAN Framing bits
//
#define RAS_FRAMING                     0x00000001
#define RAS_COMPRESSION                 0x00000002

#define ARAP_V1_FRAMING                 0x00000004
#define ARAP_V2_FRAMING                 0x00000008
#define ARAP_FRAMING                    (ARAP_V1_FRAMING | ARAP_V2_FRAMING)

#define PPP_MULTILINK_FRAMING           0x00000010
#define PPP_SHORT_SEQUENCE_HDR_FORMAT   0x00000020
#define PPP_MC_MULTILINK_FRAMING        0x00000040

#define PPP_FRAMING                     0x00000100
#define PPP_COMPRESS_ADDRESS_CONTROL    0x00000200
#define PPP_COMPRESS_PROTOCOL_FIELD     0x00000400
#define PPP_ACCM_SUPPORTED              0x00000800

#define SLIP_FRAMING                    0x00001000
#define SLIP_VJ_COMPRESSION             0x00002000
#define SLIP_VJ_AUTODETECT              0x00004000

#define MEDIA_NRZ_ENCODING              0x00010000
#define MEDIA_NRZI_ENCODING             0x00020000
#define MEDIA_NLPID                     0x00040000

#define RFC_1356_FRAMING                0x00100000
#define RFC_1483_FRAMING                0x00200000
#define RFC_1490_FRAMING                0x00400000
#define LLC_ENCAPSULATION               0x00800000

#define SHIVA_FRAMING                   0x01000000
#define NBF_PRESERVE_MAC_ADDRESS        0x01000000

#ifndef _WAN50_
#define PASS_THROUGH_MODE               0x10000000
#define RAW_PASS_THROUGH_MODE           0x20000000
#endif

#define TAPI_PROVIDER                   0x80000000

//
// NDIS WAN Information structures used
// by NDIS 3.1 Wan Miniport drivers
//
typedef struct _NDIS_WAN_INFO
{
    OUT ULONG           MaxFrameSize;
    OUT ULONG           MaxTransmit;
    OUT ULONG           HeaderPadding;
    OUT ULONG           TailPadding;
    OUT ULONG           Endpoints;
    OUT UINT            MemoryFlags;
    OUT NDIS_PHYSICAL_ADDRESS HighestAcceptableAddress;
    OUT ULONG           FramingBits;
    OUT ULONG           DesiredACCM;
} NDIS_WAN_INFO, *PNDIS_WAN_INFO;

typedef struct _NDIS_WAN_SET_LINK_INFO
{
    IN  NDIS_HANDLE     NdisLinkHandle;
    IN  ULONG           MaxSendFrameSize;
    IN  ULONG           MaxRecvFrameSize;
        ULONG           HeaderPadding;
        ULONG           TailPadding;
    IN  ULONG           SendFramingBits;
    IN  ULONG           RecvFramingBits;
    IN  ULONG           SendCompressionBits;
    IN  ULONG           RecvCompressionBits;
    IN  ULONG           SendACCM;
    IN  ULONG           RecvACCM;
} NDIS_WAN_SET_LINK_INFO, *PNDIS_WAN_SET_LINK_INFO;

typedef struct _NDIS_WAN_GET_LINK_INFO {
    IN  NDIS_HANDLE     NdisLinkHandle;
    OUT ULONG           MaxSendFrameSize;
    OUT ULONG           MaxRecvFrameSize;
    OUT ULONG           HeaderPadding;
    OUT ULONG           TailPadding;
    OUT ULONG           SendFramingBits;
    OUT ULONG           RecvFramingBits;
    OUT ULONG           SendCompressionBits;
    OUT ULONG           RecvCompressionBits;
    OUT ULONG           SendACCM;
    OUT ULONG           RecvACCM;
} NDIS_WAN_GET_LINK_INFO, *PNDIS_WAN_GET_LINK_INFO;

//
// NDIS WAN Bridging Options
//
#define BRIDGING_FLAG_LANFCS            0x00000001
#define BRIDGING_FLAG_LANID             0x00000002
#define BRIDGING_FLAG_PADDING           0x00000004

//
// NDIS WAN Bridging Capabilities
//
#define BRIDGING_TINYGRAM               0x00000001
#define BRIDGING_LANID                  0x00000002
#define BRIDGING_NO_SPANNING_TREE       0x00000004
#define BRIDGING_8021D_SPANNING_TREE    0x00000008
#define BRIDGING_8021G_SPANNING_TREE    0x00000010
#define BRIDGING_SOURCE_ROUTING         0x00000020
#define BRIDGING_DEC_LANBRIDGE          0x00000040

//
// NDIS WAN Bridging Type
//
#define BRIDGING_TYPE_RESERVED          0x00000001
#define BRIDGING_TYPE_8023_CANON        0x00000002
#define BRIDGING_TYPE_8024_NO_CANON     0x00000004
#define BRIDGING_TYPE_8025_NO_CANON     0x00000008
#define BRIDGING_TYPE_FDDI_NO_CANON     0x00000010
#define BRIDGING_TYPE_8024_CANON        0x00000400
#define BRIDGING_TYPE_8025_CANON        0x00000800
#define BRIDGING_TYPE_FDDI_CANON        0x00001000

typedef struct _NDIS_WAN_GET_BRIDGE_INFO
{
    IN  NDIS_HANDLE     NdisLinkHandle;
    OUT USHORT          LanSegmentNumber;
    OUT UCHAR           BridgeNumber;
    OUT UCHAR           BridgingOptions;
    OUT ULONG           BridgingCapabilities;
    OUT UCHAR           BridgingType;
    OUT UCHAR           MacBytes[6];
} NDIS_WAN_GET_BRIDGE_INFO, *PNDIS_WAN_GET_BRIDGE_INFO;

typedef struct _NDIS_WAN_SET_BRIDGE_INFO
{
    IN  NDIS_HANDLE     NdisLinkHandle;
    IN  USHORT          LanSegmentNumber;
    IN  UCHAR           BridgeNumber;
    IN  UCHAR           BridgingOptions;
    IN  ULONG           BridgingCapabilities;
    IN  UCHAR           BridgingType;
    IN  UCHAR           MacBytes[6];
} NDIS_WAN_SET_BRIDGE_INFO, *PNDIS_WAN_SET_BRIDGE_INFO;

//
// NDIS WAN Compression Information
//

//
// Define MSCompType bit field, 0 disables all
//
#define NDISWAN_COMPRESSION             0x00000001
#define NDISWAN_ENCRYPTION              0x00000010
#define NDISWAN_40_ENCRYPTION           0x00000020
#define NDISWAN_128_ENCRYPTION          0x00000040
#define NDISWAN_56_ENCRYPTION           0x00000080
#define NDISWAN_HISTORY_LESS            0x01000000

//
// Define CompType codes
//
#define COMPTYPE_OUI                    0
#define COMPTYPE_NT31RAS                254
#define COMPTYPE_NONE                   255


typedef struct _NDIS_WAN_COMPRESS_INFO
{
    UCHAR   SessionKey[8];
    ULONG   MSCompType;

    // Fields above indicate NDISWAN capabilities.
    // Fields below indicate MAC-specific capabilities.

    UCHAR   CompType;
    USHORT  CompLength;

    union
    {
        struct
        {
            UCHAR   CompOUI[3];
            UCHAR   CompSubType;
            UCHAR   CompValues[32];
        } Proprietary;

        struct
        {
            UCHAR   CompValues[32];
        } Public;
    };
} NDIS_WAN_COMPRESS_INFO;

typedef NDIS_WAN_COMPRESS_INFO UNALIGNED *PNDIS_WAN_COMPRESS_INFO;

typedef struct _NDIS_WAN_GET_COMP_INFO
{
    IN  NDIS_HANDLE             NdisLinkHandle;
    OUT NDIS_WAN_COMPRESS_INFO  SendCapabilities;
    OUT NDIS_WAN_COMPRESS_INFO  RecvCapabilities;
} NDIS_WAN_GET_COMP_INFO, *PNDIS_WAN_GET_COMP_INFO;

typedef struct _NDIS_WAN_SET_COMP_INFO
{
    IN  NDIS_HANDLE             NdisLinkHandle;
    IN  NDIS_WAN_COMPRESS_INFO  SendCapabilities;
    IN  NDIS_WAN_COMPRESS_INFO  RecvCapabilities;
} NDIS_WAN_SET_COMP_INFO, *PNDIS_WAN_SET_COMP_INFO;

//
// NDIS WAN Statistics Information
//

typedef struct _NDIS_WAN_GET_STATS_INFO
{
    IN  NDIS_HANDLE NdisLinkHandle;
    OUT ULONG       BytesSent;
    OUT ULONG       BytesRcvd;
    OUT ULONG       FramesSent;
    OUT ULONG       FramesRcvd;
    OUT ULONG       CRCErrors;                      // Serial-like info only
    OUT ULONG       TimeoutErrors;                  // Serial-like info only
    OUT ULONG       AlignmentErrors;                // Serial-like info only
    OUT ULONG       SerialOverrunErrors;            // Serial-like info only
    OUT ULONG       FramingErrors;                  // Serial-like info only
    OUT ULONG       BufferOverrunErrors;            // Serial-like info only
    OUT ULONG       BytesTransmittedUncompressed;   // Compression info only
    OUT ULONG       BytesReceivedUncompressed;      // Compression info only
    OUT ULONG       BytesTransmittedCompressed;     // Compression info only
    OUT ULONG       BytesReceivedCompressed;        // Compression info only
} NDIS_WAN_GET_STATS_INFO, *PNDIS_WAN_GET_STATS_INFO;

#define NdisMWanInitializeWrapper(NdisWrapperHandle,                                \
                                  SystemSpecific1,                                  \
                                  SystemSpecific2,                                  \
                                  SystemSpecific3)                                  \
{                                                                                   \
    NdisMInitializeWrapper(NdisWrapperHandle,                                       \
                            SystemSpecific1,                                        \
                            SystemSpecific2,                                        \
                            SystemSpecific3);                                       \
}

typedef struct _NDIS_MAC_LINE_UP
{
    IN  ULONG               LinkSpeed;
    IN  NDIS_WAN_QUALITY    Quality;
    IN  USHORT              SendWindow;
    IN  NDIS_HANDLE      ConnectionWrapperID;
    IN  NDIS_HANDLE      NdisLinkHandle;
    OUT NDIS_HANDLE      NdisLinkContext;
} NDIS_MAC_LINE_UP, *PNDIS_MAC_LINE_UP;


typedef struct _NDIS_MAC_LINE_DOWN
{
    IN  NDIS_HANDLE      NdisLinkContext;
} NDIS_MAC_LINE_DOWN, *PNDIS_MAC_LINE_DOWN;


//
// These are the error values that can be indicated by the driver.
// This bit field is set when calling NdisIndicateStatus.
//
#define WAN_ERROR_CRC               ((ULONG)0x00000001)
#define WAN_ERROR_FRAMING           ((ULONG)0x00000002)
#define WAN_ERROR_HARDWAREOVERRUN   ((ULONG)0x00000004)
#define WAN_ERROR_BUFFEROVERRUN     ((ULONG)0x00000008)
#define WAN_ERROR_TIMEOUT           ((ULONG)0x00000010)
#define WAN_ERROR_ALIGNMENT         ((ULONG)0x00000020)

typedef struct _NDIS_MAC_FRAGMENT
{
    IN  NDIS_HANDLE     NdisLinkContext;
    IN  ULONG           Errors;
} NDIS_MAC_FRAGMENT, *PNDIS_MAC_FRAGMENT;

//
// NDIS WAN Information structures used
// by NDIS 5.0 Miniport drivers
//

//
// Defines for the individual fields are the
// same as for NDIS 3.x/4.x Wan miniports.
//
// See the DDK.
//

//
// Information that applies to all VC's on
// this adapter.
//
// OID: OID_WAN_CO_GET_INFO
//
typedef struct _NDIS_WAN_CO_INFO {
    OUT ULONG           MaxFrameSize;
    OUT ULONG           MaxSendWindow;
    OUT ULONG           FramingBits;
    OUT ULONG           DesiredACCM;
} NDIS_WAN_CO_INFO, *PNDIS_WAN_CO_INFO;

//
// Set VC specific PPP framing information.
//
// OID: OID_WAN_CO_SET_LINK_INFO
//
typedef struct _NDIS_WAN_CO_SET_LINK_INFO {
    IN  ULONG           MaxSendFrameSize;
    IN  ULONG           MaxRecvFrameSize;
    IN  ULONG           SendFramingBits;
    IN  ULONG           RecvFramingBits;
    IN  ULONG           SendCompressionBits;
    IN  ULONG           RecvCompressionBits;
    IN  ULONG           SendACCM;
    IN  ULONG           RecvACCM;
} NDIS_WAN_CO_SET_LINK_INFO, *PNDIS_WAN_CO_SET_LINK_INFO;

//
// Get VC specific PPP framing information.
//
// OID: OID_WAN_CO_GET_LINK_INFO
//
typedef struct _NDIS_WAN_CO_GET_LINK_INFO {
    OUT ULONG           MaxSendFrameSize;
    OUT ULONG           MaxRecvFrameSize;
    OUT ULONG           SendFramingBits;
    OUT ULONG           RecvFramingBits;
    OUT ULONG           SendCompressionBits;
    OUT ULONG           RecvCompressionBits;
    OUT ULONG           SendACCM;
    OUT ULONG           RecvACCM;
} NDIS_WAN_CO_GET_LINK_INFO, *PNDIS_WAN_CO_GET_LINK_INFO;

//
// Get VC specific PPP compression information
//
// OID: OID_WAN_CO_GET_COMP_INFO
//
typedef struct _NDIS_WAN_CO_GET_COMP_INFO {
    OUT NDIS_WAN_COMPRESS_INFO  SendCapabilities;
    OUT NDIS_WAN_COMPRESS_INFO  RecvCapabilities;
} NDIS_WAN_CO_GET_COMP_INFO, *PNDIS_WAN_CO_GET_COMP_INFO;


//
// Set VC specific PPP compression information
//
// OID: OID_WAN_CO_SET_COMP_INFO
//
typedef struct _NDIS_WAN_CO_SET_COMP_INFO {
    IN  NDIS_WAN_COMPRESS_INFO  SendCapabilities;
    IN  NDIS_WAN_COMPRESS_INFO  RecvCapabilities;
} NDIS_WAN_CO_SET_COMP_INFO, *PNDIS_WAN_CO_SET_COMP_INFO;


//
// Get VC specific statistics
//
// OID: OID_WAN_CO_GET_STATS_INFO
//
typedef struct _NDIS_WAN_CO_GET_STATS_INFO {
    OUT ULONG       BytesSent;
    OUT ULONG       BytesRcvd;
    OUT ULONG       FramesSent;
    OUT ULONG       FramesRcvd;
    OUT ULONG       CRCErrors;                      // Serial-like info only
    OUT ULONG       TimeoutErrors;                  // Serial-like info only
    OUT ULONG       AlignmentErrors;                // Serial-like info only
    OUT ULONG       SerialOverrunErrors;            // Serial-like info only
    OUT ULONG       FramingErrors;                  // Serial-like info only
    OUT ULONG       BufferOverrunErrors;            // Serial-like info only
    OUT ULONG       BytesTransmittedUncompressed;   // Compression info only
    OUT ULONG       BytesReceivedUncompressed;      // Compression info only
    OUT ULONG       BytesTransmittedCompressed;     // Compression info only
    OUT ULONG       BytesReceivedCompressed;        // Compression info only
} NDIS_WAN_CO_GET_STATS_INFO, *PNDIS_WAN_CO_GET_STATS_INFO;

//
// Used to notify NdisWan of Errors.  See error
// bit mask in ndiswan.h
//
// NDIS_STATUS: NDIS_STATUS_WAN_CO_FRAGMENT
//
typedef struct _NDIS_WAN_CO_FRAGMENT {
    IN  ULONG           Errors;
} NDIS_WAN_CO_FRAGMENT, *PNDIS_WAN_CO_FRAGMENT;

//
// Used to notify NdisWan of changes in link speed and
// send window.  Can be given at any time.  NdisWan will honor
// any send window (even zero).  NdisWan will default zero
// TransmitSpeed/ReceiveSpeed settings to 28.8Kbs.
//
// NDIS_STATUS: NDIS_STATUS_WAN_CO_LINKPARAMS
//
typedef struct _WAN_CO_LINKPARAMS {
    ULONG   TransmitSpeed;              // Transmit speed of the VC in Bytes/sec
    ULONG   ReceiveSpeed;               // Receive speed of the VC in Bytes/sec
    ULONG   SendWindow;                 // Current send window for the VC
} WAN_CO_LINKPARAMS, *PWAN_CO_LINKPARAMS;

#endif  // _NDIS_WAN
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\ddk\inc\netcfgx.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0347 */
/* Compiler settings for netcfgx.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __netcfgx_h__
#define __netcfgx_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IEnumNetCfgBindingInterface_FWD_DEFINED__
#define __IEnumNetCfgBindingInterface_FWD_DEFINED__
typedef interface IEnumNetCfgBindingInterface IEnumNetCfgBindingInterface;
#endif 	/* __IEnumNetCfgBindingInterface_FWD_DEFINED__ */


#ifndef __IEnumNetCfgBindingPath_FWD_DEFINED__
#define __IEnumNetCfgBindingPath_FWD_DEFINED__
typedef interface IEnumNetCfgBindingPath IEnumNetCfgBindingPath;
#endif 	/* __IEnumNetCfgBindingPath_FWD_DEFINED__ */


#ifndef __IEnumNetCfgComponent_FWD_DEFINED__
#define __IEnumNetCfgComponent_FWD_DEFINED__
typedef interface IEnumNetCfgComponent IEnumNetCfgComponent;
#endif 	/* __IEnumNetCfgComponent_FWD_DEFINED__ */


#ifndef __INetCfg_FWD_DEFINED__
#define __INetCfg_FWD_DEFINED__
typedef interface INetCfg INetCfg;
#endif 	/* __INetCfg_FWD_DEFINED__ */


#ifndef __INetCfgLock_FWD_DEFINED__
#define __INetCfgLock_FWD_DEFINED__
typedef interface INetCfgLock INetCfgLock;
#endif 	/* __INetCfgLock_FWD_DEFINED__ */


#ifndef __INetCfgBindingInterface_FWD_DEFINED__
#define __INetCfgBindingInterface_FWD_DEFINED__
typedef interface INetCfgBindingInterface INetCfgBindingInterface;
#endif 	/* __INetCfgBindingInterface_FWD_DEFINED__ */


#ifndef __INetCfgBindingPath_FWD_DEFINED__
#define __INetCfgBindingPath_FWD_DEFINED__
typedef interface INetCfgBindingPath INetCfgBindingPath;
#endif 	/* __INetCfgBindingPath_FWD_DEFINED__ */


#ifndef __INetCfgClass_FWD_DEFINED__
#define __INetCfgClass_FWD_DEFINED__
typedef interface INetCfgClass INetCfgClass;
#endif 	/* __INetCfgClass_FWD_DEFINED__ */


#ifndef __INetCfgClassSetup_FWD_DEFINED__
#define __INetCfgClassSetup_FWD_DEFINED__
typedef interface INetCfgClassSetup INetCfgClassSetup;
#endif 	/* __INetCfgClassSetup_FWD_DEFINED__ */


#ifndef __INetCfgComponent_FWD_DEFINED__
#define __INetCfgComponent_FWD_DEFINED__
typedef interface INetCfgComponent INetCfgComponent;
#endif 	/* __INetCfgComponent_FWD_DEFINED__ */


#ifndef __INetCfgComponentBindings_FWD_DEFINED__
#define __INetCfgComponentBindings_FWD_DEFINED__
typedef interface INetCfgComponentBindings INetCfgComponentBindings;
#endif 	/* __INetCfgComponentBindings_FWD_DEFINED__ */


#ifndef __INetCfgSysPrep_FWD_DEFINED__
#define __INetCfgSysPrep_FWD_DEFINED__
typedef interface INetCfgSysPrep INetCfgSysPrep;
#endif 	/* __INetCfgSysPrep_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"
#include "prsht.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_netcfgx_0000 */
/* [local] */ 

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
//--------------------------------------------------------------------------
#if ( _MSC_VER >= 800 )
#pragma warning(disable:4201)
#endif

EXTERN_C const CLSID CLSID_CNetCfg;

#define NETCFG_E_ALREADY_INITIALIZED                 MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0xA020)
#define NETCFG_E_NOT_INITIALIZED                     MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0xA021)
#define NETCFG_E_IN_USE                              MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0xA022)
#define NETCFG_E_NO_WRITE_LOCK                       MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0xA024)
#define NETCFG_E_NEED_REBOOT                         MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0xA025)
#define NETCFG_E_ACTIVE_RAS_CONNECTIONS              MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0xA026)
#define NETCFG_E_ADAPTER_NOT_FOUND                   MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0xA027)
#define NETCFG_E_COMPONENT_REMOVED_PENDING_REBOOT    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0xA028)
#define NETCFG_S_REBOOT                              MAKE_HRESULT(SEVERITY_SUCCESS, FACILITY_ITF, 0xA020)
#define NETCFG_S_DISABLE_QUERY                       MAKE_HRESULT(SEVERITY_SUCCESS, FACILITY_ITF, 0xA022)
#define NETCFG_S_STILL_REFERENCED                    MAKE_HRESULT(SEVERITY_SUCCESS, FACILITY_ITF, 0xA023)
#define NETCFG_S_CAUSED_SETUP_CHANGE                 MAKE_HRESULT(SEVERITY_SUCCESS, FACILITY_ITF, 0xA024)
#define NETCFG_S_COMMIT_NOW                          MAKE_HRESULT(SEVERITY_SUCCESS, FACILITY_ITF, 0xA025)

#define NETCFG_CLIENT_CID_MS_MSClient        TEXT("ms_msclient")
#define NETCFG_SERVICE_CID_MS_SERVER         TEXT("ms_server")
#define NETCFG_SERVICE_CID_MS_NETBIOS        TEXT("ms_netbios")
#define NETCFG_SERVICE_CID_MS_PSCHED         TEXT("ms_pschedpc")
#define NETCFG_SERVICE_CID_MS_WLBS           TEXT("ms_wlbs")
#define NETCFG_TRANS_CID_MS_APPLETALK        TEXT("ms_appletalk")
#define NETCFG_TRANS_CID_MS_NETBEUI          TEXT("ms_netbeui")
#define NETCFG_TRANS_CID_MS_NETMON           TEXT("ms_netmon")
#define NETCFG_TRANS_CID_MS_NWIPX            TEXT("ms_nwipx")
#define NETCFG_TRANS_CID_MS_NWSPX            TEXT("ms_nwspx")
#define NETCFG_TRANS_CID_MS_TCPIP            TEXT("ms_tcpip")
















extern RPC_IF_HANDLE __MIDL_itf_netcfgx_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_netcfgx_0000_v0_0_s_ifspec;

#ifndef __IEnumNetCfgBindingInterface_INTERFACE_DEFINED__
#define __IEnumNetCfgBindingInterface_INTERFACE_DEFINED__

/* interface IEnumNetCfgBindingInterface */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IEnumNetCfgBindingInterface;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C0E8AE90-306E-11D1-AACF-00805FC1270E")
    IEnumNetCfgBindingInterface : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ INetCfgBindingInterface **rgelt,
            /* [out] */ ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumNetCfgBindingInterface **ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumNetCfgBindingInterfaceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumNetCfgBindingInterface * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumNetCfgBindingInterface * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumNetCfgBindingInterface * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumNetCfgBindingInterface * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ INetCfgBindingInterface **rgelt,
            /* [out] */ ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumNetCfgBindingInterface * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumNetCfgBindingInterface * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumNetCfgBindingInterface * This,
            /* [out] */ IEnumNetCfgBindingInterface **ppenum);
        
        END_INTERFACE
    } IEnumNetCfgBindingInterfaceVtbl;

    interface IEnumNetCfgBindingInterface
    {
        CONST_VTBL struct IEnumNetCfgBindingInterfaceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumNetCfgBindingInterface_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumNetCfgBindingInterface_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumNetCfgBindingInterface_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumNetCfgBindingInterface_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IEnumNetCfgBindingInterface_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumNetCfgBindingInterface_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumNetCfgBindingInterface_Clone(This,ppenum)	\
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumNetCfgBindingInterface_Next_Proxy( 
    IEnumNetCfgBindingInterface * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ INetCfgBindingInterface **rgelt,
    /* [out] */ ULONG *pceltFetched);


void __RPC_STUB IEnumNetCfgBindingInterface_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumNetCfgBindingInterface_Skip_Proxy( 
    IEnumNetCfgBindingInterface * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumNetCfgBindingInterface_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumNetCfgBindingInterface_Reset_Proxy( 
    IEnumNetCfgBindingInterface * This);


void __RPC_STUB IEnumNetCfgBindingInterface_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumNetCfgBindingInterface_Clone_Proxy( 
    IEnumNetCfgBindingInterface * This,
    /* [out] */ IEnumNetCfgBindingInterface **ppenum);


void __RPC_STUB IEnumNetCfgBindingInterface_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumNetCfgBindingInterface_INTERFACE_DEFINED__ */


#ifndef __IEnumNetCfgBindingPath_INTERFACE_DEFINED__
#define __IEnumNetCfgBindingPath_INTERFACE_DEFINED__

/* interface IEnumNetCfgBindingPath */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IEnumNetCfgBindingPath;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C0E8AE91-306E-11D1-AACF-00805FC1270E")
    IEnumNetCfgBindingPath : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ INetCfgBindingPath **rgelt,
            /* [out] */ ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumNetCfgBindingPath **ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumNetCfgBindingPathVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumNetCfgBindingPath * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumNetCfgBindingPath * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumNetCfgBindingPath * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumNetCfgBindingPath * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ INetCfgBindingPath **rgelt,
            /* [out] */ ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumNetCfgBindingPath * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumNetCfgBindingPath * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumNetCfgBindingPath * This,
            /* [out] */ IEnumNetCfgBindingPath **ppenum);
        
        END_INTERFACE
    } IEnumNetCfgBindingPathVtbl;

    interface IEnumNetCfgBindingPath
    {
        CONST_VTBL struct IEnumNetCfgBindingPathVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumNetCfgBindingPath_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumNetCfgBindingPath_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumNetCfgBindingPath_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumNetCfgBindingPath_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IEnumNetCfgBindingPath_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumNetCfgBindingPath_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumNetCfgBindingPath_Clone(This,ppenum)	\
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumNetCfgBindingPath_Next_Proxy( 
    IEnumNetCfgBindingPath * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ INetCfgBindingPath **rgelt,
    /* [out] */ ULONG *pceltFetched);


void __RPC_STUB IEnumNetCfgBindingPath_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumNetCfgBindingPath_Skip_Proxy( 
    IEnumNetCfgBindingPath * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumNetCfgBindingPath_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumNetCfgBindingPath_Reset_Proxy( 
    IEnumNetCfgBindingPath * This);


void __RPC_STUB IEnumNetCfgBindingPath_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumNetCfgBindingPath_Clone_Proxy( 
    IEnumNetCfgBindingPath * This,
    /* [out] */ IEnumNetCfgBindingPath **ppenum);


void __RPC_STUB IEnumNetCfgBindingPath_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumNetCfgBindingPath_INTERFACE_DEFINED__ */


#ifndef __IEnumNetCfgComponent_INTERFACE_DEFINED__
#define __IEnumNetCfgComponent_INTERFACE_DEFINED__

/* interface IEnumNetCfgComponent */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IEnumNetCfgComponent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C0E8AE92-306E-11D1-AACF-00805FC1270E")
    IEnumNetCfgComponent : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ INetCfgComponent **rgelt,
            /* [out] */ ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumNetCfgComponent **ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumNetCfgComponentVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumNetCfgComponent * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumNetCfgComponent * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumNetCfgComponent * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumNetCfgComponent * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ INetCfgComponent **rgelt,
            /* [out] */ ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumNetCfgComponent * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumNetCfgComponent * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumNetCfgComponent * This,
            /* [out] */ IEnumNetCfgComponent **ppenum);
        
        END_INTERFACE
    } IEnumNetCfgComponentVtbl;

    interface IEnumNetCfgComponent
    {
        CONST_VTBL struct IEnumNetCfgComponentVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumNetCfgComponent_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumNetCfgComponent_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumNetCfgComponent_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumNetCfgComponent_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IEnumNetCfgComponent_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumNetCfgComponent_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumNetCfgComponent_Clone(This,ppenum)	\
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumNetCfgComponent_Next_Proxy( 
    IEnumNetCfgComponent * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ INetCfgComponent **rgelt,
    /* [out] */ ULONG *pceltFetched);


void __RPC_STUB IEnumNetCfgComponent_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumNetCfgComponent_Skip_Proxy( 
    IEnumNetCfgComponent * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumNetCfgComponent_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumNetCfgComponent_Reset_Proxy( 
    IEnumNetCfgComponent * This);


void __RPC_STUB IEnumNetCfgComponent_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumNetCfgComponent_Clone_Proxy( 
    IEnumNetCfgComponent * This,
    /* [out] */ IEnumNetCfgComponent **ppenum);


void __RPC_STUB IEnumNetCfgComponent_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumNetCfgComponent_INTERFACE_DEFINED__ */


#ifndef __INetCfg_INTERFACE_DEFINED__
#define __INetCfg_INTERFACE_DEFINED__

/* interface INetCfg */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_INetCfg;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C0E8AE93-306E-11D1-AACF-00805FC1270E")
    INetCfg : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ PVOID pvReserved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Uninitialize( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Apply( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Cancel( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumComponents( 
            /* [in] */ const GUID *pguidClass,
            /* [out] */ IEnumNetCfgComponent **ppenumComponent) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FindComponent( 
            /* [string][in] */ LPCWSTR pszwInfId,
            /* [out] */ INetCfgComponent **pComponent) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryNetCfgClass( 
            /* [in] */ const GUID *pguidClass,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INetCfgVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            INetCfg * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            INetCfg * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            INetCfg * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            INetCfg * This,
            /* [in] */ PVOID pvReserved);
        
        HRESULT ( STDMETHODCALLTYPE *Uninitialize )( 
            INetCfg * This);
        
        HRESULT ( STDMETHODCALLTYPE *Apply )( 
            INetCfg * This);
        
        HRESULT ( STDMETHODCALLTYPE *Cancel )( 
            INetCfg * This);
        
        HRESULT ( STDMETHODCALLTYPE *EnumComponents )( 
            INetCfg * This,
            /* [in] */ const GUID *pguidClass,
            /* [out] */ IEnumNetCfgComponent **ppenumComponent);
        
        HRESULT ( STDMETHODCALLTYPE *FindComponent )( 
            INetCfg * This,
            /* [string][in] */ LPCWSTR pszwInfId,
            /* [out] */ INetCfgComponent **pComponent);
        
        HRESULT ( STDMETHODCALLTYPE *QueryNetCfgClass )( 
            INetCfg * This,
            /* [in] */ const GUID *pguidClass,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        END_INTERFACE
    } INetCfgVtbl;

    interface INetCfg
    {
        CONST_VTBL struct INetCfgVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INetCfg_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INetCfg_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INetCfg_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INetCfg_Initialize(This,pvReserved)	\
    (This)->lpVtbl -> Initialize(This,pvReserved)

#define INetCfg_Uninitialize(This)	\
    (This)->lpVtbl -> Uninitialize(This)

#define INetCfg_Apply(This)	\
    (This)->lpVtbl -> Apply(This)

#define INetCfg_Cancel(This)	\
    (This)->lpVtbl -> Cancel(This)

#define INetCfg_EnumComponents(This,pguidClass,ppenumComponent)	\
    (This)->lpVtbl -> EnumComponents(This,pguidClass,ppenumComponent)

#define INetCfg_FindComponent(This,pszwInfId,pComponent)	\
    (This)->lpVtbl -> FindComponent(This,pszwInfId,pComponent)

#define INetCfg_QueryNetCfgClass(This,pguidClass,riid,ppvObject)	\
    (This)->lpVtbl -> QueryNetCfgClass(This,pguidClass,riid,ppvObject)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE INetCfg_Initialize_Proxy( 
    INetCfg * This,
    /* [in] */ PVOID pvReserved);


void __RPC_STUB INetCfg_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetCfg_Uninitialize_Proxy( 
    INetCfg * This);


void __RPC_STUB INetCfg_Uninitialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetCfg_Apply_Proxy( 
    INetCfg * This);


void __RPC_STUB INetCfg_Apply_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetCfg_Cancel_Proxy( 
    INetCfg * This);


void __RPC_STUB INetCfg_Cancel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetCfg_EnumComponents_Proxy( 
    INetCfg * This,
    /* [in] */ const GUID *pguidClass,
    /* [out] */ IEnumNetCfgComponent **ppenumComponent);


void __RPC_STUB INetCfg_EnumComponents_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetCfg_FindComponent_Proxy( 
    INetCfg * This,
    /* [string][in] */ LPCWSTR pszwInfId,
    /* [out] */ INetCfgComponent **pComponent);


void __RPC_STUB INetCfg_FindComponent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetCfg_QueryNetCfgClass_Proxy( 
    INetCfg * This,
    /* [in] */ const GUID *pguidClass,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ void **ppvObject);


void __RPC_STUB INetCfg_QueryNetCfgClass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INetCfg_INTERFACE_DEFINED__ */


#ifndef __INetCfgLock_INTERFACE_DEFINED__
#define __INetCfgLock_INTERFACE_DEFINED__

/* interface INetCfgLock */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_INetCfgLock;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C0E8AE9F-306E-11D1-AACF-00805FC1270E")
    INetCfgLock : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AcquireWriteLock( 
            /* [in] */ DWORD cmsTimeout,
            /* [string][in] */ LPCWSTR pszwClientDescription,
            /* [string][out] */ LPWSTR *ppszwClientDescription) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReleaseWriteLock( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsWriteLocked( 
            /* [string][out] */ LPWSTR *ppszwClientDescription) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INetCfgLockVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            INetCfgLock * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            INetCfgLock * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            INetCfgLock * This);
        
        HRESULT ( STDMETHODCALLTYPE *AcquireWriteLock )( 
            INetCfgLock * This,
            /* [in] */ DWORD cmsTimeout,
            /* [string][in] */ LPCWSTR pszwClientDescription,
            /* [string][out] */ LPWSTR *ppszwClientDescription);
        
        HRESULT ( STDMETHODCALLTYPE *ReleaseWriteLock )( 
            INetCfgLock * This);
        
        HRESULT ( STDMETHODCALLTYPE *IsWriteLocked )( 
            INetCfgLock * This,
            /* [string][out] */ LPWSTR *ppszwClientDescription);
        
        END_INTERFACE
    } INetCfgLockVtbl;

    interface INetCfgLock
    {
        CONST_VTBL struct INetCfgLockVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INetCfgLock_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INetCfgLock_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INetCfgLock_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INetCfgLock_AcquireWriteLock(This,cmsTimeout,pszwClientDescription,ppszwClientDescription)	\
    (This)->lpVtbl -> AcquireWriteLock(This,cmsTimeout,pszwClientDescription,ppszwClientDescription)

#define INetCfgLock_ReleaseWriteLock(This)	\
    (This)->lpVtbl -> ReleaseWriteLock(This)

#define INetCfgLock_IsWriteLocked(This,ppszwClientDescription)	\
    (This)->lpVtbl -> IsWriteLocked(This,ppszwClientDescription)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE INetCfgLock_AcquireWriteLock_Proxy( 
    INetCfgLock * This,
    /* [in] */ DWORD cmsTimeout,
    /* [string][in] */ LPCWSTR pszwClientDescription,
    /* [string][out] */ LPWSTR *ppszwClientDescription);


void __RPC_STUB INetCfgLock_AcquireWriteLock_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetCfgLock_ReleaseWriteLock_Proxy( 
    INetCfgLock * This);


void __RPC_STUB INetCfgLock_ReleaseWriteLock_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetCfgLock_IsWriteLocked_Proxy( 
    INetCfgLock * This,
    /* [string][out] */ LPWSTR *ppszwClientDescription);


void __RPC_STUB INetCfgLock_IsWriteLocked_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INetCfgLock_INTERFACE_DEFINED__ */


#ifndef __INetCfgBindingInterface_INTERFACE_DEFINED__
#define __INetCfgBindingInterface_INTERFACE_DEFINED__

/* interface INetCfgBindingInterface */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_INetCfgBindingInterface;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C0E8AE94-306E-11D1-AACF-00805FC1270E")
    INetCfgBindingInterface : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetName( 
            /* [string][out] */ LPWSTR *ppszwInterfaceName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetUpperComponent( 
            /* [out] */ INetCfgComponent **ppnccItem) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLowerComponent( 
            /* [out] */ INetCfgComponent **ppnccItem) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INetCfgBindingInterfaceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            INetCfgBindingInterface * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            INetCfgBindingInterface * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            INetCfgBindingInterface * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetName )( 
            INetCfgBindingInterface * This,
            /* [string][out] */ LPWSTR *ppszwInterfaceName);
        
        HRESULT ( STDMETHODCALLTYPE *GetUpperComponent )( 
            INetCfgBindingInterface * This,
            /* [out] */ INetCfgComponent **ppnccItem);
        
        HRESULT ( STDMETHODCALLTYPE *GetLowerComponent )( 
            INetCfgBindingInterface * This,
            /* [out] */ INetCfgComponent **ppnccItem);
        
        END_INTERFACE
    } INetCfgBindingInterfaceVtbl;

    interface INetCfgBindingInterface
    {
        CONST_VTBL struct INetCfgBindingInterfaceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INetCfgBindingInterface_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INetCfgBindingInterface_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INetCfgBindingInterface_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INetCfgBindingInterface_GetName(This,ppszwInterfaceName)	\
    (This)->lpVtbl -> GetName(This,ppszwInterfaceName)

#define INetCfgBindingInterface_GetUpperComponent(This,ppnccItem)	\
    (This)->lpVtbl -> GetUpperComponent(This,ppnccItem)

#define INetCfgBindingInterface_GetLowerComponent(This,ppnccItem)	\
    (This)->lpVtbl -> GetLowerComponent(This,ppnccItem)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE INetCfgBindingInterface_GetName_Proxy( 
    INetCfgBindingInterface * This,
    /* [string][out] */ LPWSTR *ppszwInterfaceName);


void __RPC_STUB INetCfgBindingInterface_GetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetCfgBindingInterface_GetUpperComponent_Proxy( 
    INetCfgBindingInterface * This,
    /* [out] */ INetCfgComponent **ppnccItem);


void __RPC_STUB INetCfgBindingInterface_GetUpperComponent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetCfgBindingInterface_GetLowerComponent_Proxy( 
    INetCfgBindingInterface * This,
    /* [out] */ INetCfgComponent **ppnccItem);


void __RPC_STUB INetCfgBindingInterface_GetLowerComponent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INetCfgBindingInterface_INTERFACE_DEFINED__ */


#ifndef __INetCfgBindingPath_INTERFACE_DEFINED__
#define __INetCfgBindingPath_INTERFACE_DEFINED__

/* interface INetCfgBindingPath */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_INetCfgBindingPath;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C0E8AE96-306E-11D1-AACF-00805FC1270E")
    INetCfgBindingPath : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE IsSamePathAs( 
            /* [in] */ INetCfgBindingPath *pPath) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsSubPathOf( 
            /* [in] */ INetCfgBindingPath *pPath) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsEnabled( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Enable( 
            /* [in] */ BOOL fEnable) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPathToken( 
            /* [string][out] */ LPWSTR *ppszwPathToken) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOwner( 
            /* [out] */ INetCfgComponent **ppComponent) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDepth( 
            /* [out] */ ULONG *pcInterfaces) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumBindingInterfaces( 
            /* [out] */ IEnumNetCfgBindingInterface **ppenumInterface) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INetCfgBindingPathVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            INetCfgBindingPath * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            INetCfgBindingPath * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            INetCfgBindingPath * This);
        
        HRESULT ( STDMETHODCALLTYPE *IsSamePathAs )( 
            INetCfgBindingPath * This,
            /* [in] */ INetCfgBindingPath *pPath);
        
        HRESULT ( STDMETHODCALLTYPE *IsSubPathOf )( 
            INetCfgBindingPath * This,
            /* [in] */ INetCfgBindingPath *pPath);
        
        HRESULT ( STDMETHODCALLTYPE *IsEnabled )( 
            INetCfgBindingPath * This);
        
        HRESULT ( STDMETHODCALLTYPE *Enable )( 
            INetCfgBindingPath * This,
            /* [in] */ BOOL fEnable);
        
        HRESULT ( STDMETHODCALLTYPE *GetPathToken )( 
            INetCfgBindingPath * This,
            /* [string][out] */ LPWSTR *ppszwPathToken);
        
        HRESULT ( STDMETHODCALLTYPE *GetOwner )( 
            INetCfgBindingPath * This,
            /* [out] */ INetCfgComponent **ppComponent);
        
        HRESULT ( STDMETHODCALLTYPE *GetDepth )( 
            INetCfgBindingPath * This,
            /* [out] */ ULONG *pcInterfaces);
        
        HRESULT ( STDMETHODCALLTYPE *EnumBindingInterfaces )( 
            INetCfgBindingPath * This,
            /* [out] */ IEnumNetCfgBindingInterface **ppenumInterface);
        
        END_INTERFACE
    } INetCfgBindingPathVtbl;

    interface INetCfgBindingPath
    {
        CONST_VTBL struct INetCfgBindingPathVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INetCfgBindingPath_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INetCfgBindingPath_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INetCfgBindingPath_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INetCfgBindingPath_IsSamePathAs(This,pPath)	\
    (This)->lpVtbl -> IsSamePathAs(This,pPath)

#define INetCfgBindingPath_IsSubPathOf(This,pPath)	\
    (This)->lpVtbl -> IsSubPathOf(This,pPath)

#define INetCfgBindingPath_IsEnabled(This)	\
    (This)->lpVtbl -> IsEnabled(This)

#define INetCfgBindingPath_Enable(This,fEnable)	\
    (This)->lpVtbl -> Enable(This,fEnable)

#define INetCfgBindingPath_GetPathToken(This,ppszwPathToken)	\
    (This)->lpVtbl -> GetPathToken(This,ppszwPathToken)

#define INetCfgBindingPath_GetOwner(This,ppComponent)	\
    (This)->lpVtbl -> GetOwner(This,ppComponent)

#define INetCfgBindingPath_GetDepth(This,pcInterfaces)	\
    (This)->lpVtbl -> GetDepth(This,pcInterfaces)

#define INetCfgBindingPath_EnumBindingInterfaces(This,ppenumInterface)	\
    (This)->lpVtbl -> EnumBindingInterfaces(This,ppenumInterface)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE INetCfgBindingPath_IsSamePathAs_Proxy( 
    INetCfgBindingPath * This,
    /* [in] */ INetCfgBindingPath *pPath);


void __RPC_STUB INetCfgBindingPath_IsSamePathAs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetCfgBindingPath_IsSubPathOf_Proxy( 
    INetCfgBindingPath * This,
    /* [in] */ INetCfgBindingPath *pPath);


void __RPC_STUB INetCfgBindingPath_IsSubPathOf_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetCfgBindingPath_IsEnabled_Proxy( 
    INetCfgBindingPath * This);


void __RPC_STUB INetCfgBindingPath_IsEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetCfgBindingPath_Enable_Proxy( 
    INetCfgBindingPath * This,
    /* [in] */ BOOL fEnable);


void __RPC_STUB INetCfgBindingPath_Enable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetCfgBindingPath_GetPathToken_Proxy( 
    INetCfgBindingPath * This,
    /* [string][out] */ LPWSTR *ppszwPathToken);


void __RPC_STUB INetCfgBindingPath_GetPathToken_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetCfgBindingPath_GetOwner_Proxy( 
    INetCfgBindingPath * This,
    /* [out] */ INetCfgComponent **ppComponent);


void __RPC_STUB INetCfgBindingPath_GetOwner_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetCfgBindingPath_GetDepth_Proxy( 
    INetCfgBindingPath * This,
    /* [out] */ ULONG *pcInterfaces);


void __RPC_STUB INetCfgBindingPath_GetDepth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetCfgBindingPath_EnumBindingInterfaces_Proxy( 
    INetCfgBindingPath * This,
    /* [out] */ IEnumNetCfgBindingInterface **ppenumInterface);


void __RPC_STUB INetCfgBindingPath_EnumBindingInterfaces_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INetCfgBindingPath_INTERFACE_DEFINED__ */


#ifndef __INetCfgClass_INTERFACE_DEFINED__
#define __INetCfgClass_INTERFACE_DEFINED__

/* interface INetCfgClass */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_INetCfgClass;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C0E8AE97-306E-11D1-AACF-00805FC1270E")
    INetCfgClass : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE FindComponent( 
            /* [string][in] */ LPCWSTR pszwInfId,
            /* [out] */ INetCfgComponent **ppnccItem) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumComponents( 
            /* [out] */ IEnumNetCfgComponent **ppenumComponent) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INetCfgClassVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            INetCfgClass * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            INetCfgClass * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            INetCfgClass * This);
        
        HRESULT ( STDMETHODCALLTYPE *FindComponent )( 
            INetCfgClass * This,
            /* [string][in] */ LPCWSTR pszwInfId,
            /* [out] */ INetCfgComponent **ppnccItem);
        
        HRESULT ( STDMETHODCALLTYPE *EnumComponents )( 
            INetCfgClass * This,
            /* [out] */ IEnumNetCfgComponent **ppenumComponent);
        
        END_INTERFACE
    } INetCfgClassVtbl;

    interface INetCfgClass
    {
        CONST_VTBL struct INetCfgClassVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INetCfgClass_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INetCfgClass_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INetCfgClass_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INetCfgClass_FindComponent(This,pszwInfId,ppnccItem)	\
    (This)->lpVtbl -> FindComponent(This,pszwInfId,ppnccItem)

#define INetCfgClass_EnumComponents(This,ppenumComponent)	\
    (This)->lpVtbl -> EnumComponents(This,ppenumComponent)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE INetCfgClass_FindComponent_Proxy( 
    INetCfgClass * This,
    /* [string][in] */ LPCWSTR pszwInfId,
    /* [out] */ INetCfgComponent **ppnccItem);


void __RPC_STUB INetCfgClass_FindComponent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetCfgClass_EnumComponents_Proxy( 
    INetCfgClass * This,
    /* [out] */ IEnumNetCfgComponent **ppenumComponent);


void __RPC_STUB INetCfgClass_EnumComponents_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INetCfgClass_INTERFACE_DEFINED__ */


#ifndef __INetCfgClassSetup_INTERFACE_DEFINED__
#define __INetCfgClassSetup_INTERFACE_DEFINED__

/* interface INetCfgClassSetup */
/* [unique][uuid][object][local] */ 

typedef 
enum tagOBO_TOKEN_TYPE
    {	OBO_USER	= 1,
	OBO_COMPONENT	= 2,
	OBO_SOFTWARE	= 3
    } 	OBO_TOKEN_TYPE;

typedef struct tagOBO_TOKEN
    {
    OBO_TOKEN_TYPE Type;
    INetCfgComponent *pncc;
    LPCWSTR pszwManufacturer;
    LPCWSTR pszwProduct;
    LPCWSTR pszwDisplayName;
    BOOL fRegistered;
    } 	OBO_TOKEN;


EXTERN_C const IID IID_INetCfgClassSetup;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C0E8AE9D-306E-11D1-AACF-00805FC1270E")
    INetCfgClassSetup : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SelectAndInstall( 
            /* [in] */ HWND hwndParent,
            /* [in] */ OBO_TOKEN *pOboToken,
            /* [out] */ INetCfgComponent **ppnccItem) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Install( 
            /* [string][in] */ LPCWSTR pszwInfId,
            /* [in] */ OBO_TOKEN *pOboToken,
            /* [in] */ DWORD dwSetupFlags,
            /* [in] */ DWORD dwUpgradeFromBuildNo,
            /* [string][in] */ LPCWSTR pszwAnswerFile,
            /* [string][in] */ LPCWSTR pszwAnswerSections,
            /* [out] */ INetCfgComponent **ppnccItem) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeInstall( 
            /* [in] */ INetCfgComponent *pComponent,
            /* [in] */ OBO_TOKEN *pOboToken,
            /* [out] */ LPWSTR *pmszwRefs) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INetCfgClassSetupVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            INetCfgClassSetup * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            INetCfgClassSetup * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            INetCfgClassSetup * This);
        
        HRESULT ( STDMETHODCALLTYPE *SelectAndInstall )( 
            INetCfgClassSetup * This,
            /* [in] */ HWND hwndParent,
            /* [in] */ OBO_TOKEN *pOboToken,
            /* [out] */ INetCfgComponent **ppnccItem);
        
        HRESULT ( STDMETHODCALLTYPE *Install )( 
            INetCfgClassSetup * This,
            /* [string][in] */ LPCWSTR pszwInfId,
            /* [in] */ OBO_TOKEN *pOboToken,
            /* [in] */ DWORD dwSetupFlags,
            /* [in] */ DWORD dwUpgradeFromBuildNo,
            /* [string][in] */ LPCWSTR pszwAnswerFile,
            /* [string][in] */ LPCWSTR pszwAnswerSections,
            /* [out] */ INetCfgComponent **ppnccItem);
        
        HRESULT ( STDMETHODCALLTYPE *DeInstall )( 
            INetCfgClassSetup * This,
            /* [in] */ INetCfgComponent *pComponent,
            /* [in] */ OBO_TOKEN *pOboToken,
            /* [out] */ LPWSTR *pmszwRefs);
        
        END_INTERFACE
    } INetCfgClassSetupVtbl;

    interface INetCfgClassSetup
    {
        CONST_VTBL struct INetCfgClassSetupVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INetCfgClassSetup_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INetCfgClassSetup_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INetCfgClassSetup_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INetCfgClassSetup_SelectAndInstall(This,hwndParent,pOboToken,ppnccItem)	\
    (This)->lpVtbl -> SelectAndInstall(This,hwndParent,pOboToken,ppnccItem)

#define INetCfgClassSetup_Install(This,pszwInfId,pOboToken,dwSetupFlags,dwUpgradeFromBuildNo,pszwAnswerFile,pszwAnswerSections,ppnccItem)	\
    (This)->lpVtbl -> Install(This,pszwInfId,pOboToken,dwSetupFlags,dwUpgradeFromBuildNo,pszwAnswerFile,pszwAnswerSections,ppnccItem)

#define INetCfgClassSetup_DeInstall(This,pComponent,pOboToken,pmszwRefs)	\
    (This)->lpVtbl -> DeInstall(This,pComponent,pOboToken,pmszwRefs)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE INetCfgClassSetup_SelectAndInstall_Proxy( 
    INetCfgClassSetup * This,
    /* [in] */ HWND hwndParent,
    /* [in] */ OBO_TOKEN *pOboToken,
    /* [out] */ INetCfgComponent **ppnccItem);


void __RPC_STUB INetCfgClassSetup_SelectAndInstall_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetCfgClassSetup_Install_Proxy( 
    INetCfgClassSetup * This,
    /* [string][in] */ LPCWSTR pszwInfId,
    /* [in] */ OBO_TOKEN *pOboToken,
    /* [in] */ DWORD dwSetupFlags,
    /* [in] */ DWORD dwUpgradeFromBuildNo,
    /* [string][in] */ LPCWSTR pszwAnswerFile,
    /* [string][in] */ LPCWSTR pszwAnswerSections,
    /* [out] */ INetCfgComponent **ppnccItem);


void __RPC_STUB INetCfgClassSetup_Install_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetCfgClassSetup_DeInstall_Proxy( 
    INetCfgClassSetup * This,
    /* [in] */ INetCfgComponent *pComponent,
    /* [in] */ OBO_TOKEN *pOboToken,
    /* [out] */ LPWSTR *pmszwRefs);


void __RPC_STUB INetCfgClassSetup_DeInstall_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INetCfgClassSetup_INTERFACE_DEFINED__ */


#ifndef __INetCfgComponent_INTERFACE_DEFINED__
#define __INetCfgComponent_INTERFACE_DEFINED__

/* interface INetCfgComponent */
/* [unique][uuid][object][local] */ 

typedef 
enum tagCOMPONENT_CHARACTERISTICS
    {	NCF_VIRTUAL	= 0x1,
	NCF_SOFTWARE_ENUMERATED	= 0x2,
	NCF_PHYSICAL	= 0x4,
	NCF_HIDDEN	= 0x8,
	NCF_NO_SERVICE	= 0x10,
	NCF_NOT_USER_REMOVABLE	= 0x20,
	NCF_MULTIPORT_INSTANCED_ADAPTER	= 0x40,
	NCF_HAS_UI	= 0x80,
	NCF_SINGLE_INSTANCE	= 0x100,
	NCF_FILTER	= 0x400,
	NCF_DONTEXPOSELOWER	= 0x1000,
	NCF_HIDE_BINDING	= 0x2000,
	NCF_NDIS_PROTOCOL	= 0x4000,
	NCF_FIXED_BINDING	= 0x20000
    } 	COMPONENT_CHARACTERISTICS;

typedef 
enum tagNCRP_FLAGS
    {	NCRP_QUERY_PROPERTY_UI	= 0x1,
	NCRP_SHOW_PROPERTY_UI	= 0x2
    } 	NCRP_FLAGS;


EXTERN_C const IID IID_INetCfgComponent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C0E8AE99-306E-11D1-AACF-00805FC1270E")
    INetCfgComponent : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetDisplayName( 
            /* [string][out] */ LPWSTR *ppszwDisplayName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDisplayName( 
            /* [string][in] */ LPCWSTR pszwDisplayName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetHelpText( 
            /* [string][out] */ LPWSTR *pszwHelpText) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetId( 
            /* [string][out] */ LPWSTR *ppszwId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCharacteristics( 
            /* [out] */ LPDWORD pdwCharacteristics) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetInstanceGuid( 
            /* [out] */ GUID *pGuid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPnpDevNodeId( 
            /* [string][out] */ LPWSTR *ppszwDevNodeId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetClassGuid( 
            /* [out] */ GUID *pGuid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBindName( 
            /* [string][out] */ LPWSTR *ppszwBindName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDeviceStatus( 
            /* [out] */ ULONG *pulStatus) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OpenParamKey( 
            /* [out] */ HKEY *phkey) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RaisePropertyUi( 
            /* [in] */ HWND hwndParent,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IUnknown *punkContext) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INetCfgComponentVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            INetCfgComponent * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            INetCfgComponent * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            INetCfgComponent * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetDisplayName )( 
            INetCfgComponent * This,
            /* [string][out] */ LPWSTR *ppszwDisplayName);
        
        HRESULT ( STDMETHODCALLTYPE *SetDisplayName )( 
            INetCfgComponent * This,
            /* [string][in] */ LPCWSTR pszwDisplayName);
        
        HRESULT ( STDMETHODCALLTYPE *GetHelpText )( 
            INetCfgComponent * This,
            /* [string][out] */ LPWSTR *pszwHelpText);
        
        HRESULT ( STDMETHODCALLTYPE *GetId )( 
            INetCfgComponent * This,
            /* [string][out] */ LPWSTR *ppszwId);
        
        HRESULT ( STDMETHODCALLTYPE *GetCharacteristics )( 
            INetCfgComponent * This,
            /* [out] */ LPDWORD pdwCharacteristics);
        
        HRESULT ( STDMETHODCALLTYPE *GetInstanceGuid )( 
            INetCfgComponent * This,
            /* [out] */ GUID *pGuid);
        
        HRESULT ( STDMETHODCALLTYPE *GetPnpDevNodeId )( 
            INetCfgComponent * This,
            /* [string][out] */ LPWSTR *ppszwDevNodeId);
        
        HRESULT ( STDMETHODCALLTYPE *GetClassGuid )( 
            INetCfgComponent * This,
            /* [out] */ GUID *pGuid);
        
        HRESULT ( STDMETHODCALLTYPE *GetBindName )( 
            INetCfgComponent * This,
            /* [string][out] */ LPWSTR *ppszwBindName);
        
        HRESULT ( STDMETHODCALLTYPE *GetDeviceStatus )( 
            INetCfgComponent * This,
            /* [out] */ ULONG *pulStatus);
        
        HRESULT ( STDMETHODCALLTYPE *OpenParamKey )( 
            INetCfgComponent * This,
            /* [out] */ HKEY *phkey);
        
        HRESULT ( STDMETHODCALLTYPE *RaisePropertyUi )( 
            INetCfgComponent * This,
            /* [in] */ HWND hwndParent,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IUnknown *punkContext);
        
        END_INTERFACE
    } INetCfgComponentVtbl;

    interface INetCfgComponent
    {
        CONST_VTBL struct INetCfgComponentVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INetCfgComponent_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INetCfgComponent_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INetCfgComponent_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INetCfgComponent_GetDisplayName(This,ppszwDisplayName)	\
    (This)->lpVtbl -> GetDisplayName(This,ppszwDisplayName)

#define INetCfgComponent_SetDisplayName(This,pszwDisplayName)	\
    (This)->lpVtbl -> SetDisplayName(This,pszwDisplayName)

#define INetCfgComponent_GetHelpText(This,pszwHelpText)	\
    (This)->lpVtbl -> GetHelpText(This,pszwHelpText)

#define INetCfgComponent_GetId(This,ppszwId)	\
    (This)->lpVtbl -> GetId(This,ppszwId)

#define INetCfgComponent_GetCharacteristics(This,pdwCharacteristics)	\
    (This)->lpVtbl -> GetCharacteristics(This,pdwCharacteristics)

#define INetCfgComponent_GetInstanceGuid(This,pGuid)	\
    (This)->lpVtbl -> GetInstanceGuid(This,pGuid)

#define INetCfgComponent_GetPnpDevNodeId(This,ppszwDevNodeId)	\
    (This)->lpVtbl -> GetPnpDevNodeId(This,ppszwDevNodeId)

#define INetCfgComponent_GetClassGuid(This,pGuid)	\
    (This)->lpVtbl -> GetClassGuid(This,pGuid)

#define INetCfgComponent_GetBindName(This,ppszwBindName)	\
    (This)->lpVtbl -> GetBindName(This,ppszwBindName)

#define INetCfgComponent_GetDeviceStatus(This,pulStatus)	\
    (This)->lpVtbl -> GetDeviceStatus(This,pulStatus)

#define INetCfgComponent_OpenParamKey(This,phkey)	\
    (This)->lpVtbl -> OpenParamKey(This,phkey)

#define INetCfgComponent_RaisePropertyUi(This,hwndParent,dwFlags,punkContext)	\
    (This)->lpVtbl -> RaisePropertyUi(This,hwndParent,dwFlags,punkContext)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE INetCfgComponent_GetDisplayName_Proxy( 
    INetCfgComponent * This,
    /* [string][out] */ LPWSTR *ppszwDisplayName);


void __RPC_STUB INetCfgComponent_GetDisplayName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetCfgComponent_SetDisplayName_Proxy( 
    INetCfgComponent * This,
    /* [string][in] */ LPCWSTR pszwDisplayName);


void __RPC_STUB INetCfgComponent_SetDisplayName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetCfgComponent_GetHelpText_Proxy( 
    INetCfgComponent * This,
    /* [string][out] */ LPWSTR *pszwHelpText);


void __RPC_STUB INetCfgComponent_GetHelpText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetCfgComponent_GetId_Proxy( 
    INetCfgComponent * This,
    /* [string][out] */ LPWSTR *ppszwId);


void __RPC_STUB INetCfgComponent_GetId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetCfgComponent_GetCharacteristics_Proxy( 
    INetCfgComponent * This,
    /* [out] */ LPDWORD pdwCharacteristics);


void __RPC_STUB INetCfgComponent_GetCharacteristics_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetCfgComponent_GetInstanceGuid_Proxy( 
    INetCfgComponent * This,
    /* [out] */ GUID *pGuid);


void __RPC_STUB INetCfgComponent_GetInstanceGuid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetCfgComponent_GetPnpDevNodeId_Proxy( 
    INetCfgComponent * This,
    /* [string][out] */ LPWSTR *ppszwDevNodeId);


void __RPC_STUB INetCfgComponent_GetPnpDevNodeId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetCfgComponent_GetClassGuid_Proxy( 
    INetCfgComponent * This,
    /* [out] */ GUID *pGuid);


void __RPC_STUB INetCfgComponent_GetClassGuid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetCfgComponent_GetBindName_Proxy( 
    INetCfgComponent * This,
    /* [string][out] */ LPWSTR *ppszwBindName);


void __RPC_STUB INetCfgComponent_GetBindName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetCfgComponent_GetDeviceStatus_Proxy( 
    INetCfgComponent * This,
    /* [out] */ ULONG *pulStatus);


void __RPC_STUB INetCfgComponent_GetDeviceStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetCfgComponent_OpenParamKey_Proxy( 
    INetCfgComponent * This,
    /* [out] */ HKEY *phkey);


void __RPC_STUB INetCfgComponent_OpenParamKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetCfgComponent_RaisePropertyUi_Proxy( 
    INetCfgComponent * This,
    /* [in] */ HWND hwndParent,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IUnknown *punkContext);


void __RPC_STUB INetCfgComponent_RaisePropertyUi_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INetCfgComponent_INTERFACE_DEFINED__ */


#ifndef __INetCfgComponentBindings_INTERFACE_DEFINED__
#define __INetCfgComponentBindings_INTERFACE_DEFINED__

/* interface INetCfgComponentBindings */
/* [unique][uuid][object][local] */ 

typedef 
enum tagSUPPORTS_BINDING_INTERFACE_FLAGS
    {	NCF_LOWER	= 0x1,
	NCF_UPPER	= 0x2
    } 	SUPPORTS_BINDING_INTERFACE_FLAGS;

typedef 
enum tagENUM_BINDING_PATHS_FLAGS
    {	EBP_ABOVE	= 0x1,
	EBP_BELOW	= 0x2
    } 	ENUM_BINDING_PATHS_FLAGS;


EXTERN_C const IID IID_INetCfgComponentBindings;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C0E8AE9E-306E-11D1-AACF-00805FC1270E")
    INetCfgComponentBindings : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE BindTo( 
            /* [in] */ INetCfgComponent *pnccItem) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnbindFrom( 
            /* [in] */ INetCfgComponent *pnccItem) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SupportsBindingInterface( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCWSTR pszwInterfaceName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsBoundTo( 
            /* [in] */ INetCfgComponent *pnccItem) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsBindableTo( 
            /* [in] */ INetCfgComponent *pnccItem) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumBindingPaths( 
            /* [in] */ DWORD dwFlags,
            /* [out] */ IEnumNetCfgBindingPath **ppIEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MoveBefore( 
            /* [in] */ INetCfgBindingPath *pncbItemSrc,
            /* [in] */ INetCfgBindingPath *pncbItemDest) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MoveAfter( 
            /* [in] */ INetCfgBindingPath *pncbItemSrc,
            /* [in] */ INetCfgBindingPath *pncbItemDest) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INetCfgComponentBindingsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            INetCfgComponentBindings * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            INetCfgComponentBindings * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            INetCfgComponentBindings * This);
        
        HRESULT ( STDMETHODCALLTYPE *BindTo )( 
            INetCfgComponentBindings * This,
            /* [in] */ INetCfgComponent *pnccItem);
        
        HRESULT ( STDMETHODCALLTYPE *UnbindFrom )( 
            INetCfgComponentBindings * This,
            /* [in] */ INetCfgComponent *pnccItem);
        
        HRESULT ( STDMETHODCALLTYPE *SupportsBindingInterface )( 
            INetCfgComponentBindings * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCWSTR pszwInterfaceName);
        
        HRESULT ( STDMETHODCALLTYPE *IsBoundTo )( 
            INetCfgComponentBindings * This,
            /* [in] */ INetCfgComponent *pnccItem);
        
        HRESULT ( STDMETHODCALLTYPE *IsBindableTo )( 
            INetCfgComponentBindings * This,
            /* [in] */ INetCfgComponent *pnccItem);
        
        HRESULT ( STDMETHODCALLTYPE *EnumBindingPaths )( 
            INetCfgComponentBindings * This,
            /* [in] */ DWORD dwFlags,
            /* [out] */ IEnumNetCfgBindingPath **ppIEnum);
        
        HRESULT ( STDMETHODCALLTYPE *MoveBefore )( 
            INetCfgComponentBindings * This,
            /* [in] */ INetCfgBindingPath *pncbItemSrc,
            /* [in] */ INetCfgBindingPath *pncbItemDest);
        
        HRESULT ( STDMETHODCALLTYPE *MoveAfter )( 
            INetCfgComponentBindings * This,
            /* [in] */ INetCfgBindingPath *pncbItemSrc,
            /* [in] */ INetCfgBindingPath *pncbItemDest);
        
        END_INTERFACE
    } INetCfgComponentBindingsVtbl;

    interface INetCfgComponentBindings
    {
        CONST_VTBL struct INetCfgComponentBindingsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INetCfgComponentBindings_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INetCfgComponentBindings_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INetCfgComponentBindings_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INetCfgComponentBindings_BindTo(This,pnccItem)	\
    (This)->lpVtbl -> BindTo(This,pnccItem)

#define INetCfgComponentBindings_UnbindFrom(This,pnccItem)	\
    (This)->lpVtbl -> UnbindFrom(This,pnccItem)

#define INetCfgComponentBindings_SupportsBindingInterface(This,dwFlags,pszwInterfaceName)	\
    (This)->lpVtbl -> SupportsBindingInterface(This,dwFlags,pszwInterfaceName)

#define INetCfgComponentBindings_IsBoundTo(This,pnccItem)	\
    (This)->lpVtbl -> IsBoundTo(This,pnccItem)

#define INetCfgComponentBindings_IsBindableTo(This,pnccItem)	\
    (This)->lpVtbl -> IsBindableTo(This,pnccItem)

#define INetCfgComponentBindings_EnumBindingPaths(This,dwFlags,ppIEnum)	\
    (This)->lpVtbl -> EnumBindingPaths(This,dwFlags,ppIEnum)

#define INetCfgComponentBindings_MoveBefore(This,pncbItemSrc,pncbItemDest)	\
    (This)->lpVtbl -> MoveBefore(This,pncbItemSrc,pncbItemDest)

#define INetCfgComponentBindings_MoveAfter(This,pncbItemSrc,pncbItemDest)	\
    (This)->lpVtbl -> MoveAfter(This,pncbItemSrc,pncbItemDest)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE INetCfgComponentBindings_BindTo_Proxy( 
    INetCfgComponentBindings * This,
    /* [in] */ INetCfgComponent *pnccItem);


void __RPC_STUB INetCfgComponentBindings_BindTo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetCfgComponentBindings_UnbindFrom_Proxy( 
    INetCfgComponentBindings * This,
    /* [in] */ INetCfgComponent *pnccItem);


void __RPC_STUB INetCfgComponentBindings_UnbindFrom_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetCfgComponentBindings_SupportsBindingInterface_Proxy( 
    INetCfgComponentBindings * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ LPCWSTR pszwInterfaceName);


void __RPC_STUB INetCfgComponentBindings_SupportsBindingInterface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetCfgComponentBindings_IsBoundTo_Proxy( 
    INetCfgComponentBindings * This,
    /* [in] */ INetCfgComponent *pnccItem);


void __RPC_STUB INetCfgComponentBindings_IsBoundTo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetCfgComponentBindings_IsBindableTo_Proxy( 
    INetCfgComponentBindings * This,
    /* [in] */ INetCfgComponent *pnccItem);


void __RPC_STUB INetCfgComponentBindings_IsBindableTo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetCfgComponentBindings_EnumBindingPaths_Proxy( 
    INetCfgComponentBindings * This,
    /* [in] */ DWORD dwFlags,
    /* [out] */ IEnumNetCfgBindingPath **ppIEnum);


void __RPC_STUB INetCfgComponentBindings_EnumBindingPaths_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetCfgComponentBindings_MoveBefore_Proxy( 
    INetCfgComponentBindings * This,
    /* [in] */ INetCfgBindingPath *pncbItemSrc,
    /* [in] */ INetCfgBindingPath *pncbItemDest);


void __RPC_STUB INetCfgComponentBindings_MoveBefore_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetCfgComponentBindings_MoveAfter_Proxy( 
    INetCfgComponentBindings * This,
    /* [in] */ INetCfgBindingPath *pncbItemSrc,
    /* [in] */ INetCfgBindingPath *pncbItemDest);


void __RPC_STUB INetCfgComponentBindings_MoveAfter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INetCfgComponentBindings_INTERFACE_DEFINED__ */


#ifndef __INetCfgSysPrep_INTERFACE_DEFINED__
#define __INetCfgSysPrep_INTERFACE_DEFINED__

/* interface INetCfgSysPrep */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_INetCfgSysPrep;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C0E8AE98-306E-11D1-AACF-00805FC1270E")
    INetCfgSysPrep : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE HrSetupSetFirstDword( 
            /* [string][in] */ LPCWSTR pwszSection,
            /* [string][in] */ LPCWSTR pwszKey,
            /* [in] */ DWORD dwValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HrSetupSetFirstString( 
            /* [string][in] */ LPCWSTR pwszSection,
            /* [string][in] */ LPCWSTR pwszKey,
            /* [string][in] */ LPCWSTR pwszValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HrSetupSetFirstStringAsBool( 
            /* [string][in] */ LPCWSTR pwszSection,
            /* [string][in] */ LPCWSTR pwszKey,
            /* [in] */ BOOL fValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HrSetupSetFirstMultiSzField( 
            /* [string][in] */ LPCWSTR pwszSection,
            /* [string][in] */ LPCWSTR pwszKey,
            /* [in] */ LPCWSTR pmszValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INetCfgSysPrepVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            INetCfgSysPrep * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            INetCfgSysPrep * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            INetCfgSysPrep * This);
        
        HRESULT ( STDMETHODCALLTYPE *HrSetupSetFirstDword )( 
            INetCfgSysPrep * This,
            /* [string][in] */ LPCWSTR pwszSection,
            /* [string][in] */ LPCWSTR pwszKey,
            /* [in] */ DWORD dwValue);
        
        HRESULT ( STDMETHODCALLTYPE *HrSetupSetFirstString )( 
            INetCfgSysPrep * This,
            /* [string][in] */ LPCWSTR pwszSection,
            /* [string][in] */ LPCWSTR pwszKey,
            /* [string][in] */ LPCWSTR pwszValue);
        
        HRESULT ( STDMETHODCALLTYPE *HrSetupSetFirstStringAsBool )( 
            INetCfgSysPrep * This,
            /* [string][in] */ LPCWSTR pwszSection,
            /* [string][in] */ LPCWSTR pwszKey,
            /* [in] */ BOOL fValue);
        
        HRESULT ( STDMETHODCALLTYPE *HrSetupSetFirstMultiSzField )( 
            INetCfgSysPrep * This,
            /* [string][in] */ LPCWSTR pwszSection,
            /* [string][in] */ LPCWSTR pwszKey,
            /* [in] */ LPCWSTR pmszValue);
        
        END_INTERFACE
    } INetCfgSysPrepVtbl;

    interface INetCfgSysPrep
    {
        CONST_VTBL struct INetCfgSysPrepVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INetCfgSysPrep_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INetCfgSysPrep_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INetCfgSysPrep_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INetCfgSysPrep_HrSetupSetFirstDword(This,pwszSection,pwszKey,dwValue)	\
    (This)->lpVtbl -> HrSetupSetFirstDword(This,pwszSection,pwszKey,dwValue)

#define INetCfgSysPrep_HrSetupSetFirstString(This,pwszSection,pwszKey,pwszValue)	\
    (This)->lpVtbl -> HrSetupSetFirstString(This,pwszSection,pwszKey,pwszValue)

#define INetCfgSysPrep_HrSetupSetFirstStringAsBool(This,pwszSection,pwszKey,fValue)	\
    (This)->lpVtbl -> HrSetupSetFirstStringAsBool(This,pwszSection,pwszKey,fValue)

#define INetCfgSysPrep_HrSetupSetFirstMultiSzField(This,pwszSection,pwszKey,pmszValue)	\
    (This)->lpVtbl -> HrSetupSetFirstMultiSzField(This,pwszSection,pwszKey,pmszValue)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE INetCfgSysPrep_HrSetupSetFirstDword_Proxy( 
    INetCfgSysPrep * This,
    /* [string][in] */ LPCWSTR pwszSection,
    /* [string][in] */ LPCWSTR pwszKey,
    /* [in] */ DWORD dwValue);


void __RPC_STUB INetCfgSysPrep_HrSetupSetFirstDword_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetCfgSysPrep_HrSetupSetFirstString_Proxy( 
    INetCfgSysPrep * This,
    /* [string][in] */ LPCWSTR pwszSection,
    /* [string][in] */ LPCWSTR pwszKey,
    /* [string][in] */ LPCWSTR pwszValue);


void __RPC_STUB INetCfgSysPrep_HrSetupSetFirstString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetCfgSysPrep_HrSetupSetFirstStringAsBool_Proxy( 
    INetCfgSysPrep * This,
    /* [string][in] */ LPCWSTR pwszSection,
    /* [string][in] */ LPCWSTR pwszKey,
    /* [in] */ BOOL fValue);


void __RPC_STUB INetCfgSysPrep_HrSetupSetFirstStringAsBool_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetCfgSysPrep_HrSetupSetFirstMultiSzField_Proxy( 
    INetCfgSysPrep * This,
    /* [string][in] */ LPCWSTR pwszSection,
    /* [string][in] */ LPCWSTR pwszKey,
    /* [in] */ LPCWSTR pmszValue);


void __RPC_STUB INetCfgSysPrep_HrSetupSetFirstMultiSzField_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INetCfgSysPrep_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\ddk\inc\netcfgn.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0347 */
/* Compiler settings for netcfgn.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __netcfgn_h__
#define __netcfgn_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __INetCfgPnpReconfigCallback_FWD_DEFINED__
#define __INetCfgPnpReconfigCallback_FWD_DEFINED__
typedef interface INetCfgPnpReconfigCallback INetCfgPnpReconfigCallback;
#endif 	/* __INetCfgPnpReconfigCallback_FWD_DEFINED__ */


#ifndef __INetCfgComponentControl_FWD_DEFINED__
#define __INetCfgComponentControl_FWD_DEFINED__
typedef interface INetCfgComponentControl INetCfgComponentControl;
#endif 	/* __INetCfgComponentControl_FWD_DEFINED__ */


#ifndef __INetCfgComponentSetup_FWD_DEFINED__
#define __INetCfgComponentSetup_FWD_DEFINED__
typedef interface INetCfgComponentSetup INetCfgComponentSetup;
#endif 	/* __INetCfgComponentSetup_FWD_DEFINED__ */


#ifndef __INetCfgComponentPropertyUi_FWD_DEFINED__
#define __INetCfgComponentPropertyUi_FWD_DEFINED__
typedef interface INetCfgComponentPropertyUi INetCfgComponentPropertyUi;
#endif 	/* __INetCfgComponentPropertyUi_FWD_DEFINED__ */


#ifndef __INetCfgComponentNotifyBinding_FWD_DEFINED__
#define __INetCfgComponentNotifyBinding_FWD_DEFINED__
typedef interface INetCfgComponentNotifyBinding INetCfgComponentNotifyBinding;
#endif 	/* __INetCfgComponentNotifyBinding_FWD_DEFINED__ */


#ifndef __INetCfgComponentNotifyGlobal_FWD_DEFINED__
#define __INetCfgComponentNotifyGlobal_FWD_DEFINED__
typedef interface INetCfgComponentNotifyGlobal INetCfgComponentNotifyGlobal;
#endif 	/* __INetCfgComponentNotifyGlobal_FWD_DEFINED__ */


#ifndef __INetCfgComponentUpperEdge_FWD_DEFINED__
#define __INetCfgComponentUpperEdge_FWD_DEFINED__
typedef interface INetCfgComponentUpperEdge INetCfgComponentUpperEdge;
#endif 	/* __INetCfgComponentUpperEdge_FWD_DEFINED__ */


#ifndef __INetLanConnectionUiInfo_FWD_DEFINED__
#define __INetLanConnectionUiInfo_FWD_DEFINED__
typedef interface INetLanConnectionUiInfo INetLanConnectionUiInfo;
#endif 	/* __INetLanConnectionUiInfo_FWD_DEFINED__ */


#ifndef __INetCfgComponentSysPrep_FWD_DEFINED__
#define __INetCfgComponentSysPrep_FWD_DEFINED__
typedef interface INetCfgComponentSysPrep INetCfgComponentSysPrep;
#endif 	/* __INetCfgComponentSysPrep_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"
#include "netcfgx.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_netcfgn_0000 */
/* [local] */ 

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
//--------------------------------------------------------------------------
#if ( _MSC_VER >= 800 )
#pragma warning(disable:4201)
#endif


extern RPC_IF_HANDLE __MIDL_itf_netcfgn_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_netcfgn_0000_v0_0_s_ifspec;

#ifndef __INetCfgPnpReconfigCallback_INTERFACE_DEFINED__
#define __INetCfgPnpReconfigCallback_INTERFACE_DEFINED__

/* interface INetCfgPnpReconfigCallback */
/* [unique][uuid][object][local] */ 

typedef /* [v1_enum] */ 
enum tagNCPNP_RECONFIG_LAYER
    {	NCRL_NDIS	= 1,
	NCRL_TDI	= 2
    } 	NCPNP_RECONFIG_LAYER;


EXTERN_C const IID IID_INetCfgPnpReconfigCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8d84bd35-e227-11d2-b700-00a0c98a6a85")
    INetCfgPnpReconfigCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SendPnpReconfig( 
            /* [in] */ NCPNP_RECONFIG_LAYER Layer,
            /* [in] */ LPCWSTR pszwUpper,
            /* [in] */ LPCWSTR pszwLower,
            /* [in] */ PVOID pvData,
            /* [in] */ DWORD dwSizeOfData) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INetCfgPnpReconfigCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            INetCfgPnpReconfigCallback * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            INetCfgPnpReconfigCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            INetCfgPnpReconfigCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *SendPnpReconfig )( 
            INetCfgPnpReconfigCallback * This,
            /* [in] */ NCPNP_RECONFIG_LAYER Layer,
            /* [in] */ LPCWSTR pszwUpper,
            /* [in] */ LPCWSTR pszwLower,
            /* [in] */ PVOID pvData,
            /* [in] */ DWORD dwSizeOfData);
        
        END_INTERFACE
    } INetCfgPnpReconfigCallbackVtbl;

    interface INetCfgPnpReconfigCallback
    {
        CONST_VTBL struct INetCfgPnpReconfigCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INetCfgPnpReconfigCallback_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INetCfgPnpReconfigCallback_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INetCfgPnpReconfigCallback_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INetCfgPnpReconfigCallback_SendPnpReconfig(This,Layer,pszwUpper,pszwLower,pvData,dwSizeOfData)	\
    (This)->lpVtbl -> SendPnpReconfig(This,Layer,pszwUpper,pszwLower,pvData,dwSizeOfData)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE INetCfgPnpReconfigCallback_SendPnpReconfig_Proxy( 
    INetCfgPnpReconfigCallback * This,
    /* [in] */ NCPNP_RECONFIG_LAYER Layer,
    /* [in] */ LPCWSTR pszwUpper,
    /* [in] */ LPCWSTR pszwLower,
    /* [in] */ PVOID pvData,
    /* [in] */ DWORD dwSizeOfData);


void __RPC_STUB INetCfgPnpReconfigCallback_SendPnpReconfig_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INetCfgPnpReconfigCallback_INTERFACE_DEFINED__ */


#ifndef __INetCfgComponentControl_INTERFACE_DEFINED__
#define __INetCfgComponentControl_INTERFACE_DEFINED__

/* interface INetCfgComponentControl */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_INetCfgComponentControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("932238df-bea1-11d0-9298-00c04fc99dcf")
    INetCfgComponentControl : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ INetCfgComponent *pIComp,
            /* [in] */ INetCfg *pINetCfg,
            /* [in] */ BOOL fInstalling) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ApplyRegistryChanges( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ApplyPnpChanges( 
            /* [in] */ INetCfgPnpReconfigCallback *pICallback) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CancelChanges( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INetCfgComponentControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            INetCfgComponentControl * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            INetCfgComponentControl * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            INetCfgComponentControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            INetCfgComponentControl * This,
            /* [in] */ INetCfgComponent *pIComp,
            /* [in] */ INetCfg *pINetCfg,
            /* [in] */ BOOL fInstalling);
        
        HRESULT ( STDMETHODCALLTYPE *ApplyRegistryChanges )( 
            INetCfgComponentControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *ApplyPnpChanges )( 
            INetCfgComponentControl * This,
            /* [in] */ INetCfgPnpReconfigCallback *pICallback);
        
        HRESULT ( STDMETHODCALLTYPE *CancelChanges )( 
            INetCfgComponentControl * This);
        
        END_INTERFACE
    } INetCfgComponentControlVtbl;

    interface INetCfgComponentControl
    {
        CONST_VTBL struct INetCfgComponentControlVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INetCfgComponentControl_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INetCfgComponentControl_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INetCfgComponentControl_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INetCfgComponentControl_Initialize(This,pIComp,pINetCfg,fInstalling)	\
    (This)->lpVtbl -> Initialize(This,pIComp,pINetCfg,fInstalling)

#define INetCfgComponentControl_ApplyRegistryChanges(This)	\
    (This)->lpVtbl -> ApplyRegistryChanges(This)

#define INetCfgComponentControl_ApplyPnpChanges(This,pICallback)	\
    (This)->lpVtbl -> ApplyPnpChanges(This,pICallback)

#define INetCfgComponentControl_CancelChanges(This)	\
    (This)->lpVtbl -> CancelChanges(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE INetCfgComponentControl_Initialize_Proxy( 
    INetCfgComponentControl * This,
    /* [in] */ INetCfgComponent *pIComp,
    /* [in] */ INetCfg *pINetCfg,
    /* [in] */ BOOL fInstalling);


void __RPC_STUB INetCfgComponentControl_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetCfgComponentControl_ApplyRegistryChanges_Proxy( 
    INetCfgComponentControl * This);


void __RPC_STUB INetCfgComponentControl_ApplyRegistryChanges_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetCfgComponentControl_ApplyPnpChanges_Proxy( 
    INetCfgComponentControl * This,
    /* [in] */ INetCfgPnpReconfigCallback *pICallback);


void __RPC_STUB INetCfgComponentControl_ApplyPnpChanges_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetCfgComponentControl_CancelChanges_Proxy( 
    INetCfgComponentControl * This);


void __RPC_STUB INetCfgComponentControl_CancelChanges_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INetCfgComponentControl_INTERFACE_DEFINED__ */


#ifndef __INetCfgComponentSetup_INTERFACE_DEFINED__
#define __INetCfgComponentSetup_INTERFACE_DEFINED__

/* interface INetCfgComponentSetup */
/* [unique][uuid][object][local] */ 

typedef /* [v1_enum] */ 
enum tagNETWORK_INSTALL_TIME
    {	NSF_PRIMARYINSTALL	= 0x1,
	NSF_POSTSYSINSTALL	= 0x2
    } 	NETWORK_INSTALL_TIME;

typedef /* [v1_enum] */ 
enum tagNETWORK_UPGRADE_TYPE
    {	NSF_WIN16_UPGRADE	= 0x10,
	NSF_WIN95_UPGRADE	= 0x20,
	NSF_WINNT_WKS_UPGRADE	= 0x40,
	NSF_WINNT_SVR_UPGRADE	= 0x80,
	NSF_WINNT_SBS_UPGRADE	= 0x100,
	NSF_COMPONENT_UPDATE	= 0x200
    } 	NETWORK_UPGRADE_TYPE;


EXTERN_C const IID IID_INetCfgComponentSetup;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("932238e3-bea1-11d0-9298-00c04fc99dcf")
    INetCfgComponentSetup : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Install( 
            /* [in] */ DWORD dwSetupFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Upgrade( 
            /* [in] */ DWORD dwSetupFlags,
            /* [in] */ DWORD dwUpgradeFomBuildNo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReadAnswerFile( 
            /* [in] */ LPCWSTR pszwAnswerFile,
            /* [in] */ LPCWSTR pszwAnswerSections) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Removing( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INetCfgComponentSetupVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            INetCfgComponentSetup * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            INetCfgComponentSetup * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            INetCfgComponentSetup * This);
        
        HRESULT ( STDMETHODCALLTYPE *Install )( 
            INetCfgComponentSetup * This,
            /* [in] */ DWORD dwSetupFlags);
        
        HRESULT ( STDMETHODCALLTYPE *Upgrade )( 
            INetCfgComponentSetup * This,
            /* [in] */ DWORD dwSetupFlags,
            /* [in] */ DWORD dwUpgradeFomBuildNo);
        
        HRESULT ( STDMETHODCALLTYPE *ReadAnswerFile )( 
            INetCfgComponentSetup * This,
            /* [in] */ LPCWSTR pszwAnswerFile,
            /* [in] */ LPCWSTR pszwAnswerSections);
        
        HRESULT ( STDMETHODCALLTYPE *Removing )( 
            INetCfgComponentSetup * This);
        
        END_INTERFACE
    } INetCfgComponentSetupVtbl;

    interface INetCfgComponentSetup
    {
        CONST_VTBL struct INetCfgComponentSetupVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INetCfgComponentSetup_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INetCfgComponentSetup_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INetCfgComponentSetup_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INetCfgComponentSetup_Install(This,dwSetupFlags)	\
    (This)->lpVtbl -> Install(This,dwSetupFlags)

#define INetCfgComponentSetup_Upgrade(This,dwSetupFlags,dwUpgradeFomBuildNo)	\
    (This)->lpVtbl -> Upgrade(This,dwSetupFlags,dwUpgradeFomBuildNo)

#define INetCfgComponentSetup_ReadAnswerFile(This,pszwAnswerFile,pszwAnswerSections)	\
    (This)->lpVtbl -> ReadAnswerFile(This,pszwAnswerFile,pszwAnswerSections)

#define INetCfgComponentSetup_Removing(This)	\
    (This)->lpVtbl -> Removing(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE INetCfgComponentSetup_Install_Proxy( 
    INetCfgComponentSetup * This,
    /* [in] */ DWORD dwSetupFlags);


void __RPC_STUB INetCfgComponentSetup_Install_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetCfgComponentSetup_Upgrade_Proxy( 
    INetCfgComponentSetup * This,
    /* [in] */ DWORD dwSetupFlags,
    /* [in] */ DWORD dwUpgradeFomBuildNo);


void __RPC_STUB INetCfgComponentSetup_Upgrade_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetCfgComponentSetup_ReadAnswerFile_Proxy( 
    INetCfgComponentSetup * This,
    /* [in] */ LPCWSTR pszwAnswerFile,
    /* [in] */ LPCWSTR pszwAnswerSections);


void __RPC_STUB INetCfgComponentSetup_ReadAnswerFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetCfgComponentSetup_Removing_Proxy( 
    INetCfgComponentSetup * This);


void __RPC_STUB INetCfgComponentSetup_Removing_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INetCfgComponentSetup_INTERFACE_DEFINED__ */


#ifndef __INetCfgComponentPropertyUi_INTERFACE_DEFINED__
#define __INetCfgComponentPropertyUi_INTERFACE_DEFINED__

/* interface INetCfgComponentPropertyUi */
/* [unique][uuid][object][local] */ 

typedef /* [v1_enum] */ 
enum tagDEFAULT_PAGES
    {	DPP_ADVANCED	= 1
    } 	DEFAULT_PAGES;


EXTERN_C const IID IID_INetCfgComponentPropertyUi;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("932238e0-bea1-11d0-9298-00c04fc99dcf")
    INetCfgComponentPropertyUi : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE QueryPropertyUi( 
            /* [in] */ IUnknown *pUnkReserved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetContext( 
            /* [in] */ IUnknown *pUnkReserved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MergePropPages( 
            /* [out][in] */ DWORD *pdwDefPages,
            /* [out] */ BYTE **pahpspPrivate,
            /* [out] */ UINT *pcPages,
            /* [in] */ HWND hwndParent,
            /* [out] */ LPCWSTR *pszStartPage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ValidateProperties( 
            /* [in] */ HWND hwndSheet) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ApplyProperties( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CancelProperties( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INetCfgComponentPropertyUiVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            INetCfgComponentPropertyUi * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            INetCfgComponentPropertyUi * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            INetCfgComponentPropertyUi * This);
        
        HRESULT ( STDMETHODCALLTYPE *QueryPropertyUi )( 
            INetCfgComponentPropertyUi * This,
            /* [in] */ IUnknown *pUnkReserved);
        
        HRESULT ( STDMETHODCALLTYPE *SetContext )( 
            INetCfgComponentPropertyUi * This,
            /* [in] */ IUnknown *pUnkReserved);
        
        HRESULT ( STDMETHODCALLTYPE *MergePropPages )( 
            INetCfgComponentPropertyUi * This,
            /* [out][in] */ DWORD *pdwDefPages,
            /* [out] */ BYTE **pahpspPrivate,
            /* [out] */ UINT *pcPages,
            /* [in] */ HWND hwndParent,
            /* [out] */ LPCWSTR *pszStartPage);
        
        HRESULT ( STDMETHODCALLTYPE *ValidateProperties )( 
            INetCfgComponentPropertyUi * This,
            /* [in] */ HWND hwndSheet);
        
        HRESULT ( STDMETHODCALLTYPE *ApplyProperties )( 
            INetCfgComponentPropertyUi * This);
        
        HRESULT ( STDMETHODCALLTYPE *CancelProperties )( 
            INetCfgComponentPropertyUi * This);
        
        END_INTERFACE
    } INetCfgComponentPropertyUiVtbl;

    interface INetCfgComponentPropertyUi
    {
        CONST_VTBL struct INetCfgComponentPropertyUiVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INetCfgComponentPropertyUi_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INetCfgComponentPropertyUi_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INetCfgComponentPropertyUi_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INetCfgComponentPropertyUi_QueryPropertyUi(This,pUnkReserved)	\
    (This)->lpVtbl -> QueryPropertyUi(This,pUnkReserved)

#define INetCfgComponentPropertyUi_SetContext(This,pUnkReserved)	\
    (This)->lpVtbl -> SetContext(This,pUnkReserved)

#define INetCfgComponentPropertyUi_MergePropPages(This,pdwDefPages,pahpspPrivate,pcPages,hwndParent,pszStartPage)	\
    (This)->lpVtbl -> MergePropPages(This,pdwDefPages,pahpspPrivate,pcPages,hwndParent,pszStartPage)

#define INetCfgComponentPropertyUi_ValidateProperties(This,hwndSheet)	\
    (This)->lpVtbl -> ValidateProperties(This,hwndSheet)

#define INetCfgComponentPropertyUi_ApplyProperties(This)	\
    (This)->lpVtbl -> ApplyProperties(This)

#define INetCfgComponentPropertyUi_CancelProperties(This)	\
    (This)->lpVtbl -> CancelProperties(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE INetCfgComponentPropertyUi_QueryPropertyUi_Proxy( 
    INetCfgComponentPropertyUi * This,
    /* [in] */ IUnknown *pUnkReserved);


void __RPC_STUB INetCfgComponentPropertyUi_QueryPropertyUi_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetCfgComponentPropertyUi_SetContext_Proxy( 
    INetCfgComponentPropertyUi * This,
    /* [in] */ IUnknown *pUnkReserved);


void __RPC_STUB INetCfgComponentPropertyUi_SetContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetCfgComponentPropertyUi_MergePropPages_Proxy( 
    INetCfgComponentPropertyUi * This,
    /* [out][in] */ DWORD *pdwDefPages,
    /* [out] */ BYTE **pahpspPrivate,
    /* [out] */ UINT *pcPages,
    /* [in] */ HWND hwndParent,
    /* [out] */ LPCWSTR *pszStartPage);


void __RPC_STUB INetCfgComponentPropertyUi_MergePropPages_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetCfgComponentPropertyUi_ValidateProperties_Proxy( 
    INetCfgComponentPropertyUi * This,
    /* [in] */ HWND hwndSheet);


void __RPC_STUB INetCfgComponentPropertyUi_ValidateProperties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetCfgComponentPropertyUi_ApplyProperties_Proxy( 
    INetCfgComponentPropertyUi * This);


void __RPC_STUB INetCfgComponentPropertyUi_ApplyProperties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetCfgComponentPropertyUi_CancelProperties_Proxy( 
    INetCfgComponentPropertyUi * This);


void __RPC_STUB INetCfgComponentPropertyUi_CancelProperties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INetCfgComponentPropertyUi_INTERFACE_DEFINED__ */


#ifndef __INetCfgComponentNotifyBinding_INTERFACE_DEFINED__
#define __INetCfgComponentNotifyBinding_INTERFACE_DEFINED__

/* interface INetCfgComponentNotifyBinding */
/* [unique][uuid][object][local] */ 

typedef /* [v1_enum] */ 
enum tagBIND_FLAGS1
    {	NCN_ADD	= 0x1,
	NCN_REMOVE	= 0x2,
	NCN_UPDATE	= 0x4,
	NCN_ENABLE	= 0x10,
	NCN_DISABLE	= 0x20,
	NCN_BINDING_PATH	= 0x100,
	NCN_PROPERTYCHANGE	= 0x200,
	NCN_NET	= 0x10000,
	NCN_NETTRANS	= 0x20000,
	NCN_NETCLIENT	= 0x40000,
	NCN_NETSERVICE	= 0x80000
    } 	BIND_FLAGS1;


EXTERN_C const IID IID_INetCfgComponentNotifyBinding;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("932238e1-bea1-11d0-9298-00c04fc99dcf")
    INetCfgComponentNotifyBinding : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE QueryBindingPath( 
            /* [in] */ DWORD dwChangeFlag,
            /* [in] */ INetCfgBindingPath *pIPath) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NotifyBindingPath( 
            /* [in] */ DWORD dwChangeFlag,
            /* [in] */ INetCfgBindingPath *pIPath) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INetCfgComponentNotifyBindingVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            INetCfgComponentNotifyBinding * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            INetCfgComponentNotifyBinding * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            INetCfgComponentNotifyBinding * This);
        
        HRESULT ( STDMETHODCALLTYPE *QueryBindingPath )( 
            INetCfgComponentNotifyBinding * This,
            /* [in] */ DWORD dwChangeFlag,
            /* [in] */ INetCfgBindingPath *pIPath);
        
        HRESULT ( STDMETHODCALLTYPE *NotifyBindingPath )( 
            INetCfgComponentNotifyBinding * This,
            /* [in] */ DWORD dwChangeFlag,
            /* [in] */ INetCfgBindingPath *pIPath);
        
        END_INTERFACE
    } INetCfgComponentNotifyBindingVtbl;

    interface INetCfgComponentNotifyBinding
    {
        CONST_VTBL struct INetCfgComponentNotifyBindingVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INetCfgComponentNotifyBinding_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INetCfgComponentNotifyBinding_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INetCfgComponentNotifyBinding_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INetCfgComponentNotifyBinding_QueryBindingPath(This,dwChangeFlag,pIPath)	\
    (This)->lpVtbl -> QueryBindingPath(This,dwChangeFlag,pIPath)

#define INetCfgComponentNotifyBinding_NotifyBindingPath(This,dwChangeFlag,pIPath)	\
    (This)->lpVtbl -> NotifyBindingPath(This,dwChangeFlag,pIPath)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE INetCfgComponentNotifyBinding_QueryBindingPath_Proxy( 
    INetCfgComponentNotifyBinding * This,
    /* [in] */ DWORD dwChangeFlag,
    /* [in] */ INetCfgBindingPath *pIPath);


void __RPC_STUB INetCfgComponentNotifyBinding_QueryBindingPath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetCfgComponentNotifyBinding_NotifyBindingPath_Proxy( 
    INetCfgComponentNotifyBinding * This,
    /* [in] */ DWORD dwChangeFlag,
    /* [in] */ INetCfgBindingPath *pIPath);


void __RPC_STUB INetCfgComponentNotifyBinding_NotifyBindingPath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INetCfgComponentNotifyBinding_INTERFACE_DEFINED__ */


#ifndef __INetCfgComponentNotifyGlobal_INTERFACE_DEFINED__
#define __INetCfgComponentNotifyGlobal_INTERFACE_DEFINED__

/* interface INetCfgComponentNotifyGlobal */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_INetCfgComponentNotifyGlobal;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("932238e2-bea1-11d0-9298-00c04fc99dcf")
    INetCfgComponentNotifyGlobal : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetSupportedNotifications( 
            /* [out] */ DWORD *dwNotifications) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SysQueryBindingPath( 
            /* [in] */ DWORD dwChangeFlag,
            /* [in] */ INetCfgBindingPath *pIPath) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SysNotifyBindingPath( 
            /* [in] */ DWORD dwChangeFlag,
            /* [in] */ INetCfgBindingPath *pIPath) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SysNotifyComponent( 
            /* [in] */ DWORD dwChangeFlag,
            /* [in] */ INetCfgComponent *pIComp) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INetCfgComponentNotifyGlobalVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            INetCfgComponentNotifyGlobal * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            INetCfgComponentNotifyGlobal * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            INetCfgComponentNotifyGlobal * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetSupportedNotifications )( 
            INetCfgComponentNotifyGlobal * This,
            /* [out] */ DWORD *dwNotifications);
        
        HRESULT ( STDMETHODCALLTYPE *SysQueryBindingPath )( 
            INetCfgComponentNotifyGlobal * This,
            /* [in] */ DWORD dwChangeFlag,
            /* [in] */ INetCfgBindingPath *pIPath);
        
        HRESULT ( STDMETHODCALLTYPE *SysNotifyBindingPath )( 
            INetCfgComponentNotifyGlobal * This,
            /* [in] */ DWORD dwChangeFlag,
            /* [in] */ INetCfgBindingPath *pIPath);
        
        HRESULT ( STDMETHODCALLTYPE *SysNotifyComponent )( 
            INetCfgComponentNotifyGlobal * This,
            /* [in] */ DWORD dwChangeFlag,
            /* [in] */ INetCfgComponent *pIComp);
        
        END_INTERFACE
    } INetCfgComponentNotifyGlobalVtbl;

    interface INetCfgComponentNotifyGlobal
    {
        CONST_VTBL struct INetCfgComponentNotifyGlobalVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INetCfgComponentNotifyGlobal_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INetCfgComponentNotifyGlobal_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INetCfgComponentNotifyGlobal_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INetCfgComponentNotifyGlobal_GetSupportedNotifications(This,dwNotifications)	\
    (This)->lpVtbl -> GetSupportedNotifications(This,dwNotifications)

#define INetCfgComponentNotifyGlobal_SysQueryBindingPath(This,dwChangeFlag,pIPath)	\
    (This)->lpVtbl -> SysQueryBindingPath(This,dwChangeFlag,pIPath)

#define INetCfgComponentNotifyGlobal_SysNotifyBindingPath(This,dwChangeFlag,pIPath)	\
    (This)->lpVtbl -> SysNotifyBindingPath(This,dwChangeFlag,pIPath)

#define INetCfgComponentNotifyGlobal_SysNotifyComponent(This,dwChangeFlag,pIComp)	\
    (This)->lpVtbl -> SysNotifyComponent(This,dwChangeFlag,pIComp)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE INetCfgComponentNotifyGlobal_GetSupportedNotifications_Proxy( 
    INetCfgComponentNotifyGlobal * This,
    /* [out] */ DWORD *dwNotifications);


void __RPC_STUB INetCfgComponentNotifyGlobal_GetSupportedNotifications_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetCfgComponentNotifyGlobal_SysQueryBindingPath_Proxy( 
    INetCfgComponentNotifyGlobal * This,
    /* [in] */ DWORD dwChangeFlag,
    /* [in] */ INetCfgBindingPath *pIPath);


void __RPC_STUB INetCfgComponentNotifyGlobal_SysQueryBindingPath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetCfgComponentNotifyGlobal_SysNotifyBindingPath_Proxy( 
    INetCfgComponentNotifyGlobal * This,
    /* [in] */ DWORD dwChangeFlag,
    /* [in] */ INetCfgBindingPath *pIPath);


void __RPC_STUB INetCfgComponentNotifyGlobal_SysNotifyBindingPath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetCfgComponentNotifyGlobal_SysNotifyComponent_Proxy( 
    INetCfgComponentNotifyGlobal * This,
    /* [in] */ DWORD dwChangeFlag,
    /* [in] */ INetCfgComponent *pIComp);


void __RPC_STUB INetCfgComponentNotifyGlobal_SysNotifyComponent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INetCfgComponentNotifyGlobal_INTERFACE_DEFINED__ */


#ifndef __INetCfgComponentUpperEdge_INTERFACE_DEFINED__
#define __INetCfgComponentUpperEdge_INTERFACE_DEFINED__

/* interface INetCfgComponentUpperEdge */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_INetCfgComponentUpperEdge;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("932238e4-bea1-11d0-9298-00c04fc99dcf")
    INetCfgComponentUpperEdge : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetInterfaceIdsForAdapter( 
            /* [in] */ INetCfgComponent *pAdapter,
            /* [out] */ DWORD *pdwNumInterfaces,
            /* [out] */ GUID **ppguidInterfaceIds) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddInterfacesToAdapter( 
            /* [in] */ INetCfgComponent *pAdapter,
            /* [in] */ DWORD dwNumInterfaces) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveInterfacesFromAdapter( 
            /* [in] */ INetCfgComponent *pAdapter,
            /* [in] */ DWORD dwNumInterfaces,
            /* [in] */ const GUID *pguidInterfaceIds) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INetCfgComponentUpperEdgeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            INetCfgComponentUpperEdge * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            INetCfgComponentUpperEdge * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            INetCfgComponentUpperEdge * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetInterfaceIdsForAdapter )( 
            INetCfgComponentUpperEdge * This,
            /* [in] */ INetCfgComponent *pAdapter,
            /* [out] */ DWORD *pdwNumInterfaces,
            /* [out] */ GUID **ppguidInterfaceIds);
        
        HRESULT ( STDMETHODCALLTYPE *AddInterfacesToAdapter )( 
            INetCfgComponentUpperEdge * This,
            /* [in] */ INetCfgComponent *pAdapter,
            /* [in] */ DWORD dwNumInterfaces);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveInterfacesFromAdapter )( 
            INetCfgComponentUpperEdge * This,
            /* [in] */ INetCfgComponent *pAdapter,
            /* [in] */ DWORD dwNumInterfaces,
            /* [in] */ const GUID *pguidInterfaceIds);
        
        END_INTERFACE
    } INetCfgComponentUpperEdgeVtbl;

    interface INetCfgComponentUpperEdge
    {
        CONST_VTBL struct INetCfgComponentUpperEdgeVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INetCfgComponentUpperEdge_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INetCfgComponentUpperEdge_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INetCfgComponentUpperEdge_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INetCfgComponentUpperEdge_GetInterfaceIdsForAdapter(This,pAdapter,pdwNumInterfaces,ppguidInterfaceIds)	\
    (This)->lpVtbl -> GetInterfaceIdsForAdapter(This,pAdapter,pdwNumInterfaces,ppguidInterfaceIds)

#define INetCfgComponentUpperEdge_AddInterfacesToAdapter(This,pAdapter,dwNumInterfaces)	\
    (This)->lpVtbl -> AddInterfacesToAdapter(This,pAdapter,dwNumInterfaces)

#define INetCfgComponentUpperEdge_RemoveInterfacesFromAdapter(This,pAdapter,dwNumInterfaces,pguidInterfaceIds)	\
    (This)->lpVtbl -> RemoveInterfacesFromAdapter(This,pAdapter,dwNumInterfaces,pguidInterfaceIds)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE INetCfgComponentUpperEdge_GetInterfaceIdsForAdapter_Proxy( 
    INetCfgComponentUpperEdge * This,
    /* [in] */ INetCfgComponent *pAdapter,
    /* [out] */ DWORD *pdwNumInterfaces,
    /* [out] */ GUID **ppguidInterfaceIds);


void __RPC_STUB INetCfgComponentUpperEdge_GetInterfaceIdsForAdapter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetCfgComponentUpperEdge_AddInterfacesToAdapter_Proxy( 
    INetCfgComponentUpperEdge * This,
    /* [in] */ INetCfgComponent *pAdapter,
    /* [in] */ DWORD dwNumInterfaces);


void __RPC_STUB INetCfgComponentUpperEdge_AddInterfacesToAdapter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetCfgComponentUpperEdge_RemoveInterfacesFromAdapter_Proxy( 
    INetCfgComponentUpperEdge * This,
    /* [in] */ INetCfgComponent *pAdapter,
    /* [in] */ DWORD dwNumInterfaces,
    /* [in] */ const GUID *pguidInterfaceIds);


void __RPC_STUB INetCfgComponentUpperEdge_RemoveInterfacesFromAdapter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INetCfgComponentUpperEdge_INTERFACE_DEFINED__ */


#ifndef __INetLanConnectionUiInfo_INTERFACE_DEFINED__
#define __INetLanConnectionUiInfo_INTERFACE_DEFINED__

/* interface INetLanConnectionUiInfo */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_INetLanConnectionUiInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C08956A6-1CD3-11D1-B1C5-00805FC1270E")
    INetLanConnectionUiInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetDeviceGuid( 
            /* [out] */ GUID *pguid) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INetLanConnectionUiInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            INetLanConnectionUiInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            INetLanConnectionUiInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            INetLanConnectionUiInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetDeviceGuid )( 
            INetLanConnectionUiInfo * This,
            /* [out] */ GUID *pguid);
        
        END_INTERFACE
    } INetLanConnectionUiInfoVtbl;

    interface INetLanConnectionUiInfo
    {
        CONST_VTBL struct INetLanConnectionUiInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INetLanConnectionUiInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INetLanConnectionUiInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INetLanConnectionUiInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INetLanConnectionUiInfo_GetDeviceGuid(This,pguid)	\
    (This)->lpVtbl -> GetDeviceGuid(This,pguid)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE INetLanConnectionUiInfo_GetDeviceGuid_Proxy( 
    INetLanConnectionUiInfo * This,
    /* [out] */ GUID *pguid);


void __RPC_STUB INetLanConnectionUiInfo_GetDeviceGuid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INetLanConnectionUiInfo_INTERFACE_DEFINED__ */


#ifndef __INetCfgComponentSysPrep_INTERFACE_DEFINED__
#define __INetCfgComponentSysPrep_INTERFACE_DEFINED__

/* interface INetCfgComponentSysPrep */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_INetCfgComponentSysPrep;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C0E8AE9A-306E-11D1-AACF-00805FC1270E")
    INetCfgComponentSysPrep : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SaveAdapterParameters( 
            /* [in] */ INetCfgSysPrep *pncsp,
            /* [in] */ LPCWSTR pszwAnswerSections,
            /* [in] */ GUID *pAdapterInstanceGuid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RestoreAdapterParameters( 
            /* [in] */ LPCWSTR pszwAnswerFile,
            /* [in] */ LPCWSTR pszwAnswerSection,
            /* [in] */ GUID *pAdapterInstanceGuid) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INetCfgComponentSysPrepVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            INetCfgComponentSysPrep * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            INetCfgComponentSysPrep * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            INetCfgComponentSysPrep * This);
        
        HRESULT ( STDMETHODCALLTYPE *SaveAdapterParameters )( 
            INetCfgComponentSysPrep * This,
            /* [in] */ INetCfgSysPrep *pncsp,
            /* [in] */ LPCWSTR pszwAnswerSections,
            /* [in] */ GUID *pAdapterInstanceGuid);
        
        HRESULT ( STDMETHODCALLTYPE *RestoreAdapterParameters )( 
            INetCfgComponentSysPrep * This,
            /* [in] */ LPCWSTR pszwAnswerFile,
            /* [in] */ LPCWSTR pszwAnswerSection,
            /* [in] */ GUID *pAdapterInstanceGuid);
        
        END_INTERFACE
    } INetCfgComponentSysPrepVtbl;

    interface INetCfgComponentSysPrep
    {
        CONST_VTBL struct INetCfgComponentSysPrepVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INetCfgComponentSysPrep_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define INetCfgComponentSysPrep_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define INetCfgComponentSysPrep_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define INetCfgComponentSysPrep_SaveAdapterParameters(This,pncsp,pszwAnswerSections,pAdapterInstanceGuid)	\
    (This)->lpVtbl -> SaveAdapterParameters(This,pncsp,pszwAnswerSections,pAdapterInstanceGuid)

#define INetCfgComponentSysPrep_RestoreAdapterParameters(This,pszwAnswerFile,pszwAnswerSection,pAdapterInstanceGuid)	\
    (This)->lpVtbl -> RestoreAdapterParameters(This,pszwAnswerFile,pszwAnswerSection,pAdapterInstanceGuid)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE INetCfgComponentSysPrep_SaveAdapterParameters_Proxy( 
    INetCfgComponentSysPrep * This,
    /* [in] */ INetCfgSysPrep *pncsp,
    /* [in] */ LPCWSTR pszwAnswerSections,
    /* [in] */ GUID *pAdapterInstanceGuid);


void __RPC_STUB INetCfgComponentSysPrep_SaveAdapterParameters_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE INetCfgComponentSysPrep_RestoreAdapterParameters_Proxy( 
    INetCfgComponentSysPrep * This,
    /* [in] */ LPCWSTR pszwAnswerFile,
    /* [in] */ LPCWSTR pszwAnswerSection,
    /* [in] */ GUID *pAdapterInstanceGuid);


void __RPC_STUB INetCfgComponentSysPrep_RestoreAdapterParameters_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __INetCfgComponentSysPrep_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\public\ddk\inc\ndis.h ===
/*++ BUILD Version: 0095    // Increment this if a change has global effects

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    ndis.h

Abstract:

    This module defines the structures, macros, and functions available
    to NDIS drivers.

Revision History:

--*/

#if !defined(_NDIS_)
#define _NDIS_

#if !defined(NDIS_WDM)
#define NDIS_WDM        0
#endif

//
// If we're building a miniport on x86, set BINARY_COMPATIBLE so that
// we don't use functions that aren't available on Windows 9x.
//

#if !defined(BINARY_COMPATIBLE)
#if defined(NDIS_MINIPORT_DRIVER) && defined(_M_IX86)
#define BINARY_COMPATIBLE 1
#else
#define BINARY_COMPATIBLE 0
#endif
#endif

#if !defined(_M_IX86)
#undef BINARY_COMPATIBLE
#define BINARY_COMPATIBLE 0
#endif

//
// BEGIN INTERNAL DEFINITIONS
//

//
// BINARY_COMPATIBLE = 1 and NDIS_WDM = 1 then use wdm.h
// BINARY_COMPATIBLE = 1 and NDIS_WDM = 0 then use ndis.h only
// BINARY_COMPATIBLE = 0 and NDIS_WDM = 1 then use ntddk.h
// BINARY_COMPATIBLE = 0 and NDIS_WDM = 0 then use ntddk.h
//

#if (BINARY_COMPATIBLE && !NDIS_WDM)

//
// BINARY_COMPATIBLE = 1 and NDIS_WDM = 0 then use ndis.h only
//
// The following internal definitions are included here in order to allow
// the exported NDIS structures, macros, and functions to compile.  They
// must not be used directly by miniport drivers.
//

#define _NTDDK_

#include <ctype.h>  

#ifndef IN
#define IN
#endif

#ifndef OUT
#define OUT
#endif

#ifndef OPTIONAL
#define OPTIONAL
#endif

#ifndef NOTHING
#define NOTHING
#endif

#ifndef CRITICAL
#define CRITICAL
#endif

#ifndef ANYSIZE_ARRAY
#define ANYSIZE_ARRAY 1       // winnt
#endif

// begin_winnt

#if defined(_M_MRX000) && !(defined(MIDL_PASS) || defined(RC_INVOKED)) && defined(ENABLE_RESTRICTED)
#define RESTRICTED_POINTER __restrict
#else
#define RESTRICTED_POINTER
#endif

#if defined(_M_MRX000) || defined(_M_ALPHA) || defined(_M_PPC) || defined(_M_IA64) || defined(_M_AMD64)
#define UNALIGNED __unaligned
#if defined(_WIN64)
#define UNALIGNED64 __unaligned
#else
#define UNALIGNED64
#endif
#else
#define UNALIGNED
#define UNALIGNED64
#endif


#if defined(_WIN64) || defined(_M_ALPHA)
#define MAX_NATURAL_ALIGNMENT sizeof(ULONGLONG)
#define MEMORY_ALLOCATION_ALIGNMENT 16
#else
#define MAX_NATURAL_ALIGNMENT sizeof(ULONG)
#define MEMORY_ALLOCATION_ALIGNMENT 8
#endif

//
// TYPE_ALIGNMENT will return the alignment requirements of a given type for
// the current platform.
//

#ifdef __cplusplus
#if _MSC_VER >= 1300
#define TYPE_ALIGNMENT( t ) __alignof(t)
#endif
#else
#define TYPE_ALIGNMENT( t ) \
    FIELD_OFFSET( struct { char x; t test; }, test )
#endif

#if defined(_WIN64)

#define PROBE_ALIGNMENT( _s ) (TYPE_ALIGNMENT( _s ) > TYPE_ALIGNMENT( ULONG ) ? \
                               TYPE_ALIGNMENT( _s ) : TYPE_ALIGNMENT( ULONG ))

#define PROBE_ALIGNMENT32( _s ) TYPE_ALIGNMENT( ULONG )

#else

#define PROBE_ALIGNMENT( _s ) TYPE_ALIGNMENT( ULONG )

#endif

//
// C_ASSERT() can be used to perform many compile-time assertions:
//            type sizes, field offsets, etc.
//
// An assertion failure results in error C2118: negative subscript.
//

#define C_ASSERT(e) typedef char __C_ASSERT__[(e)?1:-1]

#if !defined(_MAC) && (defined(_M_MRX000) || defined(_M_AMD64) || defined(_M_IA64)) && (_MSC_VER >= 1100) && !(defined(MIDL_PASS) || defined(RC_INVOKED))
#define POINTER_64 __ptr64
typedef unsigned __int64 POINTER_64_INT;
#if defined(_WIN64)
#define POINTER_32 __ptr32
#else
#define POINTER_32
#endif
#else
#if defined(_MAC) && defined(_MAC_INT_64)
#define POINTER_64 __ptr64
typedef unsigned __int64 POINTER_64_INT;
#else
#define POINTER_64
typedef unsigned long POINTER_64_INT;
#endif
#define POINTER_32
#endif

#if defined(_IA64_) || defined(_AMD64_)
#define FIRMWARE_PTR
#else
#define FIRMWARE_PTR POINTER_32
#endif

#include <basetsd.h>

// end_winnt

#ifndef CONST
#define CONST               const
#endif

// begin_winnt

#if (defined(_M_IX86) || defined(_M_IA64) || defined(_M_AMD64)) && !defined(MIDL_PASS)
#define DECLSPEC_IMPORT __declspec(dllimport)
#else
#define DECLSPEC_IMPORT
#endif

#ifndef DECLSPEC_NORETURN
#if (_MSC_VER >= 1200) && !defined(MIDL_PASS)
#define DECLSPEC_NORETURN   __declspec(noreturn)
#else
#define DECLSPEC_NORETURN
#endif
#endif

#ifndef DECLSPEC_ALIGN
#if (_MSC_VER >= 1300) && !defined(MIDL_PASS)
#define DECLSPEC_ALIGN(x)   __declspec(align(x))
#else
#define DECLSPEC_ALIGN(x)
#endif
#endif

#ifndef DECLSPEC_CACHEALIGN
#define DECLSPEC_CACHEALIGN DECLSPEC_ALIGN(128)
#endif

#ifndef DECLSPEC_UUID
#if (_MSC_VER >= 1100) && defined (__cplusplus)
#define DECLSPEC_UUID(x)    __declspec(uuid(x))
#else
#define DECLSPEC_UUID(x)
#endif
#endif

#ifndef DECLSPEC_NOVTABLE
#if (_MSC_VER >= 1100) && defined(__cplusplus)
#define DECLSPEC_NOVTABLE   __declspec(novtable)
#else
#define DECLSPEC_NOVTABLE
#endif
#endif

#ifndef DECLSPEC_SELECTANY
#if (_MSC_VER >= 1100)
#define DECLSPEC_SELECTANY  __declspec(selectany)
#else
#define DECLSPEC_SELECTANY
#endif
#endif

#ifndef NOP_FUNCTION
#if (_MSC_VER >= 1210)
#define NOP_FUNCTION __noop
#else
#define NOP_FUNCTION (void)0
#endif
#endif

#ifndef DECLSPEC_ADDRSAFE
#if (_MSC_VER >= 1200) && (defined(_M_ALPHA) || defined(_M_AXP64))
#define DECLSPEC_ADDRSAFE  __declspec(address_safe)
#else
#define DECLSPEC_ADDRSAFE
#endif
#endif

#ifndef FORCEINLINE
#if (_MSC_VER >= 1200)
#define FORCEINLINE __forceinline
#else
#define FORCEINLINE __inline
#endif
#endif

#ifndef DECLSPEC_DEPRECATED
#if (_MSC_VER >= 1300) && !defined(MIDL_PASS)
#define DECLSPEC_DEPRECATED   __declspec(deprecated)
#define DEPRECATE_SUPPORTED
#else
#define DECLSPEC_DEPRECATED
#undef  DEPRECATE_SUPPORTED
#endif
#endif

// end_winnt

#ifdef DEPRECATE_DDK_FUNCTIONS
#ifdef _NTDDK_
#define DECLSPEC_DEPRECATED_DDK DECLSPEC_DEPRECATED
#ifdef DEPRECATE_SUPPORTED
#define PRAGMA_DEPRECATED_DDK 1
#endif
#else
#define DECLSPEC_DEPRECATED_DDK
#define PRAGMA_DEPRECATED_DDK 1
#endif
#else
#define DECLSPEC_DEPRECATED_DDK
#define PRAGMA_DEPRECATED_DDK 0
#endif

//
// Void
//
// begin_winnt

typedef void *PVOID;
typedef void * POINTER_64 PVOID64;

// end_winnt

#if defined(_M_IX86)
#define FASTCALL _fastcall
#else
#define FASTCALL
#endif


#if ((_MSC_VER >= 800) || defined(_STDCALL_SUPPORTED)) && !defined(_M_AMD64)
#define NTAPI __stdcall
#else
#define _cdecl
#define NTAPI
#endif

//
// Define API decoration for direct importing system DLL references.
//

#if !defined(_NTSYSTEM_)
#define NTSYSAPI     DECLSPEC_IMPORT
#define NTSYSCALLAPI DECLSPEC_IMPORT
#else
#define NTSYSAPI
#if defined(_NTDLLBUILD_)
#define NTSYSCALLAPI
#else
#define NTSYSCALLAPI DECLSPEC_ADDRSAFE
#endif

#endif


//
// Basics
//

#ifndef VOID
#define VOID void
typedef char CHAR;
typedef short SHORT;
typedef long LONG;
#endif

//
// UNICODE (Wide Character) types
//

#ifndef _MAC
typedef wchar_t WCHAR;    // wc,   16-bit UNICODE character
#else
// some Macintosh compilers don't define wchar_t in a convenient location, or define it as a char
typedef unsigned short WCHAR;    // wc,   16-bit UNICODE character
#endif

typedef WCHAR *PWCHAR;
typedef WCHAR *LPWCH, *PWCH;
typedef CONST WCHAR *LPCWCH, *PCWCH;
typedef WCHAR *NWPSTR;
typedef WCHAR *LPWSTR, *PWSTR;
typedef WCHAR UNALIGNED *LPUWSTR, *PUWSTR;

typedef CONST WCHAR *LPCWSTR, *PCWSTR;
typedef CONST WCHAR UNALIGNED *LPCUWSTR, *PCUWSTR;

//
// ANSI (Multi-byte Character) types
//
typedef CHAR *PCHAR;
typedef CHAR *LPCH, *PCH;

typedef CONST CHAR *LPCCH, *PCCH;
typedef CHAR *NPSTR;
typedef CHAR *LPSTR, *PSTR;
typedef CONST CHAR *LPCSTR, *PCSTR;

//
// Neutral ANSI/UNICODE types and macros
//
#ifdef  UNICODE                     // r_winnt

#ifndef _TCHAR_DEFINED
typedef WCHAR TCHAR, *PTCHAR;
typedef WCHAR TUCHAR, *PTUCHAR;
#define _TCHAR_DEFINED
#endif /* !_TCHAR_DEFINED */

typedef LPWSTR LPTCH, PTCH;
typedef LPWSTR PTSTR, LPTSTR;
typedef LPCWSTR PCTSTR, LPCTSTR;
typedef LPUWSTR PUTSTR, LPUTSTR;
typedef LPCUWSTR PCUTSTR, LPCUTSTR;
typedef LPWSTR LP;
#define __TEXT(quote) L##quote      // r_winnt

#else   /* UNICODE */               // r_winnt

#ifndef _TCHAR_DEFINED
typedef char TCHAR, *PTCHAR;
typedef unsigned char TUCHAR, *PTUCHAR;
#define _TCHAR_DEFINED
#endif /* !_TCHAR_DEFINED */

typedef LPSTR LPTCH, PTCH;
typedef LPSTR PTSTR, LPTSTR, PUTSTR, LPUTSTR;
typedef LPCSTR PCTSTR, LPCTSTR, PCUTSTR, LPCUTSTR;
#define __TEXT(quote) quote         // r_winnt

#endif /* UNICODE */                // r_winnt
#define TEXT(quote) __TEXT(quote)   // r_winnt


// end_winnt

typedef double DOUBLE;

typedef struct _QUAD {              // QUAD is for those times we want
    double  DoNotUseThisField;      // an 8 byte aligned 8 byte long structure
} QUAD;                             // which is NOT really a floating point
                                    // number.  Use DOUBLE if you want an FP
                                    // number.

//
// Pointer to Basics
//

typedef SHORT *PSHORT;  // winnt
typedef LONG *PLONG;    // winnt
typedef QUAD *PQUAD;

//
// Unsigned Basics
//

// Tell windef.h that some types are already defined.
#define BASETYPES

typedef unsigned char UCHAR;
typedef unsigned short USHORT;
typedef unsigned long ULONG;
typedef QUAD UQUAD;

//
// Pointer to Unsigned Basics
//

typedef UCHAR *PUCHAR;
typedef USHORT *PUSHORT;
typedef ULONG *PULONG;
typedef UQUAD *PUQUAD;

//
// Signed characters
//

typedef signed char SCHAR;
typedef SCHAR *PSCHAR;

#ifndef NO_STRICT
#ifndef STRICT
#define STRICT 1
#endif
#endif

//
// Handle to an Object
//

// begin_winnt

#ifdef STRICT
typedef void *HANDLE;
#define DECLARE_HANDLE(name) struct name##__ { int unused; }; typedef struct name##__ *name
#else
typedef PVOID HANDLE;
#define DECLARE_HANDLE(name) typedef HANDLE name
#endif
typedef HANDLE *PHANDLE;

//
// Flag (bit) fields
//

typedef UCHAR  FCHAR;
typedef USHORT FSHORT;
typedef ULONG  FLONG;

// Component Object Model defines, and macros

#ifndef _HRESULT_DEFINED
#define _HRESULT_DEFINED
typedef LONG HRESULT;

#endif // !_HRESULT_DEFINED

#ifdef __cplusplus
    #define EXTERN_C    extern "C"
#else
    #define EXTERN_C    extern
#endif

#if defined(_WIN32) || defined(_MPPC_)

// Win32 doesn't support __export

#ifdef _68K_
#define STDMETHODCALLTYPE       __cdecl
#else
#define STDMETHODCALLTYPE       __stdcall
#endif
#define STDMETHODVCALLTYPE      __cdecl

#define STDAPICALLTYPE          __stdcall
#define STDAPIVCALLTYPE         __cdecl

#else

#define STDMETHODCALLTYPE       __export __stdcall
#define STDMETHODVCALLTYPE      __export __cdecl

#define STDAPICALLTYPE          __export __stdcall
#define STDAPIVCALLTYPE         __export __cdecl

#endif


#define STDAPI                  EXTERN_C HRESULT STDAPICALLTYPE
#define STDAPI_(type)           EXTERN_C type STDAPICALLTYPE

#define STDMETHODIMP            HRESULT STDMETHODCALLTYPE
#define STDMETHODIMP_(type)     type STDMETHODCALLTYPE

// The 'V' versions allow Variable Argument lists.

#define STDAPIV                 EXTERN_C HRESULT STDAPIVCALLTYPE
#define STDAPIV_(type)          EXTERN_C type STDAPIVCALLTYPE

#define STDMETHODIMPV           HRESULT STDMETHODVCALLTYPE
#define STDMETHODIMPV_(type)    type STDMETHODVCALLTYPE

// end_winnt


//
// Low order two bits of a handle are ignored by the system and available
// for use by application code as tag bits.  The remaining bits are opaque
// and used to store a serial number and table index.
//

#define OBJ_HANDLE_TAGBITS  0x00000003L

//
// Cardinal Data Types [0 - 2**N-2)
//

typedef char CCHAR;          // winnt
typedef short CSHORT;
typedef ULONG CLONG;

typedef CCHAR *PCCHAR;
typedef CSHORT *PCSHORT;
typedef CLONG *PCLONG;

//
// NTSTATUS
//

typedef LONG NTSTATUS;
/*lint -save -e624 */  // Don't complain about different typedefs.
typedef NTSTATUS *PNTSTATUS;
/*lint -restore */  // Resume checking for different typedefs.

//
//  Status values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-------------------------+-------------------------------+
//  |Sev|C|       Facility          |               Code            |
//  +---+-+-------------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//

//
// Generic test for success on any status value (non-negative numbers
// indicate success).
//

#define NT_SUCCESS(Status) ((NTSTATUS)(Status) >= 0)

//
// Generic test for information on any status value.
//

#define NT_INFORMATION(Status) ((ULONG)(Status) >> 30 == 1)

//
// Generic test for warning on any status value.
//

#define NT_WARNING(Status) ((ULONG)(Status) >> 30 == 2)

//
// Generic test for error on any status value.
//

#define NT_ERROR(Status) ((ULONG)(Status) >> 30 == 3)

// end_windbgkd
// begin_winnt
#define APPLICATION_ERROR_MASK       0x20000000
#define ERROR_SEVERITY_SUCCESS       0x00000000
#define ERROR_SEVERITY_INFORMATIONAL 0x40000000
#define ERROR_SEVERITY_WARNING       0x80000000
#define ERROR_SEVERITY_ERROR         0xC0000000
// end_winnt

#ifndef __SECSTATUS_DEFINED__
typedef long SECURITY_STATUS;
#define __SECSTATUS_DEFINED__
#endif



//
// __int64 is only supported by 2.0 and later midl.
// __midl is set by the 2.0 midl and not by 1.0 midl.
//

#define _ULONGLONG_
#if (!defined (_MAC) && (!defined(MIDL_PASS) || defined(__midl)) && (!defined(_M_IX86) || (defined(_INTEGRAL_MAX_BITS) && _INTEGRAL_MAX_BITS >= 64)))
typedef __int64 LONGLONG;
typedef unsigned __int64 ULONGLONG;

#define MAXLONGLONG                      (0x7fffffffffffffff)
#else

#if defined(_MAC) && defined(_MAC_INT_64)
typedef __int64 LONGLONG;
typedef unsigned __int64 ULONGLONG;

#define MAXLONGLONG                      (0x7fffffffffffffff)
#else
typedef double LONGLONG;
typedef double ULONGLONG;
#endif //_MAC and int64

#endif

typedef LONGLONG *PLONGLONG;
typedef ULONGLONG *PULONGLONG;

// Update Sequence Number

typedef LONGLONG USN;

#if defined(MIDL_PASS)
typedef struct _LARGE_INTEGER {
#else // MIDL_PASS
typedef union _LARGE_INTEGER {
    struct {
        ULONG LowPart;
        LONG HighPart;
    };
    struct {
        ULONG LowPart;
        LONG HighPart;
    } u;
#endif //MIDL_PASS
    LONGLONG QuadPart;
} LARGE_INTEGER;

typedef LARGE_INTEGER *PLARGE_INTEGER;

#if defined(MIDL_PASS)
typedef struct _ULARGE_INTEGER {
#else // MIDL_PASS
typedef union _ULARGE_INTEGER {
    struct {
        ULONG LowPart;
        ULONG HighPart;
    };
    struct {
        ULONG LowPart;
        ULONG HighPart;
    } u;
#endif //MIDL_PASS
    ULONGLONG QuadPart;
} ULARGE_INTEGER;

typedef ULARGE_INTEGER *PULARGE_INTEGER;


//
// Physical address.
//

typedef LARGE_INTEGER PHYSICAL_ADDRESS, *PPHYSICAL_ADDRESS;

//
// Counted String
//

typedef USHORT RTL_STRING_LENGTH_TYPE;

typedef struct _STRING {
    USHORT Length;
    USHORT MaximumLength;
#ifdef MIDL_PASS
    [size_is(MaximumLength), length_is(Length) ]
#endif // MIDL_PASS
    PCHAR Buffer;
} STRING;
typedef STRING *PSTRING;

typedef STRING ANSI_STRING;
typedef PSTRING PANSI_STRING;

typedef STRING OEM_STRING;
typedef PSTRING POEM_STRING;
typedef CONST STRING* PCOEM_STRING;

//
// CONSTCounted String
//

typedef struct _CSTRING {
    USHORT Length;
    USHORT MaximumLength;
    CONST char *Buffer;
} CSTRING;
typedef CSTRING *PCSTRING;
#define ANSI_NULL ((CHAR)0)     // winnt

typedef STRING CANSI_STRING;
typedef PSTRING PCANSI_STRING;

//
// Unicode strings are counted 16-bit character strings. If they are
// NULL terminated, Length does not include trailing NULL.
//

typedef struct _UNICODE_STRING {
    USHORT Length;
    USHORT MaximumLength;
#ifdef MIDL_PASS
    [size_is(MaximumLength / 2), length_is((Length) / 2) ] USHORT * Buffer;
#else // MIDL_PASS
    PWSTR  Buffer;
#endif // MIDL_PASS
} UNICODE_STRING;
typedef UNICODE_STRING *PUNICODE_STRING;
typedef const UNICODE_STRING *PCUNICODE_STRING;
#define UNICODE_NULL ((WCHAR)0) // winnt

#if _WIN32_WINNT >= 0x0501

#define UNICODE_STRING_MAX_BYTES ((USHORT) 65534) // winnt
#define UNICODE_STRING_MAX_CHARS (32767) // winnt

#define DECLARE_CONST_UNICODE_STRING(_variablename, _string) \
const WCHAR _variablename ## _buffer[] = _string; \
const UNICODE_STRING _variablename = { sizeof(_string) - sizeof(WCHAR), sizeof(_string), (PWSTR) _variablename ## _buffer };

#endif // _WIN32_WINNT >= 0x0501

// begin_ntminiport begin_ntminitape

//
// Boolean
//

typedef UCHAR BOOLEAN;           // winnt
typedef BOOLEAN *PBOOLEAN;       // winnt

// end_ntminiport end_ntminitape

// begin_winnt
//
//  Doubly linked list structure.  Can be used as either a list head, or
//  as link words.
//

typedef struct _LIST_ENTRY {
   struct _LIST_ENTRY *Flink;
   struct _LIST_ENTRY *Blink;
} LIST_ENTRY, *PLIST_ENTRY, *RESTRICTED_POINTER PRLIST_ENTRY;

//
//  Singly linked list structure. Can be used as either a list head, or
//  as link words.
//

typedef struct _SINGLE_LIST_ENTRY {
    struct _SINGLE_LIST_ENTRY *Next;
} SINGLE_LIST_ENTRY, *PSINGLE_LIST_ENTRY;

//
// Constants
//

#define FALSE   0
#define TRUE    1

#ifndef NULL
#ifdef __cplusplus
#define NULL    0
#define NULL64  0
#else
#define NULL    ((void *)0)
#define NULL64  ((void * POINTER_64)0)
#endif
#endif // NULL


#include <guiddef.h>

#ifndef __OBJECTID_DEFINED
#define __OBJECTID_DEFINED

typedef struct  _OBJECTID {     // size is 20
    GUID Lineage;
    ULONG Uniquifier;
} OBJECTID;
#endif // !_OBJECTID_DEFINED

//
// Determine if an argument is present by testing the value of the pointer
// to the argument value.
//

#define ARGUMENT_PRESENT(ArgumentPointer)    (\
    (CHAR *)(ArgumentPointer) != (CHAR *)(NULL) )

// begin_winnt begin_ntminiport
//
// Calculate the byte offset of a field in a structure of type type.
//

#define FIELD_OFFSET(type, field)    ((LONG)(LONG_PTR)&(((type *)0)->field))

#if(_WIN32_WINNT > 0x0500)

//
// Calculate the size of a field in a structure of type type, without
// knowing or stating the type of the field.
//
#define RTL_FIELD_SIZE(type, field) (sizeof(((type *)0)->field))

//
// Calculate the size of a structure of type type up through and
// including a field.
//
#define RTL_SIZEOF_THROUGH_FIELD(type, field) \
    (FIELD_OFFSET(type, field) + RTL_FIELD_SIZE(type, field))

//
//  RTL_CONTAINS_FIELD usage:
//
//      if (RTL_CONTAINS_FIELD(pBlock, pBlock->cbSize, dwMumble)) { // safe to use pBlock->dwMumble
//
#define RTL_CONTAINS_FIELD(Struct, Size, Field) \
    ( (((PCHAR)(&(Struct)->Field)) + sizeof((Struct)->Field)) <= (((PCHAR)(Struct))+(Size)) )

//
// Return the number of elements in a statically sized array.
//   ULONG Buffer[100];
//   RTL_NUMBER_OF(Buffer) == 100
// This is also popularly known as: NUMBER_OF, ARRSIZE, _countof, NELEM, etc.
//
#define RTL_NUMBER_OF(A) (sizeof(A)/sizeof((A)[0]))

//
// An expression that yields the type of a field in a struct.
//
#define RTL_FIELD_TYPE(type, field) (((type*)0)->field)

// RTL_ to avoid collisions in the global namespace.
//
// Given typedef struct _FOO { BYTE Bar[123]; } FOO;
// RTL_NUMBER_OF_FIELD(FOO, Bar) == 123
//
#define RTL_NUMBER_OF_FIELD(type, field) (RTL_NUMBER_OF(RTL_FIELD_TYPE(type, field)))

//
// eg:
// typedef struct FOO {
//   ULONG Integer;
//   PVOID Pointer;
// } FOO;
//
// RTL_PADDING_BETWEEN_FIELDS(FOO, Integer, Pointer) == 0 for Win32, 4 for Win64
//
#define RTL_PADDING_BETWEEN_FIELDS(T, F1, F2) \
    ((FIELD_OFFSET(T, F2) > FIELD_OFFSET(T, F1)) \
        ? (FIELD_OFFSET(T, F2) - FIELD_OFFSET(T, F1) - RTL_FIELD_SIZE(T, F1)) \
        : (FIELD_OFFSET(T, F1) - FIELD_OFFSET(T, F2) - RTL_FIELD_SIZE(T, F2)))

// RTL_ to avoid collisions in the global namespace.
#if defined(__cplusplus)
#define RTL_CONST_CAST(type) const_cast<type>
#else
#define RTL_CONST_CAST(type) (type)
#endif

// end_winnt
//
// This works "generically" for Unicode and Ansi/Oem strings.
// Usage:
//   const static UNICODE_STRING FooU = RTL_CONSTANT_STRING(L"Foo");
//   const static         STRING Foo  = RTL_CONSTANT_STRING( "Foo");
// instead of the slower:
//   UNICODE_STRING FooU;
//           STRING Foo;
//   RtlInitUnicodeString(&FooU, L"Foo");
//          RtlInitString(&Foo ,  "Foo");
//
#define RTL_CONSTANT_STRING(s) { sizeof( s ) - sizeof( (s)[0] ), sizeof( s ), s }
// begin_winnt

// like sizeof
// usually this would be * CHAR_BIT, but we don't necessarily have #include <limits.h>
#define RTL_BITS_OF(sizeOfArg) (sizeof(sizeOfArg) * 8)

#define RTL_BITS_OF_FIELD(type, field) (RTL_BITS_OF(RTL_FIELD_TYPE(type, field)))

#endif /* _WIN32_WINNT > 0x0500 */

//
// Calculate the address of the base of the structure given its type, and an
// address of a field within the structure.
//

#define CONTAINING_RECORD(address, type, field) ((type *)( \
                                                  (PCHAR)(address) - \
                                                  (ULONG_PTR)(&((type *)0)->field)))


//
// Interrupt Request Level (IRQL)
//

typedef UCHAR KIRQL;

typedef KIRQL *PKIRQL;


//
// Macros used to eliminate compiler warning generated when formal
// parameters or local variables are not declared.
//
// Use DBG_UNREFERENCED_PARAMETER() when a parameter is not yet
// referenced but will be once the module is completely developed.
//
// Use DBG_UNREFERENCED_LOCAL_VARIABLE() when a local variable is not yet
// referenced but will be once the module is completely developed.
//
// Use UNREFERENCED_PARAMETER() if a parameter will never be referenced.
//
// DBG_UNREFERENCED_PARAMETER and DBG_UNREFERENCED_LOCAL_VARIABLE will
// eventually be made into a null macro to help determine whether there
// is unfinished work.
//

#if ! defined(lint)
#define UNREFERENCED_PARAMETER(P)          (P)
#define DBG_UNREFERENCED_PARAMETER(P)      (P)
#define DBG_UNREFERENCED_LOCAL_VARIABLE(V) (V)

#else // lint

// Note: lint -e530 says don't complain about uninitialized variables for
// this varible.  Error 527 has to do with unreachable code.
// -restore restores checking to the -save state

#define UNREFERENCED_PARAMETER(P)          \
    /*lint -save -e527 -e530 */ \
    { \
        (P) = (P); \
    } \
    /*lint -restore */
#define DBG_UNREFERENCED_PARAMETER(P)      \
    /*lint -save -e527 -e530 */ \
    { \
        (P) = (P); \
    } \
    /*lint -restore */
#define DBG_UNREFERENCED_LOCAL_VARIABLE(V) \
    /*lint -save -e527 -e530 */ \
    { \
        (V) = (V); \
    } \
    /*lint -restore */

#endif // lint

//
// Macro used to eliminate compiler warning 4715 within a switch statement
// when all possible cases have already been accounted for.
//
// switch (a & 3) {
//     case 0: return 1;
//     case 1: return Foo();
//     case 2: return Bar();
//     case 3: return 1;
//     DEFAULT_UNREACHABLE;
//

#if (_MSC_VER > 1200)
#define DEFAULT_UNREACHABLE default: __assume(0)
#else

//
// Older compilers do not support __assume(), and there is no other free
// method of eliminating the warning.
//

#define DEFAULT_UNREACHABLE

#endif

// end_winnt

//
//  Define standard min and max macros
//

#ifndef NOMINMAX

#ifndef min
#define min(a,b) (((a) < (b)) ? (a) : (b))
#endif

#ifndef max
#define max(a,b) (((a) > (b)) ? (a) : (b))
#endif

#endif  // NOMINMAX

//
// Processor modes.
//

typedef CCHAR KPROCESSOR_MODE;

typedef enum _MODE {
    KernelMode,
    UserMode,
    MaximumMode
} MODE;

//
// DPC routine
//

struct _KDPC;

typedef
VOID
(*PKDEFERRED_ROUTINE) (
    IN struct _KDPC *Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

//
// Define DPC importance.
//
// LowImportance - Queue DPC at end of target DPC queue.
// MediumImportance - Queue DPC at end of target DPC queue.
// HighImportance - Queue DPC at front of target DPC DPC queue.
//
// If there is currently a DPC active on the target processor, or a DPC
// interrupt has already been requested on the target processor when a
// DPC is queued, then no further action is necessary. The DPC will be
// executed on the target processor when its queue entry is processed.
//
// If there is not a DPC active on the target processor and a DPC interrupt
// has not been requested on the target processor, then the exact treatment
// of the DPC is dependent on whether the host system is a UP system or an
// MP system.
//
// UP system.
//
// If the DPC is of medium or high importance, the current DPC queue depth
// is greater than the maximum target depth, or current DPC request rate is
// less the minimum target rate, then a DPC interrupt is requested on the
// host processor and the DPC will be processed when the interrupt occurs.
// Otherwise, no DPC interupt is requested and the DPC execution will be
// delayed until the DPC queue depth is greater that the target depth or the
// minimum DPC rate is less than the target rate.
//
// MP system.
//
// If the DPC is being queued to another processor and the depth of the DPC
// queue on the target processor is greater than the maximum target depth or
// the DPC is of high importance, then a DPC interrupt is requested on the
// target processor and the DPC will be processed when the interrupt occurs.
// Otherwise, the DPC execution will be delayed on the target processor until
// the DPC queue depth on the target processor is greater that the maximum
// target depth or the minimum DPC rate on the target processor is less than
// the target mimimum rate.
//
// If the DPC is being queued to the current processor and the DPC is not of
// low importance, the current DPC queue depth is greater than the maximum
// target depth, or the minimum DPC rate is less than the minimum target rate,
// then a DPC interrupt is request on the current processor and the DPV will
// be processed whne the interrupt occurs. Otherwise, no DPC interupt is
// requested and the DPC execution will be delayed until the DPC queue depth
// is greater that the target depth or the minimum DPC rate is less than the
// target rate.
//

typedef enum _KDPC_IMPORTANCE {
    LowImportance,
    MediumImportance,
    HighImportance
} KDPC_IMPORTANCE;

//
// Deferred Procedure Call (DPC) object
//

typedef struct _KDPC {
    CSHORT Type;
    UCHAR Number;
    UCHAR Importance;
    LIST_ENTRY DpcListEntry;
    PKDEFERRED_ROUTINE DeferredRoutine;
    PVOID DeferredContext;
    PVOID SystemArgument1;
    PVOID SystemArgument2;
    PULONG_PTR Lock;
} KDPC, *PKDPC, *RESTRICTED_POINTER PRKDPC;


//
// Interprocessor interrupt worker routine function prototype.
//

typedef PVOID PKIPI_CONTEXT;

typedef
VOID
(*PKIPI_WORKER)(
    IN PKIPI_CONTEXT PacketContext,
    IN PVOID Parameter1,
    IN PVOID Parameter2,
    IN PVOID Parameter3
    );

//
// Define interprocessor interrupt performance counters.
//

typedef struct _KIPI_COUNTS {
    ULONG Freeze;
    ULONG Packet;
    ULONG DPC;
    ULONG APC;
    ULONG FlushSingleTb;
    ULONG FlushMultipleTb;
    ULONG FlushEntireTb;
    ULONG GenericCall;
    ULONG ChangeColor;
    ULONG SweepDcache;
    ULONG SweepIcache;
    ULONG SweepIcacheRange;
    ULONG FlushIoBuffers;
    ULONG GratuitousDPC;
} KIPI_COUNTS, *PKIPI_COUNTS;

#if defined(NT_UP)

#define HOT_STATISTIC(a) a

#else

#define HOT_STATISTIC(a) (KeGetCurrentPrcb()->a)

#endif

//
// I/O system definitions.
//
// Define a Memory Descriptor List (MDL)
//
// An MDL describes pages in a virtual buffer in terms of physical pages.  The
// pages associated with the buffer are described in an array that is allocated
// just after the MDL header structure itself.  In a future compiler this will
// be placed at:
//
//      ULONG Pages[];
//
// Until this declaration is permitted, however, one simply calculates the
// base of the array by adding one to the base MDL pointer:
//
//      Pages = (PULONG) (Mdl + 1);
//
// Notice that while in the context of the subject thread, the base virtual
// address of a buffer mapped by an MDL may be referenced using the following:
//
//      Mdl->StartVa | Mdl->ByteOffset
//


typedef struct _MDL {
    struct _MDL *Next;
    CSHORT Size;
    CSHORT MdlFlags;
    struct _EPROCESS *Process;
    PVOID MappedSystemVa;
    PVOID StartVa;
    ULONG ByteCount;
    ULONG ByteOffset;
} MDL, *PMDL;

#define MDL_MAPPED_TO_SYSTEM_VA     0x0001
#define MDL_PAGES_LOCKED            0x0002
#define MDL_SOURCE_IS_NONPAGED_POOL 0x0004
#define MDL_ALLOCATED_FIXED_SIZE    0x0008
#define MDL_PARTIAL                 0x0010
#define MDL_PARTIAL_HAS_BEEN_MAPPED 0x0020
#define MDL_IO_PAGE_READ            0x0040
#define MDL_WRITE_OPERATION         0x0080
#define MDL_PARENT_MAPPED_SYSTEM_VA 0x0100
#define MDL_FREE_EXTRA_PTES         0x0200
#define MDL_IO_SPACE                0x0800
#define MDL_NETWORK_HEADER          0x1000
#define MDL_MAPPING_CAN_FAIL        0x2000
#define MDL_ALLOCATED_MUST_SUCCEED  0x4000


#define MDL_MAPPING_FLAGS (MDL_MAPPED_TO_SYSTEM_VA     | \
                           MDL_PAGES_LOCKED            | \
                           MDL_SOURCE_IS_NONPAGED_POOL | \
                           MDL_PARTIAL_HAS_BEEN_MAPPED | \
                           MDL_PARENT_MAPPED_SYSTEM_VA | \
                           MDL_SYSTEM_VA               | \
                           MDL_IO_SPACE )

#define NTKERNELAPI DECLSPEC_IMPORT     
#define NTHALAPI DECLSPEC_IMPORT            
//
// Common dispatcher object header
//
// N.B. The size field contains the number of dwords in the structure.
//

typedef struct _DISPATCHER_HEADER {
    UCHAR Type;
    UCHAR Absolute;
    UCHAR Size;
    UCHAR Inserted;
    LONG SignalState;
    LIST_ENTRY WaitListHead;
} DISPATCHER_HEADER;

//
// Event object
//

typedef struct _KEVENT {
    DISPATCHER_HEADER Header;
} KEVENT, *PKEVENT, *RESTRICTED_POINTER PRKEVENT;

//
// Timer object
//

typedef struct _KTIMER {
    DISPATCHER_HEADER Header;
    ULARGE_INTEGER DueTime;
    LIST_ENTRY TimerListEntry;
    struct _KDPC *Dpc;
    LONG Period;
} KTIMER, *PKTIMER, *RESTRICTED_POINTER PRKTIMER;


typedef ULONG_PTR KSPIN_LOCK;
typedef KSPIN_LOCK *PKSPIN_LOCK;

//
// Define the I/O bus interface types.
//

typedef enum _INTERFACE_TYPE {
    InterfaceTypeUndefined = -1,
    Internal,
    Isa,
    Eisa,
    MicroChannel,
    TurboChannel,
    PCIBus,
    VMEBus,
    NuBus,
    PCMCIABus,
    CBus,
    MPIBus,
    MPSABus,
    ProcessorInternal,
    InternalPowerBus,
    PNPISABus,
    PNPBus,
    MaximumInterfaceType
}INTERFACE_TYPE, *PINTERFACE_TYPE;

//
// Define the DMA transfer widths.
//

typedef enum _DMA_WIDTH {
    Width8Bits,
    Width16Bits,
    Width32Bits,
    MaximumDmaWidth
}DMA_WIDTH, *PDMA_WIDTH;

//
// Define DMA transfer speeds.
//

typedef enum _DMA_SPEED {
    Compatible,
    TypeA,
    TypeB,
    TypeC,
    TypeF,
    MaximumDmaSpeed
}DMA_SPEED, *PDMA_SPEED;

//
// Define Interface reference/dereference routines for
//  Interfaces exported by IRP_MN_QUERY_INTERFACE
//

typedef VOID (*PINTERFACE_REFERENCE)(PVOID Context);
typedef VOID (*PINTERFACE_DEREFERENCE)(PVOID Context);

// end_wdm

//
// Define types of bus information.
//

typedef enum _BUS_DATA_TYPE {
    ConfigurationSpaceUndefined = -1,
    Cmos,
    EisaConfiguration,
    Pos,
    CbusConfiguration,
    PCIConfiguration,
    VMEConfiguration,
    NuBusConfiguration,
    PCMCIAConfiguration,
    MPIConfiguration,
    MPSAConfiguration,
    PNPISAConfiguration,
    SgiInternalConfiguration,
    MaximumBusDataType
} BUS_DATA_TYPE, *PBUS_DATA_TYPE;


#ifndef _SLIST_HEADER_
#define _SLIST_HEADER_

#define SLIST_ENTRY SINGLE_LIST_ENTRY
#define _SLIST_ENTRY _SINGLE_LIST_ENTRY
#define PSLIST_ENTRY PSINGLE_LIST_ENTRY

#if defined(_WIN64)

typedef struct DECLSPEC_ALIGN(16) _SLIST_HEADER {
    ULONGLONG Alignment;
    ULONGLONG Region;
} SLIST_HEADER;

typedef struct _SLIST_HEADER *PSLIST_HEADER;

#else

typedef union _SLIST_HEADER {
    ULONGLONG Alignment;
    struct {
        SLIST_ENTRY Next;
        USHORT Depth;
        USHORT Sequence;
    };
} SLIST_HEADER, *PSLIST_HEADER;

#endif

#endif

//
// If debugging support enabled, define an ASSERT macro that works.  Otherwise
// define the ASSERT macro to expand to an empty expression.
//
// The ASSERT macro has been updated to be an expression instead of a statement.
//

#if DBG
NTSYSAPI
VOID
NTAPI
RtlAssert(
    PVOID FailedAssertion,
    PVOID FileName,
    ULONG LineNumber,
    PCHAR Message
    );

#define ASSERT( exp ) \
    ((!(exp)) ? \
        (RtlAssert( #exp, __FILE__, __LINE__, NULL ),FALSE) : \
        TRUE)

#define ASSERTMSG( msg, exp ) \
    ((!(exp)) ? \
        (RtlAssert( #exp, __FILE__, __LINE__, msg ),FALSE) : \
        TRUE)

#define RTL_SOFT_ASSERT(_exp) \
    ((!(_exp)) ? \
        (DbgPrint("%s(%d): Soft assertion failed\n   Expression: %s\n", __FILE__, __LINE__, #_exp),FALSE) : \
        TRUE)

#define RTL_SOFT_ASSERTMSG(_msg, _exp) \
    ((!(_exp)) ? \
        (DbgPrint("%s(%d): Soft assertion failed\n   Expression: %s\n   Message: %s\n", __FILE__, __LINE__, #_exp, (_msg)),FALSE) : \
        TRUE)

#define RTL_VERIFY( exp )         ASSERT(exp)
#define RTL_VERIFYMSG( msg, exp ) ASSERT(msg, exp)

#define RTL_SOFT_VERIFY(_exp)          RTL_SOFT_ASSERT(_exp)
#define RTL_SOFT_VERIFYMSG(_msg, _exp) RTL_SOFT_ASSERTMSG(_msg, _exp)

#else
#define ASSERT( exp )         ((void) 0)
#define ASSERTMSG( msg, exp ) ((void) 0)

#define RTL_SOFT_ASSERT(_exp)          ((void) 0)
#define RTL_SOFT_ASSERTMSG(_msg, _exp) ((void) 0)

#define RTL_VERIFY( exp )         ((exp) ? TRUE : FALSE)
#define RTL_VERIFYMSG( msg, exp ) ((exp) ? TRUE : FALSE)

#define RTL_SOFT_VERIFY(_exp)         ((_exp) ? TRUE : FALSE)
#define RTL_SOFT_VERIFYMSG(msg, _exp) ((_exp) ? TRUE : FALSE)

#endif // DBG

//
//  Doubly-linked list manipulation routines.
//


//
//  VOID
//  InitializeListHead32(
//      PLIST_ENTRY32 ListHead
//      );
//

#define InitializeListHead32(ListHead) (\
    (ListHead)->Flink = (ListHead)->Blink = PtrToUlong((ListHead)))

#if !defined(MIDL_PASS) && !defined(SORTPP_PASS)


VOID
FORCEINLINE
InitializeListHead(
    IN PLIST_ENTRY ListHead
    )
{
    ListHead->Flink = ListHead->Blink = ListHead;
}

//
//  BOOLEAN
//  IsListEmpty(
//      PLIST_ENTRY ListHead
//      );
//

#define IsListEmpty(ListHead) \
    ((ListHead)->Flink == (ListHead))



VOID
FORCEINLINE
RemoveEntryList(
    IN PLIST_ENTRY Entry
    )
{
    PLIST_ENTRY Blink;
    PLIST_ENTRY Flink;

    Flink = Entry->Flink;
    Blink = Entry->Blink;
    Blink->Flink = Flink;
    Flink->Blink = Blink;
}

PLIST_ENTRY
FORCEINLINE
RemoveHeadList(
    IN PLIST_ENTRY ListHead
    )
{
    PLIST_ENTRY Flink;
    PLIST_ENTRY Entry;

    Entry = ListHead->Flink;
    Flink = Entry->Flink;
    ListHead->Flink = Flink;
    Flink->Blink = ListHead;
    return Entry;
}



PLIST_ENTRY
FORCEINLINE
RemoveTailList(
    IN PLIST_ENTRY ListHead
    )
{
    PLIST_ENTRY Blink;
    PLIST_ENTRY Entry;

    Entry = ListHead->Blink;
    Blink = Entry->Blink;
    ListHead->Blink = Blink;
    Blink->Flink = ListHead;
    return Entry;
}


VOID
FORCEINLINE
InsertTailList(
    IN PLIST_ENTRY ListHead,
    IN PLIST_ENTRY Entry
    )
{
    PLIST_ENTRY Blink;

    Blink = ListHead->Blink;
    Entry->Flink = ListHead;
    Entry->Blink = Blink;
    Blink->Flink = Entry;
    ListHead->Blink = Entry;
}


VOID
FORCEINLINE
InsertHeadList(
    IN PLIST_ENTRY ListHead,
    IN PLIST_ENTRY Entry
    )
{
    PLIST_ENTRY Flink;

    Flink = ListHead->Flink;
    Entry->Flink = Flink;
    Entry->Blink = ListHead;
    Flink->Blink = Entry;
    ListHead->Flink = Entry;
}


//
//
//  PSINGLE_LIST_ENTRY
//  PopEntryList(
//      PSINGLE_LIST_ENTRY ListHead
//      );
//

#define PopEntryList(ListHead) \
    (ListHead)->Next;\
    {\
        PSINGLE_LIST_ENTRY FirstEntry;\
        FirstEntry = (ListHead)->Next;\
        if (FirstEntry != NULL) {     \
            (ListHead)->Next = FirstEntry->Next;\
        }                             \
    }


//
//  VOID
//  PushEntryList(
//      PSINGLE_LIST_ENTRY ListHead,
//      PSINGLE_LIST_ENTRY Entry
//      );
//

#define PushEntryList(ListHead,Entry) \
    (Entry)->Next = (ListHead)->Next; \
    (ListHead)->Next = (Entry)

#endif // !MIDL_PASS


#if defined (_MSC_VER) && ( _MSC_VER >= 900 )

PVOID
_ReturnAddress (
    VOID
    );

#pragma intrinsic(_ReturnAddress)

#endif

#if (defined(_M_AMD64) || defined(_M_IA64)) && !defined(_REALLY_GET_CALLERS_CALLER_)

#define RtlGetCallersAddress(CallersAddress, CallersCaller) \
    *CallersAddress = (PVOID)_ReturnAddress(); \
    *CallersCaller = NULL;

#else

NTSYSAPI
VOID
NTAPI
RtlGetCallersAddress(
    OUT PVOID *CallersAddress,
    OUT PVOID *CallersCaller
    );

#endif

NTSYSAPI
ULONG
NTAPI
RtlWalkFrameChain (
    OUT PVOID *Callers,
    IN ULONG Count,
    IN ULONG Flags
    );


NTSYSAPI
NTSTATUS
NTAPI
RtlUnicodeStringToAnsiString(
    PANSI_STRING DestinationString,
    PCUNICODE_STRING SourceString,
    BOOLEAN AllocateDestinationString
    );


NTSYSAPI
LONG
NTAPI
RtlCompareUnicodeString(
    PCUNICODE_STRING String1,
    PCUNICODE_STRING String2,
    BOOLEAN CaseInSensitive
    );

NTSYSAPI
BOOLEAN
NTAPI
RtlEqualUnicodeString(
    const UNICODE_STRING *String1,
    const UNICODE_STRING *String2,
    BOOLEAN CaseInSensitive
    );

#define HASH_STRING_ALGORITHM_DEFAULT   (0)
#define HASH_STRING_ALGORITHM_X65599    (1)
#define HASH_STRING_ALGORITHM_INVALID   (0xffffffff)

NTSYSAPI
NTSTATUS
NTAPI
RtlHashUnicodeString(
    IN const UNICODE_STRING *String,
    IN BOOLEAN CaseInSensitive,
    IN ULONG HashAlgorithm,
    OUT PULONG HashValue
    );


NTSYSAPI
BOOLEAN
NTAPI
RtlPrefixUnicodeString(
    IN PUNICODE_STRING String1,
    IN PUNICODE_STRING String2,
    IN BOOLEAN CaseInSensitive
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlUpcaseUnicodeString(
    PUNICODE_STRING DestinationString,
    PCUNICODE_STRING SourceString,
    BOOLEAN AllocateDestinationString
    );


NTSYSAPI
VOID
NTAPI
RtlCopyUnicodeString(
    PUNICODE_STRING DestinationString,
    PCUNICODE_STRING SourceString
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlAppendUnicodeStringToString (
    PUNICODE_STRING Destination,
    PCUNICODE_STRING Source
    );

NTSYSAPI
NTSTATUS
NTAPI
RtlAppendUnicodeToString (
    PUNICODE_STRING Destination,
    PCWSTR Source
    );


NTSYSAPI
SIZE_T
NTAPI
RtlCompareMemory (
    const VOID *Source1,
    const VOID *Source2,
    SIZE_T Length
    );

#if defined(_M_AMD64) || defined(_M_IA64)

#define RtlEqualMemory(Source1, Source2, Length) \
    ((Length) == RtlCompareMemory(Source1, Source2, Length))

NTSYSAPI
VOID
NTAPI
RtlCopyMemory (
   VOID UNALIGNED *Destination,
   CONST VOID UNALIGNED *Source,
   SIZE_T Length
   );

#if !defined(_M_AMD64)

NTSYSAPI
VOID
NTAPI
RtlCopyMemory32 (
   VOID UNALIGNED *Destination,
   CONST VOID UNALIGNED *Source,
   ULONG Length
   );

#endif

NTSYSAPI
VOID
NTAPI
RtlMoveMemory (
   VOID UNALIGNED *Destination,
   CONST VOID UNALIGNED *Source,
   SIZE_T Length
   );

NTSYSAPI
VOID
NTAPI
RtlFillMemory (
   VOID UNALIGNED *Destination,
   SIZE_T Length,
   UCHAR Fill
   );

NTSYSAPI
VOID
NTAPI
RtlZeroMemory (
   VOID UNALIGNED *Destination,
   SIZE_T Length
   );

#else

#define RtlEqualMemory(Destination,Source,Length) (!memcmp((Destination),(Source),(Length)))
#define RtlMoveMemory(Destination,Source,Length) memmove((Destination),(Source),(Length))
#define RtlCopyMemory(Destination,Source,Length) memcpy((Destination),(Source),(Length))
#define RtlFillMemory(Destination,Length,Fill) memset((Destination),(Fill),(Length))
#define RtlZeroMemory(Destination,Length) memset((Destination),0,(Length))

#endif

#if !defined(MIDL_PASS)
FORCEINLINE
PVOID
RtlSecureZeroMemory(
    IN PVOID ptr, 
    IN SIZE_T cnt
    ) 
{
    volatile char *vptr = (volatile char *)ptr;
    while (cnt) {
        *vptr = 0;
        vptr++;
        cnt--;
    }
    return ptr;
}
#endif

//
// Define kernel debugger print prototypes and macros.
//
// N.B. The following function cannot be directly imported because there are
//      a few places in the source tree where this function is redefined.
//

VOID
NTAPI
DbgBreakPoint(
    VOID
    );

// end_wdm

NTSYSAPI
VOID
NTAPI
DbgBreakPointWithStatus(
    IN ULONG Status
    );

// begin_wdm

#define DBG_STATUS_CONTROL_C        1
#define DBG_STATUS_SYSRQ            2
#define DBG_STATUS_BUGCHECK_FIRST   3
#define DBG_STATUS_BUGCHECK_SECOND  4
#define DBG_STATUS_FATAL            5
#define DBG_STATUS_DEBUG_CONTROL    6
#define DBG_STATUS_WORKER           7

#if DBG

#define KdPrint(_x_) DbgPrint _x_
// end_wdm
#define KdPrintEx(_x_) DbgPrintEx _x_
#define vKdPrintEx(_x_) vDbgPrintEx _x_
#define vKdPrintExWithPrefix(_x_) vDbgPrintExWithPrefix _x_
// begin_wdm
#define KdBreakPoint() DbgBreakPoint()

// end_wdm

#define KdBreakPointWithStatus(s) DbgBreakPointWithStatus(s)

// begin_wdm

#else

#define KdPrint(_x_)
// end_wdm
#define KdPrintEx(_x_)
#define vKdPrintEx(_x_)
#define vKdPrintExWithPrefix(_x_)
// begin_wdm
#define KdBreakPoint()

// end_wdm

#define KdBreakPointWithStatus(s)

// begin_wdm

#endif

#ifndef _DBGNT_

ULONG
__cdecl
DbgPrint(
    PCH Format,
    ...
    );

// end_wdm

ULONG
__cdecl
DbgPrintEx(
    IN ULONG ComponentId,
    IN ULONG Level,
    IN PCH Format,
    ...
    );

#ifdef _VA_LIST_DEFINED

ULONG
vDbgPrintEx(
    IN ULONG ComponentId,
    IN ULONG Level,
    IN PCH Format,
    va_list arglist
    );

ULONG
vDbgPrintExWithPrefix(
    IN PCH Prefix,
    IN ULONG ComponentId,
    IN ULONG Level,
    IN PCH Format,
    va_list arglist
    );

#endif

ULONG
__cdecl
DbgPrintReturnControlC(
    PCH Format,
    ...
    );

NTSYSAPI
NTSTATUS
DbgQueryDebugFilterState(
    IN ULONG ComponentId,
    IN ULONG Level
    );

NTSYSAPI
NTSTATUS
DbgSetDebugFilterState(
    IN ULONG ComponentId,
    IN ULONG Level,
    IN BOOLEAN State
    );

// begin_wdm

#endif // _DBGNT_

//
// Component name filter id enumeration and levels.
//

#define DPFLTR_ERROR_LEVEL 0
#define DPFLTR_WARNING_LEVEL 1
#define DPFLTR_TRACE_LEVEL 2
#define DPFLTR_INFO_LEVEL 3
#define DPFLTR_MASK 0x80000000

typedef enum _DPFLTR_TYPE {
    DPFLTR_SYSTEM_ID = 0,
    DPFLTR_SMSS_ID = 1,
    DPFLTR_SETUP_ID = 2,
    DPFLTR_NTFS_ID = 3,
    DPFLTR_FSTUB_ID = 4,
    DPFLTR_CRASHDUMP_ID = 5,
    DPFLTR_CDAUDIO_ID = 6,
    DPFLTR_CDROM_ID = 7,
    DPFLTR_CLASSPNP_ID = 8,
    DPFLTR_DISK_ID = 9,
    DPFLTR_REDBOOK_ID = 10,
    DPFLTR_STORPROP_ID = 11,
    DPFLTR_SCSIPORT_ID = 12,
    DPFLTR_SCSIMINIPORT_ID = 13,
    DPFLTR_CONFIG_ID = 14,
    DPFLTR_I8042PRT_ID = 15,
    DPFLTR_SERMOUSE_ID = 16,
    DPFLTR_LSERMOUS_ID = 17,
    DPFLTR_KBDHID_ID = 18,
    DPFLTR_MOUHID_ID = 19,
    DPFLTR_KBDCLASS_ID = 20,
    DPFLTR_MOUCLASS_ID = 21,
    DPFLTR_TWOTRACK_ID = 22,
    DPFLTR_WMILIB_ID = 23,
    DPFLTR_ACPI_ID = 24,
    DPFLTR_AMLI_ID = 25,
    DPFLTR_HALIA64_ID = 26,
    DPFLTR_VIDEO_ID = 27,
    DPFLTR_SVCHOST_ID = 28,
    DPFLTR_VIDEOPRT_ID = 29,
    DPFLTR_TCPIP_ID = 30,
    DPFLTR_DMSYNTH_ID = 31,
    DPFLTR_NTOSPNP_ID = 32,
    DPFLTR_FASTFAT_ID = 33,
    DPFLTR_SAMSS_ID = 34,
    DPFLTR_PNPMGR_ID = 35,
    DPFLTR_NETAPI_ID = 36,
    DPFLTR_SCSERVER_ID = 37,
    DPFLTR_SCCLIENT_ID = 38,
    DPFLTR_SERIAL_ID = 39,
    DPFLTR_SERENUM_ID = 40,
    DPFLTR_UHCD_ID = 41,
    DPFLTR_BOOTOK_ID = 42,
    DPFLTR_BOOTVRFY_ID = 43,
    DPFLTR_RPCPROXY_ID = 44,
    DPFLTR_AUTOCHK_ID = 45,
    DPFLTR_DCOMSS_ID = 46,
    DPFLTR_UNIMODEM_ID = 47,
    DPFLTR_SIS_ID = 48,
    DPFLTR_FLTMGR_ID = 49,
    DPFLTR_WMICORE_ID = 50,
    DPFLTR_BURNENG_ID = 51,
    DPFLTR_IMAPI_ID = 52,
    DPFLTR_SXS_ID = 53,
    DPFLTR_FUSION_ID = 54,
    DPFLTR_IDLETASK_ID = 55,
    DPFLTR_SOFTPCI_ID = 56,
    DPFLTR_TAPE_ID = 57,
    DPFLTR_MCHGR_ID = 58,
    DPFLTR_IDEP_ID = 59,
    DPFLTR_PCIIDE_ID = 60,
    DPFLTR_FLOPPY_ID = 61,
    DPFLTR_FDC_ID = 62,
    DPFLTR_TERMSRV_ID = 63,
    DPFLTR_W32TIME_ID = 64,
    DPFLTR_PREFETCHER_ID = 65,
    DPFLTR_RSFILTER_ID = 66,
    DPFLTR_FCPORT_ID = 67,
    DPFLTR_PCI_ID = 68,
    DPFLTR_DMIO_ID = 69,
    DPFLTR_DMCONFIG_ID = 70,
    DPFLTR_DMADMIN_ID = 71,
    DPFLTR_WSOCKTRANSPORT_ID = 72,
    DPFLTR_VSS_ID = 73,
    DPFLTR_PNPMEM_ID = 74,
    DPFLTR_PROCESSOR_ID = 75,
    DPFLTR_DMSERVER_ID = 76,
    DPFLTR_SR_ID = 77,
    DPFLTR_INFINIBAND_ID = 78,
    DPFLTR_IHVDRIVER_ID = 79,
    DPFLTR_IHVVIDEO_ID = 80,
    DPFLTR_IHVAUDIO_ID = 81,
    DPFLTR_IHVNETWORK_ID = 82,
    DPFLTR_IHVSTREAMING_ID = 83,
    DPFLTR_IHVBUS_ID = 84,
    DPFLTR_HPS_ID = 85,
    DPFLTR_RTLTHREADPOOL_ID = 86,
    DPFLTR_LDR_ID = 87,
    DPFLTR_TCPIP6_ID = 88,
    DPFLTR_ISAPNP_ID = 89,
    DPFLTR_SHPC_ID = 90,
    DPFLTR_STORPORT_ID = 91,
    DPFLTR_STORMINIPORT_ID = 92,
    DPFLTR_PRINTSPOOLER_ID = 93,
    DPFLTR_ENDOFTABLE_ID
} DPFLTR_TYPE;

//
// Define I/O Driver error log packet structure.  This structure is filled in
// by the driver.
//

typedef struct _IO_ERROR_LOG_PACKET {
    UCHAR MajorFunctionCode;
    UCHAR RetryCount;
    USHORT DumpDataSize;
    USHORT NumberOfStrings;
    USHORT StringOffset;
    USHORT EventCategory;
    NTSTATUS ErrorCode;
    ULONG UniqueErrorValue;
    NTSTATUS FinalStatus;
    ULONG SequenceNumber;
    ULONG IoControlCode;
    LARGE_INTEGER DeviceOffset;
    ULONG DumpData[1];
}IO_ERROR_LOG_PACKET, *PIO_ERROR_LOG_PACKET;

//
// Define the I/O error log message.  This message is sent by the error log
// thread over the lpc port.
//

typedef struct _IO_ERROR_LOG_MESSAGE {
    USHORT Type;
    USHORT Size;
    USHORT DriverNameLength;
    LARGE_INTEGER TimeStamp;
    ULONG DriverNameOffset;
    IO_ERROR_LOG_PACKET EntryData;
}IO_ERROR_LOG_MESSAGE, *PIO_ERROR_LOG_MESSAGE;

//
// Define the maximum message size that will be sent over the LPC to the
// application reading the error log entries.
//

//
// Regardless of LPC size restrictions, ERROR_LOG_MAXIMUM_SIZE must remain
// a value that can fit in a UCHAR.
//

#define ERROR_LOG_LIMIT_SIZE (256-16)

//
// This limit, exclusive of IO_ERROR_LOG_MESSAGE_HEADER_LENGTH, also applies
// to IO_ERROR_LOG_MESSAGE_LENGTH
//

#define IO_ERROR_LOG_MESSAGE_HEADER_LENGTH (sizeof(IO_ERROR_LOG_MESSAGE) -    \
                                            sizeof(IO_ERROR_LOG_PACKET) +     \
                                            (sizeof(WCHAR) * 40))

#define ERROR_LOG_MESSAGE_LIMIT_SIZE                                          \
    (ERROR_LOG_LIMIT_SIZE + IO_ERROR_LOG_MESSAGE_HEADER_LENGTH)

//
// IO_ERROR_LOG_MESSAGE_LENGTH is
// min(PORT_MAXIMUM_MESSAGE_LENGTH, ERROR_LOG_MESSAGE_LIMIT_SIZE)
//

#define IO_ERROR_LOG_MESSAGE_LENGTH                                           \
    ((PORT_MAXIMUM_MESSAGE_LENGTH > ERROR_LOG_MESSAGE_LIMIT_SIZE) ?           \
        ERROR_LOG_MESSAGE_LIMIT_SIZE :                                        \
        PORT_MAXIMUM_MESSAGE_LENGTH)

//
// Define the maximum packet size a driver can allocate.
//

#define ERROR_LOG_MAXIMUM_SIZE (IO_ERROR_LOG_MESSAGE_LENGTH -                 \
                                IO_ERROR_LOG_MESSAGE_HEADER_LENGTH)


#if defined(_X86_)

//
// Types to use to contain PFNs and their counts.
//

typedef ULONG PFN_COUNT;

typedef LONG SPFN_NUMBER, *PSPFN_NUMBER;
typedef ULONG PFN_NUMBER, *PPFN_NUMBER;

//
// Define maximum size of flush multiple TB request.
//

#define FLUSH_MULTIPLE_MAXIMUM 16

//
// Indicate that the i386 compiler supports the pragma textout construct.
//

#define ALLOC_PRAGMA 1
//
// Indicate that the i386 compiler supports the DATA_SEG("INIT") and
// DATA_SEG("PAGE") pragmas
//

#define ALLOC_DATA_PRAGMA 1


//
// I/O space read and write macros.
//
//  These have to be actual functions on the 386, because we need
//  to use assembler, but cannot return a value if we inline it.
//
//  The READ/WRITE_REGISTER_* calls manipulate I/O registers in MEMORY space.
//  (Use x86 move instructions, with LOCK prefix to force correct behavior
//   w.r.t. caches and write buffers.)
//
//  The READ/WRITE_PORT_* calls manipulate I/O registers in PORT space.
//  (Use x86 in/out instructions.)
//

NTKERNELAPI
UCHAR
NTAPI
READ_REGISTER_UCHAR(
    PUCHAR  Register
    );

NTKERNELAPI
USHORT
NTAPI
READ_REGISTER_USHORT(
    PUSHORT Register
    );

NTKERNELAPI
ULONG
NTAPI
READ_REGISTER_ULONG(
    PULONG  Register
    );

NTKERNELAPI
VOID
NTAPI
READ_REGISTER_BUFFER_UCHAR(
    PUCHAR  Register,
    PUCHAR  Buffer,
    ULONG   Count
    );

NTKERNELAPI
VOID
NTAPI
READ_REGISTER_BUFFER_USHORT(
    PUSHORT Register,
    PUSHORT Buffer,
    ULONG   Count
    );

NTKERNELAPI
VOID
NTAPI
READ_REGISTER_BUFFER_ULONG(
    PULONG  Register,
    PULONG  Buffer,
    ULONG   Count
    );


NTKERNELAPI
VOID
NTAPI
WRITE_REGISTER_UCHAR(
    PUCHAR  Register,
    UCHAR   Value
    );

NTKERNELAPI
VOID
NTAPI
WRITE_REGISTER_USHORT(
    PUSHORT Register,
    USHORT  Value
    );

NTKERNELAPI
VOID
NTAPI
WRITE_REGISTER_ULONG(
    PULONG  Register,
    ULONG   Value
    );

NTKERNELAPI
VOID
NTAPI
WRITE_REGISTER_BUFFER_UCHAR(
    PUCHAR  Register,
    PUCHAR  Buffer,
    ULONG   Count
    );

NTKERNELAPI
VOID
NTAPI
WRITE_REGISTER_BUFFER_USHORT(
    PUSHORT Register,
    PUSHORT Buffer,
    ULONG   Count
    );

NTKERNELAPI
VOID
NTAPI
WRITE_REGISTER_BUFFER_ULONG(
    PULONG  Register,
    PULONG  Buffer,
    ULONG   Count
    );

NTHALAPI
UCHAR
NTAPI
READ_PORT_UCHAR(
    PUCHAR  Port
    );

NTHALAPI
USHORT
NTAPI
READ_PORT_USHORT(
    PUSHORT Port
    );

NTHALAPI
ULONG
NTAPI
READ_PORT_ULONG(
    PULONG  Port
    );

NTHALAPI
VOID
NTAPI
READ_PORT_BUFFER_UCHAR(
    PUCHAR  Port,
    PUCHAR  Buffer,
    ULONG   Count
    );

NTHALAPI
VOID
NTAPI
READ_PORT_BUFFER_USHORT(
    PUSHORT Port,
    PUSHORT Buffer,
    ULONG   Count
    );

NTHALAPI
VOID
NTAPI
READ_PORT_BUFFER_ULONG(
    PULONG  Port,
    PULONG  Buffer,
    ULONG   Count
    );

NTHALAPI
VOID
NTAPI
WRITE_PORT_UCHAR(
    PUCHAR  Port,
    UCHAR   Value
    );

NTHALAPI
VOID
NTAPI
WRITE_PORT_USHORT(
    PUSHORT Port,
    USHORT  Value
    );

NTHALAPI
VOID
NTAPI
WRITE_PORT_ULONG(
    PULONG  Port,
    ULONG   Value
    );

NTHALAPI
VOID
NTAPI
WRITE_PORT_BUFFER_UCHAR(
    PUCHAR  Port,
    PUCHAR  Buffer,
    ULONG   Count
    );

NTHALAPI
VOID
NTAPI
WRITE_PORT_BUFFER_USHORT(
    PUSHORT Port,
    PUSHORT Buffer,
    ULONG   Count
    );

NTHALAPI
VOID
NTAPI
WRITE_PORT_BUFFER_ULONG(
    PULONG  Port,
    PULONG  Buffer,
    ULONG   Count
    );


#define KeFlushIoBuffers(Mdl, ReadOperation, DmaOperation)

//
// i386 Specific portions of mm component
//

//
// Define the page size for the Intel 386 as 4096 (0x1000).
//

#define PAGE_SIZE 0x1000

//
// Define the number of trailing zeroes in a page aligned virtual address.
// This is used as the shift count when shifting virtual addresses to
// virtual page numbers.
//

#define PAGE_SHIFT 12L


#endif // defined(_X86_)


#if defined(_M_AMD64) && !defined(RC_INVOKED) && !defined(MIDL_PASS)

//
// Define intrinsic function to do in's and out's.
//

#ifdef __cplusplus
extern "C" {
#endif

UCHAR
__inbyte (
    IN USHORT Port
    );

USHORT
__inword (
    IN USHORT Port
    );

ULONG
__indword (
    IN USHORT Port
    );

VOID
__outbyte (
    IN USHORT Port,
    IN UCHAR Data
    );

VOID
__outword (
    IN USHORT Port,
    IN USHORT Data
    );

VOID
__outdword (
    IN USHORT Port,
    IN ULONG Data
    );

VOID
__inbytestring (
    IN USHORT Port,
    IN PUCHAR Buffer,
    IN ULONG Count
    );

VOID
__inwordstring (
    IN USHORT Port,
    IN PUSHORT Buffer,
    IN ULONG Count
    );

VOID
__indwordstring (
    IN USHORT Port,
    IN PULONG Buffer,
    IN ULONG Count
    );

VOID
__outbytestring (
    IN USHORT Port,
    IN PUCHAR Buffer,
    IN ULONG Count
    );

VOID
__outwordstring (
    IN USHORT Port,
    IN PUSHORT Buffer,
    IN ULONG Count
    );

VOID
__outdwordstring (
    IN USHORT Port,
    IN PULONG Buffer,
    IN ULONG Count
    );

#ifdef __cplusplus
}
#endif

#pragma intrinsic(__inbyte)
#pragma intrinsic(__inword)
#pragma intrinsic(__indword)
#pragma intrinsic(__outbyte)
#pragma intrinsic(__outword)
#pragma intrinsic(__outdword)
#pragma intrinsic(__inbytestring)
#pragma intrinsic(__inwordstring)
#pragma intrinsic(__indwordstring)
#pragma intrinsic(__outbytestring)
#pragma intrinsic(__outwordstring)
#pragma intrinsic(__outdwordstring)

//
// Interlocked intrinsic functions.
//

#define InterlockedAnd _InterlockedAnd
#define InterlockedOr _InterlockedOr
#define InterlockedXor _InterlockedXor
#define InterlockedIncrement _InterlockedIncrement
#define InterlockedDecrement _InterlockedDecrement
#define InterlockedAdd _InterlockedAdd
#define InterlockedExchange _InterlockedExchange
#define InterlockedExchangeAdd _InterlockedExchangeAdd
#define InterlockedCompareExchange _InterlockedCompareExchange

#define InterlockedAnd64 _InterlockedAnd64
#define InterlockedOr64 _InterlockedOr64
#define InterlockedXor64 _InterlockedXor64
#define InterlockedIncrement64 _InterlockedIncrement64
#define InterlockedDecrement64 _InterlockedDecrement64
#define InterlockedAdd64 _InterlockedAdd64
#define InterlockedExchange64 _InterlockedExchange64
#define InterlockedExchangeAdd64 _InterlockedExchangeAdd64
#define InterlockedCompareExchange64 _InterlockedCompareExchange64

#define InterlockedExchangePointer _InterlockedExchangePointer
#define InterlockedCompareExchangePointer _InterlockedCompareExchangePointer

#ifdef __cplusplus
extern "C" {
#endif

LONG
InterlockedAnd (
    IN OUT LONG volatile *Destination,
    IN LONG Value
    );

LONG
InterlockedOr (
    IN OUT LONG volatile *Destination,
    IN LONG Value
    );

LONG
InterlockedXor (
    IN OUT LONG volatile *Destination,
    IN LONG Value
    );

LONG64
InterlockedAnd64 (
    IN OUT LONG64 volatile *Destination,
    IN LONG64 Value
    );

LONG64
InterlockedOr64 (
    IN OUT LONG64 volatile *Destination,
    IN LONG64 Value
    );

LONG64
InterlockedXor64 (
    IN OUT LONG64 volatile *Destination,
    IN LONG64 Value
    );

LONG
InterlockedIncrement(
    IN OUT LONG volatile *Addend
    );

LONG
InterlockedDecrement(
    IN OUT LONG volatile *Addend
    );

LONG
InterlockedExchange(
    IN OUT LONG volatile *Target,
    IN LONG Value
    );

LONG
InterlockedExchangeAdd(
    IN OUT LONG volatile *Addend,
    IN LONG Value
    );

#if !defined(_X86AMD64_)

__forceinline
LONG
InterlockedAdd(
    IN OUT LONG volatile *Addend,
    IN LONG Value
    )

{
    return InterlockedExchangeAdd(Addend, Value) + Value;
}

#endif

LONG
InterlockedCompareExchange (
    IN OUT LONG volatile *Destination,
    IN LONG ExChange,
    IN LONG Comperand
    );

LONG64
InterlockedIncrement64(
    IN OUT LONG64 volatile *Addend
    );

LONG64
InterlockedDecrement64(
    IN OUT LONG64 volatile *Addend
    );

LONG64
InterlockedExchange64(
    IN OUT LONG64 volatile *Target,
    IN LONG64 Value
    );

LONG64
InterlockedExchangeAdd64(
    IN OUT LONG64 volatile *Addend,
    IN LONG64 Value
    );

#if !defined(_X86AMD64_)

__forceinline
LONG64
InterlockedAdd64(
    IN OUT LONG64 volatile *Addend,
    IN LONG64 Value
    )

{
    return InterlockedExchangeAdd64(Addend, Value) + Value;
}

#endif

LONG64
InterlockedCompareExchange64 (
    IN OUT LONG64 volatile *Destination,
    IN LONG64 ExChange,
    IN LONG64 Comperand
    );

PVOID
InterlockedCompareExchangePointer (
    IN OUT PVOID volatile *Destination,
    IN PVOID Exchange,
    IN PVOID Comperand
    );

PVOID
InterlockedExchangePointer(
    IN OUT PVOID volatile *Target,
    IN PVOID Value
    );

#pragma intrinsic(_InterlockedAnd)
#pragma intrinsic(_InterlockedOr)
#pragma intrinsic(_InterlockedXor)
#pragma intrinsic(_InterlockedIncrement)
#pragma intrinsic(_InterlockedDecrement)
#pragma intrinsic(_InterlockedExchange)
#pragma intrinsic(_InterlockedExchangeAdd)
#pragma intrinsic(_InterlockedCompareExchange)
#pragma intrinsic(_InterlockedAnd64)
#pragma intrinsic(_InterlockedOr64)
#pragma intrinsic(_InterlockedXor64)
#pragma intrinsic(_InterlockedIncrement64)
#pragma intrinsic(_InterlockedDecrement64)
#pragma intrinsic(_InterlockedExchange64)
#pragma intrinsic(_InterlockedExchangeAdd64)
#pragma intrinsic(_InterlockedCompareExchange64)
#pragma intrinsic(_InterlockedExchangePointer)
#pragma intrinsic(_InterlockedCompareExchangePointer)

#ifdef __cplusplus
}
#endif

#endif // defined(_M_AMD64) && !defined(RC_INVOKED) && !defined(MIDL_PASS)

#if defined(_AMD64_)

//
// Types to use to contain PFNs and their counts.
//

typedef ULONG PFN_COUNT;

typedef LONG64 SPFN_NUMBER, *PSPFN_NUMBER;
typedef ULONG64 PFN_NUMBER, *PPFN_NUMBER;

//
// Define maximum size of flush multiple TB request.
//

#define FLUSH_MULTIPLE_MAXIMUM 16

//
// Indicate that the AMD64 compiler supports the allocate pragmas.
//

#define ALLOC_PRAGMA 1
#define ALLOC_DATA_PRAGMA 1


//
// I/O space read and write macros.
//
//  The READ/WRITE_REGISTER_* calls manipulate I/O registers in MEMORY space.
//  (Use move instructions, with LOCK prefix to force correct behavior
//   w.r.t. caches and write buffers.)
//
//  The READ/WRITE_PORT_* calls manipulate I/O registers in PORT space.
//  (Use in/out instructions.)
//

__forceinline
UCHAR
READ_REGISTER_UCHAR (
    volatile UCHAR *Register
    )
{
    return *Register;
}

__forceinline
USHORT
READ_REGISTER_USHORT (
    volatile USHORT *Register
    )
{
    return *Register;
}

__forceinline
ULONG
READ_REGISTER_ULONG (
    volatile ULONG *Register
    )
{
    return *Register;
}

__forceinline
VOID
READ_REGISTER_BUFFER_UCHAR (
    PUCHAR Register,
    PUCHAR Buffer,
    ULONG Count
    )
{
    __movsb(Register, Buffer, Count);
    return;
}

__forceinline
VOID
READ_REGISTER_BUFFER_USHORT (
    PUSHORT Register,
    PUSHORT Buffer,
    ULONG Count
    )
{
    __movsw(Register, Buffer, Count);
    return;
}

__forceinline
VOID
READ_REGISTER_BUFFER_ULONG (
    PULONG Register,
    PULONG Buffer,
    ULONG Count
    )
{
    __movsd(Register, Buffer, Count);
    return;
}

__forceinline
VOID
WRITE_REGISTER_UCHAR (
    PUCHAR Register,
    UCHAR Value
    )
{
    LONG Synch;

    *Register = Value;
    InterlockedOr(&Synch, 1);
    return;
}

__forceinline
VOID
WRITE_REGISTER_USHORT (
    PUSHORT Register,
    USHORT Value
    )
{
    LONG Synch;

    *Register = Value;
    InterlockedOr(&Synch, 1);
    return;
}

__forceinline
VOID
WRITE_REGISTER_ULONG (
    PULONG Register,
    ULONG Value
    )
{
    LONG Synch;

    *Register = Value;
    InterlockedOr(&Synch, 1);
    return;
}

__forceinline
VOID
WRITE_REGISTER_BUFFER_UCHAR (
    PUCHAR Register,
    PUCHAR Buffer,
    ULONG Count
    )
{
    LONG Synch;

    __movsb(Register, Buffer, Count);
    InterlockedOr(&Synch, 1);
    return;
}

__forceinline
VOID
WRITE_REGISTER_BUFFER_USHORT (
    PUSHORT Register,
    PUSHORT Buffer,
    ULONG Count
    )
{
    LONG Synch;

    __movsw(Register, Buffer, Count);
    InterlockedOr(&Synch, 1);
    return;
}

__forceinline
VOID
WRITE_REGISTER_BUFFER_ULONG (
    PULONG Register,
    PULONG Buffer,
    ULONG Count
    )
{
    LONG Synch;

    __movsd(Register, Buffer, Count);
    InterlockedOr(&Synch, 1);
    return;
}

__forceinline
UCHAR
READ_PORT_UCHAR (
    PUCHAR Port
    )

{
    return __inbyte((USHORT)((ULONG64)Port));
}

__forceinline
USHORT
READ_PORT_USHORT (
    PUSHORT Port
    )

{
    return __inword((USHORT)((ULONG64)Port));
}

__forceinline
ULONG
READ_PORT_ULONG (
    PULONG Port
    )

{
    return __indword((USHORT)((ULONG64)Port));
}


__forceinline
VOID
READ_PORT_BUFFER_UCHAR (
    PUCHAR Port,
    PUCHAR Buffer,
    ULONG Count
    )

{
    __inbytestring((USHORT)((ULONG64)Port), Buffer, Count);
    return;
}

__forceinline
VOID
READ_PORT_BUFFER_USHORT (
    PUSHORT Port,
    PUSHORT Buffer,
    ULONG Count
    )

{
    __inwordstring((USHORT)((ULONG64)Port), Buffer, Count);
    return;
}

__forceinline
VOID
READ_PORT_BUFFER_ULONG (
    PULONG Port,
    PULONG Buffer,
    ULONG Count
    )

{
    __indwordstring((USHORT)((ULONG64)Port), Buffer, Count);
    return;
}

__forceinline
VOID
WRITE_PORT_UCHAR (
    PUCHAR Port,
    UCHAR Value
    )

{
    __outbyte((USHORT)((ULONG64)Port), Value);
    return;
}

__forceinline
VOID
WRITE_PORT_USHORT (
    PUSHORT Port,
    USHORT Value
    )

{
    __outword((USHORT)((ULONG64)Port), Value);
    return;
}

__forceinline
VOID
WRITE_PORT_ULONG (
    PULONG Port,
    ULONG Value
    )

{
    __outdword((USHORT)((ULONG64)Port), Value);
    return;
}

__forceinline
VOID
WRITE_PORT_BUFFER_UCHAR (
    PUCHAR Port,
    PUCHAR Buffer,
    ULONG Count
    )

{
    __outbytestring((USHORT)((ULONG64)Port), Buffer, Count);
    return;
}

__forceinline
VOID
WRITE_PORT_BUFFER_USHORT (
    PUSHORT Port,
    PUSHORT Buffer,
    ULONG Count
    )

{
    __outwordstring((USHORT)((ULONG64)Port), Buffer, Count);
    return;
}

__forceinline
VOID
WRITE_PORT_BUFFER_ULONG (
    PULONG Port,
    PULONG Buffer,
    ULONG Count
    )

{
    __outdwordstring((USHORT)((ULONG64)Port), Buffer, Count);
    return;
}


#define KeFlushIoBuffers(Mdl, ReadOperation, DmaOperation)

//
// AMD64 Specific portions of mm component.
//
// Define the page size for the AMD64 as 4096 (0x1000).
//

#define PAGE_SIZE 0x1000

//
// Define the number of trailing zeroes in a page aligned virtual address.
// This is used as the shift count when shifting virtual addresses to
// virtual page numbers.
//

#define PAGE_SHIFT 12L


#endif // defined(_AMD64_)


#if defined(_IA64_)

//
// Types to use to contain PFNs and their counts.
//

typedef ULONG PFN_COUNT;

typedef LONG_PTR SPFN_NUMBER, *PSPFN_NUMBER;
typedef ULONG_PTR PFN_NUMBER, *PPFN_NUMBER;

//
// Define maximum size of flush multiple TB request.
//

#define FLUSH_MULTIPLE_MAXIMUM 100

//
// Indicate that the IA64 compiler supports the pragma textout construct.
//

#define ALLOC_PRAGMA 1

//
// Define intrinsic calls and their prototypes
//

#include "ia64reg.h"


#ifdef __cplusplus
extern "C" {
#endif

unsigned __int64 __getReg (int);
void __setReg (int, unsigned __int64);
void __isrlz (void);
void __dsrlz (void);
void __fwb (void);
void __mf (void);
void __mfa (void);
void __synci (void);
__int64 __thash (__int64);
__int64 __ttag (__int64);
void __ptcl (__int64, __int64);
void __ptcg (__int64, __int64);
void __ptcga (__int64, __int64);
void __ptri (__int64, __int64);
void __ptrd (__int64, __int64);
void __invalat (void);
void __break (int);
void __fc (__int64);
void __sum (int);
void __rsm (int);
void _ReleaseSpinLock( unsigned __int64 *);

#ifdef _M_IA64
#pragma intrinsic (__getReg)
#pragma intrinsic (__setReg)
#pragma intrinsic (__isrlz)
#pragma intrinsic (__dsrlz)
#pragma intrinsic (__fwb)
#pragma intrinsic (__mf)
#pragma intrinsic (__mfa)
#pragma intrinsic (__synci)
#pragma intrinsic (__thash)
#pragma intrinsic (__ttag)
#pragma intrinsic (__ptcl)
#pragma intrinsic (__ptcg)
#pragma intrinsic (__ptcga)
#pragma intrinsic (__ptri)
#pragma intrinsic (__ptrd)
#pragma intrinsic (__invalat)
#pragma intrinsic (__break)
#pragma intrinsic (__fc)
#pragma intrinsic (__sum)
#pragma intrinsic (__rsm)
#pragma intrinsic (_ReleaseSpinLock)

#endif // _M_IA64

#ifdef __cplusplus
}
#endif



//
// Define the page size
//

#define PAGE_SIZE 0x2000

//
// Define the number of trailing zeroes in a page aligned virtual address.
// This is used as the shift count when shifting virtual addresses to
// virtual page numbers.
//

#define PAGE_SHIFT 13L

//
// Cache and write buffer flush functions.
//

NTKERNELAPI
VOID
KeFlushIoBuffers (
    IN PMDL Mdl,
    IN BOOLEAN ReadOperation,
    IN BOOLEAN DmaOperation
    );

//
// I/O space read and write macros.
//

NTHALAPI
UCHAR
READ_PORT_UCHAR (
    PUCHAR RegisterAddress
    );

NTHALAPI
USHORT
READ_PORT_USHORT (
    PUSHORT RegisterAddress
    );

NTHALAPI
ULONG
READ_PORT_ULONG (
    PULONG RegisterAddress
    );

NTHALAPI
VOID
READ_PORT_BUFFER_UCHAR (
    PUCHAR portAddress,
    PUCHAR readBuffer,
    ULONG  readCount
    );

NTHALAPI
VOID
READ_PORT_BUFFER_USHORT (
    PUSHORT portAddress,
    PUSHORT readBuffer,
    ULONG  readCount
    );

NTHALAPI
VOID
READ_PORT_BUFFER_ULONG (
    PULONG portAddress,
    PULONG readBuffer,
    ULONG  readCount
    );

NTHALAPI
VOID
WRITE_PORT_UCHAR (
    PUCHAR portAddress,
    UCHAR  Data
    );

NTHALAPI
VOID
WRITE_PORT_USHORT (
    PUSHORT portAddress,
    USHORT  Data
    );

NTHALAPI
VOID
WRITE_PORT_ULONG (
    PULONG portAddress,
    ULONG  Data
    );

NTHALAPI
VOID
WRITE_PORT_BUFFER_UCHAR (
    PUCHAR portAddress,
    PUCHAR writeBuffer,
    ULONG  writeCount
    );

NTHALAPI
VOID
WRITE_PORT_BUFFER_USHORT (
    PUSHORT portAddress,
    PUSHORT writeBuffer,
    ULONG  writeCount
    );

NTHALAPI
VOID
WRITE_PORT_BUFFER_ULONG (
    PULONG portAddress,
    PULONG writeBuffer,
    ULONG  writeCount
    );


#define READ_REGISTER_UCHAR(x) \
    (__mf(), *(volatile UCHAR * const)(x))

#define READ_REGISTER_USHORT(x) \
    (__mf(), *(volatile USHORT * const)(x))

#define READ_REGISTER_ULONG(x) \
    (__mf(), *(volatile ULONG * const)(x))

#define READ_REGISTER_BUFFER_UCHAR(x, y, z) {                           \
    PUCHAR registerBuffer = x;                                          \
    PUCHAR readBuffer = y;                                              \
    ULONG readCount;                                                    \
    __mf();                                                             \
    for (readCount = z; readCount--; readBuffer++, registerBuffer++) {  \
        *readBuffer = *(volatile UCHAR * const)(registerBuffer);        \
    }                                                                   \
}

#define READ_REGISTER_BUFFER_USHORT(x, y, z) {                          \
    PUSHORT registerBuffer = x;                                         \
    PUSHORT readBuffer = y;                                             \
    ULONG readCount;                                                    \
    __mf();                                                             \
    for (readCount = z; readCount--; readBuffer++, registerBuffer++) {  \
        *readBuffer = *(volatile USHORT * const)(registerBuffer);       \
    }                                                                   \
}

#define READ_REGISTER_BUFFER_ULONG(x, y, z) {                           \
    PULONG registerBuffer = x;                                          \
    PULONG readBuffer = y;                                              \
    ULONG readCount;                                                    \
    __mf();                                                             \
    for (readCount = z; readCount--; readBuffer++, registerBuffer++) {  \
        *readBuffer = *(volatile ULONG * const)(registerBuffer);        \
    }                                                                   \
}

#define WRITE_REGISTER_UCHAR(x, y) {    \
    *(volatile UCHAR * const)(x) = y;   \
    KeFlushWriteBuffer();               \
}

#define WRITE_REGISTER_USHORT(x, y) {   \
    *(volatile USHORT * const)(x) = y;  \
    KeFlushWriteBuffer();               \
}

#define WRITE_REGISTER_ULONG(x, y) {    \
    *(volatile ULONG * const)(x) = y;   \
    KeFlushWriteBuffer();               \
}

#define WRITE_REGISTER_BUFFER_UCHAR(x, y, z) {                            \
    PUCHAR registerBuffer = x;                                            \
    PUCHAR writeBuffer = y;                                               \
    ULONG writeCount;                                                     \
    for (writeCount = z; writeCount--; writeBuffer++, registerBuffer++) { \
        *(volatile UCHAR * const)(registerBuffer) = *writeBuffer;         \
    }                                                                     \
    KeFlushWriteBuffer();                                                 \
}

#define WRITE_REGISTER_BUFFER_USHORT(x, y, z) {                           \
    PUSHORT registerBuffer = x;                                           \
    PUSHORT writeBuffer = y;                                              \
    ULONG writeCount;                                                     \
    for (writeCount = z; writeCount--; writeBuffer++, registerBuffer++) { \
        *(volatile USHORT * const)(registerBuffer) = *writeBuffer;        \
    }                                                                     \
    KeFlushWriteBuffer();                                                 \
}

#define WRITE_REGISTER_BUFFER_ULONG(x, y, z) {                            \
    PULONG registerBuffer = x;                                            \
    PULONG writeBuffer = y;                                               \
    ULONG writeCount;                                                     \
    for (writeCount = z; writeCount--; writeBuffer++, registerBuffer++) { \
        *(volatile ULONG * const)(registerBuffer) = *writeBuffer;         \
    }                                                                     \
    KeFlushWriteBuffer();                                                 \
}


//
// OS_MCA, OS_INIT HandOff State definitions
//
// Note: The following definitions *must* match the definiions of the
//       corresponding SAL Revision Hand-Off structures.
//

typedef struct _SAL_HANDOFF_STATE   {
    ULONGLONG     PalProcEntryPoint;
    ULONGLONG     SalProcEntryPoint;
    ULONGLONG     SalGlobalPointer;
     LONGLONG     RendezVousResult;
    ULONGLONG     SalReturnAddress;
    ULONGLONG     MinStateSavePtr;
} SAL_HANDOFF_STATE, *PSAL_HANDOFF_STATE;

typedef struct _OS_HANDOFF_STATE    {
    ULONGLONG     Result;
    ULONGLONG     SalGlobalPointer;
    ULONGLONG     MinStateSavePtr;
    ULONGLONG     SalReturnAddress;
    ULONGLONG     NewContextFlag;
} OS_HANDOFF_STATE, *POS_HANDOFF_STATE;

//
// per processor OS_MCA and OS_INIT resource structure
//


#define SER_EVENT_STACK_FRAME_ENTRIES    8

typedef struct _SAL_EVENT_RESOURCES {

    SAL_HANDOFF_STATE   SalToOsHandOff;
    OS_HANDOFF_STATE    OsToSalHandOff;
    PVOID               StateDump;
    ULONGLONG           StateDumpPhysical;
    PVOID               BackStore;
    ULONGLONG           BackStoreLimit;
    PVOID               Stack;
    ULONGLONG           StackLimit;
    PULONGLONG          PTOM;
    ULONGLONG           StackFrame[SER_EVENT_STACK_FRAME_ENTRIES];
    PVOID               EventPool;
    ULONG               EventPoolSize;
} SAL_EVENT_RESOURCES, *PSAL_EVENT_RESOURCES;

//
// PAL Mini-save area, used by MCA and INIT
//

typedef struct _PAL_MINI_SAVE_AREA {
    ULONGLONG IntNats;      //  Nat bits for r1-r31
                            //  r1-r31 in bits 1 thru 31.
    ULONGLONG IntGp;        //  r1, volatile
    ULONGLONG IntT0;        //  r2-r3, volatile
    ULONGLONG IntT1;        //
    ULONGLONG IntS0;        //  r4-r7, preserved
    ULONGLONG IntS1;
    ULONGLONG IntS2;
    ULONGLONG IntS3;
    ULONGLONG IntV0;        //  r8, volatile
    ULONGLONG IntT2;        //  r9-r11, volatile
    ULONGLONG IntT3;
    ULONGLONG IntT4;
    ULONGLONG IntSp;        //  stack pointer (r12), special
    ULONGLONG IntTeb;       //  teb (r13), special
    ULONGLONG IntT5;        //  r14-r31, volatile
    ULONGLONG IntT6;

    ULONGLONG B0R16;        // Bank 0 registers 16-31
    ULONGLONG B0R17;        
    ULONGLONG B0R18;        
    ULONGLONG B0R19;        
    ULONGLONG B0R20;        
    ULONGLONG B0R21;        
    ULONGLONG B0R22;        
    ULONGLONG B0R23;        
    ULONGLONG B0R24;        
    ULONGLONG B0R25;        
    ULONGLONG B0R26;        
    ULONGLONG B0R27;        
    ULONGLONG B0R28;        
    ULONGLONG B0R29;        
    ULONGLONG B0R30;        
    ULONGLONG B0R31;        

    ULONGLONG IntT7;        // Bank 1 registers 16-31
    ULONGLONG IntT8;
    ULONGLONG IntT9;
    ULONGLONG IntT10;
    ULONGLONG IntT11;
    ULONGLONG IntT12;
    ULONGLONG IntT13;
    ULONGLONG IntT14;
    ULONGLONG IntT15;
    ULONGLONG IntT16;
    ULONGLONG IntT17;
    ULONGLONG IntT18;
    ULONGLONG IntT19;
    ULONGLONG IntT20;
    ULONGLONG IntT21;
    ULONGLONG IntT22;

    ULONGLONG Preds;        //  predicates, preserved
    ULONGLONG BrRp;         //  return pointer, b0, preserved
    ULONGLONG RsRSC;        //  RSE configuration, volatile
    ULONGLONG StIIP;        //  Interruption IP
    ULONGLONG StIPSR;       //  Interruption Processor Status
    ULONGLONG StIFS;        //  Interruption Function State
    ULONGLONG XIP;          //  Event IP
    ULONGLONG XPSR;         //  Event Processor Status
    ULONGLONG XFS;          //  Event Function State
    
} PAL_MINI_SAVE_AREA, *PPAL_MINI_SAVE_AREA;

//
// Define Processor Control Region Structure.
//

#define PCR_MINOR_VERSION 1
#define PCR_MAJOR_VERSION 1

typedef struct _KPCR {

//
// Major and minor version numbers of the PCR.
//
    ULONG MinorVersion;
    ULONG MajorVersion;

//
// Start of the architecturally defined section of the PCR. This section
// may be directly addressed by vendor/platform specific HAL code and will
// not change from version to version of NT.
//

//
// First and second level cache parameters.
//

    ULONG FirstLevelDcacheSize;
    ULONG FirstLevelDcacheFillSize;
    ULONG FirstLevelIcacheSize;
    ULONG FirstLevelIcacheFillSize;
    ULONG SecondLevelDcacheSize;
    ULONG SecondLevelDcacheFillSize;
    ULONG SecondLevelIcacheSize;
    ULONG SecondLevelIcacheFillSize;

//
// Data cache alignment and fill size used for cache flushing and alignment.
// These fields are set to the larger of the first and second level data
// cache fill sizes.
//

    ULONG DcacheAlignment;
    ULONG DcacheFillSize;

//
// Instruction cache alignment and fill size used for cache flushing and
// alignment. These fields are set to the larger of the first and second
// level data cache fill sizes.
//

    ULONG IcacheAlignment;
    ULONG IcacheFillSize;

//
// Processor identification from PrId register.
//

    ULONG ProcessorId;

//
// Profiling data.
//

    ULONG ProfileInterval;
    ULONG ProfileCount;

//
// Stall execution count and scale factor.
//

    ULONG StallExecutionCount;
    ULONG StallScaleFactor;

    ULONG InterruptionCount;

//
// Space reserved for the system.
//

    ULONGLONG   SystemReserved[6];

//
// Space reserved for the HAL
//

    ULONGLONG   HalReserved[64];

//
// IRQL mapping tables.
//

    UCHAR IrqlMask[64];
    UCHAR IrqlTable[64];

//
// External Interrupt vectors.
//

    PKINTERRUPT_ROUTINE InterruptRoutine[MAXIMUM_VECTOR];

//
// Reserved interrupt vector mask.
//

    ULONG ReservedVectors;

//
// Processor affinity mask.
//

    KAFFINITY SetMember;

//
// Complement of the processor affinity mask.
//

    KAFFINITY NotMember;

//
// Pointer to processor control block.
//

    struct _KPRCB *Prcb;

//
//  Shadow copy of Prcb->CurrentThread for fast access
//

    struct _KTHREAD *CurrentThread;

//
// Processor number.
//

    CCHAR Number;                        // Processor Number
    UCHAR DebugActive;                   // debug register active in user flag
    UCHAR KernelDebugActive;             // debug register active in kernel flag
    UCHAR CurrentIrql;                   // Current IRQL
    union {
        USHORT SoftwareInterruptPending; // Software Interrupt Pending Flag
        struct {
            UCHAR ApcInterrupt;          // 0x01 if APC int pending
            UCHAR DispatchInterrupt;     // 0x01 if dispatch int pending
        };
    };

//
// Address of per processor SAPIC EOI Table
//

    PVOID       EOITable;

//
// IA-64 Machine Check Events trackers
//

    UCHAR       InOsMca;
    UCHAR       InOsInit;
    UCHAR       InOsCmc;
    UCHAR       InOsCpe;
    ULONG       InOsULONG_Spare; // Spare ULONG
    PSAL_EVENT_RESOURCES OsMcaResourcePtr;
    PSAL_EVENT_RESOURCES OsInitResourcePtr;

//
// End of the architecturally defined section of the PCR. This section
// may be directly addressed by vendor/platform specific HAL code and will
// not change from version to version of NT.
//

// end_nthal end_ntddk

//
// OS Part
//

//
//  Address of the thread who currently owns the high fp register set
//

    struct _KTHREAD *HighFpOwner;

//  Per processor kernel (ntoskrnl.exe) global pointer
    ULONGLONG   KernelGP;
//  Per processor initial kernel stack for current thread
    ULONGLONG   InitialStack;
//  Per processor pointer to kernel BSP
    ULONGLONG   InitialBStore;
//  Per processor kernel stack limit
    ULONGLONG   StackLimit;
//  Per processor kernel backing store limit
    ULONGLONG   BStoreLimit;
//  Per processor panic kernel stack
    ULONGLONG   PanicStack;

//
//  Save area for kernel entry/exit
//
    ULONGLONG   SavedIIM;
    ULONGLONG   SavedIFA;

    ULONGLONG   ForwardProgressBuffer[16];
    PVOID       Pcb;      // holds KPROCESS for MP region synchronization

//
//  Nt page table base addresses
//
    ULONGLONG   PteUbase;
    ULONGLONG   PteKbase;
    ULONGLONG   PteSbase;
    ULONGLONG   PdeUbase;
    ULONGLONG   PdeKbase;
    ULONGLONG   PdeSbase;
    ULONGLONG   PdeUtbase;
    ULONGLONG   PdeKtbase;
    ULONGLONG   PdeStbase;

//
//  The actual resources for the OS_INIT and OS_MCA handlers
//  are placed at the end of the PCR structure so that auto
//  can be used to get to get between the public and private
//  sections of the PCR in the traps and context routines.
//
    SAL_EVENT_RESOURCES OsMcaResource;
    SAL_EVENT_RESOURCES OsInitResource;

// begin_nthal begin_ntddk

} KPCR, *PKPCR;

// end_nthal end_ntddk end_ntosp

// begin_nthal

//
// Define the number of bits to shift to right justify the Page Table Index
// field of a PTE.
//

#define PTI_SHIFT PAGE_SHIFT

//
// Define the number of bits to shift to right justify the Page Directory Index
// field of a PTE.
//

#define PDI_SHIFT (PTI_SHIFT + PAGE_SHIFT - PTE_SHIFT)
#define PDI1_SHIFT (PDI_SHIFT + PAGE_SHIFT - PTE_SHIFT)
#define PDI_MASK ((1 << (PAGE_SHIFT - PTE_SHIFT)) - 1)

//
// Define the number of bits to shift to left to produce page table offset
// from page table index.
//

#define PTE_SHIFT 3

//
// Define the number of bits to shift to the right justify the Page Directory
// Table Entry field.
//

#define VHPT_PDE_BITS 40

//
// Define the RID for IO Port Space.
//

#define RR_IO_PORT 6


//
// The following definitions are required for the debugger data block.
//

// begin_ntddk begin_ntosp

//
// The highest user address reserves 64K bytes for a guard page. This
// the probing of address from kernel mode to only have to check the
// starting address for structures of 64k bytes or less.
//

extern NTKERNELAPI PVOID MmHighestUserAddress;
extern NTKERNELAPI PVOID MmSystemRangeStart;
extern NTKERNELAPI ULONG_PTR MmUserProbeAddress;


#define MM_HIGHEST_USER_ADDRESS MmHighestUserAddress
#define MM_USER_PROBE_ADDRESS MmUserProbeAddress
#define MM_SYSTEM_RANGE_START MmSystemRangeStart

//
// The lowest user address reserves the low 64k.
//

#define MM_LOWEST_USER_ADDRESS  (PVOID)((ULONG_PTR)(UADDRESS_BASE+0x00010000))

// begin_wdm

#define MmGetProcedureAddress(Address) (Address)
#define MmLockPagableCodeSection(PLabelAddress) \
    MmLockPagableDataSection((PVOID)(*((PULONGLONG)PLabelAddress)))

#define VRN_MASK   0xE000000000000000UI64    // Virtual Region Number mask

// end_ntddk end_wdm end_ntosp

//
// Limit the IA32 subsystem to a 2GB virtual address space.
// This means "Large Address Aware" apps are not supported in emulation mode.
//

#define MM_MAX_WOW64_ADDRESS       (0x00000000080000000UI64)

#define MI_HIGHEST_USER_ADDRESS (PVOID) (ULONG_PTR)((UADDRESS_BASE + 0x6FC00000000 - 0x10000 - 1)) // highest user address
#define MI_USER_PROBE_ADDRESS ((ULONG_PTR)(UADDRESS_BASE + 0x6FC00000000UI64 - 0x10000)) // starting address of guard page
#define MI_SYSTEM_RANGE_START (PVOID) (UADDRESS_BASE + 0x6FC00000000) // start of system space

//
// Define the page table base and the page directory base for
// the TB miss routines and memory management.
//
//
// user/kernel page table base and top addresses
//

extern ULONG_PTR KiIA64VaSignedFill;
extern ULONG_PTR KiIA64PtaSign;

#define PTA_SIGN KiIA64PtaSign
#define VA_FILL KiIA64VaSignedFill

#define SADDRESS_BASE 0x2000000000000000UI64  // session base address

#define PTE_UBASE  PCR->PteUbase
#define PTE_KBASE  PCR->PteKbase
#define PTE_SBASE  PCR->PteSbase

#define PTE_UTOP (PTE_UBASE|(((ULONG_PTR)1 << PDI1_SHIFT) - 1)) // top level PDR address (user)
#define PTE_KTOP (PTE_KBASE|(((ULONG_PTR)1 << PDI1_SHIFT) - 1)) // top level PDR address (kernel)
#define PTE_STOP (PTE_SBASE|(((ULONG_PTR)1 << PDI1_SHIFT) - 1)) // top level PDR address (session)

//
// Second level user and kernel PDR address
//

#define PDE_UBASE  PCR->PdeUbase
#define PDE_KBASE  PCR->PdeKbase
#define PDE_SBASE  PCR->PdeSbase

#define PDE_UTOP (PDE_UBASE|(((ULONG_PTR)1 << PDI_SHIFT) - 1)) // second level PDR address (user)
#define PDE_KTOP (PDE_KBASE|(((ULONG_PTR)1 << PDI_SHIFT) - 1)) // second level PDR address (kernel)
#define PDE_STOP (PDE_SBASE|(((ULONG_PTR)1 << PDI_SHIFT) - 1)) // second level PDR address (session)

//
// 8KB first level user and kernel PDR address
//

#define PDE_UTBASE PCR->PdeUtbase
#define PDE_KTBASE PCR->PdeKtbase
#define PDE_STBASE PCR->PdeStbase

#define PDE_USELFMAP (PDE_UTBASE|(PAGE_SIZE - (1<<PTE_SHIFT))) // self mapped PPE address (user)
#define PDE_KSELFMAP (PDE_KTBASE|(PAGE_SIZE - (1<<PTE_SHIFT))) // self mapped PPE address (kernel)
#define PDE_SSELFMAP (PDE_STBASE|(PAGE_SIZE - (1<<PTE_SHIFT))) // self mapped PPE address (kernel)

#define PTE_BASE    PTE_UBASE
#define PDE_BASE    PDE_UBASE
#define PDE_TBASE   PDE_UTBASE
#define PDE_SELFMAP PDE_USELFMAP

#define KSEG0_BASE (KADDRESS_BASE + 0x80000000)           // base of kernel
#define KSEG2_BASE (KADDRESS_BASE + 0xA0000000)           // end of kernel

#define KSEG3_BASE 0x8000000000000000UI64
#define KSEG3_LIMIT 0x8000100000000000UI64

#define KSEG4_BASE 0xA000000000000000UI64
#define KSEG4_LIMIT 0xA000100000000000UI64

//
//++
//PVOID
//KSEG_ADDRESS (
//    IN ULONG PAGE
//    );
//
// Routine Description:
//
//    This macro returns a KSEG virtual address which maps the page.
//
// Arguments:
//
//    PAGE - Supplies the physical page frame number
//
// Return Value:
//
//    The address of the KSEG address
//
//--

#define KSEG_ADDRESS(PAGE) ((PVOID)(KSEG3_BASE | ((ULONG_PTR)(PAGE) << PAGE_SHIFT)))

#define KSEG4_ADDRESS(PAGE) ((PVOID)(KSEG4_BASE | ((ULONG_PTR)(PAGE) << PAGE_SHIFT)))


#define MAXIMUM_FWP_BUFFER_ENTRY 8

typedef struct _REGION_MAP_INFO {
    ULONG RegionId;
    ULONG PageSize;
    ULONGLONG SequenceNumber;
} REGION_MAP_INFO, *PREGION_MAP_INFO;

// begin_ntddk begin_wdm
//
// The lowest address for system space.
//

#define MM_LOWEST_SYSTEM_ADDRESS ((PVOID)((ULONG_PTR)(KADDRESS_BASE + 0xC0C00000)))
// end_nthal end_ntddk end_wdm

#define SYSTEM_BASE (KADDRESS_BASE + 0xC3000000)          // start of system space (no typecast)

//
// Define macro to initialize directory table base.
//

#define INITIALIZE_DIRECTORY_TABLE_BASE(dirbase, pfn)   \
    *((PULONGLONG)(dirbase)) = 0;                       \
    ((PHARDWARE_PTE)(dirbase))->PageFrameNumber = pfn;  \
    ((PHARDWARE_PTE)(dirbase))->Accessed = 1;           \
    ((PHARDWARE_PTE)(dirbase))->Dirty = 1;              \
    ((PHARDWARE_PTE)(dirbase))->Cache = 0;              \
    ((PHARDWARE_PTE)(dirbase))->Write = 1;              \
    ((PHARDWARE_PTE)(dirbase))->Valid = 1;


//
// IA64 function definitions
//

//++
//
// BOOLEAN
// KiIsThreadNumericStateSaved(
//     IN PKTHREAD Address
//     )
//
//  This call is used on a not running thread to see if it's numeric
//  state has been saved in it's context information.  On IA64 the
//  numeric state is always saved.
//
//--
#define KiIsThreadNumericStateSaved(a) TRUE

//++
//
// VOID
// KiRundownThread(
//     IN PKTHREAD Address
//     )
//
//--
#define KiRundownThread(a)

//
// ia64 Feature bit definitions
//

#define KF_BRL              0x00000001   // processor supports long branch instruction.

//
// Define macro to test if x86 feature is present.
//
// N.B. All x86 features test TRUE on IA64 systems.
//

#define Isx86FeaturePresent(_f_) TRUE


// begin_nthal begin_ntddk begin_ntndis begin_wdm begin_ntosp
#endif // defined(_IA64_)

//
// Defines the Type in the RESOURCE_DESCRIPTOR
//
// NOTE:  For all CM_RESOURCE_TYPE values, there must be a
// corresponding ResType value in the 32-bit ConfigMgr headerfile
// (cfgmgr32.h).  Values in the range [0x6,0x80) use the same values
// as their ConfigMgr counterparts.  CM_RESOURCE_TYPE values with
// the high bit set (i.e., in the range [0x80,0xFF]), are
// non-arbitrated resources.  These correspond to the same values
// in cfgmgr32.h that have their high bit set (however, since
// cfgmgr32.h uses 16 bits for ResType values, these values are in
// the range [0x8000,0x807F).  Note that ConfigMgr ResType values
// cannot be in the range [0x8080,0xFFFF), because they would not
// be able to map into CM_RESOURCE_TYPE values.  (0xFFFF itself is
// a special value, because it maps to CmResourceTypeDeviceSpecific.)
//

typedef int CM_RESOURCE_TYPE;

// CmResourceTypeNull is reserved

#define CmResourceTypeNull                0   // ResType_All or ResType_None (0x0000)
#define CmResourceTypePort                1   // ResType_IO (0x0002)
#define CmResourceTypeInterrupt           2   // ResType_IRQ (0x0004)
#define CmResourceTypeMemory              3   // ResType_Mem (0x0001)
#define CmResourceTypeDma                 4   // ResType_DMA (0x0003)
#define CmResourceTypeDeviceSpecific      5   // ResType_ClassSpecific (0xFFFF)
#define CmResourceTypeBusNumber           6   // ResType_BusNumber (0x0006)
// end_wdm
#define CmResourceTypeMaximum             7
// begin_wdm
#define CmResourceTypeNonArbitrated     128   // Not arbitrated if 0x80 bit set
#define CmResourceTypeConfigData        128   // ResType_Reserved (0x8000)
#define CmResourceTypeDevicePrivate     129   // ResType_DevicePrivate (0x8001)
#define CmResourceTypePcCardConfig      130   // ResType_PcCardConfig (0x8002)
#define CmResourceTypeMfCardConfig      131   // ResType_MfCardConfig (0x8003)

//
// Defines the ShareDisposition in the RESOURCE_DESCRIPTOR
//

typedef enum _CM_SHARE_DISPOSITION {
    CmResourceShareUndetermined = 0,    // Reserved
    CmResourceShareDeviceExclusive,
    CmResourceShareDriverExclusive,
    CmResourceShareShared
} CM_SHARE_DISPOSITION;

//
// Define the bit masks for Flags when type is CmResourceTypeInterrupt
//

#define CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE 0
#define CM_RESOURCE_INTERRUPT_LATCHED         1

//
// Define the bit masks for Flags when type is CmResourceTypeMemory
//

#define CM_RESOURCE_MEMORY_READ_WRITE       0x0000
#define CM_RESOURCE_MEMORY_READ_ONLY        0x0001
#define CM_RESOURCE_MEMORY_WRITE_ONLY       0x0002
#define CM_RESOURCE_MEMORY_PREFETCHABLE     0x0004

#define CM_RESOURCE_MEMORY_COMBINEDWRITE    0x0008
#define CM_RESOURCE_MEMORY_24               0x0010
#define CM_RESOURCE_MEMORY_CACHEABLE        0x0020

//
// Define the bit masks for Flags when type is CmResourceTypePort
//

#define CM_RESOURCE_PORT_MEMORY                             0x0000
#define CM_RESOURCE_PORT_IO                                 0x0001
#define CM_RESOURCE_PORT_10_BIT_DECODE                      0x0004
#define CM_RESOURCE_PORT_12_BIT_DECODE                      0x0008
#define CM_RESOURCE_PORT_16_BIT_DECODE                      0x0010
#define CM_RESOURCE_PORT_POSITIVE_DECODE                    0x0020
#define CM_RESOURCE_PORT_PASSIVE_DECODE                     0x0040
#define CM_RESOURCE_PORT_WINDOW_DECODE                      0x0080

//
// Define the bit masks for Flags when type is CmResourceTypeDma
//

#define CM_RESOURCE_DMA_8                   0x0000
#define CM_RESOURCE_DMA_16                  0x0001
#define CM_RESOURCE_DMA_32                  0x0002
#define CM_RESOURCE_DMA_8_AND_16            0x0004
#define CM_RESOURCE_DMA_BUS_MASTER          0x0008
#define CM_RESOURCE_DMA_TYPE_A              0x0010
#define CM_RESOURCE_DMA_TYPE_B              0x0020
#define CM_RESOURCE_DMA_TYPE_F              0x0040


#include "pshpack4.h"
typedef struct _CM_PARTIAL_RESOURCE_DESCRIPTOR {
    UCHAR Type;
    UCHAR ShareDisposition;
    USHORT Flags;
    union {

        //
        // Range of resources, inclusive.  These are physical, bus relative.
        // It is known that Port and Memory below have the exact same layout
        // as Generic.
        //

        struct {
            PHYSICAL_ADDRESS Start;
            ULONG Length;
        } Generic;

        //
        // end_wdm
        // Range of port numbers, inclusive. These are physical, bus
        // relative. The value should be the same as the one passed to
        // HalTranslateBusAddress().
        // begin_wdm
        //

        struct {
            PHYSICAL_ADDRESS Start;
            ULONG Length;
        } Port;

        //
        // end_wdm
        // IRQL and vector. Should be same values as were passed to
        // HalGetInterruptVector().
        // begin_wdm
        //

        struct {
            ULONG Level;
            ULONG Vector;
            KAFFINITY Affinity;
        } Interrupt;

        //
        // Range of memory addresses, inclusive. These are physical, bus
        // relative. The value should be the same as the one passed to
        // HalTranslateBusAddress().
        //

        struct {
            PHYSICAL_ADDRESS Start;    // 64 bit physical addresses.
            ULONG Length;
        } Memory;

        //
        // Physical DMA channel.
        //

        struct {
            ULONG Channel;
            ULONG Port;
            ULONG Reserved1;
        } Dma;

        //
        // Device driver private data, usually used to help it figure
        // what the resource assignments decisions that were made.
        //

        struct {
            ULONG Data[3];
        } DevicePrivate;

        //
        // Bus Number information.
        //

        struct {
            ULONG Start;
            ULONG Length;
            ULONG Reserved;
        } BusNumber;

        //
        // Device Specific information defined by the driver.
        // The DataSize field indicates the size of the data in bytes. The
        // data is located immediately after the DeviceSpecificData field in
        // the structure.
        //

        struct {
            ULONG DataSize;
            ULONG Reserved1;
            ULONG Reserved2;
        } DeviceSpecificData;
    } u;
} CM_PARTIAL_RESOURCE_DESCRIPTOR, *PCM_PARTIAL_RESOURCE_DESCRIPTOR;
#include "poppack.h"

//
// A Partial Resource List is what can be found in the ARC firmware
// or will be generated by ntdetect.com.
// The configuration manager will transform this structure into a Full
// resource descriptor when it is about to store it in the regsitry.
//
// Note: There must a be a convention to the order of fields of same type,
// (defined on a device by device basis) so that the fields can make sense
// to a driver (i.e. when multiple memory ranges are necessary).
//

typedef struct _CM_PARTIAL_RESOURCE_LIST {
    USHORT Version;
    USHORT Revision;
    ULONG Count;
    CM_PARTIAL_RESOURCE_DESCRIPTOR PartialDescriptors[1];
} CM_PARTIAL_RESOURCE_LIST, *PCM_PARTIAL_RESOURCE_LIST;

//
// A Full Resource Descriptor is what can be found in the registry.
// This is what will be returned to a driver when it queries the registry
// to get device information; it will be stored under a key in the hardware
// description tree.
//
// end_wdm
// Note: The BusNumber and Type are redundant information, but we will keep
// it since it allows the driver _not_ to append it when it is creating
// a resource list which could possibly span multiple buses.
//
// begin_wdm
// Note: There must a be a convention to the order of fields of same type,
// (defined on a device by device basis) so that the fields can make sense
// to a driver (i.e. when multiple memory ranges are necessary).
//

typedef struct _CM_FULL_RESOURCE_DESCRIPTOR {
    INTERFACE_TYPE InterfaceType; // unused for WDM
    ULONG BusNumber; // unused for WDM
    CM_PARTIAL_RESOURCE_LIST PartialResourceList;
} CM_FULL_RESOURCE_DESCRIPTOR, *PCM_FULL_RESOURCE_DESCRIPTOR;

//
// The Resource list is what will be stored by the drivers into the
// resource map via the IO API.
//

typedef struct _CM_RESOURCE_LIST {
    ULONG Count;
    CM_FULL_RESOURCE_DESCRIPTOR List[1];
} CM_RESOURCE_LIST, *PCM_RESOURCE_LIST;


#include "pshpack1.h"


//
// Define Mca POS data block for slot
//

typedef struct _CM_MCA_POS_DATA {
    USHORT AdapterId;
    UCHAR PosData1;
    UCHAR PosData2;
    UCHAR PosData3;
    UCHAR PosData4;
} CM_MCA_POS_DATA, *PCM_MCA_POS_DATA;

//
// Memory configuration of eisa data block structure
//

typedef struct _EISA_MEMORY_TYPE {
    UCHAR ReadWrite: 1;
    UCHAR Cached : 1;
    UCHAR Reserved0 :1;
    UCHAR Type:2;
    UCHAR Shared:1;
    UCHAR Reserved1 :1;
    UCHAR MoreEntries : 1;
} EISA_MEMORY_TYPE, *PEISA_MEMORY_TYPE;

typedef struct _EISA_MEMORY_CONFIGURATION {
    EISA_MEMORY_TYPE ConfigurationByte;
    UCHAR DataSize;
    USHORT AddressLowWord;
    UCHAR AddressHighByte;
    USHORT MemorySize;
} EISA_MEMORY_CONFIGURATION, *PEISA_MEMORY_CONFIGURATION;


//
// Interrupt configurationn of eisa data block structure
//

typedef struct _EISA_IRQ_DESCRIPTOR {
    UCHAR Interrupt : 4;
    UCHAR Reserved :1;
    UCHAR LevelTriggered :1;
    UCHAR Shared : 1;
    UCHAR MoreEntries : 1;
} EISA_IRQ_DESCRIPTOR, *PEISA_IRQ_DESCRIPTOR;

typedef struct _EISA_IRQ_CONFIGURATION {
    EISA_IRQ_DESCRIPTOR ConfigurationByte;
    UCHAR Reserved;
} EISA_IRQ_CONFIGURATION, *PEISA_IRQ_CONFIGURATION;


//
// DMA description of eisa data block structure
//

typedef struct _DMA_CONFIGURATION_BYTE0 {
    UCHAR Channel : 3;
    UCHAR Reserved : 3;
    UCHAR Shared :1;
    UCHAR MoreEntries :1;
} DMA_CONFIGURATION_BYTE0;

typedef struct _DMA_CONFIGURATION_BYTE1 {
    UCHAR Reserved0 : 2;
    UCHAR TransferSize : 2;
    UCHAR Timing : 2;
    UCHAR Reserved1 : 2;
} DMA_CONFIGURATION_BYTE1;

typedef struct _EISA_DMA_CONFIGURATION {
    DMA_CONFIGURATION_BYTE0 ConfigurationByte0;
    DMA_CONFIGURATION_BYTE1 ConfigurationByte1;
} EISA_DMA_CONFIGURATION, *PEISA_DMA_CONFIGURATION;


//
// Port description of eisa data block structure
//

typedef struct _EISA_PORT_DESCRIPTOR {
    UCHAR NumberPorts : 5;
    UCHAR Reserved :1;
    UCHAR Shared :1;
    UCHAR MoreEntries : 1;
} EISA_PORT_DESCRIPTOR, *PEISA_PORT_DESCRIPTOR;

typedef struct _EISA_PORT_CONFIGURATION {
    EISA_PORT_DESCRIPTOR Configuration;
    USHORT PortAddress;
} EISA_PORT_CONFIGURATION, *PEISA_PORT_CONFIGURATION;


//
// Eisa slot information definition
// N.B. This structure is different from the one defined
//      in ARC eisa addendum.
//

typedef struct _CM_EISA_SLOT_INFORMATION {
    UCHAR ReturnCode;
    UCHAR ReturnFlags;
    UCHAR MajorRevision;
    UCHAR MinorRevision;
    USHORT Checksum;
    UCHAR NumberFunctions;
    UCHAR FunctionInformation;
    ULONG CompressedId;
} CM_EISA_SLOT_INFORMATION, *PCM_EISA_SLOT_INFORMATION;


//
// Eisa function information definition
//

typedef struct _CM_EISA_FUNCTION_INFORMATION {
    ULONG CompressedId;
    UCHAR IdSlotFlags1;
    UCHAR IdSlotFlags2;
    UCHAR MinorRevision;
    UCHAR MajorRevision;
    UCHAR Selections[26];
    UCHAR FunctionFlags;
    UCHAR TypeString[80];
    EISA_MEMORY_CONFIGURATION EisaMemory[9];
    EISA_IRQ_CONFIGURATION EisaIrq[7];
    EISA_DMA_CONFIGURATION EisaDma[4];
    EISA_PORT_CONFIGURATION EisaPort[20];
    UCHAR InitializationData[60];
} CM_EISA_FUNCTION_INFORMATION, *PCM_EISA_FUNCTION_INFORMATION;

//
// The following defines the way pnp bios information is stored in
// the registry \\HKEY_LOCAL_MACHINE\HARDWARE\Description\System\MultifunctionAdapter\x
// key, where x is an integer number indicating adapter instance. The
// "Identifier" of the key must equal to "PNP BIOS" and the
// "ConfigurationData" is organized as follow:
//
//      CM_PNP_BIOS_INSTALLATION_CHECK        +
//      CM_PNP_BIOS_DEVICE_NODE for device 1  +
//      CM_PNP_BIOS_DEVICE_NODE for device 2  +
//                ...
//      CM_PNP_BIOS_DEVICE_NODE for device n
//

//
// Pnp BIOS device node structure
//

typedef struct _CM_PNP_BIOS_DEVICE_NODE {
    USHORT Size;
    UCHAR Node;
    ULONG ProductId;
    UCHAR DeviceType[3];
    USHORT DeviceAttributes;
    // followed by AllocatedResourceBlock, PossibleResourceBlock
    // and CompatibleDeviceId
} CM_PNP_BIOS_DEVICE_NODE,*PCM_PNP_BIOS_DEVICE_NODE;

//
// Pnp BIOS Installation check
//

typedef struct _CM_PNP_BIOS_INSTALLATION_CHECK {
    UCHAR Signature[4];             // $PnP (ascii)
    UCHAR Revision;
    UCHAR Length;
    USHORT ControlField;
    UCHAR Checksum;
    ULONG EventFlagAddress;         // Physical address
    USHORT RealModeEntryOffset;
    USHORT RealModeEntrySegment;
    USHORT ProtectedModeEntryOffset;
    ULONG ProtectedModeCodeBaseAddress;
    ULONG OemDeviceId;
    USHORT RealModeDataBaseAddress;
    ULONG ProtectedModeDataBaseAddress;
} CM_PNP_BIOS_INSTALLATION_CHECK, *PCM_PNP_BIOS_INSTALLATION_CHECK;

#include "poppack.h"

//
// Masks for EISA function information
//

#define EISA_FUNCTION_ENABLED                   0x80
#define EISA_FREE_FORM_DATA                     0x40
#define EISA_HAS_PORT_INIT_ENTRY                0x20
#define EISA_HAS_PORT_RANGE                     0x10
#define EISA_HAS_DMA_ENTRY                      0x08
#define EISA_HAS_IRQ_ENTRY                      0x04
#define EISA_HAS_MEMORY_ENTRY                   0x02
#define EISA_HAS_TYPE_ENTRY                     0x01
#define EISA_HAS_INFORMATION                    EISA_HAS_PORT_RANGE + \
                                                EISA_HAS_DMA_ENTRY + \
                                                EISA_HAS_IRQ_ENTRY + \
                                                EISA_HAS_MEMORY_ENTRY + \
                                                EISA_HAS_TYPE_ENTRY

//
// Masks for EISA memory configuration
//

#define EISA_MORE_ENTRIES                       0x80
#define EISA_SYSTEM_MEMORY                      0x00
#define EISA_MEMORY_TYPE_RAM                    0x01

//
// Returned error code for EISA bios call
//

#define EISA_INVALID_SLOT                       0x80
#define EISA_INVALID_FUNCTION                   0x81
#define EISA_INVALID_CONFIGURATION              0x82
#define EISA_EMPTY_SLOT                         0x83
#define EISA_INVALID_BIOS_CALL                  0x86


//
// Interrupt modes.
//

typedef enum _KINTERRUPT_MODE {
    LevelSensitive,
    Latched
    } KINTERRUPT_MODE;

typedef struct _KINTERRUPT *PKINTERRUPT, *RESTRICTED_POINTER PRKINTERRUPT; 

//
// On X86 the following routines are defined in the HAL and imported by
// all other modules.
//

#if defined(_X86_) && !defined(_NTHAL_)

#define _DECL_HAL_KE_IMPORT  __declspec(dllimport)

#else

#define _DECL_HAL_KE_IMPORT

#endif

//
// spin lock functions
//

NTKERNELAPI
VOID
NTAPI
KeInitializeSpinLock (
    IN PKSPIN_LOCK SpinLock
    );

#if defined(_X86_)

NTKERNELAPI
VOID
FASTCALL
KefAcquireSpinLockAtDpcLevel (
    IN PKSPIN_LOCK SpinLock
    );

NTKERNELAPI
VOID
FASTCALL
KefReleaseSpinLockFromDpcLevel (
    IN PKSPIN_LOCK SpinLock
    );

#define KeAcquireSpinLockAtDpcLevel(a)      KefAcquireSpinLockAtDpcLevel(a)
#define KeReleaseSpinLockFromDpcLevel(a)    KefReleaseSpinLockFromDpcLevel(a)

_DECL_HAL_KE_IMPORT
KIRQL
FASTCALL
KfAcquireSpinLock (
    IN PKSPIN_LOCK SpinLock
    );

_DECL_HAL_KE_IMPORT
VOID
FASTCALL
KfReleaseSpinLock (
    IN PKSPIN_LOCK SpinLock,
    IN KIRQL NewIrql
    );

// end_wdm

_DECL_HAL_KE_IMPORT
KIRQL
FASTCALL
KeAcquireSpinLockRaiseToSynch (
    IN PKSPIN_LOCK SpinLock
    );

// begin_wdm

#define KeAcquireSpinLock(a,b)  *(b) = KfAcquireSpinLock(a)
#define KeReleaseSpinLock(a,b)  KfReleaseSpinLock(a,b)

#else

NTKERNELAPI
KIRQL
FASTCALL
KeAcquireSpinLockRaiseToSynch (
    IN PKSPIN_LOCK SpinLock
    );

NTKERNELAPI
VOID
KeAcquireSpinLockAtDpcLevel (
    IN PKSPIN_LOCK SpinLock
    );

NTKERNELAPI
VOID
KeReleaseSpinLockFromDpcLevel (
    IN PKSPIN_LOCK SpinLock
    );

NTKERNELAPI
KIRQL
KeAcquireSpinLockRaiseToDpc (
    IN PKSPIN_LOCK SpinLock
    );

#define KeAcquireSpinLock(SpinLock, OldIrql) \
    *(OldIrql) = KeAcquireSpinLockRaiseToDpc(SpinLock)

NTKERNELAPI
VOID
KeReleaseSpinLock (
    IN PKSPIN_LOCK SpinLock,
    IN KIRQL NewIrql
    );

#endif

NTKERNELAPI
BOOLEAN
FASTCALL
KeTryToAcquireSpinLockAtDpcLevel (
    IN PKSPIN_LOCK SpinLock
    );

//
// Define I/O system data structure type codes.  Each major data structure in
// the I/O system has a type code  The type field in each structure is at the
// same offset.  The following values can be used to determine which type of
// data structure a pointer refers to.
//

#define IO_TYPE_ADAPTER                 0x00000001
#define IO_TYPE_CONTROLLER              0x00000002
#define IO_TYPE_DEVICE                  0x00000003
#define IO_TYPE_DRIVER                  0x00000004
#define IO_TYPE_FILE                    0x00000005
#define IO_TYPE_IRP                     0x00000006
#define IO_TYPE_MASTER_ADAPTER          0x00000007
#define IO_TYPE_OPEN_PACKET             0x00000008
#define IO_TYPE_TIMER                   0x00000009
#define IO_TYPE_VPB                     0x0000000a
#define IO_TYPE_ERROR_LOG               0x0000000b
#define IO_TYPE_ERROR_MESSAGE           0x0000000c
#define IO_TYPE_DEVICE_OBJECT_EXTENSION 0x0000000d


//
// Define the major function codes for IRPs.
//


#define IRP_MJ_CREATE                   0x00
#define IRP_MJ_CREATE_NAMED_PIPE        0x01
#define IRP_MJ_CLOSE                    0x02
#define IRP_MJ_READ                     0x03
#define IRP_MJ_WRITE                    0x04
#define IRP_MJ_QUERY_INFORMATION        0x05
#define IRP_MJ_SET_INFORMATION          0x06
#define IRP_MJ_QUERY_EA                 0x07
#define IRP_MJ_SET_EA                   0x08
#define IRP_MJ_FLUSH_BUFFERS            0x09
#define IRP_MJ_QUERY_VOLUME_INFORMATION 0x0a
#define IRP_MJ_SET_VOLUME_INFORMATION   0x0b
#define IRP_MJ_DIRECTORY_CONTROL        0x0c
#define IRP_MJ_FILE_SYSTEM_CONTROL      0x0d
#define IRP_MJ_DEVICE_CONTROL           0x0e
#define IRP_MJ_INTERNAL_DEVICE_CONTROL  0x0f
#define IRP_MJ_SHUTDOWN                 0x10
#define IRP_MJ_LOCK_CONTROL             0x11
#define IRP_MJ_CLEANUP                  0x12
#define IRP_MJ_CREATE_MAILSLOT          0x13
#define IRP_MJ_QUERY_SECURITY           0x14
#define IRP_MJ_SET_SECURITY             0x15
#define IRP_MJ_POWER                    0x16
#define IRP_MJ_SYSTEM_CONTROL           0x17
#define IRP_MJ_DEVICE_CHANGE            0x18
#define IRP_MJ_QUERY_QUOTA              0x19
#define IRP_MJ_SET_QUOTA                0x1a
#define IRP_MJ_PNP                      0x1b
#define IRP_MJ_PNP_POWER                IRP_MJ_PNP      // Obsolete....
#define IRP_MJ_MAXIMUM_FUNCTION         0x1b

//
// Make the Scsi major code the same as internal device control.
//

#define IRP_MJ_SCSI                     IRP_MJ_INTERNAL_DEVICE_CONTROL

//
// Define the minor function codes for IRPs.  The lower 128 codes, from 0x00 to
// 0x7f are reserved to Microsoft.  The upper 128 codes, from 0x80 to 0xff, are
// reserved to customers of Microsoft.
//

//
// Define driver cancel routine type.
//

typedef
VOID
(*PDRIVER_CANCEL) (
    IN struct _DEVICE_OBJECT *DeviceObject,
    IN struct _IRP *Irp
    );

//
// Define driver dispatch routine type.
//

typedef
NTSTATUS
(*PDRIVER_DISPATCH) (
    IN struct _DEVICE_OBJECT *DeviceObject,
    IN struct _IRP *Irp
    );

//
// Define driver start I/O routine type.
//

typedef
VOID
(*PDRIVER_STARTIO) (
    IN struct _DEVICE_OBJECT *DeviceObject,
    IN struct _IRP *Irp
    );

//
// Define driver unload routine type.
//
typedef
VOID
(*PDRIVER_UNLOAD) (
    IN struct _DRIVER_OBJECT *DriverObject
    );
//
// Define driver AddDevice routine type.
//

typedef
NTSTATUS
(*PDRIVER_ADD_DEVICE) (
    IN struct _DRIVER_OBJECT *DriverObject,
    IN struct _DEVICE_OBJECT *PhysicalDeviceObject
    );

typedef struct _ADAPTER_OBJECT *PADAPTER_OBJECT; 
typedef struct _DEVICE_OBJECT *PDEVICE_OBJECT; 
typedef struct _DRIVER_OBJECT *PDRIVER_OBJECT; 
typedef struct _FILE_OBJECT *PFILE_OBJECT; 

#if defined(_WIN64)
#define POINTER_ALIGNMENT DECLSPEC_ALIGN(8)
#else
#define POINTER_ALIGNMENT
#endif

#if defined(_ALPHA_) || defined(_IA64_)         
                                                
DECLSPEC_DEPRECATED_DDK                 // Use GetDmaRequirement
NTHALAPI
ULONG
HalGetDmaAlignmentRequirement (
    VOID
    );

#endif                                          
                                                
#if defined(_M_IX86) || defined(_M_AMD64)       
                                                
#define HalGetDmaAlignmentRequirement() 1L      
#endif                                          
                                                
NTHALAPI                                        
VOID                                            
KeFlushWriteBuffer (                            
    VOID                                        
    );                                          
                                                
//
// Stall processor execution function.
//

NTHALAPI
VOID
KeStallExecutionProcessor (
    IN ULONG MicroSeconds
    );


typedef struct _SCATTER_GATHER_ELEMENT {
    PHYSICAL_ADDRESS Address;
    ULONG Length;
    ULONG_PTR Reserved;
} SCATTER_GATHER_ELEMENT, *PSCATTER_GATHER_ELEMENT;

#pragma warning(disable:4200)
typedef struct _SCATTER_GATHER_LIST {
    ULONG NumberOfElements;
    ULONG_PTR Reserved;
    SCATTER_GATHER_ELEMENT Elements[];
} SCATTER_GATHER_LIST, *PSCATTER_GATHER_LIST;
#pragma warning(default:4200)

//
// Pool Allocation routines (in pool.c)
//

typedef enum _POOL_TYPE {
    NonPagedPool,
    PagedPool,
    NonPagedPoolMustSucceed,
    DontUseThisType,
    NonPagedPoolCacheAligned,
    PagedPoolCacheAligned,
    NonPagedPoolCacheAlignedMustS,
    MaxPoolType

    // end_wdm
    ,
    //
    // Note these per session types are carefully chosen so that the appropriate
    // masking still applies as well as MaxPoolType above.
    //

    NonPagedPoolSession = 32,
    PagedPoolSession = NonPagedPoolSession + 1,
    NonPagedPoolMustSucceedSession = PagedPoolSession + 1,
    DontUseThisTypeSession = NonPagedPoolMustSucceedSession + 1,
    NonPagedPoolCacheAlignedSession = DontUseThisTypeSession + 1,
    PagedPoolCacheAlignedSession = NonPagedPoolCacheAlignedSession + 1,
    NonPagedPoolCacheAlignedMustSSession = PagedPoolCacheAlignedSession + 1,

    // begin_wdm

    } POOL_TYPE;

#define POOL_COLD_ALLOCATION 256     // Note this cannot encode into the header.

//

NTKERNELAPI
VOID
FASTCALL
ExInterlockedAddLargeStatistic (
    IN PLARGE_INTEGER Addend,
    IN ULONG Increment
    );

//
// Define interlocked sequenced listhead functions.
//
// A sequenced interlocked list is a singly linked list with a header that
// contains the current depth and a sequence number. Each time an entry is
// inserted or removed from the list the depth is updated and the sequence
// number is incremented. This enables AMD64, IA64, and Pentium and later
// machines to insert and remove from the list without the use of spinlocks.
//

#if !defined(_WINBASE_)

/*++

Routine Description:

    This function initializes a sequenced singly linked listhead.

Arguments:

    SListHead - Supplies a pointer to a sequenced singly linked listhead.

Return Value:

    None.

--*/

#if defined(_WIN64) && (defined(_NTDRIVER_) || defined(_NTDDK_) || defined(_NTIFS_) || defined(_NTHAL_) || defined(_NTOSP_))

NTKERNELAPI
VOID
InitializeSListHead (
    IN PSLIST_HEADER SListHead
    );

#else

__inline
VOID
InitializeSListHead (
    IN PSLIST_HEADER SListHead
    )

{

#ifdef _WIN64

    //
    // Slist headers must be 16 byte aligned.
    //

    if ((ULONG_PTR) SListHead & 0x0f) {

        DbgPrint( "InitializeSListHead unaligned Slist header.  Address = %p, Caller = %p\n", SListHead, _ReturnAddress());
        RtlRaiseStatus(STATUS_DATATYPE_MISALIGNMENT);
    }

#endif

    SListHead->Alignment = 0;

    //
    // For IA-64 we save the region number of the elements of the list in a
    // separate field.  This imposes the requirement that all elements stored
    // in the list are from the same region.

#if defined(_IA64_)

    SListHead->Region = (ULONG_PTR)SListHead & VRN_MASK;

#elif defined(_AMD64_)

    SListHead->Region = 0;

#endif

    return;
}

#endif

#endif // !defined(_WINBASE_)

#define ExInitializeSListHead InitializeSListHead

PSLIST_ENTRY
FirstEntrySList (
    IN const SLIST_HEADER *SListHead
    );

/*++

Routine Description:

    This function queries the current number of entries contained in a
    sequenced single linked list.

Arguments:

    SListHead - Supplies a pointer to the sequenced listhead which is
        be queried.

Return Value:

    The current number of entries in the sequenced singly linked list is
    returned as the function value.

--*/

#if defined(_WIN64)

#if (defined(_NTDRIVER_) || defined(_NTDDK_) || defined(_NTIFS_) || defined(_NTHAL_) || defined(_NTOSP_))

NTKERNELAPI
USHORT
ExQueryDepthSList (
    IN PSLIST_HEADER SListHead
    );

#else

__inline
USHORT
ExQueryDepthSList (
    IN PSLIST_HEADER SListHead
    )

{

    return (USHORT)(SListHead->Alignment & 0xffff);
}

#endif

#else

#define ExQueryDepthSList(_listhead_) (_listhead_)->Depth

#endif

#if defined(_WIN64)

#define ExInterlockedPopEntrySList(Head, Lock) \
    ExpInterlockedPopEntrySList(Head)

#define ExInterlockedPushEntrySList(Head, Entry, Lock) \
    ExpInterlockedPushEntrySList(Head, Entry)

#define ExInterlockedFlushSList(Head) \
    ExpInterlockedFlushSList(Head)

#if !defined(_WINBASE_)

#define InterlockedPopEntrySList(Head) \
    ExpInterlockedPopEntrySList(Head)

#define InterlockedPushEntrySList(Head, Entry) \
    ExpInterlockedPushEntrySList(Head, Entry)

#define InterlockedFlushSList(Head) \
    ExpInterlockedFlushSList(Head)

#define QueryDepthSList(Head) \
    ExQueryDepthSList(Head)

#endif // !defined(_WINBASE_)

NTKERNELAPI
PSLIST_ENTRY
ExpInterlockedPopEntrySList (
    IN PSLIST_HEADER ListHead
    );

NTKERNELAPI
PSLIST_ENTRY
ExpInterlockedPushEntrySList (
    IN PSLIST_HEADER ListHead,
    IN PSLIST_ENTRY ListEntry
    );

NTKERNELAPI
PSLIST_ENTRY
ExpInterlockedFlushSList (
    IN PSLIST_HEADER ListHead
    );

#else

#if defined(_WIN2K_COMPAT_SLIST_USAGE) && defined(_X86_)

NTKERNELAPI
PSLIST_ENTRY
FASTCALL
ExInterlockedPopEntrySList (
    IN PSLIST_HEADER ListHead,
    IN PKSPIN_LOCK Lock
    );

NTKERNELAPI
PSLIST_ENTRY
FASTCALL
ExInterlockedPushEntrySList (
    IN PSLIST_HEADER ListHead,
    IN PSLIST_ENTRY ListEntry,
    IN PKSPIN_LOCK Lock
    );

#else

#define ExInterlockedPopEntrySList(ListHead, Lock) \
    InterlockedPopEntrySList(ListHead)

#define ExInterlockedPushEntrySList(ListHead, ListEntry, Lock) \
    InterlockedPushEntrySList(ListHead, ListEntry)

#endif

NTKERNELAPI
PSLIST_ENTRY
FASTCALL
ExInterlockedFlushSList (
    IN PSLIST_HEADER ListHead
    );

#if !defined(_WINBASE_)

NTKERNELAPI
PSLIST_ENTRY
FASTCALL
InterlockedPopEntrySList (
    IN PSLIST_HEADER ListHead
    );

NTKERNELAPI
PSLIST_ENTRY
FASTCALL
InterlockedPushEntrySList (
    IN PSLIST_HEADER ListHead,
    IN PSLIST_ENTRY ListEntry
    );

#define InterlockedFlushSList(Head) \
    ExInterlockedFlushSList(Head)

#define QueryDepthSList(Head) \
    ExQueryDepthSList(Head)

#endif // !defined(_WINBASE_)

#endif // defined(_WIN64)

// end_ntddk end_wdm end_ntosp


PSLIST_ENTRY
FASTCALL
InterlockedPushListSList (
    IN PSLIST_HEADER ListHead,
    IN PSLIST_ENTRY List,
    IN PSLIST_ENTRY ListEnd,
    IN ULONG Count
    );


//
// Define interlocked lookaside list structure and allocation functions.
//

VOID
ExAdjustLookasideDepth (
    VOID
    );

// begin_ntddk begin_wdm begin_ntosp

typedef
PVOID
(*PALLOCATE_FUNCTION) (
    IN POOL_TYPE PoolType,
    IN SIZE_T NumberOfBytes,
    IN ULONG Tag
    );

typedef
VOID
(*PFREE_FUNCTION) (
    IN PVOID Buffer
    );

#if !defined(_WIN64) && (defined(_NTDDK_) || defined(_NTIFS_) || defined(_NDIS_))

typedef struct _GENERAL_LOOKASIDE {

#else

typedef struct DECLSPEC_CACHEALIGN _GENERAL_LOOKASIDE {

#endif

    SLIST_HEADER ListHead;
    USHORT Depth;
    USHORT MaximumDepth;
    ULONG TotalAllocates;
    union {
        ULONG AllocateMisses;
        ULONG AllocateHits;
    };

    ULONG TotalFrees;
    union {
        ULONG FreeMisses;
        ULONG FreeHits;
    };

    POOL_TYPE Type;
    ULONG Tag;
    ULONG Size;
    PALLOCATE_FUNCTION Allocate;
    PFREE_FUNCTION Free;
    LIST_ENTRY ListEntry;
    ULONG LastTotalAllocates;
    union {
        ULONG LastAllocateMisses;
        ULONG LastAllocateHits;
    };

    ULONG Future[2];
} GENERAL_LOOKASIDE, *PGENERAL_LOOKASIDE;

#if !defined(_WIN64) && (defined(_NTDDK_) || defined(_NTIFS_) || defined(_NDIS_))

typedef struct _NPAGED_LOOKASIDE_LIST {

#else

typedef struct DECLSPEC_CACHEALIGN _NPAGED_LOOKASIDE_LIST {

#endif

    GENERAL_LOOKASIDE L;

#if !defined(_AMD64_) && !defined(_IA64_)

    KSPIN_LOCK Lock__ObsoleteButDoNotDelete;

#endif

} NPAGED_LOOKASIDE_LIST, *PNPAGED_LOOKASIDE_LIST;

NTKERNELAPI
VOID
ExInitializeNPagedLookasideList (
    IN PNPAGED_LOOKASIDE_LIST Lookaside,
    IN PALLOCATE_FUNCTION Allocate,
    IN PFREE_FUNCTION Free,
    IN ULONG Flags,
    IN SIZE_T Size,
    IN ULONG Tag,
    IN USHORT Depth
    );

NTKERNELAPI
VOID
ExDeleteNPagedLookasideList (
    IN PNPAGED_LOOKASIDE_LIST Lookaside
    );

__inline
PVOID
ExAllocateFromNPagedLookasideList(
    IN PNPAGED_LOOKASIDE_LIST Lookaside
    )

/*++

Routine Description:

    This function removes (pops) the first entry from the specified
    nonpaged lookaside list.

Arguments:

    Lookaside - Supplies a pointer to a nonpaged lookaside list structure.

Return Value:

    If an entry is removed from the specified lookaside list, then the
    address of the entry is returned as the function value. Otherwise,
    NULL is returned.

--*/

{

    PVOID Entry;

    Lookaside->L.TotalAllocates += 1;

#if defined(_WIN2K_COMPAT_SLIST_USAGE) && defined(_X86_)

    Entry = ExInterlockedPopEntrySList(&Lookaside->L.ListHead,
                                       &Lookaside->Lock__ObsoleteButDoNotDelete);


#else

    Entry = InterlockedPopEntrySList(&Lookaside->L.ListHead);

#endif

    if (Entry == NULL) {
        Lookaside->L.AllocateMisses += 1;
        Entry = (Lookaside->L.Allocate)(Lookaside->L.Type,
                                        Lookaside->L.Size,
                                        Lookaside->L.Tag);
    }

    return Entry;
}

__inline
VOID
ExFreeToNPagedLookasideList(
    IN PNPAGED_LOOKASIDE_LIST Lookaside,
    IN PVOID Entry
    )

/*++

Routine Description:

    This function inserts (pushes) the specified entry into the specified
    nonpaged lookaside list.

Arguments:

    Lookaside - Supplies a pointer to a nonpaged lookaside list structure.

    Entry - Supples a pointer to the entry that is inserted in the
        lookaside list.

Return Value:

    None.

--*/

{

    Lookaside->L.TotalFrees += 1;
    if (ExQueryDepthSList(&Lookaside->L.ListHead) >= Lookaside->L.Depth) {
        Lookaside->L.FreeMisses += 1;
        (Lookaside->L.Free)(Entry);

    } else {

#if defined(_WIN2K_COMPAT_SLIST_USAGE) && defined(_X86_)

        ExInterlockedPushEntrySList(&Lookaside->L.ListHead,
                                    (PSLIST_ENTRY)Entry,
                                    &Lookaside->Lock__ObsoleteButDoNotDelete);

#else

        InterlockedPushEntrySList(&Lookaside->L.ListHead,
                                  (PSLIST_ENTRY)Entry);

#endif

    }
    return;
}


typedef struct _PCI_SLOT_NUMBER {
    union {
        struct {
            ULONG   DeviceNumber:5;
            ULONG   FunctionNumber:3;
            ULONG   Reserved:24;
        } bits;
        ULONG   AsULONG;
    } u;
} PCI_SLOT_NUMBER, *PPCI_SLOT_NUMBER;


#define PCI_TYPE0_ADDRESSES             6
#define PCI_TYPE1_ADDRESSES             2
#define PCI_TYPE2_ADDRESSES             5

typedef struct _PCI_COMMON_CONFIG {
    USHORT  VendorID;                   // (ro)
    USHORT  DeviceID;                   // (ro)
    USHORT  Command;                    // Device control
    USHORT  Status;
    UCHAR   RevisionID;                 // (ro)
    UCHAR   ProgIf;                     // (ro)
    UCHAR   SubClass;                   // (ro)
    UCHAR   BaseClass;                  // (ro)
    UCHAR   CacheLineSize;              // (ro+)
    UCHAR   LatencyTimer;               // (ro+)
    UCHAR   HeaderType;                 // (ro)
    UCHAR   BIST;                       // Built in self test

    union {
        struct _PCI_HEADER_TYPE_0 {
            ULONG   BaseAddresses[PCI_TYPE0_ADDRESSES];
            ULONG   CIS;
            USHORT  SubVendorID;
            USHORT  SubSystemID;
            ULONG   ROMBaseAddress;
            UCHAR   CapabilitiesPtr;
            UCHAR   Reserved1[3];
            ULONG   Reserved2;
            UCHAR   InterruptLine;      //
            UCHAR   InterruptPin;       // (ro)
            UCHAR   MinimumGrant;       // (ro)
            UCHAR   MaximumLatency;     // (ro)
        } type0;


    } u;

    UCHAR   DeviceSpecific[192];

} PCI_COMMON_CONFIG, *PPCI_COMMON_CONFIG;


#define PCI_COMMON_HDR_LENGTH (FIELD_OFFSET (PCI_COMMON_CONFIG, DeviceSpecific))

#define PCI_MAX_DEVICES                     32
#define PCI_MAX_FUNCTION                    8
#define PCI_MAX_BRIDGE_NUMBER               0xFF

#define PCI_INVALID_VENDORID                0xFFFF

//
// Bit encodings for  PCI_COMMON_CONFIG.HeaderType
//

#define PCI_MULTIFUNCTION                   0x80
#define PCI_DEVICE_TYPE                     0x00
#define PCI_BRIDGE_TYPE                     0x01
#define PCI_CARDBUS_BRIDGE_TYPE             0x02

#define PCI_CONFIGURATION_TYPE(PciData) \
    (((PPCI_COMMON_CONFIG)(PciData))->HeaderType & ~PCI_MULTIFUNCTION)

#define PCI_MULTIFUNCTION_DEVICE(PciData) \
    ((((PPCI_COMMON_CONFIG)(PciData))->HeaderType & PCI_MULTIFUNCTION) != 0)

//
// Bit encodings for PCI_COMMON_CONFIG.Command
//

#define PCI_ENABLE_IO_SPACE                 0x0001
#define PCI_ENABLE_MEMORY_SPACE             0x0002
#define PCI_ENABLE_BUS_MASTER               0x0004
#define PCI_ENABLE_SPECIAL_CYCLES           0x0008
#define PCI_ENABLE_WRITE_AND_INVALIDATE     0x0010
#define PCI_ENABLE_VGA_COMPATIBLE_PALETTE   0x0020
#define PCI_ENABLE_PARITY                   0x0040  // (ro+)
#define PCI_ENABLE_WAIT_CYCLE               0x0080  // (ro+)
#define PCI_ENABLE_SERR                     0x0100  // (ro+)
#define PCI_ENABLE_FAST_BACK_TO_BACK        0x0200  // (ro)

//
// Bit encodings for PCI_COMMON_CONFIG.Status
//

#define PCI_STATUS_CAPABILITIES_LIST        0x0010  // (ro)
#define PCI_STATUS_66MHZ_CAPABLE            0x0020  // (ro)
#define PCI_STATUS_UDF_SUPPORTED            0x0040  // (ro)
#define PCI_STATUS_FAST_BACK_TO_BACK        0x0080  // (ro)
#define PCI_STATUS_DATA_PARITY_DETECTED     0x0100
#define PCI_STATUS_DEVSEL                   0x0600  // 2 bits wide
#define PCI_STATUS_SIGNALED_TARGET_ABORT    0x0800
#define PCI_STATUS_RECEIVED_TARGET_ABORT    0x1000
#define PCI_STATUS_RECEIVED_MASTER_ABORT    0x2000
#define PCI_STATUS_SIGNALED_SYSTEM_ERROR    0x4000
#define PCI_STATUS_DETECTED_PARITY_ERROR    0x8000

//
// The NT PCI Driver uses a WhichSpace parameter on its CONFIG_READ/WRITE
// routines.   The following values are defined-
//

#define PCI_WHICHSPACE_CONFIG               0x0
#define PCI_WHICHSPACE_ROM                  0x52696350

// end_wdm
//
// PCI Capability IDs
//

#define PCI_CAPABILITY_ID_POWER_MANAGEMENT  0x01
#define PCI_CAPABILITY_ID_AGP               0x02
#define PCI_CAPABILITY_ID_MSI               0x05

//
// All PCI Capability structures have the following header.
//
// CapabilityID is used to identify the type of the structure (is
// one of the PCI_CAPABILITY_ID values above.
//
// Next is the offset in PCI Configuration space (0x40 - 0xfc) of the
// next capability structure in the list, or 0x00 if there are no more
// entries.
//
typedef struct _PCI_CAPABILITIES_HEADER {
    UCHAR   CapabilityID;
    UCHAR   Next;
} PCI_CAPABILITIES_HEADER, *PPCI_CAPABILITIES_HEADER;

//
// Power Management Capability
//

typedef struct _PCI_PMC {
    UCHAR       Version:3;
    UCHAR       PMEClock:1;
    UCHAR       Rsvd1:1;
    UCHAR       DeviceSpecificInitialization:1;
    UCHAR       Rsvd2:2;
    struct _PM_SUPPORT {
        UCHAR   Rsvd2:1;
        UCHAR   D1:1;
        UCHAR   D2:1;
        UCHAR   PMED0:1;
        UCHAR   PMED1:1;
        UCHAR   PMED2:1;
        UCHAR   PMED3Hot:1;
        UCHAR   PMED3Cold:1;
    } Support;
} PCI_PMC, *PPCI_PMC;

typedef struct _PCI_PMCSR {
    USHORT      PowerState:2;
    USHORT      Rsvd1:6;
    USHORT      PMEEnable:1;
    USHORT      DataSelect:4;
    USHORT      DataScale:2;
    USHORT      PMEStatus:1;
} PCI_PMCSR, *PPCI_PMCSR;


typedef struct _PCI_PMCSR_BSE {
    UCHAR       Rsvd1:6;
    UCHAR       D3HotSupportsStopClock:1;       // B2_B3#
    UCHAR       BusPowerClockControlEnabled:1;  // BPCC_EN
} PCI_PMCSR_BSE, *PPCI_PMCSR_BSE;


typedef struct _PCI_PM_CAPABILITY {

    PCI_CAPABILITIES_HEADER Header;

    //
    // Power Management Capabilities (Offset = 2)
    //

    union {
        PCI_PMC         Capabilities;
        USHORT          AsUSHORT;
    } PMC;

    //
    // Power Management Control/Status (Offset = 4)
    //

    union {
        PCI_PMCSR       ControlStatus;
        USHORT          AsUSHORT;
    } PMCSR;

    //
    // PMCSR PCI-PCI Bridge Support Extensions
    //

    union {
        PCI_PMCSR_BSE   BridgeSupport;
        UCHAR           AsUCHAR;
    } PMCSR_BSE;

    //
    // Optional read only 8 bit Data register.  Contents controlled by
    // DataSelect and DataScale in ControlStatus.
    //

    UCHAR   Data;

} PCI_PM_CAPABILITY, *PPCI_PM_CAPABILITY;

//
// AGP Capability
//

typedef struct _PCI_AGP_CAPABILITY {

    PCI_CAPABILITIES_HEADER Header;

    USHORT  Minor:4;
    USHORT  Major:4;
    USHORT  Rsvd1:8;

    struct  _PCI_AGP_STATUS {
        ULONG   Rate:3;
        ULONG   Rsvd1:1;
        ULONG   FastWrite:1;
        ULONG   FourGB:1;
        ULONG   Rsvd2:3;
        ULONG   SideBandAddressing:1;                   // SBA
        ULONG   Rsvd3:14;
        ULONG   RequestQueueDepthMaximum:8;             // RQ
    } AGPStatus;

    struct  _PCI_AGP_COMMAND {
        ULONG   Rate:3;
        ULONG   Rsvd1:1;
        ULONG   FastWriteEnable:1;
        ULONG   FourGBEnable:1;
        ULONG   Rsvd2:2;
        ULONG   AGPEnable:1;
        ULONG   SBAEnable:1;
        ULONG   Rsvd3:14;
        ULONG   RequestQueueDepth:8;
    } AGPCommand;

} PCI_AGP_CAPABILITY, *PPCI_AGP_CAPABILITY;

#define PCI_AGP_RATE_1X     0x1
#define PCI_AGP_RATE_2X     0x2
#define PCI_AGP_RATE_4X     0x4

//
// MSI (Message Signalled Interrupts) Capability
//

typedef struct _PCI_MSI_CAPABILITY {

      PCI_CAPABILITIES_HEADER Header;

      struct _PCI_MSI_MESSAGE_CONTROL {
         USHORT  MSIEnable:1;
         USHORT  MultipleMessageCapable:3;
         USHORT  MultipleMessageEnable:3;
         USHORT  CapableOf64Bits:1;
         USHORT  Reserved:8;
      } MessageControl;

      union {
            struct _PCI_MSI_MESSAGE_ADDRESS {
               ULONG_PTR Reserved:2;              // always zero, DWORD aligned address
               ULONG_PTR Address:30;
            } Register;
            ULONG_PTR Raw;
      } MessageAddress;

      //
      // The rest of the Capability structure differs depending on whether
      // 32bit or 64bit addressing is being used.
      //
      // (The CapableOf64Bits bit above determines this)
      //

      union {

         // For 64 bit devices

         struct _PCI_MSI_64BIT_DATA {
            ULONG MessageUpperAddress;
            USHORT MessageData;
         } Bit64;

         // For 32 bit devices

         struct _PCI_MSI_32BIT_DATA {
            USHORT MessageData;
            ULONG Unused;
         } Bit32;
      } Data;

} PCI_MSI_CAPABILITY, *PPCI_PCI_CAPABILITY;

// begin_wdm
//
// Base Class Code encodings for Base Class (from PCI spec rev 2.1).
//

#define PCI_CLASS_PRE_20                    0x00
#define PCI_CLASS_MASS_STORAGE_CTLR         0x01
#define PCI_CLASS_NETWORK_CTLR              0x02
#define PCI_CLASS_DISPLAY_CTLR              0x03
#define PCI_CLASS_MULTIMEDIA_DEV            0x04
#define PCI_CLASS_MEMORY_CTLR               0x05
#define PCI_CLASS_BRIDGE_DEV                0x06
#define PCI_CLASS_SIMPLE_COMMS_CTLR         0x07
#define PCI_CLASS_BASE_SYSTEM_DEV           0x08
#define PCI_CLASS_INPUT_DEV                 0x09
#define PCI_CLASS_DOCKING_STATION           0x0a
#define PCI_CLASS_PROCESSOR                 0x0b
#define PCI_CLASS_SERIAL_BUS_CTLR           0x0c
#define PCI_CLASS_WIRELESS_CTLR             0x0d
#define PCI_CLASS_INTELLIGENT_IO_CTLR       0x0e
#define PCI_CLASS_SATELLITE_COMMS_CTLR      0x0f
#define PCI_CLASS_ENCRYPTION_DECRYPTION     0x10
#define PCI_CLASS_DATA_ACQ_SIGNAL_PROC      0x11

// 0d thru fe reserved

#define PCI_CLASS_NOT_DEFINED               0xff

//
// Sub Class Code encodings (PCI rev 2.1).
//

// Class 00 - PCI_CLASS_PRE_20

#define PCI_SUBCLASS_PRE_20_NON_VGA         0x00
#define PCI_SUBCLASS_PRE_20_VGA             0x01

// Class 01 - PCI_CLASS_MASS_STORAGE_CTLR

#define PCI_SUBCLASS_MSC_SCSI_BUS_CTLR      0x00
#define PCI_SUBCLASS_MSC_IDE_CTLR           0x01
#define PCI_SUBCLASS_MSC_FLOPPY_CTLR        0x02
#define PCI_SUBCLASS_MSC_IPI_CTLR           0x03
#define PCI_SUBCLASS_MSC_RAID_CTLR          0x04
#define PCI_SUBCLASS_MSC_OTHER              0x80

// Class 02 - PCI_CLASS_NETWORK_CTLR

#define PCI_SUBCLASS_NET_ETHERNET_CTLR      0x00
#define PCI_SUBCLASS_NET_TOKEN_RING_CTLR    0x01
#define PCI_SUBCLASS_NET_FDDI_CTLR          0x02
#define PCI_SUBCLASS_NET_ATM_CTLR           0x03
#define PCI_SUBCLASS_NET_ISDN_CTLR          0x04
#define PCI_SUBCLASS_NET_OTHER              0x80

// Class 03 - PCI_CLASS_DISPLAY_CTLR

// N.B. Sub Class 00 could be VGA or 8514 depending on Interface byte

#define PCI_SUBCLASS_VID_VGA_CTLR           0x00
#define PCI_SUBCLASS_VID_XGA_CTLR           0x01
#define PCI_SUBLCASS_VID_3D_CTLR            0x02
#define PCI_SUBCLASS_VID_OTHER              0x80

// Class 04 - PCI_CLASS_MULTIMEDIA_DEV

#define PCI_SUBCLASS_MM_VIDEO_DEV           0x00
#define PCI_SUBCLASS_MM_AUDIO_DEV           0x01
#define PCI_SUBCLASS_MM_TELEPHONY_DEV       0x02
#define PCI_SUBCLASS_MM_OTHER               0x80

// Class 05 - PCI_CLASS_MEMORY_CTLR

#define PCI_SUBCLASS_MEM_RAM                0x00
#define PCI_SUBCLASS_MEM_FLASH              0x01
#define PCI_SUBCLASS_MEM_OTHER              0x80

// Class 06 - PCI_CLASS_BRIDGE_DEV

#define PCI_SUBCLASS_BR_HOST                0x00
#define PCI_SUBCLASS_BR_ISA                 0x01
#define PCI_SUBCLASS_BR_EISA                0x02
#define PCI_SUBCLASS_BR_MCA                 0x03
#define PCI_SUBCLASS_BR_PCI_TO_PCI          0x04
#define PCI_SUBCLASS_BR_PCMCIA              0x05
#define PCI_SUBCLASS_BR_NUBUS               0x06
#define PCI_SUBCLASS_BR_CARDBUS             0x07
#define PCI_SUBCLASS_BR_RACEWAY             0x08
#define PCI_SUBCLASS_BR_OTHER               0x80

// Class 07 - PCI_CLASS_SIMPLE_COMMS_CTLR

// N.B. Sub Class 00 and 01 additional info in Interface byte

#define PCI_SUBCLASS_COM_SERIAL             0x00
#define PCI_SUBCLASS_COM_PARALLEL           0x01
#define PCI_SUBCLASS_COM_MULTIPORT          0x02
#define PCI_SUBCLASS_COM_MODEM              0x03
#define PCI_SUBCLASS_COM_OTHER              0x80

// Class 08 - PCI_CLASS_BASE_SYSTEM_DEV

// N.B. See Interface byte for additional info.

#define PCI_SUBCLASS_SYS_INTERRUPT_CTLR     0x00
#define PCI_SUBCLASS_SYS_DMA_CTLR           0x01
#define PCI_SUBCLASS_SYS_SYSTEM_TIMER       0x02
#define PCI_SUBCLASS_SYS_REAL_TIME_CLOCK    0x03
#define PCI_SUBCLASS_SYS_GEN_HOTPLUG_CTLR   0x04
#define PCI_SUBCLASS_SYS_OTHER              0x80

// Class 09 - PCI_CLASS_INPUT_DEV

#define PCI_SUBCLASS_INP_KEYBOARD           0x00
#define PCI_SUBCLASS_INP_DIGITIZER          0x01
#define PCI_SUBCLASS_INP_MOUSE              0x02
#define PCI_SUBCLASS_INP_SCANNER            0x03
#define PCI_SUBCLASS_INP_GAMEPORT           0x04
#define PCI_SUBCLASS_INP_OTHER              0x80

// Class 0a - PCI_CLASS_DOCKING_STATION

#define PCI_SUBCLASS_DOC_GENERIC            0x00
#define PCI_SUBCLASS_DOC_OTHER              0x80

// Class 0b - PCI_CLASS_PROCESSOR

#define PCI_SUBCLASS_PROC_386               0x00
#define PCI_SUBCLASS_PROC_486               0x01
#define PCI_SUBCLASS_PROC_PENTIUM           0x02
#define PCI_SUBCLASS_PROC_ALPHA             0x10
#define PCI_SUBCLASS_PROC_POWERPC           0x20
#define PCI_SUBCLASS_PROC_COPROCESSOR       0x40

// Class 0c - PCI_CLASS_SERIAL_BUS_CTLR

#define PCI_SUBCLASS_SB_IEEE1394            0x00
#define PCI_SUBCLASS_SB_ACCESS              0x01
#define PCI_SUBCLASS_SB_SSA                 0x02
#define PCI_SUBCLASS_SB_USB                 0x03
#define PCI_SUBCLASS_SB_FIBRE_CHANNEL       0x04
#define PCI_SUBCLASS_SB_SMBUS               0x05

// Class 0d - PCI_CLASS_WIRELESS_CTLR

#define PCI_SUBCLASS_WIRELESS_IRDA          0x00
#define PCI_SUBCLASS_WIRELESS_CON_IR        0x01
#define PCI_SUBCLASS_WIRELESS_RF            0x10
#define PCI_SUBCLASS_WIRELESS_OTHER         0x80

// Class 0e - PCI_CLASS_INTELLIGENT_IO_CTLR

#define PCI_SUBCLASS_INTIO_I2O              0x00

// Class 0f - PCI_CLASS_SATELLITE_CTLR

#define PCI_SUBCLASS_SAT_TV                 0x01
#define PCI_SUBCLASS_SAT_AUDIO              0x02
#define PCI_SUBCLASS_SAT_VOICE              0x03
#define PCI_SUBCLASS_SAT_DATA               0x04

// Class 10 - PCI_CLASS_ENCRYPTION_DECRYPTION

#define PCI_SUBCLASS_CRYPTO_NET_COMP        0x00
#define PCI_SUBCLASS_CRYPTO_ENTERTAINMENT   0x10
#define PCI_SUBCLASS_CRYPTO_OTHER           0x80

// Class 11 - PCI_CLASS_DATA_ACQ_SIGNAL_PROC

#define PCI_SUBCLASS_DASP_DPIO              0x00
#define PCI_SUBCLASS_DASP_OTHER             0x80




typedef enum _MM_PAGE_PRIORITY {
    LowPagePriority,
    NormalPagePriority = 16,
    HighPagePriority = 32
} MM_PAGE_PRIORITY;


#else // BINARY_COMPATIBLE && !NDIS_WDM

#if (!BINARY_COMPATIBLE)

//
// BINARY_COMPATIBLE = 0 and NDIS_WDM = 1 then use ntddk.h
// BINARY_COMPATIBLE = 0 and NDIS_WDM = 0 then use ntddk.h
//
//
// The definitions available in ntddk.h must not be used directly by non-WDM miniport drivers.
//

#include <ntddk.h>

#else // !BINARY_COMPATIBLE

//
// BINARY_COMPATIBLE = 1 and NDIS_WDM = 1 then use wdm.h
//

#include <wdm.h>

#endif  // else !BINARY_COMPATIBLE

#endif //  else BINARY_COMPATIBLE && !NDIS_WDM
//
// END INTERNAL DEFINITIONS
//
// The following definitions may be used by NDIS drivers, except as noted.
//

#ifndef __NET_PNP__
#define __NET_PNP__

//
//  PnP and PM event codes that can be indicated up to transports
//  and clients.
//
typedef enum _NET_PNP_EVENT_CODE
{
    NetEventSetPower,
    NetEventQueryPower,
    NetEventQueryRemoveDevice,
    NetEventCancelRemoveDevice,
    NetEventReconfigure,
    NetEventBindList,
    NetEventBindsComplete,
    NetEventPnPCapabilities,
    NetEventMaximum
} NET_PNP_EVENT_CODE, *PNET_PNP_EVENT_CODE;

//
//  Networking PnP event indication structure.
//
typedef struct _NET_PNP_EVENT
{
    //
    //  Event code describing action to take.
    //
    NET_PNP_EVENT_CODE  NetEvent;

    //
    //  Event specific data.
    //
    PVOID               Buffer;

    //
    //  Length of event specific data.
    //
    ULONG               BufferLength;

    //
    //  Reserved values are for use by respective components only.
    //
    //  Note: these reserved areas must be pointer aligned.
    //  

    ULONG_PTR           NdisReserved[4];
    ULONG_PTR           TransportReserved[4];
    ULONG_PTR           TdiReserved[4];
    ULONG_PTR           TdiClientReserved[4];
} NET_PNP_EVENT, *PNET_PNP_EVENT;

//
//  The following structure defines the device power states.
//
typedef enum _NET_DEVICE_POWER_STATE
{
    NetDeviceStateUnspecified = 0,
    NetDeviceStateD0,
    NetDeviceStateD1,
    NetDeviceStateD2,
    NetDeviceStateD3,
    NetDeviceStateMaximum
} NET_DEVICE_POWER_STATE, *PNET_DEVICE_POWER_STATE;

#endif // __NET_PNP__

//
// Indicate that we're building for NT. NDIS_NT is always used for
// miniport builds.
//

#define NDIS_NT 1

#if defined(NDIS_DOS)
#undef NDIS_DOS
#endif


//
// Define status codes and event log codes.
//

#include <ntstatus.h>
#include <netevent.h>

//
// Define a couple of extra types.
//

#if !defined(_WINDEF_)      // these are defined in windows.h too
typedef signed int INT, *PINT;
typedef unsigned int UINT, *PUINT;
#endif

typedef UNICODE_STRING NDIS_STRING, *PNDIS_STRING;


//
// Portability extentions
//

#define NDIS_INIT_FUNCTION(_F)      alloc_text(INIT,_F)
#define NDIS_PAGABLE_FUNCTION(_F)   alloc_text(PAGE,_F)
#define NDIS_PAGEABLE_FUNCTION(_F)  alloc_text(PAGE,_F)

//
// This file contains the definition of an NDIS_OID as
// well as #defines for all the current OID values.
//

//
// Define NDIS_STATUS and NDIS_HANDLE here
//
typedef PVOID NDIS_HANDLE, *PNDIS_HANDLE;

typedef int NDIS_STATUS, *PNDIS_STATUS; // note default size


//
// for Miniports versions 5.0 and up, provide a consistent way to match
// Ndis version in their characteristics with their makefile defines
//
#if (!defined(NDIS_MINIPORT_MAJOR_VERSION) && !defined(NDIS_MINIPORT_MINOR_VERSION))
#if (defined(NDIS51_MINIPORT))
#define NDIS_MINIPORT_MAJOR_VERSION 5
#define NDIS_MINIPORT_MINOR_VERSION 1
#elif (defined(NDIS50_MINIPORT))
#define NDIS_MINIPORT_MAJOR_VERSION 5
#define NDIS_MINIPORT_MINOR_VERSION 0
#endif
#endif

//
// for protocol versions 5.0 and up, provide a consistent way to match
// Ndis version in their characteristics with their makefile defines
//
#if (!defined(NDIS_PROTOCOL_MAJOR_VERSION) && !defined(NDIS_PROTOCOL_MINOR_VERSION))
#if (defined(NDIS51))
#define NDIS_PROTOCOL_MAJOR_VERSION 5
#define NDIS_PROTOCOL_MINOR_VERSION 1
#elif (defined(NDIS50))
#define NDIS_PROTOCOL_MAJOR_VERSION 5
#define NDIS_PROTOCOL_MINOR_VERSION 0
#endif
#endif


#include <ntddndis.h>



//
// Ndis defines for configuration manager data structures
//
typedef CM_MCA_POS_DATA NDIS_MCA_POS_DATA, *PNDIS_MCA_POS_DATA;
typedef CM_EISA_SLOT_INFORMATION NDIS_EISA_SLOT_INFORMATION, *PNDIS_EISA_SLOT_INFORMATION;
typedef CM_EISA_FUNCTION_INFORMATION NDIS_EISA_FUNCTION_INFORMATION, *PNDIS_EISA_FUNCTION_INFORMATION;

//
// Define an exported function.
//
#if defined(NDIS_WRAPPER)
#define EXPORT
#else
#define EXPORT DECLSPEC_IMPORT
#endif

//
// Memory manipulation functions.
//
#define NdisMoveMemory(Destination, Source, Length) RtlCopyMemory(Destination, Source, Length)
#define NdisZeroMemory(Destination, Length)         RtlZeroMemory(Destination, Length)
#define NdisEqualMemory(Source1, Source2, Length)   RtlEqualMemory(Source1, Source2, Length)
#define NdisFillMemory(Destination, Length, Fill)   RtlFillMemory(Destination, Length, Fill)
#define NdisRetrieveUlong(Destination, Source)      RtlRetrieveUlong(Destination, Source)
#define NdisStoreUlong(Destination, Value)          RtlStoreUlong(Destination, Value)

#define NDIS_STRING_CONST(x)    {sizeof(L##x)-2, sizeof(L##x), L##x}

//
// On a RISC machine, I/O mapped memory can't be accessed with
// the Rtl routines.
//
#if defined(_M_IX86) || defined(_M_AMD64)

#define NdisMoveMappedMemory(Destination,Source,Length) RtlCopyMemory(Destination,Source,Length)
#define NdisZeroMappedMemory(Destination,Length)        RtlZeroMemory(Destination,Length)

#elif defined(_M_IA64)

#define NdisMoveMappedMemory(Destination,Source,Length)                     \
{                                                                           \
    PUCHAR _Src = (Source);                                                 \
    PUCHAR _Dest = (Destination);                                           \
    PUCHAR _End = _Dest + (Length);                                         \
    while (_Dest < _End)                                                    \
    {                                                                       \
        *_Dest++ = *_Src++;                                                 \
    }                                                                       \
}

#define NdisZeroMappedMemory(Destination,Length)                            \
{                                                                           \
    PUCHAR _Dest = (Destination);                                           \
    PUCHAR _End = _Dest + (Length);                                         \
    while (_Dest < _End)                                                    \
    {                                                                       \
        *_Dest++ = 0;                                                       \
    }                                                                       \
}
#endif


#define NdisMoveToMappedMemory(Destination,Source,Length)                   \
                            NdisMoveMappedMemory(Destination,Source,Length)
#define NdisMoveFromMappedMemory(Destination,Source,Length)                 \
                            NdisMoveMappedMemory(Destination,Source,Length)


//
// definition of the basic spin lock structure
//

typedef struct _NDIS_SPIN_LOCK
{
    KSPIN_LOCK  SpinLock;
    KIRQL       OldIrql;
} NDIS_SPIN_LOCK, * PNDIS_SPIN_LOCK;


//
// definition of the ndis event structure
//
typedef struct _NDIS_EVENT
{
    KEVENT      Event;
} NDIS_EVENT, *PNDIS_EVENT;

typedef VOID    (*NDIS_PROC)(struct _NDIS_WORK_ITEM *, PVOID);

//
// Definition of an ndis work-item
//
typedef struct _NDIS_WORK_ITEM
{
    PVOID           Context;
    NDIS_PROC       Routine;
    UCHAR           WrapperReserved[8*sizeof(PVOID)];
} NDIS_WORK_ITEM, *PNDIS_WORK_ITEM;

#define NdisInterruptLatched            Latched
#define NdisInterruptLevelSensitive     LevelSensitive
typedef KINTERRUPT_MODE NDIS_INTERRUPT_MODE, *PNDIS_INTERRUPT_MODE;

//
// Configuration definitions
//

//
// Possible data types
//

typedef enum _NDIS_PARAMETER_TYPE
{
    NdisParameterInteger,
    NdisParameterHexInteger,
    NdisParameterString,
    NdisParameterMultiString,
    NdisParameterBinary
} NDIS_PARAMETER_TYPE, *PNDIS_PARAMETER_TYPE;

typedef struct
{
    USHORT          Length;
    PVOID           Buffer;
} BINARY_DATA;

//
// To store configuration information
//
typedef struct _NDIS_CONFIGURATION_PARAMETER
{
    NDIS_PARAMETER_TYPE ParameterType;
    union
    {
        ULONG           IntegerData;
        NDIS_STRING     StringData;
        BINARY_DATA     BinaryData;
    } ParameterData;
} NDIS_CONFIGURATION_PARAMETER, *PNDIS_CONFIGURATION_PARAMETER;


//
// Definitions for the "ProcessorType" keyword
//
typedef enum _NDIS_PROCESSOR_TYPE
{
    NdisProcessorX86,
    NdisProcessorMips,
    NdisProcessorAlpha,
    NdisProcessorPpc,
    NdisProcessorAmd64
} NDIS_PROCESSOR_TYPE, *PNDIS_PROCESSOR_TYPE;

//
// Definitions for the "Environment" keyword
//
typedef enum _NDIS_ENVIRONMENT_TYPE
{
    NdisEnvironmentWindows,
    NdisEnvironmentWindowsNt
} NDIS_ENVIRONMENT_TYPE, *PNDIS_ENVIRONMENT_TYPE;


//
// Possible Hardware Architecture. Define these to
// match the HAL INTERFACE_TYPE enum.
//
typedef enum _NDIS_INTERFACE_TYPE
{
    NdisInterfaceInternal = Internal,
    NdisInterfaceIsa = Isa,
    NdisInterfaceEisa = Eisa,
    NdisInterfaceMca = MicroChannel,
    NdisInterfaceTurboChannel = TurboChannel,
    NdisInterfacePci = PCIBus,
    NdisInterfacePcMcia = PCMCIABus,
    NdisInterfaceCBus = CBus,
    NdisInterfaceMPIBus = MPIBus,
    NdisInterfaceMPSABus = MPSABus,
    NdisInterfaceProcessorInternal = ProcessorInternal,
    NdisInterfaceInternalPowerBus = InternalPowerBus,
    NdisInterfacePNPISABus = PNPISABus,
    NdisInterfacePNPBus = PNPBus,
    NdisMaximumInterfaceType
} NDIS_INTERFACE_TYPE, *PNDIS_INTERFACE_TYPE;

//
// Definition for shutdown handler
//

typedef
VOID
(*ADAPTER_SHUTDOWN_HANDLER) (
    IN  PVOID ShutdownContext
    );

//
// Stuff for PCI configuring
//

typedef CM_PARTIAL_RESOURCE_LIST NDIS_RESOURCE_LIST, *PNDIS_RESOURCE_LIST;


//
// The structure passed up on a WAN_LINE_UP indication
//

typedef struct _NDIS_WAN_LINE_UP
{
    IN ULONG                LinkSpeed;          // 100 bps units
    IN ULONG                MaximumTotalSize;   // suggested max for send packets
    IN NDIS_WAN_QUALITY     Quality;
    IN USHORT               SendWindow;         // suggested by the MAC
    IN UCHAR                RemoteAddress[6];
    IN OUT UCHAR            LocalAddress[6];
    IN ULONG                ProtocolBufferLength;   // Length of protocol info buffer
    IN PUCHAR               ProtocolBuffer;     // Information used by protocol
    IN USHORT               ProtocolType;       // Protocol ID
    IN OUT NDIS_STRING      DeviceName;
} NDIS_WAN_LINE_UP, *PNDIS_WAN_LINE_UP;

//
// The structure passed up on a WAN_LINE_DOWN indication
//

typedef struct _NDIS_WAN_LINE_DOWN
{
    IN UCHAR    RemoteAddress[6];
    IN UCHAR    LocalAddress[6];
} NDIS_WAN_LINE_DOWN, *PNDIS_WAN_LINE_DOWN;

//
// The structure passed up on a WAN_FRAGMENT indication
//

typedef struct _NDIS_WAN_FRAGMENT
{
    IN UCHAR    RemoteAddress[6];
    IN UCHAR    LocalAddress[6];
} NDIS_WAN_FRAGMENT, *PNDIS_WAN_FRAGMENT;

//
// The structure passed up on a WAN_GET_STATS indication
//

typedef struct _NDIS_WAN_GET_STATS
{
    IN  UCHAR   LocalAddress[6];
    OUT ULONG   BytesSent;
    OUT ULONG   BytesRcvd;
    OUT ULONG   FramesSent;
    OUT ULONG   FramesRcvd;
    OUT ULONG   CRCErrors;                      // Serial-like info only
    OUT ULONG   TimeoutErrors;                  // Serial-like info only
    OUT ULONG   AlignmentErrors;                // Serial-like info only
    OUT ULONG   SerialOverrunErrors;            // Serial-like info only
    OUT ULONG   FramingErrors;                  // Serial-like info only
    OUT ULONG   BufferOverrunErrors;            // Serial-like info only
    OUT ULONG   BytesTransmittedUncompressed;   // Compression info only
    OUT ULONG   BytesReceivedUncompressed;      // Compression info only
    OUT ULONG   BytesTransmittedCompressed;     // Compression info only
    OUT ULONG   BytesReceivedCompressed;        // Compression info only
} NDIS_WAN_GET_STATS, *PNDIS_WAN_GET_STATS;


//
// DMA Channel information
//
typedef struct _NDIS_DMA_DESCRIPTION
{
    BOOLEAN     DemandMode;
    BOOLEAN     AutoInitialize;
    BOOLEAN     DmaChannelSpecified;
    DMA_WIDTH   DmaWidth;
    DMA_SPEED   DmaSpeed;
    ULONG       DmaPort;
    ULONG       DmaChannel;
} NDIS_DMA_DESCRIPTION, *PNDIS_DMA_DESCRIPTION;

//
// Internal structure representing an NDIS DMA channel
//
typedef struct _NDIS_DMA_BLOCK
{
    PVOID               MapRegisterBase;
    KEVENT              AllocationEvent;
    PVOID               SystemAdapterObject;
    BOOLEAN             InProgress;
} NDIS_DMA_BLOCK, *PNDIS_DMA_BLOCK;



#if defined(NDIS_WRAPPER)
//
// definitions for PnP state
//

typedef enum _NDIS_PNP_DEVICE_STATE
{
    NdisPnPDeviceAdded,
    NdisPnPDeviceStarted,
    NdisPnPDeviceQueryStopped,
    NdisPnPDeviceStopped,
    NdisPnPDeviceQueryRemoved,
    NdisPnPDeviceRemoved,
    NdisPnPDeviceSurpriseRemoved
} NDIS_PNP_DEVICE_STATE;

//
// flags to use in PnPCapabilities Flag
//
#define NDIS_DEVICE_NOT_STOPPABLE                   0x00000001      // the debvice is not stoppable i.e. ISA
#define NDIS_DEVICE_NOT_REMOVEABLE                  0x00000002      // the device can not be safely removed
#define NDIS_DEVICE_NOT_SUSPENDABLE                 0x00000004      // the device can not be safely suspended
#define NDIS_DEVICE_DISABLE_PM                      0x00000008      // disable all PM features
#define NDIS_DEVICE_DISABLE_WAKE_UP                 0x00000010      // disable device waking up the system
#define NDIS_DEVICE_DISABLE_WAKE_ON_RECONNECT       0x00000020      // disable device waking up the -system- due to a cable re-connect
#define NDIS_DEVICE_RESERVED                        0x00000040      // should not be used
#define NDIS_DEVICE_DISABLE_WAKE_ON_MAGIC_PACKET    0x00000080      // disable device waking up the -system- due to a magic packet
#define NDIS_DEVICE_DISABLE_WAKE_ON_PATTERN_MATCH   0x00000100      // disable device waking up the -system- due to a pattern match



#endif // NDIS_WRAPPER defined

//
// Ndis Buffer is actually an Mdl
//
typedef MDL NDIS_BUFFER, *PNDIS_BUFFER;

struct _NDIS_PACKET;
typedef NDIS_HANDLE PNDIS_PACKET_POOL;

//
//
// wrapper-specific part of a packet
//
typedef struct _NDIS_PACKET_PRIVATE
{
    UINT                PhysicalCount;  // number of physical pages in packet.
    UINT                TotalLength;    // Total amount of data in the packet.
    PNDIS_BUFFER        Head;           // first buffer in the chain
    PNDIS_BUFFER        Tail;           // last buffer in the chain

    // if Head is NULL the chain is empty; Tail doesn't have to be NULL also

    PNDIS_PACKET_POOL   Pool;           // so we know where to free it back to
    UINT                Count;
    ULONG               Flags;
    BOOLEAN             ValidCounts;
    UCHAR               NdisPacketFlags;    // See fPACKET_xxx bits below
    USHORT              NdisPacketOobOffset;
} NDIS_PACKET_PRIVATE, * PNDIS_PACKET_PRIVATE;

//
// The bits define the bits in the Flags
//
#define NDIS_FLAGS_PROTOCOL_ID_MASK             0x0000000F  // The low 4 bits are defined for protocol-id
                                                            // The values are defined in ntddndis.h
#define NDIS_FLAGS_MULTICAST_PACKET             0x00000010  // don't use
#define NDIS_FLAGS_RESERVED2                    0x00000020  // don't use
#define NDIS_FLAGS_RESERVED3                    0x00000040  // don't use
#define NDIS_FLAGS_DONT_LOOPBACK                0x00000080  // Write only
#define NDIS_FLAGS_IS_LOOPBACK_PACKET           0x00000100  // Read only
#define NDIS_FLAGS_LOOPBACK_ONLY                0x00000200  // Write only
#define NDIS_FLAGS_RESERVED4                    0x00000400  // don't use
#define NDIS_FLAGS_DOUBLE_BUFFERED              0x00000800  // used by ndis
#define NDIS_FLAGS_SENT_AT_DPC                  0x00001000  // the protocol sent this packet at DPC
#define NDIS_FLAGS_USES_SG_BUFFER_LIST          0x00002000  // used by Ndis

//
// Low-bits in the NdisPacketFlags are reserved by NDIS Wrapper for internal use
//
#define fPACKET_WRAPPER_RESERVED                0x3F
#define fPACKET_CONTAINS_MEDIA_SPECIFIC_INFO    0x40
#define fPACKET_ALLOCATED_BY_NDIS               0x80

//
// Definition for layout of the media-specific data. More than one class of media-specific
// information can be tagged onto a packet.
//
typedef enum _NDIS_CLASS_ID
{
    NdisClass802_3Priority,
    NdisClassWirelessWanMbxMailbox,
    NdisClassIrdaPacketInfo,
    NdisClassAtmAALInfo

} NDIS_CLASS_ID;

typedef struct _MEDIA_SPECIFIC_INFORMATION
{
    UINT            NextEntryOffset;
    NDIS_CLASS_ID   ClassId;
    UINT            Size;
    UCHAR           ClassInformation[1];

} MEDIA_SPECIFIC_INFORMATION, *PMEDIA_SPECIFIC_INFORMATION;

typedef struct _NDIS_PACKET_OOB_DATA
{
    union
    {
        ULONGLONG   TimeToSend;
        ULONGLONG   TimeSent;
    };
    ULONGLONG       TimeReceived;
    UINT            HeaderSize;
    UINT            SizeMediaSpecificInfo;
    PVOID           MediaSpecificInformation;

    NDIS_STATUS     Status;
} NDIS_PACKET_OOB_DATA, *PNDIS_PACKET_OOB_DATA;

#define NDIS_GET_PACKET_PROTOCOL_TYPE(_Packet_) ((_Packet_)->Private.Flags & NDIS_PROTOCOL_ID_MASK)

#define NDIS_OOB_DATA_FROM_PACKET(_p)                                   \
                        (PNDIS_PACKET_OOB_DATA)((PUCHAR)(_p) +          \
                        (_p)->Private.NdisPacketOobOffset)
#define NDIS_GET_PACKET_HEADER_SIZE(_Packet)                            \
                        ((PNDIS_PACKET_OOB_DATA)((PUCHAR)(_Packet) +    \
                        (_Packet)->Private.NdisPacketOobOffset))->HeaderSize
#define NDIS_GET_PACKET_STATUS(_Packet)                                 \
                        ((PNDIS_PACKET_OOB_DATA)((PUCHAR)(_Packet) +    \
                        (_Packet)->Private.NdisPacketOobOffset))->Status
#define NDIS_GET_PACKET_TIME_TO_SEND(_Packet)                           \
                        ((PNDIS_PACKET_OOB_DATA)((PUCHAR)(_Packet) +    \
                        (_Packet)->Private.NdisPacketOobOffset))->TimeToSend
#define NDIS_GET_PACKET_TIME_SENT(_Packet)                              \
                        ((PNDIS_PACKET_OOB_DATA)((PUCHAR)(_Packet) +    \
                        (_Packet)->Private.NdisPacketOobOffset))->TimeSent
#define NDIS_GET_PACKET_TIME_RECEIVED(_Packet)                          \
                        ((PNDIS_PACKET_OOB_DATA)((PUCHAR)(_Packet) +    \
                        (_Packet)->Private.NdisPacketOobOffset))->TimeReceived
#define NDIS_GET_PACKET_MEDIA_SPECIFIC_INFO(_Packet,                    \
                                            _pMediaSpecificInfo,        \
                                            _pSizeMediaSpecificInfo)    \
{                                                                       \
    if (!((_Packet)->Private.NdisPacketFlags & fPACKET_ALLOCATED_BY_NDIS) ||\
        !((_Packet)->Private.NdisPacketFlags & fPACKET_CONTAINS_MEDIA_SPECIFIC_INFO))\
    {                                                                   \
        *(_pMediaSpecificInfo) = NULL;                                  \
        *(_pSizeMediaSpecificInfo) = 0;                                 \
    }                                                                   \
    else                                                                \
    {                                                                   \
        *(_pMediaSpecificInfo) =((PNDIS_PACKET_OOB_DATA)((PUCHAR)(_Packet) +\
                    (_Packet)->Private.NdisPacketOobOffset))->MediaSpecificInformation;\
        *(_pSizeMediaSpecificInfo) = ((PNDIS_PACKET_OOB_DATA)((PUCHAR)(_Packet) +\
                    (_Packet)->Private.NdisPacketOobOffset))->SizeMediaSpecificInfo;\
    }                                                                   \
}

#define NDIS_SET_PACKET_HEADER_SIZE(_Packet, _HdrSize)                  \
                        ((PNDIS_PACKET_OOB_DATA)((PUCHAR)(_Packet) +    \
                        (_Packet)->Private.NdisPacketOobOffset))->HeaderSize = (_HdrSize)
#define NDIS_SET_PACKET_STATUS(_Packet, _Status)                        \
                        ((PNDIS_PACKET_OOB_DATA)((PUCHAR)(_Packet) +    \
                        (_Packet)->Private.NdisPacketOobOffset))->Status = (_Status)
#define NDIS_SET_PACKET_TIME_TO_SEND(_Packet, _TimeToSend)              \
                        ((PNDIS_PACKET_OOB_DATA)((PUCHAR)(_Packet) +    \
                        (_Packet)->Private.NdisPacketOobOffset))->TimeToSend = (_TimeToSend)
#define NDIS_SET_PACKET_TIME_SENT(_Packet, _TimeSent)                   \
                        ((PNDIS_PACKET_OOB_DATA)((PUCHAR)(_Packet) +    \
                        (_Packet)->Private.NdisPacketOobOffset))->TimeSent = (_TimeSent)
#define NDIS_SET_PACKET_TIME_RECEIVED(_Packet, _TimeReceived)           \
                        ((PNDIS_PACKET_OOB_DATA)((PUCHAR)(_Packet) +    \
                        (_Packet)->Private.NdisPacketOobOffset))->TimeReceived = (_TimeReceived)
#define NDIS_SET_PACKET_MEDIA_SPECIFIC_INFO(_Packet,                    \
                                            _MediaSpecificInfo,         \
                                            _SizeMediaSpecificInfo)     \
{                                                                       \
    if ((_Packet)->Private.NdisPacketFlags & fPACKET_ALLOCATED_BY_NDIS) \
    {                                                                   \
        (_Packet)->Private.NdisPacketFlags |= fPACKET_CONTAINS_MEDIA_SPECIFIC_INFO;\
        ((PNDIS_PACKET_OOB_DATA)((PUCHAR)(_Packet) +                    \
                                          (_Packet)->Private.NdisPacketOobOffset))->MediaSpecificInformation = (_MediaSpecificInfo);\
        ((PNDIS_PACKET_OOB_DATA)((PUCHAR)(_Packet) +                    \
                                          (_Packet)->Private.NdisPacketOobOffset))->SizeMediaSpecificInfo = (_SizeMediaSpecificInfo);\
    }                                                                   \
}

//
// packet definition
//
typedef struct _NDIS_PACKET
{
    NDIS_PACKET_PRIVATE Private;

    union
    {
        struct                  // For Connection-less miniports
        {
            UCHAR   MiniportReserved[2*sizeof(PVOID)];
            UCHAR   WrapperReserved[2*sizeof(PVOID)];
        };

        struct
        {
            //
            // For de-serialized miniports. And by implication conn-oriented miniports.
            // This is for the send-path only. Packets indicated will use WrapperReserved
            // instead of WrapperReservedEx
            //
            UCHAR   MiniportReservedEx[3*sizeof(PVOID)];
            UCHAR   WrapperReservedEx[sizeof(PVOID)];
        };

        struct
        {
            UCHAR   MacReserved[4*sizeof(PVOID)];
        };
    };

    ULONG_PTR       Reserved[2];            // For compatibility with Win95
    UCHAR           ProtocolReserved[1];

} NDIS_PACKET, *PNDIS_PACKET, **PPNDIS_PACKET;

//
//  NDIS per-packet information.
//
typedef enum _NDIS_PER_PACKET_INFO
{
    TcpIpChecksumPacketInfo,
    IpSecPacketInfo,
    TcpLargeSendPacketInfo,
    ClassificationHandlePacketInfo,
    NdisReserved,
    ScatterGatherListPacketInfo,
    Ieee8021QInfo,
    OriginalPacketInfo,
    PacketCancelId,
    MaxPerPacketInfo
} NDIS_PER_PACKET_INFO, *PNDIS_PER_PACKET_INFO;

typedef struct _NDIS_PACKET_EXTENSION
{
    PVOID       NdisPacketInfo[MaxPerPacketInfo];
} NDIS_PACKET_EXTENSION, *PNDIS_PACKET_EXTENSION;

#define NDIS_PACKET_EXTENSION_FROM_PACKET(_P)       ((PNDIS_PACKET_EXTENSION)((PUCHAR)(_P) + (_P)->Private.NdisPacketOobOffset + sizeof(NDIS_PACKET_OOB_DATA)))
#define NDIS_PER_PACKET_INFO_FROM_PACKET(_P, _Id)   ((PNDIS_PACKET_EXTENSION)((PUCHAR)(_P) + (_P)->Private.NdisPacketOobOffset + sizeof(NDIS_PACKET_OOB_DATA)))->NdisPacketInfo[(_Id)]
#define NDIS_GET_ORIGINAL_PACKET(_P)                NDIS_PER_PACKET_INFO_FROM_PACKET(_P, OriginalPacketInfo)
#define NDIS_SET_ORIGINAL_PACKET(_P, _OP)           NDIS_PER_PACKET_INFO_FROM_PACKET(_P, OriginalPacketInfo) = _OP
#define NDIS_GET_PACKET_CANCEL_ID(_P)               NDIS_PER_PACKET_INFO_FROM_PACKET(_P, PacketCancelId)
#define NDIS_SET_PACKET_CANCEL_ID(_P, _cId)         NDIS_PER_PACKET_INFO_FROM_PACKET(_P, PacketCancelId) = _cId


typedef struct _NDIS_PACKET_STACK
{
    ULONG_PTR   IMReserved[2];
    ULONG_PTR   NdisReserved[4];
} NDIS_PACKET_STACK, *PNDIS_PACKET_STACK;

//
//  Per-packet information for TcpIpChecksumPacketInfo.
//
typedef struct _NDIS_TCP_IP_CHECKSUM_PACKET_INFO
{
    union
    {
        struct
        {
            ULONG   NdisPacketChecksumV4:1;
            ULONG   NdisPacketChecksumV6:1;
            ULONG   NdisPacketTcpChecksum:1;
            ULONG   NdisPacketUdpChecksum:1;
            ULONG   NdisPacketIpChecksum:1;
        } Transmit;

        struct
        {
            ULONG   NdisPacketTcpChecksumFailed:1;
            ULONG   NdisPacketUdpChecksumFailed:1;
            ULONG   NdisPacketIpChecksumFailed:1;
            ULONG   NdisPacketTcpChecksumSucceeded:1;
            ULONG   NdisPacketUdpChecksumSucceeded:1;
            ULONG   NdisPacketIpChecksumSucceeded:1;
            ULONG   NdisPacketLoopback:1;
        } Receive;

        ULONG   Value;
    };
} NDIS_TCP_IP_CHECKSUM_PACKET_INFO, *PNDIS_TCP_IP_CHECKSUM_PACKET_INFO;


//
//  Per-packet information for Ieee8021QInfo.
//
typedef struct _NDIS_PACKET_8021Q_INFO
{
    union
    {
        struct
        {
            UINT32      UserPriority:3;         // 802.1p priority
            UINT32      CanonicalFormatId:1;    // always 0
            UINT32      VlanId:12;              // VLAN Identification
            UINT32      Reserved:16;            // set to 0
        }   TagHeader;

        PVOID  Value;
    };
} NDIS_PACKET_8021Q_INFO, *PNDIS_PACKET_8021Q_INFO;

//
//  Old definitions, to be obsoleted.
//
#define Ieee8021pPriority   Ieee8021QInfo
typedef UINT                IEEE8021PPRIORITY;


#define MAX_HASHES          4
#define TRUNCATED_HASH_LEN  12

#define CRYPTO_SUCCESS                      0
#define CRYPTO_GENERIC_ERROR                1
#define CRYPTO_TRANSPORT_AH_AUTH_FAILED     2
#define CRYPTO_TRANSPORT_ESP_AUTH_FAILED    3
#define CRYPTO_TUNNEL_AH_AUTH_FAILED        4
#define CRYPTO_TUNNEL_ESP_AUTH_FAILED       5
#define CRYPTO_INVALID_PACKET_SYNTAX        6
#define CRYPTO_INVALID_PROTOCOL             7

typedef struct _NDIS_IPSEC_PACKET_INFO
{
    union
    {
        struct
        {
            NDIS_HANDLE OffloadHandle;
            NDIS_HANDLE NextOffloadHandle;

        } Transmit;

        struct
        {
            ULONG   SA_DELETE_REQ:1;
            ULONG   CRYPTO_DONE:1;
            ULONG   NEXT_CRYPTO_DONE:1;
            ULONG   CryptoStatus;
        } Receive;
    };
} NDIS_IPSEC_PACKET_INFO, *PNDIS_IPSEC_PACKET_INFO;


///
//  NDIS Task Off-Load data structures.
///

#define NDIS_TASK_OFFLOAD_VERSION 1

//
//  The following defines are used in the Task field above to define
//  the type of task offloading necessary.
//
typedef enum _NDIS_TASK
{
    TcpIpChecksumNdisTask,
    IpSecNdisTask,
    TcpLargeSendNdisTask,
    MaxNdisTask
} NDIS_TASK, *PNDIS_TASK;

typedef enum _NDIS_ENCAPSULATION
{
    UNSPECIFIED_Encapsulation,
    NULL_Encapsulation,
    IEEE_802_3_Encapsulation,
    IEEE_802_5_Encapsulation,
    LLC_SNAP_ROUTED_Encapsulation,
    LLC_SNAP_BRIDGED_Encapsulation

} NDIS_ENCAPSULATION;

//
// Encapsulation header format
//
typedef struct _NDIS_ENCAPSULATION_FORMAT
{
    NDIS_ENCAPSULATION  Encapsulation;              // Encapsulation type
    struct
    {
        ULONG   FixedHeaderSize:1;
        ULONG   Reserved:31;
    } Flags;

    ULONG    EncapsulationHeaderSize;               // Encapsulation header size

} NDIS_ENCAPSULATION_FORMAT,*PNDIS_ENCAPSULATION_FORMAT;


//
// OFFLOAD header structure for OID_TCP_TASK_OFFLOAD
//
typedef struct _NDIS_TASK_OFFLOAD_HEADER
{
    ULONG       Version;                            // set to NDIS_TASK_OFFLOAD_VERSION
    ULONG       Size;                               // Size of this structure
    ULONG       Reserved;                           // Reserved for future use
    ULONG       OffsetFirstTask;                    // Offset to the first
    NDIS_ENCAPSULATION_FORMAT  EncapsulationFormat; // Encapsulation information.
                                                    // NDIS_TASK_OFFLOAD structure(s)

} NDIS_TASK_OFFLOAD_HEADER, *PNDIS_TASK_OFFLOAD_HEADER;


//
//  Task offload Structure, which follows the above header in ndis query
//
typedef struct _NDIS_TASK_OFFLOAD
{
    ULONG       Version;                            // NDIS_TASK_OFFLOAD_VERSION
    ULONG       Size;                               //  Size of this structure. Used for version checking.
    NDIS_TASK   Task;                               //  Task.
    ULONG       OffsetNextTask;                     //  Offset to the next NDIS_TASK_OFFLOAD
    ULONG       TaskBufferLength;                   //  Length of the task offload information.
    UCHAR       TaskBuffer[1];                      //  The task offload information.
} NDIS_TASK_OFFLOAD, *PNDIS_TASK_OFFLOAD;

//
//  Offload structure for NDIS_TASK_TCP_IP_CHECKSUM
//
typedef struct _NDIS_TASK_TCP_IP_CHECKSUM
{
    struct
    {
        ULONG       IpOptionsSupported:1;
        ULONG       TcpOptionsSupported:1;
        ULONG       TcpChecksum:1;
        ULONG       UdpChecksum:1;
        ULONG       IpChecksum:1;
    } V4Transmit;

    struct
    {
        ULONG       IpOptionsSupported:1;
        ULONG       TcpOptionsSupported:1;
        ULONG       TcpChecksum:1;
        ULONG       UdpChecksum:1;
        ULONG       IpChecksum:1;
    } V4Receive;


    struct
    {
        ULONG       IpOptionsSupported:1;
        ULONG       TcpOptionsSupported:1;
        ULONG       TcpChecksum:1;
        ULONG       UdpChecksum:1;

    } V6Transmit;

    struct
    {
        ULONG       IpOptionsSupported:1;
        ULONG       TcpOptionsSupported:1;
        ULONG       TcpChecksum:1;
        ULONG       UdpChecksum:1;

    } V6Receive;


} NDIS_TASK_TCP_IP_CHECKSUM, *PNDIS_TASK_TCP_IP_CHECKSUM;

//
//  Off-load structure for NDIS_TASK_TCP_LARGE_SEND
//
typedef struct _NDIS_TASK_TCP_LARGE_SEND
{
    ULONG     Version;
    ULONG     MaxOffLoadSize;
    ULONG        MinSegmentCount;
    BOOLEAN   TcpOptions;
    BOOLEAN   IpOptions;

} NDIS_TASK_TCP_LARGE_SEND, *PNDIS_TASK_TCP_LARGE_SEND;


typedef struct _NDIS_TASK_IPSEC
{
    struct
    {
        ULONG   AH_ESP_COMBINED;
        ULONG   TRANSPORT_TUNNEL_COMBINED;
        ULONG   V4_OPTIONS;
        ULONG   RESERVED;
    } Supported;

    struct
    {
        ULONG   MD5:1;
        ULONG   SHA_1:1;
        ULONG   Transport:1;
        ULONG   Tunnel:1;
        ULONG   Send:1;
        ULONG   Receive:1;
    } V4AH;

    struct
    {
        ULONG   DES:1;
        ULONG   RESERVED:1;
        ULONG   TRIPLE_DES:1;
        ULONG   NULL_ESP:1;
        ULONG   Transport:1;
        ULONG   Tunnel:1;
        ULONG   Send:1;
        ULONG   Receive:1;
    } V4ESP;

} NDIS_TASK_IPSEC, *PNDIS_TASK_IPSEC;

typedef UINT    IEEE8021PPRIORITY;

//
// WAN Packet. This is used by WAN miniports only. This is the legacy model.
// Co-Ndis is the preferred model for WAN miniports
//
typedef struct _NDIS_WAN_PACKET
{
    LIST_ENTRY          WanPacketQueue;
    PUCHAR              CurrentBuffer;
    ULONG               CurrentLength;
    PUCHAR              StartBuffer;
    PUCHAR              EndBuffer;
    PVOID               ProtocolReserved1;
    PVOID               ProtocolReserved2;
    PVOID               ProtocolReserved3;
    PVOID               ProtocolReserved4;
    PVOID               MacReserved1;
    PVOID               MacReserved2;
    PVOID               MacReserved3;
    PVOID               MacReserved4;
} NDIS_WAN_PACKET, *PNDIS_WAN_PACKET;

//
// Routines to get/set packet flags
//

/*++

UINT
NdisGetPacketFlags(
    IN  PNDIS_PACKET    Packet
    );

--*/

#define NdisGetPacketFlags(_Packet)         (_Packet)->Private.Flags

/*++

VOID
NdisSetPacketFlags(
    IN  PNDIS_PACKET Packet,
    IN  UINT Flags
    );

--*/

#define NdisSetPacketFlags(_Packet, _Flags)     (_Packet)->Private.Flags |= (_Flags)
#define NdisClearPacketFlags(_Packet, _Flags)   (_Packet)->Private.Flags &= ~(_Flags)

//
// Request types used by NdisRequest; constants are added for
// all entry points in the MAC, for those that want to create
// their own internal requests.
//

typedef enum _NDIS_REQUEST_TYPE
{
    NdisRequestQueryInformation,
    NdisRequestSetInformation,
    NdisRequestQueryStatistics,
    NdisRequestOpen,
    NdisRequestClose,
    NdisRequestSend,
    NdisRequestTransferData,
    NdisRequestReset,
    NdisRequestGeneric1,
    NdisRequestGeneric2,
    NdisRequestGeneric3,
    NdisRequestGeneric4
} NDIS_REQUEST_TYPE, *PNDIS_REQUEST_TYPE;


//
// Structure of requests sent via NdisRequest
//

typedef struct _NDIS_REQUEST
{
    UCHAR               MacReserved[4*sizeof(PVOID)];
    NDIS_REQUEST_TYPE   RequestType;
    union _DATA
    {
        struct _QUERY_INFORMATION
        {
            NDIS_OID    Oid;
            PVOID       InformationBuffer;
            UINT        InformationBufferLength;
            UINT        BytesWritten;
            UINT        BytesNeeded;
        } QUERY_INFORMATION;

        struct _SET_INFORMATION
        {
            NDIS_OID    Oid;
            PVOID       InformationBuffer;
            UINT        InformationBufferLength;
            UINT        BytesRead;
            UINT        BytesNeeded;
        } SET_INFORMATION;

    } DATA;
#if (defined(NDIS50) || defined(NDIS51) || defined(NDIS50_MINIPORT) || defined(NDIS51_MINIPORT))
    UCHAR               NdisReserved[9*sizeof(PVOID)];
    union
    {
        UCHAR           CallMgrReserved[2*sizeof(PVOID)];
        UCHAR           ProtocolReserved[2*sizeof(PVOID)];
    };
    UCHAR               MiniportReserved[2*sizeof(PVOID)];
#endif
} NDIS_REQUEST, *PNDIS_REQUEST;


//
// NDIS Address Family definitions.
//
typedef ULONG           NDIS_AF, *PNDIS_AF;
#define CO_ADDRESS_FAMILY_Q2931             ((NDIS_AF)0x1)  // ATM
#define CO_ADDRESS_FAMILY_PSCHED            ((NDIS_AF)0x2)  // Packet scheduler
#define CO_ADDRESS_FAMILY_L2TP              ((NDIS_AF)0x3)
#define CO_ADDRESS_FAMILY_IRDA              ((NDIS_AF)0x4)
#define CO_ADDRESS_FAMILY_1394              ((NDIS_AF)0x5)
#define CO_ADDRESS_FAMILY_PPP               ((NDIS_AF)0x6)
#define CO_ADDRESS_FAMILY_TAPI              ((NDIS_AF)0x800)
#define CO_ADDRESS_FAMILY_TAPI_PROXY        ((NDIS_AF)0x801)

//
// The following is OR'ed with the base AF to denote proxy support
//
#define CO_ADDRESS_FAMILY_PROXY             0x80000000


//
//  Address family structure registered/opened via
//      NdisCmRegisterAddressFamily
//      NdisClOpenAddressFamily
//
typedef struct
{
    NDIS_AF                     AddressFamily;  // one of the CO_ADDRESS_FAMILY_xxx values above
    ULONG                       MajorVersion;   // the major version of call manager
    ULONG                       MinorVersion;   // the minor version of call manager
} CO_ADDRESS_FAMILY, *PCO_ADDRESS_FAMILY;

//
// Definition for a SAP
//
typedef struct
{
    ULONG                       SapType;
    ULONG                       SapLength;
    UCHAR                       Sap[1];
} CO_SAP, *PCO_SAP;

//
// Definitions for physical address.
//

typedef PHYSICAL_ADDRESS NDIS_PHYSICAL_ADDRESS, *PNDIS_PHYSICAL_ADDRESS;
typedef struct _NDIS_PHYSICAL_ADDRESS_UNIT
{
    NDIS_PHYSICAL_ADDRESS       PhysicalAddress;
    UINT                        Length;
} NDIS_PHYSICAL_ADDRESS_UNIT, *PNDIS_PHYSICAL_ADDRESS_UNIT;


/*++

ULONG
NdisGetPhysicalAddressHigh(
    IN  NDIS_PHYSICAL_ADDRESS   PhysicalAddress
    );

--*/

#define NdisGetPhysicalAddressHigh(_PhysicalAddress)            \
        ((_PhysicalAddress).HighPart)

/*++

VOID
NdisSetPhysicalAddressHigh(
    IN  NDIS_PHYSICAL_ADDRESS   PhysicalAddress,
    IN  ULONG                   Value
    );

--*/

#define NdisSetPhysicalAddressHigh(_PhysicalAddress, _Value)    \
     ((_PhysicalAddress).HighPart) = (_Value)


/*++

ULONG
NdisGetPhysicalAddressLow(
    IN  NDIS_PHYSICAL_ADDRESS PhysicalAddress
    );

--*/

#define NdisGetPhysicalAddressLow(_PhysicalAddress)             \
    ((_PhysicalAddress).LowPart)


/*++

VOID
NdisSetPhysicalAddressLow(
    IN  NDIS_PHYSICAL_ADDRESS   PhysicalAddress,
    IN  ULONG                   Value
    );

--*/

#define NdisSetPhysicalAddressLow(_PhysicalAddress, _Value)     \
    ((_PhysicalAddress).LowPart) = (_Value)

//
// Macro to initialize an NDIS_PHYSICAL_ADDRESS constant
//

#define NDIS_PHYSICAL_ADDRESS_CONST(_Low, _High)                \
    { (ULONG)(_Low), (LONG)(_High) }


//
// block used for references...
//
typedef struct _REFERENCE
{
    KSPIN_LOCK                  SpinLock;
    USHORT                      ReferenceCount;
    BOOLEAN                     Closing;
} REFERENCE, * PREFERENCE;

//
// block used for references using a ULONG
//
typedef struct _ULONG_REFERENCE
{
    KSPIN_LOCK                  SpinLock;
    ULONG                       ReferenceCount;
    BOOLEAN                     Closing;
} ULONG_REFERENCE, *PULONG_REFERENCE;


//
// This holds a map register entry.
//

typedef struct _MAP_REGISTER_ENTRY
{
    PVOID                       MapRegister;
    BOOLEAN                     WriteToDevice;
} MAP_REGISTER_ENTRY, * PMAP_REGISTER_ENTRY;

//
// Types of Memory (not mutually exclusive)
//

#define NDIS_MEMORY_CONTIGUOUS      0x00000001
#define NDIS_MEMORY_NONCACHED       0x00000002

//
// Open options
//
#define NDIS_OPEN_RECEIVE_NOT_REENTRANT 0x00000001

//
// NDIS_STATUS values
//

#define NDIS_STATUS_SUCCESS                     ((NDIS_STATUS)STATUS_SUCCESS)
#define NDIS_STATUS_PENDING                     ((NDIS_STATUS) STATUS_PENDING)
#define NDIS_STATUS_NOT_RECOGNIZED              ((NDIS_STATUS)0x00010001L)
#define NDIS_STATUS_NOT_COPIED                  ((NDIS_STATUS)0x00010002L)
#define NDIS_STATUS_NOT_ACCEPTED                ((NDIS_STATUS)0x00010003L)
#define NDIS_STATUS_CALL_ACTIVE                 ((NDIS_STATUS)0x00010007L)

#define NDIS_STATUS_ONLINE                      ((NDIS_STATUS)0x40010003L)
#define NDIS_STATUS_RESET_START                 ((NDIS_STATUS)0x40010004L)
#define NDIS_STATUS_RESET_END                   ((NDIS_STATUS)0x40010005L)
#define NDIS_STATUS_RING_STATUS                 ((NDIS_STATUS)0x40010006L)
#define NDIS_STATUS_CLOSED                      ((NDIS_STATUS)0x40010007L)
#define NDIS_STATUS_WAN_LINE_UP                 ((NDIS_STATUS)0x40010008L)
#define NDIS_STATUS_WAN_LINE_DOWN               ((NDIS_STATUS)0x40010009L)
#define NDIS_STATUS_WAN_FRAGMENT                ((NDIS_STATUS)0x4001000AL)
#define NDIS_STATUS_MEDIA_CONNECT               ((NDIS_STATUS)0x4001000BL)
#define NDIS_STATUS_MEDIA_DISCONNECT            ((NDIS_STATUS)0x4001000CL)
#define NDIS_STATUS_HARDWARE_LINE_UP            ((NDIS_STATUS)0x4001000DL)
#define NDIS_STATUS_HARDWARE_LINE_DOWN          ((NDIS_STATUS)0x4001000EL)
#define NDIS_STATUS_INTERFACE_UP                ((NDIS_STATUS)0x4001000FL)
#define NDIS_STATUS_INTERFACE_DOWN              ((NDIS_STATUS)0x40010010L)
#define NDIS_STATUS_MEDIA_BUSY                  ((NDIS_STATUS)0x40010011L)
#define NDIS_STATUS_MEDIA_SPECIFIC_INDICATION   ((NDIS_STATUS)0x40010012L)
#define NDIS_STATUS_WW_INDICATION               NDIS_STATUS_MEDIA_SPECIFIC_INDICATION
#define NDIS_STATUS_LINK_SPEED_CHANGE           ((NDIS_STATUS)0x40010013L)
#define NDIS_STATUS_WAN_GET_STATS               ((NDIS_STATUS)0x40010014L)
#define NDIS_STATUS_WAN_CO_FRAGMENT             ((NDIS_STATUS)0x40010015L)
#define NDIS_STATUS_WAN_CO_LINKPARAMS           ((NDIS_STATUS)0x40010016L)

#define NDIS_STATUS_NOT_RESETTABLE              ((NDIS_STATUS)0x80010001L)
#define NDIS_STATUS_SOFT_ERRORS                 ((NDIS_STATUS)0x80010003L)
#define NDIS_STATUS_HARD_ERRORS                 ((NDIS_STATUS)0x80010004L)
#define NDIS_STATUS_BUFFER_OVERFLOW             ((NDIS_STATUS)STATUS_BUFFER_OVERFLOW)

#define NDIS_STATUS_FAILURE                     ((NDIS_STATUS) STATUS_UNSUCCESSFUL)
#define NDIS_STATUS_RESOURCES                   ((NDIS_STATUS)STATUS_INSUFFICIENT_RESOURCES)
#define NDIS_STATUS_CLOSING                     ((NDIS_STATUS)0xC0010002L)
#define NDIS_STATUS_BAD_VERSION                 ((NDIS_STATUS)0xC0010004L)
#define NDIS_STATUS_BAD_CHARACTERISTICS         ((NDIS_STATUS)0xC0010005L)
#define NDIS_STATUS_ADAPTER_NOT_FOUND           ((NDIS_STATUS)0xC0010006L)
#define NDIS_STATUS_OPEN_FAILED                 ((NDIS_STATUS)0xC0010007L)
#define NDIS_STATUS_DEVICE_FAILED               ((NDIS_STATUS)0xC0010008L)
#define NDIS_STATUS_MULTICAST_FULL              ((NDIS_STATUS)0xC0010009L)
#define NDIS_STATUS_MULTICAST_EXISTS            ((NDIS_STATUS)0xC001000AL)
#define NDIS_STATUS_MULTICAST_NOT_FOUND         ((NDIS_STATUS)0xC001000BL)
#define NDIS_STATUS_REQUEST_ABORTED             ((NDIS_STATUS)0xC001000CL)
#define NDIS_STATUS_RESET_IN_PROGRESS           ((NDIS_STATUS)0xC001000DL)
#define NDIS_STATUS_CLOSING_INDICATING          ((NDIS_STATUS)0xC001000EL)
#define NDIS_STATUS_NOT_SUPPORTED               ((NDIS_STATUS)STATUS_NOT_SUPPORTED)
#define NDIS_STATUS_INVALID_PACKET              ((NDIS_STATUS)0xC001000FL)
#define NDIS_STATUS_OPEN_LIST_FULL              ((NDIS_STATUS)0xC0010010L)
#define NDIS_STATUS_ADAPTER_NOT_READY           ((NDIS_STATUS)0xC0010011L)
#define NDIS_STATUS_ADAPTER_NOT_OPEN            ((NDIS_STATUS)0xC0010012L)
#define NDIS_STATUS_NOT_INDICATING              ((NDIS_STATUS)0xC0010013L)
#define NDIS_STATUS_INVALID_LENGTH              ((NDIS_STATUS)0xC0010014L)
#define NDIS_STATUS_INVALID_DATA                ((NDIS_STATUS)0xC0010015L)
#define NDIS_STATUS_BUFFER_TOO_SHORT            ((NDIS_STATUS)0xC0010016L)
#define NDIS_STATUS_INVALID_OID                 ((NDIS_STATUS)0xC0010017L)
#define NDIS_STATUS_ADAPTER_REMOVED             ((NDIS_STATUS)0xC0010018L)
#define NDIS_STATUS_UNSUPPORTED_MEDIA           ((NDIS_STATUS)0xC0010019L)
#define NDIS_STATUS_GROUP_ADDRESS_IN_USE        ((NDIS_STATUS)0xC001001AL)
#define NDIS_STATUS_FILE_NOT_FOUND              ((NDIS_STATUS)0xC001001BL)
#define NDIS_STATUS_ERROR_READING_FILE          ((NDIS_STATUS)0xC001001CL)
#define NDIS_STATUS_ALREADY_MAPPED              ((NDIS_STATUS)0xC001001DL)
#define NDIS_STATUS_RESOURCE_CONFLICT           ((NDIS_STATUS)0xC001001EL)
#define NDIS_STATUS_NO_CABLE                    ((NDIS_STATUS)0xC001001FL)

#define NDIS_STATUS_INVALID_SAP                 ((NDIS_STATUS)0xC0010020L)
#define NDIS_STATUS_SAP_IN_USE                  ((NDIS_STATUS)0xC0010021L)
#define NDIS_STATUS_INVALID_ADDRESS             ((NDIS_STATUS)0xC0010022L)
#define NDIS_STATUS_VC_NOT_ACTIVATED            ((NDIS_STATUS)0xC0010023L)
#define NDIS_STATUS_DEST_OUT_OF_ORDER           ((NDIS_STATUS)0xC0010024L)  // cause 27
#define NDIS_STATUS_VC_NOT_AVAILABLE            ((NDIS_STATUS)0xC0010025L)  // cause 35,45
#define NDIS_STATUS_CELLRATE_NOT_AVAILABLE      ((NDIS_STATUS)0xC0010026L)  // cause 37
#define NDIS_STATUS_INCOMPATABLE_QOS            ((NDIS_STATUS)0xC0010027L)  // cause 49
#define NDIS_STATUS_AAL_PARAMS_UNSUPPORTED      ((NDIS_STATUS)0xC0010028L)  // cause 93
#define NDIS_STATUS_NO_ROUTE_TO_DESTINATION     ((NDIS_STATUS)0xC0010029L)  // cause 3

#define NDIS_STATUS_TOKEN_RING_OPEN_ERROR       ((NDIS_STATUS)0xC0011000L)
#define NDIS_STATUS_INVALID_DEVICE_REQUEST      ((NDIS_STATUS)STATUS_INVALID_DEVICE_REQUEST)
#define NDIS_STATUS_NETWORK_UNREACHABLE         ((NDIS_STATUS)STATUS_NETWORK_UNREACHABLE)


//
// used in error logging
//

#define NDIS_ERROR_CODE ULONG

#define NDIS_ERROR_CODE_RESOURCE_CONFLICT           EVENT_NDIS_RESOURCE_CONFLICT
#define NDIS_ERROR_CODE_OUT_OF_RESOURCES            EVENT_NDIS_OUT_OF_RESOURCE
#define NDIS_ERROR_CODE_HARDWARE_FAILURE            EVENT_NDIS_HARDWARE_FAILURE
#define NDIS_ERROR_CODE_ADAPTER_NOT_FOUND           EVENT_NDIS_ADAPTER_NOT_FOUND
#define NDIS_ERROR_CODE_INTERRUPT_CONNECT           EVENT_NDIS_INTERRUPT_CONNECT
#define NDIS_ERROR_CODE_DRIVER_FAILURE              EVENT_NDIS_DRIVER_FAILURE
#define NDIS_ERROR_CODE_BAD_VERSION                 EVENT_NDIS_BAD_VERSION
#define NDIS_ERROR_CODE_TIMEOUT                     EVENT_NDIS_TIMEOUT
#define NDIS_ERROR_CODE_NETWORK_ADDRESS             EVENT_NDIS_NETWORK_ADDRESS
#define NDIS_ERROR_CODE_UNSUPPORTED_CONFIGURATION   EVENT_NDIS_UNSUPPORTED_CONFIGURATION
#define NDIS_ERROR_CODE_INVALID_VALUE_FROM_ADAPTER  EVENT_NDIS_INVALID_VALUE_FROM_ADAPTER
#define NDIS_ERROR_CODE_MISSING_CONFIGURATION_PARAMETER EVENT_NDIS_MISSING_CONFIGURATION_PARAMETER
#define NDIS_ERROR_CODE_BAD_IO_BASE_ADDRESS         EVENT_NDIS_BAD_IO_BASE_ADDRESS
#define NDIS_ERROR_CODE_RECEIVE_SPACE_SMALL         EVENT_NDIS_RECEIVE_SPACE_SMALL
#define NDIS_ERROR_CODE_ADAPTER_DISABLED            EVENT_NDIS_ADAPTER_DISABLED

#if BINARY_COMPATIBLE

#if USE_KLOCKS

#define DISPATCH_LEVEL      2

#define NdisAllocateSpinLock(_SpinLock) KeInitializeSpinLock(&(_SpinLock)->SpinLock)

#define NdisFreeSpinLock(_SpinLock)

#define NdisAcquireSpinLock(_SpinLock)  KeAcquireSpinLock(&(_SpinLock)->SpinLock, &(_SpinLock)->OldIrql)

#define NdisReleaseSpinLock(_SpinLock)  KeReleaseSpinLock(&(_SpinLock)->SpinLock,(_SpinLock)->OldIrql)

#define NdisDprAcquireSpinLock(_SpinLock)                       \
{                                                               \
    KeAcquireSpinLockAtDpcLevel(&(_SpinLock)->SpinLock);        \
    (_SpinLock)->OldIrql = DISPATCH_LEVEL;                      \
}

#define NdisDprReleaseSpinLock(_SpinLock) KeReleaseSpinLockFromDpcLevel(&(_SpinLock)->SpinLock)

#else

//
// Ndis Spin Locks
//
EXPORT
VOID
NdisAllocateSpinLock(
    IN  PNDIS_SPIN_LOCK         SpinLock
    );

EXPORT
VOID
NdisFreeSpinLock(
    IN  PNDIS_SPIN_LOCK         SpinLock
    );

EXPORT
VOID
NdisAcquireSpinLock(
    IN  PNDIS_SPIN_LOCK         SpinLock
    );

EXPORT
VOID
NdisReleaseSpinLock(
    IN  PNDIS_SPIN_LOCK         SpinLock
    );

EXPORT
VOID
NdisDprAcquireSpinLock(
    IN  PNDIS_SPIN_LOCK         SpinLock
    );

EXPORT
VOID
NdisDprReleaseSpinLock(
    IN  PNDIS_SPIN_LOCK         SpinLock
    );

#endif


EXPORT
VOID
NdisGetCurrentSystemTime(
    PLARGE_INTEGER              pSystemTime
    );

//
// Interlocked support functions
//

EXPORT
ULONG
NdisInterlockedIncrement(
    IN  PLONG                   Addend
    );

EXPORT
ULONG
NdisInterlockedDecrement(
    IN  PLONG                   Addend
    );

EXPORT
VOID
NdisInterlockedAddUlong(
    IN  PULONG                  Addend,
    IN  ULONG                   Increment,
    IN  PNDIS_SPIN_LOCK         SpinLock
    );

EXPORT
PLIST_ENTRY
NdisInterlockedInsertHeadList(
    IN  PLIST_ENTRY             ListHead,
    IN  PLIST_ENTRY             ListEntry,
    IN  PNDIS_SPIN_LOCK         SpinLock
    );


EXPORT
PLIST_ENTRY
NdisInterlockedInsertTailList(
    IN  PLIST_ENTRY             ListHead,
    IN  PLIST_ENTRY             ListEntry,
    IN  PNDIS_SPIN_LOCK         SpinLock
    );


EXPORT
PLIST_ENTRY
NdisInterlockedRemoveHeadList(
    IN  PLIST_ENTRY             ListHead,
    IN  PNDIS_SPIN_LOCK         SpinLock
    );

EXPORT
LARGE_INTEGER
NdisInterlockedAddLargeInteger(
    IN  PLARGE_INTEGER          Addend,
    IN  ULONG                   Increment,
    IN  PKSPIN_LOCK             Lock
    );

#else // BINARY_COMPATIBLE

#define NdisAllocateSpinLock(_SpinLock) KeInitializeSpinLock(&(_SpinLock)->SpinLock)

#define NdisFreeSpinLock(_SpinLock)

#define NdisAcquireSpinLock(_SpinLock)  KeAcquireSpinLock(&(_SpinLock)->SpinLock, &(_SpinLock)->OldIrql)

#define NdisReleaseSpinLock(_SpinLock)  KeReleaseSpinLock(&(_SpinLock)->SpinLock,(_SpinLock)->OldIrql)

#define NdisDprAcquireSpinLock(_SpinLock)                                   \
{                                                                           \
    KeAcquireSpinLockAtDpcLevel(&(_SpinLock)->SpinLock);                    \
    (_SpinLock)->OldIrql = DISPATCH_LEVEL;                                  \
}

#define NdisDprReleaseSpinLock(_SpinLock) KeReleaseSpinLockFromDpcLevel(&(_SpinLock)->SpinLock)

#define NdisGetCurrentSystemTime(_pSystemTime)                              \
    {                                                                       \
        KeQuerySystemTime(_pSystemTime);                                    \
    }

//
// Interlocked support functions
//

#define NdisInterlockedIncrement(Addend)    InterlockedIncrement(Addend)

#define NdisInterlockedDecrement(Addend)    InterlockedDecrement(Addend)

#define NdisInterlockedAddUlong(_Addend, _Increment, _SpinLock) \
    ExInterlockedAddUlong(_Addend, _Increment, &(_SpinLock)->SpinLock)

#define NdisInterlockedInsertHeadList(_ListHead, _ListEntry, _SpinLock) \
    ExInterlockedInsertHeadList(_ListHead, _ListEntry, &(_SpinLock)->SpinLock)

#define NdisInterlockedInsertTailList(_ListHead, _ListEntry, _SpinLock) \
    ExInterlockedInsertTailList(_ListHead, _ListEntry, &(_SpinLock)->SpinLock)

#define NdisInterlockedRemoveHeadList(_ListHead, _SpinLock) \
    ExInterlockedRemoveHeadList(_ListHead, &(_SpinLock)->SpinLock)

#define NdisInterlockedPushEntryList(ListHead, ListEntry, Lock) \
    ExInterlockedPushEntryList(ListHead, ListEntry, &(Lock)->SpinLock)

#define NdisInterlockedPopEntryList(ListHead, Lock) \
    ExInterlockedPopEntryList(ListHead, &(Lock)->SpinLock)

#endif // BINARY_COMPATIBLE

#ifndef MAXIMUM_PROCESSORS
#ifdef _WIN64
#define MAXIMUM_PROCESSORS 64
#else
#define MAXIMUM_PROCESSORS 32
#endif
#endif

typedef union _NDIS_RW_LOCK_REFCOUNT
{
    UINT                        RefCount;
    UCHAR                       cacheLine[16];  // One refCount per cache line
} NDIS_RW_LOCK_REFCOUNT;

typedef struct _NDIS_RW_LOCK
{
    union
    {
        struct
        {
            KSPIN_LOCK          SpinLock;
            PVOID               Context;
        };
        UCHAR                   Reserved[16];
    };

    NDIS_RW_LOCK_REFCOUNT       RefCount[MAXIMUM_PROCESSORS];
} NDIS_RW_LOCK, *PNDIS_RW_LOCK;

typedef struct _LOCK_STATE
{
    USHORT                      LockState;
    KIRQL                       OldIrql;
} LOCK_STATE, *PLOCK_STATE;


EXPORT
VOID
NdisInitializeReadWriteLock(
    IN  PNDIS_RW_LOCK           Lock
    );


EXPORT
VOID
NdisAcquireReadWriteLock(
    IN  PNDIS_RW_LOCK           Lock,
    IN  BOOLEAN                 fWrite,         // TRUE -> Write, FALSE -> Read
    IN  PLOCK_STATE             LockState
    );


EXPORT
VOID
NdisReleaseReadWriteLock(
    IN  PNDIS_RW_LOCK           Lock,
    IN  PLOCK_STATE             LockState
    );


#define NdisInterlockedAddLargeStatistic(_Addend, _Increment)   \
    ExInterlockedAddLargeStatistic((PLARGE_INTEGER)_Addend, _Increment)

//
// S-List support
//

#define NdisInterlockedPushEntrySList(SListHead, SListEntry, Lock) \
    ExInterlockedPushEntrySList(SListHead, SListEntry, &(Lock)->SpinLock)

#define NdisInterlockedPopEntrySList(SListHead, Lock) \
    ExInterlockedPopEntrySList(SListHead, &(Lock)->SpinLock)

#define NdisInterlockedFlushSList(SListHead) ExInterlockedFlushSList(SListHead)

#define NdisInitializeSListHead(SListHead)  ExInitializeSListHead(SListHead)

#define NdisQueryDepthSList(SListHead)  ExQueryDepthSList(SListHead)

EXPORT
VOID
NdisGetCurrentProcessorCpuUsage(
    OUT PULONG                  pCpuUsage
    );

EXPORT
VOID
NdisGetCurrentProcessorCounts(
    OUT PULONG                  pIdleCount,
    OUT PULONG                  pKernelAndUser,
    OUT PULONG                  pIndex
    );

EXPORT
VOID
NdisGetSystemUpTime(
    OUT PULONG                  pSystemUpTime
    );

//
// List manipulation
//

/*++

VOID
NdisInitializeListHead(
    IN  PLIST_ENTRY ListHead
    );

--*/
#define NdisInitializeListHead(_ListHead) InitializeListHead(_ListHead)


//
// Configuration Requests
//

EXPORT
VOID
NdisOpenConfiguration(
    OUT PNDIS_STATUS            Status,
    OUT PNDIS_HANDLE            ConfigurationHandle,
    IN  NDIS_HANDLE             WrapperConfigurationContext
    );

EXPORT
VOID
NdisOpenConfigurationKeyByName(
    OUT PNDIS_STATUS            Status,
    IN  NDIS_HANDLE             ConfigurationHandle,
    IN  PNDIS_STRING            SubKeyName,
    OUT PNDIS_HANDLE            SubKeyHandle
    );

EXPORT
VOID
NdisOpenConfigurationKeyByIndex(
    OUT PNDIS_STATUS            Status,
    IN  NDIS_HANDLE             ConfigurationHandle,
    IN  ULONG                   Index,
    OUT PNDIS_STRING            KeyName,
    OUT PNDIS_HANDLE            KeyHandle
    );

EXPORT
VOID
NdisReadConfiguration(
    OUT PNDIS_STATUS            Status,
    OUT PNDIS_CONFIGURATION_PARAMETER *ParameterValue,
    IN  NDIS_HANDLE             ConfigurationHandle,
    IN  PNDIS_STRING            Keyword,
    IN  NDIS_PARAMETER_TYPE     ParameterType
    );

EXPORT
VOID
NdisWriteConfiguration(
    OUT PNDIS_STATUS            Status,
    IN  NDIS_HANDLE             ConfigurationHandle,
    IN  PNDIS_STRING            Keyword,
    IN  PNDIS_CONFIGURATION_PARAMETER ParameterValue
    );

EXPORT
VOID
NdisCloseConfiguration(
    IN  NDIS_HANDLE             ConfigurationHandle
    );

EXPORT
VOID
NdisReadNetworkAddress(
    OUT PNDIS_STATUS            Status,
    OUT PVOID *                 NetworkAddress,
    OUT PUINT                   NetworkAddressLength,
    IN  NDIS_HANDLE             ConfigurationHandle
    );

EXPORT
VOID
NdisReadEisaSlotInformation(
    OUT PNDIS_STATUS            Status,
    IN  NDIS_HANDLE             WrapperConfigurationContext,
    OUT PUINT                   SlotNumber,
    OUT PNDIS_EISA_FUNCTION_INFORMATION EisaData
    );

EXPORT
VOID
NdisReadEisaSlotInformationEx(
    OUT PNDIS_STATUS            Status,
    IN  NDIS_HANDLE             WrapperConfigurationContext,
    OUT PUINT                   SlotNumber,
    OUT PNDIS_EISA_FUNCTION_INFORMATION *EisaData,
    OUT PUINT                   NumberOfFunctions
    );

EXPORT
ULONG
NdisReadPciSlotInformation(
    IN  NDIS_HANDLE             NdisAdapterHandle,
    IN  ULONG                   SlotNumber,
    IN  ULONG                   Offset,
    IN  PVOID                   Buffer,
    IN  ULONG                   Length
    );

EXPORT
ULONG
NdisWritePciSlotInformation(
    IN  NDIS_HANDLE             NdisAdapterHandle,
    IN  ULONG                   SlotNumber,
    IN  ULONG                   Offset,
    IN  PVOID                   Buffer,
    IN  ULONG                   Length
    );

EXPORT
NDIS_STATUS
NdisPciAssignResources(
    IN  NDIS_HANDLE             NdisMacHandle,
    IN  NDIS_HANDLE             NdisWrapperHandle,
    IN  NDIS_HANDLE             WrapperConfigurationContext,
    IN  ULONG                   SlotNumber,
    OUT PNDIS_RESOURCE_LIST *   AssignedResources
    );

EXPORT
ULONG
NdisReadPcmciaAttributeMemory(
    IN NDIS_HANDLE              NdisAdapterHandle,
    IN ULONG                    Offset,
    IN PVOID                    Buffer,
    IN ULONG                    Length
    );

EXPORT
ULONG
NdisWritePcmciaAttributeMemory(
    IN NDIS_HANDLE              NdisAdapterHandle,
    IN ULONG                    Offset,
    IN PVOID                    Buffer,
    IN ULONG                    Length
    );

//
// Buffer Pool
//

EXPORT
VOID
NdisAllocateBufferPool(
    OUT PNDIS_STATUS            Status,
    OUT PNDIS_HANDLE            PoolHandle,
    IN  UINT                    NumberOfDescriptors
    );

EXPORT
VOID
NdisFreeBufferPool(
    IN  NDIS_HANDLE             PoolHandle
    );

EXPORT
VOID
NdisAllocateBuffer(
    OUT PNDIS_STATUS            Status,
    OUT PNDIS_BUFFER *          Buffer,
    IN  NDIS_HANDLE             PoolHandle,
    IN  PVOID                   VirtualAddress,
    IN  UINT                    Length
    );

EXPORT
VOID
NdisCopyBuffer(
    OUT PNDIS_STATUS            Status,
    OUT PNDIS_BUFFER *          Buffer,
    IN  NDIS_HANDLE             PoolHandle,
    IN  PVOID                   MemoryDescriptor,
    IN  UINT                    Offset,
    IN  UINT                    Length
    );


//
//  VOID
//  NdisCopyLookaheadData(
//      IN  PVOID               Destination,
//      IN  PVOID               Source,
//      IN  ULONG               Length,
//      IN  ULONG               ReceiveFlags
//      );
//

#if defined(_M_IX86) || defined(_M_AMD64)
#define NdisCopyLookaheadData(_Destination, _Source, _Length, _MacOptions)  \
        RtlCopyMemory(_Destination, _Source, _Length)
#else
#define NdisCopyLookaheadData(_Destination, _Source, _Length, _MacOptions)  \
    {                                                                       \
        if ((_MacOptions) & NDIS_MAC_OPTION_COPY_LOOKAHEAD_DATA)            \
        {                                                                   \
            RtlCopyMemory(_Destination, _Source, _Length);                  \
        }                                                                   \
        else                                                                \
        {                                                                   \
            PUCHAR _Src = (PUCHAR)(_Source);                                \
            PUCHAR _Dest = (PUCHAR)(_Destination);                          \
            PUCHAR _End = _Dest + (_Length);                                \
            while (_Dest < _End)                                            \
            {                                                               \
                *_Dest++ = *_Src++;                                         \
            }                                                               \
        }                                                                   \
    }
#endif

//
// Packet Pool
//
EXPORT
VOID
NdisAllocatePacketPool(
    OUT PNDIS_STATUS            Status,
    OUT PNDIS_HANDLE            PoolHandle,
    IN  UINT                    NumberOfDescriptors,
    IN  UINT                    ProtocolReservedLength
    );

EXPORT
VOID
NdisAllocatePacketPoolEx(
    OUT PNDIS_STATUS            Status,
    OUT PNDIS_HANDLE            PoolHandle,
    IN  UINT                    NumberOfDescriptors,
    IN  UINT                    NumberOfOverflowDescriptors,
    IN  UINT                    ProtocolReservedLength
    );

EXPORT
VOID
NdisSetPacketPoolProtocolId(
    IN  NDIS_HANDLE             PacketPoolHandle,
    IN  UINT                    ProtocolId
    );

EXPORT
UINT
NdisPacketPoolUsage(
    IN  NDIS_HANDLE             PoolHandle
    );

EXPORT
UINT
NdisPacketSize(
    IN  UINT                    ProtocolReservedSize
    );

EXPORT
NDIS_HANDLE
NdisGetPoolFromPacket(
    IN  PNDIS_PACKET            Packet
    );

EXPORT
PNDIS_PACKET_STACK
NdisIMGetCurrentPacketStack(
    IN  PNDIS_PACKET            Packet,
    OUT BOOLEAN *               StacksRemaining
    );

EXPORT
VOID
NdisFreePacketPool(
    IN  NDIS_HANDLE             PoolHandle
    );

EXPORT
VOID
NdisFreePacket(
    IN  PNDIS_PACKET            Packet
    );

EXPORT
VOID
NdisDprFreePacket(
    IN  PNDIS_PACKET            Packet
    );

EXPORT
VOID
NdisDprFreePacketNonInterlocked(
    IN  PNDIS_PACKET            Packet
    );


EXPORT
VOID
NdisAllocatePacket(
    OUT PNDIS_STATUS            Status,
    OUT PNDIS_PACKET *          Packet,
    IN  NDIS_HANDLE             PoolHandle
    );

EXPORT
VOID
NdisDprAllocatePacket(
    OUT PNDIS_STATUS            Status,
    OUT PNDIS_PACKET *          Packet,
    IN  NDIS_HANDLE             PoolHandle
    );

EXPORT
VOID
NdisDprAllocatePacketNonInterlocked(
    OUT PNDIS_STATUS            Status,
    OUT PNDIS_PACKET *          Packet,
    IN  NDIS_HANDLE             PoolHandle
    );

// VOID
// NdisReinitializePacket(
//  IN OUT PNDIS_PACKET         Packet
//  );
#define NdisReinitializePacket(Packet)                                      \
{                                                                           \
    (Packet)->Private.Head = (PNDIS_BUFFER)NULL;                            \
    (Packet)->Private.ValidCounts = FALSE;                                  \
}


//
// Block Pool APIs
//
typedef
VOID
(__stdcall *NDIS_BLOCK_INITIALIZER) (
    IN  PUCHAR                  Block,
    IN  SIZE_T                  NumberOfBytes
    );

NDIS_HANDLE
NdisCreateBlockPool(
    IN  USHORT                  BlockSize,
    IN  USHORT                  FreeBlockLinkOffset,
    IN  ULONG                   Tag,
    IN  NDIS_BLOCK_INITIALIZER  InitFunction OPTIONAL
    );

VOID
NdisDestroyBlockPool(
    IN  NDIS_HANDLE             BlockPoolHandle
    );

PUCHAR
NdisAllocateFromBlockPool(
    IN  NDIS_HANDLE             BlockPoolHandle
    );

VOID
NdisFreeToBlockPool(
    IN  PUCHAR                  Block
    );

#if BINARY_COMPATIBLE

EXPORT
VOID
NdisFreeBuffer(
    IN  PNDIS_BUFFER            Buffer
    );

EXPORT
VOID
NdisQueryBuffer(
    IN  PNDIS_BUFFER            Buffer,
    OUT PVOID *                 VirtualAddress OPTIONAL,
    OUT PUINT                   Length
    );

EXPORT
VOID
NdisQueryBufferSafe(
    IN  PNDIS_BUFFER            Buffer,
    OUT PVOID *                 VirtualAddress OPTIONAL,
    OUT PUINT                   Length,
    IN  MM_PAGE_PRIORITY        Priority
    );

EXPORT
VOID
NdisQueryBufferOffset(
    IN  PNDIS_BUFFER            Buffer,
    OUT PUINT                   Offset,
    OUT PUINT                   Length
    );

//
// This is a combination of NdisQueryPacket and NdisQueryBuffer and
// optimized for protocols to get the first Buffer, its VA and its size.
//
VOID
NdisGetFirstBufferFromPacket(
    IN  PNDIS_PACKET            Packet,
    OUT PNDIS_BUFFER *          FirstBuffer,
    OUT PVOID *                 FirstBufferVA,
    OUT PUINT                   FirstBufferLength,
    OUT PUINT                   TotalBufferLength
    );

VOID
NdisGetFirstBufferFromPacketSafe(
    IN  PNDIS_PACKET            Packet,
    OUT PNDIS_BUFFER *          FirstBuffer,
    OUT PVOID *                 FirstBufferVA,
    OUT PUINT                   FirstBufferLength,
    OUT PUINT                   TotalBufferLength,
    IN  MM_PAGE_PRIORITY        Priority
    );


//
// This is used to determine how many physical pieces
// an NDIS_BUFFER will take up when mapped.
//

EXPORT
ULONG
NDIS_BUFFER_TO_SPAN_PAGES(
    IN  PNDIS_BUFFER                Buffer
    );

EXPORT
VOID
NdisGetBufferPhysicalArraySize(
    IN  PNDIS_BUFFER                Buffer,
    OUT PUINT                       ArraySize
    );

#else // BINARY_COMPATIBLE

#define NdisFreeBuffer(Buffer)  IoFreeMdl(Buffer)

#define NdisQueryBuffer(_Buffer, _VirtualAddress, _Length)                  \
{                                                                           \
    if (ARGUMENT_PRESENT(_VirtualAddress))                                  \
    {                                                                       \
        *(PVOID *)(_VirtualAddress) = MmGetSystemAddressForMdl(_Buffer);    \
    }                                                                       \
    *(_Length) = MmGetMdlByteCount(_Buffer);                                \
}

#define NdisQueryBufferSafe(_Buffer, _VirtualAddress, _Length, _Priority)   \
{                                                                           \
    if (ARGUMENT_PRESENT(_VirtualAddress))                                  \
    {                                                                       \
        *(PVOID *)(_VirtualAddress) = MmGetSystemAddressForMdlSafe(_Buffer, _Priority); \
    }                                                                       \
    *(_Length) = MmGetMdlByteCount(_Buffer);                                \
}

#define NdisQueryBufferOffset(_Buffer, _Offset, _Length)                    \
{                                                                           \
    *(_Offset) = MmGetMdlByteOffset(_Buffer);                               \
    *(_Length) = MmGetMdlByteCount(_Buffer);                                \
}


#define NdisGetFirstBufferFromPacket(_Packet,                               \
                                     _FirstBuffer,                          \
                                     _FirstBufferVA,                        \
                                     _FirstBufferLength,                    \
                                     _TotalBufferLength)                    \
    {                                                                       \
        PNDIS_BUFFER    _pBuf;                                              \
                                                                            \
        _pBuf = (_Packet)->Private.Head;                                    \
        *(_FirstBuffer) = _pBuf;                                            \
        if (_pBuf)                                                          \
        {                                                                   \
            *(_FirstBufferVA) = MmGetSystemAddressForMdl(_pBuf);            \
            *(_FirstBufferLength) =                                         \
            *(_TotalBufferLength) = MmGetMdlByteCount(_pBuf);               \
            for (_pBuf = _pBuf->Next;                                       \
                 _pBuf != NULL;                                             \
                 _pBuf = _pBuf->Next)                                       \
            {                                                               \
                *(_TotalBufferLength) += MmGetMdlByteCount(_pBuf);          \
            }                                                               \
        }                                                                   \
        else                                                                \
        {                                                                   \
            *(_FirstBufferVA) = 0;                                          \
            *(_FirstBufferLength) = 0;                                      \
            *(_TotalBufferLength) = 0;                                      \
        }                                                                   \
    }

#define NdisGetFirstBufferFromPacketSafe(_Packet,                           \
                                         _FirstBuffer,                      \
                                         _FirstBufferVA,                    \
                                         _FirstBufferLength,                \
                                         _TotalBufferLength,                \
                                         _Priority)                         \
    {                                                                       \
        PNDIS_BUFFER    _pBuf;                                              \
                                                                            \
        _pBuf = (_Packet)->Private.Head;                                    \
        *(_FirstBuffer) = _pBuf;                                            \
        if (_pBuf)                                                          \
        {                                                                   \
            *(_FirstBufferVA) = MmGetSystemAddressForMdlSafe(_pBuf, _Priority); \
            *(_FirstBufferLength) = *(_TotalBufferLength) = MmGetMdlByteCount(_pBuf); \
            for (_pBuf = _pBuf->Next;                                       \
                 _pBuf != NULL;                                             \
                 _pBuf = _pBuf->Next)                                       \
            {                                                               \
                *(_TotalBufferLength) += MmGetMdlByteCount(_pBuf);          \
            }                                                               \
        }                                                                   \
        else                                                                \
        {                                                                   \
            *(_FirstBufferVA) = 0;                                          \
            *(_FirstBufferLength) = 0;                                      \
            *(_TotalBufferLength) = 0;                                      \
        }                                                                   \
    }


#define NDIS_BUFFER_TO_SPAN_PAGES(_Buffer)                                  \
    (MmGetMdlByteCount(_Buffer)==0 ?                                        \
                1 :                                                         \
                (COMPUTE_PAGES_SPANNED(                                     \
                        MmGetMdlVirtualAddress(_Buffer),                    \
                        MmGetMdlByteCount(_Buffer))))

#define NdisGetBufferPhysicalArraySize(Buffer, ArraySize)                   \
    (*(ArraySize) = NDIS_BUFFER_TO_SPAN_PAGES(Buffer))

#endif // BINARY_COMPATIBLE


/*++

NDIS_BUFFER_LINKAGE(
    IN  PNDIS_BUFFER            Buffer
    );

--*/

#define NDIS_BUFFER_LINKAGE(Buffer) ((Buffer)->Next)


/*++

VOID
NdisRecalculatePacketCounts(
    IN OUT PNDIS_PACKET         Packet
    );

--*/

#define NdisRecalculatePacketCounts(Packet)                                 \
{                                                                           \
    {                                                                       \
        PNDIS_BUFFER TmpBuffer = (Packet)->Private.Head;                    \
        if (TmpBuffer)                                                      \
        {                                                                   \
            while (TmpBuffer->Next)                                         \
            {                                                               \
                TmpBuffer = TmpBuffer->Next;                                \
            }                                                               \
            (Packet)->Private.Tail = TmpBuffer;                             \
        }                                                                   \
        (Packet)->Private.ValidCounts = FALSE;                              \
    }                                                                       \
}


/*++

VOID
NdisChainBufferAtFront(
    IN OUT PNDIS_PACKET         Packet,
    IN OUT PNDIS_BUFFER         Buffer
    );

--*/

#define NdisChainBufferAtFront(Packet, Buffer)                              \
{                                                                           \
    PNDIS_BUFFER TmpBuffer = (Buffer);                                      \
                                                                            \
    for (;;)                                                                \
    {                                                                       \
        if (TmpBuffer->Next == (PNDIS_BUFFER)NULL)                          \
            break;                                                          \
        TmpBuffer = TmpBuffer->Next;                                        \
    }                                                                       \
    if ((Packet)->Private.Head == NULL)                                     \
    {                                                                       \
        (Packet)->Private.Tail = TmpBuffer;                                 \
    }                                                                       \
    TmpBuffer->Next = (Packet)->Private.Head;                               \
    (Packet)->Private.Head = (Buffer);                                      \
    (Packet)->Private.ValidCounts = FALSE;                                  \
}

/*++

VOID
NdisChainBufferAtBack(
    IN OUT PNDIS_PACKET         Packet,
    IN OUT PNDIS_BUFFER         Buffer
    );

--*/

#define NdisChainBufferAtBack(Packet, Buffer)                               \
{                                                                           \
    PNDIS_BUFFER TmpBuffer = (Buffer);                                      \
                                                                            \
    for (;;)                                                                \
    {                                                                       \
        if (TmpBuffer->Next == NULL)                                        \
            break;                                                          \
        TmpBuffer = TmpBuffer->Next;                                        \
    }                                                                       \
    if ((Packet)->Private.Head != NULL)                                     \
    {                                                                       \
        (Packet)->Private.Tail->Next = (Buffer);                            \
    }                                                                       \
    else                                                                    \
    {                                                                       \
        (Packet)->Private.Head = (Buffer);                                  \
    }                                                                       \
    (Packet)->Private.Tail = TmpBuffer;                                     \
    (Packet)->Private.ValidCounts = FALSE;                                  \
}

EXPORT
VOID
NdisUnchainBufferAtFront(
    IN OUT PNDIS_PACKET         Packet,
    OUT PNDIS_BUFFER *          Buffer
    );

EXPORT
VOID
NdisUnchainBufferAtBack(
    IN OUT PNDIS_PACKET         Packet,
    OUT PNDIS_BUFFER *          Buffer
    );


/*++

VOID
NdisQueryPacket(
    IN  PNDIS_PACKET            _Packet,
    OUT PUINT                   _PhysicalBufferCount OPTIONAL,
    OUT PUINT                   _BufferCount OPTIONAL,
    OUT PNDIS_BUFFER *          _FirstBuffer OPTIONAL,
    OUT PUINT                   _TotalPacketLength OPTIONAL
    );

--*/

#define NdisQueryPacket(_Packet,                                            \
                        _PhysicalBufferCount,                               \
                        _BufferCount,                                       \
                        _FirstBuffer,                                       \
                        _TotalPacketLength)                                 \
{                                                                           \
    if ((_FirstBuffer) != NULL)                                             \
    {                                                                       \
        PNDIS_BUFFER * __FirstBuffer = (_FirstBuffer);                      \
        *(__FirstBuffer) = (_Packet)->Private.Head;                         \
    }                                                                       \
    if ((_TotalPacketLength) || (_BufferCount) || (_PhysicalBufferCount))   \
    {                                                                       \
        if (!(_Packet)->Private.ValidCounts)                                \
        {                                                                   \
            PNDIS_BUFFER TmpBuffer = (_Packet)->Private.Head;               \
            UINT PTotalLength = 0, PPhysicalCount = 0, PAddedCount = 0;     \
            UINT PacketLength, Offset;                                      \
                                                                            \
            while (TmpBuffer != (PNDIS_BUFFER)NULL)                         \
            {                                                               \
                NdisQueryBufferOffset(TmpBuffer, &Offset, &PacketLength);   \
                PTotalLength += PacketLength;                               \
                PPhysicalCount += (UINT)NDIS_BUFFER_TO_SPAN_PAGES(TmpBuffer);\
                ++PAddedCount;                                              \
                TmpBuffer = TmpBuffer->Next;                                \
            }                                                               \
            (_Packet)->Private.Count = PAddedCount;                         \
            (_Packet)->Private.TotalLength = PTotalLength;                  \
            (_Packet)->Private.PhysicalCount = PPhysicalCount;              \
            (_Packet)->Private.ValidCounts = TRUE;                          \
        }                                                                   \
                                                                            \
        if (_PhysicalBufferCount)                                           \
        {                                                                   \
            PUINT __PhysicalBufferCount = (_PhysicalBufferCount);           \
            *(__PhysicalBufferCount) = (_Packet)->Private.PhysicalCount;    \
        }                                                                   \
        if (_BufferCount)                                                   \
        {                                                                   \
            PUINT __BufferCount = (_BufferCount);                           \
            *(__BufferCount) = (_Packet)->Private.Count;                    \
        }                                                                   \
        if (_TotalPacketLength)                                             \
        {                                                                   \
            PUINT __TotalPacketLength = (_TotalPacketLength);               \
            *(__TotalPacketLength) = (_Packet)->Private.TotalLength;        \
        }                                                                   \
    }                                                                       \
}


/*++

VOID
NdisQueryPacketLength(
    IN  PNDIS_PACKET            _Packet,
    OUT PUINT                   _TotalPacketLength OPTIONAL
    );

--*/

#define NdisQueryPacketLength(_Packet,                                      \
                              _TotalPacketLength)                           \
{                                                                           \
    if (!(_Packet)->Private.ValidCounts)                                    \
    {                                                                       \
        NdisQueryPacket(_Packet, NULL, NULL, NULL, _TotalPacketLength);     \
    }                                                                       \
    else *(_TotalPacketLength) = (_Packet)->Private.TotalLength;            \
}


/*++

VOID
NdisGetNextBuffer(
    IN  PNDIS_BUFFER            CurrentBuffer,
    OUT PNDIS_BUFFER *          NextBuffer
    );

--*/

#define NdisGetNextBuffer(CurrentBuffer, NextBuffer)                        \
{                                                                           \
    *(NextBuffer) = (CurrentBuffer)->Next;                                  \
}

#if BINARY_COMPATIBLE

VOID
NdisAdjustBufferLength(
    IN  PNDIS_BUFFER            Buffer,
    IN  UINT                    Length
    );

#else // BINARY_COMPATIBLE

#define NdisAdjustBufferLength(Buffer, Length)  (((Buffer)->ByteCount) = (Length))

#endif // BINARY_COMPATIBLE

EXPORT
VOID
NdisCopyFromPacketToPacket(
    IN  PNDIS_PACKET            Destination,
    IN  UINT                    DestinationOffset,
    IN  UINT                    BytesToCopy,
    IN  PNDIS_PACKET            Source,
    IN  UINT                    SourceOffset,
    OUT PUINT                   BytesCopied
    );

EXPORT
VOID
NdisCopyFromPacketToPacketSafe(
    IN  PNDIS_PACKET            Destination,
    IN  UINT                    DestinationOffset,
    IN  UINT                    BytesToCopy,
    IN  PNDIS_PACKET            Source,
    IN  UINT                    SourceOffset,
    OUT PUINT                   BytesCopied,
    IN  MM_PAGE_PRIORITY        Priority
    );

EXPORT
NDIS_STATUS
NdisAllocateMemory(
    OUT PVOID *                 VirtualAddress,
    IN  UINT                    Length,
    IN  UINT                    MemoryFlags,
    IN  NDIS_PHYSICAL_ADDRESS   HighestAcceptableAddress
    );

EXPORT
NDIS_STATUS
NdisAllocateMemoryWithTag(
    OUT PVOID *                 VirtualAddress,
    IN  UINT                    Length,
    IN  ULONG                   Tag
    );

EXPORT
VOID
NdisFreeMemory(
    IN  PVOID                   VirtualAddress,
    IN  UINT                    Length,
    IN  UINT                    MemoryFlags
    );


/*++
VOID
NdisStallExecution(
    IN  UINT                    MicrosecondsToStall
    )
--*/

#define NdisStallExecution(MicroSecondsToStall)     KeStallExecutionProcessor(MicroSecondsToStall)


EXPORT
VOID
NdisInitializeEvent(
    IN  PNDIS_EVENT             Event
);

EXPORT
VOID
NdisSetEvent(
    IN  PNDIS_EVENT             Event
);

EXPORT
VOID
NdisResetEvent(
    IN  PNDIS_EVENT             Event
);

EXPORT
BOOLEAN
NdisWaitEvent(
    IN  PNDIS_EVENT             Event,
    IN  UINT                    msToWait
);

/*++
VOID
NdisInitializeWorkItem(
    IN  PNDIS_WORK_ITEM         WorkItem,
    IN  NDIS_PROC               Routine,
    IN  PVOID                   Context
    );
--*/

#define NdisInitializeWorkItem(_WI_, _R_, _C_)  \
    {                                           \
        (_WI_)->Context = _C_;                  \
        (_WI_)->Routine = _R_;                  \
    }

EXPORT
NDIS_STATUS
NdisScheduleWorkItem(
    IN  PNDIS_WORK_ITEM         WorkItem
    );

//
// Simple I/O support
//

EXPORT
VOID
NdisOpenFile(
    OUT PNDIS_STATUS            Status,
    OUT PNDIS_HANDLE            FileHandle,
    OUT PUINT                   FileLength,
    IN  PNDIS_STRING            FileName,
    IN  NDIS_PHYSICAL_ADDRESS   HighestAcceptableAddress
    );

EXPORT
VOID
NdisCloseFile(
    IN  NDIS_HANDLE             FileHandle
    );

EXPORT
VOID
NdisMapFile(
    OUT PNDIS_STATUS            Status,
    OUT PVOID *                 MappedBuffer,
    IN  NDIS_HANDLE             FileHandle
    );

EXPORT
VOID
NdisUnmapFile(
    IN  NDIS_HANDLE             FileHandle
    );


//
// Portability extensions
//

/*++
VOID
NdisFlushBuffer(
    IN  PNDIS_BUFFER            Buffer,
    IN  BOOLEAN                 WriteToDevice
    )
--*/

#define NdisFlushBuffer(Buffer,WriteToDevice)                               \
        KeFlushIoBuffers((Buffer),!(WriteToDevice), TRUE)

EXPORT
ULONG
NdisGetSharedDataAlignment(
    VOID
    );


//
// Write Port
//

/*++
VOID
NdisWritePortUchar(
    IN  NDIS_HANDLE             NdisAdapterHandle,
    IN  ULONG                   Port,
    IN  UCHAR                   Data
    )
--*/
#define NdisWritePortUchar(Handle,Port,Data)                                \
        WRITE_PORT_UCHAR((PUCHAR)(NDIS_PORT_TO_PORT(Handle,Port)),(UCHAR)(Data))

/*++
VOID
NdisWritePortUshort(
    IN  NDIS_HANDLE             NdisAdapterHandle,
    IN  ULONG                   Port,
    IN  USHORT                  Data
    )
--*/
#define NdisWritePortUshort(Handle,Port,Data)                               \
        WRITE_PORT_USHORT((PUSHORT)(NDIS_PORT_TO_PORT(Handle,Port)),(USHORT)(Data))


/*++
VOID
NdisWritePortUlong(
    IN  NDIS_HANDLE             NdisAdapterHandle,
    IN  ULONG                   Port,
    IN  ULONG                   Data
    )
--*/
#define NdisWritePortUlong(Handle,Port,Data)                                \
        WRITE_PORT_ULONG((PULONG)(NDIS_PORT_TO_PORT(Handle,Port)),(ULONG)(Data))


//
// Write Port Buffers
//

/*++
VOID
NdisWritePortBufferUchar(
    IN  NDIS_HANDLE             NdisAdapterHandle,
    IN  ULONG                   Port,
    IN  PUCHAR                  Buffer,
    IN  ULONG                   Length
    )
--*/
#define NdisWritePortBufferUchar(Handle,Port,Buffer,Length)                 \
        NdisRawWritePortBufferUchar(NDIS_PORT_TO_PORT((Handle),(Port)),(Buffer),(Length))

/*++
VOID
NdisWritePortBufferUshort(
    IN  NDIS_HANDLE             NdisAdapterHandle,
    IN  ULONG                   Port,
    IN  PUSHORT                 Buffer,
    IN  ULONG                   Length
    )
--*/
#define NdisWritePortBufferUshort(Handle,Port,Buffer,Length)                \
        NdisRawWritePortBufferUshort(NDIS_PORT_TO_PORT((Handle),(Port)),(Buffer),(Length))


/*++
VOID
NdisWritePortBufferUlong(
    IN  NDIS_HANDLE             NdisAdapterHandle,
    IN  ULONG                   Port,
    IN  PULONG                  Buffer,
    IN  ULONG                   Length
    )
--*/
#define NdisWritePortBufferUlong(Handle,Port,Buffer,Length)                 \
        NdisRawWritePortBufferUlong(NDIS_PORT_TO_PORT((Handle),(Port)),(Buffer),(Length))


//
// Read Ports
//

/*++
VOID
NdisReadPortUchar(
    IN  NDIS_HANDLE             NdisAdapterHandle,
    IN  ULONG                   Port,
    OUT PUCHAR                  Data
    )
--*/
#define NdisReadPortUchar(Handle,Port, Data)                                \
        NdisRawReadPortUchar(NDIS_PORT_TO_PORT((Handle),(Port)),(Data))

/*++
VOID
NdisReadPortUshort(
    IN  NDIS_HANDLE             NdisAdapterHandle,
    IN  ULONG                   Port,
    OUT PUSHORT                 Data
    )
--*/
#define NdisReadPortUshort(Handle,Port,Data)                                \
        NdisRawReadPortUshort(NDIS_PORT_TO_PORT((Handle),(Port)),(Data))


/*++
VOID
NdisReadPortUlong(
    IN  NDIS_HANDLE             NdisAdapterHandle,
    IN  ULONG                   Port,
    OUT PULONG                  Data
    )
--*/
#define NdisReadPortUlong(Handle,Port,Data)                                 \
        NdisRawReadPortUlong(NDIS_PORT_TO_PORT((Handle),(Port)),(Data))

//
// Read Buffer Ports
//

/*++
VOID
NdisReadPortBufferUchar(
    IN  NDIS_HANDLE             NdisAdapterHandle,
    IN  ULONG                   Port,
    OUT PUCHAR                  Buffer,
    IN  ULONG                   Length
    )
--*/
#define NdisReadPortBufferUchar(Handle,Port,Buffer,Length)                  \
        NdisRawReadPortBufferUchar(NDIS_PORT_TO_PORT((Handle),(Port)),(Buffer),(Length))

/*++
VOID
NdisReadPortBufferUshort(
    IN  NDIS_HANDLE             NdisAdapterHandle,
    IN  ULONG                   Port,
    OUT PUSHORT                 Buffer,
    IN  ULONG                   Length
    )
--*/
#define NdisReadPortBufferUshort(Handle,Port,Buffer,Length)                 \
        NdisRawReadPortBufferUshort(NDIS_PORT_TO_PORT((Handle),(Port)),(Buffer),(Length))

/*++
VOID
NdisReadPortBufferUlong(
    IN  NDIS_HANDLE             NdisAdapterHandle,
    IN  ULONG                   Port,
    OUT PULONG                  Buffer,
    IN  ULONG                   Length
    )
--*/
#define NdisReadPortBufferUlong(Handle,Port,Buffer)                         \
        NdisRawReadPortBufferUlong(NDIS_PORT_TO_PORT((Handle),(Port)),(Buffer),(Length))

//
// Raw Routines
//

//
// Write Port Raw
//

/*++
VOID
NdisRawWritePortUchar(
    IN  ULONG_PTR               Port,
    IN  UCHAR                   Data
    )
--*/
#define NdisRawWritePortUchar(Port,Data)                                    \
        WRITE_PORT_UCHAR((PUCHAR)(Port),(UCHAR)(Data))

/*++
VOID
NdisRawWritePortUshort(
    IN  ULONG_PTR               Port,
    IN  USHORT                  Data
    )
--*/
#define NdisRawWritePortUshort(Port,Data)                                   \
        WRITE_PORT_USHORT((PUSHORT)(Port),(USHORT)(Data))

/*++
VOID
NdisRawWritePortUlong(
    IN  ULONG_PTR               Port,
    IN  ULONG                   Data
    )
--*/
#define NdisRawWritePortUlong(Port,Data)                                    \
        WRITE_PORT_ULONG((PULONG)(Port),(ULONG)(Data))


//
// Raw Write Port Buffers
//

/*++
VOID
NdisRawWritePortBufferUchar(
    IN  ULONG_PTR               Port,
    IN  PUCHAR                  Buffer,
    IN  ULONG                   Length
    )
--*/
#define NdisRawWritePortBufferUchar(Port,Buffer,Length) \
        WRITE_PORT_BUFFER_UCHAR((PUCHAR)(Port),(PUCHAR)(Buffer),(Length))

/*++
VOID
NdisRawWritePortBufferUshort(
    IN  ULONG_PTR               Port,
    IN  PUSHORT                 Buffer,
    IN  ULONG                   Length
    )
--*/
#if defined(_M_IX86) || defined(_M_AMD64)
#define NdisRawWritePortBufferUshort(Port,Buffer,Length)                    \
        WRITE_PORT_BUFFER_USHORT((PUSHORT)(Port),(PUSHORT)(Buffer),(Length))
#else
#define NdisRawWritePortBufferUshort(Port,Buffer,Length)                    \
{                                                                           \
        ULONG_PTR _Port = (ULONG_PTR)(Port);                                \
        PUSHORT _Current = (Buffer);                                        \
        PUSHORT _End = _Current + (Length);                                 \
        for ( ; _Current < _End; ++_Current)                                \
        {                                                                   \
            WRITE_PORT_USHORT((PUSHORT)_Port,*(UNALIGNED USHORT *)_Current);\
        }                                                                   \
}
#endif


/*++
VOID
NdisRawWritePortBufferUlong(
    IN  ULONG_PTR               Port,
    IN  PULONG                  Buffer,
    IN  ULONG                   Length
    )
--*/
#if defined(_M_IX86) || defined(_M_AMD64)
#define NdisRawWritePortBufferUlong(Port,Buffer,Length)                     \
        WRITE_PORT_BUFFER_ULONG((PULONG)(Port),(PULONG)(Buffer),(Length))
#else
#define NdisRawWritePortBufferUlong(Port,Buffer,Length)                     \
{                                                                           \
        ULONG_PTR _Port = (ULONG_PTR)(Port);                                \
        PULONG _Current = (Buffer);                                         \
        PULONG _End = _Current + (Length);                                  \
        for ( ; _Current < _End; ++_Current)                                \
        {                                                                   \
            WRITE_PORT_ULONG((PULONG)_Port,*(UNALIGNED ULONG *)_Current);   \
        }                                                                   \
}
#endif


//
// Raw Read Ports
//

/*++
VOID
NdisRawReadPortUchar(
    IN  ULONG_PTR               Port,
    OUT PUCHAR                  Data
    )
--*/
#define NdisRawReadPortUchar(Port, Data) \
        *(Data) = READ_PORT_UCHAR((PUCHAR)(Port))

/*++
VOID
NdisRawReadPortUshort(
    IN  ULONG_PTR               Port,
    OUT PUSHORT                 Data
    )
--*/
#define NdisRawReadPortUshort(Port,Data) \
        *(Data) = READ_PORT_USHORT((PUSHORT)(Port))

/*++
VOID
NdisRawReadPortUlong(
    IN  ULONG_PTR               Port,
    OUT PULONG                  Data
    )
--*/
#define NdisRawReadPortUlong(Port,Data) \
        *(Data) = READ_PORT_ULONG((PULONG)(Port))


//
// Raw Read Buffer Ports
//

/*++
VOID
NdisRawReadPortBufferUchar(
    IN  ULONG_PTR               Port,
    OUT PUCHAR                  Buffer,
    IN  ULONG                   Length
    )
--*/
#define NdisRawReadPortBufferUchar(Port,Buffer,Length)                      \
        READ_PORT_BUFFER_UCHAR((PUCHAR)(Port),(PUCHAR)(Buffer),(Length))


/*++
VOID
NdisRawReadPortBufferUshort(
    IN  ULONG_PTR               Port,
    OUT PUSHORT                 Buffer,
    IN  ULONG                   Length
    )
--*/
#if defined(_M_IX86) || defined(_M_AMD64)
#define NdisRawReadPortBufferUshort(Port,Buffer,Length)                     \
        READ_PORT_BUFFER_USHORT((PUSHORT)(Port),(PUSHORT)(Buffer),(Length))
#else
#define NdisRawReadPortBufferUshort(Port,Buffer,Length)                     \
{                                                                           \
        ULONG_PTR _Port = (ULONG_PTR)(Port);                                \
        PUSHORT _Current = (Buffer);                                        \
        PUSHORT _End = _Current + (Length);                                 \
        for ( ; _Current < _End; ++_Current)                                \
        {                                                                   \
            *(UNALIGNED USHORT *)_Current = READ_PORT_USHORT((PUSHORT)_Port); \
        }                                                                   \
}
#endif


/*++
VOID
NdisRawReadPortBufferUlong(
    IN  ULONG_PTR               Port,
    OUT PULONG                  Buffer,
    IN  ULONG                   Length
    )
--*/
#if defined(_M_IX86) || defined(_M_AMD64)
#define NdisRawReadPortBufferUlong(Port,Buffer,Length)                      \
        READ_PORT_BUFFER_ULONG((PULONG)(Port),(PULONG)(Buffer),(Length))
#else
#define NdisRawReadPortBufferUlong(Port,Buffer,Length)                      \
{                                                                           \
        ULONG_PTR _Port = (ULONG_PTR)(Port);                                \
        PULONG _Current = (Buffer);                                         \
        PULONG _End = _Current + (Length);                                  \
        for ( ; _Current < _End; ++_Current)                                \
        {                                                                   \
            *(UNALIGNED ULONG *)_Current = READ_PORT_ULONG((PULONG)_Port);  \
        }                                                                   \
}
#endif


//
// Write Registers
//

/*++
VOID
NdisWriteRegisterUchar(
    IN  PUCHAR                  Register,
    IN  UCHAR                   Data
    )
--*/

#if defined(_M_IX86) || defined(_M_AMD64)
#define NdisWriteRegisterUchar(Register,Data)                               \
        WRITE_REGISTER_UCHAR((Register),(Data))
#else
#define NdisWriteRegisterUchar(Register,Data)                               \
    {                                                                       \
        WRITE_REGISTER_UCHAR((Register),(Data));                            \
        READ_REGISTER_UCHAR(Register);                                      \
    }
#endif

/*++
VOID
NdisWriteRegisterUshort(
    IN  PUCHAR                  Register,
    IN  USHORT                  Data
    )
--*/

#if defined(_M_IX86) || defined(_M_AMD64)
#define NdisWriteRegisterUshort(Register,Data)                              \
        WRITE_REGISTER_USHORT((Register),(Data))
#else
#define NdisWriteRegisterUshort(Register,Data)                              \
    {                                                                       \
        WRITE_REGISTER_USHORT((Register),(Data));                           \
        READ_REGISTER_USHORT(Register);                                     \
    }
#endif

/*++
VOID
NdisWriteRegisterUlong(
    IN  PUCHAR                  Register,
    IN  ULONG                   Data
    )
--*/

#if defined(_M_IX86) || defined(_M_AMD64)
#define NdisWriteRegisterUlong(Register,Data)   WRITE_REGISTER_ULONG((Register),(Data))
#else
#define NdisWriteRegisterUlong(Register,Data)                               \
    {                                                                       \
        WRITE_REGISTER_ULONG((Register),(Data));                            \
        READ_REGISTER_ULONG(Register);                                      \
    }
#endif

/*++
VOID
NdisReadRegisterUchar(
    IN  PUCHAR                  Register,
    OUT PUCHAR                  Data
    )
--*/
#if defined(_M_IX86) || defined(_M_AMD64)
#define NdisReadRegisterUchar(Register,Data)    *(Data) = *((volatile UCHAR * const)(Register))
#else
#define NdisReadRegisterUchar(Register,Data)    *(Data) = READ_REGISTER_UCHAR((PUCHAR)(Register))
#endif

/*++
VOID
NdisReadRegisterUshort(
    IN  PUSHORT                 Register,
    OUT PUSHORT                 Data
    )
--*/
#if defined(_M_IX86) || defined(_M_AMD64)
#define NdisReadRegisterUshort(Register,Data)   *(Data) = *((volatile USHORT * const)(Register))
#else
#define NdisReadRegisterUshort(Register,Data)   *(Data) = READ_REGISTER_USHORT((PUSHORT)(Register))
#endif

/*++
VOID
NdisReadRegisterUlong(
    IN  PULONG                  Register,
    OUT PULONG                  Data
    )
--*/
#if defined(_M_IX86) || defined(_M_AMD64)
#define NdisReadRegisterUlong(Register,Data)    *(Data) = *((volatile ULONG * const)(Register))
#else
#define NdisReadRegisterUlong(Register,Data)    *(Data) = READ_REGISTER_ULONG((PULONG)(Register))
#endif

#define NdisEqualAnsiString(_String1,_String2, _CaseInsensitive)            \
            RtlEqualAnsiString(_String1, _String2, _CaseInsensitive)

#define NdisEqualString(_String1, _String2, _CaseInsensitive)               \
            RtlEqualUnicodeString(_String1, _String2, _CaseInsensitive)

#define NdisEqualUnicodeString(_String1, _String2, _CaseInsensitive)        \
            RtlEqualUnicodeString(_String1, _String2, _CaseInsensitive)

EXPORT
VOID __cdecl
NdisWriteErrorLogEntry(
    IN  NDIS_HANDLE             NdisAdapterHandle,
    IN  NDIS_ERROR_CODE         ErrorCode,
    IN  ULONG                   NumberOfErrorValues,
    ...
    );

EXPORT
VOID
NdisInitializeString(
    OUT PNDIS_STRING    Destination,
    IN  PUCHAR          Source
    );

#define NdisFreeString(String) NdisFreeMemory((String).Buffer,