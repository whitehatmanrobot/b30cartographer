

	rgdata[iMSO_PgnoFDP].SetPv(			(BYTE *)&pgnoLVFDP );
	rgdata[iMSO_PgnoFDP].SetCb(			sizeof(pgnoLVFDP) );

	rgdata[iMSO_SpaceUsage].SetPv(		(BYTE *)&ulDensity );
	rgdata[iMSO_SpaceUsage].SetCb(		sizeof(ulDensity) );

	rgdata[iMSO_Flags].SetPv(			(BYTE *)&ulFlagsNil );
	rgdata[iMSO_Flags].SetCb(			sizeof(ulFlagsNil) );

	rgdata[iMSO_Pages].SetPv(			(BYTE *)&ulPages );
	rgdata[iMSO_Pages].SetCb(			sizeof(ulPages) );
	
	return ErrCATInsert( ppib, pfucbCatalog, rgdata, iMSO_Pages );
	}


//  ================================================================
ERR ErrCATAddTableCallback(
	PIB					*ppib,
	FUCB				*pfucbCatalog,
	const OBJID			objidTable,
	const JET_CBTYP		cbtyp,
	const CHAR * const	szCallback )
//  ================================================================
	{
	Assert( objidNil != objidTable );
	Assert( NULL != szCallback );
	Assert( cbtyp > JET_cbtypNull );
	
	DATA			rgdata[idataMSOMax];
	const SYSOBJ	sysobj				= sysobjCallback;
	const ULONG		ulId				= sysobjCallback;
	const ULONG		ulFlags				= cbtyp;
	const ULONG		ulNil				= 0;
			
	//	must zero out to ensure unused fields are ignored
	memset( rgdata, 0, sizeof(rgdata) );

	rgdata[iMSO_ObjidTable].SetPv(		(BYTE *)&objidTable );
	rgdata[iMSO_ObjidTable].SetCb(		sizeof(objidTable) );

	rgdata[iMSO_Type].SetPv(			(BYTE *)&sysobj );
	rgdata[iMSO_Type].SetCb(			sizeof(sysobj) );

	rgdata[iMSO_Id].SetPv(				(BYTE *)&ulId );
	rgdata[iMSO_Id].SetCb(				sizeof(ulId) );

	rgdata[iMSO_Name].SetPv(			(BYTE *)szTableCallback );
	rgdata[iMSO_Name].SetCb(			cbTableCallback );

	rgdata[iMSO_PgnoFDP].SetPv(			(BYTE *)&ulNil );
	rgdata[iMSO_PgnoFDP].SetCb(			sizeof(ulNil) );

	rgdata[iMSO_SpaceUsage].SetPv(		(BYTE *)&ulNil );
	rgdata[iMSO_SpaceUsage].SetCb(		sizeof(ulNil) );

	rgdata[iMSO_Flags].SetPv(			(BYTE *)&ulFlags );
	rgdata[iMSO_Flags].SetCb(			sizeof(ulFlags) );
	
	rgdata[iMSO_Pages].SetPv(			(BYTE *)&ulNil );
	rgdata[iMSO_Pages].SetCb(			sizeof(ulNil) );
	
	rgdata[iMSO_Callback].SetPv(		(BYTE *)szCallback );
	rgdata[iMSO_Callback].SetCb(		strlen( szCallback ) );
	
	return ErrCATInsert( ppib, pfucbCatalog, rgdata, iMSO_Pages );
	}


LOCAL ERR ErrCATISeekTable(
	PIB			*ppib,
	FUCB		*pfucbCatalog,
	const CHAR	*szTableName )
	{
	ERR			err;
	const BYTE	bTrue		= 0xff;
	
	//	should be on the primary index
	Assert( pfucbNil != pfucbCatalog );
	Assert( pfucbNil == pfucbCatalog->pfucbCurIndex );
	Assert( !Pcsr( pfucbCatalog )->FLatched() );

	//	switch to secondary index
	Call( ErrIsamSetCurrentIndex(
					(JET_SESID)ppib,
					(JET_TABLEID)pfucbCatalog,
					szMSORootObjectsIndex ) );
	
	Call( ErrIsamMakeKey(
				ppib,
				pfucbCatalog,
				&bTrue,
				sizeof(bTrue),
				JET_bitNewKey ) );
	Call( ErrIsamMakeKey(
				ppib,
				pfucbCatalog,
				(BYTE *)szTableName,
				(ULONG)strlen(szTableName),
				NO_GRBIT ) );
	err = ErrIsamSeek( ppib, pfucbCatalog, JET_bitSeekEQ );
	if ( JET_errRecordNotFound == err )
		err = ErrERRCheck( JET_errObjectNotFound );
	Call( err );
	CallS( err );

	Assert( !Pcsr( pfucbCatalog )->FLatched() );
	Call( ErrDIRGet( pfucbCatalog ) );

#ifdef DEBUG
	{
	//	verify this is a table
	DATA	dataField;
	Assert( FFixedFid( fidMSO_Type ) );
	Call( ErrRECIRetrieveFixedColumn(
				pfcbNil,
				pfucbCatalog->u.pfcb->Ptdb(),
				fidMSO_Type,
				pfucbCatalog->kdfCurr.data,
				&dataField ) );
	CallS( err );
	Assert( dataField.Cb() == sizeof(SYSOBJ) );
	Assert( sysobjTable == *( (UnalignedLittleEndian< SYSOBJ > *)dataField.Pv() ) );
	}
#endif

HandleError:
	return err;
	}

	
LOCAL ERR ErrCATISeekTable(
	PIB			*ppib,
	FUCB		*pfucbCatalog,
	const OBJID	objidTable )
	{
	ERR			err;
	DATA		dataField;

	//	should be on the primary index
	Assert( pfucbNil != pfucbCatalog );
	Assert( pfucbNil == pfucbCatalog->pfucbCurIndex );
	Assert( !Pcsr( pfucbCatalog )->FLatched() );
	
	Call( ErrIsamMakeKey(
				ppib,
				pfucbCatalog,
				(BYTE *)&objidTable,
				sizeof(objidTable),
				JET_bitNewKey ) );
	err = ErrIsamSeek( ppib, pfucbCatalog, JET_bitSeekGT );
	if ( JET_errRecordNotFound == err )
		err = ErrERRCheck( JET_errObjectNotFound );
	Call( err );
	CallS( err );

	Assert( !Pcsr( pfucbCatalog )->FLatched() );
	Call( ErrDIRGet( pfucbCatalog ) );

	Assert( FFixedFid( fidMSO_Id ) );
	Call( ErrRECIRetrieveFixedColumn(
				pfcbNil,
				pfucbCatalog->u.pfcb->Ptdb(),
				fidMSO_Id,
				pfucbCatalog->kdfCurr.data,
				&dataField ) );
	CallS( err );
	Assert( dataField.Cb() == sizeof(OBJID) );
	if ( objidTable != *( (UnalignedLittleEndian< OBJID > *)dataField.Pv() ) )
		{
		err = ErrERRCheck( JET_errObjectNotFound );
		goto HandleError;
		}
	
#ifdef DEBUG	
	//	first record with this pgnoFDP should always be the Table object.
	Assert( FFixedFid( fidMSO_Type ) );
	Call( ErrRECIRetrieveFixedColumn(
				pfcbNil,
				pfucbCatalog->u.pfcb->Ptdb(),
				fidMSO_Type,
				pfucbCatalog->kdfCurr.data,
				&dataField ) );
	CallS( err );
	Assert( dataField.Cb() == sizeof(SYSOBJ) );
	Assert( sysobjTable == *( (UnalignedLittleEndian< SYSOBJ > *)dataField.Pv() ) );
#endif

HandleError:
	return err;
	}


ERR ErrCATSeekTable(
	PIB				*ppib,
	const IFMP		ifmp,
	const CHAR		*szTableName,
	PGNO			*ppgnoTableFDP,
	OBJID			*pobjidTable )
	{
	ERR		err;
	FUCB	*pfucbCatalog = pfucbNil;
	DATA	dataField;

	Assert( NULL != ppgnoTableFDP || NULL != pobjidTable );

	CallR( ErrCATOpen( ppib, ifmp, &pfucbCatalog ) );
	Assert( pfucbNil != pfucbCatalog );

	Call( ErrCATISeekTable( ppib, pfucbCatalog, szTableName ) );
	Assert( Pcsr( pfucbCatalog )->FLatched() );

	if ( NULL != ppgnoTableFDP )
		{
		Assert( FFixedFid( fidMSO_PgnoFDP ) );
		Call( ErrRECIRetrieveFixedColumn(
					pfcbNil,
					pfucbCatalog->u.pfcb->Ptdb(),
					fidMSO_PgnoFDP,
					pfucbCatalog->kdfCurr.data,
					&dataField ) );
		CallS( err );
		Assert( dataField.Cb() == sizeof(PGNO) );
		*ppgnoTableFDP = *(UnalignedLittleEndian< PGNO > *) dataField.Pv();
//		UtilMemCpy( ppgnoTableFDP, dataField.Pv(), sizeof(PGNO) );
		}

	if ( NULL != pobjidTable )
		{
		Assert( FFixedFid( fidMSO_Id ) );
		Call( ErrRECIRetrieveFixedColumn(
					pfcbNil,
					pfucbCatalog->u.pfcb->Ptdb(),
					fidMSO_Id,
					pfucbCatalog->kdfCurr.data,
					&dataField ) );
		CallS( err );
		Assert( dataField.Cb() == sizeof(OBJID) );
		*pobjidTable = *(UnalignedLittleEndian< OBJID > *) dataField.Pv();
//		UtilMemCpy( pobjidTable, dataField.Pv(), sizeof(OBJID) );
		}

HandleError:
	CallS( ErrCATClose( ppib, pfucbCatalog ) );
	return err;
	}


LOCAL ERR ErrCATISeekTableObject(
	PIB				*ppib,
	FUCB			*pfucbCatalog,
	const OBJID		objidTable,
	const SYSOBJ	sysobj,
	const CHAR		*szName )
	{
	ERR				err;

	Assert( sysobjColumn == sysobj
		|| sysobjIndex == sysobj
		|| sysobjLongValue == sysobj
		|| sysobjSLVAvail == sysobj
		|| sysobjSLVOwnerMap == sysobj );
	
	//	should be on the primary index
	Assert( pfucbNil != pfucbCatalog );
	Assert( pfucbNil == pfucbCatalog->pfucbCurIndex );
	Assert( !Pcsr( pfucbCatalog )->FLatched() );

	//	switch to secondary index
	Call( ErrIsamSetCurrentIndex(
				(JET_SESID)ppib,
				(JET_TABLEID)pfucbCatalog,
				szMSONameIndex ) );
	
	Call( ErrIsamMakeKey(
				ppib,
				pfucbCatalog,
				(BYTE *)&objidTable,
				sizeof(objidTable),
				JET_bitNewKey ) );
	Call( ErrIsamMakeKey(
				ppib,
				pfucbCatalog,
				(BYTE *)&sysobj,
				sizeof(sysobj),
				NO_GRBIT ) );
	Call( ErrIsamMakeKey(
				ppib,
				pfucbCatalog,
				(BYTE *)szName,
				(ULONG)strlen(szName),
				NO_GRBIT ) );
	err = ErrIsamSeek( ppib, pfucbCatalog, JET_bitSeekEQ );
	Assert( err <= JET_errSuccess );	//	SeekEQ shouldn't return warnings
	if ( JET_errRecordNotFound == err )
		{
		switch ( sysobj )
			{
			case sysobjColumn:
				err = ErrERRCheck( JET_errColumnNotFound );
				break;
			case sysobjIndex:
				err = ErrERRCheck( JET_errIndexNotFound );
				break;
				
			default:
				AssertSz( fFalse, "Invalid CATALOG object" );
				//	FALL THROUGH:
			case sysobjLongValue:
			case sysobjSLVAvail:
			case sysobjSLVOwnerMap:
				err = ErrERRCheck( JET_errObjectNotFound );
				break;
			}
		}
	else if ( JET_errSuccess == err )
		{
		Assert( !Pcsr( pfucbCatalog )->FLatched() );
		Call( ErrDIRGet( pfucbCatalog ) );
		}

HandleError:
	return err;	
	}

LOCAL ERR ErrCATISeekTableObject(
	PIB				*ppib,
	FUCB			*pfucbCatalog,
	const OBJID		objidTable,
	const SYSOBJ	sysobj,
	const OBJID		objid )
	{
	ERR				err;

	Assert( sysobjColumn == sysobj
		|| sysobjIndex == sysobj
		|| sysobjTable == sysobj
		|| sysobjLongValue == sysobj );
	
	//	should be on the primary index, which is the Id index
	Assert( pfucbNil != pfucbCatalog );
	Assert( pfucbNil == pfucbCatalog->pfucbCurIndex );
	Assert( !Pcsr( pfucbCatalog )->FLatched() );

	Call( ErrIsamMakeKey(
				ppib,
				pfucbCatalog,
				(BYTE *)&objidTable,
				sizeof(objidTable),
				JET_bitNewKey ) );
	Call( ErrIsamMakeKey(
				ppib,
				pfucbCatalog,
				(BYTE *)&sysobj,
				sizeof(sysobj),
				NO_GRBIT ) );
	Call( ErrIsamMakeKey(
				ppib,
				pfucbCatalog,
				(BYTE *)&objid,
				sizeof(objid),
				NO_GRBIT ) );
	err = ErrIsamSeek( ppib, pfucbCatalog, JET_bitSeekEQ );
	Assert( err <= JET_errSuccess );	//	SeekEQ shouldn't return warnings
	if ( JET_errRecordNotFound == err )
		{
		switch ( sysobj )
			{
			case sysobjColumn:
				err = ErrERRCheck( JET_errColumnNotFound );
				break;
			case sysobjIndex:
				err = ErrERRCheck( JET_errIndexNotFound );
				break;
				
			default:
				AssertSz( fFalse, "Invalid CATALOG object" );
				//	FALL THROUGH:
			case sysobjTable:
			case sysobjLongValue:
				err = ErrERRCheck( JET_errObjectNotFound );
				break;
			}
		}
	else if ( JET_errSuccess == err )
		{
		Assert( !Pcsr( pfucbCatalog )->FLatched() );
		Call( ErrDIRGet( pfucbCatalog ) );
		}

HandleError:
	return err;	
	}


LOCAL ERR ErrCATIDeleteTable( PIB *ppib, const IFMP ifmp, const OBJID objidTable, const BOOL fShadow )
	{
	ERR		err;
	FUCB	*pfucbCatalog	= pfucbNil;

	Assert( ppib->level > 0 );

	Assert( objidTable > objidSystemRoot );

	CallR( ErrCATOpen( ppib, ifmp, &pfucbCatalog, fShadow ) );
	Assert( pfucbNil != pfucbCatalog );

	Call( ErrCATISeekTable(
				ppib,
				pfucbCatalog,
				objidTable ) );
	Assert( Pcsr( pfucbCatalog )->FLatched() );
	CallS( ErrDIRRelease( pfucbCatalog ) );

	Call( ErrIsamMakeKey(
				ppib,
				pfucbCatalog,
				(BYTE *)&objidTable,
				sizeof(objidTable),
				JET_bitNewKey | JET_bitStrLimit ) );
				
	err = ErrIsamSetIndexRange( ppib, pfucbCatalog, JET_bitRangeUpperLimit );
	Assert( JET_errNoCurrentRecord != err );

	do
		{
		Call( err );
		Call( ErrIsamDelete( ppib, pfucbCatalog ) );
		err = ErrIsamMove( ppib, pfucbCatalog, JET_MoveNext, NO_GRBIT );
		}
	while ( JET_errNoCurrentRecord != err );
				
	err = JET_errSuccess;

HandleError:
	CallS( ErrCATClose( ppib, pfucbCatalog ) );
	return err;
	}


ERR ErrCATDeleteTable( PIB *ppib, const IFMP ifmp, const OBJID objidTable )
	{
	ERR			err;

	//	ensure we're in a transaction, so that on failure, updates to both
	//	catalog and its shadow are rolled back
	Assert( ppib->level > 0 );

	CallR( ErrCATIDeleteTable( ppib, ifmp, objidTable, fFalse ) );

	if ( !rgfmp[ifmp].FShadowingOff() )
		{
#ifdef DEBUG
		const ERR	errSave		= err;
#endif

		err = ErrCATIDeleteTable( ppib, ifmp, objidTable, fTrue );

		Assert( JET_errObjectNotFound != err );		// would have been detected in regular catalog
		Assert( err < 0 || errSave == err );
		}

	return err;
	}


/*	replaces the value in a column of a record of a system table.
/**/
LOCAL ERR ErrCATIDeleteTableColumn(
	PIB				*ppib,
	const IFMP		ifmp,
	const OBJID		objidTable,
	const CHAR		*szColumnName,
	COLUMNID		*pcolumnid,
	const BOOL		fShadow )
	{
	ERR				err;
	FUCB			*pfucbCatalog	= pfucbNil;
	DATA			dataField;
	JET_COLUMNID	columnid;
	JET_COLTYP		coltyp;
	CHAR			szStubName[cbMaxDeletedColumnStubName];

	Assert( objidTable > objidSystemRoot );

	CallR( ErrCATOpen( ppib, ifmp, &pfucbCatalog, fShadow ) );
	Assert( pfucbNil != pfucbCatalog );

	if ( fShadow )
		{
		Assert( !FCOLUMNIDTemplateColumn( *pcolumnid ) );	//	Template bit is not persisted
		Call( ErrCATISeekTableObject(
					ppib,
					pfucbCatalog,
					objidTable,
					sysobjColumn,
					*pcolumnid ) );
		}
	else
		{
		Call( ErrCATISeekTableObject(
					ppib,
					pfucbCatalog,
					objidTable,
					sysobjColumn,
					szColumnName ) );
		}
	Assert( Pcsr( pfucbCatalog )->FLatched() );

	Assert( FFixedFid( fidMSO_Id ) );
	Call( ErrRECIRetrieveFixedColumn(
				pfcbNil,
				pfucbCatalog->u.pfcb->Ptdb(),
				fidMSO_Id,
				pfucbCatalog->kdfCurr.data,
				&dataField ) );
	CallS( err );
	Assert( dataField.Cb() == sizeof(JET_COLUMNID) );
	columnid = *(UnalignedLittleEndian< JET_COLUMNID > *) dataField.Pv();
//	UtilMemCpy( &columnid, dataField.Pv(), sizeof(JET_COLUMNID) );

	Assert( !FCOLUMNIDTemplateColumn( columnid ) );	//	Template bit is not persisted

#ifdef DEBUG
	Assert( FFixedFid( fidMSO_Coltyp ) );
	Call( ErrRECIRetrieveFixedColumn(
				pfcbNil,
				pfucbCatalog->u.pfcb->Ptdb(),
				fidMSO_Coltyp,
				pfucbCatalog->kdfCurr.data,
				&dataField ) );
	CallS( err );
	Assert( dataField.Cb() == sizeof(JET_COLTYP) );
	Assert( JET_coltypNil != *( UnalignedLittleEndian< JET_COLTYP > *)dataField.Pv() );
#endif

	Call( ErrDIRRelease( pfucbCatalog ) );
	
	Call( ErrIsamPrepareUpdate( ppib, pfucbCatalog, JET_prepReplace ) );

	//	Set column type to Nil to flag column as deleted.
	//	If possible, the record will be deleted the next time the table
	//	is opened.
	coltyp = JET_coltypNil;	
	Call( ErrIsamSetColumn(
			ppib,
			pfucbCatalog, 
			fidMSO_Coltyp,
			(BYTE *)&coltyp,
			sizeof(coltyp),
			0,
			NULL ) );

	// Replace column name with bogus name of the form "JetStub_<objidFDP>_<fid>".
	strcpy( szStubName, szDeletedColumnStubPrefix );
	_ultoa( objidTable, szStubName + strlen( szDeletedColumnStubPrefix ), 10 );
	Assert( strlen( szStubName ) < cbMaxDeletedColumnStubName );
	strcat( szStubName, "_" );
	_ultoa( columnid, szStubName + strlen( szStubName ), 10 );
	Assert( strlen( szStubName ) < cbMaxDeletedColumnStubName );
	Call( ErrIsamSetColumn(
			ppib,
			pfucbCatalog, 
			fidMSO_Name,
			(BYTE *)szStubName,
			(ULONG)strlen( szStubName ),
			NO_GRBIT,
			NULL ) );
	Call( ErrIsamUpdate( ppib, pfucbCatalog, NULL, 0, NULL, NO_GRBIT ) );

	//	Set return value.
	*pcolumnid = columnid;

HandleError:
	CallS( ErrCATClose( ppib, pfucbCatalog ) );
	return err;
	}


ERR ErrCATDeleteTableColumn(
	PIB			*ppib,
	const IFMP	ifmp,
	const OBJID	objidTable,
	const CHAR	*szColumnName,
	COLUMNID	*pcolumnid )
	{
	ERR			err;

	//	ensure we're in a transaction, so that on failure, updates to both
	//	catalog and its shadow are rolled back
	Assert( ppib->level > 0 );
	
	CallR( ErrCATIDeleteTableColumn(
				ppib,
				ifmp,
				objidTable,
				szColumnName,
				pcolumnid,
				fFalse ) );


	if ( !rgfmp[ifmp].FShadowingOff() )
		{
#ifdef DEBUG
		const ERR	errSave			= err;
#endif

		COLUMNID	columnidShadow	= *pcolumnid;
	
		err = ErrCATIDeleteTableColumn(
					ppib,
					ifmp,
					objidTable,
					szColumnName,
					&columnidShadow,
					fTrue );

		Assert( JET_errColumnNotFound != err );		// would have been detected in regular catalog
		Assert( err < 0
			|| ( errSave == err && columnidShadow == *pcolumnid ) );
		}

	return err;
	}
	

LOCAL ERR ErrCATIDeleteTableIndex(
	PIB			*ppib,
	const IFMP	ifmp,
	const OBJID	objidTable,
	const CHAR	*szIndexName,
	PGNO		*ppgnoIndexFDP,
	OBJID		*pobjidIndex,
	const BOOL	fShadow )
	{
	ERR			err;
	FUCB		*pfucbCatalog		= pfucbNil;
	DATA		dataField;

	Assert( objidTable > objidSystemRoot );
	Assert( NULL != ppgnoIndexFDP );
	Assert( NULL != pobjidIndex );

	CallR( ErrCATOpen( ppib, ifmp, &pfucbCatalog, fShadow ) );
	Assert( pfucbNil != pfucbCatalog );

	if ( fShadow )
		{
		//	if shadow, must search by objidIndex because there's
		//	no index on name
		Assert( *pobjidIndex > objidSystemRoot );
		
		//	objids are monotonically increasing, so an index should
		//	always have higher objid than its table
		Assert( *pobjidIndex > objidTable );
		
		Call( ErrCATISeekTableObject(
					ppib,
					pfucbCatalog,
					objidTable,
					sysobjIndex,
					*pobjidIndex ) );
		}
	else
		{
		//	if not shadow, must search by name because we dont'
		//	know objidIndex yet
		Call( ErrCATISeekTableObject(
					ppib,
					pfucbCatalog,
					objidTable,
					sysobjIndex,
					szIndexName ) );
		}
	Assert( Pcsr( pfucbCatalog )->FLatched() );

	Assert( FFixedFid( fidMSO_PgnoFDP ) );
	Call( ErrRECIRetrieveFixedColumn(
				pfcbNil,
				pfucbCatalog->u.pfcb->Ptdb(),
				fidMSO_PgnoFDP,
				pfucbCatalog->kdfCurr.data,
				&dataField ) );
	CallS( err );
	Assert( dataField.Cb() == sizeof(PGNO) );
	*ppgnoIndexFDP = *(UnalignedLittleEndian< PGNO > *) dataField.Pv();
//	UtilMemCpy( ppgnoIndexFDP, dataField.Pv(), sizeof(PGNO) );

	Assert( FFixedFid( fidMSO_Id ) );
	Call( ErrRECIRetrieveFixedColumn(
				pfcbNil,
				pfucbCatalog->u.pfcb->Ptdb(),
				fidMSO_Id,
				pfucbCatalog->kdfCurr.data,
				&dataField ) );
	CallS( err );
	Assert( dataField.Cb() == sizeof(OBJID) );
	*pobjidIndex = *(UnalignedLittleEndian< OBJID > *) dataField.Pv();
//	UtilMemCpy( pobjidIndex, dataField.Pv(), sizeof(OBJID) );

#ifdef DEBUG
	LE_IDXFLAG		*ple_idxflag;
	IDBFLAG			fidb;
	Assert( FFixedFid( fidMSO_Flags ) );
	Call( ErrRECIRetrieveFixedColumn(
				pfcbNil,
				pfucbCatalog->u.pfcb->Ptdb(),
				fidMSO_Flags,
				pfucbCatalog->kdfCurr.data,
				&dataField ) );
	CallS( err );
	Assert( dataField.Cb() == sizeof(ULONG) );
	ple_idxflag = (LE_IDXFLAG*)dataField.Pv();
	fidb = ple_idxflag->fidb;

	if ( FIDBPrimary( fidb ) )
		{
		Assert( objidTable == *pobjidIndex );
		}
	else
		{
		//	objids are monotonically increasing, so an index should
		//	always have higher objid than its table
		Assert( *pobjidIndex > objidTable );
		}
#endif	
		
	CallS( ErrDIRRelease( pfucbCatalog ) );

	if ( objidTable == *pobjidIndex )
		err = ErrERRCheck( JET_errIndexMustStay );
	else
		err = ErrIsamDelete( ppib, pfucbCatalog );

HandleError:
	CallS( ErrCATClose( ppib, pfucbCatalog ) );
	return err;
	}


LOCAL ERR ErrCATIDeleteDbObject(
	PIB				* const ppib,
	const IFMP		ifmp,
	const CHAR		* const szName,
	const SYSOBJ 	sysobj )
	{
	ERR				err;
	FUCB *			pfucbCatalog		= pfucbNil;
	BOOKMARK 		bm;
	BYTE			rgbBookmark[JET_cbBookmarkMost];
	ULONG			cbBookmark;

	Call( ErrCATOpen( ppib, ifmp, &pfucbCatalog, fFalse ) );
	Assert( pfucbNil != pfucbCatalog );

	Call( ErrCATISeekTableObject(
				ppib,
				pfucbCatalog,
				objidSystemRoot,
				sysobj,
				szName ) );				

	Call( ErrDIRRelease( pfucbCatalog ) );

	Assert( pfucbCatalog->bmCurr.key.prefix.FNull() );
	Assert( pfucbCatalog->bmCurr.data.FNull() );
	cbBookmark = min( pfucbCatalog->bmCurr.key.Cb(), sizeof(rgbBookmark) );
	Assert( cbBookmark <= JET_cbBookmarkMost );
	pfucbCatalog->bmCurr.key.CopyIntoBuffer( rgbBookmark, cbBookmark );

	bm.key.prefix.Nullify();
	bm.key.suffix.SetPv( rgbBookmark );
	bm.key.suffix.SetCb( cbBookmark );
	bm.data.Nullify();

	Call( ErrIsamDelete( ppib, pfucbCatalog ) );
	CallS( ErrCATClose( ppib, pfucbCatalog ) );
	pfucbCatalog = pfucbNil;

	if( !rgfmp[ifmp].FShadowingOff() )
		{
		Call( ErrCATOpen( ppib, ifmp, &pfucbCatalog, fTrue ) );
		Assert( pfucbNil != pfucbCatalog );

		Call( ErrDIRGotoBookmark( pfucbCatalog, bm ) );
		Call( ErrIsamDelete( ppib, pfucbCatalog ) );
		}
	
HandleError:
	if( pfucbNil != pfucbCatalog )
		{
		CallS( ErrCATClose( ppib, pfucbCatalog ) );
		}
	return err;
	}

ERR ErrCATDeleteDbObject(
	PIB				* const ppib,
	const IFMP		ifmp,
	const CHAR		* const szName,
	const SYSOBJ 	sysobj)
	{
	ERR	err = JET_errSuccess;

	Call( ErrDIRBeginTransaction( ppib, NO_GRBIT ) );
	
	Call( ErrCATIDeleteDbObject(
				ppib,
				ifmp,
				szName,
				sysobj ) );

	Call( ErrDIRCommitTransaction( ppib, NO_GRBIT ) );
	
HandleError:
	if( err < 0 )
		{
		CallSx( ErrDIRRollback( ppib ), JET_errRollbackError );
		}
		
	return err;
	}



ERR ErrCATDeleteTableIndex(
	PIB			*ppib,
	const IFMP	ifmp,
	const OBJID	objidTable,
	const CHAR	*szIndexName,
	PGNO		*ppgnoIndexFDP )
	{
	ERR			err;
	OBJID		objidIndex;

	//	ensure we're in a transaction, so that on failure, updates to both
	//	catalog and its shadow are rolled back
	Assert( ppib->level > 0 );

	CallR( ErrCATIDeleteTableIndex(
				ppib,
				ifmp,
				objidTable,
				szIndexName,
				ppgnoIndexFDP,
				&objidIndex,
				fFalse ) );

	if ( !rgfmp[ifmp].FShadowingOff() )
		{
#ifdef DEBUG
		const ERR	errSave		= err;
#endif

		PGNO		pgnoIndexShadow;
	
		err = ErrCATIDeleteTableIndex(
					ppib,
					ifmp,
					objidTable,
					szIndexName,
					&pgnoIndexShadow,
					&objidIndex,
					fTrue );

		Assert( JET_errIndexNotFound != err );		// would have been detected in regular catalog
		Assert( err < 0
			|| ( errSave == err && pgnoIndexShadow == *ppgnoIndexFDP ) );
		}
	
	return err;
	}
	


ERR ErrCATAccessTableColumn(
	PIB				*ppib,
	const IFMP		ifmp,
	const OBJID		objidTable,
	const CHAR		*szColumnName,
	COLUMNID		*pcolumnid,
	const BOOL		fLockColumn )
	{
	ERR				err;
	FUCB			*pfucbCatalog	= pfucbNil;
	const BOOL		fSearchByName	= ( szColumnName != NULL );
	DATA			dataField;
	JET_COLTYP		coltyp;

	Assert( NULL != pcolumnid );

	CallR( ErrCATOpen( ppib, ifmp, &pfucbCatalog ) );
	Assert( pfucbNil != pfucbCatalog );

	if ( fSearchByName )
		{
		Call( ErrCATISeekTableObject(
				ppib,
				pfucbCatalog,
				objidTable,
				sysobjColumn,
				szColumnName ) );
		}
	else
		{
		COLUMNID	columnidT	= *pcolumnid;

		Assert( !FCOLUMNIDTemplateColumn( columnidT ) );
		Call( ErrCATISeekTableObject(
				ppib,
				pfucbCatalog,
				objidTable,
				sysobjColumn,
				(OBJID)columnidT ) );
		}
	Assert( Pcsr( pfucbCatalog )->FLatched() );
	
	Assert( FFixedFid( fidMSO_Coltyp ) );
	Call( ErrRECIRetrieveFixedColumn(
				pfcbNil,
				pfucbCatalog->u.pfcb->Ptdb(),
				fidMSO_Coltyp,
				pfucbCatalog->kdfCurr.data,
				&dataField ) );
	CallS( err );
	Assert( dataField.Cb() == sizeof(JET_COLTYP) );
	coltyp = *(UnalignedLittleEndian< JET_COLTYP > *) dataField.Pv();
//	UtilMemCpy( &coltyp, dataField.Pv(), sizeof(JET_COLTYP) );

	if ( JET_coltypNil == coltyp )
		{
		// Column has been deleted.
		err = ErrERRCheck( JET_errColumnNotFound );
		goto HandleError;
		}
		
	Assert( !fLockColumn || fSearchByName );		// Locking column only done by name.
	if ( fSearchByName )
		{
		Assert( FFixedFid( fidMSO_Id ) );
		Call( ErrRECIRetrieveFixedColumn(
					pfcbNil,
					pfucbCatalog->u.pfcb->Ptdb(),
					fidMSO_Id,
					pfucbCatalog->kdfCurr.data,
					&dataField ) );
		CallS( err );
		Assert( dataField.Cb() == sizeof(JET_COLUMNID) );
		*pcolumnid = *(UnalignedLittleEndian< JET_COLUMNID > *) dataField.Pv();
//		UtilMemCpy( pcolumnid, dataField.Pv(), sizeof(JET_COLUMNID) );
		Assert( 0 != *pcolumnid );

		if ( fLockColumn )
			{
			// UNDONE: Lock must be obtained in a transaction.  Further, since
			// CreateIndex is currently the only function to lock a table column,
			// we can assert that we are in a transaction.
			Assert( pfucbCatalog->ppib->level > 0 );

			Call( ErrDIRRelease( pfucbCatalog ) );
			Call( ErrDIRGetLock( pfucbCatalog, readLock ) );
			}
		}

HandleError:
	CallS( ErrCATClose( ppib, pfucbCatalog ) );

	return err;
	}


ERR ErrCATAccessTableIndex(
	PIB				*ppib,
	const IFMP		ifmp,
	const OBJID		objidTable,
	const OBJID		objidIndex )
	{
	ERR				err;
	FUCB			*pfucbCatalog		= pfucbNil;

	CallR( ErrCATOpen( ppib, ifmp, &pfucbCatalog ) );
	Assert( pfucbNil != pfucbCatalog );

	Call( ErrCATISeekTableObject(
			ppib,
			pfucbCatalog,
			objidTable,
			sysobjIndex,
			objidIndex ) );
	Assert( Pcsr( pfucbCatalog )->FLatched() );

HandleError:
	CallS( ErrCATClose( ppib, pfucbCatalog ) );

	return err;
	}

ERR ErrCATAccessTableLV(
	PIB				*ppib,
	const IFMP		ifmp,
	const OBJID		objidTable,
	PGNO			*ppgnoLVFDP,
	OBJID			*pobjidLV )
	{
	ERR				err;
	FUCB			*pfucbCatalog	= pfucbNil;

	CallR( ErrCATOpen( ppib, ifmp, &pfucbCatalog ) );
	Assert( pfucbNil != pfucbCatalog );

	err = ErrCATISeekTableObject(
				ppib,
				pfucbCatalog,
				objidTable,
				sysobjLongValue,
				szLVRoot );

	if ( err < 0 )
		{
		if ( JET_errObjectNotFound == err )
			{
			// LV tree has yet to be created.
			err = JET_errSuccess;
			*ppgnoLVFDP = pgnoNull;
			if( NULL != pobjidLV )
				{
				*pobjidLV	= objidNil;
				}
			}
		}
	else
		{
		DATA	dataField;
		
		Assert( Pcsr( pfucbCatalog )->FLatched() );

		Assert( FFixedFid( fidMSO_PgnoFDP ) );
		Call( ErrRECIRetrieveFixedColumn(
					pfcbNil,
					pfucbCatalog->u.pfcb->Ptdb(),
					fidMSO_PgnoFDP,
					pfucbCatalog->kdfCurr.data,
					&dataField ) );
		CallS( err );
		Assert( dataField.Cb() == sizeof(PGNO) );
		
		*ppgnoLVFDP = *(UnalignedLittleEndian< PGNO > *) dataField.Pv();
//		UtilMemCpy( ppgnoLVFDP, dataField.Pv(), sizeof(PGNO) );

		if( NULL != pobjidLV )
			{
			Assert( FFixedFid( fidMSO_Id ) );
			Call( ErrRECIRetrieveFixedColumn(
						pfcbNil,
						pfucbCatalog->u.pfcb->Ptdb(),
						fidMSO_Id,
						pfucbCatalog->kdfCurr.data,
						&dataField ) );
			CallS( err );
			Assert( dataField.Cb() == sizeof(OBJID) );
			
			*pobjidLV = *(UnalignedLittleEndian< OBJID > *) dataField.Pv();
//			UtilMemCpy( pobjidLV, dataField.Pv(), sizeof(OBJID) );
			}
		}

HandleError:
	CallS( ErrCATClose( ppib, pfucbCatalog ) );

	return err;
	}


ERR ErrCATGetTableInfoCursor(
	PIB				*ppib,
	const IFMP		ifmp,
	const CHAR		*szTableName,
	FUCB			**ppfucbInfo )
	{
	ERR				err;
	FUCB			*pfucbCatalog;

	Assert( NULL != ppfucbInfo );
	
	//	Can only open a system table cursor on a specific record.
	if ( NULL == szTableName || '\0' == *szTableName )
		{
		err = ErrERRCheck( JET_errObjectNotFound );
		return err;
		}

	CallR( ErrCATOpen( ppib, ifmp, &pfucbCatalog ) );
	Assert( pfucbNil != pfucbCatalog );

	Call( ErrCATISeekTable( ppib, pfucbCatalog, szTableName ) );
	Assert( Pcsr( pfucbCatalog )->FLatched() );

	CallS( ErrDIRRelease( pfucbCatalog ) );

	*ppfucbInfo = pfucbCatalog;

	return err;

HandleError:
	Assert( err < 0 );
	CallS( ErrCATClose( ppib, pfucbCatalog ) );

	return err;
	}

ERR ErrCATGetObjectNameFromObjid(
	PIB			*ppib,
	const IFMP	ifmp,
	const OBJID		objidTable,
	const SYSOBJ	sysobj,
	const OBJID	objid,
	char * 		szName, // JET_cbNameMost
	ULONG 		cbName )
	{
	ERR			err;
	FUCB 		*pfucbCatalog		= pfucbNil;
	DATA		dataField;

	Assert( NULL != szName);

	CallR( ErrCATOpen( ppib, ifmp, &pfucbCatalog ) );
	Assert( pfucbNil != pfucbCatalog );

	Call (ErrCATISeekTableObject( ppib, pfucbCatalog, objidTable, sysobj, objid) );
	Assert( Pcsr( pfucbCatalog )->FLatched() );
	
	Assert( FVarFid( fidMSO_Name ) );
	Call( ErrRECIRetrieveVarColumn(
				pfcbNil,
				pfucbCatalog->u.pfcb->Ptdb(),
				fidMSO_Name,
				pfucbCatalog->kdfCurr.data,
				&dataField ) );
	CallS( err );

	memset( szName, '\0', cbName);
	memcpy( szName, dataField.Pv(), min(cbName, dataField.Cb() ) );
	
HandleError:
	CallS( ErrCATClose( ppib, pfucbCatalog ) );
	return err;
	}

	
ERR ErrCATGetTableAllocInfo(
	PIB			*ppib,
	const IFMP	ifmp,
	const OBJID	objidTable,
	ULONG		*pulPages,
	ULONG		*pulDensity,
	PGNO 		*ppgnoFDP)
	{
	ERR			err;
	FUCB 		*pfucbCatalog		= pfucbNil;
	DATA		dataField;

	CallR( ErrCATOpen( ppib, ifmp, &pfucbCatalog ) );
	Assert( pfucbNil != pfucbCatalog );

	Call( ErrCATISeekTable( ppib, pfucbCatalog, objidTable ) );
	Assert( Pcsr( pfucbCatalog )->FLatched() );

	//	pages are optional, density is not
	if ( NULL != pulPages )
		{
		Assert( FFixedFid( fidMSO_Pages ) );
		Call( ErrRECIRetrieveFixedColumn(
					pfcbNil,
					pfucbCatalog->u.pfcb->Ptdb(),
					fidMSO_Pages,
					pfucbCatalog->kdfCurr.data,
					&dataField ) );
		CallS( err );
		Assert( dataField.Cb() == sizeof(ULONG) );
		*pulPages = *(UnalignedLittleEndian< ULONG > *) dataField.Pv();
//		UtilMemCpy( pulPages, dataField.Pv(), sizeof(ULONG) );
		}

	Assert( NULL != pulDensity );

	Assert( FFixedFid( fidMSO_SpaceUsage ) );
	Call( ErrRECIRetrieveFixedColumn(
				pfcbNil,
				pfucbCatalog->u.pfcb->Ptdb(),
				fidMSO_SpaceUsage,
				pfucbCatalog->kdfCurr.data,
				&dataField ) );
	CallS( err );
	Assert( dataField.Cb() == sizeof(ULONG) );
	*pulDensity = *(UnalignedLittleEndian< ULONG > *) dataField.Pv();
//	UtilMemCpy( pulDensity, dataField.Pv(), sizeof(ULONG) );

	if ( NULL != ppgnoFDP )
		{
		Assert( FFixedFid( iMSO_PgnoFDP ) );
		Call( ErrRECIRetrieveFixedColumn(
					pfcbNil,
					pfucbCatalog->u.pfcb->Ptdb(),
					iMSO_PgnoFDP,
					pfucbCatalog->kdfCurr.data,
					&dataField ) );
		CallS( err );
		Assert( dataField.Cb() == sizeof(PGNO) );
		*ppgnoFDP = *(UnalignedLittleEndian< PGNO > *) dataField.Pv();
//		UtilMemCpy( ppgnoFDP, dataField.Pv(), sizeof(PGNO) );
		}
	
HandleError:
	CallS( ErrCATClose( ppib, pfucbCatalog ) );
	return err;
	}


ERR ErrCATGetIndexAllocInfo(
	PIB			*ppib,
	const IFMP	ifmp,
	const OBJID	objidTable,
	const CHAR	*szIndexName,
	ULONG		*pulDensity )
	{
	ERR			err;
	FUCB 		*pfucbCatalog		= pfucbNil;
	DATA		dataField;

	CallR( ErrCATOpen( ppib, ifmp, &pfucbCatalog ) );
	Assert( pfucbNil != pfucbCatalog );

	Call( ErrCATISeekTableObject(
				ppib,
				pfucbCatalog,
				objidTable,
				sysobjIndex,
				szIndexName ) );
	Assert( Pcsr( pfucbCatalog )->FLatched() );

	Assert( NULL != pulDensity );
	
	Assert( FFixedFid( fidMSO_SpaceUsage ) );
	Call( ErrRECIRetrieveFixedColumn(
				pfcbNil,
				pfucbCatalog->u.pfcb->Ptdb(),
				fidMSO_SpaceUsage,
				pfucbCatalog->kdfCurr.data,
				&dataField ) );
	CallS( err );
	Assert( dataField.Cb() == sizeof(ULONG) );
	*pulDensity = *(UnalignedLittleEndian< ULONG > *) dataField.Pv();
//	UtilMemCpy( pulDensity, dataField.Pv(), sizeof(ULONG) );
	
HandleError:
	CallS( ErrCATClose( ppib, pfucbCatalog ) );
	return err;
	}

ERR ErrCATGetIndexLcid(
	PIB			*ppib,
	const IFMP	ifmp,
	const OBJID	objidTable,
	const CHAR	*szIndexName,
	LCID		*plcid )
	{
	ERR			err;
	FUCB 		*pfucbCatalog		= pfucbNil;
	DATA		dataField;

	CallR( ErrCATOpen( ppib, ifmp, &pfucbCatalog ) );
	Assert( pfucbNil != pfucbCatalog );

	Call( ErrCATISeekTableObject(
				ppib,
				pfucbCatalog,
				objidTable,
				sysobjIndex,
				szIndexName ) );
	Assert( Pcsr( pfucbCatalog )->FLatched() );

	Assert( NULL != plcid );

	Assert( FFixedFid( fidMSO_Localization ) );
	Call( ErrRECIRetrieveFixedColumn(
				pfcbNil,
				pfucbCatalog->u.pfcb->Ptdb(),
				fidMSO_Localization,
				pfucbCatalog->kdfCurr.data,
				&dataField ) );
	CallS( err );
	Assert( dataField.Cb() == sizeof(LCID) );
	
	*plcid = *( (UnalignedLittleEndian< LCID > *)dataField.Pv() );

HandleError:
	CallS( ErrCATClose( ppib, pfucbCatalog ) );
	return err;
	}

ERR ErrCATGetIndexVarSegMac(
	PIB			*ppib,
	const IFMP	ifmp,
	const OBJID	objidTable,
	const CHAR	*szIndexName,
	USHORT		*pusVarSegMac )
	{
	ERR			err;
	FUCB 		*pfucbCatalog	= pfucbNil;
	DATA		dataField;

	CallR( ErrCATOpen( ppib, ifmp, &pfucbCatalog ) );
	Assert( pfucbNil != pfucbCatalog );

	Call( ErrCATISeekTableObject(
				ppib,
				pfucbCatalog,
				objidTable,
				sysobjIndex,
				szIndexName ) );
	Assert( Pcsr( pfucbCatalog )->FLatched() );

	Assert( NULL != pusVarSegMac );
	
	Assert( FVarFid( fidMSO_VarSegMac ) );
	Call( ErrRECIRetrieveVarColumn(
				pfcbNil,
				pfucbCatalog->u.pfcb->Ptdb(),
				fidMSO_VarSegMac,
				pfucbCatalog->kdfCurr.data,
				&dataField ) );
	Assert( JET_errSuccess == err || JET_wrnColumnNull == err );

	if ( JET_wrnColumnNull == err )
		{
		Assert( dataField.Cb() == 0 );

		*pusVarSegMac = JET_cbKeyMost;
		}
		
	else
		{
		Assert( dataField.Cb() == sizeof(USHORT) );
		*pusVarSegMac = *(UnalignedLittleEndian< USHORT > *) dataField.Pv();
//		UtilMemCpy( pusVarSegMac, dataField.Pv(), sizeof(USHORT) );
		Assert( *pusVarSegMac > 0 );
		Assert( *pusVarSegMac < JET_cbKeyMost );
		}

HandleError:
	CallS( ErrCATClose( ppib, pfucbCatalog ) );
	return err;
	}


ERR ErrCATGetIndexSegments(
	PIB				*ppib,
	const IFMP		ifmp,
	const OBJID		objidTable,
	const IDXSEG*	rgidxseg,
	const ULONG		cidxseg,
	const BOOL		fConditional,
	const BOOL		fOldFormat,
	CHAR			rgszSegments[JET_ccolKeyMost][JET_cbNameMost+1+1] )		// extra +1 for ascending/descending byte
	{
	ERR				err;
	FUCB			*pfucbCatalog			= pfucbNil;
	DATA			dataField;
	ULONG			ulFlags;
	OBJID			objidTemplateTable		= objidNil;

	CallR( ErrCATOpen( ppib, ifmp, &pfucbCatalog ) );
	Assert( pfucbNil != pfucbCatalog );

	Call( ErrCATISeekTable( ppib, pfucbCatalog, objidTable ) );
	Assert( Pcsr( pfucbCatalog )->FLatched() );

	//	should be on primary index
	Assert( pfucbNil == pfucbCatalog->pfucbCurIndex );

	Assert( FFixedFid( fidMSO_Flags ) );
	Call( ErrRECIRetrieveFixedColumn(
				pfcbNil,
				pfucbCatalog->u.pfcb->Ptdb(),
				fidMSO_Flags,
				pfucbCatalog->kdfCurr.data,
				&dataField ) );
	CallS( err );
	Assert( dataField.Cb() == sizeof(ULONG) );
	ulFlags = *(UnalignedLittleEndian< ULONG > *) dataField.Pv();

	if ( ulFlags & JET_bitObjectTableDerived )
		{
		CHAR	szTemplateTable[JET_cbNameMost+1];

		Assert( FVarFid( fidMSO_TemplateTable ) );
		Call( ErrRECIRetrieveVarColumn(
					pfcbNil,
					pfucbCatalog->u.pfcb->Ptdb(),
					fidMSO_TemplateTable,
					pfucbCatalog->kdfCurr.data,
					&dataField ) );
		CallS( err );
		Assert( dataField.Cb() > 0 );
		Assert( dataField.Cb() <= JET_cbNameMost );
		UtilMemCpy( szTemplateTable, dataField.Pv(), dataField.Cb() );
		szTemplateTable[dataField.Cb()] = '\0';
			
		Assert( Pcsr( pfucbCatalog )->FLatched() );
		CallS( ErrDIRRelease( pfucbCatalog ) );

		Call( ErrCATSeekTable( ppib, ifmp, szTemplateTable, NULL, &objidTemplateTable ) );
		Assert( objidNil != objidTemplateTable );
		}
	else
		{
		Assert( Pcsr( pfucbCatalog )->FLatched() );
		CallS( ErrDIRRelease( pfucbCatalog ) );
		}

	//	should still be on the primary index, which is the Id index
	Assert( pfucbNil == pfucbCatalog->pfucbCurIndex );
	Assert( !Pcsr( pfucbCatalog )->FLatched() );

	UINT	i;
	for ( i = 0; i < cidxseg; i++ )
		{
		CHAR				szColumnName[JET_cbNameMost+1];
		OBJID				objidT			= objidTable;
		BYTE				bPrefix;

		if ( rgidxseg[i].FTemplateColumn() )
			{
			Assert( !fOldFormat );

			if ( ulFlags & JET_bitObjectTableDerived )
				{
				Assert( objidNil != objidTemplateTable );
				objidT = objidTemplateTable;
				}
			else
				{
				Assert( ulFlags & JET_bitObjectTableTemplate );
				Assert( objidNil == objidTemplateTable );
				}
			}

		err = ErrCATISeekTableObject(
					ppib,
					pfucbCatalog,
					objidT,
					sysobjColumn,
					ColumnidOfFid( rgidxseg[i].Fid(), fFalse ) );	//	Template bit never persisted in catalog ) );
		if ( err < 0 )
			{
			//	SPECIAL-CASE: We never stored template bit in old-format indexes, so it's
			//	possible that the column was actually derived from the template table
			if ( JET_errColumnNotFound == err
				&& fOldFormat
				&& objidNil != objidTemplateTable )
				{
				err = ErrCATISeekTableObject(
							ppib,
							pfucbCatalog,
							objidTemplateTable,
							sysobjColumn,
							ColumnidOfFid( rgidxseg[i].Fid(), fFalse ) );
				}

			Call( err );
			}
		Assert( Pcsr( pfucbCatalog )->FLatched() );
		
		//	should be on primary index
		Assert( pfucbNil == pfucbCatalog->pfucbCurIndex );
	
		Assert( FVarFid( fidMSO_Name ) );
		Call( ErrRECIRetrieveVarColumn(
					pfcbNil,
					pfucbCatalog->u.pfcb->Ptdb(),
					fidMSO_Name,
					pfucbCatalog->kdfCurr.data,
					&dataField ) );
		CallS( err );
		Assert( dataField.Cb() > 0 );
		Assert( dataField.Cb() <= JET_cbNameMost );
		UtilMemCpy( szColumnName, dataField.Pv(), dataField.Cb() );
		szColumnName[dataField.Cb()] = '\0';
		
		Assert( Pcsr( pfucbCatalog )->FLatched() );
		CallS( ErrDIRRelease( pfucbCatalog ) );

		if ( fConditional )
			{
			bPrefix = ( rgidxseg[i].FMustBeNull() ? '?' : '*' );
			}
		else
			{
			bPrefix = ( rgidxseg[i].FDescending() ? '-' : '+' );

			}
		sprintf(
			rgszSegments[i],
			"%c%-s",
			bPrefix,
			szColumnName );
		}

	err = JET_errSuccess;

HandleError:
	CallS( ErrCATClose( ppib, pfucbCatalog ) );

	return err;
	}


//  ================================================================
ERR ErrCATGetColumnCallbackInfo(
	PIB * const ppib,
	const IFMP ifmp,
	const OBJID objidTable,
	const OBJID objidTemplateTable,
	const COLUMNID columnid,
	CHAR * const szCallback,
	const ULONG cchCallbackMax,
	ULONG * const pchCallback,
	BYTE * const pbUserData,
	const ULONG cbUserDataMax,
	ULONG * const pcbUserData,
	CHAR * const szDependantColumns,
	const ULONG cchDependantColumnsMax,
	ULONG * const pchDependantColumns )
//  ================================================================
	{
	ERR				err;
	FUCB			*pfucbCatalog			= pfucbNil;
	DATA			dataField;
	
	FID				rgfidDependencies[JET_ccolKeyMost];
	ULONG			cbActual;

	CallR( ErrCATOpen( ppib, ifmp, &pfucbCatalog ) );
	Assert( pfucbNil != pfucbCatalog );

	//	Template bit is not persisted
	Assert( !FCOLUMNIDTemplateColumn( columnid ) );

	Call( ErrCATISeekTableObject( 
			ppib,
			pfucbCatalog,
			objidTable,
			sysobjColumn,
			columnid ) );
	Assert( Pcsr( pfucbCatalog )->FLatched() );

	Assert( FVarFid( fidMSO_Callback ) );
	Call( ErrRECIRetrieveVarColumn(
				pfcbNil,
				pfucbCatalog->u.pfcb->Ptdb(),
				fidMSO_Callback,
				pfucbCatalog->kdfCurr.data,
				&dataField ) );
	//  ErrCATGetColumnCallbackInfo should only be called for columns that have callbacks 
	Assert( dataField.Cb() > 0 );
	Assert( dataField.Cb() <= JET_cbNameMost );
	Assert( cchCallbackMax > JET_cbNameMost );
	UtilMemCpy( szCallback, dataField.Pv(), dataField.Cb() );
	*pchCallback = dataField.Cb() + 1;
	szCallback[dataField.Cb()] = '\0';

	Assert( FTaggedFid( fidMSO_CallbackData ) );
	Call( ErrCATIRetrieveTaggedColumn(
			pfucbCatalog,
			fidMSO_CallbackData,
			1,
			pfucbCatalog->kdfCurr.data,
			pbUserData,
			cbUserDataMax,
			pcbUserData ) );
	Assert( JET_errSuccess == err || JET_wrnColumnNull == err );

	Assert( FTaggedFid( fidMSO_CallbackDependencies ) );
	Call( ErrCATIRetrieveTaggedColumn(
			pfucbCatalog,
			fidMSO_CallbackDependencies,
			1,
			pfucbCatalog->kdfCurr.data,
			(BYTE *)rgfidDependencies,
			sizeof( rgfidDependencies ),
			&cbActual ) );
	Assert( JET_errSuccess == err || JET_wrnColumnNull == err );
	Assert( ( cbActual % sizeof( FID ) ) == 0 );

	*pchDependantColumns = 0;

	if( cbActual > 0 )
		{
		//	dependencies not currently supported
		Assert( fFalse );

		//  Loop through the FIDs in the dependency list and convert them into column names
		//  Put the column names into szDependantColumns in "column\0column\0column\0\0" form
		UINT iFid;
		for ( iFid = 0; iFid < ( cbActual / sizeof( FID ) ); ++iFid )
			{
			CHAR			szColumnName[JET_cbNameMost+1];
			const COLUMNID	columnidT = rgfidDependencies[iFid];
			Assert( columnidT <= fidMax );
			Assert( columnidT >= fidMin );
			Assert( Pcsr( pfucbCatalog )->FLatched() );		
			
			CallS( ErrDIRRelease( pfucbCatalog ) );
			err = ErrCATISeekTableObject(
						ppib,
						pfucbCatalog,
						objidTable,
						sysobjColumn,
						columnidT );
			if ( JET_errColumnNotFound == err
				&& objidNil != objidTemplateTable )
				{
				err = ErrCATISeekTableObject(
							ppib,
							pfucbCatalog,
							objidTemplateTable,
							sysobjColumn,
							columnidT );
				}
			Call( err );

			Assert( Pcsr( pfucbCatalog )->FLatched() );		

			//	should be on primary index
			Assert( pfucbNil == pfucbCatalog->pfucbCurIndex );
		
			Assert( FVarFid( fidMSO_Name ) );
			Call( ErrRECIRetrieveVarColumn(
						pfcbNil,
						pfucbCatalog->u.pfcb->Ptdb(),
						fidMSO_Name,
						pfucbCatalog->kdfCurr.data,
						&dataField ) );
			CallS( err );
			Assert( dataField.Cb() > 0 );
			Assert( dataField.Cb() <= JET_cbNameMost );
			UtilMemCpy( szColumnName, dataField.Pv(), dataField.Cb() );
			szColumnName[dataField.Cb()] = '\0';

			//  Remember to leave space for the terminating NULL
			if( *pchDependantColumns + dataField.Cb() + 2 >= cchDependantColumnsMax )
				{
				//  The buffer we pass in should always have enough space
				Assert( fFalse );
				err = JET_wrnBufferTruncated;
				break;
				}
			sprintf( szDependantColumns + *pchDependantColumns, "%s", szColumnName );
			*pchDependantColumns += dataField.Cb() + 1;
			}
		szDependantColumns[*pchDependantColumns] = '\0';
		++(*pchDependantColumns);
		}
	
HandleError:
	Assert( pfucbNil != pfucbCatalog );
	CallS( ErrCATClose( ppib, pfucbCatalog ) );
	return err;
	}

	
/*	construct the catalog TDB using the static data structures 
/*	defined in _cat.c.
/**/
INLINE ERR ErrCATIInitCatalogTDB( INST *pinst, TDB **pptdbNew )
	{
	ERR					err;
	UINT				i;
	FIELD				field;
	const CDESC			*pcdesc;
	TDB					*ptdb						= ptdbNil;
	TCIB				tcib						= { fidFixedLeast-1, fidVarLeast-1, fidTaggedLeast-1 };
	REC::RECOFFSET		ibRec						= ibRECStartFixedColumns;

	//	UNDONE:		international support.  Set these values from 
	//			   	create database connect string.
	field.cp = usEnglishCodePage;

	/*	first, determine how many columns there are
	/**/
	pcdesc	= rgcdescMSO;
	for ( i = 0; i < cColumnsMSO; i++, pcdesc++ )
		{
		COLUMNID	columnidT;
		CallS( ErrFILEGetNextColumnid( pcdesc->coltyp, pcdesc->grbit, fFalse, &tcib, &columnidT ) );

		// Verify generated columnid matches hard-coded columnid
		Assert( pcdesc->columnid == columnidT );
		}

	CallR( ErrTDBCreate( pinst, &ptdb, &tcib, pfcbNil, fTrue ) );

		/*	check initialisations
	/**/
	Assert( ptdb->FidVersion() == 0 );
	Assert( ptdb->FidAutoincrement() == 0 );
	Assert( NULL == ptdb->PdataDefaultRecord() );
	Assert( tcib.fidFixedLast == ptdb->FidFixedLast() );
	Assert( tcib.fidVarLast == ptdb->FidVarLast() );
	Assert( tcib.fidTaggedLast == ptdb->FidTaggedLast() );
	Assert( ptdb->DbkMost() == 0 );
	Assert( ptdb->UlLongIdLast() == 0 );

	// Add table name.
	Assert( ptdb->ItagTableName() == 0 );
	MEMPOOL::ITAG	itagNew;
	Call( ptdb->MemPool().ErrAddEntry( (BYTE *)szMSO, (ULONG)strlen(szMSO) + 1, &itagNew ) );
	Assert( itagNew == itagTDBTableName );
	ptdb->SetItagTableName( itagNew );

	/*	fill in the column info
	/**/
	pcdesc = rgcdescMSO;
	for ( i = 0; i < cColumnsMSO; i++, pcdesc++ )
		{
		Call( ptdb->MemPool().ErrAddEntry(
				(BYTE *)pcdesc->szColName,
				(ULONG)strlen( pcdesc->szColName ) + 1,
				&field.itagFieldName ) );
		field.strhashFieldName = StrHashValue( pcdesc->szColName );
		field.coltyp = FIELD_COLTYP( pcdesc->coltyp );
		Assert( field.coltyp != JET_coltypNil );
		field.cbMaxLen = UlCATColumnSize( pcdesc->coltyp, 0, NULL );

		/*	flag for system table columns is JET_bitColumnNotNULL
		/**/
		field.ffield = 0;
		
		Assert( 0 == pcdesc->grbit || JET_bitColumnNotNULL == pcdesc->grbit || JET_bitColumnTagged == pcdesc->grbit );
		if ( pcdesc->grbit == JET_bitColumnNotNULL )
			FIELDSetNotNull( field.ffield );

		// ibRecordOffset is only relevant for fixed fields (it will be ignored by
		// RECAddFieldDef(), so don't even bother setting it).
		if ( FCOLUMNIDFixed( pcdesc->columnid ) )
			{
			field.ibRecordOffset = ibRec;
			ibRec = REC::RECOFFSET( ibRec + field.cbMaxLen );
			}
		else
			{
			field.ibRecordOffset = 0;
			}

		Call( ErrRECAddFieldDef(
				ptdb,
				ColumnidOfFid( FID( pcdesc->columnid ), fFalse ),
				&field ) );
		}
	Assert( ibRec <= cbRECRecordMost );
	ptdb->SetIbEndFixedColumns( ibRec, ptdb->FidFixedLast() );

	*pptdbNew = ptdb;

	return JET_errSuccess;

HandleError:
	Assert( ptdb != ptdbNil );
	ptdb->Delete( pinst );

	return err;
	}
	

LOCAL VOID CATIFreeSecondaryIndexes( FCB *pfcbSecondaryIndexes )
	{
	FCB		* pfcbT		= pfcbSecondaryIndexes;
	FCB		* pfcbKill;
	INST	* pinst;

	Assert( pfcbNil != pfcbSecondaryIndexes );
	pinst = PinstFromIfmp( pfcbSecondaryIndexes->Ifmp() );

	// Must clean up secondary index FCBs and primary index FCB separately,
	// because the secondary index FCBs may not be linked to the primary index FCB.
	while ( pfcbT != pfcbNil )
		{
		if ( pfcbT->Pidb() != pidbNil )
			{
			// No need to explicitly free index name or idxseg array, since
			// memory pool will be freed when TDB is deleted.
			pfcbT->ReleasePidb();
			}
		pfcbKill = pfcbT;
		pfcbT = pfcbT->PfcbNextIndex();

		//	synchronously purge the FCB

		pfcbKill->PrepareForPurge( fFalse );
		pfcbKill->Purge();
		}
	}


/*	get index info of a system table index
/**/
ERR ErrCATInitCatalogFCB( FUCB *pfucbTable )
	{
	ERR			err;
	PIB			*ppib					= pfucbTable->ppib;
	const IFMP	ifmp					= pfucbTable->ifmp;
	FCB			*pfcb					= pfucbTable->u.pfcb;
	TDB			*ptdb					= ptdbNil;
	IDB			idb;
	UINT		iIndex;
	FCB			*pfcbSecondaryIndexes	= pfcbNil;
	const PGNO	pgnoTableFDP			= pfcb->PgnoFDP();
	const BOOL	fShadow					= ( pgnoFDPMSOShadow == pgnoTableFDP );
	BOOL		fProcessedPrimary		= fFalse;
	BOOL		fAbove					= fFalse;

	INST		*pinst = PinstFromIfmp( ifmp );

	Assert( !pfcb->FInitialized() );
	Assert( pfcb->Ptdb() == ptdbNil );

	Assert( FCATSystemTable( pgnoTableFDP ) );
	
	CallR( ErrCATIInitCatalogTDB( pinst, &ptdb ) );
	
	idb.SetLcid( lcidDefault );
	idb.SetDwLCMapFlags( dwLCMapFlagsDefault );
	idb.SetCidxsegConditional( 0 );

	Assert( pfcbSecondaryIndexes == pfcbNil );
	const IDESC			*pidesc		= rgidescMSO;
	for( iIndex = 0; iIndex < cIndexesMSO; iIndex++, pidesc++ )
		{
		USHORT		itagIndexName;

		// Add index name to table's byte pool.  On error, the entire TDB
		// and its byte pool is nuked, so we don't have to worry about
		// freeing the memory for the index name.
		Call( ptdb->MemPool().ErrAddEntry(
					(BYTE *)pidesc->szIdxName,
					(ULONG)strlen( pidesc->szIdxName ) + 1,
					&itagIndexName ) );
		idb.SetItagIndexName( itagIndexName );
		idb.SetCidxseg( CfieldCATKeyString( pidesc->szIdxKeys, idb.rgidxseg ) );
		idb.SetFlagsFromGrbit( pidesc->grbit );

		//	catalog indexes are always unique -- if this changes,
		//	ErrCATICreateCatalogIndexes() will have to be modified
		Assert( idb.FUnique() );

		//	catalog indexes are not over Unicode columns
		Assert( !idb.FLocaleId() );

		const BOOL	fPrimary = idb.FPrimary();
		if ( fPrimary )
			{
			Assert( !fProcessedPrimary );
			
			idb.SetCbVarSegMac( JET_cbPrimaryKeyMost );
				
			//	initialize FCB for this index
			//
			Call( ErrFILEIInitializeFCB(
					ppib,
					ifmp,
					ptdb,
					pfcb,
					&idb,
					fTrue,
					pgnoTableFDP,
					ulFILEDefaultDensity ) );

			pfcb->SetInitialIndex();
			fProcessedPrimary = fTrue;
			}
		else if ( !fShadow )
			{
			FUCB	*pfucbSecondaryIndex;
			PGNO	pgnoIndexFDP;
			OBJID	objidIndexFDP;

			idb.SetCbVarSegMac( JET_cbSecondaryKeyMost );
			
			// UNDONE:  This is a real hack to get around the problem of
			// determining pgnoFDPs of secondary system table indexes.
			// These values are currently hard-coded.
			Assert( pidesc == rgidescMSO + iIndex );
			if ( 1 == iIndex )
				{
				Assert( strcmp( pidesc->szIdxName, szMSONameIndex ) == 0 );
				pgnoIndexFDP = pgnoFDPMSO_NameIndex;
				objidIndexFDP = objidFDPMSO_NameIndex;
				}
			else
				{
				Assert( 2 == iIndex );
				Assert( strcmp( pidesc->szIdxName, szMSORootObjectsIndex ) == 0 );
				pgnoIndexFDP = pgnoFDPMSO_RootObjectIndex;
				objidIndexFDP = objidFDPMSO_RootObjectIndex;
				}

			Assert( idb.FUnique() );	//	all catalog indexes are unique
			Call( ErrDIROpenNoTouch(
						ppib,
						ifmp,
						pgnoIndexFDP,
						objidIndexFDP,
						fTrue,					//	all catalog indexes are unique
						&pfucbSecondaryIndex ) );

			Assert( !pfucbSecondaryIndex->u.pfcb->FInitialized() );
				
			err = ErrFILEIInitializeFCB(
					ppib,
					ifmp,
					ptdb,
					pfucbSecondaryIndex->u.pfcb,
					&idb,
					fFalse,
					pgnoIndexFDP,
					ulFILEDefaultDensity );
			if ( err < 0 )
				{
				DIRClose( pfucbSecondaryIndex );
				goto HandleError;
				}
					
			pfucbSecondaryIndex->u.pfcb->SetPfcbNextIndex( pfcbSecondaryIndexes );
			pfcbSecondaryIndexes = pfucbSecondaryIndex->u.pfcb;

			Assert( pfucbSecondaryIndex->u.pfcb->FAboveThreshold() ==
					BOOL( pfucbSecondaryIndex->u.pfcb >= PfcbFCBPreferredThreshold( pinst ) ) );
			fAbove |= pfucbSecondaryIndex->u.pfcb->FAboveThreshold();

			//	mark the secondary index as being initialized successfully

			pfucbSecondaryIndex->u.pfcb->SetInitialIndex();
			pfucbSecondaryIndex->u.pfcb->CreateComplete();
					
			DIRClose( pfucbSecondaryIndex );
			}
		}

	// All system tables have a primary index.
	Assert( fProcessedPrimary );

	// Try to compact byte pool, but if it fails, don't worry.  It just means
	// that the byte pool will have some unused space.
	ptdb->MemPool().FCompact();

	/*	link up sequential/primary index with the rest of the indexes
	/**/
	pfcb->SetPfcbNextIndex( pfcbSecondaryIndexes );

	/*	link up pfcbTable of secondary indexes
	/**/
	pfcb->LinkPrimaryIndex();

	//	set the above-threshold flag if any of the new
	//		secondary-index FCBs are above the threshold
	//
	//	since the FCB is pinned by pfucbTable, it will 
	//		not be in the avail list so we can directly 
	//		set the above-threshold flag without trying
	//		to manage the avail list

	if ( fAbove )
		{
		pfcb->SetAboveThreshold();
		}

	FILESetAllIndexMask( pfcb );
	pfcb->SetFixedDDL();
	pfcb->SetTypeTable();

	return JET_errSuccess;

	/*	error handling
	/**/
HandleError:
	// Must clean up secondary index FCBs and primary index FCB separately,
	// because the secondary index FCBs never got linked to the primary
	// index FCB.
	if ( pfcbNil != pfcbSecondaryIndexes )
		CATIFreeSecondaryIndexes( pfcbSecondaryIndexes );
	
	// No need to explicitly free index name or idxseg array, since
	// memory pool will be freed when TDB is deleted below.
	if ( pfcb->Pidb() != pidbNil )
		{
		pfcb->ReleasePidb();
		pfcb->SetPidb( pidbNil );
		}
	
	Assert( pfcb->Ptdb() == ptdbNil || pfcb->Ptdb() == ptdb );
	Assert( ptdb != ptdbNil );
	ptdb->Delete( pinst );
	pfcb->SetPtdb( ptdbNil );

	return err;
	}

LOCAL ERR ErrCATIFindHighestColumnid(
	PIB					*ppib,
	FUCB				*pfucbCatalog,
	const OBJID			objidTable,
	const JET_COLUMNID	columnidLeast,
	JET_COLUMNID		*pcolumnidMost )
	{
	ERR					err;
	SYSOBJ				sysobj		= sysobjColumn;
	DATA				dataField;
	BOOL				fLatched	= fFalse;
	
	Assert( *pcolumnidMost == fidFixedMost
		|| *pcolumnidMost == fidVarMost
		|| *pcolumnidMost == fidTaggedMost );

	//	should be on primary index
	Assert( pfucbNil == pfucbCatalog->pfucbCurIndex );
	Assert( !Pcsr( pfucbCatalog )->FLatched() );
	
	Call( ErrIsamMakeKey(
				ppib,
				pfucbCatalog,
				(BYTE *)&objidTable,
				sizeof(objidTable),
				JET_bitNewKey ) );
	Call( ErrIsamMakeKey(
				ppib,
				pfucbCatalog,
				(BYTE *)&sysobj,
				sizeof(sysobj),
				NO_GRBIT ) );
	Call( ErrIsamMakeKey(
				ppib,
				pfucbCatalog,
				(BYTE *)pcolumnidMost,
				sizeof(*pcolumnidMost),
				NO_GRBIT ) );
				
	//	should never return RecordNotFound, because in the worst
	//	case (ie. no columns), we should seek back to the Table record.
	err = ErrIsamSeek( ppib, pfucbCatalog, JET_bitSeekLE );
	Assert( JET_errRecordNotFound != err );
	Call( err );


	Assert( JET_errSuccess == err || JET_wrnSeekNotEqual == err );
	if ( JET_wrnSeekNotEqual == err )
		{
		Assert( !Pcsr( pfucbCatalog )->FLatched() );
		Call( ErrDIRGet( pfucbCatalog ) );
		fLatched = fTrue;
	
		Assert( FFixedFid( fidMSO_Type ) );
		Call( ErrRECIRetrieveFixedColumn(
					pfcbNil,
					pfucbCatalog->u.pfcb->Ptdb(),
					fidMSO_Type,
					pfucbCatalog->kdfCurr.data,
					&dataField ) );
		CallS( err );
		Assert( dataField.Cb() == sizeof(SYSOBJ) );

		if ( sysobjColumn == *( (UnalignedLittleEndian< SYSOBJ > *)dataField.Pv() ) )
			{
			Assert( FFixedFid( fidMSO_Id ) );
			Call( ErrRECIRetrieveFixedColumn(
						pfcbNil,
						pfucbCatalog->u.pfcb->Ptdb(),
						fidMSO_Id,
						pfucbCatalog->kdfCurr.data,
						&dataField ) );
			CallS( err );
			Assert( dataField.Cb() == sizeof(JET_COLUMNID) );

			Assert( *( (UnalignedLittleEndian< JET_COLUMNID > *)dataField.Pv() ) < *pcolumnidMost );
			Assert( *( (UnalignedLittleEndian< JET_COLUMNID > *)dataField.Pv() ) > 0 );

			JET_COLUMNID colidCur = *( (UnalignedLittleEndian< JET_COLUMNID >  *)dataField.Pv() );
			JET_COLUMNID colidLeast = columnidLeast - 1;
			//	might have found a column of a different type
			*pcolumnidMost = max( colidCur, colidLeast );
			}
		else
			{
			//	if no columns, must have seeked to table record
			Assert( sysobjTable == *( (UnalignedLittleEndian< SYSOBJ > *)dataField.Pv() ) );
			*pcolumnidMost = columnidLeast - 1;
			}
		}

#ifdef DEBUG
	else
		{
		Assert( !Pcsr( pfucbCatalog )->FLatched() );
		Call( ErrDIRGet( pfucbCatalog ) );
		fLatched = fTrue;
	
		Assert( FFixedFid( fidMSO_Id ) );
		Call( ErrRECIRetrieveFixedColumn(
					pfcbNil,
					pfucbCatalog->u.pfcb->Ptdb(),
					fidMSO_Id,
					pfucbCatalog->kdfCurr.data,
					&dataField ) );
		CallS( err );
		Assert( dataField.Cb() == sizeof(JET_COLUMNID) );
		
		//	the highest possible FID actually exists in this table
		Assert( *( (UnalignedLittleEndian< JET_COLUMNID > *)dataField.Pv() ) == *pcolumnidMost );
		}
#endif		

HandleError:
	if ( fLatched )
		{
		Assert( Pcsr( pfucbCatalog )->FLatched() );
		CallS( ErrDIRRelease( pfucbCatalog ) );
		}
		
	Assert( !Pcsr( pfucbCatalog )->FLatched() );
	
	return err;
	}

LOCAL ERR ErrCATIFindAllHighestColumnids(
	PIB				*ppib,
	FUCB			*pfucbCatalog,
	const OBJID		objidTable,
	TCIB			*ptcib )
	{
	ERR				err;
	FUCB			* pfucbCatalogDupe	= pfucbNil;
	COLUMNID		columnidMost;

	//	use dupe cursor to perform columnid seeks, so we won't
	//	lose our place
	CallR( ErrIsamDupCursor( ppib, pfucbCatalog, &pfucbCatalogDupe, NO_GRBIT ) );
	Assert( pfucbNil != pfucbCatalogDupe );

	//	this is an internal cursor - no dispatch needed
	Assert( pfucbCatalogDupe->pvtfndef == &vtfndefIsam );
	pfucbCatalogDupe->pvtfndef = &vtfndefInvalidTableid;

	columnidMost = fidFixedMost;
	Call( ErrCATIFindHighestColumnid(
				ppib,
				pfucbCatalogDupe,
				objidTable,
				fidFixedLeast,
				&columnidMost ) );
	ptcib->fidFixedLast = FidOfColumnid( columnidMost );
	Assert( ptcib->fidFixedLast == fidFixedLeast-1
		|| FFixedFid( ptcib->fidFixedLast ) );

	columnidMost = fidVarMost;
	Call( ErrCATIFindHighestColumnid(
				ppib,
				pfucbCatalogDupe,
				objidTable,
				fidVarLeast,
				&columnidMost ) );
	ptcib->fidVarLast = FidOfColumnid( columnidMost );
	Assert( ptcib->fidVarLast == fidVarLeast-1
		|| FVarFid( ptcib->fidVarLast ) );

	columnidMost = fidTaggedMost;
	Call( ErrCATIFindHighestColumnid(
				ppib,
				pfucbCatalogDupe,
				objidTable,
				fidTaggedLeast,
				&columnidMost ) );
	ptcib->fidTaggedLast = FidOfColumnid( columnidMost );
	Assert( ptcib->fidTaggedLast == fidTaggedLeast-1
		|| FTaggedFid( ptcib->fidTaggedLast ) );


HandleError:
	Assert( pfucbNil != pfucbCatalogDupe );
	CallS( ErrFILECloseTable( ppib, pfucbCatalogDupe ) );

	return err;
	}


LOCAL ERR ErrCATIFindLowestColumnid(
	PIB					*ppib,
	FUCB				*pfucbCatalog,
	const OBJID			objidTable,
	JET_COLUMNID		*pcolumnidLeast )
	{
	ERR					err;
	SYSOBJ				sysobj		= sysobjColumn;
	DATA				dataField;
	BOOL				fLatched	= fFalse;
	
	Assert( *pcolumnidLeast == fidFixedLeast
		|| *pcolumnidLeast == fidVarLeast
		|| *pcolumnidLeast == fidTaggedLeast );

	//	should be on primary index
	Assert( pfucbNil == pfucbCatalog->pfucbCurIndex );
	Assert( !Pcsr( pfucbCatalog )->FLatched() );
	
	Call( ErrIsamMakeKey(
				ppib,
				pfucbCatalog,
				(BYTE *)&objidTable,
				sizeof(objidTable),
				JET_bitNewKey ) );
	Call( ErrIsamMakeKey(
				ppib,
				pfucbCatalog,
				(BYTE *)&sysobj,
				sizeof(sysobj),
				NO_GRBIT ) );
	Call( ErrIsamMakeKey(
				ppib,
				pfucbCatalog,
				(BYTE *)pcolumnidLeast,
				sizeof(*pcolumnidLeast),
				NO_GRBIT ) );
				
	err = ErrIsamSeek( ppib, pfucbCatalog, JET_bitSeekGE );

	if ( JET_wrnSeekNotEqual == err )
		{
		Assert( !Pcsr( pfucbCatalog )->FLatched() );
		Call( ErrDIRGet( pfucbCatalog ) );
		fLatched = fTrue;
	
		Assert( FFixedFid( fidMSO_Type ) );
		Call( ErrRECIRetrieveFixedColumn(
					pfcbNil,
					pfucbCatalog->u.pfcb->Ptdb(),
					fidMSO_Type,
					pfucbCatalog->kdfCurr.data,
					&dataField ) );
		CallS( err );
		Assert( dataField.Cb() == sizeof(SYSOBJ) );

		if ( sysobjColumn == *( (UnalignedLittleEndian< SYSOBJ > *)dataField.Pv() ) )
			{
			Assert( FFixedFid( fidMSO_Id ) );
			Call( ErrRECIRetrieveFixedColumn(
						pfcbNil,
						pfucbCatalog->u.pfcb->Ptdb(),
						fidMSO_Id,
						pfucbCatalog->kdfCurr.data,
						&dataField ) );
			CallS( err );
			Assert( dataField.Cb() == sizeof(COLUMNID) );

			Assert( *( (UnalignedLittleEndian< COLUMNID > *)dataField.Pv() ) <= fidMax );
			Assert( *( (UnalignedLittleEndian< COLUMNID > *)dataField.Pv() ) >= fidMin );
		
			//	note that we might have found a column of a different type
			*pcolumnidLeast = *( (UnalignedLittleEndian< COLUMNID > *)dataField.Pv() );
			}
		else
			{
			//	if no columns, must have seeked on some other object
			Assert( sysobjNil != *( (UnalignedLittleEndian< SYSOBJ > *)dataField.Pv() ) );
			*pcolumnidLeast -= 1;
			}
		}

	else if ( JET_errSuccess == err )
		{
#ifdef DEBUG
		Assert( !Pcsr( pfucbCatalog )->FLatched() );
		Call( ErrDIRGet( pfucbCatalog ) );
		fLatched = fTrue;
	
		Assert( FFixedFid( fidMSO_Id ) );
		Call( ErrRECIRetrieveFixedColumn(
					pfcbNil,
					pfucbCatalog->u.pfcb->Ptdb(),
					fidMSO_Id,
					pfucbCatalog->kdfCurr.data,
					&dataField ) );
		CallS( err );
		Assert( dataField.Cb() == sizeof(COLUMNID) );
		
		//	the lowest possible FID actually exists in this table
		Assert( *( (UnalignedLittleEndian< COLUMNID > *)dataField.Pv() ) == *pcolumnidLeast );
#endif		
		}

	else
		{
		Assert( err < 0 );
		if ( JET_errRecordNotFound == err )
			err = JET_errSuccess;

		*pcolumnidLeast -= 1;
		}

HandleError:
	if ( fLatched )
		{
		Assert( Pcsr( pfucbCatalog )->FLatched() );
		CallS( ErrDIRRelease( pfucbCatalog ) );
		}
		
	Assert( !Pcsr( pfucbCatalog )->FLatched() );
	
	return err;
	}


/*	Populate a FIELD structure with column info.  Called by ErrCATConstructTDB()
/*	once the proper column has been located.
/**/
LOCAL ERR ErrCATIInitFIELD(
	PIB			*ppib,
	FUCB		*pfucbCatalog,
#ifdef DEBUG
	OBJID		objidTable,
#endif
	TDB			*ptdb,
	COLUMNID	*pcolumnid,
	FIELD		*pfield,
	DATA		&dataDefaultValue )
	{
	ERR			err;
	TDB			*ptdbCatalog;
	DATA		dataField;
	DATA&		dataRec			= pfucbCatalog->kdfCurr.data;

	Assert( locOnCurBM == pfucbCatalog->locLogical );
	Assert( Pcsr( pfucbCatalog )->FLatched() );

	Assert( pfcbNil != pfucbCatalog->u.pfcb );
	Assert( pfucbCatalog->u.pfcb->FTypeTable() );
	Assert( pfucbCatalog->u.pfcb->FFixedDDL() );
	Assert( pfucbCatalog->u.pfcb->Ptdb() != ptdbNil );
	ptdbCatalog = pfucbCatalog->u.pfcb->Ptdb();

#ifdef DEBUG
	//	verify still on same table
	Assert( FFixedFid( fidMSO_ObjidTable ) );
	Call( ErrRECIRetrieveFixedColumn(
				pfcbNil,
				ptdbCatalog,
				fidMSO_ObjidTable,
				dataRec,
				&dataField ) );
	CallS( err );
	Assert( dataField.Cb() == sizeof(OBJID) );
	Assert( objidTable == *( (UnalignedLittleEndian< OBJID > *)dataField.Pv() ) );

	//	verify this is a column
	Assert( FFixedFid( fidMSO_Type ) );
	Call( ErrRECIRetrieveFixedColumn(
				pfcbNil,
				ptdbCatalog,
				fidMSO_Type,
				dataRec,
				&dataField ) );
	CallS( err );
	Assert( dataField.Cb() == sizeof(SYSOBJ) );
	Assert( sysobjColumn == *( (UnalignedLittleEndian< SYSOBJ > *)dataField.Pv() ) );
#endif			
	

	Assert( FFixedFid( fidMSO_Id ) );
	Call( ErrRECIRetrieveFixedColumn(
				pfcbNil,
				ptdbCatalog,
				fidMSO_Id,
				dataRec,
				&dataField ) );
	CallS( err );
	Assert( dataField.Cb() == sizeof(COLUMNID) );
	*pcolumnid = *(UnalignedLittleEndian< COLUMNID > *) dataField.Pv();
//	UtilMemCpy( pfid, dataField.Pv(), sizeof(FID) );
	Assert( FCOLUMNIDValid( *pcolumnid ) );
	Assert( !FCOLUMNIDTemplateColumn( *pcolumnid ) );

	if ( ptdb->FTemplateTable() )
		COLUMNIDSetFTemplateColumn( *pcolumnid );

	Assert( FFixedFid( fidMSO_Coltyp ) );
	Call( ErrRECIRetrieveFixedColumn(
				pfcbNil,
				ptdbCatalog,
				fidMSO_Coltyp,
				dataRec,
				&dataField ) );
	CallS( err );
	Assert( dataField.Cb() == sizeof(JET_COLTYP) );
	pfield->coltyp = FIELD_COLTYP( *(UnalignedLittleEndian< JET_COLTYP > *)dataField.Pv() );
//	UtilMemCpy( &pfield->coltyp, dataField.Pv(), sizeof(JET_COLTYP) );
	Assert( pfield->coltyp >= JET_coltypNil );	// May be Nil if column deleted.
	Assert( pfield->coltyp < JET_coltypMax );

	Assert( FFixedFid( fidMSO_SpaceUsage ) );
	Call( ErrRECIRetrieveFixedColumn(
				pfcbNil,
				ptdbCatalog,
				fidMSO_SpaceUsage,
				dataRec,
				&dataField ) );
	CallS( err );
	Assert( dataField.Cb() == sizeof(ULONG) );
	pfield->cbMaxLen = *(UnalignedLittleEndian< ULONG > *) dataField.Pv();
//	UtilMemCpy( &pfield->cbMaxLen, dataField.Pv(), sizeof(ULONG) );

	Assert( FFixedFid( fidMSO_Localization ) );
	Call( ErrRECIRetrieveFixedColumn(
				pfcbNil,
				ptdbCatalog,
				fidMSO_Localization,
				dataRec,
				&dataField ) );
	CallS( err );
	Assert( dataField.Cb() == sizeof(ULONG) );
	pfield->cp = *(UnalignedLittleEndian< USHORT > *) dataField.Pv();
//	UtilMemCpy( &pfield->cp, dataField.Pv(), sizeof(USHORT) );
	if ( 0 != pfield->cp )
		{
		Assert( FRECTextColumn( pfield->coltyp ) || JET_coltypNil == pfield->coltyp );
		Assert( pfield->cp == usEnglishCodePage || pfield->cp == usUniCodePage );
		}

	Assert( FFixedFid( fidMSO_Flags ) );
	Call( ErrRECIRetrieveFixedColumn(
				pfcbNil,
				ptdbCatalog,
				fidMSO_Flags,
				dataRec,
				&dataField ) );
	CallS( err );
	Assert( dataField.Cb() == sizeof(ULONG) );
	pfield->ffield = *(UnalignedLittleEndian< FIELDFLAG > *) dataField.Pv();
//	UtilMemCpy( &pfield->ffield, dataField.Pv(), sizeof(FIELDFLAG) );
	Assert( !FFIELDVersioned( pfield->ffield ) );	// Versioned flag shouldn't persist.
	Assert( !FFIELDDeleted( pfield->ffield ) );

	Assert( FFixedFid( fidMSO_RecordOffset ) );
	Call( ErrRECIRetrieveFixedColumn(
				pfcbNil,
				ptdbCatalog,
				fidMSO_RecordOffset,
				dataRec,
				&dataField ) );
	if ( JET_wrnColumnNull == err )
		{
		Assert( dataField.Cb() == 0 );
		pfield->ibRecordOffset = 0;		// Set to a dummy value.
		}
	else
		{
		CallS( err );
		Assert( dataField.Cb() == sizeof(REC::RECOFFSET) );
		pfield->ibRecordOffset = *(UnalignedLittleEndian< REC::RECOFFSET > *) dataField.Pv();
//		UtilMemCpy( &pfield->ibRecordOffset, dataField.Pv(), sizeof(REC::RECOFFSET) );
		Assert( pfield->ibRecordOffset >= ibRECStartFixedColumns );
		}

	CHAR	szColumnName[JET_cbNameMost+1];
	Assert( FVarFid( fidMSO_Name ) );
	Call( ErrRECIRetrieveVarColumn(
				pfcbNil,
				ptdbCatalog,
				fidMSO_Name,
				dataRec,
				&dataField ) );
	CallS( err );
	Assert( dataField.Cb() <= JET_cbNameMost );
	UtilMemCpy( szColumnName, dataField.Pv(), dataField.Cb() );
	szColumnName[dataField.Cb()] = 0;		// Add null-termination.

	// Add column name to table's byte pool.  On error, the entire TDB
	// and its byte pool is nuked, so we don't have to worry about
	// freeing the memory for the column name.
	Call( ptdb->MemPool().ErrAddEntry( 
				(BYTE *)szColumnName, 
				dataField.Cb() + 1,
				&pfield->itagFieldName ) );
		pfield->strhashFieldName = StrHashValue( szColumnName );

	if( FFIELDUserDefinedDefault( pfield->ffield ) )
		{
		//  extract the callback information about this column
		//  add a CBDESC to the TDB
			
		Assert( FVarFid( fidMSO_Callback ) );
		Call( ErrRECIRetrieveVarColumn(
					pfcbNil,
					ptdbCatalog,
					fidMSO_Callback,
					dataRec,
					&dataField ) );
					
		Assert( dataField.Cb() > 0 );
		Assert( dataField.Cb() <= JET_cbNameMost );

		CHAR szCallback[JET_cbNameMost+1];
		UtilMemCpy( szCallback, dataField.Pv(), dataField.Cb() );
		szCallback[dataField.Cb()] = '\0';

		JET_CALLBACK callback;
		Call( ErrCALLBACKResolve( szCallback, &callback ) );

		Assert( FTaggedFid( fidMSO_CallbackData ) );
		ULONG cbUserData;
		cbUserData = 0;
		Call( ErrCATIRetrieveTaggedColumn(
				pfucbCatalog,
				fidMSO_CallbackData,
				1,
				dataRec,
				NULL,
				0,
				&cbUserData ) );
		Assert( JET_errSuccess == err
				|| JET_wrnColumnNull == err
				|| JET_wrnBufferTruncated == err );

		CBDESC * pcbdesc;
		pcbdesc = new CBDESC;
		if( NULL == pcbdesc )
			{
			Call( ErrERRCheck( JET_errOutOfMemory ) );
			}

		if( 0 == cbUserData )
			{
			pcbdesc->pvContext 	= NULL;
			pcbdesc->cbContext 	= 0;
			}
		else
			{
			pcbdesc->pvContext = (BYTE *)PvOSMemoryHeapAlloc( cbUserData );
			pcbdesc->cbContext 	= cbUserData;

			if( NULL == pcbdesc->pvContext )
				{
				delete pcbdesc;
				Call( ErrERRCheck( JET_errOutOfMemory ) );
				}

			Call( ErrCATIRetrieveTaggedColumn(
					pfucbCatalog,
					fidMSO_CallbackData,
					1,
					dataRec,
					reinterpret_cast<BYTE *>( pcbdesc->pvContext ),
					cbUserData,
					&cbUserData ) );
			Assert( JET_wrnBufferTruncated != err );
			}
				
		pcbdesc->pcallback 	= callback;
		pcbdesc->cbtyp 		= JET_cbtypUserDefinedDefaultValue;
		pcbdesc->ulId 		= *pcolumnid;
		pcbdesc->fPermanent = 1;
		pcbdesc->fVersioned = 0;
		
		ptdb->RegisterPcbdesc( pcbdesc );

		ptdb->SetFTableHasUserDefinedDefault();
		ptdb->SetFTableHasNonEscrowDefault();
		ptdb->SetFTableHasDefault();
		}
	else if ( FFIELDDefault( pfield->ffield ) )
		{
		Assert( FVarFid( fidMSO_DefaultValue ) );
		Call( ErrRECIRetrieveVarColumn(
					pfcbNil,
					ptdbCatalog,
					fidMSO_DefaultValue,
					dataRec,
					&dataField ) );
		Assert( dataField.Cb() <= cbDefaultValueMost );
		if ( dataField.Cb() > 0 )
			{
			dataField.CopyInto( dataDefaultValue );
			}
		else
			{
			AssertSz( fFalse, "Null default value detected in catalog." );
			Call( ErrERRCheck( JET_errCatalogCorrupted ) );
			}

		if ( !FFIELDEscrowUpdate( pfield->ffield ) )
			{
			ptdb->SetFTableHasNonEscrowDefault();
			}
		ptdb->SetFTableHasDefault();
		}
#ifdef DEBUG
	else
		{
		Assert( FVarFid( fidMSO_DefaultValue ) );
		Call( ErrRECIRetrieveVarColumn(
					pfcbNil,
					ptdbCatalog,
					fidMSO_DefaultValue,
					dataRec,
					&dataField ) );
		Assert( 0 == dataField.Cb() );
		}
#endif

HandleError:
	Assert( locOnCurBM == pfucbCatalog->locLogical );
	Assert( Pcsr( pfucbCatalog )->FLatched() );
	return err;
	}


LOCAL VOID CATPatchFixedOffsets(
	TDB *			ptdb,
	const COLUMNID	columnidLastKnownGood,
	const COLUMNID	columnidCurr )
	{
	Assert( FidOfColumnid( columnidLastKnownGood ) < FidOfColumnid( columnidCurr ) );
	Assert( FidOfColumnid( columnidLastKnownGood ) >= ptdb->FidFixedFirst() - 1 );
	Assert( FCOLUMNIDFixed( columnidCurr ) );
	Assert( FidOfColumnid( columnidCurr ) > ptdb->FidFixedFirst() );
	Assert( FidOfColumnid( columnidCurr ) <= ptdb->FidFixedLastInitial() );

	FIELD *	pfield		= ptdb->PfieldFixed( columnidLastKnownGood + 1 );
	FIELD *	pfieldCurr	= ptdb->PfieldFixed( columnidCurr );

	//	this function is only called if there are columns between the
	//	last known good one and the current one
	Assert( pfield < pfieldCurr );

	if ( FidOfColumnid( columnidLastKnownGood ) == ptdb->FidFixedFirst() - 1 )
		{
		pfield->ibRecordOffset = ptdb->IbEndFixedColumns();
		pfield++;
		}
		
	for ( ; pfield < pfieldCurr; pfield++ )
		{
		FIELD	* pfieldPrev	= pfield - 1;

		//	we're processing columns that have been removed from the catalog
		//	(either because an AddColumn rolled back or because they got
		//	deleted), so their FIELD structures should be zeroed out
		Assert( 0 == pfield->ibRecordOffset );
		Assert( 0 == pfield->cbMaxLen );
		Assert( JET_coltypNil == pfield->coltyp );
		Assert( pfieldPrev->ibRecordOffset >= ibRECStartFixedColumns );
		Assert( pfieldPrev->ibRecordOffset < pfieldCurr->ibRecordOffset );

		//	set offset to a bogus value (it doesn't matter because since
		//	the column is marked as deleted, we'll never retrieve it)
		//	note that previous column may have also been deleted, in
		//	which case its cbMaxLen will be 0, which is why we have
		//	the max() calculation
		pfield->ibRecordOffset = WORD( pfieldPrev->ibRecordOffset
										+ max( 1, pfieldPrev->cbMaxLen ) );
		Assert( pfield->ibRecordOffset < pfieldCurr->ibRecordOffset );
		}

	Assert( (pfieldCurr-1)->ibRecordOffset + max( 1, (pfieldCurr-1)->cbMaxLen )
		<= pfieldCurr->ibRecordOffset );
	}


INLINE VOID CATSetDeletedColumns( TDB *ptdb )
	{
	FIELD *				pfield		= ptdb->PfieldsInitial();
	const ULONG			cfields		= ptdb->CInitialColumns();
	const FIELD	* const	pfieldMax	= pfield + cfields;

	for ( ; pfield < pfieldMax; pfield++ )
		{
		ptdb->AssertFIELDValid( pfield );
		Assert( !FFIELDVersioned( pfield->ffield ) );
		Assert( !FFIELDDeleted( pfield->ffield ) );
		if ( JET_coltypNil == pfield->coltyp )
			{
			FIELDSetDeleted( pfield->ffield );
			}
		}
	}

LOCAL ERR ErrCATIBuildFIELDArray(
	PIB				*ppib,
	FUCB			*pfucbCatalog,
	const OBJID		objidTable,
	TDB				*ptdb )
	{
	ERR				err;
	const IFMP		ifmp					= pfucbCatalog->ifmp;
	const SYSOBJ	sysobj					= sysobjColumn;
	FUCB			fucbFake;
	FCB				fcbFake( ifmp, objidTable );	// actually expects a pgnoFDP, but it doesn't matter because it never gets referenced
	COLUMNID		columnid				= 0;
	COLUMNID		columnidPrevFixed;
	FIELD			field;
	DATA			dataField;
#ifdef INTRINSIC_LV
	BYTE			rgbDefaultValue[cbDefaultValueMost];
#else // INTRINSIC_LV
	BYTE			rgbDefaultValue[cbLVIntrinsicMost];
#endif // INTRINSIC_LV	
	DATA			dataDefaultValue;

	Assert( locOnCurBM == pfucbCatalog->locLogical );
	Assert( !Pcsr( pfucbCatalog )->FLatched() );

	//	move to columns
	err = ErrBTNext( pfucbCatalog, fDIRNull );
	if ( err < 0 )
		{
		Assert( JET_errRecordDeleted != err );
		Assert( locOnCurBM == pfucbCatalog->locLogical );
		Assert( Pcsr( pfucbCatalog )->FLatched() );
		if ( JET_errNoCurrentRecord != err )
			return err;
		}

	//	even if we got NoCurrentRecord, we are actually
	//	still left on the last node (usually, the DIR
	//	level corrects the currency)
	Assert( locOnCurBM == pfucbCatalog->locLogical );
	Assert( Pcsr( pfucbCatalog )->FLatched() );

	dataDefaultValue.SetPv( rgbDefaultValue );
	FILEPrepareDefaultRecord( &fucbFake, &fcbFake, ptdb );
	Assert( fucbFake.pvWorkBuf != NULL );

	columnidPrevFixed = ColumnidOfFid( ptdb->FidFixedFirst(), ptdb->FTemplateTable() ) - 1;

	//	UPDATE: use new FInitialisingDefaultRecord() flag instead of
	//	fudging FidFixedLast()
/*	//	must reset FidFixedLast to silence DEBUG checks in
	//	SetIbEndFixedColumns() and IbOffsetOfNextColumn()
	const FID	fidFixedLastSave	= ptdb->FidFixedLast();
	ptdb->SetFidFixedLast( FID( ptdb->FidFixedFirst() - 1 ) );
*/	

	while ( JET_errNoCurrentRecord != err )
		{
		BOOL	fAddDefaultValue	= fFalse;

		Call( err );			

		Assert( locOnCurBM == pfucbCatalog->locLogical );
		Assert( Pcsr( pfucbCatalog )->FLatched() );

		Assert( FFixedFid( fidMSO_ObjidTable ) );
		Call( ErrRECIRetrieveFixedColumn(
					pfcbNil,
					pfucbCatalog->u.pfcb->Ptdb(),
					fidMSO_ObjidTable,
					pfucbCatalog->kdfCurr.data,
					&dataField ) );
		CallS( err );
		Assert( dataField.Cb() == sizeof(OBJID) );
		if ( objidTable != *( (UnalignedLittleEndian< OBJID > *)dataField.Pv() ) )
			{
			goto DoneFields;
			}

		//	verify this is a column
		Assert( FFixedFid( fidMSO_Type ) );
		Call( ErrRECIRetrieveFixedColumn(
					pfcbNil,
					pfucbCatalog->u.pfcb->Ptdb(),
					fidMSO_Type,
					pfucbCatalog->kdfCurr.data,
					&dataField ) );
		CallS( err );
		Assert( dataField.Cb() == sizeof(SYSOBJ) );
		switch( *( (UnalignedLittleEndian< SYSOBJ > *)dataField.Pv() ) )
			{
			case sysobjColumn:
				break;

			case sysobjTable:
				AssertSz( fFalse, "Catalog corrupted - sysobj in invalid order." );
				err = ErrERRCheck( JET_errCatalogCorrupted );
				goto HandleError;

			default:
				goto DoneFields;
			}

		err = ErrCATIInitFIELD(
					ppib,
					pfucbCatalog,
#ifdef DEBUG
					objidTable,
#endif
					ptdb,
					&columnid,
					&field,
					dataDefaultValue );
		Call( err );

		Assert( FCOLUMNIDValid( columnid ) );
		const BOOL	fFixedColumn	= FCOLUMNIDFixed( columnid );
		if ( fFixedColumn )
			{
			Assert( FidOfColumnid( columnid ) >= ptdb->FidFixedFirst() );
			Assert( FidOfColumnid( columnid ) <= ptdb->FidTaggedLast() );
			}

		// If field is deleted, the coltyp for the FIELD entry should
		// already be JET_coltypNil (initialised that way).
		Assert( field.coltyp != JET_coltypNil
			|| ptdb->Pfield( columnid )->coltyp == JET_coltypNil );

		Assert( ( FCOLUMNIDTemplateColumn( columnid ) && ptdb->FTemplateTable() )
			|| ( !FCOLUMNIDTemplateColumn( columnid ) && !ptdb->FTemplateTable() ) );
		if ( ptdb->FTemplateTable() )
			{
			if ( !FFIELDTemplateColumnESE98( field.ffield ) )
				{
				ptdb->SetFESE97TemplateTable();

				if ( FCOLUMNIDTagged( columnid )
					&& FidOfColumnid( columnid ) > ptdb->FidTaggedLastOfESE97Template() )
					{
					ptdb->SetFidTaggedLastOfESE97Template( FidOfColumnid( columnid ) );
					}
				}
			}
		else if ( ptdb->FDerivedTable() )
			{
			FID		fidFirst;

			if ( FCOLUMNIDTagged( columnid ) )
				{
				fidFirst = ptdb->FidTaggedFirst();
				}
			else if ( FCOLUMNIDFixed( columnid ) )
				{
				fidFirst = ptdb->FidFixedFirst();
				}
			else
				{
				Assert( FCOLUMNIDVar( columnid ) );
				fidFirst = ptdb->FidVarFirst();
				}
			if ( FidOfColumnid( columnid ) < fidFirst )
				{
				Call( ErrERRCheck( JET_errDerivedColumnCorruption ) );
				}
			}

		Assert( locOnCurBM == pfucbCatalog->locLogical );
		Assert( Pcsr( pfucbCatalog )->FLatched() );

		if ( field.coltyp != JET_coltypNil )
			{
			Call( ErrRECAddFieldDef( ptdb, columnid, &field ) );

			/*	set version and auto increment field ids (these are mutually
			/*	exclusive (ie. a field can't be both version and autoinc).
			/**/
			Assert( ptdb->FidVersion() != ptdb->FidAutoincrement()
				|| ptdb->FidVersion() == 0 );
			if ( FFIELDVersion( field.ffield ) )
				{
				ptdb->SetFidVersion( FidOfColumnid( columnid ) );
				}
			if ( FFIELDAutoincrement( field.ffield ) )
				{
				ptdb->SetFidAutoincrement( FidOfColumnid( columnid ), field.coltyp == JET_coltypCurrency );
				}

			if ( fFixedColumn )
				{
				Assert( field.ibRecordOffset >= ibRECStartFixedColumns );
				Assert( field.cbMaxLen > 0 );

				Assert( FidOfColumnid( columnidPrevFixed ) <= FidOfColumnid( columnid ) - 1 );
				if ( FidOfColumnid( columnidPrevFixed ) < FidOfColumnid( columnid ) - 1 )
					{
					CATPatchFixedOffsets( ptdb, columnidPrevFixed, columnid );
					}
				columnidPrevFixed = columnid;

				//	Set the last offset.
				ptdb->SetIbEndFixedColumns(
							WORD( field.ibRecordOffset + field.cbMaxLen ),
							FidOfColumnid( columnid ) );
				}

			fAddDefaultValue = ( FFIELDDefault( field.ffield )
								&& !FFIELDUserDefinedDefault( field.ffield ) );
			}

		else if ( FCOLUMNIDTagged( columnid ) )
			{
			Assert( FidOfColumnid( columnid ) >= ptdb->FidTaggedFirst() );
			Assert( FidOfColumnid( columnid ) <= ptdb->FidTaggedLast() );
			if ( FidOfColumnid( columnid ) < ptdb->FidTaggedLast()
				&& !fGlobalRepair
				&& !rgfmp[ifmp].FReadOnlyAttach()
				&& JET_errSuccess == ErrPIBCheckUpdatable( ppib ) )
				{
				// Clean up unnecessary MSysColumn entries.
				Call( ErrBTRelease( pfucbCatalog ) );
				Call( ErrIsamDelete( ppib, pfucbCatalog ) );
				}
			}
		else if ( fFixedColumn )
			{
			// For deleted fixed columns, we still need its fixed offset.
			// In addition, we also need its length if it is the last fixed
			// column.  We use this length in order to calculate the 
			// offset to the rest of the record (past the fixed data).
			Assert( ptdb->Pfield( columnid )->coltyp == JET_coltypNil );
			Assert( ptdb->Pfield( columnid )->cbMaxLen == 0 );
			Assert( field.ibRecordOffset >= ibRECStartFixedColumns );
			Assert( field.cbMaxLen > 0 );

			ptdb->PfieldFixed( columnid )->ibRecordOffset = field.ibRecordOffset;
			ptdb->PfieldFixed( columnid )->cbMaxLen = field.cbMaxLen;

			Assert( FidOfColumnid( columnidPrevFixed ) <= FidOfColumnid( columnid ) - 1 );
			if ( FidOfColumnid( columnidPrevFixed ) < FidOfColumnid( columnid ) - 1 )
				{
				CATPatchFixedOffsets( ptdb, columnidPrevFixed, columnid );
				}
			columnidPrevFixed = columnid;

			//	Set the last offset.
			ptdb->SetIbEndFixedColumns(
						WORD( field.ibRecordOffset + field.cbMaxLen ),
						FidOfColumnid( columnid ) );
			}
		else
			{
			Assert( FCOLUMNIDVar( columnid ) );
			Assert( FidOfColumnid( columnid ) >= ptdb->FidVarFirst() );
			Assert( FidOfColumnid( columnid ) <= ptdb->FidVarLast() );
			if ( FidOfColumnid( columnid ) < ptdb->FidVarLast()
				&& !fGlobalRepair
				&& !rgfmp[ifmp].FReadOnlyAttach()
				&& JET_errSuccess == ErrPIBCheckUpdatable( ppib ) )
				{
				// Clean up unnecessary MSysColumn entries.
				Call( ErrBTRelease( pfucbCatalog ) );
				Call( ErrIsamDelete( ppib, pfucbCatalog ) );
				}
			}

		if ( fAddDefaultValue )
			{
			Assert( FFIELDDefault( field.ffield ) );
			Assert( !FFIELDUserDefinedDefault( field.ffield ) );
			Assert( JET_coltypNil != field.coltyp );
			Assert( FCOLUMNIDValid( columnid ) );

			// Only long values are allowed to be greater than cbColumnMost.
			Assert( dataDefaultValue.Cb() > 0 );
			Assert(	FRECLongValue( field.coltyp ) ?
						dataDefaultValue.Cb() <= JET_cbLVDefaultValueMost :
						dataDefaultValue.Cb() <= JET_cbColumnMost );

			ptdb->SetFInitialisingDefaultRecord();

			err = ErrRECSetDefaultValue( &fucbFake, columnid, dataDefaultValue.Pv(), dataDefaultValue.Cb() );
			CallS( err );

			ptdb->ResetFInitialisingDefaultRecord();
			
			Call( err );
			}

		err = ErrBTNext( pfucbCatalog, fDIRNull );

		//	we may have just deleted the record for a
		//	deleted column, and we may be at level 0,
		//	so the record may have gotten expunged
		if ( JET_errRecordDeleted == err )
			{
			BTSetupOnSeekBM( pfucbCatalog );
			err = ErrBTPerformOnSeekBM( pfucbCatalog, fDIRFavourNext );
			Assert( JET_errNoCurrentRecord != err );
			Assert( JET_errRecordDeleted != err );

			//	we never delete the highest columnid,
			//	so there must be at least one left
			Assert( JET_errRecordNotFound != err );
			Call( err );

			Assert( wrnNDFoundLess == err
				|| wrnNDFoundGreater == err );
			Assert( Pcsr( pfucbCatalog )->FLatched() );

			if ( wrnNDFoundGreater == err )
				{
				err = JET_errSuccess;
				}
			else
				{
				Assert( wrnNDFoundLess == err );
				err = ErrBTNext( pfucbCatalog, fDIRNull );
				Assert( JET_errNoCurrentRecord != err );
				Assert( JET_errRecordNotFound != err );
				Assert( JET_errRecordDeleted != err );
				}

			pfucbCatalog->locLogical = locOnCurBM;
			}
		}	//	while ( JET_errNoCurrentRecord != err )

	//	verify we didn't unexpectedly break out
	Assert( JET_errNoCurrentRecord == err );

	//	only way to get here is to hit the end of the catalog
	err = ErrERRCheck( wrnCATNoMoreRecords );


DoneFields:

	// Set Deleted bit for all deleted columns.
	CATSetDeletedColumns( ptdb );

	//	in case we have to chain together the buffers (to keep
	//	around copies of previous of old default records
	//	because other threads may have stale pointers),
	//	allocate a RECDANGLING buffer to preface the actual
	//	default record
	//
	RECDANGLING *	precdangling;

	precdangling = (RECDANGLING *)PvOSMemoryHeapAlloc( sizeof(RECDANGLING) + fucbFake.dataWorkBuf.Cb() );
	if ( NULL == precdangling )
		{
		err = ErrERRCheck( JET_errOutOfMemory );
		goto HandleError;
		}

	precdangling->precdanglingNext = NULL;
	precdangling->data.SetPv( (BYTE *)precdangling + sizeof(RECDANGLING) );
	fucbFake.dataWorkBuf.CopyInto( precdangling->data );
	ptdb->SetPdataDefaultRecord( &( precdangling->data ) );

HandleError:
	Assert( JET_errRecordDeleted != err );

	FILEFreeDefaultRecord( &fucbFake );

	//	even if we got NoCurrentRecord, we are actually
	//	still left on the last node (usually, the DIR
	//	level corrects the currency)
	Assert( locOnCurBM == pfucbCatalog->locLogical );
	Assert( Pcsr( pfucbCatalog )->FLatched() || err < 0 );

	return err;
	}


/*	construct a table TDB from the column info in the catalog
/**/
INLINE ERR ErrCATIInitTDB(
	PIB				*ppib,
	FUCB			*pfucbCatalog,
	const OBJID		objidTable,
	const CHAR		*szTableName,
	const BOOL		fTemplateTable,
	FCB				*pfcbTemplateTable,
	TDB				**pptdbNew )
	{
	ERR    			err;
	TDB				*ptdb		= ptdbNil;
	TCIB			tcib		= { fidFixedLeast-1, fidVarLeast-1, fidTaggedLeast-1 };
	INST			*pinst		= PinstFromPpib( ppib );
	BOOL			fOldFormat	= fFalse;

	Assert( locOnCurBM == pfucbCatalog->locLogical );
	Assert( !Pcsr( pfucbCatalog )->FLatched() );

	Call( ErrCATIFindAllHighestColumnids(
				ppib,
				pfucbCatalog,
				objidTable,
				&tcib ) );

	Call( ErrTDBCreate( pinst, &ptdb, &tcib, pfcbTemplateTable, fTrue ) );

	Assert( ptdb->FidVersion() == 0 );
	Assert( ptdb->FidAutoincrement() == 0 );
	Assert( tcib.fidFixedLast == ptdb->FidFixedLast() );
	Assert( tcib.fidVarLast == ptdb->FidVarLast() );
	Assert( tcib.fidTaggedLast == ptdb->FidTaggedLast() );
	Assert( ptdb->DbkMost() == 0 );
	Assert( ptdb->PfcbLV() == pfcbNil );
	Assert( ptdb->UlLongIdLast() == 0 );

	// Add table name.
	Assert( ptdb->ItagTableName() == 0 );
	MEMPOOL::ITAG	itagNew;
	Call( ptdb->MemPool().ErrAddEntry(
				(BYTE *)szTableName,
				(ULONG)strlen( szTableName ) + 1,
				&itagNew ) );
	Assert( itagNew == itagTDBTableName );
	ptdb->SetItagTableName( itagNew );

	// Inherit fidAutoinc and/or fidVersion from base table.
	Assert( ptdb->PfcbTemplateTable() == pfcbTemplateTable );

	if ( fTemplateTable )
		{
		ptdb->SetFTemplateTable();
		Assert( pfcbNil == pfcbTemplateTable );
		}
	else if ( pfcbNil != pfcbTemplateTable )
		{
		FID		fidT;

		Assert( ptdb->PfcbTemplateTable() == pfcbTemplateTable );
		ptdb->SetFDerivedTable();
		if ( ptdb->PfcbTemplateTable()->Ptdb()->FESE97TemplateTable() )
			ptdb->SetFESE97DerivedTable();

		// Can't have same fidAutoInc and fidVersion.
		fidT = pfcbTemplateTable->Ptdb()->FidAutoincrement();
		if ( fidT != 0 )
			{
			Assert( fidT != pfcbTemplateTable->Ptdb()->FidVersion() );
			ptdb->SetFidAutoincrement( FidOfColumnid( fidT ), pfcbTemplateTable->Ptdb()->F8BytesAutoInc() );
			}

		fidT = pfcbTemplateTable->Ptdb()->FidVersion();
		if ( fidT != 0 )
			{
			Assert( fidT != pfcbTemplateTable->Ptdb()->FidAutoincrement() );
			ptdb->SetFidVersion( fidT );
			}
		}

	Call( ErrCATIBuildFIELDArray( ppib, pfucbCatalog, objidTable, ptdb ) );
	CallSx( err, wrnCATNoMoreRecords );

	//	even if we got NoCurrentRecord, we are actually
	//	still left on the last node (usually, the DIR
	//	level corrects the currency)
	Assert( locOnCurBM == pfucbCatalog->locLogical );
	Assert( Pcsr( pfucbCatalog )->FLatched() );

	*pptdbNew	= ptdb;

	return err;
	

HandleError:
	Assert( err < 0 );
	
	// Delete TDB on error.	
	if ( ptdbNil != ptdb )
		ptdb->Delete( pinst );
	
	Assert( locOnCurBM == pfucbCatalog->locLogical );

	return err;
	}


/*	Populate an IDB structure with index info.
/**/
LOCAL ERR ErrCATIInitIDB(
	PIB			*ppib,
	FUCB		*pfucbCatalog,
#ifdef DEBUG
	OBJID		objidTable,
#endif	
	TDB			* const ptdb,
	IDB			* const pidb,
	PGNO		*ppgnoIndexFDP,
	OBJID		*ppgnoObjidFDP,
	ULONG_PTR	*pul )	// Density if non-derived index, pfcbTemplateIndex if derived index
	{
	ERR		err;
	TDB		*ptdbCatalog;
	DATA	dataField;
	CHAR	szIndexName[ JET_cbNameMost+1 ];

	Assert( ptdbNil != ptdb );
	Assert( pidbNil != pidb );	
	Assert( NULL != pul );

	Assert( locOnCurBM == pfucbCatalog->locLogical );
	Assert( Pcsr( pfucbCatalog )->FLatched() );
	DATA&	dataRec = pfucbCatalog->kdfCurr.data;

	Assert( pfcbNil != pfucbCatalog->u.pfcb );
	Assert( pfucbCatalog->u.pfcb->FTypeTable() );
	Assert( pfucbCatalog->u.pfcb->FFixedDDL() );
	Assert( pfucbCatalog->u.pfcb->Ptdb() != ptdbNil );
	ptdbCatalog = pfucbCatalog->u.pfcb->Ptdb();


#ifdef DEBUG
	//	verify still on same table
	Assert( FFixedFid( fidMSO_ObjidTable ) );
	Call( ErrRECIRetrieveFixedColumn(
				pfcbNil,
				ptdbCatalog,
				fidMSO_ObjidTable,
				dataRec,
				&dataField ) );
	CallS( err );
	Assert( dataField.Cb() == sizeof(OBJID) );
	Assert( objidTable == *( (UnalignedLittleEndian< OBJID > *)dataField.Pv() ) );

	//	verify this is an index
	Assert( FFixedFid( fidMSO_Type ) );
	Call( ErrRECIRetrieveFixedColumn(
				pfcbNil,
				ptdbCatalog,
				fidMSO_Type,
				dataRec,
				&dataField ) );
	CallS( err );
	Assert( dataField.Cb() == sizeof(SYSOBJ) );
	Assert( sysobjIndex == *( (UnalignedLittleEndian< SYSOBJ > *)dataField.Pv() ) );
#endif			
	
	Assert( FVarFid( fidMSO_Name ) );
	Call( ErrRECIRetrieveVarColumn(
				pfcbNil,
				ptdbCatalog,
				fidMSO_Name,
				dataRec,
				&dataField ) );
	CallS( err );
	Assert( dataField.Cb() > 0 );
	Assert( dataField.Cb() <= JET_cbNameMost );
	UtilMemCpy( szIndexName, dataField.Pv(), dataField.Cb() );
	szIndexName[dataField.Cb()] = 0;

	Assert( FFixedFid( fidMSO_PgnoFDP ) );
	Call( ErrRECIRetrieveFixedColumn(
				pfcbNil,
				ptdbCatalog,
				fidMSO_PgnoFDP,
				dataRec,
				&dataField ) );
	CallS( err );
	Assert( dataField.Cb() == sizeof(PGNO) );
	*ppgnoIndexFDP = *(UnalignedLittleEndian< PGNO > *) dataField.Pv();
//	UtilMemCpy( ppgnoIndexFDP, dataField.Pv(), sizeof(PGNO) );

	Assert( FFixedFid( fidMSO_Id ) );
	Call( ErrRECIRetrieveFixedColumn(
				pfcbNil,
				ptdbCatalog,
				fidMSO_Id,
				dataRec,
				&dataField ) );
	CallS( err );
	Assert( dataField.Cb() == sizeof(OBJID) );
	*ppgnoObjidFDP = *(UnalignedLittleEndian< PGNO > *) dataField.Pv();
//	UtilMemCpy( ppgnoObjidFDP, dataField.Pv(), sizeof(PGNO) );

	LE_IDXFLAG*	ple_idxflag;
	IDXFLAG		idxflag;
	Assert( FFixedFid( fidMSO_Flags ) );
	Call( ErrRECIRetrieveFixedColumn(
				pfcbNil,
				ptdbCatalog,
				fidMSO_Flags,
				dataRec,
				&dataField ) );
	CallS( err );
	Assert( dataField.Cb() == sizeof(ULONG) );
	ple_idxflag = (LE_IDXFLAG*)dataField.Pv();
	pidb->SetPersistedFlags( ple_idxflag->fidb );
	idxflag = ple_idxflag->fIDXFlags;
	
	//	verify flags that shouldn't be persisted, aren't
	Assert( !pidb->FVersioned() );
	Assert( !pidb->FVersionedCreate() );
	Assert( !pidb->FDeleted() );

	if ( pidb->FDerivedIndex() )
		{
		FCB	*pfcbTemplateIndex = ptdb->PfcbTemplateTable();
		Assert( pfcbNil != pfcbTemplateIndex );
		TDB	*ptdbTemplate = pfcbTemplateIndex->Ptdb();
		Assert( ptdbNil != ptdbTemplate );
		
		forever
			{
			Assert( pfcbNil != pfcbTemplateIndex );
			if ( pfcbTemplateIndex->Pidb() == pidbNil )
				{
				Assert( pfcbTemplateIndex == ptdb->PfcbTemplateTable() );
				Assert( pfcbTemplateIndex->FPrimaryIndex() );
				Assert( pfcbTemplateIndex->FSequentialIndex() );
				Assert( pfcbTemplateIndex->FTypeTable() );
				}
			else
				{
				if ( pfcbTemplateIndex == ptdb->PfcbTemplateTable() )
					{
					Assert( pfcbTemplateIndex->FPrimaryIndex() );
					Assert( !pfcbTemplateIndex->FSequentialIndex() );
					Assert( pfcbTemplateIndex->FTypeTable() );
					}
				else
					{
					Assert( pfcbTemplateIndex->FTypeSecondaryIndex() );
					}
				const USHORT	itagTemplateIndex = pfcbTemplateIndex->Pidb()->ItagIndexName();
				if ( UtilCmpName( szIndexName, ptdbTemplate->SzIndexName( itagTemplateIndex ) ) == 0 )
					break;
				}

			pfcbTemplateIndex = pfcbTemplateIndex->PfcbNextIndex();
			}

		*pul = (ULONG_PTR)pfcbTemplateIndex;
		
		return JET_errSuccess;
		}
			
	Assert( FFixedFid( fidMSO_SpaceUsage ) );
	Call( ErrRECIRetrieveFixedColumn(
				pfcbNil,
				ptdbCatalog,
				fidMSO_SpaceUsage,
				dataRec,
				&dataField ) );
	CallS( err );
	Assert( dataField.Cb() == sizeof(ULONG) );
	ULONG	ulDensity;
	ulDensity = *(UnalignedLittleEndian< ULONG > *) dataField.Pv();
//	UtilMemCpy( &ulDensity, dataField.Pv(), sizeof(ULONG) );
	Assert( ulDensity >= ulFILEDensityLeast );
	Assert( ulDensity<= ulFILEDensityMost );

	//	WARNING: Can't copy directly to pul because it may be 64-bit
	*pul = ulDensity;

	Assert( FFixedFid( fidMSO_Localization ) );
	Call( ErrRECIRetrieveFixedColumn(
				pfcbNil,
				ptdbCatalog,
				fidMSO_Localization,
				dataRec,
				&dataField ) );
	CallS( err );
	Assert( dataField.Cb() == sizeof(LCID) );
	pidb->SetLcid( *(UnalignedLittleEndian< LCID > *) dataField.Pv() );
//	UtilMemCpy( &pidb->lcid, dataField.Pv(), sizeof(LCID) );

	if ( lcidNone == pidb->Lcid() )
		{
		//	old format: fLocaleId is FALSE and lcid == 0
		//	force lcid to default value
		Assert( !pidb->FLocaleId() );
		pidb->SetLcid( lcidDefault );
		}
	else if ( pidb->FLocalizedText() )
		{
		if ( pidb->Lcid() != lcidDefault
			&& pidb->Lcid() != idxunicodeDefault.lcid )
			{
			Call( ErrNORMCheckLcid( pidb->Lcid() ) );
			}
		else
			{
			Assert( JET_errSuccess == ErrNORMCheckLcid( pidb->Lcid() ) );
			}
		}

	Assert( FFixedFid( fidMSO_LCMapFlags ) );
	Call( ErrRECIRetrieveFixedColumn(
				pfcbNil,
				ptdbCatalog,
				fidMSO_LCMapFlags,
				dataRec,
				&dataField ) );
	if ( dataField.Cb() == 0 )
		{
		Assert( JET_wrnColumnNull == err );

		//	old format: fLocaleId is FALSE and lcid == 0
		//	(forced above to default value)
		pidb->SetDwLCMapFlags( dwLCMapFlagsDefaultOBSOLETE );
		}
	else
		{
		CallS( err );
		Assert( dataField.Cb() == sizeof(DWORD) );
		pidb->SetDwLCMapFlags( *(UnalignedLittleEndian< DWORD > *) dataField.Pv() );
//		UtilMemCpy( &dwMapFlags, dataField.Pv(), sizeof(DWORD) );
		Assert( JET_errSuccess == ErrNORMCheckLCMapFlags( pidb->DwLCMapFlags() ) );
		}

	// UNDONE: make VarSegMac an array parallel to
	// KeyFldIDs so cbVarSegMac can be specified
	// on a per-field basis
	Assert( FVarFid( fidMSO_VarSegMac ) );
	Call( ErrRECIRetrieveVarColumn(
				pfcbNil,
				ptdbCatalog,
				fidMSO_VarSegMac,
				dataRec,
				&dataField ) );
	if ( dataField.Cb() == 0 )
		{
		Assert( JET_wrnColumnNull == err );
		pidb->SetCbVarSegMac( BYTE( KEY::CbKeyMost( pidb->FPrimary() ) ) );
		}
	else
		{
		CallS( err );
		Assert( dataField.Cb() == sizeof(USHORT) );
		Assert( *( (UnalignedLittleEndian<USHORT> *)dataField.Pv()) <= 0xff );	//  we will store this in one byte
		pidb->SetCbVarSegMac( BYTE( *(UnalignedLittleEndian< USHORT > *)dataField.Pv() ) );
//		UtilMemCpy( &pidb->cbVarSegMac, dataField.Pv(), sizeof(pidb->cbVarSegMac) );
		Assert( pidb->CbVarSegMac() > 0 );
		Assert( pidb->CbVarSegMac() < KEY::CbKeyMost( pidb->FPrimary() ) );
		}

	Assert( FVarFid( fidMSO_KeyFldIDs ) );
	Call( ErrRECIRetrieveVarColumn(
			pfcbNil,
			ptdbCatalog,
			fidMSO_KeyFldIDs,
			dataRec,
			&dataField ) );
	CallS( err );
	Assert( dataField.Cb() > 0 );

	// the length of the list of key fields should be a multiple
	// of the length of one field.
	if ( FIDXExtendedColumns( idxflag ) )
		{
		Assert( sizeof(IDXSEG) == sizeof(JET_COLUMNID) );
		Assert( dataField.Cb() <= sizeof(JET_COLUMNID) * JET_ccolKeyMost );
		Assert( dataField.Cb() % sizeof(JET_COLUMNID) == 0 );
		Assert( dataField.Cb() / sizeof(JET_COLUMNID) <= JET_ccolKeyMost );
		pidb->SetCidxseg( (BYTE)( dataField.Cb() / sizeof(JET_COLUMNID) ) );
		Call( ErrIDBSetIdxSeg( pidb, ptdb, fFalse, ( const LE_IDXSEG* const )dataField.Pv() ) );
		}
	else
		{
		Assert( sizeof(IDXSEG_OLD) == sizeof(FID) );
		Assert( dataField.Cb() <= sizeof(FID) * JET_ccolKeyMost );
		Assert( dataField.Cb() % sizeof(FID) == 0);
		Assert( dataField.Cb() / sizeof(FID) <= JET_ccolKeyMost );
		pidb->SetCidxseg( (BYTE)( dataField.Cb() / sizeof(FID) ) );
		Call( ErrIDBSetIdxSegFromOldFormat(
					pidb,
					ptdb,
					fFalse,
					(UnalignedLittleEndian< IDXSEG_OLD > *)dataField.Pv() ) );
		}

	
	Assert( FVarFid( fidMSO_ConditionalColumns ) );
	Call( ErrRECIRetrieveVarColumn(
				pfcbNil,
				ptdbCatalog,
				fidMSO_ConditionalColumns,
				dataRec,
				&dataField ) );
				
	// the length of the list of key fields should be a multiple
	// of the length of one field.
	if ( FIDXExtendedColumns( idxflag ) )
		{
		Assert( sizeof(IDXSEG) == sizeof(JET_COLUMNID) );
		Assert( dataField.Cb() <= sizeof(JET_COLUMNID) * JET_ccolKeyMost );
		Assert( dataField.Cb() % sizeof(JET_COLUMNID) == 0 );
		Assert( dataField.Cb() / sizeof(JET_COLUMNID) <= JET_ccolKeyMost );
		pidb->SetCidxsegConditional( (BYTE)( dataField.Cb() / sizeof(JET_COLUMNID) ) );
		Call( ErrIDBSetIdxSeg( pidb, ptdb, fTrue, (LE_IDXSEG*)dataField.Pv() ) );
		}
	else
		{
		Assert( sizeof(IDXSEG_OLD) == sizeof(FID) );
		Assert( dataField.Cb() <= sizeof(FID) * JET_ccolKeyMost );
		Assert( dataField.Cb() % sizeof(FID) == 0);
		Assert( dataField.Cb() / sizeof(FID) <= JET_ccolKeyMost );
		pidb->SetCidxsegConditional( (BYTE)( dataField.Cb() / sizeof(FID) ) );
		Call( ErrIDBSetIdxSegFromOldFormat(
					pidb,
					ptdb,
					fTrue,
					(UnalignedLittleEndian< IDXSEG_OLD > *)dataField.Pv() ) );
		}


	Assert( FVarFid( fidMSO_TupleLimits ) );
	Call( ErrRECIRetrieveVarColumn(
				pfcbNil,
				ptdbCatalog,
				fidMSO_TupleLimits,
				dataRec,
				&dataField ) );
	if ( dataField.Cb() == 0 )
		{
		Assert( JET_wrnColumnNull == err );
		}
	else
		{
		CallS( err );
		Assert( dataField.Cb() == sizeof(LE_TUPLELIMITS) );
		
		const LE_TUPLELIMITS * const	ple_tuplelimits		= (LE_TUPLELIMITS *)dataField.Pv();
		ULONG							ul;

		pidb->SetFTuples();

		ul = ple_tuplelimits->le_chLengthMin;
		pidb->SetChTuplesLengthMin( (USHORT)ul );

		ul = ple_tuplelimits->le_chLengthMax;
		pidb->SetChTuplesLengthMax( (USHORT)ul );

		ul = ple_tuplelimits->le_chToIndexMax;
		pidb->SetChTuplesToIndexMax( (USHORT)ul );
		}


	// Add index name to table's byte pool.  On error, the entire TDB
	// and its byte pool is nuked, so we don't have to worry about
	// freeing the memory for the index name.
	USHORT	itagIndexName;
	Call( ptdb->MemPool().ErrAddEntry(
						(BYTE *)szIndexName,
						(ULONG)strlen( szIndexName ) + 1,
						&itagIndexName ) );
	pidb->SetItagIndexName( itagIndexName );

HandleError:
	Assert( locOnCurBM == pfucbCatalog->locLogical );
	Assert( Pcsr( pfucbCatalog )->FLatched() );
	return err;
	}

LOCAL ERR ErrCATIInitIndexFCBs(
	PIB				*ppib,
	FUCB			*pfucbCatalog,
	const OBJID		objidTable,
	FCB				* const pfcb,
	TDB				* const ptdb,
	const ULONG		ulDefaultDensity )
	{
	ERR				err						= JET_errSuccess;
	const IFMP		ifmp					= pfcb->Ifmp();
	const SYSOBJ	sysobj					= sysobjIndex;
	FCB				*pfcbSecondaryIndexes	= pfcbNil;
	BOOL			fFoundPrimary			= fFalse;
	BOOL			fAbove					= fFalse;

	Assert( pfcb->Pidb() == pidbNil );
	Assert( ptdbNil != ptdb );
	
	Assert( locOnCurBM == pfucbCatalog->locLogical );
	Assert( Pcsr( pfucbCatalog )->FLatched() );

	do
		{
		DATA		dataField;
		IDB			idb;
		PGNO		pgnoIndexFDP;
		OBJID		objidIndexFDP;
		ULONG_PTR	ul;

		Call( err );			

		Assert( locOnCurBM == pfucbCatalog->locLogical );
		Assert( Pcsr( pfucbCatalog )->FLatched() );

		Assert( FFixedFid( fidMSO_ObjidTable ) );
		Call( ErrRECIRetrieveFixedColumn(
					pfcbNil,
					pfucbCatalog->u.pfcb->Ptdb(),
					fidMSO_ObjidTable,
					pfucbCatalog->kdfCurr.data,
					&dataField ) );
		CallS( err );
		Assert( dataField.Cb() == sizeof(OBJID) );
		if ( objidTable != *( (UnalignedLittleEndian< OBJID > *)dataField.Pv() ) )
			{
			goto CheckPrimary;
			}

		//	verify this is an index
		Assert( FFixedFid( fidMSO_Type ) );
		Call( ErrRECIRetrieveFixedColumn(
					pfcbNil,
					pfucbCatalog->u.pfcb->Ptdb(),
					fidMSO_Type,
					pfucbCatalog->kdfCurr.data,
					&dataField ) );
		CallS( err );
		Assert( dataField.Cb() == sizeof(SYSOBJ) );
		switch ( *( (UnalignedLittleEndian< SYSOBJ > *)dataField.Pv() ) )
			{
			case sysobjIndex:
				break;

			case sysobjLongValue:
			case sysobjCallback:
				goto CheckPrimary;

			case sysobjTable:
			case sysobjColumn:
			default:
				AssertSz( fFalse, "Catalog corrupted - sysobj in invalid order." );
				err = ErrERRCheck( JET_errCatalogCorrupted );
				goto HandleError;
			}


		/*	read the data
		/**/
		err = ErrCATIInitIDB(
					ppib,
					pfucbCatalog,
#ifdef DEBUG
					objidTable,
#endif						
					ptdb,
					&idb,
					&pgnoIndexFDP,
					&objidIndexFDP,
					&ul );	// returns density for non-derived index, and pfcbTemplateIndex for derived index
		Call( err );

		if ( idb.FPrimary() )
			{
			Assert( !fFoundPrimary );
			fFoundPrimary = fTrue;
			Assert( pgnoIndexFDP == pfcb->PgnoFDP() || fGlobalRepair );
			Call( ErrFILEIInitializeFCB(
				ppib,
				ifmp,
				ptdb,
				pfcb,
				&idb,
				fTrue,
				pfcb->PgnoFDP(),
				ul ) );
			pfcb->SetInitialIndex();
			}
		else
			{
			FUCB	*pfucbSecondaryIndex;
			
			Assert( pgnoIndexFDP != pfcb->PgnoFDP() || fGlobalRepair );
			Call( ErrDIROpenNoTouch(
						ppib,
						ifmp,
						pgnoIndexFDP,
						objidIndexFDP,
						idb.FUnique(),
						&pfucbSecondaryIndex ) );
			Assert( !pfucbSecondaryIndex->u.pfcb->FInitialized() );

			err = ErrFILEIInitializeFCB(
					ppib,
					ifmp,
					ptdb,
					pfucbSecondaryIndex->u.pfcb,
					&idb,
					fFalse,
					pgnoIndexFDP,
					ul );
			if ( err < 0 )
				{
				DIRClose( pfucbSecondaryIndex );
				goto HandleError;
				}
			Assert( pfucbSecondaryIndex->u.pfcb->ObjidFDP() == objidIndexFDP );

			pfucbSecondaryIndex->u.pfcb->SetPfcbNextIndex( pfcbSecondaryIndexes );
			pfcbSecondaryIndexes = pfucbSecondaryIndex->u.pfcb;

			Assert( pfucbSecondaryIndex->u.pfcb->FAboveThreshold() ==
					BOOL( pfucbSecondaryIndex->u.pfcb >= PfcbFCBPreferredThreshold( PinstFromPpib( ppib ) ) ) );
			fAbove |= pfucbSecondaryIndex->u.pfcb->FAboveThreshold();

			//	mark the secondary index as being initialized successfully

			pfucbSecondaryIndex->u.pfcb->SetInitialIndex();
			pfucbSecondaryIndex->u.pfcb->CreateComplete();
			
			DIRClose( pfucbSecondaryIndex );
			}

		Assert( locOnCurBM == pfucbCatalog->locLogical );
		Assert( Pcsr( pfucbCatalog )->FLatched() );

		err = ErrBTNext( pfucbCatalog, fDIRNull );
		Assert( JET_errRecordDeleted != err );
		}
	while ( JET_errNoCurrentRecord != err );

	//	verify we didn't unexpectedly break out
	Assert( JET_errNoCurrentRecord == err );

	//	only way to get here is to hit the end of the catalog
	err = ErrERRCheck( wrnCATNoMoreRecords );


CheckPrimary:
	CallSx( err, wrnCATNoMoreRecords );

	if ( !fFoundPrimary )
		{		
		const ERR	errInit	= ErrFILEIInitializeFCB(
										ppib,
										ifmp,
										ptdb,
										pfcb,
										pidbNil,
										fTrue,
										pfcb->PgnoFDP(),
										ulDefaultDensity );
		if ( errInit < 0 )
			{
			err = errInit;
			goto HandleError;
			}

		//	should be success, so just ignore it (to preserve wrnCATNoMoreRecords)
		CallS( errInit );
		}

	/*	link up sequential/primary index with the rest of the indexes
	/**/
	pfcb->SetPfcbNextIndex( pfcbSecondaryIndexes );

	/*	link up pfcbTable of secondary indexes
	/**/
	pfcb->LinkPrimaryIndex();

	//	set the above-threshold flag if any of the new
	//		secondary-index FCBs are above the threshold
	//
	//	since the FCB is pinned by pfucbTable, it will 
	//		not be in the avail list so we can directly 
	//		set the above-threshold flag without trying
	//		to manage the avail list

	if ( fAbove )
		{
		pfcb->SetAboveThreshold();
		}

	FILESetAllIndexMask( pfcb );

	//	even if we got NoCurrentRecord, we are actually
	//	still left on the last node (usually, the DIR
	//	level corrects the currency)
	Assert( locOnCurBM == pfucbCatalog->locLogical );
	Assert( Pcsr( pfucbCatalog )->FLatched() );

	return err;

HandleError:
	Assert( err < 0 );

	if ( pfcbNil != pfcbSecondaryIndexes )
		CATIFreeSecondaryIndexes( pfcbSecondaryIndexes );

	// No need to explicitly free index name or idxseg array, since
	// memory pool will be freed when TDB is deleted below.
	if ( pfcb->Pidb() != pidbNil )
		{
		pfcb->ReleasePidb();
		pfcb->SetPidb( pidbNil );
		}
	//	even if we got NoCurrentRecord, we are actually
	//	still left on the last node (usually, the DIR
	//	level corrects the currency)
	Assert( locOnCurBM == pfucbCatalog->locLogical );
	Assert( Pcsr( pfucbCatalog )->FLatched() );

	return err;
	}
	

//  ================================================================
ERR ErrCATCopyCallbacks(
	PIB * const ppib,
	const IFMP ifmpSrc,
	const IFMP ifmpDest,
	const OBJID objidSrc,
	const OBJID objidDest )
//  ================================================================
//
//  Used by defrag to transport callbacks from one table to another
//
//-
	{
	const SYSOBJ	sysobj = sysobjCallback;

	ERR err = JET_errSuccess;

	FUCB * pfucbSrc = pfucbNil;
	FUCB * pfucbDest = pfucbNil;

	CallR( ErrDIRBeginTransaction( ppib, NO_GRBIT ) );
	
	Call( ErrCATOpen( ppib, ifmpSrc, &pfucbSrc ) );
	Call( ErrCATOpen( ppib, ifmpDest, &pfucbDest ) );

	Call( ErrIsamMakeKey(
				ppib,
				pfucbSrc,
				(BYTE *)&objidSrc,
				sizeof(objidSrc),
				JET_bitNewKey ) );
	Call( ErrIsamMakeKey(
				ppib,
				pfucbSrc,
				(BYTE *)&sysobj,
				sizeof(sysobj),
				NO_GRBIT ) );

	err = ErrIsamSeek( ppib, pfucbSrc, JET_bitSeekGT );
	if ( err < 0 )
		{
		if ( JET_errRecordNotFound != err )
			goto HandleError;
		}
	else
		{
		CallS( err );
		
		Call( ErrIsamMakeKey(
					ppib,
					pfucbSrc,
					(BYTE *)&objidSrc,
					sizeof(objidSrc),
					JET_bitNewKey ) );
		Call( ErrIsamMakeKey(
					ppib,
					pfucbSrc,
					(BYTE *)&sysobj,
					sizeof(sysobj),
					JET_bitStrLimit ) );
		err = ErrIsamSetIndexRange( ppib, pfucbSrc, JET_bitRangeUpperLimit );
		Assert( err <= 0 );
			
		while ( JET_errNoCurrentRecord != err )
			{
			Call( err );
			
			JET_RETRIEVECOLUMN	rgretrievecolumn[3];
			INT					iretrievecolumn		= 0;
			
			ULONG				cbtyp;
			CHAR				szCallback[JET_cbColumnMost+1];

			memset( rgretrievecolumn, 0, sizeof( rgretrievecolumn ) );

			rgretrievecolumn[iretrievecolumn].columnid 		= fidMSO_Flags;
			rgretrievecolumn[iretrievecolumn].pvData 		= (BYTE *)&cbtyp;
			rgretrievecolumn[iretrievecolumn].cbData		= sizeof( cbtyp );
			rgretrievecolumn[iretrievecolumn].itagSequence	= 1;
			++iretrievecolumn;	

			rgretrievecolumn[iretrievecolumn].columnid 		= fidMSO_Callback;
			rgretrievecolumn[iretrievecolumn].pvData 		= (BYTE *)szCallback;
			rgretrievecolumn[iretrievecolumn].cbData		= sizeof( szCallback );
			rgretrievecolumn[iretrievecolumn].itagSequence	= 1;
			ULONG& cbCallback = rgretrievecolumn[iretrievecolumn].cbActual;
			++iretrievecolumn;	

			Call( ErrIsamRetrieveColumns(
					(JET_SESID)ppib,
					(JET_TABLEID)pfucbSrc,
					rgretrievecolumn,
					iretrievecolumn ) );

			szCallback[cbCallback] = 0;
			
			Assert( cbtyp != JET_cbtypNull );

			Call( ErrCATAddTableCallback( ppib, pfucbDest, objidDest, (JET_CBTYP)cbtyp, szCallback ) );
			err = ErrIsamMove( ppib, pfucbSrc, JET_MoveNext, NO_GRBIT );
			}

		Assert( JET_errNoCurrentRecord == err );
		}

	err = JET_errSuccess;

HandleError:		
	if( pfucbNil != pfucbSrc )
		{
		CallS( ErrCATClose( ppib, pfucbSrc ) );
		}
	if( pfucbNil != pfucbDest )
		{
		CallS( ErrCATClose( ppib, pfucbDest ) );
		}

	if( err >= 0 )
		{
		err = ErrDIRCommitTransaction( ppib, NO_GRBIT );
		}
	else
		{
		CallSx( ErrDIRRollback( ppib ), JET_errRollbackError );
		}

	return err;
	}

				
//  ================================================================
LOCAL ERR ErrCATIInitCallbacks(
	PIB				*ppib,
	FUCB			*pfucbCatalog,
	const OBJID		objidTable,
	FCB				* const pfcb,
	TDB				* const ptdb )
//  ================================================================
	{
	ERR				err							= JET_errSuccess;
	const IFMP		ifmp						= pfcb->Ifmp();
	const SYSOBJ	sysobj						= sysobjCallback;
	BOOL			fMovedOffCurrentRecord		= fFalse;
	JET_CALLBACK	callback;
	ULONG			cbtyp;
	CHAR			szCallback[JET_cbColumnMost+1];
	DATA			dataField;
	
	Assert( locOnCurBM == pfucbCatalog->locLogical );
	Assert( Pcsr( pfucbCatalog )->FLatched() );

	Assert( !g_fCallbacksDisabled );
		
	do
		{
		Call( err );			

		Assert( locOnCurBM == pfucbCatalog->locLogical );
		Assert( Pcsr( pfucbCatalog )->FLatched() );

		Assert( FFixedFid( fidMSO_ObjidTable ) );
		Call( ErrRECIRetrieveFixedColumn(
					pfcbNil,
					pfucbCatalog->u.pfcb->Ptdb(),
					fidMSO_ObjidTable,
					pfucbCatalog->kdfCurr.data,
					&dataField ) );
		CallS( err );
		Assert( dataField.Cb() == sizeof(OBJID) );
		if ( objidTable != *( (UnalignedLittleEndian< OBJID > *)dataField.Pv() ) )
			{
			goto DoneCallbacks;
			}

		//	verify this is a callback
		Assert( FFixedFid( fidMSO_Type ) );
		Call( ErrRECIRetrieveFixedColumn(
					pfcbNil,
					pfucbCatalog->u.pfcb->Ptdb(),
					fidMSO_Type,
					pfucbCatalog->kdfCurr.data,
					&dataField ) );
		CallS( err );
		Assert( dataField.Cb() == sizeof(SYSOBJ) );
		switch( *( (UnalignedLittleEndian< SYSOBJ > *)dataField.Pv() ) )
			{
			case sysobjCallback:
				{
				Assert( FFixedFid( fidMSO_Flags ) );
				Call( ErrRECIRetrieveFixedColumn(
							pfcbNil,
							pfucbCatalog->u.pfcb->Ptdb(),
							fidMSO_Flags,
							pfucbCatalog->kdfCurr.data,
							&dataField ) );
				CallS( err );
				Assert( dataField.Cb() == sizeof(ULONG) );
				cbtyp = *(UnalignedLittleEndian< ULONG > *) dataField.Pv();
				Assert( JET_cbtypNull != cbtyp );

				Assert( FVarFid( fidMSO_Callback ) );
				Call( ErrRECIRetrieveVarColumn(
							pfcbNil,
							pfucbCatalog->u.pfcb->Ptdb(),
							fidMSO_Callback,
							pfucbCatalog->kdfCurr.data,
							&dataField ) );
				CallS( err );
				Assert( dataField.Cb() <= JET_cbNameMost );
				UtilMemCpy( szCallback, dataField.Pv(), dataField.Cb() );
				szCallback[dataField.Cb()] = 0;		// Add null-termination.
			
				Call( ErrCALLBACKResolve( szCallback, &callback ) );

				CBDESC * const pcbdescInsert = new CBDESC;	//	freed in TDB::Delete
				if( NULL == pcbdescInsert )
					{
					Call( ErrERRCheck( JET_errOutOfMemory ) );
					}

				pcbdescInsert->pcbdescNext	= NULL;
				pcbdescInsert->ppcbdescPrev	= NULL;
				pcbdescInsert->pcallback 	= callback;
				pcbdescInsert->cbtyp 		= cbtyp;
				pcbdescInsert->pvContext	= NULL;
				pcbdescInsert->cbContext	= 0;
				pcbdescInsert->ulId			= 0;
				pcbdescInsert->fPermanent	= fTrue;
				pcbdescInsert->fVersioned	= fFalse;
				ptdb->RegisterPcbdesc( pcbdescInsert );
				break;
				}

			case sysobjLongValue:
				//	skip LV's and continue moving to next record
				if ( !fMovedOffCurrentRecord )
					{
					break;
					}

				//	LV's MUST come before callbacks, else
				//	FALL THROUGH to corruption case

			case sysobjTable:
			case sysobjColumn:
			case sysobjIndex:
			default:
				//	callbacks are currently the last type of table-level sysobjs
				AssertSz( fFalse, "Catalog corrupted - sysobj in invalid order." );
				err = ErrERRCheck( JET_errCatalogCorrupted );
				goto HandleError;
			}

		Assert( locOnCurBM == pfucbCatalog->locLogical );
		Assert( Pcsr( pfucbCatalog )->FLatched() );

		fMovedOffCurrentRecord = fTrue;
		err = ErrBTNext( pfucbCatalog, fDIRNull );
		Assert( JET_errRecordDeleted != err );
		}
	while ( JET_errNoCurrentRecord != err );

	//	verify we didn't unexpectedly break out
	Assert( JET_errNoCurrentRecord == err );
	
	//	only way to get here is to hit the end of the catalog
	err = ErrERRCheck( wrnCATNoMoreRecords );


DoneCallbacks:
	CallSx( err, wrnCATNoMoreRecords );

HandleError:
	//	even if we got NoCurrentRecord, we are actually
	//	still left on the last node (usually, the DIR
	//	level corrects the currency)
	Assert( locOnCurBM == pfucbCatalog->locLogical );
	Assert( Pcsr( pfucbCatalog )->FLatched() );

	return err;
	}


ERR ErrCATInitFCB( FUCB *pfucbTable, OBJID objidTable )
	{
	ERR    		err;
	PIB			*ppib					= pfucbTable->ppib;
	INST		*pinst					= PinstFromPpib( ppib );
	const IFMP	ifmp					= pfucbTable->ifmp;
	FUCB   		*pfucbCatalog			= pfucbNil;
	FCB			*pfcb					= pfucbTable->u.pfcb;
	TDB			*ptdb					= ptdbNil;
	FCB			*pfcbTemplateTable		= pfcbNil;
	DATA		dataField;
	ULONG		ulDefaultDensity;
	ULONG		ulFlags;
	BOOL		fHitEOF					= fFalse;
	CHAR		szTableName[ JET_cbNameMost + 1 ];

	// Temporary table FCBs are initialised by CATInitTempFCB.
	Assert( dbidTemp != rgfmp[ifmp].Dbid() );

	Assert( !pfcb->FInitialized() );
	Assert( objidTable == pfucbTable->u.pfcb->ObjidFDP()
			|| objidNil == pfucbTable->u.pfcb->ObjidFDP() && fGlobalRepair );

	CallR( ErrCATOpen( ppib, ifmp, &pfucbCatalog ) );
	Assert( pfucbNil != pfucbCatalog );

	FUCBSetPrereadForward( pfucbCatalog, 3 );
		
	Call( ErrCATISeekTable( ppib, pfucbCatalog, objidTable ) );
	Assert( Pcsr( pfucbCatalog )->FLatched() );

	//	should be on primary index
	Assert( pfucbNil == pfucbCatalog->pfucbCurIndex );
	Assert( locOnCurBM == pfucbCatalog->locLogical );

	Assert( FVarFid( fidMSO_Name ) );
	Call( ErrRECIRetrieveVarColumn(
				pfcbNil,
				pfucbCatalog->u.pfcb->Ptdb(),
				fidMSO_Name,
				pfucbCatalog->kdfCurr.data,
				&dataField ) );
	CallS( err );
	Assert( dataField.Cb() <= JET_cbNameMost );
	UtilMemCpy( szTableName, dataField.Pv(), dataField.Cb() );
	szTableName[ dataField.Cb() ] = 0;

	Assert( FFixedFid( fidMSO_SpaceUsage ) );
	Call( ErrRECIRetrieveFixedColumn(
				pfcbNil,
				pfucbCatalog->u.pfcb->Ptdb(),
				fidMSO_SpaceUsage,
				pfucbCatalog->kdfCurr.data,
				&dataField ) );
	CallS( err );
	Assert( dataField.Cb() == sizeof(ULONG) );
	ulDefaultDensity = *(UnalignedLittleEndian< ULONG > *) dataField.Pv();
//	UtilMemCpy( &ulDefaultDensity, dataField.Pv(), sizeof(ULONG) );

	Assert( FFixedFid( fidMSO_Flags ) );
	Call( ErrRECIRetrieveFixedColumn(
				pfcbNil,
				pfucbCatalog->u.pfcb->Ptdb(),
				fidMSO_Flags,
				pfucbCatalog->kdfCurr.data,
				&dataField ) );
	CallS( err );
	Assert( dataField.Cb() == sizeof(ULONG) );
	ulFlags = *(UnalignedLittleEndian< ULONG > *) dataField.Pv();
//	UtilMemCpy( &ulFlags, dataField.Pv(), sizeof(ULONG) );

	//	WARNING: Must do this initial check for the value of ulFlags to get around an
	//	Alpha code gen bug.  The compiler recognises that we only want to compare against
	//	one byte of ulFlags, so it avoids loading the entire dword.  However, it is loading
	//	the incorrect byte.  Checking for non-zero here forces the compiler to load the
	//	entire dword.
	if ( 0 != ulFlags )
		{
		Assert( !( ulFlags & JET_bitObjectSystem ) || FOLDSystemTable( szTableName ) );
		if ( ulFlags & JET_bitObjectTableTemplate )
			{
			Assert( ulFlags & JET_bitObjectTableFixedDDL );
			Assert( !( ulFlags & JET_bitObjectTableDerived ) );
			pfcb->SetFixedDDL();
			pfcb->SetTemplateTable();
			}
		else
			{
			if ( ulFlags & JET_bitObjectTableFixedDDL )
				pfcb->SetFixedDDL();
			
			if ( ulFlags & JET_bitObjectTableDerived )
				{
				CHAR	szTemplateTable[JET_cbNameMost+1];
				FUCB	*pfucbTemplateTable;

				Assert( FVarFid( fidMSO_TemplateTable ) );
				Call( ErrRECIRetrieveVarColumn(
							pfcbNil,
							pfucbCatalog->u.pfcb->Ptdb(),
							fidMSO_TemplateTable,
							pfucbCatalog->kdfCurr.data,
							&dataField ) );
				CallS( err );
				Assert( dataField.Cb() > 0 );
				Assert( dataField.Cb() <= JET_cbNameMost );
				UtilMemCpy( szTemplateTable, dataField.Pv(), dataField.Cb() );
				szTemplateTable[dataField.Cb()] = '\0';

				//	release latch once we're done retrieving data from Table record
				Call( ErrBTRelease( pfucbCatalog ) );

				Call( ErrFILEOpenTable(
							ppib,
							ifmp,
							&pfucbTemplateTable,
							szTemplateTable,
							JET_bitTableReadOnly ) );
				Assert( pfucbNil != pfucbTemplateTable );
			
				pfcbTemplateTable = pfucbTemplateTable->u.pfcb;
				Assert( pfcbNil != pfcbTemplateTable );
				Assert( pfcbTemplateTable->FTemplateTable() );
				Assert( pfcbTemplateTable->FFixedDDL() );

				// Close cursor.  FCB will be pinned because FAvail_() checks
				// for TemplateTable flag.
				CallS( ErrFILECloseTable( ppib, pfucbTemplateTable ) );

				pfcb->SetDerivedTable();

#ifdef DEBUG
				//	re-obtain latch on catalog
				Call( ErrBTGet( pfucbCatalog ) );

				//	verify still on same record
				Assert( FFixedFid( fidMSO_ObjidTable ) );
				CallS( ErrRECIRetrieveFixedColumn(
							pfcbNil,
							pfucbCatalog->u.pfcb->Ptdb(),
							fidMSO_ObjidTable,
							pfucbCatalog->kdfCurr.data,
							&dataField ) );
				Assert( dataField.Cb() == sizeof(OBJID) );
				Assert( objidTable == *( (UnalignedLittleEndian< OBJID > *)dataField.Pv() ) );

				Assert( FFixedFid( fidMSO_Type ) );
				CallS( ErrRECIRetrieveFixedColumn(
							pfcbNil,
							pfucbCatalog->u.pfcb->Ptdb(),
							fidMSO_Type,
							pfucbCatalog->kdfCurr.data,
							&dataField ) );
				Assert( dataField.Cb() == sizeof(SYSOBJ) );
				Assert( sysobjTable == *( (UnalignedLittleEndian< SYSOBJ > *)dataField.Pv() ) );

				Call( ErrBTRelease( pfucbCatalog ) );
#endif
				}
			}
		}

	//	must release page latch at this point for highest columnid
	//	search in ErrCATIInitTDB()
	//	latch will be reobtained in ErrCATIBuildFIELDArray()
	//	and will not be relinquished from that point forth
	Assert( locOnCurBM == pfucbCatalog->locLogical );
	if ( ulFlags & JET_bitObjectTableDerived )
		{
		Assert( !Pcsr( pfucbCatalog )->FLatched() );
		}
	else
		{
		Assert( Pcsr( pfucbCatalog )->FLatched() );
		Call( ErrBTRelease( pfucbCatalog ) );
		}

	//	verify key no longer in prepared state, but still in buffer
	Assert( !FKSPrepared( pfucbCatalog ) );
	FUCBAssertValidSearchKey( pfucbCatalog );
	Assert( cbCATNormalizedObjid == pfucbCatalog->dataSearchKey.Cb() );

	//	force index range on this table
	( (BYTE *)pfucbCatalog->dataSearchKey.Pv() )[cbCATNormalizedObjid] = 0xff;	//	force strlimit
	pfucbCatalog->dataSearchKey.DeltaCb( 1 );
	FUCBSetIndexRange( pfucbCatalog, JET_bitRangeUpperLimit );

	Call( ErrCATIInitTDB(
				ppib,
				pfucbCatalog,
				objidTable,
				szTableName,
				pfcb->FTemplateTable(),
				pfcbTemplateTable,
				&ptdb ) );
	CallSx( err, wrnCATNoMoreRecords );
	fHitEOF = ( wrnCATNoMoreRecords == err );

	Assert( ptdbNil != ptdb );
	Assert( ( pfcb->FTemplateTable() && ptdb->FTemplateTable() )
		|| ( !pfcb->FTemplateTable() && !ptdb->FTemplateTable() ) );

	//	even if we got NoCurrentRecord, we are actually
	//	still left on the last node (usually, the DIR
	//	level corrects the currency)
	Assert( locOnCurBM == pfucbCatalog->locLogical );
	Assert( Pcsr( pfucbCatalog )->FLatched() );

	if ( fHitEOF )
		{
		//	no primary/secondary indexes, only a sequential index
		Call( ErrFILEIInitializeFCB(
					ppib,
					ifmp,
					ptdb,
					pfcb,
					pidbNil,
					fTrue,
					pfcb->PgnoFDP(),
					ulDefaultDensity ) );
		ptdb->ResetRgbitAllIndex();
		Assert( pfcbNil == pfcb->PfcbNextIndex() );
		}
	else
		{
		Call( ErrCATIInitIndexFCBs(
					ppib,
					pfucbCatalog,
					objidTable,
					pfcb,
					ptdb,
					ulDefaultDensity ) );
		CallSx( err, wrnCATNoMoreRecords );
		fHitEOF = ( wrnCATNoMoreRecords == err );
		}

	//	even if we got NoCurrentRecord, we are actually
	//	still left on the last node (usually, the DIR
	//	level corrects the currency)
	Assert( locOnCurBM == pfucbCatalog->locLogical );
	Assert( Pcsr( pfucbCatalog )->FLatched() );

	if ( !g_fCallbacksDisabled && !fHitEOF )
		{
		Call( ErrCATIInitCallbacks(
					ppib,
					pfucbCatalog,
					objidTable,
					pfcb,
					ptdb ) );
		CallSx( err, wrnCATNoMoreRecords );
		}

	//	even if we got NoCurrentRecord, we are actually
	//	still left on the last node (usually, the DIR
	//	level corrects the currency)
	Assert( locOnCurBM == pfucbCatalog->locLogical );
	Assert( Pcsr( pfucbCatalog )->FLatched() );
	BTUp( pfucbCatalog );

	// Try to compact byte pool, but if it fails, don't worry.  It just means
	// that the byte pool will have some unused space.
	ptdb->MemPool().FCompact();

	pfcb->SetTypeTable();
	
	err = JET_errSuccess;

HandleError:
	if ( err < 0 )
		{
		Assert( pfcb->Ptdb() == ptdbNil || pfcb->Ptdb() == ptdb );
		
		if ( ptdbNil != ptdb )
			ptdb->Delete( pinst );
		pfcb->SetPtdb( ptdbNil );

		if ( pfcbNil != pfcb->PfcbNextIndex() )
			{
			CATIFreeSecondaryIndexes( pfcb->PfcbNextIndex() );
			pfcb->SetPfcbNextIndex( pfcbNil );
			}

		if ( pidbNil != pfcb->Pidb() )
			{
			pfcb->ReleasePidb();
			pfcb->SetPidb( pidbNil );
			}
		}

	CallS( ErrCATClose( ppib, pfucbCatalog ) );
		
	return err;
	}



ERR ErrCATInitTempFCB( FUCB *pfucbTable )
	{
	ERR		err;
	PIB		*ppib = pfucbTable->ppib;
	FCB		*pfcb = pfucbTable->u.pfcb;
	TDB		*ptdb = ptdbNil;
	TCIB	tcib = { fidFixedLeast-1, fidVarLeast-1, fidTaggedLeast-1 };
	INST	*pinst = PinstFromPpib( ppib );

	Assert( !pfcb->FInitialized() );
	
	/*	the only way a temporary table could get to this point is if it was being
	/*	created, in which case there are no primary or secondary indexes yet.
	/**/
	
	CallR( ErrTDBCreate( pinst, &ptdb, &tcib ) );

	Assert( ptdb->FidVersion() == 0 );
	Assert( ptdb->FidAutoincrement() == 0 );
	Assert( tcib.fidFixedLast == ptdb->FidFixedLast() );
	Assert( tcib.fidVarLast == ptdb->FidVarLast() );
	Assert( tcib.fidTaggedLast == ptdb->FidTaggedLast() );
	
	/*	for temporary tables, could only get here from
	/*	create table which means table should currently be empty
	/**/
	Assert( ptdb->FidFixedLast() == fidFixedLeast - 1 );
	Assert( ptdb->FidVarLast() == fidVarLeast - 1 );
	Assert( ptdb->FidTaggedLast() == fidTaggedLeast - 1 );
	Assert( ptdb->DbkMost() == 0 );
	Assert( ptdb->UlLongIdLast() == 0 );

	// NOTE: Table name will be added when sort is materialized.
	
	Call( ErrFILEIInitializeFCB(
		ppib,
		pinst->m_mpdbidifmp[ dbidTemp ],
		ptdb,
		pfcb,
		pidbNil,
		fTrue,
		pfcb->PgnoFDP(),
		ulFILEDefaultDensity ) );

	Assert( pfcb->PfcbNextIndex() == pfcbNil );

	pfcb->SetPtdb( ptdb );

	FILESetAllIndexMask( pfcb );
	pfcb->SetFixedDDL();
	pfcb->SetTypeTemporaryTable();
	
	return JET_errSuccess;

HandleError:
	Assert( ptdb != ptdbNil );
	Assert( pfcb->Ptdb() == ptdbNil );		// Verify TDB never got linked in.
	ptdb->Delete( pinst );
		
	return err;
	}
	

//	UNDONE:	is there another function in JET which does this?
ULONG UlCATColumnSize( JET_COLTYP coltyp, INT cbMax, BOOL *pfMaxTruncated )
	{
	ULONG	ulLength;
	BOOL	fTruncated = fFalse;

	switch( coltyp )
		{
		case JET_coltypBit:
		case JET_coltypUnsignedByte:
			ulLength = 1;
			Assert( ulLength == sizeof(BYTE) );
			break;

		case JET_coltypShort:
			ulLength = 2;
			Assert( ulLength == sizeof(SHORT) );
			break;

		case JET_coltypLong:
		case JET_coltypIEEESingle:
			ulLength = 4;
			Assert( ulLength == sizeof(LONG) );
			break;

		case JET_coltypCurrency:
		case JET_coltypIEEEDouble:
		case JET_coltypDateTime:
			ulLength = 8;		// sizeof(DREAL)
			break;

		case JET_coltypBinary:
		case JET_coltypText:
			if ( cbMax == 0 )
				{
				ulLength = JET_cbColumnMost;
				}
			else
				{
				ulLength = cbMax;
				if ( ulLength > JET_cbColumnMost )
					{
					ulLength = JET_cbColumnMost;
					fTruncated = fTrue;
					}
				}
			break;

		default:
			// Just pass back what was given.
			Assert( FRECLongValue( coltyp ) || FRECSLV( coltyp ));
			Assert( JET_coltypNil != coltyp );
			ulLength = cbMax;
			break;
		}

	if ( pfMaxTruncated != NULL )
		{
		*pfMaxTruncated = fTruncated;
		}

	return ulLength;
	}


/*	This routines sets/gets table and index stats.
/*	Pass NULL for szSecondaryIndexName if looking for sequential or primary index.
/**/
ERR ErrCATStats(
	PIB			*ppib, 
	const IFMP	ifmp, 
	const OBJID	objidTable,
	const CHAR	*szSecondaryIndexName, 
	SR			*psr,
	const BOOL	fWrite )

	{
	ERR			err;
	FUCB		*pfucbCatalog		= pfucbNil;

	CallR( ErrCATOpen( ppib, ifmp, &pfucbCatalog ) );
	Assert( pfucbNil != pfucbCatalog );

	/*	stats for sequential and primary indexes are in MSysObjects, while
	/*	stats for secondary indexes are in MSysIndexes.
	/**/
	if ( szSecondaryIndexName )
		{
		Call( ErrCATISeekTableObject(
					ppib,
					pfucbCatalog,
					objidTable,
					sysobjIndex,
					szSecondaryIndexName ) );
		}
	else
		{
		Call( ErrCATISeekTable(
					ppib,
					pfucbCatalog,
					objidTable ) );
		}

	Assert( Pcsr( pfucbCatalog )->FLatched() );
	
	/*	set/retrieve value
	/**/
	if ( fWrite )
		{
		LE_SR le_sr;
		
		le_sr = *psr;
		
		Call( ErrDIRRelease( pfucbCatalog ) );
		
		Call( ErrIsamPrepareUpdate( ppib, pfucbCatalog, JET_prepReplaceNoLock ) );
		Call( ErrIsamSetColumn(
					ppib,
					pfucbCatalog,
					fidMSO_Stats,
					(BYTE *)&le_sr,
					sizeof(LE_SR),
					NO_GRBIT,
					NULL ) );
		Call( ErrIsamUpdate( ppib, pfucbCatalog, NULL, 0, NULL, NO_GRBIT ) );
		}
	else
		{
		DATA	dataField;

		Assert( FVarFid( fidMSO_Stats ) );
		Call( ErrRECIRetrieveVarColumn(
					pfcbNil,
					pfucbCatalog->u.pfcb->Ptdb(),
					fidMSO_Stats,
					pfucbCatalog->kdfCurr.data,
					&dataField ) );
		if ( dataField.Cb() == 0 )
			{
			Assert( JET_wrnColumnNull == err );
			memset( (BYTE *)psr, '\0', sizeof(SR) );
			err = JET_errSuccess;
			}
		else
			{
			Assert( dataField.Cb() == sizeof(LE_SR) );
			CallS( err );
			LE_SR le_sr;
			le_sr = *(LE_SR*)dataField.Pv();
			*psr = le_sr;
//			UtilMemCpy( psr, dataField.Pv(), sizeof(SR) );
			}
		}

HandleError:
	CallS( ErrCATClose( ppib, pfucbCatalog ) );
	return err;
	}


//  ================================================================
ERR ErrCATChangePgnoFDP( PIB * ppib, IFMP ifmp, OBJID objidTable, OBJID objid, SYSOBJ sysobj, PGNO pgnoFDPNew )
//  ================================================================
	{
	ERR			err 			= JET_errSuccess;
	FUCB *		pfucbCatalog	= pfucbNil;
	BOOKMARK	bm;
	BYTE		rgbBookmark[JET_cbBookmarkMost];
	ULONG		cbBookmark;

	Call( ErrCATOpen( ppib, ifmp, &pfucbCatalog, fFalse ) );
	Call( ErrCATISeekTableObject( ppib, pfucbCatalog, objidTable, sysobj, objid ) );
	Assert( Pcsr( pfucbCatalog )->FLatched() );
	
	Call( ErrDIRRelease( pfucbCatalog ) );

	Assert( pfucbCatalog->bmCurr.key.prefix.FNull() );
	Assert( pfucbCatalog->bmCurr.data.FNull() );
	cbBookmark = min( pfucbCatalog->bmCurr.key.Cb(), sizeof(rgbBookmark) );
	Assert( cbBookmark <= JET_cbBookmarkMost );
	pfucbCatalog->bmCurr.key.CopyIntoBuffer( rgbBookmark, cbBookmark );

	bm.key.prefix.Nullify();
	bm.key.suffix.SetPv( rgbBookmark );
	bm.key.suffix.SetCb( cbBookmark );
	bm.data.Nullify();

	Call( ErrIsamPrepareUpdate( ppib, pfucbCatalog, JET_prepReplaceNoLock ) );
	Call( ErrIsamSetColumn(
				ppib,
				pfucbCatalog,
				fidMSO_PgnoFDP,
				(BYTE *)&pgnoFDPNew,
				sizeof(PGNO),
				NO_GRBIT,
				NULL ) );
	Call( ErrIsamUpdate( ppib, pfucbCatalog, NULL, 0, NULL, NO_GRBIT ) );
	
	CallS( ErrCATClose( ppib, pfucbCatalog ) );
	pfucbCatalog = pfucbNil;

	Call( ErrCATOpen( ppib, ifmp, &pfucbCatalog, fTrue ) );		//	shadow catalog

	Call( ErrDIRGotoBookmark( pfucbCatalog, bm ) );

	Call( ErrIsamPrepareUpdate( ppib, pfucbCatalog, JET_prepReplaceNoLock ) );
	Call( ErrIsamSetColumn(
				ppib,
				pfucbCatalog,
				fidMSO_PgnoFDP,
				(BYTE *)&pgnoFDPNew,
				sizeof(PGNO),
				NO_GRBIT,
				NULL ) );
	Call( ErrIsamUpdate( ppib, pfucbCatalog, NULL, 0, NULL, NO_GRBIT ) );

HandleError:
	if( pfucbCatalog )
		{
		CallS( ErrCATClose( ppib, pfucbCatalog ) );
		}
	return err;
	}

	
//  ================================================================
LOCAL ERR ErrCATIChangeColumnDefaultValue(
	PIB			* const ppib,
	FUCB		* const pfucbCatalog,
	const DATA&	dataDefault )
//  ================================================================
	{
	ERR			err;
	DATA		dataField;
	FIELDFLAG	ffield 		= 0;
	ULONG		ulFlags;

	CallR( ErrIsamPrepareUpdate( ppib, pfucbCatalog, JET_prepReplaceNoLock ) );

	// get the exsiting flags 
	Assert( FFixedFid( fidMSO_Flags ) );
	Call( ErrRECIRetrieveFixedColumn(
				pfcbNil,
				pfucbCatalog->u.pfcb->Ptdb(),
				fidMSO_Flags,
				pfucbCatalog->dataWorkBuf,
				&dataField ) );
	CallS( err );
	Assert( dataField.Cb() == sizeof(ULONG) );
	ffield = *(UnalignedLittleEndian< FIELDFLAG > *)dataField.Pv();

	//	force DefaultValue flag in case it's not already set
	FIELDSetDefault( ffield );

	ulFlags = ffield;
	Call( ErrIsamSetColumn(
				ppib,
				pfucbCatalog,
				fidMSO_Flags,
				&ulFlags,
				sizeof(ulFlags),
				NO_GRBIT,
				NULL ) );

	Call( ErrIsamSetColumn(
				ppib,
				pfucbCatalog,
				fidMSO_DefaultValue,
				dataDefault.Pv(),
				dataDefault.Cb(),
				NO_GRBIT,
				NULL ) );
	Call( ErrIsamUpdate( ppib, pfucbCatalog, NULL, 0, NULL, NO_GRBIT ) );
	
HandleError:
	if( err < 0 )
		{
		CallS( ErrIsamPrepareUpdate( ppib, pfucbCatalog, JET_prepCancel ) );
		}
	return err;
	}


//  ================================================================
ERR ErrCATChangeColumnDefaultValue(
	PIB			*ppib,
	const IFMP	ifmp,
	const OBJID	objidTable,
	const CHAR	*szColumn,
	const DATA&	dataDefault )
//  ================================================================
	{
	ERR			err;
	FUCB *		pfucbCatalog		= pfucbNil;
	BOOKMARK	bm;
	BYTE		rgbBookmark[JET_cbKeyMost];
	ULONG		cbBookmark;

	CallR( ErrDIRBeginTransaction( ppib, NO_GRBIT ) );

	Call( ErrCATOpen( ppib, ifmp, &pfucbCatalog, fFalse ) );	//  catalog
	Call( ErrCATISeekTableObject( ppib, pfucbCatalog, objidTable, sysobjColumn, szColumn ) );

	Call( ErrDIRRelease( pfucbCatalog ) );

	Assert( pfucbCatalog->bmCurr.key.prefix.FNull() );
	Assert( pfucbCatalog->bmCurr.data.FNull() );
	cbBookmark = min( pfucbCatalog->bmCurr.key.Cb(), sizeof(rgbBookmark) );
	Assert( cbBookmark <= JET_cbBookmarkMost );
	pfucbCatalog->bmCurr.key.CopyIntoBuffer( rgbBookmark, cbBookmark );

	bm.key.prefix.Nullify();
	bm.key.suffix.SetPv( rgbBookmark );
	bm.key.suffix.SetCb( cbBookmark );
	bm.data.Nullify();

	Call( ErrCATIChangeColumnDefaultValue( ppib, pfucbCatalog, dataDefault ) );
	Call( ErrCATClose( ppib, pfucbCatalog ) );
	pfucbCatalog = pfucbNil;

	Call( ErrCATOpen( ppib, ifmp, &pfucbCatalog, fTrue ) );		//	shadow catalog	
	Call( ErrDIRGotoBookmark( pfucbCatalog, bm ) );
	Call( ErrCATIChangeColumnDefaultValue( ppib, pfucbCatalog, dataDefault ) );
	Call( ErrCATClose( ppib, pfucbCatalog ) );
	pfucbCatalog = pfucbNil;

	Call( ErrDIRCommitTransaction( ppib, NO_GRBIT ) );

HandleError:
	if( pfucbNil != pfucbCatalog )
		{
		CallS( ErrCATClose( ppib, pfucbCatalog ) );
		}
	if( err < 0 )
		{
		CallSx( ErrDIRRollback( ppib ), JET_errRollbackError );
		}
	return err;
	}


LOCAL ERR ErrCATIDeleteLocalizedIndexesInTable(
	PIB			*ppib,
	const IFMP	ifmp,
	const CHAR	*szTableName,
	BOOL		*pfIndexesDeleted,
	const BOOL	fReadOnly )
	{
	ERR			err;
	FUCB		*pfucbTable		= pfucbNil;
	FCB			*pfcbTable;
	FCB			*pfcbIndex;
	CHAR		szIndexName[JET_cbNameMost+1];
	const CHAR	*rgsz[3];
	BOOL		fInTrx			= fFalse;

	Assert( 0 == ppib->level );

	CallR( ErrFILEOpenTable(
				ppib,
				ifmp,
				&pfucbTable,
				szTableName,
				( fReadOnly ? 0 : JET_bitTableDenyRead|JET_bitTablePermitDDL ) ) );
	Assert( pfucbNil != pfucbTable );

	//	wrap in a transaction to ensure one index doesn't disappear
	//	(due to RCE cleanup) while we're working on another
	Call( ErrDIRBeginTransaction( ppib, NO_GRBIT ) );
	fInTrx = fTrue;

	pfcbTable = pfucbTable->u.pfcb;
	Assert( pfcbNil != pfcbTable );
	Assert( pfcbTable->FTypeTable() );
	Assert( ptdbNil != pfcbTable->Ptdb() );

	rgsz[0] = rgfmp[ifmp].SzDatabaseName();
	rgsz[1] = szIndexName;
	rgsz[2] = szTableName;
					
//	No need to enter critical section because this is only called at AttachDatabase() time,
//	meaning no one else has access to this database yet.
//	ENTERCRITICALSECTION	enterCritFCB( &pfcbTable->Crit() );

	for ( pfcbIndex = pfcbTable;
		pfcbIndex != pfcbNil;
		pfcbIndex = pfcbIndex->PfcbNextIndex() )
		{
		const IDB	*pidb	= pfcbIndex->Pidb();
		
		//	only clustered index may be sequential
		Assert( pidbNil != pidb || pfcbIndex == pfcbTable );
		
		//	we need to rebuild the index if it is not US English (which
		//	we assume will never change), or if it is US English, but
		//	the LCMapString flags used to build the index no longer
		//	matches the current default
		if ( pidbNil != pidb
			&& pidb->FLocalizedText()
			&& ( lcidDefault != pidb->Lcid() || dwLCMapFlagsDefault != pidb->DwLCMapFlags() ) )
			{
			Assert( lcidNone != pidb->Lcid() );		//	CATIInitIDB() filters out lcidNone

#ifdef DEBUG
			BOOL				fFoundUnicodeTextColumn	= fFalse;
			const IDXSEG*		rgidxseg				= PidxsegIDBGetIdxSeg( pidb, pfcbTable->Ptdb() );
			Assert( pidb->Cidxseg() <= JET_ccolKeyMost );
			
			for ( ULONG iidxseg = 0; iidxseg < pidb->Cidxseg(); iidxseg++ )
				{
				const COLUMNID	columnid	= rgidxseg[iidxseg].Columnid();
				const FIELD		*pfield		= pfcbTable->Ptdb()->Pfield( columnid );
				if ( FRECTextColumn( pfield->coltyp ) && usUniCodePage == pfield->cp )
					{
					fFoundUnicodeTextColumn = fTrue;
					break;
					}
				}
			Assert( fFoundUnicodeTextColumn );
#endif			
			
			Assert( strlen( pfcbTable->Ptdb()->SzIndexName( pidb->ItagIndexName(), pfcbIndex->FDerivedIndex() ) ) <= JET_cbNameMost );
			strcpy( szIndexName, pfcbTable->Ptdb()->SzIndexName( pidb->ItagIndexName(), pfcbIndex->FDerivedIndex() ) );

			//	index could be corrupt if it contains a unicode text column
			
			if ( pfcbIndex == pfcbTable )
				{
				UtilReportEvent(
						eventError,
						DATA_DEFINITION_CATEGORY,
						PRIMARY_INDEX_CORRUPT_ERROR_ID, 3, rgsz );
				err = ErrERRCheck( JET_errPrimaryIndexCorrupted );
				}
			else if ( fReadOnly
					|| pfcbTable->FTemplateTable()		//	cannot rebuild template/derived indexes
					|| pfcbIndex->FDerivedIndex() )
				{
				UtilReportEvent(
						eventError,
						DATA_DEFINITION_CATEGORY,
						SECONDARY_INDEX_CORRUPT_ERROR_ID, 3, rgsz );
				err = ErrERRCheck( JET_errSecondaryIndexCorrupted );
				}
			else
				{
				UtilReportEvent(
						eventInformation,
						DATA_DEFINITION_CATEGORY,
						DO_SECONDARY_INDEX_CLEANUP_ID, 3, rgsz );
				*pfIndexesDeleted = fTrue;

				//	Ensure that we can always delete the index
				//	This means that for the life of this FCB, DDL will be
				//	possible and there will be a perf hit because we
				//	will now enter critFCB for many operations.
				//	Note that we cannot simply re-enable the flag after
				//	the deletion because version cleanup does some stuff
				//	with the FCB.
				pfcbTable->ResetFixedDDL();

				err = ErrIsamDeleteIndex( ppib, pfucbTable, szIndexName );
				}

			Call( err );
			}
		}

	Call( ErrDIRCommitTransaction( ppib, 0 ) );
	fInTrx = fFalse;

HandleError:
	if ( fInTrx )
		{
		Assert( err < 0 );
		CallSx( ErrDIRRollback( ppib ), JET_errRollbackError );
		}
	
	Assert( pfucbNil != pfucbTable );
	CallS( ErrFILECloseTable( ppib, pfucbTable ) );
	return err;
	}

ERR ErrCATDeleteLocalizedIndexes( PIB *ppib, const IFMP ifmp, BOOL *pfIndexesDeleted, const BOOL fReadOnly )
	{
	ERR		err;
	FUCB	*pfucbCatalog				= pfucbNil;		//	cursor to sequentially scan catalog
	OBJID	objidTable					= objidNil;
	OBJID	objidTableLastWithLocalized	= objidNil;
	SYSOBJ	sysobj;
	DATA	dataField;
	CHAR	szTableName[JET_cbNameMost+1];
	BOOL	fLatched					= fFalse;

	*pfIndexesDeleted = fFalse;

	Assert( dbidTemp != rgfmp[ifmp].Dbid() );
	CallR( ErrCATOpen( ppib, ifmp, &pfucbCatalog ) );
	Assert( pfucbNil != pfucbCatalog );

	//	we will be sequentially scanning the catalog for index records
	FUCBSetSequential( pfucbCatalog );

	err = ErrIsamMove( ppib, pfucbCatalog, JET_MoveFirst, NO_GRBIT );
	Assert( JET_errRecordNotFound != err );
	if ( JET_errNoCurrentRecord == err )
		{
		// catalog should not be empty
		err = ErrERRCheck( JET_errCatalogCorrupted );
		}

	do
		{
		Call( err );

		Assert( !fLatched );
		Assert( !Pcsr( pfucbCatalog )->FLatched() );
		Call( ErrDIRGet( pfucbCatalog ) );
		fLatched = fTrue;

		Assert( FFixedFid( fidMSO_ObjidTable ) );
		Call( ErrRECIRetrieveFixedColumn(
					pfcbNil,
					pfucbCatalog->u.pfcb->Ptdb(),
					fidMSO_ObjidTable,
					pfucbCatalog->kdfCurr.data,
					&dataField ) );
		CallS( err );
		Assert( dataField.Cb() == sizeof(OBJID) );
		objidTable = *(UnalignedLittleEndian< OBJID > *) dataField.Pv();
//		UtilMemCpy( &objidTable, dataField.Pv(), sizeof(OBJID) );

		Assert( objidTable >= objidTableLastWithLocalized );
		if ( objidTable > objidTableLastWithLocalized )
			{
			Assert( FFixedFid( fidMSO_Type ) );
			Call( ErrRECIRetrieveFixedColumn(
						pfcbNil,
						pfucbCatalog->u.pfcb->Ptdb(),
						fidMSO_Type,
						pfucbCatalog->kdfCurr.data,
						&dataField ) );
			CallS( err );
			Assert( dataField.Cb() == sizeof(SYSOBJ) );
			sysobj = *(UnalignedLittleEndian< SYSOBJ > *) dataField.Pv();
//			UtilMemCpy( &sysobj, dataField.Pv(), sizeof(SYSOBJ) );

			if ( sysobjTable == sysobj )
				{
				Assert( FVarFid( fidMSO_Name ) );
				Call( ErrRECIRetrieveVarColumn(
							pfcbNil,
							pfucbCatalog->u.pfcb->Ptdb(),
							fidMSO_Name,
							pfucbCatalog->kdfCurr.data,
							&dataField ) );
				CallS( err );
				Assert( dataField.Cb() > 0 );
				Assert( dataField.Cb() <= JET_cbNameMost );
				UtilMemCpy( szTableName, dataField.Pv(), dataField.Cb() );
				szTableName[dataField.Cb()] = 0;
				}
			else if ( sysobjIndex == sysobj )
				{
				IDBFLAG		fidb;
				
				Assert( FFixedFid( fidMSO_Flags ) );
				Call( ErrRECIRetrieveFixedColumn(
							pfcbNil,
							pfucbCatalog->u.pfcb->Ptdb(),
							fidMSO_Flags,
							pfucbCatalog->kdfCurr.data,
							&dataField ) );
				CallS( err );
				Assert( dataField.Cb() == sizeof(ULONG) );
				fidb = *(UnalignedLittleEndian< IDBFLAG > *) dataField.Pv();
//				UtilMemCpy( &fidb, dataField.Pv(), sizeof(IDBFLAG) );

				//	don't bother checking derived indexes -- they will be checked
				//	when the template table is checked.
				if ( !FIDBDerivedIndex( fidb ) && FIDBLocalizedText( fidb ) )
					{
					LCID	lcid;
					DWORD	dwMapFlags;

					Assert( FFixedFid( fidMSO_Localization ) );
					Call( ErrRECIRetrieveFixedColumn(
								pfcbNil,
								pfucbCatalog->u.pfcb->Ptdb(),
								fidMSO_Localization,
								pfucbCatalog->kdfCurr.data,
								&dataField ) );
					CallS( err );
					Assert( dataField.Cb() == sizeof(LCID) );
					lcid = *(UnalignedLittleEndian<LCID> *)dataField.Pv();
//					UtilMemCpy( &lcid, dataField.Pv(), sizeof(LCID) );

					//	old format: fLocaleId is FALSE and lcid == 0
					//	(we force lcid to default value in CATIInitIDB())
					Assert( lcidNone != lcid
						|| !FIDBLocaleId( fidb ) );

					Assert( FFixedFid( fidMSO_LCMapFlags ) );
					Call( ErrRECIRetrieveFixedColumn(
								pfcbNil,
								pfucbCatalog->u.pfcb->Ptdb(),
								fidMSO_LCMapFlags,
								pfucbCatalog->kdfCurr.data,
								&dataField ) );
					if ( dataField.Cb() == 0 )
						{
						Assert( JET_wrnColumnNull == err );

						//	old format: fLocaleId is FALSE and lcid == 0
						Assert( !FIDBLocaleId( fidb ) );
						Assert( lcidNone == lcid );
						dwMapFlags = dwLCMapFlagsDefaultOBSOLETE;
						}
					else
						{
						CallS( err );
						Assert( dataField.Cb() == sizeof(DWORD) );
						dwMapFlags = *(UnalignedLittleEndian< DWORD > *) dataField.Pv();
				//		UtilMemCpy( &dwMapFlags, dataField.Pv(), sizeof(DWORD) );
						Assert( JET_errSuccess == ErrNORMCheckLCMapFlags( dwMapFlags ) );
						}

					//	we need to rebuild the index if it is not US English (which
					//	we assume will never change), or if it is US English, but
					//	the LCMapString flags used to build the index no longer
					//	matches the current default
					if ( ( lcidDefault != lcid && lcidNone != lcid )
						|| dwMapFlags != idxunicodeDefault.dwMapFlags )
						{
						Assert( Pcsr( pfucbCatalog )->FLatched() );
						Call( ErrDIRRelease( pfucbCatalog ) );
						fLatched = fFalse;

						//	if we found one localized index in the table, its
						//	easiest to open the table and delete them all

						Assert( !FCATSystemTable( szTableName ) );
						Call( ErrCATIDeleteLocalizedIndexesInTable(
									ppib,
									ifmp,
									szTableName,
									pfIndexesDeleted,
									fReadOnly ) );
						objidTableLastWithLocalized = objidTable;
						}
					}
				}
			else
				{
				Assert( sysobjColumn == sysobj
					|| sysobjLongValue == sysobj
					|| sysobjCallback == sysobj
					|| sysobjSLVAvail == sysobj
					|| sysobjSLVOwnerMap == sysobj );
				}
			}

		if ( fLatched )
			{
			Assert( Pcsr( pfucbCatalog )->FLatched() );
			Call( ErrDIRRelease( pfucbCatalog ) );
			fLatched = fFalse;
			}

		Assert( !Pcsr( pfucbCatalog )->FLatched() );	
		err = ErrIsamMove( ppib, pfucbCatalog, JET_MoveNext, NO_GRBIT );
		}
	while ( JET_errNoCurrentRecord != err );

	err = JET_errSuccess;

HandleError:
	Assert( pfucbNil != pfucbCatalog );
	CallS( ErrCATClose( ppib, pfucbCatalog ) );

	return err;
	}


//  ================================================================
LOCAL ERR ErrCATIRenameTable(
	PIB			* const ppib,
	const IFMP			ifmp,
	const OBJID			objidTable,
	const CHAR * const 	szNameNew,
	const BOOL fShadow )
//  ================================================================
	{
	ERR err = JET_errSuccess;
	FUCB * pfucbCatalog = pfucbNil;
	BOOL fUpdatePrepared = fFalse;
	
	Call( ErrCATOpen( ppib, ifmp, &pfucbCatalog, fShadow ) );

	Call( ErrCATISeekTable( ppib, pfucbCatalog, objidTable ) );
	Call( ErrDIRRelease( pfucbCatalog ) );
	
	Call( ErrIsamPrepareUpdate( ppib, pfucbCatalog, JET_prepReplace ) );
	fUpdatePrepared = fTrue;

	ULONG ulFlags;
	ULONG cbActual;
	Call( ErrIsamRetrieveColumn(
			ppib,
			pfucbCatalog,
			fidMSO_Flags,
			&ulFlags,
			sizeof( ulFlags ),
			&cbActual,
			JET_bitRetrieveCopy,
			NULL ) );

	if( ulFlags & JET_bitObjectTableTemplate 
		|| ulFlags & JET_bitObjectTableFixedDDL )
		{
		//  we can't rename a template table becuase the derived tables won't be updated
		Call( ErrERRCheck( JET_errFixedDDL ) );
		}
			
	Call( ErrIsamSetColumn(
			ppib,
			pfucbCatalog,
			fidMSO_Name,
			szNameNew,
			(ULONG)strlen( szNameNew ),
			NO_GRBIT,
			NULL ) );
	Call( ErrIsamUpdate( ppib, pfucbCatalog, NULL, 0, NULL, NO_GRBIT ) );
	fUpdatePrepared = fFalse;
	
HandleError:
	if( fUpdatePrepared )
		{
		CallS( ErrIsamPrepareUpdate( ppib, pfucbCatalog, JET_prepCancel ) );
		}
	if( pfucbNil != pfucbCatalog )
		{
		CallS( ErrCATClose( ppib, pfucbCatalog ) );
		}
	return err;	
	}


//  ================================================================
ERR ErrCATRenameTable(
	PIB				* const ppib,
	const IFMP		ifmp,
	const CHAR		* const szNameOld,
	const CHAR		* const szNameNew )
//  ================================================================
	{
	ERR 			err;
	INT				fState				= fFCBStateNull;
	FCB				* pfcbTable			= pfcbNil;
	OBJID		 	objidTable;
	PGNO			pgnoFDPTable;
	MEMPOOL::ITAG	itagTableNameNew	= 0;

	CallR( ErrDIRBeginTransaction( ppib, NO_GRBIT ) );

	Call( ErrCATSeekTable( ppib, ifmp, szNameOld, &pgnoFDPTable, &objidTable ) );

	//  check to see if the FCB is present and initialized
	//  if its not present we can just update the catalog
	
	pfcbTable = FCB::PfcbFCBGet( ifmp, pgnoFDPTable, &fState );
	if( pfcbNil != pfcbTable )
		{
		if( fFCBStateInitialized != fState )
			{
			
			//  this should only happen if this is called in a multi-threaded scenario
			//  (which it shouldn't be)
			
			Assert( fFalse );
			Call( ErrERRCheck( JET_errTableInUse ) );
			}

		//  place the new table name in memory, to avoid possibly running out of memory later
		
		TDB * const ptdb = pfcbTable->Ptdb();
		MEMPOOL& mempool = ptdb->MemPool();

		pfcbTable->EnterDDL();
		
		err = mempool.ErrAddEntry( (BYTE *)szNameNew, (ULONG)strlen( szNameNew ) + 1, &itagTableNameNew );
		Assert( 0 != itagTableNameNew || err < JET_errSuccess );	//	0 is used as "uninit"
		
		pfcbTable->LeaveDDL();

		Call( err );
		}

	Call( ErrCATIRenameTable( ppib, ifmp, objidTable, szNameNew, fFalse ) );
	Call( ErrCATIRenameTable( ppib, ifmp, objidTable, szNameNew, fTrue ) );

	//  once the commit succeeds, no errors can be generated
	
	Call( ErrDIRCommitTransaction( ppib, NO_GRBIT ) );

	if( pfcbNil != pfcbTable )
		{
		//	delete the old name from the catalog hash
			
		CATHashDelete( pfcbTable, const_cast< CHAR * >( szNameOld ) );

		pfcbTable->EnterDDL();

		TDB * const ptdb = pfcbTable->Ptdb();
		MEMPOOL& mempool = ptdb->MemPool();
		const MEMPOOL::ITAG itagTableNameOld = ptdb->ItagTableName();
		
		ptdb->SetItagTableName( itagTableNameNew );
		itagTableNameNew = 0;
		mempool.DeleteEntry( itagTableNameOld );

		pfcbTable->LeaveDDL();

		//	insert the new name into to the catalog hash

//	UNDONE: Can't reinsert into hash now because we may be renaming to a table that
//	has just been deleted, but that table's name does not get removed from the
//	hash table until the DeleteTable commits
///		CATHashInsert( pfcbTable );
		}
		
HandleError:

	if ( 0 != itagTableNameNew )
		{
		if ( pfcbNil != pfcbTable )
			{
			TDB * const ptdb = pfcbTable->Ptdb();
			MEMPOOL& mempool = ptdb->MemPool();

			pfcbTable->EnterDDL();
			mempool.DeleteEntry( itagTableNameNew );
			pfcbTable->LeaveDDL();
			}
		}
	
	if( err < 0 )
		{
		CallSx( ErrDIRRollback( ppib ), JET_errRollbackError );
		}
	if( pfcbNil != pfcbTable )
		{
		pfcbTable->Release();
		}
	return err;
	}


//  ================================================================
LOCAL ERR ErrCATIRenameTableObject(
	PIB				* const ppib,
	const IFMP		ifmp,
	const OBJID		objidTable,
	const SYSOBJ	sysobj,
	const OBJID		objid,
	const CHAR		* const szNameNew,
	ULONG			* pulFlags,
	const BOOL		fShadow )
//  ================================================================
	{
	ERR				err				= JET_errSuccess;
	FUCB			* pfucbCatalog	= pfucbNil;
	BOOL			fUpdatePrepared	= fFalse;
	
	Call( ErrCATOpen( ppib, ifmp, &pfucbCatalog, fShadow ) );

	Call( ErrCATISeekTableObject( ppib, pfucbCatalog, objidTable, sysobj, objid ) );
	Call( ErrDIRRelease( pfucbCatalog ) );
	
	Call( ErrIsamPrepareUpdate( ppib, pfucbCatalog, JET_prepReplace ) );
	fUpdatePrepared = fTrue;
			
	Call( ErrIsamSetColumn(
			ppib,
			pfucbCatalog,
			fidMSO_Name,
			szNameNew,
			(ULONG)strlen( szNameNew ),
			NO_GRBIT,
			NULL ) );

	if ( NULL != pulFlags )
		{
		Call( ErrIsamSetColumn(
				ppib,
				pfucbCatalog,
				fidMSO_Flags,
				pulFlags,
				sizeof(ULONG),
				NO_GRBIT,
				NULL ) );
		}

	Call( ErrIsamUpdate( ppib, pfucbCatalog, NULL, 0, NULL, NO_GRBIT ) );
	fUpdatePrepared = fFalse;
	
HandleError:
	if( fUpdatePrepared )
		{
		CallS( ErrIsamPrepareUpdate( ppib, pfucbCatalog, JET_prepCancel ) );
		}
	if( pfucbNil != pfucbCatalog )
		{
		CallS( ErrCATClose( ppib, pfucbCatalog ) );
		}
	return err;	
	}


//  ================================================================
ERR ErrCATRenameColumn(
	PIB				* const ppib,
	const FUCB		* const pfucbTable,
	const CHAR		* const szNameOld,
	const CHAR		* const szNameNew,
	const JET_GRBIT	grbit )
//  ================================================================
	{
	ERR				err					= JET_errSuccess;
	const INT		cbSzNameNew			= (ULONG)strlen( szNameNew ) + 1;
	Assert( cbSzNameNew > 1 );
	
	MEMPOOL::ITAG	itagColumnNameNew	= 0;
	MEMPOOL::ITAG	itagColumnNameOld	= 0;

	FCB				* const pfcbTable 	= pfucbTable->u.pfcb;
	TDB				* const ptdbTable 	= pfcbTable->Ptdb();
	FIELD 			* pfield 			= NULL;	
	OBJID 			objidTable;
	COLUMNID		columnid;
	ULONG			ulFlags;
	BOOL			fPrimaryIndexPlaceholder	= fFalse;

	Assert( 0 == ppib->level );
	CallR( ErrDIRBeginTransaction( ppib, NO_GRBIT ) );

	objidTable 	= pfcbTable->ObjidFDP();

	pfcbTable->EnterDML();
	
	//  Get a pointer to the FIELD of the column
	//	WARNING: The following function does a LeaveDML() on error

	Call( ErrFILEPfieldFromColumnName(
			ppib,
			pfcbTable,
			szNameOld,
			&pfield,
			&columnid ) );

	pfcbTable->LeaveDML();

	if ( pfieldNil == pfield )
		{
		Call( ErrERRCheck( JET_errColumnNotFound ) );
		}
	
	pfcbTable->EnterDDL();

	//  put the new column name in the mempool
	//  do this before getting the FIELD in case we re-arrange the mempool
	
	err = ptdbTable->MemPool().ErrAddEntry( (BYTE *)szNameNew, cbSzNameNew, &itagColumnNameNew );
	if( err < 0 )
		{
		pfcbTable->LeaveDDL();
		Call( err );
		}
	Assert( 0 != itagColumnNameNew );	//	0 is used as "uninit"

	//	must refresh pfield pointer in case mempool got rearranged adding the new name
	pfield = ptdbTable->Pfield( columnid );
	Assert( pfieldNil != pfield );
	Assert( 0 == UtilCmpName( szNameOld, ptdbTable->SzFieldName( pfield->itagFieldName, fFalse ) ) );

	if ( grbit & JET_bitColumnRenameConvertToPrimaryIndexPlaceholder )
		{
		IDB		* const pidb	= pfcbTable->Pidb();

		//	placeholder column must be fixed bitfield and first column of primary index
		if ( JET_coltypBit != pfield->coltyp
			|| !FCOLUMNIDFixed( columnid )
			|| pidbNil == pidb
			|| pidb->Cidxseg() < 2 
			|| PidxsegIDBGetIdxSeg( pidb, ptdbTable )[0].Columnid() != columnid )
			{
			AssertSz( fFalse, "Column cannot be converted to a placeholder." );
			pfcbTable->LeaveDDL();
			Call( ErrERRCheck( JET_errInvalidPlaceholderColumn ) );
			}

		Assert( pidb->FPrimary() );
		fPrimaryIndexPlaceholder = fTrue;

		ulFlags	= FIELDFLAGPersisted(
						FIELDFLAG( pfield->ffield | ffieldPrimaryIndexPlaceholder ) );
		}

	pfcbTable->LeaveDDL();


	//	Template bit is not persisted
	Assert( !FCOLUMNIDTemplateColumn( columnid ) || pfcbTable->FTemplateTable() );
	COLUMNIDResetFTemplateColumn( columnid );

	//  rename in the catalog and shadow catalog

	Call( ErrCATIRenameTableObject(
				ppib,
				pfucbTable->ifmp,
				objidTable,
				sysobjColumn,
				columnid,
				szNameNew,
				fPrimaryIndexPlaceholder ? &ulFlags : NULL,
				fFalse ) );
	Call( ErrCATIRenameTableObject(
				ppib,
				pfucbTable->ifmp,
				objidTable,
				sysobjColumn,
				columnid,
				szNameNew,
				fPrimaryIndexPlaceholder ? &ulFlags : NULL,
				fTrue ) );

	//  once the commit succeeds, no errors can be generated
	
	Call( ErrDIRCommitTransaction( ppib, NO_GRBIT ) );

	pfcbTable->EnterDML();
	
	Call( ErrFILEPfieldFromColumnName(
			ppib,
			pfcbTable,
			szNameOld,
			&pfield,
			&columnid ) );
	Assert( pfieldNil != pfield );

	itagColumnNameOld = pfield->itagFieldName;
	Assert( itagColumnNameOld != itagColumnNameNew );

	pfield->itagFieldName = itagColumnNameNew;
	pfield->strhashFieldName = StrHashValue( szNameNew );
	itagColumnNameNew = 0;

	pfcbTable->LeaveDML();
	pfcbTable->EnterDDL();
	
	ptdbTable->MemPool().DeleteEntry( itagColumnNameOld );

	if ( fPrimaryIndexPlaceholder )
		{
		FIELDSetPrimaryIndexPlaceholder( pfield->ffield );

		Assert( pidbNil != pfcbTable->Pidb() );
		Assert( pfcbTable->Pidb()->FPrimary() );
		pfcbTable->Pidb()->SetFHasPlaceholderColumn();
		}

	pfcbTable->LeaveDDL();
		
HandleError:

	if( 0 != itagColumnNameNew )
		{
		pfcbTable->EnterDDL();
		ptdbTable->MemPool().DeleteEntry( itagColumnNameNew );
		pfcbTable->LeaveDDL();
		}
		
	if( err < 0 )
		{
		CallSx( ErrDIRRollback( ppib ), JET_errRollbackError );
		}

	return err;
	}


//  ================================================================
ERR ErrCATAddCallbackToTable(
	PIB * const ppib,
	const IFMP ifmp,
	const CHAR * const szTable,
	const JET_CBTYP cbtyp,
	const CHAR * const szCallback )
//  ================================================================
//
//  Used during upgrade. This does not add the callback to the TDB
//  and doesn't version it properly
//
//-
	{
	ERR 	err 			= JET_errSuccess;
	OBJID 	objidTable		= objidNil;
	PGNO	pgnoFDPTable	= pgnoNull;

	CallR( ErrDIRBeginTransaction( ppib, NO_GRBIT ) );
	Call( ErrCATSeekTable( ppib, ifmp, szTable, &pgnoFDPTable, &objidTable ) );
	Call( ErrCATAddTableCallback( ppib, ifmp, objidTable, cbtyp, szCallback ) );
	Call( ErrDIRCommitTransaction( ppib, NO_GRBIT ) );
	
HandleError:
	if( err < 0 )
		{
		CallSx( ErrDIRRollback( ppib ), JET_errRollbackError );
		}
	return err;
	}


//  ================================================================
ERR ErrCATIConvertColumn(
	PIB * const ppib,
	FUCB * const pfucbCatalog,
	JET_SETCOLUMN * const psetcols,
	const ULONG csetcols )
//  ================================================================
	{
	ERR		err				= JET_errSuccess;
	
	CallR( ErrIsamPrepareUpdate( ppib, pfucbCatalog, JET_prepReplaceNoLock ) );
	Call( ErrIsamSetColumns( (JET_SESID)ppib, (JET_VTID)pfucbCatalog, psetcols, csetcols ) );
	Call( ErrIsamUpdate( ppib, pfucbCatalog, NULL, 0, NULL, NO_GRBIT ) );

HandleError:
	if( err < 0 )
		{
		Call( ErrIsamPrepareUpdate( ppib, pfucbCatalog, JET_prepCancel ) );
		}
	return err;
	}

//  ================================================================
ERR ErrCATAddColumnCallback(
	PIB * const ppib,
	const IFMP ifmp,
	const CHAR * const szTable,
	const CHAR * const szColumn,
	const CHAR * const szCallback,
	const VOID * const pvCallbackData,
	const unsigned long cbCallbackData
	)
//  ================================================================
	{
	ERR 		err 			= JET_errSuccess;
	OBJID 		objidTable		= objidNil;
	PGNO		pgnoFDPTable	= pgnoNull;
	FUCB *		pfucbCatalog	= pfucbNil;
	BOOKMARK	bm;
	BYTE 		rgbBookmark[JET_cbBookmarkMost];
	ULONG 		cbBookmark;
	DATA		dataField;
	FIELDFLAG	ffield 		= 0;
	ULONG		ulFlags;
	
	JET_SETCOLUMN	rgsetcolumn[3];
	memset( rgsetcolumn, 0, sizeof( rgsetcolumn ) );

	rgsetcolumn[0].columnid	= fidMSO_Callback;	
	rgsetcolumn[0].pvData	= szCallback;
	rgsetcolumn[0].cbData	= (ULONG)strlen( szCallback );
	rgsetcolumn[0].grbit	= NO_GRBIT;
	rgsetcolumn[0].ibLongValue	= 0;
	rgsetcolumn[0].itagSequence	= 1;
	rgsetcolumn[0].err		= JET_errSuccess;

	rgsetcolumn[1].columnid	= fidMSO_CallbackData;	
	rgsetcolumn[1].pvData	= pvCallbackData;
	rgsetcolumn[1].cbData	= cbCallbackData;
	rgsetcolumn[1].grbit	= NO_GRBIT;
	rgsetcolumn[1].ibLongValue	= 0;
	rgsetcolumn[1].itagSequence	= 1;
	rgsetcolumn[1].err		= JET_errSuccess;

	rgsetcolumn[2].columnid	= fidMSO_Flags;	
	rgsetcolumn[2].pvData	= &ulFlags;
	rgsetcolumn[2].cbData	= sizeof( ulFlags );
	rgsetcolumn[2].grbit	= NO_GRBIT;
	rgsetcolumn[2].ibLongValue 	= 0;
	rgsetcolumn[2].itagSequence	= 1;
	rgsetcolumn[2].err		= JET_errSuccess;

	CallR( ErrDIRBeginTransaction( ppib, NO_GRBIT ) );
	Call( ErrCATSeekTable( ppib, ifmp, szTable, &pgnoFDPTable, &objidTable ) );

	//  We have to modify both the catalog and the shadow catalog
	Call( ErrCATOpen( ppib, ifmp, &pfucbCatalog, fFalse ) );	//  catalog
	Call( ErrCATISeekTableObject( ppib, pfucbCatalog, objidTable, sysobjColumn, szColumn ) );

	// get the exsiting flags 
	Assert( FFixedFid( fidMSO_Flags ) );
	Call( ErrRECIRetrieveFixedColumn(
				pfcbNil,
				pfucbCatalog->u.pfcb->Ptdb(),
				fidMSO_Flags,
				pfucbCatalog->kdfCurr.data,
				&dataField ) );
	CallS( err );
	Assert( dataField.Cb() == sizeof(ULONG) );
	ffield = *(UnalignedLittleEndian< FIELDFLAG > *)dataField.Pv();

	FIELDSetUserDefinedDefault( ffield );
	FIELDSetDefault( ffield );

	ulFlags = ffield;

	Call( ErrDIRRelease( pfucbCatalog ) );

	Assert( pfucbCatalog->bmCurr.key.prefix.FNull() );
	Assert( pfucbCatalog->bmCurr.data.FNull() );
	cbBookmark = min( pfucbCatalog->bmCurr.key.Cb(), sizeof(rgbBookmark) );
	Assert( cbBookmark <= JET_cbBookmarkMost );
	pfucbCatalog->bmCurr.key.CopyIntoBuffer( rgbBookmark, cbBookmark );

	bm.key.prefix.Nullify();
	bm.key.suffix.SetPv( rgbBookmark );
	bm.key.suffix.SetCb( cbBookmark );
	bm.data.Nullify();

	Call( ErrCATIConvertColumn( ppib, pfucbCatalog, rgsetcolumn, sizeof( rgsetcolumn ) / sizeof( rgsetcolumn[0] ) ) );
	Call( ErrCATClose( ppib, pfucbCatalog ) );
	pfucbCatalog = pfucbNil;

	Call( ErrCATOpen( ppib, ifmp, &pfucbCatalog, fTrue ) );		//	shadow catalog
	Call( ErrDIRGotoBookmark( pfucbCatalog, bm ) );
	Call( ErrCATIConvertColumn( ppib, pfucbCatalog, rgsetcolumn, sizeof( rgsetcolumn ) / sizeof( rgsetcolumn[0] ) ) );
	Call( ErrCATClose( ppib, pfucbCatalog ) );
	pfucbCatalog = pfucbNil;

	Call( ErrDIRCommitTransaction( ppib, NO_GRBIT ) );

HandleError:
	if( pfucbNil != pfucbCatalog )
		{
		CallS( ErrCATClose( ppib, pfucbCatalog ) );
		}
	if( err < 0 )
		{
		CallSx( ErrDIRRollback( ppib ), JET_errRollbackError );
		}
	return err;
	}

//  ================================================================
ERR ErrCATConvertColumn(
	PIB * const ppib,
	const IFMP ifmp,
	const CHAR * const szTable,
	const CHAR * const szColumn,
	const JET_COLTYP coltyp,
	const JET_GRBIT grbit )
//  ================================================================
	{
	ERR 		err 			= JET_errSuccess;
	OBJID 		objidTable		= objidNil;
	PGNO		pgnoFDPTable	= pgnoNull;
	FUCB *		pfucbCatalog	= pfucbNil;
	BOOKMARK	bm;
	BYTE		rgbBookmark[JET_cbBookmarkMost];
	ULONG		cbBookmark;
	FIELDFLAG	ffield = 0;

	//  this does no error checking. its for specialized use
	if ( grbit & JET_bitColumnEscrowUpdate )
		{
		FIELDSetEscrowUpdate( ffield );
		FIELDSetDefault( ffield );		//	escrow update fields must have a default valie
		}
	if( grbit & JET_bitColumnFinalize )
		{
		FIELDSetFinalize( ffield );
		}		
	if ( grbit & JET_bitColumnVersion )
		{
		FIELDSetVersion( ffield );
		}
	if ( grbit & JET_bitColumnAutoincrement )
		{
		FIELDSetAutoincrement( ffield );
		}		
	if ( grbit & JET_bitColumnNotNULL )
		{
		FIELDSetNotNull( ffield );
		}
	if ( grbit & JET_bitColumnMultiValued )
		{
		FIELDSetMultivalued( ffield );
		}
		
	const ULONG ulFlags = ffield;
	
	JET_SETCOLUMN	rgsetcolumn[2];
	memset( rgsetcolumn, 0, sizeof( rgsetcolumn ) );

	rgsetcolumn[0].columnid	= fidMSO_Coltyp;	
	rgsetcolumn[0].pvData	= &coltyp;
	rgsetcolumn[0].cbData	= sizeof( coltyp );
	rgsetcolumn[0].grbit	= NO_GRBIT;
	rgsetcolumn[0].ibLongValue	= 0;
	rgsetcolumn[0].itagSequence	= 1;
	rgsetcolumn[0].err		= JET_errSuccess;

	rgsetcolumn[1].columnid	= fidMSO_Flags;	
	rgsetcolumn[1].pvData	= &ulFlags;
	rgsetcolumn[1].cbData	= sizeof( ulFlags );
	rgsetcolumn[1].grbit	= NO_GRBIT;
	rgsetcolumn[1].ibLongValue	= 0;
	rgsetcolumn[1].itagSequence	= 1;
	rgsetcolumn[1].err		= JET_errSuccess;

	CallR( ErrDIRBeginTransaction( ppib, NO_GRBIT ) );
	Call( ErrCATSeekTable( ppib, ifmp, szTable, &pgnoFDPTable, &objidTable ) );

	//  We have to modify both the catalog and the shadow catalog
	Call( ErrCATOpen( ppib, ifmp, &pfucbCatalog, fFalse ) );	//  catalog
	Call( ErrCATISeekTableObject( ppib, pfucbCatalog, objidTable, sysobjColumn, szColumn ) );

	Call( ErrDIRRelease( pfucbCatalog ) );

	Assert( pfucbCatalog->bmCurr.key.prefix.FNull() );
	Assert( pfucbCatalog->bmCurr.data.FNull() );
	cbBookmark = min( pfucbCatalog->bmCurr.key.Cb(), sizeof(rgbBookmark) );
	Assert( cbBookmark <= JET_cbBookmarkMost );
	pfucbCatalog->bmCurr.key.CopyIntoBuffer( rgbBookmark, cbBookmark );

	bm.key.prefix.Nullify();
	bm.key.suffix.SetPv( rgbBookmark );
	bm.key.suffix.SetCb( cbBookmark );
	bm.data.Nullify();

	Call( ErrCATIConvertColumn( ppib, pfucbCatalog, rgsetcolumn, sizeof( rgsetcolumn ) / sizeof( rgsetcolumn[0] ) ) );
	Call( ErrCATClose( ppib, pfucbCatalog ) );
	pfucbCatalog = pfucbNil;

	Call( ErrCATOpen( ppib, ifmp, &pfucbCatalog, fTrue ) );		//	shadow catalog
	Call( ErrDIRGotoBookmark( pfucbCatalog, bm ) );
	Call( ErrCATIConvertColumn( ppib, pfucbCatalog, rgsetcolumn, sizeof( rgsetcolumn ) / sizeof( rgsetcolumn[0] ) ) );
	Call( ErrCATClose( ppib, pfucbCatalog ) );
	pfucbCatalog = pfucbNil;

	Call( ErrDIRCommitTransaction( ppib, NO_GRBIT ) );

HandleError:
	if( pfucbNil != pfucbCatalog )
		{
		CallS( ErrCATClose( ppib, pfucbCatalog ) );
		}
	if( err < 0 )
		{
		CallSx( ErrDIRRollback( ppib ), JET_errRollbackError );
		}
	return err;
	}


//  ================================================================
ERR ErrCATIncreaseMaxColumnSize(
	PIB * const			ppib,
	const IFMP			ifmp,
	const CHAR * const	szTable,
	const CHAR * const	szColumn,
	const ULONG			cbMaxLen )
//  ================================================================
	{
	ERR 				err 			= JET_errSuccess;
	OBJID 				objidTable		= objidNil;
	PGNO				pgnoFDPTable	= pgnoNull;
	FUCB *				pfucbCatalog	= pfucbNil;
	DATA				dataField;
	BOOKMARK			bm;
	BYTE				rgbBookmark[JET_cbBookmarkMost];
	ULONG				cbBookmark;
	JET_SETCOLUMN		rgsetcolumn[1];

	memset( rgsetcolumn, 0, sizeof( rgsetcolumn ) );

	rgsetcolumn[0].columnid	= fidMSO_SpaceUsage;	
	rgsetcolumn[0].pvData	= &cbMaxLen;
	rgsetcolumn[0].cbData	= sizeof( cbMaxLen );
	rgsetcolumn[0].grbit	= NO_GRBIT;
	rgsetcolumn[0].ibLongValue	= 0;
	rgsetcolumn[0].itagSequence	= 1;
	rgsetcolumn[0].err		= JET_errSuccess;

	CallR( ErrDIRBeginTransaction( ppib, NO_GRBIT ) );
	Call( ErrCATSeekTable( ppib, ifmp, szTable, &pgnoFDPTable, &objidTable ) );

	//  We have to modify both the catalog and the shadow catalog
	Call( ErrCATOpen( ppib, ifmp, &pfucbCatalog, fFalse ) );	//  catalog
	Call( ErrCATISeekTableObject( ppib, pfucbCatalog, objidTable, sysobjColumn, szColumn ) );

	Assert( Pcsr( pfucbCatalog )->FLatched() );

	Assert( FFixedFid( fidMSO_Coltyp ) );
	Call( ErrRECIRetrieveFixedColumn(
				pfcbNil,
				pfucbCatalog->u.pfcb->Ptdb(),
				fidMSO_Coltyp,
				pfucbCatalog->kdfCurr.data,
				&dataField ) );
	CallS( err );
	Assert( dataField.Cb() == sizeof(JET_COLTYP) );
	if ( !FRECLongValue( *( UnalignedLittleEndian< JET_COLTYP > *)dataField.Pv() ) )
		{
		Call( ErrERRCheck( JET_errInvalidParameter ) );
		}

	if ( cbMaxLen > 0 )
		{
		Assert( FFixedFid( fidMSO_SpaceUsage ) );
		Call( ErrRECIRetrieveFixedColumn(
					pfcbNil,
					pfucbCatalog->u.pfcb->Ptdb(),
					fidMSO_SpaceUsage,
					pfucbCatalog->kdfCurr.data,
					&dataField ) );
		CallS( err );
		Assert( dataField.Cb() == sizeof(ULONG) );
		if ( *(UnalignedLittleEndian< ULONG > *)dataField.Pv() > cbMaxLen
			|| 0 == *(UnalignedLittleEndian< ULONG > *)dataField.Pv() )
			{
			//	cannot decrease max. column size
			Call( ErrERRCheck( JET_errInvalidParameter ) );
			}
		}

	Call( ErrDIRRelease( pfucbCatalog ) );

	Assert( pfucbCatalog->bmCurr.key.prefix.FNull() );
	Assert( pfucbCatalog->bmCurr.data.FNull() );
	cbBookmark = min( pfucbCatalog->bmCurr.key.Cb(), sizeof(rgbBookmark) );
	Assert( cbBookmark <= JET_cbBookmarkMost );
	pfucbCatalog->bmCurr.key.CopyIntoBuffer( rgbBookmark, cbBookmark );

	bm.key.prefix.Nullify();
	bm.key.suffix.SetPv( rgbBookmark );
	bm.key.suffix.SetCb( cbBookmark );
	bm.data.Nullify();

	Call( ErrCATIConvertColumn( ppib, pfucbCatalog, rgsetcolumn, sizeof( rgsetcolumn ) / sizeof( rgsetcolumn[0] ) ) );
	Call( ErrCATClose( ppib, pfucbCatalog ) );
	pfucbCatalog = pfucbNil;

	Call( ErrCATOpen( ppib, ifmp, &pfucbCatalog, fTrue ) );		//	shadow catalog
	Call( ErrDIRGotoBookmark( pfucbCatalog, bm ) );
	Call( ErrCATIConvertColumn( ppib, pfucbCatalog, rgsetcolumn, sizeof( rgsetcolumn ) / sizeof( rgsetcolumn[0] ) ) );
	Call( ErrCATClose( ppib, pfucbCatalog ) );
	pfucbCatalog = pfucbNil;

	Call( ErrDIRCommitTransaction( ppib, NO_GRBIT ) );

HandleError:
	if( pfucbNil != pfucbCatalog )
		{
		CallS( ErrCATClose( ppib, pfucbCatalog ) );
		}
	if( err < 0 )
		{
		CallSx( ErrDIRRollback( ppib ), JET_errRollbackError );
		}
	return err;
	}


//  ================================================================
LOCAL ERR ErrCATIGetColumnsOfIndex(
	PIB			* const ppib,
	FUCB		* const pfucbCatalog,
	const OBJID	objidTable,
	const BOOL	fTemplateTable,
	const TCIB	* const ptcibTemplateTable,
	LE_IDXFLAG	* const ple_idxflag,
	IDXSEG		* const rgidxseg,
	ULONG		* const pcidxseg,
	IDXSEG		* const rgidxsegConditional,
	ULONG		* const pcidxsegConditional,
	BOOL		* const	pfPrimaryIndex
	)
//  ================================================================
	{
	ERR		err;
	DATA	dataField;

	Assert( !Pcsr( pfucbCatalog )->FLatched() );
	CallR( ErrDIRGet( pfucbCatalog ) );
	
	DATA&	dataRec = pfucbCatalog->kdfCurr.data;

	Assert( pfcbNil != pfucbCatalog->u.pfcb );
	Assert( pfucbCatalog->u.pfcb->FTypeTable() );
	Assert( pfucbCatalog->u.pfcb->FFixedDDL() );
	Assert( pfucbCatalog->u.pfcb->Ptdb() != ptdbNil );
	TDB * const ptdbCatalog = pfucbCatalog->u.pfcb->Ptdb();

	//	verify still on same table
	Assert( FFixedFid( fidMSO_ObjidTable ) );
	Call( ErrRECIRetrieveFixedColumn(
				pfcbNil,
				ptdbCatalog,
				fidMSO_ObjidTable,
				dataRec,
				&dataField ) );
	CallS( err );
	if( dataField.Cb() != sizeof(OBJID)
		|| objidTable != *( (UnalignedLittleEndian< OBJID > *)dataField.Pv() ) )
		{
		AssertSz( fFalse, "Catalog corruption" );
		Call( ErrERRCheck( JET_errCatalogCorrupted ) );
		}

	//	verify this is an index
	Assert( FFixedFid( fidMSO_Type ) );
	Call( ErrRECIRetrieveFixedColumn(
				pfcbNil,
				ptdbCatalog,
				fidMSO_Type,
				dataRec,
				&dataField ) );
	CallS( err );
	if( dataField.Cb() != sizeof(SYSOBJ)
		|| sysobjIndex != *( (UnalignedLittleEndian< SYSOBJ > *)dataField.Pv() ) )
		{
		AssertSz( fFalse, "Catalog corruption" );
		Call( ErrERRCheck( JET_errCatalogCorrupted ) );
		}

	Assert( FFixedFid( fidMSO_Flags ) );
	Call( ErrRECIRetrieveFixedColumn(
				pfcbNil,
				ptdbCatalog,
				fidMSO_Flags,
				dataRec,
				&dataField ) );
	CallS( err );
	Assert( dataField.Cb() == sizeof(ULONG) );

	*ple_idxflag = *(LE_IDXFLAG*)dataField.Pv();
	
	if( FIDBPrimary( ple_idxflag->fidb ) )
		{
		*pfPrimaryIndex = fTrue;
		*pcidxseg = 0;
		*pcidxsegConditional = 0;
		goto HandleError;
		}

	*pfPrimaryIndex = fFalse;
		
	Assert( FVarFid( fidMSO_KeyFldIDs ) );
	Call( ErrRECIRetrieveVarColumn(
				pfcbNil,
				ptdbCatalog,
				fidMSO_KeyFldIDs,
				dataRec,
				&dataField ) );
				
	// the length of the list of key fields should be a multiple
	// of the length of one field.
	if ( FIDXExtendedColumns( ple_idxflag->fIDXFlags ) )
		{
		Assert( sizeof(IDXSEG) == sizeof(JET_COLUMNID) );
		Assert( dataField.Cb() <= sizeof(JET_COLUMNID) * JET_ccolKeyMost );
		Assert( dataField.Cb() % sizeof(JET_COLUMNID) == 0 );
		Assert( dataField.Cb() / sizeof(JET_COLUMNID) <= JET_ccolKeyMost );
		*pcidxseg = dataField.Cb() / sizeof(JET_COLUMNID);

		if ( FHostIsLittleEndian() )
			{
			UtilMemCpy( rgidxseg, dataField.Pv(), dataField.Cb() );
#ifdef DEBUG			
			for ( ULONG iidxseg = 0; iidxseg < *pcidxseg; iidxseg++ )
				{
				Assert( !fTemplateTable || rgidxseg[iidxseg].FTemplateColumn() );
				Assert( FCOLUMNIDValid( rgidxseg[iidxseg].Columnid() ) );
				}
#endif				
			}
		else
			{
			LE_IDXSEG		*le_rgidxseg	= (LE_IDXSEG*)dataField.Pv();
			for ( ULONG iidxseg = 0; iidxseg < *pcidxseg; iidxseg++ )
				{
				LE_IDXSEG le_idxseg = ((LE_IDXSEG*)le_rgidxseg)[iidxseg]; // see if this will work for CISCO UNIX
				rgidxseg[iidxseg] = le_idxseg;
				Assert( !fTemplateTable || rgidxseg[iidxseg].FTemplateColumn() );
				Assert( FCOLUMNIDValid( rgidxseg[iidxseg].Columnid() ) );
				}
			}
		}
	else
		{
		Assert( sizeof(IDXSEG_OLD) == sizeof(FID) );
		Assert( dataField.Cb() <= sizeof(FID) * JET_ccolKeyMost );
		Assert( dataField.Cb() % sizeof(FID) == 0);
		Assert( dataField.Cb() / sizeof(FID) <= JET_ccolKeyMost );
		*pcidxseg = dataField.Cb() / sizeof(FID);
		SetIdxSegFromOldFormat(
				(UnalignedLittleEndian< IDXSEG_OLD > *)dataField.Pv(),
				rgidxseg,
				*pcidxseg,
				fFalse,
				fTemplateTable,
				ptcibTemplateTable );
		}

	Assert( FVarFid( fidMSO_ConditionalColumns ) );
	Call( ErrRECIRetrieveVarColumn(
				pfcbNil,
				ptdbCatalog,
				fidMSO_ConditionalColumns,
				dataRec,
				&dataField ) );
				
	// the length of the list of key fields should be a multiple
	// of the length of one field.
	if ( FIDXExtendedColumns( ple_idxflag->fIDXFlags ) )
		{
		Assert( sizeof(IDXSEG) == sizeof(JET_COLUMNID) );
		Assert( dataField.Cb() <= sizeof(JET_COLUMNID) * JET_ccolKeyMost );
		Assert( dataField.Cb() % sizeof(JET_COLUMNID) == 0 );
		Assert( dataField.Cb() / sizeof(JET_COLUMNID) <= JET_ccolKeyMost );
		*pcidxsegConditional = dataField.Cb() / sizeof(JET_COLUMNID);

		if ( FHostIsLittleEndian() )
			{
			UtilMemCpy( rgidxsegConditional, dataField.Pv(), dataField.Cb() );
#ifdef DEBUG			
			for ( ULONG iidxseg = 0; iidxseg < *pcidxsegConditional; iidxseg++ )
				{
				Assert( !fTemplateTable || rgidxsegConditional[iidxseg].FTemplateColumn() );
				Assert( FCOLUMNIDValid( rgidxsegConditional[iidxseg].Columnid() ) );
				}
#endif				
			}
		else
			{
			LE_IDXSEG		*le_rgidxseg	= (LE_IDXSEG*)dataField.Pv();
			for ( ULONG iidxseg = 0; iidxseg < *pcidxsegConditional; iidxseg++ )
				{
				rgidxsegConditional[iidxseg] = le_rgidxseg[iidxseg];
				Assert( !fTemplateTable || rgidxsegConditional[iidxseg].FTemplateColumn() );
				Assert( FCOLUMNIDValid( rgidxsegConditional[iidxseg].Columnid() ) );
				}
			}
		}
	else
		{
		Assert( sizeof(IDXSEG_OLD) == sizeof(FID) );
		Assert( dataField.Cb() <= sizeof(FID) * JET_ccolKeyMost );
		Assert( dataField.Cb() % sizeof(FID) == 0);
		Assert( dataField.Cb() / sizeof(FID) <= JET_ccolKeyMost );
		*pcidxsegConditional = dataField.Cb() / sizeof(FID);
		SetIdxSegFromOldFormat(
				(UnalignedLittleEndian< IDXSEG_OLD > *)dataField.Pv(),
				rgidxsegConditional,
				*pcidxsegConditional,
				fTrue,
				fTemplateTable,
				ptcibTemplateTable );
		}

HandleError:
	Assert( Pcsr( pfucbCatalog )->FLatched() );
	CallS( ErrDIRRelease( pfucbCatalog ) );

	return err;
	}


//  ================================================================
LOCAL ERR ErrCATIAddConditionalColumnsToIndex( 
	PIB * const ppib,
	FUCB * const pfucbCatalog,
	FUCB * const pfucbShadowCatalog,
	LE_IDXFLAG * ple_idxflag,
	const IDXSEG * const rgidxseg,
	const ULONG cidxseg,
	const IDXSEG * const rgidxsegExisting,
	const ULONG cidxsegExisting,
	const IDXSEG * const rgidxsegToAdd,
	const ULONG cidxsegToAdd )
//  ================================================================
//
//  pfucbCatalog should be on the record to be modified
//
//-
	{
	ERR 		err;
	BYTE		rgbBookmark[JET_cbBookmarkMost];
	ULONG 		cbBookmark;
	BOOKMARK	bm;
	UINT		iidxseg;
	IDXSEG 		rgidxsegConditional[JET_ccolKeyMost];
	BYTE		* pbidxsegConditional;
	ULONG		cidxsegConditional;
	LE_IDXSEG	le_rgidxsegConditional[JET_ccolKeyMost];
	LE_IDXSEG	le_rgidxseg[JET_ccolKeyMost];

	memcpy( rgidxsegConditional, rgidxsegExisting, sizeof(IDXSEG) * cidxsegExisting );

	//	start with the existing columns and add the new ones
	cidxsegConditional = cidxsegExisting;

	for ( iidxseg = 0; iidxseg < cidxsegToAdd; iidxseg++ )
		{
		//	verify column doesn't already exist in the list
		UINT	iidxsegT;
		for ( iidxsegT = 0; iidxsegT < cidxsegConditional; iidxsegT++ )
			{
			if ( rgidxsegConditional[iidxsegT].Columnid() == rgidxsegToAdd[iidxseg].Columnid() )
				{
				break;
				}
			}

		if ( iidxsegT == cidxsegConditional )
			{
			memcpy( rgidxsegConditional+cidxsegConditional, rgidxsegToAdd+iidxseg, sizeof(IDXSEG) );
			cidxsegConditional++;
			}
		}
	Assert( cidxsegConditional <= cidxsegExisting + cidxsegToAdd );

	if ( cidxsegConditional == cidxsegExisting )
		{
		//	nothing to do, just get out
		return JET_errSuccess;
		}
	else if( cidxsegConditional > JET_ccolKeyMost )
		{
		AssertSz( fFalse, "Too many conditional columns" );
		return ErrERRCheck( JET_errInvalidParameter );
		}

	LONG			l;
	JET_SETCOLUMN	rgsetcolumn[3];
	ULONG			csetcols = 0;
	memset( rgsetcolumn, 0, sizeof( rgsetcolumn ) );

	if ( FHostIsLittleEndian() )
		{
#ifdef DEBUG		
		for ( iidxseg = 0; iidxseg < cidxsegConditional; iidxseg++ )
			{
			Assert( FCOLUMNIDValid( rgidxsegConditional[iidxseg].Columnid() ) );
			}
#endif			

		pbidxsegConditional = (BYTE *)rgidxsegConditional;
		}
	else
		{
		for ( iidxseg = 0; iidxseg < cidxsegConditional; iidxseg++ )
			{
			Assert( FCOLUMNIDValid( rgidxsegConditional[iidxseg].Columnid() ) );

			//	Endian conversion
			le_rgidxsegConditional[iidxseg] = rgidxsegConditional[iidxseg];
			}

		pbidxsegConditional = (BYTE *)le_rgidxsegConditional;
		}

	//	see if we also have to update normal index columns to new format
	if ( !FIDXExtendedColumns( ple_idxflag->fIDXFlags ) )
		{
		BYTE	*pbidxseg;

		if ( FHostIsLittleEndian() )
			{
#ifdef DEBUG
			for ( iidxseg = 0; iidxseg < cidxseg; iidxseg++ )
				{
				Assert( FCOLUMNIDValid( rgidxseg[iidxseg].Columnid() ) );
				}
#endif

			pbidxseg = (BYTE *)rgidxseg;
			}
		else
			{
			for ( iidxseg = 0; iidxseg < cidxseg; iidxseg++ )
				{
				Assert( FCOLUMNIDValid( rgidxseg[iidxseg].Columnid() ) );

				//	Endian conversion
				le_rgidxseg[iidxseg] = rgidxseg[iidxseg];
				}

			pbidxseg = (BYTE *)le_rgidxseg;
			}
 
		rgsetcolumn[csetcols].columnid		= fidMSO_KeyFldIDs;
		rgsetcolumn[csetcols].pvData		= pbidxseg;
		rgsetcolumn[csetcols].cbData		= sizeof(IDXSEG) * cidxseg;
		rgsetcolumn[csetcols].grbit			= NO_GRBIT;
		rgsetcolumn[csetcols].ibLongValue	= 0;
		rgsetcolumn[csetcols].itagSequence	= 1;
		rgsetcolumn[csetcols].err			= JET_errSuccess;
		++csetcols;

		//	force to new format
		ple_idxflag->fIDXFlags = fIDXExtendedColumns;

		//	Hack on this field: SetColumn() will convert the fixed
		//	columns. So convert it here so that later it can be
		//	converted back to current value.
		l = ReverseBytesOnBE( *(LONG *)ple_idxflag );

		rgsetcolumn[csetcols].columnid		= fidMSO_Flags;
		rgsetcolumn[csetcols].pvData		= &l;
		rgsetcolumn[csetcols].cbData		= sizeof(l);
		rgsetcolumn[csetcols].grbit			= NO_GRBIT;
		rgsetcolumn[csetcols].ibLongValue	= 0;
		rgsetcolumn[csetcols].itagSequence	= 1;
		rgsetcolumn[csetcols].err			= JET_errSuccess;
		++csetcols;
		}

	rgsetcolumn[csetcols].columnid		= fidMSO_ConditionalColumns;	
	rgsetcolumn[csetcols].pvData		= pbidxsegConditional;
	rgsetcolumn[csetcols].cbData		= sizeof(IDXSEG) * cidxsegConditional;
	rgsetcolumn[csetcols].grbit			= NO_GRBIT;
	rgsetcolumn[csetcols].ibLongValue	= 0;
	rgsetcolumn[csetcols].itagSequence	= 1;
	rgsetcolumn[csetcols].err			= JET_errSuccess;
	++csetcols;

	Call( ErrIsamPrepareUpdate( ppib, pfucbCatalog, JET_prepReplaceNoLock ) );
	Call( ErrIsamSetColumns( (JET_SESID)ppib, (JET_VTID)pfucbCatalog, rgsetcolumn, csetcols ) );
	Call( ErrIsamUpdate( ppib, pfucbCatalog, rgbBookmark, sizeof( rgbBookmark ), &cbBookmark, NO_GRBIT ) );

	bm.key.Nullify();
	bm.data.Nullify();
	bm.key.suffix.SetPv( rgbBookmark );
	bm.key.suffix.SetCb( cbBookmark );
	
	Call( ErrDIRGotoBookmark( pfucbShadowCatalog, bm ) );
	Call( ErrIsamPrepareUpdate( ppib, pfucbShadowCatalog, JET_prepReplaceNoLock ) );
	Call( ErrIsamSetColumns( (JET_SESID)ppib, (JET_VTID)pfucbShadowCatalog, rgsetcolumn, csetcols ) );
	Call( ErrIsamUpdate( ppib, pfucbShadowCatalog, NULL, 0, NULL, NO_GRBIT ) );

HandleError:
	return err;
	}


//  ================================================================
ERR ErrCATAddConditionalColumnsToAllIndexes(
	PIB				* const ppib,
	const IFMP		ifmp,
	const CHAR		* const szTable,
	const JET_CONDITIONALCOLUMN	* rgconditionalcolumn,
	const ULONG		cConditionalColumn )
//  ================================================================
	{
	ERR 			err;
	OBJID 			objidTable;
	PGNO			pgnoFDPTable;
	FUCB			* pfucbCatalog			= pfucbNil;
	FUCB			* pfucbShadowCatalog	= pfucbNil;
	IDXSEG			rgidxsegToAdd[JET_ccolKeyMost];	
	ULONG			iidxseg;
	ULONG			ulFlags;
	DATA			dataField;
	BOOL			fTemplateTable			= fFalse;
	OBJID			objidTemplateTable		= objidNil;
	TCIB			tcibTemplateTable		= { fidFixedLeast-1, fidVarLeast-1, fidTaggedLeast-1 };
	LE_IDXFLAG		le_idxflag;
	const SYSOBJ	sysobj 					= sysobjIndex;

	CallR( ErrDIRBeginTransaction( ppib, NO_GRBIT ) );
	
	Call( ErrCATOpen( ppib, ifmp, &pfucbCatalog ) );
	Assert( pfucbNil != pfucbCatalog );

	Call( ErrCATSeekTable( ppib, ifmp, szTable, &pgnoFDPTable, &objidTable ) );

	Call( ErrCATISeekTable( ppib, pfucbCatalog, objidTable ) );
	Assert( Pcsr( pfucbCatalog )->FLatched() );

	//	should be on primary index
	Assert( pfucbNil == pfucbCatalog->pfucbCurIndex );
	
	Assert( FFixedFid( fidMSO_Flags ) );
	Call( ErrRECIRetrieveFixedColumn(
				pfcbNil,
				pfucbCatalog->u.pfcb->Ptdb(),
				fidMSO_Flags,
				pfucbCatalog->kdfCurr.data,
				&dataField ) );
	CallS( err );
	Assert( dataField.Cb() == sizeof(ULONG) );
	ulFlags = *(UnalignedLittleEndian< ULONG > *) dataField.Pv();
//	UtilMemCpy( &ulFlags, dataField.Pv(), sizeof(ULONG) );

	if ( ulFlags & JET_bitObjectTableDerived )
		{
		CHAR		szTemplateTable[JET_cbNameMost+1];
		COLUMNID	columnidLeast;

		Assert( FVarFid( fidMSO_TemplateTable ) );
		Call( ErrRECIRetrieveVarColumn(
					pfcbNil,
					pfucbCatalog->u.pfcb->Ptdb(),
					fidMSO_TemplateTable,
					pfucbCatalog->kdfCurr.data,
					&dataField ) );
		CallS( err );
		Assert( dataField.Cb() > 0 );
		Assert( dataField.Cb() <= JET_cbNameMost );
		UtilMemCpy( szTemplateTable, dataField.Pv(), dataField.Cb() );
		szTemplateTable[dataField.Cb()] = '\0';
			
		Assert( Pcsr( pfucbCatalog )->FLatched() );
		CallS( ErrDIRRelease( pfucbCatalog ) );
		
		Call( ErrCATSeekTable( ppib, ifmp, szTemplateTable, NULL, &objidTemplateTable ) );
		Assert( objidNil != objidTemplateTable );

		columnidLeast = fidFixedLeast;
		CallR( ErrCATIFindLowestColumnid(
					ppib,
					pfucbCatalog,
					objidTable,
					&columnidLeast ) );
		tcibTemplateTable.fidFixedLast = FID( FFixedFid( FidOfColumnid( columnidLeast ) ) ?	//	use FFixedFid() to avoid valid columnid check
											FidOfColumnid( columnidLeast ) - 1 :
											fidFixedLeast - 1 );

		columnidLeast = fidVarLeast;
		CallR( ErrCATIFindLowestColumnid(
					ppib,
					pfucbCatalog,
					objidTable,
					&columnidLeast ) );
		tcibTemplateTable.fidVarLast = FID( FCOLUMNIDVar( columnidLeast ) ?
											FidOfColumnid( columnidLeast ) - 1 :
											fidVarLeast - 1 );

		columnidLeast = fidTaggedLeast;
		CallR( ErrCATIFindLowestColumnid(
					ppib,
					pfucbCatalog,
					objidTable,
					&columnidLeast ) );
		tcibTemplateTable.fidTaggedLast = FID( FCOLUMNIDTagged( columnidLeast ) ?
											FidOfColumnid( columnidLeast ) - 1 :
											fidTaggedLeast - 1 );
		}
	else
		{
		if ( ulFlags & JET_bitObjectTableTemplate )
			fTemplateTable = fTrue;

		Assert( Pcsr( pfucbCatalog )->FLatched() );
		CallS( ErrDIRRelease( pfucbCatalog ) );
		}

	//	should still be on the primary index, which is the Id index
	Assert( pfucbNil == pfucbCatalog->pfucbCurIndex );
	Assert( !Pcsr( pfucbCatalog )->FLatched() );

	for ( iidxseg = 0; iidxseg < cConditionalColumn; iidxseg++ )
		{		
		const CHAR		* const szColumnName	= rgconditionalcolumn[iidxseg].szColumnName;
		const JET_GRBIT	grbit					= rgconditionalcolumn[iidxseg].grbit;
		COLUMNID		columnidT;
		BOOL			fColumnWasDerived;

		if( sizeof( JET_CONDITIONALCOLUMN ) != rgconditionalcolumn[iidxseg].cbStruct )
			{
			err = ErrERRCheck( JET_errIndexInvalidDef );
			Call( err );			
			}
			
		if( JET_bitIndexColumnMustBeNonNull != grbit
			&& JET_bitIndexColumnMustBeNull != grbit )
			{
			err = ErrERRCheck( JET_errInvalidGrbit );
			Call( err );			
			}

		err = ErrCATAccessTableColumn(
				ppib,
				ifmp,
				objidTable,
				szColumnName,
				&columnidT,
				!fTemplateTable );	//	only need to lock column if it's possible it might be deleted
		if ( JET_errColumnNotFound == err )
			{
			if ( objidNil != objidTemplateTable )
				{
				CallR( ErrCATAccessTableColumn(
						ppib,
						ifmp,
						objidTemplateTable,
						szColumnName,
						&columnidT ) );
				fColumnWasDerived = fTrue;
				}
			}
		else
			{
			CallR( err );
			}

		rgidxsegToAdd[iidxseg].ResetFlags();
		if ( JET_bitIndexColumnMustBeNull == grbit )
			rgidxsegToAdd[iidxseg].SetFMustBeNull();

		//	columnid's template bit is never persisted
		Assert( !FCOLUMNIDTemplateColumn( columnidT ) );
		if ( fColumnWasDerived || fTemplateTable )
			rgidxsegToAdd[iidxseg].SetFTemplateColumn();

		rgidxsegToAdd[iidxseg].SetFid( FidOfColumnid( columnidT ) );
		}

	Call( ErrCATOpen( ppib, ifmp, &pfucbShadowCatalog, fTrue ) );

	Call( ErrIsamMakeKey(
				ppib,
				pfucbCatalog,
				(BYTE *)&objidTable,
				sizeof(objidTable),
				JET_bitNewKey ) );
	Call( ErrIsamMakeKey(
				ppib,
				pfucbCatalog,
				(BYTE *)&sysobj,
				sizeof(sysobj),
				NO_GRBIT ) );

	err = ErrIsamSeek( ppib, pfucbCatalog, JET_bitSeekGT );
	if ( err < 0 )
		{
		if ( JET_errRecordNotFound != err )
			{
			//  No indexes?!
			Assert( fFalse );
			goto HandleError;
			}
		}
	else
		{
		CallS( err );
		
		Call( ErrIsamMakeKey(
					ppib,
					pfucbCatalog,
					(BYTE *)&objidTable,
					sizeof(objidTable),
					JET_bitNewKey ) );
		Call( ErrIsamMakeKey(
					ppib,
					pfucbCatalog,
					(BYTE *)&sysobj,
					sizeof(sysobj),
					JET_bitStrLimit ) );
		err = ErrIsamSetIndexRange( ppib, pfucbCatalog, JET_bitRangeUpperLimit );
		Assert( err <= 0 );
		while ( JET_errNoCurrentRecord != err )
			{
			IDXSEG	rgidxseg[JET_ccolKeyMost];
			IDXSEG	rgidxsegConditional[JET_ccolKeyMost];
			ULONG	cidxseg;
			ULONG	cidxsegConditional;
			BOOL	fPrimaryIndex;

			Call( err );			

			Call( ErrCATIGetColumnsOfIndex(
					ppib,
					pfucbCatalog,
					objidTable,
					fTemplateTable,
					( objidNil != objidTemplateTable ? &tcibTemplateTable : NULL ),
					&le_idxflag,
					rgidxseg,
					&cidxseg,
					rgidxsegConditional,
					&cidxsegConditional,
					&fPrimaryIndex ) );

			if( !fPrimaryIndex )
				{
				Call( ErrCATIAddConditionalColumnsToIndex(
					ppib,
					pfucbCatalog,
					pfucbShadowCatalog,
					&le_idxflag,
					rgidxseg,
					cidxseg,
					rgidxsegConditional,
					cidxsegConditional,
					rgidxsegToAdd,
					cConditionalColumn ) );
				}
				
			err = ErrIsamMove( ppib, pfucbCatalog, JET_MoveNext, NO_GRBIT );
			}

		Assert( JET_errNoCurrentRecord == err );
		err = JET_errSuccess;
		}

	err = ErrDIRCommitTransaction( ppib, NO_GRBIT );
	
HandleError:
	if( pfucbNil != pfucbCatalog )
		{
		CallS( ErrCATClose( ppib, pfucbCatalog ) );
		}
	if( pfucbNil != pfucbShadowCatalog )
		{
		CallS( ErrCATClose( ppib, pfucbShadowCatalog ) );
		}
	if( err < 0 )
		{
		CallSx( ErrDIRRollback( ppib ), JET_errRollbackError );
		}
	return err;
	}


// for addinf SLV tree and SLV Space Map Tree
LOCAL ERR ErrCATAddDbSLVObject(
	PIB				*ppib,
	FUCB			*pfucbCatalog,
	const CHAR		*szName,
	const PGNO		pgnoFDP,
	const OBJID		objidSLV,
	const SYSOBJ	sysobj,
	const ULONG		ulPages)
	{
	DATA			rgdata[idataMSOMax];
	const OBJID		objid				= objidSystemRoot;
	const ULONG		ulDensity			= ulFILEDensityMost;
	const ULONG		ulFlagsNil			= 0;

	//	must zero out to ensure unused fields are ignored
	memset( rgdata, 0, sizeof(rgdata) );
	
	rgdata[iMSO_ObjidTable].SetPv(		(BYTE *)&objid );
	rgdata[iMSO_ObjidTable].SetCb(		sizeof(objid) );
	rgdata[iMSO_Type].SetPv(			(BYTE *)&sysobj );
	rgdata[iMSO_Type].SetCb(			sizeof(sysobj) );
	rgdata[iMSO_Id].SetPv(				(BYTE *)&objidSLV );
	rgdata[iMSO_Id].SetCb(				sizeof(objidSLV) );
	rgdata[iMSO_Name].SetPv(			(BYTE *)szName );
	rgdata[iMSO_Name].SetCb(			strlen( szName ) );
	rgdata[iMSO_PgnoFDP].SetPv(			(BYTE *)&pgnoFDP );
	rgdata[iMSO_PgnoFDP].SetCb(			sizeof(pgnoFDP) );
	rgdata[iMSO_SpaceUsage].SetPv(		(BYTE *)&ulDensity );
	rgdata[iMSO_SpaceUsage].SetCb(		sizeof(ulDensity) );
	rgdata[iMSO_Flags].SetPv(			(BYTE *)&ulFlagsNil );
	rgdata[iMSO_Flags].SetCb(			sizeof(ulFlagsNil) );
	rgdata[iMSO_Pages].SetPv(			(BYTE *)&ulPages );
	rgdata[iMSO_Pages].SetCb(			sizeof(ulPages) );
	
	return ErrCATInsert( ppib, pfucbCatalog, rgdata, iMSO_Pages );
	}


LOCAL ERR ErrCATAccessDbSLVObject(
	PIB				* const ppib,
	const IFMP		ifmp,
	const CHAR		* const szName,
	PGNO			* const ppgno,
	OBJID			* const pobjid,
	const SYSOBJ 	sysobj)
	{
	ERR				err;
	FUCB			*pfucbCatalog	= pfucbNil;

	Assert( NULL != ppgno );
	*ppgno 	= pgnoNull;
	*pobjid = objidNil;

	CallR( ErrCATOpen( ppib, ifmp, &pfucbCatalog ) );
	Assert( pfucbNil != pfucbCatalog );

	err = ErrCATISeekTableObject(
				ppib,
				pfucbCatalog,
				objidSystemRoot,
				sysobj,
				szName );

	if ( JET_errSuccess <= err  )
		{
		DATA	dataField;
		
		Assert( Pcsr( pfucbCatalog )->FLatched() );

		Assert( FFixedFid( fidMSO_PgnoFDP ) );
		Call( ErrRECIRetrieveFixedColumn(
					pfcbNil,
					pfucbCatalog->u.pfcb->Ptdb(),
					fidMSO_PgnoFDP,
					pfucbCatalog->kdfCurr.data,
					&dataField ) );
		CallS( err );
		Assert( dataField.Cb() == sizeof(PGNO) );
		
		*ppgno = *(UnalignedLittleEndian< PGNO > *) dataField.Pv();
//		UtilMemCpy( ppgno, dataField.Pv(), sizeof(PGNO) );

		Assert( FFixedFid( fidMSO_Id ) );
		Call( ErrRECIRetrieveFixedColumn(
					pfcbNil,
					pfucbCatalog->u.pfcb->Ptdb(),
					fidMSO_Id,
					pfucbCatalog->kdfCurr.data,
					&dataField ) );
		CallS( err );
		Assert( dataField.Cb() == sizeof(OBJID) );
		
		*pobjid = *(UnalignedLittleEndian< OBJID > *) dataField.Pv();
//		UtilMemCpy( pobjid, dataField.Pv(), sizeof(OBJID) );
		}

HandleError:
	CallS( ErrCATClose( ppib, pfucbCatalog ) );

	return err;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ese98\src\ese\cpage.cxx ===
/*******************************************************************

A physical page consists of the page header, a
data array and, at the end of the page, a TAG array
Each TAG in the TAG array holds the length and location
of one data blob. The upper bits of the size and location
are used to hold the flags associated with the data
blob.

One TAG (TAG 0) is reserved for use as an external
header. The external view of the page does not include
this TAG so we must add an offset to each iLine that
we receive as an argument.

Insertions and deletions from the page may cause space
on the page to become fragmented. When there is enough
space on the page for an insertion or replacement but
not enough contigous space the data blobs on the page
are compacted, moving all the free space to the end of
the data array.

Insert/Replace routines expect there to be enough free
space in the page for their operation. 

It is possible to assign one CPAGE to another. e.g.
	CPAGE foo;
	CPAGE bar;
	...
	foo = bar;

There are two caveats:
*  The destination page (foo) must not be currently attached
   to a page, i.e. It must be new or have had Release*Latch()
   called on it.
*  The source page (bar) is destroyed in the process of copying.
   This is done to keep the semantics simple be ensuring that
   there is onlyever one copy of a page, and that every CPAGE
   maps to a unique resource and should be released.
i.e Assignment changes ownership -- like the auto_ptr<T> template

*******************************************************************/

#include "std.hxx"
	
//  ****************************************************************
//  CLASS STATICS
//  ****************************************************************

BOOL			CPAGE::fTested					= fFalse;
BFDirtyFlags	CPAGE::bfdfRecordUpgradeFlags	= bfdfUntidy;
SIZE_T			CPAGE::cbHintCache				= 0;
SIZE_T			CPAGE::maskHintCache			= 0;
DWORD_PTR*		CPAGE::rgdwHintCache			= NULL;


//	flag CPAGEs that are set up by LoadPage()
const DWORD_PTR	CPAGE::dwBFLContextForLoadPageOnly	= 1;


//  ****************************************************************
//  INTERNAL INLINE ROUTINES
//  ****************************************************************


//  ================================================================
BOOL CPAGE::TAG::CmpPtagIb( const TAG* ptag1, const TAG* ptag2 )
//  ================================================================
	{
	return ptag1->Ib() < ptag2->Ib();
	}


//  ================================================================
INLINE VOID CPAGE::TAG::SetIb( USHORT ib )
//  ================================================================
//
//  This sets the ib in a tag. The flags are left unchanged
//
//-
	{
	Assert( (ib & fMaskFlagsFromShort) == 0 );
#ifdef DEBUG_PAGE
	USHORT usFlags = FFlags();
#endif	//  DEBUG_PAGE

	USHORT ibT = ib_;			//	endian conversion
	ibT = (USHORT)(ibT & fMaskFlagsFromShort );	//  clear current ib
	ibT |= ib;						//  set new ib
	ib_ = ibT;
	
#ifdef DEBUG_PAGE
	Assert( Ib() == ib );
	Assert( FFlags() == usFlags );
#endif	//  DEBUG_PAGE
	}


//  ================================================================
INLINE VOID CPAGE::TAG::SetCb( USHORT cb )
//  ================================================================
//
//  Sets the cb in a tag. The flags are left unchanged
//
//-
	{
	Assert( (cb & fMaskFlagsFromShort) == 0 );
#ifdef DEBUG_PAGE
	USHORT usFlags = FFlags();
#endif	//  DEBUG_PAGE

	USHORT	cbT = cb_;			//	endian conversion
	cbT = (USHORT)(cbT & fMaskFlagsFromShort);	//  clear current cb
	cbT |= cb;						//  set new cb
	cb_ = cbT;

#ifdef DEBUG_PAGE
	Assert( Cb() == cb );
	Assert( FFlags() == usFlags );
#endif	//  DEBUG_PAGE	
	}


//  ================================================================
INLINE VOID CPAGE::TAG::SetFlags( USHORT fFlags )
//  ================================================================
//
//  Sets the flags in a TAG. The cb and ib are not changed.
//
//-
	{
#ifdef DEBUG_PAGE
	INT cbOld = Cb();
	INT ibOld = Ib();
#endif	//  DEBUG_PAGE

	USHORT cbT = cb_;			// endian conversion
	USHORT ibT = ib_;			// endian conversion
	cbT = (USHORT)( cbT & fMaskValueFromShort );
	ibT = (USHORT)( ibT & fMaskValueFromShort );
	cbT |= (fFlags << shfCbFlags) & fMaskFlagsFromShort;
	ibT |= (fFlags << shfIbFlags) & fMaskFlagsFromShort;
	cb_ = cbT;
	ib_ = ibT;
	
#ifdef DEBUG_PAGE
	Assert( FFlags() == fFlags );
	Assert( Cb() == cbOld );
	Assert( Ib() == ibOld );
#endif	//  DEBUG_PAGE
	}


//  ================================================================
INLINE INT CPAGE::CbDataTotal_( const DATA * rgdata, INT cdata ) const
//  ================================================================
//
//  Returns the total size of all elements in a DATA array
//
//-
	{
	Assert( rgdata );
	Assert( cdata >= 0 );

	INT cbTotal = 0;
	INT iline	= 0;
	for ( ; iline < cdata; iline++ )
		{
		cbTotal += rgdata[iline].Cb();
		}
	return cbTotal;
	}


//  ================================================================
INLINE INT CPAGE::CbContigousFree_( ) const
//  ================================================================
//
//  Returns the number of bytes available at the end of the last line
//  on the page. This gives the size of the largest item that can be
//  inserted without reorganizing
//
//-
	{
	INT cb = CbPageData() - ((PGHDR *)m_bfl.pv)->ibMicFree;	
	cb -= ((PGHDR *)m_bfl.pv)->itagMicFree * sizeof( CPAGE::TAG );
	return cb;
	}




//  ================================================================
INLINE VOID CPAGE::FreeSpace_( INT cb ) 
//  ================================================================
//
//  Creates the amount of contigous free space passed to it,
//  reorganizing if necessary.
//  If not enough free space can be created we Assert
//
//-
	{
	Assert ( cb <= ((PGHDR*)m_bfl.pv)->cbFree && cb > 0 );
	
	if ( CbContigousFree_( ) < cb )
		{
		ReorganizeData_( );
		}	
	
	Assert( CbContigousFree_( ) >= cb );
	}


//  ================================================================
INLINE VOID CPAGE::CopyData_( const TAG * ptag, const DATA * rgdata, INT cdata )
//  ================================================================
//
//  Copies the data array into the page location pointed to by the TAG
//
//-
	{
	Assert( ptag && rgdata );
	Assert( cdata > 0 );
	
	BYTE * pb = PbFromIb_( ptag->Ib() );
	INT ilineCopy = 0;
	for ( ; ilineCopy < cdata; ilineCopy++ )
		{
		memmove( pb, rgdata[ilineCopy].Pv(), rgdata[ilineCopy].Cb() );
		pb += rgdata[ilineCopy].Cb();
		}	
	
	Assert( PbFromIb_( ptag->Ib() + ptag->Cb() ) == pb );
	}


//  ****************************************************************
//  PUBLIC MEMBER FUNCTIONS 
//  ****************************************************************


#ifdef DEBUG
//  ================================================================
CPAGE::CPAGE( ) :
//  ================================================================
//
//  Sets the member variables to NULL values. In DEBUG we see if we
//  need to run the one-time checks
//
//-
		m_ppib( ppibNil ),
		m_ifmp( 0 ),
		m_pgno( pgnoNull )
	{
	m_bfl.pv		= NULL;
	m_bfl.dwContext	= NULL;
	}

//  ================================================================
CPAGE::~CPAGE( )
//  ================================================================
//
//  Empty destructor
//
//  OPTIMIZATION:  consider inlining this method
//
//-
	{
	//  the page should have been released
	Assert( FAssertUnused_( ) );
	}
#endif	// DEBUG


//  ================================================================
ERR CPAGE::ErrGetNewPage(	PIB * ppib,
							IFMP ifmp,
							PGNO pgno,
							OBJID objidFDP,
							ULONG fFlags,
							BFLatchFlags bflf )
//  ================================================================
//
//  Get and latch a new page buffer from the buffer manager. Initialize the new page.
//
//-
	{
	ASSERT_VALID( ppib );
	Assert( FAssertUnused_( ) );

	PGHDR *ppghdr;
	TAG * ptag;

	//  get the page
	ERR	err;
	Call( ErrBFWriteLatchPage( &m_bfl, ifmp, pgno, BFLatchFlags( bflf | bflfNew ) ) );

	//  set CPAGE member variables
	m_ppib = ppib;
	m_ifmp = ifmp;
	m_pgno = pgno;

#ifndef RTM
ReInit:
#endif	//	!RTM

	//  set the page header variables
	ppghdr = (PGHDR*)m_bfl.pv;
	ppghdr->fFlags				= fFlags;
	ppghdr->objidFDP			= objidFDP;
	ppghdr->cbFree				= (USHORT)CbPageData();
	ppghdr->cbUncommittedFree	= 0;
	ppghdr->ibMicFree			= 0;
	ppghdr->itagMicFree			= 0;
	ppghdr->pgnoNext			= pgnoNull;
	ppghdr->pgnoPrev			= pgnoNull;
	ppghdr->pgnoThis			= pgno;

	if ( PinstFromIfmp( ifmp )->m_plog->m_fRecoveringMode == fRecoveringRedo )
		{
		//	Set a small dbtime. This is purely for debug then real use.
		//	In redo mode, all the latched, dirtied pages' dbtime will be set again.

		ppghdr->dbtimeDirtied = 1;
		}
	else
		{
		///	dbTime will be updated by Dirty()
		///		UpdateDBTime_();
		}

	Assert( (ppghdr->cbFree + sizeof( PGHDR )) == g_cbPage ); 
	Assert( ppghdr->pgnoThis == pgno );

	// insert the line for the external header
	ppghdr->itagMicFree = ctagReserved;
	{
	USHORT cbFree = ppghdr->cbFree;		// endian conversion
	cbFree -= sizeof( CPAGE::TAG );
	ppghdr->cbFree = cbFree;
	}

	ptag = PtagFromItag_( 0 );
	ptag->SetIb( 0 );
	ptag->SetCb( 0 );
	ptag->SetFlags( 0 );

#ifndef RTM
	if( !fTested )
		{
		//  The first time we latch a new page, run the internal test
		err = ErrTest();
		if ( err < JET_errSuccess )
			{
			ReleaseWriteLatch();
			CallR( err );
			}
		CallS( err );
		memset( m_bfl.pv, 0, g_cbPage );
		fTested = fTrue;
		goto ReInit;
		}
#endif	//	!RTM

	SetFNewRecordFormat();
	
	Dirty( bfdfDirty );

	ASSERT_VALID( this );
#ifdef DEBUG_PAGE
	DebugCheckAll( );
#endif	// DEBUG_PAGE

HandleError:
	Assert( JET_errSuccess != err || FAssertWriteLatch( ) );
	return err;
	}


//  ================================================================
BOOL CPAGE::FLastNodeHasNullKey() const
//  ================================================================
	{
	const PGHDR * const	ppghdr	= (PGHDR*)m_bfl.pv;
	LINE				line;

	//	should only be called for internal pages
	Assert( FInvisibleSons() );

	//	must be at least one node on the page
	Assert( ppghdr->itagMicFree > ctagReserved );
	GetPtr( ppghdr->itagMicFree - ctagReserved - 1, &line );

	//	internal nodes can't be marked versioned or deleted
	Assert( !( line.fFlags & (fNDVersion|fNDDeleted) ) );

	return ( !( line.fFlags & fNDCompressed )
			&& cbKeyCount + sizeof(PGNO) == line.cb
			&& 0 == *(UnalignedLittleEndian<SHORT> *)line.pv );
	}


//  ================================================================
VOID CPAGE::SetAllFlags( INT fFlags )
//  ================================================================
	{
#ifdef DEBUG_PAGE
	ASSERT_VALID( this );
#endif	//	DEBUG_PAGE
	Assert( FAssertWriteLatch() || FAssertWARLatch() );

	for ( INT itag = ((PGHDR*)m_bfl.pv)->itagMicFree - 1; itag >= ctagReserved; itag-- )
		{
		TAG * const ptag = PtagFromItag_( itag );
		ptag->SetFlags( USHORT( ptag->FFlags() | fFlags ) );
		}

#ifdef DEBUG_PAGE
	DebugCheckAll( );
#endif	// DEBUG_PAGE
	}


//  ================================================================
VOID CPAGE::ResetAllFlags( INT fFlags )
//  ================================================================
	{
#ifdef DEBUG_PAGE
	ASSERT_VALID( this );
#endif	//	DEBUG_PAGE
	Assert( FAssertWriteLatch() || FAssertWARLatch() );

	for ( INT itag = ((PGHDR*)m_bfl.pv)->itagMicFree - 1; itag >= ctagReserved; itag-- )
		{
		TAG * const ptag = PtagFromItag_( itag );
		ptag->SetFlags( USHORT( ptag->FFlags() & ~fFlags ) );
		}

#ifdef DEBUG_PAGE
	DebugCheckAll( );
#endif	// DEBUG_PAGE
	}


//  ================================================================
VOID CPAGE::Dirty_( const BFDirtyFlags bfdf )
//  ================================================================
//
//  Tells the buffer manager that the page has been modified.
//  Checking the flags is cheaper than setting them (don't need a
//  critical section) so we check the flags to avoid setting them
//  redundantly.
//
//-
	{
#ifdef DEBUG_PAGE
	ASSERT_VALID( this );
#endif	//	DEBUG_PAGE
	Assert(	FAssertWriteLatch() ||
			FAssertWARLatch() );

	//  dirty the buffer.  if the page is in MSOShadow, make it filthy to force
	//  it to disk ASAP

	BFDirtyFlags bfdfT = bfdf;

	//	for the shadow catalog override changes and send them directly to disk
	
	if ( objidFDPMSOShadow == ((PGHDR*)m_bfl.pv)->objidFDP
		&& !PinstFromIfmp( m_ifmp )->m_plog->m_fRecovering
		&& rgfmp[ m_ifmp ].Dbid() != dbidTemp
		&& !fGlobalEseutil
		&& bfdfDirty == bfdf )
		{
		bfdfT = bfdfFilthy;
		}

	BFDirty( &m_bfl, bfdfT );

	//	We do not set pbf->lgposBegin0 until we update lgposModify.
	//	The reason is that we do not log deferred Begin0 until we issue
	//	the first log operation. Currently the sequence is
	//		Dirty -> Update (first) Op -> Log update Op -> update lgposModify and lgposStart
	//	Since we may not have lgposStart until the deferred begin0 is logged
	//	when the first Log Update Op is issued for this transaction.
	//
	//	During redo, since we do not log update op, so the lgposStart will not
	//	be logged, so we have to do it here (dirty).

	if ( rgfmp[ m_ifmp ].FLogOn() && PinstFromIfmp( m_ifmp )->m_plog->m_fRecoveringMode == fRecoveringRedo )
		{
		Assert( !PinstFromIfmp( m_ifmp )->m_plog->m_fLogDisabled );
		Assert( CmpLgpos( &m_ppib->lgposStart, &lgposMax ) != 0 );
		Assert( CmpLgpos( &m_ppib->lgposStart, &lgposMin ) != 0 );
		BFSetLgposBegin0( &m_bfl, m_ppib->lgposStart );
		}
	}


//  ================================================================
VOID CPAGE::ReorganizeAndZero( const CHAR chZero )
//  ================================================================
	{
#ifdef DEBUG_PAGE
	ASSERT_VALID( this );
#endif

	const PGHDR * const ppghdr = (PGHDR*)m_bfl.pv;

	//  fully compact the page if necessary
	if ( CbContigousFree_( ) != ppghdr->cbFree )
		{
///		ReorganizeData_();
		ZeroOutGaps_( chZero );
		}

	BYTE * const pbFree	= PbFromIb_( ppghdr->ibMicFree );
	memset( pbFree, chZero, CbContigousFree_() );
	}


//  ================================================================
ERR CPAGE::ErrCheckPage( CPRINTF * const pcprintf ) const
//  ================================================================
	{
	const PGHDR * const ppghdr = (PGHDR*)m_bfl.pv;
	
	if( ppghdr->cbFree > CbPageData() )
		{
		(*pcprintf)( "page corruption (%d): cbFree too large (%d bytes, expected no more than %d bytes)\r\n",
						ppghdr->pgnoThis, ppghdr->cbFree, CbPageData() );
		return ErrERRCheck( JET_errDatabaseCorrupted );
		}

	if( (USHORT) ppghdr->cbUncommittedFree > (USHORT) ppghdr->cbFree )
		{
		(*pcprintf)( "page corruption (%d): cbUncommittedFree too large (%d bytes, cbFree is %d bytes)\r\n",
						ppghdr->pgnoThis, ppghdr->cbUncommittedFree, ppghdr->cbFree );
		return ErrERRCheck( JET_errDatabaseCorrupted );
		}
		
	if( ppghdr->ibMicFree > CbPageData() )
		{
		(*pcprintf)( "page corruption (%d): ibMicFree too large (%d bytes, expected no more than %d bytes)\r\n",
						ppghdr->pgnoThis, ppghdr->ibMicFree, CbPageData() );
		return ErrERRCheck( JET_errDatabaseCorrupted );
		}

	if( ppghdr->itagMicFree >= ( g_cbPageMax / sizeof( TAG ) ) )
		{
		(*pcprintf)( "page corruption (%d): itagMicFree too large (%d bytes)\r\n",
						ppghdr->pgnoThis, ppghdr->itagMicFree );
		return ErrERRCheck( JET_errDatabaseCorrupted );
		}

//	BYTE *rgbBuf = NULL;
//	BFAlloc( (VOID **)&rgbBuf );
//	TAG ** rgptag = (TAG **)rgbBuf;

	TAG * rgptagBuf[ g_cbPageMax / sizeof( TAG ) ];
	TAG ** rgptag = rgptagBuf;

	INT	cbTotal = 0;
	INT iptag 	= 0;
	INT itag 	= 0;
	for ( ; itag < ppghdr->itagMicFree; ++itag )
		{
		TAG * const ptag = PtagFromItag_( itag );
		if( ptag->Cb() < 0 )
			{
			(*pcprintf)( "page corruption (%d): TAG %d corrupted (cb = %d)\r\n",
							ppghdr->pgnoThis, itag, ptag->Cb() );
//			BFFree( rgbBuf );
			return ErrERRCheck( JET_errDatabaseCorrupted );
			}
		if ( 0 == ptag->Cb() )
			{
			continue;
			}
		if( ptag->Ib() < 0 )
			{
			(*pcprintf)( "page corruption (%d): TAG %d corrupted (cb = %d, ib = %d)\r\n",
							ppghdr->pgnoThis, itag, ptag->Cb(), ptag->Ib() );
//			BFFree( rgbBuf );
			return ErrERRCheck( JET_errDatabaseCorrupted );
			}

		if( ptag->Ib() + ptag->Cb() > ppghdr->ibMicFree )
			{
			(*pcprintf)( "page corruption (%d): TAG %d ends in free space (cb = %d, ib = %d, ibMicFree = %d)\r\n",
							ppghdr->pgnoThis, itag, ptag->Cb(), ptag->Ib(), ppghdr->ibMicFree );
//			BFFree( rgbBuf );
			return ErrERRCheck( JET_errDatabaseCorrupted );
			}
			
		cbTotal += ptag->Cb();
		rgptag[iptag++] = ptag;
		}
		
	const INT cptag = iptag;

	//  sort the array by ib
	
	sort( rgptag, rgptag + cptag, TAG::CmpPtagIb );

	//  work through the array, from smallest to second-largest, checking for overlaps
	
	for ( iptag = 0; iptag < cptag - 1; ++iptag )
		{
		const TAG * const ptag 			= rgptag[iptag];
		const TAG * const ptagNext 		= rgptag[iptag+1];

		Assert( ptag->Ib() < ptagNext->Ib() );
		
		if( ptag->Ib() + ptag->Cb() > ptagNext->Ib() )
			{
			(*pcprintf)( "page corruption (%d): TAG overlap ( [cb:%d,ib:%d] overlaps [cb:%d,ib:%d])\r\n",
						ppghdr->pgnoThis, 
						ptag->Cb(), ptag->Ib(), 
						ptagNext->Cb(), ptagNext->Ib() );
//			BFFree( rgbBuf );
			return ErrERRCheck( JET_errDatabaseCorrupted );
			}
		}

	if( ppghdr->cbFree > 0 && cptag > 1 )
		{
		//  ibMicFree may not be correct, but it should always be too larger
		//  ibMicFree becomes wrong if you have three nodes ABC and you delete
		//  B (doesn't change ibMicFree) and then you delete C (ibMicFree should
		//  point to the end of A, but points to the end of B)
		TAG * const ptag 			= rgptag[cptag-1];
		if( ppghdr->ibMicFree < ptag->Ib() + ptag->Cb() )
			{
			(*pcprintf)( "page corruption (%d): ibMicFree is wrong (got %d, expected %d)\r\n",
						ppghdr->pgnoThis, 
						ppghdr->ibMicFree,
						ptag->Cb() + ptag->Ib() );
//			BFFree( rgbBuf );
			return ErrERRCheck( JET_errDatabaseCorrupted );
			}
		}
		
	//  all space on the page should be accounted for
	
	const INT cbAccountedFor = cbTotal + ppghdr->cbFree + (ppghdr->itagMicFree * sizeof( CPAGE::TAG ));
	if( cbAccountedFor != CbPageData() )
		{
		(*pcprintf)( "page corruption (%d): space mismatch (%d bytes accounted for, %d bytes expected)\r\n",
						ppghdr->pgnoThis, cbAccountedFor, CbPageData() );
//		BFFree( rgbBuf );
		return ErrERRCheck( JET_errDatabaseCorrupted );
		}

	//  make sure the page flags are coherent
	
	if( FIndexPage() && FPrimaryPage() )
		{
		(*pcprintf)( "page corruption (%d): corrupt flags (0x%x)\r\n", Pgno(), FFlags() );
//		BFFree( rgbBuf );
		return ErrERRCheck( JET_errDatabaseCorrupted );
		}

	if( FLongValuePage() && FIndexPage() )
		{
		(*pcprintf)( "page corruption (%d): corrupt flags (0x%x)\r\n", Pgno(), FFlags() );
//		BFFree( rgbBuf );
		return ErrERRCheck( JET_errDatabaseCorrupted );
		}

	if( FRepairedPage() )
		{
		(*pcprintf)( "page corruption (%d): repaired page (0x%x)\r\n", Pgno(), FFlags() );
//		BFFree( rgbBuf );
		return ErrERRCheck( JET_errDatabaseCorrupted );
		}

	if( FEmptyPage() )
		{
		(*pcprintf)( "page corruption (%d): empty page (0x%x)\r\n", Pgno(), FFlags() );
//		BFFree( rgbBuf );
		return ErrERRCheck( JET_errDatabaseCorrupted );
		}

//	BFFree( rgbBuf );

	return JET_errSuccess;
	}


	
//------------------------------------------------------------------
//  PRIVATE MEMBER FUNCTIONS 
//------------------------------------------------------------------



//  ================================================================
VOID CPAGE::Replace_( INT itag, const DATA * rgdata, INT cdata, INT fFlags )
//  ================================================================
//
//  Replace the specified line. Do not try to replace a line with data elsewhere on
//  the page -- a reorganization will destroy the pointers.
//
//-
	{
	PGHDR *ppghdr = (PGHDR*)m_bfl.pv;

	Assert( itag >= 0 && itag < ppghdr->itagMicFree );
	Assert( rgdata );
	Assert( cdata > 0 );
	Assert( FAssertWriteLatch( ) );

	const USHORT	cbTotal = (USHORT)CbDataTotal_( rgdata, cdata );
	Assert( cbTotal >= 0 );

	TAG * const ptag	= PtagFromItag_( itag );
	Assert ( rgdata[0].Pv() != PbFromIb_( ptag->Ib() ) );
	
	const SHORT	cbDiff	= (SHORT)((INT)ptag->Cb() - (INT)cbTotal);	//  shrinking if cbDiff > 0

	//  we should have enough space
	Assert ( cbDiff > 0 || -cbDiff <= ppghdr->cbFree );

	if (	cbDiff >= 0 ||
			(	PbFromIb_( ptag->Ib() ) + ptag->Cb() == PbFromIb_( ppghdr->ibMicFree ) &&
				CbContigousFree_( ) >= -cbDiff ) )
		{

		//  we are either shrinking or we are the last node on the page and there is enough space at the end
		//  of the page for us to grow. the node stays where it is
		if ( ptag->Ib() + ptag->Cb() == ppghdr->ibMicFree )
			{
			ppghdr->ibMicFree = USHORT( ppghdr->ibMicFree - cbDiff );
			}
		ppghdr->cbFree = USHORT( ppghdr->cbFree + cbDiff );
		}
	else
		{

		//  GROWING. we will be moving the line
		//  delete the current line in preparation
		USHORT cbFree = (USHORT)( ppghdr->cbFree + ptag->Cb() );
		ppghdr->cbFree = cbFree;
		ptag->SetIb( 0 );
		ptag->SetCb( 0 );
		ptag->SetFlags( 0 );

#ifdef DEBUG
		//  we cannot have a pointer to anything on the page because we may reorganize the page
		INT idata = 0;
		for ( ; idata < cdata; ++idata )
			{
			Assert( FAssertNotOnPage_( rgdata[idata].Pv() ) );
			}
#endif	//  DEBUG

#ifdef DEBUG_PAGE_SHAKE
		//  force a reorganization
		DebugMoveMemory_();
#endif	//	DEBUG_PAGE_SHAKE

		FreeSpace_( cbTotal );

		ptag->SetIb( ppghdr->ibMicFree );
		ppghdr->ibMicFree = USHORT( ppghdr->ibMicFree + cbTotal );
		ppghdr->cbFree = USHORT( ppghdr->cbFree - cbTotal );
		}
	ptag->SetCb( cbTotal );
	ptag->SetFlags( (USHORT)fFlags );

	CopyData_ ( ptag, rgdata, cdata );

#ifdef DEBUG_PAGE
	DebugCheckAll( );
#endif	// DEBUG_PAGE
	}


//  ================================================================
VOID CPAGE::ReplaceFlags_( INT itag, INT fFlags )
//  ================================================================
	{
	Assert( itag >= 0 && itag < ((PGHDR*)m_bfl.pv)->itagMicFree );
	Assert( FAssertWriteLatch() || FAssertWARLatch() );

	TAG * const ptag = PtagFromItag_( itag );
	ptag->SetFlags( (USHORT)fFlags );

#ifdef DEBUG_PAGE
	DebugCheckAll( );
#endif	// DEBUG_PAGE
	}


//  ================================================================
VOID CPAGE::Insert_( INT itag, const DATA * rgdata, INT cdata, INT fFlags )
//  ================================================================
//
//  Insert a new line into the page, reorganizing if necessary. If we are
//  inserting at a location where a line exists it will be moved up.
//
//-
	{
	PGHDR *ppghdr = (PGHDR*)m_bfl.pv;
	
	Assert( itag >= 0 && itag <= ppghdr->itagMicFree );
	Assert( rgdata );
	Assert( cdata > 0 );
	Assert( FAssertWriteLatch( ) );

	const USHORT cbTotal = (USHORT)CbDataTotal_( rgdata, cdata );
	Assert( cbTotal >= 0 );

#ifdef DEBUG_PAGE
	//  we cannot have a pointer to anything on the page because we may reorganize the page
	INT idata = 0;
	for ( ; idata < cdata; ++idata )
		{
		Assert( FAssertNotOnPage_( rgdata[idata].pv ) );
		}
#endif	//  DEBUG

	FreeSpace_( cbTotal + sizeof( CPAGE::TAG ) );

	//  expand the tag array and make room
	copy(
		PtagFromItag_( ppghdr->itagMicFree-1 ) ,
		PtagFromItag_( itag-1 ),
		PtagFromItag_( ppghdr->itagMicFree ) );
	ppghdr->itagMicFree = USHORT( ppghdr->itagMicFree + 1 );
///	ShiftTagsUp_( itag );

	TAG * const ptag = PtagFromItag_( itag );
	ptag->SetCb( 0 );
	ptag->SetIb( 0 );
	ptag->SetFlags( 0 );

	ptag->SetIb( ppghdr->ibMicFree );
	ppghdr->ibMicFree = USHORT( ppghdr->ibMicFree + cbTotal );
	ptag->SetCb( cbTotal );
	const USHORT cbFree =	(USHORT)(ppghdr->cbFree - ( cbTotal + sizeof( CPAGE::TAG ) ) );
	ppghdr->cbFree = cbFree;
	ptag->SetFlags( (USHORT)fFlags );

	CopyData_ ( ptag, rgdata, cdata );

#ifdef DEBUG_PAGE
	DebugCheckAll( );
#endif	// DEBUG_PAGE
	}


//  ================================================================
VOID CPAGE::Delete_( INT itag )
//  ================================================================
//
//  Delete a line, freeing its space on the page
//
//-
	{
	PGHDR *ppghdr = (PGHDR*)m_bfl.pv;
	
	Assert( itag >= ctagReserved && itag < ppghdr->itagMicFree );	// never delete the external header
	Assert( FAssertWriteLatch( ) );

	const TAG * const ptag = PtagFromItag_( itag );
	
	//  reclaim the free space if it is at the end
	if ( (ptag->Cb() + ptag->Ib()) == ppghdr->ibMicFree )
		{
		const USHORT ibMicFree = (USHORT)( ppghdr->ibMicFree - ptag->Cb() );
		ppghdr->ibMicFree = ibMicFree;
		}

	//  do this before we trash the tag
	
	const USHORT cbFree =	(USHORT)( ppghdr->cbFree + ptag->Cb() + sizeof( CPAGE::TAG ) );
	ppghdr->cbFree = cbFree;

	
///	ShiftTagsDown_( itag );
	ppghdr->itagMicFree = USHORT( ppghdr->itagMicFree - 1 );
	copy_backward(
		PtagFromItag_( ppghdr->itagMicFree ),
		PtagFromItag_( itag ),
		PtagFromItag_( itag-1 ) ); 

#ifdef DEBUG_PAGE
	DebugCheckAll( );
#endif	// DEBUG_PAGE
	}


//  ================================================================
INLINE VOID CPAGE::ReorganizeData_( )
//  ================================================================
//
//  Compact the data on the page to be contigous on the lower end of
//  the page. Sort the tags ( actually an array of pointers to TAGS -
//  we cannot reorder the tags on the page) by ib and move the lines
//  down, from first to last.
//
//  OPTIMIZATION:  searching the sorted array of tags for a gap of the right size
//  OPTIMIZATION:  sort an array of itags (2-bytes), not TAG* (4 bytes)
//  OPTIMIZATION:  try to fill gaps with a tag of the appropriate size from the end
//
//-
	{
	PGHDR *ppghdr = (PGHDR*)m_bfl.pv;
	
#ifdef DEBUG_PAGE_REORGANIZE
	// store a copy of the page
	BYTE rgbPage[g_cbPageMax];
	UtilMemCpy( rgbPage, m_bfl.pv, g_cbPage );
	CPAGE cpageT;
	cpageT.m_ppib	= m_ppib;
	cpageT.m_ifmp	= m_ifmp;
	cpageT.m_pgno	= m_pgno;
	cpageT.m_bfl.pv	= rgbPage;
#endif	// DEBUG_PAGE_REORGANIZE

	Assert( ppghdr->itagMicFree > 0 );
	Assert( 0 != ppghdr->cbFree );	// we should have space if we are to reorganize
	
	//  create a temporary array for the tags every tag except the external header
	//  must have at least two bytes of data and there must be at least one empty byte

	BYTE *rgbBuf;
	BFAlloc( (VOID **)&rgbBuf );
	TAG ** rgptag = (TAG **)rgbBuf;

//	TAG * rgptagBuf[ ( g_cbPageMax / ( cbNDNullKeyData ) ) + 1 ];
//	TAG ** rgptag = rgptagBuf;

	//  find all non-zero length tags and put them in the temporary array
	//  only the external header can be zero-length so we check for that
	//  case separately (for speed)
	INT iptag 	= 0;
	INT itag	= 0;
	for ( ; itag < ppghdr->itagMicFree; ++itag )
		{
		TAG * const ptag = PtagFromItag_( itag );
		rgptag[iptag++] = ptag;
		}
		
	const INT cptag = iptag;
	Assert( iptag <= ppghdr->itagMicFree );

	//  sort the array
	sort( rgptag, rgptag + cptag, TAG::CmpPtagIb );

	//  work through the array, from smallest to largest, moving the tags down
	USHORT ibDest		= 0;
	BYTE * pbDest	= PbFromIb_( ibDest );
	for ( iptag = 0; iptag < cptag; ++iptag )
		{
		TAG * const ptag 			= rgptag[iptag];
		const BYTE * const pbSrc	= PbFromIb_( ptag->Ib() );
		
		Assert( pbSrc >= pbDest || ptag->Cb() == 0 );
		memmove( pbDest, pbSrc, ptag->Cb() );
		ptag->SetIb( ibDest );
		
		ibDest = (USHORT)( ibDest + ptag->Cb() );
		pbDest += ptag->Cb();
		}

	ppghdr->ibMicFree = ibDest;

	BFFree( rgbBuf );

#ifdef DEBUG_PAGE_REORGANIZE
	
	//  see that the copy we made has the same info as the current page
	INT itagT;
	for ( itagT = 0; itagT < ppghdr->itagMicFree; ++itagT )
		{
		const TAG * const ptagOld = cpageT.PtagFromItag_( itagT );
		const TAG * const ptagNew = PtagFromItag_( itagT );
		Assert( ptagOld != ptagNew );
		Assert( ptagOld->Cb() == ptagNew->Cb() );
		Assert( cpageT.PbFromIb_( ptagOld->Ib() ) != PbFromIb_( ptagNew->Ib() ) );
		Assert( memcmp(	cpageT.PbFromIb_( ptagOld->Ib() ), PbFromIb_( ptagNew->Ib() ),
				ptagNew->Cb() ) == 0 );  
		}
	cpageT.m_ppib	= ppibNil;
	cpageT.m_ifmp	= 0;
	cpageT.m_pgno	= pgnoNull
	cpageT.m_bfl.pv	= NULL;
	DebugCheckAll( );
#endif	//  DEBUG_PAGE_REORGANIZE
	}

//  ================================================================
INLINE VOID CPAGE::ZeroOutGaps_( const CHAR chZero )
//  ================================================================
//
	//	Code has been cut-and-pasted from ReorganizeData_() above, then
	//	modified slightly to zero out gaps instead of filling them in
	{
	PGHDR *ppghdr = (PGHDR*)m_bfl.pv;
	
#ifdef DEBUG_PAGE_REORGANIZE
	// store a copy of the page
	BYTE rgbPage[g_cbPageMax];
	UtilMemCpy( rgbPage, m_bfl.pv, g_cbPage );
	CPAGE cpageT;
	cpageT.m_ppib	= m_ppib;
	cpageT.m_ifmp	= m_ifmp;
	cpageT.m_pgno	= m_pgno;
	cpageT.m_bfl.pv	= rgbPage;
#endif	// DEBUG_PAGE_REORGANIZE

	Assert( ppghdr->itagMicFree > 0 );
	Assert( 0 != ppghdr->cbFree );	// we should have space if we are to reorganize
	
	//  create a temporary array for the tags every tag except the external header
	//  must have at least two bytes of data and there must be at least one empty byte

	BYTE *rgbBuf;
	BFAlloc( (VOID **)&rgbBuf );
	TAG ** rgptag = (TAG **)rgbBuf;

//	TAG * rgptagBuf[ ( g_cbPageMax / ( cbNDNullKeyData ) ) + 1 ];
//	TAG ** rgptag = rgptagBuf;

	//  find all non-zero length tags and put them in the temporary array
	//  only the external header can be zero-length so we check for that
	//  case separately (for speed)
	INT iptag 	= 0;
	INT itag	= 0;
	for ( ; itag < ppghdr->itagMicFree; ++itag )
		{
		TAG * const ptag = PtagFromItag_( itag );

		if ( ptag->Cb() > 0 )
			{
			rgptag[iptag++] = ptag;
			}
		}
		
	const INT cptag = iptag;
	Assert( iptag <= ppghdr->itagMicFree );

	//  sort the array
	sort( rgptag, rgptag + cptag, TAG::CmpPtagIb );

	//  work through the array, from smallest to largest, filling in gaps
	for ( iptag = 0; iptag < cptag - 1; ++iptag )
		{
		const TAG	* const ptag 			= rgptag[iptag];
		const TAG	* const ptagNext		= rgptag[iptag+1];
		BYTE		* const pbStartZeroing	= PbFromIb_( ptag->Ib() ) + ptag->Cb();
		const SIZE_T cbToZero				= PbFromIb_( ptagNext->Ib() ) - pbStartZeroing;

		Assert( ptag->Ib() < ptagNext->Ib() );

		if ( cbToZero > 0 )
			{
			memset( pbStartZeroing, chZero, cbToZero );
			}
		else
			{
			//	UNDONE: How do we hit the case where ptag->Cb()==0?
			Assert( 0 == cbToZero );
			}
		}

	BFFree( rgbBuf );

#ifdef DEBUG_PAGE_REORGANIZE
	
	//  see that the copy we made has the same info as the current page
	INT itagT;
	for ( itagT = 0; itagT < ppghdr->itagMicFree; ++itagT )
		{
		const TAG * const ptagOld = cpageT.PtagFromItag_( itagT );
		const TAG * const ptagNew = PtagFromItag_( itagT );
		Assert( ptagOld != ptagNew );
		Assert( ptagOld->Cb() == ptagNew->Cb() );
		Assert( cpageT.PbFromIb_( ptagOld->Ib() ) == PbFromIb_( ptagNew->Ib() ) );
		Assert( memcmp(	cpageT.PbFromIb_( ptagOld->Ib() ), PbFromIb_( ptagNew->Ib() ),
				ptagNew->Cb() ) == 0 );  
		}
	cpageT.m_ppib	= ppibNil;
	cpageT.m_ifmp	= 0;
	cpageT.m_pgno	= pgnoNull;
	cpageT.m_bfl.pv	= NULL;
	DebugCheckAll( );
#endif	//  DEBUG_PAGE_REORGANIZE
	}

//------------------------------------------------------------------
//  TEST ROUTINE
//------------------------------------------------------------------


#ifndef RTM

//  ================================================================
ERR CPAGE::TAG::ErrTest()
//  ================================================================
	{
	TAG tag;
	TAG tag2;

	tag.SetIb( 0x0 );
	tag.SetCb( 0x0 );
	tag.SetFlags( 0x0 );
	AssertRTL( tag.Cb() == 0x0 );
	AssertRTL( tag.Ib() == 0x0 );
	AssertRTL( tag.FFlags() == 0x0 );

	tag2.SetIb( 0x0 );
	tag2.SetCb( 0x0 );
	tag2.SetFlags( 0x0 );
	AssertRTL( tag2.Cb() == 0x0 );
	AssertRTL( tag2.Ib() == 0x0 );
	AssertRTL( tag2.FFlags() == 0x0 );

	AssertRTL( CPAGE::TAG::CmpPtagIb( &tag, &tag2 ) == 0 );

	tag.SetIb( 0x2000 );
	tag.SetCb( 0x2000 );
	tag.SetFlags( 0x003F );
	AssertRTL( tag.Cb() == 0x2000 );
	AssertRTL( tag.Ib() == 0x2000 );
	AssertRTL( tag.FFlags() == 0x03F );

	AssertRTL( CPAGE::TAG::CmpPtagIb( &tag, &tag2 ) > 0 );
	AssertRTL( CPAGE::TAG::CmpPtagIb( &tag2, &tag ) < 0 );

	tag2.SetIb( 0x500 );
	tag2.SetCb( 0x1 );
	tag2.SetFlags( 0x0003 );
	AssertRTL( tag2.Cb() == 0x500 );
	AssertRTL( tag2.Ib() == 0x1 );
	AssertRTL( tag2.FFlags() == 0x0003 );

	AssertRTL( CPAGE::TAG::CmpPtagIb( &tag, &tag2 ) > 0 );
	AssertRTL( CPAGE::TAG::CmpPtagIb( &tag2, &tag ) < 0 );
	
	tag2.SetIb( 0xFFF );
	tag2.SetCb( 0xFFF );
	tag2.SetFlags( 0x0030 );
	AssertRTL( tag2.Cb() == 0xFFF );
	AssertRTL( tag2.Ib() == 0xFFF );
	AssertRTL( tag2.FFlags() == 0x0030 );

	tag2.SetIb( 0x123 );
	tag2.SetCb( 0x456 );
	tag2.SetFlags( 0x0002 );
	AssertRTL( tag2.Cb() == 0x123 );
	AssertRTL( tag2.Ib() == 0x456 );
	AssertRTL( tag2.FFlags() == 0x0002 );

	return JET_errSuccess;
	}


//  ================================================================
ERR CPAGE::ErrTest()
//  ================================================================
	{
	const INT cbMaxNodeOld = 4047 + 1;	// the node grows by one byte as we have a 2-byte key size
	const INT cbTestNode = 34;

	INT cb;
	INT ib;

	VOID * const pvBuffer = PvOSMemoryHeapAlloc( g_cbPage );
	if( NULL == pvBuffer )
		{
		return ErrERRCheck( JET_errOutOfMemory );
		}
	//  set the buffer to a known value
	for( ib = 0; ib < g_cbPage; ++ib )
		{
		((BYTE *)pvBuffer)[ib] = (BYTE)ib;
		}

	//  Check the constants
	AssertRTL( 0 == g_cbPage % cchDumpAllocRow );
	AssertRTL( sizeof( CPAGE::TAG ) == 4 );
	AssertRTL( g_cbPage - sizeof( PGHDR ) - sizeof( CPAGE::TAG ) >= cbMaxNodeOld );
	AssertRTL( CbPageData() >= cbMaxNodeOld );
	AssertRTL( ctagReserved > 0 );		

	//  This should be an empty page
	AssertRTL( 0x0 == Clines() );
	AssertRTL( 0x0 == CbUncommittedFree() );
	
	SetPgnoNext( 0x1234 );
	AssertRTL( PgnoNext() == 0x1234 );
	SetPgnoPrev( 0x87654321 );
	AssertRTL( PgnoPrev() == 0x87654321 ); 
	SetPgnoNext( 0x0 );
	AssertRTL( PgnoNext() == 0x0 );
	SetPgnoPrev( 0x0 );
	AssertRTL( PgnoPrev() == 0x0 ); 

	SetFlags( fPageRoot | fPageLeaf | fPageLongValue );
	AssertRTL( ( fPageRoot | fPageLeaf | fPageLongValue ) == FFlags() );
	AssertRTL( FLeafPage() );
	AssertRTL( !FInvisibleSons() );
	AssertRTL( FRootPage() );
	AssertRTL( FFDPPage() );
	AssertRTL( !FEmptyPage() );
	AssertRTL( !FParentOfLeaf() );
	AssertRTL( !FSpaceTree() );
	AssertRTL( !FRepairedPage() );
	AssertRTL( FPrimaryPage() );
	AssertRTL( !FIndexPage() );
	AssertRTL( FLongValuePage() );
	AssertRTL( !FSLVAvailPage() );
	SetEmpty();
	AssertRTL( FLeafPage() );
	AssertRTL( !FInvisibleSons() );
	AssertRTL( FRootPage() );
	AssertRTL( FFDPPage() );
	AssertRTL( FEmptyPage() );
	AssertRTL( !FParentOfLeaf() );
	AssertRTL( !FSpaceTree() );
	AssertRTL( !FRepairedPage() );
	AssertRTL( FPrimaryPage() );
	AssertRTL( !FIndexPage() );
	AssertRTL( FLongValuePage() );
	AssertRTL( !FSLVAvailPage() );
	SetFlags( fPageRoot | fPageLeaf );
	AssertRTL( FPrimaryPage() );
	AssertRTL( !FIndexPage() );
	AssertRTL( !FLongValuePage() );
	AssertRTL( !FSLVAvailPage() );
	SetFlags( 0 );
	AssertRTL( 0 == FFlags() );

	SetCbUncommittedFree( 0x50 );
	AssertRTL( 0x50 == CbUncommittedFree() );
	AddUncommittedFreed( 0x25 );
	AssertRTL( 0x75 == CbUncommittedFree() );
	ReclaimUncommittedFreed( 0x10 );
	AssertRTL( 0x65 == CbUncommittedFree() );
	SetCbUncommittedFree( 0x0 );
	AssertRTL( 0x0 == CbUncommittedFree() );
	
	//  Test inserting one node of each size, up to the maximum
	
	for( cb = 1; cb < CbFree() - sizeof( CPAGE::TAG ); ++cb )
		{		
		DATA data;
		LINE line;
		LINE lineSav;
		
		data.SetPv( pvBuffer );
		data.SetCb( cb );
		
		Insert( 0, &data, 1, fNDVersion );
#ifdef DEBUG
		DebugCheckAll();
#endif	//	DEBUG
		
		GetPtr( 0, &lineSav );
		AssertRTL( lineSav.cb == cb );
		AssertRTL( 0 == memcmp( lineSav.pv, pvBuffer, cb ) );
		AssertRTL( fNDVersion == lineSav.fFlags );
		
		Replace( 0, &data, 1, fNDDeleted | fNDCompressed );
#ifdef DEBUG
		DebugCheckAll();
#endif	//	DEBUG

		//  The replace didn't change the size of the node so it shouldn't have moved
		GetPtr( 0, &line );
		AssertRTL( line.cb == cb );
		AssertRTL( line.pv == lineSav.pv );
		AssertRTL( ( fNDDeleted | fNDCompressed ) == line.fFlags );
		
		Delete( 0 );
#ifdef DEBUG
		DebugCheckAll();
#endif	//	DEBUG
		AssertRTL( 0x0 == Clines() );
		}
		
	OSMemoryHeapFree( pvBuffer );
	return JET_errSuccess;
	}

#endif	//	!RTM


//  Page Hint Cache

//  ================================================================
ERR CPAGE::ErrGetPageHintCacheSize( ULONG_PTR* const pcbPageHintCache )
//  ================================================================
	{
	*pcbPageHintCache = ( maskHintCache + 1 ) * sizeof( DWORD_PTR );
	return JET_errSuccess;
	}

//  ================================================================
ERR CPAGE::ErrSetPageHintCacheSize( const ULONG_PTR cbPageHintCache )
//  ================================================================
	{
	//  clip the requested size to the valid range
	
	const SIZE_T cbPageHintCacheMin = 128;
	const SIZE_T cbPageHintCacheMax = cbHintCache;

	SIZE_T	cbPageHintCacheVal	= cbPageHintCache;
			cbPageHintCacheVal	= max( cbPageHintCacheVal, cbPageHintCacheMin );
			cbPageHintCacheVal	= min( cbPageHintCacheVal, cbPageHintCacheMax );

	//  round the validated size up to the next power of two

	for (	SIZE_T cbPageHintCacheSet = 1;
			cbPageHintCacheSet < cbPageHintCacheVal;
			cbPageHintCacheSet *= 2 );

	//  set the new utilized size of the page hint cache to the new size if it
	//  has grown by a power of two or shrunk by two powers of two.  we try to
	//  minimize size changes as they invalidate the contents of the cache

	if (	maskHintCache < cbPageHintCacheSet / sizeof( DWORD_PTR ) - 1 ||
			maskHintCache > cbPageHintCacheSet / sizeof( DWORD_PTR ) * 2 - 1 )
		{
		maskHintCache = cbPageHintCacheSet / sizeof( DWORD_PTR ) - 1;
		}

	return JET_errSuccess;
	}


//  ================================================================
ERR CPAGE::ErrInit()
//  ================================================================
	{
	ERR err;
	
	//  allocate the hint cache.  the hint cache is a direct map cache
	//  used to store BFLatch hints for the page pointer of each node
	//  in each internal page
	//
	//  NOTE:  due to the fact that this is a direct map cache, it is not
	//  possible to guarantee the consistency of an entire BFLatch structure.
	//  as a result, we only store the dwContext portion of the BFLatch.  the
	//  buffer manager recomputes the other parts of the BFLatch on a hit.
	//  this helps the cache as it allows it have a higher hint density

	ULONG_PTR cbfCacheMax;
	CallS( ErrBFGetCacheSizeMax( &cbfCacheMax ) );
	if ( cbfCacheMax == lCacheSizeDefault )
		{
		cbfCacheMax = ULONG_PTR( QWORD( min( OSMemoryPageReserveTotal(), OSMemoryTotal() ) ) / g_cbPage );
		}

	const SIZE_T cbPageHintCacheMin = OSMemoryPageCommitGranularity();
	const SIZE_T cbPageHintCacheMax = cbfCacheMax * sizeof( DWORD_PTR );

	SIZE_T	cbPageHintCache	= g_cbPageHintCache;
			cbPageHintCache	= max( cbPageHintCache, cbPageHintCacheMin );
			cbPageHintCache	= min( cbPageHintCache, cbPageHintCacheMax );

	for ( cbHintCache = 1; cbHintCache < cbPageHintCache; cbHintCache *= 2 );
	maskHintCache = cbPageHintCacheMin / sizeof( DWORD_PTR ) - 1;

	if ( !( rgdwHintCache = (DWORD_PTR*)PvOSMemoryPageAlloc( cbHintCache, NULL ) ) )
		{
		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}

	return JET_errSuccess;

HandleError:
	Term();
	return err;
	}

//  ================================================================
VOID CPAGE::Term()
//  ================================================================
	{
	//  free the hint cache

	if ( rgdwHintCache )
		{
		OSMemoryPageFree( (void*) rgdwHintCache );
		rgdwHintCache = NULL;
		}
	}


//------------------------------------------------------------------
//  DEBUG/DEBUGGER_EXTENSION ROUTINES
//------------------------------------------------------------------


#if defined(DEBUGGER_EXTENSION) || defined(DEBUG)


//  ================================================================
INT	CPAGE::DumpAllocMap( CPRINTF * pcprintf )
//  ================================================================
//
//  Prints a 'map' of the page, showing how it is used.
//		H -- header
//		E -- external header
//		* -- data
//		T -- tag
//		. -- unused
//
//-
	{
	const INT cchBuf = g_cbPage;
	_TCHAR rgchBuf[g_cbPageMax];
	
	PGHDR *ppghdr = (PGHDR*)m_bfl.pv;

	INT ich = 0;
	for ( ; ich < cchBuf; ++ich )
		{
		//  we have to use a loop, not memset, so this will work with unicode
		rgchBuf[ich] = _T( '.' );
		}

	INT ichBase = 0;

	//  header
	ich = 0;
	for ( ; ich < sizeof( PGHDR ); ++ich )
		{
		rgchBuf[ich+ichBase] = _T( 'H' );
		}
	ichBase = ich;

	const TAG * const ptag = PtagFromItag_( 0 );
	Assert( ptag->Cb() < g_cbPage );
	Assert( ptag->Ib() < g_cbPage );
	ich = ptag->Ib();
	for ( ; ich < (ptag->Cb() + ptag->Ib()); ++ich )
		{
		rgchBuf[ich+ichBase] = _T( 'E' );
		}

	TAG * rgptagBuf[g_cbPageMax/sizeof(TAG)]; 
	TAG ** rgptag = rgptagBuf;

	INT iptag 	= 0;
	INT itag	= 1;
	for ( ; itag < ppghdr->itagMicFree; ++itag )
		{
		TAG * const ptag = PtagFromItag_( itag );
		rgptag[iptag++] = ptag;
		}
		
	const INT cptag = iptag;
	Assert( iptag <= ppghdr->itagMicFree );

	//  sort the array
	sort( rgptag, rgptag + cptag, TAG::CmpPtagIb );

	//  nodes
	for ( iptag = 0; iptag < ppghdr->itagMicFree - 1; ++iptag )
		{
		const TAG * const ptag = rgptag[iptag];
		Assert( ptag->Cb() < g_cbPage );
		Assert( ptag->Ib() < g_cbPage );
		ich = ptag->Ib();
		for ( ; ich < (ptag->Cb() + ptag->Ib()); ++ich )
			{
			rgchBuf[ich+ichBase] = ( iptag % 2 ) ? _T( '%' ) : _T( '#' );
			}
		}

	//  tags
	ichBase = g_cbPage;
	ichBase -= sizeof( CPAGE::TAG ) * ppghdr->itagMicFree;

	ich = 0;
	for ( ; ich < (INT)(sizeof( CPAGE::TAG ) * ppghdr->itagMicFree); ++ich )
		{
		rgchBuf[ich+ichBase] = _T( 'T' );
		}

	// print the map
	INT iRow = 0;
	for ( ; iRow < g_cbPage/cchDumpAllocRow; ++iRow )
		{
		_TCHAR rgchLineBuf[cchDumpAllocRow+1+1];
		UtilMemCpy( rgchLineBuf, &(rgchBuf[iRow*cchDumpAllocRow]), cchDumpAllocRow * sizeof( _TCHAR ) );
		rgchLineBuf[cchDumpAllocRow] = _T( '\n' );
		rgchLineBuf[cchDumpAllocRow+1] = 0;
		(*pcprintf)( "%s", rgchLineBuf );
		}
	(*pcprintf)( _T( "\n" ) );

	return 0;
	}


//  ================================================================
INT	CPAGE::DumpTags( CPRINTF * pcprintf, DWORD_PTR dwOffset )
//  ================================================================
	{
	PGHDR *ppghdr = (PGHDR*)m_bfl.pv;
	
	INT itag = 0;
	for ( ; itag < ppghdr->itagMicFree; ++itag )
		{
		const TAG * const ptag = PtagFromItag_( itag );
		if( 0 == dwOffset )
			{
			(*pcprintf)( _T( "TAG %3d    cb: %4d    ib: %4d    offset:%4x -%4x    flags: 0x%4.4x    " ),
					 itag, 
					 ptag->Cb(),
					 ptag->Ib(),
					 ptag->Ib() + sizeof(PGHDR),
					 ptag->Ib() + sizeof(PGHDR) + ptag->Cb() - 1,
					 ptag->FFlags() );
			}
		else
			{
			const DWORD_PTR		dwAddress = reinterpret_cast<DWORD_PTR>( PbFromIb_( ptag->Ib() ) ) + dwOffset;
			(*pcprintf)( _T( "TAG %3d    address: 0x%0*I64x-0x%0*I64x    cb: %4d    ib: %4d    flags: 0x%4.4x    " ),
					 itag,
					 sizeof(DWORD_PTR) * 2,		//	need 2 hex bytes for each byte
					 QWORD( dwAddress ),		//	assumes QWORD is largest pointer size we'll ever use
					 sizeof(DWORD_PTR) * 2,
					 QWORD( dwAddress + ptag->Cb() - 1 ),
					 ptag->Cb(),
					 ptag->Ib(),
					 ptag->FFlags() );
			}
		if( 0 != ptag->FFlags() )
			{
			(*pcprintf)( "(" );
			if( ptag->FFlags() & fNDVersion )
				{
				(*pcprintf)( "v" );
				}
			if( ptag->FFlags() & fNDDeleted )
				{
				(*pcprintf)( "d" );
				}
			if( ptag->FFlags() & fNDCompressed )
				{
				(*pcprintf)( "c" );
				}
			(*pcprintf)( ")" );
			}
		(*pcprintf)( "\n" );
		}
	if ( 0 == ppghdr->itagMicFree )
		{
		(*pcprintf)( _T( "Empty page\n" ) );
		}
	(*pcprintf)( _T( "\n" ) );
	return 0;
	}


//  ================================================================
INT	CPAGE::DumpHeader( CPRINTF * pcprintf, DWORD_PTR dwOffset )
//  ================================================================
//
//  Print the header of the page.
//
//-
	{
	PGHDR *ppghdr = (PGHDR*)m_bfl.pv;

	(*pcprintf)( FORMAT_INT( CPAGE::PGHDR, (PGHDR*)m_bfl.pv, pgnoThis, dwOffset ) );
	(*pcprintf)( FORMAT_INT( CPAGE::PGHDR, (PGHDR*)m_bfl.pv, objidFDP, dwOffset ) );
	(*pcprintf)( FORMAT_INT( CPAGE::PGHDR, (PGHDR*)m_bfl.pv, ulChecksumParity, dwOffset ) );
	
	const ULONG ulChecksumComputed = UlUtilChecksum( reinterpret_cast<const BYTE *>( m_bfl.pv ), g_cbPage );
	if( ulChecksumComputed != ppghdr->ulChecksumParity )
		{
		(*pcprintf)(
			_T( "\t** computed checksum: %u (0x%8.8x)\n" ),
			ulChecksumComputed,
			ulChecksumComputed );
		}

	(*pcprintf)( FORMAT_UINT( CPAGE::PGHDR, (PGHDR*)m_bfl.pv, dbtimeDirtied, dwOffset ) );
	(*pcprintf)( FORMAT_INT( CPAGE::PGHDR, (PGHDR*)m_bfl.pv, cbFree, dwOffset ) );
	(*pcprintf)( FORMAT_INT( CPAGE::PGHDR, (PGHDR*)m_bfl.pv, ibMicFree, dwOffset ) );
	(*pcprintf)( FORMAT_INT( CPAGE::PGHDR, (PGHDR*)m_bfl.pv, itagMicFree, dwOffset ) );
	(*pcprintf)( FORMAT_INT( CPAGE::PGHDR, (PGHDR*)m_bfl.pv, cbUncommittedFree, dwOffset ) );
	(*pcprintf)( FORMAT_INT( CPAGE::PGHDR, (PGHDR*)m_bfl.pv, pgnoNext, dwOffset ) );
	(*pcprintf)( FORMAT_INT( CPAGE::PGHDR, (PGHDR*)m_bfl.pv, pgnoPrev, dwOffset ) );
	(*pcprintf)( FORMAT_INT( CPAGE::PGHDR, (PGHDR*)m_bfl.pv, fFlags, dwOffset ) );

	if( FLeafPage() )
		{
		(*pcprintf)( _T( "\t\tLeaf page\n" ) );
		}

	if( FParentOfLeaf() )
		{
		(*pcprintf)( _T( "\t\tParent of leaf\n" ) );
		}

	if( FInvisibleSons() )
		{
		(*pcprintf)( _T( "\t\tInternal page\n" ) );
		}
		
	if( FRootPage() )
		{
		(*pcprintf)( _T( "\t\tRoot page\n" ) );
		}

	if( FFDPPage() )
		{
		(*pcprintf)( _T( "\t\tFDP page\n" ) );

		const TAG * const ptag = PtagFromItag_( 0 );
		if ( sizeof(SPACE_HEADER) != ptag->Cb()
			|| ptag->Ib() < 0
			|| ptag->Ib() > g_cbPage - sizeof(PGHDR) - sizeof(TAG) )
			{
			(*pcprintf)( _T( "\t\tCorrupted Space Header\n" ) );
			}
		else
			{
			const SPACE_HEADER	* const psph	= (SPACE_HEADER *)PbFromIb_( ptag->Ib() );
			if ( psph->FMultipleExtent() )
				{
				(*pcprintf)(
					_T( "\t\tMultiple Extent Space (ParentFDP: %d, pgnoOE: %d)\n" ),
					psph->PgnoParent(),
					psph->PgnoOE() );
				}
			else
				{
				(*pcprintf)( _T( "\t\tSingle Extent Space (ParentFDP: %d)\n" ), psph->PgnoParent() );
				}
			}
		}

	if( FEmptyPage() )
		{
		(*pcprintf)( _T( "\t\tEmpty page\n" ) );
		}

	if( FSpaceTree() )
		{
		(*pcprintf)( _T( "\t\tSpace tree page\n" ) );
		}

	if( FRepairedPage() )
		{
		(*pcprintf)( _T( "\t\tRepaired page\n" ) );
		}

	if( FPrimaryPage() )
		{
		(*pcprintf)( _T( "\t\tPrimary page\n" ) );
		}

	if( FIndexPage() )
		{
		(*pcprintf)( _T( "\t\tIndex page " ) );

		if ( FNonUniqueKeys() )
			{
			(*pcprintf)( _T( "(non-unique keys)\n" ) );
			}
		else
			{
			(*pcprintf)( _T( "(unique keys)\n" ) );
			}
		}
	else
		{
		Assert( !FNonUniqueKeys() );
		}

	if( FLongValuePage() )
		{
		(*pcprintf)( _T( "\t\tLong Value page\n" ) );
		}

	if( FSLVAvailPage() )
		{
		(*pcprintf)( _T( "\t\tSLV-Avail page\n" ) );
		}

	if( FSLVOwnerMapPage() )
		{
		(*pcprintf)( _T( "\t\tSLV-OwnerMap page\n" ) );
		}

	(*pcprintf)( _T( "\n" ) );

	return 0;
	}


#endif	//	DEBUGGER_EXTENSION || DEBUG


#ifdef DEBUG


//  ================================================================
VOID CPAGE::AssertValid() const
//  ================================================================
//
//  Do basic sanity checking on the object. Do not call a public method
//  from this, as it will call ASSERT_VALID( this ) again, causing an infinite
//  loop.
//
//-
	{
	PGHDR *ppghdr = (PGHDR*)m_bfl.pv;
	
	ASSERT_VALID( m_ppib );
	Assert( m_bfl.dwContext == dwBFLContextForLoadPageOnly || FBFLatched( &m_bfl ) );
	Assert( ppghdr->cbFree <= CbPageData() );
	Assert( ppghdr->cbUncommittedFree <= ppghdr->cbFree );
	Assert( ppghdr->ibMicFree <= CbPageData() );
	Assert( (USHORT) ppghdr->itagMicFree >= ctagReserved );
	//  we must use a static_cast to do the unsigned/signed conversion
	Assert( (USHORT) ppghdr->itagMicFree <= ( CbPageData() - (USHORT) ppghdr->cbFree ) / static_cast<INT>( sizeof( CPAGE::TAG ) ) ); // external header tag
	Assert( CbContigousFree_() <= ppghdr->cbFree );
	Assert( CbContigousFree_() >= 0 );
	Assert( static_cast<VOID *>( PbFromIb_( ppghdr->ibMicFree ) )
				<= static_cast<VOID *>( PtagFromItag_( ppghdr->itagMicFree - 1 ) ) );
	}									


//  ================================================================
VOID CPAGE::DebugCheckAll( ) const
//  ================================================================
//
//  Extensive checking on the page. This is expensive and slow -- it
//  is O(n^2) with respect to the number of lines.
//
//-
	{
	ASSERT_VALID( this );

	PGHDR *ppghdr = (PGHDR*)m_bfl.pv;
	INT	cbTotal = 0;
	
	INT itag = 0;
	for ( ; itag < ppghdr->itagMicFree; ++itag )
		{
		const TAG * const ptag = PtagFromItag_( itag );
		Assert( ptag );
		Assert( ptag->Cb() >= 0 );
		if ( 0 == ptag->Cb() )
			{
			continue;
			}
		Assert( ptag->Ib() >= 0 );
		Assert( ptag->Ib() + ptag->Cb() <= ppghdr->ibMicFree );
		cbTotal += ptag->Cb();

		//  check to see that we do not overlap with other tags

		INT itagOther = 0;
		for ( itagOther = 0; itagOther < ppghdr->itagMicFree; ++itagOther )
			{
			if ( ptag->Cb() == 0 )
				{
				continue;
				}
			if ( itagOther != itag )
				{
				const TAG * const ptagOther = PtagFromItag_( itagOther );
				Assert( ptagOther != ptag );
				if ( ptagOther->Cb() == 0 )
					{
					continue;
					}
				Assert( ptagOther->Ib() != ptag->Ib() );
				if ( ptagOther->Ib() < ptag->Ib() )
					{
					Assert( ptagOther->Ib() + ptagOther->Cb()
							<= ptag->Ib() );
					}
				else
					{
					Assert( ptag->Ib() + ptag->Cb() <= ptagOther->Ib() );
					}
				}
			}
		}

	//  all space on the page should be accounted for

	Assert( cbTotal + ppghdr->cbFree + (ppghdr->itagMicFree * sizeof( CPAGE::TAG )) == CbPageData() );
	}


//  ================================================================
VOID CPAGE::DebugMoveMemory_( )
//  ================================================================
//
//  This forces a reorganization of the page by removing the smallest
//  tag, reorganizing the page and then re-intserting it. Watch out
//  for infinite loops with Replace_, which calls this function.  
// 
//-
	{
	BYTE	rgbBuf[g_cbPageMax];
	PGHDR *ppghdr = (PGHDR*)m_bfl.pv;
	INT		cbTag = 0;
	INT		fFlagsTag;

	//  there may not be enough tags to reorganize
	//  we need one to delete and one to move
	if ( ppghdr->itagMicFree < ctagReserved + 2 )
		{
		return;
		}

	//  the page may be fully compacted
	if ( CbContigousFree_( ) == ppghdr->cbFree )
		{
		return;
		}

	//  save the smallest tag with a non-zero size
	//  we only loop to itagMicFree-1 as deleting the last tag is useless
	TAG * ptag 	= NULL;
	INT itag	= ctagReserved;
	for ( ; itag < ppghdr->itagMicFree - 1; ++itag )
		{
		ptag	= PtagFromItag_( itag );
		cbTag 	= ptag->Cb();
		if ( cbTag > 0 )
			{
			break;
			}
		}
	Assert( ptag );

	if ( 0 == cbTag )
		{
		//  nothing to reorganize
		return;
		}
	Assert( itag >= ctagReserved && itag < (ppghdr->itagMicFree - 1) );
	Assert( cbTag > 0 );

	fFlagsTag = ptag->FFlags();
	UtilMemCpy( rgbBuf, PbFromIb_( ptag->Ib() ), cbTag );

	//  reorganize the page
	Delete_( itag );
	ReorganizeData_( );

	//  reinsert the tag
	DATA data;
	data.SetPv( rgbBuf );
	data.SetCb( cbTag );
	Insert_( itag, &data, 1, fFlagsTag );
	}



//  ================================================================
BOOL CPAGE::FAssertDirty( ) const
//  ================================================================
	{
	return m_bfl.pv && FBFDirty( &m_bfl ) != bfdfClean;
	}


//  ================================================================
BOOL CPAGE::FAssertReadLatch( ) const
//  ================================================================
	{
	return m_bfl.dwContext == dwBFLContextForLoadPageOnly || FBFReadLatched( &m_bfl );
	}


//  ================================================================
BOOL CPAGE::FAssertRDWLatch( ) const
//  ================================================================
	{
	return m_bfl.dwContext == dwBFLContextForLoadPageOnly || FBFRDWLatched( &m_bfl );
	}


//  ================================================================
BOOL CPAGE::FAssertWriteLatch( ) const
//  ================================================================
	{
	return m_bfl.dwContext == dwBFLContextForLoadPageOnly || FBFWriteLatched( &m_bfl );
	}


//  ================================================================
BOOL CPAGE::FAssertWARLatch( ) const
//  ================================================================
	{
	return m_bfl.dwContext == dwBFLContextForLoadPageOnly || FBFWARLatched( &m_bfl );
	}


//  ================================================================
BOOL CPAGE::FAssertNotOnPage_( const VOID * pv ) const
//  ================================================================
//
//  Tests to see if the pointer given is on the page or not. Returns
//  fTrue if the pointer is not on the page.
//
//-
	{
	const BYTE * const pb = static_cast<const BYTE *>( pv );
	BOOL fGood =
		pb < reinterpret_cast<const BYTE * >( m_bfl.pv )
		|| pb >= reinterpret_cast<const BYTE * >( m_bfl.pv ) + g_cbPage
		;
	return fGood;
	}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ese98\src\ese\cres.cxx ===
#include "std.hxx"

#ifdef DEBUG
VOID CRES::DBGUpdateStat( BOOL fAlloc )
	{
	if ( fAlloc )
		{
		m_cBlockUsed++;
		if ( m_cBlockUsed > m_cBlockPeakUse )
			{
			m_cBlockPeakUse = m_cBlockUsed;
			}
		}
	else
		{
		m_cBlockUsed--;
		}
	}


VOID CRES::DBGPrintStat(  ) const
	{
	CHAR	*sz;
	
	static char *rgszName[] = {
		"FCB",
		"FUCB",
		"TDB",
		"IDB",
		"PIB",
		"SCB",
		"VER",
		};

	if ( ( sz = GetDebugEnvValue( (CHAR *)szVerbose ) ) != NULL )
		{
		DBGprintf( "%s resource %d allocated %d peak allocation.\n",
			rgszName[m_resid], m_cBlockUsed, m_cBlockPeakUse );

		OSMemoryHeapFree( sz );
		}
	}
#endif /* DEBUG */


CRES::CRES( INST *pinst, RESID resid, INT cbBlock, INT cBlocksAllocated, ERR *perr )
	:	m_crit( CLockBasicInfo( CSyncBasicInfo( szRES ), rankRES, 0 ) )
	{	
	ERR		err = JET_errSuccess;

	//	Check parameters
	
#if defined(_MIPS_) || defined(_ALPHA_) || defined(_M_PPC)
	Assert( cbBlock % 4 == 0 );
#endif

	Assert( IbAlignForAllPlatforms( cbBlock ) == cbBlock );
#ifdef PCACHE_OPTIMIZATION
	//
	//	the size of the allocated resource should be on a 32-byte boundary,
	//	for cache locality.
	//
#ifdef _WIN64
	//	UNDONE: cache alignment for 64 bit build
#else
	Assert( cbBlock == 16 || cbBlock % 32 == 0 );
#endif
#endif

	m_cbBlock = 0;
	m_cBlocksAllocated = 0;

#ifdef DEBUG
	m_cBlockUsed = 0;
	m_cBlockPeakUse = 0;
#endif

	m_cBlockAvail = 0;
	m_pbBlockAvail = NULL;
	m_cBlockCommit = 0;
	m_cBlockCommitThreshold = 0;
	m_iBlockToCommit = 0;
	m_pbPreferredThreshold = 0;
	
	m_pinst = pinst;

	//	allocate space for resources

	m_pbBlocksAllocated = static_cast<BYTE *>( PvOSMemoryPageReserve( cBlocksAllocated * cbBlock, NULL ) );

	//	if try to allocate more than zero and fail then out of memory

	if ( m_pbBlocksAllocated == NULL && cBlocksAllocated > 0 )
		{
		*perr = ErrERRCheck( JET_errOutOfMemory );
		return;
		}

	Assert( FAlignedForAllPlatforms( m_pbBlocksAllocated ) );
#ifdef PCACHE_OPTIMIZATION
	Assert( ( (ULONG) m_pbBlocksAllocated & 31 ) == 0 );
#endif

	//	Initialize other varialbes

	m_resid = resid;
	m_cbBlock = cbBlock;
	m_cBlocksAllocated = cBlocksAllocated;

	if ( resid == residVER )
		{
		m_cBlockCommitThreshold = m_cBlocksAllocated;
		m_iBlockToCommit = 0;
		}
	else
		m_pbPreferredThreshold = m_pbBlocksAllocated + m_cBlocksAllocated * m_cbBlock;


#ifdef GLOBAL_VERSTORE_MEMPOOL
	Assert( ( NULL != pinst && residVER != resid )	//	only version store not instanced
		|| ( NULL == pinst && residVER == resid ) );
#else
	Assert( NULL != pinst );						//	should be impossible -- all CRES are instanced
#endif

	*perr = JET_errSuccess;
	return;
	}


#ifdef MEM_CHECK
const _TCHAR szAssertFile[] 	= _T( "assert.txt" );

char rgszRESID[][5] =
	{
	"FCB",
	"FUCB",
	"TDB",
	"IDB",
	"PIB",
	"SCB",
	"VER"
	};
#endif  //  MEM_CHECK

CRES::~CRES( )
	{

	// nothing to do, we faild in the constructor
	// when allocating this
	if ( NULL == m_pbBlocksAllocated )
		return;

#ifdef MEM_CHECK
	//	dump stats to the debug stream

	DBGPrintStat();

	if ( g_fMemCheck )
		{
		if ( m_cbBlock < cbMemoryPage )
			{
			Assert( ( m_cBlockCommit - m_cBlockPeakUse ) * m_cbBlock <= cbMemoryPage );
			}
		else
			{
			Assert( m_cBlockCommit <= m_cBlockCommitThreshold  );
			}

		if ( ( ( NULL == m_pinst ) || 
			   ( m_pinst->m_fTermInProgress && !m_pinst->m_fTermAbruptly ) ) && 
			 m_cBlockUsed > 0 )
			{
			_TCHAR szT[80];
	
			DumpAlloc( szAssertFile );
			_stprintf( szT, _T( "%d %s not freed on resource pool destruction!" ), m_cBlockUsed, rgszRESID[m_resid] );
			EnforceSz( fFalse, szT );
			}
		}
#endif // MEM_CHECK

	Assert ( m_pbBlocksAllocated );
	OSMemoryPageDecommit( m_pbBlocksAllocated, m_cBlocksAllocated * m_cbBlock );
	OSMemoryPageFree( m_pbBlocksAllocated );
	m_pbBlocksAllocated = NULL;
	
	return;
	}


BYTE *CRES::PbAlloc( const char* szFile, unsigned long ulLine )
	{
	BYTE	*pb;

#ifdef RFS2
	switch ( m_resid )
		{
		case residFCB:
			if (!RFSAlloc( FCBAllocResource ) )
				return NULL;
			break;
		case residFUCB:
			if (!RFSAlloc( FUCBAllocResource ) )
				return NULL;
			break;
		case residTDB:
			if (!RFSAlloc( TDBAllocResource ) )
				return NULL;
			break;
		case residIDB:
			if (!RFSAlloc( IDBAllocResource ) )
				return NULL;
			break;
		case residPIB:
			if (!RFSAlloc( PIBAllocResource ) )
				return NULL;
			break;
		case residSCB:
			if (!RFSAlloc( SCBAllocResource ) )
				return NULL;
			break;
		case residVER:
			if (!RFSAlloc( VERAllocResource ) )
				return NULL;
			break;
		default:
			if (!RFSAlloc( UnknownAllocResource ) )
				return NULL;
			break;
		};
#endif

	m_crit.Enter();

	pb = m_pbBlockAvail;
	
	if ( pb != NULL )
		{
		m_cBlockAvail--;

		Assert( FAlignedForAllPlatforms( pb ) );
#ifdef PCACHE_OPTIMIZATION
#ifdef _WIN64
	//	UNDONE: cache alignment for 64 bit build
#else
		Assert( (ULONG)pb % 32 == 0 );
#endif
#endif
		m_pbBlockAvail = (BYTE *) ( (BLK*) pb)->pblkNext;

		Assert( FContains( pb ) );
		}
		
	Assert( m_cBlockCommit <= m_cBlocksAllocated );
	
	/*	commit new resource if have uncommitted available
	/**/
	if ( pb == NULL && m_cBlockCommit < m_cBlocksAllocated )
		{
		INT cBlock;

		/*	there must be at least 1 block left
		/**/

		if ( m_resid == residVER )
			{
			//	Allocate blocks circularly

			Assert( m_cbBlock > cbMemoryPage );
			cBlock = 1;
			pb = m_pbBlocksAllocated + ( m_iBlockToCommit * m_cbBlock );
			}
		else
			{
			/*	commit one pages of memory at a time
			/**/
			cBlock = ( ( ( ( ( ( m_cBlockCommit * m_cbBlock ) + cbMemoryPage - 1 )
				/ cbMemoryPage ) + 1 ) * cbMemoryPage )
				/ m_cbBlock ) - m_cBlockCommit - 1;
			Assert( cBlock > 0 && cBlock <= (LONG) ( cbMemoryPage/sizeof(BYTE *) ) );
			if ( cBlock > m_cBlocksAllocated - m_cBlockCommit )
				cBlock = m_cBlocksAllocated - m_cBlockCommit;
			
			pb = m_pbBlocksAllocated + ( m_cBlockCommit * m_cbBlock );
			}

		Assert( FAlignedForAllPlatforms( pb ) );
		
		if ( !FOSMemoryPageCommit( pb, cBlock * m_cbBlock ) )
			{
			//	UNDONE: log event.

			pb = NULL;
			}
		else
			{
			if ( m_resid == residVER )
				m_iBlockToCommit = ( m_iBlockToCommit + cBlock )
									% ( m_cBlocksAllocated + m_cBlockCommitThreshold );

			m_cBlockCommit += cBlock;

			/*	if surplus blocks, then link to resource
			/**/
			if ( cBlock > 1 )
				{
				BYTE	*pbLink		= pb + m_cbBlock;
				BYTE	*pbLinkMax	= pb + ( ( cBlock - 1 ) * m_cbBlock );

				Assert( m_pbBlockAvail == NULL );
				Assert( FAlignedForAllPlatforms( pbLink ) );
#ifdef PCACHE_OPTIMIZATION
#ifdef _WIN64
				//	UNDONE: cache alignment for 64 bit build
#else
				Assert( (ULONG)pbLink % 32 == 0 );
#endif
#endif
				m_pbBlockAvail = pbLink;
				m_cBlockAvail += cBlock - 1;

				/*	link surplus blocks into resource free list
				/**/
				for ( ; pbLink < pbLinkMax; pbLink += m_cbBlock )
					{
					Assert( FAlignedForAllPlatforms( pbLink + m_cbBlock ) );
					((BLK*)pbLink)->pblkNext = (BLK*)( pbLink + m_cbBlock );
					}
				((BLK*)pbLink)->pblkNext = NULL;
				}
			Assert( FContains( pb ) );
			}
		}
	else if ( pbNil == pb && residVER == m_resid && m_cBlockCommit == m_cBlocksAllocated )
		{
		// free list should be empty
		Assert( pbNil == m_pbBlockAvail );

		// This is simple because the block size is a multiple of the
		// page size, so we don't need to think about extra free blocks, etc.
		Assert( 0 == m_cbBlock % ::OSMemoryPageCommitGranularity() );
		pb = reinterpret_cast< BYTE* >( PvOSMemoryPageAlloc( m_cbBlock, NULL ) );
		// Valid to return NULL from this PbAlloc if unsuccessful

		if ( pbNil != pb )
			{
			Assert( ! FContains( pb ) );
			}
		}

#ifdef DEBUG
	/*	for setting break point:
	/**/
	if ( pb == NULL )
		pb = NULL;
	else
		{
		DBGUpdateStat( fTrue );

		/*	set resource space to 0xff
		/**/
		memset( pb, chCRESAllocFill, m_cbBlock );

		Assert( FAlignedForAllPlatforms( pb ) );
		}
#endif  //  DEBUG
	
	m_crit.Leave();

	InsertAlloc( pb, szFile, ulLine );
	return pb;
	}


VOID CRES::Release( BYTE *pb )
	{
	DeleteAlloc( pb );
#ifdef DEBUG
	memset( pb + sizeof(BLK), chCRESFreeFill, m_cbBlock - sizeof(BLK) );
#endif  //  DEBUG

	m_crit.Enter();

	DBGUpdateStat( fFalse );

	if ( m_resid == residVER )
		{
		// if block is outside reserve region
		if ( ! FContains( pb ) )
			{
			// decommit & return to OS
			::OSMemoryPageFree( pb );
			}
		else
			{			
			SIZE_T iBlock = ( pb - m_pbBlocksAllocated ) / m_cbBlock;

			//	if we are still within the range of threshold i.e.
			//	(m_iBlockToCommit - m_cBlockCommitThreshold) <= ibBlock < m_iBlockToCommit
			//	then we simply put it into the avail list.

			BOOL fWithinThresholdRange;
			if ( m_iBlockToCommit > m_cBlockCommitThreshold )
				{
				// regular non-wraparound case

				fWithinThresholdRange = (
					   ( m_iBlockToCommit - m_cBlockCommitThreshold ) <= iBlock
					&& iBlock < m_iBlockToCommit );
				}
			else
				{
				//	A wrap around case

				fWithinThresholdRange = (
					   ( ( m_cBlocksAllocated + m_cBlockCommitThreshold )
					   - ( m_iBlockToCommit - m_cBlockCommitThreshold ) ) <= iBlock
					|| iBlock < m_iBlockToCommit );
				}

			if ( !fWithinThresholdRange )
				{
				OSMemoryPageDecommit( pb, m_cbBlock );
				m_cBlockCommit--;
				}
			else
				{
				//	put to the head of avail list for next use.

				BLK *pblk = (BLK *) pb;
				BLK **ppblk = (BLK **) &m_pbBlockAvail;
				pblk->pblkNext = *ppblk;
				*ppblk = pblk;

				m_cBlockAvail++;
				}
			}
		}
	else if ( pb >= m_pbPreferredThreshold )
		{
		Assert( m_cbBlock < cbMemoryPage );
		Assert( pb < PbMax() );

		// We need to ensure that we first re-use resources below the
		// preferred threshold.

		BYTE	*pbT;
		BYTE	*pbLast = NULL;

		for ( pbT = m_pbBlockAvail;
			  pbT != NULL &&  pbT < m_pbPreferredThreshold;
			  pbT = (BYTE *)((BLK*)pbT)->pblkNext )
			{
			pbLast = pbT;
			}
			
		((BLK*)pb)->pblkNext = (BLK*)pbT;
		
		if ( pbLast != NULL )
			{
			Assert( ((BLK* )pbLast)->pblkNext == (BLK*)pbT );
			((BLK*)pbLast)->pblkNext = (BLK*)pb;
			}
		else
			{
			Assert( m_pbBlockAvail == pbT );
			m_pbBlockAvail = pb;
			}

		m_cBlockAvail++;	
		}
	else if ( pb != m_pbBlockAvail )
		{
		// Memory freed is below the preferred threshold, so just put it at
		// the head of the free list.

		((BLK*)pb)->pblkNext = (BLK*)m_pbBlockAvail;
		m_pbBlockAvail = pb;

		m_cBlockAvail++;
		}
	else
		{
		//	prevent double-free
		FireWall();
		}
	
	m_crit.Leave();
	}


#ifdef MEM_CHECK

#define icalMax 100001

struct CAL
	{
	VOID		*pv;
	ULONG		ulLine;
	const char	*szFile;
	};

CAL rgcal[icalMax] = { { NULL, 0, 0 } };
CCriticalSection critCAL( CLockBasicInfo( CSyncBasicInfo( szCALGlobal ), rankCALGlobal, 0 ) );

LONG CRES::LHash( const void * const pv )
	{
	return (LONG)(( DWORD_PTR( pv ) / m_cbBlock ) % icalMax);
	}

VOID CRES::DumpAlloc( const char* szDumpFile )
	{
	if ( !g_fMemCheck )
		{
		return;
		}
	INT		ical;

	CPRINTFFILE cprintf( szDumpFile );
	
	cprintf( "    Address             File(Line)\n" );
    cprintf( "    ==================  ==============================================================\n" );

	critCAL.Enter();
	for ( ical = 0; ical < icalMax; ical++ )
		{
		if ( rgcal[ical].pv == NULL )
			{
			continue;
			}
		else
			{
			cprintf(	"    0x%016I64X  %s(%d)\n",
						QWORD( rgcal[ical].pv ),
						rgcal[ical].szFile,
						rgcal[ical].ulLine );
			}
		}
	critCAL.Leave();
	}

VOID CRES::InsertAlloc( void* pv, const char* szFile, unsigned long ulLine )
	{
	if ( !g_fMemCheck )
		{
		return;
		}
	INT		icalHash 	= LHash( pv );
	INT		ical 		= icalHash;

	/*	do not track failed allocations
	/**/
	if ( pv == NULL )
		return;

	critCAL.Enter();
	do
		{
		if ( rgcal[ical].pv == NULL )
			{
			rgcal[ical].pv = pv;
			rgcal[ical].ulLine = ulLine;
			rgcal[ical].szFile = szFile;
			critCAL.Leave();
			return;
			}
		if ( ++ical == icalMax )
			{
			ical = 0;
			}
		}
	while ( ical != icalHash );
	critCAL.Leave();
	AssertSz( fFalse, "Insufficient entries to track current block allocations" );
	DumpAlloc( szAssertFile );
	}

VOID CRES::DeleteAlloc( void* pv )
	{
	if ( !g_fMemCheck )
		{
		return;
		}
	INT		icalHash 	= LHash( pv );
	INT		ical 		= icalHash;

	if ( pv == NULL )
		{
		return;
		}

	do
		{
		if ( rgcal[ical].pv == pv )
			{
			rgcal[ical].pv = NULL;
			return;
			}
		if ( ++ical == icalMax )
			{
			ical = 0;
			}
		}
	while ( ical != icalHash );
	AssertSz( fFalse, "Attempt to Release a bad block" );
	}

#endif  //  MEM_CHECK
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ese98\src\ese\bt.cxx ===
#include "std.hxx"
#include "_bt.hxx"

//	general directives
//	always correct bmCurr and csr.DBTime on loss of physical currency
//	unless not needed because of loc in which case, reset bmCurr

//	*****************************************************
//	internal function prototypes
//
ERR	ErrBTIIRefresh( FUCB *pfucb, LATCH latch );
ERR ErrBTDelete( FUCB *pfucb, const BOOKMARK& bm );
INT CbBTIFreeDensity( const FUCB *pfucb );
VOID BTIComputePrefix( FUCB *pfucb, CSR *pcsr, const KEY& key, KEYDATAFLAGS	*pkdf );
BOOL FBTIAppend( const FUCB *pfucb, CSR *pcsr, ULONG cbReq, const BOOL fUpdateUncFree = fTrue );
BOOL FBTISplit( const FUCB *pfucb, CSR *pcsr, const ULONG cbReq, const BOOL fUpdateUncFree = fTrue );
ERR ErrBTISplit(
					FUCB * const pfucb,
					KEYDATAFLAGS * const pkdf,
					const DIRFLAG	dirflagT,
					const RCEID rceid1,
					const RCEID rceid2,
					RCE * const prceReplace,
					const INT cbDataOld,
					const VERPROXY * const pverproxy );
VOID BTISplitSetCbAdjust(
					SPLIT 				*psplit,
					FUCB				*pfucb,
					const KEYDATAFLAGS& kdf,
					const RCE			*prce1,
					const RCE			*prce2 );
VOID BTISplitSetCursor( FUCB *pfucb, SPLITPATH *psplitPathLeaf );
VOID BTIPerformSplit( FUCB *pfucb, SPLITPATH *psplitPathLeaf, KEYDATAFLAGS *pkdf, DIRFLAG dirflag );
LOCAL VOID BTIComputePrefixAndInsert( FUCB *pfucb, CSR *pcsr, const KEYDATAFLAGS& kdf );
VOID BTICheckSplitLineinfo( FUCB *pfucb, SPLIT *psplit, const KEYDATAFLAGS& kdf );
VOID BTICheckSplits( FUCB *pfucb, SPLITPATH *psplitPathLeaf, KEYDATAFLAGS *pkdf, DIRFLAG dirflag );
LOCAL VOID BTICheckSplitFlags( const SPLIT *psplit );
VOID BTICheckOneSplit( FUCB *pfucb, SPLITPATH *psplitPathLeaf, KEYDATAFLAGS *pkdf, DIRFLAG dirflag );
LOCAL VOID BTIInsertPgnoNewAndSetPgnoSplit( FUCB *pfucb, SPLITPATH *psplitPath );
BOOL FBTIUpdatablePage( const CSR& csr );
LOCAL VOID BTISplitFixSiblings( SPLIT *psplit );
LOCAL VOID BTIInsertPgnoNew ( FUCB *pfucb, SPLITPATH *psplitPath );
VOID BTISplitMoveNodes( FUCB *pfucb, SPLIT *psplit, KEYDATAFLAGS *pkdf, DIRFLAG dirflag );
VOID BTISplitBulkCopy( FUCB *pfucb, SPLIT *psplit, INT ilineStart, INT clines );
VOID BTISplitBulkDelete( CSR * pcsr, INT clines );
const LINEINFO *PlineinfoFromIline( SPLIT *psplit, INT iline );
VOID BTISplitSetPrefixInSrcPage( FUCB *pfucb, SPLIT *psplit );
LOCAL ERR ErrBTIGetNewPages( FUCB *pfucb, SPLITPATH *psplitPathLeaf );
VOID BTISplitRevertDbtime( SPLITPATH *psplitPathLeaf );
VOID BTIMergeRevertDbtime( MERGEPATH *pmergePathLeaf );
LOCAL VOID BTISplitReleaseUnneededPages( INST *pinst, SPLITPATH **psplitPathLeaf );
LOCAL ERR ErrBTISplitUpgradeLatches( const IFMP ifmp, SPLITPATH * const psplitPathLeaf );
LOCAL VOID BTISplitSetLgpos( SPLITPATH *psplitPathLeaf, const LGPOS& lgpos );
VOID BTIReleaseOneSplitPath( INST *pinst, SPLITPATH *psplitPath );
VOID BTIReleaseSplitPaths( INST *pinst, SPLITPATH *psplitPath );
VOID BTIReleaseMergePaths( MERGEPATH *pmergePathLeaf );
LOCAL VOID BTISplitCheckPath( SPLITPATH *psplitPathLeaf );

ERR	ErrBTINewMergePath( MERGEPATH **ppmergePath );
LOCAL ERR ErrBTICreateMergePath( FUCB *pfucb, const BOOKMARK& bm, MERGEPATH **ppmergePath );
						   
ERR	ErrBTINewSplitPath( SPLITPATH **ppsplitPath );
ERR ErrBTICreateSplitPath( FUCB				*pfucb,
						   const BOOKMARK&	bm,
						   SPLITPATH		**ppsplitPath );
						   
ERR	ErrBTICreateSplitPathAndRetryOper( FUCB 			* const pfucb,
									   const KEYDATAFLAGS * const pkdf,
									   SPLITPATH 		**ppsplitPath,
									   DIRFLAG	* const pdirflag,
									   const RCEID rceid1,
									   const RCEID rceid2,
									   const RCE * const prceReplace,
									   const VERPROXY * const pverproxy );
ERR	ErrBTISelectSplit( FUCB *pfucb, SPLITPATH *psplitPath, KEYDATAFLAGS *pkdf, DIRFLAG dirflag );
ERR	ErrBTISplitAllocAndCopyPrefix( const KEY &key, DATA *pdata );
ERR	ErrBTISplitAllocAndCopyPrefixes( FUCB *pfucb, SPLIT *psplit );
VOID BTISeekSeparatorKey( SPLIT *psplit, FUCB *pfucb );
ERR ErrBTISplitComputeSeparatorKey( SPLIT *psplit, FUCB *pfucb );
LOCAL VOID BTISelectPrefix( const LINEINFO 	*rglineinfo, 
							INT 			clines, 
							PREFIXINFO		*pprefixinfo );
LOCAL VOID BTISelectPrefixes( SPLIT *psplit, INT ilineSplit );
VOID BTISplitSetPrefixes( SPLIT *psplit );
VOID BTISetPrefix( LINEINFO *rglineinfo, INT clines, const PREFIXINFO& prefixinfo );
VOID BTISplitCalcUncFree( SPLIT *psplit );
VOID BTISelectAppend( SPLIT *psplit, FUCB *pfucb );
VOID BTISelectVerticalSplit( SPLIT *psplit, FUCB *pfucb );
VOID BTISelectRightSplit( SPLIT *psplit, FUCB *pfucb );
BOOL FBTISplitCausesNoOverflow( SPLIT *psplit, INT cLineSplit );
VOID BTIRecalcWeightsLE( SPLIT *psplit );
VOID BTISelectSplitWithOperNone( SPLIT *psplit, FUCB *pfucb );
ERR	ErrBTINewSplit( FUCB *pfucb, SPLITPATH *psplitPath, KEYDATAFLAGS *pkdf, DIRFLAG dirflag );
ERR ErrBTINewMerge( MERGEPATH *pmergePathLeaf );
VOID BTIReleaseSplit( INST *pinst, SPLIT *psplit );
VOID BTIReleaseMergeLineinfo( MERGE *pmerge );
VOID BTIReleaseMerge( MERGE *pmerge );
LOCAL ULONG CbBTIMaxSizeOfNode( const FUCB * const pfucb, const CSR * const pcsr );
INT IlineBTIFrac( FUCB *pfucb, DIB *pdib );

ERR	ErrBTISelectMerge(
	FUCB	*pfucb,
	MERGEPATH *pmergePathLeaf,
	const BOOKMARK& bm,
	BOOKMARK *pbmNext,
	RECCHECK * const preccheck );
ERR ErrBTIMergeCollectPageInfo( FUCB *pfucb, MERGEPATH *pmergePathLeaf, RECCHECK * preccheck );
ERR ErrBTIMergeLatchSiblingPages( FUCB *pfucb, MERGEPATH * const pmergePathLeaf );
VOID BTICheckMergeable( FUCB *pfucb, MERGEPATH *pmergePath );
BOOL FBTIOverflowOnReplacingKey( FUCB 					*pfucb,
								 MERGEPATH				*pmergePath,
								 const KEYDATAFLAGS& 	kdfSep );
ERR ErrBTIMergeCopySeparatorKey( MERGEPATH 	*pmergePath, 
								 MERGE		*pmergeLeaf,
								 FUCB 		*pfucb );

ERR ErrBTISelectMergeInternalPages( FUCB *pfucb, MERGEPATH * const pmergePathLeaf );
ERR  ErrBTIMergeOrEmptyPage( FUCB *pfucb, MERGEPATH *pmergePathLeaf );
VOID BTIPerformMerge( FUCB *pfucb, MERGEPATH *pmergePathLeaf );
VOID BTIPerformOneMerge( FUCB *pfucb, 
						 MERGEPATH *pmergePath, 
						 MERGE *pmergeLeaf );
VOID BTIChangeKeyOfPagePointer( FUCB *pfucb, CSR *pcsr, const KEY& key );
LOCAL ERR ErrBTIMergeUpgradeLatches( const IFMP ifmp, MERGEPATH * const pmergePathLeaf );
VOID BTIMergeReleaseUnneededPages( MERGEPATH *pmergePathLeaf );
VOID BTIMergeSetLgpos( MERGEPATH *pmergePathLeaf, const LGPOS& lgpos );
VOID BTIMergeReleaseLatches( MERGEPATH *pmergePathLeaf );
VOID BTIReleaseEmptyPages( FUCB *pfucb, MERGEPATH *pmergePathLeaf );
VOID BTIMergeDeleteFlagDeletedNodes( FUCB *pfucb, MERGEPATH *pmergePath );
VOID BTIMergeFixSiblings( INST *pinst, MERGEPATH *pmergePath );
VOID BTIMergeMoveNodes( FUCB *pfucb, MERGEPATH *pmergePath );

VOID BTICheckMerge( FUCB *pfucb, MERGEPATH *pmergePathLeaf );
VOID BTICheckMergeLeaf( FUCB *pfucb, MERGEPATH *pmergePath );
VOID BTICheckMergeInternal( FUCB 		*pfucb, 
							MERGEPATH 	*pmergePath, 
							MERGE		*pmergeLeaf );

//	single page cleanup routines
//
LOCAL ERR ErrBTISinglePageCleanup( FUCB *pfucb, const BOOKMARK& bm );
LOCAL ERR ErrBTISPCCollectLeafPageInfo(
	FUCB		*pfucb, 
	CSR			*pcsr, 
	LINEINFO	**plineinfo,
	RECCHECK	* const preccheck,
	BOOL		*pfEmptyPage,
	BOOL		*pfExistsFlagDeletedNodeWithActiveVersion,
	BOOL		*pfLessThanOneThirdFull );
LOCAL ERR ErrBTISPCDeleteNodes( FUCB *pfucb, CSR *pcsr, LINEINFO *rglineinfo );
ERR ErrBTISPCSeek( FUCB *pfucb, const BOOKMARK& bm );
BOOL FBTISPCCheckMergeable( FUCB *pfucb, CSR *pcsrRight, LINEINFO *rglineinfo );
			
//	debug routines
//
VOID AssertBTIVerifyPgnoSplit( FUCB *pfucb, SPLITPATH *psplitPath );
VOID AssertBTIBookmarkSaved( const FUCB *pfucb );

//	move to node
//
INT CbNDCommonPrefix( FUCB *pfucb, CSR *pcsr, const KEY& key );

//  system parameters

extern BOOL	g_fImprovedSeekShortcut;

//  HACK:  reference to BF internal

extern TABLECLASS tableclassNameSetMax;

PERFInstanceG<> cBTSeekShortCircuit;
PM_CEF_PROC LBTSeekShortCircuitCEFLPv;
LONG LBTSeekShortCircuitCEFLPv( LONG iInstance, VOID *pvBuf )
	{
	cBTSeekShortCircuit.PassTo( iInstance, pvBuf );
	return 0;
	}

PERFInstanceG<> cBTUnnecessarySiblingLatch;
PM_CEF_PROC LBTUnnecessarySiblingLatchCEFLPv;
LONG LBTUnnecessarySiblingLatchCEFLPv( LONG iInstance, VOID *pvBuf )
	{
	cBTUnnecessarySiblingLatch.PassTo( iInstance, pvBuf );
	return 0;
	}

PERFInstanceG<> cBTNext;
PM_CEF_PROC LBTNextCEFLPv;
LONG LBTNextCEFLPv( LONG iInstance, VOID *pvBuf )
	{
	cBTNext.PassTo( iInstance, pvBuf );
	return 0;
	}

PERFInstanceG<> cBTPrev;
PM_CEF_PROC LBTPrevCEFLPv;
LONG LBTPrevCEFLPv( LONG iInstance, VOID* pvBuf )
	{
	cBTPrev.PassTo( iInstance, pvBuf );
	return 0;
	}

PERFInstanceG<> cBTSeek;
PM_CEF_PROC LBTSeekCEFLPv;
LONG LBTSeekCEFLPv( LONG iInstance, VOID *pvBuf )
	{
	cBTSeek.PassTo( iInstance, pvBuf );
	return 0;
	}

PERFInstanceG<> cBTAppend;
PM_CEF_PROC LBTAppendCEFLPv;
LONG LBTAppendCEFLPv( LONG iInstance, VOID *pvBuf )
	{
	cBTSeek.PassTo( iInstance, pvBuf );
	return 0;
	}

PERFInstanceG<> cBTInsert;
PM_CEF_PROC LBTInsertCEFLPv;
LONG LBTInsertCEFLPv( LONG iInstance, VOID *pvBuf )
	{
	cBTInsert.PassTo( iInstance, pvBuf );
	return 0;
	}

PERFInstanceG<> cBTReplace;
PM_CEF_PROC LBTReplaceCEFLPv;
LONG LBTReplaceCEFLPv( LONG iInstance, VOID *pvBuf )
	{
	cBTReplace.PassTo( iInstance, pvBuf );
	return 0;
	}

PERFInstanceG<> cBTFlagDelete;
PM_CEF_PROC LBTFlagDeleteCEFLPv;
LONG LBTFlagDeleteCEFLPv( LONG iInstance, VOID *pvBuf )
	{
	cBTFlagDelete.PassTo( iInstance, pvBuf );
	return 0;
	}

PERFInstanceG<> cBTDelete;
PM_CEF_PROC LBTDeleteCEFLPv;
LONG LBTDeleteCEFLPv( LONG iInstance, VOID *pvBuf )
	{
	cBTDelete.PassTo( iInstance, pvBuf );
	return 0;
	}

PERFInstanceG<> cBTAppendSplit;
PM_CEF_PROC LBTAppendSplitCEFLPv;
LONG LBTAppendSplitCEFLPv( LONG iInstance, VOID *pvBuf )
	{
	cBTAppendSplit.PassTo( iInstance, pvBuf );
	return 0;
	}

PERFInstanceG<> cBTRightSplit;
PM_CEF_PROC LBTRightSplitCEFLPv;
LONG LBTRightSplitCEFLPv( LONG iInstance, VOID *pvBuf )
	{
	cBTRightSplit.PassTo( iInstance, pvBuf );
	return 0;
	}

PERFInstanceG<> cBTVerticalSplit;
PM_CEF_PROC LBTVerticalSplitCEFLPv;
LONG LBTVerticalSplitCEFLPv( LONG iInstance, VOID *pvBuf )
	{
	cBTVerticalSplit.PassTo( iInstance, pvBuf );
	return 0;
	}

PM_CEF_PROC LBTSplitCEFLPv;
LONG LBTSplitCEFLPv( LONG iInstance, VOID *pvBuf )
	{
	if ( NULL != pvBuf )
		{
		*(LONG*)pvBuf = cBTAppendSplit.Get( iInstance ) + cBTRightSplit.Get( iInstance ) + cBTVerticalSplit.Get( iInstance );
		}
	return 0;
	}

PERFInstanceG<> cBTEmptyPageMerge;
PM_CEF_PROC LBTEmptyPageMergeCEFLPv;
LONG LBTEmptyPageMergeCEFLPv( LONG iInstance, VOID *pvBuf )
	{
	cBTEmptyPageMerge.PassTo( iInstance, pvBuf );
	return 0;
	}

PERFInstanceG<> cBTRightMerge;
PM_CEF_PROC LBTRightMergeCEFLPv;
LONG LBTRightMergeCEFLPv( LONG iInstance, VOID *pvBuf )
	{
	cBTRightMerge.PassTo( iInstance, pvBuf );
	return 0;
	}

PERFInstanceG<> cBTPartialMerge;
PM_CEF_PROC LBTPartialMergeCEFLPv;
LONG LBTPartialMergeCEFLPv( LONG iInstance, VOID *pvBuf )
	{
	cBTPartialMerge.PassTo( iInstance, pvBuf );
	return 0;
	}

PM_CEF_PROC LBTMergeCEFLPv;
LONG LBTMergeCEFLPv( LONG iInstance, VOID *pvBuf )
	{
	if ( NULL != pvBuf )
		{
		*(LONG*)pvBuf = cBTEmptyPageMerge.Get( iInstance ) + cBTRightMerge.Get( iInstance ) + cBTPartialMerge.Get( iInstance );
		}
	return 0;
	}

//	UNDONE: Fully add support for this counter
PERFInstanceG<> cBTFailedWriteLatchForSPC;
PM_CEF_PROC LBTFailedWriteLatchForSPC;
LONG LBTFailedWriteLatchForSPC( LONG iInstance, VOID *pvBuf )
	{
	cBTFailedWriteLatchForSPC.PassTo( iInstance, pvBuf );
	return 0;
	}



//	******************************************************
//	BTREE API ROUTINES
//


//	******************************************************
//	Open/Close operations
//

//	opens a cursor on given fcb [BTree]
//	uses defer-closed cursor, if possible
//	given FCB must already have a cursor on it
//		which will not be closed while this operation is
//		in progress
//	
ERR	ErrBTOpen( PIB *ppib, FCB *pfcb, FUCB **ppfucb, BOOL fAllowReuse )
	{
	ERR		err;
	FUCB 	*pfucb;

	Assert( pfcb != pfcbNil );
	Assert( pfcb->FInitialized() );

	// In most cases, we should reuse a deferred-closed FUCB.  The one
	// time we don't want to is if we're opening a space cursor.
	if ( fAllowReuse )
		{
		// cannabalize deferred closed cursor
		for ( pfucb = ppib->pfucbOfSession;
			pfucb != pfucbNil;
			pfucb = pfucb->pfucbNextOfSession )
			{
			if ( FFUCBDeferClosed( pfucb ) && !FFUCBNotReuse( pfucb ) )
				{
				Assert( !FFUCBSpace( pfucb ) );		// Space cursors are never defer-closed.

				// Secondary index FCB may have been deallocated by
				// rollback of CreateIndex or cleanup of DeleteIndex
				Assert( pfucb->u.pfcb != pfcbNil || FFUCBSecondary( pfucb ) );
				if ( pfucb->u.pfcb == pfcb )
					{
					const BOOL	fVersioned	= FFUCBVersioned( pfucb );

					Assert( pfcbNil != pfucb->u.pfcb );
					Assert( ppib->level > 0 );
					Assert( pfucb->levelOpen <= ppib->level );
				
					//	Reset all used flags. Keep Updatable (fWrite) flag
					//
					FUCBResetFlags( pfucb );
					Assert( !FFUCBDeferClosed( pfucb ) );

					FUCBResetPreread( pfucb );

					//	must persist Versioned flag
					Assert( !FFUCBVersioned( pfucb ) );		//	got reset by FUCBResetFlags()
					if ( fVersioned )
						FUCBSetVersioned( pfucb );

					Assert( !FFUCBUpdatable( pfucb ) );
					if ( !rgfmp[ pfcb->Ifmp() ].FReadOnlyAttach() )
						{
						FUCBSetUpdatable( pfucb );
						}

					*ppfucb = pfucb;

					return JET_errSuccess;
					}
				}
			}
		}
	else
		pfucb = pfucbNil;		// Initialise for FUCBOpen() below.

	Assert( pfucbNil == pfucb );
	CallR( ErrFUCBOpen( ppib, 
					   pfcb->Ifmp(),
					   &pfucb ) ); 
	
	//	link FCB
	//
	pfcb->Link( pfucb );
	*ppfucb = pfucb;

	return JET_errSuccess;
	}

//	opens a cursor on given FCB on behalf of another thread.
//	uses defer-closed cursor, if possible
ERR	ErrBTOpenByProxy( PIB *ppib, FCB *pfcb, FUCB **ppfucb, const LEVEL level )
	{
	ERR		err;
	FUCB 	*pfucb;

	Assert( ppib->critTrx.FOwner() );

	Assert( level > 0 );
	Assert( pfcb != pfcbNil );
	Assert( pfcb->FInitialized() );

	// This routine only called by concurrent create index to obtain a cursor
	// on a secondary index tree.
	Assert( pfcb->FTypeSecondaryIndex() );
	Assert( pfcb->PfcbTable() == pfcbNil );	// FCB not yet linked into table's index list.

	pfcb->Lock();
	
	for ( pfucb = pfcb->Pfucb();
		pfucb != pfucbNil;
		pfucb = pfucb->pfucbNextOfFile )
		{
		if ( pfucb->ppib == ppib )
			{
			const BOOL	fVersioned	= FFUCBVersioned( pfucb );
			
			// If there are any cursors on this tree at all for this user, then
			// it must be deferred closed, because we only use the cursor to
			// insert into the version store, then close it.
			Assert( FFUCBDeferClosed( pfucb ) );
			
			Assert( !FFUCBNotReuse( pfucb ) );
			Assert( !FFUCBSpace( pfucb ) );
			Assert( FFUCBIndex( pfucb ) );
			Assert( FFUCBSecondary( pfucb ) );
			Assert( pfucb->u.pfcb == pfcb );
			Assert( ppib->level > 0 );
			Assert( pfucb->levelOpen > 0 );

			// Temporarily set levelOpen to 0 to ensure
			// that ErrIsamRollback() doesn't close the
			// FUCB on us.
			pfucb->levelOpen = 0;
				
			// Reset all used flags. Keep Updatable (fWrite) flag
			//
			FUCBResetFlags( pfucb );
			Assert( !FFUCBDeferClosed( pfucb ) );

			FUCBResetPreread( pfucb );

			//	must persist Versioned flag
			Assert( !FFUCBVersioned( pfucb ) );		//	got reset by FUCBResetFlags()
			if ( fVersioned )
				FUCBSetVersioned( pfucb );

			// Set fIndex/fSecondary flags to ensure FUCB
			// doesn't get closed by ErrIsamRollback(), then
			// set proper levelOpen.
			FUCBSetIndex( pfucb );
			FUCBSetSecondary( pfucb );
			pfucb->levelOpen = level;
			
			Assert( !rgfmp[ pfcb->Ifmp() ].FReadOnlyAttach() );
			FUCBSetUpdatable( pfucb );

			pfcb->Unlock();

			*ppfucb = pfucb;

			return JET_errSuccess;
			}
		}

	pfcb->Unlock();

	Assert( pfucbNil == pfucb );
	Assert( level > 0 );
	CallR( ErrFUCBOpen( ppib, 
					   pfcb->Ifmp(),
					   &pfucb,
					   level ) );

	// Must have these flags set BEFORE linking into session list to
	// ensure ErrIsamRollback() doesn't close the FUCB prematurely.
	Assert( FFUCBIndex( pfucb ) );
	Assert( FFUCBSecondary( pfucb ) );
	
	//	link FCB
	//
	pfcb->Link( pfucb );
	
	*ppfucb = pfucb;

	return JET_errSuccess;
	}


//	closes cursor at BT level
//	releases BT level resources
//
VOID BTClose( FUCB *pfucb )
	{
	INST *pinst = PinstFromPfucb( pfucb );

	FUCBAssertNoSearchKey( pfucb );

	// Current secondary index should already have been closed.
	Assert( !FFUCBCurrentSecondary( pfucb ) );

	//	release memory used by bookmark buffer
	//
	BTReleaseBM( pfucb );
	
	if ( Pcsr( pfucb )->FLatched() )
		{
		if( pfucb->pvRCEBuffer )
			{
			OSMemoryHeapFree( pfucb->pvRCEBuffer );
			pfucb->pvRCEBuffer = NULL;
			}
		Pcsr( pfucb )->ReleasePage( pfucb->u.pfcb->FNoCache() );
		}
	
	Assert( pfucb->u.pfcb != pfcbNil );
	if ( pinst->m_plog->m_fRecovering && 
		 pinst->m_plog->m_ptablehfhash != NULL &&
		 pfucb == pinst->m_plog->m_ptablehfhash->PfucbGet( pfucb->ifmp, 
	 											PgnoFDP( pfucb ), 
	 											pfucb->ppib->procid, 
	 											FFUCBSpace( pfucb ) ) )
		{
		//	delete reference to FUCB from hash table
		//
		pinst->m_plog->m_ptablehfhash->Delete( pfucb );
		}

	//	if cursor created version,
	//		defer close until commit to transaction level 0
	//		since rollback needs cursor
	//
	if ( pfucb->ppib->level > 0 && FFUCBVersioned( pfucb ) )
		{
		Assert( !FFUCBSpace( pfucb ) );		// Space operations not versioned.
		FUCBSetDeferClose( pfucb );
		}
	else
		{
		FCB *pfcb = pfucb->u.pfcb;

		//	reset FCB flags associated with this cursor
		//
		if ( FFUCBDenyRead( pfucb ) )
			{
			pfcb->ResetDomainDenyRead();
			}
		if ( FFUCBDenyWrite( pfucb ) )
			{
			pfcb->ResetDomainDenyWrite();
			}

		if ( !pfcb->FInitialized() )
			{

			//	we own the FCB (we're closing because the FCB was created during 
			//		a DIROpen() of a DIRCreateDirectory() or because an error 
			//		occurred during FILEOpenTable())

			//	unlink the FUCB from the FCB without moving the FCB to the
			//		avail LRU list (this prevents the FCB from being purged)

			FCBUnlinkWithoutMoveToAvailList( pfucb );

			//	synchronously purge the FCB

			pfcb->PrepareForPurge();
			pfcb->Purge();
			}
		else if ( pfcb->FTypeTable() )
			{

			//	only table FCBs can be moved to the avail-LRU list

			//	unlink the FUCB from the FCB and place the FCB in the avail-LRU
			//		list so it can be used or purged later

			FCBUnlink( pfucb );
			}
		else
			{

			//	all other types of FCBs will not be allowed in the avail-LRU list
			//
			//	NOTE: these FCBs must be purged manually!

			//	possible reasons why we are here:
			//		- we were called from ErrFILECloseTable() and have taken the 
			//			special temp-table path
			//		- we are closing a sort FCB
			//		- ???
			//
			//	NOTE: database FCBs will never be purged because they are never
			//			available (PgnoFDP() == pgnoSystemRoot); these FCBs will
			//			be cleaned up when the database is detached or the instance
			//			is closed
			//	NOTE: sentinel FCBs will never be purged because they are never
			//			available either (FTypeSentinel()); these FCBs will be
			//			purged by version cleanup

			FCBUnlinkWithoutMoveToAvailList( pfucb );
			}

		//	close the FUCB
		
		FUCBClose( pfucb );
		}
	}


//	******************************************************
//	retrieve/release operations
//

//	UNDONE: INLINE the following functions

//	gets node in pfucb->kdfCurr
//	refreshes currency to point to node
//	if node is versioned get correct version from the version store
//
ERR ErrBTGet( FUCB *pfucb )
	{
	ERR			err;
	const BOOL	fBookmarkPreviouslySaved	= pfucb->fBookmarkPreviouslySaved;
	
	Call( ErrBTIRefresh( pfucb ) );
	CallS( err );
	Assert( Pcsr( pfucb )->FLatched() );

	BOOL	fVisible;
	err = ErrNDVisibleToCursor( pfucb, &fVisible );
	if ( err < 0 )
		{
		BTUp( pfucb );
		}
	else if ( !fVisible )
		{
		BTUp( pfucb );
		err = ErrERRCheck( JET_errRecordDeleted );
		}
	else
		{
		//	if this flag was FALSE when we first came into
		//	this function, it means the bookmark has yet
		//	to be saved (so leave it to FALSE so that
		//	BTRelease() will know to save it)
		//	if this flag was TRUE when we first came into
		//	this function, it means that we previously
		//	saved the bookmark already, so no need to
		//	re-save it (if NDGet() was called in the call
		//	to ErrBTIRefresh() above, it would have set
		//	the flag to FALSE, which is why we need to
		//	set it back to TRUE here)
		pfucb->fBookmarkPreviouslySaved = fBookmarkPreviouslySaved;
		}

HandleError:
	Assert( err >= 0 || !Pcsr( pfucb )->FLatched() );
	return err;
	}


//	releases physical currency, 
//	save logical currency
//	then, unlatch page
//
ERR ErrBTRelease( FUCB	*pfucb )
	{
	ERR	err = JET_errSuccess;

	if ( Pcsr( pfucb )->FLatched() )
		{
		if ( !pfucb->fBookmarkPreviouslySaved )
			{
			err = ErrBTISaveBookmark( pfucb );		
			}
		if ( err >= JET_errSuccess )
			{
			AssertBTIBookmarkSaved( pfucb );
			}

		// release page anyway, return previous error
		Pcsr( pfucb )->ReleasePage( pfucb->u.pfcb->FNoCache() );
		if( NULL != pfucb->pvRCEBuffer )
			{
			OSMemoryHeapFree( pfucb->pvRCEBuffer );
			pfucb->pvRCEBuffer = NULL;
			}
		}

	//	We have touched, no longer need to touch again.
	//
	pfucb->fTouch = fFalse;

#ifdef DEBUG
	pfucb->kdfCurr.Invalidate();
#endif	//	DEBUG

	return err;
	}


//	saves given bookmark in cursor 
//	and resets physical currency
//
ERR	ErrBTDeferGotoBookmark( FUCB *pfucb, const BOOKMARK& bm, BOOL fTouch )
	{
	ERR		err;
	
	CallR( ErrBTISaveBookmark( pfucb, bm, fTouch ) );
	BTUp( pfucb );

	return err;
	}

	
//	saves logical currency -- bookmark only
//	must be called before releasing physical currency
//	CONSIDER: change callers to not ask for bookmarks if not needed
//	CONSIDER: simplify by invalidating currency on resource allocation failure
//
//	tries to save primary key [or data] in local cache first
//	since it has higher chance of fitting
//	and in many cases we can refresh currency using just the primary key
//	bookmark save operation should be after all resources are allocated,
//	so resource failure would still leave previous bm valid
//
ERR ErrBTISaveBookmark( FUCB *pfucb, const BOOKMARK& bm, BOOL fTouch )
	{
	const UINT	cbKey	= bm.key.Cb();
	const UINT	cbData	= bm.data.Cb();
	UINT	cbReq;
	BOOL	fUnique		=  FFUCBUnique( pfucb );
	BOOL	fKeyLocal	= fFalse;
	BOOL	fDataLocal	= fFalse;

	Assert( !fUnique || pfucb->bmCurr.data.FNull() );
	Assert( NULL == bm.key.suffix.Pv() || bm.key.suffix.Pv() != pfucb->bmCurr.key.suffix.Pv() );
	Assert( NULL == bm.key.prefix.Pv() || bm.key.prefix.Pv() != pfucb->bmCurr.key.prefix.Pv() );
	Assert( NULL == bm.data.Pv() || bm.data.Pv() != pfucb->bmCurr.data.Pv() );
		
	//	if tree does not allow duplicates
	//	store only key
	//
	cbReq = cbKey;
	if ( !fUnique )
		{
		cbReq += cbData;
		}

	//	assess key and data placement
	//
	if ( cbReq <= cbBMCache )
		{
		fKeyLocal	= fTrue;
		fDataLocal	= fTrue;
		cbReq = 0;
		}
	else if ( cbData <= cbBMCache && !fUnique )
		{
		fDataLocal = fTrue;
		Assert( cbReq >= cbData );
		cbReq -= cbData;
		}
	else if ( cbKey <= cbBMCache )
		{
		fKeyLocal = fTrue;
		Assert( cbReq >= cbKey );
		cbReq -= cbKey;
		}

	const UINT	fracIncrease	= 2;

	//	if we need more memory than allocated buffer, allocate more
	//	if  we have allocated way too much, free some
	//
	if ( cbReq > pfucb->cbBMBuffer ||
		 cbReq < pfucb->cbBMBuffer / ( fracIncrease * 2 ) )
		{
		UINT	cbAlloc = cbReq > pfucb->cbBMBuffer ?
								cbReq * fracIncrease : 
								pfucb->cbBMBuffer / fracIncrease;
		Assert( cbAlloc >= cbReq );

		VOID	*pvTemp = NULL;

		if ( cbAlloc > 0 )
			{
			pvTemp = PvOSMemoryHeapAlloc( cbAlloc );
			if ( pvTemp == NULL )
				{
				return ErrERRCheck( JET_errOutOfMemory );
				}		
			}

		Assert( pvTemp != NULL || cbAlloc == 0 );
		if ( pfucb->cbBMBuffer > 0 )
			{
			OSMemoryHeapFree( pfucb->pvBMBuffer );
			}
		pfucb->pvBMBuffer = pvTemp;
		pfucb->cbBMBuffer = cbAlloc;
		Assert( cbAlloc >= cbReq );
		}

	//	now we are ready to copy the bookmark
	//	since we are guaranteed  not to fail
	//
	//	copy key
	//
	pfucb->bmCurr.key.Nullify();
	if ( fKeyLocal )
		{
		Assert( cbKey <= cbBMCache );
		pfucb->bmCurr.key.suffix.SetPv( pfucb->rgbBMCache );
		}
	else
		{
		Assert( cbKey <= pfucb->cbBMBuffer );
		pfucb->bmCurr.key.suffix.SetPv( pfucb->pvBMBuffer );
		}
	pfucb->bmCurr.key.suffix.SetCb( cbKey );
	bm.key.CopyIntoBuffer( pfucb->bmCurr.key.suffix.Pv() );

	//	copy data
	//
	if ( fUnique )
		{
		//	bookmark does not need data
		pfucb->bmCurr.data.Nullify();
		}

	else
		{
		if ( fDataLocal )
			{
			Assert( cbData <= cbBMCache );
			pfucb->bmCurr.data.SetPv ( fKeyLocal ? 
				pfucb->rgbBMCache + cbKey : pfucb->rgbBMCache );
			}
		else if ( fKeyLocal )
			{
			Assert( fKeyLocal && !fDataLocal );
			Assert( cbKey <= cbBMCache );
			Assert( cbData <= pfucb->cbBMBuffer );
			pfucb->bmCurr.data.SetPv( pfucb->pvBMBuffer );
			}
		else
			{
			Assert( !fKeyLocal && !fDataLocal );
			Assert( cbKey > cbBMCache && cbData > cbBMCache );
			Assert( cbData + cbKey <= pfucb->cbBMBuffer );
			pfucb->bmCurr.data.SetPv( (BYTE *) pfucb->pvBMBuffer + cbKey );
			}

		bm.data.CopyInto( pfucb->bmCurr.data );
		}

	//	Record if we are going to touch the data page of this bookmark

	pfucb->fTouch = fTouch;

	//	Record that we now have the bookmark saved

	pfucb->fBookmarkPreviouslySaved = fTrue;

	return JET_errSuccess;
	}



//  ================================================================
LOCAL BOOL FKeysEqual( const KEY& key1, KEY * const pkey, const ULONG cbKey )
//  ================================================================
//
//  Compares two keys, using length as a tie-breaker
//
//-
	{
	if( key1.Cb() == cbKey )
		{
		KEY		key2;
		key2.prefix.Nullify();
		key2.suffix.SetPv( pkey );
		key2.suffix.SetCb( cbKey );
		return ( 0 == CmpKeyShortest( key1, key2 ) );
		}
	return fFalse;
	}


LOCAL ERR ErrBTIReportBadPageLink(
	FUCB		* const pfucb,
	const ERR	err,
	const PGNO	pgnoComingFrom,
	const PGNO	pgnoGoingTo,
	const PGNO	pgnoBadLink )
	{
	//	only report the error if not repairing
	if ( !fGlobalRepair )
		{
		const UINT	csz		= 7;
		const CHAR	* rgsz[csz];
		CHAR		rgszDw[csz][16];

		sprintf( rgszDw[0], "%d", err );
		sprintf( rgszDw[1], "%d", pfucb->u.pfcb->ObjidFDP() );
		sprintf( rgszDw[2], "%d", pfucb->u.pfcb->PgnoFDP() );
		sprintf( rgszDw[3], "%d", pgnoComingFrom );
		sprintf( rgszDw[4], "%d", pgnoGoingTo );
		sprintf( rgszDw[5], "%d", pgnoBadLink );

		rgsz[0] = rgszDw[0];
		rgsz[1] = rgszDw[1];
		rgsz[2] = rgszDw[2];
		rgsz[3] = rgfmp[pfucb->u.pfcb->Ifmp()].SzDatabaseName();
		rgsz[4] = rgszDw[3];
		rgsz[5] = rgszDw[4];
		rgsz[6] = rgszDw[5];

		UtilReportEvent( eventError, DATABASE_CORRUPTION_CATEGORY, BAD_PAGE_LINKS_ID, csz, rgsz );
		}

	Assert( JET_errBadPageLink == err || JET_errBadParentPageLink == err );
	return err;
	}


//	goto the next line in tree
//
ERR	ErrBTNext( FUCB *pfucb, DIRFLAG dirflag )
	{
	// function called with dirflag == fDIRAllNode from eseutil - node dumper
	// Assert( ! ( dirflag & fDIRAllNode ) );
	
	ERR		err;
	KEY		* pkeySave		= NULL;
	ULONG	cbKeySave;

	//	refresh currency
	//	places cursor on record to move from
	//
	CallR( ErrBTIRefresh( pfucb ) );

Start:
	PERFIncCounterTable( cBTNext, PinstFromPfucb( pfucb ), pfucb->u.pfcb->Tableclass() );
	
	//	now we have a read latch on page
	//
	Assert( Pcsr( pfucb )->Latch() == latchReadTouch ||
			Pcsr( pfucb )->Latch() == latchReadNoTouch ||
			Pcsr( pfucb )->Latch() == latchRIW );
	Assert( ( Pcsr( pfucb )->Cpage().FLeafPage() ) != 0 );
	AssertNDGet( pfucb );
	
	//	get next node in page
	//	if it does not exist, go to next page
	//
	if ( Pcsr( pfucb )->ILine() + 1 < Pcsr( pfucb )->Cpage().Clines() )
		{
		//	get next node
		//
		Pcsr( pfucb )->IncrementILine();
		NDGet( pfucb );
		}
	else
		{
		Assert( Pcsr( pfucb )->ILine() + 1 == Pcsr( pfucb )->Cpage().Clines() );
		
		//	next node not in current page
		//	get next page and continue
		//
		if ( Pcsr( pfucb )->Cpage().PgnoNext() == pgnoNull )
			{
			//	past the last node
			//	callee must set loc to AfterLast
			//
			err = ErrERRCheck( JET_errNoCurrentRecord );
			goto HandleError;
			}
		else
			{
			const PGNO pgnoPrev = Pcsr( pfucb )->Pgno();
			
			//	access next page [R latched]
			//				
			Call( Pcsr( pfucb )->ErrSwitchPage( 
									pfucb->ppib,
									pfucb->ifmp,
									Pcsr( pfucb )->Cpage().PgnoNext(),
									pfucb->u.pfcb->Tableclass(),
									pfucb->u.pfcb->FNoCache() ) );

			if( Pcsr( pfucb )->Cpage().PgnoPrev() != pgnoPrev )
				{
				//	if not repair, assert, otherwise, suppress the assert and
				//	repair will just naturally err out
				AssertSz( fGlobalRepair, "Corrupt B-tree: bad leaf page links detected on MoveNext" );
				Call( ErrBTIReportBadPageLink(
						pfucb,
						ErrERRCheck( JET_errBadPageLink ),
						pgnoPrev,
						Pcsr( pfucb )->Pgno(),
						Pcsr( pfucb )->Cpage().PgnoPrev() ) );
				}
				
			// get first node
			//
			NDMoveFirstSon( pfucb );

			if( FFUCBPreread( pfucb ) && 
				FFUCBPrereadForward( pfucb ) )
				{
				if ( pfucb->cpgPrereadNotConsumed > 0 )
					{
					//	read one more of preread pages
					//
					pfucb->cpgPrereadNotConsumed--;
					}

				if( 1 == pfucb->cpgPrereadNotConsumed
					&& Pcsr( pfucb )->Cpage().PgnoNext() != pgnoNull )
					{
					//  preread the next page as it was not originally preread
					const PGNO pgnoNext = Pcsr( pfucb )->Cpage().PgnoNext();
					BFPrereadPageRange( pfucb->ifmp, pgnoNext, 1 );
					}

				if ( 0 == pfucb->cpgPrereadNotConsumed
					 && !FNDDeleted( pfucb->kdfCurr ) )
					{
					//	if we need to do neighbour-key check, must save off
					//	bookmark
					if ( ( dirflag & fDIRNeighborKey )
						&& NULL == pkeySave )
						{
						pkeySave = (KEY *)PvOSMemoryHeapAlloc( KEY::cbKeyMax );
						if ( NULL == pkeySave )
							{
							Call( ErrERRCheck( JET_errOutOfMemory ) );
							}

						cbKeySave = pfucb->bmCurr.key.Cb();
						pfucb->bmCurr.key.CopyIntoBuffer( pkeySave, KEY::cbKeyMax );
						}

					//	UNDONE:	this might cause a bug since there is an assumption 
					//			that ErrBTNext does not lose latch
					//
					//	preread more pages
					//
					Call( ErrBTRelease( pfucb ) );				
					BTUp( pfucb );
					Call( ErrBTIRefresh( pfucb ) );
					}
				}
			}
		}

	AssertNDGet( pfucb );

	//	but node may not be valid due to dirFlag
	//
	
	//	move again if fDIRNeighborKey set and next node has same key
	//
	if ( dirflag & fDIRNeighborKey )
		{
		const BOOL	fSkip	= ( NULL == pkeySave ?
									FKeysEqual( pfucb->kdfCurr.key, pfucb->bmCurr.key ) :
									FKeysEqual( pfucb->kdfCurr.key, pkeySave, cbKeySave ) );
		if ( fSkip )
			{
			Assert( !FFUCBUnique( pfucb ) );
			goto Start;
			}
		}

	// function called with dirflag == fDIRAllNode from eseutil - node dumper
	// Assert( ! ( dirflag & fDIRAllNode ) );
	if ( !( dirflag & fDIRAllNode ) )
		{
		//	fDIRAllNode not set
		//	check version store to see if node is visible to cursor
		//
		BOOL fVisible;
		Call( ErrNDVisibleToCursor( pfucb, &fVisible ) );
		if ( !fVisible )
			{
			//	node not visible to cursor
			//	goto next node
			//
			goto Start;
			}
		}
		
	AssertNDGet( pfucb );
	err = JET_errSuccess;

HandleError:
	if ( NULL != pkeySave )
		{
		Assert( dirflag & fDIRNeighborKey );
		OSMemoryHeapFree( pkeySave );
		}
	return err;
	}


//	goes to previous line in tree
//
ERR	ErrBTPrev( FUCB *pfucb, DIRFLAG dirflag )
	{
	Assert( !( dirflag & fDIRAllNode ) );
	
	ERR		err;
	KEY		* pkeySave		= NULL;
	ULONG	cbKeySave;

	#ifdef DEBUG
	INT		crepeat = 0;
	#endif

	//	refresh currency
	//	places cursor on record to move from
	//

	CallR( ErrBTIRefresh( pfucb ) );

Start:
	PERFIncCounterTable( cBTPrev, PinstFromPfucb( pfucb ), pfucb->u.pfcb->Tableclass() );
	
	//	now we have a read latch on page
	//
	Assert( latchReadTouch == Pcsr( pfucb )->Latch() ||
			latchReadNoTouch == Pcsr( pfucb )->Latch() ||
			latchRIW == Pcsr( pfucb )->Latch() );
	Assert( ( Pcsr( pfucb )->Cpage().FLeafPage() ) != 0 );
	AssertNDGet( pfucb );
	
	//	get prev node in page
	//	if it does not exist, go to prev page
	//
	if ( Pcsr( pfucb )->ILine() > 0 )
		{
		//	get prev node
		//
		Pcsr( pfucb )->DecrementILine();
		NDGet( pfucb );
		}
	else
		{
		Assert( Pcsr( pfucb )->ILine() == 0 );
		
		//	prev node not in current page
		//	get prev page and continue
		//
		if ( Pcsr( pfucb )->Cpage().PgnoPrev() == pgnoNull )
			{
			//	past the first node
			//
			err = ErrERRCheck( JET_errNoCurrentRecord );
			goto HandleError;
			}
		else
			{
			const PGNO pgnoNext = Pcsr( pfucb )->Pgno();
			
			//	access prev page [R latched] without wait
			//	if conflict, release latches and retry
			//	else proceed
			//	the release of current page is done atomically by CSR
			//
			err = Pcsr( pfucb )->ErrSwitchPageNoWait( 
											pfucb->ppib, 
											pfucb->ifmp,
											Pcsr( pfucb )->Cpage().PgnoPrev(),
											pfucb->u.pfcb->Tableclass()
											);

			if ( err == errBFLatchConflict )
				{
				#ifdef DEBUG
				crepeat++;
				Assert( crepeat < 1000 );
				#endif
				
				//	save bookmark
				//	release latches
				//	re-seek
				//
				const LATCH		latch	= Pcsr( pfucb )->Latch();

				//	if we need to do neighbour-key check, must save off
				//	bookmark
				if ( ( dirflag & fDIRNeighborKey )
					&& NULL == pkeySave )
					{
					pkeySave = (KEY *)PvOSMemoryHeapAlloc( KEY::cbKeyMax );
					if ( NULL == pkeySave )
						{
						Call( ErrERRCheck( JET_errOutOfMemory ) );
						}

					cbKeySave = pfucb->bmCurr.key.Cb();
					pfucb->bmCurr.key.CopyIntoBuffer( pkeySave, KEY::cbKeyMax );
					}
				
				Assert( Pcsr( pfucb )->FLatched() );
				Call( ErrBTRelease( pfucb ) );
				Assert( !Pcsr( pfucb )->FLatched() );

				//	wait & refresh currency
				//
				UtilSleep( cmsecWaitGeneric );
				
				Call( ErrBTGotoBookmark( pfucb, pfucb->bmCurr, latch, fFalse ) );

				if ( wrnNDFoundGreater == err ||
					 JET_errSuccess == err )
					{
					//	go to previous node
					//
					goto Start;
					}
				}
			else
				{
				Call( err );

				if( Pcsr( pfucb )->Cpage().PgnoNext() != pgnoNext )
					{
					//	if not repair, assert, otherwise, suppress the assert and
					//	repair will just naturally err out
					AssertSz( fGlobalRepair, "Corrupt B-tree: bad leaf page links detected on MovePrev" );
					Call( ErrBTIReportBadPageLink(
								pfucb,
								ErrERRCheck( JET_errBadPageLink ),
								pgnoNext,
								Pcsr( pfucb )->Pgno(),
								Pcsr( pfucb )->Cpage().PgnoNext() ) );
					}

				//	get last node in page
				//
				NDMoveLastSon( pfucb );

				if( FFUCBPreread( pfucb ) && 
					FFUCBPrereadBackward( pfucb ) )
					{
					if ( pfucb->cpgPrereadNotConsumed > 0 )
						{
						pfucb->cpgPrereadNotConsumed--;
						}

					if( 1 == pfucb->cpgPrereadNotConsumed
						&& Pcsr( pfucb )->Cpage().PgnoPrev() != pgnoNull )
						{
						//  preread the next page as it was not originally preread
						const PGNO pgnoPrev = Pcsr( pfucb )->Cpage().PgnoPrev();
						BFPrereadPageRange( pfucb->ifmp, pgnoPrev, 1 );
						}

					if ( 0 == pfucb->cpgPrereadNotConsumed
						 && !FNDDeleted( pfucb->kdfCurr ) )
						{
						//	if we need to do neighbour-key check, must save off
						//	bookmark
						if ( ( dirflag & fDIRNeighborKey )
							&& NULL == pkeySave )
							{
							pkeySave = (KEY *)PvOSMemoryHeapAlloc( KEY::cbKeyMax );
							if ( NULL == pkeySave )
								{
								Call( ErrERRCheck( JET_errOutOfMemory ) );
								}
	
							cbKeySave = pfucb->bmCurr.key.Cb();
							pfucb->bmCurr.key.CopyIntoBuffer( pkeySave, KEY::cbKeyMax );
							}

						//	preread more pages
						//
						Call( ErrBTRelease( pfucb ) );
						BTUp( pfucb );
						Call( ErrBTIRefresh( pfucb ) );
						}
					}
				}
			}
		}

	//	get prev node
	//
	AssertNDGet( pfucb );

	//	but node may not be valid due to dirFlag
	//
	
	//	move again if fDIRNeighborKey set and prev node has same key
	//
	if ( dirflag & fDIRNeighborKey )
		{
		const BOOL	fSkip	= ( NULL == pkeySave ?
									FKeysEqual( pfucb->kdfCurr.key, pfucb->bmCurr.key ) :
									FKeysEqual( pfucb->kdfCurr.key, pkeySave, cbKeySave ) );
		if ( fSkip )
			{
			Assert( !FFUCBUnique( pfucb ) );
			goto Start;
			}
		}
	
	Assert( !( dirflag & fDIRAllNode ) );
	if ( !( dirflag & fDIRAllNode ) )
		{
		//	fDIRAllNode not set
		//	check version store to see if node is visible to cursor
		//
		BOOL fVisible;
		Call( ErrNDVisibleToCursor( pfucb, &fVisible ) );
		if ( !fVisible)
			{
			//	node not visible to cursor
			//	goto prev node
			//
			goto Start;
			}
		}

	AssertNDGet( pfucb );
	err = JET_errSuccess;

HandleError:
	if ( NULL != pkeySave )
		{
		Assert( dirflag & fDIRNeighborKey );
		OSMemoryHeapFree( pkeySave );
		}
	return err;
	}


//  ================================================================
VOID BTPrereadPage( IFMP ifmp, PGNO pgno )
//  ================================================================
	{
	PGNO rgpgno[2] = { pgno, pgnoNull };
	BFPrereadPageList( ifmp, rgpgno );
	}


//  ================================================================
VOID BTPrereadSpaceTree( const FCB * const pfcb )
//  ================================================================
//
//  Most of the time we will only need the Avail-Extent. Only if it
//  is empty will we need the Owned-Extent. However, the two pages are together
//  on disk so they are very cheap to read together.
//
//-
	{
	Assert( pfcbNil != pfcb );

	INT		ipgno = 0;
	PGNO	rgpgno[3];		// pgnoOE, pgnoAE, pgnoNull
	if( pgnoNull != pfcb->PgnoOE() )	//	may be single-extent
		{
		Assert( pgnoNull != pfcb->PgnoAE() );
		rgpgno[ipgno++] = pfcb->PgnoOE();
		rgpgno[ipgno++] = pfcb->PgnoAE();
		rgpgno[ipgno++] = pgnoNull;
		BFPrereadPageList( pfcb->Ifmp(), rgpgno );
		}
	}


//  ================================================================
VOID BTPrereadIndexesOfFCB( FCB * const pfcb )
//  ================================================================
	{
#ifdef DEBUG
	Assert( pfcbNil != pfcb );
	Assert( pfcb->FTypeTable() );
	Assert( ptdbNil != pfcb->Ptdb() );
#endif	//	DEBUG
	
	const INT cSecondaryIndexesToPreread = 16;
	
	PGNO rgpgno[cSecondaryIndexesToPreread + 1];	//  NULL-terminated
	INT	ipgno = 0;

	pfcb->EnterDML();
	
	const FCB *	pfcbT = pfcb->PfcbNextIndex();

	while( ipgno < ( ( sizeof( rgpgno ) / sizeof( PGNO ) ) - 1 )
			&& pfcbNil != pfcbT )
		{
		//  STORE SPECIFIC: this is intended to be used with MsgFolderTables.
		//  Normally, the only indexes we update are those which have
		//  fidbAllowAllNulls, fidbAllowFirstNull and fidbAllowSomeNulls set
		//  (this weeds out the rules index)
		if( pfcbT->Pidb() != pidbNil
			&& pfcbT->Pidb()->FAllowSomeNulls() )
			{
			rgpgno[ipgno++] = pfcbT->PgnoFDP();
			}
		pfcbT = pfcbT->PfcbNextIndex();
		}
	rgpgno[ipgno] = pgnoNull;

	pfcb->LeaveDML();

	BFPrereadPageList( pfcb->Ifmp(), rgpgno );
	}


//  extracts the list of pages to preread and call BF to preread them
//
ERR ErrBTIPreread( FUCB *pfucb, CPG cpg, CPG * pcpgActual )
	{					
#ifdef DEBUG
	const INT	ilineOrig = Pcsr( pfucb )->ILine();
#endif	//	DEBUG

	const CPG	cpgPreread = min( cpg,
								  FFUCBPrereadForward( pfucb ) ?
									Pcsr( pfucb )->Cpage().Clines() - Pcsr( pfucb )->ILine() :
									Pcsr( pfucb )->ILine() + 1 );
									

	//  add 1 PGNO for null termination of the list
	PGNO * rgpgnoPreread = (PGNO *)PvOSMemoryHeapAlloc( ( cpgPreread + 1 ) * sizeof(PGNO) );
	if( NULL == rgpgnoPreread )
		{
		return ErrERRCheck( JET_errOutOfMemory );
		}

	KEY		keyLimit;
	BOOL	fOutOfRange = fFalse;
	if( FFUCBLimstat( pfucb ) )
		{			
		//  we don't want to preread pages that aren't part of the index range
		//  the separator key is greater than any key on the page it points to
		//  so we always preread a page if the separator key is equal to our
		//  index limit

		FUCBAssertValidSearchKey( pfucb );
		keyLimit.prefix.Nullify();
		keyLimit.suffix.SetPv( pfucb->dataSearchKey.Pv() );
		keyLimit.suffix.SetCb( pfucb->dataSearchKey.Cb() );
		}

	INT 	ipgnoPreread;
	for( ipgnoPreread = 0; ipgnoPreread < cpgPreread; ++ipgnoPreread )
		{
		NDGet( pfucb );
		Assert( pfucb->kdfCurr.data.Cb() == sizeof( PGNO ) );

		if( FFUCBLimstat( pfucb ) )
			{			

			//  we want to preread the first page that is out of range
			//  so don't break until the top of the loop
			
			if( fOutOfRange )
				{
				break;
				}

			//  the separator key is suffix compressed so just compare the shortest key
			
			const INT	cmp				= CmpKeyShortest( pfucb->kdfCurr.key, keyLimit );

			if ( cmp > 0 )
				{
				fOutOfRange = FFUCBUpper( pfucb );
				}
			else if ( cmp < 0 )
				{
				fOutOfRange = !FFUCBUpper( pfucb );
				}
			else
				{
				//  always preread the page if the separator key is equal				
				fOutOfRange = fFalse;
				}
			}
		
		rgpgnoPreread[ipgnoPreread] = *(UnalignedLittleEndian< PGNO > *) pfucb->kdfCurr.data.Pv();

		if( FFUCBPrereadBackward( pfucb ) )
			{
			Assert( Pcsr( pfucb )->ILine() >= 0 );
			Pcsr( pfucb )->DecrementILine();
			}
		else
			{
			Assert( Pcsr( pfucb )->ILine() < Pcsr( pfucb )->Cpage().Clines() );
			Pcsr( pfucb )->IncrementILine();
			}
		}
		
	rgpgnoPreread[ipgnoPreread] = pgnoNull;

	BFPrereadPageList( pfucb->u.pfcb->Ifmp(), rgpgnoPreread, pcpgActual );
	
	OSMemoryHeapFree( rgpgnoPreread );
	return JET_errSuccess;
	}

	
//	seeks to key from root of tree
//
//		pdib->pos == posFirst --> seek to first node in tree
//					 posLast  --> seek to last node in tree
//					 posDown --> seek to pdib->key in tree
//					 posFrac --> fractional positioning
//		
//		pdib->pbm	used for posDown and posFrac
//		
//		pdib->dirflag == fDIRAllNode --> seek to deleted/versioned nodes too
//
//	positions cursor on node if one exists and is visible to cursor
//	else on next node visible to cursor
//	if no next node exists that is visible to cursor,
//		move previous to visible node
//
ERR	ErrBTDown( FUCB *pfucb, DIB *pdib, LATCH latch )
	{
	ERR			err = JET_errSuccess;
	ERR			wrn = JET_errSuccess;
	const BOOL	fSeekOnNonUniqueKeyOnly	= ( posDown == pdib->pos
											&& !FFUCBUnique( pfucb )
											&& 0 == pdib->pbm->data.Cb() );

	PGNO 		pgnoParent = pgnoNull;
	
#ifdef DEBUG
	ULONG	ulTrack = 0x00;
#endif	//	DEBUG

	Assert( latchReadTouch == latch || latchReadNoTouch == latch ||
			latchRIW == latch );
	Assert( posDown == pdib->pos
			|| 0 == ( pdib->dirflag & (fDIRFavourPrev|fDIRFavourNext|fDIRExact) ) );

	//	no latch should be held by cursor on tree
	//
	Assert( !Pcsr( pfucb )->FLatched() );

	PERFIncCounterTable( cBTSeek, PinstFromPfucb( pfucb ), pfucb->u.pfcb->Tableclass() );

	if( g_fImprovedSeekShortcut
		&& !PinstFromIfmp( pfucb->ifmp )->m_plog->m_fRecovering
		&& posDown == pdib->pos								//  seeking down
		&& locOnCurBM == pfucb->locLogical					//	already on a node
		&& FFUCBUnique( pfucb )								//  on a unique index	
		&& !FFUCBSpace( pfucb )								//  but not on its space tree
		&& !( fDIRAllNode & pdib->dirflag )					//  BTGotoBookmark uses fDIRAllNode
		&& FKeysEqual( pdib->pbm->key, pfucb->bmCurr.key ) )
		{		
		Assert( pdib->pbm->data.FNull() );
		Assert( pfucb->bmCurr.data.FNull() );

#ifdef DEBUG
		ulTrack |= 0x1000;
#endif	//	DEBUG

		PERFIncCounterTable( cBTSeekShortCircuit, PinstFromPfucb( pfucb ), pfucb->u.pfcb->Tableclass() );

		err = ErrBTIRefresh( pfucb );
		if( err >= 0 )
			{
			//  check deleted state
			goto FoundRecord;
			}
		// else fallthru to normal case below
		}

	//	go to root
	//
	Call( ErrBTIGotoRoot( pfucb, latch ) );
	
	//	if no nodes in root, return
	//
	if ( 0 == Pcsr( pfucb )->Cpage().Clines() )
		{
		BTUp( pfucb );
		return ErrERRCheck( JET_errRecordNotFound );
		}

	CallS( err );

	//	seek to key
	//
	for ( ; ; )
		{
		//	for every page level, seek to key
		//	if internal page, 
		//		get child page
		//		move cursor to new page
		//		release parent page
		//
		switch ( pdib->pos )
			{
			case posDown:
				Call( ErrNDSeek( pfucb, *(pdib->pbm) ) );
				wrn = err;
				break;
			
			case posFirst:
				NDMoveFirstSon( pfucb );
				break;

			case posLast:
				NDMoveLastSon( pfucb );
				break;

			default:
				Assert( pdib->pos == posFrac );
				Pcsr( pfucb )->SetILine( IlineBTIFrac( pfucb, pdib ) );
				NDGet( pfucb );
				break;
			}			
			
		if ( !Pcsr( pfucb )->Cpage().FInvisibleSons( ) )
			{
			//	leaf node reached, exit loop
			//
			break;
			}
		else
			{
			//	get pgno of child from node
			//	switch to that page
			//
#ifdef DEBUG
			ulTrack |= 0x01;
			
			const BOOL	fPageParentOfLeaf 	= Pcsr( pfucb )->Cpage().FParentOfLeaf();
			const PGNO	pgnoOld				= Pcsr( pfucb )->Pgno();
			const INT	ilineOld				= Pcsr( pfucb )->ILine();
#endif	//	DEBUG

			Assert( pfucb->kdfCurr.data.Cb() == sizeof( PGNO ) );
			const PGNO	pgnoChild			= *(UnalignedLittleEndian< PGNO > *) pfucb->kdfCurr.data.Pv();
			
			//  NOTE: the preread code below may not restore the kdfCurr
			const INT	ilineParent			= Pcsr( pfucb )->ILine();
			
			if ( FFUCBPreread( pfucb ) )
				{
				if( Pcsr( pfucb )->Cpage().FParentOfLeaf() )
					{
					if( 0 == pfucb->cpgPrereadNotConsumed && pfucb->cpgPreread > 1 )
						{
						//	if prereading and have reached the page above the leaf level,
						//	extract next set of pages to be preread
						Call( ErrBTIPreread( pfucb, pfucb->cpgPreread, &pfucb->cpgPrereadNotConsumed) );
						}
					}
				else if ( ( FFUCBSequential( pfucb ) || FFUCBLimstat( pfucb ) )
						&& FFUCBPrereadForward( pfucb ) )
					{
					//  if prereading a sequential table and on an internal page read the next
					//  internal child page as well
					CPG cpgUnused;
					Call( ErrBTIPreread( pfucb, 2, &cpgUnused ) );
					}
				}

			Pcsr( pfucb )->SetILine( ilineParent );

			pgnoParent = Pcsr( pfucb )->Pgno();
			
			Call( Pcsr( pfucb )->ErrSwitchPage( 
						pfucb->ppib,
						pfucb->ifmp,
						pgnoChild,
						pfucb->u.pfcb->Tableclass(),
						pfucb->u.pfcb->FNoCache()  ) );

			Assert( FFUCBRepair( pfucb )
					|| Pcsr( pfucb )->Cpage().FLeafPage() && fPageParentOfLeaf
					|| !Pcsr( pfucb )->Cpage().FLeafPage() && !fPageParentOfLeaf );
			}
		}

FoundRecord:
	//	now, the cursor is on leaf node
	//	
	Assert( Pcsr( pfucb )->Cpage().FLeafPage() );
	AssertBTType( pfucb );
	AssertNDGet( pfucb );

	//  if we were going to the first/last page in the tree, check to see that it 
	//  doesn't have a sibling
	if( posFirst == pdib->pos && pgnoNull != Pcsr( pfucb )->Cpage().PgnoPrev() )
		{
		//	if not repair, assert, otherwise, suppress the assert and repair will
		//	just naturally err out
		AssertSz( fGlobalRepair, "Corrupt B-tree: first page has pgnoPrev" );
		Call( ErrBTIReportBadPageLink(
					pfucb,
					ErrERRCheck( JET_errBadParentPageLink ),
					pgnoParent,
					Pcsr( pfucb )->Pgno(),
					Pcsr( pfucb )->Cpage().PgnoPrev() ) );
		}
	else if( posLast == pdib->pos && pgnoNull != Pcsr( pfucb )->Cpage().PgnoNext() )
		{
		//	if not repair, assert, otherwise, suppress the assert and repair will
		//	just naturally err out
		AssertSz( fGlobalRepair, "Corrupt B-tree: last page has pgnoNext" );
		Call( ErrBTIReportBadPageLink(
					pfucb,
					ErrERRCheck( JET_errBadParentPageLink ),
					pgnoParent,
					Pcsr( pfucb )->Pgno(),
					Pcsr( pfucb )->Cpage().PgnoNext() ) );
		}
		
	//	if node is not visible to cursor,
	//	move next till a node visible to cursor is found,
	//		if that leaves end of tree, 
	//			move previous to first node visible to cursor
	//
	//	fDIRAllNode flag is used by ErrBTGotoBookmark 
	//	to go to deleted records
	//
	Assert( !( ( pdib->dirflag & fDIRAllNode ) && 
			JET_errNoCurrentRecord == err ) );
	if ( !( pdib->dirflag & fDIRAllNode ) )
		{
#ifdef DEBUG
		ulTrack |= 0x02;
#endif	//	DEBUG
		
		BOOL	fVisible;
		Call( ErrNDVisibleToCursor( pfucb, &fVisible ) );
		Assert( !fVisible || JET_errNoCurrentRecord != err );

		if ( !fVisible )
			{
#ifdef DEBUG
			ulTrack |= 0x04;
#endif	//	DEBUG
			
			if ( ( pdib->dirflag & fDIRFavourNext ) || posFirst == pdib->pos )
				{
				//	fDIRFavourNext is only set if we know we want RecordNotFound
				//	if there are no nodes greater than or equal to the one we
				//	want, in which case there's no point going ErrBTPrev().
				//
#ifdef DEBUG
				ulTrack |= 0x08;
#endif	//	DEBUG
				wrn = wrnNDFoundGreater;
				err = ErrBTNext( pfucb, fDIRNull );
				}
			else if ( ( pdib->dirflag & fDIRFavourPrev ) || posLast == pdib->pos )
				{
				//	this flag is only set if we know we want RecordNotFound
				//	if there are no nodes less than or equal to the one we
				//	want, in which case there's no point going ErrBTNext().
				//
#ifdef DEBUG
				ulTrack |= 0x10;
#endif	//	DEBUG
				wrn = wrnNDFoundLess;
				err = ErrBTPrev( pfucb, fDIRNull );
				}
			else if ( ( pdib->dirflag & fDIRExact ) && !fSeekOnNonUniqueKeyOnly )
				{
#ifdef DEBUG
				ulTrack |= 0x20;
#endif	//	DEBUG
				err = ErrERRCheck( JET_errRecordNotFound );
				}
			else
				{
#ifdef DEBUG
				ulTrack |= 0x40;
#endif	//	DEBUG
				wrn = wrnNDFoundGreater;
				err = ErrBTNext( pfucb, fDIRNull );
				if( JET_errNoCurrentRecord == err )
					{
					wrn = wrnNDFoundLess;
					err = ErrBTPrev( pfucb, fDIRNull );
					}
				}
			Call( err );

			//	BTNext/Prev() shouldn't return these warnings
			Assert( wrnNDFoundGreater != err );
			Assert( wrnNDFoundLess != err );

			//	if on a non-unique index and no data portion of the
			//	bookmark was passed in, may need to do a "just the key"
			//	comparison
			if ( fSeekOnNonUniqueKeyOnly )
				{
#ifdef DEBUG
				ulTrack |= 0x80;
#endif	//	DEBUG
				const BOOL fKeysEqual = FKeysEqual( pfucb->kdfCurr.key, pdib->pbm->key );
				if ( fKeysEqual )
					{
					wrn = JET_errSuccess;
					}
				else
					{
#ifdef DEBUG
					const INT cmp = CmpKey( pfucb->kdfCurr.key, pdib->pbm->key );
					Assert( ( cmp < 0 && wrnNDFoundLess == wrn )
						|| ( cmp > 0 && wrnNDFoundGreater == wrn ) );
#endif	//	DEBUG
					}
				}
			}
		}

	if ( posDown == pdib->pos )
		{
#ifdef DEBUG
		INT	cmp = FFUCBUnique( pfucb ) || fSeekOnNonUniqueKeyOnly ?
					CmpKey( pfucb->kdfCurr.key, pdib->pbm->key ) :
					CmpKeyData( pfucb->kdfCurr, *pdib->pbm );

		if ( cmp < 0 )
			Assert( wrnNDFoundLess == wrn );
		else if ( cmp > 0 )
			Assert( wrnNDFoundGreater == wrn );
		else
			CallS( wrn );
#endif		

		err = wrn;
		}


	//	now, the cursor is on leaf node
	//	
	Assert( Pcsr( pfucb )->Cpage().FLeafPage() );
	AssertBTType( pfucb );
	AssertNDGet( pfucb );
	Assert( err >= 0 );

///	Assert( Pcsr( pfucb )->Latch() == latch );
	return err;
	
HandleError:
	Assert( err < 0 );
	BTUp( pfucb );
	if ( JET_errNoCurrentRecord == err )
		{
		err = ErrERRCheck( JET_errRecordNotFound );
		}
	return err;
	}


ERR ErrBTPerformOnSeekBM( FUCB * const pfucb, const DIRFLAG dirflag )
	{
	ERR		err;
	DIB		dib;

	Assert( locOnSeekBM == pfucb->locLogical );
	Assert( !Pcsr( pfucb )->FLatched() );
	Assert( fDIRFavourPrev == dirflag
		|| fDIRFavourNext == dirflag );

	dib.pbm		= &pfucb->bmCurr;
	dib.pos		= posDown;
	dib.dirflag	= dirflag;
	err = ErrBTDown( pfucb, &dib, latchReadNoTouch );
	Assert( JET_errRecordDeleted != err );
	Assert( JET_errNoCurrentRecord != err );
	if ( JET_errRecordNotFound == err )
		{
		//	moved past last node
		//
		pfucb->locLogical = ( fDIRFavourPrev == dirflag ? locBeforeFirst : locAfterLast );
		}

	Assert( err < 0 || Pcsr( pfucb )->FLatched() );
	return err;
	}


//	*********************************************
//	direct access routines
//
	

//	gets position of key by seeking down from root
//	ulTotal is estimated total number of records in tree
//	ulLT is estimated number of nodes lesser than given node
//
ERR ErrBTGetPosition( FUCB *pfucb, ULONG *pulLT, ULONG *pulTotal )
	{
	ERR		err;
	UINT	ulLT = 0;
	UINT	ulTotal = 1;

	//	no latch should be held by cursor on tree
	//
	Assert( !Pcsr( pfucb )->FLatched() );

	PERFIncCounterTable( cBTSeek, PinstFromPfucb( pfucb ), pfucb->u.pfcb->Tableclass() );

	//	go to root
	//
	CallR( ErrBTIGotoRoot( pfucb, latchReadTouch ) );

	//	seek to bookmark key
	//
	for ( ; ; )
		{
		INT		clines = Pcsr( pfucb )->Cpage().Clines();

		//	for every page level, seek to bookmark key
		//	
		Call( ErrNDSeek( pfucb, pfucb->bmCurr ) );

		//	adjust number of records and key position
		//	for this tree level
		//
		ulLT = ulLT * clines + Pcsr( pfucb )->ILine();
		ulTotal = ulTotal * clines;

		if ( !Pcsr( pfucb )->Cpage().FInvisibleSons( ) )
			{
			//	leaf node reached, exit loop
			//
			break;
			}
		else
			{
			//	get pgno of child from node
			//	switch to that page
			//
			Assert( pfucb->kdfCurr.data.Cb() == sizeof( PGNO ) );
			Call( Pcsr( pfucb )->ErrSwitchPage(
								pfucb->ppib,
								pfucb->ifmp,
								*(UnalignedLittleEndian< PGNO > *) pfucb->kdfCurr.data.Pv(),
								pfucb->u.pfcb->Tableclass(),
								pfucb->u.pfcb->FNoCache()
								) );
			}
		}

	*pulLT = ulLT;
	*pulTotal = ulTotal;
	Assert( ulTotal >= ulLT );

HandleError:
	//	unlatch the page
	//	do not save logical currency
	//
	BTUp( pfucb );
	return err;
	}


//	goes to given bookmark on page [does not check version store]
//	bookmark must have been obtained on a node
//	if bookmark does not exist, returns JET_errRecordNotFound
//	if ExactPos is set, and we can not find node with bookmark == bm
//		we return error
//
ERR ErrBTGotoBookmark( FUCB *pfucb, const BOOKMARK& bm, LATCH latch, BOOL fExactPos )
	{
	ERR			err;
	DIB			dib;
	BOOKMARK 	bmT = bm;
	
	Assert( !bm.key.FNull() );
	Assert( !FFUCBUnique( pfucb ) || bm.data.Cb() == 0 );
	Assert( FFUCBUnique( pfucb ) || bm.data.Cb() != 0 );
	Assert( latchReadTouch == latch || latchReadNoTouch == latch ||
			latchRIW == latch );
			
	//	similar to BTDown
	//	goto Root and seek down using bookmark key and data
	//
	dib.pos		= posDown;
	dib.pbm		= &bmT;
	dib.dirflag = fDIRAllNode | ( fExactPos ? fDIRExact : fDIRNull );

	err = ErrBTDown( pfucb, &dib, latch );
	Assert( err < 0 || Pcsr( pfucb )->Latch() == latch );
	
	if ( fExactPos
		&& ( JET_errRecordNotFound == err
			|| wrnNDFoundLess == err
			|| wrnNDFoundGreater == err ) )
		{
		//	bookmark does not exist anymore
		//
		BTUp( pfucb );
		Assert( !Pcsr( pfucb )->FLatched() );
///		AssertTracking();		//	need this assert to track concurrency bugs
		err = ErrERRCheck( JET_errRecordDeleted );
		}
		
	return err;
	}


//	seeks for bookmark in page
//	functionality is similar to ErrBTGotoBookmark
//		looking at all nodes [fDIRAllNode]
//		and seeking for equal
//	returns wrnNDNotInPage if bookmark falls outside page boundary
//
ERR	ErrBTISeekInPage( FUCB *pfucb, const BOOKMARK& bmSearch )
	{
	ERR		err;

	Assert( Pcsr( pfucb )->FLatched() );

	if ( Pcsr( pfucb )->Cpage().FEmptyPage() ||
		 !Pcsr( pfucb )->Cpage().FLeafPage() ||
		 Pcsr( pfucb )->Cpage().ObjidFDP() != ObjidFDP( pfucb ) ||
		 0 == Pcsr( pfucb )->Cpage().Clines() )
		{
		return ErrERRCheck( wrnNDNotFoundInPage );
		}

	Assert( Pcsr( pfucb )->Cpage().FLeafPage() );
	Assert( Pcsr( pfucb )->Cpage().ObjidFDP() == ObjidFDP( pfucb ) );
	Assert( !Pcsr( pfucb )->Cpage().FEmptyPage() );

	CallR( ErrNDSeek( pfucb, bmSearch ) );

	if ( wrnNDFoundLess == err &&
			 Pcsr( pfucb )->Cpage().Clines() - 1 == Pcsr( pfucb )->ILine() ||
		 wrnNDFoundGreater == err &&
			 0 == Pcsr( pfucb )->ILine() )
		{
		//	node may be elsewhere if it is not in the range of this page
		//			
		err = ErrERRCheck( wrnNDNotFoundInPage );
		}

	return err;
	}


//	******************************************************
//	UPDATE OPERATIONS
//

//	lock record. this does not lock anything, we do not set
//  the version bit and the page is not write latched
//
//  UNDONE: we don't need to latch the page at all. just create 
//          the version using the bookmark in the FUCB
//
ERR	ErrBTLock( FUCB *pfucb, DIRLOCK dirlock )
	{
	Assert( dirlock == writeLock
			|| dirlock == readLock
			|| dirlock == waitLock );

	const BOOL  fVersion = !rgfmp[pfucb->ifmp].FVersioningOff();
	Assert( !fVersion || !PinstFromIfmp( pfucb->ifmp )->m_plog->m_fRecovering );
	
	ERR		err = JET_errSuccess;
	
	// UNDONE: If versioning is disabled, so is locking.
	if ( fVersion )
		{
		OPER oper = 0;
		switch( dirlock )
			{
			case writeLock:
				oper = operWriteLock;
				break;
			case readLock:
				oper = operReadLock;
				break;
			case waitLock:
				oper = operWaitLock;
				break;
			default:
				Assert( fFalse );
				break;
			}
			
		RCE	*prce = prceNil;
		VER *pver = PverFromIfmp( pfucb->ifmp );
		Call( pver->ErrVERModify(
				pfucb,
				pfucb->bmCurr,
				oper,
				&prce,
				NULL ) );
		Assert( prceNil != prce );
		VERInsertRCEIntoLists( pfucb, pcsrNil, prce, NULL );
		}
	Assert( !Pcsr( pfucb )->FLatched() );

HandleError:	
	return err;
	}


//	replace data of current node with given data
//		if necessary, split before replace
//  doesn't take a proxy because it isn't used by concurrent create index
//
ERR	ErrBTReplace( FUCB * const pfucb, const DATA& data, const DIRFLAG dirflag )
	{
	Assert( !FFUCBSpace( pfucb ) || fDIRNoVersion & dirflag );

	ERR		err;
	LATCH	latch		= latchReadNoTouch;
	INT		cbDataOld	= 0;

	PERFIncCounterTable( cBTReplace, PinstFromPfucb( pfucb ), pfucb->u.pfcb->Tableclass() );

	//	save bookmark
	//
	if ( Pcsr( pfucb )->FLatched() )
		CallR( ErrBTISaveBookmark( pfucb ) );

#ifdef DEBUG
	char rgbKey[ KEY::cbKeyMax ];
	int cbKey;
	char rgbData[ JET_cbPrimaryKeyMost ];
	DATA dataBM;
	dataBM.SetPv( rgbData );
	
	BOOKMARK *pbmCur = &pfucb->bmCurr;
	pbmCur->key.CopyIntoBuffer( rgbKey, (ULONG)pbmCur->key.Cb() );
	cbKey = pbmCur->key.Cb();
	pbmCur->data.CopyInto( dataBM );
#endif

	const BOOL		fVersion		= !( dirflag & fDIRNoVersion ) && !rgfmp[pfucb->ifmp].FVersioningOff();
	Assert( !fVersion || !PinstFromIfmp( pfucb->ifmp )->m_plog->m_fRecovering );
	
	RCE * prceReplace = prceNil;
	RCEID rceidReplace = rceidNull;

Start:
	CallR( ErrBTIRefresh( pfucb, latch ) );
	AssertNDGet( pfucb );

	//	non-unique trees have nodes in key-data order
	//	so to replace data, we need to delete and re-insert
	//
	Assert( FFUCBUnique( pfucb ) );

#ifdef DEBUG			
	if ( ( latchReadTouch == latch || latchReadNoTouch == latch )
		&& ( latchReadTouch == Pcsr( pfucb )->Latch() || latchReadNoTouch == Pcsr( pfucb )->Latch() ) )
		{
		//	fine!
		}
	else if ( latch == Pcsr( pfucb )->Latch() )
		{
		//	fine!
		}
	else
		{
		Assert( latchWrite == Pcsr( pfucb )->Latch() );
		Assert( FFUCBSpace( pfucb ) || pfucb->u.pfcb->FTypeSLVAvail() );
		}
#endif

#ifdef DEBUG
	char rgbKey2[ KEY::cbKeyMax ];
	pbmCur = &pfucb->bmCurr;
	pbmCur->key.CopyIntoBuffer( rgbKey2, (ULONG)pbmCur->key.Cb() );
	Assert( pbmCur->key.Cb() == cbKey );
	Assert( memcmp( rgbKey, rgbKey2, pbmCur->key.Cb() ) == 0 );
	Assert( pbmCur->data.Cb() == dataBM.Cb() );
	Assert( memcmp( pbmCur->data.Pv(), dataBM.Pv(), dataBM.Cb() ) == 0 );
#endif

	if ( latchWrite != Pcsr( pfucb )->Latch() )
		{
		//	upgrade latch
		//

		err = Pcsr( pfucb )->ErrUpgrade();
		
		if ( err == errBFLatchConflict )
			{
			Assert( !Pcsr( pfucb )->FLatched() );
			latch = latchRIW;
			goto Start;
			}
		Call( err );
		}
	
	Assert( latchWrite == Pcsr( pfucb )->Latch() );

	if( fVersion )
		{
		Assert( prceNil == prceReplace );
		VER *pver = PverFromIfmp( pfucb->ifmp );
		Call( pver->ErrVERModify( pfucb, pfucb->bmCurr, operReplace, &prceReplace, NULL ) );
		Assert( prceNil != prceReplace );		
		rceidReplace = Rceid( prceReplace );
		}

#ifdef DEBUG
	USHORT	cbUncFreeDBG;
	cbUncFreeDBG = Pcsr( pfucb )->Cpage().CbUncommittedFree();
#endif

	//	try to replace node data with new data
	//
	cbDataOld	= pfucb->kdfCurr.data.Cb();
	err = ErrNDReplace( pfucb, &data, dirflag, rceidReplace, prceReplace );

	if ( errPMOutOfPageSpace == err )
		{
		const INT	cbData		= data.Cb();
		Assert( cbData >= 0 );
		const INT	cbReq 		= data.Cb() - cbDataOld;
		Assert( cbReq > 0 );

		KEYDATAFLAGS	kdf;
		
		//	node replace causes page overflow
		//
		Assert( data.Cb() > pfucb->kdfCurr.data.Cb() );

		AssertNDGet( pfucb );

		kdf.Nullify();
		kdf.data = data;
		Assert( 0 == kdf.fFlags );

		//	call split repeatedly till replace succeeds
		//
		err = ErrBTISplit(
					pfucb,
					&kdf,
					dirflag | fDIRReplace,
					rceidReplace,
					rceidNull,
					prceReplace,
					cbDataOld,
					NULL );

		if ( errBTOperNone == err )
			{
			//	split was performed
			//	but replace did not succeed
			//	retry replace
			//
			Assert( !Pcsr( pfucb )->FLatched() );
			prceReplace = prceNil;	//  the version was nullified in ErrBTISplit
			latch = latchRIW;
			goto Start;
			}
		}

	//	this is the error either from ErrNDReplace() or from ErrBTISplit()
	Call( err );

	AssertBTGet( pfucb );

	if( prceNil != prceReplace )
		{
		Assert( fVersion );
		VERInsertRCEIntoLists( pfucb, Pcsr( pfucb ), prceReplace, NULL );
		}
	else
		{
		Assert( !fVersion );
		}

	return err;
	
HandleError:
	Assert( err < 0 );
	if( prceNil != prceReplace )
		{
		Assert( fVersion );
		VERNullifyFailedDMLRCE( prceReplace );
		}
	BTUp( pfucb );	//  UNDONE:  is this correct?
	
	return err;
	}


//	performs a delta operation on current node at specified offset
//
ERR	ErrBTDelta(
	FUCB*		pfucb,
	INT			cbOffset,
	const VOID*	pv,
	ULONG		cbMax,
	VOID*		pvOld,
	ULONG		cbMaxOld,
	ULONG*		pcbOldActual,
	DIRFLAG		dirflag )
	{
	ERR			err;
	LATCH		latch		= latchReadNoTouch;

	Assert( !FFUCBSpace( pfucb ) || fDIRNoVersion & dirflag );

	Assert( cbOffset >= 0 );
	if( sizeof( LONG ) != cbMax )
		{
		Assert( fFalse );
		return ErrERRCheck( JET_errInvalidBufferSize );
		}
		
	if( 0 != cbMaxOld
		&& NULL != pvOld
		&& sizeof( LONG ) != cbMaxOld )
		{
		Assert( fFalse );
		return ErrERRCheck( JET_errInvalidBufferSize );
		}

	//	can't normally come into this function with the page latched,
	//	because we may have to wait on a wait-lock when we go to create
	//	the Delta RCE, but the exception is a delta on the LV tree,
	//	which we know won't conflict with a wait-lock
	Assert( locOnCurBM == pfucb->locLogical );
	if ( Pcsr( pfucb )->FLatched() )
		{
		Assert( pfucb->u.pfcb->FTypeLV() );
		CallR( ErrBTISaveBookmark( pfucb ) );
		}

#ifdef DEBUG
	char rgbKey[ KEY::cbKeyMax ];
	int cbKey;
	char rgbData[ JET_cbPrimaryKeyMost ];
	DATA dataBM;
	dataBM.SetPv( rgbData );
	
	BOOKMARK *pbmCur = &pfucb->bmCurr;
	pbmCur->key.CopyIntoBuffer( rgbKey, (ULONG)pbmCur->key.Cb() );
	cbKey = pbmCur->key.Cb();
	pbmCur->data.CopyInto( dataBM );
#endif	//	DEBUG

	const LONG		lDelta			= *((LONG *)pv);	
	const BOOL		fVersion		= !( dirflag & fDIRNoVersion ) && !rgfmp[pfucb->ifmp].FVersioningOff();
	Assert( !fVersion || !PinstFromIfmp( pfucb->ifmp )->m_plog->m_fRecovering );
	
	RCE*			prce			= prceNil;
	RCEID			rceid			= rceidNull;

	//	must create delta RCE first to block out OLDSLV
	//	(if we created the RCE after getting the page
	//	write-latch, we'd cause a deadlock because we
	//	may wait on OLDSLV's waitlock while it waits on
	//	the page latch), but can't put in true delta yet
	//	because the page operation hasn't occurred yet
	//	(meaning other threads could still come in
	//	before we're able to obtain the write-latch and
	//	would calculate the wrong versioned delta
	//	because they would take into account this delta
	//	and erroneously compensate for it assuming it
	//	has already occurred on the page), so initially
	//	put in a zero-delta and then update RCE once
	//	we've done the node operation
	if( fVersion )
		{
		VERDELTA	verdelta;
		verdelta.lDelta				= 0;		//	this will be set properly after the node operation
		verdelta.cbOffset			= (USHORT)cbOffset;
		verdelta.fDeferredDelete	= fFalse; 	//	this will be set properly after the node operation
		verdelta.fFinalize			= fFalse;	//  this will be set properly after the node operation

		const KEYDATAFLAGS kdfSave = pfucb->kdfCurr;
		
		pfucb->kdfCurr.data.SetPv( &verdelta );
		pfucb->kdfCurr.data.SetCb( sizeof( VERDELTA ) );
		
		VER *pver = PverFromIfmp( pfucb->ifmp );
		err = pver->ErrVERModify( pfucb, pfucb->bmCurr, operDelta, &prce, NULL );

		pfucb->kdfCurr = kdfSave;

		Call( err );
		
		Assert( prceNil != prce );
		rceid = Rceid( prce );
		Assert( rceidNull != rceid );
		}

Start:
	Call( ErrBTIRefresh( pfucb, latch ) );
	AssertNDGet( pfucb );

#ifdef DEBUG
	char rgbKey2[ KEY::cbKeyMax ];
	pbmCur = &pfucb->bmCurr;
	pbmCur->key.CopyIntoBuffer( rgbKey2, (ULONG)pbmCur->key.Cb() );
	Assert( pbmCur->key.Cb() == cbKey );
	Assert( memcmp( rgbKey, rgbKey2, pbmCur->key.Cb() ) == 0 );
	Assert( pbmCur->data.Cb() == dataBM.Cb() );
	Assert( memcmp( pbmCur->data.Pv(), dataBM.Pv(), dataBM.Cb() ) == 0 );
#endif

	Assert(	( ( latchReadTouch == latch || latchReadNoTouch == latch ) &&
			  ( latchReadTouch == Pcsr( pfucb )->Latch() ||
				latchReadNoTouch == Pcsr( pfucb )->Latch() ) ) ||
			latch == Pcsr( pfucb )->Latch() );

	err = Pcsr( pfucb )->ErrUpgrade();
	
	if ( err == errBFLatchConflict )
		{
		Assert( !Pcsr( pfucb )->FLatched() );
		latch = latchRIW;
		goto Start;
		}
	Call( err );

	//	try to replace node data with new data
	//  we need to store the old value
	LONG lPrev;
	ULONG cbPrevActual;
	
	Call( ErrNDDelta( pfucb, cbOffset, pv, cbMax, &lPrev, sizeof( lPrev ), &cbPrevActual, dirflag, rceid ) );

	Assert( sizeof( lPrev ) == cbPrevActual );
	if( pvOld )
		{
		*((LONG *)pvOld) = lPrev;
		}
	if( pcbOldActual )
		{
		*pcbOldActual = cbPrevActual;
		}

	if( prceNil != prce )
		{
		VERDELTA* const		pverdelta		= (VERDELTA *)prce->PbData();
		
		Assert( fVersion );
		Assert( rceidNull != rceid );
		Assert( Pcsr( pfucb )->FLatched() );

		pverdelta->lDelta = lDelta;

		//  if the refcount went to zero we may need to set a flag in the RCE
		if ( 0 == ( lDelta + lPrev ) )
			{
			if( dirflag & fDIRDeltaDeleteDereferencedLV )
				{
				pverdelta->fDeferredDelete = fTrue;
				}
			else if( dirflag & fDIRFinalize )
				{
				pverdelta->fFinalize = fTrue;
				}
			}
		
		VERInsertRCEIntoLists( pfucb, Pcsr( pfucb ), prce, NULL );
		}
	else
		{
		Assert( !fVersion );
		}

	return err;
	
HandleError:
	Assert( err < 0 );
	if( prceNil != prce )
		{
		Assert( fVersion );
		VERNullifyFailedDMLRCE( prce );
		}

	BTUp( pfucb );
	return err;
	}
				
//	inserts key and data into tree
//	if inserted node does not fit into leaf page, split page and insert
//	if tree does not allow duplicates,
//		check that there are no duplicates in the tree
//		and also block out other inserts with the same key
//
ERR	ErrBTInsert(
	FUCB			*pfucb, 
	const KEY&		key, 
	const DATA&		data, 
	DIRFLAG			dirflag,
	RCE				*prcePrimary )
	{
	ERR				err;
	BOOKMARK		bmSearch;
	ULONG			cbReq;
	BOOL			fInsert;
	const BOOL		fUnique			= FFUCBUnique( pfucb );
	const BOOL		fVersion		= !( dirflag & fDIRNoVersion ) && !rgfmp[pfucb->ifmp].FVersioningOff();
	Assert( !fVersion || !PinstFromIfmp( pfucb->ifmp )->m_plog->m_fRecovering );

	INT cbDataOld;
	
	BOOKMARK	bookmark;
	bookmark.key = key;
	if( fUnique )
		{
		bookmark.data.Nullify();
		}
	else
		{
		bookmark.data = data;
		}

	RCE				*prceInsert		= prceNil;
	RCE				*prceReplace	= prceNil;

	RCEID			rceidInsert		= rceidNull;
	RCEID			rceidReplace	= rceidNull;
	
	VERPROXY		verproxy;		
	if ( prceNil != prcePrimary )
		{
		verproxy.prcePrimary 	= prcePrimary;
		verproxy.proxy 			= proxyCreateIndex;
		}
		
	const VERPROXY * const pverproxy = ( prceNil != prcePrimary ) ? &verproxy : NULL;

	KEYDATAFLAGS	kdf;
	LATCH			latch	= latchReadTouch;

	if ( fVersion )
		{
		VER *pver = PverFromIfmp( pfucb->ifmp );
		err = pver->ErrVERModify( pfucb, bookmark, operPreInsert, &prceInsert, pverproxy );
		if( JET_errWriteConflict == err )
			{
			//  insert never returns a writeConflict, turn it into a keyDuplicate
			err = ErrERRCheck( JET_errKeyDuplicate );
			}
		Call( err );
		Assert( prceInsert );
		rceidInsert = Rceid( prceInsert );
		}		
	
	Assert( !Pcsr( pfucb )->FLatched( ) );
	Assert( !FFUCBSpace( pfucb ) || fDIRNoVersion & dirflag );

	PERFIncCounterTable( cBTInsert, PinstFromPfucb( pfucb ), pfucb->u.pfcb->Tableclass() );

Seek:
	PERFIncCounterTable( cBTSeek, PinstFromPfucb( pfucb ), pfucb->u.pfcb->Tableclass() );

	//	set kdf to insert
	//
	
	kdf.data	= data;
	kdf.key		= key;
	kdf.fFlags	= 0;
	ASSERT_VALID( &kdf );

	NDGetBookmarkFromKDF( pfucb, kdf, &bmSearch );

	//	no page should be latched
	//	
	Assert( !Pcsr( pfucb )->FLatched( ) );

	//	go to root
	//
	Call( ErrBTIGotoRoot( pfucb, latch ) );
	Assert( 0 == Pcsr( pfucb )->ILine() );

	if ( Pcsr( pfucb )->Cpage().Clines() == 0 )
		{
		//	page is empty
		//	set error so we insert at current iline
		//
		Assert( Pcsr( pfucb )->Cpage().FLeafPage() );
		pfucb->kdfCurr.Nullify();
		err = ErrERRCheck( wrnNDFoundGreater );
		}
	else
		{
		//	seek down tree for key alone
		//
		for ( ; ; )
			{
			//	for every page level, seek to bmSearch
			//	if internal page, 
			//		get child page
			//		move cursor to new page
			//		release parent page
			//
			Call( ErrNDSeek( pfucb, bmSearch ) );

			if ( !Pcsr( pfucb )->Cpage().FInvisibleSons( ) )
				{
				//	leaf node reached, exit loop
				//
				break;
				}
			else
				{
				//	get pgno of child from node
				//	switch to that page
				//
				Assert( pfucb->kdfCurr.data.Cb() == sizeof( PGNO ) );
				Call( Pcsr( pfucb )->ErrSwitchPage( 
							pfucb->ppib,
							pfucb->ifmp,
							*(UnalignedLittleEndian< PGNO > *) pfucb->kdfCurr.data.Pv(),
							pfucb->u.pfcb->Tableclass(),
							pfucb->u.pfcb->FNoCache() ) );
				Assert( Pcsr( pfucb )->Cpage().Clines() > 0 );
				}
			}
		}

Insert:
	kdf.data	= data;
	kdf.key		= key;
	kdf.fFlags	= 0;
	ASSERT_VALID( &kdf );

	//	now, the cursor is on leaf node
	//	
	Assert( Pcsr( pfucb )->Cpage().FLeafPage() );
	
	if ( JET_errSuccess == err )
		{
		if ( fUnique )
			{
			Assert( FKeysEqual( kdf.key, pfucb->kdfCurr.key ) );

			if( !FNDDeleted( pfucb->kdfCurr ) )
				{
				//  this is either committed by another transaction that committed before we began
				//  or we inserted this key ourselves earlier
				Call( ErrERRCheck( JET_errKeyDuplicate ) );				
				}
#ifdef DEBUG
			else
				{
				Assert( !FNDPotVisibleToCursor( pfucb ) );	//  should have gotten a JET_errWriteConflict when we created the RCE
				}
#endif	//	DEBUG


			cbReq = kdf.data.Cb() > pfucb->kdfCurr.data.Cb() ?
						kdf.data.Cb() - pfucb->kdfCurr.data.Cb() :
						0;
			}
		else
			{
			Assert( 0 == CmpKeyData( bmSearch, pfucb->kdfCurr ) );

			//	can not have two nodes with same key-data
			//
			if ( !FNDDeleted( pfucb->kdfCurr ) )
				{
				// Only way to get here is if a multi-valued index column
				// caused us to generate the same key for the record.
				// This would have happened if the multi-values are non-
				// unique, or if we ran out of keyspace before we could
				// evaluate the unique portion of the multi-values.
				err = ErrERRCheck( JET_errMultiValuedIndexViolation );
				goto HandleError;
				}
#ifdef DEBUG
			else
				{
				Assert( !FNDPotVisibleToCursor( pfucb ) );	//  should have gotten a JET_errWriteConflict when we created the RCE
				}
#endif	//	DEBUG

			//	flag insert node
			//
			cbReq	= 0;
			}

		//	flag insert node and replace data atomically
		//
		fInsert = fFalse;
		}
	else
		{
		//	error is from ErrNDSeek
		//
		if ( wrnNDFoundLess == err )
			{
			//	inserted key-data falls past last node on cursor
			//
			Assert( Pcsr( pfucb )->Cpage().Clines() - 1 
						== Pcsr( pfucb )->ILine() );
			Assert( Pcsr( pfucb )->Cpage().Clines() == 0 ||
					!fUnique && CmpKeyData( pfucb->kdfCurr, bmSearch ) < 0 ||
					fUnique && CmpKey( pfucb->kdfCurr.key, bmSearch.key ) < 0 );
		
 			Pcsr( pfucb )->IncrementILine();
 			}

		//	calculate key prefix
		//
		BTIComputePrefix( pfucb, Pcsr( pfucb ), key, &kdf );
		Assert( !FNDCompressed( kdf ) || kdf.key.prefix.Cb() > 0 );
		
 		cbReq = CbNDNodeSizeCompressed( kdf );
 		fInsert = fTrue;
 		}

	if( !fInsert && fUnique && fVersion )
		{
		Assert( prceNil != prceInsert );
		Assert( prceNil == prceReplace );
		VER *pver = PverFromIfmp( pfucb->ifmp );
		Call( pver->ErrVERModify( pfucb, bookmark, operReplace, &prceReplace, pverproxy ) );
		Assert( prceNil != prceReplace );		
		rceidReplace = Rceid( prceReplace );
		cbDataOld = pfucb->kdfCurr.data.Cb();
		}
#ifdef DEBUG
	else
		{
		Assert( rceidNull == rceidReplace );
		}
#endif	//	DEBUG
		
#ifdef DEBUG
	USHORT	cbUncFreeDBG;
	cbUncFreeDBG = Pcsr( pfucb )->Cpage().CbUncommittedFree();
#endif

 	//	cursor is at insertion point
 	//
 	//	check if node fits in page
 	//
 	if ( FBTIAppend( pfucb, Pcsr( pfucb ), cbReq ) || FBTISplit( pfucb, Pcsr( pfucb ), cbReq ) )
 		{
		Assert( fUnique || fInsert );

#ifdef PREREAD_SPACETREE_ON_SPLIT
		if( pfucb->u.pfcb->FPreread() )
			{
	 		//  PREREAD space tree while we determine what to split (we WILL need the AE and possibly the OE)
	 		BTPrereadSpaceTree( pfucb->u.pfcb );
	 		}
#endif	//	PREREAD_SPACETREE_ON_SPLIT 

		//	re-adjust kdf to not contain prefix info
		//
		kdf.key		= key;
		kdf.data 	= data;
		kdf.fFlags 	= 0;
		
 		//	split and insert in tree
 		//
 		err = ErrBTISplit(
 					pfucb, 
					&kdf, 
					dirflag | ( fInsert ? fDIRInsert : fDIRFlagInsertAndReplaceData ),
					rceidInsert,
					rceidReplace,
					prceReplace,
					cbDataOld,
					pverproxy
					);
 
		if ( errBTOperNone == err )
			{
			//	insert was not performed
			//	retry insert
			//
			Assert( !Pcsr( pfucb )->FLatched() );

			//  the RCE was nullified in ErrBTISplit
			rceidReplace = rceidNull;
			prceReplace = prceNil;
			latch = latchRIW;
			goto Seek;
			}
			
		Call( err );
		}
	else
		{
		//	upgrade latch to write
		//
		PGNO	pgno = Pcsr( pfucb )->Pgno();

		err = Pcsr( pfucb )->ErrUpgrade();

		if ( err == errBFLatchConflict )
			{
			//	upgrade conflicted
			//	we lost our read latch
			//
			Assert( !Pcsr( pfucb )->FLatched( ) );

			Call( Pcsr( pfucb )->ErrGetPage(
						pfucb->ppib,
						pfucb->ifmp,
						pgno,
						latch,
						pfucb->u.pfcb->Tableclass()
						) );

			Call( ErrBTISeekInPage( pfucb, bmSearch ) );

			if ( wrnNDNotFoundInPage != err )
				{
				//	we have re-seeked to the insert position in page
				//
				Assert( JET_errSuccess == err ||
						wrnNDFoundLess == err ||
						wrnNDFoundGreater == err );

				//  if necessary, we will recreate this so remove it now
				if( prceNil != prceReplace )
					{
					Assert( prceNil != prceInsert );
					VERNullifyFailedDMLRCE( prceReplace );
					rceidReplace = rceidNull;
					prceReplace = prceNil;
					}
					
				latch = latchRIW;
				goto Insert;
				}

			//  if necessary, we will recreate this so remove it now
			
			if( prceNil != prceReplace )
				{
				Assert( prceNil != prceInsert );
				VERNullifyFailedDMLRCE( prceReplace );
				rceidReplace = rceidNull;
				prceReplace = prceNil;
				}
				
			//	reseek from root for insert
			
			BTUp( pfucb );

			latch = latchRIW;
			goto Seek;
			}

		Call( err );
		Assert( !FBTIAppend( pfucb, Pcsr( pfucb ), cbReq, fFalse ) );
		Assert(	!FBTISplit( pfucb, Pcsr( pfucb ), cbReq, fFalse ) );
		
		if ( fInsert )
			{
			err = ErrNDInsert( pfucb, &kdf, dirflag, rceidInsert, pverproxy );
			}
		else if ( fUnique )
			{
			Assert( FKeysEqual( kdf.key, pfucb->kdfCurr.key ) );
			err = ErrNDFlagInsertAndReplaceData(
						pfucb,
						&kdf,
						dirflag,
						rceidInsert,
						rceidReplace,
						prceReplace,
						pverproxy );
			}
		else
			{
			err = ErrNDFlagInsert( pfucb, dirflag, rceidInsert, pverproxy );
			}
		Assert ( errPMOutOfPageSpace != err );
		Call( err );
		}

	Assert( err >= 0 );
	Assert( Pcsr( pfucb )->FLatched( ) );
	if( prceNil != prceInsert )
		{
		Assert( fVersion );

		prceInsert->ChangeOper( operInsert );
		VERInsertRCEIntoLists( pfucb, Pcsr( pfucb ), prceInsert, pverproxy );
		}
#ifdef DEBUG
	else
		{
		Assert( !fVersion );
		}
#endif	//	DEBUG
		
	if( prceNil != prceReplace )
		{
		Assert( fVersion );
		Assert( prceNil != prceInsert );
		VERInsertRCEIntoLists( pfucb, Pcsr( pfucb ), prceReplace, pverproxy );
		}

HandleError:
	if ( err < 0 )
		{
		if( prceNil != prceReplace )
			{
			Assert( fVersion );
			Assert( prceNil != prceInsert );
			VERNullifyFailedDMLRCE( prceReplace );
			}
		if( prceNil != prceInsert )
			{
			Assert( fVersion );
			VERNullifyFailedDMLRCE( prceInsert );
			}
		BTUp( pfucb );
		}
		
	return err;
	}


//	append a node to the end of the  latched page
//	if node insert violates density constraint
//		split and insert
//
ERR	ErrBTAppend( FUCB			*pfucb, 
				 const KEY& 	key, 
				 const DATA& 	data,
				 DIRFLAG		dirflag )
	{
	const BOOL		fUnique			= FFUCBUnique( pfucb );
	const BOOL		fVersion		= !( dirflag & fDIRNoVersion ) && !rgfmp[pfucb->ifmp].FVersioningOff();
	Assert( !fVersion || !PinstFromIfmp( pfucb->ifmp )->m_plog->m_fRecovering );
	
	ERR				err;
	KEYDATAFLAGS	kdf;
	ULONG			cbReq;

Retry:

	Assert( !FFUCBSpace( pfucb ) || fDIRNoVersion & dirflag );
	Assert( Pcsr( pfucb )->FLatched() &&
			latchWrite == Pcsr( pfucb )->Latch() );
	Assert( pgnoNull == Pcsr( pfucb )->Cpage().PgnoNext() );
	Assert( Pcsr( pfucb )->Cpage().FLeafPage( ) );

	PERFIncCounterTable( cBTAppend, PinstFromPfucb( pfucb ), pfucb->u.pfcb->Tableclass() );

	BOOKMARK	bookmark;
	bookmark.key = key;
	if( fUnique )
		{
		bookmark.data.Nullify();
		}
	else
		{
		bookmark.data = data;
		}
		
	RCE	* prceInsert = prceNil;
	if ( fVersion )
		{
		VER *pver = PverFromIfmp( pfucb->ifmp );
		Call( pver->ErrVERModify( pfucb, bookmark, operPreInsert, &prceInsert, NULL ) );
		Assert( prceInsert );
		}	

	//	set kdf
	//
	kdf.key		= key;
	kdf.data	= data;
	kdf.fFlags	= 0;
		
#ifdef DEBUG
	Pcsr( pfucb )->SetILine( Pcsr( pfucb )->Cpage().Clines() - 1 );
	NDGet( pfucb );
	//  while repairing we may append a NULL key to the end of the page
	if( !( FFUCBRepair( pfucb ) && key.Cb() == 0 ) )
		{
		if ( FFUCBUnique( pfucb ) )
			{
			Assert( CmpKey( pfucb->kdfCurr.key, kdf.key ) < 0 );
			}
		else
			{
			Assert( CmpKeyData( pfucb->kdfCurr, kdf ) < 0 );
			}
		}
#endif

	//	set insertion point
	//
	Pcsr( pfucb )->SetILine( Pcsr( pfucb )->Cpage().Clines() );

	//	insert node at end of page
	//
	BTIComputePrefix( pfucb, Pcsr( pfucb ), key, &kdf );
	Assert( !FNDCompressed( kdf ) || kdf.key.prefix.Cb() > 0 );
		
	cbReq = CbNDNodeSizeCompressed( kdf );

#ifdef DEBUG
	USHORT	cbUncFreeDBG;
	cbUncFreeDBG = Pcsr( pfucb )->Cpage().CbUncommittedFree();
#endif

	//	cursor is at insertion point
	//
	//	check if node fits in page
	//
	if ( FBTIAppend( pfucb, Pcsr( pfucb ), cbReq ) )
		{
		//	readjust kdf to not contain prefix info
		//
		kdf.key		= key;
		kdf.data	= data;
		kdf.fFlags	= 0;
		
		//	split and insert in tree
		//
		err = ErrBTISplit( pfucb, 
						   &kdf, 
						   dirflag | fDIRInsert,
						   Rceid( prceInsert ),
						   rceidNull,
						   prceNil,
						   0,
						   NULL );

		if ( errBTOperNone == err && !FFUCBRepair( pfucb ) )
			{
			//	insert was not performed
			//	retry insert using normal insert operation
			//
			Assert( !Pcsr( pfucb )->FLatched() );
			Call( ErrBTInsert( pfucb, key, data, dirflag ) );
			return err;
			}
		else if ( errBTOperNone == err && FFUCBRepair( pfucb ) )
			{
			//	insert was not performed
			//	we may be inserting a NULL key so we can't go through
			//	the normal insert logic. move to the end of the tree
			//	and insert
			//
			Assert( !Pcsr( pfucb )->FLatched() );
			
			DIB dib;
			dib.pos = posLast;
			dib.pbm = NULL;
			dib.dirflag = fDIRNull;
			Call( ErrBTDown( pfucb, &dib, latchRIW ) );
			Call( Pcsr( pfucb )->ErrUpgrade() );
			goto Retry;
			}
			
		}
	else
		{
		Assert( !FBTISplit( pfucb, Pcsr( pfucb ), cbReq, fFalse ) );
		Assert( latchWrite == Pcsr( pfucb )->Latch() );

		//	insert node
		//
		err = ErrNDInsert( pfucb, &kdf, dirflag, Rceid( prceInsert ), NULL );
		Assert ( errPMOutOfPageSpace != err );
		}

	Call( err );

	AssertBTGet( pfucb );

	Assert( err >= 0 );
	Assert( Pcsr( pfucb )->FLatched( ) );
	if( prceNil != prceInsert )
		{
		Assert( fVersion );
		prceInsert->ChangeOper( operInsert );
		VERInsertRCEIntoLists( pfucb, Pcsr( pfucb ), prceInsert, NULL );
		}
#ifdef DEBUG
	else
		{
		Assert( !fVersion );
		}
#endif	//	DEBUG

	return err;
	
HandleError:
	Assert( err < 0 );
	if( prceNil != prceInsert )
		{
		Assert( fVersion );
		VERNullifyFailedDMLRCE( prceInsert );
		}
#ifdef DEBUG
	else
		{
		Assert( !fVersion );
		}
#endif	//	DEBUG

	BTUp( pfucb );
	return err;
	}
	

LOCAL ERR ErrBTITryAvailExtMerge( FUCB * const pfucb )
	{
	Assert( FFUCBAvailExt( pfucb ) );

	ERR					err = JET_errSuccess;
	MERGEAVAILEXTTASK	* const ptask = new MERGEAVAILEXTTASK(
												pfucb->u.pfcb->PgnoFDP(),
												pfucb->u.pfcb,
												pfucb->ifmp,
												pfucb->bmCurr );

	if( NULL == ptask )
		{
		CallR ( ErrERRCheck( JET_errOutOfMemory ) );
		}
	
	if ( PinstFromIfmp( pfucb->ifmp )->m_pver->m_fSyncronousTasks || rgfmp[ pfucb->ifmp ].FDetachingDB() )
		{
		// don't start the task because the task manager is not longer running
		// and we can't run is syncronous because it will deadlock.
		delete ptask;
		return JET_errSuccess;		
		}
		
	err = PinstFromIfmp( pfucb->ifmp )->Taskmgr().ErrTMPost( TASK::DispatchGP, ptask );
	if( err < JET_errSuccess )
		{
		//  The task was not enqued sucessfully.
		delete ptask;
		}	

	return err;
	}

//	flag-deletes a node
//
ERR ErrBTFlagDelete( FUCB *pfucb, DIRFLAG dirflag, RCE *prcePrimary )
	{
	const BOOL		fVersion		= !( dirflag & fDIRNoVersion ) && !rgfmp[pfucb->ifmp].FVersioningOff();
	Assert( !fVersion || !PinstFromIfmp( pfucb->ifmp )->m_plog->m_fRecovering );
	Assert( !FFUCBSpace( pfucb ) || fDIRNoVersion & dirflag );

	ERR		err;
	LATCH	latch = latchReadNoTouch;

	//	save bookmark
	//
	if ( Pcsr( pfucb )->FLatched() )
		CallR( ErrBTISaveBookmark( pfucb ) );

#ifdef DEBUG
	char rgbKey[ KEY::cbKeyMax ];
	int cbKey;
	char rgbData[ JET_cbPrimaryKeyMost ];
	DATA dataBM;
	dataBM.SetPv( rgbData );
	
	BOOKMARK *pbmCur = &pfucb->bmCurr;
	pbmCur->key.CopyIntoBuffer( rgbKey, (ULONG)pbmCur->key.Cb() );
	cbKey = pbmCur->key.Cb();
	pbmCur->data.CopyInto( dataBM );
#endif

	PERFIncCounterTable( cBTFlagDelete, PinstFromPfucb( pfucb ), pfucb->u.pfcb->Tableclass() );

	VERPROXY		verproxy;		
	if ( prceNil != prcePrimary )
		{
		verproxy.prcePrimary 	= prcePrimary;
		verproxy.proxy 			= proxyCreateIndex;
		}
		
	const VERPROXY * const pverproxy = ( prceNil != prcePrimary ) ? &verproxy : NULL;

	RCE * prce = prceNil;
	RCEID rceid = rceidNull;

	if( fVersion )
		{
		VER *pver = PverFromIfmp( pfucb->ifmp );
		Call( pver->ErrVERModify( pfucb, pfucb->bmCurr, operFlagDelete, &prce, pverproxy ) );
		Assert( prceNil != prce );
		rceid = Rceid( prce );
		Assert( rceidNull != rceid );
		}

Start:
	Call( ErrBTIRefresh( pfucb, latch ) );
	AssertNDGet( pfucb );

#ifdef DEBUG
	if ( ( latchReadTouch == latch || latchReadNoTouch == latch )
		&& ( latchReadTouch == Pcsr( pfucb )->Latch() || latchReadNoTouch == Pcsr( pfucb )->Latch() ) )
		{
		//	fine!
		}
	else if ( latch == Pcsr( pfucb )->Latch() )
		{
		//	fine!
		}
	else
		{
		Assert( latchWrite == Pcsr( pfucb )->Latch() );
		Assert( FFUCBSpace( pfucb ) || pfucb->u.pfcb->FTypeSLVAvail() );
		}

	char rgbKey2[ KEY::cbKeyMax ];
	pbmCur = &pfucb->bmCurr;
	pbmCur->key.CopyIntoBuffer( rgbKey2, (ULONG)pbmCur->key.Cb() );
	Assert( pbmCur->key.Cb() == cbKey );
	Assert( memcmp( rgbKey, rgbKey2, pbmCur->key.Cb() ) == 0 );
	Assert( pbmCur->data.Cb() == dataBM.Cb() );
	Assert( memcmp( pbmCur->data.Pv(), dataBM.Pv(), dataBM.Cb() ) == 0 );
#endif

	if ( latchWrite != Pcsr( pfucb )->Latch() )
		{
		//	upgrade latch
		//
		err = Pcsr( pfucb )->ErrUpgrade();
		
		if ( err == errBFLatchConflict )
			{
			Assert( !Pcsr( pfucb )->FLatched() );
			latch = latchRIW;
			goto Start;
			}
		Call( err );
		}
	
	Assert( latchWrite == Pcsr( pfucb )->Latch() );

	Assert( Pcsr( pfucb )->FLatched( ) );
	AssertNDGet( pfucb );

	//  if we are in the space tree and unversioned and we are
	//  not the first node in the page expunge the node
	//  UNDONE: if we do a BTPrev we will end up on the wrong node
	if ( dirflag & fDIRNoVersion
		 && Pcsr( pfucb )->Cpage().FSpaceTree() )
		{
		Assert( FFUCBSpace( pfucb ) );
		if ( 0 != Pcsr( pfucb )->ILine() )
			{
			Assert( !FNDVersion( pfucb->kdfCurr ) );
			Assert( prceNil == prcePrimary );
			Call( ErrNDDelete( pfucb ) );

			Assert( Pcsr( pfucb )->ILine() > 0 );
			Pcsr( pfucb )->DecrementILine();	//  correct the currency for a BTNext
			NDGet( pfucb );
			}
		else
			{
			Call( ErrNDFlagDelete( pfucb, dirflag, rceid, pverproxy ) );
			}

		if ( FFUCBAvailExt( pfucb )
			&& pgnoNull != Pcsr( pfucb )->Cpage().PgnoNext()
			&& Pcsr( pfucb )->Cpage().Clines() < 32
			&& dbidTemp != rgfmp[pfucb->ifmp].Dbid()
			&& !fGlobalRepair )
			{
			Call( ErrBTITryAvailExtMerge( pfucb ) );
			}
		}
	else
		{
		Call( ErrNDFlagDelete( pfucb, dirflag, rceid, pverproxy ) );
		}

	if( prceNil != prce )
		{
		Assert( rceidNull != rceid );
		Assert( fVersion );
		Assert( Pcsr( pfucb )->FLatched() );
		VERInsertRCEIntoLists( pfucb, Pcsr( pfucb ), prce, pverproxy );
		}
#ifdef DEBUG
	else
		{
		Assert( !fVersion );
		}
#endif	//	DEBUG

	return err;
	
HandleError:
	//  the page may or may not be latched
	//  it won't be latched if RCE creation failed

	Assert( err < 0 );
	if( prceNil != prce )
		{
		Assert( fVersion );
		VERNullifyFailedDMLRCE( prce );
		}

	CallS( ErrBTRelease( pfucb ) );
	return err;
	}
	


//  ================================================================
ERR ErrBTCopyTree( FUCB * pfucbSrc, FUCB * pfucbDest, DIRFLAG dirflag ) 
//  ================================================================
//
//  Used by repair. Copy all records in one tree to another tree.
//
	{
	ERR err;

	FUCBSetPrereadForward( pfucbSrc, cpgPrereadSequential );
	
	VOID * pvWorkBuf;
	BFAlloc( &pvWorkBuf );
	
	DIB dib;
	dib.pos 	= posFirst;
	dib.pbm 	= NULL;
	dib.dirflag = fDIRNull;
	err = ErrBTDown( pfucbSrc, &dib, latchReadTouch );

	while( err >= 0 )
		{
		KEY key;
		DATA data;

		key.Nullify();
		data.Nullify();
		
		BYTE * pb = (BYTE *)pvWorkBuf;
		pfucbSrc->kdfCurr.key.CopyIntoBuffer( pb );
		key.suffix.SetPv( pb );
		key.suffix.SetCb( pfucbSrc->kdfCurr.key.Cb() );
		pb += pfucbSrc->kdfCurr.key.Cb();
		
		UtilMemCpy( pb, pfucbSrc->kdfCurr.data.Pv(), pfucbSrc->kdfCurr.data.Cb() );
		data.SetPv( pb );
		data.SetCb( pfucbSrc->kdfCurr.data.Cb() );

		Call( ErrBTRelease( pfucbSrc ) );
		Call( ErrBTInsert( pfucbDest, key, data, dirflag, NULL ) );
		BTUp( pfucbDest );

		err = ErrBTNext( pfucbSrc, fDIRNull );
		}
	if( JET_errNoCurrentRecord == err )
		{
		err = JET_errSuccess;
		}

HandleError:
	BTUp( pfucbSrc );
	BTUp( pfucbDest );
	BFFree( pvWorkBuf );
	return err;
	}


//	******************************************************
//	STATISTICAL OPERATIONS
//

//	computes statistics on a given tree
//		calculates number of nodes, keys and leaf pages 
//		in tree
ERR ErrBTComputeStats( FUCB *pfucb, INT *pcnode, INT *pckey, INT *pcpage )
	{
	ERR		err;
	DIB		dib;
	PGNO	pgnoT;
	INT		cnode = 0;
	INT		ckey = 0;
	INT		cpage = 0;

	Assert( !Pcsr( pfucb )->FLatched() );

	//	go to first node, this is one-time deal. No need to change buffer touch,
	//	set read latch as a ReadAgain latch.
	//
	FUCBSetPrereadForward( pfucb, cpgPrereadSequential );
	dib.dirflag = fDIRNull;
	dib.pos		= posFirst;
	err = ErrBTDown( pfucb, &dib, latchReadNoTouch );
	if ( err < 0 )
		{
		//	if index empty then set err to success
		//
		if ( err == JET_errRecordNotFound )
			{
			err = JET_errSuccess;
			goto Done;
			}
		goto HandleError;
		}

	Assert( Pcsr( pfucb )->FLatched() );
	
	//	if there is at least one node, then there is a first page.
	//
	cpage = 1;

	if ( FFUCBUnique( pfucb ) )
		{
		forever
			{
			cnode++;

			//	move to next node.  If cross page boundary then
			//	increment page count.
			//
			pgnoT = Pcsr( pfucb )->Pgno();
			err = ErrBTNext( pfucb, fDIRNull );
				
			if ( err < JET_errSuccess )
				{
				ckey = cnode;
				goto Done;
				}

			if ( Pcsr( pfucb )->Pgno() != pgnoT )
				{
				cpage++;
				}
			}
		}
	else
		{
		BYTE	rgbKey[ JET_cbSecondaryKeyMost ];
		KEY		key;

		Assert( dib.dirflag == fDIRNull );
		key.Nullify();
		key.suffix.SetPv( rgbKey );

		Assert( pfucb->u.pfcb->FTypeSecondaryIndex() );
		Assert( pidbNil != pfucb->u.pfcb->Pidb() );
		Assert( !pfucb->u.pfcb->Pidb()->FUnique() );

		//	initialize key count to 1, to represent the
		//	node we're currently on
		ckey = 1;

		forever
			{
			//	copy key of current node
			//
			Assert( pfucb->kdfCurr.key.Cb() <= JET_cbSecondaryKeyMost );
			key.suffix.SetCb( pfucb->kdfCurr.key.Cb() );
			pfucb->kdfCurr.key.CopyIntoBuffer( key.suffix.Pv() );

			cnode++;

			//	move to next node
			//	increment page count, if page boundary is crossed
			//	
			pgnoT = Pcsr( pfucb )->Pgno();
			err = ErrBTNext( pfucb, fDIRNull );
			if ( err < 0 )
				{
				goto Done;
				}
			
			if ( Pcsr( pfucb )->Pgno() != pgnoT )
				{
				cpage++;
				}

			if ( !FKeysEqual( pfucb->kdfCurr.key, key ) )
				{ 
				ckey++;
				}
			}
		}
		

Done:
	//	common exit loop processing
	//
	if ( err < 0 && err != JET_errNoCurrentRecord )
		goto HandleError;

	err		= JET_errSuccess;
	*pcnode = cnode;
	*pckey	= ckey;
	*pcpage = cpage;

HandleError:
	BTUp( pfucb );
	Assert( !Pcsr( pfucb )->FLatched() );
	return err;
	}
	

//	******************************************************
//	SPECIAL OPERATIONS
//


INLINE ERR ErrBTICreateFCB(
	PIB				*ppib,
	const IFMP		ifmp,
	const PGNO		pgnoFDP,
	const OBJID		objidFDP,
	const OPENTYPE	opentype,
	const BOOL		fAlreadyTriedCleanup,
	FUCB			**ppfucb )
	{
	ERR				err;
	FCB				*pfcb		= pfcbNil;
	FUCB			*pfucb		= pfucbNil;

	//	create a new FCB

	CallR( FCB::ErrCreate( ppib, ifmp, pgnoFDP, &pfcb, fAlreadyTriedCleanup ) );

	//	the creation was successful

	Assert( pfcb->IsLocked() );
	Assert( pfcb->FTypeNull() );				// No fcbtype yet.
	Assert( pfcb->Ifmp() == ifmp );
	Assert( pfcb->PgnoFDP() == pgnoFDP );
	Assert( !pfcb->FInitialized() );
	Assert( pfcb->WRefCount() == 0 );
	pfcb->Unlock();
		
	Call( ErrFUCBOpen( ppib, ifmp, &pfucb ) );
	pfcb->Link( pfucb );

	Assert( !pfcb->FSpaceInitialized() );
	Assert( openNew != opentype || objidNil == objidFDP );
	if ( openNew != opentype )
		{
		if ( objidNil == objidFDP )
			{
			Assert( openNormal == opentype );

			//	read space info into FCB cache, including objid
			Call( ErrSPInitFCB( pfucb ) );
			Assert( fGlobalRepair || pfcb->FSpaceInitialized() );
			}
		else
			{
			pfcb->SetObjidFDP( objidFDP );
			if ( openNormalNonUnique == opentype )
				{
				pfcb->SetNonUnique();
				}
			else
				{
				Assert( pfcb->FUnique() );			//	btree is initially assumed to be unique
				Assert( openNormalUnique == opentype );
				}
			Assert( !pfcb->FSpaceInitialized() );
			}
		}

	if ( pgnoFDP == pgnoSystemRoot )
		{
		// SPECIAL CASE: For database cursor, we've got all the
		// information we need.

		//	when opening db cursor, always force to check the root page
		Assert( objidNil == objidFDP );
		if ( openNew == opentype )
			{
			//	objid will be set when we return to ErrSPCreate()
			Assert( objidNil == pfcb->ObjidFDP() );
			}
		else
			{
			Assert( objidSystemRoot == pfcb->ObjidFDP() );
			}

		//	insert this FCB into the global list

		pfcb->InsertList();

		//	finish initializing this FCB
			
		pfcb->Lock();
		Assert( pfcb->FTypeNull() );
		pfcb->SetTypeDatabase();
		pfcb->CreateComplete();
		pfcb->Unlock();
		}
		
	*ppfucb = pfucb;
	Assert( !Pcsr( pfucb )->FLatched() );

	return err;

HandleError:
	Assert( pfcbNil != pfcb );
	Assert( !pfcb->FInitialized() );
	Assert( !pfcb->FInList() );
	Assert( !pfcb->FInLRU() );
	Assert( ptdbNil == pfcb->Ptdb() );
	Assert( pfcbNil == pfcb->PfcbNextIndex() );
	Assert( pidbNil == pfcb->Pidb() );

	if ( pfucbNil != pfucb )
		{
		Assert( pfcb == pfucb->u.pfcb );
		FCBUnlinkWithoutMoveToAvailList( pfucb );

		//	synchronously purge the FCB
		pfcb->PrepareForPurge( fFalse );
		pfcb->Purge( fFalse );

		//	close the FUCB 
		FUCBClose( pfucb );
		}
	else
		{
		//	synchronously purge the FCB
		pfcb->PrepareForPurge( fFalse );
		pfcb->Purge( fFalse );
		}

	return err;
	}

	
//	*****************************************************
//	BTREE INTERNAL ROUTINES
//	

//	opens a cursor on a tree rooted at pgnoFDP
//	open cursor on corresponding FCB if it is in cache [common case]
//	if FCB not in cache, create one, link with cursor
//				and initialize FCB space info
//	if fNew is set, this is a new tree, 
//		so do not initialize FCB space info
//
ERR ErrBTIOpen(
	PIB				*ppib,
	const IFMP		ifmp,
	const PGNO		pgnoFDP,
	const OBJID		objidFDP,
	const OPENTYPE	opentype,
	FUCB			**ppfucb )
	{
	ERR				err;
	FCB				*pfcb;
	INT				fState;
	BOOL			fCleanupPerformed = fFalse;

RetrieveFCB:

	//	get the FCB for the given ifmp/pgnoFDP

	pfcb = FCB::PfcbFCBGet( ifmp, pgnoFDP, &fState );
	if ( pfcb == pfcbNil )
		{

		//	the FCB does not exist
		
		Assert( fFCBStateNull == fState );

		//	try to create a new B-tree which will cause the creation of the new FCB

		err = ErrBTICreateFCB( ppib, ifmp, pgnoFDP, objidFDP, opentype, fTrue, ppfucb );
		Assert( err <= JET_errSuccess );		// Shouldn't return warnings.
		if ( err < 0 )
			{

			//	the B-tree creation failed

			if ( err == errFCBExists )
				{

				//	we failed because someone else was racing to create
				//		the same FCB that we want, but they beat us to it

				//	try to get the FCB again

				goto RetrieveFCB;
				}

			if ( fCleanupPerformed )
				{

				//	we already signaled a version-clean, so we do not
				//		expect to suffer from a lack of FCBs
				
				Assert( errFCBTooManyOpen != err );
				Assert( errFCBAboveThreshold != err );
				}
			else
				{
				if ( err == errFCBTooManyOpen )
					{
					/*	clean versions in order to make more FCBs avaiable
					/*	for reuse.  This must be done since FCBs are referenced
					/*	by version and can only be cleaned when the cVersion
					/*	count in the FCB is 0.
					/**/
					VERSignalCleanup( ppib );
					UtilSleep( 10 );

					fCleanupPerformed = fTrue;	// May only attempt cleanup once.
					goto RetrieveFCB;
					}
				}
			}
		}
	else
		{
		if ( fFCBStateInitialized == fState )
			{
			Assert( pfcb->WRefCount() >= 1);
			err = ErrBTOpen( ppib, pfcb, ppfucb );

			// Cursor has been opened on FCB, so refcount should be
			// at least 2 (one for cursor, one for call to PfcbFCBGet()).
			// (if ErrBTOpen returns w/o error)
			Assert( pfcb->WRefCount() > 1 || (1 == pfcb->WRefCount() && err < JET_errSuccess) );

			pfcb->Release();
			}		
		else
			{
			Assert( fFCBStateSentinel == fState );
			Assert( rgfmp[ ifmp ].Dbid() != dbidTemp );		// Sentinels not used by sort/temp. tables.

			// If we encounter a sentinel, it means the
			// table has been locked for subsequent deletion.
			err = ErrERRCheck( JET_errTableLocked );
			}
		}
		
	return err;
	}


//	*************************************************
//	movement operations
//

//	positions cursor on root page of tree
//	this is root page of data/index for user cursors
//		and root of AvailExt or OwnExt trees for Space cursors
//	page is latched Read or RIW
//
ERR ErrBTIGotoRoot( FUCB *pfucb, LATCH latch )
	{
	ERR		err;
	
	//	should have no page latched
	//
	Assert( !Pcsr( pfucb )->FLatched() );

	CallR( Pcsr( pfucb )->ErrGetPage( pfucb->ppib, 
									  pfucb->ifmp,
									  PgnoRoot( pfucb ),
									  latch,
									  pfucb->u.pfcb->Tableclass(),
									  PBFLatchHintPgnoRoot( pfucb )
									  ) );
	Pcsr( pfucb )->SetILine( 0 );
	
	return JET_errSuccess;
	}


ERR ErrBTIOpenAndGotoRoot( PIB *ppib, const PGNO pgnoFDP, const IFMP ifmp, FUCB **ppfucb )
	{
	ERR		err;
	FUCB	*pfucb;
	
	CallR( ErrBTIOpen( ppib, ifmp, pgnoFDP, objidNil, openNormal, &pfucb ) );
	Assert( pfucbNil != pfucb );
	Assert( pfcbNil != pfucb->u.pfcb );
	Assert( pfucb->u.pfcb->FInitialized() );

	err = ErrBTIGotoRoot( pfucb, latchRIW );
	if ( err < JET_errSuccess )
		{
		BTClose( pfucb );
		}
	else
		{
		Assert( latchRIW == Pcsr( pfucb )->Latch() );
		Assert( pcsrNil == pfucb->pcsrRoot );
		pfucb->pcsrRoot = Pcsr( pfucb );

		*ppfucb = pfucb;
		}

	return err;
	}


//	this is the uncommon case in the refresh logic
//	where we lost physical currency on page
//
ERR	ErrBTIIRefresh( FUCB *pfucb, LATCH latch )
	{
	ERR		err;
	
	DBTIME	dbtimeLast = Pcsr( pfucb )->Dbtime();

	Assert( !Pcsr( pfucb )->FLatched() );
	Assert( !pfucb->bmCurr.key.FNull() );
	Assert( latchReadTouch == latch || latchReadNoTouch == latch ||
			latchRIW == latch );
			
	if ( pgnoNull != Pcsr( pfucb )->Pgno() )
		{
		//	get page latched as per request
		//
		Call( Pcsr( pfucb )->ErrGetPage( pfucb->ppib, 
										 pfucb->ifmp, 
										 Pcsr( pfucb )->Pgno(),
										 latch,
										 pfucb->u.pfcb->Tableclass() ) );

		//	check if DBTime of page is same as last seen by CSR
		//
		if ( Pcsr( pfucb )->Dbtime() == dbtimeLast )
			{
			//	page is same as last seen by cursor
			//
			Assert( Pcsr( pfucb )->Cpage().FLeafPage() );
			Assert( Pcsr( pfucb )->Cpage().ObjidFDP() == ObjidFDP( pfucb ) );
			NDGet( pfucb );
			
			AssertNDGet( pfucb );
			return JET_errSuccess;
			}

		Assert( Pcsr( pfucb )->Dbtime() > dbtimeLast );

		//	check if node still belongs to latched page
		//
		Call( ErrBTISeekInPage( pfucb, pfucb->bmCurr ) );

		if ( JET_errSuccess == err )
			{
			goto HandleError;
			}
		else
			{
			//	smart refresh did not work
			//	use bookmark to seek to node
			//
			BTUp( pfucb );

			if ( wrnNDFoundGreater == err || wrnNDFoundLess == err )
				{
				err = ErrERRCheck( JET_errRecordDeleted );
				goto HandleError;
				}
			}

		Assert( wrnNDNotFoundInPage == err );
		}
				
	//	Although the caller said no need to touch, but the buffer of the bookmark
	//	never touched before, refresh as touch.

	if ( latch == latchReadNoTouch && pfucb->fTouch )
		latch = latchReadTouch;

	Call( ErrBTGotoBookmark( pfucb, pfucb->bmCurr, latch ) );

	pfucb->fTouch = fFalse;

	AssertNDGet( pfucb );

HandleError:
	if ( err >= 0 )
		{
		CallS( err );
		Assert( Pcsr( pfucb )->Cpage().FLeafPage() );
		Assert( Pcsr( pfucb )->Cpage().ObjidFDP() == ObjidFDP( pfucb ) );
		AssertNDGet( pfucb );
		}
		
	return err;
	}


//	deletes a node and blows it away
//	performs single-page cleanup or multipage cleanup, if possible
//	this is called from VER cleanup or other cleanup threads
//
ERR ErrBTDelete( FUCB *pfucb, const BOOKMARK& bm )
	{
	ASSERT_VALID( &bm );
	Assert( !Pcsr( pfucb )->FLatched( ) );
	Assert( !FFUCBSpace( pfucb ) );
	Assert( dbidTemp != rgfmp[pfucb->ifmp].Dbid() );

	ERR		err;

	PERFIncCounterTable( cBTDelete, PinstFromPfucb( pfucb ), pfucb->u.pfcb->Tableclass() );

	//	try to delete node, if multi-page operation is not needed
	//
	CallR( ErrBTISinglePageCleanup( pfucb, bm ) );
	Assert( !Pcsr( pfucb )->FLatched() );

	if ( wrnBTMultipageOLC == err )
		{
		//	multipage operations are needed to cleanup page
		//
		err = ErrBTIMultipageCleanup( pfucb, bm );
		if ( errBTMergeNotSynchronous == err )
			{
			//	ignore merge conflicts
			err = JET_errSuccess;
			}
		}

	return err;
	}


//  ================================================================
ERR ErrBTMungeSLVSpace( FUCB * const pfucb,
						const SLVSPACEOPER slvspaceoper,
						const LONG ipage,
						const LONG cpages,
						const DIRFLAG dirflag,
						const QWORD fileid,
						const QWORD cbAlloc,
						const wchar_t* const wszFileName )
//  ================================================================
//
//  Transition the given range of pages from one state to another 
//  in the SLV space tree. The FUCB be pointing to the write-latched
//  SLVSPACENODE
//
//-
	{
	ASSERT_VALID( pfucb );
	Assert( latchWrite == Pcsr( pfucb )->Latch() );
	Assert( pfucb->kdfCurr.data.Cb() == sizeof( SLVSPACENODE ) );
	Assert( pfucb->kdfCurr.key.Cb() == sizeof( PGNO ) );

	const BOOL fVersion	= !( dirflag & fDIRNoVersion ) && !rgfmp[pfucb->ifmp].FVersioningOff();

	ERR 	err 	= JET_errSuccess;
	RCEID 	rceid 	= rceidNull;
	RCE		*prce	= prceNil;

	//  We'll need the bookmark to create the version
	CallR( ErrBTISaveBookmark( pfucb ) );

	//  Create the version
	
	if( fVersion )
		{
		VERSLVSPACE	verslvspace;
		verslvspace.oper 	= slvspaceoper;
		verslvspace.ipage	= ipage;
		verslvspace.cpages	= cpages;
		verslvspace.fileid	= fileid;
		verslvspace.cbAlloc	= cbAlloc;

		SIZE_T cbFileName = ( wcslen( wszFileName ) + 1 ) * sizeof( wchar_t );
		UtilMemCpy( verslvspace.wszFileName, wszFileName, cbFileName );

		//  these are only used by rollback
		Assert( slvspaceoperFree != verslvspace.oper );
		Assert( slvspaceoperDeletedToCommitted != verslvspace.oper );
		Assert( slvspaceoperDeletedToFree != verslvspace.oper );
		Assert( slvspaceoperFreeReserved != verslvspace.oper );

		const KEYDATAFLAGS kdfSave = pfucb->kdfCurr;
		
		pfucb->kdfCurr.data.SetPv( &verslvspace );
		pfucb->kdfCurr.data.SetCb( OffsetOf( VERSLVSPACE, wszFileName ) + cbFileName );
		
		VER * const pver = PverFromIfmp( pfucb->ifmp );
		err = pver->ErrVERModify( pfucb, pfucb->bmCurr, operSLVSpace, &prce, NULL );

		pfucb->kdfCurr = kdfSave;

		Call( err );
		
		Assert( prceNil != prce );
		rceid = Rceid( prce );
		Assert( rceidNull != rceid );
		}

	Call( ErrNDMungeSLVSpace(
				pfucb,
				Pcsr( pfucb ),
				slvspaceoper,
				ipage,
				cpages,
				dirflag,
				rceid ) );

	if( prceNil != prce )
		{
		Assert( rceidNull != rceid );
		Assert( fVersion );
		Assert( Pcsr( pfucb )->FLatched() );
		VERInsertRCEIntoLists( pfucb, Pcsr( pfucb ), prce, NULL );
		}
#ifdef DEBUG
	else
		{
		Assert( !fVersion );
		}
#endif	//	DEBUG

	Assert( Pcsr( pfucb )->FLatched() );
	Assert( err >= 0 );

	return err;
		
HandleError:
	Assert( err < 0 );
	Assert( Pcsr( pfucb )->FLatched() );
	if( prceNil != prce )
		{
		Assert( fVersion );
		VERNullifyFailedDMLRCE( prce );
		}

	BTUp( pfucb );
	return err;
	}


//	returns number of bytes to leave free in page
//	to satisfied density constraint
//
INLINE INT CbBTIFreeDensity( const FUCB *pfucb )
	{
	Assert( pfucb->u.pfcb != pfcbNil );
	return ( (INT) pfucb->u.pfcb->CbDensityFree() );
	}


//	returns required space for inserting a node into given page
//	used by split for estimating cbReq for internal page insertions
//
LOCAL ULONG CbBTICbReq( FUCB *pfucb, CSR *pcsr, const KEYDATAFLAGS& kdf )
	{
	Assert( pcsr->Latch() == latchRIW );
	Assert( !pcsr->Cpage().FLeafPage() );
	Assert( sizeof( PGNO )== kdf.data.Cb() );

	//	temporary kdf to accommodate 
	KEYDATAFLAGS	kdfT = kdf;
	
	//	get prefix from page
	//
	const INT	cbCommon = CbNDCommonPrefix( pfucb, pcsr, kdf.key );

	if ( cbCommon > cbPrefixOverhead )
		{
		kdfT.key.prefix.SetCb( cbCommon );
		#ifdef	DEBUG
		kdfT.key.prefix.SetPv( (VOID *)lBitsAllFlipped );
		#endif
		kdfT.key.suffix.SetCb( kdf.key.Cb() - cbCommon );
		kdfT.fFlags = fNDCompressed;
		}
	else
		{
		kdfT.key.prefix.SetCb( 0 );
		kdfT.key.suffix.SetCb( kdf.key.Cb() );
		}

	const	ULONG	cbReq = CbNDNodeSizeCompressed( kdfT );
	return cbReq;
	}


//	returns cbCommon for given key 
//	with respect to prefix in page
//
INT	CbNDCommonPrefix( FUCB *pfucb, CSR *pcsr, const KEY& key )
	{
	Assert( pcsr->FLatched() );
	
	//	get prefix from page
	//
	NDGetPrefix( pfucb, pcsr );
	Assert( pfucb->kdfCurr.key.suffix.Cb() == 0 );

	const ULONG	cbCommon = CbCommonKey( key, pfucb->kdfCurr.key );

	return cbCommon;
	}
	
	
//	computes prefix for a given key with respect to prefix key in page
//	reorganizes key in given kdf to reflect prefix
//
VOID BTIComputePrefix( FUCB 		*pfucb, 
					   CSR 			*pcsr, 
					   const KEY& 	key, 
					   KEYDATAFLAGS	*pkdf )
	{
	Assert( key.prefix.Cb() == 0 );
	Assert( pkdf->key.prefix.FNull() );
	Assert( pcsr->FLatched() );

	INT		cbCommon = CbNDCommonPrefix( pfucb, pcsr, key );

	if ( cbCommon > cbPrefixOverhead )
		{
		//	adjust inserted key to reflect prefix
		//
		pkdf->key.prefix.SetCb( cbCommon );
		pkdf->key.prefix.SetPv( key.suffix.Pv() );
		pkdf->key.suffix.SetCb( key.suffix.Cb() - cbCommon );
		pkdf->key.suffix.SetPv( (BYTE *)key.suffix.Pv() + cbCommon );

		pkdf->fFlags = fNDCompressed;
		}
	else
		{
		}

	return; 
	}

	
//	decides if a particular insert should be treated as an append
//
INLINE BOOL FBTIAppend( const FUCB *pfucb, CSR *pcsr, ULONG cbReq, const BOOL fUpdateUncFree )
	{
	Assert( cbReq <= cbNDPageAvailMost );
	Assert( cbNDPageAvailMost > 0 );
	Assert( pcsr->FLatched() );

	//	adjust cbReq for density constraint
	//
	if ( pcsr->Cpage().FLeafPage()
		&& !pcsr->Cpage().FSpaceTree() )		//	100% density on space trees
		{
		cbReq += CbBTIFreeDensity( pfucb );
		}
		
	//	last page in tree
	//	inserting past the last node in page
	//	and inserting a node of size cbReq violates density contraint
	//
	return ( pgnoNull == pcsr->Cpage().PgnoNext()
			&& pcsr->ILine() == pcsr->Cpage().Clines()
			&& !FNDFreePageSpace( pfucb, pcsr, cbReq, fUpdateUncFree ) );
	}


INLINE BOOL FBTISplit( const FUCB *pfucb, CSR *pcsr, const ULONG cbReq, const BOOL fUpdateUncFree )
	{
	return !FNDFreePageSpace( pfucb, pcsr, cbReq, fUpdateUncFree );
	}
	
	
//	finds max size of node in pfucb->kdfCurr
//	checks version store to find reserved space for
//	uncommitted nodes
//
LOCAL ULONG CbBTIMaxSizeOfNode( const FUCB * const pfucb, const CSR * const pcsr )	
	{
	if ( FNDPossiblyVersioned( pfucb, pcsr ) )
		{
		BOOKMARK	bm;
		INT			cbData;

		NDGetBookmarkFromKDF( pfucb, pfucb->kdfCurr, &bm );			
		cbData = CbVERGetNodeMax( pfucb, bm );

		if ( cbData >= pfucb->kdfCurr.data.Cb() )
			{
			return CbNDNodeSizeTotal( pfucb->kdfCurr ) - pfucb->kdfCurr.data.Cb() + cbData;
			}
		}
	
	return CbNDNodeSizeTotal( pfucb->kdfCurr );
	}


//	split page and perform operation
//	update operation to be be performed can be
//		Insert:		node to insert is in kdf
//		Replace:	data to replace with is in kdf
//		FlagInsertAndReplaceData:	node to insert is in kdf
//					[for unique trees that
//					 already have a flag-deleted node
//					 with the same key]
//
//	cursor is placed on node to replace, or insertion point
//	
ERR ErrBTISplit( FUCB		 	* const pfucb, 
				 KEYDATAFLAGS	* const pkdf,
				 const DIRFLAG	dirflagT,
				 const RCEID	rceid1,
				 const RCEID	rceid2,
				 RCE			* const prceReplace,
				 const INT		cbDataOld,
				 const VERPROXY	* const pverproxy
				 )
	{
	ERR			err;
	BOOL		fOperNone 	= fFalse;
	SPLITPATH	*psplitPath = NULL;
	LGPOS		lgpos;
	INST		*pinst = PinstFromIfmp( pfucb->ifmp );
	
	Assert( rceid2 == Rceid( prceReplace ) 
			|| rceid1 == Rceid( prceReplace ) );
	
	//	copy flags into local, since it can be changed by SelectSplitPath
	//
	DIRFLAG		dirflag 	= dirflagT;
	BOOL		fVersion	= !( dirflag & fDIRNoVersion ) && !rgfmp[ pfucb->ifmp ].FVersioningOff();
	const BOOL	fLogging	= !( dirflag & fDIRNoLog ) && rgfmp[pfucb->ifmp].FLogOn();
		
	ASSERT_VALID( pkdf );

#ifdef DEBUG
	Assert( !fVersion || rceidNull != rceid1 );
	Assert( pfucb->ppib->level > 0 || !fVersion );
	Assert( dirflag & fDIRInsert ||
			dirflag & fDIRReplace ||
			dirflag & fDIRFlagInsertAndReplaceData );
	Assert( !( dirflag & fDIRInsert && dirflag & fDIRReplace ) );
	if ( NULL != pverproxy )
		{
		Assert( !PinstFromIfmp( pfucb->ifmp )->m_plog->m_fRecovering );
		Assert( proxyCreateIndex == pverproxy->proxy );
		}
	Assert( pkdf->key.prefix.FNull() );
#endif	//	DEBUG

	//	seek from root
	//	RIW latching all intermediate pages
	//		and right sibling of leaf page
	//	also retry the operation
	//
	err = ErrBTICreateSplitPathAndRetryOper(
				pfucb,
				pkdf,
				&psplitPath,
				&dirflag,
				rceid1,
				rceid2,
				prceReplace,
				pverproxy );
	
	if ( JET_errSuccess == err )
		{
		Assert( psplitPath != NULL ) ;
		//	performed operation successfully
		//	set cursor to leaf page,
		//	release splitPath and return
		//
		const INT	ilineT		= psplitPath->csr.ILine();
		*Pcsr( pfucb ) = psplitPath->csr;
		Pcsr( pfucb )->SetILine( ilineT );
		Assert( Pcsr( pfucb )->FLatched() );
		goto HandleError;
		}
	else if ( err != errPMOutOfPageSpace )
		{
		Assert( err < 0 );
		Call( err );
		}
	
	Assert( psplitPath != NULL ) ;
	
	//	select split 
	//		-- this selects split of parents too
	//
	Call( ErrBTISelectSplit( pfucb, psplitPath, pkdf, dirflag ) );
	BTISplitCheckPath( psplitPath );
	if ( NULL == psplitPath->psplit ||
		 splitoperNone == psplitPath->psplit->splitoper )
		{
		//	save err if operNone
		//
		fOperNone = fTrue;
		}

	//	get new pages
	//
	Call( ErrBTIGetNewPages( pfucb, psplitPath ) );

	//	release latch on unnecessary pages
	//
	BTISplitReleaseUnneededPages( pinst, &psplitPath );
	Assert( psplitPath->psplit != NULL );
	
	//	write latch remaining pages in order
	//	flag pages dirty and set each with max dbtime of the pages
	//
	Call( ErrBTISplitUpgradeLatches( pfucb->ifmp, psplitPath ) );

	//	The logging code will log the iline currently in the CSR of the
	//	psplitPath. The iline is ignored for recovery, but its nice to
	//	have it set to something sensible for debugging

	psplitPath->csr.SetILine( psplitPath->psplit->ilineOper );	

	//	log split -- macro logging for whole split
	//
	if ( fLogging )
		{
		err = ErrLGSplit( pfucb, 
					  psplitPath, 
					  *pkdf, 
					  rceid1, 
					  rceid2,
					  dirflag, 
					  &lgpos,
					  pverproxy );
					  
		// on error, return to before dirty dbtime on all pages
		if ( JET_errSuccess > err )
			{
			BTISplitRevertDbtime( psplitPath );
			}
			
		Call ( err );		
		}
		
	BTISplitSetLgpos( psplitPath, lgpos );

	//	NOTE: after logging succeeds, nothing should fail...
	//
	if ( prceNil != prceReplace && !fOperNone )
		{
		const INT cbData 	= pkdf->data.Cb();
		
		//	set uncommitted freed space for shrinking node
		VERSetCbAdjust( Pcsr( pfucb ), prceReplace, cbData, cbDataOld, fDoNotUpdatePage );
		}

	//	perform split
	//	insert parent page pointers
	//	fix sibling page pointers at leaf
	//	move nodes
	//	set dependencies
	//
	BTIPerformSplit( pfucb, psplitPath, pkdf, dirflag );

	BTICheckSplits( pfucb, psplitPath, pkdf, dirflag );

	//	move cursor to leaf page [write-latched]
	//	and iLine to operNode
	//
	BTISplitSetCursor( pfucb, psplitPath );
	
	//	release all splitPaths
	//
	BTIReleaseSplitPaths( pinst, psplitPath );

	if ( fOperNone )
		{
		Assert( !Pcsr( pfucb )->FLatched() );
		err = ErrERRCheck( errBTOperNone );

		if( prceNil != prceReplace )
			{
			//  UNDONE: we don't have to nullify the RCE here. We could keep it and reuse it. No-one
			//  else can alter the node because we have a version on it.
			Assert( fVersion );
			VERNullifyFailedDMLRCE( prceReplace );
			}		
		}
	else
		{
		Assert( Pcsr( pfucb )->FLatched() );
		}

	return err;

HandleError:		
	//	release splitPath
	//
	if ( psplitPath != NULL )
		{
		BTIReleaseSplitPaths( pinst, psplitPath );
		}
		
	return err;
	}


//	creates path of RIW-latched pages from root for split to work on
//	if DBTime or leaf pgno has changed after RIW latching path,
//		retry operation
//
ERR	ErrBTICreateSplitPathAndRetryOper( FUCB 			* const pfucb,
									   const KEYDATAFLAGS * const pkdf,
									   SPLITPATH 		**ppsplitPath,
									   DIRFLAG	* const pdirflag,
									   const RCEID rceid1,
									   const RCEID rceid2,
									   const RCE * const prceReplace,
									   const VERPROXY * const pverproxy )
	{
	ERR			err;
	BOOKMARK	bm;
	PGNO		pgnoSplit = Pcsr( pfucb )->Pgno();
	DBTIME		dbtimeLast = Pcsr( pfucb )->Dbtime();

	Assert( Pcsr( pfucb )->FLatched() );
	Assert( NULL == pfucb->pvRCEBuffer );
	Pcsr( pfucb )->ReleasePage();

	//	initialize bookmark to seek for
	//
	NDGetBookmarkFromKDF( pfucb, *pkdf, &bm );

	if ( *pdirflag & fDIRInsert )
		{
		Assert( bm.key.Cb() == pkdf->key.Cb() );
		//	[ldb 4/30/96]: assert below _may_ go off wrongly. possibly use CmpBm == 0
		Assert( bm.key.suffix.Pv() == pkdf->key.suffix.Pv() );
		Assert( bm.key.prefix.FNull() );
		}
	else if ( *pdirflag & fDIRFlagInsertAndReplaceData )
		{
		Call( ErrBTISaveBookmark( pfucb, bm, fFalse ) );
		}
	else
		{
		//	get key from cursor
		//
		Assert( *pdirflag & fDIRReplace );
		bm.key = pfucb->bmCurr.key;
		}

	Call( ErrBTICreateSplitPath( pfucb, bm, ppsplitPath ) );
	Assert( (*ppsplitPath)->csr.Cpage().FLeafPage() );

	//	set iline to point of insert
	//
	if ( wrnNDFoundLess == err )
		{
		Assert( (*ppsplitPath)->csr.Cpage().Clines() - 1 ==  (*ppsplitPath)->csr.ILine() );
		(*ppsplitPath)->csr.SetILine( (*ppsplitPath)->csr.Cpage().Clines() );
		}

	//	retry operation if timestamp / pgno has changed
	//
	if ( (*ppsplitPath)->csr.Pgno() != pgnoSplit ||
		 (*ppsplitPath)->csr.Dbtime() != dbtimeLast )
		{
		CSR		*pcsr = &(*ppsplitPath)->csr;
		
		if ( fDIRReplace & *pdirflag )
			{
			//	check if replace fits in page
			//
			AssertNDGet( pfucb, pcsr );
			const INT  cbReq = pfucb->kdfCurr.data.Cb() >= pkdf->data.Cb() ?
								  0 : 
								  pkdf->data.Cb() - pfucb->kdfCurr.data.Cb();
								
			if ( cbReq > 0 && FBTISplit( pfucb, pcsr, cbReq ) )
				{
				err = ErrERRCheck( errPMOutOfPageSpace );
				goto HandleError;
				}
	
			//	upgrade to write latch
			//
			pcsr->UpgradeFromRIWLatch();
			Assert( latchWrite == pcsr->Latch() );

			//	try to replace node data with new data
			//
			err = ErrNDReplace( pfucb, pcsr, &pkdf->data, *pdirflag, rceid1, prceReplace );
			Assert( errPMOutOfPageSpace != err );
			Call( err );
			}
		else
			{
			ULONG	cbReq;
				
			Assert( ( fDIRInsert & *pdirflag ) ||
					( fDIRFlagInsertAndReplaceData & *pdirflag ) );

			//	UNDONE: copy code from BTInsert
			//	set *pdirflag
			//
			//	if seek succeeded
			//		if unique 
			//			flag insert and replace data
			//		else
			//			flag insert
			//	else
			//		insert whole node
			//
			if ( JET_errSuccess == err )
				{
				//	seek succeeded
				//
				//	can not have two nodes with same bookmark (attempts
				//	to do so should have been caught before split)
				//
#ifdef DEBUG
				FUCBResetUpdatable( pfucb );	//  don't reset the version bit in FNDPotVisibleToCursor
				Assert( FNDDeleted( pfucb->kdfCurr ) );
				Assert( !FNDPotVisibleToCursor( pfucb, pcsr ) );
				FUCBSetUpdatable( pfucb );
#endif	//	DEBUG

				if ( FFUCBUnique( pfucb ) )
					{
					Assert( *pdirflag & fDIRFlagInsertAndReplaceData );
					
					//	calcualte space requred
					//	if new data fits, flag insert node and replace data
					//
					cbReq = pkdf->data.Cb() > pfucb->kdfCurr.data.Cb() ?
								pkdf->data.Cb() - pfucb->kdfCurr.data.Cb() :
								0;

					if ( FBTISplit( pfucb, pcsr, cbReq ) )
						{
						err = ErrERRCheck( errPMOutOfPageSpace );
						goto HandleError;
						}

					//	upgrade to write latch
					//
					pcsr->UpgradeFromRIWLatch();
					Assert( latchWrite == pcsr->Latch() );

					//	flag insert node and replace data
					//
					Call( ErrNDFlagInsertAndReplaceData( pfucb, 
														 pcsr,
														 pkdf, 
														 *pdirflag,
														 rceid1,
														 rceid2,
														 prceReplace,
														 pverproxy ) );
					}
				else
					{
					//	should never happen, because:
					//		- if this is an insert, the dupe should
					//		  have been caught by BTInsert() before
					//		  the split
					//		- if this is a flag-insert, it wouldn't
					//		  have caused a split
					//		- FlagInsertAndReplaceData doesn't happen
					//		  on non-unique indexes
					Assert( fFalse );
					Assert( *pdirflag & fDIRInsert );
					Assert( 0 == CmpKeyData( bm, pfucb->kdfCurr ) );

					if ( !FNDDeleted( pfucb->kdfCurr )
						|| FNDPotVisibleToCursor( pfucb, pcsr ) )
						{
						err = ErrERRCheck( JET_errMultiValuedIndexViolation );
						goto HandleError;
						}

					//	upgrade to write latch
					//
					pcsr->UpgradeFromRIWLatch();
					Assert( latchWrite == pcsr->Latch() );

					//	no additional space required
					//
					Assert( fFalse );
					Call( ErrNDFlagInsert( pfucb, pcsr, *pdirflag, rceid1, pverproxy ) );
					}
				}
			else
				{
				//	insert node if it fits
				//
				KEYDATAFLAGS kdfCompressed = *pkdf;

				//  bug #57023, #58638
				//  if we were doing a flag insert and replace data and didn't find the node
				//  then it has been removed. change the operation to an ordinary insert
				*pdirflag &= ~fDIRFlagInsertAndReplaceData;
				*pdirflag |= fDIRInsert;

				BTIComputePrefix( pfucb, pcsr, pkdf->key, &kdfCompressed );
				Assert( !FNDCompressed( kdfCompressed ) || 
						kdfCompressed.key.prefix.Cb() > 0 );
		
				cbReq = CbNDNodeSizeCompressed( kdfCompressed );

				if ( FBTISplit( pfucb, pcsr, cbReq ) || FBTIAppend( pfucb, pcsr, cbReq ) )
					{
					err = ErrERRCheck( errPMOutOfPageSpace );
					goto HandleError;
					}

				//	upgrade to write latch
				//
				pcsr->UpgradeFromRIWLatch();
				Assert( latchWrite == pcsr->Latch() );

				Call( ErrNDInsert( pfucb, pcsr, &kdfCompressed, *pdirflag, rceid1, pverproxy ) );
				}
			}
			
		Assert( errPMOutOfPageSpace != err );
		CallS( err );
		}
	else
		{
		err = ErrERRCheck( errPMOutOfPageSpace );
		}
	
HandleError:
	Assert( errPMOutOfPageSpace != err || 
			latchRIW == (*ppsplitPath)->csr.Latch() );
	return err;
	}


//	creates splitPath of RIW latched pages from root of tree
//	to seeked bookmark
//
LOCAL ERR	ErrBTICreateSplitPath( FUCB 			*pfucb, 
								   const BOOKMARK& 	bm,
								   SPLITPATH 		**ppsplitPath )
	{
	ERR		err;
	BOOL	fLeftEdgeOfBtree	= fTrue;
	BOOL	fRightEdgeOfBtree	= fTrue;
	
	//	create splitPath structure
	//
	CallR( ErrBTINewSplitPath( ppsplitPath ) );
	Assert( NULL != *ppsplitPath );

	//	RIW latch root
	//
	Call( (*ppsplitPath)->csr.ErrGetRIWPage( pfucb->ppib,
											 pfucb->ifmp,
											 PgnoRoot( pfucb ),
											 pfucb->u.pfcb->Tableclass() ) );

	if ( 0 == (*ppsplitPath)->csr.Cpage().Clines() )
		{
		(*ppsplitPath)->csr.SetILine( -1 );
		err = ErrERRCheck( wrnNDFoundLess );
		goto HandleError;
		}

	for ( ; ; )
		{
		Assert( (*ppsplitPath)->csr.Cpage().Clines() > 0 );
		if( fGlobalRepair
			&& FFUCBRepair( pfucb )
			&& bm.key.Cb() == 0 )
			{
			//	when creating a repair tree we want NULL keys to go at the end, not the beginning
			NDMoveLastSon( pfucb, &(*ppsplitPath)->csr );			
			err = ErrERRCheck( wrnNDFoundLess );
			}
		else
			{
			Call( ErrNDSeek( pfucb, 
						 &(*ppsplitPath)->csr,
						 bm ) );
			}

		Assert( (*ppsplitPath)->csr.ILine() < (*ppsplitPath)->csr.Cpage().Clines() );

		if ( (*ppsplitPath)->csr.Cpage().FLeafPage() )
			{
			const SPLITPATH * const		psplitPathParent		= (*ppsplitPath)->psplitPathParent;

			if ( NULL != psplitPathParent )
				{
				Assert( !( (*ppsplitPath)->csr.Cpage().FRootPage() ) );

				const BOOL				fLeafPageIsFirstPage	= ( pgnoNull == (*ppsplitPath)->csr.Cpage().PgnoPrev() );
				const BOOL				fLeafPageIsLastPage		= ( pgnoNull == (*ppsplitPath)->csr.Cpage().PgnoNext() );

				if ( fLeftEdgeOfBtree ^ fLeafPageIsFirstPage )					
					{
					//	if not repair, assert, otherwise, suppress the assert
					//	and repair will just naturally err out
					AssertSz( fGlobalRepair, "Corrupt B-tree: first leaf page has mismatched parent" );
					Call( ErrBTIReportBadPageLink(
								pfucb,
								ErrERRCheck( JET_errBadParentPageLink ),
								psplitPathParent->csr.Pgno(),
								(*ppsplitPath)->csr.Pgno(),
								(*ppsplitPath)->csr.Cpage().PgnoPrev() ) );
					}
				if ( fRightEdgeOfBtree ^ fLeafPageIsLastPage )
					{
					//	if not repair, assert, otherwise, suppress the assert
					//	and repair will just naturally err out
					AssertSz( fGlobalRepair, "Corrupt B-tree: last leaf page has mismatched parent" );
					Call( ErrBTIReportBadPageLink(
								pfucb,
								ErrERRCheck( JET_errBadParentPageLink ),
								psplitPathParent->csr.Pgno(),
								(*ppsplitPath)->csr.Pgno(),
								(*ppsplitPath)->csr.Cpage().PgnoNext() ) );
					}
				}
			else
				{
				Assert( (*ppsplitPath)->csr.Cpage().FRootPage() );
				}

			break;
			}

		Assert( (*ppsplitPath)->csr.Cpage().FInvisibleSons() );
		Assert( !( fRightEdgeOfBtree ^ (*ppsplitPath)->csr.Cpage().FLastNodeHasNullKey() ) );

		fRightEdgeOfBtree = ( fRightEdgeOfBtree
							&& (*ppsplitPath)->csr.ILine() == (*ppsplitPath)->csr.Cpage().Clines() - 1 );
		fLeftEdgeOfBtree = ( fLeftEdgeOfBtree
							&& 0 == (*ppsplitPath)->csr.ILine() );

		//	allocate another splitPath structure for next level
		//
		Call( ErrBTINewSplitPath( ppsplitPath ) );

		//	access child page
		//
		Assert( sizeof( PGNO ) == pfucb->kdfCurr.data.Cb() );
		Call( (*ppsplitPath)->csr.ErrGetRIWPage( 
								pfucb->ppib,
								pfucb->ifmp,
								*(UnalignedLittleEndian< PGNO > *) pfucb->kdfCurr.data.Pv(),
								pfucb->u.pfcb->Tableclass() ) );
		}

HandleError:
	return err;
	}


//	creates a new SPLITPATH structure and initializes it
//		adds newly created splitPath structure to head of list
//		pointed to by *ppSplitPath passed in
//
ERR	ErrBTINewSplitPath( SPLITPATH **ppsplitPath )
	{
	SPLITPATH	*psplitPath;

	psplitPath = static_cast<SPLITPATH *>( PvOSMemoryHeapAlloc( sizeof(SPLITPATH) ) );
	if ( NULL == psplitPath )
		{
		return ErrERRCheck( JET_errOutOfMemory );
		}

	psplitPath->psplitPathParent	= *ppsplitPath;
	psplitPath->psplitPathChild		= NULL;
	psplitPath->psplit				= NULL;
	psplitPath->dbtimeBefore		= dbtimeInvalid;
	new( &psplitPath->csr ) CSR;

	if ( psplitPath->psplitPathParent != NULL )
		{
		Assert( NULL == psplitPath->psplitPathParent->psplitPathChild );
		psplitPath->psplitPathParent->psplitPathChild = psplitPath;
		}

	*ppsplitPath = psplitPath;
	return JET_errSuccess;
	}
	
	
//	selects split at leaf level
//	recursively calls itself to select split at parent level
//		psplitPath is already created and all required pages RIW latched
//
LOCAL ERR ErrBTISelectSplit( FUCB 			*pfucb, 
							 SPLITPATH		*psplitPath,
							 KEYDATAFLAGS	*pkdf,
							 DIRFLAG		dirflag )
	{
	ERR		err;

///	Assert( pkdf->key.prefix.cb == 0 );

	//	create and initialize split structure
	//	and link to psplitPath
	//
	CallR( ErrBTINewSplit( pfucb, psplitPath, pkdf, dirflag ) );
	Assert( psplitPath->psplit != NULL );
	Assert( psplitPath->psplit->psplitPath == psplitPath );

	SPLIT	*psplit = psplitPath->psplit;
	BTIRecalcWeightsLE( psplit );

	//	if root page
	//		select vertical split
	//
	if ( psplitPath->csr.Cpage().FRootPage() )
		{
		BTISelectVerticalSplit( psplit, pfucb );

		//	calculate uncommitted freed space
		//
		BTISplitCalcUncFree( psplit );
	
		Call( ErrBTISplitAllocAndCopyPrefixes( pfucb, psplit ) );
		return JET_errSuccess;
		}

	ULONG	cbReq;
	CSR		*pcsrParent;
	
	//	horizontal split
	//
	//	check if append
	//
	if	( psplit->splitoper == splitoperInsert &&
		  psplit->ilineOper == psplit->clines - 1 &&
		  psplit->psplitPath->csr.Cpage().PgnoNext() == pgnoNull )
		{
		BTISelectAppend( psplit, pfucb );
		}
	else
		{
		//	find split point such that the 
		//	two pages have almost equal weight
		//
		BTISelectRightSplit( psplit, pfucb );
		Assert( psplit->ilineSplit >= 0 );
		}

	//	calculate uncommitted freed space
	//
	BTISplitCalcUncFree( psplit );

	//	copy page flags
	//
	psplit->fNewPageFlags 	= 
	psplit->fSplitPageFlags	= psplitPath->csr.Cpage().FFlags();
	
	//	allocate and copy prefixes
	//
	Call( ErrBTISplitAllocAndCopyPrefixes( pfucb, psplit ) );

	//	compute separator key to insert in parent
	//	allocate space for key and link to psplit
	//
	Call( ErrBTISplitComputeSeparatorKey( psplit, pfucb ) );
	Assert( sizeof( PGNO ) == psplit->kdfParent.data.Cb() );

	//	seek to separator key in parent
	//
	BTISeekSeparatorKey( psplit, pfucb );
	
	//	if insert in parent causes split
	//	call BTSelectSplit recursively
	//
	pcsrParent = &psplit->psplitPath->psplitPathParent->csr;
	cbReq = CbBTICbReq( pfucb, pcsrParent, psplit->kdfParent );

	if ( FBTISplit( pfucb, pcsrParent, cbReq ) )
		{
		Call( ErrBTISelectSplit( pfucb,
								 psplitPath->psplitPathParent,
								 &psplit->kdfParent,
								 dirflag ) );

		if ( NULL == psplitPath->psplitPathParent->psplit || 
			 splitoperNone == psplitPath->psplitPathParent->psplit->splitoper )
			{
			//	somewhere up the tree, split could not bepsplit->kdfParent performed
			//	along with the operation [insert]
			//	so reset psplit at this level
			//
			BTIReleaseSplit( PinstFromIfmp( pfucb->ifmp ), psplit );
			psplitPath->psplit = NULL;
			return err;
			}
		}

	Assert( psplit->ilineSplit < psplit->clines );
	Assert( splittypeAppend == psplit->splittype ||
			FBTISplitCausesNoOverflow( psplit, psplit->ilineSplit ) );
	Assert( psplitPath->psplit != NULL );
	Assert( psplitPath->psplitPathParent != NULL );

HandleError:
	return err;
	}

	
//	allocates a new SPLIT structure
//	initalizes psplit and links it to psplitPath
//
ERR	ErrBTINewSplit(
	FUCB *			pfucb,
	SPLITPATH *		psplitPath,
	KEYDATAFLAGS *	pkdf,
	DIRFLAG			dirflag )
	{
	ERR				err;
	SPLIT *			psplit;
	INT				iLineTo;
	INT				iLineFrom;
	BOOL			fPossibleHotpoint		= fFalse;
	VOID *			pvHighest				= NULL;

	Assert( psplitPath != NULL );
	Assert( psplitPath->psplit == NULL );

	//	allocate split structure
	//
	psplit = static_cast<SPLIT *>( PvOSMemoryHeapAlloc( sizeof(SPLIT) ) );
	if ( psplit == NULL )
		{
		return ErrERRCheck( JET_errOutOfMemory );
		}
	memset( (BYTE *)psplit, 0, sizeof(SPLIT) );
	new( &psplit->csrRight ) CSR;
	new( &psplit->csrNew ) CSR;

	psplit->dbtimeRightBefore = dbtimeInvalid;
	
	psplit->prefixinfoSplit.Nullify();
	psplit->prefixinfoNew.Nullify();

	psplit->pgnoSplit = psplitPath->csr.Pgno();
	
	//	initialize split structure
	//	and link to psplitPath
	//
	if ( psplitPath->csr.Cpage().FLeafPage( ) &&
		 pgnoNull != psplitPath->csr.Cpage().PgnoNext() )
		{
		//	set right page
		//
		Assert( !psplitPath->csr.Cpage().FRootPage( ) );
		Call( psplit->csrRight.ErrGetRIWPage( 
										pfucb->ppib,
										pfucb->ifmp,
										psplitPath->csr.Cpage().PgnoNext( ),
										pfucb->u.pfcb->Tableclass() ) );
		if ( psplit->csrRight.Cpage().PgnoPrev() != psplit->pgnoSplit )
			{
			//	if not repair, assert, otherwise, suppress the assert and
			//	repair will just naturally err out
			AssertSz( fGlobalRepair, "Corrupt B-tree: bad leaf page links detected on Split" );
			Call( ErrBTIReportBadPageLink(
					pfucb,
					ErrERRCheck( JET_errBadPageLink ),
					psplit->pgnoSplit,
					psplit->csrRight.Pgno(),
					psplit->csrRight.Cpage().PgnoPrev() ) );
			}
		}
	else
		{
		Assert( pgnoNull == psplit->csrRight.Pgno() );
		}

	psplit->psplitPath = psplitPath;

	//	get operation
	//	this will be corrected later to splitoperNone (for leaf pages only)
	//	if split can not still satisfy space requested for operation
	//
	if ( psplitPath->csr.Cpage().FInvisibleSons( ) )
		{
		//	internal pages have only insert operation
		//
		psplit->splitoper = splitoperInsert;
		}
	else if ( dirflag & fDIRInsert )
		{
		Assert( !( dirflag & fDIRReplace ) );
		Assert( !( dirflag & fDIRFlagInsertAndReplaceData ) );
		psplit->splitoper = splitoperInsert;

		//	must have at least two existing nodes to establish a hotpoint pattern
		fPossibleHotpoint = ( !psplitPath->csr.Cpage().FRootPage()
							&& psplitPath->csr.ILine() >= 2 );
		}
	else if ( dirflag & fDIRReplace )
		{
		Assert( !( dirflag & fDIRFlagInsertAndReplaceData ) );
		psplit->splitoper = splitoperReplace;
		}
	else
		{
		Assert( dirflag & fDIRFlagInsertAndReplaceData );
		psplit->splitoper = splitoperFlagInsertAndReplaceData;
		}

	//	allocate line info
	//
	psplit->clines = psplitPath->csr.Cpage().Clines();

	if ( splitoperInsert == psplit->splitoper )
		{
		//	insert needs one more line for inserted node
		//
		psplit->clines++;
		}

	//  allocate one more entry than we need so that BTISelectPrefix can use a sentinel value
	psplit->rglineinfo = new LINEINFO[psplit->clines + 1];	

	if ( NULL == psplit->rglineinfo )
		{
		err = ErrERRCheck( JET_errOutOfMemory );
		goto HandleError;
		}

	//	psplitPath->csr is positioned at point of insert/replace
	//
	Assert( splitoperInsert == psplit->splitoper && 
			psplitPath->csr.Cpage().Clines() >= psplitPath->csr.ILine() ||
			psplitPath->csr.Cpage().Clines() > psplitPath->csr.ILine() );

	psplit->ilineOper = psplitPath->csr.ILine();

	for ( iLineFrom = 0, iLineTo = 0; iLineTo < psplit->clines; iLineTo++ )
		{
		if ( psplit->ilineOper == iLineTo && 
			 splitoperInsert == psplit->splitoper )
			{
			//	place to be inserted node here
			//
			psplit->rglineinfo[iLineTo].kdf = *pkdf;
			psplit->rglineinfo[iLineTo].cbSizeMax = 
			psplit->rglineinfo[iLineTo].cbSize = 
					CbNDNodeSizeTotal( *pkdf );

			if ( fPossibleHotpoint )
				{
				Assert( iLineTo >= 2 );

				//	verify last two nodes before insertion point are
				//	currently last two nodes physically in page
				if ( psplit->rglineinfo[iLineTo-2].kdf.key.suffix.Pv() > pvHighest
					&& psplit->rglineinfo[iLineTo-1].kdf.key.suffix.Pv() > psplit->rglineinfo[iLineTo-2].kdf.key.suffix.Pv() )
					{
					//	need to guarantee that nodes after
					//	the insert point are all physically
					//	located before the nodes in the
					//	the hotpoint area
					pvHighest = psplit->rglineinfo[iLineTo-2].kdf.key.suffix.Pv();
					}
				else
					{
					fPossibleHotpoint = fFalse;
					}
				}

			//	do not increment iLineFrom
			//
			continue;
			}

		//	get node from page
		//	
		psplitPath->csr.SetILine( iLineFrom );

		NDGet( pfucb, &psplitPath->csr );

		if ( iLineTo == psplit->ilineOper )
			{
			//	get key from node
			//	and data from parameter
			//
			Assert( splitoperInsert != psplit->splitoper );
			Assert( splitoperNone != psplit->splitoper );

			//	hotpoint is dealt with above
			Assert( !fPossibleHotpoint );

			psplit->rglineinfo[iLineTo].kdf.key		= pfucb->kdfCurr.key;
			psplit->rglineinfo[iLineTo].kdf.data	= pkdf->data;
			psplit->rglineinfo[iLineTo].kdf.fFlags	= pfucb->kdfCurr.fFlags;

			ULONG	cbMax 		= CbBTIMaxSizeOfNode( pfucb, &psplitPath->csr );
			ULONG	cbSize		= CbNDNodeSizeTotal( psplit->rglineinfo[iLineTo].kdf );

			psplit->rglineinfo[iLineTo].cbSizeMax = max( cbSize, cbMax );

			//	there should be no uncommitted version for node
			//
			Assert( cbSize != cbMax || CbNDReservedSizeOfNode( pfucb, &psplitPath->csr ) == 0 );
			}
		else
			{
			psplit->rglineinfo[iLineTo].kdf			= pfucb->kdfCurr;
			psplit->rglineinfo[iLineTo].cbSizeMax	= CbBTIMaxSizeOfNode( pfucb, &psplitPath->csr );

			if ( fPossibleHotpoint )
				{
				if ( iLineTo < psplit->ilineOper - 2 )
					{
					//	for nodes before the hotpoint area, keep track
					//	of highest physical location
					pvHighest = max( pvHighest, pfucb->kdfCurr.key.suffix.Pv() );
					}
				else if ( iLineTo > psplit->ilineOper )
					{
					//	for nodes after insertion point, ensure
					//	all are physically located before nodes in hotpoint area
					fPossibleHotpoint = pfucb->kdfCurr.key.suffix.Pv() < pvHighest;
					}
				}

#ifdef DEBUG
			const ULONG		cbMax 		= CbBTIMaxSizeOfNode( pfucb, &psplitPath->csr );
			const ULONG		cbReserved 	= CbNDReservedSizeOfNode( pfucb, &psplitPath->csr );
			const ULONG		cbSize		= CbNDNodeSizeTotal( pfucb->kdfCurr );

			Assert( cbMax >= cbSize + cbReserved );
#endif
			}

		psplit->rglineinfo[iLineTo].cbSize = 
					CbNDNodeSizeTotal( psplit->rglineinfo[iLineTo].kdf );

		Assert( iLineFrom <= iLineTo );
		Assert(	iLineFrom + 1 >= iLineTo );

		iLineFrom++;
		}

	if ( fPossibleHotpoint )
		{
		Assert( psplitPath->csr.Cpage().FLeafPage( ) );
		Assert( splitoperInsert == psplit->splitoper );
		Assert( psplit->ilineOper >= 2 );
		Assert( psplit->clines >= 3 );
		Assert( !psplit->fHotpoint );
		psplit->fHotpoint = fTrue;
		}

	psplitPath->psplit = psplit;
	return JET_errSuccess;

HandleError:
	BTIReleaseSplit( PinstFromIfmp( pfucb->ifmp ), psplit );
	Assert( psplitPath->psplit == NULL );
	return err;
	}
	

//	calculates 
//		size of all nodes to the left of a node
//			using size of nodes already collected
//		maximum size of nodes possible due to rollback
//		size of common key with previous node
//		cbUncFree in the source and dest pages
//			using info collected
//
VOID BTIRecalcWeightsLE( SPLIT *psplit )
	{
	INT		iline;
	Assert( psplit->clines > 0 );

	psplit->rglineinfo[0].cbSizeLE = psplit->rglineinfo[0].cbSize;
	psplit->rglineinfo[0].cbSizeMaxLE = psplit->rglineinfo[0].cbSizeMax;
	psplit->rglineinfo[0].cbCommonPrev = 0;
	psplit->rglineinfo[0].cbPrefix = 0;
	for ( iline = 1; iline < psplit->clines; iline++ )
		{
		Assert( CbNDNodeSizeTotal( psplit->rglineinfo[iline].kdf ) ==
				psplit->rglineinfo[iline].cbSize );
				
		psplit->rglineinfo[iline].cbSizeLE = 
			psplit->rglineinfo[iline-1].cbSizeLE + 
			psplit->rglineinfo[iline].cbSize;

		psplit->rglineinfo[iline].cbSizeMaxLE = 
			psplit->rglineinfo[iline-1].cbSizeMaxLE + 
			psplit->rglineinfo[iline].cbSizeMax;

		const INT	cbCommonKey = 
						CbCommonKey( psplit->rglineinfo[iline].kdf.key,
									 psplit->rglineinfo[iline - 1].kdf.key );

		psplit->rglineinfo[iline].cbCommonPrev = 
						cbCommonKey > cbPrefixOverhead ?
							cbCommonKey - cbPrefixOverhead :
							0;

		psplit->rglineinfo[0].cbPrefix = 0;
		}

	Assert( iline == psplit->clines );
	}


//	calculates cbUncommitted for split and new pages
//
VOID BTISplitCalcUncFree( SPLIT *psplit )
	{
	Assert( psplit->ilineSplit > 0 || 
			splittypeVertical == psplit->splittype );
	psplit->cbUncFreeDest = SHORT( ( psplit->rglineinfo[psplit->clines - 1].cbSizeMaxLE -
							  psplit->rglineinfo[psplit->clines - 1].cbSizeLE ) -
							( splittypeVertical == psplit->splittype ? 
								0 :
								( psplit->rglineinfo[psplit->ilineSplit - 1].cbSizeMaxLE - 
								  psplit->rglineinfo[psplit->ilineSplit - 1].cbSizeLE ) ) );

	psplit->cbUncFreeSrc = SHORT( ( splittypeVertical == psplit->splittype ? 
								0 :
								( psplit->rglineinfo[psplit->ilineSplit - 1].cbSizeMaxLE - 
								  psplit->rglineinfo[psplit->ilineSplit - 1].cbSizeLE ) ) );
								  
	Assert( splittypeAppend != psplit->splittype || 0 == psplit->cbUncFreeDest );
	Assert( psplit->cbUncFreeSrc <= psplit->psplitPath->csr.Cpage().CbUncommittedFree() );
			
	Assert( psplit->psplitPath->csr.Cpage().FLeafPage() ||
			0 == psplit->cbUncFreeSrc && 0 == psplit->cbUncFreeDest );
	return;
	}
	
//	selects vertical split
//	if oper can not be performed with split,
//		selects vertical split with operNone
//		
VOID BTISelectVerticalSplit( SPLIT *psplit, FUCB *pfucb )
	{
	Assert( psplit->psplitPath->csr.Pgno() == PgnoRoot( pfucb ) );
	
	psplit->splittype	= splittypeVertical;
	psplit->ilineSplit	= 0;

	//	select prefix
	//
	BTISelectPrefixes( psplit, psplit->ilineSplit );
	
	//	check if oper fits in new page
	//
	if ( !FBTISplitCausesNoOverflow( psplit, psplit->ilineSplit ) )
		{
		//	split without performing operation
		//
		BTISelectSplitWithOperNone( psplit, pfucb );
		BTISelectPrefixes( psplit, psplit->ilineSplit );
		Assert( FBTISplitCausesNoOverflow( psplit, psplit->ilineSplit ) );
		}
	else
		{
		//	split and oper would both succeed
		//
		Assert( psplit->splitoper != splitoperNone );
		}

	BTISplitSetPrefixes( psplit );
	Assert( FBTISplitCausesNoOverflow( psplit, psplit->ilineSplit ) );

	//	set page flags for split and new pages
	//
	Assert( !psplit->fNewPageFlags );
	Assert( !psplit->fSplitPageFlags );

	psplit->fSplitPageFlags = 
	psplit->fNewPageFlags = psplit->psplitPath->csr.Cpage().FFlags();

	psplit->fNewPageFlags &= ~ CPAGE::fPageRoot;
	if ( psplit->psplitPath->csr.Cpage().FLeafPage() && !FFUCBRepair( pfucb ) )
		{
		psplit->fSplitPageFlags = psplit->fSplitPageFlags | CPAGE::fPageParentOfLeaf;
		}
	else
		{
		Assert( !( PinstFromIfmp( pfucb->ifmp )->m_plog->m_fRecovering && FFUCBRepair( pfucb ) ) );
		psplit->fSplitPageFlags &= ~ CPAGE::fPageParentOfLeaf;
		}
		
	psplit->fSplitPageFlags &= ~ CPAGE::fPageLeaf;
	Assert( FFUCBRepair( pfucb ) || !( psplit->fSplitPageFlags & CPAGE::fPageRepair ) );
	psplit->fSplitPageFlags &= ~ CPAGE::fPageRepair;

	return;
	}


//	selects append split
//	if appended node would not cause an overflow,
//		set prefix in page to inserted key
//
VOID BTISelectAppend( SPLIT *psplit, FUCB *pfucb )
	{
	Assert( psplit->clines - 1 == psplit->ilineOper );
	Assert( splitoperInsert == psplit->splitoper );
	Assert( psplit->psplitPath->csr.Cpage().FLeafPage() );

	psplit->splittype			= splittypeAppend;
	psplit->ilineSplit			= psplit->ilineOper;

	LINEINFO	*plineinfoOper	= &psplit->rglineinfo[psplit->ilineOper];
	if ( CbNDNodeSizeTotal( plineinfoOper->kdf ) + cbPrefixOverhead <= cbNDPageAvailMost &&
		 plineinfoOper->kdf.key.Cb() > cbPrefixOverhead )
		{	  
		plineinfoOper->cbPrefix = plineinfoOper->kdf.key.Cb();
		psplit->prefixinfoNew.ilinePrefix	= 0;
		psplit->prefixinfoNew.ilineSegBegin = 0;
		psplit->prefixinfoNew.cbSavings		= 0;
		}
	else
		{
		psplit->prefixinfoNew.Nullify();
		plineinfoOper->cbPrefix = 0;
		}

	psplit->prefixinfoSplit.Nullify();
	}


//	selects split point such that 
//		node weights are almost equal 
//		and split nodes fit in both pages [with optimal prefix key]
//	if no such node exists,
//		select split with operNone
//		
VOID BTISelectRightSplit( SPLIT *psplit, FUCB *pfucb )
	{
	INT			iline;
	INT			ilineCandidate;
	PREFIXINFO	prefixinfoSplitCandidate;
	PREFIXINFO	prefixinfoNewCandidate;
	ULONG		cbSizeCandidateLE;
	ULONG		cbSizeTotal;
	BOOL		fAppendLeaf = fFalse;

	psplit->splittype = splittypeRight;

	//	check if internal page 
	//		and split at leaf level is append
	//
	if ( !psplit->psplitPath->csr.Cpage().FLeafPage( ) )
		{
		SPLITPATH	*psplitPath = psplit->psplitPath;
		
		for ( ; psplitPath->psplitPathChild != NULL; psplitPath = psplitPath->psplitPathChild )
			{
			}

		Assert( psplitPath->psplitPathChild == NULL );
		Assert( psplitPath->csr.Cpage().FLeafPage() );
		if ( NULL != psplitPath->psplit &&
			 splittypeAppend == psplitPath->psplit->splittype )
			{
			fAppendLeaf = fTrue;
			}
		}

	if ( psplit->fHotpoint )
		{
		Assert( psplit->psplitPath->csr.Cpage().FLeafPage( ) );
		Assert( splitoperInsert == psplit->splitoper );
		Assert( psplit->ilineOper < psplit->clines );
		Assert( psplit->ilineOper >= 2 );
		Assert( psplit->clines >= 3 );

		ilineCandidate = psplit->ilineOper;
		if ( ilineCandidate < psplit->clines - 1 )
			{
			//	there are nodes after the hotpoint, so what
			//	we do is force a split consisting of just
			//	the nodes beyond the hotpoint, then try
			//	the operation again (the retry will either
			//	result in the new node being inserted as
			//	the last node on the page or it will
			//	result in a hotpoint split)

			BTISelectSplitWithOperNone( psplit, pfucb );
			psplit->fHotpoint = fFalse;
			}
		else
			{
			Assert( ilineCandidate == psplit->clines - 1 );
			}

		psplit->ilineSplit = ilineCandidate;

		//	find optimal prefix key for split page
		BTISelectPrefix(
				psplit->rglineinfo, 
				ilineCandidate, 
				&psplit->prefixinfoSplit );

		//	find optimal prefix key for new pages
		BTISelectPrefix(
				&psplit->rglineinfo[ilineCandidate], 
				psplit->clines - ilineCandidate,
				&psplit->prefixinfoNew );
				
		Assert( FBTISplitCausesNoOverflow( psplit, ilineCandidate ) );
		BTISplitSetPrefixes( psplit );
		return;
		}

Start:
	ilineCandidate		= 0;
	cbSizeCandidateLE	= 0;
	cbSizeTotal			= psplit->rglineinfo[psplit->clines - 1].cbSizeLE;

	Assert( psplit->clines > 1 );

	//	starting from last node
	//	find candidate split points
	//
	for ( iline = psplit->clines - 1; iline > 0; iline-- )
		{
		//	UNDONE:	optimize prefix selection using a prefix upgrade function
		//
		//	find optimal prefix key for both pages
		//
		BTISelectPrefixes( psplit, iline );
		
		if ( FBTISplitCausesNoOverflow( psplit, iline ) )
			{
			if ( fAppendLeaf )
				{
				//	if this is an internal page split for an append at leaf
				//		set prefixes and return
				//
				ilineCandidate = iline;
				prefixinfoNewCandidate = psplit->prefixinfoNew;
				prefixinfoSplitCandidate = psplit->prefixinfoSplit;
				break;
				}
				
			//	if this candidate is closer to cbSizeTotal / 2
			//	than last one, replace candidate
			//
			if ( absdiff( cbSizeCandidateLE, cbSizeTotal / 2 ) >
				 absdiff( psplit->rglineinfo[iline - 1].cbSizeLE, cbSizeTotal / 2 ) )
				{
				ilineCandidate = iline;
				prefixinfoNewCandidate = psplit->prefixinfoNew;
				prefixinfoSplitCandidate = psplit->prefixinfoSplit;
				cbSizeCandidateLE = psplit->rglineinfo[iline - 1].cbSizeLE;
				}
			}
		else
			{
			//	shouldn't get overflow if only two nodes on page (should end up getting
			//	one node on split page and one node on new page), but it appears that
			//	we may have a bug where this is not the case, so put in a firewall
			//	to trap the occurrence and allow us to debug it the next time it is hit.
			Enforce( psplit->clines > 2 );
			}
		}

	if ( ilineCandidate == 0 )
		{
		//	no candidate line fits the bill
		//	need to split without performing operation
		//
		Assert( psplit->psplitPath->csr.Cpage().FLeafPage() );
		Assert( psplit->splitoper != splitoperNone );
		BTISelectSplitWithOperNone( psplit, pfucb );
		goto Start;
		}

	Assert( ilineCandidate != 0 );
	psplit->ilineSplit = ilineCandidate;
///	BTISelectPrefixes( psplit, ilineCandidate );
	psplit->prefixinfoNew = prefixinfoNewCandidate;
	psplit->prefixinfoSplit = prefixinfoSplitCandidate;
	Assert( FBTISplitCausesNoOverflow( psplit, ilineCandidate ) );
	BTISplitSetPrefixes( psplit );
	return;
	}


//	sets up psplit, so split is performed with no 
//	user-requested operation
//
VOID BTISelectSplitWithOperNone( SPLIT *psplit, FUCB *pfucb )
	{
	if ( splitoperInsert == psplit->splitoper )
		{
		//	move up all lines beyond ilineOper
		//
		INT		iLine = psplit->ilineOper;
		
		for ( ; iLine < psplit->clines - 1 ; iLine++ )
			{
			psplit->rglineinfo[iLine] = psplit->rglineinfo[iLine + 1];
			}
			
		psplit->clines--;
		}
	else
		{
		Assert( psplit->psplitPath->csr.Cpage().FLeafPage( ) );
		
		//	adjust only rglineinfo[ilineOper]
		//
		//	get kdfCurr for ilineOper
		// 
		psplit->psplitPath->csr.SetILine( psplit->ilineOper );
		NDGet( pfucb, &psplit->psplitPath->csr );

		psplit->rglineinfo[psplit->ilineOper].kdf = pfucb->kdfCurr;
		psplit->rglineinfo[psplit->ilineOper].cbSize = 
			CbNDNodeSizeTotal( pfucb->kdfCurr );

		ULONG	cbMax 	= CbBTIMaxSizeOfNode( pfucb, &psplit->psplitPath->csr );
		Assert( cbMax >= psplit->rglineinfo[psplit->ilineOper].cbSize );
		psplit->rglineinfo[psplit->ilineOper].cbSizeMax = cbMax;
		}

	//	UNDONE: optimize recalc for only nodes >= ilineOper
	//			optimize recalc for cbCommonPrev separately
	//
	psplit->ilineOper = 0;
	BTIRecalcWeightsLE( psplit );
	psplit->splitoper = splitoperNone;

	psplit->prefixinfoNew.Nullify();
	psplit->prefixinfoSplit.Nullify();
	}


//	checks if splitting psplit->rglineinfo[] at cLineSplit
//		-- i.e., moving nodes cLineSplit and above to new page -- 
//		would cause an overflow in either page
//
BOOL FBTISplitCausesNoOverflow( SPLIT *psplit, INT ilineSplit )
	{
#ifdef DEBUG
	//	check that prefixes have been calculated correctly
	//
	PREFIXINFO	prefixinfo;
	
	if ( 0 == ilineSplit )
		{
		//	root page in vertical split has no prefix
		//
		Assert( splittypeVertical == psplit->splittype );
		prefixinfo.Nullify();
		}
	else
		{
		//	select prefix for split page
		//
		BTISelectPrefix( psplit->rglineinfo, 
						 ilineSplit, 
						 &prefixinfo );
		}

///	Assert( prefixinfo.ilinePrefix 	== psplit->prefixinfoSplit.ilinePrefix );
	Assert( prefixinfo.cbSavings 	== psplit->prefixinfoSplit.cbSavings );
	Assert( prefixinfo.ilineSegBegin 
				== psplit->prefixinfoSplit.ilineSegBegin );
	Assert( prefixinfo.ilineSegEnd 	
				== psplit->prefixinfoSplit.ilineSegEnd );
	
	//	select prefix for new page
	//
	Assert( psplit->clines > ilineSplit );
	BTISelectPrefix( &psplit->rglineinfo[ilineSplit], 
					 psplit->clines - ilineSplit,
					 &prefixinfo );

///	Assert( prefixinfo.ilinePrefix 	== psplit->prefixinfoNew.ilinePrefix );
	Assert( prefixinfo.cbSavings 	== psplit->prefixinfoNew.cbSavings );
	Assert( prefixinfo.ilineSegBegin 
				== psplit->prefixinfoNew.ilineSegBegin );
	Assert( prefixinfo.ilineSegEnd 	
				== psplit->prefixinfoNew.ilineSegEnd );
#endif

	//	ilineSplit == 0 <=> vertical split
	//	where every node is moved to new page
	//
	Assert( splittypeVertical != psplit->splittype || ilineSplit == 0 );
	Assert( splittypeVertical == psplit->splittype || ilineSplit > 0 );
	Assert( ilineSplit < psplit->clines );

	//	all nodes to left of ilineSplit should fit in page
	//	and all nodes >= ilineSplit should fit in page
	//
	const INT	cbSplitPage = 
					ilineSplit == 0 ? 
						0 :
						( psplit->rglineinfo[ilineSplit - 1].cbSizeMaxLE - 
						  psplit->prefixinfoSplit.cbSavings );

	Assert( cbSplitPage >= 0 );
	const BOOL	fSplitPageFits = cbSplitPage <= cbNDPageAvailMostNoInsert;

	const INT	cbNewPage = 
					psplit->rglineinfo[psplit->clines - 1].cbSizeMaxLE - 
					( ilineSplit == 0 ? 
						0 :
		 				psplit->rglineinfo[ilineSplit - 1].cbSizeMaxLE ) -
		 			psplit->prefixinfoNew.cbSavings;

	const BOOL	fNewPageFits = ( ilineSplit == psplit->clines ||
								 cbNewPage <= cbNDPageAvailMostNoInsert );

	return fSplitPageFits && fNewPageFits;
	}


//	allocates space for key in data and copies entire key into data
//
ERR	ErrBTISplitAllocAndCopyPrefix( const KEY &key, DATA *pdata )
	{
	Assert( pdata->Pv() == NULL );
	Assert( !key.FNull() );
	
	pdata->SetPv( PvOSMemoryHeapAlloc( key.Cb() ) );
	if ( pdata->Pv() == NULL )
		{
		return ErrERRCheck( JET_errOutOfMemory );
		}

	pdata->SetCb( key.Cb() );
	key.CopyIntoBuffer( pdata->Pv(), pdata->Cb() );

	return JET_errSuccess;
	}

	
//	allocate space for new and old prefixes for split page
//	copy prefixes
//
ERR	ErrBTISplitAllocAndCopyPrefixes( FUCB *pfucb, SPLIT *psplit )
	{
	ERR		err = JET_errSuccess;

	Assert( psplit->prefixSplitOld.FNull() );
	Assert( psplit->prefixSplitNew.FNull() );

	NDGetPrefix( pfucb, &psplit->psplitPath->csr );
	if ( !pfucb->kdfCurr.key.prefix.FNull() )
		{
		CallR( ErrBTISplitAllocAndCopyPrefix( pfucb->kdfCurr.key,
											  &psplit->prefixSplitOld ) );
		}
		
	if ( psplit->prefixinfoSplit.ilinePrefix != ilineInvalid )
		{
		const INT	ilinePrefix = psplit->prefixinfoSplit.ilinePrefix;
		
		Assert( psplit->splittype != splittypeAppend );
		CallR( ErrBTISplitAllocAndCopyPrefix( 
						psplit->rglineinfo[ilinePrefix].kdf.key,
						&psplit->prefixSplitNew ) );
		}

	CallS( err );
	return err;
	}

	
//	leave psplitPath->psplitPathParent->csr at insert point in parent
//
VOID BTISeekSeparatorKey( SPLIT *psplit, FUCB *pfucb )
	{
	ERR			err;
	CSR			*pcsr = &psplit->psplitPath->psplitPathParent->csr;
	BOOKMARK	bm;

	
	Assert( !psplit->kdfParent.key.FNull() );
	Assert( sizeof( PGNO ) == psplit->kdfParent.data.Cb() );
	Assert( splittypeVertical != psplit->splittype );
	Assert( pcsr->Cpage().FInvisibleSons() );

	//	seeking in internal page should have NULL data
	//
	bm.key	= psplit->kdfParent.key;
	bm.data.Nullify();
	err = ErrNDSeek( pfucb, pcsr, bm );

	Assert( err == wrnNDFoundGreater );
	Assert( err != JET_errSuccess );
	if ( err == wrnNDFoundLess )
		{
		//	inserted node should never fall after last node in page
		//
		Assert( fFalse );
		Assert( pcsr->Cpage().Clines() - 1 == pcsr->ILine() );
		pcsr->IncrementILine();
		}

	return;
	}


//	allocates and computes separator key between given lines
//
ERR	ErrBTIComputeSeparatorKey( FUCB 				*pfucb,
							   const KEYDATAFLAGS 	&kdfPrev, 
							   const KEYDATAFLAGS 	&kdfSplit,
							   KEY					*pkey )
	{
	INT		cbDataCommon	= 0;
	INT		cbKeyCommon		= CbCommonKey( kdfSplit.key, kdfPrev.key );
	BOOL	fKeysEqual		= fFalse;
	
	if ( cbKeyCommon == kdfSplit.key.Cb() &&
		 cbKeyCommon == kdfPrev.key.Cb() )
		{
		//	split key is the same as the previous one
		//
		Assert( !FFUCBUnique( pfucb ) );
		Assert( FKeysEqual( kdfSplit.key, kdfPrev.key ) );
		Assert( CmpData( kdfSplit.data, kdfPrev.data ) > 0 );
		
		fKeysEqual = fTrue;
		cbDataCommon = CbCommonData( kdfSplit.data, kdfPrev.data );
		}
	else
		{
		Assert( CmpKey( kdfSplit.key, kdfPrev.key ) > 0 );
		Assert( cbKeyCommon < kdfSplit.key.Cb() );
		}

	//	allocate memory for separator key
	//
	Assert( pkey->FNull() );
	pkey->suffix.SetPv( PvOSMemoryHeapAlloc( cbKeyCommon + cbDataCommon + 1 ) );
	if ( pkey->suffix.Pv() == NULL )
		{
		return ErrERRCheck( JET_errOutOfMemory );
		}
	pkey->suffix.SetCb( cbKeyCommon + cbDataCommon + 1 );
	
	//	copy separator key and data into alocated memory
	//
	Assert( cbKeyCommon <= pkey->Cb() );
	Assert( pkey->suffix.Pv() != NULL );
	kdfSplit.key.CopyIntoBuffer( pkey->suffix.Pv(), 
								 cbKeyCommon );

	if ( !fKeysEqual )
		{
		//	copy difference byte from split key
		//
		Assert( 0 == cbDataCommon );
		Assert( kdfSplit.key.Cb() > cbKeyCommon );

		if ( kdfSplit.key.prefix.Cb() > cbKeyCommon )
			{
			//	byte of difference is in prefix
			//
			( (BYTE *)pkey->suffix.Pv() )[cbKeyCommon] = 
					( (BYTE *) kdfSplit.key.prefix.Pv() )[cbKeyCommon];
			}
		else
			{
			//	get byte of difference from suffix
			//
			( (BYTE *)pkey->suffix.Pv() )[cbKeyCommon] = 
					( (BYTE *) kdfSplit.key.suffix.Pv() )[cbKeyCommon - 
											kdfSplit.key.prefix.Cb() ];
			}
		}
	else
		{
		//	copy common data
		//	then copy difference byte from split data
		//
		UtilMemCpy( (BYTE *)pkey->suffix.Pv() + cbKeyCommon,
				kdfSplit.data.Pv(),
				cbDataCommon );

		Assert( kdfSplit.data.Cb() > cbDataCommon );

		( (BYTE *)pkey->suffix.Pv() )[cbKeyCommon + cbDataCommon] = 
				( (BYTE *)kdfSplit.data.Pv() )[cbDataCommon];
		}

	return JET_errSuccess;
	}


//	for leaf level, 
//	computes shortest separator
//	between the keys of ilineSplit and ilineSplit - 1
//	allocates memory for node to be inserted
//		and the pointer to it in psplit->kdfParent
//	for internal pages, return last kdf in page
//
ERR ErrBTISplitComputeSeparatorKey( SPLIT *psplit, FUCB *pfucb )
	{
	ERR				err;
	KEYDATAFLAGS	*pkdfSplit = &psplit->rglineinfo[psplit->ilineSplit].kdf;
	KEYDATAFLAGS	*pkdfPrev = &psplit->rglineinfo[psplit->ilineSplit - 1].kdf;
	
	Assert( psplit->kdfParent.key.FNull() );
	Assert( psplit->kdfParent.data.FNull() );
	Assert( psplit->psplitPath->psplitPathParent != NULL );

	//	data of node inserted at parent should point to split page
	//
	psplit->kdfParent.data.SetCb( sizeof( PGNO ) );
	psplit->kdfParent.data.SetPv( &psplit->pgnoSplit );
	
	if ( psplit->psplitPath->csr.Cpage().FInvisibleSons( ) || FFUCBRepair( pfucb ) )
		{
		//	not leaf page
		//	separator key should be key of ilineSplit - 1
		//
		Assert( !psplit->psplitPath->csr.Cpage().FLeafPage() &&	pkdfSplit->key.FNull()
				|| CmpKey( pkdfPrev->key, pkdfSplit->key )  < 0
				|| fGlobalRepair );

		psplit->kdfParent.key = pkdfPrev->key;
		return JET_errSuccess;
		}

	Assert( psplit->psplitPath->csr.Cpage().FLeafPage() );
	Assert( !psplit->fAllocParent );

	CallR( ErrBTIComputeSeparatorKey( pfucb, *pkdfPrev, *pkdfSplit, &psplit->kdfParent.key ) );
	psplit->fAllocParent = fTrue;

	return err;
	}


//	selects prefix for clines in rglineinfo
//	places result in *pprefixinfo
//
LOCAL VOID BTISelectPrefixCheck( const LINEINFO 	*rglineinfo, 
								 INT	 			clines, 
								 PREFIXINFO			*pprefixinfo )
	{
#ifdef DEBUG
	pprefixinfo->Nullify();
	
	Assert( clines > 0 );
	if ( 1 == clines )
		{
		return;
		}
		
	//	set cbCommonPrev for first line to zero
	//
	const ULONG	cbCommonPrevSav = rglineinfo[0].cbCommonPrev;
	((LINEINFO *)rglineinfo)[0].cbCommonPrev = 0;
	
	INT			iline;

	//	UNDONE:	optimize loop to use info from previous iteration
	//
	//	calculate prefixinfo for line
	//	if better than previous candidate
	//		choose as new candidate
	//
	for ( iline = 0; iline < clines; iline++ )
		{
		if ( iline != 0 )
			{
			ULONG cbCommonKey = CbCommonKey( rglineinfo[iline].kdf.key,
											 rglineinfo[iline - 1].kdf.key );

			Assert( cbCommonKey <= cbPrefixOverhead && 
						rglineinfo[iline].cbCommonPrev == 0 ||
					cbCommonKey - cbPrefixOverhead == 
						rglineinfo[iline].cbCommonPrev );
			}
		else
			{
			Assert( rglineinfo[iline].cbCommonPrev == 0 );
			}

		INT		ilineSegLeft;
		INT		ilineSegRight;
		INT		cbSavingsLeft = 0;
		INT		cbSavingsRight = 0;
		ULONG	cbCommonMin;

		//	calculate savings for previous lines
		//
		cbCommonMin = rglineinfo[iline].cbCommonPrev;
		for ( ilineSegLeft = iline; 
			  ilineSegLeft > 0 && rglineinfo[ilineSegLeft].cbCommonPrev > 0; 
			  ilineSegLeft-- )
			{
			Assert( cbCommonMin > 0 );
			if ( cbCommonMin > rglineinfo[ilineSegLeft].cbCommonPrev )
				{
				cbCommonMin = rglineinfo[ilineSegLeft].cbCommonPrev;
				}
				
			cbSavingsLeft += cbCommonMin;
			}
			
		//	calculate savings for following lines
		//
		for ( ilineSegRight = iline + 1;
			  ilineSegRight < clines && rglineinfo[ilineSegRight].cbCommonPrev > 0;
			  ilineSegRight++ )
			{
			if ( ilineSegRight == iline + 1 )
				{
				cbCommonMin = rglineinfo[ilineSegRight].cbCommonPrev;
				}
			else if ( cbCommonMin > rglineinfo[ilineSegRight].cbCommonPrev )
				{
				cbCommonMin = rglineinfo[ilineSegRight].cbCommonPrev;
				}
			Assert( cbCommonMin > 0 );
			cbSavingsRight += cbCommonMin;
			}
		ilineSegRight--;

		//	check if savings with iline as prefix
		//		compensate for prefix overhead
		//	 	and are better than previous prefix candidate
		//	
		const INT		cbSavings = cbSavingsLeft + cbSavingsRight - cbPrefixOverhead;
		if ( cbSavings > pprefixinfo->cbSavings )
			{
			Assert( cbSavings > 0 );
			pprefixinfo->ilinePrefix 	= iline;
			pprefixinfo->cbSavings 		= cbSavings;
			pprefixinfo->ilineSegBegin	= ilineSegLeft;
			pprefixinfo->ilineSegEnd 	= ilineSegRight;
			}
		}

	//	set cbCommonPrev for first line to original value
	//
	((LINEINFO *)rglineinfo)[0].cbCommonPrev = cbCommonPrevSav;
#endif
	}


//	selects prefix for clines in rglineinfo
//	places result in *pprefixinfo
//
LOCAL VOID BTISelectPrefix( const LINEINFO 	*rglineinfo, 
							INT 			clines, 
							PREFIXINFO		*pprefixinfo )
	{
	pprefixinfo->Nullify();
	
	Assert( clines > 0 );
	if ( 1 == clines )
		{
		return;
		}

	if ( 2 == clines )
		{
		INT		cbSavings = rglineinfo[1].cbCommonPrev - cbPrefixOverhead;
		if ( cbSavings > 0 )
			{
			pprefixinfo->ilinePrefix 	= 1;
			pprefixinfo->cbSavings 		= cbSavings;
			pprefixinfo->ilineSegBegin	= 0;
			pprefixinfo->ilineSegEnd 	= 1;
			}
			
		return;
		}
		
	//	set cbCommonPrev for first and last line to zero
	//  we exploit this to remove an extra check in the calculation loops
	//  WARNING:  the rglineinfo array must be allocated one entry too large!
	//
	const ULONG	cbCommonPrevFirstSav = rglineinfo[0].cbCommonPrev;
	const ULONG	cbCommonPrevLastSav	 = rglineinfo[clines].cbCommonPrev;
	((LINEINFO *)rglineinfo)[0].cbCommonPrev = 0;
	((LINEINFO *)rglineinfo)[clines].cbCommonPrev = 0;
	
	INT			iline;

	//	UNDONE:	optimize loop to use info from previous iteration
	//
	//	calculate prefixinfo for line
	//	if better than previous candidate
	//		choose as new candidate
	//
	for ( iline = 1; iline < clines - 1; iline++ )
		{
#ifdef DEBUG
		if ( iline != 0 )
			{
			ULONG cbCommonKey = CbCommonKey( rglineinfo[iline].kdf.key,
											 rglineinfo[iline - 1].kdf.key );

			Assert( cbCommonKey <= cbPrefixOverhead && 
						rglineinfo[iline].cbCommonPrev == 0 ||
					cbCommonKey - cbPrefixOverhead == 
						rglineinfo[iline].cbCommonPrev );
			}
		else
			{
			Assert( rglineinfo[iline].cbCommonPrev == 0 );
			}
#endif

		if ( iline != 1 && 
			 iline != clines - 2 && 
			 rglineinfo[iline + 1].cbCommonPrev >= rglineinfo[iline].cbCommonPrev )
			{
			//	next line would be at least as good a prefix as this one
			//
			continue;
			}
			
		INT		ilineSegLeft;
		INT		ilineSegRight;
		INT		cbSavingsLeft = 0;
		INT		cbSavingsRight = 0;
		ULONG	cbCommonMin;

		//	calculate savings for previous lines
		//
		cbCommonMin = rglineinfo[iline].cbCommonPrev;
		for ( ilineSegLeft = iline; 
			  rglineinfo[ilineSegLeft].cbCommonPrev > 0; //  rglineinfo[0].cbCommonPrev == 0
			  ilineSegLeft-- )
			{
			Assert( ilineSegLeft > 0 );
			Assert( cbCommonMin > 0 );
			if ( cbCommonMin > rglineinfo[ilineSegLeft].cbCommonPrev )
				{
				cbCommonMin = rglineinfo[ilineSegLeft].cbCommonPrev;
				}
				
			cbSavingsLeft += cbCommonMin;
			}
			
		//	calculate savings for following lines
		//
		cbCommonMin = rglineinfo[iline+1].cbCommonPrev;
		for ( ilineSegRight = iline + 1;
			  rglineinfo[ilineSegRight].cbCommonPrev > 0; //  rglineinfo[clines].cbCommonPrev == 0
			  ilineSegRight++ )
			{
			Assert( ilineSegRight < clines );
			if ( cbCommonMin > rglineinfo[ilineSegRight].cbCommonPrev )
				{
				cbCommonMin = rglineinfo[ilineSegRight].cbCommonPrev;
				}
			Assert( cbCommonMin > 0 );
			cbSavingsRight += cbCommonMin;
			}
		ilineSegRight--;

		//	check if savings with iline as prefix
		//		compensate for prefix overhead
		//	 	and are better than previous prefix candidate
		//	
		const INT		cbSavings = cbSavingsLeft + cbSavingsRight - cbPrefixOverhead;
		if ( cbSavings > pprefixinfo->cbSavings )
			{
			Assert( cbSavings > 0 );
			pprefixinfo->ilinePrefix 	= iline;
			pprefixinfo->cbSavings 		= cbSavings;
			pprefixinfo->ilineSegBegin	= ilineSegLeft;
			pprefixinfo->ilineSegEnd 	= ilineSegRight;
			}
		}

	//	set cbCommonPrev for first line to original value
	//
	((LINEINFO *)rglineinfo)[0].cbCommonPrev = cbCommonPrevFirstSav;
	((LINEINFO *)rglineinfo)[clines].cbCommonPrev = cbCommonPrevLastSav;

	#ifdef DEBUG
	PREFIXINFO	prefixinfoT;
	BTISelectPrefixCheck( rglineinfo, clines, &prefixinfoT );
//	Assert( prefixinfoT.ilinePrefix == pprefixinfo->ilinePrefix );
	Assert( prefixinfoT.cbSavings == pprefixinfo->cbSavings );
	Assert( prefixinfoT.ilineSegBegin == pprefixinfo->ilineSegBegin );
	Assert( prefixinfoT.ilineSegEnd == pprefixinfo->ilineSegEnd );
	#endif
	}


//	remove last line and re-calculate prefix
//
LOCAL VOID BTISelectPrefixDecrement( const LINEINFO *rglineinfo, 
									 INT 			clines, 
									 PREFIXINFO		*pprefixinfo )
	{
	Assert( pprefixinfo->ilinePrefix <= clines );
	Assert( pprefixinfo->ilineSegBegin <= clines );
	Assert( pprefixinfo->ilineSegEnd <= clines );
	Assert( pprefixinfo->ilineSegBegin <= pprefixinfo->ilineSegEnd );
	
	if ( pprefixinfo->ilineSegEnd == clines )
		{
		//	removed line contributed to prefix
		//
		Assert( !pprefixinfo->FNull() );
		BTISelectPrefix( rglineinfo, clines, pprefixinfo );
		}
	else
		{
		//	no need to change prefix
		//
///		Assert( fFalse );
		}
		
	return;
	}


//	add line at beginning and re-calculate prefix
//
LOCAL VOID BTISelectPrefixIncrement( const LINEINFO *rglineinfo, 
									 INT 			clines, 
									 PREFIXINFO		*pprefixinfo )
	{
	Assert( pprefixinfo->ilinePrefix <= clines - 1 );
	Assert( pprefixinfo->ilineSegBegin <= clines - 1);
	Assert( pprefixinfo->ilineSegEnd <= clines - 1 );
	Assert( pprefixinfo->ilineSegBegin <= pprefixinfo->ilineSegEnd );
	
	if ( clines > 1 &&
		 rglineinfo[1].cbCommonPrev == 0 )
		{
		//	added line does not contribute to prefix
		//
		if ( !pprefixinfo->FNull() )
			{
			pprefixinfo->ilinePrefix++;
			pprefixinfo->ilineSegBegin++;
			pprefixinfo->ilineSegEnd++;
			}
		}
	else if ( pprefixinfo->FNull() )
		{
			
		//	look for prefix only in first segment
		//
		INT		iline;
		for ( iline = 1; iline < clines; iline++ )
			{
			if ( rglineinfo[iline].cbCommonPrev == 0 )
				{
				break;
				}
			}

		BTISelectPrefix( rglineinfo, iline, pprefixinfo );
		}
	else
		{
		//	current prefix should be at or before earlier prefix
		//
		Assert( clines > 1 );
		Assert( pprefixinfo->ilineSegEnd + 1 + 1 <= clines );
		BTISelectPrefix( rglineinfo, 
						 pprefixinfo->ilineSegEnd + 1 + 1,
						 pprefixinfo );
		}
		
	return;
	}

	
//	selects optimal prefix for split page and new page
//	and places result in prefixinfoSplit and prefixinfoNew
//
LOCAL VOID BTISelectPrefixes( SPLIT *psplit, INT ilineSplit )
	{
	if ( 0 == ilineSplit )
		{
		//	root page in vertical split has no prefix
		//
		Assert( splittypeVertical == psplit->splittype );
		Assert( psplit->prefixinfoSplit.FNull() );
		BTISelectPrefix( &psplit->rglineinfo[ilineSplit], 
						 psplit->clines - ilineSplit,
						 &psplit->prefixinfoNew );
		}
	else
		{
		Assert( psplit->clines > ilineSplit );

		//	select prefix for split page
		//
		if ( psplit->clines - 1 == ilineSplit )
			{
			Assert( psplit->prefixinfoSplit.FNull() );

			BTISelectPrefix( psplit->rglineinfo,
							 ilineSplit,
							 &psplit->prefixinfoSplit );
			}
		else
			{
			BTISelectPrefixDecrement( psplit->rglineinfo, 
							 		  ilineSplit, 
									  &psplit->prefixinfoSplit );
			}
			
		//	select prefix for new page
		//
		BTISelectPrefixIncrement( &psplit->rglineinfo[ilineSplit], 
						 		  psplit->clines - ilineSplit,
								  &psplit->prefixinfoNew );
		}
	}


//	sets cbPrefix for clines in rglineinfo
//	based on prefix selected in prefixinfo
//
LOCAL VOID BTISetPrefix( LINEINFO *rglineinfo, INT clines, const PREFIXINFO& prefixinfo )
	{
	Assert( clines > 0 );

	INT			iline;

	//	set all cbPrefix to zero
	//
	for ( iline = 0; iline < clines; iline++ )
		{
		rglineinfo[iline].cbPrefix = 0;
		
#ifdef DEBUG
		if ( iline != 0 )
			{
			ULONG cbCommonKey = CbCommonKey( rglineinfo[iline].kdf.key,
											 rglineinfo[iline - 1].kdf.key );

			Assert( cbCommonKey <= cbPrefixOverhead && 
						rglineinfo[iline].cbCommonPrev == 0 ||
					cbCommonKey - cbPrefixOverhead == 
						rglineinfo[iline].cbCommonPrev );
			}
#endif
		}

	if ( ilineInvalid == prefixinfo.ilinePrefix )
		{
		return;
		}

	//	set cbPrefix to appropriate value for lines in prefix segment
	//
	const INT	ilineSegLeft 	= prefixinfo.ilineSegBegin;
	const INT	ilineSegRight 	= prefixinfo.ilineSegEnd;
	const INT	ilinePrefix		= prefixinfo.ilinePrefix;
	ULONG		cbCommonMin;

	#ifdef DEBUG
	INT		cbSavingsLeft = 0;
	INT		cbSavingsRight = 0;
	#endif

	Assert( ilineSegLeft != ilineSegRight );
	
	//	cbPrefix for ilinePrefix
	//
	rglineinfo[ilinePrefix].cbPrefix = rglineinfo[ilinePrefix].kdf.key.Cb();
	
	//	cbPrefix for previous lines
	//
	cbCommonMin = rglineinfo[ilinePrefix].cbCommonPrev;
	for ( iline = ilinePrefix; iline > ilineSegLeft; iline-- )
		{
		Assert( cbCommonMin > 0 );
		Assert( iline > 0 );
		Assert( rglineinfo[iline].cbCommonPrev > 0 );
		
		if ( cbCommonMin > rglineinfo[iline].cbCommonPrev )
			{
			cbCommonMin = rglineinfo[iline].cbCommonPrev;
			}

		rglineinfo[iline-1].cbPrefix = cbCommonMin + cbPrefixOverhead;

		#ifdef DEBUG
		cbSavingsLeft += cbCommonMin;
		#endif
		}
			
	//	calculate savings for following lines
	//
	for ( iline = ilinePrefix + 1; iline <= ilineSegRight; iline++ )
		{
		Assert( iline > 0 );
		if ( iline == ilinePrefix + 1 )
			{
			cbCommonMin = rglineinfo[iline].cbCommonPrev;
			}
		else if ( cbCommonMin > rglineinfo[iline].cbCommonPrev )
			{
			cbCommonMin = rglineinfo[iline].cbCommonPrev;
			}

		rglineinfo[iline].cbPrefix = cbCommonMin + cbPrefixOverhead;
		
		#ifdef DEBUG
		cbSavingsRight += cbCommonMin;
		#endif
		}

	#ifdef DEBUG
	//	check if savings are same as in prefixinfo
	const INT	cbSavings = cbSavingsLeft + cbSavingsRight - cbPrefixOverhead;

	Assert( cbSavings > 0 );
	Assert( prefixinfo.ilinePrefix == ilinePrefix );
	Assert( prefixinfo.cbSavings == cbSavings );
	#endif
	}

//	sets cbPrefix in all lineinfo to correspond to chosen prefix
//
VOID BTISplitSetPrefixes( SPLIT *psplit )
	{
	const INT	ilineSplit = psplit->ilineSplit;
	
	if ( 0 == ilineSplit )
		{
		//	root page in vertical split has no prefix
		//
		Assert( splittypeVertical == psplit->splittype );
		Assert( ilineInvalid == psplit->prefixinfoSplit.ilinePrefix );
		}
	else
		{
		//	select prefix for split page
		//
		BTISetPrefix( psplit->rglineinfo, 
					  ilineSplit, 
					  psplit->prefixinfoSplit );
		}

	//	select prefix for new page
	//
	Assert( psplit->clines > ilineSplit );
	BTISetPrefix( &psplit->rglineinfo[ilineSplit], 
				  psplit->clines - ilineSplit,
				  psplit->prefixinfoNew );
	}
	

//	get new pages for split
//
LOCAL ERR ErrBTIGetNewPages( FUCB *pfucb, SPLITPATH *psplitPathLeaf )
	{
	ERR			err;
	SPLITPATH	*psplitPath;

	//	find pcsrRoot for pfucb
	//
	Assert( pfucb->pcsrRoot == pcsrNil );
	for ( psplitPath = psplitPathLeaf;
		  psplitPath->psplitPathParent != NULL;
		  psplitPath = psplitPath->psplitPathParent )
		{
		//	all logic in for loop
		//
		}
	pfucb->pcsrRoot = &psplitPath->csr;

	//	get a new page for every split
	//
	Assert( psplitPath->psplitPathParent == NULL );
	for ( ; psplitPath != NULL; psplitPath = psplitPath->psplitPathChild )
		{
		if ( psplitPath->psplit != NULL )
			{
			SPLIT *	psplit		= psplitPath->psplit;

			BTICheckSplitFlags( psplit );

			//	pass in split page for getting locality
			//
			Assert( psplit->psplitPath == psplitPath );
			PGNO	pgnoNew		= psplitPath->csr.Pgno();

			Call( ErrSPGetPage( pfucb, &pgnoNew ) );
			psplit->pgnoNew = pgnoNew;

			Call( psplit->csrNew.ErrGetNewPage(
					pfucb->ppib,
					pfucb->ifmp,
					psplit->pgnoNew,
					ObjidFDP( pfucb ),
					psplit->fNewPageFlags,
					pfucb->u.pfcb->Tableclass() ) );

			Assert( latchWrite == psplit->csrNew.Latch() );

			//  if this is not an append split, depend the new page on the split
			//  page so that the data moved from the split page to the new page
			//  will always be available no matter when we crash

			if ( FBTISplitDependencyRequired( psplit ) )
				{
				Call( ErrBFDepend(
							psplit->csrNew.Cpage().PBFLatch(),
							psplitPath->csr.Cpage().PBFLatch() ) );
				}
			}
		}

	pfucb->pcsrRoot = pcsrNil;
	return JET_errSuccess;

HandleError:
	//	release all latched pages
	//	free all allocated pages
	//
	for ( psplitPath = psplitPathLeaf;
		  psplitPath != NULL;
		  psplitPath = psplitPath->psplitPathParent )
		{
		if ( psplitPath->psplit != NULL	&&
			 pgnoNull != psplitPath->psplit->pgnoNew )
			{
			SPLIT	*psplit = psplitPath->psplit;
			
			if ( psplit->csrNew.Pgno() == psplit->pgnoNew )
				{
				Assert( latchWrite == psplit->csrNew.Latch() );

				psplit->csrNew.ReleasePage();
				psplit->csrNew.Reset();
				}

			ERR errT;
			errT = ErrSPFreeExt( pfucb, psplit->pgnoNew, 1 );
#ifdef DEBUG			
			switch( errT )
				{
				case JET_errSuccess:
				case JET_errOutOfCursors:
				case JET_errOutOfMemory:
				case JET_errOutOfBuffers:
				case JET_errLogWriteFail:
					break;
				default:
					CallS( errT ); 
				}
#endif // DEBUG				
			psplit->pgnoNew = pgnoNull;
			}
		}
		
	pfucb->pcsrRoot = pcsrNil;
	return err;
	}


//	release latches on pages that are not in the split
//		this might cause psplitPathLeaf to change\
//
LOCAL VOID BTISplitReleaseUnneededPages( INST *pinst, SPLITPATH **ppsplitPathLeaf )
	{
	SPLITPATH 	*psplitPath;
	SPLITPATH 	*psplitPathNewLeaf = NULL;

	//	go to root
	//	since we need to latch bottom-down
	//
	for ( psplitPath = *ppsplitPathLeaf;
		  psplitPath->psplitPathParent != NULL;
		  psplitPath = psplitPath->psplitPathParent )
		{
		}

	for ( ; NULL != psplitPath;  )
		{
		//	check if page is needed
		//		-- either there is a split at this level
		//		   or there is a split one level below
		//			when we need write latch for inserting page pointer
		//
		SPLIT	*psplit = psplitPath->psplit;
		
		if ( psplit == NULL &&
			 ( psplitPath->psplitPathChild == NULL ||
			   psplitPath->psplitPathChild->psplit == NULL ) )
			{
			//	release latch and psplitPath at this level
			//
			SPLITPATH *psplitPathT = psplitPath;
			psplitPath = psplitPath->psplitPathChild;
			
			BTIReleaseOneSplitPath( pinst, psplitPathT );
			}
		else
			{
			//	update new leaf
			//
			Assert( NULL == psplitPathNewLeaf ||
					psplitPath == psplitPathNewLeaf->psplitPathChild );

			psplitPathNewLeaf = psplitPath;
			psplitPath = psplitPath->psplitPathChild;
			}
		}
	Assert( psplitPathNewLeaf != NULL );
	Assert( psplitPathNewLeaf->psplit != NULL );

	*ppsplitPathLeaf = psplitPathNewLeaf;

	return;
	}

	
//	upgrade to write latch on all pages invloved in the split
//	new pages are already latched
//
LOCAL ERR ErrBTISplitUpgradeLatches( const IFMP ifmp, SPLITPATH * const psplitPathLeaf )
	{
	ERR				err;
	SPLITPATH 		* psplitPath;
	const DBTIME	dbtimeSplit		= rgfmp[ifmp].DbtimeIncrementAndGet();

	Assert( dbtimeSplit > 1 );
	Assert( PinstFromIfmp( ifmp )->m_plog->m_fRecoveringMode != fRecoveringRedo
		|| rgfmp[ifmp].FCreatingDB() );			//	may hit this code path during recovery if explicitly redoing CreateDb

	//	go to root
	//	since we need to latch bottom-down
	//
	for ( psplitPath = psplitPathLeaf;
		  psplitPath->psplitPathParent != NULL;
		  psplitPath = psplitPath->psplitPathParent )
		{
		}

	Assert( NULL == psplitPath->psplitPathParent );
	for ( ; NULL != psplitPath;  psplitPath = psplitPath->psplitPathChild )
		{
		//	assert write latch is needed
		//		-- either there is a split at this level
		//		   or there is a split one level below
		//			when we need write latch for inserting page pointer
		//
		SPLIT	*psplit = psplitPath->psplit;
		
		Assert( psplit != NULL ||
			 	( psplitPath->psplitPathChild != NULL &&
			   	  psplitPath->psplitPathChild->psplit != NULL ) );
		Assert( psplitPath->csr.Latch() == latchWrite || 
				psplitPath->csr.Latch() == latchRIW );
		if ( psplitPath->csr.Latch() != latchWrite )
			 psplitPath->csr.UpgradeFromRIWLatch();


		Assert( psplitPath->csr.Latch() == latchWrite );
		if ( psplitPath->csr.Dbtime() < dbtimeSplit )
			{
			psplitPath->dbtimeBefore = psplitPath->csr.Dbtime();
			psplitPath->csr.CoordinatedDirty( dbtimeSplit );
			}
		else
			{
			FireWall();
			Call( ErrERRCheck( JET_errDbTimeCorrupted ) );
			}
		
		//	new page will already be write latched
		//	dirty it and update max dbtime
		//
		if ( psplit != NULL )
			{
			Assert( psplit->csrNew.Latch() == latchWrite );
			psplit->csrNew.CoordinatedDirty( dbtimeSplit );
			}

		//	write latch right page at leaf-level
		//
		if ( psplitPath->psplitPathChild == NULL )
			{
			Assert( psplit != NULL );
			Assert( psplitPath->csr.Cpage().FLeafPage()
				|| ( splitoperNone == psplit->splitoper
					&& splittypeVertical == psplit->splittype ) );

			if ( pgnoNull != psplit->csrRight.Pgno() )
				{
				Assert( psplit->splittype != splittypeAppend );
				Assert( psplit->csrRight.Cpage().FLeafPage() );

				psplit->csrRight.UpgradeFromRIWLatch();
				
				if ( psplit->csrRight.Dbtime() < dbtimeSplit )
					{
					psplit->dbtimeRightBefore = psplit->csrRight.Dbtime() ;
					psplit->csrRight.CoordinatedDirty( dbtimeSplit );
					}
				else
					{
					FireWall();
					Call( ErrERRCheck( JET_errDbTimeCorrupted ) );
					}
				}
			else
				{
				psplit->dbtimeRightBefore = dbtimeNil ;
				}
			}
		}

	return JET_errSuccess;

HandleError:
	Assert( err < 0 );
	BTISplitRevertDbtime( psplitPathLeaf );
	return err;
	}
	

//	sets dbtime of every (write) latched page to given dbtime
//
VOID BTISplitRevertDbtime( SPLITPATH *psplitPathLeaf )
	{
	SPLITPATH *psplitPath = psplitPathLeaf;

	Assert( NULL == psplitPath->psplitPathChild );
	
	for ( ; NULL != psplitPath;
			psplitPath = psplitPath->psplitPathParent )
		{
		//	set the dbtime for this page
		//		
		Assert( latchWrite == psplitPath->csr.Latch() );

		Assert( dbtimeInvalid != psplitPath->dbtimeBefore && dbtimeNil != psplitPath->dbtimeBefore);
		Assert( psplitPath->dbtimeBefore < psplitPath->csr.Dbtime() );
		psplitPath->csr.RevertDbtime( psplitPath->dbtimeBefore );
		
		SPLIT	*psplit = psplitPath->psplit;

		//	set dbtime for sibling and new pages
		//
		if ( psplit != NULL && pgnoNull != psplit->csrRight.Pgno() )
			{
			Assert( psplit->splittype != splittypeAppend );
			Assert( psplit->csrRight.Cpage().FLeafPage() );

			Assert( dbtimeInvalid != psplit->dbtimeRightBefore && dbtimeNil != psplit->dbtimeRightBefore);
			Assert( psplit->dbtimeRightBefore < psplit->csrRight.Dbtime() );
			psplit->csrRight.RevertDbtime( psplit->dbtimeRightBefore );
			}
		}
	}


//	sets lgpos for all pages invloved in split
//
LOCAL VOID BTISplitSetLgpos( SPLITPATH *psplitPathLeaf, const LGPOS& lgpos )
	{
	SPLITPATH	*psplitPath = psplitPathLeaf;
	
	for ( ; psplitPath != NULL ; psplitPath = psplitPath->psplitPathParent )
		{
		Assert( psplitPath->csr.FDirty() );

		psplitPath->csr.Cpage().SetLgposModify( lgpos );

		SPLIT	*psplit = psplitPath->psplit;
		
		if ( psplit != NULL )
			{
			psplit->csrNew.Cpage().SetLgposModify( lgpos );

			if ( psplit->csrRight.Pgno() != pgnoNull )
				{
				Assert( psplit->csrRight.Cpage().FLeafPage() );
				psplit->csrRight.Cpage().SetLgposModify( lgpos );
				}
			}
		}
	}
	

//	gets node to replace or flagInsertAndReplaceData at leaf level
//
VOID BTISplitGetReplacedNode( FUCB *pfucb, SPLIT *psplit )
	{
	Assert( psplit != NULL );
	Assert( splitoperFlagInsertAndReplaceData == psplit->splitoper ||
			splitoperReplace == psplit->splitoper );

	CSR 	*pcsr = &psplit->psplitPath->csr;
	Assert( pcsr->Cpage().FLeafPage() );
	Assert( pcsr->Cpage().Clines() > psplit->ilineOper );

	pcsr->SetILine( psplit->ilineOper );
	NDGet( pfucb, pcsr );
	}


VOID BTISplitInsertIntoRCELists( FUCB 				*pfucb, 
								 SPLITPATH			*psplitPath, 
								 const KEYDATAFLAGS	*pkdf, 
								 RCE				*prce1, 
								 RCE				*prce2, 
								 VERPROXY			*pverproxy )
	{
	Assert( splitoperNone != psplitPath->psplit->splitoper );

	SPLIT	*psplit = psplitPath->psplit;
	CSR		*pcsrOper = psplit->ilineOper < psplit->ilineSplit ?
							&psplitPath->csr : &psplit->csrNew;
	
	if ( splitoperInsert != psplitPath->psplit->splitoper
		&& !PinstFromIfmp( pfucb->ifmp )->FRecovering() 
		&& FBTIUpdatablePage( *pcsrOper ) )
		{
		Assert( latchWrite == psplitPath->csr.Latch() );
		Assert( pcsrOper->Cpage().FLeafPage() );
		BTISplitSetCbAdjust( psplitPath->psplit, 
							 pfucb,
							 *pkdf,
							 prce1,
							 prce2 );
		}
	
	VERInsertRCEIntoLists( pfucb, &psplitPath->csr, prce1, pverproxy );
	if ( prceNil != prce2 )
		{
		VERInsertRCEIntoLists( pfucb, &psplitPath->csr, prce2, pverproxy );
		}
		
	return;
	}


VOID BTISplitSetCbAdjust( SPLIT 				*psplit,
						  FUCB					*pfucb,
						  const KEYDATAFLAGS& 	kdf,
						  const RCE				*prce1,
						  const RCE				*prce2 )
	{
	Assert( NULL != psplit );
	
	const SPLITOPER splitoper 	= psplit->splitoper;
	const RCE		*prceReplace;
	
	Assert( splitoperReplace == splitoper ||
			splitoperFlagInsertAndReplaceData == splitoper );

	BTISplitGetReplacedNode( pfucb, psplit );
	const INT	cbDataOld = pfucb->kdfCurr.data.Cb();

	if ( splitoper == splitoperReplace )
		{
		Assert( NULL == prce2 );
		prceReplace = prce1;
		}
	else
		{
		Assert( NULL != prce2 );
		prceReplace = prce2;
		}

	Assert( cbDataOld < kdf.data.Cb() );
	Assert( PinstFromIfmp( pfucb->ifmp )->m_plog->m_fRecovering );
	VERSetCbAdjust( &psplit->psplitPath->csr, 
					prceReplace, 
					kdf.data.Cb(),
					cbDataOld, 
					fDoNotUpdatePage );
	}

		
//	sets cursor to point to ilineOper if requested 
//	leaf-level operation was performed successfully
//
VOID BTISplitSetCursor( FUCB *pfucb, SPLITPATH *psplitPathLeaf )
	{
	SPLIT	*psplit = psplitPathLeaf->psplit;

	Assert( NULL != psplit );
	Assert( !Pcsr( pfucb )->FLatched() );
		
	if ( splitoperNone == psplit->splitoper ||
		 !psplit->csrNew.Cpage().FLeafPage() )
		{
		//	split was not performed
		//	set cursor to point to no valid node
		//
		BTUp( pfucb );
		}
	else
		{
		//	set Pcsr( pfucb ) to leaf page with oper
		//	reset CSR copied from to point to no page
		//
		Assert( psplit->csrNew.Cpage().FLeafPage() );
		Assert( splitoperNone != psplitPathLeaf->psplit->splitoper );
		Assert( !Pcsr( pfucb )->FLatched() );

		if ( psplit->ilineOper < psplit->ilineSplit )
			{
			//	ilineOper falls in split page
			//
			*Pcsr( pfucb )			= psplitPathLeaf->csr;
			Pcsr( pfucb )->SetILine( psplit->ilineOper );
			}
		else
			{
			*Pcsr( pfucb )			= psplit->csrNew;
			Pcsr( pfucb )->SetILine( psplit->ilineOper - psplit->ilineSplit );
			}

		Assert( Pcsr( pfucb )->ILine() < Pcsr( pfucb )->Cpage().Clines() );
		NDGet( pfucb );
		}
	}

	
//	performs split
//	this code shared between do and redo phases
//		insert parent page pointers
//		fix sibling page pointers at leaf
//		move nodes
//		set dependencies
//
VOID BTIPerformSplit( FUCB 			*pfucb, 
					  SPLITPATH 	*psplitPathLeaf,
					  KEYDATAFLAGS	*pkdf,
					  DIRFLAG		dirflag )
	{
	SPLITPATH	*psplitPath;

	ASSERT_VALID( pkdf );

	//	go to root
	//	since we need to latch bottom-down
	//
	for ( psplitPath = psplitPathLeaf;
		  psplitPath->psplitPathParent != NULL;
		  psplitPath = psplitPath->psplitPathParent )
		{
		}

	for ( ; psplitPath != NULL; psplitPath = psplitPath->psplitPathChild )
		{
		SPLIT	*psplit = psplitPath->psplit;

		if ( psplit == NULL )
			{
			Assert( psplitPath->psplitPathChild != NULL &&
					psplitPath->psplitPathChild->psplit != NULL );

			//	insert parent page pointer for next level
			//
			BTIInsertPgnoNewAndSetPgnoSplit( pfucb, psplitPath );
			
			continue;
			}

		KEYDATAFLAGS	*pkdfOper;

		if ( splitoperNone == psplit->splitoper ) 
			{
			pkdfOper = NULL;
			}
		else if ( psplit->fNewPageFlags & CPAGE::fPageLeaf )
			{
			pkdfOper = pkdf;
			}
		else
			{
			Assert( psplitPath->psplitPathChild != NULL &&
					psplitPath->psplitPathChild->psplit != NULL );
			pkdfOper = &psplitPath->psplitPathChild->psplit->kdfParent;
			}

		if ( psplit->splittype == splittypeVertical )
			{
			PERFIncCounterTable( cBTVerticalSplit, PinstFromPfucb( pfucb ), pfucb->u.pfcb->Tableclass() );

			//	move all nodes from root to new page
			//
			BTISplitMoveNodes( pfucb, psplit, pkdfOper, dirflag );

			CSR		*pcsrRoot = &psplit->psplitPath->csr;

			if ( FBTIUpdatablePage( *pcsrRoot ) )
				{
				Assert( latchWrite == pcsrRoot->Latch() );
				Assert( pcsrRoot->Cpage().FRootPage() );

				//	set parent page to non-leaf
				//
				pcsrRoot->Cpage().SetFlags( psplit->fSplitPageFlags );

				//	insert page pointer in root zero-sized key
				//
				Assert( NULL != psplit->psplitPath );
				Assert( 0 == pcsrRoot->Cpage().Clines() );

#ifdef DEBUG
				//	check prefix in root is null
				//
				NDGetPrefix( pfucb, pcsrRoot );
				Assert( pfucb->kdfCurr.key.prefix.FNull() );
#endif

				KEYDATAFLAGS		kdf;
				LittleEndian<PGNO>	le_pgnoNew = psplit->pgnoNew;

				kdf.key.Nullify();
				kdf.fFlags = 0;
				Assert( psplit->csrNew.Pgno() == psplit->pgnoNew );
				kdf.data.SetPv( &le_pgnoNew );
				kdf.data.SetCb( sizeof( PGNO ) );
				NDInsert( pfucb, pcsrRoot, &kdf );
				}
				
			if ( psplitPath->psplitPathChild != NULL &&
				 psplitPath->psplitPathChild->psplit != NULL )
				{
				//	replace data in ilineOper + 1 with pgnoNew
				//	assert data in ilineOper is pgnoSplit
				//
				BTIInsertPgnoNew( pfucb, psplitPath );
				AssertBTIVerifyPgnoSplit( pfucb, psplitPath );
				}
			}
		else
			{
			PERFIncCounterTable(
				splittypeAppend == psplit->splittype ? cBTAppendSplit : cBTRightSplit,
				PinstFromPfucb( pfucb ),
				pfucb->u.pfcb->Tableclass() );
			
			Assert( psplit->splittype == splittypeAppend ||
					psplit->splittype == splittypeRight );
			BTISplitMoveNodes( pfucb, psplit, pkdfOper, dirflag );

			if ( psplit->fNewPageFlags & CPAGE::fPageLeaf )
				{
				//	set sibling page pointers
				//
				BTISplitFixSiblings( psplit );
				}
			else
				{
				//	set page pointers
				//
				//	internal pages have no sibling pointers
				//
#ifdef DEBUG
				if ( FBTIUpdatablePage( psplit->csrNew ) )
					{
					Assert( pgnoNull == psplit->csrNew.Cpage().PgnoPrev() );
					Assert( pgnoNull == psplit->csrNew.Cpage().PgnoNext() );
					}
				if ( FBTIUpdatablePage( psplitPath->csr ) )
					{
					Assert( pgnoNull == psplitPath->csr.Cpage().PgnoPrev() );
					Assert( pgnoNull == psplitPath->csr.Cpage().PgnoNext() );
					}
				Assert( pgnoNull == psplit->csrRight.Pgno() );
#endif

				//	replace data in ilineOper + 1 with pgnoNew
				//	assert data in ilineOper is pgnoSplit
				//
				BTIInsertPgnoNew( pfucb, psplitPath );
				AssertBTIVerifyPgnoSplit( pfucb, psplitPath );
				}
			}
		}
	}
	

//	inserts kdfParent of lower level with pgnoSplit as data
//	replace data of next node with pgnoNew
//
LOCAL VOID BTIInsertPgnoNewAndSetPgnoSplit( FUCB *pfucb, SPLITPATH *psplitPath )
	{
	ERR			err;
	CSR			*pcsr = &psplitPath->csr;
	DATA		data;
	BOOKMARK	bmParent;

	if ( !FBTIUpdatablePage( *pcsr ) )
		{
		//	page does not need redo
		//
		return;
		}
	Assert( latchWrite == pcsr->Latch() );
	
	Assert( NULL == psplitPath->psplit );
	Assert( !psplitPath->csr.Cpage().FLeafPage() );
	Assert( psplitPath->psplitPathChild != NULL );
	Assert( psplitPath->psplitPathChild->psplit != NULL );

	SPLIT	*psplit = psplitPath->psplitPathChild->psplit;
	
	Assert( !psplitPath->csr.Cpage().FLeafPage() );
	Assert( sizeof(PGNO) == psplit->kdfParent.data.Cb() );
	Assert( psplit->pgnoSplit ==
			*( reinterpret_cast<UnalignedLittleEndian<PGNO> *>( psplit->kdfParent.data.Pv() ) ) );

	bmParent.key	= psplit->kdfParent.key;
	bmParent.data.Nullify();
	err = ErrNDSeek( pfucb, pcsr, bmParent );
	Assert( err != JET_errSuccess );
	Assert( err != wrnNDFoundLess );
	Assert( err == wrnNDFoundGreater );
	Assert( psplit->pgnoSplit ==
			*( reinterpret_cast<UnalignedLittleEndian< PGNO > *> ( pfucb->kdfCurr.data.Pv() ) ) );
	Assert( pcsr->FDirty() );
	
	BTIComputePrefixAndInsert( pfucb, pcsr, psplit->kdfParent );

	//	go to next node and update pgno to pgnoNew
	//
	Assert( pcsr->ILine() < pcsr->Cpage().Clines() );
	pcsr->IncrementILine();
#ifdef DEBUG
	//	current page pointer should point to pgnoSplit
	//
	NDGet( pfucb, pcsr );
	Assert( sizeof(PGNO) == pfucb->kdfCurr.data.Cb() );
	Assert( psplit->pgnoSplit ==
			*( reinterpret_cast<UnalignedLittleEndian< PGNO > *> 
						( pfucb->kdfCurr.data.Pv() ) ) );
#endif

	LittleEndian<PGNO> le_pgnoNew = psplit->pgnoNew;
	data.SetCb( sizeof( PGNO ) );
	data.SetPv( reinterpret_cast<VOID *> (&le_pgnoNew) );
	NDReplace( pcsr, &data );
	}
	

//	computes prefix for node with repect to given page
//	inserts with appropriate prefix
//
LOCAL VOID BTIComputePrefixAndInsert( FUCB *pfucb, CSR *pcsr, const KEYDATAFLAGS& kdf )
	{
	Assert( latchWrite == pcsr->Latch() );

	INT		cbCommon = CbNDCommonPrefix( pfucb, pcsr, kdf.key );

	if ( cbCommon <= cbPrefixOverhead )
		{
		cbCommon = 0;
		}

	NDInsert( pfucb, pcsr, &kdf, cbCommon );
	return;
	}
	

//	replace data in ilineOper + 1 with pgnoNew at lower level
//
LOCAL VOID BTIInsertPgnoNew( FUCB *pfucb, SPLITPATH *psplitPath )
	{
	SPLIT	*psplit = psplitPath->psplit;
	CSR		*pcsr;
	DATA	data;
	
	Assert( psplit != NULL );
	Assert( splittypeRight == psplit->splittype
		|| ( splittypeVertical == psplit->splittype
				&& psplitPath->psplitPathChild != NULL
				&& psplitPath->psplitPathChild->psplit != NULL ) );
	Assert( psplit->ilineOper < psplit->clines - 1 );
	Assert( psplitPath->psplitPathChild != NULL );
	Assert( psplitPath->psplitPathChild->psplit != NULL );
	Assert( !FBTIUpdatablePage( psplitPath->csr )
		|| !psplitPath->csr.Cpage().FLeafPage() );
	Assert( !FBTIUpdatablePage( psplit->csrNew )
		|| !psplit->csrNew.Cpage().FLeafPage() );

	LittleEndian<PGNO> le_pgnoNew = psplitPath->psplitPathChild->psplit->pgnoNew;
	data.SetCb( sizeof( PGNO ) );
	data.SetPv( reinterpret_cast<BYTE *>(&le_pgnoNew) );
					
	if ( psplit->ilineOper + 1 >= psplit->ilineSplit )
		{
		//	page pointer to new page falls in new page
		//
		pcsr			= &psplit->csrNew;
		pcsr->SetILine( psplit->ilineOper + 1 - psplit->ilineSplit );
		}
	else
		{
		//	page pointer falls in split page
		//
		Assert( splittypeVertical != psplit->splittype );
		pcsr			= &psplit->psplitPath->csr;
		pcsr->SetILine( psplit->ilineOper + 1 );
		}

	if ( !FBTIUpdatablePage( *pcsr ) )
		{
		//	page does not need redo
		//
		return;
		}
	Assert( latchWrite == pcsr->Latch() );
	
	//	check that we already dirtied these pages
	//
	Assert( pcsr->FDirty() );

#ifdef DEBUG
	//	current page pointer should point to pgnoSplit
	//
	NDGet( pfucb, pcsr );
	Assert( sizeof(PGNO) == pfucb->kdfCurr.data.Cb() );
	Assert( psplitPath->psplitPathChild->psplit->pgnoSplit ==
			*( reinterpret_cast<UnalignedLittleEndian< PGNO >  *> 
					(pfucb->kdfCurr.data.Pv() ) ) );
#endif

	NDReplace( pcsr, &data );
	}


//	fixes sibling pages of split, new and right pages
//
LOCAL VOID BTISplitFixSiblings( SPLIT *psplit )
	{
	SPLITPATH	*psplitPath = psplit->psplitPath;
	
	//	set sibling page pointers only if page is write-latched
	//
	if ( FBTIUpdatablePage( psplit->csrNew ) )
		{
		psplit->csrNew.Cpage().SetPgnoPrev( psplit->pgnoSplit );
		}

	if ( FBTIUpdatablePage( psplitPath->csr ) )
		{
		psplitPath->csr.Cpage().SetPgnoNext( psplit->pgnoNew );
		}

	if ( pgnoNull != psplit->csrRight.Pgno() )
		{
		Assert( psplit->splittype == splittypeRight );

		if ( FBTIUpdatablePage( psplit->csrRight ) )
			{
			Assert( psplit->csrRight.FDirty() );
			psplit->csrRight.Cpage().SetPgnoPrev( psplit->pgnoNew );
			}

		if ( FBTIUpdatablePage( psplit->csrNew ) )
			{
			psplit->csrNew.Cpage().SetPgnoNext( psplit->csrRight.Pgno() );
			}
		}
	else
		{
		Assert( pgnoNull == psplit->csrNew.Cpage().PgnoNext() || 
				!FBTIUpdatablePage( psplit->csrNew ) );
		}
	return;
	}


//	move nodes from src to dest page
//	set prefix in destination page
//	move nodes >= psplit->ilineSplit
//	if oper is not operNone, perform oper on ilineOper
//	set prefix in src page [in-page]
//	set cbUncommittedFree in src and dest pages
//	move undoInfo of moved nodes to destination page
//
VOID BTISplitMoveNodes( FUCB			*pfucb, 
						SPLIT			*psplit, 
						KEYDATAFLAGS	*pkdf, 
						DIRFLAG			dirflag )
	{
	CSR				*pcsrSrc		= &psplit->psplitPath->csr;
	CSR				*pcsrDest		= &psplit->csrNew;
	INT				cLineInsert 	= psplit->splitoper == splitoperInsert ? 1 : 0;
	const LINEINFO	*plineinfoOper	= &psplit->rglineinfo[psplit->ilineOper];

	Assert( splittypeVertical != psplit->splittype
		|| 0 == psplit->ilineSplit );
	Assert( splittypeVertical == psplit->splittype
		|| 0 < psplit->ilineSplit );
	Assert( !( psplit->fSplitPageFlags & CPAGE::fPageRoot )
		|| splittypeVertical == psplit->splittype );
	Assert( psplit->splitoper != splitoperNone
		|| 0 == psplit->ilineOper );

	Assert( !FBTIUpdatablePage( *pcsrDest ) || pcsrDest->FDirty() );
	Assert( !FBTIUpdatablePage( *pcsrSrc ) || pcsrSrc->FDirty() );
	
	pcsrDest->SetILine( 0 );
	BTICheckSplitLineinfo( pfucb, psplit, *pkdf );

	//	set prefix in destination page
	//
	if ( psplit->prefixinfoNew.ilinePrefix != ilineInvalid
		&& FBTIUpdatablePage( *pcsrDest ) )
		{
		const INT	ilinePrefix = psplit->prefixinfoNew.ilinePrefix + psplit->ilineSplit;

		Assert( ilinePrefix < psplit->clines );
		Assert( ilinePrefix >= psplit->ilineSplit );
			
		NDSetPrefix( pcsrDest, psplit->rglineinfo[ilinePrefix].kdf.key );
		}
	
	//	move every node from Src to Dest
	//
	if ( psplit->splitoper != splitoperNone
		&& psplit->ilineOper >= psplit->ilineSplit )
		{
		//	ilineOper falls in Dest page
		//	copy lines from ilineSplit till ilineOper - 1 from Src to Dest
		//	perform oper
		//	copy remaining lines
		//	delete copied lines from Src
		//
		Assert( 0 == pcsrDest->ILine() );
		BTISplitBulkCopy( pfucb, 
						  psplit,
						  psplit->ilineSplit,
						  psplit->ilineOper - psplit->ilineSplit );
		
		//	insert ilineOper
		//
		pcsrSrc->SetILine( psplit->ilineOper );

		if ( FBTIUpdatablePage( *pcsrDest ) )
			{
			//	if need to redo destination, must need to redo source page as well
			Assert( FBTIUpdatablePage( *pcsrSrc )
				|| !FBTISplitDependencyRequired( psplit ) );
			Assert( psplit->ilineOper - psplit->ilineSplit == pcsrDest->ILine() );
			Assert( psplit->ilineOper - psplit->ilineSplit == pcsrDest->Cpage().Clines() );

			switch( psplit->splitoper )
				{
				case splitoperNone:
					Assert( fFalse );
					break;

				case splitoperInsert:
#ifdef DEBUG
					{
					const INT	cbCommon = CbNDCommonPrefix( pfucb, pcsrDest, pkdf->key );
					if ( cbCommon > cbPrefixOverhead )
						{
						Assert( cbCommon == plineinfoOper->cbPrefix  ) ;
						}
					else
						{
						Assert( 0 == plineinfoOper->cbPrefix );
						}
					}
#endif
					NDInsert( pfucb, pcsrDest, pkdf, plineinfoOper->cbPrefix );
					if ( !( dirflag & fDIRNoVersion ) && 
						 !rgfmp[ pfucb->ifmp ].FVersioningOff() &&
						 ( psplit->fNewPageFlags & CPAGE::fPageLeaf ) )
						{
						//	UNDONE: assert version for this node exists
						//
						CallS( ErrNDFlagVersion( pcsrDest ) );
						}
					else
						{
#ifdef	DEBUG
						NDGet( pfucb, pcsrDest );
						Assert( !FNDVersion( pfucb->kdfCurr ) );
#endif
						}
					break;

				default:
					Assert( psplit->splitoper == splitoperFlagInsertAndReplaceData ||
							psplit->splitoper == splitoperReplace );
					Assert( psplit->ilineOper == pcsrSrc->ILine() );
					Assert( pkdf->data == plineinfoOper->kdf.data );

					NDInsert( pfucb, 
							  pcsrDest, 
							  &plineinfoOper->kdf,
							  plineinfoOper->cbPrefix );

					if ( splitoperReplace != psplit->splitoper )
						{
#ifdef DEBUG
						NDGet( pfucb, pcsrDest );
						Assert( FNDDeleted( pfucb->kdfCurr ) );
#endif
						NDResetFlagDelete( pcsrDest );
						NDGet( pfucb, pcsrDest );
						}
					else
						{
#ifdef	DEBUG
						NDGet( pfucb, pcsrDest );
						Assert( !FNDDeleted( pfucb->kdfCurr ) );
#endif
						}

					if ( !( dirflag & fDIRNoVersion ) && 
						 !rgfmp[ pfucb->ifmp ].FVersioningOff( ) &&
						 ( psplit->fNewPageFlags & CPAGE::fPageLeaf ) )
						{
						//	UNDONE: assert version for this node exists
						//
						CallS( ErrNDFlagVersion( pcsrDest ) );
						}
					else
						{
#ifdef DEBUG
						NDGet( pfucb, pcsrDest );
						Assert( !FNDVersion( pfucb->kdfCurr ) ||
								FNDVersion( plineinfoOper->kdf ) );
						Assert( FNDVersion( pfucb->kdfCurr ) ||
								!FNDVersion( plineinfoOper->kdf ) );
#endif
						}
				}
			}

		pcsrDest->IncrementILine();
		Assert( pcsrDest->Cpage().Clines() == pcsrDest->ILine() || 
				latchRIW == pcsrDest->Latch() );
		
		BTISplitBulkCopy( pfucb,
						  psplit, 
						  psplit->ilineOper + 1, 
						  psplit->clines - psplit->ilineOper - 1 );

		pcsrSrc->SetILine( psplit->ilineSplit );
		BTISplitBulkDelete( pcsrSrc, 
				psplit->clines - psplit->ilineSplit - cLineInsert );

		//	set prefix in source page
		//
		if ( splittypeAppend != psplit->splittype )
			{
			//	set new prefix in src page
			//	adjust nodes in src to correspond to new prefix
			//
			BTISplitSetPrefixInSrcPage( pfucb, psplit );
			}
		}
	else
		{
		//	oper node is in Src page
		//	move nodes to Dest page
		//	delete nodes that have been moved
		//	perform oper in Src page
		//
		Assert( psplit->ilineOper < psplit->ilineSplit ||
				splitoperNone == psplit->splitoper );
				
		pcsrSrc->SetILine( psplit->ilineSplit - cLineInsert );
		Assert( 0 == pcsrDest->ILine() );
		
		BTISplitBulkCopy( pfucb, 
						  psplit,
						  psplit->ilineSplit,
						  psplit->clines - psplit->ilineSplit );

		Assert( psplit->ilineSplit - cLineInsert == pcsrSrc->ILine() );
		BTISplitBulkDelete( pcsrSrc, 
							psplit->clines - psplit->ilineSplit );

		//	set prefix
		//
		Assert( splittypeAppend != psplit->splittype );
		BTISplitSetPrefixInSrcPage( pfucb, psplit );

		//	can't use rglineinfo[].kdf anymore
		//	since page may have been reorged
		//

		pcsrSrc->SetILine( psplit->ilineOper );

		if ( FBTIUpdatablePage( *pcsrSrc ) )
			{
			switch ( psplit->splitoper )
				{
				case splitoperNone:
					break;

				case splitoperInsert:
					NDInsert( pfucb, pcsrSrc, pkdf, plineinfoOper->cbPrefix );
					if ( !( dirflag & fDIRNoVersion ) && 
						 !rgfmp[ pfucb->ifmp ].FVersioningOff( ) &&
						 ( psplit->fNewPageFlags & CPAGE::fPageLeaf ) )
						{
						//	UNDONE: assert version for this node exists
						//
						CallS( ErrNDFlagVersion( pcsrSrc ) );
						}
					else
						{
#ifdef DEBUG
						NDGet( pfucb, pcsrSrc );
						Assert( !FNDVersion( pfucb->kdfCurr ) );
#endif
						}

					break;
				
				default:
					//	replace data
					//	by deleting and re-inserting [to avoid page reorg problems]
					//
					Assert( psplit->splitoper == splitoperFlagInsertAndReplaceData ||
							psplit->splitoper == splitoperReplace );

#ifdef DEBUG
					//	assert that key of node is in pfucb->bmCurr
					//
					NDGet( pfucb, pcsrSrc );
					Assert( FFUCBUnique( pfucb ) );
					Assert( FKeysEqual( pfucb->bmCurr.key, pfucb->kdfCurr.key ) );
#endif

					NDDelete( pcsrSrc );

					Assert( !pkdf->data.FNull() );
					Assert(	pkdf->data.Cb() > pfucb->kdfCurr.data.Cb() );
					Assert( pcsrSrc->ILine() == psplit->ilineOper );

					KEYDATAFLAGS	kdfInsert;
					kdfInsert.data		= pkdf->data;
					kdfInsert.key		= pfucb->bmCurr.key;
					kdfInsert.fFlags	= 0;
				
					NDInsert( pfucb, pcsrSrc, &kdfInsert, plineinfoOper->cbPrefix );
					if ( !( dirflag & fDIRNoVersion ) && 
						 !rgfmp[ pfucb->ifmp ].FVersioningOff( ) &&
						 ( psplit->fNewPageFlags & CPAGE::fPageLeaf ) )
						{
						//	UNDONE: assert version for this node exists
						//
						CallS( ErrNDFlagVersion( pcsrSrc ) );
						}
					else
						{
#ifdef DEBUG
						NDGet( pfucb, pcsrDest );
						Assert( !FNDVersion( pfucb->kdfCurr ) );
#endif
						}

					break;
				}
			}
		else
			{
			//	if we didn't need to redo the source page, we shouldn't need to redo the
			//	destination page
			Assert( !FBTIUpdatablePage( *pcsrDest ) );
			}
		}

	if ( psplit->fNewPageFlags & CPAGE::fPageLeaf )
		{
		//	set cbUncommittedFreed in src and dest pages
		//
		Assert( PinstFromIfmp( pfucb->ifmp )->FRecovering()
			|| ( pcsrDest->Cpage().FLeafPage() && latchWrite == pcsrDest->Latch() ) );
		if ( FBTIUpdatablePage( *pcsrDest ) )
			{
			//	if need to redo destination, must need to redo source page as well
			Assert( FBTIUpdatablePage( *pcsrSrc )
				|| !FBTISplitDependencyRequired( psplit ) );
			pcsrDest->Cpage().SetCbUncommittedFree( psplit->cbUncFreeDest );
			if ( pcsrDest->Cpage().FSpaceTree() )
				{
				Assert( 0 == psplit->cbUncFreeDest );
				}
			else
				{
				Assert( CbNDUncommittedFree( pfucb, pcsrDest ) <= psplit->cbUncFreeDest );
				}
			}

		if ( FBTIUpdatablePage( *pcsrSrc ) )
			{
			pcsrSrc->Cpage().SetCbUncommittedFree( psplit->cbUncFreeSrc );
			if ( pcsrSrc->Cpage().FSpaceTree() )
				{
				Assert( 0 == psplit->cbUncFreeSrc );
				}
			else
				{
				Assert( CbNDUncommittedFree( pfucb, pcsrSrc ) <= psplit->cbUncFreeSrc );
				}
			}
		else
			{
			//	if we didn't need to redo the source page, we shouldn't need to redo the
			//	destination page if not an append
			Assert( !FBTIUpdatablePage( *pcsrDest )
				|| !FBTISplitDependencyRequired( psplit ) );
			}


		//	move UndoInfo of moved nodes to destination page
		//
		Assert( ( splittypeVertical == psplit->splittype && psplit->kdfParent.key.FNull() )
			|| ( splittypeVertical != psplit->splittype && !psplit->kdfParent.key.FNull() ) );
		if ( FBTIUpdatablePage( *pcsrSrc ) )
			{
			VERMoveUndoInfo( pfucb, pcsrSrc, pcsrDest, psplit->kdfParent.key );
			}
		else
			{
			//	if we didn't need to redo the source page, we shouldn't need to redo the
			//	destination page if not an append
			Assert( !FBTIUpdatablePage( *pcsrDest )
				|| !FBTISplitDependencyRequired( psplit ) );
			}
		}
	else
		{
		Assert( 0 == psplit->cbUncFreeSrc );
		Assert( 0 == psplit->cbUncFreeDest );
		
#ifdef DEBUG
		if ( !PinstFromIfmp( pfucb->ifmp )->FRecovering() )
			{
			Assert( !pcsrDest->Cpage().FLeafPage() );
			Assert( pcsrSrc->Cpage().CbUncommittedFree() == 0 );
			Assert( pcsrDest->Cpage().CbUncommittedFree() == 0 );
			}
#endif
		}

	return; 
	}
	

INLINE VOID BTISplitBulkDelete( CSR * pcsr, INT clines )
	{
	if ( !FBTIUpdatablePage( *pcsr ) )
		{
		//	page does not need redo
		//
		return;
		}
	Assert( latchWrite == pcsr->Latch() );
	
	NDBulkDelete( pcsr, clines );
	}

	
//	copy clines starting from rglineInfo[ilineStart] to csrDest
//	prefixes have been calculated in rglineInfo
//
VOID BTISplitBulkCopy( FUCB *pfucb, SPLIT *psplit, INT ilineStart, INT clines )
	{
	INT			iline;
	const INT	ilineEnd	= ilineStart + clines;
	CSR			*pcsrDest	= &psplit->csrNew;
	
	if ( !FBTIUpdatablePage( *pcsrDest ) )
		{
		//	page does not need redo
		//
		return;
		}
	Assert( latchWrite == pcsrDest->Latch() );
	
	Assert( ilineEnd <= psplit->clines );
	for ( iline = ilineStart; iline < ilineEnd; iline++ )
		{
		Assert( iline != psplit->ilineOper || 
				splitoperNone == psplit->splitoper );
		Assert( pcsrDest->Cpage().Clines() == pcsrDest->ILine() );

		const LINEINFO	* plineinfo	= &psplit->rglineinfo[iline];

#ifdef DEBUG
		const INT		cbCommon	= CbNDCommonPrefix( pfucb, pcsrDest, plineinfo->kdf.key );
		if ( cbCommon > cbPrefixOverhead )
			{
			Assert( cbCommon == plineinfo->cbPrefix  ) ;
			}
		else
			{
			Assert( 0 == plineinfo->cbPrefix );
			}
#endif

		NDInsert( pfucb, pcsrDest, &plineinfo->kdf, plineinfo->cbPrefix );

		pcsrDest->IncrementILine();	
		}
	}


//	returns reference to rglineInfo corresponding to iline
//
INLINE const LINEINFO *PlineinfoFromIline( SPLIT *psplit, INT iline )
	{
	Assert( iline < psplit->clines );
	if ( psplit->splitoper != splitoperInsert ||
		 iline < psplit->ilineOper )
		{
		return &psplit->rglineinfo[iline];
		}

	Assert( psplit->splitoper == splitoperInsert );
	Assert( iline >= psplit->ilineOper );
	Assert( iline + 1 < psplit->clines );
	
	return &psplit->rglineinfo[iline+1];
	}

//	set prefix in page to psplit->prefix and reorg nodes
//
VOID BTISplitSetPrefixInSrcPage( FUCB *pfucb, SPLIT *psplit )
	{
	Assert( psplit->splittype != splittypeAppend );
	Assert( !psplit->prefixSplitNew.FNull()
		|| psplit->prefixinfoSplit.ilinePrefix == ilineInvalid );

	CSR			*pcsr = &psplit->psplitPath->csr;

	if ( !FBTIUpdatablePage( *pcsr ) )
		{
		//	page does not need redo
		//
		return;
		}
	Assert( latchWrite == pcsr->Latch() );
		
	const DATA	*pprefixOld = &psplit->prefixSplitOld;
	const DATA 	*pprefixNew = &psplit->prefixSplitNew;
	Assert( psplit->prefixinfoSplit.ilinePrefix != ilineInvalid ||
			pprefixNew->FNull() );
	Assert( psplit->prefixinfoSplit.ilinePrefix == ilineInvalid ||
			!pprefixNew->FNull() );

	INT			iline;
	const INT	clines = pcsr->Cpage().Clines();
	
	//	delete old prefix
	//
	if ( !pprefixOld->FNull() )
		{
		KEY	keyNull;

		keyNull.Nullify();
		NDSetPrefix( pcsr, keyNull );
		}
	else
		{
#ifdef DEBUG
		//	check prefix was null before
		//
		NDGetPrefix( pfucb, pcsr );
		Assert( pfucb->kdfCurr.key.FNull() );
#endif
		}

	//	fix nodes that shrink because of prefix change
	//
	for ( iline = 0; iline < clines; iline++ )
		{
		pcsr->SetILine( iline );
		NDGet( pfucb, pcsr );

		const LINEINFO	*plineinfo = PlineinfoFromIline( psplit, iline );
		Assert( plineinfo->cbPrefix == 0 ||
				plineinfo->cbPrefix > cbPrefixOverhead );
		
#ifdef DEBUG
		KEY		keyPrefix;
		
		keyPrefix.Nullify();
		keyPrefix.prefix = *pprefixNew;

		const INT	cbCommonKey = CbCommonKey( keyPrefix, pfucb->kdfCurr.key );

		if ( cbCommonKey > cbPrefixOverhead )
			{
			Assert( cbCommonKey == plineinfo->cbPrefix );
			}
		else
			{
			Assert( plineinfo->cbPrefix == 0 );
			}
#endif

		if ( plineinfo->cbPrefix > pfucb->kdfCurr.key.prefix.Cb() )
			{

			NDGrowCbPrefix( pfucb, pcsr, plineinfo->cbPrefix );

#ifdef DEBUG
			NDGet( pfucb, pcsr );
			Assert( pfucb->kdfCurr.key.prefix.Cb() == plineinfo->cbPrefix );
#endif
			}
		}

	//	fix nodes that grow because of prefix change
	//
	for ( iline = 0; iline < clines; iline++ )
		{
		pcsr->SetILine( iline );
		NDGet( pfucb, pcsr );

		const LINEINFO	*plineinfo = PlineinfoFromIline( psplit, iline );
		Assert( plineinfo->cbPrefix == 0 ||
				plineinfo->cbPrefix > cbPrefixOverhead );

		if ( plineinfo->cbPrefix < pfucb->kdfCurr.key.prefix.Cb() )
			{
			NDShrinkCbPrefix( pfucb, pcsr, pprefixOld, plineinfo->cbPrefix );

#ifdef DEBUG
			NDGet( pfucb, pcsr );
			Assert( pfucb->kdfCurr.key.prefix.Cb() == plineinfo->cbPrefix );
#endif
			}
		}

	//	set new prefix
	//
	KEY		keyPrefixNew;

	keyPrefixNew.Nullify();
	keyPrefixNew.prefix = *pprefixNew;
	NDSetPrefix( pcsr, keyPrefixNew );

	return;
	}


//	releases splitPath at this level
//	also releases any latches held at this level
//		sets pointers at parent and child SplitPath's to NULL
//
VOID BTIReleaseOneSplitPath( INST *pinst, SPLITPATH *psplitPath )
	{
	if ( psplitPath->psplit != NULL )
		{
		BTIReleaseSplit( pinst, psplitPath->psplit );
		psplitPath->psplit = NULL;
		}

	if ( pgnoNull != psplitPath->csr.Pgno() )
		{
		Assert( psplitPath->csr.FLatched() );
		psplitPath->csr.ReleasePage();
		psplitPath->csr.Reset();
		}

//	delete( &psplitPath->csr.Cpage() );

	if ( NULL != psplitPath->psplitPathParent )
		{
		psplitPath->psplitPathParent->psplitPathChild = NULL;
		}
		
	if ( NULL != psplitPath->psplitPathChild )
		{
		psplitPath->psplitPathChild->psplitPathParent = NULL;
		}

	OSMemoryHeapFree( psplitPath );
	}

	
//	releases whole chain of splitpath's
//	from leaf to root
//
VOID BTIReleaseSplitPaths( INST *pinst, SPLITPATH *psplitPathLeaf )
	{
	SPLITPATH *psplitPath = psplitPathLeaf;
	
	for ( ; psplitPath != NULL; )
		{
		//	save parent 
		//
		SPLITPATH *psplitPathParent = psplitPath->psplitPathParent;

		BTIReleaseOneSplitPath( pinst, psplitPath );
		psplitPath = psplitPathParent;
		}
	}

	
VOID BTIReleaseSplit( INST *pinst, SPLIT *psplit )
	{
	if ( psplit->fAllocParent )
		{
		//	space is allocated for leaf pages only
		//	for internal pages, this is not allocated space
		//
		Assert( !psplit->kdfParent.key.FNull() );
		Assert( pinst->m_plog->m_fRecovering || 
				!psplit->csrNew.FLatched() ||
				psplit->csrNew.Cpage().FLeafPage() );
				
		OSMemoryHeapFree( psplit->kdfParent.key.suffix.Pv() );
		psplit->fAllocParent = fFalse;
		}
		
	if ( psplit->prefixSplitOld.Pv() != NULL )
		{
		Assert( psplit->prefixSplitOld.Cb() > 0 );
		OSMemoryHeapFree( psplit->prefixSplitOld.Pv() );
		psplit->prefixSplitOld.Nullify();
		}
	
	if ( psplit->prefixSplitNew.Pv() != NULL )
		{
		Assert( psplit->prefixSplitNew.Cb() > 0 );
		OSMemoryHeapFree( psplit->prefixSplitNew.Pv() );
		psplit->prefixSplitNew.Nullify();
		}
			
	if ( psplit->csrNew.FLatched() )
		{
		psplit->csrNew.ReleasePage();
		}
//	delete( &psplit->csrNew.Cpage() );
	
	if ( psplit->csrRight.FLatched() )
		{
		psplit->csrRight.ReleasePage();
		}
//	delete( &psplit->csrRight.Cpage() );

	if ( psplit->rglineinfo != NULL )
		{
		delete [] psplit->rglineinfo;
		psplit->rglineinfo = NULL;
		}
	OSMemoryHeapFree( psplit );
	}


//	checks to make sure there are no erroneous splits
//	if there is a operNone split at any level,
//		there should be no splits at lower levels
//
LOCAL VOID BTISplitCheckPath( SPLITPATH *psplitPathLeaf )
	{
#ifdef DEBUG
	SPLITPATH	*psplitPath; 
	BOOL		fOperNone = fFalse;
	
	//	goto root
	//
	for ( psplitPath = psplitPathLeaf;
		  psplitPath->psplitPathParent != NULL;
		  psplitPath = psplitPath->psplitPathParent )
		{
		}

	Assert( NULL == psplitPath->psplit ||
			splittypeVertical == psplitPath->psplit->splittype );

	for ( ; psplitPath != NULL; psplitPath = psplitPath->psplitPathChild )
		{
		SPLIT	*psplit = psplitPath->psplit;

		if ( fOperNone )
			{
			//	higher level has a split with no oper
			//
			Assert( NULL == psplit );
			}
		else
			{
			if ( psplit != NULL && splitoperNone == psplit->splitoper )
				{
				fOperNone = fTrue;
				}
			}
		}
#endif
	}


//	checks lineinfo in split point to the right nodes
//
VOID BTICheckSplitLineinfo( FUCB *pfucb, SPLIT *psplit, const KEYDATAFLAGS& kdf )
	{
#ifdef DEBUG
	if ( PinstFromIfmp( pfucb->ifmp )->FRecovering() && psplit->psplitPath->csr.Latch() != latchWrite )
		{
		return;
		}

	INT				iline;
	CSR				*pcsr 		= &psplit->psplitPath->csr;
	const INT		clines 		= pcsr->Cpage().Clines();
	const SPLITOPER	splitoper	= psplit->splitoper;
	
	for ( iline = 0; iline < clines; iline++ )
		{
		const LINEINFO	*plineinfo = PlineinfoFromIline( psplit, iline );

		pcsr->SetILine( iline );
		NDGet( pfucb, pcsr );

		if ( splitoper == splitoperInsert ||
			 iline != psplit->ilineOper )
			{
			Assert( FKeysEqual( plineinfo->kdf.key, pfucb->kdfCurr.key ) );
			Assert( FDataEqual( plineinfo->kdf.data, pfucb->kdfCurr.data ) );
///			Assert( plineinfo->kdf.fFlags == pfucb->kdfCurr.fFlags );
			}
		else if ( splitoper == splitoperNone )
			{
			}
		else
			{
			Assert( iline == psplit->ilineOper );
			if ( splitoper != splitoperReplace )
				{
				Assert( FKeysEqual( plineinfo->kdf.key, kdf.key ) );
				}
			else
				{
				Assert( kdf.key.FNull() );
				}

			Assert( FKeysEqual( pfucb->kdfCurr.key, plineinfo->kdf.key ) );
			Assert( FDataEqual( plineinfo->kdf.data, kdf.data ) );
			}
		}

	//	check ilineOper
	//
	LINEINFO	*plineinfo = &psplit->rglineinfo[psplit->ilineOper];
	if ( splitoperInsert == psplit->splitoper )
		{
		Assert( plineinfo->kdf == kdf );
		}
#endif
	}

	
//	check if a split just performed is correct
//
VOID BTICheckSplits( FUCB 			*pfucb, 
					SPLITPATH		*psplitPathLeaf,
					KEYDATAFLAGS	*pkdf,
					DIRFLAG			dirflag )
	{
#ifdef DEBUG
	SPLITPATH	*psplitPath;
	for ( psplitPath = psplitPathLeaf; 
		  psplitPath != NULL; 
		  psplitPath = psplitPath->psplitPathParent )
		{
		BTICheckOneSplit( pfucb, psplitPath, pkdf, dirflag );
		}
#endif
	}


LOCAL VOID BTICheckSplitFlags( const SPLIT *psplit )
	{
#ifdef DEBUG
	const SPLITPATH	*psplitPath = psplit->psplitPath;
	
	if ( psplit->splittype == splittypeVertical )
		{
		Assert( psplit->fSplitPageFlags & CPAGE::fPageRoot );
		Assert( !( psplit->fSplitPageFlags & CPAGE::fPageLeaf ) );
		
		if ( psplitPath->csr.Cpage().FLeafPage() )
			{
			Assert( psplit->fNewPageFlags | CPAGE::fPageLeaf );
			Assert( fGlobalRepair || ( psplit->fSplitPageFlags & CPAGE::fPageParentOfLeaf ) );
			}
		else
			{
			Assert( !( psplit->fSplitPageFlags & CPAGE::fPageParentOfLeaf ) );
			}
		}
	else
		{
		Assert( psplit->fNewPageFlags == psplit->fSplitPageFlags );
		Assert( psplitPath->csr.Cpage().FFlags() == psplit->fNewPageFlags );
		Assert( !( psplit->fSplitPageFlags & CPAGE::fPageRoot ) );
		}

	Assert( !( psplit->fNewPageFlags & CPAGE::fPageRoot ) );
	Assert( !(psplit->fNewPageFlags & CPAGE::fPageEmpty ) );
	Assert( !(psplit->fSplitPageFlags & CPAGE::fPageEmpty ) );
#endif
	}

	
//	check split at one level
//
VOID BTICheckOneSplit( FUCB 			*pfucb, 
					   SPLITPATH		*psplitPath,
					   KEYDATAFLAGS		*pkdf,
					   DIRFLAG			dirflag )
	{
#ifdef DEBUG
	SPLIT			*psplit = psplitPath->psplit;
	const DBTIME	dbtime	= psplitPath->csr.Dbtime();

//	UNDONE:	check lgpos of all pages is the same
//	const LGPOS		lgpos;
	
	//	check that nodes in every page are in order
	//	this will be done by node at NDGet
	//

	//	check that key at parent > all sons
	//
	if ( psplit == NULL )
		{
		return;
		}

	Assert( psplit->csrNew.Pgno() == psplit->pgnoNew );
	switch ( psplit->splittype )
		{
		case splittypeVertical:
			{
			CSR 	*pcsrRoot = &psplitPath->csr;
		
			//	parent page has only one node
			//
			Assert( pcsrRoot->Cpage().FRootPage() );
			Assert( !pcsrRoot->Cpage().FLeafPage() );
			Assert( 1 == pcsrRoot->Cpage().Clines() );
			Assert( pcsrRoot->Dbtime() == dbtime );
			Assert( psplit->csrNew.Dbtime() == dbtime );

			NDGet( pfucb, pcsrRoot );
			Assert( pfucb->kdfCurr.key.FNull() );
			Assert( sizeof( PGNO ) == pfucb->kdfCurr.data.Cb() );
			Assert( psplit->pgnoNew == *( (UnalignedLittleEndian< PGNO > *)pfucb->kdfCurr.data.Pv() ) );
			}
			break;	

		case splittypeAppend:
			//	assert no node is moved
			//
			Assert( psplit->csrNew.Cpage().Clines() == 1 );
			Assert( psplit->csrRight.Pgno() == pgnoNull );
			Assert( psplit->csrNew.Cpage().PgnoNext() == pgnoNull );

		case splittypeRight:
			CSR				*pcsrParent		= &psplitPath->psplitPathParent->csr;
			CSR				*pcsrSplit		= &psplitPath->csr;
			CSR				*pcsrNew		= &psplit->csrNew;
			CSR				*pcsrRight		= &psplit->csrRight;

			KEYDATAFLAGS	kdfLess, kdfGreater;
			
			//	if parent is undergoing a vertical split, new page is parent
			//
			if ( psplitPath->psplitPathParent->psplit != NULL &&
				 splittypeVertical == psplitPath->psplitPathParent->psplit->splittype )
				{
				pcsrParent = &psplitPath->psplitPathParent->psplit->csrNew;
				}

			Assert( pcsrSplit->Dbtime() == dbtime );
			Assert( pcsrNew->Dbtime() == dbtime );
			Assert( pcsrParent->Dbtime() == dbtime );
			
			//	check split, new and right pages are in order
			//
			NDMoveLastSon( pfucb, pcsrSplit );
			kdfLess = pfucb->kdfCurr;

			NDMoveFirstSon( pfucb, pcsrNew );
			kdfGreater = pfucb->kdfCurr;

			if ( pcsrNew->Cpage().FLeafPage() )
				{
				Assert( CmpKeyData( kdfLess, kdfGreater ) < 0 || fGlobalRepair );
				}
			else
				{
				Assert( sizeof( PGNO ) == kdfGreater.data.Cb() );
				Assert( sizeof( PGNO ) == kdfLess.data.Cb() );
				Assert( !kdfLess.key.FNull() );
				Assert( kdfGreater.key.FNull() ||
						CmpKey( kdfLess.key, kdfGreater.key ) < 0 );
				}

			if ( pcsrRight->Pgno() != pgnoNull )
				{
				Assert( pcsrRight->Dbtime() == dbtime );
				Assert( pcsrRight->Cpage().FLeafPage() );
				NDMoveLastSon( pfucb, pcsrNew );
				kdfLess = pfucb->kdfCurr;

				NDMoveFirstSon( pfucb, pcsrRight );
				kdfGreater = pfucb->kdfCurr;

				Assert( CmpKeyData( kdfLess, kdfGreater ) < 0 );

				//	right page should also be >= parent of new page
				//
				
				}

			//	check parent pointer key > all nodes in child page
			//
			NDMoveFirstSon( pfucb, pcsrParent );

			Assert( sizeof( PGNO ) == pfucb->kdfCurr.data.Cb() );
			PGNO	pgnoChild = *( (UnalignedLittleEndian< PGNO > *)pfucb->kdfCurr.data.Pv() );
			for ( ; pgnoChild != psplit->pgnoSplit ; )
				{

				Assert( pgnoChild != psplit->pgnoNew );
				Assert( pgnoChild != psplit->csrRight.Pgno() );

				//	get next page-pointer node
				//
				if ( pcsrParent->ILine() + 1 == pcsrParent->Cpage().Clines() )
					{
					Assert( psplitPath->psplitPathParent->psplit != NULL );
					pcsrParent = &psplitPath->psplitPathParent->psplit->csrNew;
					NDMoveFirstSon( pfucb, pcsrParent );
					}
				else
					{
					pcsrParent->IncrementILine();
					}
					
				Assert( pcsrParent->ILine() < pcsrParent->Cpage().Clines() );
				NDGet( pfucb, pcsrParent );
				
				Assert( sizeof( PGNO ) == pfucb->kdfCurr.data.Cb() );
				pgnoChild = *( (UnalignedLittleEndian< PGNO > *)pfucb->kdfCurr.data.Pv() );
				}

			Assert( pgnoChild == psplit->pgnoSplit );
			kdfGreater = pfucb->kdfCurr;

			NDMoveLastSon( pfucb, pcsrSplit );
			if ( pcsrSplit->Cpage().FLeafPage() && !FFUCBRepair( pfucb ) )
				{
				if ( !FFUCBUnique( pfucb ) )
					{
					Assert( kdfGreater.key.FNull() ||				
							CmpKeyWithKeyData( kdfGreater.key, pfucb->kdfCurr ) > 0 );
					}
				else
					{
					Assert( kdfGreater.key.FNull() ||
							CmpKey( kdfGreater.key, pfucb->kdfCurr.key ) > 0 );
					}
				}
			else
				{
				//	no suffix compression at internal levels
				//
				Assert( FKeysEqual( kdfGreater.key, pfucb->kdfCurr.key ) );
				}

			//	next page pointer should point to new page
			//
			if ( pcsrParent->ILine() + 1 == pcsrParent->Cpage().Clines() )
				{
				Assert( psplitPath->psplitPathParent->psplit != NULL );
				pcsrParent = &psplitPath->psplitPathParent->psplit->csrNew;
				NDMoveFirstSon( pfucb, pcsrParent );
				}
			else
				{
				pcsrParent->IncrementILine();
				NDGet( pfucb, pcsrParent );
				}

			Assert( sizeof( PGNO ) == pfucb->kdfCurr.data.Cb() );
			Assert( psplit->pgnoNew == *( (UnalignedLittleEndian< PGNO > *)pfucb->kdfCurr.data.Pv() ) );

			//	key at this node should be > last node in pgnoNew
			//
			kdfGreater = pfucb->kdfCurr;

			NDMoveLastSon( pfucb, pcsrNew );
			if ( pcsrNew->Cpage().FLeafPage() )
				{
				if ( !FFUCBUnique( pfucb ) )
					{
					Assert( kdfGreater.key.FNull() ||				
							CmpKeyWithKeyData( kdfGreater.key, pfucb->kdfCurr ) > 0 );
					}
				else
					{
					Assert( kdfGreater.key.FNull() ||
							CmpKey( kdfGreater.key, pfucb->kdfCurr.key ) > 0 );
					}
				}
			else
				{
				//	no suffix compression at internal levels
				//
				Assert( FKeysEqual( kdfGreater.key, pfucb->kdfCurr.key ) );
				}

			//	key at this node should be < first node in right page, if any
			//
			if ( pcsrRight->Pgno() != pgnoNull )
				{
				Assert( pcsrRight->Cpage().FLeafPage() );

				kdfLess = kdfGreater;
				NDMoveFirstSon( pfucb, pcsrRight );

				Assert( !kdfLess.key.FNull() );
				Assert( CmpKeyWithKeyData( kdfLess.key, pfucb->kdfCurr ) <= 0 );
				}
		}
#endif	//	DEBUG
	}


//	creates a new MERGEPATH structure and initializes it
//	adds newly created mergePath structure to head of list
//	pointed to by *ppMergePath passed in
//
ERR	ErrBTINewMergePath( MERGEPATH **ppmergePath )
	{
	MERGEPATH	*pmergePath;

	pmergePath = static_cast<MERGEPATH *>( PvOSMemoryHeapAlloc( sizeof(MERGEPATH) ) );
	if ( NULL == pmergePath )
		{
		return ErrERRCheck( JET_errOutOfMemory );
		}
	memset( (BYTE *) pmergePath, 0, sizeof( MERGEPATH ) );

	pmergePath->pmergePathParent = *ppmergePath;
	new( &pmergePath->csr ) CSR;

	pmergePath->dbtimeBefore = dbtimeInvalid;
	
	if ( pmergePath->pmergePathParent != NULL )
		{
		Assert( NULL == pmergePath->pmergePathParent->pmergePathChild );
		pmergePath->pmergePathParent->pmergePathChild = pmergePath;
		}

	*ppmergePath = pmergePath;
	return JET_errSuccess;
	}

	
//	releases mergePath at this level
//	also releases any latches held at this level
//		sets pointers at parent and child mergePath's to NULL
//
VOID BTIReleaseOneMergePath( MERGEPATH *pmergePath )
	{
	if ( pmergePath->pmerge != NULL )
		{
		BTIReleaseMerge( pmergePath->pmerge );
		pmergePath->pmerge = NULL;
		}

	if ( pmergePath->csr.FLatched() )
		{
		Assert( pmergePath->csr.Pgno() != pgnoNull );
		pmergePath->csr.ReleasePage();
		}
	pmergePath->csr.Reset();

	if ( NULL != pmergePath->pmergePathParent )
		{
		pmergePath->pmergePathParent->pmergePathChild = NULL;
		}
		
	if ( NULL != pmergePath->pmergePathChild )
		{
		pmergePath->pmergePathChild->pmergePathParent = NULL;
		}

	OSMemoryHeapFree( pmergePath );
	}


//	seeks to node for single page cleanup
//	returns error if node is not found
//
INLINE ERR ErrBTISPCSeek( FUCB *pfucb, const BOOKMARK& bm )
	{
	ERR		err;
	
	//	no page should be latched
	//
	Assert( !Pcsr( pfucb )->FLatched( ) );

	//	go to root
	//
	Call( ErrBTIGotoRoot( pfucb, latchReadNoTouch ) );
	Assert( 0 == Pcsr( pfucb )->ILine() );

	if ( Pcsr( pfucb )->Cpage().Clines() == 0 )
		{
		//	page is empty
		//
		Assert( Pcsr( pfucb )->Cpage().FLeafPage() );
		err = wrnNDFoundGreater;
		}
	else
		{
		//	seek down tree for bm
		//
		for ( ; ; )
			{
			Call( ErrNDSeek( pfucb, bm ) );

			if ( !Pcsr( pfucb )->Cpage().FInvisibleSons( ) )
				{
				//	leaf node reached, exit loop
				//
				break;
				}
			else
				{
				//	get pgno of child from node
				//	switch to that page
				//
				Assert( pfucb->kdfCurr.data.Cb() == sizeof( PGNO ) );
				Call( Pcsr( pfucb )->ErrSwitchPage( 
							pfucb->ppib,
							pfucb->ifmp,
							*(UnalignedLittleEndian< PGNO > *) pfucb->kdfCurr.data.Pv(),
							pfucb->u.pfcb->Tableclass(),
							pfucb->u.pfcb->FNoCache() ) );
				Assert( Pcsr( pfucb )->Cpage().Clines() > 0 );
				}
			}
		}

	if ( wrnNDFoundGreater == err ||
		 wrnNDFoundLess == err )
		{
		Call( ErrERRCheck( JET_errNoCurrentRecord ) );
		}
	else if ( !FNDDeleted( pfucb->kdfCurr ) )
		{
		Call( ErrERRCheck( JET_errRecordNotDeleted ) );
		}

HandleError:
	if ( err < 0 )
		{
		BTUp( pfucb );
		}
		
	return err;
	}


//	deletes all nodes in page that are flagged-deleted 
//		and have no active version
//	also nullifies versions on deleted nodes
//
LOCAL ERR ErrBTISPCDeleteNodes( FUCB *pfucb, CSR *pcsr, LINEINFO *rglineinfo )
	{
	ERR		err = JET_errSuccess;
	INT		iline;
	INT		clines = pcsr->Cpage().Clines();

	Assert( clines > 0 );
	for ( iline = clines - 1; iline >= 0 ; iline-- )
		{
		LINEINFO	*plineinfo = &rglineinfo[iline];
		
		if ( FNDDeleted( plineinfo->kdf )
			&& !plineinfo->fVerActive
			&& pcsr->Cpage().Clines() > 1 )
			{
			pcsr->SetILine( iline );

			BOOKMARK	bm;
			NDGet( pfucb, pcsr );
			NDGetBookmarkFromKDF( pfucb, pfucb->kdfCurr, &bm );

			Assert( FKeysEqual( pfucb->kdfCurr.key, plineinfo->kdf.key ) );
			Assert( FDataEqual( pfucb->kdfCurr.data, plineinfo->kdf.data ) );
			Assert( FNDDeleted( pfucb->kdfCurr ) );
			Assert( FNDDeleted( plineinfo->kdf ) );
			
			Call( ErrNDDelete( pfucb, pcsr ) );

//			WARNING: The assert below is wrong, because by this point, there may actually
//			be future active versions.  This is because versioning is now done before we
//			latch the page.
//			Assert( !FVERActive( pfucb, bm ) );
			VERNullifyInactiveVersionsOnBM( pfucb, bm );
			}
		}

HandleError:
	return err;
	}


LOCAL ERR ErrBTIMergeEmptyTree(
	FUCB		* const pfucb,
	MERGEPATH	* const pmergePathLeaf )
	{
	ERR			err					= JET_errSuccess;
	MERGEPATH	* pmergePath;
	ULONG		cPagesToFree		= 0;
	EMPTYPAGE	rgemptypage[cBTMaxDepth];
	LGPOS		lgpos;

	//	go to root
	//	since we need to latch top-down
	for ( pmergePath = pmergePathLeaf;
		  pmergePath->pmergePathParent != NULL;
		  pmergePath = pmergePath->pmergePathParent )
		{
		Assert( latchRIW == pmergePath->csr.Latch() );
		}

	MERGEPATH	* const pmergePathRoot	= pmergePath;
	CSR			* const pcsrRoot		= &pmergePathRoot->csr;

	Assert( pcsrRoot->Cpage().FRootPage() );
	Assert( !pcsrRoot->Cpage().FLeafPage() );
	Assert( 1 == pcsrRoot->Cpage().Clines() );
	pcsrRoot->UpgradeFromRIWLatch();

	//	latch and dirty all pages
	Assert( NULL != pmergePathRoot->pmergePathChild );
	for ( pmergePath = pmergePathRoot->pmergePathChild;
		NULL != pmergePath;
		pmergePath = pmergePath->pmergePathChild )
		{
		pmergePath->csr.UpgradeFromRIWLatch();

		rgemptypage[cPagesToFree].dbtimeBefore = pmergePath->csr.Dbtime();
		rgemptypage[cPagesToFree].pgno = pmergePath->csr.Pgno();
		rgemptypage[cPagesToFree].ulFlags = pmergePath->csr.Cpage().FFlags();

		cPagesToFree++;
		Assert( cPagesToFree <= cBTMaxDepth );
		}
	Assert( cPagesToFree > 0 );

	err = ErrLGEmptyTree(
				pfucb,
				pcsrRoot,
				rgemptypage,
				cPagesToFree,
				&lgpos );

	if ( JET_errSuccess <= err )
		{
		NDSetEmptyTree( pcsrRoot );

		//	update lgpos
		pcsrRoot->Cpage().SetLgposModify( lgpos );

		//	update all child pages with dbtime of root, mark them as empty, and update lgpos
		const DBTIME	dbtime		= pcsrRoot->Dbtime();
		for ( pmergePath = pmergePathRoot->pmergePathChild;
			NULL != pmergePath;
			pmergePath = pmergePath->pmergePathChild )
			{
			pmergePath->csr.CoordinatedDirty( dbtime );
			pmergePath->csr.Cpage().SetEmpty();
			pmergePath->csr.Cpage().SetLgposModify( lgpos );
			}
		}

	BTIReleaseMergePaths( pmergePathLeaf );
	CallR( err );

	//	WARNING: If we crash after this point, we will lose space

	const BOOL		fAvailExt	= FFUCBAvailExt( pfucb );
	const BOOL		fOwnExt		= FFUCBOwnExt( pfucb );

	//	fake out cursor to make it think it's not a space cursor
	if ( fAvailExt )
		{
		Assert( !fOwnExt );
		FUCBResetAvailExt( pfucb );
		}
	else if ( fOwnExt )
		{
		FUCBResetOwnExt( pfucb );
		}
	Assert( !FFUCBSpace( pfucb ) );

	//	return freed pages to AvailExt
	BTUp( pfucb );
	for ( ULONG i = 0; i < cPagesToFree; i++ )
		{
		//	UNDONE:	track lost space because of inability 
		//			to split availExt tree with the released space
		Assert( PgnoRoot( pfucb ) != rgemptypage[i].pgno );
		const ERR	errFreeExt	= ErrSPFreeExt( pfucb, rgemptypage[i].pgno, 1 );
#ifdef DEBUG
		if ( JET_errSuccess != errFreeExt
			&& !FRFSAnyFailureDetected() )
			{
			CallS( errFreeExt );
			}
#endif				
		CallR( errFreeExt );
		}

	Assert( !FFUCBSpace( pfucb ) );
	if ( fAvailExt )
		{
		FUCBSetAvailExt( pfucb );
		}
	else if ( fOwnExt )
		{
		FUCBSetOwnExt( pfucb );
		}

	return JET_errSuccess;
	}
	


//	performs multipage cleanup
//		seeks down to node 
//		performs empty page or merge operation if possible
//		else expunges all deletable nodes in page
//	

#ifdef OLD_DEPENDENCY_CHAIN_HACK
	const CPG	cpgOLDAdjacentPartialMergesThreshold	= 32;		//	number of consecutive-page merges before bailing out
#endif																	//	(to avoid building length dependency chain)

ERR ErrBTIMultipageCleanup(
	FUCB			*pfucb,
	const BOOKMARK&	bm,
	BOOKMARK		*pbmNext,
	RECCHECK		* preccheck )
	{
	ERR				err;
	MERGEPATH		*pmergePath		= NULL;

#ifdef OLD_DEPENDENCY_CHAIN_HACK
#ifdef DEBUG
	const PGNO		pgnoPrevMergeT	= PinstFromIfmp( pfucb->ifmp )->m_rgoldstatDB[ rgfmp[pfucb->ifmp].Dbid() ].PgnoPrevPartialMerge();
#endif
#endif

	//	get path RIW latched
	//
	Call( ErrBTICreateMergePath( pfucb, bm, &pmergePath ) );
	if ( wrnBTShallowTree == err )
		{
		if ( NULL != pbmNext )
			{
			pbmNext->key.suffix.SetCb( 0 );
			pbmNext->data.SetCb( 0 );
			}
		goto HandleError;
		}

	//	check if merge conditions hold
	//
	Call( ErrBTISelectMerge( pfucb, pmergePath, bm, pbmNext, preccheck ) );
	Assert( pmergePath->pmerge != NULL );
	Assert( pmergePath->pmerge->rglineinfo != NULL );

	if ( mergetypeEmptyTree == pmergePath->pmerge->mergetype )
		{
		if ( NULL != pbmNext )
			{
			pbmNext->key.suffix.SetCb( 0 );
			pbmNext->data.SetCb( 0 );
			}


		err = ErrBTIMergeEmptyTree( pfucb, pmergePath );
		return err;
		}

	//	release pages not involved in merge
	//
	BTIMergeReleaseUnneededPages( pmergePath );

	
#ifdef OLD_DEPENDENCY_CHAIN_HACK
	if ( mergetypePartialRight == pmergePath->pmerge->mergetype
		&& pfucb->ppib->FSessionOLD() )
		{
		const IFMP				ifmp			= pfucb->ifmp;
		INST * const			pinst			= PinstFromIfmp( ifmp );
		OLDDB_STATUS * const	poldstatDB		= pinst->m_rgoldstatDB + rgfmp[ifmp].Dbid();

		//	if right page already had a partial merge, increment
		//	adjacent partial merge count, and don't bother doing
		//	a partial merge on this page if we exceed the threshold
		Assert( pgnoNull != pmergePath->csr.Cpage().PgnoNext() );
		if ( poldstatDB->PgnoPrevPartialMerge() == pmergePath->csr.Cpage().PgnoNext() )
			{
			if ( poldstatDB->CpgAdjacentPartialMerges() > cpgOLDAdjacentPartialMergesThreshold )
				{
				pmergePath->pmerge->mergetype = mergetypeNone;
				poldstatDB->ResetCpgAdjacentPartialMerges();
				}
			else
				{
				poldstatDB->IncCpgAdjacentPartialMerges();
				}
			}
		else
			{
			poldstatDB->ResetCpgAdjacentPartialMerges();
			}

		poldstatDB->SetPgnoPrevPartialMerge( pmergePath->csr.Pgno() );
		}
#endif	//	OLD_DEPENDENCY_CHAIN_HACK

	switch( pmergePath->pmerge->mergetype )
		{
		case mergetypeEmptyPage:
			Call( ErrBTIMergeOrEmptyPage( pfucb, pmergePath ) );
			break;

		//	UNDONE:	disable partial merges from RCE cleanup
		//
		case mergetypePartialRight:
		case mergetypeFullRight:
			//	sibling pages, if any, should be RIW latched
			//
			Assert( pgnoNull != pmergePath->csr.Cpage().PgnoNext() );
			Assert( latchRIW == pmergePath->pmerge->csrRight.Latch() );

			Assert( pgnoNull == pmergePath->csr.Cpage().PgnoPrev()
				|| latchRIW == pmergePath->pmerge->csrLeft.Latch() );

			//	log merge, merge pages, release empty page
			//
			Call( ErrBTIMergeOrEmptyPage( pfucb, pmergePath ) );
			break;

		default:
			Assert( pmergePath->pmerge->mergetype == mergetypeNone );
			Assert( latchRIW == pmergePath->csr.Latch() );

			//	can not delete only node in page
			//
			if ( pmergePath->csr.Cpage().Clines() == 1 )
				{
				goto HandleError;
				}

			//	upgrade to write latch on leaf page
			//
			pmergePath->csr.UpgradeFromRIWLatch();

			//	delete all other flag-deleted nodes with no active version
			//
			Call( ErrBTISPCDeleteNodes( pfucb, &pmergePath->csr, pmergePath->pmerge->rglineinfo ) );
			Assert( pmergePath->csr.Cpage().Clines() > 0 );
			break;
		}
		
HandleError:
	BTIReleaseMergePaths( pmergePath );
	return err;
	}

	
//	performs cleanup deleting bookmarked node from tree
//	seeks for node using single page read latches
//	if page is empty/mergeable
//		return NeedsMultipageOLC
//	else
//		expunge all flag deleted nodes without active version from page
//
LOCAL ERR ErrBTISinglePageCleanup( FUCB *pfucb, const BOOKMARK& bm )
	{
	Assert( !Pcsr( pfucb )->FLatched() );
	
	ERR			err;

	CallR( ErrBTISPCSeek( pfucb, bm ) );

	LINEINFO	*rglineinfo = NULL;
	BOOL		fEmptyPage;
	BOOL		fLessThanOneThirdFull;

	//	collect page info for nodes
	//
	Call( ErrBTISPCCollectLeafPageInfo(
				pfucb,
				Pcsr( pfucb ),
				&rglineinfo,
				NULL,
				&fEmptyPage,
				NULL,
				&fLessThanOneThirdFull ) );

	//	do not call multi-page cleanup if online backup is occurring
	if ( !PinstFromPfucb( pfucb )->m_plog->m_fBackupInProgress )
		{
		//	if page is empty
		//		needs MultipageOLC 
		//
		if ( fEmptyPage )
			{
			err = ErrERRCheck( wrnBTMultipageOLC );
			goto HandleError;
			}

		if ( fLessThanOneThirdFull && pgnoNull != Pcsr( pfucb )->Cpage().PgnoNext() )
			{
			const PGNO	pgnoRight = Pcsr( pfucb )->Cpage().PgnoNext();
			CSR			csrRight;
			BOOL		fMergeable;

			//	latch right page
			//
			Call( csrRight.ErrGetReadPage( pfucb->ppib, pfucb->ifmp, pgnoRight, bflfNoTouch ) );

			//	check is page is mergeable with right page
			//
			fMergeable = FBTISPCCheckMergeable( pfucb, &csrRight, rglineinfo );
			if ( !fMergeable )
				{
				PERFIncCounterTable( cBTUnnecessarySiblingLatch, PinstFromPfucb( pfucb ), pfucb->u.pfcb->Tableclass() );
				}

			//	release right page
			//
			csrRight.ReleasePage();
			if ( fMergeable )
				{
				//	if page is mergeable
				//		needs MultipageOLC
				//
				err = ErrERRCheck( wrnBTMultipageOLC );
				goto HandleError;
				}
			}
		}

	//	upgrade page to write latch
	//	if upgrade fails, return NeedsMultipageOLC
	//
	err = Pcsr( pfucb )->ErrUpgradeFromReadLatch( );
	if ( errBFLatchConflict == err )
		{
		cBTFailedWriteLatchForSPC.Inc( PinstFromPfucb( pfucb ) );
		err = ErrERRCheck( wrnBTMultipageOLC );
		goto HandleError;
		}
	Call( err );

	//	delete all flag-deleted nodes in page 
	//		that have no active versions
	//
	Assert( latchWrite == Pcsr( pfucb )->Latch() );
	Call( ErrBTISPCDeleteNodes( pfucb, Pcsr( pfucb ), rglineinfo ) );
		
HandleError:
	if ( rglineinfo != NULL )
		{
		delete [] rglineinfo;
		}
		
	BTUp( pfucb );
	return err;
	}


//	creates mergePath of RIW latched pages from root of tree
//	to seeked bookmark
//
LOCAL ERR ErrBTICreateMergePath( FUCB	 			*pfucb, 
								 const BOOKMARK& 	bm,
								 MERGEPATH 			**ppmergePath )
	{
	ERR		err;
	
	//	create mergePath structure
	//
	CallR( ErrBTINewMergePath( ppmergePath ) );
	Assert( NULL != *ppmergePath );

	//	RIW latch root
	//
	Call( (*ppmergePath)->csr.ErrGetRIWPage( pfucb->ppib,
											 pfucb->ifmp,
											 PgnoRoot( pfucb ),
											 pfucb->u.pfcb->Tableclass() ) );

	if ( (*ppmergePath)->csr.Cpage().FLeafPage() )
		{
		//	tree is too shallow to bother doing merges on
		//
		err = ErrERRCheck( wrnBTShallowTree );
		}
	else
		{
		BOOL	fLeftEdgeOfBtree	= fTrue;
		BOOL	fRightEdgeOfBtree	= fTrue;

		Assert( (*ppmergePath)->csr.Cpage().Clines() > 0 );

		for ( ; ; )
			{
			Call( ErrNDSeek( pfucb, 
							 &(*ppmergePath)->csr,
							 bm ) );

			//	save iLine for later use 
			//
			(*ppmergePath)->iLine = SHORT( (*ppmergePath)->csr.ILine() );
			Assert( (*ppmergePath)->iLine < (*ppmergePath)->csr.Cpage().Clines() );

			if ( (*ppmergePath)->csr.Cpage().FLeafPage() )
				{
				const MERGEPATH * const	pmergePathParent		= (*ppmergePath)->pmergePathParent;
				const BOOL				fLeafPageIsFirstPage	= ( pgnoNull == (*ppmergePath)->csr.Cpage().PgnoPrev() );
				const BOOL				fLeafPageIsLastPage		= ( pgnoNull == (*ppmergePath)->csr.Cpage().PgnoNext() );

				//	if root page was also a leaf page, we would have
				//	err'd out above with wrnBTShallowTree
				Assert( NULL != pmergePathParent );
				Assert( !( (*ppmergePath)->csr.Cpage().FRootPage() ) );

				if ( fLeftEdgeOfBtree ^ fLeafPageIsFirstPage )					
					{
					//	if not repair, assert, otherwise, suppress the assert
					//	and repair will just naturally err out
					AssertSz( fGlobalRepair, "Corrupt B-tree: first leaf page has mismatched parent" );
					Call( ErrBTIReportBadPageLink(
								pfucb,
								ErrERRCheck( JET_errBadParentPageLink ),
								pmergePathParent->csr.Pgno(),
								(*ppmergePath)->csr.Pgno(),
								(*ppmergePath)->csr.Cpage().PgnoPrev() ) );
					}
				if ( fRightEdgeOfBtree ^ fLeafPageIsLastPage )
					{
					//	if not repair, assert, otherwise, suppress the assert
					//	and repair will just naturally err out
					AssertSz( fGlobalRepair, "Corrupt B-tree: last leaf page has mismatched parent" );
					Call( ErrBTIReportBadPageLink(
								pfucb,
								ErrERRCheck( JET_errBadParentPageLink ),
								pmergePathParent->csr.Pgno(),
								(*ppmergePath)->csr.Pgno(),
								(*ppmergePath)->csr.Cpage().PgnoNext() ) );
					}

				break;
				}

			Assert( (*ppmergePath)->csr.Cpage().FInvisibleSons() );
			Assert( !( fRightEdgeOfBtree ^ (*ppmergePath)->csr.Cpage().FLastNodeHasNullKey() ) );

			fRightEdgeOfBtree = ( fRightEdgeOfBtree
								&& (*ppmergePath)->iLine == (*ppmergePath)->csr.Cpage().Clines() - 1 );
			fLeftEdgeOfBtree = ( fLeftEdgeOfBtree
								&& 0 == (*ppmergePath)->iLine );

			//	allocate another mergePath structure for next level
			//
			Call( ErrBTINewMergePath( ppmergePath ) );

			//	access child page
			//
			Assert( sizeof( PGNO ) == pfucb->kdfCurr.data.Cb() );
			Call( (*ppmergePath)->csr.ErrGetRIWPage( 
									pfucb->ppib,
									pfucb->ifmp,
									*(UnalignedLittleEndian< PGNO > *) pfucb->kdfCurr.data.Pv(),
									pfucb->u.pfcb->Tableclass() ) );
			}
		}

HandleError:
	return err;
	}
	

//	copies next bookmark to seek for online defrag
//	from left page
//
LOCAL VOID BTIMergeCopyNextBookmark( FUCB		*pfucb, 
									 MERGEPATH 	*pmergePathLeaf, 
									 BOOKMARK	*pbmNext )
	{
	Assert( NULL != pmergePathLeaf );
	Assert( NULL != pbmNext );
	Assert( pmergePathLeaf->csr.FLatched() );
	Assert( pmergePathLeaf->pmerge != NULL );
	
	Assert( pbmNext->key.prefix.FNull() );
	
	//	if no left sibling, nullify bookmark
	//
	if ( pmergePathLeaf->pmerge->csrLeft.Pgno() == pgnoNull )
		{
		Assert( pmergePathLeaf->csr.Cpage().PgnoPrev() == pgnoNull );
		pbmNext->key.suffix.SetCb( 0 );
		pbmNext->data.SetCb( 0 );
		return;
		}

	Assert( mergetypeEmptyTree != pmergePathLeaf->pmerge->mergetype );

	CSR			*pcsrLeft = &pmergePathLeaf->pmerge->csrLeft;
	BOOKMARK	bm;
	
	Assert( pcsrLeft->FLatched() );
	Assert( pcsrLeft->Cpage().Clines() > 0 );

	//	get bm of first node from page
	//
	pcsrLeft->SetILine( 0 );
	NDGet( pfucb, pcsrLeft );
	NDGetBookmarkFromKDF( pfucb, pfucb->kdfCurr, &bm );

	//	copy bm into given buffer
	//
	Assert( NULL != pbmNext->key.suffix.Pv() );
	Assert( 0 == pbmNext->key.prefix.Cb() );
	bm.key.CopyIntoBuffer( pbmNext->key.suffix.Pv(), bm.key.Cb() );
	pbmNext->key.suffix.SetCb( bm.key.Cb() );

	pbmNext->data.SetPv( (BYTE *) pbmNext->key.suffix.Pv() + pbmNext->key.Cb() );
	bm.data.CopyInto( pbmNext->data );

	return;
	}

	
//	select merge at leaf level and recursively at parent levels
//	pmergePath already created and RIW latched
//
LOCAL ERR ErrBTISelectMerge(
	FUCB			*pfucb, 
	MERGEPATH 		*pmergePathLeaf, 
	const BOOKMARK&	bm, 
	BOOKMARK		*pbmNext,
	RECCHECK 		* const preccheck )
	{
	ERR				err;

	Assert( pmergePathLeaf->csr.Cpage().FLeafPage() );
	
	//	allocate merge structure and initialize
	//
	CallR( ErrBTINewMerge( pmergePathLeaf ) );
	Assert( NULL != pmergePathLeaf->pmerge );

	MERGE	*pmerge = pmergePathLeaf->pmerge;
	pmerge->mergetype = mergetypeNone;
	
	//	check if page is mergeable, without latching sibling pages,
	//	also collect info on all nodes in page
	//
	CallR( ErrBTIMergeCollectPageInfo( pfucb, pmergePathLeaf, preccheck ) );

	//	if we want the next bookmark, then we have to latch the left page to
	//	obtain it, even if no merge will occur will the current page
	if ( mergetypeNone == pmerge->mergetype
		&& NULL == pbmNext )
		{
		return err;
		}
	else if ( mergetypeEmptyTree == pmerge->mergetype )
		{
		return err;
		}

	//	page could be merged
	//	acquire latches on sibling pages
	//	this might cause latch of merged page to be released
	//
	const DBTIME	dbtimeLast	= pmergePathLeaf->csr.Cpage().Dbtime();
	const VOID		*pvPageLast	= pmergePathLeaf->csr.Cpage().PvBuffer();

	Call( ErrBTIMergeLatchSiblingPages( pfucb, pmergePathLeaf ) );

	//	copy next bookmark to seek for online defrag
	//
	if ( NULL != pbmNext )
		{
		BTIMergeCopyNextBookmark( pfucb, pmergePathLeaf, pbmNext );
		}
	
	Assert( pmergePathLeaf->pmergePathParent != NULL || mergetypeNone == pmerge->mergetype );

	if ( pmergePathLeaf->csr.Cpage().Dbtime() != dbtimeLast ||
		 pmergePathLeaf->csr.Cpage().PvBuffer() != pvPageLast )
		{
		//	page was changed when we released and reacquired latch
		//	reseek to deleted node
		//	recompute if merge is possible
		//
		BTIReleaseMergeLineinfo( pmerge );

		Call( ErrNDSeek( pfucb, &pmergePathLeaf->csr, bm ) );

		pmergePathLeaf->iLine = SHORT( pmergePathLeaf->csr.ILine() );

		//  we don't want to check the same node multiple times so we don't bother with the reccheck
		Call( ErrBTIMergeCollectPageInfo( pfucb, pmergePathLeaf, NULL ) );
		}

	switch ( pmerge->mergetype )
		{
		case mergetypeEmptyPage:
			Call( ErrBTISelectMergeInternalPages( pfucb, pmergePathLeaf ) );
			break;

		case mergetypeFullRight:
		case mergetypePartialRight:

			//	check if page can be merged to next page
			//	without violating density constraint
			//
			BTICheckMergeable( pfucb, pmergePathLeaf );
			if ( mergetypeNone == pmerge->mergetype )
				{
				return err;
				}

			//	select merge at parent pages
			//
			Call( ErrBTISelectMergeInternalPages( pfucb, pmergePathLeaf ) );
		
			if ( mergetypeEmptyPage != pmerge->mergetype )
				{
				//	calcualte uncommitted freed space in right page
				//
				pmerge->cbUncFreeDest	= pmerge->csrRight.Cpage().CbUncommittedFree() +
											pmerge->cbSizeMaxTotal - 
											pmerge->cbSizeTotal;
				}
			break;

		default:
			Assert( mergetypeNone == pmerge->mergetype
				|| mergetypeEmptyTree == pmerge->mergetype );
		}

HandleError:
	return err;
	}


//	allocate a new merge structure
//		and link it to mergePath
//
ERR ErrBTINewMerge( MERGEPATH *pmergePath )
	{
	MERGE	*pmerge;
	
	Assert( pmergePath != NULL );
	Assert( pmergePath->pmerge == NULL );

	//	allocate split structure
	//
	pmerge = static_cast<MERGE *>( PvOSMemoryHeapAlloc( sizeof(MERGE) ) );
	if ( pmerge == NULL )
		{
		return ErrERRCheck( JET_errOutOfMemory );
		}
	memset( (BYTE *)pmerge, 0, sizeof(MERGE) );
	new( &pmerge->csrRight ) CSR;
	new( &pmerge->csrLeft ) CSR;

	pmerge->dbtimeLeftBefore = dbtimeInvalid;
	pmerge->dbtimeRightBefore = dbtimeInvalid;
	
	//	link merge structure to pmergePath
	//
	pmerge->pmergePath = pmergePath;
	pmergePath->pmerge = pmerge;
	
	return JET_errSuccess;
	}


INLINE VOID BTIReleaseMergeLineinfo( MERGE *pmerge )
	{
	if ( pmerge->rglineinfo != NULL )
		{
		delete [] pmerge->rglineinfo;
		pmerge->rglineinfo = NULL;
		}
	}
	

//	revert dbtime of every (write) latched page to the before dirty dbtime
//
VOID BTIMergeRevertDbtime( MERGEPATH *pmergePathLeaf )
	{
	MERGEPATH *pmergePath = pmergePathLeaf;

	Assert( NULL == pmergePath->pmergePathChild );
	for ( ; NULL != pmergePath && pmergePath->csr.Latch() == latchWrite;
			pmergePath = pmergePath->pmergePathParent )
		{
		//	set the dbtime for this page
		//
		Assert ( latchWrite == pmergePath->csr.Latch() );

		Assert ( dbtimeInvalid != pmergePath->dbtimeBefore && dbtimeNil != pmergePath->dbtimeBefore);
		Assert ( pmergePath->dbtimeBefore < pmergePath->csr.Dbtime() );
		pmergePath->csr.RevertDbtime( pmergePath->dbtimeBefore );

		MERGE	*pmerge = pmergePath->pmerge;

		//	set dbtime for sibling and new pages
		//
		if ( pmerge != NULL )
			{
			if ( pgnoNull != pmerge->csrLeft.Pgno() )
				{
				Assert( pmerge->csrLeft.Cpage().FLeafPage() );

				Assert ( dbtimeInvalid != pmerge->dbtimeLeftBefore && dbtimeNil != pmerge->dbtimeLeftBefore);
				Assert ( pmerge->dbtimeLeftBefore < pmerge->csrLeft.Dbtime() );
				pmerge->csrLeft.RevertDbtime( pmerge->dbtimeLeftBefore );
				}
			
			if ( pgnoNull != pmerge->csrRight.Pgno() )
				{
				Assert( pmerge->csrRight.Cpage().FLeafPage() );

				Assert ( dbtimeInvalid != pmerge->dbtimeRightBefore && dbtimeNil != pmerge->dbtimeRightBefore);
				Assert ( pmerge->dbtimeRightBefore < pmerge->csrRight.Dbtime() );
				pmerge->csrRight.RevertDbtime( pmerge->dbtimeRightBefore );
				}
			}
		}
	}


VOID BTIReleaseMerge( MERGE *pmerge )
	{
	if ( pmerge->fAllocParentSep )
		{
		//	space is allocated for leaf pages only
		//	for internal pages, this is not allocated space
		//
		Assert( !pmerge->kdfParentSep.key.FNull() );
		Assert( pmerge->kdfParentSep.key.prefix.FNull() );

		OSMemoryHeapFree( pmerge->kdfParentSep.key.suffix.Pv() );
		pmerge->fAllocParentSep = fFalse;
		}
		
	if ( pmerge->csrLeft.FLatched() )
		{
		pmerge->csrLeft.ReleasePage();
		}
	
	if ( pmerge->csrRight.FLatched() )
		{
		pmerge->csrRight.ReleasePage();
		}

	BTIReleaseMergeLineinfo( pmerge );
	OSMemoryHeapFree( pmerge );
	}

	
//	positions cursor fractionally
//	so that approximately ( pfrac->ulLT / pfrac->ulTotal ) * 100 % 
//	of all records are less than cursor position
//	UNDONE: understand and rewrite so it does not use clinesMax
//
LOCAL INT IlineBTIFrac( FUCB *pfucb, DIB *pdib )
	{
	INT			iLine;
	INT			clines		= Pcsr( pfucb )->Cpage().Clines( );
	FRAC		*pfrac		= (FRAC *)pdib->pbm;
	const INT	clinesMax	= 4096;

	Assert( pdib->pos == posFrac );
	Assert( pfrac->ulTotal >= pfrac->ulLT );

	//	cast to float to avoid overflow/underflow with
	//	INT operation
	//
	iLine = (INT) ( ( (float) pfrac->ulLT * clines ) / pfrac->ulTotal );
	Assert( iLine <= clines );
	if ( iLine >= clines )
		{
		iLine = clines - 1;
		}

	//	preseve fractional information by avoiding underflow
	//
	if ( pfrac->ulTotal / clines == 0 )
		{
		pfrac->ulTotal *= clinesMax;
		pfrac->ulLT *= clinesMax;
		}

	//	prepare fraction for next lower B-tree level
	//
	Assert( pfrac->ulTotal > 0 );
	pfrac->ulLT =  (INT) ( (float) pfrac->ulLT - 
						   (float) ( iLine * pfrac->ulTotal ) / clines );
	pfrac->ulTotal /= clines;
	
	Assert( pfrac->ulLT <= pfrac->ulTotal );
	return iLine;
	}


//	collects lineinfo for page
//	if all nodes in page are flag-deleted without active version
//		set fEmptyPage
//	if there exists a flag deleted node with active version
//		set fExistsFlagDeletedNodeWithActiveVersion
//
ERR ErrBTISPCCollectLeafPageInfo(
	FUCB		*pfucb, 
	CSR			*pcsr, 
	LINEINFO	**pplineinfo, 
	RECCHECK	* const preccheck,
	BOOL		*pfEmptyPage,
	BOOL		*pfExistsFlagDeletedNodeWithActiveVersion,
	BOOL		*pfLessThanOneThirdFull )
	{
	const INT 	clines									= pcsr->Cpage().Clines();
	BOOL		fExistsFlagDeletedNodeWithActiveVersion	= fFalse;
	ULONG		cbSizeMaxTotal							= 0;

	Assert( pcsr->Cpage().FLeafPage() );

	//	UNDONE:	allocate rglineinfo on demand [only if not empty page]
	//
	//	allocate rglineinfo
	//
	Assert( NULL == *pplineinfo );
	*pplineinfo = new LINEINFO[clines];
								 
	if ( NULL == *pplineinfo )
		{
		return ErrERRCheck( JET_errOutOfMemory );
		}

	LINEINFO	*rglineinfo = *pplineinfo;

	Assert( NULL != pfEmptyPage );
	*pfEmptyPage = fTrue;

	//	collect total size of movable nodes in page
	//		i.e, nodes that are not flag-deleted
	//			 or flag-deleted with active versions
	//
	for ( INT iline = 0; iline < clines; iline++ )
		{
		pcsr->SetILine( iline );
		NDGet( pfucb, pcsr );

		rglineinfo[iline].kdf 		= pfucb->kdfCurr;
		rglineinfo[iline].cbSize	= CbNDNodeSizeTotal( pfucb->kdfCurr );
		rglineinfo[iline].cbSizeMax	= CbBTIMaxSizeOfNode( pfucb, pcsr );

		if ( !FNDDeleted( pfucb->kdfCurr ) )
			{
			if( NULL != preccheck )
				{
				(*preccheck)( pfucb->kdfCurr );
				}
			
			cbSizeMaxTotal += rglineinfo[iline].cbSizeMax;
			*pfEmptyPage = fFalse;
			continue;
			}

		rglineinfo[iline].fVerActive = fFalse;

		Assert( FNDDeleted( pfucb->kdfCurr ) );
		if ( FNDPossiblyVersioned( pfucb, pcsr ) )
			{
			BOOKMARK	bm;
			NDGetBookmarkFromKDF( pfucb, pfucb->kdfCurr, &bm );

			if ( FVERActive( pfucb, bm ) )
				{
				//	version is still active
				//
				cbSizeMaxTotal += rglineinfo[iline].cbSizeMax;
				rglineinfo[iline].fVerActive = fTrue;
				*pfEmptyPage = fFalse;
				fExistsFlagDeletedNodeWithActiveVersion = fTrue;
				}
			}
		}

	if ( NULL != pfExistsFlagDeletedNodeWithActiveVersion )
		{
		*pfExistsFlagDeletedNodeWithActiveVersion = fExistsFlagDeletedNodeWithActiveVersion;
		}
	if ( NULL != pfLessThanOneThirdFull )
		{
		const ULONG		cbDensityFree	= CbBTIFreeDensity( pfucb );
		Assert( cbDensityFree < cbNDPageAvailMostNoInsert );
		*pfLessThanOneThirdFull = ( cbSizeMaxTotal < ( ( cbNDPageAvailMostNoInsert - cbDensityFree ) / 3 ) );
		}
		
	return JET_errSuccess;
	}


//	collects merge info for page
//	if page has flag-deleted node with an active version
//		return pmerge->mergetype = mergetypeNone
//
ERR ErrBTIMergeCollectPageInfo( FUCB *pfucb, MERGEPATH *pmergePath, RECCHECK * const preccheck )
	{
	ERR			err;
	const INT 	clines = pmergePath->csr.Cpage().Clines();
	MERGE		*pmerge = pmergePath->pmerge;

	Assert( pmerge != NULL );
	Assert( pmergePath->csr.Cpage().FLeafPage() );

	BOOL	fEmptyPage;
	BOOL	fExistsFlagDeletedNodeWithActiveVersion;
	
	pmerge->clines = clines;
	Assert( NULL == pmerge->rglineinfo );

	Assert( 0 == pmerge->cbSavings );
	Assert( 0 == pmerge->cbSizeTotal );
	Assert( 0 == pmerge->cbSizeMaxTotal );
	
	CallR( ErrBTISPCCollectLeafPageInfo(
			pfucb, 
			&pmergePath->csr, 
			&pmerge->rglineinfo, 
			preccheck,
			&fEmptyPage,
			&fExistsFlagDeletedNodeWithActiveVersion,
			NULL ) );
	Assert( NULL != pmerge->rglineinfo );

	Assert( pmergePath->pmergePathParent != NULL || 
			PgnoRoot( pfucb ) == pmergePath->csr.Pgno() && 
			pmergePath->csr.Cpage().FRootPage() );
	
	//	no merge/empty page possible if single-page tree
	//	also eliminate the case where right sibling does not exist  
	//	and left sibling does not have the same parent
	//	since we can't fix page pointer to left sibling to be NULL-keyed
	//		[left sibling page's parent is not latched]
	//
	if ( pmergePath->pmergePathParent == NULL ||
		 ( pmergePath->csr.Cpage().PgnoPrev() != pgnoNull && 
		   pmergePath->csr.Cpage().PgnoNext() == pgnoNull &&
		   pmergePath->pmergePathParent->csr.Cpage().Clines() == 1 ) )
		{
		pmerge->mergetype = mergetypeNone;
		}
	else if ( fEmptyPage )
		{
		pmerge->mergetype	= ( pmergePath->csr.Cpage().PgnoPrev() == pgnoNull
								&& pmergePath->csr.Cpage().PgnoNext() == pgnoNull ?
									mergetypeEmptyTree :
									mergetypeEmptyPage );
		}
	else if ( fExistsFlagDeletedNodeWithActiveVersion )
		{
		//	next cleanup with clean this page
		//
		pmerge->mergetype	= mergetypeNone;
		}
	else
		{
		pmerge->mergetype	= mergetypeFullRight;
		}
		
	return err;
	}


//	latches sibling pages
//	release current page
//	RIW latch left, current and right pages in order
//
ERR ErrBTIMergeLatchSiblingPages( FUCB *pfucb, MERGEPATH * const pmergePathLeaf )
	{
	ERR				err				= JET_errSuccess;
	CSR * const		pcsr			= &pmergePathLeaf->csr;
	MERGE * const	pmerge			= pmergePathLeaf->pmerge;
	const PGNO		pgnoCurr		= pcsr->Pgno();
	ULONG			cLatchFailures	= 0;

	Assert( NULL != pmerge );

Start:
	Assert( latchRIW == pcsr->Latch() );

	const DBTIME	dbtimeCurr		= pcsr->Dbtime();
	const PGNO		pgnoLeft		= pcsr->Cpage().PgnoPrev();
	PGNO			pgnoRight;

	if ( pgnoLeft != pgnoNull )
		{
		pcsr->ReleasePage();

		Assert( mergetypeEmptyTree != pmerge->mergetype );
		Call( pmerge->csrLeft.ErrGetRIWPage( pfucb->ppib, 
											 pfucb->ifmp, 
											 pgnoLeft,
											 pfucb->u.pfcb->Tableclass() ) );

		if ( pmerge->csrLeft.Cpage().PgnoNext() != pgnoCurr )
			{
			const PGNO	pgnoBadLink		= pmerge->csrLeft.Cpage().PgnoNext();

			//	left page has split after we released current page
			//	release left page
			//	relatch current page and retry
			//	
			pmerge->csrLeft.ReleasePage();

			Call( pcsr->ErrGetRIWPage( pfucb->ppib,
									   pfucb->ifmp,
									   pgnoCurr,
									   pfucb->u.pfcb->Tableclass() ) );

			Assert( pcsr->Dbtime() >= dbtimeCurr );
			if ( pcsr->Dbtime() == dbtimeCurr )
				{
				//	dbtime didn't change, but pgnoNext of the left page doesn't
				//	match pgnoPrev of the current page - must be bad page link, so
				//	if not repair, assert, otherwise, suppress the assert and
				//	repair will just naturally err out
				AssertSz( fGlobalRepair, "Corrupt B-tree: bad leaf page links detected on Merge (left sibling)" );
				Call( ErrBTIReportBadPageLink(
							pfucb,
							ErrERRCheck( JET_errBadPageLink ),
							pgnoCurr,
							pgnoLeft,
							pgnoBadLink ) );
				}
			else if ( cLatchFailures < 10
				&& !pcsr->Cpage().FEmptyPage() )	//	someone else could have cleaned the page when we gave it up to latch the sibling
				{
				cLatchFailures++;
				goto Start;
				}
			else
				{
				err = ErrERRCheck( errBTMergeNotSynchronous );
				goto HandleError;
				}
			}

		//	relatch current page
		//
		Call( pcsr->ErrGetRIWPage( pfucb->ppib, 
								   pfucb->ifmp, 
								   pgnoCurr,
								   pfucb->u.pfcb->Tableclass() ) );
		}
	else
		{
		//	set pgnoLeft to pgnoNull
		//
		pmerge->csrLeft.Reset();
		}


	Assert( latchRIW == pcsr->Latch() );
	pgnoRight = pcsr->Cpage().PgnoNext();

	Assert( pmerge->csrRight.Pgno() == pgnoNull );
	if ( pgnoRight != pgnoNull )
		{
		Assert( mergetypeEmptyTree != pmerge->mergetype );
		Call( pmerge->csrRight.ErrGetRIWPage( pfucb->ppib,
											  pfucb->ifmp,
											  pgnoRight,
											  pfucb->u.pfcb->Tableclass() ) );
		if ( pmerge->csrRight.Cpage().PgnoPrev() != pgnoCurr )
			{
			//	if not repair, assert, otherwise, suppress the assert and
			//	repair will just naturally err out
			AssertSz( fGlobalRepair, "Corrupt B-tree: bad leaf page links detected on Merge (right sibling)" );
			Call( ErrBTIReportBadPageLink(
					pfucb,
					ErrERRCheck( JET_errBadPageLink ),
					pgnoCurr,
					pmerge->csrRight.Pgno(),
					pmerge->csrRight.Cpage().PgnoPrev() ) );
			}
		}

	Assert( pgnoRight == pcsr->Cpage().PgnoNext() );
	Assert( pgnoLeft == pcsr->Cpage().PgnoPrev() );
	Assert( pcsr->Cpage().FLeafPage() );
	Assert( pgnoLeft == pgnoNull || pmerge->csrLeft.Cpage().FLeafPage() );
	Assert( pgnoRight == pgnoNull || pmerge->csrRight.Cpage().FLeafPage() );
	
HandleError:
	return err;
	}

	
//	calculates how many nodes in merged page fit in the right/root page
//		without violating density constraint
//
VOID BTICheckMergeable( FUCB *pfucb, MERGEPATH *pmergePath )
	{
	CSR		*pcsr;
	MERGE	*pmerge = pmergePath->pmerge;

	Assert( pmerge != NULL );
	Assert( pmerge->mergetype == mergetypeFullRight );
	
	if ( pmergePath->csr.Cpage().PgnoNext() == pgnoNull )
		{
		//	no right sibling -- can not merge
		//
		Assert( latchNone == pmerge->csrRight.Latch() );
		pmerge->mergetype = mergetypeNone;
		return;
		}
		
	Assert( mergetypeFullRight == pmerge->mergetype );
	Assert( pmerge->csrRight.FLatched() );
	pcsr = &pmerge->csrRight;

	//	calculate total size, total max size and prefixes of nodes to move
	//
	Assert( NULL != pmerge->rglineinfo );
	Assert( mergetypeFullRight == pmerge->mergetype );
	Assert( 0 == pmerge->cbSizeTotal );
	Assert( 0 == pmerge->cbSizeMaxTotal );

	const ULONG	cbDensityFree	= ( pcsr->Cpage().FLeafPage() ? CbBTIFreeDensity( pfucb ) : 0 );
	INT			iline;

	NDGetPrefix( pfucb, pcsr );

	for ( iline = pmerge->clines - 1; iline >= 0 ; pmerge->ilineMerge = iline, iline-- )
		{
		LINEINFO	*plineinfo = &pmerge->rglineinfo[iline];
		
		if ( FNDDeleted( plineinfo->kdf ) && !plineinfo->fVerActive )
			{
			//	this node will not be moved
			//
			continue;
			}

		//	calculate cbPrefix for node
		//
		const INT	cbCommon = CbCommonKey( pfucb->kdfCurr.key, 
											plineinfo->kdf.key );
		INT			cbSavings = pmerge->cbSavings;
		
		if ( cbCommon > cbPrefixOverhead )
			{
			plineinfo->cbPrefix = cbCommon;
			cbSavings += cbCommon - cbPrefixOverhead;
			}
		else
			{
			plineinfo->cbPrefix = 0;
			}

		//	moving nodes should not violate density constraint [assuming no rollbacks]
		//	and moving nodes should still allow rollbacks to succeed
		//
		Assert( pcsr->Pgno() != pgnoNull );
		const INT	cbSizeTotal		= pmerge->cbSizeTotal  + plineinfo->cbSize;
		const INT	cbSizeMaxTotal 	= pmerge->cbSizeMaxTotal + plineinfo->cbSizeMax;
		const INT	cbReq 			= ( cbSizeMaxTotal - cbSavings ) + cbDensityFree;

		//	UNDONE:	this may be expensive if we do not want a partial merge
		//			move this check to later [on all nodes in page]
		//
		Assert( cbReq >= 0 );
		if ( !FNDFreePageSpace( pfucb, pcsr, cbReq ) )
			{
			//	if no nodes are moved, there is no merge
			//
			if ( iline == pmerge->clines - 1 )
				{
				pmerge->mergetype = mergetypeNone;
				}
			else
				{
				Assert( iline + 1 == pmerge->ilineMerge );
				Assert( pmerge->ilineMerge < pmerge->clines );
				Assert( 0 < pmerge->ilineMerge );
				
				pmerge->mergetype 	= mergetypePartialRight;
				}
				
			break;
			}
			
		//	update merge to include node
		//
		pmerge->cbSavings		= cbSavings;
		pmerge->cbSizeTotal 	= cbSizeTotal;
		pmerge->cbSizeMaxTotal 	= cbSizeMaxTotal;
		}
		
	return;
	}

	
//	check if remaining nodes in merged page fit in the right/root page
//		without violating density constraint
//
BOOL FBTISPCCheckMergeable( FUCB *pfucb, CSR *pcsrRight, LINEINFO *rglineinfo )
	{
	const INT	clines = Pcsr( pfucb )->Cpage().Clines();
	
	Assert( Pcsr( pfucb )->FLatched() );
	Assert( pcsrRight->FLatched() );
	Assert( Pcsr( pfucb )->Cpage().PgnoNext() == pcsrRight->Pgno() );
	Assert( pcsrRight->Cpage().PgnoPrev() == Pcsr( pfucb )->Pgno() );
	Assert( pcsrRight->Cpage().FLeafPage() );
	Assert( Pcsr( pfucb )->Cpage().FLeafPage() ); 

	//	calculate total size, total max size and prefixes of nodes to move
	//
	INT		cbSizeTotal = 0;
	INT		cbSizeMaxTotal = 0;
	INT		cbSavings = 0;
	INT		iline;

	NDGetPrefix( pfucb, pcsrRight );

	for ( iline = 0; iline < clines; iline++ )
		{
		LINEINFO	*plineinfo = &rglineinfo[iline];
		
		if ( FNDDeleted( plineinfo->kdf ) && !plineinfo->fVerActive )
			{
			//	this node will not be moved
			//
			continue;
			}

		//	calculate cbPrefix for node
		//
		INT		cbCommon = CbCommonKey( pfucb->kdfCurr.key, 
										plineinfo->kdf.key );
		if ( cbCommon > cbPrefixOverhead )
			{
			plineinfo->cbPrefix = cbCommon;
			cbSavings += cbCommon - cbPrefixOverhead;
			}
		else
			{
			plineinfo->cbPrefix = 0;
			}

		//	add cbSize and cbSizeMax
		//
		cbSizeTotal 	+= plineinfo->cbSize;
		cbSizeMaxTotal 	+= plineinfo->cbSizeMax;
		}
	
	//	moving nodes should not violate density constraint [assuming no rollbacks]
	//	and moving nodes should still allow rollbacks to succeed
	//
	Assert( pcsrRight->Pgno() != pgnoNull );
	const INT		cbReq		= ( cbSizeMaxTotal - cbSavings )
									+ ( Pcsr( pfucb )->Cpage().FLeafPage() ? CbBTIFreeDensity( pfucb ) : 0 );
	const BOOL		fMergeable	= FNDFreePageSpace( pfucb, pcsrRight, cbReq );
	
	return fMergeable;
	}

//	check if last node in internal page is null-keyed
//
INLINE BOOL FBTINullKeyedLastNode( FUCB *pfucb, MERGEPATH *pmergePath )
	{
	CSR 	*pcsr = &pmergePath->csr;

	Assert( !pcsr->Cpage().FLeafPage() );

	pcsr->SetILine( pmergePath->iLine );
	NDGet( pfucb, pcsr );
	Assert( sizeof( PGNO ) == pfucb->kdfCurr.data.Cb() );

	//	cannot be null if not last node
	Assert( pcsr->Cpage().Clines() - 1 == pmergePath->iLine
		|| !pfucb->kdfCurr.key.FNull() );
	
	return pfucb->kdfCurr.key.FNull();
	}


//	checks if internal pages are emptied because of page merge/deletion
//	also checks if internal page must and can adjust page-pointer key
//
ERR ErrBTISelectMergeInternalPages( FUCB *pfucb, MERGEPATH * const pmergePathLeaf )
	{
	ERR			err;
	MERGEPATH	*pmergePath			= pmergePathLeaf->pmergePathParent;
	MERGE		* const pmergeLeaf	= pmergePathLeaf->pmerge;
	const BOOL	fLeftSibling		= pgnoNull != pmergeLeaf->csrLeft.Pgno();
	const BOOL	fRightSibling		= pgnoNull != pmergeLeaf->csrRight.Pgno();
	BOOL		fKeyChange			= fFalse;
	
	//	check input
	//
	Assert( mergetypeNone != pmergeLeaf->mergetype );
	Assert( pmergePath != NULL );
	Assert( !pmergePath->csr.Cpage().FLeafPage() );
	Assert( fRightSibling || 
			pmergePath->csr.Cpage().Clines() - 1 == pmergePath->csr.ILine() );
	Assert( fLeftSibling || 
			0 == pmergePath->csr.ILine() );
	Assert( fRightSibling || 
			!fLeftSibling ||
			pmergePath->csr.ILine() > 0 );
	
	//	set flag to empty leaf page
	//
	Assert( !pmergePathLeaf->fEmptyPage );
	if ( mergetypePartialRight != pmergeLeaf->mergetype )
		{
		pmergePathLeaf->fEmptyPage = fTrue;
		}
		
	for ( ; pmergePath != NULL; pmergePath = pmergePath->pmergePathParent )
		{
		Assert( pmergePath->pmerge == NULL );
		Assert( !pmergePath->csr.Cpage().FLeafPage() );
		Assert( !pmergePath->fKeyChange );
		Assert( !pmergePath->fEmptyPage );
		Assert( !pmergePath->fDeleteNode );
		Assert( pmergePath->iLine == pmergePath->csr.ILine() );

		if ( mergetypePartialRight == pmergeLeaf->mergetype )
			{
			MERGEPATH	*pmergePathChild = pmergePath->pmergePathChild;

			Assert( NULL != pmergePathChild );
			
			//	if parent of leaf 
			//	  or last node in child is changing key
			//		change key at level
			//	else break
			if ( NULL == pmergePathChild->pmergePathChild ||
				 pmergePathChild->csr.Cpage().Clines() - 1 == pmergePathChild->iLine )
				{
				if ( NULL == pmergePathChild->pmergePathChild )
					{
					const INT		ilineMerge 	= pmergeLeaf->ilineMerge;
					KEYDATAFLAGS 	*pkdfMerge 	= &pmergeLeaf->rglineinfo[ilineMerge].kdf;
					KEYDATAFLAGS 	*pkdfPrev 	= &pmergeLeaf->rglineinfo[ilineMerge - 1].kdf;
					
					//	allocate key separator
					//
					Assert( ilineMerge > 0 );
					Assert( !pmergeLeaf->fAllocParentSep );
					CallR( ErrBTIComputeSeparatorKey( pfucb, 
													  *pkdfPrev, 
													  *pkdfMerge, 
													  &pmergeLeaf->kdfParentSep.key ) );

					pmergeLeaf->kdfParentSep.data.SetCb( sizeof( PGNO ) );
					pmergeLeaf->fAllocParentSep = fTrue;
					}
				else
					{
///					Assert( fFalse );
					}
					
				Assert( pmergeLeaf->fAllocParentSep );
				
				if ( FBTIOverflowOnReplacingKey( pfucb, pmergePath, pmergeLeaf->kdfParentSep ) )
					{
					goto Overflow;
					}

				pmergePath->fKeyChange = fTrue;
				continue;
				}

			break;
			}
			
		if ( pmergePath->csr.Cpage().Clines() == 1 )
			{
			//	only node in page
			//	whole page will be deleted
			//
			Assert( pmergePath->csr.ILine() == 0 );

			if ( pmergePath->csr.Cpage().FRootPage() )
				{
				//	UNDONE:	fix this by deleting page pointer in root,
				//			releasing all pages except root and 
				//			setting root to be a leaf page
				//
				//	we can't free root page -- so punt empty page operation
				//
				Assert( fFalse );	//	should now be handled by mergetypeEmptyTree/
				Assert( mergetypeEmptyPage == pmergeLeaf->mergetype );

				goto Overflow;
				}
				
			//	can only delete this page if child page is deleted as well
			if ( pmergePath->pmergePathChild->fEmptyPage )
				{
				Assert( pmergePath->pmergePathChild->csr.Cpage().FLeafPage()
						|| ( 0 == pmergePath->pmergePathChild->csr.ILine()
							&& 1 == pmergePath->pmergePathChild->csr.Cpage().Clines() ) );
				pmergePath->fEmptyPage = fTrue;
				}
			else
				{
				//	this code path is a very specialised case -- there is only one page pointer
				//	in this page, and in the non-leaf child page, the page pointer with
				//	the largest key was deleted (and the key was non-null), necessitating a key
				//	change in the key of the sole page pointer in this page
				Assert( fKeyChange );
				Assert( pmergePath->pmergePathChild->fDeleteNode );
				Assert( pmergePath->pmergePathChild->iLine ==
				   pmergePath->pmergePathChild->csr.Cpage().Clines() - 1 );
				Assert( !pmergePath->pmergePathChild->csr.Cpage().FLeafPage() );
				if ( FBTIOverflowOnReplacingKey(
							pfucb,
							pmergePath,
							pmergeLeaf->kdfParentSep ) )
					{
					goto Overflow;
					}
											 
				pmergePath->fKeyChange = fTrue;
				}
				
			continue;
			}

		Assert( pmergePath->csr.ILine() == pmergePath->iLine );
		if ( pmergePath->csr.Cpage().Clines() - 1 == pmergePath->iLine )
			{
			//	delete largest parent pointer node in page
			//		replace current last node in page with new separator key
			//
			Assert( fLeftSibling );

			if ( !fKeyChange )
				{
				//	allocate and compute separator key from leaf level
				//
				Assert( !pmergePathLeaf->pmerge->fAllocParentSep );
				
				fKeyChange = fTrue;
				CallR( ErrBTIMergeCopySeparatorKey( pmergePath,
													pmergePathLeaf->pmerge, 
													pfucb ) );
				Assert( pmergePathLeaf->pmerge->fAllocParentSep );

				pmergePath->fDeleteNode = fTrue;

				Assert( pmergePath->csr.Cpage().Clines() > 1 );
				if ( FBTINullKeyedLastNode( pfucb, pmergePath ) )
					{
					//	parent pointer is also null-keyed
					//
					Assert( NULL == pmergePath->pmergePathParent ||
							pmergePath->pmergePathParent->csr.Cpage().Clines() - 1 ==
								pmergePath->pmergePathParent->iLine &&
							FBTINullKeyedLastNode( pfucb, 
												   pmergePath->pmergePathParent ) );
					break;
					}
				}
			else
				{
				if ( FBTIOverflowOnReplacingKey( pfucb,
												 pmergePath,
												 pmergeLeaf->kdfParentSep ) )
					{
					goto Overflow;
					}
					
				pmergePath->fKeyChange = fTrue;
				}

			continue;
			}

		if ( pmergePath->pmergePathChild->fKeyChange ||
			 ( pmergePath->pmergePathChild->fDeleteNode && 
			   pmergePath->pmergePathChild->iLine == 
			   pmergePath->pmergePathChild->csr.Cpage().Clines() - 1 ) )
			{
			//	change key of page pointer in this page
			//	since largest key in child page has changed
			//
			Assert( !pmergePath->pmergePathChild->csr.Cpage().FLeafPage() );
			Assert( pmergePath->pmergePathChild->iLine == 
					pmergePath->pmergePathChild->csr.Cpage().Clines() - 1 );
			Assert( fKeyChange );

			if ( FBTIOverflowOnReplacingKey( pfucb,
											 pmergePath,
											 pmergeLeaf->kdfParentSep ) )
				{
				goto Overflow;
				}
											 
			pmergePath->fKeyChange = fTrue;
			}
		else if ( pmergePath->pmergePathChild->fEmptyPage )
			{
			//	parent of merged or emptied page
			//
			Assert( pmergePath->iLine != pmergePath->csr.Cpage().Clines() - 1 );
			Assert( pmergePath->csr.Cpage().Clines() > 1 );

			pmergePath->fDeleteNode = fTrue;
			}
			
		break;
		}

	return JET_errSuccess;
	
Overflow:
	pmergePathLeaf->pmerge->mergetype = mergetypeNone;
	return JET_errSuccess;
	}



//	does replacing the key in node pmergePath->iLine of page
//	cause a page overflow?
//
BOOL FBTIOverflowOnReplacingKey( FUCB 					*pfucb,
								 MERGEPATH				*pmergePath,
								 const KEYDATAFLAGS& 	kdfSep )
	{
	CSR		*pcsr = &pmergePath->csr;

	Assert( !kdfSep.key.FNull() );
	Assert( !pcsr->Cpage().FLeafPage() );

	//	calculate required space for separator with current prefix
	//
	ULONG 	cbReq = CbBTICbReq( pfucb, pcsr, kdfSep );
	
	//	get last node in page
	//
	pcsr->SetILine( pmergePath->iLine );
	NDGet( pfucb, pcsr );
	Assert( !FNDVersion( pfucb->kdfCurr ) );

	ULONG	cbSizeCurr = CbNDNodeSizeCompressed( pfucb->kdfCurr );
	
	//	check if new separator key would cause overflow
	//
	if ( cbReq > cbSizeCurr )
		{
		const BOOL	fOverflow = FBTISplit( pfucb, pcsr, cbReq - cbSizeCurr );

		return fOverflow;
		}
		
	return fFalse;
	}


//	UNDONE: we can do without the allocation and copy by 
//			copying kdfCurr into kdfParentSep
//			and ordering merge/empty page operations bottom-down
//
//	copies new page separator key from last - 1 node in current page
//	
ERR ErrBTIMergeCopySeparatorKey( MERGEPATH 	*pmergePath, 
								 MERGE		*pmergeLeaf,
								 FUCB 		*pfucb )
	{
	Assert( NULL != pmergeLeaf );
	Assert( mergetypePartialRight != pmergeLeaf->mergetype );
	Assert( pmergeLeaf->kdfParentSep.key.FNull() );
	Assert( pmergeLeaf->kdfParentSep.data.FNull() );
	
	Assert( !pmergePath->csr.Cpage().FLeafPage() );
	Assert( pmergePath->iLine == pmergePath->csr.Cpage().Clines() - 1 );
	Assert( pmergePath->iLine > 0 );
	
	pmergePath->csr.SetILine( pmergePath->iLine - 1 );
	NDGet( pfucb, &pmergePath->csr );
	Assert( sizeof( PGNO ) == pfucb->kdfCurr.data.Cb() );

	pmergeLeaf->kdfParentSep.key.Nullify();
	pmergeLeaf->kdfParentSep.key.suffix.SetPv( PvOSMemoryHeapAlloc( pfucb->kdfCurr.key.Cb() ) );
	if ( pmergeLeaf->kdfParentSep.key.suffix.Pv() == NULL )
		{
		return ErrERRCheck( JET_errOutOfMemory );
		}
		
	//	copy separator key into alocated memory
	//
	pfucb->kdfCurr.key.CopyIntoBuffer( pmergeLeaf->kdfParentSep.key.suffix.Pv() );
	pmergeLeaf->kdfParentSep.key.suffix.SetCb( pfucb->kdfCurr.key.Cb() );
	
	Assert( !pmergeLeaf->fAllocParentSep );
	Assert( !pmergeLeaf->kdfParentSep.key.FNull() );
	pmergeLeaf->fAllocParentSep = fTrue;

	//	page pointer should have pgno as data
	//
	pmergeLeaf->kdfParentSep.data.SetCb( sizeof( PGNO ) );
	return JET_errSuccess;
	}


//	from leaf to root
//
VOID BTIReleaseMergePaths( MERGEPATH *pmergePathLeaf )
	{
	MERGEPATH *pmergePath = pmergePathLeaf;
	
	for ( ; pmergePath != NULL; )
		{
		//	save parent 
		//
		MERGEPATH *pmergePathParent = pmergePath->pmergePathParent;

		BTIReleaseOneMergePath( pmergePath );
		pmergePath = pmergePathParent;
		}
	}


//	performs merge by going through pages top-down
//	
ERR ErrBTIMergeOrEmptyPage( FUCB *pfucb, MERGEPATH *pmergePathLeaf )
	{
	ERR			err = JET_errSuccess;
	MERGE		*pmerge = pmergePathLeaf->pmerge;
	LGPOS		lgpos;

	Assert( NULL != pmerge );
	Assert( mergetypeNone != pmerge->mergetype );

	//	upgrade latches
	//
	CallR( ErrBTIMergeUpgradeLatches( pfucb->ifmp, pmergePathLeaf ) );

	//	log merge operation as a multi-page operation
	//	there can be no failures after this
	//		till space release operations
	//
	err = ErrLGMerge( pfucb, pmergePathLeaf, &lgpos );
	
	// on error, return to before dirty dbtime on all pages
	if ( JET_errSuccess > err )
		{
		BTIMergeRevertDbtime( pmergePathLeaf );
		}
	CallR ( err );
	
	BTIMergeSetLgpos( pmergePathLeaf, lgpos );

	BTIPerformMerge( pfucb, pmergePathLeaf );

	//	check if the merge performed is correct
	//
	BTICheckMerge( pfucb, pmergePathLeaf );
	
	//	release all latches 
	//	so space can latch root successfully
	//
	BTIMergeReleaseLatches( pmergePathLeaf );
	
	//	release empty pages -- ignores errors
	//
	BTIReleaseEmptyPages( pfucb, pmergePathLeaf );
	
	return err;
	}


//	performs merge or empty page operation 
//		by calling one-level merge at each level top-down
//
VOID BTIPerformMerge( FUCB *pfucb, MERGEPATH *pmergePathLeaf )
	{
	MERGEPATH	*pmergePath;
	
	//	go to root
	//	since we need to process pages bottom-down
	//
	for ( pmergePath = pmergePathLeaf;
		  pmergePath->pmergePathParent != NULL;
		  pmergePath = pmergePath->pmergePathParent )
		{
		}

	//	process pages top-down
	//
	for ( ; pmergePath != NULL; pmergePath = pmergePath->pmergePathChild )
		{
		if ( pmergePath->csr.Latch() == latchWrite ||
			 PinstFromIfmp( pfucb->ifmp )->m_plog->m_fRecovering )
			{
			BTIPerformOneMerge( pfucb, pmergePath, pmergePathLeaf->pmerge );
			switch ( pmergePath->pmerge ? pmergePath->pmerge->mergetype : mergetypeNone )
				{
				case mergetypeEmptyPage:
					PERFIncCounterTable( cBTEmptyPageMerge, PinstFromPfucb( pfucb ), pfucb->u.pfcb->Tableclass() );
					break;
					
				case mergetypeFullRight:
					PERFIncCounterTable( cBTRightMerge, PinstFromPfucb( pfucb ), pfucb->u.pfcb->Tableclass() );
					break;
					
				case mergetypePartialRight:
					PERFIncCounterTable( cBTPartialMerge, PinstFromPfucb( pfucb ), pfucb->u.pfcb->Tableclass() );
					break;
					
				default:
					break;
				}
			}
		else
			{
//			Assert( fFalse );
			}
		}
	}

	
//	processes one page for merge or empty page operation
//	depending on the operation selection in pmergePath->flags
//
VOID BTIPerformOneMerge( FUCB 		*pfucb, 
						 MERGEPATH 	*pmergePath, 
						 MERGE 		*pmergeLeaf )
	{
	CSR		*pcsr = &pmergePath->csr;

	Assert( !FBTIUpdatablePage( *pcsr ) || pcsr->FDirty() );
	
	Assert( !pmergePath->fKeyChange || !pmergePath->fDeleteNode );
	Assert( !pmergePath->fEmptyPage ||
			!pmergePath->fKeyChange && !pmergePath->fDeleteNode );
	Assert( !pmergePath->fEmptyPage ||
			mergetypePartialRight != pmergeLeaf->mergetype );
	
	//	if leaf page, 
	//		fix all flag deleted versions of nodes in page to operNull
	//		if merge, 
	//			move nodes to right page
	//		if not partial merge
	//			fix siblings
	//
	if ( NULL == pmergePath->pmergePathChild )
		{
		Assert( pmergePath->pmerge == pmergeLeaf );
		const MERGETYPE	mergetype = pmergeLeaf->mergetype;
		
		Assert( mergetype != mergetypeNone );
		Assert( !FBTIUpdatablePage( *pcsr ) || pcsr->Cpage().FLeafPage() );

		if ( mergetypeEmptyPage != mergetype )
			{
			BTIMergeMoveNodes( pfucb, pmergePath );
			}
			
		//	delete flag deleted nodes that have no active version
		//	if there is a version nullify it
		//
		BTIMergeDeleteFlagDeletedNodes( pfucb, pmergePath );

		if ( mergetypePartialRight != mergetype )
			{
			//	fix siblings 
			BTIMergeFixSiblings( PinstFromIfmp( pfucb->ifmp ), pmergePath );
			}

#ifdef LV_MERGE_BUG
		if ( mergetypeEmptyPage != mergetype
			&& pcsr->Cpage().FLeafPage()
			&& pcsr->Cpage().FLongValuePage() )
			{
			extern VOID	LVICheckLVMerge( FUCB *pfucb, MERGEPATH *pmergePath );
			LVICheckLVMerge( pfucb, pmergePath );
			}
#endif			
		}

	//	if page not write latched [no redo needed]
	//		do nothing
	else if ( !FBTIUpdatablePage( *pcsr ) )
		{
		Assert( PinstFromIfmp( pfucb->ifmp )->FRecovering() );
		}

	//	if fDeleteNode, 
	//		delete node
	//		if page pointer is last node and 
	//		there is no right sibling to leaf page, 
	//			fix new last key to NULL
	//
	else if ( pmergePath->fDeleteNode )
		{
		Assert( !pmergePath->csr.Cpage().FLeafPage() );
		Assert( pmergePath->csr.Cpage().Clines() > 1 );
		Assert( mergetypePartialRight != pmergeLeaf->mergetype );

		const BOOL fFixLastNodeToNull = FBTINullKeyedLastNode( pfucb, pmergePath );

		NDDelete( pcsr );
		if ( fFixLastNodeToNull )
			{
			Assert( pmergeLeaf->mergetype == mergetypeEmptyPage );
			Assert( !FBTIUpdatablePage( pmergeLeaf->pmergePath->csr ) ||
					pmergeLeaf->pmergePath->csr.Cpage().PgnoNext() == pgnoNull );
			Assert( pcsr->Cpage().Clines() == pmergePath->iLine );
			Assert( pcsr->ILine() > 0 );

			pcsr->DecrementILine();
			KEY keyNull;
			keyNull.Nullify();
			BTIChangeKeyOfPagePointer( pfucb, pcsr, keyNull );
			}
		}

	//	if fKeyChange
	//		change the key of seeked node to new separator
	//
	else if ( pmergePath->fKeyChange )
		{
		Assert( !pmergeLeaf->kdfParentSep.key.FNull() );

		pcsr->SetILine( pmergePath->iLine );
		BTIChangeKeyOfPagePointer( pfucb, 
								   pcsr, 
								   pmergeLeaf->kdfParentSep.key );
		}

	else
		{
		Assert( pmergePath->fEmptyPage );
		}

	if ( pmergePath->fEmptyPage &&
		 FBTIUpdatablePage( pmergePath->csr ) )
		{
		//	set page flag to Empty
		//
		pmergePath->csr.Cpage().SetEmpty();
		}
		
	return;
	}


//	changes the key of a page pointer node to given key
//
VOID BTIChangeKeyOfPagePointer( FUCB *pfucb, CSR *pcsr, const KEY& key )
	{
	Assert( !pcsr->Cpage().FLeafPage() );
	
	NDGet( pfucb, pcsr );
	Assert( sizeof( PGNO ) == pfucb->kdfCurr.data.Cb() );
	Assert( !pfucb->kdfCurr.key.FNull() );

	LittleEndian<PGNO>	le_pgno = *((UnalignedLittleEndian< PGNO > *) pfucb->kdfCurr.data.Pv() );
	Assert( le_pgno != pgnoNull );

	//	delete node and re-insert with given key 
	//
	NDDelete( pcsr );

	KEYDATAFLAGS	kdfInsert;

	kdfInsert.fFlags	= 0;
	kdfInsert.data.SetCb( sizeof( PGNO ) );
	kdfInsert.data.SetPv( &le_pgno );
	kdfInsert.key		= key;

	BTIComputePrefixAndInsert( pfucb, pcsr, kdfInsert );
	}


//	release latches on pages that are not required
//
VOID BTIMergeReleaseUnneededPages( MERGEPATH *pmergePathLeaf )
	{
	MERGEPATH 	*pmergePath;

	//	go to root
	//	release latches top-down
	//
	for ( pmergePath = pmergePathLeaf;
		  pmergePath->pmergePathParent != NULL;
		  pmergePath = pmergePath->pmergePathParent )
		{
		}

	Assert( NULL == pmergePath->pmergePathParent );
	for ( ; NULL != pmergePath;  )
		{

		//	check if page is needed
		//		-- either there is a merge/empty page at this level
		//		   or there is a merge/empty page one level below
		//				when we need write latch for deleting page pointer
		//		   or there is a key change at this level
		//
		MERGE	*pmerge = pmergePath->pmerge;
		
		if ( !pmergePath->fKeyChange &&
			 !pmergePath->fEmptyPage && 
			 !pmergePath->fDeleteNode && 
			 pmergePath->pmergePathChild != NULL )
			{
			Assert( NULL == pmergePath->pmergePathParent );
			
			//	release latch and pmergePath at this level
			//
			MERGEPATH *pmergePathT = pmergePath;

			Assert( !pmergePath->fDeleteNode );
			Assert( !pmergePath->fKeyChange );
			Assert( !pmergePath->fEmptyPage );
			Assert( !pmergePath->csr.Cpage().FLeafPage() );
			Assert( NULL != pmergePath->pmergePathChild );
			if ( mergetypeNone != pmergePathLeaf->pmerge->mergetype )
				{
				//	parent of merged or emptied page must not be released
				//
				Assert( pmergePath->pmergePathChild->pmergePathChild != NULL );
				Assert( !pmergePath->pmergePathChild->csr.Cpage().FLeafPage() );
				}
			Assert( pmergePath->csr.Latch() == latchRIW );
			
			pmergePath = pmergePath->pmergePathChild;

			//	release latches on these pages
			//
			BTIReleaseOneMergePath( pmergePathT );
			}
		else
			{
			pmergePath = pmergePath->pmergePathChild;
			}
		}
	}
	

//	upgrade to write latch on all pages invloved in the merge/emptypage
//
LOCAL ERR ErrBTIMergeUpgradeLatches( const IFMP ifmp, MERGEPATH * const pmergePathLeaf )
	{
	ERR				err;
	MERGEPATH 		* pmergePath;
	const DBTIME	dbtimeMerge		= rgfmp[ifmp].DbtimeIncrementAndGet();

	Assert( dbtimeMerge > 1 );
	Assert( PinstFromIfmp( ifmp )->m_plog->m_fRecoveringMode != fRecoveringRedo );

	//	go to root
	//	since we need to latch top-down
	//
	for ( pmergePath = pmergePathLeaf;
		  pmergePath->pmergePathParent != NULL;
		  pmergePath = pmergePath->pmergePathParent )
		{
		}

	Assert( NULL == pmergePath->pmergePathParent );
	for ( ; NULL != pmergePath;  )
		{
		//	check if write latch is needed
		//		-- either there is a merge/empty page at this level
		//		   or there is a merge/empty page one level below
		//				when we need write latch for deleting page pointer
		//		   or there is a key change at this level
		//
		MERGE	*pmerge = pmergePath->pmerge;
		
		if ( pmergePath->fKeyChange ||
			 pmergePath->fEmptyPage ||
			 pmergePath->fDeleteNode ||
			 pmergePath->pmergePathChild == NULL )
			{
			Assert( latchWrite != pmergePath->csr.Latch() );
			
			if ( pmergePath->pmergePathChild == NULL )
				{
				//	leaf-level
				//	write latch left, current and right pages in order
				//
				Assert( NULL != pmerge );
				Assert( mergetypeNone != pmerge->mergetype );
				Assert( pmergePath->csr.Cpage().FLeafPage() );

				pmerge->dbtimeLeftBefore = dbtimeNil;
				pmerge->dbtimeRightBefore = dbtimeNil;

				if ( pgnoNull != pmerge->csrLeft.Pgno() )
					{
					Assert( pmerge->csrLeft.Cpage().FLeafPage() );

					pmerge->csrLeft.UpgradeFromRIWLatch();

					if ( pmerge->csrLeft.Dbtime() < dbtimeMerge )
						{
						pmerge->dbtimeLeftBefore = pmerge->csrLeft.Dbtime();
						pmerge->csrLeft.CoordinatedDirty( dbtimeMerge );
						}
					else
						{
						FireWall();
						Call( ErrERRCheck( JET_errDbTimeCorrupted ) );
						}
					}

				if (	pmerge->mergetype == mergetypePartialRight ||
						pmerge->mergetype == mergetypeFullRight )
					{
					Assert( pgnoNull != pmerge->csrRight.Pgno() );

					//  depend the right page on the merge page so that the data
					//  moved from the merge page to the right page will always
					//  be available no matter when we crash

					Call( ErrBFDepend(	pmerge->csrRight.Cpage().PBFLatch(),
										pmergePath->csr.Cpage().PBFLatch() ) );
					}
					
				pmergePath->csr.UpgradeFromRIWLatch();

				if ( pmergePath->csr.Dbtime() < dbtimeMerge )
					{
					pmergePath->dbtimeBefore = pmergePath->csr.Dbtime();
					pmergePath->csr.CoordinatedDirty( dbtimeMerge );
					}
				else
					{
					FireWall();
					Call( ErrERRCheck( JET_errDbTimeCorrupted ) );
					}
				
				if ( pgnoNull != pmerge->csrRight.Pgno() )
					{
					Assert( pmerge->csrRight.Cpage().FLeafPage() );

					pmerge->csrRight.UpgradeFromRIWLatch();

					if ( pmerge->csrRight.Dbtime() < dbtimeMerge )
						{
						pmerge->dbtimeRightBefore = pmerge->csrRight.Dbtime();
						pmerge->csrRight.CoordinatedDirty( dbtimeMerge );
						}
					else
						{
						FireWall();
						Call( ErrERRCheck( JET_errDbTimeCorrupted ) );
						}
					}
				}
			else
				{
				Assert( !pmergePath->csr.Cpage().FLeafPage() );
				pmergePath->csr.UpgradeFromRIWLatch();

				if ( pmergePath->csr.Dbtime() < dbtimeMerge )
					{
					pmergePath->dbtimeBefore = pmergePath->csr.Dbtime();
					pmergePath->csr.CoordinatedDirty( dbtimeMerge );
					}
				else
					{
					FireWall();
					Call( ErrERRCheck( JET_errDbTimeCorrupted ) );
					}
				}
				
			pmergePath = pmergePath->pmergePathChild;
			}
		else
			{
			//	release latch and pmergePath at this level
			//
			AssertTracking();
			MERGEPATH *pmergePathT = pmergePath;

			Assert( !pmergePath->fDeleteNode );
			Assert( !pmergePath->fKeyChange );
			Assert( !pmergePath->fEmptyPage );
			Assert( !pmergePath->csr.Cpage().FLeafPage() );
			Assert( NULL != pmergePath->pmergePathChild );
			Assert( pmergePath->pmergePathChild->pmergePathChild != NULL );
			Assert( !pmergePath->pmergePathChild->csr.Cpage().FLeafPage() );
			Assert( pmergePath->csr.Latch() == latchRIW );
			
			pmergePath = pmergePath->pmergePathChild;

			//	UNDONE:	release latches on these pages
			//
			BTIReleaseOneMergePath( pmergePathT );
			}
		}

	return JET_errSuccess;

HandleError:
	Assert( err < 0 );
	BTIMergeRevertDbtime( pmergePathLeaf );
	return err;
	}


//	sets lgpos for every page involved in merge or empty page operation
//
VOID BTIMergeSetLgpos( MERGEPATH *pmergePathLeaf, const LGPOS& lgpos )
	{
	MERGEPATH	*pmergePath = pmergePathLeaf;

	for ( ; pmergePath != NULL && pmergePath->csr.Latch() == latchWrite;
		  pmergePath = pmergePath->pmergePathParent )
		{
		Assert( pmergePath->csr.FDirty() );

		pmergePath->csr.Cpage().SetLgposModify( lgpos );

		MERGE	*pmerge = pmergePath->pmerge;
		
		if ( pmerge != NULL )
			{
			if ( pmerge->csrLeft.Pgno() != pgnoNull )
				{
				Assert( pmerge->csrLeft.Cpage().FLeafPage() );
				pmerge->csrLeft.Cpage().SetLgposModify( lgpos );
				}

			if ( pmerge->csrRight.Pgno() != pgnoNull )
				{
				Assert( pmerge->csrRight.Cpage().FLeafPage() );
				pmerge->csrRight.Cpage().SetLgposModify( lgpos );
				}
			}
		}

#ifdef DEBUG
	for ( ; NULL != pmergePath; pmergePath = pmergePath->pmergePathParent )
		{
		Assert( pmergePath->csr.Latch() == latchRIW );
		}
#endif
	}
	

//	releases all latches held by merge or empty page operation
//
VOID BTIMergeReleaseLatches( MERGEPATH *pmergePathLeaf )
	{
	MERGEPATH	*pmergePath = pmergePathLeaf;

	for ( ; pmergePath != NULL; pmergePath = pmergePath->pmergePathParent )
		{
		Assert( pmergePath->csr.FLatched() );
		pmergePath->csr.ReleasePage();

		if ( pmergePath->pmerge != NULL )
			{
			if ( pmergePath->pmerge->csrLeft.FLatched() )
				{
				pmergePath->pmerge->csrLeft.ReleasePage();
				}
				
			if ( pmergePath->pmerge->csrRight.FLatched() )
				{
				pmergePath->pmerge->csrRight.ReleasePage();
				}
			}
		}
	}


//	release every page marked empty
//
VOID BTIReleaseEmptyPages( FUCB *pfucb, MERGEPATH *pmergePathLeaf ) 
	{
	MERGEPATH	*pmergePath = pmergePathLeaf;
	const BOOL	fAvailExt	= FFUCBAvailExt( pfucb );
	const BOOL	fOwnExt		= FFUCBOwnExt( pfucb );

	//	fake out cursor to make it think it's not a space cursor
	if ( fAvailExt )
		{
		Assert( !fOwnExt );
		FUCBResetAvailExt( pfucb );
		}
	else if ( fOwnExt )
		{
		FUCBResetOwnExt( pfucb );
		}
	Assert( !FFUCBSpace( pfucb ) );

	Assert( pmergePathLeaf->fEmptyPage ||
			mergetypePartialRight == pmergePathLeaf->pmerge->mergetype );
	Assert( !PinstFromIfmp( pfucb->ifmp )->m_plog->m_fRecovering );
	
	for ( ; pmergePath != NULL; pmergePath = pmergePath->pmergePathParent )
		{
		//	if empty page
		//		release space to FDP
		//
		Assert( !pmergePath->csr.FLatched() );
		if ( pmergePath->fEmptyPage )
			{

			//	space flags reset at the top of this function in order to fake out SPFreeExtent()
			Assert( !FFUCBSpace( pfucb ) );

			//	UNDONE:	track lost space because of inability 
			//			to split availExt tree with the released space
			//
			Assert( pmergePath->csr.Pgno() != PgnoRoot( pfucb ) );
			const ERR	errFreeExt	= ErrSPFreeExt( pfucb, pmergePath->csr.Pgno(), 1 );
#ifdef DEBUG
			if ( JET_errSuccess != errFreeExt
				&& !FRFSAnyFailureDetected() )
				{
				CallS( errFreeExt );
				}
#endif				
			}
		}

	Assert( !FFUCBSpace( pfucb ) );
	if ( fAvailExt )
		{
		FUCBSetAvailExt( pfucb );
		}
	else if ( fOwnExt )
		{
		FUCBSetOwnExt( pfucb );
		}
	}


//	nullify every inactive flag-deleted version in page
//	delete node if flag-deleted with no active version
//
VOID BTIMergeDeleteFlagDeletedNodes( FUCB *pfucb, MERGEPATH *pmergePath )
	{
	SHORT		iline;
	CSR			*pcsr = &pmergePath->csr;

	if ( !FBTIUpdatablePage( *pcsr ) )
		{
		Assert( PinstFromIfmp( pfucb->ifmp )->FRecovering() );
		return;
		}
	Assert( latchWrite == pcsr->Latch() );

	Assert( pcsr->Cpage().FLeafPage() );
	Assert( pmergePath->pmergePathChild == NULL );

	const MERGE	*pmerge = pmergePath->pmerge;

	for ( iline = SHORT( pcsr->Cpage().Clines() - 1 ); iline >= 0; iline-- )
		{
		const LINEINFO	*plineinfo = &pmerge->rglineinfo[iline];
		
		pcsr->SetILine( iline );
		NDGet( pfucb, pcsr );

		if ( FNDDeleted( pfucb->kdfCurr ) )
			{
			if ( FNDVersion( pfucb->kdfCurr ) && !plineinfo->fVerActive )
				{
				BOOKMARK	bm;

				NDGetBookmarkFromKDF( pfucb, pfucb->kdfCurr, &bm );

				VERNullifyInactiveVersionsOnBM( pfucb, bm );
				}
			}

		if ( mergetypePartialRight == pmerge->mergetype &&
			 pmerge->ilineMerge <= iline )
			{
			//	node has moved
			//
			NDDelete( pcsr );
			}
		}
	}


//	fix siblings of leaf page merged or emptied
//	to point to each other
//
VOID BTIMergeFixSiblings( INST *pinst, MERGEPATH *pmergePath )
	{
	MERGE	*pmerge = pmergePath->pmerge;
	
	Assert( !FBTIUpdatablePage( pmergePath->csr ) ||
			pmergePath->csr.Cpage().FLeafPage() );
	Assert( pmergePath->pmergePathChild == NULL );
	Assert( pmerge != NULL );

	if ( pmerge->csrLeft.Pgno() != pgnoNull &&
		 FBTIUpdatablePage( pmerge->csrLeft ) )
		{
		Assert( !FBTIUpdatablePage( pmergePath->csr ) ||
				pmergePath->csr.Cpage().PgnoPrev() != pgnoNull );
		Assert( pmerge->csrLeft.Latch() == latchWrite );
		Assert( pmerge->csrLeft.FDirty() );
		
		pmerge->csrLeft.Cpage().SetPgnoNext( pmerge->csrRight.Pgno() );
		}
	else if ( !pinst->FRecovering() )
		{
		Assert( pmergePath->csr.Cpage().PgnoPrev() == pgnoNull );
		}
	else
		{
		Assert( pgnoNull == pmerge->csrLeft.Pgno() &&
					( !FBTIUpdatablePage( pmergePath->csr ) || 
					  pgnoNull == pmergePath->csr.Cpage().PgnoPrev() ) ||
				!FBTIUpdatablePage( pmerge->csrLeft ) );
		}

	if ( pmerge->csrRight.Pgno() != pgnoNull && 
		 FBTIUpdatablePage( pmerge->csrRight ) )
		{
		Assert( !FBTIUpdatablePage( pmergePath->csr ) ||
				pmergePath->csr.Cpage().PgnoNext() != pgnoNull );
		Assert( pmerge->csrRight.Latch() == latchWrite );
		Assert( pmerge->csrRight.FDirty() );
		
		pmerge->csrRight.Cpage().SetPgnoPrev( pmerge->csrLeft.Pgno() );
		}
	else  if (!pinst->m_plog->m_fRecovering )
		{
		Assert( pmergePath->csr.Cpage().PgnoNext() == pgnoNull );
		}
	else
		{
		Assert( pgnoNull == pmerge->csrRight.Pgno() &&
					( !FBTIUpdatablePage( pmergePath->csr ) ||
					  pgnoNull == pmergePath->csr.Cpage().PgnoNext() ) ||
				!FBTIUpdatablePage( pmerge->csrRight ) );
		}
	}


//	move undeleted nodes >= ilineMerge from current page to right page
//	set cbUncommittedFree on right page
//
VOID BTIMergeMoveNodes( FUCB *pfucb, MERGEPATH *pmergePath )
	{
	CSR			*pcsrSrc = &pmergePath->csr;
	CSR			*pcsrDest = &pmergePath->pmerge->csrRight;
	MERGE		*pmerge = pmergePath->pmerge;
	INT			iline;
	const INT	clines = pmerge->clines;
	const INT	ilineMerge = pmerge->ilineMerge;

	if ( !FBTIUpdatablePage( *pcsrDest ) )
		{
		goto MoveUndoInfo;
		}
	Assert( latchWrite == pcsrDest->Latch() );

	Assert( FBTIUpdatablePage( *pcsrSrc ) );
	Assert( FBTIUpdatablePage( *pcsrDest ) );

	Assert( mergetypeFullRight == pmerge->mergetype ||
			mergetypePartialRight == pmerge->mergetype );
	Assert( 0 == pmerge->ilineMerge ||
			mergetypePartialRight == pmerge->mergetype );
	Assert( clines > ilineMerge );
	Assert( clines == pcsrSrc->Cpage().Clines() );
	Assert( NULL != pmerge );
	Assert( pmerge->csrRight.Pgno() != pgnoNull );
	Assert( pcsrSrc->Cpage().PgnoNext() == pcsrDest->Pgno() );
	Assert( pcsrDest->Cpage().PgnoPrev() == pcsrSrc->Pgno() );

	Assert( latchWrite == pmergePath->pmerge->csrRight.Latch() );

	pcsrDest->SetILine( 0 );
	for ( iline = clines - 1; iline >= ilineMerge; iline-- )
		{
		LINEINFO *plineinfo = &pmerge->rglineinfo[iline];

#ifdef DEBUG
		pcsrSrc->SetILine( iline );
		NDGet( pfucb, pcsrSrc );
///		Assert( pfucb->kdfCurr.fFlags == plineinfo->kdf.fFlags );
		Assert( FKeysEqual( pfucb->kdfCurr.key, plineinfo->kdf.key ) );
		Assert( FDataEqual( pfucb->kdfCurr.data, plineinfo->kdf.data ) );
#endif
		
		if ( FNDDeleted( plineinfo->kdf ) && !plineinfo->fVerActive )
			{
			continue;
			}

#ifdef DEBUG
		//	check cbPrefix
		//
		NDGetPrefix( pfucb, pcsrDest );
		const INT	cbCommon = CbCommonKey( pfucb->kdfCurr.key, 
											plineinfo->kdf.key );
		if ( cbCommon > cbPrefixOverhead )
			{
			Assert( cbCommon == plineinfo->cbPrefix );
			}
		else
			{
			Assert( 0 == plineinfo->cbPrefix );
			}
#endif
		
		//	copy node to start of destination page
		//
		Assert( !FNDDeleted( plineinfo->kdf ) );
		Assert( pcsrDest->ILine() == 0 );
		NDInsert( pfucb, pcsrDest, &plineinfo->kdf, plineinfo->cbPrefix );
		}

	//	add uncommitted freed space caused by move to destination page
	//
	Assert( PinstFromIfmp( pfucb->ifmp )->m_plog->m_fRecovering || 
			pcsrDest->Cpage().CbUncommittedFree() +
				pmerge->cbSizeMaxTotal - 
				pmerge->cbSizeTotal  == 
				pmerge->cbUncFreeDest );
	pcsrDest->Cpage().SetCbUncommittedFree( pmerge->cbUncFreeDest );
	
MoveUndoInfo:
	KEY		keySep;

	if ( mergetypePartialRight == pmerge->mergetype )
		{
		Assert( pmerge->ilineMerge > 0 );
		Assert( pmerge->fAllocParentSep );

		keySep = pmerge->kdfParentSep.key;
		}
	else
		{
		keySep.Nullify();
		}

	if ( FBTIUpdatablePage( *pcsrSrc ) )
		{
		VERMoveUndoInfo( pfucb, pcsrSrc, pcsrDest, keySep );
		}
	else
		{
		//	if we didn't need to redo the source page, we shouldn't need to redo the
		//	destination page
		Assert( !FBTIUpdatablePage( *pcsrDest ) );
		}
	return;
	}


//	checks merge/empty page operation
//
INLINE VOID BTICheckMerge( FUCB *pfucb, MERGEPATH *pmergePathLeaf )
	{
#ifdef DEBUG
	MERGEPATH	*pmergePath;
	
	//	check leaf level merge/empty page
	//
	BTICheckMergeLeaf( pfucb, pmergePathLeaf );
	
	//	check operation at internal levels
	//
	for ( pmergePath = pmergePathLeaf->pmergePathParent; 
		  pmergePath != NULL; 
		  pmergePath = pmergePath->pmergePathParent )
		{
		BTICheckMergeInternal( pfucb, pmergePath, pmergePathLeaf->pmerge );
		}
#endif
	}

//	checks merge/empty page operation at leaf-level
//
VOID BTICheckMergeLeaf( FUCB *pfucb, MERGEPATH *pmergePath )
	{
#ifdef DEBUG
	MERGE	*pmerge		= pmergePath->pmerge;
	CSR		*pcsr		= &pmergePath->csr;
	CSR		*pcsrRight	= &pmerge->csrRight;
	CSR		*pcsrLeft	= &pmerge->csrLeft;
	
	Assert( pmerge != NULL );

	MERGETYPE 		mergetype = pmerge->mergetype;
	const DBTIME	dbtime = pcsr->Dbtime();
	
	Assert( mergetypeFullRight == mergetype ||
			mergetypeEmptyPage == mergetype ||
			mergetypePartialRight == mergetype );
	Assert( pcsr->Cpage().FLeafPage() );
	Assert( pmergePath->pmergePathParent != NULL );
	Assert( pmergePath->pmergePathParent->csr.Dbtime() == dbtime );

	if ( mergetypeEmptyPage != mergetype )
		{
		Assert( latchWrite == pcsrRight->Latch() );
		Assert( pcsrRight->Pgno() != pgnoNull );
		}

	//	check sibling pages point to each other
	//
	if ( pmergePath->fEmptyPage )
		{
		Assert( pcsrRight->Pgno() != pcsr->Pgno() );
		if ( pcsrRight->Pgno() != pgnoNull )
			{
			Assert( pcsrRight->Dbtime() == dbtime );
			Assert( latchWrite == pcsrRight->Latch() );
			Assert( pcsrRight->Cpage().PgnoPrev() == pcsrLeft->Pgno() );
			}
		
		Assert( pcsrLeft->Pgno() != pcsr->Pgno() );
		if ( pcsrLeft->Pgno() != pgnoNull )
			{
			Assert( pcsrLeft->Dbtime() == dbtime );
			Assert( latchWrite == pcsrLeft->Latch() );
			Assert( pcsrLeft->Cpage().PgnoNext() == pcsrRight->Pgno() );
			}
		}

	//	check last node in left page has key less than page pointer
	//

	//	check first node in right page has key >= page pointer key
	//
#endif  //  DEBUG
	}


//	checks internal page after a merge/empty page operation
//
VOID BTICheckMergeInternal( FUCB 		*pfucb, 
							MERGEPATH 	*pmergePath, 
							MERGE 		*pmergeLeaf )
	{
#ifdef DEBUG
	Assert( pmergePath->pmerge == NULL );

	CSR 			*pcsr	= &pmergePath->csr;
	const SHORT 	clines	= SHORT( pcsr->Cpage().Clines() );
	const DBTIME	dbtime	= pcsr->Dbtime();
	
	Assert( !pcsr->Cpage().FLeafPage() );
	Assert( pcsr->Latch() == latchRIW
		|| pcsr->Dbtime() == dbtime );

	//	if empty page,
	//		return
	//
	if ( pmergePath->fEmptyPage )
		{
		Assert( pmergePath->csr.Cpage().Clines() == 1 );
		return;
		}

	Assert( pmergePath->pmergePathParent == NULL ||
			!pmergePath->pmergePathParent->fEmptyPage );
			
	if ( pmergePath->fKeyChange || 
		 pmergePath->fDeleteNode )
		{
		Assert( pcsr->Latch() == latchWrite );
		}
	else
		{
		//	UNDONE:	change this later to Assert( fFalse )
		//			since the page should be released
		//
///		Assert( pcsr->Latch() == latchRIW );
		Assert( fFalse );
		}
		
	//	for every node in page 
	//	check that it does not point to an empty page
	//
	for ( SHORT iline = 0; iline < clines; iline++ )
		{
		pcsr->SetILine( iline );
		NDGet( pfucb, pcsr );

		Assert( sizeof( PGNO ) == pfucb->kdfCurr.data.Cb() );
		PGNO pgnoChild = *( (UnalignedLittleEndian< PGNO > *) pfucb->kdfCurr.data.Pv() );
		
		MERGEPATH	*pmergePathT = pmergeLeaf->pmergePath;
		Assert( pmergePathT->pmergePathChild == NULL );
		
		for ( ; 
			  pmergePathT != NULL; 
			  pmergePathT = pmergePathT->pmergePathParent )
			{
			if ( pmergePathT->fEmptyPage )
				{
				Assert( pgnoChild != pmergePathT->csr.Pgno() );
				}
			}
		}

	//	check last node in page has same key 
	//	as parent pointer
	//
	if ( pmergePath->pmergePathParent == NULL )
		{
		//	if root page, check if last node is NULL-keyed
		//
		Assert( !pcsr->Cpage().FLeafPage() );

		pcsr->SetILine( pcsr->Cpage().Clines() - 1 );
		NDGet( pfucb, pcsr );

		Assert( sizeof( PGNO ) == pfucb->kdfCurr.data.Cb() );
		Assert( !pcsr->Cpage().FRootPage() || 
				pfucb->kdfCurr.key.FNull() );
		
		return;
		}
		
	pcsr->SetILine( clines - 1 );
	NDGet( pfucb, pcsr );
	const KEYDATAFLAGS kdfLast = pfucb->kdfCurr;

	CSR		*pcsrParent = &pmergePath->pmergePathParent->csr;

	Assert( pcsrParent->Latch() == latchRIW
		|| pcsrParent->Dbtime() == dbtime );
	Assert( !pmergePath->pmergePathParent->fDeleteNode );
	pcsrParent->SetILine( pmergePath->pmergePathParent->iLine );
	NDGet( pfucb, pcsrParent );

	Assert( FKeysEqual( kdfLast.key, pfucb->kdfCurr.key ) );
#endif  //  DEBUG
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ese98\src\ese\comp.cxx ===
#include "std.hxx"
#include "_comp.hxx"

#define	SLVDEFRAG_HACK

// UNDONE:  Do these need to be localised?
#define szCompactStatsFile		"DFRGINFO.TXT"
#define szCompactAction			"Defragmentation"
#define szCMPSTATSTableName		"Table Name"
#define szCMPSTATSFixedVarCols	"# Non-Derived Fixed/Variable Columns"
#define szCMPSTATSTaggedCols	"# Non-Derived Tagged Columns"
#define szCMPSTATSColumns		"# Columns"
#define szCMPSTATSSecondaryIdx	"# Secondary Indexes"
#define szCMPSTATSPagesOwned	"Pages Owned (Source DB)"
#define szCMPSTATSPagesAvail	"Pages Avail. (Source DB)"
#define szCMPSTATSInitTime		"Table Create/Init. Time"
#define szCMPSTATSRecordsCopied	"# Records Copied"
#define szCMPSTATSRawData		"Raw Data Bytes Copied"
#define szCMPSTATSRawDataLV		"Raw Data LV Bytes Copied"
#define szCMPSTATSLeafPages		"Leaf Pages Traversed"
#define szCMPSTATSMinLVPages	"Min. LV Pages Traversed"
#define szCMPSTATSRecordsTime	"Copy Records Time"
#define szCMPSTATSTableTime		"Copy Table Time"


//  ================================================================
class CMEMLIST
//  ================================================================
//
//  Allocate a chunk of memory, keep allocating more. All memory
//  can be destroyed.
//
//	Memory is stored in a singly-linked list. The first 4 bytes
//  of memory allocated points to the next chunk
//
//-
	{
	private:
		VOID * m_pvHead;
		ULONG  m_cbAllocated;	//	includes list overhead

	public:
		CMEMLIST();
		~CMEMLIST();

		VOID * PvAlloc( const ULONG cb );
		VOID FreeAllMemory();

	public:
#ifndef RTM
		static void UnitTest();
#endif	//	!RTM

#ifdef DEBUG
		VOID AssertValid() const ;
#endif	//	DEBUG

	private:
		CMEMLIST( const CMEMLIST& );
		CMEMLIST& operator=( const CMEMLIST& );
	};


//  ================================================================
CMEMLIST::CMEMLIST() :
	m_pvHead( 0 ),
	m_cbAllocated( 0 )
//  ================================================================
	{
	}


//  ================================================================
CMEMLIST::~CMEMLIST()
//  ================================================================
	{
	//  Have people call FreeAllMemory to make the code clearer
	Assert( NULL == m_pvHead );	//	CMEMLIST::FreeAllMemory() not called?
	Assert( 0 == m_cbAllocated ); //	CMEMLIST::FreeAllMemory() not called?
	FreeAllMemory();
	}


//  ================================================================
VOID * CMEMLIST::PvAlloc( const ULONG cb )
//  ================================================================
//
//	Get a new chunk of memory, put it at the head of the list
//
//-
	{
	const ULONG cbActualAllocate = cb + sizeof( VOID* );
	VOID * const pvNew = PvOSMemoryHeapAlloc( cbActualAllocate );
	if( NULL == pvNew )
		{
		return NULL;
		}
		
	VOID * const pvReturn = reinterpret_cast<BYTE *>( pvNew ) + sizeof( VOID* );
	*(reinterpret_cast<VOID **>( pvNew ) ) = m_pvHead;
	m_pvHead = pvNew;

	m_cbAllocated += cbActualAllocate;
	
	return pvReturn;
	}


//  ================================================================
VOID CMEMLIST::FreeAllMemory()
//  ================================================================
	{
	VOID * pv = m_pvHead;
	while( pv )
		{
		VOID * const pvNext = *(reinterpret_cast<VOID **>( pv ) );
		OSMemoryHeapFree( pv );
		pv = pvNext;
		}

	m_cbAllocated 	= 0;
	m_pvHead 		= NULL;
	}


#ifdef DEBUG
//  ================================================================
VOID CMEMLIST::AssertValid() const
//  ================================================================
	{
	const VOID * pv = m_pvHead;
	while( pv )
		{
		const VOID * const pvNext = *((VOID **)( pv ) );
		pv = pvNext;
		}

	if( 0 == m_cbAllocated )
		{
		Assert( NULL == m_pvHead );
		}
	else
		{
		Assert( NULL != m_pvHead );
		}
	}	
#endif	//	DEBUG


#ifndef RTM
//  ================================================================
VOID CMEMLIST::UnitTest()
//  ================================================================
//
//  STATIC function
//
//-
	{
	CMEMLIST cmemlist;

	ULONG cbAllocated = 0;
	INT i;
	for( i = 0; i < 64; ++i )
		{
		VOID * const pv = cmemlist.PvAlloc( i );
		AssertRTL( NULL != pv );	//	Out-of-memory is not acceptable during a unit test :-)
		cbAllocated += i + sizeof( VOID* );
		AssertRTL( cbAllocated == cmemlist.m_cbAllocated );
		ASSERT_VALID( &cmemlist );
		}

	cmemlist.FreeAllMemory();
	ASSERT_VALID( &cmemlist );

	(VOID)cmemlist.PvAlloc( 1024 * 1024 );
	ASSERT_VALID( &cmemlist );

	(VOID)cmemlist.PvAlloc( 0xffffffff );	//	try an allocation that fails
	ASSERT_VALID( &cmemlist );

	cmemlist.FreeAllMemory();
	ASSERT_VALID( &cmemlist );	
	}
#endif	//	!RTM

struct COMPACTINFO
	{
	PIB				*ppib;
	IFMP			ifmpSrc;
	IFMP			ifmpDest;
	COLUMNIDINFO	rgcolumnids[ccolCMPFixedVar];
	ULONG			ccolSingleValue;
	STATUSINFO		*pstatus;
	BYTE			rgbBuf[g_cbLVBufMax];		// Buffer for copying LV and other misc. usage
	};


INLINE ERR ErrCMPOpenDB(
	COMPACTINFO		*pcompactinfo, 
	const CHAR		*szDatabaseSrc, 
	IFileSystemAPI	*pfsapiDest,
	const CHAR		*szDatabaseDest, 
	const CHAR		*szDatabaseSLVDest )
	{
	ERR			err;
	JET_GRBIT	grbitCreateForDefrag	= JET_bitDbRecoveryOff|JET_bitDbVersioningOff;

	//	open the source DB Exclusive and ReadOnly
	//	UNDONE: JET_bitDbReadOnly currently unsupported
	//	by OpenDatabase (must be specified with AttachDb)
	CallR( ErrDBOpenDatabase(
				pcompactinfo->ppib,
				(CHAR *)szDatabaseSrc, 
				&pcompactinfo->ifmpSrc,
				JET_bitDbExclusive|JET_bitDbReadOnly ) );

	if ( rgfmp[pcompactinfo->ifmpSrc].FSLVAttached() )
		{
		grbitCreateForDefrag |= JET_bitDbCreateStreamingFile;
		}
	else
		{
		szDatabaseSLVDest = NULL;
		}

	//	Create and then open the destination database.
	//	CONSIDER: Should the destination database be deleted
	//	if it already exists?
	Assert( NULL != pfsapiDest );
	err = ErrDBCreateDatabase(
				pcompactinfo->ppib,
				pfsapiDest,
				szDatabaseDest,
				szDatabaseSLVDest,
				NULL,
				0, 
				&pcompactinfo->ifmpDest,
				dbidMax,
				cpgDatabaseMin,
				grbitCreateForDefrag,
				NULL );

	Assert( err <= 0 );		// No warnings.
	if ( err < 0 )
		{
		(VOID)ErrDBCloseDatabase(
						pcompactinfo->ppib,
						pcompactinfo->ifmpSrc,
						NO_GRBIT );
		}

	return err;
	}


LOCAL VOID CMPCopyOneIndex(
	FCB						* const pfcbSrc,
	FCB						*pfcbIndex,
	JET_INDEXCREATE			*pidxcreate,
	JET_CONDITIONALCOLUMN	*pconditionalcolumn )
	{
	TDB						*ptdb = pfcbSrc->Ptdb();
	IDB						*pidb = pfcbIndex->Pidb();

	Assert( pfcbSrc->FTypeTable() );
	Assert( pfcbSrc->FPrimaryIndex() );
	
	Assert( ptdbNil != ptdb );
	Assert( pidbNil != pidb );

	// Derived indexes are inherited at table creation time.
	Assert( !pfcbIndex->FDerivedIndex() );

	Assert( sizeof(JET_INDEXCREATE) == pidxcreate->cbStruct );
	
	pfcbSrc->EnterDML();	// Strictly speaking, not needed because defrag is single-threaded
	
	strcpy( pidxcreate->szIndexName, ptdb->SzIndexName( pidb->ItagIndexName() ) );

	ULONG	cb = (ULONG)strlen( pidxcreate->szIndexName );
	Assert( cb > 0 );
	Assert( cb <= JET_cbNameMost );
	Assert( pidxcreate->szIndexName[cb] == '\0' );

	CHAR	* const szKey = pidxcreate->szKey;
	ULONG	ichKey = 0;
	const IDXSEG* rgidxseg = PidxsegIDBGetIdxSeg( pidb, ptdb );
	
	Assert( pidb->Cidxseg() > 0 );
	Assert( pidb->Cidxseg() <= JET_ccolKeyMost );
	for ( ULONG iidxseg = 0; iidxseg < pidb->Cidxseg(); iidxseg++ )
		{
		const COLUMNID	columnid		= rgidxseg[iidxseg].Columnid();
		const FIELD		* const pfield	= ptdb->Pfield( columnid );

		Assert( pfieldNil != pfield );

		if ( !FFIELDPrimaryIndexPlaceholder( pfield->ffield ) )
			{
			const BOOL		fDerived	= ( FCOLUMNIDTemplateColumn( columnid ) && !ptdb->FTemplateTable() );
			szKey[ichKey++] = ( rgidxseg[iidxseg].FDescending() ? '-' : '+' );
			strcpy( szKey+ichKey, ptdb->SzFieldName( pfield->itagFieldName, fDerived ) );
			cb = (ULONG)strlen( szKey+ichKey );
			Assert( cb > 0 );
			Assert( cb <= JET_cbNameMost );
		
			Assert( szKey[ichKey+cb] == '\0' );
			ichKey += cb + 1;		// +1 for segment's null terminator.
			}
		else
			{
			//	must be first column in primary index
			Assert( pidb->FPrimary() );
			Assert( 0 == iidxseg );
			Assert( 0 == ichKey );
			}
		}
		
	szKey[ichKey++] = '\0';	// double-null termination

	Assert( ichKey > 2 );

	Assert( pidb->CbVarSegMac() > 0 );
	Assert( pidb->CbVarSegMac() <= KEY::CbKeyMost( pidb->FPrimary() ) );

	pidxcreate->cbVarSegMac = pidb->CbVarSegMac();
	pidxcreate->cbKey 		= ichKey;
	pidxcreate->grbit 		= pidb->GrbitFromFlags() | JET_bitIndexUnicode;

	Assert( lcidNone != pidb->Lcid() );
	Assert( NULL != pidxcreate->pidxunicode );
	*( pidxcreate->pidxunicode ) = *( pidb->Pidxunicode() );

	pidxcreate->rgconditionalcolumn = pconditionalcolumn;
	pidxcreate->cConditionalColumn	= pidb->CidxsegConditional();

	rgidxseg = PidxsegIDBGetIdxSegConditional( pidb, ptdb );
	for( iidxseg = 0; iidxseg < pidxcreate->cConditionalColumn; ++iidxseg )
		{
		CHAR * const szConditionalKey = szKey + ichKey;

		const COLUMNID	columnid	= rgidxseg[iidxseg].Columnid();
		const FIELD		*pfield		= ptdb->Pfield( columnid );
		const BOOL		fDerived	= FCOLUMNIDTemplateColumn( columnid ) && !ptdb->FTemplateTable();

		Assert( pfieldNil != pfield );

		strcpy( szConditionalKey, ptdb->SzFieldName( pfield->itagFieldName, fDerived ) );
		ichKey += (ULONG)strlen( szConditionalKey ) + 1;

		pidxcreate->rgconditionalcolumn[iidxseg].cbStruct 		= sizeof( JET_CONDITIONALCOLUMN );
		pidxcreate->rgconditionalcolumn[iidxseg].szColumnName 	= szConditionalKey;
		pidxcreate->rgconditionalcolumn[iidxseg].grbit			= ( rgidxseg[iidxseg].FMustBeNull()
												? JET_bitIndexColumnMustBeNull
												: JET_bitIndexColumnMustBeNonNull );
		}

	pfcbSrc->LeaveDML();
	
	pidxcreate->ulDensity = pfcbSrc->UlDensity();
	}

LOCAL ERR ErrCMPCreateTableColumnIndex( 
	COMPACTINFO		*pcompactinfo, 
	FCB				* const pfcbSrc,
	JET_TABLECREATE2	*ptablecreate,
	JET_COLUMNLIST	*pcolumnList, 
	COLUMNIDINFO	*columnidInfo, 
	JET_COLUMNID	**pmpcolumnidcolumnidTagged )
	{
	ERR				err;
	PIB				*ppib = pcompactinfo->ppib;
	FCB				*pfcbIndex;
	ULONG			cColumns;
	ULONG			cbColumnids;
	ULONG			cbAllocate;
	ULONG			cSecondaryIndexes;
	ULONG			cIndexesToCreate;
	ULONG			cConditionalColumns;
	ULONG			ccolSingleValue = 0;
	ULONG			cbActual;
	JET_COLUMNID	*mpcolumnidcolumnidTagged = NULL;
	FID				fidTaggedHighest = 0;
	ULONG			cTagged = 0;
	BOOL			fLocalAlloc = fFalse;
	ULONG			cbDefaultRecRemaining = cbRECRecordMost;

	//	All memory allocated from this will be freed at the end of the function
	CMEMLIST		cmemlist;

	const INT		cbName			= JET_cbNameMost+1;	// index/column name plus terminator
	const INT		cbLangid		= sizeof(LANGID)+2;	// langid plus double-null terminator
	const INT		cbCbVarSegMac	= sizeof(BYTE)+2;	// cbVarSegMac plus double-null terminator
	const INT		cbKeySegment	= 1+cbName;			// +/- prefix plus name
	const INT		cbKey			= ( JET_ccolKeyMost * cbKeySegment ) + 1;	// plus 1 for double-null terminator
	const INT		cbKeyExtended	= cbKey + cbLangid + cbCbVarSegMac;

	Assert( ptablecreate->cCreated == 0 );

	// Allocate a pool of memory for:
	//		1) list of source table columnids
	//		2) the JET_COLUMNCREATE structures
	//		3) buffer for column names
	//		4) buffer for default values
	//		5) the JET_INDEXCREATE structures
	//		6) buffer for index names
	//		7) buffer for index keys.

	cColumns = pcolumnList->cRecord;

	//	start by allocating space for the source table columnids, adjusted for alignment
	cbColumnids = cColumns * sizeof(JET_COLUMNID);
	cbColumnids = ( ( cbColumnids + sizeof(SIZE_T) - 1 ) / sizeof(SIZE_T) ) * sizeof(SIZE_T);

	cbAllocate = cbColumnids +
					( cColumns *
						( sizeof(JET_COLUMNCREATE) +	// JET_COLUMNCREATE structures
						cbName ) );						// column names

	// Derived indexes will get inherited from template -- don't count
	// them as ones that need to be created.
	Assert( ( pfcbSrc->FSequentialIndex() && pfcbSrc->Pidb() == pidbNil )
		|| ( !pfcbSrc->FSequentialIndex() && pfcbSrc->Pidb() != pidbNil ) );
	cIndexesToCreate = ( pfcbSrc->Pidb() != pidbNil && !pfcbSrc->FDerivedIndex() ? 1 : 0 );
	cConditionalColumns = 0;
	cSecondaryIndexes = 0;
	for ( pfcbIndex = pfcbSrc->PfcbNextIndex();
		pfcbIndex != pfcbNil;
		pfcbIndex = pfcbIndex->PfcbNextIndex() )
		{
		cConditionalColumns += pfcbIndex->Pidb()->CidxsegConditional();
		cSecondaryIndexes++;
		Assert( pfcbIndex->FTypeSecondaryIndex() );
		Assert( pfcbIndex->Pidb() != pidbNil );
		if ( !pfcbIndex->FDerivedIndex() )
			cIndexesToCreate++;
		}

	//	ensure primary extent is large enough to at least accommodate the primary index
	//	and each secondary index
	ptablecreate->ulPages = max( cSecondaryIndexes+1, ptablecreate->ulPages );

	cbAllocate +=
		cIndexesToCreate *
			(
			sizeof( JET_INDEXCREATE )	// JET_INDEXCREATE
			+ cbName					// index name
			+ cbKeyExtended				// index key, plus langid and cbVarSegmac
			+ sizeof( JET_UNICODEINDEX )
			);

	cbAllocate += cConditionalColumns * ( sizeof( JET_CONDITIONALCOLUMN ) + cbKeySegment );

	cbAllocate += cbDefaultRecRemaining;		// all default values must fit in an intrinsic record

	// WARNING: To ensure that columnids and JET_COLUMN/INDEXCREATE
	// structs are 4-byte aligned, arrange everything in the following
	// order:
	//		1) list of source table columnids
	//		2) JET_COLUMNCREATE structures
	//		3) JET_INDEXCREATE structures
	//		4) JET_UNICODEINDEX structures
	//		5) JET_CONDITIONALCOLUMN structures
	//		6) buffer for column names
	//		7) buffer for index names
	//		8) buffer for index keys
	//		9) buffer for default values
			

	// Can we use the buffer hanging off pcompactinfo?
	JET_COLUMNID	*pcolumnidSrc;
	if ( cbAllocate <= g_cbLVBuf )
		{
		pcolumnidSrc = (JET_COLUMNID *)pcompactinfo->rgbBuf;
		}
	else
		{
		pcolumnidSrc = static_cast<JET_COLUMNID *>( PvOSMemoryHeapAlloc( cbAllocate ) );
		if ( pcolumnidSrc == NULL )
			{
			err = ErrERRCheck( JET_errOutOfMemory );
			return err;
			}
		fLocalAlloc = fTrue;
		}
	
	JET_COLUMNID	* const rgcolumnidSrc = pcolumnidSrc;
	BYTE			* const pbMax = (BYTE *)rgcolumnidSrc + cbAllocate;
	memset( (BYTE *)pcolumnidSrc, 0, cbAllocate );
	
	// JET_COLUMNCREATE structures follow the tagged columnid map.
	JET_COLUMNCREATE *pcolcreateCurr		= (JET_COLUMNCREATE *)( (BYTE *)rgcolumnidSrc + cbColumnids );
	JET_COLUMNCREATE * const rgcolcreate	= pcolcreateCurr;
	Assert( (BYTE *)rgcolcreate < pbMax );

	// JET_INDEXCREATE structures follow the JET_COLUMNCREATE structures
	JET_INDEXCREATE	*pidxcreateCurr = (JET_INDEXCREATE *)( rgcolcreate + cColumns );
	JET_INDEXCREATE	* const rgidxcreate = pidxcreateCurr;
	Assert( (BYTE *)rgidxcreate < pbMax );

	JET_UNICODEINDEX	*pidxunicodeCurr		= (JET_UNICODEINDEX *)( rgidxcreate + cIndexesToCreate );
	JET_UNICODEINDEX	* const rgidxunicode	= pidxunicodeCurr;
	Assert( (BYTE *)rgidxunicode < pbMax );

	// JET_CONDITIONALCOLUMN structures follow the JET_INDEXCREATE structures
	JET_CONDITIONALCOLUMN	*pconditionalcolumnCurr 	= (JET_CONDITIONALCOLUMN *)( rgidxunicode + cIndexesToCreate  );
	JET_CONDITIONALCOLUMN	* const rgconditionalcolumn = pconditionalcolumnCurr;
	Assert( (BYTE *)rgconditionalcolumn < pbMax );

	// Column names follow the JET_CONDITIONALCOLUMN structures.
	CHAR	*szCurrColumn = (CHAR *)( rgconditionalcolumn + cConditionalColumns );
	CHAR	* const rgszColumns = szCurrColumn;
	Assert( (BYTE *)rgszColumns < pbMax );

	// Index names follow the column names.
	CHAR	*szCurrIndex = (CHAR *)( rgszColumns + ( cColumns * cbName ) );
	CHAR	* const rgszIndexes = szCurrIndex;
	Assert( (BYTE *)rgszIndexes < pbMax );

	// Index/Conditional Column keys follow the index names.
	CHAR	*szCurrKey = ( CHAR *)( rgszIndexes + ( cIndexesToCreate * cbName ) );
	CHAR	* const rgszKeys = szCurrKey;
	Assert( (BYTE *)rgszKeys < pbMax );

	// Default values follow the keys.
	BYTE	*pbCurrDefault = (BYTE *)( rgszKeys + ( cIndexesToCreate * cbKeyExtended) + ( cConditionalColumns * cbKeySegment ) );
	BYTE	* const rgbDefaultValues = pbCurrDefault;
	Assert( rgbDefaultValues < pbMax );

	Assert( rgbDefaultValues + cbRECRecordMost == pbMax );

	err = ErrDispMove( 
				reinterpret_cast<JET_SESID>( ppib ),
				pcolumnList->tableid,
				JET_MoveFirst,
				NO_GRBIT );

	/* loop though all the columns in the table for the src tbl and
	/* copy the information in the destination database
	/**/
	cColumns = 0;
	while ( err >= 0 )
		{
		memset( pcolcreateCurr, 0, sizeof( JET_COLUMNCREATE ) );
		pcolcreateCurr->cbStruct = sizeof(JET_COLUMNCREATE);

		/* retrieve info from table and create all the columns
		/**/
		Assert( (BYTE *)szCurrColumn + JET_cbNameMost + 1 <= (BYTE *)rgszIndexes );
		Call( ErrDispRetrieveColumn(
					reinterpret_cast<JET_SESID>( ppib ),
					pcolumnList->tableid, 
					pcolumnList->columnidcolumnname,
					szCurrColumn,
					JET_cbNameMost,
					&cbActual,
					NO_GRBIT,
					NULL ) );

		Assert( cbActual <= JET_cbNameMost );
		szCurrColumn[cbActual] = '\0';
		pcolcreateCurr->szColumnName = szCurrColumn;
		
		szCurrColumn += cbActual + 1;
		Assert( (BYTE *)szCurrColumn <= (BYTE *)rgszIndexes );

#ifdef DEBUG		
		// Assert Presentation order no longer supported.
		ULONG	ulPOrder;
		Call( ErrDispRetrieveColumn(
					reinterpret_cast<JET_SESID>( ppib ),
					pcolumnList->tableid,
					pcolumnList->columnidPresentationOrder,
					&ulPOrder,
					sizeof(ulPOrder),
					&cbActual,
					NO_GRBIT,
					NULL ) );
		Assert( JET_wrnColumnNull == err );
#endif		

		Call( ErrDispRetrieveColumn(
					reinterpret_cast<JET_SESID>( ppib ),
					pcolumnList->tableid, 
					pcolumnList->columnidcoltyp,
					&pcolcreateCurr->coltyp, 
					sizeof( pcolcreateCurr->coltyp ),
					&cbActual, 
					NO_GRBIT, 
					NULL ) );
		Assert( cbActual == sizeof( JET_COLTYP ) );
		Assert( JET_coltypNil != pcolcreateCurr->coltyp );

		Call( ErrDispRetrieveColumn(
					reinterpret_cast<JET_SESID>( ppib ),
					pcolumnList->tableid, 
					pcolumnList->columnidcbMax, 
					&pcolcreateCurr->cbMax, 
					sizeof( pcolcreateCurr->cbMax ), 
					&cbActual, 
					NO_GRBIT, 
					NULL ) );
		Assert( cbActual == sizeof( ULONG ) );

		Call( ErrDispRetrieveColumn(
					reinterpret_cast<JET_SESID>( ppib ),
					pcolumnList->tableid, 
					pcolumnList->columnidgrbit, 
					&pcolcreateCurr->grbit, 
					sizeof( pcolcreateCurr->grbit ), 
					&cbActual, 
					NO_GRBIT, 
					NULL ) );
		Assert( cbActual == sizeof( JET_GRBIT ) );

		Call( ErrDispRetrieveColumn(
					reinterpret_cast<JET_SESID>( ppib ),
					pcolumnList->tableid, 
					pcolumnList->columnidCp, 
					&pcolcreateCurr->cp,
					sizeof( pcolcreateCurr->cp ), 
					&cbActual, 
					NO_GRBIT, 
					NULL ) );
		Assert( cbActual == sizeof( USHORT ) );

		/*	retrieve default value.
		/**/
		if( pcolcreateCurr->grbit & JET_bitColumnUserDefinedDefault )
			{
			JET_USERDEFINEDDEFAULT * pudd = NULL;

			//  don't want to pass in NULL
			BYTE b;
			Call( ErrDispRetrieveColumn(
						reinterpret_cast<JET_SESID>( ppib ),
						pcolumnList->tableid, 
						pcolumnList->columnidDefault, 
						&b,
						sizeof( b ),
						&pcolcreateCurr->cbDefault, 
						NO_GRBIT, 
						NULL ) );
			
			pcolcreateCurr->pvDefault = cmemlist.PvAlloc( pcolcreateCurr->cbDefault );
			if( NULL == pcolcreateCurr->pvDefault )
				{
				Call( ErrERRCheck( JET_errOutOfMemory ) );
				}
				
			Call( ErrDispRetrieveColumn(
						reinterpret_cast<JET_SESID>( ppib ),
						pcolumnList->tableid, 
						pcolumnList->columnidDefault, 
						pcolcreateCurr->pvDefault,
						pcolcreateCurr->cbDefault,
						&pcolcreateCurr->cbDefault, 
						NO_GRBIT, 
						NULL ) );
			Assert( JET_wrnBufferTruncated != err );
			Assert( JET_wrnColumnNull != err );
			Assert( pcolcreateCurr->cbDefault > 0 );

			//  All of the information about a user-defined default is in the default buffer
			//  ErrINFOGetTableColumnInfo lays it out like this:
			//
			//  JET_USERDEFINEDDEFAULT | szCallback | pbUserData | szDependantColumns
			//
			//  The pointers in the JET_USERDEFINEDDEFAULT are no longer usable so they have
			//  to be fixed up. The cbDefault has to be reduced to sizeof( JET_USERDEFINEDDEFAULT )
			//  because that is what the JET APIs are expecting
			
			pudd = (JET_USERDEFINEDDEFAULT *)pcolcreateCurr->pvDefault;
			pudd->szCallback = ((CHAR*)(pcolcreateCurr->pvDefault)) + sizeof( JET_USERDEFINEDDEFAULT );
			pudd->pbUserData = ((BYTE*)(pudd->szCallback)) + strlen( pudd->szCallback ) + 1;
			if( NULL != pudd->szDependantColumns )
				{
				pudd->szDependantColumns = (CHAR *)pudd->pbUserData + pudd->cbUserData;
				}
			
			//  in order to create the column the pvDefault should point to the JET_USERDEFINEDDEFAULT structure
			Assert( pcolcreateCurr->cbDefault > sizeof( JET_USERDEFINEDDEFAULT ) );
			pcolcreateCurr->cbDefault = sizeof( JET_USERDEFINEDDEFAULT );
			}
		else
			{
			Assert( cbDefaultRecRemaining > 0 );		// can never reach cbDefaultRecRemaining, because of record overhead
			Assert( pbCurrDefault + cbDefaultRecRemaining == pbMax );
			Call( ErrDispRetrieveColumn(
						reinterpret_cast<JET_SESID>( ppib ),
						pcolumnList->tableid, 
						pcolumnList->columnidDefault, 
						pbCurrDefault,
						cbDefaultRecRemaining,
						&pcolcreateCurr->cbDefault, 
						NO_GRBIT, 
						NULL ) );
			Assert( JET_wrnBufferTruncated != err );
			Assert( pcolcreateCurr->cbDefault < cbDefaultRecRemaining );	// can never reach cbDefaultRecRemaining, because of record overhead
			pcolcreateCurr->pvDefault = pbCurrDefault;
			pbCurrDefault += pcolcreateCurr->cbDefault;
			cbDefaultRecRemaining -= pcolcreateCurr->cbDefault;
			Assert( cbDefaultRecRemaining > 0 );		// can never reach cbDefaultRecRemaining, because of record overhead
			Assert( pbCurrDefault + cbDefaultRecRemaining == pbMax );
			}

		// Save the source columnid.
		/* CONSIDER: Should the column id be checked? */
		Call( ErrDispRetrieveColumn(
					reinterpret_cast<JET_SESID>( ppib ),
					pcolumnList->tableid, 
					pcolumnList->columnidcolumnid, 
					pcolumnidSrc, 
					sizeof( JET_COLUMNID ), 
					&cbActual, 
					NO_GRBIT, 
					NULL ) );
		Assert( cbActual == sizeof( JET_COLUMNID ) );

		if ( pcolcreateCurr->grbit & JET_bitColumnTagged )
			{
			cTagged++;
			fidTaggedHighest = max( fidTaggedHighest, FidOfColumnid( *pcolumnidSrc ) );
			}

		pcolumnidSrc++;
		Assert( (BYTE *)pcolumnidSrc <= (BYTE *)rgcolcreate );

		pcolcreateCurr++;
		Assert( (BYTE *)pcolcreateCurr <= (BYTE *)rgidxcreate );
		cColumns++;

		err = ErrDispMove(
					reinterpret_cast<JET_SESID>( ppib ),
					pcolumnList->tableid, 
					JET_MoveNext, 
					NO_GRBIT );
		}

	Assert( cColumns == pcolumnList->cRecord );

	Assert( ptablecreate->rgcolumncreate == NULL );
	Assert( ptablecreate->cColumns == 0 );
	ptablecreate->rgcolumncreate = rgcolcreate;
	ptablecreate->cColumns = cColumns;


	Assert( ptablecreate->rgindexcreate == NULL );
	Assert( ptablecreate->cIndexes == 0 );

	for ( pfcbIndex = pfcbSrc;
		pfcbIndex != pfcbNil;
		pfcbIndex = pfcbIndex->PfcbNextIndex() )
		{
		if ( pfcbIndex->Pidb() != pidbNil )
			{
			// Derived indexes will get inherited from template.
			if ( !pfcbIndex->FDerivedIndex() )
				{
				Assert( (BYTE *)pidxcreateCurr < (BYTE *)rgidxunicode );
				Assert( (BYTE *)pidxunicodeCurr < (BYTE *)rgconditionalcolumn );
				Assert( ( cConditionalColumns > 0 && (BYTE *)pconditionalcolumnCurr <= (BYTE *)rgszColumns )
					|| ( 0 == cConditionalColumns && (BYTE *)pconditionalcolumnCurr == (BYTE *)rgszColumns ) );
				Assert( (BYTE *)szCurrIndex < (BYTE *)rgszKeys );
				Assert( (BYTE *)szCurrKey < (BYTE *)rgbDefaultValues );

				memset( pidxcreateCurr, 0, sizeof( JET_INDEXCREATE ) );

				pidxcreateCurr->cbStruct 	= sizeof(JET_INDEXCREATE);
				pidxcreateCurr->szIndexName = szCurrIndex;
				pidxcreateCurr->szKey 		= szCurrKey;
				pidxcreateCurr->pidxunicode	= pidxunicodeCurr;

				CMPCopyOneIndex(
					pfcbSrc,
					pfcbIndex,
					pidxcreateCurr,
					pconditionalcolumnCurr );

				ptablecreate->cIndexes++;

				szCurrIndex += strlen( pidxcreateCurr->szIndexName ) + 1;
				Assert( (BYTE *)szCurrIndex <= (BYTE *)rgszKeys );
				
				szCurrKey += pidxcreateCurr->cbKey;
				Assert( (BYTE *)szCurrKey <= (BYTE *)rgbDefaultValues );

				if ( 0 != pidxcreateCurr->cConditionalColumn )
					{
					Assert( pidxcreateCurr->rgconditionalcolumn == pconditionalcolumnCurr );
					Assert( NULL != pconditionalcolumnCurr->szColumnName );
					Assert( pidxcreateCurr->cConditionalColumn > 0 );

					INT iConditionalColumn;
					for( iConditionalColumn = 0; iConditionalColumn < pidxcreateCurr->cConditionalColumn; ++iConditionalColumn )
						{
						szCurrKey += strlen( pidxcreateCurr->rgconditionalcolumn[iConditionalColumn].szColumnName ) + 1;
						}
					pconditionalcolumnCurr += pidxcreateCurr->cConditionalColumn;
					}
					
				pidxcreateCurr++;
				pidxunicodeCurr++;
				Assert( (BYTE *)pidxcreateCurr <= (BYTE *)rgidxunicode );
				Assert( (BYTE *)pidxunicodeCurr <= (BYTE *)rgconditionalcolumn );
				}
			}
		else
			{
			// If IDB is null, must be sequential index.
			Assert( pfcbIndex == pfcbSrc );
			Assert( pfcbIndex->FSequentialIndex() );
			}
		}

	Assert( (BYTE *)pidxcreateCurr == (BYTE *)rgidxunicode );
	Assert( (BYTE *)pidxunicodeCurr == (BYTE *)rgconditionalcolumn );
	Assert( ptablecreate->cIndexes == cIndexesToCreate );

	ptablecreate->rgindexcreate = rgidxcreate;
	
	Call( ErrFILECreateTable(
				ppib,
				pcompactinfo->ifmpDest,
				ptablecreate ) );
	Assert( ptablecreate->cCreated == 1 + cColumns + cIndexesToCreate );


	// If there's at least one tagged column, create an array for the
	// tagged columnid map.
	if ( cTagged > 0 )
		{
		Assert( FTaggedFid( fidTaggedHighest ) );
		cbAllocate = sizeof(JET_COLUMNID) * ( fidTaggedHighest + 1 - fidTaggedLeast );
		mpcolumnidcolumnidTagged = static_cast<JET_COLUMNID *>( PvOSMemoryHeapAlloc( cbAllocate ) );
		if ( mpcolumnidcolumnidTagged == NULL )
			{
			err = ErrERRCheck( JET_errOutOfMemory );
			goto HandleError;
			}
		memset( (BYTE *)mpcolumnidcolumnidTagged, 0, cbAllocate );
		}


	// Update columnid maps.
	for ( pcolcreateCurr = rgcolcreate, pcolumnidSrc = rgcolumnidSrc, cColumns = 0;
		cColumns < pcolumnList->cRecord;
		pcolcreateCurr++, pcolumnidSrc++, cColumns++ )
		{
		Assert( (BYTE *)pcolcreateCurr <= (BYTE *)rgidxcreate );
		Assert( (BYTE *)pcolumnidSrc <= (BYTE *)rgcolcreate );

		if ( FCOLUMNIDTemplateColumn( *pcolumnidSrc ) )
			{
			Assert( ptablecreate->grbit & JET_bitTableCreateTemplateTable );
			Assert( FCOLUMNIDTemplateColumn( pcolcreateCurr->columnid ) );
			}
		else
			{
			Assert( !( ptablecreate->grbit & JET_bitTableCreateTemplateTable ) );
			Assert( !( ptablecreate->grbit & JET_bitTableCreateNoFixedVarColumnsInDerivedTables ) );
			Assert( !FCOLUMNIDTemplateColumn( pcolcreateCurr->columnid ) );
			}

		if ( pcolcreateCurr->grbit & JET_bitColumnTagged )
			{
			Assert( FCOLUMNIDTagged( *pcolumnidSrc ) );
			Assert( FCOLUMNIDTagged( pcolcreateCurr->columnid ) );
			Assert( FidOfColumnid( *pcolumnidSrc ) <= fidTaggedHighest );
			Assert( mpcolumnidcolumnidTagged != NULL );
			Assert( mpcolumnidcolumnidTagged[FidOfColumnid( *pcolumnidSrc ) - fidTaggedLeast] == 0 );
			mpcolumnidcolumnidTagged[FidOfColumnid( *pcolumnidSrc ) - fidTaggedLeast] = pcolcreateCurr->columnid;
			}
		else
			{
			/*	else add the columnids to the columnid array
			/**/
			columnidInfo[ccolSingleValue].columnidDest = pcolcreateCurr->columnid;
			columnidInfo[ccolSingleValue].columnidSrc  = *pcolumnidSrc;
			ccolSingleValue++;
			}	// if ( columndef.grbit & JET_bitColumnTagged )
		}

	/*	set count of fixed and variable columns to copy
	/**/
	pcompactinfo->ccolSingleValue = ccolSingleValue; 

	if ( err == JET_errNoCurrentRecord )
		err = JET_errSuccess;

HandleError:
	if ( err < 0  &&  mpcolumnidcolumnidTagged )
		{
		OSMemoryHeapFree( mpcolumnidcolumnidTagged );
		mpcolumnidcolumnidTagged = NULL;
		}

	if ( fLocalAlloc )
		{
		OSMemoryHeapFree( rgcolumnidSrc );
		}

	cmemlist.FreeAllMemory();
	
	// Set return value.
	*pmpcolumnidcolumnidTagged = mpcolumnidcolumnidTagged;

	return err;
	}


LOCAL ERR ErrCMPCopyTable( 
	COMPACTINFO		*pcompactinfo, 
	const CHAR		*szObjectName,
	ULONG			ulFlags )
	{
	ERR				err;
	PIB				*ppib = pcompactinfo->ppib;
	IFMP			ifmpSrc = pcompactinfo->ifmpSrc;
	FUCB			*pfucbSrc = pfucbNil;
	FUCB			*pfucbDest = pfucbNil;
	FCB				*pfcbSrc;
	JET_COLUMNLIST	columnList;
	JET_COLUMNID    *mpcolumnidcolumnidTagged = NULL;
	STATUSINFO		*pstatus = pcompactinfo->pstatus;
	ULONG			crowCopied = 0;
	ULONG			recidLast;
	ULONG			rgulAllocInfo[] = { ulCMPDefaultPages, ulCMPDefaultDensity };
	CHAR			*szTemplateTableName = NULL;
	BOOL			fCorruption = fFalse;
	JET_TABLECREATE2	tablecreate = {
						sizeof(JET_TABLECREATE2),
						(CHAR *)szObjectName,
						NULL,					// Template table
						ulCMPDefaultPages,
						ulCMPDefaultDensity,
						NULL, 0,				// Columns
						NULL, 0,				// Indexes
						NULL, 0,				// Callbacks
						NO_GRBIT,
						0,
						0
						};

	if ( pstatus  &&  pstatus->fDumpStats )
		{
		Assert( pstatus->hfCompactStats );
		fprintf( pstatus->hfCompactStats, "%s\t", szObjectName );
		fflush( pstatus->hfCompactStats );
		CMPSetTime( &pstatus->timerCopyTable );
		CMPSetTime( &pstatus->timerInitTable );
		}

	CallR( ErrFILEOpenTable(
				ppib,
				ifmpSrc,
				&pfucbSrc,
				szObjectName,
				JET_bitTableSequential ) );
	Assert( pfucbNil != pfucbSrc );

	err = ErrIsamGetTableInfo(
				reinterpret_cast<JET_SESID>( ppib ),
				reinterpret_cast<JET_TABLEID>( pfucbSrc ),
				rgulAllocInfo,
				sizeof(rgulAllocInfo),
				JET_TblInfoSpaceAlloc );
	if ( err < 0  &&  !fGlobalRepair )
		{
		goto HandleError;
		}

	// On error, just use the default values of rgulAllocInfo.
	tablecreate.ulPages = rgulAllocInfo[0];
	tablecreate.ulDensity = rgulAllocInfo[1];

	/*	if a table create the columns in the Dest Db the same as in
	/*	the src Db.
	/**/
	Assert( !( ulFlags & JET_bitObjectSystem ) );
	if ( ulFlags & JET_bitObjectTableTemplate )
		{
		Assert( ulFlags & JET_bitObjectTableFixedDDL );
		Assert( !( ulFlags & JET_bitObjectTableDerived ) );
		tablecreate.grbit = ( JET_bitTableCreateTemplateTable | JET_bitTableCreateFixedDDL );

		if ( ulFlags & JET_bitObjectTableNoFixedVarColumnsInDerivedTables )
			tablecreate.grbit |= JET_bitTableCreateNoFixedVarColumnsInDerivedTables;
		}
	else
		{
		Assert( !( ulFlags & JET_bitObjectTableNoFixedVarColumnsInDerivedTables ) );
		if ( ulFlags & JET_bitObjectTableFixedDDL )
			{
			tablecreate.grbit = JET_bitTableCreateFixedDDL;
			}
		if ( ulFlags & JET_bitObjectTableDerived )
			{
			szTemplateTableName = reinterpret_cast<CHAR *>( PvOSMemoryHeapAlloc( JET_cbNameMost + 1 ) );
			if ( NULL == szTemplateTableName )
				{
				err = ErrERRCheck( JET_errOutOfMemory );
				goto HandleError;
				}
				
			// extract name.
			Call( ErrIsamGetTableInfo(
						reinterpret_cast<JET_SESID>( ppib ),
						reinterpret_cast<JET_TABLEID>( pfucbSrc ),
						szTemplateTableName,
						JET_cbNameMost+1,
						JET_TblInfoTemplateTableName ) );

			Assert( strlen( szTemplateTableName ) > 0 );
			tablecreate.szTemplateTableName = szTemplateTableName;
			}
		}
		

	pfcbSrc = pfucbSrc->u.pfcb;
	Assert( pfcbNil != pfcbSrc );
	Assert( pfcbSrc->FTypeTable() );
	
	/*	get a table with the column information for the query in it
	/**/
	Call( ErrIsamGetTableColumnInfo(
				reinterpret_cast<JET_SESID>( ppib ),
				reinterpret_cast<JET_TABLEID>( pfucbSrc ),
				NULL,
				NULL,
				&columnList,
				sizeof(columnList),
				JET_ColInfoListCompact ) );

	err = ErrCMPCreateTableColumnIndex(
				pcompactinfo,
				pfcbSrc,
				&tablecreate,
				&columnList,
				pcompactinfo->rgcolumnids, 
				&mpcolumnidcolumnidTagged );

	// Must use dispatch layer for temp/sort table.
	CallS( ErrDispCloseTable( 
					reinterpret_cast<JET_SESID>( ppib ),
					columnList.tableid ) );

	// Act on error code returned from CreateTableColumnIndex().
	Call( err );

	pfucbDest = reinterpret_cast<FUCB *>( tablecreate.tableid );
	Assert( tablecreate.cCreated == 1 + tablecreate.cColumns + tablecreate.cIndexes + ( tablecreate.szCallback ? 1 : 0 ) );
	Assert( tablecreate.cColumns >= pcompactinfo->ccolSingleValue );

	if ( pstatus )
		{
		ULONG	rgcpgExtent[2];		// OwnExt and AvailExt

		Assert( pstatus->pfnStatus );
		Assert( pstatus->snt == JET_sntProgress );

		// tablecreate.cIndexes is only a count of the indexes that were created.  We
		// also need the number of indexes inherited.
		FCB	*pfcbIndex = pfucbDest->u.pfcb;
		Assert( pfcbIndex->FPrimaryIndex() );
		Assert( ( pfcbIndex->FSequentialIndex() && pfcbIndex->Pidb() == pidbNil )
			|| ( !pfcbIndex->FSequentialIndex() && pfcbIndex->Pidb() != pidbNil ) );
		INT	cSecondaryIndexes = 0;
		for ( pfcbIndex = pfcbIndex->PfcbNextIndex();
			pfcbIndex != pfcbNil;
			pfcbIndex = pfcbIndex->PfcbNextIndex() )
			{
			Assert( pfcbIndex->FTypeSecondaryIndex() );
			Assert( pfcbIndex->Pidb() != pidbNil );
			cSecondaryIndexes++;
			}
	
		pstatus->szTableName = (char *)szObjectName;
		pstatus->cTableFixedVarColumns = pcompactinfo->ccolSingleValue;
		pstatus->cTableTaggedColumns = tablecreate.cColumns - pcompactinfo->ccolSingleValue;
		pstatus->cTableInitialPages = rgulAllocInfo[0];
		pstatus->cSecondaryIndexes = cSecondaryIndexes;

		err = ErrIsamGetTableInfo(
					reinterpret_cast<JET_SESID>( ppib ),
					reinterpret_cast<JET_TABLEID>( pfucbSrc ),
					rgcpgExtent,
					sizeof(rgcpgExtent),
					JET_TblInfoSpaceUsage );
		if ( err < 0 )
			{
			if ( fGlobalRepair )
				{
				//	if failure in space query then default to
				//	one page owned and no pages available.
				fCorruption = fTrue;
				rgcpgExtent[0] = 1;
				rgcpgExtent[1] = 0;
				}
			else
				{
				goto HandleError;
				}
			}

		// AvailExt always less than OwnExt.
		Assert( rgcpgExtent[1] < rgcpgExtent[0] );

		// cunitProjected is the projected total pages completed once
		// this table has been copied.
		pstatus->cunitProjected = pstatus->cunitDone + rgcpgExtent[0];
		if ( pstatus->cunitProjected > pstatus->cunitTotal )
			{
			Assert( fGlobalRepair );
			fCorruption = fTrue;
			pstatus->cunitProjected = pstatus->cunitTotal;
			}

		const ULONG	cpgUsed = rgcpgExtent[0] - rgcpgExtent[1];
		Assert( cpgUsed > 0 );

		pstatus->cbRawData = 0;
		pstatus->cbRawDataLV = 0;
		pstatus->cLeafPagesTraversed = 0;
		pstatus->cLVPagesTraversed = 0;

		// If corrupt, suppress progression of meter.
		pstatus->cunitPerProgression =
			( fCorruption ? 0 : 1 + ( rgcpgExtent[1] / cpgUsed ) );
		pstatus->cTablePagesOwned = rgcpgExtent[0];
		pstatus->cTablePagesAvail = rgcpgExtent[1];

		if ( pstatus->fDumpStats )
			{
			Assert( pstatus->hfCompactStats );

			const TDB	* const ptdbT = pfucbDest->u.pfcb->Ptdb();
			Assert( ptdbNil != ptdbT );
			const INT	cColumns = ( ptdbT->FidFixedLast() + 1 - fidFixedLeast )
									+ ( ptdbT->FidVarLast() + 1 - fidVarLeast )
									+ ( ptdbT->FidTaggedLast() + 1 - fidTaggedLeast );

			if ( cColumns > pstatus->cTableFixedVarColumns + pstatus->cTableTaggedColumns )
				{
				Assert( pfucbDest->u.pfcb->FDerivedTable() );
				}
			else
				{
				Assert( cColumns == pstatus->cTableFixedVarColumns + pstatus->cTableTaggedColumns );
				}
		
			INT	iSec, iMSec;
			CMPGetTime( pstatus->timerInitTable, &iSec, &iMSec );
			fprintf(
				pstatus->hfCompactStats,
				"%d\t%d\t%d\t%d\t%d\t%d\t%d.%d\t",
				pstatus->cTableFixedVarColumns,
				pstatus->cTableTaggedColumns,
				cColumns,
				pstatus->cSecondaryIndexes,
				pstatus->cTablePagesOwned,
				pstatus->cTablePagesAvail,
				iSec, iMSec );
			fflush( pstatus->hfCompactStats );
			CMPSetTime( &pstatus->timerCopyRecords );
			}
		}

	err = ErrSORTCopyRecords(
				ppib,
				pfucbSrc,
				pfucbDest,
				(CPCOL *)pcompactinfo->rgcolumnids,
				pcompactinfo->ccolSingleValue,
				0,
				&crowCopied,
				&recidLast,
				pcompactinfo->rgbBuf,
				mpcolumnidcolumnidTagged,
				pstatus );

	if ( err >= 0 )
		{
		//  copy the callbacks from one database to another
		err = ErrCATCopyCallbacks(
				ppib,
				pcompactinfo->ifmpSrc,
				pcompactinfo->ifmpDest, 
				pfucbSrc->u.pfcb->ObjidFDP(),
				pfucbDest->u.pfcb->ObjidFDP()
				);
		}
		
	if ( pstatus )
		{
		if ( pstatus->fDumpStats )
			{
			INT	iSec, iMSec;
			Assert( pstatus->hfCompactStats );
			CMPGetTime( pstatus->timerCopyRecords, &iSec, &iMSec );
			fprintf( pstatus->hfCompactStats,
					"%d\t%I64d\t%I64d\t%d\t%d\t%d.%d\t",
					crowCopied,
					pstatus->cbRawData,
					pstatus->cbRawDataLV,
					pstatus->cLeafPagesTraversed,
					pstatus->cLVPagesTraversed,
					iSec, iMSec );
			fflush( pstatus->hfCompactStats );
			}

		if ( err >= 0 || fGlobalRepair )
			{
			// Top off progress meter for this table.
			Assert( pstatus->cunitDone <= pstatus->cunitProjected );
			pstatus->cunitDone = pstatus->cunitProjected;
			ERR	errT = ErrCMPReportProgress( pstatus );
			if ( err >= 0 )
				err = errT;
			}
		}

HandleError:
	if ( pfucbNil != pfucbDest )
		{
		Assert( (JET_TABLEID)pfucbDest == tablecreate.tableid );
		CallS( ErrFILECloseTable( ppib, pfucbDest ) );
		}

	if ( mpcolumnidcolumnidTagged != NULL )
		{
		OSMemoryHeapFree( mpcolumnidcolumnidTagged );
		}

	if ( szTemplateTableName != NULL )
		{
		OSMemoryHeapFree( szTemplateTableName );
		}

	Assert( pfucbNil != pfucbSrc );
	CallS( ErrFILECloseTable( ppib, pfucbSrc ) );
	
	if ( pstatus  &&  pstatus->fDumpStats )
		{
		INT	iSec, iMSec;
		Assert( pstatus->hfCompactStats );
		CMPGetTime( pstatus->timerCopyTable, &iSec, &iMSec );
		fprintf( pstatus->hfCompactStats, "%d.%d\n", iSec, iMSec );
		fflush( pstatus->hfCompactStats );
		}

	return err;
	}


LOCAL ERR ErrCMPCopySelectedTables(
	COMPACTINFO	*pcompactinfo,
	FUCB		*pfucbCatalog,
	const BOOL	fCopyDerivedTablesOnly,
	BOOL		*pfEncounteredDerivedTable )
	{
	ERR			err;
	FCB			*pfcbCatalog	= pfucbCatalog->u.pfcb;
	DATA		dataField;
	BOOL		fLatched		= fFalse;
	CHAR		szTableName[JET_cbNameMost+1];

	Assert( pfcbNil != pfcbCatalog );
	Assert( pfcbCatalog->FTypeTable() );
	Assert( pfcbCatalog->FFixedDDL() );
	Assert( pfcbCatalog->PgnoFDP() == pgnoFDPMSO );

	err = ErrIsamMove( pcompactinfo->ppib, pfucbCatalog, JET_MoveFirst, NO_GRBIT );
	if ( err < 0 )
		{
		Assert( JET_errRecordNotFound != err );
		if ( JET_errNoCurrentRecord == err )
			err = ErrERRCheck( JET_errDatabaseCorrupted );	// MSysObjects shouldn't be empty.

		return err;
		}

	do
		{
		Assert( !Pcsr( pfucbCatalog )->FLatched() );
		Call( ErrDIRGet( pfucbCatalog ) );
		fLatched = fTrue;
		
		const DATA&	dataRec				= pfucbCatalog->kdfCurr.data;
		BOOL		fProceedWithCopy	= fTrue;
		ULONG		ulFlags;

		Assert( FFixedFid( fidMSO_Flags ) );
		Call( ErrRECIRetrieveFixedColumn(
						pfcbNil,
						pfucbCatalog->u.pfcb->Ptdb(),
						fidMSO_Flags,
						dataRec,
						&dataField ) );
		Assert( JET_errSuccess == err );
		Assert( dataField.Cb() == sizeof(ULONG) );
		UtilMemCpy( &ulFlags, dataField.Pv(), sizeof(ULONG) );

		if ( ulFlags & JET_bitObjectTableDerived )
			{
			if ( !fCopyDerivedTablesOnly )
				{
				//	Must defer derived tables to a second pass
				//	(in order to ensure that the base tables are
				//	created first).
				*pfEncounteredDerivedTable = fTrue;
				fProceedWithCopy = fFalse;
				}
			}
		else if ( fCopyDerivedTablesOnly )
			{
			// Only want derived tables.  If this isn't one, skip it.
			fProceedWithCopy = fFalse;
			}


		if ( fProceedWithCopy )
			{
			
#ifdef DEBUG
			//	verify this is a column
			Assert( FFixedFid( fidMSO_Type ) );
			Call( ErrRECIRetrieveFixedColumn(
						pfcbNil,
						pfucbCatalog->u.pfcb->Ptdb(),
						fidMSO_Type,
						dataRec,
						&dataField ) );
			Assert( JET_errSuccess == err );
			Assert( dataField.Cb() == sizeof(SYSOBJ) );
			Assert( sysobjTable == *( (UnalignedLittleEndian< SYSOBJ > *)dataField.Pv() ) );
#endif			

			Assert( FVarFid( fidMSO_Name ) );
			Call( ErrRECIRetrieveVarColumn(
							pfcbNil,
							pfucbCatalog->u.pfcb->Ptdb(),
							fidMSO_Name,
							dataRec,
							&dataField ) );
			Assert( JET_errSuccess == err );
			Assert( dataField.Cb() > 0 );
			Assert( dataField.Cb() <= JET_cbNameMost );
			UtilMemCpy( szTableName, dataField.Pv(), dataField.Cb() );
			szTableName[dataField.Cb()] = '\0';

			Assert( Pcsr( pfucbCatalog )->FLatched() );
			CallS( ErrDIRRelease( pfucbCatalog ) );
			fLatched = fFalse;
					
			if ( !FCATSystemTable( szTableName ) && !FOLDSystemTable( szTableName ) )
				{
				err = ErrCMPCopyTable( pcompactinfo, szTableName, ulFlags );
				if ( err < 0 && fGlobalRepair )
					{
					const CHAR	*szName		= szTableName;
					err = JET_errSuccess;
					UtilReportEvent(
						eventWarning,
						REPAIR_CATEGORY,
						REPAIR_BAD_TABLE,
						1,
						&szName );
					}
				Call( err );
				}
			}
		else
			{
			Assert( Pcsr( pfucbCatalog )->FLatched() );
			CallS( ErrDIRRelease( pfucbCatalog ) );
			fLatched = fFalse;
			}
			
		err = ErrIsamMove( pcompactinfo->ppib, pfucbCatalog, JET_MoveNext, NO_GRBIT );
		}
	while ( err >= 0 );
		
	if ( JET_errNoCurrentRecord == err )
		err = JET_errSuccess;

HandleError:
	if ( fLatched )
		{
		//	if still latched at this point, an error must have occurred
		Assert( err < 0 );
		CallS( ErrDIRRelease( pfucbCatalog ) );
		}
			
	Assert( !Pcsr( pfucbCatalog )->FLatched() );

	return err;
	}


#ifdef SLVDEFRAG_HACK


LOCAL ERR ErrCMPCopySLVOwnerMapObjidFid(
	PIB			* const ppib,
	FCB			* const pfcbSrc,
	FCB			* const pfcbDest,
	SLVOWNERMAP	* const pnodeSrc,
	SLVOWNERMAP	* const pnodeDest )
	{
	ERR	 		err 		= JET_errSuccess;
	char 		szTableName[JET_cbNameMost + 1];
	char 		szColumnName[JET_cbNameMost + 1];

	memcpy( pnodeDest, pnodeSrc, sizeof(SLVOWNERMAP) );

	Call( ErrCATGetObjectNameFromObjid(
				ppib,
				pfcbSrc->Ifmp(),
				pnodeSrc->Objid(),
				sysobjTable,
				pnodeSrc->Objid(),
				szTableName,
				sizeof(szTableName) ) );

	{
	OBJID objid = pnodeDest->Objid();
	Call( ErrCATSeekTable( ppib, pfcbDest->Ifmp(), szTableName, NULL, &objid ) );
	pnodeDest->SetObjid( objid );
	}

	//	UNDONE: I think this will fail if this is a derived table and the SLV column is in the template.
	Enforce( !FCOLUMNIDTemplateColumn( pnodeSrc->Columnid() ) );
	Call( ErrCATGetObjectNameFromObjid(
				ppib,
				pfcbSrc->Ifmp(),
				pnodeSrc->Objid(),
				sysobjColumn,
				pnodeSrc->Columnid(),
				szColumnName,
				sizeof(szColumnName) ) );

	JET_COLUMNDEF columndefDest;
	
	Call( ErrIsamGetColumnInfo(
				(JET_SESID)ppib,
				(JET_DBID)pfcbDest->Ifmp(),
				szTableName,
				szColumnName,
				NULL,
				&columndefDest,
				sizeof(columndefDest),
				JET_ColInfo ) );

	pnodeDest->SetColumnid( columndefDest.columnid );
		
HandleError:
	return err;
}

LOCAL ERR ErrCMPCopySLVTree( PIB *ppib, FCB *pfcbSrc, FCB *pfcbDest )
	{
	ERR		err;
	FUCB	*pfucbSrc	= pfucbNil;
	FUCB	*pfucbDest	= pfucbNil;
	DIB		dib;
	KEY		key;
	DATA	data;
	PGNO	pgnoT;
	BYTE	rgbKey[sizeof(PGNO)];
	BYTE	rgbData[ max ( sizeof(SLVSPACENODE), sizeof(SLVOWNERMAP) ) ];

	const BOOL 		fCopySLVAvailTree 	= pfcbSrc->FTypeSLVAvail();

	Assert ( pfcbSrc->FTypeSLVAvail() || pfcbSrc->FTypeSLVOwnerMap() );
	Assert ( pfcbDest->FTypeSLVAvail() || pfcbDest->FTypeSLVOwnerMap() );
	Assert ( ( pfcbSrc->FTypeSLVAvail() && pfcbDest->FTypeSLVAvail() )
			|| ( pfcbSrc->FTypeSLVOwnerMap() && pfcbDest->FTypeSLVOwnerMap() ) );


	key.prefix.Nullify();
	key.suffix.SetCb( sizeof(PGNO) );
	key.suffix.SetPv( rgbKey );
	
	data.SetPv( rgbData );

	Assert( pfcbNil != pfcbSrc );
	Assert( pfcbNil != pfcbDest );

	Call( ErrDIROpen( ppib, pfcbSrc, &pfucbSrc ) );
	Call( ErrDIROpen( ppib, pfcbDest, &pfucbDest ) );

	dib.dirflag = fDIRNull;
	dib.pos = posFirst;
	dib.pbm = NULL;
	
	//	first, delete all nodes from dest tree
	err = ErrBTDown( pfucbDest, &dib, latchReadNoTouch );
	if ( JET_errRecordNotFound != err )
		{
		Assert( JET_errNoCurrentRecord != err );

		do
			{
			Call( err );
			Call( ErrBTFlagDelete( pfucbDest, fDIRNoVersion ) );
			Pcsr( pfucbDest )->Downgrade( latchReadTouch );
			err = ErrBTNext( pfucbDest, fDIRNull );
			}
		while ( JET_errNoCurrentRecord != err );
		}
	BTUp( pfucbDest );

	//	now copy all nodes from src
	err = ErrBTDown( pfucbSrc, &dib, latchReadNoTouch );
	if ( JET_errRecordNotFound != err )
		{
		OBJID 	objidTableSrc 		= objidNil;

		Assert( JET_errNoCurrentRecord != err );
		do
			{
			BOOL fObjectDeleted = fFalse; // table or column deleted so we need to mark the space as empty
			
			Call( err );

			Assert( sizeof(PGNO) == pfucbSrc->kdfCurr.key.Cb() );
			LongFromKey( &pgnoT, pfucbSrc->kdfCurr.key );
			KeyFromLong( rgbKey, pgnoT );
			Assert( sizeof(PGNO) == key.Cb() );
			
			Assert ( pfucbSrc->kdfCurr.data.Cb() <= sizeof(rgbData) );
			
			if ( fCopySLVAvailTree )
				{
				Assert( sizeof(SLVSPACENODE) == pfucbSrc->kdfCurr.data.Cb() );
				}
			else
				{
				Assert( SLVOWNERMAP::FValidData( pfucbSrc->kdfCurr.data ) );
				
				// m_objid must be first in structure and persistent in the node 
				objidTableSrc = *( (UnalignedLittleEndian< OBJID >*)pfucbSrc->kdfCurr.data.Pv() );
				}

			SLVOWNERMAP	nodeSrc;
			if (!fCopySLVAvailTree)
				{
				nodeSrc.Retrieve( pfucbSrc->kdfCurr.data );
				nodeSrc.CopyInto( data );
				}
			else
				{
				memcpy( rgbData, pfucbSrc->kdfCurr.data.Pv(), pfucbSrc->kdfCurr.data.Cb() );
				data.SetCb( pfucbSrc->kdfCurr.data.Cb() );
				}
				
			Call( ErrBTRelease( pfucbSrc ) );
				
			if ( !fCopySLVAvailTree && objidNil != objidTableSrc )
				{
				SLVOWNERMAP	nodeDest;
				err = ErrCMPCopySLVOwnerMapObjidFid( ppib, pfcbSrc, pfcbDest, &nodeSrc, &nodeDest );

				if ( err == JET_errColumnNotFound || err == JET_errObjectNotFound )
					{
					// we have to clean the page in SLVAvail and SLVOwnerMap
					// we insert the same node and after that we call ErrSLVDeleteCommittedRange that will clean SLVAvial and
					// will update the node from SLVOwnerMap just inserted
					fObjectDeleted = fTrue;
					err = JET_errSuccess;
					}
				Call ( err );

				nodeDest.CopyInto( data );
				}
				
			Call( ErrBTInsert( pfucbDest, key, data, fDIRNoVersion ) );
			BTUp( pfucbDest ); 

			if ( fObjectDeleted )
				{
				Call( ErrSLVDeleteCommittedRange(	ppib,
													pfcbDest->Ifmp(),
													OffsetOfPgno( pgnoT ),
													SLVPAGE_SIZE,
													CSLVInfo::fileidNil,
													0,
													L"" ) );
				}
			
			err = ErrBTNext( pfucbSrc, fDIRNull );
			}
		while ( JET_errNoCurrentRecord != err );
		}

	err = JET_errSuccess;

HandleError:
	if ( pfucbNil != pfucbDest )
		DIRClose( pfucbDest );
	if ( pfucbNil != pfucbSrc )
		DIRClose( pfucbSrc );

	return err;
	}
#endif


INLINE ERR ErrCMPCopyTables( COMPACTINFO *pcompactinfo )
	{
	ERR		err;
	FUCB	*pfucbCatalog	= pfucbNil;
	BOOL	fDerivedTables	= fFalse;

	CallR( ErrCATOpen( pcompactinfo->ppib, pcompactinfo->ifmpSrc, &pfucbCatalog ) );
	Assert( pfucbNil != pfucbCatalog );

	Call( ErrIsamSetCurrentIndex( pcompactinfo->ppib, pfucbCatalog, szMSORootObjectsIndex ) );

	fDerivedTables = fFalse;
	Call( ErrCMPCopySelectedTables(
				pcompactinfo,
				pfucbCatalog,
				fFalse,
				&fDerivedTables ) );

	if ( fDerivedTables )		// Process derived tables on second pass.
		{
		Call( ErrCMPCopySelectedTables(
					pcompactinfo,
					pfucbCatalog,
					fTrue,
					NULL ) );
		}

	Call( ErrCATClose( pcompactinfo->ppib, pfucbCatalog ) );
	pfucbCatalog = pfucbNil;

#ifdef SLVDEFRAG_HACK
	if ( !rgfmp[pcompactinfo->ifmpDest].FDefragSLVCopy() && 
		rgfmp[pcompactinfo->ifmpSrc].FSLVAttached() )
		{
		CHAR		szSLVPath[IFileSystemAPI::cchPathMax];
		SLVFILEHDR	*pslvfilehdr;

		Call( ErrCMPCopySLVTree(
					pcompactinfo->ppib,
					rgfmp[pcompactinfo->ifmpSrc].PfcbSLVAvail(),
					rgfmp[pcompactinfo->ifmpDest].PfcbSLVAvail() ) );

		// copy also the OwnerMap tree
		Assert ( pfcbNil != rgfmp[pcompactinfo->ifmpSrc].PfcbSLVOwnerMap() );
		Assert ( pfcbNil != rgfmp[pcompactinfo->ifmpDest].PfcbSLVOwnerMap() );
		Call ( ErrCMPCopySLVTree(
					pcompactinfo->ppib,
					rgfmp[pcompactinfo->ifmpSrc].PfcbSLVOwnerMap(),
					rgfmp[pcompactinfo->ifmpDest].PfcbSLVOwnerMap() ) );		

		Assert( rgfmp[pcompactinfo->ifmpDest].FSLVAttached() );

		Assert( NULL != rgfmp[pcompactinfo->ifmpSrc].SzSLVName() );
		strcpy( szSLVPath, rgfmp[pcompactinfo->ifmpSrc].SzSLVName() );

		pslvfilehdr = (SLVFILEHDR *)PvOSMemoryPageAlloc( g_cbPage, NULL );
		if ( NULL == pslvfilehdr )
			{
			err = ErrERRCheck( JET_errOutOfMemory );
			goto HandleError;
			}

		SLVClose( pcompactinfo->ifmpSrc );
		
        err = ErrUtilReadAndFixShadowedHeader(
        				PinstFromPpib( pcompactinfo->ppib )->m_pfsapi,
        				( const _TCHAR* ) szSLVPath,
        				( BYTE * ) pslvfilehdr,
        				( unsigned long ) g_cbPage,
        				(const unsigned long) (OffsetOf( SLVFILEHDR, le_cbPageSize )) );
		if ( err >= 0 )
			{
			Assert( rgfmp[pcompactinfo->ifmpDest].Pdbfilehdr()->FSLVExists() );
			rgfmp[pcompactinfo->ifmpDest].Pdbfilehdr()->SetSLVExists();
			memcpy( &rgfmp[pcompactinfo->ifmpDest].Pdbfilehdr()->signSLV, &pslvfilehdr->signSLV, sizeof(SIGNATURE) );

			// terrible hack: replace one SLV file's header with other 
			SLVSoftSyncHeaderSLVDB( pslvfilehdr, rgfmp[pcompactinfo->ifmpDest].Pdbfilehdr() );
			err = ErrUtilWriteShadowedHeader(	PinstFromPpib( pcompactinfo->ppib )->m_pfsapi, 
												rgfmp[pcompactinfo->ifmpDest].SzSLVName(), 
												fFalse,
												(BYTE *)pslvfilehdr, 
												g_cbPage,
												rgfmp[pcompactinfo->ifmpDest].PfapiSLV() );
			ERR errT;
			errT = ErrUtilWriteShadowedHeader(	PinstFromPpib( pcompactinfo->ppib )->m_pfsapi, 
												szSLVPath, 
												fFalse,
												(BYTE *)pslvfilehdr, 
												g_cbPage );
			if ( err >= 0 )
				{
				err = errT; 
				}
			}
		
		Assert( NULL != pslvfilehdr );
		OSMemoryPageFree( (VOID *)pslvfilehdr );

		Call( err );
		}
#endif // SLVDEFRAG_HACK

HandleError:
	if (pfucbNil != pfucbCatalog)
		{
		CallS( ErrCATClose( pcompactinfo->ppib, pfucbCatalog ) );
		pfucbCatalog = pfucbNil;
		}

	return err;
	}


INLINE ERR ErrCMPCloseDB( COMPACTINFO *pcompactinfo, ERR err )
	{
	ERR		errCloseSrc;
	ERR		errCloseDest;
	PIB		*ppib = pcompactinfo->ppib;

	errCloseSrc = ErrDBCloseDatabase( ppib, pcompactinfo->ifmpSrc, NO_GRBIT );
	errCloseDest = ErrDBCloseDatabase( ppib, pcompactinfo->ifmpDest, NO_GRBIT );

	if ( err >= 0 )
		{
		if ( errCloseSrc < 0 )
			err = errCloseSrc;
		else if ( errCloseDest < 0 )
			err = errCloseDest;
		}
		
	return err;
	}


ERR ISAMAPI ErrIsamCompact(
	JET_SESID		sesid,
	const CHAR		*szDatabaseSrc,
	IFileSystemAPI	*pfsapiDest,
	const CHAR		*szDatabaseDest,
	const CHAR		*szDatabaseSLVDest,
	JET_PFNSTATUS	pfnStatus,
	JET_CONVERT		*pconvert,
	JET_GRBIT		grbit )
	{
	ERR				err					= JET_errSuccess;
	COMPACTINFO		*pcompactinfo		= NULL;
	BOOL			fDatabasesOpened	= fFalse;
	BOOL			fGlobalRepairSave	= fGlobalRepair;

#ifdef RTM
#else
	CMEMLIST::UnitTest();
#endif	//	!RTM

	if ( pconvert )
		{
		//	convert was ripped out in ESE98
		return ErrERRCheck( JET_errFeatureNotAvailable );
		}

	pcompactinfo = (COMPACTINFO *)PvOSMemoryHeapAlloc( sizeof( COMPACTINFO ) );
	if ( !pcompactinfo )
		{
		return ErrERRCheck( JET_errOutOfMemory );
		}
	memset( pcompactinfo, 0, sizeof( COMPACTINFO ) );
	
 	pcompactinfo->ppib = reinterpret_cast<PIB *>( sesid );
 	if ( pcompactinfo->ppib->level > 0 )
 		{
 		Error( ErrERRCheck( JET_errInTransaction ), Cleanup );
 		}

	fGlobalRepair = grbit & JET_bitCompactRepair;

	if ( NULL != pfnStatus )
		{
		pcompactinfo->pstatus = (STATUSINFO *)PvOSMemoryHeapAlloc( sizeof(STATUSINFO) );
		if ( pcompactinfo->pstatus == NULL )
			{
			Error( ErrERRCheck( JET_errOutOfMemory ), Cleanup );
			}

		memset( pcompactinfo->pstatus, 0, sizeof(STATUSINFO) );

		pcompactinfo->pstatus->sesid = sesid;
		pcompactinfo->pstatus->pfnStatus = pfnStatus;
		
		if ( fGlobalRepair )
			pcompactinfo->pstatus->snp = JET_snpRepair;
		else
			pcompactinfo->pstatus->snp = JET_snpCompact;

		Call( ErrCMPInitProgress(
					pcompactinfo->pstatus,
					szDatabaseSrc,
					szCompactAction,
					( grbit & JET_bitCompactStats ) ? szCompactStatsFile : NULL ) );
		}

	else
		{
		pcompactinfo->pstatus = NULL;
		}

	/* Open and create the databases */
	Call( ErrCMPOpenDB( pcompactinfo, szDatabaseSrc, pfsapiDest, szDatabaseDest, szDatabaseSLVDest ) );
	if ( grbit & JET_bitCompactSLVCopy )
		{
		rgfmp[ pcompactinfo->ifmpDest ].SetDefragSLVCopy();
		}
	else
		{
		rgfmp[ pcompactinfo->ifmpDest ].ResetDefragSLVCopy();
		}
	fDatabasesOpened = fTrue;

	if ( NULL != pfnStatus )
		{
		Assert( pcompactinfo->pstatus );

		/* Init status meter.  We'll be tracking status by pages processed, */
		err = ErrIsamGetDatabaseInfo(
					sesid,
					(JET_DBID) pcompactinfo->ifmpSrc,
					&pcompactinfo->pstatus->cDBPagesOwned,
					sizeof(pcompactinfo->pstatus->cDBPagesOwned),
					JET_DbInfoSpaceOwned );
		if ( err < 0 )
			{
			if ( fGlobalRepair )
				{
				// Set to default value.
				pcompactinfo->pstatus->cDBPagesOwned = cpgDatabaseMin;
				}
			else
				{
				goto HandleError;
				}
			}
			
		err = ErrIsamGetDatabaseInfo(
					sesid,
					(JET_DBID) pcompactinfo->ifmpSrc,
					&pcompactinfo->pstatus->cDBPagesAvail,
					sizeof(pcompactinfo->pstatus->cDBPagesAvail),
					JET_DbInfoSpaceAvailable );
		if ( err < 0 )
			{
			if ( fGlobalRepair )
				{
				// Set to default value.
				pcompactinfo->pstatus->cDBPagesAvail = 0;
				}
			else
				goto HandleError;
			}

		// Don't count unused space in the database;
		Assert( pcompactinfo->pstatus->cDBPagesOwned >= cpgDatabaseMin );
		Assert( pcompactinfo->pstatus->cDBPagesAvail < pcompactinfo->pstatus->cDBPagesOwned );
		pcompactinfo->pstatus->cunitTotal = 
			pcompactinfo->pstatus->cDBPagesOwned - pcompactinfo->pstatus->cDBPagesAvail;

		// Approximate the number of pages used by MSysObjects
		pcompactinfo->pstatus->cunitDone = cpgMSOInitial;
		Assert( pcompactinfo->pstatus->cunitDone <= pcompactinfo->pstatus->cunitTotal );
		pcompactinfo->pstatus->cunitProjected = pcompactinfo->pstatus->cunitTotal;

		Call( ErrCMPReportProgress( pcompactinfo->pstatus ) );

		if ( pcompactinfo->pstatus->fDumpStats )
			{
			INT iSec, iMSec;

			Assert( pcompactinfo->pstatus->hfCompactStats );
			CMPGetTime( pcompactinfo->pstatus->timerInitDB, &iSec, &iMSec );
			fprintf(
				pcompactinfo->pstatus->hfCompactStats,
				"\nNew database created and initialized in %d.%d seconds.\n",
				iSec, iMSec );
				
			fprintf(
				pcompactinfo->pstatus->hfCompactStats,
				"    (Source database is %I64d bytes and it owns %d pages, of which %d are available.)\n",
				QWORD( pcompactinfo->pstatus->cDBPagesOwned + cpgDBReserved ) * g_cbPage,
				pcompactinfo->pstatus->cDBPagesOwned,
				pcompactinfo->pstatus->cDBPagesAvail );
			fprintf(
				pcompactinfo->pstatus->hfCompactStats,
				"\n\n%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\t%s\n\n",
				szCMPSTATSTableName,
				szCMPSTATSFixedVarCols,
				szCMPSTATSTaggedCols,
				szCMPSTATSColumns,
				szCMPSTATSSecondaryIdx,
				szCMPSTATSPagesOwned,
				szCMPSTATSPagesAvail,
				szCMPSTATSInitTime,
				szCMPSTATSRecordsCopied,
				szCMPSTATSRawData,
				szCMPSTATSRawDataLV,
				szCMPSTATSLeafPages,
				szCMPSTATSMinLVPages,
				szCMPSTATSRecordsTime,
				szCMPSTATSTableTime );
			fflush( pcompactinfo->pstatus->hfCompactStats );
			}
		}


	/* Create and copy all non-container objects */

	Call( ErrCMPCopyTables( pcompactinfo ) );

	if ( pfnStatus )
		{
		Assert( pcompactinfo->pstatus );
		Assert( pcompactinfo->pstatus->cunitDone <= pcompactinfo->pstatus->cunitTotal );
		if ( pcompactinfo->pstatus->fDumpStats )
			{
			fprintf(
				pcompactinfo->pstatus->hfCompactStats,
				"\nDatabase defragmented to %I64d bytes.\n",
				rgfmp[pcompactinfo->ifmpDest].CbTrueFileSize() );
				
			INST *pinst = PinstFromPpib( (PIB *) sesid );
			fprintf(
				pcompactinfo->pstatus->hfCompactStats,
				"Temp. database used %I64d bytes during defragmentation.\n",
				rgfmp[pinst->m_mpdbidifmp[dbidTemp]].CbTrueFileSize() );
			fflush( pcompactinfo->pstatus->hfCompactStats );
			}
		}

		

HandleError:
	if ( fDatabasesOpened )
		{
		err = ErrCMPCloseDB( pcompactinfo, err );
		
		ERR	errT = ErrIsamDetachDatabase( sesid, pfsapiDest, szDatabaseDest );
		if ( errT < 0 && err >= 0 )
			err = errT;
		}

	if ( NULL != pfnStatus )		// top off status meter
		{
		Assert( pcompactinfo->pstatus );

		err = ErrCMPTermProgress( pcompactinfo->pstatus, szCompactAction, err );
		}

Cleanup:
	if ( pcompactinfo->pstatus )
		{
		OSMemoryHeapFree( pcompactinfo->pstatus );
		}

	OSMemoryHeapFree( pcompactinfo );

	fGlobalRepair = fGlobalRepairSave;
	return err;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ese98\src\ese\callback.cxx ===
#include "std.hxx"

//  store an array of all the librarys we have open, close them at termination
//  we assume there will be a very small number of callback DLLs used so a relatively
//  poor memory allocation scheme is used

LOCAL const CHAR chSep 				= '!';	//  callbacks are of the form DLL!Function

struct LIBRARYMAP
	{
	char * 	szLibrary;
	LIBRARY	library;
	};

LOCAL INT			clibrary		= 0;
LOCAL LIBRARYMAP * 	rglibrarymap 	= NULL;

LOCAL CCriticalSection critCallback( CLockBasicInfo( CSyncBasicInfo( szCritCallbacks ), rankCallbacks, 0 ) );


//  ================================================================
ERR ErrCALLBACKInit()
//  ================================================================
	{
	clibrary = 0;
	rglibrarymap = NULL;
	return JET_errSuccess;
	}


//  ================================================================
VOID CALLBACKTerm()
//  ================================================================
//
//  Close all the module handles
//
//-
	{
	INT ilibrary;
	for( ilibrary = 0; ilibrary < clibrary; ++ilibrary )
		{
		UtilFreeLibrary( rglibrarymap[ilibrary].library );
		OSMemoryHeapFree( rglibrarymap[ilibrary].szLibrary );
		}
	OSMemoryHeapFree( rglibrarymap );
	}


//  ================================================================
LOCAL BOOL FCALLBACKISearchForLibrary( const char * const szLibrary, LIBRARY * plibrary )
//  ================================================================
	{
	//  see if the library is already loaded
	INT ilibrary;
	for( ilibrary = 0; ilibrary < clibrary; ++ilibrary )
		{
		if( 0 == _stricmp( szLibrary, rglibrarymap[ilibrary].szLibrary ) )
			{
			// this library is already loaded
			*plibrary = rglibrarymap[ilibrary].library;		
			return fTrue;
			}
		}
	return fFalse;
	}


//  ================================================================
ERR ErrCALLBACKResolve( const CHAR * const szCallback, JET_CALLBACK * pcallback )
//  ================================================================
	{	
	JET_ERR err = JET_errSuccess;
	Assert( pcallback );

	CHAR szCallbackT[JET_cbColumnMost+1+3];
	Assert( strlen( szCallback ) < sizeof( szCallbackT ) );

	ENTERCRITICALSECTION entercritcallback( &critCallback );

	strncpy( szCallbackT, szCallback, sizeof( szCallbackT ) );
	const CHAR * const szLibrary = szCallbackT;
	CHAR * const pchSep = strchr( szCallbackT, chSep );
	CHAR * const szFunction = pchSep + 1;
	if( NULL == pchSep )
		{
		err = ErrERRCheck( JET_errInvalidParameter );
		goto HandleError;
		}
	*pchSep = 0;

	LIBRARY library;
	
	if( !FCALLBACKISearchForLibrary( szLibrary, &library ) )
		{
		if( FUtilLoadLibrary( szLibrary, &library, fGlobalEseutil ) )
			{
			//  we were able to load the library. allocate a new rglibrary array
			//  swap the arrays so that threads not in the critical section can continue
			//  to traverse the array
			const INT clibraryT = clibrary + 1;
			LIBRARYMAP * const rglibrarymapOld = rglibrarymap;
			
			LIBRARYMAP * const rglibrarymapNew = (LIBRARYMAP *)PvOSMemoryHeapAlloc( clibraryT * sizeof( LIBRARYMAP ) );
			CHAR * const szLibraryT = (CHAR *)PvOSMemoryHeapAlloc( strlen( szLibrary ) + 1 );
			if( NULL == rglibrarymapNew
				|| NULL == szLibraryT )
				{
				if( NULL != rglibrarymapNew )
					{
					OSMemoryHeapFree( rglibrarymapNew );
					}
				UtilFreeLibrary( library );
				Call( ErrERRCheck( JET_errOutOfMemory ) );
				}
				
			strcpy( szLibraryT, szLibrary );
			memcpy( rglibrarymapNew, rglibrarymapOld, clibrary * sizeof( LIBRARYMAP ) );
			rglibrarymapNew[clibrary].szLibrary = szLibraryT;
			rglibrarymapNew[clibrary].library = library;
			
			Assert( rglibrarymapOld == rglibrarymap );
			Assert( clibraryT - 1 == clibrary );
			rglibrarymap = rglibrarymapNew;
			clibrary = clibraryT;
			if( NULL != rglibrarymapOld )
				{
				OSMemoryHeapFree( rglibrarymapOld );
				}
			}
		else
			{
			//  log the fact that we couldn't find the callback
			const CHAR *rgszT[1];
			rgszT[0] = szLibrary;
			UtilReportEvent( eventError, GENERAL_CATEGORY, FILE_NOT_FOUND_ERROR_ID, 1, rgszT );
			Call( ErrERRCheck( JET_errCallbackNotResolved ) );
			}
		}

	//  we now have the library
	*pcallback = (JET_CALLBACK)PfnUtilGetProcAddress( library, szFunction );
	if( NULL == *pcallback )
		{
		strcat( szFunction, "@32" );
		*pcallback = (JET_CALLBACK)PfnUtilGetProcAddress( library, szFunction );
		if( NULL == *pcallback )
			{	
			const CHAR *rgszT[2];
			rgszT[0] = szFunction;
			rgszT[1] = szLibrary;
			UtilReportEvent( eventError, GENERAL_CATEGORY, FUNCTION_NOT_FOUND_ERROR_ID, 2, rgszT );		
			Call( ErrERRCheck( JET_errCallbackNotResolved ) );
			}
		}

HandleError:
	return err;
	}


ERR VTAPI ErrIsamSetLS(
	JET_SESID		sesid,
	JET_VTID		vtid,
	JET_LS			ls,
	JET_GRBIT		grbit )
	{
	ERR				err;
 	PIB				*ppib		= reinterpret_cast<PIB *>( sesid );
	FUCB			*pfucb		= reinterpret_cast<FUCB *>( vtid );
	const BOOL		fReset		= ( grbit & JET_bitLSReset );
	const LSTORE	lsT			= ( fReset ? JET_LSNil : ls );

	CallR( ErrPIBCheck( ppib ) );
	CheckFUCB( ppib, pfucb );
	AssertDIRNoLatch( ppib );

	if ( NULL == PinstFromPpib( ppib )->m_pfnRuntimeCallback )
		{
		return ErrERRCheck( JET_errLSCallbackNotSpecified );
		}

	if ( grbit & JET_bitLSTable )
		{
		if ( grbit & JET_bitLSCursor )
			{
			err = ErrERRCheck( JET_errInvalidGrbit );
			}
		else
			{
			err = pfucb->u.pfcb->ErrSetLS( lsT );
			}
		}
	else
		{
		err = ErrSetLS( pfucb, lsT );
		}

	return err;
	}

ERR VTAPI ErrIsamGetLS(
	JET_SESID		sesid,
	JET_VTID		vtid,
	JET_LS			*pls,
	JET_GRBIT		grbit )
	{
	ERR				err;
 	PIB				*ppib		= reinterpret_cast<PIB *>( sesid );
	FUCB			*pfucb		= reinterpret_cast<FUCB *>( vtid );
	const BOOL		fReset		= ( grbit & JET_bitLSReset );

	CallR( ErrPIBCheck( ppib ) );
	CheckFUCB( ppib, pfucb );
	AssertDIRNoLatch( ppib );

	if ( grbit & JET_bitLSTable )
		{
		if ( grbit & JET_bitLSCursor )
			{
			err = ErrERRCheck( JET_errInvalidGrbit );
			}
		else
			{
			err = pfucb->u.pfcb->ErrGetLS( pls, fReset );
			}
		}
	else
		{
		err = ErrGetLS( pfucb, pls, fReset );
		}

	//	if successfully able to retrieve LS, there must be an associated callback
	Assert( err < 0 || NULL != PinstFromPpib( ppib )->m_pfnRuntimeCallback );

	return err;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ese98\src\ese\db.cxx ===
#include "std.hxx"

#ifdef DEBUG
///#define FORCE_ONLINE_SLV_DEFRAG
///#define FORCE_ONLINE_DEFRAG
#else
///#define FORCE_ONLINE_SLV_DEFRAG
///#define FORCE_ONLINE_DEFRAG
#endif	//	!DEBUG

//
// this function will return one of the followings:
//		JET_errDatabase200Format
//		JET_errDatabase400Format
//		JET_errDatabaseCorrupted
//

LOCAL ERR ErrDBICheck200And400( IFileSystemAPI *const pfsapi, CHAR *szDatabaseName )
	{
	/* persistent database data, in database root node
	/**/
#include <pshpack1.h>

	//	Structures copied from JET200/JET400

	typedef ULONG SRID;

	typedef struct _database_data
		{
		ULONG	ulMagic;
		ULONG	ulVersion;
		ULONG	ulDBTime;
		USHORT	usFlags;
		} P_DATABASE_DATA;

	typedef BYTE	PGTYP;

	typedef struct _threebytes { BYTE b[3]; } THREEBYTES;

	typedef struct _pghdr
		{
		ULONG		ulChecksum;	  		//	checksum of page, always 1st byte
		ULONG		ulDBTime;	  		//	database time page dirtied
		PGNO		pgnoFDP;	  		//	pgno of FDP which owns this page
		SHORT		cbFree;  			//	count free bytes
		SHORT		ibMic;	  			//	minimum used byte
		SHORT		ctagMac; 	  		//	count tags used
		SHORT		itagFree;	  		//	itag of first free tag
		SHORT		cbUncommittedFreed;	//	bytes freed from this page, but *possibly*
										//	  uncommitted (this number will always be
										//	  a subset of cbFree)
		THREEBYTES	pgnoPrev;	  		//	pgno of previous page
		THREEBYTES	pgnoNext;	  		//	pgno of next page
		} PGHDR;

	typedef struct _pgtrlr
		{
		PGTYP	   	pgtyp;
		THREEBYTES 	pgnoThisPage;
		} PGTRLR;

	typedef struct _tag
		{
		SHORT		cb;
		SHORT		ib;
		} TAG;

	typedef struct _page
		{
		PGHDR	   	pghdr;
		TAG  	   	rgtag[1];
		BYTE	   	rgbFiller[ cbPageOld -
						sizeof(PGHDR) -			// pghdr
						sizeof(TAG) -			// rgtag[1]
						sizeof(BYTE) -			// rgbData[1]
						sizeof(PGTYP) -			// pgtyp
						sizeof(THREEBYTES) ];	// pgnoThisPage
		BYTE	   	rgbData[1];
		PGTYP	   	pgtyp;
		THREEBYTES	pgnoThisPage;
		} PAGE;

#include <poppack.h>

#define IbCbFromPtag( ibP, cbP, ptagP )							\
			{	TAG *_ptagT = ptagP;					 		\
			(ibP) = _ptagT->ib;							 		\
			(cbP) = _ptagT->cb;							 		\
			}

	//	node header bits
#define fNDVersion		  		0x80
#define fNDDeleted		  		0x40
#define fNDBackLink		  		0x20
#define fNDFDPPtr				0x10
#define fNDSon					0x08
#define fNDVisibleSon	  		0x04
#define fNDFirstItem  	  		0x02
#define fNDLastItem	  	  		0x01

#define	FNDVisibleSons(b)		( (b) & fNDVisibleSon )
#define	FNDInvisibleSons(b) 	( !( (b) & fNDVisibleSon ) )
#define CbNDKey(pb)				( *( (pb) + 1 ) )
#define	FNDNullSon(b)	 		( !( (b) & fNDSon ) )
#define PbNDSonTable(pb)	  		( (pb) + 1 + 1 + *(pb + 1) )
#define PbNDBackLink(pb)											\
	( PbNDSonTable(pb) + ( FNDNullSon( *(pb) ) ? 0 :				\
	( ( ( *PbNDSonTable(pb) == 1 ) && FNDInvisibleSons( *(pb) ) ) ?	\
	sizeof(PGNO) + 1 : *PbNDSonTable(pb) + 1 ) ) )
#define	FNDBackLink(b)	 		( (b) & fNDBackLink )
#define PbNDData(pb) ( PbNDBackLink(pb) + ( FNDBackLink( *(pb) ) ? sizeof(SRID) : 0 ) )

	ERR	  			err = JET_errSuccess;
	PAGE   			*ppage;
	INT	  			ibTag;
	INT	  			cbTag;
	BYTE  			*pb;
	ULONG			ulVersion;
	IFileAPI	*pfapi;

	CallR( pfsapi->ErrFileOpen( szDatabaseName, &pfapi, fTrue ) );
	if ( ( ppage = (PAGE *)PvOSMemoryPageAlloc( cbPageOld, NULL ) ) == NULL )
		{
		err = ErrERRCheck( JET_errOutOfMemory );
		goto HandleError;
		}

	err = pfapi->ErrIORead( QWORD( 0 ), cbPageOld, (BYTE* const)ppage );
	
	/*	since file exists and we are unable to read data,
	/*	it may not be a system.mdb 
	/**/
	if ( err == JET_errDiskIO )
		err = ErrERRCheck( JET_errDatabaseCorrupted );

	Call( err );
	
	IbCbFromPtag(ibTag, cbTag, &ppage->rgtag[0]);
	if ( ibTag < (BYTE*)&ppage->rgtag[1] - (BYTE*)ppage ||
		(BYTE*)ppage + ibTag + cbTag >= (BYTE*)(ppage + 1) )
		{
		err = ErrERRCheck( JET_errDatabaseCorrupted );
		goto HandleError;
		}

	/*	at least FILES, OWNEXT, AVAILEXT
	/**/
	pb = (BYTE *)ppage + ibTag;
	if ( !FNDVisibleSons( *pb ) || CbNDKey( pb ) != 0 || FNDNullSon( *pb ) )
		{
		err = ErrERRCheck( JET_errDatabaseCorrupted );
		goto HandleError;
		}

	/*	check data length
	/**/
	INT cb;
	cb = (INT)( cbTag - ( PbNDData( pb ) - pb ) );
	if ( cb != sizeof(P_DATABASE_DATA) )
		{
		err = ErrERRCheck( JET_errDatabaseCorrupted );
		goto HandleError;
		}

	/*	check database version, for 200 ulVersion should be 1, for 400 ulVersion is 0x400.
	/**/
	ulVersion = ((P_DATABASE_DATA *)PbNDData(pb))->ulVersion;
	if ( ulDAEVersion200 == ulVersion )
		err = ErrERRCheck( JET_errDatabase200Format );
	else if ( ulDAEVersion400 == ulVersion )
		err = ErrERRCheck( JET_errDatabase400Format );
	else
		err = ErrERRCheck( JET_errDatabaseCorrupted );

HandleError:
	if ( ppage != NULL )
		OSMemoryPageFree( (VOID *)ppage );

	delete pfapi;
	return err;
	}


//+local
//	ErrDBInitDatabase
//	========================================================================
//	ErrDBInitDatabase( PIB *ppib, IFMP ifmp, CPG cpgPrimary )
//
//	Initializes database structure.  Structure is customized for
//	system, temporary and user databases which are identified by
//	the ifmp.  Primary extent is set to cpgPrimary but no allocation
//	is performed.  The effect of this routine can be entirely
//	represented with page operations.
//
//	PARAMETERS	ppib			ppib of database creator
//		  		ifmp			ifmp of created database
//		  		cpgPrimary 		number of pages to show in primary extent
//
//	RETURNS		JET_errSuccess or error returned from called routine.
//-
LOCAL ERR ErrDBInitDatabase( PIB *ppib, IFMP ifmp, CPG cpgPrimary )
	{
	ERR				err;
	OBJID			objidFDP;

	CallR( ErrDIRBeginTransaction( ppib, NO_GRBIT ) );

	//	set up root page
	//
	Call( ErrSPCreate(
				ppib,
				ifmp,
				pgnoNull,
				pgnoSystemRoot,
				cpgPrimary,
				fSPMultipleExtent,
				(ULONG)CPAGE::fPagePrimary,
				&objidFDP ) );
	Assert( objidSystemRoot == objidFDP );
	
	Call( ErrDIRCommitTransaction( ppib, 0 ) );
	
	return err;

HandleError:
	CallSx( ErrDIRRollback( ppib ), JET_errRollbackError );
	
	return err;
	}


//	to prevent read ahead over-preread, we may want to keep track of last
//	page of the database.

ERR ErrDBSetLastPageAndOpenSLV( IFileSystemAPI *const pfsapi, PIB *ppib, const IFMP ifmp, const BOOL fOpenSLV )
	{
	ERR		err;
	PGNO	pgno;
	IFMP	ifmpT;
	BOOL	fDbOpened	= fFalse;

	ppib->SetFSetAttachDB();

	Call( ErrDBOpenDatabase( ppib, rgfmp[ifmp].SzDatabaseName(), &ifmpT, NO_GRBIT ) );
	Assert( ifmpT == ifmp );
	fDbOpened = fTrue;

	Assert( ppib->FSetAttachDB() );
	Assert( g_cbPage == 1 << g_shfCbPage );
	Call( ErrBTGetLastPgno( ppib, ifmp, &pgno ) );
	rgfmp[ifmp].SetFileSize( QWORD( pgno ) << g_shfCbPage );

	if ( fOpenSLV )
		{
		Call( ErrFILEOpenSLV( pfsapi, ppib, ifmpT ) );
		}

HandleError:
	if ( fDbOpened )
		{
		CallS( ErrDBCloseDatabase( ppib, ifmpT, NO_GRBIT ) );
		}

	ppib->ResetFSetAttachDB();
	return err;
	}


ERR ISAMAPI ErrIsamCreateDatabase(
	JET_SESID	sesid,
	const CHAR	*szDatabaseName,
	const CHAR	*szSLVName,
	const CHAR	*szSLVRoot,
	const ULONG	cpgDatabaseSizeMax,
	JET_DBID	*pjifmp,
	JET_GRBIT	grbit )
	{
	ERR			err;
	PIB			*ppib;
	IFMP		ifmp;

	//	check parameters
	//
	Assert( sizeof(JET_SESID) == sizeof(PIB *) );
	ppib = (PIB *)sesid;
	CallR( ErrPIBCheck( ppib ) );

	CallR( ErrDBCreateDatabase(
				ppib,
				NULL,
				szDatabaseName,
				szSLVName,
				szSLVRoot,
				cpgDatabaseSizeMax,
				&ifmp,
				dbidMax,
				cpgDatabaseMin,
				grbit,
				NULL ) );

	*pjifmp = (JET_DBID)ifmp;

	return JET_errSuccess;
	}


LOCAL VOID DBGetSLVNameFromDbName( INST* const pinst, IFileSystemAPI *const pfsapi, const CHAR *szDbName, CHAR *szSLVName, CHAR *szSLVRoot )
	{
	CHAR	szDbDir[IFileSystemAPI::cchPathMax];
	CHAR	szDbBaseName[IFileSystemAPI::cchPathMax];
	CHAR	szDbExt[IFileSystemAPI::cchPathMax];
	
	CallS( pfsapi->ErrPathParse( szDbName, szDbDir, szDbBaseName, szDbExt ) );

	if ( NULL != szSLVName )
		{
		CallS( pfsapi->ErrPathBuild( szDbDir, szDbBaseName, szSLVExt, szSLVName ) );
		}

	if ( NULL != szSLVRoot )
		{
		Assert( pinstNil != pinst );
		for ( int ipinst = 0; ipinst < ipinstMax; ipinst++ )
			{
			if ( pinst == g_rgpinst[ ipinst ] )
				break;
			}
		Assert( ipinst < ipinstMax );	//	pinst should always be valid

		sprintf( szSLVRoot, "\\ESE98\\$%d.%d.%s%s$", DwUtilProcessId(), ipinst, szDbBaseName, szSLVExt );
		}
	}

ERR ErrDBCreateDatabase(
	PIB				*ppib,
	IFileSystemAPI	*pfsapiDest,
	const CHAR		*szDatabaseName,
	const CHAR		*szSLVName,
	const CHAR		*szSLVRoot,
	const CPG		cpgDatabaseSizeMax,
	IFMP			*pifmp,
	DBID			dbidGiven,
	CPG				cpgPrimary,
	const ULONG		grbit,
	SIGNATURE		*psignDb )
	{
	ERR			err;
	CHAR  		rgchDbFullName[IFileSystemAPI::cchPathMax];
	CHAR  		rgchSLVFullName[IFileSystemAPI::cchPathMax];
	CHAR  		rgchSLVRootName[IFileSystemAPI::cchPathMax];
	CHAR  		*szDbFullName		= rgchDbFullName;
	CHAR		*szSLVFullName		= rgchSLVFullName;
	CHAR		*szSLVRootName		= rgchSLVRootName;
	BOOL		fDatabaseOpen		= fFalse;
	DBFILEHDR	*pdbfilehdr			= NULL;
	BOOL		fNewDBCreated		= fFalse;
	BOOL		fLogged				= fFalse;
	LGPOS		lgposLogRec;

	CheckPIB( ppib );
	
	if ( ppib->level > 0 )
		return ErrERRCheck( JET_errInTransaction );

	if ( cpgPrimary == 0 )
		cpgPrimary = cpgDatabaseMin;

	if ( cpgPrimary > pgnoSysMax )
		return ErrERRCheck( JET_errDatabaseInvalidPages );

	if ( grbit & JET_bitDbVersioningOff )
		{
		if ( !( grbit & JET_bitDbRecoveryOff ) )
			{
			return ErrERRCheck( JET_errCannotDisableVersioning );
			}
		}
	
	INST *pinst = PinstFromPpib( ppib );
	LOG *plog = pinst->m_plog;
	IFMP ifmp;
	IFileSystemAPI *pfsapi;

	if ( NULL != pfsapiDest )
		{
		pfsapi = pfsapiDest;
		}
	else 
		{
		pfsapi = pinst->m_pfsapi;
		}

	//	if recovering and ifmp is given latch the fmp first

	if ( plog->m_fRecovering && dbidGiven < dbidMax && dbidGiven != dbidTemp )
		{
		ifmp = pinst->m_mpdbidifmp[ dbidGiven ];
		FMP::AssertVALIDIFMP( ifmp );
		
		//	get corresponding ifmp
		//
		CallS( FMP::ErrNewAndWriteLatch(
						&ifmp,
						rgfmp[ifmp].SzDatabaseName(),
						rgfmp[ifmp].SzSLVName(),
						rgfmp[ifmp].SzSLVRoot(),
						ppib,
						pinst,
						pfsapi,
						dbidGiven ) );

		szDbFullName = rgfmp[ifmp].SzDatabaseName();
		szSLVFullName = rgfmp[ifmp].SzSLVName();
		szSLVRootName = rgfmp[ifmp].SzSLVRoot();
		
		}
	else
		{
		if ( NULL == szDatabaseName || 0 == *szDatabaseName )
			return ErrERRCheck( JET_errDatabaseInvalidPath );

		if ( pinst->m_fCreatePathIfNotExist )
			{
			//	make sure database name has a file at the end of it (no '\')
			Assert( !FOSSTRTrailingPathDelimiter( const_cast< CHAR * >( szDatabaseName ) ) );
			err = ErrUtilCreatePathIfNotExist( pfsapi, szDatabaseName, rgchDbFullName );
			}
		else
			{
			err = pfsapi->ErrPathComplete( szDatabaseName, rgchDbFullName );
			}
		CallR( err == JET_errInvalidPath ? ErrERRCheck( JET_errDatabaseInvalidPath ) : err );
		
		Assert( szDbFullName == rgchDbFullName );
		Assert( szSLVFullName == rgchSLVFullName );
		Assert( szSLVRootName == rgchSLVRootName );

		//	if SLV name passed in, use that for SLV filename
		//	if no SLV name passed in and JET_bitDbCreateStreamingFile specified, base SLV name off db name
		//	if no SLV name passed in and JET_bitDbCreateStreamingFile NOT specified, don't create SLV file
		if ( NULL != szSLVName && 0 != *szSLVName )
			{
			if ( pinst->m_fCreatePathIfNotExist )
				{
				//	make sure SLV name has a file at the end of it (no '\')
				Assert( !FOSSTRTrailingPathDelimiter( const_cast< CHAR * >( szSLVName ) ) );
				err = ErrUtilCreatePathIfNotExist( pfsapi, szSLVName, rgchSLVFullName );
				}
			else
				{
				err = pfsapi->ErrPathComplete( szSLVName, rgchSLVFullName );
				}
			CallR( err == JET_errInvalidPath ? ErrERRCheck( JET_errSLVInvalidPath ) : err );
			
			if ( NULL != szSLVRoot && 0 != *szSLVRoot )
				{
				strcpy( szSLVRootName, szSLVRoot );
				}
			else if ( pinst->FSLVProviderEnabled() )
				{
				//	must ALWAYS specify root name when SLV provider is enabled
				CallR( ErrERRCheck( JET_errSLVRootNotSpecified ) );
				}
			else
				{
				//	auto-generate root name only
				DBGetSLVNameFromDbName( pinst, pfsapi, szDbFullName, NULL, szSLVRootName );
				}
			}
		else if ( grbit & JET_bitDbCreateStreamingFile )
			{
			DBGetSLVNameFromDbName( pinst, pfsapi, szDbFullName, szSLVFullName, szSLVRootName );
			}
		else
			{
			szSLVFullName = NULL;
			szSLVRootName = NULL;
			}

		Assert( dbidTemp == dbidGiven || dbidMax == dbidGiven );
		err = FMP::ErrNewAndWriteLatch( &ifmp, szDbFullName, szSLVFullName, szSLVRootName, ppib, pinst, pfsapi, dbidGiven );
		if ( err != JET_errSuccess )
			{
			if ( JET_wrnDatabaseAttached == err )
				err = ErrERRCheck( JET_errDatabaseDuplicate );
			return err;
			}

		dbidGiven = rgfmp[ ifmp ].Dbid();
		}

	//	From this point we got a valid ifmp entry. Start the creat DB process.

	FMP *pfmp;
	pfmp = &rgfmp[ ifmp ];

	pfmp->RwlDetaching().EnterAsWriter();
	pfmp->SetCreatingDB();
	pfmp->RwlDetaching().LeaveAsWriter();

	//	check if database file already exists

	if ( dbidGiven != dbidTemp )
		{
		err = ErrUtilPathExists( pfsapi, szDbFullName );
		if ( JET_errFileNotFound != err )
			{
			if ( JET_errSuccess == err ) // database file exists
				{
				// delete db with the same name
				if( grbit & JET_bitDbOverwriteExisting )
					{		
					err = pfsapi->ErrFileDelete( szDbFullName );
					}
				else
					{
					err = ErrERRCheck( JET_errDatabaseDuplicate );
					}
				}
			Call( err );
			}

		if ( NULL != szSLVFullName )
			{
			err = ErrUtilPathExists( pfsapi, szSLVFullName );
			if ( JET_errFileNotFound != err )
				{
				if ( JET_errSuccess == err ) // streaming file exists
					{
					// delete db with the same name
					if( grbit & JET_bitDbOverwriteExisting )
						{
						err = pfsapi->ErrFileDelete( szSLVFullName );
						}
					else
						{
						err = ErrERRCheck( JET_errSLVStreamingFileAlreadyExists );
						}
					}
				Call( err );
				}
			}
		}
	else
		{
		ERR errDelFile;

		errDelFile = pfsapi->ErrFileDelete( szDbFullName );
#ifdef DEBUG
		if ( JET_errSuccess != errDelFile
			&& JET_errFileNotFound != errDelFile
			&& JET_errInvalidPath != errDelFile
			&& !FRFSFailureDetected( OSFileDelete ) )
			{
			CallS( errDelFile );
			}
#endif			
			

#ifdef TEMP_SLV
		//	temp db. always created with streaming file
		Assert( NULL != szSLVFullName );

		errDelFile = pfsapi->ErrFileDelete( szSLVFullName );
#ifdef DEBUG
		if ( JET_errSuccess != errDelFile
			&& JET_errFileNotFound != errDelFile
			&& !FRFSFailureDetected( OSFileDelete ) )
			{
			CallS( errDelFile );
			}
#endif

#else
		Assert( NULL == szSLVFullName );

#endif	//	TEMP_SLV
		}

	//	create an empty database with header only.
	 
	pdbfilehdr = (DBFILEHDR_FIX * )PvOSMemoryPageAlloc( g_cbPage, NULL );
	if ( pdbfilehdr == NULL )
		{
		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}

	//	set database non-loggable during create database

	pfmp->ResetLogOn();
	pfmp->SetVersioningOff();

	//	create database header

	memset( pdbfilehdr, 0, g_cbPage );
	pdbfilehdr->le_ulMagic = ulDAEMagic;
	pdbfilehdr->le_ulVersion = ulDAEVersion;
	pdbfilehdr->le_ulUpdate = ulDAEUpdate;
	pdbfilehdr->le_ulCreateVersion = ulDAEVersion;
	pdbfilehdr->le_ulCreateUpdate = ulDAEUpdate;
	Assert( 0 == pdbfilehdr->le_dbtimeDirtied );
	Assert( 0 == pdbfilehdr->le_objidLast );
	Assert( attribDb == pdbfilehdr->le_attrib );

	Assert( 0 == pdbfilehdr->m_ulDbFlags );
	Assert( !pdbfilehdr->FShadowingDisabled() );
	if ( grbit & JET_bitDbShadowingOff )
		{
		pdbfilehdr->SetShadowingDisabled();
		}

	pdbfilehdr->le_dbid = pfmp->Dbid();
	if ( psignDb == NULL )
		SIGGetSignature( &pdbfilehdr->signDb );
	else
		UtilMemCpy( &pdbfilehdr->signDb, psignDb, sizeof( SIGNATURE ) );
	if ( NULL != szSLVFullName )
		{
		Assert( NULL != pfmp->SzSLVName() );
		pdbfilehdr->SetSLVExists();
		pdbfilehdr->signSLV = pdbfilehdr->signDb;
		}
	Assert( !pfmp->FSLVAttached() );
	pdbfilehdr->SetDbstate( JET_dbstateJustCreated );
	Assert( 0 == pdbfilehdr->le_dbtimeDirtied );
	Assert( 0 == pdbfilehdr->le_objidLast );

	pdbfilehdr->le_cbPageSize = g_cbPage;

	if ( plog->m_fLogDisabled || ( grbit & JET_bitDbRecoveryOff ) )
		{
		memset( &pdbfilehdr->signLog, 0, sizeof( SIGNATURE ) );
		}
	else
		{
		Assert( plog->m_fSignLogSet );
		pdbfilehdr->signLog = plog->m_signLog;
		}

	pdbfilehdr->le_filetype	= filetypeDB;

	pfmp->SetDbtimeLast( 0 );
	pfmp->SetObjidLast( 0 );
	Assert( pdbfilehdr->le_dbtimeDirtied == pfmp->DbtimeLast() );
	Assert( pdbfilehdr->le_objidLast == pfmp->ObjidLast() );
	err = pfmp->ErrSetPdbfilehdr( pdbfilehdr );
	if ( err < 0 )
		{
		OSMemoryPageFree( pdbfilehdr );
		goto HandleError;
		}

	//	Write database header

	Call( ErrUtilWriteShadowedHeader(	pfsapi, 
										szDbFullName, 
										fTrue,
										(BYTE*)pdbfilehdr, 
										g_cbPage ) );

	fNewDBCreated = fTrue;

	//	Set proper database size.

	Call( ErrIOOpenDatabase( pfsapi, ifmp, szDbFullName ) );
	Call( ErrIONewSize( ifmp, cpgPrimary ) );

	//	not in a transaction, but still need to set lgposRC of the buffers
	//	used by this function such that when get checkpoint, it will get
	//	right check point.

	if ( !plog->m_fLogDisabled
		&& !( grbit & JET_bitDbRecoveryOff )
		&& !plog->m_fRecovering )
		{
		plog->m_critLGBuf.Enter();
		plog->GetLgposOfPbEntry( &ppib->lgposStart );
		plog->m_critLGBuf.Leave();
		}

	//	initialize the database file.  Logging of page operations is
	//	turned off, during creation only.  After creation the database
	//	is marked loggable and logging is turned on.

	DBSetOpenDatabaseFlag( ppib, ifmp );
	fDatabaseOpen = fTrue;

	Call( ErrDBInitDatabase( ppib, ifmp, cpgPrimary ) );

	if ( rgfmp[ifmp].Dbid() != dbidTemp )
		{
		//	create system tables
		//
		Call( ErrCATCreate( ppib, ifmp ) );
		}

	Assert( !pfmp->FSLVAttached() );
	if ( pdbfilehdr->FSLVExists() )
		{
		Call( ErrFILECreateSLV( pfsapi, ppib, ifmp ) );
		Assert( pfmp->FSLVAttached() );
		}

	AssertDIRNoLatch( ppib );

	//	flush buffers

	Call( ErrBFFlush( ifmp ) );
	Call( ErrBFFlush( ifmp | ifmpSLV ) );

	Assert( !pfmp->FLogOn() );
	Assert( pfmp->FVersioningOff() );

	//	set database status to loggable if it is.

	if ( grbit & JET_bitDbRecoveryOff )
		{
		Assert( !pfmp->FLogOn() );
		Assert( !pfmp->FReadOnlyAttach() );
		if ( !( grbit & JET_bitDbVersioningOff ) )
			{
			pfmp->ResetVersioningOff();
			}
		}
	else 
		{
		Assert( !( grbit & JET_bitDbVersioningOff ) );
		pfmp->ResetVersioningOff();
		pfmp->SetLogOn();
		}

	pfmp->SetDatabaseSizeMax( cpgDatabaseSizeMax );

	if ( pfmp->FLogOn() )
		{
		Assert( pfmp == &rgfmp[ifmp] );
		Assert( UtilCmpFileName( szDbFullName, pfmp->SzDatabaseName() ) == 0 );
		Assert( ( NULL == szSLVFullName && NULL == pfmp->SzSLVName() )
			|| UtilCmpFileName( szSLVFullName, pfmp->SzSLVName() ) == 0 );
		Assert( ( NULL == szSLVRootName && NULL == pfmp->SzSLVRoot() )
			|| UtilCmpFileName( szSLVRootName, pfmp->SzSLVRoot() ) == 0 );
		Assert( pfmp->CpgDatabaseSizeMax() == cpgDatabaseSizeMax );

		Call( ErrLGCreateDB( ppib, ifmp, grbit, &lgposLogRec ) );

		fLogged = fTrue;
		if ( plog->m_fRecovering )
			{
			pdbfilehdr->le_lgposAttach = plog->m_lgposRedo;
			}
		else
			{
			pdbfilehdr->le_lgposAttach = lgposLogRec;
			}
		}

	pdbfilehdr->le_dbtimeDirtied = pfmp->DbtimeLast();
	LGIGetDateTime( &pdbfilehdr->logtimeAttach );

	IOCloseDatabase( ifmp );

	//	set database state to be inconsistent from creating since
	//	the createdatabase op is logged.

	pdbfilehdr->le_objidLast = pfmp->ObjidLast();
	if ( !plog->m_fLogDisabled )
		pdbfilehdr->SetDbstate( JET_dbstateInconsistent, plog->m_plgfilehdr->lgfilehdr.le_lGeneration, &plog->m_plgfilehdr->lgfilehdr.tmCreate );
	else
		pdbfilehdr->SetDbstate( JET_dbstateInconsistent );
	
	//	Set version info
	if ( !plog->m_fRecovering )
		{
		pdbfilehdr->le_dwMajorVersion = dwGlobalMajorVersion;
		pdbfilehdr->le_dwMinorVersion = dwGlobalMinorVersion;
		pdbfilehdr->le_dwBuildNumber = dwGlobalBuildNumber;
		pdbfilehdr->le_lSPNumber = lGlobalSPNumber;
		}
	Assert( pdbfilehdr->le_objidLast );

	if ( pdbfilehdr->FSLVExists() )
		{
		Assert( NULL != pfmp->SzSLVName() );
		Call( ErrSLVSyncHeader(	pfsapi, 
								rgfmp[ifmp].FReadOnlyAttach(),
								rgfmp[ifmp].SzSLVName(),
								pdbfilehdr ) );
		}
	else
		{
		Assert( NULL == pfmp->SzSLVName() );
		}
		
	Call( ErrUtilWriteShadowedHeader(	pfsapi, 
										szDbFullName, 
										fTrue,
										(BYTE*)pdbfilehdr, 
										g_cbPage ) );

	Call( ErrIOOpenDatabase( pfsapi, ifmp, szDbFullName ) );

	//	Make the database attached.

	Assert( !( pfmp->FAttached() ) );
	pfmp->SetAttached();

	Assert (! pfmp->FAllowHeaderUpdate() );	
	pfmp->RwlDetaching().EnterAsWriter();
	pfmp->SetAllowHeaderUpdate();
	pfmp->RwlDetaching().LeaveAsWriter();

	pfmp->SetDbtimeOldestGuaranteed( pfmp->DbtimeLast() );
	pfmp->SetDbtimeOldestCandidate( pfmp->DbtimeLast() );
	pfmp->SetDbtimeOldestTarget( pfmp->DbtimeLast() );
	pfmp->SetTrxOldestCandidate( pinst->m_trxNewest );
	pfmp->SetTrxOldestTarget( trxMax );

	Call( ErrDBSetLastPageAndOpenSLV( pfsapi, ppib, ifmp, pdbfilehdr->FSLVExists() ) );

	//	the database is created and attached.
	//	Make the fmp available for others to open etc.

	//	No need to wrl since it is OK for reader to mistaken it is
	//	being created.

	pfmp->RwlDetaching().EnterAsWriter();
	pfmp->ResetCreatingDB();
	pfmp->ReleaseWriteLatch( ppib );
	pfmp->RwlDetaching().LeaveAsWriter();

	*pifmp = ifmp;

#ifdef FORCE_ONLINE_DEFRAG
	Assert( !pfmp->FReadOnlyAttach() );
	if ( !plog->m_fRecovering && pfmp->FLogOn() )
		{
		Assert( !pfmp->FVersioningOff() );
		CallS( ErrOLDDefragment( ifmp, NULL, NULL, NULL, NULL, JET_bitDefragmentBatchStart ) );
		}
#endif		

#ifdef FORCE_ONLINE_SLV_DEFRAG
	Assert( !pfmp->FReadOnlyAttach() );
	if ( !plog->m_fRecovering && pfmp->FLogOn() && pfmp->FSLVAttached() )
		{
		Assert( !pfmp->FVersioningOff() );
		CallS( ErrOLDDefragment( ifmp, NULL, NULL, NULL, NULL, JET_bitDefragmentSLVBatchStart ) );
		}
#endif	//	FORCE_ONLINE_SLV_DEFRAG		

	return JET_errSuccess;

HandleError:

	//	purge the bad, half-created database
	FCB::DetachDatabase( ifmp, fFalse );
	BFPurge( ifmp );
	BFPurge( ifmp | ifmpSLV );

	if ( fLogged && err < 0 )
		{
		//	we have to take the instance offline if there is an error
		//	during database creation and the creation is logged

		PinstFromPpib( ppib )->SetFInstanceUnavailable();
		ppib->SetErrRollbackFailure( err );
		}

	if ( FIODatabaseOpen( ifmp ) )
		{
		IOCloseDatabase( ifmp );
		}

	if ( fNewDBCreated )
		{
		(VOID)ErrIODeleteDatabase( pfsapi, ifmp );
		if ( NULL != szSLVFullName )
			{
			(VOID)pfsapi->ErrFileDelete( szSLVFullName );
			}
		if ( fLogged )
			{
			Assert( UtilCmpFileName( szDbFullName, rgfmp[ifmp].SzDatabaseName() ) == 0 );

#ifdef INDEPENDENT_DB_FAILURE
			ErrLGForceDetachDB( ppib, ifmp, fLRForceDetachDeleteDB, &lgposLogRec );
#endif			
			}
		}

	if ( fDatabaseOpen )	
		{
		DBResetOpenDatabaseFlag( ppib, ifmp );
		}

	if ( pfmp->Pdbfilehdr() )
		{
		pfmp->FreePdbfilehdr();
		}

	FMP::EnterCritFMPPool();
	pfmp->RwlDetaching().EnterAsWriter();
	pfmp->ResetCreatingDB();
	pfmp->ReleaseWriteLatchAndFree( ppib );
	pfmp->RwlDetaching().LeaveAsWriter();
	FMP::LeaveCritFMPPool();
	
	return err;
	}


//	delete db and slv files (currently only used to remove temp db and slv upon shutdown)
VOID DBDeleteDbFiles( INST *pinst, IFileSystemAPI *const pfsapi, const CHAR *szDbName )
	{
	CHAR	szSLVName[IFileSystemAPI::cchPathMax];

	DBGetSLVNameFromDbName( pinst, pfsapi, szDbName, szSLVName, NULL );

	(VOID)pfsapi->ErrFileDelete( szDbName );
	(VOID)pfsapi->ErrFileDelete( szSLVName );
	}

ERR ErrDBCheckUniqueSignature( IFMP ifmp ) 
	{
	ERR				err 		= JET_errSuccess;
	const FMP * 	pfmp 		= &rgfmp[ifmp];	
	Assert ( pfmp );
	const INST * 	pinst 		= pfmp->Pinst();
	DBID			dbid;

	if ( pfmp->FReadOnlyAttach() || NULL == pfmp->Pdbfilehdr() )
		return JET_errSuccess;

	Assert ( pfmp->FInUse() );
	Assert ( NULL != pfmp->Pdbfilehdr() );
	Assert ( !pfmp->FSkippedAttach() );

	FMP::EnterCritFMPPool();
	for ( dbid = dbidUserLeast; dbid < dbidMax; dbid++ )
		{
		if ( pinst->m_mpdbidifmp[ dbid ] >= ifmpMax || pinst->m_mpdbidifmp[ dbid ] == ifmp )
			continue;

		FMP	*pfmpT;
					
		pfmpT = &rgfmp[ pinst->m_mpdbidifmp[ dbid ] ];

		pfmpT->RwlDetaching().EnterAsReader();
		if ( pfmpT->Pdbfilehdr()
			&& 0 == memcmp( &(pfmp->Pdbfilehdr()->signDb), &(pfmpT->Pdbfilehdr()->signDb), sizeof( SIGNATURE ) ) )
			{
			pfmpT->RwlDetaching().LeaveAsReader();
			Call ( ErrERRCheck ( JET_errDatabaseSignInUse ) );
			}
		pfmpT->RwlDetaching().LeaveAsReader();
		}

	Assert ( JET_errSuccess == err );
HandleError:
	FMP::LeaveCritFMPPool();
	return err;
	}

ERR ErrDBReadHeaderCheckConsistency(
	IFileSystemAPI	* const pfsapi, 
	FMP				* pfmp )
	{
	ERR				err;
	DBFILEHDR		* pdbfilehdr;
	IFileAPI		* pfapiT;

	//	bring in the database and check its header
	//
	pdbfilehdr = (DBFILEHDR * )PvOSMemoryPageAlloc( g_cbPage, NULL );
	if ( NULL == pdbfilehdr )
		{
		return ErrERRCheck( JET_errOutOfMemory );
		}
		
	//	need to zero out header because we try to read it
	//	later even on failure
	memset( pdbfilehdr, 0, g_cbPage );

	Call( pfsapi->ErrFileOpen( pfmp->SzDatabaseName(), &pfapiT, pfmp->FReadOnlyAttach() ) )

	Assert( pfmp->FInUse() );
	err = ( pfmp->FReadOnlyAttach() ?
			ErrUtilReadShadowedHeader : ErrUtilReadAndFixShadowedHeader )
				(	pfsapi,
					pfmp->SzDatabaseName(),
					(BYTE*)pdbfilehdr,
					g_cbPage,
					OffsetOf( DBFILEHDR, le_cbPageSize ),
					pfapiT );

	delete pfapiT;

	if ( err < 0 )
		{
		//	600 use new checksum method, so read shadow will fail with JET_errDiskIO.
		if ( JET_errDiskIO == err )
			{
			if ( 	ulDAEMagic == pdbfilehdr->le_ulMagic
				 && ulDAEVersion500 == pdbfilehdr->le_ulVersion )
				{
				//	500 has different way of doing checksum. Let's check the version directly.
				//	The magic number stays the same since 500
				
				err = ErrERRCheck( JET_errDatabase500Format );
				}
				
			else
				{
				err = ErrDBICheck200And400( pfsapi, pfmp->SzDatabaseName() );

				if ( err != JET_errDatabase200Format && err != JET_errDatabase400Format )
					{
					if ( pdbfilehdr->le_ulMagic == ulDAEMagic )
						err = ErrERRCheck( JET_errInvalidDatabaseVersion );
					else
						err = ErrERRCheck( JET_errDatabaseCorrupted );
					}
				}
			}

		goto HandleError;
		}

	//  the version and update numbers should always increase
	Assert( ulDAEVersion >= ulDAEVersionESE97 );
	
	//	do version check
	if ( ulDAEMagic != pdbfilehdr->le_ulMagic )
		{
		err = ErrERRCheck( JET_errInvalidDatabaseVersion );
		goto HandleError;
		}
	else if ( pdbfilehdr->le_ulVersion >= ulDAEVersionESE97 )
		{
		//  if the database format needs to be upgraded we will do it after
		//  attaching
		err = JET_errSuccess;
		}
	else
		{
		Assert( pdbfilehdr->le_ulVersion < ulDAEVersion );
		err = ErrERRCheck( JET_errInvalidDatabaseVersion );
		goto HandleError;
		}

	//  do pagesize check
	if ( ( 0 == pdbfilehdr->le_cbPageSize && g_cbPageDefault != g_cbPage )
			|| ( 0 != pdbfilehdr->le_cbPageSize && pdbfilehdr->le_cbPageSize != g_cbPage ) )
			{
			Call( ErrERRCheck( JET_errPageSizeMismatch ) );
			}
			
	if ( !fGlobalRepair )
		{
		if ( pdbfilehdr->Dbstate() != JET_dbstateConsistent )
			{
			if ( JET_dbstateForceDetach == pdbfilehdr->Dbstate() )
				{
				CHAR		szT1[128];
				const CHAR	*rgszT[3];
				LOGTIME		tm;

				/*	log event that the database is not recovered completely
				/**/
				rgszT[0] = pfmp->SzDatabaseName();
				tm = pdbfilehdr->signDb.logtimeCreate;
				sprintf( szT1, "%d/%d/%d %d:%d:%d",
					(short) tm.bMonth, (short) tm.bDay,	(short) tm.bYear + 1900,
					(short) tm.bHours, (short) tm.bMinutes, (short) tm.bSeconds);
				rgszT[1] = szT1;

				UtilReportEvent(
						eventError,
						LOGGING_RECOVERY_CATEGORY,
						RESTORE_DATABASE_MISSED_ERROR_ID,
						2,
						rgszT );
				err = ErrERRCheck( JET_errDatabaseInconsistent );
				}
			else if ( pdbfilehdr->Dbstate() == JET_dbstateBeingConverted )
				{
				const CHAR	*rgszT[1];

				rgszT[0] = pfmp->SzDatabaseName();
				
				//	attempting to use a database which did not successfully
				//	complete conversion
				UtilReportEvent(
						eventError,
						CONVERSION_CATEGORY,
						CONVERT_INCOMPLETE_ERROR_ID,
						1,
						rgszT );
				err = ErrERRCheck( JET_errDatabaseIncompleteUpgrade );
				}
			else
				{
				// we want to return a specific error if the database is from a backup set and not recovered
				if ( 0 != pdbfilehdr->bkinfoFullCur.le_genLow )
					{
					const CHAR	*rgszT[1];

					rgszT[0] = pfmp->SzDatabaseName();
				
					//	attempting to use a database which did not successfully
					//	complete conversion
					UtilReportEvent(
							eventError,
							LOGGING_RECOVERY_CATEGORY,
							ATTACH_TO_BACKUP_SET_DATABASE_ERROR_ID,
							1,
							rgszT );
					err = ErrERRCheck( JET_errSoftRecoveryOnBackupDatabase );
					}
				else
					{
					err = ErrERRCheck( JET_errDatabaseInconsistent );
					}
				}
			goto HandleError;
			}
		}

	// make sure the attached file is a database file
	if ( attribDb != pdbfilehdr->le_attrib
		|| ( filetypeUnknown != pdbfilehdr->le_filetype && filetypeDB != pdbfilehdr->le_filetype ) )
		{
		const CHAR	*rgszT[1];
		rgszT[0] = pfmp->SzDatabaseName();
		
		UtilReportEvent(
				eventError,
				DATABASE_CORRUPTION_CATEGORY,
				DATABASE_HEADER_ERROR_ID,
				1,
				rgszT );

		Call( ErrERRCheck( JET_errDatabaseCorrupted ) );
		}

	Assert( pfmp->Pdbfilehdr() == NULL );
	Call( pfmp->ErrSetPdbfilehdr( pdbfilehdr ) );
	pfmp->SetDbtimeLast( pdbfilehdr->le_dbtimeDirtied );
	Assert( pfmp->Pdbfilehdr()->le_dbtimeDirtied != 0 );
	pfmp->SetObjidLast( pdbfilehdr->le_objidLast );
	Assert( pfmp->Pdbfilehdr()->le_objidLast != 0 );
	
	return JET_errSuccess;

HandleError:
	Assert( err < 0 );
	Assert( NULL != pdbfilehdr );
	OSMemoryPageFree( (VOID *)pdbfilehdr );
	return err;
	}

VOID DBISetHeaderAfterAttach( DBFILEHDR_FIX *pdbfilehdr, LGPOS lgposAttach, IFMP ifmp, BOOL fKeepBackupInfo )
	{
	LOG *plog = PinstFromIfmp( ifmp )->m_plog;
	
	//	Update database file header.
	
	if ( pdbfilehdr->Dbstate() != JET_dbstateInconsistent )
		{
		Assert( pdbfilehdr->Dbstate() == JET_dbstateConsistent );
		if ( plog->m_fLogDisabled )
			{
			pdbfilehdr->SetDbstate( JET_dbstateInconsistent );
			}
		else
			{
			pdbfilehdr->SetDbstate( JET_dbstateInconsistent, plog->m_plgfilehdr->lgfilehdr.le_lGeneration, &plog->m_plgfilehdr->lgfilehdr.tmCreate );
			if ( plog->m_fRecovering )
				{
				pdbfilehdr->SetDbFromRecovery();
				}
			else
				{
				pdbfilehdr->ResetDbFromRecovery();
				}
			}
		}
		
	Assert( !rgfmp[ifmp].FLogOn() || !plog->m_fLogDisabled );
	Assert( pdbfilehdr->le_dbtimeDirtied >= rgfmp[ifmp].DbtimeLast() );
	Assert( pdbfilehdr->le_objidLast >= rgfmp[ifmp].ObjidLast() );
	
	if ( objidFDPThreshold < (ULONG)(pdbfilehdr->le_objidLast) )
		{
		const _TCHAR *rgpszT[1] = { rgfmp[ifmp].SzDatabaseName() };
		UtilReportEvent( eventWarning, GENERAL_CATEGORY, ALMOST_OUT_OF_OBJID, 1, rgpszT );
		}
	
	//	reset bkinfo except in the recovering UNDO mode where
	//	we would like to keep the original backup information.
	 
	if ( !fKeepBackupInfo )
		{
		if ( !rgfmp[ifmp].FLogOn()
			|| memcmp( &pdbfilehdr->signLog, &plog->m_signLog, sizeof( SIGNATURE ) ) != 0 )
			{
			//	if no log or the log signaure is not the same as current log signature,
			//	then the bkinfoIncPrev and bfkinfoFullPrev are not meaningful.
			 
			memset( &pdbfilehdr->bkinfoIncPrev, 0, sizeof( BKINFO ) );
			memset( &pdbfilehdr->bkinfoFullPrev, 0, sizeof( BKINFO ) );
			}
		memset( &pdbfilehdr->bkinfoFullCur, 0, sizeof( BKINFO ) );
		// reset the snapshot data as well
		memset( &pdbfilehdr->bkinfoSnapshotCur, 0, sizeof( BKINFO ) );
		}

	if ( fGlobalRepair )
		{
		//	preserve the signature
		}
	else if ( plog->m_fRecovering || rgfmp[ifmp].FLogOn() )
		{
		Assert( !plog->m_fLogDisabled );
		Assert( plog->m_fSignLogSet );
		Assert( 0 != CmpLgpos( lgposMin, rgfmp[ifmp].LgposAttach() ) );
		Assert( 0 == CmpLgpos( lgposMin, rgfmp[ifmp].LgposDetach() ) );

		//	set new attachment time
		pdbfilehdr->le_lgposAttach = lgposAttach;
		
		//	Set global signature.
		if ( 0 != memcmp( &pdbfilehdr->signLog, &plog->m_signLog, sizeof(SIGNATURE) ) )
			{
			//	must reset lgposConsistent for this log set
			//	keep that order (set lgposConsistent first
			//	then signLog) for the following two lines
			//	it is used by LGLoadAttachmentsFromFMP
			pdbfilehdr->le_lgposConsistent = lgposMin;
			pdbfilehdr->signLog = plog->m_signLog;
			}
		}
	else
		{
		//	must regenerate signDb to disassociate it from the past
		SIGGetSignature( &pdbfilehdr->signDb );
		}
	
	LGIGetDateTime( &pdbfilehdr->logtimeAttach );

	//	reset detach time
	pdbfilehdr->le_lgposDetach = lgposMin;
	memset( &pdbfilehdr->logtimeDetach, 0, sizeof( LOGTIME ) );

	//	version compatibility checks already performed,
	//	so just update version info
	pdbfilehdr->le_ulVersion = ulDAEVersion;
	pdbfilehdr->le_ulUpdate = ulDAEUpdate;

	pdbfilehdr->le_dbid = rgfmp[ ifmp ].Dbid();
	}


INLINE ERR ErrDBUpgradeForLocalisation( PIB *ppib, const IFMP ifmp, const JET_GRBIT grbit )
	{
	ERR			err;
	IFMP		ifmpT;
	BOOL		fIndexesDeleted;
	const CHAR	*rgsz[9];

	//	Write out header with build # = 0 so that any crash from now
	//	will have buld # 0. This will cause upgrade again till it is done.
	DBFILEHDR_FIX	*pdbfilehdr			= rgfmp[ifmp].Pdbfilehdr();
	CHAR		*szDatabaseName		= rgfmp[ifmp].SzDatabaseName();

//	UNDONE: Is the statement below true??? I don't think it has to be zeroed out because
//	on restart, the version stamp will still be mismatched and index update will still
//	be forced.
//			For JET97 only. We need to zero out build number so that when it crashes
//			in the middle of index delete/create, it will always redo delete/create.
//			pdbfilehdr->dwBuildNumber = 0;
//			Assert( ifmp != PinstFromPpib( ppib )->m_mpdbidifmp[dbidTemp] );
//			err = ErrUtilWriteShadowedHeader( PinstFromPpib( ppib )->m_pfsapi, szFileName, (BYTE*)pdbfilehdr, g_cbPage );

	Assert( pdbfilehdr->FUpgradeDb() );

	Call( ErrDBOpenDatabase( ppib, szDatabaseName, &ifmpT, NO_GRBIT ) );
	Assert( ifmp == ifmpT );
	
	if ( 0 == pdbfilehdr->le_dwMajorVersion )
		{
		CHAR	rgszVerInfo[4][16];
		
		sprintf( rgszVerInfo[0], "%d", dwGlobalMajorVersion );
		sprintf( rgszVerInfo[1], "%d", dwGlobalMinorVersion );
		sprintf( rgszVerInfo[2], "%d", dwGlobalBuildNumber );
		sprintf( rgszVerInfo[3], "%d", lGlobalSPNumber );

		rgsz[0]	= szDatabaseName;
		rgsz[1] = rgszVerInfo[0];
		rgsz[2] = rgszVerInfo[1];
		rgsz[3] = rgszVerInfo[2];
		rgsz[4] = rgszVerInfo[3];
		
		UtilReportEvent(
				eventInformation,
				DATA_DEFINITION_CATEGORY,
				START_INDEX_CLEANUP_UNKNOWN_VERSION_ID, 5, rgsz );
		}
	else
		{
		CHAR	rgszVerInfo[8][16];
		
		sprintf( rgszVerInfo[0], "%d", DWORD( pdbfilehdr->le_dwMajorVersion ));
		sprintf( rgszVerInfo[1], "%d", DWORD( pdbfilehdr->le_dwMinorVersion ));
		sprintf( rgszVerInfo[2], "%d", DWORD( pdbfilehdr->le_dwBuildNumber ));
		sprintf( rgszVerInfo[3], "%d", DWORD( pdbfilehdr->le_lSPNumber ));
		sprintf( rgszVerInfo[4], "%d", dwGlobalMajorVersion );
		sprintf( rgszVerInfo[5], "%d", dwGlobalMinorVersion );
		sprintf( rgszVerInfo[6], "%d", dwGlobalBuildNumber );
		sprintf( rgszVerInfo[7], "%d", lGlobalSPNumber );
		
		rgsz[0]	= szDatabaseName;
		rgsz[1] = rgszVerInfo[0];
		rgsz[2] = rgszVerInfo[1];
		rgsz[3] = rgszVerInfo[2];
		rgsz[4] = rgszVerInfo[3];
		rgsz[5] = rgszVerInfo[4];
		rgsz[6] = rgszVerInfo[5];
		rgsz[7] = rgszVerInfo[6];
		rgsz[8] = rgszVerInfo[7];
	
		UtilReportEvent(
				eventInformation,
				DATA_DEFINITION_CATEGORY,
				START_INDEX_CLEANUP_KNOWN_VERSION_ID, 9, rgsz );
		}

	err = ErrCATDeleteLocalizedIndexes(
				ppib,
				ifmpT,
				&fIndexesDeleted,
				grbit & JET_bitDbReadOnly || !( grbit & JET_bitDbDeleteCorruptIndexes ) );
		
	CallS( ErrDBCloseDatabase( ppib, ifmpT, 0 ) );

	Call( err );

	UtilReportEvent(
			eventInformation,
			DATA_DEFINITION_CATEGORY,
			STOP_INDEX_CLEANUP_ID, 1, rgsz );

	//	Update the header with the new version info

	pdbfilehdr->le_dwMajorVersion = dwGlobalMajorVersion;
	pdbfilehdr->le_dwMinorVersion = dwGlobalMinorVersion;
	pdbfilehdr->le_dwBuildNumber = dwGlobalBuildNumber;
	pdbfilehdr->le_lSPNumber = lGlobalSPNumber;
	pdbfilehdr->ResetUpgradeDb();

	return ( fIndexesDeleted ? ErrERRCheck( JET_wrnCorruptIndexDeleted ) : JET_errSuccess );
	
HandleError:
	//	Detach the database, ignoring any errors since an error already occurred
	Assert( err < 0 );
	(VOID)ErrIsamDetachDatabase( (JET_SESID) ppib, NULL, rgfmp[ifmp].SzDatabaseName() );
	return err;
	
	}


//  ================================================================
LOCAL ERR ErrDBUpgradeFormat(
	PIB * const ppib,
	const IFMP ifmp,
	const JET_GRBIT grbit )
//  ================================================================
//
//  Update an older (compatible )format to a newer format
//
//-
	{
	ERR			err = JET_errSuccess;

	DBFILEHDR_FIX	* const pdbfilehdr		= rgfmp[ifmp].Pdbfilehdr();
	Assert( FDBUpgradeFormat( pdbfilehdr ) );
	const CHAR * const szDatabaseName		= rgfmp[ifmp].SzDatabaseName();
	const ULONG ulVersionCurrent 			= pdbfilehdr->le_ulVersion;
	const ULONG ulUpdateCurrent 			= pdbfilehdr->le_ulUpdate;

	const CHAR	*rgsz[4];
	CHAR	rgrgchBuf[2][16];
		
	sprintf( rgrgchBuf[0], "0x%x.%x", ulVersionCurrent, ulUpdateCurrent );
	sprintf( rgrgchBuf[1], "0x%x.%x", ulDAEVersion, ulDAEUpdate );

	rgsz[0]	= szDatabaseName;
	rgsz[1] = rgrgchBuf[0];
	rgsz[2] = rgrgchBuf[1];
	rgsz[3] = NULL;
		
	UtilReportEvent(
			eventInformation,
			DATA_DEFINITION_CATEGORY,
			START_FORMAT_UPGRADE_ID, 3, rgsz );

	UtilReportEvent(
		eventInformation,
		DATA_DEFINITION_CATEGORY,
		STOP_FORMAT_UPGRADE_ID, 3, rgsz );

	if( err < 0 )
		{
		UtilReportEvent(
			eventInformation,
			DATA_DEFINITION_CATEGORY,
			CONVERT_INCOMPLETE_ERROR_ID, 1, rgsz );	
		}
	return err;
	}


LOCAL VOID DBReportPartiallyAttachedDb(
	const CHAR	*szDbName,
	const ULONG	ulAttachStage,
	const ERR	err )
	{
	CHAR		szErr[8];
	CHAR		szAttachStage[8];
	const CHAR	* rgszT[3]	= { szDbName, szAttachStage, szErr };
	
	sprintf( szAttachStage, "%d", ulAttachStage );
	sprintf( szErr, "%d", err );
	UtilReportEvent( eventError, DATABASE_CORRUPTION_CATEGORY, DB_PARTIALLY_ATTACHED_ID, 3, rgszT );
	}

LOCAL VOID DBReportPartiallyDetachedDb(
	const CHAR	*szDbName,
	const ERR	err )
	{
	CHAR		szErr[8];
	const CHAR	* rgszT[2]	= { szDbName, szErr };
	
	sprintf( szErr, "%d", err );
	UtilReportEvent( eventError, DATABASE_CORRUPTION_CATEGORY, DB_PARTIALLY_DETACHED_ID, 2, rgszT );
	}

ERR ISAMAPI ErrIsamAttachDatabase(
	JET_SESID	sesid,
	const CHAR	*szDatabaseName,
	const CHAR	*szSLVName,
	const CHAR	*szSLVRoot,
	const ULONG	cpgDatabaseSizeMax,
	JET_GRBIT	grbit )
	{
	PIB					*ppib;
	ERR					err;
	IFMP				ifmp;
	CHAR				rgchSLVName[IFileSystemAPI::cchPathMax];
	CHAR				rgchDbFullName[IFileSystemAPI::cchPathMax];
	CHAR				rgchSLVFullName[IFileSystemAPI::cchPathMax];
	CHAR				rgchSLVRootName[IFileSystemAPI::cchPathMax];
	CHAR				*szDbFullName			= rgchDbFullName;
	CHAR				*szSLVFullName			= rgchSLVFullName;
	CHAR				*szSLVRootName			= rgchSLVRootName;
	LGPOS				lgposLogRec;
	DBFILEHDR			*pdbfilehdr				= NULL;
#ifdef INDEPENDENT_DB_FAILURE
	DBFILEHDR			*pdbfilehdrRevert		= NULL;
#endif
	SLVFILEHDR			*pslvfilehdr			= NULL;
	BOOL				fReadOnly;
	BOOL				fForceUpgrade;
	BOOL				fContinueUpgrade		= fFalse;
	const BOOL			fForUpgrade				= ( grbit & JET_bitDbUpgrade );
	IFileSystemAPI	*pfsapi;
	enum { ATTACH_NONE, ATTACH_LOGGED, ATTACH_SLV_UPDATED, ATTACH_DB_UPDATED, ATTACH_DB_OPENED, ATTACH_END } 
		attachState;
	const CHAR *szAttachState[ATTACH_END] = 
		{ "start", "logged attachment", "stream file header updated", "database file header updated", "database opened" };
	attachState = ATTACH_NONE;

	//	check parameters
	//

	Assert( sizeof(JET_SESID) == sizeof(PIB *) );
	ppib = (PIB *)sesid;

	CallR( ErrPIBCheck( ppib ) );

	INST *pinst = PinstFromPpib( ppib );
	LOG *plog = pinst->m_plog;

	if ( ppib->level > 0 )
		return ErrERRCheck( JET_errInTransaction );

	if ( grbit & JET_bitDbVersioningOff )
		return ErrERRCheck( JET_errCannotDisableVersioning );

	if ( NULL == szDatabaseName || 0 == *szDatabaseName )
		return ErrERRCheck( JET_errDatabaseInvalidPath );

	pfsapi = pinst->m_pfsapi;

	//	depend on ErrPathComplete to make same files same name
	//	thereby preventing same file to be multiply attached
	err = ErrUtilPathComplete( pfsapi, szDatabaseName, rgchDbFullName, fTrue );
//	if ( JET_errFileNotFound == err )
//		{
//		must return FileNotFound to retain backward-compatibility
//		err = ErrERRCheck( JET_errDatabaseNotFound );
//		}
	CallR( JET_errInvalidPath == err ? ErrERRCheck( JET_errDatabaseInvalidPath ) : err );

	Assert( szDbFullName == rgchDbFullName );
	Assert( szSLVFullName == rgchSLVFullName );

	//	if SLV name passed in, use that for SLV filename
	//	if no SLV name passed, base SLV name off db name
	//	if no SLV name passed in and JET_bitDbCreateStreamingFile NOT specified, don't create SLV file
	if ( NULL != szSLVName && 0 != *szSLVName )
		{
		err = pfsapi->ErrPathComplete( szSLVName, rgchSLVName );
		CallR( err == JET_errInvalidPath ? ErrERRCheck( JET_errSLVInvalidPath ) : err );

		if ( NULL != szSLVRoot && 0 != *szSLVRoot )
			{
			strcpy( szSLVRootName, szSLVRoot );
			}
		else if ( pinst->FSLVProviderEnabled() )
			{
			//	must ALWAYS specify root name when SLV provider is enabled
			Call( ErrERRCheck( JET_errSLVRootNotSpecified ) );
			}
		else
			{
			//	auto-generate root name only
			DBGetSLVNameFromDbName( pinst, pfsapi, szDbFullName, NULL, szSLVRootName );
			}
		}
	else
		{
		DBGetSLVNameFromDbName( pinst, pfsapi, szDbFullName, rgchSLVName, szSLVRootName );
		}

	err = ErrUtilPathExists( pfsapi, rgchSLVName, rgchSLVFullName );
	if ( JET_errFileNotFound == err )
		{
		if ( NULL != szSLVName && 0 != *szSLVName )
			{
			//	client specified SLV file, but it doesn't exist
			err = ErrERRCheck( JET_errSLVStreamingFileMissing );
			}
		else
			{
			//	client didn't specify SLV file, so we assume
			//	it has the same base name as the db, but in
			//	fact, an SLV may not have existed at all
			//	assume this is okay and detect true missing
			//	SLV file later when we read the db header
			szSLVFullName = NULL;
			szSLVRootName = NULL;
			err = JET_errSuccess;
			}
		}
	CallR( err );

	//  attaching to the SLV causes us to read the SLVAvail and SLVOwnerMap
	//  trees. we don't want to do this during repair as we haven't checked
	//  them yet. avoid attaching the SLV during integrity/repair and open
	//  the file manually
	
	if( fGlobalRepair )
		{
		szSLVFullName = NULL;
		szSLVRootName = NULL;
		}

	CallR( ErrUtilPathReadOnly( pfsapi, szDbFullName, &fReadOnly ) );
	if ( fReadOnly && !( grbit & JET_bitDbReadOnly ) )
		{
		err = ErrERRCheck( JET_errDatabaseFileReadOnly );
		return err;
		}

	if ( NULL != szSLVFullName )
		{
		CallR( ErrUtilPathReadOnly( pfsapi, szSLVFullName, &fReadOnly ) );
		if ( fReadOnly && !( grbit & JET_bitDbReadOnly ) )
			{
			err = ErrERRCheck( JET_errSLVStreamingFileReadOnly );
			return err;
			}
		}

	plog->m_critBackupInProgress.Enter();
	
	if ( plog->m_fBackupInProgress )
		{
		plog->m_critBackupInProgress.Leave();
		return ErrERRCheck( JET_errBackupInProgress );
		}

	err = FMP::ErrNewAndWriteLatch( &ifmp, szDbFullName, szSLVFullName, szSLVRootName, ppib, pinst, pfsapi, dbidMax );
	if ( err != JET_errSuccess )
		{
#ifdef DEBUG
		switch ( err )
			{
			case JET_wrnDatabaseAttached:
			case JET_errOutOfMemory:
			case JET_errDatabaseInUse:
			case JET_errTooManyAttachedDatabases:
			case JET_errDatabaseSharingViolation:
			case JET_errSLVStreamingFileInUse:
			case JET_errDatabaseInvalidPath:
			case JET_errSLVInvalidPath:
				break;
			default:
				CallS( err );		//	force error to be reported in assert
			}
#endif
		plog->m_critBackupInProgress.Leave();
		return err;
		}

	//	From this point we got a valid ifmp entry. Start the attaching DB process.

	FMP *pfmp;
	pfmp = &rgfmp[ ifmp ];
	
	pfmp->RwlDetaching().EnterAsWriter();
	pfmp->SetAttachingDB( );
	pfmp->RwlDetaching().LeaveAsWriter();

	// backup thread will wait on attach complition from this point
	// as the db is marked as attaching
	plog->m_critBackupInProgress.Leave();

	//	set database loggable flags.

	if ( grbit & JET_bitDbRecoveryOff )
		{
		pfmp->ResetLogOn();
		}
	else
		{
		Assert( pfmp->Dbid() != dbidTemp );
		
		//	set all databases loggable except Temp if not specified in grbit
		//
		pfmp->SetLogOn();
		}

	// Can only turn versioning off for CreateDatabase().
	// UNDONE:  Is it useful to allow user to turn versioning off for AttachDatabase()?

	Assert( !pfmp->FVersioningOff() );
	pfmp->ResetVersioningOff();

	//	Set up FMP before logging

	if ( grbit & JET_bitDbReadOnly )
		{
		pfmp->ResetLogOn();
		pfmp->SetVersioningOff();
		pfmp->SetReadOnlyAttach();
		}
	else
		{
		pfmp->ResetReadOnlyAttach();
		}
	
	pfmp->SetDatabaseSizeMax( cpgDatabaseSizeMax );

	//	Make sure the database is a good one

	Assert( UtilCmpFileName( pfmp->SzDatabaseName(), szDbFullName ) == 0 );
	Assert( !(grbit & JET_bitDbReadOnly) == !rgfmp[ifmp].FReadOnlyAttach() );
	Call( ErrDBReadHeaderCheckConsistency( pfsapi, pfmp ) );
	pdbfilehdr = pfmp->Pdbfilehdr();
	Assert( NULL != pdbfilehdr );

	//	verify db matches SLV file, if any
	if ( NULL != szSLVFullName )
		{
		Assert ( !fGlobalRepair );
		if ( pdbfilehdr->FSLVExists() )
			{
			IFileAPI *	pfapiT;

			Assert( NULL != pfmp->SzSLVName() );
			Assert( NULL == pslvfilehdr );
			Assert( !(grbit & JET_bitDbReadOnly) == !pfmp->FReadOnlyAttach() );

			pslvfilehdr = (SLVFILEHDR *)PvOSMemoryPageAlloc( g_cbPage, NULL );
			if ( NULL == pslvfilehdr )
				{
				Call( ErrERRCheck( JET_errOutOfMemory ) );
				}

			Call( pfsapi->ErrFileOpen( pfmp->SzSLVName(), &pfapiT, pfmp->FReadOnlyAttach() ) )

			err = ErrSLVReadHeader(
						pfsapi,
						pfmp->FReadOnlyAttach(),
						pfmp->SzSLVName(),
						pfmp->Pdbfilehdr(),
						pslvfilehdr,
						pfapiT );

			delete pfapiT;

			Call( err );
			}
		else
			{
			//	db doesn't believe an SLV should exist, but it does
			//		- either the client specified an SLV to AttachDatabase()
			//		  or he didn't specify one, but an SLV file with the
			//		  same base name exists (to minimise confusion, we
			//		  don't allow this)
			Call( ErrERRCheck( JET_errDatabaseStreamingFileMismatch ) );
			}
		}
	else if ( fGlobalRepair )
		{
		//  we don't ever want to attach to the SLV during repair
		}
	else if ( pdbfilehdr->FSLVExists() )
		{
		Assert( NULL == pfmp->SzSLVName() );
		Call( ErrERRCheck( JET_errSLVStreamingFileMissing ) );
		}

	if ( !plog->m_fLogDisabled
		&& 0 == memcmp( &pdbfilehdr->signLog, &plog->m_signLog, sizeof(SIGNATURE) ) )
		{
#if 0	//	UNDONE: This logic detects if we are trying to detect a database that
		//	is too far in the future.  Re-enable this code when test scripts
		//	can properly handle this
		if ( CmpLgpos( &pdbfilehdr->lgposAttach, &plog->m_lgposLogRec ) > 0
			|| CmpLgpos( &pdbfilehdr->lgposConsistent, &plog->m_lgposLogRec ) > 0 )
			{
			//	something is gravely wrong - the current lgposAttach
			//	and/or lgposConsistent are ahead of the current log position
			AssertTracking();
			Call( ErrERRCheck( JET_errConsistentTimeMismatch ) );
			}
#endif			
		}

	BOOL fUpgradeFormat;
	fUpgradeFormat = FDBUpgradeFormat( pdbfilehdr );

	if( fUpgradeFormat && !fForUpgrade )
		{
		Call( ErrERRCheck( JET_errInvalidDatabaseVersion ) );
		}
		
	if( fUpgradeFormat && pfmp->FReadOnlyAttach() )
		{
		Call( ErrERRCheck( JET_errDatabaseFileReadOnly ) );
		}
	
	fForceUpgrade = ( !plog->m_fRecovering
					&& fGlobalIndexChecking
					&& FDBUpgradeForLocalization( pdbfilehdr ) );
	if ( fForceUpgrade )
		pdbfilehdr->SetUpgradeDb();

	//	update header if upgrade needed
	if ( !pfmp->FReadOnlyAttach() )
		{
#ifdef INDEPENDENT_DB_FAILURE
		//	remember old header in case we need to revert to it
		pdbfilehdrRevert = (DBFILEHDR *) PvOSMemoryPageAlloc( g_cbPage, NULL );
		if ( NULL == pdbfilehdrRevert )
			{
			Call( JET_errOutOfMemory );
			}
		memcpy( pdbfilehdrRevert, pdbfilehdr, sizeof( DBFILEHDR ) );
#endif

		//	log Attach
		Assert( pfmp == &rgfmp[ifmp] );
		Assert( pfmp->Pdbfilehdr() == pdbfilehdr );
		Assert( UtilCmpFileName( szDbFullName, pfmp->SzDatabaseName() ) == 0 );
		Assert( ( NULL == szSLVFullName && NULL == pfmp->SzSLVName() )
			|| UtilCmpFileName( szSLVFullName, pfmp->SzSLVName() ) == 0 );
		Assert( ( NULL == szSLVRootName && NULL == pfmp->SzSLVRoot() )
			|| UtilCmpFileName( szSLVRootName, pfmp->SzSLVRoot() ) == 0 );
		Assert( pfmp->CpgDatabaseSizeMax() == cpgDatabaseSizeMax );
		Call( ErrLGAttachDB(
				ppib,
				ifmp,
				&lgposLogRec ) );

		attachState = ATTACH_LOGGED;

		//	Update database state to be inconsistent
		DBISetHeaderAfterAttach( pdbfilehdr, lgposLogRec, ifmp, fFalse ); // do not keep bkinfo
		Assert( pdbfilehdr->le_objidLast );

		if ( !fGlobalRepair && pdbfilehdr->FSLVExists() )
			{
			Assert( NULL != szSLVFullName );
			Assert( NULL != pslvfilehdr );
			Assert( NULL != pfmp->SzSLVName() );

			Call( ErrSLVSyncHeader(	pfsapi, 
									rgfmp[ifmp].FReadOnlyAttach(),
									rgfmp[ifmp].SzSLVName(),
									pdbfilehdr,
									pslvfilehdr ) );
			attachState = ATTACH_SLV_UPDATED;
				
			}
		else
			{
			Assert( NULL == szSLVFullName );
			Assert( NULL == pslvfilehdr );
			Assert( NULL == pfmp->SzSLVName() );
			}
					
		Call( ErrUtilWriteShadowedHeader(
					pfsapi, 
					szDbFullName,
					fTrue,
					(BYTE*)pdbfilehdr,
					g_cbPage ) );

		attachState = ATTACH_DB_UPDATED;
		}
	else
		{
		Assert( pfmp->FReadOnlyAttach() );
		}

	OSMemoryPageFree( (VOID *)pslvfilehdr );
	pslvfilehdr = NULL;
		
	Call( ErrIOOpenDatabase( pfsapi, ifmp, szDbFullName ) );

	//	if we fail after this, we must close the db
	attachState = ATTACH_DB_OPENED;

#ifdef INDEPENDENT_DB_FAILURE
	OSMemoryPageFree( (VOID *)pdbfilehdrRevert );
	pdbfilehdrRevert = NULL;
#endif

	//	Make the database attached.

	Assert( !( pfmp->FAttached() ) );
	pfmp->SetAttached();

	Assert (! pfmp->FAllowHeaderUpdate() );	
	pfmp->RwlDetaching().EnterAsWriter();
	pfmp->SetAllowHeaderUpdate();
	pfmp->RwlDetaching().LeaveAsWriter();
	
	pfmp->SetDbtimeOldestGuaranteed( pfmp->DbtimeLast() );
	pfmp->SetDbtimeOldestCandidate( pfmp->DbtimeLast() );
	pfmp->SetDbtimeOldestTarget( pfmp->DbtimeLast() );
	pfmp->SetTrxOldestCandidate( pinst->m_trxNewest );
	pfmp->SetTrxOldestTarget( trxMax );

	if( fUpgradeFormat )
		{
		Call( ErrDBUpgradeFormat( ppib, ifmp, grbit ) );
		}

	//	preread the first 16 pages of the database
	BFPrereadPageRange( ifmp, 1, 16, NULL );

	//	set the last page of the database (ulFileSizeLow), used to prevent over preread.
	//	must call after setting ReadOnly flag because opening SLV uses it	
	Call( ErrDBSetLastPageAndOpenSLV( pfsapi, ppib, ifmp, pdbfilehdr->FSLVExists() && !fGlobalRepair ) );

	//	Make the fmp available for others to open etc.
	pfmp->RwlDetaching().EnterAsWriter();
	pfmp->ResetAttachingDB();
	pfmp->ReleaseWriteLatch( ppib );
	pfmp->RwlDetaching().LeaveAsWriter();

	err = JET_errSuccess;

	if ( fForceUpgrade )
		{
		CallR( ErrDBUpgradeForLocalisation( ppib, ifmp, grbit ) );
		Assert( JET_wrnCorruptIndexDeleted == err || JET_errSuccess == err );
		}

#ifdef FORCE_ONLINE_DEFRAG
	if ( !plog->m_fRecovering && pfmp->FLogOn() )
		{
		Assert( !pfmp->FVersioningOff() );
		Assert( !pfmp->FReadOnlyAttach() );
		CallS( ErrOLDDefragment( ifmp, NULL, NULL, NULL, NULL, JET_bitDefragmentBatchStart ) );
		}
#endif

#ifdef FORCE_ONLINE_SLV_DEFRAG
	if ( !plog->m_fRecovering && pfmp->FLogOn() && pfmp->FSLVAttached() )
		{
		Assert( !pfmp->FVersioningOff() );
		Assert( !pfmp->FReadOnlyAttach() );
		CallS( ErrOLDDefragment( ifmp, NULL, NULL, NULL, NULL, JET_bitDefragmentSLVBatchStart ) );
		}
#endif	//	FORCE_ONLINE_SLV_DEFRAG

	return err;

HandleError:
	Assert( err < 0 );

#ifdef INDEPENDENT_DB_FAILURE		
	BOOL	fDetached	= fFalse;
	if ( attachState != ATTACH_NONE )
		{
		ERR errOriginal = err;
		switch ( attachState )
			{
			case ATTACH_DB_OPENED:
				{
				ERR errT;
				Assert( pfmp->FAttached() );
				errT = ErrIsamDetachDatabase( sesid, NULL, szDbFullName );
				if ( errT < 0 )
					{
					Assert( UtilCmpFileName( szDbFullName, rgfmp[ifmp].SzDatabaseName() ) == 0 );
					if ( JET_dbstateConsistent != pfmp->Pdbfilehdr()->Dbstate() )
						{
						errT = ErrLGForceDetachDB( ppib, ifmp, 0, &lgposLogRec );
						Assert( errT >= 0 || PinstFromIfmp( ifmp )->m_plog->m_fLGNoMoreLogWrite );
						}
					err = ErrERRCheck( JET_errPartiallyAttachedDB );
					}
				else
					{
					fDetached = fTrue;
					}
				break;	
				}
			default:
				Assert( fFalse );
				
			case ATTACH_LOGGED:
				//	Failed on database header update
				if ( !pdbfilehdr->FSLVExists() )
					{
			case ATTACH_SLV_UPDATED:
					// try to fix only if no FileAccessDenied. Otherwise we couldn't have updated DB header at all
					if ( JET_errFileAccessDenied != errOriginal )
						{
						err = ErrUtilReadShadowedHeader( pfsapi, szDbFullName, (BYTE*)pdbfilehdr, g_cbPage, OffsetOf( DBFILEHDR, le_cbPageSize ) );
						if ( JET_errSuccess == err )
							{
							//	If db header is updated try to revert it
							if ( 0 != memcmp( pdbfilehdr, pdbfilehdrRevert, sizeof( DBFILEHDR ) ) )
								{
				case ATTACH_DB_UPDATED:
								//	revert of db header
								memcpy( pdbfilehdr, pdbfilehdrRevert, sizeof( DBFILEHDR ) );
								err = ErrUtilWriteShadowedHeader( pfsapi, szDbFullName, fTrue, (BYTE*)pdbfilehdr, g_cbPage );
								if ( JET_errSuccess != err )
									{
									ERR errT;
									//	Read new status
									errT = ErrUtilReadShadowedHeader( pfsapi, szDbFullName, (BYTE*)pdbfilehdr, g_cbPage, OffsetOf( DBFILEHDR, le_cbPageSize) );
									//	If databasa header is reverted
									if ( JET_errSuccess == errT && 0 == memcmp( pdbfilehdr, pdbfilehdrRevert, sizeof( DBFILEHDR ) ) )
										{
										err = JET_errSuccess;
										}
	  								}
								}
							}
						}
					else
						{
						err = JET_errSuccess;
						}
 					}
				else
					{
					//	Revert SLV update only if the error is not FileAccessDenied. Otherwise we didn't update the header at all
					if ( JET_errFileAccessDenied != errOriginal )
						{
						err = JET_errSuccess;
						}
					}

				if ( pdbfilehdr->FSLVExists() && JET_errSuccess == err )
					{
					// try to revert SLV header
					memcpy( pdbfilehdr, pdbfilehdrRevert, sizeof( DBFILEHDR ) );
					(VOID)ErrSLVSyncHeader(	pfsapi, 
											rgfmp[ifmp].FReadOnlyAttach(),
											rgfmp[ifmp].SzSLVName(),
											pdbfilehdr,
											pslvfilehdr );
					}

				err = ErrERRCheck( JET_errPartiallyAttachedDB );
					{
					ERR errT;
					Assert( UtilCmpFileName( szDbFullName, rgfmp[ifmp].SzDatabaseName() ) == 0 );
					errT = ErrLGForceDetachDB( ppib, ifmp, fLRForceDetachRevertDBHeader, &lgposLogRec );
					Assert( errT >= 0 || PinstFromIfmp( ifmp )->m_plog->m_fLGNoMoreLogWrite );
					}
				break;
			}
		if ( err == JET_errPartiallyAttachedDB )
			{
			DBReportPartiallyAttachedDb( szDbFullName, attachState, errOriginal );
			}
		}

#else

	const BOOL	fDetached	= fFalse;

	if ( attachState != ATTACH_NONE )
		{
		//	we have to take the instance offline if there is an error
		//	during attach and the attach is logged
		Assert( err < JET_errSuccess );
		PinstFromPpib( ppib )->SetFInstanceUnavailable();
		ppib->SetErrRollbackFailure( err );
		DBReportPartiallyAttachedDb( szDbFullName, attachState, err );
		}

#endif	//	INDEPENDENT_DB_FAILURE

	Assert( pfmp->CrefWriteLatch() == 1 );
	if ( !fDetached )
		{
		if ( FIODatabaseOpen( ifmp ) )
			{
			BFPurge( ifmp );
			BFPurge( ifmp | ifmpSLV );

			IOCloseDatabase( ifmp );
			}

		FMP::EnterCritFMPPool();
		pfmp->RwlDetaching().EnterAsWriter();
		DBResetFMP(  pfmp, plog, fFalse );
		pfmp->ReleaseWriteLatchAndFree( ppib );
		pfmp->RwlDetaching().LeaveAsWriter();
		FMP::LeaveCritFMPPool();
		}
	else
		{
#ifdef INDEPENDENT_DB_FAILURE
		//	UNDONE: this won't work, because the fmp has already been released
		Assert( fFalse );
		pfmp->RwlDetaching().EnterAsWriter();
		pfmp->ReleaseWriteLatch( ppib );
		pfmp->RwlDetaching().LeaveAsWriter();
#endif		
		}

#ifdef INDEPENDENT_DB_FAILURE
	OSMemoryPageFree( (VOID *)pdbfilehdrRevert );
#endif

	OSMemoryPageFree( (VOID *)pslvfilehdr );

	return err;
	}

ERR ErrDBUpgradeDatabase(
	JET_SESID	sesid,
	const CHAR	*szDatabaseName,
	const CHAR	*szSLVName,
	JET_GRBIT	grbit )
	{
	ERR			err;
	PIB			*ppib					= PpibFromSesid( sesid );
	IFMP		ifmp;
	FMP 		*pfmp					= NULL;
	DBFILEHDR 	*pdbfilehdr				= NULL;
	SLVFILEHDR	*pslvfilehdr			= NULL;
	CHAR		rgchDbFullName[IFileSystemAPI::cchPathMax];
	CHAR		rgchSLVFullName[IFileSystemAPI::cchPathMax];
	CHAR		rgchSLVRootName[IFileSystemAPI::cchPathMax];
	CHAR		*szDbFullName			= rgchDbFullName;
	CHAR		*szSLVFullName			= rgchSLVFullName;
	CHAR		*szSLVRootName			= rgchSLVRootName;
	BOOL		fNeedToAddSLVFile		= fFalse;
	BOOL		fSLVAttached			= fFalse;
	BOOL		fOpenedDb				= fFalse;
	BOOL		fAttachLogged			= fFalse;
	const BOOL	fNeedFormatUpgrade		= fFalse;	//	UNDONE: unsupported
	
	//	check parameters
	//
	Assert( sizeof(JET_SESID) == sizeof(PIB *) );

	CallR( ErrPIBCheck( ppib ) );

	if ( ppib->level > 0 )
		return ErrERRCheck( JET_errInTransaction );

	if ( NULL == szDatabaseName || 0 == *szDatabaseName )
		return ErrERRCheck( JET_errDatabaseInvalidPath );

	INST				*pinst					= PinstFromPpib( ppib );

	Assert( !pinst->FRecovering() );

	LOG					*plog					= pinst->m_plog;

	//	this never gets called on a the temp database (e.g. we do not need to force the OS file-system)

	IFileSystemAPI	*pfsapi 					= pinst->m_pfsapi;
	
	Assert( szDbFullName == rgchDbFullName );
	Assert( szSLVFullName == rgchSLVFullName );

	//	depend on ErrPathComplete to make same files same name
	//	thereby preventing same file to be multiply attached
	err = ErrUtilPathComplete( pfsapi, szDatabaseName, szDbFullName, fTrue );
	switch ( err )
		{
		case JET_errInvalidPath:
			err = ErrERRCheck( JET_errDatabaseInvalidPath );
			break;
		case JET_errFileNotFound:
			err = ErrERRCheck( JET_errDatabaseNotFound );
			break;
		default:
			break;
		}
	CallR( err );

	if ( NULL != szSLVName && 0 != *szSLVName )
		{
		err = ErrUtilPathComplete( pfsapi, szSLVName, szSLVFullName, fFalse );
		Assert( JET_errFileNotFound != err );
		CallR( JET_errInvalidPath == err ? ErrERRCheck( JET_errSLVInvalidPath ) : err );
		fNeedToAddSLVFile = fTrue;
		}
	else
		{
		szSLVFullName = NULL;
		}

	Assert( !fNeedToAddSLVFile || szSLVFullName != NULL );
	
	BOOL	fReadOnly;
	CallR( ErrUtilPathReadOnly( pfsapi, szDbFullName, &fReadOnly ) );
	if ( fReadOnly )
		{
		err = ErrERRCheck( JET_errDatabaseFileReadOnly );
		return err;
		}
	
	plog->m_critBackupInProgress.Enter();
	
	if ( plog->m_fBackupInProgress )
		{
		plog->m_critBackupInProgress.Leave();
		return ErrERRCheck( JET_errBackupInProgress );
		}

	//	auto-generate root name -- it doesn't matter what
	//	it is because we'll be detaching at the end of this
	//	function anyways
	DBGetSLVNameFromDbName( pinst, pfsapi, szDbFullName, NULL, szSLVRootName );

	err = FMP::ErrNewAndWriteLatch( &ifmp, szDbFullName, szSLVFullName, szSLVRootName, ppib, pinst, pfsapi, dbidMax );
	if ( err != JET_errSuccess )
		{
		switch ( err )
			{
			case JET_wrnDatabaseAttached:
				err = ErrERRCheck( JET_errDatabaseInUse );
			case JET_errOutOfMemory:
			case JET_errDatabaseInUse:
			case JET_errTooManyAttachedDatabases:
			case JET_errDatabaseSharingViolation:
			case JET_errDatabaseInvalidPath:
			case JET_errSLVInvalidPath:
				break;
			default:
				CallS( err );
			}

		plog->m_critBackupInProgress.Leave();
		return err;
		}

	//	From this point we got a valid ifmp entry. Start the attaching DB process.

	pfmp = &rgfmp[ ifmp ];
	
	pfmp->SetCreatingDB();

	plog->m_critBackupInProgress.Leave();

	//	set database loggable flags.

	Assert( pfmp->Dbid() != dbidTemp );
		
	if ( grbit & JET_bitDbRecoveryOff )
		{
		pfmp->ResetLogOn();
		}
	else
		{
		//	set all databases loggable except Temp if not specified in grbit
		//
		pfmp->SetLogOn();
		}
		
	pfmp->SetDatabaseSizeMax( 0 );

	//	Make sure the database is a good one

	Assert( UtilCmpFileName( pfmp->SzDatabaseName(), szDbFullName ) == 0 );
	Assert( !rgfmp[ifmp].FReadOnlyAttach() );
	Call( ErrDBReadHeaderCheckConsistency( pfsapi, pfmp ) );

	Assert( NULL != pfmp->Pdbfilehdr() );
	Assert( NULL == pdbfilehdr );

	pdbfilehdr = pfmp->Pdbfilehdr();

	if ( NULL != szSLVFullName )
		{
		Assert( fNeedToAddSLVFile );
		err = ErrUtilPathExists( pfsapi, szSLVFullName );
		if ( err < 0 )
			{
			if ( JET_errFileNotFound != err )
				{
				Call( err );
				}
			if ( pdbfilehdr->FSLVExists() )
				{
				//	db thinks an SLV file should already exist for this database,
				//	but we couldn't find it
				Call( ErrERRCheck( JET_errSLVStreamingFileMissing ) );
				}
			}
		else
			{
			IFileAPI *	pfapiT;
			BOOL		fReadOnly;

			Call( ErrUtilPathReadOnly( pfsapi, szSLVFullName, &fReadOnly ) );
			if ( fReadOnly )
				{
				Call( ErrERRCheck( JET_errSLVStreamingFileReadOnly ) );
				}

			Assert( NULL != pfmp->SzSLVName() );
			Assert( NULL == pslvfilehdr );
			pslvfilehdr = (SLVFILEHDR *)PvOSMemoryPageAlloc( g_cbPage, NULL );
			if ( NULL == pslvfilehdr )
				{
				Call( ErrERRCheck( JET_errOutOfMemory ) );
				}

			Call( pfsapi->ErrFileOpen( pfmp->SzSLVName(), &pfapiT, fFalse ) );

			err = ErrSLVReadHeader(	pfsapi,
									fFalse,
									pfmp->SzSLVName(),
									pfmp->Pdbfilehdr(),
									pslvfilehdr,
									pfapiT );

			delete pfapiT;

			if ( err < 0 )
				{
				if ( err != JET_errDatabaseStreamingFileMismatch
					|| pdbfilehdr->FSLVExists()
					|| CmpLgpos( &pslvfilehdr->le_lgposAttach, &pdbfilehdr->le_lgposAttach ) != 0
					|| memcmp( &pslvfilehdr->signDb, &pdbfilehdr->signDb, sizeof( SIGNATURE ) ) != 0 )
					{
					OSMemoryPageFree( (VOID *)pslvfilehdr );
					pslvfilehdr = NULL;
					Call( err );
					}
				err = JET_errSuccess;
				Assert( !pdbfilehdr->FSLVExists() );
				
				// we will recreate an slv file again
				
				Call( pfsapi->ErrFileDelete( pfmp->SzSLVName() ) );
				}
			else
				{
				Assert( pdbfilehdr->FSLVExists() );
				fNeedToAddSLVFile = fFalse;
				} 
			Assert( 0 <= err );
			}
		}
	else
		{
		Assert( !fNeedToAddSLVFile );
		if ( pdbfilehdr->FSLVExists() )
			{
			Assert( NULL == pfmp->SzSLVName() );
			Call( ErrERRCheck( JET_errSLVStreamingFileMissing ) );
			}
		}

	Assert( !fNeedToAddSLVFile || !pdbfilehdr->FSLVExists() );

	if ( !fNeedToAddSLVFile && !fNeedFormatUpgrade )
		{
		Call( ErrERRCheck( JET_errDatabaseAlreadyUpgraded ) );
		}

	LGPOS lgposLogRec;
	Assert( pfmp == &rgfmp[ifmp] );
	Assert( pfmp->Pdbfilehdr() == pdbfilehdr );
	Assert( UtilCmpFileName( szDbFullName, pfmp->SzDatabaseName() ) == 0 );
	Assert( ( NULL == szSLVFullName && NULL == pfmp->SzSLVName() )
		|| UtilCmpFileName( szSLVFullName, pfmp->SzSLVName() ) == 0 );
	Assert( ( NULL == szSLVRootName && NULL == pfmp->SzSLVRoot() )
		|| UtilCmpFileName( szSLVRootName, pfmp->SzSLVRoot() ) == 0 );
	Assert( pfmp->CpgDatabaseSizeMax() == 0 );
	Call( ErrLGAttachDB( 
					ppib, 
					ifmp, 
					&lgposLogRec ) );
	fAttachLogged = fTrue;

	DBISetHeaderAfterAttach( pdbfilehdr, lgposLogRec, ifmp, fFalse );

	Assert( pdbfilehdr->le_objidLast > 0 );

	if ( fNeedFormatUpgrade )
		{
		if ( pdbfilehdr->FSLVExists() )
			{
			Assert( NULL != pslvfilehdr );
			Assert( !fNeedToAddSLVFile );
			Assert( NULL != pfmp->SzSLVName() );

			Call( ErrSLVSyncHeader(	pfsapi, 
									rgfmp[ifmp].FReadOnlyAttach(),
									rgfmp[ifmp].SzSLVName(),
									pdbfilehdr, 
									pslvfilehdr ) );
			}
		}
	else
		{
		Assert( !pdbfilehdr->FSLVExists() );
		}

	Call( ErrUtilWriteShadowedHeader(
				pfsapi, 
				szDbFullName,
				fTrue,
				(BYTE*)pdbfilehdr,
				g_cbPage ) );
		
	if ( NULL != pslvfilehdr )
		{
		OSMemoryPageFree( (VOID *)pslvfilehdr );
		pslvfilehdr = NULL;
		}

	//	Make the database attached.
	Assert( !( pfmp->FAttached() ) );
	pfmp->SetAttached();
	
	Call( ErrIOOpenDatabase( pfsapi, ifmp, szDbFullName ) );
	DBSetOpenDatabaseFlag( ppib, ifmp );

	Assert (! pfmp->FAllowHeaderUpdate() );	
	pfmp->RwlDetaching().EnterAsWriter();
	pfmp->SetAllowHeaderUpdate();
	pfmp->RwlDetaching().LeaveAsWriter();
	fOpenedDb = fTrue;

	pfmp->SetDbtimeOldestGuaranteed( pfmp->DbtimeLast() );
	pfmp->SetDbtimeOldestCandidate( pfmp->DbtimeLast() );
	pfmp->SetDbtimeOldestTarget( pfmp->DbtimeLast() );
	pfmp->SetTrxOldestCandidate( pinst->m_trxNewest );
	pfmp->SetTrxOldestTarget( trxMax );

	if ( fNeedToAddSLVFile )
		{
		Assert( NULL != pfmp->SzSLVName() );
		Assert( !pfmp->FSLVAttached() );
		Assert( !pdbfilehdr->FSLVExists() );
		pdbfilehdr->SetSLVExists();
		pdbfilehdr->signSLV = pdbfilehdr->signDb;

		// Check the catalog
		// if we have already set slv record in catalog we will only recreate an SLV file
		
		PGNO pgno;
		OBJID objidSLV;
		
		err = ErrCATAccessDbSLVAvail( ppib, ifmp, szSLVAvail, &pgno, &objidSLV );
		if ( err >= 0 )
			{
			err = ErrFILECreateSLV( pfsapi, ppib, ifmp, SLV_CREATESLV_CREATE );
			}
		else
			{
			err =  ErrFILECreateSLV( pfsapi, ppib, ifmp, SLV_CREATESLV_CREATE | SLV_CREATESLV_ATTACH );
			}

		if ( 0 > err )
			{
			pdbfilehdr->ResetSLVExists();
			memset ( &pdbfilehdr->signSLV, 0, sizeof( SIGNATURE ) );
			Call( err );
			}
		fSLVAttached = fTrue;

		// update DB header to mark successfull end of SLV file creation
		Call( ErrUtilWriteShadowedHeader(
						pfsapi, 
						szDbFullName,
						fTrue,
						(BYTE*)pdbfilehdr,
						g_cbPage,
						pfmp->Pfapi() ) );

		Assert( !pfmp->FSLVAttached() );

		}
	else
		{
		Assert( fNeedFormatUpgrade );
		}

	Assert( pfmp->FWriteLatchByMe( ppib ) );

	DBResetOpenDatabaseFlag( ppib, ifmp );
	fOpenedDb = fFalse;

	//	Make the fmp available for detach
	pfmp->RwlDetaching().EnterAsWriter();
	pfmp->ResetCreatingDB();
	pfmp->ReleaseWriteLatch( ppib );
	pfmp->RwlDetaching().LeaveAsWriter();

	err = ErrIsamDetachDatabase(
				SesidFromPpib( ppib ),
				NULL,
				szDbFullName,
				fSLVAttached ? fLRForceDetachCreateSLV : 0 );
	if ( err < 0 && JET_errSuccess == ppib->ErrRollbackFailure() )
		{
		pinst->SetFInstanceUnavailable();
		ppib->SetErrRollbackFailure( err );
		}

	return err;


HandleError:
	Assert( err < 0 );
	const BOOL	fDetached	= fFalse;

	if ( pslvfilehdr != NULL )
		{
		OSMemoryPageFree( (VOID *)pslvfilehdr );
		pslvfilehdr = NULL;
		}

	if ( fAttachLogged )
		{
		if ( fOpenedDb )
			{
			DBResetOpenDatabaseFlag( ppib, ifmp );
			}

#ifdef INDEPENDENT_DB_FAILURE			
		ERR errT = ErrIsamDetachDatabase( SesidFromPpib( ppib ), NULL, szDbFullName, fSLVAttached ? fLRForceDetachCreateSLV: 0 );
		if ( errT < 0 && JET_dbstateConsistent != rgfmp[ifmp].Pdbfilehdr()->Dbstate() )
			{
			Assert( UtilCmpFileName( szDbFullName, rgfmp[ifmp].SzDatabaseName() ) == 0 );
			errT = ErrLGForceDetachDB( ppib, ifmp, (BYTE)(fSLVAttached? fLRForceDetachCreateSLV: 0), &lgposLogRec );
			Assert( errT >= 0 || PinstFromIfmp( ifmp )->m_plog->m_fLGNoMoreLogWrite );
			}
		else
			{
			fDetached = fTrue;
			}
		err = ( errT < 0 && err >= 0 ? errT : err );
#else
		pinst->SetFInstanceUnavailable();
		ppib->SetErrRollbackFailure( err );
#endif
		}

	Assert( pfmp->CrefWriteLatch() == 1 );

	if ( !fDetached )
		{
		if ( FIODatabaseOpen( ifmp ) )
			{
			BFPurge( ifmp );
			BFPurge( ifmp | ifmpSLV );

			IOCloseDatabase( ifmp );
			}

		FMP::EnterCritFMPPool();
		pfmp->RwlDetaching().EnterAsWriter();
		DBResetFMP(  pfmp, plog, fFalse );
		pfmp->ReleaseWriteLatchAndFree( ppib );
		pfmp->RwlDetaching().LeaveAsWriter();
		FMP::LeaveCritFMPPool();
		}
	else
		{
#ifdef INDEPENDENT_DB_FAILURE
		//	UNDONE: this won't work, because the fmp has already been released
		Assert( fFalse );
		Assert( NULL == pfmp->Pdbfilehdr() );
		pfmp->RwlDetaching().EnterAsWriter();
		pfmp->ReleaseWriteLatch( ppib );
		pfmp->RwlDetaching().LeaveAsWriter();
#endif		
		}
		
	return err;
	}


VOID DBResetFMP( FMP *pfmp, LOG *plog, BOOL fDetaching )
	{
	if ( pfmp->FSkippedAttach() )
		{
		Assert( NULL != plog );
		Assert( plog->m_fHardRestore );
		pfmp->ResetSkippedAttach();
		}
	else if ( pfmp->FDeferredAttach() )
		{
		Assert( NULL != plog );
		Assert( plog->m_fRecovering );
		pfmp->ResetDeferredAttach();
		}
	else
		{
		FCB::DetachDatabase( pfmp - rgfmp, fDetaching );
		}

	pfmp->ResetAttached();
#ifdef DEBUG
	pfmp->SetDatabaseSizeMax( 0xffffffff );
#endif
	pfmp->ResetExclusiveOpen( );
	pfmp->ResetLogOn();
	pfmp->ResetReadOnlyAttach();
	pfmp->ResetVersioningOff();

	//	indicate this db entry is detached.
	 
	if ( pfmp->Pdbfilehdr() )
		{
		if ( NULL != plog && 
			 plog->m_fRecovering &&
			 plog->m_fRecoveringMode == fRecoveringRedo &&
			 pfmp->Patchchk() )
			{
			Assert( pfmp->Patchchk() );
			OSMemoryHeapFree( pfmp->Patchchk() );
			pfmp->SetPatchchk( NULL );
			}

		pfmp->FreePdbfilehdr();
		}
	
	//	rgfmp[ifmp].szDatabaseName will be released within critFMPPool.
	//	other stream resources will be released within write latch.


#ifdef ELIMINATE_PATCH_FILE
#else
	if ( pfmp->SzPatchPath() )
		{
		Assert( plog->m_fRecovering );
		Assert( plog->m_fHardRestore );
		delete pfmp->PfapiPatch();
		pfmp->SetPfapiPatch( NULL );
		OSMemoryHeapFree( pfmp->SzPatchPath() );
		pfmp->SetSzPatchPath( NULL );
		}
#endif

	//	clean up fmp for future use

	Assert( !pfmp->Pfapi() );

	//	Free the FMP entry.

	pfmp->ResetDetachingDB();
	}	


#ifdef INDEPENDENT_DB_FAILURE
//	szDatabaseName of NULL detaches all user databases.  
//
ERR ISAMAPI ErrIsamForceDetachDatabase( JET_SESID sesid, const CHAR *szDatabaseName, const JET_GRBIT grbit )
	{
	ERR		err = JET_errSuccess;
	PIB		*ppib = NULL;
	IFMP   	ifmp = ifmpMax;
	CHAR   	rgchFullName[IFileSystemAPI::cchPathMax];
	CHAR   	*szFullName = NULL;
	CHAR   	*szFileName = NULL;
	LGPOS	lgposLogRec;
	INST * pinst =  PinstFromPpib( (PIB *)sesid );
	FMP *pfmp = NULL;
	LOG * plog = NULL;
	BOOL fFMPLatched = fFalse;
	BOOL fForceClose = JET_bitForceCloseAndDetach & grbit;

	//	this should not be called on the temp database (it's ok to use the regular file-system)

	// just find full the database name, don't try to open the file
	Assert ( pinst );
	CallS ( pinst->m_pfsapi->ErrPathComplete( szDatabaseName, rgchFullName ) );
	
// find the instance owning the database
	FMP::EnterCritFMPPool();
	for ( IFMP ifmpT = FMP::IfmpMinInUse(); ifmpT <= FMP::IfmpMacInUse(); ifmpT++ )
		{
		FMP	* pfmp = &rgfmp[ ifmpT ];

		if ( !pfmp->FInUse() )
			{
			continue;
			}
			
		if ( 0 != UtilCmpFileName( pfmp->SzDatabaseName(), rgchFullName ) )
			{
			continue;
			}

		ifmp = ifmpT;
		break;
		}			
	FMP::LeaveCritFMPPool();

	if ( ifmpMax == ifmp )
		{
		CallR ( ErrERRCheck( JET_errDatabaseNotFound) );
		}
		
	szFullName = rgchFullName;
	
	pfmp = &rgfmp[ ifmp ];
	Assert ( pinst == PinstFromIfmp( ifmp ) );
	plog = pinst->m_plog;

	if ( !pfmp->FAllowForceDetach() ) 
		{
		CallR ( ErrERRCheck( JET_errForceDetachNotAllowed) );		
		}
		
	Assert ( NULL != pinst );
	
	CallR ( ErrPIBBeginSession( pinst, &ppib, procidNil, fFalse ) );

	Call( FMP::ErrWriteLatchByNameSz( szFullName, &ifmpT, ppib ) );
	fFMPLatched = fTrue;
	Assert ( ifmpT == ifmp );
		
	Assert( !pfmp->FDetachingDB( ) );

	pfmp->SetForceDetaching();
	
#ifdef FORCE_ONLINE_DEFRAG
	if ( !plog->m_fRecovering && pfmp->FLogOn() )
		{
		Assert( !pfmp->FVersioningOff() );
		Assert( !pfmp->FReadOnlyAttach() );
		pfmp->ReleaseWriteLatch( ppib );
		fFMPLatched = fFalse;
		(VOID) ErrOLDDefragment( ifmp, NULL, NULL, NULL, NULL, JET_bitDefragmentBatchStop );
		Assert( JET_wrnDefragNotRunning == err || JET_errSuccess == err );
		Call( FMP::ErrWriteLatchByNameSz( szFullName, &ifmp, ppib ) );
		fFMPLatched = fTrue;
		pfmp = &rgfmp[ifmp];
		Assert( !pfmp->FDetachingDB( ) );
		}
#endif	

#ifdef FORCE_ONLINE_SLV_DEFRAG
	if ( !plog->m_fRecovering && pfmp->FLogOn() && pfmp->FSLVAttached() )
		{
		Assert( !pfmp->FVersioningOff() );
		Assert( !pfmp->FReadOnlyAttach() );
		pfmp->ReleaseWriteLatch( ppib );
		fFMPLatched = fFalse;
		(VOID) ErrOLDDefragment( ifmp, NULL, NULL, NULL, NULL, JET_bitDefragmentSLVBatchStop );
		Assert( JET_wrnDefragNotRunning == err || JET_errSuccess >= err );
		Call( FMP::ErrWriteLatchByNameSz( szFullName, &ifmp, ppib ) );
		fFMPLatched = fTrue;
		pfmp = &rgfmp[ifmp];
		Assert( !pfmp->FDetachingDB( ) );
		}
#endif	//	FORCE_ONLINE_SLV_DEFRAG	

	if ( pfmp->CPin() && !fForceClose )
		{
		pfmp->ReleaseWriteLatch( ppib );
		fFMPLatched = fFalse;
		Call( ErrERRCheck( JET_errDatabaseInUse ) );
		}

	if ( pfmp->CPin() )
		{
		Assert ( fForceClose );

		PIB * ppibToClean;
		
		pfmp->ReleaseWriteLatch( ppib );
		fFMPLatched = fFalse;
		pinst->m_critPIB.Enter();

		for (ppibToClean = pinst->m_ppibGlobal; ppibToClean; ppibToClean = ppibToClean->ppibNext)
			{
			if ( 0 == ppibToClean->rgcdbOpen[ pfmp->Dbid() ] )
				continue;

			RCE	 * prceNewest	= ppibToClean->prceNewest;

			if ( 1 > ppibToClean->level )
				{
				Assert ( prceNil == prceNewest );
				CallS ( ErrDBCloseDatabase( ppibToClean, ifmp, NO_GRBIT ) );
				continue;
				}

			// if first RCE is not from the database we want to force detach
			// where should be no operations on these DB
			if ( NULL != prceNewest && prceNewest->Ifmp() != ifmp )
				{
				CallS ( ErrDBCloseDatabase( ppibToClean, ifmp, NO_GRBIT ) );
				continue;
				}

			// we have the db opened for these session and 
			// RCEs regardin these database
			// all RCE should be of these database: we will check that 
			// during the rollback process

			Assert ( ifmpMax == ppibToClean->m_ifmpForceDetach );
			ppibToClean->m_ifmpForceDetach = ifmp;
			if ( 1 <= ppibToClean->level )
				{
				pinst->m_critPIB.Leave();
				PIBSetTrxContext( ppibToClean );
				// during force detach, Rollback will clean the the RCE's, etc
				// and we don;t expect any error
				CallS ( ErrIsamRollback( (JET_SESID)ppibToClean, JET_bitForceDetachRollback ) );
				pinst->m_critPIB.Enter();
				}

			Assert ( ppibToClean->level == 0 );
			Assert ( ifmp == ppibToClean->m_ifmpForceDetach );
			ppibToClean->m_ifmpForceDetach = ifmpMax;
			
			CallS ( ErrDBCloseDatabase( ppibToClean, ifmp, NO_GRBIT ) );
			}
		pinst->m_critPIB.Leave();
		
		Call( FMP::ErrWriteLatchByNameSz( szFullName, &ifmp, ppib ) );
		fFMPLatched = fTrue;
		pfmp = &rgfmp[ifmp];
		}

	Assert ( 0 == pfmp->CPin() );

	pinst = PinstFromIfmp( ifmp );
	plog = pinst->m_plog;
	
	Assert ( NULL != pinst );	
	Assert ( pfmp->FAttached( ) );


	//	Enter a critical section to make sure no one, especially the
	//	checkpointer, looking for pdbfilehdr

	//	From this point we got a valid ifmp entry. Start the detaching DB process.

	pfmp->RwlDetaching().EnterAsWriter();
	pfmp->SetDetachingDB( );
	pfmp->RwlDetaching().LeaveAsWriter();
	
	Assert( pfmp->Dbid() != dbidTemp );

	//  Let all tasks active on this database complete
	//  From this point on, no additional tasks should be
	//  registered because:
	//		- OLD has terminated
	//		- the version store has been cleaned up
	//		- the database has been closed so no user actions can be performed
	CallS( pfmp->ErrWaitForTasksToComplete() );	

	// Call RCE clean again, this time to clean versions on this db that
	// we may have missed.
	err = PverFromIfmp( ifmp )->ErrVERRCEClean( ifmp );
	if ( JET_wrnRemainingVersions == err )
		{
		// it means we didn't cleaned all session using the database
		// that's because they are session with RCEs on multiple databases
		// (and the first RCE wasn't on the one we are detaching)
		// we error out with session sharing violation
		EnforceSz ( JET_wrnRemainingVersions != err,
				"Force detach not allowed if sessions are used cross-databases");
		}		
	CallS( err );
	
	Assert ( FIODatabaseOpen( ifmp ) );
	//	purge all buffers for this ifmp
	// PURGE ALL
	BFPurge( ifmp );
	BFPurge( ifmp | ifmpSLV );

	IOCloseDatabase( ifmp );

	//	log detach database
	Assert( pfmp->Dbid() != dbidTemp );
	Assert( UtilCmpFileName( szFullName, rgfmp[ifmp].SzDatabaseName() ) == 0 );
	Call( ErrLGForceDetachDB( ppib, ifmp , fForceClose? fLRForceDetachCloseSessions: (BYTE)0, &lgposLogRec ) );

	Assert (pfmp->FAllowForceDetach() );

	FMP::EnterCritFMPPool();
	pfmp->RwlDetaching().EnterAsWriter();
	DBResetFMP( pfmp, plog, fTrue );
	pfmp->ReleaseWriteLatchAndFree( ppib );
	fFMPLatched = fFalse;
	pfmp->RwlDetaching().LeaveAsWriter();
	FMP::LeaveCritFMPPool();

	PIBEndSession( ppib );

	return JET_errSuccess;

HandleError:

	//	do not reset detaching. We leave the database in detaching
	//	mode till next restore.

	if ( NULL != ppib )
		{
		pfmp->ResetForceDetaching();
		
		Assert ( NULL != pfmp );
		if ( fFMPLatched )
			{
			pfmp->RwlDetaching().EnterAsWriter();
			pfmp->ReleaseWriteLatch( ppib );
			pfmp->RwlDetaching().LeaveAsWriter();
			}
		PIBEndSession( ppib );
		ppib = NULL;
		}
	else
		{
		Assert ( !fFMPLatched );
		}

	return err;
	}

#endif	//	INDEPENDENT_DB_FAILURE
	
LOCAL ERR ErrIsamDetachAllDatabase( JET_SESID sesid, const INT flags )
	{
	ERR					err 		= JET_errSuccess;
	PIB					*ppib 		= PpibFromSesid( sesid );
	INST 				*pinst 		= PinstFromPpib( ppib );

	CallR( ErrPIBCheck( ppib ) );
	Assert ( 0 == ppib->level );

	FMP::EnterCritFMPPool();
	
	for ( DBID dbidDetach = dbidUserLeast; dbidDetach < dbidMax; dbidDetach++ )
		{
		IFMP ifmp = pinst->m_mpdbidifmp[ dbidDetach ];
		if ( ifmp >= ifmpMax )
			continue;
			
		FMP *pfmp = &rgfmp[ ifmp ];
		if ( pfmp->FInUse() && pfmp->FAttached() )
			{
			FMP::LeaveCritFMPPool();

			FMP::AssertVALIDIFMP( pinst->m_mpdbidifmp[ dbidDetach ] );
			Assert ( NULL != rgfmp[ pinst->m_mpdbidifmp[ dbidDetach ] ].SzDatabaseName() );
			Call ( ErrIsamDetachDatabase( sesid, NULL, rgfmp[ pinst->m_mpdbidifmp[ dbidDetach ] ].SzDatabaseName(), flags ) );
			
			FMP::EnterCritFMPPool();
			}
		}	
		
	FMP::LeaveCritFMPPool();

HandleError:
	return err;
	}

//	szDatabaseName of NULL detaches all user databases.  
//
ERR ISAMAPI ErrIsamDetachDatabase( JET_SESID sesid, IFileSystemAPI* const pfsapiDB, const CHAR *szDatabaseName, const INT flags )
	{
	// check parameters
	//
	Assert( sizeof(JET_SESID) == sizeof(PIB *) );
	// there is no unknown flags set
	Assert( (flags & ~(0xf)) == 0 );
	
	ERR					err 		= JET_errSuccess;
	PIB					*ppib 		= PpibFromSesid( sesid );

	CallR( ErrPIBCheck( ppib ) );

	if ( ppib->level > 0 )
		{
		return ErrERRCheck( JET_errInTransaction );
		}

	IFMP   				ifmp 			= ifmpMax;
	FMP					*pfmp 			= NULL;
	DBFILEHDR_FIX 		*pdbfilehdr 	= NULL;
	LGPOS				lgposLogRec;
	INST 				*pinst 			= PinstFromPpib( ppib );
	LOG 				*plog 			= pinst->m_plog;
	BOOL				fInCritBackup	= fFalse;
	BOOL				fDetachLogged	= fFalse;
	CHAR   				szFullName[IFileSystemAPI::cchPathMax];

	if ( pinst->FInstanceUnavailable() )
		{
		return ErrERRCheck( JET_errInstanceUnavailable );
		}
	Assert( JET_errSuccess == ppib->ErrRollbackFailure() );

	//	this should never be called on the temp database (e.g. we do not need to force the OS file-system)

	IFileSystemAPI	*pfsapi			= ( NULL == pfsapiDB ) ? pinst->m_pfsapi : pfsapiDB;

	if ( NULL == szDatabaseName || 0 == *szDatabaseName )
		{
		// this function will go through m_mpdbidifmp and call ErrIsamDetachDatabase for each one
		return ErrIsamDetachAllDatabase( sesid, flags );
		}

	err = ErrUtilPathComplete( pfsapi, szDatabaseName, szFullName, fTrue );
	switch ( err )
		{
		case JET_errFileNotFound:
		case JET_errInvalidPath:
			err = ErrERRCheck( JET_errDatabaseNotFound );
			break;
		}
	CallR( err );

	plog->m_critBackupInProgress.Enter();
	fInCritBackup = fTrue;

	if ( plog->m_fBackupInProgress )
		{
		Call( ErrERRCheck( JET_errBackupInProgress ) );
		}

	Call( FMP::ErrWriteLatchByNameSz( szFullName, &ifmp, ppib ) )
	pfmp = &rgfmp[ ifmp ];
		
	Assert( !pfmp->FDetachingDB( ) );

#ifdef FORCE_ONLINE_DEFRAG
	if ( !plog->m_fRecovering && pfmp->FLogOn() )
		{
		Assert( !pfmp->FVersioningOff() );
		Assert( !pfmp->FReadOnlyAttach() );
		pfmp->ReleaseWriteLatch( ppib );
		Call( ErrOLDDefragment( ifmp, NULL, NULL, NULL, NULL, JET_bitDefragmentBatchStop ) );
		Assert( JET_wrnDefragNotRunning == err || JET_errSuccess == err );
		Call( FMP::ErrWriteLatchByNameSz( szFullName, &ifmp, ppib ) );
		pfmp = &rgfmp[ifmp];
		Assert( !pfmp->FDetachingDB( ) );
		}
#endif	

#ifdef FORCE_ONLINE_SLV_DEFRAG
	if ( !plog->m_fRecovering && pfmp->FLogOn() && pfmp->FSLVAttached() )
		{
		Assert( !pfmp->FVersioningOff() );
		Assert( !pfmp->FReadOnlyAttach() );
		pfmp->ReleaseWriteLatch( ppib );
		Call( ErrOLDDefragment( ifmp, NULL, NULL, NULL, NULL, JET_bitDefragmentSLVBatchStop ) );
		Assert( JET_wrnDefragNotRunning == err || JET_errSuccess == err );
		Call( FMP::ErrWriteLatchByNameSz( szFullName, &ifmp, ppib ) );
		pfmp = &rgfmp[ifmp];
		Assert( !pfmp->FDetachingDB( ) );
		}
#endif	//	FORCE_ONLINE_SLV_DEFRAG	

	if ( pfmp->CPin() )
		{
		Call( ErrERRCheck( JET_errDatabaseInUse ) );
		}

	if ( !pfmp->FAttached( ) )
		{
		Call( ErrERRCheck( JET_errDatabaseNotFound ) );
		}

	//	Enter a critical section to make sure no one, especially the
	//	checkpointer, looking for pdbfilehdr

	//	From this point we got a valid ifmp entry. Start the detaching DB process.

	pfmp->RwlDetaching().EnterAsWriter();
	pfmp->SetDetachingDB( );
	pfmp->RwlDetaching().LeaveAsWriter();

	//	the version store will now process all tasks syncronously

	plog->m_critBackupInProgress.Leave();
	fInCritBackup = fFalse;
	
	Assert( pfmp->Dbid() != dbidTemp );

	if ( !pfmp->FSkippedAttach()
		&& !pfmp->FDeferredAttach() )
		{
		//	BUGFIX: X5:105352
		//	cleanup the version store to allow all tasks to be generated
		
		Call( PverFromIfmp( ifmp )->ErrVERRCEClean( ifmp ) );

		//	LaurionB 06/09/99
		//
		//	CONSIDER: if there was an active user transaction and it commits
		//	after this call version store cleanup could generate tasks after
		//	the call to ErrWaitForTasksToComplete which would cause an erroneous
		//	JET_errDatabaseInUse
		//
		//	The fix for this is to grab the version store cleanup critical section
		//	and to hold it over to calls to ErrVERRCEClean, ErrWaitForTasksToComplete
		//	and ErrVERRCEClean
		}

	//  Let all tasks active on this database complete
	//  From this point on, no additional tasks should be
	//  registered because:
	//		- OLD has terminated
	//		- the version store has been cleaned up
	//		- the database has been closed so no user actions can be performed
	CallS( pfmp->ErrWaitForTasksToComplete() );	

	//	Clean up resources used by the ifmp.
	if ( !pfmp->FSkippedAttach()
		&& !pfmp->FDeferredAttach() )
		{
		// Call RCE clean again, this time to clean versions on this db that
		// we may have missed.
		Call( PverFromIfmp( ifmp )->ErrVERRCEClean( ifmp ) );
		
		// All versions on this ifmp should be cleanable.
		if ( JET_wrnRemainingVersions == err )
			{
			Assert( fFalse );
			err = ErrERRCheck( JET_errDatabaseInUse );

#ifdef INDEPENDENT_DB_FAILURE
			// UNDONE: check more precise error conditions to
			// allow force detach
			pfmp->SetAllowForceDetach( ppib, err );
#endif			
			
			goto HandleError;
			}
		}
	
	if ( FIODatabaseOpen( ifmp ) )
		{
		//	flush all database buffers
		//
		err = ErrBFFlush( ifmp );
		if ( err < 0 )
			{
#ifdef INDEPENDENT_DB_FAILURE			
			// UNDONE: check more precise error conditions to
			// allow force detach
			pfmp->SetAllowForceDetach( ppib, err );
#endif			
			pfmp->ReleaseWriteLatch( ppib );
			return err;
			}
		err = ErrBFFlush( ifmp | ifmpSLV );
		if ( err < 0 )
			{
			pfmp->ReleaseWriteLatch( ppib );
			return err;
			}

		//	purge all buffers for this ifmp
		//
		BFPurge( ifmp );
		BFPurge( ifmp | ifmpSLV );
		}

	//	log detach database

	Assert( pfmp->Dbid() != dbidTemp );
	Assert( UtilCmpFileName( szFullName, rgfmp[ifmp].SzDatabaseName() ) == 0 );

	Call( ErrLGDetachDB( ppib, ifmp, (BYTE)flags, &lgposLogRec ) );
	fDetachLogged = fTrue;

	if ( FIODatabaseOpen( ifmp ) )
		{
		// Now disallow header update by other threads (log writer or checkpoint advancement)
		// 1. For the log writer it is OK to generate a new log w/o updating the header as no log operations
		// for this db will be logged in new logs
		// 2. For the checkpoint: don't advance the checkpoint if db's header weren't update 
		Assert ( pfmp->FAllowHeaderUpdate() || pfmp->FReadOnlyAttach() );
		pfmp->RwlDetaching().EnterAsWriter();
		pfmp->ResetAllowHeaderUpdate();
		pfmp->RwlDetaching().LeaveAsWriter();

		IOCloseDatabase( ifmp );
		}
	else
		{
		//	should be impossible
		Assert( fFalse );
		}

	//	Update database file header. If we are detaching a bogus entry,
	//	then the db file should never be opened and pdbfilehdr will be Nil.

	pdbfilehdr = pfmp->Pdbfilehdr();

	if ( !pfmp->FReadOnlyAttach() && pdbfilehdr )
		{

		Assert( !pfmp->FSkippedAttach() );
		Assert( !pfmp->FDeferredAttach() );

		//	If anything fail in this block, we simply occupy the FMP
		//	but bail out to the caller. The database in a state that it can
		//	not be used any more till next restore where FMP said it is
		//	detaching!

		// UNDONE: ask user to restart the engine.

		pdbfilehdr->SetDbstate( JET_dbstateConsistent );
		
		pdbfilehdr->le_dbtimeDirtied = pfmp->DbtimeLast();
		Assert( pdbfilehdr->le_dbtimeDirtied != 0 );
		pdbfilehdr->le_objidLast = pfmp->ObjidLast();
		Assert( pdbfilehdr->le_objidLast != 0 );

		if ( pfmp->FLogOn() )
			{
			Assert( !plog->m_fLogDisabled );
			Assert( FSIGSignSet( &pdbfilehdr->signLog ) );

			//	Set detachment time.
			 
			if ( plog->m_fRecovering && plog->m_fRecoveringMode == fRecoveringRedo )
				{
				Assert( szDatabaseName );
				pdbfilehdr->le_lgposDetach = plog->m_lgposRedo;
				}
			else
				pdbfilehdr->le_lgposDetach = lgposLogRec;

			pdbfilehdr->le_lgposConsistent = pdbfilehdr->le_lgposDetach;
			}
		LGIGetDateTime( &pdbfilehdr->logtimeDetach );
		pdbfilehdr->logtimeConsistent = pdbfilehdr->logtimeDetach;

		if ( flags & fLRForceDetachRevertDBHeader )
			{
			Assert( pfmp->Patchchk() != NULL );
			ATCHCHK *patchchk = pfmp->Patchchk();
			pdbfilehdr->le_lgposAttach = patchchk->lgposAttach;
			pdbfilehdr->le_lgposDetach = pdbfilehdr->le_lgposConsistent = patchchk->lgposConsistent;
			pdbfilehdr->signDb = patchchk->signDb;
			pdbfilehdr->signLog = patchchk->signLog;
			memset( &pdbfilehdr->logtimeAttach, 0, sizeof( LOGTIME ) );
			memset( &pdbfilehdr->logtimeConsistent, 0, sizeof( LOGTIME ) );
			memset( &pdbfilehdr->logtimeDetach, 0, sizeof( LOGTIME ) );
			}
		//	update the scrub information
		//	we wait until this point so we are sure all scrubbed pages have 
		//	been written to disk

		pdbfilehdr->le_dbtimeLastScrub 	= pfmp->DbtimeLastScrub();
		pdbfilehdr->logtimeScrub 		= pfmp->LogtimeScrub();		

		memset( &pdbfilehdr->bkinfoSnapshotCur, 0, sizeof( BKINFO ) );
		
		Assert( pdbfilehdr->le_objidLast );
		if ( !fGlobalRepair )
			{
			if ( pdbfilehdr->FSLVExists() )
				{
				Call( ErrSLVSyncHeader(	pfsapi, 
										rgfmp[ifmp].FReadOnlyAttach(),
										rgfmp[ifmp].SzSLVName(),
										pdbfilehdr ) );
				}
			else if ( plog->m_fRecovering && (flags & fLRForceDetachCreateSLV) )
				{
				BOOL fLogOn;
				fLogOn = pfmp->FLogOn();
				// check the SLV and if is right one recreate it and set db header
				SLVFILEHDR *pslvfilehdr;
				pslvfilehdr = NULL;
				err = ErrSLVAllocAndReadHeader(	pfsapi, 
												rgfmp[ifmp].FReadOnlyAttach(),
												rgfmp[ifmp].SzSLVName(),
												pdbfilehdr,
												&pslvfilehdr );
				Assert( err < 0 );
				if ( JET_errFileNotFound == err )
					{
					err = JET_errSuccess;
					}
				else if ( JET_errDatabaseStreamingFileMismatch == err
					&& 0 == CmpLgpos( &pslvfilehdr->le_lgposAttach, &pdbfilehdr->le_lgposAttach )
					&& 0 == memcmp( &pslvfilehdr->signDb, &pdbfilehdr->signDb, sizeof( SIGNATURE ) ) )
					{
					OSMemoryPageFree( pslvfilehdr );
#ifdef DEBUG
					pslvfilehdr = NULL;
#endif // DEBUG
					Call( pfsapi->ErrFileDelete( pfmp->SzSLVName() ) );
				 	err = JET_errSuccess;
					}
				else
					{
					OSMemoryPageFree( pslvfilehdr );
#ifdef DEBUG
					pslvfilehdr = NULL;
#endif // DEBUG
					Call( err );
					}
				Assert( NULL == pslvfilehdr );
				pfmp->ResetLogOn(); 
				pdbfilehdr->SetSLVExists();
				pdbfilehdr->signSLV = pdbfilehdr->signDb;
				err = ErrFILECreateSLV( pfsapi, ppib, ifmp, SLV_CREATESLV_CREATE );
				if ( fLogOn )
					{
					pfmp->SetLogOn();
					}
				if ( err < 0 )
					{
					pdbfilehdr->ResetSLVExists();
					memset( &pdbfilehdr->signSLV, 0, sizeof( SIGNATURE ) );
					Call( err );
					}
				}
			}
		err = ErrUtilWriteShadowedHeader( pfsapi, szDatabaseName, fTrue, (BYTE*)pdbfilehdr, g_cbPage );
		//	Check what have we written
		if ( JET_errSuccess != err )
			{
			ERR errT;
			DBFILEHDR *pdbfilehdrT = NULL;

			pdbfilehdrT = (DBFILEHDR *)PvOSMemoryPageAlloc( g_cbPage, NULL );
			if ( NULL != pdbfilehdrT )
				{
				//	Read new status
				errT = ErrUtilReadShadowedHeader( pfsapi, szDatabaseName, (BYTE*)pdbfilehdrT, g_cbPage, OffsetOf( DBFILEHDR, le_cbPageSize) );
				//	If database header is set properly
				if ( JET_errSuccess == errT && JET_dbstateConsistent == pdbfilehdrT->Dbstate() )
					{
					err = JET_errSuccess;
					}
				(VOID)OSMemoryPageFree( (VOID*)pdbfilehdrT );
				}
			Call( err );
			}
			
		if ( flags & fLRForceDetachDeleteDB )
			{
			if ( pfmp->SzSLVName() != NULL )
				{
				pfsapi->ErrFileDelete( pfmp->SzSLVName() );
				}
			pfsapi->ErrFileDelete( pfmp->SzDatabaseName() );
			}
		}
		
	//	Reset and free up FMP

	FMP::EnterCritFMPPool();
	pfmp->RwlDetaching().EnterAsWriter();
	DBResetFMP( pfmp, plog, fTrue );
	pfmp->ReleaseWriteLatchAndFree( ppib );
	pfmp->RwlDetaching().LeaveAsWriter();
	FMP::LeaveCritFMPPool();

	return JET_errSuccess;

HandleError:
	Assert( err < JET_errSuccess );

	//	do not reset detaching. We leave the database in detaching
	//	mode till next restore.

	if ( fDetachLogged )
		{
		//	if failure after detach logged, force shutdown to fix up database
		DBReportPartiallyDetachedDb( szDatabaseName, err );
		ppib->SetErrRollbackFailure( err );
		pinst->SetFInstanceUnavailable();

		Assert( NULL != pfmp );
		pfmp->ReleaseWriteLatch( ppib );
		}
	else if ( NULL != pfmp )
		{
		//	detach not logged yet, so database is still usable
		pfmp->RwlDetaching().EnterAsWriter();
		pfmp->ResetDetachingDB( );
		pfmp->ReleaseWriteLatch( ppib );
		pfmp->RwlDetaching().LeaveAsWriter();
		}

	if ( fInCritBackup )
		plog->m_critBackupInProgress.Leave();

	return err;
	}


//	DAE databases are repaired automatically on system restart
//
ERR ISAMAPI ErrIsamRepairDatabase(
	JET_SESID sesid,
	const CHAR  *lszDbFile,
	JET_PFNSTATUS pfnstatus )
	{
	PIB *ppib;

	Assert( sizeof(JET_SESID) == sizeof(PIB *) );
	ppib = (PIB*) sesid;

	NotUsed(ppib);
	NotUsed(lszDbFile);
	NotUsed(pfnstatus);

	Assert( fFalse );
	return ErrERRCheck( JET_errFeatureNotAvailable );
	}


ERR ISAMAPI ErrIsamOpenDatabase(
	JET_SESID sesid,
	const CHAR  *szDatabaseName,
	const CHAR  *szConnect,
	JET_DBID *pjdbid,
	JET_GRBIT grbit )
	{
	ERR		err;
	PIB		*ppib;
	IFMP  	ifmp;

	//	initialize return value
	Assert( pjdbid );
	*pjdbid = JET_dbidNil;
	
	//	check parameters
	//
	Assert( sizeof(JET_SESID) == sizeof(PIB *) );
	ppib = (PIB *)sesid;
	NotUsed(szConnect);

	CallR( ErrPIBCheck( ppib ) );

	CallR( ErrDBOpenDatabase( ppib, (CHAR *)szDatabaseName, &ifmp, grbit ) );

	// we don't have any check to prevent JetOpenDatabase 
	// using the temp database name.
	// we check now if we actualy opened the temp db
	if( !FUserIfmp( ifmp ) )
		{
		CallS ( ErrDBCloseDatabase( ppib, ifmp, NO_GRBIT ) );
		return ErrERRCheck( JET_errInvalidDatabase );
		}

	*pjdbid = (JET_DBID)ifmp;

	return JET_errSuccess;
	}


ERR ErrDBOpenDatabaseBySLV( IFileSystemAPI *const pfsapi, PIB *ppib, CHAR *szSLVName, IFMP *pifmp )
	{
	ERR		err = JET_errSuccess;
	CHAR  	rgchSLVFullName[IFileSystemAPI::cchPathMax];
	CHAR  	*szSLVFullName;
	CHAR  	*szSLVFileName;
	IFMP  	ifmp;
	INST	*pinst = PinstFromPpib( ppib );
	LOG		*plog = pinst->m_plog;

	Assert( !plog->m_fRecovering );
	Assert( NULL != szSLVName );
	Assert( 0 != *szSLVName );

	//	this should never be called on the temp database (its ok to use the regular file-system)

	err = pfsapi->ErrPathComplete( szSLVName, rgchSLVFullName );
	CallR( err == JET_errInvalidPath ? ErrERRCheck( JET_errDatabaseInvalidPath ) : err );
	szSLVFullName = rgchSLVFullName;
	szSLVFileName = szSLVFullName;

	CallR( FMP::ErrWriteLatchBySLVNameSz( szSLVFullName, &ifmp, ppib ) );

	FMP *pfmp = &rgfmp[ ifmp ];

	//  during recovering, we could open an non-detached database
	//  to force to initialize the fmp entry.
	//	if database has been detached, then return error.
	//
	if ( !plog->m_fRecovering && !pfmp->FAttached() )
		{
		Call( ErrERRCheck( JET_errDatabaseNotFound ) );
		}
	Assert( !pfmp->FSkippedAttach() );

	if ( pfmp->FReadOnlyAttach() )
		err = ErrERRCheck( JET_wrnFileOpenReadOnly );

	if ( pfmp->FExclusiveByAnotherSession( ppib ) )
		{
		Call( ErrERRCheck( JET_errDatabaseLocked ) );
		}

	Assert( pfmp->Pfapi() );
	DBSetOpenDatabaseFlag( ppib, ifmp );

	//	Allow others to open.

	pfmp->ReleaseWriteLatch( ppib );

	*pifmp = ifmp;
	return err;

HandleError:

	pfmp->ReleaseWriteLatch( ppib );
	return err;
	}


ERR ErrDBOpenDatabase( PIB *ppib, CHAR *szDatabaseName, IFMP *pifmp, ULONG grbit )
	{
	ERR					err = JET_errSuccess;
	CHAR  				rgchFullName[IFileSystemAPI::cchPathMax];
	CHAR  				*szFullName;
	CHAR  				*szFileName;
	IFMP  				ifmp;
	INST				*pinst = PinstFromPpib( ppib );
	LOG					*plog = pinst->m_plog;
	IFileSystemAPI	*pfsapi = NULL;
		
	if ( plog->m_fRecovering )
		{
		Assert( NULL != szDatabaseName );
		Assert( 0 != *szDatabaseName );
		CallS( FMP::ErrWriteLatchByNameSz( szDatabaseName, &ifmp, ppib ) );
		}

	pfsapi = pinst->m_pfsapi;
	if ( plog->m_fRecovering && dbidTemp != rgfmp[ ifmp ].Dbid() )
		{
		szFileName = szFullName = rgfmp[ifmp].SzDatabaseName();
		}
	else
		{
		if ( NULL == szDatabaseName || 0 == *szDatabaseName )
			return ErrERRCheck( JET_errDatabaseInvalidPath );

		err = ErrUtilPathComplete( pfsapi, szDatabaseName, rgchFullName, fFalse );
		Assert( JET_errFileNotFound != err );
		CallR( err == JET_errInvalidPath ? ErrERRCheck( JET_errDatabaseInvalidPath ) : err );

		szFullName = rgchFullName;
		szFileName = szFullName;
		}

	if ( !plog->m_fRecovering )
		{
		Assert( rgchFullName == szFullName );
		CallR( FMP::ErrWriteLatchByNameSz( szFullName, &ifmp, ppib ) );
		}

	FMP *pfmp = &rgfmp[ ifmp ];

	if ( g_fOneDatabasePerSession
		&& !plog->m_fRecovering
		&& FUserIfmp( ifmp )
		&& FSomeDatabaseOpen( ppib, ifmp ) )
		{
		Call( ErrERRCheck( JET_errOneDatabasePerSession ) );
		}

	//  during recovering, we could open an non-detached database
	//  to force to initialize the fmp entry.
	//	if database has been detached, then return error.
	//
	if ( !plog->m_fRecovering && !pfmp->FAttached() )
		{
		Call( ErrERRCheck( JET_errDatabaseNotFound ) );
		}

	Assert( !pfmp->FSkippedAttach() );
	Assert( !pfmp->FDeferredAttach() );

	if ( pfmp->FReadOnlyAttach() && !( grbit & JET_bitDbReadOnly ) )
		err = ErrERRCheck( JET_wrnFileOpenReadOnly );

	if ( pfmp->FExclusiveByAnotherSession( ppib ) )
		{
		Call( ErrERRCheck( JET_errDatabaseLocked ) );
		}

	if ( grbit & JET_bitDbExclusive )
		{
#ifdef FORCE_ONLINE_DEFRAG
		if ( pfmp->CPin() > 0 )
			{
			if ( !plog->m_fRecovering && pfmp->FLogOn() )
				{
				Assert( !pfmp->FVersioningOff() );
				Assert( !pfmp->FReadOnlyAttach() );
				pfmp->ReleaseWriteLatch( ppib );
				CallR( ErrOLDDefragment( ifmp, NULL, NULL, NULL, NULL, JET_bitDefragmentBatchStop ) );
				Assert( JET_wrnDefragNotRunning == err || JET_errSuccess == err );
				CallR( FMP::ErrWriteLatchByNameSz( szFullName, &ifmp, ppib ) );
				Assert( !pfmp->FDetachingDB( ) );
				pfmp = &rgfmp[ifmp];
				}
			Assert( !pfmp->FRunningOLD() );
			}			
#endif	//	FORCE_ONLINE_DEFRAG

#ifdef FORCE_ONLINE_SLV_DEFRAG
		if ( pfmp->CPin() > 0 )
			{
			if ( !plog->m_fRecovering && pfmp->FLogOn() && pfmp->FSLVAttached() )
				{
				Assert( !pfmp->FVersioningOff() );
				Assert( !pfmp->FReadOnlyAttach() );
				pfmp->ReleaseWriteLatch( ppib );
				CallR( ErrOLDDefragment( ifmp, NULL, NULL, NULL, NULL, JET_bitDefragmentSLVBatchStop ) );
				Assert( JET_wrnDefragNotRunning == err || JET_errSuccess == err );
				CallR( FMP::ErrWriteLatchByNameSz( szFullName, &ifmp, ppib ) );
				Assert( !pfmp->FDetachingDB( ) );
				pfmp = &rgfmp[ifmp];
				}
			Assert( !pfmp->FRunningOLDSLV() );
			}			
#endif	//	FORCE_ONLINE_SLV_DEFRAG

		if( pfmp->CPin() > 0 )
			{
			Call( ErrERRCheck( JET_errDatabaseInUse ) );			
			}
		pfmp->SetExclusiveOpen( ppib );
		}

	Assert( pfmp->Pfapi() );
	DBSetOpenDatabaseFlag( ppib, ifmp );

	//	Allow others to open.

	pfmp->ReleaseWriteLatch( ppib );

	*pifmp = ifmp;
	return err;

HandleError:

	pfmp->ReleaseWriteLatch( ppib );
	return err;
	}


ERR ISAMAPI ErrIsamCloseDatabase( JET_SESID sesid, JET_DBID ifmp, JET_GRBIT grbit )
	{
	ERR	  	err;
	PIB	  	*ppib = (PIB *)sesid;

	NotUsed( grbit );

	//	check parameters
	//
	Assert( sizeof(JET_SESID) == sizeof(PIB *) );
	CallR( ErrPIBCheck( ppib ) );

	CallR( ErrDBCheckUserDbid( ifmp ) );

	CallR ( ErrDBCloseDatabase( ppib, ifmp, grbit ) );

	Assert( !g_fOneDatabasePerSession || !FSomeDatabaseOpen( ppib ) );

	return JET_errSuccess;
	}


ERR ISAMAPI ErrIsamSetDatabaseSize( JET_SESID sesid, const CHAR *szDatabase, DWORD cpg, DWORD *pcpgReal )
	{
	ERR				err			= JET_errSuccess;
	PIB*			ppib		= (PIB *)sesid;
	IFileSystemAPI*	pfsapi		= PinstFromPpib( ppib )->m_pfsapi;
	DBFILEHDR_FIX*	pdbfilehdr	= NULL;
	IFileAPI*		pfapi		= NULL;
	QWORD			cbFileSize;

	if ( NULL == szDatabase || 0 == *szDatabase )
		return ErrERRCheck( JET_errDatabaseInvalidPath );

	if ( cpg < cpgDatabaseMin )
		{
		return ErrERRCheck( JET_errInvalidParameter );
		}

	if ( !( pdbfilehdr = (DBFILEHDR_FIX*)PvOSMemoryPageAlloc( g_cbPage, NULL ) ) )
		{
		return ErrERRCheck( JET_errOutOfMemory );
		}

	//	this should never be called on the temp database (e.g. we will not need to force the OS file-system)

	Call( ErrUtilReadAndFixShadowedHeader(	pfsapi, 
											(CHAR *)szDatabase, 
											(BYTE *)pdbfilehdr, 
											g_cbPage, 
											OffsetOf( DBFILEHDR_FIX, le_cbPageSize ) ) );

	//	Disallow setting size on an inconsistent database

	if ( pdbfilehdr->Dbstate() != JET_dbstateConsistent )
		{
		Call( ErrERRCheck( JET_errDatabaseInconsistent ) );
		}
	
	//	Set new database size only if it is larger than db size.

	Call( pfsapi->ErrFileOpen( szDatabase, &pfapi ) );
	Call( pfapi->ErrSize( &cbFileSize ) );
		
	ULONG cpgNow;
	cpgNow = ULONG( ( cbFileSize / g_cbPage ) - cpgDBReserved );

	if ( cpgNow >= cpg )
		{
		*pcpgReal = cpgNow;
		}
	else
		{
		*pcpgReal = cpg;

		cbFileSize = g_cbPage * ( cpg + cpgDBReserved );

		Call( pfapi->ErrSetSize( cbFileSize ) );
	 	}

HandleError:
	OSMemoryPageFree( (void*)pdbfilehdr );
	delete pfapi;
	return err;
	}


ERR ISAMAPI ErrIsamGrowDatabase( JET_SESID sesid, JET_DBID ifmp, DWORD cpg, DWORD *pcpgReal )
	{
	ERR		err			= JET_errSuccess;
	PIB*	ppib		= (PIB *)sesid;
	FUCB*	pfucb 		= pfucbNil;
	PGNO	pgnoAlloc	= pgnoNull;

	PGNO	pgnoLast	= pgnoNull;
	Call( ErrSPGetLastPgno( ppib, ifmp, &pgnoLast ) );

	CPG		cpgCurrent;
	CPG		cpgExtend;
	
	cpgCurrent = pgnoLast + cpgDBReserved;
	cpgExtend = cpg < cpgCurrent ? 0 : cpg - cpgCurrent;
	
	Call( ErrDIROpen( ppib, pgnoSystemRoot, ifmp, &pfucb ) );
	Call( ErrSPGetExt( pfucb, pgnoSystemRoot, &cpgExtend, cpgExtend, &pgnoAlloc ) );

	Call( ErrSPGetLastPgno( ppib, ifmp, &pgnoLast ) );
	*pcpgReal = pgnoLast + cpgDBReserved;

HandleError:
	if( pfucbNil != pfucb )
		{
		DIRClose( pfucb );
		}
	return err;
	}


ERR ErrDBCloseDatabase( PIB *ppib, IFMP ifmp, ULONG	grbit )
	{
	FMP		*pfmp = &rgfmp[ ifmp ];
	FUCB	*pfucb;
	FUCB	*pfucbNext;

	if ( !( FPIBUserOpenedDatabase( ppib, pfmp->Dbid() ) ) )
		{
		return ErrERRCheck( JET_errDatabaseNotFound );
		}

	/*	get a write latch on this fmp in order to change cPin.
	 */
	pfmp->GetWriteLatch( ppib );

	Assert( FIODatabaseOpen( ifmp ) );
	if ( FLastOpen( ppib, ifmp ) )
		{
		//	close all open FUCBs on this database
		//

		//	get first table FUCB
		//
		pfucb = ppib->pfucbOfSession;
		while ( pfucb != pfucbNil
			&& ( pfucb->ifmp != ifmp || !pfucb->u.pfcb->FPrimaryIndex() ) )
			{
			pfucb = pfucb->pfucbNextOfSession;
			}

		while ( pfucb != pfucbNil )
			{
			//	get next table FUCB
			//
			pfucbNext = pfucb->pfucbNextOfSession;
			while ( pfucbNext != pfucbNil
				&& ( pfucbNext->ifmp != ifmp || !pfucbNext->u.pfcb->FPrimaryIndex() ) )
				{
				pfucbNext = pfucbNext->pfucbNextOfSession;
				}

			if ( !( FFUCBDeferClosed( pfucb ) ) )
				{
				CallS( pfucb->pvtfndef->pfnCloseTable( (JET_SESID)ppib, (JET_TABLEID) pfucb ) );
				}
			pfucb = pfucbNext;
			}
		}

	// if we opened it exclusively, we reset the flag

	DBResetOpenDatabaseFlag( ppib, ifmp );
	if ( pfmp->FExclusiveBySession( ppib ) )
		pfmp->ResetExclusiveOpen( );

	if ( ppib->FSessionOLD() )
		{
		Assert( pfmp->FRunningOLD() );
		pfmp->ResetRunningOLD();
		}

	if ( ppib->FSessionOLDSLV() )
		{
		Assert( pfmp->FRunningOLDSLV() );
		pfmp->ResetRunningOLDSLV();
		}

	// Release Write Latch

	pfmp->ReleaseWriteLatch( ppib );

	//	do not close file until file map space needed or database
	//	detached.

	return JET_errSuccess;
	}


ERR ErrDBOpenDatabaseByIfmp( PIB *ppib, IFMP ifmp )
	{
	ERR		err;

	//	Write latch the fmp since we are going to change cPin.

	CallR( FMP::ErrWriteLatchByIfmp( ifmp, ppib ) );

	//	The fmp we latch must be write latched by us and have
	//	a attached database.

	FMP *pfmp = &rgfmp[ ifmp ];
	Assert( pfmp->FWriteLatchByMe(ppib) );
	Assert( pfmp->FAttached() );


	// Allow LV create, RCE clean, and OLD sessions to bypass exclusive lock.
	if ( pfmp->FExclusiveByAnotherSession( ppib )
		&& !FPIBSessionLV( ppib )
		&& !FPIBSessionSystemCleanup( ppib ) )
		{
		//	It is opened by others already.
		err = ErrERRCheck( JET_errDatabaseLocked );
		}
	else
		{
		DBSetOpenDatabaseFlag( ppib, ifmp );

		if ( ppib->FSessionOLD() && !pfmp->FRunningOLD() )
			{
			pfmp->SetRunningOLD();
			}

		if ( ppib->FSessionOLDSLV() && !pfmp->FRunningOLDSLV() )
			{
			pfmp->SetRunningOLDSLV();
			}

		err = JET_errSuccess;
		}
	
	pfmp->ReleaseWriteLatch( ppib );

	return err;
	}


//	ErrDABCloseAllDBs: Close all databases opened by this thread
//ErrDBCloseAllDBs
ERR ErrDBCloseAllDBs( PIB *ppib )
	{
	DBID	dbid;
	ERR		err;
	INST	*pinst = PinstFromPpib( ppib );

	for ( dbid = dbidUserLeast; dbid < dbidMax; dbid++ )
		{
		IFMP ifmp = pinst->m_mpdbidifmp[ dbid ];
		if ( ifmp >= ifmpMax )
			continue;
		while ( FPIBUserOpenedDatabase( ppib, dbid ) )
			CallR( ErrDBCloseDatabase( ppib, ifmp, 0 ) );
		}

	return JET_errSuccess;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ese98\src\ese\esedump.cxx ===
#include "std.hxx"
#include "_dump.hxx"
#include "_bt.hxx"


extern CPRINTFSTDOUT cprintfStdout;

CPRINTFINDENT cprintfIndent( &cprintfStdout);

const BYTE mpbb[] = {'0', '1', '2', '3', '4', '5', '6', '7', '8',
					 '9', 'A', 'B', 'C', 'D', 'E', 'F' };

#define addPBI				cprintfIndent
#define flushPB( )			
#define addIndent() 		cprintfIndent.Indent()
#define delIndent() 		cprintfIndent.Unindent()


// numer of bytes to be displayed from the key of each node
#define MAX_KEY_SIZE_DISPLAY 8

// helps to don't pass as param the dumping mode (all nodes or visible ones)
// to all the function down the call stack

typedef char * (*PfnFormatNodeInfo)( KEYDATAFLAGS * pNode );

LOCAL ERR ErrESEDUMPOneTable(FUCB *, char *, JET_GRBIT);
LOCAL ERR ErrESEDUMPNodesForOneTree(FUCB *pfucbTable, JET_GRBIT grbitESEDUMPMode, PfnFormatNodeInfo pfnFormat = NULL);
LOCAL ERR ErrESEDUMPTables( JET_SESID , JET_DBID , char* , JET_GRBIT);
LOCAL ERR ErrESEDUMPIndexForOneTable(FUCB *, JET_GRBIT);
LOCAL ERR ErrESEDUMPCheckAndDumpSpaceInfo(FUCB *, JET_GRBIT);
LOCAL ERR ErrESEDUMPDatabaseInfo(PIB *, IFMP , JET_GRBIT);
LOCAL ERR ErrESEDUMPLVForOneTable(FUCB *, JET_GRBIT);
LOCAL VOID ESEDUMPSplitBufferDump(SPLIT_BUFFER & , FUCB * , JET_GRBIT);
LOCAL VOID ESEDUMPSingleSpaceHeaderDump(SPACE_HEADER &, FUCB * , JET_GRBIT);
LOCAL ERR ErrESEDUMPMultipleSpaceHeaderDump(SPACE_HEADER & , FUCB *, JET_GRBIT );
LOCAL ERR ErrESEDUMPSpecialFDP(FUCB *pfucbCatalog, PGNO pgnoFDP, const char *szName, JET_GRBIT grbitESEDUMPMode, PfnFormatNodeInfo pfnFormat = NULL);
LOCAL ERR ErrESEDUMPSpecialFDPs( JET_SESID sesid, JET_DBID ifmp, JET_GRBIT grbitESEDUMPMode );


// main function that dumps the nodes (it's called from the eseutil.cxx)
// the dump parameters are set according to the command line in pdbutil 
// Current options:	- dump only one table /{x|X}TableName
//					- dump visible nodes or all nodes 
//					  (including those marked as deleted)
ERR ErrESEDUMPData( JET_SESID sesid, JET_DBUTIL *pdbutil )
	{
	ERR			err;
	JET_DBID	ifmp				= JET_dbidNil;
	JET_GRBIT 	grbitESEDUMPMode	= 0;
	
	Assert( NULL != pdbutil);
	Assert( sizeof(JET_DBUTIL) == pdbutil->cbStruct );
	Assert( NULL != pdbutil->szDatabase );

	// attach to the database
	CallR( ErrIsamAttachDatabase(
				sesid,
				pdbutil->szDatabase,
				NULL,
				NULL,
				0,
				JET_bitDbReadOnly
				) );
	Call( ErrIsamOpenDatabase(
				sesid,
				pdbutil->szDatabase,
				NULL,
				&ifmp,
				JET_bitDbExclusive | JET_bitDbReadOnly
				) );
	Assert( JET_dbidNil != ifmp );
	
	grbitESEDUMPMode = pdbutil->grbitOptions;

	// just dump the database space info if not "one table dump"
	if (!pdbutil->szTable)
		Call ( ErrESEDUMPDatabaseInfo( (PIB *)sesid, ifmp, grbitESEDUMPMode ) );

	addIndent();

	if ( rgfmp[ifmp].FSLVAttached() )
		{
		Call ( ErrESEDUMPSpecialFDPs( sesid, ifmp, grbitESEDUMPMode ) );
		}

	if (!pdbutil->szTable || ( pdbutil->szTable && pdbutil->szTable[0] ) )
		{
		// dump the tables, if ERR jump to CloseDb and DetachDb
		Call( ErrESEDUMPTables( sesid, ifmp, pdbutil->szTable, grbitESEDUMPMode ) );
		}
	


HandleError:
	if ( JET_dbidNil != ifmp )
		{
		(VOID)ErrIsamCloseDatabase( sesid, ifmp, NO_GRBIT );
		}
	
	(VOID)ErrIsamDetachDatabase( sesid, NULL, pdbutil->szDatabase );

	return err;		
	}

char * FormatNodeInfoForSLVOwnerMap( KEYDATAFLAGS * pNode )
	{
	static char szBuffer[1024];
	
	PGNO pgno;

	Assert ( pNode );
#ifdef DEBUG	
	pNode->AssertValid();
#endif // DEBUG
	Assert ( sizeof(PGNO) == pNode->key.Cb() );
	
	LongFromKey( &pgno, pNode->key);

	SLVOWNERMAP slvownermapT;
	slvownermapT.Retrieve( pNode->data );
	
	const BYTE * pvKey = (const BYTE *)slvownermapT.PvKey();
	
	sprintf(
		szBuffer,
		"pgno:%u objid:%d columnid:0x%X ValidChecksum:%s checksum:0x%x cbData:%d cbKey:%d pvKey:",
		pgno,
		slvownermapT.Objid(), 
		slvownermapT.Columnid(), 
		slvownermapT.FValidChecksum() ? "Y" : "N",
		slvownermapT.UlChecksum(),
		slvownermapT.CbDataChecksummed(),
		slvownermapT.CbKey() );

	BYTE *	pbT		= (BYTE *)szBuffer + strlen( szBuffer );

	for ( ULONG i = 0; i < min( slvownermapT.CbKey(), MAX_KEY_SIZE_DISPLAY ); i++)
		{
		const BYTE	b	= pvKey[i];

		*pbT++ = mpbb[b >> 4];
		*pbT++ = mpbb[b & 0x0f];
		*pbT++ = ' ';
		}
	*pbT = 0;
		
	return szBuffer;
	}

// Dumps all the tables with nodes, space info, indexes, LV's
// It makes a loop into the Catalog and
// for each table call a DumpOneTable function
LOCAL ERR ErrESEDUMPSpecialFDPs( JET_SESID sesid, JET_DBID ifmp, JET_GRBIT grbitESEDUMPMode )
	{
	ERR			err;
	FUCB		*pfucbCatalog = 	pfucbNil;
	PGNO 		pgno;
	OBJID		objid;

	// opens the catalog
	CallR( ErrCATOpen( (PIB *)sesid, ifmp, &pfucbCatalog ) );
	Assert( pfucbNil != pfucbCatalog );

	Assert( pfcbNil != pfucbCatalog->u.pfcb );
	Assert( pfucbCatalog->u.pfcb->FTypeTable() );
	Assert( pfucbCatalog->u.pfcb->FFixedDDL() );
	Assert( pfucbCatalog->u.pfcb->PgnoFDP() == pgnoFDPMSO );

	Call ( ErrCATAccessDbSLVAvail( (PIB *)sesid, ifmp, szSLVAvail, &pgno, &objid ) ) ;
	Call ( ErrESEDUMPSpecialFDP(pfucbCatalog, pgno, szSLVAvail, grbitESEDUMPMode) );

	Call ( ErrCATAccessDbSLVOwnerMap( (PIB *)sesid, ifmp, szSLVOwnerMap, &pgno, &objid ) ) ;
	Call ( ErrESEDUMPSpecialFDP(pfucbCatalog, pgno, szSLVOwnerMap, grbitESEDUMPMode, (PfnFormatNodeInfo) FormatNodeInfoForSLVOwnerMap) );
		
HandleError:
	Assert(pfucbNil != pfucbCatalog);
	CallS(ErrCATClose( (PIB *)sesid, pfucbCatalog ));
	return err;
	}


// Dumps all the tables with nodes, space info, indexes, LV's
// It makes a loop into the Catalog and
// for each table call a DumpOneTable function
LOCAL ERR ErrESEDUMPTables( JET_SESID sesid, JET_DBID ifmp, char *szTable, JET_GRBIT grbitESEDUMPMode )
	{
	ERR			err;
	FUCB		*pfucbCatalog = 	pfucbNil;
	const BYTE	bTrue = 			0xff;

	// opens the catalog
	CallR( ErrCATOpen( (PIB *)sesid, ifmp, &pfucbCatalog ) );
	Assert( pfucbNil != pfucbCatalog );

	// set that index in order to "see" only the tables (user and system tabels)
	Call ( ErrIsamSetCurrentIndex(
				(PIB *)sesid,
				pfucbCatalog,
				szMSORootObjectsIndex ) );

	Assert( pfcbNil != pfucbCatalog->u.pfcb );
	Assert( pfucbCatalog->u.pfcb->FTypeTable() );
	Assert( pfucbCatalog->u.pfcb->FFixedDDL() );
	Assert( pfucbCatalog->u.pfcb->PgnoFDP() == pgnoFDPMSO );

	if (szTable)
		{
		// if table name specified
		// make the key and seek
		Call( ErrIsamMakeKey(
					pfucbCatalog->ppib,
					pfucbCatalog,
					&bTrue,
					sizeof(bTrue),
					JET_bitNewKey ) );
		Call( ErrIsamMakeKey(
					pfucbCatalog->ppib,
					pfucbCatalog,
					(BYTE *)szTable,
					(ULONG)strlen(szTable),
					NO_GRBIT ) );
		err = ErrIsamSeek( pfucbCatalog->ppib, pfucbCatalog, JET_bitSeekEQ );
		if ( JET_errRecordNotFound == err )
			{
			addPBI("\n Table %s not found.\n", szTable);
			flushPB();
			}
		Call( err );

		Call (ErrESEDUMPOneTable(pfucbCatalog, szTable, grbitESEDUMPMode));
		
		}
	else
		{
		// if no table specified
		// move to the first record
		// it must exist (also JET_errRecordNotFound is error)
		Call ( ErrIsamMove( pfucbCatalog->ppib,
					pfucbCatalog,
					JET_MoveFirst,
					NO_GRBIT ));
					
		do
			{
			DATA	dataField;
			CHAR	szTableName[JET_cbNameMost+1];
			
			Assert( !Pcsr( pfucbCatalog )->FLatched() );
			Call( ErrDIRGet( pfucbCatalog ) );
			Assert( Pcsr( pfucbCatalog )->FLatched() );
					
			const DATA&	dataRec	= pfucbCatalog->kdfCurr.data;
			

			// get the table name
			Call( ErrRECIRetrieveVarColumn(
					pfcbNil,
					pfucbCatalog->u.pfcb->Ptdb(),
					fidMSO_Name,
					dataRec,
					&dataField ) );
			Assert( JET_errSuccess == err );
			Assert( dataField.Cb() > 0 && dataField.Cb() <= JET_cbNameMost );
			UtilMemCpy( szTableName, dataField.Pv(), dataField.Cb() );
			szTableName[dataField.Cb()] = '\0';

			Assert( Pcsr( pfucbCatalog )->FLatched() );
			Call ( ErrDIRRelease( pfucbCatalog ) );
			Assert( !Pcsr( pfucbCatalog )->FLatched() );

			// dump the table
			Call (ErrESEDUMPOneTable(pfucbCatalog, szTableName, grbitESEDUMPMode));

			// move to the next table
			err = ErrIsamMove( 
						pfucbCatalog->ppib,
						pfucbCatalog,
						JET_MoveNext,
						NO_GRBIT );
			}
		while ( err >= 0);
			
		if ( JET_errNoCurrentRecord == err )
			err = JET_errSuccess;
		}
		
HandleError:
	Assert(pfucbNil != pfucbCatalog);
	CallS(ErrCATClose( (PIB *)sesid, pfucbCatalog ));
	return err;
	}

LOCAL ERR ErrESEDUMPSpecialFDP(FUCB *pfucbCatalog, PGNO pgnoFDP, const char *szName, JET_GRBIT grbitESEDUMPMode, PfnFormatNodeInfo pfnFormat)
	{
	ERR	 		err 	= JET_errSuccess;
	FUCB * 		pfucb 	= pfucbNil;
	
	// open the directory

	CallR ( ErrDIROpen( pfucbCatalog->ppib, pgnoFDP, pfucbCatalog->ifmp, &pfucb ) );
	
	Assert( pfucbNil != pfucb );
	Assert( pfcbNil != pfucb->u.pfcb );
	Assert( pfucb->u.pfcb->FTypeSLVAvail() || pfucb->u.pfcb->FTypeSLVOwnerMap());


	// print the information about ifmp,
	// page and table name for this table (pageFDP)
	addPBI("\n");
	addPBI("[%d , %d] %s (Special)\n",
				pfucbCatalog->ifmp,
				pfucb->u.pfcb->PgnoFDP(),
				szName);
	flushPB();

	Call (ErrESEDUMPCheckAndDumpSpaceInfo(pfucb, grbitESEDUMPMode));


	// the function that dumps the nodes and must conserve
	// the table root page unlached
	Call (ErrESEDUMPNodesForOneTree(pfucb, grbitESEDUMPMode, pfnFormat));
		
HandleError:
	Assert( pfucbNil != pfucb );
	DIRClose( pfucb );	
	return err;
	}



// dumps one table with nodes, space info, indexes, LV's
// szTableName - is the table name
// pfucbCatalob - get the session and database
LOCAL ERR ErrESEDUMPOneTable(FUCB *pfucbCatalog, char *szTableName, JET_GRBIT grbitESEDUMPMode)
	{
	ERR	err = 			JET_errSuccess;
	FUCB *pfucbTable = 	pfucbNil;
	
	// open the table
	CallR( ErrFILEOpenTable(
				pfucbCatalog->ppib,
				pfucbCatalog->ifmp,
				&pfucbTable,
				szTableName,
				JET_bitTableSequential ) );
	Assert( pfucbNil != pfucbTable );
	Assert( pfcbNil != pfucbTable->u.pfcb );
	Assert( pfucbTable->u.pfcb->FTypeTable() );


	// print the information about ifmp,
	// page and table name for this table (pageFDP)
	addPBI("\n");
	addPBI("[%d , %d] %s (Table)\n",
				pfucbCatalog->ifmp,
				pfucbTable->u.pfcb->PgnoFDP(),
				szTableName);
	flushPB();

	Call (ErrESEDUMPCheckAndDumpSpaceInfo(pfucbTable, grbitESEDUMPMode));


	// the function that dumps the nodes and must conserve
	// the table root page unlached
	Call (ErrESEDUMPNodesForOneTree(pfucbTable, grbitESEDUMPMode));
	
	// the function that dumps all the secondary indexes and must conserve
	// the table root page unlached
	Call (ErrESEDUMPIndexForOneTable(pfucbTable, grbitESEDUMPMode));
		
	// dump the LV's, if any
	// the function that dumps all the secondary indexes and must conserve
	// the table root page unlached
	Call (ErrESEDUMPLVForOneTable(pfucbTable, grbitESEDUMPMode));
	
HandleError:
	Assert( pfucbNil != pfucbTable );
	CallS( ErrFILECloseTable( pfucbCatalog->ppib, pfucbTable ) );	
	return err;
	}

// dump the LV tree (if it exists) for a table
LOCAL ERR ErrESEDUMPLVForOneTable(FUCB *pfucbTable, JET_GRBIT grbitESEDUMPMode)
{
	ERR	err = 		JET_errSuccess;
	FUCB *pfucbLV =	pfucbNil;

	Assert(pfucbTable);
	Assert( Pcsr(pfucbTable ));
	Assert( !Pcsr(pfucbTable )->FLatched() );
	
	addIndent();
	
	// get the LV root page handle
	err = ErrFILEOpenLVRoot( pfucbTable, &pfucbLV, fFalse );
	if ( JET_errSuccess == err )
		{		
		Assert(pfucbLV);
		Assert( !Pcsr(pfucbLV )->FLatched() );

		addPBI("\n");
		addPBI("[%d , %d] LONG VALUES:\n",
					pfucbLV->ifmp,
					pfucbLV->u.pfcb->PgnoFDP());		
		
		flushPB();
		FUCBSetIndex(pfucbLV);

		Call (ErrESEDUMPCheckAndDumpSpaceInfo(pfucbLV, grbitESEDUMPMode));

		Call (ErrESEDUMPNodesForOneTree(pfucbLV, grbitESEDUMPMode));
		
		DIRClose(pfucbLV);
		pfucbLV = pfucbNil;
		}
	else
		// if other error than No LV tree, it's error for good
		if ( wrnLVNoLongValues != err)
			{
			Call (err);
			}
		else
		// if wrnLVNoLongValues, that's fine
			err = JET_errSuccess;
	
HandleError:
	delIndent();
	
	if( pfucbNil != pfucbLV )
		DIRClose( pfucbLV );	

	Assert(pfucbTable);
	Assert( Pcsr(pfucbTable ));
	Assert( !Pcsr(pfucbTable )->FLatched() );

	return err;
	}


// dump the indexes
// iterates trough the secondary index list, if any
LOCAL ERR ErrESEDUMPIndexForOneTable(FUCB *pfucbTable, JET_GRBIT grbitESEDUMPMode)
	{
	
	ERR	err = 			JET_errSuccess;
	FUCB *pfucbIndex = 	pfucbNil;
	FCB * pfcb =		pfcbNil;
	
	
	Assert(pfucbTable);
	Assert( Pcsr(pfucbTable ));
	Assert( !Pcsr(pfucbTable )->FLatched() );

	// get the first secondary index
	pfcb = pfucbTable->u.pfcb->PfcbNextIndex();
	
	addIndent();
	
	// if a secondary index still exists ...	
	while (pfcb)
		{
		// open it
		Call (ErrDIROpen(
					pfucbTable->ppib,
					pfcb->PgnoFDP(),
					pfucbTable->ifmp,
					&pfucbIndex ));
					
		Assert(pfucbIndex != pfucbNil );
		
		FUCBSetIndex( pfucbIndex );

		// print the name of the index, with ifmp and pageNo.
		USHORT indexNameTag = 0;
		char * szIndexName = (char *)0;
		FCB *pfcbT = pfucbTable->u.pfcb;
		
		Assert(pfcbT);	
		Assert(pfucbIndex->u.pfcb->Pidb());
		indexNameTag = pfucbIndex->u.pfcb->Pidb()->ItagIndexName();

		Assert( pfcbT->Ptdb() );
		szIndexName = pfcbT->Ptdb()->SzIndexName(indexNameTag,
													pfucbIndex->u.pfcb->FDerivedIndex()); 			
		Assert(szIndexName);
				
			
		addPBI("\n");
		addPBI("[%d , %d] INDEX %s:\n",
					pfucbIndex->ifmp,
					pfucbIndex->u.pfcb->PgnoFDP(),
					szIndexName);
		flushPB();
		Assert( !Pcsr( pfucbIndex )->FLatched() );

		// dump the space info for the Index tree himself
		Call (ErrESEDUMPCheckAndDumpSpaceInfo(pfucbIndex, grbitESEDUMPMode));
		
		// dumps the nodes for the index
		Call (ErrESEDUMPNodesForOneTree(pfucbIndex, grbitESEDUMPMode));

		// close the current index
		DIRClose(pfucbIndex);
		pfucbIndex = pfucbNil;			

		// move to the next index
		pfcb = pfcb->PfcbNextIndex();
		}
	
HandleError:
	delIndent();
	if ( pfucbNil != pfucbIndex)
		{
		DIRClose(pfucbIndex);
		}

	Assert(pfucbTable);
	Assert( Pcsr(pfucbTable ));
	Assert( !Pcsr(pfucbTable )->FLatched() );
	return err;
	}

// dumps nodes from Btree 
// If the Btree is a space tree (nodes contains info about extents),
// the node info is processed in order to show the pages of the extent
// If the Btree is of other kind (table records, table index, LV) the nodes
// are dumped adding only info about the page/line/flags/key size/data size
// and the first part of the key is dumped also (see MAX_KEY_SIZE_DISPLAY)
LOCAL ERR ErrESEDUMPNodesForOneTree(FUCB *pfucbTable, JET_GRBIT grbitESEDUMPMode, PfnFormatNodeInfo pfnFormat)
	{
	ERR	err = 			JET_errSuccess;
	int fSpaceTree = 	fFalse;
	DIB dib;

	Assert( pfucbTable );
	Assert( Pcsr( pfucbTable ) );
	Assert( !Pcsr( pfucbTable )->FLatched() );
	
	// start to dump from the first node
	dib.pos 	= posFirst;			
	dib.dirflag = (grbitESEDUMPMode & JET_bitDBUtilOptionAllNodes)?
						fDIRAllNode:fDIRNull;

	err = ErrDIRDown( pfucbTable, &dib );	

	if ( JET_errRecordNotFound == err )
		{
		addIndent();
		addPBI("NODES: none \n");
		delIndent();
		flushPB();
		
		Assert(pfucbTable);
		Assert( Pcsr(pfucbTable ));
		Assert( !Pcsr(pfucbTable )->FLatched() );
		return JET_errSuccess;
		}

	if ( JET_errSuccess != err )
		{
		Assert(pfucbTable);
		Assert( Pcsr(pfucbTable ));
		Assert( !Pcsr(pfucbTable )->FLatched() );
		CallR (err);
		}

	Assert (JET_errSuccess == err );
	Assert( Pcsr(pfucbTable )->FLatched() );

	fSpaceTree = Pcsr(pfucbTable)->Cpage().FSpaceTree();
	
	addIndent();
	addPBI("NODES:\n");
	
	// print the header, there are small differences between 
	// ordinary and space tree nodes
	addIndent();
	addPBI("********************************"
				"**********************************\n");

	if (pfnFormat)
		{
		addPBI("Page    | Line | Flags | KSize | DSize | Node info \n");
		}
	else if (fSpaceTree)
		{
		addPBI("Page    | Line | Flags | KSize | DSize | Pages\n");
		}
	else
		{
		addPBI("Page    | Line | Flags | KSize | DSize | Key value\n");
		}
		
	addPBI("********************************"
				"**********************************\n");

	flushPB();

	// goes to each node of the tree
	// Obs: ErrESEDUMPIsamMove will return with 
	// JET_errRecordDeleted on deleted records
	while ( JET_errSuccess == err )
		{

		char *pCustomFormat;
		char keyDataPrintBuffer[ max ( MAX_KEY_SIZE_DISPLAY * 3 /* = space for " %02X" */ + 1,
									2*12 + 3 /* = "%lu - %lu"*/ + 1) ];
		
		keyDataPrintBuffer[0] = 0;
		
		if (pfnFormat)
			{
			pCustomFormat = pfnFormat( &pfucbTable->kdfCurr );
			}
		// print the extent pages info for space trees
		// or the key for others
		else if (fSpaceTree)
			{
			ULONG lastPage;
			PGNO noPages;
			
			LongFromKey(&lastPage, pfucbTable->kdfCurr.key);	
			Assert( pfucbTable->kdfCurr.data.Cb() == sizeof( PGNO ) );
			noPages = *(UnalignedLittleEndian< PGNO > *) pfucbTable->kdfCurr.data.Pv();

			Assert(lastPage >= noPages);
			sprintf(keyDataPrintBuffer, "%lu - %lu", lastPage - noPages + 1, lastPage);
			}
		else
			{
			char keyBuffer[MAX_KEY_SIZE_DISPLAY];
			
			pfucbTable->kdfCurr.key.CopyIntoBuffer( keyBuffer, 
						min(MAX_KEY_SIZE_DISPLAY,
							pfucbTable->kdfCurr.key.Cb()) );

			BYTE * pbT	= (BYTE *)keyDataPrintBuffer;

			for( ULONG i = 0 ;
				i < min(MAX_KEY_SIZE_DISPLAY, pfucbTable->kdfCurr.key.Cb());
				i++)
				{
				const BYTE	b	= keyBuffer[i];

				*pbT++ = mpbb[b >> 4];
				*pbT++ = mpbb[b & 0x0f];
				*pbT++ = ' ';
				}
			*pbT = 0;
			}

		// print the common info of the node and the specific ones at the end
		addPBI("%7d | %4d |  %c%c%c  | %5ld | %5ld | %s\n", 
					pfucbTable->csr.Pgno(),
					pfucbTable->csr.ILine(), 
					pfucbTable->kdfCurr.fFlags & fNDCompressed ? 'c':' ',
					pfucbTable->kdfCurr.fFlags & fNDDeleted ? 'd':' ',
					pfucbTable->kdfCurr.fFlags & fNDVersion ? 'v':' ',					
					pfucbTable->kdfCurr.key.Cb(),
					pfucbTable->kdfCurr.data.Cb(),
					pfnFormat?pCustomFormat:keyDataPrintBuffer);
		
		Assert( Pcsr( pfucbTable )->FLatched() );
		Call (ErrDIRRelease( pfucbTable ));
		Assert( !Pcsr( pfucbTable )->FLatched() );

		// move to next node
		err = ErrDIRNext(pfucbTable, (grbitESEDUMPMode & JET_bitDBUtilOptionAllNodes)?
						fDIRAllNode:fDIRNull);
		
		}

	// chech for error, JET_errNoCurrentRecord is not an error
	if (JET_errNoCurrentRecord == err )
		{
		err = JET_errSuccess;
		}

HandleError:
	flushPB();
	delIndent();
	delIndent();

	if ( Pcsr( pfucbTable )->FLatched() )
		(VOID)ErrDIRRelease( pfucbTable );
		
	Assert(pfucbTable);
	Assert( Pcsr(pfucbTable ));
	Assert( !Pcsr(pfucbTable )->FLatched() );
	return err;
	}


// Check the split buffer (and dump it) for space tree root
// Call ErrESEDUMPSpaceInfoForOneTree for pages that have 
// space info (root of tree and not SpaceTrees), where the
// space header is checked and dumped, if MultiExtent also
// the Own and Avail trees are dumped
LOCAL ERR ErrESEDUMPCheckAndDumpSpaceInfo(FUCB *pfucb, JET_GRBIT grbitESEDUMPMode)
	{	
	ERR	err = 			JET_errSuccess;
	int fIsSpaceTree = 	fFalse;
	int fIsRoot =		fFalse;
	LINE line;
	
	Assert(pfucb);
	Assert( Pcsr(pfucb ));
	Assert( !Pcsr(pfucb )->FLatched() );

	// get the root page (read mode) so that
	// the flags and buffer/header are accesible
	CallR (ErrBTIGotoRoot( pfucb, latchReadNoTouch ));
	Assert( Pcsr(pfucb )->FLatched() );

	fIsSpaceTree = Pcsr(pfucb )->Cpage().FSpaceTree();
	fIsRoot =  Pcsr(pfucb )->Cpage().FRootPage();

	if (!fIsSpaceTree && !fIsRoot)
		{
		goto HandleError;
		}

	
	Pcsr(pfucb )->Cpage().GetPtrExternalHeader( &line );

	Assert ( (fIsSpaceTree &&	sizeof( SPLIT_BUFFER ) == line.cb) ||
			 (fIsRoot && sizeof( SPACE_HEADER ) == line.cb) );
	
	// for space trees (with SPLIT_BUFFER) dump info on that one
	if (fIsSpaceTree)
		{		
		if (sizeof( SPLIT_BUFFER ) == line.cb)
			{
			SPLIT_BUFFER spb;
			UtilMemCpy( &spb, line.pv, sizeof( SPLIT_BUFFER ) );
			ESEDUMPSplitBufferDump(spb, pfucb, grbitESEDUMPMode);
			}
		else
			{
			addIndent();
			addPBI("SPLIT BUFFER not found in tree.\n");
			delIndent();
			}
		}
	else
		{
		SPACE_HEADER sph;
		
		UtilMemCpy( &sph, line.pv, sizeof( SPACE_HEADER ) );

		addIndent();
		addPBI("\n");
		addPBI("SPACE INFO:\n");		
		addIndent();
		addPBI("Primary extent size: %ld page%s\n", sph.CpgPrimary(),
					sph.CpgPrimary() == 1 ? "" : "s" );

		if ( sph.FSingleExtent())
			{
			ESEDUMPSingleSpaceHeaderDump(sph, pfucb, grbitESEDUMPMode);
			}
		else
			{
			err = ErrESEDUMPMultipleSpaceHeaderDump(sph, pfucb, grbitESEDUMPMode);
			}
			
		delIndent();
		delIndent();
		}

HandleError:
	flushPB();
	Assert(pfucb);
	Assert( Pcsr(pfucb ));
	Assert( Pcsr(pfucb )->FLatched() );
	BTUp(pfucb);
	Assert( !Pcsr(pfucb )->FLatched() );
	return err;	
	}


// Used to check only the database header, print the pagenumber
// then call the space info function for this page
LOCAL ERR ErrESEDUMPDatabaseInfo(PIB *ppib, IFMP ifmp, JET_GRBIT grbitESEDUMPMode)
	{
	FUCB *pfucbDb = 	pfucbNil;
	ERR	err = 			JET_errSuccess;
	
	// open the table
	CallR (ErrDIROpen( 
				ppib, 
				pgnoSystemRoot,
				ifmp,
				&pfucbDb ));
	Assert( pfucbNil != pfucbDb );
	Assert( pfcbNil != pfucbDb->u.pfcb );
	Assert( pgnoSystemRoot == pfucbDb->u.pfcb->PgnoFDP());

	addPBI("\n");
	addPBI("[%d , %d] DATABASE ROOT\n", ifmp, pgnoSystemRoot);
	flushPB();

	Call (ErrESEDUMPCheckAndDumpSpaceInfo(pfucbDb, grbitESEDUMPMode));

HandleError:
	DIRClose(pfucbDb);
	return err;
	}


// just dumps a SPLIT_BUFFER
LOCAL VOID ESEDUMPSplitBufferDump(SPLIT_BUFFER & spb, FUCB * pfucb, JET_GRBIT grbitESEDUMPMode)
{
	Assert(pfucb);
	Assert(Pcsr(pfucb));
	Assert(Pcsr(pfucb)->Cpage().FSpaceTree());
	
	addIndent();
	addPBI("SPLIT BUFFER:\n");
	addIndent();
	addPBI("Buffer 1: Pgno = %ld, Count %ld\n",
				spb.PgnoLastBuffer1(),
				spb.CpgBuffer1());
	addPBI("Buffer 2: Pgno = %ld, Count %ld\n",
				spb.PgnoLastBuffer2(),
				spb.CpgBuffer2());
	delIndent();	
	delIndent();	
	flushPB();
}

// dumps a SPACE_HEADER with SingleExtent
LOCAL VOID ESEDUMPSingleSpaceHeaderDump(SPACE_HEADER & sph, FUCB * pfucb, JET_GRBIT grbitESEDUMPMode)
{
	Assert( sph.FSingleExtent());
	Assert(pfucb);
	
	// space info are in the same space_header as bit array
	addPBI("Single extent covering pages %d to %d\n",
				PgnoFDP(pfucb),
				PgnoFDP(pfucb) + sph.CpgPrimary() -1 );		

	
	UINT rgbAvailBitMask = sph.RgbitAvail();
	UINT rgbCurrentPageMask = 0x1;
	
	PGNO pageNo = PgnoFDP(pfucb) + 1;

	char pagesPrintBuffer[ 8*sizeof(UINT) * 12 /* " %lu"  */ + 1];
	pagesPrintBuffer[0] = 0;
	
	while(rgbCurrentPageMask)
		{
		if (rgbAvailBitMask & rgbCurrentPageMask)	
			sprintf(pagesPrintBuffer + strlen(pagesPrintBuffer)," %lu", pageNo);

		rgbCurrentPageMask = rgbCurrentPageMask << 1;
		pageNo++;
		}
	addPBI("Avail pages : %s\n", pagesPrintBuffer);	
	flushPB();
}


// dumps a SPACE_HEADER with MutipleExtent
LOCAL ERR ErrESEDUMPMultipleSpaceHeaderDump(SPACE_HEADER & sph, FUCB * pfucb, JET_GRBIT grbitESEDUMPMode)
	{
	FUCB *pfucbExtent = 	pfucbNil;
	ERR	err = 				JET_errSuccess;
	
	Assert(pfucb);
	Assert( Pcsr(pfucb ));
	Assert( Pcsr(pfucb )->FLatched() );
	
	
	Assert (sph.FMultipleExtent());
	addPBI("Multiple extents\n");
	addPBI("Own extent page number   : %d\n", sph.PgnoOE());
	addPBI("Avail extent page number : %d\n", sph.PgnoAE());
	flushPB();
	
	// for each of two trees (own and avail)
	// we must dump the space tree and the nodes
	// 2 steps: 0 - Own, 1 - Avail
	for(int step = 0; step < 2; step++)
		{
		addPBI(step?"[%d , %d] AVAIL EXTENT:\n":"[%d , %d] OWN EXTENT:\n",
					pfucb->ifmp,
					step?sph.PgnoAE():sph.PgnoOE());
		flushPB();

		// open the page of the coresponding space tree
		Call (ErrDIROpen( 
					pfucb->ppib,
					step?sph.PgnoAE():sph.PgnoOE(),
					pfucb->ifmp,
					&pfucbExtent ));
		FUCBSetIndex( pfucbExtent );
		Assert( pfucbExtent != pfucbNil);
		
		Call (ErrESEDUMPCheckAndDumpSpaceInfo(pfucbExtent, grbitESEDUMPMode));

		Call (ErrESEDUMPNodesForOneTree(pfucbExtent, grbitESEDUMPMode));

		DIRClose(pfucbExtent);
		pfucbExtent = pfucbNil;					
		}

HandleError:
	if ( pfucbNil != pfucbExtent)
		{
		DIRClose(pfucbExtent);
		}
	Assert( pfucb );
	Assert( Pcsr(pfucb ) );
	Assert( Pcsr(pfucb )->FLatched() );
	flushPB();
	return err;	
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ese98\src\ese\dir.cxx ===
#include "std.hxx"

//	prototypes of DIR internal routines
//
LOCAL ERR ErrDIRICheckIndexRange( FUCB *pfucb, const KEY& key );
LOCAL ERR ErrDIRIIRefresh( FUCB * const pfucb );
INLINE ERR ErrDIRIRefresh( FUCB * const pfucb )
	{
 	return ( locDeferMoveFirst != pfucb->locLogical ?
				JET_errSuccess :
				ErrDIRIIRefresh( pfucb ) );
	}

extern CCriticalSection	critCommit0;


//  perf stats

PM_CEF_PROC LDIRUserROTrxCommit0CEFLPv;
PERFInstanceG<> cDIRUserROTrxCommit0;
long LDIRUserROTrxCommit0CEFLPv(long iInstance,void *pvBuf)
{
	cDIRUserROTrxCommit0.PassTo( iInstance, pvBuf );
	return 0;
}


PM_CEF_PROC LDIRUserRWTrxCommit0CEFLPv;
PERFInstanceG<> cDIRUserRWTrxCommit0;
long LDIRUserRWTrxCommit0CEFLPv(long iInstance,void *pvBuf)
{
	cDIRUserRWTrxCommit0.PassTo( iInstance, pvBuf );
	return 0;
}


PM_CEF_PROC LDIRUserTrxCommit0CEFLPv;
long LDIRUserTrxCommit0CEFLPv(long iInstance,void *pvBuf)
{
	if ( NULL != pvBuf )
		{
		*((LONG *)pvBuf) = cDIRUserROTrxCommit0.Get( iInstance )+ cDIRUserRWTrxCommit0.Get( iInstance );
		}
	return 0;
}


PM_CEF_PROC LDIRUserROTrxRollback0CEFLPv;
PERFInstanceG<> cDIRUserROTrxRollback0;
long LDIRUserROTrxRollback0CEFLPv(long iInstance,void *pvBuf)
{
	cDIRUserROTrxRollback0.PassTo( iInstance, pvBuf );
	return 0;
}


PM_CEF_PROC LDIRUserRWTrxRollback0CEFLPv;
PERFInstanceG<> cDIRUserRWTrxRollback0;
long LDIRUserRWTrxRollback0CEFLPv(long iInstance,void *pvBuf)
{
	cDIRUserRWTrxRollback0.PassTo( iInstance, pvBuf );
	return 0;
}


PM_CEF_PROC LDIRUserTrxRollback0CEFLPv;
long LDIRUserTrxRollback0CEFLPv(long iInstance,void *pvBuf)
{
	if ( NULL != pvBuf )
		{
		*((LONG *)pvBuf) = cDIRUserROTrxRollback0.Get( iInstance ) + cDIRUserRWTrxRollback0.Get( iInstance );
		}
	return 0;
}


PM_CEF_PROC LDIRSystemROTrxCommit0CEFLPv;
PERFInstanceG<> cDIRSystemROTrxCommit0;
long LDIRSystemROTrxCommit0CEFLPv(long iInstance,void *pvBuf)
{
	cDIRSystemROTrxCommit0.PassTo( iInstance, pvBuf );
	return 0;
}


PM_CEF_PROC LDIRSystemRWTrxCommit0CEFLPv;
PERFInstanceG<> cDIRSystemRWTrxCommit0;
long LDIRSystemRWTrxCommit0CEFLPv(long iInstance,void *pvBuf)
{
	cDIRSystemRWTrxCommit0.PassTo( iInstance, pvBuf );
		
	return 0;
}


PM_CEF_PROC LDIRSystemTrxCommit0CEFLPv;
long LDIRSystemTrxCommit0CEFLPv(long iInstance,void *pvBuf)
{
	if ( NULL != pvBuf )
		{
		*((LONG *)pvBuf) = cDIRSystemROTrxCommit0.Get( iInstance ) + cDIRSystemRWTrxCommit0.Get( iInstance );
		}
	return 0;
}


PM_CEF_PROC LDIRSystemROTrxRollback0CEFLPv;
PERFInstanceG<> cDIRSystemROTrxRollback0;
long LDIRSystemROTrxRollback0CEFLPv(long iInstance,void *pvBuf)
{
	cDIRSystemROTrxRollback0.PassTo( iInstance, pvBuf );
	return 0;
}


PM_CEF_PROC LDIRSystemRWTrxRollback0CEFLPv;
PERFInstanceG<> cDIRSystemRWTrxRollback0;
long LDIRSystemRWTrxRollback0CEFLPv(long iInstance,void *pvBuf)
{
	cDIRSystemRWTrxRollback0.PassTo( iInstance, pvBuf );
	return 0;
}


PM_CEF_PROC LDIRSystemTrxRollback0CEFLPv;
long LDIRSystemTrxRollback0CEFLPv(long iInstance,void *pvBuf)
{
	if ( NULL != pvBuf )
		{
		*((LONG *)pvBuf) = cDIRSystemROTrxRollback0.Get( iInstance ) + cDIRSystemRWTrxRollback0.Get( iInstance );
		}
	return 0;
}


//	*****************************************
//	DIR API functions
//

// *********************************************************
// ******************** DIR API Routines ********************
//

//	***********************************************
//	constructor/destructor routines
//

//	creates a directory
//	get a new extent from space that is initialized to a directory
//
ERR ErrDIRCreateDirectory(
	FUCB	*pfucb,
	CPG		cpgMin,
	PGNO	*ppgnoFDP,
	OBJID	*pobjidFDP,
	UINT	fPageFlags,
	BOOL	fSPFlags )
	{
	ERR		err;
	CPG		cpgRequest = cpgMin;

	CheckFUCB( pfucb->ppib, pfucb );
	Assert( NULL != ppgnoFDP );
	Assert( NULL != pobjidFDP );

	//	check currency is on "parent" FDP
	//
	Assert( !Pcsr( pfucb )->FLatched( ) );
	Assert( locOnFDPRoot == pfucb->locLogical );

	fSPFlags |= fSPNewFDP;

	// WARNING: Should only create an unversioned extent if its parent was
	// previously created and versioned in the same transaction as the
	// creation of this extent.
	Assert( ( fSPFlags & fSPUnversionedExtent )
		|| dbidTemp != rgfmp[ pfucb->ifmp ].Dbid() );		// Don't version creation of temp. table.

	//	create FDP
	//
	*ppgnoFDP = pgnoNull;
	Call( ErrSPGetExt(
		pfucb,
		PgnoFDP( pfucb ),
		&cpgRequest,
		cpgMin,
		ppgnoFDP,
		fSPFlags,
		fPageFlags,
		pobjidFDP ) );
	Assert( *ppgnoFDP > pgnoSystemRoot );
	Assert( *ppgnoFDP <= pgnoSysMax );
	Assert( *pobjidFDP > objidSystemRoot );

HandleError:
	return err;
	}


//	***********************************************
//	Open/Close routines
//

//	opens a cursor on given ifmp, pgnoFDP
//
ERR ErrDIROpen( PIB *ppib, PGNO pgnoFDP, IFMP ifmp, FUCB **ppfucb )
	{
	ERR		err;
	FUCB	*pfucb;

	CheckPIB( ppib );

#ifdef DEBUG
	INST *pinst = PinstFromPpib( ppib );
	if ( !pinst->m_plog->m_fRecovering
		 && pinst->m_fSTInit == fSTInitDone
		 && !Ptls()->fIsTaskThread
		 && !Ptls()->fIsRCECleanup )
		{
		CheckDBID( ppib, ifmp );
		}
#endif

	CallR( ErrBTOpen( ppib, pgnoFDP, ifmp, &pfucb ) );
	DIRInitOpenedCursor( pfucb, pfucb->ppib->level );

	//	set return pfucb
	//
	*ppfucb = pfucb;
	return JET_errSuccess;
	}

//	open cursor, don't touch root page
ERR ErrDIROpenNoTouch( PIB *ppib, IFMP ifmp, PGNO pgnoFDP, OBJID objidFDP, BOOL fUnique, FUCB **ppfucb )
	{
	ERR		err;
	FUCB	*pfucb;

	CheckPIB( ppib );

#ifdef DEBUG
	INST *pinst = PinstFromPpib( ppib );
	if ( !pinst->m_plog->m_fRecovering
		 && pinst->m_fSTInit == fSTInitDone
		 && !Ptls()->fIsTaskThread
		 && !Ptls()->fIsRCECleanup )
		{
		CheckDBID( ppib, ifmp );
		}
#endif

	CallR( ErrBTOpenNoTouch( ppib, ifmp, pgnoFDP, objidFDP, fUnique, &pfucb ) );
	DIRInitOpenedCursor( pfucb, pfucb->ppib->level );

	//	set return pfucb
	//
	*ppfucb = pfucb;
	return JET_errSuccess;
	}

//	open cursor on given FCB
//
ERR	ErrDIROpen( PIB *ppib, FCB *pfcb, FUCB **ppfucb )
	{
	ERR		err;
	FUCB	*pfucb;

	CheckPIB( ppib );

#ifdef DEBUG
	INST *pinst = PinstFromPpib( ppib );
	if ( !pinst->m_plog->m_fRecovering
		&& pinst->m_fSTInit == fSTInitDone 
		&& !Ptls()->fIsTaskThread
		&& !Ptls()->fIsRCECleanup )
		{
		CheckDBID( ppib, pfcb->Ifmp() );
		}
#endif

	Assert( pfcbNil != pfcb );
	CallR( ErrBTOpen( ppib, pfcb, &pfucb ) );
	DIRInitOpenedCursor( pfucb, pfucb->ppib->level );

	//	set return pfucb
	//
	*ppfucb = pfucb;
	return JET_errSuccess;
	}

//	open cursor on given FCB on behalf of another session
//
ERR	ErrDIROpenByProxy( PIB *ppib, FCB *pfcb, FUCB **ppfucb, LEVEL level )
	{
	ERR		err;
	FUCB	*pfucb;

	CheckPIB( ppib );

#ifdef DEBUG
	INST *pinst = PinstFromPpib( ppib );
	if ( !pinst->m_plog->m_fRecovering
		&& pinst->m_fSTInit == fSTInitDone
		&& !Ptls()->fIsTaskThread
	 	&& !Ptls()->fIsRCECleanup )
		{
		CheckDBID( ppib, pfcb->Ifmp() );
		}
#endif

	Assert( pfcbNil != pfcb );
	Assert( level > 0 );
	CallR( ErrBTOpenByProxy( ppib, pfcb, &pfucb, level ) );
	DIRInitOpenedCursor( pfucb, level );

	//	set return pfucb
	//
	*ppfucb = pfucb;
	return JET_errSuccess;
	}


//	closes cursor
//	frees space allocated for logical currency
//
VOID DIRClose( FUCB *pfucb )
	{
	//	this cursor should not be already defer closed
	//
	Assert( PinstFromIfmp( pfucb->ifmp )->m_plog->m_fRecovering || !FFUCBDeferClosed(pfucb) );

	RECReleaseKeySearchBuffer( pfucb );
	FILEReleaseCurrentSecondary( pfucb );

	BTClose( pfucb );
	}


//	***************************************************
//	RETRIEVE OPERATIONS
//

//	currency is implemented at BT level,
//	so DIRGet just does a BTRefresh()
//	returns a latched page iff the node access is successful
//
ERR ErrDIRGet( FUCB *pfucb )
	{
	ERR		err;

	CheckFUCB( pfucb->ppib, pfucb );
	Assert( !FFUCBSpace( pfucb ) );

	//	UNDONE: special case
	// 		if on current BM and page cached and
	// 		timestamp not changed and
	// 		node has not been versioned
	//
	if ( locOnCurBM == pfucb->locLogical )
		{
		Call( ErrBTGet( pfucb ) );
		Assert( Pcsr( pfucb )->FLatched() );
		return err;
		}

	CallR( ErrDIRIRefresh( pfucb ) );
	
	//	check logical currency status
	//
	switch ( pfucb->locLogical )
		{
		case locOnCurBM:
			Call( ErrBTGet( pfucb ) );
			return err;

		case locAfterSeekBM:
		case locBeforeSeekBM:
		case locOnFDPRoot:
		case locDeferMoveFirst:
			Assert( fFalse );
			break;

///		case locOnSeekBM:
///			return ErrERRCheck( JET_errRecordDeleted );
///			break;
			
		default:
			Assert( pfucb->locLogical == locAfterLast
					|| pfucb->locLogical == locOnSeekBM
					|| pfucb->locLogical == locBeforeFirst );
			return ErrERRCheck( JET_errNoCurrentRecord );
		}

	Assert( fFalse );
	return err;

HandleError:
	BTUp( pfucb );
	Assert( !Pcsr( pfucb )->FLatched() );
	return err;
	}


//	gets fractional postion of current node in directory
//
ERR ErrDIRGetPosition( FUCB *pfucb, ULONG *pulLT, ULONG *pulTotal )
	{
	ERR		err;
	ULONG	ulLT;
	ULONG	ulTotal;

	CheckFUCB( pfucb->ppib, pfucb );
	Assert( !Pcsr( pfucb )->FLatched() );
	Assert( !FFUCBSpace( pfucb ) );

	//	refresh logical currency
	//
	Call( ErrDIRIRefresh( pfucb ) );

	//	return error if not on a record
	//
	if ( locOnCurBM != pfucb->locLogical &&
		 locOnSeekBM != pfucb->locLogical )
		{
		return ErrERRCheck( JET_errNoCurrentRecord );
		}

	//	get approximate position of node.
	//
	Call( ErrBTGetPosition( pfucb, &ulLT, &ulTotal ) );
	CallS( err );
	
	Assert( ulLT <= ulTotal );
	*pulLT = ulLT;
	*pulTotal = ulTotal;

HandleError:
	Assert( !Pcsr( pfucb )->FLatched() );
	return err;
	}


//	reverses a DIRGet() operation
//	releases latch on page after recording bm of node or seek in pfucb
//
ERR	ErrDIRRelease( FUCB *pfucb )
	{
	ERR		err;

	Assert( pfucb->locLogical == locOnCurBM ||
			pfucb->locLogical == locAfterSeekBM ||
			pfucb->locLogical == locBeforeSeekBM );
	Assert( !FFUCBSpace( pfucb ) );

	switch ( pfucb->locLogical )
		{
		case locOnCurBM:
///			AssertDIRGet( pfucb );
			Call( ErrBTRelease( pfucb ) );
			break;
		
		case locAfterSeekBM:
		case locBeforeSeekBM:
			{
			BOOKMARK	bm;

			FUCBAssertValidSearchKey( pfucb );
			bm.Nullify();

			//	first byte is segment counter
			//
			bm.key.suffix.SetPv( pfucb->dataSearchKey.Pv() );
			bm.key.suffix.SetCb( pfucb->dataSearchKey.Cb() );
			Call( ErrBTDeferGotoBookmark( pfucb, bm, fFalse/*no touch*/ ) );
			pfucb->locLogical = locOnSeekBM;
			break;
			}
			
		default:
			//	should be impossible, but return success just in case
			//	(okay to return success because we shouldn't have a latch
			//	even if the locLogical is an unexpected value)
			AssertSz( fFalse, "Unexpected locLogical" );
			err = JET_errSuccess;
			break;
		}

	Assert( !Pcsr( pfucb )->FLatched() );
	return err;
	
HandleError:
	Assert( err < 0 );

	//	bookmark could not be saved
	//	move up
	//
	Assert( JET_errOutOfMemory == err );
	DIRUp( pfucb );

	Assert( !Pcsr( pfucb )->FLatched() );
	return err;
	}

//	***************************************************
//	POSITIONING OPERATIONS
//

//	called from JetGotoBookmark
//		bookmark may not be valid
//		therefore, logical currency of cursor can be changed
//		only after we move to bookmark successfully
//		also, save bookmark and release latch
//
ERR	ErrDIRGotoJetBookmark( FUCB *pfucb, const BOOKMARK& bm )
	{
	ERR		err;
	
	Assert( !Pcsr( pfucb )->FLatched() );
	ASSERT_VALID( &bm );
	Assert( !FFUCBSpace( pfucb ) );

	if( !FFUCBSequential( pfucb ) )
		{
		FUCBResetPreread( pfucb );
		}

	Call( ErrBTGotoBookmark( pfucb, bm, latchReadNoTouch, fTrue ) );
	
	Assert( Pcsr( pfucb )->FLatched() );
	Assert( Pcsr( pfucb )->Cpage().FLeafPage() );

	Call( ErrBTGet( pfucb ) );
	pfucb->locLogical = locOnCurBM;

	Call( ErrBTRelease( pfucb ) );
	Assert( 0 == CmpBM( pfucb->bmCurr, bm ) );

	return err;

HandleError:
	BTUp( pfucb );
	return err;
	}


//	go to given bookmark
//	saves bookmark in cursor
//	next DIRGet() call will return an error if bookmark is not valid
//		this is an internal bookmark [possibly on/from a secondary index]
//		so bookmark should be valid
//
ERR	ErrDIRGotoBookmark( FUCB *pfucb, const BOOKMARK& bm )
	{
	ERR		err;

	ASSERT_VALID( &bm );
	Assert( !Pcsr( pfucb )->FLatched() );
	Assert( !FFUCBSpace( pfucb ) );

	if( !FFUCBSequential( pfucb ) )
		{
		FUCBResetPreread( pfucb );
		}

	//	copy given bookmark to cursor, we will need to touch the data page buffer
	//
	CallR( ErrBTDeferGotoBookmark( pfucb, bm, fTrue/*Touch*/ ) );
	pfucb->locLogical = locOnCurBM;

#ifdef DEBUG
	//	check that bookmark is valid
	//
	err = ErrBTGotoBookmark( pfucb, pfucb->bmCurr, latchReadNoTouch );
	switch( err )
		{
		case JET_errSuccess:
			//	if we suddenly lost visibility on the node, it must mean
			//	that we're at level 0 and the node deletion was suddenly
			//	committed underneath us
			if ( 0 != pfucb->ppib->level )
				{
				BOOL fVisible;
				CallS( ErrNDVisibleToCursor( pfucb, &fVisible ) );
				Assert( fVisible );
				}
			break;

		case JET_errRecordDeleted:
			//	node must have gotten expunged by RCEClean (only possible
			//	if we're at level 0)
			Assert( 0 == pfucb->ppib->level );
			break;

		case JET_errDiskIO:					//	(#48313 -- RFS testing causes JET_errDiskIO)
		case JET_errReadVerifyFailure:		//	(#86323 -- Repair testing causes JET_errReadVerifyFailure )
		case JET_errOutOfMemory:			//	(#146720 -- RFS testing causes JET_errOutOfMemory)
		case JET_errOutOfBuffers:
			break;

		default:
			//	force an assert
			CallS( err );
		}

	CallS( ErrBTRelease( pfucb ) );
#endif

	Assert( !Pcsr( pfucb )->FLatched() );
	return JET_errSuccess;
	}																					


//	goes to fractional position in directory
//
ERR ErrDIRGotoPosition( FUCB *pfucb, ULONG ulLT, ULONG ulTotal )
	{
	ERR		err;
	DIB		dib;
	FRAC	frac;

	CheckFUCB( pfucb->ppib, pfucb );
	Assert( !Pcsr( pfucb )->FLatched() );
	Assert( !FFUCBSpace( pfucb ) );

	if( !FFUCBSequential( pfucb ) )
		{
		FUCBResetPreread( pfucb );
		}

	//	set cursor navigation level for rollback support
	//
	FUCBSetLevelNavigate( pfucb, pfucb->ppib->level );

	//	UNDONE: do we need to refresh here???
	
	//	refresh logical currency
	//
	Call( ErrDIRIRefresh( pfucb ) );

	dib.dirflag = fDIRNull;
	dib.pos		= posFrac;
	dib.pbm		= reinterpret_cast<BOOKMARK *>( &frac );

	Assert( ulLT <= ulTotal );

	frac.ulLT		= ulLT;
	frac.ulTotal	= ulTotal;

	//	position fractionally on node.  Move up preserving currency
	//	in case down fails.
	//
	Call( ErrBTDown( pfucb, &dib, latchReadNoTouch ) );

	pfucb->locLogical = locOnCurBM;
	AssertDIRGet( pfucb );
	return err;
	
HandleError:
	Assert( !Pcsr( pfucb )->FLatched() );
	return err;
	}


//	seek down to a key or position in the directory
//		returns errSuccess, wrnNDFoundGreater or wrnNDFoundLess
//
ERR ErrDIRDown( FUCB *pfucb, DIB *pdib )
	{
	ERR		err;
	
	Assert( !Pcsr( pfucb )->FLatched() );
	Assert( pdib->pos != posFrac );
	Assert( !FFUCBSpace( pfucb ) );
	
	CheckFUCB( pfucb->ppib, pfucb );

	if( !FFUCBSequential( pfucb ) && !pfucb->u.pfcb->FTypeLV() )
		{
		FUCBResetPreread( pfucb );
		}

	//	set cursor navigation level for rollback support
	//
	FUCBSetLevelNavigate( pfucb, pfucb->ppib->level );

	err = ErrBTDown( pfucb, pdib, latchReadTouch );
	if ( err < 0 )
		{
		if( ( JET_errRecordNotFound == err )
			&& ( posDown == pdib->pos ) )
			{
			//  we didn't find the record we were looking for. save the bookmark
			//  so that a DIRNext/DIRPrev will work properly
			Call( ErrBTDeferGotoBookmark( pfucb, *(pdib->pbm), fFalse ) );
			pfucb->locLogical = locOnSeekBM;

			err = ErrERRCheck( JET_errRecordNotFound );
			}

		goto HandleError;
		}

	Assert( Pcsr( pfucb )->FLatched() );

	//	bookmark in pfucb has not been set to bm of current node
	//	but that will be done at the time of latch release
	//
	//	save physical position of cursor with respect to node
	//	
	if ( wrnNDFoundGreater == err )
		{
		pfucb->locLogical = locAfterSeekBM;
		}
	else if ( wrnNDFoundLess == err )
		{
		pfucb->locLogical = locBeforeSeekBM;
		}
	else
		{
		pfucb->locLogical = locOnCurBM;
		err = JET_errSuccess;
		}
		
	return err;

HandleError:
	Assert( err < 0 );
	Assert( !Pcsr( pfucb )->FLatched() );
	Assert( err != JET_errNoCurrentRecord );
	return err;
	}


//	seeks secondary index record corresponding to NC key + primary key
//
ERR ErrDIRDownKeyData( FUCB 		*pfucb, 
					   const KEY& 	key, 
					   const DATA& 	data )
	{
	ERR			err;
	BOOKMARK	bm;

	//	this routine should only be called with secondary indexes.
	//
	ASSERT_VALID( &key );
	ASSERT_VALID( &data );
	Assert( FFUCBSecondary( pfucb ) );
	Assert( locOnFDPRoot == pfucb->locLogical );
	Assert( !FFUCBSpace( pfucb ) );

	if( !FFUCBSequential( pfucb ) )
		{
		FUCBResetPreread( pfucb );
		}

	//	set cursor navigation level for rollback support
	//
	FUCBSetLevelNavigate( pfucb, pfucb->ppib->level );

	//	goto bookmark pointed by NC key + primary key
	//
	bm.key = key;
	if ( FFUCBUnique( pfucb ) )
		{
		bm.data.Nullify();
		}
	else
		{
		bm.data = data;
		}
	Call( ErrDIRGotoBookmark( pfucb, bm ) );
	CallS( err );

	return JET_errSuccess;

HandleError:
	Assert( JET_errNoCurrentRecord != err );
	Assert( !Pcsr( pfucb )->FLatched() );
	return err;
	}


//	CONSIDER: not needed for one-level trees?
//	
//	moves cursor to root -- releases latch, if any
//
VOID DIRUp( FUCB *pfucb )
	{
	BTUp( pfucb );
	Assert( !Pcsr( pfucb )->FLatched() );

	pfucb->locLogical = locOnFDPRoot;
	}


//	moves cursor to node after current bookmark
//	if cursor is after current bookmark, gets current record
//
ERR ErrDIRNext( FUCB *pfucb, DIRFLAG dirflag )
	{
	ERR		err;
	ERR		wrn = JET_errSuccess;

	CheckFUCB( pfucb->ppib, pfucb );
	Assert( !FFUCBSpace( pfucb ) );

	//  set preread flags if we are navigating sequentially
	if( FFUCBSequential( pfucb ) )
		{
		FUCBSetPrereadForward( pfucb, cpgPrereadSequential );
		}
#ifdef PREDICTIVE_PREREAD
	else
		{
		if( FFUCBPrereadForward( pfucb ) )
			{
			if( !FFUCBPreread( pfucb )
				&& FFUCBIndex( pfucb )
				&& pfucb->cbSequentialDataRead >= cbSequentialDataPrereadThreshold
				&& locOnCurBM == pfucb->locLogical )	//	can't call DIRRelease() if locBefore/AfterSeekBM because there may not be a bookmark available
				{
				FUCBSetPrereadForward( pfucb, cpgPrereadPredictive );
				//  release to save bookmark and nullify csr to force a BTDown
				Call( ErrDIRRelease( pfucb ) );
				BTUp( pfucb );
				}
			}
		else
			{
			FUCBResetPreread( pfucb );
			pfucb->fPrereadForward = fTrue;
			}
		}
#endif	//	PREDICTIVE_PREREAD

	//	set cursor navigation level for rollback support
	//
	FUCBSetLevelNavigate( pfucb, pfucb->ppib->level );

Refresh:
	//	check currency and refresh if necessary
	//
	Call( ErrDIRIRefresh( pfucb ) );

	//	switch action based on logical cursor location
	//
	switch( pfucb->locLogical )
		{
		case locOnCurBM:
		case locBeforeSeekBM:
			break;

		case locOnSeekBM:
			{
			//	re-seek to key and if foundLess, fall through to MoveNext
			//
			Call( ErrBTPerformOnSeekBM( pfucb, fDIRFavourNext ) );
			Assert( Pcsr( pfucb )->FLatched() );

			if ( wrnNDFoundGreater == err )
				{
				pfucb->locLogical = locOnCurBM;
				return JET_errSuccess;
				}
			else
				{
				Assert( wrnNDFoundLess == err );
				}
			break;
			}
			
		case locOnFDPRoot: 
			return( ErrERRCheck( JET_errNoCurrentRecord ) );

		case locAfterLast:
			return( ErrERRCheck( JET_errNoCurrentRecord ) );

		case locAfterSeekBM:
			Assert( Pcsr( pfucb )->FLatched() );

			//	set currency on current
			//
			pfucb->locLogical = locOnCurBM;
			Assert( Pcsr( pfucb )->FLatched( ) );
			
			return err;

		default:
			{
			DIB	dib;
			Assert( locBeforeFirst == pfucb->locLogical );

			//	move to root.
			//
			DIRGotoRoot( pfucb );
			dib.dirflag	= fDIRNull;
			dib.pos		= posFirst;
			err = ErrDIRDown( pfucb, &dib );
			if ( err < 0 )
				{
				//	retore currency.
				//
				pfucb->locLogical = locBeforeFirst;
				Assert( !Pcsr( pfucb )->FLatched() );

				//	polymorph error code.
				//
				if ( err == JET_errRecordNotFound )
					{
					err = ErrERRCheck( JET_errNoCurrentRecord );
					}
				}

			return err;
			}
		}

	Assert( locOnCurBM == pfucb->locLogical ||
			locBeforeSeekBM == pfucb->locLogical ||
			locOnSeekBM == pfucb->locLogical && err != wrnNDFoundGreater );

	err = ErrBTNext( pfucb, dirflag );

	if ( err < 0 )
		{
		if ( JET_errNoCurrentRecord == err )
			{
			//	moved past last node
			//
			pfucb->locLogical = locAfterLast;
			}
		else if ( JET_errRecordDeleted == err )
			{
			//	node was deleted from under the cursor
			//	reseek to logical bm and move to next node
			//
			BTSetupOnSeekBM( pfucb );
			goto Refresh;
			}
		goto HandleError;
		}

	pfucb->locLogical = locOnCurBM;
	wrn = err;
	
	//	check index range
	//
	if ( FFUCBLimstat( pfucb ) && 
		 FFUCBUpper( pfucb ) && 
		 JET_errSuccess == err )
		{
		Call( ErrDIRICheckIndexRange( pfucb, pfucb->kdfCurr.key ) );
		}

#ifdef PREDICTIVE_PREREAD
	Assert( FFUCBSequential( pfucb ) || FFUCBPrereadForward( pfucb ) );
	pfucb->cbSequentialDataRead += pfucb->kdfCurr.data.Cb();
#endif	//	PREDICTIVE_PREREAD

	return wrn != JET_errSuccess ? wrn : err;

HandleError:
	Assert( err < 0 );
	BTUp( pfucb );
	if ( JET_errRecordNotFound == err )
		{
		err = ErrERRCheck( JET_errNoCurrentRecord );
		}
	Assert( !Pcsr( pfucb )->FLatched() );
	return err;
	}


//	moves cursor to node before current bookmark
//	
ERR ErrDIRPrev( FUCB *pfucb, DIRFLAG dirflag )
	{
	ERR		err;
	ERR		wrn = JET_errSuccess;

	CheckFUCB( pfucb->ppib, pfucb );
	Assert( !FFUCBSpace( pfucb ) );

	//  set preread flags if we are navigating sequentially
	if( FFUCBSequential( pfucb ) )
		{
		FUCBSetPrereadBackward( pfucb, cpgPrereadSequential );
		}
#ifdef PREDICTIVE_PREREAD
	else
		{
		if( FFUCBPrereadBackward( pfucb ) )
			{
			if( !FFUCBPreread( pfucb )
				&& FFUCBIndex( pfucb )
				&& pfucb->cbSequentialDataRead >= cbSequentialDataPrereadThreshold
				&& locOnCurBM == pfucb->locLogical )	//	can't call DIRRelease() if locBefore/AfterSeekBM because there may not be a bookmark available
				{
				FUCBSetPrereadBackward( pfucb, cpgPrereadPredictive );
				//  release to save bookmark and nullify csr to force a BTDown
				Call( ErrDIRRelease( pfucb ) );
				BTUp( pfucb );
				}
			}
		else
			{
			FUCBResetPreread( pfucb );
			pfucb->fPrereadBackward = fTrue;
			}
		}
#endif	//	PREDICTIVE_PREREAD

	//	set cursor navigation level for rollback support
	//
	FUCBSetLevelNavigate( pfucb, pfucb->ppib->level );

Refresh:
	//	check currency and refresh if necessary
	//
	Call( ErrDIRIRefresh( pfucb ) );

	//	switch action based on logical cursor location
	//
	switch( pfucb->locLogical )
		{
		case locOnCurBM:
		case locAfterSeekBM:
			break;

		case locOnSeekBM:
			{
			//	re-seek to key and if foundGreater, fall through to MovePrev
			//
			Call( ErrBTPerformOnSeekBM( pfucb, fDIRFavourPrev ) );
			Assert( Pcsr( pfucb )->FLatched() );

			if ( wrnNDFoundLess == err )
				{
				pfucb->locLogical = locOnCurBM;
				return JET_errSuccess;
				}
			else
				{
				Assert( wrnNDFoundGreater == err );
				}
			break;
			}

		case locOnFDPRoot: 
			return( ErrERRCheck( JET_errNoCurrentRecord ) );

		case locBeforeFirst:
			return( ErrERRCheck( JET_errNoCurrentRecord ) );

		case locBeforeSeekBM:
			Assert( Pcsr( pfucb )->FLatched() );

			//	set currency on current
			//
			pfucb->locLogical = locOnCurBM;
			Assert( Pcsr( pfucb )->FLatched( ) );
			
			return err;

		default:
			{
			DIB	dib;
			Assert( locAfterLast == pfucb->locLogical );

			//	move to root.
			//
			DIRGotoRoot( pfucb );
			dib.dirflag = fDIRNull;
			dib.pos		= posLast;
			err = ErrDIRDown( pfucb, &dib );
			if ( err < 0 )
				{
				//	retore currency.
				//
				pfucb->locLogical = locAfterLast;
				Assert( !Pcsr( pfucb )->FLatched() );

				//	polymorph error code.
				//
				if ( err == JET_errRecordNotFound )
					{
					err = ErrERRCheck( JET_errNoCurrentRecord );
					}
				}

			return err;
			}
		}

	Assert( locOnCurBM == pfucb->locLogical ||
			locAfterSeekBM == pfucb->locLogical ||
			locOnSeekBM == pfucb->locLogical && wrnNDFoundGreater == err );

	err = ErrBTPrev( pfucb, dirflag );

	if ( err < 0 )
		{
		if ( JET_errNoCurrentRecord == err )
			{
			//	moved past first node
			//
			pfucb->locLogical = locBeforeFirst;
			}
		else if ( JET_errRecordDeleted == err )
			{
			//	node was deleted from under the cursor
			//	reseek to logical bm and move to next node
			//
			BTSetupOnSeekBM( pfucb );
			goto Refresh;
			}

		goto HandleError;
		}

	pfucb->locLogical = locOnCurBM;
	wrn = err;
	
	//	check index range
	//
	if ( FFUCBLimstat( pfucb ) && 
		 !FFUCBUpper( pfucb ) && 
		 JET_errSuccess == err )
		{
		Call( ErrDIRICheckIndexRange( pfucb, pfucb->kdfCurr.key ) );
		}

#ifdef PREDICTIVE_PREREAD
	Assert( FFUCBSequential( pfucb ) || FFUCBPrereadBackward( pfucb ) );
	pfucb->cbSequentialDataRead += pfucb->kdfCurr.data.Cb();
#endif	//	PREDICTIVE_PREREAD

	return wrn != JET_errSuccess ? wrn : err;

HandleError:
	Assert( err < 0 );
	BTUp( pfucb );
	if ( JET_errRecordNotFound == err )
		{
		err = ErrERRCheck( JET_errNoCurrentRecord );
		}
	Assert( !Pcsr( pfucb )->FLatched() );
	return err;
	}


//	************************************************
//	INDEX RANGE OPERATIONS
//
//	could become part of BT
//
ERR ErrDIRCheckIndexRange( FUCB *pfucb )
	{
	ERR		err;

	CheckFUCB( pfucb->ppib, pfucb );
	Assert( !FFUCBSpace( pfucb ) );

	//	check currency and refresh if necessary
	//
	CallR( ErrDIRIRefresh( pfucb ) );
	
	//	get key of node for check index range
	//  we don't need to latch the page, we just need the logical bookmark
	//  if we were locDeferMoveFirst the ErrDIRIRefresh above should have
	//  straightened us out
	//
	if( locOnCurBM == pfucb->locLogical
		|| locOnSeekBM == pfucb->locLogical )
		{
		Call( ErrDIRICheckIndexRange( pfucb, pfucb->bmCurr.key ) );
		}
	else
		{
		//  UNDONE: deal with locBeforeSeekBM, locAfterSeekBM, locBeforeFirst etc.
		Call( ErrERRCheck( JET_errNoCurrentRecord ) );
		}
	
HandleError:
	Assert( !Pcsr( pfucb )->FLatched() );
	return err;
	}



//	************************************************
//	UPDATE OPERATIONS
//

//	insert key-data-flags into tree
//	cursor should be at FDP root
//		and have no physical currency
//
ERR ErrDIRInsert( FUCB 			*pfucb, 
				  const KEY& 	key, 
				  const DATA& 	data, 
				  DIRFLAG		dirflag,
				  RCE			*prcePrimary )
	{
	ERR		err;

	ASSERT_VALID( &key );
	ASSERT_VALID( &data );
	CheckFUCB( pfucb->ppib, pfucb );
	Assert( !FFUCBSpace( pfucb ) );

	//	set cursor navigation level for rollback support
	//
	FUCBSetLevelNavigate( pfucb, pfucb->ppib->level );

	Assert( !Pcsr( pfucb )->FLatched() );

	Call( ErrBTInsert( pfucb, key, data, dirflag, prcePrimary ) );

	if ( dirflag & fDIRBackToFather )
		{
		//	no need to save bookmark
		//
		DIRUp( pfucb );
		Assert( locOnFDPRoot == pfucb->locLogical );
		}
	else
		{
		//	save bookmark
		//
		Call( ErrBTRelease( pfucb ) );
		pfucb->locLogical = locOnCurBM;
		}

HandleError:
	Assert( !Pcsr( pfucb )->FLatched() );
	return err;
	}


//	the following three calls provide an API for inserting secondary keys
//	at Index creation time
//	DIRAppend is used instead of DIRInit for performance reasons
//
ERR ErrDIRInitAppend( FUCB *pfucb )
	{
	Assert( !FFUCBSpace( pfucb ) );

	//	set cursor navigation level for rollback support
	//
	FUCBSetLevelNavigate( pfucb, pfucb->ppib->level );

	return JET_errSuccess;
	}


//	appends key-data at the end of page
//	leaves page latched
//
ERR ErrDIRAppend( FUCB 			*pfucb, 
				  const KEY& 	key,
				  const DATA& 	data, 
				  DIRFLAG		dirflag )
	{
	ERR		err;

	ASSERT_VALID( &key );
	ASSERT_VALID( &data );
	Assert( !FFUCBSpace( pfucb ) );
	Assert( !data.FNull() );
	Assert( !key.FNull() || FFUCBRepair( pfucb ) );
	Assert( LevelFUCBNavigate( pfucb ) == pfucb->ppib->level );
	
	if ( locOnFDPRoot == pfucb->locLogical )
		{
		CallR( ErrBTInsert( pfucb, key, data, dirflag ) );
		Assert( Pcsr( pfucb )->FLatched() );
		pfucb->locLogical = locOnCurBM;
		return err;
		}

	Assert( Pcsr( pfucb )->FLatched() );
	Assert( locOnCurBM == pfucb->locLogical );
	AssertDIRGet( pfucb );
	
	//	if key-data same as current node, must be
	//	trying to insert duplicate keys into a
	//	multi-valued index.
	if ( FKeysEqual( pfucb->kdfCurr.key, key )
		&& FDataEqual( pfucb->kdfCurr.data, data ) )
		{
		Assert( FFUCBSecondary( pfucb ) );
		Assert( pfcbNil != pfucb->u.pfcb );
		Assert( rgfmp[ pfucb->u.pfcb->Ifmp() ].Dbid() != dbidTemp );
		Assert( pfucb->u.pfcb->FTypeSecondaryIndex() );
		Assert( pfucb->u.pfcb->Pidb() != pidbNil );
		Assert( !pfucb->u.pfcb->Pidb()->FPrimary() );
		Assert( !pfucb->u.pfcb->Pidb()->FUnique() );
		Assert( pfucb->u.pfcb->Pidb()->FMultivalued() );
		//	must have been record with multi-value column
		//	with sufficiently similar values (ie. the
		//	indexed portion of the multi-values were
		//	identical) to produce redundant index
		//	entries -- this is okay, we simply have
		//	one index key pointing to multiple multi-values
		err = JET_errSuccess;
		return err;
		}

	Assert( FFUCBRepair( pfucb ) && key.FNull()
			|| CmpKey( pfucb->kdfCurr.key, key ) < 0
			|| CmpData( pfucb->kdfCurr.data, data ) < 0 );

	Call( ErrBTAppend( pfucb, key, data, dirflag ) );
	
	//	set logical currency on inserted node.
	//
	pfucb->locLogical = locOnCurBM;
	Assert( Pcsr( pfucb )->FLatched() );
	return err;

HandleError:
	Assert( !Pcsr( pfucb )->FLatched() );
	return err;
	}


ERR ErrDIRTermAppend( FUCB *pfucb )
	{
	ERR		err = JET_errSuccess;

	DIRUp( pfucb );
	return err;
	}
	

//	flag delete node
//	release latch
//
ERR ErrDIRDelete( FUCB *pfucb, DIRFLAG dirflag, RCE *prcePrimary )
	{
	ERR		err;

	Assert( !FFUCBSpace( pfucb ) );
	CheckFUCB( pfucb->ppib, pfucb );

	//	refresh logical currency
	//
	Call( ErrDIRIRefresh( pfucb ) );

	if ( locOnCurBM == pfucb->locLogical )
		{
		err = ErrBTFlagDelete( pfucb, dirflag, prcePrimary );
///		if( err >= JET_errSuccess )
///			{
///			pfucb->locLogical = locOnSeekBM;
///			}
		}
	else
		{
		Assert( !Pcsr( pfucb )->FLatched() );
		err = ErrERRCheck( JET_errNoCurrentRecord );
		return err;
		}

HandleError:
	CallS( ErrBTRelease( pfucb ) );
	Assert( !Pcsr( pfucb )->FLatched() );
	return err;
	}


//	replaces data portion of current node
//	releases latch after recording bm of node in pfucb
//
ERR ErrDIRReplace( FUCB *pfucb, const DATA& data, DIRFLAG dirflag )
	{
	ERR		err;

	ASSERT_VALID( &data );
	Assert( !FFUCBSpace( pfucb ) );
	CheckFUCB( pfucb->ppib, pfucb );

	//	check currency and refresh if necessary.
	//
	Call( ErrDIRIRefresh( pfucb ) );

	if ( locOnCurBM != pfucb->locLogical )
		{
		Assert( !Pcsr( pfucb )->FLatched( ) );
		err = ErrERRCheck( JET_errNoCurrentRecord );
		return err;
		}

	Call( ErrBTReplace( pfucb, data, dirflag ) );
	Assert( locOnCurBM == pfucb->locLogical );

HandleError:
	CallS( ErrBTRelease( pfucb ) );
	Assert( !Pcsr( pfucb )->FLatched( ) );
	return err;
	}


//	lock record	by calling BTLockRecord 
//
ERR ErrDIRGetLock( FUCB *pfucb, DIRLOCK dirlock )
	{
	ERR     err = JET_errSuccess;

	Assert( !FFUCBSpace( pfucb ) );
	Assert( pfucb->ppib->level > 0 );
	Assert( !Pcsr( pfucb )->FLatched() );

	//	check currency and refresh if necessary.
	//
	Call( ErrDIRIRefresh( pfucb ) );

	//	check cursor location
	//
	switch ( pfucb->locLogical )
		{
		case locOnCurBM:
			break;
			
		case locOnFDPRoot:
		case locDeferMoveFirst:
			Assert( fFalse );
			
		default:
			Assert( pfucb->locLogical == locBeforeSeekBM ||
					pfucb->locLogical == locAfterSeekBM ||
					pfucb->locLogical == locAfterLast ||
					pfucb->locLogical == locBeforeFirst ||
					pfucb->locLogical == locOnSeekBM );
			return( ErrERRCheck( JET_errNoCurrentRecord ) );
		}

	Call( ErrBTLock( pfucb, dirlock ) );
	CallS( err );
	
	return err;
	
HandleError:
	Assert( !Pcsr( pfucb )->FLatched() );
	return err;
	}


//	called by Lv.c
//	calls ErrBTDelta
//
ERR ErrDIRDelta( 
		FUCB		*pfucb,
		INT			cbOffset,
		const VOID	*pv,
		ULONG		cbMax,
		VOID		*pvOld,
		ULONG		cbMaxOld,
		ULONG		*pcbOldActual,
		DIRFLAG		dirflag )
	{
	ERR		err;

	Assert( !FFUCBSpace( pfucb ) );
	CheckFUCB( pfucb->ppib, pfucb );
	
	//	check currency and refresh if necessary.
	//
	Call( ErrDIRIRefresh( pfucb ) );
	Assert( locOnCurBM == pfucb->locLogical );

	Call( ErrBTDelta( pfucb, cbOffset, pv, cbMax, pvOld, cbMaxOld, pcbOldActual, dirflag ) );
	
HandleError:
	CallS( ErrBTRelease( pfucb ) );
	Assert( !Pcsr( pfucb )->FLatched() );
	return err;
	}


//	****************************************************************
//	STATISTICAL ROUTINES
//

//	counts nodes from current to limit or end of table
//
ERR ErrDIRIndexRecordCount( FUCB *pfucb, ULONG *pulCount, ULONG ulCountMost, BOOL fNext )
	{
	ERR		err;
	CPG		cpgPreread;
	BOOKMARK bm;
	BYTE	*pb = NULL;

	CheckFUCB( pfucb->ppib, pfucb );
	Assert( !Pcsr( pfucb )->FLatched() );

	//  there is no record count limit or the record count limit is larger than
	//  the maximum fanout of the maximum preread

	if ( !ulCountMost || ulCountMost > ULONG( cpgPrereadSequential * cpgPrereadSequential ) )
		{
		//  turn on maximum preread

		cpgPreread = cpgPrereadSequential;
		}

	//  we have a small record count limit

	else
		{
		//  preread two pages so that we can use the first page to estimate
		//  the true number of pages to preread and use the second page to
		//  trigger the preread without taking another cache miss

		cpgPreread = 2;
		}

	//  turn on preread

	if ( fNext )
		{
		FUCBSetPrereadForward( pfucb, cpgPreread );
		}
	else
		{
		FUCBSetPrereadBackward( pfucb, cpgPreread );
		}

	//	refresh logical currency
	//
	Call( ErrDIRIRefresh( pfucb ) );

	//	return error if not on a record
	//
	if ( locOnCurBM != pfucb->locLogical )
		{
		Call( ErrERRCheck( JET_errNoCurrentRecord ) );
		}

	Assert( pfucb->bmCurr.key.Cb() + pfucb->bmCurr.data.Cb() > 0 );
	pb = new BYTE[ pfucb->bmCurr.key.Cb() + pfucb->bmCurr.data.Cb() ];
	if ( pb == NULL )
		{
		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}
	bm.Nullify();
	if ( pfucb->bmCurr.key.Cb() > 0 )
		{
		bm.key.suffix.SetPv( pb );
		pfucb->bmCurr.key.CopyIntoBuffer( pb );
		bm.key.suffix.SetCb( pfucb->bmCurr.key.Cb() );
		}
	if ( pfucb->bmCurr.data.Cb() > 0 )
		{
		bm.data.SetPv( pb + bm.key.Cb() );
		pfucb->bmCurr.data.CopyInto( bm.data );
		}

	Call( ErrBTGet( pfucb ) );

	//  if we have a small record count limit, use the current page to make an
	//  estimate at how much we should preread and set our preread limit to that
	//  amount
	//
	//  CONSIDER:  sample and account for percentage of visible nodes

	if ( cpgPreread == 2 )
		{
		cpgPreread = min(	CPG(	(	( ulCountMost + Pcsr( pfucb )->ILine() ) /
										max( Pcsr( pfucb )->Cpage().Clines(), 1 ) ) -
									cpgPreread ),
							cpgPrereadSequential );

		if ( fNext )
			{
			FUCBSetPrereadForward( pfucb, cpgPreread );
			}
		else
			{
			FUCBSetPrereadBackward( pfucb, cpgPreread );
			}
		}

	//	intialize count variable
	//
	*pulCount = 0;

	//	count nodes from current to limit or end of table
	//
	forever
		{
		if ( ulCountMost && ++(*pulCount) == ulCountMost )
			{
			BTUp( pfucb );
			break;
			}

		if ( fNext )
			{
			err = ErrBTNext( pfucb, fDIRNull );
			}
		else
			{
			err = ErrBTPrev( pfucb, fDIRNull );
			}
			
		if ( err < 0 )
			{
			BTUp( pfucb );
			break;
			}

		//	check index range
		//
		if ( FFUCBLimstat( pfucb ) )
			{
			err = ErrDIRICheckIndexRange( pfucb, pfucb->kdfCurr.key );
			if ( err < 0 )
				{
				Assert( !Pcsr( pfucb )->FLatched() );
				break;
				}
			}
		}
		
	//	common exit loop processing
	//
	if ( err >= 0 || err == JET_errNoCurrentRecord )
		{
		err = JET_errSuccess;
		}
	
HandleError:
	if ( pb != NULL )
		{
		if ( err == JET_errSuccess )
			{
			FUCBResetLimstat( pfucb );
			err = ErrDIRGotoBookmark( pfucb, bm );
			}
		else
			{
			// Keep the existing err code, even if hit the error. At least we did our best
			(VOID)ErrDIRGotoBookmark( pfucb, bm );
			}
		bm.Nullify();	
		delete[] pb;
		pb = NULL;
		}
	Assert( pb == NULL );
	Assert( !Pcsr( pfucb )->FLatched() );
	FUCBResetPreread( pfucb );
	return err;
	}


//	computes statistics on directory by calling BT level function
//
ERR ErrDIRComputeStats( FUCB *pfucb, INT *pcnode, INT *pckey, INT *pcpage )
	{
	ERR		err;

	CheckFUCB( pfucb->ppib, pfucb );
	Assert( !FFUCBLimstat( pfucb ) );
	Assert( locOnFDPRoot == pfucb->locLogical );
	
	CallR( ErrBTComputeStats( pfucb, pcnode, pckey, pcpage ) );
	return err;
	}


//	********************************************************
//	************** DIR Transaction Routines ******************
//

LOCAL VOID DIRIReportSessionSharingViolation( PIB *ppib )
	{
	CHAR szSession[32];
	CHAR szSesContext[32]; 
	CHAR szSesContextThreadID[32];
	CHAR szThreadID[32];

	_stprintf( szSession, _T( "0x%p" ), ppib );
	if ( ppib->FUseSessionContextForTrxContext() )
		{
		_stprintf( szSesContext, _T( "0x%0*I64X" ), sizeof(DWORD_PTR)*2, QWORD( ppib->dwSessionContext ) );
		_stprintf( szSesContextThreadID, _T( "0x%0*I64X" ), sizeof(DWORD_PTR)*2, QWORD( ppib->dwSessionContextThreadId ) );
		}
	else
		{
		_stprintf( szSesContext, _T( "0x%08X" ), 0 );
		_stprintf( szSesContextThreadID, _T( "0x%0*I64X" ), sizeof(DWORD_PTR)*2, QWORD( ppib->dwTrxContext ) );
		}
	_stprintf( szThreadID, _T( "0x%0*I64X" ), sizeof(DWORD_PTR)*2, QWORD( DwUtilThreadId() ) );

	const CHAR *rgszT[4] = { szSession, szSesContext, szSesContextThreadID, szThreadID };
	UtilReportEvent( eventError, TRANSACTION_MANAGER_CATEGORY, SESSION_SHARING_VIOLATION_ID, 4, rgszT );
	}

//	begins a transaction
//	gets transaction id
//	logs trqansaction
//	records lgpos of begin in ppib [VERBeginTransaction]
//
ERR ErrDIRBeginTransaction( PIB *ppib, const JET_GRBIT grbit )
	{
	ERR			err			= JET_errSuccess;
	BOOL		fInCritTrx	= fFalse;
	INST		* pinst		= PinstFromPpib( ppib );

	//	The critical section ensure that the deferred begin trx level
	//	issued by indexer for a updater will not be changed till the indexer
	//	finish changing for the updater's RCEs that need be updated by indexer.

	//	log begin transaction. 
	//	Must be called first so that lgpos and trx used in ver are consistent. 
	//
	if ( ppib->level == 0 )
		{
		//	UNDONE: if we can guarantee that our clients are well-behaved, we don't
		//	need this check
		PIBSetTrxContext( ppib );

		Assert( prceNil == ppib->prceNewest );
		if ( grbit & JET_bitTransactionReadOnly )
			ppib->SetFReadOnlyTrx();
		else
			ppib->ResetFReadOnlyTrx();
		pinst->m_blBegin0Commit0.Enter1();		
		PIBSetTrxBegin0( ppib );
		pinst->m_blBegin0Commit0.Leave1();
		}
	else if( prceNil != ppib->prceNewest )
		{
		ppib->critTrx.Enter();
		Assert( !( ppib->FReadOnlyTrx() ) );
		fInCritTrx = fTrue;
		}
	else 
		{
		Assert( FPIBCheckTrxContext( ppib ) );
		}

	//	UNDONE: if we can guarantee that our clients are well-behaved, we don't
	//	need this check
	if ( ppib->level != 0 && !FPIBCheckTrxContext( ppib ) )
		{
		DIRIReportSessionSharingViolation( ppib );
		FireWall();
		Call( ErrERRCheck( JET_errSessionSharingViolation ) );
		}
	else
		{
#ifdef DTC
		if ( grbit & JET_bitDistributedTransaction )
			{
			if ( 0 == ppib->level )
				{
				if ( NULL != pinst->m_pfnRuntimeCallback )
					{
					ppib->SetFDistributedTrx();
					}
				else
					{
					Call( ErrERRCheck( JET_errDTCMissingCallback ) );
					}
				}
			else
				{
				Call( ErrERRCheck( JET_errCannotNestDistributedTransactions ) );
				}
			}
#else
		//	should have been filtered out at ISAM level
		Assert( !( grbit & JET_bitDistributedTransaction ) );
#endif	//	DTC

		CallS( ErrLGBeginTransaction( ppib ) );
		VERBeginTransaction( ppib );
		}

HandleError:
	if ( fInCritTrx )
		{
		Assert( prceNil != ppib->prceNewest );
		Assert( !( ppib->FReadOnlyTrx() ) );
		ppib->critTrx.Leave();
		}

	return err;
	}


#ifdef DTC
ERR ErrDIRPrepareToCommitTransaction(
	PIB			* const ppib,
	const VOID	* const pvData,
	const ULONG	cbData )
	{
	ERR			err;

	CheckPIB( ppib );
	Assert( 1 == ppib->level );		//	distributed transactions are not nestable

	//	UNDONE: if we can guarantee that our clients are well-behaved, we don't
	//	need this check
	if ( !FPIBCheckTrxContext( ppib ) )
		{
		DIRIReportSessionSharingViolation( ppib );
		FireWall();
		Call( ErrERRCheck( JET_errSessionSharingViolation ) );
		}

	Call( ErrLGPrepareToCommitTransaction( ppib, pvData, cbData ) );

	ppib->SetFPreparedToCommitTrx();

HandleError:
	return err;
	}
#endif	//	DTC


//	commits transaction
//
ERR ErrDIRCommitTransaction( PIB *ppib, JET_GRBIT grbit )
	{
	ERR		err = JET_errSuccess;
	FUCB	*pfucb;

	const BOOL	fCommit0		= ( 1 == ppib->level );
	const BOOL	fRWTrx			= ppib->FBegin0Logged();
	const BOOL	fSessionHasRCE	= ( prceNil != ppib->prceNewest );
	const BOOL  fModeCommit0	= ( fCommit0 && fSessionHasRCE );

	CheckPIB( ppib );
	Assert( ppib->level > 0 );

	INST * const pinst = PinstFromPpib( ppib );
	LOG  * const plog = pinst->m_plog;
	
	//	UNDONE: if we can guarantee that our clients are well-behaved, we don't
	//	need this check
	if ( !FPIBCheckTrxContext( ppib ) )
		{
		DIRIReportSessionSharingViolation( ppib );
		FireWall();
		return ErrERRCheck( JET_errSessionSharingViolation );
		}

	// This critical section ensures that we don't commit RCE's from
	// underneath CreateIndex.
	if( fSessionHasRCE )
		{
		ppib->critTrx.Enter();
		}

	//  perf stats

	if ( fCommit0 )
		{
		if ( ppib->FDistributedTrx() && !ppib->FPreparedToCommitTrx() )
			{
			Call( ErrERRCheck( JET_errDistributedTransactionNotYetPreparedToCommit ) );
			}
		if ( fRWTrx )
			{
			ppib->FUserSession() ? cDIRUserRWTrxCommit0.Inc( pinst ) : cDIRSystemRWTrxCommit0.Inc( pinst );
			}
		else
			{
			ppib->FUserSession() ? cDIRUserROTrxCommit0.Inc( pinst ) : cDIRSystemROTrxCommit0.Inc( pinst );
			}

		//  get a snapshot of our approximate trxCommi0. This doesn't have to be exact
		ppib->trxCommit0 = ( pinst->m_trxNewest + 2 );
		}

	LGPOS	lgposCommitRec;
	Call( ErrLGCommitTransaction( ppib, LEVEL( ppib->level - 1 ), &lgposCommitRec ) );

	if ( fCommit0 )
		{
		ppib->lgposCommit0 = lgposCommitRec;

		//	for distributed transactions, the PrepareToCommit is always force-flushed,
		//	so never any need to force-flush the Commit0
		if( fRWTrx && !ppib->FDistributedTrx() )
			{
			const JET_GRBIT grbitT = grbit | ppib->grbitsCommitDefault;

			//  UNDONE:  if we are a read-only transaction we don't need to 
			//  call ErrLGWaitCommit0Flush, which enters critLGBuf
			if ( !( grbitT & JET_bitCommitLazyFlush ) )
				{
				//	remember the minimum requirement to flush. It is ok to use the beginning
				//	of commit log record lgposLogRec we flush up to
				//	the end of all flushable log records and the whole log record will be
				//	flushed.
				err = plog->ErrLGWaitCommit0Flush( ppib );
				Assert( err >= 0  ||
						( plog->m_fLGNoMoreLogWrite  &&  
						  err == JET_errLogWriteFail ) );

				//  CONSIDER:  if ErrLGWaitCommit0Flush fails, are we sure our commit record wasn't logged?
				Call( err );
				}
			}

		if( fModeCommit0 )
			{
			pinst->m_blBegin0Commit0.Enter2();	//  so no-one else can see partially completed transactions
			ppib->trxCommit0 = TRX( AtomicExchangeAdd( (LONG *)&pinst->m_trxNewest, 2 ) ) + 2;
			Assert( !( ppib->trxCommit0 & 1 ) );
			}
		}
		
	VERCommitTransaction( ppib );

	if ( fModeCommit0 )
		{
		//	if committing to level 0, ppib should have no more
		//	outstanding versions
		Assert( 0 == ppib->level );
		Assert( prceNil == ppib->prceNewest );
		pinst->m_blBegin0Commit0.Leave2();
		}
	
	//	set all open cursor transaction levels to new level
	//
	FUCB	*pfucbNext;
	for ( pfucb = ppib->pfucbOfSession; pfucb != pfucbNil; pfucb = pfucbNext )
		{
		pfucbNext = pfucb->pfucbNextOfSession;
		
		if ( pfucb->levelOpen > ppib->level )
			{
			pfucb->levelOpen = ppib->level;
			}

		if ( FFUCBUpdatePrepared( pfucb ) )
			{
			// If update was prepared during this transaction, migrate the
			// update to the next lower level.
			Assert( pfucb->levelPrep <= ppib->level + 1 );
			if ( ppib->level + 1 == pfucb->levelPrep )
				{
				pfucb->levelPrep = ppib->level;
				}

			//	LV updates no longer allowed at level 0.  This assert detects
			//	any of the following illegal client actions:
			//		--	calling PrepareUpdate() at level 1, doing some
			//			LV operations, then calling CommitTransaction()
			//			before calling Update(), effectively causing the
			//			update to migrate to level 0.
			// 		--	called Update(), but the Update() failed
			//			(eg. errWriteConflict) and the client continued
			//			to commit the transaction anyway with the update
			//			still pending
			//		--	beginning a transaction at level 0 AFTER calling
			//			PrepareUpdate(), then committing the transaction
			//			BEFORE calling Update().
			AssertSz(
				ppib->level > 0 || !FFUCBInsertReadOnlyCopyPrepared( pfucb ),
				"Illegal attempt to migrate read-only copy to level 0." );			
			AssertSz(
				ppib->level > 0 || !FFUCBUpdateSeparateLV( pfucb ),
				"Illegal attempt to migrate outstanding LV update(s) to level 0." );
			AssertSz(
				ppib->level > 0 || !rgfmp[pfucb->ifmp].FSLVAttached() || !pfucb->u.pfcb->Ptdb()->FTableHasSLVColumn(),
				"Illegal attempt to migrate update(s) to level 0 with SLV column present." );
			}

		//	set cursor navigation level for rollback support
		//
		Assert( PinstFromIfmp( pfucb->ifmp )->m_plog->m_fRecovering || LevelFUCBNavigate( pfucb ) <= ppib->level + 1 );
		if ( LevelFUCBNavigate( pfucb ) > ppib->level )
			{
			FUCBSetLevelNavigate( pfucb, ppib->level );
			}

		if ( fCommit0 )
			{
			//	if committing to level 0, ppib should have no more
			//	outstanding versions
			Assert( 0 == ppib->level );
			Assert( prceNil == ppib->prceNewest );
			FUCBResetVersioned( pfucb );
			
			if ( FFUCBDeferClosed( pfucb ) )
				FUCBCloseDeferredClosed( pfucb );
			}
		else
			{
			Assert( ppib->level > 0 );
			}
		}
		
	if ( fCommit0 )
		{
		PIBResetTrxBegin0( ppib );
		if ( !ppib->FUseSessionContextForTrxContext() )
			{
			PIBResetTrxContext( ppib );
			}
		}

HandleError:
	if( fSessionHasRCE )
		{
		ppib->critTrx.Leave();
		}

#ifdef DEBUG
	if ( fCommit0 )
		{
		Assert( err < 0 || 0 == ppib->level );
		}
	else
		{
		Assert( ppib->level > 0 );
		}
#endif		

	return err;
	}


//	rolls back a transaction
//
ERR ErrDIRRollback( PIB *ppib )
	{
	ERR   		err = JET_errSuccess;
	FUCB		*pfucb;
	const BOOL	fRollbackToLevel0	= ( 1 == ppib->level );

	CheckPIB( ppib );
	Assert( ppib->level > 0 );
	INST		*pinst = PinstFromPpib( ppib );

	//	UNDONE: if we can guarantee that our clients are well-behaved, we don't
	//	need this check
	if ( !FPIBCheckTrxContext( ppib ) )
		{
		DIRIReportSessionSharingViolation( ppib );
		FireWall();
		return ErrERRCheck( JET_errSessionSharingViolation );
		}

	if ( JET_errSuccess != ppib->ErrRollbackFailure() )
		{
		//	previous rollback error encountered, no further rollbacks permitted
		return ErrERRCheck( JET_errRollbackError );
		}

	//  perf stats

	if ( fRollbackToLevel0 )
		{
		if ( ppib->FBegin0Logged() )
			{
			ppib->FUserSession() ? cDIRUserRWTrxRollback0.Inc( pinst ) : cDIRSystemRWTrxRollback0.Inc( pinst );
			}
		else
			{
			ppib->FUserSession() ? cDIRUserROTrxRollback0.Inc( pinst ) : cDIRSystemROTrxRollback0.Inc( pinst );
			}
		}
	
	for ( pfucb = ppib->pfucbOfSession; pfucb != pfucbNil; pfucb = pfucb->pfucbNextOfSession )
		{
		Assert( pinst->FRecovering() || LevelFUCBNavigate( pfucb ) <= ppib->level );
		if ( LevelFUCBNavigate( pfucb ) == ppib->level )
			{
			FUCBSetLevelNavigate( pfucb, LEVEL( ppib->level - 1 ) );
			DIRBeforeFirst( pfucb );

			Assert( !FFUCBUpdatePrepared( pfucb ) ||
					pfucb->levelPrep == ppib->level );
			}

		//	reset copy buffer if prepared at transaction level
		//	which is being rolled back.
		//
		Assert( !FFUCBUpdatePrepared( pfucb ) ||
			pfucb->levelPrep <= ppib->level );
		if ( FFUCBUpdatePreparedLevel( pfucb, ppib->level ) )
			{
			//	reset update separate LV and copy buffer status
			//	all long value resources will be freed as a result of
			//	rollback and copy buffer status is reset
			//
			//	UNDONE: all updates should have already been cancelled
			//	in ErrIsamRollback(), but better to be safe than sorry,
			//	so just leave this code here
			RECIFreeCopyBuffer( pfucb );
			FUCBResetUpdateFlags( pfucb );
			}
		}

	//	UNDONE:	rollback may fail from resource failure so
	//			we must retry in order to assure success

	//	rollback changes made in transaction
	//
	err = ErrVERRollback( ppib );
	CallSx( err, JET_errRollbackError );
	CallR ( err );

	//	log rollback. Must be called after VERRollback to record
	//  the UNDO operations.  Do not handle error.
	//
	// during a force detach we don;t log the rollback as we haven't log
	// the undo operations
	if ( ppib->m_ifmpForceDetach == ifmpMax )
		{
		err = ErrLGRollback( ppib, 1 );
		if ( err == JET_errLogWriteFail || err == JET_errDiskFull )
			{
			//	these error codes will lead to crash recovery which will
			//	rollback transaction.
			//
			err = JET_errSuccess;
			}
		CallS( err );
		}

#ifdef DEBUG
	if ( fRollbackToLevel0 )
		{
		Assert( 0 == ppib->level );
		
		//	if rolling back to level 0, ppib should have no more
		//	outstanding versions
		Assert( prceNil == ppib->prceNewest );
		}
	else
		{
		Assert( ppib->level > 0 );
		}
#endif

	//	if recovering then we are done. No need to close fucb since they are faked and
	//	not the same behavior as regular fucb which could be deferred.
	//
	if ( !pinst->FRecovering() )
		{
		//	if rollback to level 0 then close deferred closed cursors
		//	if cursor was opened at this level, close it
		//
		ENTERCRITICALSECTION	enterCritTrx( &ppib->critTrx );
		for ( pfucb = ppib->pfucbOfSession; pfucb != pfucbNil; )
			{
			FUCB    	*pfucbT = pfucb->pfucbNextOfSession;
			const BOOL	fOpenedInThisTransaction = ( pfucb->levelOpen > ppib->level );

			if ( fRollbackToLevel0 )
				{
				//	if rolling back to level 0, ppib should have no more
				//	outstanding versions
				Assert( 0 == ppib->level );
				Assert( prceNil == ppib->prceNewest );
				FUCBResetVersioned( pfucb );
				}
			else
				{
				Assert( ppib->level > 0 );
				}
			
			if ( fOpenedInThisTransaction || FFUCBDeferClosed( pfucb ) )
				{
				// A bookmark may still be outstanding if:
				//   1) Cursor opened in this transaction was
				//      not closed before rolling back.
				//   2) Bookmark was allocated by ErrVERIUndoLoggedOper()
				//		on a deferred-closed cursor.
				BTReleaseBM( pfucb );

				if ( fOpenedInThisTransaction || fRollbackToLevel0 )
					{
					// Force-close cursor if it was open at this level (or higher).
					// or if we're dropping to level 0 and there are still deferred-
					// closed cursors.
					FUCBCloseDeferredClosed( pfucb );
					}
				}

			pfucb = pfucbT;
			}
		}

	if ( fRollbackToLevel0 )
		{
		if ( pinst->FRecovering() )
			{
			for ( pfucb = ppib->pfucbOfSession; pfucb != pfucbNil; pfucb = pfucb->pfucbNextOfSession )
				{
				FUCBResetVersioned( pfucb );
				}
			}

		PIBResetTrxBegin0( ppib );
		if ( !ppib->FUseSessionContextForTrxContext() )
			{
			PIBResetTrxContext( ppib );
			}
		}

	return err;
	}


//	**********************************************************
//	******************* DIR Internal *************************
//	**********************************************************
//
//	*******************************************
//	DIR internal routines
//

//	checks index range 
//	and sets currency if cursor is beyond boundaries
//	
LOCAL ERR ErrDIRICheckIndexRange( FUCB *pfucb, const KEY& key )
	{
	ERR		err;
	
	err = ErrFUCBCheckIndexRange( pfucb, key );

	Assert( err >= 0 || err == JET_errNoCurrentRecord );
	if ( err == JET_errNoCurrentRecord )
		{
		if( Pcsr( pfucb )->FLatched() )
			{
			//  if we are called from ErrDIRCheckIndexRange the page may not be latched
			//  (we use the logical bookmark instead)
			DIRUp( pfucb );
			}
		
		if ( FFUCBUpper( pfucb ) )
			{
			DIRAfterLast( pfucb );
			}
		else
			{
			DIRBeforeFirst( pfucb );
			}
		}

	return err;
	}


//	cursor is refreshed
//	if cursor status is DeferMoveFirst,
//		go to first node in the CurrentIdx
//	refresh for other cases is handled at BT-level
//
LOCAL ERR ErrDIRIIRefresh( FUCB * const pfucb )
	{
	ERR		err;
	DIB		dib;
	FUCB 	* pfucbIdx;

 	Assert( locDeferMoveFirst == pfucb->locLogical );
	Assert( !Pcsr( pfucb )->FLatched() );

	if ( pfucb->pfucbCurIndex )
		{
		pfucbIdx = pfucb->pfucbCurIndex;
		}
	else
		{
		pfucbIdx = pfucb;
		}

	//	go to root of index
	//
	DIRGotoRoot( pfucbIdx );

	//	move to first child
	//
	dib.dirflag = fDIRNull;
	dib.pos		= posFirst;
	err = ErrBTDown( pfucbIdx, &dib, latchReadNoTouch );
	if ( err < 0 )
		{
		Assert( err != JET_errNoCurrentRecord );
		if ( JET_errRecordNotFound == err )
			{
			err = ErrERRCheck( JET_errNoCurrentRecord );
			}

		Assert( !Pcsr( pfucb )->FLatched() );
		pfucb->locLogical = locDeferMoveFirst;
			
		goto HandleError;
		}

	Assert( JET_errSuccess == err || 
			wrnBFPageFault == err ||
			wrnBFPageFlushPending == err );

	pfucbIdx->locLogical = locOnCurBM;

	if ( pfucbNil != pfucb->pfucbCurIndex )
		{
		//	go to primary key on primary index
		//
		BOOKMARK	bm;

		bm.data.Nullify();
		bm.key.prefix.Nullify();
		bm.key.suffix = pfucbIdx->kdfCurr.data;

		Call( ErrDIRGotoBookmark( pfucb, bm ) );
		}

	Call( ErrBTRelease( pfucbIdx ) );
	CallS( err );

HandleError:
	Assert( !Pcsr( pfucb )->FLatched() );
	Assert( JET_errRecordDeleted != err );
	Assert( JET_errRecordNotFound != err );
	return err;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ese98\src\ese\dbtask.cxx ===
#include "std.hxx"

//  ****************************************************************
//	TASK
//  ****************************************************************

TASK::TASK()
	{
	}

TASK::~TASK()
	{
	}

DWORD TASK::DispatchGP( void *pvThis )
	{
	TASK * const ptask = (TASK *)pvThis;
	PIB *ppibT;
	INST *pinst;
	pinst = ptask->PInstance();
	Assert( pinstNil != pinst );
	if ( JET_errSuccess <= pinst->ErrGetSystemPib( &ppibT ) )
		{
		(VOID)ptask->ErrExecute( ppibT );
		pinst->ReleaseSystemPib( ppibT );
		}

	//  the TASK must have been allocated with "new"
	delete ptask;
	return 0;
	}

VOID TASK::Dispatch( PIB * const ppib, const ULONG_PTR ulThis )
	{
	TASK * const ptask = (TASK *)ulThis;
	(VOID)ptask->ErrExecute( ppib );

	//  the TASK must have been allocated with "new"
	delete ptask;
	}


//  ****************************************************************
//	DBTASK
//  ****************************************************************
		
DBTASK::DBTASK( const IFMP ifmp ) :
	m_ifmp( ifmp )
	{
	FMP * const pfmp = &rgfmp[m_ifmp];

	//	don't fire off async tasks on the temp. database because the
	//	temp. database is simply not equipped to deal with concurrent access
	AssertRTL( dbidTemp != pfmp->Dbid() );

	CallS( pfmp->RegisterTask() );
	}

INST *DBTASK::PInstance()
	{
	return PinstFromIfmp( m_ifmp );
	}

DBTASK::~DBTASK()
	{
	FMP * const pfmp = &rgfmp[m_ifmp];
	CallS( pfmp->UnregisterTask() );
	}


//  ****************************************************************
//	RECTASK
//  ****************************************************************

RECTASK::RECTASK( const PGNO pgnoFDP, FCB * const pfcb, const IFMP ifmp, const BOOKMARK& bm ) :
	DBTASK( ifmp ),
	m_pgnoFDP( pgnoFDP ),
	m_pfcb( pfcb ),
	m_cbBookmarkKey( bm.key.Cb() ),
	m_cbBookmarkData( bm.data.Cb() )
	{
	Assert( !bm.key.FNull() );
	Assert( m_cbBookmarkKey < sizeof( m_rgbBookmarkKey ) );
	Assert( m_cbBookmarkData < sizeof( m_rgbBookmarkData ) );
	bm.key.CopyIntoBuffer( m_rgbBookmarkKey, sizeof( m_rgbBookmarkKey ) );
	memcpy( m_rgbBookmarkData, bm.data.Pv(), m_cbBookmarkData );

	//	if coming from version cleanup, refcount may be zero, so the only thing
	//	currently keeping this FCB pinned is the RCE that spawned this task
	//	if coming from OLD, there must already be a cursor open on this
	Assert( m_pgnoFDP == m_pfcb->PgnoFDP() );
	Assert( prceNil != m_pfcb->PrceOldest() || m_pfcb->WRefCount() > 0 );

	//	pin the FCB by incrementing its refcnt

	Assert( m_pfcb->FNeedLock() );
	m_pfcb->IncrementRefCount();
	m_pfcb->RegisterTask();
	
	Assert( prceNil != m_pfcb->PrceOldest() || m_pfcb->WRefCount() > 1 );
	}

RECTASK::~RECTASK()
	{
	Assert( m_pfcb->PgnoFDP() == m_pgnoFDP );

	//	release the FCB by decrementing its refcnt

	Assert( m_pfcb->WRefCount() > 0 );
	Assert( m_pfcb->FNeedLock() );
	m_pfcb->Release();
	m_pfcb->UnregisterTask();
	}

ERR RECTASK::ErrOpenFUCBAndGotoBookmark( PIB * const ppib, FUCB ** ppfucb )
	{
	ERR err;
	BOOKMARK bookmark;

	bookmark.key.Nullify();
	bookmark.key.suffix.SetPv( m_rgbBookmarkKey );
	bookmark.key.suffix.SetCb( m_cbBookmarkKey );
	bookmark.data.SetPv( m_rgbBookmarkData );
	bookmark.data.SetCb( m_cbBookmarkData );

	Assert( m_pfcb->FInitialized() );
	Assert( m_pfcb->WRefCount() > 0 );
	Assert( m_pgnoFDP == m_pfcb->PgnoFDP() );
	CallR( ErrDIROpen( ppib, m_pfcb, ppfucb ) );
//	CallR( ErrDIROpen( ppib, m_pgnoFDP, m_ifmp, ppfucb ) );

	FUCBSetIndex( *ppfucb );
	Call( ErrDIRGotoBookmark( *ppfucb, bookmark ) );

HandleError:
	if( err < 0 )
		{
		DIRClose( *ppfucb );
		//  if we don't set this to NULL the calling function may try to close this again
		*ppfucb = pfucbNil;
		}
	return err;
	}


//  ****************************************************************
//	FINALIZETASK
//  ****************************************************************

FINALIZETASK::FINALIZETASK( const PGNO pgnoFDP, FCB * const pfcb, const IFMP ifmp, const BOOKMARK& bm, const USHORT ibRecordOffset ) :
	RECTASK( pgnoFDP, pfcb, ifmp, bm ),
	m_ibRecordOffset( ibRecordOffset )
	{
	}

ERR FINALIZETASK::ErrExecute( PIB * const ppib )
	{
	ERR		err;
	ULONG	ulColumn;
	FUCB *	pfucb		= pfucbNil;
	BOOL	fInTrx		= fFalse;

	Assert( 0 == ppib->level );
	CallR( ErrOpenFUCBAndGotoBookmark( ppib, &pfucb ) );
	Assert( pfucbNil != pfucb );

	Call( ErrDIRBeginTransaction( ppib, NO_GRBIT ) );
	fInTrx = fTrue;

	Call( ErrDIRGet( pfucb ) );

	//  Currently all finalizable columns are ULONGs
	ulColumn = *( (UnalignedLittleEndian< ULONG > *)( (BYTE *)pfucb->kdfCurr.data.Pv() + m_ibRecordOffset ) );

	CallS( ErrDIRRelease( pfucb ) );

	//	verify refcount is still at zero and there are
	//	no outstanding record updates
	if ( 0 == ulColumn
		&& !FVERActive( pfucb, pfucb->bmCurr ) )
		{
		Call( ErrIsamDelete( ppib, pfucb ) );
		}

	Call( ErrDIRCommitTransaction( ppib, NO_GRBIT ) );
	fInTrx = fFalse;

HandleError:	
	if ( fInTrx )
		{
		CallSx( ErrDIRRollback( ppib ), JET_errRollbackError );
		}

	Assert( pfucbNil != pfucb );
	DIRClose( pfucb );
	return err;
	}


//  ****************************************************************
//	DELETELVTASK
//  ****************************************************************

DELETELVTASK::DELETELVTASK( const PGNO pgnoFDP, FCB * const pfcb, const IFMP ifmp, const BOOKMARK& bm ) :
	RECTASK( pgnoFDP, pfcb, ifmp, bm )
	{
	}

ERR DELETELVTASK::ErrExecute( PIB * const ppib )
	{
	ERR err = JET_errSuccess;
	BOOL fInTrx = fFalse;
	
	Assert( sizeof( LID ) == m_cbBookmarkKey );
	Assert( 0 == m_cbBookmarkData );
	
	FUCB * pfucb = pfucbNil;

	Assert( m_pfcb->FTypeLV() );
	CallR( ErrOpenFUCBAndGotoBookmark( ppib, &pfucb ) );

	Call( ErrDIRBeginTransaction( ppib, NO_GRBIT ) );
	fInTrx = fTrue;

	Call( ErrDIRGet( pfucb ) );
	Call( ErrRECDeletePossiblyDereferencedLV( pfucb, TrxOldest( PinstFromPfucb( pfucb ) ) ) );
	if ( Pcsr( pfucb )->FLatched() )
		{
		CallS( ErrDIRRelease( pfucb ) );
		}
	
	Call( ErrDIRCommitTransaction( ppib, NO_GRBIT ) );
	fInTrx = fFalse;

HandleError:	
	if ( fInTrx )
		{
		if ( Pcsr( pfucb )->FLatched() )
			{
			CallS( ErrDIRRelease( pfucb ) );
			}
		CallSx( ErrDIRRollback( ppib ), JET_errRollbackError );
		}

	if ( pfucbNil != pfucb )
		{
		DIRClose( pfucb );
		}
	return err;
	}


//  ****************************************************************
//	MERGEAVAILEXTTASK
//  ****************************************************************

MERGEAVAILEXTTASK::MERGEAVAILEXTTASK( const PGNO pgnoFDP, FCB * const pfcb, const IFMP ifmp, const BOOKMARK& bm ) :
	RECTASK( pgnoFDP, pfcb, ifmp, bm )
	{
	}

ERR MERGEAVAILEXTTASK::ErrExecute( PIB * const ppib )
	{
	ERR			err			= JET_errSuccess;
	FUCB		* pfucbAE	= pfucbNil;
	BOOL		fInTrx		= fFalse;
	BOOKMARK	bookmark;

	bookmark.key.Nullify();
	bookmark.key.suffix.SetPv( m_rgbBookmarkKey );
	bookmark.key.suffix.SetCb( m_cbBookmarkKey );
	bookmark.data.SetPv( m_rgbBookmarkData );
	bookmark.data.SetCb( m_cbBookmarkData );

	Assert( m_pgnoFDP == m_pfcb->PgnoFDP() );
	Assert( pgnoNull != m_pfcb->PgnoAE() );
	CallR( ErrSPIOpenAvailExt( ppib, m_pfcb, &pfucbAE ) );

	//	wrap in transaction solely to silence assert
	Call( ErrDIRBeginTransaction( ppib, NO_GRBIT ) );
	fInTrx = fTrue;

	Call( ErrBTIMultipageCleanup( pfucbAE, bookmark ) );

	Call( ErrDIRCommitTransaction( ppib, JET_bitCommitLazyFlush ) );
	fInTrx = fFalse;

HandleError:
	Assert( pfucbNil != pfucbAE );
	Assert( !Pcsr( pfucbAE )->FLatched() );

	if ( fInTrx )
		{
		CallSx( ErrDIRRollback( ppib ), JET_errRollbackError );
		}

	Assert( pfucbNil != pfucbAE );
	BTClose( pfucbAE );

	return err;
	}

//  ****************************************************************
//	FREESLVSPACETASK
//  ****************************************************************

SLVSPACETASK::SLVSPACETASK(
			const PGNO pgnoFDP,
			FCB * const pfcb,
			const IFMP ifmp,
			const BOOKMARK& bm,
			const SLVSPACEOPER oper,
			const LONG ipage,
			const LONG cpages ) :
	RECTASK( pgnoFDP, pfcb, ifmp, bm ),
	m_oper( oper ),
	m_ipage( ipage ),
	m_cpages( cpages )
	{
	}
		
ERR SLVSPACETASK::ErrExecute( PIB * const ppib )
	{
	ERR err = JET_errSuccess;
	BOOL fInTrx = fFalse;
	
	Assert( sizeof( PGNO ) == m_cbBookmarkKey );
	Assert( 0 == m_cbBookmarkData );
	
	FUCB * pfucb = pfucbNil;

	CallR( ErrOpenFUCBAndGotoBookmark( ppib, &pfucb ) );

	Call( ErrDIRBeginTransaction( ppib, NO_GRBIT ) );
	fInTrx = fTrue;

Refresh:
	Call( ErrDIRGet( pfucb ) );
	err = Pcsr( pfucb )->ErrUpgrade();
	if ( errBFLatchConflict == err )
		{
		Assert( !Pcsr( pfucb )->FLatched() );
		goto Refresh;
		}
	Call( err );

	// No need to mark the pages as unused in the SpaceMap
	// because the operation isn't moving pages out from the commited state
	// (transition into commited state are not marked in SpaceMap at this level)
	Assert ( slvspaceoperDeletedToFree == m_oper );
	
	Call( ErrBTMungeSLVSpace( pfucb, m_oper, m_ipage, m_cpages, fDIRNoVersion ) );
	CallS( ErrDIRRelease( pfucb ) );
	
	Call( ErrDIRCommitTransaction( ppib, JET_bitCommitLazyFlush ) );
	fInTrx = fFalse;

HandleError:	
	if ( fInTrx )
		{
		if ( Pcsr( pfucb )->FLatched() )
			{
			CallS( ErrDIRRelease( pfucb ) );
			}
		CallSx( ErrDIRRollback( ppib ), JET_errRollbackError );
		}
	if ( pfucbNil != pfucb )
		{
		DIRClose( pfucb );
		}
	return err;
	}


//  ****************************************************************
//	OSSLVDELETETASK
//  ****************************************************************

OSSLVDELETETASK::OSSLVDELETETASK(
			const IFMP				ifmp,
			const QWORD				ibLogical,
			const QWORD				cbSize,
			const CSLVInfo::FILEID	fileid,
			const QWORD				cbAlloc,
			const wchar_t*			wszFileName ) :
	DBTASK( ifmp ),
	m_ibLogical( ibLogical ),
	m_cbSize( cbSize ),
	m_fileid( fileid ),
	m_cbAlloc( cbAlloc )
	{
	wcscpy( m_wszFileName, wszFileName );
	}
		
ERR OSSLVDELETETASK::ErrExecute( PIB * const ppib )
	{
	ERR			err		= JET_errSuccess;
	CSLVInfo	slvinfo;

	CallS( slvinfo.ErrCreateVolatile() );

	CallS( slvinfo.ErrSetFileID( m_fileid ) );
	CallS( slvinfo.ErrSetFileAlloc( m_cbAlloc ) );
	CallS( slvinfo.ErrSetFileName( m_wszFileName ) );

	CSLVInfo::HEADER header;
	header.cbSize			= m_cbSize;
	header.cRun				= 1;
	header.fDataRecoverable	= fFalse;
	header.rgbitReserved_31	= 0;
	header.rgbitReserved_32	= 0;
	CallS( slvinfo.ErrSetHeader( header ) );

	CSLVInfo::RUN run;
	run.ibVirtualNext	= m_cbSize;
	run.ibLogical		= m_ibLogical;
	run.qwReserved		= 0;
	run.ibVirtual		= 0;
	run.cbSize			= m_cbSize;
	run.ibLogicalNext	= m_ibLogical + m_cbSize;
	CallS( slvinfo.ErrMoveAfterLast() );
	CallS( slvinfo.ErrSetCurrentRun( run ) );

	Call( ErrOSSLVRootSpaceDelete( rgfmp[ m_ifmp ].SlvrootSLV(), slvinfo ) );

HandleError:
	slvinfo.Unload();
	return err;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ese98\src\ese\dump.cxx ===
#include "std.hxx"
#include "_dump.hxx"
///#include <ctype.h>

LOCAL const char *rgszDBState[] = {
						"Illegal",
						"Just Created",
						"Dirty Shutdown",
						"Clean Shutdown",
						"Being Converted",
						"Force Detach Replay Error" };


// For ErrDUMPLog():

extern BOOL 	fDBGPrintToStdOut;

ULONG rgclrtyp[ lrtypMax ];
ULONG rgcb[ lrtypMax ];

/* in-memory log buffer. */
#define			csecLGBufSize 100

LOCAL VOID VARARG DUMPPrintF(const CHAR * fmt, ...)
	{
	va_list arg_ptr;
	va_start( arg_ptr, fmt );
	vprintf( fmt, arg_ptr );
	fflush( stdout );
	va_end( arg_ptr );
	}


LOCAL VOID DUMPPrintSig( SIGNATURE *psig )
	{
	LOGTIME tm = psig->logtimeCreate;
	DUMPPrintF( "Create time:%02d/%02d/%04d %02d:%02d:%02d ",
						(short) tm.bMonth, (short) tm.bDay,	(short) tm.bYear + 1900,
						(short) tm.bHours, (short) tm.bMinutes, (short) tm.bSeconds);
	DUMPPrintF( "Rand:%lu ", ULONG(psig->le_ulRandom) );
	DUMPPrintF( "Computer:%s\n", psig->szComputerName );
	}

VOID DUMPIAttachInfo( ATCHCHK *patchchk )
	{
	const DBTIME	dbtime	= patchchk->Dbtime();
	DUMPPrintF( "        dbtime: %I64u (%u-%u)\n",
				dbtime,
				((QWORDX *)&dbtime)->DwHigh(),
				((QWORDX *)&dbtime)->DwLow() );
	DUMPPrintF( "        objidLast: %u\n", patchchk->ObjidLast() );
	DUMPPrintF( "        Signature: " );
	DUMPPrintSig( &patchchk->signDb );
	DUMPPrintF( "        MaxDbSize: %u pages\n", patchchk->CpgDatabaseSizeMax() );
	DUMPPrintF( "        Last Attach: (0x%X,%X,%X)\n",
			patchchk->lgposAttach.lGeneration,
			patchchk->lgposAttach.isec,
			patchchk->lgposAttach.ib );
	DUMPPrintF( "        Last Consistent: (0x%X,%X,%X)\n",
			patchchk->lgposConsistent.lGeneration,
			patchchk->lgposConsistent.isec,
			patchchk->lgposConsistent.ib );
	}
	
ERR ErrDUMPCheckpoint( INST *pinst, IFileSystemAPI *const pfsapi, CHAR *szCheckpoint )
	{
	Assert( pinst->m_plog );
	Assert( pinst->m_pver );

	ERR err = pinst->m_plog->ErrLGDumpCheckpoint( pinst->m_pfsapi, szCheckpoint );

	return err;
	}
	
ERR LOG::ErrLGDumpCheckpoint( IFileSystemAPI *const pfsapi, CHAR *szCheckpoint )
	{
	ERR			err;
	LGPOS		lgpos;
	LOGTIME		tm;
	CHECKPOINT	*pcheckpoint = NULL;
	DBMS_PARAM	dbms_param;
	IFMP		ifmp;

	pcheckpoint = (CHECKPOINT *) PvOSMemoryPageAlloc( sizeof( CHECKPOINT ), NULL );
	if ( pcheckpoint == NULL )
		return ErrERRCheck( JET_errOutOfMemory );
	
	err = ErrLGReadCheckpoint( pfsapi, szCheckpoint, pcheckpoint, fTrue );
	if ( err == JET_errSuccess )
		{
		lgpos = pcheckpoint->checkpoint.le_lgposLastFullBackupCheckpoint;
		DUMPPrintF( "      LastFullBackupCheckpoint: (0x%X,%X,%X)\n",
				lgpos.lGeneration, lgpos.isec, lgpos.ib );
		
		lgpos = pcheckpoint->checkpoint.le_lgposCheckpoint;
		DUMPPrintF( "      Checkpoint: (0x%X,%X,%X)\n",
				lgpos.lGeneration, lgpos.isec, lgpos.ib );

		lgpos = pcheckpoint->checkpoint.le_lgposFullBackup;
		DUMPPrintF( "      FullBackup: (0x%X,%X,%X)\n",
				lgpos.lGeneration, lgpos.isec, lgpos.ib );

		tm = pcheckpoint->checkpoint.logtimeFullBackup;
		DUMPPrintF( "      FullBackup time: %02d/%02d/%04d %02d:%02d:%02d\n",
					(short) tm.bMonth, (short) tm.bDay,	(short) tm.bYear + 1900,
					(short) tm.bHours, (short) tm.bMinutes, (short) tm.bSeconds);
		
		lgpos = pcheckpoint->checkpoint.le_lgposIncBackup;
		DUMPPrintF( "      IncBackup: (0x%X,%X,%X)\n",
				lgpos.lGeneration, lgpos.isec, lgpos.ib );

		tm = pcheckpoint->checkpoint.logtimeIncBackup;
		DUMPPrintF( "      IncBackup time: %02d/%02d/%04d %02d:%02d:%02d\n",
					(short) tm.bMonth, (short) tm.bDay,	(short) tm.bYear + 1900,
					(short) tm.bHours, (short) tm.bMinutes, (short) tm.bSeconds);

		DUMPPrintF( "      Signature: " );
		DUMPPrintSig( &pcheckpoint->checkpoint.signLog );

		dbms_param = pcheckpoint->checkpoint.dbms_param;
		DUMPPrintF( "      Env (CircLog,Session,Opentbl,VerPage,Cursors,LogBufs,LogFile,Buffers)\n");
		DUMPPrintF( "          (%s,%7lu,%7lu,%7lu,%7lu,%7lu,%7lu,%7lu)\n",
					( dbms_param.fDBMSPARAMFlags & fDBMSPARAMCircularLogging ? "     on" : "    off" ),
					ULONG( dbms_param.le_lSessionsMax ),	ULONG( dbms_param.le_lOpenTablesMax ),
					ULONG( dbms_param.le_lVerPagesMax ), 	ULONG( dbms_param.le_lCursorsMax ),
					ULONG( dbms_param.le_lLogBuffers ), 	ULONG( dbms_param.le_lcsecLGFile ),
					ULONG( dbms_param.le_ulCacheSizeMax ) );
		
//		rgfmp = new FMP[ifmpMax];
		
		Call( ErrLGLoadFMPFromAttachments( m_pinst, pfsapi, pcheckpoint->rgbAttach ) );
		for ( ifmp = FMP::IfmpMinInUse(); ifmp <= FMP::IfmpMacInUse(); ifmp++)
			{
			FMP *pfmp = &rgfmp[ifmp];
			if ( pfmp->FInUse() )
				{
				ATCHCHK *patchchk = pfmp->Patchchk();

				DUMPPrintF( "%7d %s %s %s %s\n",
							pfmp->Dbid(),
							pfmp->SzDatabaseName(),
							pfmp->FLogOn() ? "LogOn" : "LogOff",
							pfmp->FVersioningOff() ? "VerOff" : "VerOn",
							pfmp->FReadOnlyAttach() ? "R" : "RW"
							);
				DUMPIAttachInfo( patchchk );
				}
			}
		}

HandleError:
//	if ( NULL != rgfmp )
//		FMP::Term();
	OSMemoryPageFree( pcheckpoint );		
	
	return err;
	}


LOCAL ERR ErrFindNextGen( INST *pinst, CHAR *szLog, LONG *plgen, CHAR *szLogFile )
	{
	Assert( pinst );
	Assert( szLog );
	Assert( szLogFile );
	Assert( plgen );
	Assert( 0 <= *plgen );
	Assert( lGenerationMaxDuringRecovery + 2 > *plgen );
	Assert( pinst->m_plog );
	Assert( pinst->m_pver );

	ERR					err;
	CHAR				szFind[IFileSystemAPI::cchPathMax];
	CHAR				szFileName[IFileSystemAPI::cchPathMax];
	IFileFindAPI		*pffapi = NULL;
	LONG				lGenMax = lGenerationMaxDuringRecovery + 2;
	IFileSystemAPI		*pfsapi = pinst->m_pfsapi;

	/*	make search string "<search path>\edb*.log"
	/**/
	szLogFile[0] = 0;
	strcpy( szFind, szLog );
	strcat( szFind, "*" );
	strcat( szFind, szLogExt );

	CallR( pfsapi->ErrFileFind( szFind, &pffapi ) );
	forever
		{
		CHAR	szDirT[IFileSystemAPI::cchPathMax];
		CHAR	szFNameT[IFileSystemAPI::cchPathMax];
		CHAR	szExtT[IFileSystemAPI::cchPathMax];

		/*	get file name and extension
		/**/
		Call( pffapi->ErrNext() );
		Call( pffapi->ErrPath( szFileName ) );
		Call( pfsapi->ErrPathParse( szFileName, szDirT, szFNameT, szExtT ) );

		/* if length of a numbered log file name and has log file extension
		/**/
		if ( UtilCmpFileName( szExtT, szLogExt ) == 0 )
			{
			if ( strlen( szFNameT ) == 8 )
				{
				INT		ib = 3;
				INT		ibMax = 8;
				LONG	lGen = 0;

				for ( ; ib < ibMax; ib++ )
					{
					BYTE	b = szFNameT[ib];

					if ( b >= '0' && b <= '9' )
						lGen = lGen * 16 + b - '0';
					else if ( b >= 'A' && b <= 'F' )
						lGen = lGen * 16 + b - 'A' + 10;
					else if ( b >= 'a' && b <= 'f' )
						lGen = lGen * 16 + b - 'a' + 10;
					else
						break;
					}

				if ( ib == ibMax )
					{
					Assert( lGen < lGenerationMaxDuringRecovery + 1 );
					if ( lGen < lGenMax && lGen > *plgen )
						{
						lGenMax = lGen;
						strcpy( szLogFile, szFileName );
						}
					}
				}

			else if ( strlen( szFNameT ) == 3 )
				{
				//	found jet.log
				if ( lGenMax == lGenerationMaxDuringRecovery + 2 && lGenerationMaxDuringRecovery + 1 > *plgen )
					{
					lGenMax = lGenerationMaxDuringRecovery + 1;
					strcpy( szLogFile, szFileName );
					}
				}
			}
		}

HandleError:
	delete pffapi;

	if ( err == JET_errFileNotFound )
		{
		err = JET_errSuccess;
		}
	if ( err == JET_errSuccess )
		{
		*plgen = lGenMax;
		}
	return err;
	}

ERR ErrDUMPLog( INST *pinst, CHAR *szLog, JET_GRBIT grbit )
	{
	ERR				err				= JET_errSuccess;
	ERR				errDump			= JET_errSuccess;
	CHAR			szLogFileDir[IFileSystemAPI::cchPathMax];
	CHAR			szLogFileName[IFileSystemAPI::cchPathMax];
	CHAR			szLogFileExt[IFileSystemAPI::cchPathMax];
	LGFILEHDR *		plgfilehdr		= NULL;
	LOG::LOGDUMP_OP	logdumpOp;

	logdumpOp.m_opts = 0;

	Call( pinst->m_pfsapi->ErrPathParse( szLog, szLogFileDir, szLogFileName, szLogFileExt ) );
	if ( 3 == strlen( szLogFileName ) + strlen( szLogFileExt ) )
		{
		LONG	lgen = 0;
		LONG 	lgenLast = 0;

		if ( 0 != szLogFileExt[0] )
			{
			strcat( szLogFileName, szLogFileExt );
			}

		logdumpOp.m_loghdr = LOG::LOGDUMP_LOGHDR_INVALID;
		if ( grbit & JET_bitDBUtilOptionDumpVerbose )
			{
			logdumpOp.m_fVerbose = 1;
			logdumpOp.m_fPrint = 1;
			}

		DUMPPrintF( "Verifying log files...\n" );
		DUMPPrintF( "     %sBase name: %s\n", logdumpOp.m_fVerbose ? " " : "", pinst->m_plog->m_szBaseName );

		plgfilehdr = (LGFILEHDR *) PvOSMemoryPageAlloc( sizeof( LGFILEHDR ), NULL );
		if ( plgfilehdr == NULL )
			{
			Call( ErrERRCheck( JET_errOutOfMemory ) );
			}
		Call( ErrFindNextGen( pinst, szLog, &lgen, szLogFileName ) );

		if ( !logdumpOp.m_fVerbose && 0 != szLogFileName[0] )
			DUMPPrintF( "\n" );

		while ( 0 != szLogFileName[0] )
			{
			lgenLast = lgen;
			if ( logdumpOp.m_fVerbose )
				{
				DUMPPrintF( "\n      Log file: %s", szLogFileName );
				}
			else
				{
				DUMPPrintF( "      Log file: %s", szLogFileName );
				}
			pinst->m_plog->m_fDumppingLogs = fTrue;
			err = pinst->m_plog->ErrLGDumpLog( pinst->m_pfsapi, szLogFileName, &logdumpOp, plgfilehdr );
			if ( err < JET_errSuccess )
				{
				errDump = ( errDump >= JET_errSuccess ? err : errDump );
				}
			else if ( LOG::LOGDUMP_LOGHDR_VALIDADJACENT == logdumpOp.m_loghdr
				&& lgen != plgfilehdr->lgfilehdr.le_lGeneration
				&& lgen < lGenerationMaxDuringRecovery + 1 )
				{
				DUMPPrintF( "\n      %sERROR: Mismatched log generation %lu (0x%lX) with log file name. Expected generation %lu (0x%lX).\n",
						( logdumpOp.m_fVerbose ? "" : "          " ),
						(ULONG)plgfilehdr->lgfilehdr.le_lGeneration, (LONG)plgfilehdr->lgfilehdr.le_lGeneration, 
						lgen, lgen );
				logdumpOp.m_loghdr = LOG::LOGDUMP_LOGHDR_VALID;
				errDump = ( errDump >= JET_errSuccess ? ErrERRCheck( JET_errLogGenerationMismatch ) : errDump );
				}
			else if ( !logdumpOp.m_fVerbose )
				{
				//	just verifying, so report that logfile is OK
				DUMPPrintF( " - OK\n" );
				}

			Call( ErrFindNextGen( pinst, szLog, &lgen, szLogFileName ) );

			//	if it is not jet.log file
			if ( lgen < lGenerationMaxDuringRecovery + 1 )
				{
				if ( lgen != lgenLast+1 )
					{
					Assert( lgenLast < lgen );
					if ( LOG::LOGDUMP_LOGHDR_VALIDADJACENT == logdumpOp.m_loghdr )
						{
						logdumpOp.m_loghdr = LOG::LOGDUMP_LOGHDR_VALID;
						}
					if ( logdumpOp.m_fVerbose )
						DUMPPrintF( "\n\n" );
					if ( lgen == lgenLast + 2 )
						{
						DUMPPrintF( "      Missing log file: %s%05lx%s\n", szLog, lgenLast+1, szLogExt );
						}
					else
						{
						DUMPPrintF( "      Missing log files: %s{%05lx - %05lx}%s\n", szLog, lgenLast+1, lgen-1, szLogExt );
						}
					errDump = ( errDump >= JET_errSuccess ? ErrERRCheck( JET_errMissingLogFile ) : errDump );
					}
				}

			if ( logdumpOp.m_fVerbose )
				DUMPPrintF( "\n" );
			}

		if ( errDump >= JET_errSuccess )
			{
			DUMPPrintF( "\nNo damaged log files were found.\n" );
			}
		else
			{
			DUMPPrintF( "\n" );
			}
		}
	else
		{
		logdumpOp.m_loghdr = LOG::LOGDUMP_LOGHDR_NOHDR;
		logdumpOp.m_fPrint = 1;

#ifdef DEBUG
		logdumpOp.m_fVerbose = 1;
#else
		if ( grbit & JET_bitDBUtilOptionDumpVerbose )
			{
			logdumpOp.m_fVerbose = 1;
			}
#endif			
		
		DUMPPrintF( "     Base name: %s\n", pinst->m_plog->m_szBaseName );
		DUMPPrintF( "      Log file: %s", szLog );
		pinst->m_plog->m_fDumppingLogs = fTrue;
		errDump = pinst->m_plog->ErrLGDumpLog( pinst->m_pfsapi, szLog, &logdumpOp );
		DUMPPrintF( "\n" );
		}
HandleError:
	if ( NULL != plgfilehdr )
		{
		OSMemoryPageFree( plgfilehdr );
		}
	if ( err >= JET_errSuccess && errDump < JET_errSuccess )
		{
		err = errDump;
		}
	return err;
	}

ERR LOG::ErrLGDumpLog( IFileSystemAPI *const pfsapi, CHAR *szLog, LOGDUMP_OP * const plogdumpOp, LGFILEHDR * const plgfilehdr )
	{
	Assert( NULL != plogdumpOp );
	Assert( !( ( LOGDUMP_LOGHDR_NOHDR == plogdumpOp->m_loghdr ) ^ (NULL == plgfilehdr ) ) );

	ERR					err;
	CHECKPOINT			*pcheckpoint	= NULL;
	DBMS_PARAM			dbms_param;
	IFMP				ifmp;
	LGPOS				lgposCheckpoint;
	CHAR 	  			szPathJetChkLog[IFileSystemAPI::cchPathMax];
	BOOL				fCloseNormally;
	BOOL				fCorrupt		= fFalse;
	ERR					errCorrupt		= JET_errSuccess;
	BOOL				fIsPatchable	= fFalse;
	LE_LGPOS			le_lgposFirstT;
	BYTE				*pbNextLR;
	const BOOL			fPrint			= plogdumpOp->m_fPrint;
	const INT			loghdr			= plogdumpOp->m_loghdr;

	if ( LOGDUMP_LOGHDR_VALIDADJACENT == loghdr )
		{
		//	if we fail reading next header will keep the current one
		plogdumpOp->m_loghdr = LOGDUMP_LOGHDR_VALID;
		}

	m_csecLGBuf = csecLGBufSize;	// XXX - what for? For call to InitLogBuf?
	
	//	initialize the sector sizes

	if ( pfsapi->ErrPathComplete( szLog, szPathJetChkLog ) == JET_errInvalidPath )
		{
		DUMPPrintF( "\n                ERROR: File not found.\n" );
		return ErrERRCheck( JET_errFileNotFound );
		}

	err = pfsapi->ErrFileAtomicWriteSize( szPathJetChkLog, (DWORD*)&m_cbSecVolume );
	if ( err < 0 )
		{
		DUMPPrintF( "\n                ERROR: File error %d.\n", err );
		return err;
		}

	//	NOTE: m_cbSec, m_csecHeader, and m_csecLGFile will be setup
	//		  when we call LOG::ErrLGReadFileHdr()

	m_fLGIgnoreVersion = fTrue;
	m_fRecovering = fTrue;		/* behave like doing recovery */
	m_plgfilehdr = NULL;

	/* open the log file, and read dump its log record. */
	Assert( !m_pfapiLog );
	err = pfsapi->ErrFileOpen( szLog, &m_pfapiLog, fTrue );
	if ( err < 0 )
		{
		DUMPPrintF( "\n                ERROR: Cannot open log file. Error %d.\n", err );
		goto HandleError;
		}

	/* dump file header */
	m_plgfilehdr = (LGFILEHDR *) PvOSMemoryPageAlloc( sizeof( LGFILEHDR ), NULL );
	if ( m_plgfilehdr == NULL )
		{
		DUMPPrintF( "\n                ERROR: Out of memory trying to validate log file.\n" );
		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}

	err = ErrLGReadFileHdr( m_pfapiLog, m_plgfilehdr, fNoCheckLogID, fTrue );
	if ( err < 0 )
		{
		DUMPPrintF( "\n                ERROR: Cannot read log file header. Error %d.\n", err );
		goto HandleError;
		}
		
	if ( LOGDUMP_LOGHDR_VALIDADJACENT == loghdr && m_plgfilehdr->lgfilehdr.le_lGeneration != plgfilehdr->lgfilehdr.le_lGeneration + 1 )
		{
		//	edb.log is not the correct generation number (all other missing log file cases are caught in ErrDUMPLog())
		DUMPPrintF( "\n                ERROR: Missing log file(s). Log file is generation %lu (0x%lX), but expected generation is %u (0x%lX).\n",
			(ULONG)m_plgfilehdr->lgfilehdr.le_lGeneration, (LONG)m_plgfilehdr->lgfilehdr.le_lGeneration,
			(ULONG)(plgfilehdr->lgfilehdr.le_lGeneration + 1), (LONG)(plgfilehdr->lgfilehdr.le_lGeneration + 1) );
		Call( ErrERRCheck( JET_errMissingLogFile ) );
		}


	/*	dump checkpoint file
	/**/
	if ( fPrint )
		{
		DUMPPrintF( "\n      lGeneration: %u (0x%X)\n", (ULONG)m_plgfilehdr->lgfilehdr.le_lGeneration, (LONG)m_plgfilehdr->lgfilehdr.le_lGeneration );

		pcheckpoint = (CHECKPOINT *)PvOSMemoryPageAlloc( sizeof( CHECKPOINT ), NULL );
		if ( NULL != pcheckpoint )
			{
			CHAR szJetLogFileName[IFileSystemAPI::cchPathMax];
			CHAR szJetLogFileExt[IFileSystemAPI::cchPathMax];

			CallS( pfsapi->ErrPathParse( szLog, szPathJetChkLog, szJetLogFileName, szJetLogFileExt ) );
			szJetLogFileName[3] = 0;
			CallS( pfsapi->ErrPathBuild( m_pinst->m_szSystemPath, szJetLogFileName, szChkExt, szPathJetChkLog ) );
			err = ErrLGReadCheckpoint( pfsapi, szPathJetChkLog, pcheckpoint, fTrue );
			dbms_param = m_plgfilehdr->lgfilehdr.dbms_param;
		
			if ( JET_errSuccess == err )
				{
				lgposCheckpoint = pcheckpoint->checkpoint.le_lgposCheckpoint;
				DUMPPrintF( "      Checkpoint: (0x%X,%X,%X)\n",
							lgposCheckpoint.lGeneration,
							lgposCheckpoint.isec,
							lgposCheckpoint.ib );
				}
			else
				{
				DUMPPrintF( "      Checkpoint: NOT AVAILABLE\n" );
				err = JET_errSuccess;
				}
			}
		else
			{
			DUMPPrintF( "      Checkpoint: NOT AVAILABLE\n" );
			}

		DUMPPrintF( "      creation time: %02d/%02d/%04d %02d:%02d:%02d\n",
			(short) m_plgfilehdr->lgfilehdr.tmCreate.bMonth,
			(short) m_plgfilehdr->lgfilehdr.tmCreate.bDay,
			(short) m_plgfilehdr->lgfilehdr.tmCreate.bYear + 1900,
			(short) m_plgfilehdr->lgfilehdr.tmCreate.bHours,
			(short) m_plgfilehdr->lgfilehdr.tmCreate.bMinutes,
			(short) m_plgfilehdr->lgfilehdr.tmCreate.bSeconds);
		}

	if ( LOGDUMP_LOGHDR_VALIDADJACENT == loghdr
		&& 0 != memcmp( &m_plgfilehdr->lgfilehdr.tmPrevGen, &plgfilehdr->lgfilehdr.tmCreate, sizeof( LOGTIME ) ) )
		{
		DUMPPrintF( "%sERROR: Invalid log sequence. Previous generation time is [%02d/%02d/%04d %02d:%02d:%02d], but expected [%02d/%02d/%04d %02d:%02d:%02d].\n",
			( fPrint ? "      " : "\n                " ),
			(short) m_plgfilehdr->lgfilehdr.tmPrevGen.bMonth,
			(short) m_plgfilehdr->lgfilehdr.tmPrevGen.bDay,
			(short) m_plgfilehdr->lgfilehdr.tmPrevGen.bYear + 1900,
			(short) m_plgfilehdr->lgfilehdr.tmPrevGen.bHours,
			(short) m_plgfilehdr->lgfilehdr.tmPrevGen.bMinutes,
			(short) m_plgfilehdr->lgfilehdr.tmPrevGen.bSeconds,
			(short) plgfilehdr->lgfilehdr.tmCreate.bMonth,
			(short) plgfilehdr->lgfilehdr.tmCreate.bDay,
			(short) plgfilehdr->lgfilehdr.tmCreate.bYear + 1900,
			(short) plgfilehdr->lgfilehdr.tmCreate.bHours,
			(short) plgfilehdr->lgfilehdr.tmCreate.bMinutes,
			(short) plgfilehdr->lgfilehdr.tmCreate.bSeconds);

		Call( ErrERRCheck( JET_errInvalidLogSequence ) );
		}

	if ( fPrint )
		{
		DUMPPrintF( "      prev gen time: %02d/%02d/%04d %02d:%02d:%02d\n",
			(short) m_plgfilehdr->lgfilehdr.tmPrevGen.bMonth,
			(short) m_plgfilehdr->lgfilehdr.tmPrevGen.bDay,
			(short) m_plgfilehdr->lgfilehdr.tmPrevGen.bYear + 1900,
			(short) m_plgfilehdr->lgfilehdr.tmPrevGen.bHours,
			(short) m_plgfilehdr->lgfilehdr.tmPrevGen.bMinutes,
			(short) m_plgfilehdr->lgfilehdr.tmPrevGen.bSeconds);
		}

	if ( LOGDUMP_LOGHDR_VALIDADJACENT == loghdr
		&& ( m_plgfilehdr->lgfilehdr.le_ulMajor != plgfilehdr->lgfilehdr.le_ulMajor 
			|| m_plgfilehdr->lgfilehdr.le_ulMinor != plgfilehdr->lgfilehdr.le_ulMinor 
			|| m_plgfilehdr->lgfilehdr.le_ulUpdate > plgfilehdr->lgfilehdr.le_ulUpdate ) )
		{
		DUMPPrintF( "%sERROR: Invalid log version. Format LGVersion: (%d.%d.%d). Expected: (%d.%d.%d).\n",
			( fPrint ? "      " : "\n                " ),
			(short) m_plgfilehdr->lgfilehdr.le_ulMajor,
			(short) m_plgfilehdr->lgfilehdr.le_ulMinor,
			(short) m_plgfilehdr->lgfilehdr.le_ulUpdate,
			(short) plgfilehdr->lgfilehdr.le_ulMajor,
			(short) plgfilehdr->lgfilehdr.le_ulMinor,
			(short) plgfilehdr->lgfilehdr.le_ulUpdate );

		Call( ErrERRCheck( JET_errBadLogVersion ) );
		}

	if ( fPrint )
		{
		DUMPPrintF( "      Format LGVersion: (%d.%d.%d)\n",
			(short) m_plgfilehdr->lgfilehdr.le_ulMajor,
			(short) m_plgfilehdr->lgfilehdr.le_ulMinor,
			(short) m_plgfilehdr->lgfilehdr.le_ulUpdate );
		DUMPPrintF( "      Engine LGVersion: (%d.%d.%d)\n",
			(short) ulLGVersionMajor,
			(short) ulLGVersionMinor,
			(short) ulLGVersionUpdate );
		}

	if ( LOGDUMP_LOGHDR_VALIDADJACENT == loghdr
		&& 0 != memcmp( &m_plgfilehdr->lgfilehdr.signLog, &plgfilehdr->lgfilehdr.signLog, sizeof( SIGNATURE ) ) )
		{
		DUMPPrintF( "%sERROR: Invalid log signature: ", ( fPrint ? "      " : "\n                " ) );
		DUMPPrintSig( &m_plgfilehdr->lgfilehdr.signLog );
		DUMPPrintF( "             %s   Expected signature: ", ( fPrint ? "" : "          " ) );
		DUMPPrintSig( &plgfilehdr->lgfilehdr.signLog );

		Call( ErrERRCheck( JET_errBadLogSignature ) );
		}

	if ( fPrint )
		{
		DUMPPrintF( "      Signature: " );
		DUMPPrintSig( &m_plgfilehdr->lgfilehdr.signLog );
		DUMPPrintF( "      Env SystemPath: %s\n",
			m_plgfilehdr->lgfilehdr.dbms_param.szSystemPath);
		DUMPPrintF( "      Env LogFilePath: %s\n",
			m_plgfilehdr->lgfilehdr.dbms_param.szLogFilePath);
		DUMPPrintF( "      Env Log Sec size: %d\n",	(short) m_plgfilehdr->lgfilehdr.le_cbSec);
		DUMPPrintF( "      Env (CircLog,Session,Opentbl,VerPage,Cursors,LogBufs,LogFile,Buffers)\n");
		DUMPPrintF( "          (%s,%7lu,%7lu,%7lu,%7lu,%7lu,%7lu,%7lu)\n",
					( dbms_param.fDBMSPARAMFlags & fDBMSPARAMCircularLogging ? "     on" : "    off" ),
					ULONG( dbms_param.le_lSessionsMax ), 	ULONG( dbms_param.le_lOpenTablesMax ),
					ULONG( dbms_param.le_lVerPagesMax ), 	ULONG( dbms_param.le_lCursorsMax ),
					ULONG( dbms_param.le_lLogBuffers ), 	ULONG( dbms_param.le_lcsecLGFile ),
					ULONG( dbms_param.le_ulCacheSizeMax ) );
		DUMPPrintF( "      Using Reserved Log File: %s\n", 
					( m_plgfilehdr->lgfilehdr.fLGFlags & fLGReservedLog ) ? "true" : "false" );		
		DUMPPrintF( "      Circular Logging Flag (current file): %s\n", 
					( m_plgfilehdr->lgfilehdr.fLGFlags & fLGCircularLoggingCurrent ) ? "on":"off" ); 
		DUMPPrintF( "      Circular Logging Flag (past files): %s\n",
					( m_plgfilehdr->lgfilehdr.fLGFlags & fLGCircularLoggingHistory ) ? "on": "off" );
		err = ErrLGLoadFMPFromAttachments( m_pinst, pfsapi, m_plgfilehdr->rgbAttach );
		if ( err < 0 )
			{
			DUMPPrintF( "      ERROR: Cannot read database attachment list. Error %d.\n", err );
			goto HandleError;
			}
			
		for ( ifmp = FMP::IfmpMinInUse(); ifmp <= FMP::IfmpMacInUse(); ifmp++)
			{
			FMP *pfmp = &rgfmp[ifmp];
			if ( pfmp->FInUse() && fPrint )
				{
				ATCHCHK *patchchk = pfmp->Patchchk();

				DUMPPrintF( "      %d %s\n", pfmp->Dbid(), pfmp->SzDatabaseName() );
				DUMPIAttachInfo( patchchk );
				}
			}

		DUMPPrintF( "\n" );
		}

	if ( LOGDUMP_LOGHDR_NOHDR != plogdumpOp->m_loghdr )
		{
		//	we can set new current header for sure
		Assert( NULL != plgfilehdr );
		plogdumpOp->m_loghdr = LOGDUMP_LOGHDR_VALIDADJACENT;
		}


	/*	set buffer
	/**/
	m_cbSec = m_plgfilehdr->lgfilehdr.le_cbSec;
	err = ErrLGInitLogBuffers( m_csecLGBuf );
	if ( err < 0 )
		{
		DUMPPrintF( "%sERROR: Log file header is OK but integrity could not be verified due to an out-of-memory condition.\n",
					( fPrint ? "      " : "\n                " ) );
		goto HandleError;
		}

	m_fNewLogRecordAdded = fFalse;
	strcpy( m_szLogName, szLog );

	err = ErrLGCheckReadLastLogRecordFF( pfsapi, &fCloseNormally, fTrue, &fIsPatchable );
	if ( FErrIsLogCorruption( err ) )
		{
		Assert( !fIsPatchable );
		DUMPPrintF( "%sERROR: Log damaged (unusable). Last Lgpos: (0x%x,%X,%X). Error %d.\n",
					( fPrint ? "      " : "\n                " ),
					m_lgposLastRec.lGeneration,
					m_lgposLastRec.isec,
					m_lgposLastRec.ib,
					err );

		fCorrupt = fTrue;
		errCorrupt = err;
#ifdef DEBUG
		//	in case we're in verbose mode,
		//	keep going to try to print out
		//	as many log records as possible
		err = JET_errSuccess;
#else
		goto HandleError;
#endif
		}
	else if ( JET_errSuccess != err )
		{
		DUMPPrintF( "%sERROR: Log file header is OK but integrity could not be verified. Error %d.\n",
				( fPrint ? "      " : "\n                " ),
				err );

		Assert( 0 < err );
		goto HandleError;
		}
	else if ( fPrint )
		{
		DUMPPrintF( "      Last Lgpos: (0x%x,%X,%X)\n",
				m_lgposLastRec.lGeneration,
				m_lgposLastRec.isec,
				m_lgposLastRec.ib );
		}

	//	verbose dump
	if ( plogdumpOp->m_fVerbose )
		{
		// initialize other variables
		memset( rgclrtyp, 0, sizeof( rgclrtyp ) );
		memset( rgcb, 0, sizeof( rgcb ) );

#ifdef DEBUG
		fDBGPrintToStdOut = fTrue;
		m_fDBGTraceLog = fTrue;
		m_fDBGTraceRedo = fTrue;
		DUMPPrintF( "\n" );
#endif	//	DEBUG

		le_lgposFirstT.le_lGeneration = m_plgfilehdr->lgfilehdr.le_lGeneration;
		le_lgposFirstT.le_isec = (WORD) m_csecHeader;
		le_lgposFirstT.le_ib = 0;

		Assert( m_plread == pNil );
		m_plread = new LogReader();
		if ( pNil == m_plread )
			{
			Call( ErrERRCheck( JET_errOutOfMemory ) );
			}
		Call( m_plread->ErrLReaderInit( this, m_plgfilehdr->lgfilehdr.le_csecLGFile ) );
		Call( m_plread->ErrEnsureLogFile() );
		err = ErrLGLocateFirstRedoLogRecFF( &le_lgposFirstT, &pbNextLR );
		if ( err == errLGNoMoreRecords )
			{
			fCorrupt = fTrue;
			errCorrupt = ErrERRCheck( JET_errLogFileCorrupt );
			}

		while ( JET_errSuccess == err )
			{
			rgclrtyp[ *pbNextLR ]++;
			rgcb[ *pbNextLR ] += CbLGSizeOfRec( (LR*) pbNextLR );

			LR *plr = (LR *)pbNextLR;
#ifdef DEBUG
			if ( GetNOP() > 0 )
				{
				CheckEndOfNOPList( plr, this );
				}

			if ( 0 == GetNOP() || plr->lrtyp != lrtypNOP )
				{
				PrintLgposReadLR();
				ShowLR( plr, this );
				}
#endif // DEBUG

			err = ErrLGGetNextRecFF( &pbNextLR );
			}

		if ( err == errLGNoMoreRecords )
			{
			err = JET_errSuccess;
			}
		Call( err );
		CallS( err );

		if ( fCorrupt )
			{
			Assert( !fIsPatchable );
			Assert( errCorrupt < JET_errSuccess );
#ifdef DEBUG
			DUMPPrintF( ">%06.6X,%04.4X,%04.4X Log Damaged (unusable) -- cannot continue\n", 
						m_lgposLastRec.lGeneration, m_lgposLastRec.isec, m_lgposLastRec.ib );
#else // !DEBUG
			DUMPPrintF( "      Last Lgpos: (0x%x,%X,%X)\n",
					m_lgposLastRec.lGeneration,
					m_lgposLastRec.isec,
					m_lgposLastRec.ib );
			DUMPPrintF( "\nLog Damaged (unusable): %s\n\n", szLog );
#endif // DEBUG
			}
#ifdef DEBUG
		else if ( fIsPatchable )
			{
			DUMPPrintF( ">%06.6X,%04.4X,%04.4X Log Damaged (PATCHABLE) -- soft recovery will fix this\n",
						m_lgposLastRec.lGeneration, m_lgposLastRec.isec, m_lgposLastRec.ib );
			}
		else if ( GetNOP() > 0 )
			{
			CheckEndOfNOPList( NULL, this );
			}
#endif // DEBUG

		DUMPPrintF( "\n" );
		DUMPPrintF( "==================================\n" );
		DUMPPrintF( "Op         # Records     Avg. Size\n" );
		DUMPPrintF( "----------------------------------\n" );
#ifdef DEBUG
		int i;
		for ( i = 0; i < lrtypMax; i++ )
			{
			//	Temporary hack
			//	Do not print replaced lrtyps
			if ( lrtypInit == i || lrtypTerm == i || lrtypRecoveryUndo == i || lrtypRecoveryQuit == i )
				{
				continue;
				}
			const ULONG	cbAvgSize	= ( rgclrtyp[i] > 0 ? rgcb[i]/rgclrtyp[i] : 0 );
			DUMPPrintF( "%s  %7lu       %7lu\n", SzLrtyp( (LRTYP) i ), rgclrtyp[i], cbAvgSize );
			}
#else // DEBUG
			{
			const int cCollectable = 8;
			static const LRTYP rgcLrtypCollect[cCollectable][lrtypMax] = 
				{ 
					{ lrtypNOP, lrtypInit, lrtypTerm, lrtypMS, lrtypEnd, lrtypInit2, lrtypTerm2,
						lrtypRecoveryUndo, lrtypRecoveryQuit, lrtypFullBackup, lrtypIncBackup, 
						lrtypJetOp, lrtypTrace, lrtypRecoveryUndo2, lrtypRecoveryQuit2,
						lrtypBackup, 47, // hardcoded unknown
						lrtypChecksum, lrtypExtRestore,
						lrtypMax
						},
					{ lrtypBegin, lrtypBegin0, lrtypMax },
					{ lrtypCommit, lrtypCommit0, lrtypMax },
					{ lrtypMacroBegin, lrtypMacroCommit, lrtypMacroAbort, lrtypMax },
					{ lrtypInsert, lrtypFlagInsert, lrtypFlagInsertAndReplaceData, lrtypMax },
					{ lrtypCreateSingleExtentFDP, lrtypCreateMultipleExtentFDP, lrtypMax },
					{ lrtypDelete, lrtypFlagDelete, lrtypMax },
					{ lrtypReplace, lrtypReplaceD, lrtypMax }
				};
			
			const char *rgszLrtypCollect[cCollectable] = 
				{ 
				"Others   ",
				SzLrtyp( lrtypBegin ),
				SzLrtyp( lrtypCommit ),
				"MacroOp  ",
				SzLrtyp( lrtypInsert ),
				"CreateFDP",
				SzLrtyp( lrtypDelete ),
				SzLrtyp( lrtypReplace )
				};
				
			for ( int i = 0; i < lrtypMax; i++ )
				{
				for ( int j = 0; j < cCollectable; j++ )
					{
					int k;
					for ( k = 0; lrtypMax > k && lrtypMax != rgcLrtypCollect[j][k] && i != rgcLrtypCollect[j][k]; k++ )
						{
						//	Nothing
						}
					if ( lrtypMax != rgcLrtypCollect[j][k] && lrtypMax > k)
						{
						if ( 0 == k )
							{
							for ( k = 1; lrtypMax != rgcLrtypCollect[j][k]; k++ )
								{
								rgclrtyp[i] += rgclrtyp[rgcLrtypCollect[j][k]];
								rgcb[i] += rgcb[rgcLrtypCollect[j][k]];
								}
							const ULONG	cbAvgSize	= ( rgclrtyp[i] > 0 ? rgcb[i]/rgclrtyp[i] : 0 );
							DUMPPrintF( "%s  %7lu       %7lu\n", rgszLrtypCollect[j], rgclrtyp[i], cbAvgSize );
							}
						break;
						}
					}
				if ( j < cCollectable )
					{
					continue;
					}
				const ULONG	cbAvgSize	= ( rgclrtyp[i] > 0 ? rgcb[i]/rgclrtyp[i] : 0 );
				DUMPPrintF( "%s  %7lu       %7lu\n", SzLrtyp( (LRTYP) i ), rgclrtyp[i], cbAvgSize );
				}
			}
#endif // DEBUG

		DUMPPrintF( "==================================\n" );
		}


#ifdef DEBUG
#else // !DEBUG
	if ( fPrint && !fCorrupt )
		{
		DUMPPrintF( "\nIntegrity check passed for log file: %s\n", szLog );
		}
#endif // DEBUG


HandleError:
	m_fNewLogRecordAdded = fTrue;
	
	if ( pNil != m_plread )
		{
		if ( err == JET_errSuccess )
			{
			err = m_plread->ErrLReaderTerm();
			}
		else
			{
			m_plread->ErrLReaderTerm();
			}
		delete m_plread;
		m_plread = pNil;
		}

	OSMemoryPageFree( pcheckpoint );

	if ( NULL != m_plgfilehdr && LOGDUMP_LOGHDR_VALIDADJACENT == plogdumpOp->m_loghdr )
		{
		Assert( NULL != plgfilehdr );
		memcpy( plgfilehdr, m_plgfilehdr, sizeof( LGFILEHDR ) );
		}

	OSMemoryPageFree( m_plgfilehdr );
	m_plgfilehdr = NULL;

//	if ( rgfmp != NULL )
//		FMP::Term();

	delete m_pfapiLog;
	m_pfapiLog = NULL;

	LGTermLogBuffers();

	if ( err >= JET_errSuccess && errCorrupt < JET_errSuccess )
		{
		Assert( fCorrupt );
		err = errCorrupt;
		}
	return err;
	}


#ifdef DEBUG

//  ================================================================
struct DUMPNODE
//  ================================================================
	{
	DUMPNODE(
		const LGPOS& lgpos,
		LRTYP lrtyp,
		const NODELOC& nodeloc,
		const CHAR * szOper
		) :
			pdumpnodeNext( NULL ),
			pdumpnodePrev( NULL ),
			lgpos( lgpos ),
			lrtyp( lrtyp ),
			nodeloc( nodeloc ),
			nodelocCur( nodelocCur ),
			sz( new CHAR[strlen(szOper)+1] )
		{ 
		Assert( lrtyp < lrtypMax );
		strcpy( sz, szOper );
		}
	virtual ~DUMPNODE() { delete[] sz; }		
	
	DUMPNODE * pdumpnodeNext;
	DUMPNODE * pdumpnodePrev;
	NODELOC	   nodelocCur;

	CHAR 		* const sz;
	const LGPOS			lgpos;
	const LRTYP			lrtyp;
	const NODELOC		nodeloc;
	};


//  ================================================================
struct DUMPNODESPLIT : public DUMPNODE
//  ================================================================
	{
	DUMPNODESPLIT(
		const LGPOS& lgpos,
		LRTYP lrtyp,
		const NODELOC& nodeloc,
		const CHAR * szOper,
		PGNO  pgno,
		INT	  iline,
		BYTE  oper
		) :
			DUMPNODE( lgpos, lrtyp, nodeloc, szOper ),
			pgnoOld( pgno ),
			ilineOper( iline ),
			splitoper( oper )
		{
		}
	
	const PGNO	pgnoOld;
	const INT	ilineOper;
	const BYTE	splitoper;
	};


//  ================================================================
class DUMPLOGNODE
//  ================================================================
	{
	public:
		DUMPLOGNODE( const NODELOC& nodeloc, const LGPOS& lgpos, LOG *plog );
		~DUMPLOGNODE();

		VOID ProcessLR( const LR* plr, LGPOS *plgpos );
		VOID DumpNodes();

	private:
		VOID ProcessLRAfterLgpos_( const LR* plr, const LGPOS& lgpos );
		VOID ProcessLRBeforeLgpos_( const LR* plr, const LGPOS& lgpos );
		VOID UpdateNodelocBackward_( DUMPNODE * pdumpnode );
		
	private:
		const NODELOC 	m_nodelocOrig_;
		const LGPOS		m_lgposOrig_;
		LGPOS			m_lgposStart_;
		LGPOS			m_lgposEnd_;
		
		NODELOC			m_nodelocCur_;
		NODELOC			m_nodelocStart_;
		NODELOC			m_nodelocEnd_;

		DUMPNODE		*m_pdumpnodeHead_;
		DUMPNODE		*m_pdumpnodeTail_;

		BOOL			m_fInMacro;
		BOOL			m_fDumpSplit;
		
		LOG 			*m_plog;
	};


//  ================================================================
DUMPLOGNODE::DUMPLOGNODE( const NODELOC& nodeloc, const LGPOS& lgpos, LOG *plog ) :
//  ================================================================
	m_nodelocOrig_( nodeloc ),
	m_lgposOrig_( lgpos ),
	m_nodelocCur_( nodeloc ),
	m_lgposStart_( lgpos ),
	m_nodelocStart_( nodeloc ),
	m_lgposEnd_( lgpos ),
	m_nodelocEnd_( nodeloc ),
	m_pdumpnodeHead_( NULL ),
	m_pdumpnodeTail_( NULL ),
	m_fInMacro( fFalse ),
	m_fDumpSplit( fFalse ),
	m_plog( plog )
	{
	}


//  ================================================================
DUMPLOGNODE::~DUMPLOGNODE()
//  ================================================================
	{
	DUMPNODE * pdumpnode = m_pdumpnodeHead_;
	DUMPNODE * pdumpnodeDelete;
	while( pdumpnode )
		{
		pdumpnodeDelete = pdumpnode;
		pdumpnode = pdumpnode->pdumpnodeNext;
		delete pdumpnodeDelete;
		}
	}



//  ================================================================
VOID DUMPLOGNODE::ProcessLRBeforeLgpos_( const LR* plr, const LGPOS& lgpos )
//  ================================================================
	{
	DUMPNODE * pdumpnode = NULL;
	CHAR rgchBuf[1024];
	
	switch ( plr->lrtyp )
		{
		case lrtypNOP:
		case lrtypMS:
		case lrtypJetOp:
		case lrtypBegin:
		case lrtypBegin0:
		case lrtypBeginDT:
		case lrtypRefresh:
		case lrtypCommit:
		case lrtypCommit0:
		case lrtypPrepCommit:
		case lrtypPrepRollback:
		case lrtypRollback:
		case lrtypCreateDB:
		case lrtypAttachDB:
		case lrtypDetachDB:
		case lrtypCreateMultipleExtentFDP:
		case lrtypCreateSingleExtentFDP:
		case lrtypConvertFDP:
		case lrtypSetExternalHeader:
		case lrtypInit:
		case lrtypTerm:
		case lrtypShutDownMark:
		case lrtypRecoveryQuit:
		case lrtypRecoveryUndo:
		case lrtypFullBackup:
		case lrtypIncBackup:
		case lrtypBackup:
		case lrtypTrace:
		case lrtypExtRestore:
		case lrtypForceDetachDB:
		case lrtypEmptyTree:
			break;

		case lrtypMacroBegin:
		case lrtypMacroCommit:
			{
			const NODELOC 			nodeloc( 0, 0, 0 );

			LrToSz( plr, rgchBuf, m_plog );
			pdumpnode = new DUMPNODE( lgpos, plr->lrtyp, nodeloc, rgchBuf );
			}
			break;

		case lrtypMacroAbort:
			AssertSz( fFalse, "lrtypMacroAbort not handled" );
			break;
			
		case lrtypUndoInfo:
			{
			const LRPAGE_ * const	plrpage = reinterpret_cast<const LRPAGE_ *>( plr );
			const NODELOC 			nodeloc( plrpage->dbid, plrpage->le_pgno, 0 );

			LrToSz( plr, rgchBuf, m_plog );
			pdumpnode = new DUMPNODE( lgpos, plrpage->lrtyp, nodeloc, rgchBuf );
			}
			break;

		case lrtypDelta:
		case lrtypFlagDelete:
		case lrtypFlagInsert:
		case lrtypFlagInsertAndReplaceData:
		case lrtypReplace:
		case lrtypReplaceD:
		case lrtypUndo:
		case lrtypInsert:
		case lrtypDelete:		
			{
			const LRNODE_ * const	plrnode = reinterpret_cast<const LRNODE_ *>( plr );
			const NODELOC 			nodeloc( plrnode->dbid, plrnode->le_pgno, plrnode->ILine() );

			LrToSz( plr, rgchBuf, m_plog );
			pdumpnode = new DUMPNODE( lgpos, plrnode->lrtyp, nodeloc, rgchBuf );
			}
			break;

		case lrtypSplit:
			{
			const LRSPLIT * const plrsplit = reinterpret_cast<const LRSPLIT *>( plr );

			switch( plrsplit->splittype )
				{
				case splittypeRight:
				case splittypeVertical:
				case splittypeAppend:
					{
					const NODELOC 	nodelocNew( plrsplit->dbid, plrsplit->le_pgnoNew, plrsplit->le_ilineSplit );
					
					LrToSz( plr, rgchBuf, m_plog );
					pdumpnode = new DUMPNODESPLIT(
						lgpos,
						plrsplit->lrtyp,
						nodelocNew,
						rgchBuf,
						plrsplit->le_pgno,
						plrsplit->le_ilineOper,
						plrsplit->splitoper
						);
					}
					break;
				default:
					break;
				}
			}
			break;
			
		case lrtypMerge:
			AssertSz( fFalse, "lrtypMerge not handled" );
			break;

		default:
			Assert( fFalse );
			break;			
		}

	if( pdumpnode )
		{
		if( NULL == m_pdumpnodeHead_ )
			{
			Assert( NULL == m_pdumpnodeTail_ );
			m_pdumpnodeHead_ = pdumpnode;
			m_pdumpnodeTail_ = pdumpnode;
			}
		else
			{
			Assert( NULL != m_pdumpnodeTail_ );
			m_pdumpnodeTail_->pdumpnodeNext = pdumpnode;
			pdumpnode->pdumpnodePrev 		= m_pdumpnodeTail_;
			m_pdumpnodeTail_ 				= pdumpnode;
			}
		}
	}



//  ================================================================
VOID DUMPLOGNODE::ProcessLRAfterLgpos_( const LR* plr, const LGPOS& lgpos )
//  ================================================================
	{
	DUMPNODE * pdumpnode = NULL;
	char rgchBuf[1024];
	
	switch ( plr->lrtyp )
		{
		case lrtypNOP:
		case lrtypMS:
		case lrtypJetOp:
		case lrtypBegin:
		case lrtypBegin0:
		case lrtypBeginDT:
		case lrtypRefresh:
		case lrtypCommit:
		case lrtypCommit0:
		case lrtypPrepCommit:
		case lrtypPrepRollback:
		case lrtypRollback:
		case lrtypCreateDB:
		case lrtypAttachDB:
		case lrtypDetachDB:
		case lrtypCreateMultipleExtentFDP:
		case lrtypCreateSingleExtentFDP:
		case lrtypConvertFDP:
		case lrtypSetExternalHeader:
		case lrtypInit:
		case lrtypTerm:
		case lrtypShutDownMark:
		case lrtypRecoveryQuit:
		case lrtypRecoveryUndo:
		case lrtypFullBackup:
		case lrtypBackup:
		case lrtypIncBackup:
		case lrtypTrace:
		case lrtypExtRestore:
		case lrtypForceDetachDB:
		case lrtypEmptyTree:
			break;

		case lrtypMacroAbort:
			AssertSz( fFalse, "lrtypMacroAbort not handled" );
			break;

		case lrtypMacroBegin:
			m_fDumpSplit	= fFalse;
			m_fInMacro 		= fTrue;
			break;
			
		case lrtypMacroCommit:
			m_fDumpSplit	= fFalse;
			m_fInMacro 		= fFalse;
			break;

		case lrtypUndoInfo:
			{
			const LRPAGE_ * const	plrpage = reinterpret_cast<const LRPAGE_ *>( plr );
			const NODELOC 			nodeloc( plrpage->dbid, plrpage->le_pgno, 0 );

			if( m_nodelocCur_.FSamePage( nodeloc ) )
				{
				LrToSz( plr, rgchBuf, m_plog );
				pdumpnode = new DUMPNODE( lgpos, plrpage->lrtyp, nodeloc, rgchBuf );
				}
			}
			break;

		case lrtypDelta:
		case lrtypFlagDelete:
		case lrtypFlagInsert:
		case lrtypFlagInsertAndReplaceData:
		case lrtypReplace:
		case lrtypReplaceD:
		case lrtypUndo:
			{
			const LRNODE_ * const	plrnode = reinterpret_cast<const LRNODE_ *>( plr );
			const NODELOC 			nodeloc( plrnode->dbid, plrnode->le_pgno, plrnode->ILine() );

			if( m_fInMacro && m_fDumpSplit
				|| m_nodelocCur_ == nodeloc )
				{
				LrToSz( plr, rgchBuf, m_plog );
				pdumpnode = new DUMPNODE( lgpos, plrnode->lrtyp, nodeloc, rgchBuf );
				}
			}
			break;

		case lrtypInsert:
		case lrtypDelete:		
			{
			const LRNODE_ * const	plrnode = reinterpret_cast<const LRNODE_ *>( plr );
			const NODELOC 			nodeloc( plrnode->dbid, plrnode->le_pgno, plrnode->ILine() );

			if( m_fInMacro && m_fDumpSplit
				|| m_nodelocCur_.FSamePage( nodeloc ) && nodeloc <= m_nodelocCur_
				)
				{
				LrToSz( plr, rgchBuf, m_plog );
				pdumpnode = new DUMPNODE( lgpos, plrnode->lrtyp, nodeloc, rgchBuf );

				if( lrtypInsert == plr->lrtyp )
					{
					if( m_nodelocCur_ != nodeloc
						|| CmpLgpos( &lgpos, &m_lgposOrig_ ) != 0 )
						{
						m_nodelocCur_.MoveUp();
						}
					}
				else if( m_nodelocCur_ == nodeloc )
					{
					Assert( lrtypDelete == plr->lrtyp );
					m_nodelocCur_.MovePage( 0, 0 );			//  node no longer exists
					}
				else
					{
					Assert( lrtypDelete == plr->lrtyp );
					m_nodelocCur_.MoveDown();
					}
				}
			}
			break;

		case lrtypSplit:
			{
			const LRSPLIT * const plrsplit = reinterpret_cast<const LRSPLIT *>( plr );
			const NODELOC 	nodeloc( plrsplit->dbid, plrsplit->le_pgno, plrsplit->le_ilineSplit );
			const NODELOC 	nodelocNew( plrsplit->dbid, plrsplit->le_pgnoNew, 0 );

			if( nodeloc.FSamePage( m_nodelocCur_ ) && m_nodelocCur_ >= nodeloc
				|| nodelocNew.FSamePage( m_nodelocCur_ ) )
				{
				//  this node was split onto the new page
				LrToSz( plr, rgchBuf, m_plog );
				pdumpnode = new DUMPNODE(lgpos, plrsplit->lrtyp, nodeloc, rgchBuf );
				}

			if( nodeloc.FSamePage( m_nodelocCur_ ) )
				{
				if ( splittypeRight == plrsplit->splittype )
					{
					if( splitoperInsert == plrsplit->splitoper
						&& 	( m_nodelocCur_ > nodeloc
							|| 	m_nodelocCur_ == nodeloc
								&& CmpLgpos( &lgpos, &m_lgposOrig_ ) != 0 ) )
						{
						Assert( pdumpnode );
						Assert( m_fInMacro );
						m_nodelocCur_.MoveUp();
						m_fDumpSplit = fTrue;
						}

					if( m_nodelocCur_ >= nodeloc )
						{
						Assert( pdumpnode );
						Assert( m_fInMacro );
						m_nodelocCur_.MovePage( plrsplit->le_pgnoNew, m_nodelocCur_.Iline() - nodeloc.Iline() );
						m_fDumpSplit = fTrue;
						}
					}
				else if ( splittypeVertical == plrsplit->splittype )
					{
					Assert( pdumpnode );
					Assert( m_fInMacro );
					m_nodelocCur_.MovePage( plrsplit->le_pgnoNew, m_nodelocCur_.Iline() );
					m_fDumpSplit = fTrue;
					}
				else if ( splittypeAppend == plrsplit->splittype )
					{
					}
				else
					{
					}
				}
			}
			break;
			
		case lrtypMerge:
			{
			const LRMERGE * const plrmerge = reinterpret_cast<const LRMERGE *>( plr );
			const NODELOC 	nodeloc( plrmerge->dbid, plrmerge->le_pgno, 0 );
			const NODELOC 	nodelocNew( plrmerge->dbid, plrmerge->le_pgnoRight, 0 );

			if( nodeloc.FSamePage( m_nodelocCur_ )
				|| nodelocNew.FSamePage( m_nodelocCur_ ) )
				{
				AssertSz( fFalse, "lrtypMerge not handled" );
				}
			}
			break;

		default:
			Assert( fFalse );
			break;
			
		}

	if( pdumpnode )
		{
		if( m_nodelocCur_.Pgno() != 0 )
			{
			m_nodelocEnd_ = m_nodelocCur_;
			}
		m_lgposEnd_ = pdumpnode->lgpos;
		
		pdumpnode->pdumpnodePrev = m_pdumpnodeTail_;
		if( NULL == m_pdumpnodeHead_ )
			{
			Assert( NULL == m_pdumpnodeTail_ );
			m_pdumpnodeHead_ = pdumpnode;
			}
		else
			{
			Assert( NULL != m_pdumpnodeTail_ );
			m_pdumpnodeTail_->pdumpnodeNext = pdumpnode;
			}
		m_pdumpnodeTail_ = pdumpnode;

		pdumpnode->nodelocCur = m_nodelocCur_;
		}
	}


//  ================================================================
VOID DUMPLOGNODE::UpdateNodelocBackward_( DUMPNODE * pdumpnode )
//  ================================================================
	{
	BOOL fDelete = fTrue;
	
	switch ( pdumpnode->lrtyp )
		{
		case lrtypMacroBegin:
			m_fInMacro = fFalse;
			break;
			
		case lrtypMacroCommit:
			m_fInMacro = fTrue;
			break;

		case lrtypMacroAbort:
			AssertSz( fFalse, "lrtypMacroAbort not handled" );
			break;

		case lrtypUndoInfo:
			if( m_nodelocCur_.FSamePage( pdumpnode->nodeloc ) )
				{
				fDelete = fFalse;
				}
			break;

		case lrtypDelta:
		case lrtypFlagDelete:
		case lrtypFlagInsert:
		case lrtypFlagInsertAndReplaceData:
		case lrtypReplace:
		case lrtypReplaceD:
		case lrtypUndo:
			if( m_nodelocCur_ == pdumpnode->nodeloc )
				{
				fDelete = fFalse;
				}
			break;

		case lrtypInsert:
		case lrtypDelete:		
			if( m_nodelocCur_.FSamePage( pdumpnode->nodeloc ) 
				&& pdumpnode->nodeloc <= m_nodelocCur_ )
				{
				fDelete = fFalse;
						
				if( lrtypInsert == pdumpnode->lrtyp )
					{
					if( pdumpnode->nodeloc == m_nodelocCur_ )
						{
						//  this was the insert that created this node
						m_nodelocCur_.MovePage( 0,0 );
						}
					else
						{
						//  a node underneath this one was inserted
						m_nodelocCur_.MoveDown();
						}
					}
				else if( pdumpnode->nodeloc < m_nodelocCur_ )
					{
					//  a node underneath this node was deleted
					Assert( lrtypDelete == pdumpnode->lrtyp );
					m_nodelocCur_.MoveUp();
					}
				}
			break;

		case lrtypSplit:
			if( m_nodelocCur_.FSamePage( pdumpnode->nodeloc ) )
				{
				//  the page this node is on was created by this split
				fDelete = fFalse;
				const DUMPNODESPLIT * const pdumpnodesplit = static_cast<DUMPNODESPLIT *>( pdumpnode );
				DUMPPrintF( ">>> Split moves [%d:%d] to [%d:%d] <<<\n", m_nodelocCur_.Dbid(), m_nodelocCur_.Pgno(),
							m_nodelocCur_.Dbid(), pdumpnodesplit->pgnoOld );
				m_nodelocCur_.MovePage(
					pdumpnodesplit->pgnoOld,
					m_nodelocCur_.Iline() + pdumpnodesplit->nodeloc.Iline()
				);
					
				if( splitoperInsert == pdumpnodesplit->splitoper )
					{
					if( pdumpnodesplit->ilineOper < m_nodelocCur_.Iline() )
						{
						//  the node was inserted in front of us
						m_nodelocCur_.MoveDown();
						}			
					else if( pdumpnodesplit->ilineOper == m_nodelocCur_.Iline() )
						{
						//  this insertion created this node
						m_nodelocCur_.MovePage( 0, 0 );
						}
					}
				}
			break;
			
		case lrtypMerge:
			AssertSz( fFalse, "lrtypMerge not handled" );
			break;

		default:
			Assert( fFalse );
			break;
			
		}

	if( fDelete )
		{
		if( m_pdumpnodeHead_ == pdumpnode
			|| m_pdumpnodeTail_ == pdumpnode )
			{
			if( m_pdumpnodeHead_ == pdumpnode )
				{
				m_pdumpnodeHead_ = pdumpnode->pdumpnodeNext;
				if( m_pdumpnodeHead_ )
					{
					m_pdumpnodeHead_->pdumpnodePrev = NULL;
					}
				}

			if( m_pdumpnodeTail_ == pdumpnode )
				{
				m_pdumpnodeTail_ = pdumpnode->pdumpnodePrev;
				if( m_pdumpnodeTail_ )
					{
					m_pdumpnodeTail_->pdumpnodeNext = NULL;
					}
				}	
			}
		else
			{
			DUMPNODE * const pdumpnodeNext = pdumpnode->pdumpnodeNext;
			DUMPNODE * const pdumpnodePrev = pdumpnode->pdumpnodePrev;
			
			pdumpnodeNext->pdumpnodePrev = pdumpnodePrev;
			pdumpnodePrev->pdumpnodeNext = pdumpnodeNext;
			}

		delete pdumpnode;
		}
	else
		{
		if( m_nodelocCur_.Pgno() != 0 )
			{
			m_nodelocStart_ = m_nodelocCur_;
			}
		m_lgposStart_ = pdumpnode->lgpos;

		pdumpnode->nodelocCur = m_nodelocCur_;
		}
	}

//  ================================================================
VOID DUMPLOGNODE::ProcessLR( const	LR* plr, LGPOS *plgpos )
//  ================================================================
	{
	if( CmpLgpos( plgpos, &m_lgposOrig_ ) <= 0 )
		{
		ProcessLRBeforeLgpos_( plr, *plgpos );
		}
	else
		{
		ProcessLRAfterLgpos_( plr, *plgpos );
		}
	}

	
//  ================================================================
VOID DUMPLOGNODE::DumpNodes()
//  ================================================================
	{
	DUMPPrintF( "\n" );

	DUMPNODE * pdumpnode;

	m_nodelocCur_ = m_nodelocOrig_;

	pdumpnode = m_pdumpnodeTail_;
	while( pdumpnode && CmpLgpos( &m_lgposOrig_, &(pdumpnode->lgpos) ) <= 0 )
		{
		pdumpnode = pdumpnode->pdumpnodePrev;
		}
		
	while( pdumpnode )
		{
		DUMPNODE * const pdumpnodePrev = pdumpnode->pdumpnodePrev;
		UpdateNodelocBackward_( pdumpnode );
		pdumpnode = pdumpnodePrev;
		}

	DUMPPrintF( "\n" );

	pdumpnode = m_pdumpnodeHead_;
	while( pdumpnode )
		{
		DUMPPrintF( ">%06X,%04X,%04X ", pdumpnode->lgpos.lGeneration, pdumpnode->lgpos.isec, pdumpnode->lgpos.ib );
		DUMPPrintF( "%s", pdumpnode->sz );
		DUMPPrintF( " ([%d:%d:%d])",
			pdumpnode->nodelocCur.Dbid(),
			pdumpnode->nodelocCur.Pgno(),
			pdumpnode->nodelocCur.Iline() );
		DUMPPrintF( "\n" );
		pdumpnode = pdumpnode->pdumpnodeNext;
		}

	DUMPPrintF( "\n\n" );

	DUMPPrintF( 
		"[%d:%d:%d]@%06X,%04X,%04X ",
		m_nodelocOrig_.Dbid(), m_nodelocOrig_.Pgno(), m_nodelocOrig_.Iline(),
		m_lgposOrig_.lGeneration, m_lgposOrig_.isec, m_lgposOrig_.ib
	);
	DUMPPrintF(
		"starts at " );
	DUMPPrintF(
		"[%d:%d:%d]@%06X,%04X,%04X ",
		m_nodelocStart_.Dbid(), m_nodelocStart_.Pgno(), m_nodelocStart_.Iline(),
		m_lgposStart_.lGeneration, m_lgposStart_.isec, m_lgposStart_.ib
		);
	DUMPPrintF( " and moves to " );
	DUMPPrintF(
		"[%d:%d:%d]@%06X,%04X,%04X ",
		m_nodelocEnd_.Dbid(), m_nodelocEnd_.Pgno(), m_nodelocEnd_.Iline(),
		m_lgposEnd_.lGeneration, m_lgposEnd_.isec, m_lgposEnd_.ib
		);
	DUMPPrintF( "\n" );
	}

	
//  ================================================================
ERR ErrDUMPLogNode( INST *pinst, CHAR *szLog, const NODELOC& nodeloc, const LGPOS& lgpos )
//  ================================================================
	{
	Assert( pinst->m_plog );
	Assert( pinst->m_pver );

	return pinst->m_plog->ErrLGDumpLogNode( szLog, nodeloc, lgpos );
	}
	
ERR LOG::ErrLGDumpLogNode( CHAR *szLog, const NODELOC& nodeloc, const LGPOS& lgpos )
	{
	AssertTracking();

	return JET_errSuccess;
	}

#endif		// DEBUG


INLINE LOCAL VOID DUMPPrintBkinfo( BKINFO *pbkinfo )
	{
	LONG	genLow, genHigh;
	LOGTIME	tm = pbkinfo->logtimeMark;
	LGPOS	lgpos;
	
	lgpos = pbkinfo->le_lgposMark;
	genLow = pbkinfo->le_genLow;
	genHigh = pbkinfo->le_genHigh;
	DUMPPrintF( "        Log Gen: %u-%u (0x%x-0x%x)\n", genLow, genHigh, genLow, genHigh );
	DUMPPrintF( "           Mark: (0x%X,%X,%X)\n", lgpos.lGeneration, lgpos.isec, lgpos.ib );
		
	DUMPPrintF( "           Mark: %02d/%02d/%04d %02d:%02d:%02d\n",
						(short) tm.bMonth, (short) tm.bDay,	(short) tm.bYear + 1900,
						(short) tm.bHours, (short) tm.bMinutes, (short) tm.bSeconds);
	}	
		
ERR ErrDUMPHeader( INST *pinst, CHAR *szDatabase, BOOL fSetState )
	{
	ERR			err;
	DBFILEHDR_FIX	*pdfh;
	LGPOS		lgpos;
	LOGTIME		tm;

	pdfh = (DBFILEHDR_FIX * )PvOSMemoryPageAlloc( g_cbPage, NULL );
	if ( pdfh == NULL )
		return ErrERRCheck( JET_errOutOfMemory );
	
	err = ( ( !fSetState ) ? 
			ErrUtilReadShadowedHeader : ErrUtilReadAndFixShadowedHeader )
				( pinst->m_pfsapi, szDatabase, (BYTE*)pdfh, g_cbPage, OffsetOf( DBFILEHDR_FIX, le_cbPageSize ) );
	if ( err < 0 )
		{
		if ( err == JET_errDiskIO )
			err = ErrERRCheck( JET_errDatabaseCorrupted );
		goto HandleError;
		}

	// check filetype
	if( filetypeUnknown != pdfh->le_filetype // old format
		&& filetypeDB != pdfh->le_filetype 
		&& filetypeSLV != pdfh->le_filetype )
		{
		// not a database or streaming file
		Call( ErrERRCheck( JET_errFileInvalidType ) );
		}

	if ( fSetState )
		{
		pdfh->SetDbstate( JET_dbstateConsistent );
		memset( &pdfh->le_lgposConsistent, 0, sizeof( pdfh->le_lgposConsistent ) );
		memset( &pdfh->logtimeConsistent, 0, sizeof( pdfh->logtimeConsistent ) );
		memset( &pdfh->le_lgposAttach, 0, sizeof( pdfh->le_lgposAttach ) );
		pdfh->le_lGenMinRequired = 0;
		pdfh->le_lGenMaxRequired = 0;
		Call( ErrUtilWriteShadowedHeader(	pinst->m_pfsapi, 
											szDatabase, 
											fTrue,
											(BYTE*)pdfh, 
											g_cbPage ) );
		}

	DUMPPrintF( "        File Type: %s\n", attribDb == pdfh->le_attrib ? "Database" : attribSLV == pdfh->le_attrib ? "Streaming File" : "UNKNOWN" );
	DUMPPrintF( "   Format ulMagic: 0x%lx\n", LONG( pdfh->le_ulMagic ) );
	DUMPPrintF( "   Engine ulMagic: 0x%lx\n", ulDAEMagic );
	DUMPPrintF( " Format ulVersion: 0x%lx,%d\n", LONG( pdfh->le_ulVersion ), short( pdfh->le_ulUpdate ) );
	DUMPPrintF( " Engine ulVersion: 0x%lx,%d\n", ulDAEVersion, ulDAEUpdate );
		
	DUMPPrintF( "     DB Signature: " );
	DUMPPrintSig( &pdfh->signDb );
		
#ifdef DBHDR_FORMAT_CHANGE
	DUMPPrintF( "      cbDbHdrPage: %l\n", (LONG)pdfh->le_ulCbDbHdrPage );
#endif
	
	DUMPPrintF( "         cbDbPage: %d\n", pdfh->le_cbPageSize );

	DBTIME dbtimeDirtied;
	dbtimeDirtied = pdfh->le_dbtimeDirtied;
	DUMPPrintF( "           dbtime: %I64u (0x%I64x)\n", dbtimeDirtied, dbtimeDirtied );

	switch ( pdfh->Dbstate() )
		{
		case JET_dbstateJustCreated:
		case JET_dbstateInconsistent:
		case JET_dbstateConsistent:
		case JET_dbstateBeingConverted:
		case JET_dbstateForceDetach:
			DUMPPrintF( "            State: %s\n", rgszDBState[pdfh->Dbstate()] );
			break;
		default:
			DUMPPrintF( "            State: %s\n", rgszDBState[0] );
			break;
		}

	DUMPPrintF(
			"     Log Required: %u-%u (0x%x-0x%x)\n",
			(ULONG) pdfh->le_lGenMinRequired,
			(ULONG) pdfh->le_lGenMaxRequired,
			(ULONG) pdfh->le_lGenMinRequired,
			(ULONG) pdfh->le_lGenMaxRequired );

	if ( attribDb == pdfh->le_attrib )
		DUMPPrintF( "   Streaming File: %s\n", pdfh->FSLVExists() ? "Yes" : "No" );

	DUMPPrintF( "         Shadowed: %s\n", pdfh->FShadowingDisabled() ? "No" : "Yes" );
	DUMPPrintF( "       Last Objid: %u\n", (ULONG) pdfh->le_objidLast );
	DBTIME dbtimeLastScrub;
	dbtimeLastScrub = pdfh->le_dbtimeLastScrub;
	DUMPPrintF( "     Scrub Dbtime: %I64u (0x%I64x)\n", dbtimeLastScrub, dbtimeLastScrub );
	DUMPPrintF( "       Scrub Date: " );
	tm = pdfh->logtimeScrub;
	DUMPPrintF( "%02d/%02d/%04d %02d:%02d:%02d\n",
		(short) tm.bMonth, (short) tm.bDay,	(short) tm.bYear + 1900,
		(short) tm.bHours, (short) tm.bMinutes, (short) tm.bSeconds);
	DUMPPrintF( "     Repair Count: %u\n", (ULONG) pdfh->le_ulRepairCount );	
	DUMPPrintF( "      Repair Date: " );
	tm = pdfh->logtimeRepair;
	DUMPPrintF( "%02d/%02d/%04d %02d:%02d:%02d\n",
		(short) tm.bMonth, (short) tm.bDay,	(short) tm.bYear + 1900,
		(short) tm.bHours, (short) tm.bMinutes, (short) tm.bSeconds);

	lgpos = pdfh->le_lgposConsistent;
	DUMPPrintF( "  Last Consistent: (0x%X,%X,%X)  ", lgpos.lGeneration, lgpos.isec, lgpos.ib );
		
	tm = pdfh->logtimeConsistent;
	DUMPPrintF( "%02d/%02d/%04d %02d:%02d:%02d\n",
		(short) tm.bMonth, (short) tm.bDay,	(short) tm.bYear + 1900,
		(short) tm.bHours, (short) tm.bMinutes, (short) tm.bSeconds);
		
	lgpos = pdfh->le_lgposAttach;
	DUMPPrintF( "      Last Attach: (0x%X,%X,%X)  ", lgpos.lGeneration, lgpos.isec, lgpos.ib );
		
	tm = pdfh->logtimeAttach;
	DUMPPrintF( "%02d/%02d/%04d %02d:%02d:%02d\n",
		(short) tm.bMonth, (short) tm.bDay,	(short) tm.bYear + 1900,
		(short) tm.bHours, (short) tm.bMinutes, (short) tm.bSeconds);
		
	lgpos = pdfh->le_lgposDetach;
	DUMPPrintF( "      Last Detach: (0x%X,%X,%X)  ", lgpos.lGeneration, lgpos.isec, lgpos.ib );
		
	tm = pdfh->logtimeDetach;
	DUMPPrintF( "%02d/%02d/%04d %02d:%02d:%02d\n",
		(short) tm.bMonth, (short) tm.bDay,	(short) tm.bYear + 1900,
		(short) tm.bHours, (short) tm.bMinutes, (short) tm.bSeconds);
		
	DUMPPrintF( "             Dbid: %d\n", (short) pdfh->le_dbid );
		
	DUMPPrintF( "    Log Signature: " );
	DUMPPrintSig( &pdfh->signLog );

	DUMPPrintF( "       OS Version: (%u.%u.%u SP %u)\n",
				(ULONG) pdfh->le_dwMajorVersion,
				(ULONG) pdfh->le_dwMinorVersion,
				(ULONG) pdfh->le_dwBuildNumber,
				(ULONG) pdfh->le_lSPNumber );

	DUMPPrintF( "\nPrevious Full Backup:\n" );
	DUMPPrintBkinfo( &pdfh->bkinfoFullPrev );
	
	DUMPPrintF( "\nCurrent Incremental Backup:\n" );
	DUMPPrintBkinfo( &pdfh->bkinfoIncPrev );
		
	DUMPPrintF( "\nCurrent Full Backup:\n" );
	DUMPPrintBkinfo( &pdfh->bkinfoFullCur );

	DUMPPrintF( "\nCurrent snapshot backup:\n" );
	DUMPPrintBkinfo( &pdfh->bkinfoSnapshotCur );	

	DUMPPrintF( "\n" );
	DUMPPrintF( "     cpgUpgrade55Format: %d\n", pdfh->le_cpgUpgrade55Format );
	DUMPPrintF( "    cpgUpgradeFreePages: %d\n", pdfh->le_cpgUpgradeFreePages );
	DUMPPrintF( "cpgUpgradeSpaceMapPages: %d\n", pdfh->le_cpgUpgradeSpaceMapPages );

#ifdef ELIMINATE_PATCH_FILE
	if ( pdfh->bkinfoFullCur.le_genLow && !pdfh->bkinfoFullCur.le_genHigh )
		{
		SIGNATURE signLog;
		SIGNATURE signDb;
		BKINFO bkinfoFullCur;

		PATCHHDR * ppatchHdr = (PATCHHDR *)pdfh;

		memcpy( &signLog, &pdfh->signLog, sizeof(signLog) );
		memcpy( &signDb, &pdfh->signDb, sizeof(signLog) );
		memcpy( &bkinfoFullCur, &pdfh->bkinfoFullCur, sizeof(BKINFO) );
		
		//	the patch file is always on the OS file-system
		Call ( pinst->m_plog->ErrLGBKReadAndCheckDBTrailer( pinst->m_pfsapi, szDatabase, (BYTE *)ppatchHdr) );

		if ( memcmp( &signDb, &ppatchHdr->signDb, sizeof( SIGNATURE ) ) != 0 ||
			 memcmp( &signLog, &ppatchHdr->signLog, sizeof( SIGNATURE ) ) != 0 ||
			 CmpLgpos( &bkinfoFullCur.le_lgposMark, &ppatchHdr->bkinfo.le_lgposMark ) != 0 )
			{
			Call ( ErrERRCheck( JET_errDatabasePatchFileMismatch ) );
			}
		
		DUMPPrintF( "\nPatch Current Full Backup:\n" );
		DUMPPrintBkinfo( &ppatchHdr->bkinfo );
		}
	
#endif // ELIMINATE_PATCH_FILE

HandleError:
	OSMemoryPageFree( pdfh );
	return err;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ese98\src\ese\dbutil.cxx ===
#include "std.hxx"
#include "_bt.hxx"
#include "_dump.hxx"

//	description of page_info table
const JET_COLUMNDEF rgcolumndefPageInfoTable[] =
	{
	//	Pgno
	{sizeof(JET_COLUMNDEF), 0, JET_coltypLong, 0, 0, 0, 0, 0, JET_bitColumnFixed | JET_bitColumnTTKey}, 

	//	consistency checked
	{sizeof(JET_COLUMNDEF), 0, JET_coltypBit, 0, 0, 0, 0, 0, JET_bitColumnFixed | JET_bitColumnNotNULL},
	
	//	Avail
	{sizeof(JET_COLUMNDEF), 0, JET_coltypBit, 0, 0, 0, 0, 0, JET_bitColumnFixed },

	//	Space free
	{sizeof(JET_COLUMNDEF), 0, JET_coltypLong, 0, 0, 0, 0, 0, JET_bitColumnFixed},

	//	Pgno left
	{sizeof(JET_COLUMNDEF), 0, JET_coltypLong, 0, 0, 0, 0, 0, JET_bitColumnFixed }, 

	//	Pgno right
	{sizeof(JET_COLUMNDEF), 0, JET_coltypLong, 0, 0, 0, 0, 0, JET_bitColumnFixed }
	};	

const INT icolumnidPageInfoPgno			= 0;
const INT icolumnidPageInfoFChecked		= 1;
const INT icolumnidPageInfoFAvail		= 2;
const INT icolumnidPageInfoFreeSpace	= 3;
const INT icolumnidPageInfoPgnoLeft		= 4;
const INT icolumnidPageInfoPgnoRight	= 5;

const INT ccolumndefPageInfoTable		= ( sizeof ( rgcolumndefPageInfoTable ) / sizeof(JET_COLUMNDEF) );
LOCAL JET_COLUMNID rgcolumnidPageInfoTable[ccolumndefPageInfoTable];


typedef ERR(*PFNDUMP)( PIB *ppib, FUCB *pfucbCatalog, VOID *pfnCallback, VOID *pvCallback );


LOCAL ERR ErrDBUTLDump( JET_SESID sesid, const JET_DBUTIL *pdbutil );


//	UNDONE: Need a better way of tracking total available space, especially if
//	space dumper must be online
CPG	cpgTotalAvailExt					= 0;


//  ================================================================
VOID DBUTLSprintHex(
	CHAR * const 		szDest,
	const BYTE * const 	rgbSrc,
	const INT 			cbSrc,
	const INT 			cbWidth,
	const INT 			cbChunk,
	const INT			cbAddress,
	const INT			cbStart)
//  ================================================================
	{
	static const CHAR rgchConvert[] =	{ '0','1','2','3','4','5','6','7','8','9','a','b','c','d','e','f' };
			
	const BYTE * const pbMax = rgbSrc + cbSrc;
	const INT cchHexWidth = ( cbWidth * 2 ) + (  cbWidth / cbChunk );

	const BYTE * pb = rgbSrc;
	CHAR * sz = szDest;
	while( pbMax != pb )
		{
		sz += ( 0 == cbAddress ) ? 0 : sprintf( sz, "%*.*lx    ", cbAddress, cbAddress, pb - rgbSrc + cbStart );
		CHAR * szHex	= sz;
		CHAR * szText	= sz + cchHexWidth;
		do
			{
			for( INT cb = 0; cbChunk > cb && pbMax != pb; ++cb, ++pb )
				{
				*szHex++ 	= rgchConvert[ *pb >> 4 ];
				*szHex++ 	= rgchConvert[ *pb & 0x0F ];
				*szText++ 	= isprint( *pb ) ? *pb : '.';
				}
			*szHex++ = ' ';
			} while( ( ( pb - rgbSrc ) % cbWidth ) && pbMax > pb );
		while( szHex != sz + cchHexWidth )
			{
			*szHex++ = ' ';
			}
		*szText++ = '\n';
		*szText = '\0';
		sz = szText;
		}
	}

/*
//  ================================================================
LOCAL VOID DBUTLSprintHex(
	CHAR * const 		szDest,
	const BYTE * const 	rgbSrc,
	const INT 			cbSrc,
	const INT 			cbWidth = 16,
	const INT 			cbChunk = 4 )
//  ================================================================
	{
	CHAR 	szFormat[256];
	CHAR *	szDestT = szDest;

	const BYTE * pb 			= rgbSrc;
	const BYTE * const pbMax	= rgbSrc + cbSrc;

	Assert( cbWidth % cbChunk == 0 );

	sprintf( szFormat, "%%8.8lx    %%-%d.%ds %%-%d.%ds\n",
		cbWidth * 2 + cbWidth / cbChunk,
		cbWidth * 2 + cbWidth / cbChunk,
		cbWidth,
		cbWidth );
		
	while( pb < pbMax )
		{
		const INT ibAddress = pb - rgbSrc;

		CHAR rgchData[256];
		CHAR rgchText[256];

		CHAR * szData = rgchData;
		CHAR * szText = rgchText;
		
		do
			{
			INT ib;
			for( ib = 0; ib < cbChunk && pb < pbMax; ++ib, ++pb )
				{
				szData += sprintf( szData, "%2.2x", *pb );
				szText += sprintf( szText, "%c", isprint( *pb ) ? *pb : '.' );
				}

			*szData++ = ' ';
			} while( pb < pbMax && ( (pb - rgbSrc) % cbWidth != 0 ) );
		*szData = '\0';
		*szText = '\0';
		
		szDestT += sprintf( szDestT, szFormat, ibAddress, rgchData, rgchText );
		}
	*szDestT = '\0';
	}
*/


//  ================================================================
LOCAL VOID DBUTLPrintfIntN( INT iValue, INT ichMax )
//  ================================================================
	{
	CHAR	rgchT[17]; /* C-runtime max bytes == 17 */
	INT		ichT;

	_itoa( iValue, rgchT, 10 );
	for ( ichT = 0; rgchT[ichT] != '\0' && ichT < 17; ichT++ )
		;
	if ( ichT > ichMax ) //lint !e661
		{
		for ( ichT = 0; ichT < ichMax; ichT++ )
			printf( "#" );
		}
	else
		{
		for ( ichT = ichMax - ichT; ichT > 0; ichT-- )
			printf( " " );
		for ( ichT = 0; rgchT[ichT] != '\0'; ichT++ )
			printf( "%c", rgchT[ichT] );
		}
	return;
	}

LOCAL VOID DBUTLPrintfStringN( CHAR *sz, INT ichMax )
	{
	INT		ich;

	for ( ich = 0; sz[ich] != '\0' && ich < ichMax; ich++ )
		printf( "%c", sz[ich] );
	for ( ; ich < ichMax; ich++ )
		printf( " " );
	printf( " " );
	return;
	}


//  ================================================================
LOCAL ERR ErrDBUTLRegExt( DBCCINFO *pdbccinfo, PGNO pgnoFirst, CPG cpg, BOOL fAvailT )
//  ================================================================
	{
	ERR 			err = JET_errSuccess;
	PGNO			pgno;
	PIB				*ppib = pdbccinfo->ppib;
	JET_SESID		sesid = (JET_SESID) pdbccinfo->ppib;
	JET_TABLEID		tableid = pdbccinfo->tableidPageInfo;
	BYTE			fAvail = (BYTE) fAvailT;
	
	Assert( tableid != JET_tableidNil );

	for ( pgno = pgnoFirst; pgno <= pgnoFirst + cpg - 1; pgno++ )
		{
		BOOL		fFound;
		BYTE		fChecked = fFalse;

		CallR( ErrIsamBeginTransaction( (JET_SESID) ppib, NO_GRBIT ) );

		/*	search for page in the table
		/**/
		CallS( ErrDispMakeKey( sesid, tableid, (BYTE *)&pgno, sizeof(pgno), JET_bitNewKey ) );
  		err = ErrDispSeek( sesid, tableid, JET_bitSeekEQ );
		if ( err < 0 && err != JET_errRecordNotFound )
			{
			Assert( fFalse );
			Call( err );
			}
		
		fFound = ( err == JET_errRecordNotFound ) ? fFalse : fTrue;
		if ( fFound )
			{
			ULONG	cbActual;
			BYTE	fAvailT2;
			
			/*	is this in availext
			/**/
			Call( ErrDispRetrieveColumn( sesid, 
				tableid, 
				rgcolumnidPageInfoTable[icolumnidPageInfoFAvail],
				(BYTE *)&fAvailT2,
				sizeof(fAvailT2),
				&cbActual,
				0,
				NULL ) );

			Assert( err == JET_wrnColumnNull || cbActual == sizeof(fAvailT2) );
			if ( err != JET_wrnColumnNull )
				{
				Assert( !fAvail || fAvailT2 );
				}

			/*	if fAvail is false, no changes to record
			/**/
			if ( !fAvail )
				goto Commit;

			/*	get fChecked [for setting it later]
			/**/
			Call( ErrDispRetrieveColumn( sesid, 
				tableid, 
				rgcolumnidPageInfoTable[icolumnidPageInfoFChecked],
				(BYTE *)&fChecked,
				sizeof(fChecked),
				&cbActual,
				0,
				NULL ) );

			Assert( cbActual == sizeof(fChecked) );

			Call( ErrDispPrepareUpdate( sesid, tableid, JET_prepReplaceNoLock ) );
			}
		else
			{
			Call( ErrDispPrepareUpdate( sesid, tableid, JET_prepInsert ) );

			/*	pgno
			/**/
			Call( ErrDispSetColumn( sesid, 
				tableid, 
				rgcolumnidPageInfoTable[icolumnidPageInfoPgno],
				(BYTE *) &pgno, 
				sizeof(pgno), 
				0, 
				NULL ) );
			}

		/*	set FChecked
		/**/
		Call( ErrDispSetColumn( sesid, 
			tableid, 
			rgcolumnidPageInfoTable[icolumnidPageInfoFChecked],
			(BYTE *)&fChecked, 
			sizeof(fChecked), 
			0, 
			NULL ) );

		/*	fAvail set if in AvailExt node
		/**/
		if ( fAvail )
			{
			Call( ErrDispSetColumn( sesid,
				tableid,
				rgcolumnidPageInfoTable[icolumnidPageInfoFAvail],
				(BYTE *) &fAvail, 
				sizeof(fAvail), 
				0, 
				NULL ) );
			}

		/*	update
		/**/
		Call( ErrDispUpdate( sesid, tableid, NULL, 0, NULL, 0 ) );								
		
		/*	commit
		/**/
Commit:
		Assert( ppib->level == 1 );
		Call( ErrIsamCommitTransaction( ( JET_SESID ) ppib, 0 ) );
		}

	return JET_errSuccess;
	
HandleError:
	CallS( ErrIsamRollback( (JET_SESID) ppib, JET_bitRollbackAll ) );

	return err;
	}


//  ****************************************************************
//	DBCC Info Routines
//  ****************************************************************


//  ================================================================
LOCAL ERR ErrDBUTLPrintPageDump( DBCCINFO *pdbccinfo )
//  ================================================================
	{
	ERR					err;
	const JET_SESID		sesid	= (JET_SESID) pdbccinfo->ppib;
	const JET_TABLEID	tableid = pdbccinfo->tableidPageInfo;
	ULONG				cbT;
		
	FUCBSetSequential( reinterpret_cast<FUCB *>( tableid ) );

	Assert( pdbccinfo->grbitOptions & JET_bitDBUtilOptionPageDump );

	//	move to first record
	err = ErrDispMove( sesid, tableid, JET_MoveFirst, 0 );
	if ( JET_errNoCurrentRecord != err )
		{
		err = JET_errSuccess;
		goto HandleError;
		}
	Call( err );
	
	printf( "\n\n ***************** PAGE DUMP *******************\n\n" );
	printf( "PGNO\tAVAIL\tCHECK\tLEFT\tRIGHT\tFREESPACE\n" );

	/*	while there are more records, print record
	/**/
	for( ;
		JET_errSuccess == err; 
		err = ErrDispMove( sesid, tableid, JET_MoveNext, 0 ) )
		{
		PGNO	pgnoThis	= pgnoNull;
		PGNO	pgnoLeft	= pgnoNull;
		PGNO	pgnoRight	= pgnoNull;
		BYTE 	fChecked	= fFalse;
		BYTE 	fAvail		= fFalse;
		ULONG	cbFreeSpace	= 0;
		
		//	pgno
	 	Call( ErrDispRetrieveColumn( sesid, 
			tableid, 
			rgcolumnidPageInfoTable[icolumnidPageInfoPgno],
			(BYTE *) &pgnoThis, 
			sizeof(pgnoThis), 
			&cbT,
 			0, 
		 	NULL ) );
		Assert( sizeof(pgnoThis) == cbT );
		
		//	FAvail
		Call( ErrDispRetrieveColumn( sesid, 
			tableid, 
			rgcolumnidPageInfoTable[icolumnidPageInfoFAvail],
			(BYTE *) &fAvail, 
			sizeof(fAvail), 
			&cbT,
			0, 
			NULL ) );
		Assert( sizeof(fAvail) == cbT || JET_wrnColumnNull == err );
			
		//	FChecked
		Call( ErrDispRetrieveColumn( sesid, 
			tableid, 
		 	rgcolumnidPageInfoTable[icolumnidPageInfoFChecked],
		 	(BYTE *)&fChecked, 
		 	sizeof(fChecked), 
		 	&cbT,
		 	0, 
			NULL ) );
		Assert( cbT == sizeof(fChecked) );
		Assert( fChecked || fAvail );
			
		//	left and right pgno
		Call( ErrDispRetrieveColumn( sesid, 
			tableid, 
			rgcolumnidPageInfoTable[icolumnidPageInfoPgnoLeft],
			(BYTE *)&pgnoLeft, 
			sizeof(pgnoLeft), 
			&cbT,
			0, 		
			NULL ) );
		Assert( cbT == sizeof(pgnoLeft) );
								
		Call( ErrDispRetrieveColumn( sesid, 
			 tableid, 
			 rgcolumnidPageInfoTable[icolumnidPageInfoPgnoRight],
			 (BYTE *) &pgnoRight, 
			 sizeof(pgnoRight), 
			 &cbT,
			 0, 
			 NULL ) );
		Assert( cbT == sizeof(pgnoRight) );									
																	
		//	free space
		Call( ErrDispRetrieveColumn( sesid,
			tableid,
			rgcolumnidPageInfoTable[icolumnidPageInfoFreeSpace],
			(BYTE *) &cbFreeSpace, 
			sizeof(cbFreeSpace), 
			&cbT,
			0, 
			NULL ) );
		Assert( cbT == sizeof(cbFreeSpace) );

		//	print
		printf( "%u\t%s\t%s", pgnoThis, fAvail ? "FAvail" : "", fChecked ? "FCheck" : "" );
		if( fChecked )
			{
			printf( "\t%u\t%u\t%u", pgnoLeft, pgnoRight, cbFreeSpace );
			}
		printf( "\n" );
		}

	//	polymorph expected error to success
	if ( JET_errNoCurrentRecord == err )
		err = JET_errSuccess;

HandleError:
	return err;
	}


//  ================================================================
VOID DBUTLDumpRec( const VOID * const pv, const INT cb, CPRINTF * pcprintf, const INT cbWidth )
//  ================================================================
	{
	CHAR szBuf[g_cbPageMax];
	
	//  dump the columns of the record
	const REC * const prec = reinterpret_cast<const REC *>( pv );

	FID fid;
	
	const FID fidFixedFirst = fidFixedLeast;
	const FID fidFixedLast  = prec->FidFixedLastInRec();
	const INT cColumnsFixed = max( 0, fidFixedLast - fidFixedFirst + 1 );
	(*pcprintf)( "   Fixed Columns:  %d\n", cColumnsFixed );
	(*pcprintf)( "=================\n" );
	for( fid = fidFixedFirst; fid <= fidFixedLast; ++fid )
		{
		const UINT	ifid 					= fid - fidFixedLeast;
		const BYTE	* const prgbitNullity 	= prec->PbFixedNullBitMap() + ifid/8;

		(*pcprintf)( "%d:  %s\n", fid, FFixedNullBit( prgbitNullity, ifid ) ? "NULL" : "" );
		}		

	(*pcprintf)( "\n" );
	
	const FID fidVariableFirst = fidVarLeast ;
	const FID fidVariableLast  = prec->FidVarLastInRec();
	const INT cColumnsVariable = max( 0, fidVariableLast - fidVariableFirst + 1 );
	(*pcprintf)( "Variable Columns:  %d\n", cColumnsVariable );
	(*pcprintf)( "=================\n" );

	const UnalignedLittleEndian<REC::VAROFFSET> * const pibVarOffs		= ( const UnalignedLittleEndian<REC::VAROFFSET> * const )prec->PibVarOffsets();
	for( fid = fidVariableFirst; fid <= fidVariableLast; ++fid )
		{
		const UINT				ifid			= fid - fidVarLeast;
		const REC::VAROFFSET	ibStartOfColumn	= prec->IbVarOffsetStart( fid );
		const REC::VAROFFSET	ibEndOfColumn	= IbVarOffset( pibVarOffs[ifid] );

		(*pcprintf)( "%d:  ", fid );
		if ( FVarNullBit( pibVarOffs[ifid] ) )
			{
			(*pcprintf)( "NULL\n" );
			}
		else
			{
			const VOID * const pvColumn = prec->PbVarData() + ibStartOfColumn;
			const INT cbColumn			= ibEndOfColumn - ibStartOfColumn;
			(*pcprintf)( "%d bytes\n", cbColumn );
			DBUTLSprintHex( szBuf, (BYTE *)pvColumn, cbColumn, cbWidth );
			(*pcprintf)( "%s\n", szBuf );	
			}
		}		

	(*pcprintf)( "\n" );

	(*pcprintf)( "  Tagged Columns:\n" );
	(*pcprintf)( "=================\n" );

	DATA	dataRec;
	dataRec.SetPv( (VOID *)pv );
	dataRec.SetCb( cb );

	if ( !TAGFIELDS::FIsValidTagfields( dataRec, pcprintf ) )
		{
		(*pcprintf)( "Tagged column corruption detected.\n" );
		}

	(*pcprintf)( "TAGFIELDS array begins at offset 0x%x from start of record.\n\n", prec->PbTaggedData() - (BYTE *)prec );

	TAGFIELDS_ITERATOR ti( dataRec );

	ti.MoveBeforeFirst();

	while( JET_errSuccess == ti.ErrMoveNext() )
		{
		//	we are now on an individual column

		const CHAR * szComma = " ";

		(*pcprintf)( "%d:", ti.Fid() );
		if( ti.FNull() )
			{
			(*pcprintf)( "%sNull ", szComma );
			szComma = ", ";
			}
		if( ti.FDerived() )
			{
			(*pcprintf)( "%sDerived", szComma );
			szComma = ", ";
			}
		if( ti.FSLV() )
			{
			(*pcprintf)( "%sSLV", szComma );
			szComma = ", ";
			}
		if( ti.FLV() )
			{
			(*pcprintf)( "%sLong-Value", szComma );
			szComma = ", ";
			}
		(*pcprintf)( "\r\n" );

		ti.TagfldIterator().MoveBeforeFirst();

		int itag = 1;
		
		while( JET_errSuccess == ti.TagfldIterator().ErrMoveNext() )
			{
			const BOOL	fSeparated	= ti.TagfldIterator().FSeparated();

			(*pcprintf)( ">> itag %d: %d bytes: ", itag, ti.TagfldIterator().CbData() );
			if ( fSeparated )
				{
				(*pcprintf)( "separated" );
				}
			(*pcprintf)( "\r\n" );

			if ( ti.FSLV() && !fSeparated )
				{
				//	UNDONE: use CSLVInfo iterator instead of this manual hack
				CSLVInfo::HEADER*	pslvinfoHdr		= (CSLVInfo::HEADER *)( ti.TagfldIterator().PbData() );
				CSLVInfo::_RUN*		prun			= (CSLVInfo::_RUN *)( pslvinfoHdr + 1 );
				QWORD				ibVirtualPrev	= 0;

				(*pcprintf)( "SLV size: 0x%I64x bytes, Runs: %I64d, Recoverable: %s\r\n",
									pslvinfoHdr->cbSize,
									pslvinfoHdr->cRun,
									( pslvinfoHdr->fDataRecoverable ? "YES" : "NO" ) );

				for ( ULONG irun = 1; irun <= pslvinfoHdr->cRun; irun++ )
					{
					const PGNO	pgnoStart	= PGNO( ( prun->ibLogical / g_cbPage ) - cpgDBReserved + 1 );
					const PGNO	pgnoEnd		= PGNO( pgnoStart + ( ( prun->ibVirtualNext - ibVirtualPrev ) / g_cbPage ) - 1 );
					(*pcprintf)( "    Run %d: ibVirtualNext=0x%I64x, ibLogical=0x%I64x ",
									irun,
									prun->ibVirtualNext,
									prun->ibLogical );
					Assert( pgnoEnd >= pgnoStart );
					if ( pgnoStart == pgnoEnd )
						(*pcprintf)( "(page %d)\r\n", pgnoStart );
					else
						(*pcprintf)( "(pages %d-%d)\r\n", pgnoStart, pgnoEnd );

					ibVirtualPrev = prun->ibVirtualNext;
					prun++;
					}

				(*pcprintf)( "\r\n" );
				}
			else
				{
				szBuf[0] = 0;
				DBUTLSprintHex(
					szBuf,
					ti.TagfldIterator().PbData(),
					min( ti.TagfldIterator().CbData(), 240 ),	//	only print 240b of data to ensure we don't overrun printf buffer
					cbWidth );
				(*pcprintf)( "%s%s\r\n", szBuf, ( ti.TagfldIterator().CbData() > 240 ? "...\r\n" : "" ) );
				}

			++itag;
			}
		}

/*
	if ( TAGFIELDS::FIsValidTagfields( dataRec, pcprintf ) )
		{
		TAGFIELDS	tagfields( dataRec );
		tagfields.Dump( pcprintf, szBuf, cbWidth );
		}
	else
		{
		(*pcprintf)( "Tagged column corruption detected.\n" );
		}
*/

	(*pcprintf)( "\n" );
	}


#ifdef DEBUG


//  ================================================================
LOCAL ERR ErrDBUTLISzToData( const CHAR * const sz, DATA * const pdata )
//  ================================================================
	{
	DATA& data = *pdata;
	
	const LONG cch = (LONG)strlen( sz );
	if( cch % 2 == 1
		|| cch <= 0 )
		{
		//  no data to insert
		return ErrERRCheck( JET_errInvalidParameter );
		}
	const LONG cbInsert = cch / 2;
	BYTE * pbInsert = (BYTE *)PvOSMemoryHeapAlloc( cbInsert );
	if( NULL == pbInsert )
		{
		return ErrERRCheck( JET_errOutOfMemory );
		}

	for( INT ibInsert = 0; ibInsert < cbInsert; ++ibInsert )
		{
		CHAR szConvert[3];
		szConvert[0] = sz[ibInsert * 2 ];
		szConvert[1] = sz[ibInsert * 2 + 1];
		szConvert[2] = 0;
		CHAR * pchEnd;
		const ULONG lConvert = strtoul( szConvert, &pchEnd, 16 );
		if( lConvert > 0xff 
			|| 0 != *pchEnd )
			{
			OSMemoryHeapFree( pbInsert );
			return ErrERRCheck( JET_errInvalidParameter );
			}
		pbInsert[ibInsert] = (BYTE)lConvert;
		}
			
	data.SetCb( cbInsert );
	data.SetPv( pbInsert );

	return JET_errSuccess;
	}


//  ================================================================
LOCAL ERR ErrDBUTLIInsertNode(
	PIB * const ppib,
	const IFMP ifmp,
	const PGNO pgno,
	const LONG iline,
	const DATA& data,
	CPRINTF * const pcprintf )
//  ================================================================
	{
	ERR err = JET_errSuccess;

	CPAGE cpage;	
	CallR( cpage.ErrGetReadPage( ppib, ifmp, pgno, bflfNoTouch ) );
	Call( cpage.ErrUpgradeReadLatchToWriteLatch() );

	cpage.Dirty( bfdfFilthy );

	(*pcprintf)( "inserting data at %d:%d\r\n", pgno, iline );
	cpage.Insert( iline, &data, 1, 0 );

HandleError:
	cpage.ReleaseWriteLatch( fTrue );

	return err;
	}


//  ================================================================
LOCAL ERR ErrDBUTLIReplaceNode(
	PIB * const ppib,
	const IFMP ifmp,
	const PGNO pgno,
	const LONG iline,
	const DATA& data,
	CPRINTF * const pcprintf )
//  ================================================================
	{
	ERR err = JET_errSuccess;

	CPAGE cpage;	
	CallR( cpage.ErrGetReadPage( ppib, ifmp, pgno, bflfNoTouch ) );
	Call( cpage.ErrUpgradeReadLatchToWriteLatch() );

	cpage.Dirty( bfdfFilthy );

	(*pcprintf)( "replacing data at %d:%d\r\n", pgno, iline );
	cpage.Replace( iline, &data, 1, 0 );

HandleError:
	cpage.ReleaseWriteLatch( fTrue );

	return err;
	}


//  ================================================================
LOCAL ERR ErrDBUTLISetNodeFlags(
	PIB * const ppib,
	const IFMP ifmp,
	const PGNO pgno,
	const LONG iline,
	const INT fFlags,
	CPRINTF * const pcprintf )
//  ================================================================
	{
	ERR err = JET_errSuccess;

	CPAGE cpage;	
	CallR( cpage.ErrGetReadPage( ppib, ifmp, pgno, bflfNoTouch ) );
	Call( cpage.ErrUpgradeReadLatchToWriteLatch() );

	cpage.Dirty( bfdfFilthy );

	(*pcprintf)( "settings flags at %d:%d to 0x%x\r\n", pgno, iline, fFlags );
	cpage.ReplaceFlags( iline, fFlags );

HandleError:
	cpage.ReleaseWriteLatch( fTrue );

	return err;
	}


//  ================================================================
LOCAL ERR ErrDBUTLIDeleteNode(
	PIB * const ppib,
	const IFMP ifmp,
	const PGNO pgno,
	const LONG iline,
	CPRINTF * const pcprintf )
//  ================================================================
	{
	ERR err = JET_errSuccess;

	CPAGE cpage;	
	CallR( cpage.ErrGetReadPage( ppib, ifmp, pgno, bflfNoTouch ) );
	Call( cpage.ErrUpgradeReadLatchToWriteLatch() );

	cpage.Dirty( bfdfFilthy );

	(*pcprintf)( "deleting %d:%d\r\n", pgno, iline );
	cpage.Delete( iline );

HandleError:
	cpage.ReleaseWriteLatch( fTrue );

	return err;
	}


//  ================================================================
LOCAL ERR ErrDBUTLISetExternalHeader(
	PIB * const ppib,
	const IFMP ifmp,
	const PGNO pgno,
	const DATA& data,
	CPRINTF * const pcprintf )
//  ================================================================
	{
	ERR err = JET_errSuccess;

	CPAGE cpage;	
	CallR( cpage.ErrGetReadPage( ppib, ifmp, pgno, bflfNoTouch ) );
	Call( cpage.ErrUpgradeReadLatchToWriteLatch() );

	cpage.Dirty( bfdfFilthy );

	(*pcprintf)( "setting external header of %d\r\n", pgno );
	cpage.SetExternalHeader( &data, 1, 0 );

HandleError:
	cpage.ReleaseWriteLatch( fTrue );

	return err;
	}


//  ================================================================
LOCAL ERR ErrDBUTLISetPgnoNext( 
	PIB * const ppib,
	const IFMP ifmp,
	const PGNO pgno,
	const PGNO pgnoNext,
	CPRINTF * const pcprintf )
//  ================================================================
	{
	ERR err = JET_errSuccess;

	CPAGE cpage;	
	CallR( cpage.ErrGetReadPage( ppib, ifmp, pgno, bflfNoTouch ) );
	Call( cpage.ErrUpgradeReadLatchToWriteLatch() );

	cpage.Dirty( bfdfFilthy );

	(*pcprintf)( "setting pgnoNext of %d to %d (was %d)\r\n", pgno, pgnoNext, cpage.PgnoNext() );
	cpage.SetPgnoNext( pgnoNext );

HandleError:
	cpage.ReleaseWriteLatch( fTrue );

	return err;
	}


//  ================================================================
LOCAL ERR ErrDBUTLISetPgnoPrev( 
	PIB * const ppib,
	const IFMP ifmp,
	const PGNO pgno,
	const PGNO pgnoPrev,
	CPRINTF * const pcprintf )
//  ================================================================
	{
	ERR err = JET_errSuccess;

	CPAGE cpage;	
	CallR( cpage.ErrGetReadPage( ppib, ifmp, pgno, bflfNoTouch ) );
	Call( cpage.ErrUpgradeReadLatchToWriteLatch() );

	cpage.Dirty( bfdfFilthy );

	(*pcprintf)( "setting pgnoPrev of %d to %d (was %d)\r\n", pgno, pgnoPrev, cpage.PgnoPrev() );
	cpage.SetPgnoPrev( pgnoPrev );

HandleError:
	cpage.ReleaseWriteLatch( fTrue );

	return err;
	}


//  ================================================================
LOCAL ERR ErrDBUTLISetPageFlags( 
	PIB * const ppib,
	const IFMP ifmp,
	const PGNO pgno,
	const ULONG fFlags,
	CPRINTF * const pcprintf )
//  ================================================================
	{
	ERR err = JET_errSuccess;

	CPAGE cpage;	
	CallR( cpage.ErrGetReadPage( ppib, ifmp, pgno, bflfNoTouch ) );
	Call( cpage.ErrUpgradeReadLatchToWriteLatch() );

	cpage.Dirty( bfdfFilthy );

	(*pcprintf)( "setting flags of %d to 0x%x (was 0x%x)\r\n", pgno, fFlags, cpage.FFlags() );
	cpage.SetFlags( fFlags );

HandleError:
	cpage.ReleaseWriteLatch( fTrue );

	return err;
	}


//  ================================================================
LOCAL ERR ErrDBUTLMungeDatabase(
	PIB * const ppib,
	const IFMP ifmp,
	const CHAR * const rgszCommand[],
	const INT cszCommand,
	CPRINTF * const pcprintf )
//  ================================================================
	{
	ERR err = JET_errSuccess;

	if( 3 == cszCommand
		&& _stricmp( rgszCommand[0], "insert" ) == 0 )
		{
		PGNO	pgno;
		LONG	iline;
		DATA	data;
		
		if( 2 != sscanf( rgszCommand[1], "%d:%d", &pgno, &iline ) )
			{
			//  we didn't get all the arguments we need
			return ErrERRCheck( JET_errInvalidParameter );
			}
			
		CallR( ErrDBUTLISzToData( rgszCommand[2], &data ) );
		err = ErrDBUTLIInsertNode( ppib, ifmp, pgno, iline, data, pcprintf );		
		OSMemoryHeapFree( data.Pv() );
		return err;
		}
	if( 3 == cszCommand
		&& _stricmp( rgszCommand[0], "replace" ) == 0 )
		{
		PGNO	pgno;
		LONG	iline;
		DATA	data;
		
		if( 2 != sscanf( rgszCommand[1], "%d:%d", &pgno, &iline ) )
			{
			//  we didn't get all the arguments we need
			return ErrERRCheck( JET_errInvalidParameter );
			}
			
		CallR( ErrDBUTLISzToData( rgszCommand[2], &data ) );
		err = ErrDBUTLIReplaceNode( ppib, ifmp, pgno, iline, data, pcprintf );		
		OSMemoryHeapFree( data.Pv() );
		
		return err;
		}
	if( 3 == cszCommand
		&& _stricmp( rgszCommand[0], "setflags" ) == 0 )
		{
		PGNO	pgno;
		LONG	iline;		
		if( 2 != sscanf( rgszCommand[1], "%d:%d", &pgno, &iline ) )
			{
			//  we didn't get all the arguments we need
			return ErrERRCheck( JET_errInvalidParameter );
			}

		const ULONG fFlags = strtoul( rgszCommand[2], NULL, 0 );
		err = ErrDBUTLISetNodeFlags( ppib, ifmp, pgno, iline, fFlags, pcprintf );		
		
		return err;
		}
	else if( 2 == cszCommand
		&& _stricmp( rgszCommand[0], "delete" ) == 0 )
		{
		PGNO	pgno;
		LONG	iline;
		
		if( 2 != sscanf( rgszCommand[1], "%d:%d", &pgno, &iline ) )
			{
			//  we didn't get all the arguments we need
			return ErrERRCheck( JET_errInvalidParameter );
			}
			
		err = ErrDBUTLIDeleteNode( ppib, ifmp, pgno, iline, pcprintf );
		return err;
		}
	if( 3 == cszCommand
		&& _stricmp( rgszCommand[0], "exthdr" ) == 0 )
		{		
		char * pchEnd;
		const PGNO pgno = strtoul( rgszCommand[1], &pchEnd, 0 );
		if( pgnoNull == pgno
			|| 0 != *pchEnd )
			{
			return ErrERRCheck( JET_errInvalidParameter );
			}
			
		DATA	data;
		CallR( ErrDBUTLISzToData( rgszCommand[2], &data ) );
		err = ErrDBUTLISetExternalHeader( ppib, ifmp, pgno, data, pcprintf );		
		OSMemoryHeapFree( data.Pv() );
		
		return err;
		}
	if( 3 == cszCommand
		&& _stricmp( rgszCommand[0], "pgnonext" ) == 0 )
		{
		char * pchEnd;
		const PGNO pgno = strtoul( rgszCommand[1], &pchEnd, 0 );
		if( pgnoNull == pgno
			|| 0 != *pchEnd )
			{
			return ErrERRCheck( JET_errInvalidParameter );
			}
		const PGNO pgnoNext = strtoul( rgszCommand[2], NULL, 0 );
		if( 0 != *pchEnd )
			{
			return ErrERRCheck( JET_errInvalidParameter );
			}
		err = ErrDBUTLISetPgnoNext( ppib, ifmp, pgno, pgnoNext, pcprintf );				
		return err;
		}
	if( 3 == cszCommand
		&& _stricmp( rgszCommand[0], "pgnoprev" ) == 0 )
		{
		char * pchEnd;
		const PGNO pgno = strtoul( rgszCommand[1], &pchEnd, 0 );
		if( pgnoNull == pgno
			|| 0 != *pchEnd )
			{
			return ErrERRCheck( JET_errInvalidParameter );
			}
		const PGNO pgnoPrev = strtoul( rgszCommand[2], NULL, 0 );
		if( 0 != *pchEnd )
			{
			return ErrERRCheck( JET_errInvalidParameter );
			}
		err = ErrDBUTLISetPgnoPrev( ppib, ifmp, pgno, pgnoPrev, pcprintf );				
		return err;
		}
	if( 3 == cszCommand
		&& _stricmp( rgszCommand[0], "pageflags" ) == 0 )
		{
		char * pchEnd;
		const PGNO pgno = strtoul( rgszCommand[1], &pchEnd, 0 );
		if( pgnoNull == pgno
			|| 0 != *pchEnd )
			{
			return ErrERRCheck( JET_errInvalidParameter );
			}
		const ULONG fFlags = strtoul( rgszCommand[2], NULL, 0 );
		if( 0 != *pchEnd )
			{
			return ErrERRCheck( JET_errInvalidParameter );
			}
		err = ErrDBUTLISetPageFlags( ppib, ifmp, pgno, fFlags, pcprintf );				
		return err;
		}
	if( 1 == cszCommand
		&& _stricmp( rgszCommand[0], "help" ) == 0 )
		{
		(*pcprintf)( "insert <pgno>:<iline> <data>  -  insert a node\r\n" );
		(*pcprintf)( "replace <pgno>:<iline> <data>  -  replace a node\r\n" );
		(*pcprintf)( "delete <pgno>:<iline>  -  delete a node\r\n" );
		(*pcprintf)( "setflags <pgno>:<iline> <flags>  -  set flags on a node\r\n" );
		(*pcprintf)( "exthdr <pgno> <data>  -  set external header\r\n" );
		(*pcprintf)( "pgnonext <pgno> <pgnonext>  -  set pgnonext on a page\r\n" );
		(*pcprintf)( "pgnoprev <pgno> <pgnoprev>  -  set pgnoprev on a page\r\n" );
		(*pcprintf)( "pageflags <pgno> <flags>  -  set flags on a page\r\n" );
		}
	else
		{
		(*pcprintf)( "unknown command \"%s\"\r\n", rgszCommand[0] );
		return ErrERRCheck( JET_errInvalidParameter );
		}

	return err;
	}


//  ================================================================
LOCAL ERR ErrDBUTLDumpOneColumn( PIB * ppib, FUCB * pfucbCatalog, VOID * pfnCallback, VOID * pvCallback )
//  ================================================================
	{
	JET_RETRIEVECOLUMN	rgretrievecolumn[10];
	COLUMNDEF			columndef;
	ERR					err				= JET_errSuccess;
	INT					iretrievecolumn	= 0;

	memset( rgretrievecolumn, 0, sizeof( rgretrievecolumn ) );
	memset( &columndef, 0, sizeof( columndef ) );

	rgretrievecolumn[iretrievecolumn].columnid 		= fidMSO_Name;
	rgretrievecolumn[iretrievecolumn].pvData 		= (BYTE *)columndef.szName;
	rgretrievecolumn[iretrievecolumn].cbData		= sizeof( columndef.szName );
	rgretrievecolumn[iretrievecolumn].itagSequence	= 1;
	++iretrievecolumn;	

	rgretrievecolumn[iretrievecolumn].columnid 		= fidMSO_Id;
	rgretrievecolumn[iretrievecolumn].pvData 		= (BYTE *)&( columndef.columnid );
	rgretrievecolumn[iretrievecolumn].cbData		= sizeof( columndef.columnid );
	rgretrievecolumn[iretrievecolumn].itagSequence	= 1;
	++iretrievecolumn;	

	rgretrievecolumn[iretrievecolumn].columnid 		= fidMSO_Coltyp;
	rgretrievecolumn[iretrievecolumn].pvData 		= (BYTE *)&( columndef.coltyp );
	rgretrievecolumn[iretrievecolumn].cbData		= sizeof( columndef.coltyp );
	rgretrievecolumn[iretrievecolumn].itagSequence	= 1;
	++iretrievecolumn;	

	rgretrievecolumn[iretrievecolumn].columnid 		= fidMSO_Localization;
	rgretrievecolumn[iretrievecolumn].pvData 		= (BYTE *)&( columndef.cp );
	rgretrievecolumn[iretrievecolumn].cbData		= sizeof( columndef.cp );
	rgretrievecolumn[iretrievecolumn].itagSequence	= 1;
	++iretrievecolumn;	

	rgretrievecolumn[iretrievecolumn].columnid 		= fidMSO_Flags;
	rgretrievecolumn[iretrievecolumn].pvData 		= (BYTE *)&( columndef.fFlags );
	rgretrievecolumn[iretrievecolumn].cbData		= sizeof( columndef.fFlags );
	rgretrievecolumn[iretrievecolumn].itagSequence	= 1;
	++iretrievecolumn;	

	rgretrievecolumn[iretrievecolumn].columnid 		= fidMSO_SpaceUsage;
	rgretrievecolumn[iretrievecolumn].pvData 		= (BYTE *)&( columndef.cbLength );
	rgretrievecolumn[iretrievecolumn].cbData		= sizeof( columndef.cbLength );
	rgretrievecolumn[iretrievecolumn].itagSequence	= 1;
	++iretrievecolumn;	

	rgretrievecolumn[iretrievecolumn].columnid 		= fidMSO_RecordOffset;
	rgretrievecolumn[iretrievecolumn].pvData 		= (BYTE *)&( columndef.ibRecordOffset );
	rgretrievecolumn[iretrievecolumn].cbData		= sizeof( columndef.ibRecordOffset );
	rgretrievecolumn[iretrievecolumn].itagSequence	= 1;
	++iretrievecolumn;	

	rgretrievecolumn[iretrievecolumn].columnid 		= fidMSO_Callback;
	rgretrievecolumn[iretrievecolumn].pvData 		= (BYTE *)&( columndef.szCallback );
	rgretrievecolumn[iretrievecolumn].cbData		= sizeof( columndef.szCallback );
	rgretrievecolumn[iretrievecolumn].itagSequence	= 1;
	++iretrievecolumn;	

	rgretrievecolumn[iretrievecolumn].columnid 		= fidMSO_CallbackData;
	rgretrievecolumn[iretrievecolumn].pvData 		= (BYTE *)&( columndef.rgbCallbackData );
	rgretrievecolumn[iretrievecolumn].cbData		= sizeof( columndef.rgbCallbackData );
	rgretrievecolumn[iretrievecolumn].itagSequence	= 1;
	++iretrievecolumn;	

	rgretrievecolumn[iretrievecolumn].columnid 		= fidMSO_DefaultValue;
	rgretrievecolumn[iretrievecolumn].pvData 		= (BYTE *)columndef.rgbDefaultValue;
	rgretrievecolumn[iretrievecolumn].cbData		= sizeof( columndef.rgbDefaultValue );
	rgretrievecolumn[iretrievecolumn].itagSequence	= 1;
	++iretrievecolumn;	

	CallR( ErrIsamRetrieveColumns(
				(JET_SESID)ppib,
				(JET_TABLEID)pfucbCatalog,
				rgretrievecolumn,
				iretrievecolumn ) );

	// WARNING: if the order of rgretrievecolumn initialization is changed above this must change too
	columndef.cbDefaultValue 	= rgretrievecolumn[iretrievecolumn-1].cbActual;
	columndef.cbCallbackData 	= rgretrievecolumn[iretrievecolumn-2].cbActual;

	columndef.fFixed 			= !!FFixedFid( FidOfColumnid( columndef.columnid ) );
	columndef.fVariable 		= !!FVarFid( FidOfColumnid( columndef.columnid ) );
	columndef.fTagged			= !!FTaggedFid( FidOfColumnid( columndef.columnid ) );

	const FIELDFLAG	ffield		= FIELDFLAG( columndef.fFlags );
	columndef.fVersion 			= !!FFIELDVersion( ffield );
	columndef.fNotNull 			= !!FFIELDNotNull( ffield );
	columndef.fMultiValue 		= !!FFIELDMultivalued( ffield );
	columndef.fAutoIncrement	= !!FFIELDAutoincrement( ffield );
	columndef.fDefaultValue		= !!FFIELDDefault( ffield );
	columndef.fEscrowUpdate		= !!FFIELDEscrowUpdate( ffield );
	columndef.fVersioned		= !!FFIELDVersioned( ffield );
	columndef.fDeleted			= !!FFIELDDeleted( ffield );
	columndef.fFinalize			= !!FFIELDFinalize( ffield );
	columndef.fUserDefinedDefault		= !!FFIELDUserDefinedDefault( ffield );
	columndef.fTemplateColumnESE98		= !!FFIELDTemplateColumnESE98( ffield );
	columndef.fPrimaryIndexPlaceholder	= !!FFIELDPrimaryIndexPlaceholder( ffield );

	PFNCOLUMN const	pfncolumn	= (PFNCOLUMN)pfnCallback;
	(*pfncolumn)( &columndef, pvCallback );
				
	return err;
	}


//  ================================================================
LOCAL ERR ErrDBUTLDumpOneCallback( PIB * ppib, FUCB * pfucbCatalog, VOID * pfnCallback, VOID * pvCallback )
//  ================================================================
	{
	JET_RETRIEVECOLUMN	rgretrievecolumn[3];
	CALLBACKDEF			callbackdef;
	ERR					err				= JET_errSuccess;
	INT					iretrievecolumn	= 0;

	memset( rgretrievecolumn, 0, sizeof( rgretrievecolumn ) );
	memset( &callbackdef, 0, sizeof( callbackdef ) );

	rgretrievecolumn[iretrievecolumn].columnid 		= fidMSO_Name;
	rgretrievecolumn[iretrievecolumn].pvData 		= (BYTE *)callbackdef.szName;
	rgretrievecolumn[iretrievecolumn].cbData		= sizeof( callbackdef.szName );
	rgretrievecolumn[iretrievecolumn].itagSequence	= 1;
	++iretrievecolumn;	

	rgretrievecolumn[iretrievecolumn].columnid 		= fidMSO_Flags;
	rgretrievecolumn[iretrievecolumn].pvData 		= (BYTE *)&( callbackdef.cbtyp );
	rgretrievecolumn[iretrievecolumn].cbData		= sizeof( callbackdef.cbtyp );
	rgretrievecolumn[iretrievecolumn].itagSequence	= 1;
	++iretrievecolumn;	

	rgretrievecolumn[iretrievecolumn].columnid 		= fidMSO_Callback;
	rgretrievecolumn[iretrievecolumn].pvData 		= (BYTE *)callbackdef.szCallback;
	rgretrievecolumn[iretrievecolumn].cbData		= sizeof( callbackdef.szCallback );
	rgretrievecolumn[iretrievecolumn].itagSequence	= 1;
	++iretrievecolumn;	

	CallR( ErrIsamRetrieveColumns(
				(JET_SESID)ppib,
				(JET_TABLEID)pfucbCatalog,
				rgretrievecolumn,
				iretrievecolumn ) );

	PFNCALLBACKFN const	pfncallback	= (PFNCALLBACKFN)pfnCallback;
	(*pfncallback)( &callbackdef, pvCallback );
				
	return err;
	}


//  ================================================================
LOCAL ERR ErrDBUTLDumpPage( PIB * ppib, IFMP ifmp, PGNO pgno, PFNPAGE pfnpage, VOID * pvCallback )
//  ================================================================
	{
	ERR	err = JET_errSuccess;
	CSR	csr;	
	Call( csr.ErrGetReadPage( ppib, ifmp, pgno, bflfNoTouch ) );

	PAGEDEF	pagedef;

	pagedef.dbtime		= csr.Cpage().Dbtime();
	pagedef.pgno		= csr.Cpage().Pgno();
	pagedef.objidFDP	= csr.Cpage().ObjidFDP();
	pagedef.pgnoNext	= csr.Cpage().PgnoNext();
	pagedef.pgnoPrev	= csr.Cpage().PgnoPrev();
	
	pagedef.pbRawPage	= reinterpret_cast<BYTE *>( csr.Cpage().PvBuffer() );

	pagedef.cbFree		= csr.Cpage().CbFree();
	pagedef.cbUncommittedFree	= csr.Cpage().CbUncommittedFree();
	pagedef.clines		= SHORT( csr.Cpage().Clines() );

	pagedef.fFlags			= csr.Cpage().FFlags();

	pagedef.fLeafPage		= !!csr.Cpage().FLeafPage();
	pagedef.fInvisibleSons	= !!csr.Cpage().FInvisibleSons();
	pagedef.fRootPage		= !!csr.Cpage().FRootPage();
	pagedef.fPrimaryPage	= !!csr.Cpage().FPrimaryPage();
	pagedef.fParentOfLeaf	= !!csr.Cpage().FParentOfLeaf();

	if( pagedef.fInvisibleSons )
		{
		Assert( !pagedef.fLeafPage );
		
		INT iline;
		for( iline = 0; iline < pagedef.clines; iline++ )
			{
			extern VOID NDIGetKeydataflags( const CPAGE& cpage, INT iline, KEYDATAFLAGS * pkdf );
			KEYDATAFLAGS	kdf;
			
			csr.SetILine( iline );
			NDIGetKeydataflags( csr.Cpage(), csr.ILine(), &kdf );

			Assert( kdf.data.Cb() == sizeof( PGNO ) );
			pagedef.rgpgnoChildren[iline] = *((UnalignedLittleEndian< PGNO > *)kdf.data.Pv() );
			}
		pagedef.rgpgnoChildren[pagedef.clines] = pgnoNull;
		}
	else
		{
		Assert( pagedef.fLeafPage );
		}

	(*pfnpage)( &pagedef, pvCallback );

HandleError:
	csr.ReleasePage();
	return err;
	}

//  ================================================================
LOCAL INT PrintCallback( const CALLBACKDEF * pcallbackdef, void * )
//  ================================================================
	{
	//  this will only compile if the signatures match
	PFNCALLBACKFN pfncallback = PrintCallback;
	
	char szCbtyp[255];
	szCbtyp[0] = 0;

	if( JET_cbtypNull == pcallbackdef->cbtyp )
		{
		strcat( szCbtyp, "NULL" );
		}
	if(	pcallbackdef->cbtyp & JET_cbtypFinalize )
		{
		strcat( szCbtyp, "Finalize|" );
		}
	if(	pcallbackdef->cbtyp & JET_cbtypBeforeInsert )
		{
		strcat( szCbtyp, "BeforeInsert|" );
		}
	if(	pcallbackdef->cbtyp & JET_cbtypAfterInsert )
		{
		strcat( szCbtyp, "AfterInsert|" );
		}
	if(	pcallbackdef->cbtyp & JET_cbtypBeforeReplace )
		{
		strcat( szCbtyp, "BeforeReplace|" );
		}
	if(	pcallbackdef->cbtyp & JET_cbtypAfterReplace )
		{
		strcat( szCbtyp, "AfterReplace|" );
		}
	if(	pcallbackdef->cbtyp & JET_cbtypBeforeDelete )
		{
		strcat( szCbtyp, "BeforeDelete|" );
		}
	if(	pcallbackdef->cbtyp & JET_cbtypAfterDelete )
		{
		strcat( szCbtyp, "AfterDelete|" );
		}
	szCbtyp[strlen( szCbtyp ) - 1] = 0;

	printf( "    %2.2d (%s)   %s\n", pcallbackdef->cbtyp, szCbtyp, pcallbackdef->szCallback );
	return 0;
	}


//  ================================================================
LOCAL INT PrintIndexMetaData( const INDEXDEF * pindexdef, void * )
//  ================================================================
	{
	//  this will only compile if the signatures match
	PFNINDEX pfnindex = PrintIndexMetaData;
	
	Assert( pindexdef );
	
	printf( "    %-15.15s  ", pindexdef->szName );
	DBUTLPrintfIntN( pindexdef->pgnoFDP, 8 );
	printf( "  " );
	DBUTLPrintfIntN( pindexdef->objidFDP, 8 );
	printf( "  " );
	DBUTLPrintfIntN( pindexdef->density, 6 );
	printf( "%%\n" );

	if ( pindexdef->fUnique )					
		printf( "        Unique=yes\n" );		
	if ( pindexdef->fPrimary )
		printf( "        Primary=yes\n" );
	if ( pindexdef->fTemplateIndex )
		printf( "        Template=yes\n" );
	if ( pindexdef->fDerivedIndex )
		printf( "        Derived=yes\n" );
	if ( pindexdef->fNoNullSeg )
		printf( "        Disallow Null=yes\n" );
	if ( pindexdef->fAllowAllNulls )
		printf( "        Allow All Nulls=yes\n" );
	if ( pindexdef->fAllowFirstNull )
		printf( "        Allow First Null=yes\n" );
	if ( pindexdef->fAllowSomeNulls )
		printf( "        Allow Some Nulls=yes\n" );
	if ( pindexdef->fSortNullsHigh )
		printf( "        Sort Nulls High=yes\n" );
	if ( pindexdef->fMultivalued )
		printf( "        Multivalued=yes\n" );
	if ( pindexdef->fTuples )
		{
		printf( "        Tuples=yes\n" );
		printf( "            LengthMin=%d\n", pindexdef->le_tuplelimits.le_chLengthMin );
		printf( "            LengthMax=%d\n", pindexdef->le_tuplelimits.le_chLengthMax );
		printf( "            ToIndexMax=%d\n", pindexdef->le_tuplelimits.le_chToIndexMax );
		}
	if ( pindexdef->fLocalizedText )
		{
		printf( "        Localized Text=yes\n" );
		printf( "            Locale Id=%d\n", pindexdef->lcid );
		printf( "            LCMap flags=0x%08x\n", pindexdef->dwMapFlags );
		}
	if ( pindexdef->fExtendedColumns )
		printf( "        Extended Columns=yes\n" );
	printf( "        Flags=0x%08x\n", pindexdef->fFlags );

	UINT isz;		

	Assert( pindexdef->ccolumnidDef > 0 );
	if ( pindexdef->fExtendedColumns )
		{
		printf( "        Key Segments (%d)\n", pindexdef->ccolumnidDef );
		printf(	"        -----------------\n" );
		}
	else
		{
		printf( "        Key Segments (%d - ESE97 format)\n", pindexdef->ccolumnidDef );
		printf(	"        --------------------------------\n" );
		}
	for( isz = 0; isz < pindexdef->ccolumnidDef; isz++ )
		{
		printf( "            %-15.15s (0x%08x)\n", pindexdef->rgszIndexDef[isz], pindexdef->rgidxsegDef[isz].Columnid() );
		}

	if( pindexdef->ccolumnidConditional > 0 )
		{
		if ( pindexdef->fExtendedColumns )
			{
			printf( "        Conditional Columns (%d)\n", pindexdef->ccolumnidConditional );
			printf(	"        ------------------------\n" );
			}
		else
			{
			printf( "        Conditional Columns (%d - ESE97 format)\n", pindexdef->ccolumnidConditional );
			printf(	"        ---------------------------------------\n" );
			}
		for( isz = 0; isz < pindexdef->ccolumnidConditional; isz++ )
			{
			printf( "            %-15.15s (0x%08x,%s)\n",
					( pindexdef->rgszIndexConditional[isz] ) + 1,
					pindexdef->rgidxsegConditional[isz].Columnid(),
					( pindexdef->rgidxsegConditional[isz] ).FMustBeNull() ? "JET_bitIndexColumnMustBeNull" : "JET_bitIndexColumnMustBeNonNull" );
			}
		}

	return 0;
	}

	
//  ================================================================
LOCAL INT PrintColumn( const COLUMNDEF * pcolumndef, void * )
//  ================================================================
	{
	//  this will only compile if the signatures match
	PFNCOLUMN pfncolumn = PrintColumn;	

	Assert( pcolumndef );
	
	printf( "    %-15.15s ", pcolumndef->szName );
	DBUTLPrintfIntN( pcolumndef->columnid, 9 );

	const CHAR * szType;
	const CHAR * szFVT;
	CHAR szUnknown[50];

	if( pcolumndef->fFixed )
		{
		szFVT = "(F)";
		}
	else if( pcolumndef->fTagged )
		{
		szFVT = "(T)";
		}
	else
		{
		szFVT = "";
		}
		
	switch ( pcolumndef->coltyp )
		{
		case JET_coltypBit:
			szType = "Bit";
			break;
			
		case JET_coltypUnsignedByte:
			szType = "UnsignedByte";
			break;

		case JET_coltypShort:
			szType = "Short";
			break;

		case JET_coltypLong:
			szType = "Long";
			break;
			
		case JET_coltypCurrency:
			szType = "Currency";
			break;

		case JET_coltypIEEESingle:
			szType = "IEEESingle";
			break;
			
		case JET_coltypIEEEDouble:
			szType = "IEEEDouble";
			break;
			
		case JET_coltypDateTime:
			szType = "DateTime";
			break;
			
		case JET_coltypBinary:
			szType = "Binary";
			break;

		case JET_coltypText:
			szType = "Text";
			break;

		case JET_coltypLongBinary:
			szType = "LongBinary";
			break;

		case JET_coltypLongText:
			szType = "LongText";
			break;

		case JET_coltypSLV:
			szType = "SLV";
			break;

		case JET_coltypNil:
			szType = "Deleted";
			break;
			
		default:
			LOSSTRFormatA( szUnknown, "???(%d)", pcolumndef->coltyp );
			szType = szUnknown;
			break;
		}

		printf("  %-12.12s%3.3s ", szType, szFVT );
		DBUTLPrintfIntN( pcolumndef->cbLength, 7 );
		
		if ( 0 != pcolumndef->cbDefaultValue )
			{
			printf( "  Yes" );
			}
		printf( "\n" );
		
		if ( FRECTextColumn( pcolumndef->coltyp ) )
			{
			printf( "        Code Page=%d\n", pcolumndef->cp );
			}
			
		if ( pcolumndef->fVersion )
			printf( "        Version=yes\n" );
		if ( pcolumndef->fNotNull )
			printf( "        Disallow Null=yes\n" );
		if ( pcolumndef->fMultiValue )
			printf( "        Multi-value=yes\n" );
		if ( pcolumndef->fAutoIncrement )
			printf( "        Auto-increment=yes\n" );
		if ( pcolumndef->fEscrowUpdate )
			printf( "        EscrowUpdate=yes\n" );
		if ( pcolumndef->fFinalize )
			printf( "        Finalize=yes\n" );
		if ( pcolumndef->fDefaultValue )
			{
			printf( "        DefaultValue=yes\n" );
			printf( "                Length=%d bytes\n", pcolumndef->cbDefaultValue );        
			}
		if ( pcolumndef->fUserDefinedDefault )
			{
			printf( "        User-defined Default=yes\n" );
			printf( "                Callback=%s\n", pcolumndef->szCallback );        
			printf( "                CallbackData=%d bytes\n", pcolumndef->cbCallbackData );        
			}
		if ( pcolumndef->fTemplateColumnESE98 )
			printf( "        TemplateColumnESE98=yes\n" );
		if ( pcolumndef->fPrimaryIndexPlaceholder )
			printf( "        PrimaryIndexPlaceholder=yes\n" );

		printf( "        Flags=0x%x\n", pcolumndef->fFlags );

	return 0;
	}


//  ================================================================
LOCAL INT PrintTableMetaData( const TABLEDEF * ptabledef, void * pv )
//  ================================================================
	{
	//  this will only compile if the signatures match
	PFNTABLE pfntable = PrintTableMetaData;

	Assert( ptabledef );
	JET_DBUTIL * pdbutil = (JET_DBUTIL *)pv;

	printf( "Table Name        PgnoFDP  ObjidFDP    PgnoLV   ObjidLV     Pages  Density\n"
			"==========================================================================\n"
			"%-15.15s  ", ptabledef->szName );
	DBUTLPrintfIntN( ptabledef->pgnoFDP, 8 );
	printf( "  " );
	DBUTLPrintfIntN( ptabledef->objidFDP, 8 );
	printf( "  " );
	DBUTLPrintfIntN( ptabledef->pgnoFDPLongValues, 8 );
	printf( "  " );
	DBUTLPrintfIntN( ptabledef->objidFDPLongValues, 8 );
	printf( "  " );
	DBUTLPrintfIntN( ptabledef->pages, 8 );
	printf( "  " );
	DBUTLPrintfIntN( ptabledef->density, 6 );
	printf( "%%\n" );

	if ( ptabledef->fFlags & JET_bitObjectSystem )
		printf( "    System Table=yes\n" );
	if ( ptabledef->fFlags & JET_bitObjectTableFixedDDL )
		printf( "    FixedDDL=yes\n" );
	if ( ptabledef->fFlags & JET_bitObjectTableTemplate )
		printf( "    Template=yes\n" );

	if ( NULL != ptabledef->szTemplateTable
		&& '\0' != ptabledef->szTemplateTable[0] )
		{
		Assert( ptabledef->fFlags & JET_bitObjectTableDerived );
		printf( "    Derived From: %5s\n", ptabledef->szTemplateTable );
		}
	else
		{
		Assert( !( ptabledef->fFlags & JET_bitObjectTableDerived ) );
		}

	JET_DBUTIL	dbutil;
	ERR			err 	= JET_errSuccess;

	printf( "    Column Name     Column Id  Column Type      Length  Default\n"
			"    -----------------------------------------------------------\n" );

	memset( &dbutil, 0, sizeof( dbutil ) );
	
	dbutil.cbStruct		= sizeof( dbutil );
	dbutil.op 			= opDBUTILEDBDump;
	dbutil.sesid		= pdbutil->sesid;
	dbutil.dbid			= pdbutil->dbid;	
	dbutil.pgno			= ptabledef->objidFDP;
	dbutil.pfnCallback	= (void *)PrintColumn;
	dbutil.pvCallback	= &dbutil;
	dbutil.edbdump		= opEDBDumpColumns;

	err = ErrDBUTLDump( pdbutil->sesid, &dbutil );

	printf( "    Index Name        PgnoFDP  ObjidFDP  Density\n"
			"    --------------------------------------------\n" );

	memset( &dbutil, 0, sizeof( dbutil ) );
	
	dbutil.cbStruct		= sizeof( dbutil );
	dbutil.op 			= opDBUTILEDBDump;
	dbutil.sesid		= pdbutil->sesid;
	dbutil.dbid			= pdbutil->dbid;	
	dbutil.pgno			= ptabledef->objidFDP;
	dbutil.pfnCallback	= (void *)PrintIndexMetaData;
	dbutil.pvCallback	= &dbutil;
	dbutil.edbdump		= opEDBDumpIndexes;

	err = ErrDBUTLDump( pdbutil->sesid, &dbutil );

	printf( "    Callback Type        Callback\n"
			"    --------------------------------------------\n" );

	memset( &dbutil, 0, sizeof( dbutil ) );
	
	dbutil.cbStruct		= sizeof( dbutil );
	dbutil.op 			= opDBUTILEDBDump;
	dbutil.sesid		= pdbutil->sesid;
	dbutil.dbid			= pdbutil->dbid;	
	dbutil.pgno			= ptabledef->objidFDP;
	dbutil.pfnCallback	= (void *)PrintCallback;
	dbutil.pvCallback	= &dbutil;
	dbutil.edbdump		= opEDBDumpCallbacks;

	err = ErrDBUTLDump( pdbutil->sesid, &dbutil );

	return err;
	}


//  ================================================================
LOCAL ERR ErrDBUTLDumpNode( IFileSystemAPI *const pfsapi, const CHAR * const szFile, const PGNO pgno, const INT iline, const  JET_GRBIT grbit )
//  ================================================================
	{
	ERR 			err			= JET_errSuccess;
	KEYDATAFLAGS	kdf;
	CPAGE 			cpage;
	IFileAPI*		pfapi		= NULL;
	QWORD			ibOffset	= OffsetOfPgno( pgno );
	VOID*			pvPage		= NULL;
	CHAR*			szBuf		= NULL;
	const INT		cbWidth		= UtilCprintfStdoutWidth() >= 116 ? 32 : 16;

	pvPage = PvOSMemoryPageAlloc( g_cbPage, NULL );
	if( NULL == pvPage )
		{
		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}

	err = pfsapi->ErrFileOpen( szFile, &pfapi, fTrue );
	if ( err < 0 )
		{
		printf( "Cannot open file %s.\n\n", szFile );
		Call( err );
		}
	Call( pfapi->ErrIORead( ibOffset, g_cbPage, (BYTE* const)pvPage ) );

	cpage.LoadPage( pvPage );

	if ( iline < 0 || iline >= cpage.Clines() )
		{
		printf( "Invalid iline: %d\n\n", iline );
		Call( ErrERRCheck( JET_errInvalidParameter ) );
		}
	else
		{
		extern VOID NDIGetKeydataflags( const CPAGE& cpage, INT iline, KEYDATAFLAGS * pkdf );
		NDIGetKeydataflags( cpage, iline, &kdf );
		}

	printf( "     Flags:  0x%4.4x\n", kdf.fFlags );
	printf( "===========\n" );
	if( FNDVersion( kdf ) )
		{
		printf( "            Versioned\n" );
		}
	if( FNDDeleted( kdf ) )
		{
		printf( "            Deleted\n" );
		}
	if( FNDCompressed( kdf ) )
		{
		printf( "            Compressed\n" );
		}
	printf( "\n" );

	szBuf = (CHAR *)PvOSMemoryPageAlloc( g_cbPage * 8, NULL );
	if( NULL == szBuf )
		{
		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}

	printf( "Key Prefix:  %4d bytes\n", kdf.key.prefix.Cb() );
	printf( "===========\n" );
	szBuf[0] = 0;
	DBUTLSprintHex( szBuf, reinterpret_cast<BYTE *>( kdf.key.prefix.Pv() ), kdf.key.prefix.Cb(), cbWidth );
	printf( "%s\n", szBuf );
	printf( "Key Suffix:  %4d bytes\n", kdf.key.suffix.Cb() );
	printf( "===========\n" );
	szBuf[0] = 0;
	DBUTLSprintHex( szBuf, reinterpret_cast<BYTE *>( kdf.key.suffix.Pv() ), kdf.key.suffix.Cb(), cbWidth );
	printf( "%s\n", szBuf );
	printf( "      Data:  %4d bytes\n", kdf.data.Cb() );
	printf( "===========\n" );
	szBuf[0] = 0;
	DBUTLSprintHex( szBuf, reinterpret_cast<BYTE *>( kdf.data.Pv() ), kdf.data.Cb(), cbWidth );
	printf( "%s\n", szBuf );

	printf( "\n\n" );

	if( !cpage.FLeafPage() )
		{
		if( sizeof( PGNO ) == kdf.data.Cb() )
			{
			const PGNO pgno = *(reinterpret_cast<UnalignedLittleEndian< PGNO > *>( kdf.data.Pv() ) );
			printf( "pgnoChild = %d\n", pgno );
			}
		}
	else if( cpage.FPrimaryPage() )
		{
		if( cpage.FLongValuePage() )
			{
			//  UNDONE: dump this
			}
		else if( cpage.FSpaceTree() )
			{

			PGNO pgno;
			LongFromKey( &pgno, kdf.key );
			const CPG cpg = *(reinterpret_cast<UnalignedLittleEndian< CPG > *>( kdf.data.Pv() ) );
			printf( "%d pages ending at %d\n", cpg, pgno );
			}
		else if( cpage.FSLVAvailPage() )
			{
#define SLVAVAIL_PAGESTATUS_PER_ROW  32
			char * 	szState[] 	= { "F", "R", "D", "C" };			
			PGNO 	pgnoLast 	= pgnoNull;
			PGNO 	pgnoFirst 	= pgnoNull;

			Assert( sizeof( SLVSPACENODE ) == kdf.data.Cb() );
			SLVSPACENODE * const pslvspacenode = (SLVSPACENODE *)kdf.data.Pv();
			ASSERT_VALID( pslvspacenode );
			
			LongFromKey( &pgnoLast, kdf.key );
			printf( "SLV-Avail node: %d pages ending at %d, %d free",
						SLVSPACENODE::cpageMap,
						pgnoLast,
						pslvspacenode->CpgAvail() );
			Assert ( pgnoLast >= SLVSPACENODE::cpageMap);
			pgnoFirst = pgnoLast - SLVSPACENODE::cpageMap + 1;

			for (CPG cpg = 0; SLVSPACENODE::cpageMap > cpg ; cpg++ )
				{
				const SLVSPACENODE::STATE state = pslvspacenode->GetState( cpg );					
				if ( 0 == cpg % SLVAVAIL_PAGESTATUS_PER_ROW)
					{
					printf( "\n%6d -%6d : ", pgnoFirst + cpg, pgnoFirst + cpg + SLVAVAIL_PAGESTATUS_PER_ROW - 1);
					}
				printf( "%s", szState[ state ] );				
				}

			}
		else if( cpage.FSLVOwnerMapPage() )
			{
			KEYDATAFLAGS * pNode = &kdf;

			PGNO pgno;
			Assert ( sizeof(PGNO) == pNode->key.Cb() );
			LongFromKey( &pgno, pNode->key);

			SLVOWNERMAP slvownermapT;
			slvownermapT.Retrieve( pNode->data );
			
			const BYTE * pvKey = (const BYTE *)slvownermapT.PvKey();

			if ( slvownermapT.FValidChecksum() )
				{
				printf(
					"SLV-SpaceMap node: pgno:%u objid:%d fid:%d checksum:%lX cb:%d pv:",
					pgno,
					slvownermapT.Objid(), 
					slvownermapT.Columnid(), 
					slvownermapT.UlChecksum(), 
					slvownermapT.CbKey() );	
				}
			else
				{
				printf(
					"SLV-SpaceMap node: pgno:%u objid:%d fid:%d checksum:<invalid> cb:%d pv:",
					pgno, 
					slvownermapT.Objid(), 
					slvownermapT.Columnid(), 
					slvownermapT.CbKey() );
				}
				
			for ( ULONG i = 0; i < slvownermapT.CbKey(); i++)
				{
				printf( "%02X ", pvKey[i] );
				}
			}
		else
			{
			DBUTLDumpRec( kdf.data.Pv(), kdf.data.Cb(), CPRINTFSTDOUT::PcprintfInstance(), cbWidth );
			}
		}
	
HandleError:
	cpage.UnloadPage();
	OSMemoryPageFree( szBuf );
	OSMemoryPageFree( pvPage );
	delete pfapi;
	return err;
	}

#endif	//	DEBUG


//  ================================================================
LOCAL ERR ErrDBUTLDumpPage( IFileSystemAPI *const pfsapi, const CHAR * szFile, PGNO pgno, JET_GRBIT grbit )
//  ================================================================
	{
	ERR 			err = JET_errSuccess;
	CPAGE 			cpage;
	IFileAPI	*pfapi = NULL;

	CHAR * szBuf = 0;

	QWORD ibOffset = OffsetOfPgno( pgno );

	VOID * const pvPage = PvOSMemoryPageAlloc( g_cbPage, NULL );
	if( NULL == pvPage )
		{
		CallR( ErrERRCheck( JET_errOutOfMemory ) );
		}

	err = pfsapi->ErrFileOpen( szFile, &pfapi, fTrue );
	if ( err < 0 )
		{
		printf( "Cannot open file %s.\n\n", szFile );
		Call( err );
		}
	Call( pfapi->ErrIORead( ibOffset, g_cbPage, (BYTE* const)pvPage ) );

	cpage.LoadPage( pvPage );
	(VOID)cpage.DumpHeader( CPRINTFSTDOUT::PcprintfInstance() );
	printf( "\n" );
	(VOID)cpage.DumpTags( CPRINTFSTDOUT::PcprintfInstance() );
	printf( "\n" );

#ifdef DEBUG
	if( grbit & JET_bitDBUtilOptionDumpVerbose )
		{
		(VOID)cpage.DumpAllocMap( CPRINTFSTDOUT::PcprintfInstance() );
		printf( "\n" );

		const INT cbWidth = UtilCprintfStdoutWidth() >= 116 ? 32 : 16;

		CHAR * szBuf = new CHAR[g_cbPage * 8];
		if( NULL == szBuf )
			{
			Call( ErrERRCheck( JET_errOutOfMemory ) );
			}

		DBUTLSprintHex( szBuf, reinterpret_cast<BYTE *>( pvPage ), g_cbPage, cbWidth );
		printf( "%s\n", szBuf );

		delete [] szBuf;
		}
#endif		
		
HandleError:
	cpage.UnloadPage();
	delete pfapi;
	OSMemoryPageFree( pvPage );
	return err;
	}


//  ================================================================
LOCAL ERR ErrDBUTLPrintSLVSpace(
	PIB* const	 	ppib,
	const IFMP		ifmp,
	CPRINTF* const	pcprintf )
//  ================================================================
	{
	ERR				err					= JET_errSuccess;
	FUCB*			pfucbSLVAvail		= pfucbNil;
	FCB* const		pfcbSLVAvail		= rgfmp[ifmp].PfcbSLVAvail();
	Assert( pfcbNil != pfcbSLVAvail );
	
	CPG				cpgTotalFree		= 0;
	CPG				cpgTotalReserved	= 0;
	CPG				cpgTotalDeleted		= 0;
	CPG				cpgTotalCommitted	= 0;
	CPG				cpgTotalUnknown		= 0;

	//  Open the SVLAvail Tree
	
	Call( ErrBTOpen( ppib, pfcbSLVAvail, &pfucbSLVAvail, fFalse ) );
	Assert( pfucbNil != pfucbSLVAvail );

	DIB dib;
	dib.pos 	= posFirst;
	dib.dirflag = fDIRNull;
	dib.pbm		= NULL;
	Call( ErrBTDown( pfucbSLVAvail, &dib, latchReadTouch ) );
	
	while( 1 )
		{
		if( sizeof( SLVSPACENODE ) != pfucbSLVAvail->kdfCurr.data.Cb() )
			{
			(*pcprintf)( "node %d:%d in the SLVAvail tree is corrupted\n",
							Pcsr( pfucbSLVAvail )->Pgno(),
							Pcsr( pfucbSLVAvail )->ILine() );
			Call( ErrERRCheck( JET_errDatabaseCorrupted ) );
			}
			
		if( sizeof( PGNO ) != pfucbSLVAvail->kdfCurr.key.Cb() )
			{
			(*pcprintf)( "node %d:%d in the SLVAvail tree is corrupted\n",
							Pcsr( pfucbSLVAvail )->Pgno(),
							Pcsr( pfucbSLVAvail )->ILine() );
			Call( ErrERRCheck( JET_errDatabaseCorrupted ) );
			}
		
		const SLVSPACENODE* const	pspacenode		= reinterpret_cast<SLVSPACENODE *>( pfucbSLVAvail->kdfCurr.data.Pv() );
		const CPG					cpgAvail		= pspacenode->CpgAvail();
		CPG							cpgFree			= 0;
		CPG							cpgReserved		= 0;
		CPG							cpgDeleted		= 0;
		CPG							cpgCommitted	= 0;
		CPG							cpgUnknown		= 0;
		PGNO						pgnoLast;
		UINT						i;

		for ( i = 0; i < SLVSPACENODE::cpageMap; i++ )
			{
			switch ( pspacenode->GetState( i ) )
				{
				case SLVSPACENODE::sFree:
					cpgFree++;
					cpgTotalFree++;
					break;
				case SLVSPACENODE::sReserved:
					cpgReserved++;
					cpgTotalReserved++;
					break;
				case SLVSPACENODE::sDeleted:
					cpgDeleted++;
					cpgTotalDeleted++;
					break;
				case SLVSPACENODE::sCommitted:
					cpgCommitted++;
					cpgTotalCommitted++;
					break;
				default:
					Assert( fFalse );
					cpgUnknown++;
					cpgTotalUnknown++;
					break;
				}
			}

		Assert( cpgFree == cpgAvail );
		Assert( cpgReserved + cpgDeleted + cpgCommitted == ( SLVSPACENODE::cpageMap - cpgAvail ) );
		
		LongFromKey( &pgnoLast, pfucbSLVAvail->kdfCurr.key );
		(*pcprintf)( "%-14d  %3d %3d %3d %3d  ", pgnoLast, cpgFree, cpgReserved, cpgDeleted, cpgCommitted );

		for( i = 0; i < ( SLVSPACENODE::cpageMap - cpgAvail ) / 16; ++i )
			{
			(*pcprintf)( "*" );
			}

 		(*pcprintf)( "\n" );

		err = ErrBTNext( pfucbSLVAvail, fDIRNull );
		if( JET_errNoCurrentRecord == err )
			{
			//  end of the tree
			err = JET_errSuccess;
			break;
			}
		Call( err );
		}

	printf( "============================================================================\n" );
	printf( "TOTALS:\n" );
	printf( "         Free: %12d\n", cpgTotalFree );
	printf( "     Reserved: %12d\n", cpgTotalReserved );
	printf( "      Deleted: %12d\n", cpgTotalDeleted );
	printf( "    Committed: %12d\n", cpgTotalCommitted );
	printf( "      Unknown: %12d\n", cpgTotalUnknown );
	printf( "              -------------\n" );
	printf( "               %12d\n", cpgTotalFree+cpgTotalReserved+cpgTotalDeleted+cpgTotalCommitted+cpgTotalUnknown );
	printf( "****************************************************************************\n" );


HandleError:
	if( pfucbNil != pfucbSLVAvail )
		{
		BTClose( pfucbSLVAvail );
		pfucbSLVAvail = pfucbNil;
		}
	return err;
	}


LOCAL ERR ErrDBUTLPrintSpace(
	PIB				*ppib,
	const IFMP		ifmp,
	const OBJID		objidFDP,
	const PGNO		pgnoFDP,
	CPRINTF * const	pcprintf )
	{
	ERR				err;
	FUCB			*pfucb			= pfucbNil;
	BOOL			fForceInit		= fFalse;
	SPACE_HEADER	*psph;
	CPG				rgcpgExtent[2];

	CallR( ErrBTOpen( ppib, pgnoFDP, ifmp, &pfucb ) );
	Assert( pfucbNil != pfucb );
	Assert( pfcbNil != pfucb->u.pfcb );

	if ( !pfucb->u.pfcb->FInitialized() )
		{
		Assert( pgnoSystemRoot != pgnoFDP );
		Assert( pgnoFDPMSO != pgnoFDP );
		Assert( pgnoFDPMSO_NameIndex != pgnoFDP );
		Assert( pgnoFDPMSO_RootObjectIndex != pgnoFDP );
		Assert( pfucb->u.pfcb->WRefCount() == 1 );

		//	must force FCB to initialized state to allow SPGetInfo() to
		//	open more cursors on the FCB -- this is safe because no
		//	other thread should be opening this FCB
		pfucb->u.pfcb->CreateComplete();
		fForceInit = fTrue;
		}
	else if ( pgnoSystemRoot == pgnoFDP
			|| pgnoFDPMSO == pgnoFDP
			|| pgnoFDPMSO_NameIndex == pgnoFDP
			|| pgnoFDPMSO_RootObjectIndex == pgnoFDP )
		{
		//	fine!
		}
	else
		{
		Assert( rgfmp[ifmp].FSLVAttached() );
		Assert( pfcbNil != rgfmp[ifmp].PfcbSLVAvail() );
		Assert( pfcbNil != rgfmp[ifmp].PfcbSLVOwnerMap() );
		Assert( rgfmp[ifmp].PfcbSLVAvail()->ObjidFDP() == objidFDP
			|| rgfmp[ifmp].PfcbSLVOwnerMap()->ObjidFDP() == objidFDP );
		Assert( rgfmp[ifmp].PfcbSLVAvail()->PgnoFDP() == pgnoFDP
			|| rgfmp[ifmp].PfcbSLVOwnerMap()->PgnoFDP() == pgnoFDP );
		}
	
	Call( ErrBTIGotoRoot( pfucb, latchReadNoTouch ) );
	
	NDGetExternalHeader ( pfucb );
	Assert( sizeof( SPACE_HEADER ) == pfucb->kdfCurr.data.Cb() );
	psph = reinterpret_cast <SPACE_HEADER *> ( pfucb->kdfCurr.data.Pv() );

	DBUTLPrintfIntN( objidFDP, 10 );
	printf( " " );
	DBUTLPrintfIntN( pgnoFDP, 10 );
	printf( " " );
	DBUTLPrintfIntN( psph->CpgPrimary(), 5 );
	printf( "-%c ", psph->FMultipleExtent() ? 'm' : 's' );
	BTUp( pfucb );

	Call( ErrSPGetInfo(
				ppib,
				ifmp,
				pfucb,
				(BYTE *)rgcpgExtent,
				sizeof(rgcpgExtent),
				fSPOwnedExtent|fSPAvailExtent ) );
//				pcprintf ) );
				
	DBUTLPrintfIntN( rgcpgExtent[0], 10 );
	printf( " " );
	DBUTLPrintfIntN( rgcpgExtent[1], 10 );
	printf( "\n" );

	cpgTotalAvailExt += rgcpgExtent[1];

HandleError:
	Assert( pfucbNil != pfucb );

	if ( fForceInit )
		{
		Assert( pfucb->u.pfcb->WRefCount() == 1 );

		//	force the FCB to be uninitialized so it will be purged by BTClose

		pfucb->u.pfcb->CreateComplete( errFCBUnusable );
		}
	BTClose( pfucb );

	return err;
	}

//  ================================================================
LOCAL INT PrintIndexSpace( const INDEXDEF * pindexdef, void * pv )
//  ================================================================
	{
	//  this will only compile if the signatures match
	PFNINDEX	pfnindex		= PrintIndexSpace;

	ERR			err				= JET_errSuccess;
	JET_DBUTIL	*pdbutil		= (JET_DBUTIL *)pv;
	PIB			*ppib			= (PIB *)pdbutil->sesid;
	const IFMP	ifmp			= (IFMP)pdbutil->dbid;
	
	Assert( pindexdef );

	if ( !pindexdef->fPrimary )		//	primary index dumped when table was dumped
		{
		CPRINTF * const pcprintf = ( pdbutil->grbitOptions & JET_bitDBUtilOptionDumpVerbose ) ?
			CPRINTFSTDOUT::PcprintfInstance() : NULL;
		printf( "  %-21.21s Idx ", pindexdef->szName );
		err = ErrDBUTLPrintSpace( ppib, ifmp, pindexdef->objidFDP, pindexdef->pgnoFDP, pcprintf );
		}

	return err;
	}

//  ================================================================
LOCAL INT PrintTableSpace( const TABLEDEF * ptabledef, void * pv )
//  ================================================================
	{
	//  this will only compile if the signatures match
	PFNTABLE pfntable = PrintTableSpace;

	ERR			err;
	JET_DBUTIL	*pdbutil		= (JET_DBUTIL *)pv;
	PIB			*ppib			= (PIB *)pdbutil->sesid;
	const IFMP	ifmp			= (IFMP)pdbutil->dbid;

	Assert( ptabledef );
	
	printf( "%-23.23s Tbl ", ptabledef->szName );

	if ( pgnoNull != ptabledef->pgnoFDPLongValues )
		{
		BFPrereadPageRange( ifmp, ptabledef->pgnoFDPLongValues, 1 );
		}

	CPRINTF * const pcprintf = ( pdbutil->grbitOptions & JET_bitDBUtilOptionDumpVerbose ) ?
		CPRINTFSTDOUT::PcprintfInstance() : NULL;

	CallR( ErrDBUTLPrintSpace(
				ppib,
				ifmp,
				ptabledef->objidFDP,
				ptabledef->pgnoFDP,
				pcprintf ) );

	if ( pgnoNull != ptabledef->pgnoFDPLongValues )
		{
		printf( "  %-21.21s LV  ", "<Long Values>" );
		CallR( ErrDBUTLPrintSpace(
					ppib,
					ifmp,
					ptabledef->objidFDPLongValues,
					ptabledef->pgnoFDPLongValues,
					pcprintf ) );
		}
	
	JET_DBUTIL	dbutil;	
	memset( &dbutil, 0, sizeof( dbutil ) );
	
	dbutil.cbStruct		= sizeof( dbutil );
	dbutil.op 			= opDBUTILEDBDump;
	dbutil.sesid		= pdbutil->sesid;
	dbutil.dbid			= pdbutil->dbid;	
	dbutil.pgno			= ptabledef->objidFDP;
	dbutil.pfnCallback	= (void *)PrintIndexSpace;
	dbutil.pvCallback	= &dbutil;
	dbutil.edbdump		= opEDBDumpIndexes;
	dbutil.grbitOptions	= pdbutil->grbitOptions;

	err = ErrDBUTLDump( pdbutil->sesid, &dbutil );
	return err;
	}


//  ================================================================
LOCAL INT PrintIndexBareMetaData( const INDEXDEF * pindexdef, void * pv )
//  ================================================================
	{
	//  this will only compile if the signatures match
	PFNINDEX	pfnindex		= PrintIndexBareMetaData;

	Assert( pindexdef );

	if ( !pindexdef->fPrimary )		//	primary index dumped when table was dumped
		{
		printf( "  %-49.49s Idx  ", pindexdef->szName );
		DBUTLPrintfIntN( pindexdef->objidFDP, 10 );
		printf( " " );
		DBUTLPrintfIntN( pindexdef->pgnoFDP, 10 );
		printf( "\n" );
		}

	return JET_errSuccess;
	}


//  ================================================================
LOCAL INT PrintTableBareMetaData( const TABLEDEF * ptabledef, void * pv )
//  ================================================================
	{
	//  this will only compile if the signatures match
	PFNTABLE	pfntable		= PrintTableBareMetaData;
	ERR			err;
	JET_DBUTIL	*pdbutil		= (JET_DBUTIL *)pv;

	Assert( ptabledef );
	
	printf( "%-51.51s Tbl  ", ptabledef->szName );
	DBUTLPrintfIntN( ptabledef->objidFDP, 10 );
	printf( " " );
	DBUTLPrintfIntN( ptabledef->pgnoFDP, 10 );
	printf( "\n" );

	if ( pgnoNull != ptabledef->pgnoFDPLongValues )
		{
		printf( "  %-49.49s LV   ", "<Long Values>" );
		DBUTLPrintfIntN( ptabledef->objidFDPLongValues, 10 );
		printf( " " );
		DBUTLPrintfIntN( ptabledef->pgnoFDPLongValues, 10 );
		printf( "\n" );
		}
	
	JET_DBUTIL	dbutil;	
	memset( &dbutil, 0, sizeof( dbutil ) );
	
	dbutil.cbStruct		= sizeof( dbutil );
	dbutil.op 			= opDBUTILEDBDump;
	dbutil.sesid		= pdbutil->sesid;
	dbutil.dbid			= pdbutil->dbid;	
	dbutil.pgno			= ptabledef->objidFDP;
	dbutil.pfnCallback	= (void *)PrintIndexBareMetaData;
	dbutil.pvCallback	= &dbutil;
	dbutil.edbdump		= opEDBDumpIndexes;
	dbutil.grbitOptions	= pdbutil->grbitOptions;

	err = ErrDBUTLDump( pdbutil->sesid, &dbutil );

	return err;
	}


//  ================================================================
LOCAL ERR ErrDBUTLDumpOneIndex( PIB * ppib, FUCB * pfucbCatalog, VOID * pfnCallback, VOID * pvCallback )
//  ================================================================
	{
	JET_RETRIEVECOLUMN	rgretrievecolumn[11];
	BYTE				pbufidxseg[JET_ccolKeyMost*sizeof(IDXSEG)];
	BYTE				pbufidxsegConditional[JET_ccolKeyMost*sizeof(IDXSEG)];
	INDEXDEF			indexdef;
	ERR					err				= JET_errSuccess;
	INT					iretrievecolumn	= 0;
	OBJID				objidTable;

	memset( &indexdef, 0, sizeof( indexdef ) );
	memset( rgretrievecolumn, 0, sizeof( rgretrievecolumn ) );

	//  objectId of owning table
	rgretrievecolumn[iretrievecolumn].columnid 		= fidMSO_ObjidTable;
	rgretrievecolumn[iretrievecolumn].pvData 		= (BYTE *)&objidTable;
	rgretrievecolumn[iretrievecolumn].cbData		= sizeof(objidTable);
	rgretrievecolumn[iretrievecolumn].itagSequence	= 1;
	++iretrievecolumn;	

	//  pgnoFDP of index tree
	rgretrievecolumn[iretrievecolumn].columnid 		= fidMSO_PgnoFDP;
	rgretrievecolumn[iretrievecolumn].pvData 		= (BYTE *)&indexdef.pgnoFDP;
	rgretrievecolumn[iretrievecolumn].cbData		= sizeof(indexdef.pgnoFDP);
	rgretrievecolumn[iretrievecolumn].itagSequence	= 1;
	++iretrievecolumn;	

	//  indexId (objidFDP of index tree)
	rgretrievecolumn[iretrievecolumn].columnid 		= fidMSO_Id;
	rgretrievecolumn[iretrievecolumn].pvData 		= (BYTE *)&indexdef.objidFDP;
	rgretrievecolumn[iretrievecolumn].cbData		= sizeof(indexdef.objidFDP);
	rgretrievecolumn[iretrievecolumn].itagSequence	= 1;
	++iretrievecolumn;	

	rgretrievecolumn[iretrievecolumn].columnid 		= fidMSO_Name;
	rgretrievecolumn[iretrievecolumn].pvData 		= (BYTE *)indexdef.szName;
	rgretrievecolumn[iretrievecolumn].cbData		= sizeof(indexdef.szName);
	rgretrievecolumn[iretrievecolumn].itagSequence	= 1;
	++iretrievecolumn;	
	
	rgretrievecolumn[iretrievecolumn].columnid 		= fidMSO_SpaceUsage;
	rgretrievecolumn[iretrievecolumn].pvData 		= (BYTE *)&indexdef.density;
	rgretrievecolumn[iretrievecolumn].cbData		= sizeof(indexdef.density);
	rgretrievecolumn[iretrievecolumn].itagSequence	= 1;
	++iretrievecolumn;	

	rgretrievecolumn[iretrievecolumn].columnid 		= fidMSO_Localization;
	rgretrievecolumn[iretrievecolumn].pvData 		= (BYTE *)&indexdef.lcid;
	rgretrievecolumn[iretrievecolumn].cbData		= sizeof(indexdef.lcid);
	rgretrievecolumn[iretrievecolumn].itagSequence	= 1;
	++iretrievecolumn;	

	rgretrievecolumn[iretrievecolumn].columnid 		= fidMSO_LCMapFlags;
	rgretrievecolumn[iretrievecolumn].pvData 		= (BYTE *)&indexdef.dwMapFlags;
	rgretrievecolumn[iretrievecolumn].cbData		= sizeof(indexdef.dwMapFlags);
	rgretrievecolumn[iretrievecolumn].itagSequence	= 1;
	++iretrievecolumn;	

	rgretrievecolumn[iretrievecolumn].columnid 		= fidMSO_Flags;
	rgretrievecolumn[iretrievecolumn].pvData 		= (BYTE *)&indexdef.fFlags;
	rgretrievecolumn[iretrievecolumn].cbData		= sizeof(indexdef.fFlags);
	rgretrievecolumn[iretrievecolumn].itagSequence	= 1;
	++iretrievecolumn;	

	rgretrievecolumn[iretrievecolumn].columnid 		= fidMSO_TupleLimits;
	rgretrievecolumn[iretrievecolumn].pvData 		= (BYTE *)&indexdef.le_tuplelimits;
	rgretrievecolumn[iretrievecolumn].cbData		= sizeof(indexdef.le_tuplelimits);
	rgretrievecolumn[iretrievecolumn].itagSequence	= 1;
	++iretrievecolumn;	

	rgretrievecolumn[iretrievecolumn].columnid 		= fidMSO_ConditionalColumns;
	rgretrievecolumn[iretrievecolumn].pvData 		= pbufidxsegConditional;
	rgretrievecolumn[iretrievecolumn].cbData		= sizeof(pbufidxsegConditional);
	rgretrievecolumn[iretrievecolumn].itagSequence	= 1;
	++iretrievecolumn;	

	rgretrievecolumn[iretrievecolumn].columnid 		= fidMSO_KeyFldIDs;
	rgretrievecolumn[iretrievecolumn].pvData 		= pbufidxseg;
	rgretrievecolumn[iretrievecolumn].cbData		= sizeof(pbufidxseg);
	rgretrievecolumn[iretrievecolumn].itagSequence	= 1;
	++iretrievecolumn;	

	CallR( ErrIsamRetrieveColumns(
				(JET_SESID)ppib,
				(JET_TABLEID)pfucbCatalog,
				rgretrievecolumn,
				iretrievecolumn ) );

	const IDBFLAG	idbflag		= (IDBFLAG)indexdef.fFlags;
	const IDXFLAG	idxflag		= (IDXFLAG)( indexdef.fFlags >> sizeof(IDBFLAG) * 8 );

	indexdef.fUnique			= !!FIDBUnique( idbflag );
	indexdef.fPrimary			= !!FIDBPrimary( idbflag );
	indexdef.fAllowAllNulls		= !!FIDBAllowAllNulls( idbflag );
	indexdef.fAllowFirstNull	= !!FIDBAllowFirstNull( idbflag );
	indexdef.fAllowSomeNulls	= !!FIDBAllowSomeNulls( idbflag );
	indexdef.fNoNullSeg			= !!FIDBNoNullSeg( idbflag );
	indexdef.fSortNullsHigh		= !!FIDBSortNullsHigh( idbflag );
	indexdef.fMultivalued		= !!FIDBMultivalued( idbflag );
	indexdef.fTuples			= ( JET_wrnColumnNull == rgretrievecolumn[iretrievecolumn-3].err ? fFalse : fTrue );
	indexdef.fLocaleId			= !!FIDBLocaleId( idbflag );
	indexdef.fLocalizedText		= !!FIDBLocalizedText( idbflag );
	indexdef.fTemplateIndex		= !!FIDBTemplateIndex( idbflag );
	indexdef.fDerivedIndex		= !!FIDBDerivedIndex( idbflag );
	indexdef.fExtendedColumns	= !!FIDXExtendedColumns( idxflag );

	// WARNING: if the order of rgretrievecolumn initialization is changed above this must change too
	const INT	iretcolIdxseg				= iretrievecolumn-1;
	const INT	iretcolIdxsegConditional	= iretrievecolumn-2;
	Assert( rgretrievecolumn[iretcolIdxseg].cbActual > 0 );

	if ( indexdef.fExtendedColumns )
		{
		UINT	iidxseg;

		Assert( sizeof(IDXSEG) == sizeof(JET_COLUMNID) );

		Assert( rgretrievecolumn[iretcolIdxseg].cbActual <= sizeof(JET_COLUMNID) * JET_ccolKeyMost );
		Assert( rgretrievecolumn[iretcolIdxseg].cbActual % sizeof(JET_COLUMNID) == 0 );
		Assert( rgretrievecolumn[iretcolIdxseg].cbActual / sizeof(JET_COLUMNID) <= JET_ccolKeyMost );
		indexdef.ccolumnidDef = rgretrievecolumn[iretcolIdxseg].cbActual / sizeof(JET_COLUMNID);

		for ( iidxseg = 0; iidxseg < indexdef.ccolumnidDef; iidxseg++ )
			{
			const LE_IDXSEG		* const ple_idxseg	= (LE_IDXSEG *)pbufidxseg + iidxseg;
			//	Endian conversion
			indexdef.rgidxsegDef[iidxseg] = *ple_idxseg;
			Assert( FCOLUMNIDValid( indexdef.rgidxsegDef[iidxseg].Columnid() ) );
			}

		Assert( rgretrievecolumn[iretcolIdxsegConditional].cbActual <= sizeof(JET_COLUMNID) * JET_ccolKeyMost );
		Assert( rgretrievecolumn[iretcolIdxsegConditional].cbActual % sizeof(JET_COLUMNID) == 0 );
		Assert( rgretrievecolumn[iretcolIdxsegConditional].cbActual / sizeof(JET_COLUMNID) <= JET_ccolKeyMost );
		indexdef.ccolumnidConditional = rgretrievecolumn[iretcolIdxsegConditional].cbActual / sizeof(JET_COLUMNID);

		for ( iidxseg = 0; iidxseg < indexdef.ccolumnidConditional; iidxseg++ )
			{
			const LE_IDXSEG		* const ple_idxsegConditional	= (LE_IDXSEG *)pbufidxsegConditional + iidxseg;
			//	Endian conversion
			indexdef.rgidxsegConditional[iidxseg] = *ple_idxsegConditional;
			Assert( FCOLUMNIDValid( indexdef.rgidxsegConditional[iidxseg].Columnid() ) );
			}

		}
	else
		{
		Assert( sizeof(IDXSEG_OLD) == sizeof(FID) );

		Assert( rgretrievecolumn[iretcolIdxseg].cbActual <= sizeof(FID) * JET_ccolKeyMost );
		Assert( rgretrievecolumn[iretcolIdxseg].cbActual % sizeof(FID) == 0);
		Assert( rgretrievecolumn[iretcolIdxseg].cbActual / sizeof(FID) <= JET_ccolKeyMost );
		indexdef.ccolumnidDef = rgretrievecolumn[iretcolIdxseg].cbActual / sizeof( FID );

		SetIdxSegFromOldFormat(
			(UnalignedLittleEndian< IDXSEG_OLD > *)pbufidxseg,
			indexdef.rgidxsegDef,
			indexdef.ccolumnidDef,
			fFalse,
			fFalse,
			NULL );

		Assert( rgretrievecolumn[iretcolIdxsegConditional].cbActual <= sizeof(FID) * JET_ccolKeyMost );
		Assert( rgretrievecolumn[iretcolIdxsegConditional].cbActual % sizeof(FID) == 0);
		Assert( rgretrievecolumn[iretcolIdxsegConditional].cbActual / sizeof(FID) <= JET_ccolKeyMost );
		indexdef.ccolumnidConditional = rgretrievecolumn[iretcolIdxsegConditional].cbActual / sizeof( FID );

		SetIdxSegFromOldFormat(
			(UnalignedLittleEndian< IDXSEG_OLD > *)pbufidxsegConditional,
			indexdef.rgidxsegConditional,
			indexdef.ccolumnidConditional,
			fTrue,
			fFalse,
			NULL );
		}

	CallR( ErrCATGetIndexSegments(
					ppib,
					pfucbCatalog->u.pfcb->Ifmp(),
					objidTable,
					indexdef.rgidxsegDef,
					indexdef.ccolumnidDef,
					fFalse,
					!indexdef.fExtendedColumns,
					indexdef.rgszIndexDef ) );
					
	CallR( ErrCATGetIndexSegments(
					ppib,
					pfucbCatalog->u.pfcb->Ifmp(),
					objidTable,
					indexdef.rgidxsegConditional,
					indexdef.ccolumnidConditional,
					fTrue,
					!indexdef.fExtendedColumns,
					indexdef.rgszIndexConditional ) );

	PFNINDEX const pfnindex = (PFNINDEX)pfnCallback;
	(*pfnindex)( &indexdef, pvCallback );

	return err;
	}


//  ================================================================
LOCAL ERR ErrDBUTLDumpOneTable( PIB * ppib, FUCB * pfucbCatalog, PFNTABLE pfntable, VOID * pvCallback )
//  ================================================================
	{
	JET_RETRIEVECOLUMN	rgretrievecolumn[10];
	TABLEDEF			tabledef;
	ERR					err				= JET_errSuccess;
	INT					iretrievecolumn	= 0;

	memset( &tabledef, 0, sizeof( tabledef ) );
	memset( rgretrievecolumn, 0, sizeof( rgretrievecolumn ) );

	rgretrievecolumn[iretrievecolumn].columnid 		= fidMSO_Name;
	rgretrievecolumn[iretrievecolumn].pvData 		= (BYTE *)tabledef.szName;
	rgretrievecolumn[iretrievecolumn].cbData		= sizeof( tabledef.szName );
	rgretrievecolumn[iretrievecolumn].itagSequence	= 1;
	++iretrievecolumn;	

	rgretrievecolumn[iretrievecolumn].columnid 		= fidMSO_TemplateTable;
	rgretrievecolumn[iretrievecolumn].pvData 		= (BYTE *)tabledef.szTemplateTable;
	rgretrievecolumn[iretrievecolumn].cbData		= sizeof( tabledef.szTemplateTable );
	rgretrievecolumn[iretrievecolumn].itagSequence	= 1;
	++iretrievecolumn;	

	rgretrievecolumn[iretrievecolumn].columnid 		= fidMSO_PgnoFDP;
	rgretrievecolumn[iretrievecolumn].pvData 		= (BYTE *)&( tabledef.pgnoFDP );
	rgretrievecolumn[iretrievecolumn].cbData		= sizeof( tabledef.pgnoFDP );
	rgretrievecolumn[iretrievecolumn].itagSequence	= 1;
	++iretrievecolumn;	

	rgretrievecolumn[iretrievecolumn].columnid 		= fidMSO_Id;
	rgretrievecolumn[iretrievecolumn].pvData 		= (BYTE *)&( tabledef.objidFDP );
	rgretrievecolumn[iretrievecolumn].cbData		= sizeof( tabledef.objidFDP );
	rgretrievecolumn[iretrievecolumn].itagSequence	= 1;
	++iretrievecolumn;	

	rgretrievecolumn[iretrievecolumn].columnid 		= fidMSO_Pages;
	rgretrievecolumn[iretrievecolumn].pvData 		= (BYTE *)&( tabledef.pages );
	rgretrievecolumn[iretrievecolumn].cbData		= sizeof( tabledef.pages );
	rgretrievecolumn[iretrievecolumn].itagSequence	= 1;
	++iretrievecolumn;	

	rgretrievecolumn[iretrievecolumn].columnid 		= fidMSO_SpaceUsage;
	rgretrievecolumn[iretrievecolumn].pvData 		= (BYTE *)&( tabledef.density );
	rgretrievecolumn[iretrievecolumn].cbData		= sizeof( tabledef.density );
	rgretrievecolumn[iretrievecolumn].itagSequence	= 1;
	++iretrievecolumn;	

	rgretrievecolumn[iretrievecolumn].columnid 		= fidMSO_Flags;
	rgretrievecolumn[iretrievecolumn].pvData 		= (BYTE *)&( tabledef.fFlags );
	rgretrievecolumn[iretrievecolumn].cbData		= sizeof( tabledef.fFlags );
	rgretrievecolumn[iretrievecolumn].itagSequence	= 1;
	++iretrievecolumn;	

	Call( ErrIsamRetrieveColumns(
				(JET_SESID)ppib,
				(JET_TABLEID)pfucbCatalog,
				rgretrievecolumn,
				iretrievecolumn ) );
				
	Call( ErrCATAccessTableLV(
				ppib,
				pfucbCatalog->u.pfcb->Ifmp(),
				tabledef.objidFDP,
				&tabledef.pgnoFDPLongValues,
				&tabledef.objidFDPLongValues ) );

	(*pfntable)( &tabledef, pvCallback );

HandleError:
	return err;
	}


//  ================================================================
LOCAL ERR ErrDBUTLDumpTables( PIB * ppib, IFMP ifmp, CHAR *szTableName, PFNTABLE pfntable, VOID * pvCallback )
//  ================================================================
	{
	ERR		err;
	FUCB	*pfucbCatalog	= pfucbNil;
	
	CallR( ErrCATOpen( ppib, ifmp, &pfucbCatalog ) );
	Assert( pfucbNil != pfucbCatalog );
	
	Call( ErrIsamSetCurrentIndex( ppib, pfucbCatalog, szMSORootObjectsIndex ) );

	if ( NULL != szTableName )
		{
		//  find the table we want and dump it
		const BYTE	bTrue	= 0xff;
		
		Call( ErrIsamMakeKey(
					ppib,
					pfucbCatalog,
					&bTrue,
					sizeof(bTrue),
					JET_bitNewKey ) );
		Call( ErrIsamMakeKey(
					ppib,
					pfucbCatalog,
					(BYTE *)szTableName,
					(ULONG)strlen(szTableName),
					NO_GRBIT ) );
		err = ErrIsamSeek( ppib, pfucbCatalog, JET_bitSeekEQ );
		if ( JET_errRecordNotFound == err )
			err = ErrERRCheck( JET_errObjectNotFound );
		Call( err );
		CallS( err );

		Call( ErrDBUTLDumpOneTable( ppib, pfucbCatalog, pfntable, pvCallback ) );
		}
	else
		{
		err = ErrIsamMove( ppib, pfucbCatalog, JET_MoveFirst, NO_GRBIT );
		while ( JET_errNoCurrentRecord != err )
			{
			Call( err );
			
			Call( ErrDBUTLDumpOneTable( ppib, pfucbCatalog, pfntable, pvCallback ) );
			err = ErrIsamMove( ppib, pfucbCatalog, JET_MoveNext, NO_GRBIT );
			}
		}
		
	err = JET_errSuccess;

HandleError:
	CallS( ErrCATClose( ppib, pfucbCatalog ) );

	return err;
	}


//  ================================================================
LOCAL ERR ErrDBUTLDumpTableObjects(
	PIB				*ppib,
	const IFMP		ifmp,
	const OBJID		objidFDP,
	const SYSOBJ	sysobj,
	PFNDUMP			pfnDump,
	VOID			*pfnCallback,
	VOID			*pvCallback )
//  ================================================================
	{
	ERR				err;
	FUCB			*pfucbCatalog	= pfucbNil;

	CallR( ErrCATOpen( ppib, ifmp, &pfucbCatalog ) );
	Assert( pfucbNil != pfucbCatalog );
	FUCBSetSequential( pfucbCatalog );

	Call( ErrIsamSetCurrentIndex( ppib, pfucbCatalog, szMSONameIndex ) );
	
	Call( ErrIsamMakeKey(
				ppib,
				pfucbCatalog,
				(BYTE *)&objidFDP,
				sizeof(objidFDP),
				JET_bitNewKey ) );
	Call( ErrIsamMakeKey(
				ppib,
				pfucbCatalog,
				(BYTE *)&sysobj,
				sizeof(sysobj),
				NO_GRBIT ) );

	err = ErrIsamSeek( ppib, pfucbCatalog, JET_bitSeekGT );
	if ( err < 0 )
		{
		if ( JET_errRecordNotFound != err )
			goto HandleError;
		}
	else
		{
		CallS( err );
		
		Call( ErrIsamMakeKey(
					ppib,
					pfucbCatalog,
					(BYTE *)&objidFDP,
					sizeof(objidFDP),
					JET_bitNewKey ) );
		Call( ErrIsamMakeKey(
					ppib,
					pfucbCatalog,
					(BYTE *)&sysobj,
					sizeof(sysobj),
					JET_bitStrLimit ) );
		err = ErrIsamSetIndexRange( ppib, pfucbCatalog, JET_bitRangeUpperLimit );
		Assert( err <= 0 );
		while ( JET_errNoCurrentRecord != err )
			{
			Call( err );
			
			Call( (*pfnDump)( ppib, pfucbCatalog, pfnCallback, pvCallback ) );
			err = ErrIsamMove( ppib, pfucbCatalog, JET_MoveNext, NO_GRBIT );
			}
		}

	err = JET_errSuccess;

HandleError:
	CallS( ErrCATClose( ppib, pfucbCatalog ) );

	return err;
	}


//  ================================================================
LOCAL ERR ErrDBUTLDump( JET_SESID sesid, const JET_DBUTIL *pdbutil )
//  ================================================================
	{
	ERR		err;

	switch( pdbutil->edbdump )
		{
		case opEDBDumpTables:
			{
			PFNTABLE const pfntable = (PFNTABLE)( pdbutil->pfnCallback );
			err = ErrDBUTLDumpTables(
						(PIB *)sesid,
						IFMP( pdbutil->dbid ),
						pdbutil->szTable,
						pfntable,
						pdbutil->pvCallback );
			}
			break;
		case opEDBDumpIndexes:
			err = ErrDBUTLDumpTableObjects(
						(PIB *)sesid,
						IFMP( pdbutil->dbid ),
						(OBJID)pdbutil->pgno,
						sysobjIndex,
						&ErrDBUTLDumpOneIndex,
						pdbutil->pfnCallback,
						pdbutil->pvCallback );
			break;

#ifdef DEBUG			
		case opEDBDumpColumns:
			err = ErrDBUTLDumpTableObjects(
						(PIB *)sesid,
						IFMP( pdbutil->dbid ),
						OBJID( pdbutil->pgno ),
						sysobjColumn,
						&ErrDBUTLDumpOneColumn,
						pdbutil->pfnCallback,
						pdbutil->pvCallback );
			break;
		case opEDBDumpCallbacks:
			err = ErrDBUTLDumpTableObjects(
						(PIB *)sesid,
						IFMP( pdbutil->dbid ),
						OBJID( pdbutil->pgno ),
						sysobjCallback,
						&ErrDBUTLDumpOneCallback,
						pdbutil->pfnCallback,
						pdbutil->pvCallback );
			break;
		case opEDBDumpPage:
			{
			PFNPAGE const pfnpage = (PFNPAGE)( pdbutil->pfnCallback );
			err = ErrDBUTLDumpPage( (PIB *)sesid, (IFMP) pdbutil->dbid, pdbutil->pgno, pfnpage, pdbutil->pvCallback );
			}
			break;
#endif			

		default:
			Assert( fFalse );
			err = ErrERRCheck( JET_errFeatureNotAvailable );
			break;
		}
		
	return err;
	}


//  ================================================================
LOCAL ERR ErrDBUTLDumpTables( DBCCINFO *pdbccinfo, PFNTABLE pfntable )
//  ================================================================
	{
	JET_SESID	sesid 			= (JET_SESID)pdbccinfo->ppib;
	JET_DBID	dbid 			= (JET_DBID)pdbccinfo->ifmp;
	JET_DBUTIL	dbutil;

	memset( &dbutil, 0, sizeof( dbutil ) );

	dbutil.cbStruct		= sizeof( dbutil );
	dbutil.op 			= opDBUTILEDBDump;
	dbutil.sesid		= sesid;
	dbutil.dbid			= dbid;
	dbutil.pfnCallback	= (void *)pfntable;
	dbutil.pvCallback	= &dbutil;
	dbutil.edbdump		= opEDBDumpTables;
	dbutil.grbitOptions	= pdbccinfo->grbitOptions;
	
	dbutil.szTable		= ( NULL == pdbccinfo->szTable || '\0' == pdbccinfo->szTable[0] ?
								NULL :
								pdbccinfo->szTable );

	return ErrDBUTLDump( sesid, &dbutil );
	}



LOCAL ERR ErrDBUTLDumpExchangeSLVInfo( DBCCINFO	*pdbccinfo )
	{
	ERR					err;
	PIB * const			ppib			= pdbccinfo->ppib;
	const IFMP			ifmp			= pdbccinfo->ifmp;
	const CHAR * const	szTableName		= "Msg";
	const CHAR * const	szSLVColumn		= "F6659";
	FUCB *				pfucb			= pfucbNil;
	FCB *				pfcb;
	FIELD *				pfield;
	COLUMNID			columnid;
	DIB					dib;
	DATA				dataRetrieved;
	const ULONG			cbBuf			= 65536;
	VOID * const		pvBuf			= PvOSMemoryPageAlloc( cbBuf, NULL );

	if ( NULL == pvBuf )
		return ErrERRCheck( JET_errOutOfMemory );

	printf( "         Table: %s\n", szTableName );

	Call( ErrFILEOpenTable(
				ppib,
				ifmp,
				&pfucb,
				szTableName,
				JET_bitTableDenyRead|JET_bitTableReadOnly|JET_bitTableSequential ) );

	pfcb = pfucb->u.pfcb;
				
	printf( "      ObjidFDP: 0x%08x (%d)\n", pfcb->ObjidFDP(), pfcb->ObjidFDP() );
	printf( "       PgnoFDP: 0x%08x (%d)\n", pfcb->PgnoFDP(), pfcb->PgnoFDP() );
	printf( "   Column Name: %s\n", szSLVColumn );
	pfcb->EnterDML();

	//	WARNING: The following function does a LeaveDML() on error
	Call( ErrFILEPfieldFromColumnName(
				ppib,
				pfcb,
				szSLVColumn,
				&pfield,
				&columnid ) );

	if ( pfieldNil == pfield )
		{
		Call( ErrERRCheck( JET_errColumnNotFound ) );
		}
	else if ( JET_coltypSLV != pfield->coltyp )
		{
		Call( ErrERRCheck( JET_errInvalidColumnType ) );
		}

	pfcb->LeaveDML();

	printf( "      Columnid: 0x%08x (%d)\n\n", columnid, columnid );

	//	verify preread enabled
	Assert( FFUCBSequential( pfucb ) );

	dib.pos 	= posFirst;
	dib.pbm 	= NULL;
	dib.dirflag = fDIRNull;

	FUCBSetPrereadForward( pfucb, cpgPrereadSequential );
	err = ErrBTDown( pfucb, &dib, latchReadTouch );
	Assert( JET_errNoCurrentRecord != err );
	if( JET_errRecordNotFound == err )
		{
		//  the tree is empty
		err = JET_errSuccess;
		goto HandleError;
		}

	do
		{
		BOOL	fSeparated	= fFalse;

		Call( err );

		Assert( Pcsr( pfucb )->FLatched() );

		Call( ErrRECIRetrieveTaggedColumn(
				pfcb,
				columnid,
				1,
				pfucb->kdfCurr.data,
				&dataRetrieved ) );
		Assert( Pcsr( pfucb )->FLatched() );
		Assert( wrnRECLongField != err );
		Assert( wrnRECUserDefinedDefault != err );
		Assert( wrnRECSeparatedLV != err );
		Assert( wrnRECIntrinsicLV != err );

		if ( wrnRECSeparatedSLV == err )
			{
			ULONG	cbActual;

			Call( ErrBTRelease( pfucb ) );
		
			Assert( sizeof(LID) == dataRetrieved.Cb() );
			Call( ErrRECIRetrieveSeparatedLongValue(
						pfucb,
						dataRetrieved,
						fTrue,
						0,
						pvBuf,
						cbBuf,
						&cbActual,
						NO_GRBIT ) );
			CallSx( err, JET_wrnBufferTruncated );
		
			//	must re-latch record
			Assert( !Pcsr( pfucb )->FLatched() );
			Call( ErrBTIRefresh( pfucb ) );
			CallS( err );
			Assert( Pcsr( pfucb )->FLatched() );

			dataRetrieved.SetPv( pvBuf );
			dataRetrieved.SetCb( cbActual );
			fSeparated = fTrue;
			}
		else
			{
			Assert( wrnRECIntrinsicSLV == err
				|| JET_wrnColumnNull == err );
			}

		printf( "\n" );
		for ( ULONG i = 0; i < pfucb->kdfCurr.key.prefix.Cb(); i++ )
			printf( "%02x ", *( (BYTE *)( pfucb->kdfCurr.key.prefix.Pv() ) + i ) );
		for ( i = 0; i < pfucb->kdfCurr.key.suffix.Cb(); i++ )
			printf( "%02x ", *( (BYTE *)( pfucb->kdfCurr.key.suffix.Pv() ) + i ) );

		if ( dataRetrieved.Cb() > 0 )
			{
			//	UNDONE: use CSLVInfo iterator instead of this manual hack
			CSLVInfo::HEADER*	pslvinfoHdr		= (CSLVInfo::HEADER *)( dataRetrieved.Pv() );
			CSLVInfo::_RUN*		prun			= (CSLVInfo::_RUN *)( pslvinfoHdr + 1 );
			QWORD				ibVirtualPrev	= 0;
			const QWORD			cRunsMax		= ( cbBuf - sizeof(CSLVInfo::HEADER) ) / sizeof(CSLVInfo::_RUN);
			const QWORD			cRuns			= min( pslvinfoHdr->cRun, cRunsMax );

			printf( ":\n" );
			printf( "    SLV size: 0x%I64x bytes, Runs: %I64d, Separated: %s, Recoverable: %s\n",
							pslvinfoHdr->cbSize,
							pslvinfoHdr->cRun,
							( fSeparated ? "YES" : "NO" ),
							( pslvinfoHdr->fDataRecoverable ? "YES" : "NO" ) );

			for ( ULONG irun = 1; irun <= cRuns; irun++ )
				{
				const PGNO	pgnoStart	= PGNO( ( prun->ibLogical / g_cbPage ) - cpgDBReserved + 1 );
				const PGNO	pgnoEnd		= PGNO( pgnoStart + ( ( prun->ibVirtualNext - ibVirtualPrev ) / g_cbPage ) - 1 );
				printf( "    Run %d: ibVirtualNext=0x%I64x, ibLogical=0x%I64x ",
									irun,
									prun->ibVirtualNext,
									prun->ibLogical );
				Assert( pgnoEnd >= pgnoStart );
				if ( pgnoStart == pgnoEnd )
					printf( "(page %d)\n", pgnoStart );
				else
					printf( "(pages %d-%d)\n", pgnoStart, pgnoEnd );

				ibVirtualPrev = prun->ibVirtualNext;
				prun++;
				}
			if ( cRuns < pslvinfoHdr->cRun )
				printf( "    ...\n" );
			}
		else
			{
			printf( ": (NULL)\n" );
			}


		err = ErrBTNext( pfucb, fDIRNull );
		}
	while ( JET_errNoCurrentRecord != err );

	printf( "\n" );

	Assert( JET_errNoCurrentRecord == err );
	err = JET_errSuccess;

HandleError:
	if ( pfucbNil != pfucb )
		CallS( ErrFILECloseTable( ppib, pfucb ) );

	OSMemoryPageFree( pvBuf );
	return err;
	}


//  ================================================================
ERR ISAMAPI ErrIsamDBUtilities( JET_SESID sesid, JET_DBUTIL *pdbutil )
//  ================================================================
	{
	ERR		err		= JET_errSuccess;
	INST	*pinst	= PinstFromPpib( (PIB*)sesid );

	//	verify input

	Assert( pdbutil );
	Assert( pdbutil->cbStruct == sizeof( JET_DBUTIL ) );

	if ( opDBUTILEDBDump != pdbutil->op )
		{

		//	the current operation requires szDatabase != NULL

		if ( NULL == pdbutil->szDatabase || '\0' == pdbutil->szDatabase[0] )
			{
			return ErrERRCheck( JET_errDatabaseInvalidName );
			}
		}

	//	dispatch the work

	switch ( pdbutil->op )
		{
		case opDBUTILDumpLogfile:
			return ErrDUMPLog( pinst, pdbutil->szDatabase, pdbutil->grbitOptions );

#ifdef DEBUG
		case opDBUTILDumpLogfileTrackNode:
			{
			NODELOC nodeloc( pdbutil->dbid, pdbutil->pgno, pdbutil->iline );
			LGPOS	lgpos;

			lgpos.lGeneration 	= pdbutil->lGeneration;
			lgpos.isec 			= (USHORT)pdbutil->isec;
			lgpos.ib			= (USHORT)pdbutil->ib;

			return ErrDUMPLogNode( pinst, pdbutil->szDatabase, nodeloc, lgpos );
			}			

		case opDBUTILEDBDump:
            return ErrDBUTLDump( sesid, pdbutil );
            
		case opDBUTILDumpNode:
			return ErrDBUTLDumpNode( pinst->m_pfsapi, pdbutil->szDatabase, pdbutil->pgno, pdbutil->iline, pdbutil->grbitOptions );

		case opDBUTILSetHeaderState:
			return ErrDUMPHeader( pinst, pdbutil->szDatabase, fTrue );

		case opDBUTILSLVMove:
			{
			extern ERR ErrOLDSLVTest( JET_SESID sesid, JET_DBUTIL *pdbutil );
			return ErrOLDSLVTest( sesid, pdbutil );
			}

#endif	//	DEBUG

		case opDBUTILDumpPage:
			return ErrDBUTLDumpPage( pinst->m_pfsapi, pdbutil->szDatabase, pdbutil->pgno, pdbutil->grbitOptions );

		case opDBUTILDumpHeader:
			return ErrDUMPHeader( pinst, pdbutil->szDatabase );

		case opDBUTILDumpCheckpoint:
			return ErrDUMPCheckpoint( pinst, pinst->m_pfsapi, pdbutil->szDatabase );

		case opDBUTILEDBRepair:
            return ErrDBUTLRepair( sesid, pdbutil, CPRINTFSTDOUT::PcprintfInstance() );

		case opDBUTILEDBScrub:
            return ErrDBUTLScrub( sesid, pdbutil );

		case opDBUTILDBConvertRecords:
			return ErrDBUTLConvertRecords( sesid, pdbutil );

		case opDBUTILDumpData:
			return ErrESEDUMPData( sesid, pdbutil );

		case opDBUTILDBDefragment:
			{
			ERR	errDetach;

			err = ErrIsamAttachDatabase(	sesid, 
											pdbutil->szDatabase, 
											pdbutil->szSLV, 
											NULL, 
											0, 
											JET_bitDbReadOnly );
			if ( JET_errSuccess != err )
				{
				return err;
				}

			err = ErrIsamCompact(			sesid, 
											pdbutil->szDatabase, 
											pinst->m_pfsapi, 
											pdbutil->szTable, 
											pdbutil->szIndex, 
											JET_PFNSTATUS( pdbutil->pfnCallback ), 
											NULL, 
											pdbutil->grbitOptions );

			errDetach = ErrIsamDetachDatabase( sesid, NULL, pdbutil->szDatabase );

			if ( err >= JET_errSuccess && errDetach < JET_errSuccess )
				{
				err = errDetach;
				}
			}
			return err;
		}


	DBCCINFO	dbccinfo;
	IFMP		ifmp;
	JET_GRBIT	grbitAttach;

	//	setup DBCCINFO

	memset( &dbccinfo, 0, sizeof(DBCCINFO) );
	dbccinfo.tableidPageInfo 	= JET_tableidNil;
	dbccinfo.tableidSpaceInfo 	= JET_tableidNil;

	//	default to the consistency checker

	dbccinfo.op = opDBUTILConsistency;

	switch ( pdbutil->op )
		{
#ifdef DEBUG
		case opDBUTILMunge:
#endif	//	DEBUG
		case opDBUTILDumpMetaData:
		case opDBUTILDumpSpace:
		case opDBUTILDumpExchangeSLVInfo:
			dbccinfo.op = pdbutil->op;
			break;
		}

	//	copy object names

    Assert( NULL != pdbutil->szDatabase );
	strcpy( dbccinfo.szDatabase, pdbutil->szDatabase );

    if ( NULL != pdbutil->szSLV )
    	{
		strcpy( dbccinfo.szSLV, pdbutil->szSLV );
		}
	if ( NULL != pdbutil->szTable )
		{
		strcpy( dbccinfo.szTable, pdbutil->szTable );
		}
	if ( NULL != pdbutil->szIndex )
		{
		strcpy( dbccinfo.szIndex, pdbutil->szIndex );
		}

	//  propagate the grbit

	if ( pdbutil->grbitOptions & JET_bitDBUtilOptionStats )
		{
		dbccinfo.grbitOptions |= JET_bitDBUtilOptionStats;
		}
	if ( pdbutil->grbitOptions & JET_bitDBUtilOptionDumpVerbose )
		{
		dbccinfo.grbitOptions |= JET_bitDBUtilOptionDumpVerbose;
		}
		
	//	attach/open database, table and index

	grbitAttach = ( opDBUTILMunge == dbccinfo.op ) ? 0 : JET_bitDbReadOnly;
	CallR( ErrIsamAttachDatabase(	sesid, 
									dbccinfo.szDatabase, 
									( '\0' != dbccinfo.szSLV[0] ) ? dbccinfo.szSLV : NULL, 
									NULL, 
									0, 
									grbitAttach ) );
	Assert( JET_wrnDatabaseAttached != err );	// Since logging/recovery is disabled.

	ifmp = 0;
	Call( ErrIsamOpenDatabase(		sesid, 
									dbccinfo.szDatabase, 
									NULL, 
									(JET_DBID*)&ifmp, 
									JET_bitDbExclusive | grbitAttach ) );

	//	copy the session and database handles

	dbccinfo.ppib = (PIB*)sesid;
	dbccinfo.ifmp = ifmp;

	//	check database according to command line args/flags

	switch ( dbccinfo.op )
		{
		case opDBUTILConsistency:
			Call( ErrERRCheck( JET_errFeatureNotAvailable ) );

#ifdef DEAD_CODE

		//
		//	NOTE: when removing this code, be sure to remove rgcolumndefPageInfoTable if it is not used
		//		  by anyone else
		//

			//	open temporary table
			if ( dbccinfo.grbitOptions & JET_bitDBUtilOptionPageDump )
				{
				Call( ErrIsamOpenTempTable(
					(JET_SESID)dbccinfo.ppib,
					rgcolumndefPageInfoTable, 
					ccolumndefPageInfoTable,
					0,
					JET_bitTTUpdatable|JET_bitTTIndexed, 
					&dbccinfo.tableidPageInfo, 
					rgcolumnidPageInfoTable
					) );

				/// UNDONE: page dump routine is missing
				/// Call( ??? );
					
				Call( ErrDBUTLPrintPageDump( &dbccinfo ) );
				}
#endif	//	DEAD_CODE
			break;

#ifdef DEBUG
		case opDBUTILMunge:
			Call( ErrDBUTLMungeDatabase(
					dbccinfo.ppib,
					dbccinfo.ifmp,
					(char **)(pdbutil->szBackup), // over loaded by JetEdit
					(long)(pdbutil->iline),
					CPRINTFSTDOUT::PcprintfInstance() ) );
			break;
#endif	//	DEBUG

		case opDBUTILDumpSpace:
			if( rgfmp[dbccinfo.ifmp].FSLVAttached() )
				{
				printf( "****************************** SLV SPACE DUMP ******************************\n" );
				printf( "Chunk          Free Res Del Com  |------------ Used ------------|           \n" );
				printf(	"============================================================================\n" );

				CPRINTF * const pcprintf = CPRINTFSTDOUT::PcprintfInstance();
				Call( ErrDBUTLPrintSLVSpace( dbccinfo.ppib, dbccinfo.ifmp, pcprintf ) );			

				printf( "\n\n" );
				}
				
			printf( "******************************** SPACE DUMP ***********************************\n" );
			printf( "Name                   Type   ObjidFDP    PgnoFDP  PriExt      Owned  Available\n" );
			printf(	"===============================================================================\n" );
			printf( "%-23.23s Db  ", dbccinfo.szDatabase );
			cpgTotalAvailExt = 0;

			{
			CPRINTF * const pcprintf = ( pdbutil->grbitOptions & JET_bitDBUtilOptionDumpVerbose ) ?
											CPRINTFSTDOUT::PcprintfInstance() :
											NULL;

			Call( ErrDBUTLPrintSpace( dbccinfo.ppib, dbccinfo.ifmp, objidSystemRoot, pgnoSystemRoot, pcprintf ) );

			if( rgfmp[dbccinfo.ifmp].FSLVAttached() )
				{
				PGNO	pgnoSLV;
				OBJID	objidSLV;

				printf( "%-23.23s SLV ", "<SLV Avail Map>" );
				Call( ErrCATAccessDbSLVAvail(
							dbccinfo.ppib,
							dbccinfo.ifmp,
							szSLVAvail,
							&pgnoSLV,
							&objidSLV ) );
				Call( ErrDBUTLPrintSpace( dbccinfo.ppib, dbccinfo.ifmp, objidSLV, pgnoSLV, pcprintf ) );

				printf( "%-23.23s SLV ", "<SLV Owner Map>" );
				Call( ErrCATAccessDbSLVOwnerMap(
							dbccinfo.ppib,
							dbccinfo.ifmp,
							szSLVOwnerMap,
							&pgnoSLV,
							&objidSLV ) );
				Call( ErrDBUTLPrintSpace( dbccinfo.ppib, dbccinfo.ifmp, objidSLV, pgnoSLV, pcprintf ) );
				}
			}
			
			printf( "\n" );
			Call( ErrDBUTLDumpTables( &dbccinfo, PrintTableSpace ) );
			printf( "-------------------------------------------------------------------------------\n" );
			printf( "                                                                     " );
			DBUTLPrintfIntN( cpgTotalAvailExt, 10 );
			printf( "\n" );
			break;

		case opDBUTILDumpMetaData:
			printf( "******************************* META-DATA DUMP *******************************\n" );

#ifdef DEBUG
			if ( dbccinfo.grbitOptions & JET_bitDBUtilOptionDumpVerbose )
				{
				Call( ErrDBUTLDumpTables( &dbccinfo, PrintTableMetaData ) );
				}
			else
#endif			
				{
				printf( "Name                                               Type    ObjidFDP    PgnoFDP\n" );
				printf(	"==============================================================================\n" );
				printf( "%-51.51s Db   ", dbccinfo.szDatabase );
				DBUTLPrintfIntN( objidSystemRoot, 10 );
				printf( " " );
				DBUTLPrintfIntN( pgnoSystemRoot, 10 );

				if( rgfmp[dbccinfo.ifmp].FSLVAttached() )
					{
					PGNO	pgnoSLV;
					OBJID	objidSLV;

					printf( "\n%-51.51s SLV  ", "<SLV Avail Map>" );
					Call( ErrCATAccessDbSLVAvail(
								dbccinfo.ppib,
								dbccinfo.ifmp,
								szSLVAvail,
								&pgnoSLV,
								&objidSLV ) );
					DBUTLPrintfIntN( objidSLV, 10 );
					printf( " " );
					DBUTLPrintfIntN( pgnoSLV, 10 );

					printf( "\n%-51.51s SLV  ", "<SLV Owner Map>" );
					Call( ErrCATAccessDbSLVOwnerMap(
								dbccinfo.ppib,
								dbccinfo.ifmp,
								szSLVOwnerMap,
								&pgnoSLV,
								&objidSLV ) );
					DBUTLPrintfIntN( objidSLV, 10 );
					printf( " " );
					DBUTLPrintfIntN( pgnoSLV, 10 );
					}
				printf( "\n\n" );

				Call( ErrDBUTLDumpTables( &dbccinfo, PrintTableBareMetaData ) );
				}

			printf( "******************************************************************************\n" );
			break;

		case opDBUTILDumpExchangeSLVInfo:
			Call( ErrDBUTLDumpExchangeSLVInfo( &dbccinfo ) );
			break;

		default:
			err = ErrERRCheck( JET_errFeatureNotAvailable );
			Call( err );
			break;
		}

	//	terminate
HandleError:
	if ( JET_tableidNil != dbccinfo.tableidPageInfo )
		{
		Assert( dbccinfo.grbitOptions & JET_bitDBUtilOptionPageDump );
		CallS( ErrDispCloseTable( (JET_SESID)dbccinfo.ppib, dbccinfo.tableidPageInfo ) );
		dbccinfo.tableidPageInfo = JET_tableidNil;
		}
		
	if ( ifmp )
		{
		(VOID)ErrIsamCloseDatabase( sesid, (JET_DBID) ifmp, 0 );
		}

	(VOID)ErrIsamDetachDatabase( sesid, NULL, dbccinfo.szDatabase );

	fflush( stdout );
	return err;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ese98\src\ese\fcb.cxx ===
#include "std.hxx"

//	performance counters

//	"asynchronous" purging in FCB::ErrAlloc_ and 
//		FCB::FCheckFreeAndTryToLockForPurge_

PERFInstanceG<> cFCBAsyncScan;
PERFInstanceG<> cFCBAsyncPurge;
PERFInstanceG<> cFCBAsyncThresholdScan;
PERFInstanceG<> cFCBAsyncThresholdPurge;
PERFInstanceG<> cFCBAsyncPurgeConflict;

//	synchronous purging in FCB::LockForPurge_

PERFInstanceG<> cFCBSyncPurge;
PERFInstanceG<> cFCBSyncPurgeStalls;

//	FCB cache activity

PERFInstanceG<> cFCBCacheHits;
PERFInstanceG<> cFCBCacheRequests;
PERFInstanceG<> cFCBCacheStalls;

//	FCB cache sizes

PERFInstance<> cFCBCacheMax;
PERFInstance<> cFCBCachePreferred;
PERFInstanceG<> cFCBCacheAlloc;
PERFInstanceG<> cFCBCacheAllocAvail;


//	perf counter function declarations

PM_CEF_PROC LFCBAsyncScanCEFLPv;
PM_CEF_PROC LFCBAsyncPurgeCEFLPv;
PM_CEF_PROC LFCBAsyncThresholdScanCEFLPv;
PM_CEF_PROC LFCBAsyncThresholdPurgeCEFLPv;
PM_CEF_PROC LFCBAsyncPurgeConflictCEFLPv;
PM_CEF_PROC LFCBSyncPurgeCEFLPv;
PM_CEF_PROC LFCBSyncPurgeStallsCEFPLv;
PM_CEF_PROC LFCBCacheHitsCEFPLv;
PM_CEF_PROC LFCBCacheRequestsCEFLPv;
PM_CEF_PROC LFCBCacheStallsCEFLPv;
PM_CEF_PROC LFCBCacheMaxCEFLPv;
PM_CEF_PROC LFCBCachePreferredCEFLPv;
PM_CEF_PROC LFCBCacheAllocCEFLPv;
PM_CEF_PROC LFCBCacheAllocAvailCEFLPv;


//	perf counter function bodies

long LFCBAsyncScanCEFLPv( long iInstance, void* pvBuf )
	{
	cFCBAsyncScan.PassTo( iInstance, pvBuf );
	return 0;
	}

long LFCBAsyncPurgeCEFLPv( long iInstance, void* pvBuf )
	{
	cFCBAsyncPurge.PassTo( iInstance, pvBuf );
	return 0;
	}

long LFCBAsyncThresholdScanCEFLPv( long iInstance, void* pvBuf )
	{
	cFCBAsyncThresholdScan.PassTo( iInstance, pvBuf );
	return 0;
	}

long LFCBAsyncThresholdPurgeCEFLPv( long iInstance, void* pvBuf )
	{
	cFCBAsyncThresholdPurge.PassTo( iInstance, pvBuf );
	return 0;
	}

long LFCBAsyncPurgeConflictCEFLPv( long iInstance, void* pvBuf )
	{
	cFCBAsyncPurgeConflict.PassTo( iInstance, pvBuf );
	return 0;
	}

long LFCBSyncPurgeCEFLPv( long iInstance, void* pvBuf )
	{
	cFCBSyncPurge.PassTo( iInstance, pvBuf );
	return 0;
	}

long LFCBSyncPurgeStallsCEFLPv( long iInstance, void* pvBuf )
	{
	cFCBSyncPurgeStalls.PassTo( iInstance, pvBuf );
	return 0;
	}

long LFCBCacheHitsCEFLPv( long iInstance, void* pvBuf )
	{
	cFCBCacheHits.PassTo( iInstance, pvBuf );
	return 0;
	}

long LFCBCacheRequestsCEFLPv( long iInstance, void* pvBuf )
	{
	cFCBCacheRequests.PassTo( iInstance, pvBuf );
	return 0;
	}

long LFCBCacheStallsCEFLPv( long iInstance, void* pvBuf )
	{
	cFCBCacheStalls.PassTo( iInstance, pvBuf );
	return 0;
	}

long LFCBCacheMaxCEFLPv( long iInstance, void* pvBuf )
	{
	if ( NULL != pvBuf && perfinstGlobal == iInstance )
		{
		*(LONG*)pvBuf = g_lOpenTablesMax*2;
		}
	else
		{
		cFCBCacheMax.PassTo( iInstance, pvBuf );
		}
	return 0;
	}

long LFCBCachePreferredCEFLPv( long iInstance, void* pvBuf )
	{
	if ( NULL != pvBuf && perfinstGlobal == iInstance )
		{
		*(LONG*)pvBuf = g_lOpenTablesPreferredMax*2;
		}
	else
		{
		cFCBCachePreferred.PassTo( iInstance, pvBuf );
		}
	return 0;
	}

long LFCBCacheAllocCEFLPv( long iInstance, void* pvBuf )
	{
	cFCBCacheAlloc.PassTo( iInstance, pvBuf );
	return 0;
	}

long LFCBCacheAllocAvailCEFLPv( long iInstance, void* pvBuf )
	{
	cFCBCacheAllocAvail.PassTo( iInstance, pvBuf );
	return 0;
	}



//	check parameters before calling FCB::ErrFCBInit

BOOL FCB::FCheckParams( long cFCB, long cFCBPreferredThreshold )
	{
	char szPreferred[32];
	_itoa( cFCBPreferredThreshold, szPreferred, 10 );
		
	if ( cFCB < cFCBPreferredThreshold )
		{
		char szCFCB[32];
		_itoa( cFCB, szCFCB, 10 );
		
		const char *rgsz[] = {szCFCB, szPreferred};
		UtilReportEvent( eventError,
				SYSTEM_PARAMETER_CATEGORY,
				SYS_PARAM_CFCB_PREFER_ID, 
				2, 
				rgsz );
		return fFalse;
		}

	return fTrue;
	}


//	verifies that the FCB is in the correct avail list

#ifdef DEBUG
INLINE VOID FCB::AssertFCBAvailList_( const BOOL fPurging )
	{
	INST *pinst = PinstFromIfmp( Ifmp() );
	Assert( pinst->m_critFCBList.FOwner() );
	Assert( IsLocked() || fPurging );

	//	the FCB should be in both the avail-LRU list and the global list

	Assert( FInLRU() );

	//	we only allow table FCBs in the avail-LRU list
	
	Assert( FTypeTable() );

	//	get the list pointer

	FCB **ppfcbAvailMRU = pinst->PpfcbAvailMRU( FAboveThreshold() );
	FCB **ppfcbAvailLRU = pinst->PpfcbAvailLRU( FAboveThreshold() );

	//	verify the consistency of the list (it should not be empty)

	Assert( pinst->m_cFCBAvail > 0 );
	Assert( *ppfcbAvailMRU != pfcbNil );
	Assert( *ppfcbAvailLRU != pfcbNil );
	Assert( (*ppfcbAvailMRU)->PfcbMRU() == pfcbNil );
	Assert( (*ppfcbAvailLRU)->PfcbLRU() == pfcbNil );

	//	scan for the FCB

	FCB *pfcbThis = *ppfcbAvailMRU;
	while ( pfcbThis != pfcbNil )
		{
		if ( pfcbThis == this )
			break;
		pfcbThis = pfcbThis->PfcbLRU();
		}
	Assert( pfcbThis == this );
	}
#endif	//	DEBUG


//	initialize the FCB manager (per-instance initialization)

ERR FCB::ErrFCBInit( INST *pinst, INT cSession, INT cFCB, INT cTempTable, INT cFCBPreferredThreshold )
	{
	ERR				err;
	CRES 			*pcresTDBPool = NULL;
	CRES 			*pcresIDBPool = NULL;
	CRES 			*pcresFCBPool = NULL;
	BYTE			*rgbFCBHash;
	FCBHash::ERR 	errFCBHash;

	Assert( IbAlignForAllPlatforms( sizeof(TDB) ) == sizeof(TDB) );
	Assert( IbAlignForAllPlatforms( sizeof(IDB) ) == sizeof(IDB) );
	Assert( IbAlignForAllPlatforms( sizeof(FCB) ) == sizeof(FCB) );
#ifdef PCACHE_OPTIMIZATION
#ifdef _WIN64
	//	UNDONE: cache alignment for 64 bit build
#else
	Assert( sizeof(TDB) % 32 == 0 );
	Assert( sizeof(IDB) % 32 == 0 );
	Assert( sizeof(FCB) % 32 == 0 );
#endif
#endif

	//	init perf counters

	cFCBAsyncScan.Clear( pinst );
	cFCBAsyncPurge.Clear( pinst );
	cFCBAsyncThresholdScan.Clear( pinst );
	cFCBAsyncThresholdPurge.Clear( pinst );
	cFCBAsyncPurgeConflict.Clear( pinst );
	cFCBSyncPurge.Clear( pinst );
	cFCBSyncPurgeStalls.Clear( pinst );
	cFCBCacheHits.Clear( pinst );
	cFCBCacheRequests.Clear( pinst );
	cFCBCacheStalls.Clear( pinst );
	cFCBCacheMax.Set( pinst, cFCB );
	cFCBCachePreferred.Set( pinst, cFCBPreferredThreshold );
	cFCBCacheAlloc.Clear( pinst );
	cFCBCacheAllocAvail.Clear( pinst );

	//	allocate memory pools for TDBs, IDBs, and FCBs

	pcresTDBPool = new CRES( pinst, residTDB, sizeof( TDB ), cFCB + cTempTable, &err );
	if ( NULL == pcresTDBPool && err >= 0 )
		{
		err = ErrERRCheck( JET_errOutOfMemory );
		}
	Call( err );

	pcresIDBPool = new CRES( pinst, residIDB, sizeof( IDB ), cFCB + cTempTable, &err );
	if ( NULL == pcresIDBPool && err >= 0 )
		{
		err = ErrERRCheck( JET_errOutOfMemory );
		}
	Call( err );

	pcresFCBPool = new CRES( pinst, residFCB, sizeof( FCB ), cFCB, &err );
	if ( NULL == pcresFCBPool && err >= 0 )
		{
		err = ErrERRCheck( JET_errOutOfMemory );
		}
	Call( err );

	rgbFCBHash = (BYTE*)PvOSMemoryHeapAllocAlign( sizeof( FCBHash ), cbCacheLine );
	if ( NULL == rgbFCBHash  )
		{
		err = ErrERRCheck( JET_errOutOfMemory );
		}
	Call( err );
	pinst->m_pfcbhash = new( rgbFCBHash ) FCBHash( rankFCBHash );

	//	setup the preferred limit on TDBs, IDBs, and FCBs

	if ( cFCBPreferredThreshold == 0 )
		{

		//	no preferred limit
		
		cFCBPreferredThreshold = cFCB;
		}

	if ( cFCBPreferredThreshold < cFCB )
		{
		pcresTDBPool->SetPreferredThreshold( cFCBPreferredThreshold );
		pcresIDBPool->SetPreferredThreshold( cFCBPreferredThreshold );
		pcresFCBPool->SetPreferredThreshold( cFCBPreferredThreshold );
		}

	Assert( pfcbNil == (FCB *)0 );
	Assert( pinst->m_pfcbList == pfcbNil );
	Assert( pinst->m_pfcbAvailBelowMRU == pfcbNil );
	Assert( pinst->m_pfcbAvailBelowLRU == pfcbNil );
	Assert( pinst->m_pfcbAvailAboveMRU == pfcbNil );
	Assert( pinst->m_pfcbAvailAboveLRU == pfcbNil );
	pinst->m_cFCBAvail = 0;

	pinst->m_pcresTDBPool = pcresTDBPool;
	pinst->m_pcresIDBPool = pcresIDBPool;
	pinst->m_pcresFCBPool = pcresFCBPool;
	pinst->m_cFCBPreferredThreshold = cFCBPreferredThreshold;
	pinst->m_cFCBAboveThresholdSinceLastPurge = 0;

	//	initialize the FCB hash-table
	//		5.0 entries/bucket (average)
	//		uniformity ==> 1.0 (perfectly uniform)

	errFCBHash = pinst->m_pfcbhash->ErrInit( 5.0, 1.0 );
	if ( errFCBHash != FCBHash::errSuccess )
		{
		Assert( errFCBHash == FCBHash::errOutOfMemory );
		CallJ( ErrERRCheck( JET_errOutOfMemory ), FreeFCBHash );
		}

	return err;

FreeFCBHash:
	pinst->m_pfcbhash->Term();
	pinst->m_pfcbhash->FCBHash::~FCBHash();
	OSMemoryHeapFreeAlign( pinst->m_pfcbhash );
	pinst->m_pfcbhash = NULL;
	
HandleError:
	delete pcresFCBPool;
	delete pcresIDBPool;
	delete pcresTDBPool;

	return err;
	}


//	term the FCB manager (per-instance termination)

VOID FCB::Term( INST *pinst )
	{
	cFCBAsyncScan.Clear( pinst );
	cFCBAsyncPurge.Clear( pinst );
	cFCBAsyncThresholdScan.Clear( pinst );
	cFCBAsyncThresholdPurge.Clear( pinst );
	cFCBAsyncPurgeConflict.Clear( pinst );
	cFCBSyncPurge.Clear( pinst );
	cFCBSyncPurgeStalls.Clear( pinst );
	cFCBCacheHits.Clear( pinst );
	cFCBCacheRequests.Clear( pinst );
	cFCBCacheStalls.Clear( pinst );
	cFCBCacheMax.Clear( pinst );
	cFCBCachePreferred.Clear( pinst );
	cFCBCacheAlloc.Clear( pinst );
	cFCBCacheAllocAvail.Clear( pinst );

	pinst->m_pfcbList = pfcbNil;
	pinst->m_pfcbAvailBelowMRU = pfcbNil;
	pinst->m_pfcbAvailBelowLRU = pfcbNil;
	pinst->m_pfcbAvailAboveMRU = pfcbNil;
	pinst->m_pfcbAvailAboveLRU = pfcbNil;

	if ( pinst->m_pfcbhash )
		{
		pinst->m_pfcbhash->Term();
		pinst->m_pfcbhash->FCBHash::~FCBHash();
		OSMemoryHeapFreeAlign( pinst->m_pfcbhash );
		pinst->m_pfcbhash = NULL;
		}

	delete pinst->m_pcresFCBPool;
	delete pinst->m_pcresIDBPool;
	delete pinst->m_pcresTDBPool;
	}


//	allocate an FCB from the memory pool

#define PfcbFCBAlloc( pinst ) reinterpret_cast<FCB*>( pinst->m_pcresFCBPool->PbAlloc( __FILE__, __LINE__ ) )

//	free an FCB back to the memory pool

INLINE VOID FCBReleasePfcb( INST *pinst, FCB *pfcb )
	{
	pinst->m_pcresFCBPool->Release( (BYTE *)pfcb );
	}


BOOL FCB::FValid( INST *pinst ) const
	{
	return ( this >= PfcbFCBMin( pinst )
		&& this < PfcbFCBMax( pinst )
		&& 0 == ( ( (BYTE *)this - (BYTE *)PfcbFCBMin( pinst ) ) % sizeof(FCB) ) );
	}


VOID FCB::UnlinkIDB( FCB *pfcbTable )
	{
	Assert( pfcbNil != pfcbTable );
	Assert( ptdbNil != pfcbTable->Ptdb() );
	Assert( pfcbTable->FPrimaryIndex() );

	pfcbTable->AssertDDL();
	
	// If index and table FCB's are the same, then it's the primary index FCB.
	if ( pfcbTable == this )
		{
		Assert( !pfcbTable->FSequentialIndex() );
		}
	else
		{
		// Temp/sort tables don't have secondary indexes
		Assert( pfcbTable->FTypeTable() );
		
		// Only way IDB could have been linked in is if already set FCB type.
		Assert( FTypeSecondaryIndex() );
		}
		
	IDB	*pidb = Pidb();
	Assert( pidbNil != pidb );

	Assert( !pidb->FTemplateIndex() );
	Assert( !pidb->FDerivedIndex() );

	// Wait for lazy version checkers.  Verify flags set to Deleted and non-Versioned
	// to prevent future version checkers while we're waiting for the lazy ones to finish.
	Assert( pidb->FDeleted() );
	Assert( !pidb->FVersioned() );
	while ( pidb->CrefVersionCheck() > 0 )
		{
		// Since we reset the Versioned flag, there should be no further
		// version checks on this IDB.
		pfcbTable->LeaveDDL();
		UtilSleep( cmsecWaitGeneric );
		pfcbTable->EnterDDL();
		
		Assert( pidb == Pidb() );		// Verify pointer.
		}
		
	// Free index name and idxseg array, if any.
	if ( pidb->ItagIndexName() != 0 )
		{
		pfcbTable->Ptdb()->MemPool().DeleteEntry( pidb->ItagIndexName() );
		}
	if ( pidb->FIsRgidxsegInMempool() )
		{
		Assert( pidb->ItagRgidxseg() != 0 );
		pfcbTable->Ptdb()->MemPool().DeleteEntry( pidb->ItagRgidxseg() );
		}
	if ( pidb->FIsRgidxsegConditionalInMempool() )
		{
		Assert( pidb->ItagRgidxsegConditional() != 0 );
		pfcbTable->Ptdb()->MemPool().DeleteEntry( pidb->ItagRgidxsegConditional() );
		}

	ReleasePidb();
	}


//	lookup an FCB by ifmp/pgnoFDP using the FCB hash-table and pin it by
//		adding 1 to the refcnt
//
//	returns pfcbNil if the FCB does not exist (or exists but is not visible)
//
//	for FCBs that are being initialized but are not finished, this code will
//		retry repeatedly until the initialization finished with success or
//		an error-code
//
//	for FCBs that failed to initialize, they are left in place until they
//		can be purged and recycled
//
//	NOTE: this is the proper channel for accessing an FCB; it uses the locking
//		protocol setup by the FCB hash-table and FCB latch

FCB *FCB::PfcbFCBGet( IFMP ifmp, PGNO pgnoFDP, INT *pfState, const BOOL fIncrementRefCount )
	{
	INT				fState = fFCBStateNull;
	INST			*pinst = PinstFromIfmp( ifmp );
	FCB				*pfcbT;
	BOOL			fDoIncRefCount = fFalse;
	FCBHash::ERR	errFCBHash;
	FCBHash::CLock	lockFCBHash;
	FCBHashKey		keyFCBHash( ifmp, pgnoFDP );
	FCBHashEntry	entryFCBHash;
	CSXWLatch::ERR	errSXWLatch;

RetrieveFCB:

	//	lock the hash table

	pinst->m_pfcbhash->ReadLockKey( keyFCBHash, &lockFCBHash );

	//	update performance counter

	cFCBCacheRequests.Inc( pinst );

	//	try to retrieve the entry

	errFCBHash = pinst->m_pfcbhash->ErrRetrieveEntry( &lockFCBHash, &entryFCBHash );
	if ( errFCBHash == FCBHash::errSuccess )
		{

		//	update performance counter

		cFCBCacheHits.Inc( pinst );

		//	the entry exists

		Assert( entryFCBHash.m_pgnoFDP == pgnoFDP );
		pfcbT = entryFCBHash.m_pfcb;
		Assert( pfcbNil != pfcbT );
		
		//	we must declare ourselves as an owner/waiter on the exclusive latch
		//		to prevent the FCB from randomly disappearing (via the purge code)

		errSXWLatch = pfcbT->m_sxwl.ErrAcquireExclusiveLatch();
		}

	//	unlock the hash table

	pinst->m_pfcbhash->ReadUnlockKey( &lockFCBHash );

	if ( errFCBHash != FCBHash::errSuccess )
		{

		//	set the state

		if ( pfState )
			{
			*pfState = fState;
			}

		return pfcbNil;
		}

	if ( errSXWLatch == CSXWLatch::errWaitForExclusiveLatch )
		{

		//	wait to acquire the exclusive latch
		
		pfcbT->m_sxwl.WaitForExclusiveLatch();
		}

	//	we now have the FCB pinned via the latch

	if ( pfcbT->FInitialized() )
		{

		//	FCB is initialized

		CallS( pfcbT->ErrErrInit() );
		Assert( pfcbT->Ifmp() == ifmp );
		Assert( pfcbT->PgnoFDP() == pgnoFDP );

		if ( !fIncrementRefCount )
			{

			//	there is no state when "checking" the presence of the FCB
			
			Assert( pfState == NULL );
			}
		else if ( dbidTemp == rgfmp[ ifmp ].Dbid() || !pfcbT->FTypeSentinel() )
			{			
			fState = fFCBStateInitialized;

			//	increment the reference count
			
			fDoIncRefCount = fTrue;
			}
		else
			{

			//	sentinel FCBs do not get refcounted
			//	this avoids us blocking whoever created it from
			//		deleting it later

			fState = fFCBStateSentinel;
			}
		}
	else
		{

		//	the FCB is not initialized meaning it is either being 
		//		initialized now or failed somewhere in the middle
		//		of initialization

		Assert( !pinst->m_plog->m_fRecovering );

		const ERR	errInit		= pfcbT->ErrErrInit();

		//	release exclusive latch
		pfcbT->m_sxwl.ReleaseExclusiveLatch();

		if ( JET_errSuccess != errInit )
			{

			//	FCB init failed with an error code

			Assert( errInit < JET_errSuccess );
			pfcbT = pfcbNil;
			}
		else
			{

			//	FCB is not finished initializing

			//	update performance counter

			cFCBCacheStalls.Inc( pinst );

			//	wait

			UtilSleep( 10 );

			//	try to get the FCB again

			goto RetrieveFCB;
			}
		}

	if ( pfcbT != pfcbNil )
		{
		//	we found the FCB and have it locked exclusively 
		
		Assert( pfcbT->m_sxwl.FNotOwnSharedLatch() );
		Assert( pfcbT->m_sxwl.FOwnExclusiveLatch() );
		Assert( pfcbT->m_sxwl.FNotOwnWriteLatch() );

		//	increment refcount if necessary
		const BOOL	fMoveFromAvailList	= ( fDoIncRefCount ?
												pfcbT->FIncrementRefCount_() :
												fFalse );

		//	unlock the FCB
		pfcbT->m_sxwl.ReleaseExclusiveLatch();

		if ( fMoveFromAvailList )
			{
			pfcbT->MoveFromAvailList_();
			}
		}

	//	set the state

	if ( pfState )
		{
		*pfState = fState;	
		}

	//	return the FCB

	return pfcbT;
	}


//	create a new FCB
//
//	this function allocates an FCB from CRES and possibly recycles unused
//		FCBs to CRES for later use
//	once an FCB is allocated, this code uses the proper locking protocls to
//		insert it into the hash-table; no one will be able to look it up
//		until the initialization is completed successfully or with an error
//
//	WARNING: we leave this function holding the FCB lock (IsLocked() == fTrue);
//			 this is so the caller can perform further initialization before 
//			     anyone else can touch the FCB including PfcbFCBGet (this is 
//				 not currently used for anything except some Assert()s even 
//				 though it could be)

ERR FCB::ErrCreate( PIB *ppib, IFMP ifmp, PGNO pgnoFDP, FCB **ppfcb, BOOL fReusePermitted )
	{
	ERR		err;
	INST	*pinst = PinstFromPpib( ppib );

	//	prepare output

	*ppfcb = pfcbNil;

	//	acquire the creation mutex (used critical section for deadlock-detect info)

	pinst->m_critFCBCreate.Enter();

	if ( !FInHashTable( ifmp, pgnoFDP ) )
		{

		//	the entry does not yet exist, so we are guaranteed
		//		to be the first user to create this FCB

		//	try to allocate a new FCB
	
		err = ErrAlloc_( ppib, ppfcb, fReusePermitted );
		Assert( err <= 0 );
		if ( err >= JET_errSuccess )
			{
			Assert( *ppfcb != pfcbNil );
			
			FCBHash::ERR	errFCBHash;
			FCBHash::CLock	lockFCBHash;
			FCBHashKey		keyFCBHash( ifmp, pgnoFDP );
			FCBHashEntry	entryFCBHash( pgnoFDP, *ppfcb );

			//	lock the hash-table

			pinst->m_pfcbhash->WriteLockKey( keyFCBHash, &lockFCBHash );

			//	try to insert the entry

			errFCBHash = pinst->m_pfcbhash->ErrInsertEntry( &lockFCBHash, entryFCBHash );
			if ( errFCBHash == FCBHash::errSuccess )
				{

				//	the FCB is now in the hash table

				//	construct the FCB

				new( *ppfcb ) FCB( ifmp, pgnoFDP );

				//	verify the FCB

				Assert( pgnoNull == (*ppfcb)->PgnoNextAvailSE() );
				Assert( NULL == (*ppfcb)->Psplitbufdangling_() );
				Assert( (*ppfcb)->PrceOldest() == prceNil );
				
				//	set the threshold position

				Assert( !(*ppfcb)->FAboveThreshold() );
				if ( *ppfcb >= PfcbFCBPreferredThreshold( pinst ) )
					{
					(*ppfcb)->SetAboveThreshold();
					}

				Assert( (*ppfcb)->IsUnlocked() );
				if ( (*ppfcb)->FNeedLock_() )
					{

					//	declare ourselves as an owner/waiter on the exclusive latch
					//	we should immediately become the owner since we just
					//		constructed this latch AND since we are the only ones
					//		with access to it

					CSXWLatch::ERR errSXWLatch = (*ppfcb)->m_sxwl.ErrAcquireExclusiveLatch();
					Assert( errSXWLatch == CSXWLatch::errSuccess );
					}
				Assert( (*ppfcb)->IsLocked() );

				err = JET_errSuccess;
				}
			else
				{

				//	we were unable to insert the FCB into the hash table

				Assert( errFCBHash == FCBHash::errOutOfMemory );

				//	release the FCB

				FCBReleasePfcb( pinst, *ppfcb );
				*ppfcb = pfcbNil;

				//	update performance counter

				cFCBCacheAlloc.Dec( pinst );

				//	NOTE: we should never get errKeyDuplicate because only 1 person
				//		  can create FCBs at a time (that's us right now), and we
				//		  made sure that the entry did not exist when we started!

				err = ErrERRCheck( JET_errOutOfMemory );
				}

			//	unlock the hash table

			pinst->m_pfcbhash->WriteUnlockKey( &lockFCBHash );
			}
		}
	else
		{

		//	the FCB was already in the hash-table

		err = ErrERRCheck( errFCBExists );
		}

	//	unlock the creation mutex

	pinst->m_critFCBCreate.Leave();

	Assert( ( err >= JET_errSuccess && *ppfcb != pfcbNil ) ||
			( err < JET_errSuccess && *ppfcb == pfcbNil ) );
		
	return err;
	}
	

//	finish the FCB creation process by assigning an error code to the FCB
//		and setting/resetting the FInitialized flag
//
//	if the FCB is completing with error, it will be !FInitialized() and
//		the error-code will be stored in the FCB; this signals PfcbFCBGet
//		that the FCB is not "visible" even though it exists

VOID FCB::CreateComplete( ERR err )
	{
	CallSx( err, errFCBUnusable );

	//	set the initialization result

	SetErrInit( err );

	if ( JET_errSuccess == err )
		{
		Assert( !FInitialized() );

		//	initialization succeeded

		SetInitialized_();
		}
	else
		{
		//	initializtion failed

		ResetInitialized_();
		}
	}


//	allocate an FCB for FCB::ErrCreate
//
//	when an above-threshold FCB is allocated and fResuePermitted is set,
//		this code cycles through the avail-LRU list starts purging FCBs
//		that are available (there are 2 version of this purge loop: the 
//		purge-one-FCB version and the purge-as-many-as-possible version;
//		the latter only gets called once in a great while)

ERR FCB::ErrAlloc_( PIB *ppib, FCB **ppfcb, BOOL fReusePermitted )
	{
	FCB		*pfcbCandidate;
	FCB		*pfcbAboveThreshold = pfcbNil;
	INST	*pinst = PinstFromPpib( ppib );

	Assert( pinst->m_critFCBCreate.FOwner() );

	//	try to allocate an entry from the CRES pool of FCBs

	pfcbCandidate = PfcbFCBAlloc( pinst );
	if ( pfcbNil == pfcbCandidate )
		{

		//	the pool of FCBs is empty
		
		if ( !fReusePermitted )
			{

			//	we are not allowed to attempt to re-use existing FCBs
			//		(ie: recycle them from pinst->m_pfcbGlobalLRUAvail)

			//	eventually, version cleanup will free unused FCBs back
			//		to the CRES pool

			return ErrERRCheck( errFCBTooManyOpen );
			}

		//	we are allow to re-use existing FCBs, so we fall through
		//		to that code below
		
		}
	else
		{
		Assert( FAlignedForAllPlatforms( pfcbCandidate ) );
		
		//	update performance counter

		cFCBCacheAlloc.Inc( pinst );
		
		if ( pfcbCandidate >= PfcbFCBPreferredThreshold( pinst ) )
			{

			//	the FCB we allocated from CRES is above the preferred threshold

			//	ideally, we want an FCB below the threshold; to get one, we try
			//		to recycle (if we are allowed to) existing FCBs and hope
			//		that this recycling process will release an FCB below the 
			//		threshold

			Assert( PfcbFCBPreferredThreshold( pinst ) < PfcbFCBMax( pinst ) );
			pfcbAboveThreshold = pfcbCandidate;
			
			if ( !fReusePermitted )
				{

				//	we are not allowed to attempt to re-use existing FCBs
				//		(ie: recycle them from pinst->m_pfcbGlobalLRUAvail)
				//	therefore, we cannot allow use of any FCBs above the 
				//		threshold because we would never get around to
				//		recycling them later (ie: we cannot reuse them)

				//	eventually, version cleanup will free unused FCBs which
				//		are below the threshold back to the CRES pool

				//	release the above-threshold FCB that we just allocated

				FCBReleasePfcb( pinst, pfcbAboveThreshold );

				//	update performance counter

				cFCBCacheAlloc.Dec( pinst );

				return ErrERRCheck( errFCBAboveThreshold );
				}

			//	we are allowed re-use existing FCBs so that we may find one
			//		below the threshold; fall through to that code below

			//	mark the fact that we allocated an above-threshold FCB
			
			pinst->m_cFCBAboveThresholdSinceLastPurge++;
			}
		else
			{

			//	we got an FCB and it is below the threshold
			
			goto InitFCB;
			}
		}

	Assert( fReusePermitted );

	//	we were unable to get an FCB below the threshold
	//		(we may have one above the threshold)

	//	try to re-use existing FCBs

	if ( PfcbFCBPreferredThreshold( pinst ) < PfcbFCBMax( pinst ) &&
		 pinst->m_cFCBAboveThresholdSinceLastPurge > cFCBPurgeAboveThresholdInterval )
		{
		FCB *pfcbNextMRU;

		//	we have allocated a lot of FCBs above the preferred threshold 
		//		and need to recycle them to reduce the working-set size

		//	we will cycle through the avail-above list and free as many FCBs 
		//		as we can
		//	we will then free one FCB from the avail-below list

		//	reset the number of allocated FCBs

		pinst->m_cFCBAboveThresholdSinceLastPurge = 0;

		//	lock the FCB list

		pinst->m_critFCBList.Enter();

		//	examine each FCB in the avail-above and try to free it
	
		for ( pfcbCandidate = *( pinst->PpfcbAvailLRU( fTrue ) ); 
			  pfcbCandidate != pfcbNil; 
			  pfcbCandidate = pfcbNextMRU )
			{
			Assert( pfcbCandidate->FInLRU() );

			//	trap for bug x5:100491
			AssertRTL( pfcbCandidate->FTypeTable() );
			
			//	update performance counter
			
			cFCBAsyncThresholdScan.Inc( pinst );
			
			//	read the ptr to the next FCB now
			//	if we release the current FCB, this ptr will be destroyed

			pfcbNextMRU = pfcbCandidate->PfcbMRU();

			if ( pfcbCandidate->FCheckFreeAndTryToLockForPurge_( ppib ) )
				{
				Assert( pfcbCandidate->FTypeTable() );
				Assert( pfcbCandidate->FAboveThreshold() );
				Assert( FAlignedForAllPlatforms( pfcbCandidate ) );

				//	the FCB is available; release it

				pfcbCandidate->Purge( fFalse );

				//	update performance counter

				cFCBAsyncThresholdPurge.Inc( pinst );
				}
			}

		//	release the first available FCB in the avail-below list

		for ( pfcbCandidate = *( pinst->PpfcbAvailLRU( fFalse ) );
			  pfcbCandidate != pfcbNil;
			  pfcbCandidate = pfcbCandidate->PfcbMRU() )
			{
			Assert( pfcbCandidate->FInLRU() );

			//	trap for bug x5:100491
			AssertRTL( pfcbCandidate->FTypeTable() );

			//	update performance counter
			
			cFCBAsyncThresholdScan.Inc( pinst );

			if ( pfcbCandidate->FCheckFreeAndTryToLockForPurge_( ppib ) )
				{
				Assert( pfcbCandidate->FTypeTable() );
				Assert( !pfcbCandidate->FAboveThreshold() );
				Assert( FAlignedForAllPlatforms( pfcbCandidate ) );

				//	the FCB is available; release it

				pfcbCandidate->Purge( fFalse );

				//	update performance counter
			
				cFCBAsyncThresholdPurge.Inc( pinst );

				//	stop after releasing one below-threshold FCB

				break;
				}
			}
	
		//	unlock the list

		pinst->m_critFCBList.Leave();
		}
	else
		{

		//	we have not allocated very many FCBs above the preferred 
		//		threshold (OR there is no preferred threshold at all)

		//	lock the list

		pinst->m_critFCBList.Enter();

		//	scan for the first available LRU FCB we can find

		//	start scanning the avail-above list
		
		for ( pfcbCandidate = *( pinst->PpfcbAvailLRU( fTrue ) );
			  pfcbCandidate != pfcbNil;
			  pfcbCandidate = pfcbCandidate->PfcbMRU() )
			{
			Assert( pfcbCandidate->FInLRU() );

			//	trap for bug x5:100491
			AssertRTL( pfcbCandidate->FTypeTable() );

			//	update performance counter
			
			cFCBAsyncScan.Inc( pinst );

			if ( pfcbCandidate->FCheckFreeAndTryToLockForPurge_( ppib ) )
				{
				Assert( pfcbCandidate->FTypeTable() );
				Assert( pfcbCandidate->FAboveThreshold() );
				Assert( FAlignedForAllPlatforms( pfcbCandidate ) );

				//	the FCB is available; release it

				pfcbCandidate->Purge( fFalse );

				//	update performance counter
			
				cFCBAsyncPurge.Inc( pinst );

				//	stop after releasing one FCB

				goto GotOneFCB;
				}
			}

		//	we did not find an available FCB in the above-avail LRU list
		//	we must now look in the below-avail LRU list

		for ( pfcbCandidate = *( pinst->PpfcbAvailLRU( fFalse ) );
			  pfcbCandidate != pfcbNil;
			  pfcbCandidate = pfcbCandidate->PfcbMRU() )
			{
			Assert( pfcbCandidate->FInLRU() );

			//	trap for bug x5:100491
			AssertRTL( pfcbCandidate->FTypeTable() );

			//	update performance counter
			
			cFCBAsyncScan.Inc( pinst );
			
			if ( pfcbCandidate->FCheckFreeAndTryToLockForPurge_( ppib ) )
				{
				Assert( pfcbCandidate->FTypeTable() );
				Assert( !pfcbCandidate->FAboveThreshold() );
				Assert( FAlignedForAllPlatforms( pfcbCandidate ) );

				//	the FCB is available; release it

				pfcbCandidate->Purge( fFalse );

				//	update performance counter
			
				cFCBAsyncPurge.Inc( pinst );

				//	stop after releasing one FCB

				break;
				}
			}

GotOneFCB:

		//	unlock the list

		pinst->m_critFCBList.Leave();
		}

	//	try to allocate an FCB from CRES again

	pfcbCandidate = PfcbFCBAlloc( pinst );
	if ( pfcbCandidate != pfcbNil )
		{
		Assert( FAlignedForAllPlatforms( pfcbCandidate ) );

		//	update performance counter

		cFCBCacheAlloc.Inc( pinst );

		//	we got an FCB from CRES (either via version cleanup
		//		or via our re-use code)

		if ( pfcbAboveThreshold != pfcbNil )
			{

			//	we had an FCB from before, so we need to free 
			//		one of them now; free the one that is closest
			//		to the threshold

			if ( pfcbCandidate < pfcbAboveThreshold )
				{
				FCBReleasePfcb( pinst, pfcbAboveThreshold );

				//	update performance counter

				cFCBCacheAlloc.Dec( pinst );
				}
			else
				{
				FCBReleasePfcb( pinst, pfcbCandidate );

				//	update performance counter

				cFCBCacheAlloc.Dec( pinst );
				
				pfcbCandidate = pfcbAboveThreshold;
				}
			}
		}
	else if ( pfcbAboveThreshold != pfcbNil )
		{

		//	we did not get an FCB from CRES, but we had an FCB
		//		which we allocated at the start of this function

		pfcbCandidate = pfcbAboveThreshold;
		}
	else
		{

		//	we were not able to allocate any FCBs

		//	UNDONE: synchronous version-cleanup here? 
		//			OR, set a signal to start version-cleanup?

		return ErrERRCheck( JET_errTooManyOpenTables );
		}

InitFCB:	

	//	initialize the FCB
	
	FCBInitFCB( pfcbCandidate );

	//	return a ptr to the FCB

	*ppfcb = pfcbCandidate;
	
	return JET_errSuccess;
	}


//	used by ErrAlloc_ to passively check an FCB to see if it can be recycled
//
//	this will only block on the hash-table -- and since hash-table locks
//		are brief, it shouldn't block too long; locking the FCB itself
//		will not block because we only "Try" the lock
//	
//	if the FCB is available and we were able to lock it, we remove it from 
//		the hash-table (making it completely invisible); then, ErrAlloc_
//		will purge the FCB
//
//	HOW IT BECOMES COMPLETELY INVISIBLE:
//		we locked the hash-table meaning no one could hash to the FCB
//		it also means that anyone else hashing to the FCB has already
//			declared themselves as an owner/waiter on the FCB lock
//		we then TRIED locked the FCB itself
//		since we got that lock without blocking, it means no one else was
//			an owner/waiter on the FCB lock meaning no one else was looking
//			at the FCB
//		thus, if the FCB has refcnt == 0, and no outstanding versions, and
//			etc... (everything that makes it free), we can purge the FCB

BOOL FCB::FCheckFreeAndTryToLockForPurge_( PIB *ppib )
	{
	INST			*pinst = PinstFromPpib( ppib );

	Assert( pinst->m_critFCBList.FOwner() );
	Assert( FInLRU() );

	FCBHash::ERR	errFCBHash;
	FCBHash::CLock	lockFCBHash;
	FCBHashKey		keyFCBHash( Ifmp(), PgnoFDP() );
	CSXWLatch::ERR	errSXWLatch;
	BOOL			fAvail = fFalse;

	//	lock the hash table to protect the SXW latch

	pinst->m_pfcbhash->WriteLockKey( keyFCBHash, &lockFCBHash );

	//	try to acquire a write latch on the FCB

	errSXWLatch = m_sxwl.ErrTryAcquireWriteLatch();
	if ( errSXWLatch == CSXWLatch::errSuccess )
		{

		//	we have the write latch meaning there were no owners/waiters
		//		on the shared or the exclusive latch
		//	if the FCB is free, we can delete it from the hash-table and 
		//		know that no one will be touching the it

#ifdef DEBUG
		BOOL	fAbove = fFalse;
#endif	//	DEBUG

		//	check the condition of this FCB

		if ( WRefCount() == 0 &&
			 PgnoFDP() != pgnoSystemRoot &&
			 !FTypeSentinel() &&			//	sentinel FCBs are freed by RCEClean
			 !FDeletePending() &&			//	FCB with pending "delete-table" is freed by RCEClean
			 !FTemplateTable() &&
			 !FDomainDenyRead( ppib ) &&
			 !FOutstandingVersions_() &&
			 !FHasCallbacks_( pinst ) )
			{
			FCB	*pfcbIndex;

			//	check each secondary-index FCB

			for ( pfcbIndex = this; pfcbIndex != pfcbNil; pfcbIndex = pfcbIndex->PfcbNextIndex() )
				{
				if ( pfcbIndex->Pidb() != pidbNil )
					{
					// Since there is no cursor on the table,
					// no one should be doing a version check on the index
					// or setting a current secondary index.
					Assert( pfcbIndex->Pidb()->CrefVersionCheck() == 0 );
					Assert( pfcbIndex->Pidb()->CrefCurrentIndex() == 0 );
					}

				//	should never get the case where there are no table cursors and
				//	no outstanding versions on the secondary index, but there is
				//	an outstanding cursor on the secondary index
				//	UNDONE: How to check for this?
				if ( pfcbIndex->FOutstandingVersions_() || pfcbIndex->WRefCount() > 0 )
					{
					break;
					}

#ifdef DEBUG
				if ( pfcbIndex >= PfcbFCBPreferredThreshold( pinst ) )
					fAbove = fTrue;
#endif	//	DEBUG				
				}

			//	check the LV-tree FCB

			if ( pinst->m_plog->m_fRecovering && Ptdb() == ptdbNil )
				{
				Assert( pfcbNil == pfcbIndex );
				fAvail = fTrue;
				}
			else if ( pfcbNil == pfcbIndex )
				{
				Assert( Ptdb() != ptdbNil );
				FCB	*pfcbLV = Ptdb()->PfcbLV();
				if ( pfcbNil == pfcbLV )
					{
					fAvail = fTrue;
					}
				else if ( pfcbLV->FOutstandingVersions_() || pfcbLV->WRefCount() > 0 )
					{
					//	should never get the case where there are no table cursors and
					//	no outstanding versions on the LV tree, but there is an
					//	outstanding cursor on the LV tree
					//	UNDONE: How to check for this?
					}
				else
					{
					fAvail = fTrue;
#ifdef DEBUG
					if ( pfcbLV >= PfcbFCBPreferredThreshold( pinst ) )
						fAbove = fTrue;
#endif	//	DEBUG
					}
				}

			//	verify the threshold position

			Assert( FAboveThreshold() == fAbove );
			}

		if ( fAvail )
			{
			FCB *pfcbT;

			//	the FCB is ready to be purged

			//	delete the FCB from the hash table

			errFCBHash = pinst->m_pfcbhash->ErrDeleteEntry( &lockFCBHash );

			//	FCB must be in the hash table unless FDeleteCommitted is set
			
			Assert( errFCBHash == FCBHash::errSuccess || 
					( errFCBHash == FCBHash::errNoCurrentEntry && FDeleteCommitted() ) );

			//	mark all children as uninitialized so no one can hash to them
			//
			//	this will prevent the following concurrency hole:
			//		thread 1: table A is being pitched
			//		thread 1: table A's table-FCB is removed from the hash-table
			//		thread 2: table A gets reloaded from disk
			//		thread 2: when loading table A's secondary index FCBs, we see
			//				  that they alrady exist (not yet purged by thread 1)
			//				  and try to link to them even though thread 1 will
			//				  soon be purging them
			//	NOTE: since we have the table-FCB all to ourselves, no one else
			//		  should be trying to load the table or touch any of its
			//		  children FCBs -- thus, we do not need to lock them!

			pfcbT = PfcbNextIndex();
			while ( pfcbT != pfcbNil )
				{
				Assert( 0 == pfcbT->WRefCount() );
				pfcbT->CreateComplete( errFCBUnusable );
				pfcbT = pfcbT->PfcbNextIndex();
				}
			if ( Ptdb() )
				{
				if ( Ptdb()->PfcbLV() )
					{
					Assert( 0 == Ptdb()->PfcbLV()->WRefCount() );
					Ptdb()->PfcbLV()->CreateComplete( errFCBUnusable );
					}
				}
			}

		if ( errSXWLatch == CSXWLatch::errSuccess )
			{

			//	release the write latch

			m_sxwl.ReleaseWriteLatch();
			}
		}
	else
		{

		//	update performance counter

		cFCBAsyncPurgeConflict.Inc( pinst );
		}

	//	unlock hash table

	pinst->m_pfcbhash->WriteUnlockKey( &lockFCBHash );

	if ( fAvail )
		{
		FCB	*pfcbT;

		//	prepare the children of this FCB for purge
		//	NOTE: no one will be touching them because we have marked them
		//		  all as being uninitialized due to an error

		pfcbT = PfcbNextIndex();
		while ( pfcbT != pfcbNil )
			{
			Assert( !pfcbT->FInitialized() );
			Assert( errFCBUnusable == pfcbT->ErrErrInit() );
			pfcbT->PrepareForPurge( fFalse );
			pfcbT = pfcbT->PfcbNextIndex();
			}
		if ( Ptdb() )
			{
			if ( Ptdb()->PfcbLV() )
				{
				Assert( !Ptdb()->PfcbLV()->FInitialized() );
				Assert( errFCBUnusable == Ptdb()->PfcbLV()->ErrErrInit() );
				Ptdb()->PfcbLV()->PrepareForPurge( fFalse );
				}

			//	remove the entry for this table from the catalog hash
			//	NOTE: there is the possibility that after this FCB is removed from the FCB hash
			//		    someone could get to its pgno/objid from the catalog hash; this is ok
			//		    because the pgno/objid are still valid (they will be until the space
			//			they occupy is released to the space-tree)

			if ( FCATHashActive( pinst ) )
				{
				CHAR szTable[JET_cbNameMost+1];

				//	catalog hash is active so we can delete the entry 

				//	read the table name

				EnterDML();
				strcpy( szTable, Ptdb()->SzTableName() );
				LeaveDML();

				//	delete the hash-table entry

				CATHashIDelete( this, szTable );
				}
			}
		}

	return fAvail;
	}


//	remove all RCEs and close all cursors on this FCB

INLINE VOID FCB::CloseAllCursorsOnFCB_( const BOOL fTerminating )
	{
	if ( fTerminating )
		{
		//	version-clean was already attempted as part of shutdown
		//	ignore any outstanding versions and continue

		m_prceNewest = prceNil;
		m_prceOldest = prceNil;
		}

	Assert( PrceNewest() == prceNil );
	Assert( PrceOldest() == prceNil );

	//	close all cursors on this FCB
		
	FUCBCloseAllCursorsOnFCB( ppibNil, this );
	}


//	close all cursors on this FCB and its children FCBs

VOID FCB::CloseAllCursors( const BOOL fTerminating )
	{
#ifdef DEBUG	
	if ( FTypeDatabase() )
		{
		Assert( PgnoFDP() == pgnoSystemRoot );
		Assert( Ptdb() == ptdbNil );
		Assert( PfcbNextIndex() == pfcbNil );
		}
	else if ( FTypeTable() )
		{
		Assert( PgnoFDP() > pgnoSystemRoot );
		if ( Ptdb() == ptdbNil )
			{
			LOG *plog = PinstFromIfmp( Ifmp() )->m_plog;
			Assert( plog->m_fRecovering
				|| ( fTerminating && plog->m_fHardRestore ) );
			}
		}
	else if ( FTypeSentinel() )
		{
		Assert( PgnoFDP() > pgnoSystemRoot );
		Assert( Ptdb() == ptdbNil );
		Assert( PfcbNextIndex() == pfcbNil );
		}
	else if ( FTypeTemporaryTable() )
		{
		Assert( PgnoFDP() > pgnoSystemRoot );
		Assert( Ptdb() != ptdbNil );
		Assert( PfcbNextIndex() == pfcbNil );
		}
	else
		{
		Assert( FTypeSLVAvail() || FTypeSLVOwnerMap() );
		Assert( ptdbNil == Ptdb() );
		Assert( pfcbNil == PfcbNextIndex() );
		}
#endif	//	DEBUG

	if ( Ptdb() != ptdbNil )
		{
		FCB	* const pfcbLV = Ptdb()->PfcbLV();
		if ( pfcbNil != pfcbLV )
			{
			pfcbLV->CloseAllCursorsOnFCB_( fTerminating );
			}
		}

	FCB	*pfcbNext;
	for ( FCB *pfcbT = this; pfcbNil != pfcbT; pfcbT = pfcbNext )
		{
		pfcbNext = pfcbT->PfcbNextIndex();
		Assert( pfcbNil == pfcbNext
			|| ( FTypeTable()
				&& pfcbNext->FTypeSecondaryIndex()
				&& pfcbNext->PfcbTable() == this ) );

		pfcbT->CloseAllCursorsOnFCB_( fTerminating );
		}
	}


//	finish cleaning up an FCB and return it to the CRES pool
//
//	NOTE: this assumes the FCB has been locked for purging via
//		FCheckFreeAndTryToLockForPurge or PrepareForPurge

VOID FCB::Delete_( INST *pinst )
	{
	Assert( IsUnlocked() );

	//	this FCB should no longer be in either of the lists

#if defined( DEBUG ) && defined( SYNC_DEADLOCK_DETECTION )
	const BOOL fDEBUGLockList = pinst->m_critFCBList.FNotOwner();
	if ( fDEBUGLockList )
		{
		pinst->m_critFCBList.Enter();
		}
	Assert( pinst->m_critFCBList.FOwner() );
	Assert( !FInList() );
	Assert( pfcbNil == PfcbNextList() );
	Assert( pfcbNil == PfcbPrevList() );
	Assert( !FInLRU() );
	Assert( pfcbNil == PfcbMRU() );
	Assert( pfcbNil == PfcbLRU() );
	if ( fDEBUGLockList )
		{
		pinst->m_critFCBList.Leave();
		}
#endif	//	DEBUG && SYNC_DEADLOCK_DETECTION

	//	this FCB should not be in the hash table

#ifdef DEBUG
	FCB *pfcbT;
	Assert( !FInHashTable( Ifmp(), PgnoFDP(), &pfcbT ) || pfcbT != this );
#endif

	//	verify the contents of this FCB

	Assert( Ptdb() == ptdbNil );
	Assert( Pidb() == pidbNil );
	Assert( Pfucb() == pfucbNil );
	Assert( WRefCount() == 0 );
	Assert( PrceNewest() == prceNil );
	Assert( PrceOldest() == prceNil );

	//	finish cleaning up the FCB

	if ( NULL != Precdangling() )
		{
		RECDANGLING		*precdangling	= Precdangling();
		while ( NULL != precdangling )
			{
			RECDANGLING	*precToFree		= precdangling;
			
			precdangling = precdangling->precdanglingNext;

			OSMemoryHeapFree( precToFree );
			}
		}

	if ( NULL != Psplitbufdangling_() )
		{
		//	UNDONE: all space in the splitbuf is lost
		OSMemoryHeapFree( Psplitbufdangling_() );
		}


	if ( JET_LSNil != m_ls )
		{
		JET_CALLBACK	pfn		= pinst->m_pfnRuntimeCallback;

		Assert( NULL != pfn );
		(*pfn)(
			JET_sesidNil,
			JET_dbidNil,
			JET_tableidNil,
			JET_cbtypFreeTableLS,
			(VOID *)m_ls,
			NULL,
			NULL,
			NULL );
		}

	//	destruct the FCB

	this->~FCB();

	//	release the FCB to CRES

	FCBReleasePfcb( pinst, this );

	//	update performance counter

	cFCBCacheAlloc.Dec( pinst );
	}


//	force the FCB to disappear such that we can purge it without fear that
//		we will be pulling the FCB out from underneath anyone else
//
//	the FCB disappears by being removed from the hash-table using the
//		same locking protocol as FCheckFreeAndTryToLockForPurge; however,
//		this routine will block when locking the FCB to make sure that all
//		other owner/waiters will be done (we will be the last owner/waiter)

VOID FCB::PrepareForPurge( const BOOL fPrepareChildren )
	{
	INST			*pinst = PinstFromIfmp( Ifmp() );
	FCBHash::ERR	errFCBHash;
	FCBHash::CLock	lockFCBHash;
	FCBHashKey		keyFCBHash( Ifmp(), PgnoFDP() );
	CSXWLatch::ERR	errSXWLatch;

#if defined( DEBUG ) && defined( SYNC_DEADLOCK_DETECTION )

	//	lock the FCB list

	const BOOL fDBGONLYLockList = pinst->m_critFCBList.FNotOwner();

	if ( fDBGONLYLockList )
		{
		pinst->m_critFCBList.Enter();
		}

	if ( FInList() )
		{
			
		//	verify that this FCB is in the global list

		Assert( pinst->m_pfcbList != pfcbNil );

		FCB *pfcbT = pinst->m_pfcbList;
		while ( pfcbT->PgnoFDP() != PgnoFDP() || pfcbT->Ifmp() != Ifmp() )
			{
			Assert( pfcbNil != pfcbT );
			pfcbT = pfcbT->PfcbNextList();
			}
		
		if ( pfcbT != this )
			{
			Assert( rgfmp[ pfcbT->Ifmp() ].Dbid() == dbidTemp );

			//	Because we delete the table at close time when it is from Temp DB,
			//	the pgnoFDP may be reused by other threads several time already
			//	and the Purge table for each thread may not be called in LRU order.
			//	So continue search for it.

			while ( pfcbT->PgnoFDP() != PgnoFDP() || pfcbT->Ifmp() != Ifmp() || pfcbT != this )
				{
				Assert( pfcbNil != pfcbT );
				pfcbT = pfcbT->PfcbNextList();
				}

			//	Must be found
			
			Assert( pfcbT == this );
			}
		}

	//	unlock the FCB list

	if ( fDBGONLYLockList )
		{
		pinst->m_critFCBList.Leave();
		}

#endif	//	DEBUG && SYNC_DEADLOCK_DETECTION

	//	update performance counter

	cFCBSyncPurge.Inc( pinst );

#ifdef DEBUG
	DWORD cStalls = 0;
#endif	//	DEBUG

RetryLock:

	//	lock the hash table to protect the SXW latch

	pinst->m_pfcbhash->WriteLockKey( keyFCBHash, &lockFCBHash );

	//	try to acquire a write latch on the FCB

	errSXWLatch = m_sxwl.ErrTryAcquireWriteLatch();

	if ( CSXWLatch::errSuccess == errSXWLatch )
		{

		//	we got the write-latch
		//	we can now be sure that we are the only ones who can see this FCB

		//	remove the entry from the hash table regardless of whether or not
		//		we got the write latch

		errFCBHash = pinst->m_pfcbhash->ErrDeleteEntry( &lockFCBHash );

		//	FCB must be in the hash table unless FDeleteCommitted is set
			
		Assert( errFCBHash == FCBHash::errSuccess || FDeleteCommitted() );

		//	mark all children as uninitialized so no one can hash to them
		//
		//	this will prevent the following concurrency hole:
		//		thread 1: table A is being pitched
		//		thread 1: table A's table-FCB is removed from the hash-table
		//		thread 2: table A gets reloaded from disk
		//		thread 2: when loading table A's secondary index FCBs, we see
		//				  that they alrady exist (not yet purged by thread 1)
		//				  and try to link to them even though thread 1 will
		//				  soon be purging them
		//	NOTE: since we have the table-FCB all to ourselves, no one else
		//		  should be trying to load the table or touch any of its
		//		  children FCBs -- thus, we do not need to lock them!

		if ( fPrepareChildren )
			{
			FCB *pfcbT;

			pfcbT = PfcbNextIndex();
			while ( pfcbT != pfcbNil )
				{
				pfcbT->CreateComplete( errFCBUnusable );
				pfcbT = pfcbT->PfcbNextIndex();
				}
			if ( Ptdb() )
				{
				Assert( !FTypeSentinel() );
				if ( Ptdb()->PfcbLV() )
					{
					Ptdb()->PfcbLV()->CreateComplete( errFCBUnusable );
					}
				}
			}
		}

	//	unlock hash table

	pinst->m_pfcbhash->WriteUnlockKey( &lockFCBHash );

	if ( CSXWLatch::errLatchConflict == errSXWLatch )
		{

		//	we were unable to get the write-latch
		//	someone else is touching with this FCB

#ifdef DEBUG
		cStalls++;
		Assert( cStalls < 100 );
#endif	//	DEBUG

		//	update performance counter

		cFCBSyncPurgeStalls.Inc( pinst );

		//	wait

		UtilSleep( 10 );

		//	try to lock the FCB again

		goto RetryLock;
		}

	//	we have the write latch meaning there were no owners/waiters
	//		on the shared or the exclusive latch

	//	release the write latch

	m_sxwl.ReleaseWriteLatch();

	//	the FCB is now invisible and so are its children FCBs

	if ( fPrepareChildren )
		{
		if ( FTypeDatabase() || FTypeTable() || FTypeTemporaryTable() || FTypeSentinel() )
			{
			FCB *pfcbT;

			pfcbT = PfcbNextIndex();
			while ( pfcbT != pfcbNil )
				{
				Assert( !pfcbT->FInitialized() );
				Assert( errFCBUnusable == pfcbT->ErrErrInit() );
				pfcbT->PrepareForPurge( fFalse );
				pfcbT = pfcbT->PfcbNextIndex();
				}
			if ( Ptdb() )
				{
				Assert( !FTypeSentinel() );
				
				if ( Ptdb()->PfcbLV() )
					{
					Assert( !Ptdb()->PfcbLV()->FInitialized() );
					Assert( errFCBUnusable == Ptdb()->PfcbLV()->ErrErrInit() );
					Ptdb()->PfcbLV()->PrepareForPurge( fFalse );
					}
				}
			}
		}

	if ( FTypeTable() )
		{
		if ( Ptdb() )
			{

			//	remove the entry for this table from the catalog hash
			//	NOTE: there is the possibility that after this FCB is removed from the FCB hash
			//		    someone could get to its pgno/objid from the catalog hash; this is ok,
			//		    because the pgno/objid are still valid -- they become invalid AFTER the
			//			space they occupy has been released (ErrSPFreeFDP) and that NEVER happens
			//			until after the FCB is prepared for purge [ie: this function is called]

			if ( FCATHashActive( pinst ) )
				{
				CHAR szTable[JET_cbNameMost+1];

				//	catalog hash is active so we can delete the entry 

				//	read the table name

				EnterDML();
				strcpy( szTable, Ptdb()->SzTableName() );
				LeaveDML();

				//	delete the hash-table entry

				CATHashIDelete( this, szTable );
				}
			}
		}
	}


//	purge any FCB that has previously locked down via PrepareForPurge or
//		FCheckFreeAndTryToLockForPurge

VOID FCB::Purge( const BOOL fLockList, const BOOL fTerminating )
	{
	INST 	*pinst = PinstFromIfmp( Ifmp() );
#ifdef DEBUG
	FCB		*pfcbInHash;
#endif	//	DEBUG
	FCB 	*pfcbT;
	FCB		*pfcbNextT;

	if ( fLockList )
		{
		Assert( pinst->m_critFCBList.FNotOwner() );
		}
	else
		{
		//	either we already have the list locked,
		//	or this is an error during FCB creation,
		//	in which case it's guaranteed not to be
		//	in the avail or global lists
		Assert( pinst->m_critFCBList.FOwner()
			|| ( !FInLRU() && !FInList() ) );
		}
	Assert( IsUnlocked() );

	//	the refcount should be zero by now
	//		(enforce this in retail builds because those are the only
	//		 places this condition will likely arise)

	Enforce( WRefCount() == 0 );

	//	this FCB should not be in the catalog hash table

#ifdef DEBUG
	if ( FTypeTable() && Ptdb() != ptdbNil )
		{
		CHAR	szName[JET_cbNameMost+1];
		PGNO	pgnoT;
		OBJID	objidT;

		EnterDML();
		strcpy( szName, Ptdb()->SzTableName() );
		LeaveDML();
		Assert( !FCATHashLookup( Ifmp(), szName, &pgnoT, &objidT ) );
		}
#endif

	//	this FCB should not be in the FCB hash table

	Assert( !FInHashTable( Ifmp(), PgnoFDP(), &pfcbInHash ) || pfcbInHash != this );

	//	verify the members of this FCB

	Assert( WRefCount() == 0 );
	Assert( Pfucb() == pfucbNil );
	Assert( PrceOldest() == prceNil );
	Assert( PrceNewest() == prceNil );

	if ( FTypeTable() )
		{

		//	unlink the secondary-index chain

		pfcbT = PfcbNextIndex();
		SetPfcbNextIndex( pfcbNil );
		while ( pfcbT != pfcbNil )
			{

	//	ASSUME: no one will be touching these FCBs so we do not
	//			need to lock pfcbT for each one

//	we cannot make assumption about the initialized state of the FCB
//	if we are purging an FCB that was lingering due to an initialization error,
//		the error-code could be anything! also, the member data could be garbled!
//	the assumption below only accounts for initialized FCBs and FCBs which were
//		prepared-for-purge
//
//			Assert( pfcbT->FInitialized() || errFCBUnusable == pfcbT->ErrErrInit() );

			Assert( !pfcbT->FInitialized() || pfcbT->FTypeSecondaryIndex() );
			Assert( ptdbNil == pfcbT->Ptdb() );
			Assert( !pfcbT->FInitialized() || pfcbT->PfcbTable() == this );
			Assert( !FInHashTable( pfcbT->Ifmp(), pfcbT->PgnoFDP(), &pfcbInHash ) ||
					pfcbInHash != pfcbT );
			
			// Return the memory used. No need to explicitly free index
			// name or idxseg array, since memory pool will be freed when
			// TDB is deleted below.
			if ( pidbNil != pfcbT->Pidb() )
				{
				pfcbT->ReleasePidb( fTerminating );
				}
			pfcbNextT = pfcbT->PfcbNextIndex();
			pfcbT->Delete_( pinst );
			pfcbT = pfcbNextT;
			}
		}
	else
		{
		Assert( !FTypeDatabase()		|| pfcbNil == PfcbNextIndex() );
		Assert( !FTypeTemporaryTable()	|| pfcbNil == PfcbNextIndex() );
		Assert( !FTypeSort()			|| pfcbNil == PfcbNextIndex() );
		Assert( !FTypeSentinel()		|| pfcbNil == PfcbNextIndex() );
		Assert( !FTypeLV()				|| pfcbNil == PfcbNextIndex() );
		Assert( !FTypeSLVAvail()		|| pfcbNil == PfcbNextIndex() );
		Assert(	!FTypeSLVOwnerMap()		|| pfcbNil == PfcbNextIndex() );
		}

	//	delete the TDB

	if ( Ptdb() != ptdbNil )
		{
		Assert( FTypeTable() || FTypeTemporaryTable() );

		//	delete the LV-tree FCB

		pfcbT = Ptdb()->PfcbLV();
		Ptdb()->SetPfcbLV( pfcbNil );
		if ( pfcbT != pfcbNil )
			{

			//	verify the LV-tree FCB

//	we cannot make assumptions about the initialized state of the FCB
//	the FCB could have failed to be initialized because of a disk error
//		and it was left lingering meaning its member data would be garbled!
//
//			Assert( pfcbT->FInitialized() );

			Assert( !pfcbT->FInitialized() || pfcbT->FTypeLV() );
			Assert( !pfcbT->FInitialized() || pfcbT->PfcbTable() == this );
			Assert( !FInHashTable( pfcbT->Ifmp(), pfcbT->PgnoFDP(), &pfcbInHash ) ||
					pfcbInHash != pfcbT );

			pfcbT->Delete_( pinst );
			}

		Ptdb()->Delete( pinst );
		SetPtdb( ptdbNil );
		}

	//	unlink the IDB

	if ( Pidb() != pidbNil )
		{
		Assert( FTypeTable() || FTypeTemporaryTable() );

		// No need to explicitly free index name or idxseg array, since
		// memory pool was freed when TDB was deleted above.
		ReleasePidb();
		}

	if ( fLockList )
		{

		//	lock the list

		pinst->m_critFCBList.Enter();
		}

	if ( FInLRU() )
		{

		//	remove this FCB from the avail list

#ifdef DEBUG
		RemoveAvailList_( fTrue );
#else	//	!DEBUG
		RemoveAvailList_();
#endif	//	DEBUG
		}

	if ( FInList() )
		{

		//	remove this FCB from the global list

		RemoveList_();
		}

	if ( fLockList )
		{

		//	unlock the list

		pinst->m_critFCBList.Leave();
		}

	//	delete this FCB

	Delete_( pinst );
	}


//	returns fTrue when this FCB has temporary callbacks

INLINE BOOL FCB::FHasCallbacks_( INST *pinst )
	{
	if ( pinst->m_plog->m_fRecovering || g_fCallbacksDisabled )
		{
		return fFalse;
		}
		
	const CBDESC *pcbdesc = m_ptdb->Pcbdesc();
	while ( pcbdesc != NULL )
		{
		if ( !pcbdesc->fPermanent )
			{
			return fTrue;
			}
		pcbdesc = pcbdesc->pcbdescNext;
		}

	//  no callbacks, or all callbacks are in the catalog

	return fFalse;
	}



//	returns fTrue when this FCB has atlease one outstanding version

INLINE BOOL FCB::FOutstandingVersions_()
	{
	//	if we're checking the RCE list with the intent to free the FCB, we must grab
	//	the critical section first, otherwise we can get into the state where version
	//	cleanup has freed the last RCE for the FCB, but has yet to leave the critical
	//	section when we suddenly free the FCB (and hence the critical section) out
	//	from underneath him.
	ENTERCRITICALSECTION	enterCritRCEList( &CritRCEList() );
	return ( prceNil != PrceOldest() );
	}



//	free all FCBs belonging to a particular database (matching IFMP)

VOID FCB::DetachDatabase( const IFMP ifmp, BOOL fDetaching )
	{
//	Assert( dbidTemp != rgfmp[ifmp].Dbid() );
	Assert( !fDetaching ||					//	shutdown with attached db
			rgfmp[ifmp].FDetachingDB() ||	//	called by detaching db
			fGlobalRepair );				//	repair

	INST 	*pinst = PinstFromIfmp( ifmp );
	FCB		*pfcbNext;
	FCB		*pfcbThis;

	Assert( pinst->m_critFCBList.FNotOwner() );
	
	//	lock the FCB list

	pinst->m_critFCBList.Enter();

	//	scan the list for any FCB whose Ifmp() matches the given ifmp

	pfcbThis = pinst->m_pfcbList;
	while ( pfcbThis != pfcbNil )
		{

		//	get the next FCB
		
		pfcbNext = pfcbThis->PfcbNextList();

		if ( pfcbThis->Ifmp() == ifmp )
			{

			//	this FCB belongs to the IFMP that is being detached

			Assert( pfcbThis->FTypeDatabase() 		||
					pfcbThis->FTypeTable() 			||
					pfcbThis->FTypeTemporaryTable()	||
					pfcbThis->FTypeSentinel() );

			//	lock this FCB for purging

			pfcbThis->PrepareForPurge();

			//	purge this FCB

			pfcbThis->CloseAllCursors( fFalse );
			pfcbThis->Purge( fFalse );
			}

		//	move next

		pfcbThis = pfcbNext;
		}

	//	unlock the FCB list

	pinst->m_critFCBList.Leave();

#ifdef DEBUG

	//	make sure all entries for the IFMP are gone

	CATHashAssertCleanIfmp( ifmp );

#endif	//	DEBUG
	}


//	free all FCBs (within the current instance)

VOID FCB::PurgeAllDatabases( INST *pinst )
	{
	FCB 	*pfcbNext;
	FCB 	*pfcbThis;

	Assert( pinst->m_critFCBList.FNotOwner() );

	//	lock the FCB list

	pinst->m_critFCBList.Enter();

	//	scan the list for any FCB whose Ifmp() matches the given ifmp

	pfcbThis = pinst->m_pfcbList;
	while ( pfcbThis != pfcbNil )
		{

		//	get the next FCB
		
		pfcbNext = pfcbThis->PfcbNextList();

		Assert( pfcbThis->FTypeDatabase() 		||
				pfcbThis->FTypeTable() 			||
				pfcbThis->FTypeTemporaryTable()	||
				pfcbThis->FTypeSentinel() );

		//	lock this FCB for purging

		pfcbThis->PrepareForPurge();

		//	purge this FCB

		pfcbThis->CloseAllCursors( fTrue );
		pfcbThis->Purge( fFalse, fTrue );

		//	move next

		pfcbThis = pfcbNext;
		}

	//	reset the list

	pinst->m_pfcbList = pfcbNil;
	
	//	unlock the FCB list

	pinst->m_critFCBList.Leave();


	for ( DBID dbidT = dbidMin; dbidT < dbidMax; dbidT++ )
		{
		const IFMP	ifmpT	= pinst->m_mpdbidifmp[dbidT];
		if ( ifmpT < ifmpMax )
			{
			//	can't wait for SLVClose() to free SLV FCB's
			//	because all FUCB's are about to be returned
			//	to CRES
			SLVAvailMapTerm( ifmpT, fTrue );
			SLVOwnerMapTerm( ifmpT, fTrue );

#ifdef DEBUG
			//	make sure all catalog-hash entries are gone for all IFMPs 
			//	used by the current instance
			CATHashAssertCleanIfmp( ifmpT );
#endif
			}
		}
	}



//	insert this FCB into the hash-table
//		(USED ONLY BY SCBInsertHashTable!!!)

VOID FCB::InsertHashTable()
	{	
	Assert( IsLocked() || FTypeSort() );

	//	make sure this FCB is not in the hash-table

	Assert( !FInHashTable( Ifmp(), PgnoFDP() ) );
	
	INST 			*pinst = PinstFromIfmp( Ifmp() );
	FCBHash::ERR	errFCBHash;
	FCBHash::CLock	lockFCBHash;
	FCBHashKey		keyFCBHash( Ifmp(), PgnoFDP() );
	FCBHashEntry	entryFCBHash( PgnoFDP(), this );

	//	lock the key

	pinst->m_pfcbhash->WriteLockKey( keyFCBHash, &lockFCBHash );

	//	insert the entry

	errFCBHash = pinst->m_pfcbhash->ErrInsertEntry( &lockFCBHash, entryFCBHash );
	Assert( errFCBHash == FCBHash::errSuccess );

	//	unlock the key

	pinst->m_pfcbhash->WriteUnlockKey( &lockFCBHash );

#ifdef DEBUG

	//	this FCB should now be in the hash-table

	FCB *pfcbT;
	Assert( FInHashTable( Ifmp(), PgnoFDP(), &pfcbT ) );
	Assert( pfcbT == this );
#endif	//	DEBUG
	}


//	delete this FCB from the hash-table

VOID FCB::DeleteHashTable()
	{
#ifdef DEBUG

	//	make sure this FCB is in the hash-table

	FCB *pfcbT;
	Assert( FInHashTable( Ifmp(), PgnoFDP(), &pfcbT ) );
	Assert( pfcbT == this );
#endif	//	DEBUG

	INST 			*pinst = PinstFromIfmp( Ifmp() );
	FCBHash::ERR	errFCBHash;
	FCBHash::CLock	lockFCBHash;
	FCBHashKey		keyFCBHash( Ifmp(), PgnoFDP() );

	//	lock the key

	pinst->m_pfcbhash->WriteLockKey( keyFCBHash, &lockFCBHash );

	//	delete the entry

	errFCBHash = pinst->m_pfcbhash->ErrDeleteEntry( &lockFCBHash );
	Assert( errFCBHash == FCBHash::errSuccess );

	//	unlock the key

	pinst->m_pfcbhash->WriteUnlockKey( &lockFCBHash );

	//	make sure this FCB is not in the hash-table

	Assert( !FInHashTable( Ifmp(), PgnoFDP() ) );
	}


//	validate the refcount of the FCB

INLINE VOID AssertFCBRefCount( FCB *pfcb )
	{
#ifdef DEBUG

	Assert( pfcb->IsLocked() );
	
	ULONG			cfcb = 0;
	const ULONG		refcnt = pfcb->WRefCount();
	FUCB			*pfucbT;

	for ( pfucbT = pfcb->Pfucb(); pfucbT != pfucbNil; pfucbT = pfucbT->pfucbNextOfFile )
		{
		Assert( cfcb < refcnt );
		cfcb++;
		}

	//	the refcount may actually be higher than the number of cursors on this FCB because sometimes we
	//	artificially increase the refcnt when we just want to pin the FCB momentarily.

	Assert( cfcb <= refcnt );
	Assert( refcnt == pfcb->WRefCount() );
#endif	//	DEBUG
	}


//	link an FUCB to this FCB

VOID FCB::Link( FUCB *pfucb )
	{
	Assert( pfucb != pfucbNil );
	Assert( IsUnlocked() );

#ifdef DEBUG
	if ( rgfmp[ Ifmp() ].Dbid() == dbidTemp && !FTypeNull() )
		{
		if ( PgnoFDP() == pgnoSystemRoot )
			{
			Assert( FTypeDatabase() );
			}
		else
			{
		 	Assert( FTypeTemporaryTable() || FTypeSort() || FTypeSLVAvail() || FTypeSLVOwnerMap() );
		 	}
		 }

	//	if this FCB has a refcount of 0, it should not be purgable
	//	otherwise, it could be purged while we are trying to link an FUCB to it!

	INST *pinst = PinstFromIfmp( Ifmp() );
	Assert( pinst->m_critFCBList.FNotOwner() );

	pinst->m_critFCBList.Enter();
	if ( FInLRU() )
		{

		//	FCB is in the avail-LRU list meaning it has the potential to be purged

		Lock();
		if ( WRefCount() == 0 &&
			 PgnoFDP() != pgnoSystemRoot &&
			 !FTypeSentinel() &&			//	sentinel FCBs are freed by RCEClean
			 !FDeletePending() &&			//	FCB with pending "delete-table" is freed by RCEClean
			 !FTemplateTable() &&
			 //!FDomainDenyRead( ppib ) &&
			 !FOutstandingVersions_() &&
			 !FHasCallbacks_( pinst ) )
			{

			//	FCB is ready to be purged -- this is very bad
			//
			//	whoever the caller is, they are calling Link() on an FCB which
			//		could disappear at any moment because its in the avail-LRU
			//		list and its purge-able
			//
			//	this is a bug in the caller...

			//	NOTE: this may have been reached in error!
			//		  if the FCB's FDomainDenyRead counter is set, this is a bad
			//			 assert (I couldn't call FDomainDenyRead without a good ppib)

			AssertTracking();
			}
		Unlock();
		}
	pinst->m_critFCBList.Leave();

#endif	//	DEBUG

	//	lock the FCB

	Lock();

#ifdef DEBUG

	//	verify the refcount

	AssertFCBRefCount( this );
#endif	//	DEBUG

	//	increment the refcount

	const BOOL	fMoveFromAvailList	= FIncrementRefCount_();

	if ( !fMoveFromAvailList )
		{

		//	we did not defer the refcount of this FCB
		
		//	link the FUCB
		
		pfucb->u.pfcb = this;
		pfucb->pfucbNextOfFile = Pfucb();
		SetPfucb( pfucb );

#ifdef DEBUG

		//	verify the refcount again

		Assert( WRefCount() > 0 );
		AssertFCBRefCount( this );
#endif	//	DEBUG
		}

	//	unlock the FCB

	Unlock();

	if ( fMoveFromAvailList )
		{
		INST *pinst = PinstFromIfmp( Ifmp() );
		Assert( pinst->m_critFCBList.FNotOwner() );

		//	lock the list

		pinst->m_critFCBList.Enter();

		//	lock the FCB again

		Lock();

		//	link the FUCB
		
		pfucb->u.pfcb = this;
		pfucb->pfucbNextOfFile = Pfucb();
		SetPfucb( pfucb );

		//	verify the refcount again

		Assert( WRefCount() > 0 );
		AssertFCBRefCount( this );

		//	refcnt just went from 0 to 1 so this FCB should be removed
		//		from the avail-LRU list
		//	NOTE: if the FCB was just created, it will not be in the list

		if ( FInLRU() )
			{
			//	remove this FCB from the avail list
			RemoveAvailList_();
			}

		//	unlock the FCB

		Unlock();

		//	unlock the list
				
		pinst->m_critFCBList.Leave();
		}
	}



//  ================================================================
VOID FCB::AttachRCE( RCE * const prce )
//  ================================================================
//
//  Add a newly created RCE to the head of the RCE queue. Increments
//  the version refcount on the FCB
//
//-
	{
	Assert( CritRCEList().FOwner() );

	Assert( prce->Ifmp() == Ifmp() );
	Assert( prce->PgnoFDP() == PgnoFDP() );

	if ( prce->Oper() != operAddColumn )
		{
		// UNDONE: Don't hold pfcb->CritFCB() over versioning of AddColumn
		Assert( IsUnlocked() );
		}
	
	Assert( (prceNil == m_prceNewest) == (prceNil == m_prceOldest) );

	prce->SetPrceNextOfFCB( prceNil );
	prce->SetPrcePrevOfFCB( m_prceNewest );
	if( prceNil != m_prceNewest )
		{
		Assert( m_prceNewest->PrceNextOfFCB() == prceNil );
		m_prceNewest->SetPrceNextOfFCB( prce );
		}
	m_prceNewest = prce;
	if( prceNil == m_prceOldest )
		{
		m_prceOldest = prce;
		}

	Assert( PrceOldest() != prceNil );
	Assert( prceNil != m_prceNewest );
	Assert( prceNil != m_prceOldest );
	Assert( m_prceNewest == prce );
	Assert( this == prce->Pfcb() );
	}


//  ================================================================
VOID FCB::DetachRCE( RCE * const prce )
//  ================================================================
//
//  Removes the RCE from the queue of RCEs held in the FCB. Decrements
//  the version count of the FCB
//
//-
	{
	Assert( CritRCEList().FOwner() );
	Assert( IsUnlocked() );
	
	Assert( this == prce->Pfcb() );
	Assert( prce->Ifmp() == Ifmp() );
	Assert( prce->PgnoFDP() == PgnoFDP() );

	Assert( PrceOldest() != prceNil );
	Assert( prceNil != m_prceNewest );
	Assert( prceNil != m_prceOldest );

	if( prce == m_prceNewest || prce == m_prceOldest )
		{
		//  at the head/tail of the list
		Assert( prceNil == prce->PrceNextOfFCB() || prceNil == prce->PrcePrevOfFCB() );
		if( prce == m_prceNewest )
			{
			Assert( prce->PrceNextOfFCB() == prceNil );
			m_prceNewest = prce->PrcePrevOfFCB();
			if( prceNil != m_prceNewest )
				{
				m_prceNewest->SetPrceNextOfFCB( prceNil );
				}
			}
		if( prce == m_prceOldest )
			{
			Assert( prce->PrcePrevOfFCB() == prceNil );
			m_prceOldest = prce->PrceNextOfFCB();
			if ( prceNil != m_prceOldest )
				{
				m_prceOldest->SetPrcePrevOfFCB( prceNil );
				}
			}
		}
	else
		{
		//  in the middle of the list
		Assert( prceNil != prce->PrceNextOfFCB() );
		Assert( prceNil != prce->PrcePrevOfFCB() );

		RCE * const prceNext = prce->PrceNextOfFCB();
		RCE * const prcePrev = prce->PrcePrevOfFCB();
		
		prceNext->SetPrcePrevOfFCB( prcePrev );
		prcePrev->SetPrceNextOfFCB( prceNext );
		}
		
	prce->SetPrceNextOfFCB( prceNil );
	prce->SetPrcePrevOfFCB( prceNil );

	Assert( ( prceNil == m_prceNewest ) == ( prceNil == m_prceOldest ) );
	Assert( prce->PrceNextOfFCB() == prceNil );
	Assert( prce->PrcePrevOfFCB() == prceNil );
	}
	

//	unlink an FUCB from this FCB

INLINE VOID FCB::Unlink( FUCB *pfucb, const BOOL fPreventMoveToAvail )
	{
	Assert( pfucb != pfucbNil );
	Assert( pfucb->u.pfcb != pfcbNil );
	Assert( this == pfucb->u.pfcb );

#ifdef DEBUG

	//	we do not need CritFCB() to check these flags because they are immutable
	
	if ( rgfmp[ Ifmp() ].Dbid() == dbidTemp && !FTypeNull() )
		{
		if ( PgnoFDP() == pgnoSystemRoot )
			{
			Assert( FTypeDatabase() );
			}
		else
			{
		 	Assert( FTypeTemporaryTable() || FTypeSort() || FTypeSLVAvail() || FTypeSLVOwnerMap() );
		 	}
		 }
#endif	//	DEBUG

	//	lock this FCB
	
	Lock();

#ifdef DEBUG

	//	verify the refcount
	
	Assert( WRefCount() > 0 );
	AssertFCBRefCount( this );
#endif	//	DEBUG

	//	unlink the FCB backpointer from the FUCB 

	pfucb->u.pfcb = pfcbNil;

	//	scan the list of FUCBs linked to this FCB and
	//		remove the given FUCB from that list

	Assert( Pfucb() != pfucbNil );

	FUCB *pfucbCurr = Pfucb();
	FUCB *pfucbPrev = pfucbNil;
	while ( pfucbCurr != pfucb )
		{
		if ( pfucbNil == pfucbCurr )
			{
			//	FUCB is linked to this FCB, but FCB has no record of this cursor in
			//	its cursor chain.
			FireWall();

			//	unlock the FCB

			Unlock();

			return;
			}

		pfucbPrev = pfucbCurr;
		pfucbCurr = pfucbCurr->pfucbNextOfFile;
		Assert( pfucbCurr != pfucbNil );
		}
		
	if ( pfucbNil == pfucbPrev )
		{

		//	the FUCB was at the head of the list
		
		SetPfucb( pfucbCurr->pfucbNextOfFile );
		}
	else
		{

		//	the FUCB was not at the head of the list
		
		pfucbPrev->pfucbNextOfFile = pfucbCurr->pfucbNextOfFile;
		}

	//	decrement the refcount of this FCB

	const BOOL fMoveToAvailList = FDecrementRefCount_( !fPreventMoveToAvail );

#ifdef DEBUG

	//	verify the refcount
	
	Assert( WRefCount() >= 0 );
	AssertFCBRefCount( this );
#endif	//	DEBUG

	//	unlock this FCB 
	
	Unlock();

	if ( fMoveToAvailList )
		{	
		INST *pinst = PinstFromIfmp( Ifmp() );
		Assert( pinst->m_critFCBList.FNotOwner() );

		//	lock the list

		pinst->m_critFCBList.Enter();

		//	the FCB should not already be in the avail-LRU list because it has
		//		atleast one outstanding refcnt decrement (this one)

		Assert( !FInLRU() );

		//	lock the FCB

		Lock();

		//	decrement the refcount

		DeferredDecrementRefCount_();

#ifdef DEBUG

		//	verify the refcount
	
		Assert( WRefCount() >= 0 );
		AssertFCBRefCount( this );
#endif	//	DEBUG

		if ( WRefCount() == 0 )
			{

			//	the refcnt just went from 1 to 0 so it will be moving into the
			//		avail-LRU list (should not already be there)
			
			//	insert this FCB into the avail list at the MRU position

			InsertAvailListMRU_();
			}
		else
			{
			//	the refcnt did not get incremented from 0 and should not be in the
			//		avail-LRU list
			}

		//	unlock the FCB

		Unlock();

		//	unlock the list
		
		pinst->m_critFCBList.Leave();
		}
	}


//	unlink an FUCB from its FCB and possibly move the FCB into
//		the avail LRU list

VOID FCBUnlink( FUCB *pfucb )
	{
	Assert( pfucbNil != pfucb );
	Assert( pfcbNil != pfucb->u.pfcb );
	pfucb->u.pfcb->Unlink( pfucb, fFalse );
	}


//	unlink an FUCB from its FCB and do not move the FCB to
//		the avail LRU list

VOID FCBUnlinkWithoutMoveToAvailList( FUCB *pfucb )
	{
	Assert( pfucbNil != pfucb );
	Assert( pfcbNil != pfucb->u.pfcb );
	pfucb->u.pfcb->Unlink( pfucb, fTrue );
	}


ERR FCB::ErrSetUpdatingAndEnterDML( PIB *ppib, BOOL fWaitOnConflict )
	{
	ERR	err = JET_errSuccess;
	
	Assert( IsUnlocked() );
	
	// If DDL is fixed, then there's no contention with CreateIndex
	if ( !FFixedDDL() )
		{
		Assert( FTypeTable() );				// Sorts and temp tables have fixed DDL.
		Assert( !FTemplateTable() );
		Assert( Ptdb() != ptdbNil );
		
CheckIndexing:
		Ptdb()->EnterUpdating();
		EnterDML_();

		// SPECIAL CASE: Cannot update an uncommitted primary index if
		// it doesn't belong to us.
		if ( Pidb() != pidbNil && Pidb()->FVersionedCreate() )
			{
			err = ErrFILEIAccessIndex( ppib, this, this );
			if ( JET_errIndexNotFound == err )
				{
				LeaveDML_();
				ResetUpdating_();

				if ( fWaitOnConflict )
					{
					// Abort update and wait for primary index to commit or
					// rollback.  We're guaranteed the FCB will still exist
					// because we have a cursor open on it.
					UtilSleep( cmsecWaitGeneric );
					err = JET_errSuccess;
					goto CheckIndexing;
					}
				else
					{
					err = ErrERRCheck( JET_errWriteConflictPrimaryIndex );
					}
				}
			}
		}
		
	return err;
	}



ERR FCB::ErrSetDeleteIndex( PIB *ppib )
	{
	Assert( FTypeSecondaryIndex() );
	Assert( !FDeletePending() );
	Assert( !FDeleteCommitted() );
	Assert( PfcbTable() != pfcbNil );
	Assert( PfcbTable()->FTypeTable() );
	Assert( Pidb() != pidbNil );
	Assert( !Pidb()->FDeleted() );
	PfcbTable()->AssertDDL();

	Assert( Pidb()->CrefCurrentIndex() <= WRefCount() );

	if ( Pidb()->CrefCurrentIndex() > 0 )
		{
		return ErrERRCheck( JET_errIndexInUse );
		}

	Assert( !PfcbTable()->FDomainDenyRead( ppib ) );
	if ( !PfcbTable()->FDomainDenyReadByUs( ppib ) )
		{
		Pidb()->SetFVersioned();
		}
	Pidb()->SetFDeleted();
	
	SetDomainDenyRead( ppib );
	SetDeletePending();

	return JET_errSuccess;
	}



ERR VTAPI ErrIsamRegisterCallback(
	JET_SESID 		vsesid,
	JET_VTID		vtid,
	JET_CBTYP		cbtyp, 
	JET_CALLBACK	pCallback,
	VOID			*pvContext,
	JET_HANDLE		*phCallbackId )
	{	
 	PIB		* const ppib	= reinterpret_cast<PIB *>( vsesid );
	FUCB	* const pfucb	= reinterpret_cast<FUCB *>( vtid );

	Assert( pfucb != pfucbNil );
	CheckTable( ppib, pfucb );

	ERR	err = JET_errSuccess;

	if( JET_cbtypNull == cbtyp
		|| NULL == pCallback
		|| NULL == phCallbackId )
		{
		return ErrERRCheck( JET_errInvalidParameter );
		}

	CallR( ErrPIBCheck( ppib ) );
	CallR( ErrIsamBeginTransaction( vsesid, NO_GRBIT ) );
	
	CBDESC * const pcbdescInsert = new CBDESC;
	if( NULL != pcbdescInsert )
		{
		FCB * const pfcb = pfucb->u.pfcb;
		Assert( NULL != pfcb );
		TDB * const ptdb = pfcb->Ptdb();
		Assert( NULL != ptdb );

		*phCallbackId = (JET_HANDLE)pcbdescInsert;
		
		pcbdescInsert->pcallback 	= pCallback;
		pcbdescInsert->cbtyp 		= cbtyp;
		pcbdescInsert->pvContext	= pvContext;
		pcbdescInsert->cbContext	= 0;
		pcbdescInsert->ulId			= 0;
		pcbdescInsert->fPermanent	= fFalse;

#ifdef VERSIONED_CALLBACKS
		pcbdescInsert->fVersioned	= !rgfmp[pfucb->ifmp].FVersioningOff();

		pcbdescInsert->trxRegisterBegin0	=	ppib->trxBegin0;
		pcbdescInsert->trxRegisterCommit0	=	trxMax;
		pcbdescInsert->trxUnregisterBegin0	=	trxMax;
		pcbdescInsert->trxUnregisterCommit0	=	trxMax;

		VERCALLBACK vercallback;
		vercallback.pcallback 	= pcbdescInsert->pcallback;
		vercallback.cbtyp 		= pcbdescInsert->cbtyp;
		vercallback.pvContext 	= pcbdescInsert->pvContext;
		vercallback.pcbdesc 	= pcbdescInsert;	

		if( pcbdescInsert->fVersioned )
			{
			VER *pver = PverFromIfmp( pfucb->ifmp );
			err = pver->ErrVERFlag( pfucb, operRegisterCallback, &vercallback, sizeof( VERCALLBACK ) );
			}
#else
		pcbdescInsert->fVersioned	= fFalse;
#endif	//	DYNAMIC_CALLBACKS		

		if( err >= 0 )
			{
			pfcb->EnterDDL();
			ptdb->RegisterPcbdesc( pcbdescInsert );		
			pfcb->LeaveDDL();		
			}
		}
	else
		{
		err = ErrERRCheck( JET_errOutOfMemory );
		*phCallbackId = 0xFFFFFFFA;
		}	

	if( err >= 0 )
		{
		err = ErrIsamCommitTransaction( vsesid, NO_GRBIT );
		}
	if( err < 0 )
		{
		CallS( ErrIsamRollback( vsesid, NO_GRBIT ) );
		}
	return err;
	}
	

ERR VTAPI ErrIsamUnregisterCallback(
	JET_SESID 		vsesid,
	JET_VTID		vtid,
	JET_CBTYP		cbtyp, 
	JET_HANDLE		hCallbackId )
	{
 	PIB		* const ppib 	= reinterpret_cast<PIB *>( vsesid );
	FUCB	* const pfucb 	= reinterpret_cast<FUCB *>( vtid );
	
	ERR		err = JET_errSuccess;

	//	check input
	CallR( ErrPIBCheck( ppib ) );
	Assert( pfucb != pfucbNil );
	CheckTable( ppib, pfucb );

	//	the callback id is a pointer to the CBDESC to remove
	
	FCB * const pfcb = pfucb->u.pfcb;
	Assert( NULL != pfcb );
	TDB * const ptdb = pfcb->Ptdb();
	Assert( NULL != ptdb );

	CBDESC * const pcbdescRemove = (CBDESC *)hCallbackId;
	Assert( !pcbdescRemove->fPermanent );
	Assert( JET_cbtypNull != pcbdescRemove->cbtyp );
	Assert( NULL != pcbdescRemove->pcallback );

	CallR( ErrIsamBeginTransaction( vsesid, NO_GRBIT ) );

#ifndef VERSIONED_CALLBACKS
	Assert( !pcbdescRemove->fVersioned );
#else	//	!VERSIONED_CALLBACKS

	VERCALLBACK vercallback;
	vercallback.pcallback 	= pcbdescRemove->pcallback;
	vercallback.cbtyp 		= pcbdescRemove->cbtyp;
	vercallback.pvContext 	= pcbdescRemove->pvContext;
	vercallback.pcbdesc 	= pcbdescRemove;	

	if( pcbdescRemove->fVersioned )
		{
		VER *pver = PverFromIfmp( pfucb->ifmp );
		err = pver->ErrVERFlag( pfucb, operUnregisterCallback, &vercallback, sizeof( VERCALLBACK ) );
		if( err >= 0 )
			{
			pfcb->EnterDDL();
			pcbdescRemove->trxUnregisterBegin0 = ppib->trxBegin0;		
			pfcb->LeaveDDL();		
			}
		}
	else
		{
#endif	//	VERSIONED_CALLBACKS

		//  unversioned
		pfcb->EnterDDL();
		ptdb->UnregisterPcbdesc( pcbdescRemove );
		pfcb->LeaveDDL();		
		delete pcbdescRemove;

#ifdef VERSIONED_CALLBACKS
		}
#endif	//	VERSIONED_CALLBACKS

	if( err >= 0 )
		{
		err = ErrIsamCommitTransaction( vsesid, NO_GRBIT );
		}
	if( err < 0 )
		{
		CallS( ErrIsamRollback( vsesid, NO_GRBIT ) );
		}
	return err;
	}

	
#ifdef DEBUG
VOID FCBAssertAllClean( INST *pinst )
	{
	FCB	*pfcbT;

	//	lock the FCB list

	pinst->m_critFCBList.Enter();

	//	verify that all FCB's have been cleaned and there are no outstanding versions.
	
	for ( pfcbT = pinst->m_pfcbList; pfcbT != pfcbNil; pfcbT = pfcbT->PfcbNextList() )
		{
		Assert( pfcbT->PrceOldest() == prceNil );
		}

	//	unlock the FCB list

	pinst->m_critFCBList.Leave();
	}
#endif


//	public API to increment the refcount of an FCB directly
//
//	this allows you to bypass PfcbFCBGet (the proper lookup function)
//		under the assumption that the FCB you are refcounting will
//		not suddenly disappear (e.g. you own a cursor on it or know 
//		for a fact that someone else does and they will not close it)
VOID FCB::IncrementRefCount()
	{
	Assert( IsUnlocked() );

	//	lock the FCB
	Lock();

	//	increment the refcount
	const BOOL	fMoveFromAvailList	= FIncrementRefCount_();

	//	unlock the FCB
	Unlock();


	//	if necessary, move to AvailList (requires entering
	//	critFCBList, which is why we have to leave the
	//	FCB Lock first)
	if ( fMoveFromAvailList )
		{
		MoveFromAvailList_();
		}
	}


// public API to Move FCB from Available List
//	================================================================
VOID FCB::MoveFromAvailList_()
//	================================================================
	{
	INST* const		pinst = PinstFromIfmp( Ifmp() );

	//	lock the list
	Assert( pinst->m_critFCBList.FNotOwner() );
	pinst->m_critFCBList.Enter();

	//	lock the FCB
	Lock();

	//	verify the refcount again
	Assert( WRefCount() > 0 );
	AssertFCBRefCount( this );

	//	refcnt went from 0 to 1 so this FCB should be removed
	//		from the avail-LRU list
	if ( FInLRU() )
		{
		//	remove this FCB from the avail list
		RemoveAvailList_();
		}
	else
		{
		//	this is the case where the FCB was just created and its
		//		refcount == 0
		//	NOTE: this should be impossible to hit because every FCB
		//		that gets created will have a refcount of 1 when
		//		it is finished with CreateComplete; therefore, every 
		//		FCB whose refcount == 0 got that way due to a 
		//		refcnt-- meaning that FCB is in the avail-LRU list
		AssertTracking();
		}

	//	unlock the FCB
	Unlock();

	//	unlock the list
	pinst->m_critFCBList.Leave();
	}


//	decrement the refcount of an FCB directly
//
//	if refcnt goes from 1 to 0, the FCB is moved into the avail-LRU list
//
//	this is only used by FCB::Release (though other forms are used elsewhere
//		such as in FCB::Unlink())

VOID FCB::DecrementRefCount_()
	{
	Assert( IsUnlocked() );

	//	lock the FCB

	Lock();

	//	increment the refcount
	
	const BOOL fMoveToAvailList = FDecrementRefCount_();

	//	unlock the FCB

	Unlock();

	if ( fMoveToAvailList )
		{
		INST *pinst = PinstFromIfmp( Ifmp() );
		Assert( pinst->m_critFCBList.FNotOwner() );

		//	lock the list

		pinst->m_critFCBList.Enter();

		//	the FCB should not already be in the avail-LRU list because it has
		//		atleast one outstanding refcnt decrement (this one)

		Assert( !FInLRU() );

		//	lock the FCB

		Lock();

		//	decrement the refcount (deferred from FDecrementRefCount_)

		DeferredDecrementRefCount_();
		
		if ( WRefCount() == 0 )
			{

			//	the refcnt just went from 1 to 0 so it will be moving into the
			//		avail-LRU list (should not already be there)
			
			//	insert this FCB into the avail list at the MRU position

			InsertAvailListMRU_();
			}
		else
			{
			//	the refcnt did not get incremented from 0 and should not be in the
			//		avail-LRU list
			}

		//	unlock the FCB

		Unlock();

		//	unlock the list
		
		pinst->m_critFCBList.Leave();
		}
	}


//	increment the refcount of the FCB
//
//	if the FCB's refcnt went from 0 to 1 and the FCB is of type 
//		table/database/sentinel, fTrue will be returned
//	otherwise, fFalse will be returned
//
//	the return value fTrue means the refcount operation has changed the
//		availability of the FCB (e.g. the FCB could be in the avail-LRU
//		list but it is no longer "available" because it has a refcount);
//		thus, it is the signal to the caller that the FCB should be 
//		removed from the avail-LRU list immediately
//

INLINE BOOL FCB::FIncrementRefCount_()
	{
	Assert( IsLocked() );

	const INT	wRefCountInitial	= m_wRefCount;
	Assert( wRefCountInitial == WRefCount() );

	//	do the increment now

	Assert( WRefCount() >= 0 );
	m_wRefCount++;
	Assert( WRefCount() > 0 );

	//	no one should be updating the refcount without the FCB lock
	Assert( WRefCount() == wRefCountInitial + 1 );

	return ( 0 == wRefCountInitial && FTypeTable() );
	}


//	try to decrement the refcount of the FCB
//
//	if the FCB's current refcnt == 0 and the FCB is of type 
//		table/database/sentinel and fWillMoveToAvailList is set, 
//		the refcount will NOT be decremented and fTrue will be returned
//	otherwise, the refcnt will be decremented and fFalse will be returned
//
//	the return value fTrue means the refcount operation was deferred
//		so that the avail-LRU list could be locked to insert the FCB
//		at the exact moment its refcount changes from 1 to 0
//
//	the predicate fWillMoveToAvailList tell this function whether or not
//		the FCB being decremented will in fact be moving to the avail-LRU
//		list or not; in the case where the FCB is NOT moving to the
//		avail-LRU list (for whatever reason), this code will not defer
//		the decrement because there is no need to lock the avail-LRU list

INLINE BOOL FCB::FDecrementRefCount_( const BOOL fWillMoveToAvailList )
	{
	Assert( IsLocked() );
	
	if ( !fWillMoveToAvailList || WRefCount() != 1 || !FTypeTable() )
		{
	
		//	decrement the refcount now

		Assert( WRefCount() > 0 );
		m_wRefCount--;
		Assert( WRefCount() >= 0 );

		return fFalse;
		}

	//	defer the decrement until we lock the avail-LRU list

	return fTrue;
	}


//	do the deferred refcount decrement from a previous call to 
//		FDecrementRefCount_
//
//	NOTE: this should only be called with the avail-LRU list locked
//		  also, it should only be called by FCBs that can enter/leave
//		      the avail-LRU list

INLINE VOID FCB::DeferredDecrementRefCount_()
	{
	Assert( PinstFromIfmp( Ifmp() )->m_critFCBList.FOwner() );
	Assert( IsLocked() );
	Assert( FTypeTable() );

	Assert( WRefCount() >= 1 );
	m_wRefCount--;
	Assert( WRefCount() >= 0 );
	}


//	remove this FCB from the avail-LRU list

VOID FCB::RemoveAvailList_( 
#ifdef DEBUG
	const BOOL fPurging
#endif	//	DEBUG
	)
	{
	INST *pinst = PinstFromIfmp( Ifmp() );
	Assert( pinst->m_critFCBList.FOwner() );
	Assert( IsLocked() || fPurging );

	//	trap for bug x5:100491
	AssertRTL( FTypeTable() );

#ifdef DEBUG

	//	verify that the FCB is in the avail list

	AssertFCBAvailList_( fPurging );
#endif	//	DEBUG

	//	get the list pointers

	FCB **ppfcbAvailMRU = pinst->PpfcbAvailMRU( FAboveThreshold() );
	FCB **ppfcbAvailLRU = pinst->PpfcbAvailLRU( FAboveThreshold() );

	//	verify the consistency of the list (it should not be empty)

	Assert( pinst->m_cFCBAvail > 0 );
	Assert( *ppfcbAvailMRU != pfcbNil );
	Assert( *ppfcbAvailLRU != pfcbNil );
	Assert( (*ppfcbAvailMRU)->PfcbMRU() == pfcbNil );
	Assert( (*ppfcbAvailLRU)->PfcbLRU() == pfcbNil );

	//	remove the FCB

	if ( PfcbMRU() != pfcbNil )
		{
		Assert( *ppfcbAvailMRU != this );
		Assert( PfcbMRU()->PfcbLRU() == this );		//	verify that this FCB is in the LRU list
		PfcbMRU()->SetPfcbLRU( PfcbLRU() );
		}
	else
		{
		Assert( *ppfcbAvailMRU == this );			//	verify that this FCB is in the LRU list
		*ppfcbAvailMRU = PfcbLRU();
		}
	if ( PfcbLRU() != pfcbNil )
		{
		Assert( *ppfcbAvailLRU != this );
		Assert( PfcbLRU()->PfcbMRU() == this );		//	verify that this FCB is in the LRU list
		PfcbLRU()->SetPfcbMRU( PfcbMRU() );
		}
	else
		{
		Assert( *ppfcbAvailLRU == this );			//	verify that this FCB is in the LRU list
		*ppfcbAvailLRU = PfcbMRU();
		}
	ResetInLRU();
	SetPfcbMRU( pfcbNil );
	SetPfcbLRU( pfcbNil );
	Assert( pinst->m_cFCBAvail > 0 );
	pinst->m_cFCBAvail--;

	//	update performance counter

	cFCBCacheAllocAvail.Dec( pinst );

	//	verify the consistency of the list (it may be empty)

	Assert( *ppfcbAvailMRU == pfcbNil ||
			(*ppfcbAvailMRU)->PfcbMRU() == pfcbNil );
	Assert( *ppfcbAvailLRU == pfcbNil ||
			(*ppfcbAvailLRU)->PfcbLRU() == pfcbNil );
	}


//	insert this FCB into the avail list at the MRU position

VOID FCB::InsertAvailListMRU_()
	{
	INST *pinst = PinstFromIfmp( Ifmp() );
	Assert( pinst->m_critFCBList.FOwner() );
	Assert( IsLocked() );
	
	//	trap for bug x5:100491
	AssertRTL( FTypeTable() );

	//	get the list pointers

	FCB **ppfcbAvailMRU = pinst->PpfcbAvailMRU( FAboveThreshold() );
	FCB **ppfcbAvailLRU = pinst->PpfcbAvailLRU( FAboveThreshold() );

	//	verify the consistency of the list (it may be empty)

	Assert( *ppfcbAvailMRU == pfcbNil ||
			(*ppfcbAvailMRU)->PfcbMRU() == pfcbNil );
	Assert( *ppfcbAvailLRU == pfcbNil ||
			(*ppfcbAvailLRU)->PfcbLRU() == pfcbNil );

	//	verify that this FCB is not in the LRU list
	
	Assert( !FInLRU() );
	Assert( PfcbMRU() == pfcbNil );
	Assert( PfcbLRU() == pfcbNil );

	//	insert the FCB at the MRU end of the avail list

	if ( *ppfcbAvailMRU != pfcbNil )
		{
		(*ppfcbAvailMRU)->SetPfcbMRU( this );
		}
	//SetPfcbMRU( pfcbNil );
	SetPfcbLRU( *ppfcbAvailMRU );
	*ppfcbAvailMRU = this;
	if ( *ppfcbAvailLRU == pfcbNil )
		{
		*ppfcbAvailLRU = this;
		}
	SetInLRU();
	pinst->m_cFCBAvail++;

	//	update performance counter

	cFCBCacheAllocAvail.Inc( pinst );
	
	//	verify the consistency of the list (it should not be empty)

	Assert( *ppfcbAvailMRU != pfcbNil );
	Assert( *ppfcbAvailLRU != pfcbNil );
	Assert( (*ppfcbAvailMRU)->PfcbMRU() == pfcbNil );
	Assert( (*ppfcbAvailLRU)->PfcbLRU() == pfcbNil );

#ifdef DEBUG

	//	verify that this FCB is in the avail list

	AssertFCBAvailList_();
#endif	//	DEBUG
	}


//	insert this FCB into the global list

VOID FCB::InsertList()
	{
	INST *pinst = PinstFromIfmp( Ifmp() );
	Assert( pinst->m_critFCBList.FNotOwner() );

	//	lock the global list

	pinst->m_critFCBList.Enter();

	//	verify that this FCB is not yet in the list

	Assert( !FInList() );
	Assert( PfcbNextList() == pfcbNil );
	Assert( PfcbPrevList() == pfcbNil );

	//	verify the consistency of the list (it may be empty)

	Assert( pinst->m_pfcbList == pfcbNil ||
			pinst->m_pfcbList->PfcbPrevList() == pfcbNil );

	//	insert the FCB at the MRU end of the avail list

	if ( pinst->m_pfcbList != pfcbNil )
		{
		pinst->m_pfcbList->SetPfcbPrevList( this );
		}
	//SetPfcbPrevList( pfcbNil );
	SetPfcbNextList( pinst->m_pfcbList );
	pinst->m_pfcbList = this;
	SetInList();

	//	verify the consistency of the list (it should not be empty)

	Assert( pinst->m_pfcbList != pfcbNil );
	Assert( pinst->m_pfcbList->PfcbPrevList() == pfcbNil );

	//	unlock the global list

	pinst->m_critFCBList.Leave();
	}


//	remove this FCB from the global list

VOID FCB::RemoveList_()
	{
	INST *pinst = PinstFromIfmp( Ifmp() );
	
	Assert( pinst->m_critFCBList.FOwner() );

	//	verify that this FCB is in the list

	Assert( FInList() );

	//	verify the consistency of the list (it will not be empty)

	Assert( pinst->m_pfcbList != pfcbNil );
	Assert( pinst->m_pfcbList->PfcbPrevList() == pfcbNil );

	//	remove the FCB

	if ( PfcbPrevList() != pfcbNil )
		{
		Assert( pinst->m_pfcbList != this );
		Assert( PfcbPrevList()->PfcbNextList() == this );	//	verify that this FCB is in the list
		PfcbPrevList()->SetPfcbNextList( PfcbNextList() );
		}
	else
		{
		Assert( pinst->m_pfcbList == this );				//	verify that this FCB is in the list
		pinst->m_pfcbList = PfcbNextList();
		}
	if ( PfcbNextList() != pfcbNil )
		{
		Assert( PfcbNextList()->PfcbPrevList() == this );	//	verify that this FCB is in the list
		PfcbNextList()->SetPfcbPrevList( PfcbPrevList() );
		}
	ResetInList();
	SetPfcbNextList( pfcbNil );
	SetPfcbPrevList( pfcbNil );

	//	verify the consistency of the list (it may be empty)

	Assert( pinst->m_pfcbList == pfcbNil ||
			pinst->m_pfcbList->PfcbPrevList() == pfcbNil );
	}


//	re-evaluate and possibly update the avail-LRU list position of this FCB 
//		due to a change in the threshold position of the FCB
//
//	when an FCB gains or loses children FCBs (e.g. secondary index FCBs, 
//		LV FCBs, ...), the avail-LRU list position of the FCB could change;
//		this function is called to check for and handle such a condition
//
//	NOTE: at the time of calling this, FAboveThreshold() reports the current
//		avail-LRU list position, but the FCB has gained/lost children; this
//		gain/loss will show up when we scan the FCB to determine its real
//		avail-LRU list position

VOID FCB::UpdateAvailListPosition()
	{
	INST 	*pinst = PinstFromIfmp( Ifmp() );
	BOOL	fAboveBefore;
	BOOL	fAboveAfter = fFalse;

	Assert( pinst->m_critFCBList.FNotOwner() );

	//	trap for bug x5:100491
	AssertRTL( FTypeTable() );

	//	lock the list

	pinst->m_critFCBList.Enter();

	Lock();
	fAboveBefore = ( FAboveThreshold() ? fTrue : fFalse );
	Unlock();

#ifdef DEBUG
	if ( FInLRU() )
		{

		//	assert the current avail-LRU list position based on the current
		//		FAboveThrehsold() flag
		
		AssertFCBAvailList_();
		}
#endif	//	DEBUG

	//	recalculate the above-threshold flag

	if ( this >= PfcbFCBPreferredThreshold( pinst ) )
		{
		fAboveAfter = fTrue;
		}
	else
		{
		FCB *pfcbT;

		EnterDML();
		for ( pfcbT = PfcbNextIndex(); pfcbT != pfcbNil; pfcbT = pfcbT->PfcbNextIndex() )
			{
			if ( pfcbT >= PfcbFCBPreferredThreshold( pinst ) )
				{
				fAboveAfter = fTrue;
				break;
				}
			}
		if ( Ptdb()->PfcbLV() >= PfcbFCBPreferredThreshold( pinst ) )
			{
			fAboveAfter = fTrue;
			}
		LeaveDML();
		}

	Assert( fTrue == fAboveBefore || fFalse == fAboveBefore );
	Assert( fTrue == fAboveAfter || fFalse == fAboveAfter );
	if ( fAboveAfter == fAboveBefore )
		{

		//	the avail-LRU list position has not changed

		//	unlock the list

		pinst->m_critFCBList.Leave();

		return;
		}

	//	lock the FCB

	Lock();

	//	update the threshold position

	if ( fAboveAfter )
		{
		Assert( !FAboveThreshold() );
		SetAboveThreshold();
		}
	else
		{
		Assert( FAboveThreshold() );
		ResetAboveThreshold();
		}

	//	unlock the FCB

	Unlock();

	//	update the avail-LRU list position (may not be in avail-LRU list)

	if ( FInLRU() )
		{

		//	this FCB is in the LRU list
		//		remove the FCB from its current avail list
		//		insert the FCB into the new avail list


		//	REMOVE FROM OLD LIST -------------------------------

		//	get the list pointers of the current list

		FCB **ppfcbAvailMRU = pinst->PpfcbAvailMRU( fAboveBefore );
		FCB **ppfcbAvailLRU = pinst->PpfcbAvailLRU( fAboveBefore );

		//	verify the consistency of the list (it should not be empty)

		Assert( *ppfcbAvailMRU != pfcbNil );
		Assert( *ppfcbAvailLRU != pfcbNil );
		Assert( (*ppfcbAvailMRU)->PfcbMRU() == pfcbNil );
		Assert( (*ppfcbAvailLRU)->PfcbLRU() == pfcbNil );

		//	remove the FCB

		if ( PfcbMRU() != pfcbNil )
			{
			Assert( *ppfcbAvailMRU != this );
			Assert( PfcbMRU()->PfcbLRU() == this );		//	verify that this FCB is in the LRU list
			PfcbMRU()->SetPfcbLRU( PfcbLRU() );
			}
		else
			{
			Assert( *ppfcbAvailMRU == this );			//	verify that this FCB is in the LRU list
			*ppfcbAvailMRU = PfcbLRU();
			}
		if ( PfcbLRU() != pfcbNil )
			{
			Assert( *ppfcbAvailLRU != this );
			Assert( PfcbLRU()->PfcbMRU() == this );		//	verify that this FCB is in the LRU list
			PfcbLRU()->SetPfcbMRU( PfcbMRU() );
			}
		else
			{
			Assert( *ppfcbAvailLRU == this );			//	verify that this FCB is in the LRU list
			*ppfcbAvailLRU = PfcbMRU();
			}

		//	verify the consistency of the list (it may be empty)

		Assert( *ppfcbAvailMRU == pfcbNil ||
				(*ppfcbAvailMRU)->PfcbMRU() == pfcbNil );
		Assert( *ppfcbAvailLRU == pfcbNil ||
				(*ppfcbAvailLRU)->PfcbLRU() == pfcbNil );


		//	INSERT INTO NEW LIST -------------------------------

		//	get the list pointers of the new list

		ppfcbAvailMRU = pinst->PpfcbAvailMRU( fAboveAfter );
		ppfcbAvailLRU = pinst->PpfcbAvailLRU( fAboveAfter );

		//	verify the consistency of the list (it may be empty)

		Assert( *ppfcbAvailMRU == pfcbNil ||
				(*ppfcbAvailMRU)->PfcbMRU() == pfcbNil );
		Assert( *ppfcbAvailLRU == pfcbNil ||
				(*ppfcbAvailLRU)->PfcbLRU() == pfcbNil );

		//	insert the FCB at the MRU end of the avail list

		if ( *ppfcbAvailMRU != pfcbNil )
			{
			(*ppfcbAvailMRU)->SetPfcbMRU( this );
			}
		SetPfcbMRU( pfcbNil );
		SetPfcbLRU( *ppfcbAvailMRU );
		*ppfcbAvailMRU = this;
		if ( *ppfcbAvailLRU == pfcbNil )
			{
			*ppfcbAvailLRU = this;
			}

		//	verify the consistency of the list (it should not be empty)

		Assert( *ppfcbAvailMRU != pfcbNil );
		Assert( *ppfcbAvailLRU != pfcbNil );
		Assert( (*ppfcbAvailMRU)->PfcbMRU() == pfcbNil );
		Assert( (*ppfcbAvailLRU)->PfcbLRU() == pfcbNil );

#ifdef DEBUG
		//	verify the avail list position

		AssertFCBAvailList_();
#endif	//	DEBUG
		}

	//	unlock the list

	pinst->m_critFCBList.Leave();
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ese98\src\ese\fcreate.cxx ===
#include "std.hxx"

///#define SHOW_INDEX_PERF

// UNDONE:  TEMPORARY HACK to get around unversioned AddColumn/CreateIndex.

CCriticalSection	critUnverCol( CLockBasicInfo( CSyncBasicInfo( szFILEUnverCol ), rankFILEUnverCol, 0 ) );
CCriticalSection	critUnverIndex( CLockBasicInfo( CSyncBasicInfo( szFILEUnverIndex ), rankFILEUnverIndex, 0 ) );

struct UNVER_DDL
	{
	AGENT		agentUnverDDL;
	OBJID		objidTable;
	CHAR		szName[JET_cbNameMost+4];	// +1 for null-terminator, +3 for 4-byte alignment
	UNVER_DDL	*punverNext;
	};
	
UNVER_DDL	*punvercolGlobal = NULL;
UNVER_DDL	*punveridxGlobal = NULL;


//  ================================================================
ERR ErrFILEGetPfieldAndEnterDML(
	PIB			* ppib,
	FCB			* pfcb,
	const CHAR	* szColumnName,
	FIELD		** ppfield,
	COLUMNID	* pcolumnid,
	BOOL		* pfColumnWasDerived,
	const BOOL	fLockColumn )
//  ================================================================
	{
	ERR			err;
	
	*pfColumnWasDerived = fFalse;

	//	CONSIDER: Look in template table first because we don't
	//	have to grab DML/DDL latch (since DDL is fixed).  However,
	//	we used to do this, but we found that for Exchange,
	//	GetTableColumnInfo() calls would be very expensive because
	//	it is typically only called for derived columns and we
	//	first end up searching the 400+ columns of the template
	//	table

	//	WARNING: This function does a EnterDML() for the derived table only
	//	and stays in the latch if the requested field is found.  If the
	//	field is in the template table, the latch is not held.

	if ( fLockColumn )
		{
		Assert( ppib->level > 0 );
		Assert( !pfcb->Ptdb()->FTemplateTable() );
		Assert( !pfcb->FDomainDenyReadByUs( ppib ) );

		err = ErrCATAccessTableColumn(
					ppib,
					pfcb->Ifmp(),
					pfcb->ObjidFDP(),
					szColumnName,
					pcolumnid,
					fTrue );			//	read-lock the column in the catalog to ensure it doesn't disappear
		if ( err < 0 )
			{
			if ( JET_errColumnNotFound != err )
				return err;

			//	force retrieval from template table
			*ppfield = pfieldNil;
			err = JET_errSuccess;
			}
		else
			{
			CallS( err );	//	warnings not expected

			//	shouldn't be a template table if it needs,
			//	to be locked, and besides, we don't persist
			//	the template bit anyways
			Assert( !FCOLUMNIDTemplateColumn( *pcolumnid ) );
			Assert( !*pfColumnWasDerived );

			pfcb->EnterDML();
			*ppfield = pfcb->Ptdb()->Pfield( *pcolumnid );
			}
		}
	else
		{
		pfcb->EnterDML();

		//	WARNING: The following function does a LeaveDML() on error
		CallR( ErrFILEPfieldFromColumnName(
					ppib,
					pfcb,
					szColumnName,
					ppfield,
					pcolumnid ) );

			//	not expecting warnings
		CallS( err );

		if ( pfieldNil == *ppfield )
			pfcb->LeaveDML();
		}

	CallS( err );

	if ( pfieldNil == *ppfield )
		{
		FCB		* const pfcbTemplate	= pfcb->Ptdb()->PfcbTemplateTable();
		if ( pfcbNil != pfcbTemplate )
			{
			pfcb->Ptdb()->AssertValidDerivedTable();
			CallS( ErrFILEPfieldFromColumnName(
						ppib,
						pfcbTemplate,
						szColumnName,
						ppfield,
						pcolumnid ) );
			}

		if ( pfieldNil != *ppfield )
			{
			//	must have found it in the template table
			Assert( pfcbNil != pfcbTemplate );
			Assert( FCOLUMNIDTemplateColumn( *pcolumnid ) );
			*pfColumnWasDerived = fTrue;
			}
		else
			{
			err = ErrERRCheck( JET_errColumnNotFound );
			}
		}
	else if ( FCOLUMNIDTemplateColumn( *pcolumnid ) )
		{
		Assert( pfcb->FTemplateTable() );
		pfcb->Ptdb()->AssertValidTemplateTable();
		}

	return err;
	}


LOCAL BOOL FFILEIUnverColumnExists(
	TDB			*ptdb,
	const FID	fidFirst,
	const FID	fidLast,
	const CHAR	*szColumnName )
	{
	Assert( fidFirst == ptdb->FidFixedFirst()
		|| fidFirst == ptdb->FidVarFirst()
		|| fidFirst == ptdb->FidTaggedFirst() );

	if ( fidLast >= fidFirst )
		{
		const STRHASH strhash = StrHashValue( szColumnName );		
		FIELD	*pfield;
		FIELD	*pfieldLast = ptdb->Pfield( ColumnidOfFid( fidLast, ptdb->FTemplateTable() ) );
		
		Assert( pfieldLast >= ptdb->Pfield( ColumnidOfFid( fidFirst, ptdb->FTemplateTable() ) ) );
		for ( pfield = ptdb->Pfield( ColumnidOfFid( fidFirst, ptdb->FTemplateTable() ) );
			pfield <= pfieldLast;
			pfield++ )
			{
			if ( !FFIELDVersioned( pfield->ffield ) && !FFIELDDeleted( pfield->ffield ) )
				{
				if (	strhash == pfield->strhashFieldName &&
						!UtilCmpName( szColumnName, ptdb->SzFieldName( pfield->itagFieldName, fFalse ) ) )
					{
					return fTrue;
					}
				}
			}
		}

	return fFalse;	
	}

INLINE BOOL FFILEUnverColumnExists( FCB *pfcb, const CHAR *szColumnName )
	{
	TDB			*ptdb			= pfcb->Ptdb();
	BOOL		fExists			= fFalse;

	pfcb->EnterDML();

	fExists = FFILEIUnverColumnExists(
							ptdb,
							ptdb->FidTaggedFirst(),
							ptdb->FidTaggedLast(),
							szColumnName )
			|| FFILEIUnverColumnExists(
							ptdb,
							ptdb->FidFixedFirst(),
							ptdb->FidFixedLast(),
							szColumnName )
			|| FFILEIUnverColumnExists(
							ptdb,
							ptdb->FidVarFirst(),
							ptdb->FidVarLast(),
							szColumnName );

	pfcb->LeaveDML();

	return fExists;
	}
	
	
INLINE ERR ErrFILEInsertIntoUnverColumnList( FCB *pfcbTable, const CHAR *szColumnName )
	{
	ERR			err			= JET_errSuccess;
	const OBJID	objidTable	= pfcbTable->ObjidFDP();
	UNVER_DDL	*punvercol;

	critUnverCol.Enter();

FindColumn:
	for ( punvercol = punvercolGlobal; NULL != punvercol; punvercol = punvercol->punverNext )
		{
		if ( objidTable == punvercol->objidTable
			&& 0 == UtilCmpName( punvercol->szName, szColumnName ) )
			{
			punvercol->agentUnverDDL.Wait( critUnverCol );
			
			if ( FFILEUnverColumnExists( pfcbTable, szColumnName ) )
				{
				critUnverCol.Leave();
				err = ErrERRCheck( JET_errColumnDuplicate );
				return err;
				}
			goto FindColumn;
			}
		}

	punvercol = (UNVER_DDL *)PvOSMemoryHeapAlloc( sizeof( UNVER_DDL ) );
	if ( NULL == punvercol )
		err = ErrERRCheck( JET_errOutOfMemory );
	else
		{
		memset( (BYTE *)punvercol, 0, sizeof( UNVER_DDL ) );
		new( &punvercol->agentUnverDDL ) AGENT;
		punvercol->objidTable = objidTable;
		Assert( strlen( szColumnName ) <= JET_cbNameMost );
		strcpy( punvercol->szName, szColumnName );
		punvercol->punverNext = punvercolGlobal;
		punvercolGlobal = punvercol;
		}
		
	critUnverCol.Leave();

	return err;
	}

INLINE BOOL FFILEUnverIndexExists( FCB *pfcbTable, const CHAR *szIndexName )
	{
	TDB		*ptdb = pfcbTable->Ptdb();
	FCB		*pfcb;
	BOOL	fExists = fFalse;
	
	pfcbTable->EnterDML();

	for ( pfcb = pfcbTable; pfcbNil != pfcb; pfcb = pfcb->PfcbNextIndex() )
		{
		const IDB	* const pidb	= pfcb->Pidb();
		if ( pidbNil != pidb && !pidb->FDeleted() )
			{
			if ( UtilCmpName(
					szIndexName,
					ptdb->SzIndexName( pidb->ItagIndexName(), pfcb->FDerivedIndex() ) ) == 0 )
				{
				fExists = fTrue;
				break;
				}
			}
		}

	pfcbTable->LeaveDML();

	return fExists;
	}

INLINE ERR ErrFILEInsertIntoUnverIndexList( FCB *pfcbTable, const CHAR *szIndexName )
	{
	ERR			err			= JET_errSuccess;
	const OBJID	objidTable	= pfcbTable->ObjidFDP();
	UNVER_DDL	*punveridx;

	critUnverIndex.Enter();

FindIndex:
	for ( punveridx = punveridxGlobal; NULL != punveridx; punveridx = punveridx->punverNext )
		{
		if ( objidTable == punveridx->objidTable
			&& 0 == UtilCmpName( punveridx->szName, szIndexName ) )
			{
			punveridx->agentUnverDDL.Wait( critUnverIndex );
			
			if ( FFILEUnverIndexExists( pfcbTable, szIndexName ) )
				{
				critUnverIndex.Leave();
				err = ErrERRCheck( JET_errIndexDuplicate );
				return err;
				}
			goto FindIndex;
			}
		}

	punveridx = (UNVER_DDL *)PvOSMemoryHeapAlloc( sizeof( UNVER_DDL ) );
	if ( NULL == punveridx )
		{
		err = ErrERRCheck( JET_errOutOfMemory );
		}
	else
		{
		memset( (BYTE *)punveridx, 0, sizeof( UNVER_DDL ) );
		new( &punveridx->agentUnverDDL ) AGENT;
		punveridx->objidTable = objidTable;
		Assert( strlen( szIndexName ) <= JET_cbNameMost );
		strcpy( punveridx->szName, szIndexName );
		punveridx->punverNext = punveridxGlobal;
		punveridxGlobal = punveridx;
		}
		
	critUnverIndex.Leave();

	return err;
	}


LOCAL VOID FILERemoveFromUnverList(
	UNVER_DDL	**ppunverGlobal,
	CCriticalSection&		critUnver,
	const OBJID	objidTable,
	const CHAR	*szName )
	{
	UNVER_DDL	**ppunver;

	critUnver.Enter();

	Assert( NULL != *ppunverGlobal );
	for ( ppunver = ppunverGlobal; *ppunver != NULL; ppunver = &( (*ppunver)->punverNext ) )
		{
		if ( objidTable == (*ppunver)->objidTable
			&& 0 == UtilCmpName( (*ppunver)->szName, szName ) )
			{
			UNVER_DDL	*punverToRemove;
			(*ppunver)->agentUnverDDL.Release( critUnver );
			punverToRemove = *ppunver;
			*ppunver = (*ppunver)->punverNext;
			punverToRemove->agentUnverDDL.~AGENT();
			OSMemoryHeapFree( punverToRemove );
			critUnver.Leave();
			return;
			}
		}

	Assert( fFalse );
	critUnver.Leave();
	}
	

ERR VTAPI ErrIsamCreateTable2( JET_SESID vsesid, JET_DBID vdbid, JET_TABLECREATE2 *ptablecreate )
	{
	ERR				err;
	PIB				*ppib = (PIB *)vsesid;
	FUCB 			*pfucb;
	IFMP			ifmp = (IFMP) vdbid;

	//	check parameters
	//
	CallR( ErrPIBCheck( ppib ) );

	if ( ifmp >= ifmpMax || dbidTemp == rgfmp[ ifmp ].Dbid() )
		{
		err = ErrERRCheck( JET_errInvalidDatabaseId );
		return err;
		}

	// UNDONE: Supported nesting of hierarchical DDL.
	if ( ptablecreate->grbit & JET_bitTableCreateTemplateTable )
		{
		if ( ptablecreate->szTemplateTableName != NULL )
			{
			err = ErrERRCheck( JET_errCannotNestDDL );
			return err;
			}
		}
	else if ( ptablecreate->grbit & JET_bitTableCreateNoFixedVarColumnsInDerivedTables )
		{
		//	this grbit must be used in conjunction with JET_bitTableCreateTemplateTable
		err = ErrERRCheck( JET_errInvalidGrbit );
		return err;
		}

	if ( ptablecreate->grbit & JET_bitTableCreateSystemTable )		//	internal use only
		{
		err = ErrERRCheck( JET_errInvalidGrbit );
		return err;
		}

	//	create the table, and open it
	//
	CallR( ErrFILECreateTable( ppib, ifmp, ptablecreate ) );
	pfucb = (FUCB *)(ptablecreate->tableid);
	pfucb->pvtfndef = &vtfndefIsam;

	Assert( ptablecreate->cCreated <= 1 + ptablecreate->cColumns + ptablecreate->cIndexes + ( ptablecreate->szCallback ? 1 : 0 ) );

	return err;
	}


//  ================================================================
ERR VTAPI ErrIsamCreateTable( JET_SESID vsesid, JET_DBID vdbid, JET_TABLECREATE *ptablecreate )
//  ================================================================
	{
	Assert( ptablecreate );
	
	JET_TABLECREATE2 tablecreate;

	tablecreate.cbStruct 				= sizeof( JET_TABLECREATE2 );
	tablecreate.szTableName				= ptablecreate->szTableName;
	tablecreate.szTemplateTableName		= ptablecreate->szTemplateTableName;
	tablecreate.ulPages					= ptablecreate->ulPages;
	tablecreate.ulDensity				= ptablecreate->ulDensity;
	tablecreate.rgcolumncreate			= ptablecreate->rgcolumncreate;
	tablecreate.cColumns				= ptablecreate->cColumns;
	tablecreate.rgindexcreate			= ptablecreate->rgindexcreate;
	tablecreate.cIndexes				= ptablecreate->cIndexes;
	tablecreate.szCallback				= NULL;
	tablecreate.cbtyp					= 0;
	tablecreate.grbit					= ptablecreate->grbit;
	tablecreate.tableid					= ptablecreate->tableid;
	tablecreate.cCreated				= ptablecreate->cCreated;

	const ERR err = ErrIsamCreateTable2( vsesid, vdbid, &tablecreate );

	ptablecreate->tableid 	= tablecreate.tableid;
	ptablecreate->cCreated 	= tablecreate.cCreated;

	return err;
	}

	
//	return fTrue if the column type specified has a fixed length
//
INLINE BOOL FCOLTYPFixedLength( JET_COLTYP coltyp )
	{
	switch( coltyp )
		{
		case JET_coltypBit:
		case JET_coltypUnsignedByte:
		case JET_coltypShort:
		case JET_coltypLong:
		case JET_coltypCurrency:
		case JET_coltypIEEESingle:
		case JET_coltypIEEEDouble:
		case JET_coltypDateTime:
			return fTrue;

		default:
			return fFalse;
		}
	}


LOCAL ERR ErrFILEIScanForColumnName(
	PIB				*ppib,
	FCB				*pfcb,
	const CHAR		*szColumnName,
	FIELD			**ppfield,
	COLUMNID		*pcolumnid,
	const COLUMNID	columnidLastInitial,
	const COLUMNID	columnidLast )
	{
	ERR				err;
	TDB				*ptdb		= pfcb->Ptdb();
	FIELD			*pfield;
	const STRHASH	strhash		= StrHashValue( szColumnName );
	const BOOL		fDerived	= fFalse;		//	only looking at columns in this TDB (ie. no derived columns)

	Assert( FidOfColumnid( *pcolumnid ) == ptdb->FidFixedFirst()
		|| FidOfColumnid( *pcolumnid ) == ptdb->FidVarFirst()
		|| FidOfColumnid( *pcolumnid ) == ptdb->FidTaggedFirst() );
	
	Assert( pfieldNil == *ppfield );

	pfcb->AssertDML();
	
	Assert( FidOfColumnid( columnidLast ) >= FidOfColumnid( *pcolumnid ) );
		
	for ( pfield = ptdb->Pfield( *pcolumnid );
		*pcolumnid <= columnidLast;
		pfield++, (*pcolumnid)++ )
		{
		if ( *pcolumnid == columnidLastInitial + 1 )
			{
			//	refresh in case the FIELD structures were
			//	partitioned into initial/dynamic fields
			pfield = ptdb->Pfield( *pcolumnid );
			}

		Assert( !pfcb->FFixedDDL() || !FFIELDVersioned( pfield->ffield ) );
		if ( !FFIELDCommittedDelete( pfield->ffield ) )
			{
			Assert( JET_coltypNil != pfield->coltyp );
			Assert( 0 != pfield->itagFieldName );
			if ( strhash == pfield->strhashFieldName
				&& 0 == UtilCmpName( szColumnName, ptdb->SzFieldName( pfield->itagFieldName, fDerived ) ) )
				{
				if ( FFIELDVersioned( pfield->ffield ) )
					{
					COLUMNID	columnidT;

					pfcb->LeaveDML();

					//	no versioned operations on template table
					Assert( !ptdb->FTemplateTable() );
					Assert( !FCOLUMNIDTemplateColumn( *pcolumnid ) );
						
					//	must consult catalog.
					CallR( ErrCATAccessTableColumn(
								ppib,
								pfcb->Ifmp(),
								pfcb->ObjidFDP(),
								szColumnName,
								&columnidT ) );
					CallS( err );		//	shouldn't return warnings.

					pfcb->EnterDML();

					//	WARNING: the columnid returned
					//	from the catalog lookup (columnidT)
					//	may be different from the original
					//	columnid (*pcolumnid) if the column
					//	got deleted then re-added with the
					//	same name
					*pcolumnid = columnidT;

					*ppfield = ptdb->Pfield( columnidT );
					}
				else
					{
					Assert( !FFIELDDeleted( pfield->ffield ) );
					Assert( ptdb->Pfield( *pcolumnid ) == pfield );
					*ppfield = pfield;
					}

				Assert( pfieldNil != *ppfield );
				return JET_errSuccess;
				}
			}
		}

	Assert( pfieldNil == *ppfield );	// Scan was successful, but seek failed.
	return JET_errSuccess;
	}

ERR ErrFILEPfieldFromColumnName(
	PIB			*ppib,
	FCB			*pfcb,
	const CHAR	*szColumnName,
	FIELD		**ppfield,
	COLUMNID	*pcolumnid )
	{
	ERR			err;
	TDB			*ptdb			= pfcb->Ptdb();
	const BOOL	fTemplateTable	= ptdb->FTemplateTable();

	pfcb->AssertDML();

	*ppfield = pfieldNil;

	if ( ptdb->FidTaggedLast() >= ptdb->FidTaggedFirst() )
		{
		*pcolumnid = ColumnidOfFid( ptdb->FidTaggedFirst(), fTemplateTable );
		CallR( ErrFILEIScanForColumnName(
					ppib,
					pfcb,
					szColumnName,
					ppfield,
					pcolumnid,
					ColumnidOfFid( ptdb->FidTaggedLastInitial(), fTemplateTable ),
					ColumnidOfFid( ptdb->FidTaggedLast(), fTemplateTable ) ) );

		if ( pfieldNil != *ppfield )
			return JET_errSuccess;
		}


	if ( ptdb->FidFixedLast() >= ptdb->FidFixedFirst() )
		{
		*pcolumnid = ColumnidOfFid( ptdb->FidFixedFirst(), fTemplateTable );
		CallR( ErrFILEIScanForColumnName(
					ppib,
					pfcb,
					szColumnName,
					ppfield,
					pcolumnid,
					ColumnidOfFid( ptdb->FidFixedLastInitial(), fTemplateTable ),
					ColumnidOfFid( ptdb->FidFixedLast(), fTemplateTable ) ) );

		if ( pfieldNil != *ppfield )
			return JET_errSuccess;
		}

	if ( ptdb->FidVarLast() >= ptdb->FidVarFirst() )
		{
		*pcolumnid = ColumnidOfFid( ptdb->FidVarFirst(), fTemplateTable );
		CallR( ErrFILEIScanForColumnName(
					ppib,
					pfcb,
					szColumnName,
					ppfield,
					pcolumnid,
					ColumnidOfFid( ptdb->FidVarLastInitial(), fTemplateTable ),
					ColumnidOfFid( ptdb->FidVarLast(), fTemplateTable ) ) );
		}

	return JET_errSuccess;
	}


LOCAL BOOL FFILEIColumnExists(
	const TDB * const	ptdb,
	const CHAR * const	szColumn,
	const FIELD * const	pfieldStart,
	const ULONG			cfields )
	{
	const STRHASH		strhash		= StrHashValue( szColumn );
	const FIELD * const	pfieldMax	= pfieldStart + cfields;

	//	caller ensures there must be at least one column
	Assert( pfieldNil != pfieldStart );
	Assert( pfieldStart < pfieldMax );

	for ( const FIELD * pfield = pfieldStart; pfield < pfieldMax; pfield++ )
		{
		//	field may have been marked as deleted if an AddColumn rolled back
		if ( !FFIELDDeleted( pfield->ffield )
			&& ( strhash == pfield->strhashFieldName )
			&& ( 0 == UtilCmpName( szColumn, ptdb->SzFieldName( pfield->itagFieldName, fFalse ) ) ) )
			{
			return fTrue;
			}
		}

	return fFalse;
	}
		
LOCAL BOOL FFILEITemplateTableColumn(
	const FCB * const	pfcbTemplateTable,
	const CHAR * const	szColumn )
	{
	Assert( pfcbNil != pfcbTemplateTable );
	Assert( pfcbTemplateTable->FTemplateTable() );
	Assert( pfcbTemplateTable->FFixedDDL() );
		
	const TDB * const	ptdbTemplateTable	= pfcbTemplateTable->Ptdb();
	Assert( ptdbTemplateTable != ptdbNil );
	ptdbTemplateTable->AssertValidTemplateTable();

	const ULONG			cInitialCols		= ptdbTemplateTable->CInitialColumns();
	const ULONG			cDynamicCols		= ptdbTemplateTable->CDynamicColumns();

	if ( cInitialCols > 0 )
		{
		if ( FFILEIColumnExists(
					ptdbTemplateTable,
					szColumn,
					ptdbTemplateTable->PfieldsInitial(),
					cInitialCols ) )
			return fTrue;
		}

	if ( cDynamicCols > 0 )
		{
		//	shouldn't be any dynamic columns in the template table
		Assert( fFalse );

		if ( FFILEIColumnExists(
					ptdbTemplateTable,
					szColumn,
					(FIELD *)ptdbTemplateTable->MemPool().PbGetEntry( itagTDBFields ),
					cDynamicCols ) )
			return fTrue;
		}
	
	return fFalse;
	}

LOCAL BOOL FFILEITemplateTableIndex( const FCB * const pfcbTemplateTable, const CHAR *szIndex )
	{
	Assert( pfcbNil != pfcbTemplateTable );
	Assert( pfcbTemplateTable->FTemplateTable() );
	Assert( pfcbTemplateTable->FFixedDDL() );
		
	const TDB	* const ptdbTemplateTable = pfcbTemplateTable->Ptdb();
	Assert( ptdbTemplateTable != ptdbNil );

	const FCB	*pfcbIndex;
	for ( pfcbIndex = pfcbTemplateTable;
		pfcbIndex != pfcbNil;
		pfcbIndex = pfcbIndex->PfcbNextIndex() )
		{
		const IDB	* const pidb = pfcbIndex->Pidb();
		if ( pfcbIndex == pfcbTemplateTable )
			{
			Assert( pidbNil == pidb || pidb->FPrimary() );
			}
		else
			{
			Assert( pfcbIndex->FTypeSecondaryIndex() );
			Assert( pidbNil != pidb );
			Assert( !pidb->FPrimary() );
			}
		if ( pidbNil != pidb
			&& UtilCmpName( szIndex, ptdbTemplateTable->SzIndexName( pidb->ItagIndexName() ) ) == 0 )
			{
			return fTrue;
			}
		}
	
	return fFalse;
	}


LOCAL ERR ErrFILEIValidateAddColumn(
	const CHAR		*szName,
	CHAR			*szColumnName,
	FIELD			*pfield,
	const JET_GRBIT	grbit,
	const INT		cbDefaultValue,
	const BOOL		fExclusiveLock,
	FCB				*pfcbTemplateTable )
	{
	ERR				err;
	const	BOOL	fDefaultValue = ( cbDefaultValue > 0 );

	pfield->ffield = 0;
	
	// Duplicate column names will get detected when catalog
	// insertion is attempted.
	CallR( ErrUTILCheckName( szColumnName, szName, ( JET_cbNameMost + 1 ) ) );
	if ( pfcbNil != pfcbTemplateTable
		&& FFILEITemplateTableColumn( pfcbTemplateTable, szColumnName ) )
		{
		err = ErrERRCheck( JET_errColumnDuplicate );
		return err;
		}


//	OLD
//	if ( pfield->coltyp == 0 || pfield->coltyp > JET_coltypLongText )
// 	NEW - because of the new column type
	if ( pfield->coltyp == 0 || pfield->coltyp >= JET_coltypMax )
		{
		return ErrERRCheck( JET_errInvalidColumnType );
		}
		
	//	if column type is text then check code page
	//
	if ( FRECTextColumn( pfield->coltyp ) )
		{
		//	check code page
		//
		if ( 0 == pfield->cp )
			{
			//	force text column to always have a code page
			pfield->cp = usEnglishCodePage;
			}
		else if ( pfield->cp != usEnglishCodePage && pfield->cp != usUniCodePage )
			{
			return ErrERRCheck( JET_errInvalidCodePage );
			}
		}
	else
		pfield->cp = 0;
		
	// check conflicting Tagged column options
	if ( grbit & JET_bitColumnTagged || FRECLongValue( pfield->coltyp ) || FRECSLV( pfield->coltyp ) )
		{
		if ( grbit & JET_bitColumnNotNULL )
			return ErrERRCheck( JET_errTaggedNotNULL );

		if ( grbit & JET_bitColumnFixed )
			return ErrERRCheck( JET_errInvalidGrbit );

		if ( fDefaultValue && FRECSLV( pfield->coltyp ) )
			return ErrERRCheck( JET_errSLVColumnDefaultValueNotAllowed );
		}
	else if ( grbit & JET_bitColumnMultiValued )
		{
		return ErrERRCheck( JET_errMultiValuedColumnMustBeTagged );
		}

	if ( grbit & JET_bitColumnEscrowUpdate )
		{
		//  Escrow columns can be updated by different sessions in a concurrent fashion
		//  in order for that to be possible the column must always be present in the record
		//  otherwise we will end up in a situation where a column must be inserted into the
		//  record before we escrow it. It would be extremely difficult to insert a column
		//  into a record concurrently (a replace would be required). 
		//
		//  Thus, Escrow columns _must_ have a default value and must be fixed so that they
		//  will be burst into any new records. One alternative is to disallow default values
		//  for escrow columns so that they will have to be set before they can be escrowed --
		//  that would probably reduce their usefullness though..
		//
		//  This also means that an escrow column cannot be added to a table with any records
		//  aleady in it because the column will not be present in those records (the alternative
		//  is to syncronously insert the default-value of the column into all of the records).		
		if ( pfield->coltyp != JET_coltypLong )
			return ErrERRCheck( JET_errInvalidGrbit );		
		if ( grbit & JET_bitColumnTagged )
			return ErrERRCheck( JET_errCannotBeTagged );
		if ( grbit & JET_bitColumnVersion )
			return ErrERRCheck( JET_errInvalidGrbit );
		if ( grbit & JET_bitColumnAutoincrement )
			return ErrERRCheck( JET_errInvalidGrbit );
			
		if ( !fDefaultValue )
			return ErrERRCheck( JET_errInvalidGrbit );
			
		if ( !fExclusiveLock )
			return ErrERRCheck( JET_errExclusiveTableLockRequired );

		FIELDSetEscrowUpdate( pfield->ffield );
		if( grbit & JET_bitColumnFinalize )
			{
			FIELDSetFinalize( pfield->ffield );
			}
		}
	else if ( grbit & JET_bitColumnFinalize )
		{
		return ErrERRCheck( JET_errInvalidGrbit );				
		}
	else if ( grbit & (JET_bitColumnVersion|JET_bitColumnAutoincrement) )
		{
		//	if any special column properties have been set,
		//	then check parameters and set column attributes.
		//
		if ( grbit & JET_bitColumnAutoincrement )
			{
			if ( pfield->coltyp != JET_coltypLong && pfield->coltyp != JET_coltypCurrency )
				return ErrERRCheck( JET_errInvalidGrbit );
			}
		else if ( pfield->coltyp != JET_coltypLong )
			return ErrERRCheck( JET_errInvalidGrbit );
		
		if ( grbit & JET_bitColumnTagged )
			return ErrERRCheck( JET_errCannotBeTagged );
		
		if ( grbit & JET_bitColumnVersion )
			{
			if ( grbit & (JET_bitColumnAutoincrement|JET_bitColumnEscrowUpdate) )
				return ErrERRCheck( JET_errInvalidGrbit );
			FIELDSetVersion( pfield->ffield );
			}
		
		else if ( grbit & JET_bitColumnAutoincrement )
			{
			Assert( !( grbit & JET_bitColumnVersion ) );
			if ( grbit & JET_bitColumnEscrowUpdate )
				return ErrERRCheck( JET_errInvalidGrbit );
			
			// For AutoInc or EscrowUpdate columns, we first need
			// exclusive use of the table.
			if ( !fExclusiveLock )
				return ErrERRCheck( JET_errExclusiveTableLockRequired );

			FIELDSetAutoincrement( pfield->ffield );
			}		
		}

	//  Check FOR user-defined default value
	if( grbit & JET_bitColumnUserDefinedDefault )
		{ 
		if( grbit & JET_bitColumnFixed )
			return ErrERRCheck( JET_errInvalidGrbit );
		if( grbit & JET_bitColumnNotNULL )
			return ErrERRCheck( JET_errInvalidGrbit );
		if( grbit & JET_bitColumnVersion )
			return ErrERRCheck( JET_errInvalidGrbit );
		if( grbit & JET_bitColumnAutoincrement )
			return ErrERRCheck( JET_errInvalidGrbit );
		if( grbit & JET_bitColumnUpdatable )
			return ErrERRCheck( JET_errInvalidGrbit );
		if( grbit & JET_bitColumnEscrowUpdate )
			return ErrERRCheck( JET_errInvalidGrbit );
		if( grbit & JET_bitColumnFinalize )
			return ErrERRCheck( JET_errInvalidGrbit );
		if( grbit & JET_bitColumnMaybeNull )
			return ErrERRCheck( JET_errInvalidGrbit );

		//  The column must be tagged. If it is fixed/variable
		//  we may have to copy the default value into the record
		//  this won't work for calculated defaults
		if( !( grbit & JET_bitColumnTagged )
			&& !FRECLongValue( pfield->coltyp ) )
			return ErrERRCheck( JET_errInvalidGrbit );

		if( sizeof( JET_USERDEFINEDDEFAULT ) != cbDefaultValue )
			return ErrERRCheck( JET_errInvalidParameter );

		//	SLV's should have been caught above by the tagged column check
		Assert( !FRECSLV( pfield->coltyp ) );

		FIELDSetUserDefinedDefault( pfield->ffield );
		}
	
	if ( grbit & JET_bitColumnNotNULL )
		{
		FIELDSetNotNull( pfield->ffield );
		}

	if ( grbit & JET_bitColumnMultiValued )
		{
		FIELDSetMultivalued( pfield->ffield );
		}

	if ( fDefaultValue )
		{
		FIELDSetDefault( pfield->ffield );
		}

	BOOL	fMaxTruncated = fFalse;
	pfield->cbMaxLen = UlCATColumnSize( pfield->coltyp, pfield->cbMaxLen, &fMaxTruncated );
	
	return ( fMaxTruncated ? ErrERRCheck( JET_wrnColumnMaxTruncated ) : JET_errSuccess );
	}


//  ================================================================
LOCAL ERR ErrFILEIAddColumns(
	PIB					* const ppib,
	const IFMP			ifmp,
	JET_TABLECREATE2	* const ptablecreate,
	const OBJID			objidTable,
	FCB					* const pfcbTemplateTable )
//  ================================================================
//
//  User-defined-default columns can be dependant on other columns
//  we need to know the columnids of all the normal columns in order
//  to be able to create user-defined-default columns. We make two
//  passes through the columns to do this -- once for the normal ones
//  and once for the user-defined defaults
//
//  OPTIMIZATION: on the first pass note if there are any user-defined defaults
//  and only make the second pass if there are
//		
//-
	{
	ERR					err;
	FUCB				*pfucbCatalog		= pfucbNil;
	CHAR				szColumnName[ JET_cbNameMost+1 ];
	JET_COLUMNCREATE	*pcolcreate;
	JET_COLUMNCREATE	*plastcolcreate;
	BOOL				fSetColumnError 	= fFalse;
	TCIB				tcib				= { fidFixedLeast-1, fidVarLeast-1, fidTaggedLeast-1 };
	USHORT				ibNextFixedOffset	= ibRECStartFixedColumns;
	FID					fidVersion			= 0;
	FID					fidAutoInc			= 0;
	const BOOL			fTemplateTable		= ( ptablecreate->grbit & JET_bitTableCreateTemplateTable );

	Assert( rgfmp[ ifmp ].Dbid() != dbidTemp );
	
	//	table has been created
	Assert( 1 == ptablecreate->cCreated );

	if ( ptablecreate->rgcolumncreate == NULL )
		{
		err = ErrERRCheck( JET_errInvalidParameter );
		return err;
		}

	if ( pfcbNil != pfcbTemplateTable )
		{
		TDB	*ptdbTemplateTable = pfcbTemplateTable->Ptdb();

		Assert( pfcbTemplateTable->FTemplateTable() );
		Assert( pfcbTemplateTable->FFixedDDL() );
		ptdbTemplateTable->AssertValidTemplateTable();
							
		// Can't have same fidAutoInc and fidVersion.
		fidAutoInc = ptdbTemplateTable->FidAutoincrement();
		Assert( 0 == fidAutoInc || ptdbTemplateTable->FidVersion() != fidAutoInc );

		fidVersion = ptdbTemplateTable->FidVersion();
		Assert( 0 == fidVersion || ptdbTemplateTable->FidAutoincrement() != fidVersion );

		//	fixed and variable columns continue column space started by template table
		//	tagged columns start their own column space
		tcib.fidFixedLast = ptdbTemplateTable->FidFixedLast();
		tcib.fidVarLast = ptdbTemplateTable->FidVarLast();
		ibNextFixedOffset = ptdbTemplateTable->IbEndFixedColumns();
		}
		
	Assert( fidTaggedLeast-1 == tcib.fidTaggedLast );
	
	CallR( ErrCATOpen( ppib, ifmp, &pfucbCatalog ) );
	Assert( pfucbNil != pfucbCatalog );

	Assert( ptablecreate->rgcolumncreate != NULL );

	plastcolcreate = ptablecreate->rgcolumncreate + ptablecreate->cColumns;


#ifdef ACCOUNT_FOR_CALLBACK_DEPENDENCIES	
	for ( pcolcreate = ptablecreate->rgcolumncreate;
		pcolcreate < plastcolcreate;
		pcolcreate++ )
		{
		Assert( pcolcreate != NULL );
		Assert( pcolcreate < ptablecreate->rgcolumncreate + ptablecreate->cColumns );

		//  this is the data that will actually be inserted into the catalog
		const VOID		*pvDefaultAdd 	= NULL;
		ULONG			cbDefaultAdd 	= 0;
		CHAR			*szCallbackAdd 	= NULL;
		const VOID		*pvUserDataAdd 	= NULL;
		ULONG			cbUserDataAdd 	= 0;

		if ( pcolcreate->cbStruct != sizeof(JET_COLUMNCREATE) )
			{
			err = ErrERRCheck( JET_errInvalidParameter );
			goto HandleError;
			}

		pvDefaultAdd = pcolcreate->pvDefault;
		cbDefaultAdd = pcolcreate->cbDefault;
		
		FIELD			field;
		memset( &field, 0, sizeof(FIELD) );
		field.coltyp = FIELD_COLTYP( pcolcreate->coltyp );
		field.cbMaxLen = pcolcreate->cbMax;
		field.cp = (USHORT)pcolcreate->cp;

		//	UNDONE:	interpret pbDefault of NULL for NULL value, and
		//			cbDefault == 0 and pbDefault != NULL as set to 
		//			zero length.
		Assert( pcolcreate->cbDefault == 0 || pcolcreate->pvDefault != NULL );

		fSetColumnError = fTrue;
		
		// May return a warning.  Hold warning in pcolcreate->err unless
		// error encountered.
		Call( ErrFILEIValidateAddColumn(
					pcolcreate->szColumnName,
					szColumnName,
					&field,
					pcolcreate->grbit,
					( pcolcreate->pvDefault ? pcolcreate->cbDefault : 0 ),
					fTrue,
					pfcbTemplateTable ) );

		if( FFIELDUserDefinedDefault( field.ffield ) )
			{
			//  don't process user-defined-defaults on this pass
			//  the loop below will process them
			pcolcreate->columnid = 0;
			pcolcreate->err = JET_errSuccess;
			fSetColumnError = fFalse;
			continue;
			}
			
		if ( FRECSLV( field.coltyp ) && !rgfmp[ifmp].FSLVAttached() )
			{
			Call( ErrERRCheck( JET_errSLVStreamingFileNotCreated ) );
			}

		//	for fixed-length columns, make sure record not too big
		//
		Assert( tcib.fidFixedLast >= fidFixedLeast ?
			ibNextFixedOffset > ibRECStartFixedColumns :
			ibNextFixedOffset == ibRECStartFixedColumns );
		if ( ( ( pcolcreate->grbit & JET_bitColumnFixed ) || FCOLTYPFixedLength( field.coltyp ) )
			&& ibNextFixedOffset + pcolcreate->cbMax > cbRECRecordMost )
			{
			err = ErrERRCheck( JET_errRecordTooBig );
			goto HandleError;
			}
		else
			{
			Call( ErrFILEGetNextColumnid(
						field.coltyp,
						pcolcreate->grbit,
						fTemplateTable,
						&tcib,
						&pcolcreate->columnid ) );
			}


		//	update TDB
		//
		Assert( 0 == field.ibRecordOffset );
		if ( FCOLUMNIDFixed( pcolcreate->columnid ) )
			{
			Assert( FidOfColumnid( pcolcreate->columnid ) == tcib.fidFixedLast );
			field.ibRecordOffset = ibNextFixedOffset;
			ibNextFixedOffset = USHORT( ibNextFixedOffset + field.cbMaxLen );
			}
		else if ( FCOLUMNIDTagged( pcolcreate->columnid ) )
			{
			Assert( FidOfColumnid( pcolcreate->columnid ) == tcib.fidTaggedLast );
			}
		else
			{
			Assert( FCOLUMNIDVar( pcolcreate->columnid ) );
			Assert( FidOfColumnid( pcolcreate->columnid ) == tcib.fidVarLast );
			}

		if ( FFIELDVersion( field.ffield ) )
			{
			Assert( !FFIELDAutoincrement( field.ffield ) );
			Assert( !FFIELDEscrowUpdate( field.ffield ) );
			Assert( field.coltyp == JET_coltypLong );
			Assert( FCOLUMNIDFixed( pcolcreate->columnid ) );
			if ( 0 != fidVersion )
				{
				err = ErrERRCheck( JET_errColumnRedundant );
				goto HandleError;
				}
			fidVersion = FidOfColumnid( pcolcreate->columnid );
			}
		else if ( FFIELDAutoincrement( field.ffield ) )
			{
			Assert( !FFIELDVersion( field.ffield ) );
			Assert( !FFIELDEscrowUpdate( field.ffield ) );
			Assert( field.coltyp == JET_coltypLong || field.coltyp == JET_coltypCurrency );
			Assert( FCOLUMNIDFixed( pcolcreate->columnid ) );
			if ( 0 != fidAutoInc )
				{
				err = ErrERRCheck( JET_errColumnRedundant );
				goto HandleError;
				}
			fidAutoInc = FidOfColumnid( pcolcreate->columnid );
			}
		else if ( FFIELDEscrowUpdate( field.ffield ) )
			{
			Assert( !FFIELDVersion( field.ffield ) );
			Assert( !FFIELDAutoincrement( field.ffield ) );
			Assert( field.coltyp == JET_coltypLong );
			Assert( FFixedFid( (FID)pcolcreate->columnid ) );
			}

		fSetColumnError = fFalse;
		pcolcreate->err = JET_errSuccess;

		ptablecreate->cCreated++;
		Assert( ptablecreate->cCreated <= 1 + ptablecreate->cColumns );

		if ( fTemplateTable )
			{
			FIELDSetTemplateColumnESE98( field.ffield );
			}

		Call( ErrCATAddTableColumn(
					ppib,
					pfucbCatalog,
					objidTable,
					szColumnName,
					pcolcreate->columnid,
					&field,
					pvDefaultAdd,
					cbDefaultAdd,
					szCallbackAdd,
					pvUserDataAdd,
					cbUserDataAdd ) );
		}	// for


	//  go through a second time to create all the user-defined-default columns
	for ( pcolcreate = ptablecreate->rgcolumncreate;
		pcolcreate < plastcolcreate;
		pcolcreate++ )
		{
		Assert( pcolcreate != NULL );
		Assert( pcolcreate < ptablecreate->rgcolumncreate + ptablecreate->cColumns );

		//  this is the data that will actually be inserted into the catalog
		const VOID			*pvDefaultAdd 	= pcolcreate->pvDefault;
		ULONG				cbDefaultAdd 	= pcolcreate->cbDefault;
		CHAR				*szCallbackAdd 	= NULL;
		const VOID			*pvUserDataAdd 	= NULL;
		ULONG				cbUserDataAdd 	= 0;

		//  this was checked in the first loop
		Assert( pcolcreate->cbStruct == sizeof(JET_COLUMNCREATE) );
		
		FIELD				field;
		memset( &field, 0, sizeof(FIELD) );
		field.coltyp = FIELD_COLTYP( pcolcreate->coltyp );
		field.cbMaxLen = pcolcreate->cbMax;
		field.cp = (USHORT)pcolcreate->cp;

		fSetColumnError = fTrue;
		
		// This was called above so any errors should have been caught there
		err = ErrFILEIValidateAddColumn(
					pcolcreate->szColumnName,
					szColumnName,
					&field,
					pcolcreate->grbit,
					( pcolcreate->pvDefault ? pcolcreate->cbDefault : 0 ),
					fTrue,
					pfcbTemplateTable );
		Assert( 0 <= err );

		if( !FFIELDUserDefinedDefault( field.ffield ) )
			{
			//  we should not be here if the creation of this column failed
			Assert( 0 <= pcolcreate->err );
			fSetColumnError = fFalse;
			continue;
			}

		Assert( 0 == pcolcreate->columnid );
		Assert( JET_errSuccess == pcolcreate->err );
		Assert( !FRECSLV( field.coltyp ) );
		Assert( pcolcreate->grbit & JET_bitColumnTagged );
		
		Call( ErrFILEGetNextColumnid(
					field.coltyp,
					pcolcreate->grbit,
					fTemplateTable,
					&tcib,
					&pcolcreate->columnid ) );

		//	update TDB
		//

		//	UDD's must be tagged columns
		Assert( 0 == field.ibRecordOffset );
		Assert( !FCOLUMNIDFixed( pcolcreate->columnid ) );
		Assert( !FCOLUMNIDVar( pcolcreate->columnid ) );
		Assert( FCOLUMNIDTagged( pcolcreate->columnid ) );
		Assert( FidOfColumnid( pcolcreate->columnid ) == tcib.fidTaggedLast );

		Assert( !FFIELDVersion( field.ffield ) );
		Assert( !FFIELDAutoincrement( field.ffield ) );
		Assert( !FFIELDEscrowUpdate( field.ffield ) );

			{
			JET_USERDEFINEDDEFAULT * const pudd = (JET_USERDEFINEDDEFAULT *)(pcolcreate->pvDefault);

			//  the table will be opened from the catalog later so we don't need to deal with registering
			//  a CBDESC right now. Make sure that it can be resolved though
			JET_CALLBACK callback;
			Call( ErrCALLBACKResolve( pudd->szCallback, &callback ) );
						
			//  for user-defined-defaults we don't store a default value at all
			pvDefaultAdd 	= NULL;
			cbDefaultAdd 	= 0;
			szCallbackAdd	= pudd->szCallback;
			pvUserDataAdd 	= pudd->pbUserData;
			cbUserDataAdd 	= pudd->cbUserData;
			}

		fSetColumnError = fFalse;
		pcolcreate->err = JET_errSuccess;

		ptablecreate->cCreated++;
		Assert( ptablecreate->cCreated <= 1 + ptablecreate->cColumns );

		if ( fTemplateTable )
			{
			FIELDSetTemplateColumnESE98( field.ffield );
			}

		Call( ErrCATAddTableColumn(
					ppib,
					pfucbCatalog,
					objidTable,
					szColumnName,
					pcolcreate->columnid,
					&field,
					pvDefaultAdd,
					cbDefaultAdd,
					szCallbackAdd,
					pvUserDataAdd,
					cbUserDataAdd ) );
		}	// for

#else	//	!ACCOUNT_FOR_CALLBACK_DEPENDENCIES		

	for ( pcolcreate = ptablecreate->rgcolumncreate;
		pcolcreate < plastcolcreate;
		pcolcreate++ )
		{
		Assert( pcolcreate != NULL );
		Assert( pcolcreate < ptablecreate->rgcolumncreate + ptablecreate->cColumns );

		//  this is the data that will actually be inserted into the catalog
		const VOID		*pvDefaultAdd 	= NULL;
		ULONG			cbDefaultAdd 	= 0;
		CHAR			*szCallbackAdd 	= NULL;
		const VOID		*pvUserDataAdd 	= NULL;
		ULONG			cbUserDataAdd 	= 0;

		if ( pcolcreate->cbStruct != sizeof(JET_COLUMNCREATE) )
			{
			err = ErrERRCheck( JET_errInvalidParameter );
			goto HandleError;
			}

		pvDefaultAdd = pcolcreate->pvDefault;
		cbDefaultAdd = pcolcreate->cbDefault;
		
		FIELD			field;
		memset( &field, 0, sizeof(FIELD) );
		field.coltyp = FIELD_COLTYP( pcolcreate->coltyp );
		field.cbMaxLen = pcolcreate->cbMax;
		field.cp = (USHORT)pcolcreate->cp;

		//	UNDONE:	interpret pbDefault of NULL for NULL value, and
		//			cbDefault == 0 and pbDefault != NULL as set to 
		//			zero length.
		Assert( pcolcreate->cbDefault == 0 || pcolcreate->pvDefault != NULL );

		fSetColumnError = fTrue;
		
		// May return a warning.  Hold warning in pcolcreate->err unless
		// error encountered.
		Call( ErrFILEIValidateAddColumn(
					pcolcreate->szColumnName,
					szColumnName,
					&field,
					pcolcreate->grbit,
					( pcolcreate->pvDefault ? pcolcreate->cbDefault : 0 ),
					fTrue,
					pfcbTemplateTable ) );

		if ( FRECSLV( field.coltyp ) && !rgfmp[ifmp].FSLVAttached() )
			{
			Call( ErrERRCheck( JET_errSLVStreamingFileNotCreated ) );
			}

		//	for fixed-length columns, make sure record not too big
		//
		Assert( tcib.fidFixedLast >= fidFixedLeast ?
			ibNextFixedOffset > ibRECStartFixedColumns :
			ibNextFixedOffset == ibRECStartFixedColumns );
		if ( ( ( pcolcreate->grbit & JET_bitColumnFixed ) || FCOLTYPFixedLength( field.coltyp ) )
			&& ibNextFixedOffset + pcolcreate->cbMax > cbRECRecordMost )
			{
			err = ErrERRCheck( JET_errRecordTooBig );
			goto HandleError;
			}

		Call( ErrFILEGetNextColumnid(
					field.coltyp,
					pcolcreate->grbit,
					fTemplateTable,
					&tcib,
					&pcolcreate->columnid ) );

		//	update TDB
		//
		Assert( 0 == field.ibRecordOffset );
		if ( FCOLUMNIDFixed( pcolcreate->columnid ) )
			{
			Assert( FidOfColumnid( pcolcreate->columnid ) == tcib.fidFixedLast );
			field.ibRecordOffset = ibNextFixedOffset;
			ibNextFixedOffset = USHORT( ibNextFixedOffset + field.cbMaxLen );
			}
		else if ( FCOLUMNIDTagged( pcolcreate->columnid ) )
			{
			Assert( FidOfColumnid( pcolcreate->columnid ) == tcib.fidTaggedLast );
			}
		else
			{
			Assert( FCOLUMNIDVar( pcolcreate->columnid ) );
			Assert( FidOfColumnid( pcolcreate->columnid ) == tcib.fidVarLast );
			}

		if ( FFIELDVersion( field.ffield ) )
			{
			Assert( !FFIELDAutoincrement( field.ffield ) );
			Assert( !FFIELDEscrowUpdate( field.ffield ) );
			Assert( field.coltyp == JET_coltypLong );
			Assert( FCOLUMNIDFixed( pcolcreate->columnid ) );
			if ( 0 != fidVersion )
				{
				err = ErrERRCheck( JET_errColumnRedundant );
				goto HandleError;
				}
			fidVersion = FidOfColumnid( pcolcreate->columnid );
			}
		else if ( FFIELDAutoincrement( field.ffield ) )
			{
			Assert( !FFIELDVersion( field.ffield ) );
			Assert( !FFIELDEscrowUpdate( field.ffield ) );
			Assert( field.coltyp == JET_coltypLong || field.coltyp == JET_coltypCurrency );
			Assert( FCOLUMNIDFixed( pcolcreate->columnid ) );
			if ( 0 != fidAutoInc )
				{
				err = ErrERRCheck( JET_errColumnRedundant );
				goto HandleError;
				}
			fidAutoInc = FidOfColumnid( pcolcreate->columnid );
			}
		else if ( FFIELDEscrowUpdate( field.ffield ) )
			{
			Assert( !FFIELDVersion( field.ffield ) );
			Assert( !FFIELDAutoincrement( field.ffield ) );
			Assert( field.coltyp == JET_coltypLong );
			Assert( FFixedFid( (FID)pcolcreate->columnid ) );
			}
		else if ( FFIELDUserDefinedDefault( field.ffield ) )
			{
			JET_USERDEFINEDDEFAULT * const pudd = (JET_USERDEFINEDDEFAULT *)(pcolcreate->pvDefault);

			//  the table will be opened from the catalog later so we don't need to deal with registering
			//  a CBDESC right now. Make sure that it can be resolved though
			JET_CALLBACK callback;
			Call( ErrCALLBACKResolve( pudd->szCallback, &callback ) );
						
			//  for user-defined-defaults we don't store a default value at all
			pvDefaultAdd 	= NULL;
			cbDefaultAdd 	= 0;
			szCallbackAdd	= pudd->szCallback;
			pvUserDataAdd 	= pudd->pbUserData;
			cbUserDataAdd 	= pudd->cbUserData;
			}

		fSetColumnError = fFalse;
		pcolcreate->err = JET_errSuccess;

		ptablecreate->cCreated++;
		Assert( ptablecreate->cCreated <= 1 + ptablecreate->cColumns );

		if ( fTemplateTable )
			{
			FIELDSetTemplateColumnESE98( field.ffield );
			}

		Call( ErrCATAddTableColumn(
					ppib,
					pfucbCatalog,
					objidTable,
					szColumnName,
					pcolcreate->columnid,
					&field,
					pvDefaultAdd,
					cbDefaultAdd,
					szCallbackAdd,
					pvUserDataAdd,
					cbUserDataAdd ) );
		}	// for

#endif	//	ACCOUNT_FOR_CALLBACK_DEPENDENCIES		

	err = JET_errSuccess;

HandleError:
	CallS( ErrCATClose( ppib, pfucbCatalog ) );

	if ( fSetColumnError )
		{
		Assert( err < 0 );
		Assert( pcolcreate != NULL );
		Assert( pcolcreate->cbStruct == sizeof(JET_COLUMNCREATE) );
		pcolcreate->err = err;
		}

	return err;
	}


//	WARNING: This function will modify lcid as necessary
ERR ErrFILEICheckUserDefinedUnicode( IDXUNICODE * const pidxunicode )
	{
	ERR		err;

	if ( NULL == pidxunicode )
		{
		return ErrERRCheck( JET_errIndexInvalidDef );
		}

	CallR( ErrNORMCheckLcid( &pidxunicode->lcid ) );
	CallR( ErrNORMCheckLCMapFlags( &pidxunicode->dwMapFlags ) );

	return JET_errSuccess;
	}


LOCAL ERR ErrFILEIValidateCreateIndex(
	IDB *							pidb,
	const CHAR *					rgszColumns[],
	BYTE * const					rgfbDescending,
	const JET_INDEXCREATE * const	pidxcreate,
	const ULONG						ulDensity )
	{
	ERR								err;
	const JET_GRBIT					grbit				= pidxcreate->grbit;
	const CHAR *					szKey				= pidxcreate->szKey;
	const ULONG						cchKey				= pidxcreate->cbKey;
	const IDXUNICODE * const		pidxunicode			= pidxcreate->pidxunicode;

	const BOOL						fConditional		= ( pidxcreate->cConditionalColumn > 0 );
	const BOOL						fPrimary			= ( grbit & JET_bitIndexPrimary );
	const BOOL						fUnique				= ( grbit & ( JET_bitIndexUnique|JET_bitIndexPrimary ) );
	const BOOL						fDisallowNull		= ( grbit & JET_bitIndexDisallowNull );
	const BOOL						fIgnoreNull			= ( grbit & JET_bitIndexIgnoreNull );
	const BOOL						fIgnoreAnyNull		= ( grbit & JET_bitIndexIgnoreAnyNull );
	const BOOL						fIgnoreFirstNull	= ( grbit & JET_bitIndexIgnoreFirstNull );
	const BOOL						fEmptyIndex			= ( grbit & JET_bitIndexEmpty );
	const BOOL						fSortNullsHigh		= ( grbit & JET_bitIndexSortNullsHigh );
	const BOOL						fUserDefinedUnicode	= ( grbit & JET_bitIndexUnicode );
	const BOOL						fTuples				= ( grbit & JET_bitIndexTuples );

	const CHAR *					pch					= szKey;
	ULONG							cFields				= 0;
	USHORT							cbVarSegMac			= USHORT( 0 == pidxcreate->cbVarSegMac ?
																KEY::CbKeyMost( fPrimary ) :
																pidxcreate->cbVarSegMac );

	pidb->ResetFlags();
	
	//	do not allow primary indexes with any ignore bits on
	//
	if ( fPrimary && ( fIgnoreNull || fIgnoreAnyNull || fIgnoreFirstNull ) )
		{
		err = ErrERRCheck( JET_errInvalidGrbit );
		return err;
		}

	if ( fPrimary && fConditional )
		{
		err = ErrERRCheck( JET_errIndexInvalidDef );
		return err;
		}

	if ( fEmptyIndex && !fIgnoreAnyNull )
		{
		err = ErrERRCheck( JET_errInvalidGrbit );
		return err;
		}

	if ( fUserDefinedUnicode )
		{
		*( pidb->Pidxunicode() ) = *pidxunicode;
		}
	else
		{
		pidb->SetLcid( LCID( DWORD_PTR( pidxunicode ) ) );
		pidb->SetDwLCMapFlags( idxunicodeDefault.dwMapFlags );
		}

	//	check index description for required format
	//
	if ( cchKey == 0 )
		{
		err = ErrERRCheck( JET_errInvalidParameter );
		return err;
		}
		
	if ( ( szKey[0] != '+' && szKey[0] != '-' ) ||
		szKey[cchKey - 1] != '\0' ||
		szKey[cchKey - 2] != '\0' )
		{
		err = ErrERRCheck( JET_errIndexInvalidDef );
		return err;
		}
	Assert( szKey[cchKey - 1] == '\0' );
	Assert( szKey[cchKey - 2] == '\0' );

	if ( ulDensity < ulFILEDensityLeast || ulDensity > ulFILEDensityMost )
		{
		err = ErrERRCheck( JET_errDensityInvalid );
		return err;
		}

	pch = szKey;
	while ( *pch != '\0' )
		{
		if ( cFields >= JET_ccolKeyMost )
			{
			err = ErrERRCheck( JET_errIndexInvalidDef );
			return err;
			}
		if ( *pch == '-' )
			{
			rgfbDescending[cFields] = fTrue;
			pch++;
			}
		else
			{
			rgfbDescending[cFields] = fFalse;
			if ( *pch == '+' )
				pch++;
			}
		rgszColumns[cFields++] = pch;
		pch += strlen( pch ) + 1;
		}
	if ( cFields == 0 )
		{
		err = ErrERRCheck( JET_errIndexInvalidDef );
		return err;
		}

	//	number of columns should not exceed maximum
	//
	Assert( cFields <= JET_ccolKeyMost );

	//	get locale from end of szKey if present
	//
	pch++;
	Assert( pch > szKey );
	if ( (unsigned)( pch - szKey ) < cchKey )
		{
		const SIZE_T	cbKeyOnly = pch - szKey;
		const SIZE_T	cbDoubleNullTerm = sizeof(BYTE) * 2;	// "\0\0"
		const SIZE_T	cbKeyAndLangid = cbKeyOnly + sizeof(LANGID) + cbDoubleNullTerm;
		const SIZE_T	cbKeyAndLangidAndCbVarSegMac = cbKeyAndLangid + sizeof(BYTE) + cbDoubleNullTerm;
		LANGID		langid;
		
		if ( cbKeyAndLangid == cchKey )
			{
			AssertSz( lcidNone == pidb->Lcid() && !fUserDefinedUnicode, "langid specified in index string _and_ JET_INDEXCREATE structure" );
			if( lcidNone != pidb->Lcid() || fUserDefinedUnicode )
				{
				err = ErrERRCheck( JET_errIndexInvalidDef );
				return err;
				}
				
			langid = *( Unaligned< LANGID > *)( szKey + cbKeyOnly );
			}
		else if ( cbKeyAndLangidAndCbVarSegMac == cchKey )
			{
			AssertSz( 0 == pidxcreate->cbVarSegMac, "cbVarSegMac specified in index string _and_ JET_INDEXCREATE structure" );
			if( 0 != pidxcreate->cbVarSegMac )
				{
				err = ErrERRCheck( JET_errIndexInvalidDef );
				return err;
				}
			AssertSz( lcidNone == pidb->Lcid() && !fUserDefinedUnicode, "langid specified in index string _and_ JET_INDEXCREATE structure" );
			if( lcidNone != pidb->Lcid() || fUserDefinedUnicode )
				{
				err = ErrERRCheck( JET_errIndexInvalidDef );
				return err;
				}

			langid = *( Unaligned< LANGID > *)(pch);
			cbVarSegMac = USHORT( *( szKey + cbKeyAndLangid ) );
			}
		else
			{
			err = ErrERRCheck( JET_errIndexInvalidDef );
			return err;
			}

		pidb->SetLcid( LcidFromLangid( langid ) );
		}

	if ( cbVarSegMac <= 0 || cbVarSegMac > KEY::CbKeyMost( fPrimary ) )
		{
		err = ErrERRCheck( JET_errIndexInvalidDef );
		return err;
		}

	if ( fUserDefinedUnicode )
		{
		CallR( ErrFILEICheckUserDefinedUnicode( pidb->Pidxunicode() ) );
		pidb->SetFLocaleId();
		}
	else
		{
		Assert( JET_errSuccess == ErrNORMCheckLCMapFlags( pidb->DwLCMapFlags() ) );
		if ( lcidNone != pidb->Lcid() )
			{
			LCID	lcidT	= pidb->Lcid();
			CallR( ErrNORMCheckLcid( &lcidT ) );
			pidb->SetLcid( lcidT );
			pidb->SetFLocaleId();
			}
		else
			{
			Assert( !pidb->FLocaleId() );
			pidb->SetLcid( idxunicodeDefault.lcid );
			}
		}

	if ( fTuples )
		{
		if ( fPrimary )
			return ErrERRCheck( JET_errIndexTuplesSecondaryIndexOnly );

		if ( cFields > 1 )
			return ErrERRCheck( JET_errIndexTuplesOneColumnOnly );

		if ( fUnique )
			return ErrERRCheck( JET_errIndexTuplesNonUniqueOnly );

		if ( cbVarSegMac < JET_cbSecondaryKeyMost )
			return ErrERRCheck( JET_errIndexTuplesVarSegMacNotAllowed );

		pidb->SetFTuples();
		pidb->SetCbVarSegMac( JET_cbSecondaryKeyMost );
		pidb->SetCidxseg( 1 );
		pidb->SetChTuplesLengthMin( (USHORT)g_chIndexTuplesLengthMin );
		pidb->SetChTuplesLengthMax( (USHORT)g_chIndexTuplesLengthMax );
		pidb->SetChTuplesToIndexMax( (USHORT)g_chIndexTuplesToIndexMax );
		}
	else
		{
		pidb->SetCbVarSegMac( (BYTE)cbVarSegMac );
		pidb->SetCidxseg( (BYTE)cFields );
		}

	if ( !fDisallowNull && !fIgnoreAnyNull )
		{	   	
		pidb->SetFAllowSomeNulls();
		if ( !fIgnoreFirstNull )
			{
			pidb->SetFAllowFirstNull();
			if ( !fIgnoreNull )
				pidb->SetFAllowAllNulls();
			}
		}
		
	if ( fUnique )
		{
		pidb->SetFUnique();
		}
	if ( fPrimary )
		{
		pidb->SetFPrimary();
		}
	if ( fDisallowNull )
		{
		pidb->SetFNoNullSeg();
		}
	else if ( fSortNullsHigh )
		{
		pidb->SetFSortNullsHigh();
		}

#ifdef DEBUG
	IDB		idbT;
	idbT.SetFlagsFromGrbit( grbit );
	if ( pidb->FLocaleId() )
		idbT.SetFLocaleId();
	Assert( idbT.FPersistedFlags() == pidb->FPersistedFlags() );
#endif	

	return JET_errSuccess;
	}


LOCAL ERR ErrFILEICreateIndexes(
	PIB				*ppib,
	IFMP			ifmp,
	JET_TABLECREATE2*ptablecreate,
	PGNO			pgnoTableFDP,
	OBJID			objidTable,
	ULONG			ulTableDensity,
	FCB				*pfcbTemplateTable )
	{
	ERR				err = JET_errSuccess;
	FUCB			*pfucbTableExtent		= pfucbNil;
	FUCB			*pfucbCatalog			= pfucbNil;
	CHAR			szIndexName[ JET_cbNameMost+1 ];
	const CHAR		*rgsz[JET_ccolKeyMost];
	BYTE			rgfbDescending[JET_ccolKeyMost];
	IDXSEG			rgidxseg[JET_ccolKeyMost];
	IDXSEG			rgidxsegConditional[JET_ccolKeyMost];
	JET_INDEXCREATE	*pidxcreate;
	INT				iIndex;
	PGNO			pgnoIndexFDP;
	OBJID			objidIndex;
	IDB				idb;
	BOOL			fProcessedPrimary		= fFalse;
	BOOL			fSetIndexError			= fFalse;
	const BOOL		fTemplateTable			= ( ptablecreate->grbit & JET_bitTableCreateTemplateTable );

	JET_INDEXCREATE	idxcreate;
	JET_INDEXCREATEOLD	* pidxcreateold = NULL;
	JET_INDEXCREATE	* pidxcreateNext = NULL;

	Assert( rgfmp[ ifmp ].Dbid() != dbidTemp );
	Assert( !FCATSystemTable( pgnoTableFDP ) );

	Assert( ptablecreate->cIndexes > 0 );
	Assert( ptablecreate->cCreated == 1 + ptablecreate->cColumns );

	if ( ptablecreate->rgindexcreate == NULL
		|| ptablecreate->rgcolumncreate == NULL )	// must have columns in order to create indexes
		{
		//	if an invalid structure is encountered, get out right away
		//
		err = ErrERRCheck( JET_errInvalidCreateIndex );
		return err;
		}

	// Open cursor for space navigation
	CallR( ErrDIROpen( ppib, pgnoTableFDP, ifmp, &pfucbTableExtent ) );
	Assert( pfucbNil != pfucbTableExtent );
	Assert( !FFUCBVersioned( pfucbTableExtent ) );	// Verify won't be deferred closed.
	Assert( pfcbNil != pfucbTableExtent->u.pfcb );
	Assert( !pfucbTableExtent->u.pfcb->FInitialized() );
	Assert( pfucbTableExtent->u.pfcb->Pidb() == pidbNil );

	//	force the FCB to be initialized successfully

	pfucbTableExtent->u.pfcb->Lock();
	pfucbTableExtent->u.pfcb->CreateComplete();
	pfucbTableExtent->u.pfcb->Unlock();
	
	Call( ErrCATOpen( ppib, ifmp, &pfucbCatalog ) );
	Assert( pfucbNil != pfucbCatalog );

	if ( pfcbNil != pfcbTemplateTable )
		{
		Assert( !fTemplateTable );
		Assert( pfcbTemplateTable->FTemplateTable() );
		Assert( pfcbTemplateTable->FTypeTable() );
		Assert( pfcbTemplateTable->FFixedDDL() );
		if ( pfcbTemplateTable->FSequentialIndex() )
			{
			Assert( pfcbTemplateTable->Pidb() == pidbNil );
			}
		else
			{
			Assert( pfcbTemplateTable->Pidb() != pidbNil );
			Assert( pfcbTemplateTable->Pidb()->FPrimary() );
			Assert( pfcbTemplateTable->Pidb()->FTemplateIndex() );
			fProcessedPrimary = fTrue;
			}
		}

	pidxcreate 		= ptablecreate->rgindexcreate;
	for( iIndex = 0; iIndex < ptablecreate->cIndexes; iIndex++, pidxcreate = pidxcreateNext )
		{		
		pidxcreateNext	= (JET_INDEXCREATE *)((BYTE *)( pidxcreate ) + pidxcreate->cbStruct);
		pidxcreateold 	= NULL;
		
		Assert( pidxcreate < ptablecreate->rgindexcreate + ptablecreate->cIndexes );

		if ( sizeof(JET_INDEXCREATEOLD) == pidxcreate->cbStruct )
			{
			pidxcreateold 		= (JET_INDEXCREATEOLD *)pidxcreate;
			pidxcreateold->err 	= JET_errSuccess;

			memset( &idxcreate, 0, sizeof( JET_INDEXCREATE ) );

			idxcreate.cbStruct		= sizeof( JET_INDEXCREATE );
			idxcreate.szIndexName 	= pidxcreateold->szIndexName;
			idxcreate.szKey			= pidxcreateold->szKey;
			idxcreate.cbKey			= pidxcreateold->cbKey;
			idxcreate.grbit			= pidxcreateold->grbit;
			idxcreate.ulDensity		= pidxcreateold->ulDensity;
			Assert( 0 == idxcreate.lcid );
			Assert( NULL == idxcreate.pidxunicode );
			Assert( 0 == idxcreate.cbVarSegMac );
			Assert( NULL == idxcreate.rgconditionalcolumn );
			Assert( 0 == idxcreate.cConditionalColumn );
			Assert( JET_errSuccess == idxcreate.err );
			pidxcreate = &idxcreate;			
			}
		else if ( pidxcreate->cbStruct != sizeof(JET_INDEXCREATE) )
			{
			//	if an invalid structure is encountered, get out right away
			//
			err = ErrERRCheck( JET_errInvalidCreateIndex );
			goto HandleError;
			}

		pidxcreate->err = JET_errSuccess;

		fSetIndexError = fTrue;
				
		Call( ErrUTILCheckName( szIndexName, pidxcreate->szIndexName, JET_cbNameMost+1 ) );
	
		//	if density not specified, use density of table
		const ULONG	ulDensity	= ( 0 == pidxcreate->ulDensity ?
									ulTableDensity :
									pidxcreate->ulDensity );

		Call( ErrFILEIValidateCreateIndex(
					&idb,
					rgsz,
					rgfbDescending,
					pidxcreate,
					ulDensity ) );

		for ( ULONG iidxseg = 0 ; iidxseg < idb.Cidxseg(); iidxseg++ )
			{
			COLUMNID				columnidT;
			BOOL					fEscrow;
			BOOL					fMultivalued;
			BOOL					fSLV;
			BOOL					fText;
			BOOL					fLocalizedText;
			const JET_COLUMNCREATE	* pcolcreate			= ptablecreate->rgcolumncreate;
			const JET_COLUMNCREATE	* const plastcolcreate	= pcolcreate + ptablecreate->cColumns;

			Assert( NULL != pcolcreate );
			for ( ; pcolcreate < plastcolcreate; pcolcreate++ )
				{
				Assert( pcolcreate->cbStruct == sizeof(JET_COLUMNCREATE) );
				Assert( pcolcreate->err >= 0 );		// must have been created successfully
				if ( UtilCmpName( rgsz[iidxseg], pcolcreate->szColumnName ) == 0 )
					break;
				}
				
			if ( plastcolcreate != pcolcreate )
				{
				columnidT = pcolcreate->columnid;
				Assert( ( fTemplateTable && FCOLUMNIDTemplateColumn( columnidT ) )
					|| ( !fTemplateTable && !FCOLUMNIDTemplateColumn( columnidT ) ) );
				fEscrow = ( pcolcreate->grbit & JET_bitColumnEscrowUpdate );
				fSLV = FRECSLV( pcolcreate->coltyp );
				fMultivalued = ( pcolcreate->grbit & JET_bitColumnMultiValued );
				fText = FRECTextColumn( pcolcreate->coltyp );
				fLocalizedText = ( fText && usUniCodePage == (USHORT)pcolcreate->cp );
				}
			else
				{
				FIELD	*pfield	= pfieldNil;

				//	column is not in table, so check template table (if any)
				if ( pfcbNil != pfcbTemplateTable )
					{
					Assert( !fTemplateTable );
					CallS( ErrFILEPfieldFromColumnName(
								ppib,
								pfcbTemplateTable,
								rgsz[iidxseg],
								&pfield,
								&columnidT ) );
					}

				if ( pfieldNil != pfield )
					{
					//	must be a template column
					Assert( FCOLUMNIDTemplateColumn( columnidT ) );
					Assert( pfcbNil != pfcbTemplateTable );
					fEscrow = FFIELDEscrowUpdate( pfield->ffield );
					fSLV = FRECSLV( pfield->coltyp );
					fMultivalued = FFIELDMultivalued( pfield->ffield );
					fText = FRECTextColumn( pfield->coltyp );
					fLocalizedText = ( fText && usUniCodePage == pfield->cp );
					}
				else
					{
					err = ErrERRCheck( JET_errColumnNotFound );
					goto HandleError;
					}
				}

			if ( fEscrow || fSLV )			//lint !e644
				{
				err = ErrERRCheck( JET_errCannotIndex );
				goto HandleError;
				}

			if ( fMultivalued )		//lint !e644
				{
				if ( idb.FPrimary() )
					{
					//	primary index cannot be multivalued
					//
					err = ErrERRCheck( JET_errIndexInvalidDef );
					goto HandleError;
					}

				idb.SetFMultivalued();
				}

			if ( idb.FTuples() )
				{
				if ( !fText )
					{
					err = ErrERRCheck( JET_errIndexTuplesTextColumnsOnly );
					goto HandleError;
					}
				}

			if ( fLocalizedText )	//lint !e644
				idb.SetFLocalizedText();
					
			rgidxseg[iidxseg].ResetFlags();

			if ( rgfbDescending[iidxseg] )
				rgidxseg[iidxseg].SetFDescending();

			rgidxseg[iidxseg].SetColumnid( columnidT );
			}

 		if( JET_ccolKeyMost < pidxcreate->cConditionalColumn )
			{
			err = ErrERRCheck( JET_errIndexInvalidDef );
			Call( err );			
			}

		idb.SetCidxsegConditional( BYTE( pidxcreate->cConditionalColumn ) );
		for ( iidxseg = 0 ; iidxseg < idb.CidxsegConditional(); iidxseg++ )
			{
			COLUMNID				columnidT;
			const CHAR				* const szColumnName	= pidxcreate->rgconditionalcolumn[iidxseg].szColumnName;
			BOOL					fColumnWasDerived		= fFalse;
			const JET_GRBIT			grbit					= pidxcreate->rgconditionalcolumn[iidxseg].grbit;
			const JET_COLUMNCREATE	* pcolcreate 			= ptablecreate->rgcolumncreate;
			const JET_COLUMNCREATE	* const plastcolcreate 	= pcolcreate + ptablecreate->cColumns;

			Assert( sizeof( rgidxsegConditional ) / sizeof( rgidxsegConditional[0] ) == JET_ccolKeyMost );

			if( sizeof( JET_CONDITIONALCOLUMN ) != pidxcreate->rgconditionalcolumn[iidxseg].cbStruct )
				{
				err = ErrERRCheck( JET_errIndexInvalidDef );
				Call( err );			
				}
				
			if( JET_bitIndexColumnMustBeNonNull != grbit
				&& JET_bitIndexColumnMustBeNull != grbit )
				{
				err = ErrERRCheck( JET_errInvalidGrbit );
				Call( err );			
				}

			Assert( NULL != pcolcreate );
			for ( ; pcolcreate < plastcolcreate; pcolcreate++ )
				{
				Assert( pcolcreate->cbStruct == sizeof(JET_COLUMNCREATE) );
				Assert( pcolcreate->err >= 0 );		// must have been created successfully
				if ( UtilCmpName( szColumnName, pcolcreate->szColumnName ) == 0 )
					break;
				}
					
			if ( plastcolcreate != pcolcreate )
				{
				columnidT = pcolcreate->columnid;
				Assert( ( fTemplateTable && FCOLUMNIDTemplateColumn( columnidT ) )
					|| ( !fTemplateTable && !FCOLUMNIDTemplateColumn( columnidT ) ) );
				}
			else
				{
				FIELD	*pfield	= pfieldNil;

				//	column is not in table, so check template table (if any)
				if ( pfcbNil != pfcbTemplateTable )
					{
					Assert( !fTemplateTable );
					CallS( ErrFILEPfieldFromColumnName(
								ppib,
								pfcbTemplateTable,
								szColumnName,
								&pfield,
								&columnidT ) );
					}

				if ( pfieldNil == pfield )
					{
					err = ErrERRCheck( JET_errColumnNotFound );
					goto HandleError;
					}
				else
					{
					Assert( FCOLUMNIDTemplateColumn( columnidT ) );
					}
				}

			Assert( FCOLUMNIDValid( columnidT ) );

			rgidxsegConditional[iidxseg].ResetFlags();

			if ( JET_bitIndexColumnMustBeNull == grbit )
				{
				rgidxsegConditional[iidxseg].SetFMustBeNull();
				}

			rgidxsegConditional[iidxseg].SetColumnid( columnidT );
			}

		if ( idb.FPrimary() )
			{
			if ( fProcessedPrimary )
				{
				err = ErrERRCheck( JET_errIndexHasPrimary );
				goto HandleError;
				}

			fProcessedPrimary = fTrue;
			pgnoIndexFDP = pgnoTableFDP;
			objidIndex = objidTable;
			}
		else
			{
			Call( ErrDIRCreateDirectory(
						pfucbTableExtent,
						(CPG)0,
						&pgnoIndexFDP,
						&objidIndex,
						CPAGE::fPageIndex | ( idb.FUnique() ? 0 : CPAGE::fPageNonUniqueKeys ),
						fSPUnversionedExtent | ( idb.FUnique() ? 0 : fSPNonUnique ) ) );
			Assert( pgnoIndexFDP != pgnoTableFDP );
			Assert( objidIndex > objidSystemRoot );
			
			//	objids are monotonically increasing, so an index should
			//	always have higher objid than its table
			Assert( objidIndex > objidTable );
			}

		ptablecreate->cCreated++;
		Assert( ptablecreate->cCreated <= 1 + ptablecreate->cColumns + ptablecreate->cIndexes );

		fSetIndexError = fFalse;

		if ( fTemplateTable )
			{
			Assert( NULL == ptablecreate->szTemplateTableName );
			
			// If we're creating a template table, this must be a template index.
			idb.SetFTemplateIndex();
			}

		Assert( !idb.FVersioned() );
		Assert( !idb.FVersionedCreate() );
		
		Call( ErrCATAddTableIndex(
					ppib,
					pfucbCatalog,
					objidTable,
					szIndexName,
					pgnoIndexFDP,
					objidIndex,
					&idb,
					rgidxseg,
					rgidxsegConditional,
					ulDensity ) );
		}

HandleError:
	if ( pfucbNil != pfucbCatalog )
		{
		CallS( ErrCATClose( ppib, pfucbCatalog ) );
		}
		
	Assert( pfucbTableExtent != pfucbNil );
	Assert( pfucbTableExtent->u.pfcb->WRefCount() == 1 );

	//	force the FCB to be uninitialized so it will be purged by DIRClose

	pfucbTableExtent->u.pfcb->Lock();
	pfucbTableExtent->u.pfcb->CreateComplete( errFCBUnusable );
	pfucbTableExtent->u.pfcb->Unlock();

	//	verify that this FUCB will not be defer-closed

	Assert( !FFUCBVersioned( pfucbTableExtent ) );
	
	//	close the FUCB

	DIRClose( pfucbTableExtent );
		
	if ( fSetIndexError )
		{
		Assert( err < 0 );
		Assert( pidxcreate != NULL );
		Assert( sizeof( JET_INDEXCREATE ) == pidxcreate->cbStruct );
		Assert( JET_errSuccess == pidxcreate->err );
		pidxcreate->err = err;	//lint !e644
		if( NULL != pidxcreateold )
			{
			// pidxcreateold points to the real structure. return the error value in it.
			Assert( sizeof( JET_INDEXCREATEOLD ) == pidxcreateold->cbStruct );
			Assert( JET_errSuccess == pidxcreateold->err );
			pidxcreateold->err = err;
			}
		}

	return err;
	}


LOCAL ERR ErrFILEIInheritIndexes(
	PIB				*ppib,
	const IFMP		ifmp,
	JET_TABLECREATE2*ptablecreate,
	const PGNO		pgnoTableFDP,
	const OBJID		objidTable,
	FCB				*pfcbTemplateTable )
	{
	ERR				err = JET_errSuccess;
	FUCB			*pfucbTableExtent	= pfucbNil;
	FUCB			*pfucbCatalog		= pfucbNil;
	TDB				*ptdbTemplateTable;
	FCB				*pfcbIndex;
	PGNO			pgnoIndexFDP;
	OBJID			objidIndex;

	// Temp tables and catalogs don't use hierarchical DDL.
	Assert( rgfmp[ ifmp ].Dbid() != dbidTemp );
	Assert( !FCATSystemTable( pgnoTableFDP ) );

	Assert( pfcbTemplateTable->FPrimaryIndex() );
	Assert( pfcbTemplateTable->FTypeTable() );
	Assert( pfcbTemplateTable->FFixedDDL() );
	Assert( pfcbTemplateTable->FTemplateTable() );

	// Open cursor for space navigation
	CallR( ErrDIROpen( ppib, pgnoTableFDP, ifmp, &pfucbTableExtent ) );
	Assert( pfucbNil != pfucbTableExtent );
	Assert( !FFUCBVersioned( pfucbTableExtent ) );	// Verify won't be deferred closed.
	Assert( pfcbNil != pfucbTableExtent->u.pfcb );
	Assert( !pfucbTableExtent->u.pfcb->FInitialized() );
	Assert( pfucbTableExtent->u.pfcb->Pidb() == pidbNil );

	//	force the FCB to be initialized successfully

	pfucbTableExtent->u.pfcb->Lock();
	pfucbTableExtent->u.pfcb->CreateComplete();
	pfucbTableExtent->u.pfcb->Unlock();
	
	Call( ErrCATOpen( ppib, ifmp, &pfucbCatalog ) );
	Assert( pfucbNil != pfucbCatalog );

	ptdbTemplateTable = pfcbTemplateTable->Ptdb();
	Assert( ptdbNil != ptdbTemplateTable );
		
	
	if ( pfcbTemplateTable->Pidb() == pidbNil )
		{
		Assert( pfcbTemplateTable->FSequentialIndex() );
		pfcbIndex = pfcbTemplateTable->PfcbNextIndex();
		}
	else
		{
		Assert( !pfcbTemplateTable->FSequentialIndex() );
		pfcbIndex = pfcbTemplateTable;
		}

	for ( ; pfcbIndex != pfcbNil; pfcbIndex = pfcbIndex->PfcbNextIndex() )
		{
		Assert( pfcbIndex == pfcbTemplateTable || pfcbIndex->FTypeSecondaryIndex() );
		Assert( pfcbIndex->FTemplateIndex() );
		Assert( pfcbIndex->Pidb() != pidbNil );
		
		IDB	idb = *pfcbIndex->Pidb();

		Assert( idb.FTemplateIndex() );
		Assert( !idb.FDerivedIndex() );
		idb.SetFDerivedIndex();
		idb.ResetFTemplateIndex();

		if ( idb.FPrimary() )
			{
			Assert( pfcbIndex == pfcbTemplateTable );
			pgnoIndexFDP = pgnoTableFDP;
			objidIndex = objidTable;
			}
		else
			{
			Call( ErrDIRCreateDirectory(
						pfucbTableExtent,
						(CPG)0,
						&pgnoIndexFDP,
						&objidIndex,
						CPAGE::fPageIndex | ( idb.FUnique() ? 0 : CPAGE::fPageNonUniqueKeys ),
						fSPUnversionedExtent | ( idb.FUnique() ? 0 : fSPNonUnique ) ) );
			Assert( pgnoIndexFDP != pgnoTableFDP );
			Assert( objidIndex > objidSystemRoot );
			
			//	objids are monotonically increasing, so an index should
			//	always have higher objid than its table
			Assert( objidIndex > objidTable );
			}


		// Can hold pointers into the TDB's memory pool because the
		// template table has fixed DDL (and therefore, a fixed memory pool).
		Assert( pfcbTemplateTable->FFixedDDL() );
		
		const IDXSEG*	rgidxseg;
		const IDXSEG*	rgidxsegConditional;
		CHAR*			szIndexName;
		
		Assert( idb.Cidxseg() > 0 );
		rgidxseg = PidxsegIDBGetIdxSeg( pfcbIndex->Pidb(), pfcbTemplateTable->Ptdb() );
		rgidxsegConditional = PidxsegIDBGetIdxSegConditional( pfcbIndex->Pidb(), pfcbTemplateTable->Ptdb() );
		szIndexName = ptdbTemplateTable->SzIndexName( idb.ItagIndexName() );

		Assert( !idb.FVersioned() );
		Assert( !idb.FVersionedCreate() );
		
		Call( ErrCATAddTableIndex(
					ppib,
					pfucbCatalog,
					objidTable,
					szIndexName,
					pgnoIndexFDP,
					objidIndex,
					&idb,
					rgidxseg,
					rgidxsegConditional,
					pfcbIndex->UlDensity() ) );
		}

HandleError:
	if ( pfucbNil != pfucbCatalog )
		{
		CallS( ErrCATClose( ppib, pfucbCatalog ) );
		}
		
	Assert( pfucbTableExtent != pfucbNil );
	Assert( pfucbTableExtent->u.pfcb->WRefCount() == 1 );

	//	force the FCB to be uninitialized so it will be purged by DIRClose

	pfucbTableExtent->u.pfcb->Lock();
	pfucbTableExtent->u.pfcb->CreateComplete( errFCBUnusable );
	pfucbTableExtent->u.pfcb->Unlock();

	//	verify that this FUCB will not be defer-closed

	Assert( !FFUCBVersioned( pfucbTableExtent ) );

	//	close the FUCB

	DIRClose( pfucbTableExtent );
		
	return err;
	}


//  ================================================================
LOCAL ERR ErrFILEIValidateCallback(
	const PIB * const ppib,
	const IFMP ifmp,
	const OBJID objidTable,
	const JET_CBTYP cbtyp,
	const CHAR * const szCallback ) 
//  ================================================================
	{
	if( 0 == cbtyp )
		{
		return ErrERRCheck( JET_errInvalidParameter );
		}
	if( NULL == szCallback )
		{
		return ErrERRCheck( JET_errInvalidParameter );
		}
	if( strlen( szCallback ) >= JET_cbColumnMost )
		{
		return ErrERRCheck( JET_errInvalidParameter );
		}
	return JET_errSuccess;
	}


//  ================================================================
LOCAL ERR ErrFILEICreateCallbacks(
	PIB * const ppib,
	const IFMP ifmp,
	JET_TABLECREATE2 * const ptablecreate,
	const OBJID objidTable )
//  ================================================================
	{
	Assert( sizeof( JET_TABLECREATE2 ) == ptablecreate->cbStruct );

	ERR	err = JET_errSuccess;

	Call( ErrFILEIValidateCallback( ppib, ifmp, objidTable, ptablecreate->cbtyp, ptablecreate->szCallback ) );
	if( !g_fCallbacksDisabled )
		{
		JET_CALLBACK callback = NULL;
		Call( ErrCALLBACKResolve( ptablecreate->szCallback, &callback ) );
		Assert( NULL != callback );
		}
	Call( ErrCATAddTableCallback( ppib, ifmp, objidTable, ptablecreate->cbtyp, ptablecreate->szCallback ) );	
	++(ptablecreate->cCreated);
	Assert( ptablecreate->cCreated <= 1 + ptablecreate->cColumns + ptablecreate->cIndexes + 1 );
		
HandleError:
	return err;
	}

	
//+API
// ErrFILECreateTable
// =========================================================================
// ERR ErrFILECreateTable( PIB *ppib, IFMP ifmp, CHAR *szName,
//		ULONG ulPages, ULONG ulDensity, FUCB **ppfucb )
//
// Create file with pathname szName.  Created file will have no fields or
// indexes defined (and so will be a "sequential" file ).
//
// PARAMETERS
//					ppib   			PIB of user
//					ifmp   			database id
//					szName			path name of new file
//					ulPages			initial page allocation for file
//					ulDensity		initial loading density
//					ppfucb			Exclusively locked FUCB on new file
// RETURNS		Error codes from DIRMAN or
//					 JET_errSuccess		Everything worked OK
//					-DensityInvalid	  	Density parameter not valid
//					-TableDuplicate   	A file already exists with the path given
// COMMENTS		A transaction is wrapped around this function.	Thus, any
//			 	work done will be undone if a failure occurs.
// SEE ALSO		ErrIsamAddColumn, ErrIsamCreateIndex, ErrIsamDeleteTable
//-
ERR ErrFILECreateTable( PIB *ppib, IFMP ifmp, JET_TABLECREATE2 *ptablecreate )
	{
	ERR		  	err;
	CHAR	  	szTable[JET_cbNameMost+1];
	FUCB	  	*pfucb;
	FDPINFO		fdpinfo;
	VER			*pver;
	BOOL		fOpenedTable	= fFalse;

	FMP::AssertVALIDIFMP( ifmp );
	Assert( sizeof(JET_TABLECREATE2) == ptablecreate->cbStruct );

	ptablecreate->cCreated = 0;

	//	check parms
	//
	CheckPIB(ppib );
	CheckDBID( ppib, ifmp );
	CallR( ErrUTILCheckName( szTable, ptablecreate->szTableName, JET_cbNameMost+1 ) );

	Assert( !( ptablecreate->grbit & JET_bitTableCreateSystemTable )
		|| FOLDSystemTable( szTable ) );
	
	ULONG		ulTableDensity		= ptablecreate->ulDensity;
	if ( 0 == ulTableDensity )
		{
		ulTableDensity = ulFILEDefaultDensity;
		}
	else if ( ulTableDensity < ulFILEDensityLeast || ulTableDensity > ulFILEDensityMost )
		{
		return ErrERRCheck( JET_errDensityInvalid );
		}

	const BOOL	fTemplateTable		= ( ptablecreate->grbit & JET_bitTableCreateTemplateTable );
	const BOOL	fDerived			= ( ptablecreate->szTemplateTableName != NULL );
	FCB			*pfcbTemplateTable	= pfcbNil;
	if ( fDerived )
		{
		FUCB	*pfucbTemplateTable;

		Assert( dbidTemp != rgfmp[ ifmp ].Dbid() );
		
		//	UNDONE:	nested hierarchical DDL not yet supported
		//
		Assert( !fTemplateTable );

		//	bring base table FCB into memory
		//
		CallR( ErrFILEOpenTable(
			ppib,
			ifmp,
			&pfucbTemplateTable,
			ptablecreate->szTemplateTableName,
			JET_bitTableReadOnly ) );

		Assert( pfcbNil == pfcbTemplateTable );
		if ( pfucbTemplateTable->u.pfcb->FTemplateTable() )
			{
			Assert( pfucbTemplateTable->u.pfcb->FFixedDDL() );
			pfcbTemplateTable = pfucbTemplateTable->u.pfcb;
			}

		//	close cursor.  FCB will be pinned in memory because
		//	FAvail_() checks for the TemplateTable flag.
		//
		CallS( ErrFILECloseTable( ppib, pfucbTemplateTable ) );

		if ( pfcbNil == pfcbTemplateTable )
			return ErrERRCheck( JET_errDDLNotInheritable );
		}

	CallR( ErrDIRBeginTransaction( ppib, NO_GRBIT ) );

	//	allocate cursor
	//
	Call( ErrDIROpen( ppib, pgnoSystemRoot, ifmp, &pfucb ) );
	Call( ErrDIRCreateDirectory(
				pfucb,
				max( (CPG)ptablecreate->ulPages, cpgTableMin ),
				&fdpinfo.pgnoFDP,
				&fdpinfo.objidFDP,
				CPAGE::fPagePrimary,
				dbidTemp == rgfmp[ ifmp ].Dbid() ? fSPUnversionedExtent : 0 ) );	// For temp. tables, create unversioned extents
	DIRClose( pfucb );

	Assert( ptablecreate->cCreated == 0 );
	ptablecreate->cCreated = 1;

	if ( dbidTemp == rgfmp[ ifmp ].Dbid() )
		{
		//	don't currently support creation of columns/indexes for temp.
		//	tables via this API.
		Assert( 0 == ptablecreate->cColumns );
		Assert( 0 == ptablecreate->cIndexes );
		Assert( NULL == ptablecreate->szCallback );
		}
		
	else
		{
		Assert( !FCATSystemTable( fdpinfo.pgnoFDP ) );
		Assert( fdpinfo.objidFDP > objidSystemRoot );
		
		//	insert record in MSysObjects
		//
		JET_GRBIT	grbit;
		if ( fTemplateTable )
			{
			Assert( !fDerived );	// UNDONE: Nested hierarchical DDL not yet supported
			Assert( !( ptablecreate->grbit & JET_bitTableCreateSystemTable ) );
			grbit = ( JET_bitObjectTableTemplate | JET_bitObjectTableFixedDDL );
			}
		else
			{
			Assert( !( ptablecreate->grbit & JET_bitTableCreateNoFixedVarColumnsInDerivedTables ) );
			grbit = 0;
			if ( fDerived )
				grbit |= JET_bitObjectTableDerived;
			if ( ptablecreate->grbit & JET_bitTableCreateFixedDDL )
				grbit |= JET_bitObjectTableFixedDDL;
			if ( ptablecreate->grbit & JET_bitTableCreateSystemTable )
				{
				//	if calling CreateTable(), this must be a dynamic system table
				grbit |= JET_bitObjectSystemDynamic;
				Assert( FOLDSystemTable( szTable ) );
				}
			}
				
#ifdef DEBUG
		if ( fDerived )
			{
			Assert( pfcbNil != pfcbTemplateTable );
			Assert( NULL != ptablecreate->szTemplateTableName );
			}
		else
			{
			Assert( pfcbNil == pfcbTemplateTable );
			Assert( NULL == ptablecreate->szTemplateTableName );
			}
#endif				

		Call( ErrCATAddTable(
					ppib,
					ifmp,
					fdpinfo.pgnoFDP,
					fdpinfo.objidFDP,
					szTable,
					ptablecreate->szTemplateTableName,
					ptablecreate->ulPages,
					ulTableDensity,
					grbit ) );


		//	create columns and indexes as necessary.
		
		if ( fDerived )
			{
			Call( ErrFILEIInheritIndexes(
					ppib,
					ifmp,
					ptablecreate,
					fdpinfo.pgnoFDP,
					fdpinfo.objidFDP,
					pfcbTemplateTable ) );
			}
		if ( ptablecreate->cColumns > 0 )
			{
			Call( ErrFILEIAddColumns(
					ppib,
					ifmp,
					ptablecreate,
					fdpinfo.objidFDP,
					pfcbTemplateTable ) );
			}
		Assert( ptablecreate->cCreated == 1 + ptablecreate->cColumns );

		if ( ptablecreate->cIndexes > 0 )
			{
			Call( ErrFILEICreateIndexes(
					ppib,
					ifmp,
					ptablecreate,
					fdpinfo.pgnoFDP,
					fdpinfo.objidFDP,
					ulTableDensity,
					pfcbTemplateTable ) );
			}

		if ( NULL != ptablecreate->szCallback )
			{
			Call( ErrFILEICreateCallbacks(
					ppib,
					ifmp,
					ptablecreate,
					fdpinfo.objidFDP ) );
			}

		}
		

	Assert( ptablecreate->cCreated == 1 + ptablecreate->cColumns + ptablecreate->cIndexes + ( ptablecreate->szCallback ? 1 : 0 ) );

	
	//	open table in exclusive mode, for output parameter
	//
	Call( ErrFILEOpenTable(
			ppib,
			ifmp,
			&pfucb, 
			szTable,
			JET_bitTableCreate|JET_bitTableDenyRead,
			&fdpinfo ) );
	fOpenedTable = fTrue;

#ifdef DEBUG		
	if ( 0 == ptablecreate->cColumns )
		{
		TDB	*ptdb = pfucb->u.pfcb->Ptdb();
		Assert( ptdb->FidFixedLast() == ptdb->FidFixedFirst()-1 );
		Assert( ptdb->FidVarLast() == ptdb->FidVarFirst()-1 );
		Assert( ptdb->FidTaggedLast() == ptdb->FidTaggedFirst()-1 );
		}
#endif
			
	// Allow DDL until table (cursor) is closed.
	if ( pfucb->u.pfcb->FFixedDDL() && !fTemplateTable )
		FUCBSetPermitDDL( pfucb );

	Assert( pfucb->u.pfcb->FInitialized() );
	Assert( pfucb->u.pfcb->FTypeTable() || pfucb->u.pfcb->FTypeTemporaryTable() );
	Assert( pfucb->u.pfcb->FPrimaryIndex() );

	pver = PverFromIfmp( pfucb->ifmp );
	Call( pver->ErrVERFlag( pfucb, operCreateTable, NULL, 0 ) );

	Call( ErrDIRCommitTransaction( ppib, 0 ) );

#ifdef NEVER
	//  HACK: run the SLV internal tests
	if( dbidTemp != ifmp )
		{
		static fRunOnce = fFalse;
		if( !fRunOnce )
			{
			extern ERR ErrSLVSpaceTest( PIB * const ppib, FUCB * const pfucb );
			CallS( ErrSLVSpaceTest( ppib, pfucb ) );
			fRunOnce = fTrue;
			}
		}
#endif

	/*	internally, we use tableid and pfucb interchangeably
	/**/
	ptablecreate->tableid = (JET_TABLEID)pfucb;

	return JET_errSuccess;

HandleError:
	if ( fOpenedTable )
		{
		CallS( ErrFILECloseTable( ppib, pfucb ) );
		}

	//	pfucb is closed by rollback if necessary
	//
	CallSx( ErrDIRRollback( ppib ), JET_errRollbackError );

	//	reset return variable if close table via rollback
	//
	ptablecreate->tableid = JET_tableidNil;

	return err;
	}


//====================================================
// Determine field "mode" as follows:
// if ("long" textual || JET_bitColumnTagged given ) ==> TAGGED
// else if (numeric type || JET_bitColumnFixed given ) ==> FIXED
// else ==> VARIABLE
//====================================================
ERR ErrFILEGetNextColumnid(
	const JET_COLTYP	coltyp,
	const JET_GRBIT		grbit,
	const BOOL			fTemplateTable,
	TCIB				*ptcib, 
	COLUMNID			*pcolumnid )
	{
	FID					fid;
	FID					fidMost;

	if ( ( grbit & JET_bitColumnTagged ) || FRECLongValue( coltyp ) || FRECSLV( coltyp ) )
		{
		Assert( fidTaggedLeast-1 == ptcib->fidTaggedLast || FTaggedFid( ptcib->fidTaggedLast ) );
		fid = ++(ptcib->fidTaggedLast);
		fidMost = fidTaggedMost;
		}
	else if ( ( grbit & JET_bitColumnFixed ) || FCOLTYPFixedLength( coltyp ) )
		{
		Assert( fidFixedLeast-1 == ptcib->fidFixedLast || FFixedFid( ptcib->fidFixedLast ) );
		fid = ++(ptcib->fidFixedLast);
		fidMost = fidFixedMost;
		}
	else
		{
		Assert( !( grbit & JET_bitColumnTagged ) );
		Assert( !( grbit & JET_bitColumnFixed ) );
		Assert( JET_coltypText == coltyp || JET_coltypBinary == coltyp );
		Assert( fidVarLeast-1 == ptcib->fidVarLast || FVarFid( ptcib->fidVarLast ) );
		fid = ++(ptcib->fidVarLast);
		fidMost = fidVarMost;
		}
	if ( fid > fidMost )
		{
		return ErrERRCheck( JET_errTooManyColumns );
		}
	*pcolumnid = ColumnidOfFid( fid, fTemplateTable );
	return JET_errSuccess;
	}

INLINE ERR ErrFILEIUpdateAutoInc( PIB *ppib, FUCB *pfucb )
	{
	ERR				err;
	QWORD			qwT				= 1;
	TDB				* const ptdb	= pfucb->u.pfcb->Ptdb();
	const BOOL		f8BytesAutoInc	= ptdb->F8BytesAutoInc();
	const BOOL		fTemplateColumn	= ptdb->FFixedTemplateColumn( ptdb->FidAutoincrement() );
	const COLUMNID	columnidT		= ColumnidOfFid( ptdb->FidAutoincrement(), fTemplateColumn );

	// set column does not allow sets over an
	// autoincrement column.  To work around this,
	// temporarily disable AutoInc column.
	Assert( pfucb->u.pfcb->FDomainDenyReadByUs( ppib ) );
	ptdb->ResetFidAutoincrement();

	err = ErrIsamMove( ppib, pfucb, JET_MoveFirst, NO_GRBIT );
	Assert( err <= 0 );
	while ( JET_errSuccess == err )
		{
		Call( ErrIsamPrepareUpdate( ppib, pfucb, JET_prepReplaceNoLock ) );

		if ( !f8BytesAutoInc )
			{
			ULONG ulT;
			ulT = (ULONG)qwT;
			Call( ErrIsamSetColumn( ppib,
					pfucb,
					columnidT,
					(BYTE *)&ulT,
			  		sizeof(ulT),
					NO_GRBIT,
					NULL ) );
			}
		else
			{
			Call( ErrIsamSetColumn( ppib,
					pfucb,
					columnidT,
					(BYTE *)&qwT,
			  		sizeof(qwT),
					NO_GRBIT,
					NULL ) );
			}		
		Call( ErrIsamUpdate( ppib, pfucb, NULL, 0, NULL, NO_GRBIT ) );
		
		qwT++;
		err = ErrIsamMove( ppib, pfucb, JET_MoveNext, NO_GRBIT );
		Assert( err <= 0 );
		}

	Assert( err < 0 );
	if ( JET_errNoCurrentRecord == err )
		{
		//	we have exclusive use of the table, so we should always succeed
		ptdb->SetFidAutoincrement( FidOfColumnid( columnidT ), f8BytesAutoInc );
		Assert( ptdb->QwAutoincrement() == 0 );
		ptdb->InitAutoincrement( qwT );
		Assert( ptdb->QwAutoincrement() == qwT );
		err = JET_errSuccess;
		}
	else
		{
HandleError:
		ptdb->SetFidAutoincrement( FidOfColumnid( columnidT ), f8BytesAutoInc );
		}

	return err;
	}


//+API
// ErrIsamAddColumn
// ========================================================================
// ERR ErrIsamAddColumn(
//		PIB				*ppib;			// IN PIB of user
//		FUCB			*pfucb;	 		// IN Exclusively opened FUCB on file
//		CHAR			*szName;		// IN name of new field
//		JET_COLUMNDEF	*pcolumndef		// IN definition of column added
//		BYTE			*pvDefault		// IN Default value of column
//		ULONG			cbDefault		// IN length of Default value
//		JET_COLUMNID	*pcolumnid )	// OUT columnid of added column
//
// Creates a new field definition for a file.
//
// PARAMETERS
//				pcolumndef->coltyp			data type of new field, see jet.h
//				pcolumndef->grbit  			field describing flags:
//					VALUE				MEANING
//					========================================
//					JET_bitColumnNotNULL		 	Indicates that the field may
//													not take on NULL values.
//					JET_bitColumnTagged		 		The field is a "tagged" field.
//					JET_bitColumnVersion		 	The field is a version field
//
// RETURNS		JET_errSuccess			Everything worked OK.
//					-TaggedDefault			A default value was specified
//												for a tagged field.
//					-ColumnDuplicate		There is already a field
//												defined for the name given.
// COMMENTS
//		There must not be anyone currently using the file, unless
//		the ErrIsamAddColumn is at level 0 [when non-exclusive ErrIsamAddColumn works].
//		A transaction is wrapped around this function.	Thus, any
//		work done will be undone if a failure occurs.
//		Transaction logging is turned off for temporary files.
//
// SEE ALSO		ErrIsamCreateTable, ErrIsamCreateIndex
//-
ERR VTAPI ErrIsamAddColumn(
	JET_SESID			sesid,
	JET_VTID			vtid,
	const CHAR		  	* const szName,
	const JET_COLUMNDEF	* const pcolumndef,
	const VOID		  	* const pvDefault,
	ULONG			  	cbDefault,
	JET_COLUMNID		* const pcolumnid )
	{
	ERR					err;
 	PIB					* const ppib				= reinterpret_cast<PIB *>( sesid );
	FUCB				* const pfucb				= reinterpret_cast<FUCB *>( vtid );
	TCIB				tcib;
	CHAR				szFieldName[JET_cbNameMost+1];
	FCB					*pfcb;
	TDB					*ptdb;
	JET_COLUMNID		columnid;
	VERADDCOLUMN		veraddcolumn;
	FIELD				field;
	BOOL		  		fMaxTruncated;
	ULONG				cFixed, cVar, cTagged;
	ULONG				cbFieldsTotal, cbFieldsUsed;
	BOOL				fInCritDDL					= fFalse;
	FIELD				*pfieldNew					= pfieldNil;
	BOOL				fUnversioned				= fFalse;
	BOOL				fSetVersioned				= fFalse;
	BOOL				fOverrideFixedDDL			= fFalse;
	VER					*pver;

	//  this is the data that will actually be inserted into the catalog
	const VOID			*pvDefaultAdd 				= pvDefault;
	ULONG				cbDefaultAdd 				= cbDefault;
	CHAR				*szCallbackAdd				= NULL;
	const VOID			*pvUserDataAdd				= NULL;
	ULONG				cbUserDataAdd				= 0;

	//	check paramaters
	//
	CallR( ErrPIBCheck( ppib ) );
	Assert( pfucb != pfucbNil );
	CheckTable( ppib, pfucb );
	FMP::AssertVALIDIFMP( pfucb->ifmp );

	//	ensure that table is updatable
	//
	CallR( ErrFUCBCheckUpdatable( pfucb ) );
	CallR( ErrPIBCheckUpdatable( ppib ) );

	pfcb = pfucb->u.pfcb;
	Assert( pfcb->WRefCount() > 0 );
	Assert( pfcb->FTypeTable() );	// Temp. tables have fixed DDL.

	ptdb = pfcb->Ptdb();
	Assert( ptdbNil != ptdb );

	if ( pfcb->FFixedDDL() )
		{
		// Check FixedDDL override.
		if ( !FFUCBPermitDDL( pfucb ) )
			return ErrERRCheck( JET_errFixedDDL );
			
		// If DDL temporarily permitted, we must have exclusive use of the table.
		Assert( pfcb->FDomainDenyReadByUs( ppib ) );

		fOverrideFixedDDL = fTrue;
		}

	if ( pcolumndef->cbStruct < sizeof(JET_COLUMNDEF) )
		{
		return ErrERRCheck( JET_errInvalidParameter );
		}

	if ( pcolumndef->grbit & JET_bitColumnUnversioned )
		{
		if ( !FFUCBDenyRead( pfucb ) )
			{
			if ( ppib->level != 0 )
				{
				AssertSz( fFalse, "Must not be in transaction for unversioned AddColumn." );
				err = ErrERRCheck( JET_errInTransaction );
				return err;
				}
			fUnversioned = fTrue;
			}
		}

	//	UNDONE:	interpret pvDefault of NULL for NULL value, and
	//			cbDefault == 0 and pvDefault != NULL as set to 
	//			zero length.
	Assert( cbDefault == 0 || pvDefault != NULL );

	memset( &field, 0, sizeof(FIELD) );
	field.coltyp = FIELD_COLTYP( pcolumndef->coltyp );
	field.cbMaxLen = pcolumndef->cbMax;
	field.cp = pcolumndef->cp;

	CallR( ErrFILEIValidateAddColumn(
				szName,
				szFieldName,
				&field,
				pcolumndef->grbit,
				( pvDefault ? cbDefault : 0 ),
				pfcb->FDomainDenyReadByUs( ppib ),
				ptdb->PfcbTemplateTable() ) );
	fMaxTruncated = ( JET_wrnColumnMaxTruncated == err );

	if ( FRECSLV( field.coltyp ) && !rgfmp[pfucb->ifmp].FSLVAttached() )
		{
		err = ErrERRCheck( JET_errSLVStreamingFileNotCreated );
		return err;
		}

	if ( fUnversioned )
		{
		CallR( ErrFILEInsertIntoUnverColumnList( pfcb, szFieldName ) );
		}

	if ( FFIELDEscrowUpdate( field.ffield ) )
		{
		//  see the comment int ErrFILEIValidateAddColumn to find out why we
		//  cannot add an escrow column to a table with any records in it
		Assert( pfcb->FDomainDenyReadByUs( ppib ) );
		Assert( FFIELDDefault( field.ffield ) );
		
		//	check for any node there, even if it is deleted.  This
		//	is too strong since it may be deleted and committed,
		//	but this strong check ensures that no potentially there
		//	records exist.
		DIB dib;
		dib.dirflag = fDIRAllNode;
		dib.pos		= posFirst;
		DIRGotoRoot( pfucb );
		if ( ( err = ErrDIRDown( pfucb, &dib ) ) != JET_errRecordNotFound )
			{
			if ( JET_errSuccess == err )
				{
				err = ErrERRCheck( JET_errTableNotEmpty );
				DIRUp( pfucb );
				DIRDeferMoveFirst( pfucb );
				}					
			return err;
			}
		DIRGotoRoot( pfucb );
		}

	CallR( ErrDIRBeginTransaction( ppib, NO_GRBIT ) );

	const PGNO	pgnoFDP			= pfcb->PgnoFDP();
	const OBJID	objidTable		= pfcb->ObjidFDP();
	FUCB		fucbFake;		// for rebuilding default record
	FCB			fcbFake( pfucb->ifmp, pgnoFDP );

	if ( FFIELDDefault( field.ffield ) && !FFIELDUserDefinedDefault( field.ffield ) )
		{
		// pre-allocate buffer for rebuilding default record
		//
		FILEPrepareDefaultRecord( &fucbFake, &fcbFake, ptdb );
		Assert( fucbFake.pvWorkBuf != NULL );
		}
	else
		{
		fucbFake.pvWorkBuf = NULL;
		}

	//	move to FDP root and update FDP timestamp
	//
	Assert( ppib->level < levelMax );
	DIRGotoRoot( pfucb );

	pfcb->EnterDDL();
	fInCritDDL = fTrue;
	
	//	set tcib
	//
	tcib.fidFixedLast = ptdb->FidFixedLast();
	tcib.fidVarLast = ptdb->FidVarLast();
	tcib.fidTaggedLast = ptdb->FidTaggedLast();

	//******************************************************
	//	Determine maximum field length as follows:
	//	switch field type
	//		case numeric:
	//			max = <exact length of specified type>;
	//		case "short" textual ( Text || Binary ):
	//			if (specified max == 0 ) max = JET_cbColumnMost
	//			else max = MIN( JET_cbColumnMost, specified max )
	//		case "long" textual (Memo || Graphic ):
	//			max = specified max (if 0, unlimited )
	//*****************************************************
	//
	Assert( field.coltyp != JET_coltypNil );

	//	for fixed-length columns, make sure record not too big
	//
	Assert( ptdb->FidFixedLast() >= fidFixedLeast ?
		ptdb->IbEndFixedColumns() > ibRECStartFixedColumns :
		ptdb->IbEndFixedColumns() == ibRECStartFixedColumns );
	if ( ( ( pcolumndef->grbit & JET_bitColumnFixed ) || FCOLTYPFixedLength( field.coltyp ) )
		&& ptdb->IbEndFixedColumns() + field.cbMaxLen > cbRECRecordMost )
		{
		err = ErrERRCheck( JET_errRecordTooBig );
		goto HandleError;
		}

	Call( ErrFILEGetNextColumnid(
			field.coltyp,
			pcolumndef->grbit,
			ptdb->FTemplateTable(),
			&tcib,
			&columnid ) );

	if ( pcolumnid != NULL )
		{
		*pcolumnid = columnid;
		}

	//	version and autoincrement are mutually exclusive
	//
	if ( FFIELDVersion( field.ffield ) )
		{
		if ( ptdb->FidVersion() != 0 )
			{
			err = ErrERRCheck( JET_errColumnRedundant );
			goto HandleError;
			}
		ptdb->SetFidVersion( FidOfColumnid( columnid ) );
		}
	else if ( FFIELDAutoincrement( field.ffield ) )
		{
		if ( ptdb->FidAutoincrement() != 0 )
			{
			err = ErrERRCheck( JET_errColumnRedundant );
			goto HandleError;
			}
		ptdb->SetFidAutoincrement( FidOfColumnid( columnid ), field.coltyp == JET_coltypCurrency );
		}

	//	update TDB and default record value
	//
	cFixed = ptdb->CDynamicFixedColumns();
	cVar = ptdb->CDynamicVarColumns();
	cTagged = ptdb->CDynamicTaggedColumns();
	cbFieldsUsed = ( cFixed + cVar + cTagged ) * sizeof(FIELD);
	cbFieldsTotal = ptdb->MemPool().CbGetEntry( itagTDBFields );

	//	WARNING: if cbFieldsTotal is less than even one FIELD,
	//	this is the special-case where we just stuck in a
	//	placeholder in the MEMPOOL for the FIELD structures
	if ( cbFieldsTotal < sizeof(FIELD) )
		{
		Assert( cbFIELDPlaceholder == cbFieldsTotal );
		Assert( 0 == cbFieldsUsed );
		cbFieldsTotal = 0;
		}

	Assert( cbFieldsTotal >= cbFieldsUsed );

	// Is there enough space to add another FIELD?
	if ( sizeof(FIELD) > ( cbFieldsTotal - cbFieldsUsed ) )
		{
		//	add space for another 10 columns
		//
		Call( ptdb->MemPool().ErrReplaceEntry(
			itagTDBFields,
			NULL,
			cbFieldsTotal + ( sizeof(FIELD) * 10 )
			) );
		}

	//	add the column name to the buffer
	//
	Call( ptdb->MemPool().ErrAddEntry(
							reinterpret_cast<BYTE *>( szFieldName ),
							(ULONG)strlen( szFieldName ) + 1,
							&field.itagFieldName ) );
	field.strhashFieldName = StrHashValue( szFieldName );
	Assert( field.itagFieldName != 0 );

	veraddcolumn.columnid = columnid;
										
	Assert( NULL != ptdb->PdataDefaultRecord() );
	if ( FFIELDDefault( field.ffield )
		&& !FFIELDUserDefinedDefault( field.ffield ) )
		{
		//	note that if AddColumn rolls back, the memory may end up
		//	on the FCB RECDANGLING list,
		veraddcolumn.pbOldDefaultRec = (BYTE *)ptdb->PdataDefaultRecord();
		}
	else
		{
		veraddcolumn.pbOldDefaultRec = NULL;
		}

	pver = PverFromIfmp( pfucb->ifmp );
	err = pver->ErrVERFlag( pfucb, operAddColumn, (VOID *)&veraddcolumn, sizeof(VERADDCOLUMN) );
	if ( err < 0 )
		{
		ptdb->MemPool().DeleteEntry( field.itagFieldName );
		field.itagFieldName = 0;
		goto HandleError;
		}

	// If we have the table exclusively locked, then there's no need to
	// set the Versioned bit.
	Assert( !pfcb->FDomainDenyRead( ppib ) );
	if ( !pfcb->FDomainDenyReadByUs( ppib ) )
		{
		FIELDSetVersioned( field.ffield );
		FIELDSetVersionedAdd( field.ffield );
		fSetVersioned = fTrue;
		}

	if ( pfcb->FTemplateTable() )
		{
		Assert( FCOLUMNIDTemplateColumn( columnid ) );
		FIELDSetTemplateColumnESE98( field.ffield );
		}
	else
		{
		Assert( !FCOLUMNIDTemplateColumn( columnid ) );
		}

	//	incrementing fidFixed/Var/TaggedLast guarantees that a new FIELD structure
	//	was added -- rollback checks for this.
	//
	Assert( pfieldNil == pfieldNew );
	if ( FCOLUMNIDFixed( columnid ) )
		{
		Assert( FidOfColumnid( columnid ) == ptdb->FidFixedLast() + 1 );
		ptdb->IncrementFidFixedLast();
		Assert( FFixedFid( ptdb->FidFixedLast() ) );
		pfieldNew = ptdb->PfieldFixed( columnid );

		//	Adjust the location of the FIELD structures for tagged and variable
		//	columns to accommodate the insertion of a fixed column FIELD structure
		//	and its associated entry in the fixed offsets table.
		//	Thus, the new fixed column FIELD structure is now located where
		//	the variable column FIELD structures used to start.
		memmove(
			(BYTE *)pfieldNew + sizeof(FIELD),
			pfieldNew,
			sizeof(FIELD) * ( cVar + cTagged )
			);

		field.ibRecordOffset = ptdb->IbEndFixedColumns();
		
		Assert( ptdb->Pfield( columnid ) == pfieldNew );
		*pfieldNew = field;
		
		Assert( field.ibRecordOffset + field.cbMaxLen <= cbRECRecordMost );
		ptdb->SetIbEndFixedColumns( (WORD)( field.ibRecordOffset + field.cbMaxLen ), ptdb->FidFixedLast() );
		}
	else
		{
		if ( FCOLUMNIDTagged( columnid ) )
			{
			Assert( FidOfColumnid( columnid ) == ptdb->FidTaggedLast() + 1 );

			// Append the new FIELD structure to the end of the tagged column
			// FIELD structures.
			ptdb->IncrementFidTaggedLast();
			Assert( FTaggedFid( ptdb->FidTaggedLast() ) );
			pfieldNew = ptdb->PfieldTagged( columnid );

			//	WARNING:	if the add-column rolls back this flag will not be unset
			
			if( JET_coltypSLV == field.coltyp )
				{
				//	set the SLV flag
				ptdb->SetFTableHasSLVColumn();
				}		
			}
		else
			{
			// The new variable column FIELD structure, now located where
			// the tagged column FIELD structures used to start.
			Assert( FCOLUMNIDVar( columnid ) );
			Assert( FidOfColumnid( columnid ) == ptdb->FidVarLast() + 1 );
			ptdb->IncrementFidVarLast();
			Assert( FVarFid( ptdb->FidVarLast() ) );
			pfieldNew = ptdb->PfieldVar( columnid );

			//	adjust the location of the FIELD structures for tagged columns to
			//	accommodate the insertion of the variable column FIELD structure.
			memmove( pfieldNew + 1, pfieldNew, sizeof(FIELD) * cTagged );
			}
			
		Assert( ptdb->Pfield( columnid ) == pfieldNew );
		*pfieldNew = field;
		}


	Assert( field.itagFieldName != 0 );
	field.itagFieldName = 0;	// From this point on, version cleanup
								// will reclaim name space on rollback.

	if ( FFIELDUserDefinedDefault( field.ffield ) )
		{
		//  the size of the structure should have been checked by ErrFILEIValidateAddColumn
		Assert( NULL != pvDefault );
		Assert( sizeof( JET_USERDEFINEDDEFAULT ) == cbDefault );

		JET_USERDEFINEDDEFAULT * const pudd = (JET_USERDEFINEDDEFAULT *)pvDefault;

		JET_CALLBACK callback;
		Call( ErrCALLBACKResolve( pudd->szCallback, &callback ) );
		
		CBDESC * const pcbdesc = new CBDESC;
		BYTE * const pbUserData = ( ( pudd->cbUserData > 0 ) ?
						(BYTE *)PvOSMemoryHeapAlloc( pudd->cbUserData ) : NULL );

		if( NULL == pcbdesc
			|| ( NULL == pbUserData && pudd->cbUserData > 0 ) )
			{
			delete pcbdesc;
			OSMemoryHeapFree( pbUserData );
			Call( ErrERRCheck( JET_errOutOfMemory ) );
			}

		//  we should not fail between this point and registering the CBDESC in the TDB
		//  once the CBDESC is in the TDB it will be freed by TDB::Delete

		memcpy( pbUserData, pudd->pbUserData, pudd->cbUserData );
		
		pcbdesc->pcallback 	= callback;
		pcbdesc->cbtyp 		= JET_cbtypUserDefinedDefaultValue;
		pcbdesc->pvContext 	= pbUserData;
		pcbdesc->cbContext 	= pudd->cbUserData;
		pcbdesc->ulId 		= columnid;
		pcbdesc->fPermanent = 1;
		pcbdesc->fVersioned = 0;

		//  for user-defined-defaults we don't store a default value at all
		pvDefaultAdd 	= NULL;
		cbDefaultAdd 	= 0;
		szCallbackAdd	= pudd->szCallback;
		pvUserDataAdd 	= pudd->pbUserData;
		cbUserDataAdd 	= pudd->cbUserData;
		
		pfcb->AssertDDL();
		ptdb->RegisterPcbdesc( pcbdesc );

		ptdb->SetFTableHasUserDefinedDefault();
		ptdb->SetFTableHasNonEscrowDefault();
		ptdb->SetFTableHasDefault();
		}
	else if ( FFIELDDefault( field.ffield ) )
		{
		DATA	dataDefault;
		
		Assert( cbDefault > 0 );
		Assert( pvDefault != NULL );
		dataDefault.SetCb( cbDefault );
		dataDefault.SetPv( (VOID *)pvDefault );
		
		Assert( fucbFake.pvWorkBuf != NULL );
		Assert( fucbFake.u.pfcb == &fcbFake );
		Assert( fcbFake.Ptdb() == ptdb );
		Call( ErrFILERebuildDefaultRec( &fucbFake, columnid, &dataDefault ) );

		Assert( NULL != veraddcolumn.pbOldDefaultRec );
		Assert( veraddcolumn.pbOldDefaultRec != (BYTE *)ptdb->PdataDefaultRecord() );
		if ( rgfmp[pfucb->ifmp].FVersioningOff() )
			{
			//	versioning disabled, but we normally rely on version cleanup
			//	to take clean up pbOldDefaultRec, so instead we need to
			//	manually put it on the RECDANGLING list
			for ( RECDANGLING * precdangling = pfcb->Precdangling();
				;
				precdangling = precdangling->precdanglingNext )
				{
				if ( NULL == precdangling )
					{
					//	not in list, so add it;
					//	assumes that the memory pointed to by pmemdangling is always at
					//	least sizeof(ULONG_PTR) bytes
					Assert( NULL == ( (RECDANGLING *)veraddcolumn.pbOldDefaultRec )->precdanglingNext );
					( (RECDANGLING *)veraddcolumn.pbOldDefaultRec )->precdanglingNext = pfcb->Precdangling();
					pfcb->SetPrecdangling( (RECDANGLING *)veraddcolumn.pbOldDefaultRec );
					break;
					}
				else if ( (BYTE *)precdangling == veraddcolumn.pbOldDefaultRec )
					{
					//	pointer is already in the list, just get out
					AssertTracking();
					break;
					}
				}
			}

		if ( !FFIELDEscrowUpdate( field.ffield ) )
			{
			ptdb->SetFTableHasNonEscrowDefault();
			}
		ptdb->SetFTableHasDefault();
		}
		
	pfcb->LeaveDDL();
	fInCritDDL = fFalse;

	//	set currency before first
	//
	DIRBeforeFirst( pfucb );
	if ( pfucb->pfucbCurIndex != pfucbNil )
		{
		DIRBeforeFirst( pfucb->pfucbCurIndex );
		}

	// Insert record into MSysColumns.
	Call( ErrCATAddTableColumn(
				ppib,
				pfucb->ifmp,
				objidTable,
				szFieldName,
				columnid,
				&field,
				pvDefaultAdd,
				cbDefaultAdd,
				szCallbackAdd,
				pvUserDataAdd,
				cbUserDataAdd ) );
					
	if ( ( pcolumndef->grbit & JET_bitColumnAutoincrement ) != 0 )
		{
		Call( ErrFILEIUpdateAutoInc( ppib, pfucb ) );
		}

	Call( ErrDIRCommitTransaction( ppib, 0 ) );

	FILEFreeDefaultRecord( &fucbFake );

	if ( fMaxTruncated )
		return ErrERRCheck( JET_wrnColumnMaxTruncated );

	AssertDIRNoLatch( ppib );

	if ( fUnversioned )
		{
		if ( fSetVersioned )
			{
			// On success, reset versioned bit (on error, bit reset by rollback)
			FIELD	*pfieldT;
			pfcb->EnterDDL();
			Assert( pfcb->Ptdb() == ptdb );
			pfieldT = ptdb->Pfield( columnid );
			FIELDResetVersioned( pfieldT->ffield );
			FIELDResetVersionedAdd( pfieldT->ffield );
			pfcb->LeaveDDL();
			}

		FILERemoveFromUnverList( &punvercolGlobal, critUnverCol, objidTable, szFieldName );
		}

	return JET_errSuccess;

HandleError:
	//	For FixedDDL tables, we assume such tables NEVER have deleted columns,
	//	so we can't tolerate the hack where we set the FIELD of the rolled-back
	//	column to deleted

	// Verify name space has been reclaimed.
	Assert( field.itagFieldName == 0 );
	
	if ( fInCritDDL )
		{
		pfcb->LeaveDDL();
		}

	FILEFreeDefaultRecord( &fucbFake );
				
	CallSx( ErrDIRRollback( ppib ), JET_errRollbackError );

	if ( fUnversioned )
		{
		FILERemoveFromUnverList( &punvercolGlobal, critUnverCol, objidTable, szFieldName );
		}

	AssertDIRNoLatch( ppib );
	
	return err;
	}


LOCAL ERR ErrFILEIAddSecondaryIndexEntriesForPrimaryKey(
	FUCB			* const pfucbTable,
	IDB				* const pidb,
	DATA&			dataRec,
	const BOOKMARK	* const pbmPrimary,
	FUCB			* const pfucbSort,
	KEY&			keyBuffer,
	LONG			*pcEntriesAdded
	)
	{
	ERR				err;
	BOOL			fNullKey	= fFalse;
	ULONG			itagSequence;

#ifdef DEBUG
	//	latch status shouldn't change during this function
	const BOOL		fLatched	= Pcsr( pfucbTable )->FLatched();
#endif

	*pcEntriesAdded = 0;

	for ( itagSequence = 1; ; itagSequence++ )
		{
		//	latch status shouldn't change during this function
		Assert( ( fLatched && Pcsr( pfucbTable )->FLatched() )
			|| ( !fLatched && !Pcsr( pfucbTable )->FLatched() ) );

		CallR( ErrRECIRetrieveKey(
				pfucbTable,
				pidb,
				dataRec,
				&keyBuffer,
				itagSequence,
				0,
				fFalse,
				prceNil ) );

		//	latch status shouldn't change during this function
		Assert( ( fLatched && Pcsr( pfucbTable )->FLatched() )
			|| ( !fLatched && !Pcsr( pfucbTable )->FLatched() ) );

		CallS( ErrRECValidIndexKeyWarning( err ) );

		const ERR	errRetrieveKey	= err;		//	for debugging

		if ( JET_errSuccess == err )
			{
			//	insert key (below)
			}

		else if ( wrnFLDOutOfKeys == err )
			{
			Assert( itagSequence > 1 );
			break;
			}

		else if ( wrnFLDOutOfTuples == err )
			{
			//	try next itagSequence
			Assert( pidb->FTuples() );
			if ( pidb->FMultivalued() )
				continue;
			else
				break;
			}

		else if ( wrnFLDNotPresentInIndex == err )
			{
			Assert( 1 == itagSequence );
			break;
			}

		else
			{
			//	should not receive any other type of warnings
			//	if this is a tuple index (because there's
			//	only one column in the index)
			Assert( !pidb->FTuples() );

			Assert( wrnFLDNullSeg == err
				|| wrnFLDNullFirstSeg == err
				|| wrnFLDNullKey == err );

			if ( pidb->FNoNullSeg() )
				{
				err = ErrERRCheck( JET_errNullKeyDisallowed );
				return err;
				}

			if ( wrnFLDNullKey == err )
				{
				Assert( 1 == itagSequence );	//	nulls beyond itagSequence 1 would have generated wrnFLDOutOfKeys
				if ( !pidb->FAllowAllNulls() )
					{
					//	do not insert NULL key as indicated
					break;
					}
				fNullKey = fTrue;
				}
			else if ( wrnFLDNullFirstSeg == err )
				{
				if ( !pidb->FAllowFirstNull() )
					{
					//	do not insert keys with NULL first
					//	segment as indicated
					break;
					}
				}
			else
				{
				Assert( wrnFLDNullSeg == err );
				if ( !pidb->FAllowSomeNulls() )
					{
					//	do not insert keys with null
					//	segment as indicated
					break;
					}
				}
			}

		Assert( pbmPrimary->key.prefix.FNull() );
		Assert( keyBuffer.Cb() <= JET_cbSecondaryKeyMost );
		CallR( ErrSORTInsert( pfucbSort, keyBuffer, pbmPrimary->key.suffix ) );
		(*pcEntriesAdded)++;

		if ( pidb->FTuples() )
			{
			//	if we received a warning on the first tuple,
			//	the logic above should ensure we don't
			//	try to create further tuples
			CallS( errRetrieveKey );

			for ( ULONG ichOffset = 1; ichOffset < pidb->ChTuplesToIndexMax(); ichOffset++ )
				{
				//	latch status shouldn't change during this function
				Assert( ( fLatched && Pcsr( pfucbTable )->FLatched() )
					|| ( !fLatched && !Pcsr( pfucbTable )->FLatched() ) );

				CallR( ErrRECIRetrieveKey(
						pfucbTable,
						pidb,
						dataRec,
						&keyBuffer,
						itagSequence,
						ichOffset,
						fFalse,
						prceNil ) );

				//	latch status shouldn't change during this function
				Assert( ( fLatched && Pcsr( pfucbTable )->FLatched() )
					|| ( !fLatched && !Pcsr( pfucbTable )->FLatched() ) );

				//	all other warnings should have been detected
				//	when we retrieved with ichOffset==0
				CallSx( err, wrnFLDOutOfTuples );
				if ( JET_errSuccess != err )
					break;

				Assert( pbmPrimary->key.prefix.FNull() );
				Assert( keyBuffer.Cb() <= JET_cbSecondaryKeyMost );
				CallR( ErrSORTInsert( pfucbSort, keyBuffer, pbmPrimary->key.suffix ) );
				(*pcEntriesAdded)++;
				}
			}

		if ( !pidb->FMultivalued() || fNullKey )
			{
			//	if no multivalues in this index, there's no point going beyond first itagSequence
			//	if key is null, this implies there are no further multivalues
			Assert( 1 == itagSequence );	//	nulls beyond itagSequence 1 would have generated wrnFLDOutOfKeys
			break;
			}
		}
	
	//	latch status shouldn't change during this function
	Assert( ( fLatched && Pcsr( pfucbTable )->FLatched() )
		|| ( !fLatched && !Pcsr( pfucbTable )->FLatched() ) );

	return JET_errSuccess;
	}

INLINE ERR ErrFILEIndexProgress( STATUSINFO	* const pstatus )
	{
	JET_SNPROG	snprog;

	Assert( pstatus->pfnStatus );
	Assert( pstatus->snt == JET_sntProgress );

	pstatus->cunitDone += pstatus->cunitPerProgression;
	
	Assert( pstatus->cunitProjected <= pstatus->cunitTotal );
	if ( pstatus->cunitDone > pstatus->cunitProjected )
		{
		Assert( fGlobalRepair );
		pstatus->cunitPerProgression = 0;
		pstatus->cunitDone = pstatus->cunitProjected;
		}
		
	Assert( pstatus->cunitDone <= pstatus->cunitTotal );

	snprog.cbStruct = sizeof( JET_SNPROG );
	snprog.cunitDone = pstatus->cunitDone;
	snprog.cunitTotal = pstatus->cunitTotal;

	return ( ERR )( *pstatus->pfnStatus )(
		pstatus->sesid,
		pstatus->snp,
		pstatus->snt,
		&snprog );
	}


ERR ErrFILEIndexBatchInit(
	PIB			* const ppib,
	FUCB		** const rgpfucbSort,
	FCB			* const pfcbIndexesToBuild,
	INT			* const pcIndexesToBuild,
	ULONG		* const rgcRecInput,
	FCB			**ppfcbNextBuildIndex,
	const ULONG	cIndexBatchMax )
	{
	ERR			err;
	FCB			*pfcbIndex;
	INT			iindex;

	Assert( pfcbNil != pfcbIndexesToBuild );
	Assert( cIndexBatchMax > 0 );
	Assert( cIndexBatchMax <= cFILEIndexBatchMax );
	
	iindex = 0;
	for ( pfcbIndex = pfcbIndexesToBuild;
		pfcbIndex != pfcbNil;
		pfcbIndex = pfcbIndex->PfcbNextIndex() )
		{
		Assert( pfcbIndex->Pidb() != pidbNil );
		Assert( pfcbIndex->FTypeSecondaryIndex() );
		Assert( pfcbIndex->FInitialized() );
		
		//	open sort
		//
		CallR( ErrSORTOpen( ppib, &rgpfucbSort[iindex], pfcbIndex->Pidb()->FUnique(), fTrue ) );

		rgcRecInput[iindex] = 0;

		iindex++;

		if ( cIndexBatchMax == iindex )
			{
			break;
			}
		}

	*pcIndexesToBuild = iindex;
	Assert( *pcIndexesToBuild > 0 );

	if ( NULL != ppfcbNextBuildIndex )
		{
		if ( cIndexBatchMax == *pcIndexesToBuild )
			*ppfcbNextBuildIndex = pfcbIndex->PfcbNextIndex();
		else
			*ppfcbNextBuildIndex = pfcbNil;
		}
	
	return JET_errSuccess;
	}

ERR ErrFILEIndexBatchAddEntry(
	FUCB			** const rgpfucbSort,
	FUCB			* const pfucbTable,
	const BOOKMARK	* const pbmPrimary,
	DATA&			dataRec,
	FCB				* const pfcbIndexesToBuild,
	const INT		cIndexesToBuild,
	ULONG			* const rgcRecInput,
	KEY&			keyBuffer )
	{
	ERR				err;
	FCB				*pfcbIndex;
	INT				iindex;
	LONG			cSecondaryIndexEntriesAdded;

	Assert( pfcbNil != pfcbIndexesToBuild );
	Assert( cIndexesToBuild > 0 );
	
	Assert( pbmPrimary->key.prefix.FNull() );
	Assert( pbmPrimary->data.FNull() );

	pfcbIndex = pfcbIndexesToBuild;
	for ( iindex = 0; iindex < cIndexesToBuild; iindex++, pfcbIndex = pfcbIndex->PfcbNextIndex() )
		{
		Assert( pfcbNil != pfcbIndex );
		Assert( pidbNil != pfcbIndex->Pidb() );
		CallR( ErrFILEIAddSecondaryIndexEntriesForPrimaryKey(
					pfucbTable,
					pfcbIndex->Pidb(),
					dataRec,
					pbmPrimary,
					rgpfucbSort[iindex],
					keyBuffer,
					&cSecondaryIndexEntriesAdded
					) );

		Assert( cSecondaryIndexEntriesAdded >= 0 );
		rgcRecInput[iindex] += cSecondaryIndexEntriesAdded;
		}

	return JET_errSuccess;
	}


INLINE ERR ErrFILEIAppendToIndex(
	FUCB		* const pfucbSort,
	FUCB		* const pfucbIndex,
	ULONG		*pcRecOutput )
	{
	ERR			err;
	const INT	fDIRFlags = ( fDIRNoVersion | fDIRAppend );

	CallR( ErrDIRInitAppend( pfucbIndex ) );
	do
		{
		(*pcRecOutput)++;
		CallR( ErrDIRAppend(
					pfucbIndex, 
					pfucbSort->kdfCurr.key, 
					pfucbSort->kdfCurr.data,
					fDIRFlags ) );

		Assert( Pcsr( pfucbIndex )->FLatched() );
				
		err = ErrSORTNext( pfucbSort );
		}
	while ( err >= 0 );
			
	if ( JET_errNoCurrentRecord == err )
		err = ErrDIRTermAppend( pfucbIndex );

	return err;
	}


// Don't make this INLINE, since it's just error-handling code.
LOCAL VOID FILEIReportIndexCorrupt( FUCB * const pfucbIndex, CPRINTF * const pcprintf )
	{
		
	FCB			*pfcbIndex = pfucbIndex->u.pfcb;
	Assert( pfcbNil != pfcbIndex );
	Assert( pfcbIndex->FTypeSecondaryIndex() );
	Assert( pfcbIndex->Pidb() != pidbNil );
	
	FCB			*pfcbTable = pfcbIndex->PfcbTable();
	Assert( pfcbNil != pfcbTable );
	Assert( pfcbTable->FTypeTable() );
	Assert( pfcbTable->Ptdb() != ptdbNil );

	// Strictly speaking, EnterDML() is not needed because this
	// function only gets executed by the consistency-checker,
	// which is single-threaded.  However, make the call anyway
	// to avoid potential bugs in the future if this function
	// ever gets used in multi-threaded situations.
	pfcbTable->EnterDML();
	(*pcprintf)(
		"Table \"%s\", Index \"%s\":  ",
		pfcbTable->Ptdb()->SzTableName(),
		pfcbTable->Ptdb()->SzIndexName( pfcbIndex->Pidb()->ItagIndexName(), pfcbIndex->FDerivedIndex() ) );
	pfcbTable->LeaveDML();
	}
	

INLINE ERR ErrFILEICheckIndex(
	FUCB	* const pfucbSort,
	FUCB	* const pfucbIndex,
	ULONG	*pcRecSeen,
	BOOL	*pfCorruptedIndex,
	CPRINTF	* const pcprintf )
	{
	ERR		err;
	DIB 	dib;
	dib.dirflag = fDIRNull;
	dib.pos		= posFirst;

	Assert( NULL != pfCorruptedIndex );

	FUCBSetPrereadForward( pfucbIndex, cpgPrereadSequential );

	Call( ErrBTDown( pfucbIndex, &dib, latchReadTouch ) );

	do
		{
		(*pcRecSeen)++;

		Assert( Pcsr( pfucbIndex )->FLatched() );

		INT cmp = CmpKeyData( pfucbIndex->kdfCurr, pfucbSort->kdfCurr );
		if( 0 != cmp )
			{
			FILEIReportIndexCorrupt( pfucbIndex, pcprintf );
			(*pcprintf)(	"index entry %d [%d:%d] (objid %d) inconsistent\r\n",
							*pcRecSeen,
							Pcsr( pfucbIndex )->Pgno(),
							Pcsr( pfucbIndex )->ILine(),
							Pcsr( pfucbIndex )->Cpage().ObjidFDP() );

			BYTE rgbBuf[JET_cbKeyMost+1];
			CHAR rgchBuf[1024];

			INT ib;
			INT ibMax;
			const BYTE * pb;
			CHAR * pchBuf;
			
			pfucbIndex->kdfCurr.key.CopyIntoBuffer( rgbBuf, sizeof( rgbBuf ) );
			pb = rgbBuf;
			ibMax = pfucbIndex->kdfCurr.key.Cb();
			pchBuf = rgchBuf;
			for( ib = 0; ib < ibMax; ++ib )
				{
				pchBuf += sprintf( pchBuf, " %2.2x", pb[ib] );
				}
			(*pcprintf)( "\tkey in database (%d bytes):%s\r\n", ibMax, rgchBuf );
			
			pb = (BYTE*)pfucbIndex->kdfCurr.data.Pv();
			ibMax = pfucbIndex->kdfCurr.data.Cb();
			pchBuf = rgchBuf;
			for( ib = 0; ib < ibMax; ++ib )
				{
				pchBuf += sprintf( pchBuf, " %2.2x", pb[ib] );
				}
			(*pcprintf)( "\tdata in database (%d bytes):%s\r\n", ibMax, rgchBuf );

			pfucbSort->kdfCurr.key.CopyIntoBuffer( rgbBuf, sizeof( rgbBuf ) );
			pb = rgbBuf;
			ibMax = pfucbSort->kdfCurr.key.Cb();
			pchBuf = rgchBuf;
			for( ib = 0; ib < ibMax; ++ib )
				{
				pchBuf += sprintf( pchBuf, " %2.2x", pb[ib] );
				}
			(*pcprintf)( "\tcalculated key (%d bytes):%s\r\n", ibMax, rgchBuf );
			
			pb = (BYTE*)pfucbSort->kdfCurr.data.Pv();
			ibMax = pfucbSort->kdfCurr.data.Cb();
			pchBuf = rgchBuf;
			for( ib = 0; ib < ibMax; ++ib )
				{
				pchBuf += sprintf( pchBuf, " %2.2x", pb[ib] );
				}
			(*pcprintf)( "\tcalculated data (%d bytes):%s\r\n", ibMax, rgchBuf );
						
			*pfCorruptedIndex = fTrue;
			break;
			}
			
		err = ErrBTNext( pfucbIndex, fDIRNull );
		if( err < 0 )
			{
			if ( JET_errNoCurrentRecord == err 
				&& JET_errNoCurrentRecord != ErrSORTNext( pfucbSort ) )
				{
				FILEIReportIndexCorrupt( pfucbIndex, pcprintf );
				(*pcprintf)( "real index has fewer (%d) srecords\r\n", *pcRecSeen );
				*pfCorruptedIndex = fTrue;
				break;
				}
			}
		else
			{
			err = ErrSORTNext( pfucbSort );
			if( JET_errNoCurrentRecord == err )
				{
				FILEIReportIndexCorrupt( pfucbIndex, pcprintf );
				(*pcprintf)( "generated index has fewer (%d) srecords\r\n", *pcRecSeen );
				*pfCorruptedIndex = fTrue;
				break;
				}
			}
		}
	while ( err >= 0 );

	err = ( JET_errNoCurrentRecord == err ? JET_errSuccess : err );

HandleError:
	FUCBResetPreread( pfucbIndex );
	BTUp( pfucbIndex );
	return err;
	}

	
ERR ErrFILEIndexBatchTerm(
	PIB			* const ppib,
	FUCB		** const rgpfucbSort,
	FCB			* const pfcbIndexesToBuild,
	const INT	cIndexesToBuild,
	ULONG		* const rgcRecInput,
	STATUSINFO	* const pstatus,
	BOOL		*pfCorruptionEncountered,
	CPRINTF		* const pcprintf )
	{
	ERR			err = JET_errSuccess;
	FUCB		*pfucbIndex = pfucbNil;
	FCB			*pfcbIndex = pfcbIndexesToBuild;
	INT			iindex;

	Assert( pfcbNil != pfcbIndexesToBuild );
	Assert( cIndexesToBuild > 0 );
	
	for ( iindex = 0; iindex < cIndexesToBuild; iindex++, pfcbIndex = pfcbIndex->PfcbNextIndex() )
		{
		const BOOL	fUnique			= pfcbIndex->Pidb()->FUnique();
		ULONG		cRecOutput		= 0;
		BOOL		fEntriesExist	= fTrue;
		BOOL		fCorruptedIndex	= fFalse;
		
		Assert( pfcbNil != pfcbIndex );
		Assert( pfcbIndex->FTypeSecondaryIndex() );
		Assert( pidbNil != pfcbIndex->Pidb() );
		
#ifdef SHOW_INDEX_PERF
		TICK		tickStart;
		tickStart	= TickOSTimeCurrent();
#endif

		Call( ErrSORTEndInsert( rgpfucbSort[iindex] ) );

#ifdef SHOW_INDEX_PERF
		printf( "    Sorted keys for index %d in %d msecs.\n", iindex+1, TickOSTimeCurrent() - tickStart );
#endif

		//	transfer index entries to actual index
		//	insert first one in normal method!
		//
		err = ErrSORTNext( rgpfucbSort[iindex] );
		if ( err < 0 )
			{
			if ( JET_errNoCurrentRecord != err )
				goto HandleError;

			err = JET_errSuccess;

			Assert( rgcRecInput[iindex] == 0 );
			fEntriesExist = fFalse;
			}

		if ( fEntriesExist )
			{

			//	open cursor on index
			//
			Assert( pfucbNil == pfucbIndex );
			Call( ErrDIROpen( ppib, pfcbIndex, &pfucbIndex ) );
			FUCBSetIndex( pfucbIndex );
			FUCBSetSecondary( pfucbIndex );
			DIRGotoRoot( pfucbIndex );

			if ( NULL != pfCorruptionEncountered )
				{
				Assert( NULL != pcprintf );
				Call( ErrFILEICheckIndex(
							rgpfucbSort[iindex],
							pfucbIndex,
							&cRecOutput,
							&fCorruptedIndex,
							pcprintf ) );
				if ( fCorruptedIndex )
					*pfCorruptionEncountered = fTrue;
				}
			else
				{
#ifdef SHOW_INDEX_PERF
				tickStart	= TickOSTimeCurrent();
#endif

				Call( ErrFILEIAppendToIndex(
							rgpfucbSort[iindex],
							pfucbIndex,
							&cRecOutput ) );

#ifdef SHOW_INDEX_PERF
				printf( "      Appended %d keys for index %d in %d msecs.\n", cRecOutput, iindex+1, TickOSTimeCurrent() - tickStart );
#endif
				}
			
			DIRClose( pfucbIndex );
			pfucbIndex = pfucbNil;
			}
			
		SORTClose( rgpfucbSort[iindex] );
		rgpfucbSort[iindex] = pfucbNil;

		Assert( cRecOutput <= rgcRecInput[iindex] );
		if ( cRecOutput != rgcRecInput[iindex] )
			{
			if ( cRecOutput < rgcRecInput[iindex] && !fUnique )
				{
				//	duplicates over multi-valued columns must have been removed
				}
				
			else if ( NULL != pfCorruptionEncountered )
				{
				*pfCorruptionEncountered = fTrue;
				
				// Only report this error if we haven't
				// encountered corruption on this index already.
				if ( !fCorruptedIndex )
					{
					if ( cRecOutput > rgcRecInput[iindex] )
						{
						(*pcprintf)( "Too many index keys generated\n" );
						}
					else
						{
						Assert( fUnique );
						(*pcprintf)( "%d duplicate key(s) on unique index\n", rgcRecInput[iindex] - cRecOutput );
						}
					}
				}
				
			else if ( cRecOutput > rgcRecInput[iindex] )
				{
				err = ErrERRCheck( JET_errIndexBuildCorrupted );
				goto HandleError;
				}
				
			else
				{
				Assert( cRecOutput < rgcRecInput[iindex] );
				Assert( fUnique );
				
				//	If we got dupes and the index was NOT unique, it must have been
				//	dupes over multi-value columns, in which case the dupes
				//	get properly eliminated.
				err = ErrERRCheck( JET_errKeyDuplicate );
				goto HandleError;
				}
			}

		if ( pstatus )
			{
			Call( ErrFILEIndexProgress( pstatus ) );
			}
		}

HandleError:
	if ( pfucbNil != pfucbIndex )
		{
		Assert( err < 0 );
		DIRClose( pfucbIndex );
		}

	return err;
	}


ERR ErrFILEBuildAllIndexes(
	PIB			* const ppib,
	FUCB		* const pfucbTable,
	FCB			* const pfcbIndexes,
	STATUSINFO	* const pstatus,
	const ULONG	cIndexBatchMax,
	const BOOL	fCheckOnly,
	CPRINTF		* const pcprintf )
	{
	ERR	 	 	err;
	DIB			dib;
	FUCB 	  	*rgpfucbSort[cFILEIndexBatchMax];
	FCB			*pfcbIndexesToBuild;
	FCB			*pfcbNextBuildIndex;
	KEY			keyBuffer;
	BYTE  	 	rgbKey[JET_cbSecondaryKeyMost];
	ULONG		rgcRecInput[cFILEIndexBatchMax];
	INT			cIndexesToBuild;
	INT			iindex;
	BOOL		fTransactionStarted		= fFalse;
	BOOL		fCorruptionEncountered = fFalse;

	if ( 0 == ppib->level )
		{
		//	only reason we need a transaction is to ensure read-consistency of primary data
		CallR( ErrDIRBeginTransaction( ppib, NO_GRBIT ) );
		fTransactionStarted = fTrue;
		}

	Assert( cIndexBatchMax > 0 );
	Assert( cIndexBatchMax <= cFILEIndexBatchMax );
	for ( iindex = 0; iindex < cIndexBatchMax; iindex++ )
		rgpfucbSort[iindex] = pfucbNil;

	keyBuffer.prefix.Nullify();
	keyBuffer.suffix.SetCb( sizeof( rgbKey ) );
	keyBuffer.suffix.SetPv( rgbKey );

	dib.pos 	= posFirst;
	dib.pbm 	= NULL;
	dib.dirflag = fDIRNull;

	FUCBSetPrereadForward( pfucbTable, cpgPrereadSequential );
	err = ErrBTDown( pfucbTable, &dib, latchReadTouch );
	Assert( JET_errNoCurrentRecord != err );
	if( JET_errRecordNotFound == err )
		{
		//  the tree is empty
		err = JET_errSuccess;
		goto HandleError;
		}

	// Cursor building index should only be navigating primary index.
	Assert( pfucbNil == pfucbTable->pfucbCurIndex );

	// Don't waste time by calling this function when unneeded.
	Assert( pfcbNil != pfcbIndexes );

	pfcbNextBuildIndex = pfcbIndexes;

NextBuild:
#ifdef SHOW_INDEX_PERF
	ULONG	cRecs, cPages;
	TICK	tickStart;
	PGNO	pgnoLast;
	cRecs = 0;
	cPages	= 1;
	pgnoLast = Pcsr( pfucbTable )->Pgno();
	tickStart	= TickOSTimeCurrent();
#endif	

	//	HACK: force locLogical to OnCurBM to silence
	//	RECIRetrieveKey(), which will make DIR-level
	//	calls using this cursor
	pfucbTable->locLogical = locOnCurBM;

	pfcbIndexesToBuild = pfcbNextBuildIndex;
	pfcbNextBuildIndex = pfcbNil;

	err = ErrFILEIndexBatchInit(
				ppib,
				rgpfucbSort,
				pfcbIndexesToBuild,
				&cIndexesToBuild,
				rgcRecInput,
				&pfcbNextBuildIndex,
				cIndexBatchMax );

	// This is either a full batch or the last batch of indexes to build.
	Assert( err < 0
		|| cIndexBatchMax == cIndexesToBuild
		|| pfcbNil == pfcbNextBuildIndex );
	
#ifdef SHOW_INDEX_PERF
	printf( "    Beginning scan of records to rebuild %d indexes.\n", cIndexBatchMax );
#endif	

	//	build up new index in a sort file
	//
	do
		{
		Call( err );

#ifdef SHOW_INDEX_PERF
		cRecs++;

		if ( Pcsr( pfucbTable )->Pgno() != pgnoLast )
			{
			cPages++;
			pgnoLast = Pcsr( pfucbTable )->Pgno();
			}
#endif			

		//	get bookmark of primary index node
		//
		Assert( Pcsr( pfucbTable )->FLatched() );
		Assert( locOnCurBM == pfucbTable->locLogical );
		Call( ErrBTISaveBookmark( pfucbTable ) );

		Call( ErrFILEIndexBatchAddEntry(
					rgpfucbSort,
					pfucbTable,
					&pfucbTable->bmCurr,
					pfucbTable->kdfCurr.data,
					pfcbIndexesToBuild,
					cIndexesToBuild,
					rgcRecInput,
					keyBuffer ) );

		Assert( Pcsr( pfucbTable )->FLatched() );
		err = ErrBTNext( pfucbTable, fDIRNull );
		}
	while ( JET_errNoCurrentRecord != err );
	Assert( JET_errNoCurrentRecord == err );

#ifdef SHOW_INDEX_PERF
	printf( "    Scanned %d records (%d pages) and formulated all keys in %d msecs.\n",
			cRecs,
			cPages,
			TickOSTimeCurrent() - tickStart );
#endif			

	FUCBResetPreread( pfucbTable );
	BTUp( pfucbTable );

	Call( ErrFILEIndexBatchTerm(
				ppib,
				rgpfucbSort,
				pfcbIndexesToBuild,
				cIndexesToBuild,
				rgcRecInput,
				pstatus,
				fCheckOnly ? &fCorruptionEncountered : NULL,
				pcprintf ) );

	if ( pfcbNil != pfcbNextBuildIndex )
		{
		//	reseek to beginning of data (must succeed since it succeeded the first time)
		FUCBSetPrereadForward( pfucbTable, cpgPrereadSequential );
		err = ErrBTDown( pfucbTable, &dib, latchReadTouch );
		CallS( err );
		Call( err );

		goto NextBuild;
		}

	err = ( fCorruptionEncountered ?
				ErrERRCheck( JET_errDatabaseCorrupted ) :
				JET_errSuccess );
	
HandleError:
	Assert ( err != errDIRNoShortCircuit );
	if ( err < 0 )
		{
		for ( iindex = 0; iindex < cIndexBatchMax; iindex++ )
			{
			if ( pfucbNil != rgpfucbSort[iindex] )
				{
				SORTClose( rgpfucbSort[iindex] );
				rgpfucbSort[iindex] = pfucbNil;
				}
			}

		FUCBResetPreread( pfucbTable );
		BTUp( pfucbTable );
		}

	if ( fTransactionStarted )
		{
		//	read-only transaction, so should never fail
		CallS( ErrDIRCommitTransaction( ppib, NO_GRBIT ) );
		}

	return err;
	}


//+API
// BuildIndex
// ========================================================================
// ERR BuildIndex( PIB *ppib, FUCB *pfucb, CHAR *szIndex )
//
// Builds a new index for a file from scratch;  szIndex gives the
// name of an index definition.
//
// PARAMETERS	ppib						PIB of user
//		   		pfucb						Exclusively opened FUCB on file
//		   		szIndex 					name of index to build
//
// RETURNS		Error code from DIRMAN or SORT or
//					JET_errSuccess	  		Everything worked OK.
// COMMENTS
//			A transaction is wrapped around this function at the callee.
//
// SEE ALSO		ErrIsamCreateIndex
//-
LOCAL ERR ErrFILEIBuildIndex( PIB *ppib, FUCB *pfucbTable, FUCB *pfucbIndex )
	{
	ERR	 	 	err;
	DIB			dib;
	INT			fDIRFlags;
	FUCB 	  	*pfucbSort = pfucbNil;
	IDB	 	 	*pidb;
	KEY			keyBuffer;
	BYTE  	 	rgbKey[JET_cbSecondaryKeyMost];
	INT			fUnique;
	LONG  	 	cRecInput = 0;
	LONG  	 	cRecOutput;

	// Cursor building index should only be navigating primary index.
	Assert( pfucbNil == pfucbTable->pfucbCurIndex );

	// Work buffer is not used when building index.
	Assert( NULL == pfucbIndex->pvWorkBuf );

	Assert( FFUCBSecondary( pfucbIndex ) );
	Assert( pfcbNil != pfucbIndex->u.pfcb );
	Assert( pfucbIndex->u.pfcb->Pidb() != pidbNil );
	Assert( pfucbIndex->u.pfcb->FTypeSecondaryIndex() );
	Assert( pfucbIndex->u.pfcb->FInitialized() );

	// Index has not yet been linked into table's index list.
	Assert( pfucbIndex->u.pfcb->PfcbTable() == pfcbNil );
	Assert( pfucbIndex->u.pfcb->PfcbNextIndex() == pfcbNil );
		
	pidb = pfucbIndex->u.pfcb->Pidb();
	fUnique = pidb->FUnique();

	dib.pos 	= posFirst;
	dib.pbm 	= NULL;
	dib.dirflag = fDIRNull;

	FUCBSetPrereadForward( pfucbTable, cpgPrereadSequential );
	err = ErrBTDown( pfucbTable, &dib, latchReadTouch );
	Assert( JET_errNoCurrentRecord != err );
	if( JET_errRecordNotFound == err )
		{
		//  the tree is empty
		err = JET_errSuccess;
		goto HandleError;
		}

	Call( err );

	//	HACK: force locLogical to OnCurBM to silence
	//	RECIRetrieveKey(), which will make DIR-level
	//	calls using this cursor
	pfucbTable->locLogical = locOnCurBM;

	//	directory manager flags
	//
	fDIRFlags = ( fDIRNoVersion | fDIRAppend );

	keyBuffer.prefix.Nullify();
	keyBuffer.suffix.SetCb( sizeof( rgbKey ) );
	keyBuffer.suffix.SetPv( rgbKey );

	//	open sort
	//
	err = ErrSORTOpen( ppib, &pfucbSort, fUnique, fTrue );

#ifdef SHOW_INDEX_PERF
	ULONG	cRecs, cPages;
	TICK	tickStart;
	PGNO	pgnoLast;
	cRecs = 0;
	cPages	= 1;
	pgnoLast = Pcsr( pfucbTable )->Pgno();
	tickStart	= TickOSTimeCurrent();
#endif	

	//	build up new index in a sort file
	//
	do
		{
		Call( err );

#ifdef SHOW_INDEX_PERF
		cRecs++;

		if ( Pcsr( pfucbTable )->Pgno() != pgnoLast )
			{
			cPages++;
			pgnoLast = Pcsr( pfucbTable )->Pgno();
			}
#endif			

		//	get bookmark of primary index node
		//
		Assert( Pcsr( pfucbTable )->FLatched() );
		Assert( locOnCurBM == pfucbTable->locLogical );
		Call( ErrBTISaveBookmark( pfucbTable ) );

		LONG	cSecondaryIndexEntriesAdded;
		Call( ErrFILEIAddSecondaryIndexEntriesForPrimaryKey(
					pfucbTable,
					pidb,
					pfucbTable->kdfCurr.data,
					&pfucbTable->bmCurr,
					pfucbSort,
					keyBuffer,
					&cSecondaryIndexEntriesAdded
					) );

		cRecInput += cSecondaryIndexEntriesAdded;

		Assert( Pcsr( pfucbTable )->FLatched() );
		err = ErrBTNext( pfucbTable, fDIRNull );
		}
	while ( JET_errNoCurrentRecord != err );
	Assert( JET_errNoCurrentRecord == err );

#ifdef SHOW_INDEX_PERF
	printf( "    Scanned %d records (%d pages) and formed %d keys in %d msecs.\n",
			cRecs,
			cPages,
			cRecInput,
			TickOSTimeCurrent() - tickStart );
#endif			

	FUCBResetPreread( pfucbTable );
	BTUp( pfucbTable );

#ifdef SHOW_INDEX_PERF
	tickStart	= TickOSTimeCurrent();
#endif

	Call( ErrSORTEndInsert( pfucbSort ) );

#ifdef SHOW_INDEX_PERF
	printf( "    Sorted keys in %d msecs.\n", TickOSTimeCurrent() - tickStart );
#endif

	//	transfer index entries to actual index
	//	insert first one in normal method!
	//
	err = ErrSORTNext( pfucbSort );
	if ( err < 0 )
		{
		if ( JET_errNoCurrentRecord == err )
			{
			SORTClose( pfucbSort );
			err = JET_errSuccess;
			}
		goto HandleError;
		}
	cRecOutput = 1;

	//	move to FDP root
	//
	DIRGotoRoot( pfucbIndex );
	Call( ErrDIRInitAppend( pfucbIndex ) );
	
#ifdef SHOW_INDEX_PERF
	tickStart = TickOSTimeCurrent();
#endif	

	Call( ErrDIRAppend( pfucbIndex, 
						pfucbSort->kdfCurr.key, 
						pfucbSort->kdfCurr.data, 
						fDIRFlags ) );
	Assert( Pcsr( pfucbIndex )->FLatched() );
	
	//	from now on, try short circuit first
	//
	forever
		{
		err = ErrSORTNext( pfucbSort );
		if ( err == JET_errNoCurrentRecord )
			break;
		if ( err < 0 )
			goto HandleError;
		cRecOutput++;
		Call( ErrDIRAppend( pfucbIndex, 
							pfucbSort->kdfCurr.key, 
							pfucbSort->kdfCurr.data, 
							fDIRFlags ) );

		Assert( Pcsr( pfucbIndex )->FLatched() );
		}

#ifdef SHOW_INDEX_PERF
	printf( "    Appended %d records to secondary index in %d msecs.\n",
			cRecOutput,
			TickOSTimeCurrent() - tickStart );
#endif			

	Call( ErrDIRTermAppend( pfucbIndex ) );

	//	If we got dupes and the index was NOT unique, it must have been
	//	dupes over multi-value columns, in which case the dupes
	//	get properly eliminated.
	Assert( cRecOutput <= cRecInput );
	if ( cRecOutput != cRecInput )
		{
		if ( cRecOutput < cRecInput )
			{
			if ( fUnique )
				{
				err = ErrERRCheck( JET_errKeyDuplicate );
				goto HandleError;
				}
			else
				{
				//	duplicates over multi-valued columns must have been removed
				}
			}
		else
			{
			err = ErrERRCheck( JET_errIndexBuildCorrupted );
			goto HandleError;
			}
		}

	SORTClose( pfucbSort );
	err = JET_errSuccess;

HandleError:
	Assert ( err != errDIRNoShortCircuit );
	if ( err < 0 )
		{
		if ( pfucbSort != pfucbNil )
			{
			SORTClose( pfucbSort );
			}

		FUCBResetPreread( pfucbTable );
		BTUp( pfucbTable );
		}

	// Work buffer is not used when building index.
	Assert( NULL == pfucbIndex->pvWorkBuf );

	return err;
	}

LOCAL ERR ErrFILEIProcessRCE( PIB *ppib, FUCB *pfucbTable, FUCB *pfucbIndex, RCE *prce )
	{
	ERR			err;
	FCB			*pfcbTable = pfucbTable->u.pfcb;
	FCB			*pfcbIndex = pfucbIndex->u.pfcb;
	const OPER	oper = prce->Oper();
	BOOKMARK	bookmark;
	BOOL		fUncommittedRCE = fFalse;
	PIB			*ppibProxy = ppibNil;

	Assert( pfcbTable != pfcbNil );
	Assert( pfcbIndex != pfcbNil );

	Assert( pfcbTable->CritRCEList().FOwner() );

	Assert( prceNil != prce );
	if ( prce->TrxCommitted() == trxMax )
		{
		Assert( prce->Pfucb() != pfucbNil );
		Assert( !prce->FRolledBack() );
		
		ppibProxy = prce->Pfucb()->ppib;
		Assert( ppibNil != ppibProxy );
		Assert( ppibProxy != ppib );

		Assert( crefVERCreateIndexLock >= 0 );
		AtomicIncrement( const_cast<LONG *>( &crefVERCreateIndexLock ) );
		Assert( crefVERCreateIndexLock >= 0 );

		fUncommittedRCE = fTrue;
		}
	
	prce->GetBookmark( &bookmark );
	Assert( bookmark.key.prefix.FNull() );
	Assert( bookmark.key.Cb() > 0 );

	pfcbTable->CritRCEList().Leave();
	
	// Find node and obtain read latch.
	err = ErrBTGotoBookmark( pfucbTable, bookmark, latchReadNoTouch );
	if ( err < 0 )
		{
		Assert( JET_errRecordDeleted != err );
		AssertDIRNoLatch( pfucbTable->ppib );

		if ( fUncommittedRCE )
			{
			Assert( crefVERCreateIndexLock >= 0 );
			AtomicDecrement( const_cast<LONG *>( &crefVERCreateIndexLock ) );
			Assert( crefVERCreateIndexLock >= 0 );
			}

		// Must re-enter CritRCEList() before leaving, to get to the
		// next RCE on this FCB.
		pfcbTable->CritRCEList().Enter();
		return err;
		}
		
	Assert( Pcsr( pfucbTable )->FLatched() );	// Read-latch obtained.

	// Must extract proper data-record image with which to update secondary index.
	// In order to obtain proper image, must scan future RCE's on this node.
	prce->CritChain().Enter();
	
	RCE	*prceNextReplace;
	for ( prceNextReplace = prce->PrceNextOfNode();
		prceNextReplace != prceNil && prceNextReplace->Oper() != operReplace;
		prceNextReplace = prceNextReplace->PrceNextOfNode() )
		{
		// Shouldn't be NULL, since our transaction will block cleanup.
		Assert( !prceNextReplace->FOperNull() );
		}
		
	if ( prceNextReplace != prceNil )
		{
		Assert( prceNextReplace->Oper() == operReplace );
		pfucbTable->dataWorkBuf.SetPv(
			const_cast<BYTE *>( prceNextReplace->PbData() ) + cbReplaceRCEOverhead );
		pfucbTable->dataWorkBuf.SetCb(
			prceNextReplace->CbData() - cbReplaceRCEOverhead );
		prce->CritChain().Leave();
		}
	else
		{
		prce->CritChain().Leave();
		
		// Set dataWorkBuf.pv to point to pvWorkBuf, in case it was reset.
		Assert ( NULL != pfucbTable->pvWorkBuf );
		pfucbTable->dataWorkBuf.SetPv( (BYTE*)pfucbTable->pvWorkBuf );
		
		// Go to database for record.
		pfucbTable->kdfCurr.data.CopyInto( pfucbTable->dataWorkBuf );
		}
		
	// Table's cursor now contains (in dataWorkBuf) the data record used to generate
	// the secondary index key to be inserted (for operInsert or operReplace)
	// or deleted (for operDeleted).
	// Read-latch may now be freed.
	BTUp( pfucbTable );

	// RCE's can only be removed by two routines: RCEClean and rollback.  Since
	// we're in a transaction and this RCE is active, the RCE is blocked from
	// being cleaned up.  This leaves just rollback, which we handle using
	// the crefVERCreateIndexLock global variable.
	// If this count is non-zero, anyone trying to rollback an update (ie. insert,
	// delete, or replace) on any primary index will fail and retry.
	if ( fUncommittedRCE )
		{

		// This ensures that the RCE is not committed from underneath us.
		// Note that even if the RCE has since been committed and the
		// PIB freed, we are still able to use the critTrx member of
		// the PIB because we never actually release the PIB memory
		// (we just put it on the free PIB list).
		// UNDONE: Optimise by blocking only Commit, not all other CreateIndex
		// threads working on an RCE belonging to this session as well.
		ppibProxy->critTrx.Enter();

		// Decrement PreventRollback count.  The RCEChain critical section now
		// protects the RCE from being deleted.
		Assert( crefVERCreateIndexLock >= 0 );
		AtomicDecrement( const_cast<LONG *>( &crefVERCreateIndexLock ) );
		Assert( crefVERCreateIndexLock >= 0 );

		// See if the RCE committed or rolled back in the time when we lost
		// the FCB critical section and when we gained the PIB critical section.
		if ( prce->TrxCommitted() == trxMax )
			{
			if ( prce->FRolledBack() )
				{
				err = JET_errSuccess;	// RCE rolled back, so nothing to do.
				goto HandleError;
				}
			}
		else
			{
			Assert( TrxCmp( prce->TrxCommitted(), ppib->trxBegin0 ) > 0 );

			ppibProxy->critTrx.Leave();
			fUncommittedRCE = fFalse;
			}
		}
	
	Assert( ::FOperAffectsSecondaryIndex( oper ) );
	Assert( prce->TrxCommitted() != trxMax || !prce->FRolledBack() );

	if ( oper == operInsert )
		{
		Call( ErrRECIAddToIndex( pfucbTable, pfucbIndex, &bookmark, fDIRNull, prce ) );
		}
	else if ( oper == operFlagDelete )
		{
		Call( ErrRECIDeleteFromIndex( pfucbTable, pfucbIndex, &bookmark, prce ) );
		}
	else
		{
		Assert( oper == operReplace );
		Call( ErrRECIReplaceInIndex( pfucbTable, pfucbIndex, &bookmark, prce ) );
		}
	
	// Must version operations committed after the indexer began his
	// transaction is to ensure that the indexer himself will have a 
	// consistent view of the secondary index.  Additionally, we must
	// provide an RCE for write-conflict detection.

HandleError:	
	AssertDIRNoLatch( pfucbTable->ppib );

	pfcbTable->CritRCEList().Enter();

	if ( fUncommittedRCE )
		{
		Assert( ppibNil != ppibProxy );
		ppibProxy->critTrx.Leave();
		}
	
	return err;
	}


// This routine updates the index being created with the versioned up
LOCAL ERR ErrFILEIUpdateIndex( PIB *ppib, FUCB *pfucbTable, FUCB *pfucbIndex )
	{
	ERR			err			= JET_errSuccess;
	FCB			*pfcbTable	= pfucbTable->u.pfcb;
	FCB			*pfcbIndex	= pfucbIndex->u.pfcb;
	const TRX	trxSession	= ppib->trxBegin0;

	Assert( trxSession != trxMax );
	
	Assert( pfcbTable->FInitialized() );
	Assert( pfcbTable->FPrimaryIndex() );
	Assert( pfcbTable->FTypeTable() );
	Assert( pfcbTable->FInitialized() );
	
	Assert( FFUCBSecondary( pfucbIndex ) );
	Assert( pfcbIndex->FInitialized() );
	Assert( pfcbIndex->FTypeSecondaryIndex() );
	Assert( pfcbIndex->PfcbTable() == pfcbNil );	// Index FCB should not be linked in yet.
	Assert( pfcbIndex->Pidb() != pidbNil );

	//	allocate working buffer
	//
	Assert( NULL == pfucbTable->pvWorkBuf );
	RECIAllocCopyBuffer( pfucbTable );

	// Set dirty cursor isolation model to allow unversioned
	// access to secondary index by proxy.
	Assert( !FPIBDirty( pfucbIndex->ppib ) );
	PIBSetCIMDirty( pfucbIndex->ppib );


	BOOL	fUpdatesQuiesced	= fFalse;
	RCE		*prceLastProcessed	= prceNil;
	RCE		*prce;

	pfcbTable->CritRCEList().Enter();
	prce = pfcbTable->PrceOldest();

	forever
		{
		//	scan RCE's for next one to process
		while ( prceNil != prce
				&& ( !prce->FOperAffectsSecondaryIndex()
					|| prce->FRolledBack()
					|| prce->FDoesNotWriteConflict()
					|| !prce->FActiveNotByMe( ppib, trxSession ) ) )
			{
			Assert( prce->FActiveNotByMe( ppib, trxSession ) || prce->TrxCommitted() != trxSession );
			prce = prce->PrceNextOfFCB();
			}

		if ( prceNil == prce )
			{
			if ( fUpdatesQuiesced )
				break;
						
			// Reached end of RCE list for this FCB.  Quiesce further updates
			// (letting current updates complete), then re-read RCE list in
			// case more RCE's entered while we were quiescing.  The RCE we
			// last processed is guaranteed to remain because we block rollbacks.
			Assert( prceNil == prceLastProcessed || !prceLastProcessed->FOperNull() );
			Assert( crefVERCreateIndexLock >= 0 );
			AtomicIncrement( const_cast<LONG *>( &crefVERCreateIndexLock ) );
			Assert( crefVERCreateIndexLock >= 0 );

			pfcbTable->CritRCEList().Leave();
			pfcbTable->SetIndexing();
			pfcbTable->CritRCEList().Enter();

			Assert( crefVERCreateIndexLock >= 0 );
			AtomicDecrement( const_cast<LONG *>( &crefVERCreateIndexLock ) );
			Assert( crefVERCreateIndexLock >= 0 );

			fUpdatesQuiesced = fTrue;
			
			Assert( prceNil == prceLastProcessed || !prceLastProcessed->FOperNull() );
			prce = ( prceNil == prceLastProcessed ? pfcbTable->PrceOldest() : prceLastProcessed->PrceNextOfFCB() );
			}

		else
			{
			Assert( prce->FOperAffectsSecondaryIndex() );
			Assert( !prce->FRolledBack() );
			Assert( prce->FActiveNotByMe( ppib, trxSession ) );
			Call( ErrFILEIProcessRCE( ppib, pfucbTable, pfucbIndex, prce ) );

			prceLastProcessed = prce;
			prce = prce->PrceNextOfFCB();
			}
		}

	pfcbTable->CritRCEList().Leave();

	//	link new FCB and update index mask
	Assert( fUpdatesQuiesced );

	pfcbTable->EnterDDL();
	pfcbTable->LinkSecondaryIndex( pfcbIndex );
	FILESetAllIndexMask( pfcbTable );
	pfcbTable->LeaveDDL();

	//	since we have a cursor open on pfcbTable, the FCB
	//		cannot be in the avail list; thus, we can directly
	//		set the above-threshold flag 

	if ( pfcbIndex >= PfcbFCBPreferredThreshold( PinstFromPpib( ppib ) ) )
		{
		pfcbTable->Lock();
		pfcbTable->SetAboveThreshold();
		pfcbTable->Unlock();
		}

	pfcbTable->ResetIndexing();
	goto ResetCursor;

HandleError:
	pfcbTable->CritRCEList().Leave();
	if ( fUpdatesQuiesced )
		{
		pfcbTable->ResetIndexing();
		}

ResetCursor:
	Assert( FPIBDirty( pfucbIndex->ppib ) );
	PIBResetCIMDirty( pfucbIndex->ppib );
	
	Assert ( NULL != pfucbTable->pvWorkBuf );
	RECIFreeCopyBuffer( pfucbTable );
	
	return err;
	}


LOCAL ERR ErrFILEIPrepareOneIndex(
	PIB				* const ppib,
	FUCB			* const pfucbTable,
	FUCB			** ppfucbIdx,
	JET_INDEXCREATE	* const pidxcreate,
	const CHAR		* const szIndexName,
	const CHAR		* rgszColumns[],
	const BYTE		* rgfbDescending,
	IDB				* const pidb,
	const ULONG		ulDensity )
	{
	ERR				err;
	const IFMP		ifmp					= pfucbTable->ifmp;
	FCB				* const pfcb			= pfucbTable->u.pfcb;
	FCB			 	* pfcbIdx 				= pfcbNil;
	PGNO			pgnoIndexFDP;
	OBJID			objidIndex;
	FIELD			* pfield;
	COLUMNID		columnid;
	IDXSEG			rgidxseg[JET_ccolKeyMost];
	IDXSEG			rgidxsegConditional[JET_ccolKeyMost];
	const BOOL		fLockColumn				= !pfcb->FDomainDenyReadByUs( ppib );
	const BOOL		fPrimary				= pidb->FPrimary();
	BOOL			fColumnWasDerived;
	BOOL			fMultivalued;
	BOOL			fText;
	BOOL			fLocalizedText;
	BOOL			fCleanupIDB 			= fFalse;
	USHORT			iidxseg;

	//	if we don't have exclusive use of the table, we have
	//	to lock all columns in the index to ensure they don't
	//	get deleted out from underneath us
	Assert( !fLockColumn || !pfcb->FTemplateTable() );

	for ( iidxseg = 0; iidxseg < pidb->Cidxseg(); iidxseg++ )
		{
		Call( ErrFILEGetPfieldAndEnterDML(
					ppib,
					pfcb,
					rgszColumns[iidxseg],
					&pfield,
					&columnid,
					&fColumnWasDerived,
					fLockColumn ) );

		fMultivalued = FFIELDMultivalued( pfield->ffield );
		fText = FRECTextColumn( pfield->coltyp );
		fLocalizedText = ( fText && usUniCodePage == pfield->cp );
		
		if ( FFIELDEscrowUpdate( pfield->ffield ) || FRECSLV( pfield->coltyp ) )
			{
			err = ErrERRCheck( JET_errCannotIndex );
			}
		else if ( fPrimary && fMultivalued )
			{
			//	primary index cannot be multivalued
			//
			err = ErrERRCheck( JET_errIndexInvalidDef );
			}
		else if ( ( pidxcreate->grbit & JET_bitIndexEmpty ) && FFIELDDefault( pfield->ffield ) )
			{
			//	can't build empty index over column with default value
			err = ErrERRCheck( JET_errIndexInvalidDef );
			}

		if ( !fColumnWasDerived )
			{
			pfcb->LeaveDML();
			}
			
		Call( err );

		if ( pidb->FTuples() )
			{
			if ( !fText )
				{
				err = ErrERRCheck( JET_errIndexTuplesTextColumnsOnly );
				goto HandleError;
				}
			}

		if ( fMultivalued )
			pidb->SetFMultivalued();
		if ( fLocalizedText )
			pidb->SetFLocalizedText();

		rgidxseg[iidxseg].ResetFlags();

		if ( rgfbDescending[iidxseg] )
			rgidxseg[iidxseg].SetFDescending();

		rgidxseg[iidxseg].SetColumnid( columnid );
		}

	if( pidxcreate->cConditionalColumn > JET_ccolKeyMost )
		{
		err = ErrERRCheck( JET_errIndexInvalidDef );
		Call( err );			
		}
		
	pidb->SetCidxsegConditional( BYTE( pidxcreate->cConditionalColumn ) );
	for ( iidxseg = 0; iidxseg < pidb->CidxsegConditional(); iidxseg++ )
		{
		Assert( !pidb->FPrimary() );
		
		const CHAR			* const szColumnName	= pidxcreate->rgconditionalcolumn[iidxseg].szColumnName;
		const JET_GRBIT		grbit					= pidxcreate->rgconditionalcolumn[iidxseg].grbit;

		if( sizeof( JET_CONDITIONALCOLUMN ) != pidxcreate->rgconditionalcolumn[iidxseg].cbStruct )
			{
			err = ErrERRCheck( JET_errIndexInvalidDef );
			Call( err );			
			}
			
		if( JET_bitIndexColumnMustBeNonNull != grbit
			&& JET_bitIndexColumnMustBeNull != grbit )
			{
			err = ErrERRCheck( JET_errInvalidGrbit );
			Call( err );			
			}

		Call( ErrFILEGetPfieldAndEnterDML(
				ppib,
				pfcb,
				szColumnName,
				&pfield,
				&columnid,
				&fColumnWasDerived,
				fLockColumn ) );
		if ( !fColumnWasDerived )
			{
			pfcb->LeaveDML();
			}

		rgidxsegConditional[iidxseg].ResetFlags();

		if ( JET_bitIndexColumnMustBeNull == grbit )
			{
			rgidxsegConditional[iidxseg].SetFMustBeNull();
			}

		rgidxsegConditional[iidxseg].SetColumnid( columnid );
		}
		
	pfcb->EnterDDL();

	USHORT	itag;
	err = pfcb->Ptdb()->MemPool().ErrAddEntry(
				(BYTE *)szIndexName,
				(ULONG)strlen( szIndexName ) + 1,
				&itag );
	if ( err < JET_errSuccess )
		{
		pfcb->LeaveDDL();
		goto HandleError;
		}
	Assert( 0 != itag );
	pidb->SetItagIndexName( itag );
		
	err = ErrIDBSetIdxSeg( pidb, pfcb->Ptdb(), rgidxseg );
	if ( err < JET_errSuccess )
		{
		pfcb->Ptdb()->MemPool().DeleteEntry( pidb->ItagIndexName() );
		pfcb->LeaveDDL();
		goto HandleError;
		}
	err = ErrIDBSetIdxSegConditional( pidb, pfcb->Ptdb(), rgidxsegConditional );
	if ( err < JET_errSuccess )
		{
		if ( pidb->Cidxseg() > cIDBIdxSegMax )
			pfcb->Ptdb()->MemPool().DeleteEntry( pidb->ItagRgidxseg() );
		pfcb->Ptdb()->MemPool().DeleteEntry( pidb->ItagIndexName() );
		pfcb->LeaveDDL();
		goto HandleError;
		}
	fCleanupIDB = fTrue;

	Assert( !pfcb->FDomainDenyRead( ppib ) );
	if ( !pfcb->FDomainDenyReadByUs( ppib ) )
		{
		pidb->SetFVersioned();
		pidb->SetFVersionedCreate();
		}
		
	//	currently on Table FDP
	//
	DIRGotoRoot( pfucbTable );
	if ( fPrimary )
		{
		pfcb->AssertDDL();

		if ( pfcb->FSequentialIndex() )
			{
			Assert( pfcb->Pidb() == pidbNil );
			}
		else
			{
			// Primary index exists, or is in the process of being created (thus,
			// IDB may or may not be linked in).
			Assert( pfcb->Pidb() != pidbNil );
			pfcb->LeaveDDL();
			err = ErrERRCheck( JET_errIndexHasPrimary );
			goto HandleError;
			}

		// Block other threads from also creating primary index.
		pfcb->ResetSequentialIndex();
		
		pfcb->LeaveDDL();
		
		//	primary indexes are in same FDP as table
		//
		pgnoIndexFDP = pfcb->PgnoFDP();
		objidIndex = pfcb->ObjidFDP();

		// Must quiesce all updates in order to check that table is empty and
		// then link IDB in.
		pfcb->SetIndexing();

		//	check for records
		//
		DIRGotoRoot( pfucbTable );

		//	check for any node there, even if it is deleted.
		//	UNDONE: This is too strong since it may be deleted and
		//	committed, but this strong check ensures that no
		//	potentially there records exist.
		//
		DIB	dib;
		dib.dirflag = fDIRAllNode;
		dib.pos = posFirst;

		err = ErrDIRDown( pfucbTable, &dib );
		Assert( err <= 0 );		// Shouldn't get warnings.
		if ( JET_errRecordNotFound != err )
			{
			if ( JET_errSuccess == err )
				{
				err = ErrERRCheck( JET_errTableNotEmpty );
				DIRUp( pfucbTable );
				DIRDeferMoveFirst( pfucbTable );
				}
				
			pfcb->ResetIndexing();
			goto HandleError;
			}

		DIRGotoRoot( pfucbTable );

		pfcb->EnterDDL();

		Assert( !pfcb->FSequentialIndex() );
		err = ErrFILEIGenerateIDB( pfcb, pfcb->Ptdb(), pidb );
		if ( err < 0 )
			{
			pfcb->LeaveDDL();
			pfcb->ResetIndexing();
			goto HandleError;
			}

		Assert( pidbNil != pfcb->Pidb() );
		Assert( !pfcb->FSequentialIndex() );
		
		Assert( pfcb->PgnoFDP() == pgnoIndexFDP );
		Assert( ((( 100 - ulDensity ) << g_shfCbPage ) / 100) < g_cbPage );
		pfcb->SetCbDensityFree( (SHORT)( ( ( 100 - ulDensity ) << g_shfCbPage ) / 100 ) );

		// update all index mask
		FILESetAllIndexMask( pfcb );

		pfcb->LeaveDDL();

		pfcb->ResetIndexing();

		//	set currency to before first
		//
		DIRBeforeFirst( pfucbTable );
		
		Assert( pfucbNil == *ppfucbIdx );
		Assert( pfcbIdx == pfcbNil );
		}
	else
		{
		pfcb->LeaveDDL();

		Call( ErrDIRCreateDirectory(
				pfucbTable,
				(CPG)0,
				&pgnoIndexFDP,
				&objidIndex,
				CPAGE::fPageIndex | ( pidb->FUnique() ? 0 : CPAGE::fPageNonUniqueKeys ),
				( pidb->FUnique() ? 0 : fSPNonUnique ) ) );
		Assert( pgnoIndexFDP != pfcb->PgnoFDP() );
		Assert( objidIndex > objidSystemRoot );
		
		//	objids are monotonically increasing, so an index should
		//	always have higher objid than its table
		Assert( objidIndex > pfcb->ObjidFDP() );

		//	get pfcb of index directory
		//
		Call( ErrDIROpen( ppib, pgnoIndexFDP, ifmp, ppfucbIdx ) );
		Assert( *ppfucbIdx != pfucbNil );
		Assert( !FFUCBVersioned( *ppfucbIdx ) );	// Verify won't be deferred closed.
		pfcbIdx = (*ppfucbIdx)->u.pfcb;
		Assert( !pfcbIdx->FInitialized() );
		Assert( pfcbIdx->Pidb() == pidbNil );

		//	make an FCB for this index
		//
		pfcb->EnterDDL();
		err = ErrFILEIInitializeFCB(
			ppib,
			ifmp,
			pfcb->Ptdb(),
			pfcbIdx,
			pidb, 
			fFalse,
			pgnoIndexFDP,
			ulDensity );
		pfcb->LeaveDDL();
		Call( err );

		Assert( pidbNil != pfcbIdx->Pidb() );

		//	finish the initialization of the secondary index

		pfcbIdx->CreateComplete();
		}

	Assert( pgnoIndexFDP > pgnoSystemRoot );
	Assert( pgnoIndexFDP <= pgnoSysMax );

	//	create index is flagged in version store so that
	//	DDL will be undone.  If flag fails then pfcbIdx
	//	must be released.
	//
	err = PverFromIfmp( ifmp )->ErrVERFlag( pfucbTable, operCreateIndex, &pfcbIdx, sizeof( pfcbIdx ) );
	if ( err < 0 )
		{
		if ( fPrimary )
			{
			pfcb->EnterDDL();
			pfcb->SetSequentialIndex();
			pfcb->LeaveDDL();
			}
		else
			{

			//	force the FCB to be uninitialized so that it will 
			//		eventually be purged by DIRClose
			
			pfcbIdx->Lock();
			pfcbIdx->CreateComplete( errFCBUnusable );
			pfcbIdx->Unlock();

			//	verify that the FUCB will not be defer-closed

			Assert( !FFUCBVersioned( *ppfucbIdx ) );
			}
		goto HandleError;
		}

	fCleanupIDB = fFalse;	// FCB and IDB now in version store, so rollback will clean up.

	// Insert record into MSysIndexes.
	Call( ErrCATAddTableIndex(
				ppib,
				ifmp,
				pfcb->ObjidFDP(),
				szIndexName,
				pgnoIndexFDP,
				objidIndex,
				pidb,
				rgidxseg,
				rgidxsegConditional,
				ulDensity ) );

HandleError:
	if ( fCleanupIDB )
		{
		// We failed before we could properly version the index's FCB, so we'll
		// have to clean up the IDB ourself.
		Assert( err < 0 );
		
		pfcb->Ptdb()->MemPool().DeleteEntry( pidb->ItagIndexName() );
		if ( pidb->FIsRgidxsegInMempool() )
			pfcb->Ptdb()->MemPool().DeleteEntry( pidb->ItagRgidxseg() );
		if ( pidb->FIsRgidxsegConditionalInMempool() )
			pfcb->Ptdb()->MemPool().DeleteEntry( pidb->ItagRgidxsegConditional() );
		if ( pfcbNil != pfcbIdx && pidbNil != pfcbIdx->Pidb() )
			{
			pfcbIdx->ReleasePidb();
			}
		}

	return err;
	}


// ErrFILEICreateIndex
// ========================================================================
// ERR ErrFILEICreateIndex(
//		PIB		*ppib;			// IN	PIB of user
//		FUCB  	*pfucb;   		// IN	Exclusively opened FUCB of file
//		JET_INDEXCREATE * pindexcreate )	
//
//	Defines an index on a file.
//
// PARAMETERS
//		ppib			PIB of user
//		pfucb			Exclusively opened FUCB of file
//		pindexcreate	Pointer to index create structure
//
//
// RETURNS	Error code from DIRMAN or
//			JET_errSuccess			Everything worked OK.
//			-JET_errColumnNotFound 	The index key specified
//									contains an undefined field.
//			-IndexHasPrimary 		The primary index for this
//							 		Insertfile is already defined.
// 			-IndexDuplicate  		An index on this file is
//	   								already defined with the
//									given name.
// 			-IndexInvalidDef 		There are too many segments
//							 		in the key.
// 			-TableNotEmpty	 		A primary index may not be
// 									defined because there is at
// 									least one record already in
// 									the file.
// COMMENTS
//		If transaction level > 0, there must not be anyone currently
//		using the file.
//		A transaction is wrapped around this function.	Thus, any
//		work done will be undone if a failure occurs.
//
// SEE ALSO		ErrIsamAddColumn, ErrIsamCreateTable, ErrIsamCreateIndex
//-
LOCAL ERR VTAPI ErrFILEICreateIndex(
	PIB					* ppib,
	FUCB				* pfucbTable,
	JET_INDEXCREATE		* pidxcreate )
	{
	ERR					err;
	FUCB				* pfucb						= pfucbNil;
	FUCB				* pfucbIdx 					= pfucbNil;
	FCB					* const pfcb				= pfucbTable->u.pfcb;
	FCB					* pfcbIdx					= pfcbNil;
	IDB					idb;
	CHAR				szIndexName[ JET_cbNameMost+1 ];
	const CHAR			* rgszColumns[JET_ccolKeyMost];
	BYTE				rgfbDescending[JET_ccolKeyMost];
	const ULONG			ulDensity					= ( 0 == pidxcreate->ulDensity ) ? pfcb->UlDensity() : pidxcreate->ulDensity;
	BOOL				fInTransaction				= fFalse;
	BOOL				fUnversioned 				= fFalse;
	BOOL				fResetVersionedOnSuccess	= fFalse;

	//	check parms
	//
	CallR( ErrPIBCheck( ppib ) );
	CheckTable( ppib, pfucbTable );

	if( sizeof( JET_INDEXCREATE ) != pidxcreate->cbStruct )
		{
		return ErrERRCheck( JET_errInvalidParameter );
		}
		
	Assert( dbidTemp != rgfmp[ pfucbTable->ifmp ].Dbid() );	// Don't currently support DDL on temp. tables.
	
	if ( pidxcreate->grbit & JET_bitIndexUnversioned )
		{
		if ( !FFUCBDenyRead( pfucbTable ) )
			{
			if ( ppib->level != 0 )
				{
				AssertSz( fFalse, "Must not be in transaction for unversioned CreateIndex." );
				err = ErrERRCheck( JET_errInTransaction );
				return err;
				}
			fUnversioned = fTrue;
			}
		}
		

	//	ensure that table is updatable
	//
	CallR( ErrFUCBCheckUpdatable( pfucbTable ) );
	CallR( ErrPIBCheckUpdatable( ppib ) );

	if ( pfcb->FFixedDDL() )
		{
		// Check FixedDDL override.
		if ( !FFUCBPermitDDL( pfucbTable ) || pfcb->FTemplateTable() )
			{
			err = ErrERRCheck( JET_errFixedDDL );
			return err;
			}
			
		// If DDL temporarily permitted, we must have exclusive use of the table.
		Assert( pfcb->FDomainDenyReadByUs( ppib ) );
		}

	CallR( ErrUTILCheckName( szIndexName, pidxcreate->szIndexName, JET_cbNameMost+1 ) );

	Assert( pfcb->Ptdb() != ptdbNil );
	CallR( ErrFILEIValidateCreateIndex(
				&idb,
				rgszColumns,
				rgfbDescending,
				pidxcreate,
				ulDensity ) );

	if ( fUnversioned )
		{
		CallR( ErrFILEInsertIntoUnverIndexList( pfcb, szIndexName ) );
		fResetVersionedOnSuccess = !pfcb->FDomainDenyReadByUs( ppib );
		}

	const BOOL	fPrimary	= idb.FPrimary();

	// Temporarily open new table cursor.
	Call( ErrDIROpen( ppib, pfcb, &pfucb ) );
	FUCBSetIndex( pfucb );

	Assert( pfucb->u.pfcb != pfcbNil );
	Assert( pfcb == pfucbTable->u.pfcb );
	Assert( pfcb->WRefCount() > 0 );
	Assert( pfcb->FTypeTable() );	// Temp. tables have fixed DDL.
	Assert( pfcb->Ptdb() != ptdbNil );

	Assert( !FFUCBSecondary( pfucb ) );
	Assert( !FCATSystemTable( pfcb->PgnoFDP() ) );

	Call( ErrDIRBeginTransaction( ppib, NO_GRBIT ) );
	fInTransaction = fTrue;
	
	Call( ErrFILEIPrepareOneIndex(
			ppib,
			pfucb,
			&pfucbIdx,
			pidxcreate,
			szIndexName,
			rgszColumns,
			rgfbDescending,
			&idb,
			ulDensity ) );

	if ( fPrimary )
		{
		Assert( pfucbNil == pfucbIdx );
		Assert( pfcbNil == pfcbIdx );
		}
	else
		{
		Assert( pfucbNil != pfucbIdx );
		pfcbIdx = pfucbIdx->u.pfcb;

		Assert( pfcbNil != pfcbIdx );
		Assert( pfcbIdx->FTypeSecondaryIndex() );
		
		if ( fUnversioned )
			{
			// Must reset trxBegin0 to oldest outstanding transaction
			// in order to get index properly versioned for all sessions.
			INST *pinst = PinstFromPpib( ppib );
			pinst->m_critPIBTrxOldest.Enter();
			if( pinst->m_ppibTrxOldest->trxBegin0 != ppib->trxBegin0 )
				{
				PIBDeleteFromTrxList( ppib );
				PIBSetTrxBegin0ToTrxOldest( ppib );
				}
			pinst->m_critPIBTrxOldest.Leave();
			}
		
		if ( pidxcreate->grbit & JET_bitIndexEmpty )
			{
			// UNDONE: This is a VERY dangerous flag.  The client had better
			// really know what he's doing, or the index could be easily
			// corrupted.  Ideally, the CreateIndex() should be wrapped in
			// a transaction along with the AddColumn() calls for the columns
			// in the index, and no records should be added between the
			// AddColumn() and the CreateIndex().  By putting the AddColumn()
			// in the same transaction as the CreateIndex(), you ensure that
			// other sessions won't be adding records with values over the
			// indexed columns.
			Assert( !idb.FNoNullSeg() );		// JET_bitIndexIgnoreAnyNull must also be specified.
			Assert( !idb.FAllowSomeNulls() );
			Assert( !idb.FAllowFirstNull() );
			Assert( !idb.FAllowAllNulls() );
	
			// link new FCB and update all index mask
			pfcb->EnterDDL();
			pfcb->LinkSecondaryIndex( pfcbIdx );
			FILESetAllIndexMask( pfcb );
			pfcb->LeaveDDL();

			//	since we have a cursor open on pfcbTable, the FCB
			//		cannot be in the avail list; thus, we can directly
			//		set the above-threshold flag 

			if ( pfcbIdx >= PfcbFCBPreferredThreshold( PinstFromPpib( ppib ) ) )
				{
				pfcb->Lock();
				pfcb->SetAboveThreshold();
				pfcb->Unlock();
				}
			}
		else
			{
			FUCBSetIndex( pfucbIdx );
			FUCBSetSecondary( pfucbIdx );
			
			//	build index using our versioned view of the table
			Call( ErrFILEIBuildIndex( ppib, pfucb, pfucbIdx ) );

			Assert( !FFUCBVersioned( pfucbIdx ) );	// no versioned operations should have occurred on this cursor
			DIRBeforeFirst( pfucb );

			//	update the index with operations happening concurrently
			Call( ErrFILEIUpdateIndex( ppib, pfucb, pfucbIdx ) );
			}

		// FCB now linked into table's index list, which guarantees that
		// it will be available at Commit/Rollback time, so we can dispose
		// of the index cursor.
		Assert( !FFUCBVersioned( pfucbIdx ) );	// no versioned operations should have occurred on this cursor
		Assert( pfucbNil != pfucbIdx );
		DIRClose( pfucbIdx );
		pfucbIdx = pfucbNil;
		}
	
	Call( ErrDIRCommitTransaction( ppib, ( pidxcreate->grbit & JET_bitIndexLazyFlush ) ? JET_bitCommitLazyFlush : 0 ) );
	fInTransaction = fFalse;

HandleError:
	if ( fInTransaction )
		{
		Assert( err < 0 );		// Must have hit an error.
		
		if ( pfucbNil != pfucbIdx )
			{
			//	no versioned operations should have been performed, 
			//		so this FUCB will not be defer-closed
			Assert( !FFUCBVersioned( pfucbIdx ) );
			DIRClose( pfucbIdx );
			}
			
		CallSx( ErrDIRRollback( ppib ), JET_errRollbackError );
		}
	else
		{
		Assert( pfucbNil == pfucbIdx );
		}

	if ( pfucbNil != pfucb )
		DIRClose( pfucb );
	AssertDIRNoLatch( ppib );

	if ( fUnversioned )
		{
		if ( fResetVersionedOnSuccess && err >= 0 )
			{
			IDB		* pidbT;

			//	for primary index, FUCB is not opened
			//	for secondary index, FUCB is closed on success
			Assert( pfucbNil == pfucbIdx );

			// On success, reset versioned bit (on error, bit reset by rollback)
			pfcb->EnterDDL();
			if ( fPrimary )
				{
				Assert( pfcbNil == pfcbIdx );
				pidbT = pfcb->Pidb();
				}
			else
				{
				Assert( pfcbNil != pfcbIdx );
				pidbT = pfcbIdx->Pidb();
				}
			Assert( pidbNil != pidbT );
			pidbT->ResetFVersioned();
			pidbT->ResetFVersionedCreate();
			pfcb->LeaveDDL();
			}

		FILERemoveFromUnverList( &punveridxGlobal, critUnverIndex, pfcb->ObjidFDP(), szIndexName );
		}
	
	return err;
	}


LOCAL ERR VTAPI ErrFILEIBatchCreateIndex(
	PIB					*ppib,
	FUCB				*pfucbTable,
	JET_INDEXCREATE		*pidxcreate,
	const ULONG			cIndexes )
	{
	ERR					err;
	FUCB				* pfucb						= pfucbNil;
	FCB					* const pfcb				= pfucbTable->u.pfcb;
	FUCB 			  	* rgpfucbIdx[cFILEIndexBatchMax];
	FCB					* pfcbIndexes				= pfcbNil;
	IDB					idb;
	CHAR				szIndexName[ JET_cbNameMost+1 ];
	const CHAR			*rgszColumns[JET_ccolKeyMost];
	BYTE				rgfbDescending[JET_ccolKeyMost];
	BOOL				fInTransaction				= fFalse;
	BOOL				fLazyCommit					= fTrue;
	ULONG				iindex;

	//	check parms
	//
	CallR( ErrPIBCheck( ppib ) );
	CheckTable( ppib, pfucbTable );

	Assert( dbidTemp != rgfmp[ pfucbTable->ifmp ].Dbid() );	// Don't currently support DDL on temp. tables.

	//	ensure that table is updatable
	//
	CallR( ErrFUCBCheckUpdatable( pfucbTable ) );
	CallR( ErrPIBCheckUpdatable( ppib ) );

	if ( 0 != ppib->level )
		{
		//	batch mode requires level 0
		err = ErrERRCheck( JET_errInTransaction );
		return err;
		}

	if ( !pfcb->FDomainDenyReadByUs( ppib ) )
		{
		//	batch mode requires 
		err = ErrERRCheck( JET_errExclusiveTableLockRequired );
		return err;
		}

	if ( pfcb->FFixedDDL() )
		{
		// Check FixedDDL override.
		if ( !FFUCBPermitDDL( pfucbTable ) || pfcb->FTemplateTable() )
			{
			err = ErrERRCheck( JET_errFixedDDL );
			return err;
			}
			
		// If DDL temporarily permitted, we must have exclusive use of the table.
		Assert( pfcb->FDomainDenyReadByUs( ppib ) );
		}

	if ( cIndexes > cFILEIndexBatchMax )
		{
		err = ErrERRCheck( JET_errTooManyIndexes );
		return err;
		}

	for ( iindex = 0; iindex < cIndexes; iindex++ )
		rgpfucbIdx[iindex] = pfucbNil;

	// Temporarily open new table cursor.
	CallR( ErrDIROpen( ppib, pfcb, &pfucb ) );
	FUCBSetIndex( pfucb );

	Assert( pfucb->u.pfcb != pfcbNil );
	Assert( pfcb == pfucb->u.pfcb );
	Assert( pfcb->WRefCount() > 0 );
	Assert( pfcb->FTypeTable() );	// Temp. tables have fixed DDL.
	Assert( pfcb->Ptdb() != ptdbNil );

	Assert( !FFUCBSecondary( pfucb ) );
	Assert( !FCATSystemTable( pfcb->PgnoFDP() ) );

	Call( ErrDIRBeginTransaction( ppib, NO_GRBIT ) );
	fInTransaction = fTrue;

	for ( iindex = 0; iindex < cIndexes; iindex++ )
		{
		JET_INDEXCREATE		* const pidxcreateT	= pidxcreate + iindex;
		FCB					* pfcbIndexT;

		if( sizeof( JET_INDEXCREATE ) != pidxcreateT->cbStruct )
			{
			return ErrERRCheck( JET_errInvalidParameter );
			}
		if ( pidxcreateT->grbit & ( JET_bitIndexPrimary | JET_bitIndexUnversioned | JET_bitIndexEmpty ) )
			{
			//	currently unsupported in batch mode
			return ErrERRCheck( JET_errInvalidGrbit );
			}

		if ( fLazyCommit && !( pidxcreateT->grbit & JET_bitIndexLazyFlush ) )
			{
			//	if even one of the indexes cannot be lazily flushed,
			//	then none of them can
			fLazyCommit = fFalse;
			}

		const ULONG		ulDensity	= ( 0 == pidxcreateT->ulDensity ) ?
											pfcb->UlDensity() :
											pidxcreateT->ulDensity;

		Call( ErrUTILCheckName( szIndexName, pidxcreateT->szIndexName, JET_cbNameMost+1 ) );

		Call( ErrFILEIValidateCreateIndex(
					&idb,
					rgszColumns,
					rgfbDescending,
					pidxcreateT,
					ulDensity ) );

		Call( ErrFILEIPrepareOneIndex(
				ppib,
				pfucb,
				&rgpfucbIdx[iindex],
				pidxcreateT,
				szIndexName,
				rgszColumns,
				rgfbDescending,
				&idb,
				ulDensity ) );

		pfcbIndexT = rgpfucbIdx[iindex]->u.pfcb;
		Assert( pfcbIndexT->FTypeSecondaryIndex() );
		pfcbIndexT->SetPfcbNextIndex( pfcbIndexes );
		pfcbIndexT->SetPfcbTable( pfcb );

		pfcbIndexes = pfcbIndexT;
		}

	Call( ErrFILEBuildAllIndexes( ppib, pfucb, pfcbIndexes, NULL, cIndexes ) );

	pfcb->EnterDDL();

	Assert( pfcbNil == rgpfucbIdx[0]->u.pfcb->PfcbNextIndex() );
	Assert( pfcbIndexes == rgpfucbIdx[cIndexes-1]->u.pfcb );
	rgpfucbIdx[0]->u.pfcb->SetPfcbNextIndex( pfcb->PfcbNextIndex() );
	pfcb->SetPfcbNextIndex( pfcbIndexes );

	FILESetAllIndexMask( pfcb );

	pfcb->LeaveDDL();

	for ( iindex = 0; iindex < cIndexes; iindex++ )
		{
		Assert( pfucbNil != rgpfucbIdx[iindex] );
		Assert( pfcbNil != rgpfucbIdx[iindex]->u.pfcb );
		Assert( rgpfucbIdx[iindex]->u.pfcb->FTypeSecondaryIndex() );

		//	since we have a cursor open on pfcbTable, the FCB
		//		cannot be in the avail list; thus, we can directly
		//		set the above-threshold flag 
		if ( rgpfucbIdx[iindex]->u.pfcb >= PfcbFCBPreferredThreshold( PinstFromPpib( ppib ) ) )
			{
			pfcb->Lock();
			pfcb->SetAboveThreshold();
			pfcb->Unlock();
			}

		Assert( !FFUCBVersioned( rgpfucbIdx[iindex] ) );	// No versioned operations should have been performed, so won't be defer-closed.
		DIRClose( rgpfucbIdx[iindex] );
		}

	Call( ErrDIRCommitTransaction( ppib, fLazyCommit ? JET_bitCommitLazyFlush : 0 ) );
	fInTransaction = fFalse;

HandleError:
	if ( fInTransaction )
		{
		Assert( err < 0 );		// Must have hit an error.
		
		for ( iindex = 0; iindex < cIndexes; iindex++ )
			{
			if ( pfucbNil != rgpfucbIdx[iindex] )
				{
				Assert( !FFUCBVersioned( rgpfucbIdx[iindex] ) );	// No versioned operations should have been performed, so won't be defer-closed.
				DIRClose( rgpfucbIdx[iindex] );
				}
			}
			
		CallSx( ErrDIRRollback( ppib ), JET_errRollbackError );
		}

	Assert( pfucbNil != pfucb );
	DIRClose( pfucb );
	AssertDIRNoLatch( ppib );

	return err;
	}

//+API
// ErrIsamCreateIndex
// ========================================================================
// ERR ErrIsamCreateIndex(
//		SESID	sesid;			// IN	PIB of user
//		TABLEID tableid;   		// IN	Exclusively opened FUCB of file
//		JET_INDEXCREATE * pindexcreate;	// IN	Array of indexes to create
//		unsigned long cIndexCreate );	// IN	Number of indexes to create
//
//	Creates indexes on a table
//
//
// RETURNS	Error code from ErrFILEICreateIndex or
//			JET_errSuccess			Everything worked OK.
//			-JET_errColumnNotFound 	The index key specified
//									contains an undefined field.
//			-IndexHasPrimary 		The primary index for this
//							 		Insertfile is already defined.
// 			-IndexDuplicate  		An index on this file is
//	   								already defined with the
//									given name.
// 			-IndexInvalidDef 		There are too many segments
//							 		in the key.
// 			-TableNotEmpty	 		A primary index may not be
// 									defined because there is at
// 									least one record already in
// 									the file.
// COMMENTS
//		If transaction level > 0, there must not be anyone currently
//		using the file.
//		A transaction is wrapped around this function.	Thus, any
//		work done will be undone if a failure occurs.
//
// SEE ALSO		ErrIsamAddColumn, ErrIsamCreateTable, ErrFILEICreateTable
//-
ERR VTAPI ErrIsamCreateIndex(
	JET_SESID			sesid,
	JET_VTID			vtid,
	JET_INDEXCREATE		*pindexcreate,
	unsigned long		cIndexCreate )
	{
	ERR					err;
 	PIB					* const ppib 		= reinterpret_cast<PIB *>( sesid );
	FUCB				* const pfucbTable 	= reinterpret_cast<FUCB *>( vtid );

	if ( 1 == cIndexCreate )
		{
		err = ErrFILEICreateIndex( ppib, pfucbTable, pindexcreate );
		}
	else
		{
		err = ErrFILEIBatchCreateIndex( ppib, pfucbTable, pindexcreate, cIndexCreate );
		}

	return err;
	}


//+API
// ErrIsamDeleteTable
// ========================================================================
// ERR ErrIsamDeleteTable( JET_SESID vsesid, JET_DBID vdbid, CHAR *szName )
//
// Calls ErrFILEIDeleteTable to
// delete a file and all indexes associated with it.
//
// RETURNS		JET_errSuccess or err from called routine.
//
// SEE ALSO		ErrIsamCreateTable
//-
ERR VTAPI ErrIsamDeleteTable( JET_SESID vsesid, JET_DBID vdbid, const CHAR *szName )
	{
	ERR		err;
	PIB		*ppib = (PIB *)vsesid;
	IFMP	ifmp = (IFMP)vdbid;

	//	check parameters
	//
	CallR( ErrPIBCheck( ppib ) );
	CallR( ErrPIBCheckIfmp( ppib, ifmp ) );
	CallR( ErrPIBCheckUpdatable( ppib ) );

	if ( dbidTemp == rgfmp[ ifmp ].Dbid() )
		{
		// Cannot use DeleteTable on temporary tables.
		// Must use CloseTable insetad.
		err = ErrERRCheck( JET_errCannotDeleteTempTable );
		}
	else
		{
		err = ErrFILEDeleteTable( ppib, ifmp, szName );
		}

	return err;
	}


// ErrFILEDeleteTable
// ========================================================================
// ERR ErrFILEDeleteTable( PIB *ppib, IFMP ifmp, CHAR *szName )
//
// Deletes a file and all indexes associated with it.
//
// RETURNS		JET_errSuccess or err from called routine.
//

// COMMENTS
//	Acquires an exclusive lock on the file [FCBSetDelete].
//	A transaction is wrapped around this function.	Thus,
//	any work done will be undone if a failure occurs.
//	Transaction logging is turned off for temporary files.
//
// SEE ALSO		ErrIsamCreateTable
//-
ERR ErrFILEDeleteTable( PIB *ppib, IFMP ifmp, const CHAR *szName )
	{
	ERR   	err;
	FUCB  	*pfucb				= pfucbNil;
	FUCB	*pfucbParent		= pfucbNil;
	FCB	  	*pfcb				= pfcbNil;
	PGNO	pgnoFDP;
	OBJID	objidTable;
	CHAR	szTable[JET_cbNameMost+1];
	BOOL	fInUseBySystem;
	BOOL	fSentinel			= fFalse;
	VER		*pver;

	CheckPIB( ppib );
	CheckDBID( ppib, ifmp );

	//	must normalise for CAT hash deletion
	//	PERF UNDONE: the name will be normalised again in FILEOpenTable()
	CallR( ErrUTILCheckName( szTable, szName, JET_cbNameMost+1 ) );

	CallR( ErrDIRBeginTransaction( ppib, NO_GRBIT ) );

	//	open cursor on database and seek to table without locking
	//
	Call( ErrDIROpen( ppib, pgnoSystemRoot, ifmp, &pfucbParent ) );

	Assert( dbidTemp != rgfmp[ ifmp ].Dbid() );	// Don't call DeleteTable on temp. tables -- use CloseTable instead.
	
	Call( ErrFILEOpenTable(
				ppib,
				ifmp,
				&pfucb,
				szName,
				JET_bitTableDelete|JET_bitTableDenyRead ) );
	fInUseBySystem = ( JET_wrnTableInUseBySystem == err );

	// We should now have exclusive use of the table.
    pfcb = pfucb->u.pfcb;
	pgnoFDP = pfcb->PgnoFDP();
	objidTable = pfcb->ObjidFDP();

	Assert( pfcb->FTypeTable() || pfcb->FTypeSentinel() );
	if ( pfcb->FTemplateTable() )
		{
		// UNDONE: Deletion of template table not currently supported.
		// However, if the template table is opened as a sentinel,
		// then the TemplateTable flag will not be set, in which
		// case the table will be allowed to be deleted.  Any existing
		// inherited tables will fail if an attempt is made to open
		// them.
		err = ErrERRCheck( JET_errCannotDeleteTemplateTable );
		goto HandleError;
		}

	if( pfcb->Ptdb()->FTableHasSLVColumn() )
		{
		//	Deleting of tables with SLV columns and records is not supported
		//	as we will orphan the space.
		
		DIB dib;
		dib.dirflag = fDIRNull;
		dib.pos		= posFirst;
		DIRGotoRoot( pfucb );
		if ( ( err = ErrDIRDown( pfucb, &dib ) ) != JET_errRecordNotFound )
			{
			if ( JET_errSuccess == err )
				{
				Call( ErrERRCheck( JET_errSLVColumnCannotDelete ) );
				}					
			Call( err );
			}
		}

	//	the following assert(s) goes off when we reuse a cursor that 
	//	was defer closed by us -- it has been disabled for now
	//
//	Assert( !FFUCBVersioned( pfucb ) );
	Assert( pfcb->FDomainDenyReadByUs( ppib ) );

	// If sentinel was allocated, it will be freed by commit/rollback, unless
	// versioning failed, it which case we'll free it.
	fSentinel = pfcb->FTypeSentinel();
	Assert( !fSentinel || !FFUCBVersioned( pfucb ) );
	
	pver = PverFromIfmp( pfucb->ifmp );
	err = pver->ErrVERFlag( pfucbParent, operDeleteTable, &pgnoFDP, sizeof(pgnoFDP) );
	if ( err < 0 )
		{
		// Must close FUCB first in case sentinel exists.  Set to pfucbNil
		// afterwards so HandleError doesn't try to close FUCB again.
//		Assert( !FFUCBVersioned( pfucb ) );		// Verifies FUCB is not deferred closed.
		Assert( !fSentinel || !FFUCBVersioned( pfucb ) );
		DIRClose( pfucb );
		pfucb = pfucbNil;
		
		if ( fSentinel )
			{
			// No one else has access to this FCB, so pfcb should still be valid.
			pfcb->PrepareForPurge();
			pfcb->Purge();
			}
		goto HandleError;
		}

	Assert( pfcb->PgnoFDP() == pgnoFDP );
	Assert( pfcb->Ifmp() == ifmp );

	// UNDONE: Is it necessary to grab critical section, since we have
	// exclusive use of the table?
	if ( pfcb->Ptdb() != ptdbNil )
		{
		Assert( !fSentinel );
		
		pfcb->EnterDDL();
			
		for ( FCB *pfcbT = pfcb; pfcbT != pfcbNil; pfcbT = pfcbT->PfcbNextIndex() )
			{
			Assert( pfcbT->Ifmp() == ifmp );
			Assert( pfcbT == pfcb
				|| ( pfcbT->FTypeSecondaryIndex()
					&& pfcbT->PfcbTable() == pfcb ) );
			pfcbT->SetDeletePending();
			}
			
		if ( pfcb->Ptdb()->PfcbLV() != pfcbNil )
			pfcb->Ptdb()->PfcbLV()->SetDeletePending();

		pfcb->LeaveDDL();
		}
	else
		{
		Assert( fSentinel );
		Assert( !fInUseBySystem );
		Assert( pfcbNil == pfcb->PfcbNextIndex() );
		pfcb->SetDeletePending();
		}


	if ( fInUseBySystem )
		{
		pfcb->Lock();

		do
			{
			fInUseBySystem = fFalse;

			for ( FUCB * pfucbT = pfcb->Pfucb(); pfucbT != pfucbNil; pfucbT = pfucbT->pfucbNextOfFile )
				{
				Assert( pfucbT->ppib == ppib || FPIBSessionSystemCleanup( pfucbT->ppib ) );

				//	don't care about RCE clean, because any outstanding versions will be cleaned
				//	before the DeleteTable version is cleaned.
				if ( pfucbT->ppib->FSessionOLD()
					|| pfucbT->ppib->FSessionOLDSLV() )
					{
					//	the DeletePending flag for this table has now been set, forcing
					//	OLD to exit at its earliest convenience.  Wait for it.
					Assert( !fSentinel );
					fInUseBySystem = fTrue;
					pfcb->Unlock();
					UtilSleep( 500 );
					pfcb->Lock();
					break;
					}
#ifdef DEBUG				
				else if ( !FPIBSessionRCEClean( pfucbT->ppib ) )
					{
					Assert( pfucbT->ppib == ppib );
					Assert( pfucbT == pfucb || FFUCBDeferClosed( pfucbT ) );
					}
#endif				
				}
			}
		while ( fInUseBySystem );

		pfcb->Unlock();
		}

#ifdef DEBUG
	if ( pfcb->Ptdb() != ptdbNil )
		{
		Assert( !fSentinel );
		}
	else
		{
		Assert( fSentinel );
		Assert( !FFUCBVersioned( pfucb ) );
		}
#endif

	DIRClose( pfucb );
	pfucb = pfucbNil;

	DIRClose( pfucbParent );
	pfucbParent = pfucbNil;

	//	remove table record from MSysObjects before committing.
	Call( ErrCATDeleteTable( ppib, ifmp, objidTable ) );
	CATHashDelete( pfcb, const_cast< CHAR * >( szTable ) );

	Call( ErrDIRCommitTransaction( ppib, NO_GRBIT ) );

	AssertDIRNoLatch( ppib );
	return err;

HandleError:
	if ( pfucb != pfucbNil )
		{
		Assert( !fSentinel || !FFUCBVersioned( pfucb ) );
		DIRClose( pfucb );
		}
	if ( pfucbParent != pfucbNil )
		DIRClose( pfucbParent );

	CallSx( ErrDIRRollback( ppib ), JET_errRollbackError );
	
	AssertDIRNoLatch( ppib );

	return err;
	}


//+API
// DeleteIndex
// ========================================================================
// ERR DeleteIndex( PIB *ppib, FUCB *pfucb, CHAR *szIndex )
//
// Deletes an index definition and all index entries it contains.
//
// PARAMETERS	ppib						PIB of user
// 				pfucb						Exclusively opened FUCB on file
// 				szName						name of index to delete
// RETURNS		Error code from DIRMAN or
//					JET_errSuccess		  	 Everything worked OK.
//					-TableInvalid			 There is no file corresponding
// 											 to the file name given.
//					-TableNoSuchIndex		 There is no index corresponding
// 											 to the index name given.
//					-IndexMustStay			 The primary index of a file may
// 											 not be deleted.
// COMMENTS
//		There must not be anyone currently using the file.
//		A transaction is wrapped around this function.	Thus,
//		any work done will be undone if a failure occurs.
//		Transaction logging is turned off for temporary files.
// SEE ALSO		DeleteTable, CreateTable, CreateIndex
//-
ERR VTAPI ErrIsamDeleteIndex(
	JET_SESID		sesid,
	JET_VTID		vtid,
	const CHAR		*szName
	)
	{
 	PIB *ppib			= reinterpret_cast<PIB *>( sesid );
	FUCB *pfucbTable	= reinterpret_cast<FUCB *>( vtid );

	ERR		err;
	CHAR	szIndex[ (JET_cbNameMost + 1) ];
	FCB		*pfcbTable;
	FCB		*pfcbIdx;
	FUCB	*pfucb;
	PGNO	pgnoIndexFDP;
	BOOL	fInTransaction = fFalse;
	VER		*pver;

	CallR( ErrPIBCheck( ppib ) );
	CheckTable( ppib, pfucbTable );
	CallR( ErrUTILCheckName( szIndex, szName, ( JET_cbNameMost + 1 ) ) );

	//	ensure that table is updatable
	//
	CallR( ErrFUCBCheckUpdatable( pfucbTable )  );
	CallR( ErrPIBCheckUpdatable( ppib ) );

	Assert( ppib != ppibNil );
	Assert( pfucbTable != pfucbNil );
	Assert( pfucbTable->u.pfcb != pfcbNil );
	pfcbTable = pfucbTable->u.pfcb;

	Assert( pfcbTable->FTypeTable() );		// Temp. tables have fixed DDL.

	if ( pfcbTable->FFixedDDL() )
		{

//	UNDONE: Cannot currently permit DDL deletes even if PermitDDL flag is
//	specified because DDL deletes will leave RCE's that have to be cleaned
//	up and modify the FCB while doing so.  This will mess up cursors
//	opened normally after the PermitDDL cursor closes.
#ifdef PERMIT_DDL_DELETE
		// Check FixedDDL override.
		if ( !FFUCBPermitDDL( pfucbTable ) )
			{
			err = ErrERRCheck( JET_errFixedDDL );
			return err;
			}
			
		// If DDL temporarily permitted, we must have exclusive use of the table.
		Assert( pfcbTable->FDomainDenyReadByUs( ppib ) );
#else
		err = ErrERRCheck( JET_errFixedDDL );
		return err;
#endif			
		}

	Assert( pfcbTable->Ptdb() != ptdbNil );
	if ( pfcbTable->Ptdb()->PfcbTemplateTable() != pfcbNil
		&& FFILEITemplateTableIndex( pfcbTable->Ptdb()->PfcbTemplateTable(), szIndex ) )
		{
		err = ErrERRCheck( JET_errFixedInheritedDDL );
		return err;
		}
	
	//	create new cursor -- to leave user's cursor unmoved
	//
	CallR( ErrDIROpen( ppib, pfcbTable, &pfucb ) );

	Call( ErrDIRBeginTransaction( ppib, NO_GRBIT ) );
	fInTransaction = fTrue;

	//	remove index record from MSysIndexes, preventing other threads from
	//	trying to delete the same index.
	//
	Assert( rgfmp[ pfcbTable->Ifmp() ].Dbid() != dbidTemp );	// Don't currently support DDL operations on temp tables.
	Call( ErrCATDeleteTableIndex(
				ppib,
				pfcbTable->Ifmp(),
				pfcbTable->ObjidFDP(),
				szIndex,
				&pgnoIndexFDP ) );

	// Can't delete primary index.
	Assert( pfcbTable->PgnoFDP() != pgnoIndexFDP );

	// Find index's FCB in the table's index list.
	pfcbTable->EnterDDL();
	for ( pfcbIdx = pfcbTable->PfcbNextIndex(); pfcbIdx != pfcbNil; pfcbIdx = pfcbIdx->PfcbNextIndex() )
		{
		Assert( pfcbIdx->Pidb() != pidbNil );
		if ( pfcbIdx->PgnoFDP() == pgnoIndexFDP )
			{
#ifdef DEBUG
			// Verify no one else is deleting this index (if so, conflict would
			// have been detected when updating catalog above).
			Assert( !pfcbIdx->FDeletePending() );
			Assert( !pfcbIdx->FDeleteCommitted() );
			Assert( !pfcbIdx->Pidb()->FDeleted() );
			
			// verify that no other FCB has the same FDP -- would never happen
			// because the FCB is deallocated before the space is freed.
			FCB	*pfcbT;
			for ( pfcbT = pfcbIdx->PfcbNextIndex(); pfcbT != pfcbNil; pfcbT = pfcbT->PfcbNextIndex() )
				{
				Assert( pfcbT->PgnoFDP() != pgnoIndexFDP );
				}
#endif
			break;
			}
		}
	pfcbTable->AssertDDL();

	if ( pfcbIdx == pfcbNil )
		{
		Assert( fFalse );		// If index in catalog, FCB must exist.
		pfcbTable->LeaveDDL();
		err = ErrERRCheck( JET_errIndexNotFound );
		goto HandleError;
		}

	Assert( !pfcbIdx->FTemplateIndex() );
	Assert( !pfcbIdx->FDerivedIndex() );
	Assert( pfcbIdx->PfcbTable() == pfcbTable );
		
	err = pfcbIdx->ErrSetDeleteIndex( ppib );
	pfcbTable->LeaveDDL();
	Call( err );
		
	// Assert not deleting current secondary index.
	if ( pfucb->pfucbCurIndex != pfucbNil )
		{
		Assert( pfucb->pfucbCurIndex->u.pfcb != pfcbNil );
		Assert( pfucb->pfucbCurIndex->u.pfcb->PfcbTable() == pfcbTable );
		Assert( pfucb->pfucbCurIndex->u.pfcb->Pidb() != pidbNil );
		Assert( pfucb->pfucbCurIndex->u.pfcb->Pidb()->CrefCurrentIndex() > 0
			|| pfucb->pfucbCurIndex->u.pfcb->Pidb()->FTemplateIndex() );
		Assert( pgnoIndexFDP != pfucb->pfucbCurIndex->u.pfcb->PgnoFDP() );
		}
		
	pver = PverFromIfmp( pfucb->ifmp );
	err = pver->ErrVERFlag( pfucb, operDeleteIndex, &pfcbIdx, sizeof(pfcbIdx) );
	if ( err < 0 )
		{
		pfcbIdx->ResetDeleteIndex();
		goto HandleError;
		}

	// Ensure consistent view of table's space tree (to prevent doubly-freed space).
	Assert( pfcbIdx->PfcbTable() == pfcbTable );
	Assert( pfcbIdx->FDeletePending() );
	Assert( !pfcbIdx->FDeleteCommitted() );
//	Call( ErrDIRDeleteDirectory( pfucb, pfcbIdx->PgnoFDP() ) );

	Call( ErrDIRCommitTransaction( ppib, 0 ) );
	fInTransaction = fFalse;

	//	set currency to before first
	//
	DIRBeforeFirst( pfucb );
	CallS( err );

HandleError:
	if ( fInTransaction )
		CallSx( ErrDIRRollback( ppib ), JET_errRollbackError );
		
	DIRClose( pfucb );
	AssertDIRNoLatch( ppib );
	return err;
	}


// Ensures the column doesn't belong to any non-deleted indexes, or indexes
// version-deleted by someone else (because the delete may roll back).
BOOL FFILEIsIndexColumn( PIB *ppib, FCB *pfcbTable, const COLUMNID columnid )
	{
	FCB*			pfcbIndex;
	ULONG			iidxseg;
	const IDXSEG*	rgidxseg;

	Assert( pfcbNil != pfcbTable );
	for ( pfcbIndex = pfcbTable; pfcbIndex != pfcbNil; pfcbIndex = pfcbIndex->PfcbNextIndex() )
		{
		const IDB * const pidb = pfcbIndex->Pidb();
		if ( pidbNil == pidb )
			{
			Assert( pfcbIndex == pfcbTable );	// Only sequential index has no IDB
			continue;
			}

		if ( pidb->FDeleted() )
			{
			if ( pidb->FVersioned() )
				{
				// The cursor that deletes the index will set DomainDenyRead
				// on the FCB.  If it's us, we can bypass the index check (because
				// this operation will only commit if the DeleteIndex commits),
				// otherwise we can't (because the DeleteIndex may roll back).
				Assert( pfcbIndex->FDomainDenyRead( ppib )
					|| pfcbIndex->FDomainDenyReadByUs( ppib ) );
				if ( pfcbIndex->FDomainDenyReadByUs( ppib ) )
					{
					continue;
					}
				}
			else
				{
				// Index is unversioned deleted, meaning the delete has committed
				// or we have exclusive use of the table and we deleted the index.
				// In either case, we can bypass the index check.
				continue;
				}
			}
			
		rgidxseg = PidxsegIDBGetIdxSeg( pidb, pfcbTable->Ptdb() );
		for ( iidxseg = 0; iidxseg < pidb->Cidxseg(); iidxseg++ )
			{
			if ( rgidxseg[iidxseg].FIsEqual( columnid ) )
				{
				//	found the column in an index
				//
				return fTrue;
				}
			}

		rgidxseg = PidxsegIDBGetIdxSegConditional( pidb, pfcbTable->Ptdb() );
		for ( iidxseg = 0; iidxseg < pidb->CidxsegConditional(); iidxseg++ )
			{
			if ( rgidxseg[iidxseg].FIsEqual( columnid ) )
				{
				//	column is used for a condition
				//
				return fTrue;
				}
			}
		}
	return fFalse;
	}



ERR VTAPI ErrIsamDeleteColumn(
	JET_SESID		sesid,
	JET_VTID		vtid,
	const CHAR		*szName,
	const JET_GRBIT	grbit )
	{
 	PIB 			*ppib = reinterpret_cast<PIB *>( sesid );
	FUCB			*pfucb = reinterpret_cast<FUCB *>( vtid );
	ERR				err;
	CHAR			szColumn[ (JET_cbNameMost + 1) ];
	FCB				*pfcb;
	TDB				*ptdb;
	COLUMNID		columnidColToDelete;
	FIELD			*pfield;
	BOOL			fIndexColumn;
#ifdef DELETE_SLV_COLS	
#else // DELETE_SLV_COLS	
	BOOL			fSLVColumn;
#endif // DELETE_SLV_COLS	
	VER				*pver;

	CallR( ErrPIBCheck( ppib ) );
	CheckTable( ppib, pfucb );
	CallR( ErrUTILCheckName( szColumn, szName, (JET_cbNameMost + 1) ) );

	//	ensure that table is updatable
	//
	CallR( ErrFUCBCheckUpdatable( pfucb ) );
	CallR( ErrPIBCheckUpdatable( ppib ) );

	Assert( ppib != ppibNil );
	Assert( pfucb != pfucbNil );
	Assert( pfucb->u.pfcb != pfcbNil );
	pfcb = pfucb->u.pfcb;
	Assert( pfcb->WRefCount() > 0 );
	Assert( pfcb->FTypeTable() );		// Temp. tables have fixed DDL.
	Assert( pfcb->FPrimaryIndex() );

	if ( pfcb->FFixedDDL() )
		{
//	UNDONE: Cannot currently permit DDL deletes even if PermitDDL flag is
//	specified because DDL deletes will leave RCE's that have to be cleaned
//	up and modify the FCB while doing so.  This will mess up cursors
//	opened normally after the PermitDDL cursor closes.
#ifdef PERMIT_DDL_DELETE
		// Check FixedDDL override.
		if ( !FFUCBPermitDDL( pfucb ) )
			{
			err = ErrERRCheck( JET_errFixedDDL );
			return err;
			}
			
		// If DDL temporarily permitted, we must have exclusive use of the table.
		Assert( pfcb->FDomainDenyReadByUs( ppib ) );
#else
		err = ErrERRCheck( JET_errFixedDDL );
		return err;
#endif		
		}

	if ( pfcb->Ptdb()->PfcbTemplateTable() != pfcbNil 
		&& !( grbit & JET_bitDeleteColumnIgnoreTemplateColumns )
		&& FFILEITemplateTableColumn( pfcb->Ptdb()->PfcbTemplateTable(), szColumn ) )
		{
		return ErrERRCheck( JET_errFixedInheritedDDL );
		}
	

	CallR( ErrDIRBeginTransaction( ppib, NO_GRBIT ) );

	// Flag-delete in the catalog.
	// Also has the effect of properly reconciling concurrent
	// CreateIndexes over this column.
	Call( ErrCATDeleteTableColumn(
				ppib,
				pfcb->Ifmp(),
				pfcb->ObjidFDP(),
				szColumn,
				&columnidColToDelete ) );

#ifdef PERMIT_DDL_DELETE
	if ( pfcb->FTemplateTable() )
		{
		Assert( !COLUMNIDTemplateColumn( columnidColToDelete ) );	//	Template flag is not persisted
		COLUMNIDSetFTemplateColumn( columnidColToDelete );
		}
#endif		
	
	// Search for column in use.  For indexes being concurrently created,
	// conflict would have been detected by catalog update above.
	pfcb->EnterDML();
	fIndexColumn = FFILEIsIndexColumn( ppib, pfcb, columnidColToDelete );
#ifdef DELETE_SLV_COLS
#else // DELETE_SLV_COLS
	fSLVColumn = ( JET_coltypSLV == pfcb->Ptdb()->Pfield( columnidColToDelete )->coltyp );
#endif // DELETE_SLV_COLS	
	pfcb->LeaveDML();

	if ( fIndexColumn )
		{
		err = ErrERRCheck( JET_errColumnInUse );
		goto HandleError;
		}
#ifdef DELETE_SLV_COLS
#else // DELETE_SLV_COLS
	else if ( fSLVColumn )
		{
		err = ErrERRCheck( JET_errSLVColumnCannotDelete );
		goto HandleError;
		}
#endif // DELETE_SLV_COLS	

	pver = PverFromIfmp( pfucb->ifmp );
	Call( pver->ErrVERFlag( pfucb, operDeleteColumn, (VOID *)&columnidColToDelete, sizeof(COLUMNID) ) );

	pfcb->EnterDDL();

	ptdb = pfcb->Ptdb();
	pfield = ptdb->Pfield( columnidColToDelete );

	// If we have the table exclusively locked, then there's no need to
	// set the Versioned bit.
	Assert( !pfcb->FDomainDenyRead( ppib ) );
	if ( !pfcb->FDomainDenyReadByUs( ppib ) )
		{
		FIELDSetVersioned( pfield->ffield );
		}
	FIELDSetDeleted( pfield->ffield );

	pfcb->LeaveDDL();

	//	move to FDP root, then set currencies to BeforeFirst and remove unused CSR
	DIRGotoRoot( pfucb );
	Assert( Pcsr( pfucb ) != pcsrNil );
	DIRBeforeFirst( pfucb );
	if ( pfucb->pfucbCurIndex != pfucbNil )
		{
		DIRBeforeFirst( pfucb->pfucbCurIndex );
		}

	Call( ErrDIRCommitTransaction( ppib, 0 ) );

	return JET_errSuccess;

HandleError:
	CallSx( ErrDIRRollback( ppib ), JET_errRollbackError );

	return err;
	}


//  ================================================================
ERR VTAPI ErrIsamRenameTable( JET_SESID sesid, JET_DBID dbid, const CHAR *szName, const CHAR *szNameNew )
//  ================================================================
//
//  WARNINGS:
//    This doesn't version the name properly. Its instantly visible in the TDB, but versioned in the catalog
//    You can't rename a template table (derived tables are not updated).
//
//
	{
	ERR 	err;
 	PIB 	* const ppib = reinterpret_cast<PIB *>( sesid );
 	IFMP	ifmp = (IFMP) dbid;
	
	CallR( ErrPIBCheck( ppib ) );
	CallR( ErrPIBCheckUpdatable( ppib ) );
	CallR( ErrDBCheckUserDbid( ifmp ) );
	CallR( ErrPIBCheckIfmp( ppib, ifmp ) );

	if( NULL == szName )
		{
		return ErrERRCheck( JET_errInvalidParameter );
		}

	if( NULL == szNameNew )
		{
		return ErrERRCheck( JET_errInvalidParameter );
		}
		
	CHAR	szTableOld[JET_cbNameMost+1];
	CHAR	szTableNew[JET_cbNameMost+1];

	CallR( ErrUTILCheckName( szTableOld, szName, JET_cbNameMost+1 ) );
	CallR( ErrUTILCheckName( szTableNew, szNameNew, JET_cbNameMost+1 ) );

	CallR( ErrCATRenameTable( ppib, ifmp, szTableOld, szTableNew ) );
	
	return err;
	}


ERR VTAPI ErrIsamRenameObject( JET_SESID vsesid, JET_DBID	vdbid, const CHAR *szName, const CHAR  *szNameNew )
	{
	Assert( fFalse );
	return JET_errSuccess;
	}


//  ================================================================
ERR VTAPI ErrIsamRenameColumn(
	JET_SESID		vsesid,
	JET_VTID		vtid,
	const CHAR		*szName,
	const CHAR		*szNameNew,
	const JET_GRBIT	grbit )
//  ================================================================
//
//  WARNINGS:
//    This doesn't version the name properly. Its instantly visible in the FIELD, but versioned in the catalog
//    You can't rename an inherited column.
//
//
	{
	ERR 	err;
 	PIB 	* const ppib	= reinterpret_cast<PIB *>( vsesid );
	FUCB	* const pfucb	= reinterpret_cast<FUCB *>( vtid );
		
	CallR( ErrPIBCheck( ppib ) );
	CallR( ErrPIBCheckUpdatable( ppib ) );
	CheckTable( ppib, pfucb );

	if( NULL == szName )
		{
		return ErrERRCheck( JET_errInvalidParameter );
		}

	if( NULL == szNameNew )
		{
		return ErrERRCheck( JET_errInvalidParameter );
		}

	if( 0 != ppib->level )
		{
		return ErrERRCheck( JET_errInTransaction );
		}
		
	CHAR	szColumnOld[JET_cbNameMost+1];
	CHAR	szColumnNew[JET_cbNameMost+1];

	CallR( ErrUTILCheckName( szColumnOld, szName, JET_cbNameMost+1 ) );
	CallR( ErrUTILCheckName( szColumnNew, szNameNew, JET_cbNameMost+1 ) );

	CallR( ErrCATRenameColumn( ppib, pfucb, szColumnOld, szColumnNew, grbit ) );
	
	return err;
	}


ERR VTAPI ErrIsamRenameIndex( JET_SESID vsesid, JET_VTID vtid, const CHAR *szName, const CHAR *szNameNew )
	{
	Assert( fFalse );
	return JET_errSuccess;
	}


VOID IDB::SetFlagsFromGrbit( const JET_GRBIT grbit )
	{
	const BOOL	fPrimary			= ( grbit & JET_bitIndexPrimary );
	const BOOL	fUnique				= ( grbit & JET_bitIndexUnique );
	const BOOL	fDisallowNull		= ( grbit & JET_bitIndexDisallowNull );
	const BOOL	fIgnoreNull			= ( grbit & JET_bitIndexIgnoreNull );
	const BOOL	fIgnoreAnyNull		= ( grbit & JET_bitIndexIgnoreAnyNull );
	const BOOL	fIgnoreFirstNull	= ( grbit & JET_bitIndexIgnoreFirstNull );
	const BOOL	fSortNullsHigh		= ( grbit & JET_bitIndexSortNullsHigh );

	ResetFlags();

	if ( !fDisallowNull && !fIgnoreAnyNull )
		{	   	
		SetFAllowSomeNulls();
		if ( !fIgnoreFirstNull )
			{
			SetFAllowFirstNull();
			if ( !fIgnoreNull )
				SetFAllowAllNulls();
			}
		}

	if ( fPrimary )
		{
		SetFUnique();
		SetFPrimary();
		}
	else if ( fUnique )
		{
		SetFUnique();
		}
		
	if ( fDisallowNull )
		{
		SetFNoNullSeg();
		}
	else if ( fSortNullsHigh )
		{
		SetFSortNullsHigh();
		}
	}

JET_GRBIT IDB::GrbitFromFlags() const
	{
	JET_GRBIT	grbit = 0;

	if ( FPrimary() )
		grbit |= JET_bitIndexPrimary;
	if ( FUnique() )
		grbit |= JET_bitIndexUnique;
	if ( FNoNullSeg() )
		grbit |= JET_bitIndexDisallowNull;
	else
		{
		if ( !FAllowAllNulls() )
			grbit |= JET_bitIndexIgnoreNull;
		if ( !FAllowFirstNull() )				
			grbit |= JET_bitIndexIgnoreFirstNull;
		if ( !FAllowSomeNulls() )
			grbit |= JET_bitIndexIgnoreAnyNull;
		if ( FSortNullsHigh() )
			grbit |= JET_bitIndexSortNullsHigh;
		}

	return grbit;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ese98\src\ese\fldext.cxx ===
#include "std.hxx"

extern BOOL	g_fSortedRetrieveColumns;


INLINE ERR ErrRECIGetRecord(
	FUCB	*pfucb,
	DATA	**ppdataRec,
	BOOL	fUseCopyBuffer )
	{
	ERR		err = JET_errSuccess;

	Assert( ppdataRec );
	Assert( FFUCBSort( pfucb ) || FFUCBIndex( pfucb ) );

	//	retrieving from copy buffer?
	//
	if ( fUseCopyBuffer )
		{
		//	only index cursors have copy buffers.
		//
		Assert( FFUCBIndex( pfucb ) );
		Assert( !Pcsr( pfucb )->FLatched() );
		*ppdataRec = &pfucb->dataWorkBuf;
		}
	else
		{
		if ( FFUCBIndex( pfucb ) )
			{
			err = ErrDIRGet( pfucb );
			}
		else
			{
			//	sorts always have current data cached.
			Assert( pfucb->locLogical == locOnCurBM
				|| pfucb->locLogical == locBeforeFirst
				|| pfucb->locLogical == locAfterLast );
			if ( pfucb->locLogical != locOnCurBM )
				{
				err = ErrERRCheck( JET_errNoCurrentRecord );
				}
			else
				{
				Assert( pfucb->kdfCurr.data.Cb() != 0 );
				}
			}

		*ppdataRec = &pfucb->kdfCurr.data;
		}
		
	return err;
	}

ERR ErrRECIAccessColumn( FUCB *pfucb, COLUMNID columnid, FIELD * const pfieldFixed )
	{
	ERR 		err		= JET_errSuccess;
	PIB *		ppib	= pfucb->ppib;
	FCB *		pfcb	= pfucb->u.pfcb;
	TDB *		ptdb	= pfcb->Ptdb();
	const FID	fid		= FidOfColumnid( columnid );

	Assert( 0 != columnid );
	if ( !FCOLUMNIDValid( columnid ) )
		{
		return ErrERRCheck( JET_errBadColumnId );
		}

	if ( FCOLUMNIDTemplateColumn( columnid ) )
		{
		if ( pfcb->FTemplateTable() )
			{
			ptdb->AssertValidTemplateTable();
			}
		else if ( pfcbNil != ptdb->PfcbTemplateTable() )
			{
			ptdb->AssertValidDerivedTable();
			ptdb = ptdb->PfcbTemplateTable()->Ptdb();
			}
		else
			{
			return ErrERRCheck( JET_errColumnNotFound );
			}

		BOOL	fCopyField	= fFalse;
		FID		fidLast;

		if ( FTaggedFid( fid ) )
			{
			fidLast = ptdb->FidTaggedLast();
			}
		else if ( FFixedFid( fid ) )
			{
			fidLast = ptdb->FidFixedLast();
			if ( pfieldNil != pfieldFixed )
				fCopyField = fTrue;
			}
		else
			{
			Assert( FVarFid( fid ) );
			fidLast = ptdb->FidVarLast();
			}

		Assert( JET_errSuccess == err );
		if ( fid > fidLast )
			{
			err = ErrERRCheck( JET_errColumnNotFound );
			}
		else
			{
#ifdef DEBUG
			const FIELD * const	pfieldT	= ptdb->Pfield( columnid );
			Assert( JET_coltypNil != pfieldT->coltyp );
			Assert( !FFIELDVersioned( pfieldT->ffield ) );
			Assert( !FFIELDDeleted( pfieldT->ffield ) );
#endif
			CallS( err );
			if ( fCopyField )
				*pfieldFixed = *( ptdb->PfieldFixed( columnid ) );
			}

		return err;
		}

	else if ( pfcb->FTemplateTable() )
		{
		return ErrERRCheck( JET_errColumnNotFound );
		}


	BOOL		fUseDMLLatch	= fFalse;
	FIELDFLAG	ffield;

	if ( FTaggedFid( fid ) )
		{
		if ( fid > ptdb->FidTaggedLastInitial() )
			{
			pfcb->EnterDML();
			if ( fid > ptdb->FidTaggedLast() )
				{
				pfcb->LeaveDML();
				return ErrERRCheck( JET_errColumnNotFound );
				}
			fUseDMLLatch = fTrue;
			}

		ffield = ptdb->PfieldTagged( columnid )->ffield;
		}
	else if ( FFixedFid( fid ) )
		{
		if ( fid > ptdb->FidFixedLastInitial() )
			{
			pfcb->EnterDML();
			if ( fid > ptdb->FidFixedLast() )
				{
				pfcb->LeaveDML();
				return ErrERRCheck( JET_errColumnNotFound );
				}
			fUseDMLLatch = fTrue;
			}

		FIELD * const	pfieldT		= ptdb->PfieldFixed( columnid );
		if ( pfieldNil != pfieldFixed )
			{
			*pfieldFixed = *pfieldT;

			//	use the snapshotted FIELD, because the real one
			//	could be being modified
			ffield = pfieldFixed->ffield;
			}
		else
			{
			ffield = pfieldT->ffield;
			}
		}
	else
		{
		Assert( FVarFid( fid ) );

		if ( fid > ptdb->FidVarLastInitial() )
			{
			pfcb->EnterDML();
			if ( fid > ptdb->FidVarLast() )
				{
				pfcb->LeaveDML();
				return ErrERRCheck( JET_errColumnNotFound );
				}
			fUseDMLLatch = fTrue;
			}

		ffield = ptdb->PfieldVar( columnid )->ffield;
		}

	if ( fUseDMLLatch )
		pfcb->AssertDML();

	//	check if the FIELD has been versioned or deleted
	//	(note that we took only a snapshot of the flags
	//	above, so by now the FIELD may be different), 
	if ( FFIELDVersioned( ffield ) )
		{
		Assert( !pfcb->FFixedDDL() );
		Assert( !pfcb->FTemplateTable() );

		if ( fUseDMLLatch )
			pfcb->LeaveDML();

		const BOOL	fLatchHeld	= Pcsr( pfucb )->FLatched();
		if ( fLatchHeld )
			{
			// UNDONE:  Move latching logic to caller.
			CallS( ErrDIRRelease( pfucb ) );
			}

		// Inherited columns are never versioned.
		Assert( !FCOLUMNIDTemplateColumn( columnid ) );
			
		err = ErrCATAccessTableColumn(
					ppib,
					pfcb->Ifmp(),
					pfcb->ObjidFDP(),
					NULL,
					&columnid );
		Assert( err <= 0 );		// No warning should be generated.
		
		if ( fLatchHeld )
			{
			ERR	errT = ErrDIRGet( pfucb );
			if ( errT < 0 )
				{
				//	if error encountered while re-latching record, return the error
				//	only if no unexpected errors from catalog consultation.
				if ( err >= 0 || JET_errColumnNotFound == err )
					err = errT;
				}
			}
		}
		
	else
		{
		if ( FFIELDDeleted( ffield ) )
			{
			//	may get deleted columns in FixedDDL tables if an AddColumn() in those
			//	tables rolled back
//			Assert( !pfcb->FFixedDDL() );
//			Assert( !FCOLUMNIDTemplateColumn( columnid ) );
			err = ErrERRCheck( JET_errColumnNotFound );
			}

		if ( fUseDMLLatch )
			pfcb->LeaveDML();
		}

	return err;
	}

ERR ErrRECIRetrieveFixedColumn(
	FCB				* const pfcb,		// pass pfcbNil to bypass EnterDML()
	const TDB		*ptdb,
	const COLUMNID	columnid,
	const DATA&		dataRec,
	DATA			* pdataField,
	const FIELD		* const pfieldFixed )
	{
	ERR				err;
	const FID		fid		= FidOfColumnid( columnid );
	
	Assert( ptdb != ptdbNil );
	Assert( pfcbNil == pfcb || pfcb->Ptdb() == ptdb );
	Assert( FCOLUMNIDFixed( columnid ) );
	Assert( !dataRec.FNull() );
	Assert( dataRec.Cb() >= REC::cbRecordMin );
	Assert( dataRec.Cb() <= REC::CbRecordMax() );
	Assert( pdataField != NULL );
	
	const REC	*prec = (REC *)dataRec.Pv();
	
	Assert( prec->FidFixedLastInRec() >= fidFixedLeast-1 );
	Assert( prec->FidFixedLastInRec() <= fidFixedMost );

#ifdef DEBUG
	const BOOL	fUseDMLLatchDBG		= ( pfcbNil != pfcb && fid > ptdb->FidFixedLastInitial() );
#else
	const BOOL	fUseDMLLatchDBG		= fFalse;
#endif

	if ( fUseDMLLatchDBG )
		pfcb->EnterDML();

	// RECIAccessColumn() should have already been called to verify FID.
	Assert( fid <= ptdb->FidFixedLast() );
	Assert( pfieldNil != ptdb->PfieldFixed( columnid ) );
	Assert( JET_coltypNil != ptdb->PfieldFixed( columnid )->coltyp );
	Assert( ptdb->PfieldFixed( columnid )->ibRecordOffset >= ibRECStartFixedColumns );
	Assert( ptdb->PfieldFixed( columnid )->ibRecordOffset < ptdb->IbEndFixedColumns() );
	Assert( !FFIELDUserDefinedDefault( ptdb->PfieldFixed( columnid )->ffield ) );

	// Don't forget to LeaveDML() before exitting this function.

	//	column not represented in record, retrieve from default
	//	or null column.
	//
	if ( fid > prec->FidFixedLastInRec() )
		{
		// if DEBUG, then EnterDML() was already done at the top of this function
		const BOOL	fUseDMLLatch	= ( !fUseDMLLatchDBG
										&& pfcbNil != pfcb
										&& fid > ptdb->FidFixedLastInitial() );
		
		if ( fUseDMLLatch )
			pfcb->EnterDML();

		//	assert no infinite recursion
		Assert( dataRec.Pv() != ptdb->PdataDefaultRecord() );
		
		//	if default value set, then retrieve default
		//
		if ( FFIELDDefault( ptdb->PfieldFixed( columnid )->ffield ) )
			{
			err = ErrRECIRetrieveFixedDefaultValue( ptdb, columnid, pdataField );
			}
		else
			{
			pdataField->Nullify();
			err = ErrERRCheck( JET_wrnColumnNull );
			}

		if ( fUseDMLLatch || fUseDMLLatchDBG )
			pfcb->LeaveDML();

		return err;
		}

	Assert( prec->FidFixedLastInRec() >= fidFixedLeast );
	Assert( ptdb->PfieldFixed( columnid )->ibRecordOffset < prec->IbEndOfFixedData() );
	
	// check nullity

	const UINT	ifid			= fid - fidFixedLeast;
	const BYTE	*prgbitNullity	= prec->PbFixedNullBitMap() + ifid/8;

	//	bit is not set: column is NULL
	//
	if ( FFixedNullBit( prgbitNullity, ifid ) )
		{
		pdataField->Nullify();
		err = ErrERRCheck( JET_wrnColumnNull );

		}
	else
		{
		// if DEBUG, then EnterDML() was already done at the top of this function
		const BOOL	fUseDMLLatch	= ( !fUseDMLLatchDBG
										&& pfcbNil != pfcb
										&& pfieldNil == pfieldFixed
										&& fid > ptdb->FidFixedLastInitial() );

		if ( fUseDMLLatch )
			pfcb->EnterDML();

		//	set output parameter to length and address of column
		//
		const FIELD	* const pfield = ( pfieldNil != pfieldFixed ? pfieldFixed : ptdb->PfieldFixed( columnid ) );
		Assert( pfield->cbMaxLen == UlCATColumnSize( pfield->coltyp, pfield->cbMaxLen, NULL ) );
		pdataField->SetCb( pfield->cbMaxLen );
		pdataField->SetPv( (BYTE *)prec + pfield->ibRecordOffset );

		if ( fUseDMLLatch )
			pfcb->LeaveDML();

		err = JET_errSuccess;
		}
		

	if ( fUseDMLLatchDBG )
		pfcb->LeaveDML();
		
	return err;
	}


ERR ErrRECIRetrieveVarColumn(
	FCB				* const pfcb,		// pass pfcbNil to bypass EnterDML()
	const TDB		* ptdb,
	const COLUMNID	columnid,
	const DATA&		dataRec,
	DATA			* pdataField )
	{
	const FID		fid			= FidOfColumnid( columnid );

	Assert( ptdbNil != ptdb );
	Assert( pfcbNil == pfcb || pfcb->Ptdb() == ptdb );
	Assert( FCOLUMNIDVar( columnid ) );
	Assert( !dataRec.FNull() );
	Assert( dataRec.Cb() >= REC::cbRecordMin );
	Assert( dataRec.Cb() <= REC::CbRecordMax() );
	Assert( pdataField != NULL );
	
	const REC	*prec = (REC *)dataRec.Pv();
	
	Assert( prec->FidVarLastInRec() >= fidVarLeast-1 );
	Assert( prec->FidVarLastInRec() <= fidVarMost );

#ifdef DEBUG
	const BOOL	fUseDMLLatchDBG		= ( pfcbNil != pfcb && fid > ptdb->FidVarLastInitial() );
#else
	const BOOL	fUseDMLLatchDBG		= fFalse;
#endif

	if ( fUseDMLLatchDBG )
		pfcb->EnterDML();

	// RECIAccessColumn() should have already been called to verify FID.
	Assert( fid <= ptdb->FidVarLast() );
	Assert( JET_coltypNil != ptdb->PfieldVar( columnid )->coltyp );
	Assert( !FFIELDUserDefinedDefault( ptdb->PfieldVar( columnid )->ffield ) );

	//	column not represented in record: column is NULL
	//
	if ( fid > prec->FidVarLastInRec() )
		{
		// if DEBUG, then EnterDML() was already done at the top of this function
		ERR			err;
		const BOOL	fUseDMLLatch	= ( !fUseDMLLatchDBG
										&& pfcbNil != pfcb
										&& fid > ptdb->FidVarLastInitial() );
		
		if ( fUseDMLLatch )
			pfcb->EnterDML();
		
		//	assert no infinite recursion
		Assert( dataRec.Pv() != ptdb->PdataDefaultRecord() );

		//	if default value set, then retrieve default
		//
		if ( FFIELDDefault( ptdb->PfieldVar( columnid )->ffield ) )
			{
			err = ErrRECIRetrieveVarDefaultValue( ptdb, columnid, pdataField );
			}
		else
			{
			pdataField->Nullify();
			err = ErrERRCheck( JET_wrnColumnNull );
			}

		if ( fUseDMLLatch || fUseDMLLatchDBG )
			pfcb->LeaveDML();

		return err;
		}

	if ( fUseDMLLatchDBG )
		pfcb->LeaveDML();

	Assert( prec->FidVarLastInRec() >= fidVarLeast );

	UnalignedLittleEndian<REC::VAROFFSET>	*pibVarOffs		= prec->PibVarOffsets();

	//	adjust fid to an index
	//
	const UINT				ifid			= fid - fidVarLeast;

	//	beginning of current column is end of previous column
	const REC::VAROFFSET	ibStartOfColumn	= prec->IbVarOffsetStart( fid );

	Assert( IbVarOffset( pibVarOffs[ifid] ) == prec->IbVarOffsetEnd( fid ) );
	Assert( IbVarOffset( pibVarOffs[ifid] ) >= ibStartOfColumn );
	
	//	column is set to Null
	//
	if ( FVarNullBit( pibVarOffs[ifid] ) )
		{
		Assert( IbVarOffset( pibVarOffs[ifid] ) - ibStartOfColumn == 0 );
		pdataField->Nullify();
		return ErrERRCheck( JET_wrnColumnNull );
		}

	pdataField->SetCb( IbVarOffset( pibVarOffs[ifid] ) - ibStartOfColumn );
	Assert( pdataField->Cb() < dataRec.Cb() );
	
	if ( pdataField->Cb() == 0 )
		{
		// length is zero: return success [zero-length non-null
		// values are allowed]
		pdataField->SetPv( NULL );
		}
	else
		{
		//	set output parameter: column address
		//
		BYTE	*pbVarData = prec->PbVarData();
		Assert( pbVarData + IbVarOffset( pibVarOffs[prec->FidVarLastInRec()-fidVarLeast] )
					<= (BYTE *)dataRec.Pv() + dataRec.Cb() );
		pdataField->SetPv( pbVarData + ibStartOfColumn );
		Assert( pdataField->Pv() >= (BYTE *)prec );
		Assert( pdataField->Pv() <= (BYTE *)prec + dataRec.Cb() );
		}
		
	return JET_errSuccess;
	}


ERR ErrRECIRetrieveTaggedColumn(
	FCB				* pfcb,
	const COLUMNID	columnid,
	const ULONG		itagSequence,
	const DATA&		dataRec,
	DATA			* const pdataRetrieveBuffer,
	const ULONG		grbit )
	{
	BOOL			fUseDerivedBit		= fFalse;
	Assert( !( grbit & grbitRetrieveColumnUseDerivedBit ) );	//	fDerived check is made below
	
	Assert( FCOLUMNIDTagged( columnid ) );
	Assert( itagSequence > 0 );
	Assert( !dataRec.FNull() );
	Assert( dataRec.Cb() >= REC::cbRecordMin );
	Assert( dataRec.Cb() <= REC::CbRecordMax() );
	Assert( NULL != pdataRetrieveBuffer );

	if ( FCOLUMNIDTemplateColumn( columnid ) )
		{
		if ( !pfcb->FTemplateTable() )
			{
			pfcb->Ptdb()->AssertValidDerivedTable();

			//	HACK: treat derived columns in original-format derived table as
			//	non-derived, because they don't have the fDerived bit set in the TAGFLD
			fUseDerivedBit = FRECUseDerivedBitForTemplateColumnInDerivedTable( columnid, pfcb->Ptdb() );

			// switch to template table
			pfcb = pfcb->Ptdb()->PfcbTemplateTable();
			}
		else
			{
			pfcb->Ptdb()->AssertValidTemplateTable();
			Assert( !fUseDerivedBit );
			}
		}
	else
		{
		Assert( !pfcb->FTemplateTable() );
		}

	TAGFIELDS	tagfields( dataRec );
	return tagfields.ErrRetrieveColumn(
				pfcb,
				columnid,
				itagSequence,
				dataRec,
				pdataRetrieveBuffer,
				grbit | ( fUseDerivedBit ? grbitRetrieveColumnUseDerivedBit : 0  ) );
	}

INLINE ULONG UlRECICountTaggedColumnInstances(
	FCB				* pfcb,
	const COLUMNID	columnid,
	const DATA&		dataRec )
	{
	BOOL			fUseDerivedBit		= fFalse;

	Assert( FCOLUMNIDTagged( columnid ) );
	Assert( !dataRec.FNull() );
	Assert( dataRec.Cb() >= REC::cbRecordMin );
	Assert( dataRec.Cb() <= REC::CbRecordMax() );

	if ( FCOLUMNIDTemplateColumn( columnid ) )
		{
		if ( !pfcb->FTemplateTable() )
			{
			pfcb->Ptdb()->AssertValidDerivedTable();

			//	HACK: treat derived columns in original-format derived table as
			//	non-derived, because they don't have the fDerived bit set in the TAGFLD
			fUseDerivedBit = FRECUseDerivedBitForTemplateColumnInDerivedTable( columnid, pfcb->Ptdb() );

			// switch to template table
			pfcb = pfcb->Ptdb()->PfcbTemplateTable();
			}
		else
			{
			pfcb->Ptdb()->AssertValidTemplateTable();
			Assert( !fUseDerivedBit );
			}
		}
	else
		{
		Assert( !pfcb->FTemplateTable() );
		}

	TAGFIELDS	tagfields( dataRec );
	return tagfields.UlColumnInstances(
				pfcb,
				columnid,
				fUseDerivedBit );
	}


ERR ErrRECIRetrieveSeparatedLongValue(
	FUCB		*pfucb,
	const DATA&	dataField,
	BOOL		fAfterImage,
	ULONG		ibLVOffset,
	VOID		*pv,
	ULONG		cbMax,
	ULONG		*pcbActual,
	JET_GRBIT 	grbit )
	{
	Assert( NULL != pv || 0 == cbMax );

	const LID	lid			= LidOfSeparatedLV( dataField );
	ERR			err;
	ULONG		cbActual;

	Assert( FFUCBIndex( pfucb ) );		// Sorts don't have separated LV's.

	if ( grbit & JET_bitRetrieveLongId )
		{
		Assert( ibLVOffset == 0 );
		if ( cbMax < sizeof(LID) )
			return ErrERRCheck( JET_errInvalidBufferSize );
			
		cbActual = sizeof(LID);
		UtilMemCpy( pv, (BYTE *)&lid, cbActual );
		err = ErrERRCheck( JET_wrnSeparateLongValue );
		}

	else
		{
		//	Must release any latch held.
		//
		if ( Pcsr( pfucb )->FLatched() )
			{
			CallS( ErrDIRRelease( pfucb ) );
			}
		AssertDIRNoLatch( pfucb->ppib );

		if ( grbit & JET_bitRetrieveLongValueRefCount )
			{
			Assert( 0 == ibLVOffset );
		
			Call( ErrRECRetrieveSLongFieldRefCount(
					pfucb,
					lid,
					reinterpret_cast<BYTE *>( pv ),
					cbMax,
			  		&cbActual ) );		  		
			err = ErrERRCheck( JET_wrnSeparateLongValue );
			}

		else
			{
			Call( ErrRECRetrieveSLongField( pfucb,
					lid,
					fAfterImage,
					ibLVOffset,
					reinterpret_cast<BYTE *>( pv ),
					cbMax,
			  		&cbActual ) );
			CallS( err );			// Don't expect any warnings.
		
			if ( cbActual > cbMax )
				err = ErrERRCheck( JET_wrnBufferTruncated );
			}
		}
		
	if ( pcbActual )
		*pcbActual = cbActual;

HandleError:
	return err;
	}


COLUMNID ColumnidRECFirstTaggedForScanOfDerivedTable( const TDB * const ptdb )
	{
	COLUMNID	columnidT;

	ptdb->AssertValidDerivedTable();
	const TDB	* ptdbTemplate	= ptdb->PfcbTemplateTable()->Ptdb();

	if ( ptdb->FESE97DerivedTable()
		&& 0 != ptdbTemplate->FidTaggedLastOfESE97Template() )
		{
		if ( ptdbTemplate->FidTaggedLast() > ptdbTemplate->FidTaggedLastOfESE97Template() )
			{
			//	HACK: scan starts with first ESE98 template column
			columnidT = ColumnidOfFid(
							FID( ptdbTemplate->FidTaggedLastOfESE97Template() + 1 ),
							fTrue );
			}
		else
			{
			//	no ESE98 template columns, go to first ESE97 template column (at least one
			//	must exist)
			Assert( ptdbTemplate->FidTaggedLast() >= ptdbTemplate->FidTaggedFirst() );
			columnidT = ColumnidOfFid( ptdbTemplate->FidTaggedFirst(), fTrue );
			}
		}
	else
		{
		//	since no ESE97 tagged columns in template, template and derived tables
		//	must both start numbering at same place
		Assert( ptdbTemplate->FidTaggedFirst() == ptdb->FidTaggedFirst() );
		if ( ptdbTemplate->FidTaggedLast() >= fidTaggedLeast )
			{
			columnidT = ColumnidOfFid( ptdbTemplate->FidTaggedFirst(), fTrue );
			}
		else
			{
			//	no template columns, go to derived columns
			columnidT = ColumnidOfFid( ptdb->FidTaggedFirst(), fFalse );
			}
		}

	return columnidT;
	}

COLUMNID ColumnidRECNextTaggedForScanOfDerivedTable( const TDB * const ptdb, const COLUMNID columnid )
	{
	COLUMNID	columnidT	= columnid + 1;

	Assert( FCOLUMNIDTemplateColumn( columnidT ) );
	
	ptdb->AssertValidDerivedTable();
	const TDB	* const ptdbTemplate	= ptdb->PfcbTemplateTable()->Ptdb();
	
	Assert( FidOfColumnid( columnid ) <= ptdbTemplate->FidTaggedLast() );
	if ( ptdb->FESE97DerivedTable()
		&& 0 != ptdbTemplate->FidTaggedLastOfESE97Template() )
		{
		Assert( ptdbTemplate->FidTaggedLastOfESE97Template() <= ptdbTemplate->FidTaggedLast() );
		if ( FidOfColumnid( columnidT ) == ptdbTemplate->FidTaggedLastOfESE97Template() + 1 )
			{
			Assert( ptdbTemplate->FidTaggedLastOfESE97Template() + 1 == ptdb->FidTaggedFirst() );
			columnidT = ColumnidOfFid( ptdb->FidTaggedFirst(), fFalse );
			}
		else if ( FidOfColumnid( columnidT ) > ptdbTemplate->FidTaggedLast() )
			{
			//	move to ESE97 template column space (at least one must exist)
			Assert( ptdbTemplate->FidTaggedLast() >= ptdbTemplate->FidTaggedFirst() );
			columnidT = ColumnidOfFid( ptdbTemplate->FidTaggedFirst(), fTrue );
			}
		else
			{
			//	still in template table column space, so do nothing special
			}
		}
	else if ( FidOfColumnid( columnidT ) > ptdbTemplate->FidTaggedLast() )
		{
		//	move to derived table column space
		columnidT = ColumnidOfFid( ptdb->FidTaggedFirst(), fFalse );
		}
	else
		{
		//	still in template table column space, so do nothing special
		}

	return columnidT;
	}


LOCAL ERR ErrRECIScanTaggedColumns(
			FUCB            *pfucb,
			const ULONG     itagSequence,
			const DATA&     dataRec,
			DATA            *pdataField,
			COLUMNID        *pcolumnidRetrieved,
			ULONG           *pitagSequenceRetrieved,
			JET_GRBIT       grbit )
	{
	TAGFIELDS tagfields( dataRec );
	return tagfields.ErrScan(
				pfucb,
				itagSequence,
				dataRec,
				pdataField,
				pcolumnidRetrieved,
				pitagSequenceRetrieved,
				grbit );
	}

	
JET_COLTYP ColtypFromColumnid( FUCB *pfucb, const COLUMNID columnid )
	{
	FCB			*pfcbTable;
	TDB			*ptdb;
	FIELD		*pfield;
	JET_COLTYP	coltyp;

	pfcbTable = pfucb->u.pfcb;
	ptdb = pfcbTable->Ptdb();
	
	pfcbTable->EnterDML();
	
	if ( FCOLUMNIDTagged( columnid ) )
		{
		pfield = ptdb->PfieldTagged( columnid );
		}
	else if ( FCOLUMNIDFixed( columnid ) )
		{
		pfield = ptdb->PfieldFixed( columnid );
		Assert( !FRECLongValue( pfield->coltyp ) );
		}
	else
		{
		Assert( FCOLUMNIDVar( columnid ) );
		pfield = ptdb->PfieldVar( columnid );
		Assert( !FRECLongValue( pfield->coltyp ) );
		}
		
	coltyp = pfield->coltyp;
	
	pfcbTable->LeaveDML();
	
	return coltyp;
	}

LOCAL ERR ErrRECIRetrieveFromIndex(
	FUCB		*pfucb,
	COLUMNID	columnid,
	ULONG		*pitagSequence,
	BYTE		*pb,
	ULONG		cbMax,
	ULONG		*pcbActual,
	ULONG		ibGraphic,
	JET_GRBIT	grbit )
	{
	ERR			err;
	FUCB   		*pfucbIdx;
	FCB			*pfcbTable;
	TDB			*ptdb;
	IDB			*pidb;
	BOOL		fInitialIndex;
	BOOL		fDerivedIndex;
	BOOL		fLatched				= fFalse;
	BOOL   		fText					= fFalse;
	BOOL	   	fLongValue				= fFalse;
	BOOL		fBinaryChunks			= fFalse;
	BOOL		fSawMultiValued			= fFalse;
	BOOL		fFirstMultiValued		= fFalse;
	BOOL		fVarSegMac				= fFalse;
	INT			iidxseg;
	DATA   		dataColumn;
	BOOL		fRetrieveFromPrimaryBM;
	ULONG		cbKeyMost;
	BYTE   		rgb[JET_cbKeyMost];
	KEY			keyT;
	KEY			*pkey;
	FIELD		*pfield;
	const IDXSEG*	rgidxseg;

	Assert( NULL != pitagSequence );
	AssertDIRNoLatch( pfucb->ppib );

	//	caller checks for these grbits
	Assert( grbit & ( JET_bitRetrieveFromIndex|JET_bitRetrieveFromPrimaryBookmark ) );

	//	RetrieveFromIndex and RetrieveFromPrimaryBookmark are mutually exclusive
	if ( ( grbit & JET_bitRetrieveFromIndex )
		&& ( grbit & JET_bitRetrieveFromPrimaryBookmark ) )
		return ErrERRCheck( JET_errInvalidGrbit );
	
	if ( !FCOLUMNIDValid( columnid ) )
		return ErrERRCheck( JET_errBadColumnId );
		
	//	if on primary index, then return code indicating that
	//	retrieve should be from record.  Note, sequential files
	//	having no indexes, will be natually handled this way.
	//
	if ( pfucbNil == pfucb->pfucbCurIndex )
		{
		pfucbIdx = pfucb;
		
		Assert( pfcbNil != pfucb->u.pfcb );
		Assert( pfucb->u.pfcb->FTypeTable()
			|| pfucb->u.pfcb->FTypeTemporaryTable()
			|| pfucb->u.pfcb->FTypeSort() );

		Assert( ( pfucb->u.pfcb->FSequentialIndex() && pidbNil == pfucb->u.pfcb->Pidb() )
			|| ( !pfucb->u.pfcb->FSequentialIndex() && pidbNil != pfucb->u.pfcb->Pidb() ) );

		//	if currency is not locOnCurBM, we have to go to the record anyway,
		//		so it's pointless to continue
		//	for a sequential index, must go to the record
		//	for a sort, data is always cached anyway so just retrieve normally
		if ( locOnCurBM != pfucb->locLogical
			|| pfucb->u.pfcb->FSequentialIndex()
			|| FFUCBSort( pfucb ) )
			{
			//	can't have multi-valued column in a primary index,
			//	so itagSequence must be 1
			*pitagSequence = 1;
			return ErrERRCheck( errDIRNoShortCircuit );
			}

		Assert( pidbNil != pfucbIdx->u.pfcb->Pidb() );
		Assert( pfucbIdx->u.pfcb->Pidb()->FPrimary() );

		//	force RetrieveFromIndex, strip off RetrieveTag
		grbit = JET_bitRetrieveFromIndex;
		fRetrieveFromPrimaryBM = fFalse;
		cbKeyMost = JET_cbPrimaryKeyMost;
		}
	else
		{
		pfucbIdx = pfucb->pfucbCurIndex;
		Assert( pfucbIdx->u.pfcb->FTypeSecondaryIndex() );
		Assert( pidbNil != pfucbIdx->u.pfcb->Pidb() );
		Assert( !pfucbIdx->u.pfcb->Pidb()->FPrimary() );
		fRetrieveFromPrimaryBM = ( grbit & JET_bitRetrieveFromPrimaryBookmark );
		cbKeyMost = ( fRetrieveFromPrimaryBM ? JET_cbPrimaryKeyMost : JET_cbSecondaryKeyMost );
		}
	
	//	find index segment for given column id
	//
	pfcbTable = pfucb->u.pfcb;
	Assert( pfcbNil != pfcbTable );
	Assert( pfcbTable->Ptdb() != ptdbNil );

	if ( fRetrieveFromPrimaryBM )
		{
		Assert( !pfucbIdx->u.pfcb->Pidb()->FPrimary() );
		if ( pfcbTable->FSequentialIndex() )
			{
			//	no columns in a sequential index
			Assert( pidbNil == pfcbTable->Pidb() );
 			return ErrERRCheck( JET_errColumnNotFound );
			}
			
		pidb = pfcbTable->Pidb();
		Assert( pidbNil != pidb );

		fInitialIndex = pfcbTable->FInitialIndex();
		fDerivedIndex = pfcbTable->FDerivedIndex();
		}
	else
		{
		const FCB * const	pfcbIdx		= pfucbIdx->u.pfcb;

		pidb = pfcbIdx->Pidb();
		fInitialIndex = pfcbIdx->FInitialIndex();
		fDerivedIndex = pfcbIdx->FDerivedIndex();
		}

	if ( fDerivedIndex )
		{
		Assert( pidb->FTemplateIndex() );
		Assert( pfcbTable->Ptdb() != ptdbNil );
		pfcbTable = pfcbTable->Ptdb()->PfcbTemplateTable();
		Assert( pfcbNil != pfcbTable );
		Assert( pfcbTable->FTemplateTable() );
		Assert( pfcbTable->Ptdb() != ptdbNil );
		}
	
	ptdb = pfcbTable->Ptdb();

	const BOOL		fUseDMLLatch	= ( !fInitialIndex
										|| pidb->FIsRgidxsegInMempool() );

	if ( fUseDMLLatch )
		pfcbTable->EnterDML();

	rgidxseg = PidxsegIDBGetIdxSeg( pidb, ptdb );
	for ( iidxseg = 0; iidxseg < pidb->Cidxseg(); iidxseg++ )
		{
		const COLUMNID	columnidT	= rgidxseg[iidxseg].Columnid();
		if ( columnidT == columnid )
			{
			break;
			}
		else if ( pidb->FMultivalued()
			&& !fSawMultiValued
			&& FCOLUMNIDTagged( columnidT ) )
			{
			pfield = ptdb->PfieldTagged( columnidT );
			fSawMultiValued = FFIELDMultivalued( pfield->ffield );
			}
		}
	Assert( iidxseg <= pidb->Cidxseg() );
	if ( iidxseg == pidb->Cidxseg() )
		{
		if ( fUseDMLLatch )
			pfcbTable->LeaveDML();
		return ErrERRCheck( JET_errColumnNotFound );
		}

	if ( pidb->FTuples() )
		{
		if ( fUseDMLLatch )
			pfcbTable->LeaveDML();
		return ErrERRCheck( JET_errIndexTuplesCannotRetrieveFromIndex );
		}

	Assert( pidb->CbVarSegMac() > 0 );
	Assert( pidb->CbVarSegMac() <= cbKeyMost );
	fVarSegMac = ( pidb->CbVarSegMac() < cbKeyMost );

	// Since the column belongs to an active index, we are guaranteed
	// that the column is accessible.
	if ( FCOLUMNIDTagged( columnid ) )
		{
		pfield = ptdb->PfieldTagged( columnid );
		fLongValue = FRECLongValue( pfield->coltyp );
		fBinaryChunks = FRECBinaryColumn( pfield->coltyp );

		Assert( !FFIELDMultivalued( pfield->ffield )
			|| ( pidb->FMultivalued() && !pidb->FPrimary() ) );		//	primary index can't be over multi-valued column
		fFirstMultiValued = ( !fSawMultiValued && FFIELDMultivalued( pfield->ffield ) );
		}
	else if ( FCOLUMNIDFixed( columnid ) )
		{
		pfield = ptdb->PfieldFixed( columnid );
		Assert( !FRECLongValue( pfield->coltyp ) );
		}
	else
		{
		Assert( FCOLUMNIDVar( columnid ) );
 		pfield = ptdb->PfieldVar( columnid );
		Assert( !FRECLongValue( pfield->coltyp ) );
		fBinaryChunks = FRECBinaryColumn( pfield->coltyp );
		}
		
	fText = FRECTextColumn( pfield->coltyp );
	Assert( pfield->cp != usUniCodePage || fText );		// Can't be Unicode unless it's text.

	if ( fUseDMLLatch )
		pfcbTable->LeaveDML();

	//	if not locOnCurBM, must go to record
	//
	//	if locOnCurBM and retrieving from the index, we can just retrieve from bmCurr
	//
	//  if locOnCurBM and retrieveing from the primary bookmark we can use the bmCurr
	//  of the FUCB of the table -- unless the table is not locOnCurBM. The table can
	//  not be on locCurBM if (iff?) we call JetSetCurrentIndex( JET_bitMoveFirst ) and
	//  then call JetRetrieveColumn() -- the FUCB of the index will be updated, but not the
	//  table. We could optimize this case by noting that on a non-unique secondary index
	//  we could get the primary key from the data of the bmCurr of the pfucbIdx
	if ( locOnCurBM != pfucbIdx->locLogical
		|| ( fRetrieveFromPrimaryBM && ( locOnCurBM != pfucb->locLogical ) ) )
		{
		CallR( ErrDIRGet( pfucbIdx ) );
		fLatched = fTrue;

		if ( fRetrieveFromPrimaryBM )
			{
			keyT.prefix.Nullify();
			keyT.suffix.SetCb( pfucbIdx->kdfCurr.data.Cb() );
			keyT.suffix.SetPv( pfucbIdx->kdfCurr.data.Pv() );
			pkey = &keyT;
			}
		else
			{
			pkey = &pfucbIdx->kdfCurr.key;
			}
		}
	else if ( fRetrieveFromPrimaryBM )
		{
		//  the key in the primary index is in sync with the secondary
		Assert( pfucbIdx != pfucb );
		Assert( locOnCurBM == pfucb->locLogical );
		pkey = &pfucb->bmCurr.key;
		}
	else
		{
		pkey = &pfucbIdx->bmCurr.key;
		}

	//	If key is text, then can't de-normalise (due to case).
	//	If key may have been truncated, then return code indicating
	//	that retrieve should be from record.  Note that since we
	//	always consume as much keyspace as possible, the key would
	//	only have been truncated if the size of the key is cbKeyMost.
	//	If key is variable/tagged binary and cbVarSegMac specified,
	//	then key may also have been truncated.
	Assert( pkey->Cb() <= cbKeyMost );
	if ( fText
		|| pkey->Cb() == cbKeyMost
		|| ( fBinaryChunks && fVarSegMac ) )
		{
		err = ErrERRCheck( errDIRNoShortCircuit );
		goto ComputeItag;
		}

	dataColumn.SetPv( rgb );
	pfcbTable->EnterDML();
	Assert( pfcbTable->Ptdb() == ptdb );
	Call( ErrRECIRetrieveColumnFromKey( ptdb, pidb, pkey, columnid, &dataColumn ) );
	pfcbTable->LeaveDML();

	Assert( locOnCurBM == pfucbIdx->locLogical );
	if ( fLatched )
		{
		AssertDIRGet( pfucbIdx );
		}

	//	if long value then effect offset
	//
	if ( fLongValue )
		{
		if ( ibGraphic >= dataColumn.Cb() )
			{
			dataColumn.SetCb( 0 );
			}
		else
			{
			dataColumn.DeltaPv( ibGraphic );
			dataColumn.DeltaCb( -ibGraphic );
			}
		}

	//	set return values
	//
	if ( pcbActual )
		*pcbActual = dataColumn.Cb();

	if ( 0 == dataColumn.Cb() )
		{
		//	either NULL, zero-length, or
		//	LV with ibOffset out-of-range
		CallSx( err, JET_wrnColumnNull );
		}
	else
		{
		ULONG	cbReturned;
		if ( dataColumn.Cb() <= cbMax )
			{
			cbReturned = dataColumn.Cb();
			CallS( err );
			}
		else
			{
			cbReturned = cbMax;
			err = ErrERRCheck( JET_wrnBufferTruncated );
			}

		UtilMemCpy( pb, dataColumn.Pv(), (size_t)cbReturned );
		}

ComputeItag:
	if ( errDIRNoShortCircuit == err || ( grbit & JET_bitRetrieveTag ) )
		{
		ERR		errT			= err;
		ULONG	itagSequence	= 1;		// return 1 for non-tagged columns

		Assert( JET_errSuccess == err
			|| JET_wrnColumnNull == err
			|| JET_wrnBufferTruncated == err
			|| errDIRNoShortCircuit == err );

		//	- retrieve keys from record and compare against current key
		//	to compute itag for tagged column instance, responsible for
		//	this index key.
		//	- if column is NULL, then there must only be one itagsequence
		if ( fFirstMultiValued
			&& JET_wrnColumnNull != err )
			{
			keyT.prefix.Nullify();
			keyT.suffix.SetCb( sizeof( rgb ) );
			keyT.suffix.SetPv( rgb );

			if ( fLatched )
				{
				CallR( ErrDIRRelease( pfucbIdx ) );
				fLatched = fFalse;
				}

			Assert( 1 == itagSequence );
			for ( ; ;itagSequence++ )
				{
				Call( ErrRECRetrieveKeyFromRecord(
								pfucb,
								pidb,
								&keyT,
								itagSequence,
								0,
								fFalse ) );
				CallS( ErrRECValidIndexKeyWarning( err ) );
				Assert( wrnFLDOutOfTuples != err );
				Assert( wrnFLDNotPresentInIndex != err );
				if ( wrnFLDOutOfKeys == err )
					{
					//	index entry cannot be formulated from primary record
					err = ErrERRCheck( JET_errSecondaryIndexCorrupted );
					goto HandleError;
					}

				Assert( !fLatched );
				Call( ErrDIRGet( pfucbIdx ) );
				fLatched = fTrue;
				
				if ( FKeysEqual( pfucbIdx->kdfCurr.key, keyT ) )
					break;

				Assert( fLatched );
				Call( ErrDIRRelease( pfucbIdx ) );
				fLatched = fFalse;
				}
			}
			
		*pitagSequence = itagSequence;
			
		err = errT;	
		}

HandleError:
	if ( fLatched )
		{
		Assert( Pcsr( pfucbIdx )->FLatched() );
		CallS( ErrDIRRelease( pfucbIdx ) );
		}
	AssertDIRNoLatch( pfucbIdx->ppib );
	return err;
	}


//  ================================================================
INLINE ERR ErrRECAdjustEscrowedColumn(
	FUCB * 			pfucb,
	const COLUMNID	columnid,
	const ULONG		ibRecordOffset,
	VOID *			pv,
	const INT		cb )
//  ================================================================
//  
//  if this is an escrowed column, get the compensating delta from the version
//  store and apply it to the buffer
//
//-
	{
	//	UNDONE: remove columnid param because it's only
	//	used for DEBUG purposes
	Assert( 0 != columnid );
	Assert( FCOLUMNIDFixed( columnid ) );

	if ( sizeof(LONG) != cb )
		return ErrERRCheck( JET_errInvalidBufferSize );
	
	const LONG	lDelta	= LDeltaVERGetDelta( pfucb, pfucb->bmCurr, ibRecordOffset );
	*(LONG *)pv += lDelta;

	return JET_errSuccess;
	}


ERR VTAPI ErrIsamRetrieveColumn(
	JET_SESID		sesid,
	JET_VTID		vtid,
	JET_COLUMNID	columnid,
	VOID*			pv,
	const ULONG	  	cbMax,
	ULONG*			pcbActual,
	JET_GRBIT		grbit,
	JET_RETINFO*	pretinfo )
	{
	ERR				err;
 	PIB*			ppib				= reinterpret_cast<PIB *>( sesid );
	FUCB*			pfucb				= reinterpret_cast<FUCB *>( vtid );
	DATA*			pdataRec;
	DATA			dataRetrieved;
	ULONG			itagSequence;
	ULONG			ibLVOffset;
	FIELD			fieldFixed;
	BOOL			fScanTagged			= fFalse;
	BOOL			fTransactionStarted	= fFalse;
	BOOL			fSetReturnValue		= fTrue;
	BOOL			fUseCopyBuffer		= fFalse;

	CallR( ErrPIBCheck( ppib ) );
	CheckFUCB( ppib, pfucb );
	AssertDIRNoLatch( ppib );

	//	set ptdb.  ptdb is same for indexes and for sorts.
	//
	Assert( pfucb->u.pfcb->Ptdb() == pfucb->u.pscb->fcb.Ptdb() );
	Assert( pfucb->u.pfcb->Ptdb() != ptdbNil );

	if ( pretinfo != NULL )
		{
		if ( pretinfo->cbStruct < sizeof(JET_RETINFO) )
			return ErrERRCheck( JET_errInvalidParameter );
		ibLVOffset = pretinfo->ibLongValue;
		itagSequence = pretinfo->itagSequence;
		}
	else
		{
		itagSequence = 1;
		ibLVOffset = 0;
		}

	if ( grbit & grbitRetrieveColumnInternalFlagsMask )
		{
		err = ErrERRCheck( JET_errInvalidGrbit );
		return err;
		}

	if ( pfucb->cbstat == fCBSTATInsertReadOnlyCopy )
		{
		grbit = grbit & ~( JET_bitRetrieveFromIndex | JET_bitRetrieveFromPrimaryBookmark );
		}

	if ( ppib->level == 0 )
		{
		// Begin transaction for read consistency (in case page
		// latch must be released in order to validate column).
		CallR( ErrDIRBeginTransaction( ppib, JET_bitTransactionReadOnly ) );
		fTransactionStarted = fTrue;
		}
		
	AssertDIRNoLatch( ppib );

	Assert( FFUCBSort( pfucb ) || FFUCBIndex( pfucb ) );
	
	if ( grbit & ( JET_bitRetrieveFromIndex|JET_bitRetrieveFromPrimaryBookmark ) )
		{
		if ( FFUCBAlwaysRetrieveCopy( pfucb )
			|| FFUCBNeverRetrieveCopy( pfucb ) )
			{
			//	insde a callback, so cannot use RetrieveFromIndex/PrimaryBookmark
			Call( ErrERRCheck( JET_errInvalidGrbit ) );
			}

		err = ErrRECIRetrieveFromIndex(
					pfucb,
					columnid,
					&itagSequence,
					reinterpret_cast<BYTE *>( pv ),
					cbMax,
					pcbActual,
					ibLVOffset,
					grbit );
		
		//	return itagSequence if requested
		//
		if ( pretinfo != NULL
			&& ( grbit & JET_bitRetrieveTag )
			&& ( errDIRNoShortCircuit == err || err >= 0 ) )
			{
			pretinfo->itagSequence = itagSequence;
			}
			
		if ( err != errDIRNoShortCircuit )
			{
			goto HandleError;
		 	}
		}
		
	AssertDIRNoLatch( ppib );

	fieldFixed.ffield = 0;
	if ( 0 != columnid )
		{
		Assert( !fScanTagged );
		Call( ErrRECIAccessColumn( pfucb, columnid, &fieldFixed ) );
		AssertDIRNoLatch( ppib );
		}
	else
		{
		fScanTagged = fTrue;
		}

	fUseCopyBuffer = ( ( ( grbit & JET_bitRetrieveCopy ) && FFUCBUpdatePrepared( pfucb ) && !FFUCBNeverRetrieveCopy( pfucb ) )
						|| FFUCBAlwaysRetrieveCopy( pfucb ) );
		
	Call( ErrRECIGetRecord( pfucb, &pdataRec, fUseCopyBuffer ) );
	
	if ( fScanTagged )
		{
		const ULONG	icolumnToRetrieve	= itagSequence;

		Assert( 0 == columnid );
		if ( 0 == itagSequence )
			{
			//	must use RetrieveColumns() in order to count columns
			err = ErrERRCheck( JET_errBadItagSequence );
			goto HandleError;
			}
			
		Call( ErrRECIScanTaggedColumns(
				pfucb,
				icolumnToRetrieve,
				*pdataRec,
				&dataRetrieved,
				&columnid,
				&itagSequence,
				grbit ) );
		Assert( 0 != columnid || JET_wrnColumnNull == err );
		}
	else if ( FCOLUMNIDTagged( columnid ) )
		{
		Call( ErrRECRetrieveTaggedColumn(
				pfucb->u.pfcb,
				columnid,
				itagSequence,
				*pdataRec,
				&dataRetrieved,
				grbit ) );
		}
	else
		{
		Call( ErrRECRetrieveNonTaggedColumn(
				pfucb->u.pfcb,
				columnid,
				*pdataRec,
				&dataRetrieved,
				&fieldFixed ) );
		}

	if ( wrnRECUserDefinedDefault == err )
		{
		Assert( FCOLUMNIDTagged( columnid ) );
		Assert( dataRetrieved.Cb() == 0 );

		if ( Pcsr( pfucb )->FLatched() )
			{
			CallS( ErrDIRRelease( pfucb ) );
			}

		const BOOL fAlwaysRetrieveCopy 	= FFUCBAlwaysRetrieveCopy( pfucb );
		const BOOL fNeverRetrieveCopy	= FFUCBNeverRetrieveCopy( pfucb );

		Assert( !( fAlwaysRetrieveCopy && fNeverRetrieveCopy ) );
		
		if( fUseCopyBuffer )
			{
			FUCBSetAlwaysRetrieveCopy( pfucb );
			}
		else
			{
			FUCBSetNeverRetrieveCopy( pfucb );
			}
			
		*pcbActual = cbMax;
		err =  ErrRECCallback(
					ppib,		
					pfucb,
					JET_cbtypUserDefinedDefaultValue,
					columnid,
					pv,
					(VOID *)pcbActual,
					columnid );
		if( JET_errSuccess == err && *pcbActual > cbMax )
			{
			//  the callback function may not set this correctly.
			err = ErrERRCheck( JET_wrnBufferTruncated );
			}

		FUCBResetAlwaysRetrieveCopy( pfucb );
		FUCBResetNeverRetrieveCopy( pfucb );

		if( fAlwaysRetrieveCopy )
			{
			FUCBSetAlwaysRetrieveCopy( pfucb );
			}
		else if( fNeverRetrieveCopy )
			{
			FUCBSetNeverRetrieveCopy( pfucb );
			}

		Call( err );
		
		fSetReturnValue = fFalse;
		}

	else
		{
		Assert( wrnRECLongField != err );		//	obsolete error code
		switch ( err )
			{
			case wrnRECSeparatedSLV:
			case wrnRECIntrinsicSLV:
				{
				DATA	dataRetrieveBuffer;
				dataRetrieveBuffer.SetCb( cbMax );
				dataRetrieveBuffer.SetPv( pv );
		
				Call( ErrSLVRetrieveColumn(
							pfucb,
							columnid,
							itagSequence,
							( wrnRECSeparatedSLV == err ),
							ibLVOffset,
							grbit,
							dataRetrieved,
							&dataRetrieveBuffer,
							pcbActual ) );
				fSetReturnValue = fFalse;
				break;
				}
			case wrnRECSeparatedLV:
				{
				//  If we are retrieving an after-image or
				//	haven't replaced a LV we can simply go
				//	to the LV tree. Otherwise we have to
				//	perform a more detailed consultation of
				//	the version store with ErrRECGetLVImage
				const BOOL fAfterImage = fUseCopyBuffer
										|| !FFUCBUpdateSeparateLV( pfucb )
										|| !FFUCBReplacePrepared( pfucb );
				Call( ErrRECIRetrieveSeparatedLongValue(
						pfucb,
						dataRetrieved,
						fAfterImage,
						ibLVOffset,
						pv,
						cbMax,
						pcbActual,
						grbit ) );
				fSetReturnValue = fFalse;
				break;
				}

			case wrnRECIntrinsicLV:
				if ( ibLVOffset >= dataRetrieved.Cb() )
					dataRetrieved.SetCb( 0 );
				else
					{
					dataRetrieved.DeltaPv( ibLVOffset );
					dataRetrieved.DeltaCb( -ibLVOffset );
					}
				err = JET_errSuccess;
				break;
			case JET_wrnColumnSetNull:
				Assert( fScanTagged );
				break;
			default:
				CallSx( err, JET_wrnColumnNull );
			}
		}

	//	these should have been handled and mapped
	//	to an appropriate return value
	Assert( wrnRECUserDefinedDefault != err );
	Assert( wrnRECSeparatedLV != err );
	Assert( wrnRECIntrinsicLV != err );
	Assert( wrnRECSeparatedSLV != err );
	Assert( wrnRECIntrinsicSLV != err );

	//** Set return values **
	if ( fSetReturnValue )
		{
		ULONG	cbCopy;
		BYTE	rgb[8];
		
		if ( 0 != columnid && dataRetrieved.Cb() <= 8 && dataRetrieved.Cb() && !FHostIsLittleEndian() )
			{
			Assert( dataRetrieved.Pv() );
			
			//	Depends on coltyp, we may need to reverse the bytes
			JET_COLTYP coltyp = ColtypFromColumnid( pfucb, columnid );
			if ( coltyp == JET_coltypShort )
				{
			 	*(USHORT*)rgb = ReverseBytesOnBE( *(USHORT*)dataRetrieved.Pv() );
				dataRetrieved.SetPv( rgb );
				}
			else if ( coltyp == JET_coltypLong ||
					  coltyp == JET_coltypIEEESingle )
				{
				*(ULONG*)rgb = ReverseBytesOnBE( *(ULONG*)dataRetrieved.Pv() );
				dataRetrieved.SetPv( rgb );
				}
			else if ( coltyp == JET_coltypCurrency	||
					  coltyp == JET_coltypIEEEDouble	||
				 	  coltyp == JET_coltypDateTime )
				{
				*(QWORD*)rgb = ReverseBytesOnBE( *(QWORD*)dataRetrieved.Pv() );
				dataRetrieved.SetPv( rgb );
				}
			}

		if ( pcbActual )
			*pcbActual = dataRetrieved.Cb();

		if ( dataRetrieved.Cb() <= cbMax )
			{
			cbCopy = dataRetrieved.Cb();
			}
		else
			{
			cbCopy = cbMax;
			err = ErrERRCheck( JET_wrnBufferTruncated );
			}

		if ( cbCopy )
			UtilMemCpy( pv, dataRetrieved.Pv(), cbCopy );

		//  if we are inserting a new record there can't be any versions on the 
		//  escrow column. we also don't know the bookmark of the new record yet...
		if ( FFIELDEscrowUpdate( fieldFixed.ffield ) && !FFUCBInsertPrepared( pfucb ) )
			{
			const ERR	errT	= ErrRECAdjustEscrowedColumn(
										pfucb,
										columnid,
										fieldFixed.ibRecordOffset,
										pv,
										cbCopy );
			if ( errT < 0 )
				{
				Call( errT );
				}
			}
		}
	
	if ( pretinfo != NULL )
		pretinfo->columnidNextTagged = columnid;

HandleError:
	if ( Pcsr( pfucb )->FLatched() )
		{
		ERR errT;
		Assert( !fUseCopyBuffer );
		errT = ErrDIRRelease( pfucb );
		CallSx( errT, JET_errOutOfMemory );
		if ( errT < JET_errSuccess && err >= JET_errSuccess )
			{
			err = errT;
			}
		}
		
	if ( fTransactionStarted )
		{
		//	No updates performed, so force success.
		CallS( ErrDIRCommitTransaction( ppib, NO_GRBIT ) );
		}

	AssertDIRNoLatch( ppib );
	return err;
	}


INLINE VOID RECICountColumn(
	FCB				*pfcb,
	const COLUMNID	columnid,
	const DATA&		dataRec,
	ULONG			*pulNumOccurrences )
	{
	Assert( 0 != columnid );

	if ( FCOLUMNIDTagged( columnid ) )
		{
		*pulNumOccurrences = UlRECICountTaggedColumnInstances(
					pfcb,
					columnid,
					dataRec );
		}
	else
		{
		ERR		errT;
		BOOL	fNull;
		
		if ( FCOLUMNIDTemplateColumn( columnid ) && !pfcb->FTemplateTable() )
			{
			if ( !pfcb->FTemplateTable() )
				{
				pfcb->Ptdb()->AssertValidDerivedTable();
				pfcb = pfcb->Ptdb()->PfcbTemplateTable();
				}
			else
				{
				pfcb->Ptdb()->AssertValidTemplateTable();
				}
			}

		if ( FCOLUMNIDFixed( columnid ) )
			{
			//	columnid should already have been validated
			Assert( FidOfColumnid( columnid ) >= pfcb->Ptdb()->FidFixedFirst() );
			Assert( FidOfColumnid( columnid ) <= pfcb->Ptdb()->FidFixedLast() );
				
			errT = ErrRECIFixedColumnInRecord( columnid, pfcb, dataRec );

			if ( JET_errColumnNotFound == errT )
				{
				// Column not in record -- it's null if there's no default value.
				const TDB * const	ptdb	= pfcb->Ptdb();
				if ( FidOfColumnid( columnid ) > ptdb->FidFixedLastInitial() )
					{
					pfcb->EnterDML();
					fNull = !FFIELDDefault( ptdb->PfieldFixed( columnid )->ffield );
					pfcb->LeaveDML();
					}
				else
					{
					fNull = !FFIELDDefault( ptdb->PfieldFixed( columnid )->ffield );
					}
				}
			else
				{
				CallSx( errT, JET_wrnColumnNull );
				fNull = ( JET_wrnColumnNull == errT );
				}
			}
		else
			{
			Assert( FCOLUMNIDVar( columnid ) );

			//	columnid should already have been validated
			Assert( FidOfColumnid( columnid ) >= pfcb->Ptdb()->FidVarFirst() );
			Assert( FidOfColumnid( columnid ) <= pfcb->Ptdb()->FidVarLast() );
			
			errT = ErrRECIVarColumnInRecord( columnid, pfcb, dataRec );
						
			if ( JET_errColumnNotFound == errT )
				{
				// Column not in record -- it's null if there's no default value.
				const TDB * const	ptdb	= pfcb->Ptdb();
				if ( FidOfColumnid( columnid ) > ptdb->FidVarLastInitial() )
					{
					pfcb->EnterDML();
					fNull = !FFIELDDefault( ptdb->PfieldVar( columnid )->ffield );
					pfcb->LeaveDML();
					}
				else
					{
					fNull = !FFIELDDefault( ptdb->PfieldVar( columnid )->ffield );
					}
				}
			else
				{
				CallSx( errT, JET_wrnColumnNull );
				fNull = ( JET_wrnColumnNull == errT );
				}
			}

		*pulNumOccurrences = ( fNull ? 0 : 1 );
		}
	}


LOCAL ERR ErrRECRetrieveColumns(
	FUCB				*pfucb,
	JET_RETRIEVECOLUMN	*pretcol,
	ULONG				cretcol,
	BOOL				*pfBufferTruncated )
	{
	ERR					err;
	const DATA			* pdataRec;

	Assert( !( FFUCBAlwaysRetrieveCopy( pfucb ) && FFUCBNeverRetrieveCopy( pfucb ) ) );
			
	//	set ptdb, ptdb is same for indexes and for sorts
	//
	Assert( pfucb->u.pfcb->Ptdb() == pfucb->u.pscb->fcb.Ptdb() );
	Assert( pfucb->u.pfcb->Ptdb() != ptdbNil );
	AssertDIRNoLatch( pfucb->ppib );

	*pfBufferTruncated = fFalse;

	//	get current data
	//
	if ( FFUCBSort( pfucb ) )
		{
		//	sorts always have current data cached.
		if ( pfucb->locLogical != locOnCurBM )
			{
			Assert( locBeforeFirst == pfucb->locLogical
				|| locAfterLast == pfucb->locLogical );
			err = ErrERRCheck( JET_errNoCurrentRecord );
			}
		else
			{
			Assert( pfucb->kdfCurr.data.Cb() != 0 );
			}

		pdataRec = &pfucb->kdfCurr.data;
		}

	for ( ULONG i = 0; i < cretcol; i++ )
		{
		// efficiency variables
		//
		JET_RETRIEVECOLUMN	* pretcolT		= pretcol + i;
		JET_GRBIT			grbit			= pretcolT->grbit;
		COLUMNID			columnid		= pretcolT->columnid;
		FIELD				fieldFixed;
		DATA 				dataRetrieved;
		BOOL				fSetReturnValue = fTrue;

		fieldFixed.ffield = 0;

		if ( grbit & grbitRetrieveColumnInternalFlagsMask )
			{
			Call( ErrERRCheck( JET_errInvalidGrbit ) );
			}

		if ( pfucb->cbstat == fCBSTATInsertReadOnlyCopy )
			{
			grbit = grbit & ~( JET_bitRetrieveFromIndex | JET_bitRetrieveFromPrimaryBookmark );
			}

		if ( FFUCBIndex( pfucb ) )
			{
			// UNDONE: No copy buffer with sorts, and don't currently support
			// secondary indexes with sorts, so RetrieveFromIndex reduces to
			// a record retrieval.
			if ( grbit & ( JET_bitRetrieveFromIndex|JET_bitRetrieveFromPrimaryBookmark ) )
				{
				if ( Pcsr( pfucb )->FLatched() )
					{
					Call( ErrDIRRelease( pfucb ) );
					}

				if ( FFUCBAlwaysRetrieveCopy( pfucb )
					|| FFUCBNeverRetrieveCopy( pfucb ) )
					{
					//	insde a callback, so cannot use RetrieveFromIndex/PrimaryBookmark
					Call( ErrERRCheck( JET_errInvalidGrbit ) );
					}

				err = ErrRECIRetrieveFromIndex(
							pfucb,
							columnid,
							&pretcolT->itagSequence,
							reinterpret_cast<BYTE *>( pretcolT->pvData ),
							pretcolT->cbData,
							&pretcolT->cbActual,
							pretcolT->ibLongValue,
							grbit );
						AssertDIRNoLatch( pfucb->ppib );

				if ( errDIRNoShortCircuit == err )
					{
					//	UNDONE: this is EXTREMELY expensive because we
					//	will go to the record and formulate all keys
					//	for the record to try to determine the itagSequence
					//	of the current index entry
					Assert( pretcolT->itagSequence > 0 );
					}
				else
					{
					if ( err < 0 )
						goto HandleError;

					pretcolT->columnidNextTagged = columnid;
					pretcolT->err = err;
					if ( JET_wrnBufferTruncated == err )
						*pfBufferTruncated = fTrue;
								
					continue;
					}
				}
					
			if ( ( ( grbit & JET_bitRetrieveCopy ) && FFUCBUpdatePrepared( pfucb ) && !FFUCBNeverRetrieveCopy( pfucb ) )
				|| FFUCBAlwaysRetrieveCopy( pfucb ) )
				{
				//	if we obtained the latch on a previous pass,
				//	we don't relinquish it because we want to
				//	avoid excessive latching/unlatching
				Assert( !Pcsr( pfucb )->FLatched()
					|| !FFUCBAlwaysRetrieveCopy( pfucb ) );
				pdataRec = &pfucb->dataWorkBuf;
				}
			else
				{
				if ( !Pcsr( pfucb )->FLatched() )
					{
					Call( ErrDIRGet( pfucb ) );
					}
				pdataRec = &pfucb->kdfCurr.data;
				}
			}
		else
			{
			Assert( FFUCBSort( pfucb ) );
			Assert( pdataRec == &pfucb->kdfCurr.data );
			Assert( !Pcsr( pfucb )->FLatched() );
			}


		ULONG	itagSequence	= pretcolT->itagSequence;

		if ( 0 == columnid )
			{
			if ( 0 == itagSequence )		// Are we counting all tagged columns?
				{
				Call( ErrRECIScanTaggedColumns(
						pfucb,
						0,
						*pdataRec,
						&dataRetrieved,
						&columnid,
						&pretcolT->itagSequence,	// Store count in itagSequence
						grbit ) );
				Assert( 0 == columnid );
				Assert( JET_wrnColumnNull == err );
				pretcolT->cbActual = 0;
				pretcolT->columnidNextTagged = 0;
				pretcolT->err = JET_errSuccess;
				continue;
				}
			else
				{
				Call( ErrRECIScanTaggedColumns(
						pfucb,
						pretcolT->itagSequence,
						*pdataRec,
						&dataRetrieved,
						&columnid,
						&itagSequence,
						grbit ) );
				Assert( 0 != columnid || JET_wrnColumnNull == err );
				}
			}
		else
			{
			// Verify column is accessible and that we're in a transaction
			// (for read consistency).
			Assert( pfucb->ppib->level > 0 );
			Call( ErrRECIAccessColumn( pfucb, columnid, &fieldFixed ) );
			
			if ( 0 == itagSequence )
				{
				RECICountColumn(
						pfucb->u.pfcb,
						columnid,
						*pdataRec,
						&pretcolT->itagSequence );	// Store count in itagSequence
				pretcolT->cbActual = 0;
				pretcolT->columnidNextTagged = columnid;
				pretcolT->err = JET_errSuccess;
				continue;
				}
			else if ( FCOLUMNIDTagged( columnid ) )
				{
				Call( ErrRECRetrieveTaggedColumn(
						pfucb->u.pfcb,
						columnid,
						itagSequence,
						*pdataRec,
						&dataRetrieved,
						grbit ) );
				}
			else
				{
				Call( ErrRECRetrieveNonTaggedColumn(
						pfucb->u.pfcb,
						columnid,
						*pdataRec,
						&dataRetrieved,
						&fieldFixed ) );
				}
			}

		if ( wrnRECUserDefinedDefault == err )
			{
			Assert( FCOLUMNIDTagged( columnid ) );
			Assert( dataRetrieved.Cb() == 0 );

			if ( Pcsr( pfucb )->FLatched() )
				{
				Call( ErrDIRRelease( pfucb ) );
				}

			Assert( pretcolT->columnid == columnid );
			
			VOID * const pvArg1 = pretcolT->pvData;
			pretcolT->cbActual = pretcolT->cbData;
			VOID * const pvArg2 = &(pretcolT->cbActual);

			const BOOL fAlwaysRetrieveCopy 	= FFUCBAlwaysRetrieveCopy( pfucb );
			const BOOL fNeverRetrieveCopy	= FFUCBNeverRetrieveCopy( pfucb );

			Assert( !( fAlwaysRetrieveCopy && fNeverRetrieveCopy ) );

			if( ( ( grbit & JET_bitRetrieveCopy) || FFUCBAlwaysRetrieveCopy( pfucb ) )
				&& FFUCBUpdatePrepared( pfucb ) )
				{
				FUCBSetAlwaysRetrieveCopy( pfucb );
				}
			else
				{
				FUCBSetNeverRetrieveCopy( pfucb );
				}

			err = ErrRECCallback(
						pfucb->ppib,		
						pfucb,
						JET_cbtypUserDefinedDefaultValue,
						columnid,
						pvArg1,
						pvArg2,
						columnid );
			if( JET_errSuccess == err && pretcolT->cbActual > pretcolT->cbData )
				{
				//  the callback function may not set this correctly.
				err = ErrERRCheck( JET_wrnBufferTruncated );
				}

			FUCBResetAlwaysRetrieveCopy( pfucb );
			FUCBResetNeverRetrieveCopy( pfucb );

			if( fAlwaysRetrieveCopy )
				{
				FUCBSetAlwaysRetrieveCopy( pfucb );
				}
			else if ( fNeverRetrieveCopy )
				{
				FUCBSetNeverRetrieveCopy( pfucb );
				}
				
			Call( err );
			
			pretcolT->err = err;
			fSetReturnValue = fFalse;

			Assert( !Pcsr( pfucb )->FLatched() );
			}

		else
			{
			Assert( wrnRECLongField != err );		//	obsolete error code

			switch ( err )
				{
				case wrnRECSeparatedSLV:
				case wrnRECIntrinsicSLV:
					{
					DATA	dataRetrieveBuffer;
					dataRetrieveBuffer.SetCb( pretcolT->cbData );
					dataRetrieveBuffer.SetPv( pretcolT->pvData );
				
					Call( ErrSLVRetrieveColumn(
								pfucb,
								columnid,
								itagSequence,
								( wrnRECSeparatedSLV == err ),
								pretcolT->ibLongValue,
								grbit,
								dataRetrieved,
								&dataRetrieveBuffer,
								&pretcolT->cbActual ) );

					pretcolT->err = err;
					fSetReturnValue = fFalse;
					break;
					}
				case wrnRECSeparatedLV:
					{
					//  If we are retrieving a copy, go ahead
					//	and do a normal retrieval. Otherwise
					//	we have to consult the version store
					const BOOL fRetrieveBeforeImage = 
						( FFUCBNeverRetrieveCopy( pfucb ) || !( grbit & JET_bitRetrieveCopy ) ) 
						&& FFUCBReplacePrepared( pfucb )
						&& FFUCBUpdateSeparateLV( pfucb )
						&& !FFUCBAlwaysRetrieveCopy( pfucb );
			
					Call( ErrRECIRetrieveSeparatedLongValue(
								pfucb,
								dataRetrieved,
								!fRetrieveBeforeImage,
								pretcolT->ibLongValue,
								pretcolT->pvData,
								pretcolT->cbData,
								&pretcolT->cbActual,
								grbit ) );
					pretcolT->err = err;
					fSetReturnValue = fFalse;
					break;
					}

				case wrnRECIntrinsicLV:
					if ( pretcolT->ibLongValue >= dataRetrieved.Cb() )
						dataRetrieved.SetCb( 0 );
					else
						{
						dataRetrieved.DeltaPv( pretcolT->ibLongValue );
						dataRetrieved.DeltaCb( -( pretcolT->ibLongValue ) );
						}
					err = JET_errSuccess;
					break;
				case JET_wrnColumnSetNull:
					Assert( 0 == pretcolT->columnid );
					break;
				default:
					CallSx( err, JET_wrnColumnNull );
				}
			}

		//	these should have been handled and mapped
		//	to an appropriate return value
		Assert( wrnRECUserDefinedDefault != err );
		Assert( wrnRECSeparatedLV != err );
		Assert( wrnRECIntrinsicLV != err );
		Assert( wrnRECSeparatedSLV != err );
		Assert( wrnRECIntrinsicSLV != err );

		if ( fSetReturnValue )
			{
			ULONG	cbCopy;
			BYTE	rgb[8];
		
			if ( 0 != columnid && dataRetrieved.Cb() <= 8 && dataRetrieved.Cb() && !FHostIsLittleEndian() )
				{
				Assert( dataRetrieved.Pv() );
				
				//	Depends on coltyp, we may need to reverse the bytes
				JET_COLTYP coltyp = ColtypFromColumnid( pfucb, columnid );
				if ( coltyp == JET_coltypShort )
					 {
					 *(USHORT*)rgb = ReverseBytesOnBE( *(USHORT*)dataRetrieved.Pv() );
					 dataRetrieved.SetPv( rgb );
					 }
				else if ( coltyp == JET_coltypLong ||
						  coltyp == JET_coltypIEEESingle )
					 {
					 *(ULONG*)rgb = ReverseBytesOnBE( *(ULONG*)dataRetrieved.Pv() );
					 dataRetrieved.SetPv( rgb );
					 }
				else if ( coltyp == JET_coltypCurrency	||
						  coltyp == JET_coltypIEEEDouble	||
					 	  coltyp == JET_coltypDateTime )
					 {
					 *(QWORD*)rgb = ReverseBytesOnBE( *(QWORD*)dataRetrieved.Pv() );
					 dataRetrieved.SetPv( rgb );
					 }
				}

			pretcolT->cbActual = dataRetrieved.Cb();

			if ( dataRetrieved.Cb() <= pretcolT->cbData )
				{
				pretcolT->err = err;
				cbCopy = dataRetrieved.Cb();
				}
			else
				{
				pretcolT->err = ErrERRCheck( JET_wrnBufferTruncated );
				cbCopy = pretcolT->cbData;
				}

			UtilMemCpy( pretcolT->pvData, dataRetrieved.Pv(), cbCopy );

			//  if we are inserting a new record there can't be any versions on the 
			//  escrow column. we also don't know the bookmark of the new record yet...
			if ( FFIELDEscrowUpdate( fieldFixed.ffield ) && !FFUCBInsertPrepared( pfucb ) )
				{
				const ERR	errT	= ErrRECAdjustEscrowedColumn(
											pfucb,
											columnid,
											fieldFixed.ibRecordOffset,
											pretcolT->pvData,
											cbCopy );
				//	only assign to err if there was an error
				if ( errT < 0 )
					{
					Call( errT );
					}
				}
			}

		pretcolT->columnidNextTagged = columnid;

		if ( JET_wrnBufferTruncated == pretcolT->err )
			*pfBufferTruncated = fTrue;

		Assert( pretcolT->err != JET_errNullInvalid );
		}	// for

	err = JET_errSuccess;

HandleError:
	if ( Pcsr( pfucb )->FLatched() )
		{
		CallS( ErrDIRRelease( pfucb ) );
		}
		
	AssertDIRNoLatch( pfucb->ppib );

	return err;
	}

ERR VTAPI ErrIsamRetrieveColumns(
	JET_SESID				vsesid,
	JET_VTID				vtid,
	JET_RETRIEVECOLUMN		*pretcol,
	ULONG					cretcol )
	{
	ERR						err;
	PIB						*ppib				= (PIB *)vsesid;
	FUCB					*pfucb				= (FUCB *)vtid;
	BOOL					fBufferTruncated;
	BOOL					fTransactionStarted = fFalse;

	CallR( ErrPIBCheck( ppib ) );
	CheckFUCB( ppib, pfucb );
	AssertDIRNoLatch( ppib );

	if ( 0 == ppib->level )
		{
		// Begin transaction for read consistency (in case page
		// latch must be released in order to validate column).
		Call( ErrDIRBeginTransaction( ppib, JET_bitTransactionReadOnly ) );
		fTransactionStarted = fTrue;
		}
		
	AssertDIRNoLatch( ppib );
	Assert( FFUCBSort( pfucb ) || FFUCBIndex( pfucb ) );

	Call( ErrRECRetrieveColumns(
				pfucb,
				pretcol,
				cretcol,
				&fBufferTruncated ) );
	if ( fBufferTruncated )
		err = ErrERRCheck( JET_wrnBufferTruncated );

HandleError:
	if ( fTransactionStarted )
		{
		//	No updates performed, so force success.
		CallS( ErrDIRCommitTransaction( ppib, NO_GRBIT ) );
		}
	AssertDIRNoLatch( ppib );

	return err;
	}


INLINE VOID RECIAddTaggedColumnListEntry(
	TAGCOLINFO					* const ptagcolinfo,
	const TAGFIELDS_ITERATOR	* const piterator,
	const TDB					* const ptdb,
	const BOOL					fDefaultValue )
	{
	const BOOL			fDerived	= ( piterator->FDerived()
										|| ( ptdb->FESE97DerivedTable()
											&& piterator->Fid() < ptdb->FidTaggedFirst() ) );

	ptagcolinfo->columnid			= piterator->Columnid( ptdb );
	ptagcolinfo->cMultiValues		= static_cast<USHORT>( piterator->TagfldIterator().Ctags() );				
	ptagcolinfo->usFlags			= 0;
	ptagcolinfo->fLongValue			= USHORT( piterator->FLV() ? fTrue : fFalse );
	ptagcolinfo->fDefaultValue		= USHORT( fDefaultValue ? fTrue : fFalse );
	ptagcolinfo->fNullOverride		= USHORT( piterator->FNull() ? fTrue : fFalse );
	ptagcolinfo->fDerived			= USHORT( fDerived ? fTrue : fFalse );
	}


LOCAL ERR ErrRECIBuildTaggedColumnList(
	FUCB				* const pfucb,
	const DATA&			dataRec,
	TAGCOLINFO			* const rgtagcolinfo,
	ULONG				* const pcentries,
	const ULONG			centriesMax,
	const JET_COLUMNID	columnidStart,
	const JET_GRBIT		grbit )
	{
	ERR					err = JET_errSuccess;
	
	FCB					* const pfcb		= pfucb->u.pfcb;
	TDB					* const ptdb		= pfcb->Ptdb();
	
	const BOOL			fCountOnly			= ( NULL == rgtagcolinfo );
	const BOOL			fRetrieveNulls		= ( grbit & JET_bitRetrieveNull );
	const BOOL			fRetrieveDefaults	= ( !( grbit & JET_bitRetrieveIgnoreDefault )
												&& ptdb->FTableHasNonEscrowDefault() );
	
	const BOOL			fNeedToRefresh		= ( dataRec.Pv() == pfucb->kdfCurr.data.Pv() );

	INT centriesCurr = 0;

	TAGFIELDS_ITERATOR * precordIterator		= NULL;
	TAGFIELDS_ITERATOR * pdefaultValuesIterator	= NULL;

	VOID * pvBuf	= NULL;

	//	initialize return values

	*pcentries = 0;

	//	create the iterators
		
	precordIterator = new TAGFIELDS_ITERATOR( dataRec );
	if( NULL == precordIterator )
		{
		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}
	precordIterator->MoveBeforeFirst();
	if( JET_errNoCurrentRecord == ( err = precordIterator->ErrMoveNext() ) )
		{
		//	no tagged columns;
		delete precordIterator;
		precordIterator = NULL;
		err = JET_errSuccess;
		}
	Call( err );

	if( fRetrieveDefaults )
		{
		pdefaultValuesIterator = new TAGFIELDS_ITERATOR( *ptdb->PdataDefaultRecord() );
		if( NULL == pdefaultValuesIterator )
			{
			Call( ErrERRCheck( JET_errOutOfMemory ) );
			}
		pdefaultValuesIterator->MoveBeforeFirst();
		if( JET_errNoCurrentRecord == ( err = pdefaultValuesIterator->ErrMoveNext() ) )
			{
			//	no tagged columns;
			delete pdefaultValuesIterator;
			pdefaultValuesIterator = NULL;
			err = JET_errSuccess;
			}
		Call( err );
		}

	//	if necessary, advance to starting column
	
	if ( FTaggedFid( (FID)columnidStart ) )		//	can't use FCOLUMNIDTagged() because it assumes a valid columnid
		{
		if ( precordIterator )
			{
			while( CmpFid(
					precordIterator->Fid(),
					precordIterator->FDerived(),
					FidOfColumnid( columnidStart ),
					FRECUseDerivedBit( columnidStart, ptdb ) ) < 0 )
				{
				if( JET_errNoCurrentRecord == ( err = precordIterator->ErrMoveNext() ) )
					{
					delete precordIterator;
					precordIterator = NULL;			
					err = JET_errSuccess;
					break;
					}
				Call( err );
				}
			}

		if ( pdefaultValuesIterator )
			{
			while( CmpFid(
					pdefaultValuesIterator->Fid(),
					pdefaultValuesIterator->FDerived(),
					FidOfColumnid( columnidStart ),
					FRECUseDerivedBit( columnidStart, ptdb ) ) < 0 )
				{
				if( JET_errNoCurrentRecord == ( err = pdefaultValuesIterator->ErrMoveNext() ) )
					{
					delete pdefaultValuesIterator;
					pdefaultValuesIterator = NULL;			
					err = JET_errSuccess;
					break;
					}
				Call( err );
				}
			}
		}

	//	iterate

	TAGFIELDS_ITERATOR *pIteratorCur;
	INT ExistingIterators;
	FID fidRecordFID;
	BOOL fRecordDerived;
	FID fidDefaultFID;
	BOOL fDefaultDerived;
	INT cmp;
	
	pIteratorCur = NULL;
	ExistingIterators = 0;
	if ( NULL != pdefaultValuesIterator )
		{
		ExistingIterators++;
		pIteratorCur = pdefaultValuesIterator;
		cmp = 1;
		}
	if ( NULL != precordIterator )
		{
		ExistingIterators++;
		pIteratorCur = precordIterator;
		cmp = -1;
		// we have both iterators, assume that we were starting with recordIterator
		if ( 2 == ExistingIterators )
			{
			fidRecordFID = 0;
			fRecordDerived = fFalse;
			fidDefaultFID = pdefaultValuesIterator->Fid();
			fDefaultDerived = pdefaultValuesIterator->FDerived();
			}
		}

	while ( ExistingIterators > 0 )
		{
		if ( 2 == ExistingIterators )
			{
			if ( pIteratorCur == precordIterator )
				{
				fidRecordFID = pIteratorCur->Fid();
				fRecordDerived = pIteratorCur->FDerived();
				if ( 0 == cmp )
					{
					// skip this because we've alread picked up this column from record
					pIteratorCur = pdefaultValuesIterator;
					goto NextIteration;
					}
				}
			else
				{
				Assert( pIteratorCur == pdefaultValuesIterator );
				fidDefaultFID = pIteratorCur->Fid();
				fDefaultDerived = pIteratorCur->FDerived();
				}
			//	there are both record and default tagged column values
			//	find which one is first
			cmp = CmpFid( fidRecordFID, fRecordDerived, fidDefaultFID, fDefaultDerived );
			if ( cmp > 0 )
				{
				//	the column is less than the current column in the record
				pIteratorCur = pdefaultValuesIterator;
				}
			else 
				{
				//	columns are equal or the default value is greater
				//	select the one in the record
				pIteratorCur = precordIterator;
				}
			}
			
		err = ErrRECIAccessColumn(
					pfucb,
					pIteratorCur->Columnid( ptdb ) );
		if ( err < 0 )
			{
			if ( JET_errColumnNotFound != err )
				{
				Call( err );
				}
			}
		else
			{
			//	column is visible to us
			if( !fCountOnly )
				{
				RECIAddTaggedColumnListEntry(
					rgtagcolinfo + centriesCurr,
					pIteratorCur,
					ptdb,
					fFalse );
				}
			++centriesCurr;
			if( centriesMax == centriesCurr )
				{
				break;
				}							
			}

NextIteration:
		err = pIteratorCur->ErrMoveNext();
		if ( JET_errNoCurrentRecord == err )
			{
			ExistingIterators--;
			if ( pIteratorCur == precordIterator )
				{
				pIteratorCur = pdefaultValuesIterator;
				if ( 0 == cmp )
					{
					goto NextIteration;
					}
				}
			else
				{
				Assert( pIteratorCur == pdefaultValuesIterator );
				pIteratorCur = precordIterator;
				}
			err = JET_errSuccess;
			}
		Call( err );
		CallS( err );
		}
	CallS( err );
	*pcentries = centriesCurr;

HandleError:
	if ( NULL != precordIterator )
		{
		delete precordIterator;
		}
	if ( NULL != pdefaultValuesIterator )
		{
		delete pdefaultValuesIterator;
		}

	return err;
	}

ERR VTAPI ErrIsamRetrieveTaggedColumnList(
	JET_SESID			vsesid,
	JET_VTID			vtid,
	ULONG				*pcentries,
	VOID				*pv,
	const ULONG			cbMax,
	const JET_COLUMNID	columnidStart,
	const JET_GRBIT		grbit )
	{
	ERR					err;
 	PIB					*ppib				= reinterpret_cast<PIB *>( vsesid );
	FUCB				*pfucb				= reinterpret_cast<FUCB *>( vtid );
	DATA				*pdataRec;
	BOOL				fTransactionStarted	= fFalse;

	CallR( ErrPIBCheck( ppib ) );
	CheckFUCB( ppib, pfucb );
	AssertDIRNoLatch( ppib );

	//	must always provide facility to return number of entries in the list
	if ( NULL == pcentries )
		{
		err = ErrERRCheck( JET_errInvalidParameter );
		return err;
		}

	//	set ptdb.  ptdb is same for indexes and for sorts.
	//
	Assert( pfucb->u.pfcb->Ptdb() == pfucb->u.pscb->fcb.Ptdb() );
	Assert( pfucb->u.pfcb->Ptdb() != ptdbNil );

	if ( 0 == ppib->level )
		{
		// Begin transaction for read consistency (in case page
		// latch must be released in order to validate column).
		CallR( ErrDIRBeginTransaction( ppib, JET_bitTransactionReadOnly ) );
		fTransactionStarted = fTrue;
		}
		
	AssertDIRNoLatch( ppib );

	Assert( FFUCBSort( pfucb ) || FFUCBIndex( pfucb ) );

	const BOOL	fUseCopyBuffer	= ( ( ( grbit & JET_bitRetrieveCopy ) && FFUCBUpdatePrepared( pfucb ) && !FFUCBNeverRetrieveCopy( pfucb ) )
									|| FFUCBAlwaysRetrieveCopy( pfucb ) );

	Call( ErrRECIGetRecord( pfucb, &pdataRec, fUseCopyBuffer ) );

	Call( ErrRECIBuildTaggedColumnList(
				pfucb,
				*pdataRec,
				reinterpret_cast<TAGCOLINFO *>( pv ),
				pcentries,
				cbMax / sizeof(TAGCOLINFO),
				columnidStart,
				grbit ) );

HandleError:
	if ( Pcsr( pfucb )->FLatched() )
		{
		Assert( !fUseCopyBuffer );
		CallS( ErrDIRRelease( pfucb ) );
		}
		
	if ( fTransactionStarted )
		{
		//	No updates performed, so force success.
		CallS( ErrDIRCommitTransaction( ppib, NO_GRBIT ) );
		}

	AssertDIRNoLatch( ppib );

	return err;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ese98\src\ese\fldnorm.cxx ===
#include "std.hxx"

const BYTE	bPrefixNull			= 0x00;
const BYTE	bPrefixZeroLength	= 0x40;
const BYTE	bPrefixNullHigh		= 0xc0;
const BYTE	bPrefixData			= 0x7f;
const BYTE	bSentinel			= 0xff;


LOCAL ERR ErrFLDNormalizeTextSegment(
	BYTE *						pbField,
	const ULONG					cbField,
	BYTE *						rgbSeg,
	INT *						pcbSeg,
	const ULONG					cbKeyAvail,
	const ULONG					cbKeyMost,
	const ULONG					cbVarSegMac,
	const USHORT				cp,
	const IDXUNICODE * const	pidxunicode )
	{
	ERR							err;

	// Null column handled elsewhere.
	Assert( NULL != pbField );
	Assert( cbField > 0 );

	Assert( cbKeyAvail > 0 );
	Assert( cbVarSegMac > 0 );

	// If cbVarSegMac == cbKeyMost, that implies that it
	// was never set.  However, to detect this, the caller
	// artificially increments it to cbKeyMost+1.
	Assert( cbVarSegMac <= cbKeyMost+1 );
	Assert( cbKeyMost != cbVarSegMac );
				
	// if cbVarSegMac was not set (ie. it is cbKeyMost+1),
	// then cbKeyAvail will always be less than it.
	Assert( cbVarSegMac < cbKeyMost || cbKeyAvail < cbVarSegMac );
	INT	cbT = min( cbKeyAvail, cbVarSegMac );

	//	cbT is the max size of the key segment data,
	//	and does not include the header byte which indicates
	//	NULL key, zero length key, or non-NULL key.
	cbT--;

	//	unicode support
	//
	if ( cp == usUniCodePage )
		{
		//	cbField may have been truncated to an odd number
		//	of bytes, so enforce even.
		Assert( cbField % 2 == 0 || cbKeyMost == cbField );
		err = ErrNORMMapString(
					pidxunicode->lcid,
					pidxunicode->dwMapFlags,
					pbField,
					( cbField / 2 ) * 2,	// enforce even
					rgbSeg + 1,
					cbT,
					pcbSeg );
		if ( err < 0 )
			{
#ifdef DEBUG
			switch ( err )
				{
				case JET_errInvalidLanguageId:
				case JET_errOutOfMemory:
				case JET_errUnicodeNormalizationNotSupported:
					break;
				default:
					//	report unexpected error
					CallS( err );
				}
#endif
			return err;
			}
		}
	else
		{
		err = ErrUtilNormText(
					(CHAR *)pbField,
					cbField,
					cbT,
					(CHAR *)rgbSeg + 1,
					pcbSeg );
		}
					
	Assert( JET_errSuccess == err || wrnFLDKeyTooBig == err );
	if ( wrnFLDKeyTooBig == err )
		{
		const INT	cbVarSegMacNoHeader = cbVarSegMac - 1;	// account for header byte
					
		// If not truncated on purpose, set flag
		Assert( cbKeyMost != cbVarSegMac );
		Assert( *pcbSeg <= cbVarSegMacNoHeader );
		if ( cbVarSegMac > cbKeyMost || *pcbSeg < cbVarSegMacNoHeader )
			{
			Assert( *pcbSeg + 1 == cbKeyAvail );
			}
		else
			{
			// Truncated on purpose, so suppress warning.
			Assert( cbVarSegMac < cbKeyMost );
			Assert( cbVarSegMacNoHeader == *pcbSeg );
			err = JET_errSuccess;
			}
		}

	Assert( *pcbSeg >= 0 );
	Assert( *pcbSeg <= cbT );

	//	put the prefix there
	//
	*rgbSeg = bPrefixData;
	(*pcbSeg)++;

	return err;
	}


LOCAL VOID FLDNormalizeBinarySegment(
	const BYTE		* const pbField,
	const ULONG		cbField,
	BYTE			* const rgbSeg,
	INT				* const pcbSeg,
	const ULONG		cbKeyAvail,
	const ULONG		cbKeyMost,
	const ULONG		cbVarSegMac,
	const BOOL		fFixedField,
	BOOL			* const pfColumnTruncated,
	ULONG			* pibBinaryColumnDelimiter )
	{
	ULONG			cbSeg;

	Assert( NULL == pibBinaryColumnDelimiter
		|| 0 == *pibBinaryColumnDelimiter );		//	either NULL or initialised to 0
	
	// Null column handled elsewhere.
	Assert( NULL != pbField );
	Assert( cbField > 0 );

	Assert( cbKeyAvail > 0 );
	Assert( cbVarSegMac > 0 );

	// If cbVarSegMac == cbKeyMost, that implies that it
	// was never set.  However, to detect this, the caller
	// artificially increments it to cbKeyMost+1.
	Assert( cbVarSegMac <= cbKeyMost+1 );
	Assert( cbKeyMost != cbVarSegMac );
				
	// if cbVarSegMac was not set (ie. it is cbKeyMost+1),
	// then cbKeyAvail will always be less than it.
	Assert( cbVarSegMac < cbKeyMost || cbKeyAvail < cbVarSegMac );

	rgbSeg[0] = bPrefixData;
			
	if ( fFixedField )
		{
		// calculate size of the normalized column, including header byte
		cbSeg = cbField + 1;

		// First check if we exceeded the segment maximum.
		if ( cbVarSegMac < cbKeyMost && cbSeg > cbVarSegMac )
			{
			cbSeg = cbVarSegMac;
			}
			
		// Once we've fitted the field into the segment
		// maximum, may need to resize further to fit
		// into the total key space.
		if ( cbSeg > cbKeyAvail )
			{
			cbSeg = cbKeyAvail;
			*pfColumnTruncated = fTrue;
			}

		Assert( cbSeg > 0 );
		UtilMemCpy( rgbSeg+1, pbField, cbSeg-1 );
		}
	else
		{
		// The difference between fNormalisedEntireColumn and
		// fColumnTruncated is that fNormaliseEntiredColumn is
		// set to FALSE if we had to truncate the column because
		// of either limited key space or we exceeded the
		// limitation imposed by cbVarSegMac.  fColumnTruncated
		// is only set to TRUE if the column was truncated due
		// to limited key space.
		BOOL			fNormalisedEntireColumn		= fTrue;
		const ULONG		cChunks						= ( cbField + ( cbFLDBinaryChunk-1 ) ) / cbFLDBinaryChunk;
		
		cbSeg = ( cChunks * cbFLDBinaryChunkNormalized ) + 1;		// +1 for header byte
		
		// First check if we exceeded the segment maximum.
		if ( cbVarSegMac < cbKeyMost && cbSeg > cbVarSegMac )
			{
			cbSeg = cbVarSegMac;
			fNormalisedEntireColumn = fFalse;
			}

		// Once we've fitted the field into the segment
		// maximum, may need to resize further to fit
		// into the total key space.
		if ( cbSeg > cbKeyAvail )
			{
			cbSeg = cbKeyAvail;
			fNormalisedEntireColumn = fFalse;
			*pfColumnTruncated = fTrue;
			}

		// At least one chunk, unless truncated.
		Assert( cbSeg > 0 );
		Assert( cbSeg > cbFLDBinaryChunkNormalized || !fNormalisedEntireColumn );
		
		INT 		cbSegRemaining = cbSeg - 1;	// account for header byte
		INT			cbFieldRemaining = cbField;
		BYTE		*pbSeg = rgbSeg + 1;	// skip header byte
		const BYTE	*pbNextChunk = pbField;
		while ( cbSegRemaining >= cbFLDBinaryChunkNormalized )
			{
			Assert( cbFieldRemaining > 0 );
			Assert( pbNextChunk + cbFieldRemaining == pbField + cbField );
	
			if ( cbFieldRemaining <= cbFLDBinaryChunk )
				{
				// This is the last chunk.
				Assert( cbSegRemaining - cbFLDBinaryChunkNormalized == 0 );
				UtilMemCpy( pbSeg, pbNextChunk, cbFieldRemaining );
				pbSeg += cbFieldRemaining;

				if ( NULL != pibBinaryColumnDelimiter )
					{
					Assert( 0 == *pibBinaryColumnDelimiter );
					*pibBinaryColumnDelimiter = ULONG( pbSeg - rgbSeg );
					}

				if ( cbFieldRemaining == cbFLDBinaryChunk )
					{
					// This allows us to differentiate between a
					// a column that is entirely normalised and ends
					// at the end of a chunk and one that is truncated
					// at the end of a chunk.
					if ( fNormalisedEntireColumn )
						*pbSeg++ = cbFLDBinaryChunkNormalized-1;
					else
						*pbSeg++ = cbFLDBinaryChunkNormalized;
					}
				else
					{
					// Zero out rest of chunk.
					memset( pbSeg, 0, cbFLDBinaryChunk - cbFieldRemaining );
					pbSeg += ( cbFLDBinaryChunk - cbFieldRemaining );
					*pbSeg++ = (BYTE)cbFieldRemaining;

					}
					
#ifdef DEBUG
				cbFieldRemaining = 0;
#endif				
				}
			else
				{
				UtilMemCpy( pbSeg, pbNextChunk, cbFLDBinaryChunk );
			
				pbNextChunk += cbFLDBinaryChunk;
				pbSeg += cbFLDBinaryChunk;
				*pbSeg++ = cbFLDBinaryChunkNormalized;

				cbFieldRemaining -= cbFLDBinaryChunk;
				}
				
			cbSegRemaining -= cbFLDBinaryChunkNormalized;
			}

		
		if ( cbSeg >= 1 + cbFLDBinaryChunkNormalized )
			{
			// Able to fit at least one chunk in.
			Assert( pbSeg >= rgbSeg + 1 + cbFLDBinaryChunkNormalized );
			Assert( pbSeg[-1] > 0 );
			Assert( pbSeg[-1] <= cbFLDBinaryChunkNormalized );
			
			// Must have ended up at the end of a chunk.
			Assert( ( pbSeg - ( rgbSeg + 1 ) ) % cbFLDBinaryChunkNormalized == 0 );
			}
		else
			{
			// Couldn't accommodate any chunks.
			Assert( pbSeg == rgbSeg + 1 );
			}

		Assert( cbSegRemaining >= 0 );
		Assert( cbSegRemaining < cbFLDBinaryChunkNormalized );
		if ( cbSegRemaining > 0 )
			{
			Assert( !fNormalisedEntireColumn );
			Assert( cbFieldRemaining > 0 );

			if ( cbFieldRemaining >= cbSegRemaining )
				{
				// Fill out remaining key space.
				UtilMemCpy( pbSeg, pbNextChunk, cbSegRemaining );
				}
			else
				{
				if ( NULL != pibBinaryColumnDelimiter )
					{
					Assert( 0 == *pibBinaryColumnDelimiter );
					*pibBinaryColumnDelimiter = ULONG( pbSeg + cbFieldRemaining - rgbSeg );
					}

				// Entire column will fit, but last bytes don't form
				// a complete chunk.  Pad with zeroes to end of available
				// key space.
				UtilMemCpy( pbSeg, pbNextChunk, cbFieldRemaining );
				memset( pbSeg+cbFieldRemaining, 0, cbSegRemaining - cbFieldRemaining );
				}
			}
		}

	Assert( cbSeg > 0 );
	*pcbSeg = cbSeg;
	}


INLINE VOID FLDNormalizeFixedSegment(
	const BYTE			*pbField,
	const ULONG			cbField,
	BYTE				*rgbSeg,
	INT					*pcbSeg,
	const JET_COLTYP	coltyp,
	BOOL				fDataPassedFromUser = fFalse )	// data in machine format, not necessary little endian format
	{
	WORD				wSrc;
	DWORD				dwSrc;
	QWORD				qwSrc;
	
	rgbSeg[0] = bPrefixData;
	switch ( coltyp )
		{
		//	BIT: prefix with 0x7f, flip high bit
		//
		case JET_coltypBit:
			Assert( 1 == cbField );
			*pcbSeg = 2;
			
			rgbSeg[1] = BYTE( pbField[0] == 0 ? 0x00 : 0xff );
			break;
			
		//	UBYTE: prefix with 0x7f
		//
		case JET_coltypUnsignedByte:
			Assert( 1 == cbField );
			*pcbSeg = 2;
			
			rgbSeg[1] = pbField[0];
			break;

		//	SHORT: prefix with 0x7f, flip high bit
		//
		case JET_coltypShort:
			Assert( 2 == cbField );
			*pcbSeg = 3;
			
			if ( fDataPassedFromUser )
				{
				wSrc = *(Unaligned< WORD >*)pbField;
				}
			else
				{
				wSrc = *(UnalignedLittleEndian< WORD >*)pbField;
				}
				
			*( (UnalignedBigEndian< WORD >*) &rgbSeg[ 1 ] ) = wFlipHighBit( wSrc );
			break;

		//*	LONG: prefix with 0x7f, flip high bit
		//
		//	works because of 2's complement *
		case JET_coltypLong:
			Assert( 4 == cbField );
			*pcbSeg = 5;
			
			if ( fDataPassedFromUser )
				{
				dwSrc = *(Unaligned< DWORD >*)pbField;
				}
			else
				{
				dwSrc = *(UnalignedLittleEndian< DWORD >*)pbField;
				}

			*( (UnalignedBigEndian< DWORD >*) &rgbSeg[ 1 ] ) = dwFlipHighBit( dwSrc );
			break;

		//	REAL: First swap bytes.  Then, if positive:
		//	flip sign bit, else negative: flip whole thing.
		//	Then prefix with 0x7f.
		//
		case JET_coltypIEEESingle:
			Assert( 4 == cbField );
			*pcbSeg = 5;
			
			if ( fDataPassedFromUser )
				{
				dwSrc = *(Unaligned< DWORD >*)pbField;
				}
			else
				{
				dwSrc = *(UnalignedLittleEndian< DWORD >*)pbField;
				}

			if ( dwSrc & maskDWordHighBit )
				{
				*( (UnalignedBigEndian< DWORD >*) &rgbSeg[ 1 ] ) = ~dwSrc;
				}
			else
				{
				*( (UnalignedBigEndian< DWORD >*) &rgbSeg[ 1 ] ) = dwFlipHighBit( dwSrc );
				}
			break;

		//	CURRENCY: First swap bytes.  Then, flip the sign bit
		//
		case JET_coltypCurrency:
			Assert( 8 == cbField );
			*pcbSeg = 9;
			
			if ( fDataPassedFromUser )
				{
				qwSrc = *(Unaligned< QWORD >*)pbField;
				}
			else
				{
				qwSrc = *(UnalignedLittleEndian< QWORD >*)pbField;
				}

			*( (UnalignedBigEndian< QWORD >*) &rgbSeg[ 1 ] ) = qwFlipHighBit( qwSrc );
			break;
		
		//	LONGREAL: First swap bytes.  Then, if positive:
		//	flip sign bit, else negative: flip whole thing.
		//	Then prefix with 0x7f.
		//
		//	Same for DATETIME
		//
		case JET_coltypIEEEDouble:
		case JET_coltypDateTime:
			Assert( 8 == cbField );
			*pcbSeg = 9;
			
			if ( fDataPassedFromUser )
				{
				qwSrc = *(Unaligned< QWORD >*)pbField;
				}
			else
				{
				qwSrc = *(UnalignedLittleEndian< QWORD >*)pbField;
				}

			if ( qwSrc & maskQWordHighBit )
				{
				*( (UnalignedBigEndian< QWORD >*) &rgbSeg[ 1 ] ) = ~qwSrc;
				}
			else
				{
				*( (UnalignedBigEndian< QWORD >*) &rgbSeg[ 1 ] ) = qwFlipHighBit( qwSrc );
				}
			break;

		default:
			Assert( !FRECTextColumn( coltyp ) );	// These types handled elsewhere.
			Assert( !FRECBinaryColumn( coltyp ) );
			Assert( fFalse );
			break;
		}
	}


INLINE VOID FLDNormalizeNullSegment(
	BYTE				*rgbSeg,
	const JET_COLTYP	coltyp,
	const BOOL			fZeroLength,
	const BOOL			fSortNullsHigh )
	{
	const BYTE			bPrefixNullT	= ( fSortNullsHigh ? bPrefixNullHigh : bPrefixNull );
	
	switch ( coltyp )
		{
		//	most nulls are represented by 0x00
		//	zero-length columns are represented by 0x40
		case JET_coltypBit:
		case JET_coltypUnsignedByte:
		case JET_coltypShort:
		case JET_coltypLong:
		case JET_coltypCurrency:
		case JET_coltypIEEESingle:
		case JET_coltypIEEEDouble:
		case JET_coltypDateTime:
			rgbSeg[0] = bPrefixNullT;
			break;
				
		default:
			Assert( FRECTextColumn( coltyp ) || FRECBinaryColumn( coltyp ) );
			rgbSeg[0] = ( fZeroLength ? bPrefixZeroLength : bPrefixNullT );
			break;
		}
	}


ERR ErrFLDNormalizeTaggedData(
	const FIELD		* pfield,
	const DATA&		dataRaw,
	DATA&			dataNorm,
	BOOL			* pfDataTruncated )
	{
	ERR				err		= JET_errSuccess;

	*pfDataTruncated = fFalse;

	if ( 0 == dataRaw.Cb() )
		{
		FLDNormalizeNullSegment(
				(BYTE *)dataNorm.Pv(),
				pfield->coltyp,
				fTrue,				//	cannot normalize NULL via this function
				fFalse );
		dataNorm.SetCb( 1 );
		}
	else
		{
		INT			cb		= 0;
		switch ( pfield->coltyp )
			{
			//	case-insensitive TEXT: convert to uppercase.
			//	If fixed, prefix with 0x7f;  else affix with 0x00
			//
			case JET_coltypText:
			case JET_coltypLongText:
				CallR( ErrFLDNormalizeTextSegment(
							(BYTE *)dataRaw.Pv(),
							dataRaw.Cb(),
							(BYTE *)dataNorm.Pv(),
							&cb,
							KEY::cbKeyMax,
							KEY::cbKeyMax,
							KEY::cbKeyMax+1,
							pfield->cp,
							&idxunicodeDefault ) );
				dataNorm.SetCb( cb );
				if ( wrnFLDKeyTooBig == err )
					{
					*pfDataTruncated = fTrue;
					err = JET_errSuccess;
					}
				CallS( err );
				Assert( dataNorm.Cb() > 0 );
				break;

			//	BINARY data: if fixed, prefix with 0x7f;
			//	else break into chunks of 8 bytes, affixing each
			//	with 0x09, except for the last chunk, which is
			//	affixed with the number of bytes in the last chunk.
			//
			case JET_coltypBinary:
			case JET_coltypLongBinary:
				FLDNormalizeBinarySegment(
						(BYTE *)dataRaw.Pv(),
						dataRaw.Cb(),
						(BYTE *)dataNorm.Pv(),
						&cb,
						KEY::cbKeyMax,
						KEY::cbKeyMax,
						KEY::cbKeyMax+1,
						fFalse,					//	only called for tagged columns
						pfDataTruncated,
						NULL );
				dataNorm.SetCb( cb );
				break;

			default:
				FLDNormalizeFixedSegment(
						(BYTE *)dataRaw.Pv(),
						dataRaw.Cb(),
						(BYTE *)dataNorm.Pv(),
						&cb,
						pfield->coltyp );
				dataNorm.SetCb( cb );
				break;
			}
		}

	return err;
	}


//+API
//	ErrRECIRetrieveKey
//	========================================================
//	ErrRECIRetrieveKey( FUCB *pfucb, TDB *ptdb, IDB *pidb, DATA *plineRec, KEY *pkey, ULONG itagSequence )
//
//	Retrieves the normalized key from a record, based on an index descriptor.
//
//	PARAMETERS
//		pfucb			cursor for record
//	 	ptdb		  	column info for index
// 		pidb		  	index key descriptor
// 		plineRec	  	data record to retrieve key from
// 		pkey		  	buffer to put retrieve key in; pkey->pv must
//						point to a large enough buffer, cbKeyMost bytes.
// 		itagSequence  	A secondary index whose key contains a tagged
//						column segment will have an index entry made for
//						each value of the tagged column, each refering to
//						the same record.  This parameter specifies which
//						occurance of the tagged column should be included
//						in the retrieve key.
//
//	RETURNS	Error code, one of:
//		JET_errSuccess		success
//		+wrnFLDNullKey	   	key has all NULL segments
//		+wrnFLDNullSeg	   	key has NULL segment
//
//	COMMENTS
//		Key formation is as follows:  each key segment is retrieved
//		from the record, transformed into a normalized form, and
//		complemented if it is "descending" in the key.	The key is
//		formed by concatenating each such transformed segment.
//-
ERR ErrRECIRetrieveKey(
	FUCB	  			*pfucb,
	const IDB			* const pidb,
	DATA&				lineRec,
	KEY	 				*pkey,
	const ULONG			itagSequence,
	const ULONG			ichOffset,
	const BOOL			fRetrieveLVBeforeImage,
	RCE					*prce )
	{
	ERR	 				err							= JET_errSuccess;
	FCB					* const pfcbTable			= pfucb->u.pfcb;
	FCB	 				* pfcb						= pfcbTable;
	BOOL	  			fAllNulls					= fTrue;	// Assume all null, until proven otherwise
	BOOL	  			fNullFirstSeg				= fFalse; 	// Assume no null first segment
	BOOL	  			fNullSeg					= fFalse;	// Assume no null segments
	BOOL	  			fColumnTruncated			= fFalse;
	BOOL	  			fKeyTruncated				= fFalse;
	BOOL	  			fSawMultivalue				= fFalse;
	const BOOL			fPageInitiallyLatched		= Pcsr( pfucb )->FLatched();
	BOOL				fPageLatched				= fPageInitiallyLatched;

	BYTE	  			*pbSeg;					  				// Pointer to current segment
	ULONG 				cbKeyAvail;				  				// Space remaining in key buffer
	const IDXSEG 		*pidxseg;
	const IDXSEG 		*pidxsegMac;
	IDXSEG				rgidxseg[JET_ccolKeyMost];
	IDXSEG				rgidxsegConditional[JET_ccolKeyMost];
	const BOOL			fOnRecord					= ( lineRec == pfucb->kdfCurr.data );
	BOOL				fTransactionStarted			= fFalse;
	const BOOL			fRetrieveBasedOnRCE			= ( prceNil != prce );
	BYTE				rgbLV[KEY::cbKeyMax];					// long value support

	Assert( pkey != NULL );
	Assert( !pkey->FNull() );
	Assert( pfcb->Ptdb() != ptdbNil );
	Assert( pidb != pidbNil );
	Assert( pidb->Cidxseg() > 0 );

	//	page is only latched if we're coming from CreateIndex
	if ( fPageInitiallyLatched )
		{
		Assert( fOnRecord );
		Assert( locOnCurBM == pfucb->locLogical );
		Assert( !fRetrieveLVBeforeImage );
		Assert( !fRetrieveBasedOnRCE );
		Assert( pfucb->ppib->level > 0 );
		}

	//	check cbVarSegMac and set to key most plus one if no column
	//	truncation enabled.  This must be done for subsequent truncation
	// 	checks.
	//
	const ULONG	cbKeyMost		= KEY::CbKeyMost( pidb->FPrimary() );

	Assert( pidb->CbVarSegMac() > 0 );
	Assert( pidb->CbVarSegMac() <= cbKeyMost );

	const ULONG cbVarSegMac		= ( cbKeyMost == pidb->CbVarSegMac() ?
										cbKeyMost+1 :
										pidb->CbVarSegMac() );
	Assert( cbVarSegMac > 0 );
	Assert( cbVarSegMac < cbKeyMost || cbVarSegMac == cbKeyMost+1 );

	const BOOL	fSortNullsHigh	= pidb->FSortNullsHigh();


	//	start at beginning of buffer, with max size remaining.
	//
	Assert( pkey->prefix.FNull() );
	pbSeg = (BYTE *)pkey->suffix.Pv();
	cbKeyAvail = cbKeyMost;

	//	fRetrieveFromLVBuf flags whether or not we have to check in the LV buffer.
	//	We only check in the LV buffer if one exists, and if we are looking for the
	//	before-image (as specified by the parameter passed in).  Assert that this
	//	only occurs during a Replace.
	//
	Assert( fRetrieveBasedOnRCE
		|| !fRetrieveLVBeforeImage
		|| FFUCBReplacePrepared( pfucb ) );

	//	retrieve each segment in key description
	//
	if ( pidb->FTemplateIndex() )
		{
		Assert( pfcb->FDerivedTable() || pfcb->FTemplateTable() );
		if ( pfcb->FDerivedTable() )
			{
			// switch to template table
			pfcb = pfcb->Ptdb()->PfcbTemplateTable();
			Assert( pfcbNil != pfcb );
			Assert( pfcb->FTemplateTable() );
			}
		else
			{
			Assert( pfcb->Ptdb()->PfcbTemplateTable() == pfcbNil );
			}
		}

	pfcb->EnterDML();
	UtilMemCpy( rgidxseg, PidxsegIDBGetIdxSeg( pidb, pfcb->Ptdb() ), pidb->Cidxseg() * sizeof(IDXSEG) );
	UtilMemCpy( rgidxsegConditional, PidxsegIDBGetIdxSegConditional( pidb, pfcb->Ptdb() ), pidb->CidxsegConditional() * sizeof(IDXSEG) );
	pfcb->LeaveDML();

	//	if we're looking at a record, then make sure we're in
	//	a transaction to ensure read consistency
	if ( fOnRecord && 0 == pfucb->ppib->level )
		{
		Assert( !fPageInitiallyLatched );
		Assert( !Pcsr( pfucb )->FLatched() );

		//	UNDONE: only time we're not in a transaction is if we got
		//	here via ErrRECIGotoBookmark() -- can it be eliminated??
		CallR( ErrDIRBeginTransaction( pfucb->ppib, JET_bitTransactionReadOnly ) );
		fTransactionStarted = fTrue;
		}

	//  if the idxsegConditional doesn't match return wrnFLDRecordNotPresentInIndex
	pidxseg = rgidxsegConditional;	
	pidxsegMac = pidxseg + pidb->CidxsegConditional();
	for ( ; pidxseg < pidxsegMac; pidxseg++ )
		{		
		const COLUMNID	columnidConditional 	= pidxseg->Columnid();
		const BOOL		fMustBeNull				= pidxseg->FMustBeNull();
		BOOL			fColumnIsNull			= fFalse;
		DATA   			dataField;

		if ( fOnRecord && !fPageLatched )
			{
			Assert( !fPageInitiallyLatched || locOnCurBM == pfucb->locLogical );
			Call( ErrDIRGet( pfucb ) );
			fPageLatched = fTrue;
			}

#ifdef DEBUG
		//	page should be latched iff key is retrieved from record
		if ( fOnRecord )
			{
			Assert( Pcsr( pfucb )->FLatched() );
			}
		else
			{
			Assert( !Pcsr( pfucb )->FLatched() );
			}
#endif	//	DEBUG

		//	get segment value:
		Assert( !lineRec.FNull() );
		if ( FCOLUMNIDTagged( columnidConditional ) )
			{
			err = ErrRECRetrieveTaggedColumn(
						pfcbTable,
						columnidConditional,
						1,
						lineRec,
						&dataField );

			if( wrnRECUserDefinedDefault == err )
				{
				//  if this is a user-defined default we should execute the callback
				//  and let the callback possibly return JET_wrnColumnNull
				
				//  release the page and retrieve the appropriate copy of the user-defined-default
				if ( fPageLatched )
					{
					Assert( !fPageInitiallyLatched || locOnCurBM == pfucb->locLogical );
					CallS( ErrDIRRelease( pfucb ) );
					fPageLatched = fFalse;
					}

				//  if we aren't on the record we'll point the copy buffer to the record and
				//  retrieve from there. save off the old value
				DATA	dataSaved	= pfucb->dataWorkBuf;

				const BOOL fAlwaysRetrieveCopy 	= FFUCBAlwaysRetrieveCopy( pfucb );
				const BOOL fNeverRetrieveCopy	= FFUCBNeverRetrieveCopy( pfucb );

				Assert( !( fAlwaysRetrieveCopy && fNeverRetrieveCopy ) );

				if( fOnRecord )
					{
					FUCBSetNeverRetrieveCopy( pfucb );
					}
				else
					{
					pfucb->dataWorkBuf = lineRec;
					FUCBSetAlwaysRetrieveCopy( pfucb );
					}

#ifdef SYNC_DEADLOCK_DETECTION
				//  At this point we have the Indexing/Updating latch
				//  turn off the checks to avoid asserts
				COwner * pownerSaved;
				UtilAssertCriticalSectionCanDoIO();
				pownerSaved = Pcls()->pownerLockHead;
#endif	//	SYNC_DEADLOCK_DETECTION

				ULONG	cbActual	= sizeof( rgbLV );
				err = ErrRECCallback(
					pfucb->ppib,		
					pfucb,
					JET_cbtypUserDefinedDefaultValue,
					columnidConditional,
					NULL,
					&cbActual,
					columnidConditional );

#ifdef SYNC_DEADLOCK_DETECTION
				Assert( Pcls()->pownerLockHead == pownerSaved );
#endif	//	SYNC_DEADLOCK_DETECTION

				pfucb->dataWorkBuf = dataSaved;
				FUCBResetAlwaysRetrieveCopy( pfucb );
				FUCBResetNeverRetrieveCopy( pfucb );

				if( fAlwaysRetrieveCopy )
					{
					FUCBSetAlwaysRetrieveCopy( pfucb );
					}
				else if ( fNeverRetrieveCopy )
					{
					FUCBSetNeverRetrieveCopy( pfucb );
					}

				Call( err );
				}
			}
		else
			{
			err = ErrRECRetrieveNonTaggedColumn(
						pfcbTable,
						columnidConditional,
						lineRec,
						&dataField,
						pfieldNil );
			}
		Assert( err >= 0 );

		fColumnIsNull = ( JET_wrnColumnNull == err );
		
		if( fMustBeNull && !fColumnIsNull )
			{
			err = ErrERRCheck( wrnFLDNotPresentInIndex );
			goto HandleError;
			}
		else if( !fMustBeNull && fColumnIsNull )
			{
			err = ErrERRCheck( wrnFLDNotPresentInIndex );
			goto HandleError;
			}
		}
		
	pidxseg = rgidxseg;	
	pidxsegMac = pidxseg + pidb->Cidxseg();
	for ( ; pidxseg < pidxsegMac; pidxseg++ )
		{
		FIELD 			field;
		BYTE   			*pbField;						// pointer to column data.
		ULONG			cbField;						// length of column data.
		BYTE   			rgbSeg[ KEY::cbKeyMax ]; 		// segment buffer.
		DATA 	  		dataField;
		INT				cbSeg		= 0;				// length of segment.
		const COLUMNID	columnid	= pidxseg->Columnid();
		const BOOL		fDescending	= pidxseg->FDescending();
		const BOOL		fFixedField	= FCOLUMNIDFixed( columnid );

		// No need to check column access -- since the column belongs
		// to an index, it MUST be available.  It can't be deleted, or
		// even versioned deleted.
		pfcb->EnterDML();
		field = *( pfcb->Ptdb()->Pfield( columnid ) );
		pfcb->LeaveDML();

		Assert( !FFIELDDeleted( field.ffield ) );
		Assert( JET_coltypNil != field.coltyp );
		Assert( !FCOLUMNIDVar( columnid ) || field.coltyp == JET_coltypBinary || field.coltyp == JET_coltypText );
		Assert( !FFIELDMultivalued( field.ffield ) || FCOLUMNIDTagged( columnid ) );

		if ( fOnRecord && !fPageLatched )
			{
			// Obtain latch only if we're retrieving from the record and
			// this is the first time through, or if we had to give
			// up the latch on a previous iteration.
			Assert( !fPageInitiallyLatched || locOnCurBM == pfucb->locLogical );
			Call( ErrDIRGet( pfucb ) );
			fPageLatched = fTrue;
			}

		//	page should be latched iff key is retrieved from record
		//
		if ( fOnRecord )
			{
			Assert( Pcsr( pfucb )->FLatched() );
			}
		else
			{
			Assert( !Pcsr( pfucb )->FLatched() );
			}

		//	get segment value:
		Assert( !lineRec.FNull() );
		if ( FCOLUMNIDTagged( columnid ) )
			{
			err = ErrRECRetrieveTaggedColumn(
						pfcbTable,
						columnid,
						( FFIELDMultivalued( field.ffield ) && !fSawMultivalue ) ? itagSequence : 1,
						lineRec,
						&dataField );
			}
		else
			{
			err = ErrRECRetrieveNonTaggedColumn(
						pfcbTable,
						columnid,
						lineRec,
						&dataField,
						&field );
			}
		Assert( err >= 0 );

		//	with no space left in the key buffer we cannot insert any more 
		//	normalised keys
		//
		if ( cbKeyAvail == 0 )
			{
			fKeyTruncated = fTrue;

			//	only one column in a tuple index, so we're guaranteed
			//	to always have available key space
			Assert( !pidb->FTuples() );

			//	check if column is NULL for tagged column support
			//
			if ( JET_wrnColumnNull == err )
				{
				//	cannot be all NULL and cannot be first NULL
				//	since key truncated.
				//
				Assert( itagSequence >= 1 );
				if ( itagSequence > 1
					&& FFIELDMultivalued( field.ffield )
					&& !fSawMultivalue )
					{
					err = ErrERRCheck( wrnFLDOutOfKeys );
					goto HandleError;
					}
				else
					{
					if ( pidxseg == rgidxseg )
						fNullFirstSeg = fTrue;
					fNullSeg = fTrue;
					}
				}

			Assert( JET_errSuccess == err
				|| wrnRECSeparatedLV == err
				|| wrnRECIntrinsicLV == err
				|| wrnRECUserDefinedDefault == err
				|| JET_wrnColumnNull == err );
			err = JET_errSuccess;
			
			if ( FFIELDMultivalued( field.ffield ) )
				fSawMultivalue = fTrue;
				
			continue;
			}

		Assert( cbKeyAvail > 0 );
		if ( wrnRECUserDefinedDefault == err )
			{
			//  release the page and retrieve the appropriate copy of the user-defined-default
			if ( fPageLatched )
				{
				Assert( !fPageInitiallyLatched || locOnCurBM == pfucb->locLogical );
				CallS( ErrDIRRelease( pfucb ) );
				fPageLatched = fFalse;
				}

			//  if we aren't on the record we'll point the copy buffer to the record and
			//  retrieve from there. save off the old value
			DATA dataSaved = pfucb->dataWorkBuf;

			const BOOL fAlwaysRetrieveCopy 	= FFUCBAlwaysRetrieveCopy( pfucb );
			const BOOL fNeverRetrieveCopy	= FFUCBNeverRetrieveCopy( pfucb );

			Assert( !( fAlwaysRetrieveCopy && fNeverRetrieveCopy ) );
			
			if( fOnRecord )
				{
				FUCBSetNeverRetrieveCopy( pfucb );
				}
			else
				{
				pfucb->dataWorkBuf = lineRec;
				FUCBSetAlwaysRetrieveCopy( pfucb );
				}

#ifdef SYNC_DEADLOCK_DETECTION
			//  At this point we have the Indexing/Updating latch
			//  turn off the checks to avoid asserts
			COwner * pownerSaved;
			UtilAssertCriticalSectionCanDoIO();
			pownerSaved = Pcls()->pownerLockHead;
#endif	//	SYNC_DEADLOCK_DETECTION

			ULONG cbActual;
			cbActual = sizeof( rgbLV );
			err = ErrRECCallback(
				pfucb->ppib,		
				pfucb,
				JET_cbtypUserDefinedDefaultValue,
				columnid,
				rgbLV,
				&cbActual,
				columnid );

#ifdef SYNC_DEADLOCK_DETECTION
			Assert( Pcls()->pownerLockHead == pownerSaved );
#endif	//	SYNC_DEADLOCK_DETECTION

			pfucb->dataWorkBuf = dataSaved;
			FUCBResetAlwaysRetrieveCopy( pfucb );
			FUCBResetNeverRetrieveCopy( pfucb );

			if( fAlwaysRetrieveCopy )
				{
				FUCBSetAlwaysRetrieveCopy( pfucb );
				}
			else if ( fNeverRetrieveCopy )
				{
				FUCBSetNeverRetrieveCopy( pfucb );
				}

			Call( err );

			dataField.SetPv( rgbLV );
			dataField.SetCb( min( cbActual, sizeof(rgbLV) ) );

			if ( JET_wrnBufferTruncated == err )
				err = JET_errSuccess;
			}

		else if ( wrnRECSeparatedLV == err )
			{
			const LID	lid				= LidOfSeparatedLV( dataField );
			const BOOL	fAfterImage		= !fRetrieveLVBeforeImage;
			ULONG		cbActual;

			if ( fRetrieveBasedOnRCE )
				{
				Assert( !fOnRecord );
				Assert( !fPageLatched );
				Assert( !fPageInitiallyLatched );
				Assert( !Pcsr( pfucb )->FLatched() );

				Assert( prceNil != prce );
				Assert( prce->TrxCommitted() != trxMax
						|| ppibNil != prce->Pfucb()->ppib );
				Call( ErrRECGetLVImageOfRCE(
							pfucb,
							lid,
							prce,
							fAfterImage,
							rgbLV,
							cbKeyMost,
							&cbActual ) );

				// Verify all latches released after LV call.
				Assert( !Pcsr( pfucb )->FLatched() );
					
				dataField.SetPv( rgbLV );
				dataField.SetCb( cbActual );
				}
			
			// First check in the LV buffer (if allowed).
			else
				{
				Assert( prceNil == prce );

				if ( fPageLatched )
					{
					Assert( !fPageInitiallyLatched || locOnCurBM == pfucb->locLogical );
					CallS( ErrDIRRelease( pfucb ) );
					fPageLatched = fFalse;
					}

				Call( ErrRECGetLVImage(
							pfucb,
							lid,
							fAfterImage,
							rgbLV,
							cbKeyMost,
							&cbActual ) );

				// Verify all latches released after LV call.
				Assert( !Pcsr( pfucb )->FLatched() );

				dataField.SetPv( rgbLV );
				dataField.SetCb( cbActual );
				}

			// Trim returned value if necessary.
			if ( dataField.Cb() > cbKeyMost )
				dataField.SetCb( cbKeyMost );

			Assert( JET_wrnColumnNull != err );
			err = JET_errSuccess;
			}
		else if ( wrnRECIntrinsicLV == err )
			{
			// Trim returned value if necessary.
			if ( dataField.Cb() > cbKeyMost )
				{
				dataField.SetCb( cbKeyMost );
				}
			err = JET_errSuccess;
			}
		else
			{
			CallSx( err, JET_wrnColumnNull );
			}

		if ( FFIELDMultivalued( field.ffield ) && !fSawMultivalue )
			{
			if ( itagSequence > 1 && JET_wrnColumnNull == err )
				{
				err = ErrERRCheck( wrnFLDOutOfKeys );
				goto HandleError;
				}
			fSawMultivalue = fTrue;
			}

		CallSx( err, JET_wrnColumnNull );
		Assert( dataField.Cb() <= cbKeyMost );
		cbField = dataField.Cb();
		pbField = (BYTE *)dataField.Pv();

		if ( pidb->FTuples() )
			{
			Assert( FRECTextColumn( field.coltyp ) );

			//	caller should have verified whether we've
			//	exceeded maximum allowable characters to
			//	index in this string 
			Assert( ichOffset < pidb->ChTuplesToIndexMax() );

			//	normalise counts to account for Unicode
			Assert( usUniCodePage != field.cp || cbField % 2 == 0 || cbKeyMost == cbField );
			const ULONG		ibOffset	= ( usUniCodePage == field.cp ? ichOffset * 2 : ichOffset );
			const ULONG		chField		= ( usUniCodePage == field.cp ? cbField / 2 : cbField );
			const ULONG		cbFieldMax	= ( usUniCodePage == field.cp ? pidb->ChTuplesLengthMax() * 2 : pidb->ChTuplesLengthMax() );

			//	if column is NULL or if tuple begins beyond end
			//	of column, or tuple is not large enough, bail out
			if ( JET_wrnColumnNull == err
				|| ibOffset >= cbField
				|| chField - ichOffset < pidb->ChTuplesLengthMin() )
				{
				err = ErrERRCheck( wrnFLDOutOfTuples );
				goto HandleError;
				}
			else
				{
				Assert( pbField + ibOffset <= pbField + cbField );
				pbField += ibOffset;
				cbField = min( cbField - ibOffset, cbFieldMax );
				}
			}

		//	segment transformation: check for null column or zero-length columns first
		//	err == JET_wrnColumnNull => Null column
		//	zero-length column otherwise,
		//
		Assert( cbKeyAvail > 0 );
		if ( JET_wrnColumnNull == err || pbField == NULL || cbField == 0 )
			{
			if ( JET_wrnColumnNull == err )
				{
				if ( pidxseg == rgidxseg )
					fNullFirstSeg = fTrue;
				fNullSeg = fTrue;
				}
			else
				{
				// Only variable-length binary and text columns
				// can be zero-length.
				Assert( !fFixedField );
				Assert( FRECTextColumn( field.coltyp ) || FRECBinaryColumn( field.coltyp ) );
				fAllNulls = fFalse;
				}

			FLDNormalizeNullSegment(
					rgbSeg,
					field.coltyp,
					JET_wrnColumnNull != err,
					fSortNullsHigh );
			cbSeg = 1;
			}

		else
			{
			//	column is not null-valued: perform transformation
			//
			fAllNulls = fFalse;

			switch ( field.coltyp )
				{
				//	case-insensetive TEXT: convert to uppercase.
				//	If fixed, prefix with 0x7f;  else affix with 0x00
				//
				case JET_coltypText:
				case JET_coltypLongText:
					Call( ErrFLDNormalizeTextSegment(
								pbField,
								cbField,
								rgbSeg,
								&cbSeg,
								cbKeyAvail,
								cbKeyMost,
								cbVarSegMac,
								field.cp,
								pidb->Pidxunicode() ) );
					Assert( JET_errSuccess == err || wrnFLDKeyTooBig == err );
					if ( wrnFLDKeyTooBig == err )
						{
						fColumnTruncated = fTrue;
						err = JET_errSuccess;
						}
					Assert( cbSeg > 0 );
					break;

				//	BINARY data: if fixed, prefix with 0x7f;
				//	else break into chunks of 8 bytes, affixing each
				//	with 0x09, except for the last chunk, which is
				//	affixed with the number of bytes in the last chunk.
				//
				case JET_coltypBinary:
				case JET_coltypLongBinary:
					FLDNormalizeBinarySegment(
							pbField,
							cbField,
							rgbSeg,
							&cbSeg,
							cbKeyAvail,
							cbKeyMost,
							cbVarSegMac,
							fFixedField,
							&fColumnTruncated,
							NULL );
					break;

				default:
					FLDNormalizeFixedSegment(
							pbField,
							cbField,
							rgbSeg,
							&cbSeg,
							field.coltyp );
					break;
				}
			}

		//	if key has not already been truncated, then append
		//	normalized key segment.  If insufficient room in key
		//	for key segment, then set key truncated to fTrue.  No
		//	additional key data will be appended after this append.
		//
		if ( !fKeyTruncated )
			{
			//	if column truncated or insufficient room in key
			//	for key segment, then set key truncated to fTrue.
			//	Append variable size column keys only.
			//
			if ( fColumnTruncated )
				{
				fKeyTruncated = fTrue;

				Assert( FRECTextColumn( field.coltyp ) || FRECBinaryColumn( field.coltyp ) );

				// If truncating, in most cases, we fill up as much
				// key space as possible.  The only exception is
				// for non-fixed binary columns, which are
				// broken up into chunks.
				if ( cbSeg != cbKeyAvail )
					{
					Assert( cbSeg < cbKeyAvail );
					Assert( !fFixedField );
					Assert( FRECBinaryColumn( field.coltyp ) );
					Assert( cbKeyAvail - cbSeg < cbFLDBinaryChunkNormalized );
					}
				}
			else if ( cbSeg > cbKeyAvail )
				{
				fKeyTruncated = fTrue;

				// Put as much as possible into the key space.
				cbSeg = cbKeyAvail;
				}

			//	if descending, flip all bits of transformed segment
			//
			if ( fDescending && cbSeg > 0 )
				{
				BYTE *pb;

				for ( pb = rgbSeg + cbSeg - 1; pb >= (BYTE*)rgbSeg; pb-- )
					*pb ^= 0xff;
				}

			Assert( cbKeyAvail >= cbSeg );
			UtilMemCpy( pbSeg, rgbSeg, cbSeg );
			pbSeg += cbSeg;
			cbKeyAvail -= cbSeg;
			}
			
		}	// for

	//	compute length of key and return error code
	//
	Assert( pkey->prefix.FNull() );
	pkey->suffix.SetCb( pbSeg - (BYTE *) pkey->suffix.Pv() );
	if ( fAllNulls )
		err = ErrERRCheck( wrnFLDNullKey );
	else if ( fNullFirstSeg )
		err = ErrERRCheck( wrnFLDNullFirstSeg );
	else if ( fNullSeg )
		err = ErrERRCheck( wrnFLDNullSeg );

#ifdef DEBUG
	switch ( err )
		{
		case wrnFLDNullKey:
		case wrnFLDNullFirstSeg:
		case wrnFLDNullSeg:
			break;
		default:
			CallS( err );
		}
#endif		
		
HandleError:
	if ( fPageLatched )
		{
		if ( !fPageInitiallyLatched )
			{
			CallS( ErrDIRRelease( pfucb ) );
			}
		}
	else if ( fPageInitiallyLatched && err >= 0 )
		{
		const ERR	errT	= ErrBTGet( pfucb );
		if ( errT < 0 )
			err = errT;
		}
	Assert( !fPageInitiallyLatched || locOnCurBM == pfucb->locLogical );

	if ( fTransactionStarted )
		{
		//	No updates performed, so force success.
		Assert( fOnRecord );
		Assert( !fPageInitiallyLatched );
		CallS( ErrDIRCommitTransaction( pfucb->ppib, NO_GRBIT ) );
		}
	
	return err;
	}


INLINE VOID FLDISetFullColumnLimit(
	DATA		* const plineNorm,
	const ULONG	cbAvailWithSuffix,
	const BOOL	fNeedSentinel )
	{
	if ( fNeedSentinel )
		{
		Assert( cbAvailWithSuffix > 0 );
		Assert( cbAvailWithSuffix <= cbKeyMostWithOverhead );
		Assert( plineNorm->Cb() < cbAvailWithSuffix );

		BYTE	* const pbNorm				= (BYTE *)plineNorm->Pv() + plineNorm->Cb();
		const	ULONG	cbSentinelPadding	= cbAvailWithSuffix - plineNorm->Cb();

		//	pad rest of key space with 0xff
		memset( pbNorm, bSentinel, cbSentinelPadding );
		plineNorm->DeltaCb( cbSentinelPadding );
		}
	}

INLINE VOID FLDISetPartialColumnLimitOnTextColumn(
	DATA			*plineNorm,
	const ULONG		cbAvailWithSuffix,
	const BOOL		fDescending,
	const BOOL		fNeedSentinel,
	const USHORT	cp )
	{
	ULONG			ibT;
	const ULONG		ibSuffix			= cbAvailWithSuffix - 1; 
	BYTE			* const pbNorm		= (BYTE *)plineNorm->Pv();

	Assert( plineNorm->Cb() > 0 );		//	must be at least a prefix byte
	Assert( cbAvailWithSuffix > 0 );					//	Always have a suffix byte reserved for limit purposes
	Assert( cbAvailWithSuffix <= cbKeyMostWithOverhead );
	Assert( plineNorm->Cb() < cbAvailWithSuffix );

	if ( plineNorm->Cb() < 2 )
		{
		//	cannot effect partial column limit,
		//	so set full column limit instead
		FLDISetFullColumnLimit( plineNorm, cbAvailWithSuffix, fNeedSentinel );
		return;
		}

	if ( usUniCodePage == cp )
		{
		const BYTE	bUnicodeDelimiter	= BYTE( fDescending ? 0xfe : 0x01 );

		//	find end of base char weight and truncate key
		//	Append 0xff as first byte of next character as maximum
		//	possible value.
		//
		for ( ibT = 1;		//	skip header byte
			pbNorm[ibT] != bUnicodeDelimiter && ibT < ibSuffix;
			ibT += 2 )
			;
		}
	else
		{
		const BYTE	bTerminator			= BYTE( fDescending ? 0xff : 0x00 );

		ibT = plineNorm->Cb();

		if ( bTerminator == pbNorm[ibT-1] )
			{
			// Strip off null-terminator.
			ibT--;
			Assert( plineNorm->Cb() >= 1 );
			}
		else
			{
			//	must be at the end of key space
			Assert( plineNorm->Cb() == ibSuffix );
			}

		Assert( ibT <= ibSuffix );
		}

	ibT = min( ibT, ibSuffix );
	if ( fNeedSentinel )
		{
		//	starting at the delimiter, fill the rest of key
		//	space with the sentinel
		memset(
			pbNorm + ibT,
			bSentinel,
			ibSuffix - ibT + 1 );
		plineNorm->SetCb( cbAvailWithSuffix );
		}
	else
		{
		//	just strip off delimeter (or suffix byte if we spilled over it)
		plineNorm->SetCb( ibT );
		}
	}


//	try to set partial column limit, but set full column limit if can't
INLINE VOID FLDITrySetPartialColumnLimitOnBinaryColumn(
	DATA			* const plineNorm,
	const ULONG		cbAvailWithSuffix,
	const ULONG		ibBinaryColumnDelimiter,
	const BOOL		fNeedSentinel )
	{
	Assert( plineNorm->Cb() > 0 );		//	must be at least a prefix byte
	Assert( cbAvailWithSuffix > 0 );					//	Always have a suffix byte reserved for limit purposes
	Assert( cbAvailWithSuffix <= cbKeyMostWithOverhead );
	Assert( plineNorm->Cb() < cbAvailWithSuffix );

#ifdef DEBUG
	if ( 0 != ibBinaryColumnDelimiter )
		{
		Assert( plineNorm->Cb() > 1 );
		Assert( ibBinaryColumnDelimiter > 1 );
		Assert( ibBinaryColumnDelimiter < plineNorm->Cb() );
		}
#endif		

	if ( 0 == ibBinaryColumnDelimiter )
		{
		//	cannot effect partial column limit,
		//	so set full column limit instead
		FLDISetFullColumnLimit( plineNorm, cbAvailWithSuffix, fNeedSentinel );
		}
	else if ( fNeedSentinel )
		{
		//	starting at the delimiter, fill up to the end
		//	of the chunk with the sentinel
		//	UNDONE (jliem): go one past just to be safe, but I
		//	couldn't prove whether or not it is really needed
		plineNorm->DeltaCb( 1 );
		memset(
			(BYTE *)plineNorm->Pv() + ibBinaryColumnDelimiter,
			bSentinel,
			plineNorm->Cb() - ibBinaryColumnDelimiter );
		}
	else
		{
		//	just strip off delimiting bytes
		plineNorm->SetCb( ibBinaryColumnDelimiter );
		}
	}


LOCAL ERR ErrFLDNormalizeSegment(
	FUCB				* const pfucb,
	IDB					* const pidb,
	DATA				* const plineColumn,
	DATA				* const plineNorm,
	const JET_COLTYP	coltyp,
	const USHORT		cp,
	const ULONG			cbAvail,
	const BOOL			fDescending,
	const BOOL			fFixedField,
	const JET_GRBIT		grbit )
	{
	INT	 	  			cbColumn;
	BYTE 				* pbColumn;
	BYTE				* const pbNorm				= (BYTE *)plineNorm->Pv();
	ULONG				ibBinaryColumnDelimiter		= 0;

		
	//	check cbVarSegMac and set to key most plus one if no column
	//	truncation enabled.  This must be done for subsequent truncation
	// 	checks.
	//
	const ULONG	cbKeyMost		= KEY::CbKeyMost( pidb->FPrimary() );
	
	Assert( pidb->CbVarSegMac() > 0 );
	Assert( pidb->CbVarSegMac() <= cbKeyMost );
	
	const ULONG cbVarSegMac		= ( cbKeyMost == pidb->CbVarSegMac() ?
										cbKeyMost+1 :
										pidb->CbVarSegMac() );
	Assert( cbVarSegMac > 0 );
	Assert( cbVarSegMac < cbKeyMost || cbVarSegMac == cbKeyMost+1 );

	const BOOL	fSortNullsHigh	= pidb->FSortNullsHigh();


	//	check for null or zero-length column first
	//	plineColumn == NULL implies null-column,
	//	zero-length otherwise
	//
	Assert( !FKSTooBig( pfucb ) );
	Assert( cbAvail > 0 );
	if ( NULL == plineColumn || NULL == plineColumn->Pv() || 0 == plineColumn->Cb() )
		{
		if ( pidb->FTuples() )
			{
			Assert( FRECTextColumn( coltyp ) );
			Assert( pidb->ChTuplesLengthMin() > 0 );
			return ErrERRCheck( JET_errIndexTuplesKeyTooSmall );
			}
		else
			{
			// Only variable binary and text columns can be zero-length.
			Assert( !( grbit & JET_bitKeyDataZeroLength ) || !fFixedField );
			
			const BOOL	fZeroLength = !fFixedField && ( grbit & JET_bitKeyDataZeroLength );
			Assert( FRECTextColumn( coltyp )
				|| FRECBinaryColumn( coltyp )
				|| !fZeroLength );
			FLDNormalizeNullSegment(
					pbNorm,
					coltyp,
					fZeroLength,
					fSortNullsHigh );
			plineNorm->SetCb( 1 );
			}
		}
		
	else
		{
		INT		cbSeg	= 0;

		cbColumn = plineColumn->Cb();
		pbColumn = (BYTE *)plineColumn->Pv();

		switch ( coltyp )
			{
			//	case-insensetive TEXT:	convert to uppercase.
			//	If fixed, prefix with 0x7f;  else affix with 0x00
			//
			case JET_coltypText:
			case JET_coltypLongText:
				{
				if ( pidb->FTuples() )
					{
					Assert( FRECTextColumn( coltyp ) );

					//	normalise counts to account for Unicode
					Assert( usUniCodePage != cp || cbColumn % 2 == 0 );
					const ULONG		chColumn	= ( usUniCodePage == cp ? cbColumn / 2 : cbColumn );
					const ULONG		cbColumnMax	= ( usUniCodePage == cp ? pidb->ChTuplesLengthMax() * 2 : pidb->ChTuplesLengthMax() );

					//	if data is not large enough, bail out
					if ( chColumn < pidb->ChTuplesLengthMin() )
						{
						return ErrERRCheck( JET_errIndexTuplesKeyTooSmall );
						}
					else
						{
						cbColumn = min( cbColumn, cbColumnMax );
						}
					}
				
				const ERR	errNorm		= ErrFLDNormalizeTextSegment(
												pbColumn,
												cbColumn,
												pbNorm,
												&cbSeg,
												cbAvail,
												cbKeyMost,
												cbVarSegMac,
												cp,
												pidb->Pidxunicode() );
				if ( errNorm < 0 )
					return errNorm;
				else if ( wrnFLDKeyTooBig == errNorm )
					KSSetTooBig( pfucb );
				else
					CallS( errNorm );

				Assert( cbSeg > 0 );
				break;
				}

			//	BINARY data: if fixed, prefix with 0x7f;
			//	else break into chunks of 8 bytes, affixing each
			//	with 0x09, except for the last chunk, which is
			//	affixed with the number of bytes in the last chunk.
			//
			case JET_coltypBinary:
			case JET_coltypLongBinary:
				{
				BOOL	fColumnTruncated = fFalse;
				Assert( FRECBinaryColumn( coltyp ) );
				FLDNormalizeBinarySegment(
						pbColumn,
						cbColumn,
						pbNorm,
						&cbSeg,
						cbAvail,
						cbKeyMost,
						cbVarSegMac,
						fFixedField,
						&fColumnTruncated,
						&ibBinaryColumnDelimiter );
				if ( fColumnTruncated )
					{
					KSSetTooBig( pfucb );
					}
				break;
				}

			default:
				FLDNormalizeFixedSegment(
						pbColumn,
						cbColumn,
						pbNorm,
						&cbSeg,
						coltyp,
						fTrue /* data is passed by user, in machine format */);
				if ( cbSeg > cbAvail )
					{
					cbSeg = cbAvail;
					KSSetTooBig( pfucb );
					}
				break;
			}
			
		Assert( cbSeg <= cbAvail );
		plineNorm->SetCb( cbSeg );
		}


	if ( fDescending )
		{
		BYTE *pbMin = (BYTE *)plineNorm->Pv();
		BYTE *pb = pbMin + plineNorm->Cb() - 1;
		while ( pb >= pbMin )
			*pb-- ^= 0xff;
		}

	//	string and substring limit key support
	//	NOTE:  The difference between the two is that StrLimit appends 0xff to the end of
	//	key space for any column type, while SubStrLimit only works on text columns and
	//	will strip the trailing null terminator of the string before appending 0xff to the
	//	end of key space.
	//
	Assert( plineNorm->Cb() < cbAvail + 1 );	//	should always be room for suffix byte
	switch ( grbit & JET_maskLimitOptions )
		{
		case JET_bitFullColumnStartLimit:
		case JET_bitFullColumnEndLimit:
			FLDISetFullColumnLimit( plineNorm, cbAvail + 1, grbit & JET_bitFullColumnEndLimit );
			KSSetLimit( pfucb );
			break;
		case JET_bitPartialColumnStartLimit:
		case JET_bitPartialColumnEndLimit:
			if ( FRECTextColumn( coltyp ) )
				{
				FLDISetPartialColumnLimitOnTextColumn(
						plineNorm,
						cbAvail + 1,		//	+1 for suffix byte
						fDescending,
						grbit & JET_bitPartialColumnEndLimit,
						cp );
				}
			else
				{
				FLDITrySetPartialColumnLimitOnBinaryColumn(
						plineNorm,
						cbAvail + 1,		//	+1 for suffix byte
						ibBinaryColumnDelimiter,
						grbit & JET_bitPartialColumnEndLimit );
				}
			KSSetLimit( pfucb );
			break;
		default:
			{
			Assert( !( grbit & JET_maskLimitOptions ) );
			if ( ( grbit & JET_bitSubStrLimit )
				&& FRECTextColumn( coltyp ) )
				{
				FLDISetPartialColumnLimitOnTextColumn(
						plineNorm,
						cbAvail + 1,		//	+1 for suffix byte
						fDescending,
						fTrue,
						cp );
				KSSetLimit( pfucb );
				}
			else if ( grbit & JET_bitStrLimit )
				{
				FLDITrySetPartialColumnLimitOnBinaryColumn(
						plineNorm,
						cbAvail + 1,		//	+1 for suffix byte
						ibBinaryColumnDelimiter,
						fTrue );
				KSSetLimit( pfucb );
				}
			break;
			}
		}

	return JET_errSuccess;
	}


LOCAL VOID RECINormalisePlaceholder(
	FUCB	* const pfucb,
	FCB		* const pfcbTable,
	IDB		* const pidb )
	{
	Assert( !FKSPrepared( pfucb ) );

	//	there must be more than just this column in the index
	Assert( pidb->FHasPlaceholderColumn() );
	Assert( pidb->Cidxseg() > 1 );
	Assert( pidb->FPrimary() );

	pfcbTable->EnterDML();

	const TDB		* const ptdb	= pfcbTable->Ptdb();
	const IDXSEG	idxseg			= PidxsegIDBGetIdxSeg( pidb, ptdb )[0];
	const BOOL		fDescending		= idxseg.FDescending();

#ifdef DEBUG	
	//	HACK: placeholder column MUST be fixed bitfield
	Assert( FCOLUMNIDFixed( idxseg.Columnid() ) );
	const FIELD		* pfield		= ptdb->PfieldFixed( idxseg.Columnid() );

	Assert( FFIELDPrimaryIndexPlaceholder( pfield->ffield ) );
	Assert( JET_coltypBit == pfield->coltyp );
#endif	

	pfcbTable->LeaveDML();


	const BYTE		bPrefix			= BYTE( fDescending ? ~bPrefixData : bPrefixData );
	const BYTE		bData			= BYTE( fDescending ? 0xff : 0x00 );
	BYTE			* pbSeg			= (BYTE *)pfucb->dataSearchKey.Pv();

	pbSeg[0] = bPrefix;
	pbSeg[1] = bData;
	pfucb->dataSearchKey.SetCb( 2 );
	pfucb->cColumnsInSearchKey = 1;
	}

ERR VTAPI ErrIsamMakeKey(
	JET_SESID		sesid,
	JET_VTID		vtid,
	const VOID*		pvKeySeg,
	const ULONG		cbKeySeg,
	JET_GRBIT		grbit )
	{
	ERR				err;
 	PIB*			ppib			= reinterpret_cast<PIB *>( sesid );
	FUCB*			pfucbTable		= reinterpret_cast<FUCB *>( vtid );
	FUCB*			pfucb;
	FCB*			pfcbTable;
	BYTE*			pbKeySeg		= const_cast<BYTE *>( reinterpret_cast<const BYTE *>( pvKeySeg ) ); 
	IDB*			pidb;
	BOOL			fInitialIndex	= fFalse;
	INT				iidxsegCur;
	DATA			lineNormSeg;
	BYTE			rgbNormSegBuf[ cbKeyMostWithOverhead ];
	BYTE			rgbFixedColumnKeyPadded[ JET_cbColumnMost ];
	BOOL			fFixedField;
	DATA			lineKeySeg;
	ULONG			cbKeyMost;

	CallR( ErrPIBCheck( ppib ) );
	CheckFUCB( ppib, pfucbTable );
	AssertDIRNoLatch( ppib );

	if ( pfucbNil != pfucbTable->pfucbCurIndex )
		{
		pfucb = pfucbTable->pfucbCurIndex;
		Assert( pfucb->u.pfcb->FTypeSecondaryIndex() );
		Assert( pfucb->u.pfcb->Pidb() != pidbNil );
		Assert( !pfucb->u.pfcb->Pidb()->FPrimary() );
		cbKeyMost = JET_cbSecondaryKeyMost;
		}
	else
		{
		pfucb = pfucbTable;
		Assert( pfucb->u.pfcb->FPrimaryIndex() );
		Assert( pfucb->u.pfcb->Pidb() == pidbNil
			|| pfucb->u.pfcb->Pidb()->FPrimary() );
		cbKeyMost = JET_cbPrimaryKeyMost;
		}

						
	//	set efficiency variables
	//
	lineNormSeg.SetPv( rgbNormSegBuf );
	lineKeySeg.SetPv( pbKeySeg );
	lineKeySeg.SetCb( min( cbKeyMost, cbKeySeg ) );

	//	allocate key buffer if needed
	//
	if ( NULL == pfucb->dataSearchKey.Pv() )
		{
		Assert( !FKSPrepared( pfucb ) );

		pfucb->dataSearchKey.SetPv( PvOSMemoryHeapAlloc( cbKeyMostWithOverhead ) );
		if ( NULL == pfucb->dataSearchKey.Pv() )
			return ErrERRCheck( JET_errOutOfMemory );

		pfucb->dataSearchKey.SetCb( 0 );
		pfucb->cColumnsInSearchKey = 0;
		KSReset( pfucb );
		}

	Assert( !( grbit & JET_bitKeyDataZeroLength )
		|| 0 == cbKeySeg );

	//	if key is already normalized, then copy directly to
	//	key buffer and return.
	//
	if ( grbit & JET_bitNormalizedKey )
		{
		if ( cbKeySeg > cbKeyMostWithOverhead )
			{
			return ErrERRCheck( JET_errInvalidParameter );
			}

		//	ensure previous key is wiped out
		KSReset( pfucb );

		//	set key segment counter to any value
		//	regardless of the number of key segments.
		//
		pfucb->cColumnsInSearchKey = 1;
		UtilMemCpy( (BYTE *)pfucb->dataSearchKey.Pv(), pbKeySeg, cbKeySeg );
		pfucb->dataSearchKey.SetCb( cbKeySeg );

		KSSetPrepare( pfucb );
		if ( cbKeySeg > cbKeyMost )
			KSSetLimit( pfucb );

		return JET_errSuccess;
		}

	//	start new key if requested
	//
	else if ( grbit & JET_bitNewKey )
		{
		//	ensure previous key is wiped out
		KSReset( pfucb );

		pfucb->dataSearchKey.SetCb( 0 );
		pfucb->cColumnsInSearchKey = 0;
		}

	else if ( FKSLimit( pfucb ) )
		{
		return ErrERRCheck( JET_errKeyIsMade );
		}
	else if ( !FKSPrepared( pfucb ) )
		{
		return ErrERRCheck( JET_errKeyNotMade );
		}

	//	get pidb
	//
	pfcbTable = pfucbTable->u.pfcb;
	if ( FFUCBIndex( pfucbTable ) )
		{
		if ( pfucbTable->pfucbCurIndex != pfucbNil )
			{
			Assert( pfucb == pfucbTable->pfucbCurIndex );
			Assert( pfucb->u.pfcb->FTypeSecondaryIndex() );
			pidb = pfucb->u.pfcb->Pidb();
			fInitialIndex = pfucb->u.pfcb->FInitialIndex();
			if ( pfucb->u.pfcb->FDerivedIndex() )
				{
				// If secondary index is inherited, use FCB of template table.
				Assert( pidb->FTemplateIndex() );
				Assert( pfcbTable->Ptdb() != ptdbNil );
				pfcbTable = pfcbTable->Ptdb()->PfcbTemplateTable();
				Assert( pfcbNil != pfcbTable );
				}
			}
		else
			{
			BOOL	fPrimaryIndexTemplate	= fFalse;

			Assert( pfcbTable->FPrimaryIndex() );
			if ( pfcbTable->FDerivedTable() )
				{
				Assert( pfcbTable->Ptdb() != ptdbNil );
				Assert( pfcbTable->Ptdb()->PfcbTemplateTable() != pfcbNil );
				if ( !pfcbTable->Ptdb()->PfcbTemplateTable()->FSequentialIndex() )
					{
					// If template table has a primary index, we must have inherited it,
					// so use FCB of template table instead.
					fPrimaryIndexTemplate = fTrue;
					pfcbTable = pfcbTable->Ptdb()->PfcbTemplateTable();
					pidb = pfcbTable->Pidb();
					Assert( pidbNil != pidb );
					Assert( pfcbTable->Pidb()->FTemplateIndex() );
					fInitialIndex = fTrue;
					}
				else
					{
					Assert( pfcbTable->Ptdb()->PfcbTemplateTable()->Pidb() == pidbNil );
					}
				}

			if ( !fPrimaryIndexTemplate )
				{
				if ( pfcbTable->FInitialIndex() )
					{
					//	since the primary index can't be deleted,
					//	no need to check visibility
					pidb = pfcbTable->Pidb();
					fInitialIndex = fTrue;
					}
				else
					{
					pfcbTable->EnterDML();

					pidb = pfcbTable->Pidb();

					//	must check whether we have a primary or sequential index and
					//	whether we have visibility on it

					const ERR	errT	= ( pidbNil != pidb ?
												ErrFILEIAccessIndex( pfucbTable->ppib, pfcbTable, pfcbTable ) :
												ErrERRCheck( JET_errNoCurrentIndex ) );

					pfcbTable->LeaveDML();

					if ( errT < JET_errSuccess )
						{
						return ( JET_errIndexNotFound == errT ?
									ErrERRCheck( JET_errNoCurrentIndex ) :
									errT );
						}
					}
				}
			}
		}
	else
		{
		pidb = pfucbTable->u.pscb->fcb.Pidb();
		Assert( pfcbTable == &pfucbTable->u.pscb->fcb );
		}

	Assert( pidb != pidbNil );
	Assert( pidb->Cidxseg() > 0 );

	if ( !FKSPrepared( pfucb )
		&& pidb->FHasPlaceholderColumn()
		&& !( grbit & JET_bitKeyOverridePrimaryIndexPlaceholder ) )
		{
		//	HACK: first column is placeholder
		RECINormalisePlaceholder( pfucb, pfcbTable, pidb );
		}

	iidxsegCur = pfucb->cColumnsInSearchKey;
	if ( iidxsegCur >= pidb->Cidxseg() )
		return ErrERRCheck( JET_errKeyIsMade );

	const BOOL		fUseDMLLatch	= ( !fInitialIndex
										|| pidb->FIsRgidxsegInMempool() );

	if ( fUseDMLLatch )
		pfcbTable->EnterDML();

	const TDB		* const ptdb	= pfcbTable->Ptdb();
	const IDXSEG	idxseg			= PidxsegIDBGetIdxSeg( pidb, ptdb )[iidxsegCur];
	const BOOL		fDescending		= idxseg.FDescending();
	const COLUMNID	columnid		= idxseg.Columnid();
	const FIELD		* pfield;
	
	if ( fFixedField = FCOLUMNIDFixed( columnid ) )
		{
		Assert( fUseDMLLatch
				|| idxseg.FTemplateColumn()
				|| FidOfColumnid( columnid ) <= ptdb->FidFixedLastInitial() );
		pfield = ptdb->PfieldFixed( columnid );

		//	check that length of key segment matches fixed column length
		//
		Assert( pfield->cbMaxLen <= JET_cbColumnMost );
		if ( cbKeySeg > 0 && cbKeySeg != pfield->cbMaxLen )
			{
			//	if column is fixed text and buffer size is less
			//	than fixed size then pad with spaces.
			//
			Assert( pfield->coltyp != JET_coltypLongText );
			if ( pfield->coltyp == JET_coltypText && cbKeySeg < pfield->cbMaxLen )
				{
				Assert( cbKeySeg == lineKeySeg.Cb() );
				UtilMemCpy( rgbFixedColumnKeyPadded, lineKeySeg.Pv(), lineKeySeg.Cb() );
				memset( rgbFixedColumnKeyPadded + lineKeySeg.Cb(), ' ', pfield->cbMaxLen - lineKeySeg.Cb() );
				lineKeySeg.SetPv( rgbFixedColumnKeyPadded );
				lineKeySeg.SetCb( pfield->cbMaxLen );
				}
			else
				{
				if ( fUseDMLLatch )
					pfcbTable->LeaveDML();
				return ErrERRCheck( JET_errInvalidBufferSize );
				}
			}
		}
	else if ( FCOLUMNIDTagged( columnid ) )
		{
		Assert( fUseDMLLatch
				|| idxseg.FTemplateColumn()
				|| FidOfColumnid( columnid ) <= ptdb->FidTaggedLastInitial() );
		pfield = ptdb->PfieldTagged( columnid );
		}
	else
		{
		Assert( FCOLUMNIDVar( columnid ) );
		Assert( fUseDMLLatch
				|| idxseg.FTemplateColumn()
				|| FidOfColumnid( columnid ) <= ptdb->FidVarLastInitial() );
		pfield = ptdb->PfieldVar( columnid );
		}

	const JET_COLTYP	coltyp		= pfield->coltyp;
	const USHORT		cp			= pfield->cp;
	
	if ( fUseDMLLatch )
		pfcbTable->LeaveDML();

	switch ( grbit & JET_maskLimitOptions )
		{
		case JET_bitPartialColumnStartLimit:
		case JET_bitPartialColumnEndLimit:
			if ( !FRECTextColumn( coltyp )
				&& ( fFixedField || !FRECBinaryColumn( coltyp ) ) )
				{
				//	partial column limits can only be done
				//	on text columns and non-fixed binary columns
				//	(because they are the only ones that have
				//	delimiters that need to be stripped off)
				return ErrERRCheck( JET_errInvalidGrbit );
				}
		case 0:
		case JET_bitFullColumnStartLimit:
		case JET_bitFullColumnEndLimit:
			break;

		default:
			return ErrERRCheck( JET_errInvalidGrbit );
		}

	Assert( KEY::CbKeyMost( pidb->FPrimary() ) == cbKeyMost );
	
	Assert( pfucb->dataSearchKey.Cb() < cbKeyMostWithOverhead );

	if ( !FKSTooBig( pfucb )
		&& pfucb->dataSearchKey.Cb() < cbKeyMost )
		{
		const ERR	errNorm		= ErrFLDNormalizeSegment(
										pfucb,
										pidb,
										( cbKeySeg != 0 || ( grbit & JET_bitKeyDataZeroLength ) ) ? &lineKeySeg : NULL,
										&lineNormSeg,
										coltyp,
										cp,
										cbKeyMost - pfucb->dataSearchKey.Cb(),
										fDescending,
										fFixedField,
										grbit );
		if ( errNorm < 0 )
			{
			Assert( FRECTextColumn( coltyp ) );
#ifdef DEBUG
			switch ( errNorm )
				{
				case JET_errInvalidLanguageId:
				case JET_errOutOfMemory:
				case JET_errUnicodeNormalizationNotSupported:
					Assert( usUniCodePage == cp );
					break;
				case JET_errIndexTuplesKeyTooSmall:
					Assert( pidb->FTuples() );
					break;
				default:
					//	report unexpected error
					CallS( errNorm );
				}
#endif
			return errNorm;
			}
		CallS( errNorm );
		}
	else
		{
		lineNormSeg.SetCb( 0 );
		}

	//	increment segment counter
	//
	pfucb->cColumnsInSearchKey++;

	//	UNDONE:	normalized segment should already be sized properly to ensure we
	//	don't overrun key buffer.  Assert this, but leave the check in for now
	//	just in case.
	Assert( pfucb->dataSearchKey.Cb() + lineNormSeg.Cb() <= cbKeyMostWithOverhead );
	if ( pfucb->dataSearchKey.Cb() + lineNormSeg.Cb() > cbKeyMostWithOverhead )
		{
		lineNormSeg.SetCb( cbKeyMostWithOverhead - pfucb->dataSearchKey.Cb() );
		//	no warning returned when key exceeds most size
		//
		}

	UtilMemCpy(
		(BYTE *)pfucb->dataSearchKey.Pv() + pfucb->dataSearchKey.Cb(),
		lineNormSeg.Pv(),
		lineNormSeg.Cb() );
	pfucb->dataSearchKey.DeltaCb( lineNormSeg.Cb() );
	KSSetPrepare( pfucb );
	AssertDIRNoLatch( ppib );

	CallS( err );
	return err;
	}


//+API
//	ErrRECIRetrieveColumnFromKey
//	========================================================================
//	ErrRECIRetrieveColumnFromKey(
//		TDB *ptdb,				// IN	 column info for index
//		IDB *pidb,				// IN	 IDB of index defining key
//		KEY *pkey,				// IN	 key in normalized form
//		DATA *plineColumn ); 	// OUT	 receives value list
//
//	PARAMETERS	
//		ptdb			column info for index
//		pidb			IDB of index defining key
//		pkey			key in normalized form
//		plineColumn		plineColumn->pv must point to a buffer large
//						enough to hold the denormalized column.  A buffer
//						of cbKeyMost bytes is sufficient.
//
//	RETURNS		JET_errSuccess
//
//-
ERR ErrRECIRetrieveColumnFromKey(
	TDB 					* ptdb,
	IDB						* pidb,
	const KEY				* pkey,
	const COLUMNID			columnid,
	DATA					* plineColumn )
	{
	ERR						err			= JET_errSuccess;
	const IDXSEG* pidxseg;
	const IDXSEG* pidxsegMac;

	Assert( ptdb != ptdbNil );
	Assert( pidb != pidbNil );
	Assert( pidb->Cidxseg() > 0 );
	Assert( !pkey->FNull() );
	Assert( plineColumn != NULL );
	Assert( plineColumn->Pv() != NULL );

	BYTE				rgbKey[ KEY::cbKeyMax ];
	BYTE  				*pbKey		= rgbKey;				// runs through key bytes
	const BYTE		 	*pbKeyMax	= pbKey + pkey->Cb();	// end of key
	pkey->CopyIntoBuffer( pbKey );
	Assert( pbKeyMax <= pbKey + KEY::cbKeyMax );

	pidxseg = PidxsegIDBGetIdxSeg( pidb, ptdb );
	pidxsegMac = pidxseg + pidb->Cidxseg();

	const BYTE	bPrefixNullT	= ( pidb->FSortNullsHigh() ? bPrefixNullHigh : bPrefixNull );

	for ( ; pidxseg < pidxsegMac && pbKey < pbKeyMax; pidxseg++ )
		{
		JET_COLTYP 		coltyp;				  	 	// Type of column.
		ULONG 			cbField;			   		// Length of column data.
		FIELD			*pfield;
		BOOL 	   		fFixedField		= fFalse;	// Current column is fixed-length?


		//	negative column id means descending in the key
		//
		const BOOL		fDescending		= pidxseg->FDescending();
		const COLUMNID	columnidT		= pidxseg->Columnid();
		const BYTE		bMask			= BYTE( fDescending ? ~BYTE( 0 ) : BYTE( 0 ) );
		const WORD		wMask			= WORD( fDescending ? ~WORD( 0 ) : WORD( 0 ) );
		const DWORD		dwMask			= DWORD( fDescending ? ~DWORD( 0 ) : DWORD( 0 ) );
		const QWORD		qwMask			= QWORD( fDescending ? ~QWORD( 0 ) : QWORD( 0 ) );

		err = JET_errSuccess;				// reset error code

		//	determine column type from TDB
		//
		if ( FCOLUMNIDTagged( columnidT ) )
			{
			pfield = ptdb->PfieldTagged( columnidT );
			}
		else if ( FCOLUMNIDFixed( columnidT ) )
			{
			pfield = ptdb->PfieldFixed( columnidT );
			fFixedField = fTrue;
			}
		else
			{
			Assert( FCOLUMNIDVar( columnidT ) );
			pfield = ptdb->PfieldVar( columnidT );
			Assert( pfield->coltyp == JET_coltypBinary || pfield->coltyp == JET_coltypText );
			}
		coltyp = pfield->coltyp;

		Assert( coltyp != JET_coltypNil );
		BYTE		* const pbDataColumn = (BYTE *)plineColumn->Pv();		//	efficiency variable

		switch ( coltyp )
			{
			default:
				Assert( coltyp == JET_coltypBit );
				if ( *pbKey++ == (BYTE)(bMask ^ bPrefixNullT) )
					{
					plineColumn->SetCb( 0 );
					err = ErrERRCheck( JET_wrnColumnNull );
					}
				else 
					{
					Assert( pbKey[-1] == (BYTE)(bMask ^ bPrefixData) );
					plineColumn->SetCb( 1 );
					
					*( (BYTE *)plineColumn->Pv() ) = BYTE( ( ( bMask ^ pbKey[ 0 ] ) == 0 ) ? 0x00 : 0xff );

					pbKey++;
					}
				break;

			case JET_coltypUnsignedByte:
				if ( *pbKey++ == (BYTE)(bMask ^ bPrefixNullT) )
					{
					plineColumn->SetCb( 0 );
					err = ErrERRCheck( JET_wrnColumnNull );
					}
				else
					{
					Assert( pbKey[-1] == (BYTE)(bMask ^ bPrefixData) );
					plineColumn->SetCb( 1 );
					
					*( (BYTE *)plineColumn->Pv() ) = BYTE( bMask ^ pbKey[ 0 ] );
					
					pbKey++;
					}
				break;

			case JET_coltypShort:
				if ( *pbKey++ == (BYTE)(bMask ^ bPrefixNullT) )
					{
					plineColumn->SetCb( 0 );
					err = ErrERRCheck( JET_wrnColumnNull );
					}
				else
					{
					Assert( pbKey[-1] == (BYTE)(bMask ^ bPrefixData) );
					plineColumn->SetCb( 2 );
					
					*( (Unaligned< WORD > *)plineColumn->Pv() ) =
							WORD( wMask ^ wFlipHighBit( *( (UnalignedBigEndian< WORD >*) &pbKey[ 0 ] ) ) );
					
					pbKey += 2;
					}
				break;

			case JET_coltypLong:
				if ( *pbKey++ == (BYTE)(bMask ^ bPrefixNullT) )
					{
					plineColumn->SetCb( 0 );
					err = ErrERRCheck( JET_wrnColumnNull );
					}
				else
					{
					Assert(pbKey[-1] == (BYTE)(bMask ^ bPrefixData) );
					plineColumn->SetCb( 4 );
					
					*( (Unaligned< DWORD >*) plineColumn->Pv() ) = dwMask ^ dwFlipHighBit( *( (UnalignedBigEndian< DWORD >*) &pbKey[ 0 ] ) );
					
					pbKey += 4;
					}
				break;

			case JET_coltypIEEESingle:
				if ( *pbKey++ == (BYTE)(bMask ^ bPrefixNullT) )
					{
					plineColumn->SetCb( 0 );
					err = ErrERRCheck( JET_wrnColumnNull );
					}
				else
					{
					Assert(pbKey[-1] == (BYTE)(bMask ^ bPrefixData) );
					plineColumn->SetCb( 4 );

					DWORD dwT = dwMask ^ *( (UnalignedBigEndian< DWORD >*) &pbKey[ 0 ] );

					if ( dwT & maskDWordHighBit )
						{
						dwT = dwFlipHighBit( dwT );
						}
					else
						{
						dwT = ~dwT;
						}
					
					*( (Unaligned< DWORD >*) plineColumn->Pv() ) = dwT;
					
					pbKey += 4;
					}
				break;

			case JET_coltypCurrency:
				if ( *pbKey++ == (BYTE)(bMask ^ bPrefixNullT) )
					{
					plineColumn->SetCb( 0 );
					err = ErrERRCheck( JET_wrnColumnNull );
					}
				else
					{
					Assert(pbKey[-1] == (BYTE)(bMask ^ bPrefixData) );
					plineColumn->SetCb( 8 );
					
					*( (Unaligned< QWORD >*) plineColumn->Pv() ) = qwMask ^ qwFlipHighBit( *( (UnalignedBigEndian< QWORD >*) &pbKey[ 0 ] ) );
					
					pbKey += 8;
					}
				break;
				
			case JET_coltypIEEEDouble:
			case JET_coltypDateTime:
				if ( *pbKey++ == (BYTE)(bMask ^ bPrefixNullT) )
					{
					plineColumn->SetCb( 0 );
					err = ErrERRCheck( JET_wrnColumnNull );
					}
				else
					{
					Assert(pbKey[-1] == (BYTE)(bMask ^ bPrefixData) );
					plineColumn->SetCb( 8 );

					QWORD qwT = qwMask ^ *( (UnalignedBigEndian< QWORD >*) &pbKey[ 0 ] );

					if ( qwT & maskQWordHighBit )
						{
						qwT = qwFlipHighBit( qwT );
						}
					else
						{
						qwT = ~qwT;
						}
					
					*( (Unaligned< QWORD >*) plineColumn->Pv() ) = qwT;
					
					pbKey += 8;
					}
				break;

			case JET_coltypText:
			case JET_coltypLongText:
				//	Can only de-normalise text column for the purpose of skipping
				//	over it (since normalisation doesn't alter the length of
				//	the string).  Can't return the string to the caller because
				//	we have no way of restoring the original case.
				AssertSz( columnidT != columnid, "Can't de-normalise text strings (due to case)." );

				//	FALL THROUGH (fixed text handled the same as fixed binary,
				//	non-fixed text special-cased below):

			case JET_coltypBinary:
			case JET_coltypLongBinary:
				if ( fDescending )
					{
					if ( fFixedField )
						{
						if ( *pbKey++ == (BYTE)~bPrefixData )
							{
							cbField = pfield->cbMaxLen;
							Assert( cbField <= pbKeyMax - pbKey );	// wouldn't call this function if key possibly truncated
							plineColumn->SetCb( cbField );
							for ( ULONG ibT = 0; ibT < cbField; ibT++ )
								{
								Assert( pbDataColumn == (BYTE *)plineColumn->Pv() );
								pbDataColumn[ibT] = (BYTE)~*pbKey++;
								}
							}
//						// zero-length strings -- only for non-fixed columns
//						//	
//						else if ( pbKey[-1] == (BYTE)~bPrefixZeroLength )
//							{
//							plineColumn->cb = 0;
//							Assert( FRECTextColumn( coltyp ) );
//							}
						else
							{
							Assert( pbKey[-1] == (BYTE)~bPrefixNullT );
							plineColumn->SetCb( 0 );
							err = ErrERRCheck( JET_wrnColumnNull );
							}
						}
					else
						{
						cbField = 0;
						if ( *pbKey++ == (BYTE)~bPrefixData )
							{
							Assert( pbDataColumn == (BYTE *)plineColumn->Pv() );
							if ( FRECBinaryColumn( coltyp ) )
								{
								BYTE	*pbColumn = pbDataColumn;
								do {
									Assert( pbKey + cbFLDBinaryChunkNormalized <= pbKeyMax );
									
									BYTE	cbChunk = (BYTE)~pbKey[cbFLDBinaryChunkNormalized-1];
									if ( cbFLDBinaryChunkNormalized == cbChunk )
										cbChunk = cbFLDBinaryChunkNormalized-1;
										
									for ( BYTE ib = 0; ib < cbChunk; ib++ )
										pbColumn[ib] = (BYTE)~pbKey[ib];
										
									cbField += cbChunk;
									pbKey += cbFLDBinaryChunkNormalized;
									pbColumn += cbChunk;
									}
								while ( pbKey[-1] == (BYTE)~cbFLDBinaryChunkNormalized );
								}
								
							else
								{
								Assert( FRECTextColumn( coltyp ) );
								//	we are guaranteed to hit the NULL terminator, because
								//	we never call this function if we hit the end
								//	of key space
								for ( ; *pbKey != (BYTE)~0; cbField++)
									{
									Assert( pbKey < pbKeyMax );
									pbDataColumn[cbField] = (BYTE)~*pbKey++;
									}
								pbKey++;	// skip null-terminator
								}
							}
						else if ( pbKey[-1] == (BYTE)~bPrefixNullT )
							{
							err = ErrERRCheck( JET_wrnColumnNull );
							}
						else
							{
							Assert( pbKey[-1] == (BYTE)~bPrefixZeroLength );
							}
						Assert( cbField <= KEY::cbKeyMax );
						plineColumn->SetCb( cbField );
						}
					}
				else
					{
					if ( fFixedField )
						{
						if ( *pbKey++ == bPrefixData )
							{
							cbField = pfield->cbMaxLen;
							Assert( cbField <= pbKeyMax - pbKey );	// wouldn't call this function if key possibly truncated
							plineColumn->SetCb( cbField );
							UtilMemCpy( plineColumn->Pv(), pbKey, cbField );
							pbKey += cbField;
							}
//						// zero-length strings -- only for non-fixed columns
//						//	
//						else if ( pbKey[-1] == bPrefixZeroLength )
//							{
//							Assert( FRECTextColumn( coltyp ) );
//							plineColumn->SetCb( 0 );
//							}
						else
							{
							Assert( pbKey[-1] == bPrefixNullT );
							plineColumn->SetCb( 0 );
							err = ErrERRCheck( JET_wrnColumnNull );
							}
						}
					else
						{
						cbField = 0;
						if ( *pbKey++ == bPrefixData )
							{
							Assert( pbDataColumn == (BYTE *)plineColumn->Pv() );
							if ( FRECBinaryColumn( coltyp ) )
								{
								BYTE	*pbColumn = pbDataColumn;
								do {
									Assert( pbKey + cbFLDBinaryChunkNormalized <= pbKeyMax );
									
									BYTE	cbChunk = pbKey[cbFLDBinaryChunkNormalized-1];
									if ( cbFLDBinaryChunkNormalized == cbChunk )
										cbChunk = cbFLDBinaryChunkNormalized-1;
										
									UtilMemCpy( pbColumn, pbKey, cbChunk );
									
									cbField += cbChunk;
									pbKey += cbFLDBinaryChunkNormalized;
									pbColumn += cbChunk;
									}
								while ( pbKey[-1] == cbFLDBinaryChunkNormalized );
								}
								
							else
								{
								Assert( FRECTextColumn( coltyp ) );
								//	we are guaranteed to hit the NULL terminator, because
								//	we never call this function if we hit the end
								//	of key space
								for ( ; *pbKey != (BYTE)0; cbField++ )
									{
									Assert( pbKey < pbKeyMax );
									pbDataColumn[cbField] = (BYTE)*pbKey++;
									}
								pbKey++;	// skip null-terminator
								}
							}
						else if ( pbKey[-1] == bPrefixNullT )
							{
							err = ErrERRCheck( JET_wrnColumnNull );
							}
						else
							{
							Assert( pbKey[-1] == bPrefixZeroLength );
							}
						Assert( cbField <= KEY::cbKeyMax );
						plineColumn->SetCb( cbField );
						}
					}
				break;
			}
		
		//	if just retrieved field requested then break
		//
		if ( columnidT == columnid )
			break;
		}

	CallSx( err, JET_wrnColumnNull );
	return err;
	}


ERR VTAPI ErrIsamRetrieveKey(
	JET_SESID		sesid,
	JET_VTID		vtid,
	VOID*			pv,
	const ULONG		cbMax,
	ULONG*			pcbActual,
	JET_GRBIT		grbit )
	{
	ERR				err;
 	PIB*			ppib		= reinterpret_cast<PIB *>( sesid );
	FUCB*			pfucb		= reinterpret_cast<FUCB *>( vtid );
	FUCB*			pfucbIdx;
	FCB*			pfcbIdx;
	ULONG			cbKeyReturned;
			  	
	CallR( ErrPIBCheck( ppib ) );
	CheckFUCB( ppib, pfucb );
	AssertDIRNoLatch( ppib );

	//	retrieve key from key buffer
	//
	if ( grbit & JET_bitRetrieveCopy )
		{
		if ( pfucb->pfucbCurIndex != pfucbNil )
			pfucb = pfucb->pfucbCurIndex;
	
		//	UNDONE:	support JET_bitRetrieveCopy for inserted record
		//			by creating key on the fly.
		if ( pfucb->dataSearchKey.FNull()
			|| NULL == pfucb->dataSearchKey.Pv() )
			{
			return ErrERRCheck( JET_errKeyNotMade );
			}
		if ( pv != NULL )
			{
			UtilMemCpy( pv, 
					pfucb->dataSearchKey.Pv(),
					min( (ULONG)pfucb->dataSearchKey.Cb(), cbMax ) );
			}
		if ( pcbActual )
			*pcbActual = pfucb->dataSearchKey.Cb();
		return JET_errSuccess;
		}

	//	retrieve current index value
	//
	if ( FFUCBIndex( pfucb ) )
		{
		pfucbIdx = pfucb->pfucbCurIndex != pfucbNil ? pfucb->pfucbCurIndex : pfucb;
		Assert( pfucbIdx != pfucbNil );
		pfcbIdx = pfucbIdx->u.pfcb;
		Assert( pfcbIdx != pfcbNil );
		CallR( ErrDIRGet( pfucbIdx ) );
		}
	else
		{
		pfucbIdx = pfucb;
		pfcbIdx = (FCB *)pfucb->u.pscb; // first element of an SCB is an FCB
		Assert( pfcbIdx != pfcbNil );
		}

	//	set err to JET_errSuccess.
	//
	err = JET_errSuccess;

	cbKeyReturned = pfucbIdx->kdfCurr.key.Cb();
	if ( pcbActual )
		*pcbActual = cbKeyReturned;
	if ( cbKeyReturned > cbMax )
		{
		err = ErrERRCheck( JET_wrnBufferTruncated );
		cbKeyReturned = cbMax;
		}

	if ( pv != NULL )
		{
		UtilMemCpy( pv, pfucbIdx->kdfCurr.key.prefix.Pv(),
				min( (ULONG)pfucbIdx->kdfCurr.key.prefix.Cb(), cbKeyReturned ) );
		UtilMemCpy( (BYTE *)pv+pfucbIdx->kdfCurr.key.prefix.Cb(), 
				pfucbIdx->kdfCurr.key.suffix.Pv(),
				min( (ULONG)pfucbIdx->kdfCurr.key.suffix.Cb(), cbKeyReturned -
														pfucbIdx->kdfCurr.key.prefix.Cb() ) );
		}

	if ( FFUCBIndex( pfucb ) )
		{
		Assert( Pcsr( pfucbIdx )->FLatched( ) );
		CallS( ErrDIRRelease( pfucbIdx ) );
		}
		
	AssertDIRNoLatch( ppib );
	return err;
	}


ERR VTAPI ErrIsamGetBookmark(
	JET_SESID		sesid,
	JET_VTID		vtid,
	VOID * const	pvBookmark,
	const ULONG		cbMax,
	ULONG * const	pcbActual )
	{
	ERR				err;
 	PIB *			ppib		= reinterpret_cast<PIB *>( sesid );
	FUCB *			pfucb		= reinterpret_cast<FUCB *>( vtid );
	ULONG			cb;
	ULONG			cbReturned;
	BOOKMARK *		pbm;

	CallR( ErrPIBCheck( ppib ) );
	CheckTable( ppib, pfucb );
	AssertDIRNoLatch( ppib );
	Assert( NULL != pvBookmark || 0 == cbMax );

	//	retrieve bookmark
	//
	CallR( ErrDIRGetBookmark( pfucb, &pbm ) );
	Assert( !Pcsr( pfucb )->FLatched() );

	Assert( pbm->key.prefix.FNull() );
	Assert( pbm->data.FNull() );

	cb = pbm->key.Cb();

	//	set return values
	//
	if ( pcbActual )
		*pcbActual = cb;
		
	if ( cb <= cbMax )
		{
		cbReturned = cb;
		}
	else
		{
		cbReturned = cbMax;
		err = ErrERRCheck( JET_errBufferTooSmall );
		}

	pbm->key.CopyIntoBuffer( pvBookmark, cbReturned );

	AssertDIRNoLatch( ppib );
	return err;
	}

ERR VTAPI ErrIsamGetIndexBookmark(
	JET_SESID		sesid,
	JET_VTID		vtid,
	VOID * const	pvSecondaryKey,
	const ULONG		cbSecondaryKeyMax,
	ULONG * const	pcbSecondaryKeyActual,
	VOID * const	pvPrimaryBookmark,
	const ULONG		cbPrimaryBookmarkMax,
	ULONG *	const	pcbPrimaryBookmarkActual )
	{
	ERR				err;
 	PIB *			ppib		= reinterpret_cast<PIB *>( sesid );
	FUCB *			pfucb		= reinterpret_cast<FUCB *>( vtid );
	FUCB * const	pfucbIdx	= pfucb->pfucbCurIndex;
	ULONG			cb;
	ULONG			cbReturned;
	BOOKMARK *		pbm;

	CallR( ErrPIBCheck( ppib ) );
	AssertDIRNoLatch( ppib );
	CheckTable( ppib, pfucb );
	Assert( FFUCBIndex( pfucb ) );
	Assert( FFUCBPrimary( pfucb ) );
	Assert( pfucb->u.pfcb->FPrimaryIndex() );

	Assert( NULL != pvSecondaryKey || 0 == cbSecondaryKeyMax );
	Assert( NULL != pvPrimaryBookmark || 0 == cbPrimaryBookmarkMax );

	if ( pfucbNil == pfucbIdx )
		{
		return ErrERRCheck( JET_errNoCurrentIndex );
		}

	Assert( FFUCBSecondary( pfucbIdx ) );
	Assert( pfucbIdx->u.pfcb->FTypeSecondaryIndex() );

	//	retrieve bookmark
	//
	CallR( ErrDIRGetBookmark( pfucbIdx, &pbm ) );
	Assert( !Pcsr( pfucbIdx )->FLatched() );

	Assert( pbm->key.prefix.FNull() );
	Assert( !pbm->data.FNull() );

	//	set secondary index key return value
	//
	cb = pbm->key.Cb();
	if ( NULL != pcbSecondaryKeyActual )
		*pcbSecondaryKeyActual = cb;
		
	if ( cb <= cbSecondaryKeyMax )
		{
		cbReturned = cb;
		}
	else
		{
		cbReturned = cbSecondaryKeyMax;
		err = ErrERRCheck( JET_errBufferTooSmall );
		}

	pbm->key.CopyIntoBuffer( pvSecondaryKey, cbReturned );

	//	set primary bookmark return value
	//
	cb = pbm->data.Cb();
	if ( NULL != pcbPrimaryBookmarkActual )
		*pcbPrimaryBookmarkActual = cb;

	if ( cb <= cbPrimaryBookmarkMax )
		{
		cbReturned = cb;
		}
	else
		{
		cbReturned = cbPrimaryBookmarkMax;
		err = ErrERRCheck( JET_errBufferTooSmall );
		}

	UtilMemCpy( pvPrimaryBookmark, pbm->data.Pv(), cbReturned );

	AssertDIRNoLatch( ppib );
	return err;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ese98\src\ese\fldenum.cxx ===
#include "std.hxx"


class IColumnIter
	{
	public:

		//  Properties
		
		virtual ERR ErrGetWorstCaseColumnCount( size_t* const pcColumn ) const = 0;

		//  Column Navigation
		
		virtual ERR ErrMoveBeforeFirst() = 0;
		virtual ERR ErrMoveNext() = 0;
		virtual ERR ErrSeek( const COLUMNID columnid ) = 0;

		//  Column Properties

		virtual ERR ErrGetColumnId( COLUMNID* const pColumnId ) const = 0;
		virtual ERR ErrGetColumnValueCount( size_t* const pcColumnValue ) const = 0;

		//  Column Value Properties

		virtual ERR ErrGetColumnValue(	const size_t	iColumnValue,
										size_t* const	pcbColumnValue,
										void** const	ppvColumnValue,
										BOOL* const		pfColumnValueSeparated ) const = 0;
	};

class CFixedColumnIter
	:	public IColumnIter
	{
	public:

		//  ctor

		CFixedColumnIter();

		//  initializes the iterator

		ERR ErrInit( FCB* const pfcb, const DATA& dataRec );

	public:

		//  Properties
		
		virtual ERR ErrGetWorstCaseColumnCount( size_t* const pcColumn ) const;

		//  Column Navigation
		
		virtual ERR ErrMoveBeforeFirst();
		virtual ERR ErrMoveNext();
		virtual ERR ErrSeek( const COLUMNID columnid );

		//  Column Properties

		virtual ERR ErrGetColumnId( COLUMNID* const pColumnId ) const;
		virtual ERR ErrGetColumnValueCount( size_t* const pcColumnValue ) const;

		//  Column Value Properties

		virtual ERR ErrGetColumnValue(	const size_t	iColumnValue,
										size_t* const	pcbColumnValue,
										void** const	ppvColumnValue,
										BOOL* const		pfColumnValueSeparated ) const;
		
	private:

		FCB*			m_pfcb;
		const REC*		m_prec;
		COLUMNID		m_columnidCurr;
		ERR				m_errCurr;
		FIELD			m_fieldCurr;
	};

inline CFixedColumnIter::
CFixedColumnIter()
	:	m_pfcb( pfcbNil ),
		m_prec( NULL ),
		m_errCurr( JET_errNoCurrentRecord )
	{
	}

inline ERR CFixedColumnIter::
ErrInit( FCB* const pfcb, const DATA& dataRec )
	{
	ERR err = JET_errSuccess;

	if ( !pfcb || !dataRec.Pv() )
		{
		Call( ErrERRCheck( JET_errInvalidParameter ) );
		}

	m_pfcb	= pfcb;
	m_prec	= (REC*)dataRec.Pv();

	Call( CFixedColumnIter::ErrMoveBeforeFirst() );

HandleError:
	return err;
	}


ERR CFixedColumnIter::
ErrGetWorstCaseColumnCount( size_t* const pcColumn ) const
	{
	ERR err = JET_errSuccess;

	if ( !m_prec )
		{
		Call( ErrERRCheck( JET_errNotInitialized ) );
		}
	
	*pcColumn = m_prec->FidFixedLastInRec() - fidFixedLeast + 1;

HandleError:
	return err;
	}


inline ERR CFixedColumnIter::
ErrMoveBeforeFirst()
	{
	ERR err = JET_errSuccess;

	if ( !m_prec )
		{
		Call( ErrERRCheck( JET_errNotInitialized ) );
		}
	
	m_columnidCurr	= fidFixedLeast - 1;
	m_errCurr		= JET_errNoCurrentRecord;

HandleError:
	return err;
	}

ERR CFixedColumnIter::
ErrMoveNext()
	{
	ERR	err	= JET_errSuccess;
	FID	fid;

	if ( !m_prec )
		{
		Call( ErrERRCheck( JET_errNotInitialized ) );
		}
	
	fid = FidOfColumnid( m_columnidCurr + 1 );

	if ( fid > m_prec->FidFixedLastInRec() )
		{
		m_columnidCurr	= m_prec->FidFixedLastInRec() + 1;
		m_errCurr		= JET_errNoCurrentRecord;
		}
	else
		{
		m_columnidCurr	= ColumnidOfFid( fid, m_pfcb->Ptdb()->FFixedTemplateColumn( fid ) );
		m_errCurr		= JET_errSuccess;

		if ( fid > m_pfcb->Ptdb()->FidFixedLastInitial() )
			{
			m_pfcb->EnterDML();
			}
		m_fieldCurr		= *m_pfcb->Ptdb()->PfieldFixed( m_columnidCurr );
		if ( fid > m_pfcb->Ptdb()->FidFixedLastInitial() )
			{
			m_pfcb->LeaveDML();
			}
		}

	if ( m_errCurr < JET_errSuccess )
		{
		Call( ErrERRCheck( m_errCurr ) );
		}

HandleError:
	return err;
	}

ERR CFixedColumnIter::
ErrSeek( const COLUMNID columnid )
	{
	ERR	err	= JET_errSuccess;
	FID	fid;

	if ( !m_prec )
		{
		Call( ErrERRCheck( JET_errNotInitialized ) );
		}
	
	fid = FidOfColumnid( columnid );

	if ( fid < fidFixedLeast )
		{
		m_columnidCurr	= fidFixedLeast - 1;
		m_errCurr		= JET_errNoCurrentRecord;

		Call( ErrERRCheck( JET_errRecordNotFound ) );
		}
	else if ( fid > m_prec->FidFixedLastInRec() )
		{
		m_columnidCurr	= m_prec->FidFixedLastInRec() + 1;
		m_errCurr		= JET_errNoCurrentRecord;

		Call( ErrERRCheck( JET_errRecordNotFound ) );
		}
	else
		{
		m_columnidCurr	= columnid;
		m_errCurr		= JET_errSuccess;

		if ( fid > m_pfcb->Ptdb()->FidFixedLastInitial() )
			{
			m_pfcb->EnterDML();
			}
		m_fieldCurr		= *m_pfcb->Ptdb()->PfieldFixed( m_columnidCurr );
		if ( fid > m_pfcb->Ptdb()->FidFixedLastInitial() )
			{
			m_pfcb->LeaveDML();
			}
		}

	if ( m_errCurr < JET_errSuccess )
		{
		Call( ErrERRCheck( m_errCurr ) );
		}

HandleError:
	return err;
	}


ERR CFixedColumnIter::
ErrGetColumnId( COLUMNID* const pColumnId ) const
	{
	ERR err = JET_errSuccess;

	if ( m_errCurr < JET_errSuccess )
		{
		Call( ErrERRCheck( m_errCurr ) );
		}

	*pColumnId = m_columnidCurr;

HandleError:
	return err;
	}

ERR CFixedColumnIter::
ErrGetColumnValueCount( size_t* const pcColumnValue ) const
	{
	ERR		err			= JET_errSuccess;
	size_t	ifid;
	BYTE*	prgbitNullity;

	if ( m_errCurr < JET_errSuccess )
		{
		Call( ErrERRCheck( m_errCurr ) );
		}

	ifid			= FidOfColumnid( m_columnidCurr ) - fidFixedLeast;
	prgbitNullity	= m_prec->PbFixedNullBitMap() + ifid / 8;

	*pcColumnValue = FFixedNullBit( prgbitNullity, ifid ) ? 0 : 1;

HandleError:
	return err;
	}


ERR CFixedColumnIter::
ErrGetColumnValue(	const size_t	iColumnValue,
					size_t* const	pcbColumnValue,
					void** const	ppvColumnValue,
					BOOL* const		pfColumnValueSeparated ) const
	{
	ERR err = JET_errSuccess;

	if ( m_errCurr < JET_errSuccess )
		{
		Call( ErrERRCheck( m_errCurr ) );
		}

	if ( iColumnValue != 1 )
		{
		Call( ErrERRCheck( JET_errBadItagSequence ) );
		}

	*pcbColumnValue			= m_fieldCurr.cbMaxLen;
	*ppvColumnValue			= (BYTE*)m_prec + m_fieldCurr.ibRecordOffset;
	*pfColumnValueSeparated	= fFalse;

HandleError:
	return err;
	}


class CVariableColumnIter
	:	public IColumnIter
	{
	public:

		//  ctor

		CVariableColumnIter();

		//  initializes the iterator

		ERR ErrInit( FCB* const pfcb, const DATA& dataRec );

	public:

		//  Properties
		
		virtual ERR ErrGetWorstCaseColumnCount( size_t* const pcColumn ) const;

		//  Column Navigation
		
		virtual ERR ErrMoveBeforeFirst();
		virtual ERR ErrMoveNext();
		virtual ERR ErrSeek( const COLUMNID columnid );

		//  Column Properties

		virtual ERR ErrGetColumnId( COLUMNID* const pColumnId ) const;
		virtual ERR ErrGetColumnValueCount( size_t* const pcColumnValue ) const;

		//  Column Value Properties

		virtual ERR ErrGetColumnValue(	const size_t	iColumnValue,
										size_t* const	pcbColumnValue,
										void** const	ppvColumnValue,
										BOOL* const		pfColumnValueSeparated ) const;
		
	private:

		FCB*			m_pfcb;
		const REC*		m_prec;
		COLUMNID		m_columnidCurr;
		ERR				m_errCurr;
	};

inline CVariableColumnIter::
CVariableColumnIter()
	:	m_pfcb( pfcbNil ),
		m_prec( NULL ),
		m_errCurr( JET_errNoCurrentRecord )
	{
	}

inline ERR CVariableColumnIter::
ErrInit( FCB* const pfcb, const DATA& dataRec )
	{
	ERR err = JET_errSuccess;

	if ( !pfcb || !dataRec.Pv() )
		{
		Call( ErrERRCheck( JET_errInvalidParameter ) );
		}

	m_pfcb	= pfcb;
	m_prec	= (REC*)dataRec.Pv();

	Call( CVariableColumnIter::ErrMoveBeforeFirst() );

HandleError:
	return err;
	}


ERR CVariableColumnIter::
ErrGetWorstCaseColumnCount( size_t* const pcColumn ) const
	{
	ERR err = JET_errSuccess;

	if ( !m_prec )
		{
		Call( ErrERRCheck( JET_errNotInitialized ) );
		}
	
	*pcColumn = m_prec->FidVarLastInRec() - fidVarLeast + 1;

HandleError:
	return err;
	}


inline ERR CVariableColumnIter::
ErrMoveBeforeFirst()
	{
	ERR err = JET_errSuccess;

	if ( !m_prec )
		{
		Call( ErrERRCheck( JET_errNotInitialized ) );
		}
	
	m_columnidCurr	= fidVarLeast - 1;
	m_errCurr		= JET_errNoCurrentRecord;

HandleError:
	return err;
	}

ERR CVariableColumnIter::
ErrMoveNext()
	{
	ERR	err	= JET_errSuccess;
	FID	fid;

	if ( !m_prec )
		{
		Call( ErrERRCheck( JET_errNotInitialized ) );
		}
	
	fid = FidOfColumnid( m_columnidCurr + 1 );

	if ( fid > m_prec->FidVarLastInRec() )
		{
		m_columnidCurr	= m_prec->FidVarLastInRec() + 1;
		m_errCurr		= JET_errNoCurrentRecord;
		}
	else
		{
		m_columnidCurr	= ColumnidOfFid( fid, m_pfcb->Ptdb()->FVarTemplateColumn( fid ) );
		m_errCurr		= JET_errSuccess;
		}

	if ( m_errCurr < JET_errSuccess )
		{
		Call( ErrERRCheck( m_errCurr ) );
		}

HandleError:
	return err;
	}

ERR CVariableColumnIter::
ErrSeek( const COLUMNID columnid )
	{
	ERR	err	= JET_errSuccess;
	FID	fid;

	if ( !m_prec )
		{
		Call( ErrERRCheck( JET_errNotInitialized ) );
		}
	
	fid = FidOfColumnid( columnid );

	if ( fid < fidVarLeast )
		{
		m_columnidCurr	= fidVarLeast - 1;
		m_errCurr		= JET_errNoCurrentRecord;

		Call( ErrERRCheck( JET_errRecordNotFound ) );
		}
	else if ( fid > m_prec->FidVarLastInRec() )
		{
		m_columnidCurr	= m_prec->FidVarLastInRec() + 1;
		m_errCurr		= JET_errNoCurrentRecord;

		Call( ErrERRCheck( JET_errRecordNotFound ) );
		}
	else
		{
		m_columnidCurr	= columnid;
		m_errCurr		= JET_errSuccess;
		}

	if ( m_errCurr < JET_errSuccess )
		{
		Call( ErrERRCheck( m_errCurr ) );
		}

HandleError:
	return err;
	}


ERR CVariableColumnIter::
ErrGetColumnId( COLUMNID* const pColumnId ) const
	{
	ERR err = JET_errSuccess;

	if ( m_errCurr < JET_errSuccess )
		{
		Call( ErrERRCheck( m_errCurr ) );
		}

	*pColumnId = m_columnidCurr;

HandleError:
	return err;
	}

ERR CVariableColumnIter::
ErrGetColumnValueCount( size_t* const pcColumnValue ) const
	{
	ERR											err			= JET_errSuccess;
	size_t										ifid;
	UnalignedLittleEndian< REC::VAROFFSET >*	pibVarOffs;

	if ( m_errCurr < JET_errSuccess )
		{
		Call( ErrERRCheck( m_errCurr ) );
		}

	ifid		= FidOfColumnid( m_columnidCurr ) - fidVarLeast;
	pibVarOffs	= m_prec->PibVarOffsets();

	*pcColumnValue = FVarNullBit( pibVarOffs[ ifid ] ) ? 0 : 1;

HandleError:
	return err;
	}


ERR CVariableColumnIter::
ErrGetColumnValue(	const size_t	iColumnValue,
					size_t* const	pcbColumnValue,
					void** const	ppvColumnValue,
					BOOL* const		pfColumnValueSeparated ) const
	{
	ERR											err				= JET_errSuccess;
	size_t										ifid;
	UnalignedLittleEndian< REC::VAROFFSET >*	pibVarOffs;
	REC::VAROFFSET								ibStartOfColumn;

	if ( m_errCurr < JET_errSuccess )
		{
		Call( ErrERRCheck( m_errCurr ) );
		}

	if ( iColumnValue != 1 )
		{
		Call( ErrERRCheck( JET_errBadItagSequence ) );
		}

	ifid			= FidOfColumnid( m_columnidCurr ) - fidVarLeast;
	pibVarOffs		= m_prec->PibVarOffsets();
	ibStartOfColumn	= m_prec->IbVarOffsetStart( FidOfColumnid( m_columnidCurr ) );

	*pcbColumnValue = IbVarOffset( pibVarOffs[ ifid ] ) - ibStartOfColumn;
	if ( *pcbColumnValue == 0 )
		{
		*ppvColumnValue = NULL;
		}
	else
		{
		*ppvColumnValue = m_prec->PbVarData() + ibStartOfColumn;
		}
	*pfColumnValueSeparated = fFalse;

HandleError:
	return err;
	}


class IColumnValueIter
	{
	public:

		//  Properties

		virtual ERR ErrGetColumnValueCount( size_t* const pcColumnValue ) const = 0;

		//  Column Value Properties

		virtual ERR ErrGetColumnValue(	const size_t	iColumnValue,
										size_t* const	pcbColumnValue,
										void** const	ppvColumnValue,
										BOOL* const		pfColumnValueSeparated ) const = 0;
	};

class CNullValuedTaggedColumnValueIter
	:	public IColumnValueIter
	{
	public:

		//  ctor

		CNullValuedTaggedColumnValueIter();

		//  initializes the iterator

		ERR ErrInit();

	public:

		//  Properties

		virtual ERR ErrGetColumnValueCount( size_t* const pcColumnValue ) const;

		//  Column Value Properties

		virtual ERR ErrGetColumnValue(	const size_t	iColumnValue,
										size_t* const	pcbColumnValue,
										void** const	ppvColumnValue,
										BOOL* const		pfColumnValueSeparated ) const;
	};

inline CNullValuedTaggedColumnValueIter::
CNullValuedTaggedColumnValueIter()
	{
	}

inline ERR CNullValuedTaggedColumnValueIter::
ErrInit()
	{
	return JET_errSuccess;
	}

ERR CNullValuedTaggedColumnValueIter::
ErrGetColumnValueCount( size_t* const pcColumnValue ) const
	{
	*pcColumnValue = 0;

	return JET_errSuccess;
	}


ERR CNullValuedTaggedColumnValueIter::
ErrGetColumnValue(	const size_t	iColumnValue,
					size_t* const	pcbColumnValue,
					void** const	ppvColumnValue,
					BOOL* const		pfColumnValueSeparated ) const
	{
	return ErrERRCheck( JET_errBadItagSequence );
	}


class CSingleValuedTaggedColumnValueIter
	:	public IColumnValueIter
	{
	public:

		//  ctor

		CSingleValuedTaggedColumnValueIter();

		//  initializes the iterator

		ERR ErrInit( BYTE* const rgbData, size_t cbData, const BOOL fSeparated );

	public:

		//  Properties

		virtual ERR ErrGetColumnValueCount( size_t* const pcColumnValue ) const;

		//  Column Value Properties

		virtual ERR ErrGetColumnValue(	const size_t	iColumnValue,
										size_t* const	pcbColumnValue,
										void** const	ppvColumnValue,
										BOOL* const		pfColumnValueSeparated ) const;
		
	private:

		BYTE*		m_rgbData;
		size_t		m_cbData;
		BOOL		m_fSeparated;
	};

inline CSingleValuedTaggedColumnValueIter::
CSingleValuedTaggedColumnValueIter()
	:	m_rgbData( NULL )
	{
	}

inline ERR CSingleValuedTaggedColumnValueIter::
ErrInit( BYTE* const rgbData, size_t cbData, const BOOL fSeparated )
	{
	ERR err = JET_errSuccess;

	if ( !rgbData )
		{
		Call( ErrERRCheck( JET_errInvalidParameter ) );
		}

	m_rgbData		= rgbData;
	m_cbData		= cbData;
	m_fSeparated	= fSeparated;

HandleError:
	return err;
	}

ERR CSingleValuedTaggedColumnValueIter::
ErrGetColumnValueCount( size_t* const pcColumnValue ) const
	{
	ERR err = JET_errSuccess;

	if ( !m_rgbData )
		{
		Call( ErrERRCheck( JET_errNotInitialized ) );
		}

	*pcColumnValue = 1;

HandleError:
	return err;
	}


ERR CSingleValuedTaggedColumnValueIter::
ErrGetColumnValue(	const size_t	iColumnValue,
					size_t* const	pcbColumnValue,
					void** const	ppvColumnValue,
					BOOL* const		pfColumnValueSeparated ) const
	{
	ERR err = JET_errSuccess;

	if ( !m_rgbData )
		{
		Call( ErrERRCheck( JET_errNotInitialized ) );
		}

	if ( iColumnValue != 1 )
		{
		Call( ErrERRCheck( JET_errBadItagSequence ) );
		}

	*pcbColumnValue			= m_cbData;
	*ppvColumnValue			= m_rgbData;
	*pfColumnValueSeparated	= m_fSeparated;

HandleError:
	return err;
	}


class CDualValuedTaggedColumnValueIter
	:	public IColumnValueIter
	{
	public:

		//  ctor

		CDualValuedTaggedColumnValueIter();

		//  initializes the iterator

		ERR ErrInit( BYTE* const rgbData, size_t cbData );

	public:

		//  Properties

		virtual ERR ErrGetColumnValueCount( size_t* const pcColumnValue ) const;

		//  Column Value Properties

		virtual ERR ErrGetColumnValue(	const size_t	iColumnValue,
										size_t* const	pcbColumnValue,
										void** const	ppvColumnValue,
										BOOL* const		pfColumnValueSeparated ) const;
		
	private:

		TWOVALUES*		m_ptwovalues;

		BYTE			m_rgbTWOVALUES[ sizeof( TWOVALUES ) ];
	};

inline CDualValuedTaggedColumnValueIter::
CDualValuedTaggedColumnValueIter()
	:	m_ptwovalues( NULL )
	{
	}

inline ERR CDualValuedTaggedColumnValueIter::
ErrInit( BYTE* const rgbData, size_t cbData )
	{
	ERR err = JET_errSuccess;

	if ( !rgbData )
		{
		Call( ErrERRCheck( JET_errInvalidParameter ) );
		}

	m_ptwovalues = new( m_rgbTWOVALUES ) TWOVALUES( rgbData, cbData );

HandleError:
	return err;
	}

ERR CDualValuedTaggedColumnValueIter::
ErrGetColumnValueCount( size_t* const pcColumnValue ) const
	{
	ERR err = JET_errSuccess;

	if ( !m_ptwovalues )
		{
		Call( ErrERRCheck( JET_errNotInitialized ) );
		}

	*pcColumnValue = 2;

HandleError:
	return err;
	}


ERR CDualValuedTaggedColumnValueIter::
ErrGetColumnValue(	const size_t	iColumnValue,
					size_t* const	pcbColumnValue,
					void** const	ppvColumnValue,
					BOOL* const		pfColumnValueSeparated ) const
	{
	ERR err = JET_errSuccess;

	if ( !m_ptwovalues )
		{
		Call( ErrERRCheck( JET_errNotInitialized ) );
		}

	if ( iColumnValue < 1 || iColumnValue > 2 )
		{
		Call( ErrERRCheck( JET_errBadItagSequence ) );
		}

	if ( iColumnValue == 1 )
		{
		*pcbColumnValue	= m_ptwovalues->CbFirstValue();
		*ppvColumnValue	= m_ptwovalues->PbData();
		}
	else
		{
		*pcbColumnValue	= m_ptwovalues->CbSecondValue();
		*ppvColumnValue	= m_ptwovalues->PbData() + m_ptwovalues->CbFirstValue();
		}

	*pfColumnValueSeparated = fFalse;

HandleError:
	return err;
	}


class CMultiValuedTaggedColumnValueIter
	:	public IColumnValueIter
	{
	public:

		//  ctor

		CMultiValuedTaggedColumnValueIter();

		//  initializes the iterator

		ERR ErrInit( BYTE* const rgbData, size_t cbData );

	public:

		//  Properties

		virtual ERR ErrGetColumnValueCount( size_t* const pcColumnValue ) const;

		//  Column Value Properties

		virtual ERR ErrGetColumnValue(	const size_t	iColumnValue,
										size_t* const	pcbColumnValue,
										void** const	ppvColumnValue,
										BOOL* const		pfColumnValueSeparated ) const;
		
	private:

		MULTIVALUES*	m_pmultivalues;

		BYTE			m_rgbMULTIVALUES[ sizeof( MULTIVALUES ) ];
	};

inline CMultiValuedTaggedColumnValueIter::
CMultiValuedTaggedColumnValueIter()
	:	m_pmultivalues( NULL )
	{
	}

inline ERR CMultiValuedTaggedColumnValueIter::
ErrInit( BYTE* const rgbData, size_t cbData )
	{
	ERR err = JET_errSuccess;

	if ( !rgbData )
		{
		Call( ErrERRCheck( JET_errInvalidParameter ) );
		}

	m_pmultivalues = new( m_rgbMULTIVALUES ) MULTIVALUES( rgbData, cbData );

HandleError:
	return err;
	}

ERR CMultiValuedTaggedColumnValueIter::
ErrGetColumnValueCount( size_t* const pcColumnValue ) const
	{
	ERR err = JET_errSuccess;

	if ( !m_pmultivalues )
		{
		Call( ErrERRCheck( JET_errNotInitialized ) );
		}

	*pcColumnValue = m_pmultivalues->CMultiValues();

HandleError:
	return err;
	}


ERR CMultiValuedTaggedColumnValueIter::
ErrGetColumnValue(	const size_t	iColumnValue,
					size_t* const	pcbColumnValue,
					void** const	ppvColumnValue,
					BOOL* const		pfColumnValueSeparated ) const
	{
	ERR err = JET_errSuccess;

	if ( !m_pmultivalues )
		{
		Call( ErrERRCheck( JET_errNotInitialized ) );
		}

	if ( iColumnValue < 1 || iColumnValue > m_pmultivalues->CMultiValues() )
		{
		Call( ErrERRCheck( JET_errBadItagSequence ) );
		}

	*pcbColumnValue			= m_pmultivalues->CbData( iColumnValue - 1 );
	*ppvColumnValue			= m_pmultivalues->PbData( iColumnValue - 1 );
	*pfColumnValueSeparated	= m_pmultivalues->FSeparatedInstance( iColumnValue - 1 );

HandleError:
	return err;
	}


#define SIZEOF_CVITER_MAX											\
	max(	max(	sizeof( CNullValuedTaggedColumnValueIter ),		\
					sizeof( CSingleValuedTaggedColumnValueIter ) ),	\
			max(	sizeof( CDualValuedTaggedColumnValueIter ),		\
					sizeof( CMultiValuedTaggedColumnValueIter ) ) )	\


class CTaggedColumnIter
	:	public IColumnIter
	{
	public:

		//  ctor

		CTaggedColumnIter();

		//  initializes the iterator

		ERR ErrInit( FCB* const pfcb, const DATA& dataRec );

	public:

		//  Properties
		
		virtual ERR ErrGetWorstCaseColumnCount( size_t* const pcColumn ) const;

		//  Column Navigation
		
		virtual ERR ErrMoveBeforeFirst();
		virtual ERR ErrMoveNext();
		virtual ERR ErrSeek( const COLUMNID columnid );

		//  Column Properties

		virtual ERR ErrGetColumnId( COLUMNID* const pColumnId ) const;
		virtual ERR ErrGetColumnValueCount( size_t* const pcColumnValue ) const;

		//  Column Value Properties

		virtual ERR ErrGetColumnValue(	const size_t	iColumnValue,
										size_t* const	pcbColumnValue,
										void** const	ppvColumnValue,
										BOOL* const		pfColumnValueSeparated ) const;

	private:

		ERR ErrCreateCVIter( IColumnValueIter** const ppcviter );
		
	private:

		FCB*				m_pfcb;
		TAGFIELDS*			m_ptagfields;
		TAGFLD*				m_ptagfldCurr;
		ERR					m_errCurr;
		IColumnValueIter*	m_pcviterCurr;

		BYTE			m_rgbTAGFIELDS[ sizeof( TAGFIELDS ) ];
		BYTE			m_rgbCVITER[ SIZEOF_CVITER_MAX ];
	};

inline CTaggedColumnIter::
CTaggedColumnIter()
	:	m_pfcb( pfcbNil ),
		m_ptagfields( NULL ),
		m_errCurr( JET_errNoCurrentRecord )
	{
	}

inline ERR CTaggedColumnIter::
ErrInit( FCB* const pfcb, const DATA& dataRec )
	{
	ERR err = JET_errSuccess;

	if ( !pfcb || !dataRec.Pv() )
		{
		Call( ErrERRCheck( JET_errInvalidParameter ) );
		}

	m_pfcb			= pfcb;
	m_ptagfields	= new( m_rgbTAGFIELDS ) TAGFIELDS( dataRec );

	Call( CTaggedColumnIter::ErrMoveBeforeFirst() );

HandleError:
	return err;
	}


ERR CTaggedColumnIter::
ErrGetWorstCaseColumnCount( size_t* const pcColumn ) const
	{
	ERR err = JET_errSuccess;

	if ( !m_ptagfields )
		{
		Call( ErrERRCheck( JET_errNotInitialized ) );
		}
	
	*pcColumn = m_ptagfields->CTaggedColumns();

HandleError:
	return err;
	}


inline ERR CTaggedColumnIter::
ErrMoveBeforeFirst()
	{
	ERR err = JET_errSuccess;

	if ( !m_ptagfields )
		{
		Call( ErrERRCheck( JET_errNotInitialized ) );
		}
	
	m_ptagfldCurr	= m_ptagfields->Rgtagfld() - 1;
	m_errCurr		= JET_errNoCurrentRecord;

HandleError:
	return err;
	}

ERR CTaggedColumnIter::
ErrMoveNext()
	{
	ERR			err		= JET_errSuccess;
	TAGFLD*		ptagfld;

	if ( !m_ptagfields )
		{
		Call( ErrERRCheck( JET_errNotInitialized ) );
		}
	
	ptagfld = m_ptagfldCurr + 1;

	if ( ptagfld > m_ptagfields->Rgtagfld() + m_ptagfields->CTaggedColumns() - 1 )
		{
		m_ptagfldCurr	= m_ptagfields->Rgtagfld() + m_ptagfields->CTaggedColumns();
		m_errCurr		= JET_errNoCurrentRecord;
		}
	else
		{
		m_ptagfldCurr	= ptagfld;
		m_errCurr		= JET_errSuccess;
		
		Call( ErrCreateCVIter( &m_pcviterCurr ) );
		}

	if ( m_errCurr < JET_errSuccess )
		{
		Call( ErrERRCheck( m_errCurr ) );
		}

HandleError:
	m_errCurr = err;
	return err;
	}

ERR CTaggedColumnIter::
ErrSeek( const COLUMNID columnid )
	{
	ERR			err				= JET_errSuccess;
	BOOL		fUseDerivedBit	= fFalse;
	FCB*		pfcb			= m_pfcb;
	FID			fid;
	size_t		itagfld;
	TAGFLD*		ptagfld;

	if ( !m_ptagfields )
		{
		Call( ErrERRCheck( JET_errNotInitialized ) );
		}

	if ( FCOLUMNIDTemplateColumn( columnid ) )
		{
		if ( !pfcb->FTemplateTable() )
			{
			pfcb->Ptdb()->AssertValidDerivedTable();

			//	HACK: treat derived columns in original-format derived table as
			//	non-derived, because they don't have the fDerived bit set in the TAGFLD
			fUseDerivedBit = FRECUseDerivedBitForTemplateColumnInDerivedTable( columnid, pfcb->Ptdb() );

			// switch to template table
			pfcb = pfcb->Ptdb()->PfcbTemplateTable();
			}
		else
			{
			pfcb->Ptdb()->AssertValidTemplateTable();
			Assert( !fUseDerivedBit );
			}
		}
	else
		{
		Assert( !pfcb->FTemplateTable() );
		}

	fid		= FidOfColumnid( columnid );
	itagfld	= m_ptagfields->ItagfldFind( TAGFLD( fid, fUseDerivedBit ) );
	ptagfld	= m_ptagfields->Rgtagfld() + itagfld;

	if (	itagfld < m_ptagfields->CTaggedColumns() &&
			ptagfld->FIsEqual( fid, fUseDerivedBit ) )
		{
		m_ptagfldCurr	= ptagfld;
		m_errCurr		= JET_errSuccess;

		Call( ErrCreateCVIter( &m_pcviterCurr ) );
		}
	else
		{
		m_ptagfldCurr	= ptagfld - 1;
		m_errCurr		= JET_errNoCurrentRecord;

		Call( ErrERRCheck( JET_errRecordNotFound ) );
		}

	if ( m_errCurr < JET_errSuccess )
		{
		Call( ErrERRCheck( m_errCurr ) );
		}

HandleError:
	m_errCurr = err;
	return err;
	}


ERR CTaggedColumnIter::
ErrGetColumnId( COLUMNID* const pColumnId ) const
	{
	ERR err = JET_errSuccess;

	if ( m_errCurr < JET_errSuccess )
		{
		Call( ErrERRCheck( m_errCurr ) );
		}

	*pColumnId = m_ptagfldCurr->Columnid( m_pfcb->Ptdb() );

HandleError:
	return err;
	}

ERR CTaggedColumnIter::
ErrGetColumnValueCount( size_t* const pcColumnValue ) const
	{
	ERR err = JET_errSuccess;

	if ( m_errCurr < JET_errSuccess )
		{
		Call( ErrERRCheck( m_errCurr ) );
		}

	Call( m_pcviterCurr->ErrGetColumnValueCount( pcColumnValue ) );

HandleError:
	return err;
	}


ERR CTaggedColumnIter::
ErrGetColumnValue(	const size_t	iColumnValue,
					size_t* const	pcbColumnValue,
					void** const	ppvColumnValue,
					BOOL* const		pfColumnValueSeparated ) const
	{
	ERR err = JET_errSuccess;

	if ( m_errCurr < JET_errSuccess )
		{
		Call( ErrERRCheck( m_errCurr ) );
		}

	Call( m_pcviterCurr->ErrGetColumnValue(	iColumnValue,
											pcbColumnValue,
											ppvColumnValue,
											pfColumnValueSeparated ) );

HandleError:
	return err;
	}

ERR CTaggedColumnIter::
ErrCreateCVIter( IColumnValueIter** const ppcviter )
	{
	ERR err = JET_errSuccess;
	
	if ( m_ptagfldCurr->FNull() )
		{
		CNullValuedTaggedColumnValueIter* pcviterNV = new( m_rgbCVITER ) CNullValuedTaggedColumnValueIter();
		Call( pcviterNV->ErrInit() );
		*ppcviter = pcviterNV;
		}
	else
		{
		BYTE*	rgbData	= m_ptagfields->PbTaggedColumns() + m_ptagfldCurr->Ib();
		size_t	cbData	= m_ptagfields->CbData( ULONG( m_ptagfldCurr - m_ptagfields->Rgtagfld() ) );

		if ( !m_ptagfldCurr->FExtendedInfo() )
			{
			CSingleValuedTaggedColumnValueIter* pcviterSV = new( m_rgbCVITER ) CSingleValuedTaggedColumnValueIter();
			Call( pcviterSV->ErrInit( rgbData, cbData, fFalse ) );
			*ppcviter = pcviterSV;
			}
		else
			{
			TAGFLD_HEADER* ptagfldhdr = (TAGFLD_HEADER*)rgbData;

			if ( ptagfldhdr->FTwoValues() )
				{
				CDualValuedTaggedColumnValueIter* pcviterDV = new( m_rgbCVITER ) CDualValuedTaggedColumnValueIter();
				Call( pcviterDV->ErrInit( rgbData, cbData ) );
				*ppcviter = pcviterDV;
				}
			else if ( ptagfldhdr->FMultiValues() )
				{
				CMultiValuedTaggedColumnValueIter* pcviterMV = new( m_rgbCVITER ) CMultiValuedTaggedColumnValueIter();
				Call( pcviterMV->ErrInit( rgbData, cbData ) );
				*ppcviter = pcviterMV;
				}
			else
				{
				CSingleValuedTaggedColumnValueIter* pcviterSV = new( m_rgbCVITER ) CSingleValuedTaggedColumnValueIter();
				Call( pcviterSV->ErrInit(	rgbData + sizeof( TAGFLD_HEADER ),
											cbData - sizeof( TAGFLD_HEADER ),
											ptagfldhdr->FSeparated() ) );
				*ppcviter = pcviterSV;
				}
			}
		}

HandleError:
	return err;
	}


class CUnionIter
	:	public IColumnIter
	{
	public:

		//  ctor

		CUnionIter();

		//  initializes the iterator

		ERR ErrInit( IColumnIter* const pciterLHS, IColumnIter* const pciterRHS );

	public:

		//  Properties
		
		virtual ERR ErrGetWorstCaseColumnCount( size_t* const pcColumn ) const;

		//  Column Navigation
		
		virtual ERR ErrMoveBeforeFirst();
		virtual ERR ErrMoveNext();
		virtual ERR ErrSeek( const COLUMNID columnid );

		//  Column Properties

		virtual ERR ErrGetColumnId( COLUMNID* const pColumnId ) const;
		virtual ERR ErrGetColumnValueCount( size_t* const pcColumnValue ) const;

		//  Column Value Properties

		virtual ERR ErrGetColumnValue(	const size_t	iColumnValue,
										size_t* const	pcbColumnValue,
										void** const	ppvColumnValue,
										BOOL* const		pfColumnValueSeparated ) const;
		
	private:

		IColumnIter*	m_pciterLHS;
		IColumnIter*	m_pciterRHS;
		IColumnIter*	m_pciterCurr;
	};

inline CUnionIter::
CUnionIter()
	:	m_pciterLHS( NULL ),
		m_pciterRHS( NULL ),
		m_pciterCurr( NULL )
	{
	}

inline ERR CUnionIter::
ErrInit( IColumnIter* const pciterLHS, IColumnIter* const pciterRHS )
	{
	ERR err = JET_errSuccess;

	if ( !pciterLHS || !pciterRHS )
		{
		Call( ErrERRCheck( JET_errInvalidParameter ) );
		}

	m_pciterLHS		= pciterLHS;
	m_pciterRHS		= pciterRHS;

	Call( CUnionIter::ErrMoveBeforeFirst() );

HandleError:
	return err;
	}


ERR CUnionIter::
ErrGetWorstCaseColumnCount( size_t* const pcColumn ) const
	{
	ERR		err			= JET_errSuccess;
	size_t	cColumnLHS;
	size_t	cColumnRHS;

	if ( !m_pciterLHS )
		{
		Call( ErrERRCheck( JET_errNotInitialized ) );
		}
	
	Call( m_pciterLHS->ErrGetWorstCaseColumnCount( &cColumnLHS ) );
	Call( m_pciterRHS->ErrGetWorstCaseColumnCount( &cColumnRHS ) );

	*pcColumn = cColumnLHS + cColumnRHS;

HandleError:
	return err;
	}


inline ERR CUnionIter::
ErrMoveBeforeFirst()
	{
	ERR err = JET_errSuccess;

	if ( !m_pciterLHS )
		{
		Call( ErrERRCheck( JET_errNotInitialized ) );
		}

	Call( m_pciterLHS->ErrMoveBeforeFirst() );
	
	Call( m_pciterRHS->ErrMoveBeforeFirst() );
	err = m_pciterRHS->ErrMoveNext();
	Call( err == JET_errNoCurrentRecord ? JET_errSuccess : err );

	m_pciterCurr = m_pciterLHS;

HandleError:
	return err;
	}

ERR CUnionIter::
ErrMoveNext()
	{
	ERR			err			= JET_errSuccess;
	COLUMNID	columnidLHS;
	COLUMNID	columnidRHS;

	if ( !m_pciterLHS )
		{
		Call( ErrERRCheck( JET_errNotInitialized ) );
		}

	err = m_pciterCurr->ErrMoveNext();
	Call( err == JET_errNoCurrentRecord ? JET_errSuccess : err );

	err = m_pciterLHS->ErrGetColumnId( &columnidLHS );
	if ( err == JET_errNoCurrentRecord )
		{
		err = JET_errSuccess;
		columnidLHS = ~fCOLUMNIDTemplate;
		}
	Call( err );
	
	err = m_pciterRHS->ErrGetColumnId( &columnidRHS );
	if ( err == JET_errNoCurrentRecord )
		{
		err = JET_errSuccess;
		columnidRHS = ~fCOLUMNIDTemplate;
		}
	Call( err );

	if ( ( columnidLHS ^ fCOLUMNIDTemplate ) < ( columnidRHS ^ fCOLUMNIDTemplate ) )
		{
		m_pciterCurr = m_pciterLHS;
		}
	else if ( ( columnidLHS ^ fCOLUMNIDTemplate ) > ( columnidRHS ^ fCOLUMNIDTemplate ) )
		{
		m_pciterCurr = m_pciterRHS;
		}
	else
		{
		if ( columnidLHS != ~fCOLUMNIDTemplate )
			{
			err = m_pciterRHS->ErrMoveNext();
			Call( err == JET_errNoCurrentRecord ? JET_errSuccess : err );

			m_pciterCurr = m_pciterLHS;
			}
		else
			{
			Call( ErrERRCheck( JET_errNoCurrentRecord ) );
			}
		}

HandleError:
	return err;
	}

ERR CUnionIter::
ErrSeek( const COLUMNID columnid )
	{
	ERR err = JET_errSuccess;

	if ( !m_pciterLHS )
		{
		Call( ErrERRCheck( JET_errNotInitialized ) );
		}

	m_pciterCurr = m_pciterLHS;
	err = m_pciterCurr->ErrSeek( columnid );

	if ( err == JET_errRecordNotFound )
		{
		m_pciterCurr = m_pciterRHS;
		err = m_pciterCurr->ErrSeek( columnid );
		}

HandleError:
	return err;
	}


ERR CUnionIter::
ErrGetColumnId( COLUMNID* const pColumnId ) const
	{
	ERR err = JET_errSuccess;

	Call( m_pciterCurr->ErrGetColumnId( pColumnId ) );

HandleError:
	return err;
	}

ERR CUnionIter::
ErrGetColumnValueCount( size_t* const pcColumnValue ) const
	{
	ERR err = JET_errSuccess;

	Call( m_pciterCurr->ErrGetColumnValueCount( pcColumnValue ) );

HandleError:
	return err;
	}


ERR CUnionIter::
ErrGetColumnValue(	const size_t	iColumnValue,
					size_t* const	pcbColumnValue,
					void** const	ppvColumnValue,
					BOOL* const		pfColumnValueSeparated ) const
	{
	ERR err = JET_errSuccess;

	Call( m_pciterCurr->ErrGetColumnValue(	iColumnValue,
											pcbColumnValue,
											ppvColumnValue,
											pfColumnValueSeparated ) );

HandleError:
	return err;
	}

LOCAL ErrRECIFetchMissingLVs(
	FUCB*					pfucb,
	ULONG*					pcEnumColumn,
	JET_ENUMCOLUMN**		prgEnumColumn,
	JET_PFNREALLOC			pfnRealloc,
	void*					pvReallocContext,
	ULONG					cbDataMost,
	BOOL					fAfterImage )
	{
	ERR						err					= JET_errSuccess;
	ULONG					cEnumColumnT;
	ULONG&					cEnumColumn			= ( pcEnumColumn ? *pcEnumColumn : cEnumColumnT );
	JET_ENUMCOLUMN*			rgEnumColumnT;
	JET_ENUMCOLUMN*&		rgEnumColumn		= ( prgEnumColumn ? *prgEnumColumn : rgEnumColumnT );
	size_t					iEnumColumn;
	size_t					iEnumColumnValue;

	//  release our page latch, if any
	
	if ( Pcsr( pfucb )->FLatched() )
		{
		CallS( ErrDIRRelease( pfucb ) );
		}
	AssertDIRNoLatch( pfucb->ppib );

	//  walk all column values looking for missing separated LVs
	
	for ( iEnumColumn = 0; iEnumColumn < cEnumColumn; iEnumColumn++ )
		{
		JET_ENUMCOLUMN* const pEnumColumn = &rgEnumColumn[ iEnumColumn ];

		if ( pEnumColumn->err != JET_wrnColumnSingleValue )
			{
			for (	iEnumColumnValue = 0;
					iEnumColumnValue < rgEnumColumn[ iEnumColumn ].cEnumColumnValue;
					iEnumColumnValue++ )
				{
				JET_ENUMCOLUMNVALUE* const pEnumColumnValue = &pEnumColumn->rgEnumColumnValue[ iEnumColumnValue ];

				//  if this isn't a missing separated LV then skip it

				if ( pEnumColumnValue->err != wrnRECSeparatedLV )
					{
					continue;
					}

				//  retrieve the LID from cbData

				const LID lid = pEnumColumnValue->cbData;
				
				pEnumColumnValue->err		= JET_errSuccess;
				pEnumColumnValue->cbData	= 0;

				//  fetch up to the requested maximum column value size of this
				//  LV.  note that in this mode, we are retrieving a pointer to
				//  a newly allocated buffer containing the LV data NOT the LV
				//  data itself

				Call( ErrRECRetrieveSLongField(	pfucb,
												lid,
												fAfterImage,
												0,
												(BYTE*)&pEnumColumnValue->pvData,
												cbDataMost,
										  		&pEnumColumnValue->cbData,
										  		pfnRealloc,
										  		pvReallocContext ) );

				//  if the returned cbActual is larger than cbDataMost then we
				//  obviously only got cbDataMost bytes of data.  warn the caller
				//  that they didn't get all the data

				if ( pEnumColumnValue->cbData > cbDataMost )
					{
					pEnumColumnValue->err		= JET_wrnColumnTruncated;
					pEnumColumnValue->cbData	= cbDataMost;
					}
				}
			}
		}

HandleError:
	return err;
	}

LOCAL ErrRECEnumerateAllColumns(
	FUCB*					pfucb,
	ULONG*					pcEnumColumn,
	JET_ENUMCOLUMN**		prgEnumColumn,
	JET_PFNREALLOC			pfnRealloc,
	void*					pvReallocContext,
	ULONG					cbDataMost,
	JET_GRBIT				grbit )
	{
	ERR						err					= JET_errSuccess;
	ULONG					cEnumColumnT;
	ULONG&					cEnumColumn			= ( pcEnumColumn ? *pcEnumColumn : cEnumColumnT );
							cEnumColumn			= 0;
	JET_ENUMCOLUMN*			rgEnumColumnT;
	JET_ENUMCOLUMN*&		rgEnumColumn		= ( prgEnumColumn ? *prgEnumColumn : rgEnumColumnT );
							rgEnumColumn		= NULL;
	size_t					iEnumColumn;
	size_t					iEnumColumnValue;
	BOOL					fSeparatedLV		= fFalse;
	BOOL					fRecord				= fFalse;
	BOOL					fDefaultRecord		= fFalse;
	BOOL					fNonEscrowDefault	= fFalse;
	BOOL					fTaggedOnly			= fFalse;
	BOOL					fUseCopyBuffer		= fFalse;
	DATA*					pdataRec			= NULL;
	DATA*					pdataDefaultRec		= NULL;

	CFixedColumnIter		rgciterFC[ 2 ];
	size_t					iciterFC			= 0;
	CFixedColumnIter*		pciterFC			= NULL;
	CVariableColumnIter		rgciterVC[ 2 ];
	size_t					iciterVC			= 0;
	CVariableColumnIter*	pciterVC			= NULL;
	CTaggedColumnIter		rgciterTC[ 2 ];
	size_t					iciterTC			= 0;
	CTaggedColumnIter*		pciterTC			= NULL;
	CUnionIter				rgciterU[ 5 ];
	size_t					iciterU				= 0;
	CUnionIter*				pciterU				= NULL;

	IColumnIter*			pciterRec			= NULL;
	IColumnIter*			pciterDefaultRec	= NULL;
	IColumnIter*			pciterRoot			= NULL;

	FIELD					fieldFC;
	size_t					cColumnValue		= 0;
	BOOL					fSeparated			= fFalse;
	size_t					cbData				= 0;
	void*					pvData				= NULL;

	//  validate parameters

	if ( !pcEnumColumn || !prgEnumColumn || !pfnRealloc )
		{
		Call( ErrERRCheck( JET_errInvalidParameter ) );
		}
	if ( grbit & ~(	JET_bitEnumerateCopy |
					JET_bitEnumerateIgnoreDefault |
					JET_bitEnumerateLocal |
					JET_bitEnumeratePresenceOnly |
					JET_bitEnumerateTaggedOnly |
					JET_bitEnumerateCompressOutput ) )
		{
		Call( ErrERRCheck( JET_errInvalidGrbit ) );
		}

	//  NOCODE:  JET_bitEnumerateLocal is NYI

	if ( grbit & JET_bitEnumerateLocal )
		{
		Call( ErrERRCheck( JET_errInvalidGrbit ) );
		}

	//  NOCODE:  integration with user-defined callbacks is NYI

	if ( pfucb->u.pfcb->Ptdb()->FTableHasUserDefinedDefault() )
		{
		Call( ErrERRCheck( JET_errCallbackFailed ) );
		}
	
	fRecord				= fTrue;
	fDefaultRecord		= !( grbit & JET_bitEnumerateIgnoreDefault ) && pfucb->u.pfcb->Ptdb()->FTableHasDefault();
	fNonEscrowDefault	= pfucb->u.pfcb->Ptdb()->FTableHasNonEscrowDefault();
	fTaggedOnly			= grbit & JET_bitEnumerateTaggedOnly;

	//  get access to the data we need
	//
	//  NOTE:  do not unlatch the page until we are done with the iterators!

	if ( fRecord )
		{
		fUseCopyBuffer = (	(	( grbit & JET_bitEnumerateCopy ) &&
								FFUCBUpdatePrepared( pfucb ) &&
								!FFUCBNeverRetrieveCopy( pfucb ) ) ||
							FFUCBAlwaysRetrieveCopy( pfucb ) );
			
		Call( ErrRECIGetRecord( pfucb, &pdataRec, fUseCopyBuffer ) );
		}
	if ( fDefaultRecord )
		{
		pdataDefaultRec = pfucb->u.pfcb->Ptdb()->PdataDefaultRecord();
		}

	//  build an iterator tree over all our input data
	//
	//  NOTE:  if no input data is needed then the root iterator will be NULL!
	//  NOTE:  make sure we have enough iterator storage to hold these iterators

	if ( fRecord )
		{
		if ( !fTaggedOnly )
			{
			pciterVC = &rgciterVC[ iciterVC++ ];
			Call( pciterVC->ErrInit( pfucb->u.pfcb, *pdataRec ) );
			if ( !pciterRec )
				{
				pciterRec = pciterVC;
				}
			else
				{
				pciterU = &rgciterU[ iciterU++ ];
				Call( pciterU->ErrInit( pciterVC, pciterRec ) );
				pciterRec = pciterU;
				}
			}

		if ( !fTaggedOnly )
			{
			pciterFC = &rgciterFC[ iciterFC++ ];
			Call( pciterFC->ErrInit( pfucb->u.pfcb, *pdataRec ) );
			if ( !pciterRec )
				{
				pciterRec = pciterFC;
				}
			else
				{
				pciterU = &rgciterU[ iciterU++ ];
				Call( pciterU->ErrInit( pciterFC, pciterRec ) );
				pciterRec = pciterU;
				}
			}

		pciterTC = &rgciterTC[ iciterTC++ ];
		Call( pciterTC->ErrInit( pfucb->u.pfcb, *pdataRec ) );
		if ( !pciterRec )
			{
			pciterRec = pciterTC;
			}
		else
			{
			pciterU = &rgciterU[ iciterU++ ];
			Call( pciterU->ErrInit( pciterTC, pciterRec ) );
			pciterRec = pciterU;
			}
		
		if ( !pciterRoot )
			{
			pciterRoot = pciterRec;
			}
		else
			{
			pciterU = &rgciterU[ iciterU++ ];
			Call( pciterU->ErrInit( pciterRoot, pciterRec ) );
			pciterRoot = pciterU;
			}
		}
	
	if ( fDefaultRecord )
		{
		if ( !fTaggedOnly && fNonEscrowDefault )
			{
			pciterVC = &rgciterVC[ iciterVC++ ];
			Call( pciterVC->ErrInit( pfucb->u.pfcb, *pdataDefaultRec ) );
			if ( !pciterDefaultRec )
				{
				pciterDefaultRec = pciterVC;
				}
			else
				{
				pciterU = &rgciterU[ iciterU++ ];
				Call( pciterU->ErrInit( pciterVC, pciterDefaultRec ) );
				pciterDefaultRec = pciterU;
				}
			}

		if ( !fTaggedOnly )
			{
			pciterFC = &rgciterFC[ iciterFC++ ];
			Call( pciterFC->ErrInit( pfucb->u.pfcb, *pdataDefaultRec ) );
			if ( !pciterDefaultRec )
				{
				pciterDefaultRec = pciterFC;
				}
			else
				{
				pciterU = &rgciterU[ iciterU++ ];
				Call( pciterU->ErrInit( pciterFC, pciterDefaultRec ) );
				pciterDefaultRec = pciterU;
				}
			}

		if ( fNonEscrowDefault )
			{
			pciterTC = &rgciterTC[ iciterTC++ ];
			Call( pciterTC->ErrInit( pfucb->u.pfcb, *pdataDefaultRec ) );
			if ( !pciterDefaultRec )
				{
				pciterDefaultRec = pciterTC;
				}
			else
				{
				pciterU = &rgciterU[ iciterU++ ];
				Call( pciterU->ErrInit( pciterTC, pciterDefaultRec ) );
				pciterDefaultRec = pciterU;
				}
			}

		if ( pciterDefaultRec )
			{
			if ( !pciterRoot )
				{
				pciterRoot = pciterDefaultRec;
				}
			else
				{
				pciterU = &rgciterU[ iciterU++ ];
				Call( pciterU->ErrInit( pciterRoot, pciterDefaultRec ) );
				pciterRoot = pciterU;
				}
			}
		}

	//  get worst case storage for the column array
	
	size_t cColumnWorstCase;
	Call( pciterRoot->ErrGetWorstCaseColumnCount( &cColumnWorstCase ) );
	cEnumColumn = (ULONG)cColumnWorstCase;

	Alloc( rgEnumColumn = (JET_ENUMCOLUMN*)pfnRealloc(
			pvReallocContext,
			NULL,
			cEnumColumn * sizeof( JET_ENUMCOLUMN ) ) );
	memset( rgEnumColumn, 0, cEnumColumn * sizeof( JET_ENUMCOLUMN ) );

	//  walk all columns in the input data

	Call( pciterRoot->ErrMoveBeforeFirst() );
	for ( iEnumColumn = 0; iEnumColumn < cEnumColumn; iEnumColumn++ )
		{
		JET_ENUMCOLUMN* const pEnumColumn = &rgEnumColumn[ iEnumColumn ];

		//  if we have walked off the end of the input array then we are done
		
		err = pciterRoot->ErrMoveNext();
		if ( err == JET_errNoCurrentRecord )
			{
			err = JET_errSuccess;
			cEnumColumn = iEnumColumn;
			continue;
			}
		Call( err );

		//  if we do not have access to this column then do not include it
		//  in the output array
		
		Call( pciterRoot->ErrGetColumnId( &pEnumColumn->columnid ) );

		err = ErrRECIAccessColumn( pfucb, pEnumColumn->columnid, &fieldFC );
		if ( err == JET_errColumnNotFound )
			{
			err = JET_errSuccess;
			iEnumColumn--;
			continue;
			}
		Call( err );

		//  get the properties for this column

		Call( pciterRoot->ErrGetColumnValueCount( &cColumnValue ) );

		//  if the column is NULL then include it in the output array

		if ( !cColumnValue )
			{
			pEnumColumn->err = ErrERRCheck( JET_wrnColumnNull );
			continue;
			}

		//  if we are testing for the presence of a column value only then
		//  return that it is present but do not return any column values

		if ( grbit & JET_bitEnumeratePresenceOnly )
			{
			pEnumColumn->err = ErrERRCheck( JET_wrnColumnPresent );
			continue;
			}

		//  if there is only one column value and output compression was
		//  requested and the caller asked for all column values then we may be
		//  able to put the column value directly in the JET_ENUMCOLUMN struct

		if (	cColumnValue == 1 &&
				( grbit & JET_bitEnumerateCompressOutput ) )
			{
			//  get the properties for this column value

			Call( pciterRoot->ErrGetColumnValue( 1, &cbData, &pvData, &fSeparated ) );

			//  this column value is suitable for compression
			//
			//  NOTE:  currently, this criteria equals zero chance of needing
			//  to return a warning for this column

			if ( !fSeparated )
				{
				//  store the column value in the JET_ENUMCOLUMN struct

				pEnumColumn->err = ErrERRCheck( JET_wrnColumnSingleValue );
				pEnumColumn->cbData = (ULONG)cbData;
				Alloc( pEnumColumn->pvData = pfnRealloc( pvReallocContext, NULL, cbData ) );

				if ( !FHostIsLittleEndian() && FCOLUMNIDFixed( pEnumColumn->columnid ) )
					{
					switch ( fieldFC.cbMaxLen )
						{
						case 1:
							*((BYTE*)pEnumColumn->pvData) = *((UnalignedLittleEndian< BYTE >*)pvData);
							break;
							
						case 2:
							*((USHORT*)pEnumColumn->pvData) = *((UnalignedLittleEndian< USHORT >*)pvData);
							break;

						case 4:
							*((ULONG*)pEnumColumn->pvData) = *((UnalignedLittleEndian< ULONG >*)pvData);
							break;

						case 8:
							*((QWORD*)pEnumColumn->pvData) = *((UnalignedLittleEndian< QWORD >*)pvData);
							break;

						default:
							Assert( fFalse );
							Call( ErrERRCheck( JET_errInternalError ) );
							break;
						}
					}
				else
					{
					memcpy(	pEnumColumn->pvData,
							pvData,
							pEnumColumn->cbData );
					}

				//  if this is an escrow update column then adjust it

				if (	FCOLUMNIDFixed( pEnumColumn->columnid ) &&
						FFIELDEscrowUpdate( fieldFC.ffield ) &&
						!FFUCBInsertPrepared( pfucb ) )
					{
					Call( ErrRECAdjustEscrowedColumn(	pfucb,
														pEnumColumn->columnid,
														fieldFC.ibRecordOffset,
														pEnumColumn->pvData,
														pEnumColumn->cbData ) );
					}

				//  we're done with this column

				continue;
				}
			}

		//  get storage for the column value array

		pEnumColumn->cEnumColumnValue = (ULONG)cColumnValue;

		Alloc( pEnumColumn->rgEnumColumnValue = (JET_ENUMCOLUMNVALUE*)pfnRealloc(
				pvReallocContext,
				NULL,
				pEnumColumn->cEnumColumnValue * sizeof( JET_ENUMCOLUMNVALUE ) ) );
		memset(	pEnumColumn->rgEnumColumnValue,
				0,
				pEnumColumn->cEnumColumnValue * sizeof( JET_ENUMCOLUMNVALUE ) );

		//  walk all column values for this column in the input data

		for (	iEnumColumnValue = 0;
				iEnumColumnValue < pEnumColumn->cEnumColumnValue;
				iEnumColumnValue++ )
			{
			JET_ENUMCOLUMNVALUE* const pEnumColumnValue = &pEnumColumn->rgEnumColumnValue[ iEnumColumnValue ];

			pEnumColumnValue->itagSequence = (ULONG)( iEnumColumnValue + 1 );

			//  get the properties for this column value

			Call( pciterRoot->ErrGetColumnValue( pEnumColumnValue->itagSequence, &cbData, &pvData, &fSeparated ) );
			
			//  if this column value is a separated long value, then we must
			//  defer fetching it until after we have iterated the record. 
			//  we will do this by flagging the column value with
			//  wrnRECSeparatedLV and storing the LID in cbData

			if ( fSeparated )
				{
				pEnumColumnValue->err		= ErrERRCheck( wrnRECSeparatedLV );
				pEnumColumnValue->cbData	= LidOfSeparatedLV( (BYTE*)pvData );

				fSeparatedLV = fTrue;
				continue;
				}

			//  store the column value
			
			pEnumColumnValue->cbData = (ULONG)cbData;
			Alloc( pEnumColumnValue->pvData = pfnRealloc( pvReallocContext, NULL, cbData ) );

			if ( !FHostIsLittleEndian() && FCOLUMNIDFixed( pEnumColumn->columnid ) )
				{
				switch ( fieldFC.cbMaxLen )
					{
					case 1:
						*((BYTE*)pEnumColumnValue->pvData) = *((UnalignedLittleEndian< BYTE >*)pvData);
						break;
						
					case 2:
						*((USHORT*)pEnumColumnValue->pvData) = *((UnalignedLittleEndian< USHORT >*)pvData);
						break;

					case 4:
						*((ULONG*)pEnumColumnValue->pvData) = *((UnalignedLittleEndian< ULONG >*)pvData);
						break;

					case 8:
						*((QWORD*)pEnumColumnValue->pvData) = *((UnalignedLittleEndian< QWORD >*)pvData);
						break;

					default:
						Assert( fFalse );
						Call( ErrERRCheck( JET_errInternalError ) );
						break;
					}
				}
			else
				{
				memcpy(	pEnumColumnValue->pvData,
						pvData,
						pEnumColumnValue->cbData );
				}

			//  if this is an escrow update column then adjust it

			if (	FCOLUMNIDFixed( pEnumColumn->columnid ) &&
					FFIELDEscrowUpdate( fieldFC.ffield ) &&
					!FFUCBInsertPrepared( pfucb ) )
				{
				Call( ErrRECAdjustEscrowedColumn(	pfucb,
													pEnumColumn->columnid,
													fieldFC.ibRecordOffset,
													pEnumColumnValue->pvData,
													pEnumColumnValue->cbData ) );
				}
			}
		}

	//  we should have reached the end of the input data or else the "worst
	//  case" column count wasn't actually the worst case now was it?

	Assert( pciterRoot->ErrMoveNext() == JET_errNoCurrentRecord );

	//  we need to fixup some missing separated LVs
	//
	//  NOTE:  as soon as we do this our iterators are invalid

	if ( fSeparatedLV )
		{
		//  If we are retrieving an after-image or
		//	haven't replaced a LV we can simply go
		//	to the LV tree. Otherwise we have to
		//	perform a more detailed consultation of
		//	the version store with ErrRECGetLVImage
		const BOOL fAfterImage = fUseCopyBuffer
								|| !FFUCBUpdateSeparateLV( pfucb )
								|| !FFUCBReplacePrepared( pfucb );

		Call( ErrRECIFetchMissingLVs(	pfucb,
										pcEnumColumn,
										prgEnumColumn,
										pfnRealloc,
										pvReallocContext,
										cbDataMost,
										fAfterImage ) );
		}

	//  cleanup
	
HandleError:
	if ( Pcsr( pfucb )->FLatched() )
		{
		CallS( ErrDIRRelease( pfucb ) );
		}
	AssertDIRNoLatch( pfucb->ppib );

	if ( err < JET_errSuccess )
		{
		if ( prgEnumColumn )
			{
			for ( iEnumColumn = 0; iEnumColumn < cEnumColumn; iEnumColumn++ )
				{
				if ( rgEnumColumn[ iEnumColumn ].err != JET_wrnColumnSingleValue )
					{
					for (	iEnumColumnValue = 0;
							iEnumColumnValue < rgEnumColumn[ iEnumColumn ].cEnumColumnValue;
							iEnumColumnValue++ )
						{
						pfnRealloc(	pvReallocContext,
									rgEnumColumn[ iEnumColumn ].rgEnumColumnValue[ iEnumColumnValue ].pvData,
									0 );
						}
					pfnRealloc(	pvReallocContext,
								rgEnumColumn[ iEnumColumn ].rgEnumColumnValue,
								0 );
					}
				else
					{
					pfnRealloc(	pvReallocContext,
								rgEnumColumn[ iEnumColumn ].pvData,
								0 );
					}
				}
			pfnRealloc( pvReallocContext, rgEnumColumn, 0 );
			rgEnumColumn = NULL;
			}
		if ( pcEnumColumn )
			{
			cEnumColumn = 0;
			}
		}
	return err;
	}

LOCAL ErrRECEnumerateReqColumns(
	FUCB*					pfucb,
	ULONG					cEnumColumnId,
	JET_ENUMCOLUMNID*		rgEnumColumnId,
	ULONG*					pcEnumColumn,
	JET_ENUMCOLUMN**		prgEnumColumn,
	JET_PFNREALLOC			pfnRealloc,
	void*					pvReallocContext,
	ULONG					cbDataMost,
	JET_GRBIT				grbit )
	{
	ERR						err					= JET_errSuccess;
	ULONG					cEnumColumnT;
	ULONG&					cEnumColumn			= ( pcEnumColumn ? *pcEnumColumn : cEnumColumnT );
							cEnumColumn			= 0;
	JET_ENUMCOLUMN*			rgEnumColumnT;
	JET_ENUMCOLUMN*&		rgEnumColumn		= ( prgEnumColumn ? *prgEnumColumn : rgEnumColumnT );
							rgEnumColumn		= NULL;
	BOOL					fColumnIdError		= fFalse;
	BOOL					fRetColumnIdError	= fFalse;
	BOOL					fSeparatedLV		= fFalse;
	size_t					iEnumColumn			= 0;
	size_t					iEnumColumnValue	= 0;
	BOOL					fUseCopyBuffer		= fFalse;
	DATA*					pdataRec			= NULL;
	DATA*					pdataDefaultRec		= NULL;
	BOOL					fNonEscrowDefault	= fFalse;
	FIELD					fieldFC;
	CTaggedColumnIter		rgciterTC[ 2 ];
	CTaggedColumnIter*		pciterTC			= NULL;
	CTaggedColumnIter*		pciterTCDefault		= NULL;
	CFixedColumnIter		rgciterFC[ 2 ];
	CFixedColumnIter*		pciterFC			= NULL;
	CFixedColumnIter*		pciterFCDefault		= NULL;
	CVariableColumnIter		rgciterVC[ 2 ];
	CVariableColumnIter*	pciterVC			= NULL;
	CVariableColumnIter*	pciterVCDefault		= NULL;
	IColumnIter*			pciter				= NULL;
	size_t					cColumnValue		= 0;
	BOOL					fSeparated			= fFalse;
	size_t					cbData				= 0;
	void*					pvData				= NULL;

	//  validate parameters

	if ( !pcEnumColumn || !prgEnumColumn || !pfnRealloc )
		{
		Call( ErrERRCheck( JET_errInvalidParameter ) );
		}
	if ( grbit & ~(	JET_bitEnumerateCopy |
					JET_bitEnumerateIgnoreDefault |
					JET_bitEnumerateLocal |
					JET_bitEnumeratePresenceOnly |
					JET_bitEnumerateCompressOutput ) )
		{
		Call( ErrERRCheck( JET_errInvalidGrbit ) );
		}

	//  NOCODE:  JET_bitEnumerateLocal is NYI

	if ( grbit & JET_bitEnumerateLocal )
		{
		Call( ErrERRCheck( JET_errInvalidGrbit ) );
		}

	//  NOCODE:  integration with user-defined callbacks is NYI

	if ( pfucb->u.pfcb->Ptdb()->FTableHasUserDefinedDefault() )
		{
		Call( ErrERRCheck( JET_errCallbackFailed ) );
		}

	//  get access to the data we need

	fUseCopyBuffer = (	(	( grbit & JET_bitEnumerateCopy ) &&
							FFUCBUpdatePrepared( pfucb ) &&
							!FFUCBNeverRetrieveCopy( pfucb ) ) ||
						FFUCBAlwaysRetrieveCopy( pfucb ) );
		
	Call( ErrRECIGetRecord( pfucb, &pdataRec, fUseCopyBuffer ) );

	if ( !( grbit & JET_bitEnumerateIgnoreDefault ) && pfucb->u.pfcb->Ptdb()->FTableHasDefault() )
		{
		pdataDefaultRec = pfucb->u.pfcb->Ptdb()->PdataDefaultRecord();
		fNonEscrowDefault = pfucb->u.pfcb->Ptdb()->FTableHasNonEscrowDefault();
		}

	//  allocate storage for the column array
	
	cEnumColumn = cEnumColumnId;

	Alloc( rgEnumColumn = (JET_ENUMCOLUMN*)pfnRealloc(
			pvReallocContext,
			NULL,
			cEnumColumn * sizeof( JET_ENUMCOLUMN ) ) );
	memset( rgEnumColumn, 0, cEnumColumn * sizeof( JET_ENUMCOLUMN ) );

	//  walk all requested columns

	for ( iEnumColumn = 0; iEnumColumn < cEnumColumn; iEnumColumn++ )
		{
		JET_ENUMCOLUMN* const pEnumColumn = &rgEnumColumn[ iEnumColumn ];

		//  if the requested column id is zero then we should skip this column
		
		pEnumColumn->columnid = rgEnumColumnId[ iEnumColumn ].columnid;

		if ( !pEnumColumn->columnid )
			{
			pEnumColumn->err = ErrERRCheck( JET_wrnColumnSkipped );
			continue;
			}

		//  if we do not have access to the requested column then set the
		//  appropriate error for this column so that the caller can see
		//  which column ids were bad

		err = ErrRECIAccessColumn( pfucb, pEnumColumn->columnid, &fieldFC );
		if ( err == JET_errBadColumnId || err == JET_errColumnNotFound )
			{
			pEnumColumn->err = err;

			fColumnIdError = fTrue;
			
			err = JET_errSuccess;
			continue;
			}
		Call( err );

		//  lookup the value for this column in the record.  if we cannot find
		//  a value there and we are returning default values then lookup the
		//  value for this column in the default record

		if ( FCOLUMNIDTagged( pEnumColumn->columnid ) )
			{
			if ( !pciterTC )
				{
				pciterTC = &rgciterTC[ 0 ];
				Call( pciterTC->ErrInit( pfucb->u.pfcb, *pdataRec ) );
				}
			err = pciterTC->ErrSeek( pEnumColumn->columnid );
			pciter = pciterTC;
			if ( err == JET_errRecordNotFound && fNonEscrowDefault )
				{
				if ( !pciterTCDefault )
					{
					pciterTCDefault = &rgciterTC[ 1 ];
					Call( pciterTCDefault->ErrInit( pfucb->u.pfcb, *pdataDefaultRec ) );
					}
				err = pciterTCDefault->ErrSeek( pEnumColumn->columnid );
				pciter = pciterTCDefault;
				}
			}
		else if ( FCOLUMNIDFixed( pEnumColumn->columnid ) )
			{
			if ( !pciterFC )
				{
				pciterFC = &rgciterFC[ 0 ];
				Call( pciterFC->ErrInit( pfucb->u.pfcb, *pdataRec ) );
				}
			err = pciterFC->ErrSeek( pEnumColumn->columnid );
			pciter = pciterFC;
			if ( err == JET_errRecordNotFound && pdataDefaultRec )
				{
				if ( !pciterFCDefault )
					{
					pciterFCDefault = &rgciterFC[ 1 ];
					Call( pciterFCDefault->ErrInit( pfucb->u.pfcb, *pdataDefaultRec ) );
					}
				err = pciterFCDefault->ErrSeek( pEnumColumn->columnid );
				pciter = pciterFCDefault;
				}
			}
		else
			{
			if ( !pciterVC )
				{
				pciterVC = &rgciterVC[ 0 ];
				Call( pciterVC->ErrInit( pfucb->u.pfcb, *pdataRec ) );
				}
			err = pciterVC->ErrSeek( pEnumColumn->columnid );
			pciter = pciterVC;
			if ( err == JET_errRecordNotFound && fNonEscrowDefault )
				{
				if ( !pciterVCDefault )
					{
					pciterVCDefault = &rgciterVC[ 1 ];
					Call( pciterVCDefault->ErrInit( pfucb->u.pfcb, *pdataDefaultRec ) );
					}
				err = pciterVCDefault->ErrSeek( pEnumColumn->columnid );
				pciter = pciterVCDefault;
				}
			}

		//  if we couldn't find a value for the column then it is NULL

		if ( err == JET_errRecordNotFound )
			{
			pEnumColumn->err = ErrERRCheck( JET_wrnColumnNull );
			
			err = JET_errSuccess;
			continue;
			}
		Call( err );

		//  get the properties for this column

		Call( pciter->ErrGetColumnValueCount( &cColumnValue ) );
		
		//  if the column is explicitly set to NULL then report that

		if ( !cColumnValue )
			{
			pEnumColumn->err = ErrERRCheck( JET_wrnColumnNull );
			continue;
			}

		//  if we are testing for the presence of a column value only and
		//  the caller asked for all column values then return that the column
		//  is present but do not return any column values

		if (	( grbit & JET_bitEnumeratePresenceOnly ) &&
				!rgEnumColumnId[ iEnumColumn ].ctagSequence )
			{
			pEnumColumn->err = ErrERRCheck( JET_wrnColumnPresent );
			continue;
			}

		//  if there is only one column value and output compression was
		//  requested and the caller asked for all column values then we may be
		//  able to put the column value directly in the JET_ENUMCOLUMN struct

		if (	cColumnValue == 1 &&
				( grbit & JET_bitEnumerateCompressOutput ) &&
				!rgEnumColumnId[ iEnumColumn ].ctagSequence )
			{
			//  get the properties for this column value

			Call( pciter->ErrGetColumnValue( 1, &cbData, &pvData, &fSeparated ) );

			//  this column value is suitable for compression
			//
			//  NOTE:  currently, this criteria equals zero chance of needing
			//  to return a warning for this column

			if ( !fSeparated )
				{
				//  store the column value in the JET_ENUMCOLUMN struct

				pEnumColumn->err = ErrERRCheck( JET_wrnColumnSingleValue );
				pEnumColumn->cbData = (ULONG)cbData;
				Alloc( pEnumColumn->pvData = pfnRealloc( pvReallocContext, NULL, cbData ) );

				if ( !FHostIsLittleEndian() && FCOLUMNIDFixed( pEnumColumn->columnid ) )
					{
					switch ( fieldFC.cbMaxLen )
						{
						case 1:
							*((BYTE*)pEnumColumn->pvData) = *((UnalignedLittleEndian< BYTE >*)pvData);
							break;
							
						case 2:
							*((USHORT*)pEnumColumn->pvData) = *((UnalignedLittleEndian< USHORT >*)pvData);
							break;

						case 4:
							*((ULONG*)pEnumColumn->pvData) = *((UnalignedLittleEndian< ULONG >*)pvData);
							break;

						case 8:
							*((QWORD*)pEnumColumn->pvData) = *((UnalignedLittleEndian< QWORD >*)pvData);
							break;

						default:
							Assert( fFalse );
							Call( ErrERRCheck( JET_errInternalError ) );
							break;
						}
					}
				else
					{
					memcpy(	pEnumColumn->pvData,
							pvData,
							pEnumColumn->cbData );
					}

				//  if this is an escrow update column then adjust it

				if (	FCOLUMNIDFixed( pEnumColumn->columnid ) &&
						FFIELDEscrowUpdate( fieldFC.ffield ) &&
						!FFUCBInsertPrepared( pfucb ) )
					{
					Call( ErrRECAdjustEscrowedColumn(	pfucb,
														pEnumColumn->columnid,
														fieldFC.ibRecordOffset,
														pEnumColumn->pvData,
														pEnumColumn->cbData ) );
					}

				//  we're done with this column

				continue;
				}
			}

		//  get storage for the column value array

		pEnumColumn->cEnumColumnValue = rgEnumColumnId[ iEnumColumn ].ctagSequence;
		if ( !pEnumColumn->cEnumColumnValue )
			{
			pEnumColumn->cEnumColumnValue = (ULONG)cColumnValue;
			}

		Alloc( pEnumColumn->rgEnumColumnValue = (JET_ENUMCOLUMNVALUE*)pfnRealloc(
				pvReallocContext,
				NULL,
				pEnumColumn->cEnumColumnValue * sizeof( JET_ENUMCOLUMNVALUE ) ) );
		memset(	pEnumColumn->rgEnumColumnValue,
				0,
				pEnumColumn->cEnumColumnValue * sizeof( JET_ENUMCOLUMNVALUE ) );

		//  walk all requested column values
		//  NOCODE:  JET_wrnColumnMoreTags is NYI
		
		for (	iEnumColumnValue = 0;
				iEnumColumnValue < pEnumColumn->cEnumColumnValue;
				iEnumColumnValue++ )
			{
			JET_ENUMCOLUMNVALUE* const pEnumColumnValue = &pEnumColumn->rgEnumColumnValue[ iEnumColumnValue ];

			//  if the requested itagSequence is zero then we should skip
			//  this column value

			if ( rgEnumColumnId[ iEnumColumn ].ctagSequence )
				{
				pEnumColumnValue->itagSequence = rgEnumColumnId[ iEnumColumn ].rgtagSequence[ iEnumColumnValue ];
				}
			else
				{
				pEnumColumnValue->itagSequence = (ULONG)( iEnumColumnValue + 1 );
				}

			if ( !pEnumColumnValue->itagSequence )
				{
				pEnumColumnValue->err = ErrERRCheck( JET_wrnColumnSkipped );
				continue;
				}

			//  if there is no corresponding column value for the requested
			//  itagSequence then the column value is NULL

			if ( pEnumColumnValue->itagSequence > cColumnValue )
				{
				pEnumColumnValue->err = ErrERRCheck( JET_wrnColumnNull );
				continue;
				}

			//  if we are testing for the presence of a column value only then
			//  return that it is present but do not return the column value

			if ( grbit & JET_bitEnumeratePresenceOnly )
				{
				pEnumColumnValue->err = ErrERRCheck( JET_wrnColumnPresent );
				continue;
				}

			//  get the properties for this column value

			Call( pciter->ErrGetColumnValue( pEnumColumnValue->itagSequence, &cbData, &pvData, &fSeparated ) );
			
			//  if this column value is a separated long value, then we must
			//  defer fetching it until after we have iterated the record. 
			//  we will do this by flagging the column value with
			//  wrnRECSeparatedLV and storing the LID in cbData

			if ( fSeparated )
				{
				pEnumColumnValue->err		= ErrERRCheck( wrnRECSeparatedLV );
				pEnumColumnValue->cbData	= LidOfSeparatedLV( (BYTE*)pvData );

				fSeparatedLV = fTrue;
				continue;
				}

			//  store the column value
			
			pEnumColumnValue->cbData = (ULONG)cbData;
			Alloc( pEnumColumnValue->pvData = pfnRealloc( pvReallocContext, NULL, cbData ) );

			if ( !FHostIsLittleEndian() && FCOLUMNIDFixed( pEnumColumn->columnid ) )
				{
				switch ( fieldFC.cbMaxLen )
					{
					case 1:
						*((BYTE*)pEnumColumnValue->pvData) = *((UnalignedLittleEndian< BYTE >*)pvData);
						break;
						
					case 2:
						*((USHORT*)pEnumColumnValue->pvData) = *((UnalignedLittleEndian< USHORT >*)pvData);
						break;

					case 4:
						*((ULONG*)pEnumColumnValue->pvData) = *((UnalignedLittleEndian< ULONG >*)pvData);
						break;

					case 8:
						*((QWORD*)pEnumColumnValue->pvData) = *((UnalignedLittleEndian< QWORD >*)pvData);
						break;

					default:
						Assert( fFalse );
						Call( ErrERRCheck( JET_errInternalError ) );
						break;
					}
				}
			else
				{
				memcpy(	pEnumColumnValue->pvData,
						pvData,
						pEnumColumnValue->cbData );
				}

			//  if this is an escrow update column then adjust it

			if (	FCOLUMNIDFixed( pEnumColumn->columnid ) &&
					FFIELDEscrowUpdate( fieldFC.ffield ) &&
					!FFUCBInsertPrepared( pfucb ) )
				{
				Call( ErrRECAdjustEscrowedColumn(	pfucb,
													pEnumColumn->columnid,
													fieldFC.ibRecordOffset,
													pEnumColumnValue->pvData,
													pEnumColumnValue->cbData ) );
				}
			}
		}

	//  we need to fixup some missing separated LVs

	if ( fSeparatedLV )
		{
		//  If we are retrieving an after-image or
		//	haven't replaced a LV we can simply go
		//	to the LV tree. Otherwise we have to
		//	perform a more detailed consultation of
		//	the version store with ErrRECGetLVImage
		const BOOL fAfterImage = fUseCopyBuffer
								|| !FFUCBUpdateSeparateLV( pfucb )
								|| !FFUCBReplacePrepared( pfucb );

		Call( ErrRECIFetchMissingLVs(	pfucb,
										pcEnumColumn,
										prgEnumColumn,
										pfnRealloc,
										pvReallocContext,
										cbDataMost,
										fAfterImage ) );
		}

	//  if there was a column id error then return the first one we see

	if ( fColumnIdError )
		{
		fRetColumnIdError = fTrue;
		for ( iEnumColumn = 0; iEnumColumn < cEnumColumn; iEnumColumn++ )
			{
			JET_ENUMCOLUMN* const pEnumColumn = &rgEnumColumn[ iEnumColumn ];
			if ( pEnumColumn->err < JET_errSuccess )
				{
				Call( ErrERRCheck( pEnumColumn->err ) );
				}
			}
		fRetColumnIdError = fFalse;
		err = JET_errSuccess;
		}

	//  cleanup
	
HandleError:
	if ( Pcsr( pfucb )->FLatched() )
		{
		CallS( ErrDIRRelease( pfucb ) );
		}
	AssertDIRNoLatch( pfucb->ppib );

	if ( err < JET_errSuccess )
		{
		if ( !fRetColumnIdError )
			{
			if ( prgEnumColumn )
				{
				for ( iEnumColumn = 0; iEnumColumn < cEnumColumn; iEnumColumn++ )
					{
					if ( rgEnumColumn[ iEnumColumn ].err != JET_wrnColumnSingleValue )
						{
						for (	iEnumColumnValue = 0;
								iEnumColumnValue < rgEnumColumn[ iEnumColumn ].cEnumColumnValue;
								iEnumColumnValue++ )
							{
							pfnRealloc(	pvReallocContext,
										rgEnumColumn[ iEnumColumn ].rgEnumColumnValue[ iEnumColumnValue ].pvData,
										0 );
							}
						pfnRealloc(	pvReallocContext,
									rgEnumColumn[ iEnumColumn ].rgEnumColumnValue,
									0 );
						}
					else
						{
						pfnRealloc(	pvReallocContext,
									rgEnumColumn[ iEnumColumn ].pvData,
									0 );
						}
					}
				pfnRealloc( pvReallocContext, rgEnumColumn, 0 );
				rgEnumColumn = NULL;
				}
			if ( pcEnumColumn )
				{
				cEnumColumn = 0;
				}
			}
		}
	return err;
	}

ERR VTAPI ErrIsamEnumerateColumns(
	JET_SESID				vsesid,
	JET_VTID				vtid,
	unsigned long			cEnumColumnId,
	JET_ENUMCOLUMNID*		rgEnumColumnId,
	unsigned long*			pcEnumColumn,
	JET_ENUMCOLUMN**		prgEnumColumn,
	JET_PFNREALLOC			pfnRealloc,
	void*					pvReallocContext,
	unsigned long			cbDataMost,
	JET_GRBIT				grbit )
	{
	ERR		err;
	PIB*	ppib				= (PIB *)vsesid;
	FUCB*	pfucb				= (FUCB *)vtid;
	BOOL	fTransactionStarted	= fFalse;

	CallR( ErrPIBCheck( ppib ) );
	CheckFUCB( ppib, pfucb );
	AssertDIRNoLatch( ppib );

	if ( 0 == ppib->level )
		{
		// Begin transaction for read consistency (in case page
		// latch must be released in order to validate column).
		Call( ErrDIRBeginTransaction( ppib, JET_bitTransactionReadOnly ) );
		fTransactionStarted = fTrue;
		}
		
	AssertDIRNoLatch( ppib );
	Assert( FFUCBSort( pfucb ) || FFUCBIndex( pfucb ) );

	//  if no column list is given then enumerate all columns

	if ( !cEnumColumnId )
		{
		Call( ErrRECEnumerateAllColumns(	pfucb,
											pcEnumColumn,
											prgEnumColumn,
											pfnRealloc,
											pvReallocContext,
											cbDataMost,
											grbit ) );
		}

	//  if an explicit column list is provided then enumerate those columns

	else
		{
		Call( ErrRECEnumerateReqColumns(	pfucb,
											cEnumColumnId,
											rgEnumColumnId,
											pcEnumColumn,
											prgEnumColumn,
											pfnRealloc,
											pvReallocContext,
											cbDataMost,
											grbit ) );
		}

HandleError:
	if ( fTransactionStarted )
		{
		//	No updates performed, so force success.
		CallS( ErrDIRCommitTransaction( ppib, NO_GRBIT ) );
		}
	AssertDIRNoLatch( ppib );

	return err;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ese98\src\ese\fldmod.cxx ===
#include "std.hxx"


LOCAL ERR ErrRECISetAutoincrement( FUCB *pfucb )
	{
	ERR				err				= JET_errSuccess;
	FUCB			* pfucbT		= pfucbNil;
	FCB				* const pfcbT	= pfucb->u.pfcb;
	TDB				* const ptdbT	= pfcbT->Ptdb();
	const BOOL		fTemplateColumn	= ptdbT->FFixedTemplateColumn( ptdbT->FidAutoincrement() );
	const COLUMNID	columnidT		= ColumnidOfFid( ptdbT->FidAutoincrement(), fTemplateColumn );
	QWORD			qwT				= 0;
	ULONG			ulT;
	const BOOL		f8BytesAutoInc	= ptdbT->F8BytesAutoInc();
	ULONG			cbT;
	DATA			dataT;

	Assert( pfucb != pfucbNil );
	Assert( pfcbT != pfcbNil );

	Assert( !( pfcbT->FTypeSort()
			|| pfcbT->FTypeTemporaryTable() ) );	// Don't currently support autoinc with sorts/temp. tables

	//	If autoincrement is not yet initialized, query table to
	//	initialize autoincrement value.
	//
	if  ( ptdbT->QwAutoincrement() == 0 )
		{
		BOOL	fAbleToUseIndex		= fFalse;
		QWORD	qwAutoincrement		= 0;
		FDPINFO	fdpinfo				= { pfcbT->PgnoFDP(), pfcbT->ObjidFDP() };
		CHAR	szObjectName[JET_cbNameMost+1];

		Assert( 0 != columnidT );

		pfcbT->EnterDML();
		Assert( strlen( ptdbT->SzTableName() ) <= JET_cbNameMost );
		strcpy( szObjectName, ptdbT->SzTableName() );
		pfcbT->LeaveDML();

		//	Get new table cursor.
		//
		Call( ErrFILEOpenTable(
			pfucb->ppib,
			pfucb->ifmp,
			&pfucbT,
			szObjectName,
			NO_GRBIT,
			&fdpinfo ) );

		// Set updating latch, to freeze index list.
		Call( pfcbT->ErrSetUpdatingAndEnterDML( pfucb->ppib ) );

		//	Look for autoincrement column.  If found, look for index with
		//	first column as autoincrement column and seek on index to find
		//	maximum existing autoincrement column.  If no such index can be
		//	found, scan table for maximum existing autoincrement column.
		//
		FCB		*pfcbIdx;
		BOOL	fDescending = fFalse;
		
		pfcbT->AssertDML();
		for ( pfcbIdx = pfcbT->Pidb() == pidbNil ? pfcbT->PfcbNextIndex() : pfcbT;
			pfcbIdx != pfcbNil;
			pfcbIdx = pfcbIdx->PfcbNextIndex() )
			{
			if ( !pfcbIdx->FDeletePending() )
				{
				Assert( pfcbIdx->Pidb() != pidbNil );
				const IDXSEG*	rgidxseg = PidxsegIDBGetIdxSeg( pfcbIdx->Pidb(), ptdbT );
				if ( rgidxseg[0].Columnid() == columnidT )
					{
					if ( rgidxseg[0].FDescending() )
						fDescending = fTrue;
					break;
					}
				}
			}

		if  ( pfcbIdx != pfcbNil )
			{
			//	Seek on found index for maximum autoincrement value.
			//
			Assert( pfcbIdx->Pidb() != pidbNil );
			Assert( strlen( ptdbT->SzIndexName( pfcbIdx->Pidb()->ItagIndexName(), pfcbIdx->FDerivedIndex() ) ) <= JET_cbNameMost );
			strcpy(
				szObjectName,
				ptdbT->SzIndexName( pfcbIdx->Pidb()->ItagIndexName(), pfcbIdx->FDerivedIndex() ) );
			pfcbT->LeaveDML();

			// May not be able to use index if it's versioned.  In that case,
			// revert to clustered index scan.
			err = ErrIsamSetCurrentIndex(
						(JET_SESID)pfucb->ppib,
						(JET_VTID)pfucbT,
						szObjectName );

			// The open cursor in the index will prevent the index from being
			// deleted, so we no longer need the updating latch.
			pfcbT->ResetUpdating();

			if ( err < 0 )
				{
				if ( JET_errIndexNotFound != err )
					{
					goto HandleError;
					}
				}
			else
				{
				err = ErrIsamMove(
							(JET_SESID)pfucb->ppib,
							(JET_VTID)pfucbT,
							fDescending ? JET_MoveFirst : JET_MoveLast,
							NO_GRBIT );
				if	( err < 0 )
					{
					if ( err != JET_errNoCurrentRecord )
						goto HandleError;
						
					Assert( qwAutoincrement == 0 );
					}
				else
					{
					if ( !f8BytesAutoInc )
						{
						ULONG ulAutoincrement;
						ulAutoincrement = (ULONG)qwAutoincrement;
						Call( ErrIsamRetrieveColumn(
								(JET_SESID)pfucb->ppib,
								(JET_VTID)pfucbT,
								columnidT,
								&ulAutoincrement,
								sizeof(ulAutoincrement),
								&cbT,
								JET_bitRetrieveFromIndex,
								NULL ) );
						qwAutoincrement = ulAutoincrement;
						Assert( cbT == sizeof(ulAutoincrement) );
						}
					else
						{
						Call( ErrIsamRetrieveColumn(
								(JET_SESID)pfucb->ppib,
								(JET_VTID)pfucbT,
								columnidT,
								&qwAutoincrement,
								sizeof(qwAutoincrement),
								&cbT,
								JET_bitRetrieveFromIndex,
								NULL ) );
						Assert( cbT == sizeof(qwAutoincrement) );
						}
					}
				fAbleToUseIndex = fTrue;
				}
			}

		else
			{
			pfcbT->ResetUpdatingAndLeaveDML();
			}

		if ( !fAbleToUseIndex )
			{
			//	Scan clustered index for maximum autoincrement value.
			//
			Assert( 0 == qwAutoincrement );
			err = ErrIsamMove(
						(JET_SESID)pfucb->ppib,
						(JET_VTID)pfucbT,
						JET_MoveFirst,
						NO_GRBIT );
			while ( err >= 0 )
				{
				if ( !f8BytesAutoInc )
					{
					ULONG ulT;
					Call( ErrIsamRetrieveColumn(
								(JET_SESID)pfucb->ppib,
								(JET_VTID)pfucbT,
								columnidT,
								&ulT,
								sizeof(ulT),
								&cbT,
								NO_GRBIT,
								NULL ) );
					Assert( sizeof(ulT) == cbT );
					qwT = ulT;
					}
				else
					{
					Call( ErrIsamRetrieveColumn(
								(JET_SESID)pfucb->ppib,
								(JET_VTID)pfucbT,
								columnidT,
								&qwT,
								sizeof(qwT),
								&cbT,
								NO_GRBIT,
								NULL ) );
					Assert( sizeof(qwT) == cbT );
					}
				if	( qwT > qwAutoincrement )
					qwAutoincrement = qwT;
				err = ErrIsamMove(
							(JET_SESID)pfucb->ppib,
							(JET_VTID)pfucbT,
							JET_MoveNext,
							NO_GRBIT );
				}
			Assert( JET_errRecordNotFound != err );
			if ( JET_errNoCurrentRecord != err )
				goto HandleError;

			// error code will get cannibalised by SetColumn below
			}

		//	if there are no records in the table, then the first
		//	autoincrement value is 1.  Otherwise, set autoincrement
		//	to next value after maximum found.
		//
	   	qwAutoincrement++;

		//	at this point, we have a candidate ulAutoincrement for the table
		//	but we must record it in the table very carefully to avoid
		//	timing errors.
		//
		ptdbT->InitAutoincrement( qwAutoincrement );
		}

	//	set auto increment column in record
	//
	Call( ptdbT->ErrGetAndIncrAutoincrement( &qwT ) );
	Assert( qwT > 0 );

	if ( !f8BytesAutoInc )
		{
		ulT = (ULONG)qwT;
		dataT.SetPv( &ulT );
		dataT.SetCb( sizeof(ulT) );
		}
	else
		{
		dataT.SetPv( &qwT );
		dataT.SetCb( sizeof(qwT) );
		}
	
	pfcbT->EnterDML();
	err = ErrRECISetFixedColumn(
				pfucb,
				ptdbT,
				columnidT,
				&dataT );
	pfcbT->LeaveDML();

HandleError:
	if ( pfucbT != pfucbNil )
		{
		CallS( ErrFILECloseTable( pfucbT->ppib, pfucbT ) );
		}

	return err;
	}

#ifdef RTM
#else // RTM
ERR ErrRECSessionWriteConflict( FUCB *pfucb )
	{
	FUCB	*pfucbT;

	AssertDIRNoLatch( pfucb->ppib );
	for ( pfucbT = pfucb->ppib->pfucbOfSession; pfucbT != pfucbNil; pfucbT = pfucbT->pfucbNextOfSession )
		{
		//	all cursors in the list should be owned by the same session
		Assert( pfucbT->ppib == pfucb->ppib );
		
		if ( pfucbT->ifmp == pfucb->ifmp
			&& FFUCBReplacePrepared( pfucbT )
			&& PgnoFDP( pfucbT ) == PgnoFDP( pfucb )
			&& pfucbT != pfucb
			&& 0 == CmpBM( pfucbT->bmCurr, pfucb->bmCurr ) )
			{
			CHAR		szSession[32];
			CHAR		szThreadID[16];
			CHAR		szDatabaseName[JET_cbNameMost+1];
			CHAR		szTableName[JET_cbNameMost+1];
			CHAR		szConflictTableID1[32];
			CHAR		szConflictTableID2[32];
			CHAR		szBookmarkLength[32];
			CHAR		pchBookmark[JET_cbBookmarkMost];
			DWORD 		cbRawData			= 0;
			const CHAR	* rgszT[7]			= { szSession, 
												szThreadID, 
												szDatabaseName, 
												szTableName,
												szConflictTableID1, 
												szConflictTableID2, 
												szBookmarkLength };

			sprintf( szSession, "0x%p", pfucb->ppib );
			sprintf( szThreadID, "0x%08lX", DwUtilThreadId() );
			sprintf( szDatabaseName, "%s", rgfmp[pfucb->ifmp].SzDatabaseName() );
			sprintf( szTableName, "%s", pfucb->u.pfcb->Ptdb()->SzTableName() );
			sprintf( szConflictTableID1, "0x%p", pfucb );
			sprintf( szConflictTableID2, "0x%p", pfucbT );
			sprintf( szBookmarkLength, "0x%lX/0x%lX",
				pfucb->bmCurr.key.prefix.Cb(), pfucb->bmCurr.key.suffix.Cb() );

			Assert( pfucb->bmCurr.key.Cb() < sizeof( pchBookmark ) );
			Assert( pfucb->bmCurr.data.FNull() );
			pfucb->bmCurr.key.CopyIntoBuffer(pchBookmark, sizeof(pchBookmark) );
			cbRawData = pfucb->bmCurr.key.Cb();
			
			UtilReportEvent(
					eventError,
					TRANSACTION_MANAGER_CATEGORY,
					SESSION_WRITE_CONFLICT_ID,
					7,
					rgszT,
					cbRawData,
					pchBookmark );
			FireWall();
			return ErrERRCheck( JET_errSessionWriteConflict );
			}
		}

	return JET_errSuccess;
	}
#endif // RTM


ERR VTAPI ErrIsamPrepareUpdate( JET_SESID sesid, JET_VTID vtid, ULONG grbit )
	{
	ERR		err;
 	PIB *	ppib				= reinterpret_cast<PIB *>( sesid );
	FUCB *	pfucb				= reinterpret_cast<FUCB *>( vtid );
	BOOL	fFreeCopyBufOnErr	= fFalse;

	CallR( ErrPIBCheck( ppib ) );
	CheckFUCB( ppib, pfucb );
	Assert( ppib->level < levelMax );
	AssertDIRNoLatch( ppib );

	if( JET_prepReplaceNoLock == grbit
		&& pfucb->u.pfcb->Ptdb()->FTableHasSLVColumn() )
		{
		//  OLDSLV won't work if we replace-no-lock on a record while we are moving its SLV
		grbit = JET_prepReplace;
		}

	switch ( grbit )
		{
		case JET_prepCancel:
			if ( !FFUCBUpdatePrepared( pfucb ) )
				return ErrERRCheck( JET_errUpdateNotPrepared );

			if( FFUCBUpdateSeparateLV( pfucb ) )
				{
				//  rollback the operations we did while the update was prepared.
				//	on insert copy, also rollback refcount increments.
				Assert( updateidNil != pfucb->updateid );
				Assert( pfucb->ppib->level > 0 );
				err = ErrVERRollback( pfucb->ppib, pfucb->updateid );
				CallSx( err, JET_errRollbackError );
				Call ( err );
				}

			// Ensure empty LV buffer.  Don't put this check inside the
			// FFUCBUpdateSeparateLV() check above because we may have created
			// a copy buffer, but cancelled the SetColumn() (eg. write conflict)
			// before the LV was actually updated (before FUCBSetUpdateSeparateLV()
			// could be called).
			RECIFreeCopyBuffer( pfucb );
			FUCBResetUpdateFlags( pfucb );
			break;

		case JET_prepInsert:
			//	ensure that table is updatable
			//
			CallR( ErrFUCBCheckUpdatable( pfucb ) );
			CallR( ErrPIBCheckUpdatable( ppib ) );
			if ( FFUCBUpdatePrepared( pfucb ) )
				return ErrERRCheck( JET_errAlreadyPrepared );
			Assert( !FFUCBUpdatePrepared( pfucb ) );

			RECIAllocCopyBuffer( pfucb );
			fFreeCopyBufOnErr = fTrue;
			Assert( pfucb->pvWorkBuf != NULL );

			//	initialize record
			//
			Assert( pfucb != pfucbNil );
			Assert( pfucb->dataWorkBuf.Pv() != NULL );
			Assert( FFUCBIndex( pfucb ) || FFUCBSort( pfucb ) );

#ifdef PREREAD_INDEXES_ON_PREPINSERT
			if( pfucb->u.pfcb->FPreread() )
				{
				BTPrereadIndexesOfFCB( pfucb->u.pfcb );
				}
#endif	//	PREREAD_INDEXES_ON_PREPINSERT

			Assert( pfucb->u.pfcb != pfcbNil );
			pfucb->u.pfcb->EnterDML();
			
			if ( NULL == pfucb->u.pfcb->Ptdb()->PdataDefaultRecord() )
				{
				// Only temporary tables and system tables don't have default records
				// (ie. all "regular" tables have at least a minimal default record).
				Assert( ( FFUCBSort( pfucb ) && pfucb->u.pfcb->FTypeSort() )
					|| pfucb->u.pfcb->FTypeTemporaryTable()
					|| FCATSystemTable( pfucb->u.pfcb->Ptdb()->SzTableName() ) );
				pfucb->u.pfcb->LeaveDML();

				REC::SetMinimumRecord( pfucb->dataWorkBuf );
				}
			else
				{
				TDB		*ptdbT = pfucb->u.pfcb->Ptdb();
				BOOL	fBurstDefaultRecord;

				// Temp/sort tables and system tables don't have default records.
				Assert( !FFUCBSort( pfucb ) );
				Assert( !pfucb->u.pfcb->FTypeSort() );
				Assert( !pfucb->u.pfcb->FTypeTemporaryTable() );
				Assert( !FCATSystemTable( ptdbT->SzTableName() ) );

				Assert( ptdbT->PdataDefaultRecord()->Cb() >= REC::cbRecordMin );
				Assert( ptdbT->PdataDefaultRecord()->Cb() <= REC::CbRecordMax() );
				REC	*precDefault = (REC *)ptdbT->PdataDefaultRecord()->Pv();

				Assert( precDefault->FidFixedLastInRec() <= ptdbT->FidFixedLast() );
				Assert( precDefault->FidVarLastInRec() <= ptdbT->FidVarLast() );

				// May only burst default record if last fixed and
				// var columns in the default record are committed.
				// If they are versioned, there's a risk they might
				// be rolled back from underneath us.
				fBurstDefaultRecord = fTrue;
				if ( precDefault->FidFixedLastInRec() >= fidFixedLeast )
					{
					const FID	fid				= precDefault->FidFixedLastInRec();
					const BOOL	fTemplateColumn	= ptdbT->FFixedTemplateColumn( fid );
					FIELD		*pfield			= ptdbT->PfieldFixed( ColumnidOfFid( fid, fTemplateColumn ) );
					if ( FFIELDVersioned( pfield->ffield ) )
						fBurstDefaultRecord = fFalse;
					}
				if ( precDefault->FidVarLastInRec() >= fidVarLeast )
					{
					const FID	fid				= precDefault->FidVarLastInRec();
					const BOOL	fTemplateColumn	= ptdbT->FVarTemplateColumn( fid );
					FIELD		*pfield			= ptdbT->PfieldVar( ColumnidOfFid( fid, fTemplateColumn ) );
					if ( FFIELDVersioned( pfield->ffield ) )
						fBurstDefaultRecord = fFalse;
					}

				if ( fBurstDefaultRecord )
					{
					// Only burst fixed and variable column defaults.
					pfucb->dataWorkBuf.SetCb( precDefault->PbTaggedData() - (BYTE *)precDefault );
					Assert( pfucb->dataWorkBuf.Cb() >= REC::cbRecordMin );
					Assert( pfucb->dataWorkBuf.Cb() <= ptdbT->PdataDefaultRecord()->Cb() );
					UtilMemCpy( pfucb->dataWorkBuf.Pv(),
							(BYTE *)precDefault,
							pfucb->dataWorkBuf.Cb() );
					pfucb->u.pfcb->LeaveDML();
					}
				else
					{
					// Try bursting just the fixed columns.

					FID fidBurst;
					for ( fidBurst = precDefault->FidFixedLastInRec();
						fidBurst >= fidFixedLeast;
						fidBurst-- )
						{
						const BOOL	fTemplateColumn	= ptdbT->FFixedTemplateColumn( fidBurst );
						const FIELD	*pfield			= ptdbT->PfieldFixed( ColumnidOfFid( fidBurst, fTemplateColumn ) );
						if ( !FFIELDVersioned( pfield->ffield )
							&& !FFIELDDeleted( pfield->ffield ) )
							{
							break;
							}
						}
					if ( fidBurst >= fidFixedLeast )
						{
						BYTE	*pbRec	= (BYTE *)pfucb->dataWorkBuf.Pv();
						REC		*prec	= (REC *)pbRec;

						//  there is at least one non-versioned column. burst it
						Assert( fidBurst <= fidFixedMost );
						const INT	cFixedColumnsToBurst = fidBurst - fidFixedLeast + 1;
						Assert( cFixedColumnsToBurst > 0 );
						
						//  get the starting offset of the column ahead of this one
						//  add space for the column bitmap
						Assert( !ptdbT->FInitialisingDefaultRecord() );
						const INT	ibFixEnd = ptdbT->IbOffsetOfNextColumn( fidBurst );
						const INT	cbBitMap = ( cFixedColumnsToBurst + 7 ) / 8;
						const INT	cbFixedBurst = ibFixEnd + cbBitMap;
						pfucb->dataWorkBuf.SetCb( cbFixedBurst );

						Assert( pfucb->dataWorkBuf.Cb() >= REC::cbRecordMin );
						Assert( pfucb->dataWorkBuf.Cb() <= ptdbT->PdataDefaultRecord()->Cb() );

						//  copy the default record values
						UtilMemCpy( pbRec, (BYTE *)precDefault, cbFixedBurst );

						prec->SetFidFixedLastInRec( fidBurst );
						prec->SetFidVarLastInRec( fidVarLeast-1 );
						prec->SetIbEndOfFixedData( (USHORT)cbFixedBurst );

						//  set the fixed column bitmap
						BYTE	*pbDefaultBitMap	= precDefault->PbFixedNullBitMap();
						Assert( pbDefaultBitMap - (BYTE *)precDefault ==
							ptdbT->IbOffsetOfNextColumn( precDefault->FidFixedLastInRec() ) );
							
						UtilMemCpy( pbRec + ibFixEnd, pbDefaultBitMap, cbBitMap );

						//	must nullify bits for columns not in this record
						BYTE	*pbitNullity = pbRec + cbFixedBurst - 1;
						Assert( pbitNullity == pbRec + ibFixEnd + ( ( fidBurst - fidFixedLeast ) / 8 ) );
						
						for ( FID fidT = FID( fidBurst + 1 ); ; fidT++ )
							{
							const UINT	ifid = fidT - fidFixedLeast;

							if ( ( pbRec + ibFixEnd + ifid/8 ) != pbitNullity )
								{
								Assert( ( pbRec + ibFixEnd + ifid/8 ) == ( pbitNullity + 1 ) );
								break;
								}

							Assert( pbitNullity - pbRec < cbFixedBurst );
							Assert( fidT < fidBurst + 8 );
							SetFixedNullBit( pbitNullity, ifid );
							}

						pfucb->u.pfcb->LeaveDML();
						}
					else
						{
						// all fixed columns are versioned, or no fixed columns
						pfucb->u.pfcb->LeaveDML();

						// Start with an empty record.  Columns will be
						// burst on an as-needed basis.
						REC::SetMinimumRecord( pfucb->dataWorkBuf );
						}
					}
				}
				
			FUCBResetColumnSet( pfucb );

			//	if table has an autoincrement column, then set column
			//	value now so that it can be retrieved from copy buffer.
			//
			if ( pfucb->u.pfcb->Ptdb()->FidAutoincrement() != 0 )
				{
				Call( ErrRECISetAutoincrement( pfucb ) );
				}
			err = JET_errSuccess;
			PrepareInsert( pfucb );
			break;

		case JET_prepReplace:
			//	ensure that table is updatable
			//
			CallR( ErrFUCBCheckUpdatable( pfucb ) );
			CallR( ErrPIBCheckUpdatable( ppib ) );
			if ( FFUCBUpdatePrepared( pfucb ) )
				return ErrERRCheck( JET_errAlreadyPrepared );
			Assert( !FFUCBUpdatePrepared( pfucb ) );

			//	write lock node.  Note that ErrDIRGetLock also
			//	gets the current node, so no additional call to ErrDIRGet
			//	is required.
			//
			//	if locking at level 0 then goto JET_prepReplaceNoLock
			//	since lock cannot be acquired at level 0 and lock flag
			//	in fucb will prevent locking in update operation required
			//	for rollback.
			//
			if ( pfucb->ppib->level == 0 )
				{
				if( pfucb->u.pfcb->Ptdb()->FTableHasSLVColumn() )
					{
					AssertSz( fFalse, "cannot replace at level 0 with SLVs" );
					return ErrERRCheck( JET_errNotInTransaction );
					}
				goto ReplaceNoLock;
				}

			//	put assert to catch client's misbehavior. Make sure that
			//	no such sequence:
			//		PrepUpdate(t1) PrepUpdate(t2) Update(t1) Update(t2)
			//	where t1 and t2 happen to be on the same record and on the
			//	the same table. Client will experience lost update of t1 if
			//	they have such calling sequence.
			//
			Call( ErrRECSessionWriteConflict( pfucb ) );

			// Ensure we don't mistakenly set rceidBeginReplace.
			Assert( !FFUCBUpdateSeparateLV( pfucb ) );

			Call( ErrDIRGetLock( pfucb, writeLock ) );
			Call( ErrDIRGet( pfucb ) );

			if( prceNil != pfucb->ppib->prceNewest )
				pfucb->rceidBeginUpdate = pfucb->ppib->prceNewest->Rceid();
			else
				{
				Assert( rgfmp[pfucb->ifmp].FVersioningOff() );
				pfucb->rceidBeginUpdate = rceidNull;
				}

			RECIAllocCopyBuffer( pfucb );
			fFreeCopyBufOnErr = fTrue;
			Assert( pfucb->pvWorkBuf != NULL );
			pfucb->kdfCurr.data.CopyInto( pfucb->dataWorkBuf );

			Call( ErrDIRRelease( pfucb ) );
			FUCBResetColumnSet( pfucb );
			PrepareReplace( pfucb );
			break;

		case JET_prepReplaceNoLock:
			//	ensure that table is updatable
			//
			CallR( ErrFUCBCheckUpdatable( pfucb ) );
			CallR( ErrPIBCheckUpdatable( ppib ) );
			if ( FFUCBUpdatePrepared( pfucb ) )
				return ErrERRCheck( JET_errAlreadyPrepared );

ReplaceNoLock:
			Assert( !FFUCBUpdatePrepared( pfucb ) );
			
			//	put assert to catch client's misbehavior. Make sure that
			//	no such sequence:
			//		PrepUpdate(t1) PrepUpdate(t2) Update(t1) Update(t2)
			//	where t1 and t2 happen to be on the same record and on the
			//	the same table. Client will experience lost update of t1 if
			//	they have such calling sequence.
			//
			Call( ErrRECSessionWriteConflict( pfucb ) );

			Call( ErrDIRGet( pfucb ) );

			RECIAllocCopyBuffer( pfucb );
			fFreeCopyBufOnErr = fTrue;
			Assert( pfucb->pvWorkBuf != NULL );
			pfucb->kdfCurr.data.CopyInto( pfucb->dataWorkBuf );

			pfucb->rceidBeginUpdate = RCE::RceidLast();

			FUCBResetColumnSet( pfucb );

			if ( pfucb->ppib->level == 0 )
				{
				StoreChecksum( pfucb );
				}
			else
				{
				FUCBSetDeferredChecksum( pfucb );
				}

			Call( ErrDIRRelease( pfucb ) );
			PrepareReplaceNoLock( pfucb );
			break;

		case JET_prepInsertCopy:
		case JET_prepInsertCopyWithoutSLVColumns:
		case JET_prepInsertCopyDeleteOriginal:
			//	ensure that table is updatable
			//
			CallR( ErrFUCBCheckUpdatable( pfucb ) );
			CallR( ErrPIBCheckUpdatable( ppib ) );
			if ( FFUCBUpdatePrepared( pfucb ) )
				return ErrERRCheck( JET_errAlreadyPrepared );
			Assert( !FFUCBUpdatePrepared( pfucb ) );

			if( JET_prepInsertCopyDeleteOriginal == grbit )
				{
				Call( ErrDIRGetLock( pfucb, writeLock ) );
				}
			
			Call( ErrDIRGet( pfucb ) );

			RECIAllocCopyBuffer( pfucb );
			fFreeCopyBufOnErr = fTrue;
			Assert( pfucb->pvWorkBuf != NULL );
			pfucb->kdfCurr.data.CopyInto( pfucb->dataWorkBuf );
			Assert( !pfucb->dataWorkBuf.FNull() );

			Call( ErrDIRRelease( pfucb ) );
			FUCBResetColumnSet( pfucb );

			//	if table has an autoincrement column, then set column
			//	value now so that it can be retrieved from copy
			//	buffer.
			//
			if ( pfucb->u.pfcb->Ptdb()->FidAutoincrement() != 0 )
				{
				Call( ErrRECISetAutoincrement( pfucb ) );
				}
				
			if ( grbit == JET_prepInsertCopyDeleteOriginal )
				{
				PrepareInsertCopyDeleteOriginal( pfucb );
				}
			else
				{
				PrepareInsertCopy( pfucb );

				//	increment reference count on long values
				//	and remove all SLVs
				//
				Assert( updateidNil == ppib->updateid );		// should not be nested
				PIBSetUpdateid( ppib, pfucb->updateid );
				err = ErrRECAffectLongFieldsInWorkBuf( pfucb, lvaffectReferenceAll );
				if ( err >= 0 && JET_prepInsertCopyWithoutSLVColumns != grbit )
					{
					err = ErrRECCopySLVsInRecord( pfucb );
					}
				PIBSetUpdateid( ppib, updateidNil );
				if ( err < 0 )
					{
					FUCBResetUpdateFlags( pfucb );
					goto HandleError;
					}
				}
			break;

		case JET_prepReadOnlyCopy:
			if ( FFUCBUpdatePrepared( pfucb ) )
				return ErrERRCheck( JET_errAlreadyPrepared );
			Assert( !FFUCBUpdatePrepared( pfucb ) );

			if( 0 == pfucb->ppib->level )
				{
				return ErrERRCheck( JET_errNotInTransaction );
				}

				
			Call( ErrDIRGet( pfucb ) );

			RECIAllocCopyBuffer( pfucb );
			fFreeCopyBufOnErr = fTrue;
			Assert( pfucb->pvWorkBuf != NULL );
			pfucb->kdfCurr.data.CopyInto( pfucb->dataWorkBuf );
			Assert( !pfucb->dataWorkBuf.FNull() );

			Call( ErrDIRRelease( pfucb ) );
			FUCBResetColumnSet( pfucb );
			
			PrepareInsertReadOnlyCopy( pfucb );
			break;

		default:
			err = ErrERRCheck( JET_errInvalidParameter );
			goto HandleError;
		}

	CallS( err );
	AssertDIRNoLatch( ppib );
	return err;

HandleError:
	Assert( err < 0 );
	if ( fFreeCopyBufOnErr )
		{
		RECIFreeCopyBuffer( pfucb );
		}
	AssertDIRNoLatch( ppib );
	return err;
	}

	
ERR ErrRECICheckUniqueNormalizedTaggedRecordData(
	const FIELD *pfield,
	const DATA&	dataFieldNorm,
	const DATA&	dataRecRaw,
	const BOOL	fNormDataFieldTruncated )
	{
	ERR			err;
	DATA		dataRecNorm;
	BYTE		rgbRecNorm[KEY::cbKeyMax];
	BOOL		fNormDataRecTruncated;

	Assert( NULL != pfield );

	dataRecNorm.SetPv( rgbRecNorm );
	CallR( ErrFLDNormalizeTaggedData(
				pfield,
				dataRecRaw,
				dataRecNorm,
				&fNormDataRecTruncated ) );

	CallS( err );		//	shouldn't get warnings

	if ( FDataEqual( dataFieldNorm, dataRecNorm ) )
		{
		//	since data is equal, they should either both be truncated or both not truncated
		if ( fNormDataFieldTruncated || fNormDataRecTruncated )
			{
			Assert( fNormDataFieldTruncated );
			Assert( fNormDataRecTruncated );
			err = ErrERRCheck( JET_errMultiValuedDuplicateAfterTruncation );
			}
		else
			{
			Assert( !fNormDataFieldTruncated );
			Assert( !fNormDataRecTruncated );
			err = ErrERRCheck( JET_errMultiValuedDuplicate );
			}
		}

	return err;
	}


LOCAL ERR ErrRECICheckUniqueLVMultiValues(
	FUCB			* const pfucb,
	const COLUMNID	columnid,
	const ULONG		itagSequence,
	const DATA&		dataToSet,
	BYTE			* rgbLVData = NULL,
	const BOOL		fNormalizedDataToSetIsTruncated = fFalse )
	{
	ERR				err;
	FCB				* const pfcb	= pfucb->u.pfcb;
	const BOOL		fNormalize		= ( NULL != rgbLVData );
	DATA			dataRetrieved;
	ULONG			itagSequenceT	= 0;

	Assert( FCOLUMNIDTagged( columnid ) );
	Assert( pfcbNil != pfcb );
	Assert( ptdbNil != pfcb->Ptdb() );

#ifdef DEBUG
	pfcb->EnterDML();
	Assert( FRECLongValue( pfcb->Ptdb()->PfieldTagged( columnid )->coltyp ) );
	pfcb->LeaveDML();
#endif

	forever
		{
		itagSequenceT++;
		if ( itagSequenceT != itagSequence )
			{
			CallR( ErrRECIRetrieveTaggedColumn(
					pfcb,
					columnid,
					itagSequenceT,
					pfucb->dataWorkBuf,
					&dataRetrieved,
					JET_bitRetrieveIgnoreDefault | grbitRetrieveColumnDDLNotLocked ) );

			if ( wrnRECSeparatedLV == err )
				{
				if ( fNormalize )
					{
					ULONG	cbActual;
					CallR( ErrRECRetrieveSLongField(
								pfucb,
								LidOfSeparatedLV( dataRetrieved ),
								fTrue,
								0,
								rgbLVData,
								KEY::cbKeyMax,
								&cbActual ) );
					dataRetrieved.SetPv( rgbLVData );
					dataRetrieved.SetCb( min( cbActual, KEY::cbKeyMax ) );

					pfcb->EnterDML();
					err = ErrRECICheckUniqueNormalizedTaggedRecordData(
									pfcb->Ptdb()->PfieldTagged( columnid ),
									dataToSet,
									dataRetrieved,
									fNormalizedDataToSetIsTruncated );
					pfcb->LeaveDML();
					CallR( err );
					}
				else
					{
					CallR( ErrRECRetrieveSLongField(
								pfucb,
								LidOfSeparatedLV( dataRetrieved ),
								fTrue,
								0,
								(BYTE *)dataToSet.Pv(),
								dataToSet.Cb(),
								NULL ) );				//	pass NULL to force comparison instead of retrieval
					}
				}
			else if ( wrnRECIntrinsicLV == err )
				{
				if ( fNormalize )
					{
					pfcb->EnterDML();
					err = ErrRECICheckUniqueNormalizedTaggedRecordData(
									pfcb->Ptdb()->PfieldTagged( columnid ),
									dataToSet,
									dataRetrieved,
									fNormalizedDataToSetIsTruncated );
					pfcb->LeaveDML();
					CallR( err );
					}
				else if ( FDataEqual( dataToSet, dataRetrieved ) )
					{
					return ErrERRCheck( JET_errMultiValuedDuplicate );
					}
				}
			else
				{
				Assert( JET_wrnColumnNull == err
					|| ( wrnRECUserDefinedDefault == err && 1 == itagSequenceT ) );
				break;
				}
			}
		}

	return JET_errSuccess;
	}

LOCAL ERR ErrRECICheckUniqueNormalizedLVMultiValues(
	FUCB			* const pfucb,
	const COLUMNID	columnid,
	const ULONG		itagSequence,
	const DATA&		dataToSet )
	{
	ERR				err;
	FCB				* const pfcb				= pfucb->u.pfcb;
	DATA			dataToSetNorm;
	BYTE			rgbDataToSetNorm[KEY::cbKeyMax];
	BYTE			rgbLVData[KEY::cbKeyMax];
	BOOL			fNormalizedDataToSetIsTruncated;

	Assert( FCOLUMNIDTagged( columnid ) );
	Assert( pfcbNil != pfcb );
	Assert( ptdbNil != pfcb->Ptdb() );

	dataToSetNorm.SetPv( rgbDataToSetNorm );

	pfcb->EnterDML();
	Assert( FRECLongValue( pfcb->Ptdb()->PfieldTagged( columnid )->coltyp ) );
	err = ErrFLDNormalizeTaggedData(
				pfcb->Ptdb()->PfieldTagged( columnid ),
				dataToSet,
				dataToSetNorm,
				&fNormalizedDataToSetIsTruncated );
	pfcb->LeaveDML();

	CallR( err );

	return ErrRECICheckUniqueLVMultiValues(
				pfucb,
				columnid,
				itagSequence,
				dataToSetNorm,
				rgbLVData,
				fNormalizedDataToSetIsTruncated );
	}


LOCAL ERR ErrFLDSetOneColumn(
	FUCB 		*pfucb,
	COLUMNID	columnid,
	DATA		*pdataField,
	ULONG		itagSequence,
	ULONG		ibLongValue,
	ULONG		grbit )
	{
	ERR			err;
	FCB			*pfcb						= pfucb->u.pfcb;
	BOOL		fEnforceUniqueMultiValues	= fFalse;

	if ( grbit & ( JET_bitSetUniqueMultiValues|JET_bitSetUniqueNormalizedMultiValues) )
		{
		if ( grbit & ( JET_bitSetAppendLV|JET_bitSetOverwriteLV|JET_bitSetSizeLV ) )
			{
			//	cannot currently combine JET_bitSetUniqueMultiValues with other grbits
			err = ErrERRCheck( JET_errInvalidGrbit );
			return err;
			}
		else if ( NULL == pdataField->Pv() || 0 == pdataField->Cb() )
			{
			if ( grbit & JET_bitSetZeroLength )
				fEnforceUniqueMultiValues = fTrue;
			}
		else
			{
			fEnforceUniqueMultiValues = fTrue;
			}
		}

	if ( ( grbit & grbitSetColumnInternalFlagsMask )
		|| ( grbit & JET_bitSetSLVFromSLVInfo ) )		// JET_bitSetSLVFromSLVInfo is for internal use only

		{
		err = ErrERRCheck( JET_errInvalidGrbit );
		return err;
		}
		
	Assert( !(grbit & JET_bitSetSLVFromSLVInfo) );

		// Verify column is visible to us.
	CallR( ErrRECIAccessColumn( pfucb, columnid ) );

	// If pv is NULL, cb should be 0, except if SetSizeLV is specified.
	if ( pdataField->Pv() == NULL && !( grbit & JET_bitSetSizeLV ) )
		pdataField->SetCb( 0 );

	//	Return error if version or autoinc column is being set.  We don't
	//	need to grab the FCB critical section -- since we can see the
	//	column, we're guaranteed the FID won't be deleted or rolled back.
	if ( FCOLUMNIDFixed( columnid ) )
		{
#ifdef DEBUG
		FIELDFLAG	ffield;

		pfcb->EnterDML();
		ffield = pfcb->Ptdb()->PfieldFixed( columnid )->ffield;
		pfcb->LeaveDML();

		Assert( !( FFIELDVersion( ffield ) && FFIELDAutoincrement( ffield ) ) );
#endif

		if ( pfcb->Ptdb()->FidVersion() == FidOfColumnid( columnid ) )
			{
			Assert( pfcb->Ptdb()->FidAutoincrement() != FidOfColumnid( columnid ) );	// Assert mutual-exclusivity.
			Assert( FFIELDVersion( ffield ) );

			// Cannot set a Version field during a replace.
			if ( FFUCBReplacePrepared( pfucb ) )
				return ErrERRCheck( JET_errInvalidColumnType );
			}
		else if ( pfcb->Ptdb()->FidAutoincrement() == FidOfColumnid( columnid ) )
			{
			Assert( FFIELDAutoincrement( ffield ) );

			// Can never set an AutoInc field.
			return ErrERRCheck( JET_errInvalidColumnType );
			}
		}

	else if ( FCOLUMNIDTagged( columnid ) )		// check for long value
		{
		pfcb->EnterDML();
		
		const FIELD	*pfield				= pfcb->Ptdb()->PfieldTagged( columnid );
		const BOOL	fLongValue			= FRECLongValue( pfield->coltyp );
		const BOOL	fSLV				= FRECSLV( pfield->coltyp );
		const ULONG	cbMaxLen			= pfield->cbMaxLen;

		pfcb->LeaveDML();
		
		if ( fSLV )
			{
			//	UniqueMultiValues check over SLV columns is currently not supported
			//	in RETAIL, ErrSLVSetColumn() will err out with JET_errInvalidGrbit
			Assert( !fEnforceUniqueMultiValues );

			//  set the SLV column

			err = ErrSLVSetColumn(	pfucb,
									columnid,
									itagSequence,
									ibLongValue,
									grbit,
									pdataField );

			//  we're done
			
			goto HandleError;
			}
			
		if ( fLongValue )
			{
			if ( FFUCBInsertCopyDeleteOriginalPrepared( pfucb ) )
				{
				//	UNDONE:	cannot currently update LV's in an
				//	InsertCopyDeleteOriginal because of LV visibility
				//	problems (similar to Replace - we would need
				//	an rceidBeginUpdate in the RCE of the insert
				//	so that concurrent create index would be
				//	able to find the proper LV before-image)
				AssertSz( fFalse, "Illegal attempt to update a Long Value column in an InsertCopyDeleteOriginal update." );
				Call( ErrERRCheck( JET_errColumnNotUpdatable ) );
				}

			if ( fEnforceUniqueMultiValues )
				{
				if ( grbit & JET_bitSetUniqueNormalizedMultiValues )
					{
					Call( ErrRECICheckUniqueNormalizedLVMultiValues(
								pfucb,
								columnid,
								itagSequence,
								*pdataField ) );
					}
				else
					{
					Call( ErrRECICheckUniqueLVMultiValues(
								pfucb,
								columnid,
								itagSequence,
								*pdataField ) );
					}
				}


			err = ErrRECSetLongField(
				pfucb,
				columnid,
				itagSequence,
				pdataField,
				grbit,
				ibLongValue,
				cbMaxLen );

			//	if column does not fit then try to separate long values
			//	and try to set column again.
			//
			if ( JET_errRecordTooBig == err )
				{
				Call( ErrRECAffectLongFieldsInWorkBuf( pfucb, lvaffectSeparateAll ) );
				err = ErrRECSetLongField(
					pfucb,
					columnid,
					itagSequence,
					pdataField,
					grbit,
					ibLongValue,
					cbMaxLen );
				}

			goto HandleError;
			}
		}


	//	do the actual column operation
	//

	//	setting value to NULL
	//
	if ( pdataField->Cb() == 0 && !( grbit & JET_bitSetZeroLength ) )
		pdataField = NULL;

	Assert( !( grbit & grbitSetColumnInternalFlagsMask ) );

	err = ErrRECSetColumn( pfucb, columnid, itagSequence, pdataField, grbit );
	if ( err == JET_errRecordTooBig )
		{
		Call( ErrRECAffectLongFieldsInWorkBuf( pfucb, lvaffectSeparateAll ) );
		err = ErrRECSetColumn( pfucb, columnid, itagSequence, pdataField, grbit );
		}

HandleError:
	AssertDIRNoLatch( pfucb->ppib );
	return err;
	}



//+API
//	ErrIsamSetColumn
//	========================================================================
//	ErrIsamSetColumn( PIB *ppib, FUCB *pfucb, FID fid, ULONG itagSequence, DATA *pdataField, JET_GRBIT grbit )
//
//	Adds or changes a column value in the record being worked on.
//	Fixed and variable columns are replaced if they already have values.
//	A sequence number must be given for tagged columns.  If this is zero,
//	a new tagged column occurance is added to the record.  If not zero, it
//	specifies the occurance to change.
//	A working buffer is allocated if there isn't one already.
//	If fNewBuf == fTrue, the buffer is initialized with the default values
//	for the columns in the record.  If fNewBuf == fFalse, and there was
//	already a working buffer, it is left unaffected;	 if a working buffer
//	had to be allocated, then this new working buffer will be initialized
//	with either the column values of the current record, or the default column
//	values (if the user's currency is not on a record).
//
//	PARAMETERS	ppib			PIB of user
//				pfucb			FUCB of data file to which this record
//								is being added/updated.
//				fid				column id: which column to set
//				itagSequence 	Occurance number (for tagged columns):
//								which occurance of the column to change
//								If zero, it means "add a new occurance"
//				pdataField		column data to use
//				grbit 			If JET_bitSetZeroLength, the column is set to size 0.
//
//	RETURNS		Error code, one of:
//					 JET_errSuccess				Everything worked.
//					-JET_errOutOfBuffers		Failed to allocate a working
//												buffer
//					-JET_errInvalidBufferSize
//
//					-ColumnInvalid				The column id given does not
//												corresponding to a defined column
//					-NullInvalid			  	An attempt was made to set a
//												column to NULL which is defined
//												as NotNull.
//					-JET_errRecordTooBig		There is not enough room in
//												the record for new column.
//	COMMENTS 	The GET and DELETE commands discard the working buffer
//				without writing it to the database.	 The REPLACE and INSERT
//				commands may be used to write the working buffer to the
//				database, but they also discard it when finished (the INSERT
//				command can be told not to discard it, though;	this is
//				useful for adding several similar records).
//				For tagged columns, if the data given is NULL-valued, then the
//				tagged column occurance specified is deleted from the record.
//				If there is no tagged column occurance corresponding to the
//				specified occurance number, a new tagged column is added to
//				the record, and assumes the new highest occurance number
//				(unless the data given is NULL-valued, in which case the
//				record is unaffected).
//-
ERR VTAPI ErrIsamSetColumn(
	JET_SESID		sesid,
	JET_VTID		vtid,
	JET_COLUMNID	columnid,
	const VOID*		pvData,
	const ULONG 	cbData,
	ULONG	  		grbit,
	JET_SETINFO*	psetinfo )
	{
	ERR				err;
 	PIB*			ppib		= reinterpret_cast<PIB *>( sesid );
	FUCB*			pfucb		= reinterpret_cast<FUCB *>( vtid );
	DATA	  		dataField;
	ULONG	  		itagSequence;
	ULONG			ibLongValue;

	// check for updatable table
	//
	CallR( ErrFUCBCheckUpdatable( pfucb ) );
	CallR( ErrPIBCheckUpdatable( ppib ) );

	CallR( ErrPIBCheck( ppib ) );
	CheckFUCB( ppib, pfucb );
	AssertDIRNoLatch( ppib );

	if ( !FFUCBSetPrepared( pfucb ) )
		return ErrERRCheck( JET_errUpdateNotPrepared );

	//  remember which update we are part of (save off session's current
	//	updateid because we may be nested if the top-level SetColumn()
	//	causes catalog updates when creating LV tree).
	const UPDATEID	updateidSave	= ppib->updateid;
	PIBSetUpdateid( ppib, pfucb->updateid );

	if ( psetinfo != NULL )
		{
		if ( psetinfo->cbStruct < sizeof(JET_SETINFO) )
			{
			err = ErrERRCheck( JET_errInvalidParameter );
			goto HandleError;
			}
		itagSequence = psetinfo->itagSequence;
		ibLongValue = psetinfo->ibLongValue;
		}
	else
		{
		itagSequence = 1;
		ibLongValue = 0;
		}

	dataField.SetPv( (VOID *)pvData );
	dataField.SetCb( cbData );

	err = ErrFLDSetOneColumn(
				pfucb,
				columnid,
				&dataField,
				itagSequence,
				ibLongValue,
				grbit );

HandleError:
	PIBSetUpdateid( ppib, updateidSave );
	AssertDIRNoLatch( ppib );
	return err;
	}


ERR VTAPI ErrIsamSetColumns(
	JET_SESID		vsesid,
	JET_VTID		vtid,
	JET_SETCOLUMN	*psetcols,
	unsigned long	csetcols )
	{
	ERR	 			err;
	PIB				*ppib = (PIB *)vsesid;
	FUCB			*pfucb = (FUCB *)vtid;
	ULONG			ccols;
	DATA			dataField;
	JET_SETCOLUMN	*psetcolcurr;

	// check for updatable table
	//
	CallR( ErrFUCBCheckUpdatable( pfucb ) );
	CallR( ErrPIBCheckUpdatable( ppib ) );

	CallR( ErrPIBCheck( ppib ) );
	AssertDIRNoLatch( ppib );
	CheckFUCB( ppib, pfucb );

	if ( !FFUCBSetPrepared( pfucb ) )
		return ErrERRCheck( JET_errUpdateNotPrepared );

	//  remember which update we are part of (save off session's current
	//	updateid because we may be nested if the top-level SetColumn()
	//	causes catalog updates when creating LV tree).
	const UPDATEID	updateidSave	= ppib->updateid;
	PIBSetUpdateid( ppib, pfucb->updateid );

	for ( ccols = 0; ccols < csetcols ; ccols++ )
		{
		psetcolcurr = psetcols + ccols;

		dataField.SetPv( (VOID *)psetcolcurr->pvData );
		dataField.SetCb( psetcolcurr->cbData );

		Call( ErrFLDSetOneColumn(
			pfucb,
			psetcolcurr->columnid,
			&dataField,
			psetcolcurr->itagSequence,
			psetcolcurr->ibLongValue,
			psetcolcurr->grbit ) );
		psetcolcurr->err = err;
		}

HandleError:
	PIBSetUpdateid( ppib, updateidSave );

	AssertDIRNoLatch( ppib );
	return err;
	}


ERR ErrRECSetDefaultValue( FUCB *pfucbFake, const COLUMNID columnid, VOID *pvDefault, ULONG cbDefault )
	{
	ERR		err;
	DATA	dataField;
	TDB		*ptdb		= pfucbFake->u.pfcb->Ptdb();

	Assert( pfucbFake->u.pfcb->FTypeTable() );
	Assert( pfucbFake->u.pfcb->FFixedDDL() );

	dataField.SetPv( pvDefault );
	dataField.SetCb( cbDefault );

	if ( FRECLongValue( ptdb->Pfield( columnid )->coltyp ) )
		{
		Assert( FCOLUMNIDTagged( columnid ) );
		Assert( FidOfColumnid( columnid ) <= ptdb->FidTaggedLast() );

		//	max. default long value is cbLVIntrinsicMost-1 (one byte
		//	reserved for fSeparated flag).
		Assert( JET_cbLVDefaultValueMost < cbLVIntrinsicMost );

		if ( cbDefault > JET_cbLVDefaultValueMost )
			{
			err = ErrERRCheck( JET_errDefaultValueTooBig );
			}
		else
			{
			DATA dataNullT;
			dataNullT.Nullify();

#ifdef INTRINSIC_LV
			BYTE rgb[JET_cbLVDefaultValueMost];
			err = ErrRECAOIntrinsicLV(
						pfucbFake,
						columnid,
						NO_ITAG,		// itagSequence == 0 to force new column
						&dataNullT,
						&dataField,
						0,
						lvopInsert,
						rgb );
#else // INTRINSIC_LV
			err = ErrRECAOIntrinsicLV(
						pfucbFake,
						columnid,
						NO_ITAG,		// itagSequence == 0 to force new column
						&dataNullT,
						&dataField,
						0,
						lvopInsert );
#endif // INTRINSIC_LV						
			}
		}
	else
		{
		err = ErrRECSetColumn( pfucbFake, columnid, NO_ITAG, &dataField );
		if ( JET_errColumnTooBig == err )
			{
			err = ErrERRCheck( JET_errDefaultValueTooBig );
			}
		}

	return err;
	}


ERR ErrRECISetFixedColumn(
	FUCB			* const pfucb,
	TDB				* const ptdb,
	const COLUMNID	columnid,
	DATA			*pdataField )
	{
	const FID		fid			= FidOfColumnid( columnid );

	Assert( FFixedFid( fid ) );
	
	Assert( pfucbNil != pfucb );
	Assert( FFUCBIndex( pfucb ) || FFUCBSort( pfucb ) );
	
	INT			cbRec = pfucb->dataWorkBuf.Cb();
	Assert( cbRec >= REC::cbRecordMin );
	Assert( cbRec <= REC::CbRecordMax() );

	BYTE		*pbRec = (BYTE *)pfucb->dataWorkBuf.Pv();
	REC			*prec = (REC *)pbRec;
	Assert( precNil != prec );

	if ( fid > ptdb->FidFixedLast() )
		return ErrERRCheck( JET_errColumnNotFound );

	FIELD		*pfield = ptdb->PfieldFixed( columnid );
	Assert( pfieldNil != pfield );
	if ( JET_coltypNil == pfield->coltyp )
		return ErrERRCheck( JET_errColumnNotFound );

	//	record the fact that this column has been changed
	//
	FUCBSetColumnSet( pfucb, fid );

	//	column not represented in record? Make room, make room
	//
	if ( fid > prec->FidFixedLastInRec() )
		{
		const FID	fidFixedLastInRec = prec->FidFixedLastInRec();
		FID			fidT;
		FID			fidLastDefault;
		
		if ( ( NULL == pdataField || pdataField->FNull() )
			&& FFIELDNotNull( pfield->ffield ) )
			{
			return ErrERRCheck( JET_errNullInvalid );
			}

		// Verify there's at least one more fid beyond fidFixedLastInRec,
		// thus enabling us to reference the FIELD structure of the fid
		// beyond fidFixedLastInRec.
		Assert( fidFixedLastInRec < ptdb->FidFixedLast() );

		//	compute room needed for new column and bitmap
		//
		const WORD	ibOldFixEnd		= WORD( prec->PbFixedNullBitMap() - pbRec );
		const WORD	ibOldBitMapEnd	= prec->IbEndOfFixedData();
		const INT	cbOldBitMap		= ibOldBitMapEnd - ibOldFixEnd;
		Assert( ibOldBitMapEnd >= ibOldFixEnd );
		Assert(	ibOldFixEnd == ptdb->IbOffsetOfNextColumn( fidFixedLastInRec ) );
		Assert( ibOldBitMapEnd == ibOldFixEnd + cbOldBitMap );
		Assert( cbOldBitMap == prec->CbFixedNullBitMap() );

		const WORD	ibNewFixEnd		= WORD( pfield->ibRecordOffset + pfield->cbMaxLen );
		const INT	cbNewBitMap		= ( ( fid - fidFixedLeast + 1 ) + 7 ) / 8;
		const WORD	ibNewBitMapEnd	= WORD( ibNewFixEnd + cbNewBitMap );
		const INT	cbShift			= ibNewBitMapEnd - ibOldBitMapEnd;
		Assert( ibNewFixEnd == ptdb->IbOffsetOfNextColumn( fid ) );
		Assert( ibNewFixEnd > ibOldFixEnd );
		Assert( cbNewBitMap >= cbOldBitMap );
		Assert( ibNewBitMapEnd > ibOldBitMapEnd );
		Assert( cbShift > 0 );

		if ( cbRec + cbShift > cbRECRecordMost )
			return ErrERRCheck( JET_errRecordTooBig );

		//	shift rest of record over to make room
		//
		Assert( cbRec >= ibOldBitMapEnd );
		memmove(
			pbRec + ibNewBitMapEnd,
			pbRec + ibOldBitMapEnd,
			cbRec - ibOldBitMapEnd );

#ifdef DEBUG
		memset( pbRec + ibOldBitMapEnd, chRECFill, cbShift );
#endif

		pfucb->dataWorkBuf.DeltaCb( cbShift );
		cbRec = pfucb->dataWorkBuf.Cb();

		// set new location of variable/tagged data
		prec->SetIbEndOfFixedData( ibNewBitMapEnd );
		
		//	shift fixed column bitmap over
		//
		memmove(
			pbRec + ibNewFixEnd,
			pbRec + ibOldFixEnd,
			cbOldBitMap );

#ifdef DEBUG
		memset( pbRec + ibOldFixEnd, chRECFill, ibNewFixEnd - ibOldFixEnd );
#endif

		//	clear all new bitmap bits
		//

		// If there's at least one fixed column currently in the record,
		// find the nullity bit for the last fixed column and clear the
		// rest of the bits in that byte.
		BYTE	*prgbitNullity;
		if ( fidFixedLastInRec >= fidFixedLeast )
			{
			UINT	ifid	= fidFixedLastInRec - fidFixedLeast;	// Fid converted to an index.

			prgbitNullity = pbRec + ibNewFixEnd + ifid/8;
			
			for ( fidT = FID( fidFixedLastInRec + 1 ); fidT <= fid; fidT++ )
				{
				ifid = fidT - fidFixedLeast;
				if ( ( pbRec + ibNewFixEnd + ifid/8 ) != prgbitNullity )
					{
					Assert( ( pbRec + ibNewFixEnd + ifid/8 ) == ( prgbitNullity + 1 ) );
					break;
					}
				SetFixedNullBit( prgbitNullity, ifid );
				}

			prgbitNullity++;		// Advance to next nullity byte.
			Assert( prgbitNullity <= pbRec + ibNewBitMapEnd );
			}
		else
			{
			prgbitNullity = pbRec + ibNewFixEnd;
			Assert( prgbitNullity < pbRec + ibNewBitMapEnd );
			}

		// set all NULL bits at once
		memset( prgbitNullity, 0xff, pbRec + ibNewBitMapEnd - prgbitNullity );


		// Default values may have to be burst if there are default value columns
		// between the last one currently in the record and the one we are setting.
		// (note that if the column being set also has a default value, we have
		// to set the default value first in case the actual set fails.
		const REC * const	precDefault = ( NULL != ptdb->PdataDefaultRecord() ?
													(REC *)ptdb->PdataDefaultRecord()->Pv() :
													NULL );
		Assert( NULL == precDefault		// temp/system tables have no default record.
			|| ptdb->PdataDefaultRecord()->Cb() >= REC::cbRecordMin );

		fidLastDefault = ( NULL != precDefault ?
								precDefault->FidFixedLastInRec() :
								FID( fidFixedLeast - 1 ) );
		Assert( fidLastDefault >= fidFixedLeast-1 );
		Assert( fidLastDefault <= ptdb->FidFixedLast() );

		if ( fidLastDefault > fidFixedLastInRec )
			{
			Assert( !ptdb->FInitialisingDefaultRecord() );
			Assert( fidFixedLastInRec < fid );
			for ( fidT = FID( fidFixedLastInRec + 1 ); fidT <= fid; fidT++ )
				{
				const BOOL	fTemplateColumn	= ptdb->FFixedTemplateColumn( fidT );
				const FIELD	*pfieldFixed 	= ptdb->PfieldFixed( ColumnidOfFid( fidT, fTemplateColumn ) );

				Assert( fidT <= ptdb->FidFixedLast() );

				if ( FFIELDDefault( pfieldFixed->ffield )
					&& !FFIELDCommittedDelete( pfieldFixed->ffield ) )
					{
					UINT	ifid	= fidT - fidFixedLeast;

					Assert( pfieldFixed->coltyp != JET_coltypNil );

					// Update nullity bit.  Assert that it's currently
					// set to null, then set it to non-null in preparation
					// of the bursting of the default value.
					prgbitNullity = pbRec + ibNewFixEnd + (ifid/8);
					Assert( FFixedNullBit( prgbitNullity, ifid ) );
					ResetFixedNullBit( prgbitNullity, ifid );
					fidLastDefault = fidT;
					}
				}

			// Only burst default values between the last fixed
			// column currently in the record and the column now
			// being set.
			Assert( fidLastDefault > fidFixedLastInRec );
			if ( fidLastDefault <= fid )
				{
				WORD	ibLastDefault = ptdb->IbOffsetOfNextColumn( fidLastDefault );
				Assert( ibLastDefault > ibOldFixEnd );
				UtilMemCpy(
					pbRec + ibOldFixEnd,
					(BYTE *)precDefault + ibOldFixEnd,
					ibLastDefault - ibOldFixEnd );
				}
			}

		//	increase fidFixedLastInRec
		//
		prec->SetFidFixedLastInRec( fid );
		}

	//	fid is now definitely represented in
	//	the record; its data can simply be replaced
	//

	//	adjust fid to an index
	//
	const UINT	ifid			= fid - fidFixedLeast;

	//	byte containing bit representing column's nullity
	//
	BYTE		*prgbitNullity	= prec->PbFixedNullBitMap() + ifid/8;

	//	adding NULL: clear bit (or maybe error)
	//
	if ( NULL == pdataField || pdataField->FNull() )
		{
		if ( FFIELDNotNull( pfield->ffield ) )
			return ErrERRCheck( JET_errNullInvalid );
		SetFixedNullBit( prgbitNullity, ifid );
		}

	else
		{
		//	adding non-NULL value: set bit, copy value into slot
		//
		const JET_COLTYP	coltyp = pfield->coltyp;
		ULONG				cbCopy = pfield->cbMaxLen;

		Assert( pfield->cbMaxLen == UlCATColumnSize( coltyp, cbCopy, NULL ) );

		if ( pdataField->Cb() != cbCopy )
			{
			switch ( coltyp )
				{
				case JET_coltypBit:
				case JET_coltypUnsignedByte:
				case JET_coltypShort:
				case JET_coltypLong:
				case JET_coltypCurrency:
				case JET_coltypIEEESingle:
				case JET_coltypIEEEDouble:
				case JET_coltypDateTime:
					return ErrERRCheck( JET_errInvalidBufferSize );

				case JET_coltypBinary:
					if ( pdataField->Cb() > cbCopy )
						return ErrERRCheck( JET_errInvalidBufferSize );
					else
						{
						memset(
							pbRec + pfield->ibRecordOffset + pdataField->Cb(),
							0,
							cbCopy - pdataField->Cb() );
						}
					cbCopy = pdataField->Cb();
					break;

				default:
					Assert( JET_coltypText == coltyp );
					if ( pdataField->Cb() > cbCopy )
						return ErrERRCheck( JET_errInvalidBufferSize );
					else
						{
						memset(
							pbRec + pfield->ibRecordOffset + pdataField->Cb(),
							' ',
							cbCopy - pdataField->Cb() );
						}
					cbCopy = pdataField->Cb();
					break;
				}
			}

		ResetFixedNullBit( prgbitNullity, ifid );

		if ( JET_coltypBit == coltyp )
			{
			if ( *( (BYTE *)pdataField->Pv() ) == 0 )
				*( pbRec + pfield->ibRecordOffset ) = 0x00;
			else
				*( pbRec + pfield->ibRecordOffset ) = 0xFF;
			}
		else
			{
			BYTE	rgb[8];
			BYTE	*pbDataField;
			
			SetPbDataField( &pbDataField, pdataField, rgb, coltyp );
			
			//	If the data is converted, then the cbCopy must be the same as pdataField->Cb()
			Assert( pbDataField != pdataField->Pv() || cbCopy == pdataField->Cb() );
	
			UtilMemCpy( pbRec + pfield->ibRecordOffset, pbDataField, cbCopy );
			}
		}

	Assert( pfucb->dataWorkBuf.Cb() <= REC::CbRecordMax() );
	return JET_errSuccess;
	}
	

INLINE ULONG CbBurstVarDefaults( TDB *ptdb, FID fidVarLastInRec, FID fidSet, FID *pfidLastDefault )
	{
	ULONG				cbBurstDefaults		= 0;
	const REC * const	precDefault			= ( NULL != ptdb->PdataDefaultRecord() ?
														(REC *)ptdb->PdataDefaultRecord()->Pv() :
														NULL );

	// Compute space needed to burst default values.
	// Default values may have to be burst if there are default value columns
	// between the last one currently in the record and the one we are setting.
	// (note that if the column being set also has a default value, we don't
	// bother setting it, since it will be overwritten).
	Assert( NULL == precDefault		// temp/system tables have no default record.
		|| ptdb->PdataDefaultRecord()->Cb() >= REC::cbRecordMin );

	*pfidLastDefault = ( NULL != precDefault ?
							precDefault->FidVarLastInRec() :
							FID( fidVarLeast - 1 ) );
	Assert( *pfidLastDefault >= fidVarLeast-1 );
	Assert( *pfidLastDefault <= ptdb->FidVarLast() );

	if ( *pfidLastDefault > fidVarLastInRec )
		{
		Assert( ptdb->PdataDefaultRecord()->Cb() >= REC::cbRecordMin );
		Assert( fidVarLastInRec < fidSet );
		Assert( fidSet <= ptdb->FidVarLast() );

		const UnalignedLittleEndian<REC::VAROFFSET>	*pibDefaultVarOffs = precDefault->PibVarOffsets();

		for ( FID fidT = FID( fidVarLastInRec + 1 ); fidT < fidSet; fidT++ )
			{
			const BOOL	fTemplateColumn	= ptdb->FVarTemplateColumn( fidT );
			const FIELD	*pfieldVar		= ptdb->PfieldVar( ColumnidOfFid( fidT, fTemplateColumn ) );
			if ( FFIELDDefault( pfieldVar->ffield )
				&& !FFIELDCommittedDelete( pfieldVar->ffield ) )
				{
				const UINT	ifid = fidT - fidVarLeast;
				Assert( pfieldVar->coltyp != JET_coltypNil );

				// Don't currently support NULL default values.
				Assert( !FVarNullBit( pibDefaultVarOffs[ifid] ) );
				
				//	beginning of current column is end of previous column
				const WORD	ibVarOffset = ( fidVarLeast == fidT ?
												(WORD)0 :
												IbVarOffset( pibDefaultVarOffs[ifid-1] ) );

				Assert( IbVarOffset( pibDefaultVarOffs[ifid] ) > ibVarOffset );
				Assert( precDefault->PbVarData() + IbVarOffset( pibDefaultVarOffs[ifid] )
							<= (BYTE *)ptdb->PdataDefaultRecord()->Pv() + ptdb->PdataDefaultRecord()->Cb() );

				cbBurstDefaults += ( IbVarOffset( pibDefaultVarOffs[ifid] ) - ibVarOffset );
				Assert( cbBurstDefaults > 0 );

				*pfidLastDefault = fidT;
				}
			}
		}

	Assert( cbBurstDefaults == 0  ||
		( *pfidLastDefault > fidVarLastInRec && *pfidLastDefault < fidSet ) );

	return cbBurstDefaults;
	}


ERR ErrRECISetVarColumn(
	FUCB			* const pfucb,
	TDB				* const ptdb,
	const COLUMNID	columnid,
	DATA			*pdataField )
	{
	ERR				err				= JET_errSuccess;
	const FID		fid				= FidOfColumnid( columnid );
	
	Assert( FVarFid( fid ) );
	
	Assert( pfucbNil != pfucb );
	Assert( FFUCBIndex( pfucb ) || FFUCBSort( pfucb ) );
	
	INT			cbRec = pfucb->dataWorkBuf.Cb();
	Assert( cbRec >= REC::cbRecordMin );
	Assert( cbRec <= REC::CbRecordMax() );

	BYTE		*pbRec = (BYTE *)pfucb->dataWorkBuf.Pv();
	REC			*prec = (REC *)pbRec;
	Assert( precNil != prec );

	if ( fid > ptdb->FidVarLast() )
		return ErrERRCheck( JET_errColumnNotFound );

	FIELD		*pfield = ptdb->PfieldVar( columnid );
	Assert( pfieldNil != pfield );
	if ( JET_coltypNil == pfield->coltyp )
		return ErrERRCheck( JET_errColumnNotFound );

	//	record the fact that this column has been changed
	//
	FUCBSetColumnSet( pfucb, fid );


	//	NULL-value check
	//
	INT		cbCopy;				// Number of bytes to copy from user's buffer
	if ( NULL == pdataField )
		{
		if ( FFIELDNotNull( pfield->ffield ) )
			return ErrERRCheck( JET_errNullInvalid );
		else
			cbCopy = 0;
		}
	else if ( NULL == pdataField->Pv() )
		{
		cbCopy = 0;
		}
	else if ( pdataField->Cb() > pfield->cbMaxLen )
		{
		//	column too long
		//
		cbCopy = pfield->cbMaxLen;
		err = ErrERRCheck( JET_wrnColumnMaxTruncated );
		}
	else
		{
		cbCopy = pdataField->Cb();
		}
	Assert( cbCopy >= 0 );

	//	variable column offsets
	//
	UnalignedLittleEndian<REC::VAROFFSET>	*pib;
	UnalignedLittleEndian<REC::VAROFFSET>	*pibLast;
	UnalignedLittleEndian<REC::VAROFFSET>	*pibVarOffs;
	
	//	column not represented in record?  Make room, make room
	//
	const BOOL		fBurstRecord = ( fid > prec->FidVarLastInRec() );
	if ( fBurstRecord )
		{
		const FID	fidVarLastInRec = prec->FidVarLastInRec();
		FID			fidLastDefault;

		Assert( !( pdataField == NULL && FFIELDNotNull( pfield->ffield ) ) );

		//	compute space needed for new var column offsets
		//
		const INT	cbNeed = ( fid - fidVarLastInRec ) * sizeof(REC::VAROFFSET);
		const INT	cbBurstDefaults = CbBurstVarDefaults(
											ptdb,
											fidVarLastInRec,
											fid,
											&fidLastDefault );
											
		if ( cbRec + cbNeed + cbBurstDefaults + cbCopy > cbRECRecordMost )
			return ErrERRCheck( JET_errRecordTooBig );

		pibVarOffs = prec->PibVarOffsets();

		//	shift rest of record over to make room
		//
		BYTE	*pbVarOffsEnd = prec->PbVarData();
		Assert( pbVarOffsEnd >= (BYTE *)pibVarOffs );
		memmove(
				pbVarOffsEnd + cbNeed,
				pbVarOffsEnd,
				pbRec + cbRec - pbVarOffsEnd );

#ifdef DEBUG
		memset( pbVarOffsEnd, chRECFill, cbNeed );
#endif

		
		//	set new var offsets to tag offset, making them NULL
		//
		pib = (UnalignedLittleEndian<REC::VAROFFSET> *)pbVarOffsEnd;
		pibLast	= pibVarOffs + ( fid - fidVarLeast );
		
		WORD			ibTagFields	= prec->IbEndOfVarData();
		SetVarNullBit( ibTagFields );
		
		Assert( pib == pibVarOffs + ( fidVarLastInRec+1-fidVarLeast ) );
		Assert( prec->PbVarData() + IbVarOffset( ibTagFields ) - pbRec <= cbRec );
		Assert( pib <= pibLast );
		Assert( pibLast - pib + 1 == cbNeed / sizeof(REC::VAROFFSET) );
		while( pib <= pibLast )
			*pib++ = ibTagFields;
		Assert( pib == pibVarOffs + ( fid+1-fidVarLeast ) );

		//	increase record size to reflect addition of entries in the
		//	variable offsets table.
		//
		Assert( prec->FidVarLastInRec() == fidVarLastInRec );
		prec->SetFidVarLastInRec( fid );
		Assert( pfucb->dataWorkBuf.Cb() == cbRec );
		cbRec += cbNeed;

		Assert( prec->PibVarOffsets() == pibVarOffs );
		Assert( pibVarOffs[fid-fidVarLeast] == ibTagFields );	// Includes null-bit comparison.

		// Burst default values if required.
		Assert( cbBurstDefaults == 0
			|| ( fidLastDefault > fidVarLastInRec && fidLastDefault < fid ) );
		if ( cbBurstDefaults > 0 )
			{
			Assert( NULL != ptdb->PdataDefaultRecord() );

			BYTE			*pbVarData			= prec->PbVarData();
			const REC		*precDefault		= (REC *)ptdb->PdataDefaultRecord()->Pv();
			const BYTE		*pbVarDataDefault	= precDefault->PbVarData();
			UnalignedLittleEndian<REC::VAROFFSET>	*pibDefaultVarOffs;
			UnalignedLittleEndian<REC::VAROFFSET>	*pibDefault;

			// Should have changed since last time, since we added
			// some columns.
			Assert( pbVarData > pbVarOffsEnd );
			Assert( pbVarData > pbRec );
			Assert( pbVarData <= pbRec + cbRec );

			pibDefaultVarOffs = precDefault->PibVarOffsets();

			// Make room for the default values to be burst.
			Assert( FVarNullBit( ibTagFields ) );
			Assert( cbRec >= pbVarData + IbVarOffset( ibTagFields ) - pbRec );
			const ULONG		cbTaggedData = cbRec - ULONG( pbVarData + IbVarOffset( ibTagFields ) - pbRec );
			memmove(
				pbVarData + IbVarOffset( ibTagFields ) + cbBurstDefaults,
				pbVarData + IbVarOffset( ibTagFields ),
				cbTaggedData );

			Assert( fidVarLastInRec < fidLastDefault );
			
			Assert( fidVarLastInRec == fidVarLeast-1
				|| IbVarOffset( pibDefaultVarOffs[fidVarLastInRec-fidVarLeast] )
						< IbVarOffset( pibDefaultVarOffs[fidLastDefault-fidVarLeast] ) );
			Assert( pbVarDataDefault + IbVarOffset( pibDefaultVarOffs[fidLastDefault-fidVarLeast] ) - (BYTE *)precDefault
					<= ptdb->PdataDefaultRecord()->Cb() );

			pib = pibVarOffs + ( fidVarLastInRec + 1 - fidVarLeast );
			Assert( *pib == ibTagFields );	// Null bit also compared.
			pibDefault = pibDefaultVarOffs + ( fidVarLastInRec + 1 - fidVarLeast );

#ifdef DEBUG
			ULONG	cbBurstSoFar		= 0;
#endif			
			
			for ( FID fidT = FID( fidVarLastInRec + 1 );
				fidT <= fidLastDefault;
				fidT++, pib++, pibDefault++ )
				{
				const BOOL	fTemplateColumn	= ptdb->FVarTemplateColumn( fidT );
				const FIELD *pfieldVar		= ptdb->PfieldVar( ColumnidOfFid( fidT, fTemplateColumn ) );

				// Null bit is initially set when the offsets
				// table is expanded above.
				Assert( FVarNullBit( *pib ) );

				if ( FFIELDDefault( pfieldVar->ffield )
					&& !FFIELDCommittedDelete( pfieldVar->ffield ) )
					{
					Assert( JET_coltypNil != pfieldVar->coltyp );

					// Update offset entry in preparation for the default value.
					Assert( !FVarNullBit( *pibDefault ) );

					if ( fidVarLeast == fidT )
						{
						Assert( IbVarOffset( *pibDefault ) > 0 );
						const USHORT	cb	= IbVarOffset( *pibDefault );
						*pib = cb;
						UtilMemCpy( pbVarData, pbVarDataDefault, cb );
#ifdef DEBUG
						cbBurstSoFar += cb;
#endif					
						}
					else
						{
						Assert( IbVarOffset( *pibDefault ) > IbVarOffset( *(pibDefault-1) ) );
						const USHORT	cb	= USHORT( IbVarOffset( *pibDefault )
												- IbVarOffset( *(pibDefault-1) ) );
						const USHORT	ib	= USHORT( IbVarOffset( *(pib-1) ) + cb );
						*pib = ib;
						UtilMemCpy( pbVarData + IbVarOffset( *(pib-1) ),
								pbVarDataDefault + IbVarOffset( *(pibDefault-1) ),
								cb );
#ifdef DEBUG
						cbBurstSoFar += cb;
#endif					
						}
						
//					Null bit gets reset when cb is set
//					ResetVarNullBit( *pib );
					Assert( !FVarNullBit( *pib ) );
					}
				else if ( fidT > fidVarLeast )
					{
					*pib = IbVarOffset( *(pib-1) );
					
//					Null bit gets reset when cb is set
					Assert( !FVarNullBit( *pib ) );
					SetVarNullBit( *(UnalignedLittleEndian< WORD >*)(pib) );
					}
				else
					{
					Assert( fidT == fidVarLeast );
					Assert( FVarNullBit( *pib ) );
					Assert( 0 == IbVarOffset( *pib ) );
					}
				}

#ifdef DEBUG
			Assert( cbBurstDefaults == cbBurstSoFar );
#endif			

			Assert( FVarNullBit( *pib ) );
			Assert( *pib == ibTagFields );
			if ( fidVarLastInRec >= fidVarLeast )
				{
				Assert( IbVarOffset( pibVarOffs[fidVarLastInRec-fidVarLeast] )
					== IbVarOffset( ibTagFields ) );
				Assert( IbVarOffset( *(pib-1) ) -
						IbVarOffset( pibVarOffs[fidVarLastInRec-fidVarLeast] )
					== (WORD)cbBurstDefaults );
				}
			else
				{
				Assert( IbVarOffset( *(pib-1) ) == (WORD)cbBurstDefaults );
				}

			// Offset entries up to the last default have been set.
			// Update the entries between the last default and the
			// column being set.
			pibLast = pibVarOffs + ( fid - fidVarLeast );
			for ( ; pib <= pibLast; pib++ )
				{
				Assert( FVarNullBit( *pib ) );
				Assert( *pib == ibTagFields );

				*pib = REC::VAROFFSET( *pib + cbBurstDefaults );
				}

#ifdef DEBUG
			// Verify null bits vs. offsets.
			pibLast = pibVarOffs + ( fid - fidVarLeast );
			for ( pib = pibVarOffs+1; pib <= pibLast; pib++ )
				{
				Assert( IbVarOffset( *pib ) >= IbVarOffset( *(pib-1) ) );
				if ( FVarNullBit( *pib ) )
					{
					Assert( pib != pibVarOffs + ( fidLastDefault - fidVarLeast ) );
					Assert( IbVarOffset( *pib ) == IbVarOffset( *(pib-1) ) );
					}
				else
					{
					Assert( pib <= pibVarOffs + ( fidLastDefault - fidVarLeast ) );
					Assert( IbVarOffset( *pib ) > IbVarOffset( *(pib-1) ) );
					}
				}
#endif
			}

		Assert( pfucb->dataWorkBuf.Cb() == cbRec - cbNeed );
		cbRec += cbBurstDefaults;
		pfucb->dataWorkBuf.SetCb( cbRec );
		
		Assert( prec->FidVarLastInRec() == fid );
		}

	//	fid is now definitely represented in the record;
	//	its data can be replaced, shifting remainder of record,
	//	either to the right or left (if expanding/shrinking)
	//

	Assert( JET_errSuccess == err || JET_wrnColumnMaxTruncated == err );


	//	compute change in column size and value of null-bit in offset
	//
	pibVarOffs = prec->PibVarOffsets();
	pib = pibVarOffs + ( fid - fidVarLeast );

	// Calculate size change of column data
	REC::VAROFFSET	ibStartOfColumn;
	if( fidVarLeast == fid )
		{
		ibStartOfColumn = 0;
		}
	else
		{
		ibStartOfColumn = IbVarOffset( *(pib-1) );
		}
		
	const REC::VAROFFSET	ibEndOfColumn	= IbVarOffset( *pib );
	const INT				dbFieldData		= cbCopy - ( ibEndOfColumn - ibStartOfColumn );

	//	size changed: must shift rest of record data
	//
	if ( 0 != dbFieldData )
		{
		BYTE	*pbVarData = prec->PbVarData();
		
		//	shift data
		//
		if ( cbRec + dbFieldData > cbRECRecordMost )
			{
			Assert( !fBurstRecord );		// If record had to be extended, space
											// consumption was already checked.
			return ErrERRCheck( JET_errRecordTooBig );
			}

		Assert( cbRec >= pbVarData + ibEndOfColumn - pbRec );
		memmove(
			pbVarData + ibEndOfColumn + dbFieldData,
			pbVarData + ibEndOfColumn,
			cbRec - ( pbVarData + ibEndOfColumn - pbRec ) );

#ifdef DEBUG
		if ( dbFieldData > 0 )
			memset( pbVarData + ibEndOfColumn, chRECFill, dbFieldData );
#endif

		pfucb->dataWorkBuf.DeltaCb( dbFieldData );
		cbRec = pfucb->dataWorkBuf.Cb();

		//	bump affected var column offsets
		//
		Assert( fid <= prec->FidVarLastInRec() );
		Assert( prec->FidVarLastInRec() >= fidVarLeast );
		pibLast = pibVarOffs + ( prec->FidVarLastInRec() - fidVarLeast );
		for ( pib = pibVarOffs + ( fid - fidVarLeast ); pib <= pibLast; pib++ )
			{
			*pib = WORD( *pib + dbFieldData );
			}

		// Reset for setting of null bit below.
		pib = pibVarOffs + ( fid - fidVarLeast );
		}

	//	data shift complete, if any;  copy new column value in
	//
	Assert( cbCopy >= 0 );
	if ( cbCopy > 0 )
		{
		UtilMemCpy(
			prec->PbVarData() + ibStartOfColumn,
			pdataField->Pv(),
			cbCopy );
		}

	//	set value of null-bit in offset
	//
	if ( NULL == pdataField )
		{
		SetVarNullBit( *( UnalignedLittleEndian< WORD >*)pib );
		}
	else
		{
		ResetVarNullBit( *( UnalignedLittleEndian< WORD >*)pib );
		}

	Assert( pfucb->dataWorkBuf.Cb() <= cbRECRecordMost );
	Assert( JET_errSuccess == err || JET_wrnColumnMaxTruncated == err );
	return err;
	}


ERR ErrRECISetTaggedColumn(
	FUCB			* const pfucb,
	TDB				* const ptdb,
	const COLUMNID	columnid,
	const ULONG		itagSequence,
	const DATA		* const pdataToSet,
	const BOOL		fUseDerivedBit,
	const JET_GRBIT	grbit )
	{
	const FID		fid					= FidOfColumnid( columnid );
	Assert( FCOLUMNIDTagged( columnid ) );
	
	Assert( pfucbNil != pfucb );
	Assert( FFUCBIndex( pfucb ) || FFUCBSort( pfucb ) );
	
	if ( fid > ptdb->FidTaggedLast() )
		return ErrERRCheck( JET_errColumnNotFound );

	const FIELD		*const pfield		= ptdb->PfieldTagged( columnid );
	Assert( pfieldNil != pfield );
	if ( JET_coltypNil == pfield->coltyp )
		return ErrERRCheck( JET_errColumnNotFound );

	//	record the fact that this column has been changed
	//
	FUCBSetColumnSet( pfucb, fid );
	
	//	check for column too long
	//
	if ( pfield->cbMaxLen > 0
		&& NULL != pdataToSet
		&& pdataToSet->Cb() > pfield->cbMaxLen )
		{
		return ErrERRCheck( JET_errColumnTooBig );
		}

	//	check fixed size column size
	//
	if ( NULL != pdataToSet
		&& pdataToSet->Cb() > 0 )
		{
		switch ( pfield->coltyp )
			{
			case JET_coltypBit:
			case JET_coltypUnsignedByte:
				if ( pdataToSet->Cb() != 1 )
					{
					return ErrERRCheck( JET_errInvalidBufferSize );
					}
				break;
			case JET_coltypShort:
				if ( pdataToSet->Cb() != 2 )
					{
					return ErrERRCheck( JET_errInvalidBufferSize );
					}
				break;
			case JET_coltypLong:
			case JET_coltypIEEESingle:
				if ( pdataToSet->Cb() != 4 )
					{
					return ErrERRCheck( JET_errInvalidBufferSize );
					}
				break;
			case JET_coltypCurrency:
			case JET_coltypIEEEDouble:
			case JET_coltypDateTime:
				if ( pdataToSet->Cb() != 8 )
					{
					return ErrERRCheck( JET_errInvalidBufferSize );
					}
				break;
			default:
				Assert( JET_coltypText == pfield->coltyp
					|| JET_coltypBinary == pfield->coltyp
					|| FRECLongValue( pfield->coltyp )
					|| FRECSLV( pfield->coltyp) );
				break;
			}
		}

	//	cannot set column more than cbLVIntrinsicMost bytes
	//
	if ( NULL != pdataToSet
		&& pdataToSet->Cb() > cbLVIntrinsicMost )
		{
		return ErrERRCheck( JET_errColumnLong );
		}

#ifdef DEBUG
	VOID			* pvDBGCopyOfRecord;
	const ULONG		cbDBGCopyOfRecord		= pfucb->dataWorkBuf.Cb();
	BFAlloc( &pvDBGCopyOfRecord );
	UtilMemCpy( pvDBGCopyOfRecord, pfucb->dataWorkBuf.Pv(), cbDBGCopyOfRecord );
#endif
								
	TAGFIELDS	tagfields( pfucb->dataWorkBuf );
	const ERR	errT		= tagfields.ErrSetColumn(
									pfucb,
									pfield,
									columnid,
									itagSequence,
									pdataToSet,
									grbit | ( fUseDerivedBit ? grbitSetColumnUseDerivedBit : 0 ) );

#ifdef DEBUG
	BFFree( pvDBGCopyOfRecord );
#endif

	return errT;
	}


//	change default value of a non-derived column
ERR VTAPI ErrIsamSetColumnDefaultValue(
	JET_SESID	vsesid,
	JET_DBID	vdbid,
	const CHAR	*szTableName,
	const CHAR	*szColumnName,
	const VOID	*pvData,
	const ULONG	cbData,
	const ULONG	grbit )
	{
	ERR			err;
	PIB			*ppib				= (PIB *)vsesid;
	IFMP		ifmp				= (IFMP)vdbid;
	FUCB		*pfucb				= pfucbNil;
	FCB			*pfcb				= pfcbNil;
	TDB			*ptdb				= ptdbNil;
	BOOL		fInTrx				= fFalse;
	BOOL		fNeedToSetFlag		= fFalse;
	BOOL		fResetFlagOnErr		= fFalse;
	BOOL		fRestorePrevOnErr	= fFalse;
	DATA		dataDefault;
	DATA *		pdataDefaultPrev;
	OBJID		objidTable;
	FIELD		*pfield;
	COLUMNID	columnid;
	CHAR		szColumn[JET_cbNameMost+1];

	//	check parameters
	//
	CallR( ErrPIBCheck( ppib ) );
	CallR( ErrPIBCheckIfmp( ppib, ifmp ) );
	Assert( dbidTemp != rgfmp[ ifmp ].Dbid() );

	CallR( ErrUTILCheckName( szColumn, szColumnName, JET_cbNameMost+1 ) );

	if ( NULL == pvData || 0 == cbData )
		{
		err = ErrERRCheck( JET_errNullInvalid );
		return err;
		}

	CallR( ErrFILEOpenTable(
				ppib,
				ifmp,
				&pfucb,
				szTableName,
				JET_bitTableDenyRead ) );
	CallSx( err, JET_wrnTableInUseBySystem );
	Assert( pfucbNil != pfucb );

	// We should now have exclusive use of the table.
    pfcb = pfucb->u.pfcb;
	objidTable = pfcb->ObjidFDP();
    Assert( pfcbNil != pfcb );

    ptdb = pfcb->Ptdb();
    Assert( ptdbNil != ptdb );

	//	save off old default record in case we have to restore it on error
	Assert( NULL != ptdb->PdataDefaultRecord() );
	pdataDefaultPrev = ptdb->PdataDefaultRecord();
	Assert( NULL != pdataDefaultPrev );
	Assert( !pdataDefaultPrev->FNull() );

	Assert( cbData > 0 );
	Assert( pvData != NULL );
	dataDefault.SetCb( cbData );
	dataDefault.SetPv( (VOID *)pvData );

	FUCB	fucbFake;
	FCB		fcbFake( pfcb->Ifmp(), pfcb->PgnoFDP() );
	FILEPrepareDefaultRecord( &fucbFake, &fcbFake, ptdb );
	Assert( fucbFake.pvWorkBuf != NULL );
	
	Call( ErrDIRBeginTransaction( ppib, NO_GRBIT ) );
	fInTrx = fTrue;


	//	NOTE: Can only change the default value of non-derived columns
	//	so don't even bother looking for the column in the template
	//	table's column space

	pfcb->EnterDML();
	err = ErrFILEPfieldFromColumnName(
			ppib,
			pfcb,
			szColumn,
			&pfield,
			&columnid );
	if ( err >= 0 )
		{
		if ( pfieldNil == pfield )
			{
			err = ErrERRCheck( JET_errColumnNotFound );
			}
		else if ( FFILEIsIndexColumn( ppib, pfcb, columnid ) )
			{
			err = ErrERRCheck( JET_errColumnInUse );
			}
		else
			{
			fNeedToSetFlag = !FFIELDDefault( pfield->ffield );
			}
		}
	pfcb->LeaveDML();

	Call( err );

	Call( ErrCATChangeColumnDefaultValue(
				ppib,
				ifmp,
				objidTable,
				szColumn,
				dataDefault ) )

	Assert( fucbFake.pvWorkBuf != NULL );
	Assert( fucbFake.u.pfcb == &fcbFake );
	Assert( fcbFake.Ptdb() == ptdb );

	//	if adding a default value, the default value
	//	flag will not be set, so must set it now
	//	before rebuilding the default record (because
	//	the rebuild code checks that flag)
	if ( fNeedToSetFlag )
		{
		pfcb->EnterDDL();
		FIELDSetDefault( ptdb->Pfield( columnid )->ffield );
		if ( !FFIELDEscrowUpdate( ptdb->Pfield( columnid )->ffield ) )
			{
			ptdb->SetFTableHasNonEscrowDefault();
			}
		ptdb->SetFTableHasDefault();
		pfcb->LeaveDDL();

		fResetFlagOnErr = fTrue;
		}

	Call( ErrFILERebuildDefaultRec( &fucbFake, columnid, &dataDefault ) );
	Assert( NULL != ptdb->PdataDefaultRecord() );
	Assert( !ptdb->PdataDefaultRecord()->FNull() );
	Assert( ptdb->PdataDefaultRecord() != pdataDefaultPrev );
	fRestorePrevOnErr = fTrue;

	Call( ErrDIRCommitTransaction( ppib, NO_GRBIT ) );
	fInTrx = fFalse;

	Assert( NULL != pdataDefaultPrev );
	OSMemoryHeapFree( pdataDefaultPrev );

HandleError:
	if ( err < 0 )
		{
		Assert( ptdbNil != ptdb );

		if ( fResetFlagOnErr )
			{
			Assert( fNeedToSetFlag );
			pfcb->EnterDDL();
			FIELDResetDefault( ptdb->Pfield( columnid )->ffield );
			pfcb->LeaveDDL();
			}

		if ( fRestorePrevOnErr )
			{
			Assert( NULL != ptdb->PdataDefaultRecord() );
			OSMemoryHeapFree( ptdb->PdataDefaultRecord() );
			ptdb->SetPdataDefaultRecord( pdataDefaultPrev );
			}
		
		if ( fInTrx )
			{
			CallSx( ErrDIRRollback( ppib ), JET_errRollbackError );
			}
		}
	else
		{
		Assert( !fInTrx );
		}
	
	FILEFreeDefaultRecord( &fucbFake );

	Assert( pfucbNil != pfucb );
	DIRClose( pfucb );

	AssertDIRNoLatch( ppib );

	return err;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ese98\src\ese\fileopen.cxx ===
#include "std.hxx"

extern CAutoResetSignal sigDoneFCB;

ERR VTAPI ErrIsamDupCursor( JET_SESID sesid, JET_VTID vtid, JET_TABLEID  *ptableid, ULONG grbit )
	{
 	PIB *ppib		= reinterpret_cast<PIB *>( sesid );
	FUCB *pfucbOpen = reinterpret_cast<FUCB *>( vtid );
	FUCB **ppfucb	= reinterpret_cast<FUCB **>( ptableid );

	ERR		err;
	FUCB 	*pfucb;

	CallR( ErrPIBCheck( ppib ) );
	CheckTable( ppib, pfucbOpen );

	//	silence warnings
	//
	NotUsed( grbit );

	//	allocate FUCB
	//
	Call( ErrDIROpen( ppib, pfucbOpen->u.pfcb, &pfucb ) );

	//	reset copy buffer
	//
	pfucb->pvWorkBuf = NULL;
	pfucb->dataWorkBuf.SetPv( NULL );
	Assert( !FFUCBUpdatePrepared( pfucb ) );

	//	reset key buffer
	//
	pfucb->dataSearchKey.Nullify();
	pfucb->cColumnsInSearchKey = 0;
	KSReset( pfucb );

	//	copy cursor flags
	//
	FUCBSetIndex( pfucb );
	if ( FFUCBUpdatable( pfucbOpen ) )
		{
		FUCBSetUpdatable( pfucb );
		Assert( !rgfmp[pfucb->ifmp].FReadOnlyAttach() );
		}
	else
		{
		FUCBResetUpdatable( pfucb );
		}

	//	move currency to the first record and ignore error if no records
	//
	RECDeferMoveFirst( ppib, pfucb );
	err = JET_errSuccess;

	pfucb->pvtfndef = &vtfndefIsam;
	*ppfucb = pfucb;

	return JET_errSuccess;

HandleError:
	return err;
	}


//+local
// ErrTDBCreate
// ========================================================================
// ErrTDBCreate(
//		TDB **pptdb,			// OUT	 receives new TDB
//		FID fidFixedLast,		// IN	   last fixed field id to be used
//		FID fidVarLast,			// IN	   last var field id to be used
//		FID fidTaggedLast )		// IN	   last tagged field id to be used
//
// Allocates a new TDB, initializing internal elements appropriately.
//
// PARAMETERS
//				pptdb			receives new TDB
//				fidFixedLast	last fixed field id to be used
//								(should be fidFixedLeast-1 if none)
//				fidVarLast		last var field id to be used
//								(should be fidVarLeast-1 if none)
//				fidTaggedLast	last tagged field id to be used
//								(should be fidTaggedLeast-1 if none)
// RETURNS		Error code, one of:
//					 JET_errSuccess				Everything worked.
//					-JET_errOutOfMemory	Failed to allocate memory.
// SEE ALSO		ErrRECAddFieldDef
//-

const ULONG	cbAvgName	= 16;

ERR ErrTDBCreate(
	INST	*pinst,
	TDB		**pptdb,
	TCIB	*ptcib,
	FCB		*pfcbTemplateTable,
	BOOL	fAllocateNameSpace )
	{
	ERR		err;					// standard error value
	WORD 	cfieldFixed;  			// # of fixed fields
	WORD 	cfieldVar;	  			// # of var fields
	WORD 	cfieldTagged; 			// # of tagged fields
	WORD	cfieldTotal;			// Fixed + Var + Tagged
	TDB   	*ptdb = ptdbNil;		// temporary TDB pointer
	FID		fidFixedFirst;
	FID		fidVarFirst;
	FID		fidTaggedFirst;
	WORD	ibEndFixedColumns;

	Assert( pptdb != NULL );
	Assert( ptcib->fidFixedLast <= fidFixedMost );
	Assert( ptcib->fidVarLast >= fidVarLeast-1 && ptcib->fidVarLast <= fidVarMost );
	Assert( ptcib->fidTaggedLast >= fidTaggedLeast-1 && ptcib->fidTaggedLast <= fidTaggedMost );

	if ( pfcbNil == pfcbTemplateTable )
		{
		fidFixedFirst = fidFixedLeast;
		fidVarFirst = fidVarLeast;
		fidTaggedFirst = fidTaggedLeast;
		ibEndFixedColumns = ibRECStartFixedColumns;
		}
	else
		{
		fidFixedFirst = FID( pfcbTemplateTable->Ptdb()->FidFixedLast() + 1 );
		if ( fidFixedLeast-1 == ptcib->fidFixedLast )
			{
			ptcib->fidFixedLast = FID( fidFixedFirst - 1 );
			}
		Assert( ptcib->fidFixedLast >= fidFixedFirst-1 );
			
		fidVarFirst = FID( pfcbTemplateTable->Ptdb()->FidVarLast() + 1 );
		if ( fidVarLeast-1 == ptcib->fidVarLast )
			{
			ptcib->fidVarLast = FID( fidVarFirst - 1 );
			}
		Assert( ptcib->fidVarLast >= fidVarFirst-1 );
			
		fidTaggedFirst = ( 0 != pfcbTemplateTable->Ptdb()->FidTaggedLastOfESE97Template() ?
							FID( pfcbTemplateTable->Ptdb()->FidTaggedLastOfESE97Template() + 1 ) :
							fidTaggedLeast );
		if ( fidTaggedLeast-1 == ptcib->fidTaggedLast )
			{
			ptcib->fidTaggedLast = FID( fidTaggedFirst - 1 );
			}
		Assert( ptcib->fidTaggedLast >= fidTaggedFirst-1 );
		
		ibEndFixedColumns = pfcbTemplateTable->Ptdb()->IbEndFixedColumns();
		}
		
	//	calculate how many of each field type to allocate
	//
	cfieldFixed = WORD( ptcib->fidFixedLast + 1 - fidFixedFirst );
	cfieldVar = WORD( ptcib->fidVarLast + 1 - fidVarFirst );
	cfieldTagged = WORD( ptcib->fidTaggedLast + 1 - fidTaggedFirst );
	cfieldTotal = WORD( cfieldFixed + cfieldVar + cfieldTagged );

	if ( ( ptdb = PtdbTDBAlloc( pinst ) ) == NULL )
		return ErrERRCheck( JET_errTooManyOpenTables );

	Assert( FAlignedForAllPlatforms( ptdb ) );

	memset( (BYTE *)ptdb, '\0', sizeof(TDB) );

	//	fill in max field id numbers
	new( ptdb ) TDB(
					fidFixedFirst,
					ptcib->fidFixedLast,
					fidVarFirst,
					ptcib->fidVarLast,
					fidTaggedFirst,
					ptcib->fidTaggedLast,
					ibEndFixedColumns,
					pfcbTemplateTable );

	//	propagate the SLVColumn flag from the template table
	
	if ( pfcbNil != pfcbTemplateTable
		&& pfcbTemplateTable->Ptdb()->FTableHasSLVColumn() )
		{
		ptdb->SetFTableHasSLVColumn();
		}

	// Allocate space for the FIELD structures.  In addition, allocate padding
	// in case there's index info
	if ( fAllocateNameSpace )
		{
		Call( ptdb->MemPool().ErrMEMPOOLInit(
			cbAvgName * ( cfieldTotal + 1 ),	// +1 for table name
			USHORT( cfieldTotal + 2 ),			// # tag entries = 1 per fieldname, plus 1 for all FIELD structures, plus 1 for table name
			fTrue ) );
		}
	else
		{
		//	this is a temp/sort table, so only allocate enough tags
		//	for the FIELD structures, table name, and IDXSEG
		Call( ptdb->MemPool().ErrMEMPOOLInit( cbFIELDPlaceholder, 3, fFalse ) );
		}

	//	add FIELD placeholder
	MEMPOOL::ITAG	itagNew;
	Call( ptdb->MemPool().ErrAddEntry( NULL, cbFIELDPlaceholder, &itagNew ) );
	Assert( itagNew == itagTDBFields );	// Should be the first entry in the buffer.

	const ULONG		cbFieldInfo		= cfieldTotal * sizeof(FIELD);
	if ( cbFieldInfo > 0 )
		{
		FIELD * const	pfieldInitial	= (FIELD *)PvOSMemoryHeapAlloc( cbFieldInfo );
		if ( NULL == pfieldInitial )
			{
			Call( ErrERRCheck( JET_errOutOfMemory ) );
			}
		memset( pfieldInitial, 0, cbFieldInfo );
		ptdb->SetPfieldInitial( pfieldInitial );
		}
	else
		{
		ptdb->SetPfieldInitial( NULL );
		}

	//	set output parameter and return
	//
	*pptdb = ptdb;
	return JET_errSuccess;

HandleError:
	Assert( ptdb != ptdbNil );
	ptdb->Delete( pinst );

	return err;
	}



//+API
// ErrRECAddFieldDef
// ========================================================================
// ErrRECAddFieldDef(
//		TDB *ptdb,		//	INOUT	TDB to add field definition to
//		FID fid );		//	IN		field id of new field
//
// Adds a field descriptor to an TDB.
//
// PARAMETERS	ptdb   			TDB to add new field definition to
//				fid	   			field id of new field (should be within
//					   			the ranges imposed by the parameters
//								supplied to ErrTDBCreate)
//				ftFieldType		data type of field
//				cbField			field length (only important when
//								defining fixed textual fields)
//				bFlags			field behaviour flags:
//				szFieldName		name of field
//
// RETURNS		Error code, one of:
//					 JET_errSuccess			Everything worked.
//					-ColumnInvalid	   		Field id given is greater than
//									   		the maximum which was given
//									   		to ErrTDBCreate.
//					-JET_errBadColumnId		A nonsensical field id was given.
//					-errFLDInvalidFieldType The field type given is either
//									   		undefined, or is not acceptable
//									   		for this field id.
// COMMENTS		When adding a fixed field, the fixed field offset table
//				in the TDB is recomputed.
// SEE ALSO		ErrTDBCreate
//-
ERR ErrRECAddFieldDef( TDB *ptdb, const COLUMNID columnid, FIELD *pfield )
	{
	FIELD	*pfieldNew;
	
	Assert( ptdb != ptdbNil );
	Assert( pfield != pfieldNil );

	//	fixed field: determine length, either from field type
	//	or from parameter (for text/binary types)
	//
	Assert( FCOLUMNIDValid( columnid ) );

	if ( FCOLUMNIDTagged( columnid ) )
		{
		//	tagged field: any type is ok
		//
		if ( FidOfColumnid( columnid ) > ptdb->FidTaggedLast() )
			return ErrERRCheck( JET_errColumnNotFound );

		if( JET_coltypSLV == pfield->coltyp )
			{
			//	set the SLV flag
			ptdb->SetFTableHasSLVColumn();
			}
			
		Assert( 0 == pfield->ibRecordOffset );
		pfieldNew = ptdb->PfieldTagged( columnid );
		}
	else if ( FCOLUMNIDFixed( columnid ) )
		{
		if ( FidOfColumnid( columnid ) > ptdb->FidFixedLast() )
			return ErrERRCheck( JET_errColumnNotFound );

		Assert( pfield->ibRecordOffset >= ibRECStartFixedColumns );
		pfieldNew = ptdb->PfieldFixed( columnid );
		}

	else
		{
		Assert( FCOLUMNIDVar( columnid ) );

		//	variable column.  Check for bogus numeric and long types
		//
		if ( FidOfColumnid( columnid ) > ptdb->FidVarLast() )
			return ErrERRCheck( JET_errColumnNotFound );
		else if ( pfield->coltyp != JET_coltypBinary && pfield->coltyp != JET_coltypText )
			return ErrERRCheck( JET_errInvalidColumnType );
		
		Assert( 0 == pfield->ibRecordOffset );
		pfieldNew = ptdb->PfieldVar( columnid );
		}

	*pfieldNew = *pfield;

	return JET_errSuccess;
	}


ERR ErrFILEIGenerateIDB( FCB *pfcb, TDB *ptdb, IDB *pidb )
	{
	const IDXSEG*	pidxseg;
	const IDXSEG*	pidxsegMac;
	BOOL			fFoundUserDefinedDefault	= fFalse;
	
	Assert( pfcb != pfcbNil );
	Assert( ptdb != ptdbNil );
	Assert( pidb != pidbNil );

	Assert( (cbitFixed % 8) == 0 );
	Assert( (cbitVariable % 8) == 0 );
	Assert( (cbitTagged % 8) == 0 );

	Assert( pidb->Cidxseg() <= JET_ccolKeyMost );

	memset( pidb->RgbitIdx(), 0x00, 32 );

	//	check validity of each segment id and
	//	also set index mask bits
	//
	pidxseg = PidxsegIDBGetIdxSeg( pidb, ptdb );
	pidxsegMac = pidxseg + pidb->Cidxseg();

	if ( !pidb->FAllowFirstNull() )
		{
		//	HACK for existing databases that
		//	were corrupted by bug #108371
		pidb->ResetFAllowAllNulls();
		}


	//	SPARSE INDEXES
	//	--------------
	//	Sparse indexes are an attempt to
	//	optimise record insertion by not having to
	//	update indexes that are likely to be sparse
	//	(ie. there are enough unset columns in the
	//	record to cause the record to be excluded
	//	due to the Ignore*Null flags imposed on the
	//	index).  Sparse indexes exploit any Ignore*Null
	//	flags to check before index update that enough
	//	index columns were left unset to satisfy the
	//	Ignore*Null conditions and therefore not require
	//	that the index be updated. In order for an
	//	index to be labelled as sparse, the following
	//	conditions must be satisfied:
	//		1) this is not the primary index (can't
	//		   skip records in the primary index)
	//		2) null segments are permitted
	//		3) no index entry generated if any/all/first
	//		   index column(s) is/are null (ie. at
	//		   least one of the Ignore*Null flags
	//		   was used to create the index)
	//		4) all of the index columns may be set
	//		   to NULL
	//		5) none of the index columns has a default
	//		   value (because then the column would
	//		   be non-null)

	const BOOL	fIgnoreAllNull		= !pidb->FAllowAllNulls();
	const BOOL	fIgnoreFirstNull	= !pidb->FAllowFirstNull();
	const BOOL	fIgnoreAnyNull		= !pidb->FAllowSomeNulls();
	BOOL		fSparseIndex		= ( !pidb->FPrimary()
										&& !pidb->FNoNullSeg()
										&& ( fIgnoreAllNull || fIgnoreFirstNull || fIgnoreAnyNull ) );

	//	the primary index should not have had any of the Ignore*Null flags set
	Assert( !pidb->FPrimary()
		|| pidb->FNoNullSeg()
		|| ( pidb->FAllowAllNulls() && pidb->FAllowFirstNull() && pidb->FAllowSomeNulls() ) );

	const IDXSEG * const	pidxsegFirst	= pidxseg;
	for ( ; pidxseg < pidxsegMac; pidxseg++ )
		{
		//	field id is absolute value of segment id -- these should already
		//	have been validated, so just add asserts to verify integrity of
		//	fid's and their FIELD structures
		//
		const COLUMNID			columnid	= pidxseg->Columnid();
		const FIELD * const		pfield		= ptdb->Pfield( columnid );
		Assert( pfield->coltyp != JET_coltypNil );
		Assert( !FFIELDDeleted( pfield->ffield ) );

		if ( FFIELDUserDefinedDefault( pfield->ffield ) )
			{
			if ( !fFoundUserDefinedDefault )
				{
				//  UNDONE:  use the dependency list to optimize this
				memset( pidb->RgbitIdx(), 0xff, 32 );
				fFoundUserDefinedDefault = fTrue;
				}

			//	user-defined defaults may return a NULL or
			//	non-NULL default value for the column,
			//	so it is unclear whether the record would be
			//	present in the index
			//	SPECIAL CASE: if IgnoreFirstNull and this is
			//	not the first column, then it's still possible
			//	for this to be a sparse index
			if ( !fIgnoreFirstNull
				|| fIgnoreAnyNull
				|| pidxsegFirst == pidxseg )
				{
				fSparseIndex = fFalse;
				}
			}

		if ( FFIELDNotNull( pfield->ffield ) || FFIELDDefault( pfield->ffield ) )
			{
			//	if field can't be NULL or if there's a default value
			//	overriding NULL, this can't be a sparse index
			//	SPECIAL CASE: if IgnoreFirstNull and this is
			//	not the first column, then it's still possible
			//	for this to be a sparse index
			if ( !fIgnoreFirstNull
				|| fIgnoreAnyNull
				|| pidxsegFirst == pidxseg )
				{
				fSparseIndex = fFalse;
				}
			}

		if ( FCOLUMNIDTagged( columnid ) )
			{
			Assert( !FFIELDPrimaryIndexPlaceholder( pfield->ffield ) );

			if ( FFIELDMultivalued( pfield->ffield ) )
				{
				Assert( !pidb->FPrimary() );

				//	Multivalued flag was persisted in catalog as of 0x620,2
				if ( !pidb->FMultivalued() )
					{
					Assert( rgfmp[pfcb->Ifmp()].Pdbfilehdr()->le_ulVersion == 0x00000620 );
					Assert( rgfmp[pfcb->Ifmp()].Pdbfilehdr()->le_ulUpdate < 0x00000002 );
					}
						
				//	Must set the flag anyway to ensure backward
				//	compatibility.
				pidb->SetFMultivalued();
				}
			}
		else if ( FFIELDPrimaryIndexPlaceholder( pfield->ffield )
			&& pidb->FPrimary() )
			{
			//	must be first column in index
			Assert( PidxsegIDBGetIdxSeg( pidb, ptdb ) == pidxseg );

			//	must be fixed bitfield
			Assert( FCOLUMNIDFixed( columnid ) );
			Assert( JET_coltypBit == pfield->coltyp );
			pidb->SetFHasPlaceholderColumn();
			}

		if ( FRECTextColumn( pfield->coltyp ) && usUniCodePage == pfield->cp )
			{
			//	LocalizedText flag was persisted in catalog as of 0x620,2
			if ( !pidb->FLocalizedText() )
				{
				Assert( rgfmp[pfcb->Ifmp()].Pdbfilehdr()->le_ulVersion == 0x00000620 );
				Assert( rgfmp[pfcb->Ifmp()].Pdbfilehdr()->le_ulUpdate < 0x00000002 );
				}
						
			//	Must set the flag anyway to ensure backward
			//	compatibility.
			pidb->SetFLocalizedText();
			}

		pidb->SetColumnIndex( FidOfColumnid( columnid ) );
		Assert ( pidb->FColumnIndex( FidOfColumnid( columnid ) ) );
		}


	//	SPARSE CONDITIONAL INDEXES
	//	---------------------------
	//	Sparse conditional indexes are an attempt to
	//	optimise record insertion by not having to
	//	update conditional indexes that are likely to
	//	be sparse (ie. there are enough unset columns
	//	in the record to cause the record to be
	//	excluded due to the conditional columns imposed
	//	on the index).  We label a conditional index as
	//	sparse if there is AT LEAST ONE conditional
	//	column which, if unset, will cause the record
	//	to NOT be included in the index.  This means
	//	that if the condition is MustBeNull, the column
	//	must have a default value, and if the
	//	condition is MustBeNonNull, the column must
	//	NOT have a default value.

	BOOL	fSparseConditionalIndex		= fFalse;

	//	the primary index should not have any conditional columns
	Assert( !pidb->FPrimary()
		|| 0 == pidb->CidxsegConditional() );

	pidxseg = PidxsegIDBGetIdxSegConditional( pidb, ptdb );
	pidxsegMac = pidxseg + pidb->CidxsegConditional();
	for ( ; pidxseg < pidxsegMac; pidxseg++ )
		{
		const COLUMNID			columnid	= pidxseg->Columnid();
		const FIELD * const		pfield		= ptdb->Pfield( columnid );
		Assert( pfield->coltyp != JET_coltypNil );
		Assert( !FFIELDDeleted( pfield->ffield ) );

		if ( FFIELDUserDefinedDefault( pfield->ffield ) )
			{
			if ( !fFoundUserDefinedDefault )
				{
				//  UNDONE:  use the dependency list to optimize this
				memset( pidb->RgbitIdx(), 0xff, 32 );
				fFoundUserDefinedDefault = fTrue;
				}

			//	only reason to continue is to see if
			//	this might be a sparse conditional
			//	index, so if this has already been
			//	determined, then we can exit
			if ( fSparseConditionalIndex )
				break;
			}
		else if ( !fSparseConditionalIndex )
			{
			//	if there is a default value to force the
			//	column to be non-NULL by default
			//	(and thus NOT be present in the index),
			//	then we can treat this as a sparse column
			//	if there is no default value for this column,
			//	the column will be NULL by default (and
			//	thus be present in the index), so we can
			//	treat this as a sparse column
			const BOOL	fHasDefault	= FFIELDDefault( pfield->ffield );

			fSparseConditionalIndex = ( pidxseg->FMustBeNull() ?
											fHasDefault :
											!fHasDefault );
			}

		pidb->SetColumnIndex( FidOfColumnid( columnid ) );
		Assert( pidb->FColumnIndex( FidOfColumnid( columnid ) ) );
		}

	//	all requirements for sparse indexes are met
	//
	if ( fSparseIndex )
		{
		Assert( !pidb->FPrimary() );
		pidb->SetFSparseIndex();
		}
	else
		{
		pidb->ResetFSparseIndex();
		}

	if ( fSparseConditionalIndex )
		{
		Assert( !pidb->FPrimary() );
		pidb->SetFSparseConditionalIndex();
		}
	else
		{
		pidb->ResetFSparseConditionalIndex();
		}


	IDB	*pidbNew = PidbIDBAlloc( PinstFromIfmp( pfcb->Ifmp() ) );
	if ( pidbNil == pidbNew )
		return ErrERRCheck( JET_errTooManyOpenIndexes );

	Assert( FAlignedForAllPlatforms( pidbNew ) );

	*pidbNew = *pidb;

	pidbNew->InitRefcounts();
	
	pfcb->SetPidb( pidbNew );

	return JET_errSuccess;
	}


//  ================================================================
ERR VTAPI ErrIsamSetSequential(
	const JET_SESID sesid,
	const JET_VTID vtid,
	const JET_GRBIT )
//  ================================================================
	{
	ERR				err;
 	PIB * const		ppib		= reinterpret_cast<PIB *>( sesid );
	FUCB * const	pfucb		= reinterpret_cast<FUCB *>( vtid );

	CallR( ErrPIBCheck( ppib ) );
	CheckTable( ppib, pfucb );
	CheckSecondary( pfucb );
	AssertDIRNoLatch( ppib );

	FUCB * const	pfucbIdx	= ( pfucbNil != pfucb->pfucbCurIndex ?
										pfucb->pfucbCurIndex :
										pfucb );
	FUCBSetSequential( pfucbIdx );

	return JET_errSuccess;
	}


//  ================================================================
ERR VTAPI ErrIsamResetSequential(
	const JET_SESID sesid,
	const JET_VTID vtid,
	const JET_GRBIT )
//  ================================================================
	{
	ERR				err;
 	PIB * const		ppib		= reinterpret_cast<PIB *>( sesid );
	FUCB * const	pfucb		= reinterpret_cast<FUCB *>( vtid );

	CallR( ErrPIBCheck( ppib ) );
	CheckTable( ppib, pfucb );
	CheckSecondary( pfucb );
	AssertDIRNoLatch( ppib );

	FUCB * const	pfucbIdx	= ( pfucbNil != pfucb->pfucbCurIndex ?
										pfucb->pfucbCurIndex :
										pfucb );
	FUCBResetSequential( pfucbIdx );
	FUCBResetPreread( pfucbIdx );

	return JET_errSuccess;
	}


ERR VTAPI ErrIsamOpenTable(
	JET_SESID	vsesid,
	JET_DBID	vdbid,
	JET_TABLEID	*ptableid,
	CHAR		*szPath,
	JET_GRBIT	grbit )
	{
	ERR			err;
	PIB			*ppib	= (PIB *)vsesid;
	const IFMP	ifmp	= (IFMP)vdbid;
	FUCB		*pfucb	= pfucbNil;

	//	initialise return value
	Assert( ptableid );
	*ptableid = JET_tableidNil;
	
	//	check parameters
	//
	CallR( ErrPIBCheck( ppib ) );
	CallR( ErrPIBCheckIfmp( ppib, ifmp ) );
	AssertDIRNoLatch( ppib );

	if ( grbit & ( JET_bitTableDelete | JET_bitTableCreate ) )
		{
		err = ErrERRCheck( JET_errInvalidGrbit );
		goto HandleError;
		}
	else if ( grbit & JET_bitTablePermitDDL )
		{
		if ( !( grbit & JET_bitTableDenyRead ) )
			{
			err = ErrERRCheck( JET_errInvalidGrbit );
			goto HandleError;
			}
		}

	Call( ErrFILEOpenTable( ppib, ifmp, &pfucb, szPath, grbit ) );

#ifdef DEBUG
	if ( rgfmp[ifmp].FReadOnlyAttach() || ( grbit & JET_bitTableReadOnly ) )
		Assert( !FFUCBUpdatable( pfucb ) );
	else
		Assert( FFUCBUpdatable( pfucb ) );
#endif		

	pfucb->pvtfndef = &vtfndefIsam;
	*(FUCB **)ptableid = pfucb;

	AssertDIRNoLatch( ppib );
	return JET_errSuccess;

HandleError:

	AssertDIRNoLatch( ppib );
	return err;
	}


// monitoring statistics 

PM_CEF_PROC LTableOpenCacheHitsCEFLPv;
PERFInstanceG<> cTableOpenCacheHits;
long LTableOpenCacheHitsCEFLPv( long iInstance, void *pvBuf )
	{
	cTableOpenCacheHits.PassTo( iInstance, pvBuf );
	return 0;
	}


PM_CEF_PROC LTableOpenCacheMissesCEFLPv;
PERFInstanceG<> cTableOpenCacheMisses;
long LTableOpenCacheMissesCEFLPv( long iInstance, void *pvBuf )
	{
	cTableOpenCacheMisses.PassTo( iInstance, pvBuf );
	return 0;
	}

PM_CEF_PROC LTableOpensCEFLPv;
long LTableOpensCEFLPv( long iInstance, void *pvBuf )
	{
	if ( NULL != pvBuf )
		{
		*(LONG*)pvBuf = cTableOpenCacheHits.Get( iInstance ) + cTableOpenCacheMisses.Get( iInstance );
		}
	return 0;
	}


//	set domain usage mode or return error.  Allow only one deny read
//	or one deny write.  Sessions that own locks may open other read
//	or read write cursors.
//
LOCAL ERR ErrFILEISetMode( FUCB *pfucb, const JET_GRBIT grbit )
	{
	ERR		wrn		= JET_errSuccess;
	PIB		*ppib	= pfucb->ppib;
	FCB		*pfcb	= pfucb->u.pfcb;
	FUCB	*pfucbT;

	Assert( !pfcb->FDeleteCommitted() );

	//	all cursors can read so check for deny read flag by other session.
	//
	if ( pfcb->FDomainDenyRead( ppib ) )
		{
		Assert( pfcb->PpibDomainDenyRead() != ppibNil );
		if ( pfcb->PpibDomainDenyRead() != ppib )
			{
			return ErrERRCheck( JET_errTableLocked );
			}
			
#ifdef DEBUG
		for ( pfucbT = pfcb->Pfucb(); pfucbT != pfucbNil; pfucbT = pfucbT->pfucbNextOfFile )
			{
			Assert( pfucbT->ppib == pfcb->PpibDomainDenyRead()
				|| FPIBSessionSystemCleanup( pfucbT->ppib ) );
			}
#endif
		}

	//	check for deny write flag by other session.  If deny write flag
	//	set then only cursors of that session or cleanup cursors may have
	//	write privileges.
	//
	if ( grbit & JET_bitTableUpdatable )
		{
		if ( pfcb->FDomainDenyWrite() )
			{
			for ( pfucbT = pfcb->Pfucb(); pfucbT != pfucbNil; pfucbT = pfucbT->pfucbNextOfFile )
				{
				if ( pfucbT->ppib != ppib && FFUCBDenyWrite( pfucbT ) )
					{
					return ErrERRCheck( JET_errTableLocked );
					}
				}
			}
		}

	//	if deny write lock requested, check for updatable cursor of
	//	other session.  If lock is already held, even by given session,
	//	then return error.
	//
	if ( grbit & JET_bitTableDenyWrite )
		{
		//	if any session has this table open deny write, including given
		//	session, then return error.
		//
		if ( pfcb->FDomainDenyWrite() )
			{
			return ErrERRCheck( JET_errTableInUse );
			}

		//	check is cursors with write mode on domain.
		//
		for ( pfucbT = pfcb->Pfucb(); pfucbT != pfucbNil; pfucbT = pfucbT->pfucbNextOfFile )
			{
			if ( pfucbT->ppib != ppib
				&& FFUCBUpdatable( pfucbT )
				&& !FPIBSessionSystemCleanup( pfucbT->ppib ) )
				{
				return ErrERRCheck( JET_errTableInUse );
				}
			}
		pfcb->SetDomainDenyWrite();
		FUCBSetDenyWrite( pfucb );
		}

	//	if deny read lock requested, then check for cursor of other
	//	session.  If lock is already held, return error.
	//
	if ( grbit & JET_bitTableDenyRead )
		{
		//	if other session has this table open deny read, return error
		//
		if ( pfcb->FDomainDenyRead( ppib ) )
			{
			return ErrERRCheck( JET_errTableInUse );
			}
			
		//	check if cursors belonging to another session
		//	are open on this domain.
		//
		BOOL	fOpenSystemCursor = fFalse;
		for ( pfucbT = pfcb->Pfucb(); pfucbT != pfucbNil; pfucbT = pfucbT->pfucbNextOfFile )
			{
			if ( pfucbT != pfucb )		// Ignore current cursor )
				{
				if ( FPIBSessionSystemCleanup( pfucbT->ppib ) )
					{
					fOpenSystemCursor = fTrue;
					}
				else if ( pfucbT->ppib != ppib
					|| ( ( grbit & JET_bitTableDelete ) && !FFUCBDeferClosed( pfucbT ) ) )
					{
					return ErrERRCheck( JET_errTableInUse );
					}
				}
			}

		if ( fOpenSystemCursor )
			{
			wrn = ErrERRCheck( JET_wrnTableInUseBySystem );
			}

		pfcb->SetDomainDenyRead( ppib );
		FUCBSetDenyRead( pfucb );

		if ( grbit & JET_bitTablePermitDDL )
			{
			if ( !pfcb->FTemplateTable() )
				{
				ENTERCRITICALSECTION	enterCritFCBRCE( &pfcb->CritRCEList() );
				if ( pfcb->PrceNewest() != prceNil )
					return ErrERRCheck( JET_errTableInUse );

				Assert( pfcb->PrceOldest() == prceNil );
				}

			FUCBSetPermitDDL( pfucb );
			}
		}

	return wrn;
	}


//	if opening domain for read, write or read write, and not with
//	deny read or deny write, and domain does not have deny read or
//	deny write set, then return JET_errSuccess, else call
//	ErrFILEISetMode to determine if lock is by other session or to
//	put lock on domain.			 
//
LOCAL ERR ErrFILEICheckAndSetMode( FUCB *pfucb, const ULONG grbit )
	{
	PIB	*ppib = pfucb->ppib;
	FCB	*pfcb = pfucb->u.pfcb;

	if ( grbit & JET_bitTableReadOnly )
		{
		if ( grbit & JET_bitTableUpdatable )
			{
			return ErrERRCheck( JET_errInvalidGrbit );
			}

		FUCBResetUpdatable( pfucb );
		}

	// table delete cannot be specified without DenyRead
	//
	Assert( !( grbit & JET_bitTableDelete )
		|| ( grbit & JET_bitTableDenyRead ) );
	
	// PermitDDL cannot be specified without DenyRead
	//
	Assert( !( grbit & JET_bitTablePermitDDL )
		|| ( grbit & JET_bitTableDenyRead ) );
	
	//	if table is scheduled for deletion, then return error
	//
	if ( pfcb->FDeletePending() )
		{
		// Normally, the FCB of a table to be deleted is protected by the
		// DomainDenyRead flag.  However, this flag is released during VERCommit,
		// while the FCB is not actually purged until RCEClean.  So to prevent
		// anyone from accessing this FCB after the DomainDenyRead flag has been
		// released but before the FCB is actually purged, check the DeletePending
		// flag, which is NEVER cleared after a table is flagged for deletion.
		//
		return ErrERRCheck( JET_errTableLocked );
		}

	//	if read/write restrictions specified, or other
	//	session has any locks, then must check further
	//
	if ( ( grbit & (JET_bitTableDenyRead|JET_bitTableDenyWrite) )
		|| pfcb->FDomainDenyRead( ppib )
		|| pfcb->FDomainDenyWrite() )
		{
		return ErrFILEISetMode( pfucb, grbit );
		}

	if( grbit & JET_bitTableNoCache )
		{
		pfcb->SetNoCache();
		}
	else
		{
		pfcb->ResetNoCache();
		}

	if( grbit & JET_bitTablePreread )
		{
		pfcb->SetPreread();
		}
	else
		{
		pfcb->ResetPreread();
		}

	return JET_errSuccess;
	}

				
	
//+local
//	ErrFILEOpenTable
//	========================================================================
//	ErrFILEOpenTable(
//		PIB *ppib,			// IN	 PIB of who is opening file
//		IFMP ifmp,			// IN	 database id
//		FUCB **ppfucb,		// OUT	 receives a new FUCB open on the file
//		CHAR *szName,		// IN	 path name of file to open
//		ULONG grbit );		// IN	 open flags
//	Opens a data file, returning a new
//	FUCB on the file.
//
// PARAMETERS
//				ppib	   	PIB of who is opening file
//				ifmp	   	database id
//				ppfucb		receives a new FUCB open on the file
//						   	( should NOT already be pointing to an FUCB )
//				szName		path name of file to open ( the node
//						   	corresponding to this path must be an FDP )
//				grbit	   	flags:
//						   	JET_bitTableDenyRead	open table in exclusive mode;
//						   	default is share mode
// RETURNS		Lower level errors, or one of:
//					 JET_errSuccess					Everything worked.
//					-TableInvalidName	 			The path given does not
//										 			specify a file.
//					-JET_errDatabaseCorrupted		The database directory tree
//										 			is corrupted.
//					-Various out-of-memory error codes.
//				In the event of a fatal ( negative ) error, a new FUCB
//				will not be returned.
// SIDE EFFECTS FCBs for the file and each of its secondary indexes are
//				created ( if not already in the global list ).  The file's
//				FCB is inserted into the global FCB list.  One or more
//				unused FCBs may have had to be reclaimed.
//				The currency of the new FUCB is set to "before the first item".
// SEE ALSO		ErrFILECloseTable
//-
ERR ErrFILEOpenTable(
	PIB			*ppib,
	IFMP		ifmp,
	FUCB		**ppfucb,
	const CHAR	*szName,
	ULONG		grbit,
	FDPINFO		*pfdpinfo )
	{
	ERR			err;
	FUCB		*pfucb					= pfucbNil;
	FCB			*pfcb;
	CHAR		szTable[JET_cbNameMost+1];
	BOOL		fOpeningSys;
	PGNO		pgnoFDP					= pgnoNull;
	OBJID		objidTable				= objidNil;
	BOOL		fInTransaction			= fFalse;
	BOOL		fInitialisedCursor		= fFalse;

	Assert( ppib != ppibNil );
	Assert( ppfucb != NULL );
	FMP::AssertVALIDIFMP( ifmp );

	//	initialize return value to Nil
	//
	*ppfucb = pfucbNil; 

#ifdef DEBUG
	CheckPIB( ppib );
	if( !Ptls()->fIsTaskThread
		&& !Ptls()->fIsTaskThread
		&& !Ptls()->fIsRCECleanup )
		{
		CheckDBID( ppib, ifmp );
		}
#endif	//	DEBUG
	CallR( ErrUTILCheckName( szTable, szName, JET_cbNameMost+1 ) );

	fOpeningSys = FCATSystemTable( szTable );

	if ( NULL == pfdpinfo )
		{
		if ( dbidTemp == rgfmp[ ifmp ].Dbid() )
			{
			// Temp tables should pass in PgnoFDP.
			AssertSz( fFalse, "Illegal dbid" );
			return ErrERRCheck( JET_errInvalidDatabaseId );
			}

		if ( fOpeningSys )
			{
			if ( grbit & JET_bitTableDelete )
				{
				return ErrERRCheck( JET_errCannotDeleteSystemTable );
				}
			pgnoFDP 	= PgnoCATTableFDP( szTable );
			objidTable 	= ObjidCATTable( szTable );
			}
		else
			{
			if ( 0 == ppib->level )
				{
				CallR( ErrDIRBeginTransaction( ppib, JET_bitTransactionReadOnly ) );
				fInTransaction = fTrue;
				}

			//	lookup the table in the catalog hash before seeking
			if ( !FCATHashLookup( ifmp, szTable, &pgnoFDP, &objidTable ) )
				{
				Call( ErrCATSeekTable( ppib, ifmp, szTable, &pgnoFDP, &objidTable ) );
				}
			}
		}
	else 
		{
		Assert( pgnoNull != pfdpinfo->pgnoFDP );
		Assert( objidNil != pfdpinfo->objidFDP );
		pgnoFDP = pfdpinfo->pgnoFDP;
		objidTable = pfdpinfo->objidFDP;

#ifdef DEBUG
		if( fOpeningSys )
			{
			Assert( fGlobalRepair );
			Assert( PgnoCATTableFDP( szTable ) == pgnoFDP );
			Assert( ObjidCATTable( szTable ) == objidTable );
			}
		else if ( dbidTemp != rgfmp[ ifmp ].Dbid() )
			{
			PGNO	pgnoT;
			OBJID	objidT;

			//	lookup the table in the catalog hash before seeking
			if ( !FCATHashLookup( ifmp, szTable, &pgnoT, &objidT ) )
				{
				CallR( ErrCATSeekTable( ppib, ifmp, szTable, &pgnoT, &objidT ) );
				}

			Assert( pgnoT == pgnoFDP );
			Assert( objidT == objidTable );
			}
#endif	//	DEBUG
		}

	Assert( pgnoFDP > pgnoSystemRoot );
	Assert( pgnoFDP <= pgnoSysMax );
	Assert( objidNil != objidTable );
	Assert( objidTable > objidSystemRoot );

	Call( ErrDIROpenNoTouch( ppib, ifmp, pgnoFDP, objidTable, fTrue, &pfucb ) );
	Assert( pfucbNil != pfucb );

	pfcb = pfucb->u.pfcb;
	Assert( objidTable == pfcb->ObjidFDP() );
	Assert( pgnoFDP == pfcb->PgnoFDP() );

	FUCBSetIndex( pfucb );

	if( grbit & JET_bitTablePreread 
		|| grbit & JET_bitTableSequential )
		{
		//  Preread the root page of the tree
		BFPrereadPageRange( ifmp, pgnoFDP, 1 );
		}

	//	if we're opening after table creation, the FCB shouldn't be initialised
	Assert( !( grbit & JET_bitTableCreate ) || !pfcb->FInitialized() );

	// Only one thread could possibly get to this point with an uninitialized
	// FCB, which is why we don't have to grab the FCB's critical section.
	if ( !pfcb->FInitialized() )
		{
		if ( fInTransaction )
			{
			//	if FCB is not initialised, access to is serialised
			//	at this point, so no more need for transaction
			Call( ErrDIRCommitTransaction( ppib,NO_GRBIT ) );
			fInTransaction = fFalse;
			}

		if ( fOpeningSys )
			{
			Call( ErrCATInitCatalogFCB( pfucb ) );
			}
		else if ( dbidTemp == rgfmp[ ifmp ].Dbid() )
			{
			Assert( !( grbit & JET_bitTableDelete ) );
			Call( ErrCATInitTempFCB( pfucb ) );
			}

			///	BUGFIX: 99457: always init the TDB because we need to know if there are SLV columns
#ifdef NEVER			
		else if ( grbit & JET_bitTableDelete )
			{
			//	opening a table for deletion.  Do not
			//	initialise but instead mark it as a sentinel.
			//
			pfcb->SetTypeSentinel();
			Assert( pfcb->Ptdb() == ptdbNil );
			}
#endif	//	NEVER

		else
			{
			//	initialize the table's FCB
			
			Call( ErrCATInitFCB( pfucb, objidTable ) );

			//	cache the table name in the catalog hash after it gets initialized
			if ( !( grbit & ( JET_bitTableCreate|JET_bitTableDelete) ) )
				{
				CATHashInsert( pfcb, pfcb->Ptdb()->SzTableName() );
				}

			//	only count "regular" table opens

			cTableOpenCacheMisses.Inc( PinstFromPpib( ppib ) );
			}

		Assert( pfcb->Ptdb() != ptdbNil || pfcb->FTypeSentinel() );

		//	insert the FCB into the global list

		pfcb->InsertList();

		//	we have a full-fledged initialised cursor
		//	(FCB will be marked initialised in CreateComplete()
		//	below, which is guaranteed to succeed)
		fInitialisedCursor = fTrue;

		//	allow other cursors to use this FCB

		pfcb->Lock();
		Assert( !pfcb->FTypeNull() );
		Assert( !pfcb->FInitialized() );
		Assert( pfcb == pfucb->u.pfcb );
		pfcb->CreateComplete();
		err = ErrFILEICheckAndSetMode( pfucb, grbit );
		pfcb->Unlock();

		//	check result of ErrFILEICheckAndSetMode
		Call( err );
		}
	else
		{
		if ( !fOpeningSys
			&& dbidTemp != rgfmp[ ifmp ].Dbid()
			&& !( grbit & JET_bitTableDelete ) )
			{
			//	only count "regular" table opens
			cTableOpenCacheHits.Inc( PinstFromPpib( ppib ) );
			}
			
		//	we have a full-fledged initialised cursor
		fInitialisedCursor = fTrue;

		//	set table usage mode
		//
		Assert( pfcb == pfucb->u.pfcb );
		pfcb->Lock();
		err = ErrFILEICheckAndSetMode( pfucb, grbit );
		pfcb->Unlock();

		//	check result of ErrFILEICheckAndSetMode
		Call( err );

		if ( fInTransaction )
			{
			Call( ErrDIRCommitTransaction( ppib, NO_GRBIT ) );
			fInTransaction = fFalse;
			}
		}

	//	System cleanup threads (OLD and RCEClean) are permitted to open
	//	a cursor on a deleted table
	Assert( !pfcb->FDeletePending() || FPIBSessionSystemCleanup( ppib ) );
	Assert( !pfcb->FDeleteCommitted() || FPIBSessionSystemCleanup( ppib ) );

	//  set FUCB for sequential access if requested
	//
	if ( grbit & JET_bitTableSequential )
		FUCBSetSequential( pfucb );
	else
		FUCBResetSequential( pfucb );

#ifdef TABLES_PERF
	//  set the Table Class for this table and all its indexes
	//
	if ( pfcb->Ptdb() != ptdbNil )
		{
		Assert( !pfcb->FTypeSentinel() );

		pfcb->EnterDDL();
		pfcb->SetTableclass( TABLECLASS( ( grbit & JET_bitTableClassMask ) / JET_bitTableClass1 ) );
		for ( FCB *pfcbT = pfcb->PfcbNextIndex(); pfcbT != pfcbNil; pfcbT = pfcbT->PfcbNextIndex() )
			{
			pfcbT->SetTableclass( pfcb->Tableclass() );
			}
		pfcb->LeaveDDL();
		}
	else
		{
		Assert( pfcb->FTypeSentinel() );
		Assert( pfcbNil == pfcb->PfcbNextIndex() );
		}
#endif  //  TABLES_PERF

	//	reset copy buffer
	//
	pfucb->pvWorkBuf = NULL;
	pfucb->dataWorkBuf.SetPv( NULL );
	Assert( !FFUCBUpdatePrepared( pfucb ) );

	//	reset key buffer
	//
	pfucb->dataSearchKey.Nullify();
	pfucb->cColumnsInSearchKey = 0;
	KSReset( pfucb );

	//	move currency to the first record and ignore error if no records
	//
	RECDeferMoveFirst( ppib, pfucb );

#ifdef DEBUG
	if ( pfcb->Ptdb() != ptdbNil )
		{
		Assert( !pfcb->FTypeSentinel() );
	
		pfcb->EnterDDL();
		for ( FCB *pfcbT = pfcb->PfcbNextIndex(); pfcbT != pfcbNil; pfcbT = pfcbT->PfcbNextIndex() )
			{
			Assert( pfcbT->PfcbTable() == pfcb );
			}
		pfcb->LeaveDDL();
		}
	else
		{
		Assert( pfcb->FTypeSentinel() );
		Assert( pfcbNil == pfcb->PfcbNextIndex() );
		}
#endif

	Assert( !fInTransaction );
	AssertDIRNoLatch( ppib );
	*ppfucb = pfucb;

	//	Be sure to return the error from ErrFILEICheckAndSetMode()
	CallSx( err, JET_wrnTableInUseBySystem );
	return err;

HandleError:
	Assert( pfucbNil != pfucb || !fInitialisedCursor );
	if ( pfucbNil != pfucb )
		{
		if ( fInitialisedCursor )
			{
			CallS( ErrFILECloseTable( ppib, pfucb ) );
			}
		else
			{
			DIRClose( pfucb );
			}
		}

	if ( fInTransaction )
		{
		CallSx( ErrDIRRollback( ppib ), JET_errRollbackError );
		}
	AssertDIRNoLatch( ppib );

	return err;
	}


ERR VTAPI ErrIsamCloseTable( JET_SESID sesid, JET_VTID vtid )
	{
 	PIB *ppib	= reinterpret_cast<PIB *>( sesid );
	FUCB *pfucb = reinterpret_cast<FUCB *>( vtid );

	ERR		err;

	CallR( ErrPIBCheck( ppib ) );
	CheckTable( ppib, pfucb );

	Assert( pfucb->pvtfndef == &vtfndefIsam );

	//	reset pfucb which was exported as tableid
	//	 
	pfucb->pvtfndef = &vtfndefInvalidTableid;
	err = ErrFILECloseTable( ppib, pfucb );
	return err;
	}


//+API
//	ErrFILECloseTable
//	========================================================================
//	ErrFILECloseTable( PIB *ppib, FUCB *pfucb )
//
//	Closes the FUCB of a data file, previously opened using FILEOpen.
//	Also closes the current secondary index, if any.
//
//	PARAMETERS	ppib	PIB of this user
//				pfucb	FUCB of file to close
//
//	RETURNS		JET_errSuccess
//				or lower level errors
//
//	SEE ALSO 	ErrFILEOpenTable
//-
ERR ErrFILECloseTable( PIB *ppib, FUCB *pfucb )
	{
	CheckPIB( ppib );
	CheckTable( ppib, pfucb );
	Assert( pfucb->pvtfndef == &vtfndefInvalidTableid );

	if ( FFUCBUpdatePrepared( pfucb ) )
		{
		CallS( ErrIsamPrepareUpdate( ppib, pfucb, JET_prepCancel ) );
		}
	Assert( !FFUCBUpdatePrepared( pfucb ) );

	//  reset the index-range in case this cursor
	//  is used for a rollback
	DIRResetIndexRange( pfucb );
	
	//	release working buffer and search key
	//
	RECIFreeCopyBuffer( pfucb );

	RECReleaseKeySearchBuffer( pfucb );

	//	detach, close and free index FUCB, if any
	//
	if ( pfucb->pfucbCurIndex != pfucbNil )
		{
		DIRClose( pfucb->pfucbCurIndex );
		pfucb->pfucbCurIndex = pfucbNil;
		}

	//	if closing a temporary table, free resources if
	//	last one to close.
	//
	if ( pfucb->u.pfcb->FTypeTemporaryTable() )
		{
		FCB		*pfcb = pfucb->u.pfcb;
		INT		wRefCnt;
		FUCB	*pfucbT;

		Assert( rgfmp[ pfcb->Ifmp() ].Dbid() == dbidTemp );
		Assert( pfcb->Ptdb() != ptdbNil );
		Assert( pfcb->FFixedDDL() );
		DIRClose( pfucb );

		//	We may have deferred close cursors on the temporary table.
		//	If one or more cursors are open, then temporary table
		//	should not be deleted.
		//
		pfucbT = ppib->pfucbOfSession;
		wRefCnt = pfcb->WRefCount();
		while ( wRefCnt > 0 && pfucbT != pfucbNil )
			{
			Assert( pfucbT->ppib == ppib );	// We should be the only one with access to the temp. table.
			if ( pfucbT->u.pfcb == pfcb )
				{
				if ( !FFUCBDeferClosed( pfucbT ) )
					{
					break;
					}
				Assert( wRefCnt > 0 );
				wRefCnt--;
				}

			pfucbT = pfucbT->pfucbNextOfSession;
			}
		Assert( wRefCnt >= 0 );
		if ( wRefCnt == 0 )
			{
			Assert( ppibNil != ppib );
			
			// Shouldn't be any index FDP's to free, since we don't
			// currently support secondary indexes on temp. tables.
			Assert( pfcb->PfcbNextIndex() == pfcbNil );

			// We nullify temp table RCEs at commit time so there should be 
			// no RCEs on the FCBs except uncommitted ones
			
			Assert( pfcb->Ptdb() != ptdbNil );
			FCB	* const pfcbLV = pfcb->Ptdb()->PfcbLV();
			if ( pfcbNil != pfcbLV )
				{
				Assert( pfcbLV->PrceNewest() == prceNil || pfcbLV->PrceNewest()->TrxCommitted() == trxMax );
				Assert( pfcbLV->PrceOldest() == prceNil || pfcbLV->PrceOldest()->TrxCommitted() == trxMax );
				VERNullifyAllVersionsOnFCB( pfcbLV );
				FUCBCloseAllCursorsOnFCB( ppib, pfcbLV );
				
				Assert( !pfcbLV->FDeleteCommitted() );
				pfcbLV->SetDeleteCommitted();

				pfcbLV->PrepareForPurge( fFalse );
				}

			Assert( pfcb->PrceNewest() == prceNil || pfcb->PrceNewest()->TrxCommitted() == trxMax  );
			Assert( pfcb->PrceOldest() == prceNil || pfcb->PrceOldest()->TrxCommitted() == trxMax  );
			VERNullifyAllVersionsOnFCB( pfcb );
			FUCBCloseAllCursorsOnFCB( ppib, pfcb );
				
			Assert( !pfcb->FDeleteCommitted() );
			pfcb->SetDeleteCommitted();

			//	prepare the FCB to be purged
			//	this removes the FCB from the hash-table among other things
			//		so that the following case cannot happen:
			//			we free the space for this FCb
			//			someone else allocates it
			//			someone else BTOpen's the space
			//			we try to purge the table and find that the refcnt
			//				is not zero and the state of the FCB says it is
			//				currently in use! 
			//			result --> CONCURRENCY HOLE

			pfcb->PrepareForPurge( fFalse );

			//	if fail to delete temporary table, then lose space until
			//	termination.  Temporary database is deleted on termination
			//	and space is reclaimed.  This error should be rare, and
			//	can be caused by resource failure.
			
			// Under most circumstances, this should not fail.  Since we check
			// the RefCnt beforehand, we should never fail with JET_errTableLocked
			// or JET_errTableInUse.  If we do, it's indicative of a
			// concurrency problem.
			(VOID)ErrSPFreeFDP( ppib, pfcb, pgnoSystemRoot );

			pfcb->Purge();
			}
		return JET_errSuccess;
		}

	DIRClose( pfucb );
	return JET_errSuccess;
	}


ERR ErrFILEIInitializeFCB(
	PIB			*ppib,
	IFMP		ifmp,
	TDB			*ptdb,
	FCB			*pfcbNew,
	IDB			*pidb,
	BOOL		fPrimary,
	PGNO		pgnoFDP,
	ULONG_PTR	ul )	// Density of non-derived index, pfcbTemplateIndex if derived index
	{
	ERR		err = JET_errSuccess;

	Assert( pgnoFDP > pgnoSystemRoot );
	Assert( pgnoFDP <= pgnoSysMax );
	Assert( pfcbNew != pfcbNil );
	Assert( pfcbNew->Ifmp() == ifmp );
	Assert( pfcbNew->PgnoFDP() == pgnoFDP );

	Assert( pfcbNew->Ptdb() == ptdbNil );

	if ( fPrimary )
		{
		pfcbNew->SetPtdb( ptdb );
		pfcbNew->SetPrimaryIndex();
		Assert( !pfcbNew->FSequentialIndex() );
		if ( pidbNil == pidb )
			pfcbNew->SetSequentialIndex();
		}
	else
		{
		pfcbNew->SetTypeSecondaryIndex();
		}

	if  ( pidb != pidbNil && pidb->FDerivedIndex() )
		{
		FCB	*pfcbTemplateIndex = (FCB *)ul;

		Assert( pfcbTemplateIndex->FTemplateIndex() );
		Assert( pfcbTemplateIndex->Pidb() != pidbNil );
		Assert( pfcbTemplateIndex->Pidb()->FTemplateIndex() );
		pfcbNew->SetCbDensityFree( pfcbTemplateIndex->CbDensityFree() );
		pfcbNew->SetPidb( pfcbTemplateIndex->Pidb() );

		Assert( !pfcbNew->FTemplateIndex() );
		pfcbNew->SetDerivedIndex();
		}
	else
		{
		Assert( ul >= ulFILEDensityLeast );
		Assert( ul <= ulFILEDensityMost );
		Assert( ((( 100 - ul ) << g_shfCbPage ) / 100) < g_cbPage );
		pfcbNew->SetCbDensityFree( (SHORT)( ( ( 100 - ul ) << g_shfCbPage ) / 100 ) );

		Assert( pidb != pidbNil || fPrimary );
		if ( pidb != pidbNil )
			{
			if ( pidb->FTemplateIndex() )
				pfcbNew->SetTemplateIndex();
			Call( ErrFILEIGenerateIDB( pfcbNew, ptdb, pidb ) );
			}
		}

	Assert( err >= 0 );
	return err;
	
HandleError:	
	Assert( err < 0 );
	Assert( pfcbNew->Pidb() == pidbNil );		// Verify IDB not allocated.
	return err;
	}


INLINE VOID RECIForceTaggedColumnsAsDerived(
	const TDB			* const ptdb,
	DATA&				dataDefault )
	{
	TAGFIELDS			tagfields( dataDefault );
	tagfields.ForceAllColumnsAsDerived();
	tagfields.AssertValid( ptdb );
	}

// To build a default record, we need a fake FUCB and FCB for RECSetColumn().
// We also need to allocate a temporary buffer in which to store the default
// record.
VOID FILEPrepareDefaultRecord( FUCB *pfucbFake, FCB *pfcbFake, TDB *ptdb )
	{
	Assert( ptdbNil != ptdb );
	pfcbFake->SetPtdb( ptdb );			// Attach a real TDB and a fake FCB.
	pfucbFake->u.pfcb = pfcbFake;
	FUCBSetIndex( pfucbFake );

	pfcbFake->ResetFlags();
	pfcbFake->SetTypeTable();			// Ensures SetColumn doesn't need crit. sect.
	pfcbFake->SetFixedDDL();

	pfucbFake->pvWorkBuf = NULL;
	RECIAllocCopyBuffer( pfucbFake );

	if ( pfcbNil != ptdb->PfcbTemplateTable() )
		{
		ptdb->AssertValidDerivedTable();
		pfcbFake->SetDerivedTable();

		const TDB	* const ptdbTemplate = ptdb->PfcbTemplateTable()->Ptdb();

		// If template table exists, use its default record.
		Assert( ptdbTemplate != ptdbNil );
		Assert( NULL != ptdbTemplate->PdataDefaultRecord() );
		ptdbTemplate->PdataDefaultRecord()->CopyInto( pfucbFake->dataWorkBuf );

		//	update derived bit of all tagged columns
		RECIForceTaggedColumnsAsDerived( ptdb, pfucbFake->dataWorkBuf );
		}
	else
		{
		if ( ptdb->FTemplateTable() )
			{
			ptdb->AssertValidTemplateTable();
			pfcbFake->SetTemplateTable();
			}

		// Start with an empty record.
		REC::SetMinimumRecord( pfucbFake->dataWorkBuf );
		}
	}


LOCAL ERR ErrFILERebuildOneDefaultValue(
	FUCB			* pfucbFake,
	const COLUMNID	columnid,
	const COLUMNID	columnidToAdd,
	const DATA		* const pdataDefaultToAdd )
	{
	ERR				err;
	DATA			dataDefaultValue;

	if ( columnid == columnidToAdd )
		{
		Assert( pdataDefaultToAdd );
		dataDefaultValue = *pdataDefaultToAdd;
		}
	else
		{
		CallR( ErrRECIRetrieveDefaultValue(
						pfucbFake->u.pfcb,
						columnid,
						&dataDefaultValue ) );

		Assert( JET_wrnColumnNull != err );
		Assert( wrnRECUserDefinedDefault != err );
		Assert( wrnRECSeparatedSLV != err );
		Assert( wrnRECIntrinsicSLV != err );
		Assert( wrnRECSeparatedLV != err );

		Assert( wrnRECLongField != err );
		}

	Assert( dataDefaultValue.Pv() != NULL );
	Assert( dataDefaultValue.Cb() > 0 );
	CallR( ErrRECSetDefaultValue(
				pfucbFake,
				columnid,
				dataDefaultValue.Pv(),
				dataDefaultValue.Cb() ) );

	return err;
	}

ERR ErrFILERebuildDefaultRec(
	FUCB			* pfucbFake,
	const COLUMNID	columnidToAdd,
	const DATA		* const pdataDefaultToAdd )
	{
	ERR				err		= JET_errSuccess;
	TDB				* ptdb	= pfucbFake->u.pfcb->Ptdb();
	VOID			*pv		= NULL;
	FID				fid;

	Assert( ptdbNil != ptdb );

	for ( fid = ptdb->FidFixedFirst(); ;fid++ )
		{
		if ( ptdb->FidFixedLast() + 1 == fid )
			fid = ptdb->FidVarFirst();
		if ( ptdb->FidVarLast() + 1 == fid )
			fid = ptdb->FidTaggedFirst();
		if ( fid > ptdb->FidTaggedLast() )
			break;

		Assert( ( fid >= ptdb->FidFixedFirst() && fid <= ptdb->FidFixedLast() )
			|| ( fid >= ptdb->FidVarFirst() && fid <= ptdb->FidVarLast() )
			|| ( fid >= ptdb->FidTaggedFirst() && fid <= ptdb->FidTaggedLast() ) );

		const COLUMNID	columnid		= ColumnidOfFid( fid, ptdb->FTemplateTable() );
		const FIELD		* const pfield	= ptdb->Pfield( columnid );
		if ( FFIELDDefault( pfield->ffield )
			&& !FFIELDUserDefinedDefault( pfield->ffield )
			&& !FFIELDCommittedDelete( pfield->ffield ) )	//	make sure column not deleted
			{
			Assert( JET_coltypNil != pfield->coltyp );
			Call( ErrFILERebuildOneDefaultValue(
						pfucbFake,
						columnid,
						columnidToAdd,
						pdataDefaultToAdd ) );
			}
		}

	//	in case we have to chain together the buffers (to keep
	//	around copies of previous of old default records
	//	because other threads may have stale pointers),
	//	allocate a RECDANGLING buffer to preface the actual
	//	default record
	//
	RECDANGLING *	precdangling;

	precdangling = (RECDANGLING *)PvOSMemoryHeapAlloc( sizeof(RECDANGLING) + pfucbFake->dataWorkBuf.Cb() );
	if ( NULL == precdangling )
		{
		err = ErrERRCheck( JET_errOutOfMemory );
		goto HandleError;
		}

	precdangling->precdanglingNext = NULL;
	precdangling->data.SetPv( (BYTE *)precdangling + sizeof(RECDANGLING) );
	pfucbFake->dataWorkBuf.CopyInto( precdangling->data );
	ptdb->SetPdataDefaultRecord( &( precdangling->data ) );

HandleError:
	return err;
	}


//	combines all index column masks into a single per table
//	index mask, used for index update check skip.
//
VOID FILESetAllIndexMask( FCB *pfcbTable )
	{
	FCB		*pfcbT;
	LONG	*plMax;
	LONG	*plAll;
	LONG	*plIndex;
	TDB		*ptdb = pfcbTable->Ptdb();

	//	initialize variables
	//
	Assert( ptdb != ptdbNil );
	plMax = (LONG *)ptdb->RgbitAllIndex() + ( cbRgbitIndex / sizeof(LONG) );

	//	initialize mask to primary index, or to 0s for sequential file.
	//
	if ( pfcbTable->Pidb() != pidbNil )
		{
		ptdb->SetRgbitAllIndex( pfcbTable->Pidb()->RgbitIdx() );
		}
	else
		{
		ptdb->ResetRgbitAllIndex();
		}

	//	for each secondary index, combine index mask with all index
	//	mask.  Also, combine has tagged flag.
	//
	for ( pfcbT = pfcbTable->PfcbNextIndex();
		pfcbT != pfcbNil;
		pfcbT = pfcbT->PfcbNextIndex() )
		{
		Assert( pfcbT->Pidb() != pidbNil );

		// Only process non-deleted indexes (or deleted but versioned).
		if ( !pfcbT->Pidb()->FDeleted() || pfcbT->Pidb()->FVersioned() )
			{
			plAll = (LONG *)ptdb->RgbitAllIndex();
			plIndex = (LONG *)pfcbT->Pidb()->RgbitIdx();
			for ( ; plAll < plMax; plAll++, plIndex++ )
				{
				*plAll |= *plIndex;
				}
			}
		}

	return;
	}

ERR ErrIDBSetIdxSeg(
	IDB				* const pidb,
	TDB				* const ptdb,
	const IDXSEG	* const rgidxseg )
	{
	ERR				err;

	if ( pidb->FIsRgidxsegInMempool() )
		{
		USHORT	itag;

		// Array is too big to fit into IDB, so put into TDB's byte pool instead.
		CallR( ptdb->MemPool().ErrAddEntry(
				(BYTE *)rgidxseg,
				pidb->Cidxseg() * sizeof(IDXSEG),
				&itag ) );

		pidb->SetItagRgidxseg( itag );
		}
	else
		{
		UtilMemCpy( pidb->rgidxseg, rgidxseg, pidb->Cidxseg() * sizeof(IDXSEG) );
		err = JET_errSuccess;
		}

	return err;
	}
ERR ErrIDBSetIdxSegConditional(
	IDB				* const pidb,
	TDB				* const ptdb,
	const IDXSEG 	* const rgidxseg )
	{
	ERR		err;

	if ( pidb->FIsRgidxsegConditionalInMempool() )
		{
		USHORT	itag;

		// Array is too big to fit into IDB, so put into TDB's byte pool instead.
		CallR( ptdb->MemPool().ErrAddEntry(
				(BYTE *)rgidxseg,
				pidb->CidxsegConditional() * sizeof(IDXSEG),
				&itag ) );
		pidb->SetItagRgidxsegConditional( itag );
		}
	else
		{
		UtilMemCpy( pidb->rgidxsegConditional, rgidxseg, pidb->CidxsegConditional() * sizeof(IDXSEG) );
		err = JET_errSuccess;
		}

	return err;
	}

ERR ErrIDBSetIdxSeg(
	IDB			* const pidb,
	TDB			* const ptdb,
	const BOOL	fConditional,
	const		LE_IDXSEG* const le_rgidxseg )
	{
	IDXSEG		rgidxseg[JET_ccolKeyMost];
	const ULONG	cidxseg		= ( fConditional ? pidb->CidxsegConditional() : pidb->Cidxseg() );

	if ( 0 == cidxseg )
		{
		Assert( fConditional );
		return JET_errSuccess;
		}

	//	If it is on little endian machine, we still copy it into
	//	the stack array which is aligned.
	//	If it is on big endian machine, we always need to convert first.
	
	for ( UINT iidxseg = 0; iidxseg < cidxseg; iidxseg++ )
		{
		//	Endian conversion
		rgidxseg[ iidxseg ] = (LE_IDXSEG &) le_rgidxseg[iidxseg];
		Assert( FCOLUMNIDValid( rgidxseg[iidxseg].Columnid() ) );
		}

	return ( fConditional ?
				ErrIDBSetIdxSegConditional( pidb, ptdb, rgidxseg ) :
				ErrIDBSetIdxSeg( pidb, ptdb, rgidxseg ) );
	}

VOID SetIdxSegFromOldFormat(
	const UnalignedLittleEndian< IDXSEG_OLD >	* const le_rgidxseg,
	IDXSEG			* const rgidxseg,
	const ULONG		cidxseg,
	const BOOL		fConditional,
	const BOOL		fTemplateTable,
	const TCIB		* const ptcibTemplateTable )
	{
	FID				fid;

	for ( UINT iidxseg = 0; iidxseg < cidxseg; iidxseg++ )
		{
		rgidxseg[iidxseg].ResetFlags();
///		rgidxseg[iidxseg].SetFOldFormat();

		if ( le_rgidxseg[iidxseg] < 0 )
			{
			if ( fConditional )
				{
				rgidxseg[iidxseg].SetFMustBeNull();
				}
			else
				{
				rgidxseg[iidxseg].SetFDescending();
				}
			fid = FID( -le_rgidxseg[iidxseg] );
			}
		else
			{
			fid = le_rgidxseg[iidxseg];
			}

		if ( NULL != ptcibTemplateTable )
			{
			Assert( !fTemplateTable );

			//	WARNING: the fidLast's were set based on what was found
			//	in the derived table, so if any are equal to fidLeast-1,
			//	it actually means there were no columns in the derived
			//	table and hence the column must belong to the template
			if ( FTaggedFid( fid ) )
				{
				if ( fidTaggedLeast-1 == ptcibTemplateTable->fidTaggedLast
					|| fid <= ptcibTemplateTable->fidTaggedLast )
					rgidxseg[iidxseg].SetFTemplateColumn();
				}
			else if ( FFixedFid( fid ) )
				{
				if ( fidFixedLeast-1 == ptcibTemplateTable->fidFixedLast
					|| fid <= ptcibTemplateTable->fidFixedLast )
					rgidxseg[iidxseg].SetFTemplateColumn();
				}
			else
				{
				Assert( FVarFid( fid ) );
				if ( fidVarLeast-1 == ptcibTemplateTable->fidVarLast
					|| fid <= ptcibTemplateTable->fidVarLast )
					rgidxseg[iidxseg].SetFTemplateColumn();
				}
			}

		else if ( fTemplateTable )
			{
			Assert( NULL == ptcibTemplateTable );
			Assert( !rgidxseg[iidxseg].FTemplateColumn() );
			rgidxseg[iidxseg].SetFTemplateColumn();
			}
		
		rgidxseg[iidxseg].SetFid( fid );
		Assert( FCOLUMNIDValid( rgidxseg[iidxseg].Columnid() ) );
		}
	}

ERR ErrIDBSetIdxSegFromOldFormat(
	IDB 		* const pidb,
	TDB			* const ptdb,
	const BOOL	fConditional,
	const UnalignedLittleEndian< IDXSEG_OLD >	* const le_rgidxseg )
	{
	IDXSEG		rgidxseg[JET_ccolKeyMost];
	const ULONG	cidxseg						= ( fConditional ? pidb->CidxsegConditional() : pidb->Cidxseg() );
	TCIB		tcibTemplateTable			= { FID( ptdb->FidFixedFirst()-1 ),
												FID( ptdb->FidVarFirst()-1 ),
												FID( ptdb->FidTaggedFirst()-1 ) };
#ifdef DEBUG
	if ( ptdb->FDerivedTable() )
		{
		Assert( ptdb->FESE97DerivedTable() );
		ptdb->AssertValidDerivedTable();
		}
	else if ( ptdb->FTemplateTable() )
		{
		Assert( ptdb->FESE97TemplateTable() );
		ptdb->AssertValidTemplateTable();
		}
#endif		

	if ( 0 == cidxseg )
		{
		Assert( fConditional );
		return JET_errSuccess;
		}

	SetIdxSegFromOldFormat(
			le_rgidxseg,
			rgidxseg,
			cidxseg,
			fConditional,
			ptdb->FTemplateTable(),
			( ptdb->FDerivedTable() ? &tcibTemplateTable : NULL ) );

	return ( fConditional ?
				ErrIDBSetIdxSegConditional( pidb, ptdb, rgidxseg ) :
				ErrIDBSetIdxSeg( pidb, ptdb, rgidxseg ) );
	}


const IDXSEG* PidxsegIDBGetIdxSeg( const IDB * const pidb, const TDB * const ptdb )
	{
	const IDXSEG* pidxseg;

	if ( pidb->FTemplateIndex() )
		{
		if ( pfcbNil != ptdb->PfcbTemplateTable() )
			{
			// Must retrieve from the template table's TDB.
			ptdb->AssertValidDerivedTable();
			pidxseg = PidxsegIDBGetIdxSeg( pidb, ptdb->PfcbTemplateTable()->Ptdb() );
			return pidxseg;
			}

		// If marked as a template index, but pfcbTemplateTable is NULL,
		// then this must already be the TDB for the template table.
		}
	
	if ( pidb->FIsRgidxsegInMempool() )
		{
		Assert( pidb->ItagRgidxseg() != 0 );
		Assert( ptdb->MemPool().CbGetEntry( pidb->ItagRgidxseg() ) == pidb->Cidxseg() * sizeof(IDXSEG) );
		pidxseg = (IDXSEG*)ptdb->MemPool().PbGetEntry( pidb->ItagRgidxseg() );
		}
	else
		{
		Assert( pidb->Cidxseg() > 0 );		// Must be at least one segment.
		pidxseg = pidb->rgidxseg;
		}

	return pidxseg;
	}

const IDXSEG* PidxsegIDBGetIdxSegConditional( const IDB * const pidb, const TDB * const ptdb )
	{
	const IDXSEG* pidxseg;

	if ( pidb->FTemplateIndex() )
		{
		if ( pfcbNil != ptdb->PfcbTemplateTable() )
			{
			// Must retrieve from the template table's TDB.
			ptdb->AssertValidDerivedTable();
			pidxseg = PidxsegIDBGetIdxSegConditional( pidb, ptdb->PfcbTemplateTable()->Ptdb() );
			return pidxseg;
			}

		// If marked as a template index, but pfcbTemplateTable is NULL,
		// then this must already be the TDB for the template table.
		}
	
	if ( pidb->FIsRgidxsegConditionalInMempool() )
		{
		Assert( pidb->ItagRgidxsegConditional() != 0 );
		Assert( ptdb->MemPool().CbGetEntry( pidb->ItagRgidxsegConditional() ) == pidb->CidxsegConditional() * sizeof(IDXSEG) );
		pidxseg = (IDXSEG*)ptdb->MemPool().PbGetEntry( pidb->ItagRgidxsegConditional() );
		}
	else
		{
		pidxseg = pidb->rgidxsegConditional;
		}

	return pidxseg;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ese98\src\ese\fucb.cxx ===
#include "std.hxx"


#ifdef DEBUG
BOOL FFUCBValidTableid( const JET_SESID sesid, const JET_TABLEID tableid )
	{
	const INST	*pinst		= PinstFromPpib( (PIB *)sesid );
	const FUCB	*pfucb		= (FUCB *)tableid;
	const FUCB	*pfucbMin	= PfucbMEMMin( pinst );

	// Validate that pfucb is in the global FUCB pool
	return (	( pfucb >= pfucbMin ) &&
				( pfucb < PfucbMEMMax( pinst ) ) &&
				( ( ( (BYTE *)pfucb - (BYTE *)pfucbMin ) % sizeof( FUCB ) ) == 0 ) );
	}
#endif

//+api
//	ErrFUCBOpen
//	------------------------------------------------------------------------
//	ERR ErrFUCBOpen( PIB *ppib, IFMP ifmp, FUCB **ppfucb );
//
//	Creates an open FUCB. At this point, no FCB is assigned yet.
//
//	PARAMETERS	ppib	PIB of this user
//				ifmp	Database Id
//				ppfucb	Address of pointer to FUCB.	 If *ppfucb == NULL, 
//						an FUCB is allocated and **ppfucb is set to its
//						address.  Otherwise, *ppfucb is assumed to be
//						pointing at a closed FUCB, to be reused in the open.
//
//	RETURNS		JET_errSuccess if successful.
//					JET_errOutOfCursors
//
//	SIDE EFFECTS	links the newly opened FUCB into the chain of open FUCBs
//					for this session.
//
//	SEE ALSO		ErrFUCBClose
//-
ERR ErrFUCBOpen( PIB *ppib, IFMP ifmp, FUCB **ppfucb, const LEVEL level )
	{
	ERR err;
	FUCB *pfucb;

	Assert( ppfucb );
	Assert( pfucbNil == *ppfucb );

	//	if no fucb allocate new fucb and initialize it
	//	and allocate csr
	//
	pfucb = PfucbMEMAlloc( PinstFromPpib( ppib ) );
	if ( pfucb == pfucbNil )
		{
		err = ErrERRCheck( JET_errOutOfCursors );
		return err;
		}
		
	Assert( FAlignedForAllPlatforms( pfucb ) );

	//	memset implicitly clears pointer cache
	//
#ifdef DEBUG
	BYTE	chFill[sizeof(UINT_PTR)];
	memset( chFill, chCRESAllocFill, sizeof(UINT_PTR) );
	Assert( 0 == memcmp( chFill, &pfucb->pfucbNextOfSession, sizeof(UINT_PTR) ) );
#endif	

	memset( (BYTE *)pfucb, 0, sizeof( FUCB ) );

	pfucb->pvtfndef = &vtfndefInvalidTableid;	// invalide dispatch table.

	Assert( !FFUCBUpdatable( pfucb ) );
	if ( !rgfmp[ ifmp ].FReadOnlyAttach() )
		{
		FUCBSetUpdatable( pfucb );
		}

	//	set ppib and ifmp
	//
	pfucb->ifmp = ifmp;
	pfucb->ppib = ppib;

	pfucb->ls = JET_LSNil;

	//	initialize CSR in fucb
	//	this allocates page structure
	//
	new( Pcsr( pfucb ) ) CSR;

	// If level is non-zero, this indicates we're opening the FUCB via a proxy
	// (ie. concurrent CreateIndex).
	if ( level > 0 )
		{
		// If opening by proxy, then proxy should already have obtained critTrx.
		Assert( ppib->critTrx.FOwner() );
		pfucb->levelOpen = level;
		
		// Must have these flags set BEFORE linking into session list to
		// ensure rollback doesn't close the FUCB prematurely.
		FUCBSetIndex( pfucb );
		FUCBSetSecondary( pfucb );
		}
	else
		{
		pfucb->levelOpen = ppib->level;
		}
		
	//	link new FUCB into user chain, only when success is sure
	//	as unlinking NOT handled in error
	//
	*ppfucb = pfucb;
		
	//	link the fucb now
	//
	//	NOTE: The only concurrency involved is when concurrent create
	//	index must create an FUCB for the session.  This is always
	//	at the head of the FUCB list.  Note that the concurrent create
	//	index thread doesn't remove the FUCB from the session list, 
	//	except on error.  The original session will normally close the
	//	FUCB created by proxy.
	//	So, only need a mutex wherever the head of the list is modified
	//	or if scanning and we want to look at secondary index FUCBs.
	ppib->critCursors.Enter();
	pfucb->pfucbNextOfSession = ( FUCB * )ppib->pfucbOfSession;
	ppib->pfucbOfSession = pfucb;
	ppib->critCursors.Leave();
		
	return JET_errSuccess;
	}


//+api
//	FUCBClose
//	------------------------------------------------------------------------
//	FUCBClose( FUCB *pfucb )
//
//	Closes an active FUCB, optionally returning it to the free FUCB pool.
//	All the pfucb->pcsr are freed.
//
//	PARAMETERS		pfucb		FUCB to close.	Should be open. pfucb->ssib should
//									hold no page.
//
//	SIDE EFFECTS	Unlinks the closed FUCB from the FUCB chain of its
//					   associated PIB and FCB.
//
//	SEE ALSO		ErrFUCBOpen
//-
VOID FUCBClose( FUCB *pfucb )
	{
	FUCB		*pfucbPrev;
	PIB			*ppib = pfucb->ppib;

	Assert( pfcbNil == pfucb->u.pfcb );
	
	//	free CSR
	//
	Assert( !Pcsr( pfucb )->FLatched() );
//	delete( &Pcsr( pfucb )->Cpage() );

	// Current secondary index should already have been closed.
	Assert( !FFUCBCurrentSecondary( pfucb ) );

	//	bookmark should have already been released
	//
	Assert( NULL == pfucb->pvBMBuffer );
	Assert( NULL == pfucb->pvRCEBuffer );
	Assert( 0 == pfucb->cbBMBuffer );
	
	ppib->critCursors.Enter();
	
	//	locate the pfucb in this thread and take it out of the fucb list
	//
	pfucbPrev = (FUCB *)( (BYTE *)&ppib->pfucbOfSession - (BYTE *)&( (FUCB *)0 )->pfucbNextOfSession );
	while ( pfucbPrev->pfucbNextOfSession != pfucb )
		{
		pfucbPrev = pfucbPrev->pfucbNextOfSession;
		Assert( pfucbPrev != pfucbNil );
		}
	pfucbPrev->pfucbNextOfSession = pfucb->pfucbNextOfSession;

	//	set ppibNil to detect bogus reusage.
	//
#ifdef DEBUG
	pfucb->ppib = ppibNil;
#endif

	ppib->critCursors.Leave();
	
	//	release key buffer if one was allocated.
	//
	RECReleaseKeySearchBuffer( pfucb );

	// release the fucb
	//
	pfucb->pvtfndef = &vtfndefInvalidTableid;	// invalide dispatch table.

	if ( JET_LSNil != pfucb->ls )
		{
		JET_CALLBACK	pfn		= PinstFromPpib( ppib )->m_pfnRuntimeCallback;

		Assert( NULL != pfn );
		(*pfn)(
			JET_sesidNil,
			JET_dbidNil,
			JET_tableidNil,
			JET_cbtypFreeCursorLS,
			(VOID *)pfucb->ls,
			NULL,
			NULL,
			NULL );
		}
	
	MEMReleasePfucb( PinstFromPpib( ppib ), pfucb );

	return;
	}


VOID FUCBCloseAllCursorsOnFCB(
	PIB			* const ppib,	// pass ppibNil when closing cursors because we're terminating
	FCB			* const pfcb )
	{
	while( pfcb->Pfucb() )
		{
		FUCB * const pfucbT = pfcb->Pfucb();

		// This function only called for temp. tables, for
		// table being rolled back, or when purging database (in
		// which case ppib is ppibNil), so no other session should
		// have open cursor on it.
		Assert( pfucbT->ppib == ppib || ppibNil == ppib );
		if ( ppibNil == ppib )
			{
			// If terminating, may have to manually clean up some FUCB resources.
			RECReleaseKeySearchBuffer( pfucbT );
			FILEReleaseCurrentSecondary( pfucbT );
			BTReleaseBM( pfucbT );
			RECIFreeCopyBuffer( pfucbT );
			}
		
		Assert( pfucbT->u.pfcb == pfcb );

		//	unlink the FCB without moving it to the avail LRU list because
		//		we will be synchronously purging the FCB shortly
		
		FCBUnlinkWithoutMoveToAvailList( pfucbT );

		//	close the FUCB

		FUCBClose( pfucbT );
		}
	Assert( pfcb->WRefCount() == 0 );
	}


VOID FUCBSetIndexRange( FUCB *pfucb, JET_GRBIT grbit )
	{
	//	set limstat
	//  also set the preread flags
	
	FUCBResetPreread( pfucb );
	FUCBSetLimstat( pfucb );
	if ( grbit & JET_bitRangeUpperLimit )
		{
		FUCBSetPrereadForward( pfucb, cpgPrereadSequential );
		FUCBSetUpper( pfucb );
		}
	else
		{
		FUCBSetPrereadBackward( pfucb, cpgPrereadSequential );
		FUCBResetUpper( pfucb );
		}
	if ( grbit & JET_bitRangeInclusive )
		{
		FUCBSetInclusive( pfucb );
		}
	else
		{
		FUCBResetInclusive( pfucb );
		}

	return;
	}


VOID FUCBResetIndexRange( FUCB *pfucb )
	{
	if ( pfucb->pfucbCurIndex )
		{
		FUCBResetLimstat( pfucb->pfucbCurIndex );
		FUCBResetPreread( pfucb->pfucbCurIndex );
		}

	FUCBResetLimstat( pfucb );
	FUCBResetPreread( pfucb );
	}


INLINE INT CmpPartialKeyKey( const KEY& key1, const KEY& key2 )
	{
	INT		cmp;

	if ( key1.FNull() || key2.FNull() )
		{
		cmp = key1.Cb() - key2.Cb();
		}
	else
		{
		cmp = CmpKey( key1, key2 );
		}

	return cmp;
	}

ERR ErrFUCBCheckIndexRange( FUCB *pfucb, const KEY& key )
	{
	KEY		keyLimit;

	FUCBAssertValidSearchKey( pfucb );
	keyLimit.prefix.Nullify();
	keyLimit.suffix.SetPv( pfucb->dataSearchKey.Pv() );
	keyLimit.suffix.SetCb( pfucb->dataSearchKey.Cb() );
	
	const INT	cmp				= CmpPartialKeyKey( key, keyLimit );
	BOOL		fOutOfRange;

	if ( cmp > 0 )
		{
		fOutOfRange = FFUCBUpper( pfucb );
		}
	else if ( cmp < 0 )
		{
		fOutOfRange = !FFUCBUpper( pfucb );
		}
	else
		{
		fOutOfRange = !FFUCBInclusive( pfucb );
		}

	ERR		err;
	if ( fOutOfRange )
		{
		FUCBResetLimstat( pfucb );
		FUCBResetPreread( pfucb );
		err = ErrERRCheck( JET_errNoCurrentRecord );
		}
	else
		{
		err = JET_errSuccess;
		}

	return err;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ese98\src\ese\info.cxx ===
#include "std.hxx"


/*	local data types
/**/

typedef struct						/* returned by INFOGetTableColumnInfo */
	{
	JET_COLUMNID	columnid;
	JET_COLTYP		coltyp;
	USHORT			wCountry;
	LANGID			langid;
	USHORT			cp;
	USHORT			wCollate;
	ULONG			cbMax;
	JET_GRBIT		grbit;
	ULONG			cbDefault;
	BYTE			*pbDefault;
	CHAR			szName[JET_cbNameMost + 1];
	} INFOCOLUMNDEF;


/* Static data for ErrIsamGetObjectInfo */

CODECONST( JET_COLUMNDEF ) rgcolumndefGetObjectInfo[] =
	{
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypText, 0, 0, 0, 0, 0, JET_bitColumnTTKey },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypText, 0, 0, 0, 0, 0, JET_bitColumnTTKey },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypLong, 0, 0, 0, 0, 0, JET_bitColumnFixed },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypDateTime, 0, 0, 0, 0, 0, JET_bitColumnFixed },	//  XXX -- to be deleted
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypDateTime, 0, 0, 0, 0, 0, JET_bitColumnFixed },	//  XXX -- to be deleted
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypLong, 0, 0, 0, 0, 0, JET_bitColumnFixed },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypLong, 0, 0, 0, 0, 0, JET_bitColumnFixed },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypLong, 0, 0, 0, 0, 0, JET_bitColumnFixed },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypLong, 0, 0, 0, 0, 0, JET_bitColumnFixed }
	};

const ULONG ccolumndefGetObjectInfoMax	= ( sizeof(rgcolumndefGetObjectInfo) / sizeof(JET_COLUMNDEF) );

/* column indexes for rgcolumndefGetObjectInfo */
#define iContainerName		0
#define iObjectName			1
#define iObjectType			2
//  #define iDtCreate			3	//  XXX -- to be deleted
//  #define iDtUpdate			4	//  XXX -- to be deleted
#define iCRecord			5
#define iCPage				6
#define iGrbit				7
#define iFlags				8


/* static data for ErrIsamGetColumnInfo
/**/
CODECONST( JET_COLUMNDEF ) rgcolumndefGetColumnInfo[] =
	{
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypLong, 0, 0, 0, 0, 0, JET_bitColumnFixed | JET_bitColumnTTKey },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypText, 0, 0, 0, 0, 0, JET_bitColumnTTKey },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypLong, 0, 0, 0, 0, 0, JET_bitColumnFixed },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypLong, 0, 0, 0, 0, 0, JET_bitColumnFixed },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypShort, 0, 0, 0, 0, 0, JET_bitColumnFixed },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypShort, 0, 0, 0, 0, 0, JET_bitColumnFixed },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypShort, 0, 0, 0, 0, 0, JET_bitColumnFixed },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypShort, 0, 0, 0, 0, 0, JET_bitColumnFixed },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypLong, 0, 0, 0, 0, 0, JET_bitColumnFixed },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypLong, 0, 0, 0, 0, 0, JET_bitColumnFixed },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypLongBinary, 0, 0, 0, 0, 0, 0 },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypText, 0, 0, 0, 0, 0, 0 },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypText, 0, 0, 0, 0, 0, 0 }
	};

CODECONST( JET_COLUMNDEF ) rgcolumndefGetColumnInfoCompact[] =
	{
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypLong, 0, 0, 0, 0, 0, JET_bitColumnFixed },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypText, 0, 0, 0, 0, 0, 0 },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypLong, 0, 0, 0, 0, 0, JET_bitColumnFixed },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypLong, 0, 0, 0, 0, 0, JET_bitColumnFixed },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypShort, 0, 0, 0, 0, 0, JET_bitColumnFixed },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypShort, 0, 0, 0, 0, 0, JET_bitColumnFixed },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypShort, 0, 0, 0, 0, 0, JET_bitColumnFixed },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypShort, 0, 0, 0, 0, 0, JET_bitColumnFixed },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypLong, 0, 0, 0, 0, 0, JET_bitColumnFixed },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypLong, 0, 0, 0, 0, 0, JET_bitColumnFixed },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypBinary, 0, 0, 0, 0, 0, 0 },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypText, 0, 0, 0, 0, 0, 0 },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypText, 0, 0, 0, 0, 0, 0 }
	};

const ULONG ccolumndefGetColumnInfoMax	= ( sizeof( rgcolumndefGetColumnInfo ) / sizeof( JET_COLUMNDEF ) );

#define iColumnPOrder		0
#define iColumnName			1
#define iColumnId  			2
#define iColumnType			3
#define iColumnCountry		4
#define iColumnLangid		5
#define iColumnCp			6
#define iColumnCollate		7
#define iColumnSize			8
#define iColumnGrbit  		9
#define iColumnDefault		10
#define iColumnTableName	11
#define iColumnColumnName	12


/*	static data for ErrIsamGetIndexInfo
/**/
CODECONST( JET_COLUMNDEF ) rgcolumndefGetIndexInfo[] =
	{
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypText, 0, 0, 0, 0, 0, JET_bitColumnTTKey },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypLong, 0, 0, 0, 0, 0, JET_bitColumnFixed },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypLong, 0, 0, 0, 0, 0, JET_bitColumnFixed },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypLong, 0, 0, 0, 0, 0, JET_bitColumnFixed },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypLong, 0, 0, 0, 0, 0, JET_bitColumnFixed },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypLong, 0, 0, 0, 0, 0, JET_bitColumnFixed },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypLong, 0, 0, 0, 0, 0, JET_bitColumnFixed | JET_bitColumnTTKey },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypLong, 0, 0, 0, 0, 0, JET_bitColumnFixed },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypLong, 0, 0, 0, 0, 0, JET_bitColumnFixed },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypShort, 0, 0, 0, 0, 0, JET_bitColumnFixed },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypShort, 0, 0, 0, 0, 0, JET_bitColumnFixed },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypShort, 0, 0, 0, 0, 0, JET_bitColumnFixed },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypShort, 0, 0, 0, 0, 0, JET_bitColumnFixed },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypLong, 0, 0, 0, 0, 0, JET_bitColumnFixed },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypText, 0, 0, 0, 0, 0, 0 },
	{ sizeof(JET_COLUMNDEF), 0, JET_coltypLong, 0, 0, 0, 0, 0, JET_bitColumnFixed }
	};

const ULONG ccolumndefGetIndexInfoMax	= ( sizeof( rgcolumndefGetIndexInfo ) / sizeof( JET_COLUMNDEF ) );

#define iIndexName			0
#define iIndexGrbit			1
#define iIndexCKey			2
#define iIndexCEntry		3
#define iIndexCPage			4
#define iIndexCCol			5
#define iIndexICol			6
#define iIndexColId			7
#define iIndexColType		8
#define iIndexCountry		9
#define iIndexLangid		10
#define iIndexCp			11
#define iIndexCollate		12
#define iIndexColBits		13
#define iIndexColName		14
#define iIndexLCMapFlags	15

extern const ULONG	cbIDXLISTNewMembersSinceOriginalFormat	= 4;	// for LCMapFlags


/*	internal function prototypes
/**/
/*=================================================================
INFOGetTableColumnInfo

Parameters:	pfucb				pointer to FUCB for table containing columns
			szColumnName		column name or NULL for next column
			pcolumndef			output buffer containing column info

Return Value: Column id of column found ( fidTaggedMost if none )

Errors/Warnings:

Side Effects:
=================================================================*/
LOCAL ERR ErrINFOGetTableColumnInfo(
	FUCB			*pfucb, 			/* FUCB for table containing columns */
	const CHAR		*szColumnName, 		/* column name */
	INFOCOLUMNDEF	*pcolumndef )	 	/* output buffer for column info */
	{
	ERR				err;
	FCB				*pfcb					= pfucb->u.pfcb;
	TDB				*ptdb					= pfcb->Ptdb();
	FCB				* const pfcbTemplate	= ptdb->PfcbTemplateTable();
	COLUMNID		columnidT;
	FIELD			*pfield					= pfieldNil;	/* first element of specific field type */
	JET_GRBIT 		grbit;					/* flags for the field */

	Assert( pcolumndef != NULL );

	Assert( szColumnName != NULL || pcolumndef->columnid != 0 );
	if ( szColumnName != NULL )
		{
		//	quick failure for empty column name
		if ( *szColumnName == '\0' )
			return ErrERRCheck( JET_errColumnNotFound );

		BOOL	fColumnWasDerived;
		CallR( ErrFILEGetPfieldAndEnterDML(
					pfucb->ppib,
					pfcb,
					szColumnName,
					&pfield,
					&columnidT,
					&fColumnWasDerived,
					fFalse ) );
		if ( fColumnWasDerived )
			{
			ptdb->AssertValidDerivedTable();

			Assert( FCOLUMNIDTemplateColumn( columnidT ) );
			pfcb = pfcbTemplate;
			ptdb = pfcbTemplate->Ptdb();
			pfcb->EnterDML();				//	to match LeaveDML() at the end of this function
			}
		else
			{
			//	if column was not derived, then this can't be a template
			//	column, unless we are querying the template table itself
			if ( FCOLUMNIDTemplateColumn( columnidT ) )
				{
				Assert( pfcb->FTemplateTable() );
				}
			else
				{
				Assert( !pfcb->FTemplateTable() );
				}
			}
		}
	else	// szColumnName == NULL
		{
		const FID	fid	= FidOfColumnid( pcolumndef->columnid );

		columnidT = pcolumndef->columnid;

		if ( FCOLUMNIDTemplateColumn( columnidT ) && !pfcb->FTemplateTable() )
			{
			pfcb->Ptdb()->AssertValidDerivedTable();
			
			// switch to template table
			pfcb = pfcbTemplate;
			Assert( pfcbNil != pfcb );
			Assert( pfcb->FTemplateTable() );
			
			ptdb = pfcbTemplate->Ptdb();
			Assert( ptdbNil != ptdb );
			}
			
		pfcb->EnterDML();

		//	special case of TDB::Pfield( fidT )
		pfield = pfieldNil;
		if ( FCOLUMNIDTagged( columnidT ) )
			{
			if ( fid >= ptdb->FidTaggedFirst() && fid <= ptdb->FidTaggedLast() )
				pfield = ptdb->PfieldTagged( columnidT );
			}
		else if ( FCOLUMNIDFixed( columnidT ) )
			{
			if ( fid >= ptdb->FidFixedFirst() && fid <= ptdb->FidFixedLast() )
				pfield = ptdb->PfieldFixed( columnidT );
			}
		else if ( FCOLUMNIDVar( columnidT ) )
			{
			if ( fid >= ptdb->FidVarFirst() && fid <= ptdb->FidVarLast() )
				pfield = ptdb->PfieldVar( columnidT );
			}

		if ( pfieldNil == pfield )
			{
			pfcb->LeaveDML();
			return ErrERRCheck( JET_errColumnNotFound );
			}
		Assert( !FFIELDCommittedDelete( pfield->ffield ) );
		}

	pfcb->AssertDML();
	Assert( ptdb->Pfield( columnidT ) == pfield );
	
	/*	if a field was found, then return the information about it
	/**/
	if ( FCOLUMNIDTagged( columnidT ) )	//lint !e644
		{
		grbit = JET_bitColumnTagged;
		}
	else if ( FCOLUMNIDVar( columnidT ) )
		{
		grbit = 0;
		}
	else
		{
		Assert( FCOLUMNIDFixed( columnidT ) );
		grbit = JET_bitColumnFixed;
		}
		
	if ( FFUCBUpdatable( pfucb ) )
		grbit |= JET_bitColumnUpdatable;

	if ( FFIELDNotNull( pfield->ffield ) )
		grbit |= JET_bitColumnNotNULL;

	if ( FFIELDAutoincrement( pfield->ffield ) )
		grbit |= JET_bitColumnAutoincrement;

	if ( FFIELDVersion( pfield->ffield ) )
		grbit |= JET_bitColumnVersion;

	if ( FFIELDMultivalued( pfield->ffield ) )
		grbit |= JET_bitColumnMultiValued;

	if ( FFIELDEscrowUpdate( pfield->ffield ) )
		grbit |= JET_bitColumnEscrowUpdate;

	if ( FFIELDFinalize( pfield->ffield ) )
		grbit |= JET_bitColumnFinalize;

	if ( FFIELDUserDefinedDefault( pfield->ffield ) )
		grbit |= JET_bitColumnUserDefinedDefault;

	if ( FFIELDPrimaryIndexPlaceholder( pfield->ffield ) )
		grbit |= JET_bitColumnRenameConvertToPrimaryIndexPlaceholder;

	pcolumndef->columnid 	= columnidT;
	pcolumndef->coltyp		= pfield->coltyp;
	pcolumndef->wCountry	= countryDefault;
	pcolumndef->langid		= LangidFromLcid( idxunicodeDefault.lcid );
	pcolumndef->cp			= pfield->cp;
//	UNDONE:	support collation order
	pcolumndef->wCollate	= 0;
	pcolumndef->grbit    	= grbit;
	pcolumndef->cbMax      	= pfield->cbMaxLen;
	pcolumndef->cbDefault	= 0;

	strcpy( pcolumndef->szName,	ptdb->SzFieldName( pfield->itagFieldName, fFalse ) );

	//  only retrieve the default value if we are passed in a buffer to place it into
	if( NULL != pcolumndef->pbDefault )
		{
		if ( FFIELDUserDefinedDefault( pfield->ffield ) )
			{
			//  We need to build up a JET_USERDEFINEDDEFAULT structure
			//  in the pvDefault.

			CHAR		szCallback[JET_cbNameMost+1];
			ULONG		cchSzCallback			= 0;
			BYTE		rgbUserData[cbDefaultValueMost];
			ULONG		cbUserData				= 0;
			CHAR		szDependantColumns[ (JET_ccolKeyMost*(JET_cbNameMost+1)) + 1 ];
			ULONG		cchDependantColumns		= 0;
			COLUMNID	columnidCallback		= columnidT;

			pfcb->LeaveDML();

			//	Template bit is not persisted
			COLUMNIDResetFTemplateColumn( columnidCallback );

			err = ErrCATGetColumnCallbackInfo(
					pfucb->ppib,
					pfucb->ifmp,
					pfcb->ObjidFDP(),
					( NULL == pfcbTemplate ? objidNil : pfcbTemplate->ObjidFDP() ),
					columnidCallback,
					szCallback,
					sizeof( szCallback ),
					&cchSzCallback,
					rgbUserData,
					sizeof( rgbUserData ),
					&cbUserData,
					szDependantColumns,
					sizeof( szDependantColumns ),
					&cchDependantColumns );
			if( err < 0 )
				{
				return err;
				}

			Assert( cchSzCallback <= sizeof( szCallback ) );
			Assert( cbUserData <= sizeof( rgbUserData ) );
			Assert( cchDependantColumns <= sizeof( szDependantColumns ) );
			Assert( '\0' == szCallback[cchSzCallback-1] );
			Assert( 0 == cchDependantColumns || 
					( '\0' == szDependantColumns[cchDependantColumns-1]
					&& '\0' == szDependantColumns[cchDependantColumns-2] ) );

			BYTE * const pbMin					= pcolumndef->pbDefault;
			BYTE * const pbUserdefinedDefault 	= pbMin;
			BYTE * const pbSzCallback 			= pbUserdefinedDefault + sizeof( JET_USERDEFINEDDEFAULT );
			BYTE * const pbUserData 			= pbSzCallback + cchSzCallback;
			BYTE * const pbDependantColumns		= pbUserData + cbUserData;
			BYTE * const pbMax					= pbDependantColumns + cchDependantColumns;
			
			JET_USERDEFINEDDEFAULT * const puserdefineddefault = (JET_USERDEFINEDDEFAULT *)pbUserdefinedDefault;
			memcpy( pbSzCallback, szCallback, cchSzCallback );
			memcpy( pbUserData, rgbUserData, cbUserData );
			memcpy( pbDependantColumns, szDependantColumns, cchDependantColumns );
			
			puserdefineddefault->szCallback 		= (CHAR *)pbSzCallback;
			puserdefineddefault->pbUserData 		= rgbUserData;
			puserdefineddefault->cbUserData 		= cbUserData;
			if( 0 != cchDependantColumns )
				{
				puserdefineddefault->szDependantColumns = (CHAR *)pbDependantColumns;
				}
			else
				{
				puserdefineddefault->szDependantColumns = NULL;
				}

			//  REMEMBER: to pass this into JetAddColumn the cbDefault must be set to sizeof( JET_USERDEFINEDDEFAULT )
			pcolumndef->cbDefault = ULONG( pbMax - pbMin );

			//  re-enter because we will try and leave at the end of this routine
			pfcb->EnterDML();
			}
		else if ( FFIELDDefault( pfield->ffield ) )
			{
			DATA	dataT;

			Assert( pfcb->Ptdb() == ptdb );
			err = ErrRECIRetrieveDefaultValue( pfcb, columnidT, &dataT );
			Assert( err >= JET_errSuccess );
			Assert( wrnRECSeparatedSLV != err );
			Assert( wrnRECIntrinsicSLV != err );
			Assert( wrnRECSeparatedLV != err );
			Assert( wrnRECLongField != err );

			pcolumndef->cbDefault = dataT.Cb();
			UtilMemCpy( pcolumndef->pbDefault, dataT.Pv(), dataT.Cb() );
			}
		}

	pfcb->LeaveDML();

	return JET_errSuccess;
	}


LOCAL ERR ErrInfoGetObjectInfo(
	PIB					*ppib,
	const IFMP			ifmp,
	const CHAR			*szObjectName,
	VOID				*pv,
	const ULONG			cbMax,
	const BOOL			fStats );
LOCAL ERR ErrInfoGetObjectInfoList(
	PIB					*ppib,
	const IFMP			ifmp,
	const JET_OBJTYP	objtyp,
	VOID				*pv,
	const ULONG			cbMax,
	const BOOL			fStats );

LOCAL ERR ErrInfoGetTableColumnInfo(
	PIB					*ppib,
	FUCB				*pfucb,
	const CHAR			*szColumnName,
	const JET_COLUMNID	*pcolid,
	VOID				*pv,
	const ULONG			cbMax );
LOCAL ERR ErrInfoGetTableColumnInfoList(
	PIB					*ppib,
	FUCB				*pfucb,
	VOID				*pv,
	const ULONG			cbMax,
	const BOOL			fCompacting,
	const BOOL			fOrderByColid );
LOCAL ERR ErrInfoGetTableColumnInfoBase(
	PIB					*ppib,
	FUCB				*pfucb,
	const CHAR			*szColumnName,
	VOID				*pv,
	const ULONG			cbMax );

LOCAL ERR ErrINFOGetTableIndexInfo(
	PIB					*ppib,
	FUCB				*pfucb,
	const CHAR			*szIndexName,
	VOID				*pv,
	const ULONG			cbMax );
LOCAL ERR ErrINFOGetTableIndexIdInfo(
	PIB					* ppib,
	FUCB				* pfucb,
	const CHAR			* szIndexName,
	INDEXID				* pindexid );


LOCAL const CHAR	szTcObject[]	= "Tables";		//	currently the only valid "container" object

/*=================================================================
ErrIsamGetObjectInfo

Description: Returns information about all objects or a specified object

Parameters:		ppib		   	pointer to PIB for current session
				ifmp		   	database id containing objects
				objtyp			type of object or objtypNil for all objects
				szContainer		container name or NULL for all objects
				szObjectName	object name or NULL for all objects
				pout		   	output buffer
				lInfoLevel		level of information ( 0, 1, or 2 )

Return Value:	JET_errSuccess if the oubput buffer is valid

Errors/Warnings:

Side Effects:
=================================================================*/
ERR VDBAPI ErrIsamGetObjectInfo(
	JET_SESID		vsesid, 			/* pointer to PIB for current session */
	JET_DBID		vdbid, 	  			/* database id containing objects */
	JET_OBJTYP		objtyp,				/* type of object or objtypNil for all */
	const CHAR		*szContainer, 		/* container name or NULL for all */
	const CHAR		*szObject, 			/* object name or NULL for all */
	VOID			*pv,
	ULONG			cbMax,
	ULONG 			lInfoLevel ) 		/* information level */
	{
	ERR				err;
	PIB				*ppib			= (PIB *) vsesid;
	const IFMP   	ifmp			= (IFMP)vdbid;
	CHAR   			szObjectName[JET_cbNameMost+1];

	/*	check parameters
	/**/
	CallR( ErrPIBCheck( ppib ) );
	CallR( ErrPIBCheckIfmp( ppib, ifmp ) );

	if ( NULL != szContainer && '\0' != *szContainer )
		{
		CHAR	szContainerName[JET_cbNameMost+1];
		CallR( ErrUTILCheckName( szContainerName, szContainer, JET_cbNameMost+1 ) );
		if ( 0 != _stricmp( szContainerName, szTcObject ) )
			{
			//	UNDONE: currently only support "Tables" container
			err = ErrERRCheck( JET_errObjectNotFound );
			return err;
			}
		}
		
	if ( szObject == NULL || *szObject == '\0' )
		*szObjectName = '\0';
	else
		CallR( ErrUTILCheckName( szObjectName, szObject, JET_cbNameMost+1 ) );

	switch ( lInfoLevel )
		{
		case JET_ObjInfo:
		case JET_ObjInfoNoStats:
			err = ErrInfoGetObjectInfo(
				ppib,
				ifmp,
				szObjectName,
				pv,
				cbMax,
				JET_ObjInfo == lInfoLevel );
			break;
			
		case JET_ObjInfoList:
		case JET_ObjInfoListNoStats:
			err = ErrInfoGetObjectInfoList(
				ppib,
				ifmp,
				objtyp,
				pv,
				cbMax,
				JET_ObjInfoList == lInfoLevel );
			break;
			
		case JET_ObjInfoSysTabCursor:
		case JET_ObjInfoSysTabReadOnly:
		case JET_ObjInfoListACM:
		case JET_ObjInfoRulesLoaded:
		default:
			Assert( fFalse );		// should be impossible (filtered out by JetGetObjectInfo())
			err = ErrERRCheck( JET_errInvalidParameter );
			break;
		}

	return err;
	}


LOCAL ERR ErrInfoGetObjectInfo(
	PIB				*ppib,
	const IFMP		ifmp,
	const CHAR		*szObjectName,
	VOID			*pv,
	const ULONG		cbMax,
	const BOOL		fStats )
	{
	ERR				err;
	FUCB			*pfucbInfo;
	JET_OBJECTINFO	objectinfo;
	
	/*	return error if the output buffer is too small
	/**/
	if ( cbMax < sizeof( JET_OBJECTINFO ) )
		{
		return ErrERRCheck( JET_errBufferTooSmall );
		}

	CallR( ErrCATGetTableInfoCursor( ppib, ifmp, szObjectName, &pfucbInfo ) );

	/*	set cbStruct
	/**/
	objectinfo.cbStruct	= sizeof( JET_OBJECTINFO );
	objectinfo.objtyp	= JET_objtypTable;

	/*	set base table capability bits
	/**/
	objectinfo.grbit = JET_bitTableInfoBookmark | JET_bitTableInfoRollback;
	
	// UNDONE: How to set updatable (currently, use catalog's Updatable flag)
	if ( FFUCBUpdatable( pfucbInfo ) )
		{
		objectinfo.grbit |= JET_bitTableInfoUpdatable;
		}

	ULONG	cbActual;
	Call( ErrIsamRetrieveColumn(
				ppib,
				pfucbInfo,
				fidMSO_Flags,
				&objectinfo.flags,
				sizeof( objectinfo.flags ),
				&cbActual,
				NO_GRBIT,
				NULL ) );
	CallS( err );
	Assert( sizeof(ULONG) == cbActual );

	/*	set stats
	/**/
	if ( fStats )
		{
		LONG	cRecord, cPage;
		Call( ErrSTATSRetrieveTableStats(
					ppib,
					ifmp,
					(CHAR *)szObjectName,
					&cRecord,
					NULL,
					&cPage ) );
					
		objectinfo.cRecord	= cRecord;
		objectinfo.cPage	= cPage;
		}
	else
		{
		objectinfo.cRecord	= 0;
		objectinfo.cPage	= 0;
		}

	memcpy( pv, &objectinfo, sizeof( JET_OBJECTINFO ) );
	err = JET_errSuccess;

HandleError:
	CallS( ErrCATClose( ppib, pfucbInfo ) );
	return err;
	}


LOCAL ERR ErrInfoGetObjectInfoList(
	PIB					*ppib,
	const IFMP			ifmp,
	const JET_OBJTYP	objtyp,
	VOID				*pv,
	const ULONG			cbMax,
	const BOOL			fStats )
	{
#ifdef	DISPATCHING
	ERR					err;
	const JET_SESID		sesid			= (JET_SESID)ppib;
	JET_TABLEID			tableid;
	JET_COLUMNID		rgcolumnid[ccolumndefGetObjectInfoMax];
	FUCB				*pfucbCatalog	= pfucbNil;
	const JET_OBJTYP	objtypTable		= JET_objtypTable;
	JET_GRBIT			grbitTable;
	ULONG				ulFlags;
	LONG  				cRecord			= 0;		/* count of records in table */
	LONG  				cPage			= 0;		/* count of pages in table */
	ULONG  				cRows			= 0;		/* count of objects found */
	ULONG				cbActual;
	CHAR				szObjectName[JET_cbNameMost+1];
	JET_OBJECTLIST		objectlist;
	
	/* Open the temporary table which will be returned to the caller
	/**/
	CallR( ErrIsamOpenTempTable(
				sesid,
				(JET_COLUMNDEF *)rgcolumndefGetObjectInfo,
				ccolumndefGetObjectInfoMax,
				NULL,
				JET_bitTTScrollable|JET_bitTTIndexed,
				&tableid,
				rgcolumnid ) );

	if ( JET_objtypNil != objtyp && JET_objtypTable != objtyp )
		{
		//	the only objects currently supported are Table objects
		//	(or objtypNil, which means scan all objects)
		goto ResetTempTblCursor;
		}

	Call( ErrCATOpen( ppib, ifmp, &pfucbCatalog ) );
	Assert( pfucbNil != pfucbCatalog );

	Call( ErrIsamSetCurrentIndex( ppib, pfucbCatalog, szMSORootObjectsIndex ) );
	
	//	set base table capability bits
	grbitTable = JET_bitTableInfoBookmark|JET_bitTableInfoRollback;
	
	//	UNDONE: How to set updatable (currently, use catalog's Updatable flag)
	if ( FFUCBUpdatable( pfucbCatalog ) )
		grbitTable |= JET_bitTableInfoUpdatable;
		

	err = ErrIsamMove( ppib, pfucbCatalog, JET_MoveFirst, NO_GRBIT );
	while ( JET_errNoCurrentRecord != err )
		{
		Call( err );
		CallS( err );

		
#ifdef DEBUG	
		//	verify this is a Table object
		SYSOBJ	sysobj;
		Call( ErrIsamRetrieveColumn(
					ppib,
					pfucbCatalog,
					fidMSO_Type,
					(BYTE *)&sysobj,
					sizeof(sysobj),
					&cbActual,
					NO_GRBIT,
					NULL ) );
		CallS( err );
		Assert( sizeof(SYSOBJ) == cbActual );
		Assert( sysobjTable == sysobj );
#endif

		// get object name
		//
		Call( ErrIsamRetrieveColumn(
					ppib,
					pfucbCatalog,
					fidMSO_Name,
					szObjectName,
					JET_cbNameMost,
					&cbActual,
					NO_GRBIT,
					NULL ) );
		CallS( err );
		Assert( cbActual > 0 );
		Assert( cbActual <= JET_cbNameMost );
		szObjectName[cbActual] = 0;

		//	get flags
		//
		Call( ErrIsamRetrieveColumn(
					ppib,
					pfucbCatalog,
					fidMSO_Flags,
					&ulFlags,
					sizeof(ulFlags),
					&cbActual,
					NO_GRBIT,
					NULL ) );
		CallS( err );
		Assert( sizeof(ULONG) == cbActual );

		//	get statistics (if requested)
		//
		if ( fStats )
			{
			Call( ErrSTATSRetrieveTableStats(
						ppib,
						ifmp,
						szObjectName,
						&cRecord,
						NULL,
						&cPage ) );
			}
		else
			{
			Assert( 0 == cRecord );
			Assert( 0 == cPage );
			}

		// add the current object info to the temporary table
		//
		Call( ErrDispPrepareUpdate(
					sesid, 
					tableid, 
					JET_prepInsert ) );
					
		Call( ErrDispSetColumn(
					sesid, 
					tableid,
					rgcolumnid[iContainerName], 
					szTcObject,
					(ULONG)strlen(szTcObject),
					NO_GRBIT, 
					NULL ) );
		Call( ErrDispSetColumn(
					sesid, 
					tableid,
					rgcolumnid[iObjectType], 
					&objtypTable,
					sizeof(objtypTable), 
					NO_GRBIT, 
					NULL ) );
		Call( ErrDispSetColumn(
					sesid, 
					tableid,
					rgcolumnid[iObjectName], 
					szObjectName,
					(ULONG)strlen(szObjectName),
					NO_GRBIT,
					NULL ) );
		Call( ErrDispSetColumn(
					sesid,
					tableid,
					rgcolumnid[iFlags],
					&ulFlags,
					sizeof(ulFlags),
					NO_GRBIT,
					NULL ) );
		Call( ErrDispSetColumn(
					sesid,
					tableid,
					rgcolumnid[iCRecord],
					&cRecord,
					sizeof(cRecord),
					NO_GRBIT,
					NULL ) );
		Call( ErrDispSetColumn(
					sesid,
					tableid,
					rgcolumnid[iCPage],
					&cPage,
					sizeof(cPage),
					NO_GRBIT,
					NULL ) );
		Call( ErrDispSetColumn(
					sesid,
					tableid,
					rgcolumnid[iGrbit],
					&grbitTable,
					sizeof(grbitTable),
					NO_GRBIT,
					NULL ) );
					
		Call( ErrDispUpdate(
					sesid,
					tableid,
					NULL,
					0,
					NULL,
					NO_GRBIT ) );

		//	set the number of objects found
		//
		cRows++;

		/* move to the next record
		/**/
		err = ErrIsamMove( ppib, pfucbCatalog, JET_MoveNext, NO_GRBIT );
		}

	CallS( ErrCATClose( ppib, pfucbCatalog ) );
	pfucbCatalog = pfucbNil;
	

ResetTempTblCursor:
	/* move to first record in the temporary table
	/**/
	err = ErrDispMove( sesid, tableid, JET_MoveFirst, NO_GRBIT );
	if ( err < 0 )
		{
		if ( JET_errNoCurrentRecord != err )
			goto HandleError;
		}

	/* set the return structure
	/**/
	objectlist.cbStruct					= sizeof(JET_OBJECTLIST);
	objectlist.tableid					= tableid;
	objectlist.cRecord					= cRows;
	objectlist.columnidcontainername	= rgcolumnid[iContainerName];
	objectlist.columnidobjectname		= rgcolumnid[iObjectName];
	objectlist.columnidobjtyp			= rgcolumnid[iObjectType];
	objectlist.columnidgrbit			= rgcolumnid[iGrbit];
	objectlist.columnidflags			= rgcolumnid[iFlags];
	objectlist.columnidcRecord			= rgcolumnid[iCRecord];
	objectlist.columnidcPage			= rgcolumnid[iCPage];

	AssertDIRNoLatch( ppib );
	Assert( pfucbNil == pfucbCatalog );

	memcpy( pv, &objectlist, sizeof( JET_OBJECTLIST ) );
	return JET_errSuccess;

HandleError:
	Assert( err < 0 );
	AssertDIRNoLatch( ppib );

	if ( pfucbNil != pfucbCatalog )
		{
		CallS( ErrCATClose( ppib, pfucbCatalog ) );
		}

	//	ignore errors returned while destroying temp table.
	(VOID)ErrDispCloseTable( sesid, tableid );
	
	return err;
	
#else	/* !DISPATCHING */
	Assert( fFalse );
	return ErrERRCheck( JET_errFeatureNotAvailable );
#endif	/* !DISPATCHING */

	}


//  ================================================================
LOCAL ERR ErrInfoGetTableAvailSpace(
	PIB * const ppib,
	FUCB * const pfucb,
	void * const pvResult,
	const ULONG cbMax )
//  ================================================================
//
//  Count the number of available pages in a table, its indexes and its
//  LV tree
//
//-
	{
	ERR err = JET_errSuccess;
	
	if( sizeof( CPG ) != cbMax )
		{
		return ErrERRCheck( JET_errInvalidBufferSize );
		}

	CPG cpgT;
	CPG * const pcpg = (CPG *)pvResult;
	*pcpg = 0;

	FCB * pfcbT		= pfcbNil;
	FUCB * pfucbT 	= pfucbNil;

	//  first, the table
	Call( ErrSPGetInfo( ppib, pfucb->ifmp, pfucb, (BYTE *)&cpgT, sizeof( cpgT ), fSPAvailExtent ) );
	*pcpg += cpgT;

	//  then, the indexes of the table
	for( pfcbT = pfucb->u.pfcb->PfcbNextIndex(); pfcbNil != pfcbT; pfcbT = pfcbT->PfcbNextIndex() )
		{
		Call( ErrDIROpen( ppib, pfcbT, &pfucbT ) );
		Call( ErrSPGetInfo( ppib, pfucbT->ifmp, pfucbT, (BYTE *)&cpgT, sizeof( cpgT ), fSPAvailExtent ) );
		*pcpg += cpgT;
		DIRClose( pfucbT );
		pfucbT = pfucbNil;
		}

	//  finally, the LV tree
	err = ErrFILEOpenLVRoot( pfucb, &pfucbT, fFalse );
	if( JET_errSuccess == err )
		{
		//  the LV tree exists
		Call( ErrSPGetInfo( ppib, pfucbT->ifmp, pfucbT, (BYTE *)&cpgT, sizeof( cpgT ), fSPAvailExtent ) );
		*pcpg += cpgT;
		DIRClose( pfucbT );
		pfucbT = pfucbNil;
		}
	else
		{
		Call( err );
		//  don't want to return wrnLVNoLongValues
		err = JET_errSuccess;
		}
	
HandleError:
	if( pfucbNil != pfucbT )
		{
		DIRClose( pfucbT );
		}
	return err;
	}

	
ERR VTAPI ErrIsamGetTableInfo(
	JET_SESID		vsesid,
	JET_VTID	 	vtid,
	void		 	*pvResult,
	unsigned long	cbMax,
	unsigned long	lInfoLevel )
	{
	ERR	 			err;
	PIB				*ppib		= (PIB *)vsesid;
	FUCB		 	*pfucb		= (FUCB *)vtid;
	CHAR			szTableName[JET_cbNameMost+1];

	CallR( ErrPIBCheck( ppib ) );
	CheckTable( ppib, pfucb );

	/* if OLCStats info/reset can be done now 
	/**/
	switch( lInfoLevel )
		{
		case JET_TblInfo:
		case JET_TblInfoName:
		case JET_TblInfoTemplateTableName:
			break;

		case JET_TblInfoOLC:
		case JET_TblInfoResetOLC:
			return ErrERRCheck( JET_errFeatureNotAvailable );

		case JET_TblInfoSpaceAlloc:
			/*	number of pages and density
			/**/
			Assert( cbMax >= sizeof(ULONG) * 2);
			err = ErrCATGetTableAllocInfo(
					ppib,
					pfucb->ifmp,
					pfucb->u.pfcb->ObjidFDP(),
					(ULONG *)pvResult, 
					((ULONG *)pvResult) + 1);
			return err;

		case JET_TblInfoSpaceUsage:
			{
			BYTE	fSPExtents = fSPOwnedExtent|fSPAvailExtent;

			if ( cbMax > 2 * sizeof(CPG) )
				fSPExtents |= fSPExtentList;

			err = ErrSPGetInfo(
						ppib,
						pfucb->ifmp,
						pfucb,
						static_cast<BYTE *>( pvResult ),
						cbMax,
						fSPExtents );
			return err;
			}

		case JET_TblInfoSpaceOwned:
			err = ErrSPGetInfo(
						ppib,
						pfucb->ifmp,
						pfucb,
						static_cast<BYTE *>( pvResult ),
						cbMax,
						fSPOwnedExtent );
			return err;

		case JET_TblInfoSpaceAvailable:
			err = ErrInfoGetTableAvailSpace(
					ppib,
					pfucb,
					pvResult,
					cbMax );
			return err;

		case JET_TblInfoDumpTable:
			Assert( fFalse );
			return ErrERRCheck( JET_errFeatureNotAvailable );

		default:
			Assert( fFalse );
		}

		
	Assert( pfucb->u.pfcb->Ptdb() != ptdbNil );
	pfucb->u.pfcb->EnterDML();
	Assert( strlen( pfucb->u.pfcb->Ptdb()->SzTableName() ) <= JET_cbNameMost );
	strcpy( szTableName, pfucb->u.pfcb->Ptdb()->SzTableName() );
	pfucb->u.pfcb->LeaveDML();
	
	switch ( lInfoLevel )
		{
		case JET_TblInfo:
			{
			JET_OBJECTINFO	objectinfo;
			LONG			cRecord;
			LONG			cPage;
			
			/* check buffer size
			/**/
			if ( cbMax < sizeof( JET_OBJECTINFO ) )
				{
				err = ErrERRCheck( JET_errBufferTooSmall );
				goto HandleError;
				}

			if ( pfucb->u.pfcb->FTypeTemporaryTable() )
				{
				err = ErrERRCheck( JET_errObjectNotFound );
				goto HandleError;
				}

			Assert( rgfmp[ pfucb->u.pfcb->Ifmp() ].Dbid() != dbidTemp );

			/* set data to return
			/**/
			objectinfo.cbStruct	= sizeof(JET_OBJECTINFO);
			objectinfo.objtyp	= JET_objtypTable;
			objectinfo.flags	= 0;
			
			if ( FCATSystemTable( pfucb->u.pfcb->PgnoFDP() ) )
				objectinfo.flags |= JET_bitObjectSystem;
			else if ( FOLDSystemTable( szTableName ) )
				objectinfo.flags |= JET_bitObjectSystemDynamic;

			if ( pfucb->u.pfcb->FFixedDDL() )
				objectinfo.flags |= JET_bitObjectTableFixedDDL;

			//	hierarchical DDL not currently nestable
			Assert( !( pfucb->u.pfcb->FTemplateTable() && pfucb->u.pfcb->FDerivedTable() ) );
			if ( pfucb->u.pfcb->FTemplateTable() )
				objectinfo.flags |= JET_bitObjectTableTemplate;
			else if ( pfucb->u.pfcb->FDerivedTable() )
				objectinfo.flags |= JET_bitObjectTableDerived;

			/*	set base table capability bits
			/**/
			objectinfo.grbit = JET_bitTableInfoBookmark | JET_bitTableInfoRollback;
			if ( FFUCBUpdatable( pfucb ) )
				objectinfo.grbit |= JET_bitTableInfoUpdatable;

			Call( ErrSTATSRetrieveTableStats(
						pfucb->ppib,
						pfucb->ifmp,
						szTableName,
						&cRecord,
						NULL,
						&cPage ) );
						
			objectinfo.cRecord	= cRecord;
			objectinfo.cPage	= cPage;

			memcpy( pvResult, &objectinfo, sizeof( JET_OBJECTINFO ) );

			break;
			}

		case JET_TblInfoRvt:
			err = ErrERRCheck( JET_errQueryNotSupported );
			break;

		case JET_TblInfoName:
		case JET_TblInfoMostMany:
			//	UNDONE:	add support for most many
			if ( pfucb->u.pfcb->FTypeTemporaryTable() )
				{
				err = ErrERRCheck( JET_errInvalidOperation );
				goto HandleError;
				}
			if ( strlen( szTableName ) >= cbMax )
				err = ErrERRCheck( JET_errBufferTooSmall );
			else
				{
				strcpy( static_cast<CHAR *>( pvResult ), szTableName );
				}
			break;

		case JET_TblInfoDbid:
			if ( pfucb->u.pfcb->FTypeTemporaryTable() )
				{
				err = ErrERRCheck( JET_errInvalidOperation );
				goto HandleError;
				}
			/* check buffer size
			/**/
			if ( cbMax < sizeof(JET_DBID) + sizeof(JET_DBID) )
				{
				err = ErrERRCheck( JET_errBufferTooSmall );
				goto HandleError;
				}
			else
				{
				JET_DBID	jifmp = (JET_DBID) pfucb->ifmp;

				*(JET_DBID *)pvResult = jifmp;
				*(JET_DBID *)((CHAR *)pvResult + sizeof(JET_DBID)) = (JET_DBID)pfucb->ifmp;
				}
			break;

		case JET_TblInfoTemplateTableName:
			if ( pfucb->u.pfcb->FTypeTemporaryTable() )
				{
				err = ErrERRCheck( JET_errInvalidOperation );
				goto HandleError;
				}

			// Need at least JET_cbNameMost, plus 1 for null-terminator.
			if ( cbMax <= JET_cbNameMost )
				err = ErrERRCheck( JET_errBufferTooSmall );
			else if ( pfucb->u.pfcb->FDerivedTable() )
				{
				FCB		*pfcbTemplateTable = pfucb->u.pfcb->Ptdb()->PfcbTemplateTable();
				Assert( pfcbNil != pfcbTemplateTable );
				Assert( pfcbTemplateTable->FFixedDDL() );
				Assert( strlen( pfcbTemplateTable->Ptdb()->SzTableName() ) <= JET_cbNameMost );
				strcpy( (CHAR *)pvResult, pfcbTemplateTable->Ptdb()->SzTableName() );
				}
			else
				{
				//	table was not derived from a template -- return NULL
				*( (CHAR *)pvResult ) = '\0';
				}
			break;

		default:
			err = ErrERRCheck( JET_errInvalidParameter );
		}

HandleError:
	return err;
	}


/*=================================================================
ErrIsamGetColumnInfo

Description: Returns information about all columns for the table named

Parameters:
			ppib				pointer to PIB for current session
			ifmp				id of database containing the table
			szTableName			table name
			szColumnName		column name or NULL for all columns
			pv					pointer to results
			cbMax				size of result buffer
			lInfoLevel			level of information ( 0, 1, or 2 )

Return Value: JET_errSuccess

Errors/Warnings:

Side Effects:
=================================================================*/
ERR VDBAPI ErrIsamGetColumnInfo(
	JET_SESID		vsesid, 				/* pointer to PIB for current session */
	JET_DBID  		vdbid, 					/* id of database containing the table */
	const CHAR		*szTable, 				/* table name */
	const CHAR		*szColumnName,   		/* column name or NULL for all columns except when pcolid set */
	JET_COLUMNID	*pcolid,				/* used when szColumnName is null or "" AND lInfoLevel == JET_ColInfoByColid */
	VOID			*pv,
	unsigned long	cbMax,
	unsigned long	lInfoLevel )
	{
	PIB				*ppib = (PIB *) vsesid;
	ERR				err;
	IFMP	 		ifmp;
	CHAR	 		szTableName[ JET_cbNameMost+1 ];
	FUCB	 		*pfucb;

	/*	check parameters
	/**/
	CallR( ErrPIBCheck( ppib ) );
	CallR( ErrPIBCheckIfmp( ppib, (IFMP)vdbid ) );
	ifmp = (IFMP) vdbid;
	if ( szTable == NULL )
		return ErrERRCheck( JET_errInvalidParameter );
	CallR( ErrUTILCheckName( szTableName, szTable, JET_cbNameMost+1 ) );

	CallR( ErrFILEOpenTable( ppib, ifmp, &pfucb, szTableName, NO_GRBIT ) );
	Assert( pfucbNil != pfucb );

	Assert( ( rgfmp[ifmp].FReadOnlyAttach() && !FFUCBUpdatable( pfucb ) )
		|| ( !rgfmp[ifmp].FReadOnlyAttach() && FFUCBUpdatable( pfucb ) ) );
	FUCBResetUpdatable( pfucb );

	Call( ErrIsamGetTableColumnInfo(
				(JET_SESID)ppib,
				(JET_VTID)pfucb,
				szColumnName,
				pcolid,
				pv,
				cbMax,
				lInfoLevel ) );

HandleError:
	CallS( ErrFILECloseTable( ppib, pfucb ) );
	return err;
	}


/*=================================================================
ErrIsamGetTableColumnInfo

Description: Returns column information for the table id passed

Parameters: 	ppib				pointer to PIB for the current session
				pfucb				pointer to FUCB for the table
				szColumnName		column name or NULL for all columns
				pcolid				retrieve info by colid, JET_colInfo only
				pv					pointer to result buffer
				cbMax				size of result buffer
				lInfoLevel			level of information

Return Value: JET_errSuccess

Errors/Warnings:

Side Effects:
=================================================================*/
	ERR VTAPI
ErrIsamGetTableColumnInfo(
	JET_SESID			vsesid,			/* pointer to PIB for current session */
	JET_VTID			vtid, 			/* pointer to FUCB for the table */
	const CHAR			*szColumn, 		/* column name or NULL for all columns */
	const JET_COLUMNID	*pcolid,		/* except if colid is set, then retrieve column info of ths col */
	void   				*pb,
	unsigned long		cbMax,
	unsigned long		lInfoLevel )	/* information level ( 0, 1, or 2 ) */
	{
	ERR			err;
	PIB			*ppib = (PIB *)vsesid;
	FUCB		*pfucb = (FUCB *)vtid;
	CHAR		szColumnName[ (JET_cbNameMost + 1) ];

	CallR( ErrPIBCheck( ppib ) );
	CheckTable( ppib, pfucb );
	if ( szColumn == NULL || *szColumn == '\0' )
		{
		szColumnName[0] = '\0';
		}
	else
		{
		CallR( ErrUTILCheckName( szColumnName, szColumn, ( JET_cbNameMost + 1 ) ) );
		}

	CallR( ErrIsamBeginTransaction( (JET_SESID)ppib, NO_GRBIT ) );
	
	switch ( lInfoLevel )
		{
		case JET_ColInfo:
		case JET_ColInfoByColid:
			err = ErrInfoGetTableColumnInfo( ppib, pfucb, szColumnName, pcolid, pb, cbMax );
			break;
		case JET_ColInfoList:
			err = ErrInfoGetTableColumnInfoList( ppib, pfucb, pb, cbMax, fFalse, fFalse );
			break;
		case JET_ColInfoListSortColumnid:
			err = ErrInfoGetTableColumnInfoList( ppib, pfucb, pb, cbMax, fFalse, fTrue );
			break;
		case JET_ColInfoBase:
			err = ErrInfoGetTableColumnInfoBase( ppib, pfucb, szColumnName, pb, cbMax );
			break;
		case JET_ColInfoListCompact:
			err = ErrInfoGetTableColumnInfoList( ppib, pfucb, pb, cbMax, fTrue, fFalse );
			break;
			
		case JET_ColInfoSysTabCursor:
		default:
			Assert( fFalse );		// should be impossible (filtered out by JetGetTableColumnInfo())
			err = ErrERRCheck( JET_errInvalidParameter );
		}

	if( err >= 0 )
		{
		err = ErrIsamCommitTransaction( (JET_SESID)ppib, NO_GRBIT );
		}
		
	if( err < 0 )
		{
		const ERR	errT	= ErrIsamRollback( (JET_SESID)ppib, NO_GRBIT );
		if ( JET_errSuccess != errT )
			{
			Assert( errT < 0 );
			Assert( PinstFromPpib( ppib )->FInstanceUnavailable() );
			Assert( JET_errSuccess != ppib->ErrRollbackFailure() );
			}
		}
		
	return err;
	}


LOCAL ERR ErrInfoGetTableColumnInfo(
	PIB					*ppib,
	FUCB				*pfucb,
	const CHAR			*szColumnName,
	const JET_COLUMNID	*pcolid,
	VOID				*pv,
	const ULONG			cbMax )
	{
	ERR			err;	
	INFOCOLUMNDEF	columndef;
	columndef.pbDefault	= NULL;

	if ( cbMax < sizeof(JET_COLUMNDEF) || szColumnName == NULL )
		{
		return ErrERRCheck( JET_errInvalidParameter );
		}

	//	do lookup by columnid, not column name
	if ( szColumnName[0] == '\0' )
		{
		if ( pcolid )
			{
			columndef.columnid = *pcolid;
			szColumnName = NULL;
			}
		else
			columndef.columnid = 0;
		}

	CallR( ErrINFOGetTableColumnInfo( pfucb, szColumnName, &columndef ) );

	((JET_COLUMNDEF *)pv)->cbStruct	= sizeof(JET_COLUMNDEF);
	((JET_COLUMNDEF *)pv)->columnid	= columndef.columnid;
	((JET_COLUMNDEF *)pv)->coltyp  	= columndef.coltyp;
	((JET_COLUMNDEF *)pv)->cbMax   	= columndef.cbMax;
	((JET_COLUMNDEF *)pv)->grbit   	= columndef.grbit;
	((JET_COLUMNDEF *)pv)->wCollate	= 0;
	((JET_COLUMNDEF *)pv)->cp	   	= columndef.cp;
	((JET_COLUMNDEF *)pv)->wCountry	= columndef.wCountry;
	((JET_COLUMNDEF *)pv)->langid  	= columndef.langid;

	return JET_errSuccess;
	}


LOCAL ERR ErrINFOSetTableColumnInfoList(
	PIB				*ppib,
	JET_TABLEID		tableid,
	const CHAR		*szTableName,
	COLUMNID		*rgcolumnid,
	INFOCOLUMNDEF	*pcolumndef,
	const BOOL		fOrderByColid )
	{
	ERR				err;

	Call( ErrDispPrepareUpdate( (JET_SESID)ppib, tableid, JET_prepInsert ) );

	if ( fOrderByColid )
		{
		Call( ErrDispSetColumn( 
					(JET_SESID)ppib, 
					tableid,
					rgcolumnid[iColumnPOrder], 
					(BYTE *)&pcolumndef->columnid,
					sizeof(pcolumndef->columnid), 
					NO_GRBIT,
					NULL ) );
		}

	Call( ErrDispSetColumn( 
				(JET_SESID)ppib, 
				tableid,
				rgcolumnid[iColumnName], 
				pcolumndef->szName,
				(ULONG)strlen( pcolumndef->szName ), 
				NO_GRBIT,
				NULL ) );
	Call( ErrDispSetColumn(
				(JET_SESID)ppib,
				tableid,
				rgcolumnid[iColumnId], 
				(BYTE *)&pcolumndef->columnid,
				sizeof(pcolumndef->columnid), 
				NO_GRBIT,
				NULL ) );
	Call( ErrDispSetColumn(
				(JET_SESID)ppib,
				tableid,
				rgcolumnid[iColumnType], 
				(BYTE *)&pcolumndef->coltyp,
				sizeof(pcolumndef->coltyp), 
				NO_GRBIT, 
				NULL ) );
	Call( ErrDispSetColumn( 
				(JET_SESID)ppib, 
				tableid,
				rgcolumnid[iColumnCountry], 
				&pcolumndef->wCountry,
				sizeof( pcolumndef->wCountry ), 
				NO_GRBIT, 
				NULL ) );
	Call( ErrDispSetColumn( 
				(JET_SESID)ppib, 
				tableid,
				rgcolumnid[iColumnLangid], 
				&pcolumndef->langid,
				sizeof( pcolumndef->langid ),
				NO_GRBIT,
				NULL ) );
	Call( ErrDispSetColumn( 
				(JET_SESID)ppib, 
				tableid,
				rgcolumnid[iColumnCp], 
				&pcolumndef->cp,
				sizeof(pcolumndef->cp), 
				NO_GRBIT, 
				NULL ) );
	Call( ErrDispSetColumn( 
				(JET_SESID)ppib, 
				tableid,
				rgcolumnid[iColumnSize], 
				(BYTE *)&pcolumndef->cbMax,
				sizeof(pcolumndef->cbMax), 
				NO_GRBIT,
				NULL ) );
	Call( ErrDispSetColumn( 
				(JET_SESID)ppib,
				tableid,
				rgcolumnid[iColumnGrbit], 
				&pcolumndef->grbit,
				sizeof(pcolumndef->grbit), 
				NO_GRBIT,
				NULL ) );

	Call( ErrDispSetColumn(
				(JET_SESID)ppib,
				tableid,
				rgcolumnid[iColumnCollate],
				&pcolumndef->wCollate,
				sizeof(pcolumndef->wCollate),
				NO_GRBIT,
				NULL ) );

	if ( pcolumndef->cbDefault > 0 )
		{
		Call( ErrDispSetColumn(
				(JET_SESID)ppib,
				tableid,
				rgcolumnid[iColumnDefault],
				pcolumndef->pbDefault,
				pcolumndef->cbDefault, 
				NO_GRBIT,
				NULL ) );
		}

	Call( ErrDispSetColumn(
				(JET_SESID)ppib,
				tableid,
				rgcolumnid[iColumnTableName],
				szTableName,
				(ULONG)strlen( szTableName ),
				NO_GRBIT,
				NULL ) );
	Call( ErrDispSetColumn(
				(JET_SESID)ppib,
				tableid,
				rgcolumnid[iColumnColumnName], 
				pcolumndef->szName,
				(ULONG)strlen( pcolumndef->szName ),
				NO_GRBIT,
				NULL ) );

	Call( ErrDispUpdate( (JET_SESID)ppib, tableid, NULL, 0, NULL, NO_GRBIT ) );

HandleError:
	return err;
	}


BOOL g_fCompactTemplateTableColumnDropped = fFalse;	//	LAURIONB_HACK

LOCAL ERR ErrInfoGetTableColumnInfoList(
	PIB				*ppib,
	FUCB			*pfucb,
	VOID			*pv,
	const ULONG		cbMax,
	const BOOL		fCompacting,
	const BOOL		fOrderByColid )
	{
	ERR				err;
	JET_TABLEID		tableid;
	COLUMNID		rgcolumnid[ccolumndefGetColumnInfoMax];
	FCB				*pfcb				= pfucb->u.pfcb;
	TDB				*ptdb				= pfcb->Ptdb();
	FID				fid;
	FID				fidFixedFirst;
	FID				fidFixedLast;
	FID				fidVarFirst;
	FID				fidVarLast;
	FID				fidTaggedFirst;
	FID				fidTaggedLast;
	CHAR			szTableName[JET_cbNameMost+1];
	INFOCOLUMNDEF	columndef;
	ULONG		  	cRows				= 0;
	const BOOL		fTemplateTable		= pfcb->FTemplateTable();

	columndef.pbDefault = NULL;

	/*	initialize variables
	/**/
	if ( cbMax < sizeof(JET_COLUMNLIST) )
		{
		return ErrERRCheck( JET_errInvalidParameter );
		}

	/*	create temporary table
	/**/
	CallR( ErrIsamOpenTempTable(
				(JET_SESID)ppib,
				(JET_COLUMNDEF *)( fCompacting ? rgcolumndefGetColumnInfoCompact : rgcolumndefGetColumnInfo ),
				ccolumndefGetColumnInfoMax,
				NULL,
				JET_bitTTScrollable|JET_bitTTIndexed,
				&tableid,
				rgcolumnid ) );

#ifdef INTRINSIC_LV
	columndef.pbDefault = (BYTE *)PvOSMemoryHeapAlloc( cbDefaultValueMost * 64 );
#else // INTRINSIC_LV	
	columndef.pbDefault = (BYTE *)PvOSMemoryHeapAlloc( cbLVIntrinsicMost * 64 );
#endif // INTRINSIC_LV	
	if( NULL == columndef.pbDefault )
		{
		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}

	pfcb->EnterDML();
		
	fidFixedLast = ptdb->FidFixedLast();
	fidVarLast = ptdb->FidVarLast();
	fidTaggedLast = ptdb->FidTaggedLast();

	Assert( fidFixedLast == fidFixedLeast-1 || FFixedFid( fidFixedLast ) );
	Assert( fidVarLast == fidVarLeast-1 || FVarFid( fidVarLast ) );
	Assert( fidTaggedLast == fidTaggedLeast-1 || FTaggedFid( fidTaggedLast ) );

	Assert( strlen( ptdb->SzTableName() ) <= JET_cbNameMost );
	strcpy( szTableName, ptdb->SzTableName() );
	
	pfcb->LeaveDML();

	if ( !fCompacting && pfcbNil != ptdb->PfcbTemplateTable() )
		{
		ptdb->AssertValidDerivedTable();
		Assert( !fTemplateTable );

		const FID	fidTemplateFixedLast	= ptdb->PfcbTemplateTable()->Ptdb()->FidFixedLast();
		const FID	fidTemplateVarLast		= ptdb->PfcbTemplateTable()->Ptdb()->FidVarLast();
		const FID	fidTemplateTaggedLast	= ptdb->PfcbTemplateTable()->Ptdb()->FidTaggedLast();

		Assert( fidTemplateFixedLast == fidFixedLeast-1 || FFixedFid( fidTemplateFixedLast ) );
		Assert( fidTemplateVarLast == fidVarLeast-1 || FVarFid( fidTemplateVarLast ) );
		Assert( fidTemplateTaggedLast == fidTaggedLeast-1 || FTaggedFid( fidTemplateTaggedLast ) );

		for ( fid = fidFixedLeast; ; fid++ )
			{
			if ( fidTemplateFixedLast+1 == fid )
				fid = fidVarLeast;
			if ( fidTemplateVarLast+1 == fid )
				fid = fidTaggedLeast;
			if ( fid > fidTemplateTaggedLast )
				break;

			columndef.columnid = ColumnidOfFid( fid, fTrue );
			CallS( ErrINFOGetTableColumnInfo( pfucb, NULL, &columndef ) );

			Call( ErrINFOSetTableColumnInfoList(
					ppib,
					tableid,
					szTableName,
					rgcolumnid,
					&columndef,
					fOrderByColid ) );
			
			cRows++;
			}
		}

	fidFixedFirst = ptdb->FidFixedFirst();
	fidVarFirst = ptdb->FidVarFirst();
	fidTaggedFirst = ptdb->FidTaggedFirst();

	for ( fid = fidFixedFirst; ; fid++ )
		{
		if ( fidFixedLast+1 == fid )
			fid = fidVarFirst;
		if ( fidVarLast+1 == fid )
			fid = fidTaggedFirst;
		if ( fid > fidTaggedLast )
			break;


		if ( fTemplateTable )
			{
			columndef.columnid = ColumnidOfFid( fid, fTrue );
			}
		else
			{
			columndef.columnid = ColumnidOfFid( fid, fFalse );
			err = ErrRECIAccessColumn( pfucb, columndef.columnid );
			if ( err < 0 )
				{
				if ( JET_errColumnNotFound == err )
					continue;
				goto HandleError;
				}
			}
			
		CallS( ErrINFOGetTableColumnInfo( pfucb, NULL, &columndef ) );
			
		//	if compacting, ignore placeholder
		if ( !fCompacting || !( columndef.grbit & JET_bitColumnRenameConvertToPrimaryIndexPlaceholder ) )
			{
			Call( ErrINFOSetTableColumnInfoList(
					ppib,
					tableid,
					szTableName,
					rgcolumnid,
					&columndef,
					fOrderByColid ) );

			cRows++;
			}
		else if ( fCompacting && ( columndef.grbit & JET_bitColumnRenameConvertToPrimaryIndexPlaceholder ) )
			{

			//	LAURIONB_HACK
			
			g_fCompactTemplateTableColumnDropped = fTrue;
			}
			
		}	// for

	/*	move temporary table cursor to first row and return column list
	/**/
	err = ErrDispMove( (JET_SESID)ppib, tableid, JET_MoveFirst, NO_GRBIT );
	if ( err < 0  )
		{
		if ( err != JET_errNoCurrentRecord )
			goto HandleError;
		err = JET_errSuccess;
		}

	JET_COLUMNLIST	*pcolumnlist;
	pcolumnlist = reinterpret_cast<JET_COLUMNLIST *>( pv );
	pcolumnlist->cbStruct = sizeof(JET_COLUMNLIST);
	pcolumnlist->tableid = tableid;
	pcolumnlist->cRecord = cRows;
	pcolumnlist->columnidPresentationOrder = rgcolumnid[iColumnPOrder];
	pcolumnlist->columnidcolumnname = rgcolumnid[iColumnName];
	pcolumnlist->columnidcolumnid = rgcolumnid[iColumnId];
	pcolumnlist->columnidcoltyp = rgcolumnid[iColumnType];
	pcolumnlist->columnidCountry = rgcolumnid[iColumnCountry];
	pcolumnlist->columnidLangid = rgcolumnid[iColumnLangid];
	pcolumnlist->columnidCp = rgcolumnid[iColumnCp];
	pcolumnlist->columnidCollate = rgcolumnid[iColumnCollate];
	pcolumnlist->columnidcbMax = rgcolumnid[iColumnSize];
	pcolumnlist->columnidgrbit = rgcolumnid[iColumnGrbit];
	pcolumnlist->columnidDefault =	rgcolumnid[iColumnDefault];
	pcolumnlist->columnidBaseTableName = rgcolumnid[iColumnTableName];
	pcolumnlist->columnidBaseColumnName = rgcolumnid[iColumnColumnName];
 	pcolumnlist->columnidDefinitionName = rgcolumnid[iColumnName];

	Assert( NULL != columndef.pbDefault );
	OSMemoryHeapFree( columndef.pbDefault );
	
	return JET_errSuccess;

HandleError:
	(VOID)ErrDispCloseTable( (JET_SESID)ppib, tableid );
	
	//  columndef.pbDefault may be NULL
	OSMemoryHeapFree( columndef.pbDefault );
	
	return err;
	}


LOCAL ERR ErrInfoGetTableColumnInfoBase(
	PIB				*ppib,
	FUCB			*pfucb,
	const CHAR		*szColumnName,
	VOID			*pv,
	const ULONG		cbMax )
	{
	ERR				err;
	INFOCOLUMNDEF	columndef;
	columndef.pbDefault = NULL;

	if ( cbMax < sizeof(JET_COLUMNBASE) || szColumnName == NULL )
		{
		return ErrERRCheck( JET_errInvalidParameter );
		}

	CallR( ErrINFOGetTableColumnInfo( pfucb, szColumnName, &columndef ) );

	Assert( pfucb->u.pfcb->Ptdb() != ptdbNil );

	((JET_COLUMNBASE *)pv)->cbStruct		= sizeof(JET_COLUMNBASE);
	((JET_COLUMNBASE *)pv)->columnid		= columndef.columnid;
	((JET_COLUMNBASE *)pv)->coltyp			= columndef.coltyp;
	((JET_COLUMNBASE *)pv)->wFiller			= 0;
	((JET_COLUMNBASE *)pv)->cbMax			= columndef.cbMax;
	((JET_COLUMNBASE *)pv)->grbit			= columndef.grbit;
	strcpy( ( ( JET_COLUMNBASE *)pv )->szBaseColumnName, szColumnName );
	((JET_COLUMNBASE *)pv)->wCountry		= columndef.wCountry;
	((JET_COLUMNBASE *)pv)->langid  		= columndef.langid;
	((JET_COLUMNBASE *)pv)->cp	   			= columndef.cp;

	pfucb->u.pfcb->EnterDML();
	strcpy( ( ( JET_COLUMNBASE *)pv )->szBaseTableName,
		pfucb->u.pfcb->Ptdb()->SzTableName() );
	pfucb->u.pfcb->LeaveDML();
		
	return JET_errSuccess;
	}


/*=================================================================
ErrIsamGetIndexInfo

Description: Returns a temporary file containing index definition

Parameters:		ppib		   		pointer to PIB for the current session
				ifmp		   		id of database containing the table
				szTableName	 		name of table owning the index
				szIndexName	 		index name
				pv					pointer to result buffer
				cbMax				size of result buffer
				lInfoLevel	 		level of information ( 0, 1, or 2 )

Return Value: JET_errSuccess

Errors/Warnings:

Side Effects:
=================================================================*/
	ERR VDBAPI
ErrIsamGetIndexInfo(
	JET_SESID		vsesid,					/* pointer to PIB for current session */
	JET_DBID		vdbid, 	 				/* id of database containing table */
	const CHAR		*szTable, 				/* name of table owning the index */
	const CHAR		*szIndexName, 			/* index name */
	VOID			*pv,
	unsigned long	cbMax,
	unsigned long	lInfoLevel ) 			/* information level ( 0, 1, or 2 ) */
	{
	ERR				err;
	PIB				*ppib = (PIB *)vsesid;
	IFMP			ifmp;
	CHAR			szTableName[ JET_cbNameMost+1 ];
	FUCB 			*pfucb;

	/*	check parameters
	/**/
	CallR( ErrPIBCheck( ppib ) );
	CallR( ErrPIBCheckIfmp( ppib, (IFMP)vdbid ) );
	ifmp = (IFMP) vdbid;
	CallR( ErrUTILCheckName( szTableName, szTable, ( JET_cbNameMost + 1 ) ) );

	CallR( ErrFILEOpenTable( ppib, ifmp, &pfucb, szTableName, NO_GRBIT ) );
	Assert( pfucbNil != pfucb );
	
	Assert( ( rgfmp[ifmp].FReadOnlyAttach() && !FFUCBUpdatable( pfucb ) )
		|| ( !rgfmp[ifmp].FReadOnlyAttach() && FFUCBUpdatable( pfucb ) ) );
	FUCBResetUpdatable( pfucb );
		
	Call( ErrIsamGetTableIndexInfo(
				(JET_SESID)ppib,
				(JET_VTID)pfucb,
				szIndexName, 
				pv, 
				cbMax, 
				lInfoLevel ) );

HandleError:
	CallS( ErrFILECloseTable( ppib, pfucb ) );
	return err;
	}


/*=================================================================
ErrIsamGetTableIndexInfo

Description: Returns a temporary table containing the index definition

Parameters:		ppib		   		pointer to PIB for the current session
				pfucb		   		FUCB for table owning the index
				szIndexName			index name
				pv					pointer to result buffer
				cbMax				size of result buffer
				lInfoLevel			level of information

Return Value: JET_errSuccess

Errors/Warnings:

Side Effects:
=================================================================*/
	ERR VTAPI
ErrIsamGetTableIndexInfo(
	JET_SESID		vsesid,					/* pointer to PIB for current session */
	JET_VTID		vtid, 					/* FUCB for the table owning the index */
	const CHAR		*szIndex, 				/* index name */
	void			*pb,
	unsigned long	cbMax,
	unsigned long	lInfoLevel )			/* information level ( 0, 1, or 2 ) */
	{
	ERR				err;
	PIB				*ppib			= (PIB *) vsesid;
	FUCB			*pfucb			= (FUCB *) vtid;
	CHAR			szIndexName[JET_cbNameMost+1];

	/*	validate the arguments
	/**/
	CallR( ErrPIBCheck( ppib ) );
	CheckTable( ppib, pfucb );
	if ( szIndex == NULL || *szIndex == '\0' )
		{
		*szIndexName = '\0';
		}
	else
		{
		CallR( ErrUTILCheckName( szIndexName, szIndex, ( JET_cbNameMost + 1 ) ) );
		}

	switch ( lInfoLevel )
		{
		case JET_IdxInfo:
		case JET_IdxInfoList:
			err = ErrINFOGetTableIndexInfo( ppib, pfucb, szIndexName, pb, cbMax );
			break;
		case JET_IdxInfoIndexId:
			Assert( sizeof(JET_INDEXID) == cbMax );
			err = ErrINFOGetTableIndexIdInfo( ppib, pfucb, szIndexName, (INDEXID *)pb );
			break;
		case JET_IdxInfoSpaceAlloc:
			Assert( sizeof(ULONG) == cbMax );
			err = ErrCATGetIndexAllocInfo(
						ppib,
						pfucb->ifmp,
						pfucb->u.pfcb->ObjidFDP(),
						szIndexName,
						(ULONG *)pb );
			break;
		case JET_IdxInfoLCID:
			{
			LCID		lcid;
			Assert( sizeof(LANGID) == cbMax
				|| sizeof(LCID) == cbMax );
			err = ErrCATGetIndexLcid(
						ppib,
						pfucb->ifmp,
						pfucb->u.pfcb->ObjidFDP(),
						szIndexName,
						&lcid );
			if ( cbMax < sizeof(LCID) )
				{
				*(LANGID *)pb = LangidFromLcid( lcid );
				}
			else
				{
				*(LCID *)pb = lcid;
				}
			}
			break;
		case JET_IdxInfoVarSegMac:
			Assert( sizeof(USHORT) == cbMax );
			err = ErrCATGetIndexVarSegMac(
						ppib,
						pfucb->ifmp,
						pfucb->u.pfcb->ObjidFDP(), 
						szIndexName,
						(USHORT *)pb );
			break;
		case JET_IdxInfoCount:
			{
			INT	cIndexes = 1;		// the first index is the primary/sequential index
			FCB	*pfcbT;
			FCB	* const pfcbTable = pfucb->u.pfcb;

			pfcbTable->EnterDML();
			for ( pfcbT = pfcbTable->PfcbNextIndex();
				pfcbT != pfcbNil;
				pfcbT = pfcbT->PfcbNextIndex() )
				{
				err = ErrFILEIAccessIndex( pfucb->ppib, pfcbTable, pfcbT );
				if ( err < 0 )
					{
					if ( JET_errIndexNotFound != err )
						{
						pfcbTable->LeaveDML();
						return err;
						}
					}
				else
					{
					cIndexes++;
					}
				}
			pfcbTable->LeaveDML();

			Assert( sizeof(INT) == cbMax );
			*( (INT *)pb ) = cIndexes;

			err = JET_errSuccess;
			break;
			}

		case JET_IdxInfoSysTabCursor:
		case JET_IdxInfoOLC:
		case JET_IdxInfoResetOLC:
		default:
			Assert( fFalse );		// should be impossible (filtered out by JetGetTableIndexInfo())
			err = ErrERRCheck( JET_errInvalidParameter );
			break;
		}

	return err;
	}


LOCAL ERR ErrINFOGetTableIndexInfo(
	PIB				*ppib,
	FUCB 			*pfucb,
	const CHAR 		*szIndexName,
	VOID			*pv,
	const ULONG		cbMax )
	{
#ifdef	DISPATCHING
	ERR				err;			/* return code from internal functions */
	FCB				*pfcbTable;
	FCB				*pfcbIndex;		/* file control block for the index */
	TDB				*ptdb;			/* field descriptor block for column */

	LONG			cRecord;		/* number of index entries */
	LONG			cKey;			/* number of unique index entries */
	LONG			cPage;			/* number of pages in the index */
	LONG			cRows;			/* number of index definition records */

	JET_TABLEID		tableid;  		/* table id for the VT */
	JET_COLUMNID	columnid;		/* column id of the current column */
	JET_GRBIT		grbit = 0;		/* flags for the current index */
	JET_GRBIT		grbitColumn;	/* flags for the current column */
	JET_COLUMNID	rgcolumnid[ccolumndefGetIndexInfoMax];

	WORD			wCollate = 0;
	WORD			wT;
	LANGID			langid;			/* langid for the current index */
	DWORD			dwMapFlags;		/* LCMapString() flags for the current index */

	Assert( NULL != szIndexName );
	BOOL			fIndexList = ( '\0' == *szIndexName );
	BOOL			fUpdatingLatchSet = fFalse;

	/*	return nothing if the buffer is too small
	/**/
	if ( cbMax < sizeof(JET_INDEXLIST) - cbIDXLISTNewMembersSinceOriginalFormat )
		return ErrERRCheck( JET_wrnBufferTruncated );

	const ULONG		cbIndexList		= sizeof(JET_INDEXLIST) -
										( cbMax < sizeof(JET_INDEXLIST) ? cbIDXLISTNewMembersSinceOriginalFormat : 0 );

	/*	open the temporary table ( fills in the column ids in rgcolumndef )
	/**/
	CallR( ErrIsamOpenTempTable(
				(JET_SESID)ppib,
				(JET_COLUMNDEF *)rgcolumndefGetIndexInfo,
				ccolumndefGetIndexInfoMax,
				NULL,
				JET_bitTTScrollable|JET_bitTTIndexed,
				&tableid,
				rgcolumnid ) );

	cRows = 0;
	
	/*	set the pointer to the field definitions for the table
	/**/
	pfcbTable = pfucb->u.pfcb;
	Assert( pfcbTable != pfcbNil );

	ptdb = pfcbTable->Ptdb();
	Assert( ptdbNil != ptdb );

	// Treat this as an update (but ignore write conflicts), to freeze index list.
	Call( pfcbTable->ErrSetUpdatingAndEnterDML( ppib, fTrue ) );
	fUpdatingLatchSet = fTrue;

	/*	locate the FCB for the specified index ( if null name, get list of indexes )
	/**/
	pfcbTable->AssertDML();
	for ( pfcbIndex = pfcbTable; pfcbIndex != pfcbNil; pfcbIndex = pfcbIndex->PfcbNextIndex() )
		{
		// Only primary index may not have an IDB.
		Assert( pfcbIndex->Pidb() != pidbNil || pfcbIndex == pfcbTable );
		
		if ( pfcbIndex->Pidb() != pidbNil )
			{
			if ( fIndexList )
				{
				err = ErrFILEIAccessIndex( ppib, pfcbTable, pfcbIndex );
				}
			else
				{
				Assert( NULL != szIndexName );
				err = ErrFILEIAccessIndexByName( ppib, pfcbTable, pfcbIndex, szIndexName );
				}
			if ( err < 0 )
				{
				if ( JET_errIndexNotFound != err )
					{
					pfcbTable->LeaveDML();
					goto HandleError;
					}
				}
			else
				break;		// The index is accessible
			}
		}
		
	pfcbTable->AssertDML();
	
	if ( pfcbNil == pfcbIndex && !fIndexList )
		{
		pfcbTable->LeaveDML();
		err = ErrERRCheck( JET_errIndexNotFound );
		goto HandleError;
		}
	
	/*	as long as there is a valid index, add its definition to the VT
	/**/
	while ( pfcbIndex != pfcbNil )
		{
		CHAR	szCurrIndex[JET_cbNameMost+1];
		IDXSEG	rgidxseg[JET_ccolKeyMost];
		
		pfcbTable->AssertDML();
		
		const IDB		*pidb = pfcbIndex->Pidb();
		Assert( pidbNil != pidb );

		Assert( pidb->ItagIndexName() != 0 );
		strcpy(
			szCurrIndex,
			pfcbTable->Ptdb()->SzIndexName( pidb->ItagIndexName(), pfcbIndex->FDerivedIndex() ) );

		const LONG		cColumn	= pidb->Cidxseg();		/* get number of columns in the key */
		UtilMemCpy( rgidxseg, PidxsegIDBGetIdxSeg( pidb, pfcbTable->Ptdb() ), cColumn * sizeof(IDXSEG) );

		/*	set the index flags
		/**/
		grbit = pidb->GrbitFromFlags();
		langid = LangidFromLcid( pidb->Lcid() );
		dwMapFlags = pidb->DwLCMapFlags();
				
		pfcbTable->LeaveDML();

		/*	process each column in the index key
		/**/
		for ( ULONG iidxseg = 0; iidxseg < cColumn; iidxseg++ )
			{
			FIELD	field;
			CHAR	szFieldName[JET_cbNameMost+1];
			
			Call( ErrDispPrepareUpdate( (JET_SESID)ppib, tableid, JET_prepInsert ) );

			/* index name
			/**/
			Call( ErrDispSetColumn(
						(JET_SESID)ppib,
						tableid,
						rgcolumnid[iIndexName],
						szCurrIndex,
						(ULONG)strlen( szCurrIndex ),
						NO_GRBIT,
						NULL ) );

			/*	index flags
			/**/
			Call( ErrDispSetColumn(
						(JET_SESID)ppib,
						tableid,
						rgcolumnid[iIndexGrbit], 
						&grbit, 
						sizeof( grbit ), 
						NO_GRBIT,
						NULL ) );

			/*	get statistics
			/**/
			Call( ErrSTATSRetrieveIndexStats(
						pfucb,
						szCurrIndex, 
						pfcbIndex->FPrimaryIndex(), 
						&cRecord, 
						&cKey, 
						&cPage ) );
			Call( ErrDispSetColumn(
						(JET_SESID)ppib, 
						tableid,
						rgcolumnid[iIndexCKey], 
						&cKey, 
						sizeof( cKey ), 
						NO_GRBIT,
						NULL ) );
			Call( ErrDispSetColumn( 
						(JET_SESID)ppib, 
						tableid,
						rgcolumnid[iIndexCEntry], 
						&cRecord, 
						sizeof( cRecord ), 
						NO_GRBIT, 
						NULL ) );
			Call( ErrDispSetColumn( 
						(JET_SESID)ppib, 
						tableid,
						rgcolumnid[iIndexCPage], 
						&cPage, 
						sizeof( cPage ), 
						NO_GRBIT,
						NULL ) );

			/*	number of key columns
			/**/
			Call( ErrDispSetColumn( 
						(JET_SESID)ppib, 
						tableid,
						rgcolumnid[iIndexCCol], 
						&cColumn, 
						sizeof( cColumn ), 
						NO_GRBIT, 
						NULL ) );

 			/*	column number within key
			/*	required by CLI and JET spec
			/**/
			Call( ErrDispSetColumn(
						(JET_SESID)ppib, 
						tableid,
						rgcolumnid[iIndexICol], 
						&iidxseg, 
						sizeof( iidxseg ), 
						NO_GRBIT,
						NULL ) );

			/*	get the ascending/descending flag
			/**/
			grbitColumn = ( rgidxseg[iidxseg].FDescending() ?
								JET_bitKeyDescending :
								JET_bitKeyAscending );

			/*	column id
			/**/
			columnid  = rgidxseg[iidxseg].Columnid();
			Call( ErrDispSetColumn(
						(JET_SESID)ppib, 
						tableid,
						rgcolumnid[iIndexColId], 
						&columnid, 
						sizeof( columnid ),
						0, 
						NULL ) );

			/*	make copy of column definition
			/**/
			if ( FCOLUMNIDTemplateColumn( columnid ) && !ptdb->FTemplateTable() )
				{
				ptdb->AssertValidDerivedTable();
				
				const TDB	* const ptdbTemplateTable = ptdb->PfcbTemplateTable()->Ptdb();
				
				field = *( ptdbTemplateTable->Pfield( columnid ) );
				strcpy( szFieldName, ptdbTemplateTable->SzFieldName( field.itagFieldName, fFalse ) );
				}
			else
				{
				pfcbTable->EnterDML();
				field = *( ptdb->Pfield( columnid ) );
				strcpy( szFieldName, ptdb->SzFieldName( field.itagFieldName, fFalse ) );
				pfcbTable->LeaveDML();
				}

			/*	column type
			/**/
				{
				JET_COLTYP coltyp = field.coltyp; // just to resize the variable from 2 to 4 bytes width
				Call( ErrDispSetColumn(
							(JET_SESID)ppib, 
							tableid,
							rgcolumnid[iIndexColType], 
							&coltyp, 
							sizeof( coltyp ), 
							NO_GRBIT,
							NULL ) );
				}

			/*	Country
			/**/
			wT = countryDefault;
			Call( ErrDispSetColumn(
						(JET_SESID)ppib, 
						tableid,
						rgcolumnid[iIndexCountry], 
						&wT, 
						sizeof( wT ), 
						NO_GRBIT, 
						NULL ) );

			/*	Langid
			/**/
			Call( ErrDispSetColumn( 
						(JET_SESID)ppib, 
						tableid,
						rgcolumnid[iIndexLangid], 
						&langid, 
						sizeof( langid ),
						NO_GRBIT,
						NULL ) );

			/*	LCMapStringFlags
			/**/
			Call( ErrDispSetColumn( 
						(JET_SESID)ppib, 
						tableid,
						rgcolumnid[iIndexLCMapFlags], 
						&dwMapFlags, 
						sizeof( dwMapFlags ),
						NO_GRBIT,
						NULL ) );

			/*	Cp
			/**/
			Call( ErrDispSetColumn( 
						(JET_SESID)ppib, 
						tableid,
						rgcolumnid[iIndexCp], 
						&field.cp, 
						sizeof(field.cp), 
						NO_GRBIT,
						NULL ) );

			/* Collate
			/**/
			Call( ErrDispSetColumn( 
						(JET_SESID)ppib, 
						tableid,
						rgcolumnid[iIndexCollate], 
						&wCollate, 
						sizeof(wCollate), 
						NO_GRBIT,
						NULL ) );

			/* column flags
			/**/
			Call( ErrDispSetColumn( 
						(JET_SESID)ppib, 
						tableid,
						rgcolumnid[iIndexColBits], 
						&grbitColumn,
						sizeof( grbitColumn ), 
						NO_GRBIT,
						NULL ) );

			/*	column name
			/**/
			Call( ErrDispSetColumn(
						(JET_SESID)ppib, 
						tableid,
						rgcolumnid[iIndexColName], 
						szFieldName,
						(ULONG)strlen( szFieldName ), 
						NO_GRBIT,
						NULL ) );

			Call( ErrDispUpdate( (JET_SESID)ppib, tableid, NULL, 0, NULL, NO_GRBIT ) );

			/* count the number of VT rows
			/**/
			cRows++;
			}

		/*	quit if an index name was specified; otherwise do the next index
		/**/
		pfcbTable->EnterDML();
		if ( fIndexList )
			{
			for ( pfcbIndex = pfcbIndex->PfcbNextIndex(); pfcbIndex != pfcbNil; pfcbIndex = pfcbIndex-> PfcbNextIndex() )
				{
				err = ErrFILEIAccessIndex( ppib, pfcbTable, pfcbIndex );
				if ( err < 0 )
					{
					if ( JET_errIndexNotFound != err )
						{
						pfcbTable->LeaveDML();
						goto HandleError;
						}
					}
				else
					break;	// The index is accessible.
				}
			}
		else
			{
			pfcbIndex = pfcbNil;
			}
		}	// while ( pfcbIndex != pfcbNil )
		
	pfcbTable->ResetUpdatingAndLeaveDML();
	fUpdatingLatchSet = fFalse;

	/*	position to the first entry in the VT ( ignore error if no rows )
	/**/
	err = ErrDispMove( (JET_SESID)ppib, tableid, JET_MoveFirst, NO_GRBIT );
	if ( err < 0  )
		{
		if ( err != JET_errNoCurrentRecord )
			goto HandleError;
		err = JET_errSuccess;
		}

	/*	set up the return structure
	/**/
	((JET_INDEXLIST *)pv)->cbStruct = cbIndexList;
	((JET_INDEXLIST *)pv)->tableid = tableid;
	((JET_INDEXLIST *)pv)->cRecord = cRows;
	((JET_INDEXLIST *)pv)->columnidindexname = rgcolumnid[iIndexName];
	((JET_INDEXLIST *)pv)->columnidgrbitIndex = rgcolumnid[iIndexGrbit];
	((JET_INDEXLIST *)pv)->columnidcEntry = rgcolumnid[iIndexCEntry];
	((JET_INDEXLIST *)pv)->columnidcKey = rgcolumnid[iIndexCKey];
	((JET_INDEXLIST *)pv)->columnidcPage = rgcolumnid[iIndexCPage];
	((JET_INDEXLIST *)pv)->columnidcColumn = rgcolumnid[iIndexCCol];
	((JET_INDEXLIST *)pv)->columnidiColumn = rgcolumnid[iIndexICol];
	((JET_INDEXLIST *)pv)->columnidcolumnid = rgcolumnid[iIndexColId];
	((JET_INDEXLIST *)pv)->columnidcoltyp = rgcolumnid[iIndexColType];
	((JET_INDEXLIST *)pv)->columnidCountry = rgcolumnid[iIndexCountry];
	((JET_INDEXLIST *)pv)->columnidLangid = rgcolumnid[iIndexLangid];
	((JET_INDEXLIST *)pv)->columnidCp = rgcolumnid[iIndexCp];
	((JET_INDEXLIST *)pv)->columnidCollate = rgcolumnid[iIndexCollate];
	((JET_INDEXLIST *)pv)->columnidgrbitColumn = rgcolumnid[iIndexColBits];
	((JET_INDEXLIST *)pv)->columnidcolumnname = rgcolumnid[iIndexColName];

	if ( cbIndexList < sizeof(JET_INDEXLIST) )
		{
		Assert( cbMax >= sizeof(JET_INDEXLIST) - cbIDXLISTNewMembersSinceOriginalFormat );
		}
	else
		{
		Assert( cbMax >= sizeof(JET_INDEXLIST) );
		((JET_INDEXLIST *)pv)->columnidLCMapFlags = rgcolumnid[iIndexLCMapFlags];
		}

	return JET_errSuccess;

HandleError:
	if ( fUpdatingLatchSet )
		{
		pfcbTable->ResetUpdating();
		}
	(VOID)ErrDispCloseTable( (JET_SESID)ppib, tableid );
	return err;
#else	/* !DISPATCHING */
	Assert( fFalse );
	return ErrERRCheck( JET_errFeatureNotAvailable );
#endif	/* !DISPATCHING */
	}

LOCAL ERR ErrINFOGetTableIndexIdInfo(
	PIB					* ppib,
	FUCB				* pfucb,
	const CHAR			* szIndexName,
	INDEXID				* pindexid )
	{
	ERR					err;
	FCB					* const pfcbTable	= pfucb->u.pfcb;
	FCB					* pfcbIndex;

	Assert( NULL != szIndexName );

	/*	set the pointer to the field definitions for the table
	/**/
	Assert( pfcbTable != pfcbNil );

	// Treat this as an update (but ignore write conflicts), to freeze index list.
	CallR( pfcbTable->ErrSetUpdatingAndEnterDML( ppib, fTrue ) );

	/*	locate the FCB for the specified index ( if null name, get list of indexes )
	/**/
	pfcbTable->AssertDML();
	for ( pfcbIndex = pfcbTable; pfcbIndex != pfcbNil; pfcbIndex = pfcbIndex->PfcbNextIndex() )
		{
		// Only primary index may not have an IDB.
		Assert( pfcbIndex->Pidb() != pidbNil || pfcbIndex == pfcbTable );
		
		if ( pfcbIndex->Pidb() != pidbNil )
			{
			err = ErrFILEIAccessIndexByName(
						ppib,
						pfcbTable,
						pfcbIndex,
						szIndexName );
			if ( err < 0 )
				{
				if ( JET_errIndexNotFound != err )
					{
					goto HandleError;
					}
				}
			else
				{
				CallS( err );
				break;		// The index is accessible
				}
			}
		}

	pfcbTable->AssertDML();

	if ( pfcbNil == pfcbIndex )
		{
		err = ErrERRCheck( JET_errIndexNotFound );
		}
	else
		{
		CallS( err );

		Assert( pfcbIndex->FValid( PinstFromPpib( ppib ) ) );

		Assert( sizeof(INDEXID) == sizeof(JET_INDEXID) );
		pindexid->cbStruct = sizeof(INDEXID);
		pindexid->pfcbIndex = pfcbIndex;
		pindexid->objidFDP = pfcbIndex->ObjidFDP();
		pindexid->pgnoFDP = pfcbIndex->PgnoFDP();
		}

HandleError:
	pfcbTable->AssertDML();
	pfcbTable->ResetUpdatingAndLeaveDML();

	return err;
	}


ERR VDBAPI ErrIsamGetDatabaseInfo(
	JET_SESID		vsesid,
	JET_DBID		vdbid,
	VOID			*pvResult,
	const ULONG		cbMax,
	const ULONG		ulInfoLevel )
	{
	PIB				*ppib = (PIB *)vsesid;
	ERR				err;
	IFMP			ifmp;
	//	UNDONE:	support these fields;
	WORD 			cp			= usEnglishCodePage;
	WORD			wCountry	= countryDefault;
	WORD			wCollate	= 0;

	/*	check parameters
	/**/
	CallR( ErrPIBCheck( ppib ) );
	CallR( ErrPIBCheckIfmp( ppib, (IFMP)vdbid ) );
	ifmp = (IFMP) vdbid;
	
	Assert ( cbMax == 0 || pvResult != NULL );

	//	UNDONE:	move access to FMP internals into io.c for proper MUTEX.
	//			Please note that below is a bug.

	/*	returns database name and connect string given ifmp
	/**/
	if ( ifmp >= ifmpMax || !rgfmp[ifmp].FInUse()  )
		{
		err = ErrERRCheck( JET_errInvalidParameter );
		goto HandleError;
		}

	switch ( ulInfoLevel )
		{
		case JET_DbInfoFilename:
			if ( strlen( rgfmp[ifmp].SzDatabaseName() ) + 1UL > cbMax )
				{
				err = ErrERRCheck( JET_errBufferTooSmall );
				goto HandleError;
				}
			strcpy( (CHAR  *)pvResult, rgfmp[ifmp].SzDatabaseName() );
			break;

		case JET_DbInfoConnect:
			if ( 1UL > cbMax )
				{
				err = ErrERRCheck( JET_errBufferTooSmall );
				goto HandleError;
				}
			*(CHAR *)pvResult = '\0';
			break;

		case JET_DbInfoCountry:
			 if ( cbMax != sizeof(long) )
			    return ErrERRCheck( JET_errInvalidBufferSize );
			*(long  *)pvResult = wCountry;
			break;

		case JET_DbInfoLCID:
			if ( cbMax != sizeof(long) )
	  			return ErrERRCheck( JET_errInvalidBufferSize );
			*(long  *)pvResult = idxunicodeDefault.lcid;
			break;

		case JET_DbInfoCp:
			if ( cbMax != sizeof(long) )
				return ErrERRCheck( JET_errInvalidBufferSize );
			*(long  *)pvResult = cp;
			break;

		case JET_DbInfoCollate:
	 		/*	check the buffer size
			/**/
	 		if ( cbMax != sizeof(long) )
	    		return ErrERRCheck( JET_errInvalidBufferSize );
     		*(long *)pvResult = wCollate;
     		break;

		case JET_DbInfoOptions:
	 		/*	check the buffer size
			/**/
	 		if ( cbMax != sizeof(JET_GRBIT) )
	    		return ErrERRCheck( JET_errInvalidBufferSize );

			/*	return the open options for the current database
			/**/
			*(JET_GRBIT *)pvResult = rgfmp[ifmp].FExclusiveBySession( ppib ) ? JET_bitDbExclusive : 0;
     		break;

		case JET_DbInfoTransactions:
	 		/*	check the buffer size
			/**/
	 		if ( cbMax != sizeof(long) )
	    		return ErrERRCheck( JET_errInvalidBufferSize );

			*(long*)pvResult = levelUserMost;
     		break;

		case JET_DbInfoVersion:
	 		/*	check the buffer size
			/**/
	 		if ( cbMax != sizeof(long) )
	    		return ErrERRCheck( JET_errInvalidBufferSize );

			*(long *)pvResult = ulDAEVersion;
     		break;

		case JET_DbInfoIsam:
	 		/*	check the buffer size
			/**/
    		return ErrERRCheck( JET_errFeatureNotAvailable );

	    case JET_DbInfoMisc:
	    	if ( sizeof( JET_DBINFOMISC ) != cbMax )
		    		return ErrERRCheck( JET_errInvalidBufferSize );
	    	FillClientBuffer( pvResult, cbMax );
			UtilLoadDbinfomiscFromPdbfilehdr( (JET_DBINFOMISC *) pvResult, rgfmp[ ifmp ].Pdbfilehdr() );
			break;
			
		case JET_DbInfoPageSize:
			if ( sizeof( ULONG ) != cbMax )
				{
				err = ErrERRCheck( JET_errBufferTooSmall );
				goto HandleError;
				}
			
			*(ULONG *)pvResult = ( 0 != rgfmp[ifmp].Pdbfilehdr()->le_cbPageSize ?
											rgfmp[ifmp].Pdbfilehdr()->le_cbPageSize :
											cbPageDefault );
			break;

		case JET_DbInfoFilesize:
		case JET_DbInfoSpaceOwned:
			// Return file size in terms of 4k pages.
			if ( cbMax != sizeof(ULONG) )
				return ErrERRCheck( JET_errInvalidBufferSize );

#ifdef DEBUG
			// FMP should store agree with database's OwnExt tree.
			CallS( ErrSPGetInfo(
						ppib,
						ifmp,
						pfucbNil,
						static_cast<BYTE *>( pvResult ),
						cbMax,
						fSPOwnedExtent ) );
			Assert( *(ULONG *)pvResult == ULONG( rgfmp[ifmp].PgnoLast() ) );
#endif			

			// If filesize, add DB header.
			*(ULONG *)pvResult =
				ULONG( rgfmp[ifmp].PgnoLast() ) +
				( ulInfoLevel == JET_DbInfoFilesize ? cpgDBReserved : 0 );
			break;

		case JET_DbInfoSpaceAvailable:
			err = ErrSPGetInfo(
						ppib,
						ifmp,
						pfucbNil,
						static_cast<BYTE *>( pvResult ),
						cbMax,
						fSPAvailExtent );
			return err;
		case JET_DbInfoHasSLVFile:
			if ( sizeof( BOOL ) != cbMax )
				{
				err = ErrERRCheck( JET_errBufferTooSmall );
				goto HandleError;
				}
			*(BOOL *)pvResult = !!rgfmp[ ifmp ].Pdbfilehdr()->FSLVExists();
			break;

/* UNDONE: remove on code scrub
		case JET_DbInfoStreamingFileSpace:
			if ( sizeof( JET_STREAMINGFILESPACEINFO ) != cbMax )
				{
				return ErrERRCheck( JET_errInvalidBufferSize );
				}
			{
			JET_STREAMINGFILESPACEINFO *const pssi = static_cast< JET_STREAMINGFILESPACEINFO* >( pvResult );
			Call( ErrSLVGetSpaceInformation(	ppib, 
												ifmp, 
												(CPG*)&pssi->cpageOwned, 
												(CPG*)&pssi->cpageAvail ) );
			}
			break;
*/
		default:
			 return ErrERRCheck( JET_errInvalidParameter );
		}

	err = JET_errSuccess;
HandleError:
	return err;
	}


ERR VTAPI ErrIsamGetCursorInfo(
	JET_SESID 		vsesid,
	JET_VTID   		vtid,
	void 	   		*pvResult,
	unsigned long 	cbMax,
	unsigned long 	InfoLevel )
	{
	ERR				err;
	PIB				*ppib	= (PIB *)vsesid;
	FUCB			*pfucb	= (FUCB *)vtid;
	VS				vs;

	CallR( ErrPIBCheck( ppib ) );
	CheckFUCB( pfucb->ppib, pfucb );

	if ( cbMax != 0 || InfoLevel != 0 )
		return ErrERRCheck( JET_errInvalidParameter );

	if ( pfucb->locLogical != locOnCurBM )
		return ErrERRCheck( JET_errNoCurrentRecord );

	//	check if this record is being updated by another cursor
	//
	Assert( !Pcsr( pfucb )->FLatched() );
	
	Call( ErrDIRGet( pfucb ) );
	if ( FNDVersion( pfucb->kdfCurr ) )
		{
		vs = VsVERCheck( pfucb, pfucb->bmCurr );
		if ( vs == vsUncommittedByOther )
			{
			CallS( ErrDIRRelease( pfucb ) );
			return ErrERRCheck( JET_errWriteConflict );
			}
		}

	CallS( ErrDIRRelease( pfucb ) );

	//	temporary tables are never visible to other sessions
	//
	if ( pfucb->u.pfcb->FTypeTemporaryTable() )
		err = JET_errSuccess;

HandleError:
	return err;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ese98\src\ese\logdiff.cxx ===
#include "std.hxx"

class TAGFIELDS_DUMP : public TAGFIELDS
	{
	ULONG m_itagfld;

	enum { iInvalidState = -1 };

	const DATA* m_pData;
public:
	TAGFIELDS_DUMP( const DATA& dataRec ) : TAGFIELDS( dataRec ) { m_itagfld = iInvalidState; m_pData = &dataRec; }
	virtual ~TAGFIELDS_DUMP() {}
	
	BOOL FIsValidTagField() const { return ( m_itagfld != iInvalidState )? fTrue: fFalse; }
	const BYTE *PbTagColumnsHeader() const { return (const BYTE *)TAGFIELDS::PbTaggedColumns(); }
	ULONG CbTagColumnsHeaderSize() const { return TAGFIELDS::CTaggedColumns()*sizeof( TAGFLD ); }
	FID GetFID() const { Assert( FIsValidTagField() ); return TAGFIELDS::Fid( m_itagfld ); }
	const BYTE *PbData() const { Assert( FIsValidTagField() ); return ( const BYTE *)TAGFIELDS::PbData( m_itagfld ); }
	ULONG CbData() const { Assert( FIsValidTagField() ); return TAGFIELDS::CbData( m_itagfld ); }
	VOID FindFirstTagField() { m_itagfld = TAGFIELDS::CTaggedColumns() != 0? 0: iInvalidState; }
	VOID FindNextTagField() { Assert( FIsValidTagField() ); m_itagfld = ( m_itagfld+1 < TAGFIELDS::CTaggedColumns() )? m_itagfld+1: iInvalidState; }
	SIZE_T IbDataOffset() const { Assert( FIsValidTagField() ); return PbData() - (const BYTE *)m_pData->Pv(); }
	SIZE_T CbRestData() const { Assert( FIsValidTagField() ); return m_pData->Cb() - IbDataOffset(); }
	INT	Compare( const TAGFIELDS_DUMP &tfd ) const { Assert( FIsValidTagField() ); Assert( tfd.FIsValidTagField() ); return TAGFIELDS::TagFldCmp( Ptagfld( m_itagfld ), tfd.Ptagfld( tfd.m_itagfld ) ); }
	};


///#define DISABLE_LOGDIFF

#ifdef DEBUG
//	Dump diffs
//
VOID LGDumpDiff ( BYTE *pbDiff, INT cbDiff )
	{
	BYTE *pbDiffCur = pbDiff;
	BYTE *pbDiffMax = pbDiff + cbDiff;

	while ( pbDiffCur < pbDiffMax )
		{
		INT	ibOffsetOld;
		INT cbDataNew;

		DIFFHDR diffhdr = *( (DIFFHDR*) pbDiffCur );
		pbDiffCur += sizeof( DIFFHDR );

		ibOffsetOld = ( diffhdr.m_bitfield & DIFFHDR::ibOffsetMask ) >> DIFFHDR::ibOffsetShf;
		DBGprintf( "\n[ Offs:%u ", ibOffsetOld );

		if ( diffhdr.m_bitfield & DIFFHDR::fUseTwoBytesForDataLength )
			{
			DBGprintf( "2B " );
			cbDataNew = *( (UnalignedLittleEndian< WORD >*) pbDiffCur );
			pbDiffCur += sizeof( WORD );
			}
		else
			{
			DBGprintf( "1B " );
			cbDataNew = *( (UnalignedLittleEndian< BYTE >*) pbDiffCur );
			pbDiffCur += sizeof( BYTE );
			}
		
		if ( diffhdr.m_bitfield & DIFFHDR::fInsert )
			{
			DBGprintf( "InsertWithValue (%u): ", cbDataNew );
			ShowData( pbDiffCur, cbDataNew );
			pbDiffCur += cbDataNew;
			}
		else
			{
			if ( diffhdr.m_bitfield & DIFFHDR::fReplaceWithSameLength )
				{
				DBGprintf( "ReplaceWithSameLength (%u): ", cbDataNew );
				ShowData( pbDiffCur, cbDataNew );
				pbDiffCur += cbDataNew;
				}
			else
				{
				INT cbDataOld;

				if ( diffhdr.m_bitfield & DIFFHDR::fUseTwoBytesForDataLength )
					{
					cbDataOld = *( (UnalignedLittleEndian< WORD >*) pbDiffCur );
					pbDiffCur += sizeof( WORD );
					}
				else
					{
					cbDataOld = *( (UnalignedLittleEndian< BYTE >*) pbDiffCur );
					pbDiffCur += sizeof( BYTE );
					}
				
				DBGprintf( "ReplaceWithNewValue (%u=>%u): ", cbDataOld, cbDataNew );
				ShowData( pbDiffCur, cbDataNew );
				pbDiffCur += cbDataNew;
				}
			}

		DBGprintf( "]" );
		
		Assert( pbDiffCur <= pbDiffMax );
		}

	DBGprintf( "\n                 " );
	}
#endif



//	cbDataOld == 0 ----------------------> insertion.
//	cbDataNew == 0 ----------------------> deletion.
//	cbDataOld != 0 && cbDataNew != 0 ----> replace.
//
//	Fomat: DiffHdr - cbDataNew - [cbDataOld] - [NewData]
//

BOOL FLGAppendDiff(
	BYTE		**ppbCur,		// diff to append
	BYTE		*pbMax,			// max of pbCur to append
	const SIZE_T	ibOffsetOld,
	const SIZE_T	cbDataOld,
	const SIZE_T	cbDataNew,
	const BYTE	*pbDataNew )
	{
	//  validate IN args
	
	Assert( pbNil != pbDataNew || cbDataNew == 0 );
	Assert( REC::CbRecordMax() < g_cbColumnLVChunkMost );
	Assert( ibOffsetOld + cbDataOld >= ibOffsetOld );
	Assert( ibOffsetOld + cbDataOld <= g_cbColumnLVChunkMost );

	//  setup diffhdr
	DIFFHDR		diffhdr;
	const WORD	wBitField	= WORD( ( ( ibOffsetOld << DIFFHDR::ibOffsetShf ) & DIFFHDR::ibOffsetMask ) |
								(	cbDataOld != 0 && cbDataOld == cbDataNew ?
										DIFFHDR::fReplaceWithSameLength :
										0 ) |
								(	cbDataOld == 0 ?
										DIFFHDR::fInsert :
										0 ) |
								(	cbDataOld > 255 || cbDataNew > 255 ?
										DIFFHDR::fUseTwoBytesForDataLength :
										0 ) );

	diffhdr.m_bitfield = wBitField;

	//  check for truncation of the offset by too small of a bit field

	Assert( ( ( wBitField & DIFFHDR::ibOffsetMask ) >> DIFFHDR::ibOffsetShf ) == ibOffsetOld );

	//  compute the size of our data length storage.  we will need two data lengths
	//  if we are replacing with a different length:  one for the initial length
	//  and one for the final length

	const BOOL	fReplaceWithDiffLength	= !( wBitField & DIFFHDR::fReplaceWithSameLength )
											&& !( wBitField & DIFFHDR::fInsert );
	const ULONG	cbBytesForDataLength	= ( wBitField & DIFFHDR::fUseTwoBytesForDataLength ? 2 : 1 )
											* ( fReplaceWithDiffLength ? 2 : 1 );

	//	bail if the diff is too big to fit in the user's buffer

	BYTE	* pbCur	= *ppbCur;
	if ( ( pbCur + sizeof( DIFFHDR ) + cbBytesForDataLength + cbDataNew ) > pbMax )
		{
		return fFalse;
		}

	//  copy the diffhdr into the user's buffer

	*( (DIFFHDR*) pbCur ) = diffhdr;
	pbCur += sizeof( DIFFHDR );

	//  copy the data length(s) into the user's buffer

	if ( wBitField & DIFFHDR::fUseTwoBytesForDataLength )
		{
		*( (UnalignedLittleEndian< WORD >*) pbCur ) = (WORD)cbDataNew;
		pbCur += sizeof( WORD );
		
		if ( fReplaceWithDiffLength )
			{
			*( (UnalignedLittleEndian< WORD >*) pbCur ) = (WORD)cbDataOld;
			pbCur += sizeof( WORD );
			}
		}
	else
		{
		*( (UnalignedLittleEndian< BYTE >*) pbCur ) = (BYTE)cbDataNew;
		pbCur += sizeof( BYTE );
		
		if ( fReplaceWithDiffLength )
			{
			*( (UnalignedLittleEndian< BYTE >*) pbCur ) = (BYTE)cbDataOld;
			pbCur += sizeof( BYTE );
			}
		}

	//  copy the new data into the user's buffer
	
	UtilMemCpy( pbCur, pbDataNew, cbDataNew );
	pbCur += cbDataNew;

	//  return a pointer past the end of the section of the user's buffer that
	//  we consumed

	*ppbCur = pbCur;
	return fTrue;
	}

// Store header array of tagged fields
//
BOOL FLGSetArrayDiff( 
const BYTE * pbDataBegin,
const BYTE * const pbOld, 
const BYTE * const pbNew, 
const ULONG cbOld, 
const ULONG cbNew, 
BYTE ** ppbDiff, 
BYTE * pbDiffMaxTotal )
	{
	Assert( pbOld != NULL || cbOld == 0 );
	Assert( pbNew != NULL || cbNew == 0 );
	Assert( ppbDiff != NULL && *ppbDiff != NULL );
	Assert( pbDiffMaxTotal != NULL );
	Assert( (cbOld % sizeof( DWORD )) == 0 );
	Assert( (cbNew % sizeof( DWORD )) == 0 );
	Assert( (sizeof( TAGFLD ) %sizeof( DWORD )) == 0 );
	
	INT cbMinSize = cbOld;
	BOOL fTruncate, fEndIsReached;
	fTruncate = fFalse;
	fEndIsReached = fFalse;	//	if during comparision ends of both blocks are reached
	if ( cbMinSize > cbNew ) 
		{
		cbMinSize = cbNew;
		fTruncate = fTrue;
		}
	else if ( cbMinSize == cbNew )
		{
		fEndIsReached = fTrue;
		}

	Unaligned< DWORD > *pdwOldCur	= ( Unaligned< DWORD > * )pbOld;
	Unaligned< DWORD > *pdwOldMax	= pdwOldCur + ( cbMinSize / sizeof( DWORD ) );
	Unaligned< DWORD > *pdwNewCur	= ( Unaligned< DWORD > * )pbNew;
	Assert ( (BYTE *)(pdwOldCur + 1) - (BYTE *)pdwOldCur == 4 );
	
	//	establish diff buffer and
	//	ensure that diff record is no bigger than the after-image 
	//	(otherwise, it's cheaper just to log the entire after-image).
	BYTE	*pbDiffCur = *ppbDiff;
	BYTE	*pbDiffMax = pbDiffCur + cbNew;

	while ( pdwOldCur < pdwOldMax )
		{
		if ( *pdwOldCur == *pdwNewCur )
			{
			pdwOldCur++;
			pdwNewCur++;
			}
		else
			{
			//	store the offset
			//
			Assert( (const BYTE *)pdwOldCur >= pbOld );
			const SIZE_T ibOld		= (BYTE *)pdwOldCur - pbDataBegin;
			const BYTE	*pbNewData	= (BYTE *)pdwNewCur;
			SIZE_T		cbNewData	= sizeof( DWORD );
			pdwOldCur++;
			pdwNewCur++;
				//	compare 4 bytes at a time until data streams re-sync
			while ( pdwOldCur < pdwOldMax && *pdwOldCur != *pdwNewCur )
				{
				cbNewData += sizeof( DWORD );
				pdwOldCur ++;
				pdwNewCur ++;
				}

			//	if end of comparision block is reached
			//	check if should truncate ot expand the size of chunk
			SIZE_T cbOldData = cbNewData;
			if ( pdwOldCur == pdwOldMax )
				{
				if ( fTruncate )
					{
					cbOldData += cbOld - cbMinSize;
					}
				else
					{
					cbNewData += cbNew - cbMinSize;
					}
				fEndIsReached = fTrue;	//	the differences are completly set
				}
			else
				{
				// it is reached place there two datas are equal
				// so those DWORDs can be skipped
				pdwOldCur++;
				pdwNewCur++;
				}
			
			if ( !FLGAppendDiff(
					&pbDiffCur,
					pbDiffMax,					// max of pbCur to append
					ibOld,						// offset to old image
					cbOldData,					// length of the old image
					cbNewData,					// length of the new image
					pbNewData					// pbDataNew
					) )
				{
				goto LogAll;
				}
			}
		}

	Assert( pdwOldMax == pdwOldCur );
		
	if ( !fEndIsReached )
		{
		//	Different size of arrays
		//
		if ( !FLGAppendDiff(
					&pbDiffCur,
					pbDiffMax,						//	max of pbCur to append
					cbMinSize + pbOld - pbDataBegin,	//	offset to old image
					cbOld - cbMinSize,				//	length of the old image
					cbNew - cbMinSize,				//	length of the new image
					(const BYTE *)pdwNewCur ) )		//	pbDataNew
			{
			goto LogAll;
			}
		}
	*ppbDiff = pbDiffCur;
	return fTrue;
		
	LogAll:
		//	if logging differences is more expensive than
		//	logging all array
	return FLGAppendDiff(
			ppbDiff,
			pbDiffMaxTotal,		//	max of pbCur to append
			pbOld - pbDataBegin,	//	offset to old image
			cbOld,				//	length of the old image
			cbNew,				//	length of the new image
			pbNew );			//	pbDataNew
	}

//	Go through each column, compare the before image and after image of each column.
//

//  UNDONE:  Currently, we look at the rgbitSet bit array to detect if a column has
//  been set.  Since these bits no longer uniquely identify a particular column as
//  being set, we must compare the BI and the change for a difference for each column
//  set, and then only log if there is an actual change.

VOID LGSetColumnDiffs(
	FUCB		*pfucb,
	const DATA&	dataNew,
	const DATA&	dataOld,
	BYTE		*pbDiff,
	SIZE_T		*pcbDiff )
	{
	FID			fid;
	
	//	Initialize return value
	Assert( NULL != pcbDiff );
	*pcbDiff = 0;
	
	Assert( pfucbNil != pfucb );
	Assert( FFUCBIndex( pfucb ) || FFUCBSort( pfucb ) );

	FCB		*pfcb = pfucb->u.pfcb;
	Assert( pfcbNil != pfcb );

	TDB		*ptdb = pfcb->Ptdb();
	Assert( ptdbNil != ptdb );


#ifdef DISABLE_LOGDIFF
	// Returning with cbDiff set to 0 will effectively disable logdiff.
	return;
#endif

	const REC	*precOld	= (REC *)dataOld.Pv();
	const ULONG	cbRecOld	= dataOld.Cb();
	
	Assert( precNil != precOld );
	Assert( cbRecOld >= REC::cbRecordMin );
	Assert( cbRecOld <= REC::CbRecordMax() );

	//	get new data
	//
	const REC	*precNew	= (REC *)dataNew.Pv();
	const ULONG	cbRecNew	= dataNew.Cb();
	
	Assert( precNil != precNew );
	Assert( cbRecNew >= REC::cbRecordMin );
	Assert( cbRecNew <= REC::CbRecordMax() );
	
	//	check old and new data are consistent.
	//
	const FID	fidFixedLastInRecOld	= precOld->FidFixedLastInRec();
	const FID	fidFixedLastInRecNew	= precNew->FidFixedLastInRec();
	Assert( fidFixedLastInRecOld <= fidFixedLastInRecNew );
	
	const FID	fidVarLastInRecOld		= precOld->FidVarLastInRec();
	const FID	fidVarLastInRecNew		= precNew->FidVarLastInRec();
	Assert( fidVarLastInRecOld <= fidVarLastInRecNew );
	

	//	establish diff buffer, and ensure that diff record is no bigger
	//	than the after-image (otherwise, it's cheaper just to log the
	//	entire after-image).
	BYTE			*pbDiffCur				= pbDiff;
	BYTE			*pbDiffMax				= pbDiffCur + cbRecNew;
	
	//	log diffs in record header
	if ( memcmp( (BYTE *)precOld, (BYTE *)precNew, REC::cbRecordHeader ) != 0 )
		{
		if ( !FLGAppendDiff(
				&pbDiffCur,						// diff to append 
				pbDiffMax,						// max of pbDiffCur to append 
				0,								// offset to old rec 
				REC::cbRecordHeader,			// cbDataOld 
				REC::cbRecordHeader,			// cbDataNew 
				(BYTE *)precNew ) )				// pbDataNew
			{
			return;
			}
		}


	BOOL		fLogFixedNullBitMap		= fFalse;

	const BYTE	*pbFixedNullBitMapOld	= precOld->PbFixedNullBitMap();
	const BYTE	*pbFixedNullBitMapNew	= precNew->PbFixedNullBitMap();
														
	Assert( pbFixedNullBitMapOld > (BYTE *)precOld );
	Assert( pbFixedNullBitMapOld <= (BYTE *)precOld + cbRecOld );
	Assert( pbFixedNullBitMapNew > (BYTE *)precNew );
	Assert( pbFixedNullBitMapNew <= (BYTE *)precNew + cbRecNew );
	
	pfcb->EnterDML();
	
	Assert( fidFixedLastInRecOld <= fidFixedLastInRecNew );		//	can't shrink record
	for ( fid = fidFixedLeast; fid <= fidFixedLastInRecOld; fid++ )
		{
		//  if this column is not set, skip
		//
		// UNDONE: make it table look up instead of loop.
		if ( !FFUCBColumnSet( pfucb, fid ) )
			{
			continue;
			}

		//  at this point, the column _may_be_ set, but this is not known for
		//  sure!
		//

		//	this fixed column is set, make the diffs.
		//  (if this is a deleted column, skip)
		//

		//	convert fid to an offset
		const UINT	ifid			= fid - fidFixedLeast;
		const BOOL	fFieldNullOld	= FFixedNullBit( pbFixedNullBitMapOld + ifid/8, ifid );
		const BOOL	fFieldNullNew	= FFixedNullBit( pbFixedNullBitMapNew + ifid/8, ifid );

		if ( fFieldNullOld ^ fFieldNullNew )
			{
			//	If nullity changed, force diff of null bitmap.
			fLogFixedNullBitMap = fTrue;
			}

		//	If new field value is NULL, then don't need to update record data.
		//	It is sufficient just to update the null bitmap.
		if ( !fFieldNullNew )
			{
			const BOOL	fTemplateColumn	= ptdb->FFixedTemplateColumn( fid );
			const FIELD	*pfield			= ptdb->PfieldFixed( ColumnidOfFid( fid, fTemplateColumn ) );

			//	skip column if deleted
			if ( JET_coltypNil != pfield->coltyp )
				{
				if ( !FLGAppendDiff(
						&pbDiffCur,										// diff to append 
						pbDiffMax,										// max of pbDiffCur to append 
						pfield->ibRecordOffset,							// offset to old rec 
						pfield->cbMaxLen,								// cbDataOld 
						pfield->cbMaxLen,								// cbDataNew 
						(BYTE *)precNew + pfield->ibRecordOffset ) )	// pbDataNew
					{
					pfcb->LeaveDML();
					return;
					}
				}
			}
		}

	pfcb->LeaveDML();

	if ( fidFixedLastInRecOld < fidFixedLastInRecNew )
		{
		//	Log extended fixed columns.
		Assert( fidFixedLastInRecNew >= fidFixedLeast );

		//	we extend fixed field. Null array is resized. Log it.
		//
		fLogFixedNullBitMap = fTrue;

		//	log all the fields after fidFixedLastInRecOld.
		//
		const REC::RECOFFSET	ibBitMapOffsetOld	= (REC::RECOFFSET)( pbFixedNullBitMapOld - (BYTE *)precOld );
		const REC::RECOFFSET	ibBitMapOffsetNew	= (REC::RECOFFSET)( pbFixedNullBitMapNew - (BYTE *)precNew );

		Assert( ibBitMapOffsetNew > ibBitMapOffsetOld );
		const SIZE_T cbToAppend	= ibBitMapOffsetNew - ibBitMapOffsetOld;

		//	from the new record, get the data to append, but start
		//	where the old record left off.
		const BYTE	*pbToAppend	= (BYTE *)precNew + ibBitMapOffsetOld;

		if ( !FLGAppendDiff(
				&pbDiffCur,							// diff to append 
				pbDiffMax,							// max of pbDiffCur to append
				ibBitMapOffsetOld,					// offset to old rec 
				0,									// cbDataOld (0 == insert)
				cbToAppend,							// cbDataNew 
				pbToAppend							// pbDataNew 
				) )
			{
			return;
			}
		}


	//	check if need to log fixed fields null bitmap
	//
	if ( fLogFixedNullBitMap )
		{
		if ( !FLGAppendDiff(
			&pbDiffCur,
			pbDiffMax,									// max of pbDiffCur to append
			pbFixedNullBitMapOld - (BYTE *)precOld,		// offset to old image
			( fidFixedLastInRecOld + 7 ) / 8,			// length of the old image
			( fidFixedLastInRecNew + 7 ) / 8,			// length of the new image
			pbFixedNullBitMapNew ) )					// pbDataNew
			{
			return;
			}
		}

	//	check variable length fields
	//
	const UnalignedLittleEndian<REC::VAROFFSET>	*pibVarOffsOld	= precOld->PibVarOffsets();
	const UnalignedLittleEndian<REC::VAROFFSET>	*pibVarOffsNew	= precNew->PibVarOffsets();
	const REC::RECOFFSET	ibVarDataOld	= (REC::RECOFFSET)( precOld->PbVarData() - (BYTE *)precOld );
	const REC::RECOFFSET	ibVarDataNew	= (REC::RECOFFSET)( precNew->PbVarData() - (BYTE *)precNew );
	
	//	Find first set var field whose offset entry has changed, either
	//	because the offset has changed or because the null flag has changed.
	Assert( fidVarLastInRecOld <= fidVarLastInRecNew );
	for ( fid = fidVarLeast; fid <= fidVarLastInRecOld; fid++ )
		{
		const UINT	ifid	= fid - fidVarLeast;
		if ( pibVarOffsOld[ifid] != pibVarOffsNew[ifid] )
			{
			break;
			}
		}

	Assert( fid <= fidVarLastInRecNew || fidVarLastInRecOld == fidVarLastInRecNew );
	if ( fid <= fidVarLastInRecNew )
		{
		const UINT	ifid	= fid - fidVarLeast;
		
		//	we need to log the offset between fid and fidVarLastInRecNew
		//
		if ( !FLGAppendDiff(
				&pbDiffCur,
				pbDiffMax,													// max of pbDiffCur to append 
				(BYTE*)( pibVarOffsOld + ifid ) - (BYTE *)precOld,			// offset to old image 
				( fidVarLastInRecOld + 1 - fid ) * sizeof(REC::VAROFFSET),	// length of the old image 
				( fidVarLastInRecNew + 1 - fid ) * sizeof(REC::VAROFFSET),	// length of the new image 
				(BYTE *)( pibVarOffsNew + ifid ) ) )						// pbDataNew 
			{
			return;
			}
		}
			

	//	scan through each variable length field up to old last fid and log its replace image.
	//
	for ( fid = fidVarLeast; fid <= fidVarLastInRecOld; fid++ )
		{
		//  if this column is not set, skip
		//
		if ( !FFUCBColumnSet( pfucb, fid ) )
			continue;

		//  at this point, the column _may_be_ set, but this is not known for
		//  sure!
		//

//	Deleted column check is too expensive because we'd have to access the TDB
//
//		//  if this column is deleted, skip
//		//
//		if ( ptdb->PfieldVar( ColumnidOfFid( fid ) )->coltyp == JET_coltypNil )
//			{
//			continue;
//			}

		const REC::VAROFFSET	ibStartOfColumnOld	= precOld->IbVarOffsetStart( fid );
		const REC::VAROFFSET	ibEndOfColumnOld	= precOld->IbVarOffsetEnd( fid );
		const REC::VAROFFSET	ibStartOfColumnNew	= precNew->IbVarOffsetStart( fid );
		const REC::VAROFFSET	ibEndOfColumnNew	= precNew->IbVarOffsetEnd( fid );

		if ( !FLGAppendDiff(
					&pbDiffCur,
					pbDiffMax,										// max of pbDiffCur to append 
					ibVarDataOld + ibStartOfColumnOld,				// offset to old image 
					ibEndOfColumnOld - ibStartOfColumnOld,			// length of the old image 
					ibEndOfColumnNew - ibStartOfColumnNew,			// length of the new image 
					precNew->PbVarData() + ibStartOfColumnNew ) )	// pbDataNew 
			{
			return;
			}
		}
		
	Assert( fid == fidVarLastInRecOld + 1 );
	
	//	insert new image for fid > old last var fid as one contigous diff
	//
	if ( fid <= fidVarLastInRecNew )
		{
		const REC::VAROFFSET	ibStartOfColumn	= precNew->IbVarOffsetStart( fid );

		if ( !FLGAppendDiff(
				&pbDiffCur,
				pbDiffMax,											// max of pbDiffCur to append 
				ibVarDataOld + precOld->IbEndOfVarData(),			// offset to old image 
				0,													// length of the old image 
				precNew->IbEndOfVarData() - ibStartOfColumn,		// length of the new image 
				precNew->PbVarData() + ibStartOfColumn ) )			// pbDataNew 
			{
			return;
			}

		}

	// if we made some implicit operations store all the record
	// UNDONE: try to store whole tagfields area
	if ( FFUCBTagImplicitOp( pfucb ) )
		{
		SIZE_T ibTagOffsetOld = precOld->PbTaggedData() - (BYTE *)precOld;
		SIZE_T ibTagOffsetNew = precNew->PbTaggedData() - (BYTE *)precNew;
		if ( !FLGAppendDiff(
					&pbDiffCur,
					pbDiffMax,								// max of pbDiffCur to append
					ibTagOffsetOld,							// offset to old image 
					cbRecOld - ibTagOffsetOld,				// length of the old image 
					cbRecNew - ibTagOffsetNew,				// length of the new image 
					precNew->PbTaggedData() ) )				// pbDataNew 
			{
			return;
			}
		}
		
	else if ( FFUCBTaggedColumnSet( pfucb ) )
		{
		//	go through each Tag fields. check if tag field is different and check if a tag is
		//	deleted (set to Null), added (new tag field), or replaced.
		TAGFIELDS_DUMP tfdOld( dataOld );
		TAGFIELDS_DUMP tfdNew( dataNew );
		BOOL fTagColumnsHeaderLog = fFalse;
		//	check if have changes in tags header, like:
		//	adding a new column, deleting a column or resizing an existing column
		//
		if ( !FLGSetArrayDiff(
			(const BYTE *)precOld,
			tfdOld.PbTagColumnsHeader(),
			tfdNew.PbTagColumnsHeader(),
			tfdOld.CbTagColumnsHeaderSize(),
			tfdNew.CbTagColumnsHeaderSize(),
			&pbDiffCur,
			pbDiffMax ) )
			{
			return;
			}

		tfdOld.FindFirstTagField();
		tfdNew.FindFirstTagField();
		for ( ; tfdOld.FIsValidTagField() && tfdNew.FIsValidTagField(); )
			{
			const INT iFidOrder = tfdOld.Compare( tfdNew );
			if ( iFidOrder == 0 )
				{
				//	check if this column is modified
				//
				if ( FFUCBColumnSet( pfucb, tfdOld.GetFID() ) )
					{
					const SIZE_T	cbTagFieldOld	= tfdOld.CbData();
					const SIZE_T	cbTagFieldNew	= tfdNew.CbData();

					//	check if contents are still the same. If not, log replace.
					//
					if ( cbTagFieldNew != cbTagFieldOld
						|| memcmp( tfdOld.PbData(), tfdNew.PbData(), cbTagFieldNew ) != 0 )
						{
						//	replace from offset
						//
						if ( !FLGAppendDiff(
									&pbDiffCur,
									pbDiffMax,						// max of pbDiffCur to append 
									tfdOld.IbDataOffset(),			// offset to old image 
									cbTagFieldOld,					// length of the old image 
									cbTagFieldNew,					// length of the new image 
									tfdNew.PbData() ) )				// pbDataNew 
							{
							return;
							}
						}
					}
				tfdOld.FindNextTagField();
				tfdNew.FindNextTagField();
				}
			else if ( iFidOrder > 0 )
				{
				//	just set a new column, log insertion.
				//
				if ( !FLGAppendDiff(
							&pbDiffCur,
							pbDiffMax,							// max of pbDiffCur to append 
							tfdOld.IbDataOffset(),				// offset to old image 
							0,									// length of the old image 
							tfdNew.CbData(),					// length of the new image 
							tfdNew.PbData() ) )					// pbDataNew 
					{
					return;
					}

				tfdNew.FindNextTagField();
				}
				
			else
				{
				//	just set a column to Null (or default value if default value is defined)
				//	log as deletion.
				//
				if ( !FLGAppendDiff(
							&pbDiffCur,
							pbDiffMax,							// max of pbDiffCur to append 
							tfdOld.IbDataOffset(),				// offset to old image 
							tfdOld.CbData(),					// length of the old image 
							0,									// length of the new image 
							pbNil ) )							// pbDataNew 
					{
					return;
					}
							
				tfdOld.FindNextTagField();
				}
			}

		if ( tfdNew.FIsValidTagField() )
			{
			Assert( !tfdOld.FIsValidTagField() );
			
			if ( !FLGAppendDiff(
						&pbDiffCur,
						pbDiffMax,					// max of pbDiffCur to append 
						cbRecOld,					// offset to old image 
						0,							// length of the old image 
						tfdNew.CbRestData(),		// length of the new image 
						tfdNew.PbData() ) )			// pbDataNew
				{
				return;
				}
			}

		else if ( tfdOld.FIsValidTagField() )
			{
			Assert( !tfdNew.FIsValidTagField() );
			
			//	delete the remaining old tag columns
			//
			if ( !FLGAppendDiff(
						&pbDiffCur,
						pbDiffMax,								// max of pbDiffCur to append
						tfdOld.IbDataOffset(),						// offset to old image 
						tfdOld.CbRestData(),					// length of the old image 
						0,										// length of the new image 
						pbNil ) )								// pbDataNew 
				{
				return;
				}
			}

		else
			{
			Assert( !tfdOld.FIsValidTagField() );
			Assert( !tfdNew.FIsValidTagField() );
			}
		}	// FFUCBTaggedColumnSet()

	//	set up return value.
	//
	if ( pbDiffCur == pbDiff )
		{
		//	Old and New are the same, log a short diff.
		//
		if ( !FLGAppendDiff(
				&pbDiffCur,
				pbDiffMax,						// max of pbDiffCur to append
				0,							// offset to old image
				0,							// length of the old image
				0,							// length of the new image
				pbNil						// pbDataNew
				) )
			{
			Assert( *pcbDiff == 0 );
			return;
			}
		}

	*pcbDiff = pbDiffCur - pbDiff;


#ifdef DEBUG
	Assert( *pcbDiff != 0 );

	BYTE	rgbAfterImage[g_cbPageMax];
	SIZE_T	cbAfterImage;
	DATA	dataAfterImage;

	Assert( dataNew.Cb() <= REC::CbRecordMax() );
	Assert( g_cbColumnLVChunkMost > REC::CbRecordMax() );

	LGGetAfterImage( 
			pbDiff,
			*pcbDiff,
			(BYTE *)dataOld.Pv(),
			dataOld.Cb(),
			rgbAfterImage,
			&cbAfterImage );
	Assert( dataNew.Cb() == cbAfterImage );

	Assert( dataNew.Pv() == (BYTE *)precNew );

	dataAfterImage.SetPv( rgbAfterImage );
	dataAfterImage.SetCb( cbAfterImage );
	
	if ( !FDataEqual( dataNew, dataAfterImage ) )
		{
		REC		*precAfterImage		= (REC *)rgbAfterImage;
		DATA	dataNewT;
		
		//	dissect the comparison for easier debugging.

		//	check record header
		Assert( memcmp( precAfterImage, precNew, REC::cbRecordHeader ) == 0 );

		//	check fixed fields
		dataNewT.SetPv( (BYTE *)precNew );
		dataNewT.SetCb( precNew->IbEndOfFixedData() - precNew->CbFixedNullBitMap() );
		dataAfterImage.SetPv( precAfterImage );
		dataAfterImage.SetCb( precAfterImage->IbEndOfFixedData() - precAfterImage->CbFixedNullBitMap() );
		Assert( FDataEqual( dataNewT, dataAfterImage ) );
		
		//	check fixed field null bitmap
		dataNewT.SetPv( (BYTE *)precNew + precNew->IbEndOfFixedData() - precNew->CbFixedNullBitMap() );
		dataNewT.SetCb( precNew->CbFixedNullBitMap() );
		dataAfterImage.SetPv( (BYTE *)precAfterImage + precAfterImage->IbEndOfFixedData() - precAfterImage->CbFixedNullBitMap() );
		dataAfterImage.SetCb( precAfterImage->CbFixedNullBitMap() );
		Assert( FDataEqual( dataNewT, dataAfterImage ) );

		//	check variable offsets table
		dataNewT.SetPv( (BYTE *)precNew->PibVarOffsets() );
		dataNewT.SetCb( precNew->PbVarData() - (BYTE *)precNew->PibVarOffsets() );
		dataAfterImage.SetPv( (BYTE *)precAfterImage->PibVarOffsets() );
		dataAfterImage.SetCb( precAfterImage->PbVarData() - (BYTE *)precAfterImage->PibVarOffsets() );
		Assert( FDataEqual( dataNewT, dataAfterImage ) );

		//	check variable offsets table
		dataNewT.SetPv( precNew->PbVarData() );
		dataNewT.SetCb( precNew->PbTaggedData() - precNew->PbVarData() );
		dataAfterImage.SetPv( precAfterImage->PbVarData() );
		dataAfterImage.SetCb( precAfterImage->PbTaggedData() - precAfterImage->PbVarData() );
		Assert( FDataEqual( dataNewT, dataAfterImage ) );

		dataNewT.SetPv( precNew->PbTaggedData() );
		dataNewT.SetCb( (BYTE *)precNew + dataNew.Cb() - precNew->PbTaggedData() );
		dataAfterImage.SetPv( precAfterImage->PbTaggedData() );
		dataAfterImage.SetCb( rgbAfterImage + cbAfterImage - precAfterImage->PbTaggedData() );
		Assert( FDataEqual( dataNewT, dataAfterImage ) );

		//	one of the asserts above should have gone off, but
		//	add the following assert to ensures that we didn't
		//	miss any cases.
		Assert( fFalse );
		}
		
#endif	// DEBUG
	}


//  TODO:  rewrite this function

VOID LGSetLVDiffs(
	FUCB		*pfucb,
	const DATA&	dataNew,
	const DATA&	dataOld,
	BYTE		*pbDiff,
	SIZE_T		*pcbDiff )
	{
	//	Initialize return value
	Assert( NULL != pcbDiff );
	*pcbDiff = 0;
	
	Assert( pfucbNil != pfucb );
	Assert( pfcbNil != pfucb->u.pfcb );
	Assert( pfucb->u.pfcb->FTypeLV() );

#ifdef DISABLE_LOGDIFF
	//	Returning with cbDiff set to 0 will effectively disable logdiff.
	return;
#endif

	//	UNDONE: Need a more sophisticated diff routine that doesn't
	//	rely on the data segments being the same size
	INT cbMinSize = dataOld.Cb();
	BOOL fTruncate, fEndIsReached;
	fTruncate = fFalse;
	fEndIsReached = fFalse;	//	if during comparision ends of both blocks are reached
	if ( cbMinSize > dataNew.Cb() ) 
		{
		cbMinSize = dataNew.Cb();
		fTruncate = fTrue;
		}
	else if ( cbMinSize == dataNew.Cb() )
		{
		fEndIsReached = fTrue;
		}

	BYTE	*pbOldCur	= (BYTE *)dataOld.Pv();
	BYTE	*pbOldMax	= pbOldCur + ( cbMinSize - cbMinSize % sizeof( LONG ) );
	BYTE	*pbNewCur	= (BYTE *)dataNew.Pv();
	
	//	quickly finds where the differences begin
	//
	while ( pbOldCur < pbOldMax && *( Unaligned< LONG > * )pbOldCur == *( Unaligned< LONG > * )pbNewCur )
		{
		pbOldCur += sizeof( LONG );
		pbNewCur += sizeof( LONG );
		}

	pbOldMax += cbMinSize % sizeof( LONG );
	
	//	establish diff buffer and
	//	ensure that diff record is no bigger than the after-image 
	//	(otherwise, it's cheaper just to log the entire after-image).
	BYTE	*pbDiffCur = pbDiff;
	BYTE	*pbDiffMax = pbDiffCur + dataNew.Cb();

	while ( pbOldCur < pbOldMax )
		{
		if ( *pbOldCur == *pbNewCur )
			{
			pbOldCur++;
			pbNewCur++;
			}
		else
			{
			//	store the offset
			//
			Assert( pbOldCur >= dataOld.Pv() ); 
			const SIZE_T ibOld		= pbOldCur - (BYTE *)dataOld.Pv();
			const BYTE	*pbNewData	= pbNewCur;
			SIZE_T		cbNewData	= 0;
			SIZE_T		cbT;
				//	compare 4 bytes at a time until data streams re-sync
			do
				{
				if ( pbOldCur + sizeof( SIZE_T ) >= pbOldMax )
					cbT = pbOldMax - pbOldCur;
				else if ( *(Unaligned< SIZE_T > *)pbOldCur == *(Unaligned< SIZE_T > *)pbNewCur )
					{
					pbOldCur += sizeof( SIZE_T );
					pbNewCur += sizeof( SIZE_T );
					break;
					}
				else
					cbT = sizeof( SIZE_T );
					
				cbNewData += cbT;
				pbOldCur += cbT;
				pbNewCur += cbT;
				}
			while ( pbOldCur < pbOldMax );

			//	if end of comparision block is reached
			//	check if should truncate ot expand the size of chunk
			SIZE_T cbOldData = cbNewData;
			if ( pbOldCur == pbOldMax ) 
				{
				if ( fTruncate )
					{
					cbOldData += dataOld.Cb() - cbMinSize;
					}
				else
					{
					cbNewData += dataNew.Cb() - cbMinSize;
					}
				fEndIsReached = fTrue;	//	the differences are completly set
				}
				
			if ( !FLGAppendDiff(
					&pbDiffCur,
					pbDiffMax,					// max of pbCur to append
					ibOld,						// offset to old image
					cbOldData,					// length of the old image
					cbNewData,					// length of the new image
					pbNewData					// pbDataNew
					) )
				{
				return;
				}
			}
		}

	Assert( pbOldMax == pbOldCur );
		
	if ( pbDiffCur == pbDiff || !fEndIsReached )
		{
		//	No diff is found. Old and New are the same. Log insert null.
		//  Or different chunk's sizes. Log differences
		if ( !FLGAppendDiff(
					&pbDiffCur,
					pbDiffMax,					//	max of pbCur to append
					cbMinSize,					//	offset to old image
					dataOld.Cb() - cbMinSize,	//	length of the old image
					dataNew.Cb() - cbMinSize,	//	length of the new image
					pbNewCur ) )				//	pbDataNew
			{
			return;
			}

		}

	*pcbDiff = pbDiffCur - pbDiff;

#	if DEBUG
	Assert ( *pcbDiff != 0 );
	
	BYTE	rgbAfterImage[g_cbColumnLVChunkMax];
	SIZE_T	cbAfterImage;

	Assert( dataNew.Cb() <= g_cbColumnLVChunkMost );
	Assert( g_cbColumnLVChunkMost > REC::CbRecordMax() );
		
	LGGetAfterImage(
			pbDiff,
			*pcbDiff,
			(BYTE *)dataOld.Pv(),
			dataOld.Cb(),
			rgbAfterImage,
			&cbAfterImage );
	Assert( dataNew.Cb() == cbAfterImage );

	Assert( memcmp( rgbAfterImage, dataNew.Pv(), cbAfterImage ) == 0 );
#	endif
	}


VOID LGGetAfterImage(
	BYTE		*pbDiff,
	const SIZE_T	cbDiff,
	BYTE		*pbOld,
	const SIZE_T	cbOld,
	BYTE		*pbNew,
	SIZE_T	*pcbNew )
	{
	BYTE		*pbOldCur	= pbOld;
	BYTE		*pbNewCur	= pbNew;
	BYTE		*pbDiffCur	= pbDiff;
	BYTE		*pbDiffMax	= pbDiff + cbDiff;
	SIZE_T		cbT;

	while ( pbDiffCur < pbDiffMax )
		{
		INT 	cbDataNew;
		INT 	ibOffsetOld;
		SIZE_T 	cbSkip;
		
		DIFFHDR diffhdr = *( (DIFFHDR*) pbDiffCur );
		pbDiffCur += sizeof( DIFFHDR );
		
		ibOffsetOld = ( diffhdr.m_bitfield & DIFFHDR::ibOffsetMask ) >> DIFFHDR::ibOffsetShf;

		Assert( ibOffsetOld >= 0 );
		Assert( pbOld + ibOffsetOld >= pbOldCur );
		cbSkip = pbOld + ibOffsetOld - pbOldCur;
		Assert( g_cbColumnLVChunkMost > REC::CbRecordMax() );
		Assert( pbNewCur + cbSkip - pbNew <= g_cbColumnLVChunkMost );
		UtilMemCpy( pbNewCur, pbOldCur, cbSkip );
		pbNewCur += cbSkip;
		pbOldCur += cbSkip;
		
		if ( diffhdr.m_bitfield & DIFFHDR::fUseTwoBytesForDataLength )
			{
			cbDataNew = *( (UnalignedLittleEndian< WORD >*) pbDiffCur );
			pbDiffCur += sizeof( WORD );
			}
		else
			{
			cbDataNew = *( (UnalignedLittleEndian< BYTE >*) pbDiffCur );
			pbDiffCur += sizeof( BYTE );
			}
				
		Assert( g_cbColumnLVChunkMost > REC::CbRecordMax() );
		Assert( pbNewCur + cbDataNew - pbNew <= g_cbColumnLVChunkMost );
		if ( diffhdr.m_bitfield & DIFFHDR::fInsert )
			{
			UtilMemCpy( pbNewCur, pbDiffCur, cbDataNew );
			pbDiffCur += cbDataNew;
			}
		else
			{
			INT cbDataOld;

			if ( diffhdr.m_bitfield & DIFFHDR::fReplaceWithSameLength )
				{
				cbDataOld = cbDataNew;
				}
			else if ( diffhdr.m_bitfield & DIFFHDR::fUseTwoBytesForDataLength )
				{
				cbDataOld = *( (UnalignedLittleEndian< WORD >*) pbDiffCur );
				pbDiffCur += sizeof( WORD );
				}
			else
				{
				cbDataOld = *( (UnalignedLittleEndian< BYTE >*) pbDiffCur );
				pbDiffCur += sizeof( BYTE );
				}
				
			UtilMemCpy( pbNewCur, pbDiffCur, cbDataNew );
			pbDiffCur += cbDataNew;

			pbOldCur += cbDataOld;
			}

		pbNewCur += cbDataNew;

		Assert( pbDiffCur <= pbDiffMax );
		Assert( pbOldCur <= pbOld + cbOld );
		}

	//	copy the rest of before image.
	//
	cbT = pbOld + cbOld - pbOldCur;
	Assert( g_cbColumnLVChunkMost > REC::CbRecordMax() );
	Assert( pbNewCur + cbT - pbNew <= g_cbColumnLVChunkMost );
	UtilMemCpy( pbNewCur, pbOldCur, cbT );
	pbNewCur += cbT;

	//	set return value.
	//
	Assert( pbNewCur >= pbNew );
	*pcbNew = pbNewCur - pbNew;

	return;	
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ese98\src\ese\logapi.cxx ===
#include "std.hxx"
#include <ctype.h>

//	global log disabled flag
//

BOOL	g_fLGIgnoreVersion = fFalse;

ERR ErrLGIMacroBegin( PIB *ppib, DBTIME dbtime );
ERR ErrLGIMacroEnd( PIB *ppib, DBTIME dbtime, LRTYP lrtyp, LGPOS *plgpos );

//********************************************************
//****     deferred begin transactions                ****
//********************************************************

LOCAL ERR ErrLGIDeferBeginTransaction( PIB *ppib );

INLINE ERR ErrLGDeferBeginTransaction( PIB *ppib )
	{
	Assert( ppib->level > 0 );
	const ERR	err		= ( 0 != ppib->clevelsDeferBegin ?
									ErrLGIDeferBeginTransaction( ppib ) :
									JET_errSuccess );
	return err;
	}


//********************************************************
//****     Page Oriented Operations                   ****
//********************************************************

//	WARNING: If fVersion bit needs to be set, ensure it's set before
//	calling this function, as it will be reset if necessary.
INLINE VOID LGISetTrx( PIB *ppib, LRPAGE_ *plrpage, const VERPROXY * const pverproxy = NULL )
	{
	if ( NULL == pverproxy )
		{
		plrpage->le_trxBegin0 = ppib->trxBegin0;
		plrpage->level = ppib->level;
		}
	else
		{
		Assert( prceNil != pverproxy->prcePrimary );
		plrpage->le_trxBegin0 = pverproxy->prcePrimary->TrxBegin0();
		if ( trxMax == pverproxy->prcePrimary->TrxCommitted() )
			{
			Assert( pverproxy->prcePrimary->Level() > 0 );
			plrpage->level = pverproxy->prcePrimary->Level();
			}
		else
			{
			plrpage->level = 0;
			
			//	for redo, don't version proxy operations if they have
			//	already committed (at do time, we still need to version
			//	them for visibility reasons -- the indexer may not be
			//	able to see them once he's finished building the index)
			plrpage->ResetFVersioned();
			}
		}
	}

INLINE ERR ErrLGSetDbtimeBeforeAndDirty(
	CSR									* const pcsr,
	UnalignedLittleEndian< DBTIME >		* ple_dbtimeBefore,
	UnalignedLittleEndian< DBTIME >		* ple_dbtime,
	const BOOL							fDirty )
	{
	ERR									err			= JET_errSuccess;

	Assert ( NULL != pcsr );
	Assert ( NULL != ple_dbtimeBefore );
	Assert ( NULL != ple_dbtime );
	
	if ( fDirty )
		{
		*ple_dbtimeBefore = pcsr->Dbtime();
		pcsr->Dirty();

		if ( pcsr->Dbtime() <= *ple_dbtimeBefore )
			{
			pcsr->RevertDbtime( *ple_dbtimeBefore );
			FireWall();
			err = ErrERRCheck( JET_errDbTimeCorrupted );
			}
		}
	else
		{
		*ple_dbtimeBefore = dbtimeNil;
		}
		
	*ple_dbtime = pcsr->Dbtime();
	Assert( pcsr->Dbtime() == pcsr->Cpage().Dbtime() );

	return err;
	}
	
ERR ErrLGInsert( const FUCB				* const pfucb,
				 CSR					* const pcsr,
				 const KEYDATAFLAGS&	kdf,
				 const RCEID			rceid,
				 const DIRFLAG			dirflag,
				 LGPOS					* const plgpos,
				 const VERPROXY			* const pverproxy,
				 const BOOL				fDirtyCSR ) 	// true - if we must dirty the page inside (in witch case dbtime before is in the CSR
			 											// false - record dbtimeInvalid for dbtimeBefore (insert part of split operations)
	{
	ERR				err;
	DATA			rgdata[4];
	LRINSERT		lrinsert;

	INST *pinst = PinstFromIfmp( pfucb->ifmp );
	LOG *plog = pinst->m_plog;
	
	Assert( !plog->m_fRecovering );
	
	Assert( fDirtyCSR || pcsr->FDirty() );
	
	if ( plog->m_fLogDisabled )
		{
		if ( fDirtyCSR )
			{
			pcsr->Dirty();
			}
		*plgpos = lgposMin;
		return JET_errSuccess;
		}

	Assert( !( dirflag & fDIRNoLog ) );
	Assert( rgfmp[pfucb->ifmp].FLogOn() );

	PIB	* const ppib = pverproxy != NULL &&
					trxMax == pverproxy->prcePrimary->TrxCommitted() ?
						pverproxy->prcePrimary->Pfucb()->ppib :
						pfucb->ppib;
	Assert( NULL == pverproxy ||
			prceNil != pverproxy->prcePrimary &&
			( pverproxy->prcePrimary->TrxCommitted() != trxMax ||
			  pfucbNil != pverproxy->prcePrimary->Pfucb() &&
			  ppibNil != pverproxy->prcePrimary->Pfucb()->ppib ) );
						
	//	must be in a transaction since we will not redo level 0 modifications
	//
	Assert( ppib->level > 0 );

	CallR( ErrLGDeferBeginTransaction( ppib ) );

	lrinsert.lrtyp		= lrtypInsert;

	Assert( pcsr->ILine() >= 0 );
	Assert( pcsr->ILine() < ( 1 << 10 ) );
	lrinsert.SetILine( (USHORT)pcsr->ILine() );

	Assert( !lrinsert.FVersioned() );
	Assert( !lrinsert.FDeleted() );
	Assert( !lrinsert.FUnique() );
	Assert( !lrinsert.FSpace() );
	Assert( !lrinsert.FConcCI() );

	if ( !( dirflag & fDIRNoVersion ) )
		lrinsert.SetFVersioned();
	if ( pfucb->u.pfcb->FUnique() )
		lrinsert.SetFUnique();
	if ( FFUCBSpace( pfucb ) )
		lrinsert.SetFSpace();
	if ( NULL != pverproxy )
		lrinsert.SetFConcCI();

	lrinsert.le_rceid		= rceid;
	lrinsert.le_pgnoFDP		= PgnoFDP( pfucb );
	lrinsert.le_objidFDP	= ObjidFDP( pfucb );

	lrinsert.le_procid 	= ppib->procid;

	CallR( ErrLGSetDbtimeBeforeAndDirty( pcsr, &lrinsert.le_dbtimeBefore, &lrinsert.le_dbtime, fDirtyCSR ) )

	lrinsert.dbid			= rgfmp[ pfucb->ifmp ].Dbid();
	lrinsert.le_pgno		= pcsr->Pgno();

	LGISetTrx( ppib, &lrinsert, pverproxy );

	lrinsert.SetCbSuffix( USHORT( kdf.key.suffix.Cb() ) );
	lrinsert.SetCbPrefix( USHORT( kdf.key.prefix.Cb() ) );
	lrinsert.SetCbData( USHORT( kdf.data.Cb() ) );

	rgdata[0].SetPv( (BYTE *)&lrinsert );
	rgdata[0].SetCb( sizeof(LRINSERT) );
	
	rgdata[1].SetPv( kdf.key.prefix.Pv() );
	rgdata[1].SetCb( kdf.key.prefix.Cb() );
	
	rgdata[2].SetPv( kdf.key.suffix.Pv() );
	rgdata[2].SetCb( kdf.key.suffix.Cb() );
	
	rgdata[3].SetPv( kdf.data.Pv() );
	rgdata[3].SetCb( kdf.data.Cb() );

	err = plog->ErrLGLogRec( rgdata, 4, fLGNoNewGen, plgpos );

	// on error, return to before dirty dbtime on page
	if ( JET_errSuccess > err && fDirtyCSR )
		{
		Assert ( dbtimeInvalid !=  lrinsert.le_dbtimeBefore && dbtimeNil != lrinsert.le_dbtimeBefore);
		Assert ( pcsr->Dbtime() > lrinsert.le_dbtimeBefore );
		pcsr->RevertDbtime( lrinsert.le_dbtimeBefore );
		}
		
	return err;
	}


ERR ErrLGFlagInsertAndReplaceData( const FUCB		 	* const pfucb, 
								   CSR			* const pcsr, 
								   const KEYDATAFLAGS&	kdf, 
								   const RCEID			rceidInsert,
								   const RCEID			rceidReplace,
								   const DIRFLAG		dirflag, 
								   LGPOS				* const plgpos,
								   const VERPROXY		* const pverproxy, 
								 const BOOL				fDirtyCSR ) 	// true - if we must dirty the page inside (in witch case dbtime before is in the CSR
			 															// false - record dbtimeInvalid for dbtimeBefore (insert part of split operations)
								   
	{
	ERR							err;
	DATA						rgdata[4];
	LRFLAGINSERTANDREPLACEDATA	lrfiard;

	INST *pinst = PinstFromIfmp( pfucb->ifmp );
	LOG *plog = pinst->m_plog;
	
	Assert( !plog->m_fRecovering );

	Assert( fDirtyCSR || pcsr->FDirty() );
	
	if ( plog->m_fLogDisabled )
		{
		if ( fDirtyCSR )
			{
			pcsr->Dirty();
			}				
		*plgpos = lgposMin;
		return JET_errSuccess;
		}

	Assert( !( dirflag & fDIRNoLog ) );
	Assert( rgfmp[pfucb->ifmp].FLogOn() );

	PIB	* const ppib = pverproxy != NULL && 
					trxMax == pverproxy->prcePrimary->TrxCommitted() ?
						pverproxy->prcePrimary->Pfucb()->ppib :
						pfucb->ppib;
	Assert( NULL == pverproxy ||
			prceNil != pverproxy->prcePrimary &&
			( pverproxy->prcePrimary->TrxCommitted() != trxMax ||
			  pfucbNil != pverproxy->prcePrimary->Pfucb() &&
			  ppibNil != pverproxy->prcePrimary->Pfucb()->ppib ) );

	//	must be in a transaction since we will not redo level 0 modifications
	//
	Assert( ppib->level > 0 );

	CallR( ErrLGDeferBeginTransaction( ppib ) );

	lrfiard.lrtyp		= lrtypFlagInsertAndReplaceData;

	Assert( pcsr->ILine() >= 0 );
	Assert( pcsr->ILine() < ( 1 << 10 ) );
	lrfiard.SetILine( (USHORT)pcsr->ILine() );

	Assert( !lrfiard.FVersioned() );
	Assert( !lrfiard.FDeleted() );
	Assert( !lrfiard.FUnique() );
	Assert( !lrfiard.FSpace() );
	Assert( !lrfiard.FConcCI() );

	if ( !( dirflag & fDIRNoVersion ) )
		lrfiard.SetFVersioned();
	if ( pfucb->u.pfcb->FUnique() )
		lrfiard.SetFUnique();
	if ( FFUCBSpace( pfucb ) )
		lrfiard.SetFSpace();
	if ( NULL != pverproxy )
		lrfiard.SetFConcCI();

	lrfiard.le_rceid			= rceidInsert;
	lrfiard.le_rceidReplace		= rceidReplace;
	lrfiard.le_pgnoFDP			= PgnoFDP( pfucb );
	lrfiard.le_objidFDP			= ObjidFDP( pfucb );
	
	lrfiard.le_procid 		= ppib->procid;

	CallR( ErrLGSetDbtimeBeforeAndDirty( pcsr, &lrfiard.le_dbtimeBefore, &lrfiard.le_dbtime, fDirtyCSR ) );
								
	lrfiard.dbid		= rgfmp[ pfucb->ifmp ].Dbid();
	lrfiard.le_pgno		= pcsr->Pgno();

	LGISetTrx( ppib, &lrfiard, pverproxy );
	
	Assert( !kdf.key.FNull() );
	lrfiard.SetCbKey( USHORT( kdf.key.Cb() ) );
	lrfiard.SetCbData( USHORT( kdf.data.Cb() ) );

	rgdata[0].SetPv( (BYTE *)&lrfiard );
	rgdata[0].SetCb( sizeof(LRFLAGINSERTANDREPLACEDATA) );

	rgdata[1].SetPv( kdf.key.prefix.Pv() );
	rgdata[1].SetCb( kdf.key.prefix.Cb() );
	
	rgdata[2].SetPv( kdf.key.suffix.Pv() );
	rgdata[2].SetCb( kdf.key.suffix.Cb() );
	
	rgdata[3].SetPv( kdf.data.Pv() );
	rgdata[3].SetCb( kdf.data.Cb() );

	err = plog->ErrLGLogRec( rgdata, 4, fLGNoNewGen, plgpos );

	// on error, return to before dirty dbtime on page
	if ( JET_errSuccess > err && fDirtyCSR )
		{
		Assert ( dbtimeInvalid !=  lrfiard.le_dbtimeBefore && dbtimeNil != lrfiard.le_dbtimeBefore);
		Assert ( pcsr->Dbtime() > lrfiard.le_dbtimeBefore );
		pcsr->RevertDbtime( lrfiard.le_dbtimeBefore );
		}

	return err;
	}
	
	
ERR ErrLGFlagInsert( const FUCB 			* const pfucb, 
					 CSR					* const pcsr,
					 const KEYDATAFLAGS& 	kdf,
					 const RCEID			rceid,
					 const DIRFLAG			dirflag, 
					 LGPOS					* const plgpos,
					 const VERPROXY			* const pverproxy ,
					 const BOOL				fDirtyCSR ) 	// true - if we must dirty the page inside (in witch case dbtime before is in the CSR
				 											// false - record dbtimeInvalid for dbtimeBefore (insert part of split operations)			 
	{
	ERR				err;
	DATA			rgdata[4];
	LRFLAGINSERT	lrflaginsert;

	INST *pinst = PinstFromIfmp( pfucb->ifmp );
	LOG *plog = pinst->m_plog;
	
	Assert( !plog->m_fRecovering );
	Assert( fDirtyCSR || pcsr->FDirty() );
	
	if ( plog->m_fLogDisabled )
		{
		if ( fDirtyCSR )
			{
			pcsr->Dirty();
			}		
		*plgpos = lgposMin;
		return JET_errSuccess;
		}

	Assert( !( dirflag & fDIRNoLog ) );
	Assert( rgfmp[pfucb->ifmp].FLogOn() );

	Assert( NULL == pverproxy ||
			prceNil != pverproxy->prcePrimary &&
			( pverproxy->prcePrimary->TrxCommitted() != trxMax ||
			  pfucbNil != pverproxy->prcePrimary->Pfucb() &&
			  ppibNil != pverproxy->prcePrimary->Pfucb()->ppib ) );
			  
	PIB	* const ppib = pverproxy != NULL && 
					trxMax == pverproxy->prcePrimary->TrxCommitted() ?
						pverproxy->prcePrimary->Pfucb()->ppib :
						pfucb->ppib;
			  
	//	must be in a transaction since we will not redo level 0 modifications
	//
	Assert( ppib->level > 0 );

	CallR( ErrLGDeferBeginTransaction( ppib ) );
	
	lrflaginsert.lrtyp		= lrtypFlagInsert;

	Assert( pcsr->ILine() >= 0 );
	Assert( pcsr->ILine() < ( 1 << 10 ) );
	lrflaginsert.SetILine( (USHORT)pcsr->ILine() );

	Assert( !lrflaginsert.FVersioned() );
	Assert( !lrflaginsert.FDeleted() );
	Assert( !lrflaginsert.FUnique() );
	Assert( !lrflaginsert.FSpace() );
	Assert( !lrflaginsert.FConcCI() );

	if ( !( dirflag & fDIRNoVersion ) )
		lrflaginsert.SetFVersioned();
	if ( pfucb->u.pfcb->FUnique() )
		lrflaginsert.SetFUnique();
	if ( FFUCBSpace( pfucb ) )
		lrflaginsert.SetFSpace();
	if ( NULL != pverproxy )
		lrflaginsert.SetFConcCI();

	lrflaginsert.le_rceid		= rceid;
	lrflaginsert.le_pgnoFDP		= PgnoFDP( pfucb );
	lrflaginsert.le_objidFDP	= ObjidFDP( pfucb );
	
	lrflaginsert.le_procid 	= ppib->procid;

	CallR( ErrLGSetDbtimeBeforeAndDirty( pcsr, &lrflaginsert.le_dbtimeBefore, &lrflaginsert.le_dbtime, fDirtyCSR ) );

	lrflaginsert.dbid			= rgfmp[ pfucb->ifmp ].Dbid();
	lrflaginsert.le_pgno		= pcsr->Pgno();

	LGISetTrx( ppib, &lrflaginsert, pverproxy );
	
	Assert( !kdf.key.FNull() );
	lrflaginsert.SetCbKey( USHORT( kdf.key.Cb() ) );
	lrflaginsert.SetCbData(	USHORT( kdf.data.Cb() ) );

	rgdata[0].SetPv( (BYTE *)&lrflaginsert );
	rgdata[0].SetCb( sizeof(LRFLAGINSERT) );

	rgdata[1].SetPv( kdf.key.prefix.Pv() );
	rgdata[1].SetCb( kdf.key.prefix.Cb() );
	
	rgdata[2].SetPv( kdf.key.suffix.Pv() );
	rgdata[2].SetCb( kdf.key.suffix.Cb() );
	
	rgdata[3].SetPv( kdf.data.Pv() );
	rgdata[3].SetCb( kdf.data.Cb() );

	err = plog->ErrLGLogRec( rgdata, 4, fLGNoNewGen, plgpos );

	// on error, return to before dirty dbtime on page
	if ( JET_errSuccess > err && fDirtyCSR )
		{
		Assert ( dbtimeInvalid !=  lrflaginsert.le_dbtimeBefore && dbtimeNil != lrflaginsert.le_dbtimeBefore);
		Assert ( pcsr->Dbtime() > lrflaginsert.le_dbtimeBefore );
		pcsr->RevertDbtime( lrflaginsert.le_dbtimeBefore );
		}

	return err;
	}
	
ERR ErrLGSetExternalHeader( const FUCB 	*pfucb, 
							CSR 	*pcsr, 
							const DATA&	data, 
							LGPOS		*plgpos,
						const BOOL		fDirtyCSR ) 	// true - if we must dirty the page inside (in witch case dbtime before is in the CSR
						 								// false - record dbtimeInvalid for dbtimeBefore (insert part of split operations)
				 
	{
	ERR					err;
	LRSETEXTERNALHEADER	lrsetextheader;
	DATA				rgdata[2];

	INST *pinst = PinstFromIfmp( pfucb->ifmp );
	LOG *plog = pinst->m_plog;
	
	Assert( !plog->m_fRecovering );
	Assert( fDirtyCSR || pcsr->FDirty() );
	
	if ( plog->m_fLogDisabled )
		{
		if ( fDirtyCSR )
			{
			pcsr->Dirty();
			}		
		*plgpos = lgposMin;
		return JET_errSuccess;
		}

	Assert( rgfmp[pfucb->ifmp].FLogOn() );

	PIB		*ppib	= pfucb->ppib;

	Assert( ppib->level > 0 );

	//	Redo only operation
	
	CallR( ErrLGDeferBeginTransaction( ppib ) );

	lrsetextheader.lrtyp = lrtypSetExternalHeader;
	
	lrsetextheader.le_procid	= ppib->procid;
	lrsetextheader.dbid			= rgfmp[ pfucb->ifmp ].Dbid();
	lrsetextheader.le_pgno		= pcsr->Pgno();
	lrsetextheader.le_pgnoFDP	= PgnoFDP( pfucb );
	lrsetextheader.le_objidFDP	= ObjidFDP( pfucb );

	Assert( !lrsetextheader.FVersioned() );
	Assert( !lrsetextheader.FDeleted() );
	Assert( !lrsetextheader.FUnique() );
	Assert( !lrsetextheader.FSpace() );
	Assert( !lrsetextheader.FConcCI() );

	if ( pfucb->u.pfcb->FUnique() )
		lrsetextheader.SetFUnique();
	if ( FFUCBSpace( pfucb ) )
		lrsetextheader.SetFSpace();

	CallR( ErrLGSetDbtimeBeforeAndDirty( pcsr, &lrsetextheader.le_dbtimeBefore, &lrsetextheader.le_dbtime, fDirtyCSR ) );
	
	LGISetTrx( ppib, &lrsetextheader );
	
	lrsetextheader.SetCbData( USHORT( data.Cb() ) );

	rgdata[0].SetPv( (BYTE *)&lrsetextheader );
	rgdata[0].SetCb( sizeof(LRSETEXTERNALHEADER) );

	rgdata[1].SetPv( data.Pv() );
	rgdata[1].SetCb( data.Cb() );

	err = plog->ErrLGLogRec( rgdata, 2, fLGNoNewGen, plgpos );

	// on error, return to before dirty dbtime on page
	if ( JET_errSuccess > err && fDirtyCSR )
		{
		Assert ( dbtimeInvalid !=  lrsetextheader.le_dbtimeBefore && dbtimeNil != lrsetextheader.le_dbtimeBefore);
		Assert ( pcsr->Dbtime() > lrsetextheader.le_dbtimeBefore );
		pcsr->RevertDbtime( lrsetextheader.le_dbtimeBefore );
		}

	return err;
	}

ERR ErrLGReplace( const FUCB 	* const pfucb, 
				  CSR		* const pcsr,
				  const	DATA&	dataOld, 
				  const DATA&	dataNew,
				  const DATA	* const pdataDiff,
				  const RCEID	rceid,
				  const DIRFLAG	dirflag, 
				  LGPOS			* const plgpos,
				 const BOOL				fDirtyCSR ) 	// true - if we must dirty the page inside (in witch case dbtime before is in the CSR
			 															// false - record dbtimeInvalid for dbtimeBefore (insert part of split operations)
				  
	{
	ERR			err;
	DATA		rgdata[2];
	LRREPLACE	lrreplace;

	INST *pinst = PinstFromIfmp( pfucb->ifmp );
	LOG *plog = pinst->m_plog;
	
	Assert( !plog->m_fRecovering );
	Assert( fDirtyCSR || pcsr->FDirty() );
	
	if ( plog->m_fLogDisabled )
		{
		if ( fDirtyCSR )
			{
			pcsr->Dirty();
			}				
		*plgpos = lgposMin;
		return JET_errSuccess;
		}

	Assert( !( dirflag & fDIRNoLog ) );
	Assert( rgfmp[pfucb->ifmp].FLogOn() );
			  
	PIB	* const ppib = pfucb->ppib;
			  
	//	must be in a transaction since we will not redo level 0 modifications
	//
	Assert( ppib->level > 0 );
	
	CallR( ErrLGDeferBeginTransaction( ppib ) );

	Assert( pcsr->ILine() >= 0 );
	Assert( pcsr->ILine() < ( 1 << 10 ) );
	lrreplace.SetILine( (USHORT)pcsr->ILine() );

	Assert( !lrreplace.FVersioned() );
	Assert( !lrreplace.FDeleted() );
	Assert( !lrreplace.FUnique() );
	Assert( !lrreplace.FSpace() );
	Assert( !lrreplace.FConcCI() );

	if ( !( dirflag & fDIRNoVersion ) )
		lrreplace.SetFVersioned();
	if ( pfucb->u.pfcb->FUnique() )
		lrreplace.SetFUnique();
	if ( FFUCBSpace( pfucb ) )
		lrreplace.SetFSpace();

	lrreplace.le_rceid		= rceid;
	lrreplace.le_pgnoFDP	= PgnoFDP( pfucb );
	lrreplace.le_objidFDP	= ObjidFDP( pfucb );

	lrreplace.le_procid	= ppib->procid;

	CallR( ErrLGSetDbtimeBeforeAndDirty( pcsr, &lrreplace.le_dbtimeBefore, &lrreplace.le_dbtime, fDirtyCSR ) );
							
	lrreplace.dbid			= rgfmp[ pfucb->ifmp ].Dbid();
	lrreplace.le_pgno		= pcsr->Pgno();

	LGISetTrx( ppib, &lrreplace );
	
	lrreplace.SetCbOldData( USHORT( dataOld.Cb() ) );
	lrreplace.SetCbNewData( USHORT( dataNew.Cb() ) );

	rgdata[0].SetPv( (BYTE *)&lrreplace );
	rgdata[0].SetCb( sizeof(LRREPLACE) );

	if ( NULL != pdataDiff )
		{
		lrreplace.lrtyp		= lrtypReplaceD;
		lrreplace.SetCb( (USHORT)pdataDiff->Cb() );
		rgdata[1].SetCb( pdataDiff->Cb() );
		rgdata[1].SetPv( pdataDiff->Pv() );
		}
	else
		{
		lrreplace.lrtyp 	= lrtypReplace;
		lrreplace.SetCb( (USHORT)dataNew.Cb() );
		rgdata[1].SetCb( dataNew.Cb() );
		rgdata[1].SetPv( dataNew.Pv() );
		}

	err = plog->ErrLGLogRec( rgdata, 2, fLGNoNewGen, plgpos );

	// on error, return to before dirty dbtime on page
	if ( JET_errSuccess > err && fDirtyCSR )
		{
		Assert ( dbtimeInvalid !=  lrreplace.le_dbtimeBefore && dbtimeNil != lrreplace.le_dbtimeBefore);
		Assert ( pcsr->Dbtime() > lrreplace.le_dbtimeBefore );
		pcsr->RevertDbtime( lrreplace.le_dbtimeBefore );
		}

	Assert(	lrreplace.Cb() <= lrreplace.CbNewData() );
	Assert( lrreplace.CbNewData() == lrreplace.Cb()
		|| lrreplace.lrtyp == lrtypReplaceD );
	return err;
	}

ERR ErrLGAtomicReplaceAndCommit(
		const FUCB 	* const pfucb, 
		CSR		* const pcsr,
		const	DATA&	dataOld, 
		const DATA&	dataNew,
		const DATA	* const pdataDiff,
		const DIRFLAG	dirflag, 
		LGPOS			* const plgpos,
		const BOOL				fDirtyCSR ) 	// true - if we must dirty the page inside (in witch case dbtime before is in the CSR
			 															// false - record dbtimeInvalid for dbtimeBefore (insert part of split operations)				  
	{
	ERR			err;
	DATA		rgdata[3];
	LRREPLACE	lrreplace;
	LRCOMMIT0	lrcommit0;

	INST *pinst = PinstFromIfmp( pfucb->ifmp );
	LOG *plog = pinst->m_plog;
	
	Assert( !plog->m_fRecovering );
	Assert( fDirtyCSR || pcsr->FDirty() );
	
	if ( plog->m_fLogDisabled )
		{
		if ( fDirtyCSR )
			{
			pcsr->Dirty();
			}				
		*plgpos = lgposMin;
		return JET_errSuccess;
		}

	Assert( !( dirflag & fDIRNoLog ) );
	Assert( rgfmp[pfucb->ifmp].FLogOn() );
			  
	PIB	* const ppib = pfucb->ppib;
			  
	//	must be in a transaction since we will not redo level 0 modifications
	//
	Assert( ppib->level > 0 );
	
	CallR( ErrLGDeferBeginTransaction( ppib ) );

	Assert( pcsr->ILine() >= 0 );
	Assert( pcsr->ILine() < ( 1 << 10 ) );
	lrreplace.SetILine( (USHORT)pcsr->ILine() );

	Assert( !lrreplace.FVersioned() );
	Assert( !lrreplace.FDeleted() );
	Assert( !lrreplace.FUnique() );
	Assert( !lrreplace.FSpace() );
	Assert( !lrreplace.FConcCI() );

	Assert( !FFUCBSpace( pfucb ) );
	Assert( pfucb->u.pfcb->FUnique() );
	
	lrreplace.SetFUnique();

	lrreplace.le_rceid		= rceidNull;
	lrreplace.le_pgnoFDP	= PgnoFDP( pfucb );
	lrreplace.le_objidFDP	= ObjidFDP( pfucb );

	lrreplace.le_procid		= ppib->procid;

	CallR( ErrLGSetDbtimeBeforeAndDirty( pcsr, &lrreplace.le_dbtimeBefore, &lrreplace.le_dbtime, fDirtyCSR ) );
							
	lrreplace.dbid			= rgfmp[ pfucb->ifmp ].Dbid();
	lrreplace.le_pgno		= pcsr->Pgno();

	LGISetTrx( ppib, &lrreplace );
	
	lrreplace.SetCbOldData( USHORT( dataOld.Cb() ) );
	lrreplace.SetCbNewData( USHORT( dataNew.Cb() ) );

	rgdata[0].SetPv( (BYTE *)&lrreplace );
	rgdata[0].SetCb( sizeof(LRREPLACE) );

	if ( NULL != pdataDiff )
		{
		lrreplace.lrtyp		= lrtypReplaceD;
		lrreplace.SetCb( (USHORT)pdataDiff->Cb() );
		rgdata[1].SetCb( pdataDiff->Cb() );
		rgdata[1].SetPv( pdataDiff->Pv() );
		}
	else
		{
		lrreplace.lrtyp 	= lrtypReplace;
		lrreplace.SetCb( (USHORT)dataNew.Cb() );
		rgdata[1].SetCb( dataNew.Cb() );
		rgdata[1].SetPv( dataNew.Pv() );
		}

	Assert( ppib->procid < 64000 );
	Assert( ppib->trxCommit0 != trxMax );
	Assert( 1 == ppib->level );	//  this can only be used to commit from level 1 to level 0
	
	lrcommit0.le_trxCommit0 = ppib->trxCommit0;
	lrcommit0.lrtyp 		= lrtypCommit0;
	lrcommit0.le_procid 	= (USHORT) ppib->procid;
	lrcommit0.levelCommitTo	= 0;

	rgdata[2].SetPv( (BYTE *)&lrcommit0 );
	rgdata[2].SetCb( sizeof(LRCOMMIT0) );

	err = plog->ErrLGLogRec( rgdata, 3, fLGNoNewGen, plgpos );

	// on error, return to before dirty dbtime on page
	if ( JET_errSuccess > err && fDirtyCSR )
		{
		Assert ( dbtimeInvalid !=  lrreplace.le_dbtimeBefore && dbtimeNil != lrreplace.le_dbtimeBefore);
		Assert ( pcsr->Dbtime() > lrreplace.le_dbtimeBefore );
		pcsr->RevertDbtime( lrreplace.le_dbtimeBefore );
		}

	Assert(	lrreplace.Cb() <= lrreplace.CbNewData() );
	Assert( lrreplace.CbNewData() == lrreplace.Cb()
		|| lrreplace.lrtyp == lrtypReplaceD );
	return err;
	}


//	log Deferred Undo Info of given RCE.
 
ERR ErrLGIUndoInfo( const RCE *prce, LGPOS *plgpos, const BOOL fRetry )
	{
	ERR				err;
	FUCB   			* pfucb			= prce->Pfucb();
	const PGNO		pgnoUndoInfo	= prce->PgnoUndoInfo();
	INST			* pinst			= PinstFromIfmp( pfucb->ifmp );
	LOG				* plog			= pinst->m_plog;
	LRUNDOINFO		lrundoinfo;
	DATA   			rgdata[4];

	*plgpos = lgposMin;
	
	//	NOTE: even during recovering, we might want to record it if
	//	NOTE: it is logging during undo in LGEndAllSession.
	//
	Assert( !rgfmp[pfucb->ifmp].FLogOn() || !plog->m_fLogDisabled );
	if ( !rgfmp[pfucb->ifmp].FLogOn() )
		{		
		return JET_errSuccess;
		}

	//	Multiple threads may be trying to log UndoInfo (BF when it flushes or
	//	original thread when transaction is rolled back)
	//	It doesn't actually matter if multiple UndoInfo's are logged (on
	//	recovery, any UndoInfo log records beyond the first will cause
	//	be ignored because version creation will err out with JET_errPreviousVersion).
	if ( pgnoNull == pgnoUndoInfo )
		{
		//	someone beat us to it, so just bail out
		return JET_errSuccess;
		}

	if ( plog->m_fLogDisabledDueToRecoveryFailure )
		{
		return ErrERRCheck( JET_errLogDisabledDueToRecoveryFailure );
		}
		
	if ( plog->m_fRecovering && plog->m_fRecoveringMode == fRecoveringRedo )
		{
		return ErrERRCheck( JET_errCannotLogDuringRecoveryRedo );
		}

	Assert( pfucb->ppib->level > 0 );

	lrundoinfo.lrtyp		= lrtypUndoInfo;
	lrundoinfo.le_procid	= pfucb->ppib->procid;
	lrundoinfo.dbid			= rgfmp[ pfucb->ifmp ].Dbid();

	Assert( !lrundoinfo.FVersioned() );
	Assert( !lrundoinfo.FDeleted() );
	Assert( !lrundoinfo.FUnique() );
	Assert( !lrundoinfo.FSpace() );
	Assert( !lrundoinfo.FConcCI() );

	if ( pfucb->u.pfcb->FUnique() )
		lrundoinfo.SetFUnique();

	Assert( !FFUCBSpace( pfucb ) );

	lrundoinfo.le_dbtime		= dbtimeNil;
	lrundoinfo.le_dbtimeBefore 	= dbtimeNil;

	Assert( rceidNull != prce->Rceid() );
	lrundoinfo.le_rceid		= prce->Rceid();
	lrundoinfo.le_pgnoFDP	= prce->PgnoFDP();
	lrundoinfo.le_objidFDP	= prce->ObjidFDP();

	lrundoinfo.le_pgno		= pgnoUndoInfo;
	lrundoinfo.level	= prce->Level();
	lrundoinfo.le_trxBegin0 = prce->TrxBegin0();
	lrundoinfo.le_oper		= USHORT( prce->Oper() );
	if ( prce->FOperReplace() )
		{
		Assert( prce->CbData() > cbReplaceRCEOverhead );
		lrundoinfo.le_cbData	= USHORT( prce->CbData() - cbReplaceRCEOverhead );

		VERREPLACE* const pverreplace = (VERREPLACE*)prce->PbData();
		lrundoinfo.le_cbMaxSize = (SHORT) pverreplace->cbMaxSize;
		lrundoinfo.le_cbDelta	= (SHORT) pverreplace->cbDelta;
		}
	else
		{
		Assert( prce->CbData() == 0 );
		lrundoinfo.le_cbData = 0;
		}

	BOOKMARK	bm;
	prce->GetBookmark( &bm );
	Assert( bm.key.prefix.FNull() );
	lrundoinfo.SetCbBookmarkData( USHORT( bm.data.Cb() ) );
	lrundoinfo.SetCbBookmarkKey( USHORT( bm.key.suffix.Cb() ) );

	rgdata[0].SetPv( (BYTE *)&lrundoinfo );
	rgdata[0].SetCb( sizeof(LRUNDOINFO) );

	Assert( 0 == bm.key.prefix.Cb() );
	rgdata[1].SetPv( bm.key.suffix.Pv() );
	rgdata[1].SetCb( lrundoinfo.CbBookmarkKey() );

	rgdata[2].SetPv( bm.data.Pv() );
	rgdata[2].SetCb( lrundoinfo.CbBookmarkData() );
	
	rgdata[3].SetPv( const_cast<BYTE *>( prce->PbData() ) + cbReplaceRCEOverhead );
	rgdata[3].SetCb( lrundoinfo.le_cbData );

	forever
		{
		err = plog->ErrLGTryLogRec( rgdata, 4, fLGNoNewGen, plgpos );
		if ( errLGNotSynchronous != err || !fRetry )
			break;

		UtilSleep( cmsecWaitLogFlush );
		}

	return err;
	}


ERR ErrLGFlagDelete( const FUCB * const pfucb, 
					 CSR	* const pcsr,
					 const RCEID	rceid,
					 const DIRFLAG 	dirflag,
					 LGPOS		* const plgpos,
					 const VERPROXY	* const pverproxy,
					 const BOOL				fDirtyCSR ) 	// true - if we must dirty the page inside (in witch case dbtime before is in the CSR
				 											// false - record dbtimeInvalid for dbtimeBefore (insert part of split operations)
				 	
	{
	ERR				err;
	LRFLAGDELETE	lrflagdelete;
	DATA			rgdata[1];

	INST *pinst = PinstFromIfmp( pfucb->ifmp );
	LOG *plog = pinst->m_plog;
	
	Assert( !plog->m_fRecovering );
	Assert( fDirtyCSR || pcsr->FDirty() );
	
	if ( plog->m_fLogDisabled )
		{
		if ( fDirtyCSR )
			{
			pcsr->Dirty();
			}				
		*plgpos = lgposMin;
		return JET_errSuccess;
		}

	Assert( !( dirflag & fDIRNoLog ) );
	Assert( rgfmp[pfucb->ifmp].FLogOn() );

	Assert( NULL == pverproxy ||
			prceNil != pverproxy->prcePrimary &&
			( pverproxy->prcePrimary->TrxCommitted() != trxMax ||
			  pfucbNil != pverproxy->prcePrimary->Pfucb() &&
			  ppibNil != pverproxy->prcePrimary->Pfucb()->ppib ) );
			  
	PIB	* const ppib = pverproxy != NULL && 
					trxMax == pverproxy->prcePrimary->TrxCommitted() ?
						pverproxy->prcePrimary->Pfucb()->ppib :
						pfucb->ppib;
			  
	//	assert in a transaction since will not redo level 0 modifications
	//
	Assert( ppib->level > 0 );
	
	CallR( ErrLGDeferBeginTransaction( ppib ) );
	
	lrflagdelete.lrtyp		= lrtypFlagDelete;

	Assert( pcsr->ILine() >= 0 );
	Assert( pcsr->ILine() < ( 1 << 10 ) );
	lrflagdelete.SetILine( (USHORT)pcsr->ILine() );
	lrflagdelete.le_procid		= ppib->procid;

	CallR( ErrLGSetDbtimeBeforeAndDirty( pcsr, &lrflagdelete.le_dbtimeBefore, &lrflagdelete.le_dbtime, fDirtyCSR ) );
	
	lrflagdelete.dbid			= rgfmp[ pfucb->ifmp ].Dbid();
	lrflagdelete.le_pgno		= pcsr->Pgno();

	Assert( !lrflagdelete.FVersioned() );
	Assert( !lrflagdelete.FDeleted() );
	Assert( !lrflagdelete.FUnique() );
	Assert( !lrflagdelete.FSpace() );
	Assert( !lrflagdelete.FConcCI() );

	if ( !( dirflag & fDIRNoVersion ) )
		lrflagdelete.SetFVersioned();
	if ( pfucb->u.pfcb->FUnique() )
		lrflagdelete.SetFUnique();
	if ( FFUCBSpace( pfucb ) )
		lrflagdelete.SetFSpace();
	if ( NULL != pverproxy )
		lrflagdelete.SetFConcCI();

	LGISetTrx( ppib, &lrflagdelete, pverproxy );

	lrflagdelete.le_rceid		= rceid;
	lrflagdelete.le_pgnoFDP	= PgnoFDP( pfucb );
	lrflagdelete.le_objidFDP	= ObjidFDP( pfucb );
	
	rgdata[0].SetPv( (BYTE *)&lrflagdelete );
	rgdata[0].SetCb( sizeof(LRFLAGDELETE) );

	err = plog->ErrLGLogRec( rgdata, 1, fLGNoNewGen, plgpos );

	// on error, return to before dirty dbtime on page
	if ( JET_errSuccess > err && fDirtyCSR )
		{
		Assert ( dbtimeInvalid !=  lrflagdelete.le_dbtimeBefore && dbtimeNil != lrflagdelete.le_dbtimeBefore);
		Assert ( pcsr->Dbtime() > lrflagdelete.le_dbtimeBefore );
		pcsr->RevertDbtime( lrflagdelete.le_dbtimeBefore );
		}

	return err;
	}

	
ERR ErrLGDelete( 	const FUCB 		*pfucb,
					CSR 			*pcsr,
					LGPOS 			*plgpos , 
					const BOOL		fDirtyCSR ) 	// true - if we must dirty the page inside (in witch case dbtime before is in the CSR
							 								// false - record dbtimeInvalid for dbtimeBefore (insert part of split operations)
	{
	ERR			err;
	LRDELETE	lrdelete;
	DATA		rgdata[1];

	INST *pinst = PinstFromIfmp( pfucb->ifmp );
	LOG *plog = pinst->m_plog;

	Assert( fDirtyCSR || pcsr->FDirty() );
	if ( plog->m_fRecovering || plog->m_fLogDisabled )
		{
		if ( fDirtyCSR )
			{
			pcsr->Dirty();
			}
		*plgpos = lgposMin;
		return JET_errSuccess;
		}

	Assert( rgfmp[pfucb->ifmp].FLogOn() );

	//	assert in a transaction since will not redo level 0 modifications
	//
	PIB		*ppib	= pfucb->ppib;
	Assert( ppib->level > 0 );


	//	Redo only operation

	CallR( ErrLGDeferBeginTransaction( ppib ) );

	lrdelete.lrtyp		= lrtypDelete;

	Assert( pcsr->ILine() >= 0 );
	Assert( pcsr->ILine() < ( 1 << 10 ) );
	lrdelete.SetILine( (USHORT)pcsr->ILine() );
	lrdelete.le_procid		= ppib->procid;

	CallR( ErrLGSetDbtimeBeforeAndDirty( pcsr, &lrdelete.le_dbtimeBefore, &lrdelete.le_dbtime, fDirtyCSR ) );

	lrdelete.le_pgnoFDP	= PgnoFDP( pfucb );
	lrdelete.le_objidFDP	= ObjidFDP( pfucb );
	
	lrdelete.le_pgno		= pcsr->Pgno();
	lrdelete.dbid			= rgfmp[ pfucb->ifmp ].Dbid();

	Assert( !lrdelete.FVersioned() );
	Assert( !lrdelete.FDeleted() );
	Assert( !lrdelete.FUnique() );
	Assert( !lrdelete.FSpace() );
	Assert( !lrdelete.FConcCI() );

	if ( pfucb->u.pfcb->FUnique() )
		lrdelete.SetFUnique();
	if ( FFUCBSpace( pfucb ) )
		lrdelete.SetFSpace();

	LGISetTrx( ppib, &lrdelete );
	
	rgdata[0].SetPv( (BYTE *)&lrdelete );
	rgdata[0].SetCb( sizeof(LRDELETE) );

	err = plog->ErrLGLogRec( rgdata, 1, fLGNoNewGen, plgpos );

	// on error, return to before dirty dbtime on page
	if ( JET_errSuccess > err && fDirtyCSR )
		{
		Assert ( dbtimeInvalid !=  lrdelete.le_dbtimeBefore && dbtimeNil != lrdelete.le_dbtimeBefore);
		Assert ( pcsr->Dbtime() > lrdelete.le_dbtimeBefore );
		pcsr->RevertDbtime( lrdelete.le_dbtimeBefore );
		}

	return err;
	}


ERR ErrLGUndo( 	RCE 			*prce,
				CSR 			*pcsr,
				const BOOL		fDirtyCSR ) 	// true - if we must dirty the page inside (in witch case dbtime before is in the CSR
				 								// false - record dbtimeInvalid for dbtimeBefore (insert part of split operations)
	{
	ERR				err;
	FUCB * 			pfucb 			= prce->Pfucb();
	LRUNDO			lrundo;
	DATA   			rgdata[3];
	LGPOS			lgpos;

	INST *pinst = PinstFromIfmp( pfucb->ifmp );
	LOG *plog = pinst->m_plog;

	Assert( fDirtyCSR );
	
	//	NOTE: even during recovering, we want to record it
	//
	if ( plog->m_fLogDisabled || ( plog->m_fRecovering && plog->m_fRecoveringMode != fRecoveringUndo ) )
		{
		pcsr->Dirty();
		Assert( pcsr->Dbtime() == pcsr->Cpage().Dbtime() );

		// During ForceDetach we may crash after we did some undo's
		// To avoid replaying those we change dbtime on the page with 
		// a new dbtime that will be check if we retry the undo
		if ( rgfmp[pfucb->ifmp].FUndoForceDetach() )
			{
			pcsr->SetDbtime( rgfmp[pfucb->ifmp].DbtimeUndoForceDetach() - prce->Rceid() );
			// update the dbtime of the db after the redo phase (dbtimeCurrent)
			Assert ( pcsr->Dbtime() > rgfmp[ pfucb->ifmp ].DbtimeCurrentDuringRecovery() );
			rgfmp[ pfucb->ifmp ].SetDbtimeCurrentDuringRecovery( pcsr->Dbtime() );
			}
		return JET_errSuccess;
		}
		
	Assert ( !rgfmp[pfucb->ifmp].FUndoForceDetach() );

	if ( !rgfmp[pfucb->ifmp].FLogOn() )
		{
		pcsr->Dirty();
		Assert( pcsr->Dbtime() == pcsr->Cpage().Dbtime() );
		return JET_errSuccess;
		}

	// only undo during normal operations must go this way
	// in this case the CSR must be the same as in the FUCB (from RCE)
	Assert ( Pcsr( pfucb ) == pcsr );

	
	//	must be in a transaction since we will not redo level 0 modifications
	//
	PIB		*ppib	= pfucb->ppib;
	Assert( ppib->level > 0 );
	
	Assert( pcsr->FLatched() );
	Assert( fDirtyCSR || pcsr->FDirty() );

	CallR( ErrLGDeferBeginTransaction( ppib ) );
	
	lrundo.lrtyp		= lrtypUndo;
	
	lrundo.level		= prce->Level();
	lrundo.le_procid		= ppib->procid;

	CallR( ErrLGSetDbtimeBeforeAndDirty( pcsr, &lrundo.le_dbtimeBefore, &lrundo.le_dbtime, fDirtyCSR ) );

	lrundo.dbid				= rgfmp[prce->Pfucb()->ifmp].Dbid();
	lrundo.le_oper			= USHORT( prce->Oper() );
	Assert( lrundo.le_oper == prce->Oper() );		// regardless the size 
	Assert( lrundo.le_oper != operMaskNull );
	
	Assert( pcsr->ILine() >= 0 );
	Assert( pcsr->ILine() < ( 1 << 10 ) );
	lrundo.SetILine( (USHORT)pcsr->ILine() );
	lrundo.le_pgno			= pcsr->Pgno();

	Assert( !lrundo.FVersioned() );
	Assert( !lrundo.FDeleted() );
	Assert( !lrundo.FUnique() );
	Assert( !lrundo.FSpace() );
	Assert( !lrundo.FConcCI() );

	if ( pfucb->u.pfcb->FUnique() )
		lrundo.SetFUnique();

	Assert( !FFUCBSpace( pfucb ) );

	LGISetTrx( ppib, &lrundo );
	
	lrundo.le_rceid		= prce->Rceid();
	lrundo.le_pgnoFDP 	= PgnoFDP( pfucb );
	lrundo.le_objidFDP 	= ObjidFDP( pfucb );

	BOOKMARK	bm;
	prce->GetBookmark( &bm );

	Assert( bm.key.prefix.FNull() );
	lrundo.SetCbBookmarkKey( USHORT( bm.key.Cb() ) );
	lrundo.SetCbBookmarkData( USHORT( bm.data.Cb() ) );
	
	rgdata[0].SetPv( (BYTE *)&lrundo );
	rgdata[0].SetCb( sizeof(LRUNDO) );

	rgdata[1].SetPv( bm.key.suffix.Pv() );
	rgdata[1].SetCb( lrundo.CbBookmarkKey() );

	rgdata[2].SetPv( bm.data.Pv() );
	rgdata[2].SetCb( bm.data.Cb() );
	Assert( !lrundo.FUnique() || bm.data.FNull() );

	Call( plog->ErrLGLogRec( rgdata, 3, fLGNoNewGen, &lgpos ) );
	CallS( err );
	Assert( pcsr->Latch() == latchWrite );

	pcsr->Cpage().SetLgposModify( lgpos );

	Assert ( JET_errSuccess <= err );

HandleError:
	// on error, return to before dirty dbtime on page
	if ( JET_errSuccess > err && fDirtyCSR )
		{
		Assert ( dbtimeInvalid !=  lrundo.le_dbtimeBefore && dbtimeNil != lrundo.le_dbtimeBefore);
		Assert ( pcsr->Dbtime() > lrundo.le_dbtimeBefore );
		pcsr->RevertDbtime( lrundo.le_dbtimeBefore );
		}

	return err;
	}


ERR ErrLGDelta( const FUCB 		*pfucb, 
				CSR		*pcsr,
				const BOOKMARK&	bm,
				INT				cbOffset,
				LONG	 		lDelta, 
				RCEID			rceid,
				DIRFLAG			dirflag,
				LGPOS			*plgpos,
			 	const BOOL		fDirtyCSR ) 	// true - if we must dirty the page inside (in witch case dbtime before is in the CSR
				 								// false - record dbtimeInvalid for dbtimeBefore (insert part of split operations)
				 
	{
	DATA		rgdata[4];
	LRDELTA		lrdelta;
	ERR			err;

	INST *pinst = PinstFromIfmp( pfucb->ifmp );
	LOG *plog = pinst->m_plog;
	
	Assert( !plog->m_fRecovering );
	Assert( fDirtyCSR || pcsr->FDirty() );
	
	if ( plog->m_fLogDisabled )
		{
		if ( fDirtyCSR )
			{
			pcsr->Dirty();
			}				
		*plgpos = lgposMin;
		return JET_errSuccess;
		}

	Assert( rgfmp[pfucb->ifmp].FLogOn() );
			  
	PIB		* const ppib = pfucb->ppib;
			  
	//	must be in a transaction since we will not redo level 0 modifications
	//
	Assert( ppib->level > 0 );

	CallR( ErrLGDeferBeginTransaction( ppib ) );

	lrdelta.lrtyp		= lrtypDelta;

	Assert( pcsr->ILine() >= 0 );
	Assert( pcsr->ILine() < ( 1 << 10 ) );
	lrdelta.SetILine( (USHORT)pcsr->ILine() );
	lrdelta.le_procid		= ppib->procid;

	CallR( ErrLGSetDbtimeBeforeAndDirty( pcsr, &lrdelta.le_dbtimeBefore, &lrdelta.le_dbtime, fDirtyCSR ) );

	lrdelta.dbid		= rgfmp[ pfucb->ifmp ].Dbid();
	lrdelta.le_pgno		= pcsr->Pgno();

	Assert( !lrdelta.FVersioned() );
	Assert( !lrdelta.FDeleted() );
	Assert( !lrdelta.FUnique() );
	Assert( !lrdelta.FSpace() );
	Assert( !lrdelta.FConcCI() );

	if ( !( dirflag & fDIRNoVersion ) )
		lrdelta.SetFVersioned();
	if ( pfucb->u.pfcb->FUnique() )
		lrdelta.SetFUnique();

	Assert( !FFUCBSpace( pfucb ) );

	LGISetTrx( ppib, &lrdelta );
	
	lrdelta.le_rceid		= rceid;
	lrdelta.le_pgnoFDP		= PgnoFDP( pfucb );
	lrdelta.le_objidFDP	= ObjidFDP( pfucb );

	lrdelta.SetCbBookmarkKey( USHORT( bm.key.Cb() ) );
	lrdelta.SetCbBookmarkData( USHORT( bm.data.Cb() ) );
	Assert( 0 == bm.data.Cb() );
	
	lrdelta.SetLDelta( lDelta );

	Assert( cbOffset < g_cbPage );
	lrdelta.SetCbOffset( USHORT( cbOffset ) );
	
	rgdata[0].SetPv( (BYTE *)&lrdelta );
	rgdata[0].SetCb( sizeof( LRDELTA ) );

	rgdata[1].SetPv( bm.key.prefix.Pv() );
	rgdata[1].SetCb( bm.key.prefix.Cb() );

	rgdata[2].SetPv( bm.key.suffix.Pv() );
	rgdata[2].SetCb( bm.key.suffix.Cb() );

	rgdata[3].SetPv( bm.data.Pv() );
	rgdata[3].SetCb( bm.data.Cb() );
	
	err = plog->ErrLGLogRec( rgdata, 4, fLGNoNewGen, plgpos );

	// on error, return to before dirty dbtime on page
	if ( JET_errSuccess > err && fDirtyCSR )
		{
		Assert ( dbtimeInvalid !=  lrdelta.le_dbtimeBefore && dbtimeNil != lrdelta.le_dbtimeBefore);
		Assert ( pcsr->Dbtime() > lrdelta.le_dbtimeBefore );
		pcsr->RevertDbtime( lrdelta.le_dbtimeBefore );
		}

	return err;
	}


ERR ErrLGSLVSpace( 	const FUCB 			* const pfucb, 
					CSR					* const pcsr,
					const BOOKMARK&		bm,
					const SLVSPACEOPER 	oper,
					const LONG			ipage,
					const LONG			cpages,
					const RCEID			rceid,
					const DIRFLAG		dirflag,
					LGPOS				* const plgpos,
					const BOOL			fDirtyCSR ) 	// true - if we must dirty the page inside (in witch case dbtime before is in the CSR
							 							// false - record dbtimeInvalid for dbtimeBefore (insert part of split operations)
	{
	DATA		rgdata[4];
	LRSLVSPACE	lrslvspace;
	ERR			err;

	INST * const pinst 	= PinstFromIfmp( pfucb->ifmp );
	LOG * const plog 	= pinst->m_plog;
	
	Assert( !plog->m_fRecovering );
	Assert( fDirtyCSR || pcsr->FDirty() );
	
	if ( plog->m_fLogDisabled )
		{
		if ( fDirtyCSR )
			{
			pcsr->Dirty();
			}
		*plgpos = lgposMin;
		return JET_errSuccess;
		}

	Assert( rgfmp[pfucb->ifmp].FLogOn() );
			  
	PIB		* const ppib = pfucb->ppib;
			  
	//	must be in a transaction since we will not redo level 0 modifications
	//
	Assert( ppib->level > 0 );

	CallR( ErrLGDeferBeginTransaction( ppib ) );

	lrslvspace.lrtyp		= lrtypSLVSpace;

	Assert( pcsr->ILine() >= 0 );
	Assert( pcsr->ILine() < ( 1 << 10 ) );
	lrslvspace.SetILine( (USHORT)pcsr->ILine() );
	lrslvspace.le_procid		= ppib->procid;

	CallR( ErrLGSetDbtimeBeforeAndDirty( pcsr, &lrslvspace.le_dbtimeBefore, &lrslvspace.le_dbtime, fDirtyCSR ) );
	
	lrslvspace.dbid			= rgfmp[ pfucb->ifmp ].Dbid();
	lrslvspace.le_pgno		= pcsr->Pgno();

	Assert( !lrslvspace.FVersioned() );
	Assert( !lrslvspace.FDeleted() );
	Assert( !lrslvspace.FUnique() );
	Assert( !lrslvspace.FSpace() );
	Assert( !lrslvspace.FConcCI() );

	if ( !( dirflag & fDIRNoVersion ) )
		lrslvspace.SetFVersioned();
	if ( pfucb->u.pfcb->FUnique() )
		lrslvspace.SetFUnique();

	Assert( !FFUCBSpace( pfucb ) );

	LGISetTrx( ppib, &lrslvspace );
	
	lrslvspace.le_rceid		= rceid;
	lrslvspace.le_pgnoFDP		= PgnoFDP( pfucb );
	lrslvspace.le_objidFDP	= ObjidFDP( pfucb );

	lrslvspace.le_cbBookmarkKey = USHORT( bm.key.Cb() );
	lrslvspace.le_cbBookmarkData = USHORT( bm.data.Cb() );
	Assert( 0 == bm.data.Cb() );

	Assert( oper >= 0 );
	Assert( oper <= 0xff );
	lrslvspace.oper			= BYTE( oper );
	Assert( ipage >= 0 );
	Assert( ipage <= 0xffff );
	lrslvspace.le_ipage		= USHORT( ipage );
	Assert( cpages >= 0 );
	Assert( cpages <= 0xffff );
	lrslvspace.le_cpages	= USHORT( cpages );

	rgdata[0].SetPv( (BYTE *)&lrslvspace );
	rgdata[0].SetCb( sizeof( lrslvspace ) );

	rgdata[1].SetPv( bm.key.prefix.Pv() );
	rgdata[1].SetCb( bm.key.prefix.Cb() );

	rgdata[2].SetPv( bm.key.suffix.Pv() );
	rgdata[2].SetCb( bm.key.suffix.Cb() );

	rgdata[3].SetPv( bm.data.Pv() );
	rgdata[3].SetCb( bm.data.Cb() );
	
	err = plog->ErrLGLogRec( rgdata, 4, fLGNoNewGen, plgpos );

	// on error, return to before dirty dbtime on page
	if ( JET_errSuccess > err && fDirtyCSR )
		{
		Assert ( dbtimeInvalid !=  lrslvspace.le_dbtimeBefore && dbtimeNil != lrslvspace.le_dbtimeBefore);
		Assert ( pcsr->Dbtime() > lrslvspace.le_dbtimeBefore );
		pcsr->RevertDbtime( lrslvspace.le_dbtimeBefore );
		}

	return err;
	}


		//**************************************************
		//     Transaction Operations                       
		//**************************************************


//	logs deferred open transactions.  No error returned since
//	failure to log results in termination.
//
LOCAL ERR ErrLGIDeferBeginTransaction( PIB *ppib )
	{
	ERR	   		err;
	DATA		rgdata[1];
	LRBEGINDT	lrbeginDT;

	INST *pinst = PinstFromPpib( ppib );
	LOG *plog = pinst->m_plog;
	
	ENTERCRITICALSECTION	enterCritLogDeferBeginTrx( &ppib->critLogDeferBeginTrx );

	//	check again, because if a proxy existed, it may have logged
	//	the defer-begin for us
	if ( 0 == ppib->clevelsDeferBegin )
		{
		return JET_errSuccess;
		}

	Assert( !plog->m_fLogDisabled );
	Assert( ppib->clevelsDeferBegin > 0 );
	Assert( !plog->m_fRecovering );

	//	if using reserve log space, try to allocate more space
	//	to resume normal logging.

	//	HACK: use the file-system stored in the INST
	//		  (otherwise, we will need to drill a pfsapi down through to EVERY logged operation that 
	//		   begins a deferred operation and that means ALL the B-Tree code will be touched among
	//		   other things)
	CallR( ErrLGCheckState( plog->m_pinst->m_pfsapi, plog ) );

	//	begin transaction may be logged during rollback if
	//	rollback is from a higher transaction level which has
	//	not performed any updates.
	//
	Assert( ppib->procid < 64000 );
	lrbeginDT.le_procid = (USHORT) ppib->procid;

	lrbeginDT.levelBeginFrom = ppib->levelBegin;
	Assert(	lrbeginDT.levelBeginFrom >= 0 );
	Assert( lrbeginDT.levelBeginFrom <= levelMax );
	lrbeginDT.clevelsToBegin = (BYTE)ppib->clevelsDeferBegin;
	Assert(	lrbeginDT.clevelsToBegin >= 0 );
	Assert( lrbeginDT.clevelsToBegin <= levelMax );

	rgdata[0].SetPv( (BYTE *) &lrbeginDT );
	if ( 0 == lrbeginDT.levelBeginFrom )
		{
		Assert( ppib->trxBegin0 != trxMax );
///		Assert( ppib->trxBegin0 != trxMin );	//	wrap-around can make this true
		lrbeginDT.le_trxBegin0 = ppib->trxBegin0;

		if ( ppib->FDistributedTrx() )
			{
			lrbeginDT.lrtyp = lrtypBeginDT;
			rgdata[0].SetCb( sizeof(LRBEGINDT) );
			}
		else
			{
			lrbeginDT.lrtyp = lrtypBegin0;
			rgdata[0].SetCb( sizeof(LRBEGIN0) );
			}
		}
	else
		{
		lrbeginDT.lrtyp = lrtypBegin;
		rgdata[0].SetCb( sizeof(LRBEGIN) );
		}

	LGPOS lgposLogRec;
	err = plog->ErrLGLogRec( rgdata, 1, fLGNoNewGen, &lgposLogRec );

	//	reset deferred open transaction count
	//	Also set the ppib->lgposStart if it is begin for level 0.
	//
	if ( err >= 0 )
		{
		ppib->clevelsDeferBegin = 0;
		if ( 0 == lrbeginDT.levelBeginFrom )
			{	
			ppib->SetFBegin0Logged();
			ppib->lgposStart = lgposLogRec;
			}
		}

	return err;
	}

#ifdef DEBUG
VOID LGJetOp( JET_SESID sesid, INT op )
	{
	DATA		rgdata[1];
	PIB			*ppib = (PIB *) sesid;
	LRJETOP		lrjetop;

	if ( sesid == (JET_SESID)0xffffffff )
		return;

	INST *pinst = PinstFromPpib( ppib );
	LOG *plog = pinst->m_plog;
	
	if ( !plog->m_fLogDisabled && !plog->m_fRecovering )
		{
		Assert( plog->m_fLogDisabled == fFalse );
		Assert( plog->m_fRecovering == fFalse );

		lrjetop.lrtyp = lrtypJetOp;
		Assert( ppib->procid < 64000 );
		lrjetop.le_procid = (USHORT) ppib->procid;
		lrjetop.op = (BYTE)op;
		rgdata[0].SetPv( (BYTE *) &lrjetop );
		rgdata[0].SetCb( sizeof(LRJETOP) );
	
		plog->ErrLGLogRec( rgdata, 1, fLGNoNewGen, pNil );
		}
	}
#endif

ERR ErrLGBeginTransaction( PIB * const ppib )
	{
	const INST	* const pinst	= PinstFromPpib( ppib );
	const LOG	* const plog	= pinst->m_plog;
	
	if ( plog->m_fLogDisabled || plog->m_fRecovering )
		return JET_errSuccess;

	if ( 0 == ppib->clevelsDeferBegin )
		{
		ppib->levelBegin = ppib->level;
		}

	ppib->clevelsDeferBegin++;
	Assert( ppib->clevelsDeferBegin < levelMax );

	return JET_errSuccess;
	}


ERR ErrLGRefreshTransaction( PIB *ppib )
	{
	ERR			err;
	LRREFRESH	lrrefresh;
	DATA		rgdata[1];
	
	INST *pinst = PinstFromPpib( ppib );
	LOG *plog = pinst->m_plog;
	
	if ( plog->m_fLogDisabled || plog->m_fRecovering )
		return JET_errSuccess;

	//	Dead code
	
	CallR( ErrLGDeferBeginTransaction( ppib ) );

	//	log refresh operation
	//
	rgdata[0].SetPv( (BYTE *) &lrrefresh );
	rgdata[0].SetCb( sizeof ( LRREFRESH ) );
	lrrefresh.lrtyp = lrtypRefresh;
	Assert( ppib->procid < 64000 );
	lrrefresh.le_procid = (USHORT) ppib->procid;
	lrrefresh.le_trxBegin0 = (ppib)->trxBegin0;		

	plog->ErrLGLogRec( rgdata, 1, fLGNoNewGen, pNil );

	return JET_errSuccess;
	}

ERR ErrLGCommitTransaction( PIB *ppib, const LEVEL levelCommitTo, LGPOS *plgposRec )
	{
	ERR			err;
	DATA		rgdata[1];
	LRCOMMIT0	lrcommit0;

	INST *pinst = PinstFromPpib( ppib );
	LOG *plog = pinst->m_plog;

	*plgposRec = lgposMax;
	
	if ( plog->m_fLogDisabled || ( plog->m_fRecovering && plog->m_fRecoveringMode != fRecoveringUndo ) )
		return JET_errSuccess;

	if ( ppib->clevelsDeferBegin > 0 )
		{
		Assert( !plog->m_fRecovering );
		ppib->clevelsDeferBegin--;
		if ( levelCommitTo == 0 )
			{
			Assert( 0 == ppib->clevelsDeferBegin );
			Assert( !ppib->FBegin0Logged() );
			*plgposRec = lgposMin;
			}
		return JET_errSuccess;
		}

	Assert( ppib->procid < 64000 );
	lrcommit0.le_procid = (USHORT) ppib->procid;
	lrcommit0.levelCommitTo = levelCommitTo;

	rgdata[0].SetPv( (BYTE *)&lrcommit0 );

	if ( levelCommitTo == 0 )
		{
		Assert( ppib->trxCommit0 != trxMax );
///		Assert( ppib->trxCommit0 != trxMin );	//	wrap-around can make this true
		lrcommit0.le_trxCommit0 = ppib->trxCommit0;
		lrcommit0.lrtyp = lrtypCommit0;
		rgdata[0].SetCb( sizeof(LRCOMMIT0) );
		}
	else
		{
		lrcommit0.lrtyp = lrtypCommit;
		rgdata[0].SetCb( sizeof(LRCOMMIT) );
		}

	err = plog->ErrLGLogRec( rgdata, 1, fLGNoNewGen, plgposRec );
	Assert( err >= 0 || plog->m_fLGNoMoreLogWrite );

	if ( 0 == levelCommitTo
		&& err >= 0 )
		{
		ppib->ResetFBegin0Logged();
		}

	return err;
	}

ERR ErrLGRollback( PIB *ppib, LEVEL levelsRollback )
	{
	ERR			err;
	DATA		rgdata[1];
	LRROLLBACK	lrrollback;
	INST		* pinst		= PinstFromPpib( ppib );
	LOG			* plog		= pinst->m_plog;
	
	if ( plog->m_fLogDisabled || ( plog->m_fRecovering && plog->m_fRecoveringMode != fRecoveringUndo ) )
		return JET_errSuccess;

	if ( ppib->clevelsDeferBegin > 0 )
		{
		Assert( !plog->m_fRecovering );
		if ( ppib->clevelsDeferBegin >= levelsRollback )
			{
			ppib->clevelsDeferBegin = LEVEL( ppib->clevelsDeferBegin - levelsRollback );
			return JET_errSuccess;
			}
		levelsRollback = LEVEL( levelsRollback - ppib->clevelsDeferBegin );
		ppib->clevelsDeferBegin = 0;
		}

	Assert( levelsRollback > 0 );
	lrrollback.lrtyp = lrtypRollback;
	Assert( ppib->procid < 64000 );
	lrrollback.le_procid = (USHORT) ppib->procid;
	lrrollback.levelRollback = levelsRollback;

	rgdata[0].SetPv( (BYTE *)&lrrollback );
	rgdata[0].SetCb( sizeof(LRROLLBACK) );
	
	err = plog->ErrLGLogRec( rgdata, 1, fLGNoNewGen, pNil );
		
	if ( 0 == ppib->level )
		{
		//	transaction is no longee outstanding,
		//	so MUST reset flag, even on failure
		//	(otherwise subsequent transaction
		//	will still have the flag set)
		ppib->ResetFBegin0Logged();
		}

 	return err;
	}

#ifdef DTC
ERR ErrLGPrepareToCommitTransaction(
	PIB				* const ppib,
	const VOID		* const pvData,
	const ULONG		cbData )
	{
	ERR				err;
	DATA			rgdata[2];
	INST			* const pinst	= PinstFromPpib( ppib );
	LOG				* const plog	= pinst->m_plog;
	LGPOS			lgposRec;
	LRPREPCOMMIT	lrprepcommit;

	if ( plog->m_fLogDisabled || plog->m_fRecovering )
		{
		Assert( !plog->m_fRecovering );		//	shouldn't be called during recovery
		return JET_errSuccess;
		}

	if ( ppib->clevelsDeferBegin > 0 )
		{
		Assert( 1 == ppib->clevelsDeferBegin );
		Assert( !ppib->FBegin0Logged() );
		return JET_errSuccess;
		}

	lrprepcommit.lrtyp = lrtypPrepCommit;

	Assert( ppib->procid < 64000 );
	lrprepcommit.le_procid = (USHORT)ppib->procid;

	lrprepcommit.le_cbData = cbData;

	rgdata[0].SetPv( &lrprepcommit );
	rgdata[0].SetCb( sizeof(lrprepcommit) );

	rgdata[1].SetPv( (VOID *)pvData );
	rgdata[1].SetCb( cbData );

	err = plog->ErrLGLogRec( rgdata, 1, fLGNoNewGen, &lgposRec );
	Assert( err >= 0 || plog->m_fLGNoMoreLogWrite );
	Call( err );

	ppib->lgposCommit0 = lgposRec;
	err = plog->ErrLGWaitCommit0Flush( ppib );
	CallSx( err, JET_errLogWriteFail );
	Assert( JET_errSuccess == err || plog->m_fLGNoMoreLogWrite );
	Call( err );

HandleError:
	return err;
	}

ERR ErrLGPrepareToRollback( PIB * const ppib )
	{
	DATA			rgdata[1];
	LRPREPROLLBACK	lrpreprollback;
	INST		* pinst		= PinstFromPpib( ppib );
	LOG			* plog		= pinst->m_plog;
	
	if ( plog->m_fLogDisabled || ( plog->m_fRecovering && plog->m_fRecoveringMode != fRecoveringUndo ) )
		{
		Assert( fFalse );	// should only be called during RecoveryUndo
		return JET_errSuccess;
		}

	lrpreprollback.lrtyp = lrtypPrepRollback;
	Assert( ppib->procid < 64000 );
	lrpreprollback.le_procid = (USHORT) ppib->procid;

	rgdata[0].SetPv( (BYTE *)&lrpreprollback );
	rgdata[0].SetCb( sizeof(LRPREPROLLBACK) );
	
	return plog->ErrLGLogRec( rgdata, 1, fLGNoNewGen, pNil );
	}
#endif	//	DTC


//**************************************************
//     Database Operations		                    
//**************************************************

INLINE ERR ErrLGWaitForFlush( PIB *ppib, LGPOS *plgposLogRec )
	{
	ERR err;

	INST *pinst = PinstFromPpib( ppib );
	LOG *plog = pinst->m_plog;
	
	if ( plog->m_fLogDisabled || ( plog->m_fRecovering && plog->m_fRecoveringMode != fRecoveringUndo ) )
		return JET_errSuccess;

	ppib->lgposCommit0 = *plgposLogRec;

	plog->LGSignalFlush();
	err = plog->ErrLGWaitCommit0Flush( ppib );

	Assert( err >= 0 || ( plog->m_fLGNoMoreLogWrite && JET_errLogWriteFail == err ) );
	return err;
	}

ERR ErrLGCreateDB(
	PIB				*ppib,
	const IFMP		ifmp,
	const JET_GRBIT	grbit,
	LGPOS			*plgposRec
	)
	{
	ERR				err;
	FMP				*pfmp			= &rgfmp[ifmp];
	Assert( NULL != pfmp->Pdbfilehdr() );
	const BOOL		fCreateSLV		= ( NULL != pfmp->SzSLVName() );
	const USHORT	cbDbName		= USHORT( strlen( pfmp->SzDatabaseName() ) + 1 );
	const USHORT	cbSLVName		= USHORT( fCreateSLV ? strlen( pfmp->SzSLVName() ) + 1 : 0 );
	const ULONG		cbSLVRoot		= ( fCreateSLV ? strlen( pfmp->SzSLVRoot() ) + 1 : 0 );
	DATA			rgdata[4];
	ULONG			cdata			= ( fCreateSLV ? 4 : 2 );
	LRCREATEDB		lrcreatedb;
	INST			*pinst			= PinstFromPpib( ppib );
	LOG				*plog			= pinst->m_plog;

	Assert( 0 == CmpLgpos( lgposMin, pfmp->LgposDetach() ) );
	Assert( !pfmp->FLogOn() || !plog->m_fLogDisabled );
	if ( plog->m_fRecovering || !pfmp->FLogOn() )
		{
		if ( plog->m_fRecovering )
			{
			//	UNDONE: in theory, lgposAttach should already have been set
			//	when the ATCHCHK was setup, but ivantrin says he's not 100%
			//	sure, so to be safe, we definitely set the lgposAttach here
			Assert( 0 == CmpLgpos( pfmp->LgposAttach(), plog->m_lgposRedo ) );
			pfmp->SetLgposAttach( plog->m_lgposRedo );
			}
		*plgposRec = lgposMin;
		return JET_errSuccess;
		}

	Assert( 0 == CmpLgpos( lgposMin, pfmp->LgposAttach() ) );
	//	HACK: use the file-system stored in the INST
	//		  (otherwise, we will need to drill a pfsapi down through to EVERY logged operation that 
	//		   begins a deferred operation and that means ALL the B-Tree code will be touched among
	//		   other things)
	CallR( ErrLGCheckState( plog->m_pinst->m_pfsapi, plog ) );

	//	insert database attachment in log attachments
	//
	lrcreatedb.lrtyp = lrtypCreateDB;
	Assert( ppib->procid < 64000 );
	lrcreatedb.le_procid = (USHORT) ppib->procid;
	FMP::AssertVALIDIFMP( ifmp );
	lrcreatedb.dbid = pfmp->Dbid();

	Assert( !lrcreatedb.FCreateSLV() );
	if ( fCreateSLV )
		lrcreatedb.SetFCreateSLV();

	lrcreatedb.le_grbit = grbit;
	lrcreatedb.signDb = pfmp->Pdbfilehdr()->signDb;
	lrcreatedb.le_cpgDatabaseSizeMax = pfmp->CpgDatabaseSizeMax();

	if ( !pinst->FSLVProviderEnabled() )
		lrcreatedb.SetFSLVProviderNotEnabled();

	Assert( cbDbName > 1 );
	lrcreatedb.SetCbPath( USHORT( cbDbName + ( fCreateSLV ? cbSLVName + cbSLVRoot : 0 ) ) );

	rgdata[0].SetPv( (BYTE *)&lrcreatedb );
	rgdata[0].SetCb( sizeof(LRCREATEDB) );
	rgdata[1].SetPv( (BYTE *)pfmp->SzDatabaseName() );
	rgdata[1].SetCb( cbDbName );
	
	if ( fCreateSLV )
		{
		Assert( cbSLVName > 1 );
		rgdata[2].SetPv( (BYTE *)pfmp->SzSLVName() );
		rgdata[2].SetCb( cbSLVName );
		Assert( cbSLVRoot > 1 );
		rgdata[3].SetPv( (BYTE *)pfmp->SzSLVRoot() );
		rgdata[3].SetCb( cbSLVRoot );
		}

	Assert( pfmp->RwlDetaching().FNotWriter() );
	Assert( pfmp->RwlDetaching().FNotReader() );

#ifdef UNLIMITED_DB
	CallR( plog->ErrLGLogRec( rgdata, cdata, fLGNoNewGen|fLGInterpretLR, pfmp->PlgposAttach() ) );
	*plgposRec = pfmp->LgposAttach();
#else	
	pfmp->RwlDetaching().EnterAsWriter();
	while ( errLGNotSynchronous == ( err = plog->ErrLGTryLogRec( rgdata, cdata, fLGNoNewGen, plgposRec ) ) )
		{
		pfmp->RwlDetaching().LeaveAsWriter();
		UtilSleep( cmsecWaitLogFlush );
		pfmp->RwlDetaching().EnterAsWriter();
		}
	if ( err >= JET_errSuccess )
		{
		pfmp->SetLgposAttach( *plgposRec );
		}
	pfmp->RwlDetaching().LeaveAsWriter();
	CallR( err );
#endif	

	//	make sure the log is flushed before we change the state
	//	We must wait on the last log record added, not necessarily the LGPOS returned from
	//	ErrLGLogRec(), when adding multiple log records in one call.
	LGPOS	lgposStartOfLastRec = *plgposRec;
	plog->AddLgpos( &lgposStartOfLastRec, rgdata[0].Cb() + rgdata[1].Cb() + ( fCreateSLV ? ( rgdata[2].Cb() + rgdata[3].Cb() ) : 0 ) - 1 );
	err = ErrLGWaitForFlush( ppib, &lgposStartOfLastRec );
	return err;
	}

	
ERR ErrLGAttachDB(
	PIB				*ppib,
	const IFMP		ifmp,
	LGPOS			*plgposRec )
	{
	ERR				err;
	FMP				*pfmp			= &rgfmp[ifmp];
	Assert( NULL != pfmp->Pdbfilehdr() );
	const BOOL		fSLVExists		= ( NULL != pfmp->SzSLVName() );
	const ULONG		cbDbName		= (ULONG)strlen( pfmp->SzDatabaseName() ) + 1;
	const ULONG		cbSLVName		= ( fSLVExists ? strlen( pfmp->SzSLVName() ) + 1 : 0 );
	const ULONG		cbSLVRoot		= ( fSLVExists ? strlen( pfmp->SzSLVRoot() ) + 1 : 0 );
	DATA			rgdata[4];
	ULONG			cdata			= ( fSLVExists ? 4 : 2 );
	LRATTACHDB		lrattachdb;
	INST			*pinst			= PinstFromPpib( ppib );
	LOG				*plog			= pinst->m_plog;
	
	Assert( 0 == CmpLgpos( lgposMin, pfmp->LgposDetach() ) );
	Assert( !pfmp->FLogOn() || !plog->m_fLogDisabled );
	Assert( !plog->m_fRecovering );
	if ( ( plog->m_fRecovering && plog->m_fRecoveringMode != fRecoveringUndo )
		|| !pfmp->FLogOn() )
		{
		if ( plog->m_fRecovering )
			{
			//	UNDONE: in theory, lgposAttach should already have been set
			//	when the ATCHCHK was setup, but ivantrin says he's not 100%
			//	sure, so to be safe, we definitely set the lgposAttach here
			Assert( 0 == CmpLgpos( pfmp->LgposAttach(), plog->m_lgposRedo ) );
			pfmp->SetLgposAttach( plog->m_lgposRedo );
			}
		*plgposRec = lgposMin;
		return JET_errSuccess;
		}

	Assert( 0 == CmpLgpos( lgposMin, pfmp->LgposAttach() ) );
	// BUG_125831	
	// we should not start the attachement if we are low on disk space
	CallR( ErrLGCheckState( plog->m_pinst->m_pfsapi, plog ) );
	// BUG_125831	

	//	insert database attachment in log attachments
	//
	lrattachdb.lrtyp = lrtypAttachDB;
	Assert( ppib->procid < 64000 );
	lrattachdb.le_procid = (USHORT) ppib->procid;
	lrattachdb.dbid = pfmp->Dbid();

	Assert( !lrattachdb.FSLVExists() );

	if ( fSLVExists )
		{
		lrattachdb.SetFSLVExists();
		}
	Assert( !rgfmp[ifmp].FReadOnlyAttach() );
	if ( !pinst->FSLVProviderEnabled() )
		{
		lrattachdb.SetFSLVProviderNotEnabled();
		}
		
	lrattachdb.signDb = pfmp->Pdbfilehdr()->signDb;
	lrattachdb.le_cpgDatabaseSizeMax = pfmp->CpgDatabaseSizeMax();
	lrattachdb.signLog = pfmp->Pdbfilehdr()->signLog;
	lrattachdb.lgposConsistent = pfmp->Pdbfilehdr()->le_lgposConsistent;

	Assert( cbDbName > 1 );
	lrattachdb.SetCbPath( USHORT( cbDbName + ( fSLVExists ? cbSLVName + cbSLVRoot : 0 ) ) );

	rgdata[0].SetPv( (BYTE *)&lrattachdb );
	rgdata[0].SetCb( sizeof(LRATTACHDB) );
	rgdata[1].SetPv( (BYTE *)pfmp->SzDatabaseName() );
	rgdata[1].SetCb( cbDbName );
	
	if ( fSLVExists )
		{
		Assert( cbSLVName > 1 );
		rgdata[2].SetPv( (BYTE *)pfmp->SzSLVName() );
		rgdata[2].SetCb( cbSLVName );
		Assert( cbSLVRoot > 1 );
		rgdata[3].SetPv( (BYTE *)pfmp->SzSLVRoot() );
		rgdata[3].SetCb( cbSLVRoot );
		}

	Assert( pfmp->RwlDetaching().FNotWriter() );
	Assert( pfmp->RwlDetaching().FNotReader() );

#ifdef UNLIMITED_DB
	CallR( plog->ErrLGLogRec( rgdata, cdata, fLGNoNewGen|fLGInterpretLR, pfmp->PlgposAttach() ) );
	*plgposRec = pfmp->LgposAttach();
#else
	pfmp->RwlDetaching().EnterAsWriter();
	while ( errLGNotSynchronous == ( err = plog->ErrLGTryLogRec( rgdata, cdata, fLGNoNewGen, plgposRec ) ) )
		{
		pfmp->RwlDetaching().LeaveAsWriter();
		UtilSleep( cmsecWaitLogFlush );
		pfmp->RwlDetaching().EnterAsWriter();
		}
	if ( err >= JET_errSuccess )
		{
		pfmp->SetLgposAttach( *plgposRec );
		}
	pfmp->RwlDetaching().LeaveAsWriter();
	CallR( err );
#endif

	//	make sure the log is flushed before we change the state
	//	We must wait on the last log record added, not necessarily the LGPOS returned from
	//	ErrLGLogRec(), when adding multiple log records in one call.
	LGPOS	lgposStartOfLastRec = *plgposRec;
	plog->AddLgpos( &lgposStartOfLastRec, rgdata[0].Cb() + rgdata[1].Cb() + ( fSLVExists ? rgdata[2].Cb() + rgdata[3].Cb() : 0 ) - 1 );
	err = ErrLGWaitForFlush( ppib, &lgposStartOfLastRec );
	return err;
	}


ERR ErrLGForceDetachDB(
	PIB			*ppib,
	const IFMP	ifmp,
	BYTE		flags,
	LGPOS		*plgposRec )
	{
	ERR			err;
	FMP			*pfmp		= &rgfmp[ifmp];
	const ULONG	cbDbName	= (ULONG)strlen(pfmp->SzDatabaseName() ) + 1;
	DATA		rgdata[2];
	LRFORCEDETACHDB	lrdetachdb;
	INST		*pinst		= PinstFromPpib( ppib );
	LOG			*plog		= pinst->m_plog;
	
	Assert( !pfmp->FLogOn() || !plog->m_fLogDisabled );
	if ( ( plog->m_fRecovering && plog->m_fRecoveringMode != fRecoveringUndo )
		|| !pfmp->FLogOn() )
		{
		if ( plog->m_fRecovering )
			{
			Assert( 0 == CmpLgpos( lgposMin, pfmp->LgposDetach() ) );
			pfmp->SetLgposDetach( pinst->m_plog->m_lgposRedo );
			}
		*plgposRec = lgposMin;
		return JET_errSuccess;
		}

	Assert( 0 != CmpLgpos( lgposMin, pfmp->LgposAttach() ) || NULL == pfmp->Pdbfilehdr() );
	Assert( !pfmp->FReadOnlyAttach() ); 

	//	delete database attachment in log attachments
	//
	lrdetachdb.lrtyp = lrtypForceDetachDB;
	Assert( ppib->procid < 64000 );
	lrdetachdb.le_procid = (USHORT) ppib->procid;
	lrdetachdb.dbid = pfmp->Dbid();
	lrdetachdb.SetCbPath( cbDbName );
	lrdetachdb.le_dbtime = pfmp->DbtimeLast();	
#ifdef IGNORE_BAD_ATTACH
	if ( plog->m_fRecovering ) 
		{
		lrdetachdb.le_rceidMax = ++plog->m_rceidLast;
		}
	else
		{
		lrdetachdb.le_rceidMax = RCE::RceidLastIncrement();
		}
#else // IGNORE_BAD_ATTACH
	lrdetachdb.le_rceidMax = RCE::RceidLastIncrement();
#endif // IGNORE_BAD_ATTACH
	lrdetachdb.m_fFlags = 0;
	lrdetachdb.SetFlags( flags );

	rgdata[0].SetPv( (BYTE *)&lrdetachdb );
	rgdata[0].SetCb( sizeof(LRFORCEDETACHDB) );
	rgdata[1].SetPv( (BYTE *)pfmp->SzDatabaseName() );
	rgdata[1].SetCb( cbDbName );

	Assert( pfmp->RwlDetaching().FNotWriter() );
	Assert( pfmp->RwlDetaching().FNotReader() );

	// disable logging twice detach/force detach record
	if ( 0 != CmpLgpos( lgposMin, pfmp->LgposDetach() ) )
		{
		*plgposRec = pfmp->LgposDetach();
		}
	else
		{
#ifdef UNLIMITED_DB
		CallR( plog->ErrLGLogRec( rgdata, 2, fLGNoNewGen|fLGInterpretLR, pfmp->PlgposDetach() ) );
		*plgposRec = pfmp->LgposDetach();
#else
		pfmp->RwlDetaching().EnterAsWriter();
		while ( errLGNotSynchronous == ( err = plog->ErrLGTryLogRec( rgdata, 2, fLGNoNewGen, plgposRec ) ) )
			{
			pfmp->RwlDetaching().LeaveAsWriter();
			UtilSleep( cmsecWaitLogFlush );
			pfmp->RwlDetaching().EnterAsWriter();
			}
		if ( err >= JET_errSuccess )
			{
			Assert( 0 != CmpLgpos( lgposMin, pfmp->LgposAttach() ) );
			Assert( 0 == CmpLgpos( lgposMin, pfmp->LgposDetach() ) );
			pfmp->SetLgposDetach( *plgposRec );
			}
		pfmp->RwlDetaching().LeaveAsWriter();
		CallR( err );
#endif		
		}

	//	make sure the log is flushed before we change the state
	//	We must wait on the last log record added, not necessarily the LGPOS returned from
	//	ErrLGLogRec(), when adding multiple log records in one call.
	LGPOS	lgposStartOfLastRec = *plgposRec;
	plog->AddLgpos( &lgposStartOfLastRec, rgdata[0].Cb() + rgdata[1].Cb() - 1 );
	err = ErrLGWaitForFlush( ppib, &lgposStartOfLastRec );
	return err;
	}



ERR ErrLGDetachDB(
	PIB			*ppib,
	const IFMP	ifmp,
	BYTE 		flags,
	LGPOS		*plgposRec )
	{
	ERR			err;
	FMP			*pfmp		= &rgfmp[ifmp];
	INST		*pinst		= PinstFromPpib( ppib );
	LOG			*plog		= pinst->m_plog;

	char * 		szDatabaseName = pfmp->SzDatabaseName();
	Assert ( szDatabaseName );
			
	if ( plog->m_fRecovering )
		{
		INT irstmap = plog->IrstmapSearchNewName( szDatabaseName );

		if ( 0 <= irstmap )
			{
			szDatabaseName = pinst->m_plog->m_rgrstmap[irstmap].szDatabaseName;
			}
		}
	Assert ( szDatabaseName );

	const ULONG	cbDbName	= (ULONG)strlen( szDatabaseName ) + 1;
	DATA		rgdata[2];
	LRDETACHDB	lrdetachdb;
	
	Assert( !pfmp->FLogOn() || !plog->m_fLogDisabled );
	if ( ( plog->m_fRecovering && plog->m_fRecoveringMode != fRecoveringUndo )
		|| !pfmp->FLogOn() )
		{
		if ( plog->m_fRecovering )
			{
			Assert( 0 == CmpLgpos( lgposMin, pfmp->LgposDetach() ) );
			pfmp->SetLgposDetach( plog->m_lgposRedo );
			}
		*plgposRec = lgposMin;
		return JET_errSuccess;
		}

	Assert( !pfmp->FReadOnlyAttach() );
	Assert( 0 != CmpLgpos( lgposMin, pfmp->LgposAttach() ) || NULL == pfmp->Pdbfilehdr() );

	//	delete database attachment in log attachments
	//
	lrdetachdb.lrtyp = lrtypDetachDB;
	Assert( ppib->procid < 64000 );
	lrdetachdb.le_procid = (USHORT) ppib->procid;
	lrdetachdb.dbid = pfmp->Dbid();
	lrdetachdb.SetCbPath( cbDbName );
	if ( flags & fLRForceDetachCreateSLV )
		{
		lrdetachdb.SetFCreateSLV();
		}

	rgdata[0].SetPv( (BYTE *)&lrdetachdb );
	rgdata[0].SetCb( sizeof(LRDETACHDB) );
	rgdata[1].SetPv( (BYTE *)szDatabaseName );
	rgdata[1].SetCb( cbDbName );
	
	Assert( pfmp->RwlDetaching().FNotWriter() );
	Assert( pfmp->RwlDetaching().FNotReader() );

	// disable logging twice detach/force detach record
	if ( 0 != CmpLgpos( lgposMin, pfmp->LgposDetach() ) )
		{
		*plgposRec = pfmp->LgposDetach();
		}
	else
		{
#ifdef UNLIMITED_DB
		CallR( plog->ErrLGLogRec( rgdata, 2, fLGNoNewGen|fLGInterpretLR, pfmp->PlgposDetach() ) );
		*plgposRec = pfmp->LgposDetach();
#else
		pfmp->RwlDetaching().EnterAsWriter();
		while ( errLGNotSynchronous == ( err = plog->ErrLGTryLogRec( rgdata, 2, fLGNoNewGen, plgposRec ) ) )
			{
			pfmp->RwlDetaching().LeaveAsWriter();
			UtilSleep( cmsecWaitLogFlush );
			pfmp->RwlDetaching().EnterAsWriter();
			}
		if ( err >= JET_errSuccess )
			{
			Assert( 0 != CmpLgpos( lgposMin, pfmp->LgposAttach() ) );
			Assert( 0 == CmpLgpos( lgposMin, pfmp->LgposDetach() ) );
			pfmp->SetLgposDetach( *plgposRec );
			}
		pfmp->RwlDetaching().LeaveAsWriter();
		CallR( err );
#endif		
		}

	//	make sure the log is flushed before we change the state
	//	We must wait on the last log record added, not necessarily the LGPOS returned from
	//	ErrLGLogRec(), when adding multiple log records in one call.
	LGPOS	lgposStartOfLastRec = *plgposRec;
	plog->AddLgpos( &lgposStartOfLastRec, rgdata[0].Cb() + rgdata[1].Cb() - 1 );
	err = ErrLGWaitForFlush( ppib, &lgposStartOfLastRec );
	return err;
	}



//********************************************************
//****     Split Operations			                  ****
//********************************************************

//	logs the following
//		-- 	begin macro
//			for every split in the split chain [top-down order]
//				log LRSPLIT
//			leaf-level node operation to be performed atomically with split
//			end macro
//	returns lgpos of last log operation
//
ERR ErrLGSplit( const FUCB			* const pfucb,
				SPLITPATH		* const psplitPathLeaf,
				const KEYDATAFLAGS&	kdfOper,
				const RCEID			rceid1,
				const RCEID			rceid2,
				const DIRFLAG		dirflag,
				LGPOS				* const plgpos,
				const VERPROXY		* const pverproxy )
	{
	ERR			err = JET_errSuccess;

	INST *pinst = PinstFromIfmp( pfucb->ifmp );
	LOG *plog = pinst->m_plog;
	
	Assert( !plog->m_fRecovering );
	if ( plog->m_fLogDisabled )
		{
		*plgpos = lgposMin;
		return JET_errSuccess;
		}

	Assert( rgfmp[pfucb->ifmp].FLogOn() );
	Assert( NULL == pverproxy ||
			prceNil != pverproxy->prcePrimary &&
			( pverproxy->prcePrimary->TrxCommitted() != trxMax ||
			  pfucbNil != pverproxy->prcePrimary->Pfucb() &&
			  ppibNil != pverproxy->prcePrimary->Pfucb()->ppib ) );
			  
	PIB	* const ppib = pverproxy != NULL && 
					trxMax == pverproxy->prcePrimary->TrxCommitted() ?
						pverproxy->prcePrimary->Pfucb()->ppib :
						pfucb->ppib;
			  
	Assert( rgfmp[pfucb->ifmp].Dbid() != dbidTemp );
	Assert( ppib->level > 0 );

	//	Redo only operation
	
	CallR( ErrLGDeferBeginTransaction( ppib ) );

	DBTIME	dbtime = psplitPathLeaf->csr.Dbtime();
	CallR( ErrLGIMacroBegin( ppib, dbtime ) );

	//	log splits top-down
	//
	const SPLITPATH	*psplitPath = psplitPathLeaf;
	for ( ; psplitPath->psplitPathParent != NULL; psplitPath = psplitPath->psplitPathParent )
		{
		}

	for ( ; psplitPath != NULL; psplitPath = psplitPath->psplitPathChild )
		{
		DATA		rgdata[5];
		USHORT		idata = 0;
		LRSPLIT		lrsplit;

		lrsplit.lrtyp 					= lrtypSplit;

		//	dbtime should have been validated in ErrBTISplitUpgradeLatches()
		Assert( dbtime > psplitPath->dbtimeBefore );
		
		lrsplit.le_dbtime 				= dbtime;
		Assert ( dbtimeNil != psplitPath->dbtimeBefore);
		lrsplit.le_dbtimeBefore 		= psplitPath->dbtimeBefore;
		Assert( dbtime == psplitPath->csr.Dbtime() );
		Assert( psplitPath->csr.FDirty() );
		
		lrsplit.dbid					= (BYTE) rgfmp[pfucb->ifmp].Dbid();
		lrsplit.le_procid				= ppib->procid;
		
		lrsplit.le_pgno	 			= psplitPath->csr.Pgno();
		lrsplit.le_pgnoParent 		= psplitPath->psplitPathParent != NULL ? psplitPath->psplitPathParent->csr.Pgno() : pgnoNull;
		lrsplit.le_dbtimeParentBefore      = psplitPath->psplitPathParent != NULL ? psplitPath->psplitPathParent->dbtimeBefore : dbtimeNil;
		lrsplit.le_pgnoFDP			= PgnoFDP( pfucb );
		lrsplit.le_objidFDP			= ObjidFDP( pfucb );

		lrsplit.SetILine( 0 );				//	iline member of LRPAGE is unused by split -- see iline members of LRSPLIT instead

		Assert( !lrsplit.FVersioned() );	//	version flag will get properly set by node operation causing the split
		Assert( !lrsplit.FDeleted() );
		Assert( !lrsplit.FUnique() );
		Assert( !lrsplit.FSpace() );
		Assert( !lrsplit.FConcCI() );

		if ( pfucb->u.pfcb->FUnique() )
			lrsplit.SetFUnique();
		if ( NULL != pverproxy )
			lrsplit.SetFConcCI();

		LGISetTrx( ppib, &lrsplit, pverproxy );
		
		rgdata[idata].SetPv( (BYTE *) &lrsplit );
		rgdata[idata++].SetCb( sizeof (LRSPLIT) );

		if ( psplitPath->psplit == NULL )
			{
			//	UNDONE:	spin off separate log operation for parent page
			//
			lrsplit.le_pgnoNew		= pgnoNull;
			lrsplit.le_ilineOper	= USHORT( psplitPath->csr.ILine() );

			lrsplit.le_cbKeyParent		= 0;
			lrsplit.le_cbPrefixSplitOld	= 0;
			lrsplit.le_cbPrefixSplitNew	= 0;
			lrsplit.le_dbtimeRightBefore       = dbtimeNil;
			}
		else
			{
			const SPLIT	*psplit = psplitPath->psplit;
			Assert( psplit->csrNew.Dbtime() == lrsplit.le_dbtime );
			Assert( psplit->csrNew.FDirty() );

		//	dbtime should have been validated in ErrBTISplitUpgradeLatches()
			Assert( pgnoNull == psplit->csrRight.Pgno()
				|| dbtime > psplit->dbtimeRightBefore );

			lrsplit.le_dbtimeRightBefore	= psplit->dbtimeRightBefore;
			
			lrsplit.le_pgnoNew 			= psplit->csrNew.Pgno();
			lrsplit.le_pgnoRight	 	= psplit->csrRight.Pgno();
			Assert( lrsplit.le_pgnoNew != pgnoNull );
	
			lrsplit.splittype 			= BYTE( psplit->splittype );
			lrsplit.splitoper 			= BYTE( psplit->splitoper );

			lrsplit.le_ilineOper		= USHORT( psplit->ilineOper );
			lrsplit.le_ilineSplit		= USHORT( psplit->ilineSplit );
			lrsplit.le_clines			= USHORT( psplit->clines );
			Assert( lrsplit.le_clines < g_cbPage );

			lrsplit.le_fNewPageFlags 	= psplit->fNewPageFlags;
			lrsplit.le_fSplitPageFlags	= psplit->fSplitPageFlags;

			lrsplit.le_cbUncFreeSrc		= psplit->cbUncFreeSrc;
			lrsplit.le_cbUncFreeDest	= psplit->cbUncFreeDest;
			
			lrsplit.le_ilinePrefixSplit	= psplit->prefixinfoSplit.ilinePrefix;
			lrsplit.le_ilinePrefixNew	= psplit->prefixinfoNew.ilinePrefix;
			
			lrsplit.le_cbKeyParent		= (USHORT) psplit->kdfParent.key.Cb();
			rgdata[idata].SetPv( psplit->kdfParent.key.prefix.Pv() );
			rgdata[idata++].SetCb( psplit->kdfParent.key.prefix.Cb() );
			
			rgdata[idata].SetPv( psplit->kdfParent.key.suffix.Pv() );
			rgdata[idata++].SetCb( psplit->kdfParent.key.suffix.Cb() );

			lrsplit.le_cbPrefixSplitOld	= USHORT( psplit->prefixSplitOld.Cb() );
			rgdata[idata].SetPv( psplit->prefixSplitOld.Pv() );
			rgdata[idata++].SetCb( lrsplit.le_cbPrefixSplitOld );

			lrsplit.le_cbPrefixSplitNew	= USHORT( psplit->prefixSplitNew.Cb() );
			rgdata[idata].SetPv( psplit->prefixSplitNew.Pv() );
			rgdata[idata++].SetCb( lrsplit.le_cbPrefixSplitNew );
			}

		Call( plog->ErrLGLogRec( rgdata, idata, fLGNoNewGen, plgpos ) );
		}
		
	//	log leaf-level operation
	//
	if ( psplitPathLeaf->psplit != NULL &&
		 psplitPathLeaf->psplit->splitoper != splitoperNone )
		{
		const SPLIT	*psplit = psplitPathLeaf->psplit;
		Assert( psplitPathLeaf->csr.Cpage().FLeafPage() );
		
		switch ( psplit->splitoper )
			{
			//	log the appropriate operation
			//
			case splitoperInsert:
				Assert( rceidNull == rceid2 );
				Call( ErrLGInsert( pfucb, 
								   &psplitPathLeaf->csr, 
								   kdfOper,
								   rceid1,
								   dirflag, 
								   plgpos, 
								   pverproxy,
								   fDontDirtyCSR ) );
				break;

			case splitoperFlagInsertAndReplaceData:
				Call( ErrLGFlagInsertAndReplaceData( pfucb,
													 &psplitPathLeaf->csr,
													 kdfOper,
													 rceid1,
													 rceid2,
													 dirflag,
													 plgpos,
													 pverproxy,
													 fDontDirtyCSR ) );
				break;

			//	UNDONE:	get the correct dataOld!!!
			//
			case splitoperReplace:
				Assert( rceidNull == rceid2 );
				Assert( NULL == pverproxy );
				Call( ErrLGReplace( pfucb, 
									&psplitPathLeaf->csr,
									psplit->rglineinfo[psplit->ilineOper].kdf.data,
									kdfOper.data,
									NULL,			// UNDONE: logdiff for split
									rceid1,
									dirflag,
									plgpos,
									fDontDirtyCSR ) );
				break;

			default:
				Assert( fFalse );
			}
		}
	
	Call( ErrLGIMacroEnd( ppib, dbtime, lrtypMacroCommit, plgpos ) );

HandleError:
	return err;
	}


//	logs the following
//		-- 	begin macro
//			for every split in the split chain
//				log LRSPLIT
//			end macro
//	returns lgpos of last log operation
//
ERR ErrLGMerge( const FUCB *pfucb, MERGEPATH *pmergePathLeaf, LGPOS *plgpos )
	{
	ERR		err = JET_errSuccess;

	INST *pinst = PinstFromIfmp( pfucb->ifmp );
	LOG *plog = pinst->m_plog;
	
	Assert( !plog->m_fRecovering );
	Assert( !rgfmp[pfucb->ifmp].FLogOn() || !plog->m_fLogDisabled );

	if ( !rgfmp[pfucb->ifmp].FLogOn() )
		{
		*plgpos = lgposMin;
		return JET_errSuccess;
		}

	//	merge always happens at level 1
	Assert( pfucb->ppib->level == 1 );
	Assert( dbidTemp != rgfmp[pfucb->ifmp].Dbid() );

	//	Redo only operations
	
	CallR( ErrLGDeferBeginTransaction( pfucb->ppib ) );

	MERGEPATH		*pmergePath = pmergePathLeaf;
	const DBTIME	dbtime = pmergePath->csr.Dbtime();
	
	CallR( ErrLGIMacroBegin( pfucb->ppib, dbtime ) );

	Assert( pmergePathLeaf->pmerge != NULL );
	
	for ( ; pmergePath->pmergePathParent != NULL && latchWrite == pmergePath->pmergePathParent->csr.Latch();
			pmergePath = pmergePath->pmergePathParent )
		{
		}
			
	for ( ; pmergePath != NULL; pmergePath = pmergePath->pmergePathChild )
		{
		Assert( latchWrite == pmergePath->csr.Latch() );

		const MERGE	*pmerge = pmergePath->pmerge;
		DATA		rgdata[2];
		USHORT		idata = 0;
		LRMERGE		lrmerge;

		lrmerge.lrtyp 			= lrtypMerge;
		lrmerge.le_dbtime 		= dbtime;
		lrmerge.le_dbtimeBefore = pmergePath->dbtimeBefore;
		Assert( pmergePath->csr.FDirty() );
		
		lrmerge.le_procid		= pfucb->ppib->procid;
		lrmerge.dbid			= (BYTE) rgfmp[ pfucb->ifmp ].Dbid();

		lrmerge.le_pgno	 		= pmergePath->csr.Pgno();
		lrmerge.SetILine( pmergePath->iLine );

		Assert( !lrmerge.FVersioned() );
		Assert( !lrmerge.FDeleted() );
		Assert( !lrmerge.FUnique() );
		Assert( !lrmerge.FSpace() );
		Assert( !lrmerge.FConcCI() );
		Assert( !lrmerge.FKeyChange() );
		Assert( !lrmerge.FDeleteNode() );
		Assert( !lrmerge.FEmptyPage() );

		if ( pfucb->u.pfcb->FUnique() )
			lrmerge.SetFUnique();
		if ( FFUCBSpace( pfucb ) )
			lrmerge.SetFSpace();
		if ( pmergePath->fKeyChange )
			lrmerge.SetFKeyChange();
		if ( pmergePath->fDeleteNode )
			lrmerge.SetFDeleteNode();
		if ( pmergePath->fEmptyPage )
			lrmerge.SetFEmptyPage();

		LGISetTrx( pfucb->ppib, &lrmerge );
		
		lrmerge.le_pgnoParent 	= pmergePath->pmergePathParent != NULL ? pmergePath->pmergePathParent->csr.Pgno() : pgnoNull;
		lrmerge.le_dbtimeParentBefore = pmergePath->pmergePathParent != NULL ? pmergePath->pmergePathParent->dbtimeBefore : dbtimeNil;
		
		lrmerge.le_pgnoFDP		= PgnoFDP( pfucb );
		lrmerge.le_objidFDP		= ObjidFDP( pfucb );

		rgdata[idata].SetPv( (BYTE *) &lrmerge );
		rgdata[idata++].SetCb( sizeof (LRMERGE) );

		if ( pmerge != NULL )
			{
			Assert( pgnoNull == pmerge->csrLeft.Pgno() || 
					pmerge->csrLeft.FDirty() );
			Assert( pgnoNull == pmerge->csrRight.Pgno() || 
					pmerge->csrRight.FDirty() );
			Assert( 0 == pmerge->ilineMerge || 
					mergetypePartialRight == pmerge->mergetype );

			lrmerge.SetILineMerge( USHORT( pmerge->ilineMerge ) );
			
			lrmerge.le_pgnoLeft 	= pmerge->csrLeft.Pgno();
			lrmerge.le_pgnoRight 	= pmerge->csrRight.Pgno();

			lrmerge.le_dbtimeRightBefore = pmerge->dbtimeRightBefore;
			lrmerge.le_dbtimeLeftBefore = pmerge->dbtimeLeftBefore;

			Assert( mergetypeNone != pmerge->mergetype );
			lrmerge.mergetype 			= BYTE( pmerge->mergetype );
			lrmerge.le_cbSizeTotal		= USHORT( pmerge->cbSizeTotal );
			lrmerge.le_cbSizeMaxTotal	= USHORT( pmerge->cbSizeMaxTotal );
			lrmerge.le_cbUncFreeDest	= USHORT( pmerge->cbUncFreeDest );

			lrmerge.le_cbKeyParentSep	= (USHORT) pmerge->kdfParentSep.key.suffix.Cb();
			Assert( pmerge->kdfParentSep.key.prefix.FNull() );
			
			rgdata[idata].SetPv( pmerge->kdfParentSep.key.suffix.Pv() );
			rgdata[idata++].SetCb( pmerge->kdfParentSep.key.suffix.Cb() );
			}
		else
			{
			lrmerge.le_dbtimeRightBefore = dbtimeNil;
			lrmerge.le_dbtimeLeftBefore = dbtimeNil;
			}

		Call( plog->ErrLGLogRec( rgdata, idata, fLGNoNewGen, plgpos ) );
		}
		
	Call( ErrLGIMacroEnd( pfucb->ppib, dbtime, lrtypMacroCommit, plgpos ) );

HandleError:
	return err;
	}


ERR ErrLGEmptyTree(
	FUCB			* const pfucb,
	CSR				* const pcsrRoot,
	EMPTYPAGE		* const rgemptypage,
	const CPG		cpgToFree,
	LGPOS			* const plgpos )
	{
	ERR				err;
	INST 			* const pinst	= PinstFromIfmp( pfucb->ifmp );
	LOG				* const plog	= pinst->m_plog;
	DATA			rgdata[2];
	LREMPTYTREE		lremptytree;

	Assert( !pinst->FRecovering() );
	Assert( pcsrRoot->Pgno() == PgnoRoot( pfucb ) );

	if ( plog->m_fLogDisabled
		|| !rgfmp[pfucb->ifmp].FLogOn() )
		{
		pcsrRoot->Dirty();
		*plgpos = lgposMin;
		return JET_errSuccess;
		}

	Assert( pfucb->ppib->level > 0 );
	CallR( ErrLGDeferBeginTransaction( pfucb->ppib ) );

	lremptytree.lrtyp 				= lrtypEmptyTree;
	lremptytree.le_procid 			= pfucb->ppib->procid;
	lremptytree.dbid 				= rgfmp[ pfucb->ifmp ].Dbid();
	lremptytree.le_pgno				= pcsrRoot->Pgno();
	lremptytree.SetILine( 0 );

	Assert( !lremptytree.FVersioned() );
	Assert( !lremptytree.FDeleted() );
	Assert( !lremptytree.FUnique() );
	Assert( !lremptytree.FSpace() );
	Assert( !lremptytree.FConcCI() );
	if ( pfucb->u.pfcb->FUnique() )
		lremptytree.SetFUnique();
	if ( FFUCBSpace( pfucb ) )
		lremptytree.SetFSpace();

	CallR( ErrLGSetDbtimeBeforeAndDirty( pcsrRoot, &lremptytree.le_dbtimeBefore, &lremptytree.le_dbtime, fTrue ) );
	LGISetTrx( pfucb->ppib, &lremptytree );

	Assert( cpgToFree > 0 );
	Assert( cpgToFree <= cBTMaxDepth );
	const USHORT	cbEmptyPageList		= USHORT( sizeof(EMPTYPAGE) * cpgToFree );

	lremptytree.le_rceid = rceidNull;
	lremptytree.le_pgnoFDP = PgnoFDP( pfucb );
	lremptytree.le_objidFDP = ObjidFDP( pfucb );

	lremptytree.SetCbEmptyPageList( cbEmptyPageList );

	rgdata[0].SetPv( (BYTE *)&lremptytree );
	rgdata[0].SetCb( sizeof(lremptytree) );

	rgdata[1].SetPv( (BYTE *)rgemptypage );
	rgdata[1].SetCb( cbEmptyPageList );
	
	err = plog->ErrLGLogRec( rgdata, 2, fLGNoNewGen, plgpos );

	//	on logging failure, must revert dbtime to ensure page doesn't
	//	get erroneously flushed with wrong dbtime
	if ( err < 0 )
		{
		Assert( dbtimeInvalid !=  lremptytree.le_dbtimeBefore );
		Assert( dbtimeNil != lremptytree.le_dbtimeBefore );
		Assert( pcsrRoot->Dbtime() > lremptytree.le_dbtimeBefore );
		pcsrRoot->RevertDbtime( lremptytree.le_dbtimeBefore );
		}

	return err;
	}


		//**************************************************
		//     Miscellaneous Operations
		//**************************************************


ERR ErrLGCreateMultipleExtentFDP( 
	const FUCB			*pfucb,
	const CSR 			*pcsr,
	const SPACE_HEADER	*psph,
	const ULONG			fPageFlags,
	LGPOS	  			*plgpos )
	{
	ERR					err;
	DATA				rgdata[1];
	LRCREATEMEFDP		lrcreatemefdp;

	INST *pinst = PinstFromIfmp( pfucb->ifmp );
	LOG *plog = pinst->m_plog;
	
	Assert( pcsr->FDirty() );
	Assert( !rgfmp[pfucb->ifmp].FLogOn() || !plog->m_fLogDisabled );

	if ( !rgfmp[pfucb->ifmp].FLogOn() )
		{
		*plgpos = lgposMin;
		return JET_errSuccess;
		}

	Assert( !plog->m_fRecovering );
	Assert( 0 < pfucb->ppib->level );

	//	HACK: use the file-system stored in the INST
	//		  (otherwise, we will need to drill a pfsapi down through to EVERY logged operation that 
	//		   begins a deferred operation and that means ALL the B-Tree code will be touched among
	//		   other things)
	CallR( ErrLGCheckState( plog->m_pinst->m_pfsapi, plog ) );

	//	Redo only operation
	
	CallR( ErrLGDeferBeginTransaction( pfucb->ppib ) );

	Assert( psph->FMultipleExtent() );

	lrcreatemefdp.lrtyp 			= lrtypCreateMultipleExtentFDP;
	lrcreatemefdp.le_procid 			= pfucb->ppib->procid;
	lrcreatemefdp.le_pgno				= PgnoFDP( pfucb );
	lrcreatemefdp.le_objidFDP			= ObjidFDP( pfucb );
	lrcreatemefdp.le_pgnoFDPParent 	= psph->PgnoParent();
	lrcreatemefdp.le_pgnoOE			= PgnoOE( pfucb );
	lrcreatemefdp.le_pgnoAE			= PgnoAE( pfucb );
	lrcreatemefdp.le_fPageFlags		= fPageFlags;
	
	lrcreatemefdp.dbid 				= rgfmp[ pfucb->ifmp ].Dbid();
	lrcreatemefdp.le_dbtime			= pcsr->Dbtime();
	// new page, dbtimeBefore has no meaning
	lrcreatemefdp.le_dbtimeBefore = dbtimeNil;
	lrcreatemefdp.le_cpgPrimary		= psph->CpgPrimary();

	Assert( !lrcreatemefdp.FVersioned() );
	Assert( !lrcreatemefdp.FDeleted() );
	Assert( !lrcreatemefdp.FUnique() );
	Assert( !lrcreatemefdp.FSpace() );
	Assert( !lrcreatemefdp.FConcCI() );

	if ( psph->FUnique() )
		lrcreatemefdp.SetFUnique();

	LGISetTrx( pfucb->ppib, &lrcreatemefdp );
	
	rgdata[0].SetPv( (BYTE *)&lrcreatemefdp );
	rgdata[0].SetCb( sizeof(lrcreatemefdp) );
	
	err = plog->ErrLGLogRec( rgdata, 1, fLGNoNewGen, plgpos );

	return err;
	}


ERR ErrLGCreateSingleExtentFDP( 
	const FUCB			*pfucb,
	const CSR 			*pcsr,
	const SPACE_HEADER	*psph,
	const ULONG			fPageFlags,
	LGPOS	  			*plgpos )
	{
	ERR					err;
	DATA				rgdata[1];
	LRCREATESEFDP		lrcreatesefdp;

	INST *pinst = PinstFromIfmp( pfucb->ifmp );
	LOG *plog = pinst->m_plog;
	
	Assert( !plog->m_fRecovering );
	Assert( pcsr->FDirty() );
	Assert( !rgfmp[pfucb->ifmp].FLogOn() || !plog->m_fLogDisabled );
	if ( !rgfmp[pfucb->ifmp].FLogOn() )
		{
		*plgpos = lgposMin;
		return JET_errSuccess;
		}

	Assert( 0 < pfucb->ppib->level );

	//	HACK: use the file-system stored in the INST
	//		  (otherwise, we will need to drill a pfsapi down through to EVERY logged operation that 
	//		   begins a deferred operation and that means ALL the B-Tree code will be touched among
	//		   other things)
	CallR( ErrLGCheckState( plog->m_pinst->m_pfsapi, plog ) );

	//	Redo only operation
	
	CallR( ErrLGDeferBeginTransaction( pfucb->ppib ) );

	Assert( psph->FSingleExtent() );

	lrcreatesefdp.lrtyp 			= lrtypCreateSingleExtentFDP;
	lrcreatesefdp.le_procid 			= pfucb->ppib->procid;
	lrcreatesefdp.le_pgnoFDPParent 	= psph->PgnoParent();

	Assert( pcsr->Pgno() == PgnoFDP( pfucb ) );
	lrcreatesefdp.le_pgno				= pcsr->Pgno();
	lrcreatesefdp.le_objidFDP			= ObjidFDP( pfucb );
	lrcreatesefdp.le_fPageFlags		= fPageFlags;
	
	lrcreatesefdp.dbid 				= rgfmp[ pfucb->ifmp ].Dbid();
	lrcreatesefdp.le_dbtime			= pcsr->Dbtime();
	// new page, dbtimeBefore has no meaning
	lrcreatesefdp.le_dbtimeBefore = dbtimeNil;
	lrcreatesefdp.le_cpgPrimary		= psph->CpgPrimary();

	Assert( !lrcreatesefdp.FVersioned() );
	Assert( !lrcreatesefdp.FDeleted() );
	Assert( !lrcreatesefdp.FUnique() );
	Assert( !lrcreatesefdp.FSpace() );
	Assert( !lrcreatesefdp.FConcCI() );

	if ( psph->FUnique() )
		lrcreatesefdp.SetFUnique();

	LGISetTrx( pfucb->ppib, &lrcreatesefdp );
	
	rgdata[0].SetPv( (BYTE *)&lrcreatesefdp );
	rgdata[0].SetCb( sizeof(lrcreatesefdp) );
	
	err = plog->ErrLGLogRec( rgdata, 1, fLGNoNewGen, plgpos );

	return err;
	}


ERR ErrLGConvertFDP( 
	const FUCB			*pfucb,
	const CSR 			*pcsr,
	const SPACE_HEADER	*psph,
	const PGNO			pgnoSecondaryFirst,
	const CPG			cpgSecondary,
	const DBTIME 		dbtimeBefore,
	LGPOS	  			*plgpos )
	{
	ERR					err;
	DATA				rgdata[1];
	LRCONVERTFDP		lrconvertfdp;

	INST *pinst = PinstFromIfmp( pfucb->ifmp );
	LOG *plog = pinst->m_plog;
	
	Assert( !plog->m_fRecovering );
	Assert( pcsr->FDirty() );
	Assert( !FFUCBSpace( pfucb ) );
	Assert( !rgfmp[pfucb->ifmp].FLogOn() || !plog->m_fLogDisabled );
	if ( !rgfmp[pfucb->ifmp].FLogOn() )
		{
		*plgpos = lgposMin;
		return JET_errSuccess;
		}

	Assert( 0 < pfucb->ppib->level );

	//	HACK: use the file-system stored in the INST
	//		  (otherwise, we will need to drill a pfsapi down through to EVERY logged operation that 
	//		   begins a deferred operation and that means ALL the B-Tree code will be touched among
	//		   other things)
	CallR( ErrLGCheckState( plog->m_pinst->m_pfsapi, plog ) );

	//	Redo only operation
	
	CallR( ErrLGDeferBeginTransaction( pfucb->ppib ) );

	lrconvertfdp.lrtyp 			= lrtypConvertFDP;
	lrconvertfdp.le_procid 	  	= pfucb->ppib->procid;
	lrconvertfdp.le_pgnoFDPParent 	= psph->PgnoParent();
	lrconvertfdp.le_pgno			= PgnoFDP( pfucb );
	lrconvertfdp.le_objidFDP		= ObjidFDP( pfucb );
	lrconvertfdp.le_pgnoOE			= PgnoOE( pfucb );
	lrconvertfdp.le_pgnoAE			= PgnoAE( pfucb );
	
	lrconvertfdp.dbid 			  	= rgfmp[ pfucb->ifmp ].Dbid();
	lrconvertfdp.le_dbtime			= pcsr->Dbtime();
	lrconvertfdp.le_dbtimeBefore 	= dbtimeBefore;
	lrconvertfdp.le_cpgPrimary		= psph->CpgPrimary();
	lrconvertfdp.le_cpgSecondary	= cpgSecondary;
	lrconvertfdp.le_pgnoSecondaryFirst = pgnoSecondaryFirst;

	Assert( !lrconvertfdp.FVersioned() );
	Assert( !lrconvertfdp.FDeleted() );
	Assert( !lrconvertfdp.FUnique() );
	Assert( !lrconvertfdp.FSpace() );
	Assert( !lrconvertfdp.FConcCI() );

	if ( psph->FUnique() )
		lrconvertfdp.SetFUnique();

	LGISetTrx( pfucb->ppib, &lrconvertfdp );
	
	rgdata[0].SetPv( (BYTE *)&lrconvertfdp );
	rgdata[0].SetCb( sizeof(lrconvertfdp) );
	
	err = plog->ErrLGLogRec( rgdata, 1, fLGNoNewGen, plgpos );

	return err;
	}


ERR ErrLGStart( INST *pinst )
	{
	ERR		err;
	DATA	rgdata[1];
	LRINIT2	lr;
	LOG		*plog = pinst->m_plog;

	if ( plog->m_fLogDisabled || ( plog->m_fRecovering && plog->m_fRecoveringMode != fRecoveringUndo ) )
		return JET_errSuccess;

	// BUG_125831	
	// we should not start if we are low on disk space
	CallR( ErrLGCheckState( plog->m_pinst->m_pfsapi, plog ) );
	// BUG_125831	

	lr.lrtyp = lrtypInit2;
	LGIGetDateTime( &lr.logtime );
	pinst->SaveDBMSParams( &lr.dbms_param );

	rgdata[0].SetPv( (BYTE *)&lr );
	rgdata[0].SetCb( sizeof(lr) );

	err = plog->ErrLGLogRec( rgdata, 1, fLGNoNewGen, pNil );

	plog->m_lgposStart = plog->m_lgposLogRec;
	
	return err;
	}
	

ERR ErrLGIMacroBegin( PIB *ppib, DBTIME dbtime )
	{
	ERR				err;
	DATA			rgdata[1];
	LRMACROBEGIN	lrMacroBegin;

	INST *pinst = PinstFromPpib( ppib );
	LOG *plog = pinst->m_plog;
	
	Assert( !plog->m_fRecovering );
	
	if ( plog->m_fLogDisabled )
		return JET_errSuccess;

	lrMacroBegin.lrtyp 	= lrtypMacroBegin;
	lrMacroBegin.le_procid = ppib->procid;
	lrMacroBegin.le_dbtime = dbtime;

	rgdata[0].SetPv( (BYTE *)&lrMacroBegin );
	rgdata[0].SetCb( sizeof(lrMacroBegin) );

	err = plog->ErrLGLogRec( rgdata, 1, fLGNoNewGen, pNil );

	return err;
	}
	

ERR ErrLGIMacroEnd( PIB *ppib, DBTIME dbtime, LRTYP lrtyp, LGPOS *plgpos )
	{
	ERR			err;
	DATA		rgdata[1];
	LRMACROEND	lrMacroEnd;

	INST *pinst = PinstFromPpib( ppib );
	LOG *plog = pinst->m_plog;
	
	Assert( !plog->m_fRecovering || plog->m_fRecoveringMode == fRecoveringUndo );
	
	if ( plog->m_fLogDisabled )
		{
		*plgpos = lgposMin;
		return JET_errSuccess;
		}

	Assert( lrtyp == lrtypMacroCommit || lrtyp == lrtypMacroAbort );
	lrMacroEnd.lrtyp	= lrtyp;
	lrMacroEnd.le_procid	= ppib->procid;
	lrMacroEnd.le_dbtime	= dbtime;

	rgdata[0].SetPv( (BYTE *)&lrMacroEnd );
	rgdata[0].SetCb( sizeof(lrMacroEnd) );

	err = plog->ErrLGLogRec( rgdata, 1, fLGNoNewGen, plgpos );

	return err;
	}


ERR ErrLGMacroAbort( PIB *ppib, DBTIME dbtime, LGPOS *plgpos )
	{
	return ErrLGIMacroEnd( ppib, dbtime, lrtypMacroAbort, plgpos );
	}

ERR ErrLGShutDownMark( LOG *plog, LGPOS *plgposRec )
	{
	ERR				err;
	DATA			rgdata[1];
	LRSHUTDOWNMARK	lr;

	//	record even during recovery
	//
	if ( plog->m_fLogDisabled || ( plog->m_fRecovering && plog->m_fRecoveringMode != fRecoveringUndo ) )
		{
		*plgposRec = lgposMin;
		return JET_errSuccess;
		}

	lr.lrtyp = lrtypShutDownMark;

	rgdata[0].SetPv( (BYTE *)&lr );
	rgdata[0].SetCb( sizeof(lr) );

	CallR( plog->ErrLGLogRec( rgdata, 1, fLGNoNewGen, plgposRec ) );

	//	Continue to make sure it is flushed

SendSignal:
	plog->LGSignalFlush();
		
	plog->m_critLGBuf.Enter();
	const INT	cmp = CmpLgpos( plgposRec, &plog->m_lgposToFlush );
	plog->m_critLGBuf.Leave();
	if ( cmp >= 0 )
		{
		if ( plog->m_fLGNoMoreLogWrite )
			{
			err = ErrERRCheck( JET_errLogWriteFail );
			return err;
			}
		else
			{
			UtilSleep( cmsecWaitLogFlush );
			goto SendSignal;
			}
		}
		
	return err;
	}

	
ERR ErrLGRecoveryUndo( LOG *plog )
	{
	ERR				err;
	DATA			rgdata[1];
	LRRECOVERYUNDO2	lr;

	//	should only be called during undo phase of recovery
	Assert( plog->m_fRecovering );
	Assert( fRecoveringUndo == plog->m_fRecoveringMode );

	if ( plog->m_fLogDisabled || ( plog->m_fRecovering && plog->m_fRecoveringMode != fRecoveringUndo ) )
		{
		return JET_errSuccess;
		}

	lr.lrtyp = lrtypRecoveryUndo2;
	LGIGetDateTime( &lr.logtime );

	rgdata[0].SetPv( (BYTE *)&lr );
	rgdata[0].SetCb( sizeof(lr) );

	err = plog->ErrLGLogRec( rgdata, 1, fLGNoNewGen, pNil );

	return err;
	}


ERR ErrLGQuitRec( LOG *plog, LRTYP lrtyp, const LE_LGPOS *ple_lgpos, const LE_LGPOS *ple_lgposRedoFrom, BOOL fHard )
	{
	ERR			err;
	DATA		rgdata[1];
	LRTERMREC2	lr;

	//	record even during recovery
	//
	if ( plog->m_fLogDisabled || ( plog->m_fRecovering && plog->m_fRecoveringMode != fRecoveringUndo ) )
		return JET_errSuccess;

	lr.lrtyp = lrtyp;
	LGIGetDateTime( &lr.logtime );
	lr.lgpos = *ple_lgpos;
	if ( ple_lgposRedoFrom )
		{
		Assert( lrtyp == lrtypRecoveryQuit2 );
		lr.lgposRedoFrom = *ple_lgposRedoFrom;
		lr.fHard = BYTE( fHard );
		}
	rgdata[0].SetPv( (BYTE *)&lr );
	rgdata[0].SetCb( sizeof(lr) );

	err = plog->ErrLGLogRec( rgdata, 1, fLGNoNewGen, pNil );

	return err;
	}

	
ERR ErrLGLogBackup(
	LOG*							plog,
	LRLOGBACKUP::LRLOGBACKUP_TYPE	fBackupType,
	CHAR*							szLogRestorePath,
	const BOOL						fLGFlags,
	LGPOS*							plgposLogRec )
	{
	ERR								err;
	DATA							rgdata[2];
	LRLOGBACKUP						lr;
	
	//	record even during recovery
	//
	if ( plog->m_fLogDisabled || ( plog->m_fRecovering && plog->m_fRecoveringMode != fRecoveringUndo ) )
		{
		*plgposLogRec = lgposMin;
		return JET_errSuccess;
		}

	lr.lrtyp = lrtypBackup;

	Assert ( 	LRLOGBACKUP::fLGBackupFull == fBackupType ||
				LRLOGBACKUP::fLGBackupIncremental == fBackupType ||
				LRLOGBACKUP::fLGBackupSnapshotStart == fBackupType ||
				LRLOGBACKUP::fLGBackupSnapshotStop == fBackupType );

	lr.m_fBackupType = BYTE( fBackupType );
	lr.le_cbPath = USHORT( strlen( szLogRestorePath ) );

	rgdata[0].SetPv( (BYTE *)&lr );
	rgdata[0].SetCb( sizeof(lr) );
	rgdata[1].SetPv( reinterpret_cast<BYTE *>( szLogRestorePath ) );
	rgdata[1].SetCb( lr.le_cbPath );

	err = plog->ErrLGLogRec( rgdata, 2, fLGFlags, plgposLogRec );

	return err;
	}

ERR ErrLGSLVIPageAppendChecksum(
						PIB* const 		ppib,
						const IFMP		ifmp,
						const QWORD		ibLogical,
						const ULONG		cbData,
						VOID* const		pvData,
						SLVOWNERMAPNODE	*pOwnerMapNode )
	{
	ERR				err = JET_errSuccess;
	
	ASSERT_VALID( ppib );
	Assert( ifmp & ifmpSLV );
	Assert( cbData );
	Assert( cbData <= g_cbPage );
	Assert( pvData );
	Assert( pOwnerMapNode != NULL );

	//  get our instance and log instance

	INST*	pinst	= PinstFromIfmp( ifmp & ifmpMask );
	LOG*	plog	= pinst->m_plog;

	Assert ( pinst->FSLVProviderEnabled() );
	
	Assert ( 0 == ( ibLogical % sizeof(QWORD) ) );
	// we don't append in a SLV page for backdoor
	// so we have to start at a page boundary
	Assert ( 0 == ( ibLogical % SLVPAGE_SIZE ) );

	if ( rgfmp[ifmp & ifmpMask].PfcbSLVOwnerMap() )
		{		
		Assert ( !plog->m_fRecovering );		
		ULONG ulChecksum; 

		TRY
			{
			ulChecksum = UlChecksumSLV(
								(BYTE*)pvData,
								(BYTE*)pvData + cbData );
			}
		EXCEPT ( efaExecuteHandler )
			{
			CallR ( ErrERRCheck( JET_errSLVFileIO ) );
			}
		ENDEXCEPT

		pOwnerMapNode->AssertOnPage( PgnoOfOffset( ibLogical ) );
		CallR( pOwnerMapNode->ErrSetChecksum( ppib, ulChecksum, cbData ) );
		}

	return JET_errSuccess;
	}

// ErrLGSLVPageAppend			- logs a physical SLV append
//
// IN:
//		ppib					- session
//      ifmp					- SLV ifmp
//		ibLogical				- starting SLV file offset
//		cbData					- size
//		pvData					- data
//		fDataLogged				- fTrue if the data should be logged
//		plgpos					- buffer for receiving the LGPOS of this record
//
// RESULT:						ERR
//
// OUT:	
//		plgpos					- LGPOS of this record

ERR ErrLGSLVPageAppend(	PIB* const 		ppib,
						const IFMP		ifmp,
						const QWORD		ibLogical,
						const ULONG		cbData,
						VOID* const		pvData,
						const BOOL		fDataLogged,
						const BOOL		fMovedByOLDSLV,
						SLVOWNERMAPNODE	*pslvownermapNode,
						LGPOS* const	plgpos )
	{
	ERR				err = JET_errSuccess;
	DATA			rgdata[ 2 ];
	LRSLVPAGEAPPEND	lrSLVPageAppend;

//	UNDONE (see bug X5:143388): don't currently support appends if not on page boundary
///Assert( 0 == ( ibLogical % SLVPAGE_SIZE ) );	

	//  validate IN args

	ASSERT_VALID( ppib );
	Assert( ifmp & ifmpSLV );
	Assert( cbData );
	Assert( cbData <= g_cbPage );
	Assert( pvData );

	//  get our instance and log instance

	INST * const	pinst	= PinstFromIfmp( ifmp & ifmpMask );
	LOG * const		plog	= pinst->m_plog;

	//	we don't always need to log the data
	//	if
	//		- circular logging is on (i.e. we won't need to roll forward)
	//		- we are using IFS (i.e. the streaming file is write-through)
	//		- we aren't backing up the server
	//	we can avoid logging
	
	const BOOL fBackup 				= plog->m_fBackupInProgress;
	const BOOL fCircularLogging		= plog->m_fLGCircularLogging;
	const BOOL fSLVProviderEnabled 	= pinst->FSLVProviderEnabled();
	
	const BOOL fLogData 			= fDataLogged && ( fBackup || !fCircularLogging || !fSLVProviderEnabled );
	
	// on frontdoor, it is done in ErrSLVWriteRun
	if ( pinst->FSLVProviderEnabled() )
		{
		CallR ( ErrLGSLVIPageAppendChecksum( ppib, ifmp, ibLogical, cbData, pvData, pslvownermapNode ) );
		}
		
	//  forget it if logging is disabled globally or for this database or if we
	//  are recovering

	Assert( !rgfmp[ifmp & ifmpMask].FLogOn() || !plog->m_fLogDisabled );
	if ( !rgfmp[ ifmp & ifmpMask ].FLogOn() || plog->m_fRecovering )
		{
		if ( plgpos )
			{
			if ( plog->m_fRecovering )
				{
				*plgpos = plog->m_lgposRedo;
				}
			else
				{
				*plgpos = lgposMin;
				}
			}
		return JET_errSuccess;
		}

	//  perform our session's deferred begin transaction if necessary
	
	CallR( ErrLGDeferBeginTransaction( ppib ) );

	// fill the append record
	
	lrSLVPageAppend.lrtyp			= lrtypSLVPageAppend;
	lrSLVPageAppend.le_procid		= ppib->procid;
	lrSLVPageAppend.dbid			= rgfmp[ ifmp & ifmpMask ].Dbid();
	lrSLVPageAppend.le_ibLogical	= ibLogical;
	lrSLVPageAppend.le_cbData		= cbData;

	rgdata[0].SetPv( (BYTE*)&lrSLVPageAppend );
	rgdata[0].SetCb( sizeof( LRSLVPAGEAPPEND ) );

	Assert( !lrSLVPageAppend.FDataLogged() );
	if ( fLogData )
		{
		lrSLVPageAppend.SetFDataLogged();
		rgdata[1].SetPv( pvData );
		rgdata[1].SetCb( cbData );	
		}
	
	//  log the record
	err = plog->ErrLGLogRec( rgdata, fLogData ? 2 : 1, fLGNoNewGen, plgpos );

	return err;
	}


char const *szNOP 						= "NOP      ";
char const *szNOPEndOfList				= "NOPEnd   ";
char const *szInit						= "Init     ";
char const *szTerm						= "Term     ";
char const *szMS						= "MS       ";
char const *szEnd						= "End      ";

char const *szBegin						= "Begin    ";
char const *szCommit					= "Commit   ";
char const *szRollback					= "Rollback ";

char const *szCreateDB					= "CreateDB ";
char const *szAttachDB					= "AttachDB ";
char const *szDetachDB					= "DetachDB ";
char const *szDbList					= "DbList   ";

char const *szCreateMultipleExtentFDP	= "Create M ";
char const *szCreateSingleExtentFDP		= "Create S ";
char const *szConvertFDP				= "Convert  ";

char const *szSplit						= "Split    ";
char const *szEmptyPage					= "EmptyPage";
char const *szMerge						= "Merge    ";
char const *szEmptyTree					= "EmptyTree";

char const *szInsert					= "Insert   ";
char const *szFlagInsert				= "FInsert  ";
char const *szFlagInsertAndReplaceData	= "FInsertRD";
char const *szFlagDelete				= "FDelete  ";
char const *szReplace					= "Replace  ";
char const *szReplaceD					= "ReplaceD ";

char const *szLock						= "Lock     ";
char const *szUndoInfo					= "UndoInfo ";

char const *szDelta						= "Delta    ";
char const *szDelete					= "Delete   ";

char const *szUndo						= "Undo     ";

char const *szBegin0					= "Begin0   ";
char const *szBeginDT					= "BeginDT  ";
char const *szPrepCommit				= "PreCommit";
char const *szPrepRollback				= "PreRollbk";
char const *szCommit0					= "Commit0  ";
char const *szRefresh					= "Refresh  ";

char const *szRecoveryUndo				= "RcvUndo  ";
char const *szRecoveryQuit				= "RcvQuit  ";

char const *szFullBackup				= "FullBkUp ";
char const *szIncBackup					= "IncBkUp  ";
char const *szBackup					= "Backup   ";

char const *szJetOp						= "JetOp    ";
char const *szTrace						= "Trace    ";

char const *szShutDownMark				= "ShutDown ";

char const *szSetExternalHeader 		= "SetExtHdr";

char const *szMacroBegin				= "McroBegin";
char const *szMacroCommit				= "McroComit";
char const *szMacroAbort				= "McroAbort";

char const *szSLVPageAppend				= "SLVPgAppd";
char const *szSLVSpace					= "SLVSpace ";
char const *szSLVPageMove				= "SLVPgMove";

char const *szChecksum					= "Checksum ";

char const *szExtRestore 				= "ExtRest  ";
char const *szForceDetachDB				= "FDetachDB";

char const *szUnknown					= "*UNKNOWN*";

const char * SzLrtyp( LRTYP lrtyp )
	{
	switch ( lrtyp )
		{
		case lrtypNOP:			return szNOP;
		case lrtypInit:			return szInit;
		case lrtypInit2:		return szInit;
		case lrtypTerm:			return szTerm;
		case lrtypTerm2:		return szTerm;
		case lrtypMS:			return szMS;
		case lrtypEnd:			return szEnd;

		case lrtypBegin:		return szBegin;
		case lrtypCommit:		return szCommit;
		case lrtypRollback:		return szRollback;	
		case lrtypBegin0:		return szBegin0;
		case lrtypCommit0:		return szCommit0;
		case lrtypBeginDT:		return szBeginDT;
		case lrtypPrepCommit:	return szPrepCommit;
		case lrtypPrepRollback:	return szPrepRollback;
		case lrtypRefresh:		return szRefresh;
		case lrtypMacroBegin:	return szMacroBegin;
		case lrtypMacroCommit:	return szMacroCommit;
		case lrtypMacroAbort:	return szMacroAbort;
		
		case lrtypCreateDB:		return szCreateDB;
		case lrtypAttachDB:		return szAttachDB;
		case lrtypDetachDB:		return szDetachDB;
		case lrtypDbList:		return szDbList;
		
		//	debug log records
		//
		case lrtypRecoveryUndo:	return szRecoveryUndo;
		case lrtypRecoveryUndo2:	return szRecoveryUndo;
		case lrtypRecoveryQuit: return szRecoveryQuit;
		case lrtypRecoveryQuit2: return szRecoveryQuit;
		
		case lrtypFullBackup:	return szFullBackup;
		case lrtypIncBackup:	return szIncBackup;
		case lrtypBackup:		return szBackup;
		
		case lrtypJetOp:		return szJetOp;
		case lrtypTrace:		return szTrace;
		
		case lrtypShutDownMark:	return szShutDownMark;

		//	multi-page updaters
		//
		case lrtypCreateMultipleExtentFDP:	return szCreateMultipleExtentFDP;
		case lrtypCreateSingleExtentFDP:	return szCreateSingleExtentFDP;
		case lrtypConvertFDP:				return szConvertFDP;
	
		case lrtypSplit:		return szSplit;
		case lrtypMerge:	 	return szMerge;
		case lrtypEmptyTree:	return szEmptyTree;
		
		//	single-page updaters
		//
		case lrtypInsert:		return szInsert;
		case lrtypFlagInsert:	return szFlagInsert;
		case lrtypFlagInsertAndReplaceData:	
								return szFlagInsertAndReplaceData;
		case lrtypFlagDelete:	return szFlagDelete;
		case lrtypReplace:		return szReplace;
		case lrtypReplaceD:		return szReplaceD;
		case lrtypDelete:		return szDelete;
		
		case lrtypUndoInfo:	return szUndoInfo;

		case lrtypDelta:		return szDelta;
		
		case lrtypSetExternalHeader:
								return szSetExternalHeader;

		case lrtypUndo:			return szUndo;

		

		// SLV file changed
		case lrtypSLVPageAppend:
								return szSLVPageAppend;
		case lrtypSLVSpace:		return szSLVSpace;

		case lrtypSLVPageMove:	return szSLVPageMove;

		case lrtypChecksum:		return szChecksum;

		case lrtypExtRestore: 	return szExtRestore;
		case lrtypForceDetachDB: return szForceDetachDB;

		default:				return szUnknown;
		}
	Assert( fFalse );
	}
	
#ifdef DEBUG

const CHAR * const mpopsz[opMax] = {
	0,									//	0		
	"JetIdle",							//	1	
	"JetGetTableIndexInfo",				//	2	
	"JetGetIndexInfo",					//	3	
	"JetGetObjectInfo",					//	4	
	"JetGetTableInfo",					//	5	
	"JetCreateObject",					//	6	
	"JetDeleteObject",					//	7	
	"JetRenameObject",					//	8	
	"JetBeginTransaction",				//	9	
	"JetCommitTransaction",				//	10	
	"JetRollback",						//	11	
	"JetOpenTable",						//	12	
	"JetDupCursor",						//	13	
	"JetCloseTable",					//	14	
	"JetGetTableColumnInfo",			//	15	
	"JetGetColumnInfo",					//	16	
	"JetRetrieveColumn",				//	17	
	"JetRetrieveColumns",				//	18	
	"JetSetColumn",						//	19	
	"JetSetColumns",					//	20	
	"JetPrepareUpdate",					//	21	
	"JetUpdate",						//	22	
	"JetDelete",						//	23	
	"JetGetCursorInfo",					//	24	
	"JetGetCurrentIndex",				//	25	
	"JetSetCurrentIndex",				//	26	
	"JetMove",							// 	27	
	"JetMakeKey",						//	28	
	"JetSeek",							//	29	
	"JetGetBookmark",					//	30	
	"JetGotoBookmark",					//	31	
	"JetGetRecordPosition",				//	32	
	"JetGotoPosition",					//	33	
	"JetRetrieveKey",					//	34	
	"JetCreateDatabase",				//	35	
	"JetOpenDatabase",					//	36	
	"JetGetDatabaseInfo",				//	37	
	"JetCloseDatabase",					//	38	
	"JetCapability",					//	39	
	"JetCreateTable",					//	40	
	"JetRenameTable",					//	41	
	"JetDeleteTable",					//	42	
	"JetAddColumn",						//	43	
	"JetRenameColumn",					//	44	
	"JetDeleteColumn",					//	45	
	"JetCreateIndex",					//	46	
	"JetRenameIndex",					//	47	
	"JetDeleteIndex",					//	48	
	"JetComputeStats",					//	49	
	"JetAttachDatabase",				//	50	
	"JetDetachDatabase",				//	51	
	"JetOpenTempTable",					//	52	
	"JetSetIndexRange",					//	53	
	"JetIndexRecordCount",				//	54	
	"JetGetChecksum",					//	55	
	"JetGetObjidFromName",				//	56	
	"JetEscrowUpdate",					//	57
	"JetGetLock",						//	58
	"JetRetrieveTaggedColumnList",		//	59
	"JetCreateTableColumnIndex",		//	60
	"JetSetColumnDefaultValue",			//	61
	"JetPrepareToCommitTransaction",	//	62
	"JetSetTableSequential",			//  63
	"JetResetTableSequential",			//  64
	"JetRegisterCallback",				//  65
	"JetUnregisterCallback",			//  66
	"JetSetLS",							//  67
	"JetGetLS",							//  68
	"JetGetVersion",					//  69
	"JetBeginSession",					//  70
	"JetDupSession",					//  71
	"JetEndSession",					//  72
	"JetBackupInstance",				//  73
	"JetBeginExternalBackupInstance",	//  74
	"JetGetAttachInfoInstance",			//  75
	"JetOpenFileInstance",				//  76
	"JetReadFileInstance",				//  77
	"JetCloseFileInstance",				//  78
	"JetGetLogInfoInstance",			//  79
	"JetGetTruncateLogInfoInstance",	//  80
	"JetTruncateLogInstance",			//  81
	"JetEndExternalBackupInstance",		//  82
	"JetSnapshotStart",					//  83
	"JetSnapshotStJet",					//  84
	"JetResetCounter",					//  85
	"JetGetCounter",					//  86
	"JetCompact",						//  87
	"JetConvertDDL",					//  88
	"JetUpgradeDatabase",				//  89
	"JetDefragment",					//  90
	"JetSetDatabaseSize",				//  91
	"JetGrowDatabase",					//  92
	"JetSetSessionContext",				//  93
	"JetResetSessionContext",			//  94
	"JetSetSystemParameter",			//  95
	"JetGetSystemParameter",			//  96
	"JetTerm",							//  97
	"JetInit",							//  98
	"JetIntersectIndexes",				//  99
	"JetEnumerateColumns",				//  100
};

VOID SPrintSign( SIGNATURE *psign, char * sz )
	{
	LOGTIME tm = psign->logtimeCreate;
	sprintf( sz, "Create time:%d/%d/%d %d:%d:%d Rand:%lu Computer:%s",
						(short) tm.bMonth,
						(short) tm.bDay,
						(short) tm.bYear + 1900,
						(short) tm.bHours,
						(short) tm.bMinutes,
						(short) tm.bSeconds,
						(ULONG) psign->le_ulRandom,
						0 != psign->szComputerName[0] ? psign->szComputerName : "<None>" );
	}

const BYTE mpbb[] = {'0', '1', '2', '3', '4', '5', '6', '7', '8',
					 '9', 'A', 'B', 'C', 'D', 'E', 'F' };

// In order to output 1 byte of raw data, need 3 bytes - two to
// represent the data and a trailing space.
// Also need a null-terminator to mark the end of the data stream.
// Finally, DWORD-align the buffer.
const INT	cbRawDataMax		= 16;
const INT	cbFormattedDataMax	= ( ( ( ( cbRawDataMax * 3 ) + 1 )
									+ (sizeof(DWORD)-1) ) / sizeof(DWORD) ) * sizeof(DWORD);

LOCAL VOID DataToSz ( const BYTE *pbData, INT cbData, CHAR * sz )
	{
	const BYTE	*pb;
	const BYTE	*pbMax;
	BYTE	*pbPrint = reinterpret_cast<BYTE *>( sz );

	if ( cbData > cbRawDataMax )
		pbMax = pbData + cbRawDataMax;
	else
		pbMax = pbData + cbData;

	for( pb = pbData; pb < pbMax; pb++ )
		{
		BYTE b = *pb;
		
		*pbPrint++ = mpbb[b >> 4];
		*pbPrint++ = mpbb[b & 0x0f];
		*pbPrint++ = ' ';
		
//		if ( isalnum( *pb ) )
//			DBGprintf( "%c", *pb );
//		else
//			DBGprintf( "%x", *pb );
		}

	*pbPrint='\0';
	}


VOID ShowData ( const BYTE *pbData, INT cbData )
	{
	CHAR	rgchPrint[cbFormattedDataMax];
	DataToSz( pbData, cbData, rgchPrint );
	DBGprintf( "%s", rgchPrint );
	}

	

//	Prints log record contents.  If pv == NULL, then data is assumed
//	to follow log record in contiguous memory.
//
// INT cNOP = 0;

const INT	cbLRBuf = 1024 + cbFormattedDataMax;

VOID ShowLR( const LR *plr, LOG * plog )
	{
	char rgchBuf[cbLRBuf];
	LrToSz( plr, rgchBuf, plog );
	DBGprintf( "%s\n", rgchBuf );
	}

VOID CheckEndOfNOPList( const LR *plr, LOG *plog )
	{
	const ULONG	cNOP	= plog->GetNOP();

	Assert( cNOP > 0 );
	if ( NULL == plr || lrtypNOP != plr->lrtyp )
		{
		if ( cNOP > 1 )
			{
			DBGprintf( ">                 %s (Total NOPs: %d)\n", szNOPEndOfList, cNOP );
			}
		plog->SetNOP(0);
		}
	else
		{
		plog->IncNOP();
		}
	}

VOID LrToSz( const LR *plr, char * szLR, LOG * plog )
	{
	LRTYP 	lrtyp;
	CHAR	rgchBuf[cbLRBuf];

	char const *szUnique 		= "U";
	char const *szNotUnique		= "NU";

	char const *szPrefix		= "P";
	char const *szNoPrefix		= "NP";

	char const *szVersion		= "V";
	char const *szNoVersion		= "NV";

	char const *szDeleted		= "D";
	char const *szNotDeleted	= "ND";

	char const *szEmptyPage		= "EP";
	char const *szNotEmptyPage	= "NEP";

	char const *szKeyChange		= "KC";
	char const *szNoKeyChange	= "NKC";

	char const *szConcCI		= "CI";
	char const *szNotConcCI		= "NCI";

	char const *szData			= "D";
	char const *szNoData		= "ND";

	char const *szSpaceTree		= "SP";
	char const *szNotSpaceTree	= "NSP";

	char const *rgszIO[]		= { "???", "SR", "SW", "AR", "AW", "???" };
	char const *rgszMergeType[]	= { "None", "EmptyPage", "FullRight", "PartialRight", "EmptyTree" };

	const char * const szMovedByOLDSLV 		= "moved by OLDSLV";
	const char * const szNotMovedByOLDSLV	= "not moved by OLDSLV";

 	if ( plr->lrtyp >= lrtypMax )
		lrtyp = lrtypMax;
	else
		lrtyp = plr->lrtyp;

	if ( !plog || plog->GetNOP() == 0 || lrtyp != lrtypNOP )
		{
		sprintf( szLR, " %s", SzLrtyp( lrtyp ) );
		}
		
	switch ( plr->lrtyp )
		{
		case lrtypNOP:
			if( plog )
				{
				Assert( 0 == plog->GetNOP() );
				plog->IncNOP();
				}
			break;

		case lrtypMS:
			{
			LRMS *plrms = (LRMS *)plr;

			sprintf( rgchBuf, " (%X,%X checksum %u)",
				(USHORT) plrms->le_isecForwardLink,
				(USHORT) plrms->le_ibForwardLink,
				(ULONG) plrms->le_ulCheckSum );
			strcat( szLR, rgchBuf );
			break;
			}

		case lrtypInsert:
			{
			LRINSERT	*plrinsert = (LRINSERT *)plr;
			BYTE		*pb;
			ULONG		cb;

			pb = (BYTE *) plr + sizeof( LRINSERT );
			cb = plrinsert->CbSuffix() + plrinsert->CbPrefix() + plrinsert->CbData();
			
			sprintf( rgchBuf, " %I64x,%I64x,%lx:%u(%x,[%u:%lu:%u],%s:%s:%s:%s,%u,%u,%u,rceid:%lu,objid:%lu)",
					(DBTIME) plrinsert->le_dbtime,
					(DBTIME) plrinsert->le_dbtimeBefore,
					(TRX) plrinsert->le_trxBegin0,
					(USHORT) plrinsert->level,
					(PROCID) plrinsert->le_procid,
					(USHORT) plrinsert->dbid,
					(PGNO) plrinsert->le_pgno,
					plrinsert->ILine(),
					plrinsert->FUnique() ? szUnique : szNotUnique,
					plrinsert->FVersioned() ? szVersion : szNoVersion,
					plrinsert->FDeleted() ? szDeleted : szNotDeleted,
					plrinsert->FConcCI() ? szConcCI : szNotConcCI,
 					plrinsert->CbPrefix(),
 					plrinsert->CbSuffix(),
					plrinsert->CbData(),
					(RCEID) plrinsert->le_rceid,
					(OBJID) plrinsert->le_objidFDP );
			strcat( szLR, rgchBuf );

			DataToSz( pb, cb, rgchBuf );
			strcat( szLR, rgchBuf );
			break;
			}

		case lrtypFlagInsert:
			{
			LRFLAGINSERT	*plrflaginsert = (LRFLAGINSERT *)plr;

			sprintf( rgchBuf, " %I64x,%I64x,%lx:%u(%x,[%u:%lu:%u],%s:%s:%s:%s,rceid:%lu,objid:%lu)",
					(DBTIME) plrflaginsert->le_dbtime,
					(DBTIME) plrflaginsert->le_dbtimeBefore,
					(TRX) plrflaginsert->le_trxBegin0,
					(USHORT) plrflaginsert->level,
					(PROCID) plrflaginsert->le_procid,
					(USHORT) plrflaginsert->dbid,
					(PGNO) plrflaginsert->le_pgno,
					plrflaginsert->ILine(),
					plrflaginsert->FUnique() ? szUnique : szNotUnique,
					plrflaginsert->FVersioned() ? szVersion : szNoVersion,
					plrflaginsert->FDeleted() ? szDeleted : szNotDeleted,
					plrflaginsert->FConcCI() ? szConcCI : szNotConcCI,
					(RCEID) plrflaginsert->le_rceid,
					(OBJID) plrflaginsert->le_objidFDP );
			strcat( szLR, rgchBuf );

			break;
			}

		case lrtypReplace:
		case lrtypReplaceD:
			{
			LRREPLACE *plrreplace = (LRREPLACE *)plr;
			BYTE	*pb;
			USHORT	cb;

			pb = (BYTE *) plrreplace + sizeof( LRREPLACE );
			cb = plrreplace->Cb();

			sprintf( rgchBuf, " %I64x,%I64x,%lx:%u(%x,[%u:%lu:%u],%s:%s:%s,%5u,%5u,%5u,rceid:%lu,objid:%lu)",
				(DBTIME) plrreplace->le_dbtime,
				(DBTIME) plrreplace->le_dbtimeBefore,
				(TRX) plrreplace->le_trxBegin0,
				(USHORT) plrreplace->level,
				(PROCID) plrreplace->le_procid,
				(USHORT) plrreplace->dbid,
				(PGNO) plrreplace->le_pgno,
				plrreplace->ILine(),
				plrreplace->FUnique() ? szUnique : szNotUnique,
				plrreplace->FVersioned() ? szVersion : szNoVersion,
				plrreplace->FConcCI() ? szConcCI : szNotConcCI,
				cb,
				plrreplace->CbNewData(),
				plrreplace->CbOldData(),
				(RCEID) plrreplace->le_rceid,
				(OBJID) plrreplace->le_objidFDP );
			strcat( szLR, rgchBuf );
			if ( plr->lrtyp == lrtypReplaceD )
				{
				LGDumpDiff(	pb, cb );
				}
			else
				{
				DataToSz( pb, cb, rgchBuf );
				strcat( szLR, rgchBuf );
				}
			break;
			}

		case lrtypFlagInsertAndReplaceData:
			{
			LRFLAGINSERTANDREPLACEDATA *plrfiard = (LRFLAGINSERTANDREPLACEDATA *)plr;
			BYTE	*pb;
			ULONG	cb;

			pb = (BYTE *) plrfiard + sizeof( LRFLAGINSERTANDREPLACEDATA );
			cb = plrfiard->CbKey() + plrfiard->CbData();

			sprintf( rgchBuf, " %I64x,%I64x,%lx:%u(%x,[%u:%lu:%u],%s:%s:%s,%5u,rceidInsert:%lu,rceidReplace:%lu,objid:%lu)",
				(DBTIME) plrfiard->le_dbtime,
				(DBTIME) plrfiard->le_dbtimeBefore,
				(TRX) plrfiard->le_trxBegin0,
				(USHORT) plrfiard->level,
				(PROCID) plrfiard->le_procid,
				(USHORT) plrfiard->dbid,
				(PGNO) plrfiard->le_pgno,
				plrfiard->ILine(),
				plrfiard->FUnique() ? szUnique : szNotUnique,
				plrfiard->FVersioned() ? szVersion : szNoVersion,
				plrfiard->FConcCI() ? szConcCI : szNotConcCI,
				cb,
				(RCEID) plrfiard->le_rceid,
				(RCEID) plrfiard->le_rceidReplace,
				(OBJID) plrfiard->le_objidFDP );
			strcat( szLR, rgchBuf );
			if ( plr->lrtyp == lrtypReplaceD )
				{
				LGDumpDiff(	pb, cb );
				}
			else
				{
				DataToSz( pb, cb, rgchBuf );
				strcat( szLR, rgchBuf );
				}
			break;
			}
			
		case lrtypFlagDelete:
			{
			LRFLAGDELETE *plrflagdelete = (LRFLAGDELETE *)plr;
			sprintf( rgchBuf, " %I64x,%I64x,%lx:%u(%x,[%u:%lu:%u],%s:%s:%s),rceid:%lu,objid:%lu",
				(DBTIME) plrflagdelete->le_dbtime,
				(DBTIME) plrflagdelete->le_dbtimeBefore,
				(TRX) plrflagdelete->le_trxBegin0,
				(USHORT) plrflagdelete->level,
				(PROCID) plrflagdelete->le_procid,
				(USHORT) plrflagdelete->dbid,
				(PGNO) plrflagdelete->le_pgno,
				plrflagdelete->ILine(),
				plrflagdelete->FUnique() ? szUnique : szNotUnique,
				plrflagdelete->FVersioned() ? szVersion : szNoVersion,
				plrflagdelete->FConcCI() ? szConcCI : szNotConcCI,
				(RCEID) plrflagdelete->le_rceid,
				(OBJID) plrflagdelete->le_objidFDP );
			strcat( szLR, rgchBuf );
			break;
			}

		case lrtypDelete:
			{
			LRDELETE *plrdelete = (LRDELETE *)plr;
			sprintf( rgchBuf, " %I64x,%I64x,%lx:%u(%x,[%u:%lu:%u],%s,objid:%lu)",
				(DBTIME) plrdelete->le_dbtime,
				(DBTIME) plrdelete->le_dbtimeBefore,
				(TRX) plrdelete->le_trxBegin0,
				(USHORT) plrdelete->level,
				(PROCID) plrdelete->le_procid,
				(USHORT) plrdelete->dbid,
				(PGNO) plrdelete->le_pgno,
				plrdelete->ILine(),
				plrdelete->FUnique() ? szUnique : szNotUnique,
				(OBJID) plrdelete->le_objidFDP );
			strcat( szLR, rgchBuf );
			break;
			}

		case lrtypUndoInfo:
			{
			LRUNDOINFO *plrundoinfo = (LRUNDOINFO *)plr;
			sprintf( rgchBuf, " %lx:%u(%x,[%u:%lu],%u,rceid:%lu,objid:%lu)",
				(TRX) plrundoinfo->le_trxBegin0,
				(USHORT) plrundoinfo->level,
				(PROCID) plrundoinfo->le_procid,
				(USHORT) plrundoinfo->dbid,
				(PGNO) plrundoinfo->le_pgno,
				(USHORT) plrundoinfo->le_cbData,
				(RCEID) plrundoinfo->le_rceid,
				(OBJID) plrundoinfo->le_objidFDP
				);
			strcat( szLR, rgchBuf );

			DataToSz( plrundoinfo->rgbData, plrundoinfo->le_cbData, rgchBuf );
			strcat( szLR, rgchBuf );
			break;
			}

		case lrtypDelta:
			{
			LRDELTA *plrdelta = (LRDELTA *)plr;

			sprintf( rgchBuf, " %I64x,%I64x,%lx:%u(%x,[%u:%lu:%u],%s:%s,%d,rceid:%lu,objid:%lu)",
				(DBTIME) plrdelta->le_dbtime,
				(DBTIME) plrdelta->le_dbtimeBefore,
				(TRX) plrdelta->le_trxBegin0,
				(USHORT) plrdelta->level,
				(PROCID) plrdelta->le_procid,
				(USHORT) plrdelta->dbid,
				(PGNO) plrdelta->le_pgno,
				plrdelta->ILine(),
				plrdelta->FVersioned() ? szVersion : szNoVersion,
				plrdelta->FConcCI() ? szConcCI : szNotConcCI,
				(SHORT) plrdelta->LDelta(),
				(RCEID) plrdelta->le_rceid,
				(OBJID) plrdelta->le_objidFDP );
			strcat( szLR, rgchBuf );
			break;
			}


		case lrtypJetOp:
			{
			LRJETOP *plrjetop = (LRJETOP *)plr;
	   		sprintf( rgchBuf, " (%x) -- %s",
	   			(PROCID) plrjetop->le_procid,
	   			mpopsz[ plrjetop->op ] );
			strcat( szLR, rgchBuf );
			break;
			}

		case lrtypBegin:
		case lrtypBegin0:
#ifdef DTC		
		case lrtypBeginDT:
#endif		
			{
			const LRBEGINDT		* const plrbeginDT	= (LRBEGINDT *)plr;
			Assert( plrbeginDT->levelBeginFrom >= 0 );
			Assert( plrbeginDT->clevelsToBegin <= levelMax );
	   		sprintf( rgchBuf, " (%x,from:%d,to:%d)",
	   			(PROCID) plrbeginDT->le_procid,
	   			(SHORT) plrbeginDT->levelBeginFrom,
	   			(SHORT) ( plrbeginDT->levelBeginFrom + plrbeginDT->clevelsToBegin ) );
			strcat( szLR, rgchBuf );
			if ( lrtypBegin != plr->lrtyp )
				{
				sprintf( rgchBuf, " %lx", (TRX) plrbeginDT->le_trxBegin0 );
				strcat( szLR, rgchBuf );
				}
			break;
			}

		case lrtypMacroBegin:
		case lrtypMacroCommit:
		case lrtypMacroAbort:
			{
			LRMACROBEGIN *plrmbegin = (LRMACROBEGIN *)plr;
	   		sprintf( rgchBuf, " (%x) %I64x", (PROCID) plrmbegin->le_procid, (DBTIME) plrmbegin->le_dbtime );
			strcat( szLR, rgchBuf );
			break;
			}

		case lrtypRefresh:
			{
			LRREFRESH *plrrefresh = (LRREFRESH *) plr;

			sprintf( rgchBuf, " (%x,%lx)",
	   			(PROCID) plrrefresh->le_procid,
	   			(TRX) plrrefresh->le_trxBegin0 );
			strcat( szLR, rgchBuf );

			break;
			}

		case lrtypCommit:
		case lrtypCommit0:
			{
			LRCOMMIT0 *plrcommit0 = (LRCOMMIT0 *)plr;
	   		sprintf( rgchBuf, " (%x,to:%d)",
	   			(PROCID) plrcommit0->le_procid,
	   			(USHORT) plrcommit0->levelCommitTo );
	   		strcat( szLR, rgchBuf );
			if ( plr->lrtyp == lrtypCommit0 )
				{
				sprintf( rgchBuf, " %lx", (TRX) plrcommit0->le_trxCommit0 );
				strcat( szLR, rgchBuf );
				}
			break;
			}

		case lrtypRollback:
			{
			LRROLLBACK *plrrollback = (LRROLLBACK *)plr;
			sprintf( rgchBuf, " (%x,%d)",
				(PROCID) plrrollback->le_procid,
				(USHORT) plrrollback->levelRollback );
			strcat( szLR, rgchBuf );
			break;
			}

#ifdef DTC
		case lrtypPrepCommit:
			{
			const LRPREPCOMMIT	* const plrprepcommit	= (LRPREPCOMMIT *)plr;

			sprintf( rgchBuf, " (%x)", (PROCID)plrprepcommit->le_procid );
			strcat( szLR, rgchBuf );

			DataToSz( plrprepcommit->rgbData, plrprepcommit->le_cbData, rgchBuf );
			strcat( szLR, rgchBuf );
			break;
			}

		case lrtypPrepRollback:
			{
			const LRPREPROLLBACK	* const plrpreprollback	= (LRPREPROLLBACK *)plr;

			sprintf( rgchBuf, " (%x)", (PROCID)plrpreprollback->le_procid );
			strcat( szLR, rgchBuf );
			break;			
			}
#endif	//	DTC

		case lrtypCreateDB:
			{
			LRCREATEDB *plrcreatedb = (LRCREATEDB *) plr;
			CHAR *sz;

			sz = (CHAR *)( plr ) + sizeof(LRCREATEDB);
			sprintf( rgchBuf, " (%x,%s,%u)", (PROCID)plrcreatedb->le_procid, sz, (USHORT) plrcreatedb->dbid );
			strcat( szLR, rgchBuf );

			if ( plrcreatedb->FCreateSLV() )
				{
				sz += strlen(sz) + 1;		//	SLV name follows db name
				sprintf( rgchBuf, " SLV: %s", sz );
				strcat( szLR, rgchBuf );

				sz += strlen(sz) + 1;
				sprintf( rgchBuf, " SLVRoot: %s", sz );
				strcat( szLR, rgchBuf );
				}
			else
				{
				sprintf( rgchBuf, " SLV: <none>" );
				strcat( szLR, rgchBuf );
				sprintf( rgchBuf, " SLVRoot: <none>" );
				strcat( szLR, rgchBuf );
				}

			sprintf( rgchBuf, " SLV Provider: %s", plrcreatedb->FSLVProviderNotEnabled() ? "NO" : "YES" );
			strcat( szLR, rgchBuf );

			sprintf( rgchBuf, " cpgMax: %lu Sig: ", (ULONG) plrcreatedb->le_cpgDatabaseSizeMax );
			strcat( szLR, rgchBuf );
			SPrintSign( &plrcreatedb->signDb, rgchBuf );
			strcat( szLR, rgchBuf );
			break;
			}

		case lrtypAttachDB:
			{
			LRATTACHDB *plrattachdb = (LRATTACHDB *) plr;
			CHAR *sz;

			sz = reinterpret_cast<CHAR *>( plrattachdb ) + sizeof(LRATTACHDB);
			sprintf( rgchBuf, " (%x,%s,%u)", (PROCID)plrattachdb->le_procid, sz, (USHORT) plrattachdb->dbid );
			strcat( szLR, rgchBuf );

			if ( plrattachdb->FSLVExists() )
				{
				sz += strlen(sz) + 1;		//	SLV name follows db name
				sprintf( rgchBuf, " SLV: %s", sz );
				strcat( szLR, rgchBuf );

				sz += strlen(sz) + 1;
				sprintf( rgchBuf, " SLVRoot: %s", sz );
				strcat( szLR, rgchBuf );
				}
			else
				{
				sprintf( rgchBuf, " SLV: <none>" );
				strcat( szLR, rgchBuf );
				sprintf( rgchBuf, " SLVRoot: <none>" );
				strcat( szLR, rgchBuf );
				}

			sprintf( rgchBuf, " SLV Provider: %s", plrattachdb->FSLVProviderNotEnabled() ? "NO" : "YES" );
			strcat( szLR, rgchBuf );

			sprintf( rgchBuf, " cpgMax: %u", plrattachdb->le_cpgDatabaseSizeMax );
			strcat( szLR, rgchBuf );
			sprintf( rgchBuf, " consistent:(%X,%X,%X)   SigDb: ",
				(short) plrattachdb->lgposConsistent.le_lGeneration,
				(short) plrattachdb->lgposConsistent.le_isec,
				(short) plrattachdb->lgposConsistent.le_ib );
			strcat( szLR, rgchBuf );
			SPrintSign( &plrattachdb->signDb, rgchBuf );
			strcat( szLR, rgchBuf );
			sprintf( rgchBuf, "   SigLog: " );
			strcat( szLR, rgchBuf );
			SPrintSign( &plrattachdb->signLog, rgchBuf );
			strcat( szLR, rgchBuf );
			break;
			}

		case lrtypDetachDB:
			{
			LRDETACHDB *plrdetachdb = (LRDETACHDB *) plr;
			CHAR *sz;

			sz = reinterpret_cast<CHAR *>( plrdetachdb ) + sizeof(LRDETACHDB);
			sprintf( rgchBuf, " (%x,%s,%u)", (PROCID)plrdetachdb->le_procid, sz, (USHORT) plrdetachdb->dbid );
			strcat( szLR, rgchBuf );
			break;
			}

		case lrtypForceDetachDB:
			{
			LRFORCEDETACHDB *plrfdetachdb = (LRFORCEDETACHDB *) plr;
			CHAR *sz;

			sz = reinterpret_cast<CHAR *>( plrfdetachdb ) + sizeof(LRFORCEDETACHDB);
			sprintf( rgchBuf, " (%x,%s,%u) %I64x, %lu", (PROCID)plrfdetachdb->le_procid, sz, (USHORT) plrfdetachdb->dbid, plrfdetachdb->le_dbtime, plrfdetachdb->le_rceidMax );
			strcat( szLR, rgchBuf );
			break;
			}

		case lrtypDbList:
			{
			LRDBLIST* const		plrdblist		= (LRDBLIST *)plr;

			if ( plog )
				{
				const ATTACHINFO*	pattachinfo		= NULL;
				const BYTE*			pbT				= plrdblist->rgb;
				
				DBGprintf( " %s Total Attachments: %d", SzLrtyp( lrtyp ), plrdblist->CAttachments() );
				while ( 0 != *pbT )
					{
					const ATTACHINFO* const		pattachinfo 	= (ATTACHINFO *)pbT;

					Assert( pbT - plrdblist->rgb < plrdblist->CbAttachInfo() );

					DBGprintf( "\n    %d %s",
						(DBID)pattachinfo->Dbid(),
						pattachinfo->szNames );		//	first name is DB name

					pbT += sizeof(ATTACHINFO) + pattachinfo->CbNames();
					}

				sprintf( szLR, "\n[End of DbList]" );
				}
			else
				{
				sprintf( rgchBuf, " Total Attachments: %d", plrdblist->CAttachments() );
				strcat( szLR, rgchBuf );
				}
			break;
			}

		case lrtypCreateMultipleExtentFDP:
			{
			LRCREATEMEFDP *plrcreatemefdp = (LRCREATEMEFDP *)plr;
			
			sprintf( rgchBuf, " %I64x,%lx:%u(%x,FDP:[%u:%lu],OE:[%u:%lu],AE:[%u:%lu],FDPParent:[%u:%lu],Objid:[%lu],PageFlags:[0x%lx],%lu,%s)",
				(DBTIME) plrcreatemefdp->le_dbtime,
				(TRX) plrcreatemefdp->le_trxBegin0,
				(USHORT) plrcreatemefdp->level,
				(PROCID) plrcreatemefdp->le_procid,
				(USHORT) plrcreatemefdp->dbid,
				(PGNO) plrcreatemefdp->le_pgno,
				(USHORT) plrcreatemefdp->dbid,
				(PGNO) plrcreatemefdp->le_pgnoOE,
				(USHORT) plrcreatemefdp->dbid,
				(PGNO) plrcreatemefdp->le_pgnoAE,
				(USHORT) plrcreatemefdp->dbid,
				(PGNO) plrcreatemefdp->le_pgnoFDPParent,
				(OBJID) plrcreatemefdp->le_objidFDP,
				(ULONG) plrcreatemefdp->le_fPageFlags,
				(ULONG) plrcreatemefdp->le_cpgPrimary,
				plrcreatemefdp->FUnique() ? szUnique : szNotUnique );
			strcat( szLR, rgchBuf );

			break;
			}

		case lrtypCreateSingleExtentFDP:
			{
			LRCREATESEFDP *plrcreatesefdp = (LRCREATESEFDP *)plr;
			
			sprintf( rgchBuf, " %I64x,%lx:%u(%x,[%u:%lu],[%u:%lu],[%lu],PageFlags:[0x%lx]%lu,%s)",
				(DBTIME) plrcreatesefdp->le_dbtime,
				(TRX) plrcreatesefdp->le_trxBegin0,
				(USHORT) plrcreatesefdp->level,
				(PROCID) plrcreatesefdp->le_procid,
				(USHORT) plrcreatesefdp->dbid,
				(PGNO) plrcreatesefdp->le_pgno,
				(USHORT) plrcreatesefdp->dbid,
				(PGNO) plrcreatesefdp->le_pgnoFDPParent,
				(OBJID) plrcreatesefdp->le_objidFDP,
				(ULONG) plrcreatesefdp->le_fPageFlags,
				(ULONG) plrcreatesefdp->le_cpgPrimary,
				plrcreatesefdp->FUnique() ? szUnique : szNotUnique );
			strcat( szLR, rgchBuf );

			break;
			}

		case lrtypConvertFDP:
			{
			LRCONVERTFDP *plrconvertfdp = (LRCONVERTFDP *)plr;
			
			sprintf( rgchBuf, " %I64x,%I64x,%lx:%u(%x,[%u:%lu],[%u:%lu],[%lu],%lu)",
				(DBTIME) plrconvertfdp->le_dbtime,
				(DBTIME) plrconvertfdp->le_dbtimeBefore,
				(TRX) plrconvertfdp->le_trxBegin0,
				(USHORT) plrconvertfdp->level,
				(PROCID) plrconvertfdp->le_procid,
				(USHORT) plrconvertfdp->dbid,
				(PGNO) plrconvertfdp->le_pgno,
				(USHORT) plrconvertfdp->dbid,
				(PGNO) plrconvertfdp->le_pgnoFDPParent,
				(OBJID) plrconvertfdp->le_objidFDP,
				(ULONG) plrconvertfdp->le_cpgPrimary);
			strcat( szLR, rgchBuf );

			break;
			}

		case lrtypSplit:
			{
			LRSPLIT *plrsplit = (LRSPLIT *)plr;

			if ( pgnoNull == plrsplit->le_pgnoNew )
				{
				Assert( 0 == plrsplit->le_cbKeyParent );
				Assert( 0 == plrsplit->le_cbPrefixSplitOld );
				Assert( 0 == plrsplit->le_cbPrefixSplitNew );
				sprintf( rgchBuf, "%s %I64x,%I64x,%lx:%u(%x,parent:%I64x,[%u:%lu])",
						" ParentOfSplitPage",
						(DBTIME) plrsplit->le_dbtime,
						(DBTIME) plrsplit->le_dbtimeBefore,
						(TRX) plrsplit->le_trxBegin0,
						(USHORT) plrsplit->level,
						(PROCID) plrsplit->le_procid,
						(DBTIME) plrsplit->le_dbtimeParentBefore,
						(USHORT) plrsplit->dbid,
						(PGNO) plrsplit->le_pgno );
				strcat( szLR, rgchBuf );
				}
			else
				{
				switch( plrsplit->splittype )
					{
					case splittypeRight:
						if ( splitoperInsert == plrsplit->splitoper
							&& plrsplit->le_ilineSplit == plrsplit->le_ilineOper
							&& plrsplit->le_ilineSplit == plrsplit->le_clines - 1 )
							{
							sprintf( rgchBuf, " SplitHotpoint" );
							}
						else
							{
							sprintf( rgchBuf, " SplitRight" );
							}
						break;
					case splittypeVertical:
						sprintf( rgchBuf, " SplitVertical" );
						break;
					case splittypeAppend:
						sprintf( rgchBuf, " Append" );
						break;
					default:
						Assert( fFalse );
					}
				strcat( szLR, rgchBuf );

				const CHAR *	szSplitoper[4]	= {	"None",
										   			"Insert",
													"Replace",
													"FlagInsertAndReplaceData" };

				// Verify valid splitoper
				switch( plrsplit->splitoper )
					{
					case splitoperNone:
					case splitoperInsert:
					case splitoperReplace:
					case splitoperFlagInsertAndReplaceData:
						break;
					default:
						Assert( fFalse );
					}

				sprintf( rgchBuf, " %I64x,%I64x,%lx:%u(%x,split:[%u:%lu:%u],oper/last:[%u/%u],new:[%u:%lu],parent:%I64x,[%u:%lu],right:%I64x,[%u:%lu], objid:[%lu], %s, splitoper:%s)",
						(DBTIME) plrsplit->le_dbtime,
						(DBTIME) plrsplit->le_dbtimeBefore,
						(TRX) plrsplit->le_trxBegin0,
						(USHORT) plrsplit->level,
						(PROCID) plrsplit->le_procid,
						(USHORT) plrsplit->dbid,
						(PGNO) plrsplit->le_pgno,
						(USHORT) plrsplit->le_ilineSplit,
						(USHORT) plrsplit->le_ilineOper,
						(USHORT) plrsplit->le_clines-1,		// convert to iline
						(USHORT) plrsplit->dbid,
						(PGNO) plrsplit->le_pgnoNew,
						(DBTIME) (pgnoNull != (PGNO) plrsplit->le_pgnoParent ? (DBTIME) plrsplit->le_dbtimeParentBefore: 0),
						(USHORT) plrsplit->dbid,
						(PGNO) plrsplit->le_pgnoParent,
						(DBTIME) (pgnoNull != (PGNO) plrsplit->le_pgnoRight ? (DBTIME) plrsplit->le_dbtimeRightBefore: 0),
						(USHORT) plrsplit->dbid,
						(PGNO) plrsplit->le_pgnoRight,
						(OBJID) plrsplit->le_objidFDP,
						plrsplit->FConcCI() ? szConcCI : szNotConcCI,
						szSplitoper[plrsplit->splitoper] );
				strcat( szLR, rgchBuf );
				}

			break;
			}


		case lrtypMerge:
			{
			LRMERGE *plrmerge = (LRMERGE *)plr;
			BYTE 	*pb = &(plrmerge->rgb[0]);
			INT		cb = plrmerge->le_cbKeyParentSep;

			sprintf( rgchBuf," %I64x,%I64x,%lx:%u(%x,merge:[%u:%lu:%u],right:%I64x,[%u:%lu],left:%I64x,[%u:%lu],parent:%I64x,[%u:%lu],%s:%s:%s:%s,size:%d,maxsize:%d,uncfree:%d)",
				(DBTIME) plrmerge->le_dbtime,
				(DBTIME) plrmerge->le_dbtimeBefore,
				(TRX) plrmerge->le_trxBegin0,
				(USHORT) plrmerge->level,
				(PROCID) plrmerge->le_procid,
				(USHORT) plrmerge->dbid,
				(PGNO) plrmerge->le_pgno,
				plrmerge->ILineMerge(),
				(DBTIME)  (pgnoNull != (PGNO) plrmerge->le_pgnoRight ? (DBTIME) plrmerge->le_dbtimeRightBefore: 0),
				(USHORT) plrmerge->dbid,
				(PGNO) plrmerge->le_pgnoRight,
				(DBTIME)  (pgnoNull != (PGNO) plrmerge->le_pgnoLeft ? (DBTIME) plrmerge->le_dbtimeLeftBefore: 0),
				(USHORT) plrmerge->dbid,
				(PGNO) plrmerge->le_pgnoLeft,
				(DBTIME)  (pgnoNull != (PGNO) plrmerge->le_pgnoParent ? (DBTIME) plrmerge->le_dbtimeParentBefore: 0),
				(USHORT) plrmerge->dbid,
				(PGNO) plrmerge->le_pgnoParent,
				plrmerge->FKeyChange() ? szKeyChange : szNoKeyChange,
				plrmerge->FEmptyPage() ? szEmptyPage : szNotEmptyPage,
				plrmerge->FDeleteNode() ? szDeleted : szNotDeleted,
				rgszMergeType[plrmerge->mergetype],
				(SHORT) plrmerge->le_cbSizeTotal,
				(SHORT) plrmerge->le_cbSizeMaxTotal,
				(SHORT) plrmerge->le_cbUncFreeDest );
			strcat( szLR, rgchBuf );

			DataToSz( pb, cb, rgchBuf );
			strcat( szLR, rgchBuf );

			break;
			}

		case lrtypEmptyTree:
			{
			LREMPTYTREE	*plremptytree	= (LREMPTYTREE *)plr;
			
			sprintf( rgchBuf, " %I64x,%I64x,%lx:%u(%x,[%u:%lu],objid:[%lu],%s,%s,%lu)",
				(DBTIME) plremptytree->le_dbtime,
				(DBTIME) plremptytree->le_dbtimeBefore,
				(TRX) plremptytree->le_trxBegin0,
				(USHORT) plremptytree->level,
				(PROCID) plremptytree->le_procid,
				(USHORT) plremptytree->dbid,
				(PGNO) plremptytree->le_pgno,
				plremptytree->le_objidFDP,
				plremptytree->FUnique() ? szUnique : szNotUnique,
				plremptytree->FSpace() ? szSpaceTree : szNotSpaceTree,
				plremptytree->CbEmptyPageList() );
			strcat( szLR, rgchBuf );

			DataToSz( plremptytree->rgb, plremptytree->CbEmptyPageList(), rgchBuf );
			strcat( szLR, rgchBuf );
			break;
			}

		case lrtypSetExternalHeader:
			{
			const LRSETEXTERNALHEADER * const 	plrsetexternalheader = (LRSETEXTERNALHEADER *)plr;
			const BYTE * const 					pb 	= plrsetexternalheader->rgbData;
			const INT 							cb	= plrsetexternalheader->CbData();
			sprintf( rgchBuf, " %I64x,%I64x,%lx:%u(%x,[%u:%lu],%5u)",
						(DBTIME) plrsetexternalheader->le_dbtime,
						(DBTIME) plrsetexternalheader->le_dbtimeBefore,
						(TRX) plrsetexternalheader->le_trxBegin0,
						(USHORT) plrsetexternalheader->level,
						(PROCID) plrsetexternalheader->le_procid,
						(USHORT) plrsetexternalheader->dbid,
						(PGNO) plrsetexternalheader->le_pgno,
						plrsetexternalheader->CbData() );
			strcat( szLR, rgchBuf );

			DataToSz( pb, cb, rgchBuf );
			strcat( szLR, rgchBuf );
			break;
			}

		case lrtypUndo:
			{
			LRUNDO *plrundo = (LRUNDO *)plr;
			sprintf( rgchBuf, " %I64x,%I64x,%lx:%u(%x,[%u:%lu:%u],%s,%u,%u,rceid:%u)",
				(DBTIME) plrundo->le_dbtime,
				(DBTIME) plrundo->le_dbtimeBefore,
				(TRX) plrundo->le_trxBegin0,
				(USHORT) plrundo->level,
				(PROCID) plrundo->le_procid,
				(USHORT) plrundo->dbid,
				(PGNO) plrundo->le_pgno,
				plrundo->ILine(),
				plrundo->FUnique() ? szVersion : szNoVersion,
				(USHORT) plrundo->level,
				(USHORT) plrundo->le_oper,
				(RCEID) plrundo->le_rceid );
			strcat( szLR, rgchBuf );
			break;
			}

		case lrtypInit:
		case lrtypInit2:
			{
			if ( lrtypInit2 == plr->lrtyp )
				{
				const LOGTIME &logtime = ((LRINIT2 *)plr)->logtime;
				sprintf( rgchBuf, " (%u/%u/%u %u:%02u:%02u)", 
					(INT) (logtime.bMonth),
					(INT) (logtime.bDay),
					(INT) (logtime.bYear+1900),
					(INT) (logtime.bHours),
					(INT) (logtime.bMinutes),
					(INT) (logtime.bSeconds) );
				strcat( szLR, rgchBuf );
				}
			DBMS_PARAM *pdbms_param = &((LRINIT2 *)plr)->dbms_param;
			sprintf( rgchBuf, "\n      Env SystemPath:%s\n",	pdbms_param->szSystemPath);
			strcat( szLR, rgchBuf );
			sprintf( rgchBuf, "      Env LogFilePath:%s\n", pdbms_param->szLogFilePath);
			strcat( szLR, rgchBuf );
			sprintf( rgchBuf, "      Env (CircLog,Session,Opentbl,VerPage,Cursors,LogBufs,LogFile,Buffers)\n");
			strcat( szLR, rgchBuf );
			sprintf( rgchBuf, "          (%s,%7lu,%7lu,%7lu,%7lu,%7lu,%7lu,%7lu)\n",
				( pdbms_param->fDBMSPARAMFlags & fDBMSPARAMCircularLogging ? "     on" : "    off" ),
				(ULONG) pdbms_param->le_lSessionsMax,
				(ULONG) pdbms_param->le_lOpenTablesMax,
				(ULONG) pdbms_param->le_lVerPagesMax,
				(ULONG) pdbms_param->le_lCursorsMax,
				(ULONG) pdbms_param->le_lLogBuffers,
				(ULONG) pdbms_param->le_lcsecLGFile,
				(ULONG) pdbms_param->le_ulCacheSizeMax );
			strcat( szLR, rgchBuf );
			}
			break;
			
		case lrtypTerm:
		case lrtypShutDownMark:
		case lrtypRecoveryUndo:
			break;
		case lrtypTerm2:
			{
			const LOGTIME &logtime = ((LRTERMREC2 *)plr)->logtime;
			sprintf( rgchBuf, " (%u/%u/%u %u:%02u:%02u)", 
				(INT) (logtime.bMonth),
				(INT) (logtime.bDay),
				(INT) (logtime.bYear+1900),
				(INT) (logtime.bHours),
				(INT) (logtime.bMinutes),
				(INT) (logtime.bSeconds) );
			strcat( szLR, rgchBuf );
			}
			break;
			
		case lrtypRecoveryUndo2:
			{
			const LOGTIME &logtime = ((LRRECOVERYUNDO2 *)plr)->logtime;
			sprintf( rgchBuf, " (%u/%u/%u %u:%02u:%02u)", 
				(INT) (logtime.bMonth),
				(INT) (logtime.bDay),
				(INT) (logtime.bYear+1900),
				(INT) (logtime.bHours),
				(INT) (logtime.bMinutes),
				(INT) (logtime.bSeconds) );
			strcat( szLR, rgchBuf );
			}
			break;
			
		case lrtypRecoveryQuit:
		case lrtypRecoveryQuit2:
			{
			LRTERMREC2 *plrquit = (LRTERMREC2 *) plr;

			if ( lrtypRecoveryQuit2 == plr->lrtyp )
				{
				const LOGTIME &logtime = plrquit->logtime;
				sprintf( rgchBuf, " (%u/%u/%u %u:%02u:%02u)", 
					(INT) (logtime.bMonth),
					(INT) (logtime.bDay),
					(INT) (logtime.bYear+1900),
					(INT) (logtime.bHours),
					(INT) (logtime.bMinutes),
					(INT) (logtime.bSeconds) );
				strcat( szLR, rgchBuf );
				}
			if ( plrquit->fHard )
				{
				sprintf( rgchBuf, "\n      Quit on Hard Restore." );
				strcat( szLR, rgchBuf );
				}
			else
				{
				sprintf( rgchBuf, "\n      Quit on Soft Restore." );
				strcat( szLR, rgchBuf );
				}
			
			sprintf( rgchBuf, "\n      RedoFrom:(%X,%X,%X)\n",
				(short) plrquit->lgposRedoFrom.le_lGeneration,
				(short) plrquit->lgposRedoFrom.le_isec,
				(short) plrquit->lgposRedoFrom.le_ib );
			strcat( szLR, rgchBuf );
					
			sprintf( rgchBuf, "      UndoRecordFrom:(%X,%X,%X)\n",
  				(short) plrquit->lgpos.le_lGeneration,
				(short) plrquit->lgpos.le_isec,
				(short) plrquit->lgpos.le_ib );
			strcat( szLR, rgchBuf );
			}
			break;
			
		case lrtypFullBackup:
		case lrtypIncBackup:
			{
			LRLOGRESTORE *plrlr = (LRLOGRESTORE *) plr;

		   	if ( plrlr->le_cbPath )
				{
				sprintf( rgchBuf, "%*s", plrlr->le_cbPath, plrlr->szData );
				strcat( szLR, rgchBuf );
				}
			break;
			}
			
		case lrtypBackup:
			{
			LRLOGBACKUP *plrlb = (LRLOGBACKUP *) plr;
			
			if ( plrlb->FFull() )
				{
				strcat( szLR, "FullBackup" );
				}
			else if ( plrlb->FIncremental() )
				{
				strcat( szLR, "IncrementalBackup" );
				}
			else if ( plrlb->FSnapshotStart() )
				{
				strcat( szLR, "StartSnapshot" );
				}
			else if ( plrlb->FSnapshotStop() )
				{
				strcat( szLR, "StopSnapshot" );
				}
			else
				{
				Assert ( fFalse );
				}
			
		   	if ( plrlb->le_cbPath )
				{
				sprintf( rgchBuf, " %*s", plrlb->le_cbPath, plrlb->szData );
				strcat( szLR, rgchBuf );
				}
			break;
			}

		case lrtypTrace:
			{
			LRTRACE *plrtrace = (LRTRACE *)plr;
			char szFormat[255];
			sprintf( szFormat, " (%%x) %%%lds", plrtrace->le_cb );
	   		sprintf( rgchBuf, szFormat,	(PROCID) plrtrace->le_procid, plrtrace->sz );
			strcat( szLR, rgchBuf );
			break;
			}

		case lrtypSLVPageAppend:
			{
			LRSLVPAGEAPPEND*	plrSLVPageAppend = (LRSLVPAGEAPPEND *)plr;
			BYTE* 				pb;
			ULONG				cb;

			pb = (BYTE*) plr + sizeof( LRSLVPAGEAPPEND );
			cb = plrSLVPageAppend->le_cbData;

			sprintf( rgchBuf, " (%x,dbid:%u,ibLogical:0x%I64x,page:%lu,size:%lu,%s) [%s]",
					(PROCID) plrSLVPageAppend->le_procid,
					(USHORT) plrSLVPageAppend->dbid,
					(QWORD) plrSLVPageAppend->le_ibLogical,
					PGNO( ( plrSLVPageAppend->le_ibLogical / g_cbPage ) - cpgDBReserved + 1 ),
					(ULONG) plrSLVPageAppend->le_cbData,
					plrSLVPageAppend->FDataLogged() ? szData : szNoData,
					plrSLVPageAppend->FOLDSLV() ? szMovedByOLDSLV : szNotMovedByOLDSLV );
					
			strcat( szLR, rgchBuf );

			if ( plrSLVPageAppend->FDataLogged() )
				{
				DataToSz( pb, cb, rgchBuf );
				strcat( szLR, rgchBuf );
				}
			break;
			}

		case lrtypSLVPageMove:
			{
			LRSLVPAGEMOVE*	plrSLVPageMove = (LRSLVPAGEMOVE *)plr;

			sprintf( rgchBuf, " (%x,dbid:%u,ibLogicalSrc:%I64u,ibLogicalDest:%I64u,size:%lu,checksum:0x%X) ",
					(PROCID) plrSLVPageMove->le_procid,
					(USHORT) plrSLVPageMove->dbid,
					(QWORD) plrSLVPageMove->le_ibLogicalSrc,
					(QWORD) plrSLVPageMove->le_ibLogicalDest,
					(ULONG) plrSLVPageMove->le_cbData,
					(ULONG) plrSLVPageMove->le_checksumSrc );
					
			strcat( szLR, rgchBuf );
			break;
			}

		case lrtypSLVSpace:
			{
			const CHAR			* szOper			= "UNKNOWN";
			const LRSLVSPACE	* const plrSLVSpace = (LRSLVSPACE *)plr;
			const BYTE			* const pb			= (BYTE *)plr + sizeof(LRSLVSPACE);
			const ULONG			cb					= plrSLVSpace->le_cbBookmarkKey;

			PGNO				pgnoLast;
			LongFromKey( &pgnoLast, plrSLVSpace->rgbData );
			Assert( 0 == ( pgnoLast % SLVSPACENODE::cpageMap ) );
			const PGNO			pgnoFirst			= pgnoLast - SLVSPACENODE::cpageMap + 1;

			switch( plrSLVSpace->oper )
				{
				case slvspaceoperInvalid:
					szOper = "Invalid";
					break;
				case slvspaceoperFreeToReserved:
					szOper = "FreeToReserved";
					break;
				case slvspaceoperReservedToCommitted:
					szOper = "ReservedToCommitted";
					break;
				case slvspaceoperFreeToCommitted:
					szOper = "FreeToCommitted";
					break;
				case slvspaceoperCommittedToDeleted:
					szOper = "CommittedToDeleted";
					break;
				case slvspaceoperDeletedToFree:
					szOper = "DeletedToFree";
					break;
				case slvspaceoperFree:	
					szOper = "Free";
					break;
				case slvspaceoperFreeReserved:
					szOper = "FreeReserved";
					break;
				case slvspaceoperDeletedToCommitted:
					szOper = "DeletedToCommitted";
					break;
 				default:
					szOper = "UNKNOWN";
					break;
				}
				
			sprintf( rgchBuf, " %I64x,%I64x,%lx:%u(%x,[%u:%lu:%u],%s:%s,%s(%d),%d-%d,rceid:%lu,objid:%lu)",
				(DBTIME) plrSLVSpace->le_dbtime,
				(DBTIME) plrSLVSpace->le_dbtimeBefore,
				(TRX) plrSLVSpace->le_trxBegin0,
				(USHORT) plrSLVSpace->level,
				(PROCID) plrSLVSpace->le_procid,
				(USHORT) plrSLVSpace->dbid,
				(PGNO) plrSLVSpace->le_pgno,
				plrSLVSpace->ILine(),
				plrSLVSpace->FVersioned() ? szVersion : szNoVersion,
				plrSLVSpace->FConcCI() ? szConcCI : szNotConcCI,
				szOper,
				plrSLVSpace->oper,
				pgnoFirst + plrSLVSpace->le_ipage,
				pgnoFirst + plrSLVSpace->le_ipage + plrSLVSpace->le_cpages - 1,
				plrSLVSpace->le_rceid,
				plrSLVSpace->le_objidFDP );
					
			strcat( szLR, rgchBuf );
			DataToSz( pb, cb, rgchBuf );
			strcat( szLR, rgchBuf );
			break;
			}

		case lrtypChecksum:
			{
			const LRCHECKSUM * const plrck = static_cast< const LRCHECKSUM* const >( plr );

			Assert( plrck->bUseShortChecksum == bShortChecksumOn ||
					plrck->bUseShortChecksum == bShortChecksumOff );

			if ( plrck->bUseShortChecksum == bShortChecksumOn )
				{
				sprintf( rgchBuf, " (0x%X,0x%X,0x%X checksum [0x%X,0x%X])",
					plrck->le_cbBackwards,
					plrck->le_cbForwards,
					plrck->le_cbNext,
					plrck->le_ulChecksum,
					plrck->le_ulShortChecksum );
				}
			else if ( plrck->bUseShortChecksum == bShortChecksumOff )
				{
				sprintf( rgchBuf, " (0x%X,0x%X,0x%X checksum [0x%X])",
					plrck->le_cbBackwards,
					plrck->le_cbForwards,
					plrck->le_cbNext,
					plrck->le_ulChecksum );
				}
			else
				{
				sprintf( rgchBuf, " CORRUPT (0x%X,0x%X,0x%X checksum 0x%X short checksum 0x%X use short checksum 0x%X)",
					plrck->le_cbBackwards,
					plrck->le_cbForwards,
					plrck->le_cbNext,
					plrck->le_ulChecksum,
					plrck->le_ulShortChecksum,
					plrck->bUseShortChecksum );
				}
			strcat( szLR, rgchBuf );
			break;
			}

		case lrtypExtRestore:
			{
			LREXTRESTORE *plrextrestore = (LREXTRESTORE *) plr;
			CHAR *sz;

			sz = reinterpret_cast<CHAR *>( plrextrestore ) + sizeof(LREXTRESTORE);
			sprintf( rgchBuf, " (%s,%s)", sz, sz + strlen(sz) + 1 );
			strcat( szLR, rgchBuf );
			break;
			}

		default:
			{
			Assert( fFalse );
			break;
			}
		}
	}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ese98\src\ese\mem.cxx ===
#include "std.hxx"


// PRIVATE:
const ULONG			MEMPOOL::cbChunkSize		= 256;		// If out of buffer space, increase by this many bytes.
const USHORT		MEMPOOL::ctagChunkSize		= 4;		// If out of tag space, increase by this many tags.
const USHORT		MEMPOOL::cMaxEntries		= 0xfff0;	// maximum number of tags
const MEMPOOL::ITAG	MEMPOOL::itagTagArray		= 0;		// itag 0 is reserved for the itag array itself
const MEMPOOL::ITAG	MEMPOOL::itagFirstUsable	= 1;		// First itag available for users


INLINE BOOL MEMPOOL::FResizeBuf( ULONG cbNewBufSize )
	{
	BYTE 		*pbuf;

	// Ensure we're not cropping off used space.
	Assert( IbBufFree() <= CbBufSize() );
	Assert( cbNewBufSize >= IbBufFree() );

	pbuf = (BYTE *)PvOSMemoryHeapAlloc( cbNewBufSize );
	if ( pbuf == NULL )
		return fFalse;

	// Copy the old buffer contents to the new, then delete the old buffer.
	UtilMemCpy( pbuf, Pbuf(), IbBufFree() );
	OSMemoryHeapFree( Pbuf() );
				
	// Buffer has relocated.
	SetPbuf( pbuf );
	SetCbBufSize( cbNewBufSize );

	return fTrue;
	}


INLINE BOOL MEMPOOL::FGrowBuf( ULONG cbNeeded )
	{
	return FResizeBuf( CbBufSize() + cbNeeded + cbChunkSize );
	}


INLINE ERR MEMPOOL::ErrGrowEntry( ITAG itag, ULONG cbNew )
	{
	MEMPOOLTAG	*rgbTags = (MEMPOOLTAG *)Pbuf();
	ITAG		itagCurrent;

	Assert( itag >= itagFirstUsable || itag == itagTagArray );

	//  get current tag

	const ULONG ibEntry	= rgbTags[itag].ib;
	const ULONG cbOld	= rgbTags[itag].cb;

	//  we had better be growing this tag

	Assert( cbNew > cbOld );

	//  align cbOld and cbNew

	ULONG cbOldAlign = cbOld + sizeof( QWORD ) - 1;
	cbOldAlign -= cbOldAlign % sizeof( QWORD );
	ULONG cbNewAlign = cbNew + sizeof( QWORD ) - 1;
	cbNewAlign -= cbNewAlign % sizeof( QWORD );

	//  compute the additional space that we will need

	const ULONG cbAdditional = cbNewAlign - cbOldAlign;

	// First ensure that we have enough buffer space to allow the entry
	// to enlarge.
	
	if ( CbBufSize() - IbBufFree() < cbAdditional )
		{
		if ( !FGrowBuf( cbAdditional - ( CbBufSize() - IbBufFree() ) ) )
			return ErrERRCheck( JET_errOutOfMemory );

		// Buffer likely relocated, so refresh.
		rgbTags = (MEMPOOLTAG *)Pbuf();
		}

	Assert( ( ibEntry + cbOld ) <= IbBufFree() );
	Assert( ( ibEntry + cbNew ) <= CbBufSize() );
	memmove( Pbuf() + ibEntry + cbNewAlign, Pbuf() + ibEntry + cbOldAlign, IbBufFree() - ( ibEntry + cbOldAlign ) );

	SetIbBufFree( IbBufFree() + cbAdditional );
	Assert( IbBufFree() <= CbBufSize() );

	// Fix up the tag array to match the byte movement of the buffer.
	for ( itagCurrent = itagFirstUsable; itagCurrent < ItagUnused(); itagCurrent++ )
		{
		// Ignore itags on the freed list.  Also ignore buffer space that occurs
		// before the space to be enlarged.
		if ( rgbTags[itagCurrent].cb > 0  &&  rgbTags[itagCurrent].ib > ibEntry )
			{
			Assert( rgbTags[itagCurrent].ib >= ibEntry + cbOldAlign );
			rgbTags[itagCurrent].ib += cbAdditional;
			Assert( rgbTags[itagCurrent].ib + rgbTags[itagCurrent].cb <= IbBufFree() );
			}
		}
	Assert( itagCurrent == ItagUnused() );

	// Update byte count.

	rgbTags[itag].cb = cbNew;

	return JET_errSuccess;
	}


INLINE VOID MEMPOOL::ShrinkEntry( ITAG itag, ULONG cbNew )
	{
	BYTE		*pbuf = Pbuf();
	MEMPOOLTAG	*rgbTags = (MEMPOOLTAG *)pbuf;
	ITAG		itagCurrent;

	Assert( itag >= itagFirstUsable );
	Assert( cbNew < rgbTags[itag].cb );

	//  get current tag

	const ULONG ibEntry	= rgbTags[itag].ib;
	const ULONG cbOld	= rgbTags[itag].cb;

	//  we had better be shrinking this tag

	Assert( cbNew < cbOld );

	//  align cbOld and cbNew

	ULONG cbOldAlign = cbOld + sizeof( QWORD ) - 1;
	cbOldAlign -= cbOldAlign % sizeof( QWORD );
	ULONG cbNewAlign = cbNew + sizeof( QWORD ) - 1;
	cbNewAlign -= cbNewAlign % sizeof( QWORD );

	//  compute the new ending offset and the space to delete

	const ULONG ibNewEnd = ibEntry + cbNewAlign;
	const ULONG cbDelete = cbOldAlign - cbNewAlign;

	// Remove the entry to be deleted by collapsing the buffer over
	// the space occupied by that entry.
	
	Assert( ibNewEnd > 0 );
	Assert( ibNewEnd >= rgbTags[itagTagArray].ib + rgbTags[itagTagArray].cb );
	Assert( ( ibNewEnd + cbDelete ) <= IbBufFree() );

	memmove( pbuf + ibNewEnd, pbuf + ibNewEnd + cbDelete, IbBufFree() - ( ibNewEnd + cbDelete ) );

	SetIbBufFree( IbBufFree() - cbDelete );
	Assert( IbBufFree() > 0 );
	Assert( IbBufFree() >= rgbTags[itagTagArray].ib + rgbTags[itagTagArray].cb );

	// Fix up the tag array to match the byte movement of the buffer.
	for ( itagCurrent = itagFirstUsable; itagCurrent < ItagUnused(); itagCurrent++ )
		{
		Assert( rgbTags[itagCurrent].ib != ibNewEnd  ||
			( itagCurrent == itag  &&  cbNew == 0 ) );

		// Ignore itags on the freed list.  Also ignore buffer space that occurs
		// before the space to be deleted.
		if ( rgbTags[itagCurrent].cb > 0  &&  rgbTags[itagCurrent].ib > ibNewEnd )
			{
			Assert( rgbTags[itagCurrent].ib >= ibNewEnd + cbDelete );
			rgbTags[itagCurrent].ib -= cbDelete;
			Assert( rgbTags[itagCurrent].ib >= ibNewEnd );
			Assert( rgbTags[itagCurrent].ib + rgbTags[itagCurrent].cb <= IbBufFree() );
			}
		}
	Assert( itagCurrent == ItagUnused() );

	rgbTags[itag].cb = cbNew;
	}


ERR MEMPOOL::ErrMEMPOOLInit(
	ULONG		cbInitialSize,
	USHORT		cInitialEntries,
	BOOL		fPadding )			// Pass TRUE if additional insertions will occur
	{
	MEMPOOLTAG	*rgbTags;
	BYTE		*pbuf;

	if ( cInitialEntries >= cMaxEntries )
		return ErrERRCheck( JET_errTooManyMempoolEntries );
		
	cInitialEntries++;			// Add one for the tag array itself

	if ( fPadding )
		{
		Assert ( cMaxEntries > ctagChunkSize );
		if ( cInitialEntries > cMaxEntries - ctagChunkSize )
			{
			fPadding = fFalse;
			}
		else
			{
			cInitialEntries += ctagChunkSize;
			}
		}
	
	Assert( cInitialEntries >= 1 );
	
	if ( cInitialEntries > cMaxEntries )
		return ErrERRCheck( JET_errTooManyMempoolEntries );

	ULONG cbTagArray		= cInitialEntries * sizeof( MEMPOOLTAG );
	ULONG cbTagArrayAlign	= cbTagArray + sizeof( QWORD ) - 1;
	cbTagArrayAlign			-= cbTagArrayAlign % sizeof( QWORD );

	if ( fPadding )
		{
		cbInitialSize += cbChunkSize;
		Assert( cbInitialSize > cbChunkSize );			// Overflow check
		}
		
	cbInitialSize += cbTagArrayAlign;
	Assert( cbInitialSize >= sizeof(MEMPOOLTAG) );		// At least one tag.
	Assert( cbInitialSize >= cbTagArrayAlign );			// Overflow check

	pbuf = (BYTE *)PvOSMemoryHeapAlloc( cbInitialSize );
	if ( pbuf == NULL )
		return ErrERRCheck( JET_errOutOfMemory );

	rgbTags = (MEMPOOLTAG *)pbuf;
	rgbTags[itagTagArray].ib = 0;		// tag array starts at beginning of memory
	rgbTags[itagTagArray].cb = cbTagArray;

	Assert( cbTagArrayAlign <= cbInitialSize );

	SetCbBufSize( cbInitialSize );
	SetIbBufFree( cbTagArrayAlign );
	SetItagUnused( itagFirstUsable );
	SetItagFreed( itagFirstUsable );
	SetPbuf( pbuf );
	
	return JET_errSuccess;
	}


// Add some bytes to the buffer and return an itag to its entry.
ERR MEMPOOL::ErrAddEntry( BYTE *rgb, ULONG cb, ITAG *piTag )
	{
	MEMPOOLTAG	*rgbTags;
	ULONG		cTotalTags;

	Assert( cb > 0 );
	Assert( piTag );

	AssertValid();					// Validate integrity of string buffer.
	rgbTags = (MEMPOOLTAG *)Pbuf();
	cTotalTags = rgbTags[itagTagArray].cb / sizeof(MEMPOOLTAG);

	// Check for tag space.
	if ( ItagFreed() < ItagUnused() )
		{
		// Re-use a freed iTag.
		*piTag = ItagFreed();
		Assert( rgbTags[ItagFreed()].cb == 0 );
		Assert( rgbTags[ItagFreed()].ib >= itagFirstUsable );

		//	The tag entry of the freed tag will point to the next freed tag.
		SetItagFreed( (ITAG)rgbTags[ItagFreed()].ib );
		Assert( rgbTags[ItagFreed()].cb == 0 || ItagFreed() == ItagUnused() );
		}

	else 
		{
		// No freed tags to re-use, so get the next unused tag.
		Assert( ItagFreed() == ItagUnused() );

		if ( ItagUnused() == cTotalTags )
			{
			ERR err;

			if ( cTotalTags + ctagChunkSize > cMaxEntries )
				return ErrERRCheck( JET_errOutOfMemory );

			// Tags all used up.  Allocate a new block of tags.
			err = ErrGrowEntry(
				itagTagArray,
				rgbTags[itagTagArray].cb + ( ctagChunkSize * sizeof(MEMPOOLTAG) ) );
			if ( err != JET_errSuccess )
				{
				Assert( err == JET_errOutOfMemory );
				return err;
				}

			cTotalTags += ctagChunkSize;
			
			rgbTags = (MEMPOOLTAG *)Pbuf();		// In case buffer relocated to accommodate growth.
			Assert( rgbTags[itagTagArray].cb == cTotalTags * sizeof(MEMPOOLTAG) );
			}

		*piTag = ItagUnused();
		SetItagFreed( ITAG( ItagFreed() + 1 ) );
		SetItagUnused( ITAG( ItagUnused() + 1 ) );
		}

	Assert( ItagFreed() <= ItagUnused() );
	Assert( ItagUnused() <= cTotalTags );

	//  init the tag to be zero sized at the end of the used buffer

	rgbTags[*piTag].ib = IbBufFree();
	rgbTags[*piTag].cb = 0;

	//  try to grow the tag to the requested size

	ERR err = ErrGrowEntry( *piTag, cb );
	rgbTags = (MEMPOOLTAG *)Pbuf();		// In case buffer relocated to accommodate growth.

	//  if we failed to grow the tag, return it to the freed list

	if ( err < JET_errSuccess )
		{
		Assert( err == JET_errOutOfMemory );
		
		Assert( rgbTags[*piTag].cb == 0 );
		rgbTags[*piTag].ib = ItagFreed();
		SetItagFreed( *piTag );
		*piTag = 0;
	
		return ErrERRCheck( JET_errOutOfMemory );
		}

	// If user passed in info, copy it to the buffer space allocated.
	// Otherwise, zero out the space allocated.
	
	if ( rgb )
		{
		UtilMemCpy( Pbuf() + rgbTags[*piTag].ib, rgb, cb );
		}
	else
		{
		memset( Pbuf() + rgbTags[*piTag].ib, 0, cb );
		}
	
	return JET_errSuccess;	
	}


VOID MEMPOOL::DeleteEntry( ITAG itag )
	{
	MEMPOOLTAG	*rgbTags;

	AssertValid();					// Validate integrity of buffer.

	rgbTags = (MEMPOOLTAG *)Pbuf();

	// We should not have already freed this entry.
	Assert( itag >= itagFirstUsable );
	Assert( itag < ItagUnused() );
	Assert( itag != ItagFreed() );

	// Remove the space dedicated to the entry to be deleted.
	Assert( rgbTags[itag].cb > 0 );			// Make sure it's not currently on the freed list.
	ShrinkEntry( itag, 0 );

	// Add the tag of the deleted entry to the list of freed tags.
	Assert( rgbTags[itag].cb == 0 );
	rgbTags[itag].ib = ItagFreed();
	SetItagFreed( itag );
	}


// If rgb==NULL, then just resize the entry (ie. don't replace the contents).
ERR MEMPOOL::ErrReplaceEntry( ITAG itag, BYTE *rgb, ULONG cb )
	{
	ERR			err = JET_errSuccess;
	MEMPOOLTAG	*rgbTags;

	// If replacing to 0 bytes, use DeleteEntry() instead.
	Assert( cb > 0 );

	AssertValid();					// Validate integrity of buffer.
	Assert( itag >= itagFirstUsable );
	Assert( itag < ItagUnused() );

	rgbTags = (MEMPOOLTAG *)Pbuf();

	Assert( rgbTags[itag].cb > 0 );
	Assert( rgbTags[itag].ib + rgbTags[itag].cb <= IbBufFree() );

	if ( cb < rgbTags[itag].cb )
		{
		// The new entry is smaller than the old entry.  Remove leftover space.
		ShrinkEntry( itag, cb );
		}
	else if ( cb > rgbTags[itag].cb )
		{
		// The new entry is larger than the old entry, so enlargen the
		// entry before writing to it.
		err = ErrGrowEntry( itag, cb );
		rgbTags = (MEMPOOLTAG *)Pbuf();		// In case buffer relocated to accommodate growth.
		}

	if ( JET_errSuccess == err && rgb != NULL )
		{
		// Overwrite the old entry with the new one.
		UtilMemCpy( Pbuf() + rgbTags[itag].ib, rgb, cb );
		}

	return err;
	}


BOOL MEMPOOL::FCompact()
	{
	AssertValid();				// Validate integrity of buffer.

	// Compact only if there's excessive unused space.
	BOOL	fCompactNeeded = ( CbBufSize() - IbBufFree() > 32 );
	return ( fCompactNeeded ? FResizeBuf( IbBufFree() ) : fTrue );
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ese98\src\ese\lv.cxx ===
/*******************************************************************

Long Values are stored in a per-table B-Tree. Each long value has 
a first node that contains the refcount and size of the long value
-- an LVROOT struct. The key of this node is the LID. Further nodes
have a key of LID:OFFSET (a LVKEY struct). The offset starts at 1
These values are big endian on disk.

OPTIMIZATION:  consider a critical section in each FCB for LV access
OPTIMIZATION:  don't store the longIdMax in the TDB. Seek to the end of
               the table, write latch the page and get the last id.

*******************************************************************/


#include "std.hxx"


//  ****************************************************************
//  MACROS
//  ****************************************************************

#ifdef DEBUG

//	DEBUG_LV:  this walks the long value tree at the top of RECAOSeparateLV
///#define DEBUG_LV

#endif	//	DEBUG


//  ****************************************************************
//  GLOBALS
//  ****************************************************************

//  OPTIMIZATION:  replace this with a pool of critical sections. hash on pgnoFDP
// LOCAL CCriticalSection critLV( CLockBasicInfo( CSyncBasicInfo( szLVCreate ), rankLVCreate, 0 ) );
// LOCAL PIB * ppibLV;


//  ****************************************************************
//  CONSTANTS
//  ****************************************************************

const ULONG ulLVOffsetFirst = 0;
const LID	lidMin			= 0;

//  ****************************************************************
//  INTERNAL FUNCTIONS
//  ****************************************************************


//  ****************************************************************
//  STRUCTURES
//  ****************************************************************


//  ================================================================
PERSISTED
struct LVKEY
//  ================================================================
//
// 	the nodes in the Long Value tree use a longID and an offset as
//  keys. we must have the lid first as this is all we store for LVROOTs
//
//-
	{
	UnalignedBigEndian< LID >		lid;
	UnalignedBigEndian< ULONG >		offset;
	};


//  ================================================================
INLINE LVKEY LVKeyFromLidOffset( LID lid, ULONG ulOffset )
//  ================================================================
	{
	Assert( lid > lidMin );
	LVKEY lvkey;
	lvkey.lid = lid;
	lvkey.offset = ulOffset;
	return lvkey;
	}


//  ================================================================
VOID OffsetFromKey( ULONG * pulOffset, const KEY& key )
//  ================================================================
	{
	Assert( sizeof( LVKEY ) == key.Cb() );
	Assert( pulOffset );

	LVKEY lvkey;
	key.CopyIntoBuffer( &lvkey );
	*pulOffset = lvkey.offset;
	}


//  ================================================================
INLINE VOID LidFromKey( LID * plid, const KEY& key )
//  ================================================================
	{
	Assert( sizeof( LVKEY ) == key.Cb() || sizeof( LID ) == key.Cb() );
	Assert( plid );

	LVKEY lvkey;
	key.CopyIntoBuffer( &lvkey );
	*plid = lvkey.lid;
	Assert( *plid > lidMin );
	}


//  ================================================================
VOID LidOffsetFromKey( LID * plid, ULONG * pulOffset, const KEY& key )
//  ================================================================
	{
	Assert( sizeof( LVKEY ) == key.Cb() );
	Assert( plid );
	Assert( pulOffset );

	LidFromKey( plid, key );
	OffsetFromKey( pulOffset, key );
	Assert( *pulOffset % g_cbColumnLVChunkMost == 0 );
	}



#ifdef LV_MERGE_BUG

LOCAL VOID LVICheckLVPage( FUCB *pfucb, CSR *pcsr, LID *plidOrphan )
	{
	const LID	lidOrphan		= *plidOrphan;
	LID			lidPrev			= lidMin;
	ULONG		ulOffsetPrev	= 0;
	BOOL		fLastSawRoot	= fFalse;
	BOOL		fLastSawData	= fFalse;
	ULONG		iline;
	const ULONG	clines			= pcsr->Cpage().Clines();

	Assert( pcsr->FLatched() );

	//	reset return value
	*plidOrphan = lidMin;
	
	for ( iline = 0; iline < clines; iline++ )
		{
		LID		lidT;
		ULONG	ulOffsetT;
		
		pcsr->ILine() = iline;
		NDGet( pfucb, pcsr );

		if ( FNDDeleted( pfucb->kdfCurr ) )
			continue;

		if ( sizeof(LID) == pfucb->kdfCurr.key.Cb() )
			{
			Enforce( sizeof(LVROOT) == pfucb->kdfCurr.data.Cb() );

			LidFromKey( &lidT, pfucb->kdfCurr.key );

			//	LIDs are monotonically increasing
			Enforce( lidPrev < lidT )

			//	assert below is invalid, because we can actually get two
			//	straight LVROOTs if two threads are inserting LV's simultaneously
			///	Assert( !fLastSawRoot );

			lidPrev = lidT;
			ulOffsetPrev = 0;
			fLastSawRoot = fTrue;
			fLastSawData = fFalse;
			}
			
		else if ( sizeof(LVKEY) == pfucb->kdfCurr.key.Cb() )
			{
			LidOffsetFromKey( &lidT, &ulOffsetT, pfucb->kdfCurr.key );
			if ( fLastSawRoot )
				{
				//	lid doesn't match root, or not first data node
				Enforce( lidT == lidPrev );
				Enforce( 0 == ulOffsetT );
				}
			else if ( fLastSawData )
				{
				//	lid doesn't match previous node, or offset not in line with offset of previous node
				Enforce( lidT == lidPrev );
				Enforce( ulOffsetT == ulOffsetPrev + g_cbColumnLVChunkMost );
				}
			else
				{
				Enforce( 0 == iline );

				//	LVROOT must be on previous page
				*plidOrphan = lidT;
				}

			lidPrev = lidT;
			ulOffsetPrev = ulOffsetT;
			fLastSawRoot = fFalse;
			fLastSawData = fTrue;
			}
		else
			{
			//	invalid key size
			EnforceSz( fFalse, "LV node has invalid key size" );
			}
		}

	if ( lidOrphan > lidMin && lidOrphan != lidPrev )
		{
		//	the next page had an orphan, so the last lid we encounter on this page should
		//	match the orphan
		Enforce( fFalse );
		}
	}

//	copied from FBTIUpdatablePage() (because that function is only
//	exposed in _bt.hxx)
INLINE BOOL	FLVIUpdatablePage( CSR *pcsr ) 
	{
	LOG *plog = PinstFromIfmp( pcsr->Cpage().Ifmp() )->m_plog;
	
	Assert( ( plog->m_fRecovering && latchRIW == pcsr->Latch() )
		|| latchWrite == pcsr->Latch() );
	
	return !plog->m_fRecovering || latchWrite == pcsr->Latch();
	}

VOID LVICheckLVMerge( FUCB *pfucb, MERGEPATH *pmergePath )
	{
	CSR			*pcsr			= &pmergePath->csr;
	CSR			*pcsrRight		= &pmergePath->pmerge->csrRight;
	CSR			*pcsrLeft		= &pmergePath->pmerge->csrLeft;
	LID			lidOrphan		= lidMin;
	const BOOL	fCheckMergePage	= FLVIUpdatablePage( pcsr );
	const BOOL	fCheckRight		= FLVIUpdatablePage( pcsrRight );
	const BOOL	fCheckLeft		= ( pgnoNull != pcsrLeft->Pgno()
									&& FLVIUpdatablePage( pcsrLeft ) );

	//	merge page is dependent on right page
	Enforce( !fCheckRight || fCheckMergePage );

	Enforce( pcsrRight->Pgno() != pgnoNull );
		
	if ( fCheckRight )
		LVICheckLVPage( pfucb, pcsrRight, &lidOrphan );

	if ( mergetypeFullRight != pmergePath->pmerge->mergetype )
		{
		Enforce( !fCheckRight || pcsrRight->Cpage().PgnoPrev() == pcsr->Pgno() );
		Enforce( !fCheckLeft || pcsrLeft->Cpage().PgnoNext() == pcsr->Pgno() );
		if ( fCheckMergePage )
			{
			Enforce( pcsr->Cpage().PgnoNext() == pcsrRight->Pgno() );
			Enforce( pcsr->Cpage().PgnoPrev() == pcsrLeft->Pgno() );

			LVICheckLVPage( pfucb, pcsr, &lidOrphan );
			}
		else
			{
			//	can't check merged page, must reset orphan or we might
			//	end up thinking the orphan's root is on the left page
			lidOrphan = lidMin;
			}
		}
	else
		{
		Enforce( !fCheckRight || pcsrRight->Cpage().PgnoPrev() == pcsrLeft->Pgno() );
		Enforce( !fCheckLeft || pcsrLeft->Cpage().PgnoNext() == pcsrRight->Pgno() );
		}

	if ( fCheckLeft )
		{
		LVICheckLVPage( pfucb, pcsrLeft, &lidOrphan );
		}
	}

#endif	//	LV_MERGE_BUG



//	retrieve versioned LV refcount
INLINE ULONG UlLVIVersionedRefcount( FUCB *pfucbLV )
	{
	LVROOT				*plvrootVersioned;
	LONG				lCompensating;
	BOOKMARK			bookmark;

	Assert( Pcsr( pfucbLV )->FLatched() );
	Assert( sizeof(LVROOT) == pfucbLV->kdfCurr.data.Cb() );
	Assert( sizeof(LID) == pfucbLV->kdfCurr.key.Cb() );

	bookmark.key = pfucbLV->kdfCurr.key;
	bookmark.data.Nullify();

	plvrootVersioned = reinterpret_cast<LVROOT*>( pfucbLV->kdfCurr.data.Pv() );

	lCompensating = LDeltaVERGetDelta( pfucbLV, bookmark, OffsetOf( LVROOT, ulReference )	);

	return plvrootVersioned->ulReference + lCompensating;
	}


//  ****************************************************************
//  DEBUG ROUTINES
//  ****************************************************************


//  ================================================================
INLINE VOID AssertLVRootNode( FUCB *pfucbLV, const LID lid )
//  ================================================================
//
//  This checks that the FUCB is currently referencing a valid LVROOT node
//
//-
	{
#ifdef DEBUG	
	LID		lidT;

	Assert( Pcsr( pfucbLV )->FLatched() );
	Assert( sizeof(LVROOT) == pfucbLV->kdfCurr.data.Cb() );
	Assert( sizeof(LID) == pfucbLV->kdfCurr.key.Cb() );
	LidFromKey( &lidT, pfucbLV->kdfCurr.key );
	Assert( lid == lidT );

	// versioned refcount must be non-zero, otherwise we couldn't see it
	Assert( UlLVIVersionedRefcount( pfucbLV ) > 0 );;
#endif	
	}


//	verify lid/offset of an LVKEY node
INLINE VOID AssertLVDataNode(
	FUCB		*pfucbLV,
	const LID	lid,
	const ULONG ulOffset )
	{
#ifdef DEBUG
	LID			lidT;
	ULONG		ib;

	Assert( Pcsr( pfucbLV )->FLatched() );
	Assert( sizeof(LVKEY) == pfucbLV->kdfCurr.key.Cb() );
	LidOffsetFromKey( &lidT, &ib, pfucbLV->kdfCurr.key );
	Assert( lid == lidT );
	Assert( ib % g_cbColumnLVChunkMost == 0 );
	Assert( ulOffset == ib );
#endif
	}


//  ================================================================
VOID LVReportCorruptedLV( const FUCB * const pfucbLV, const LID lid )
//  ================================================================
	{
	const CHAR *rgsz[4];
	INT			irgsz = 0;

	CHAR szTable[JET_cbNameMost+1];
	CHAR szDatabase[IFileSystemAPI::cchPathMax+1];
	CHAR szpgno[16];
	CHAR szlid[16];

	sprintf( szTable, "%s", pfucbLV->u.pfcb->PfcbTable()->Ptdb()->SzTableName() );
	sprintf( szDatabase, "%s", rgfmp[pfucbLV->u.pfcb->Ifmp()].SzDatabaseName() );
	sprintf( szpgno, "%d", Pcsr( pfucbLV )->Pgno() );
	sprintf( szlid, "%d", lid );

	rgsz[irgsz++] = szTable;
	rgsz[irgsz++] = szDatabase;
	rgsz[irgsz++] = szpgno;
	rgsz[irgsz++] = szlid;

	UtilReportEvent( eventError, DATABASE_CORRUPTION_CATEGORY, CORRUPT_LONG_VALUE_ID, irgsz, rgsz );
	}


ERR ErrLVCheckDataNodeOfLid( FUCB *pfucbLV, const LID lid )
	{
	ERR		err;
	LID		lidT;
	
	Assert( Pcsr( pfucbLV )->FLatched() );

	if( fGlobalRepair )
		{
		//  don't bother returning an error during repair
		//  if we are running repair the database is probably corrupted
		return JET_errSuccess;
		}
		
	if ( sizeof(LVKEY) == pfucbLV->kdfCurr.key.Cb() )
		{
		LidFromKey( &lidT, pfucbLV->kdfCurr.key );
		if ( lid == lidT )
			{
#ifdef DEBUG
			ULONG	ib;
			OffsetFromKey( &ib, pfucbLV->kdfCurr.key );
			Assert( ib % g_cbColumnLVChunkMost == 0 );
#endif

			//	this is a valid data node belonging to this lid
			err = JET_errSuccess;
			}
		else
			{
			//	should be impossible (if lids don't match, we
			//	should have hit an LV root node, not another
			//	LV data node)
			LVReportCorruptedLV( pfucbLV, lid );
			FireWall();
			err = ErrERRCheck( JET_errLVCorrupted );
			}
		}

	else if ( sizeof(LID) == pfucbLV->kdfCurr.key.Cb()
		&& sizeof(LVROOT) == pfucbLV->kdfCurr.data.Cb() )
		{
		LidFromKey( &lidT, pfucbLV->kdfCurr.key );
		if ( lidT <= lid  )
			{
			LVReportCorruptedLV( pfucbLV, lid );
			FireWall();

			//	current LV has should have higher lid than previous LV
			err = ErrERRCheck( JET_errLVCorrupted );
			}
		else
			{
			//	moved on to a new lid, issue warning
			err = ErrERRCheck( wrnLVNoMoreData );
			}
		}
	else
		{
		LVReportCorruptedLV( pfucbLV, lid );
		FireWall();

		//	bogus LV node
		err = ErrERRCheck( JET_errLVCorrupted );
		}

	return err;
	}


#ifdef DEBUG
//  ================================================================
BOOL FAssertLVFUCB( const FUCB * const pfucb )
//  ================================================================
//
//  Asserts that the FUCB references a Long Value directory
//  long value directories do not have TDBs.
//
//-
	{
	FCB	*pfcb = pfucb->u.pfcb;
	if ( pfcb->FTypeLV() )
		{
		Assert( pfcb->Ptdb() == ptdbNil );
		}
	return pfcb->FTypeLV();
	}
#endif	


//  ****************************************************************
//  ROUTINES
//  ****************************************************************


//  ================================================================
BOOL FPIBSessionLV( PIB *ppib )
//  ================================================================
	{
	Assert( ppibNil != ppib );
	return ( PinstFromPpib(ppib)->m_ppibLV == ppib );
	}


//  ================================================================
LOCAL ERR ErrFILECreateLVRoot( PIB *ppib, FUCB *pfucb, PGNO *ppgnoLV )
//  ================================================================
//
//  Creates the LV tree for the given table. 
//	
//-
	{
	ERR		err = JET_errSuccess;
	FUCB	*pfucbTable = pfucbNil;
	PGNO	pgnoLVFDP = pgnoNull;
	OBJID	objidLV;
	BOOL	fInTransaction = fFalse;

	Assert( !FAssertLVFUCB( pfucb ) );
	
	const BOOL	fTemp = ( dbidTemp == rgfmp[ pfucb->ifmp ].Dbid() );
	Assert( ( fTemp && pfucb->u.pfcb->FTypeTemporaryTable() )
		|| ( !fTemp && pfucb->u.pfcb->FTypeTable() ) );

#ifdef DEBUG
	const BOOL	fExclusive = !FPIBSessionLV( ppib );
	if ( fExclusive )
		{
		Assert( pfucb->ppib == ppib );
		Assert( pfucb->u.pfcb->FDomainDenyReadByUs( pfucb->ppib ) );
		}
	else
		{
		Assert( !FPIBSessionLV( pfucb->ppib ) );
		Assert( !pfucb->u.pfcb->FDomainDenyReadByUs( pfucb->ppib ) );
		Assert( PinstFromPpib(ppib)->m_critLV.FOwner() );
		}
#endif		
	
	//  open the parent directory (so we are on the pgnoFDP ) and create the LV tree
	CallR( ErrDIROpen( ppib, pfucb->u.pfcb, &pfucbTable ) );
	Call( ErrDIRBeginTransaction( ppib, NO_GRBIT ) );
	fInTransaction = fTrue;

	Call( PverFromIfmp( pfucb->ifmp )->ErrVERFlag( pfucbTable, operCreateLV, NULL, 0 ) );
	
	//  CONSIDER:  get at least enough pages to hold the LV we are about to insert
	//  we must open the directory with a different session.
	//	if this fails, rollback will free the extent, or at least, it will attempt
	//  to free the extent.
	Call( ErrDIRCreateDirectory( pfucbTable, cpgLVTree, &pgnoLVFDP, &objidLV, CPAGE::fPageLongValue ) );

	Assert( pgnoLVFDP > pgnoSystemRoot );
	Assert( pgnoLVFDP <= pgnoSysMax );
	Assert( pgnoLVFDP != pfucbTable->u.pfcb->PgnoFDP() );

	if ( !fTemp )
		{
		Assert( objidLV > objidSystemRoot );
		Call( ErrCATAddTableLV(
					ppib,
					pfucb->ifmp,
					pfucb->u.pfcb->ObjidFDP(),
					pgnoLVFDP,
					objidLV ) );
		}

	Call( ErrDIRCommitTransaction( ppib, NO_GRBIT ) );
	fInTransaction = fFalse;

	*ppgnoLV = pgnoLVFDP;

HandleError:
	if ( fInTransaction )
		{
		CallSx( ErrDIRRollback( ppib ), JET_errRollbackError );
		}
	Assert( pfucbTable != pfucbNil );
	DIRClose( pfucbTable );

#ifdef DEBUG
	if ( !fExclusive )
		Assert( PinstFromPpib(ppib)->m_critLV.FOwner() );
#endif		

	//	should have no other directory with the same parentId and name, or the same pgnoFDP	
	Assert( JET_errKeyDuplicate != err );
	return err;
	}


//  ================================================================
INLINE ERR ErrFILEIInitLVRoot( FUCB *pfucb, const PGNO pgnoLV, FUCB **ppfucbLV )
//  ================================================================
	{
	ERR				err;
	FCB * const		pfcbTable	= pfucb->u.pfcb;
	FCB	*			pfcbLV;

	// Link LV FCB into table.
	CallR( ErrDIROpen( pfucb->ppib, pgnoLV, pfucb->ifmp, ppfucbLV ) );
	Assert( *ppfucbLV != pfucbNil );
	Assert( !FFUCBVersioned( *ppfucbLV ) );	// Verify won't be deferred closed.
	pfcbLV = (*ppfucbLV)->u.pfcb;
	Assert( !pfcbLV->FInitialized() );

	Assert( pfcbLV->Ifmp() == pfucb->ifmp );
	Assert( pfcbLV->PgnoFDP() == pgnoLV );
	Assert( pfcbLV->Ptdb() == ptdbNil );
	Assert( pfcbLV->CbDensityFree() == 0 );

	Assert( pfcbLV->FTypeNull() );
	pfcbLV->SetTypeLV();
	
	Assert( pfcbLV->PfcbTable() == pfcbNil );
	pfcbLV->SetPfcbTable( pfcbTable );

	//	NOTE: we do not need to lock pfcbLV to read FAboveThreshold()
	//		  because the flag will never change on an LV FCB
	
	if ( pfcbLV->FAboveThreshold() )
		{
		//	since there is a cursor open on the FCB, it will not be in
		//		the avail list and we can directly set the flag
		
		//	NOTE: we must be the only people accessing pfucb->u.pfcb
		pfcbTable->Lock();
		pfcbTable->SetAboveThreshold();
		pfcbTable->Unlock();
		}

	//	finish the initialization of this LV FCB
	
	pfcbLV->CreateComplete();

	//	WARNING: publishing the FCB in the TDB *must*
	//	be the last thing or else other sessions might
	//	see an FCB that's not fully initialised
	//
	Assert( pfcbTable->Ptdb()->PfcbLV() == pfcbNil );
	pfcbTable->Ptdb()->SetPfcbLV( pfcbLV );

	return err;
	}


//  ================================================================
ERR ErrFILEOpenLVRoot( FUCB *pfucb, FUCB **ppfucbLV, BOOL fCreate )
//  ================================================================
	{
	ERR			err;
	PIB			*ppib;
	PGNO		pgnoLV = pgnoNull;
	
	Assert( pfcbNil != pfucb->u.pfcb );
	Assert( pfucb->ppib != PinstFromPfucb(pfucb)->m_ppibLV );

	//  HACK: repair checks only one table per thread, but we can't open derived tables
	//  if the template table is opened exculsively
	
	const BOOL	fExclusive = pfucb->u.pfcb->FDomainDenyReadByUs( pfucb->ppib ) || fGlobalRepair;
	const BOOL	fTemp = ( dbidTemp == rgfmp[ pfucb->ifmp ].Dbid() );	

	Assert( PinstFromPfucb(pfucb)->m_critLV.FNotOwner() );
	
	if ( fExclusive )
		{
		Assert( ( fTemp && pfucb->u.pfcb->FTypeTemporaryTable() )
			|| ( !fTemp && pfucb->u.pfcb->FTypeTable() ) );
		ppib = pfucb->ppib;
		Assert( pfcbNil == pfucb->u.pfcb->Ptdb()->PfcbLV() );
		}
	else
		{
		Assert( !fTemp );
		Assert( pfucb->u.pfcb->FTypeTable() );
		
		PinstFromPfucb(pfucb)->m_critLV.Enter();
		ppib = PinstFromPfucb(pfucb)->m_ppibLV;

		FCB	*pfcbLV = pfucb->u.pfcb->Ptdb()->PfcbLV();

		//  someone may have come in and created the LV tree already
		if ( pfcbNil != pfcbLV )
			{
			PinstFromPfucb(pfucb)->m_critLV.Leave();
			
			// PfcbLV won't go away, since only way it would be freed is if table
			// FCB is freed, which can't happen because we've got a cursor on the table.
			err = ErrDIROpen( pfucb->ppib, pfcbLV, ppfucbLV );
			return err;
			}
			
		err = ErrDBOpenDatabaseByIfmp( PinstFromPfucb(pfucb)->m_ppibLV, pfucb->ifmp );
		if ( err < 0 )
			{
			PinstFromPfucb(pfucb)->m_critLV.Leave();
			return err;
			}
		}

	Assert( pgnoNull == pgnoLV );	// initial value
	if ( !fTemp )
		{
		Call( ErrCATAccessTableLV( ppib, pfucb->ifmp, pfucb->u.pfcb->ObjidFDP(), &pgnoLV ) );
		}
	else
		{
		//	if opening LV tree for a temp. table, it MUST be created
		Assert( fCreate );
		}

	if ( pgnoNull == pgnoLV && fCreate )
		{
		// LV root not yet created.
		Call( ErrFILECreateLVRoot( ppib, pfucb, &pgnoLV ) );
		}

	// For temp. tables, if initialisation fails here, the space
	// for the LV will be lost, because it's not persisted in
	// the catalog.
	if( pgnoNull != pgnoLV )
		{
		err = ErrFILEIInitLVRoot( pfucb, pgnoLV, ppfucbLV );
		}
	else
		{
		//	if only opening LV tree (ie. no creation), and no LV tree
		//	exists, then return warning and no cursor.
		Assert( !fTemp );
		Assert( !fCreate );
		*ppfucbLV = pfucbNil;
		err = ErrERRCheck( wrnLVNoLongValues );
		}

HandleError:
	if ( !fExclusive )
		{
		Assert( ppib == PinstFromPfucb(pfucb)->m_ppibLV );
		CallS( ErrDBCloseAllDBs( PinstFromPfucb(pfucb)->m_ppibLV ) );

		PinstFromPfucb(pfucb)->m_critLV.Leave();
		}

#ifdef DEBUG
	if ( pfucb->u.pfcb->Ptdb()->PfcbLV() == pfcbNil )
		{
		Assert( err < JET_errSuccess
			|| ( !fCreate && wrnLVNoLongValues == err ) );
		}
	else
		{
		CallS( err );
		}
#endif

	return err;
	}


//  ================================================================
ERR ErrDIROpenLongRoot( FUCB * pfucb, FUCB ** ppfucbLV, BOOL fCreate = fFalse )
//  ================================================================
//
//  Extract the pgnoFDP of the long value tree table from the catalog and go to it
//  if the Long Value tree does not exist we will create it
//
//-
	{
	Assert( !FAssertLVFUCB( pfucb ) );
	Assert( ppfucbLV );

	FCB	*pfcbLV = pfucb->u.pfcb->Ptdb()->PfcbLV();
	ERR	err;

	if ( pfcbNil == pfcbLV )
		{
		CallR( ErrFILEOpenLVRoot( pfucb, ppfucbLV, fCreate ) );
		if ( wrnLVNoLongValues == err )
			{
			Assert( !fCreate );
			Assert( pfucbNil == *ppfucbLV );
			return err;
			}
		else
			{
			CallS( err );
			Assert( pfucbNil != *ppfucbLV );
			}
		}
	else
		{
		CallR( ErrDIROpen( pfucb->ppib, pfcbLV, ppfucbLV ) );
		Assert( (*ppfucbLV)->u.pfcb == pfcbLV );
		}

	ASSERT_VALID( *ppfucbLV );
	
	pfcbLV = (*ppfucbLV)->u.pfcb;
	Assert( pfcbLV != pfcbNil );
	Assert( pfcbLV->Ifmp() == pfucb->ifmp );
	Assert( pfcbLV->PgnoFDP() != pfucb->u.pfcb->PgnoFDP() );
	Assert( pfcbLV->Ptdb() == ptdbNil );
	Assert( pfcbLV->FInitialized() );
	Assert( pfcbLV->FTypeLV() );
	Assert( pfcbLV->PfcbTable() == pfucb->u.pfcb );
	Assert( pfucb->u.pfcb->Ptdb()->PfcbLV() == pfcbLV );

    // if our table is open in sequential mode open the long value table in sequential mode as well
    // compact opens all its tables in sequential mode
    if ( FFUCBSequential( pfucb ) )
		{
        FUCBSetSequential( *ppfucbLV );
        }
        
	// UNDONE: Since FCB critical sections are shared, is it not possible for this
	// assert to fire on a hash collision??
	Assert( pfcbLV->IsUnlocked() );	//lint !e539

	return err;
	}


//  ================================================================
ERR ErrDIRDownLV(
	FUCB			*pfucb,
	const LID		lid,
	const ULONG		ulOffset,
	const DIRFLAG	dirflag )
//  ================================================================
//
//	This takes an FUCB that is opened on the Long Value tree table and seeks
//  to the appropriate offset in the long value.
//
//-
	{
	Assert( FAssertLVFUCB( pfucb ) );
	Assert( lid > lidMin );

	//  normalize the offset to a multiple of g_cbColumnLVChunkMost. we should seek to the exact node
	const ULONG ulOffsetT = ( ulOffset / g_cbColumnLVChunkMost ) * g_cbColumnLVChunkMost;
	
	//  make a key that consists of the long id and the offset
	const LVKEY	lvkey = LVKeyFromLidOffset( lid, ulOffsetT );

	DIRUp( pfucb );
	
	BOOKMARK	bm;
	bm.key.prefix.Nullify();
	bm.key.suffix.SetPv( const_cast<LVKEY *>( &lvkey ) );
	bm.key.suffix.SetCb( sizeof( LVKEY ) );
	bm.data.Nullify();

	DIB			dib;
	dib.dirflag = dirflag | fDIRExact;
	dib.pos		= posDown;
	dib.pbm		= &bm;
	
	ERR err = ErrDIRDown( pfucb, &dib );

	if ( JET_errSuccess == err )
		{
		AssertLVDataNode( pfucb, lid, ulOffsetT );
		}
	else if ( wrnNDFoundGreater == err
			|| wrnNDFoundLess == err )
		{
		LVReportCorruptedLV( pfucb, lid );
		FireWall();
		err = ErrERRCheck( JET_errLVCorrupted );
		}

	return err;
	}


//  ================================================================
ERR ErrDIRDownLV( FUCB * pfucb, const LID lid, DIRFLAG dirflag )
//  ================================================================
//
//	This takes an FUCB that is opened on the Long Value tree table and seeks
//  to the LVROOT node
//
//-
	{
	Assert( FAssertLVFUCB( pfucb ) );
	Assert( lid > lidMin );

	DIRUp( pfucb );

	//  make a key that consists of the LID only

	BYTE rgbKey[ sizeof( LID ) ];
	KeyFromLong( rgbKey, lid );

	BOOKMARK	bm;
	bm.key.prefix.Nullify();
	bm.key.suffix.SetPv( rgbKey );
	bm.key.suffix.SetCb( sizeof( rgbKey ) );
	bm.data.Nullify();

	DIB	dib;
	dib.dirflag = dirflag | fDIRExact;
	dib.pos		= posDown;
	dib.pbm		= &bm;
	
	ERR	err		= ErrDIRDown( pfucb, &dib );

	if ( JET_errSuccess == err )
		{
		AssertLVRootNode( pfucb, lid );
		}
	else if ( ( wrnNDFoundGreater == err
				|| wrnNDFoundLess == err
				|| JET_errRecordNotFound == err )
			&& !fGlobalRepair )
		{
		Assert( pfucb->ppib->level > 0 );
		LVReportCorruptedLV( pfucb, lid );
		FireWall();
		err = ErrERRCheck( JET_errLVCorrupted );
		}

	return err;
	}


//  ================================================================
INLINE ERR ErrRECISetLid(
	FUCB			*pfucb,
	const COLUMNID	columnid,
	const ULONG		itagSequence,
	const LID		lid )
//  ================================================================
//
//  Sets the separated LV struct in the record to point to the given LV.
//  Used after an LV is copied.
//
//-
	{
	Assert( !FAssertLVFUCB( pfucb ) );
	Assert( lid > lidMin );

	UnalignedLittleEndian< LID >		lidT	= lid;
	DATA								dataLV;

	dataLV.SetPv( &lidT );
	dataLV.SetCb( sizeof(lidT) );

	const ERR	err		= ErrRECSetColumn(
								pfucb,
								columnid,
								itagSequence,
								&dataLV,
								grbitSetColumnSeparated );
	return err;
	}


//	========================================================================
ERR ErrLVInit( INST *pinst )
//	========================================================================
//
//  This may leak critical sections if ErrPIBBeginSession fails.
//  Is this important?
//
//-
	{
	ERR err = JET_errSuccess;

	if ( !pinst->FRecovering() )
		{
		Call( ErrPIBBeginSession( pinst, &pinst->m_ppibLV, procidNil, fFalse ) );
		}

HandleError:
	return err;
	}


//	========================================================================
VOID LVTerm( INST * pinst )
//	========================================================================
	{	
	Assert( pinst->m_critLV.FNotOwner() );

	if ( pinst->m_ppibLV )
		{
		PIBEndSession( pinst->m_ppibLV );
		pinst->m_ppibLV = ppibNil;
		}
	}


// WARNING: See "LV grbit matrix" before making any modifications here.
INLINE ERR ErrLVOpFromGrbit(
	const JET_GRBIT	grbit,
	const ULONG		cbData,
	const BOOL		fNewInstance,
	const ULONG		ibLongValue,
	LVOP			*plvop )
	{
	const BOOL		fNoCbData = ( 0 == cbData );
	
	switch ( grbit )
		{
		case JET_bitSetAppendLV:
			if ( fNoCbData )
				{
				*plvop = ( fNewInstance ? lvopInsertZeroLength : lvopNull );
				}
			else
				{
				*plvop = ( fNewInstance ? lvopInsert : lvopAppend );
				}
			break;
		case JET_bitSetOverwriteLV:
			if ( fNoCbData )
				{
				if ( fNewInstance )
					{
					if ( 0 == ibLongValue )
						*plvop = lvopInsertZeroLength;
					else
						{
						*plvop = lvopNull;
						return ErrERRCheck( JET_errColumnNoChunk );
						}
					}
				else
					*plvop = lvopNull;
				}
			else
				{
				if ( fNewInstance )
					{
					if ( 0 == ibLongValue )
						*plvop = lvopInsert;
					else
						{
						*plvop = lvopNull;
						return ErrERRCheck( JET_errColumnNoChunk );
						}
					}
				else
					*plvop = lvopOverwriteRange;
				}
			break;
		case JET_bitSetSizeLV:
			if ( fNoCbData )
				{
				*plvop = ( fNewInstance ? lvopInsertNull : lvopReplaceWithNull );
				}
			else
				{
				*plvop = ( fNewInstance ? lvopInsertZeroedOut : lvopResize );
				}
			break;
		case JET_bitSetZeroLength:
			if ( fNoCbData )
				{
				*plvop = ( fNewInstance ? lvopInsertZeroLength : lvopReplaceWithZeroLength );
				}
			else
				{
				*plvop = ( fNewInstance ? lvopInsert : lvopReplace );
				}
			break;
		case JET_bitSetSizeLV|JET_bitSetZeroLength:
			if ( fNoCbData )
				{
				*plvop = ( fNewInstance ? lvopInsertZeroLength : lvopReplaceWithZeroLength );
				}
			else
				{
				*plvop = ( fNewInstance ? lvopInsertZeroedOut : lvopResize );
				}
			break;
		case JET_bitSetSizeLV|JET_bitSetOverwriteLV:
			if ( fNoCbData )
				{
				*plvop = ( fNewInstance ? lvopInsertNull : lvopReplaceWithNull );
				}
			else if ( fNewInstance )
				{
				if ( 0 == ibLongValue )
					*plvop = lvopInsert;
				else
					{
					*plvop = lvopNull;
					return ErrERRCheck( JET_errColumnNoChunk );
					}
				}
			else
				{
				*plvop = lvopOverwriteRangeAndResize;
				}
			break;
		default:
			Assert( 0 == grbit );
			if ( fNoCbData )
				{
				*plvop = ( fNewInstance ? lvopInsertNull : lvopReplaceWithNull );
				}
			else
				{
				*plvop = ( fNewInstance ? lvopInsert : lvopReplace );
				}
		}

	return JET_errSuccess;
	}

#ifdef INTRINSIC_LV

//	================================================================
LOCAL ERR ErrRECIBigGateToAOIntrinsicLV(
	FUCB			*pfucb,
	const COLUMNID	columnid,
	const ULONG		itagSequence,
	const DATA		*pdataColumn,
	const DATA		*pdataNew,
	const ULONG		ibLongValue,
	const LVOP		lvop)
//	================================================================
	{
	BYTE rgb[g_cbPageMax];
	Assert( pdataNew->Cb() <= cbLVIntrinsicMost );
	return ErrRECAOIntrinsicLV(
				pfucb,
				columnid,
				itagSequence,
				pdataColumn,
				pdataNew,
				ibLongValue,
				lvop,
				rgb );
	}

//	================================================================
LOCAL ERR ErrRECIRegularGateToAOIntrinsicLV(
	FUCB			*pfucb,
	const COLUMNID	columnid,
	const ULONG		itagSequence,
	const DATA		*pdataColumn,
	const DATA		*pdataNew,
	const ULONG		ibLongValue,
	const LVOP		lvop)
//	================================================================
	{
	BYTE rgb[cbLVBurstMin-1];
	Assert( pdataNew->Cb() < cbLVBurstMin );
	return ErrRECAOIntrinsicLV(
				pfucb,
				columnid,
				itagSequence,
				pdataColumn,
				pdataNew,
				ibLongValue,
				lvop,
				rgb );
	}

#endif // INTRINSIC_LV

//	================================================================

//  ================================================================
ERR ErrRECSetLongField(
	FUCB 			*pfucb,
	const COLUMNID	columnid,
	const ULONG		itagSequence,
	DATA			*pdataField,
	JET_GRBIT		grbit,
	const ULONG		ibLongValue,
	const ULONG		ulMax )
//  ================================================================
	{
	ERR			err;
	DATA		dataRetrieved;

	//	save SetSeparateLV status, then strip off the flag
	const BOOL	fRequestSeparateLV		= ( grbit & JET_bitSetSeparateLV );
#ifdef INTRINSIC_LV
	const BOOL	fSetIntrinsicLV			= ( grbit & JET_bitSetIntrinsicLV );
#endif // INTRINSIC_LV	

	//	save SetRevertToDefaultValue, then strip off flag
	const BOOL	fRevertToDefault		= ( grbit & JET_bitSetRevertToDefaultValue );

	//	save SetSLVFromSLVInfo status, then strip off the flag
	const BOOL	fSetSLVInfo				= ( grbit & JET_bitSetSLVFromSLVInfo );
	BOOL		fModifyExistingSLV		= fFalse;

	//	stip off grbits no longer recognised by this function
	//	note: unique multivalues are checked in ErrFLDSetOneColumn()
	grbit &= ~( JET_bitSetSeparateLV
				| JET_bitSetUniqueMultiValues
				| JET_bitSetUniqueNormalizedMultiValues
				| JET_bitSetSLVFromSLVInfo
				| JET_bitSetRevertToDefaultValue 
#ifdef INTRINSIC_LV
				| JET_bitSetIntrinsicLV );
#else // !INTRINSIC_LV
				);
#endif // INTRINSIC_LV

	ASSERT_VALID( pfucb );
	Assert( !FAssertLVFUCB( pfucb ) );
	
	//	if we are setting size only, pv may be NULL with non-zero cb
#ifdef DEBUG
	const BOOL	fNullPvDataAllowed =
					( grbit == JET_bitSetSizeLV
					|| grbit == ( JET_bitSetSizeLV|JET_bitSetZeroLength ) );
	pdataField->AssertValid( fNullPvDataAllowed );
#endif

	Assert( 0 == grbit
			|| JET_bitSetAppendLV == grbit
			|| JET_bitSetOverwriteLV == grbit
			|| JET_bitSetSizeLV == grbit
			|| JET_bitSetZeroLength == grbit
			|| ( JET_bitSetSizeLV | JET_bitSetZeroLength ) == grbit
			|| ( JET_bitSetOverwriteLV | JET_bitSetSizeLV ) == grbit );

	AssertSz( pfucb->ppib->level > 0, "LV update attempted at level 0" );
	if ( 0 == pfucb->ppib->level )
		{
		err = ErrERRCheck( JET_errNotInTransaction );
		return err;
		}

	Assert( FCOLUMNIDTagged( columnid ) );
	FUCBSetColumnSet( pfucb, FidOfColumnid( columnid ) );

	CallR( ErrDIRBeginTransaction( pfucb->ppib, NO_GRBIT ) );
	
	//	sequence == 0 means that new field instance is to be set, otherwise retrieve the existing data
	BOOL	fModifyExistingSLong	= fFalse;
	BOOL	fNewInstance			= ( 0 == itagSequence );
	if ( !fNewInstance )
		{
		Call( ErrRECIRetrieveTaggedColumn(
					pfucb->u.pfcb,
					columnid,
					itagSequence,
					pfucb->dataWorkBuf,
					&dataRetrieved,
					grbitRetrieveColumnDDLNotLocked ) );
		Assert( wrnRECLongField != err );
		switch ( err )
			{
			case wrnRECSeparatedLV:
				FUCBSetUpdateSeparateLV( pfucb );
				fModifyExistingSLong = fTrue;
			case wrnRECIntrinsicLV:
				Assert( !fNewInstance );
				break;

			case wrnRECSeparatedSLV:
				FUCBSetUpdateSeparateLV( pfucb );
				fModifyExistingSLong = fTrue;
			case wrnRECIntrinsicSLV:
				fModifyExistingSLV = fTrue;
				Assert( !fNewInstance );
				break;

			default:
				Assert( JET_wrnColumnNull == err
					|| wrnRECUserDefinedDefault == err );
				Assert( 0 == dataRetrieved.Cb() );
				fNewInstance = fTrue;
			}
		}
		

	LVOP	lvop;
	Call( ErrLVOpFromGrbit(
				grbit,
				pdataField->Cb(),
				fNewInstance,
				ibLongValue,
				&lvop ) );

	if ( fModifyExistingSLong )
		{
		if ( lvopReplace == lvop
			|| lvopReplaceWithNull == lvop
			|| lvopReplaceWithZeroLength == lvop )
			{
			//	we will be replacing an existing SLong in its entirety,
			//	so must first deref existing SLong.  If WriteConflict,
			//	it means that someone is already replacing over this
			//	column, so just return the error.
			Assert( FFUCBUpdateSeparateLV( pfucb ) );
			LID		lidT	= LidOfSeparatedLV( dataRetrieved );
			Call( ErrRECAffectSeparateLV( pfucb, &lidT, fLVDereference ) );
			Assert( JET_wrnCopyLongValue != err );

			//	separated LV is being replaced entirely, so reset modify flag
			fModifyExistingSLong = fFalse;
			}
		}
		
	switch ( lvop )
		{
		case lvopNull:
			err = JET_errSuccess;
			goto Commit;

		case lvopInsertNull:
		case lvopReplaceWithNull:
			Assert( ( lvopInsertNull == lvop && fNewInstance )
				|| ( lvopReplaceWithNull == lvop && !fNewInstance ) );
			Assert( !fModifyExistingSLong );
			Call( ErrRECSetColumn(
						pfucb,
						columnid,
						itagSequence,
						NULL,
						( fRevertToDefault ? JET_bitSetRevertToDefaultValue : NO_GRBIT ) ) );
			goto Commit;

		case lvopInsertZeroLength:
		case lvopReplaceWithZeroLength:
			{
			Assert( ( lvopInsertZeroLength == lvop && fNewInstance )
				|| ( lvopReplaceWithZeroLength == lvop && !fNewInstance ) );
			Assert( !fModifyExistingSLong );

			DATA	dataT;
			dataT.SetPv( NULL );
			dataT.SetCb( 0 );
			Call( ErrRECSetColumn( pfucb, columnid, itagSequence, &dataT ) );
			goto Commit;
			}
			
		case lvopInsert:
		case lvopInsertZeroedOut:
		case lvopReplace:
			if ( lvopReplace == lvop )
				{
				Assert( !fNewInstance );
				ASSERT_VALID( &dataRetrieved );
				}
			else
				{
				Assert( fNewInstance );
				}
			Assert( !fModifyExistingSLong );
			dataRetrieved.Nullify();
			break;

		case lvopAppend:
		case lvopResize:
		case lvopOverwriteRange:
		case lvopOverwriteRangeAndResize:
			Assert( !fNewInstance );
			ASSERT_VALID( &dataRetrieved );
			break;

		default:
			Assert( fFalse );
			break;
		}

	// All null/zero-length cases should have been handled above.
	Assert( pdataField->Cb() > 0 );


	if ( fModifyExistingSLong )
		{
		Assert( lvopAppend == lvop
			|| lvopResize == lvop
			|| lvopOverwriteRange == lvop
			|| lvopOverwriteRangeAndResize == lvop );
			
		// Flag should have gotten set when column was retrieved above.
		Assert( FFUCBUpdateSeparateLV( pfucb ) );

		LID		lidT	= LidOfSeparatedLV( dataRetrieved );
		Call( ErrRECAOSeparateLV( pfucb, &lidT, pdataField, ibLongValue, ulMax, lvop ) );
		if ( JET_wrnCopyLongValue == err )
			{
			Call( ErrRECISetLid( pfucb, columnid, itagSequence, lidT ) );
			}
		}
	else
		{
		//	determine space requirements of operation to see if we can
		//	make the LV intrinsic
		//	note that long field flag is included in length thereby limiting
		//	intrinsic long field to cbLVIntrinsicMost - sizeof(BYTE)
		ULONG		cbIntrinsic			= pdataField->Cb();

		Assert( fNewInstance || dataRetrieved.Cb() <= cbLVIntrinsicMost );
		
		switch ( lvop )
			{
			case lvopInsert:
			case lvopInsertZeroedOut:
				Assert( dataRetrieved.FNull() );
			case lvopReplace:	//lint !e616
			case lvopResize:
				break;
				
			case lvopOverwriteRange:
				cbIntrinsic += ibLongValue;
				if ( dataRetrieved.Cb() > cbIntrinsic )
					cbIntrinsic = dataRetrieved.Cb();
				break;
				
			case lvopOverwriteRangeAndResize:
				cbIntrinsic += ibLongValue;
				break;

			case lvopAppend:
				cbIntrinsic += dataRetrieved.Cb();
				break;

			case lvopNull:
			case lvopInsertNull:
			case lvopInsertZeroLength:
			case lvopReplaceWithNull:
			case lvopReplaceWithZeroLength:
			default:
				Assert( fFalse );
				break;
			}

#ifdef INTRINSIC_LV
		if ( fSetIntrinsicLV )
			{
			if ( pdataField->Cb() <= cbLVIntrinsicMost )
				{
				Call ( ErrRECIBigGateToAOIntrinsicLV(
							pfucb,
							columnid,
							itagSequence,
							&dataRetrieved,
							pdataField,
							ibLongValue,
							lvop ) );
				}
			else
				{
				Call ( ErrERRCheck( JET_errRecordTooBig ) );
				}
			}
		//	burst if value is greater than cbLVIntrinsicMost, or if
		//	LV separation is requested and the value is sufficiently large.
		else
			{
			Assert( !fSetIntrinsicLV );
			BOOL	fForceSeparateLV = ( cbIntrinsic >= cbLVBurstMin
									|| ( fRequestSeparateLV && cbIntrinsic > sizeof(LID) ) );
		if ( !fForceSeparateLV )
			{
			err = ErrRECIRegularGateToAOIntrinsicLV(
						pfucb,
						columnid,
						itagSequence,
						&dataRetrieved,
						pdataField,
						ibLongValue,
						lvop );
			if ( JET_errRecordTooBig == err )
				{
				fForceSeparateLV = fTrue;
				err = JET_errSuccess;
				}
			Call( err );
			}
			
#else // !INTRINSIC_LV		
		BOOL	fForceSeparateLV = ( cbIntrinsic > cbLVIntrinsicMost
									|| ( fRequestSeparateLV && cbIntrinsic > sizeof(LID) ) );
		if ( !fForceSeparateLV )
			{
			err = ErrRECAOIntrinsicLV(
						pfucb,
						columnid,
						itagSequence,
						&dataRetrieved,
						pdataField,
						ibLongValue,
						lvop );
			if ( JET_errRecordTooBig == err )
				{
				fForceSeparateLV = fTrue;
				err = JET_errSuccess;
				}
			Call( err );
			}
			
#endif // INTRINSIC_LV
			
		if ( fForceSeparateLV )
			{
			LID		lidT;

			// Flag may not have gotten set if this is a new instance.
			FUCBSetUpdateSeparateLV( pfucb );

			Call( ErrRECSeparateLV( pfucb, &dataRetrieved, &lidT, NULL ) );
			Assert( JET_wrnCopyLongValue == err );
			Call( ErrRECAOSeparateLV( pfucb, &lidT, pdataField, ibLongValue, ulMax, lvop ) );
			Assert( JET_wrnCopyLongValue != err );
			Call( ErrRECISetLid( pfucb, columnid, itagSequence, lidT ) );
			}
#ifdef INTRINSIC_LV			
			}
#endif // INTRINSIC_LV		
		}

Commit:
	Call( ErrDIRCommitTransaction( pfucb->ppib, NO_GRBIT ) );
	return err;

HandleError:
	Assert( err < 0 );
	CallSx( ErrDIRRollback( pfucb->ppib ), JET_errRollbackError );
	return err;
	}


//  ================================================================
LOCAL ERR ErrRECIBurstSeparateLV( FUCB * pfucbTable, FUCB * pfucbSrc, LID * plid )
//  ================================================================
//
//  Makes a new copy of an existing long value. If we are sucessful pfucbSrc
//  will point to the root of the new long value. We cannot have two cursors
//  open on the table at the same time (deadlock if they try to get the same
//  page), so we use a temp buffer.
//
//  On return pfucbSrc points to the root of the new long value
//
//-
	{
	ASSERT_VALID( pfucbTable );
	Assert( !FAssertLVFUCB( pfucbTable ) );
	ASSERT_VALID( pfucbSrc );
	Assert( FAssertLVFUCB( pfucbSrc ) );
	Assert( NULL != plid );
	Assert( *plid > lidMin );

	ERR			err			= JET_errSuccess;
	FUCB  	 	*pfucbDest  = pfucbNil;
	LID			lid			= lidMin;
	ULONG  	 	ulOffset	= 0;
	LVROOT		lvroot;
	DATA  	 	data;
	VOID		*pvbf		= NULL;
	BOOL		fLatchedSrc	= fFalse;

	//	get long value length
	AssertLVRootNode( pfucbSrc, *plid );
	UtilMemCpy( &lvroot, pfucbSrc->kdfCurr.data.Pv(), sizeof(LVROOT) );	//lint !e603

	BFAlloc( &pvbf );
	data.SetPv( pvbf );

	//  if we have data in the LV copy it all

	if ( lvroot.ulSize > 0 )
		{
		//	move source cursor to first chunk. remember its length
		Call( ErrDIRDownLV( pfucbSrc, *plid, ulLVOffsetFirst, fDIRNull ) );

		//  assert that all chunks except the last are the full size
		Assert( ( g_cbColumnLVChunkMost == pfucbSrc->kdfCurr.data.Cb() ) ||
				( ulOffset + g_cbColumnLVChunkMost > lvroot.ulSize ) );

		ulOffset += pfucbSrc->kdfCurr.data.Cb();

		//	make separate long value root, and insert first chunk
		UtilMemCpy( pvbf, pfucbSrc->kdfCurr.data.Pv(), pfucbSrc->kdfCurr.data.Cb() );
		Assert( data.Pv() == pvbf );
		data.SetCb( pfucbSrc->kdfCurr.data.Cb() );
		CallS( ErrDIRRelease( pfucbSrc ) );
		Call( ErrRECSeparateLV( pfucbTable, &data, &lid, &pfucbDest ) );
		Assert( lid > lidMin );

		//  release one cursor, restore another
		DIRUp( pfucbDest );

		//	copy remaining chunks of long value.
		while ( ( err = ErrDIRNext( pfucbSrc, fDIRNull ) ) >= JET_errSuccess )
			{
			fLatchedSrc = fTrue;

			//  make sure we are still on the same long value
			Call( ErrLVCheckDataNodeOfLid( pfucbSrc, *plid ) );

			if ( JET_errSuccess == err )
				{
				if ( ulOffset >= lvroot.ulSize )
					{
					LVReportCorruptedLV( pfucbSrc, *plid );
					FireWall();

					//	LV is bigger than what the LVROOT thinks
					err = ErrERRCheck( JET_errLVCorrupted );
					goto HandleError;
					}
				}
			else
				{
				Assert( wrnLVNoMoreData == err );
				if ( ulOffset != lvroot.ulSize )
					{
					LVReportCorruptedLV( pfucbSrc, *plid );
					FireWall();

					//	reached the end of the LV, but size does not
					//	match what LVROOT thinks it is
					err = ErrERRCheck( JET_errLVCorrupted );
					goto HandleError;
					}
					
				Call( ErrDIRRelease( pfucbSrc ) );
				fLatchedSrc = fFalse;
				break;
				}

			Assert( ( g_cbColumnLVChunkMost == pfucbSrc->kdfCurr.data.Cb() ) ||
					( ulOffset + g_cbColumnLVChunkMost > lvroot.ulSize ) );
			Assert( ulOffset + pfucbSrc->kdfCurr.data.Cb() <= lvroot.ulSize );


			LVKEY	lvkey;
			KEY		key;
			key.prefix.Nullify();
			key.suffix.SetPv( &lvkey );
			key.suffix.SetCb( sizeof( LVKEY ) );

			//  cache the data and insert it into pfucbDest
			//  OPTIMIZATION:  if ulOffset > 1 page we can keep both cursors open
			//  and insert directly from one to the other
			Assert( ulOffset % g_cbColumnLVChunkMost == 0 );
			lvkey = LVKeyFromLidOffset( lid, ulOffset );
			UtilMemCpy( pvbf, pfucbSrc->kdfCurr.data.Pv(), pfucbSrc->kdfCurr.data.Cb() );
			Assert( data.Pv() == pvbf );
			data.SetCb( pfucbSrc->kdfCurr.data.Cb() ) ;

			// Determine offset of next chunk.
			ulOffset += pfucbSrc->kdfCurr.data.Cb();

			Call( ErrDIRRelease( pfucbSrc ) );
			fLatchedSrc = fFalse;
			
			Call( ErrDIRInsert( pfucbDest, key, data, fDIRBackToFather ) );			

			//  release one cursor, restore the other
			DIRUp( pfucbDest );
			}

		if ( JET_errNoCurrentRecord != err )
			{
			Call( err );
			}
		}
		
	Assert( ulOffset == lvroot.ulSize );
					  
	//	move cursor to new long value
	err = ErrDIRDownLV( pfucbSrc, lid, fDIRNull );
	if ( err < JET_errSuccess )
		{
		Assert( JET_errWriteConflict != err );
		goto HandleError;
		}
	CallS( err );
	
	//	update lvroot.ulSize to correct long value size.
	data.SetPv( &lvroot );
	data.SetCb( sizeof(LVROOT) );
	lvroot.ulReference = 1;
	Call( ErrDIRReplace( pfucbSrc, data, fDIRNull ) );
	Call( ErrDIRGet( pfucbSrc ) );		// Recache

	//	set warning and new long value id for return.
	err 	= ErrERRCheck( JET_wrnCopyLongValue );
	*plid 	= lid;

HandleError:
	if ( fLatchedSrc )
		{
		Assert( err < 0 );
		CallS( ErrDIRRelease( pfucbSrc ) );
		}
	if ( pfucbNil != pfucbDest )
		{
		DIRClose( pfucbDest );
		}

	// The first thing we do is allocate a temporary buffer, so
	// we should never get here without having a buffer to free.
	Assert( NULL != pvbf );
	BFFree( pvbf );

	return err;
	}


INLINE ERR ErrLVAppendChunks(
	FUCB		*pfucbLV,
	LID			lid,
	ULONG		ulSize,
	BYTE		*pbAppend,
	const ULONG	cbAppend )
	{
	ERR			err				= JET_errSuccess;
	LVKEY		lvkey;
	KEY			key;
	DATA		data;
	const BYTE	* const pbMax	= pbAppend + cbAppend;

	key.prefix.Nullify();
	key.suffix.SetPv( &lvkey );
	key.suffix.SetCb( sizeof( LVKEY ) );

	//	append remaining long value data
	while( pbAppend < pbMax )
		{
		Assert( ulSize % g_cbColumnLVChunkMost == 0 );
		lvkey = LVKeyFromLidOffset( lid, ulSize );
		
		Assert( key.prefix.FNull() );
		Assert( key.suffix.Pv() == &lvkey );
		Assert( key.suffix.Cb() == sizeof(LVKEY) );

		data.SetPv( pbAppend );
		data.SetCb( min( pbMax - pbAppend, g_cbColumnLVChunkMost ) );
		
 		CallR( ErrDIRInsert( pfucbLV, key, data, fDIRBackToFather ) );
	 		
		ulSize += data.Cb();

		Assert( pbAppend + data.Cb() <= pbMax );
		pbAppend += data.Cb();
		}

	return err;
	}

ERR ErrRECAppendLVChunks(
	FUCB		*pfucbLV,
	LID			lid,
	ULONG		ulSize,
	BYTE		*pbAppend,
	const ULONG	cbAppend )
	{
	// Current size a chunk multiple.
	Assert( ulSize % g_cbColumnLVChunkMost == 0 );
	
	return ErrLVAppendChunks( pfucbLV, lid, ulSize, pbAppend, cbAppend );
	}


LOCAL ERR ErrLVAppend(
	FUCB		*pfucbLV,
	LID			lid,
	ULONG		ulSize,
	const DATA	*pdataAppend,
	VOID		*pvbf )
	{
	ERR			err				= JET_errSuccess;
	BYTE		*pbAppend		= reinterpret_cast<BYTE *>( pdataAppend->Pv() );
	ULONG		cbAppend		= pdataAppend->Cb();

	if ( 0 == cbAppend )
		return JET_errSuccess;

	//  APPEND long value
	if ( ulSize > 0 )
		{
		const ULONG ulOffsetLast = ( ( ulSize - 1 ) / g_cbColumnLVChunkMost ) * g_cbColumnLVChunkMost;
		CallR( ErrDIRDownLV( pfucbLV, lid, ulOffsetLast, fDIRFavourPrev ) );
		
		const ULONG	cbUsedInChunk		= pfucbLV->kdfCurr.data.Cb();
		Assert( cbUsedInChunk <= g_cbColumnLVChunkMost );
		if ( cbUsedInChunk < g_cbColumnLVChunkMost )
			{
			DATA		data;
			const ULONG	cbAppendToChunk	= min( cbAppend, g_cbColumnLVChunkMost - cbUsedInChunk );
			
			UtilMemCpy( pvbf, pfucbLV->kdfCurr.data.Pv(), cbUsedInChunk );
			UtilMemCpy( (BYTE *)pvbf + cbUsedInChunk, pbAppend, cbAppendToChunk );
			
			pbAppend += cbAppendToChunk;
			cbAppend -= cbAppendToChunk;
			ulSize += cbAppendToChunk;

			Assert( cbUsedInChunk + cbAppendToChunk <= g_cbColumnLVChunkMost );

			data.SetPv( pvbf );
			data.SetCb( cbUsedInChunk + cbAppendToChunk );
 			CallR( ErrDIRReplace( pfucbLV, data, fDIRNull ) );
			}
		}
	else
		{
		Assert( 0 == ulSize );
	
		//  the LV is size 0 and has a root only
		CallR( ErrDIRDownLV( pfucbLV, lid, fDIRNull ) );
		}
		
	if ( cbAppend > 0 )
		{
		Assert( ulSize % g_cbColumnLVChunkMost == 0 );
		DIRUp( pfucbLV );
		CallR( ErrLVAppendChunks( pfucbLV, lid, ulSize, pbAppend, cbAppend ) );
		}

	return err;
	}
	

LOCAL ERR ErrLVAppendZeroedOutChunks(
	FUCB		*pfucbLV,
	LID			lid,
	ULONG		ulSize,
	ULONG		cbAppend,
	VOID		*pvbf )
	{
	ERR			err		= JET_errSuccess;
	LVKEY		lvkey;
	KEY			key;
	DATA		data;

	DIRUp( pfucbLV );

	memset( pvbf, 0, g_cbColumnLVChunkMost );
	
	key.prefix.Nullify();
	key.suffix.SetPv( &lvkey );
	key.suffix.SetCb( sizeof( LVKEY ) );

	Assert( NULL != pvbf );
	data.SetPv( pvbf );
	
	//	append remaining long value data
	while( cbAppend > 0 )
		{
		Assert( ulSize % g_cbColumnLVChunkMost == 0 );
		lvkey = LVKeyFromLidOffset( lid, ulSize );
		
		Assert( key.prefix.FNull() );
		Assert( key.suffix.Pv() == &lvkey );
		Assert( key.suffix.Cb() == sizeof(LVKEY) );

		Assert( data.Pv() == pvbf );
		data.SetCb( min( cbAppend, g_cbColumnLVChunkMost ) );
		
 		CallR( ErrDIRInsert( pfucbLV, key, data, fDIRBackToFather ) );
	 		
		ulSize += data.Cb();

		Assert( cbAppend >= data.Cb() );
		cbAppend -= data.Cb();
		}

	return err;
	}
	

LOCAL ERR ErrLVTruncate(
	FUCB		*pfucbLV,
	LID			lid,
	const ULONG	ulTruncatedSize,
	VOID		*pvbf )
	{
	ERR			err;
	const ULONG	ulOffset = ulTruncatedSize;
	ULONG		ulOffsetChunk;
	DATA		data;
	
	//	seek to offset to begin deleting
	CallR( ErrDIRDownLV( pfucbLV, lid, ulOffset, fDIRNull ) );
	
	//	get offset of last byte in current chunk
	//	replace current chunk with remaining data, or delete if
	//	no remaining data.
	OffsetFromKey( &ulOffsetChunk, pfucbLV->kdfCurr.key );
	Assert( ulOffset >= ulOffsetChunk );
	data.SetCb( ulOffset - ulOffsetChunk );
	if ( data.Cb() > 0 )
		{
		data.SetPv( pvbf );
		UtilMemCpy( data.Pv(), pfucbLV->kdfCurr.data.Pv(), data.Cb() );
		CallR( ErrDIRReplace( pfucbLV, data, fDIRLogChunkDiffs ) );
		}
	else
		{
		CallR( ErrDIRDelete( pfucbLV, fDIRNull ) );
		}

	//	delete forward chunks
	while ( ( err = ErrDIRNext( pfucbLV, fDIRNull ) ) >= JET_errSuccess )
		{
		//  make sure we are still on the same long value
		err = ErrLVCheckDataNodeOfLid( pfucbLV, lid );
		if ( JET_errSuccess != err )
			{
			CallS( ErrDIRRelease( pfucbLV ) );
			return ( wrnLVNoMoreData == err ? JET_errSuccess : err );
			}
			
		CallR( ErrDIRDelete( pfucbLV, fDIRNull ) );
		}

	if ( JET_errNoCurrentRecord == err )
		{
		err = JET_errSuccess;
		}

	return err;
	}


INLINE ERR ErrLVOverwriteRange(
	FUCB		*pfucbLV,
	LID			lid,
	ULONG		ibLongValue,
	const DATA	*pdataField,
	VOID		*pvbf )
	{
	ERR			err;
	ULONG		cbChunk;		//  the size of the current chunk
	ULONG		ibChunk;		//  the index of the current chunk
	DATA		data;
	BYTE		*pb				= reinterpret_cast< BYTE *>( pdataField->Pv() );
	const BYTE	* const pbMax	= pb + pdataField->Cb();

	//	OVERWRITE long value. seek to offset to begin overwritting
	CallR( ErrDIRDownLV( pfucbLV, lid, ibLongValue, fDIRNull ) );

#ifdef DEBUG
	ULONG	cPartialChunkOverwrite	= 0;
#endif	

	//	overwrite portions of and complete chunks to effect overwrite
	for ( ; ; )
		{
		//	get size and offset of current chunk.
		cbChunk = pfucbLV->kdfCurr.data.Cb();
		OffsetFromKey( &ibChunk, pfucbLV->kdfCurr.key );
		Assert( ibLongValue >= ibChunk );
		Assert( ibLongValue < ibChunk + cbChunk );
		
		const ULONG	ib	= ibLongValue - ibChunk;
		const ULONG	cb	= (ULONG)min( cbChunk - ib, pbMax - pb );

		Assert( ib < cbChunk );
		Assert( cb <= cbChunk );

		//	special case overwrite of whole chunk
		if ( cb == cbChunk )
			{
			// Start overwriting at the beginning of a chunk.
			Assert( ibLongValue == ibChunk );
			data.SetCb( cb );
			data.SetPv( pb );
			}
		else
			{
#ifdef DEBUG
			// Should only do partial chunks for the first and last chunks.
			cPartialChunkOverwrite++;
			Assert( cPartialChunkOverwrite <= 2 );
#endif
			UtilMemCpy( pvbf, pfucbLV->kdfCurr.data.Pv(), cbChunk );
			UtilMemCpy( reinterpret_cast<BYTE *>( pvbf ) + ib, pb, cb );
			data.SetCb( cbChunk );
			data.SetPv( pvbf );
			}
		CallR( ErrDIRReplace( pfucbLV, data, fDIRLogChunkDiffs ) );
		
		pb += cb;
		ibLongValue += cb;

		//  we mey have written the entire long value
		Assert( pb <= pbMax );
		if ( pbMax == pb )
			{
			return JET_errSuccess;
			}

		//  goto the next chunk
		err = ErrDIRNext( pfucbLV, fDIRNull );
		if ( err < 0 )
			{
			if ( JET_errNoCurrentRecord == err )
				break;
			else
				return err;
			}

		//  make sure we are still on the same long value
		err = ErrLVCheckDataNodeOfLid( pfucbLV, lid );
		if ( err < 0 )
			{
			CallS( ErrDIRRelease( pfucbLV ) );
			return err;
			}
		else if ( wrnLVNoMoreData == err )
			{
			break;
			}

		//	All overwrites beyond the first should happen at the beginning
		//	of a chunk.
		Assert( ibLongValue % g_cbColumnLVChunkMost == 0 );
		}

	// If we got here, we ran out of stuff to overwrite before we ran out
	// of new data.  Append the new data.
	Assert( pb < pbMax );
	data.SetPv( pb );
	data.SetCb( pbMax - pb );
	err = ErrLVAppend(
				pfucbLV,
				lid,
				ibLongValue,
				&data,
				pvbf );

	return err;
	}

						
//  ================================================================
ERR ErrRECAOSeparateLV(
	FUCB		*pfucb,
	LID			*plid,
	const DATA	*pdataField,
	const ULONG	ibLongValue,
	const ULONG	ulMax,
	const LVOP	lvop )
//  ================================================================
//
//	Appends, overwrites and sets length of separate long value data.
//
//-
	{
	ASSERT_VALID( pfucb );
	Assert( plid );
	Assert( pfucb->ppib->level > 0 );

	// Null and zero-length are handled by RECSetLongField
	Assert( lvopInsert == lvop
			|| lvopInsertZeroedOut == lvop
			|| lvopReplace == lvop
			|| lvopAppend == lvop
			|| lvopResize == lvop
			|| lvopOverwriteRange == lvop
			|| lvopOverwriteRangeAndResize == lvop );

#ifdef DEBUG
	//	if we are setting size, pv may be NULL with non-zero cb
	pdataField->AssertValid( lvopInsertZeroedOut == lvop || lvopResize == lvop );
#endif	//	DEBUG

	// NULL and zero-length cases are handled by ErrRECSetLongField().
	Assert( pdataField->Cb() > 0 );

	ERR			err				= JET_errSuccess;
	ERR			wrn				= JET_errSuccess;
	FUCB	   	*pfucbLV		= pfucbNil;
	VOID		*pvbf			= NULL;
	LVROOT		lvroot;
	DATA	   	data;
	data.SetCb( sizeof(LVROOT) );
	data.SetPv( &lvroot );
	ULONG		ulVerRefcount;
	LID			lidCurr			= *plid;

	//	open cursor on LONG directory
	//	seek to this field instance
	//	find current field size
	//	add new field segment in chunks no larger than max chunk size
	CallR( ErrDIROpenLongRoot( pfucb, &pfucbLV ) );
	Assert( wrnLVNoLongValues != err );
	Assert( pfucbNil != pfucbLV );

	//	move to start of long field instance
	Call( ErrDIRDownLV( pfucbLV, *plid, fDIRNull ) );
	UtilMemCpy( &lvroot, pfucbLV->kdfCurr.data.Pv(), sizeof(LVROOT) );
	
	ulVerRefcount = UlLVIVersionedRefcount( pfucbLV );
	Assert( ulVerRefcount > 0 );	// versioned refcount must be non-zero, otherwise we couldn't see it

	//	get offset of last byte from long value size
	ULONG		ulSize;
	ULONG	   	ulNewSize;
#ifdef DEBUG
	ULONG		ulRefcountDBG;
	ulRefcountDBG	= lvroot.ulReference;
#endif	
	ulSize			= lvroot.ulSize;

	if ( ibLongValue > ulSize
		&& ( lvopOverwriteRange == lvop || lvopOverwriteRangeAndResize == lvop ) )
		{
		err = ErrERRCheck( JET_errColumnNoChunk );
		goto HandleError;
		}
	
	//  if we have more than one reference we have to burst the long value
	if ( ulVerRefcount > 1 )
		{
		Assert( *plid == lidCurr );
		Call( ErrRECIBurstSeparateLV( pfucb, pfucbLV, plid ) );	// lid will change
		Assert( JET_wrnCopyLongValue == err );
		Assert( *plid > lidCurr );
 		wrn = err;
		AssertLVRootNode( pfucbLV, *plid );
		UtilMemCpy( &lvroot, pfucbLV->kdfCurr.data.Pv(), sizeof(LVROOT) );
		Assert( 1 == lvroot.ulReference );
		}

	Assert( ulSize == lvroot.ulSize );

	switch ( lvop )
		{
		case lvopInsert:
		case lvopInsertZeroedOut:
		case lvopReplace:
			Assert( 0 == ulSize );		// replace = delete old + insert new (thus, new LV currently has size 0)
		case lvopResize:
			ulNewSize = pdataField->Cb();
			break;
			
		case lvopOverwriteRange:
			ulNewSize = max( ibLongValue + pdataField->Cb(), ulSize );
			break;
		
		case lvopOverwriteRangeAndResize:
			ulNewSize = ibLongValue + pdataField->Cb();
			break;
			
		case lvopAppend:
			ulNewSize = ulSize + pdataField->Cb();
			break;

		case lvopNull:
		case lvopInsertNull:
		case lvopInsertZeroLength:
		case lvopReplaceWithNull:
		case lvopReplaceWithZeroLength:
		default:
			Assert( fFalse );
			break;
		}
		
	//	check for field too long
	if ( ( ulMax > 0 && ulNewSize > ulMax ) || ulNewSize > LONG_MAX )
		{
		err = ErrERRCheck( JET_errColumnTooBig );
		goto HandleError;
		}

	//	force refcount to 1, because after a successful replace, that's
	//	what the refcount should be -- anything else will cause a conflict
	lvroot.ulReference = 1;
	
	//	replace long value size with new size (even if the size didn't change).
	//	this also 'locks' the long value for us
	lvroot.ulSize = ulNewSize;
	Assert( sizeof(LVROOT) == data.Cb() );
	Assert( &lvroot == data.Pv() );
	err = ErrDIRReplace( pfucbLV, data, fDIRNull );
	if ( err < 0 )
		{
		if ( JET_errWriteConflict != err )
			goto HandleError;

		//  write conflict means someone else was modifying/deltaing
		//  the long value

		//	if ulVerRefcount was greater than 1, we would have burst
		//	and thus should not have write-conflicted
		Assert( 1 == ulVerRefcount );

		//  we lost the page during the write conflict
		Call( ErrDIRGet( pfucbLV ) );

		if ( FDIRDeltaActiveNotByMe( pfucbLV, OffsetOf( LVROOT, ulReference ) ) )
			{
			//  we lost our latch and someone else entered the page and did a delta
			//  this should only happen if we didn't burst above
			Assert( JET_wrnCopyLongValue != wrn );
			Assert( *plid == lidCurr );
			Call( ErrRECIBurstSeparateLV( pfucb, pfucbLV, plid ) );	// lid will change
			Assert( JET_wrnCopyLongValue == err );
			Assert( *plid > lidCurr );
			wrn = err;
			AssertLVRootNode( pfucbLV, *plid );
			UtilMemCpy( &lvroot, pfucbLV->kdfCurr.data.Pv(), sizeof(LVROOT) );
			Assert( 1 == lvroot.ulReference );
			lvroot.ulSize = ulNewSize;
			Assert( sizeof(LVROOT) == data.Cb() );
			Assert( &lvroot == data.Pv() );
			Call( ErrDIRReplace( pfucbLV, data, fDIRNull ) );
			
			//	if deref write-conflicts, it means someone else is
			//	already updating this record
			Assert( !Pcsr( pfucb )->FLatched() );
			Call( ErrRECAffectSeparateLV( pfucb, &lidCurr, fLVDereference ) );
			Assert( JET_wrnCopyLongValue != err );
			}
		else
			{
			// Another thread doing replace or delete on same LV.
			CallS( ErrDIRRelease( pfucbLV ) );
			err = ErrERRCheck( JET_errWriteConflict );
			goto HandleError;
			}
		}
	else if ( ulVerRefcount > 1 )
		{
		//	bursting was successful - update refcount on original LV.
		//	if this deref subsequently write-conflicts, it means
		//	someone else is already updating this record.
		Assert( !Pcsr( pfucb )->FLatched() );
		Call( ErrRECAffectSeparateLV( pfucb, &lidCurr, fLVDereference ) );
		Assert( JET_wrnCopyLongValue != err );
		}

	Assert( 1 == lvroot.ulReference );

	//	allocate buffer for partial overwrite caching.
	Assert( NULL == pvbf );
	BFAlloc( &pvbf );
	
	switch( lvop )
		{
		case lvopInsert:
		case lvopReplace:
			Assert( 0 == ulSize );
			DIRUp( pfucbLV );
			Call( ErrLVAppendChunks(
						pfucbLV,
						*plid,
						0,
						reinterpret_cast<BYTE *>( pdataField->Pv() ),
						pdataField->Cb() ) );
			break;

		case lvopResize:
			//	TRUNCATE long value
			if ( ulNewSize < ulSize )
				{
				Call( ErrLVTruncate( pfucbLV, *plid, ulNewSize, pvbf ) );
				}
			else if ( ulNewSize > ulSize )
				{
				if ( ulSize > 0 )
					{
					//	EXTEND long value with chunks of 0s
					
					//  seek to the maximum offset to get the last chunk
					//	long value chunk tree may be empty
					const ULONG ulOffsetLast = ( ( ulSize - 1 ) / g_cbColumnLVChunkMost ) * g_cbColumnLVChunkMost;
					Call( ErrDIRDownLV( pfucbLV, *plid, ulOffsetLast, fDIRFavourPrev ) );
					AssertLVDataNode( pfucbLV, *plid, ulOffsetLast );

					const ULONG	cbUsedInChunk		= pfucbLV->kdfCurr.data.Cb();
					Assert( cbUsedInChunk <= g_cbColumnLVChunkMost );
					if ( cbUsedInChunk < g_cbColumnLVChunkMost )
						{
						const ULONG	cbAppendToChunk	= min(
														ulNewSize - ulSize,
														g_cbColumnLVChunkMost - cbUsedInChunk );
						
						UtilMemCpy( pvbf, pfucbLV->kdfCurr.data.Pv(), cbUsedInChunk );
						memset( (BYTE *)pvbf + cbUsedInChunk, 0, cbAppendToChunk );
			
						ulSize += cbAppendToChunk;

						Assert( cbUsedInChunk + cbAppendToChunk <= g_cbColumnLVChunkMost );
						
						data.SetPv( pvbf );
						data.SetCb( cbUsedInChunk + cbAppendToChunk );
						Call( ErrDIRReplace( pfucbLV, data, fDIRLogChunkDiffs ) );
						}
					else
						{
						Assert( ulSize % g_cbColumnLVChunkMost == 0 );
						}

					Assert( ulSize <= ulNewSize );
					}

				else
					{
					Call( ErrDIRDownLV( pfucbLV, *plid, fDIRNull ) );

					//  the LV is size 0 and has a root only. we have landed on the root
					AssertLVRootNode( pfucbLV, *plid );

					//	we will be appending zerout-out chunks to this LV
					Assert( ulSize < ulNewSize );
					}

				if ( ulSize < ulNewSize )
					{
					Assert( ulSize % g_cbColumnLVChunkMost == 0 );
					Call( ErrLVAppendZeroedOutChunks(
							pfucbLV,
							*plid,
							ulSize,
							ulNewSize - ulSize,
							pvbf ) );
					}
				}
			else
				{
				// no size change required
				err = JET_errSuccess;
				}
			break;

		case lvopInsertZeroedOut:
			Assert( 0 == ulSize );
			Call( ErrLVAppendZeroedOutChunks(
						pfucbLV,
						*plid,
						ulSize,
						pdataField->Cb(),
						pvbf ) );
			break;

		case lvopAppend:
			Call( ErrLVAppend(
						pfucbLV,
						*plid,
						ulSize,
						pdataField,
						pvbf ) );
			break;

		case lvopOverwriteRangeAndResize:
			if ( ulNewSize < ulSize )
				{
				Call( ErrLVTruncate( pfucbLV, *plid, ulNewSize, pvbf ) );
				}
			//	Fall through to do the actual overwrite:
			
		case lvopOverwriteRange:
			if ( 0 == ulSize )
				{
				//	may hit this case if we're overwriting a zero-length column
				//	that was force-separated
				Assert( 0 == ibLongValue );
				DIRUp( pfucbLV );
				Call( ErrLVAppendChunks(
							pfucbLV,
							*plid,
							0,
							reinterpret_cast<BYTE *>( pdataField->Pv() ),
							pdataField->Cb() ) );
				}
			else if ( ibLongValue == ulSize )
				{
				//	pathological case of overwrite starting exactly at the point where
				//	the LV ends - this degenerates to an append
				Call( ErrLVAppend(
							pfucbLV,
							*plid,
							ulSize,
							pdataField,
							pvbf ) );
				}
			else
				{
				Call( ErrLVOverwriteRange(
							pfucbLV,
							*plid,
							ibLongValue,
							pdataField,
							pvbf ) );
				}
			break;

		case lvopNull:
		case lvopInsertNull:
		case lvopInsertZeroLength:
		case lvopReplaceWithNull:
		case lvopReplaceWithZeroLength:
		default:
			Assert( fFalse );
			break;
		}


#ifdef DEBUG
	{
		//	move to start of long field instance
		Call( ErrDIRDownLV( pfucbLV, *plid, fDIRNull ) );
		UtilMemCpy( &lvroot, pfucbLV->kdfCurr.data.Pv(), sizeof(LVROOT) );
		Assert( lvroot.ulSize == ulNewSize );
		Assert( ulNewSize > 0 );

		ULONG ulOffsetLastT;
		ulOffsetLastT = ( ( ulNewSize - 1 ) / g_cbColumnLVChunkMost ) * g_cbColumnLVChunkMost;
		Call( ErrDIRDownLV( pfucbLV, *plid, ulOffsetLastT, fDIRFavourPrev ) );

		ULONG ulOffsetT;
		OffsetFromKey( &ulOffsetT, pfucbLV->kdfCurr.key );
		Assert( ulOffsetLastT == ulOffsetT );

		LID		lidT;
		LidFromKey( &lidT, pfucbLV->kdfCurr.key );
		Assert( *plid == lidT );

		ULONG	ibChunk;
		OffsetFromKey( &ibChunk, pfucbLV->kdfCurr.key );

		Assert( ulNewSize == ibChunk + pfucbLV->kdfCurr.data.Cb() );

		err = ErrDIRNext( pfucbLV, fDIRNull );
		if( JET_errNoCurrentRecord == err )
			{
			err = JET_errSuccess;
			}
		else if ( err < 0 )
			{
			goto HandleError;
			}
		else
			{
			LidFromKey( &lidT, pfucbLV->kdfCurr.key );
			Assert( *plid != lidT );
			}
	}
#endif


HandleError:
	if ( NULL != pvbf )
		{
		BFFree( pvbf );
		}

	// discard temporary FUCB
	Assert( pfucbNil != pfucbLV );
	DIRClose( pfucbLV );

	//	return warning if no failure	
	err = ( err < JET_errSuccess ) ? err : wrn;
	return err;
	}


//  ================================================================
ERR ErrRECAOIntrinsicLV(
	FUCB			*pfucb,
	const COLUMNID	columnid,
	const ULONG		itagSequence,
	const DATA		*pdataColumn,
	const DATA		*pdataNew,
	const ULONG		ibLongValue,
	const LVOP		lvop
#ifdef INTRINSIC_LV
	, BYTE 			*rgb 
#endif // INTRINSIC_LV
	)
//  ================================================================
	{
	ASSERT_VALID( pdataColumn );

//	Can't perform this check on the FUCB, because it may be a fake FUCB used
//	solely as a placeholder while building the default record.	
///	ASSERT_VALID( pfucb );

	Assert( pdataNew->Cb() > 0 );
	Assert( pdataNew->Cb() <= cbLVIntrinsicMost );
#ifdef INTRINSIC_LV
	Assert( rgb != NULL );
#else // INTRINSIC_LV
	BYTE		rgb[ cbLVIntrinsicMost ];
#endif // INTRINSIC_LV	
	DATA 		dataSet;

	dataSet.SetPv( rgb );

	
	switch ( lvop )
		{
		case lvopInsert:
		case lvopReplace:
			Assert( pdataColumn->FNull() );
			
			UtilMemCpy( rgb, pdataNew->Pv(), pdataNew->Cb() );
			dataSet.SetCb( pdataNew->Cb() );
			break;
			
		case lvopInsertZeroedOut:
			Assert( pdataColumn->FNull() );

			memset( rgb, 0, pdataNew->Cb() );
			dataSet.SetCb( pdataNew->Cb() );
			break;

		case lvopResize:
			Assert( pdataColumn->Cb() <= cbLVIntrinsicMost );
			UtilMemCpy(
				rgb,
				pdataColumn->Pv(),
				min( pdataNew->Cb(), pdataColumn->Cb() ) );
			if ( pdataNew->Cb() > pdataColumn->Cb() )
				{
				memset(
					rgb + pdataColumn->Cb(),
					0,
					pdataNew->Cb() - pdataColumn->Cb() );
				}
			dataSet.SetCb( pdataNew->Cb() );
			break;

		case lvopOverwriteRange:
		case lvopOverwriteRangeAndResize:
			Assert( pdataColumn->Cb() <= cbLVIntrinsicMost );
			if ( ibLongValue > pdataColumn->Cb() )
				{
				return ErrERRCheck( JET_errColumnNoChunk );
				}
			UtilMemCpy( rgb, pdataColumn->Pv(), pdataColumn->Cb() );
			UtilMemCpy(
				rgb + ibLongValue,
				pdataNew->Pv(),
				pdataNew->Cb() );
			if ( lvopOverwriteRange == lvop
				&& pdataColumn->Cb() > ibLongValue + pdataNew->Cb() )
				{
				dataSet.SetCb( pdataColumn->Cb() );
				}
			else
				{
				dataSet.SetCb( ibLongValue + pdataNew->Cb() );
				}
			break;			

		case lvopAppend:
			Assert( pdataColumn->Cb() <= cbLVIntrinsicMost );
			UtilMemCpy( rgb, pdataColumn->Pv(), pdataColumn->Cb() );
			UtilMemCpy( rgb + pdataColumn->Cb(), pdataNew->Pv(), pdataNew->Cb() );
			dataSet.SetCb( pdataColumn->Cb() + pdataNew->Cb() );
			break;

		case lvopNull:
		case lvopInsertNull:
		case lvopInsertZeroLength:
		case lvopReplaceWithNull:
		case lvopReplaceWithZeroLength:
		default:
			Assert( fFalse );
			break;
		}

	Assert( dataSet.Cb() <= cbLVIntrinsicMost );

	return ErrRECSetColumn( pfucb, columnid, itagSequence, &dataSet );
	}


//  ================================================================
LOCAL VOID LVIGetProperLVImage(
	PIB			* const ppib,
	const FUCB 	* const pfucb,
	FUCB		* const pfucbLV
	)
//  ================================================================
	{
	Assert( FNDVersion( pfucbLV->kdfCurr ) );	//	no need to call if its not versioned
	
	const BYTE 	*pbImage	= NULL;
	ULONG		cbImage		= 0;

	BYTE		rgbKey[sizeof(LVKEY)];
	BOOKMARK	bookmark;
	
	pfucbLV->kdfCurr.key.CopyIntoBuffer( rgbKey, sizeof( rgbKey ) );
	bookmark.key.prefix.Nullify();
	bookmark.key.suffix.SetPv( rgbKey );
	bookmark.key.suffix.SetCb( pfucbLV->kdfCurr.key.Cb() );
	bookmark.data.Nullify();

	Assert( ppib->level > 0 );
	Assert( trxMax != ppib->trxBegin0 );
	
	Assert( FFUCBUpdateSeparateLV( pfucb ) );
	const RCEID	rceidBegin	= ( FFUCBReplacePrepared( pfucb ) ?
									pfucb->rceidBeginUpdate :
									rceidNull );
	
	//	on a Replace, only way rceidBeginUpdate is not set is if versioning is off
	//	(otherwise, at the very least, we would have a Write-Lock RCE)
	Assert( rceidNull != rceidBegin
		|| !FFUCBReplacePrepared( pfucb )
		|| rgfmp[pfucb->ifmp].FVersioningOff() );

	const BOOL fImage = FVERGetReplaceImage(
					ppib,
					pfucbLV->u.pfcb->Ifmp(),
					pfucbLV->u.pfcb->PgnoFDP(),
					bookmark,
					rceidBegin,
					RCE::RceidLast()+1,
					ppib->trxBegin0,
					trxMax,
					fFalse,	//	always want the before-image
					&pbImage,
					&cbImage
					);
	if( fImage )
		{
		pfucbLV->kdfCurr.data.SetPv( (BYTE *)pbImage );
		pfucbLV->kdfCurr.data.SetCb( cbImage );
		}
	}


//  ================================================================
ERR ErrRECRetrieveSLongField(
	FUCB			*pfucb,
	LID				lid,
	BOOL			fAfterImage,
	ULONG			ibGraphic,
	BYTE			*pb,
	ULONG			cbMax,
	ULONG			*pcbActual,	//	pass NULL to force LV comparison instead of retrieval
	JET_PFNREALLOC	pfnRealloc,
	void*			pvReallocContext
	)
//  ================================================================
//
//  opens cursor on LONG tree of table
//	seeks to given lid
//	copies LV from given ibGraphic into given buffer
//	must not use given FUCB to retrieve
//	also must release latches held on LONG tree and close cursor on LONG
//  pb call be null -- in that case we just retrieve the full size of the
//  long value
//
//  If fFalse is passed in for fAfterImage we go to the version store to adjust
//  the FUCB to point at the before image of any replaces the session has done
//
//-
	{
	ASSERT_VALID( pfucb );
	Assert( pfucb->u.pfcb->Ptdb() != ptdbNil );
	AssertDIRNoLatch( pfucb->ppib );

	ERR			err				= JET_errSuccess;
	BOOL		fFreeBuffer		= fFalse;
	FUCB		*pfucbLV		= NULL;
	BYTE		*pbMax;
	ULONG		cb;
	ULONG		ulActual;
	ULONG		ulOffset;
	ULONG		ib;
	BOOL		fInTransaction	= fFalse;
 	const BOOL	fComparing		= ( NULL == pcbActual );

	//	begin transaction for read consistency
	if ( 0 == pfucb->ppib->level )
		{
		Call( ErrDIRBeginTransaction( pfucb->ppib, JET_bitTransactionReadOnly ) );
		fInTransaction = fTrue;
		}

	//	open cursor on LONG, seek to long field instance
	//	seek to ibGraphic
	//	copy data from long field instance segments as
	//	necessary
	Call( ErrDIROpenLongRoot( pfucb, &pfucbLV ) );
	Assert( wrnLVNoLongValues != err );

	if( ibGraphic < g_cbColumnLVChunkMost
		&& NULL != pb )
		{
		//  in a lot of cases the chunk we want may be on the next page. always preread the next page
		const CPG cpgPreread = 2;
		FUCBSetPrereadForward( pfucbLV, cpgPreread );
		}

	//	move to long field instance
	Call( ErrDIRDownLV( pfucbLV, lid, fDIRNull ) );
	if ( !fAfterImage && FNDPossiblyVersioned( pfucbLV, Pcsr( pfucbLV ) ) )
		{
		LVIGetProperLVImage( pfucbLV->ppib, pfucb, pfucbLV );
		}
	
	ulActual = ( reinterpret_cast<LVROOT*>( pfucbLV->kdfCurr.data.Pv() )->ulSize );

	//	set return value cbActual
	if ( ibGraphic >= ulActual )
		{
		if ( NULL != pcbActual )
			*pcbActual = 0;

		if ( fComparing && 0 == cbMax )
			err = ErrERRCheck( JET_errMultiValuedDuplicate );	//	both are zero-length
		else
			err = JET_errSuccess;

		goto HandleError;
		}
	else
		{
		ulActual -= ibGraphic;

		if ( NULL != pcbActual )
			*pcbActual = ulActual;
		}

	if ( fComparing )
		{
		if ( ulActual != cbMax )
			{
			err = JET_errSuccess;		//	size is different, so LV must be different
			goto HandleError;
			}
		}
	else if ( NULL == pb )		//  special code to handle NULL buffer. just return the size
		{
		goto HandleError;
		}

	//  if we are using the pfnRealloc hack to read up to cbMax bytes of the LV
	//  then grab a buffer large enough to store the data to return and place
	//  a pointer to that buffer in the output buffer.  we will then rewrite
	//  the args to look like a normal LV retrieval
	//
	//  NOTE:  on an error, the allocated memory will NOT be freed

	if ( pfnRealloc )
		{
		Alloc( *((BYTE**)pb) = (BYTE*)pfnRealloc( pvReallocContext, NULL, min( cbMax, ulActual ) ) );
		fFreeBuffer	= fTrue;					//  free pb on an error
		pb			= *((BYTE**)pb);  			//  redirect pv to the new buffer
		cbMax		= min( cbMax, ulActual );	//  fixup cbMax to be the size of the new buffer
		}

	//  try and preread all of the pages that we will need. remember to preread a page with 
	//  a partial chunk at the end
	CPG 	cpgPreread;
	ULONG	ibOffset;
	BOOL 	fPreread;
	ULONG	cbPreread;
	ibOffset	= ( ibGraphic / g_cbColumnLVChunkMost ) *  g_cbColumnLVChunkMost;
	cbPreread	= min( cbMax, ulActual - ibOffset );
	cpgPreread 	= ( cbPreread + g_cbColumnLVChunkMost - 1 ) / g_cbColumnLVChunkMost;

	if( cpgPreread > 2 || 0 != ibGraphic )
		{
		if( cpgPreread > 256 )
			{
			//  this is a _really_ long-value. set the FUCB to sequential
			FUCBSetSequential( pfucbLV );
			}
		FUCBSetPrereadForward( pfucbLV, cpgPreread );
		fPreread = fTrue;
		}
	else
		{
		FUCBResetPreread( pfucbLV );
		fPreread = fFalse;
		}

	//	move to ibGraphic in long field
	if( ibGraphic < g_cbColumnLVChunkMost
		&& !fPreread )
		{
		//  the chunk we want is offset 0, which is the next chunk. do a DIRNext to avoid the seek
		Call( ErrDIRNext( pfucbLV, fDIRNull ) );
		if ( !fAfterImage && FNDPossiblyVersioned( pfucbLV, Pcsr( pfucbLV ) ) )
			{
			LVIGetProperLVImage( pfucbLV->ppib, pfucb, pfucbLV );
			}

		Call( ErrLVCheckDataNodeOfLid( pfucbLV, lid ) );
		OffsetFromKey( &ulOffset, pfucbLV->kdfCurr.key );
		if( 0 != ulOffset )
			{
			LVReportCorruptedLV( pfucbLV, lid );
			FireWall();
			Call( ErrERRCheck( JET_errLVCorrupted ) );
			}
		}
	else
		{
		Call( ErrDIRDownLV( pfucbLV, lid, ibGraphic, fDIRNull ) );
		if ( !fAfterImage && FNDPossiblyVersioned( pfucbLV, Pcsr( pfucbLV ) ) )
			{
			LVIGetProperLVImage( pfucbLV->ppib, pfucb, pfucbLV );
			}
		}
	Assert( sizeof(LVKEY) == pfucbLV->kdfCurr.key.Cb() );
	OffsetFromKey( &ulOffset, pfucbLV->kdfCurr.key );
	Assert( ulOffset + pfucbLV->kdfCurr.data.Cb() - ibGraphic <= g_cbColumnLVChunkMost );
	cb = min( ulOffset + pfucbLV->kdfCurr.data.Cb() - ibGraphic, cbMax );
	
	//	set pbMax to the largest pointer that we can read
	pbMax = pb + min( ulActual, cbMax );

	//	offset in chunk
	ib = ibGraphic - ulOffset;

	if ( fComparing )
		{
		if ( 0 != memcmp( pb, reinterpret_cast<BYTE *>( pfucbLV->kdfCurr.data.Pv() ) + ib, cb ) )
			{
			err = JET_errSuccess;			//	diff found
			goto HandleError;
			}
		}
	else
		{
		UtilMemCpy( pb, reinterpret_cast<BYTE *>( pfucbLV->kdfCurr.data.Pv() ) + ib, cb );
		}
	pb += cb;

	//	copy further chunks
	while ( pb < pbMax )
		{
		err = ErrDIRNext( pfucbLV, fDIRNull );
		if ( !fAfterImage && FNDPossiblyVersioned( pfucbLV, Pcsr( pfucbLV ) ) )
			{
			LVIGetProperLVImage( pfucbLV->ppib, pfucb, pfucbLV );
			}

		//	It can only failed when resource failed.
#ifdef DEBUG		
		// something like CallSx( err , "JET_errDiskIO && JET_errOutOfMemory" );
		if ( JET_errDiskIO != err && JET_errOutOfMemory != err )
			{
			CallS( err );
			}
#endif // DEBUG		

		Call( err );

		//  make sure we are still on the same long value
		Call( ErrLVCheckDataNodeOfLid( pfucbLV, lid ) );
		if ( wrnLVNoMoreData == err )
			{
			break;
			}

		cb = (ULONG)min( pfucbLV->kdfCurr.data.Cb(), pbMax - pb );
		Assert( cb <= g_cbColumnLVChunkMost );
		
		if ( fComparing )
			{
			if ( 0 != memcmp( pb, pfucbLV->kdfCurr.data.Pv(), cb ) )
				{
				err = JET_errSuccess;		//	diff found
				goto HandleError;
				}
			}
		else
			{
			UtilMemCpy( pb, pfucbLV->kdfCurr.data.Pv(), cb );
			}
		pb += cb;
		}

	err = ( fComparing ? ErrERRCheck( JET_errMultiValuedDuplicate ) : JET_errSuccess );

HandleError:
	//  if we are using the pfnRealloc hack and there was an error then free the buffer
	if ( fFreeBuffer && err < JET_errSuccess )
		{
		pfnRealloc( pvReallocContext, pb, 0 );
		}
	
	//	discard temporary FUCB
	if ( pfucbLV != pfucbNil )
		{
		DIRClose( pfucbLV );
		}

	//	commit -- we have done no updates must succeed
	if ( fInTransaction )
		{
		CallS( ErrDIRCommitTransaction( pfucb->ppib, NO_GRBIT ) );
		}

	AssertDIRNoLatch( pfucb->ppib );
	return err;
	}


//  ================================================================
ERR ErrRECRetrieveSLongFieldRefCount(
	FUCB	*pfucb,
	LID		lid,
	BYTE	*pb,
	ULONG	cbMax,
	ULONG	*pcbActual
	)
//  ================================================================
//
//  opens cursor on LONG tree of table
//	seeks to given lid
//  returns the reference count on the LV
//
//-
	{
	ASSERT_VALID( pfucb );
	Assert( pcbActual );
	Assert( pfucb->u.pfcb->Ptdb() != ptdbNil );
	AssertDIRNoLatch( pfucb->ppib );

	ERR			err				= JET_errSuccess;
	FUCB		*pfucbLV		= NULL;
	BOOL		fInTransaction	= fFalse;
 
	//	begin transaction for read consistency
	if ( 0 == pfucb->ppib->level )
		{
		Call( ErrDIRBeginTransaction( pfucb->ppib, JET_bitTransactionReadOnly ) );
		fInTransaction = fTrue;
		}

	Call( ErrDIROpenLongRoot( pfucb, &pfucbLV ) );
	Assert( wrnLVNoLongValues != err );

	//	move to long field instance
	Call( ErrDIRDownLV( pfucbLV, lid, fDIRNull ) );

	const LVROOT* plvroot;
	plvroot = reinterpret_cast<LVROOT*>( pfucbLV->kdfCurr.data.Pv() );

	if ( cbMax < sizeof( plvroot->ulReference ) )
		{
		err = ErrERRCheck( JET_errInvalidBufferSize );
		goto HandleError;
		}
			
	*pcbActual = sizeof( plvroot->ulReference );
	*( reinterpret_cast<Unaligned< ULONG > *>( pb ) ) = plvroot->ulReference;
	
HandleError:
	//	discard temporary FUCB
	if ( pfucbLV != pfucbNil )
		{
		DIRClose( pfucbLV );
		}

	//	commit -- we have done no updates must succeed
	if ( fInTransaction )
		{
		CallS( ErrDIRCommitTransaction( pfucb->ppib, NO_GRBIT ) );
		}

	AssertDIRNoLatch( pfucb->ppib );
	return err;	
	}


//  ================================================================
ERR ErrRECGetLVImage(
	FUCB 		*pfucb,
	const LID	lid,
	const BOOL	fAfterImage,
	BYTE 		*pb,
	const ULONG	cbMax,
	ULONG 		*pcbActual
	)
//  ================================================================
	{
	ERR			err			= JET_errSuccess;
	PIB			*ppib		= pfucb->ppib;
	FUCB		*pfucbLV	= pfucbNil;
	BOOL		fImage		= fFalse;
	const BYTE 	*pbImage	= NULL;

	// This function only used to retrieve LVs for index update.
	Assert( JET_cbPrimaryKeyMost == cbMax
		|| JET_cbSecondaryKeyMost == cbMax );

	*pcbActual = 0;
	
	Assert( !Pcsr( pfucb )->FLatched() );
	Assert( ( ppib->level > 0 && trxMax != ppib->trxBegin0 )
		|| rgfmp[pfucb->ifmp].FVersioningOff() );
	
	CallR( ErrDIROpenLongRoot( pfucb, &pfucbLV ) );
	Assert( wrnLVNoLongValues != err );
	Assert( pfcbNil != pfucbLV->u.pfcb );
	Assert( pfucbLV->u.pfcb->FTypeLV() );

	// Cache current image in case we don't find any other.
	Call( ErrDIRDownLV( pfucbLV, lid, ulLVOffsetFirst, fDIRAllNode ) );
	Assert( Pcsr( pfucbLV )->FLatched() );
	if ( FNDPossiblyVersioned( pfucbLV, Pcsr( pfucbLV ) ) )
		{
		LVKEY		lvkey 		= LVKeyFromLidOffset( lid, ulLVOffsetFirst );
		BOOKMARK	bookmark;
		
		bookmark.key.prefix.Nullify();
		bookmark.key.suffix.SetPv( &lvkey );
		bookmark.key.suffix.SetCb( sizeof( LVKEY ) );
		bookmark.data.Nullify();

		Assert( ppib->level > 0 );
		Assert( trxMax != ppib->trxBegin0 );
		
		//	an RCEID that's null forces retrieval of the after-image
		const RCEID	rceidBegin	= ( FFUCBUpdateSeparateLV( pfucb ) && FFUCBReplacePrepared( pfucb ) ?
											pfucb->rceidBeginUpdate :
											rceidNull );

		//	on a Replace, only way rceidBeginUpdate is not set is if versioning is off
		//	(otherwise, at the very least, we would have a Write-Lock RCE)
		Assert( rceidNull != rceidBegin
			|| !FFUCBReplacePrepared( pfucb )
			|| !FFUCBUpdateSeparateLV( pfucb )
			|| rgfmp[pfucb->ifmp].FVersioningOff() );

		fImage = FVERGetReplaceImage(
						ppib,
						pfucbLV->u.pfcb->Ifmp(),
						pfucbLV->u.pfcb->PgnoFDP(),
						bookmark,
						rceidBegin,
						RCE::RceidLast()+1,
						ppib->trxBegin0,
						trxMax,
						fAfterImage,
						&pbImage,
						pcbActual
						);
		}

	if ( !fImage )
		{
		*pcbActual = pfucbLV->kdfCurr.data.Cb();
		UtilMemCpy( pb, pfucbLV->kdfCurr.data.Pv(), min( cbMax, *pcbActual ) );
		}
	else
		{
		Assert( NULL != pbImage );
		UtilMemCpy( pb, pbImage, min( cbMax, *pcbActual ) );		
		}


HandleError:
	Assert( pfucbNil != pfucbLV );
	DIRClose( pfucbLV );
	
	Assert( !Pcsr( pfucb )->FLatched() );
		
	return err;
	}
	


//  ================================================================
ERR ErrRECGetLVImageOfRCE(
	FUCB 		*pfucb,
	const LID 	lid,
	RCE			*prce,
	const BOOL	fAfterImage,
	BYTE 		*pb,
	const ULONG	cbMax,
	ULONG 		*pcbActual
	)
//  ================================================================
	{
	ERR			err			= JET_errSuccess;
	FUCB		*pfucbLV	= pfucbNil;
	BOOL		fImage		= fFalse;
	const BYTE * pbImage	= NULL;

	// This function only used to retrieve LVs for index update.
	Assert( JET_cbPrimaryKeyMost == cbMax
		|| JET_cbSecondaryKeyMost == cbMax );

	*pcbActual = 0;
	
	Assert( !Pcsr( pfucb )->FLatched() );
	Assert( pfucb->ppib->level > 0 );
	
	CallR( ErrDIROpenLongRoot( pfucb, &pfucbLV ) );
	Assert( wrnLVNoLongValues != err );
	Assert( pfcbNil != pfucbLV->u.pfcb );
	Assert( pfucbLV->u.pfcb->FTypeLV() );

	// Cache current image in case we don't find any other.
	Call( ErrDIRDownLV( pfucbLV, lid, ulLVOffsetFirst, fDIRAllNode ) );
	Assert( Pcsr( pfucbLV )->FLatched() );
	if ( FNDPossiblyVersioned( pfucbLV, Pcsr( pfucbLV ) ) )
		{
		PIB			*ppib;
		RCEID		rceidBegin;
		LVKEY		lvkey 		= LVKeyFromLidOffset( lid, ulLVOffsetFirst );
		BOOKMARK	bookmark;
		
		bookmark.key.prefix.Nullify();
		bookmark.key.suffix.SetPv( &lvkey );
		bookmark.key.suffix.SetCb( sizeof( LVKEY ) );
		bookmark.data.Nullify();

		if ( prce->TrxCommitted() == trxMax )
			{
			Assert( ppibNil != prce->Pfucb()->ppib );
			ppib = prce->Pfucb()->ppib;
			Assert( prce->TrxBegin0() == ppib->trxBegin0 );
			}
		else
			{
			ppib = ppibNil;
			}
		Assert( TrxCmp( prce->TrxBegin0(), prce->TrxCommitted() ) < 0 );
			
		if ( prce->FOperReplace() )
			{
			const VERREPLACE* pverreplace = reinterpret_cast<VERREPLACE*>( prce->PbData() );
			rceidBegin = pverreplace->rceidBeginReplace;
			Assert( rceidNull == rceidBegin || rceidBegin < prce->Rceid() );
			}
		else
			{
			// If not a replace, force retrieval of after-image.
			rceidBegin = rceidNull;
			}

		fImage = FVERGetReplaceImage(
						ppib,
						pfucbLV->u.pfcb->Ifmp(),
						pfucbLV->u.pfcb->PgnoFDP(),
						bookmark,
						rceidBegin,
						prce->Rceid(),
						prce->TrxBegin0(),
						prce->TrxCommitted(),
						fAfterImage,
						&pbImage,
						pcbActual
						);
		}

	if ( !fImage )
		{
		*pcbActual = pfucbLV->kdfCurr.data.Cb();
		UtilMemCpy( pb, pfucbLV->kdfCurr.data.Pv(), min( cbMax, *pcbActual ) );
		}
	else
		{
		Assert( NULL != pbImage );
		UtilMemCpy( pb, pbImage, min( cbMax, *pcbActual ) );		
		}


HandleError:
	Assert( pfucbNil != pfucbLV );
	DIRClose( pfucbLV );
	
	Assert( !Pcsr( pfucb )->FLatched() );
		
	return err;
	}
	

//  ================================================================
LOCAL ERR ErrLVGetNextLID( FUCB * pfucb, FUCB * pfucbLV )
//  ================================================================
//
//  Seek to the end of the LV tree passed in. Set the lidLast of the
//  table tdb to the last lid in the LV tree. We use critLV
//  to syncronize this
//
//  We expect to be in the critical section of the fcb of the table
//
//- 
	{
	Assert( !FAssertLVFUCB( pfucb ) );
	Assert( FAssertLVFUCB( pfucbLV ) );

	ERR		err		= JET_errSuccess;
	ULONG	lidNext;
	DIB		dib;
	
	dib.dirflag = fDIRAllNode;
	dib.pos		= posLast;
	
	err = ErrDIRDown( pfucbLV, &dib );
	switch( err )
		{
		case JET_errSuccess:
			LidFromKey( reinterpret_cast<LID *>( &lidNext ), pfucbLV->kdfCurr.key );
			Assert( lidNext > lidMin );		//	lid's start numbering at 1.
			lidNext++;						//	add one to the last used lid to get the next available one
			pfucb->u.pfcb->Ptdb()->InitUlLongIdLast( lidNext );
			break;

		case JET_errRecordNotFound:
			lidNext = lidMin+1;				//	Empty tree, so first lid is 1
			pfucb->u.pfcb->Ptdb()->InitUlLongIdLast( lidNext );
			err = JET_errSuccess;			//  the tree can be empty
			break;

		default:							//  error condition -- don't set lid
			Assert( err != JET_errNoCurrentRecord );
			Assert( err < 0 );				//	if we get a warning back, we're in a lot of trouble because the caller doesn't handle that case
			break;
		}
	DIRUp( pfucbLV );						//  back to LONG.

	return err;
	}


//  ================================================================
ERR ErrRECSeparateLV(
	FUCB		*pfucb,
	const DATA	*pdataField,
	LID			*plid,
	FUCB		**ppfucb,
	LVROOT		*plvrootInit )
//  ================================================================
//
//	Converts intrinsic long field into separated long field. 
//	Intrinsic long field constraint of length less than cbLVIntrinsicMost bytes
//	means that breakup is unnecessary.  Long field may also be
//	null. At the end a LV with LID==pfucb->u.pfcb->ptdb->ulLongIdLast will have
//  been inserted. 
//
//  ppfucb can be null
//
//-
	{
	ASSERT_VALID( pfucb );
	Assert( !FAssertLVFUCB( pfucb ) );
	ASSERT_VALID( pdataField );
	Assert( plid );

	//	Unless this is for compact/upgrade
///	Assert( pfucb->ppib->level > 0 );

	ERR			err				= JET_errSuccess;
	FUCB 		*pfucbLV		= NULL;
	KEY			key;
	DATA  		data;
	LVROOT		lvroot;

	// Sorts don't have LV's (they would have been materialised).
	Assert( !pfucb->u.pfcb->FTypeSort() );
	
	CallR( ErrDIROpenLongRoot( pfucb, &pfucbLV, fTrue ) );

	BOOL	fBeginTrx = fFalse;

	if ( 0 == pfucb->ppib->level )
		{
		Call( ErrDIRBeginTransaction( pfucb->ppib, NO_GRBIT ) );
		fBeginTrx = fTrue;
		}

	// Lid's are numbered starting at 1.  An lidLast of 0 indicates that we must
	// first retrieve the lidLast.  In the pathological case where there are
	// currently no lid's, we'll go through here anyway, but only the first
	// time (since there will be lid's after that).
	Assert( pfucb->u.pfcb->Ptdb() != ptdbNil );
	if ( pfucb->u.pfcb->Ptdb()->UlLongIdLast() == lidMin )
		{
		// TDB's lidLast hasn't been set yet.  Must seek to it.
		// If successful, the TDB's lidLast will be incremented and
		// the value will be returned in lidNext
		Call( ErrLVGetNextLID( pfucb, pfucbLV ) );
		Assert( pfucb->u.pfcb->IsUnlocked() );
		}

	Call( pfucb->u.pfcb->Ptdb()->ErrGetAndIncrUlLongIdLast( plid ) );
	Assert( *plid > 0 );

	//	add long field id with long value size
	if ( NULL == plvrootInit )
		{
		lvroot.ulReference 	= 1;
		lvroot.ulSize 		= pdataField->Cb();
		data.SetPv( &lvroot );
		}
	else
		{
		data.SetPv( plvrootInit );
		}
		
	data.SetCb( sizeof(LVROOT) );

	BYTE rgbKey[ sizeof( LID ) ];
	KeyFromLong( rgbKey, *plid );
	
	key.prefix.Nullify();
	key.suffix.SetPv( rgbKey );
	key.suffix.SetCb( sizeof( rgbKey ) );
	Call( ErrDIRInsert( pfucbLV, key, data, fDIRNull ) );
	
	//	if dataField is non NULL, add dataField
	if ( pdataField->Cb() > 0 )
		{
		Assert( NULL != pdataField->Pv() );
		LVKEY lvkey = LVKeyFromLidOffset( *plid, ulLVOffsetFirst );
		key.prefix.Nullify();
		key.suffix.SetPv( &lvkey );
		key.suffix.SetCb( sizeof( LVKEY ) );
		Assert( key.Cb() == sizeof(LVKEY) );
		err = ErrDIRInsert( pfucbLV, key, *pdataField, fDIRBackToFather );
		Assert( JET_errKeyDuplicate != err );
		Call( err );
		}

	err = ErrERRCheck( JET_wrnCopyLongValue );

HandleError:
	// discard temporary FUCB, or return to caller if ppfucb is not NULL.
	if ( err < JET_errSuccess || NULL == ppfucb )
		{
		DIRClose( pfucbLV );
		}
	else
		{
		*ppfucb = pfucbLV;
		}

	if ( fBeginTrx )
		{
		if ( err >= JET_errSuccess )
			{
			err = ErrDIRCommitTransaction( pfucb->ppib, NO_GRBIT );
			//  if we fail, fallthrough to Rollback below
			}
		if ( err < JET_errSuccess )
			{
			CallSx( ErrDIRRollback( pfucb->ppib ), JET_errRollbackError );
			}
		}

	Assert( JET_errKeyDuplicate != err );

	return err;
	}


//  ================================================================
ERR ErrRECAffectSeparateLV( FUCB *pfucb, LID *plid, ULONG fLV )
//  ================================================================
	{
	ASSERT_VALID( pfucb );
	Assert( !FAssertLVFUCB( pfucb ) );
	Assert( plid && *plid > lidMin );
	Assert( pfucb->ppib->level > 0 );
 	
	ERR			err			= JET_errSuccess;
	FUCB		*pfucbLV	= NULL;
	
	CallR( ErrDIROpenLongRoot( pfucb, &pfucbLV ) );
	Assert( wrnLVNoLongValues != err );
 	
	//	move to long field instance
	Call( ErrDIRDownLV( pfucbLV, *plid, fDIRNull ) );

	Assert( locOnCurBM == pfucbLV->locLogical );
	Assert( Pcsr( pfucbLV )->FLatched() );

	if ( fLVDereference == fLV )
		{
		const LONG		lDelta		= -1;
		KEYDATAFLAGS	kdf;

		//	cursor's kdfCurr may point to version store,
		//	so must go directly to node to find true refcount
		NDIGetKeydataflags( Pcsr( pfucbLV )->Cpage(), Pcsr( pfucbLV )->ILine(), &kdf );
		Assert( sizeof( LVROOT ) == kdf.data.Cb() );

		const LVROOT * const plvroot = reinterpret_cast<LVROOT *>( kdf.data.Pv() );

		//	don't want count to drop below 0
		if ( 0 == plvroot->ulReference )
			{
			//	someone else must have an active reference to this node
			//	so if this asert fires, it indicates the LV is orphaned
			Assert( FDIRDeltaActiveNotByMe( pfucbLV, OffsetOf( LVROOT, ulReference ) )
				|| FDIRWriteConflict( pfucbLV, operDelta ) );
			err = ErrERRCheck( JET_errWriteConflict );
			goto HandleError;
			}

		Call( ErrDIRDelta(
				pfucbLV,
				OffsetOf( LVROOT, ulReference ),
				&lDelta,
				sizeof( lDelta ),
				NULL,
				0,
				NULL,
				fDIRNull | fDIRDeltaDeleteDereferencedLV ) );
///		Call( ErrDIRGet( pfucbLV ) );
///		if ( 0 == reinterpret_cast<LVROOT*>( pfucbLV->kdfCurr.data.pv )->ulReference
///			&& !FDIRDelta( pfucbLV, OffsetOf( LVROOT, ulReference ) ) )
///			{
///			//	delete long field tree
///			Call( ErrRECDeleteDereferencedLV( pfucbLV ) );
///			}
		}
	else
		{
		Assert( fLVReference == fLV );
		
		//	long value may already be in the process of being
		//	modified for a specific record.  This can only
		//	occur if the long value reference is 1.  If the reference
		//	is 1, then check the root for any version, committed
		//	or uncommitted.  If version found, then burst copy of
		//	old version for caller record.
		const LONG lDelta	= 1;
		err = ErrDIRDelta(
				pfucbLV,
				OffsetOf( LVROOT, ulReference ),
				&lDelta,
				sizeof( lDelta ),
				NULL,
				0,
				NULL,
				fDIRNull | fDIRDeltaDeleteDereferencedLV );
		if ( JET_errWriteConflict == err )
			{
			//  we lost the page during the write conflict
			Call( ErrDIRGet( pfucbLV ) );
			Call( ErrRECIBurstSeparateLV( pfucb, pfucbLV, plid ) );
			}
		}
		
HandleError:
	// discard temporary FUCB
	Assert( pfucbNil != pfucbLV );
	DIRClose( pfucbLV );

	return err;
	}

LOCAL ERR ErrRECDeleteLV( FUCB *pfucbLV, DIRFLAG dirflag )
//
//  Given a FUCB set to the root of a LV, delete the entire LV.
//
	{
	ASSERT_VALID( pfucbLV );
	Assert( FAssertLVFUCB( pfucbLV ) );
	Assert( sizeof(LVROOT) == pfucbLV->kdfCurr.data.Cb() || fGlobalRepair );
	Assert( sizeof(LID) == pfucbLV->kdfCurr.key.Cb() || fGlobalRepair );

	ERR			err			= JET_errSuccess;

 	LID			lidDelete;
	LidFromKey( &lidDelete, pfucbLV->kdfCurr.key );
	//  delete each chunk
	for( ; ; )
		{
		Call( ErrDIRDelete( pfucbLV, dirflag ) );
		err = ErrDIRNext( pfucbLV, fDIRNull );
		if ( err < JET_errSuccess )
			{
			if ( JET_errNoCurrentRecord == err )
				{
				err = JET_errSuccess;	// No more LV chunks. We're done.
				}
			goto HandleError;
			}
		CallS( err );		// Warnings not expected.

		//  make sure we are still on the same long value
		
		LID lidT;
		LidFromKey( &lidT, pfucbLV->kdfCurr.key );
		if ( lidDelete != lidT )
			{
			err = JET_errSuccess;
			break;
			}
		}

	//	verify return value
	CallS( err );

HandleError:
	Assert( JET_errNoCurrentRecord != err );
	Assert( JET_errRecordNotFound != err );
	Assert( pfucbNil != pfucbLV );
	return err;
	}

//  ================================================================
ERR ErrRECDeletePossiblyDereferencedLV( FUCB *pfucbLV, const TRX trxDeltaCommitted )
//  ================================================================
//
//  Given a FUCB set to the root of a LV, delete the entire LV. If
//  it is dereferenced
//
//-
	{	 
	ASSERT_VALID( pfucbLV );
	Assert( FAssertLVFUCB( pfucbLV ) );
	Assert( pfucbLV->ppib->level > 0 );
	Assert( sizeof(LVROOT) == pfucbLV->kdfCurr.data.Cb() );
	Assert( sizeof(LID) == pfucbLV->kdfCurr.key.Cb() );

	//	in order for us to delete the LV, it must have a refcount of 0 and there
	//	must be no other versions beyond this one
	if( reinterpret_cast<LVROOT*>( pfucbLV->kdfCurr.data.Pv() )->ulReference != 0
		|| FDIRActiveVersion( pfucbLV, trxDeltaCommitted ) )
		{
		return ErrERRCheck( JET_errRecordNotDeleted );
		}
	return ErrRECDeleteLV( pfucbLV, fDIRNull );
	}


//  ================================================================
ERR ErrRECAffectLongFieldsInWorkBuf( FUCB *pfucb, LVAFFECT lvaffect )
//  ================================================================
	{
	ASSERT_VALID( pfucb );
	Assert( !FAssertLVFUCB( pfucb ) );
	Assert( !pfucb->dataWorkBuf.FNull() );
	Assert( lvaffectSeparateAll == lvaffect || lvaffectReferenceAll == lvaffect );

	Assert( pfcbNil != pfucb->u.pfcb );
	Assert( ptdbNil != pfucb->u.pfcb->Ptdb() );

	ERR				err;
	VOID *			pvWorkBufSav	= NULL;
	const ULONG		cbWorkBufSav	= pfucb->dataWorkBuf.Cb();

	AssertDIRNoLatch( pfucb->ppib );

	AssertSz( pfucb->ppib->level > 0, "LV update attempted at level 0" );
	if ( 0 == pfucb->ppib->level )
		{
		err = ErrERRCheck( JET_errNotInTransaction );
		return err;
		}

	CallR( ErrDIRBeginTransaction( pfucb->ppib, NO_GRBIT ) );

	Assert( NULL != pfucb->dataWorkBuf.Pv() );
	Assert( cbWorkBufSav >= REC::cbRecordMin );
	Assert( cbWorkBufSav <= REC::CbRecordMax() );

	if ( lvaffectSeparateAll == lvaffect )
		{
		BFAlloc( &pvWorkBufSav );
		UtilMemCpy( pvWorkBufSav, pfucb->dataWorkBuf.Pv(), cbWorkBufSav );
		}
	else
		{
		//	don't need to save off copy buffer because this is
		//	an InsertCopy and on failure, we will throw away the
		//	copy buffer
		Assert( lvaffectReferenceAll == lvaffect );
		Assert( FFUCBInsertCopyPrepared( pfucb ) );
		}

	TAGFIELDS		tagfields( pfucb->dataWorkBuf );
	Call( tagfields.ErrAffectLongValuesInWorkBuf( pfucb, lvaffect ) );

	Assert( !Pcsr( pfucb )->FLatched() );
	
	Call( ErrDIRCommitTransaction( pfucb->ppib, NO_GRBIT ) );
	FUCBSetTagImplicitOp( pfucb );

	if ( NULL != pvWorkBufSav )
		BFFree( pvWorkBufSav );

	return err;

HandleError:
	Assert( err < 0 );
	CallSx( ErrDIRRollback( pfucb->ppib ), JET_errRollbackError );
	Assert( !Pcsr( pfucb )->FLatched() );

	if ( NULL != pvWorkBufSav )
		{
		//	restore original copy buffer, because any LV updates
		//	that happened got rolled back
		UtilMemCpy( pfucb->dataWorkBuf.Pv(), pvWorkBufSav, cbWorkBufSav );
		pfucb->dataWorkBuf.SetCb( cbWorkBufSav );
		BFFree( pvWorkBufSav );
		}

	return err;
	}


//  ================================================================
ERR ErrRECDereferenceLongFieldsInRecord( FUCB *pfucb )
//  ================================================================
	{
	ERR					err;

	ASSERT_VALID( pfucb );
	Assert( !FAssertLVFUCB( pfucb ) );
	Assert( pfcbNil != pfucb->u.pfcb );

	//	only called by ErrIsamDelete(), which always begins a transaction
	Assert( pfucb->ppib->level > 0 );
	
	AssertDIRNoLatch( pfucb->ppib );

	CallR( ErrDIRGet( pfucb ) );
	Assert( !pfucb->kdfCurr.data.FNull() );

	TAGFIELDS	tagfields( pfucb->kdfCurr.data );
	Call( tagfields.ErrDereferenceLongValuesInRecord( pfucb ) );

HandleError:
	if ( Pcsr( pfucb )->FLatched() )
		{
		CallS( ErrDIRRelease( pfucb ) );
		}
	AssertDIRNoLatch( pfucb->ppib );
	return err;
	}



//  ****************************************************************
//	Functions used by compact to scan long value tree
//		ErrCMPGetFirstSLongField
//		ErrCMPGetNextSLongField
//	are used to scan the long value root and get lid. CMPRetrieveSLongFieldValue
//	is used to scan the long value. Due to the way the long value tree is
//	organized, we use the calling sequence (see CMPCopyLVTree in sortapi.c)
//		ErrCMPGetSLongFieldFirst
//		loop
//			loop to call CMPRetrieveSLongFieldValue to get the whole long value
//		till ErrCMPGetSLongFieldNext return no current record
//		ErrCMPGetSLongFieldClose
//  ****************************************************************

LOCAL ERR ErrCMPGetReferencedSLongField(
	FUCB		*pfucbGetLV,
	LID			*plid,
	LVROOT		*plvroot )
	{
	ERR			err;
	const LID	lidPrevLV	= *plid;
	
#ifdef DEBUG
	ULONG		ulSizeCurr	= 0;
	ULONG		ulSizeSeen	= 0;
	LID			lidPrevNode	= *plid;
	
	LVCheckOneNodeWhileWalking( pfucbGetLV, plid, &lidPrevNode, &ulSizeCurr, &ulSizeSeen );
#endif	

	forever
		{
		if ( sizeof(LID) != pfucbGetLV->kdfCurr.key.Cb()
			|| sizeof(LVROOT) != pfucbGetLV->kdfCurr.data.Cb() )
			{
			LVReportCorruptedLV( pfucbGetLV, *plid );
			FireWall();
			err = ErrERRCheck( JET_errLVCorrupted );
			goto HandleError;
			}
			
		LidFromKey( plid, pfucbGetLV->kdfCurr.key );
		if ( *plid <= lidPrevLV )
			{
			LVReportCorruptedLV( pfucbGetLV, *plid );
			FireWall();

			//	lids are monotonically increasing
			err = ErrERRCheck( JET_errLVCorrupted );
			goto HandleError;
			}
		
		const ULONG	ulRefcount	= (reinterpret_cast<LVROOT*>( pfucbGetLV->kdfCurr.data.Pv() ))->ulReference;
		if ( ulRefcount > 0 )
			{
			plvroot->ulSize = (reinterpret_cast<LVROOT*>( pfucbGetLV->kdfCurr.data.Pv() ))->ulSize;
			plvroot->ulReference = ulRefcount;
			err = ErrDIRRelease( pfucbGetLV );
			Assert( JET_errNoCurrentRecord != err );
			Assert( JET_errRecordNotFound != err );
			break;
			}

		// Skip LV's with refcount == 0
		do
			{
			Call( ErrDIRNext( pfucbGetLV, fDIRNull ) );

			Call( ErrLVCheckDataNodeOfLid( pfucbGetLV, *plid ) );
				
#ifdef DEBUG			
			LVCheckOneNodeWhileWalking( pfucbGetLV, plid, &lidPrevNode, &ulSizeCurr, &ulSizeSeen );
#endif
			}
		while ( wrnLVNoMoreData != err );

		}	// forever


HandleError:
	return err;
	}


//  ================================================================
ERR ErrCMPGetSLongFieldFirst(
	FUCB	*pfucb,
	FUCB	**ppfucbGetLV,
	LID		*plid,
	LVROOT	*plvroot )
//  ================================================================
	{
	ERR		err			= JET_errSuccess;
	FUCB	*pfucbGetLV	= pfucbNil;

	Assert( pfucb != pfucbNil );
 
	//	open cursor on LONG

	CallR( ErrDIROpenLongRoot( pfucb, &pfucbGetLV ) );
	if ( wrnLVNoLongValues == err )
		{
		Assert( pfucbNil == pfucbGetLV );
		*ppfucbGetLV = pfucbNil;
		return ErrERRCheck( JET_errRecordNotFound );
		}

	Assert( pfucbNil != pfucbGetLV );

	// seek to first long field instance

	DIB		dib;
	dib.dirflag			= fDIRNull;
	dib.pos				= posFirst;
	Call( ErrDIRDown( pfucbGetLV, &dib ) );

	err = ErrCMPGetReferencedSLongField( pfucbGetLV, plid, plvroot );
	Assert( JET_errRecordNotFound != err );
	if ( err < 0 )
		{
		if ( JET_errNoCurrentRecord == err )
			err = ErrERRCheck( JET_errRecordNotFound );
		goto HandleError;
		}
		
	*ppfucbGetLV = pfucbGetLV;

	return err;
	
	
HandleError:
	//	discard temporary FUCB

	if ( pfucbGetLV != pfucbNil )
		DIRClose( pfucbGetLV );

	return err;
	}


//  ================================================================
ERR ErrCMPGetSLongFieldNext(
	FUCB	*pfucbGetLV,
	LID		*plid,
	LVROOT	*plvroot )
//  ================================================================
	{
	ERR		err = JET_errSuccess;

	Assert( pfucbNil != pfucbGetLV );
 
	//	move to next long field instance

	CallR( ErrDIRNext( pfucbGetLV, fDIRNull ) );
	
	err = ErrCMPGetReferencedSLongField( pfucbGetLV, plid, plvroot );
	Assert( JET_errRecordNotFound != err );

	return err;
	}

 
//  ================================================================
VOID CMPGetSLongFieldClose(	FUCB *pfucbGetLV )
//  ================================================================
	{
	Assert( pfucbGetLV != pfucbNil );
	DIRClose( pfucbGetLV );
	}


//  ================================================================
ERR ErrCMPRetrieveSLongFieldValueByChunks(
	FUCB		*pfucbGetLV,		//	pfucb must be on the LV root node.
	const LID	lid,
	const ULONG	cbTotal,			//	Total LV data length.
	ULONG		ibLongValue,		//	starting offset.
	BYTE		*pbBuf,
	const ULONG	cbMax,
	ULONG		*pcbReturned )		//	Total returned byte count
//  ================================================================
	{
	ERR			err;
	BYTE		*pb			= pbBuf;
	ULONG		cbRemaining	= cbMax;

	*pcbReturned = 0;

	//	We must be on LVROOT if ibGraphic == 0
#ifdef DEBUG
	if ( 0 == ibLongValue )
		{
		CallS( ErrDIRGet( pfucbGetLV ) );
		AssertLVRootNode( pfucbGetLV, lid );
		Assert( cbTotal == (reinterpret_cast<LVROOT*>( pfucbGetLV->kdfCurr.data.Pv() ))->ulSize );
		}
#endif	

	// For this to work properly, ibLongValue must always point to the
	// beginning of a chunk, and the buffer passed in must be big enough
	// to hold at least one chunk.
	Assert( ibLongValue % g_cbColumnLVChunkMost == 0 );
	Assert( cbMax >= g_cbColumnLVChunkMost );

	while( ibLongValue < cbTotal && cbRemaining >= g_cbColumnLVChunkMost )
		{
		CallR( ErrDIRNext( pfucbGetLV, fDIRNull ) );

		//  make sure we are still on the same long value
		Call( ErrLVCheckDataNodeOfLid( pfucbGetLV, lid ) );
		if ( wrnLVNoMoreData == err )
			{
			LVReportCorruptedLV( pfucbGetLV, lid );
			FireWall();

			//	ran out of data before we were supposed to
			err = ErrERRCheck( JET_errLVCorrupted );
			goto HandleError;
			}

		const ULONG cb = pfucbGetLV->kdfCurr.data.Cb();

		// If not a complete chunk, then must be the last chunk.
		Assert( cb == g_cbColumnLVChunkMost || ibLongValue + cb == cbTotal );
		
		UtilMemCpy( pb, pfucbGetLV->kdfCurr.data.Pv(), cb );
		pb += cb;
		cbRemaining -= cb;
		ibLongValue += cb;
		Assert( ibLongValue <= cbTotal );
		}

	// Either we reached the end of the LV or we ran out of buffer space.
	Assert( ibLongValue == cbTotal || cbRemaining < g_cbColumnLVChunkMost );

	*pcbReturned = ULONG( pb - pbBuf );

	Assert( *pcbReturned <= cbMax );

	err = JET_errSuccess;

HandleError:
	CallS( ErrDIRRelease( pfucbGetLV ) );
	return err;
	}


ERR ErrRECUpdateLVRefcount(
	FUCB		*pfucb,
	const LID	lid,
	const ULONG	ulRefcountOld,
	const ULONG	ulRefcountNew )
	{
	ERR			err;
	FUCB		*pfucbLV;
	
	CallR( ErrDIROpenLongRoot( pfucb, &pfucbLV ) );
	Assert( wrnLVNoLongValues != err );		// should only call this func if we know LV's exist
	Assert( pfucbNil != pfucbLV );

	Call( ErrDIRDownLV( pfucbLV, lid, fDIRNull ) );
	Assert( (reinterpret_cast<LVROOT*>( pfucbLV->kdfCurr.data.Pv() ))->ulReference
		== ulRefcountOld );

	if ( 0 == ulRefcountNew )
		{
		Assert( ulRefcountOld != ulRefcountNew );
		Call( ErrRECDeleteLV( pfucbLV, fDIRNull ) );
		}
#ifdef DEBUG
	//	in non-DEBUG, this check is performed before calling this function
	else if ( ulRefcountOld == ulRefcountNew )
		{
		//	refcount is already correct. Do nothing.
		}
#endif				
	else
		{
		//	update refcount with correct count
		LVROOT	lvroot;
		DATA	data;

		data.SetPv( &lvroot );
		data.SetCb( sizeof(LVROOT) );
				
		UtilMemCpy( &lvroot, pfucbLV->kdfCurr.data.Pv(), sizeof(LVROOT) );
		lvroot.ulReference = ulRefcountNew;
		Call( ErrDIRReplace( pfucbLV, data, fDIRNull ) );
		}

HandleError:
	Assert( pfucbNil != pfucbLV );
	DIRClose( pfucbLV );

	return err;
	}
	


#ifdef DEBUG

VOID LVCheckOneNodeWhileWalking(
	FUCB	*pfucbLV,
	LID		*plidCurr,
	LID		*plidPrev,
	ULONG	*pulSizeCurr,
	ULONG	*pulSizeSeen )
	{
	//  make sure we are still on the same long value
	if ( sizeof(LID) == pfucbLV->kdfCurr.key.Cb() )
		{
		//  we must be on the first node of a new long value
		Assert( sizeof(LVROOT) == pfucbLV->kdfCurr.data.Cb() );

		//  get the new LID
		LidFromKey( plidCurr, pfucbLV->kdfCurr.key );
		Assert( *plidCurr > *plidPrev );
		*plidPrev = *plidCurr;
			
		//  get the new size. make sure we saw all of the previous LV
		Assert( *pulSizeCurr == *pulSizeSeen );
		*pulSizeCurr = (reinterpret_cast<LVROOT*>( pfucbLV->kdfCurr.data.Pv() ))->ulSize;
		*pulSizeSeen = 0;

		//  its O.K. to have an unreferenced LV (it should get cleaned up), but we may want
		//  to set a breakpoint
		if ( 0 == ( reinterpret_cast<LVROOT*>( pfucbLV->kdfCurr.data.Pv() ) )->ulReference )
			{
			/// AssertSz( fFalse, "Unreferenced long value" );
			Assert( 0 == *pulSizeSeen );	//  a dummy statement to set a breakpoint on
			}
			
		}
	else
		{
		Assert( *plidCurr > lidMin );
		Assert( sizeof(LVKEY) == pfucbLV->kdfCurr.key.Cb() );

		//  check that we are still on our own lv.
		LID		lid			= lidMin;
		ULONG	ulOffset	= 0;
		LidOffsetFromKey( &lid, &ulOffset, pfucbLV->kdfCurr.key );
		Assert( lid == *plidCurr );
		Assert( ulOffset == *pulSizeSeen );

		//  keep track of how much of the LV we have seen
		//  the nodes should be of maximum size, except at the end
		*pulSizeSeen += pfucbLV->kdfCurr.data.Cb();
		Assert( *pulSizeSeen <= *pulSizeCurr );
		Assert( g_cbColumnLVChunkMost == pfucbLV->kdfCurr.data.Cb()
			|| *pulSizeSeen == *pulSizeCurr );

		}
	}

#endif	//  DEBUG


//  ================================================================
RECCHECKLV::RECCHECKLV( TTMAP& ttmap, const REPAIROPTS * m_popts ) :
//  ================================================================
	m_ttmap( ttmap ),
	m_popts( m_popts ),
	m_ulSizeCurr( 0 ),
	m_ulSizeSeen( 0 ),
	m_lidCurr( lidMin )
	{
	}


//  ================================================================
RECCHECKLV::~RECCHECKLV()
//  ================================================================
	{
	}


//  ================================================================
ERR RECCHECKLV::operator()( const KEYDATAFLAGS& kdf )
//  ================================================================
	{
	ERR err = JET_errSuccess;
	ERR wrn = JET_errSuccess;

	if ( sizeof(LID) == kdf.key.Cb() )
		{			
		const LID lidOld = m_lidCurr;

		LidFromKey( &m_lidCurr, kdf.key );

		if( sizeof(LVROOT) != kdf.data.Cb() )
			{
			(*m_popts->pcprintfError)( "corrupted LV(%d) (LVROOT data mismatch: expected %d bytes, got %d bytes\r\n",
										m_lidCurr, sizeof( LVROOT ), kdf.data.Cb() );
			Call( ErrERRCheck( JET_errDatabaseCorrupted ) );
			}

		if( m_lidCurr <= lidOld )
			{
			(*m_popts->pcprintfError)( "corrupted LV(%d) (LIDs are not increasing: %d )\r\n", m_lidCurr, lidOld );
			Call( ErrERRCheck( JET_errDatabaseCorrupted ) );
			}
		
		if( m_ulSizeCurr != m_ulSizeSeen )
			{
			(*m_popts->pcprintfError)( "corrupted LV(%d) (LV too short: expected %d bytes, saw %d bytes)\r\n", lidOld, m_ulSizeCurr, m_ulSizeSeen );
			Call( ErrERRCheck( JET_errDatabaseCorrupted ) );
			}
		m_ulSizeCurr = (reinterpret_cast<LVROOT*>( kdf.data.Pv() ))->ulSize;
		m_ulSizeSeen = 0;

		const ULONG ulReference = (reinterpret_cast<LVROOT*>( kdf.data.Pv() ))->ulReference;			

#ifdef SYNC_DEADLOCK_DETECTION
		COwner* const pownerSaved = Pcls()->pownerLockHead;
		Pcls()->pownerLockHead = NULL;
#endif  //  SYNC_DEADLOCK_DETECTION
		err = m_ttmap.ErrSetValue( m_lidCurr, ulReference );
#ifdef SYNC_DEADLOCK_DETECTION
		Pcls()->pownerLockHead = pownerSaved;
#endif  //  SYNC_DEADLOCK_DETECTION
		Call( err );
		}
	else
		{
		if( lidMin == m_lidCurr )
			{
			(*m_popts->pcprintfError)( "corrupted LV(%d) (lid == lidmin)\r\n", m_lidCurr );
			Call( ErrERRCheck( JET_errDatabaseCorrupted ) );
			}
		if( sizeof(LVKEY) != kdf.key.Cb() )
			{
			(*m_popts->pcprintfError)( "corrupted LV(%d) (LVKEY size mismatch: expected %d bytes, got %d bytes)\r\n",
										m_lidCurr, sizeof( LVKEY ), kdf.key.Cb() );
			Call( ErrERRCheck( JET_errDatabaseCorrupted ) );
			}

		//  check that we are still on our own lv.
		LID		lid			= lidMin;
		ULONG	ulOffset	= 0;
		LidOffsetFromKey( &lid, &ulOffset, kdf.key );
		if( lid != m_lidCurr )
			{
			(*m_popts->pcprintfError)( "corrupted LV(%d) (lid changed to %d without root, size is %d bytes)\r\n",
										m_lidCurr, lid, kdf.data.Cb() );
			Call( ErrERRCheck( JET_errDatabaseCorrupted ) );
			}
		if( ulOffset != m_ulSizeSeen )
			{
			(*m_popts->pcprintfError)( "corrupted LV(%d) (missing chunk: offset is %d, saw %d bytes, size is %d bytes)\r\n",
											m_lidCurr, ulOffset, m_ulSizeSeen, kdf.data.Cb() );
			Call( ErrERRCheck( JET_errDatabaseCorrupted ) );
			}
		if( 0 != ( ulOffset % g_cbColumnLVChunkMost ) )
			{
			(*m_popts->pcprintfError)( "corrupted LV(%d) (incorrect offset: offset is %d, size is %d bytes)\r\n",
										m_lidCurr, ulOffset, kdf.data.Cb() );
			Call( ErrERRCheck( JET_errDatabaseCorrupted ) );
			}

		//  keep track of how much of the LV we have seen
		//  the nodes should be of maximum size, except at the end
		m_ulSizeSeen += kdf.data.Cb();
		if( m_ulSizeSeen > m_ulSizeCurr )
			{
			(*m_popts->pcprintfError)( "corrupted LV(%d) (LV too long: expected %d bytes, saw %d bytes)\r\n",
										m_lidCurr, m_ulSizeCurr, m_ulSizeSeen );
			Call( ErrERRCheck( JET_errDatabaseCorrupted ) );
			}
		if( g_cbColumnLVChunkMost != kdf.data.Cb() && m_ulSizeSeen != m_ulSizeCurr )
			{
			(*m_popts->pcprintfError)( "corrupted LV(%d) (node is wrong size: node is %d bytes)\r\n",
										m_lidCurr, kdf.data.Cb() );
			Call( ErrERRCheck( JET_errDatabaseCorrupted ) );
			}
		}

HandleError:
	if( JET_errSuccess == err )
		{
		err = wrn;
		}
	return err;
	}
	

//  ================================================================
RECCHECKLVSTATS::RECCHECKLVSTATS( LVSTATS * plvstats ) :
//  ================================================================
	m_plvstats( plvstats )
	{
	}


//  ================================================================
RECCHECKLVSTATS::~RECCHECKLVSTATS()
//  ================================================================
	{
	}


//  ================================================================
ERR RECCHECKLVSTATS::operator()( const KEYDATAFLAGS& kdf )
//  ================================================================
	{
	if ( sizeof(LID) == kdf.key.Cb() )
		{			
		LID lid;
		LidFromKey( &lid, kdf.key );
		
		const ULONG ulSize 		= (reinterpret_cast<LVROOT*>( kdf.data.Pv() ))->ulSize;
		const ULONG ulReference = (reinterpret_cast<LVROOT*>( kdf.data.Pv() ))->ulReference;	

		m_plvstats->cbLVTotal += ulSize;

		if( lidMin == m_plvstats->lidMin )
			{
			m_plvstats->lidMin = lid;
			}
		m_plvstats->lidMin = min( lid, m_plvstats->lidMin );
		m_plvstats->lidMax = max( lid, m_plvstats->lidMax );
		
		++(m_plvstats->clv );

		if( ulReference > 1 )
			{
			++(m_plvstats->clvMultiRef );
			}
		else if( 0 == ulReference )
			{
			++(m_plvstats->clvNoRef );
			}

		m_plvstats->ulReferenceMax = max( ulReference, m_plvstats->ulReferenceMax );
		
		m_plvstats->cbLVMin = min( ulSize, m_plvstats->cbLVMin );
		m_plvstats->cbLVMax = max( ulSize, m_plvstats->cbLVMax );
		}

	return JET_errSuccess;
	}


//  ================================================================
ERR ErrREPAIRCheckLV(
	FUCB * const pfucb,
	LID * const plid,
	ULONG * const pulRefcount,
	ULONG * const pulSize,
	BOOL * const pfLVHasRoot,
	BOOL * const pfLVComplete,
	BOOL * const pfDone )
//  ================================================================
	{
	ERR err = JET_errSuccess;

	ULONG ulSizeSeen 	= 0;

	Call( ErrDIRGet( pfucb ) );

	*pfLVHasRoot		= fFalse;
	*pfLVComplete 		= fFalse;
	*pfDone				= fFalse;
	*pulRefcount		= 0;
	LidFromKey( plid, pfucb->kdfCurr.key );

	if ( sizeof( LID ) != pfucb->kdfCurr.key.Cb()
		|| sizeof( LVROOT ) != pfucb->kdfCurr.data.Cb() )
		{
		if( sizeof( LVKEY ) != pfucb->kdfCurr.key.Cb() )
			{
			//  this would be a really strange corruption
			goto HandleError;
			}

		LID		lid			= lidMin;
		ULONG	ulOffset	= 0;
		LidOffsetFromKey( &lid, &ulOffset, pfucb->kdfCurr.key );

		if( 0 == ulOffset )
			{
			//  we are not on the root, we are on the first LV chunk
			*pulRefcount = 0;
			*pulSize = 0;
			ulSizeSeen = pfucb->kdfCurr.data.Cb();
			}
		else
			{
			// we are neither on the root, nor on the first LV chunk
			// no way to recover this LV
			goto HandleError;
			}
		}
	else
		{
		*pfLVHasRoot = fTrue;
		*pulRefcount = (reinterpret_cast<LVROOT*>( pfucb->kdfCurr.data.Pv() ) )->ulReference;
		*pulSize = (reinterpret_cast<LVROOT*>( pfucb->kdfCurr.data.Pv() ) )->ulSize;
		}

	for( ; ; )
		{
		err = ErrDIRNext( pfucb, fDIRNull );
		if( JET_errNoCurrentRecord == err )
			{
			break;
			}
		Call( err );

		LID lidT;
		LidFromKey( &lidT, pfucb->kdfCurr.key );

		if( *plid != lidT )
			{
			//  we are on a new LV
			break;
			}

		if( sizeof( LVKEY ) != pfucb->kdfCurr.key.Cb() )
			{
			//  this would be a really strange corruption
			goto HandleError;
			}
			
		ULONG	ulOffset;
		LidOffsetFromKey( &lidT, &ulOffset, pfucb->kdfCurr.key );
		if( ulOffset != ulSizeSeen )
			{
			//  we are missing a chunk
			goto HandleError;
			}	

		ulSizeSeen += pfucb->kdfCurr.data.Cb();

		if( g_cbColumnLVChunkMost != pfucb->kdfCurr.data.Cb()
			&& ulSizeSeen < *pulSize
			&& *pfLVHasRoot )
			{
			//  all chunks in the middle should be the full LV chunk size
			goto HandleError;
			}

		if( ulSizeSeen > *pulSize
			&& *pfLVHasRoot )
			{
			//  this LV is too long
			goto HandleError;
			}
		}

	Assert( err >= 0 || JET_errNoCurrentRecord == err );
	
	*pfDone 		= ( JET_errNoCurrentRecord == err );

	if( *pfLVHasRoot )
		{
		*pfLVComplete	= ( ulSizeSeen == *pulSize );	
		}
	else
		{
		//  we can only be sure that we didn't lose a bit of a long value
		//  if the chunk at the end is not a full chunk
		*pfLVComplete = ( ulSizeSeen % g_cbColumnLVChunkMost ) != 0;
		*pulSize = ulSizeSeen;
		*pulRefcount = 1;
		}

	if( err >= 0 )
		{
		Call( ErrDIRRelease( pfucb ) );
		}
	
	err = JET_errSuccess;

HandleError:
	return err;
	}


//  ================================================================
LOCAL ERR ErrREPAIRDownLV( FUCB * pfucb, LID lid )
//  ================================================================
//
//  This will search for a partial chunk of a LV
//
//-
	{
	ERR err = JET_errSuccess;

	BYTE rgbKey[ sizeof( LID ) ];
	KeyFromLong( rgbKey, lid );

	BOOKMARK	bm;
	bm.key.prefix.Nullify();
	bm.key.suffix.SetPv( rgbKey );
	bm.key.suffix.SetCb( sizeof( rgbKey ) );
	bm.data.Nullify();

	DIB			dib;
	dib.dirflag = fDIRNull;
	dib.pos		= posDown;
	dib.pbm		= &bm;

	DIRUp( pfucb );
	err = ErrDIRDown( pfucb, &dib );
	Assert( JET_errRecordDeleted != err );
	
	const BOOL fFoundLess		= ( err == wrnNDFoundLess );
	const BOOL fFoundGreater 	= ( err == wrnNDFoundGreater );
	const BOOL fFoundEqual 		= ( !fFoundGreater && !fFoundLess && err >= 0 );
	Call( err );

	Assert( fGlobalRepair || !fFoundGreater );
	if( fFoundEqual )
		{
		//  we are on the node we want
		}
	else if( fFoundLess )
		{
		//  we are on a node that is less than our current node
		Assert( locBeforeSeekBM == pfucb->locLogical );
		Call( ErrDIRNext( pfucb, fDIRNull ) );
		}
	else if( fFoundGreater )
		{
		//  we are on a node with a greater key than the one we were seeking for
		//  this is actually the node we want to be on
		Assert( locAfterSeekBM == pfucb->locLogical );
		pfucb->locLogical = locOnCurBM;
		}
		
HandleError:
	return err;
	}


//  ================================================================
ERR ErrREPAIRDeleteLV( FUCB * pfucb, LID lid )
//  ================================================================
	{
	Assert( fGlobalRepair );
	
	ERR err = JET_errSuccess;

	Call( ErrREPAIRDownLV( pfucb, lid ) );

#ifdef DEBUG
	LID lidT;
	LidFromKey( &lidT, pfucb->kdfCurr.key );
	Assert( lidT == lid );
#endif	//	DEBUG
	
	Call( ErrRECDeleteLV( pfucb, fDIRNoVersion ) );

HandleError:
	return err;
	}


//  ================================================================
ERR ErrREPAIRCreateLVRoot( FUCB * const pfucb, const LID lid, const ULONG ulRefcount, const ULONG ulSize )
//  ================================================================
	{
	ERR err = JET_errSuccess;

	BYTE rgbKey[ sizeof( LID ) ];	//	this is the key to insert
	KeyFromLong( rgbKey, lid );

	KEY key;
	key.prefix.Nullify();
	key.suffix.SetPv( rgbKey );
	key.suffix.SetCb( sizeof( rgbKey ) );

	LVROOT lvroot;
	lvroot.ulReference = ulRefcount;
	lvroot.ulSize = ulSize;

	DATA data;
	data.SetPv( &lvroot );
	data.SetCb( sizeof( LVROOT ) );
	
	err = ErrDIRInsert( pfucb, key, data, fDIRNull | fDIRNoVersion | fDIRNoLog, NULL );
	
	return err;
	}


//  ================================================================
ERR ErrREPAIRNextLV( FUCB * pfucb, LID lidCurr, BOOL * pfDone )
//  ================================================================
	{
	ERR err = JET_errSuccess;
	const LID lidNext = lidCurr + 1;

	err = ErrREPAIRDownLV( pfucb, lidNext );
	if( JET_errNoCurrentRecord == err
		|| JET_errRecordNotFound == err )
		{
		*pfDone = fTrue;
		return JET_errSuccess;
		}
	Call( err );
	
#ifdef DEBUG
	LID lidT;
	LidFromKey( &lidT, pfucb->kdfCurr.key );
	Assert( lidT >= lidNext );
#endif	//	DEBUG
	
HandleError:
	return err;
	}


//  ================================================================
ERR ErrREPAIRUpdateLVRefcount(
	FUCB		* const pfucbLV,
	const LID	lid,
	const ULONG	ulRefcountOld,
	const ULONG	ulRefcountNew )
//  ================================================================
	{
	Assert( ulRefcountOld != ulRefcountNew );
	
	ERR			err;

	LVROOT	lvroot;
	DATA	data;

	Call( ErrDIRDownLV( pfucbLV, lid, fDIRNull ) );
	Assert( (reinterpret_cast<LVROOT*>( pfucbLV->kdfCurr.data.Pv() ))->ulReference
		== ulRefcountOld );
	
	data.SetPv( &lvroot );
	data.SetCb( sizeof(LVROOT) );
			
	UtilMemCpy( &lvroot, pfucbLV->kdfCurr.data.Pv(), sizeof(LVROOT) );
	lvroot.ulReference = ulRefcountNew;
	Call( ErrDIRReplace( pfucbLV, data, fDIRNull ) );

HandleError:
	return err;
	}


//  ================================================================
LOCAL ERR ErrSCRUBIZeroLV( 	PIB * const 	ppib,
							const IFMP 		ifmp,
							CSR * const 	pcsr,
							const INT 		iline,
							const LID 		lid,
							const ULONG 	ulSize,
							const BOOL		fCanChangeCSR )
//  ================================================================
	{
	ERR				err;
	KEYDATAFLAGS 	kdf;
	INT				ilineT = iline;

	while( 1 )
		{
		if( ilineT == pcsr->Cpage().Clines() )
			{
			const PGNO pgnoNext = pcsr->Cpage().PgnoNext();
			if( NULL == pgnoNext )
				{
				//  end of the tree
				return JET_errSuccess;
				}

			if( !fCanChangeCSR )
				{
				//  we need to keep the root of the LV latched for further processing
				//  use a new CSR to venture onto new pages
				CSR csrNext;
				CallR( csrNext.ErrGetRIWPage( ppib, ifmp, pgnoNext ) );
				csrNext.UpgradeFromRIWLatch();

				BFDirty( pcsr->Cpage().PBFLatch() );	

				err = ErrSCRUBIZeroLV( ppib, ifmp, &csrNext, 0, lid, ulSize, fTrue );
				
				csrNext.ReleasePage();
				csrNext.Reset();
				
				return err;
				}
			else
				{
				//  the page should be write latched downgrade to a RIW latch
				//  ErrSwitchPage will RIW latch the next page
				pcsr->Downgrade( latchRIW );
				
				CallR( pcsr->ErrSwitchPage( ppib, ifmp, pgnoNext ) );
				pcsr->UpgradeFromRIWLatch();

				BFDirty( pcsr->Cpage().PBFLatch() );	

				ilineT = 0;
				}
			}

		NDIGetKeydataflags( pcsr->Cpage(), ilineT, &kdf );

		//  check to see if we have reached the next LVROOT
		if( sizeof( LID ) == kdf.key.Cb() )
			{
			if( sizeof( LVROOT ) != kdf.data.Cb() )
				{
				AssertSz( fFalse, "Corrupted LV: corrupted LVROOT" );
				return ErrERRCheck( JET_errLVCorrupted );
				}
			//  reached the start of the next long-value
			return JET_errSuccess;
			}

		//  make sure we are on a LVDATA node
		if( sizeof( LVKEY ) != kdf.key.Cb() )
			{
			AssertSz( fFalse, "Corrupted LV: unknown key size" );
			return ErrERRCheck( JET_errLVCorrupted );
			}

		//  make sure LIDs haven't changed
		LID lidT;
		LidFromKey( &lidT, kdf.key );
		if( lid != lidT )
			{
			//  this can happen if the next LV is being deleted
			return JET_errSuccess;
			}

		//	make sure the LV isn't too long
		ULONG ulOffset;
		OffsetFromKey( &ulOffset, kdf.key );
		if( ulOffset > ulSize && !FNDDeleted( kdf ) )
			{
			AssertSz( fFalse, "Corrupted LV: LV too long" );
			return ErrERRCheck( JET_errLVCorrupted );
			}

		//  we are on a data node of our LV
		memset( kdf.data.Pv(), 'l', kdf.data.Cb() );
		
		++ilineT;
		}
	return JET_errSuccess;
	}


//  ================================================================
ERR ErrSCRUBZeroLV( PIB * const ppib,
					const IFMP ifmp,
					CSR * const pcsr,
					const INT iline )
//  ================================================================
	{
	CSR csrT;
	
	KEYDATAFLAGS kdf;
	NDIGetKeydataflags( pcsr->Cpage(), iline, &kdf );
	Assert( sizeof( LVROOT ) == kdf.data.Cb() );
	
	const LVROOT * const plvroot = reinterpret_cast<LVROOT *>( kdf.data.Pv() );
	Assert( 0 == plvroot->ulReference );

	const ULONG ulSize = plvroot->ulSize;
	LID lid;
	LidFromKey( &lid, kdf.key );

	return ErrSCRUBIZeroLV( ppib, ifmp, pcsr, iline+1, lid, ulSize, fFalse );
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ese98\src\ese\jetapi.cxx ===
#include "std.hxx"

char g_szEventSource[JET_cbFullNameMost] = "";
char g_szEventSourceKey[JET_cbFullNameMost] = "";
BOOL g_fNoInformationEvent = fFalse;

ULONG	IFileSystemAPI::cmsecAccessDeniedRetryPeriod	= 10000;	//	default number of milliseconds to retry on AccessDenied

UINT	g_wAssertAction	= JET_AssertMsgBox;	// Default action is to pop up msg box.

BOOL g_fGlobalMinSetByUser = fFalse; // For use by JET_paramMaxVerPages and JET_paramGlobalMinVerPages
BOOL g_fGlobalPreferredSetByUser = fFalse; // For use by JET_paramMaxVerPages and JET_paramGlobalPreferVerPages

//  automatically generated
extern void JetErrorToString( JET_ERR err, const char **szError, const char **szErrorText );


#ifdef CATCH_EXCEPTIONS
BOOL	g_fCatchExceptions	= fTrue;
#endif	//	CATCH_EXCEPTIONS


#ifdef RTM
#else
ERR 	g_errTrap			= JET_errSuccess;	// Default is no error trap.
LGPOS	g_lgposRedoTrap		= lgposMax;			// Default to no redo trap.
#endif


BOOL fGlobalEseutil			= fFalse;


/*** utilities ***/

#ifdef DEBUG
extern ERR ISAMAPI ErrIsamGetTransaction( JET_SESID vsesid, ULONG_PTR *plevel );
#endif

/*	make global variable so that it can be inspected from debugger
/**/
unsigned long	g_ulVersion = ((unsigned long) DwUtilImageVersionMajor() << 24) + ((unsigned long) DwUtilImageBuildNumberMajor() << 8) + DwUtilImageBuildNumberMinor();

#ifdef RFS2
	extern DWORD g_cRFSAlloc;
	extern DWORD g_cRFSIO;
	extern DWORD g_fDisableRFS;
#endif 


/*	Jet VTFN dispatch supports.
 */
#pragma warning(disable: 4100)			 /* Suppress Unreferenced parameter */


ERR VTAPI ErrIllegalAddColumn(JET_SESID sesid, JET_VTID vtid,
	const char  *szColumn, const JET_COLUMNDEF  *pcolumndef,
	const void  *pvDefault, unsigned long cbDefault,
	JET_COLUMNID  *pcolumnid)
	{
	return ErrERRCheck( JET_errIllegalOperation );
	}


ERR VTAPI ErrIllegalCloseTable(JET_SESID vsesid, JET_VTID vtid)
	{
	return ErrERRCheck( JET_errIllegalOperation );
	}


ERR VTAPI ErrIllegalComputeStats(JET_SESID vsesid, JET_VTID vtid)
	{
	return ErrERRCheck( JET_errIllegalOperation );
	}

ERR VTAPI ErrIllegalCopyBookmarks(JET_SESID sesid, JET_VTID vtidSrc,
	JET_TABLEID tableidDest, JET_COLUMNID columnidDest, unsigned long crecMax)
	{
	return ErrERRCheck( JET_errIllegalOperation );
	}

ERR VTAPI ErrIllegalCreateIndex(JET_SESID, JET_VTID, JET_INDEXCREATE *, unsigned long )
	{
	return ErrERRCheck( JET_errIllegalOperation );
	}


ERR VTAPI ErrIllegalDelete(JET_SESID vsesid, JET_VTID vtid)
	{
	return ErrERRCheck( JET_errIllegalOperation );
	}


ERR VTAPI ErrIllegalDeleteColumn(
	JET_SESID		vsesid,
	JET_VTID		vtid,
	const char		*szColumn,
	const JET_GRBIT	grbit )
	{
	return ErrERRCheck( JET_errIllegalOperation );
	}


ERR VTAPI ErrIllegalDeleteIndex(JET_SESID vsesid, JET_VTID vtid,
	const char  *szIndexName)
	{
	return ErrERRCheck( JET_errIllegalOperation );
	}


ERR VTAPI ErrIllegalDupCursor(JET_SESID vsesid, JET_VTID vtid,
	JET_TABLEID  *ptableid, JET_GRBIT grbit)
	{
	return ErrERRCheck( JET_errIllegalOperation );
	}


ERR VTAPI ErrIllegalEscrowUpdate( JET_SESID vsesid,
	JET_VTID vtid,
	JET_COLUMNID columnid,
	void *pv,
	unsigned long cbMax,
	void *pvOld,
	unsigned long cbOldMax,
	unsigned long *pcbOldActual,
	JET_GRBIT grbit )
	{
	return ErrERRCheck( JET_errIllegalOperation );
	}


ERR VTAPI ErrIllegalGetBookmark(
	JET_SESID		vsesid,
	JET_VTID		vtid,
	VOID * const	pvBookmark,
	const ULONG		cbMax,
	ULONG * const	pcbActual )
	{
	return ErrERRCheck( JET_errIllegalOperation );
	}

ERR VTAPI ErrIllegalGetIndexBookmark(
	JET_SESID		vsesid,
	JET_VTID		vtid,
	VOID * const	pvSecondaryKey,
	const ULONG		cbSecondaryKeyMax,
	ULONG * const	pcbSecondaryKeyActual,
	VOID * const	pvPrimaryBookmark,
	const ULONG		cbPrimaryBookmarkMax,
	ULONG *	const	pcbPrimaryBookmarkActual )
	{
	return ErrERRCheck( JET_errIllegalOperation );
	}


ERR VTAPI ErrIllegalGetChecksum(JET_SESID vsesid, JET_VTID vtid,
	unsigned long  *pChecksum)
	{
	return ErrERRCheck( JET_errIllegalOperation );
	}


ERR VTAPI ErrIllegalGetCurrentIndex(JET_SESID vsesid, JET_VTID vtid,
	char  *szIndexName, unsigned long cchIndexName)
	{
	return ErrERRCheck( JET_errIllegalOperation );
	}


ERR VTAPI ErrIllegalGetCursorInfo(JET_SESID vsesid, JET_VTID vtid,
	void  *pvResult, unsigned long cbMax, unsigned long InfoLevel)
	{
	return ErrERRCheck( JET_errIllegalOperation );
	}


ERR VTAPI ErrIllegalGetRecordPosition(JET_SESID vsesid, JET_VTID vtid,
	JET_RECPOS  *pkeypos, unsigned long cbKeypos)
	{
	return ErrERRCheck( JET_errIllegalOperation );
	}


ERR VTAPI ErrIllegalGetTableColumnInfo(JET_SESID vsesid, JET_VTID vtid,
	const char  *szColumnName, const JET_COLUMNID *pcolid, void  *pvResult,
	unsigned long cbMax, unsigned long InfoLevel)
	{
	return ErrERRCheck( JET_errIllegalOperation );
	}


ERR VTAPI ErrIllegalGetTableIndexInfo(JET_SESID vsesid, JET_VTID vtid,
	const char  *szIndexName, void  *pvResult,
	unsigned long cbMax, unsigned long InfoLevel)
	{
	return ErrERRCheck( JET_errIllegalOperation );
	}


ERR VTAPI ErrIllegalGetTableInfo(JET_SESID vsesid, JET_VTID vtid,
	void  *pvResult, unsigned long cbMax, unsigned long InfoLevel)
	{
	return ErrERRCheck( JET_errIllegalOperation );
	}


ERR VTAPI ErrIllegalGotoBookmark(
	JET_SESID			vsesid,
	JET_VTID			vtid,
	const VOID * const	pvBookmark,
	const ULONG			cbBookmark )
	{
	return ErrERRCheck( JET_errIllegalOperation );
	}

ERR VTAPI ErrIllegalGotoIndexBookmark(
	JET_SESID			vsesid,
	JET_VTID			vtid,
	const VOID * const	pvSecondaryKey,
	const ULONG			cbSecondaryKey,
	const VOID * const	pvPrimaryBookmark,
	const ULONG			cbPrimaryBookmark,
	const JET_GRBIT		grbit )
	{
	return ErrERRCheck( JET_errIllegalOperation );
	}


ERR VTAPI ErrIllegalGotoPosition(JET_SESID vsesid, JET_VTID vtid,
	JET_RECPOS *precpos)
	{
	return ErrERRCheck( JET_errIllegalOperation );
	}


ERR VTAPI ErrIllegalVtIdle(JET_SESID vsesid, JET_VTID vtid)
	{
	return ErrERRCheck( JET_errIllegalOperation );
	}


ERR VTAPI ErrIllegalMakeKey(
	JET_SESID		vsesid,
	JET_VTID		vtid,
	const VOID*		pvData,
	const ULONG		cbData,
	JET_GRBIT		grbit )
	{
	return ErrERRCheck( JET_errIllegalOperation );
	}


ERR VTAPI ErrIllegalGetLock(JET_SESID vsesid, JET_VTID vtid, JET_GRBIT grbit)
	{
	return ErrERRCheck( JET_errIllegalOperation );
	}


ERR VTAPI ErrIllegalMove(JET_SESID vsesid, JET_VTID vtid,
	long cRow, JET_GRBIT grbit)
	{
	return ErrERRCheck( JET_errIllegalOperation );
	}


ERR VTAPI ErrIllegalNotifyBeginTrans(JET_SESID vsesid, JET_VTID vtid)
	{
	return ErrERRCheck( JET_errIllegalOperation );
	}


ERR VTAPI ErrIllegalNotifyCommitTrans(JET_SESID vsesid, JET_VTID vtid,
	JET_GRBIT grbit)
	{
	return ErrERRCheck( JET_errIllegalOperation );
	}


ERR VTAPI ErrIllegalNotifyRollback(JET_SESID vsesid, JET_VTID vtid,
	JET_GRBIT grbit)
	{
	return ErrERRCheck( JET_errIllegalOperation );
	}


ERR VTAPI ErrIllegalNotifyUpdateUfn(JET_SESID vsesid, JET_VTID vtid)
	{
	return ErrERRCheck( JET_errIllegalOperation );
	}


ERR VTAPI ErrIllegalPrepareUpdate(JET_SESID vsesid, JET_VTID vtid,
	unsigned long prep)
	{
	return ErrERRCheck( JET_errIllegalOperation );
	}


ERR VTAPI ErrIllegalRenameColumn(JET_SESID vsesid, JET_VTID vtid,
	const char  *szColumn, const char  *szColumnNew, const JET_GRBIT grbit)
	{
	return ErrERRCheck( JET_errIllegalOperation );
	}


ERR VTAPI ErrIllegalRenameIndex(JET_SESID vsesid, JET_VTID vtid,
	const char  *szIndex, const char  *szIndexNew)
	{
	return ErrERRCheck( JET_errIllegalOperation );
	}


ERR VTAPI ErrIllegalRetrieveColumn(
	JET_SESID		vsesid,
	JET_VTID		vtid,
	JET_COLUMNID	columnid,
	VOID*			pvData,
	const ULONG		cbData,
	ULONG*			pcbActual,
	JET_GRBIT		grbit,
	JET_RETINFO*	pretinfo )
	{
	return ErrERRCheck( JET_errIllegalOperation );
	}

ERR VTAPI ErrIllegalRetrieveColumns(JET_SESID vsesid, JET_VTID vtid,
	JET_RETRIEVECOLUMN	*pretcols, unsigned long cretcols )
	{
	return ErrERRCheck( JET_errIllegalOperation );
	}

ERR VTAPI ErrIllegalEnumerateColumns(
	JET_SESID				vsesid,
	JET_VTID				vtid,
	unsigned long			cEnumColumnId,
	JET_ENUMCOLUMNID*		rgEnumColumnId,
	unsigned long*			pcEnumColumn,
	JET_ENUMCOLUMN**		prgEnumColumn,
	JET_PFNREALLOC			pfnRealloc,
	void*					pvReallocContext,
	unsigned long			cbDataMost,
	JET_GRBIT				grbit )
	{
	return ErrERRCheck( JET_errIllegalOperation );
	}


ERR VTAPI ErrIllegalRetrieveKey(
	JET_SESID		vsesid,
	JET_VTID		vtid,
	VOID*			pvKey,
	const ULONG		cbMax,
	ULONG*			pcbActual,
	JET_GRBIT		grbit )
	{
	return ErrERRCheck( JET_errIllegalOperation );
	}


ERR VTAPI ErrIllegalSeek(JET_SESID vsesid, JET_VTID vtid,
	JET_GRBIT grbit)
	{
	return ErrERRCheck( JET_errIllegalOperation );
	}


ERR VTAPI ErrIllegalSetColumn(
	JET_SESID		vsesid,
	JET_VTID		vtid,
	JET_COLUMNID	columnid,
	const VOID*		pvData,
	const ULONG		cbData,
	JET_GRBIT		grbit,
	JET_SETINFO*	psetinfo )
	{
	return ErrERRCheck( JET_errIllegalOperation );
	}

ERR VTAPI ErrIllegalSetColumns(JET_SESID vsesid, JET_VTID vtid,
	JET_SETCOLUMN	*psetcols, unsigned long csetcols )
	{
	return ErrERRCheck( JET_errIllegalOperation );
	}

ERR VTAPI ErrIllegalSetIndexRange(JET_SESID vsesid, JET_VTID vtid,
	JET_GRBIT grbit)
	{
	return ErrERRCheck( JET_errIllegalOperation );
	}


ERR VTAPI ErrIllegalUpdate(JET_SESID vsesid, JET_VTID vtid,
	void  *pvBookmark, unsigned long cbBookmark,
	unsigned long  *pcbActual, JET_GRBIT grbit )
	{
	return ErrERRCheck( JET_errIllegalOperation );
	}

ERR VTAPI ErrIllegalRegisterCallback(
	JET_SESID 		vsesid,
	JET_VTID		vtid,
	JET_CBTYP		cbtyp, 
	JET_CALLBACK	pCallback,
	VOID *			pvContext,
	JET_HANDLE		*phCallbackId )
	{
	return ErrERRCheck( JET_errIllegalOperation );
	}
	
ERR VTAPI ErrIllegalUnregisterCallback(
	JET_SESID 		vsesid,
	JET_VTID		vtid,
	JET_CBTYP		cbtyp, 
	JET_HANDLE		hCallbackId )
	{
	return ErrERRCheck( JET_errIllegalOperation );
	}

ERR VTAPI ErrIllegalSetLS(
	JET_SESID 		vsesid,
	JET_VTID		vtid,
	JET_LS			ls, 
	JET_GRBIT		grbit )
	{
	return ErrERRCheck( JET_errIllegalOperation );
	}

ERR VTAPI ErrIllegalGetLS(
	JET_SESID 		vsesid,
	JET_VTID		vtid,
	JET_LS			*pls, 
	JET_GRBIT		grbit )
	{
	return ErrERRCheck( JET_errIllegalOperation );
	}

ERR VTAPI ErrIllegalIndexRecordCount(
	JET_SESID sesid, JET_VTID vtid,	unsigned long *pcrec,
	unsigned long crecMax )
	{
	return ErrERRCheck( JET_errIllegalOperation );
	}

ERR VTAPI ErrIllegalRetrieveTaggedColumnList(
	JET_SESID			vsesid,
	JET_VTID			vtid,
	ULONG				*pcentries,
	VOID				*pv,
	const ULONG			cbMax,
	const JET_COLUMNID	columnidStart,
	const JET_GRBIT		grbit )
	{
	return ErrERRCheck( JET_errIllegalOperation );
	}

ERR VTAPI ErrIllegalSetSequential(
	const JET_SESID,
	const JET_VTID,
	const JET_GRBIT )
	{
	return ErrERRCheck( JET_errIllegalOperation );
	}

ERR VTAPI ErrIllegalResetSequential(
	const JET_SESID,
	const JET_VTID,
	const JET_GRBIT )
	{
	return ErrERRCheck( JET_errIllegalOperation );
	}

ERR VTAPI ErrIllegalSetCurrentIndex(
	JET_SESID			sesid,
	JET_VTID			tableid,
	const CHAR			*szIndexName,
	const JET_INDEXID	*pindexid,
	const JET_GRBIT		grbit,
	const ULONG			itagSequence )
	{
	return ErrERRCheck( JET_errIllegalOperation );
	}



ERR VTAPI ErrInvalidAddColumn(JET_SESID sesid, JET_VTID vtid,
	const char  *szColumn, const JET_COLUMNDEF  *pcolumndef,
	const void  *pvDefault, unsigned long cbDefault,
	JET_COLUMNID  *pcolumnid)
	{
	return ErrERRCheck( JET_errInvalidTableId );
	}

ERR VTAPI ErrInvalidCloseTable(JET_SESID vsesid, JET_VTID vtid)
	{
	return ErrERRCheck( JET_errInvalidTableId );
	}


ERR VTAPI ErrInvalidComputeStats(JET_SESID vsesid, JET_VTID vtid)
	{
	return ErrERRCheck( JET_errInvalidTableId );
	}

ERR VTAPI ErrInvalidCopyBookmarks(JET_SESID sesid, JET_VTID vtidSrc,
	JET_TABLEID tableidDest, JET_COLUMNID columnidDest, unsigned long crecMax)
	{
	return ErrERRCheck( JET_errInvalidTableId );
	}

ERR VTAPI ErrInvalidCreateIndex(JET_SESID vsesid, JET_VTID vtid, JET_INDEXCREATE *, unsigned long)
	{
	return ErrERRCheck( JET_errInvalidTableId );
	}


ERR VTAPI ErrInvalidDelete(JET_SESID vsesid, JET_VTID vtid)
	{
	return ErrERRCheck( JET_errInvalidTableId );
	}


ERR VTAPI ErrInvalidDeleteColumn(
	JET_SESID		vsesid,
	JET_VTID		vtid,
	const char		*szColumn,
	const JET_GRBIT	grbit )
	{
	return ErrERRCheck( JET_errInvalidTableId );
	}


ERR VTAPI ErrInvalidDeleteIndex(JET_SESID vsesid, JET_VTID vtid,
	const char  *szIndexName)
	{
	return ErrERRCheck( JET_errInvalidTableId );
	}


ERR VTAPI ErrInvalidDupCursor(JET_SESID vsesid, JET_VTID vtid,
	JET_TABLEID  *ptableid, JET_GRBIT grbit)
	{
	return ErrERRCheck( JET_errInvalidTableId );
	}


ERR VTAPI ErrInvalidEscrowUpdate(
	JET_SESID vsesid,
	JET_VTID vtid,
	JET_COLUMNID columnid,
	void *pv,
	unsigned long cbMax,
	void *pvOld,
	unsigned long cbOldMax,
	unsigned long *pcbOldActual,
	JET_GRBIT grbit )
	{
	return ErrERRCheck( JET_errInvalidTableId );
	}


ERR VTAPI ErrInvalidGetBookmark(
	JET_SESID		vsesid,
	JET_VTID		vtid,
	VOID * const	pvBookmark,
	const ULONG		cbMax,
	ULONG * const	pcbActual )
	{
	return ErrERRCheck( JET_errInvalidTableId );
	}

ERR VTAPI ErrInvalidGetIndexBookmark(
	JET_SESID		vsesid,
	JET_VTID		vtid,
	VOID * const	pvSecondaryKey,
	const ULONG		cbSecondaryKeyMax,
	ULONG * const	pcbSecondaryKeyActual,
	VOID * const	pvPrimaryBookmark,
	const ULONG		cbPrimaryBookmarkMax,
	ULONG *	const	pcbPrimaryBookmarkActual )
	{
	return ErrERRCheck( JET_errInvalidTableId );
	}


ERR VTAPI ErrInvalidGetChecksum(JET_SESID vsesid, JET_VTID vtid,
	unsigned long  *pChecksum)
	{
	return ErrERRCheck( JET_errInvalidTableId );
	}


ERR VTAPI ErrInvalidGetCurrentIndex(JET_SESID vsesid, JET_VTID vtid,
	char  *szIndexName, unsigned long cchIndexName)
	{
	return ErrERRCheck( JET_errInvalidTableId );
	}


ERR VTAPI ErrInvalidGetCursorInfo(JET_SESID vsesid, JET_VTID vtid,
	void  *pvResult, unsigned long cbMax, unsigned long InfoLevel)
	{
	return ErrERRCheck( JET_errInvalidTableId );
	}


ERR VTAPI ErrInvalidGetRecordPosition(JET_SESID vsesid, JET_VTID vtid,
	JET_RECPOS  *pkeypos, unsigned long cbKeypos)
	{
	return ErrERRCheck( JET_errInvalidTableId );
	}


ERR VTAPI ErrInvalidGetTableColumnInfo(JET_SESID vsesid, JET_VTID vtid,
	const char  *szColumnName, const JET_COLUMNID *pcolid, void  *pvResult,
	unsigned long cbMax, unsigned long InfoLevel)
	{
	return ErrERRCheck( JET_errInvalidTableId );
	}


ERR VTAPI ErrInvalidGetTableIndexInfo(JET_SESID vsesid, JET_VTID vtid,
	const char  *szIndexName, void  *pvResult,
	unsigned long cbMax, unsigned long InfoLevel)
	{
	return ErrERRCheck( JET_errInvalidTableId );
	}


ERR VTAPI ErrInvalidGetTableInfo(JET_SESID vsesid, JET_VTID vtid,
	void  *pvResult, unsigned long cbMax, unsigned long InfoLevel)
	{
	return ErrERRCheck( JET_errInvalidTableId );
	}


ERR VTAPI ErrInvalidGotoBookmark(
	JET_SESID			vsesid,
	JET_VTID			vtid,
	const VOID * const	pvBookmark,
	const ULONG			cbBookmark )
	{
	return ErrERRCheck( JET_errInvalidTableId );
	}

ERR VTAPI ErrInvalidGotoIndexBookmark(
	JET_SESID			vsesid,
	JET_VTID			vtid,
	const VOID * const	pvSecondaryKey,
	const ULONG			cbSecondaryKey,
	const VOID * const	pvPrimaryBookmark,
	const ULONG			cbPrimaryBookmark,
	const JET_GRBIT		grbit )
	{
	return ErrERRCheck( JET_errInvalidTableId );
	}


ERR VTAPI ErrInvalidGotoPosition(JET_SESID vsesid, JET_VTID vtid,
	JET_RECPOS *precpos)
	{
	return ErrERRCheck( JET_errInvalidTableId );
	}


ERR VTAPI ErrInvalidVtIdle(JET_SESID vsesid, JET_VTID vtid)
	{
	return ErrERRCheck( JET_errInvalidTableId );
	}


ERR VTAPI ErrInvalidMakeKey(
	JET_SESID		vsesid,
	JET_VTID		vtid,
	const VOID*		pvData,
	const ULONG		cbData,
	JET_GRBIT		grbit )
	{
	return ErrERRCheck( JET_errInvalidTableId );
	}


ERR VTAPI ErrInvalidMove(JET_SESID vsesid, JET_VTID vtid,
	long cRow, JET_GRBIT grbit)
	{
	return ErrERRCheck( JET_errInvalidTableId );
	}


ERR VTAPI ErrInvalidNotifyBeginTrans(JET_SESID vsesid, JET_VTID vtid)
	{
	return ErrERRCheck( JET_errInvalidTableId );
	}


ERR VTAPI ErrInvalidNotifyCommitTrans(JET_SESID vsesid, JET_VTID vtid,
	JET_GRBIT grbit)
	{
	return ErrERRCheck( JET_errInvalidTableId );
	}


ERR VTAPI ErrInvalidNotifyRollback(JET_SESID vsesid, JET_VTID vtid,
	JET_GRBIT grbit)
	{
	return ErrERRCheck( JET_errInvalidTableId );
	}


ERR VTAPI ErrInvalidNotifyUpdateUfn(JET_SESID vsesid, JET_VTID vtid)
	{
	return ErrERRCheck( JET_errInvalidTableId );
	}


ERR VTAPI ErrInvalidPrepareUpdate(JET_SESID vsesid, JET_VTID vtid,
	unsigned long prep)
	{
	return ErrERRCheck( JET_errInvalidTableId );
	}


ERR VTAPI ErrInvalidRenameColumn(JET_SESID vsesid, JET_VTID vtid,
	const char  *szColumn, const char  *szColumnNew, const JET_GRBIT grbit )
	{
	return ErrERRCheck( JET_errInvalidTableId );
	}


ERR VTAPI ErrInvalidRenameIndex(JET_SESID vsesid, JET_VTID vtid,
	const char  *szIndex, const char  *szIndexNew)
	{
	return ErrERRCheck( JET_errInvalidTableId );
	}


ERR VTAPI ErrInvalidRetrieveColumn(
	JET_SESID		vsesid,
	JET_VTID		vtid,
	JET_COLUMNID	columnid,
	VOID*			pvData,
	const ULONG		cbData,
	ULONG*			pcbActual,
	JET_GRBIT		grbit,
	JET_RETINFO*	pretinfo )
	{
	return ErrERRCheck( JET_errInvalidTableId );
	}

ERR VTAPI ErrInvalidRetrieveColumns(JET_SESID vsesid, JET_VTID vtid,
	JET_RETRIEVECOLUMN	*pretcols, unsigned long cretcols )
	{
	return ErrERRCheck( JET_errInvalidTableId );
	}

ERR VTAPI ErrInvalidEnumerateColumns(
	JET_SESID				vsesid,
	JET_VTID				vtid,
	unsigned long			cEnumColumnId,
	JET_ENUMCOLUMNID*		rgEnumColumnId,
	unsigned long*			pcEnumColumn,
	JET_ENUMCOLUMN**		prgEnumColumn,
	JET_PFNREALLOC			pfnRealloc,
	void*					pvReallocContext,
	unsigned long			cbDataMost,
	JET_GRBIT				grbit )
	{
	return ErrERRCheck( JET_errInvalidTableId );
	}

ERR VTAPI ErrInvalidRetrieveKey(
	JET_SESID		vsesid,
	JET_VTID		vtid,
	VOID*			pvKey,
	const ULONG		cbMax,
	ULONG*			pcbActual,
	JET_GRBIT		grbit )
	{
	return ErrERRCheck( JET_errInvalidTableId );
	}


ERR VTAPI ErrInvalidSeek(JET_SESID vsesid, JET_VTID vtid,
	JET_GRBIT grbit)
	{
	return ErrERRCheck( JET_errInvalidTableId );
	}



ERR VTAPI ErrInvalidSetColumn(
	JET_SESID		vsesid,
	JET_VTID		vtid,
	JET_COLUMNID	columnid,
	const VOID*		pvData,
	const ULONG		cbData,
	JET_GRBIT		grbit,
	JET_SETINFO*	psetinfo )
	{
	return ErrERRCheck( JET_errInvalidTableId );
	}

ERR VTAPI ErrInvalidSetColumns(JET_SESID vsesid, JET_VTID vtid,
	JET_SETCOLUMN	*psetcols, unsigned long csetcols )
	{
	return ErrERRCheck( JET_errInvalidTableId );
	}

ERR VTAPI ErrInvalidSetIndexRange(JET_SESID vsesid, JET_VTID vtid,
	JET_GRBIT grbit)
	{
	return ErrERRCheck( JET_errInvalidTableId );
	}


ERR VTAPI ErrInvalidUpdate(JET_SESID vsesid, JET_VTID vtid,
	void  *pvBookmark, unsigned long cbBookmark,
	unsigned long  *pcbActual, JET_GRBIT grbit )
	{
	return ErrERRCheck( JET_errInvalidTableId );
	}

ERR VTAPI ErrInvalidGetLock(JET_SESID vsesid, JET_VTID vtid,
	JET_GRBIT grbit)
	{
	return ErrERRCheck( JET_errInvalidTableId );
	}

ERR VTAPI ErrInvalidRegisterCallback(JET_SESID	vsesid, JET_VTID vtid, JET_CBTYP cbtyp, 
	JET_CALLBACK pCallback, VOID * pvContext, JET_HANDLE *phCallbackId )
	{
	return ErrERRCheck( JET_errInvalidTableId );
	}
	
ERR VTAPI ErrInvalidUnregisterCallback(JET_SESID vsesid, JET_VTID vtid, JET_CBTYP cbtyp,
	JET_HANDLE hCallbackId )
	{
	return ErrERRCheck( JET_errInvalidTableId );
	}

ERR VTAPI ErrInvalidSetLS(
	JET_SESID 		vsesid,
	JET_VTID		vtid,
	JET_LS			ls, 
	JET_GRBIT		grbit )
	{
	return ErrERRCheck( JET_errInvalidTableId );
	}

ERR VTAPI ErrInvalidGetLS(
	JET_SESID 		vsesid,
	JET_VTID		vtid,
	JET_LS			*pls, 
	JET_GRBIT		grbit )
	{
	return ErrERRCheck( JET_errInvalidTableId );
	}

ERR VTAPI ErrInvalidIndexRecordCount(
	JET_SESID sesid, JET_VTID vtid,	unsigned long *pcrec,
	unsigned long crecMax )
	{
	return ErrERRCheck( JET_errInvalidTableId );
	}

ERR VTAPI ErrInvalidRetrieveTaggedColumnList(
	JET_SESID			vsesid,
	JET_VTID			vtid,
	ULONG				*pcentries,
	VOID				*pv,
	const ULONG			cbMax,
	const JET_COLUMNID	columnidStart,
	const JET_GRBIT		grbit )
	{
	return ErrERRCheck( JET_errInvalidTableId );
	}


ERR VTAPI ErrInvalidSetSequential(
	const JET_SESID,
	const JET_VTID,
	const JET_GRBIT )
	{
	return ErrERRCheck( JET_errInvalidTableId );
	}

ERR VTAPI ErrInvalidResetSequential(
	const JET_SESID,
	const JET_VTID,
	const JET_GRBIT )
	{
	return ErrERRCheck( JET_errInvalidTableId );
	}


ERR VTAPI ErrInvalidSetCurrentIndex(
	JET_SESID			sesid,
	JET_VTID			tableid,
	const CHAR			*szIndexName,
	const JET_INDEXID	*pindexid,
	const JET_GRBIT		grbit,
	const ULONG			itagSequence )
	{
	return ErrERRCheck( JET_errInvalidTableId );
	}






#ifdef DEBUG
CODECONST(VTDBGDEF) vtdbgdefInvalidTableid =
	{
	sizeof(VTFNDEF),
	0,
	"Invalid Tableid",
	0,
	{
		0,
		0,
		0,
		0,
	},
	};
#endif	/* DEBUG */

 extern const VTFNDEF vtfndefInvalidTableid =
	{
	sizeof(VTFNDEF),
	0,
#ifndef	DEBUG
	NULL,
#else	/* DEBUG */
	&vtdbgdefInvalidTableid,
#endif	/* !DEBUG */
	ErrInvalidAddColumn,
	ErrInvalidCloseTable,
	ErrInvalidComputeStats,
	ErrInvalidCreateIndex,
	ErrInvalidDelete,
	ErrInvalidDeleteColumn,
	ErrInvalidDeleteIndex,
	ErrInvalidDupCursor,
	ErrInvalidEscrowUpdate,
	ErrInvalidGetBookmark,
	ErrInvalidGetIndexBookmark,
	ErrInvalidGetChecksum,
	ErrInvalidGetCurrentIndex,
	ErrInvalidGetCursorInfo,
	ErrInvalidGetRecordPosition,
	ErrInvalidGetTableColumnInfo,
	ErrInvalidGetTableIndexInfo,
	ErrInvalidGetTableInfo,
	ErrInvalidGotoBookmark,
	ErrInvalidGotoIndexBookmark,
	ErrInvalidGotoPosition,
	ErrInvalidMakeKey,
	ErrInvalidMove,
	ErrInvalidPrepareUpdate,
	ErrInvalidRenameColumn,
	ErrInvalidRenameIndex,
	ErrInvalidRetrieveColumn,
	ErrInvalidRetrieveColumns,
	ErrInvalidRetrieveKey,
	ErrInvalidSeek,
	ErrInvalidSetCurrentIndex,
	ErrInvalidSetColumn,
	ErrInvalidSetColumns,
	ErrInvalidSetIndexRange,
	ErrInvalidUpdate,
	ErrInvalidGetLock,
	ErrInvalidRegisterCallback,
	ErrInvalidUnregisterCallback,
	ErrInvalidSetLS,
	ErrInvalidGetLS,
	ErrInvalidIndexRecordCount,
	ErrInvalidRetrieveTaggedColumnList,
	ErrInvalidSetSequential,
	ErrInvalidResetSequential,
	ErrInvalidEnumerateColumns
	};

const VTFNDEF vtfndefIsamCallback =
	{
	sizeof(VTFNDEF),
	0,
	NULL,
	ErrIllegalAddColumn,
	ErrIllegalCloseTable,
	ErrIllegalComputeStats,
	ErrIllegalCreateIndex,
	ErrIllegalDelete,
	ErrIllegalDeleteColumn,
	ErrIllegalDeleteIndex,
	ErrIsamDupCursor,
	ErrIllegalEscrowUpdate,
	ErrIsamGetBookmark,
	ErrIsamGetIndexBookmark,
	ErrIllegalGetChecksum,
	ErrIsamGetCurrentIndex,
	ErrIsamGetCursorInfo,
	ErrIsamGetRecordPosition,
	ErrIsamGetTableColumnInfo,
	ErrIsamGetTableIndexInfo,
	ErrIsamGetTableInfo,
	ErrIllegalGotoBookmark,
	ErrIllegalGotoIndexBookmark,
	ErrIllegalGotoPosition,
	ErrIllegalMakeKey,
	ErrIllegalMove,
	ErrIllegalPrepareUpdate,
	ErrIllegalRenameColumn,
	ErrIllegalRenameIndex,
	ErrIsamRetrieveColumn,
	ErrIsamRetrieveColumns,
	ErrIsamRetrieveKey,
	ErrIllegalSeek,
	ErrIllegalSetCurrentIndex,
	ErrIsamSetColumn,
	ErrIsamSetColumns,
	ErrIllegalSetIndexRange,
	ErrIllegalUpdate,
	ErrIllegalGetLock,
	ErrIsamRegisterCallback,
	ErrIsamUnregisterCallback,
	ErrIsamSetLS,
	ErrIsamGetLS,
	ErrIllegalIndexRecordCount,
	ErrIllegalRetrieveTaggedColumnList,
	ErrIllegalSetSequential,
	ErrIllegalResetSequential,
	ErrIsamEnumerateColumns
	};


/*	The following extern decl is JET Blue only system parameters.
 *	They are declared for JetSetSystemParameter/JetGetSystemParameter.
 */
extern BOOL g_fCreatePathIfNotExist;
extern long	g_cpgSESysMin;
extern long	g_lSessionsMax;
extern long	g_lOpenTablesMax;
extern long g_lOpenTablesPreferredMax;
extern long	g_lTemporaryTablesMax;
extern long	g_lCursorsMax;
extern long	g_lVerPagesMax;
extern long	g_lVerPagesPreferredMax;
extern long	g_lLogBuffers;
extern long	g_lLogFileSize;
extern BOOL g_fSetLogFileSize;
extern long	g_grbitsCommitDefault;
extern char	g_szLogFilePath[];
extern char	g_szLogFileFailoverPath[];
extern BOOL g_fLogFileCreateAsynch;
extern char	g_szRecovery[];
extern BOOL g_fDeleteOldLogs;
extern long g_lPageFragment;
extern BOOL	g_fLGCircularLogging;
extern long	g_cbEventHeapMax;
extern BOOL	g_fTempTableVersioning;
extern BOOL	g_fScrubDB;
extern BOOL g_fImprovedSeekShortcut;
extern BOOL g_fSortedRetrieveColumns;
extern long g_cpgBackupChunk;
extern long g_cBackupRead;
extern long g_cpageTempDBMin;
extern const ULONG	cbIDXLISTNewMembersSinceOriginalFormat;
extern BOOL g_fCleanupMismatchedLogFiles;
extern LONG g_lEventLoggingLevel;

LONG INST::iActivePerfInstIDMin = LONG_MAX;
LONG INST::iActivePerfInstIDMac = 1;
LONG INST::cInstancesCounter = 0;

//	All the counters are cleared during instance creation or deletion
//	So only thing we might need is InitPERFCounters function to
//	set initial values for specific counters
LOCAL VOID InitPERFCounters( INT iInstance )
	{
	//	Empty so far
	}

CHAR **g_rgpPerfCounters = NULL;
CHAR *pInvalidPerfCounters = NULL;
INT g_iPerfCounterOffset = 0;

const INT cInstPerfName = 31;
WCHAR *wszInstanceNames;
static INT cInstances;
static CCriticalSection critInstanceNames( CLockBasicInfo( CSyncBasicInfo( "critInstanceNames" ), 0, 0 ) );
	
VOID PERFSetInstanceNames()
	{
	critInstanceNames.Enter();
	WCHAR * szT = wszInstanceNames;
	wcscpy( szT, L"_Total" );
	szT += wcslen( szT ) + 1;
	int ipinst;
	int ipinstLastUsed = 0;
	for( ipinstLastUsed = ipinstMax-1; ipinstLastUsed > 0; ipinstLastUsed-- )
		{
		if( g_rgpinst[ipinstLastUsed] )
			{
			break;
			}
		}

	for( ipinst = 0; ipinst <= ipinstLastUsed; ++ipinst )
		{
		if( g_rgpinst[ipinst] )
			{
			const char * const szInstanceName = g_rgpinst[ipinst]->m_szDisplayName ? 
					g_rgpinst[ipinst]->m_szDisplayName : g_rgpinst[ipinst]->m_szInstanceName;
						
			if( szInstanceName )
				{
				swprintf( szT, L"%.*S", cInstPerfName, szInstanceName );
				}
			else
				{
				_itow( ipinst, szT, 10 );
				}
			}
		else
			{
			wcscpy( szT, L"_Unused" );
			}
		szT += wcslen( szT ) + 1;
		}
	cInstances = ipinstLastUsed + 2;
	//	set new current 
	critInstanceNames.Leave();
	}

INST::INST( INT iInstance ) :
		m_rgEDBGGlobals( &rgEDBGGlobals ),
		m_iInstance( iInstance + 1 ),
		m_fJetInitialized( fFalse ),
		m_fTermInProgress( fFalse ),
		m_fTermAbruptly( fFalse ),
		m_fSTInit( fSTInitNotDone ),
		m_fBackupAllowed( fFalse ),
		m_cSessionInJetAPI( 0 ),
		m_fStopJetService( fFalse ),
		m_fInstanceUnavailable( fFalse ),
		m_updateid( updateidMin ),
		m_critPIB( CLockBasicInfo( CSyncBasicInfo( szPIBGlobal ), rankPIBGlobal, 0 ) ),
		m_trxNewest( trxMin ),
		m_critPIBTrxOldest( CLockBasicInfo( CSyncBasicInfo( szTrxOldest ), rankTrxOldest, 0 ) ),
		m_ppibGlobal( ppibNil ),
		m_ppibGlobalMin( ppibNil ),
		m_ppibGlobalMax( ppibNil ),
		m_blBegin0Commit0( CLockBasicInfo( CSyncBasicInfo( szBegin0Commit0 ), rankBegin0Commit0, 0 ) ),
		m_pfcbhash( NULL ),
		m_critFCBList( CLockBasicInfo( CSyncBasicInfo( szFCBList ), rankFCBList, 0 ) ),
		m_pfcbList( pfcbNil ),
		m_pfcbAvailBelowMRU( pfcbNil ),
		m_pfcbAvailBelowLRU( pfcbNil ),
		m_pfcbAvailAboveMRU( pfcbNil ),
		m_pfcbAvailAboveLRU( pfcbNil ),
		m_cFCBAvail( 0 ),
		m_pcresFCBPool( NULL ),
		m_pcresTDBPool( NULL ),
		m_pcresIDBPool( NULL ),
		m_cFCBAboveThresholdSinceLastPurge( 0 ),
		m_critFCBCreate( CLockBasicInfo( CSyncBasicInfo( szFCBCreate ), rankFCBCreate, 0 ) ),
		m_pcresFUCBPool( NULL ),
		m_pcresSCBPool( NULL ),
		m_pbAttach( NULL ),
		m_critLV( CLockBasicInfo( CSyncBasicInfo( szLVCreate ), rankLVCreate, 0 ) ),
		m_ppibLV( NULL ),
		m_szInstanceName( NULL ),
		m_szDisplayName( NULL ),
		m_ulParams( 0 ),
		m_lSLVDefragFreeThreshold( g_lSLVDefragFreeThreshold ),
		m_plog( NULL ),
		m_pver( NULL ),
		m_rgoldstatDB( NULL ),
		m_rgoldstatSLV( NULL ),
		m_pfsapi( NULL ),
		m_plnppibBegin( NULL ),
		m_plnppibEnd( NULL ),
		m_critLNPPIB( CLockBasicInfo( CSyncBasicInfo( "ListNodePPIB" ), rankPIBGlobal, 1 ) ),
		m_cOpenedSystemPibs( 0 ),
		m_lSLVDefragMoveThreshold( g_lSLVDefragMoveThreshold )
		{
		if ( m_iInstance > INST::iActivePerfInstIDMac )
			{
			INST::iActivePerfInstIDMac = m_iInstance;
			}
		if ( m_iInstance < INST::iActivePerfInstIDMin )
			{
			INST::iActivePerfInstIDMin = m_iInstance;
			}
#ifdef DEBUG
		m_trxNewest = trxMax - 1025;
#else
		m_trxNewest = trxMin;
#endif
		m_ppibTrxOldest = NULL;
		m_ppibSentinel = NULL;

		m_lSessionsMax = g_lSessionsMax;
		m_lVerPagesMax = g_lVerPagesMax;
		m_fPreferredSetByUser = fFalse;
		m_lVerPagesPreferredMax = g_lVerPagesPreferredMax;
		m_lOpenTablesMax = g_lOpenTablesMax;
		m_lOpenTablesPreferredMax = g_lOpenTablesPreferredMax;
		m_lTemporaryTablesMax = g_lTemporaryTablesMax;
		m_lCursorsMax = g_lCursorsMax;
		m_lLogBuffers = g_lLogBuffers;
		m_lLogFileSize = g_lLogFileSize;
		m_fSetLogFileSize = g_fSetLogFileSize;
		m_lLogFileSizeDuringRecovery = 0;
		m_fUseRecoveryLogFileSize = fFalse;
		m_cpgSESysMin = g_cpgSESysMin;
		m_lPageFragment = g_lPageFragment;
		m_cpageTempDBMin = g_cpageTempDBMin;
		m_pfnRuntimeCallback = g_pfnRuntimeCallback;
		m_grbitsCommitDefault = g_grbitsCommitDefault;

		m_fTempTableVersioning = ( g_fTempTableVersioning ? fTrue : fFalse );
		m_fCreatePathIfNotExist = ( g_fCreatePathIfNotExist ? fTrue : fFalse );
		m_fCleanupMismatchedLogFiles = ( g_fCleanupMismatchedLogFiles ? fTrue : fFalse );
		m_fNoInformationEvent = ( g_fNoInformationEvent ? fTrue : fFalse );
		m_fSLVProviderEnabled = ( g_fSLVProviderEnabled ? fTrue : fFalse );
		m_fOLDLevel = g_fGlobalOLDLevel;

		m_lEventLoggingLevel = g_lEventLoggingLevel;
		
		if ( ErrOSFSCreate( &m_pfsapi ) < JET_errSuccess )
			{
			m_pfsapi = NULL;
			}

		//	store absolute path if possible
		if ( NULL == m_pfsapi
			|| m_pfsapi->ErrPathComplete( g_szSystemPath, m_szSystemPath ) < 0 )
			{
			strcpy( m_szSystemPath, g_szSystemPath );
			}
		strcpy( m_szTempDatabase, g_szTempDatabase );

		strcpy( m_szEventSource, g_szEventSource );
		strcpy( m_szEventSourceKey, g_szEventSourceKey );

		OSSTRCopyA( m_szUnicodeIndexLibrary, g_szUnicodeIndexLibrary );

		for ( DBID dbid = 0; dbid < dbidMax; dbid++ )
			m_mpdbidifmp[ dbid ] = ifmpMax;

		m_plnppibEnd = new ListNodePPIB;
		if ( NULL == m_plnppibEnd )
			{
			return;
			}

#ifdef DEBUG
		m_plnppibEnd->ppib = NULL;
#endif // DEBUG
		m_plnppibEnd->pNext = m_plnppibEnd;
		m_plnppibBegin = m_plnppibEnd;

		Assert( NULL != g_rgpPerfCounters );
		Assert( NULL != g_rgpPerfCounters[ m_iInstance ] );
		// attach set of perfmon counters to the instance
		if ( pInvalidPerfCounters == g_rgpPerfCounters[ m_iInstance ] )
			{
			CHAR *pc;
			pc = new CHAR[ g_iPerfCounterOffset ];
			if ( NULL == pc )
				{
				return;
				}
			memset( pc, 0, g_iPerfCounterOffset );
			AtomicExchangePointer( (void **)&g_rgpPerfCounters[ m_iInstance ], pc );
			}

		Assert( NULL == m_plog );
		Assert( NULL == m_pver );
		m_plog = new LOG( this );
		m_pver = new VER( this );

		Assert( NULL == m_rgoldstatDB );
		Assert( NULL == m_rgoldstatSLV );
		m_rgoldstatDB = new OLDDB_STATUS[ dbidMax ];
		m_rgoldstatSLV = new OLDSLV_STATUS[ dbidMax ];

		// if allocation fails we we error out anyway
		// after the constructor
		if ( NULL != m_plog )
			{
			m_plog->m_fScrubDB = g_fScrubDB;
			}
		InitPERFCounters( m_iInstance );
		}

INST::~INST()
	{
	if ( INST::iActivePerfInstIDMin == m_iInstance )
		{
		while ( ipinstMax > INST::iActivePerfInstIDMin && pinstNil == g_rgpinst[INST::iActivePerfInstIDMin] )
			{
			INST::iActivePerfInstIDMin++;
			}
		}
	if ( INST::iActivePerfInstIDMac == m_iInstance )
		{
		while ( 1 < INST::iActivePerfInstIDMac && pinstNil == g_rgpinst[INST::iActivePerfInstIDMac-2] )
			{
			INST::iActivePerfInstIDMac--;
			}
		}
	
	ListNodePPIB *plnppib;
	// close system sessions
	m_critLNPPIB.Enter();
	if ( NULL != m_plnppibEnd )
		{
		Assert( NULL != m_plnppibBegin );
		//	all the system session must be returned to the session pool
		Assert( m_plnppibEnd->pNext == m_plnppibBegin );
		plnppib		= m_plnppibEnd;
		m_plnppibEnd	= NULL;
		m_plnppibBegin	= NULL;
		}
	else
		{
		plnppib = NULL;
		}
	m_critLNPPIB.Leave();
	if ( NULL != plnppib )
		{
		//	all the sessions should be terminated already
		//	so just free nodes
		ListNodePPIB *plnppibFirst = plnppib;
		do
			{
			ListNodePPIB *plnppibMove = plnppib->pNext;
			delete plnppib;
			plnppib = plnppibMove;
			}
		while ( plnppibFirst != plnppib );
		}

	if ( m_szInstanceName )
		{
		delete[] m_szInstanceName;
		}
	if ( m_szDisplayName )
		{
		delete[] m_szDisplayName;
		}

	delete m_plog;
	delete m_pver;

	delete[] m_rgoldstatDB;
	delete[] m_rgoldstatSLV;

	delete m_pfsapi;

	//	clear the insstance's set of perfmon counters
	Assert( NULL != g_rgpPerfCounters );
	Assert( NULL != g_rgpPerfCounters[ m_iInstance ] );
	if ( pInvalidPerfCounters != g_rgpPerfCounters[ m_iInstance ] )
		{
		memset( g_rgpPerfCounters[ m_iInstance ], 0, g_iPerfCounterOffset );
		}
	}

VOID INST::SaveDBMSParams( DBMS_PARAM *pdbms_param )
	{
	Assert( strlen( m_szSystemPath ) <= IFileSystemAPI::cchPathMax );
	strcpy( pdbms_param->szSystemPath, m_szSystemPath );

	Assert( strlen( m_plog->m_szLogFilePath ) <= IFileSystemAPI::cchPathMax );
	strcpy( pdbms_param->szLogFilePath, m_plog->m_szLogFilePath );

	pdbms_param->fDBMSPARAMFlags = 0;
	if ( m_plog->m_fLGCircularLogging )
		pdbms_param->fDBMSPARAMFlags |= fDBMSPARAMCircularLogging;

	Assert( m_lSessionsMax >= 0 );
	Assert( m_lOpenTablesMax >= 0 );
	Assert( m_lVerPagesMax >= 0 );
	Assert( m_lCursorsMax >= 0 );

	//	buffers may be less than minimum during recovery if we're
	//	recovering using an old log file generated before we started
	//	enforcing a minimum log buffer size
	Assert( m_lLogBuffers >= lLogBufferMin || FRecovering() );

	ULONG_PTR ulMaxBuffers;
	CallS( ErrBFGetCacheSizeMax( &ulMaxBuffers ) );

	pdbms_param->le_lSessionsMax = m_lSessionsMax;
	pdbms_param->le_lOpenTablesMax = m_lOpenTablesMax;
	pdbms_param->le_lVerPagesMax = m_lVerPagesMax;
	pdbms_param->le_lCursorsMax = m_lCursorsMax;
	pdbms_param->le_lLogBuffers = m_lLogBuffers;
	pdbms_param->le_lcsecLGFile = m_plog->m_csecLGFile;
	pdbms_param->le_ulCacheSizeMax = (ULONG)ulMaxBuffers;

	memset( pdbms_param->rgbReserved, 0, sizeof(pdbms_param->rgbReserved) );

	return;
	}

VOID INST::RestoreDBMSParams( DBMS_PARAM *pdbms_param )
	{
	//	UNDONE: better cover additional needed resources and
	//	reduce asynchronous activity during recovery
	//	during recovery, even more resources may be necessary than
	//	during normal operation, since asynchronous activites are
	//	both being done, for recovery operation, and being redo by
	//	recovery operation.
	//
	m_lSessionsMax = pdbms_param->le_lSessionsMax;
	m_lOpenTablesMax = pdbms_param->le_lOpenTablesMax;
	m_lVerPagesMax = pdbms_param->le_lVerPagesMax;
	m_lCursorsMax = pdbms_param->le_lCursorsMax;
	m_lLogBuffers = pdbms_param->le_lLogBuffers;
	m_plog->m_csecLGFile = pdbms_param->le_lcsecLGFile;
	const ULONG	ulMaxBuffers	= pdbms_param->le_ulCacheSizeMax;
	
	Assert( m_lSessionsMax > 0 );
	Assert( m_lOpenTablesMax > 0 );
	Assert( m_lVerPagesMax > 0 );
	Assert( m_lCursorsMax > 0 );
	Assert( m_lLogBuffers > 0 );

	//	buffers may be less than minimum during recovery if we're
	//	recovering using an old log file generated before we started
	//	enforcing a minimum log buffer size
	Assert( m_lLogBuffers >= lLogBufferMin || FRecovering() );

	Assert( ulMaxBuffers > 0 );
	}

BOOL INST::FSetInstanceName( const char * szInstanceName )
	{
	ULONG newSize = szInstanceName ? ULONG( strlen(szInstanceName) ) : 0;
	
	if (m_szInstanceName)
		{
		delete [] m_szInstanceName;
		m_szInstanceName = NULL;
		}
	Assert ( NULL ==  m_szInstanceName);
	if ( 0 == newSize)
		{
		return fTrue;
		}
		
	m_szInstanceName = new char[newSize + 1];
	if ( NULL == m_szInstanceName)
		{
		return fFalse;
		}
	m_szInstanceName[0] = 0;
	
	if ( szInstanceName )
		{
		strcpy( m_szInstanceName, szInstanceName );
		}
		
	return fTrue;
	}

BOOL INST::FSetDisplayName( const char * szDisplayName )
	{
	ULONG newSize = szDisplayName ? ULONG( strlen(szDisplayName) ) : 0;
	
	if (m_szDisplayName)
		{
		delete [] m_szDisplayName;
		m_szDisplayName = NULL;
		}
	Assert ( NULL ==  m_szDisplayName);
	if ( 0 == newSize)
		{
		return fTrue;
		}
		
	m_szDisplayName = new char[newSize + 1];
	if ( NULL == m_szDisplayName)
		{
		return fFalse;
		}
	m_szDisplayName[0] = 0;

	if ( szDisplayName )
		{
		strcpy( m_szDisplayName, szDisplayName );
		}
		
	return fTrue;
	}

INST::ErrGetSystemPib( PIB **pppib )
	{
	ERR err = JET_errSuccess;
	ENTERCRITICALSECTION enter( &m_critLNPPIB );
	Assert( NULL != m_plnppibEnd );
	Assert( NULL != m_plnppibBegin );
	//	there are some available sessions
	if ( m_plnppibEnd != m_plnppibBegin )
		{
		*pppib = m_plnppibBegin->ppib;
#ifdef DEBUG
		m_plnppibBegin->ppib = NULL;
#endif // DEBUG
		m_plnppibBegin = m_plnppibBegin->pNext;
		goto HandleError;
		}
	else if ( m_cOpenedSystemPibs >= cpibSystemFudge )
		{
		Call( ErrERRCheck( JET_errOutOfSessions ) );
		}
	//	else try to allocate new session
	else
		{
		//	allocate new node
		ListNodePPIB *plnppib = new ListNodePPIB;
		if ( NULL == plnppib )
			{
			Call( ErrERRCheck( JET_errOutOfMemory ) );
			}
		//	allocate new session and initialize it
		err = ErrPIBBeginSession( this, pppib, procidNil, fFalse );
		if ( JET_errSuccess > err )
			{
			delete plnppib;
			Call( err );
			}
		m_cOpenedSystemPibs++;
		(*pppib)->grbitsCommitDefault = JET_bitCommitLazyFlush;
		(*pppib)->SetFSystemCallback();
		//	add the node to the list
		Assert( NULL != m_plnppibEnd );
		plnppib->pNext	= m_plnppibEnd->pNext;
#ifdef DEBUG
		plnppib->ppib	= NULL;
#endif // DEBUG
		m_plnppibEnd->pNext = plnppib;
		}
		
HandleError:
	return err;
	}

VOID INST::ReleaseSystemPib( PIB *ppib )
	{
	ENTERCRITICALSECTION enter( &m_critLNPPIB );
	Assert( NULL != m_plnppibEnd );
	Assert( NULL == m_plnppibEnd->ppib );
	m_plnppibEnd->ppib	= ppib;
	m_plnppibEnd		= m_plnppibEnd->pNext;
	}

CCriticalSection critInst( CLockBasicInfo( CSyncBasicInfo( szInstance ), rankInstance, 0 ) );
ULONG	g_cMaxInstancesRequestedByUser	= cMaxInstancesMultiInstanceDefault;
ULONG	ipinstMax 						= cMaxInstancesSingleInstanceDefault;
ULONG	ipinstMac 						= 0;
INST	*g_rgpinst[cMaxInstances]		= { 0 };
CRITPOOL< INST* > critpoolPinstAPI;

ULONG	g_cTermsInProgress				= 0;

//  ICF for the current process' name

PM_ICF_PROC LProcNameICFLPpv;

WCHAR wszProcName[IFileSystemAPI::cchPathMax];

long LProcNameICFLPpv( long lAction, void const **ppvMultiSz )
	{
	//  init ICF
		
	if ( lAction == ICFInit )
		{
#ifdef _UNICODE
		swprintf( wszProcName, L"%s\0" , SzUtilProcessName() );
#else  //  !_UNICODE
		swprintf( wszProcName, L"%S\0" , SzUtilProcessName() );
#endif  //  _UNICODE
		wszProcName[cInstPerfName] = 0;
		}

	else
		{
		if ( ppvMultiSz )
			{
			*ppvMultiSz = wszProcName;
			return 1;
			}
		}
	
	return 0;
	}



PM_ICF_PROC LInstanceNamesICFLPpv;

extern BOOL g_fSystemInit;

long LInstanceNamesICFLPpv( long lAction, void const** ppvMultiSz )
	{	
	static LONG cInstancesLast;
	if( lAction == ICFData )
		{
		critInstanceNames.Enter();
		memcpy( &wszInstanceNames[ perfinstMax * ( cInstPerfName + 1) + 1 ], wszInstanceNames, sizeof(WCHAR) * (perfinstMax * ( cInstPerfName + 1) + 1) );
		cInstancesLast = cInstances;
		critInstanceNames.Leave();
		*ppvMultiSz = &wszInstanceNames[ perfinstMax * ( cInstPerfName + 1) + 1 ];
		return cInstancesLast;
		}
		
	return 0;
	}

/*
Sysrtem can be in one of the 3 states:
1. multi-instance enabled
	Use:  JetEnableMultiInstance to set global-default parameters
	Use:  JetCreateInstance to allocate an instance
	Use:  JetSetSystemParameter with not null instance to set param per instance
	Use:  JetInit with not null pinstance to initialize it (or allocate and inititalize if *pinstance == 0)
	Error:  JetSetSystemParameter with null instance (try to set global param
	Error:  JetInit with null pinstance (default instance can be find only in one-instance mode)
	
2. one-instance enabled
	Use:  JetSetSystemParameter with null instance to set param per instance
	Use:  JetSetSystemParameter with not null instance to set param per instance
	Use:  JetInit with to initialize the instance (the second call before JetTerm will fail)
	Error:  JetEnableMultiInstance
	Error:  JetCreateInstance 

3. mode not set
	no instance is started (initial state and state after last running instance calls JetTerm (ipinstMac == 0)

If the mode is not set, the first function call specific for one of the modes will set it	
*/
typedef enum { runInstModeNoSet, runInstModeOneInst, runInstModeMultiInst} RUNINSTMODE;
RUNINSTMODE g_runInstMode = runInstModeNoSet;

// set running mode 
INLINE VOID RUNINSTSetMode(RUNINSTMODE newMode)
	{
	// must be in critical section to set
	Assert ( critInst.FOwner() );
	// must be before any instance is started
	Assert ( 0 == ipinstMac);
	g_runInstMode = newMode;
	}

// set running mode to one instance
INLINE VOID RUNINSTSetModeOneInst()
	{
	Assert ( runInstModeNoSet == g_runInstMode);
	RUNINSTSetMode(runInstModeOneInst);

	//	force ipinstMax to 1
	ipinstMax = cMaxInstancesSingleInstanceDefault;
	ifmpMax = ipinstMax * dbidMax;
	}

// set running mode to multi instance
INLINE VOID RUNINSTSetModeMultiInst()
	{
	Assert ( runInstModeNoSet == g_runInstMode);
	RUNINSTSetMode(runInstModeMultiInst);

	//	NOTE: we have separate ipinstMax and
	//	g_cMaxInstancesRequestedByUser variables in case
	//	the user wants to switch back and forth between
	//	single- and multi-instance mode (ipinstMax keeps
	//	track of the max instances depending on what mode
	//	we're in, while g_cMaxInstancesRequestedByUser
	//	only keeps track of the max instances in multi-
	//	instance mode)
	ipinstMax = g_cMaxInstancesRequestedByUser;
	ifmpMax = ipinstMax * dbidMax;
	}

// get runnign mode
INLINE RUNINSTMODE RUNINSTGetMode()
	{
	// can be no set mode only if no instance is active
	Assert (  runInstModeNoSet != g_runInstMode || 0 == ipinstMac );
	return g_runInstMode;
	}

INLINE ERR ErrRUNINSTCheckAndSetOneInstMode()
	{
	ERR		err		= JET_errSuccess;
	
	INST::EnterCritInst();
	if ( RUNINSTGetMode() == runInstModeNoSet)
		{
		RUNINSTSetModeOneInst();
		}
	else if ( RUNINSTGetMode() == runInstModeMultiInst)
		{
		err = ErrERRCheck( JET_errRunningInMultiInstanceMode );
		}
	INST::LeaveCritInst();

	return err;
	}
	

INLINE BOOL FINSTInvalid( const JET_INSTANCE instance )
	{
	return ( 0 == instance || (JET_INSTANCE)JET_instanceNil == instance );
	}
	

BOOL FINSTSomeInitialized()
	{
	const BOOL	fInitAlready	= ( RUNINSTGetMode() != runInstModeNoSet );
	return fInitAlready;
	}
	
ERR ErrNewInst( 
	INST **			ppinst, 
	const CHAR *	szInstanceName, 
	const CHAR *	szDisplayName, 
	INT *			pipinst )
	{
	ERR				err			= JET_errSuccess;
	INST *			pinst		= NULL;
	ULONG			ipinst;

	//	if running out of memory, return NULL
	*ppinst = pinst;

	Assert ( NULL == *ppinst );

	//	See if g_rgpinst still have space to hold the pinst.

	INST::EnterCritInst();

	if ( 0 == ipinstMac )
		{
		//	only the first instance should initialise the system
		Call( ErrIsamSystemInit() );
		}
		
	if ( ipinstMac >= ipinstMax )
		{
		Call ( ErrERRCheck( JET_errTooManyInstances ) );
		}
	else // check unique name
		{
		for ( ipinst = 0; ipinst < ipinstMax; ipinst++ )
			{
			if ( pinstNil == g_rgpinst[ ipinst ] )
				{
				continue;
				}
			if ( NULL == szInstanceName && 
				 NULL == g_rgpinst[ ipinst ]->m_szInstanceName )
				{
				Call ( ErrERRCheck( JET_errInstanceNameInUse ) );
				}
			if ( NULL != szInstanceName && 
			   	 NULL != g_rgpinst[ ipinst ]->m_szInstanceName &&
			   	 0 == strcmp( szInstanceName, g_rgpinst[ ipinst ]->m_szInstanceName ) )
				{
				Call ( ErrERRCheck( JET_errInstanceNameInUse ) );
				}				
			}
		}

	Assert( JET_errSuccess == err );
		
	for ( ipinst = 0; ipinst < ipinstMax; ipinst++ )
		{
		if ( pinstNil == g_rgpinst[ ipinst ] )
			{
			break;
			}
		}
	Assert( ipinstMax > ipinst );
	
	(VOID)INST::IncAllocInstances();
	pinst = new INST( ipinst );
	if ( NULL != pinst )
		{
		if ( NULL == pinst->m_plog
			|| NULL == pinst->m_pver
			|| NULL == pinst->m_rgoldstatDB
			|| NULL == pinst->m_rgoldstatSLV
			|| NULL == pinst->m_pfsapi
			|| NULL == pinst->FSetInstanceName( szInstanceName )
			|| NULL == pinst->FSetDisplayName( szDisplayName) )
			{
			delete pinst;
			pinst = NULL;
			}
		}
	if ( NULL == pinst )
		{
		(VOID)INST::DecAllocInstances();
		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}
		
	*ppinst = pinst;

	Assert( pinstNil != pinst );

	AtomicExchangePointer( (void **)&g_rgpinst[ ipinst ], pinst );
	if ( pipinst )
		{
		*pipinst = ipinst;
		}
	ipinstMac++;

	PERFSetInstanceNames();

	//	verify we were allocated an entry in the instance array
	EnforceSz( ipinst < ipinstMax, "Instance array corrupted." );
	
HandleError:
	if ( JET_errSuccess > err )
		{
		if ( ipinstMac == 0 )
			{
			IsamSystemTerm();
			RUNINSTSetMode(runInstModeNoSet);
			}				
		Assert ( NULL == pinst );
		}

	INST::LeaveCritInst();

	return err;
	}

VOID FreePinst( INST *pinst )
	{
	int ipinst;
	
	Assert( pinst );

	// fSTInitFailed meens restore faild. Since now we clean up the instance resources 
	// also on error, it should be fine to release the instance
	// If we don't do that, we can reach the situation when all the g_rgpinst array is full
	// with such left "deactivated" instances and we can not start any new one 
/*
	//	if it did not shut down properly, do not free this instance.
	//	keep it as used so that no one will be able to reuse it.
	
	if ( pinst->m_fSTInit == fSTInitFailed )
		return;
*/		
	//	find the pinst.
	
	INST::EnterCritInst();
	
	for ( ipinst = 0; ipinst < ipinstMax; ipinst++ )
		{
		if ( g_rgpinst[ ipinst ] == pinst )
			{
			break;
			}
		}

	Assert( ipinst < ipinstMax );
	
	//	enter per-inst crit to make sure no one can read the pinst.

	CCriticalSection *pcritInst = &critpoolPinstAPI.Crit(&g_rgpinst[ipinst]);
	pcritInst->Enter();
	pinst->APILock( pinst->fAPIDeleting );
	AtomicExchangePointer( (void **)&g_rgpinst[ ipinst ], pinstNil );
	ipinstMac--;
	delete pinst;
	(VOID)INST::DecAllocInstances();
	pcritInst->Leave();
	PERFSetInstanceNames();
	
	if ( ipinstMac == 0 )
		{
		IsamSystemTerm();
//		Assert (RUNINSTGetMode() == runInstModeOneInst || RUNINSTGetMode() == runInstModeMultiInst);
		RUNINSTSetMode(runInstModeNoSet);
		}

	INST::LeaveCritInst();
	}

INLINE VOID SetPinst( JET_INSTANCE *pinstance, JET_SESID sesid, INST **ppinst )
	{
	if ( !sesid || sesid == JET_sesidNil )
		{
		//	setting for one instance? NULL if for global default
		
		if ( pinstance && ipinstMac )
			*ppinst = *(INST **) pinstance;
		else
			*ppinst = NULL;
		}
	else
		{
		//	sesid is given, assuming the client knows what they are doing
		*ppinst = PinstFromPpib( (PIB *)sesid );
		}
	}

LOCAL ERR ErrFindPinst( JET_INSTANCE jinst, INST **ppinst, int *pipinst = NULL )
	{
	INST				*pinst	= (INST *)jinst;
	UINT				ipinst;
	const RUNINSTMODE	mode	= RUNINSTGetMode();
	
	Assert( ppinst );

	switch ( mode )
		{
		case runInstModeOneInst:
			//	find the only one instance, ignore the given instance
			//	since the given one may be bogus
			for ( ipinst = 0; ipinst < ipinstMax; ipinst++ )
				{
				if ( pinstNil != g_rgpinst[ ipinst ] )
					{
					*ppinst = g_rgpinst[ ipinst ];
					if ( pipinst )
						*pipinst = ipinst;
					return JET_errSuccess;
					}
				}
			break;
		case runInstModeMultiInst:
			if ( FINSTInvalid( jinst ) )
				return ErrERRCheck( JET_errInvalidParameter );
			for ( ipinst = 0; ipinst < ipinstMax; ipinst++ )
				{
				if ( pinstNil != g_rgpinst[ ipinst ]
					&& pinst == g_rgpinst[ ipinst ] )
					{
					// instance found
					*ppinst = g_rgpinst[ ipinst ];
					if ( pipinst )
						*pipinst = ipinst;
					return JET_errSuccess;
					}
				}
			break;
		default:
			Assert( runInstModeNoSet == mode );
		}

	//	a bogus instance
	return ErrERRCheck( JET_errInvalidParameter );
	}

INLINE INST *PinstFromSesid( JET_SESID sesid )
	{
	AssertSzRTL( JET_SESID( ppibNil ) != sesid, "Invalid (NULL) Session ID parameter." );
	AssertSzRTL( JET_sesidNil != sesid, "Invalid (JET_sesidNil) Session ID parameter." ); 
	INST *pinst = PinstFromPpib( (PIB*)sesid );
	AssertSzRTL( NULL != pinst, "Invalid Session ID parameter - has NULL as an instance." );
	AssertSzRTL( (INST*)JET_instanceNil != pinst, "Invalid Session ID parameter - has (JET_instanceNil) as an instance." ); 
	return pinst;
	}



#ifdef PROFILE_JET_API

#ifdef DEBUG
#else
#error "PROFILE_JET_API can be defined only in debug mode"
#endif

#define PROFILE_LOG_JET_OP				1
#define PROFILE_LOG_CALLS_SUMMARY		2

INT		profile_detailLevel		= 0;
FILE *	profile_pFile			= 0;
QWORD	profile_qwTimeOffset	= 0;
CHAR	profile_szFileName[ IFileSystemAPI::cchPathMax ]	= "";

#define ProfileQwPrintMs__( x ) (((double)(signed __int64)(x)*1000)/(signed _int64)QwUtilHRTFreq())

#endif // PROFILE_JET_API



class APICALL
	{
	private:
		ERR			m_err;

#ifdef PROFILE_JET_API
		INT			m_profile_opCurrentOp;
		CHAR *		m_profile_szCurrentOp;
		QWORD		m_profile_tickStart;
#endif

	public:
		APICALL( const INT op )
			{
#ifdef PROFILE_JET_API
			//	UNDONE: need to specify the
			//	name of the op as the second
			//	param to the CProfileCounter
			//	constructor
			if ( opMax != op
				&& ( profile_detailLevel & PROFILE_LOG_JET_OP )
				&& NULL != profile_pFile )
				{
				m_profile_opCurrentOp = op;
//				m_profile_szCurrentOp = #op;	//	UNDONE: record API name
				m_profile_tickStart = QwUtilHRTCount();
				}
			else
				{
				m_profile_opCurrentOp = opMax;
				}
#endif

			//	UNDONE: a PIB will be required if
			//	actual logging of the op is ever
			//	re-enabled
			DebugLogJetOp( JET_sesidNil, op );
			}

		~APICALL()
			{
#ifdef PROFILE_JET_API
			if ( opMax != m_profile_opCurrentOp )
				{
				Assert( NULL != profile_pFile );
				Assert( profile_detailLevel & PROFILE_LOG_JET_OP );

				const QWORD	profile_tickEnd	= QwUtilHRTCount();
				const QWORD	qwTime			= m_profile_tickStart/QwUtilHRTFreq() + profile_qwTimeOffset;
				const INT	hour			= (INT)( ( qwTime / 3600 ) % 24 );
				const INT	min				= (INT)( ( qwTime / 60 ) % 60 );
				const INT	sec				= (INT)( qwTime % 60 );

				fprintf(
					profile_pFile,
					"%02d:%02d:%02d %03d %.3f ms\n",
					hour,
					min,
					sec,
					m_profile_opCurrentOp,		//	UNDONE: print m_profile_szCurrentOp instead
					ProfileQwPrintMs__( profile_tickEnd - m_profile_tickStart ) );
				}
#endif
			}

		ERR ErrResult() const				{ return m_err;	}
		VOID SetErr( const ERR err )		{ m_err = err; }
	};	//	APICALL

class APICALL_INST : public APICALL
	{
	private:
		INST *		m_pinst;

	public:
		APICALL_INST( const INT op ) : APICALL( op )	{}
		~APICALL_INST()									{}	

		INST * Pinst()									{ return m_pinst; }

		BOOL FEnter( const JET_INSTANCE instance )
			{
			const ERR	errT	=	ErrFindPinst( instance, &m_pinst );

			SetErr( errT >= JET_errSuccess ?
						m_pinst->ErrAPIEnter( fFalse ) :
						errT );

			return ( ErrResult() >= JET_errSuccess );
			}

		BOOL FEnterForInit( INST * const pinst )
			{
			m_pinst = pinst;
			SetErr( pinst->ErrAPIEnterForInit() );
			return ( ErrResult() >= JET_errSuccess );
			}

		BOOL FEnterForTerm( INST * const pinst )
			{
			m_pinst = pinst;
			SetErr( pinst->ErrAPIEnter( fTrue ) );
			return ( ErrResult() >= JET_errSuccess );
			}

		BOOL FEnterWithoutInit( INST * const pinst, const BOOL fAllowInitInProgress )
			{
			m_pinst = pinst;
			SetErr( pinst->ErrAPIEnterWithoutInit( fAllowInitInProgress ) );
			return ( ErrResult() >= JET_errSuccess );
			}

		VOID LeaveAfterCall( const ERR err )
			{
			m_pinst->APILeave();
			SetErr( err );
			}
	};

class APICALL_SESID : public APICALL
	{
	private:
		PIB *		m_ppib;

	public:
		APICALL_SESID( const INT op ) : APICALL( op )		{}
		~APICALL_SESID()									{}

		PIB * Ppib()										{ return m_ppib; }

		__forceinline BOOL FEnter(
			const JET_SESID		sesid,
			const BOOL			fIgnoreStopService = fFalse )
			{
			//	UNDONE: this check is a hack for single-
			//	instance mode to attempt to minimise the
			//	the concurrency holes that exists when
			//	API calls are made while the instance is
			//	terminating
			if ( g_cTermsInProgress >= ipinstMac )
				{
				SetErr( ErrERRCheck( 0 == ipinstMac ? JET_errNotInitialized : JET_errTermInProgress ) );
				return fFalse;
				}

			const INST * const	pinst	= PinstFromSesid( sesid );

			if ( pinst->m_fStopJetService && !fIgnoreStopService )
				{
				SetErr( ErrERRCheck( JET_errClientRequestToStopJetService ) );
				}
			else if ( pinst->FInstanceUnavailable() )
				{
				SetErr( ErrERRCheck( JET_errInstanceUnavailable ) );
				}
			else if ( pinst->m_fTermInProgress )
				{
				SetErr( ErrERRCheck( JET_errTermInProgress ) );
				}
			else
				{
				m_ppib = (PIB *)sesid;

				m_ppib->m_fInJetAPI = fTrue;

				//	Must check fTermInProgress again in case
				//	it got set after we set fInJetAPI to TRUE
				if ( pinst->m_fTermInProgress )
					{
					m_ppib->m_fInJetAPI = fFalse;
					SetErr( ErrERRCheck( JET_errTermInProgress ) );
					}
				else
					{
					SetErr( JET_errSuccess );
					}
				}

			return ( ErrResult() >= JET_errSuccess );
			}

		VOID LeaveAfterCall( const ERR err )
			{
			m_ppib->m_fInJetAPI = fFalse;
			SetErr( err );
			}
	};



LOCAL ERR INST::ErrAPIAbandonEnter_( const LONG lOld )
	{
	ERR		err;

	AtomicExchangeAdd( &m_cSessionInJetAPI, -1 );

	if ( lOld & fAPITerminating )
		{
		err = ErrERRCheck( JET_errTermInProgress );
		}
	else if ( lOld & fAPIRestoring )
		{
		err = ErrERRCheck( JET_errRestoreInProgress );
		}
	else 
		{
		//	note that init might have gotten in and succeeded by
		//	now, but return NotInit anyways
		err = ErrERRCheck( JET_errNotInitialized );
		}

	return err;
	}

LOCAL ERR INST::ErrAPIEnter( const BOOL fTerminating )
	{
	if ( !fTerminating )
		{
		if ( m_fStopJetService )
			{
			return ErrERRCheck( JET_errClientRequestToStopJetService );
			}
		else if ( FInstanceUnavailable() )
			{
			return ErrERRCheck( JET_errInstanceUnavailable );
			}
		}

	const LONG	lOld	= AtomicExchangeAdd( &m_cSessionInJetAPI, 1 );

	if ( ( ( lOld & maskAPILocked ) && !( lOld & fAPICheckpointing ) )
		|| 	!m_fJetInitialized )
		{
		return ErrAPIAbandonEnter_( lOld );
		}

	Assert( lOld < 0x0FFFFFFF );
	Assert( m_fJetInitialized );
	return JET_errSuccess;
	}

LOCAL ERR INST::ErrAPIEnterForInit()
	{
	ERR		err;
	
	if ( m_fJetInitialized )
		{
		err = ErrERRCheck( JET_errAlreadyInitialized );
		}
	else
		{
		long lT = AtomicExchangeAdd( &m_cSessionInJetAPI, 1 );
		Assert( lT >= 0 );
		err = JET_errSuccess;
		}
		
	return err;
	}

//	can enter API even if it's not initialised (but not if it's in progress)
LOCAL ERR INST::ErrAPIEnterWithoutInit( const BOOL fAllowInitInProgress )
	{
	ERR		err;
	LONG	lOld	= AtomicExchangeAdd( &m_cSessionInJetAPI, 1 );
	
	if ( ( lOld & maskAPILocked ) && !( lOld & fAPICheckpointing ) )
		{
		AtomicExchangeAdd( &m_cSessionInJetAPI, -1 );
		if ( lOld & fAPITerminating )
			{
			err = ErrERRCheck( JET_errTermInProgress );
			}
		else if ( lOld & fAPIRestoring )
			{
			err = ErrERRCheck( JET_errRestoreInProgress );
			}
		else
			{
			Assert( lOld & fAPIInitializing );
			err = ( fAllowInitInProgress ? JET_errSuccess : ErrERRCheck( JET_errInitInProgress ) );
			}
		}
	else
		{
		Assert( lOld < 0x0FFFFFFF );
		err = JET_errSuccess;
		}
		
	return err;
	}


INLINE VOID INST::APILeave()
	{
	const LONG	lOld	= AtomicExchangeAdd( &m_cSessionInJetAPI, -1 );
	Assert( lOld >= 1 );
	
	UtilAssertNotInAnyCriticalSection( );
	}


//	this function assumes we're in critpoolPinstAPI(&g_rgpinst[ipinst]).Crit()
BOOL INST::APILock( const LONG fAPIAction, const BOOL fNoWait )
	{
	LONG	lOld;
	
#ifdef DEBUG
	ULONG	cWaitForAllSessionsToLeaveJet = 0;
#endif
	
	Assert( fAPIAction & maskAPILocked );

	lOld = AtomicExchangeAdd( &m_cSessionInJetAPI, fAPIAction );

//	//	no one else could have the lock because we're in critpoolPinstAPI(&g_rgpinst[ipinst]).Crit()
//	Assert( !( lOld & maskAPILocked ) );
	
	while ( ( fAPIAction & fAPICheckpointing ) ?
				( lOld & maskAPILocked ) :
				( ( lOld & maskAPISessionCount ) > 1 || ( lOld & fAPICheckpointing ) ) )
		{
		if ( fNoWait )
			{
			lOld = AtomicExchangeAdd( &m_cSessionInJetAPI, -fAPIAction );
			return fFalse;
			}
			
		//	session still active, wait then retry
		AssertSz( ++cWaitForAllSessionsToLeaveJet < 10000,
			"The process has likely hung while attempting to terminate ESE.\nA thread was probably killed by the process while still in ESE." );
		UtilSleep( cmsecWaitGeneric );

		lOld = m_cSessionInJetAPI;	
		}

	Assert( 1 == ( lOld & maskAPISessionCount ) || fAPICheckpointing );
	Assert( m_cSessionInJetAPI & fAPIAction );

	return fTrue;
	}

VOID INST::APIUnlock( const LONG fAPIAction )
	{
	const LONG	lOld	= AtomicExchangeAdd( &m_cSessionInJetAPI, -fAPIAction );
	Assert( lOld & fAPIAction );
#ifdef DEBUG
	{
	long cSessionInJetAPI = m_cSessionInJetAPI; 
	Assert( 	!( cSessionInJetAPI & maskAPILocked )		// No one is holding except
			||	( cSessionInJetAPI & fAPICheckpointing )	// checkpointing, or
			||	( fAPIAction & fAPICheckpointing ) );		// Checkpointing itself is leaving
	}			
#endif
	}

VOID INST::EnterCritInst() { critInst.Enter(); } 
VOID INST::LeaveCritInst() { critInst.Leave(); }


ERR INST::ErrINSTSystemInit()
	{
	Assert( NULL != g_rgpinst );
	Assert( 0 == ipinstMac );
	Assert( NULL == wszInstanceNames );
	Assert( NULL == g_rgpPerfCounters );
	Assert( NULL == pInvalidPerfCounters );

	ERR err = JET_errSuccess;
	int i;

#ifdef PROFILE_JET_API
	Assert( NULL == profile_pFile );
	
	//	no file name specified
	if ( 0 == profile_szFileName[0] )
		{
		profile_detailLevel = 0;
		}
	if ( profile_detailLevel > 0 )
		{
		profile_pFile = fopen( profile_szFileName, "at" );
		if ( NULL != profile_pFile )
			{
			DATETIME datetime;
			profile_qwTimeOffset = QwUtilHRTCount();
			UtilGetCurrentDateTime( &datetime );
			profile_qwTimeOffset = 
				(QWORD)(datetime.hour*3600 + datetime.minute*60 + datetime.second)
				- profile_qwTimeOffset/QwUtilHRTFreq();
			fprintf( 
				profile_pFile, 
				"\n%02d:%02d:%02d [BEGIN %s]\n", 
				datetime.hour, 
				datetime.minute, 
				datetime.second, 
				SzUtilProcessName() );
			}
		}
#endif // PROFILE_JET_API

	//  allocate CS storage, but not as CSs (no default initializer)
	if ( !critpoolPinstAPI.FInit( ipinstMax, rankAPI, szAPI ) )
		{
		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}

	//	Initialize perfmon counters
	//	Init the array for the instance names
	wszInstanceNames = new WCHAR[ 2 * ( perfinstMax * ( cInstPerfName + 1) + 1 ) ];
	if ( NULL == wszInstanceNames)
		{
		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}

	// Init the dummy set of perfmon counters
	pInvalidPerfCounters = new CHAR[ g_iPerfCounterOffset ];
	if ( NULL == pInvalidPerfCounters )
		{
		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}
	memset( pInvalidPerfCounters, 0, g_iPerfCounterOffset );
	
	g_rgpPerfCounters = new CHAR *[perfinstMax];
	if ( NULL == g_rgpPerfCounters )
		{
		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}
	//	Init the array of pointers to sets of perfmon counters
	for ( i = 0; i < perfinstMax; i++ )
		{
		g_rgpPerfCounters[ i ] = pInvalidPerfCounters;
		}

	//	Init the global perf counter
	CHAR *pcT;
	pcT = new CHAR[ g_iPerfCounterOffset ];
	if ( NULL == pcT )
		{
		Call( ErrERRCheck( JET_errOutOfMemory ) );
		}

	memset( pcT, 0, g_iPerfCounterOffset );
	g_rgpPerfCounters[ perfinstGlobal ] = pcT;

HandleError:
	if ( JET_errSuccess > err )
		{
		INSTSystemTerm();
		}
	
	return err;
	}


VOID INST::INSTSystemTerm()
	{
	//	Free allocated perfmon counters
	if ( NULL != g_rgpPerfCounters )
		{
#ifdef DEBUG
		BOOL fNotUsed = fFalse;
#endif // DEBUG
		for ( int i = 0; i < perfinstMax; i++ )
			{
			Assert( NULL != g_rgpPerfCounters[ i ] );
			if ( pInvalidPerfCounters != g_rgpPerfCounters[ i ] )
				{
				Assert( !fNotUsed || perfinstGlobal == i );
				delete g_rgpPerfCounters[ i ];
				}
#ifdef DEBUG
			else
				{
				fNotUsed = fTrue;
				}
#endif // DEBUG
			}
		delete[] g_rgpPerfCounters;
		g_rgpPerfCounters = NULL;
		}
	delete[] pInvalidPerfCounters;
	pInvalidPerfCounters = NULL;
	delete[] wszInstanceNames;
	wszInstanceNames = NULL;

	//  terminate CS storage
	critpoolPinstAPI.Term();

#ifdef PROFILE_JET_API
	if ( NULL != profile_pFile )
		{
		DATETIME datetime;
		UtilGetCurrentDateTime( &datetime );
		fprintf( profile_pFile, "%02d:%02d:%02d [END %s]\n", datetime.hour, datetime.minute, datetime.second, SzUtilProcessName() );
		fclose( profile_pFile );
		profile_pFile = NULL;
		}
#endif
}

CCriticalSection critDBGPrint( CLockBasicInfo( CSyncBasicInfo( szDBGPrint ), rankDBGPrint, 0 ) );

VOID JET_API DBGFPrintF( char *sz )
	{
	critDBGPrint.Enter();
	FILE* f = fopen( szJetTxt, "a+" );
	if ( f != NULL )
		{
		fprintf( f, "%s", sz );
		fflush( f );
		fclose( f );
		}
	critDBGPrint.Leave();
	}


ERR ErrCheckUniquePath( INST *pinst )
	{
	ERR					err 						= JET_errSuccess;
	ERR					errFullPath					= JET_errSuccess;
	const BOOL			fTempDbForThisInst			= ( pinst->m_lTemporaryTablesMax > 0 && !pinst->FRecovering() );
	const BOOL			fRecoveryForThisInst		= !pinst->FComputeLogDisabled();
	IFileSystemAPI *	pfsapi						= NULL;
	ULONG				ipinstChecked				= 0;
	ULONG				ipinst;
	CHAR				rgchFullNameNew[IFileSystemAPI::cchPathMax];
	CHAR				rgchFullNameExist[IFileSystemAPI::cchPathMax];

	Call( ErrOSFSCreate( &pfsapi ) );

	INST::EnterCritInst();

	for ( ipinst = 0; ipinst < ipinstMax && ipinstChecked < ipinstMac; ipinst++ )
		{
		if ( !g_rgpinst[ ipinst ] )
			{
			continue;
			}
		ipinstChecked++;
		if ( g_rgpinst[ ipinst ] == pinst )
			{
			continue;
			}						
		if ( !g_rgpinst[ ipinst ]->m_fJetInitialized )
			{
			continue;
			}					

		//	check for file/path collisions against all other instances
		//
		//		check for temp database collisions
		//		check for log-path collisions
		//		check for system-path collisions

		//	if temp. database will be created,
		//	check for temp database collisions

		const BOOL	fTempDbForCurrInst	= ( g_rgpinst[ ipinst ]->m_lTemporaryTablesMax > 0
											&& !g_rgpinst[ ipinst ]->FRecovering() );	
		if ( fTempDbForCurrInst && fTempDbForThisInst )
			{
			Call( pfsapi->ErrPathComplete( g_rgpinst[ ipinst ]->m_szTempDatabase, rgchFullNameExist ) );		
			if ( JET_errSuccess == ( errFullPath = pfsapi->ErrPathComplete( pinst->m_szTempDatabase, rgchFullNameNew ) ) )
				{
				if ( !UtilCmpFileName( rgchFullNameExist, rgchFullNameNew ) )
					{
					err = ErrERRCheck( JET_errTempPathInUse );
					break;
					}			
				}
			else
				{
				Assert( JET_errInvalidPath == errFullPath );	//	our instance has a bad temp db name/path
				}
			}

		//	don't require checkpoint file or logfiles if log is disabled
		if ( !g_rgpinst[ ipinst ]->FComputeLogDisabled()
			&& fRecoveryForThisInst )
			{

			//	check for system path collisions

			Call( pfsapi->ErrPathComplete( g_rgpinst[ ipinst ]->m_szSystemPath, rgchFullNameExist ) );
			if ( JET_errSuccess == ( errFullPath = pfsapi->ErrPathComplete( pinst->m_szSystemPath, rgchFullNameNew ) ) )
				{
				if ( !UtilCmpFileName( rgchFullNameExist, rgchFullNameNew ) )
					{
					err = ErrERRCheck( JET_errSystemPathInUse );
					break;
					}
				}
			else
				{
				Assert( JET_errInvalidPath == errFullPath );	//	our instance has a bad system path
				}

			Call( pfsapi->ErrPathComplete( g_rgpinst[ ipinst ]->m_plog->m_szLogFilePath, rgchFullNameExist ) );		
			if ( JET_errSuccess == ( errFullPath = pfsapi->ErrPathComplete( pinst->m_plog->m_szLogFilePath, rgchFullNameNew ) ) )
				{
				if ( !UtilCmpFileName( rgchFullNameExist, rgchFullNameNew ) )
					{
					err = ErrERRCheck( JET_errLogFilePathInUse );
					break;
					}
				}
			else
				{
				Assert( JET_errInvalidPath == errFullPath );	//	our instance has a bad log path
				}
			}
		}
		
	INST::LeaveCritInst();

HandleError:

	delete pfsapi;
	return err;
	}

BOOL FUtilFileOnlyName( const char * szFileName)
	{
	char *szFound;

	OSSTRCharFindA( szFileName, bPathDelimiter, &szFound );
	if ( szFound )
		{
		return fFalse;
		}

	OSSTRCharFindA( szFileName, ':', &szFound );
	if ( szFound )
		{
		return fFalse;
		}

	return fTrue;
	}



	
/*=================================================================
ErrInit

Description:
  This function initializes Jet and the built-in ISAM.	It expects the
  DS register to be set correctly for this instance.

Return Value:
  JET_errSuccess if the routine can perform all operations cleanly;
  some appropriate error value otherwise.

=================================================================*/

LOCAL JET_ERR ErrInit(	INST		*pinst, 
						BOOL		fSkipIsamInit, 
						JET_GRBIT	grbit )
	{
	JET_ERR		err;

	Assert( !pinst->m_fJetInitialized );
	Assert( !pinst->m_fTermInProgress );

	if ( FUtilFileOnlyName( pinst->m_szTempDatabase ) )
		{
		char	szT[IFileSystemAPI::cchPathMax];

		//	the temporary database doesn't have a valid path
		//	use the system path as a default location (sys-path + '\' + tmpdbname + NULL)

		const DWORD cchSystemPath	= LOSSTRLengthA( pinst->m_szSystemPath );
		const DWORD cchTempPath		= LOSSTRLengthA( pinst->m_szTempDatabase );

		if ( cchSystemPath + 1 + cchTempPath + 1 > IFileSystemAPI::cchPathMax )
			{
			return ErrERRCheck( JET_errOutOfMemory );
			}

		//	copy temp database filename

		OSSTRCopyA( szT, pinst->m_szTempDatabase );

		//	construct full temp db name/path

		CallR( pinst->m_pfsapi->ErrPathBuild(
					pinst->m_szSystemPath,
					szT,
					NULL,
					pinst->m_szTempDatabase ) );
		}

	//	check for name/path collisions

	Call( ErrCheckUniquePath( pinst ) );

	/*	initialize the integrated ISAM
	/**/
	if ( !fSkipIsamInit )
		{
		Call( ErrIsamInit( JET_INSTANCE( pinst ), grbit ) );
		}

	return JET_errSuccess;

HandleError:
	Assert( err < 0 );
	return err;
	}


/*=================================================================
ErrSetSystemParameter

Description:
  This function sets system parameter values.  It calls ErrSetGlobalParameter
  to set global system parameters and ErrSetSessionParameter to set dynamic
  system parameters.

Parameters:
  sesid 		is the optional session identifier for dynamic parameters.
  sysParameter	is the system parameter code identifying the parameter.
  lParam		is the parameter value.
  sz			is the zero terminated string parameter.

Return Value:
  JET_errSuccess if the routine can perform all operations cleanly;
  some appropriate error value otherwise.

Errors/Warnings:
  JET_errInvalidParameter:
	Invalid parameter code.
  JET_errAlreadyInitialized:
	Initialization parameter cannot be set after the system is initialized.
  JET_errInvalidSesid:
	Dynamic parameters require a valid session id.

Side Effects: None
=================================================================*/

VOID SetCbPageRelated()
	{
	g_cbColumnLVChunkMost = g_cbPage - JET_cbColumnLVPageOverhead;

	g_cbLVBuf = 8 * g_cbColumnLVChunkMost;
	
	if ( 2048 == g_cbPage )
		{
		g_shfCbPage	= 11;
		}
	else if ( 8192 == g_cbPage )
		{
		g_shfCbPage	= 13;
		}
	else
		{
		Assert( 4096 == g_cbPage );
		g_shfCbPage	= 12;
		}

	cbRECRecordMost = REC::CbRecordMax();
#ifdef INTRINSIC_LV
	cbLVIntrinsicMost = cbRECRecordMost - sizeof(REC::cbRecordHeader) - sizeof(TAGFLD) - sizeof(TAGFLD_HEADER);
#endif INTRINSIC_LV
	}


// Allowed only from a general point of view, at other leveles (like BF)
// the SetSystemParam call may fail if an instance is running
LOCAL BOOL FAllowSetGlobalSysParamAfterStart( unsigned long paramid )
	{
	switch ( paramid )
		{
		case JET_paramCacheSizeMin:
		case JET_paramCacheSize:
		case JET_paramCacheSizeMax:
		case JET_paramCheckpointDepthMax:
		case JET_paramLRUKCorrInterval:
		case JET_paramLRUKHistoryMax:
		case JET_paramLRUKPolicy:
		case JET_paramLRUKTimeout:
		case JET_paramLRUKTrxCorrInterval:
		case JET_paramOutstandingIOMax:
		case JET_paramStartFlushThreshold:
		case JET_paramStopFlushThreshold:
		case JET_paramTableClassName:
		case JET_paramAssertAction:
		case JET_paramExceptionAction:
		case JET_paramPageHintCacheSize:
		case JET_paramOSSnapshotTimeout:
			return fTrue;
		}
		
	return fFalse;
	}
	
LOCAL ERR ErrAPICheckInstInit( const INST * const pinst )
	{
	Assert( pinstNil != pinst );
	return ( pinst->m_fJetInitialized ?
					ErrERRCheck( JET_errAlreadyInitialized ) :
					JET_errSuccess );
	}

LOCAL ERR ErrAPICheckSomeInstInit()
	{
	return ( FINSTSomeInitialized() ?
					ErrERRCheck( JET_errAlreadyInitialized ) :
					JET_errSuccess );
	}

JET_ERR JET_API ErrSetSystemParameter(
	JET_INSTANCE	jinst,
	JET_SESID		sesid,
	unsigned long	paramid,
	ULONG_PTR		ulParam,
	const char  	*sz )
	{
	ERR				err 	= JET_errSuccess;
	INST			*pinst 	= (INST *)jinst;

	IFileSystemAPI* pfsapi	= NULL;

	//
	//	NOTE: this function verifies that multiple instances do not use the same paths
	//		  it checks the paths using the OS file-system because the OS file-system
	//			  is the only one that is used with these paths
	//

	Call( ErrOSFSCreate( &pfsapi ) );

#ifdef DEBUG
	if ( !pinst )
		{
		Assert( RUNINSTGetMode() == runInstModeNoSet
			|| FAllowSetGlobalSysParamAfterStart( paramid )
			|| !g_fSystemInit // during IsamSystemInit (ErrOSUConfigInit) we may set global params
			);
		}
	else
		{
		Assert( !sesid
			|| JET_sesidNil == sesid
			|| pinst == PinstFromPpib( (PIB *)sesid ) );
		}
#endif		

	//	size of string argument
	//
	unsigned		cch;
	//	temporary string for path verification
	//
	CHAR			szT[IFileSystemAPI::cchPathMax];

	switch ( paramid )
		{
	case JET_paramSystemPath:		

		char *szSystemPath;
		
		if ( ( cch = (ULONG)strlen(sz) ) >= IFileSystemAPI::cchPathMax )
			{
			Call( ErrERRCheck( JET_errInvalidParameter ) );
			}
		if ( pinst )
			{			
			//	path to the checkpoint file
			//
			Call( ErrAPICheckInstInit( pinst ) );
			szSystemPath = pinst->m_szSystemPath;
			}
		else
			{
			szSystemPath = g_szSystemPath;
			}
			
		//	verify validity of path (always uses the OS file-system)
		//
		Call( pfsapi->ErrPathComplete( sz, szT ) );
		cch = (ULONG)strlen( szT );

		//	ensure there's enough room to append the name of the 
		//	checkpoint file (+1 in case a trailing path delimiter
		//	is required)
		if ( cch + 1 + cbUnpathedFilenameMax >= IFileSystemAPI::cchPathMax )
			{
			Call( ErrERRCheck( JET_errInvalidParameter ) );
			}

		UtilMemCpy( szSystemPath, szT, cch + 1 );
        if ( !FOSSTRTrailingPathDelimiter( szSystemPath ) )
			{
			//	path must be '\\' terminated
			OSSTRAppendPathDelimiter( szSystemPath, fFalse );
			}
		break;

	case JET_paramTempPath:

		char * 		szTempDatabase;
		
		cch = (ULONG)strlen( sz );
		if ( cch >= IFileSystemAPI::cchPathMax )
			{
			Call( ErrERRCheck( JET_errInvalidParameter ) );
			}
			
		//	path to the temporary file directory
		//
		if ( pinst )
			{			
			Call( ErrAPICheckInstInit( pinst ) );
			szTempDatabase = pinst->m_szTempDatabase;
			}
		else
			{
			szTempDatabase = g_szTempDatabase;
			}
			
		//	verify validity of path (always uses the OS file-system)
		//
		Call( pfsapi->ErrPathComplete( sz, szT ) );
		cch = (ULONG)strlen( szT );

		if ( FOSSTRTrailingPathDelimiter( const_cast< char * >( sz ) ) )
			{
			// If there's a trailing backslash, then this is a directory and
			// we must tack on the file name.

			// If user-specified directory had a trailing backslash, then the
			// fullpathed() directory should have one as well.
			Assert( FOSSTRTrailingPathDelimiter( szT ) );

			// Check that appending the filename doesn't exceed the maximum
			// Can't be equal to IFileSystemAPI::cchPathMax because IFileSystemAPI::cchPathMax includes the
			// null terminator.
			if ( cch + cbUnpathedFilenameMax >= IFileSystemAPI::cchPathMax )
				{
				Call( ErrERRCheck( JET_errInvalidParameter ) );
				}

			Call( pfsapi->ErrPathBuild( szT, szDefaultTempDbFileName, szDefaultTempDbExt, szTempDatabase ) );
			}
		else if ( FUtilFileOnlyName( sz ) )
			{
			// if only a file name specified, the file will get
			// created in the system directory (see ErrInit())
			UtilMemCpy( szTempDatabase, sz, strlen( sz ) + 1 );
			}
		else
			{
			if ( cch >= IFileSystemAPI::cchPathMax )
				{
				Call( ErrERRCheck( JET_errInvalidParameter ) );
				}

			// If no trailing backslash, then this is the pathed filename of
			// the temporary database.
			UtilMemCpy( szTempDatabase, szT, cch + 1 );
			}
		break;

	case JET_paramCreatePathIfNotExist:
		if ( pinst )
			pinst->m_fCreatePathIfNotExist = ( ulParam ? fTrue : fFalse );
		else
			g_fCreatePathIfNotExist = ( ulParam ? fTrue : fFalse );
		break;

	case JET_paramDbExtensionSize:				/* database expansion steps, default is 16 pages */
		if ( ulParam >= LONG_MAX || ulParam == 0 )
			Call( ErrERRCheck( JET_errInvalidParameter ) );
		if ( pinst )
			pinst->m_cpgSESysMin = (CPG)ulParam;
		else
			g_cpgSESysMin = (CPG)ulParam;
		break;

	case JET_paramPageReadAheadMax:	//	UNDONE: remove this parameter
///		Call( ErrERRCheck( JET_errInvalidParameter ) );
		break;

	case JET_paramPageTempDBMin:
		if ( ulParam >= LONG_MAX )
			Call( ErrERRCheck( JET_errInvalidParameter ) );
		if ( pinst )
			pinst->m_cpageTempDBMin = (CPG)ulParam;
		else
			g_cpageTempDBMin = (CPG)ulParam;
		break;
			
	case JET_paramEnableTempTableVersioning:	/* version all temp table operations */
		if ( pinst )
			pinst->m_fTempTableVersioning = ( ulParam ? fTrue : fFalse );
		else
			g_fTempTableVersioning = ( ulParam ? fTrue : fFalse );
		break;

	case JET_paramZeroDatabaseDuringBackup:	/* zero deleted records/orphaned LVs during backup */
		if ( pinst )
			pinst->m_plog->m_fScrubDB = ulParam ? fTrue:fFalse;
		else
			g_fScrubDB = ulParam ? fTrue:fFalse;
			
		break;

	case JET_paramSLVDefragFreeThreshold:
		if ( pinst )
			{
			pinst->m_lSLVDefragFreeThreshold = (LONG)ulParam;
			}
		else
			{
			g_lSLVDefragFreeThreshold = (LONG)ulParam;
			}
		break;
		
	case JET_paramSLVDefragMoveThreshold:
		if( pinst )
			{
			pinst->m_lSLVDefragMoveThreshold = (LONG)ulParam;
			}
		else
			{
			g_lSLVDefragMoveThreshold = (LONG)ulParam;
			}
		break;

	case JET_paramIgnoreLogVersion:
		Call( ErrAPICheckSomeInstInit() );
		if ( pinst )
			{
			pinst->m_plog->m_fLGIgnoreVersion = ( ulParam ? fTrue : fFalse );
			}
		else
			{
			g_fLGIgnoreVersion = ( ulParam ? fTrue : fFalse );
			}
		break;
		
	case JET_paramCheckFormatWhenOpenFail:		/* check format number when db/log open fails */
/*
 * This is no longer a system param - we ALWAYS do this check on open failure
 *
		g_fCheckFormatWhenOpenFail = ( ulParam ? fTrue : fFalse );
*
*/
		break;
	case JET_paramMaxSessions:					/* Maximum number of sessions */
		if ( ulParam > cpibMax )
			Call( ErrERRCheck( JET_errInvalidParameter ) );
		if ( pinst )
			pinst->m_lSessionsMax = (LONG)ulParam;
		else
			g_lSessionsMax = (LONG)ulParam;
		break;

	case JET_paramMaxOpenTables:				/* Maximum number of open tables */
		if ( ulParam >= LONG_MAX )
			Call( ErrERRCheck( JET_errInvalidParameter ) );
		if ( pinst )
			pinst->m_lOpenTablesMax = (LONG)ulParam;
		else
			g_lOpenTablesMax = (LONG)ulParam;
		break;

	case JET_paramPreferredMaxOpenTables:	/* Preferred maximum number of open tables */
		if ( ulParam >= LONG_MAX )
			Call( ErrERRCheck( JET_errInvalidParameter ) );
		if ( pinst )
			pinst->m_lOpenTablesPreferredMax = (LONG)ulParam;
		else
			g_lOpenTablesPreferredMax = (LONG)ulParam;
		break;

	case JET_paramMaxTemporaryTables:
		if ( ulParam >= LONG_MAX )
			Call( ErrERRCheck( JET_errInvalidParameter ) );
		if ( pinst )
			pinst->m_lTemporaryTablesMax = (LONG)ulParam;
		else
			g_lTemporaryTablesMax = (LONG)ulParam;
		break;

	case JET_paramMaxCursors:					/* maximum number of open cursors */
		if ( ulParam >= LONG_MAX )
			Call( ErrERRCheck( JET_errInvalidParameter ) );
		if ( pinst )
			pinst->m_lCursorsMax = (LONG)ulParam;
		else
			g_lCursorsMax = (LONG)ulParam;
		break;

	case JET_paramMaxVerPages:					/* Maximum number of modified pages */
		{
		if ( 0 == ulParam || ulParam >= LONG_MAX )
			Call( ErrERRCheck( JET_errInvalidParameter ) );
		const ULONG cbucket = ULONG( 1 + ( ulParam * 16 * 1024 - 1 ) / cbBucket );
		if ( pinst )
			{
			Call( ErrAPICheckInstInit( pinst ) );
			pinst->m_lVerPagesMax = cbucket;
			if ( ! pinst->m_fPreferredSetByUser )
				{
				// if user hasn't set InstancePrefer, set to same as max
				// for clients that aren't InstancePrefer "aware".
				pinst->m_lVerPagesPreferredMax = LONG( pinst->m_lVerPagesMax * ((double)g_lVerPagesPreferredMax / g_lVerPagesMax) );
				}
			}
		else
			{
			g_lVerPagesMax = cbucket;
			if ( ! g_fGlobalMinSetByUser )
				{
				// if user hasn't set GlobalMin, set to same as max
				// for clients that aren't GlobalMin "aware".
				g_lVerPagesMin = cbucket;
				}
			if ( ! g_fGlobalPreferredSetByUser	)
				{
				// if user hasn't set GlobalPrefer, set to same as max
				// for clients that aren't GlobalPrefer "aware".
				g_lVerPagesPreferredMax = LONG( g_lVerPagesMax * 0.9 );
				}
			}
		}
		break;

	case JET_paramGlobalMinVerPages:			/* Global minimum number of modified pages for all instances */
		{
		if ( 0 == ulParam || ulParam >= LONG_MAX )
			Call( ErrERRCheck( JET_errInvalidParameter ) );
		const ULONG cbucket = ULONG( 1 + ( ulParam * 16 * 1024 - 1 ) / cbBucket );
		if ( pinst )
			{
			Call( ErrERRCheck( JET_errInvalidParameter ) );
			}
		else
			{
			g_fGlobalMinSetByUser = fTrue;
			g_lVerPagesMin = cbucket;
			}
		}
		break;

	case JET_paramPreferredVerPages:			/* Preferred number of modified pages */
		{
		if ( 0 == ulParam || ulParam >= LONG_MAX )
			Call( ErrERRCheck( JET_errInvalidParameter ) );
		const ULONG cbucket = ULONG( 1 + ( ulParam * 16 * 1024 - 1 ) / cbBucket );
		if ( pinst )
			{
			pinst->m_fPreferredSetByUser = fTrue;
			pinst->m_lVerPagesPreferredMax = cbucket;
			}
		else
			{
			g_fGlobalPreferredSetByUser = fTrue;
			g_lVerPagesPreferredMax = cbucket;
			}
		}
		break;

	case JET_paramLogBuffers:
		if ( ulParam >= LONG_MAX )
			Call( ErrERRCheck( JET_errInvalidParameter ) );
			
		if (pinst)
			{
			pinst->m_lLogBuffers = (LONG)ulParam;
			if ( pinst->m_lLogBuffers < lLogBufferMin )
				pinst->m_lLogBuffers = lLogBufferMin;
			}
		else	
			{
			g_lLogBuffers = (LONG)ulParam;
			if ( g_lLogBuffers < lLogBufferMin )
				g_lLogBuffers = lLogBufferMin;
			}
		break;

	case JET_paramLogFileSize:
		{
		LONG	lLogFileSize	= (LONG)ulParam;

		if ( ulParam >= LONG_MAX )
			Call( ErrERRCheck( JET_errInvalidParameter ) );

		if ( lLogFileSize < lLogFileSizeMin )
			lLogFileSize = lLogFileSizeMin;

		if ( pinst )
			{			
			Call( ErrAPICheckInstInit( pinst ) );
			pinst->m_lLogFileSize = lLogFileSize;
			pinst->m_fSetLogFileSize = fTrue;
			}
		else
			{
			g_lLogFileSize = lLogFileSize;
			g_fSetLogFileSize = fTrue;
			}
		}
		break;

	case JET_paramLogCheckpointPeriod:
		//  no longer used
		break;

	case JET_paramWaitLogFlush:
		//  no longer used
		break;

	case JET_paramCommitDefault:
		//	validate grbits before setting them as defaults
		if ( ulParam & ~(JET_bitCommitLazyFlush|JET_bitWaitLastLevel0Commit) )
			Call( ErrERRCheck( JET_errInvalidParameter ) );
		
		if ( 0 == sesid || JET_sesidNil == sesid )
			{
			if ( pinst )
				pinst->m_grbitsCommitDefault = (LONG)ulParam;
			else
				g_grbitsCommitDefault = (LONG)ulParam;
			}
		else
			{
			CallS( ErrIsamSetCommitDefault( sesid, (LONG)ulParam ) );
			}
		break;

	case JET_paramLogWaitingUserMax:
		//  no longer used
		break;

	case JET_paramLogFilePath:

		char *szLogFilePath;
		
		//	path to the log file directory
		//
		if ( ( cch = (ULONG)strlen(sz) ) >= cbFilenameMost )
			{
			Call( ErrERRCheck( JET_errInvalidParameter ) );
			}
		if ( pinst )
			{			
			//	path to the checkpoint file
			//
			Call( ErrAPICheckInstInit( pinst ) );
			szLogFilePath = pinst->m_plog->m_szLogFilePath;
			}
		else
			{
			szLogFilePath = g_szLogFilePath;
			}
			
		//	verify validity of path (always uses the OS file-system)
		//
		Call( pfsapi->ErrPathComplete( sz, szT ) );
		cch = (ULONG)strlen( szT );

		//	ensure there's enough room to append the name of the 
		//	log files (+1 in case a trailing path delimiter
		//	is required)
		if ( cch + 1 + cbUnpathedFilenameMax >= IFileSystemAPI::cchPathMax )
			{
			Call( ErrERRCheck( JET_errInvalidParameter ) );
			}

		UtilMemCpy( szLogFilePath, szT, cch + 1 );
		if ( !FOSSTRTrailingPathDelimiter( szLogFilePath ) )
			{
			//	path must be '\\' terminated
			OSSTRAppendPathDelimiter( szLogFilePath, fFalse );
			}
		break;

	case JET_paramRecovery:			/* Switch for recovery on/off */
		if ( ( cch = (ULONG)strlen( sz ) ) >= cbFilenameMost )
			Call( ErrERRCheck( JET_errInvalidParameter ) );

		if ( 0 == strcmp( sz, "ESEUTIL" ) )
			{
			//	hack to allow us to know that this process is ESEUTIL
			fGlobalEseutil = fTrue;
			}
		else if ( fGlobalEseutil && 0xE5E == ulParam )
			{
			//	hack to allow specifying an alternate db directory for recovery
			g_fAlternateDbDirDuringRecovery = fTrue;

			//	verify validity of path (always uses the OS file-system)
			//
			Call( pfsapi->ErrPathComplete( sz, g_szAlternateDbDirDuringRecovery ) );
			}
		else if ( pinst )
			{
			Assert (pinst->m_plog);
			UtilMemCpy( pinst->m_plog->m_szRecovery, sz, cch + 1 );
			}
		else
			{
			UtilMemCpy( g_szRecovery, sz, cch + 1 );
			}
		break;

	case JET_paramEventLogCache:
		Call( ErrAPICheckSomeInstInit() );
		if ( ulParam >= LONG_MAX )
			Call( ErrERRCheck( JET_errInvalidParameter ) );
		g_cbEventHeapMax = (LONG)ulParam;
		break;

	case JET_paramBackupChunkSize:
		Call( ErrAPICheckSomeInstInit() );
		if ( 0 == ulParam || ulParam >= LONG_MAX )
			Call( ErrERRCheck( JET_errInvalidParameter ) );
		g_cpgBackupChunk = (CPG)ulParam;
		break;

	case JET_paramBackupOutstandingReads:
		Call( ErrAPICheckSomeInstInit() );
		if ( 0 == ulParam || ulParam >= LONG_MAX )
			Call( ErrERRCheck( JET_errInvalidParameter ) );
		g_cBackupRead = (LONG)ulParam;
		break;
		
	case JET_paramExceptionAction:
#ifdef CATCH_EXCEPTIONS
		Call( ErrAPICheckSomeInstInit() );
		g_fCatchExceptions = ( JET_ExceptionMsgBox == ulParam );
#else  //  !CATCH_EXCEPTIONS
		Call( ErrERRCheck( JET_errInvalidParameter ) );
#endif	//	CATCH_EXCEPTIONS
		break;

	case JET_paramPageFragment:
		if ( ulParam >= LONG_MAX )
			Call( ErrERRCheck( JET_errInvalidParameter ) );
		if ( pinst )
			pinst->m_lPageFragment = (LONG)ulParam;
		else
			g_lPageFragment = (LONG)ulParam;
		break;

	case JET_paramVersionStoreTaskQueueMax:
		if ( ulParam >= LONG_MAX )
			Call( ErrERRCheck( JET_errInvalidParameter ) );
		if ( pinst )
			{
			Assert( NULL != pinst->m_pver );
			Call( ErrAPICheckInstInit( pinst ) );
			pinst->m_pver->m_ulVERTasksPostMax = (ULONG)ulParam;
			}
		else
			{
			g_ulVERTasksPostMax = (ULONG)ulParam;
			}
		break;

	case JET_paramDeleteOldLogs:
		if ( pinst )
			{
			Assert( NULL != pinst->m_plog );
			Call( ErrAPICheckInstInit( pinst ) );
			pinst->m_plog->m_fDeleteOldLogs = ( ulParam ? fTrue : fFalse );
			}
		else
			{
			g_fDeleteOldLogs = ( ulParam ? fTrue : fFalse );
			}
		break;

	case JET_paramDeleteOutOfRangeLogs:
		if ( pinst )
			{
			Assert( NULL != pinst->m_plog );
			Call( ErrAPICheckInstInit( pinst ) );
			pinst->m_plog->m_fDeleteOutOfRangeLogs = ( ulParam ? fTrue : fFalse );
			}
		else
			{
			g_fDeleteOutOfRangeLogs = ( ulParam ? fTrue : fFalse );
			}
		break;

	case JET_paramAccessDeniedRetryPeriod:
		//	silently cap retry period at 1 minute
		IFileSystemAPI::cmsecAccessDeniedRetryPeriod = (ULONG)min( ulParam, 60000 );
		break;

	case JET_paramEnableOnlineDefrag:
		if ( pinst )
			pinst->m_fOLDLevel = (LONG)ulParam;
		else
			g_fGlobalOLDLevel = (LONG)ulParam;
		break;
		
	case JET_paramAssertAction:
		g_wAssertAction = (UINT)ulParam;
		break;

	case JET_paramCircularLog:
		if ( pinst )
			{
			Call( ErrAPICheckInstInit( pinst ) );
			Assert ( NULL != pinst->m_plog );
			pinst->m_plog->m_fLGCircularLogging = ( ulParam ? fTrue : fFalse );
			}
		else
			{
			g_fLGCircularLogging = ( ulParam ? fTrue : fFalse );
			}
		break;

#ifdef RFS2
	case JET_paramRFS2AllocsPermitted:
		if ( ulParam >= LONG_MAX )
			Call( ErrERRCheck( JET_errInvalidParameter ) );
		g_fDisableRFS = fFalse;
		g_cRFSAlloc = (LONG)ulParam;
		break;

	case JET_paramRFS2IOsPermitted:
		if ( ulParam >= LONG_MAX )
			Call( ErrERRCheck( JET_errInvalidParameter ) );
		g_fDisableRFS = fFalse;
		g_cRFSIO = (LONG)ulParam;
		break;
#endif 

	case JET_paramBaseName:
		{
		if ( strlen(sz) != 3 )
			Call( ErrERRCheck( JET_errInvalidParameter ) );

		if ( pinst )
			{
			LOG		* plog	= pinst->m_plog;

			Call( ErrAPICheckInstInit( pinst ) );

			strcpy( plog->m_szBaseName, sz );

			strcpy( plog->m_szJet, sz );

			strcpy( plog->m_szJetLog, sz );
			strcat( plog->m_szJetLog, szLogExt );

			strcpy( plog->m_szJetLogNameTemplate, sz );
			strcat( plog->m_szJetLogNameTemplate, "00000" );

			strcpy( plog->m_szJetTmp, sz );
			strcat( plog->m_szJetTmp, "tmp" );

			strcpy( plog->m_szJetTmpLog, plog->m_szJetTmp );
			strcat( plog->m_szJetTmpLog, szLogExt );

//			UNDONE: No point setting szJetTxt on a
//			per-instance basis because the print
//			function (DBGFPrintF) does not take an INST
//			strcpy( pinst->m_szJetTxt, sz );
//			strcat( pinst->m_szJetTxt, ".txt" );		 
			}
		else
			{
			strcpy( szBaseName, sz );

			strcpy( szJet, sz );

			strcpy( szJetLog, sz );
			strcat( szJetLog, szLogExt );

			strcpy( szJetLogNameTemplate, sz );
			strcat( szJetLogNameTemplate, "00000" );

			strcpy( szJetTmp, sz );
			strcat( szJetTmp, "tmp" );

			strcpy( szJetTmpLog, szJetTmp );
			strcat( szJetTmpLog, szLogExt );

			strcpy( szJetTxt, sz );
			strcat( szJetTxt, ".txt" );		 
			}
		break;
		}

	case JET_paramBatchIOBufferMax:
		break;

	case JET_paramCacheSizeMin:
		Call( ErrBFSetCacheSizeMin( ulParam ) );
		break;

	case JET_paramCacheSize:
		Call( ErrBFSetCacheSize( ulParam ) );
		break;

	case JET_paramCacheSizeMax:
		Call( ErrBFSetCacheSizeMax( ulParam ) );
		break;

	case JET_paramCheckpointDepthMax:
		Call( ErrBFSetCheckpointDepthMax( ulParam ) );
		break;

	case JET_paramLRUKCorrInterval:
		Call( ErrBFSetLRUKCorrInterval( ulParam ) );
		break;

	case JET_paramLRUKHistoryMax:
		break;

	case JET_paramLRUKPolicy:
		Call( ErrBFSetLRUKPolicy( ulParam ) );
		break;

	case JET_paramLRUKTimeout:
		Call( ErrBFSetLRUKTimeout( ulParam ) );
		break;

	case JET_paramLRUKTrxCorrInterval:
		break;

	case JET_paramOutstandingIOMax:
		break;

	case JET_paramStartFlushThreshold:
		Call( ErrBFSetStartFlushThreshold( ulParam ) );
		break;

	case JET_paramStopFlushThreshold:
		Call( ErrBFSetStopFlushThreshold( ulParam ) );
		break;

	case JET_paramTableClassName:
		break;

	case JET_paramEnableIndexChecking:
		fGlobalIndexChecking = ( ulParam ? fTrue : fFalse );
		break;

	case JET_paramLogFileFailoverPath:

		char *szLogFileFailoverPath;
	
		if ( ( cch = (ULONG)strlen(sz) ) >= cbFilenameMost )
			{
			Call( ErrERRCheck( JET_errInvalidParameter ) );
			}
		if ( pinst )
			{			
			//	path to the checkpoint file
			//
			Call( ErrAPICheckInstInit( pinst ) );
			szLogFileFailoverPath = pinst->m_plog->m_szLogFileFailoverPath;
			}
		else
			{
			szLogFileFailoverPath = g_szLogFileFailoverPath;
			}
			
		//	verify validity of path (always uses the OS file-system)

		Call( pfsapi->ErrPathComplete( sz, szT ) );
		cch = (ULONG)strlen( szT );

		UtilMemCpy( szLogFileFailoverPath, szT, cch + 1 );
		if ( !FOSSTRTrailingPathDelimiter( szLogFileFailoverPath ) )
			{
			//	path must be '\\' terminated
			if ( cch+1 >= IFileSystemAPI::cchPathMax )
				{
				Call( ErrERRCheck( JET_errInvalidParameter ) );
				}
			OSSTRAppendPathDelimiter( szLogFileFailoverPath, fFalse );
			}
		break;

	case JET_paramLogFileCreateAsynch:
		if ( pinst )
			{
			Call( ErrAPICheckInstInit( pinst ) );
			pinst->m_plog->m_fCreateAsynchLogFile = ulParam ? fTrue : fFalse;
			}
		else
			{
			g_fLogFileCreateAsynch = ulParam ? fTrue : fFalse;
			}
		break;
		
	case JET_paramEnableImprovedSeekShortcut:
		Call( ErrAPICheckSomeInstInit() );
		g_fImprovedSeekShortcut = ( ulParam ? fTrue : fFalse );
		break;

	case JET_paramEnableSortedRetrieveColumns:
		Call( ErrAPICheckSomeInstInit() );
		g_fSortedRetrieveColumns = ( ulParam ? fTrue : fFalse );
		break;

	case JET_paramDatabasePageSize:
		Call( ErrAPICheckSomeInstInit() );
		if ( ulParam != 2048 && ulParam != 4096 && ulParam != 8192 )
			Call( ErrERRCheck( JET_errInvalidParameter) );
		g_cbPage = (LONG)ulParam;
		SetCbPageRelated();

#ifdef DEBUG
		g_fCbPageSet = fTrue;
#endif // DEBUG		
		break;
		
	case JET_paramEventSource:

		char *szEventSource;
		
		if ( ( cch = (ULONG)strlen( sz ) ) >= cbFilenameMost )
			Call( ErrERRCheck( JET_errInvalidParameter ) );
			
		if ( pinst )
			{			
			Call( ErrAPICheckInstInit( pinst ) );
			szEventSource = pinst->m_szEventSource;
			}
		else
			{
			szEventSource = g_szEventSource;
			}
			
		UtilMemCpy( szEventSource, sz, cch + 1 );
		break;

	case JET_paramEventSourceKey:
	
		char *szEventSourceKey;
		
		if ( ( cch = (ULONG)strlen( sz ) ) >= cbFilenameMost )
			Call( ErrERRCheck( JET_errInvalidParameter ) );
			
		if ( pinst )
			{			
			Call( ErrAPICheckInstInit( pinst ) );
			szEventSourceKey = pinst->m_szEventSourceKey;
			}
		else
			{
			szEventSourceKey = g_szEventSourceKey;
			}
			
		UtilMemCpy( szEventSourceKey, sz, cch + 1 );
		break;
		
	case JET_paramNoInformationEvent:
		if ( pinst )
			pinst->m_fNoInformationEvent = ( ulParam ? fTrue : fFalse );
		else
			g_fNoInformationEvent = ( ulParam ? fTrue : fFalse );
		break;

	case JET_paramEventLoggingLevel:
		if ( ulParam >= LONG_MAX )
			Call( ErrERRCheck( JET_errInvalidParameter ) );
		if ( pinst )
			pinst->m_lEventLoggingLevel = (LONG)ulParam;
		else
			g_lEventLoggingLevel = (LONG)ulParam;
		break;
	
	case JET_paramDisableCallbacks:
		Call( ErrAPICheckSomeInstInit() );
		g_fCallbacksDisabled = ( ulParam ? fTrue : fFalse );
		break;

	case JET_paramSLVProviderEnable:
		if ( pinst )
			{			
			Call( ErrAPICheckInstInit( pinst ) );
			pinst->m_fSLVProviderEnabled = ( ulParam ? fTrue : fFalse );
			}
		else
			{
			g_fSLVProviderEnabled = ( ulParam ? fTrue : fFalse );
			}
		break;

	case JET_paramRuntimeCallback:
		if ( pinst )
			{
			Call( ErrAPICheckInstInit( pinst ) );
			pinst->m_pfnRuntimeCallback = (JET_CALLBACK)ulParam;
			}
		else
			{
			g_pfnRuntimeCallback = (JET_CALLBACK)ulParam;
			}
		Call( ( *(JET_CALLBACK)ulParam )(		//	make dummy call to callback to verify its existence
						JET_sesidNil,
						JET_dbidNil,
						JET_tableidNil,
						JET_cbtypNull,
						NULL,
						NULL,
						NULL,
						NULL ) );
		break;

	case JET_paramUnicodeIndexDefault:
		{
		ERR			err;
		IDXUNICODE	idxunicode	= *(IDXUNICODE *)ulParam;

		Call( ErrFILEICheckUserDefinedUnicode( &idxunicode ) );
		idxunicodeDefault = idxunicode;

		break;
		}

	case JET_paramIndexTuplesLengthMin:
		if ( 0 == ulParam )
			{
			g_chIndexTuplesLengthMin = chIDXTuplesLengthMinDefault;
			}
		else
			{
			if ( ulParam < chIDXTuplesLengthMinAbsolute || ulParam > chIDXTuplesLengthMaxAbsolute )
				{
				Call( ErrERRCheck( JET_errIndexTuplesInvalidLimits ) );
				}
			g_chIndexTuplesLengthMin = (ULONG)ulParam;
			}
		break;

	case JET_paramIndexTuplesLengthMax:
		if ( 0 == ulParam )
			{
			g_chIndexTuplesLengthMax = chIDXTuplesLengthMaxDefault;
			}
		else
			{
			if ( ulParam < chIDXTuplesLengthMinAbsolute || ulParam > chIDXTuplesLengthMaxAbsolute )
				{
				Call( ErrERRCheck( JET_errIndexTuplesInvalidLimits ) );
				}
			g_chIndexTuplesLengthMax = (ULONG)ulParam;
			}
		break;

	case JET_paramIndexTuplesToIndexMax:
		if ( ulParam > chIDXTuplesToIndexMaxAbsolute )
			Call( ErrERRCheck( JET_errIndexTuplesInvalidLimits ) );
		g_chIndexTuplesToIndexMax = (ULONG)( 0 == ulParam ? chIDXTuplesToIndexMaxDefault : ulParam );
		break;

	case JET_paramPageHintCacheSize:
		if ( ulParam >= LONG_MAX )
			Call( ErrERRCheck( JET_errInvalidParameter ) );
		Call( ErrAPICheckSomeInstInit() );
		g_cbPageHintCache = (LONG)ulParam;
		break;

	case JET_paramRecordUpgradeDirtyLevel:
		switch( ulParam )
			{
			case 0:
				CPAGE::bfdfRecordUpgradeFlags = bfdfClean;
				break;
			case 1:
				CPAGE::bfdfRecordUpgradeFlags = bfdfUntidy;
				break;
			case 2:
				CPAGE::bfdfRecordUpgradeFlags = bfdfDirty;
				break;
			case 3:
				CPAGE::bfdfRecordUpgradeFlags = bfdfFilthy;
				break;
			default:
				Call( ErrERRCheck( JET_errInvalidParameter ) );
				break;
			}
		break;

	case JET_paramRecoveryCurrentLogfile:
		AssertSz( fFalse, "JET_paramRecoveryCurrentLogfile cannot be set, only retrieved" );
		Call( ErrERRCheck( JET_errInvalidParameter ) );
		break;

	case JET_paramReplayingReplicatedLogfiles:
		if ( pinst )
			{
			pinst->m_plog->m_fReplayingReplicatedLogFiles = ( ulParam ? fTrue : fFalse );
			}
		else
			{
			Call( ErrERRCheck( JET_errInvalidParameter ) );
			}
		break;

	case JET_paramCleanupMismatchedLogFiles:
		if ( pinst )
			{
			Call( ErrAPICheckInstInit( pinst ) );
			pinst->m_fCleanupMismatchedLogFiles = ( ulParam ? fTrue : fFalse );
			}
		else
			{
			g_fCleanupMismatchedLogFiles = ( ulParam ? fTrue : fFalse );
			}
		break;

	case JET_paramOneDatabasePerSession:
		Call( ErrAPICheckSomeInstInit() );
		g_fOneDatabasePerSession = ( ulParam ? fTrue : fFalse );
		break;

	case JET_paramOSSnapshotTimeout:
		Call( ErrOSSnapshotSetTimeout( ulParam ) );		
		break;

	case JET_paramUnicodeIndexLibrary:
		if ( !sz )
			{
			Error( ErrERRCheck( JET_errInvalidParameter ), HandleError );
			}
		{
		CHAR* const	szDest	= pinst ? pinst->m_szUnicodeIndexLibrary : g_szUnicodeIndexLibrary;
		ULONG		cch;

		cch = LOSSTRLengthA( sz ) + 1;
		cch = min( cch, IFileSystemAPI::cchPathMax );
		memcpy( szDest, sz, cch );
		szDest[ cch - 1 ] = '\0';
		}
		break;

	case JET_paramMaxInstances:
		if ( ulParam < 1 || ulParam > cMaxInstances )
			return ErrERRCheck( JET_errInvalidParameter );

		Call( ErrAPICheckSomeInstInit() );

		g_cMaxInstancesRequestedByUser = (ULONG)ulParam;
		break;

	case JET_paramMaxDatabasesPerInstance:
		if ( ulParam < 1 || ulParam > cMaxDatabasesPerInstance )
			return ErrERRCheck( JET_errInvalidParameter );

		Call( ErrAPICheckSomeInstInit() );

//		dbidMax = (ULONG)ulParam;
		break;

	default:
		Call( ErrERRCheck( JET_errInvalidParameter ) );
		}

	err = JET_errSuccess;

HandleError:
	delete pfsapi;
	return err;
	}

JET_ERR JET_API ErrGetSystemParameter(
	JET_INSTANCE	jinst,
	JET_SESID		sesid,
	unsigned long	paramid,
	ULONG_PTR		*plParam,
	char			*sz,
	unsigned long	cbMax )
	{
	int				cch;
	INST			*pinst = (INST *)jinst;
	
	Assert( !jinst
		|| 0 == sesid
		|| JET_sesidNil == sesid
		|| pinst == PinstFromPpib( (PIB *)sesid ) );
	
	
	switch ( paramid )
		{
	case JET_paramSystemPath:		
		//	path to the checkpoint file
		//
			{
			char *szFrom;
			szFrom = (pinst)?pinst->m_szSystemPath:g_szSystemPath;
			Assert (szFrom);
			
			cch = (ULONG)strlen(szFrom) + 1;
			if ( cch > (int)cbMax )
				cch = (int)cbMax;
			UtilMemCpy( sz, szFrom, cch );
			sz[cch - 1] = '\0';
			}
			break;

	case JET_paramTempPath:
		//	path to the temporary file directory
		//
			{
			char *szFrom;
			szFrom = (pinst)?pinst->m_szTempDatabase:g_szTempDatabase;
			Assert (szFrom);
			
			cch = (ULONG)strlen(szFrom) + 1;
			if ( cch > (int)cbMax )
				cch = (int)cbMax;
			UtilMemCpy( sz, szFrom, cch );
			sz[cch - 1] = '\0';
			}
		break;

	case JET_paramCreatePathIfNotExist:
		if ( plParam == NULL )
			return ErrERRCheck( JET_errInvalidParameter );
		*plParam = ( pinst ? pinst->m_fCreatePathIfNotExist : g_fCreatePathIfNotExist );
		break;

	case JET_paramDbExtensionSize:		/* database expansion steps, default is 16 pages */
		if (plParam == NULL)
			return ErrERRCheck( JET_errInvalidParameter );
		*plParam = ( pinst ? pinst->m_cpgSESysMin : g_cpgSESysMin );
		break;
			
	case JET_paramPageReadAheadMax:
		if (plParam == NULL)
			return ErrERRCheck( JET_errInvalidParameter );
		*plParam = 0;
		break;
		
	case JET_paramPageTempDBMin:
		if (plParam == NULL)
			return ErrERRCheck( JET_errInvalidParameter );
		*plParam = (pinst)?pinst->m_cpageTempDBMin:g_cpageTempDBMin;
		break;
		
	case JET_paramEnableTempTableVersioning:	/* version all temp table operations */
		if (plParam == NULL)
			return ErrERRCheck( JET_errInvalidParameter );
		*plParam = (pinst)?pinst->m_fTempTableVersioning:g_fTempTableVersioning;
		break;

	case JET_paramZeroDatabaseDuringBackup:	/* version all temp table operations */
		if (plParam == NULL)
			return ErrERRCheck( JET_errInvalidParameter );
		*plParam = (pinst)?pinst->m_plog->m_fScrubDB:g_fScrubDB;
		break;

	case JET_paramSLVDefragFreeThreshold:
		if (plParam == NULL)
			return ErrERRCheck( JET_errInvalidParameter );
		*plParam = (pinst)?pinst->m_lSLVDefragFreeThreshold:g_lSLVDefragFreeThreshold;
		break;
		
	case JET_paramSLVDefragMoveThreshold:
		if (plParam == NULL)
			return ErrERRCheck( JET_errInvalidParameter );
		*plParam = (pinst)?pinst->m_lSLVDefragMoveThreshold:g_lSLVDefragMoveThreshold;
		break;

	case JET_paramIgnoreLogVersion:
		if (plParam == NULL )
			return ErrERRCheck( JET_errInvalidParameter );
		*plParam = ( pinst ? pinst->m_plog->m_fLGIgnoreVersion : g_fLGIgnoreVersion );
		break;
			
	case JET_paramCheckFormatWhenOpenFail:		/* check format number when db/log open fails */
		if (plParam == NULL)
			return ErrERRCheck( JET_errInvalidParameter );
/*
 * This is no longer a system param - we ALWAYS do this check on open failure
 */
//		*plParam = g_fCheckFormatWhenOpenFail;

		*plParam = fTrue;
		break;

	case JET_paramMaxSessions:     /* Maximum number of sessions */
		if (plParam == NULL)
			return ErrERRCheck( JET_errInvalidParameter );
		*plParam = (pinst)?pinst->m_lSessionsMax:g_lSessionsMax;
		break;

	case JET_paramMaxOpenTables:   /* Maximum number of open tables */
		if (plParam == NULL)
			return ErrERRCheck( JET_errInvalidParameter );
		*plParam = (pinst)?pinst->m_lOpenTablesMax:g_lOpenTablesMax;
		break;

	case JET_paramPreferredMaxOpenTables:   /* Preferred maximum number of open tables */
		if (plParam == NULL)
			return ErrERRCheck( JET_errInvalidParameter );
		*plParam = (pinst)?pinst->m_lOpenTablesPreferredMax:g_lOpenTablesPreferredMax;
		break;

	case JET_paramMaxTemporaryTables:
		if (plParam == NULL)
			return ErrERRCheck( JET_errInvalidParameter );
		*plParam = (pinst)?pinst->m_lTemporaryTablesMax:g_lTemporaryTablesMax;
		break;

	case JET_paramMaxVerPages:     /* Maximum number of modified pages */
		if (plParam == NUL