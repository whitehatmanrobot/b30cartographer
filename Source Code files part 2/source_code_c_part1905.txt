DDRESSU_RMSK                 0x00000007 /* 26:24 */ 
#define NV_055_FORMAT_TEXTUREADDRESSU_WORD                 0
#define NV_055_FORMAT_TEXTUREADDRESSU_HIGH_FIELD           0x0000001A /* =26 */
#define NV_055_FORMAT_TEXTUREADDRESSU_LOW_FIELD            0x00000018 /* =24 */
#define NV_055_FORMAT_TEXTUREADDRESSU_WRAP_ADJ             0x01000000
#define NV_055_FORMAT_TEXTUREADDRESSU_MIRROR_ADJ           0x02000000
#define NV_055_FORMAT_TEXTUREADDRESSU_CLAMP_ADJ            0x03000000
#define NV_055_FORMAT_TEXTUREADDRESSU_BORDER_ADJ           0x04000000
#define NV_055_FORMAT_WRAPU_MSK                            0x08000000 /* 27:27 */ 
#define NV_055_FORMAT_WRAPU_RMSK                           0x00000001 /* 27:27 */ 
#define NV_055_FORMAT_WRAPU_WORD                           0
#define NV_055_FORMAT_WRAPU_HIGH_FIELD                     0x0000001B /* =27 */
#define NV_055_FORMAT_WRAPU_LOW_FIELD                      0x0000001B /* =27 */
#define NV_055_FORMAT_WRAPU_FALSE_ADJ                      0x00000000
#define NV_055_FORMAT_WRAPU_TRUE_ADJ                       0x08000000
#define NV_055_FORMAT_TEXTUREADDRESSV_MSK                  0x70000000 /* 30:28 */ 
#define NV_055_FORMAT_TEXTUREADDRESSV_RMSK                 0x00000007 /* 30:28 */ 
#define NV_055_FORMAT_TEXTUREADDRESSV_WORD                 0
#define NV_055_FORMAT_TEXTUREADDRESSV_HIGH_FIELD           0x0000001E /* =30 */
#define NV_055_FORMAT_TEXTUREADDRESSV_LOW_FIELD            0x0000001C /* =28 */
#define NV_055_FORMAT_TEXTUREADDRESSV_WRAP_ADJ             0x10000000
#define NV_055_FORMAT_TEXTUREADDRESSV_MIRROR_ADJ           0x20000000
#define NV_055_FORMAT_TEXTUREADDRESSV_CLAMP_ADJ            0x30000000
#define NV_055_FORMAT_TEXTUREADDRESSV_BORDER_ADJ           0x40000000
#define NV_055_FORMAT_WRAPV_MSK                            0x80000000 /* 31:31 */ 
#define NV_055_FORMAT_WRAPV_RMSK                           0x00000001 /* 31:31 */ 
#define NV_055_FORMAT_WRAPV_WORD                           0
#define NV_055_FORMAT_WRAPV_HIGH_FIELD                     0x0000001F /* =31 */
#define NV_055_FORMAT_WRAPV_LOW_FIELD                      0x0000001F /* =31 */
#define NV_055_FORMAT_WRAPV_FALSE_ADJ                      0x00000000
#define NV_055_FORMAT_WRAPV_TRUE_ADJ                       0x80000000
#define NV_055_FORMAT_MSK                                  0xFFFFFFFF 
#define NV_055_FILTER_KERNEL_SIZE_X_MSK                    0x000000FF /* 7:0 */ 
#define NV_055_FILTER_KERNEL_SIZE_X_RMSK                   0x000000FF /* 7:0 */ 
#define NV_055_FILTER_KERNEL_SIZE_X_WORD                   0
#define NV_055_FILTER_KERNEL_SIZE_X_HIGH_FIELD             0x00000007 /* =7 */
#define NV_055_FILTER_KERNEL_SIZE_X_LOW_FIELD              0x00000000 /* =0 */
#define NV_055_FILTER_KERNEL_SIZE_Y_MSK                    0x00007F00 /* 14:8 */ 
#define NV_055_FILTER_KERNEL_SIZE_Y_RMSK                   0x0000007F /* 14:8 */ 
#define NV_055_FILTER_KERNEL_SIZE_Y_WORD                   0
#define NV_055_FILTER_KERNEL_SIZE_Y_HIGH_FIELD             0x0000000E /* =14 */
#define NV_055_FILTER_KERNEL_SIZE_Y_LOW_FIELD              0x00000008 /* =8 */
#define NV_055_FILTER_MIPMAP_DITHER_ENABLE_MSK             0x00008000 /* 15:15 */ 
#define NV_055_FILTER_MIPMAP_DITHER_ENABLE_RMSK            0x00000001 /* 15:15 */ 
#define NV_055_FILTER_MIPMAP_DITHER_ENABLE_WORD            0
#define NV_055_FILTER_MIPMAP_DITHER_ENABLE_HIGH_FIELD      0x0000000F /* =15 */
#define NV_055_FILTER_MIPMAP_DITHER_ENABLE_LOW_FIELD       0x0000000F /* =15 */
#define NV_055_FILTER_MIPMAP_DITHER_ENABLE_FALSE_ADJ       0x00000000
#define NV_055_FILTER_MIPMAP_DITHER_ENABLE_TRUE_ADJ        0x00008000
#define NV_055_FILTER_MIPMAPLODBIAS_MSK                    0x00FF0000 /* 23:16 */ 
#define NV_055_FILTER_MIPMAPLODBIAS_RMSK                   0x000000FF /* 23:16 */ 
#define NV_055_FILTER_MIPMAPLODBIAS_WORD                   0
#define NV_055_FILTER_MIPMAPLODBIAS_HIGH_FIELD             0x00000017 /* =23 */
#define NV_055_FILTER_MIPMAPLODBIAS_LOW_FIELD              0x00000010 /* =16 */
#define NV_055_FILTER_TEXTUREMIN_MSK                       0x07000000 /* 26:24 */ 
#define NV_055_FILTER_TEXTUREMIN_RMSK                      0x00000007 /* 26:24 */ 
#define NV_055_FILTER_TEXTUREMIN_WORD                      0
#define NV_055_FILTER_TEXTUREMIN_HIGH_FIELD                0x0000001A /* =26 */
#define NV_055_FILTER_TEXTUREMIN_LOW_FIELD                 0x00000018 /* =24 */
#define NV_055_FILTER_TEXTUREMIN_NEAREST_ADJ               0x01000000
#define NV_055_FILTER_TEXTUREMIN_LINEAR_ADJ                0x02000000
#define NV_055_FILTER_TEXTUREMIN_MIPNEAREST_ADJ            0x03000000
#define NV_055_FILTER_TEXTUREMIN_MIPLINEAR_ADJ             0x04000000
#define NV_055_FILTER_TEXTUREMIN_LINEARMIPNEAREST_ADJ      0x05000000
#define NV_055_FILTER_TEXTUREMIN_LINEARMIPLINEAR_ADJ       0x06000000
#define NV_055_FILTER_ANISOTROPIC_MIN_ENABLE_MSK           0x08000000 /* 27:27 */ 
#define NV_055_FILTER_ANISOTROPIC_MIN_ENABLE_RMSK          0x00000001 /* 27:27 */ 
#define NV_055_FILTER_ANISOTROPIC_MIN_ENABLE_WORD          0
#define NV_055_FILTER_ANISOTROPIC_MIN_ENABLE_HIGH_FIELD    0x0000001B /* =27 */
#define NV_055_FILTER_ANISOTROPIC_MIN_ENABLE_LOW_FIELD     0x0000001B /* =27 */
#define NV_055_FILTER_ANISOTROPIC_MIN_ENABLE_FALSE_ADJ     0x00000000
#define NV_055_FILTER_ANISOTROPIC_MIN_ENABLE_TRUE_ADJ      0x08000000
#define NV_055_FILTER_TEXTUREMAG_MSK                       0x70000000 /* 30:28 */ 
#define NV_055_FILTER_TEXTUREMAG_RMSK                      0x00000007 /* 30:28 */ 
#define NV_055_FILTER_TEXTUREMAG_WORD                      0
#define NV_055_FILTER_TEXTUREMAG_HIGH_FIELD                0x0000001E /* =30 */
#define NV_055_FILTER_TEXTUREMAG_LOW_FIELD                 0x0000001C /* =28 */
#define NV_055_FILTER_TEXTUREMAG_NEAREST_ADJ               0x10000000
#define NV_055_FILTER_TEXTUREMAG_LINEAR_ADJ                0x20000000
#define NV_055_FILTER_TEXTUREMAG_MIPNEAREST_ADJ            0x30000000
#define NV_055_FILTER_TEXTUREMAG_MIPLINEAR_ADJ             0x40000000
#define NV_055_FILTER_TEXTUREMAG_LINEARMIPNEAREST_ADJ      0x50000000
#define NV_055_FILTER_TEXTUREMAG_LINEARMIPLINEAR_ADJ       0x60000000
#define NV_055_FILTER_ANISOTROPIC_MAG_ENABLE_MSK           0x80000000 /* 31:31 */ 
#define NV_055_FILTER_ANISOTROPIC_MAG_ENABLE_RMSK          0x00000001 /* 31:31 */ 
#define NV_055_FILTER_ANISOTROPIC_MAG_ENABLE_WORD          0
#define NV_055_FILTER_ANISOTROPIC_MAG_ENABLE_HIGH_FIELD    0x0000001F /* =31 */
#define NV_055_FILTER_ANISOTROPIC_MAG_ENABLE_LOW_FIELD     0x0000001F /* =31 */
#define NV_055_FILTER_ANISOTROPIC_MAG_ENABLE_FALSE_ADJ     0x00000000
#define NV_055_FILTER_ANISOTROPIC_MAG_ENABLE_TRUE_ADJ      0x80000000
#define NV_055_FILTER_MSK                                  0xFFFFFFFF 
#define NV_055_COMBINE_0_ALPHA_INVERSE_0_MSK               0x00000001 /* 0:0 */ 
#define NV_055_COMBINE_0_ALPHA_INVERSE_0_RMSK              0x00000001 /* 0:0 */ 
#define NV_055_COMBINE_0_ALPHA_INVERSE_0_WORD              0
#define NV_055_COMBINE_0_ALPHA_INVERSE_0_HIGH_FIELD        0x00000000 /* =0 */
#define NV_055_COMBINE_0_ALPHA_INVERSE_0_LOW_FIELD         0x00000000 /* =0 */
#define NV_055_COMBINE_0_ALPHA_INVERSE_0_NORMAL_ADJ        0x00000000
#define NV_055_COMBINE_0_ALPHA_INVERSE_0_INVERSE_ADJ       0x00000001
#define NV_055_COMBINE_0_ALPHA_ALPHA_0_MSK                 0x00000002 /* 1:1 */ 
#define NV_055_COMBINE_0_ALPHA_ALPHA_0_RMSK                0x00000001 /* 1:1 */ 
#define NV_055_COMBINE_0_ALPHA_ALPHA_0_WORD                0
#define NV_055_COMBINE_0_ALPHA_ALPHA_0_HIGH_FIELD          0x00000001 /* =1 */
#define NV_055_COMBINE_0_ALPHA_ALPHA_0_LOW_FIELD           0x00000001 /* =1 */
#define NV_055_COMBINE_0_ALPHA_ARGUMENT_0_MSK              0x000000FC /* 7:2 */ 
#define NV_055_COMBINE_0_ALPHA_ARGUMENT_0_RMSK             0x0000003F /* 7:2 */ 
#define NV_055_COMBINE_0_ALPHA_ARGUMENT_0_WORD             0
#define NV_055_COMBINE_0_ALPHA_ARGUMENT_0_HIGH_FIELD       0x00000007 /* =7 */
#define NV_055_COMBINE_0_ALPHA_ARGUMENT_0_LOW_FIELD        0x00000002 /* =2 */
#define NV_055_COMBINE_0_ALPHA_ARGUMENT_0_ZERO_ADJ         0x00000004
#define NV_055_COMBINE_0_ALPHA_ARGUMENT_0_FACTOR_ADJ       0x00000008
#define NV_055_COMBINE_0_ALPHA_ARGUMENT_0_DIFFUSE_ADJ      0x0000000C
#define NV_055_COMBINE_0_ALPHA_ARGUMENT_0_INPUT_ADJ        0x00000010
#define NV_055_COMBINE_0_ALPHA_ARGUMENT_0_TEXTURE0_ADJ     0x00000014
#define NV_055_COMBINE_0_ALPHA_ARGUMENT_0_TEXTURE1_ADJ     0x00000018
#define NV_055_COMBINE_0_ALPHA_ARGUMENT_0_TEXTURELOD_ADJ   0x0000001C
#define NV_055_COMBINE_0_ALPHA_INVERSE_1_MSK               0x00000100 /* 8:8 */ 
#define NV_055_COMBINE_0_ALPHA_INVERSE_1_RMSK              0x00000001 /* 8:8 */ 
#define NV_055_COMBINE_0_ALPHA_INVERSE_1_WORD              0
#define NV_055_COMBINE_0_ALPHA_INVERSE_1_HIGH_FIELD        0x00000008 /* =8 */
#define NV_055_COMBINE_0_ALPHA_INVERSE_1_LOW_FIELD         0x00000008 /* =8 */
#define NV_055_COMBINE_0_ALPHA_INVERSE_1_NORMAL_ADJ        0x00000000
#define NV_055_COMBINE_0_ALPHA_INVERSE_1_INVERSE_ADJ       0x00000100
#define NV_055_COMBINE_0_ALPHA_ALPHA_1_MSK                 0x00000200 /* 9:9 */ 
#define NV_055_COMBINE_0_ALPHA_ALPHA_1_RMSK                0x00000001 /* 9:9 */ 
#define NV_055_COMBINE_0_ALPHA_ALPHA_1_WORD                0
#define NV_055_COMBINE_0_ALPHA_ALPHA_1_HIGH_FIELD          0x00000009 /* =9 */
#define NV_055_COMBINE_0_ALPHA_ALPHA_1_LOW_FIELD           0x00000009 /* =9 */
#define NV_055_COMBINE_0_ALPHA_ARGUMENT_1_MSK              0x0000FC00 /* 15:10 */ 
#define NV_055_COMBINE_0_ALPHA_ARGUMENT_1_RMSK             0x0000003F /* 15:10 */ 
#define NV_055_COMBINE_0_ALPHA_ARGUMENT_1_WORD             0
#define NV_055_COMBINE_0_ALPHA_ARGUMENT_1_HIGH_FIELD       0x0000000F /* =15 */
#define NV_055_COMBINE_0_ALPHA_ARGUMENT_1_LOW_FIELD        0x0000000A /* =10 */
#define NV_055_COMBINE_0_ALPHA_ARGUMENT_1_ZERO_ADJ         0x00000400
#define NV_055_COMBINE_0_ALPHA_ARGUMENT_1_FACTOR_ADJ       0x00000800
#define NV_055_COMBINE_0_ALPHA_ARGUMENT_1_DIFFUSE_ADJ      0x00000C00
#define NV_055_COMBINE_0_ALPHA_ARGUMENT_1_INPUT_ADJ        0x00001000
#define NV_055_COMBINE_0_ALPHA_ARGUMENT_1_TEXTURE0_ADJ     0x00001400
#define NV_055_COMBINE_0_ALPHA_ARGUMENT_1_TEXTURE1_ADJ     0x00001800
#define NV_055_COMBINE_0_ALPHA_ARGUMENT_1_TEXTURELOD_ADJ   0x00001C00
#define NV_055_COMBINE_0_ALPHA_INVERSE_2_MSK               0x00010000 /* 16:16 */ 
#define NV_055_COMBINE_0_ALPHA_INVERSE_2_RMSK              0x00000001 /* 16:16 */ 
#define NV_055_COMBINE_0_ALPHA_INVERSE_2_WORD              0
#define NV_055_COMBINE_0_ALPHA_INVERSE_2_HIGH_FIELD        0x00000010 /* =16 */
#define NV_055_COMBINE_0_ALPHA_INVERSE_2_LOW_FIELD         0x00000010 /* =16 */
#define NV_055_COMBINE_0_ALPHA_INVERSE_2_NORMAL_ADJ        0x00000000
#define NV_055_COMBINE_0_ALPHA_INVERSE_2_INVERSE_ADJ       0x00010000
#define NV_055_COMBINE_0_ALPHA_ALPHA_2_MSK                 0x00020000 /* 17:17 */ 
#define NV_055_COMBINE_0_ALPHA_ALPHA_2_RMSK                0x00000001 /* 17:17 */ 
#define NV_055_COMBINE_0_ALPHA_ALPHA_2_WORD                0
#define NV_055_COMBINE_0_ALPHA_ALPHA_2_HIGH_FIELD          0x00000011 /* =17 */
#define NV_055_COMBINE_0_ALPHA_ALPHA_2_LOW_FIELD           0x00000011 /* =17 */
#define NV_055_COMBINE_0_ALPHA_ARGUMENT_2_MSK              0x00FC0000 /* 23:18 */ 
#define NV_055_COMBINE_0_ALPHA_ARGUMENT_2_RMSK             0x0000003F /* 23:18 */ 
#define NV_055_COMBINE_0_ALPHA_ARGUMENT_2_WORD             0
#define NV_055_COMBINE_0_ALPHA_ARGUMENT_2_HIGH_FIELD       0x00000017 /* =23 */
#define NV_055_COMBINE_0_ALPHA_ARGUMENT_2_LOW_FIELD        0x00000012 /* =18 */
#define NV_055_COMBINE_0_ALPHA_ARGUMENT_2_ZERO_ADJ         0x00040000
#define NV_055_COMBINE_0_ALPHA_ARGUMENT_2_FACTOR_ADJ       0x00080000
#define NV_055_COMBINE_0_ALPHA_ARGUMENT_2_DIFFUSE_ADJ      0x000C0000
#define NV_055_COMBINE_0_ALPHA_ARGUMENT_2_INPUT_ADJ        0x00100000
#define NV_055_COMBINE_0_ALPHA_ARGUMENT_2_TEXTURE0_ADJ     0x00140000
#define NV_055_COMBINE_0_ALPHA_ARGUMENT_2_TEXTURE1_ADJ     0x00180000
#define NV_055_COMBINE_0_ALPHA_ARGUMENT_2_TEXTURELOD_ADJ   0x001C0000
#define NV_055_COMBINE_0_ALPHA_INVERSE_3_MSK               0x01000000 /* 24:24 */ 
#define NV_055_COMBINE_0_ALPHA_INVERSE_3_RMSK              0x00000001 /* 24:24 */ 
#define NV_055_COMBINE_0_ALPHA_INVERSE_3_WORD              0
#define NV_055_COMBINE_0_ALPHA_INVERSE_3_HIGH_FIELD        0x00000018 /* =24 */
#define NV_055_COMBINE_0_ALPHA_INVERSE_3_LOW_FIELD         0x00000018 /* =24 */
#define NV_055_COMBINE_0_ALPHA_INVERSE_3_NORMAL_ADJ        0x00000000
#define NV_055_COMBINE_0_ALPHA_INVERSE_3_INVERSE_ADJ       0x01000000
#define NV_055_COMBINE_0_ALPHA_ALPHA_3_MSK                 0x02000000 /* 25:25 */ 
#define NV_055_COMBINE_0_ALPHA_ALPHA_3_RMSK                0x00000001 /* 25:25 */ 
#define NV_055_COMBINE_0_ALPHA_ALPHA_3_WORD                0
#define NV_055_COMBINE_0_ALPHA_ALPHA_3_HIGH_FIELD          0x00000019 /* =25 */
#define NV_055_COMBINE_0_ALPHA_ALPHA_3_LOW_FIELD           0x00000019 /* =25 */
#define NV_055_COMBINE_0_ALPHA_ARGUMENT_3_MSK              0x1C000000 /* 28:26 */ 
#define NV_055_COMBINE_0_ALPHA_ARGUMENT_3_RMSK             0x00000007 /* 28:26 */ 
#define NV_055_COMBINE_0_ALPHA_ARGUMENT_3_WORD             0
#define NV_055_COMBINE_0_ALPHA_ARGUMENT_3_HIGH_FIELD       0x0000001C /* =28 */
#define NV_055_COMBINE_0_ALPHA_ARGUMENT_3_LOW_FIELD        0x0000001A /* =26 */
#define NV_055_COMBINE_0_ALPHA_ARGUMENT_3_ZERO_ADJ         0x04000000
#define NV_055_COMBINE_0_ALPHA_ARGUMENT_3_FACTOR_ADJ       0x08000000
#define NV_055_COMBINE_0_ALPHA_ARGUMENT_3_DIFFUSE_ADJ      0x0C000000
#define NV_055_COMBINE_0_ALPHA_ARGUMENT_3_INPUT_ADJ        0x10000000
#define NV_055_COMBINE_0_ALPHA_ARGUMENT_3_TEXTURE0_ADJ     0x14000000
#define NV_055_COMBINE_0_ALPHA_ARGUMENT_3_TEXTURE1_ADJ     0x18000000
#define NV_055_COMBINE_0_ALPHA_ARGUMENT_3_TEXTURELOD_ADJ   0x1C000000
#define NV_055_COMBINE_0_ALPHA_OPERATION_MSK               0xE0000000 /* 31:29 */ 
#define NV_055_COMBINE_0_ALPHA_OPERATION_RMSK              0x00000007 /* 31:29 */ 
#define NV_055_COMBINE_0_ALPHA_OPERATION_WORD              0
#define NV_055_COMBINE_0_ALPHA_OPERATION_HIGH_FIELD        0x0000001F /* =31 */
#define NV_055_COMBINE_0_ALPHA_OPERATION_LOW_FIELD         0x0000001D /* =29 */
#define NV_055_COMBINE_0_ALPHA_OPERATION_ADD_ADJ           0x20000000
#define NV_055_COMBINE_0_ALPHA_OPERATION_ADD2_ADJ          0x40000000
#define NV_055_COMBINE_0_ALPHA_OPERATION_ADD4_ADJ          0x60000000
#define NV_055_COMBINE_0_ALPHA_OPERATION_ADDSIGNED_ADJ     0x80000000
#define NV_055_COMBINE_0_ALPHA_OPERATION_MUX_ADJ           0xA0000000
#define NV_055_COMBINE_0_ALPHA_OPERATION_ADDCOMPLEMENT_ADJ 0xC0000000
#define NV_055_COMBINE_0_ALPHA_OPERATION_ADDSIGNED2_ADJ    0xE0000000
#define NV_055_COMBINE_0_ALPHA_MSK                         0xFFFFFFFF 
#define NV_055_COMBINE_0_COLOR_INVERSE_0_MSK               0x00000001 /* 0:0 */ 
#define NV_055_COMBINE_0_COLOR_INVERSE_0_RMSK              0x00000001 /* 0:0 */ 
#define NV_055_COMBINE_0_COLOR_INVERSE_0_WORD              0
#define NV_055_COMBINE_0_COLOR_INVERSE_0_HIGH_FIELD        0x00000000 /* =0 */
#define NV_055_COMBINE_0_COLOR_INVERSE_0_LOW_FIELD         0x00000000 /* =0 */
#define NV_055_COMBINE_0_COLOR_INVERSE_0_NORMAL_ADJ        0x00000000
#define NV_055_COMBINE_0_COLOR_INVERSE_0_INVERSE_ADJ       0x00000001
#define NV_055_COMBINE_0_COLOR_ALPHA_0_MSK                 0x00000002 /* 1:1 */ 
#define NV_055_COMBINE_0_COLOR_ALPHA_0_RMSK                0x00000001 /* 1:1 */ 
#define NV_055_COMBINE_0_COLOR_ALPHA_0_WORD                0
#define NV_055_COMBINE_0_COLOR_ALPHA_0_HIGH_FIELD          0x00000001 /* =1 */
#define NV_055_COMBINE_0_COLOR_ALPHA_0_LOW_FIELD           0x00000001 /* =1 */
#define NV_055_COMBINE_0_COLOR_ALPHA_0_COLOR_ADJ           0x00000000
#define NV_055_COMBINE_0_COLOR_ALPHA_0_ALPHA_ADJ           0x00000002
#define NV_055_COMBINE_0_COLOR_ARGUMENT_0_MSK              0x000000FC /* 7:2 */ 
#define NV_055_COMBINE_0_COLOR_ARGUMENT_0_RMSK             0x0000003F /* 7:2 */ 
#define NV_055_COMBINE_0_COLOR_ARGUMENT_0_WORD             0
#define NV_055_COMBINE_0_COLOR_ARGUMENT_0_HIGH_FIELD       0x00000007 /* =7 */
#define NV_055_COMBINE_0_COLOR_ARGUMENT_0_LOW_FIELD        0x00000002 /* =2 */
#define NV_055_COMBINE_0_COLOR_ARGUMENT_0_ZERO_ADJ         0x00000004
#define NV_055_COMBINE_0_COLOR_ARGUMENT_0_FACTOR_ADJ       0x00000008
#define NV_055_COMBINE_0_COLOR_ARGUMENT_0_DIFFUSE_ADJ      0x0000000C
#define NV_055_COMBINE_0_COLOR_ARGUMENT_0_INPUT_ADJ        0x00000010
#define NV_055_COMBINE_0_COLOR_ARGUMENT_0_TEXTURE0_ADJ     0x00000014
#define NV_055_COMBINE_0_COLOR_ARGUMENT_0_TEXTURE1_ADJ     0x00000018
#define NV_055_COMBINE_0_COLOR_ARGUMENT_0_TEXTURELOD_ADJ   0x0000001C
#define NV_055_COMBINE_0_COLOR_INVERSE_1_MSK               0x00000100 /* 8:8 */ 
#define NV_055_COMBINE_0_COLOR_INVERSE_1_RMSK              0x00000001 /* 8:8 */ 
#define NV_055_COMBINE_0_COLOR_INVERSE_1_WORD              0
#define NV_055_COMBINE_0_COLOR_INVERSE_1_HIGH_FIELD        0x00000008 /* =8 */
#define NV_055_COMBINE_0_COLOR_INVERSE_1_LOW_FIELD         0x00000008 /* =8 */
#define NV_055_COMBINE_0_COLOR_INVERSE_1_NORMAL_ADJ        0x00000000
#define NV_055_COMBINE_0_COLOR_INVERSE_1_INVERSE_ADJ       0x00000100
#define NV_055_COMBINE_0_COLOR_ALPHA_1_MSK                 0x00000200 /* 9:9 */ 
#define NV_055_COMBINE_0_COLOR_ALPHA_1_RMSK                0x00000001 /* 9:9 */ 
#define NV_055_COMBINE_0_COLOR_ALPHA_1_WORD                0
#define NV_055_COMBINE_0_COLOR_ALPHA_1_HIGH_FIELD          0x00000009 /* =9 */
#define NV_055_COMBINE_0_COLOR_ALPHA_1_LOW_FIELD           0x00000009 /* =9 */
#define NV_055_COMBINE_0_COLOR_ALPHA_1_COLOR_ADJ           0x00000000
#define NV_055_COMBINE_0_COLOR_ALPHA_1_ALPHA_ADJ           0x00000200
#define NV_055_COMBINE_0_COLOR_ARGUMENT_1_MSK              0x0000FC00 /* 15:10 */ 
#define NV_055_COMBINE_0_COLOR_ARGUMENT_1_RMSK             0x0000003F /* 15:10 */ 
#define NV_055_COMBINE_0_COLOR_ARGUMENT_1_WORD             0
#define NV_055_COMBINE_0_COLOR_ARGUMENT_1_HIGH_FIELD       0x0000000F /* =15 */
#define NV_055_COMBINE_0_COLOR_ARGUMENT_1_LOW_FIELD        0x0000000A /* =10 */
#define NV_055_COMBINE_0_COLOR_ARGUMENT_1_ZERO_ADJ         0x00000400
#define NV_055_COMBINE_0_COLOR_ARGUMENT_1_FACTOR_ADJ       0x00000800
#define NV_055_COMBINE_0_COLOR_ARGUMENT_1_DIFFUSE_ADJ      0x00000C00
#define NV_055_COMBINE_0_COLOR_ARGUMENT_1_INPUT_ADJ        0x00001000
#define NV_055_COMBINE_0_COLOR_ARGUMENT_1_TEXTURE0_ADJ     0x00001400
#define NV_055_COMBINE_0_COLOR_ARGUMENT_1_TEXTURE1_ADJ     0x00001800
#define NV_055_COMBINE_0_COLOR_ARGUMENT_1_TEXTURELOD_ADJ   0x00001C00
#define NV_055_COMBINE_0_COLOR_INVERSE_2_MSK               0x00010000 /* 16:16 */ 
#define NV_055_COMBINE_0_COLOR_INVERSE_2_RMSK              0x00000001 /* 16:16 */ 
#define NV_055_COMBINE_0_COLOR_INVERSE_2_WORD              0
#define NV_055_COMBINE_0_COLOR_INVERSE_2_HIGH_FIELD        0x00000010 /* =16 */
#define NV_055_COMBINE_0_COLOR_INVERSE_2_LOW_FIELD         0x00000010 /* =16 */
#define NV_055_COMBINE_0_COLOR_INVERSE_2_NORMAL_ADJ        0x00000000
#define NV_055_COMBINE_0_COLOR_INVERSE_2_INVERSE_ADJ       0x00010000
#define NV_055_COMBINE_0_COLOR_ALPHA_2_MSK                 0x00020000 /* 17:17 */ 
#define NV_055_COMBINE_0_COLOR_ALPHA_2_RMSK                0x00000001 /* 17:17 */ 
#define NV_055_COMBINE_0_COLOR_ALPHA_2_WORD                0
#define NV_055_COMBINE_0_COLOR_ALPHA_2_HIGH_FIELD          0x00000011 /* =17 */
#define NV_055_COMBINE_0_COLOR_ALPHA_2_LOW_FIELD           0x00000011 /* =17 */
#define NV_055_COMBINE_0_COLOR_ALPHA_2_COLOR_ADJ           0x00000000
#define NV_055_COMBINE_0_COLOR_ALPHA_2_ALPHA_ADJ           0x00020000
#define NV_055_COMBINE_0_COLOR_ARGUMENT_2_MSK              0x00FC0000 /* 23:18 */ 
#define NV_055_COMBINE_0_COLOR_ARGUMENT_2_RMSK             0x0000003F /* 23:18 */ 
#define NV_055_COMBINE_0_COLOR_ARGUMENT_2_WORD             0
#define NV_055_COMBINE_0_COLOR_ARGUMENT_2_HIGH_FIELD       0x00000017 /* =23 */
#define NV_055_COMBINE_0_COLOR_ARGUMENT_2_LOW_FIELD        0x00000012 /* =18 */
#define NV_055_COMBINE_0_COLOR_ARGUMENT_2_ZERO_ADJ         0x00040000
#define NV_055_COMBINE_0_COLOR_ARGUMENT_2_FACTOR_ADJ       0x00080000
#define NV_055_COMBINE_0_COLOR_ARGUMENT_2_DIFFUSE_ADJ      0x000C0000
#define NV_055_COMBINE_0_COLOR_ARGUMENT_2_INPUT_ADJ        0x00100000
#define NV_055_COMBINE_0_COLOR_ARGUMENT_2_TEXTURE0_ADJ     0x00140000
#define NV_055_COMBINE_0_COLOR_ARGUMENT_2_TEXTURE1_ADJ     0x00180000
#define NV_055_COMBINE_0_COLOR_ARGUMENT_2_TEXTURELOD_ADJ   0x001C0000
#define NV_055_COMBINE_0_COLOR_INVERSE_3_MSK               0x01000000 /* 24:24 */ 
#define NV_055_COMBINE_0_COLOR_INVERSE_3_RMSK              0x00000001 /* 24:24 */ 
#define NV_055_COMBINE_0_COLOR_INVERSE_3_WORD              0
#define NV_055_COMBINE_0_COLOR_INVERSE_3_HIGH_FIELD        0x00000018 /* =24 */
#define NV_055_COMBINE_0_COLOR_INVERSE_3_LOW_FIELD         0x00000018 /* =24 */
#define NV_055_COMBINE_0_COLOR_INVERSE_3_NORMAL_ADJ        0x00000000
#define NV_055_COMBINE_0_COLOR_INVERSE_3_INVERSE_ADJ       0x01000000
#define NV_055_COMBINE_0_COLOR_ALPHA_3_MSK                 0x02000000 /* 25:25 */ 
#define NV_055_COMBINE_0_COLOR_ALPHA_3_RMSK                0x00000001 /* 25:25 */ 
#define NV_055_COMBINE_0_COLOR_ALPHA_3_WORD                0
#define NV_055_COMBINE_0_COLOR_ALPHA_3_HIGH_FIELD          0x00000019 /* =25 */
#define NV_055_COMBINE_0_COLOR_ALPHA_3_LOW_FIELD           0x00000019 /* =25 */
#define NV_055_COMBINE_0_COLOR_ALPHA_3_COLOR_ADJ           0x00000000
#define NV_055_COMBINE_0_COLOR_ALPHA_3_ALPHA_ADJ           0x02000000
#define NV_055_COMBINE_0_COLOR_ARGUMENT_3_MSK              0x1C000000 /* 28:26 */ 
#define NV_055_COMBINE_0_COLOR_ARGUMENT_3_RMSK             0x00000007 /* 28:26 */ 
#define NV_055_COMBINE_0_COLOR_ARGUMENT_3_WORD             0
#define NV_055_COMBINE_0_COLOR_ARGUMENT_3_HIGH_FIELD       0x0000001C /* =28 */
#define NV_055_COMBINE_0_COLOR_ARGUMENT_3_LOW_FIELD        0x0000001A /* =26 */
#define NV_055_COMBINE_0_COLOR_ARGUMENT_3_ZERO_ADJ         0x04000000
#define NV_055_COMBINE_0_COLOR_ARGUMENT_3_FACTOR_ADJ       0x08000000
#define NV_055_COMBINE_0_COLOR_ARGUMENT_3_DIFFUSE_ADJ      0x0C000000
#define NV_055_COMBINE_0_COLOR_ARGUMENT_3_INPUT_ADJ        0x10000000
#define NV_055_COMBINE_0_COLOR_ARGUMENT_3_TEXTURE0_ADJ     0x14000000
#define NV_055_COMBINE_0_COLOR_ARGUMENT_3_TEXTURE1_ADJ     0x18000000
#define NV_055_COMBINE_0_COLOR_ARGUMENT_3_TEXTURELOD_ADJ   0x1C000000
#define NV_055_COMBINE_0_COLOR_OPERATION_MSK               0xE0000000 /* 31:29 */ 
#define NV_055_COMBINE_0_COLOR_OPERATION_RMSK              0x00000007 /* 31:29 */ 
#define NV_055_COMBINE_0_COLOR_OPERATION_WORD              0
#define NV_055_COMBINE_0_COLOR_OPERATION_HIGH_FIELD        0x0000001F /* =31 */
#define NV_055_COMBINE_0_COLOR_OPERATION_LOW_FIELD         0x0000001D /* =29 */
#define NV_055_COMBINE_0_COLOR_OPERATION_ADD_ADJ           0x20000000
#define NV_055_COMBINE_0_COLOR_OPERATION_ADD2_ADJ          0x40000000
#define NV_055_COMBINE_0_COLOR_OPERATION_ADD4_ADJ          0x60000000
#define NV_055_COMBINE_0_COLOR_OPERATION_ADDSIGNED_ADJ     0x80000000
#define NV_055_COMBINE_0_COLOR_OPERATION_MUX_ADJ           0xA0000000
#define NV_055_COMBINE_0_COLOR_OPERATION_ADDCOMPLEMENT_ADJ 0xC0000000
#define NV_055_COMBINE_0_COLOR_OPERATION_ADDSIGNED2_ADJ    0xE0000000
#define NV_055_COMBINE_0_COLOR_MSK                         0xFFFFFFFF 
#define NV_055_COMBINE_1_ALPHA_INVERSE_0_MSK               0x00000001 /* 0:0 */ 
#define NV_055_COMBINE_1_ALPHA_INVERSE_0_RMSK              0x00000001 /* 0:0 */ 
#define NV_055_COMBINE_1_ALPHA_INVERSE_0_WORD              0
#define NV_055_COMBINE_1_ALPHA_INVERSE_0_HIGH_FIELD        0x00000000 /* =0 */
#define NV_055_COMBINE_1_ALPHA_INVERSE_0_LOW_FIELD         0x00000000 /* =0 */
#define NV_055_COMBINE_1_ALPHA_INVERSE_0_NORMAL_ADJ        0x00000000
#define NV_055_COMBINE_1_ALPHA_INVERSE_0_INVERSE_ADJ       0x00000001
#define NV_055_COMBINE_1_ALPHA_ALPHA_0_MSK                 0x00000002 /* 1:1 */ 
#define NV_055_COMBINE_1_ALPHA_ALPHA_0_RMSK                0x00000001 /* 1:1 */ 
#define NV_055_COMBINE_1_ALPHA_ALPHA_0_WORD                0
#define NV_055_COMBINE_1_ALPHA_ALPHA_0_HIGH_FIELD          0x00000001 /* =1 */
#define NV_055_COMBINE_1_ALPHA_ALPHA_0_LOW_FIELD           0x00000001 /* =1 */
#define NV_055_COMBINE_1_ALPHA_ARGUMENT_0_MSK              0x000000FC /* 7:2 */ 
#define NV_055_COMBINE_1_ALPHA_ARGUMENT_0_RMSK             0x0000003F /* 7:2 */ 
#define NV_055_COMBINE_1_ALPHA_ARGUMENT_0_WORD             0
#define NV_055_COMBINE_1_ALPHA_ARGUMENT_0_HIGH_FIELD       0x00000007 /* =7 */
#define NV_055_COMBINE_1_ALPHA_ARGUMENT_0_LOW_FIELD        0x00000002 /* =2 */
#define NV_055_COMBINE_1_ALPHA_ARGUMENT_0_ZERO_ADJ         0x00000004
#define NV_055_COMBINE_1_ALPHA_ARGUMENT_0_FACTOR_ADJ       0x00000008
#define NV_055_COMBINE_1_ALPHA_ARGUMENT_0_DIFFUSE_ADJ      0x0000000C
#define NV_055_COMBINE_1_ALPHA_ARGUMENT_0_INPUT_ADJ        0x00000010
#define NV_055_COMBINE_1_ALPHA_ARGUMENT_0_TEXTURE0_ADJ     0x00000014
#define NV_055_COMBINE_1_ALPHA_ARGUMENT_0_TEXTURE1_ADJ     0x00000018
#define NV_055_COMBINE_1_ALPHA_INVERSE_1_MSK               0x00000100 /* 8:8 */ 
#define NV_055_COMBINE_1_ALPHA_INVERSE_1_RMSK              0x00000001 /* 8:8 */ 
#define NV_055_COMBINE_1_ALPHA_INVERSE_1_WORD              0
#define NV_055_COMBINE_1_ALPHA_INVERSE_1_HIGH_FIELD        0x00000008 /* =8 */
#define NV_055_COMBINE_1_ALPHA_INVERSE_1_LOW_FIELD         0x00000008 /* =8 */
#define NV_055_COMBINE_1_ALPHA_INVERSE_1_NORMAL_ADJ        0x00000000
#define NV_055_COMBINE_1_ALPHA_INVERSE_1_INVERSE_ADJ       0x00000100
#define NV_055_COMBINE_1_ALPHA_ALPHA_1_MSK                 0x00000200 /* 9:9 */ 
#define NV_055_COMBINE_1_ALPHA_ALPHA_1_RMSK                0x00000001 /* 9:9 */ 
#define NV_055_COMBINE_1_ALPHA_ALPHA_1_WORD                0
#define NV_055_COMBINE_1_ALPHA_ALPHA_1_HIGH_FIELD          0x00000009 /* =9 */
#define NV_055_COMBINE_1_ALPHA_ALPHA_1_LOW_FIELD           0x00000009 /* =9 */
#define NV_055_COMBINE_1_ALPHA_ARGUMENT_1_MSK              0x0000FC00 /* 15:10 */ 
#define NV_055_COMBINE_1_ALPHA_ARGUMENT_1_RMSK             0x0000003F /* 15:10 */ 
#define NV_055_COMBINE_1_ALPHA_ARGUMENT_1_WORD             0
#define NV_055_COMBINE_1_ALPHA_ARGUMENT_1_HIGH_FIELD       0x0000000F /* =15 */
#define NV_055_COMBINE_1_ALPHA_ARGUMENT_1_LOW_FIELD        0x0000000A /* =10 */
#define NV_055_COMBINE_1_ALPHA_ARGUMENT_1_ZERO_ADJ         0x00000400
#define NV_055_COMBINE_1_ALPHA_ARGUMENT_1_FACTOR_ADJ       0x00000800
#define NV_055_COMBINE_1_ALPHA_ARGUMENT_1_DIFFUSE_ADJ      0x00000C00
#define NV_055_COMBINE_1_ALPHA_ARGUMENT_1_INPUT_ADJ        0x00001000
#define NV_055_COMBINE_1_ALPHA_ARGUMENT_1_TEXTURE0_ADJ     0x00001400
#define NV_055_COMBINE_1_ALPHA_ARGUMENT_1_TEXTURE1_ADJ     0x00001800
#define NV_055_COMBINE_1_ALPHA_INVERSE_2_MSK               0x00010000 /* 16:16 */ 
#define NV_055_COMBINE_1_ALPHA_INVERSE_2_RMSK              0x00000001 /* 16:16 */ 
#define NV_055_COMBINE_1_ALPHA_INVERSE_2_WORD              0
#define NV_055_COMBINE_1_ALPHA_INVERSE_2_HIGH_FIELD        0x00000010 /* =16 */
#define NV_055_COMBINE_1_ALPHA_INVERSE_2_LOW_FIELD         0x00000010 /* =16 */
#define NV_055_COMBINE_1_ALPHA_INVERSE_2_NORMAL_ADJ        0x00000000
#define NV_055_COMBINE_1_ALPHA_INVERSE_2_INVERSE_ADJ       0x00010000
#define NV_055_COMBINE_1_ALPHA_ALPHA_2_MSK                 0x00020000 /* 17:17 */ 
#define NV_055_COMBINE_1_ALPHA_ALPHA_2_RMSK                0x00000001 /* 17:17 */ 
#define NV_055_COMBINE_1_ALPHA_ALPHA_2_WORD                0
#define NV_055_COMBINE_1_ALPHA_ALPHA_2_HIGH_FIELD          0x00000011 /* =17 */
#define NV_055_COMBINE_1_ALPHA_ALPHA_2_LOW_FIELD           0x00000011 /* =17 */
#define NV_055_COMBINE_1_ALPHA_ARGUMENT_2_MSK              0x00FC0000 /* 23:18 */ 
#define NV_055_COMBINE_1_ALPHA_ARGUMENT_2_RMSK             0x0000003F /* 23:18 */ 
#define NV_055_COMBINE_1_ALPHA_ARGUMENT_2_WORD             0
#define NV_055_COMBINE_1_ALPHA_ARGUMENT_2_HIGH_FIELD       0x00000017 /* =23 */
#define NV_055_COMBINE_1_ALPHA_ARGUMENT_2_LOW_FIELD        0x00000012 /* =18 */
#define NV_055_COMBINE_1_ALPHA_ARGUMENT_2_ZERO_ADJ         0x00040000
#define NV_055_COMBINE_1_ALPHA_ARGUMENT_2_FACTOR_ADJ       0x00080000
#define NV_055_COMBINE_1_ALPHA_ARGUMENT_2_DIFFUSE_ADJ      0x000C0000
#define NV_055_COMBINE_1_ALPHA_ARGUMENT_2_INPUT_ADJ        0x00100000
#define NV_055_COMBINE_1_ALPHA_ARGUMENT_2_TEXTURE0_ADJ     0x00140000
#define NV_055_COMBINE_1_ALPHA_ARGUMENT_2_TEXTURE1_ADJ     0x00180000
#define NV_055_COMBINE_1_ALPHA_INVERSE_3_MSK               0x01000000 /* 24:24 */ 
#define NV_055_COMBINE_1_ALPHA_INVERSE_3_RMSK              0x00000001 /* 24:24 */ 
#define NV_055_COMBINE_1_ALPHA_INVERSE_3_WORD              0
#define NV_055_COMBINE_1_ALPHA_INVERSE_3_HIGH_FIELD        0x00000018 /* =24 */
#define NV_055_COMBINE_1_ALPHA_INVERSE_3_LOW_FIELD         0x00000018 /* =24 */
#define NV_055_COMBINE_1_ALPHA_INVERSE_3_NORMAL_ADJ        0x00000000
#define NV_055_COMBINE_1_ALPHA_INVERSE_3_INVERSE_ADJ       0x01000000
#define NV_055_COMBINE_1_ALPHA_ALPHA_3_MSK                 0x02000000 /* 25:25 */ 
#define NV_055_COMBINE_1_ALPHA_ALPHA_3_RMSK                0x00000001 /* 25:25 */ 
#define NV_055_COMBINE_1_ALPHA_ALPHA_3_WORD                0
#define NV_055_COMBINE_1_ALPHA_ALPHA_3_HIGH_FIELD          0x00000019 /* =25 */
#define NV_055_COMBINE_1_ALPHA_ALPHA_3_LOW_FIELD           0x00000019 /* =25 */
#define NV_055_COMBINE_1_ALPHA_ARGUMENT_3_MSK              0x1C000000 /* 28:26 */ 
#define NV_055_COMBINE_1_ALPHA_ARGUMENT_3_RMSK             0x00000007 /* 28:26 */ 
#define NV_055_COMBINE_1_ALPHA_ARGUMENT_3_WORD             0
#define NV_055_COMBINE_1_ALPHA_ARGUMENT_3_HIGH_FIELD       0x0000001C /* =28 */
#define NV_055_COMBINE_1_ALPHA_ARGUMENT_3_LOW_FIELD        0x0000001A /* =26 */
#define NV_055_COMBINE_1_ALPHA_ARGUMENT_3_ZERO_ADJ         0x04000000
#define NV_055_COMBINE_1_ALPHA_ARGUMENT_3_FACTOR_ADJ       0x08000000
#define NV_055_COMBINE_1_ALPHA_ARGUMENT_3_DIFFUSE_ADJ      0x0C000000
#define NV_055_COMBINE_1_ALPHA_ARGUMENT_3_INPUT_ADJ        0x10000000
#define NV_055_COMBINE_1_ALPHA_ARGUMENT_3_TEXTURE0_ADJ     0x14000000
#define NV_055_COMBINE_1_ALPHA_ARGUMENT_3_TEXTURE1_ADJ     0x18000000
#define NV_055_COMBINE_1_ALPHA_OPERATION_MSK               0xE0000000 /* 31:29 */ 
#define NV_055_COMBINE_1_ALPHA_OPERATION_RMSK              0x00000007 /* 31:29 */ 
#define NV_055_COMBINE_1_ALPHA_OPERATION_WORD              0
#define NV_055_COMBINE_1_ALPHA_OPERATION_HIGH_FIELD        0x0000001F /* =31 */
#define NV_055_COMBINE_1_ALPHA_OPERATION_LOW_FIELD         0x0000001D /* =29 */
#define NV_055_COMBINE_1_ALPHA_OPERATION_ADD_ADJ           0x20000000
#define NV_055_COMBINE_1_ALPHA_OPERATION_ADD2_ADJ          0x40000000
#define NV_055_COMBINE_1_ALPHA_OPERATION_ADD4_ADJ          0x60000000
#define NV_055_COMBINE_1_ALPHA_OPERATION_ADDSIGNED_ADJ     0x80000000
#define NV_055_COMBINE_1_ALPHA_OPERATION_MUX_ADJ           0xA0000000
#define NV_055_COMBINE_1_ALPHA_OPERATION_ADDCOMPLEMENT_ADJ 0xC0000000
#define NV_055_COMBINE_1_ALPHA_OPERATION_ADDSIGNED2_ADJ    0xE0000000
#define NV_055_COMBINE_1_ALPHA_MSK                         0xFFFFFFFF 
#define NV_055_COMBINE_1_COLOR_INVERSE_0_MSK               0x00000001 /* 0:0 */ 
#define NV_055_COMBINE_1_COLOR_INVERSE_0_RMSK              0x00000001 /* 0:0 */ 
#define NV_055_COMBINE_1_COLOR_INVERSE_0_WORD              0
#define NV_055_COMBINE_1_COLOR_INVERSE_0_HIGH_FIELD        0x00000000 /* =0 */
#define NV_055_COMBINE_1_COLOR_INVERSE_0_LOW_FIELD         0x00000000 /* =0 */
#define NV_055_COMBINE_1_COLOR_INVERSE_0_NORMAL_ADJ        0x00000000
#define NV_055_COMBINE_1_COLOR_INVERSE_0_INVERSE_ADJ       0x00000001
#define NV_055_COMBINE_1_COLOR_ALPHA_0_MSK                 0x00000002 /* 1:1 */ 
#define NV_055_COMBINE_1_COLOR_ALPHA_0_RMSK                0x00000001 /* 1:1 */ 
#define NV_055_COMBINE_1_COLOR_ALPHA_0_WORD                0
#define NV_055_COMBINE_1_COLOR_ALPHA_0_HIGH_FIELD          0x00000001 /* =1 */
#define NV_055_COMBINE_1_COLOR_ALPHA_0_LOW_FIELD           0x00000001 /* =1 */
#define NV_055_COMBINE_1_COLOR_ALPHA_0_COLOR_ADJ           0x00000000
#define NV_055_COMBINE_1_COLOR_ALPHA_0_ALPHA_ADJ           0x00000002
#define NV_055_COMBINE_1_COLOR_ARGUMENT_0_MSK              0x000000FC /* 7:2 */ 
#define NV_055_COMBINE_1_COLOR_ARGUMENT_0_RMSK             0x0000003F /* 7:2 */ 
#define NV_055_COMBINE_1_COLOR_ARGUMENT_0_WORD             0
#define NV_055_COMBINE_1_COLOR_ARGUMENT_0_HIGH_FIELD       0x00000007 /* =7 */
#define NV_055_COMBINE_1_COLOR_ARGUMENT_0_LOW_FIELD        0x00000002 /* =2 */
#define NV_055_COMBINE_1_COLOR_ARGUMENT_0_ZERO_ADJ         0x00000004
#define NV_055_COMBINE_1_COLOR_ARGUMENT_0_FACTOR_ADJ       0x00000008
#define NV_055_COMBINE_1_COLOR_ARGUMENT_0_DIFFUSE_ADJ      0x0000000C
#define NV_055_COMBINE_1_COLOR_ARGUMENT_0_INPUT_ADJ        0x00000010
#define NV_055_COMBINE_1_COLOR_ARGUMENT_0_TEXTURE0_ADJ     0x00000014
#define NV_055_COMBINE_1_COLOR_ARGUMENT_0_TEXTURE1_ADJ     0x00000018
#define NV_055_COMBINE_1_COLOR_INVERSE_1_MSK               0x00000100 /* 8:8 */ 
#define NV_055_COMBINE_1_COLOR_INVERSE_1_RMSK              0x00000001 /* 8:8 */ 
#define NV_055_COMBINE_1_COLOR_INVERSE_1_WORD              0
#define NV_055_COMBINE_1_COLOR_INVERSE_1_HIGH_FIELD        0x00000008 /* =8 */
#define NV_055_COMBINE_1_COLOR_INVERSE_1_LOW_FIELD         0x00000008 /* =8 */
#define NV_055_COMBINE_1_COLOR_INVERSE_1_NORMAL_ADJ        0x00000000
#define NV_055_COMBINE_1_COLOR_INVERSE_1_INVERSE_ADJ       0x00000100
#define NV_055_COMBINE_1_COLOR_ALPHA_1_MSK                 0x00000200 /* 9:9 */ 
#define NV_055_COMBINE_1_COLOR_ALPHA_1_RMSK                0x00000001 /* 9:9 */ 
#define NV_055_COMBINE_1_COLOR_ALPHA_1_WORD                0
#define NV_055_COMBINE_1_COLOR_ALPHA_1_HIGH_FIELD          0x00000009 /* =9 */
#define NV_055_COMBINE_1_COLOR_ALPHA_1_LOW_FIELD           0x00000009 /* =9 */
#define NV_055_COMBINE_1_COLOR_ALPHA_1_COLOR_ADJ           0x00000000
#define NV_055_COMBINE_1_COLOR_ALPHA_1_ALPHA_ADJ           0x00000200
#define NV_055_COMBINE_1_COLOR_ARGUMENT_1_MSK              0x0000FC00 /* 15:10 */ 
#define NV_055_COMBINE_1_COLOR_ARGUMENT_1_RMSK             0x0000003F /* 15:10 */ 
#define NV_055_COMBINE_1_COLOR_ARGUMENT_1_WORD             0
#define NV_055_COMBINE_1_COLOR_ARGUMENT_1_HIGH_FIELD       0x0000000F /* =15 */
#define NV_055_COMBINE_1_COLOR_ARGUMENT_1_LOW_FIELD        0x0000000A /* =10 */
#define NV_055_COMBINE_1_COLOR_ARGUMENT_1_ZERO_ADJ         0x00000400
#define NV_055_COMBINE_1_COLOR_ARGUMENT_1_FACTOR_ADJ       0x00000800
#define NV_055_COMBINE_1_COLOR_ARGUMENT_1_DIFFUSE_ADJ      0x00000C00
#define NV_055_COMBINE_1_COLOR_ARGUMENT_1_INPUT_ADJ        0x00001000
#define NV_055_COMBINE_1_COLOR_ARGUMENT_1_TEXTURE0_ADJ     0x00001400
#define NV_055_COMBINE_1_COLOR_ARGUMENT_1_TEXTURE1_ADJ     0x00001800
#define NV_055_COMBINE_1_COLOR_INVERSE_2_MSK               0x00010000 /* 16:16 */ 
#define NV_055_COMBINE_1_COLOR_INVERSE_2_RMSK              0x00000001 /* 16:16 */ 
#define NV_055_COMBINE_1_COLOR_INVERSE_2_WORD              0
#define NV_055_COMBINE_1_COLOR_INVERSE_2_HIGH_FIELD        0x00000010 /* =16 */
#define NV_055_COMBINE_1_COLOR_INVERSE_2_LOW_FIELD         0x00000010 /* =16 */
#define NV_055_COMBINE_1_COLOR_INVERSE_2_NORMAL_ADJ        0x00000000
#define NV_055_COMBINE_1_COLOR_INVERSE_2_INVERSE_ADJ       0x00010000
#define NV_055_COMBINE_1_COLOR_ALPHA_2_MSK                 0x00020000 /* 17:17 */ 
#define NV_055_COMBINE_1_COLOR_ALPHA_2_RMSK                0x00000001 /* 17:17 */ 
#define NV_055_COMBINE_1_COLOR_ALPHA_2_WORD                0
#define NV_055_COMBINE_1_COLOR_ALPHA_2_HIGH_FIELD          0x00000011 /* =17 */
#define NV_055_COMBINE_1_COLOR_ALPHA_2_LOW_FIELD           0x00000011 /* =17 */
#define NV_055_COMBINE_1_COLOR_ALPHA_2_COLOR_ADJ           0x00000000
#define NV_055_COMBINE_1_COLOR_ALPHA_2_ALPHA_ADJ           0x00020000
#define NV_055_COMBINE_1_COLOR_ARGUMENT_2_MSK              0x00FC0000 /* 23:18 */ 
#define NV_055_COMBINE_1_COLOR_ARGUMENT_2_RMSK             0x0000003F /* 23:18 */ 
#define NV_055_COMBINE_1_COLOR_ARGUMENT_2_WORD             0
#define NV_055_COMBINE_1_COLOR_ARGUMENT_2_HIGH_FIELD       0x00000017 /* =23 */
#define NV_055_COMBINE_1_COLOR_ARGUMENT_2_LOW_FIELD        0x00000012 /* =18 */
#define NV_055_COMBINE_1_COLOR_ARGUMENT_2_ZERO_ADJ         0x00040000
#define NV_055_COMBINE_1_COLOR_ARGUMENT_2_FACTOR_ADJ       0x00080000
#define NV_055_COMBINE_1_COLOR_ARGUMENT_2_DIFFUSE_ADJ      0x000C0000
#define NV_055_COMBINE_1_COLOR_ARGUMENT_2_INPUT_ADJ        0x00100000
#define NV_055_COMBINE_1_COLOR_ARGUMENT_2_TEXTURE0_ADJ     0x00140000
#define NV_055_COMBINE_1_COLOR_ARGUMENT_2_TEXTURE1_ADJ     0x00180000
#define NV_055_COMBINE_1_COLOR_INVERSE_3_MSK               0x01000000 /* 24:24 */ 
#define NV_055_COMBINE_1_COLOR_INVERSE_3_RMSK              0x00000001 /* 24:24 */ 
#define NV_055_COMBINE_1_COLOR_INVERSE_3_WORD              0
#define NV_055_COMBINE_1_COLOR_INVERSE_3_HIGH_FIELD        0x00000018 /* =24 */
#define NV_055_COMBINE_1_COLOR_INVERSE_3_LOW_FIELD         0x00000018 /* =24 */
#define NV_055_COMBINE_1_COLOR_INVERSE_3_NORMAL_ADJ        0x00000000
#define NV_055_COMBINE_1_COLOR_INVERSE_3_INVERSE_ADJ       0x01000000
#define NV_055_COMBINE_1_COLOR_ALPHA_3_MSK                 0x02000000 /* 25:25 */ 
#define NV_055_COMBINE_1_COLOR_ALPHA_3_RMSK                0x00000001 /* 25:25 */ 
#define NV_055_COMBINE_1_COLOR_ALPHA_3_WORD                0
#define NV_055_COMBINE_1_COLOR_ALPHA_3_HIGH_FIELD          0x00000019 /* =25 */
#define NV_055_COMBINE_1_COLOR_ALPHA_3_LOW_FIELD           0x00000019 /* =25 */
#define NV_055_COMBINE_1_COLOR_ALPHA_3_COLOR_ADJ           0x00000000
#define NV_055_COMBINE_1_COLOR_ALPHA_3_ALPHA_ADJ           0x02000000
#define NV_055_COMBINE_1_COLOR_ARGUMENT_3_MSK              0x1C000000 /* 28:26 */ 
#define NV_055_COMBINE_1_COLOR_ARGUMENT_3_RMSK             0x00000007 /* 28:26 */ 
#define NV_055_COMBINE_1_COLOR_ARGUMENT_3_WORD             0
#define NV_055_COMBINE_1_COLOR_ARGUMENT_3_HIGH_FIELD       0x0000001C /* =28 */
#define NV_055_COMBINE_1_COLOR_ARGUMENT_3_LOW_FIELD        0x0000001A /* =26 */
#define NV_055_COMBINE_1_COLOR_ARGUMENT_3_ZERO_ADJ         0x04000000
#define NV_055_COMBINE_1_COLOR_ARGUMENT_3_FACTOR_ADJ       0x08000000
#define NV_055_COMBINE_1_COLOR_ARGUMENT_3_DIFFUSE_ADJ      0x0C000000
#define NV_055_COMBINE_1_COLOR_ARGUMENT_3_INPUT_ADJ        0x10000000
#define NV_055_COMBINE_1_COLOR_ARGUMENT_3_TEXTURE0_ADJ     0x14000000
#define NV_055_COMBINE_1_COLOR_ARGUMENT_3_TEXTURE1_ADJ     0x18000000
#define NV_055_COMBINE_1_COLOR_OPERATION_MSK               0xE0000000 /* 31:29 */ 
#define NV_055_COMBINE_1_COLOR_OPERATION_RMSK              0x00000007 /* 31:29 */ 
#define NV_055_COMBINE_1_COLOR_OPERATION_WORD              0
#define NV_055_COMBINE_1_COLOR_OPERATION_HIGH_FIELD        0x0000001F /* =31 */
#define NV_055_COMBINE_1_COLOR_OPERATION_LOW_FIELD         0x0000001D /* =29 */
#define NV_055_COMBINE_1_COLOR_OPERATION_ADD_ADJ           0x20000000
#define NV_055_COMBINE_1_COLOR_OPERATION_ADD2_ADJ          0x40000000
#define NV_055_COMBINE_1_COLOR_OPERATION_ADD4_ADJ          0x60000000
#define NV_055_COMBINE_1_COLOR_OPERATION_ADDSIGNED_ADJ     0x80000000
#define NV_055_COMBINE_1_COLOR_OPERATION_MUX_ADJ           0xA0000000
#define NV_055_COMBINE_1_COLOR_OPERATION_ADDCOMPLEMENT_ADJ 0xC0000000
#define NV_055_COMBINE_1_COLOR_OPERATION_ADDSIGNED2_ADJ    0xE0000000
#define NV_055_COMBINE_1_COLOR_MSK                         0xFFFFFFFF 
#define NV_055_COMBINE_FACTOR_BLUE_MSK                     0x000000FF /* 7:0 */ 
#define NV_055_COMBINE_FACTOR_BLUE_RMSK                    0x000000FF /* 7:0 */ 
#define NV_055_COMBINE_FACTOR_BLUE_WORD                    0
#define NV_055_COMBINE_FACTOR_BLUE_HIGH_FIELD              0x00000007 /* =7 */
#define NV_055_COMBINE_FACTOR_BLUE_LOW_FIELD               0x00000000 /* =0 */
#define NV_055_COMBINE_FACTOR_GREEN_MSK                    0x0000FF00 /* 15:8 */ 
#define NV_055_COMBINE_FACTOR_GREEN_RMSK                   0x000000FF /* 15:8 */ 
#define NV_055_COMBINE_FACTOR_GREEN_WORD                   0
#define NV_055_COMBINE_FACTOR_GREEN_HIGH_FIELD             0x0000000F /* =15 */
#define NV_055_COMBINE_FACTOR_GREEN_LOW_FIELD              0x00000008 /* =8 */
#define NV_055_COMBINE_FACTOR_RED_MSK                      0x00FF0000 /* 23:16 */ 
#define NV_055_COMBINE_FACTOR_RED_RMSK                     0x000000FF /* 23:16 */ 
#define NV_055_COMBINE_FACTOR_RED_WORD                     0
#define NV_055_COMBINE_FACTOR_RED_HIGH_FIELD               0x00000017 /* =23 */
#define NV_055_COMBINE_FACTOR_RED_LOW_FIELD                0x00000010 /* =16 */
#define NV_055_COMBINE_FACTOR_ALPHA_MSK                    0xFF000000 /* 31:24 */ 
#define NV_055_COMBINE_FACTOR_ALPHA_RMSK                   0x000000FF /* 31:24 */ 
#define NV_055_COMBINE_FACTOR_ALPHA_WORD                   0
#define NV_055_COMBINE_FACTOR_ALPHA_HIGH_FIELD             0x0000001F /* =31 */
#define NV_055_COMBINE_FACTOR_ALPHA_LOW_FIELD              0x00000018 /* =24 */
#define NV_055_COMBINE_FACTOR_MSK                          0xFFFFFFFF 
#define NV_055_BLEND_MASK_BIT_MSK                          0x0000003F /* 5:0 */ 
#define NV_055_BLEND_MASK_BIT_RMSK                         0x0000003F /* 5:0 */ 
#define NV_055_BLEND_MASK_BIT_WORD                         0
#define NV_055_BLEND_MASK_BIT_HIGH_FIELD                   0x00000005 /* =5 */
#define NV_055_BLEND_MASK_BIT_LOW_FIELD                    0x00000000 /* =0 */
#define NV_055_BLEND_MASK_BIT_LSB_ADJ                      0x00000010
#define NV_055_BLEND_MASK_BIT_MSB_ADJ                      0x00000020
#define NV_055_BLEND_SHADEMODE_MSK                         0x000000C0 /* 7:6 */ 
#define NV_055_BLEND_SHADEMODE_RMSK                        0x00000003 /* 7:6 */ 
#define NV_055_BLEND_SHADEMODE_WORD                        0
#define NV_055_BLEND_SHADEMODE_HIGH_FIELD                  0x00000007 /* =7 */
#define NV_055_BLEND_SHADEMODE_LOW_FIELD                   0x00000006 /* =6 */
#define NV_055_BLEND_SHADEMODE_FLAT_ADJ                    0x00000040
#define NV_055_BLEND_SHADEMODE_GOURAUD_ADJ                 0x00000080
#define NV_055_BLEND_SHADEMODE_PHONG_ADJ                   0x000000C0
#define NV_055_BLEND_TEXTUREPERSPECTIVE_MSK                0x00000F00 /* 11:8 */ 
#define NV_055_BLEND_TEXTUREPERSPECTIVE_RMSK               0x0000000F /* 11:8 */ 
#define NV_055_BLEND_TEXTUREPERSPECTIVE_WORD               0
#define NV_055_BLEND_TEXTUREPERSPECTIVE_HIGH_FIELD         0x0000000B /* =11 */
#define NV_055_BLEND_TEXTUREPERSPECTIVE_LOW_FIELD          0x00000008 /* =8 */
#define NV_055_BLEND_TEXTUREPERSPECTIVE_FALSE_ADJ          0x00000000
#define NV_055_BLEND_TEXTUREPERSPECTIVE_TRUE_ADJ           0x00000100
#define NV_055_BLEND_SPECULARENABLE_MSK                    0x0000F000 /* 15:12 */ 
#define NV_055_BLEND_SPECULARENABLE_RMSK                   0x0000000F /* 15:12 */ 
#define NV_055_BLEND_SPECULARENABLE_WORD                   0
#define NV_055_BLEND_SPECULARENABLE_HIGH_FIELD             0x0000000F /* =15 */
#define NV_055_BLEND_SPECULARENABLE_LOW_FIELD              0x0000000C /* =12 */
#define NV_055_BLEND_SPECULARENABLE_FALSE_ADJ              0x00000000
#define NV_055_BLEND_SPECULARENABLE_TRUE_ADJ               0x00001000
#define NV_055_BLEND_FOGENABLE_MSK                         0x000F0000 /* 19:16 */ 
#define NV_055_BLEND_FOGENABLE_RMSK                        0x0000000F /* 19:16 */ 
#define NV_055_BLEND_FOGENABLE_WORD                        0
#define NV_055_BLEND_FOGENABLE_HIGH_FIELD                  0x00000013 /* =19 */
#define NV_055_BLEND_FOGENABLE_LOW_FIELD                   0x00000010 /* =16 */
#define NV_055_BLEND_FOGENABLE_FALSE_ADJ                   0x00000000
#define NV_055_BLEND_FOGENABLE_TRUE_ADJ                    0x00010000
#define NV_055_BLEND_ALPHABLENDENABLE_MSK                  0x00F00000 /* 23:20 */ 
#define NV_055_BLEND_ALPHABLENDENABLE_RMSK                 0x0000000F /* 23:20 */ 
#define NV_055_BLEND_ALPHABLENDENABLE_WORD                 0
#define NV_055_BLEND_ALPHABLENDENABLE_HIGH_FIELD           0x00000017 /* =23 */
#define NV_055_BLEND_ALPHABLENDENABLE_LOW_FIELD            0x00000014 /* =20 */
#define NV_055_BLEND_ALPHABLENDENABLE_FALSE_ADJ            0x00000000
#define NV_055_BLEND_ALPHABLENDENABLE_TRUE_ADJ             0x00100000
#define NV_055_BLEND_SRCBLEND_MSK                          0x0F000000 /* 27:24 */ 
#define NV_055_BLEND_SRCBLEND_RMSK                         0x0000000F /* 27:24 */ 
#define NV_055_BLEND_SRCBLEND_WORD                         0
#define NV_055_BLEND_SRCBLEND_HIGH_FIELD                   0x0000001B /* =27 */
#define NV_055_BLEND_SRCBLEND_LOW_FIELD                    0x00000018 /* =24 */
#define NV_055_BLEND_SRCBLEND_ZERO_ADJ                     0x01000000
#define NV_055_BLEND_SRCBLEND_ONE_ADJ                      0x02000000
#define NV_055_BLEND_SRCBLEND_SRCCOLOR_ADJ                 0x03000000
#define NV_055_BLEND_SRCBLEND_INVSRCCOLOR_ADJ              0x04000000
#define NV_055_BLEND_SRCBLEND_SRCALPHA_ADJ                 0x05000000
#define NV_055_BLEND_SRCBLEND_INVSRCALPHA_ADJ              0x06000000
#define NV_055_BLEND_SRCBLEND_DESTALPHA_ADJ                0x07000000
#define NV_055_BLEND_SRCBLEND_INVDESTALPHA_ADJ             0x08000000
#define NV_055_BLEND_SRCBLEND_DESTCOLOR_ADJ                0x09000000
#define NV_055_BLEND_SRCBLEND_INVDESTCOLOR_ADJ             0x0A000000
#define NV_055_BLEND_SRCBLEND_SRCALPHASAT_ADJ              0x0B000000
#define NV_055_BLEND_DESTBLEND_MSK                         0xF0000000 /* 31:28 */ 
#define NV_055_BLEND_DESTBLEND_RMSK                        0x0000000F /* 31:28 */ 
#define NV_055_BLEND_DESTBLEND_WORD                        0
#define NV_055_BLEND_DESTBLEND_HIGH_FIELD                  0x0000001F /* =31 */
#define NV_055_BLEND_DESTBLEND_LOW_FIELD                   0x0000001C /* =28 */
#define NV_055_BLEND_DESTBLEND_ZERO_ADJ                    0x10000000
#define NV_055_BLEND_DESTBLEND_ONE_ADJ                     0x20000000
#define NV_055_BLEND_DESTBLEND_SRCCOLOR_ADJ                0x30000000
#define NV_055_BLEND_DESTBLEND_INVSRCCOLOR_ADJ             0x40000000
#define NV_055_BLEND_DESTBLEND_SRCALPHA_ADJ                0x50000000
#define NV_055_BLEND_DESTBLEND_INVSRCALPHA_ADJ             0x60000000
#define NV_055_BLEND_DESTBLEND_DESTALPHA_ADJ               0x70000000
#define NV_055_BLEND_DESTBLEND_INVDESTALPHA_ADJ            0x80000000
#define NV_055_BLEND_DESTBLEND_DESTCOLOR_ADJ               0x90000000
#define NV_055_BLEND_DESTBLEND_INVDESTCOLOR_ADJ            0xA0000000
#define NV_055_BLEND_DESTBLEND_SRCALPHASAT_ADJ             0xB0000000
#define NV_055_BLEND_MSK                                   0xFFFFFFFF 
#define NV_055_CONTROL0_ALPHAREF_MSK                       0x000000FF /* 7:0 */ 
#define NV_055_CONTROL0_ALPHAREF_RMSK                      0x000000FF /* 7:0 */ 
#define NV_055_CONTROL0_ALPHAREF_WORD                      0
#define NV_055_CONTROL0_ALPHAREF_HIGH_FIELD                0x00000007 /* =7 */
#define NV_055_CONTROL0_ALPHAREF_LOW_FIELD                 0x00000000 /* =0 */
#define NV_055_CONTROL0_ALPHAFUNC_MSK                      0x00000F00 /* 11:8 */ 
#define NV_055_CONTROL0_ALPHAFUNC_RMSK                     0x0000000F /* 11:8 */ 
#define NV_055_CONTROL0_ALPHAFUNC_WORD                     0
#define NV_055_CONTROL0_ALPHAFUNC_HIGH_FIELD               0x0000000B /* =11 */
#define NV_055_CONTROL0_ALPHAFUNC_LOW_FIELD                0x00000008 /* =8 */
#define NV_055_CONTROL0_ALPHAFUNC_NEVER_ADJ                0x00000100
#define NV_055_CONTROL0_ALPHAFUNC_LESS_ADJ                 0x00000200
#define NV_055_CONTROL0_ALPHAFUNC_EQUAL_ADJ                0x00000300
#define NV_055_CONTROL0_ALPHAFUNC_LESSEQUAL_ADJ            0x00000400
#define NV_055_CONTROL0_ALPHAFUNC_GREATER_ADJ              0x00000500
#define NV_055_CONTROL0_ALPHAFUNC_NOTEQUAL_ADJ             0x00000600
#define NV_055_CONTROL0_ALPHAFUNC_GREATEREQUAL_ADJ         0x00000700
#define NV_055_CONTROL0_ALPHAFUNC_ALWAYS_ADJ               0x00000800
#define NV_055_CONTROL0_ALPHATESTENABLE_MSK                0x00001000 /* 12:12 */ 
#define NV_055_CONTROL0_ALPHATESTENABLE_RMSK               0x00000001 /* 12:12 */ 
#define NV_055_CONTROL0_ALPHATESTENABLE_WORD               0
#define NV_055_CONTROL0_ALPHATESTENABLE_HIGH_FIELD         0x0000000C /* =12 */
#define NV_055_CONTROL0_ALPHATESTENABLE_LOW_FIELD          0x0000000C /* =12 */
#define NV_055_CONTROL0_ALPHATESTENABLE_FALSE_ADJ          0x00000000
#define NV_055_CONTROL0_ALPHATESTENABLE_TRUE_ADJ           0x00001000
#define NV_055_CONTROL0_ORIGIN_MSK                         0x00002000 /* 13:13 */ 
#define NV_055_CONTROL0_ORIGIN_RMSK                        0x00000001 /* 13:13 */ 
#define NV_055_CONTROL0_ORIGIN_WORD                        0
#define NV_055_CONTROL0_ORIGIN_HIGH_FIELD                  0x0000000D /* =13 */
#define NV_055_CONTROL0_ORIGIN_LOW_FIELD                   0x0000000D /* =13 */
#define NV_055_CONTROL0_ORIGIN_CENTER_ADJ                  0x00000000
#define NV_055_CONTROL0_ORIGIN_CORNER_ADJ                  0x00002000
#define NV_055_CONTROL0_ZENABLE_MSK                        0x0000C000 /* 15:14 */ 
#define NV_055_CONTROL0_ZENABLE_RMSK                       0x00000003 /* 15:14 */ 
#define NV_055_CONTROL0_ZENABLE_WORD                       0
#define NV_055_CONTROL0_ZENABLE_HIGH_FIELD                 0x0000000F /* =15 */
#define NV_055_CONTROL0_ZENABLE_LOW_FIELD                  0x0000000E /* =14 */
#define NV_055_CONTROL0_ZENABLE_FALSE_ADJ                  0x00000000
#define NV_055_CONTROL0_ZENABLE_TRUE_ADJ                   0x00004000
#define NV_055_CONTROL0_ZFUNC_MSK                          0x000F0000 /* 19:16 */ 
#define NV_055_CONTROL0_ZFUNC_RMSK                         0x0000000F /* 19:16 */ 
#define NV_055_CONTROL0_ZFUNC_WORD                         0
#define NV_055_CONTROL0_ZFUNC_HIGH_FIELD                   0x00000013 /* =19 */
#define NV_055_CONTROL0_ZFUNC_LOW_FIELD                    0x00000010 /* =16 */
#define NV_055_CONTROL0_ZFUNC_NEVER_ADJ                    0x00010000
#define NV_055_CONTROL0_ZFUNC_LESS_ADJ                     0x00020000
#define NV_055_CONTROL0_ZFUNC_EQUAL_ADJ                    0x00030000
#define NV_055_CONTROL0_ZFUNC_LESSEQUAL_ADJ                0x00040000
#define NV_055_CONTROL0_ZFUNC_GREATER_ADJ                  0x00050000
#define NV_055_CONTROL0_ZFUNC_NOTEQUAL_ADJ                 0x00060000
#define NV_055_CONTROL0_ZFUNC_GREATEREQUAL_ADJ             0x00070000
#define NV_055_CONTROL0_ZFUNC_ALWAYS_ADJ                   0x00080000
#define NV_055_CONTROL0_CULLMODE_MSK                       0x00300000 /* 21:20 */ 
#define NV_055_CONTROL0_CULLMODE_RMSK                      0x00000003 /* 21:20 */ 
#define NV_055_CONTROL0_CULLMODE_WORD                      0
#define NV_055_CONTROL0_CULLMODE_HIGH_FIELD                0x00000015 /* =21 */
#define NV_055_CONTROL0_CULLMODE_LOW_FIELD                 0x00000014 /* =20 */
#define NV_055_CONTROL0_CULLMODE_NONE_ADJ                  0x00100000
#define NV_055_CONTROL0_CULLMODE_CW_ADJ                    0x00200000
#define NV_055_CONTROL0_CULLMODE_CCW_ADJ                   0x00300000
#define NV_055_CONTROL0_DITHERENABLE_MSK                   0x00400000 /* 22:22 */ 
#define NV_055_CONTROL0_DITHERENABLE_RMSK                  0x00000001 /* 22:22 */ 
#define NV_055_CONTROL0_DITHERENABLE_WORD                  0
#define NV_055_CONTROL0_DITHERENABLE_HIGH_FIELD            0x00000016 /* =22 */
#define NV_055_CONTROL0_DITHERENABLE_LOW_FIELD             0x00000016 /* =22 */
#define NV_055_CONTROL0_DITHERENABLE_FALSE_ADJ             0x00000000
#define NV_055_CONTROL0_DITHERENABLE_TRUE_ADJ              0x00400000
#define NV_055_CONTROL0_Z_PERSPECTIVE_ENABLE_MSK           0x00800000 /* 23:23 */ 
#define NV_055_CONTROL0_Z_PERSPECTIVE_ENABLE_RMSK          0x00000001 /* 23:23 */ 
#define NV_055_CONTROL0_Z_PERSPECTIVE_ENABLE_WORD          0
#define NV_055_CONTROL0_Z_PERSPECTIVE_ENABLE_HIGH_FIELD    0x00000017 /* =23 */
#define NV_055_CONTROL0_Z_PERSPECTIVE_ENABLE_LOW_FIELD     0x00000017 /* =23 */
#define NV_055_CONTROL0_Z_PERSPECTIVE_ENABLE_FALSE_ADJ     0x00000000
#define NV_055_CONTROL0_Z_PERSPECTIVE_ENABLE_TRUE_ADJ      0x00800000
#define NV_055_CONTROL0_ZWRITEENABLE_MSK                   0x01000000 /* 24:24 */ 
#define NV_055_CONTROL0_ZWRITEENABLE_RMSK                  0x00000001 /* 24:24 */ 
#define NV_055_CONTROL0_ZWRITEENABLE_WORD                  0
#define NV_055_CONTROL0_ZWRITEENABLE_HIGH_FIELD            0x00000018 /* =24 */
#define NV_055_CONTROL0_ZWRITEENABLE_LOW_FIELD             0x00000018 /* =24 */
#define NV_055_CONTROL0_ZWRITEENABLE_FALSE_ADJ             0x00000000
#define NV_055_CONTROL0_ZWRITEENABLE_TRUE_ADJ              0x01000000
#define NV_055_CONTROL0_STENCIL_WRITE_ENABLE_MSK           0x02000000 /* 25:25 */ 
#define NV_055_CONTROL0_STENCIL_WRITE_ENABLE_RMSK          0x00000001 /* 25:25 */ 
#define NV_055_CONTROL0_STENCIL_WRITE_ENABLE_WORD          0
#define NV_055_CONTROL0_STENCIL_WRITE_ENABLE_HIGH_FIELD    0x00000019 /* =25 */
#define NV_055_CONTROL0_STENCIL_WRITE_ENABLE_LOW_FIELD     0x00000019 /* =25 */
#define NV_055_CONTROL0_STENCIL_WRITE_ENABLE_FALSE_ADJ     0x00000000
#define NV_055_CONTROL0_STENCIL_WRITE_ENABLE_TRUE_ADJ      0x02000000
#define NV_055_CONTROL0_ALPHA_WRITE_ENABLE_MSK             0x04000000 /* 26:26 */ 
#define NV_055_CONTROL0_ALPHA_WRITE_ENABLE_RMSK            0x00000001 /* 26:26 */ 
#define NV_055_CONTROL0_ALPHA_WRITE_ENABLE_WORD            0
#define NV_055_CONTROL0_ALPHA_WRITE_ENABLE_HIGH_FIELD      0x0000001A /* =26 */
#define NV_055_CONTROL0_ALPHA_WRITE_ENABLE_LOW_FIELD       0x0000001A /* =26 */
#define NV_055_CONTROL0_ALPHA_WRITE_ENABLE_FALSE_ADJ       0x00000000
#define NV_055_CONTROL0_ALPHA_WRITE_ENABLE_TRUE_ADJ        0x04000000
#define NV_055_CONTROL0_RED_WRITE_ENABLE_MSK               0x08000000 /* 27:27 */ 
#define NV_055_CONTROL0_RED_WRITE_ENABLE_RMSK              0x00000001 /* 27:27 */ 
#define NV_055_CONTROL0_RED_WRITE_ENABLE_WORD              0
#define NV_055_CONTROL0_RED_WRITE_ENABLE_HIGH_FIELD        0x0000001B /* =27 */
#define NV_055_CONTROL0_RED_WRITE_ENABLE_LOW_FIELD         0x0000001B /* =27 */
#define NV_055_CONTROL0_RED_WRITE_ENABLE_FALSE_ADJ         0x00000000
#define NV_055_CONTROL0_RED_WRITE_ENABLE_TRUE_ADJ          0x08000000
#define NV_055_CONTROL0_GREEN_WRITE_ENABLE_MSK             0x10000000 /* 28:28 */ 
#define NV_055_CONTROL0_GREEN_WRITE_ENABLE_RMSK            0x00000001 /* 28:28 */ 
#define NV_055_CONTROL0_GREEN_WRITE_ENABLE_WORD            0
#define NV_055_CONTROL0_GREEN_WRITE_ENABLE_HIGH_FIELD      0x0000001C /* =28 */
#define NV_055_CONTROL0_GREEN_WRITE_ENABLE_LOW_FIELD       0x0000001C /* =28 */
#define NV_055_CONTROL0_GREEN_WRITE_ENABLE_FALSE_ADJ       0x00000000
#define NV_055_CONTROL0_GREEN_WRITE_ENABLE_TRUE_ADJ        0x10000000
#define NV_055_CONTROL0_BLUE_WRITE_ENABLE_MSK              0x20000000 /* 29:29 */ 
#define NV_055_CONTROL0_BLUE_WRITE_ENABLE_RMSK             0x00000001 /* 29:29 */ 
#define NV_055_CONTROL0_BLUE_WRITE_ENABLE_WORD             0
#define NV_055_CONTROL0_BLUE_WRITE_ENABLE_HIGH_FIELD       0x0000001D /* =29 */
#define NV_055_CONTROL0_BLUE_WRITE_ENABLE_LOW_FIELD        0x0000001D /* =29 */
#define NV_055_CONTROL0_BLUE_WRITE_ENABLE_FALSE_ADJ        0x00000000
#define NV_055_CONTROL0_BLUE_WRITE_ENABLE_TRUE_ADJ         0x20000000
#define NV_055_CONTROL0_Z_FORMAT_MSK                       0xC0000000 /* 31:30 */ 
#define NV_055_CONTROL0_Z_FORMAT_RMSK                      0x00000003 /* 31:30 */ 
#define NV_055_CONTROL0_Z_FORMAT_WORD                      0
#define NV_055_CONTROL0_Z_FORMAT_HIGH_FIELD                0x0000001F /* =31 */
#define NV_055_CONTROL0_Z_FORMAT_LOW_FIELD                 0x0000001E /* =30 */
#define NV_055_CONTROL0_Z_FORMAT_FIXED_ADJ                 0x40000000
#define NV_055_CONTROL0_Z_FORMAT_FLOAT_ADJ                 0x80000000
#define NV_055_CONTROL0_MSK                                0xFFFFFFFF 
#define NV_055_CONTROL1_STENCIL_TEST_ENABLE_MSK            0x0000000F /* 3:0 */ 
#define NV_055_CONTROL1_STENCIL_TEST_ENABLE_RMSK           0x0000000F /* 3:0 */ 
#define NV_055_CONTROL1_STENCIL_TEST_ENABLE_WORD           0
#define NV_055_CONTROL1_STENCIL_TEST_ENABLE_HIGH_FIELD     0x00000003 /* =3 */
#define NV_055_CONTROL1_STENCIL_TEST_ENABLE_LOW_FIELD      0x00000000 /* =0 */
#define NV_055_CONTROL1_STENCIL_TEST_ENABLE_FALSE_ADJ      0x00000000
#define NV_055_CONTROL1_STENCIL_TEST_ENABLE_TRUE_ADJ       0x00000001
#define NV_055_CONTROL1_STENCIL_FUNC_MSK                   0x000000F0 /* 7:4 */ 
#define NV_055_CONTROL1_STENCIL_FUNC_RMSK                  0x0000000F /* 7:4 */ 
#define NV_055_CONTROL1_STENCIL_FUNC_WORD                  0
#define NV_055_CONTROL1_STENCIL_FUNC_HIGH_FIELD            0x00000007 /* =7 */
#define NV_055_CONTROL1_STENCIL_FUNC_LOW_FIELD             0x00000004 /* =4 */
#define NV_055_CONTROL1_STENCIL_FUNC_NEVER_ADJ             0x00000010
#define NV_055_CONTROL1_STENCIL_FUNC_LESS_ADJ              0x00000020
#define NV_055_CONTROL1_STENCIL_FUNC_EQUAL_ADJ             0x00000030
#define NV_055_CONTROL1_STENCIL_FUNC_LESSEQUAL_ADJ         0x00000040
#define NV_055_CONTROL1_STENCIL_FUNC_GREATER_ADJ           0x00000050
#define NV_055_CONTROL1_STENCIL_FUNC_NOTEQUAL_ADJ          0x00000060
#define NV_055_CONTROL1_STENCIL_FUNC_GREATEREQUAL_ADJ      0x00000070
#define NV_055_CONTROL1_STENCIL_FUNC_ALWAYS_ADJ            0x00000080
#define NV_055_CONTROL1_STENCIL_REF_MSK                    0x0000FF00 /* 15:8 */ 
#define NV_055_CONTROL1_STENCIL_REF_RMSK                   0x000000FF /* 15:8 */ 
#define NV_055_CONTROL1_STENCIL_REF_WORD                   0
#define NV_055_CONTROL1_STENCIL_REF_HIGH_FIELD             0x0000000F /* =15 */
#define NV_055_CONTROL1_STENCIL_REF_LOW_FIELD              0x00000008 /* =8 */
#define NV_055_CONTROL1_STENCIL_MASK_READ_MSK              0x00FF0000 /* 23:16 */ 
#define NV_055_CONTROL1_STENCIL_MASK_READ_RMSK             0x000000FF /* 23:16 */ 
#define NV_055_CONTROL1_STENCIL_MASK_READ_WORD             0
#define NV_055_CONTROL1_STENCIL_MASK_READ_HIGH_FIELD       0x00000017 /* =23 */
#define NV_055_CONTROL1_STENCIL_MASK_READ_LOW_FIELD        0x00000010 /* =16 */
#define NV_055_CONTROL1_STENCIL_MASK_WRITE_MSK             0xFF000000 /* 31:24 */ 
#define NV_055_CONTROL1_STENCIL_MASK_WRITE_RMSK            0x000000FF /* 31:24 */ 
#define NV_055_CONTROL1_STENCIL_MASK_WRITE_WORD            0
#define NV_055_CONTROL1_STENCIL_MASK_WRITE_HIGH_FIELD      0x0000001F /* =31 */
#define NV_055_CONTROL1_STENCIL_MASK_WRITE_LOW_FIELD       0x00000018 /* =24 */
#define NV_055_CONTROL1_MSK                                0xFFFFFFFF 
#define NV_055_CONTROL2_STENCIL_OP_FAIL_MSK                0x0000000F /* 3:0 */ 
#define NV_055_CONTROL2_STENCIL_OP_FAIL_RMSK               0x0000000F /* 3:0 */ 
#define NV_055_CONTROL2_STENCIL_OP_FAIL_WORD               0
#define NV_055_CONTROL2_STENCIL_OP_FAIL_HIGH_FIELD         0x00000003 /* =3 */
#define NV_055_CONTROL2_STENCIL_OP_FAIL_LOW_FIELD          0x00000000 /* =0 */
#define NV_055_CONTROL2_STENCIL_OP_FAIL_KEEP_ADJ           0x00000001
#define NV_055_CONTROL2_STENCIL_OP_FAIL_ZERO_ADJ           0x00000002
#define NV_055_CONTROL2_STENCIL_OP_FAIL_REPLACE_ADJ        0x00000003
#define NV_055_CONTROL2_STENCIL_OP_FAIL_INCRSAT_ADJ        0x00000004
#define NV_055_CONTROL2_STENCIL_OP_FAIL_DECRSAT_ADJ        0x00000005
#define NV_055_CONTROL2_STENCIL_OP_FAIL_INVERT_ADJ         0x00000006
#define NV_055_CONTROL2_STENCIL_OP_FAIL_INCR_ADJ           0x00000007
#define NV_055_CONTROL2_STENCIL_OP_FAIL_DECR_ADJ           0x00000008
#define NV_055_CONTROL2_STENCIL_OP_ZFAIL_MSK               0x000000F0 /* 7:4 */ 
#define NV_055_CONTROL2_STENCIL_OP_ZFAIL_RMSK              0x0000000F /* 7:4 */ 
#define NV_055_CONTROL2_STENCIL_OP_ZFAIL_WORD              0
#define NV_055_CONTROL2_STENCIL_OP_ZFAIL_HIGH_FIELD        0x00000007 /* =7 */
#define NV_055_CONTROL2_STENCIL_OP_ZFAIL_LOW_FIELD         0x00000004 /* =4 */
#define NV_055_CONTROL2_STENCIL_OP_ZFAIL_KEEP_ADJ          0x00000010
#define NV_055_CONTROL2_STENCIL_OP_ZFAIL_ZERO_ADJ          0x00000020
#define NV_055_CONTROL2_STENCIL_OP_ZFAIL_REPLACE_ADJ       0x00000030
#define NV_055_CONTROL2_STENCIL_OP_ZFAIL_INCRSAT_ADJ       0x00000040
#define NV_055_CONTROL2_STENCIL_OP_ZFAIL_DECRSAT_ADJ       0x00000050
#define NV_055_CONTROL2_STENCIL_OP_ZFAIL_INVERT_ADJ        0x00000060
#define NV_055_CONTROL2_STENCIL_OP_ZFAIL_INCR_ADJ          0x00000070
#define NV_055_CONTROL2_STENCIL_OP_ZFAIL_DECR_ADJ          0x00000080
#define NV_055_CONTROL2_STENCIL_OP_ZPASS_MSK               0xFFFFFF00 /* 31:8 */ 
#define NV_055_CONTROL2_STENCIL_OP_ZPASS_RMSK              0x00FFFFFF /* 31:8 */ 
#define NV_055_CONTROL2_STENCIL_OP_ZPASS_WORD              0
#define NV_055_CONTROL2_STENCIL_OP_ZPASS_HIGH_FIELD        0x0000001F /* =31 */
#define NV_055_CONTROL2_STENCIL_OP_ZPASS_LOW_FIELD         0x00000008 /* =8 */
#define NV_055_CONTROL2_STENCIL_OP_ZPASS_KEEP_ADJ          0x00000100
#define NV_055_CONTROL2_STENCIL_OP_ZPASS_ZERO_ADJ          0x00000200
#define NV_055_CONTROL2_STENCIL_OP_ZPASS_REPLACE_ADJ       0x00000300
#define NV_055_CONTROL2_STENCIL_OP_ZPASS_INCRSAT_ADJ       0x00000400
#define NV_055_CONTROL2_STENCIL_OP_ZPASS_DECRSAT_ADJ       0x00000500
#define NV_055_CONTROL2_STENCIL_OP_ZPASS_INVERT_ADJ        0x00000600
#define NV_055_CONTROL2_STENCIL_OP_ZPASS_INCR_ADJ          0x00000700
#define NV_055_CONTROL2_STENCIL_OP_ZPASS_DECR_ADJ          0x00000800
#define NV_055_CONTROL2_MSK                                0xFFFFFFFF 
#define NV_055_FOGCOLOR_VALUE_MSK                          0xFFFFFFFF /* 31:0 */ 
#define NV_055_FOGCOLOR_VALUE_RMSK                         0xFFFFFFFF /* 31:0 */ 
#define NV_055_FOGCOLOR_VALUE_WORD                         0
#define NV_055_FOGCOLOR_VALUE_HIGH_FIELD                   0x0000001F /* =31 */
#define NV_055_FOGCOLOR_VALUE_LOW_FIELD                    0x00000000 /* =0 */
#define NV_055_FOGCOLOR_MSK                                0xFFFFFFFF 
#define NV_055_TLMTVERTEX_SX_VALUE_MSK                     0xFFFFFFFF /* 31:0 */ 
#define NV_055_TLMTVERTEX_SX_VALUE_RMSK                    0xFFFFFFFF /* 31:0 */ 
#define NV_055_TLMTVERTEX_SX_VALUE_WORD                    0
#define NV_055_TLMTVERTEX_SX_VALUE_HIGH_FIELD              0x0000001F /* =31 */
#define NV_055_TLMTVERTEX_SX_VALUE_LOW_FIELD               0x00000000 /* =0 */
#define NV_055_TLMTVERTEX_SX_MSK                           0xFFFFFFFF 
#define NV_055_TLMTVERTEX_SY_VALUE_MSK                     0xFFFFFFFF /* 31:0 */ 
#define NV_055_TLMTVERTEX_SY_VALUE_RMSK                    0xFFFFFFFF /* 31:0 */ 
#define NV_055_TLMTVERTEX_SY_VALUE_WORD                    0
#define NV_055_TLMTVERTEX_SY_VALUE_HIGH_FIELD              0x0000001F /* =31 */
#define NV_055_TLMTVERTEX_SY_VALUE_LOW_FIELD               0x00000000 /* =0 */
#define NV_055_TLMTVERTEX_SY_MSK                           0xFFFFFFFF 
#define NV_055_TLMTVERTEX_SZ_VALUE_MSK                     0xFFFFFFFF /* 31:0 */ 
#define NV_055_TLMTVERTEX_SZ_VALUE_RMSK                    0xFFFFFFFF /* 31:0 */ 
#define NV_055_TLMTVERTEX_SZ_VALUE_WORD                    0
#define NV_055_TLMTVERTEX_SZ_VALUE_HIGH_FIELD              0x0000001F /* =31 */
#define NV_055_TLMTVERTEX_SZ_VALUE_LOW_FIELD               0x00000000 /* =0 */
#define NV_055_TLMTVERTEX_SZ_MSK                           0xFFFFFFFF 
#define NV_055_TLMTVERTEX_RHW_VALUE_MSK                    0xFFFFFFFF /* 31:0 */ 
#define NV_055_TLMTVERTEX_RHW_VALUE_RMSK                   0xFFFFFFFF /* 31:0 */ 
#define NV_055_TLMTVERTEX_RHW_VALUE_WORD                   0
#define NV_055_TLMTVERTEX_RHW_VALUE_HIGH_FIELD             0x0000001F /* =31 */
#define NV_055_TLMTVERTEX_RHW_VALUE_LOW_FIELD              0x00000000 /* =0 */
#define NV_055_TLMTVERTEX_RHW_MSK                          0xFFFFFFFF 
#define NV_055_TLMTVERTEX_COLOR_VALUE_MSK                  0xFFFFFFFF /* 31:0 */ 
#define NV_055_TLMTVERTEX_COLOR_VALUE_RMSK                 0xFFFFFFFF /* 31:0 */ 
#define NV_055_TLMTVERTEX_COLOR_VALUE_WORD                 0
#define NV_055_TLMTVERTEX_COLOR_VALUE_HIGH_FIELD           0x0000001F /* =31 */
#define NV_055_TLMTVERTEX_COLOR_VALUE_LOW_FIELD            0x00000000 /* =0 */
#define NV_055_TLMTVERTEX_COLOR_BLUE_MSK                   0x000000FF /* 7:0 */ 
#define NV_055_TLMTVERTEX_COLOR_BLUE_RMSK                  0x000000FF /* 7:0 */ 
#define NV_055_TLMTVERTEX_COLOR_BLUE_WORD                  0
#define NV_055_TLMTVERTEX_COLOR_BLUE_HIGH_FIELD            0x00000007 /* =7 */
#define NV_055_TLMTVERTEX_COLOR_BLUE_LOW_FIELD             0x00000000 /* =0 */
#define NV_055_TLMTVERTEX_COLOR_GREEN_MSK                  0x0000FF00 /* 15:8 */ 
#define NV_055_TLMTVERTEX_COLOR_GREEN_RMSK                 0x000000FF /* 15:8 */ 
#define NV_055_TLMTVERTEX_COLOR_GREEN_WORD                 0
#define NV_055_TLMTVERTEX_COLOR_GREEN_HIGH_FIELD           0x0000000F /* =15 */
#define NV_055_TLMTVERTEX_COLOR_GREEN_LOW_FIELD            0x00000008 /* =8 */
#define NV_055_TLMTVERTEX_COLOR_RED_MSK                    0x00FF0000 /* 23:16 */ 
#define NV_055_TLMTVERTEX_COLOR_RED_RMSK                   0x000000FF /* 23:16 */ 
#define NV_055_TLMTVERTEX_COLOR_RED_WORD                   0
#define NV_055_TLMTVERTEX_COLOR_RED_HIGH_FIELD             0x00000017 /* =23 */
#define NV_055_TLMTVERTEX_COLOR_RED_LOW_FIELD              0x00000010 /* =16 */
#define NV_055_TLMTVERTEX_COLOR_ALPHA_MSK                  0xFF000000 /* 31:24 */ 
#define NV_055_TLMTVERTEX_COLOR_ALPHA_RMSK                 0x000000FF /* 31:24 */ 
#define NV_055_TLMTVERTEX_COLOR_ALPHA_WORD                 0
#define NV_055_TLMTVERTEX_COLOR_ALPHA_HIGH_FIELD           0x0000001F /* =31 */
#define NV_055_TLMTVERTEX_COLOR_ALPHA_LOW_FIELD            0x00000018 /* =24 */
#define NV_055_TLMTVERTEX_COLOR_MSK                        0xFFFFFFFF 
#define NV_055_TLMTVERTEX_SPECULAR_VALUE_MSK               0xFFFFFFFF /* 31:0 */ 
#define NV_055_TLMTVERTEX_SPECULAR_VALUE_RMSK              0xFFFFFFFF /* 31:0 */ 
#define NV_055_TLMTVERTEX_SPECULAR_VALUE_WORD              0
#define NV_055_TLMTVERTEX_SPECULAR_VALUE_HIGH_FIELD        0x0000001F /* =31 */
#define NV_055_TLMTVERTEX_SPECULAR_VALUE_LOW_FIELD         0x00000000 /* =0 */
#define NV_055_TLMTVERTEX_SPECULAR_BLUE_MSK                0x000000FF /* 7:0 */ 
#define NV_055_TLMTVERTEX_SPECULAR_BLUE_RMSK               0x000000FF /* 7:0 */ 
#define NV_055_TLMTVERTEX_SPECULAR_BLUE_WORD               0
#define NV_055_TLMTVERTEX_SPECULAR_BLUE_HIGH_FIELD         0x00000007 /* =7 */
#define NV_055_TLMTVERTEX_SPECULAR_BLUE_LOW_FIELD          0x00000000 /* =0 */
#define NV_055_TLMTVERTEX_SPECULAR_GREEN_MSK               0x0000FF00 /* 15:8 */ 
#define NV_055_TLMTVERTEX_SPECULAR_GREEN_RMSK              0x000000FF /* 15:8 */ 
#define NV_055_TLMTVERTEX_SPECULAR_GREEN_WORD              0
#define NV_055_TLMTVERTEX_SPECULAR_GREEN_HIGH_FIELD        0x0000000F /* =15 */
#define NV_055_TLMTVERTEX_SPECULAR_GREEN_LOW_FIELD         0x00000008 /* =8 */
#define NV_055_TLMTVERTEX_SPECULAR_RED_MSK                 0x00FF0000 /* 23:16 */ 
#define NV_055_TLMTVERTEX_SPECULAR_RED_RMSK                0x000000FF /* 23:16 */ 
#define NV_055_TLMTVERTEX_SPECULAR_RED_WORD                0
#define NV_055_TLMTVERTEX_SPECULAR_RED_HIGH_FIELD          0x00000017 /* =23 */
#define NV_055_TLMTVERTEX_SPECULAR_RED_LOW_FIELD           0x00000010 /* =16 */
#define NV_055_TLMTVERTEX_SPECULAR_FOG_MSK                 0xFF000000 /* 31:24 */ 
#define NV_055_TLMTVERTEX_SPECULAR_FOG_RMSK                0x000000FF /* 31:24 */ 
#define NV_055_TLMTVERTEX_SPECULAR_FOG_WORD                0
#define NV_055_TLMTVERTEX_SPECULAR_FOG_HIGH_FIELD          0x0000001F /* =31 */
#define NV_055_TLMTVERTEX_SPECULAR_FOG_LOW_FIELD           0x00000018 /* =24 */
#define NV_055_TLMTVERTEX_SPECULAR_MSK                     0xFFFFFFFF 
#define NV_055_TLMTVERTEX_TU0_VALUE_MSK                    0xFFFFFFFF /* 31:0 */ 
#define NV_055_TLMTVERTEX_TU0_VALUE_RMSK                   0xFFFFFFFF /* 31:0 */ 
#define NV_055_TLMTVERTEX_TU0_VALUE_WORD                   0
#define NV_055_TLMTVERTEX_TU0_VALUE_HIGH_FIELD             0x0000001F /* =31 */
#define NV_055_TLMTVERTEX_TU0_VALUE_LOW_FIELD              0x00000000 /* =0 */
#define NV_055_TLMTVERTEX_TU0_MSK                          0xFFFFFFFF 
#define NV_055_TLMTVERTEX_TV0_VALUE_MSK                    0xFFFFFFFF /* 31:0 */ 
#define NV_055_TLMTVERTEX_TV0_VALUE_RMSK                   0xFFFFFFFF /* 31:0 */ 
#define NV_055_TLMTVERTEX_TV0_VALUE_WORD                   0
#define NV_055_TLMTVERTEX_TV0_VALUE_HIGH_FIELD             0x0000001F /* =31 */
#define NV_055_TLMTVERTEX_TV0_VALUE_LOW_FIELD              0x00000000 /* =0 */
#define NV_055_TLMTVERTEX_TV0_MSK                          0xFFFFFFFF 
#define NV_055_TLMTVERTEX_TU1_VALUE_MSK                    0xFFFFFFFF /* 31:0 */ 
#define NV_055_TLMTVERTEX_TU1_VALUE_RMSK                   0xFFFFFFFF /* 31:0 */ 
#define NV_055_TLMTVERTEX_TU1_VALUE_WORD                   0
#define NV_055_TLMTVERTEX_TU1_VALUE_HIGH_FIELD             0x0000001F /* =31 */
#define NV_055_TLMTVERTEX_TU1_VALUE_LOW_FIELD              0x00000000 /* =0 */
#define NV_055_TLMTVERTEX_TU1_MSK                          0xFFFFFFFF 
#define NV_055_TLMTVERTEX_TV1_VALUE_MSK                    0xFFFFFFFF /* 31:0 */ 
#define NV_055_TLMTVERTEX_TV1_VALUE_RMSK                   0xFFFFFFFF /* 31:0 */ 
#define NV_055_TLMTVERTEX_TV1_VALUE_WORD                   0
#define NV_055_TLMTVERTEX_TV1_VALUE_HIGH_FIELD             0x0000001F /* =31 */
#define NV_055_TLMTVERTEX_TV1_VALUE_LOW_FIELD              0x00000000 /* =0 */
#define NV_055_TLMTVERTEX_TV1_MSK                          0xFFFFFFFF 
#define NV_055_TLMTVERTEX_DRAWPRIMITIVE_I0_MSK             0x0000000F /* 3:0 */ 
#define NV_055_TLMTVERTEX_DRAWPRIMITIVE_I0_RMSK            0x0000000F /* 3:0 */ 
#define NV_055_TLMTVERTEX_DRAWPRIMITIVE_I0_WORD            0
#define NV_055_TLMTVERTEX_DRAWPRIMITIVE_I0_HIGH_FIELD      0x00000003 /* =3 */
#define NV_055_TLMTVERTEX_DRAWPRIMITIVE_I0_LOW_FIELD       0x00000000 /* =0 */
#define NV_055_TLMTVERTEX_DRAWPRIMITIVE_I1_MSK             0x000000F0 /* 7:4 */ 
#define NV_055_TLMTVERTEX_DRAWPRIMITIVE_I1_RMSK            0x0000000F /* 7:4 */ 
#define NV_055_TLMTVERTEX_DRAWPRIMITIVE_I1_WORD            0
#define NV_055_TLMTVERTEX_DRAWPRIMITIVE_I1_HIGH_FIELD      0x00000007 /* =7 */
#define NV_055_TLMTVERTEX_DRAWPRIMITIVE_I1_LOW_FIELD       0x00000004 /* =4 */
#define NV_055_TLMTVERTEX_DRAWPRIMITIVE_I2_MSK             0x00000F00 /* 11:8 */ 
#define NV_055_TLMTVERTEX_DRAWPRIMITIVE_I2_RMSK            0x0000000F /* 11:8 */ 
#define NV_055_TLMTVERTEX_DRAWPRIMITIVE_I2_WORD            0
#define NV_055_TLMTVERTEX_DRAWPRIMITIVE_I2_HIGH_FIELD      0x0000000B /* =11 */
#define NV_055_TLMTVERTEX_DRAWPRIMITIVE_I2_LOW_FIELD       0x00000008 /* =8 */
#define NV_055_TLMTVERTEX_DRAWPRIMITIVE_I3_MSK             0x0000F000 /* 15:12 */ 
#define NV_055_TLMTVERTEX_DRAWPRIMITIVE_I3_RMSK            0x0000000F /* 15:12 */ 
#define NV_055_TLMTVERTEX_DRAWPRIMITIVE_I3_WORD            0
#define NV_055_TLMTVERTEX_DRAWPRIMITIVE_I3_HIGH_FIELD      0x0000000F /* =15 */
#define NV_055_TLMTVERTEX_DRAWPRIMITIVE_I3_LOW_FIELD       0x0000000C /* =12 */
#define NV_055_TLMTVERTEX_DRAWPRIMITIVE_I4_MSK             0x000F0000 /* 19:16 */ 
#define NV_055_TLMTVERTEX_DRAWPRIMITIVE_I4_RMSK            0x0000000F /* 19:16 */ 
#define NV_055_TLMTVERTEX_DRAWPRIMITIVE_I4_WORD            0
#define NV_055_TLMTVERTEX_DRAWPRIMITIVE_I4_HIGH_FIELD      0x00000013 /* =19 */
#define NV_055_TLMTVERTEX_DRAWPRIMITIVE_I4_LOW_FIELD       0x00000010 /* =16 */
#define NV_055_TLMTVERTEX_DRAWPRIMITIVE_I5_MSK             0xFFF00000 /* 31:20 */ 
#define NV_055_TLMTVERTEX_DRAWPRIMITIVE_I5_RMSK            0x00000FFF /* 31:20 */ 
#define NV_055_TLMTVERTEX_DRAWPRIMITIVE_I5_WORD            0
#define NV_055_TLMTVERTEX_DRAWPRIMITIVE_I5_HIGH_FIELD      0x0000001F /* =31 */
#define NV_055_TLMTVERTEX_DRAWPRIMITIVE_I5_LOW_FIELD       0x00000014 /* =20 */
#define NV_055_TLMTVERTEX_DRAWPRIMITIVE_MSK                0xFFFFFFFF 
#define NV_094_HIGH_FIELD                                  0x00591FFF /* =5840895 */
#define NV_094_LOW_FIELD                                   0x00590000 /* =5832704 */
#define NV_094_NV10_DX5_TEXTURE_TRIANGLE_ADJ               0x00590000
#define NV_094_NV10_DX5_TEXTURE_TRIANGLE_HANDLE_MSK        0xFFFFFFFF /* 31:0 */ 
#define NV_094_NV10_DX5_TEXTURE_TRIANGLE_HANDLE_RMSK       0xFFFFFFFF /* 31:0 */ 
#define NV_094_NV10_DX5_TEXTURE_TRIANGLE_HANDLE_WORD       0
#define NV_094_NV10_DX5_TEXTURE_TRIANGLE_HANDLE_HIGH_FIELD 0x0000001F /* =31 */
#define NV_094_NV10_DX5_TEXTURE_TRIANGLE_HANDLE_LOW_FIELD  0x00000000 /* =0 */
#define NV_094_NV10_DX5_TEXTURE_TRIANGLE_MSK               0xFFFFFFFF 
#define NV_094_NOP_PARAMETER_MSK                           0xFFFFFFFF /* 31:0 */ 
#define NV_094_NOP_PARAMETER_RMSK                          0xFFFFFFFF /* 31:0 */ 
#define NV_094_NOP_PARAMETER_WORD                          0
#define NV_094_NOP_PARAMETER_HIGH_FIELD                    0x0000001F /* =31 */
#define NV_094_NOP_PARAMETER_LOW_FIELD                     0x00000000 /* =0 */
#define NV_094_NOP_MSK                                     0xFFFFFFFF 
#define NV_094_NOTIFY_STYLE_MSK                            0xFFFFFFFF /* 31:0 */ 
#define NV_094_NOTIFY_STYLE_RMSK                           0xFFFFFFFF /* 31:0 */ 
#define NV_094_NOTIFY_STYLE_WORD                           0
#define NV_094_NOTIFY_STYLE_HIGH_FIELD                     0x0000001F /* =31 */
#define NV_094_NOTIFY_STYLE_LOW_FIELD                      0x00000000 /* =0 */
#define NV_094_NOTIFY_STYLE_WRITE_ONLY_ADJ                 0x00000000
#define NV_094_NOTIFY_STYLE_WRITE_THEN_AWAKEN_ADJ          0x00000001
#define NV_094_SET_NOTIFY_PARAMETER_MSK                    0xFFFFFFFF /* 31:0 */ 
#define NV_094_SET_NOTIFY_PARAMETER_RMSK                   0xFFFFFFFF /* 31:0 */ 
#define NV_094_SET_NOTIFY_PARAMETER_WORD                   0
#define NV_094_SET_NOTIFY_PARAMETER_HIGH_FIELD             0x0000001F /* =31 */
#define NV_094_SET_NOTIFY_PARAMETER_LOW_FIELD              0x00000000 /* =0 */
#define NV_094_SET_NOTIFY_PARAMETER_WRITE_ADJ              0x00000000
#define NV_094_NOTIFY_MSK                                  0xFFFFFFFF 
#define NV_094_SET_CONTEXT_DMA_NOTIFY_PARAMETER_MSK        0xFFFFFFFF /* 31:0 */ 
#define NV_094_SET_CONTEXT_DMA_NOTIFY_PARAMETER_RMSK       0xFFFFFFFF /* 31:0 */ 
#define NV_094_SET_CONTEXT_DMA_NOTIFY_PARAMETER_WORD       0
#define NV_094_SET_CONTEXT_DMA_NOTIFY_PARAMETER_HIGH_FIELD 0x0000001F /* =31 */
#define NV_094_SET_CONTEXT_DMA_NOTIFY_PARAMETER_LOW_FIELD  0x00000000 /* =0 */
#define NV_094_SET_CONTEXT_DMA_NOTIFY_MSK                  0xFFFFFFFF 
#define NV_094_SET_CONTEXT_DMA_A_PARAMETER_MSK             0xFFFFFFFF /* 31:0 */ 
#define NV_094_SET_CONTEXT_DMA_A_PARAMETER_RMSK            0xFFFFFFFF /* 31:0 */ 
#define NV_094_SET_CONTEXT_DMA_A_PARAMETER_WORD            0
#define NV_094_SET_CONTEXT_DMA_A_PARAMETER_HIGH_FIELD      0x0000001F /* =31 */
#define NV_094_SET_CONTEXT_DMA_A_PARAMETER_LOW_FIELD       0x00000000 /* =0 */
#define NV_094_SET_CONTEXT_DMA_A_MSK                       0xFFFFFFFF 
#define NV_094_SET_CONTEXT_DMA_B_PARAMETER_MSK             0xFFFFFFFF /* 31:0 */ 
#define NV_094_SET_CONTEXT_DMA_B_PARAMETER_RMSK            0xFFFFFFFF /* 31:0 */ 
#define NV_094_SET_CONTEXT_DMA_B_PARAMETER_WORD            0
#define NV_094_SET_CONTEXT_DMA_B_PARAMETER_HIGH_FIELD      0x0000001F /* =31 */
#define NV_094_SET_CONTEXT_DMA_B_PARAMETER_LOW_FIELD       0x00000000 /* =0 */
#define NV_094_SET_CONTEXT_DMA_B_MSK                       0xFFFFFFFF 
#define NV_094_SET_CONTEXT_SURFACES_PARAMETER_MSK          0xFFFFFFFF /* 31:0 */ 
#define NV_094_SET_CONTEXT_SURFACES_PARAMETER_RMSK         0xFFFFFFFF /* 31:0 */ 
#define NV_094_SET_CONTEXT_SURFACES_PARAMETER_WORD         0
#define NV_094_SET_CONTEXT_SURFACES_PARAMETER_HIGH_FIELD   0x0000001F /* =31 */
#define NV_094_SET_CONTEXT_SURFACES_PARAMETER_LOW_FIELD    0x00000000 /* =0 */
#define NV_094_SET_CONTEXT_SURFACES_MSK                    0xFFFFFFFF 
#define NV_094_COLORKEY_VALUE_MSK                          0xFFFFFFFF /* 31:0 */ 
#define NV_094_COLORKEY_VALUE_RMSK                         0xFFFFFFFF /* 31:0 */ 
#define NV_094_COLORKEY_VALUE_WORD                         0
#define NV_094_COLORKEY_VALUE_HIGH_FIELD                   0x0000001F /* =31 */
#define NV_094_COLORKEY_VALUE_LOW_FIELD                    0x00000000 /* =0 */
#define NV_094_COLORKEY_MSK                                0xFFFFFFFF 
#define NV_094_OFFSET_VALUE_MSK                            0xFFFFFFFF /* 31:0 */ 
#define NV_094_OFFSET_VALUE_RMSK                           0xFFFFFFFF /* 31:0 */ 
#define NV_094_OFFSET_VALUE_WORD                           0
#define NV_094_OFFSET_VALUE_HIGH_FIELD                     0x0000001F /* =31 */
#define NV_094_OFFSET_VALUE_LOW_FIELD                      0x00000000 /* =0 */
#define NV_094_OFFSET_MSK                                  0xFFFFFFFF 
#define NV_094_FORMAT_CONTEXT_DMA_MSK                      0x00000003 /* 1:0 */ 
#define NV_094_FORMAT_CONTEXT_DMA_RMSK                     0x00000003 /* 1:0 */ 
#define NV_094_FORMAT_CONTEXT_DMA_WORD                     0
#define NV_094_FORMAT_CONTEXT_DMA_HIGH_FIELD               0x00000001 /* =1 */
#define NV_094_FORMAT_CONTEXT_DMA_LOW_FIELD                0x00000000 /* =0 */
#define NV_094_FORMAT_CONTEXT_DMA_A_ADJ                    0x00000001
#define NV_094_FORMAT_CONTEXT_DMA_B_ADJ                    0x00000002
#define NV_094_FORMAT_COLORKEYENABLE_MSK                   0x0000000C /* 3:2 */ 
#define NV_094_FORMAT_COLORKEYENABLE_RMSK                  0x00000003 /* 3:2 */ 
#define NV_094_FORMAT_COLORKEYENABLE_WORD                  0
#define NV_094_FORMAT_COLORKEYENABLE_HIGH_FIELD            0x00000003 /* =3 */
#define NV_094_FORMAT_COLORKEYENABLE_LOW_FIELD             0x00000002 /* =2 */
#define NV_094_FORMAT_COLORKEYENABLE_FALSE_ADJ             0x00000000
#define NV_094_FORMAT_COLORKEYENABLE_TRUE_ADJ              0x00000004
#define NV_094_FORMAT_ORIGIN_ZOH_MSK                       0x00000030 /* 5:4 */ 
#define NV_094_FORMAT_ORIGIN_ZOH_RMSK                      0x00000003 /* 5:4 */ 
#define NV_094_FORMAT_ORIGIN_ZOH_WORD                      0
#define NV_094_FORMAT_ORIGIN_ZOH_HIGH_FIELD                0x00000005 /* =5 */
#define NV_094_FORMAT_ORIGIN_ZOH_LOW_FIELD                 0x00000004 /* =4 */
#define NV_094_FORMAT_ORIGIN_ZOH_CENTER_ADJ                0x00000010
#define NV_094_FORMAT_ORIGIN_ZOH_CORNER_ADJ                0x00000020
#define NV_094_FORMAT_ORIGIN_FOH_MSK                       0x000000C0 /* 7:6 */ 
#define NV_094_FORMAT_ORIGIN_FOH_RMSK                      0x00000003 /* 7:6 */ 
#define NV_094_FORMAT_ORIGIN_FOH_WORD                      0
#define NV_094_FORMAT_ORIGIN_FOH_HIGH_FIELD                0x00000007 /* =7 */
#define NV_094_FORMAT_ORIGIN_FOH_LOW_FIELD                 0x00000006 /* =6 */
#define NV_094_FORMAT_ORIGIN_FOH_CENTER_ADJ                0x00000040
#define NV_094_FORMAT_ORIGIN_FOH_CORNER_ADJ                0x00000080
#define NV_094_FORMAT_COLOR_MSK                            0x00000F00 /* 11:8 */ 
#define NV_094_FORMAT_COLOR_RMSK                           0x0000000F /* 11:8 */ 
#define NV_094_FORMAT_COLOR_WORD                           0
#define NV_094_FORMAT_COLOR_HIGH_FIELD                     0x0000000B /* =11 */
#define NV_094_FORMAT_COLOR_LOW_FIELD                      0x00000008 /* =8 */
#define NV_094_FORMAT_COLOR_LE_Y8_ADJ                      0x00000100
#define NV_094_FORMAT_COLOR_LE_A1R5G5B5_ADJ                0x00000200
#define NV_094_FORMAT_COLOR_LE_X1R5G5B5_ADJ                0x00000300
#define NV_094_FORMAT_COLOR_LE_A4R4G4B4_ADJ                0x00000400
#define NV_094_FORMAT_COLOR_LE_R5G6B5_ADJ                  0x00000500
#define NV_094_FORMAT_COLOR_LE_A8R8G8B8_ADJ                0x00000600
#define NV_094_FORMAT_COLOR_LE_X8R8G8B8_ADJ                0x00000700
#define NV_094_FORMAT_MIPMAP_LEVELS_MSK                    0x0000F000 /* 15:12 */ 
#define NV_094_FORMAT_MIPMAP_LEVELS_RMSK                   0x0000000F /* 15:12 */ 
#define NV_094_FORMAT_MIPMAP_LEVELS_WORD                   0
#define NV_094_FORMAT_MIPMAP_LEVELS_HIGH_FIELD             0x0000000F /* =15 */
#define NV_094_FORMAT_MIPMAP_LEVELS_LOW_FIELD              0x0000000C /* =12 */
#define NV_094_FORMAT_BASE_SIZE_U_MSK                      0x000F0000 /* 19:16 */ 
#define NV_094_FORMAT_BASE_SIZE_U_RMSK                     0x0000000F /* 19:16 */ 
#define NV_094_FORMAT_BASE_SIZE_U_WORD                     0
#define NV_094_FORMAT_BASE_SIZE_U_HIGH_FIELD               0x00000013 /* =19 */
#define NV_094_FORMAT_BASE_SIZE_U_LOW_FIELD                0x00000010 /* =16 */
#define NV_094_FORMAT_BASE_SIZE_U_1X1_ADJ                  0x00000000
#define NV_094_FORMAT_BASE_SIZE_U_2X2_ADJ                  0x00010000
#define NV_094_FORMAT_BASE_SIZE_U_4X4_ADJ                  0x00020000
#define NV_094_FORMAT_BASE_SIZE_U_8X8_ADJ                  0x00030000
#define NV_094_FORMAT_BASE_SIZE_U_16X16_ADJ                0x00040000
#define NV_094_FORMAT_BASE_SIZE_U_32X32_ADJ                0x00050000
#define NV_094_FORMAT_BASE_SIZE_U_64X64_ADJ                0x00060000
#define NV_094_FORMAT_BASE_SIZE_U_128X128_ADJ              0x00070000
#define NV_094_FORMAT_BASE_SIZE_U_256X256_ADJ              0x00080000
#define NV_094_FORMAT_BASE_SIZE_U_512X512_ADJ              0x00090000
#define NV_094_FORMAT_BASE_SIZE_U_1024X1024_ADJ            0x000A0000
#define NV_094_FORMAT_BASE_SIZE_U_2048X2048_ADJ            0x000B0000
#define NV_094_FORMAT_BASE_SIZE_V_MSK                      0x00F00000 /* 23:20 */ 
#define NV_094_FORMAT_BASE_SIZE_V_RMSK                     0x0000000F /* 23:20 */ 
#define NV_094_FORMAT_BASE_SIZE_V_WORD                     0
#define NV_094_FORMAT_BASE_SIZE_V_HIGH_FIELD               0x00000017 /* =23 */
#define NV_094_FORMAT_BASE_SIZE_V_LOW_FIELD                0x00000014 /* =20 */
#define NV_094_FORMAT_BASE_SIZE_V_1X1_ADJ                  0x00000000
#define NV_094_FORMAT_BASE_SIZE_V_2X2_ADJ                  0x00100000
#define NV_094_FORMAT_BASE_SIZE_V_4X4_ADJ                  0x00200000
#define NV_094_FORMAT_BASE_SIZE_V_8X8_ADJ                  0x00300000
#define NV_094_FORMAT_BASE_SIZE_V_16X16_ADJ                0x00400000
#define NV_094_FORMAT_BASE_SIZE_V_32X32_ADJ                0x00500000
#define NV_094_FORMAT_BASE_SIZE_V_64X64_ADJ                0x00600000
#define NV_094_FORMAT_BASE_SIZE_V_128X128_ADJ              0x00700000
#define NV_094_FORMAT_BASE_SIZE_V_256X256_ADJ              0x00800000
#define NV_094_FORMAT_BASE_SIZE_V_512X512_ADJ              0x00900000
#define NV_094_FORMAT_BASE_SIZE_V_1024X1024_ADJ            0x00A00000
#define NV_094_FORMAT_BASE_SIZE_V_2048X2048_ADJ            0x00B00000
#define NV_094_FORMAT_TEXTUREADDRESSU_MSK                  0x07000000 /* 26:24 */ 
#define NV_094_FORMAT_TEXTUREADDRESSU_RMSK                 0x00000007 /* 26:24 */ 
#define NV_094_FORMAT_TEXTUREADDRESSU_WORD                 0
#define NV_094_FORMAT_TEXTUREADDRESSU_HIGH_FIELD           0x0000001A /* =26 */
#define NV_094_FORMAT_TEXTUREADDRESSU_LOW_FIELD            0x00000018 /* =24 */
#define NV_094_FORMAT_TEXTUREADDRESSU_WRAP_ADJ             0x01000000
#define NV_094_FORMAT_TEXTUREADDRESSU_MIRROR_ADJ           0x02000000
#define NV_094_FORMAT_TEXTUREADDRESSU_CLAMP_ADJ            0x03000000
#define NV_094_FORMAT_TEXTUREADDRESSU_BORDER_ADJ           0x04000000
#define NV_094_FORMAT_WRAPU_MSK                            0x08000000 /* 27:27 */ 
#define NV_094_FORMAT_WRAPU_RMSK                           0x00000001 /* 27:27 */ 
#define NV_094_FORMAT_WRAPU_WORD                           0
#define NV_094_FORMAT_WRAPU_HIGH_FIELD                     0x0000001B /* =27 */
#define NV_094_FORMAT_WRAPU_LOW_FIELD                      0x0000001B /* =27 */
#define NV_094_FORMAT_WRAPU_FALSE_ADJ                      0x00000000
#define NV_094_FORMAT_WRAPU_TRUE_ADJ                       0x08000000
#define NV_094_FORMAT_TEXTUREADDRESSV_MSK                  0x70000000 /* 30:28 */ 
#define NV_094_FORMAT_TEXTUREADDRESSV_RMSK                 0x00000007 /* 30:28 */ 
#define NV_094_FORMAT_TEXTUREADDRESSV_WORD                 0
#define NV_094_FORMAT_TEXTUREADDRESSV_HIGH_FIELD           0x0000001E /* =30 */
#define NV_094_FORMAT_TEXTUREADDRESSV_LOW_FIELD            0x0000001C /* =28 */
#define NV_094_FORMAT_TEXTUREADDRESSV_WRAP_ADJ             0x10000000
#define NV_094_FORMAT_TEXTUREADDRESSV_MIRROR_ADJ           0x20000000
#define NV_094_FORMAT_TEXTUREADDRESSV_CLAMP_ADJ            0x30000000
#define NV_094_FORMAT_TEXTUREADDRESSV_BORDER_ADJ           0x40000000
#define NV_094_FORMAT_WRAPV_MSK                            0x80000000 /* 31:31 */ 
#define NV_094_FORMAT_WRAPV_RMSK                           0x00000001 /* 31:31 */ 
#define NV_094_FORMAT_WRAPV_WORD                           0
#define NV_094_FORMAT_WRAPV_HIGH_FIELD                     0x0000001F /* =31 */
#define NV_094_FORMAT_WRAPV_LOW_FIELD                      0x0000001F /* =31 */
#define NV_094_FORMAT_WRAPV_FALSE_ADJ                      0x00000000
#define NV_094_FORMAT_WRAPV_TRUE_ADJ                       0x80000000
#define NV_094_FORMAT_MSK                                  0xFFFFFFFF 
#define NV_094_FILTER_KERNEL_SIZE_X_MSK                    0x000000FF /* 7:0 */ 
#define NV_094_FILTER_KERNEL_SIZE_X_RMSK                   0x000000FF /* 7:0 */ 
#define NV_094_FILTER_KERNEL_SIZE_X_WORD                   0
#define NV_094_FILTER_KERNEL_SIZE_X_HIGH_FIELD             0x00000007 /* =7 */
#define NV_094_FILTER_KERNEL_SIZE_X_LOW_FIELD              0x00000000 /* =0 */
#define NV_094_FILTER_KERNEL_SIZE_Y_MSK                    0x00007F00 /* 14:8 */ 
#define NV_094_FILTER_KERNEL_SIZE_Y_RMSK                   0x0000007F /* 14:8 */ 
#define NV_094_FILTER_KERNEL_SIZE_Y_WORD                   0
#define NV_094_FILTER_KERNEL_SIZE_Y_HIGH_FIELD             0x0000000E /* =14 */
#define NV_094_FILTER_KERNEL_SIZE_Y_LOW_FIELD              0x00000008 /* =8 */
#define NV_094_FILTER_MIPMAP_DITHER_ENABLE_MSK             0x00008000 /* 15:15 */ 
#define NV_094_FILTER_MIPMAP_DITHER_ENABLE_RMSK            0x00000001 /* 15:15 */ 
#define NV_094_FILTER_MIPMAP_DITHER_ENABLE_WORD            0
#define NV_094_FILTER_MIPMAP_DITHER_ENABLE_HIGH_FIELD      0x0000000F /* =15 */
#define NV_094_FILTER_MIPMAP_DITHER_ENABLE_LOW_FIELD       0x0000000F /* =15 */
#define NV_094_FILTER_MIPMAP_DITHER_ENABLE_FALSE_ADJ       0x00000000
#define NV_094_FILTER_MIPMAP_DITHER_ENABLE_TRUE_ADJ        0x00008000
#define NV_094_FILTER_MIPMAPLODBIAS_MSK                    0x00FF0000 /* 23:16 */ 
#define NV_094_FILTER_MIPMAPLODBIAS_RMSK                   0x000000FF /* 23:16 */ 
#define NV_094_FILTER_MIPMAPLODBIAS_WORD                   0
#define NV_094_FILTER_MIPMAPLODBIAS_HIGH_FIELD             0x00000017 /* =23 */
#define NV_094_FILTER_MIPMAPLODBIAS_LOW_FIELD              0x00000010 /* =16 */
#define NV_094_FILTER_TEXTUREMIN_MSK                       0x07000000 /* 26:24 */ 
#define NV_094_FILTER_TEXTUREMIN_RMSK                      0x00000007 /* 26:24 */ 
#define NV_094_FILTER_TEXTUREMIN_WORD                      0
#define NV_094_FILTER_TEXTUREMIN_HIGH_FIELD                0x0000001A /* =26 */
#define NV_094_FILTER_TEXTUREMIN_LOW_FIELD                 0x00000018 /* =24 */
#define NV_094_FILTER_TEXTUREMIN_NEAREST_ADJ               0x01000000
#define NV_094_FILTER_TEXTUREMIN_LINEAR_ADJ                0x02000000
#define NV_094_FILTER_TEXTUREMIN_MIPNEAREST_ADJ            0x03000000
#define NV_094_FILTER_TEXTUREMIN_MIPLINEAR_ADJ             0x04000000
#define NV_094_FILTER_TEXTUREMIN_LINEARMIPNEAREST_ADJ      0x05000000
#define NV_094_FILTER_TEXTUREMIN_LINEARMIPLINEAR_ADJ       0x06000000
#define NV_094_FILTER_ANISOTROPIC_MIN_ENABLE_MSK           0x08000000 /* 27:27 */ 
#define NV_094_FILTER_ANISOTROPIC_MIN_ENABLE_RMSK          0x00000001 /* 27:27 */ 
#define NV_094_FILTER_ANISOTROPIC_MIN_ENABLE_WORD          0
#define NV_094_FILTER_ANISOTROPIC_MIN_ENABLE_HIGH_FIELD    0x0000001B /* =27 */
#define NV_094_FILTER_ANISOTROPIC_MIN_ENABLE_LOW_FIELD     0x0000001B /* =27 */
#define NV_094_FILTER_ANISOTROPIC_MIN_ENABLE_FALSE_ADJ     0x00000000
#define NV_094_FILTER_ANISOTROPIC_MIN_ENABLE_TRUE_ADJ      0x08000000
#define NV_094_FILTER_TEXTUREMAG_MSK                       0x70000000 /* 30:28 */ 
#define NV_094_FILTER_TEXTUREMAG_RMSK                      0x00000007 /* 30:28 */ 
#define NV_094_FILTER_TEXTUREMAG_WORD                      0
#define NV_094_FILTER_TEXTUREMAG_HIGH_FIELD                0x0000001E /* =30 */
#define NV_094_FILTER_TEXTUREMAG_LOW_FIELD                 0x0000001C /* =28 */
#define NV_094_FILTER_TEXTUREMAG_NEAREST_ADJ               0x10000000
#define NV_094_FILTER_TEXTUREMAG_LINEAR_ADJ                0x20000000
#define NV_094_FILTER_TEXTUREMAG_MIPNEAREST_ADJ            0x30000000
#define NV_094_FILTER_TEXTUREMAG_MIPLINEAR_ADJ             0x40000000
#define NV_094_FILTER_TEXTUREMAG_LINEARMIPNEAREST_ADJ      0x50000000
#define NV_094_FILTER_TEXTUREMAG_LINEARMIPLINEAR_ADJ       0x60000000
#define NV_094_FILTER_ANISOTROPIC_MAG_ENABLE_MSK           0x80000000 /* 31:31 */ 
#define NV_094_FILTER_ANISOTROPIC_MAG_ENABLE_RMSK          0x00000001 /* 31:31 */ 
#define NV_094_FILTER_ANISOTROPIC_MAG_ENABLE_WORD          0
#define NV_094_FILTER_ANISOTROPIC_MAG_ENABLE_HIGH_FIELD    0x0000001F /* =31 */
#define NV_094_FILTER_ANISOTROPIC_MAG_ENABLE_LOW_FIELD     0x0000001F /* =31 */
#define NV_094_FILTER_ANISOTROPIC_MAG_ENABLE_FALSE_ADJ     0x00000000
#define NV_094_FILTER_ANISOTROPIC_MAG_ENABLE_TRUE_ADJ      0x80000000
#define NV_094_FILTER_MSK                                  0xFFFFFFFF 
#define NV_094_BLEND_TEXTUREMAPBLEND_MSK                   0x0000000F /* 3:0 */ 
#define NV_094_BLEND_TEXTUREMAPBLEND_RMSK                  0x0000000F /* 3:0 */ 
#define NV_094_BLEND_TEXTUREMAPBLEND_WORD                  0
#define NV_094_BLEND_TEXTUREMAPBLEND_HIGH_FIELD            0x00000003 /* =3 */
#define NV_094_BLEND_TEXTUREMAPBLEND_LOW_FIELD             0x00000000 /* =0 */
#define NV_094_BLEND_TEXTUREMAPBLEND_DECAL_ADJ             0x00000001
#define NV_094_BLEND_TEXTUREMAPBLEND_MODULATE_ADJ          0x00000002
#define NV_094_BLEND_TEXTUREMAPBLEND_DECALALPHA_ADJ        0x00000003
#define NV_094_BLEND_TEXTUREMAPBLEND_MODULATEALPHA_ADJ     0x00000004
#define NV_094_BLEND_TEXTUREMAPBLEND_DECALMASK_ADJ         0x00000005
#define NV_094_BLEND_TEXTUREMAPBLEND_MODULATEMASK_ADJ      0x00000006
#define NV_094_BLEND_TEXTUREMAPBLEND_COPY_ADJ              0x00000007
#define NV_094_BLEND_TEXTUREMAPBLEND_ADD_ADJ               0x00000008
#define NV_094_BLEND_OPERATION_MSK                         0x00000030 /* 5:4 */ 
#define NV_094_BLEND_OPERATION_RMSK                        0x00000003 /* 5:4 */ 
#define NV_094_BLEND_OPERATION_WORD                        0
#define NV_094_BLEND_OPERATION_HIGH_FIELD                  0x00000005 /* =5 */
#define NV_094_BLEND_OPERATION_LOW_FIELD                   0x00000004 /* =4 */
#define NV_094_BLEND_OPERATION_MUX_TALPHALSB_ADJ           0x00000010
#define NV_094_BLEND_OPERATION_MUX_TALPHAMSB_ADJ           0x00000020
#define NV_094_BLEND_SHADEMODE_MSK                         0x000000C0 /* 7:6 */ 
#define NV_094_BLEND_SHADEMODE_RMSK                        0x00000003 /* 7:6 */ 
#define NV_094_BLEND_SHADEMODE_WORD                        0
#define NV_094_BLEND_SHADEMODE_HIGH_FIELD                  0x00000007 /* =7 */
#define NV_094_BLEND_SHADEMODE_LOW_FIELD                   0x00000006 /* =6 */
#define NV_094_BLEND_SHADEMODE_FLAT_ADJ                    0x00000040
#define NV_094_BLEND_SHADEMODE_GOURAUD_ADJ                 0x00000080
#define NV_094_BLEND_SHADEMODE_PHONG_ADJ                   0x000000C0
#define NV_094_BLEND_TEXTUREPERSPECTIVE_MSK                0x00000F00 /* 11:8 */ 
#define NV_094_BLEND_TEXTUREPERSPECTIVE_RMSK               0x0000000F /* 11:8 */ 
#define NV_094_BLEND_TEXTUREPERSPECTIVE_WORD               0
#define NV_094_BLEND_TEXTUREPERSPECTIVE_HIGH_FIELD         0x0000000B /* =11 */
#define NV_094_BLEND_TEXTUREPERSPECTIVE_LOW_FIELD          0x00000008 /* =8 */
#define NV_094_BLEND_TEXTUREPERSPECTIVE_FALSE_ADJ          0x00000000
#define NV_094_BLEND_TEXTUREPERSPECTIVE_TRUE_ADJ           0x00000100
#define NV_094_BLEND_SPECULARENABLE_MSK                    0x0000F000 /* 15:12 */ 
#define NV_094_BLEND_SPECULARENABLE_RMSK                   0x0000000F /* 15:12 */ 
#define NV_094_BLEND_SPECULARENABLE_WORD                   0
#define NV_094_BLEND_SPECULARENABLE_HIGH_FIELD             0x0000000F /* =15 */
#define NV_094_BLEND_SPECULARENABLE_LOW_FIELD              0x0000000C /* =12 */
#define NV_094_BLEND_SPECULARENABLE_FALSE_ADJ              0x00000000
#define NV_094_BLEND_SPECULARENABLE_TRUE_ADJ               0x00001000
#define NV_094_BLEND_FOGENABLE_MSK                         0x000F0000 /* 19:16 */ 
#define NV_094_BLEND_FOGENABLE_RMSK                        0x0000000F /* 19:16 */ 
#define NV_094_BLEND_FOGENABLE_WORD                        0
#define NV_094_BLEND_FOGENABLE_HIGH_FIELD                  0x00000013 /* =19 */
#define NV_094_BLEND_FOGENABLE_LOW_FIELD                   0x00000010 /* =16 */
#define NV_094_BLEND_FOGENABLE_FALSE_ADJ                   0x00000000
#define NV_094_BLEND_FOGENABLE_TRUE_ADJ                    0x00010000
#define NV_094_BLEND_ALPHABLENDENABLE_MSK                  0x00F00000 /* 23:20 */ 
#define NV_094_BLEND_ALPHABLENDENABLE_RMSK                 0x0000000F /* 23:20 */ 
#define NV_094_BLEND_ALPHABLENDENABLE_WORD                 0
#define NV_094_BLEND_ALPHABLENDENABLE_HIGH_FIELD           0x00000017 /* =23 */
#define NV_094_BLEND_ALPHABLENDENABLE_LOW_FIELD            0x00000014 /* =20 */
#define NV_094_BLEND_ALPHABLENDENABLE_FALSE_ADJ            0x00000000
#define NV_094_BLEND_ALPHABLENDENABLE_TRUE_ADJ             0x00100000
#define NV_094_BLEND_SRCBLEND_MSK                          0x0F000000 /* 27:24 */ 
#define NV_094_BLEND_SRCBLEND_RMSK                         0x0000000F /* 27:24 */ 
#define NV_094_BLEND_SRCBLEND_WORD                         0
#define NV_094_BLEND_SRCBLEND_HIGH_FIELD                   0x0000001B /* =27 */
#define NV_094_BLEND_SRCBLEND_LOW_FIELD                    0x00000018 /* =24 */
#define NV_094_BLEND_SRCBLEND_ZERO_ADJ                     0x01000000
#define NV_094_BLEND_SRCBLEND_ONE_ADJ                      0x02000000
#define NV_094_BLEND_SRCBLEND_SRCCOLOR_ADJ                 0x03000000
#define NV_094_BLEND_SRCBLEND_INVSRCCOLOR_ADJ              0x04000000
#define NV_094_BLEND_SRCBLEND_SRCALPHA_ADJ                 0x05000000
#define NV_094_BLEND_SRCBLEND_INVSRCALPHA_ADJ              0x06000000
#define NV_094_BLEND_SRCBLEND_DESTALPHA_ADJ                0x07000000
#define NV_094_BLEND_SRCBLEND_INVDESTALPHA_ADJ             0x08000000
#define NV_094_BLEND_SRCBLEND_DESTCOLOR_ADJ                0x09000000
#define NV_094_BLEND_SRCBLEND_INVDESTCOLOR_ADJ             0x0A000000
#define NV_094_BLEND_SRCBLEND_SRCALPHASAT_ADJ              0x0B000000
#define NV_094_BLEND_DESTBLEND_MSK                         0xF0000000 /* 31:28 */ 
#define NV_094_BLEND_DESTBLEND_RMSK                        0x0000000F /* 31:28 */ 
#define NV_094_BLEND_DESTBLEND_WORD                        0
#define NV_094_BLEND_DESTBLEND_HIGH_FIELD                  0x0000001F /* =31 */
#define NV_094_BLEND_DESTBLEND_LOW_FIELD                   0x0000001C /* =28 */
#define NV_094_BLEND_DESTBLEND_ZERO_ADJ                    0x10000000
#define NV_094_BLEND_DESTBLEND_ONE_ADJ                     0x20000000
#define NV_094_BLEND_DESTBLEND_SRCCOLOR_ADJ                0x30000000
#define NV_094_BLEND_DESTBLEND_INVSRCCOLOR_ADJ             0x40000000
#define NV_094_BLEND_DESTBLEND_SRCALPHA_ADJ                0x50000000
#define NV_094_BLEND_DESTBLEND_INVSRCALPHA_ADJ             0x60000000
#define NV_094_BLEND_DESTBLEND_DESTALPHA_ADJ               0x70000000
#define NV_094_BLEND_DESTBLEND_INVDESTALPHA_ADJ            0x80000000
#define NV_094_BLEND_DESTBLEND_DESTCOLOR_ADJ               0x90000000
#define NV_094_BLEND_DESTBLEND_INVDESTCOLOR_ADJ            0xA0000000
#define NV_094_BLEND_DESTBLEND_SRCALPHASAT_ADJ             0xB0000000
#define NV_094_BLEND_MSK                                   0xFFFFFFFF 
#define NV_094_CONTROL_ALPHAREF_MSK                        0x000000FF /* 7:0 */ 
#define NV_094_CONTROL_ALPHAREF_RMSK                       0x000000FF /* 7:0 */ 
#define NV_094_CONTROL_ALPHAREF_WORD                       0
#define NV_094_CONTROL_ALPHAREF_HIGH_FIELD                 0x00000007 /* =7 */
#define NV_094_CONTROL_ALPHAREF_LOW_FIELD                  0x00000000 /* =0 */
#define NV_094_CONTROL_ALPHAFUNC_MSK                       0x00000F00 /* 11:8 */ 
#define NV_094_CONTROL_ALPHAFUNC_RMSK                      0x0000000F /* 11:8 */ 
#define NV_094_CONTROL_ALPHAFUNC_WORD                      0
#define NV_094_CONTROL_ALPHAFUNC_HIGH_FIELD                0x0000000B /* =11 */
#define NV_094_CONTROL_ALPHAFUNC_LOW_FIELD                 0x00000008 /* =8 */
#define NV_094_CONTROL_ALPHAFUNC_NEVER_ADJ                 0x00000100
#define NV_094_CONTROL_ALPHAFUNC_LESS_ADJ                  0x00000200
#define NV_094_CONTROL_ALPHAFUNC_EQUAL_ADJ                 0x00000300
#define NV_094_CONTROL_ALPHAFUNC_LESSEQUAL_ADJ             0x00000400
#define NV_094_CONTROL_ALPHAFUNC_GREATER_ADJ               0x00000500
#define NV_094_CONTROL_ALPHAFUNC_NOTEQUAL_ADJ              0x00000600
#define NV_094_CONTROL_ALPHAFUNC_GREATEREQUAL_ADJ          0x00000700
#define NV_094_CONTROL_ALPHAFUNC_ALWAYS_ADJ                0x00000800
#define NV_094_CONTROL_ALPHATESTENABLE_MSK                 0x00001000 /* 12:12 */ 
#define NV_094_CONTROL_ALPHATESTENABLE_RMSK                0x00000001 /* 12:12 */ 
#define NV_094_CONTROL_ALPHATESTENABLE_WORD                0
#define NV_094_CONTROL_ALPHATESTENABLE_HIGH_FIELD          0x0000000C /* =12 */
#define NV_094_CONTROL_ALPHATESTENABLE_LOW_FIELD           0x0000000C /* =12 */
#define NV_094_CONTROL_ALPHATESTENABLE_FALSE_ADJ           0x00000000
#define NV_094_CONTROL_ALPHATESTENABLE_TRUE_ADJ            0x00001000
#define NV_094_CONTROL_ORIGIN_MSK                          0x00002000 /* 13:13 */ 
#define NV_094_CONTROL_ORIGIN_RMSK                         0x00000001 /* 13:13 */ 
#define NV_094_CONTROL_ORIGIN_WORD                         0
#define NV_094_CONTROL_ORIGIN_HIGH_FIELD                   0x0000000D /* =13 */
#define NV_094_CONTROL_ORIGIN_LOW_FIELD                    0x0000000D /* =13 */
#define NV_094_CONTROL_ORIGIN_CENTER_ADJ                   0x00000000
#define NV_094_CONTROL_ORIGIN_CORNER_ADJ                   0x00002000
#define NV_094_CONTROL_ZENABLE_MSK                         0x0000C000 /* 15:14 */ 
#define NV_094_CONTROL_ZENABLE_RMSK                        0x00000003 /* 15:14 */ 
#define NV_094_CONTROL_ZENABLE_WORD                        0
#define NV_094_CONTROL_ZENABLE_HIGH_FIELD                  0x0000000F /* =15 */
#define NV_094_CONTROL_ZENABLE_LOW_FIELD                   0x0000000E /* =14 */
#define NV_094_CONTROL_ZENABLE_FALSE_ADJ                   0x00000000
#define NV_094_CONTROL_ZENABLE_TRUE_ADJ                    0x00004000
#define NV_094_CONTROL_ZFUNC_MSK                           0x000F0000 /* 19:16 */ 
#define NV_094_CONTROL_ZFUNC_RMSK                          0x0000000F /* 19:16 */ 
#define NV_094_CONTROL_ZFUNC_WORD                          0
#define NV_094_CONTROL_ZFUNC_HIGH_FIELD                    0x00000013 /* =19 */
#define NV_094_CONTROL_ZFUNC_LOW_FIELD                     0x00000010 /* =16 */
#define NV_094_CONTROL_ZFUNC_NEVER_ADJ                     0x00010000
#define NV_094_CONTROL_ZFUNC_LESS_ADJ                      0x00020000
#define NV_094_CONTROL_ZFUNC_EQUAL_ADJ                     0x00030000
#define NV_094_CONTROL_ZFUNC_LESSEQUAL_ADJ                 0x00040000
#define NV_094_CONTROL_ZFUNC_GREATER_ADJ                   0x00050000
#define NV_094_CONTROL_ZFUNC_NOTEQUAL_ADJ                  0x00060000
#define NV_094_CONTROL_ZFUNC_GREATEREQUAL_ADJ              0x00070000
#define NV_094_CONTROL_ZFUNC_ALWAYS_ADJ                    0x00080000
#define NV_094_CONTROL_CULLMODE_MSK                        0x00300000 /* 21:20 */ 
#define NV_094_CONTROL_CULLMODE_RMSK                       0x00000003 /* 21:20 */ 
#define NV_094_CONTROL_CULLMODE_WORD                       0
#define NV_094_CONTROL_CULLMODE_HIGH_FIELD                 0x00000015 /* =21 */
#define NV_094_CONTROL_CULLMODE_LOW_FIELD                  0x00000014 /* =20 */
#define NV_094_CONTROL_CULLMODE_NONE_ADJ                   0x00100000
#define NV_094_CONTROL_CULLMODE_CW_ADJ                     0x00200000
#define NV_094_CONTROL_CULLMODE_CCW_ADJ                    0x00300000
#define NV_094_CONTROL_DITHERENABLE_MSK                    0x00400000 /* 22:22 */ 
#define NV_094_CONTROL_DITHERENABLE_RMSK                   0x00000001 /* 22:22 */ 
#define NV_094_CONTROL_DITHERENABLE_WORD                   0
#define NV_094_CONTROL_DITHERENABLE_HIGH_FIELD             0x00000016 /* =22 */
#define NV_094_CONTROL_DITHERENABLE_LOW_FIELD              0x00000016 /* =22 */
#define NV_094_CONTROL_DITHERENABLE_FALSE_ADJ              0x00000000
#define NV_094_CONTROL_DITHERENABLE_TRUE_ADJ               0x00400000
#define NV_094_CONTROL_Z_PERSPECTIVE_ENABLE_MSK            0x00800000 /* 23:23 */ 
#define NV_094_CONTROL_Z_PERSPECTIVE_ENABLE_RMSK           0x00000001 /* 23:23 */ 
#define NV_094_CONTROL_Z_PERSPECTIVE_ENABLE_WORD           0
#define NV_094_CONTROL_Z_PERSPECTIVE_ENABLE_HIGH_FIELD     0x00000017 /* =23 */
#define NV_094_CONTROL_Z_PERSPECTIVE_ENABLE_LOW_FIELD      0x00000017 /* =23 */
#define NV_094_CONTROL_Z_PERSPECTIVE_ENABLE_FALSE_ADJ      0x00000000
#define NV_094_CONTROL_Z_PERSPECTIVE_ENABLE_TRUE_ADJ       0x00800000
#define NV_094_CONTROL_ZWRITEENABLE_MSK                    0x3F000000 /* 29:24 */ 
#define NV_094_CONTROL_ZWRITEENABLE_RMSK                   0x0000003F /* 29:24 */ 
#define NV_094_CONTROL_ZWRITEENABLE_WORD                   0
#define NV_094_CONTROL_ZWRITEENABLE_HIGH_FIELD             0x0000001D /* =29 */
#define NV_094_CONTROL_ZWRITEENABLE_LOW_FIELD              0x00000018 /* =24 */
#define NV_094_CONTROL_ZWRITEENABLE_FALSE_ADJ              0x00000000
#define NV_094_CONTROL_ZWRITEENABLE_TRUE_ADJ               0x01000000
#define NV_094_CONTROL_Z_FORMAT_MSK                        0xC0000000 /* 31:30 */ 
#define NV_094_CONTROL_Z_FORMAT_RMSK                       0x00000003 /* 31:30 */ 
#define NV_094_CONTROL_Z_FORMAT_WORD                       0
#define NV_094_CONTROL_Z_FORMAT_HIGH_FIELD                 0x0000001F /* =31 */
#define NV_094_CONTROL_Z_FORMAT_LOW_FIELD                  0x0000001E /* =30 */
#define NV_094_CONTROL_Z_FORMAT_FIXED_ADJ                  0x40000000
#define NV_094_CONTROL_Z_FORMAT_FLOAT_ADJ                  0x80000000
#define NV_094_CONTROL_MSK                                 0xFFFFFFFF 
#define NV_094_FOGCOLOR_VALUE_MSK                          0xFFFFFFFF /* 31:0 */ 
#define NV_094_FOGCOLOR_VALUE_RMSK                         0xFFFFFFFF /* 31:0 */ 
#define NV_094_FOGCOLOR_VALUE_WORD                         0
#define NV_094_FOGCOLOR_VALUE_HIGH_FIELD                   0x0000001F /* =31 */
#define NV_094_FOGCOLOR_VALUE_LOW_FIELD                    0x00000000 /* =0 */
#define NV_094_FOGCOLOR_MSK                                0xFFFFFFFF 
#define NV_094_TLVERTEX_SX_VALUE_MSK                       0xFFFFFFFF /* 31:0 */ 
#define NV_094_TLVERTEX_SX_VALUE_RMSK                      0xFFFFFFFF /* 31:0 */ 
#define NV_094_TLVERTEX_SX_VALUE_WORD                      0
#define NV_094_TLVERTEX_SX_VALUE_HIGH_FIELD                0x0000001F /* =31 */
#define NV_094_TLVERTEX_SX_VALUE_LOW_FIELD                 0x00000000 /* =0 */
#define NV_094_TLVERTEX_SX_MSK                             0xFFFFFFFF 
#define NV_094_TLVERTEX_SY_VALUE_MSK                       0xFFFFFFFF /* 31:0 */ 
#define NV_094_TLVERTEX_SY_VALUE_RMSK                      0xFFFFFFFF /* 31:0 */ 
#define NV_094_TLVERTEX_SY_VALUE_WORD                      0
#define NV_094_TLVERTEX_SY_VALUE_HIGH_FIELD                0x0000001F /* =31 */
#define NV_094_TLVERTEX_SY_VALUE_LOW_FIELD                 0x00000000 /* =0 */
#define NV_094_TLVERTEX_SY_MSK                             0xFFFFFFFF 
#define NV_094_TLVERTEX_SZ_VALUE_MSK                       0xFFFFFFFF /* 31:0 */ 
#define NV_094_TLVERTEX_SZ_VALUE_RMSK                      0xFFFFFFFF /* 31:0 */ 
#define NV_094_TLVERTEX_SZ_VALUE_WORD                      0
#define NV_094_TLVERTEX_SZ_VALUE_HIGH_FIELD                0x0000001F /* =31 */
#define NV_094_TLVERTEX_SZ_VALUE_LOW_FIELD                 0x00000000 /* =0 */
#define NV_094_TLVERTEX_SZ_MSK                             0xFFFFFFFF 
#define NV_094_TLVERTEX_RHW_VALUE_MSK                      0xFFFFFFFF /* 31:0 */ 
#define NV_094_TLVERTEX_RHW_VALUE_RMSK                     0xFFFFFFFF /* 31:0 */ 
#define NV_094_TLVERTEX_RHW_VALUE_WORD                     0
#define NV_094_TLVERTEX_RHW_VALUE_HIGH_FIELD               0x0000001F /* =31 */
#define NV_094_TLVERTEX_RHW_VALUE_LOW_FIELD                0x00000000 /* =0 */
#define NV_094_TLVERTEX_RHW_MSK                            0xFFFFFFFF 
#define NV_094_TLVERTEX_COLOR_VALUE_MSK                    0xFFFFFFFF /* 31:0 */ 
#define NV_094_TLVERTEX_COLOR_VALUE_RMSK                   0xFFFFFFFF /* 31:0 */ 
#define NV_094_TLVERTEX_COLOR_VALUE_WORD                   0
#define NV_094_TLVERTEX_COLOR_VALUE_HIGH_FIELD             0x0000001F /* =31 */
#define NV_094_TLVERTEX_COLOR_VALUE_LOW_FIELD              0x00000000 /* =0 */
#define NV_094_TLVERTEX_COLOR_BLUE_MSK                     0x000000FF /* 7:0 */ 
#define NV_094_TLVERTEX_COLOR_BLUE_RMSK                    0x000000FF /* 7:0 */ 
#define NV_094_TLVERTEX_COLOR_BLUE_WORD                    0
#define NV_094_TLVERTEX_COLOR_BLUE_HIGH_FIELD              0x00000007 /* =7 */
#define NV_094_TLVERTEX_COLOR_BLUE_LOW_FIELD               0x00000000 /* =0 */
#define NV_094_TLVERTEX_COLOR_GREEN_MSK                    0x0000FF00 /* 15:8 */ 
#define NV_094_TLVERTEX_COLOR_GREEN_RMSK                   0x000000FF /* 15:8 */ 
#define NV_094_TLVERTEX_COLOR_GREEN_WORD                   0
#define NV_094_TLVERTEX_COLOR_GREEN_HIGH_FIELD             0x0000000F /* =15 */
#define NV_094_TLVERTEX_COLOR_GREEN_LOW_FIELD              0x00000008 /* =8 */
#define NV_094_TLVERTEX_COLOR_RED_MSK                      0x00FF0000 /* 23:16 */ 
#define NV_094_TLVERTEX_COLOR_RED_RMSK                     0x000000FF /* 23:16 */ 
#define NV_094_TLVERTEX_COLOR_RED_WORD                     0
#define NV_094_TLVERTEX_COLOR_RED_HIGH_FIELD               0x00000017 /* =23 */
#define NV_094_TLVERTEX_COLOR_RED_LOW_FIELD                0x00000010 /* =16 */
#define NV_094_TLVERTEX_COLOR_ALPHA_MSK                    0xFF000000 /* 31:24 */ 
#define NV_094_TLVERTEX_COLOR_ALPHA_RMSK                   0x000000FF /* 31:24 */ 
#define NV_094_TLVERTEX_COLOR_ALPHA_WORD                   0
#define NV_094_TLVERTEX_COLOR_ALPHA_HIGH_FIELD             0x0000001F /* =31 */
#define NV_094_TLVERTEX_COLOR_ALPHA_LOW_FIELD              0x00000018 /* =24 */
#define NV_094_TLVERTEX_COLOR_MSK                          0xFFFFFFFF 
#define NV_094_TLVERTEX_SPECULAR_VALUE_MSK                 0xFFFFFFFF /* 31:0 */ 
#define NV_094_TLVERTEX_SPECULAR_VALUE_RMSK                0xFFFFFFFF /* 31:0 */ 
#define NV_094_TLVERTEX_SPECULAR_VALUE_WORD                0
#define NV_094_TLVERTEX_SPECULAR_VALUE_HIGH_FIELD          0x0000001F /* =31 */
#define NV_094_TLVERTEX_SPECULAR_VALUE_LOW_FIELD           0x00000000 /* =0 */
#define NV_094_TLVERTEX_SPECULAR_BLUE_MSK                  0x000000FF /* 7:0 */ 
#define NV_094_TLVERTEX_SPECULAR_BLUE_RMSK                 0x000000FF /* 7:0 */ 
#define NV_094_TLVERTEX_SPECULAR_BLUE_WORD                 0
#define NV_094_TLVERTEX_SPECULAR_BLUE_HIGH_FIELD           0x00000007 /* =7 */
#define NV_094_TLVERTEX_SPECULAR_BLUE_LOW_FIELD            0x00000000 /* =0 */
#define NV_094_TLVERTEX_SPECULAR_GREEN_MSK                 0x0000FF00 /* 15:8 */ 
#define NV_094_TLVERTEX_SPECULAR_GREEN_RMSK                0x000000FF /* 15:8 */ 
#define NV_094_TLVERTEX_SPECULAR_GREEN_WORD                0
#define NV_094_TLVERTEX_SPECULAR_GREEN_HIGH_FIELD          0x0000000F /* =15 */
#define NV_094_TLVERTEX_SPECULAR_GREEN_LOW_FIELD           0x00000008 /* =8 */
#define NV_094_TLVERTEX_SPECULAR_RED_MSK                   0x00FF0000 /* 23:16 */ 
#define NV_094_TLVERTEX_SPECULAR_RED_RMSK                  0x000000FF /* 23:16 */ 
#define NV_094_TLVERTEX_SPECULAR_RED_WORD                  0
#define NV_094_TLVERTEX_SPECULAR_RED_HIGH_FIELD            0x00000017 /* =23 */
#define NV_094_TLVERTEX_SPECULAR_RED_LOW_FIELD             0x00000010 /* =16 */
#define NV_094_TLVERTEX_SPECULAR_FOG_MSK                   0xFF000000 /* 31:24 */ 
#define NV_094_TLVERTEX_SPECULAR_FOG_RMSK                  0x000000FF /* 31:24 */ 
#define NV_094_TLVERTEX_SPECULAR_FOG_WORD                  0
#define NV_094_TLVERTEX_SPECULAR_FOG_HIGH_FIELD            0x0000001F /* =31 */
#define NV_094_TLVERTEX_SPECULAR_FOG_LOW_FIELD             0x00000018 /* =24 */
#define NV_094_TLVERTEX_SPECULAR_MSK                       0xFFFFFFFF 
#define NV_094_TLVERTEX_TU_VALUE_MSK                       0xFFFFFFFF /* 31:0 */ 
#define NV_094_TLVERTEX_TU_VALUE_RMSK                      0xFFFFFFFF /* 31:0 */ 
#define NV_094_TLVERTEX_TU_VALUE_WORD                      0
#define NV_094_TLVERTEX_TU_VALUE_HIGH_FIELD                0x0000001F /* =31 */
#define NV_094_TLVERTEX_TU_VALUE_LOW_FIELD                 0x00000000 /* =0 */
#define NV_094_TLVERTEX_TU_MSK                             0xFFFFFFFF 
#define NV_094_TLVERTEX_TV_VALUE_MSK                       0xFFFFFFFF /* 31:0 */ 
#define NV_094_TLVERTEX_TV_VALUE_RMSK                      0xFFFFFFFF /* 31:0 */ 
#define NV_094_TLVERTEX_TV_VALUE_WORD                      0
#define NV_094_TLVERTEX_TV_VALUE_HIGH_FIELD                0x0000001F /* =31 */
#define NV_094_TLVERTEX_TV_VALUE_LOW_FIELD                 0x00000000 /* =0 */
#define NV_094_TLVERTEX_TV_MSK                             0xFFFFFFFF 
#define NV_094_TLVERTEX_DRAWPRIMITIVE_I0_MSK               0x0000000F /* 3:0 */ 
#define NV_094_TLVERTEX_DRAWPRIMITIVE_I0_RMSK              0x0000000F /* 3:0 */ 
#define NV_094_TLVERTEX_DRAWPRIMITIVE_I0_WORD              0
#define NV_094_TLVERTEX_DRAWPRIMITIVE_I0_HIGH_FIELD        0x00000003 /* =3 */
#define NV_094_TLVERTEX_DRAWPRIMITIVE_I0_LOW_FIELD         0x00000000 /* =0 */
#define NV_094_TLVERTEX_DRAWPRIMITIVE_I1_MSK               0x000000F0 /* 7:4 */ 
#define NV_094_TLVERTEX_DRAWPRIMITIVE_I1_RMSK              0x0000000F /* 7:4 */ 
#define NV_094_TLVERTEX_DRAWPRIMITIVE_I1_WORD              0
#define NV_094_TLVERTEX_DRAWPRIMITIVE_I1_HIGH_FIELD        0x00000007 /* =7 */
#define NV_094_TLVERTEX_DRAWPRIMITIVE_I1_LOW_FIELD         0x00000004 /* =4 */
#define NV_094_TLVERTEX_DRAWPRIMITIVE_I2_MSK               0x00000F00 /* 11:8 */ 
#define NV_094_TLVERTEX_DRAWPRIMITIVE_I2_RMSK              0x0000000F /* 11:8 */ 
#define NV_094_TLVERTEX_DRAWPRIMITIVE_I2_WORD              0
#define NV_094_TLVERTEX_DRAWPRIMITIVE_I2_HIGH_FIELD        0x0000000B /* =11 */
#define NV_094_TLVERTEX_DRAWPRIMITIVE_I2_LOW_FIELD         0x00000008 /* =8 */
#define NV_094_TLVERTEX_DRAWPRIMITIVE_I3_MSK               0x0000F000 /* 15:12 */ 
#define NV_094_TLVERTEX_DRAWPRIMITIVE_I3_RMSK              0x0000000F /* 15:12 */ 
#define NV_094_TLVERTEX_DRAWPRIMITIVE_I3_WORD              0
#define NV_094_TLVERTEX_DRAWPRIMITIVE_I3_HIGH_FIELD        0x0000000F /* =15 */
#define NV_094_TLVERTEX_DRAWPRIMITIVE_I3_LOW_FIELD         0x0000000C /* =12 */
#define NV_094_TLVERTEX_DRAWPRIMITIVE_I4_MSK               0x000F0000 /* 19:16 */ 
#define NV_094_TLVERTEX_DRAWPRIMITIVE_I4_RMSK              0x0000000F /* 19:16 */ 
#define NV_094_TLVERTEX_DRAWPRIMITIVE_I4_WORD              0
#define NV_094_TLVERTEX_DRAWPRIMITIVE_I4_HIGH_FIELD        0x00000013 /* =19 */
#define NV_094_TLVERTEX_DRAWPRIMITIVE_I4_LOW_FIELD         0x00000010 /* =16 */
#define NV_094_TLVERTEX_DRAWPRIMITIVE_I5_MSK               0xFFF00000 /* 31:20 */ 
#define NV_094_TLVERTEX_DRAWPRIMITIVE_I5_RMSK              0x00000FFF /* 31:20 */ 
#define NV_094_TLVERTEX_DRAWPRIMITIVE_I5_WORD              0
#define NV_094_TLVERTEX_DRAWPRIMITIVE_I5_HIGH_FIELD        0x0000001F /* =31 */
#define NV_094_TLVERTEX_DRAWPRIMITIVE_I5_LOW_FIELD         0x00000014 /* =20 */
#define NV_094_TLVERTEX_DRAWPRIMITIVE_MSK                  0xFFFFFFFF 
#define NV_095_HIGH_FIELD                                  0x005A1FFF /* =5906431 */
#define NV_095_LOW_FIELD                                   0x005A0000 /* =5898240 */
#define NV_095_NV10_DX6_MULTI_TEXTURE_TRIANGLE_ADJ         0x005A0000
#define NV_095_NV10_DX6_MULTI_TEXTURE_TRIANGLE_HANDLE_MSK  0xFFFFFFFF /* 31:0 */ 
#define NV_095_NV10_DX6_MULTI_TEXTURE_TRIANGLE_HANDLE_RMSK 0xFFFFFFFF /* 31:0 */ 
#define NV_095_NV10_DX6_MULTI_TEXTURE_TRIANGLE_HANDLE_WORD 0
#define NV_095_NV10_DX6_MULTI_TEXTURE_TRIANGLE_HANDLE_HIGH_FIELD 0x0000001F /* =31 */
#define NV_095_NV10_DX6_MULTI_TEXTURE_TRIANGLE_HANDLE_LOW_FIELD 0x00000000 /* =0 */
#define NV_095_NV10_DX6_MULTI_TEXTURE_TRIANGLE_MSK         0xFFFFFFFF 
#define NV_095_NOP_PARAMETER_MSK                           0xFFFFFFFF /* 31:0 */ 
#define NV_095_NOP_PARAMETER_RMSK                          0xFFFFFFFF /* 31:0 */ 
#define NV_095_NOP_PARAMETER_WORD                          0
#define NV_095_NOP_PARAMETER_HIGH_FIELD                    0x0000001F /* =31 */
#define NV_095_NOP_PARAMETER_LOW_FIELD                     0x00000000 /* =0 */
#define NV_095_NOP_MSK                                     0xFFFFFFFF 
#define NV_095_NOTIFY_STYLE_MSK                            0xFFFFFFFF /* 31:0 */ 
#define NV_095_NOTIFY_STYLE_RMSK                           0xFFFFFFFF /* 31:0 */ 
#define NV_095_NOTIFY_STYLE_WORD                           0
#define NV_095_NOTIFY_STYLE_HIGH_FIELD                     0x0000001F /* =31 */
#define NV_095_NOTIFY_STYLE_LOW_FIELD                      0x00000000 /* =0 */
#define NV_095_NOTIFY_STYLE_WRITE_ONLY_ADJ                 0x00000000
#define NV_095_NOTIFY_STYLE_WRITE_THEN_AWAKEN_ADJ          0x00000001
#define NV_095_NOTIFY_MSK                                  0xFFFFFFFF 
#define NV_095_SET_CONTEXT_DMA_NOTIFY_PARAMETER_MSK        0xFFFFFFFF /* 31:0 */ 
#define NV_095_SET_CONTEXT_DMA_NOTIFY_PARAMETER_RMSK       0xFFFFFFFF /* 31:0 */ 
#define NV_095_SET_CONTEXT_DMA_NOTIFY_PARAMETER_WORD       0
#define NV_095_SET_CONTEXT_DMA_NOTIFY_PARAMETER_HIGH_FIELD 0x0000001F /* =31 */
#define NV_095_SET_CONTEXT_DMA_NOTIFY_PARAMETER_LOW_FIELD  0x00000000 /* =0 */
#define NV_095_SET_CONTEXT_DMA_NOTIFY_MSK                  0xFFFFFFFF 
#define NV_095_SET_CONTEXT_DMA_A_PARAMETER_MSK             0xFFFFFFFF /* 31:0 */ 
#define NV_095_SET_CONTEXT_DMA_A_PARAMETER_RMSK            0xFFFFFFFF /* 31:0 */ 
#define NV_095_SET_CONTEXT_DMA_A_PARAMETER_WORD            0
#define NV_095_SET_CONTEXT_DMA_A_PARAMETER_HIGH_FIELD      0x0000001F /* =31 */
#define NV_095_SET_CONTEXT_DMA_A_PARAMETER_LOW_FIELD       0x00000000 /* =0 */
#define NV_095_SET_CONTEXT_DMA_A_MSK                       0xFFFFFFFF 
#define NV_095_SET_CONTEXT_DMA_B_PARAMETER_MSK             0xFFFFFFFF /* 31:0 */ 
#define NV_095_SET_CONTEXT_DMA_B_PARAMETER_RMSK            0xFFFFFFFF /* 31:0 */ 
#define NV_095_SET_CONTEXT_DMA_B_PARAMETER_WORD            0
#define NV_095_SET_CONTEXT_DMA_B_PARAMETER_HIGH_FIELD      0x0000001F /* =31 */
#define NV_095_SET_CONTEXT_DMA_B_PARAMETER_LOW_FIELD       0x00000000 /* =0 */
#define NV_095_SET_CONTEXT_DMA_B_MSK                       0xFFFFFFFF 
#define NV_095_SET_CONTEXT_SURFACES_PARAMETER_MSK          0xFFFFFFFF /* 31:0 */ 
#define NV_095_SET_CONTEXT_SURFACES_PARAMETER_RMSK         0xFFFFFFFF /* 31:0 */ 
#define NV_095_SET_CONTEXT_SURFACES_PARAMETER_WORD         0
#define NV_095_SET_CONTEXT_SURFACES_PARAMETER_HIGH_FIELD   0x0000001F /* =31 */
#define NV_095_SET_CONTEXT_SURFACES_PARAMETER_LOW_FIELD    0x00000000 /* =0 */
#define NV_095_SET_CONTEXT_SURFACES_MSK                    0xFFFFFFFF 
#define NV_095_OFFSET_VALUE_MSK                            0xFFFFFFFF /* 31:0 */ 
#define NV_095_OFFSET_VALUE_RMSK                           0xFFFFFFFF /* 31:0 */ 
#define NV_095_OFFSET_VALUE_WORD                           0
#define NV_095_OFFSET_VALUE_HIGH_FIELD                     0x0000001F /* =31 */
#define NV_095_OFFSET_VALUE_LOW_FIELD                      0x00000000 /* =0 */
#define NV_095_OFFSET_MSK                                  0xFFFFFFFF 
#define NV_095_FORMAT_CONTEXT_DMA_MSK                      0x0000000F /* 3:0 */ 
#define NV_095_FORMAT_CONTEXT_DMA_RMSK                     0x0000000F /* 3:0 */ 
#define NV_095_FORMAT_CONTEXT_DMA_WORD                     0
#define NV_095_FORMAT_CONTEXT_DMA_HIGH_FIELD               0x00000003 /* =3 */
#define NV_095_FORMAT_CONTEXT_DMA_LOW_FIELD                0x00000000 /* =0 */
#define NV_095_FORMAT_CONTEXT_DMA_A_ADJ                    0x00000001
#define NV_095_FORMAT_CONTEXT_DMA_B_ADJ                    0x00000002
#define NV_095_FORMAT_ORIGIN_ZOH_MSK                       0x00000030 /* 5:4 */ 
#define NV_095_FORMAT_ORIGIN_ZOH_RMSK                      0x00000003 /* 5:4 */ 
#define NV_095_FORMAT_ORIGIN_ZOH_WORD                      0
#define NV_095_FORMAT_ORIGIN_ZOH_HIGH_FIELD                0x00000005 /* =5 */
#define NV_095_FORMAT_ORIGIN_ZOH_LOW_FIELD                 0x00000004 /* =4 */
#define NV_095_FORMAT_ORIGIN_ZOH_CENTER_ADJ                0x00000010
#define NV_095_FORMAT_ORIGIN_ZOH_CORNER_ADJ                0x00000020
#define NV_095_FORMAT_ORIGIN_FOH_MSK                       0x000000C0 /* 7:6 */ 
#define NV_095_FORMAT_ORIGIN_FOH_RMSK                      0x00000003 /* 7:6 */ 
#define NV_095_FORMAT_ORIGIN_FOH_WORD                      0
#define NV_095_FORMAT_ORIGIN_FOH_HIGH_FIELD                0x00000007 /* =7 */
#define NV_095_FORMAT_ORIGIN_FOH_LOW_FIELD                 0x00000006 /* =6 */
#define NV_095_FORMAT_ORIGIN_FOH_CENTER_ADJ                0x00000040
#define NV_095_FORMAT_ORIGIN_FOH_CORNER_ADJ                0x00000080
#define NV_095_FORMAT_COLOR_MSK                            0x00000F00 /* 11:8 */ 
#define NV_095_FORMAT_COLOR_RMSK                           0x0000000F /* 11:8 */ 
#define NV_095_FORMAT_COLOR_WORD                           0
#define NV_095_FORMAT_COLOR_HIGH_FIELD                     0x0000000B /* =11 */
#define NV_095_FORMAT_COLOR_LOW_FIELD                      0x00000008 /* =8 */
#define NV_095_FORMAT_COLOR_LE_AY8_ADJ                     0x00000100
#define NV_095_FORMAT_COLOR_LE_A1R5G5B5_ADJ                0x00000200
#define NV_095_FORMAT_COLOR_LE_X1R5G5B5_ADJ                0x00000300
#define NV_095_FORMAT_COLOR_LE_A4R4G4G4_ADJ                0x00000400
#define NV_095_FORMAT_COLOR_LE_R5G6B5_ADJ                  0x00000500
#define NV_095_FORMAT_COLOR_LE_A8R8G8B8_ADJ                0x00000600
#define NV_095_FORMAT_COLOR_LE_X8R8G8B8_ADJ                0x00000700
#define NV_095_FORMAT_MIPMAP_LEVELS_MSK                    0x0000F000 /* 15:12 */ 
#define NV_095_FORMAT_MIPMAP_LEVELS_RMSK                   0x0000000F /* 15:12 */ 
#define NV_095_FORMAT_MIPMAP_LEVELS_WORD                   0
#define NV_095_FORMAT_MIPMAP_LEVELS_HIGH_FIELD             0x0000000F /* =15 */
#define NV_095_FORMAT_MIPMAP_LEVELS_LOW_FIELD              0x0000000C /* =12 */
#define NV_095_FORMAT_MIPMAP_LEVELS_1_ADJ                  0x00001000
#define NV_095_FORMAT_MIPMAP_LEVELS_2_ADJ                  0x00002000
#define NV_095_FORMAT_MIPMAP_LEVELS_3_ADJ                  0x00003000
#define NV_095_FORMAT_MIPMAP_LEVELS_4_ADJ                  0x00004000
#define NV_095_FORMAT_MIPMAP_LEVELS_5_ADJ                  0x00005000
#define NV_095_FORMAT_MIPMAP_LEVELS_6_ADJ                  0x00006000
#define NV_095_FORMAT_MIPMAP_LEVELS_7_ADJ                  0x00007000
#define NV_095_FORMAT_MIPMAP_LEVELS_8_ADJ                  0x00008000
#define NV_095_FORMAT_MIPMAP_LEVELS_9_ADJ                  0x00009000
#define NV_095_FORMAT_MIPMAP_LEVELS_10_ADJ                 0x0000A000
#define NV_095_FORMAT_MIPMAP_LEVELS_11_ADJ                 0x0000B000
#define NV_095_FORMAT_MIPMAP_LEVELS_12_ADJ                 0x0000C000
#define NV_095_FORMAT_MIPMAP_LEVELS_13_ADJ                 0x0000D000
#define NV_095_FORMAT_MIPMAP_LEVELS_14_ADJ                 0x0000E000
#define NV_095_FORMAT_MIPMAP_LEVELS_15_ADJ                 0x0000F000
#define NV_095_FORMAT_BASE_SIZE_U_MSK                      0x000F0000 /* 19:16 */ 
#define NV_095_FORMAT_BASE_SIZE_U_RMSK                     0x0000000F /* 19:16 */ 
#define NV_095_FORMAT_BASE_SIZE_U_WORD                     0
#define NV_095_FORMAT_BASE_SIZE_U_HIGH_FIELD               0x00000013 /* =19 */
#define NV_095_FORMAT_BASE_SIZE_U_LOW_FIELD                0x00000010 /* =16 */
#define NV_095_FORMAT_BASE_SIZE_U_1X1_ADJ                  0x00000000
#define NV_095_FORMAT_BASE_SIZE_U_2X2_ADJ                  0x00010000
#define NV_095_FORMAT_BASE_SIZE_U_4X4_ADJ                  0x00020000
#define NV_095_FORMAT_BASE_SIZE_U_8X8_ADJ                  0x00030000
#define NV_095_FORMAT_BASE_SIZE_U_16X16_ADJ                0x00040000
#define NV_095_FORMAT_BASE_SIZE_U_32X32_ADJ                0x00050000
#define NV_095_FORMAT_BASE_SIZE_U_64X64_ADJ                0x00060000
#define NV_095_FORMAT_BASE_SIZE_U_128X128_ADJ              0x00070000
#define NV_095_FORMAT_BASE_SIZE_U_256X256_ADJ              0x00080000
#define NV_095_FORMAT_BASE_SIZE_U_512X512_ADJ              0x00090000
#define NV_095_FORMAT_BASE_SIZE_U_1024X1024_ADJ            0x000A0000
#define NV_095_FORMAT_BASE_SIZE_U_2048X2048_ADJ            0x000B0000
#define NV_095_FORMAT_BASE_SIZE_V_MSK                      0x00F00000 /* 23:20 */ 
#define NV_095_FORMAT_BASE_SIZE_V_RMSK                     0x0000000F /* 23:20 */ 
#define NV_095_FORMAT_BASE_SIZE_V_WORD                     0
#define NV_095_FORMAT_BASE_SIZE_V_HIGH_FIELD               0x00000017 /* =23 */
#define NV_095_FORMAT_BASE_SIZE_V_LOW_FIELD                0x00000014 /* =20 */
#define NV_095_FORMAT_BASE_SIZE_V_1X1_ADJ                  0x00000000
#define NV_095_FORMAT_BASE_SIZE_V_2X2_ADJ                  0x00100000
#define NV_095_FORMAT_BASE_SIZE_V_4X4_ADJ                  0x00200000
#define NV_095_FORMAT_BASE_SIZE_V_8X8_ADJ                  0x00300000
#define NV_095_FORMAT_BASE_SIZE_V_16X16_ADJ                0x00400000
#define NV_095_FORMAT_BASE_SIZE_V_32X32_ADJ                0x00500000
#define NV_095_FORMAT_BASE_SIZE_V_64X64_ADJ                0x00600000
#define NV_095_FORMAT_BASE_SIZE_V_128X128_ADJ              0x00700000
#define NV_095_FORMAT_BASE_SIZE_V_256X256_ADJ              0x00800000
#define NV_095_FORMAT_BASE_SIZE_V_512X512_ADJ              0x00900000
#define NV_095_FORMAT_BASE_SIZE_V_1024X1024_ADJ            0x00A00000
#define NV_095_FORMAT_BASE_SIZE_V_2048X2048_ADJ            0x00B00000
#define NV_095_FORMAT_TEXTUREADDRESSU_MSK                  0x07000000 /* 26:24 */ 
#define NV_095_FORMAT_TEXTUREADDRESSU_RMSK                 0x00000007 /* 26:24 */ 
#define NV_095_FORMAT_TEXTUREADDRESSU_WORD                 0
#define NV_095_FORMAT_TEXTUREADDRESSU_HIGH_FIELD           0x0000001A /* =26 */
#define NV_095_FORMAT_TEXTUREADDRESSU_LOW_FIELD            0x00000018 /* =24 */
#define NV_095_FORMAT_TEXTUREADDRESSU_WRAP_ADJ             0x01000000
#define NV_095_FORMAT_TEXTUREADDRESSU_MIRROR_ADJ           0x02000000
#define NV_095_FORMAT_TEXTUREADDRESSU_CLAMP_ADJ            0x03000000
#define NV_095_FORMAT_TEXTUREADDRESSU_BORDER_ADJ           0x04000000
#define NV_095_FORMAT_WRAPU_MSK                            0x08000000 /* 27:27 */ 
#define NV_095_FORMAT_WRAPU_RMSK                           0x00000001 /* 27:27 */ 
#define NV_095_FORMAT_WRAPU_WORD                           0
#define NV_095_FORMAT_WRAPU_HIGH_FIELD                     0x0000001B /* =27 */
#define NV_095_FORMAT_WRAPU_LOW_FIELD                      0x0000001B /* =27 */
#define NV_095_FORMAT_WRAPU_FALSE_ADJ                      0x00000000
#define NV_095_FORMAT_WRAPU_TRUE_ADJ                       0x08000000
#define NV_095_FORMAT_TEXTUREADDRESSV_MSK                  0x70000000 /* 30:28 */ 
#define NV_095_FORMAT_TEXTUREADDRESSV_RMSK                 0x00000007 /* 30:28 */ 
#define NV_095_FORMAT_TEXTUREADDRESSV_WORD                 0
#define NV_095_FORMAT_TEXTUREADDRESSV_HIGH_FIELD           0x0000001E /* =30 */
#define NV_095_FORMAT_TEXTUREADDRESSV_LOW_FIELD            0x0000001C /* =28 */
#define NV_095_FORMAT_TEXTUREADDRESSV_WRAP_ADJ             0x10000000
#define NV_095_FORMAT_TEXTUREADDRESSV_MIRROR_ADJ           0x20000000
#define NV_095_FORMAT_TEXTUREADDRESSV_CLAMP_ADJ            0x30000000
#define NV_095_FORMAT_TEXTUREADDRESSV_BORDER_ADJ           0x40000000
#define NV_095_FORMAT_WRAPV_MSK                            0x80000000 /* 31:31 */ 
#define NV_095_FORMAT_WRAPV_RMSK                           0x00000001 /* 31:31 */ 
#define NV_095_FORMAT_WRAPV_WORD                           0
#define NV_095_FORMAT_WRAPV_HIGH_FIELD                     0x0000001F /* =31 */
#define NV_095_FORMAT_WRAPV_LOW_FIELD                      0x0000001F /* =31 */
#define NV_095_FORMAT_WRAPV_FALSE_ADJ                      0x00000000
#define NV_095_FORMAT_WRAPV_TRUE_ADJ                       0x80000000
#define NV_095_FORMAT_MSK                                  0xFFFFFFFF 
#define NV_095_FILTER_KERNEL_SIZE_X_MSK                    0x000000FF /* 7:0 */ 
#define NV_095_FILTER_KERNEL_SIZE_X_RMSK                   0x000000FF /* 7:0 */ 
#define NV_095_FILTER_KERNEL_SIZE_X_WORD                   0
#define NV_095_FILTER_KERNEL_SIZE_X_HIGH_FIELD             0x00000007 /* =7 */
#define NV_095_FILTER_KERNEL_SIZE_X_LOW_FIELD              0x00000000 /* =0 */
#define NV_095_FILTER_KERNEL_SIZE_Y_MSK                    0x00007F00 /* 14:8 */ 
#define NV_095_FILTER_KERNEL_SIZE_Y_RMSK                   0x0000007F /* 14:8 */ 
#define NV_095_FILTER_KERNEL_SIZE_Y_WORD                   0
#define NV_095_FILTER_KERNEL_SIZE_Y_HIGH_FIELD             0x0000000E /* =14 */
#define NV_095_FILTER_KERNEL_SIZE_Y_LOW_FIELD              0x00000008 /* =8 */
#define NV_095_FILTER_MIPMAP_DITHER_ENABLE_MSK             0x00008000 /* 15:15 */ 
#define NV_095_FILTER_MIPMAP_DITHER_ENABLE_RMSK            0x00000001 /* 15:15 */ 
#define NV_095_FILTER_MIPMAP_DITHER_ENABLE_WORD            0
#define NV_095_FILTER_MIPMAP_DITHER_ENABLE_HIGH_FIELD      0x0000000F /* =15 */
#define NV_095_FILTER_MIPMAP_DITHER_ENABLE_LOW_FIELD       0x0000000F /* =15 */
#define NV_095_FILTER_MIPMAP_DITHER_ENABLE_FALSE_ADJ       0x00000000
#define NV_095_FILTER_MIPMAP_DITHER_ENABLE_TRUE_ADJ        0x00008000
#define NV_095_FILTER_MIPMAPLODBIAS_MSK                    0x00FF0000 /* 23:16 */ 
#define NV_095_FILTER_MIPMAPLODBIAS_RMSK                   0x000000FF /* 23:16 */ 
#define NV_095_FILTER_MIPMAPLODBIAS_WORD                   0
#define NV_095_FILTER_MIPMAPLODBIAS_HIGH_FIELD             0x00000017 /* =23 */
#define NV_095_FILTER_MIPMAPLODBIAS_LOW_FIELD              0x00000010 /* =16 */
#define NV_095_FILTER_TEXTUREMIN_MSK                       0x07000000 /* 26:24 */ 
#define NV_095_FILTER_TEXTUREMIN_RMSK                      0x00000007 /* 26:24 */ 
#define NV_095_FILTER_TEXTUREMIN_WORD                      0
#define NV_095_FILTER_TEXTUREMIN_HIGH_FIELD                0x0000001A /* =26 */
#define NV_095_FILTER_TEXTUREMIN_LOW_FIELD                 0x00000018 /* =24 */
#define NV_095_FILTER_TEXTUREMIN_NEAREST_ADJ               0x01000000
#define NV_095_FILTER_TEXTUREMIN_LINEAR_ADJ                0x02000000
#define NV_095_FILTER_TEXTUREMIN_MIPNEAREST_ADJ            0x03000000
#define NV_095_FILTER_TEXTUREMIN_MIPLINEAR_ADJ             0x04000000
#define NV_095_FILTER_TEXTUREMIN_LINEARMIPNEAREST_ADJ      0x05000000
#define NV_095_FILTER_TEXTUREMIN_LINEARMIPLINEAR_ADJ       0x06000000
#define NV_095_FILTER_ANISOTROPIC_MIN_ENABLE_MSK           0x08000000 /* 27:27 */ 
#define NV_095_FILTER_ANISOTROPIC_MIN_ENABLE_RMSK          0x00000001 /* 27:27 */ 
#define NV_095_FILTER_ANISOTROPIC_MIN_ENABLE_WORD          0
#define NV_095_FILTER_ANISOTROPIC_MIN_ENABLE_HIGH_FIELD    0x0000001B /* =27 */
#define NV_095_FILTER_ANISOTROPIC_MIN_ENABLE_LOW_FIELD     0x0000001B /* =27 */
#define NV_095_FILTER_ANISOTROPIC_MIN_ENABLE_FALSE_ADJ     0x00000000
#define NV_095_FILTER_ANISOTROPIC_MIN_ENABLE_TRUE_ADJ      0x08000000
#define NV_095_FILTER_TEXTUREMAG_MSK                       0x70000000 /* 30:28 */ 
#define NV_095_FILTER_TEXTUREMAG_RMSK                      0x00000007 /* 30:28 */ 
#define NV_095_FILTER_TEXTUREMAG_WORD                      0
#define NV_095_FILTER_TEXTUREMAG_HIGH_FIELD                0x0000001E /* =30 */
#define NV_095_FILTER_TEXTUREMAG_LOW_FIELD                 0x0000001C /* =28 */
#define NV_095_FILTER_TEXTUREMAG_NEAREST_ADJ               0x10000000
#define NV_095_FILTER_TEXTUREMAG_LINEAR_ADJ                0x20000000
#define NV_095_FILTER_TEXTUREMAG_MIPNEAREST_ADJ            0x30000000
#define NV_095_FILTER_TEXTUREMAG_MIPLINEAR_ADJ             0x40000000
#define NV_095_FILTER_TEXTUREMAG_LINEARMIPNEAREST_ADJ      0x50000000
#define NV_095_FILTER_TEXTUREMAG_LINEARMIPLINEAR_ADJ       0x60000000
#define NV_095_FILTER_ANISOTROPIC_MAG_ENABLE_MSK           0x80000000 /* 31:31 */ 
#define NV_095_FILTER_ANISOTROPIC_MAG_ENABLE_RMSK          0x00000001 /* 31:31 */ 
#define NV_095_FILTER_ANISOTROPIC_MAG_ENABLE_WORD          0
#define NV_095_FILTER_ANISOTROPIC_MAG_ENABLE_HIGH_FIELD    0x0000001F /* =31 */
#define NV_095_FILTER_ANISOTROPIC_MAG_ENABLE_LOW_FIELD     0x0000001F /* =31 */
#define NV_095_FILTER_ANISOTROPIC_MAG_ENABLE_FALSE_ADJ     0x00000000
#define NV_095_FILTER_ANISOTROPIC_MAG_ENABLE_TRUE_ADJ      0x80000000
#define NV_095_FILTER_MSK                                  0xFFFFFFFF 
#define NV_095_COMBINE_0_ALPHA_INVERSE_0_MSK               0x00000001 /* 0:0 */ 
#define NV_095_COMBINE_0_ALPHA_INVERSE_0_RMSK              0x00000001 /* 0:0 */ 
#define NV_095_COMBINE_0_ALPHA_INVERSE_0_WORD              0
#define NV_095_COMBINE_0_ALPHA_INVERSE_0_HIGH_FIELD        0x00000000 /* =0 */
#define NV_095_COMBINE_0_ALPHA_INVERSE_0_LOW_FIELD         0x00000000 /* =0 */
#define NV_095_COMBINE_0_ALPHA_INVERSE_0_NORMAL_ADJ        0x00000000
#define NV_095_COMBINE_0_ALPHA_INVERSE_0_INVERSE_ADJ       0x00000001
#define NV_095_COMBINE_0_ALPHA_ALPHA_0_MSK                 0x00000002 /* 1:1 */ 
#define NV_095_COMBINE_0_ALPHA_ALPHA_0_RMSK                0x00000001 /* 1:1 */ 
#define NV_095_COMBINE_0_ALPHA_ALPHA_0_WORD                0
#define NV_095_COMBINE_0_ALPHA_ALPHA_0_HIGH_FIELD          0x00000001 /* =1 */
#define NV_095_COMBINE_0_ALPHA_ALPHA_0_LOW_FIELD           0x00000001 /* =1 */
#define NV_095_COMBINE_0_ALPHA_ARGUMENT_0_MSK              0x000000FC /* 7:2 */ 
#define NV_095_COMBINE_0_ALPHA_ARGUMENT_0_RMSK             0x0000003F /* 7:2 */ 
#define NV_095_COMBINE_0_ALPHA_ARGUMENT_0_WORD             0
#define NV_095_COMBINE_0_ALPHA_ARGUMENT_0_HIGH_FIELD       0x00000007 /* =7 */
#define NV_095_COMBINE_0_ALPHA_ARGUMENT_0_LOW_FIELD        0x00000002 /* =2 */
#define NV_095_COMBINE_0_ALPHA_ARGUMENT_0_ZERO_ADJ         0x00000004
#define NV_095_COMBINE_0_ALPHA_ARGUMENT_0_FACTOR_ADJ       0x00000008
#define NV_095_COMBINE_0_ALPHA_ARGUMENT_0_DIFFUSE_ADJ      0x0000000C
#define NV_095_COMBINE_0_ALPHA_ARGUMENT_0_INPUT_ADJ        0x00000010
#define NV_095_COMBINE_0_ALPHA_ARGUMENT_0_TEXTURE0_ADJ     0x00000014
#define NV_095_COMBINE_0_ALPHA_ARGUMENT_0_TEXTURE1_ADJ     0x00000018
#define NV_095_COMBINE_0_ALPHA_INVERSE_1_MSK               0x00000100 /* 8:8 */ 
#define NV_095_COMBINE_0_ALPHA_INVERSE_1_RMSK              0x00000001 /* 8:8 */ 
#define NV_095_COMBINE_0_ALPHA_INVERSE_1_WORD              0
#define NV_095_COMBINE_0_ALPHA_INVERSE_1_HIGH_FIELD        0x00000008 /* =8 */
#define NV_095_COMBINE_0_ALPHA_INVERSE_1_LOW_FIELD         0x00000008 /* =8 */
#define NV_095_COMBINE_0_ALPHA_INVERSE_1_NORMAL_ADJ        0x00000000
#define NV_095_COMBINE_0_ALPHA_INVERSE_1_INVERSE_ADJ       0x00000100
#define NV_095_COMBINE_0_ALPHA_ALPHA_1_MSK                 0x00000200 /* 9:9 */ 
#define NV_095_COMBINE_0_ALPHA_ALPHA_1_RMSK                0x00000001 /* 9:9 */ 
#define NV_095_COMBINE_0_ALPHA_ALPHA_1_WORD                0
#define NV_095_COMBINE_0_ALPHA_ALPHA_1_HIGH_FIELD          0x00000009 /* =9 */
#define NV_095_COMBINE_0_ALPHA_ALPHA_1_LOW_FIELD           0x00000009 /* =9 */
#define NV_095_COMBINE_0_ALPHA_ARGUMENT_1_MSK              0x0000FC00 /* 15:10 */ 
#define NV_095_COMBINE_0_ALPHA_ARGUMENT_1_RMSK             0x0000003F /* 15:10 */ 
#define NV_095_COMBINE_0_ALPHA_ARGUMENT_1_WORD             0
#define NV_095_COMBINE_0_ALPHA_ARGUMENT_1_HIGH_FIELD       0x0000000F /* =15 */
#define NV_095_COMBINE_0_ALPHA_ARGUMENT_1_LOW_FIELD        0x0000000A /* =10 */
#define NV_095_COMBINE_0_ALPHA_ARGUMENT_1_ZERO_ADJ         0x00000400
#define NV_095_COMBINE_0_ALPHA_ARGUMENT_1_FACTOR_ADJ       0x00000800
#define NV_095_COMBINE_0_ALPHA_ARGUMENT_1_DIFFUSE_ADJ      0x00000C00
#define NV_095_COMBINE_0_ALPHA_ARGUMENT_1_INPUT_ADJ        0x00001000
#define NV_095_COMBINE_0_ALPHA_ARGUMENT_1_TEXTURE0_ADJ     0x00001400
#define NV_095_COMBINE_0_ALPHA_ARGUMENT_1_TEXTURE1_ADJ     0x00001800
#define NV_095_COMBINE_0_ALPHA_INVERSE_2_MSK               0x00010000 /* 16:16 */ 
#define NV_095_COMBINE_0_ALPHA_INVERSE_2_RMSK              0x00000001 /* 16:16 */ 
#define NV_095_COMBINE_0_ALPHA_INVERSE_2_WORD              0
#define NV_095_COMBINE_0_ALPHA_INVERSE_2_HIGH_FIELD        0x00000010 /* =16 */
#define NV_095_COMBINE_0_ALPHA_INVERSE_2_LOW_FIELD         0x00000010 /* =16 */
#define NV_095_COMBINE_0_ALPHA_INVERSE_2_NORMAL_ADJ        0x00000000
#define NV_095_COMBINE_0_ALPHA_INVERSE_2_INVERSE_ADJ       0x00010000
#define NV_095_COMBINE_0_ALPHA_ALPHA_2_MSK                 0x00020000 /* 17:17 */ 
#define NV_095_COMBINE_0_ALPHA_ALPHA_2_RMSK                0x00000001 /* 17:17 */ 
#define NV_095_COMBINE_0_ALPHA_ALPHA_2_WORD                0
#define NV_095_COMBINE_0_ALPHA_ALPHA_2_HIGH_FIELD          0x00000011 /* =17 */
#define NV_095_COMBINE_0_ALPHA_ALPHA_2_LOW_FIELD           0x00000011 /* =17 */
#define NV_095_COMBINE_0_ALPHA_ARGUMENT_2_MSK              0x00FC0000 /* 23:18 */ 
#define NV_095_COMBINE_0_ALPHA_ARGUMENT_2_RMSK             0x0000003F /* 23:18 */ 
#define NV_095_COMBINE_0_ALPHA_ARGUMENT_2_WORD             0
#define NV_095_COMBINE_0_ALPHA_ARGUMENT_2_HIGH_FIELD       0x00000017 /* =23 */
#define NV_095_COMBINE_0_ALPHA_ARGUMENT_2_LOW_FIELD        0x00000012 /* =18 */
#define NV_095_COMBINE_0_ALPHA_ARGUMENT_2_ZERO_ADJ         0x00040000
#define NV_095_COMBINE_0_ALPHA_ARGUMENT_2_FACTOR_ADJ       0x00080000
#define NV_095_COMBINE_0_ALPHA_ARGUMENT_2_DIFFUSE_ADJ      0x000C0000
#define NV_095_COMBINE_0_ALPHA_ARGUMENT_2_INPUT_ADJ        0x00100000
#define NV_095_COMBINE_0_ALPHA_ARGUMENT_2_TEXTURE0_ADJ     0x00140000
#define NV_095_COMBINE_0_ALPHA_ARGUMENT_2_TEXTURE1_ADJ     0x00180000
#define NV_095_COMBINE_0_ALPHA_INVERSE_3_MSK               0x01000000 /* 24:24 */ 
#define NV_095_COMBINE_0_ALPHA_INVERSE_3_RMSK              0x00000001 /* 24:24 */ 
#define NV_095_COMBINE_0_ALPHA_INVERSE_3_WORD              0
#define NV_095_COMBINE_0_ALPHA_INVERSE_3_HIGH_FIELD        0x00000018 /* =24 */
#define NV_095_COMBINE_0_ALPHA_INVERSE_3_LOW_FIELD         0x00000018 /* =24 */
#define NV_095_COMBINE_0_ALPHA_INVERSE_3_NORMAL_ADJ        0x00000000
#define NV_095_COMBINE_0_ALPHA_INVERSE_3_INVERSE_ADJ       0x01000000
#define NV_095_COMBINE_0_ALPHA_ALPHA_3_MSK                 0x02000000 /* 25:25 */ 
#define NV_095_COMBINE_0_ALPHA_ALPHA_3_RMSK                0x00000001 /* 25:25 */ 
#define NV_095_COMBINE_0_ALPHA_ALPHA_3_WORD                0
#define NV_095_COMBINE_0_ALPHA_ALPHA_3_HIGH_FIELD          0x00000019 /* =25 */
#define NV_095_COMBINE_0_ALPHA_ALPHA_3_LOW_FIELD           0x00000019 /* =25 */
#define NV_095_COMBINE_0_ALPHA_ARGUMENT_3_MSK              0x1C000000 /* 28:26 */ 
#define NV_095_COMBINE_0_ALPHA_ARGUMENT_3_RMSK             0x00000007 /* 28:26 */ 
#define NV_095_COMBINE_0_ALPHA_ARGUMENT_3_WORD             0
#define NV_095_COMBINE_0_ALPHA_ARGUMENT_3_HIGH_FIELD       0x0000001C /* =28 */
#define NV_095_COMBINE_0_ALPHA_ARGUMENT_3_LOW_FIELD        0x0000001A /* =26 */
#define NV_095_COMBINE_0_ALPHA_ARGUMENT_3_ZERO_ADJ         0x04000000
#define NV_095_COMBINE_0_ALPHA_ARGUMENT_3_FACTOR_ADJ       0x08000000
#define NV_095_COMBINE_0_ALPHA_ARGUMENT_3_DIFFUSE_ADJ      0x0C000000
#define NV_095_COMBINE_0_ALPHA_ARGUMENT_3_INPUT_ADJ        0x10000000
#define NV_095_COMBINE_0_ALPHA_ARGUMENT_3_TEXTURE0_ADJ     0x14000000
#define NV_095_COMBINE_0_ALPHA_ARGUMENT_3_TEXTURE1_ADJ     0x18000000
#define NV_095_COMBINE_0_ALPHA_OPERATION_MSK               0xE0000000 /* 31:29 */ 
#define NV_095_COMBINE_0_ALPHA_OPERATION_RMSK              0x00000007 /* 31:29 */ 
#define NV_095_COMBINE_0_ALPHA_OPERATION_WORD              0
#define NV_095_COMBINE_0_ALPHA_OPERATION_HIGH_FIELD        0x0000001F /* =31 */
#define NV_095_COMBINE_0_ALPHA_OPERATION_LOW_FIELD         0x0000001D /* =29 */
#define NV_095_COMBINE_0_ALPHA_OPERATION_ADD_ADJ           0x20000000
#define NV_095_COMBINE_0_ALPHA_OPERATION_ADD2_ADJ          0x40000000
#define NV_095_COMBINE_0_ALPHA_OPERATION_ADD4_ADJ          0x60000000
#define NV_095_COMBINE_0_ALPHA_OPERATION_ADDSIGNED_ADJ     0x80000000
#define NV_095_COMBINE_0_ALPHA_OPERATION_MUX_ADJ           0xA0000000
#define NV_095_COMBINE_0_ALPHA_OPERATION_ADDCOMPLEMENT_ADJ 0xC0000000
#define NV_095_COMBINE_0_ALPHA_OPERATION_ADDSIGNED2_ADJ    0xE0000000
#define NV_095_COMBINE_0_ALPHA_MSK                         0xFFFFFFFF 
#define NV_095_COMBINE_0_COLOR_INVERSE_0_MSK               0x00000001 /* 0:0 */ 
#define NV_095_COMBINE_0_COLOR_INVERSE_0_RMSK              0x00000001 /* 0:0 */ 
#define NV_095_COMBINE_0_COLOR_INVERSE_0_WORD              0
#define NV_095_COMBINE_0_COLOR_INVERSE_0_HIGH_FIELD        0x00000000 /* =0 */
#define NV_095_COMBINE_0_COLOR_INVERSE_0_LOW_FIELD         0x00000000 /* =0 */
#define NV_095_COMBINE_0_COLOR_INVERSE_0_NORMAL_ADJ        0x00000000
#define NV_095_COMBINE_0_COLOR_INVERSE_0_INVERSE_ADJ       0x00000001
#define NV_095_COMBINE_0_COLOR_ALPHA_0_MSK                 0x00000002 /* 1:1 */ 
#define NV_095_COMBINE_0_COLOR_ALPHA_0_RMSK                0x00000001 /* 1:1 */ 
#define NV_095_COMBINE_0_COLOR_ALPHA_0_WORD                0
#define NV_095_COMBINE_0_COLOR_ALPHA_0_HIGH_FIELD          0x00000001 /* =1 */
#define NV_095_COMBINE_0_COLOR_ALPHA_0_LOW_FIELD           0x00000001 /* =1 */
#define NV_095_COMBINE_0_COLOR_ALPHA_0_COLOR_ADJ           0x00000000
#define NV_095_COMBINE_0_COLOR_ALPHA_0_ALPHA_ADJ           0x00000002
#define NV_095_COMBINE_0_COLOR_ARGUMENT_0_MSK              0x000000FC /* 7:2 */ 
#define NV_095_COMBINE_0_COLOR_ARGUMENT_0_RMSK             0x0000003F /* 7:2 */ 
#define NV_095_COMBINE_0_COLOR_ARGUMENT_0_WORD             0
#define NV_095_COMBINE_0_COLOR_ARGUMENT_0_HIGH_FIELD       0x00000007 /* =7 */
#define NV_095_COMBINE_0_COLOR_ARGUMENT_0_LOW_FIELD        0x00000002 /* =2 */
#define NV_095_COMBINE_0_COLOR_ARGUMENT_0_ZERO_ADJ         0x00000004
#define NV_095_COMBINE_0_COLOR_ARGUMENT_0_FACTOR_ADJ       0x00000008
#define NV_095_COMBINE_0_COLOR_ARGUMENT_0_DIFFUSE_ADJ      0x0000000C
#define NV_095_COMBINE_0_COLOR_ARGUMENT_0_INPUT_ADJ        0x00000010
#define NV_095_COMBINE_0_COLOR_ARGUMENT_0_TEXTURE0_ADJ     0x00000014
#define NV_095_COMBINE_0_COLOR_ARGUMENT_0_TEXTURE1_ADJ     0x00000018
#define NV_095_COMBINE_0_COLOR_INVERSE_1_MSK               0x00000100 /* 8:8 */ 
#define NV_095_COMBINE_0_COLOR_INVERSE_1_RMSK              0x00000001 /* 8:8 */ 
#define NV_095_COMBINE_0_COLOR_INVERSE_1_WORD              0
#define NV_095_COMBINE_0_COLOR_INVERSE_1_HIGH_FIELD        0x00000008 /* =8 */
#define NV_095_COMBINE_0_COLOR_INVERSE_1_LOW_FIELD         0x00000008 /* =8 */
#define NV_095_COMBINE_0_COLOR_INVERSE_1_NORMAL_ADJ        0x00000000
#define NV_095_COMBINE_0_COLOR_INVERSE_1_INVERSE_ADJ       0x00000100
#define NV_095_COMBINE_0_COLOR_ALPHA_1_MSK                 0x00000200 /* 9:9 */ 
#define NV_095_COMBINE_0_COLOR_ALPHA_1_RMSK                0x00000001 /* 9:9 */ 
#define NV_095_COMBINE_0_COLOR_ALPHA_1_WORD                0
#define NV_095_COMBINE_0_COLOR_ALPHA_1_HIGH_FIELD          0x00000009 /* =9 */
#define NV_095_COMBINE_0_COLOR_ALPHA_1_LOW_FIELD           0x00000009 /* =9 */
#define NV_095_COMBINE_0_COLOR_ALPHA_1_COLOR_ADJ           0x00000000
#define NV_095_COMBINE_0_COLOR_ALPHA_1_ALPHA_ADJ           0x00000200
#define NV_095_COMBINE_0_COLOR_ARGUMENT_1_MSK              0x0000FC00 /* 15:10 */ 
#define NV_095_COMBINE_0_COLOR_ARGUMENT_1_RMSK             0x0000003F /* 15:10 */ 
#define NV_095_COMBINE_0_COLOR_ARGUMENT_1_WORD             0
#define NV_095_COMBINE_0_COLOR_ARGUMENT_1_HIGH_FIELD       0x0000000F /* =15 */
#define NV_095_COMBINE_0_COLOR_ARGUMENT_1_LOW_FIELD        0x0000000A /* =10 */
#define NV_095_COMBINE_0_COLOR_ARGUMENT_1_ZERO_ADJ         0x00000400
#define NV_095_COMBINE_0_COLOR_ARGUMENT_1_FACTOR_ADJ       0x00000800
#define NV_095_COMBINE_0_COLOR_ARGUMENT_1_DIFFUSE_ADJ      0x00000C00
#define NV_095_COMBINE_0_COLOR_ARGUMENT_1_INPUT_ADJ        0x00001000
#define NV_095_COMBINE_0_COLOR_ARGUMENT_1_TEXTURE0_ADJ     0x00001400
#define NV_095_COMBINE_0_COLOR_ARGUMENT_1_TEXTURE1_ADJ     0x00001800
#define NV_095_COMBINE_0_COLOR_INVERSE_2_MSK               0x00010000 /* 16:16 */ 
#define NV_095_COMBINE_0_COLOR_INVERSE_2_RMSK              0x00000001 /* 16:16 */ 
#define NV_095_COMBINE_0_COLOR_INVERSE_2_WORD              0
#define NV_095_COMBINE_0_COLOR_INVERSE_2_HIGH_FIELD        0x00000010 /* =16 */
#define NV_095_COMBINE_0_COLOR_INVERSE_2_LOW_FIELD         0x00000010 /* =16 */
#define NV_095_COMBINE_0_COLOR_INVERSE_2_NORMAL_ADJ        0x00000000
#define NV_095_COMBINE_0_COLOR_INVERSE_2_INVERSE_ADJ       0x00010000
#define NV_095_COMBINE_0_COLOR_ALPHA_2_MSK                 0x00020000 /* 17:17 */ 
#define NV_095_COMBINE_0_COLOR_ALPHA_2_RMSK                0x00000001 /* 17:17 */ 
#define NV_095_COMBINE_0_COLOR_ALPHA_2_WORD                0
#define NV_095_COMBINE_0_COLOR_ALPHA_2_HIGH_FIELD          0x00000011 /* =17 */
#define NV_095_COMBINE_0_COLOR_ALPHA_2_LOW_FIELD           0x00000011 /* =17 */
#define NV_095_COMBINE_0_COLOR_ALPHA_2_COLOR_ADJ           0x00000000
#define NV_095_COMBINE_0_COLOR_ALPHA_2_ALPHA_ADJ           0x00020000
#define NV_095_COMBINE_0_COLOR_ARGUMENT_2_MSK              0x00FC0000 /* 23:18 */ 
#define NV_095_COMBINE_0_COLOR_ARGUMENT_2_RMSK             0x0000003F /* 23:18 */ 
#define NV_095_COMBINE_0_COLOR_ARGUMENT_2_WORD             0
#define NV_095_COMBINE_0_COLOR_ARGUMENT_2_HIGH_FIELD       0x00000017 /* =23 */
#define NV_095_COMBINE_0_COLOR_ARGUMENT_2_LOW_FIELD        0x00000012 /* =18 */
#define NV_095_COMBINE_0_COLOR_ARGUMENT_2_ZERO_ADJ         0x00040000
#define NV_095_COMBINE_0_COLOR_ARGUMENT_2_FACTOR_ADJ       0x00080000
#define NV_095_COMBINE_0_COLOR_ARGUMENT_2_DIFFUSE_ADJ      0x000C0000
#define NV_095_COMBINE_0_COLOR_ARGUMENT_2_INPUT_ADJ        0x00100000
#define NV_095_COMBINE_0_COLOR_ARGUMENT_2_TEXTURE0_ADJ     0x00140000
#define NV_095_COMBINE_0_COLOR_ARGUMENT_2_TEXTURE1_ADJ     0x00180000
#define NV_095_COMBINE_0_COLOR_INVERSE_3_MSK               0x01000000 /* 24:24 */ 
#define NV_095_COMBINE_0_COLOR_INVERSE_3_RMSK              0x00000001 /* 24:24 */ 
#define NV_095_COMBINE_0_COLOR_INVERSE_3_WORD              0
#define NV_095_COMBINE_0_COLOR_INVERSE_3_HIGH_FIELD        0x00000018 /* =24 */
#define NV_095_COMBINE_0_COLOR_INVERSE_3_LOW_FIELD         0x00000018 /* =24 */
#define NV_095_COMBINE_0_COLOR_INVERSE_3_NORMAL_ADJ        0x00000000
#define NV_095_COMBINE_0_COLOR_INVERSE_3_INVERSE_ADJ       0x01000000
#define NV_095_COMBINE_0_COLOR_ALPHA_3_MSK                 0x02000000 /* 25:25 */ 
#define NV_095_COMBINE_0_COLOR_ALPHA_3_RMSK                0x00000001 /* 25:25 */ 
#define NV_095_COMBINE_0_COLOR_ALPHA_3_WORD                0
#define NV_095_COMBINE_0_COLOR_ALPHA_3_HIGH_FIELD          0x00000019 /* =25 */
#define NV_095_COMBINE_0_COLOR_ALPHA_3_LOW_FIELD           0x00000019 /* =25 */
#define NV_095_COMBINE_0_COLOR_ALPHA_3_COLOR_ADJ           0x00000000
#define NV_095_COMBINE_0_COLOR_ALPHA_3_ALPHA_ADJ           0x02000000
#define NV_095_COMBINE_0_COLOR_ARGUMENT_3_MSK              0x1C000000 /* 28:26 */ 
#define NV_095_COMBINE_0_COLOR_ARGUMENT_3_RMSK             0x00000007 /* 28:26 */ 
#define NV_095_COMBINE_0_COLOR_ARGUMENT_3_WORD             0
#define NV_095_COMBINE_0_COLOR_ARGUMENT_3_HIGH_FIELD       0x0000001C /* =28 */
#define NV_095_COMBINE_0_COLOR_ARGUMENT_3_LOW_FIELD        0x0000001A /* =26 */
#define NV_095_COMBINE_0_COLOR_ARGUMENT_3_ZERO_ADJ         0x04000000
#define NV_095_COMBINE_0_COLOR_ARGUMENT_3_FACTOR_ADJ       0x08000000
#define NV_095_COMBINE_0_COLOR_ARGUMENT_3_DIFFUSE_ADJ      0x0C000000
#define NV_095_COMBINE_0_COLOR_ARGUMENT_3_INPUT_ADJ        0x10000000
#define NV_095_COMBINE_0_COLOR_ARGUMENT_3_TEXTURE0_ADJ     0x14000000
#define NV_095_COMBINE_0_COLOR_ARGUMENT_3_TEXTURE1_ADJ     0x18000000
#define NV_095_COMBINE_0_COLOR_OPERATION_MSK               0xE0000000 /* 31:29 */ 
#define NV_095_COMBINE_0_COLOR_OPERATION_RMSK              0x00000007 /* 31:29 */ 
#define NV_095_COMBINE_0_COLOR_OPERATION_WORD              0
#define NV_095_COMBINE_0_COLOR_OPERATION_HIGH_FIELD        0x0000001F /* =31 */
#define NV_095_COMBINE_0_COLOR_OPERATION_LOW_FIELD         0x0000001D /* =29 */
#define NV_095_COMBINE_0_COLOR_OPERATION_ADD_ADJ           0x20000000
#define NV_095_COMBINE_0_COLOR_OPERATION_ADD2_ADJ          0x40000000
#define NV_095_COMBINE_0_COLOR_OPERATION_ADD4_ADJ          0x60000000
#define NV_095_COMBINE_0_COLOR_OPERATION_ADDSIGNED_ADJ     0x80000000
#define NV_095_COMBINE_0_COLOR_OPERATION_MUX_ADJ           0xA0000000
#define NV_095_COMBINE_0_COLOR_OPERATION_ADDCOMPLEMENT_ADJ 0xC0000000
#define NV_095_COMBINE_0_COLOR_OPERATION_ADDSIGNED2_ADJ    0xE0000000
#define NV_095_COMBINE_0_COLOR_MSK                         0xFFFFFFFF 
#define NV_095_COMBINE_1_ALPHA_INVERSE_0_MSK               0x00000001 /* 0:0 */ 
#define NV_095_COMBINE_1_ALPHA_INVERSE_0_RMSK              0x00000001 /* 0:0 */ 
#define NV_095_COMBINE_1_ALPHA_INVERSE_0_WORD              0
#define NV_095_COMBINE_1_ALPHA_INVERSE_0_HIGH_FIELD        0x00000000 /* =0 */
#define NV_095_COMBINE_1_ALPHA_INVERSE_0_LOW_FIELD         0x00000000 /* =0 */
#define NV_095_COMBINE_1_ALPHA_INVERSE_0_NORMAL_ADJ        0x00000000
#define NV_095_COMBINE_1_ALPHA_INVERSE_0_INVERSE_ADJ       0x00000001
#define NV_095_COMBINE_1_ALPHA_ALPHA_0_MSK                 0x00000002 /* 1:1 */ 
#define NV_095_COMBINE_1_ALPHA_ALPHA_0_RMSK                0x00000001 /* 1:1 */ 
#define NV_095_COMBINE_1_ALPHA_ALPHA_0_WORD                0
#define NV_095_COMBINE_1_ALPHA_ALPHA_0_HIGH_FIELD          0x00000001 /* =1 */
#define NV_095_COMBINE_1_ALPHA_ALPHA_0_LOW_FIELD           0x00000001 /* =1 */
#define NV_095_COMBINE_1_ALPHA_ARGUMENT_0_MSK              0x000000FC /* 7:2 */ 
#define NV_095_COMBINE_1_ALPHA_ARGUMENT_0_RMSK             0x0000003F /* 7:2 */ 
#define NV_095_COMBINE_1_ALPHA_ARGUMENT_0_WORD             0
#define NV_095_COMBINE_1_ALPHA_ARGUMENT_0_HIGH_FIELD       0x00000007 /* =7 */
#define NV_095_COMBINE_1_ALPHA_ARGUMENT_0_LOW_FIELD        0x00000002 /* =2 */
#define NV_095_COMBINE_1_ALPHA_ARGUMENT_0_ZERO_ADJ         0x00000004
#define NV_095_COMBINE_1_ALPHA_ARGUMENT_0_FACTOR_ADJ       0x00000008
#define NV_095_COMBINE_1_ALPHA_ARGUMENT_0_DIFFUSE_ADJ      0x0000000C
#define NV_095_COMBINE_1_ALPHA_ARGUMENT_0_INPUT_ADJ        0x00000010
#define NV_095_COMBINE_1_ALPHA_ARGUMENT_0_TEXTURE0_ADJ     0x00000014
#define NV_095_COMBINE_1_ALPHA_ARGUMENT_0_TEXTURE1_ADJ     0x00000018
#define NV_095_COMBINE_1_ALPHA_INVERSE_1_MSK               0x00000100 /* 8:8 */ 
#define NV_095_COMBINE_1_ALPHA_INVERSE_1_RMSK              0x00000001 /* 8:8 */ 
#define NV_095_COMBINE_1_ALPHA_INVERSE_1_WORD              0
#define NV_095_COMBINE_1_ALPHA_INVERSE_1_HIGH_FIELD        0x00000008 /* =8 */
#define NV_095_COMBINE_1_ALPHA_INVERSE_1_LOW_FIELD         0x00000008 /* =8 */
#define NV_095_COMBINE_1_ALPHA_INVERSE_1_NORMAL_ADJ        0x00000000
#define NV_095_COMBINE_1_ALPHA_INVERSE_1_INVERSE_ADJ       0x00000100
#define NV_095_COMBINE_1_ALPHA_ALPHA_1_MSK                 0x00000200 /* 9:9 */ 
#define NV_095_COMBINE_1_ALPHA_ALPHA_1_RMSK                0x00000001 /* 9:9 */ 
#define NV_095_COMBINE_1_ALPHA_ALPHA_1_WORD                0
#define NV_095_COMBINE_1_ALPHA_ALPHA_1_HIGH_FIELD          0x00000009 /* =9 */
#define NV_095_COMBINE_1_ALPHA_ALPHA_1_LOW_FIELD           0x00000009 /* =9 */
#define NV_095_COMBINE_1_ALPHA_ARGUMENT_1_MSK              0x0000FC00 /* 15:10 */ 
#define NV_095_COMBINE_1_ALPHA_ARGUMENT_1_RMSK             0x0000003F /* 15:10 */ 
#define NV_095_COMBINE_1_ALPHA_ARGUMENT_1_WORD             0
#define NV_095_COMBINE_1_ALPHA_ARGUMENT_1_HIGH_FIELD       0x0000000F /* =15 */
#define NV_095_COMBINE_1_ALPHA_ARGUMENT_1_LOW_FIELD        0x0000000A /* =10 */
#define NV_095_COMBINE_1_ALPHA_ARGUMENT_1_ZERO_ADJ         0x00000400
#define NV_095_COMBINE_1_ALPHA_ARGUMENT_1_FACTOR_ADJ       0x00000800
#define NV_095_COMBINE_1_ALPHA_ARGUMENT_1_DIFFUSE_ADJ      0x00000C00
#define NV_095_COMBINE_1_ALPHA_ARGUMENT_1_INPUT_ADJ        0x00001000
#define NV_095_COMBINE_1_ALPHA_ARGUMENT_1_TEXTURE0_ADJ     0x00001400
#define NV_095_COMBINE_1_ALPHA_ARGUMENT_1_TEXTURE1_ADJ     0x00001800
#define NV_095_COMBINE_1_ALPHA_INVERSE_2_MSK               0x00010000 /* 16:16 */ 
#define NV_095_COMBINE_1_ALPHA_INVERSE_2_RMSK              0x00000001 /* 16:16 */ 
#define NV_095_COMBINE_1_ALPHA_INVERSE_2_WORD              0
#define NV_095_COMBINE_1_ALPHA_INVERSE_2_HIGH_FIELD        0x00000010 /* =16 */
#define NV_095_COMBINE_1_ALPHA_INVERSE_2_LOW_FIELD         0x00000010 /* =16 */
#define NV_095_COMBINE_1_ALPHA_INVERSE_2_NORMAL_ADJ        0x00000000
#define NV_095_COMBINE_1_ALPHA_INVERSE_2_INVERSE_ADJ       0x00010000
#define NV_095_COMBINE_1_ALPHA_ALPHA_2_MSK                 0x00020000 /* 17:17 */ 
#define NV_095_COMBINE_1_ALPHA_ALPHA_2_RMSK                0x00000001 /* 17:17 */ 
#define NV_095_COMBINE_1_ALPHA_ALPHA_2_WORD                0
#define NV_095_COMBINE_1_ALPHA_ALPHA_2_HIGH_FIELD          0x00000011 /* =17 */
#define NV_095_COMBINE_1_ALPHA_ALPHA_2_LOW_FIELD           0x00000011 /* =17 */
#define NV_095_COMBINE_1_ALPHA_ARGUMENT_2_MSK              0x00FC0000 /* 23:18 */ 
#define NV_095_COMBINE_1_ALPHA_ARGUMENT_2_RMSK             0x0000003F /* 23:18 */ 
#define NV_095_COMBINE_1_ALPHA_ARGUMENT_2_WORD             0
#define NV_095_COMBINE_1_ALPHA_ARGUMENT_2_HIGH_FIELD       0x00000017 /* =23 */
#define NV_095_COMBINE_1_ALPHA_ARGUMENT_2_LOW_FIELD        0x00000012 /* =18 */
#define NV_095_COMBINE_1_ALPHA_ARGUMENT_2_ZERO_ADJ         0x00040000
#define NV_095_COMBINE_1_ALPHA_ARGUMENT_2_FACTOR_ADJ       0x00080000
#define NV_095_COMBINE_1_ALPHA_ARGUMENT_2_DIFFUSE_ADJ      0x000C0000
#define NV_095_COMBINE_1_ALPHA_ARGUMENT_2_INPUT_ADJ        0x00100000
#define NV_095_COMBINE_1_ALPHA_ARGUMENT_2_TEXTURE0_ADJ     0x00140000
#define NV_095_COMBINE_1_ALPHA_ARGUMENT_2_TEXTURE1_ADJ     0x00180000
#define NV_095_COMBINE_1_ALPHA_INVERSE_3_MSK               0x01000000 /* 24:24 */ 
#define NV_095_COMBINE_1_ALPHA_INVERSE_3_RMSK              0x00000001 /* 24:24 */ 
#define NV_095_COMBINE_1_ALPHA_INVERSE_3_WORD              0
#define NV_095_COMBINE_1_ALPHA_INVERSE_3_HIGH_FIELD        0x00000018 /* =24 */
#define NV_095_COMBINE_1_ALPHA_INVERSE_3_LOW_FIELD         0x00000018 /* =24 */
#define NV_095_COMBINE_1_ALPHA_INVERSE_3_NORMAL_ADJ        0x00000000
#define NV_095_COMBINE_1_ALPHA_INVERSE_3_INVERSE_ADJ       0x01000000
#define NV_095_COMBINE_1_ALPHA_ALPHA_3_MSK                 0x02000000 /* 25:25 */ 
#define NV_095_COMBINE_1_ALPHA_ALPHA_3_RMSK                0x00000001 /* 25:25 */ 
#define NV_095_COMBINE_1_ALPHA_ALPHA_3_WORD                0
#define NV_095_COMBINE_1_ALPHA_ALPHA_3_HIGH_FIELD          0x00000019 /* =25 */
#define NV_095_COMBINE_1_ALPHA_ALPHA_3_LOW_FIELD           0x00000019 /* =25 */
#define NV_095_COMBINE_1_ALPHA_ARGUMENT_3_MSK              0x1C000000 /* 28:26 */ 
#define NV_095_COMBINE_1_ALPHA_ARGUMENT_3_RMSK             0x00000007 /* 28:26 */ 
#define NV_095_COMBINE_1_ALPHA_ARGUMENT_3_WORD             0
#define NV_095_COMBINE_1_ALPHA_ARGUMENT_3_HIGH_FIELD       0x0000001C /* =28 */
#define NV_095_COMBINE_1_ALPHA_ARGUMENT_3_LOW_FIELD        0x0000001A /* =26 */
#define NV_095_COMBINE_1_ALPHA_ARGUMENT_3_ZERO_ADJ         0x04000000
#define NV_095_COMBINE_1_ALPHA_ARGUMENT_3_FACTOR_ADJ       0x08000000
#define NV_095_COMBINE_1_ALPHA_ARGUMENT_3_DIFFUSE_ADJ      0x0C000000
#define NV_095_COMBINE_1_ALPHA_ARGUMENT_3_INPUT_ADJ        0x10000000
#define NV_095_COMBINE_1_ALPHA_ARGUMENT_3_TEXTURE0_ADJ     0x14000000
#define NV_095_COMBINE_1_ALPHA_ARGUMENT_3_TEXTURE1_ADJ     0x18000000
#define NV_095_COMBINE_1_ALPHA_OPERATION_MSK               0xE0000000 /* 31:29 */ 
#define NV_095_COMBINE_1_ALPHA_OPERATION_RMSK              0x00000007 /* 31:29 */ 
#define NV_095_COMBINE_1_ALPHA_OPERATION_WORD              0
#define NV_095_COMBINE_1_ALPHA_OPERATION_HIGH_FIELD        0x0000001F /* =31 */
#define NV_095_COMBINE_1_ALPHA_OPERATION_LOW_FIELD         0x0000001D /* =29 */
#define NV_095_COMBINE_1_ALPHA_OPERATION_ADD_ADJ           0x20000000
#define NV_095_COMBINE_1_ALPHA_OPERATION_ADD2_ADJ          0x40000000
#define NV_095_COMBINE_1_ALPHA_OPERATION_ADD4_ADJ          0x60000000
#define NV_095_COMBINE_1_ALPHA_OPERATION_ADDSIGNED_ADJ     0x80000000
#define NV_095_COMBINE_1_ALPHA_OPERATION_MUX_ADJ           0xA0000000
#define NV_095_COMBINE_1_ALPHA_OPERATION_ADDCOMPLEMENT_ADJ 0xC0000000
#define NV_095_COMBINE_1_ALPHA_OPERATION_ADDSIGNED2_ADJ    0xE0000000
#define NV_095_COMBINE_1_ALPHA_MSK                         0xFFFFFFFF 
#define NV_095_COMBINE_1_COLOR_INVERSE_0_MSK               0x00000001 /* 0:0 */ 
#define NV_095_COMBINE_1_COLOR_INVERSE_0_RMSK              0x00000001 /* 0:0 */ 
#define NV_095_COMBINE_1_COLOR_INVERSE_0_WORD              0
#define NV_095_COMBINE_1_COLOR_INVERSE_0_HIGH_FIELD        0x00000000 /* =0 */
#define NV_095_COMBINE_1_COLOR_INVERSE_0_LOW_FIELD         0x00000000 /* =0 */
#define NV_095_COMBINE_1_COLOR_INVERSE_0_NORMAL_ADJ        0x00000000
#define NV_095_COMBINE_1_COLOR_INVERSE_0_INVERSE_ADJ       0x00000001
#define NV_095_COMBINE_1_COLOR_ALPHA_0_MSK                 0x00000002 /* 1:1 */ 
#define NV_095_COMBINE_1_COLOR_ALPHA_0_RMSK                0x00000001 /* 1:1 */ 
#define NV_095_COMBINE_1_COLOR_ALPHA_0_WORD                0
#define NV_095_COMBINE_1_COLOR_ALPHA_0_HIGH_FIELD          0x00000001 /* =1 */
#define NV_095_COMBINE_1_COLOR_ALPHA_0_LOW_FIELD           0x00000001 /* =1 */
#define NV_095_COMBINE_1_COLOR_ALPHA_0_COLOR_ADJ           0x00000000
#define NV_095_COMBINE_1_COLOR_ALPHA_0_ALPHA_ADJ           0x00000002
#define NV_095_COMBINE_1_COLOR_ARGUMENT_0_MSK              0x000000FC /* 7:2 */ 
#define NV_095_COMBINE_1_COLOR_ARGUMENT_0_RMSK             0x0000003F /* 7:2 */ 
#define NV_095_COMBINE_1_COLOR_ARGUMENT_0_WORD             0
#define NV_095_COMBINE_1_COLOR_ARGUMENT_0_HIGH_FIELD       0x00000007 /* =7 */
#define NV_095_COMBINE_1_COLOR_ARGUMENT_0_LOW_FIELD        0x00000002 /* =2 */
#define NV_095_COMBINE_1_COLOR_ARGUMENT_0_ZERO_ADJ         0x00000004
#define NV_095_COMBINE_1_COLOR_ARGUMENT_0_FACTOR_ADJ       0x00000008
#define NV_095_COMBINE_1_COLOR_ARGUMENT_0_DIFFUSE_ADJ      0x0000000C
#define NV_095_COMBINE_1_COLOR_ARGUMENT_0_INPUT_ADJ        0x00000010
#define NV_095_COMBINE_1_COLOR_ARGUMENT_0_TEXTURE0_ADJ     0x00000014
#define NV_095_COMBINE_1_COLOR_ARGUMENT_0_TEXTURE1_ADJ     0x00000018
#define NV_095_COMBINE_1_COLOR_INVERSE_1_MSK               0x00000100 /* 8:8 */ 
#define NV_095_COMBINE_1_COLOR_INVERSE_1_RMSK              0x00000001 /* 8:8 */ 
#define NV_095_COMBINE_1_COLOR_INVERSE_1_WORD              0
#define NV_095_COMBINE_1_COLOR_INVERSE_1_HIGH_FIELD        0x00000008 /* =8 */
#define NV_095_COMBINE_1_COLOR_INVERSE_1_LOW_FIELD         0x00000008 /* =8 */
#define NV_095_COMBINE_1_COLOR_INVERSE_1_NORMAL_ADJ        0x00000000
#define NV_095_COMBINE_1_COLOR_INVERSE_1_INVERSE_ADJ       0x00000100
#define NV_095_COMBINE_1_COLOR_ALPHA_1_MSK                 0x00000200 /* 9:9 */ 
#define NV_095_COMBINE_1_COLOR_ALPHA_1_RMSK                0x00000001 /* 9:9 */ 
#define NV_095_COMBINE_1_COLOR_ALPHA_1_WORD                0
#define NV_095_COMBINE_1_COLOR_ALPHA_1_HIGH_FIELD          0x00000009 /* =9 */
#define NV_095_COMBINE_1_COLOR_ALPHA_1_LOW_FIELD           0x00000009 /* =9 */
#define NV_095_COMBINE_1_COLOR_ALPHA_1_COLOR_ADJ           0x00000000
#define NV_095_COMBINE_1_COLOR_ALPHA_1_ALPHA_ADJ           0x00000200
#define NV_095_COMBINE_1_COLOR_ARGUMENT_1_MSK              0x0000FC00 /* 15:10 */ 
#define NV_095_COMBINE_1_COLOR_ARGUMENT_1_RMSK             0x0000003F /* 15:10 */ 
#define NV_095_COMBINE_1_COLOR_ARGUMENT_1_WORD             0
#define NV_095_COMBINE_1_COLOR_ARGUMENT_1_HIGH_FIELD       0x0000000F /* =15 */
#define NV_095_COMBINE_1_COLOR_ARGUMENT_1_LOW_FIELD        0x0000000A /* =10 */
#define NV_095_COMBINE_1_COLOR_ARGUMENT_1_ZERO_ADJ         0x00000400
#define NV_095_COMBINE_1_COLOR_ARGUMENT_1_FACTOR_ADJ       0x00000800
#define NV_095_COMBINE_1_COLOR_ARGUMENT_1_DIFFUSE_ADJ      0x00000C00
#define NV_095_COMBINE_1_COLOR_ARGUMENT_1_INPUT_ADJ        0x00001000
#define NV_095_COMBINE_1_COLOR_ARGUMENT_1_TEXTURE0_ADJ     0x00001400
#define NV_095_COMBINE_1_COLOR_ARGUMENT_1_TEXTURE1_ADJ     0x00001800
#define NV_095_COMBINE_1_COLOR_INVERSE_2_MSK               0x00010000 /* 16:16 */ 
#define NV_095_COMBINE_1_COLOR_INVERSE_2_RMSK              0x00000001 /* 16:16 */ 
#define NV_095_COMBINE_1_COLOR_INVERSE_2_WORD              0
#define NV_095_COMBINE_1_COLOR_INVERSE_2_HIGH_FIELD        0x00000010 /* =16 */
#define NV_095_COMBINE_1_COLOR_INVERSE_2_LOW_FIELD         0x00000010 /* =16 */
#define NV_095_COMBINE_1_COLOR_INVERSE_2_NORMAL_ADJ        0x00000000
#define NV_095_COMBINE_1_COLOR_INVERSE_2_INVERSE_ADJ       0x00010000
#define NV_095_COMBINE_1_COLOR_ALPHA_2_MSK                 0x00020000 /* 17:17 */ 
#define NV_095_COMBINE_1_COLOR_ALPHA_2_RMSK                0x00000001 /* 17:17 */ 
#define NV_095_COMBINE_1_COLOR_ALPHA_2_WORD                0
#define NV_095_COMBINE_1_COLOR_ALPHA_2_HIGH_FIELD          0x00000011 /* =17 */
#define NV_095_COMBINE_1_COLOR_ALPHA_2_LOW_FIELD           0x00000011 /* =17 */
#define NV_095_COMBINE_1_COLOR_ALPHA_2_COLOR_ADJ           0x00000000
#define NV_095_COMBINE_1_COLOR_ALPHA_2_ALPHA_ADJ           0x00020000
#define NV_095_COMBINE_1_COLOR_ARGUMENT_2_MSK              0x00FC0000 /* 23:18 */ 
#define NV_095_COMBINE_1_COLOR_ARGUMENT_2_RMSK             0x0000003F /* 23:18 */ 
#define NV_095_COMBINE_1_COLOR_ARGUMENT_2_WORD             0
#define NV_095_COMBINE_1_COLOR_ARGUMENT_2_HIGH_FIELD       0x00000017 /* =23 */
#define NV_095_COMBINE_1_COLOR_ARGUMENT_2_LOW_FIELD        0x00000012 /* =18 */
#define NV_095_COMBINE_1_COLOR_ARGUMENT_2_ZERO_ADJ         0x00040000
#define NV_095_COMBINE_1_COLOR_ARGUMENT_2_FACTOR_ADJ       0x00080000
#define NV_095_COMBINE_1_COLOR_ARGUMENT_2_DIFFUSE_ADJ      0x000C0000
#define NV_095_COMBINE_1_COLOR_ARGUMENT_2_INPUT_ADJ        0x00100000
#define NV_095_COMBINE_1_COLOR_ARGUMENT_2_TEXTURE0_ADJ     0x00140000
#define NV_095_COMBINE_1_COLOR_ARGUMENT_2_TEXTURE1_ADJ     0x00180000
#define NV_095_COMBINE_1_COLOR_INVERSE_3_MSK               0x01000000 /* 24:24 */ 
#define NV_095_COMBINE_1_COLOR_INVERSE_3_RMSK              0x00000001 /* 24:24 */ 
#define NV_095_COMBINE_1_COLOR_INVERSE_3_WORD              0
#define NV_095_COMBINE_1_COLOR_INVERSE_3_HIGH_FIELD        0x00000018 /* =24 */
#define NV_095_COMBINE_1_COLOR_INVERSE_3_LOW_FIELD         0x00000018 /* =24 */
#define NV_095_COMBINE_1_COLOR_INVERSE_3_NORMAL_ADJ        0x00000000
#define NV_095_COMBINE_1_COLOR_INVERSE_3_INVERSE_ADJ       0x01000000
#define NV_095_COMBINE_1_COLOR_ALPHA_3_MSK                 0x02000000 /* 25:25 */ 
#define NV_095_COMBINE_1_COLOR_ALPHA_3_RMSK                0x00000001 /* 25:25 */ 
#define NV_095_COMBINE_1_COLOR_ALPHA_3_WORD                0
#define NV_095_COMBINE_1_COLOR_ALPHA_3_HIGH_FIELD          0x00000019 /* =25 */
#define NV_095_COMBINE_1_COLOR_ALPHA_3_LOW_FIELD           0x00000019 /* =25 */
#define NV_095_COMBINE_1_COLOR_ALPHA_3_COLOR_ADJ           0x00000000
#define NV_095_COMBINE_1_COLOR_ALPHA_3_ALPHA_ADJ           0x02000000
#define NV_095_COMBINE_1_COLOR_ARGUMENT_3_MSK              0x1C000000 /* 28:26 */ 
#define NV_095_COMBINE_1_COLOR_ARGUMENT_3_RMSK             0x00000007 /* 28:26 */ 
#define NV_095_COMBINE_1_COLOR_ARGUMENT_3_WORD             0
#define NV_095_COMBINE_1_COLOR_ARGUMENT_3_HIGH_FIELD       0x0000001C /* =28 */
#define NV_095_COMBINE_1_COLOR_ARGUMENT_3_LOW_FIELD        0x0000001A /* =26 */
#define NV_095_COMBINE_1_COLOR_ARGUMENT_3_ZERO_ADJ         0x04000000
#define NV_095_COMBINE_1_COLOR_ARGUMENT_3_FACTOR_ADJ       0x08000000
#define NV_095_COMBINE_1_COLOR_ARGUMENT_3_DIFFUSE_ADJ      0x0C000000
#define NV_095_COMBINE_1_COLOR_ARGUMENT_3_INPUT_ADJ        0x10000000
#define NV_095_COMBINE_1_COLOR_ARGUMENT_3_TEXTURE0_ADJ     0x14000000
#define NV_095_COMBINE_1_COLOR_ARGUMENT_3_TEXTURE1_ADJ     0x18000000
#define NV_095_COMBINE_1_COLOR_OPERATION_MSK               0xE0000000 /* 31:29 */ 
#define NV_095_COMBINE_1_COLOR_OPERATION_RMSK              0x00000007 /* 31:29 */ 
#define NV_095_COMBINE_1_COLOR_OPERATION_WORD              0
#define NV_095_COMBINE_1_COLOR_OPERATION_HIGH_FIELD        0x0000001F /* =31 */
#define NV_095_COMBINE_1_COLOR_OPERATION_LOW_FIELD         0x0000001D /* =29 */
#define NV_095_COMBINE_1_COLOR_OPERATION_ADD_ADJ           0x20000000
#define NV_095_COMBINE_1_COLOR_OPERATION_ADD2_ADJ          0x40000000
#define NV_095_COMBINE_1_COLOR_OPERATION_ADD4_ADJ          0x60000000
#define NV_095_COMBINE_1_COLOR_OPERATION_ADDSIGNED_ADJ     0x80000000
#define NV_095_COMBINE_1_COLOR_OPERATION_MUX_ADJ           0xA0000000
#define NV_095_COMBINE_1_COLOR_OPERATION_ADDCOMPLEMENT_ADJ 0xC0000000
#define NV_095_COMBINE_1_COLOR_OPERATION_ADDSIGNED2_ADJ    0xE0000000
#define NV_095_COMBINE_1_COLOR_MSK                         0xFFFFFFFF 
#define NV_095_COMBINE_FACTOR_BLUE_MSK                     0x000000FF /* 7:0 */ 
#define NV_095_COMBINE_FACTOR_BLUE_RMSK                    0x000000FF /* 7:0 */ 
#define NV_095_COMBINE_FACTOR_BLUE_WORD                    0
#define NV_095_COMBINE_FACTOR_BLUE_HIGH_FIELD              0x00000007 /* =7 */
#define NV_095_COMBINE_FACTOR_BLUE_LOW_FIELD               0x00000000 /* =0 */
#define NV_095_COMBINE_FACTOR_GREEN_MSK                    0x0000FF00 /* 15:8 */ 
#define NV_095_COMBINE_FACTOR_GREEN_RMSK                   0x000000FF /* 15:8 */ 
#define NV_095_COMBINE_FACTOR_GREEN_WORD                   0
#define NV_095_COMBINE_FACTOR_GREEN_HIGH_FIELD             0x0000000F /* =15 */
#define NV_095_COMBINE_FACTOR_GREEN_LOW_FIELD              0x00000008 /* =8 */
#define NV_095_COMBINE_FACTOR_RED_MSK                      0x00FF0000 /* 23:16 */ 
#define NV_095_COMBINE_FACTOR_RED_RMSK                     0x000000FF /* 23:16 */ 
#define NV_095_COMBINE_FACTOR_RED_WORD                     0
#define NV_095_COMBINE_FACTOR_RED_HIGH_FIELD               0x00000017 /* =23 */
#define NV_095_COMBINE_FACTOR_RED_LOW_FIELD                0x00000010 /* =16 */
#define NV_095_COMBINE_FACTOR_ALPHA_MSK                    0xFF000000 /* 31:24 */ 
#define NV_095_COMBINE_FACTOR_ALPHA_RMSK                   0x000000FF /* 31:24 */ 
#define NV_095_COMBINE_FACTOR_ALPHA_WORD                   0
#define NV_095_COMBINE_FACTOR_ALPHA_HIGH_FIELD             0x0000001F /* =31 */
#define NV_095_COMBINE_FACTOR_ALPHA_LOW_FIELD              0x00000018 /* =24 */
#define NV_095_COMBINE_FACTOR_MSK                          0xFFFFFFFF 
#define NV_095_BLEND_MASK_BIT_MSK                          0x0000003F /* 5:0 */ 
#define NV_095_BLEND_MASK_BIT_RMSK                         0x0000003F /* 5:0 */ 
#define NV_095_BLEND_MASK_BIT_WORD                         0
#define NV_095_BLEND_MASK_BIT_HIGH_FIELD                   0x00000005 /* =5 */
#define NV_095_BLEND_MASK_BIT_LOW_FIELD                    0x00000000 /* =0 */
#define NV_095_BLEND_MASK_BIT_LSB_ADJ                      0x00000010
#define NV_095_BLEND_MASK_BIT_MSB_ADJ                      0x00000020
#define NV_095_BLEND_SHADEMODE_MSK                         0x000000C0 /* 7:6 */ 
#define NV_095_BLEND_SHADEMODE_RMSK                        0x00000003 /* 7:6 */ 
#define NV_095_BLEND_SHADEMODE_WORD                        0
#define NV_095_BLEND_SHADEMODE_HIGH_FIELD                  0x00000007 /* =7 */
#define NV_095_BLEND_SHADEMODE_LOW_FIELD                   0x00000006 /* =6 */
#define NV_095_BLEND_SHADEMODE_FLAT_ADJ                    0x00000040
#define NV_095_BLEND_SHADEMODE_GOURAUD_ADJ                 0x00000080
#define NV_095_BLEND_SHADEMODE_PHONG_ADJ                   0x000000C0
#define NV_095_BLEND_TEXTUREPERSPECTIVE_MSK                0x00000F00 /* 11:8 */ 
#define NV_095_BLEND_TEXTUREPERSPECTIVE_RMSK               0x0000000F /* 11:8 */ 
#define NV_095_BLEND_TEXTUREPERSPECTIVE_WORD               0
#define NV_095_BLEND_TEXTUREPERSPECTIVE_HIGH_FIELD         0x0000000B /* =11 */
#define NV_095_BLEND_TEXTUREPERSPECTIVE_LOW_FIELD          0x00000008 /* =8 */
#define NV_095_BLEND_TEXTUREPERSPECTIVE_FALSE_ADJ          0x00000000
#define NV_095_BLEND_TEXTUREPERSPECTIVE_TRUE_ADJ           0x00000100
#define NV_095_BLEND_SPECULARENABLE_MSK                    0x0000F000 /* 15:12 */ 
#define NV_095_BLEND_SPECULARENABLE_RMSK                   0x0000000F /* 15:12 */ 
#define NV_095_BLEND_SPECULARENABLE_WORD                   0
#define NV_095_BLEND_SPECULARENABLE_HIGH_FIELD             0x0000000F /* =15 */
#define NV_095_BLEND_SPECULARENABLE_LOW_FIELD              0x0000000C /* =12 */
#define NV_095_BLEND_SPECULARENABLE_FALSE_ADJ              0x00000000
#define NV_095_BLEND_SPECULARENABLE_TRUE_ADJ               0x00001000
#define NV_095_BLEND_FOGENABLE_MSK                         0x000F0000 /* 19:16 */ 
#define NV_095_BLEND_FOGENABLE_RMSK                        0x0000000F /* 19:16 */ 
#define NV_095_BLEND_FOGENABLE_WORD                        0
#define NV_095_BLEND_FOGENABLE_HIGH_FIELD                  0x00000013 /* =19 */
#define NV_095_BLEND_FOGENABLE_LOW_FIELD                   0x00000010 /* =16 */
#define NV_095_BLEND_FOGENABLE_FALSE_ADJ                   0x00000000
#define NV_095_BLEND_FOGENABLE_TRUE_ADJ                    0x00010000
#define NV_095_BLEND_ALPHABLENDENABLE_MSK                  0x00F00000 /* 23:20 */ 
#define NV_095_BLEND_ALPHABLENDENABLE_RMSK                 0x0000000F /* 23:20 */ 
#define NV_095_BLEND_ALPHABLENDENABLE_WORD                 0
#define NV_095_BLEND_ALPHABLENDENABLE_HIGH_FIELD           0x00000017 /* =23 */
#define NV_095_BLEND_ALPHABLENDENABLE_LOW_FIELD            0x00000014 /* =20 */
#define NV_095_BLEND_ALPHABLENDENABLE_FALSE_ADJ            0x00000000
#define NV_095_BLEND_ALPHABLENDENABLE_TRUE_ADJ             0x00100000
#define NV_095_BLEND_SRCBLEND_MSK                          0x0F000000 /* 27:24 */ 
#define NV_095_BLEND_SRCBLEND_RMSK                         0x0000000F /* 27:24 */ 
#define NV_095_BLEND_SRCBLEND_WORD                         0
#define NV_095_BLEND_SRCBLEND_HIGH_FIELD                   0x0000001B /* =27 */
#define NV_095_BLEND_SRCBLEND_LOW_FIELD                    0x00000018 /* =24 */
#define NV_095_BLEND_SRCBLEND_ZERO_ADJ                     0x01000000
#define NV_095_BLEND_SRCBLEND_ONE_ADJ                      0x02000000
#define NV_095_BLEND_SRCBLEND_SRCCOLOR_ADJ                 0x03000000
#define NV_095_BLEND_SRCBLEND_INVSRCCOLOR_ADJ              0x04000000
#define NV_095_BLEND_SRCBLEND_SRCALPHA_ADJ                 0x05000000
#define NV_095_BLEND_SRCBLEND_INVSRCALPHA_ADJ              0x06000000
#define NV_095_BLEND_SRCBLEND_DESTALPHA_ADJ                0x07000000
#define NV_095_BLEND_SRCBLEND_INVDESTALPHA_ADJ             0x08000000
#define NV_095_BLEND_SRCBLEND_DESTCOLOR_ADJ                0x09000000
#define NV_095_BLEND_SRCBLEND_INVDESTCOLOR_ADJ             0x0A000000
#define NV_095_BLEND_SRCBLEND_SRCALPHASAT_ADJ              0x0B000000
#define NV_095_BLEND_DESTBLEND_MSK                         0xF0000000 /* 31:28 */ 
#define NV_095_BLEND_DESTBLEND_RMSK                        0x0000000F /* 31:28 */ 
#define NV_095_BLEND_DESTBLEND_WORD                        0
#define NV_095_BLEND_DESTBLEND_HIGH_FIELD                  0x0000001F /* =31 */
#define NV_095_BLEND_DESTBLEND_LOW_FIELD                   0x0000001C /* =28 */
#define NV_095_BLEND_DESTBLEND_ZERO_ADJ                    0x10000000
#define NV_095_BLEND_DESTBLEND_ONE_ADJ                     0x20000000
#define NV_095_BLEND_DESTBLEND_SRCCOLOR_ADJ                0x30000000
#define NV_095_BLEND_DESTBLEND_INVSRCCOLOR_ADJ             0x40000000
#define NV_095_BLEND_DESTBLEND_SRCALPHA_ADJ                0x50000000
#define NV_095_BLEND_DESTBLEND_INVSRCALPHA_ADJ             0x60000000
#define NV_095_BLEND_DESTBLEND_DESTALPHA_ADJ               0x70000000
#define NV_095_BLEND_DESTBLEND_INVDESTALPHA_ADJ            0x80000000
#define NV_095_BLEND_DESTBLEND_DESTCOLOR_ADJ               0x90000000
#define NV_095_BLEND_DESTBLEND_INVDESTCOLOR_ADJ            0xA0000000
#define NV_095_BLEND_DESTBLEND_SRCALPHASAT_ADJ             0xB0000000
#define NV_095_BLEND_MSK                                   0xFFFFFFFF 
#define NV_095_CONTROL0_ALPHAREF_MSK                       0x000000FF /* 7:0 */ 
#define NV_095_CONTROL0_ALPHAREF_RMSK                      0x000000FF /* 7:0 */ 
#define NV_095_CONTROL0_ALPHAREF_WORD                      0
#define NV_095_CONTROL0_ALPHAREF_HIGH_FIELD                0x00000007 /* =7 */
#define NV_095_CONTROL0_ALPHAREF_LOW_FIELD                 0x00000000 /* =0 */
#define NV_095_CONTROL0_ALPHAFUNC_MSK                      0x00000F00 /* 11:8 */ 
#define NV_095_CONTROL0_ALPHAFUNC_RMSK                     0x0000000F /* 11:8 */ 
#define NV_095_CONTROL0_ALPHAFUNC_WORD                     0
#define NV_095_CONTROL0_ALPHAFUNC_HIGH_FIELD               0x0000000B /* =11 */
#define NV_095_CONTROL0_ALPHAFUNC_LOW_FIELD                0x00000008 /* =8 */
#define NV_095_CONTROL0_ALPHAFUNC_NEVER_ADJ                0x00000100
#define NV_095_CONTROL0_ALPHAFUNC_LESS_ADJ                 0x00000200
#define NV_095_CONTROL0_ALPHAFUNC_EQUAL_ADJ                0x00000300
#define NV_095_CONTROL0_ALPHAFUNC_LESSEQUAL_ADJ            0x00000400
#define NV_095_CONTROL0_ALPHAFUNC_GREATER_ADJ              0x00000500
#define NV_095_CONTROL0_ALPHAFUNC_NOTEQUAL_ADJ             0x00000600
#define NV_095_CONTROL0_ALPHAFUNC_GREATEREQUAL_ADJ         0x00000700
#define NV_095_CONTROL0_ALPHAFUNC_ALWAYS_ADJ               0x00000800
#define NV_095_CONTROL0_ALPHATESTENABLE_MSK                0x00001000 /* 12:12 */ 
#define NV_095_CONTROL0_ALPHATESTENABLE_RMSK               0x00000001 /* 12:12 */ 
#define NV_095_CONTROL0_ALPHATESTENABLE_WORD               0
#define NV_095_CONTROL0_ALPHATESTENABLE_HIGH_FIELD         0x0000000C /* =12 */
#define NV_095_CONTROL0_ALPHATESTENABLE_LOW_FIELD          0x0000000C /* =12 */
#define NV_095_CONTROL0_ALPHATESTENABLE_FALSE_ADJ          0x00000000
#define NV_095_CONTROL0_ALPHATESTENABLE_TRUE_ADJ           0x00001000
#define NV_095_CONTROL0_ORIGIN_MSK                         0x00002000 /* 13:13 */ 
#define NV_095_CONTROL0_ORIGIN_RMSK                        0x00000001 /* 13:13 */ 
#define NV_095_CONTROL0_ORIGIN_WORD                        0
#define NV_095_CONTROL0_ORIGIN_HIGH_FIELD                  0x0000000D /* =13 */
#define NV_095_CONTROL0_ORIGIN_LOW_FIELD                   0x0000000D /* =13 */
#define NV_095_CONTROL0_ORIGIN_CENTER_ADJ                  0x00000000
#define NV_095_CONTROL0_ORIGIN_CORNER_ADJ                  0x00002000
#define NV_095_CONTROL0_ZENABLE_MSK                        0x0000C000 /* 15:14 */ 
#define NV_095_CONTROL0_ZENABLE_RMSK                       0x00000003 /* 15:14 */ 
#define NV_095_CONTROL0_ZENABLE_WORD                       0
#define NV_095_CONTROL0_ZENABLE_HIGH_FIELD                 0x0000000F /* =15 */
#define NV_095_CONTROL0_ZENABLE_LOW_FIELD                  0x0000000E /* =14 */
#define NV_095_CONTROL0_ZENABLE_FALSE_ADJ                  0x00000000
#define NV_095_CONTROL0_ZENABLE_TRUE_ADJ                   0x00004000
#define NV_095_CONTROL0_ZFUNC_MSK                          0x000F0000 /* 19:16 */ 
#define NV_095_CONTROL0_ZFUNC_RMSK                         0x0000000F /* 19:16 */ 
#define NV_095_CONTROL0_ZFUNC_WORD                         0
#define NV_095_CONTROL0_ZFUNC_HIGH_FIELD                   0x00000013 /* =19 */
#define NV_095_CONTROL0_ZFUNC_LOW_FIELD                    0x00000010 /* =16 */
#define NV_095_CONTROL0_ZFUNC_NEVER_ADJ                    0x00010000
#define NV_095_CONTROL0_ZFUNC_LESS_ADJ                     0x00020000
#define NV_095_CONTROL0_ZFUNC_EQUAL_ADJ                    0x00030000
#define NV_095_CONTROL0_ZFUNC_LESSEQUAL_ADJ                0x00040000
#define NV_095_CONTROL0_ZFUNC_GREATER_ADJ                  0x00050000
#define NV_095_CONTROL0_ZFUNC_NOTEQUAL_ADJ                 0x00060000
#define NV_095_CONTROL0_ZFUNC_GREATEREQUAL_ADJ             0x00070000
#define NV_095_CONTROL0_ZFUNC_ALWAYS_ADJ                   0x00080000
#define NV_095_CONTROL0_CULLMODE_MSK                       0x00300000 /* 21:20 */ 
#define NV_095_CONTROL0_CULLMODE_RMSK                      0x00000003 /* 21:20 */ 
#define NV_095_CONTROL0_CULLMODE_WORD                      0
#define NV_095_CONTROL0_CULLMODE_HIGH_FIELD                0x00000015 /* =21 */
#define NV_095_CONTROL0_CULLMODE_LOW_FIELD                 0x00000014 /* =20 */
#define NV_095_CONTROL0_CULLMODE_NONE_ADJ                  0x00100000
#define NV_095_CONTROL0_CULLMODE_CW_ADJ                    0x00200000
#define NV_095_CONTROL0_CULLMODE_CCW_ADJ                   0x00300000
#define NV_095_CONTROL0_DITHERENABLE_MSK                   0x00400000 /* 22:22 */ 
#define NV_095_CONTROL0_DITHERENABLE_RMSK                  0x00000001 /* 22:22 */ 
#define NV_095_CONTROL0_DITHERENABLE_WORD                  0
#define NV_095_CONTROL0_DITHERENABLE_HIGH_FIELD            0x00000016 /* =22 */
#define NV_095_CONTROL0_DITHERENABLE_LOW_FIELD             0x00000016 /* =22 */
#define NV_095_CONTROL0_DITHERENABLE_FALSE_ADJ             0x00000000
#define NV_095_CONTROL0_DITHERENABLE_TRUE_ADJ              0x00400000
#define NV_095_CONTROL0_Z_PERSPECTIVE_ENABLE_MSK           0x00800000 /* 23:23 */ 
#define NV_095_CONTROL0_Z_PERSPECTIVE_ENABLE_RMSK          0x00000001 /* 23:23 */ 
#define NV_095_CONTROL0_Z_PERSPECTIVE_ENABLE_WORD          0
#define NV_095_CONTROL0_Z_PERSPECTIVE_ENABLE_HIGH_FIELD    0x00000017 /* =23 */
#define NV_095_CONTROL0_Z_PERSPECTIVE_ENABLE_LOW_FIELD     0x00000017 /* =23 */
#define NV_095_CONTROL0_Z_PERSPECTIVE_ENABLE_FALSE_ADJ     0x00000000
#define NV_095_CONTROL0_Z_PERSPECTIVE_ENABLE_TRUE_ADJ      0x00800000
#define NV_095_CONTROL0_ZWRITEENABLE_MSK                   0x01000000 /* 24:24 */ 
#define NV_095_CONTROL0_ZWRITEENABLE_RMSK                  0x00000001 /* 24:24 */ 
#define NV_095_CONTROL0_ZWRITEENABLE_WORD                  0
#define NV_095_CONTROL0_ZWRITEENABLE_HIGH_FIELD            0x00000018 /* =24 */
#define NV_095_CONTROL0_ZWRITEENABLE_LOW_FIELD             0x00000018 /* =24 */
#define NV_095_CONTROL0_ZWRITEENABLE_FALSE_ADJ             0x00000000
#define NV_095_CONTROL0_ZWRITEENABLE_TRUE_ADJ              0x01000000
#define NV_095_CONTROL0_STENCIL_WRITE_ENABLE_MSK           0x02000000 /* 25:25 */ 
#define NV_095_CONTROL0_STENCIL_WRITE_ENABLE_RMSK          0x00000001 /* 25:25 */ 
#define NV_095_CONTROL0_STENCIL_WRITE_ENABLE_WORD          0
#define NV_095_CONTROL0_STENCIL_WRITE_ENABLE_HIGH_FIELD    0x00000019 /* =25 */
#define NV_095_CONTROL0_STENCIL_WRITE_ENABLE_LOW_FIELD     0x00000019 /* =25 */
#define NV_095_CONTROL0_STENCIL_WRITE_ENABLE_FALSE_ADJ     0x00000000
#define NV_095_CONTROL0_STENCIL_WRITE_ENABLE_TRUE_ADJ      0x02000000
#define NV_095_CONTROL0_ALPHA_WRITE_ENABLE_MSK             0x04000000 /* 26:26 */ 
#define NV_095_CONTROL0_ALPHA_WRITE_ENABLE_RMSK            0x00000001 /* 26:26 */ 
#define NV_095_CONTROL0_ALPHA_WRITE_ENABLE_WORD            0
#define NV_095_CONTROL0_ALPHA_WRITE_ENABLE_HIGH_FIELD      0x0000001A /* =26 */
#define NV_095_CONTROL0_ALPHA_WRITE_ENABLE_LOW_FIELD       0x0000001A /* =26 */
#define NV_095_CONTROL0_ALPHA_WRITE_ENABLE_FALSE_ADJ       0x00000000
#define NV_095_CONTROL0_ALPHA_WRITE_ENABLE_TRUE_ADJ        0x04000000
#define NV_095_CONTROL0_RED_WRITE_ENABLE_MSK               0x08000000 /* 27:27 */ 
#define NV_095_CONTROL0_RED_WRITE_ENABLE_RMSK              0x00000001 /* 27:27 */ 
#define NV_095_CONTROL0_RED_WRITE_ENABLE_WORD              0
#define NV_095_CONTROL0_RED_WRITE_ENABLE_HIGH_FIELD        0x0000001B /* =27 */
#define NV_095_CONTROL0_RED_WRITE_ENABLE_LOW_FIELD         0x0000001B /* =27 */
#define NV_095_CONTROL0_RED_WRITE_ENABLE_FALSE_ADJ         0x00000000
#define NV_095_CONTROL0_RED_WRITE_ENABLE_TRUE_ADJ          0x08000000
#define NV_095_CONTROL0_GREEN_WRITE_ENABLE_MSK             0x10000000 /* 28:28 */ 
#define NV_095_CONTROL0_GREEN_WRITE_ENABLE_RMSK            0x00000001 /* 28:28 */ 
#define NV_095_CONTROL0_GREEN_WRITE_ENABLE_WORD            0
#define NV_095_CONTROL0_GREEN_WRITE_ENABLE_HIGH_FIELD      0x0000001C /* =28 */
#define NV_095_CONTROL0_GREEN_WRITE_ENABLE_LOW_FIELD       0x0000001C /* =28 */
#define NV_095_CONTROL0_GREEN_WRITE_ENABLE_FALSE_ADJ       0x00000000
#define NV_095_CONTROL0_GREEN_WRITE_ENABLE_TRUE_ADJ        0x10000000
#define NV_095_CONTROL0_BLUE_WRITE_ENABLE_MSK              0x20000000 /* 29:29 */ 
#define NV_095_CONTROL0_BLUE_WRITE_ENABLE_RMSK             0x00000001 /* 29:29 */ 
#define NV_095_CONTROL0_BLUE_WRITE_ENABLE_WORD             0
#define NV_095_CONTROL0_BLUE_WRITE_ENABLE_HIGH_FIELD       0x0000001D /* =29 */
#define NV_095_CONTROL0_BLUE_WRITE_ENABLE_LOW_FIELD        0x0000001D /* =29 */
#define NV_095_CONTROL0_BLUE_WRITE_ENABLE_FALSE_ADJ        0x00000000
#define NV_095_CONTROL0_BLUE_WRITE_ENABLE_TRUE_ADJ         0x20000000
#define NV_095_CONTROL0_Z_FORMAT_MSK                       0xC0000000 /* 31:30 */ 
#define NV_095_CONTROL0_Z_FORMAT_RMSK                      0x00000003 /* 31:30 */ 
#define NV_095_CONTROL0_Z_FORMAT_WORD                      0
#define NV_095_CONTROL0_Z_FORMAT_HIGH_FIELD                0x0000001F /* =31 */
#define NV_095_CONTROL0_Z_FORMAT_LOW_FIELD                 0x0000001E /* =30 */
#define NV_095_CONTROL0_Z_FORMAT_FIXED_ADJ                 0x40000000
#define NV_095_CONTROL0_Z_FORMAT_FLOAT_ADJ                 0x80000000
#define NV_095_CONTROL0_MSK                                0xFFFFFFFF 
#define NV_095_CONTROL1_STENCIL_TEST_ENABLE_MSK            0x0000000F /* 3:0 */ 
#define NV_095_CONTROL1_STENCIL_TEST_ENABLE_RMSK           0x0000000F /* 3:0 */ 
#define NV_095_CONTROL1_STENCIL_TEST_ENABLE_WORD           0
#define NV_095_CONTROL1_STENCIL_TEST_ENABLE_HIGH_FIELD     0x00000003 /* =3 */
#define NV_095_CONTROL1_STENCIL_TEST_ENABLE_LOW_FIELD      0x00000000 /* =0 */
#define NV_095_CONTROL1_STENCIL_TEST_ENABLE_FALSE_ADJ      0x00000000
#define NV_095_CONTROL1_STENCIL_TEST_ENABLE_TRUE_ADJ       0x00000001
#define NV_095_CONTROL1_STENCIL_FUNC_MSK                   0x000000F0 /* 7:4 */ 
#define NV_095_CONTROL1_STENCIL_FUNC_RMSK                  0x0000000F /* 7:4 */ 
#define NV_095_CONTROL1_STENCIL_FUNC_WORD                  0
#define NV_095_CONTROL1_STENCIL_FUNC_HIGH_FIELD            0x00000007 /* =7 */
#define NV_095_CONTROL1_STENCIL_FUNC_LOW_FIELD             0x00000004 /* =4 */
#define NV_095_CONTROL1_STENCIL_FUNC_NEVER_ADJ             0x00000010
#define NV_095_CONTROL1_STENCIL_FUNC_LESS_ADJ              0x00000020
#define NV_095_CONTROL1_STENCIL_FUNC_EQUAL_ADJ             0x00000030
#define NV_095_CONTROL1_STENCIL_FUNC_LESSEQUAL_ADJ         0x00000040
#define NV_095_CONTROL1_STENCIL_FUNC_GREATER_ADJ           0x00000050
#define NV_095_CONTROL1_STENCIL_FUNC_NOTEQUAL_ADJ          0x00000060
#define NV_095_CONTROL1_STENCIL_FUNC_GREATEREQUAL_ADJ      0x00000070
#define NV_095_CONTROL1_STENCIL_FUNC_ALWAYS_ADJ            0x00000080
#define NV_095_CONTROL1_STENCIL_REF_MSK                    0x0000FF00 /* 15:8 */ 
#define NV_095_CONTROL1_STENCIL_REF_RMSK                   0x000000FF /* 15:8 */ 
#define NV_095_CONTROL1_STENCIL_REF_WORD                   0
#define NV_095_CONTROL1_STENCIL_REF_HIGH_FIELD             0x0000000F /* =15 */
#define NV_095_CONTROL1_STENCIL_REF_LOW_FIELD              0x00000008 /* =8 */
#define NV_095_CONTROL1_STENCIL_MASK_READ_MSK              0x00FF0000 /* 23:16 */ 
#define NV_095_CONTROL1_STENCIL_MASK_READ_RMSK             0x000000FF /* 23:16 */ 
#define NV_095_CONTROL1_STENCIL_MASK_READ_WORD             0
#define NV_095_CONTROL1_STENCIL_MASK_READ_HIGH_FIELD       0x00000017 /* =23 */
#define NV_095_CONTROL1_STENCIL_MASK_READ_LOW_FIELD        0x00000010 /* =16 */
#define NV_095_CONTROL1_STENCIL_MASK_WRITE_MSK             0xFF000000 /* 31:24 */ 
#define NV_095_CONTROL1_STENCIL_MASK_WRITE_RMSK            0x000000FF /* 31:24 */ 
#define NV_095_CONTROL1_STENCIL_MASK_WRITE_WORD            0
#define NV_095_CONTROL1_STENCIL_MASK_WRITE_HIGH_FIELD      0x0000001F /* =31 */
#define NV_095_CONTROL1_STENCIL_MASK_WRITE_LOW_FIELD       0x00000018 /* =24 */
#define NV_095_CONTROL1_MSK                                0xFFFFFFFF 
#define NV_095_CONTROL2_STENCIL_OP_FAIL_MSK                0x0000000F /* 3:0 */ 
#define NV_095_CONTROL2_STENCIL_OP_FAIL_RMSK               0x0000000F /* 3:0 */ 
#define NV_095_CONTROL2_STENCIL_OP_FAIL_WORD               0
#define NV_095_CONTROL2_STENCIL_OP_FAIL_HIGH_FIELD         0x00000003 /* =3 */
#define NV_095_CONTROL2_STENCIL_OP_FAIL_LOW_FIELD          0x00000000 /* =0 */
#define NV_095_CONTROL2_STENCIL_OP_FAIL_KEEP_ADJ           0x00000001
#define NV_095_CONTROL2_STENCIL_OP_FAIL_ZERO_ADJ           0x00000002
#define NV_095_CONTROL2_STENCIL_OP_FAIL_REPLACE_ADJ        0x00000003
#define NV_095_CONTROL2_STENCIL_OP_FAIL_INCRSAT_ADJ        0x00000004
#define NV_095_CONTROL2_STENCIL_OP_FAIL_DECRSAT_ADJ        0x00000005
#define NV_095_CONTROL2_STENCIL_OP_FAIL_INVERT_ADJ         0x00000006
#define NV_095_CONTROL2_STENCIL_OP_FAIL_INCR_ADJ           0x00000007
#define NV_095_CONTROL2_STENCIL_OP_FAIL_DECR_ADJ           0x00000008
#define NV_095_CONTROL2_STENCIL_OP_ZFAIL_MSK               0x000000F0 /* 7:4 */ 
#define NV_095_CONTROL2_STENCIL_OP_ZFAIL_RMSK              0x0000000F /* 7:4 */ 
#define NV_095_CONTROL2_STENCIL_OP_ZFAIL_WORD              0
#define NV_095_CONTROL2_STENCIL_OP_ZFAIL_HIGH_FIELD        0x00000007 /* =7 */
#define NV_095_CONTROL2_STENCIL_OP_ZFAIL_LOW_FIELD         0x00000004 /* =4 */
#define NV_095_CONTROL2_STENCIL_OP_ZFAIL_KEEP_ADJ          0x00000010
#define NV_095_CONTROL2_STENCIL_OP_ZFAIL_ZERO_ADJ          0x00000020
#define NV_095_CONTROL2_STENCIL_OP_ZFAIL_REPLACE_ADJ       0x00000030
#define NV_095_CONTROL2_STENCIL_OP_ZFAIL_INCRSAT_ADJ       0x00000040
#define NV_095_CONTROL2_STENCIL_OP_ZFAIL_DECRSAT_ADJ       0x00000050
#define NV_095_CONTROL2_STENCIL_OP_ZFAIL_INVERT_ADJ        0x00000060
#define NV_095_CONTROL2_STENCIL_OP_ZFAIL_INCR_ADJ          0x00000070
#define NV_095_CONTROL2_STENCIL_OP_ZFAIL_DECR_ADJ          0x00000080
#define NV_095_CONTROL2_STENCIL_OP_ZPASS_MSK               0xFFFFFF00 /* 31:8 */ 
#define NV_095_CONTROL2_STENCIL_OP_ZPASS_RMSK              0x00FFFFFF /* 31:8 */ 
#define NV_095_CONTROL2_STENCIL_OP_ZPASS_WORD              0
#define NV_095_CONTROL2_STENCIL_OP_ZPASS_HIGH_FIELD        0x0000001F /* =31 */
#define NV_095_CONTROL2_STENCIL_OP_ZPASS_LOW_FIELD         0x00000008 /* =8 */
#define NV_095_CONTROL2_STENCIL_OP_ZPASS_KEEP_ADJ          0x00000100
#define NV_095_CONTROL2_STENCIL_OP_ZPASS_ZERO_ADJ          0x00000200
#define NV_095_CONTROL2_STENCIL_OP_ZPASS_REPLACE_ADJ       0x00000300
#define NV_095_CONTROL2_STENCIL_OP_ZPASS_INCRSAT_ADJ       0x00000400
#define NV_095_CONTROL2_STENCIL_OP_ZPASS_DECRSAT_ADJ       0x00000500
#define NV_095_CONTROL2_STENCIL_OP_ZPASS_INVERT_ADJ        0x00000600
#define NV_095_CONTROL2_STENCIL_OP_ZPASS_INCR_ADJ          0x00000700
#define NV_095_CONTROL2_STENCIL_OP_ZPASS_DECR_ADJ          0x00000800
#define NV_095_CONTROL2_MSK                                0xFFFFFFFF 
#define NV_095_FOGCOLOR_VALUE_MSK                          0xFFFFFFFF /* 31:0 */ 
#define NV_095_FOGCOLOR_VALUE_RMSK                         0xFFFFFFFF /* 31:0 */ 
#define NV_095_FOGCOLOR_VALUE_WORD                         0
#define NV_095_FOGCOLOR_VALUE_HIGH_FIELD                   0x0000001F /* =31 */
#define NV_095_FOGCOLOR_VALUE_LOW_FIELD                    0x00000000 /* =0 */
#define NV_095_FOGCOLOR_MSK                                0xFFFFFFFF 
#define NV_095_TLMTVERTEX_SX_VALUE_MSK                     0xFFFFFFFF /* 31:0 */ 
#define NV_095_TLMTVERTEX_SX_VALUE_RMSK                    0xFFFFFFFF /* 31:0 */ 
#define NV_095_TLMTVERTEX_SX_VALUE_WORD                    0
#define NV_095_TLMTVERTEX_SX_VALUE_HIGH_FIELD              0x0000001F /* =31 */
#define NV_095_TLMTVERTEX_SX_VALUE_LOW_FIELD               0x00000000 /* =0 */
#define NV_095_TLMTVERTEX_SX_MSK                           0xFFFFFFFF 
#define NV_095_TLMTVERTEX_SY_VALUE_MSK                     0xFFFFFFFF /* 31:0 */ 
#define NV_095_TLMTVERTEX_SY_VALUE_RMSK                    0xFFFFFFFF /* 31:0 */ 
#define NV_095_TLMTVERTEX_SY_VALUE_WORD                    0
#define NV_095_TLMTVERTEX_SY_VALUE_HIGH_FIELD              0x0000001F /* =31 */
#define NV_095_TLMTVERTEX_SY_VALUE_LOW_FIELD               0x00000000 /* =0 */
#define NV_095_TLMTVERTEX_SY_MSK                           0xFFFFFFFF 
#define NV_095_TLMTVERTEX_SZ_VALUE_MSK                     0xFFFFFFFF /* 31:0 */ 
#define NV_095_TLMTVERTEX_SZ_VALUE_RMSK                    0xFFFFFFFF /* 31:0 */ 
#define NV_095_TLMTVERTEX_SZ_VALUE_WORD                    0
#define NV_095_TLMTVERTEX_SZ_VALUE_HIGH_FIELD              0x0000001F /* =31 */
#define NV_095_TLMTVERTEX_SZ_VALUE_LOW_FIELD               0x00000000 /* =0 */
#define NV_095_TLMTVERTEX_SZ_MSK                           0xFFFFFFFF 
#define NV_095_TLMTVERTEX_RHW_VALUE_MSK                    0xFFFFFFFF /* 31:0 */ 
#define NV_095_TLMTVERTEX_RHW_VALUE_RMSK                   0xFFFFFFFF /* 31:0 */ 
#define NV_095_TLMTVERTEX_RHW_VALUE_WORD                   0
#define NV_095_TLMTVERTEX_RHW_VALUE_HIGH_FIELD             0x0000001F /* =31 */
#define NV_095_TLMTVERTEX_RHW_VALUE_LOW_FIELD              0x00000000 /* =0 */
#define NV_095_TLMTVERTEX_RHW_MSK                          0xFFFFFFFF 
#define NV_095_TLMTVERTEX_COLOR_VALUE_MSK                  0xFFFFFFFF /* 31:0 */ 
#define NV_095_TLMTVERTEX_COLOR_VALUE_RMSK                 0xFFFFFFFF /* 31:0 */ 
#define NV_095_TLMTVERTEX_COLOR_VALUE_WORD                 0
#define NV_095_TLMTVERTEX_COLOR_VALUE_HIGH_FIELD           0x0000001F /* =31 */
#define NV_095_TLMTVERTEX_COLOR_VALUE_LOW_FIELD            0x00000000 /* =0 */
#define NV_095_TLMTVERTEX_COLOR_BLUE_MSK                   0x000000FF /* 7:0 */ 
#define NV_095_TLMTVERTEX_COLOR_BLUE_RMSK                  0x000000FF /* 7:0 */ 
#define NV_095_TLMTVERTEX_COLOR_BLUE_WORD                  0
#define NV_095_TLMTVERTEX_COLOR_BLUE_HIGH_FIELD            0x00000007 /* =7 */
#define NV_095_TLMTVERTEX_COLOR_BLUE_LOW_FIELD             0x00000000 /* =0 */
#define NV_095_TLMTVERTEX_COLOR_GREEN_MSK                  0x0000FF00 /* 15:8 */ 
#define NV_095_TLMTVERTEX_COLOR_GREEN_RMSK                 0x000000FF /* 15:8 */ 
#define NV_095_TLMTVERTEX_COLOR_GREEN_WORD                 0
#define NV_095_TLMTVERTEX_COLOR_GREEN_HIGH_FIELD           0x0000000F /* =15 */
#define NV_095_TLMTVERTEX_COLOR_GREEN_LOW_FIELD            0x00000008 /* =8 */
#define NV_095_TLMTVERTEX_COLOR_RED_MSK                    0x00FF0000 /* 23:16 */ 
#define NV_095_TLMTVERTEX_COLOR_RED_RMSK                   0x000000FF /* 23:16 */ 
#define NV_095_TLMTVERTEX_COLOR_RED_WORD                   0
#define NV_095_TLMTVERTEX_COLOR_RED_HIGH_FIELD             0x00000017 /* =23 */
#define NV_095_TLMTVERTEX_COLOR_RED_LOW_FIELD              0x00000010 /* =16 */
#define NV_095_TLMTVERTEX_COLOR_ALPHA_MSK                  0xFF000000 /* 31:24 */ 
#define NV_095_TLMTVERTEX_COLOR_ALPHA_RMSK                 0x000000FF /* 31:24 */ 
#define NV_095_TLMTVERTEX_COLOR_ALPHA_WORD                 0
#define NV_095_TLMTVERTEX_COLOR_ALPHA_HIGH_FIELD           0x0000001F /* =31 */
#define NV_095_TLMTVERTEX_COLOR_ALPHA_LOW_FIELD            0x00000018 /* =24 */
#define NV_095_TLMTVERTEX_COLOR_MSK                        0xFFFFFFFF 
#define NV_095_TLMTVERTEX_SPECULAR_VALUE_MSK               0xFFFFFFFF /* 31:0 */ 
#define NV_095_TLMTVERTEX_SPECULAR_VALUE_RMSK              0xFFFFFFFF /* 31:0 */ 
#define NV_095_TLMTVERTEX_SPECULAR_VALUE_WORD              0
#define NV_095_TLMTVERTEX_SPECULAR_VALUE_HIGH_FIELD        0x0000001F /* =31 */
#define NV_095_TLMTVERTEX_SPECULAR_VALUE_LOW_FIELD         0x00000000 /* =0 */
#define NV_095_TLMTVERTEX_SPECULAR_BLUE_MSK                0x000000FF /* 7:0 */ 
#define NV_095_TLMTVERTEX_SPECULAR_BLUE_RMSK               0x000000FF /* 7:0 */ 
#define NV_095_TLMTVERTEX_SPECULAR_BLUE_WORD               0
#define NV_095_TLMTVERTEX_SPECULAR_BLUE_HIGH_FIELD         0x00000007 /* =7 */
#define NV_095_TLMTVERTEX_SPECULAR_BLUE_LOW_FIELD          0x00000000 /* =0 */
#define NV_095_TLMTVERTEX_SPECULAR_GREEN_MSK               0x0000FF00 /* 15:8 */ 
#define NV_095_TLMTVERTEX_SPECULAR_GREEN_RMSK              0x000000FF /* 15:8 */ 
#define NV_095_TLMTVERTEX_SPECULAR_GREEN_WORD              0
#define NV_095_TLMTVERTEX_SPECULAR_GREEN_HIGH_FIELD        0x0000000F /* =15 */
#define NV_095_TLMTVERTEX_SPECULAR_GREEN_LOW_FIELD         0x00000008 /* =8 */
#define NV_095_TLMTVERTEX_SPECULAR_RED_MSK                 0x00FF0000 /* 23:16 */ 
#define NV_095_TLMTVERTEX_SPECULAR_RED_RMSK                0x000000FF /* 23:16 */ 
#define NV_095_TLMTVERTEX_SPECULAR_RED_WORD                0
#define NV_095_TLMTVERTEX_SPECULAR_RED_HIGH_FIELD          0x00000017 /* =23 */
#define NV_095_TLMTVERTEX_SPECULAR_RED_LOW_FIELD           0x00000010 /* =16 */
#define NV_095_TLMTVERTEX_SPECULAR_FOG_MSK                 0xFF000000 /* 31:24 */ 
#define NV_095_TLMTVERTEX_SPECULAR_FOG_RMSK                0x000000FF /* 31:24 */ 
#define NV_095_TLMTVERTEX_SPECULAR_FOG_WORD                0
#define NV_095_TLMTVERTEX_SPECULAR_FOG_HIGH_FIELD          0x0000001F /* =31 */
#define NV_095_TLMTVERTEX_SPECULAR_FOG_LOW_FIELD           0x00000018 /* =24 */
#define NV_095_TLMTVERTEX_SPECULAR_MSK                     0xFFFFFFFF 
#define NV_095_TLMTVERTEX_TU0_VALUE_MSK                    0xFFFFFFFF /* 31:0 */ 
#define NV_095_TLMTVERTEX_TU0_VALUE_RMSK                   0xFFFFFFFF /* 31:0 */ 
#define NV_095_TLMTVERTEX_TU0_VALUE_WORD                   0
#define NV_095_TLMTVERTEX_TU0_VALUE_HIGH_FIELD             0x0000001F /* =31 */
#define NV_095_TLMTVERTEX_TU0_VALUE_LOW_FIELD              0x00000000 /* =0 */
#define NV_095_TLMTVERTEX_TU0_MSK                          0xFFFFFFFF 
#define NV_095_TLMTVERTEX_TV0_VALUE_MSK                    0xFFFFFFFF /* 31:0 */ 
#define NV_095_TLMTVERTEX_TV0_VALUE_RMSK                   0xFFFFFFFF /* 31:0 */ 
#define NV_095_TLMTVERTEX_TV0_VALUE_WORD                   0
#define NV_095_TLMTVERTEX_TV0_VALUE_HIGH_FIELD             0x0000001F /* =31 */
#define NV_095_TLMTVERTEX_TV0_VALUE_LOW_FIELD              0x00000000 /* =0 */
#define NV_095_TLMTVERTEX_TV0_MSK                          0xFFFFFFFF 
#define NV_095_TLMTVERTEX_TU1_VALUE_MSK                    0xFFFFFFFF /* 31:0 */ 
#define NV_095_TLMTVERTEX_TU1_VALUE_RMSK                   0xFFFFFFFF /* 31:0 */ 
#define NV_095_TLMTVERTEX_TU1_VALUE_WORD                   0
#define NV_095_TLMTVERTEX_TU1_VALUE_HIGH_FIELD             0x0000001F /* =31 */
#define NV_095_TLMTVERTEX_TU1_VALUE_LOW_FIELD              0x00000000 /* =0 */
#define NV_095_TLMTVERTEX_TU1_MSK                          0xFFFFFFFF 
#define NV_095_TLMTVERTEX_TV1_VALUE_MSK                    0xFFFFFFFF /* 31:0 */ 
#define NV_095_TLMTVERTEX_TV1_VALUE_RMSK                   0xFFFFFFFF /* 31:0 */ 
#define NV_095_TLMTVERTEX_TV1_VALUE_WORD                   0
#define NV_095_TLMTVERTEX_TV1_VALUE_HIGH_FIELD             0x0000001F /* =31 */
#define NV_095_TLMTVERTEX_TV1_VALUE_LOW_FIELD              0x00000000 /* =0 */
#define NV_095_TLMTVERTEX_TV1_MSK                          0xFFFFFFFF 
#define NV_095_TLMTVERTEX_DRAWPRIMITIVE_I0_MSK             0x0000000F /* 3:0 */ 
#define NV_095_TLMTVERTEX_DRAWPRIMITIVE_I0_RMSK            0x0000000F /* 3:0 */ 
#define NV_095_TLMTVERTEX_DRAWPRIMITIVE_I0_WORD            0
#define NV_095_TLMTVERTEX_DRAWPRIMITIVE_I0_HIGH_FIELD      0x00000003 /* =3 */
#define NV_095_TLMTVERTEX_DRAWPRIMITIVE_I0_LOW_FIELD       0x00000000 /* =0 */
#define NV_095_TLMTVERTEX_DRAWPRIMITIVE_I1_MSK             0x000000F0 /* 7:4 */ 
#define NV_095_TLMTVERTEX_DRAWPRIMITIVE_I1_RMSK            0x0000000F /* 7:4 */ 
#define NV_095_TLMTVERTEX_DRAWPRIMITIVE_I1_WORD            0
#define NV_095_TLMTVERTEX_DRAWPRIMITIVE_I1_HIGH_FIELD      0x00000007 /* =7 */
#define NV_095_TLMTVERTEX_DRAWPRIMITIVE_I1_LOW_FIELD       0x00000004 /* =4 */
#define NV_095_TLMTVERTEX_DRAWPRIMITIVE_I2_MSK             0x00000F00 /* 11:8 */ 
#define NV_095_TLMTVERTEX_DRAWPRIMITIVE_I2_RMSK            0x0000000F /* 11:8 */ 
#define NV_095_TLMTVERTEX_DRAWPRIMITIVE_I2_WORD            0
#define NV_095_TLMTVERTEX_DRAWPRIMITIVE_I2_HIGH_FIELD      0x0000000B /* =11 */
#define NV_095_TLMTVERTEX_DRAWPRIMITIVE_I2_LOW_FIELD       0x00000008 /* =8 */
#define NV_095_TLMTVERTEX_DRAWPRIMITIVE_I3_MSK             0x0000F000 /* 15:12 */ 
#define NV_095_TLMTVERTEX_DRAWPRIMITIVE_I3_RMSK            0x0000000F /* 15:12 */ 
#define NV_095_TLMTVERTEX_DRAWPRIMITIVE_I3_WORD            0
#define NV_095_TLMTVERTEX_DRAWPRIMITIVE_I3_HIGH_FIELD      0x0000000F /* =15 */
#define NV_095_TLMTVERTEX_DRAWPRIMITIVE_I3_LOW_FIELD       0x0000000C /* =12 */
#define NV_095_TLMTVERTEX_DRAWPRIMITIVE_I4_MSK             0x000F0000 /* 19:16 */ 
#define NV_095_TLMTVERTEX_DRAWPRIMITIVE_I4_RMSK            0x0000000F /* 19:16 */ 
#define NV_095_TLMTVERTEX_DRAWPRIMITIVE_I4_WORD            0
#define NV_095_TLMTVERTEX_DRAWPRIMITIVE_I4_HIGH_FIELD      0x00000013 /* =19 */
#define NV_095_TLMTVERTEX_DRAWPRIMITIVE_I4_LOW_FIELD       0x00000010 /* =16 */
#define NV_095_TLMTVERTEX_DRAWPRIMITIVE_I5_MSK             0xFFF00000 /* 31:20 */ 
#define NV_095_TLMTVERTEX_DRAWPRIMITIVE_I5_RMSK            0x00000FFF /* 31:20 */ 
#define NV_095_TLMTVERTEX_DRAWPRIMITIVE_I5_WORD            0
#define NV_095_TLMTVERTEX_DRAWPRIMITIVE_I5_HIGH_FIELD      0x0000001F /* =31 */
#define NV_095_TLMTVERTEX_DRAWPRIMITIVE_I5_LOW_FIELD       0x00000014 /* =20 */
#define NV_095_TLMTVERTEX_DRAWPRIMITIVE_MSK                0xFFFFFFFF 
#define NV_056_HIGH_FIELD                                  0x006C1FFF /* =7086079 */
#define NV_056_LOW_FIELD                                   0x006C0000 /* =7077888 */
#define NV_056_NV10_CELSIUS_PRIMITIVE_ADJ                  0x006C0000
#define NV_056_NV10_CELSIUS_PRIMITIVE_HANDLE_MSK           0xFFFFFFFF /* 31:0 */ 
#define NV_056_NV10_CELSIUS_PRIMITIVE_HANDLE_RMSK          0xFFFFFFFF /* 31:0 */ 
#define NV_056_NV10_CELSIUS_PRIMITIVE_HANDLE_WORD          0
#define NV_056_NV10_CELSIUS_PRIMITIVE_HANDLE_HIGH_FIELD    0x0000001F /* =31 */
#define NV_056_NV10_CELSIUS_PRIMITIVE_HANDLE_LOW_FIELD     0x00000000 /* =0 */
#define NV_056_NV10_CELSIUS_PRIMITIVE_MSK                  0xFFFFFFFF 
#define NV_056_DEBUG_INIT_MSK                              0x00000000 
#define NV_056_FLUSH_MSK                                   0x00000000 
#define NV_056_NO_OPERATION_MSK                            0x00000000 
#define NV_056_NOTIFY_TYPE_MSK                             0xFFFFFFFF /* 31:0 */ 
#define NV_056_NOTIFY_TYPE_RMSK                            0xFFFFFFFF /* 31:0 */ 
#define NV_056_NOTIFY_TYPE_WORD                            0
#define NV_056_NOTIFY_TYPE_HIGH_FIELD                      0x0000001F /* =31 */
#define NV_056_NOTIFY_TYPE_LOW_FIELD                       0x00000000 /* =0 */
#define NV_056_NOTIFY_TYPE_WRITE_ONLY_ADJ                  0x00000000
#define NV_056_NOTIFY_TYPE_WRITE_THEN_AWAKEN_ADJ           0x00000001
#define NV_056_NOTIFY_MSK                                  0xFFFFFFFF 
#define NV_056_SET_WARNING_ENABLE_V_MSK                    0xFFFFFFFF /* 31:0 */ 
#define NV_056_SET_WARNING_ENABLE_V_RMSK                   0xFFFFFFFF /* 31:0 */ 
#define NV_056_SET_WARNING_ENABLE_V_WORD                   0
#define NV_056_SET_WARNING_ENABLE_V_HIGH_FIELD             0x0000001F /* =31 */
#define NV_056_SET_WARNING_ENABLE_V_LOW_FIELD              0x00000000 /* =0 */
#define NV_056_SET_WARNING_ENABLE_V_FALSE_ADJ              0x00000000
#define NV_056_SET_WARNING_ENABLE_V_TRUE_ADJ               0x00000001
#define NV_056_SET_WARNING_ENABLE_MSK                      0xFFFFFFFF 
#define NV_056_GET_STATE_GETSTATE_MSK                      0xFFFFFFFF /* 31:0 */ 
#define NV_056_GET_STATE_GETSTATE_RMSK                     0xFFFFFFFF /* 31:0 */ 
#define NV_056_GET_STATE_GETSTATE_WORD                     0
#define NV_056_GET_STATE_GETSTATE_HIGH_FIELD               0x0000001F /* =31 */
#define NV_056_GET_STATE_GETSTATE_LOW_FIELD                0x00000000 /* =0 */
#define NV_056_GET_STATE_GETSTATE_ALL_STATE_ADJ            0x00000001
#define NV_056_GET_STATE_GETSTATE_TRANSFORMLIGHTING_STATE_ADJ 0x00000002
#define NV_056_GET_STATE_GETSTATE_RENDERING_STATE_ADJ      0x00000003
#define NV_056_GET_STATE_GETSTATE_GEOMETRY_STATE_ADJ       0x00000004
#define NV_056_GET_STATE_MSK                               0xFFFFFFFF 
#define NV_056_WAIT_FOR_IDLE_MSK                           0x00000000 
#define NV_056_PM_TRIGGER_MSK                              0x00000000 
#define NV_056_SET_CONTEXT_DMA_NOTIFIES_MSK                0x00000000 
#define NV_056_SET_CONTEXT_DMA_A_MSK                       0x00000000 
#define NV_056_SET_CONTEXT_DMA_B_MSK                       0x00000000 
#define NV_056_SET_CONTEXT_DMA_VERTEX_MSK                  0x00000000 
#define NV_056_SET_CONTEXT_DMA_STATE_MSK                   0x00000000 
#define NV_056_SET_CONTEXT_DMA_COLOR_MSK                   0x00000000 
#define NV_056_SET_CONTEXT_DMA_ZETA_MSK                    0x00000000 
#define NV_056_SET_SURFACE_CLIP_HORIZONTAL_X_MSK           0x0000FFFF /* 15:0 */ 
#define NV_056_SET_SURFACE_CLIP_HORIZONTAL_X_RMSK          0x0000FFFF /* 15:0 */ 
#define NV_056_SET_SURFACE_CLIP_HORIZONTAL_X_WORD          0
#define NV_056_SET_SURFACE_CLIP_HORIZONTAL_X_HIGH_FIELD    0x0000000F /* =15 */
#define NV_056_SET_SURFACE_CLIP_HORIZONTAL_X_LOW_FIELD     0x00000000 /* =0 */
#define NV_056_SET_SURFACE_CLIP_HORIZONTAL_WIDTH_MSK       0xFFFF0000 /* 31:16 */ 
#define NV_056_SET_SURFACE_CLIP_HORIZONTAL_WIDTH_RMSK      0x0000FFFF /* 31:16 */ 
#define NV_056_SET_SURFACE_CLIP_HORIZONTAL_WIDTH_WORD      0
#define NV_056_SET_SURFACE_CLIP_HORIZONTAL_WIDTH_HIGH_FIELD 0x0000001F /* =31 */
#define NV_056_SET_SURFACE_CLIP_HORIZONTAL_WIDTH_LOW_FIELD 0x00000010 /* =16 */
#define NV_056_SET_SURFACE_CLIP_HORIZONTAL_MSK             0xFFFFFFFF 
#define NV_056_SET_SURFACE_CLIP_VERTICAL_Y_MSK             0x0000FFFF /* 15:0 */ 
#define NV_056_SET_SURFACE_CLIP_VERTICAL_Y_RMSK            0x0000FFFF /* 15:0 */ 
#define NV_056_SET_SURFACE_CLIP_VERTICAL_Y_WORD            0
#define NV_056_SET_SURFACE_CLIP_VERTICAL_Y_HIGH_FIELD      0x0000000F /* =15 */
#define NV_056_SET_SURFACE_CLIP_VERTICAL_Y_LOW_FIELD       0x00000000 /* =0 */
#define NV_056_SET_SURFACE_CLIP_VERTICAL_HEIGHT_MSK        0xFFFF0000 /* 31:16 */ 
#define NV_056_SET_SURFACE_CLIP_VERTICAL_HEIGHT_RMSK       0x0000FFFF /* 31:16 */ 
#define NV_056_SET_SURFACE_CLIP_VERTICAL_HEIGHT_WORD       0
#define NV_056_SET_SURFACE_CLIP_VERTICAL_HEIGHT_HIGH_FIELD 0x0000001F /* =31 */
#define NV_056_SET_SURFACE_CLIP_VERTICAL_HEIGHT_LOW_FIELD  0x00000010 /* =16 */
#define NV_056_SET_SURFACE_CLIP_VERTICAL_MSK               0xFFFFFFFF 
#define NV_056_SET_SURFACE_FORMAT_COLOR_MSK                0x000000FF /* 7:0 */ 
#define NV_056_SET_SURFACE_FORMAT_COLOR_RMSK               0x000000FF /* 7:0 */ 
#define NV_056_SET_SURFACE_FORMAT_COLOR_WORD               0
#define NV_056_SET_SURFACE_FORMAT_COLOR_HIGH_FIELD         0x00000007 /* =7 */
#define NV_056_SET_SURFACE_FORMAT_COLOR_LOW_FIELD          0x00000000 /* =0 */
#define NV_056_SET_SURFACE_FORMAT_COLOR_LE_X1R5G5B5_Z1R5G5B5_ADJ 0x00000001
#define NV_056_SET_SURFACE_FORMAT_COLOR_LE_X1R5G5B5_O1R5G5B5_ADJ 0x00000002
#define NV_056_SET_SURFACE_FORMAT_COLOR_LE_R5G6B5_ADJ      0x00000003
#define NV_056_SET_SURFACE_FORMAT_COLOR_LE_X8R8G8B8_Z8R8G8B8_ADJ 0x00000004
#define NV_056_SET_SURFACE_FORMAT_COLOR_LE_X8R8G8B8_O8R8G8B8_ADJ 0x00000005
#define NV_056_SET_SURFACE_FORMAT_COLOR_LE_X1A7R8G8B8_Z1A7R8G8B8_ADJ 0x00000006
#define NV_056_SET_SURFACE_FORMAT_COLOR_LE_X1A7R8G8B8_O1A7R8G8B8_ADJ 0x00000007
#define NV_056_SET_SURFACE_FORMAT_COLOR_LE_A8R8G8B8_ADJ    0x00000008
#define NV_056_SET_SURFACE_FORMAT_COLOR_LE_B8_ADJ          0x00000009
#define NV_056_SET_SURFACE_FORMAT_COLOR_LE_G8B8_ADJ        0x0000000A
#define NV_056_SET_SURFACE_FORMAT_TYPE_MSK                 0x0000FF00 /* 15:8 */ 
#define NV_056_SET_SURFACE_FORMAT_TYPE_RMSK                0x000000FF /* 15:8 */ 
#define NV_056_SET_SURFACE_FORMAT_TYPE_WORD                0
#define NV_056_SET_SURFACE_FORMAT_TYPE_HIGH_FIELD          0x0000000F /* =15 */
#define NV_056_SET_SURFACE_FORMAT_TYPE_LOW_FIELD           0x00000008 /* =8 */
#define NV_056_SET_SURFACE_FORMAT_TYPE_PITCH_ADJ           0x00000100
#define NV_056_SET_SURFACE_FORMAT_TYPE_SWIZZLE_ADJ         0x00000200
#define NV_056_SET_SURFACE_FORMAT_WIDTH_MSK                0x00FF0000 /* 23:16 */ 
#define NV_056_SET_SURFACE_FORMAT_WIDTH_RMSK               0x000000FF /* 23:16 */ 
#define NV_056_SET_SURFACE_FORMAT_WIDTH_WORD               0
#define NV_056_SET_SURFACE_FORMAT_WIDTH_HIGH_FIELD         0x00000017 /* =23 */
#define NV_056_SET_SURFACE_FORMAT_WIDTH_LOW_FIELD          0x00000010 /* =16 */
#define NV_056_SET_SURFACE_FORMAT_WIDTH_1_ADJ              0x00000000
#define NV_056_SET_SURFACE_FORMAT_WIDTH_2_ADJ              0x00010000
#define NV_056_SET_SURFACE_FORMAT_WIDTH_4_ADJ              0x00020000
#define NV_056_SET_SURFACE_FORMAT_WIDTH_8_ADJ              0x00030000
#define NV_056_SET_SURFACE_FORMAT_WIDTH_16_ADJ             0x00040000
#define NV_056_SET_SURFACE_FORMAT_WIDTH_32_ADJ             0x00050000
#define NV_056_SET_SURFACE_FORMAT_WIDTH_64_ADJ             0x00060000
#define NV_056_SET_SURFACE_FORMAT_WIDTH_128_ADJ            0x00070000
#define NV_056_SET_SURFACE_FORMAT_WIDTH_256_ADJ            0x00080000
#define NV_056_SET_SURFACE_FORMAT_WIDTH_512_ADJ            0x00090000
#define NV_056_SET_SURFACE_FORMAT_WIDTH_1024_ADJ           0x000A0000
#define NV_056_SET_SURFACE_FORMAT_WIDTH_2048_ADJ           0x000B0000
#define NV_056_SET_SURFACE_FORMAT_HEIGHT_MSK               0xFF000000 /* 31:24 */ 
#define NV_056_SET_SURFACE_FORMAT_HEIGHT_RMSK              0x000000FF /* 31:24 */ 
#define NV_056_SET_SURFACE_FORMAT_HEIGHT_WORD              0
#define NV_056_SET_SURFACE_FORMAT_HEIGHT_HIGH_FIELD        0x0000001F /* =31 */
#define NV_056_SET_SURFACE_FORMAT_HEIGHT_LOW_FIELD         0x00000018 /* =24 */
#define NV_056_SET_SURFACE_FORMAT_HEIGHT_1_ADJ             0x00000000
#define NV_056_SET_SURFACE_FORMAT_HEIGHT_2_ADJ             0x01000000
#define NV_056_SET_SURFACE_FORMAT_HEIGHT_4_ADJ             0x02000000
#define NV_056_SET_SURFACE_FORMAT_HEIGHT_8_ADJ             0x03000000
#define NV_056_SET_SURFACE_FORMAT_HEIGHT_16_ADJ            0x04000000
#define NV_056_SET_SURFACE_FORMAT_HEIGHT_32_ADJ            0x05000000
#define NV_056_SET_SURFACE_FORMAT_HEIGHT_64_ADJ            0x06000000
#define NV_056_SET_SURFACE_FORMAT_HEIGHT_128_ADJ           0x07000000
#define NV_056_SET_SURFACE_FORMAT_HEIGHT_256_ADJ           0x08000000
#define NV_056_SET_SURFACE_FORMAT_HEIGHT_512_ADJ           0x09000000
#define NV_056_SET_SURFACE_FORMAT_HEIGHT_1024_ADJ          0x0A000000
#define NV_056_SET_SURFACE_FORMAT_HEIGHT_2048_ADJ          0x0B000000
#define NV_056_SET_SURFACE_FORMAT_MSK                      0xFFFFFFFF 
#define NV_056_SET_SURFACE_PITCH_COLOR_MSK                 0x0000FFFF /* 15:0 */ 
#define NV_056_SET_SURFACE_PITCH_COLOR_RMSK                0x0000FFFF /* 15:0 */ 
#define NV_056_SET_SURFACE_PITCH_COLOR_WORD                0
#define NV_056_SET_SURFACE_PITCH_COLOR_HIGH_FIELD          0x0000000F /* =15 */
#define NV_056_SET_SURFACE_PITCH_COLOR_LOW_FIELD           0x00000000 /* =0 */
#define NV_056_SET_SURFACE_PITCH_ZETA_MSK                  0xFFFF0000 /* 31:16 */ 
#define NV_056_SET_SURFACE_PITCH_ZETA_RMSK                 0x0000FFFF /* 31:16 */ 
#define NV_056_SET_SURFACE_PITCH_ZETA_WORD                 0
#define NV_056_SET_SURFACE_PITCH_ZETA_HIGH_FIELD           0x0000001F /* =31 */
#define NV_056_SET_SURFACE_PITCH_ZETA_LOW_FIELD            0x00000010 /* =16 */
#define NV_056_SET_SURFACE_PITCH_MSK                       0xFFFFFFFF 
#define NV_056_SET_SURFACE_COLOR_OFFSET_V_MSK              0xFFFFFFFF /* 31:0 */ 
#define NV_056_SET_SURFACE_COLOR_OFFSET_V_RMSK             0xFFFFFFFF /* 31:0 */ 
#define NV_056_SET_SURFACE_COLOR_OFFSET_V_WORD             0
#define NV_056_SET_SURFACE_COLOR_OFFSET_V_HIGH_FIELD       0x0000001F /* =31 */
#define NV_056_SET_SURFACE_COLOR_OFFSET_V_LOW_FIELD        0x00000000 /* =0 */
#define NV_056_SET_SURFACE_COLOR_OFFSET_MSK                0xFFFFFFFF 
#define NV_056_SET_SURFACE_ZETA_OFFSET_V_MSK               0xFFFFFFFF /* 31:0 */ 
#define NV_056_SET_SURFACE_ZETA_OFFSET_V_RMSK              0xFFFFFFFF /* 31:0 */ 
#define NV_056_SET_SURFACE_ZETA_OFFSET_V_WORD              0
#define NV_056_SET_SURFACE_ZETA_OFFSET_V_HIGH_FIELD        0x0000001F /* =31 */
#define NV_056_SET_SURFACE_ZETA_OFFSET_V_LOW_FIELD         0x00000000 /* =0 */
#define NV_056_SET_SURFACE_ZETA_OFFSET_MSK                 0xFFFFFFFF 
#define NV_056_SET_TEXTURE_OFFSET_V_MSK                    0xFFFFFFFF /* 31:0 */ 
#define NV_056_SET_TEXTURE_OFFSET_V_RMSK                   0xFFFFFFFF /* 31:0 */ 
#define NV_056_SET_TEXTURE_OFFSET_V_WORD                   0
#define NV_056_SET_TEXTURE_OFFSET_V_HIGH_FIELD             0x0000001F /* =31 */
#define NV_056_SET_TEXTURE_OFFSET_V_LOW_FIELD              0x00000000 /* =0 */
#define NV_056_SET_TEXTURE_OFFSET_MSK                      0xFFFFFFFF 
#define NV_056_SET_TEXTURE_FORMAT_CONTEXT_DMA_MSK          0x00000003 /* 1:0 */ 
#define NV_056_SET_TEXTURE_FORMAT_CONTEXT_DMA_RMSK         0x00000003 /* 1:0 */ 
#define NV_056_SET_TEXTURE_FORMAT_CONTEXT_DMA_WORD         0
#define NV_056_SET_TEXTURE_FORMAT_CONTEXT_DMA_HIGH_FIELD   0x00000001 /* =1 */
#define NV_056_SET_TEXTURE_FORMAT_CONTEXT_DMA_LOW_FIELD    0x00000000 /* =0 */
#define NV_056_SET_TEXTURE_FORMAT_CONTEXT_DMA_A_ADJ        0x00000001
#define NV_056_SET_TEXTURE_FORMAT_CONTEXT_DMA_B_ADJ        0x00000002
#define NV_056_SET_TEXTURE_FORMAT_CUBEMAP_ENABLE_MSK       0x00000004 /* 2:2 */ 
#define NV_056_SET_TEXTURE_FORMAT_CUBEMAP_ENABLE_RMSK      0x00000001 /* 2:2 */ 
#define NV_056_SET_TEXTURE_FORMAT_CUBEMAP_ENABLE_WORD      0
#define NV_056_SET_TEXTURE_FORMAT_CUBEMAP_ENABLE_HIGH_FIELD 0x00000002 /* =2 */
#define NV_056_SET_TEXTURE_FORMAT_CUBEMAP_ENABLE_LOW_FIELD 0x00000002 /* =2 */
#define NV_056_SET_TEXTURE_FORMAT_CUBEMAP_ENABLE_FALSE_ADJ 0x00000000
#define NV_056_SET_TEXTURE_FORMAT_CUBEMAP_ENABLE_TRUE_ADJ  0x00000004
#define NV_056_SET_TEXTURE_FORMAT_ORIGIN_ZOH_MSK           0x00000018 /* 4:3 */ 
#define NV_056_SET_TEXTURE_FORMAT_ORIGIN_ZOH_RMSK          0x00000003 /* 4:3 */ 
#define NV_056_SET_TEXTURE_FORMAT_ORIGIN_ZOH_WORD          0
#define NV_056_SET_TEXTURE_FORMAT_ORIGIN_ZOH_HIGH_FIELD    0x00000004 /* =4 */
#define NV_056_SET_TEXTURE_FORMAT_ORIGIN_ZOH_LOW_FIELD     0x00000003 /* =3 */
#define NV_056_SET_TEXTURE_FORMAT_ORIGIN_ZOH_CENTER_ADJ    0x00000008
#define NV_056_SET_TEXTURE_FORMAT_ORIGIN_ZOH_CORNER_ADJ    0x00000010
#define NV_056_SET_TEXTURE_FORMAT_ORIGIN_FOH_MSK           0x00000060 /* 6:5 */ 
#define NV_056_SET_TEXTURE_FORMAT_ORIGIN_FOH_RMSK          0x00000003 /* 6:5 */ 
#define NV_056_SET_TEXTURE_FORMAT_ORIGIN_FOH_WORD          0
#define NV_056_SET_TEXTURE_FORMAT_ORIGIN_FOH_HIGH_FIELD    0x00000006 /* =6 */
#define NV_056_SET_TEXTURE_FORMAT_ORIGIN_FOH_LOW_FIELD     0x00000005 /* =5 */
#define NV_056_SET_TEXTURE_FORMAT_ORIGIN_FOH_CENTER_ADJ    0x00000020
#define NV_056_SET_TEXTURE_FORMAT_ORIGIN_FOH_CORNER_ADJ    0x00000040
#define NV_056_SET_TEXTURE_FORMAT_COLOR_MSK                0x00000F80 /* 11:7 */ 
#define NV_056_SET_TEXTURE_FORMAT_COLOR_RMSK               0x0000001F /* 11:7 */ 
#define NV_056_SET_TEXTURE_FORMAT_COLOR_WORD               0
#define NV_056_SET_TEXTURE_FORMAT_COLOR_HIGH_FIELD         0x0000000B /* =11 */
#define NV_056_SET_TEXTURE_FORMAT_COLOR_LOW_FIELD          0x00000007 /* =7 */
#define NV_056_SET_TEXTURE_FORMAT_COLOR_LE_Y8_ADJ          0x00000000
#define NV_056_SET_TEXTURE_FORMAT_COLOR_LE_AY8_ADJ         0x00000080
#define NV_056_SET_TEXTURE_FORMAT_COLOR_LE_A1R5G5B5_ADJ    0x00000100
#define NV_056_SET_TEXTURE_FORMAT_COLOR_LE_X1R5G5B5_ADJ    0x00000180
#define NV_056_SET_TEXTURE_FORMAT_COLOR_LE_A4R4G4B4_ADJ    0x00000200
#define NV_056_SET_TEXTURE_FORMAT_COLOR_LE_R5G6B5_ADJ      0x00000280
#define NV_056_SET_TEXTURE_FORMAT_COLOR_LE_A8R8G8B8_ADJ    0x00000300
#define NV_056_SET_TEXTURE_FORMAT_COLOR_LE_X8R8G8B8_ADJ    0x00000380
#define NV_056_SET_TEXTURE_FORMAT_COLOR_LE_I8_A1R5G5B5_ADJ 0x00000400
#define NV_056_SET_TEXTURE_FORMAT_COLOR_LE_I8_R5G6B5_ADJ   0x00000480
#define NV_056_SET_TEXTURE_FORMAT_COLOR_LE_I8_A4R4G4B4_ADJ 0x00000500
#define NV_056_SET_TEXTURE_FORMAT_COLOR_LE_I8_A8R8G8B8_ADJ 0x00000580
#define NV_056_SET_TEXTURE_FORMAT_COLOR_LE_DXT1_A1R5G5B5_ADJ 0x00000600
#define NV_056_SET_TEXTURE_FORMAT_COLOR_LE_DXT23_A8R8G8B8_ADJ 0x00000700
#define NV_056_SET_TEXTURE_FORMAT_COLOR_LE_DXT45_A8R8G8B8_ADJ 0x00000780
#define NV_056_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_A1R5G5B5_ADJ 0x00000800
#define NV_056_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_R5G6B5_ADJ 0x00000880
#define NV_056_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_A8R8G8B8_ADJ 0x00000900
#define NV_056_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_Y8_ADJ    0x00000980
#define NV_056_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_SY8_ADJ   0x00000A00
#define NV_056_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_X7SY9_ADJ 0x00000A80
#define NV_056_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_R8B8_ADJ  0x00000B00
#define NV_056_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_G8B8_ADJ  0x00000B80
#define NV_056_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_SG8SB8_ADJ 0x00000C00
#define NV_056_SET_TEXTURE_FORMAT_MIPMAP_LEVELS_MSK        0x0000F000 /* 15:12 */ 
#define NV_056_SET_TEXTURE_FORMAT_MIPMAP_LEVELS_RMSK       0x0000000F /* 15:12 */ 
#define NV_056_SET_TEXTURE_FORMAT_MIPMAP_LEVELS_WORD       0
#define NV_056_SET_TEXTURE_FORMAT_MIPMAP_LEVELS_HIGH_FIELD 0x0000000F /* =15 */
#define NV_056_SET_TEXTURE_FORMAT_MIPMAP_LEVELS_LOW_FIELD  0x0000000C /* =12 */
#define NV_056_SET_TEXTURE_FORMAT_BASE_SIZE_U_MSK          0x000F0000 /* 19:16 */ 
#define NV_056_SET_TEXTURE_FORMAT_BASE_SIZE_U_RMSK         0x0000000F /* 19:16 */ 
#define NV_056_SET_TEXTURE_FORMAT_BASE_SIZE_U_WORD         0
#define NV_056_SET_TEXTURE_FORMAT_BASE_SIZE_U_HIGH_FIELD   0x00000013 /* =19 */
#define NV_056_SET_TEXTURE_FORMAT_BASE_SIZE_U_LOW_FIELD    0x00000010 /* =16 */
#define NV_056_SET_TEXTURE_FORMAT_BASE_SIZE_U_1_ADJ        0x00000000
#define NV_056_SET_TEXTURE_FORMAT_BASE_SIZE_U_2_ADJ        0x00010000
#define NV_056_SET_TEXTURE_FORMAT_BASE_SIZE_U_4_ADJ        0x00020000
#define NV_056_SET_TEXTURE_FORMAT_BASE_SIZE_U_8_ADJ        0x00030000
#define NV_056_SET_TEXTURE_FORMAT_BASE_SIZE_U_16_ADJ       0x00040000
#define NV_056_SET_TEXTURE_FORMAT_BASE_SIZE_U_32_ADJ       0x00050000
#define NV_056_SET_TEXTURE_FORMAT_BASE_SIZE_U_64_ADJ       0x00060000
#define NV_056_SET_TEXTURE_FORMAT_BASE_SIZE_U_128_ADJ      0x00070000
#define NV_056_SET_TEXTURE_FORMAT_BASE_SIZE_U_256_ADJ      0x00080000
#define NV_056_SET_TEXTURE_FORMAT_BASE_SIZE_U_512_ADJ      0x00090000
#define NV_056_SET_TEXTURE_FORMAT_BASE_SIZE_U_1024_ADJ     0x000A0000
#define NV_056_SET_TEXTURE_FORMAT_BASE_SIZE_U_2048_ADJ     0x000B0000
#define NV_056_SET_TEXTURE_FORMAT_BASE_SIZE_V_MSK          0x00F00000 /* 23:20 */ 
#define NV_056_SET_TEXTURE_FORMAT_BASE_SIZE_V_RMSK         0x0000000F /* 23:20 */ 
#define NV_056_SET_TEXTURE_FORMAT_BASE_SIZE_V_WORD         0
#define NV_056_SET_TEXTURE_FORMAT_BASE_SIZE_V_HIGH_FIELD   0x00000017 /* =23 */
#define NV_056_SET_TEXTURE_FORMAT_BASE_SIZE_V_LOW_FIELD    0x00000014 /* =20 */
#define NV_056_SET_TEXTURE_FORMAT_BASE_SIZE_V_1_ADJ        0x00000000
#define NV_056_SET_TEXTURE_FORMAT_BASE_SIZE_V_2_ADJ        0x00100000
#define NV_056_SET_TEXTURE_FORMAT_BASE_SIZE_V_4_ADJ        0x00200000
#define NV_056_SET_TEXTURE_FORMAT_BASE_SIZE_V_8_ADJ        0x00300000
#define NV_056_SET_TEXTURE_FORMAT_BASE_SIZE_V_16_ADJ       0x00400000
#define NV_056_SET_TEXTURE_FORMAT_BASE_SIZE_V_32_ADJ       0x00500000
#define NV_056_SET_TEXTURE_FORMAT_BASE_SIZE_V_64_ADJ       0x00600000
#define NV_056_SET_TEXTURE_FORMAT_BASE_SIZE_V_128_ADJ      0x00700000
#define NV_056_SET_TEXTURE_FORMAT_BASE_SIZE_V_256_ADJ      0x00800000
#define NV_056_SET_TEXTURE_FORMAT_BASE_SIZE_V_512_ADJ      0x00900000
#define NV_056_SET_TEXTURE_FORMAT_BASE_SIZE_V_1024_ADJ     0x00A00000
#define NV_056_SET_TEXTURE_FORMAT_BASE_SIZE_V_2048_ADJ     0x00B00000
#define NV_056_SET_TEXTURE_FORMAT_TEXTUREADDRESSU_MSK      0x07000000 /* 26:24 */ 
#define NV_056_SET_TEXTURE_FORMAT_TEXTUREADDRESSU_RMSK     0x00000007 /* 26:24 */ 
#define NV_056_SET_TEXTURE_FORMAT_TEXTUREADDRESSU_WORD     0
#define NV_056_SET_TEXTURE_FORMAT_TEXTUREADDRESSU_HIGH_FIELD 0x0000001A /* =26 */
#define NV_056_SET_TEXTURE_FORMAT_TEXTUREADDRESSU_LOW_FIELD 0x00000018 /* =24 */
#define NV_056_SET_TEXTURE_FORMAT_TEXTUREADDRESSU_WRAP_ADJ 0x01000000
#define NV_056_SET_TEXTURE_FORMAT_TEXTUREADDRESSU_MIRROR_ADJ 0x02000000
#define NV_056_SET_TEXTURE_FORMAT_TEXTUREADDRESSU_CLAMP_ADJ 0x03000000
#define NV_056_SET_TEXTURE_FORMAT_WRAPU_MSK                0x08000000 /* 27:27 */ 
#define NV_056_SET_TEXTURE_FORMAT_WRAPU_RMSK               0x00000001 /* 27:27 */ 
#define NV_056_SET_TEXTURE_FORMAT_WRAPU_WORD               0
#define NV_056_SET_TEXTURE_FORMAT_WRAPU_HIGH_FIELD         0x0000001B /* =27 */
#define NV_056_SET_TEXTURE_FORMAT_WRAPU_LOW_FIELD          0x0000001B /* =27 */
#define NV_056_SET_TEXTURE_FORMAT_WRAPU_FALSE_ADJ          0x00000000
#define NV_056_SET_TEXTURE_FORMAT_WRAPU_TRUE_ADJ           0x08000000
#define NV_056_SET_TEXTURE_FORMAT_TEXTUREADDRESSV_MSK      0x70000000 /* 30:28 */ 
#define NV_056_SET_TEXTURE_FORMAT_TEXTUREADDRESSV_RMSK     0x00000007 /* 30:28 */ 
#define NV_056_SET_TEXTURE_FORMAT_TEXTUREADDRESSV_WORD     0
#define NV_056_SET_TEXTURE_FORMAT_TEXTUREADDRESSV_HIGH_FIELD 0x0000001E /* =30 */
#define NV_056_SET_TEXTURE_FORMAT_TEXTUREADDRESSV_LOW_FIELD 0x0000001C /* =28 */
#define NV_056_SET_TEXTURE_FORMAT_TEXTUREADDRESSV_WRAP_ADJ 0x10000000
#define NV_056_SET_TEXTURE_FORMAT_TEXTUREADDRESSV_MIRROR_ADJ 0x20000000
#define NV_056_SET_TEXTURE_FORMAT_TEXTUREADDRESSV_CLAMP_ADJ 0x30000000
#define NV_056_SET_TEXTURE_FORMAT_WRAPV_MSK                0x80000000 /* 31:31 */ 
#define NV_056_SET_TEXTURE_FORMAT_WRAPV_RMSK               0x00000001 /* 31:31 */ 
#define NV_056_SET_TEXTURE_FORMAT_WRAPV_WORD               0
#define NV_056_SET_TEXTURE_FORMAT_WRAPV_HIGH_FIELD         0x0000001F /* =31 */
#define NV_056_SET_TEXTURE_FORMAT_WRAPV_LOW_FIELD          0x0000001F /* =31 */
#define NV_056_SET_TEXTURE_FORMAT_WRAPV_FALSE_ADJ          0x00000000
#define NV_056_SET_TEXTURE_FORMAT_WRAPV_TRUE_ADJ           0x80000000
#define NV_056_SET_TEXTURE_FORMAT_MSK                      0xFFFFFFFF 
#define NV_056_SET_TEXTURE_CONTROL0_ENABLE_MSK             0x40000000 /* 30:30 */ 
#define NV_056_SET_TEXTURE_CONTROL0_ENABLE_RMSK            0x00000001 /* 30:30 */ 
#define NV_056_SET_TEXTURE_CONTROL0_ENABLE_WORD            0
#define NV_056_SET_TEXTURE_CONTROL0_ENABLE_HIGH_FIELD      0x0000001E /* =30 */
#define NV_056_SET_TEXTURE_CONTROL0_ENABLE_LOW_FIELD       0x0000001E /* =30 */
#define NV_056_SET_TEXTURE_CONTROL0_ENABLE_FALSE_ADJ       0x00000000
#define NV_056_SET_TEXTURE_CONTROL0_ENABLE_TRUE_ADJ        0x40000000
#define NV_056_SET_TEXTURE_CONTROL0_MIN_LOD_CLAMP_MSK      0x3FFC0000 /* 29:18 */ 
#define NV_056_SET_TEXTURE_CONTROL0_MIN_LOD_CLAMP_RMSK     0x00000FFF /* 29:18 */ 
#define NV_056_SET_TEXTURE_CONTROL0_MIN_LOD_CLAMP_WORD     0
#define NV_056_SET_TEXTURE_CONTROL0_MIN_LOD_CLAMP_HIGH_FIELD 0x0000001D /* =29 */
#define NV_056_SET_TEXTURE_CONTROL0_MIN_LOD_CLAMP_LOW_FIELD 0x00000012 /* =18 */
#define NV_056_SET_TEXTURE_CONTROL0_MAX_LOD_CLAMP_MSK      0x0003FFC0 /* 17:6 */ 
#define NV_056_SET_TEXTURE_CONTROL0_MAX_LOD_CLAMP_RMSK     0x00000FFF /* 17:6 */ 
#define NV_056_SET_TEXTURE_CONTROL0_MAX_LOD_CLAMP_WORD     0
#define NV_056_SET_TEXTURE_CONTROL0_MAX_LOD_CLAMP_HIGH_FIELD 0x00000011 /* =17 */
#define NV_056_SET_TEXTURE_CONTROL0_MAX_LOD_CLAMP_LOW_FIELD 0x00000006 /* =6 */
#define NV_056_SET_TEXTURE_CONTROL0_LOG_MAX_ANISO_MSK      0x00000030 /* 5:4 */ 
#define NV_056_SET_TEXTURE_CONTROL0_LOG_MAX_ANISO_RMSK     0x00000003 /* 5:4 */ 
#define NV_056_SET_TEXTURE_CONTROL0_LOG_MAX_ANISO_WORD     0
#define NV_056_SET_TEXTURE_CONTROL0_LOG_MAX_ANISO_HIGH_FIELD 0x00000005 /* =5 */
#define NV_056_SET_TEXTURE_CONTROL0_LOG_MAX_ANISO_LOW_FIELD 0x00000004 /* =4 */
#define NV_056_SET_TEXTURE_CONTROL0_LOG_MAX_ANISO_0_ADJ    0x00000000
#define NV_056_SET_TEXTURE_CONTROL0_LOG_MAX_ANISO_1_ADJ    0x00000010
#define NV_056_SET_TEXTURE_CONTROL0_IMAGE_FIELD_ENABLE_MSK 0x00000008 /* 3:3 */ 
#define NV_056_SET_TEXTURE_CONTROL0_IMAGE_FIELD_ENABLE_RMSK 0x00000001 /* 3:3 */ 
#define NV_056_SET_TEXTURE_CONTROL0_IMAGE_FIELD_ENABLE_WORD 0
#define NV_056_SET_TEXTURE_CONTROL0_IMAGE_FIELD_ENABLE_HIGH_FIELD 0x00000003 /* =3 */
#define NV_056_SET_TEXTURE_CONTROL0_IMAGE_FIELD_ENABLE_LOW_FIELD 0x00000003 /* =3 */
#define NV_056_SET_TEXTURE_CONTROL0_IMAGE_FIELD_ENABLE_FALSE_ADJ 0x00000000
#define NV_056_SET_TEXTURE_CONTROL0_IMAGE_FIELD_ENABLE_TRUE_ADJ 0x00000008
#define NV_056_SET_TEXTURE_CONTROL0_ALPHA_KILL_ENABLE_MSK  0x00000004 /* 2:2 */ 
#define NV_056_SET_TEXTURE_CONTROL0_ALPHA_KILL_ENABLE_RMSK 0x00000001 /* 2:2 */ 
#define NV_056_SET_TEXTURE_CONTROL0_ALPHA_KILL_ENABLE_WORD 0
#define NV_056_SET_TEXTURE_CONTROL0_ALPHA_KILL_ENABLE_HIGH_FIELD 0x00000002 /* =2 */
#define NV_056_SET_TEXTURE_CONTROL0_ALPHA_KILL_ENABLE_LOW_FIELD 0x00000002 /* =2 */
#define NV_056_SET_TEXTURE_CONTROL0_ALPHA_KILL_ENABLE_FALSE_ADJ 0x00000000
#define NV_056_SET_TEXTURE_CONTROL0_ALPHA_KILL_ENABLE_TRUE_ADJ 0x00000004
#define NV_056_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_MSK 0x00000003 /* 1:0 */ 
#define NV_056_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_RMSK 0x00000003 /* 1:0 */ 
#define NV_056_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_WORD 0
#define NV_056_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_HIGH_FIELD 0x00000001 /* =1 */
#define NV_056_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_LOW_FIELD 0x00000000 /* =0 */
#define NV_056_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_FALSE_ADJ 0x00000000
#define NV_056_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_ALPHA_ADJ 0x00000001
#define NV_056_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_RGBA_ADJ 0x00000002
#define NV_056_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_KILL_ADJ 0x00000003
#define NV_056_SET_TEXTURE_CONTROL0_MSK                    0x7FFFFFFF 
#define NV_056_SET_TEXTURE_CONTROL1_IMAGE_PITCH_MSK        0xFFFF0000 /* 31:16 */ 
#define NV_056_SET_TEXTURE_CONTROL1_IMAGE_PITCH_RMSK       0x0000FFFF /* 31:16 */ 
#define NV_056_SET_TEXTURE_CONTROL1_IMAGE_PITCH_WORD       0
#define NV_056_SET_TEXTURE_CONTROL1_IMAGE_PITCH_HIGH_FIELD 0x0000001F /* =31 */
#define NV_056_SET_TEXTURE_CONTROL1_IMAGE_PITCH_LOW_FIELD  0x00000010 /* =16 */
#define NV_056_SET_TEXTURE_CONTROL1_ZERO_MSK               0x0000FFFF /* 15:0 */ 
#define NV_056_SET_TEXTURE_CONTROL1_ZERO_RMSK              0x0000FFFF /* 15:0 */ 
#define NV_056_SET_TEXTURE_CONTROL1_ZERO_WORD              0
#define NV_056_SET_TEXTURE_CONTROL1_ZERO_HIGH_FIELD        0x0000000F /* =15 */
#define NV_056_SET_TEXTURE_CONTROL1_ZERO_LOW_FIELD         0x00000000 /* =0 */
#define NV_056_SET_TEXTURE_CONTROL1_MSK                    0xFFFFFFFF 
#define NV_056_SET_TEXTURE_CONTROL2_PERTURB_DU_MSK         0x00000FFF /* 11:0 */ 
#define NV_056_SET_TEXTURE_CONTROL2_PERTURB_DU_RMSK        0x00000FFF /* 11:0 */ 
#define NV_056_SET_TEXTURE_CONTROL2_PERTURB_DU_WORD        0
#define NV_056_SET_TEXTURE_CONTROL2_PERTURB_DU_HIGH_FIELD  0x0000000B /* =11 */
#define NV_056_SET_TEXTURE_CONTROL2_PERTURB_DU_LOW_FIELD   0x00000000 /* =0 */
#define NV_056_SET_TEXTURE_CONTROL2_PERTURB_DV_MSK         0x00FFF000 /* 23:12 */ 
#define NV_056_SET_TEXTURE_CONTROL2_PERTURB_DV_RMSK        0x00000FFF /* 23:12 */ 
#define NV_056_SET_TEXTURE_CONTROL2_PERTURB_DV_WORD        0
#define NV_056_SET_TEXTURE_CONTROL2_PERTURB_DV_HIGH_FIELD  0x00000017 /* =23 */
#define NV_056_SET_TEXTURE_CONTROL2_PERTURB_DV_LOW_FIELD   0x0000000C /* =12 */
#define NV_056_SET_TEXTURE_CONTROL2_IMAGE_LODF_MSK         0xFF000000 /* 31:24 */ 
#define NV_056_SET_TEXTURE_CONTROL2_IMAGE_LODF_RMSK        0x000000FF /* 31:24 */ 
#define NV_056_SET_TEXTURE_CONTROL2_IMAGE_LODF_WORD        0
#define NV_056_SET_TEXTURE_CONTROL2_IMAGE_LODF_HIGH_FIELD  0x0000001F /* =31 */
#define NV_056_SET_TEXTURE_CONTROL2_IMAGE_LODF_LOW_FIELD   0x00000018 /* =24 */
#define NV_056_SET_TEXTURE_CONTROL2_MSK                    0xFFFFFFFF 
#define NV_056_SET_TEXTURE_IMAGE_RECT_WIDTH_MSK            0xFFFF0000 /* 31:16 */ 
#define NV_056_SET_TEXTURE_IMAGE_RECT_WIDTH_RMSK           0x0000FFFF /* 31:16 */ 
#define NV_056_SET_TEXTURE_IMAGE_RECT_WIDTH_WORD           0
#define NV_056_SET_TEXTURE_IMAGE_RECT_WIDTH_HIGH_FIELD     0x0000001F /* =31 */
#define NV_056_SET_TEXTURE_IMAGE_RECT_WIDTH_LOW_FIELD      0x00000010 /* =16 */
#define NV_056_SET_TEXTURE_IMAGE_RECT_HEIGHT_MSK           0x0000FFFF /* 15:0 */ 
#define NV_056_SET_TEXTURE_IMAGE_RECT_HEIGHT_RMSK          0x0000FFFF /* 15:0 */ 
#define NV_056_SET_TEXTURE_IMAGE_RECT_HEIGHT_WORD          0
#define NV_056_SET_TEXTURE_IMAGE_RECT_HEIGHT_HIGH_FIELD    0x0000000F /* =15 */
#define NV_056_SET_TEXTURE_IMAGE_RECT_HEIGHT_LOW_FIELD     0x00000000 /* =0 */
#define NV_056_SET_TEXTURE_IMAGE_RECT_MSK                  0xFFFFFFFF 
#define NV_056_SET_TEXTURE_FILTER_MIPMAPLODBIAS_MSK        0x00FFFFFF /* 23:0 */ 
#define NV_056_SET_TEXTURE_FILTER_MIPMAPLODBIAS_RMSK       0x00FFFFFF /* 23:0 */ 
#define NV_056_SET_TEXTURE_FILTER_MIPMAPLODBIAS_WORD       0
#define NV_056_SET_TEXTURE_FILTER_MIPMAPLODBIAS_HIGH_FIELD 0x00000017 /* =23 */
#define NV_056_SET_TEXTURE_FILTER_MIPMAPLODBIAS_LOW_FIELD  0x00000000 /* =0 */
#define NV_056_SET_TEXTURE_FILTER_TEXTUREMIN_MSK           0x0F000000 /* 27:24 */ 
#define NV_056_SET_TEXTURE_FILTER_TEXTUREMIN_RMSK          0x0000000F /* 27:24 */ 
#define NV_056_SET_TEXTURE_FILTER_TEXTUREMIN_WORD          0
#define NV_056_SET_TEXTURE_FILTER_TEXTUREMIN_HIGH_FIELD    0x0000001B /* =27 */
#define NV_056_SET_TEXTURE_FILTER_TEXTUREMIN_LOW_FIELD     0x00000018 /* =24 */
#define NV_056_SET_TEXTURE_FILTER_TEXTUREMIN_NEAREST_ADJ   0x01000000
#define NV_056_SET_TEXTURE_FILTER_TEXTUREMIN_LINEAR_ADJ    0x02000000
#define NV_056_SET_TEXTURE_FILTER_TEXTUREMIN_MIPNEAREST_ADJ 0x03000000
#define NV_056_SET_TEXTURE_FILTER_TEXTUREMIN_MIPLINEAR_ADJ 0x04000000
#define NV_056_SET_TEXTURE_FILTER_TEXTUREMIN_LINEARMIPNEAREST_ADJ 0x05000000
#define NV_056_SET_TEXTURE_FILTER_TEXTUREMIN_LINEARMIPLINEAR_ADJ 0x06000000
#define NV_056_SET_TEXTURE_FILTER_TEXTUREMAG_MSK           0xF0000000 /* 31:28 */ 
#define NV_056_SET_TEXTURE_FILTER_TEXTUREMAG_RMSK          0x0000000F /* 31:28 */ 
#define NV_056_SET_TEXTURE_FILTER_TEXTUREMAG_WORD          0
#define NV_056_SET_TEXTURE_FILTER_TEXTUREMAG_HIGH_FIELD    0x0000001F /* =31 */
#define NV_056_SET_TEXTURE_FILTER_TEXTUREMAG_LOW_FIELD     0x0000001C /* =28 */
#define NV_056_SET_TEXTURE_FILTER_TEXTUREMAG_NEAREST_ADJ   0x10000000
#define NV_056_SET_TEXTURE_FILTER_TEXTUREMAG_LINEAR_ADJ    0x20000000
#define NV_056_SET_TEXTURE_FILTER_MSK                      0xFFFFFFFF 
#define NV_056_SET_TEXTURE_PALETTE_CONTEXT_DMA_MSK         0x0000003F /* 5:0 */ 
#define NV_056_SET_TEXTURE_PALETTE_CONTEXT_DMA_RMSK        0x0000003F /* 5:0 */ 
#define NV_056_SET_TEXTURE_PALETTE_CONTEXT_DMA_WORD        0
#define NV_056_SET_TEXTURE_PALETTE_CONTEXT_DMA_HIGH_FIELD  0x00000005 /* =5 */
#define NV_056_SET_TEXTURE_PALETTE_CONTEXT_DMA_LOW_FIELD   0x00000000 /* =0 */
#define NV_056_SET_TEXTURE_PALETTE_CONTEXT_DMA_A_ADJ       0x00000000
#define NV_056_SET_TEXTURE_PALETTE_CONTEXT_DMA_B_ADJ       0x00000001
#define NV_056_SET_TEXTURE_PALETTE_PALETTE_OFFSET_MSK      0xFFFFFFC0 /* 31:6 */ 
#define NV_056_SET_TEXTURE_PALETTE_PALETTE_OFFSET_RMSK     0x03FFFFFF /* 31:6 */ 
#define NV_056_SET_TEXTURE_PALETTE_PALETTE_OFFSET_WORD     0
#define NV_056_SET_TEXTURE_PALETTE_PALETTE_OFFSET_HIGH_FIELD 0x0000001F /* =31 */
#define NV_056_SET_TEXTURE_PALETTE_PALETTE_OFFSET_LOW_FIELD 0x00000006 /* =6 */
#define NV_056_SET_TEXTURE_PALETTE_MSK                     0xFFFFFFFF 
#define NV_056_SET_COMBINER_ALPHA_ICW_A_MAP_MSK            0xE0000000 /* 31:29 */ 
#define NV_056_SET_COMBINER_ALPHA_ICW_A_MAP_RMSK           0x00000007 /* 31:29 */ 
#define NV_056_SET_COMBINER_ALPHA_ICW_A_MAP_WORD           0
#define NV_056_SET_COMBINER_ALPHA_ICW_A_MAP_HIGH_FIELD     0x0000001F /* =31 */
#define NV_056_SET_COMBINER_ALPHA_ICW_A_MAP_LOW_FIELD      0x0000001D /* =29 */
#define NV_056_SET_COMBINER_ALPHA_ICW_A_MAP_UNSIGNED_IDENTITY_ADJ 0x00000000
#define NV_056_SET_COMBINER_ALPHA_ICW_A_MAP_UNSIGNED_INVERT_ADJ 0x20000000
#define NV_056_SET_COMBINER_ALPHA_ICW_A_MAP_EXPAND_NORMAL_ADJ 0x40000000
#define NV_056_SET_COMBINER_ALPHA_ICW_A_MAP_EXPAND_NEGATE_ADJ 0x60000000
#define NV_056_SET_COMBINER_ALPHA_ICW_A_MAP_HALFBIAS_NORMAL_ADJ 0x80000000
#define NV_056_SET_COMBINER_ALPHA_ICW_A_MAP_HALFBIAS_NEGATE_ADJ 0xA0000000
#define NV_056_SET_COMBINER_ALPHA_ICW_A_MAP_SIGNED_IDENTITY_ADJ 0xC0000000
#define NV_056_SET_COMBINER_ALPHA_ICW_A_MAP_SIGNED_NEGATE_ADJ 0xE0000000
#define NV_056_SET_COMBINER_ALPHA_ICW_A_ALPHA_MSK          0x10000000 /* 28:28 */ 
#define NV_056_SET_COMBINER_ALPHA_ICW_A_ALPHA_RMSK         0x00000001 /* 28:28 */ 
#define NV_056_SET_COMBINER_ALPHA_ICW_A_ALPHA_WORD         0
#define NV_056_SET_COMBINER_ALPHA_ICW_A_ALPHA_HIGH_FIELD   0x0000001C /* =28 */
#define NV_056_SET_COMBINER_ALPHA_ICW_A_ALPHA_LOW_FIELD    0x0000001C /* =28 */
#define NV_056_SET_COMBINER_ALPHA_ICW_A_ALPHA_FALSE_ADJ    0x00000000
#define NV_056_SET_COMBINER_ALPHA_ICW_A_ALPHA_TRUE_ADJ     0x10000000
#define NV_056_SET_COMBINER_ALPHA_ICW_A_SOURCE_MSK         0x0F000000 /* 27:24 */ 
#define NV_056_SET_COMBINER_ALPHA_ICW_A_SOURCE_RMSK        0x0000000F /* 27:24 */ 
#define NV_056_SET_COMBINER_ALPHA_ICW_A_SOURCE_WORD        0
#define NV_056_SET_COMBINER_ALPHA_ICW_A_SOURCE_HIGH_FIELD  0x0000001B /* =27 */
#define NV_056_SET_COMBINER_ALPHA_ICW_A_SOURCE_LOW_FIELD   0x00000018 /* =24 */
#define NV_056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_0_ADJ   0x00000000
#define NV_056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_1_ADJ   0x01000000
#define NV_056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_2_ADJ   0x02000000
#define NV_056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_3_ADJ   0x03000000
#define NV_056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_4_ADJ   0x04000000
#define NV_056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_5_ADJ   0x05000000
#define NV_056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_8_ADJ   0x08000000
#define NV_056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_9_ADJ   0x09000000
#define NV_056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_C_ADJ   0x0C000000
#define NV_056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_D_ADJ   0x0D000000
#define NV_056_SET_COMBINER_ALPHA_ICW_B_MAP_MSK            0x00E00000 /* 23:21 */ 
#define NV_056_SET_COMBINER_ALPHA_ICW_B_MAP_RMSK           0x00000007 /* 23:21 */ 
#define NV_056_SET_COMBINER_ALPHA_ICW_B_MAP_WORD           0
#define NV_056_SET_COMBINER_ALPHA_ICW_B_MAP_HIGH_FIELD     0x00000017 /* =23 */
#define NV_056_SET_COMBINER_ALPHA_ICW_B_MAP_LOW_FIELD      0x00000015 /* =21 */
#define NV_056_SET_COMBINER_ALPHA_ICW_B_MAP_UNSIGNED_IDENTITY_ADJ 0x00000000
#define NV_056_SET_COMBINER_ALPHA_ICW_B_MAP_UNSIGNED_INVERT_ADJ 0x00200000
#define NV_056_SET_COMBINER_ALPHA_ICW_B_MAP_EXPAND_NORMAL_ADJ 0x00400000
#define NV_056_SET_COMBINER_ALPHA_ICW_B_MAP_EXPAND_NEGATE_ADJ 0x00600000
#define NV_056_SET_COMBINER_ALPHA_ICW_B_MAP_HALFBIAS_NORMAL_ADJ 0x00800000
#define NV_056_SET_COMBINER_ALPHA_ICW_B_MAP_HALFBIAS_NEGATE_ADJ 0x00A00000
#define NV_056_SET_COMBINER_ALPHA_ICW_B_MAP_SIGNED_IDENTITY_ADJ 0x00C00000
#define NV_056_SET_COMBINER_ALPHA_ICW_B_MAP_SIGNED_NEGATE_ADJ 0x00E00000
#define NV_056_SET_COMBINER_ALPHA_ICW_B_ALPHA_MSK          0x00100000 /* 20:20 */ 
#define NV_056_SET_COMBINER_ALPHA_ICW_B_ALPHA_RMSK         0x00000001 /* 20:20 */ 
#define NV_056_SET_COMBINER_ALPHA_ICW_B_ALPHA_WORD         0
#define NV_056_SET_COMBINER_ALPHA_ICW_B_ALPHA_HIGH_FIELD   0x00000014 /* =20 */
#define NV_056_SET_COMBINER_ALPHA_ICW_B_ALPHA_LOW_FIELD    0x00000014 /* =20 */
#define NV_056_SET_COMBINER_ALPHA_ICW_B_ALPHA_FALSE_ADJ    0x00000000
#define NV_056_SET_COMBINER_ALPHA_ICW_B_ALPHA_TRUE_ADJ     0x00100000
#define NV_056_SET_COMBINER_ALPHA_ICW_B_SOURCE_MSK         0x000F0000 /* 19:16 */ 
#define NV_056_SET_COMBINER_ALPHA_ICW_B_SOURCE_RMSK        0x0000000F /* 19:16 */ 
#define NV_056_SET_COMBINER_ALPHA_ICW_B_SOURCE_WORD        0
#define NV_056_SET_COMBINER_ALPHA_ICW_B_SOURCE_HIGH_FIELD  0x00000013 /* =19 */
#define NV_056_SET_COMBINER_ALPHA_ICW_B_SOURCE_LOW_FIELD   0x00000010 /* =16 */
#define NV_056_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_0_ADJ   0x00000000
#define NV_056_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_1_ADJ   0x00010000
#define NV_056_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_2_ADJ   0x00020000
#define NV_056_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_3_ADJ   0x00030000
#define NV_056_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_4_ADJ   0x00040000
#define NV_056_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_5_ADJ   0x00050000
#define NV_056_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_8_ADJ   0x00080000
#define NV_056_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_9_ADJ   0x00090000
#define NV_056_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_C_ADJ   0x000C0000
#define NV_056_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_D_ADJ   0x000D0000
#define NV_056_SET_COMBINER_ALPHA_ICW_C_MAP_MSK            0x0000E000 /* 15:13 */ 
#define NV_056_SET_COMBINER_ALPHA_ICW_C_MAP_RMSK           0x00000007 /* 15:13 */ 
#define NV_056_SET_COMBINER_ALPHA_ICW_C_MAP_WORD           0
#define NV_056_SET_COMBINER_ALPHA_ICW_C_MAP_HIGH_FIELD     0x0000000F /* =15 */
#define NV_056_SET_COMBINER_ALPHA_ICW_C_MAP_LOW_FIELD      0x0000000D /* =13 */
#define NV_056_SET_COMBINER_ALPHA_ICW_C_MAP_UNSIGNED_IDENTITY_ADJ 0x00000000
#define NV_056_SET_COMBINER_ALPHA_ICW_C_MAP_UNSIGNED_INVERT_ADJ 0x00002000
#define NV_056_SET_COMBINER_ALPHA_ICW_C_MAP_EXPAND_NORMAL_ADJ 0x00004000
#define NV_056_SET_COMBINER_ALPHA_ICW_C_MAP_EXPAND_NEGATE_ADJ 0x00006000
#define NV_056_SET_COMBINER_ALPHA_ICW_C_MAP_HALFBIAS_NORMAL_ADJ 0x00008000
#define NV_056_SET_COMBINER_ALPHA_ICW_C_MAP_HALFBIAS_NEGATE_ADJ 0x0000A000
#define NV_056_SET_COMBINER_ALPHA_ICW_C_MAP_SIGNED_IDENTITY_ADJ 0x0000C000
#define NV_056_SET_COMBINER_ALPHA_ICW_C_MAP_SIGNED_NEGATE_ADJ 0x0000E000
#define NV_056_SET_COMBINER_ALPHA_ICW_C_ALPHA_MSK          0x00001000 /* 12:12 */ 
#define NV_056_SET_COMBINER_ALPHA_ICW_C_ALPHA_RMSK         0x00000001 /* 12:12 */ 
#define NV_056_SET_COMBINER_ALPHA_ICW_C_ALPHA_WORD         0
#define NV_056_SET_COMBINER_ALPHA_ICW_C_ALPHA_HIGH_FIELD   0x0000000C /* =12 */
#define NV_056_SET_COMBINER_ALPHA_ICW_C_ALPHA_LOW_FIELD    0x0000000C /* =12 */
#define NV_056_SET_COMBINER_ALPHA_ICW_C_ALPHA_FALSE_ADJ    0x00000000
#define NV_056_SET_COMBINER_ALPHA_ICW_C_ALPHA_TRUE_ADJ     0x00001000
#define NV_056_SET_COMBINER_ALPHA_ICW_C_SOURCE_MSK         0x00000F00 /* 11:8 */ 
#define NV_056_SET_COMBINER_ALPHA_ICW_C_SOURCE_RMSK        0x0000000F /* 11:8 */ 
#define NV_056_SET_COMBINER_ALPHA_ICW_C_SOURCE_WORD        0
#define NV_056_SET_COMBINER_ALPHA_ICW_C_SOURCE_HIGH_FIELD  0x0000000B /* =11 */
#define NV_056_SET_COMBINER_ALPHA_ICW_C_SOURCE_LOW_FIELD   0x00000008 /* =8 */
#define NV_056_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_0_ADJ   0x00000000
#define NV_056_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_1_ADJ   0x00000100
#define NV_056_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_2_ADJ   0x00000200
#define NV_056_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_3_ADJ   0x00000300
#define NV_056_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_4_ADJ   0x00000400
#define NV_056_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_5_ADJ   0x00000500
#define NV_056_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_8_ADJ   0x00000800
#define NV_056_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_9_ADJ   0x00000900
#define NV_056_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_C_ADJ   0x00000C00
#define NV_056_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_D_ADJ   0x00000D00
#define NV_056_SET_COMBINER_ALPHA_ICW_D_MAP_MSK            0x000000E0 /* 7:5 */ 
#define NV_056_SET_COMBINER_ALPHA_ICW_D_MAP_RMSK           0x00000007 /* 7:5 */ 
#define NV_056_SET_COMBINER_ALPHA_ICW_D_MAP_WORD           0
#define NV_056_SET_COMBINER_ALPHA_ICW_D_MAP_HIGH_FIELD     0x00000007 /* =7 */
#define NV_056_SET_COMBINER_ALPHA_ICW_D_MAP_LOW_FIELD      0x00000005 /* =5 */
#define NV_056_SET_COMBINER_ALPHA_ICW_D_MAP_UNSIGNED_IDENTITY_ADJ 0x00000000
#define NV_056_SET_COMBINER_ALPHA_ICW_D_MAP_UNSIGNED_INVERT_ADJ 0x00000020
#define NV_056_SET_COMBINER_ALPHA_ICW_D_MAP_EXPAND_NORMAL_ADJ 0x00000040
#define NV_056_SET_COMBINER_ALPHA_ICW_D_MAP_EXPAND_NEGATE_ADJ 0x00000060
#define NV_056_SET_COMBINER_ALPHA_ICW_D_MAP_HALFBIAS_NORMAL_ADJ 0x00000080
#define NV_056_SET_COMBINER_ALPHA_ICW_D_MAP_HALFBIAS_NEGATE_ADJ 0x000000A0
#define NV_056_SET_COMBINER_ALPHA_ICW_D_MAP_SIGNED_IDENTITY_ADJ 0x000000C0
#define NV_056_SET_COMBINER_ALPHA_ICW_D_MAP_SIGNED_NEGATE_ADJ 0x000000E0
#define NV_056_SET_COMBINER_ALPHA_ICW_D_ALPHA_MSK          0x00000010 /* 4:4 */ 
#define NV_056_SET_COMBINER_ALPHA_ICW_D_ALPHA_RMSK         0x00000001 /* 4:4 */ 
#define NV_056_SET_COMBINER_ALPHA_ICW_D_ALPHA_WORD         0
#define NV_056_SET_COMBINER_ALPHA_ICW_D_ALPHA_HIGH_FIELD   0x00000004 /* =4 */
#define NV_056_SET_COMBINER_ALPHA_ICW_D_ALPHA_LOW_FIELD    0x00000004 /* =4 */
#define NV_056_SET_COMBINER_ALPHA_ICW_D_ALPHA_FALSE_ADJ    0x00000000
#define NV_056_SET_COMBINER_ALPHA_ICW_D_ALPHA_TRUE_ADJ     0x00000010
#define NV_056_SET_COMBINER_ALPHA_ICW_D_SOURCE_MSK         0x0000000F /* 3:0 */ 
#define NV_056_SET_COMBINER_ALPHA_ICW_D_SOURCE_RMSK        0x0000000F /* 3:0 */ 
#define NV_056_SET_COMBINER_ALPHA_ICW_D_SOURCE_WORD        0
#define NV_056_SET_COMBINER_ALPHA_ICW_D_SOURCE_HIGH_FIELD  0x00000003 /* =3 */
#define NV_056_SET_COMBINER_ALPHA_ICW_D_SOURCE_LOW_FIELD   0x00000000 /* =0 */
#define NV_056_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_0_ADJ   0x00000000
#define NV_056_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_1_ADJ   0x00000001
#define NV_056_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_2_ADJ   0x00000002
#define NV_056_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_3_ADJ   0x00000003
#define NV_056_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_4_ADJ   0x00000004
#define NV_056_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_5_ADJ   0x00000005
#define NV_056_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_8_ADJ   0x00000008
#define NV_056_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_9_ADJ   0x00000009
#define NV_056_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_C_ADJ   0x0000000C
#define NV_056_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_D_ADJ   0x0000000D
#define NV_056_SET_COMBINER_ALPHA_ICW_MSK                  0xFFFFFFFF 
#define NV_056_SET_COMBINER_COLOR_ICW_A_MAP_MSK            0xE0000000 /* 31:29 */ 
#define NV_056_SET_COMBINER_COLOR_ICW_A_MAP_RMSK           0x00000007 /* 31:29 */ 
#define NV_056_SET_COMBINER_COLOR_ICW_A_MAP_WORD           0
#define NV_056_SET_COMBINER_COLOR_ICW_A_MAP_HIGH_FIELD     0x0000001F /* =31 */
#define NV_056_SET_COMBINER_COLOR_ICW_A_MAP_LOW_FIELD      0x0000001D /* =29 */
#define NV_056_SET_COMBINER_COLOR_ICW_A_MAP_UNSIGNED_IDENTITY_ADJ 0x00000000
#define NV_056_SET_COMBINER_COLOR_ICW_A_MAP_UNSIGNED_INVERT_ADJ 0x20000000
#define NV_056_SET_COMBINER_COLOR_ICW_A_MAP_EXPAND_NORMAL_ADJ 0x40000000
#define NV_056_SET_COMBINER_COLOR_ICW_A_MAP_EXPAND_NEGATE_ADJ 0x60000000
#define NV_056_SET_COMBINER_COLOR_ICW_A_MAP_HALFBIAS_NORMAL_ADJ 0x80000000
#define NV_056_SET_COMBINER_COLOR_ICW_A_MAP_HALFBIAS_NEGATE_ADJ 0xA0000000
#define NV_056_SET_COMBINER_COLOR_ICW_A_MAP_SIGNED_IDENTITY_ADJ 0xC0000000
#define NV_056_SET_COMBINER_COLOR_ICW_A_MAP_SIGNED_NEGATE_ADJ 0xE0000000
#define NV_056_SET_COMBINER_COLOR_ICW_A_ALPHA_MSK          0x10000000 /* 28:28 */ 
#define NV_056_SET_COMBINER_COLOR_ICW_A_ALPHA_RMSK         0x00000001 /* 28:28 */ 
#define NV_056_SET_COMBINER_COLOR_ICW_A_ALPHA_WORD         0
#define NV_056_SET_COMBINER_COLOR_ICW_A_ALPHA_HIGH_FIELD   0x0000001C /* =28 */
#define NV_056_SET_COMBINER_COLOR_ICW_A_ALPHA_LOW_FIELD    0x0000001C /* =28 */
#define NV_056_SET_COMBINER_COLOR_ICW_A_ALPHA_FALSE_ADJ    0x00000000
#define NV_056_SET_COMBINER_COLOR_ICW_A_ALPHA_TRUE_ADJ     0x10000000
#define NV_056_SET_COMBINER_COLOR_ICW_A_SOURCE_MSK         0x0F000000 /* 27:24 */ 
#define NV_056_SET_COMBINER_COLOR_ICW_A_SOURCE_RMSK        0x0000000F /* 27:24 */ 
#define NV_056_SET_COMBINER_COLOR_ICW_A_SOURCE_WORD        0
#define NV_056_SET_COMBINER_COLOR_ICW_A_SOURCE_HIGH_FIELD  0x0000001B /* =27 */
#define NV_056_SET_COMBINER_COLOR_ICW_A_SOURCE_LOW_FIELD   0x00000018 /* =24 */
#define NV_056_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_0_ADJ   0x00000000
#define NV_056_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_1_ADJ   0x01000000
#define NV_056_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_2_ADJ   0x02000000
#define NV_056_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_3_ADJ   0x03000000
#define NV_056_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_4_ADJ   0x04000000
#define NV_056_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_5_ADJ   0x05000000
#define NV_056_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_8_ADJ   0x08000000
#define NV_056_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_9_ADJ   0x09000000
#define NV_056_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_C_ADJ   0x0C000000
#define NV_056_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_D_ADJ   0x0D000000
#define NV_056_SET_COMBINER_COLOR_ICW_B_MAP_MSK            0x00E00000 /* 23:21 */ 
#define NV_056_SET_COMBINER_COLOR_ICW_B_MAP_RMSK           0x00000007 /* 23:21 */ 
#define NV_056_SET_COMBINER_COLOR_ICW_B_MAP_WORD           0
#define NV_056_SET_COMBINER_COLOR_ICW_B_MAP_HIGH_FIELD     0x00000017 /* =23 */
#define NV_056_SET_COMBINER_COLOR_ICW_B_MAP_LOW_FIELD      0x00000015 /* =21 */
#define NV_056_SET_COMBINER_COLOR_ICW_B_MAP_UNSIGNED_IDENTITY_ADJ 0x00000000
#define NV_056_SET_COMBINER_COLOR_ICW_B_MAP_UNSIGNED_INVERT_ADJ 0x00200000
#define NV_056_SET_COMBINER_COLOR_ICW_B_MAP_EXPAND_NORMAL_ADJ 0x00400000
#define NV_056_SET_COMBINER_COLOR_ICW_B_MAP_EXPAND_NEGATE_ADJ 0x00600000
#define NV_056_SET_COMBINER_COLOR_ICW_B_MAP_HALFBIAS_NORMAL_ADJ 0x00800000
#define NV_056_SET_COMBINER_COLOR_ICW_B_MAP_HALFBIAS_NEGATE_ADJ 0x00A00000
#define NV_056_SET_COMBINER_COLOR_ICW_B_MAP_SIGNED_IDENTITY_ADJ 0x00C00000
#define NV_056_SET_COMBINER_COLOR_ICW_B_MAP_SIGNED_NEGATE_ADJ 0x00E00000
#define NV_056_SET_COMBINER_COLOR_ICW_B_ALPHA_MSK          0x00100000 /* 20:20 */ 
#define NV_056_SET_COMBINER_COLOR_ICW_B_ALPHA_RMSK         0x00000001 /* 20:20 */ 
#define NV_056_SET_COMBINER_COLOR_ICW_B_ALPHA_WORD         0
#define NV_056_SET_COMBINER_COLOR_ICW_B_ALPHA_HIGH_FIELD   0x00000014 /* =20 */
#define NV_056_SET_COMBINER_COLOR_ICW_B_ALPHA_LOW_FIELD    0x00000014 /* =20 */
#define NV_056_SET_COMBINER_COLOR_ICW_B_ALPHA_FALSE_ADJ    0x00000000
#define NV_056_SET_COMBINER_COLOR_ICW_B_ALPHA_TRUE_ADJ     0x00100000
#define NV_056_SET_COMBINER_COLOR_ICW_B_SOURCE_MSK         0x000F0000 /* 19:16 */ 
#define NV_056_SET_COMBINER_COLOR_ICW_B_SOURCE_RMSK        0x0000000F /* 19:16 */ 
#define NV_056_SET_COMBINER_COLOR_ICW_B_SOURCE_WORD        0
#define NV_056_SET_COMBINER_COLOR_ICW_B_SOURCE_HIGH_FIELD  0x00000013 /* =19 */
#define NV_056_SET_COMBINER_COLOR_ICW_B_SOURCE_LOW_FIELD   0x00000010 /* =16 */
#define NV_056_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_0_ADJ   0x00000000
#define NV_056_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_1_ADJ   0x00010000
#define NV_056_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_2_ADJ   0x00020000
#define NV_056_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_3_ADJ   0x00030000
#define NV_056_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_4_ADJ   0x00040000
#define NV_056_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_5_ADJ   0x00050000
#define NV_056_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_8_ADJ   0x00080000
#define NV_056_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_9_ADJ   0x00090000
#define NV_056_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_C_ADJ   0x000C0000
#define NV_056_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_D_ADJ   0x000D0000
#define NV_056_SET_COMBINER_COLOR_ICW_C_MAP_MSK            0x0000E000 /* 15:13 */ 
#define NV_056_SET_COMBINER_COLOR_ICW_C_MAP_RMSK           0x00000007 /* 15:13 */ 
#define NV_056_SET_COMBINER_COLOR_ICW_C_MAP_WORD           0
#define NV_056_SET_COMBINER_COLOR_ICW_C_MAP_HIGH_FIELD     0x0000000F /* =15 */
#define NV_056_SET_COMBINER_COLOR_ICW_C_MAP_LOW_FIELD      0x0000000D /* =13 */
#define NV_056_SET_COMBINER_COLOR_ICW_C_MAP_UNSIGNED_IDENTITY_ADJ 0x00000000
#define NV_056_SET_COMBINER_COLOR_ICW_C_MAP_UNSIGNED_INVERT_ADJ 0x00002000
#define NV_056_SET_COMBINER_COLOR_ICW_C_MAP_EXPAND_NORMAL_ADJ 0x00004000
#define NV_056_SET_COMBINER_COLOR_ICW_C_MAP_EXPAND_NEGATE_ADJ 0x00006000
#define NV_056_SET_COMBINER_COLOR_ICW_C_MAP_HALFBIAS_NORMAL_ADJ 0x00008000
#define NV_056_SET_COMBINER_COLOR_ICW_C_MAP_HALFBIAS_NEGATE_ADJ 0x0000A000
#define NV_056_SET_COMBINER_COLOR_ICW_C_MAP_SIGNED_IDENTITY_ADJ 0x0000C000
#define NV_056_SET_COMBINER_COLOR_ICW_C_MAP_SIGNED_NEGATE_ADJ 0x0000E000
#define NV_056_SET_COMBINER_COLOR_ICW_C_ALPHA_MSK          0x00001000 /* 12:12 */ 
#define NV_056_SET_COMBINER_COLOR_ICW_C_ALPHA_RMSK         0x00000001 /* 12:12 */ 
#define NV_056_SET_COMBINER_COLOR_ICW_C_ALPHA_WORD         0
#define NV_056_SET_COMBINER_COLOR_ICW_C_ALPHA_HIGH_FIELD   0x0000000C /* =12 */
#define NV_056_SET_COMBINER_COLOR_ICW_C_ALPHA_LOW_FIELD    0x0000000C /* =12 */
#define NV_056_SET_COMBINER_COLOR_ICW_C_ALPHA_FALSE_ADJ    0x00000000
#define NV_056_SET_COMBINER_COLOR_ICW_C_ALPHA_TRUE_ADJ     0x00001000
#define NV_056_SET_COMBINER_COLOR_ICW_C_SOURCE_MSK         0x00000F00 /* 11:8 */ 
#define NV_056_SET_COMBINER_COLOR_ICW_C_SOURCE_RMSK        0x0000000F /* 11:8 */ 
#define NV_056_SET_COMBINER_COLOR_ICW_C_SOURCE_WORD        0
#define NV_056_SET_COMBINER_COLOR_ICW_C_SOURCE_HIGH_FIELD  0x0000000B /* =11 */
#define NV_056_SET_COMBINER_COLOR_ICW_C_SOURCE_LOW_FIELD   0x00000008 /* =8 */
#define NV_056_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_0_ADJ   0x00000000
#define NV_056_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_1_ADJ   0x00000100
#define NV_056_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_2_ADJ   0x00000200
#define NV_056_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_3_ADJ   0x00000300
#define NV_056_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_4_ADJ   0x00000400
#define NV_056_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_5_ADJ   0x00000500
#define NV_056_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_8_ADJ   0x00000800
#define NV_056_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_9_ADJ   0x00000900
#define NV_056_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_C_ADJ   0x00000C00
#define NV_056_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_D_ADJ   0x00000D00
#define NV_056_SET_COMBINER_COLOR_ICW_D_MAP_MSK            0x000000E0 /* 7:5 */ 
#define NV_056_SET_COMBINER_COLOR_ICW_D_MAP_RMSK           0x00000007 /* 7:5 */ 
#define NV_056_SET_COMBINER_COLOR_ICW_D_MAP_WORD           0
#define NV_056_SET_COMBINER_COLOR_ICW_D_MAP_HIGH_FIELD     0x00000007 /* =7 */
#define NV_056_SET_COMBINER_COLOR_ICW_D_MAP_LOW_FIELD      0x00000005 /* =5 */
#define NV_056_SET_COMBINER_COLOR_ICW_D_MAP_UNSIGNED_IDENTITY_ADJ 0x00000000
#define NV_056_SET_COMBINER_COLOR_ICW_D_MAP_UNSIGNED_INVERT_ADJ 0x00000020
#define NV_056_SET_COMBINER_COLOR_ICW_D_MAP_EXPAND_NORMAL_ADJ 0x00000040
#define NV_056_SET_COMBINER_COLOR_ICW_D_MAP_EXPAND_NEGATE_ADJ 0x00000060
#define NV_056_SET_COMBINER_COLOR_ICW_D_MAP_HALFBIAS_NORMAL_ADJ 0x00000080
#define NV_056_SET_COMBINER_COLOR_ICW_D_MAP_HALFBIAS_NEGATE_ADJ 0x000000A0
#define NV_056_SET_COMBINER_COLOR_ICW_D_MAP_SIGNED_IDENTITY_ADJ 0x000000C0
#define NV_056_SET_COMBINER_COLOR_ICW_D_MAP_SIGNED_NEGATE_ADJ 0x000000E0
#define NV_056_SET_COMBINER_COLOR_ICW_D_ALPHA_MSK          0x00000010 /* 4:4 */ 
#define NV_056_SET_COMBINER_COLOR_ICW_D_ALPHA_RMSK         0x00000001 /* 4:4 */ 
#define NV_056_SET_COMBINER_COLOR_ICW_D_ALPHA_WORD         0
#define NV_056_SET_COMBINER_COLOR_ICW_D_ALPHA_HIGH_FIELD   0x00000004 /* =4 */
#define NV_056_SET_COMBINER_COLOR_ICW_D_ALPHA_LOW_FIELD    0x00000004 /* =4 */
#define NV_056_SET_COMBINER_COLOR_ICW_D_ALPHA_FALSE_ADJ    0x00000000
#define NV_056_SET_COMBINER_COLOR_ICW_D_ALPHA_TRUE_ADJ     0x00000010
#define NV_056_SET_COMBINER_COLOR_ICW_D_SOURCE_MSK         0x0000000F /* 3:0 */ 
#define NV_056_SET_COMBINER_COLOR_ICW_D_SOURCE_RMSK        0x0000000F /* 3:0 */ 
#define NV_056_SET_COMBINER_COLOR_ICW_D_SOURCE_WORD        0
#define NV_056_SET_COMBINER_COLOR_ICW_D_SOURCE_HIGH_FIELD  0x00000003 /* =3 */
#define NV_056_SET_COMBINER_COLOR_ICW_D_SOURCE_LOW_FIELD   0x00000000 /* =0 */
#define NV_056_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_0_ADJ   0x00000000
#define NV_056_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_1_ADJ   0x00000001
#define NV_056_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_2_ADJ   0x00000002
#define NV_056_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_3_ADJ   0x00000003
#define NV_056_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_4_ADJ   0x00000004
#define NV_056_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_5_ADJ   0x00000005
#define NV_056_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_8_ADJ   0x00000008
#define NV_056_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_9_ADJ   0x00000009
#define NV_056_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_C_ADJ   0x0000000C
#define NV_056_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_D_ADJ   0x0000000D
#define NV_056_SET_COMBINER_COLOR_ICW_MSK                  0xFFFFFFFF 
#define NV_056_SET_COMBINE_FACTOR_BLUE_MSK                 0x000000FF /* 7:0 */ 
#define NV_056_SET_COMBINE_FACTOR_BLUE_RMSK                0x000000FF /* 7:0 */ 
#define NV_056_SET_COMBINE_FACTOR_BLUE_WORD                0
#define NV_056_SET_COMBINE_FACTOR_BLUE_HIGH_FIELD          0x00000007 /* =7 */
#define NV_056_SET_COMBINE_FACTOR_BLUE_LOW_FIELD           0x00000000 /* =0 */
#define NV_056_SET_COMBINE_FACTOR_GREEN_MSK                0x0000FF00 /* 15:8 */ 
#define NV_056_SET_COMBINE_FACTOR_GREEN_RMSK               0x000000FF /* 15:8 */ 
#define NV_056_SET_COMBINE_FACTOR_GREEN_WORD               0
#define NV_056_SET_COMBINE_FACTOR_GREEN_HIGH_FIELD         0x0000000F /* =15 */
#define NV_056_SET_COMBINE_FACTOR_GREEN_LOW_FIELD          0x00000008 /* =8 */
#define NV_056_SET_COMBINE_FACTOR_RED_MSK                  0x00FF0000 /* 23:16 */ 
#define NV_056_SET_COMBINE_FACTOR_RED_RMSK                 0x000000FF /* 23:16 */ 
#define NV_056_SET_COMBINE_FACTOR_RED_WORD                 0
#define NV_056_SET_COMBINE_FACTOR_RED_HIGH_FIELD           0x00000017 /* =23 */
#define NV_056_SET_COMBINE_FACTOR_RED_LOW_FIELD            0x00000010 /* =16 */
#define NV_056_SET_COMBINE_FACTOR_ALPHA_MSK                0xFF000000 /* 31:24 */ 
#define NV_056_SET_COMBINE_FACTOR_ALPHA_RMSK               0x000000FF /* 31:24 */ 
#define NV_056_SET_COMBINE_FACTOR_ALPHA_WORD               0
#define NV_056_SET_COMBINE_FACTOR_ALPHA_HIGH_FIELD         0x0000001F /* =31 */
#define NV_056_SET_COMBINE_FACTOR_ALPHA_LOW_FIELD          0x00000018 /* =24 */
#define NV_056_SET_COMBINE_FACTOR_MSK                      0xFFFFFFFF 
#define NV_056_SET_COMBINER_ALPHA_OCW_OPERATION_MSK        0xFFFF8000 /* 31:15 */ 
#define NV_056_SET_COMBINER_ALPHA_OCW_OPERATION_RMSK       0x0001FFFF /* 31:15 */ 
#define NV_056_SET_COMBINER_ALPHA_OCW_OPERATION_WORD       0
#define NV_056_SET_COMBINER_ALPHA_OCW_OPERATION_HIGH_FIELD 0x0000001F /* =31 */
#define NV_056_SET_COMBINER_ALPHA_OCW_OPERATION_LOW_FIELD  0x0000000F /* =15 */
#define NV_056_SET_COMBINER_ALPHA_OCW_OPERATION_NOSHIFT_ADJ 0x00000000
#define NV_056_SET_COMBINER_ALPHA_OCW_OPERATION_NOSHIFT_BIAS_ADJ 0x00008000
#define NV_056_SET_COMBINER_ALPHA_OCW_OPERATION_SHIFTLEFTBY1_ADJ 0x00010000
#define NV_056_SET_COMBINER_ALPHA_OCW_OPERATION_SHIFTLEFTBY1_BIAS_ADJ 0x00018000
#define NV_056_SET_COMBINER_ALPHA_OCW_OPERATION_SHIFTLEFTBY2_ADJ 0x00020000
#define NV_056_SET_COMBINER_ALPHA_OCW_OPERATION_SHIFTRIGHTBY1_ADJ 0x00030000
#define NV_056_SET_COMBINER_ALPHA_OCW_MUX_ENABLE_MSK       0x00004000 /* 14:14 */ 
#define NV_056_SET_COMBINER_ALPHA_OCW_MUX_ENABLE_RMSK      0x00000001 /* 14:14 */ 
#define NV_056_SET_COMBINER_ALPHA_OCW_MUX_ENABLE_WORD      0
#define NV_056_SET_COMBINER_ALPHA_OCW_MUX_ENABLE_HIGH_FIELD 0x0000000E /* =14 */
#define NV_056_SET_COMBINER_ALPHA_OCW_MUX_ENABLE_LOW_FIELD 0x0000000E /* =14 */
#define NV_056_SET_COMBINER_ALPHA_OCW_MUX_ENABLE_FALSE_ADJ 0x00000000
#define NV_056_SET_COMBINER_ALPHA_OCW_MUX_ENABLE_TRUE_ADJ  0x00004000
#define NV_056_SET_COMBINER_ALPHA_OCW_SUM_DST_MSK          0x00000F00 /* 11:8 */ 
#define NV_056_SET_COMBINER_ALPHA_OCW_SUM_DST_RMSK         0x0000000F /* 11:8 */ 
#define NV_056_SET_COMBINER_ALPHA_OCW_SUM_DST_WORD         0
#define NV_056_SET_COMBINER_ALPHA_OCW_SUM_DST_HIGH_FIELD   0x0000000B /* =11 */
#define NV_056_SET_COMBINER_ALPHA_OCW_SUM_DST_LOW_FIELD    0x00000008 /* =8 */
#define NV_056_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_0_ADJ    0x00000000
#define NV_056_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_4_ADJ    0x00000400
#define NV_056_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_5_ADJ    0x00000500
#define NV_056_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_8_ADJ    0x00000800
#define NV_056_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_9_ADJ    0x00000900
#define NV_056_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_C_ADJ    0x00000C00
#define NV_056_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_D_ADJ    0x00000D00
#define NV_056_SET_COMBINER_ALPHA_OCW_AB_DST_MSK           0x000000F0 /* 7:4 */ 
#define NV_056_SET_COMBINER_ALPHA_OCW_AB_DST_RMSK          0x0000000F /* 7:4 */ 
#define NV_056_SET_COMBINER_ALPHA_OCW_AB_DST_WORD          0
#define NV_056_SET_COMBINER_ALPHA_OCW_AB_DST_HIGH_FIELD    0x00000007 /* =7 */
#define NV_056_SET_COMBINER_ALPHA_OCW_AB_DST_LOW_FIELD     0x00000004 /* =4 */
#define NV_056_SET_COMBINER_ALPHA_OCW_AB_DST_REG_0_ADJ     0x00000000
#define NV_056_SET_COMBINER_ALPHA_OCW_AB_DST_REG_4_ADJ     0x00000040
#define NV_056_SET_COMBINER_ALPHA_OCW_AB_DST_REG_5_ADJ     0x00000050
#define NV_056_SET_COMBINER_ALPHA_OCW_AB_DST_REG_8_ADJ     0x00000080
#define NV_056_SET_COMBINER_ALPHA_OCW_AB_DST_REG_9_ADJ     0x00000090
#define NV_056_SET_COMBINER_ALPHA_OCW_AB_DST_REG_C_ADJ     0x000000C0
#define NV_056_SET_COMBINER_ALPHA_OCW_AB_DST_REG_D_ADJ     0x000000D0
#define NV_056_SET_COMBINER_ALPHA_OCW_CD_DST_MSK           0x0000000F /* 3:0 */ 
#define NV_056_SET_COMBINER_ALPHA_OCW_CD_DST_RMSK          0x0000000F /* 3:0 */ 
#define NV_056_SET_COMBINER_ALPHA_OCW_CD_DST_WORD          0
#define NV_056_SET_COMBINER_ALPHA_OCW_CD_DST_HIGH_FIELD    0x00000003 /* =3 */
#define NV_056_SET_COMBINER_ALPHA_OCW_CD_DST_LOW_FIELD     0x00000000 /* =0 */
#define NV_056_SET_COMBINER_ALPHA_OCW_CD_DST_REG_0_ADJ     0x00000000
#define NV_056_SET_COMBINER_ALPHA_OCW_CD_DST_REG_4_ADJ     0x00000004
#define NV_056_SET_COMBINER_ALPHA_OCW_CD_DST_REG_5_ADJ     0x00000005
#define NV_056_SET_COMBINER_ALPHA_OCW_CD_DST_REG_8_ADJ     0x00000008
#define NV_056_SET_COMBINER_ALPHA_OCW_CD_DST_REG_9_ADJ     0x00000009
#define NV_056_SET_COMBINER_ALPHA_OCW_CD_DST_REG_C_ADJ     0x0000000C
#define NV_056_SET_COMBINER_ALPHA_OCW_CD_DST_REG_D_ADJ     0x0000000D
#define NV_056_SET_COMBINER_ALPHA_OCW_MSK                  0xFFFFCFFF 
#define NV_056_SET_COMBINER0_COLOR_OCW_ZERO_MSK            0xF8000000 /* 31:27 */ 
#define NV_056_SET_COMBINER0_COLOR_OCW_ZERO_RMSK           0x0000001F /* 31:27 */ 
#define NV_056_SET_COMBINER0_COLOR_OCW_ZERO_WORD           0
#define NV_056_SET_COMBINER0_COLOR_OCW_ZERO_HIGH_FIELD     0x0000001F /* =31 */
#define NV_056_SET_COMBINER0_COLOR_OCW_ZERO_LOW_FIELD      0x0000001B /* =27 */
#define NV_056_SET_COMBINER0_COLOR_OCW_OPERATION_MSK       0x07FF8000 /* 26:15 */ 
#define NV_056_SET_COMBINER0_COLOR_OCW_OPERATION_RMSK      0x00000FFF /* 26:15 */ 
#define NV_056_SET_COMBINER0_COLOR_OCW_OPERATION_WORD      0
#define NV_056_SET_COMBINER0_COLOR_OCW_OPERATION_HIGH_FIELD 0x0000001A /* =26 */
#define NV_056_SET_COMBINER0_COLOR_OCW_OPERATION_LOW_FIELD 0x0000000F /* =15 */
#define NV_056_SET_COMBINER0_COLOR_OCW_OPERATION_NOSHIFT_ADJ 0x00000000
#define NV_056_SET_COMBINER0_COLOR_OCW_OPERATION_NOSHIFT_BIAS_ADJ 0x00008000
#define NV_056_SET_COMBINER0_COLOR_OCW_OPERATION_SHIFTLEFTBY1_ADJ 0x00010000
#define NV_056_SET_COMBINER0_COLOR_OCW_OPERATION_SHIFTLEFTBY1_BIAS_ADJ 0x00018000
#define NV_056_SET_COMBINER0_COLOR_OCW_OPERATION_SHIFTLEFTBY2_ADJ 0x00020000
#define NV_056_SET_COMBINER0_COLOR_OCW_OPERATION_SHIFTRIGHTBY1_ADJ 0x00030000
#define NV_056_SET_COMBINER0_COLOR_OCW_MUX_ENABLE_MSK      0x00004000 /* 14:14 */ 
#define NV_056_SET_COMBINER0_COLOR_OCW_MUX_ENABLE_RMSK     0x00000001 /* 14:14 */ 
#define NV_056_SET_COMBINER0_COLOR_OCW_MUX_ENABLE_WORD     0
#define NV_056_SET_COMBINER0_COLOR_OCW_MUX_ENABLE_HIGH_FIELD 0x0000000E /* =14 */
#define NV_056_SET_COMBINER0_COLOR_OCW_MUX_ENABLE_LOW_FIELD 0x0000000E /* =14 */
#define NV_056_SET_COMBINER0_COLOR_OCW_MUX_ENABLE_FALSE_ADJ 0x00000000
#define NV_056_SET_COMBINER0_COLOR_OCW_MUX_ENABLE_TRUE_ADJ 0x00004000
#define NV_056_SET_COMBINER0_COLOR_OCW_AB_DOT_ENABLE_MSK   0x00002000 /* 13:13 */ 
#define NV_056_SET_COMBINER0_COLOR_OCW_AB_DOT_ENABLE_RMSK  0x00000001 /* 13:13 */ 
#define NV_056_SET_COMBINER0_COLOR_OCW_AB_DOT_ENABLE_WORD  0
#define NV_056_SET_COMBINER0_COLOR_OCW_AB_DOT_ENABLE_HIGH_FIELD 0x0000000D /* =13 */
#define NV_056_SET_COMBINER0_COLOR_OCW_AB_DOT_ENABLE_LOW_FIELD 0x0000000D /* =13 */
#define NV_056_SET_COMBINER0_COLOR_OCW_AB_DOT_ENABLE_FALSE_ADJ 0x00000000
#define NV_056_SET_COMBINER0_COLOR_OCW_AB_DOT_ENABLE_TRUE_ADJ 0x00002000
#define NV_056_SET_COMBINER0_COLOR_OCW_CD_DOT_ENABLE_MSK   0x00001000 /* 12:12 */ 
#define NV_056_SET_COMBINER0_COLOR_OCW_CD_DOT_ENABLE_RMSK  0x00000001 /* 12:12 */ 
#define NV_056_SET_COMBINER0_COLOR_OCW_CD_DOT_ENABLE_WORD  0
#define NV_056_SET_COMBINER0_COLOR_OCW_CD_DOT_ENABLE_HIGH_FIELD 0x0000000C /* =12 */
#define NV_056_SET_COMBINER0_COLOR_OCW_CD_DOT_ENABLE_LOW_FIELD 0x0000000C /* =12 */
#define NV_056_SET_COMBINER0_COLOR_OCW_CD_DOT_ENABLE_FALSE_ADJ 0x00000000
#define NV_056_SET_COMBINER0_COLOR_OCW_CD_DOT_ENABLE_TRUE_ADJ 0x00001000
#define NV_056_SET_COMBINER0_COLOR_OCW_SUM_DST_MSK         0x00000F00 /* 11:8 */ 
#define NV_056_SET_COMBINER0_COLOR_OCW_SUM_DST_RMSK        0x0000000F /* 11:8 */ 
#define NV_056_SET_COMBINER0_COLOR_OCW_SUM_DST_WORD        0
#define NV_056_SET_COMBINER0_COLOR_OCW_SUM_DST_HIGH_FIELD  0x0000000B /* =11 */
#define NV_056_SET_COMBINER0_COLOR_OCW_SUM_DST_LOW_FIELD   0x00000008 /* =8 */
#define NV_056_SET_COMBINER0_COLOR_OCW_SUM_DST_REG_0_ADJ   0x00000000
#define NV_056_SET_COMBINER0_COLOR_OCW_SUM_DST_REG_4_ADJ   0x00000400
#define NV_056_SET_COMBINER0_COLOR_OCW_SUM_DST_REG_5_ADJ   0x00000500
#define NV_056_SET_COMBINER0_COLOR_OCW_SUM_DST_REG_8_ADJ   0x00000800
#define NV_056_SET_COMBINER0_COLOR_OCW_SUM_DST_REG_9_ADJ   0x00000900
#define NV_056_SET_COMBINER0_COLOR_OCW_SUM_DST_REG_C_ADJ   0x00000C00
#define NV_056_SET_COMBINER0_COLOR_OCW_SUM_DST_REG_D_ADJ   0x00000D00
#define NV_056_SET_COMBINER0_COLOR_OCW_AB_DST_MSK          0x000000F0 /* 7:4 */ 
#define NV_056_SET_COMBINER0_COLOR_OCW_AB_DST_RMSK         0x0000000F /* 7:4 */ 
#define NV_056_SET_COMBINER0_COLOR_OCW_AB_DST_WORD         0
#define NV_056_SET_COMBINER0_COLOR_OCW_AB_DST_HIGH_FIELD   0x00000007 /* =7 */
#define NV_056_SET_COMBINER0_COLOR_OCW_AB_DST_LOW_FIELD    0x00000004 /* =4 */
#define NV_056_SET_COMBINER0_COLOR_OCW_AB_DST_REG_0_ADJ    0x00000000
#define NV_056_SET_COMBINER0_COLOR_OCW_AB_DST_REG_4_ADJ    0x00000040
#define NV_056_SET_COMBINER0_COLOR_OCW_AB_DST_REG_5_ADJ    0x00000050
#define NV_056_SET_COMBINER0_COLOR_OCW_AB_DST_REG_8_ADJ    0x00000080
#define NV_056_SET_COMBINER0_COLOR_OCW_AB_DST_REG_9_ADJ    0x00000090
#define NV_056_SET_COMBINER0_COLOR_OCW_AB_DST_REG_C_ADJ    0x000000C0
#define NV_056_SET_COMBINER0_COLOR_OCW_AB_DST_REG_D_ADJ    0x000000D0
#define NV_056_SET_COMBINER0_COLOR_OCW_CD_DST_MSK          0x0000000F /* 3:0 */ 
#define NV_056_SET_COMBINER0_COLOR_OCW_CD_DST_RMSK         0x0000000F /* 3:0 */ 
#define NV_056_SET_COMBINER0_COLOR_OCW_CD_DST_WORD         0
#define NV_056_SET_COMBINER0_COLOR_OCW_CD_DST_HIGH_FIELD   0x00000003 /* =3 */
#define NV_056_SET_COMBINER0_COLOR_OCW_CD_DST_LOW_FIELD    0x00000000 /* =0 */
#define NV_056_SET_COMBINER0_COLOR_OCW_CD_DST_REG_0_ADJ    0x00000000
#define NV_056_SET_COMBINER0_COLOR_OCW_CD_DST_REG_4_ADJ    0x00000004
#define NV_056_SET_COMBINER0_COLOR_OCW_CD_DST_REG_5_ADJ    0x00000005
#define NV_056_SET_COMBINER0_COLOR_OCW_CD_DST_REG_8_ADJ    0x00000008
#define NV_056_SET_COMBINER0_COLOR_OCW_CD_DST_REG_9_ADJ    0x00000009
#define NV_056_SET_COMBINER0_COLOR_OCW_CD_DST_REG_C_ADJ    0x0000000C
#define NV_056_SET_COMBINER0_COLOR_OCW_CD_DST_REG_D_ADJ    0x0000000D
#define NV_056_SET_COMBINER0_COLOR_OCW_MSK                 0xFFFFFFFF 
#define NV_056_SET_COMBINER1_COLOR_OCW_ITERATION_COUNT_MSK 0xF0000000 /* 31:28 */ 
#define NV_056_SET_COMBINER1_COLOR_OCW_ITERATION_COUNT_RMSK 0x0000000F /* 31:28 */ 
#define NV_056_SET_COMBINER1_COLOR_OCW_ITERATION_COUNT_WORD 0
#define NV_056_SET_COMBINER1_COLOR_OCW_ITERATION_COUNT_HIGH_FIELD 0x0000001F /* =31 */
#define NV_056_SET_COMBINER1_COLOR_OCW_ITERATION_COUNT_LOW_FIELD 0x0000001C /* =28 */
#define NV_056_SET_COMBINER1_COLOR_OCW_ITERATION_COUNT_ONE_ADJ 0x10000000
#define NV_056_SET_COMBINER1_COLOR_OCW_ITERATION_COUNT_TWO_ADJ 0x20000000
#define NV_056_SET_COMBINER1_COLOR_OCW_MUX_SELECT_MSK      0x08000000 /* 27:27 */ 
#define NV_056_SET_COMBINER1_COLOR_OCW_MUX_SELECT_RMSK     0x00000001 /* 27:27 */ 
#define NV_056_SET_COMBINER1_COLOR_OCW_MUX_SELECT_WORD     0
#define NV_056_SET_COMBINER1_COLOR_OCW_MUX_SELECT_HIGH_FIELD 0x0000001B /* =27 */
#define NV_056_SET_COMBINER1_COLOR_OCW_MUX_SELECT_LOW_FIELD 0x0000001B /* =27 */
#define NV_056_SET_COMBINER1_COLOR_OCW_MUX_SELECT_LSB_ADJ  0x00000000
#define NV_056_SET_COMBINER1_COLOR_OCW_MUX_SELECT_MSB_ADJ  0x08000000
#define NV_056_SET_COMBINER1_COLOR_OCW_OPERATION_MSK       0x07FF8000 /* 26:15 */ 
#define NV_056_SET_COMBINER1_COLOR_OCW_OPERATION_RMSK      0x00000FFF /* 26:15 */ 
#define NV_056_SET_COMBINER1_COLOR_OCW_OPERATION_WORD      0
#define NV_056_SET_COMBINER1_COLOR_OCW_OPERATION_HIGH_FIELD 0x0000001A /* =26 */
#define NV_056_SET_COMBINER1_COLOR_OCW_OPERATION_LOW_FIELD 0x0000000F /* =15 */
#define NV_056_SET_COMBINER1_COLOR_OCW_OPERATION_NOSHIFT_ADJ 0x00000000
#define NV_056_SET_COMBINER1_COLOR_OCW_OPERATION_NOSHIFT_BIAS_ADJ 0x00008000
#define NV_056_SET_COMBINER1_COLOR_OCW_OPERATION_SHIFTLEFTBY1_ADJ 0x00010000
#define NV_056_SET_COMBINER1_COLOR_OCW_OPERATION_SHIFTLEFTBY1_BIAS_ADJ 0x00018000
#define NV_056_SET_COMBINER1_COLOR_OCW_OPERATION_SHIFTLEFTBY2_ADJ 0x00020000
#define NV_056_SET_COMBINER1_COLOR_OCW_OPERATION_SHIFTRIGHTBY1_ADJ 0x00030000
#define NV_056_SET_COMBINER1_COLOR_OCW_MUX_ENABLE_MSK      0x00004000 /* 14:14 */ 
#define NV_056_SET_COMBINER1_COLOR_OCW_MUX_ENABLE_RMSK     0x00000001 /* 14:14 */ 
#define NV_056_SET_COMBINER1_COLOR_OCW_MUX_ENABLE_WORD     0
#define NV_056_SET_COMBINER1_COLOR_OCW_MUX_ENABLE_HIGH_FIELD 0x0000000E /* =14 */
#define NV_056_SET_COMBINER1_COLOR_OCW_MUX_ENABLE_LOW_FIELD 0x0000000E /* =14 */
#define NV_056_SET_COMBINER1_COLOR_OCW_MUX_ENABLE_FALSE_ADJ 0x00000000
#define NV_056_SET_COMBINER1_COLOR_OCW_MUX_ENABLE_TRUE_ADJ 0x00004000
#define NV_056_SET_COMBINER1_COLOR_OCW_AB_DOT_ENABLE_MSK   0x00002000 /* 13:13 */ 
#define NV_056_SET_COMBINER1_COLOR_OCW_AB_DOT_ENABLE_RMSK  0x00000001 /* 13:13 */ 
#define NV_056_SET_COMBINER1_COLOR_OCW_AB_DOT_ENABLE_WORD  0
#define NV_056_SET_COMBINER1_COLOR_OCW_AB_DOT_ENABLE_HIGH_FIELD 0x0000000D /* =13 */
#define NV_056_SET_COMBINER1_COLOR_OCW_AB_DOT_ENABLE_LOW_FIELD 0x0000000D /* =13 */
#define NV_056_SET_COMBINER1_COLOR_OCW_AB_DOT_ENABLE_FALSE_ADJ 0x00000000
#define NV_056_SET_COMBINER1_COLOR_OCW_AB_DOT_ENABLE_TRUE_ADJ 0x00002000
#define NV_056_SET_COMBINER1_COLOR_OCW_CD_DOT_ENABLE_MSK   0x00001000 /* 12:12 */ 
#define NV_056_SET_COMBINER1_COLOR_OCW_CD_DOT_ENABLE_RMSK  0x00000001 /* 12:12 */ 
#define NV_056_SET_COMBINER1_COLOR_OCW_CD_DOT_ENABLE_WORD  0
#define NV_056_SET_COMBINER1_COLOR_OCW_CD_DOT_ENABLE_HIGH_FIELD 0x0000000C /* =12 */
#define NV_056_SET_COMBINER1_COLOR_OCW_CD_DOT_ENABLE_LOW_FIELD 0x0000000C /* =12 */
#define NV_056_SET_COMBINER1_COLOR_OCW_CD_DOT_ENABLE_FALSE_ADJ 0x00000000
#define NV_056_SET_COMBINER1_COLOR_OCW_CD_DOT_ENABLE_TRUE_ADJ 0x00001000
#define NV_056_SET_COMBINER1_COLOR_OCW_SUM_DST_MSK         0x00000F00 /* 11:8 */ 
#define NV_056_SET_COMBINER1_COLOR_OCW_SUM_DST_RMSK        0x0000000F /* 11:8 */ 
#define NV_056_SET_COMBINER1_COLOR_OCW_SUM_DST_WORD        0
#define NV_056_SET_COMBINER1_COLOR_OCW_SUM_DST_HIGH_FIELD  0x0000000B /* =11 */
#define NV_056_SET_COMBINER1_COLOR_OCW_SUM_DST_LOW_FIELD   0x00000008 /* =8 */
#define NV_056_SET_COMBINER1_COLOR_OCW_SUM_DST_REG_0_ADJ   0x00000000
#define NV_056_SET_COMBINER1_COLOR_OCW_SUM_DST_REG_4_ADJ   0x00000400
#define NV_056_SET_COMBINER1_COLOR_OCW_SUM_DST_REG_5_ADJ   0x00000500
#define NV_056_SET_COMBINER1_COLOR_OCW_SUM_DST_REG_8_ADJ   0x00000800
#define NV_056_SET_COMBINER1_COLOR_OCW_SUM_DST_REG_9_ADJ   0x00000900
#define NV_056_SET_COMBINER1_COLOR_OCW_SUM_DST_REG_C_ADJ   0x00000C00
#define NV_056_SET_COMBINER1_COLOR_OCW_SUM_DST_REG_D_ADJ   0x00000D00
#define NV_056_SET_COMBINER1_COLOR_OCW_AB_DST_MSK          0x000000F0 /* 7:4 */ 
#define NV_056_SET_COMBINER1_COLOR_OCW_AB_DST_RMSK         0x0000000F /* 7:4 */ 
#define NV_056_SET_COMBINER1_COLOR_OCW_AB_DST_WORD         0
#define NV_056_SET_COMBINER1_COLOR_OCW_AB_DST_HIGH_FIELD   0x00000007 /* =7 */
#define NV_056_SET_COMBINER1_COLOR_OCW_AB_DST_LOW_FIELD    0x00000004 /* =4 */
#define NV_056_SET_COMBINER1_COLOR_OCW_AB_DST_REG_0_ADJ    0x00000000
#define NV_056_SET_COMBINER1_COLOR_OCW_AB_DST_REG_4_ADJ    0x00000040
#define NV_056_SET_COMBINER1_COLOR_OCW_AB_DST_REG_5_ADJ    0x00000050
#define NV_056_SET_COMBINER1_COLOR_OCW_AB_DST_REG_8_ADJ    0x00000080
#define NV_056_SET_COMBINER1_COLOR_OCW_AB_DST_REG_9_ADJ    0x00000090
#define NV_056_SET_COMBINER1_COLOR_OCW_AB_DST_REG_C_ADJ    0x000000C0
#define NV_056_SET_COMBINER1_COLOR_OCW_AB_DST_REG_D_ADJ    0x000000D0
#define NV_056_SET_COMBINER1_COLOR_OCW_CD_DST_MSK          0x0000000F /* 3:0 */ 
#define NV_056_SET_COMBINER1_COLOR_OCW_CD_DST_RMSK         0x0000000F /* 3:0 */ 
#define NV_056_SET_COMBINER1_COLOR_OCW_CD_DST_WORD         0
#define NV_056_SET_COMBINER1_COLOR_OCW_CD_DST_HIGH_FIELD   0x00000003 /* =3 */
#define NV_056_SET_COMBINER1_COLOR_OCW_CD_DST_LOW_FIELD    0x00000000 /* =0 */
#define NV_056_SET_COMBINER1_COLOR_OCW_CD_DST_REG_0_ADJ    0x00000000
#define NV_056_SET_COMBINER1_COLOR_OCW_CD_DST_REG_4_ADJ    0x00000004
#define NV_056_SET_COMBINER1_COLOR_OCW_CD_DST_REG_5_ADJ    0x00000005
#define NV_056_SET_COMBINER1_COLOR_OCW_CD_DST_REG_8_ADJ    0x00000008
#define NV_056_SET_COMBINER1_COLOR_OCW_CD_DST_REG_9_ADJ    0x00000009
#define NV_056_SET_COMBINER1_COLOR_OCW_CD_DST_REG_C_ADJ    0x0000000C
#define NV_056_SET_COMBINER1_COLOR_OCW_CD_DST_REG_D_ADJ    0x0000000D
#define NV_056_SET_COMBINER1_COLOR_OCW_MSK                 0xFFFFFFFF 
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW0_A_INVERSE_MSK 0xE0000000 /* 31:29 */ 
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW0_A_INVERSE_RMSK 0x00000007 /* 31:29 */ 
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW0_A_INVERSE_WORD 0
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW0_A_INVERSE_HIGH_FIELD 0x0000001F /* =31 */
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW0_A_INVERSE_LOW_FIELD 0x0000001D /* =29 */
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW0_A_INVERSE_FALSE_ADJ 0x00000000
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW0_A_INVERSE_TRUE_ADJ 0x20000000
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW0_A_ALPHA_MSK   0x10000000 /* 28:28 */ 
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW0_A_ALPHA_RMSK  0x00000001 /* 28:28 */ 
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW0_A_ALPHA_WORD  0
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW0_A_ALPHA_HIGH_FIELD 0x0000001C /* =28 */
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW0_A_ALPHA_LOW_FIELD 0x0000001C /* =28 */
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW0_A_ALPHA_FALSE_ADJ 0x00000000
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW0_A_ALPHA_TRUE_ADJ 0x10000000
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_MSK  0x0F000000 /* 27:24 */ 
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_RMSK 0x0000000F /* 27:24 */ 
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_WORD 0
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_HIGH_FIELD 0x0000001B /* =27 */
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_LOW_FIELD 0x00000018 /* =24 */
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_0_ADJ 0x00000000
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_1_ADJ 0x01000000
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_2_ADJ 0x02000000
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_3_ADJ 0x03000000
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_4_ADJ 0x04000000
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_5_ADJ 0x05000000
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_8_ADJ 0x08000000
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_9_ADJ 0x09000000
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_C_ADJ 0x0C000000
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_D_ADJ 0x0D000000
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_SPECLIT_ADJ 0x0E000000
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_EF_PROD_ADJ 0x0F000000
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW0_B_INVERSE_MSK 0x00E00000 /* 23:21 */ 
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW0_B_INVERSE_RMSK 0x00000007 /* 23:21 */ 
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW0_B_INVERSE_WORD 0
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW0_B_INVERSE_HIGH_FIELD 0x00000017 /* =23 */
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW0_B_INVERSE_LOW_FIELD 0x00000015 /* =21 */
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW0_B_INVERSE_FALSE_ADJ 0x00000000
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW0_B_INVERSE_TRUE_ADJ 0x00200000
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW0_B_ALPHA_MSK   0x00100000 /* 20:20 */ 
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW0_B_ALPHA_RMSK  0x00000001 /* 20:20 */ 
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW0_B_ALPHA_WORD  0
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW0_B_ALPHA_HIGH_FIELD 0x00000014 /* =20 */
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW0_B_ALPHA_LOW_FIELD 0x00000014 /* =20 */
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW0_B_ALPHA_FALSE_ADJ 0x00000000
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW0_B_ALPHA_TRUE_ADJ 0x00100000
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_MSK  0x000F0000 /* 19:16 */ 
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_RMSK 0x0000000F /* 19:16 */ 
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_WORD 0
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_HIGH_FIELD 0x00000013 /* =19 */
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_LOW_FIELD 0x00000010 /* =16 */
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_0_ADJ 0x00000000
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_1_ADJ 0x00010000
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_2_ADJ 0x00020000
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_3_ADJ 0x00030000
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_4_ADJ 0x00040000
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_5_ADJ 0x00050000
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_8_ADJ 0x00080000
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_9_ADJ 0x00090000
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_C_ADJ 0x000C0000
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_D_ADJ 0x000D0000
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_SPECLIT_ADJ 0x000E0000
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_EF_PROD_ADJ 0x000F0000
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW0_C_INVERSE_MSK 0x0000E000 /* 15:13 */ 
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW0_C_INVERSE_RMSK 0x00000007 /* 15:13 */ 
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW0_C_INVERSE_WORD 0
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW0_C_INVERSE_HIGH_FIELD 0x0000000F /* =15 */
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW0_C_INVERSE_LOW_FIELD 0x0000000D /* =13 */
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW0_C_INVERSE_FALSE_ADJ 0x00000000
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW0_C_INVERSE_TRUE_ADJ 0x00002000
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW0_C_ALPHA_MSK   0x00001000 /* 12:12 */ 
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW0_C_ALPHA_RMSK  0x00000001 /* 12:12 */ 
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW0_C_ALPHA_WORD  0
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW0_C_ALPHA_HIGH_FIELD 0x0000000C /* =12 */
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW0_C_ALPHA_LOW_FIELD 0x0000000C /* =12 */
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW0_C_ALPHA_FALSE_ADJ 0x00000000
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW0_C_ALPHA_TRUE_ADJ 0x00001000
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_MSK  0x00000F00 /* 11:8 */ 
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_RMSK 0x0000000F /* 11:8 */ 
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_WORD 0
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_HIGH_FIELD 0x0000000B /* =11 */
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_LOW_FIELD 0x00000008 /* =8 */
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_0_ADJ 0x00000000
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_1_ADJ 0x00000100
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_2_ADJ 0x00000200
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_3_ADJ 0x00000300
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_4_ADJ 0x00000400
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_5_ADJ 0x00000500
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_8_ADJ 0x00000800
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_9_ADJ 0x00000900
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_C_ADJ 0x00000C00
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_D_ADJ 0x00000D00
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_SPECLIT_ADJ 0x00000E00
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_EF_PROD_ADJ 0x00000F00
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW0_D_INVERSE_MSK 0x000000E0 /* 7:5 */ 
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW0_D_INVERSE_RMSK 0x00000007 /* 7:5 */ 
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW0_D_INVERSE_WORD 0
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW0_D_INVERSE_HIGH_FIELD 0x00000007 /* =7 */
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW0_D_INVERSE_LOW_FIELD 0x00000005 /* =5 */
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW0_D_INVERSE_FALSE_ADJ 0x00000000
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW0_D_INVERSE_TRUE_ADJ 0x00000020
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW0_D_ALPHA_MSK   0x00000010 /* 4:4 */ 
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW0_D_ALPHA_RMSK  0x00000001 /* 4:4 */ 
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW0_D_ALPHA_WORD  0
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW0_D_ALPHA_HIGH_FIELD 0x00000004 /* =4 */
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW0_D_ALPHA_LOW_FIELD 0x00000004 /* =4 */
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW0_D_ALPHA_FALSE_ADJ 0x00000000
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW0_D_ALPHA_TRUE_ADJ 0x00000010
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_MSK  0x0000000F /* 3:0 */ 
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_RMSK 0x0000000F /* 3:0 */ 
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_WORD 0
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_HIGH_FIELD 0x00000003 /* =3 */
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_LOW_FIELD 0x00000000 /* =0 */
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_0_ADJ 0x00000000
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_1_ADJ 0x00000001
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_2_ADJ 0x00000002
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_3_ADJ 0x00000003
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_4_ADJ 0x00000004
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_5_ADJ 0x00000005
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_8_ADJ 0x00000008
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_9_ADJ 0x00000009
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_C_ADJ 0x0000000C
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_D_ADJ 0x0000000D
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_SPECLIT_ADJ 0x0000000E
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_EF_PROD_ADJ 0x0000000F
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW0_MSK           0xFFFFFFFF 
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW1_E_INVERSE_MSK 0xE0000000 /* 31:29 */ 
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW1_E_INVERSE_RMSK 0x00000007 /* 31:29 */ 
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW1_E_INVERSE_WORD 0
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW1_E_INVERSE_HIGH_FIELD 0x0000001F /* =31 */
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW1_E_INVERSE_LOW_FIELD 0x0000001D /* =29 */
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW1_E_INVERSE_FALSE_ADJ 0x00000000
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW1_E_INVERSE_TRUE_ADJ 0x20000000
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW1_E_ALPHA_MSK   0x10000000 /* 28:28 */ 
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW1_E_ALPHA_RMSK  0x00000001 /* 28:28 */ 
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW1_E_ALPHA_WORD  0
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW1_E_ALPHA_HIGH_FIELD 0x0000001C /* =28 */
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW1_E_ALPHA_LOW_FIELD 0x0000001C /* =28 */
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW1_E_ALPHA_FALSE_ADJ 0x00000000
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW1_E_ALPHA_TRUE_ADJ 0x10000000
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_MSK  0x0F000000 /* 27:24 */ 
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_RMSK 0x0000000F /* 27:24 */ 
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_WORD 0
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_HIGH_FIELD 0x0000001B /* =27 */
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_LOW_FIELD 0x00000018 /* =24 */
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_0_ADJ 0x00000000
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_1_ADJ 0x01000000
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_2_ADJ 0x02000000
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_3_ADJ 0x03000000
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_4_ADJ 0x04000000
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_5_ADJ 0x05000000
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_8_ADJ 0x08000000
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_9_ADJ 0x09000000
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_C_ADJ 0x0C000000
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_D_ADJ 0x0D000000
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW1_F_INVERSE_MSK 0x00E00000 /* 23:21 */ 
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW1_F_INVERSE_RMSK 0x00000007 /* 23:21 */ 
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW1_F_INVERSE_WORD 0
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW1_F_INVERSE_HIGH_FIELD 0x00000017 /* =23 */
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW1_F_INVERSE_LOW_FIELD 0x00000015 /* =21 */
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW1_F_INVERSE_FALSE_ADJ 0x00000000
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW1_F_INVERSE_TRUE_ADJ 0x00200000
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW1_F_ALPHA_MSK   0x00100000 /* 20:20 */ 
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW1_F_ALPHA_RMSK  0x00000001 /* 20:20 */ 
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW1_F_ALPHA_WORD  0
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW1_F_ALPHA_HIGH_FIELD 0x00000014 /* =20 */
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW1_F_ALPHA_LOW_FIELD 0x00000014 /* =20 */
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW1_F_ALPHA_FALSE_ADJ 0x00000000
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW1_F_ALPHA_TRUE_ADJ 0x00100000
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_MSK  0x000F0000 /* 19:16 */ 
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_RMSK 0x0000000F /* 19:16 */ 
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_WORD 0
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_HIGH_FIELD 0x00000013 /* =19 */
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_LOW_FIELD 0x00000010 /* =16 */
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_0_ADJ 0x00000000
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_1_ADJ 0x00010000
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_2_ADJ 0x00020000
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_3_ADJ 0x00030000
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_4_ADJ 0x00040000
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_5_ADJ 0x00050000
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_8_ADJ 0x00080000
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_9_ADJ 0x00090000
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_C_ADJ 0x000C0000
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_D_ADJ 0x000D0000
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW1_G_INVERSE_MSK 0x0000E000 /* 15:13 */ 
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW1_G_INVERSE_RMSK 0x00000007 /* 15:13 */ 
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW1_G_INVERSE_WORD 0
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW1_G_INVERSE_HIGH_FIELD 0x0000000F /* =15 */
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW1_G_INVERSE_LOW_FIELD 0x0000000D /* =13 */
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW1_G_INVERSE_FALSE_ADJ 0x00000000
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW1_G_INVERSE_TRUE_ADJ 0x00002000
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW1_G_ALPHA_MSK   0x00001000 /* 12:12 */ 
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW1_G_ALPHA_RMSK  0x00000001 /* 12:12 */ 
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW1_G_ALPHA_WORD  0
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW1_G_ALPHA_HIGH_FIELD 0x0000000C /* =12 */
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW1_G_ALPHA_LOW_FIELD 0x0000000C /* =12 */
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW1_G_ALPHA_FALSE_ADJ 0x00000000
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW1_G_ALPHA_TRUE_ADJ 0x00001000
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_MSK  0x00000F00 /* 11:8 */ 
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_RMSK 0x0000000F /* 11:8 */ 
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_WORD 0
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_HIGH_FIELD 0x0000000B /* =11 */
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_LOW_FIELD 0x00000008 /* =8 */
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_0_ADJ 0x00000000
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_1_ADJ 0x00000100
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_2_ADJ 0x00000200
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_3_ADJ 0x00000300
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_4_ADJ 0x00000400
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_5_ADJ 0x00000500
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_8_ADJ 0x00000800
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_9_ADJ 0x00000900
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_C_ADJ 0x00000C00
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_D_ADJ 0x00000D00
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_CLAMP_MSK 0x00000080 /* 7:7 */ 
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_CLAMP_RMSK 0x00000001 /* 7:7 */ 
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_CLAMP_WORD 0
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_CLAMP_HIGH_FIELD 0x00000007 /* =7 */
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_CLAMP_LOW_FIELD 0x00000007 /* =7 */
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_CLAMP_FALSE_ADJ 0x00000000
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_CLAMP_TRUE_ADJ 0x00000080
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_ADD_INVERT_R5_MSK 0x00000040 /* 6:6 */ 
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_ADD_INVERT_R5_RMSK 0x00000001 /* 6:6 */ 
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_ADD_INVERT_R5_WORD 0
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_ADD_INVERT_R5_HIGH_FIELD 0x00000006 /* =6 */
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_ADD_INVERT_R5_LOW_FIELD 0x00000006 /* =6 */
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_ADD_INVERT_R5_FALSE_ADJ 0x00000000
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_ADD_INVERT_R5_TRUE_ADJ 0x00000040
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_ADD_INVERT_R12_MSK 0x0000003F /* 5:0 */ 
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_ADD_INVERT_R12_RMSK 0x0000003F /* 5:0 */ 
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_ADD_INVERT_R12_WORD 0
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_ADD_INVERT_R12_HIGH_FIELD 0x00000005 /* =5 */
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_ADD_INVERT_R12_LOW_FIELD 0x00000000 /* =0 */
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_ADD_INVERT_R12_FALSE_ADJ 0x00000000
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_ADD_INVERT_R12_TRUE_ADJ 0x00000020
#define NV_056_SET_COMBINER_SPECULAR_FOG_CW1_MSK           0xFFFFFFFF 
#define NV_056_SET_CONTROL0_PREMULTIPLIEDALPHA_MSK         0xFF000000 /* 31:24 */ 
#define NV_056_SET_CONTROL0_PREMULTIPLIEDALPHA_RMSK        0x000000FF /* 31:24 */ 
#define NV_056_SET_CONTROL0_PREMULTIPLIEDALPHA_WORD        0
#define NV_056_SET_CONTROL0_PREMULTIPLIEDALPHA_HIGH_FIELD  0x0000001F /* =31 */
#define NV_056_SET_CONTROL0_PREMULTIPLIEDALPHA_LOW_FIELD   0x00000018 /* =24 */
#define NV_056_SET_CONTROL0_PREMULTIPLIEDALPHA_FALSE_ADJ   0x00000000
#define NV_056_SET_CONTROL0_PREMULTIPLIEDALPHA_TRUE_ADJ    0x01000000
#define NV_056_SET_CONTROL0_TEXTUREPERSPECTIVE_MSK         0x00F00000 /* 23:20 */ 
#define NV_056_SET_CONTROL0_TEXTUREPERSPECTIVE_RMSK        0x0000000F /* 23:20 */ 
#define NV_056_SET_CONTROL0_TEXTUREPERSPECTIVE_WORD        0
#define NV_056_SET_CONTROL0_TEXTUREPERSPECTIVE_HIGH_FIELD  0x00000017 /* =23 */
#define NV_056_SET_CONTROL0_TEXTUREPERSPECTIVE_LOW_FIELD   0x00000014 /* =20 */
#define NV_056_SET_CONTROL0_TEXTUREPERSPECTIVE_FALSE_ADJ   0x00000000
#define NV_056_SET_CONTROL0_TEXTUREPERSPECTIVE_TRUE_ADJ    0x00100000
#define NV_056_SET_CONTROL0_Z_PERSPECTIVE_ENABLE_MSK       0x000F0000 /* 19:16 */ 
#define NV_056_SET_CONTROL0_Z_PERSPECTIVE_ENABLE_RMSK      0x0000000F /* 19:16 */ 
#define NV_056_SET_CONTROL0_Z_PERSPECTIVE_ENABLE_WORD      0
#define NV_056_SET_CONTROL0_Z_PERSPECTIVE_ENABLE_HIGH_FIELD 0x00000013 /* =19 */
#define NV_056_SET_CONTROL0_Z_PERSPECTIVE_ENABLE_LOW_FIELD 0x00000010 /* =16 */
#define NV_056_SET_CONTROL0_Z_PERSPECTIVE_ENABLE_FALSE_ADJ 0x00000000
#define NV_056_SET_CONTROL0_Z_PERSPECTIVE_ENABLE_TRUE_ADJ  0x00010000
#define NV_056_SET_CONTROL0_Z_FORMAT_MSK                   0x0000F000 /* 15:12 */ 
#define NV_056_SET_CONTROL0_Z_FORMAT_RMSK                  0x0000000F /* 15:12 */ 
#define NV_056_SET_CONTROL0_Z_FORMAT_WORD                  0
#define NV_056_SET_CONTROL0_Z_FORMAT_HIGH_FIELD            0x0000000F /* =15 */
#define NV_056_SET_CONTROL0_Z_FORMAT_LOW_FIELD             0x0000000C /* =12 */
#define NV_056_SET_CONTROL0_Z_FORMAT_FIXED_ADJ             0x00000000
#define NV_056_SET_CONTROL0_Z_FORMAT_FLOAT_ADJ             0x00001000
#define NV_056_SET_CONTROL0_WBUFFER_SELECT_MSK             0x00000F00 /* 11:8 */ 
#define NV_056_SET_CONTROL0_WBUFFER_SELECT_RMSK            0x0000000F /* 11:8 */ 
#define NV_056_SET_CONTROL0_WBUFFER_SELECT_WORD            0
#define NV_056_SET_CONTROL0_WBUFFER_SELECT_HIGH_FIELD      0x0000000B /* =11 */
#define NV_056_SET_CONTROL0_WBUFFER_SELECT_LOW_FIELD       0x00000008 /* =8 */
#define NV_056_SET_CONTROL0_WBUFFER_SELECT_0_ADJ           0x00000000
#define NV_056_SET_CONTROL0_WBUFFER_SELECT_1_ADJ           0x00000100
#define NV_056_SET_CONTROL0_STENCIL_WRITE_ENABLE_MSK       0x000000FF /* 7:0 */ 
#define NV_056_SET_CONTROL0_STENCIL_WRITE_ENABLE_RMSK      0x000000FF /* 7:0 */ 
#define NV_056_SET_CONTROL0_STENCIL_WRITE_ENABLE_WORD      0
#define NV_056_SET_CONTROL0_STENCIL_WRITE_ENABLE_HIGH_FIELD 0x00000007 /* =7 */
#define NV_056_SET_CONTROL0_STENCIL_WRITE_ENABLE_LOW_FIELD 0x00000000 /* =0 */
#define NV_056_SET_CONTROL0_STENCIL_WRITE_ENABLE_FALSE_ADJ 0x00000000
#define NV_056_SET_CONTROL0_STENCIL_WRITE_ENABLE_TRUE_ADJ  0x00000001
#define NV_056_SET_CONTROL0_MSK                            0xFFFFFFFF 
#define NV_056_SET_LIGHT_CONTROL_LOCALEYE_MSK              0xFFFF0000 /* 31:16 */ 
#define NV_056_SET_LIGHT_CONTROL_LOCALEYE_RMSK             0x0000FFFF /* 31:16 */ 
#define NV_056_SET_LIGHT_CONTROL_LOCALEYE_WORD             0
#define NV_056_SET_LIGHT_CONTROL_LOCALEYE_HIGH_FIELD       0x0000001F /* =31 */
#define NV_056_SET_LIGHT_CONTROL_LOCALEYE_LOW_FIELD        0x00000010 /* =16 */
#define NV_056_SET_LIGHT_CONTROL_LOCALEYE_FALSE_ADJ        0x00000000
#define NV_056_SET_LIGHT_CONTROL_LOCALEYE_TRUE_ADJ         0x00010000
#define NV_056_SET_LIGHT_CONTROL_ATTENUATION_MODE_MSK      0x0000FFFC /* 15:2 */ 
#define NV_056_SET_LIGHT_CONTROL_ATTENUATION_MODE_RMSK     0x00003FFF /* 15:2 */ 
#define NV_056_SET_LIGHT_CONTROL_ATTENUATION_MODE_WORD     0
#define NV_056_SET_LIGHT_CONTROL_ATTENUATION_MODE_HIGH_FIELD 0x0000000F /* =15 */
#define NV_056_SET_LIGHT_CONTROL_ATTENUATION_MODE_LOW_FIELD 0x00000002 /* =2 */
#define NV_056_SET_LIGHT_CONTROL_ATTENUATION_MODE_INVERT_ADJ 0x00000000
#define NV_056_SET_LIGHT_CONTROL_ATTENUATION_MODE_NOT_INVERT_ADJ 0x00000004
#define NV_056_SET_LIGHT_CONTROL_SEPARATE_SPECULAR_EN_MSK  0x00000002 /* 1:1 */ 
#define NV_056_SET_LIGHT_CONTROL_SEPARATE_SPECULAR_EN_RMSK 0x00000001 /* 1:1 */ 
#define NV_056_SET_LIGHT_CONTROL_SEPARATE_SPECULAR_EN_WORD 0
#define NV_056_SET_LIGHT_CONTROL_SEPARATE_SPECULAR_EN_HIGH_FIELD 0x00000001 /* =1 */
#define NV_056_SET_LIGHT_CONTROL_SEPARATE_SPECULAR_EN_LOW_FIELD 0x00000001 /* =1 */
#define NV_056_SET_LIGHT_CONTROL_SEPARATE_SPECULAR_EN_FALSE_ADJ 0x00000000
#define NV_056_SET_LIGHT_CONTROL_SEPARATE_SPECULAR_EN_TRUE_ADJ 0x00000002
#define NV_056_SET_LIGHT_CONTROL_SECONDARY_COLOR_EN_MSK    0x00000001 /* 0:0 */ 
#define NV_056_SET_LIGHT_CONTROL_SECONDARY_COLOR_EN_RMSK   0x00000001 /* 0:0 */ 
#define NV_056_SET_LIGHT_CONTROL_SECONDARY_COLOR_EN_WORD   0
#define NV_056_SET_LIGHT_CONTROL_SECONDARY_COLOR_EN_HIGH_FIELD 0x00000000 /* =0 */
#define NV_056_SET_LIGHT_CONTROL_SECONDARY_COLOR_EN_LOW_FIELD 0x00000000 /* =0 */
#define NV_056_SET_LIGHT_CONTROL_SECONDARY_COLOR_EN_FALSE_ADJ 0x00000000
#define NV_056_SET_LIGHT_CONTROL_SECONDARY_COLOR_EN_TRUE_ADJ 0x00000001
#define NV_056_SET_LIGHT_CONTROL_MSK                       0xFFFFFFFF 
#define NV_056_SET_COLOR_MATERIAL_V_MSK                    0xFFFFFFFF /* 31:0 */ 
#define NV_056_SET_COLOR_MATERIAL_V_RMSK                   0xFFFFFFFF /* 31:0 */ 
#define NV_056_SET_COLOR_MATERIAL_V_WORD                   0
#define NV_056_SET_COLOR_MATERIAL_V_HIGH_FIELD             0x0000001F /* =31 */
#define NV_056_SET_COLOR_MATERIAL_V_LOW_FIELD              0x00000000 /* =0 */
#define NV_056_SET_COLOR_MATERIAL_V_DISABLED_ADJ           0x00000000
#define NV_056_SET_COLOR_MATERIAL_V_EMISSION_ADJ           0x00000001
#define NV_056_SET_COLOR_MATERIAL_V_AMBIENT_ADJ            0x00000002
#define NV_056_SET_COLOR_MATERIAL_V_EMISSION_AMBIENT_ADJ   0x00000003
#define NV_056_SET_COLOR_MATERIAL_V_DIFFUSE_ADJ            0x00000004
#define NV_056_SET_COLOR_MATERIAL_V_EMISSION_DIFFUSE_ADJ   0x00000005
#define NV_056_SET_COLOR_MATERIAL_V_AMBIENT_DIFFUSE_ADJ    0x00000006
#define NV_056_SET_COLOR_MATERIAL_V_EMISSION_AMBIENT_DIFFUSE_ADJ 0x00000007
#define NV_056_SET_COLOR_MATERIAL_V_SPECULAR_ADJ           0x00000008
#define NV_056_SET_COLOR_MATERIAL_V_EMISSION_SPECULAR_ADJ  0x00000009
#define NV_056_SET_COLOR_MATERIAL_V_AMBIENT_SPECULAR_ADJ   0x0000000A
#define NV_056_SET_COLOR_MATERIAL_V_EMISSION_AMBIENT_SPECULAR_ADJ 0x0000000B
#define NV_056_SET_COLOR_MATERIAL_V_DIFFUSE_SPECULAR_ADJ   0x0000000C
#define NV_056_SET_COLOR_MATERIAL_V_EMISSION_DIFFUSE_SPECULAR_ADJ 0x0000000D
#define NV_056_SET_COLOR_MATERIAL_V_AMBIENT_DIFFUSE_SPECULAR_ADJ 0x0000000E
#define NV_056_SET_COLOR_MATERIAL_V_EMISSION_AMBIENT_DIFFUSE_SPECULAR_ADJ 0x0000000F
#define NV_056_SET_COLOR_MATERIAL_MSK                      0xFFFFFFFF 
#define NV_056_SET_FOG_MODE_FOG_MODE_MSK                   0xFFFFFFFF /* 31:0 */ 
#define NV_056_SET_FOG_MODE_FOG_MODE_RMSK                  0xFFFFFFFF /* 31:0 */ 
#define NV_056_SET_FOG_MODE_FOG_MODE_WORD                  0
#define NV_056_SET_FOG_MODE_FOG_MODE_HIGH_FIELD            0x0000001F /* =31 */
#define NV_056_SET_FOG_MODE_FOG_MODE_LOW_FIELD             0x00000000 /* =0 */
#define NV_056_SET_FOG_MODE_FOG_MODE_LINEAR_ADJ            0x00002601
#define NV_056_SET_FOG_MODE_FOG_MODE_EXP_ADJ               0x00000800
#define NV_056_SET_FOG_MODE_FOG_MODE_EXP2_ADJ              0x00000801
#define NV_056_SET_FOG_MODE_FOG_MODE_EXP_ABS_ADJ           0x00000802
#define NV_056_SET_FOG_MODE_FOG_MODE_EXP2_ABS_ADJ          0x00000803
#define NV_056_SET_FOG_MODE_MSK                            0xFFFFFFFF 
#define NV_056_SET_FOG_GEN_MODE_FOG_GEN_MODE_MSK           0xFFFFFFFF /* 31:0 */ 
#define NV_056_SET_FOG_GEN_MODE_FOG_GEN_MODE_RMSK          0xFFFFFFFF /* 31:0 */ 
#define NV_056_SET_FOG_GEN_MODE_FOG_GEN_MODE_WORD          0
#define NV_056_SET_FOG_GEN_MODE_FOG_GEN_MODE_HIGH_FIELD    0x0000001F /* =31 */
#define NV_056_SET_FOG_GEN_MODE_FOG_GEN_MODE_LOW_FIELD     0x00000000 /* =0 */
#define NV_056_SET_FOG_GEN_MODE_FOG_GEN_MODE_USE_INPUT_ADJ 0x00000000
#define NV_056_SET_FOG_GEN_MODE_FOG_GEN_MODE_RADIAL_ADJ    0x00000001
#define NV_056_SET_FOG_GEN_MODE_FOG_GEN_MODE_PLANAR_ADJ    0x00000002
#define NV_056_SET_FOG_GEN_MODE_FOG_GEN_MODE_ABS_PLANAR_ADJ 0x00000003
#define NV_056_SET_FOG_GEN_MODE_MSK                        0xFFFFFFFF 
#define NV_056_SET_FOG_ENABLE_V_MSK                        0xFFFFFFFF /* 31:0 */ 
#define NV_056_SET_FOG_ENABLE_V_RMSK                       0xFFFFFFFF /* 31:0 */ 
#define NV_056_SET_FOG_ENABLE_V_WORD                       0
#define NV_056_SET_FOG_ENABLE_V_HIGH_FIELD                 0x0000001F /* =31 */
#define NV_056_SET_FOG_ENABLE_V_LOW_FIELD                  0x00000000 /* =0 */
#define NV_056_SET_FOG_ENABLE_V_FALSE_ADJ                  0x00000000
#define NV_056_SET_FOG_ENABLE_V_TRUE_ADJ                   0x00000001
#define NV_056_SET_FOG_ENABLE_MSK                          0xFFFFFFFF 
#define NV_056_SET_FOG_COLOR_FOG_COLOR_RED_MSK             0x000000FF /* 7:0 */ 
#define NV_056_SET_FOG_COLOR_FOG_COLOR_RED_RMSK            0x000000FF /* 7:0 */ 
#define NV_056_SET_FOG_COLOR_FOG_COLOR_RED_WORD            0
#define NV_056_SET_FOG_COLOR_FOG_COLOR_RED_HIGH_FIELD      0x00000007 /* =7 */
#define NV_056_SET_FOG_COLOR_FOG_COLOR_RED_LOW_FIELD       0x00000000 /* =0 */
#define NV_056_SET_FOG_COLOR_FOG_COLOR_GREEN_MSK           0x0000FF00 /* 15:8 */ 
#define NV_056_SET_FOG_COLOR_FOG_COLOR_GREEN_RMSK          0x000000FF /* 15:8 */ 
#define NV_056_SET_FOG_COLOR_FOG_COLOR_GREEN_WORD          0
#define NV_056_SET_FOG_COLOR_FOG_COLOR_GREEN_HIGH_FIELD    0x0000000F /* =15 */
#define NV_056_SET_FOG_COLOR_FOG_COLOR_GREEN_LOW_FIELD     0x00000008 /* =8 */
#define NV_056_SET_FOG_COLOR_FOG_COLOR_BLUE_MSK            0x00FF0000 /* 23:16 */ 
#define NV_056_SET_FOG_COLOR_FOG_COLOR_BLUE_RMSK           0x000000FF /* 23:16 */ 
#define NV_056_SET_FOG_COLOR_FOG_COLOR_BLUE_WORD           0
#define NV_056_SET_FOG_COLOR_FOG_COLOR_BLUE_HIGH_FIELD     0x00000017 /* =23 */
#define NV_056_SET_FOG_COLOR_FOG_COLOR_BLUE_LOW_FIELD      0x00000010 /* =16 */
#define NV_056_SET_FOG_COLOR_FOG_COLOR_ALPHA_MSK           0xFF000000 /* 31:24 */ 
#define NV_056_SET_FOG_COLOR_FOG_COLOR_ALPHA_RMSK          0x000000FF /* 31:24 */ 
#define NV_056_SET_FOG_COLOR_FOG_COLOR_ALPHA_WORD          0
#define NV_056_SET_FOG_COLOR_FOG_COLOR_ALPHA_HIGH_FIELD    0x0000001F /* =31 */
#define NV_056_SET_FOG_COLOR_FOG_COLOR_ALPHA_LOW_FIELD     0x00000018 /* =24 */
#define NV_056_SET_FOG_COLOR_MSK                           0xFFFFFFFF 
#define NV_056_SET_COLOR_KEY_COLOR_V_MSK                   0xFFFFFFFF /* 31:0 */ 
#define NV_056_SET_COLOR_KEY_COLOR_V_RMSK                  0xFFFFFFFF /* 31:0 */ 
#define NV_056_SET_COLOR_KEY_COLOR_V_WORD                  0
#define NV_056_SET_COLOR_KEY_COLOR_V_HIGH_FIELD            0x0000001F /* =31 */
#define NV_056_SET_COLOR_KEY_COLOR_V_LOW_FIELD             0x00000000 /* =0 */
#define NV_056_SET_COLOR_KEY_COLOR_MSK                     0xFFFFFFFF 
#define NV_056_SET_WINDOW_CLIP_TYPE_V_MSK                  0xFFFFFFFF /* 31:0 */ 
#define NV_056_SET_WINDOW_CLIP_TYPE_V_RMSK                 0xFFFFFFFF /* 31:0 */ 
#define NV_056_SET_WINDOW_CLIP_TYPE_V_WORD                 0
#define NV_056_SET_WINDOW_CLIP_TYPE_V_HIGH_FIELD           0x0000001F /* =31 */
#define NV_056_SET_WINDOW_CLIP_TYPE_V_LOW_FIELD            0x00000000 /* =0 */
#define NV_056_SET_WINDOW_CLIP_TYPE_V_INCLUSIVE_ADJ        0x00000000
#define NV_056_SET_WINDOW_CLIP_TYPE_V_EXCLUSIVE_ADJ        0x00000001
#define NV_056_SET_WINDOW_CLIP_TYPE_MSK                    0xFFFFFFFF 
#define NV_056_SET_WINDOW_CLIP_HORIZONTAL_XMIN_MSK         0x0000FFFF /* 15:0 */ 
#define NV_056_SET_WINDOW_CLIP_HORIZONTAL_XMIN_RMSK        0x0000FFFF /* 15:0 */ 
#define NV_056_SET_WINDOW_CLIP_HORIZONTAL_XMIN_WORD        0
#define NV_056_SET_WINDOW_CLIP_HORIZONTAL_XMIN_HIGH_FIELD  0x0000000F /* =15 */
#define NV_056_SET_WINDOW_CLIP_HORIZONTAL_XMIN_LOW_FIELD   0x00000000 /* =0 */
#define NV_056_SET_WINDOW_CLIP_HORIZONTAL_XMAX_MSK         0xFFFF0000 /* 31:16 */ 
#define NV_056_SET_WINDOW_CLIP_HORIZONTAL_XMAX_RMSK        0x0000FFFF /* 31:16 */ 
#define NV_056_SET_WINDOW_CLIP_HORIZONTAL_XMAX_WORD        0
#define NV_056_SET_WINDOW_CLIP_HORIZONTAL_XMAX_HIGH_FIELD  0x0000001F /* =31 */
#define NV_056_SET_WINDOW_CLIP_HORIZONTAL_XMAX_LOW_FIELD   0x00000010 /* =16 */
#define NV_056_SET_WINDOW_CLIP_HORIZONTAL_MSK              0xFFFFFFFF 
#define NV_056_SET_WINDOW_CLIP_VERTICAL_YMIN_MSK           0x0000FFFF /* 15:0 */ 
#define NV_056_SET_WINDOW_CLIP_VERTICAL_YMIN_RMSK          0x0000FFFF /* 15:0 */ 
#define NV_056_SET_WINDOW_CLIP_VERTICAL_YMIN_WORD          0
#define NV_056_SET_WINDOW_CLIP_VERTICAL_YMIN_HIGH_FIELD    0x0000000F /* =15 */
#define NV_056_SET_WINDOW_CLIP_VERTICAL_YMIN_LOW_FIELD     0x00000000 /* =0 */
#define NV_056_SET_WINDOW_CLIP_VERTICAL_YMAX_MSK           0xFFFF0000 /* 31:16 */ 
#define NV_056_SET_WINDOW_CLIP_VERTICAL_YMAX_RMSK          0x0000FFFF /* 31:16 */ 
#define NV_056_SET_WINDOW_CLIP_VERTICAL_YMAX_WORD          0
#define NV_056_SET_WINDOW_CLIP_VERTICAL_YMAX_HIGH_FIELD    0x0000001F /* =31 */
#define NV_056_SET_WINDOW_CLIP_VERTICAL_YMAX_LOW_FIELD     0x00000010 /* =16 */
#define NV_056_SET_WINDOW_CLIP_VERTICAL_MSK                0xFFFFFFFF 
#define NV_056_SET_ALPHA_TEST_ENABLE_V_MSK                 0xFFFFFFFF /* 31:0 */ 
#define NV_056_SET_ALPHA_TEST_ENABLE_V_RMSK                0xFFFFFFFF /* 31:0 */ 
#define NV_056_SET_ALPHA_TEST_ENABLE_V_WORD                0
#define NV_056_SET_ALPHA_TEST_ENABLE_V_HIGH_FIELD          0x0000001F /* =31 */
#define NV_056_SET_ALPHA_TEST_ENABLE_V_LOW_FIELD           0x00000000 /* =0 */
#define NV_056_SET_ALPHA_TEST_ENABLE_V_FALSE_ADJ           0x00000000
#define NV_056_SET_ALPHA_TEST_ENABLE_V_TRUE_ADJ            0x00000001
#define NV_056_SET_ALPHA_TEST_ENABLE_MSK                   0xFFFFFFFF 
#define NV_056_SET_BLEND_ENABLE_V_MSK                      0xFFFFFFFF /* 31:0 */ 
#define NV_056_SET_BLEND_ENABLE_V_RMSK                     0xFFFFFFFF /* 31:0 */ 
#define NV_056_SET_BLEND_ENABLE_V_WORD                     0
#define NV_056_SET_BLEND_ENABLE_V_HIGH_FIELD               0x0000001F /* =31 */
#define NV_056_SET_BLEND_ENABLE_V_LOW_FIELD                0x00000000 /* =0 */
#define NV_056_SET_BLEND_ENABLE_V_FALSE_ADJ                0x00000000
#define NV_056_SET_BLEND_ENABLE_V_TRUE_ADJ                 0x00000001
#define NV_056_SET_BLEND_ENABLE_MSK                        0xFFFFFFFF 
#define NV_056_SET_CULL_FACE_ENABLE_V_MSK                  0xFFFFFFFF /* 31:0 */ 
#define NV_056_SET_CULL_FACE_ENABLE_V_RMSK                 0xFFFFFFFF /* 31:0 */ 
#define NV_056_SET_CULL_FACE_ENABLE_V_WORD                 0
#define NV_056_SET_CULL_FACE_ENABLE_V_HIGH_FIELD           0x0000001F /* =31 */
#define NV_056_SET_CULL_FACE_ENABLE_V_LOW_FIELD            0x00000000 /* =0 */
#define NV_056_SET_CULL_FACE_ENABLE_V_FALSE_ADJ            0x00000000
#define NV_056_SET_CULL_FACE_ENABLE_V_TRUE_ADJ             0x00000001
#define NV_056_SET_CULL_FACE_ENABLE_MSK                    0xFFFFFFFF 
#define NV_056_SET_DEPTH_TEST_ENABLE_V_MSK                 0xFFFFFFFF /* 31:0 */ 
#define NV_056_SET_DEPTH_TEST_ENABLE_V_RMSK                0xFFFFFFFF /* 31:0 */ 
#define NV_056_SET_DEPTH_TEST_ENABLE_V_WORD                0
#define NV_056_SET_DEPTH_TEST_ENABLE_V_HIGH_FIELD          0x0000001F /* =31 */
#define NV_056_SET_DEPTH_TEST_ENABLE_V_LOW_FIELD           0x00000000 /* =0 */
#define NV_056_SET_DEPTH_TEST_ENABLE_V_FALSE_ADJ           0x00000000
#define NV_056_SET_DEPTH_TEST_ENABLE_V_TRUE_ADJ            0x00000001
#define NV_056_SET_DEPTH_TEST_ENABLE_MSK                   0xFFFFFFFF 
#define NV_056_SET_DITHER_ENABLE_V_MSK                     0xFFFFFFFF /* 31:0 */ 
#define NV_056_SET_DITHER_ENABLE_V_RMSK                    0xFFFFFFFF /* 31:0 */ 
#define NV_056_SET_DITHER_ENABLE_V_WORD                    0
#define NV_056_SET_DITHER_ENABLE_V_HIGH_FIELD              0x0000001F /* =31 */
#define NV_056_SET_DITHER_ENABLE_V_LOW_FIELD               0x00000000 /* =0 */
#define NV_056_SET_DITHER_ENABLE_V_FALSE_ADJ               0x00000000
#define NV_056_SET_DITHER_ENABLE_V_TRUE_ADJ                0x00000001
#define NV_056_SET_DITHER_ENABLE_MSK                       0xFFFFFFFF 
#define NV_056_SET_LIGHTING_ENABLE_V_MSK                   0xFFFFFFFF /* 31:0 */ 
#define NV_056_SET_LIGHTING_ENABLE_V_RMSK                  0xFFFFFFFF /* 31:0 */ 
#define NV_056_SET_LIGHTING_ENABLE_V_WORD                  0
#define NV_056_SET_LIGHTING_ENABLE_V_HIGH_FIELD            0x0000001F /* =31 */
#define NV_056_SET_LIGHTING_ENABLE_V_LOW_FIELD             0x00000000 /* =0 */
#define NV_056_SET_LIGHTING_ENABLE_V_FALSE_ADJ             0x00000000
#define NV_056_SET_LIGHTING_ENABLE_V_TRUE_ADJ              0x00000001
#define NV_056_SET_LIGHTING_ENABLE_MSK                     0xFFFFFFFF 
#define NV_056_SET_POINT_PARAMS_ENABLE_V_MSK               0xFFFFFFFF /* 31:0 */ 
#define NV_056_SET_POINT_PARAMS_ENABLE_V_RMSK              0xFFFFFFFF /* 31:0 */ 
#define NV_056_SET_POINT_PARAMS_ENABLE_V_WORD              0
#define NV_056_SET_POINT_PARAMS_ENABLE_V_HIGH_FIELD        0x0000001F /* =31 */
#define NV_056_SET_POINT_PARAMS_ENABLE_V_LOW_FIELD         0x00000000 /* =0 */
#define NV_056_SET_POINT_PARAMS_ENABLE_V_FALSE_ADJ         0x00000000
#define NV_056_SET_POINT_PARAMS_ENABLE_V_TRUE_ADJ          0x00000001
#define NV_056_SET_POINT_PARAMS_ENABLE_MSK                 0xFFFFFFFF 
#define NV_056_SET_POINT_SMOOTH_ENABLE_V_MSK               0xFFFFFFFF /* 31:0 */ 
#define NV_056_SET_POINT_SMOOTH_ENABLE_V_RMSK              0xFFFFFFFF /* 31:0 */ 
#define NV_056_SET_POINT_SMOOTH_ENABLE_V_WORD              0
#define NV_056_SET_POINT_SMOOTH_ENABLE_V_HIGH_FIELD        0x0000001F /* =31 */
#define NV_056_SET_POINT_SMOOTH_ENABLE_V_LOW_FIELD         0x00000000 /* =0 */
#define NV_056_SET_POINT_SMOOTH_ENABLE_V_FALSE_ADJ         0x00000000
#define NV_056_SET_POINT_SMOOTH_ENABLE_V_TRUE_ADJ          0x00000001
#define NV_056_SET_POINT_SMOOTH_ENABLE_MSK                 0xFFFFFFFF 
#define NV_056_SET_LINE_SMOOTH_ENABLE_V_MSK                0xFFFFFFFF /* 31:0 */ 
#define NV_056_SET_LINE_SMOOTH_ENABLE_V_RMSK               0xFFFFFFFF /* 31:0 */ 
#define NV_056_SET_LINE_SMOOTH_ENABLE_V_WORD               0
#define NV_056_SET_LINE_SMOOTH_ENABLE_V_HIGH_FIELD         0x0000001F /* =31 */
#define NV_056_SET_LINE_SMOOTH_ENABLE_V_LOW_FIELD          0x00000000 /* =0 */
#define NV_056_SET_LINE_SMOOTH_ENABLE_V_FALSE_ADJ          0x00000000
#define NV_056_SET_LINE_SMOOTH_ENABLE_V_TRUE_ADJ           0x00000001
#define NV_056_SET_LINE_SMOOTH_ENABLE_MSK                  0xFFFFFFFF 
#define NV_056_SET_POLY_SMOOTH_ENABLE_V_MSK                0xFFFFFFFF /* 31:0 */ 
#define NV_056_SET_POLY_SMOOTH_ENABLE_V_RMSK               0xFFFFFFFF /* 31:0 */ 
#define NV_056_SET_POLY_SMOOTH_ENABLE_V_WORD               0
#define NV_056_SET_POLY_SMOOTH_ENABLE_V_HIGH_FIELD         0x0000001F /* =31 */
#define NV_056_SET_POLY_SMOOTH_ENABLE_V_LOW_FIELD          0x00000000 /* =0 */
#define NV_056_SET_POLY_SMOOTH_ENABLE_V_FALSE_ADJ          0x00000000
#define NV_056_SET_POLY_SMOOTH_ENABLE_V_TRUE_ADJ           0x00000001
#define NV_056_SET_POLY_SMOOTH_ENABLE_MSK                  0xFFFFFFFF 
#define NV_056_SET_SKIN_ENABLE_V_MSK                       0xFFFFFFFF /* 31:0 */ 
#define NV_056_SET_SKIN_ENABLE_V_RMSK                      0xFFFFFFFF /* 31:0 */ 
#define NV_056_SET_SKIN_ENABLE_V_WORD                      0
#define NV_056_SET_SKIN_ENABLE_V_HIGH_FIELD                0x0000001F /* =31 */
#define NV_056_SET_SKIN_ENABLE_V_LOW_FIELD                 0x00000000 /* =0 */
#define NV_056_SET_SKIN_ENABLE_V_FALSE_ADJ                 0x00000000
#define NV_056_SET_SKIN_ENABLE_V_TRUE_ADJ                  0x00000001
#define NV_056_SET_SKIN_ENABLE_MSK                         0xFFFFFFFF 
#define NV_056_SET_STENCIL_TEST_ENABLE_V_MSK               0xFFFFFFFF /* 31:0 */ 
#define NV_056_SET_STENCIL_TEST_ENABLE_V_RMSK              0xFFFFFFFF /* 31:0 */ 
#define NV_056_SET_STENCIL_TEST_ENABLE_V_WORD              0
#define NV_056_SET_STENCIL_TEST_ENABLE_V_HIGH_FIELD        0x0000001F /* =31 */
#define NV_056_SET_STENCIL_TEST_ENABLE_V_LOW_FIELD         0x00000000 /* =0 */
#define NV_056_SET_STENCIL_TEST_ENABLE_V_FALSE_ADJ         0x00000000
#define NV_056_SET_STENCIL_TEST_ENABLE_V_TRUE_ADJ          0x00000001
#define NV_056_SET_STENCIL_TEST_ENABLE_MSK                 0xFFFFFFFF 
#define NV_056_SET_POLY_OFFSET_POINT_ENABLE_V_MSK          0xFFFFFFFF /* 31:0 */ 
#define NV_056_SET_POLY_OFFSET_POINT_ENABLE_V_RMSK         0xFFFFFFFF /* 31:0 */ 
#define NV_056_SET_POLY_OFFSET_POINT_ENABLE_V_WORD         0
#define NV_056_SET_POLY_OFFSET_POINT_ENABLE_V_HIGH_FIELD   0x0000001F /* =31 */
#define NV_056_SET_POLY_OFFSET_POINT_ENABLE_V_LOW_FIELD    0x00000000 /* =0 */
#define NV_056_SET_POLY_OFFSET_POINT_ENABLE_V_FALSE_ADJ    0x00000000
#define NV_056_SET_POLY_OFFSET_POINT_ENABLE_V_TRUE_ADJ     0x00000001
#define NV_056_SET_POLY_OFFSET_POINT_ENABLE_MSK            0xFFFFFFFF 
#define NV_056_SET_POLY_OFFSET_LINE_ENABLE_V_MSK           0xFFFFFFFF /* 31:0 */ 
#define NV_056_SET_POLY_OFFSET_LINE_ENABLE_V_RMSK          0xFFFFFFFF /* 31:0 */ 
#define NV_056_SET_POLY_OFFSET_LINE_ENABLE_V_WORD          0
#define NV_056_SET_POLY_OFFSET_LINE_ENABLE_V_HIGH_FIELD    0x0000001F /* =31 */
#define NV_056_SET_POLY_OFFSET_LINE_ENABLE_V_LOW_FIELD     0x00000000 /* =0 */
#define NV_056_SET_POLY_OFFSET_LINE_ENABLE_V_FALSE_ADJ     0x00000000
#define NV_056_SET_POLY_OFFSET_LINE_ENABLE_V_TRUE_ADJ      0x00000001
#define NV_056_SET_POLY_OFFSET_LINE_ENABLE_MSK             0xFFFFFFFF 
#define NV_056_SET_POLY_OFFSET_FILL_ENABLE_V_MSK           0xFFFFFFFF /* 31:0 */ 
#define NV_056_SET_POLY_OFFSET_FILL_ENABLE_V_RMSK          0xFFFFFFFF /* 31:0 */ 
#define NV_056_SET_POLY_OFFSET_FILL_ENABLE_V_WORD          0
#define NV_056_SET_POLY_OFFSET_FILL_ENABLE_V_HIGH_FIELD    0x0000001F /* =31 */
#define NV_056_SET_POLY_OFFSET_FILL_ENABLE_V_LOW_FIELD     0x00000000 /* =0 */
#define NV_056_SET_POLY_OFFSET_FILL_ENABLE_V_FALSE_ADJ     0x00000000
#define NV_056_SET_POLY_OFFSET_FILL_ENABLE_V_TRUE_ADJ      0x00000001
#define NV_056_SET_POLY_OFFSET_FILL_ENABLE_MSK             0xFFFFFFFF 
#define NV_056_SET_ALPHA_FUNC_V_MSK                        0xFFFFFFFF /* 31:0 */ 
#define NV_056_SET_ALPHA_FUNC_V_RMSK                       0xFFFFFFFF /* 31:0 */ 
#define NV_056_SET_ALPHA_FUNC_V_WORD                       0
#define NV_056_SET_ALPHA_FUNC_V_HIGH_FIELD                 0x0000001F /* =31 */
#define NV_056_SET_ALPHA_FUNC_V_LOW_FIELD                  0x00000000 /* =0 */
#define NV_056_SET_ALPHA_FUNC_V_NEVER_ADJ                  0x00000200
#define NV_056_SET_ALPHA_FUNC_V_LESS_ADJ                   0x00000201
#define NV_056_SET_ALPHA_FUNC_V_EQUAL_ADJ                  0x00000202
#define NV_056_SET_ALPHA_FUNC_V_LEQUAL_ADJ                 0x00000203
#define NV_056_SET_ALPHA_FUNC_V_GREATER_ADJ                0x00000204
#define NV_056_SET_ALPHA_FUNC_V_NOTEQUAL_ADJ               0x00000205
#define NV_056_SET_ALPHA_FUNC_V_GEQUAL_ADJ                 0x00000206
#define NV_056_SET_ALPHA_FUNC_V_ALWAYS_ADJ                 0x00000207
#define NV_056_SET_ALPHA_FUNC_MSK                          0xFFFFFFFF 
#define NV_056_SET_ALPHA_REF_V_MSK                         0xFFFFFFFF /* 31:0 */ 
#define NV_056_SET_ALPHA_REF_V_RMSK                        0xFFFFFFFF /* 31:0 */ 
#define NV_056_SET_ALPHA_REF_V_WORD                        0
#define NV_056_SET_ALPHA_REF_V_HIGH_FIELD                  0x0000001F /* =31 */
#define NV_056_SET_ALPHA_REF_V_LOW_FIELD                   0x00000000 /* =0 */
#define NV_056_SET_ALPHA_REF_MSK                           0xFFFFFFFF 
#define NV_056_SET_BLEND_FUNC_SFACTOR_V_MSK                0xFFFFFFFF /* 31:0 */ 
#define NV_056_SET_BLEND_FUNC_SFACTOR_V_RMSK               0xFFFFFFFF /* 31:0 */ 
#define NV_056_SET_BLEND_FUNC_SFACTOR_V_WORD               0
#define NV_056_SET_BLEND_FUNC_SFACTOR_V_HIGH_FIELD         0x0000001F /* =31 */
#define NV_056_SET_BLEND_FUNC_SFACTOR_V_LOW_FIELD          0x00000000 /* =0 */
#define NV_056_SET_BLEND_FUNC_SFACTOR_V_ZERO_ADJ           0x00000000
#define NV_056_SET_BLEND_FUNC_SFACTOR_V_ONE_ADJ            0x00000001
#define NV_056_SET_BLEND_FUNC_SFACTOR_V_SRC_COLOR_ADJ      0x00000300
#define NV_056_SET_BLEND_FUNC_SFACTOR_V_ONE_MINUS_SRC_COLOR_ADJ 0x00000301
#define NV_056_SET_BLEND_FUNC_SFACTOR_V_SRC_ALPHA_ADJ      0x00000302
#define NV_056_SET_BLEND_FUNC_SFACTOR_V_ONE_MINUS_SRC_ALPHA_ADJ 0x00000303
#define NV_056_SET_BLEND_FUNC_SFACTOR_V_DST_ALPHA_ADJ      0x00000304
#define NV_056_SET_BLEND_FUNC_SFACTOR_V_ONE_MINUS_DST_ALPHA_ADJ 0x00000305
#define NV_056_SET_BLEND_FUNC_SFACTOR_V_DST_COLOR_ADJ      0x00000306
#define NV_056_SET_BLEND_FUNC_SFACTOR_V_ONE_MINUS_DST_COLOR_ADJ 0x00000307
#define NV_056_SET_BLEND_FUNC_SFACTOR_V_SRC_ALPHA_SATURATE_ADJ 0x00000308
#define NV_056_SET_BLEND_FUNC_SFACTOR_V_CONSTANT_COLOR_ADJ 0x00008001
#define NV_056_SET_BLEND_FUNC_SFACTOR_V_ONE_MINUS_CONSTANT_COLOR_ADJ 0x00008002
#define NV_056_SET_BLEND_FUNC_SFACTOR_V_CONSTANT_ALPHA_ADJ 0x00008003
#define NV_056_SET_BLEND_FUNC_SFACTOR_V_ONE_MINUS_CONSTANT_ALPHA_ADJ 0x00008004
#define NV_056_SET_BLEND_FUNC_SFACTOR_MSK                  0xFFFFFFFF 
#define NV_056_SET_BLEND_FUNC_DFACTOR_V_MSK                0xFFFFFFFF /* 31:0 */ 
#define NV_056_SET_BLEND_FUNC_DFACTOR_V_RMSK               0xFFFFFFFF /* 31:0 */ 
#define NV_056_SET_BLEND_FUNC_DFACTOR_V_WORD               0
#define NV_056_SET_BLEND_FUNC_DFACTOR_V_HIGH_FIELD         0x0000001F /* =31 */
#define NV_056_SET_BLEND_FUNC_DFACTOR_V_LOW_FIELD          0x00000000 /* =0 */
#define NV_056_SET_BLEND_FUNC_DFACTOR_V_ZERO_ADJ           0x00000000
#define NV_056_SET_BLEND_FUNC_DFACTOR_V_ONE_ADJ            0x00000001
#define NV_056_SET_BLEND_FUNC_DFACTOR_V_SRC_COLOR_ADJ      0x00000300
#define NV_056_SET_BLEND_FUNC_DFACTOR_V_ONE_MINUS_SRC_COLOR_ADJ 0x00000301
#define NV_056_SET_BLEND_FUNC_DFACTOR_V_SRC_ALPHA_ADJ      0x00000302
#define NV_056_SET_BLEND_FUNC_DFACTOR_V_ONE_MINUS_SRC_ALPHA_ADJ 0x00000303
#define NV_056_SET_BLEND_FUNC_DFACTOR_V_DST_ALPHA_ADJ      0x00000304
#define NV_056_SET_BLEND_FUNC_DFACTOR_V_ONE_MINUS_DST_ALPHA_ADJ 0x00000305
#define NV_056_SET_BLEND_FUNC_DFACTOR_V_DST_COLOR_ADJ      0x00000306
#define NV_056_SET_BLEND_FUNC_DFACTOR_V_ONE_MINUS_DST_COLOR_ADJ 0x00000307
#define NV_056_SET_BLEND_FUNC_DFACTOR_V_CONSTANT_COLOR_ADJ 0x00008001
#define NV_056_SET_BLEND_FUNC_DFACTOR_V_ONE_MINUS_CONSTANT_COLOR_ADJ 0x00008002
#define NV_056_SET_BLEND_FUNC_DFACTOR_V_CONSTANT_ALPHA_ADJ 0x00008003
#define NV_056_SET_BLEND_FUNC_DFACTOR_V_ONE_MINUS_CONSTANT_ALPHA_ADJ 0x00008004
#define NV_056_SET_BLEND_FUNC_DFACTOR_MSK                  0xFFFFFFFF 
#define NV_056_SET_BLEND_COLOR_V_MSK                       0xFFFFFFFF /* 31:0 */ 
#define NV_056_SET_BLEND_COLOR_V_RMSK                      0xFFFFFFFF /* 31:0 */ 
#define NV_056_SET_BLEND_COLOR_V_WORD                      0
#define NV_056_SET_BLEND_COLOR_V_HIGH_FIELD                0x0000001F /* =31 */
#define NV_056_SET_BLEND_COLOR_V_LOW_FIELD                 0x00000000 /* =0 */
#define NV_056_SET_BLEND_COLOR_MSK                         0xFFFFFFFF 
#define NV_056_SET_BLEND_EQUATION_V_MSK                    0xFFFFFFFF /* 31:0 */ 
#define NV_056_SET_BLEND_EQUATION_V_RMSK                   0xFFFFFFFF /* 31:0 */ 
#define NV_056_SET_BLEND_EQUATION_V_WORD                   0
#define NV_056_SET_BLEND_EQUATION_V_HIGH_FIELD             0x0000001F /* =31 */
#define NV_056_SET_BLEND_EQUATION_V_LOW_FIELD              0x00000000 /* =0 */
#define NV_056_SET_BLEND_EQUATION_V_FUNC_SUBTRACT_ADJ      0x0000800A
#define NV_056_SET_BLEND_EQUATION_V_FUNC_REVERSE_SUBTRACT_ADJ 0x0000800B
#define NV_056_SET_BLEND_EQUATION_V_FUNC_ADD_ADJ           0x00008006
#define NV_056_SET_BLEND_EQUATION_V_MIN_ADJ                0x00008007
#define NV_056_SET_BLEND_EQUATION_V_MAX_ADJ                0x00008008
#define NV_056_SET_BLEND_EQUATION_MSK                      0xFFFFFFFF 
#define NV_056_SET_DEPTH_FUNC_V_MSK                        0xFFFFFFFF /* 31:0 */ 
#define NV_056_SET_DEPTH_FUNC_V_RMSK                       0xFFFFFFFF /* 31:0 */ 
#define NV_056_SET_DEPTH_FUNC_V_WORD                       0
#define NV_056_SET_DEPTH_FUNC_V_HIGH_FIELD                 0x0000001F /* =31 */
#define NV_056_SET_DEPTH_FUNC_V_LOW_FIELD                  0x00000000 /* =0 */
#define NV_056_SET_DEPTH_FUNC_V_NEVER_ADJ                  0x00000200
#define NV_056_SET_DEPTH_FUNC_V_LESS_ADJ                   0x00000201
#define NV_056_SET_DEPTH_FUNC_V_EQUAL_ADJ                  0x00000202
#define NV_056_SET_DEPTH_FUNC_V_LEQUAL_ADJ                 0x00000203
#define NV_056_SET_DEPTH_FUNC_V_GREATER_ADJ                0x00000204
#define NV_056_SET_DEPTH_FUNC_V_NOTEQUAL_ADJ               0x00000205
#define NV_056_SET_DEPTH_FUNC_V_GEQUAL_ADJ                 0x00000206
#define NV_056_SET_DEPTH_FUNC_V_ALWAYS_ADJ                 0x00000207
#define NV_056_SET_DEPTH_FUNC_MSK                          0xFFFFFFFF 
#define NV_056_SET_COLOR_MASK_ALPHA_WRITE_ENABLE_MSK       0xFF000000 /* 31:24 */ 
#define NV_056_SET_COLOR_MASK_ALPHA_WRITE_ENABLE_RMSK      0x000000FF /* 31:24 */ 
#define NV_056_SET_COLOR_MASK_ALPHA_WRITE_ENABLE_WORD      0
#define NV_056_SET_COLOR_MASK_ALPHA_WRITE_ENABLE_HIGH_FIELD 0x0000001F /* =31 */
#define NV_056_SET_COLOR_MASK_ALPHA_WRITE_ENABLE_LOW_FIELD 0x00000018 /* =24 */
#define NV_056_SET_COLOR_MASK_ALPHA_WRITE_ENABLE_FALSE_ADJ 0x00000000
#define NV_056_SET_COLOR_MASK_ALPHA_WRITE_ENABLE_TRUE_ADJ  0x01000000
#define NV_056_SET_COLOR_MASK_RED_WRITE_ENABLE_MSK         0x00FF0000 /* 23:16 */ 
#define NV_056_SET_COLOR_MASK_RED_WRITE_ENABLE_RMSK        0x000000FF /* 23:16 */ 
#define NV_056_SET_COLOR_MASK_RED_WRITE_ENABLE_WORD        0
#define NV_056_SET_COLOR_MASK_RED_WRITE_ENABLE_HIGH_FIELD  0x00000017 /* =23 */
#define NV_056_SET_COLOR_MASK_RED_WRITE_ENABLE_LOW_FIELD   0x00000010 /* =16 */
#define NV_056_SET_COLOR_MASK_RED_WRITE_ENABLE_FALSE_ADJ   0x00000000
#define NV_056_SET_COLOR_MASK_RED_WRITE_ENABLE_TRUE_ADJ    0x00010000
#define NV_056_SET_COLOR_MASK_GREEN_WRITE_ENABLE_MSK       0x0000FF00 /* 15:8 */ 
#define NV_056_SET_COLOR_MASK_GREEN_WRITE_ENABLE_RMSK      0x000000FF /* 15:8 */ 
#define NV_056_SET_COLOR_MASK_GREEN_WRITE_ENABLE_WORD      0
#define NV_056_SET_COLOR_MASK_GREEN_WRITE_ENABLE_HIGH_FIELD 0x0000000F /* =15 */
#define NV_056_SET_COLOR_MASK_GREEN_WRITE_ENABLE_LOW_FIELD 0x00000008 /* =8 */
#define NV_056_SET_COLOR_MASK_GREEN_WRITE_ENABLE_FALSE_ADJ 0x00000000
#define NV_056_SET_COLOR_MASK_GREEN_WRITE_ENABLE_TRUE_ADJ  0x00000100
#define NV_056_SET_COLOR_MASK_BLUE_WRITE_ENABLE_MSK        0x000000FF /* 7:0 */ 
#define NV_056_SET_COLOR_MASK_BLUE_WRITE_ENABLE_RMSK       0x000000FF /* 7:0 */ 
#define NV_056_SET_COLOR_MASK_BLUE_WRITE_ENABLE_WORD       0
#define NV_056_SET_COLOR_MASK_BLUE_WRITE_ENABLE_HIGH_FIELD 0x00000007 /* =7 */
#define NV_056_SET_COLOR_MASK_BLUE_WRITE_ENABLE_LOW_FIELD  0x00000000 /* =0 */
#define NV_056_SET_COLOR_MASK_BLUE_WRITE_ENABLE_FALSE_ADJ  0x00000000
#define NV_056_SET_COLOR_MASK_BLUE_WRITE_ENABLE_TRUE_ADJ   0x00000001
#define NV_056_SET_COLOR_MASK_MSK                          0xFFFFFFFF 
#define NV_056_SET_DEPTH_MASK_V_MSK                        0xFFFFFFFF /* 31:0 */ 
#define NV_056_SET_DEPTH_MASK_V_RMSK                       0xFFFFFFFF /* 31:0 */ 
#define NV_056_SET_DEPTH_MASK_V_WORD                       0
#define NV_056_SET_DEPTH_MASK_V_HIGH_FIELD                 0x0000001F /* =31 */
#define NV_056_SET_DEPTH_MASK_V_LOW_FIELD                  0x00000000 /* =0 */
#define NV_056_SET_DEPTH_MASK_V_FALSE_ADJ                  0x00000000
#define NV_056_SET_DEPTH_MASK_V_TRUE_ADJ                   0x00000001
#define NV_056_SET_DEPTH_MASK_MSK                          0xFFFFFFFF 
#define NV_056_SET_STENCIL_MASK_V_MSK                      0xFFFFFFFF /* 31:0 */ 
#define NV_056_SET_STENCIL_MASK_V_RMSK                     0xFFFFFFFF /* 31:0 */ 
#define NV_056_SET_STENCIL_MASK_V_WORD                     0
#define NV_056_SET_STENCIL_MASK_V_HIGH_FIELD               0x0000001F /* =31 */
#define NV_056_SET_STENCIL_MASK_V_LOW_FIELD                0x00000000 /* =0 */
#define NV_056_SET_STENCIL_MASK_MSK                        0xFFFFFFFF 
#define NV_056_SET_STENCIL_FUNC_V_MSK                      0xFFFFFFFF /* 31:0 */ 
#define NV_056_SET_STENCIL_FUNC_V_RMSK                     0xFFFFFFFF /* 31:0 */ 
#define NV_056_SET_STENCIL_FUNC_V_WORD                     0
#define NV_056_SET_STENCIL_FUNC_V_HIGH_FIELD               0x0000001F /* =31 */
#define NV_056_SET_STENCIL_FUNC_V_LOW_FIELD                0x00000000 /* =0 */
#define NV_056_SET_STENCIL_FUNC_V_NEVER_ADJ                0x00000200
#define NV_056_SET_STENCIL_FUNC_V_LESS_ADJ                 0x00000201
#define NV_056_SET_STENCIL_FUNC_V_EQUAL_ADJ                0x00000202
#define NV_056_SET_STENCIL_FUNC_V_LEQUAL_ADJ               0x00000203
#define NV_056_SET_STENCIL_FUNC_V_GREATER_ADJ              0x00000204
#define NV_056_SET_STENCIL_FUNC_V_NOTEQUAL_ADJ             0x00000205
#define NV_056_SET_STENCIL_FUNC_V_GEQUAL_ADJ               0x00000206
#define NV_056_SET_STENCIL_FUNC_V_ALWAYS_ADJ               0x00000207
#define NV_056_SET_STENCIL_FUNC_MSK                        0xFFFFFFFF 
#define NV_056_SET_STENCIL_FUNC_REF_V_MSK                  0xFFFFFFFF /* 31:0 */ 
#define NV_056_SET_STENCIL_FUNC_REF_V_RMSK                 0xFFFFFFFF /* 31:0 */ 
#define NV_056_SET_STENCIL_FUNC_REF_V_WORD                 0
#define NV_056_SET_STENCIL_FUNC_REF_V_HIGH_FIELD           0x0000001F /* =31 */
#define NV_056_SET_STENCIL_FUNC_REF_V_LOW_FIELD            0x00000000 /* =0 */
#define NV_056_SET_STENCIL_FUNC_REF_MSK                    0xFFFFFFFF 
#define NV_056_SET_STENCIL_FUNC_MASK_V_MSK                 0xFFFFFFFF /* 31:0 */ 
#define NV_056_SET_STENCIL_FUNC_MASK_V_RMSK                0xFFFFFFFF /* 31:0 */ 
#define NV_056_SET_STENCIL_FUNC_MASK_V_WORD                0
#define NV_056_SET_STENCIL_FUNC_MASK_V_HIGH_FIELD          0x0000001F /* =31 */
#define NV_056_SET_STENCIL_FUNC_MASK_V_LOW_FIELD           0x00000000 /* =0 */
#define NV_056_SET_STENCIL_FUNC_MASK_MSK                   0xFFFFFFFF 
#define NV_056_SET_STENCIL_OP_FAIL_V_MSK                   0xFFFFFFFF /* 31:0 */ 
#define NV_056_SET_STENCIL_OP_FAIL_V_RMSK                  0xFFFFFFFF /* 31:0 */ 
#define NV_056_SET_STENCIL_OP_FAIL_V_WORD                  0
#define NV_056_SET_STENCIL_OP_FAIL_V_HIGH_FIELD            0x0000001F /* =31 */
#define NV_056_SET_STENCIL_OP_FAIL_V_LOW_FIELD             0x00000000 /* =0 */
#define NV_056_SET_STENCIL_OP_FAIL_V_KEEP_ADJ              0x00001E00
#define NV_056_SET_STENCIL_OP_FAIL_V_ZERO_ADJ              0x00000000
#define NV_056_SET_STENCIL_OP_FAIL_V_REPLACE_ADJ           0x00001E01
#define NV_056_SET_STENCIL_OP_FAIL_V_INCRSAT_ADJ           0x00001E02
#define NV_056_SET_STENCIL_OP_FAIL_V_DECRSAT_ADJ           0x00001E03
#define NV_056_SET_STENCIL_OP_FAIL_V_INVERT_ADJ            0x0000150A
#define NV_056_SET_STENCIL_OP_FAIL_V_INCR_ADJ              0x00008507
#define NV_056_SET_STENCIL_OP_FAIL_V_DECR_ADJ              0x00008508
#define NV_056_SET_STENCIL_OP_FAIL_MSK                     0xFFFFFFFF 
#define NV_056_SET_STENCIL_OP_ZFAIL_V_MSK                  0xFFFFFFFF /* 31:0 */ 
#define NV_056_SET_STENCIL_OP_ZFAIL_V_RMSK                 0xFFFFFFFF /* 31:0 */ 
#define NV_056_SET_STENCIL_OP_ZFAIL_V_WORD                 0
#define NV_056_SET_STENCIL_OP_ZFAIL_V_HIGH_FIELD           0x0000001F /* =31 */
#define NV_056_SET_STENCIL_OP_ZFAIL_V_LOW_FIELD            0x00000000 /* =0 */
#define NV_056_SET_STENCIL_OP_ZFAIL_V_KEEP_ADJ             0x00001E00
#define NV_056_SET_STENCIL_OP_ZFAIL_V_ZERO_ADJ             0x00000000
#define NV_056_SET_STENCIL_OP_ZFAIL_V_REPLACE_ADJ          0x00001E01
#define NV_056_SET_STENCIL_OP_ZFAIL_V_INCRSAT_ADJ          0x00001E02
#define NV_056_SET_STENCIL_OP_ZFAIL_V_DECRSAT_ADJ          0x00001E03
#define NV_056_SET_STENCIL_OP_ZFAIL_V_INVERT_ADJ           0x0000150A
#define NV_056_SET_STENCIL_OP_ZFAIL_V_INCR_ADJ             0x00008507
#define NV_056_SET_STENCIL_OP_ZFAIL_V_DECR_ADJ             0x00008508
#define NV_056_SET_STENCIL_OP_ZFAIL_MSK                    0xFFFFFFFF 
#define NV_056_SET_STENCIL_OP_ZPASS_V_MSK                  0xFFFFFFFF /* 31:0 */ 
#define NV_056_SET_STENCIL_OP_ZPASS_V_RMSK                 0xFFFFFFFF /* 31:0 */ 
#define NV_056_SET_STENCIL_OP_ZPASS_V_WORD                 0
#define NV_056_SET_STENCIL_OP_ZPASS_V_HIGH_FIELD           0x0000001F /* =31 */
#define NV_056_SET_STENCIL_OP_ZPASS_V_LOW_FIELD            0x00000000 /* =0 */
#define NV_056_SET_STENCIL_OP_ZPASS_V_KEEP_ADJ             0x00001E00
#define NV_056_SET_STENCIL_OP_ZPASS_V_ZERO_ADJ             0x00000000
#define NV_056_SET_STENCIL_OP_ZPASS_V_REPLACE_ADJ          0x00001E01
#define NV_056_SET_STENCIL_OP_ZPASS_V_INCRSAT_ADJ          0x00001E02
#define NV_056_SET_STENCIL_OP_ZPASS_V_DECRSAT_ADJ          0x00001E03
#define NV_056_SET_STENCIL_OP_ZPASS_V_INVERT_ADJ           0x0000150A
#define NV_056_SET_STENCIL_OP_ZPASS_V_INCR_ADJ             0x00008507
#define NV_056_SET_STENCIL_OP_ZPASS_V_DECR_ADJ             0x00008508
#define NV_056_SET_STENCIL_OP_ZPASS_MSK                    0xFFFFFFFF 
#define NV_056_SET_SHADE_MODE_V_MSK                        0xFFFFFFFF /* 31:0 */ 
#define NV_056_SET_SHADE_MODE_V_RMSK                       0xFFFFFFFF /* 31:0 */ 
#define NV_056_SET_SHADE_MODE_V_WORD                       0
#define NV_056_SET_SHADE_MODE_V_HIGH_FIELD                 0x0000001F /* =31 */
#define NV_056_SET_SHADE_MODE_V_LOW_FIELD                  0x00000000 /* =0 */
#define NV_056_SET_SHADE_MODE_V_FLAT_ADJ                   0x00001D00
#define NV_056_SET_SHADE_MODE_V_SMOOTH_ADJ                 0x00001D01
#define NV_056_SET_SHADE_MODE_MSK                          0xFFFFFFFF 
#define NV_056_SET_LINE_WIDTH_V_MSK                        0xFFFFFFFF /* 31:0 */ 
#define NV_056_SET_LINE_WIDTH_V_RMSK                       0xFFFFFFFF /* 31:0 */ 
#define NV_056_SET_LINE_WIDTH_V_WORD                       0
#define NV_056_SET_LINE_WIDTH_V_HIGH_FIELD                 0x0000001F /* =31 */
#define NV_056_SET_LINE_WIDTH_V_LOW_FIELD                  0x00000000 /* =0 */
#define NV_056_SET_LINE_WIDTH_MSK                          0xFFFFFFFF 
#define NV_056_SET_POLYGON_OFFSET_SCALE_FACTOR_V_MSK       0xFFFFFFFF /* 31:0 */ 
#define NV_056_SET_POLYGON_OFFSET_SCALE_FACTOR_V_RMSK      0xFFFFFFFF /* 31:0 */ 
#define NV_056_SET_POLYGON_OFFSET_SCALE_FACTOR_V_WORD      0
#define NV_056_SET_POLYGON_OFFSET_SCALE_FACTOR_V_HIGH_FIELD 0x0000001F /* =31 */
#define NV_056_SET_POLYGON_OFFSET_SCALE_FACTOR_V_LOW_FIELD 0x00000000 /* =0 */
#define NV_056_SET_POLYGON_OFFSET_SCALE_FACTOR_MSK         0xFFFFFFFF 
#define NV_056_SET_POLYGON_OFFSET_BIAS_V_MSK               0xFFFFFFFF /* 31:0 */ 
#define NV_056_SET_POLYGON_OFFSET_BIAS_V_RMSK              0xFFFFFFFF /* 31:0 */ 
#define NV_056_SET_POLYGON_OFFSET_BIAS_V_WORD              0
#define NV_056_SET_POLYGON_OFFSET_BIAS_V_HIGH_FIELD        0x0000001F /* =31 */
#define NV_056_SET_POLYGON_OFFSET_BIAS_V_LOW_FIELD         0x00000000 /* =0 */
#define NV_056_SET_POLYGON_OFFSET_BIAS_MSK                 0xFFFFFFFF 
#define NV_056_SET_FRONT_POLYGON_MODE_V_MSK                0xFFFFFFFF /* 31:0 */ 
#define NV_056_SET_FRONT_POLYGON_MODE_V_RMSK               0xFFFFFFFF /* 31:0 */ 
#define NV_056_SET_FRONT_POLYGON_MODE_V_WORD               0
#define NV_056_SET_FRONT_POLYGON_MODE_V_HIGH_FIELD         0x0000001F /* =31 */
#define NV_056_SET_FRONT_POLYGON_MODE_V_LOW_FIELD          0x00000000 /* =0 */
#define NV_056_SET_FRONT_POLYGON_MODE_V_POINT_ADJ          0x00001B00
#define NV_056_SET_FRONT_POLYGON_MODE_V_LINE_ADJ           0x00001B01
#define NV_056_SET_FRONT_POLYGON_MODE_V_FILL_ADJ           0x00001B02
#define NV_056_SET_FRONT_POLYGON_MODE_MSK                  0xFFFFFFFF 
#define NV_056_SET_BACK_POLYGON_MODE_V_MSK                 0xFFFFFFFF /* 31:0 */ 
#define NV_056_SET_BACK_POLYGON_MODE_V_RMSK                0xFFFFFFFF /* 31:0 */ 
#define NV_056_SET_BACK_POLYGON_MODE_V_WORD                0
#define NV_056_SET_BACK_POLYGON_MODE_V_HIGH_FIELD          0x0000001F /* =31 */
#define NV_056_SET_BACK_POLYGON_MODE_V_LOW_FIELD           0x00000000 /* =0 */
#define NV_056_SET_BACK_POLYGON_MODE_V_POINT_ADJ           0x00001B00
#define NV_056_SET_BACK_POLYGON_MODE_V_LINE_ADJ            0x00001B01
#define NV_056_SET_BACK_POLYGON_MODE_V_FILL_ADJ            0x00001B02
#define NV_056_SET_BACK_POLYGON_MODE_MSK                   0xFFFFFFFF 
#define NV_056_SET_CLIP_MIN_V_MSK                          0xFFFFFFFF /* 31:0 */ 
#define NV_056_SET_CLIP_MIN_V_RMSK                         0xFFFFFFFF /* 31:0 */ 
#define NV_056_SET_CLIP_MIN_V_WORD                         0
#define NV_056_SET_CLIP_MIN_V_HIGH_FIELD                   0x0000001F /* =31 */
#define NV_056_SET_CLIP_MIN_V_LOW_FIELD                    0x00000000 /* =0 */
#define NV_056_SET_CLIP_MIN_MSK                            0xFFFFFFFF 
#define NV_056_SET_CLIP_MAX_V_MSK                          0xFFFFFFFF /* 31:0 */ 
#define NV_056_SET_CLIP_MAX_V_RMSK                         0xFFFFFFFF /* 31:0 */ 
#define NV_056_SET_CLIP_MAX_V_WORD                         0
#define NV_056_SET_CLIP_MAX_V_HIGH_FIELD                   0x0000001F /* =31 */
#define NV_056_SET_CLIP_MAX_V_LOW_FIELD                    0x00000000 /* =0 */
#define NV_056_SET_CLIP_MAX_MSK                            0xFFFFFFFF 
#define NV_056_SET_CULL_FACE_V_MSK                         0xFFFFFFFF /* 31:0 */ 
#define NV_056_SET_CULL_FACE_V_RMSK                        0xFFFFFFFF /* 31:0 */ 
#define NV_056_SET_CULL_FACE_V_WORD                        0
#define NV_056_SET_CULL_FACE_V_HIGH_FIELD                  0x0000001F /* =31 */
#define NV_056_SET_CULL_FACE_V_LOW_FIELD                   0x00000000 /* =0 */
#define NV_056_SET_CULL_FACE_V_FRONT_ADJ                   0x00000404
#define NV_056_SET_CULL_FACE_V_BACK_ADJ                    0x00000405
#define NV_056_SET_CULL_FACE_V_FRONT_AND_BACK_ADJ          0x00000408
#define NV_056_SET_CULL_FACE_MSK                           0xFFFFFFFF 
#define NV_056_SET_FRONT_FACE_V_MSK                        0xFFFFFFFF /* 31:0 */ 
#define NV_056_SET_FRONT_FACE_V_RMSK                       0xFFFFFFFF /* 31:0 */ 
#define NV_056_SET_FRONT_FACE_V_WORD                       0
#define NV_056_SET_FRONT_FACE_V_HIGH_FIELD                 0x0000001F /* =31 */
#define NV_056_SET_FRONT_FACE_V_LOW_FIELD                  0x00000000 /* =0 */
#define NV_056_SET_FRONT_FACE_V_CW_ADJ                     0x00000900
#define NV_056_SET_FRONT_FACE_V_CCW_ADJ                    0x00000901
#define NV_056_SET_FRONT_FACE_MSK                          0xFFFFFFFF 
#define NV_056_SET_NORMALIZATION_ENABLE_V_MSK              0xFFFFFFFF /* 31:0 */ 
#define NV_056_SET_NORMALIZATION_ENABLE_V_RMSK             0xFFFFFFFF /* 31:0 */ 
#define NV_056_SET_NORMALIZATION_ENABLE_V_WORD             0
#define NV_056_SET_NORMALIZATION_ENABLE_V_HIGH_FIELD       0x0000001F /* =31 */
#define NV_056_SET_NORMALIZATION_ENABLE_V_LOW_FIELD        0x00000000 /* =0 */
#define NV_056_SET_NORMALIZATION_ENABLE_V_FALSE_ADJ        0x00000000
#define NV_056_SET_NORMALIZATION_ENABLE_V_TRUE_ADJ         0x00000001
#define NV_056_SET_NORMALIZATION_ENABLE_MSK                0xFFFFFFFF 
#define NV_056_SET_MATERIAL_EMISSION_MSK                   0x00000000 
#define NV_056_SET_MATERIAL_ALPHA_MSK                      0x00000000 
#define NV_056_SET_SPECULAR_ENABLE_V_MSK                   0xFFFFFFFF /* 31:0 */ 
#define NV_056_SET_SPECULAR_ENABLE_V_RMSK                  0xFFFFFFFF /* 31:0 */ 
#define NV_056_SET_SPECULAR_ENABLE_V_WORD                  0
#define NV_056_SET_SPECULAR_ENABLE_V_HIGH_FIELD            0x0000001F /* =31 */
#define NV_056_SET_SPECULAR_ENABLE_V_LOW_FIELD             0x00000000 /* =0 */
#define NV_056_SET_SPECULAR_ENABLE_V_FALSE_ADJ             0x00000000
#define NV_056_SET_SPECULAR_ENABLE_V_TRUE_ADJ              0x00000001
#define NV_056_SET_SPECULAR_ENABLE_MSK                     0xFFFFFFFF 
#define NV_056_SET_LIGHT_ENABLE_MASK_LIGHT0_MSK            0x00000003 /* 1:0 */ 
#define NV_056_SET_LIGHT_ENABLE_MASK_LIGHT0_RMSK           0x00000003 /* 1:0 */ 
#define NV_056_SET_LIGHT_ENABLE_MASK_LIGHT0_WORD           0
#define NV_056_SET_LIGHT_ENABLE_MASK_LIGHT0_HIGH_FIELD     0x00000001 /* =1 */
#define NV_056_SET_LIGHT_ENABLE_MASK_LIGHT0_LOW_FIELD      0x00000000 /* =0 */
#define NV_056_SET_LIGHT_ENABLE_MASK_LIGHT0_OFF_ADJ        0x00000000
#define NV_056_SET_LIGHT_ENABLE_MASK_LIGHT0_INFINITE_ADJ   0x00000001
#define NV_056_SET_LIGHT_ENABLE_MASK_LIGHT0_LOCAL_ADJ      0x00000002
#define NV_056_SET_LIGHT_ENABLE_MASK_LIGHT0_SPOT_ADJ       0x00000003
#define NV_056_SET_LIGHT_ENABLE_MASK_LIGHT1_MSK            0x0000000C /* 3:2 */ 
#define NV_056_SET_LIGHT_ENABLE_MASK_LIGHT1_RMSK           0x00000003 /* 3:2 */ 
#define NV_056_SET_LIGHT_ENABLE_MASK_LIGHT1_WORD           0
#define NV_056_SET_LIGHT_ENABLE_MASK_LIGHT1_HIGH_FIELD     0x00000003 /* =3 */
#define NV_056_SET_LIGHT_ENABLE_MASK_LIGHT1_LOW_FIELD      0x00000002 /* =2 */
#define NV_056_SET_LIGHT_ENABLE_MASK_LIGHT1_OFF_ADJ        0x00000000
#define NV_056_SET_LIGHT_ENABLE_MASK_LIGHT1_INFINITE_ADJ   0x00000004
#define NV_056_SET_LIGHT_ENABLE_MASK_LIGHT1_LOCAL_ADJ      0x00000008
#define NV_056_SET_LIGHT_ENABLE_MASK_LIGHT1_SPOT_ADJ       0x0000000C
#define NV_056_SET_LIGHT_ENABLE_MASK_LIGHT2_MSK            0x00000030 /* 5:4 */ 
#define NV_056_SET_LIGHT_ENABLE_MASK_LIGHT2_RMSK           0x00000003 /* 5:4 */ 
#define NV_056_SET_LIGHT_ENABLE_MASK_LIGHT2_WORD           0
#define NV_056_SET_LIGHT_ENABLE_MASK_LIGHT2_HIGH_FIELD     0x00000005 /* =5 */
#define NV_056_SET_LIGHT_ENABLE_MASK_LIGHT2_LOW_FIELD      0x00000004 /* =4 */
#define NV_056_SET_LIGHT_ENABLE_MASK_LIGHT2_OFF_ADJ        0x00000000
#define NV_056_SET_LIGHT_ENABLE_MASK_LIGHT2_INFINITE_ADJ   0x00000010
#define NV_056_SET_LIGHT_ENABLE_MASK_LIGHT2_LOCAL_ADJ      0x00000020
#define NV_056_SET_LIGHT_ENABLE_MASK_LIGHT2_SPOT_ADJ       0x00000030
#define NV_056_SET_LIGHT_ENABLE_MASK_LIGHT3_MSK            0x000000C0 /* 7:6 */ 
#define NV_056_SET_LIGHT_ENABLE_MASK_LIGHT3_RMSK           0x00000003 /* 7:6 */ 
#define NV_056_SET_LIGHT_ENABLE_MASK_LIGHT3_WORD           0
#define NV_056_SET_LIGHT_ENABLE_MASK_LIGHT3_HIGH_FIELD     0x00000007 /* =7 */
#define NV_056_SET_LIGHT_ENABLE_MASK_LIGHT3_LOW_FIELD      0x00000006 /* =6 */
#define NV_056_SET_LIGHT_ENABLE_MASK_LIGHT3_OFF_ADJ        0x00000000
#define NV_056_SET_LIGHT_ENABLE_MASK_LIGHT3_INFINITE_ADJ   0x00000040
#define NV_056_SET_LIGHT_ENABLE_MASK_LIGHT3_LOCAL_ADJ      0x00000080
#define NV_056_SET_LIGHT_ENABLE_MASK_LIGHT3_SPOT_ADJ       0x000000C0
#define NV_056_SET_LIGHT_ENABLE_MASK_LIGHT4_MSK            0x00000300 /* 9:8 */ 
#define NV_056_SET_LIGHT_ENABLE_MASK_LIGHT4_RMSK           0x00000003 /* 9:8 */ 
#define NV_056_SET_LIGHT_ENABLE_MASK_LIGHT4_WORD           0
#define NV_056_SET_LIGHT_ENABLE_MASK_LIGHT4_HIGH_FIELD     0x00000009 /* =9 */
#define NV_056_SET_LIGHT_ENABLE_MASK_LIGHT4_LOW_FIELD      0x00000008 /* =8 */
#define NV_056_SET_LIGHT_ENABLE_MASK_LIGHT4_OFF_ADJ        0x00000000
#define NV_056_SET_LIGHT_ENABLE_MASK_LIGHT4_INFINITE_ADJ   0x00000100
#define NV_056_SET_LIGHT_ENABLE_MASK_LIGHT4_LOCAL_ADJ      0x00000200
#define NV_056_SET_LIGHT_ENABLE_MASK_LIGHT4_SPOT_ADJ       0x00000300
#define NV_056_SET_LIGHT_ENABLE_MASK_LIGHT5_MSK            0x00000C00 /* 11:10 */ 
#define NV_056_SET_LIGHT_ENABLE_MASK_LIGHT5_RMSK           0x00000003 /* 11:10 */ 
#define NV_056_SET_LIGHT_ENABLE_MASK_LIGHT5_WORD           0
#define NV_056_SET_LIGHT_ENABLE_MASK_LIGHT5_HIGH_FIELD     0x0000000B /* =11 */
#define NV_056_SET_LIGHT_ENABLE_MASK_LIGHT5_LOW_FIELD      0x0000000A /* =10 */
#define NV_056_SET_LIGHT_ENABLE_MASK_LIGHT5_OFF_ADJ        0x00000000
#define NV_056_SET_LIGHT_ENABLE_MASK_LIGHT5_INFINITE_ADJ   0x00000400
#define NV_056_SET_LIGHT_ENABLE_MASK_LIGHT5_LOCAL_ADJ      0x00000800
#define NV_056_SET_LIGHT_ENABLE_MASK_LIGHT5_SPOT_ADJ       0x00000C00
#define NV_056_SET_LIGHT_ENABLE_MASK_LIGHT6_MSK            0x00003000 /* 13:12 */ 
#define NV_056_SET_LIGHT_ENABLE_MASK_LIGHT6_RMSK           0x00000003 /* 13:12 */ 
#define NV_056_SET_LIGHT_ENABLE_MASK_LIGHT6_WORD           0
#define NV_056_SET_LIGHT_ENABLE_MASK_LIGHT6_HIGH_FIELD     0x0000000D /* =13 */
#define NV_056_SET_LIGHT_ENABLE_MASK_LIGHT6_LOW_FIELD      0x0000000C /* =12 */
#define NV_056_SET_LIGHT_ENABLE_MASK_LIGHT6_OFF_ADJ        0x00000000
#define NV_056_SET_LIGHT_ENABLE_MASK_LIGHT6_INFINITE_ADJ   0x00001000
#define NV_056_SET_LIGHT_ENABLE_MASK_LIGHT6_LOCAL_ADJ      0x00002000
#define NV_056_SET_LIGHT_ENABLE_MASK_LIGHT6_SPOT_ADJ       0x00003000
#define NV_056_SET_LIGHT_ENABLE_MASK_LIGHT7_MSK            0x0000C000 /* 15:14 */ 
#define NV_056_SET_LIGHT_ENABLE_MASK_LIGHT7_RMSK           0x00000003 /* 15:14 */ 
#define NV_056_SET_LIGHT_ENABLE_MASK_LIGHT7_WORD           0
#define NV_056_SET_LIGHT_ENABLE_MASK_LIGHT7_HIGH_FIELD     0x0000000F /* =15 */
#define NV_056_SET_LIGHT_ENABLE_MASK_LIGHT7_LOW_FIELD      0x0000000E /* =14 */
#define NV_056_SET_LIGHT_ENABLE_MASK_LIGHT7_OFF_ADJ        0x00000000
#define NV_056_SET_LIGHT_ENABLE_MASK_LIGHT7_INFINITE_ADJ   0x00004000
#define NV_056_SET_LIGHT_ENABLE_MASK_LIGHT7_LOCAL_ADJ      0x00008000
#define NV_056_SET_LIGHT_ENABLE_MASK_LIGHT7_SPOT_ADJ       0x0000C000
#define NV_056_SET_LIGHT_ENABLE_MASK_MSK                   0x0000FFFF 
#define NV_056_SET_TEXGEN_S_V_MSK                          0xFFFFFFFF /* 31:0 */ 
#define NV_056_SET_TEXGEN_S_V_RMSK                         0xFFFFFFFF /* 31:0 */ 
#define NV_056_SET_TEXGEN_S_V_WORD                         0
#define NV_056_SET_TEXGEN_S_V_HIGH_FIELD                   0x0000001F /* =31 */
#define NV_056_SET_TEXGEN_S_V_LOW_FIELD                    0x00000000 /* =0 */
#define NV_056_SET_TEXGEN_S_V_DISABLE_ADJ                  0x00000000
#define NV_056_SET_TEXGEN_S_V_NORMAL_MAP_ADJ               0x00008511
#define NV_056_SET_TEXGEN_S_V_REFLECTION_MAP_ADJ           0x00008512
#define NV_056_SET_TEXGEN_S_V_EYE_LINEAR_ADJ               0x00002400
#define NV_056_SET_TEXGEN_S_V_OBJECT_LINEAR_ADJ            0x00002401
#define NV_056_SET_TEXGEN_S_V_SPHERE_MAP_ADJ               0x00002402
#define NV_056_SET_TEXGEN_S_V_EMBOSS_ADJ                   0x0000855F
#define NV_056_SET_TEXGEN_S_MSK                            0xFFFFFFFF 
#define NV_056_SET_TEXGEN_T_V_MSK                          0xFFFFFFFF /* 31:0 */ 
#define NV_056_SET_TEXGEN_T_V_RMSK                         0xFFFFFFFF /* 31:0 */ 
#define NV_056_SET_TEXGEN_T_V_WORD                         0
#define NV_056_SET_TEXGEN_T_V_HIGH_FIELD                   0x0000001F /* =31 */
#define NV_056_SET_TEXGEN_T_V_LOW_FIELD                    0x00000000 /* =0 */
#define NV_056_SET_TEXGEN_T_V_DISABLE_ADJ                  0x00000000
#define NV_056_SET_TEXGEN_T_V_NORMAL_MAP_ADJ               0x00008511
#define NV_056_SET_TEXGEN_T_V_REFLECTION_MAP_ADJ           0x00008512
#define NV_056_SET_TEXGEN_T_V_EYE_LINEAR_ADJ               0x00002400
#define NV_056_SET_TEXGEN_T_V_OBJECT_LINEAR_ADJ            0x00002401
#define NV_056_SET_TEXGEN_T_V_SPHERE_MAP_ADJ               0x00002402
#define NV_056_SET_TEXGEN_T_V_EMBOSS_ADJ                   0x0000855F
#define NV_056_SET_TEXGEN_T_MSK                            0xFFFFFFFF 
#define NV_056_SET_TEXGEN_R_V_MSK                          0xFFFFFFFF /* 31:0 */ 
#define NV_056_SET_TEXGEN_R_V_RMSK                         0xFFFFFFFF /* 31:0 */ 
#define NV_056_SET_TEXGEN_R_V_WORD                         0
#define NV_056_SET_TEXGEN_R_V_HIGH_FIELD                   0x0000001F /* =31 */
#define NV_056_SET_TEXGEN_R_V_LOW_FIELD                    0x00000000 /* =0 */
#define NV_056_SET_TEXGEN_R_V_DISABLE_ADJ                  0x00000000
#define NV_056_SET_TEXGEN_R_V_NORMAL_MAP_ADJ               0x00008511
#define NV_056_SET_TEXGEN_R_V_REFLECTION_MAP_ADJ           0x00008512
#define NV_056_SET_TEXGEN_R_V_EYE_LINEAR_ADJ               0x00002400
#define NV_056_SET_TEXGEN_R_V_OBJECT_LINEAR_ADJ            0x00002401
#define NV_056_SET_TEXGEN_R_V_EMBOSS_ADJ                   0x0000855F
#define NV_056_SET_TEXGEN_R_MSK                            0xFFFFFFFF 
#define NV_056_SET_TEXGEN_Q_V_MSK                          0xFFFFFFFF /* 31:0 */ 
#define NV_056_SET_TEXGEN_Q_V_RMSK                         0xFFFFFFFF /* 31:0 */ 
#define NV_056_SET_TEXGEN_Q_V_WORD                         0
#define NV_056_SET_TEXGEN_Q_V_HIGH_FIELD                   0x0000001F /* =31 */
#define NV_056_SET_TEXGEN_Q_V_LOW_FIELD                    0x00000000 /* =0 */
#define NV_056_SET_TEXGEN_Q_V_DISABLE_ADJ                  0x00000000
#define NV_056_SET_TEXGEN_Q_V_EYE_LINEAR_ADJ               0x00002400
#define NV_056_SET_TEXGEN_Q_V_OBJECT_LINEAR_ADJ            0x00002401
#define NV_056_SET_TEXGEN_Q_MSK                            0xFFFFFFFF 
#define NV_056_SET_TEXTURE_MATRIX0_ENABLE_V_MSK            0xFFFFFFFF /* 31:0 */ 
#define NV_056_SET_TEXTURE_MATRIX0_ENABLE_V_RMSK           0xFFFFFFFF /* 31:0 */ 
#define NV_056_SET_TEXTURE_MATRIX0_ENABLE_V_WORD           0
#define NV_056_SET_TEXTURE_MATRIX0_ENABLE_V_HIGH_FIELD     0x0000001F /* =31 */
#define NV_056_SET_TEXTURE_MATRIX0_ENABLE_V_LOW_FIELD      0x00000000 /* =0 */
#define NV_056_SET_TEXTURE_MATRIX0_ENABLE_V_FALSE_ADJ      0x00000000
#define NV_056_SET_TEXTURE_MATRIX0_ENABLE_V_TRUE_ADJ       0x00000001
#define NV_056_SET_TEXTURE_MATRIX0_ENABLE_MSK              0xFFFFFFFF 
#define NV_056_SET_TEXTURE_MATRIX1_ENABLE_V_MSK            0xFFFFFFFF /* 31:0 */ 
#define NV_056_SET_TEXTURE_MATRIX1_ENABLE_V_RMSK           0xFFFFFFFF /* 31:0 */ 
#define NV_056_SET_TEXTURE_MATRIX1_ENABLE_V_WORD           0
#define NV_056_SET_TEXTURE_MATRIX1_ENABLE_V_HIGH_FIELD     0x0000001F /* =31 */
#define NV_056_SET_TEXTURE_MATRIX1_ENABLE_V_LOW_FIELD      0x00000000 /* =0 */
#define NV_056_SET_TEXTURE_MATRIX1_ENABLE_V_FALSE_ADJ      0x00000000
#define NV_056_SET_TEXTURE_MATRIX1_ENABLE_V_TRUE_ADJ       0x00000001
#define NV_056_SET_TEXTURE_MATRIX1_ENABLE_MSK              0xFFFFFFFF 
#define NV_056_SET_TLMODE_PASSTHROUGH_MSK                  0x00000001 /* 0:0 */ 
#define NV_056_SET_TLMODE_PASSTHROUGH_RMSK                 0x00000001 /* 0:0 */ 
#define NV_056_SET_TLMODE_PASSTHROUGH_WORD                 0
#define NV_056_SET_TLMODE_PASSTHROUGH_HIGH_FIELD           0x00000000 /* =0 */
#define NV_056_SET_TLMODE_PASSTHROUGH_LOW_FIELD            0x00000000 /* =0 */
#define NV_056_SET_TLMODE_PASSTHROUGH_TRUE_ADJ             0x00000001
#define NV_056_SET_TLMODE_PASSTHROUGH_FALSE_ADJ            0x00000000
#define NV_056_SET_TLMODE_W_DIVIDE_0_MSK                   0x00000002 /* 1:1 */ 
#define NV_056_SET_TLMODE_W_DIVIDE_0_RMSK                  0x00000001 /* 1:1 */ 
#define NV_056_SET_TLMODE_W_DIVIDE_0_WORD                  0
#define NV_056_SET_TLMODE_W_DIVIDE_0_HIGH_FIELD            0x00000001 /* =1 */
#define NV_056_SET_TLMODE_W_DIVIDE_0_LOW_FIELD             0x00000001 /* =1 */
#define NV_056_SET_TLMODE_W_DIVIDE_0_DISABLE_ADJ           0x00000000
#define NV_056_SET_TLMODE_W_DIVIDE_0_ENABLE_ADJ            0x00000002
#define NV_056_SET_TLMODE_W_DIVIDE_1_MSK                   0x00000004 /* 2:2 */ 
#define NV_056_SET_TLMODE_W_DIVIDE_1_RMSK                  0x00000001 /* 2:2 */ 
#define NV_056_SET_TLMODE_W_DIVIDE_1_WORD                  0
#define NV_056_SET_TLMODE_W_DIVIDE_1_HIGH_FIELD            0x00000002 /* =2 */
#define NV_056_SET_TLMODE_W_DIVIDE_1_LOW_FIELD             0x00000002 /* =2 */
#define NV_056_SET_TLMODE_W_DIVIDE_1_DISABLE_ADJ           0x00000000
#define NV_056_SET_TLMODE_W_DIVIDE_1_ENABLE_ADJ            0x00000004
#define NV_056_SET_TLMODE_MSK                              0x00000007 
#define NV_056_SET_POINT_SIZE_V_MSK                        0xFFFFFFFF /* 31:0 */ 
#define NV_056_SET_POINT_SIZE_V_RMSK                       0xFFFFFFFF /* 31:0 */ 
#define NV_056_SET_POINT_SIZE_V_WORD                       0
#define NV_056_SET_POINT_SIZE_V_HIGH_FIELD                 0x0000001F /* =31 */
#define NV_056_SET_POINT_SIZE_V_LOW_FIELD                  0x00000000 /* =0 */
#define NV_056_SET_POINT_SIZE_MSK                          0xFFFFFFFF 
#define NV_056_SET_SWATH_WIDTH_V_MSK                       0xFFFFFFFF /* 31:0 */ 
#define NV_056_SET_SWATH_WIDTH_V_RMSK                      0xFFFFFFFF /* 31:0 */ 
#define NV_056_SET_SWATH_WIDTH_V_WORD                      0
#define NV_056_SET_SWATH_WIDTH_V_HIGH_FIELD                0x0000001F /* =31 */
#define NV_056_SET_SWATH_WIDTH_V_LOW_FIELD                 0x00000000 /* =0 */
#define NV_056_SET_SWATH_WIDTH_V_8_ADJ                     0x00000000
#define NV_056_SET_SWATH_WIDTH_V_16_ADJ                    0x00000001
#define NV_056_SET_SWATH_WIDTH_V_32_ADJ                    0x00000002
#define NV_056_SET_SWATH_WIDTH_V_64_ADJ                    0x00000003
#define NV_056_SET_SWATH_WIDTH_MSK                         0xFFFFFFFF 
#define NV_056_SET_FLAT_SHADE_OP_V_MSK                     0xFFFFFFFF /* 31:0 */ 
#define NV_056_SET_FLAT_SHADE_OP_V_RMSK                    0xFFFFFFFF /* 31:0 */ 
#define NV_056_SET_FLAT_SHADE_OP_V_WORD                    0
#define NV_056_SET_FLAT_SHADE_OP_V_HIGH_FIELD              0x0000001F /* =31 */
#define NV_056_SET_FLAT_SHADE_OP_V_LOW_FIELD               0x00000000 /* =0 */
#define NV_056_SET_FLAT_SHADE_OP_V_LAST_VTX_ADJ            0x00000000
#define NV_056_SET_FLAT_SHADE_OP_V_FIRST_VTX_ADJ           0x00000001
#define NV_056_SET_FLAT_SHADE_OP_MSK                       0xFFFFFFFF 
#define NV_056_SET_MODEL_VIEW_MATRIX0_MSK                  0x00000000 
#define NV_056_SET_MODEL_VIEW_MATRIX1_MSK                  0x00000000 
#define NV_056_SET_INVERSE_MODEL_VIEW_MATRIX0_MSK          0x00000000 
#define NV_056_SET_INVERSE_MODEL_VIEW_MATRIX1_MSK          0x00000000 
#define NV_056_SET_COMPOSITE_MATRIX_MSK                    0x00000000 
#define NV_056_SET_TEXTURE_MATRIX0_MSK                     0x00000000 
#define NV_056_SET_TEXTURE_MATRIX1_MSK                     0x00000000 
#define NV_056_SET_TEXGEN_SPLANE0_MSK                      0x00000000 
#define NV_056_SET_TEXGEN_TPLANE0_MSK                      0x00000000 
#define NV_056_SET_TEXGEN_RPLANE0_MSK                      0x00000000 
#define NV_056_SET_TEXGEN_QPLANE0_MSK                      0x00000000 
#define NV_056_SET_TEXGEN_SPLANE1_MSK                      0x00000000 
#define NV_056_SET_TEXGEN_TPLANE1_MSK                      0x00000000 
#define NV_056_SET_TEXGEN_RPLANE1_MSK                      0x00000000 
#define NV_056_SET_TEXGEN_QPLANE1_MSK                      0x00000000 
#define NV_056_SET_FOG_PARAMS_MSK                          0x00000000 
#define NV_056_SET_FOG_PLANE_MSK                           0x00000000 
#define NV_056_SET_SPECULAR_PARAMS_MSK                     0x00000000 
#define NV_056_SET_SCENE_AMBIENT_COLOR_MSK                 0x00000000 
#define NV_056_SET_VIEWPORT_OFFSET_MSK                     0x00000000 
#define NV_056_SET_POINT_PARAMS_MSK                        0x00000000 
#define NV_056_SET_EYE_POSITION_MSK                        0x00000000 
#define NV_056_SET_LIGHT_LOCAL_RANGE_MSK                   0x00000000 
#define NV_056_SET_VERTEX3F_MSK                            0x00000000 
#define NV_056_SET_VERTEX4F_MSK                            0x00000000 
#define NV_056_SET_VERTEX4S_MSK                            0x00000000 
#define NV_056_SET_NORMAL3F_MSK                            0x00000000 
#define NV_056_SET_NORMAL3S_MSK                            0x00000000 
#define NV_056_SET_DIFFUSE_COLOR4F_MSK                     0x00000000 
#define NV_056_SET_DIFFUSE_COLOR3F_MSK                     0x00000000 
#define NV_056_SET_DIFFUSE_COLOR4UB_MSK                    0x00000000 
#define NV_056_SET_SPECULAR_COLOR4F_MSK                    0x00000000 
#define NV_056_SET_SPECULAR_COLOR3F_MSK                    0x00000000 
#define NV_056_SET_SPECULAR_COLOR4UB_MSK                   0x00000000 
#define NV_056_SET_TEXCOORD0_2F_MSK                        0x00000000 
#define NV_056_SET_TEXCOORD0_2S_MSK                        0x00000000 
#define NV_056_SET_TEXCOORD0_4F_MSK                        0x00000000 
#define NV_056_SET_TEXCOORD0_4S_MSK                        0x00000000 
#define NV_056_SET_TEXCOORD1_2F_MSK                        0x00000000 
#define NV_056_SET_TEXCOORD1_2S_MSK                        0x00000000 
#define NV_056_SET_TEXCOORD1_4F_MSK                        0x00000000 
#define NV_056_SET_TEXCOORD1_4S_MSK                        0x00000000 
#define NV_056_SET_FOG1F_MSK                               0x00000000 
#define NV_056_SET_WEIGHT1F_MSK                            0x00000000 
#define NV_056_SET_EDGE_FLAG_MSK                           0x00000000 
#define NV_056_INVALIDATE_VERTEX_CACHE_FILE_MSK            0x00000000 
#define NV_056_INVALIDATE_VERTEX_FILE_MSK                  0x00000000 
#define NV_056_TL_NOP_MSK                                  0x00000000 
#define NV_056_TL_SYNC_MSK                                 0x00000000 
#define NV_056_SET_VERTEX_ARRAY_OFFSET_OFFSET_MSK          0x0FFFFFFF /* 27:0 */ 
#define NV_056_SET_VERTEX_ARRAY_OFFSET_OFFSET_RMSK         0x0FFFFFFF /* 27:0 */ 
#define NV_056_SET_VERTEX_ARRAY_OFFSET_OFFSET_WORD         0
#define NV_056_SET_VERTEX_ARRAY_OFFSET_OFFSET_HIGH_FIELD   0x0000001B /* =27 */
#define NV_056_SET_VERTEX_ARRAY_OFFSET_OFFSET_LOW_FIELD    0x00000000 /* =0 */
#define NV_056_SET_VERTEX_ARRAY_OFFSET_MSK                 0x0FFFFFFF 
#define NV_056_SET_VERTEX_ARRAY_FORMAT_W_MSK               0xFF000000 /* 31:24 */ 
#define NV_056_SET_VERTEX_ARRAY_FORMAT_W_RMSK              0x000000FF /* 31:24 */ 
#define NV_056_SET_VERTEX_ARRAY_FORMAT_W_WORD              0
#define NV_056_SET_VERTEX_ARRAY_FORMAT_W_HIGH_FIELD        0x0000001F /* =31 */
#define NV_056_SET_VERTEX_ARRAY_FORMAT_W_LOW_FIELD         0x00000018 /* =24 */
#define NV_056_SET_VERTEX_ARRAY_FORMAT_W_NONE_ADJ          0x00000000
#define NV_056_SET_VERTEX_ARRAY_FORMAT_W_PRESENT_ADJ       0x01000000
#define NV_056_SET_VERTEX_ARRAY_FORMAT_STRIDE_MSK          0x00FFFF00 /* 23:8 */ 
#define NV_056_SET_VERTEX_ARRAY_FORMAT_STRIDE_RMSK         0x0000FFFF /* 23:8 */ 
#define NV_056_SET_VERTEX_ARRAY_FORMAT_STRIDE_WORD         0
#define NV_056_SET_VERTEX_ARRAY_FORMAT_STRIDE_HIGH_FIELD   0x00000017 /* =23 */
#define NV_056_SET_VERTEX_ARRAY_FORMAT_STRIDE_LOW_FIELD    0x00000008 /* =8 */
#define NV_056_SET_VERTEX_ARRAY_FORMAT_SIZE_MSK            0x000000F0 /* 7:4 */ 
#define NV_056_SET_VERTEX_ARRAY_FORMAT_SIZE_RMSK           0x0000000F /* 7:4 */ 
#define NV_056_SET_VERTEX_ARRAY_FORMAT_SIZE_WORD           0
#define NV_056_SET_VERTEX_ARRAY_FORMAT_SIZE_HIGH_FIELD     0x00000007 /* =7 */
#define NV_056_SET_VERTEX_ARRAY_FORMAT_SIZE_LOW_FIELD      0x00000004 /* =4 */
#define NV_056_SET_VERTEX_ARRAY_FORMAT_SIZE_2_ADJ          0x00000020
#define NV_056_SET_VERTEX_ARRAY_FORMAT_SIZE_3_ADJ          0x00000030
#define NV_056_SET_VERTEX_ARRAY_FORMAT_SIZE_4_ADJ          0x00000040
#define NV_056_SET_VERTEX_ARRAY_FORMAT_TYPE_MSK            0x0000000F /* 3:0 */ 
#define NV_056_SET_VERTEX_ARRAY_FORMAT_TYPE_RMSK           0x0000000F /* 3:0 */ 
#define NV_056_SET_VERTEX_ARRAY_FORMAT_TYPE_WORD           0
#define NV_056_SET_VERTEX_ARRAY_FORMAT_TYPE_HIGH_FIELD     0x00000003 /* =3 */
#define NV_056_SET_VERTEX_ARRAY_FORMAT_TYPE_LOW_FIELD      0x00000000 /* =0 */
#define NV_056_SET_VERTEX_ARRAY_FORMAT_TYPE_SHORT_ADJ      0x00000001
#define NV_056_SET_VERTEX_ARRAY_FORMAT_TYPE_FLOAT_ADJ      0x00000002
#define NV_056_SET_VERTEX_ARRAY_FORMAT_MSK                 0xFFFFFFFF 
#define NV_056_SET_DIFFUSE_ARRAY_OFFSET_OFFSET_MSK         0x0FFFFFFF /* 27:0 */ 
#define NV_056_SET_DIFFUSE_ARRAY_OFFSET_OFFSET_RMSK        0x0FFFFFFF /* 27:0 */ 
#define NV_056_SET_DIFFUSE_ARRAY_OFFSET_OFFSET_WORD        0
#define NV_056_SET_DIFFUSE_ARRAY_OFFSET_OFFSET_HIGH_FIELD  0x0000001B /* =27 */
#define NV_056_SET_DIFFUSE_ARRAY_OFFSET_OFFSET_LOW_FIELD   0x00000000 /* =0 */
#define NV_056_SET_DIFFUSE_ARRAY_OFFSET_MSK                0x0FFFFFFF 
#define NV_056_SET_DIFFUSE_ARRAY_FORMAT_STRIDE_MSK         0xFFFFFF00 /* 31:8 */ 
#define NV_056_SET_DIFFUSE_ARRAY_FORMAT_STRIDE_RMSK        0x00FFFFFF /* 31:8 */ 
#define NV_056_SET_DIFFUSE_ARRAY_FORMAT_STRIDE_WORD        0
#define NV_056_SET_DIFFUSE_ARRAY_FORMAT_STRIDE_HIGH_FIELD  0x0000001F /* =31 */
#define NV_056_SET_DIFFUSE_ARRAY_FORMAT_STRIDE_LOW_FIELD   0x00000008 /* =8 */
#define NV_056_SET_DIFFUSE_ARRAY_FORMAT_SIZE_MSK           0x000000F0 /* 7:4 */ 
#define NV_056_SET_DIFFUSE_ARRAY_FORMAT_SIZE_RMSK          0x0000000F /* 7:4 */ 
#define NV_056_SET_DIFFUSE_ARRAY_FORMAT_SIZE_WORD          0
#define NV_056_SET_DIFFUSE_ARRAY_FORMAT_SIZE_HIGH_FIELD    0x00000007 /* =7 */
#define NV_056_SET_DIFFUSE_ARRAY_FORMAT_SIZE_LOW_FIELD     0x00000004 /* =4 */
#define NV_056_SET_DIFFUSE_ARRAY_FORMAT_SIZE_0_ADJ         0x00000000
#define NV_056_SET_DIFFUSE_ARRAY_FORMAT_SIZE_3_ADJ         0x00000030
#define NV_056_SET_DIFFUSE_ARRAY_FORMAT_SIZE_4_ADJ         0x00000040
#define NV_056_SET_DIFFUSE_ARRAY_FORMAT_TYPE_MSK           0x0000000F /* 3:0 */ 
#define NV_056_SET_DIFFUSE_ARRAY_FORMAT_TYPE_RMSK          0x0000000F /* 3:0 */ 
#define NV_056_SET_DIFFUSE_ARRAY_FORMAT_TYPE_WORD          0
#define NV_056_SET_DIFFUSE_ARRAY_FORMAT_TYPE_HIGH_FIELD    0x00000003 /* =3 */
#define NV_056_SET_DIFFUSE_ARRAY_FORMAT_TYPE_LOW_FIELD     0x00000000 /* =0 */
#define NV_056_SET_DIFFUSE_ARRAY_FORMAT_TYPE_UNSIGNED_BYTE_BGRA_ADJ 0x00000000
#define NV_056_SET_DIFFUSE_ARRAY_FORMAT_TYPE_FLOAT_ADJ     0x00000002
#define NV_056_SET_DIFFUSE_ARRAY_FORMAT_TYPE_UNSIGNED_BYTE_RGBA_ADJ 0x00000004
#define NV_056_SET_DIFFUSE_ARRAY_FORMAT_MSK                0xFFFFFFFF 
#define NV_056_SET_SPECULAR_ARRAY_OFFSET_OFFSET_MSK        0x0FFFFFFF /* 27:0 */ 
#define NV_056_SET_SPECULAR_ARRAY_OFFSET_OFFSET_RMSK       0x0FFFFFFF /* 27:0 */ 
#define NV_056_SET_SPECULAR_ARRAY_OFFSET_OFFSET_WORD       0
#define NV_056_SET_SPECULAR_ARRAY_OFFSET_OFFSET_HIGH_FIELD 0x0000001B /* =27 */
#define NV_056_SET_SPECULAR_ARRAY_OFFSET_OFFSET_LOW_FIELD  0x00000000 /* =0 */
#define NV_056_SET_SPECULAR_ARRAY_OFFSET_MSK               0x0FFFFFFF 
#define NV_056_SET_SPECULAR_ARRAY_FORMAT_STRIDE_MSK        0xFFFFFF00 /* 31:8 */ 
#define NV_056_SET_SPECULAR_ARRAY_FORMAT_STRIDE_RMSK       0x00FFFFFF /* 31:8 */ 
#define NV_056_SET_SPECULAR_ARRAY_FORMAT_STRIDE_WORD       0
#define NV_056_SET_SPECULAR_ARRAY_FORMAT_STRIDE_HIGH_FIELD 0x0000001F /* =31 */
#define NV_056_SET_SPECULAR_ARRAY_FORMAT_STRIDE_LOW_FIELD  0x00000008 /* =8 */
#define NV_056_SET_SPECULAR_ARRAY_FORMAT_SIZE_MSK          0x000000F0 /* 7:4 */ 
#define NV_056_SET_SPECULAR_ARRAY_FORMAT_SIZE_RMSK         0x0000000F /* 7:4 */ 
#define NV_056_SET_SPECULAR_ARRAY_FORMAT_SIZE_WORD         0
#define NV_056_SET_SPECULAR_ARRAY_FORMAT_SIZE_HIGH_FIELD   0x00000007 /* =7 */
#define NV_056_SET_SPECULAR_ARRAY_FORMAT_SIZE_LOW_FIELD    0x00000004 /* =4 */
#define NV_056_SET_SPECULAR_ARRAY_FORMAT_SIZE_0_ADJ        0x00000000
#define NV_056_SET_SPECULAR_ARRAY_FORMAT_SIZE_3_ADJ        0x00000030
#define NV_056_SET_SPECULAR_ARRAY_FORMAT_SIZE_4_ADJ        0x00000040
#define NV_056_SET_SPECULAR_ARRAY_FORMAT_TYPE_MSK          0x0000000F /* 3:0 */ 
#define NV_056_SET_SPECULAR_ARRAY_FORMAT_TYPE_RMSK         0x0000000F /* 3:0 */ 
#define NV_056_SET_SPECULAR_ARRAY_FORMAT_TYPE_WORD         0
#define NV_056_SET_SPECULAR_ARRAY_FORMAT_TYPE_HIGH_FIELD   0x00000003 /* =3 */
#define NV_056_SET_SPECULAR_ARRAY_FORMAT_TYPE_LOW_FIELD    0x00000000 /* =0 */
#define NV_056_SET_SPECULAR_ARRAY_FORMAT_TYPE_UNSIGNED_BYTE_BGRA_ADJ 0x00000000
#define NV_056_SET_SPECULAR_ARRAY_FORMAT_TYPE_FLOAT_ADJ    0x00000002
#define NV_056_SET_SPECULAR_ARRAY_FORMAT_TYPE_UNSIGNED_BYTE_RGBA_ADJ 0x00000004
#define NV_056_SET_SPECULAR_ARRAY_FORMAT_MSK               0xFFFFFFFF 
#define NV_056_SET_TEX_COORD0_ARRAY_OFFSET_OFFSET_MSK      0x0FFFFFFF /* 27:0 */ 
#define NV_056_SET_TEX_COORD0_ARRAY_OFFSET_OFFSET_RMSK     0x0FFFFFFF /* 27:0 */ 
#define NV_056_SET_TEX_COORD0_ARRAY_OFFSET_OFFSET_WORD     0
#define NV_056_SET_TEX_COORD0_ARRAY_OFFSET_OFFSET_HIGH_FIELD 0x0000001B /* =27 */
#define NV_056_SET_TEX_COORD0_ARRAY_OFFSET_OFFSET_LOW_FIELD 0x00000000 /* =0 */
#define NV_056_SET_TEX_COORD0_ARRAY_OFFSET_MSK             0x0FFFFFFF 
#define NV_056_SET_TEX_COORD0_ARRAY_FORMAT_STRIDE_MSK      0xFFFFFF00 /* 31:8 */ 
#define NV_056_SET_TEX_COORD0_ARRAY_FORMAT_STRIDE_RMSK     0x00FFFFFF /* 31:8 */ 
#define NV_056_SET_TEX_COORD0_ARRAY_FORMAT_STRIDE_WORD     0
#define NV_056_SET_TEX_COORD0_ARRAY_FORMAT_STRIDE_HIGH_FIELD 0x0000001F /* =31 */
#define NV_056_SET_TEX_COORD0_ARRAY_FORMAT_STRIDE_LOW_FIELD 0x00000008 /* =8 */
#define NV_056_SET_TEX_COORD0_ARRAY_FORMAT_SIZE_MSK        0x000000F0 /* 7:4 */ 
#define NV_056_SET_TEX_COORD0_ARRAY_FORMAT_SIZE_RMSK       0x0000000F /* 7:4 */ 
#define NV_056_SET_TEX_COORD0_ARRAY_FORMAT_SIZE_WORD       0
#define NV_056_SET_TEX_COORD0_ARRAY_FORMAT_SIZE_HIGH_FIELD 0x00000007 /* =7 */
#define NV_056_SET_TEX_COORD0_ARRAY_FORMAT_SIZE_LOW_FIELD  0x00000004 /* =4 */
#define NV_056_SET_TEX_COORD0_ARRAY_FORMAT_SIZE_0_ADJ      0x00000000
#define NV_056_SET_TEX_COORD0_ARRAY_FORMAT_SIZE_1_ADJ      0x00000010
#define NV_056_SET_TEX_COORD0_ARRAY_FORMAT_SIZE_2_ADJ      0x00000020
#define NV_056_SET_TEX_COORD0_ARRAY_FORMAT_SIZE_3_ADJ      0x00000030
#define NV_056_SET_TEX_COORD0_ARRAY_FORMAT_SIZE_4_ADJ      0x00000040
#define NV_056_SET_TEX_COORD0_ARRAY_FORMAT_TYPE_MSK        0x0000000F /* 3:0 */ 
#define NV_056_SET_TEX_COORD0_ARRAY_FORMAT_TYPE_RMSK       0x0000000F /* 3:0 */ 
#define NV_056_SET_TEX_COORD0_ARRAY_FORMAT_TYPE_WORD       0
#define NV_056_SET_TEX_COORD0_ARRAY_FORMAT_TYPE_HIGH_FIELD 0x00000003 /* =3 */
#define NV_056_SET_TEX_COORD0_ARRAY_FORMAT_TYPE_LOW_FIELD  0x00000000 /* =0 */
#define NV_056_SET_TEX_COORD0_ARRAY_FORMAT_TYPE_SHORT_ADJ  0x00000001
#define NV_056_SET_TEX_COORD0_ARRAY_FORMAT_TYPE_FLOAT_ADJ  0x00000002
#define NV_056_SET_TEX_COORD0_ARRAY_FORMAT_MSK             0xFFFFFFFF 
#define NV_056_SET_TEX_COORD1_ARRAY_OFFSET_OFFSET_MSK      0x0FFFFFFF /* 27:0 */ 
#define NV_056_SET_TEX_COORD1_ARRAY_OFFSET_OFFSET_RMSK     0x0FFFFFFF /* 27:0 */ 
#define NV_056_SET_TEX_COORD1_ARRAY_OFFSET_OFFSET_WORD     0
#define NV_056_SET_TEX_COORD1_ARRAY_OFFSET_OFFSET_HIGH_FIELD 0x0000001B /* =27 */
#define NV_056_SET_TEX_COORD1_ARRAY_OFFSET_OFFSET_LOW_FIELD 0x00000000 /* =0 */
#define NV_056_SET_TEX_COORD1_ARRAY_OFFSET_MSK             0x0FFFFFFF 
#define NV_056_SET_TEX_COORD1_ARRAY_FORMAT_STRIDE_MSK      0xFFFFFF00 /* 31:8 */ 
#define NV_056_SET_TEX_COORD1_ARRAY_FORMAT_STRIDE_RMSK     0x00FFFFFF /* 31:8 */ 
#define NV_056_SET_TEX_COORD1_ARRAY_FORMAT_STRIDE_WORD     0
#define NV_056_SET_TEX_COORD1_ARRAY_FORMAT_STRIDE_HIGH_FIELD 0x0000001F /* =31 */
#define NV_056_SET_TEX_COORD1_ARRAY_FORMAT_STRIDE_LOW_FIELD 0x00000008 /* =8 */
#define NV_056_SET_TEX_COORD1_ARRAY_FORMAT_SIZE_MSK        0x000000F0 /* 7:4 */ 
#define NV_056_SET_TEX_COORD1_ARRAY_FORMAT_SIZE_RMSK       0x0000000F /* 7:4 */ 
#define NV_056_SET_TEX_COORD1_ARRAY_FORMAT_SIZE_WORD       0
#define NV_056_SET_TEX_COORD1_ARRAY_FORMAT_SIZE_HIGH_FIELD 0x00000007 /* =7 */
#define NV_056_SET_TEX_COORD1_ARRAY_FORMAT_SIZE_LOW_FIELD  0x00000004 /* =4 */
#define NV_056_SET_TEX_COORD1_ARRAY_FORMAT_SIZE_0_ADJ      0x00000000
#define NV_056_SET_TEX_COORD1_ARRAY_FORMAT_SIZE_1_ADJ      0x00000010
#define NV_056_SET_TEX_COORD1_ARRAY_FORMAT_SIZE_2_ADJ      0x00000020
#define NV_056_SET_TEX_COORD1_ARRAY_FORMAT_SIZE_3_ADJ      0x00000030
#define NV_056_SET_TEX_COORD1_ARRAY_FORMAT_SIZE_4_ADJ      0x00000040
#define NV_056_SET_TEX_COORD1_ARRAY_FORMAT_TYPE_MSK        0x0000000F /* 3:0 */ 
#define NV_056_SET_TEX_COORD1_ARRAY_FORMAT_TYPE_RMSK       0x0000000F /* 3:0 */ 
#define NV_056_SET_TEX_COORD1_ARRAY_FORMAT_TYPE_WORD       0
#define NV_056_SET_TEX_COORD1_ARRAY_FORMAT_TYPE_HIGH_FIELD 0x00000003 /* =3 */
#define NV_056_SET_TEX_COORD1_ARRAY_FORMAT_TYPE_LOW_FIELD  0x00000000 /* =0 */
#define NV_056_SET_TEX_COORD1_ARRAY_FORMAT_TYPE_SHORT_ADJ  0x00000001
#define NV_056_SET_TEX_COORD1_ARRAY_FORMAT_TYPE_FLOAT_ADJ  0x00000002
#define NV_056_SET_TEX_COORD1_ARRAY_FORMAT_MSK             0xFFFFFFFF 
#define NV_056_SET_NORMAL_ARRAY_OFFSET_OFFSET_MSK          0x0FFFFFFF /* 27:0 */ 
#define NV_056_SET_NORMAL_ARRAY_OFFSET_OFFSET_RMSK         0x0FFFFFFF /* 27:0 */ 
#define NV_056_SET_NORMAL_ARRAY_OFFSET_OFFSET_WORD         0
#define NV_056_SET_NORMAL_ARRAY_OFFSET_OFFSET_HIGH_FIELD   0x0000001B /* =27 */
#define NV_056_SET_NORMAL_ARRAY_OFFSET_OFFSET_LOW_FIELD    0x00000000 /* =0 */
#define NV_056_SET_NORMAL_ARRAY_OFFSET_MSK                 0x0FFFFFFF 
#define NV_056_SET_NORMAL_ARRAY_FORMAT_STRIDE_MSK          0xFFFFFF00 /* 31:8 */ 
#define NV_056_SET_NORMAL_ARRAY_FORMAT_STRIDE_RMSK         0x00FFFFFF /* 31:8 */ 
#define NV_056_SET_NORMAL_ARRAY_FORMAT_STRIDE_WORD         0
#define NV_056_SET_NORMAL_ARRAY_FORMAT_STRIDE_HIGH_FIELD   0x0000001F /* =31 */
#define NV_056_SET_NORMAL_ARRAY_FORMAT_STRIDE_LOW_FIELD    0x00000008 /* =8 */
#define NV_056_SET_NORMAL_ARRAY_FORMAT_SIZE_MSK            0x000000F0 /* 7:4 */ 
#define NV_056_SET_NORMAL_ARRAY_FORMAT_SIZE_RMSK           0x0000000F /* 7:4 */ 
#define NV_056_SET_NORMAL_ARRAY_FORMAT_SIZE_WORD           0
#define NV_056_SET_NORMAL_ARRAY_FORMAT_SIZE_HIGH_FIELD     0x00000007 /* =7 */
#define NV_056_SET_NORMAL_ARRAY_FORMAT_SIZE_LOW_FIELD      0x00000004 /* =4 */
#define NV_056_SET_NORMAL_ARRAY_FORMAT_SIZE_0_ADJ          0x00000000
#define NV_056_SET_NORMAL_ARRAY_FORMAT_SIZE_3_ADJ          0x00000030
#define NV_056_SET_NORMAL_ARRAY_FORMAT_TYPE_MSK            0x0000000F /* 3:0 */ 
#define NV_056_SET_NORMAL_ARRAY_FORMAT_TYPE_RMSK           0x0000000F /* 3:0 */ 
#define NV_056_SET_NORMAL_ARRAY_FORMAT_TYPE_WORD           0
#define NV_056_SET_NORMAL_ARRAY_FORMAT_TYPE_HIGH_FIELD     0x00000003 /* =3 */
#define NV_056_SET_NORMAL_ARRAY_FORMAT_TYPE_LOW_FIELD      0x00000000 /* =0 */
#define NV_056_SET_NORMAL_ARRAY_FORMAT_TYPE_SHORT_ADJ      0x00000001
#define NV_056_SET_NORMAL_ARRAY_FORMAT_TYPE_FLOAT_ADJ      0x00000002
#define NV_056_SET_NORMAL_ARRAY_FORMAT_MSK                 0xFFFFFFFF 
#define NV_056_SET_WEIGHT_ARRAY_OFFSET_OFFSET_MSK          0x0FFFFFFF /* 27:0 */ 
#define NV_056_SET_WEIGHT_ARRAY_OFFSET_OFFSET_RMSK         0x0FFFFFFF /* 27:0 */ 
#define NV_056_SET_WEIGHT_ARRAY_OFFSET_OFFSET_WORD         0
#define NV_056_SET_WEIGHT_ARRAY_OFFSET_OFFSET_HIGH_FIELD   0x0000001B /* =27 */
#define NV_056_SET_WEIGHT_ARRAY_OFFSET_OFFSET_LOW_FIELD    0x00000000 /* =0 */
#define NV_056_SET_WEIGHT_ARRAY_OFFSET_MSK                 0x0FFFFFFF 
#define NV_056_SET_WEIGHT_ARRAY_FORMAT_STRIDE_MSK          0xFFFFFF00 /* 31:8 */ 
#define NV_056_SET_WEIGHT_ARRAY_FORMAT_STRIDE_RMSK         0x00FFFFFF /* 31:8 */ 
#define NV_056_SET_WEIGHT_ARRAY_FORMAT_STRIDE_WORD         0
#define NV_056_SET_WEIGHT_ARRAY_FORMAT_STRIDE_HIGH_FIELD   0x0000001F /* =31 */
#define NV_056_SET_WEIGHT_ARRAY_FORMAT_STRIDE_LOW_FIELD    0x00000008 /* =8 */
#define NV_056_SET_WEIGHT_ARRAY_FORMAT_SIZE_MSK            0x000000F0 /* 7:4 */ 
#define NV_056_SET_WEIGHT_ARRAY_FORMAT_SIZE_RMSK           0x0000000F /* 7:4 */ 
#define NV_056_SET_WEIGHT_ARRAY_FORMAT_SIZE_WORD           0
#define NV_056_SET_WEIGHT_ARRAY_FORMAT_SIZE_HIGH_FIELD     0x00000007 /* =7 */
#define NV_056_SET_WEIGHT_ARRAY_FORMAT_SIZE_LOW_FIELD      0x00000004 /* =4 */
#define NV_056_SET_WEIGHT_ARRAY_FORMAT_SIZE_0_ADJ          0x00000000
#define NV_056_SET_WEIGHT_ARRAY_FORMAT_SIZE_1_ADJ          0x00000010
#define NV_056_SET_WEIGHT_ARRAY_FORMAT_TYPE_MSK            0x0000000F /* 3:0 */ 
#define NV_056_SET_WEIGHT_ARRAY_FORMAT_TYPE_RMSK           0x0000000F /* 3:0 */ 
#define NV_056_SET_WEIGHT_ARRAY_FORMAT_TYPE_WORD           0
#define NV_056_SET_WEIGHT_ARRAY_FORMAT_TYPE_HIGH_FIELD     0x00000003 /* =3 */
#define NV_056_SET_WEIGHT_ARRAY_FORMAT_TYPE_LOW_FIELD      0x00000000 /* =0 */
#define NV_056_SET_WEIGHT_ARRAY_FORMAT_TYPE_SHORT_ADJ      0x00000001
#define NV_056_SET_WEIGHT_ARRAY_FORMAT_TYPE_FLOAT_ADJ      0x00000002
#define NV_056_SET_WEIGHT_ARRAY_FORMAT_MSK                 0xFFFFFFFF 
#define NV_056_SET_FOG_ARRAY_OFFSET_OFFSET_MSK             0x0FFFFFFF /* 27:0 */ 
#define NV_056_SET_FOG_ARRAY_OFFSET_OFFSET_RMSK            0x0FFFFFFF /* 27:0 */ 
#define NV_056_SET_FOG_ARRAY_OFFSET_OFFSET_WORD            0
#define NV_056_SET_FOG_ARRAY_OFFSET_OFFSET_HIGH_FIELD      0x0000001B /* =27 */
#define NV_056_SET_FOG_ARRAY_OFFSET_OFFSET_LOW_FIELD       0x00000000 /* =0 */
#define NV_056_SET_FOG_ARRAY_OFFSET_MSK                    0x0FFFFFFF 
#define NV_056_SET_FOG_ARRAY_FORMAT_STRIDE_MSK             0xFFFFFF00 /* 31:8 */ 
#define NV_056_SET_FOG_ARRAY_FORMAT_STRIDE_RMSK            0x00FFFFFF /* 31:8 */ 
#define NV_056_SET_FOG_ARRAY_FORMAT_STRIDE_WORD            0
#define NV_056_SET_FOG_ARRAY_FORMAT_STRIDE_HIGH_FIELD      0x0000001F /* =31 */
#define NV_056_SET_FOG_ARRAY_FORMAT_STRIDE_LOW_FIELD       0x00000008 /* =8 */
#define NV_056_SET_FOG_ARRAY_FORMAT_SIZE_MSK               0x000000F0 /* 7:4 */ 
#define NV_056_SET_FOG_ARRAY_FORMAT_SIZE_RMSK              0x0000000F /* 7:4 */ 
#define NV_056_SET_FOG_ARRAY_FORMAT_SIZE_WORD              0
#define NV_056_SET_FOG_ARRAY_FORMAT_SIZE_HIGH_FIELD        0x00000007 /* =7 */
#define NV_056_SET_FOG_ARRAY_FORMAT_SIZE_LOW_FIELD         0x00000004 /* =4 */
#define NV_056_SET_FOG_ARRAY_FORMAT_SIZE_0_ADJ             0x00000000
#define NV_056_SET_FOG_ARRAY_FORMAT_SIZE_1_ADJ             0x00000010
#define NV_056_SET_FOG_ARRAY_FORMAT_TYPE_MSK               0x0000000F /* 3:0 */ 
#define NV_056_SET_FOG_ARRAY_FORMAT_TYPE_RMSK              0x0000000F /* 3:0 */ 
#define NV_056_SET_FOG_ARRAY_FORMAT_TYPE_WORD              0
#define NV_056_SET_FOG_ARRAY_FORMAT_TYPE_HIGH_FIELD        0x00000003 /* =3 */
#define NV_056_SET_FOG_ARRAY_FORMAT_TYPE_LOW_FIELD         0x00000000 /* =0 */
#define NV_056_SET_FOG_ARRAY_FORMAT_TYPE_SHORT_ADJ         0x00000001
#define NV_056_SET_FOG_ARRAY_FORMAT_TYPE_FLOAT_ADJ         0x00000002
#define NV_056_SET_FOG_ARRAY_FORMAT_MSK                    0xFFFFFFFF 
#define NV_056_SET_BEGIN_END_OP_MSK                        0xFFFFFFFF /* 31:0 */ 
#define NV_056_SET_BEGIN_END_OP_RMSK                       0xFFFFFFFF /* 31:0 */ 
#define NV_056_SET_BEGIN_END_OP_WORD                       0
#define NV_056_SET_BEGIN_END_OP_HIGH_FIELD                 0x0000001F /* =31 */
#define NV_056_SET_BEGIN_END_OP_LOW_FIELD                  0x00000000 /* =0 */
#define NV_056_SET_BEGIN_END_OP_END_ADJ                    0x00000000
#define NV_056_SET_BEGIN_END_OP_POINTS_ADJ                 0x00000001
#define NV_056_SET_BEGIN_END_OP_LINES_ADJ                  0x00000002
#define NV_056_SET_BEGIN_END_OP_LINE_LOOP_ADJ              0x00000003
#define NV_056_SET_BEGIN_END_OP_LINE_STRIP_ADJ             0x00000004
#define NV_056_SET_BEGIN_END_OP_TRIANGLES_ADJ              0x00000005
#define NV_056_SET_BEGIN_END_OP_TRIANGLE_STRIP_ADJ         0x00000006
#define NV_056_SET_BEGIN_END_OP_TRIANGLE_FAN_ADJ           0x00000007
#define NV_056_SET_BEGIN_END_OP_QUADS_ADJ                  0x00000008
#define NV_056_SET_BEGIN_END_OP_QUAD_STRIP_ADJ             0x00000009
#define NV_056_SET_BEGIN_END_OP_POLYGON_ADJ                0x0000000A
#define NV_056_SET_BEGIN_END_MSK                           0xFFFFFFFF 
#define NV_056_ARRAY_ELEMENT16_VERTEX0_MSK                 0x0000FFFF /* 15:0 */ 
#define NV_056_ARRAY_ELEMENT16_VERTEX0_RMSK                0x0000FFFF /* 15:0 */ 
#define NV_056_ARRAY_ELEMENT16_VERTEX0_WORD                0
#define NV_056_ARRAY_ELEMENT16_VERTEX0_HIGH_FIELD          0x0000000F /* =15 */
#define NV_056_ARRAY_ELEMENT16_VERTEX0_LOW_FIELD           0x00000000 /* =0 */
#define NV_056_ARRAY_ELEMENT16_VERTEX1_MSK                 0xFFFF0000 /* 31:16 */ 
#define NV_056_ARRAY_ELEMENT16_VERTEX1_RMSK                0x0000FFFF /* 31:16 */ 
#define NV_056_ARRAY_ELEMENT16_VERTEX1_WORD                0
#define NV_056_ARRAY_ELEMENT16_VERTEX1_HIGH_FIELD          0x0000001F /* =31 */
#define NV_056_ARRAY_ELEMENT16_VERTEX1_LOW_FIELD           0x00000010 /* =16 */
#define NV_056_ARRAY_ELEMENT16_MSK                         0xFFFFFFFF 
#define NV_056_SET_BEGIN_END2_OP_MSK                       0xFFFFFFFF /* 31:0 */ 
#define NV_056_SET_BEGIN_END2_OP_RMSK                      0xFFFFFFFF /* 31:0 */ 
#define NV_056_SET_BEGIN_END2_OP_WORD                      0
#define NV_056_SET_BEGIN_END2_OP_HIGH_FIELD                0x0000001F /* =31 */
#define NV_056_SET_BEGIN_END2_OP_LOW_FIELD                 0x00000000 /* =0 */
#define NV_056_SET_BEGIN_END2_OP_END_ADJ                   0x00000000
#define NV_056_SET_BEGIN_END2_OP_POINTS_ADJ                0x00000001
#define NV_056_SET_BEGIN_END2_OP_LINES_ADJ                 0x00000002
#define NV_056_SET_BEGIN_END2_OP_LINE_LOOP_ADJ             0x00000003
#define NV_056_SET_BEGIN_END2_OP_LINE_STRIP_ADJ            0x00000004
#define NV_056_SET_BEGIN_END2_OP_TRIANGLES_ADJ             0x00000005
#define NV_056_SET_BEGIN_END2_OP_TRIANGLE_STRIP_ADJ        0x00000006
#define NV_056_SET_BEGIN_END2_OP_TRIANGLE_FAN_ADJ          0x00000007
#define NV_056_SET_BEGIN_END2_OP_QUADS_ADJ                 0x00000008
#define NV_056_SET_BEGIN_END2_OP_QUAD_STRIP_ADJ            0x00000009
#define NV_056_SET_BEGIN_END2_OP_POLYGON_ADJ               0x0000000A
#define NV_056_SET_BEGIN_END2_MSK                          0xFFFFFFFF 
#define NV_056_ARRAY_ELEMENT32_V_MSK                       0xFFFFFFFF /* 31:0 */ 
#define NV_056_ARRAY_ELEMENT32_V_RMSK                      0xFFFFFFFF /* 31:0 */ 
#define NV_056_ARRAY_ELEMENT32_V_WORD                      0
#define NV_056_ARRAY_ELEMENT32_V_HIGH_FIELD                0x0000001F /* =31 */
#define NV_056_ARRAY_ELEMENT32_V_LOW_FIELD                 0x00000000 /* =0 */
#define NV_056_ARRAY_ELEMENT32_MSK                         0xFFFFFFFF 
#define NV_056_SET_BEGIN_END3_OP_MSK                       0xFFFFFFFF /* 31:0 */ 
#define NV_056_SET_BEGIN_END3_OP_RMSK                      0xFFFFFFFF /* 31:0 */ 
#define NV_056_SET_BEGIN_END3_OP_WORD                      0
#define NV_056_SET_BEGIN_END3_OP_HIGH_FIELD                0x0000001F /* =31 */
#define NV_056_SET_BEGIN_END3_OP_LOW_FIELD                 0x00000000 /* =0 */
#define NV_056_SET_BEGIN_END3_OP_END_ADJ                   0x00000000
#define NV_056_SET_BEGIN_END3_OP_POINTS_ADJ                0x00000001
#define NV_056_SET_BEGIN_END3_OP_LINES_ADJ                 0x00000002
#define NV_056_SET_BEGIN_END3_OP_LINE_LOOP_ADJ             0x00000003
#define NV_056_SET_BEGIN_END3_OP_LINE_STRIP_ADJ            0x00000004
#define NV_056_SET_BEGIN_END3_OP_TRIANGLES_ADJ             0x00000005
#define NV_056_SET_BEGIN_END3_OP_TRIANGLE_STRIP_ADJ        0x00000006
#define NV_056_SET_BEGIN_END3_OP_TRIANGLE_FAN_ADJ          0x00000007
#define NV_056_SET_BEGIN_END3_OP_QUADS_ADJ                 0x00000008
#define NV_056_SET_BEGIN_END3_OP_QUAD_STRIP_ADJ            0x00000009
#define NV_056_SET_BEGIN_END3_OP_POLYGON_ADJ               0x0000000A
#define NV_056_SET_BEGIN_END3_MSK                          0xFFFFFFFF 
#define NV_056_DRAW_ARRAYS_COUNT_MSK                       0xFF000000 /* 31:24 */ 
#define NV_056_DRAW_ARRAYS_COUNT_RMSK                      0x000000FF /* 31:24 */ 
#define NV_056_DRAW_ARRAYS_COUNT_WORD                      0
#define NV_056_DRAW_ARRAYS_COUNT_HIGH_FIELD                0x0000001F /* =31 */
#define NV_056_DRAW_ARRAYS_COUNT_LOW_FIELD                 0x00000018 /* =24 */
#define NV_056_DRAW_ARRAYS_START_INDEX_MSK                 0x00FFFFFF /* 23:0 */ 
#define NV_056_DRAW_ARRAYS_START_INDEX_RMSK                0x00FFFFFF /* 23:0 */ 
#define NV_056_DRAW_ARRAYS_START_INDEX_WORD                0
#define NV_056_DRAW_ARRAYS_START_INDEX_HIGH_FIELD          0x00000017 /* =23 */
#define NV_056_DRAW_ARRAYS_START_INDEX_LOW_FIELD           0x00000000 /* =0 */
#define NV_056_DRAW_ARRAYS_MSK                             0xFFFFFFFF 
#define NV_056_SET_BEGIN_END4_OP_MSK                       0xFFFFFFFF /* 31:0 */ 
#define NV_056_SET_BEGIN_END4_OP_RMSK                      0xFFFFFFFF /* 31:0 */ 
#define NV_056_SET_BEGIN_END4_OP_WORD                      0
#define NV_056_SET_BEGIN_END4_OP_HIGH_FIELD                0x0000001F /* =31 */
#define NV_056_SET_BEGIN_END4_OP_LOW_FIELD                 0x00000000 /* =0 */
#define NV_056_SET_BEGIN_END4_OP_END_ADJ                   0x00000000
#define NV_056_SET_BEGIN_END4_OP_POINTS_ADJ                0x00000001
#define NV_056_SET_BEGIN_END4_OP_LINES_ADJ                 0x00000002
#define NV_056_SET_BEGIN_END4_OP_LINE_LOOP_ADJ             0x00000003
#define NV_056_SET_BEGIN_END4_OP_LINE_STRIP_ADJ            0x00000004
#define NV_056_SET_BEGIN_END4_OP_TRIANGLES_ADJ             0x00000005
#define NV_056_SET_BEGIN_END4_OP_TRIANGLE_STRIP_ADJ        0x00000006
#define NV_056_SET_BEGIN_END4_OP_TRIANGLE_FAN_ADJ          0x00000007
#define NV_056_SET_BEGIN_END4_OP_QUADS_ADJ                 0x00000008
#define NV_056_SET_BEGIN_END4_OP_QUAD_STRIP_ADJ            0x00000009
#define NV_056_SET_BEGIN_END4_OP_POLYGON_ADJ               0x0000000A
#define NV_056_SET_BEGIN_END4_MSK                          0xFFFFFFFF 
#define NV_056_INLINE_ARRAY_MSK                            0x00000000 
#define NV_096_HIGH_FIELD                                  0x006C1FFF /* =7086079 */
#define NV_096_LOW_FIELD                                   0x006C0000 /* =7077888 */
#define NV_096_NV12_CELSIUS_PRIMITIVE_ADJ                  0x006C0000
#define NV_096_NV12_CELSIUS_PRIMITIVE_HANDLE_MSK           0xFFFFFFFF /* 31:0 */ 
#define NV_096_NV12_CELSIUS_PRIMITIVE_HANDLE_RMSK          0xFFFFFFFF /* 31:0 */ 
#define NV_096_NV12_CELSIUS_PRIMITIVE_HANDLE_WORD          0
#define NV_096_NV12_CELSIUS_PRIMITIVE_HANDLE_HIGH_FIELD    0x0000001F /* =31 */
#define NV_096_NV12_CELSIUS_PRIMITIVE_HANDLE_LOW_FIELD     0x00000000 /* =0 */
#define NV_096_NV12_CELSIUS_PRIMITIVE_MSK                  0xFFFFFFFF 
#define NV_096_DEBUG_INIT_MSK                              0x00000000 
#define NV_096_FLUSH_MSK                                   0x00000000 
#define NV_096_NO_OPERATION_MSK                            0x00000000 
#define NV_096_NOTIFY_TYPE_MSK                             0xFFFFFFFF /* 31:0 */ 
#define NV_096_NOTIFY_TYPE_RMSK                            0xFFFFFFFF /* 31:0 */ 
#define NV_096_NOTIFY_TYPE_WORD                            0
#define NV_096_NOTIFY_TYPE_HIGH_FIELD                      0x0000001F /* =31 */
#define NV_096_NOTIFY_TYPE_LOW_FIELD                       0x00000000 /* =0 */
#define NV_096_NOTIFY_TYPE_WRITE_ONLY_ADJ                  0x00000000
#define NV_096_NOTIFY_TYPE_WRITE_THEN_AWAKEN_ADJ           0x00000001
#define NV_096_NOTIFY_MSK                                  0xFFFFFFFF 
#define NV_096_SET_WARNING_ENABLE_V_MSK                    0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_WARNING_ENABLE_V_RMSK                   0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_WARNING_ENABLE_V_WORD                   0
#define NV_096_SET_WARNING_ENABLE_V_HIGH_FIELD             0x0000001F /* =31 */
#define NV_096_SET_WARNING_ENABLE_V_LOW_FIELD              0x00000000 /* =0 */
#define NV_096_SET_WARNING_ENABLE_V_FALSE_ADJ              0x00000000
#define NV_096_SET_WARNING_ENABLE_V_TRUE_ADJ               0x00000001
#define NV_096_SET_WARNING_ENABLE_MSK                      0xFFFFFFFF 
#define NV_096_GET_STATE_GETSTATE_MSK                      0xFFFFFFFF /* 31:0 */ 
#define NV_096_GET_STATE_GETSTATE_RMSK                     0xFFFFFFFF /* 31:0 */ 
#define NV_096_GET_STATE_GETSTATE_WORD                     0
#define NV_096_GET_STATE_GETSTATE_HIGH_FIELD               0x0000001F /* =31 */
#define NV_096_GET_STATE_GETSTATE_LOW_FIELD                0x00000000 /* =0 */
#define NV_096_GET_STATE_GETSTATE_ALL_STATE_ADJ            0x00000001
#define NV_096_GET_STATE_GETSTATE_TRANSFORMLIGHTING_STATE_ADJ 0x00000002
#define NV_096_GET_STATE_GETSTATE_RENDERING_STATE_ADJ      0x00000003
#define NV_096_GET_STATE_GETSTATE_GEOMETRY_STATE_ADJ       0x00000004
#define NV_096_GET_STATE_MSK                               0xFFFFFFFF 
#define NV_096_WAIT_FOR_IDLE_MSK                           0x00000000 
#define NV_096_PM_TRIGGER_MSK                              0x00000000 
#define NV_096_SET_CONTEXT_DMA_NOTIFIES_MSK                0x00000000 
#define NV_096_SET_CONTEXT_DMA_A_MSK                       0x00000000 
#define NV_096_SET_CONTEXT_DMA_B_MSK                       0x00000000 
#define NV_096_SET_CONTEXT_DMA_VERTEX_MSK                  0x00000000 
#define NV_096_SET_CONTEXT_DMA_STATE_MSK                   0x00000000 
#define NV_096_SET_CONTEXT_DMA_COLOR_MSK                   0x00000000 
#define NV_096_SET_CONTEXT_DMA_ZETA_MSK                    0x00000000 
#define NV_096_SET_SURFACE_CLIP_HORIZONTAL_X_MSK           0x0000FFFF /* 15:0 */ 
#define NV_096_SET_SURFACE_CLIP_HORIZONTAL_X_RMSK          0x0000FFFF /* 15:0 */ 
#define NV_096_SET_SURFACE_CLIP_HORIZONTAL_X_WORD          0
#define NV_096_SET_SURFACE_CLIP_HORIZONTAL_X_HIGH_FIELD    0x0000000F /* =15 */
#define NV_096_SET_SURFACE_CLIP_HORIZONTAL_X_LOW_FIELD     0x00000000 /* =0 */
#define NV_096_SET_SURFACE_CLIP_HORIZONTAL_WIDTH_MSK       0xFFFF0000 /* 31:16 */ 
#define NV_096_SET_SURFACE_CLIP_HORIZONTAL_WIDTH_RMSK      0x0000FFFF /* 31:16 */ 
#define NV_096_SET_SURFACE_CLIP_HORIZONTAL_WIDTH_WORD      0
#define NV_096_SET_SURFACE_CLIP_HORIZONTAL_WIDTH_HIGH_FIELD 0x0000001F /* =31 */
#define NV_096_SET_SURFACE_CLIP_HORIZONTAL_WIDTH_LOW_FIELD 0x00000010 /* =16 */
#define NV_096_SET_SURFACE_CLIP_HORIZONTAL_MSK             0xFFFFFFFF 
#define NV_096_SET_SURFACE_CLIP_VERTICAL_Y_MSK             0x0000FFFF /* 15:0 */ 
#define NV_096_SET_SURFACE_CLIP_VERTICAL_Y_RMSK            0x0000FFFF /* 15:0 */ 
#define NV_096_SET_SURFACE_CLIP_VERTICAL_Y_WORD            0
#define NV_096_SET_SURFACE_CLIP_VERTICAL_Y_HIGH_FIELD      0x0000000F /* =15 */
#define NV_096_SET_SURFACE_CLIP_VERTICAL_Y_LOW_FIELD       0x00000000 /* =0 */
#define NV_096_SET_SURFACE_CLIP_VERTICAL_HEIGHT_MSK        0xFFFF0000 /* 31:16 */ 
#define NV_096_SET_SURFACE_CLIP_VERTICAL_HEIGHT_RMSK       0x0000FFFF /* 31:16 */ 
#define NV_096_SET_SURFACE_CLIP_VERTICAL_HEIGHT_WORD       0
#define NV_096_SET_SURFACE_CLIP_VERTICAL_HEIGHT_HIGH_FIELD 0x0000001F /* =31 */
#define NV_096_SET_SURFACE_CLIP_VERTICAL_HEIGHT_LOW_FIELD  0x00000010 /* =16 */
#define NV_096_SET_SURFACE_CLIP_VERTICAL_MSK               0xFFFFFFFF 
#define NV_096_SET_SURFACE_FORMAT_COLOR_MSK                0x000000FF /* 7:0 */ 
#define NV_096_SET_SURFACE_FORMAT_COLOR_RMSK               0x000000FF /* 7:0 */ 
#define NV_096_SET_SURFACE_FORMAT_COLOR_WORD               0
#define NV_096_SET_SURFACE_FORMAT_COLOR_HIGH_FIELD         0x00000007 /* =7 */
#define NV_096_SET_SURFACE_FORMAT_COLOR_LOW_FIELD          0x00000000 /* =0 */
#define NV_096_SET_SURFACE_FORMAT_COLOR_LE_X1R5G5B5_Z1R5G5B5_ADJ 0x00000001
#define NV_096_SET_SURFACE_FORMAT_COLOR_LE_X1R5G5B5_O1R5G5B5_ADJ 0x00000002
#define NV_096_SET_SURFACE_FORMAT_COLOR_LE_R5G6B5_ADJ      0x00000003
#define NV_096_SET_SURFACE_FORMAT_COLOR_LE_X8R8G8B8_Z8R8G8B8_ADJ 0x00000004
#define NV_096_SET_SURFACE_FORMAT_COLOR_LE_X8R8G8B8_O8R8G8B8_ADJ 0x00000005
#define NV_096_SET_SURFACE_FORMAT_COLOR_LE_X1A7R8G8B8_Z1A7R8G8B8_ADJ 0x00000006
#define NV_096_SET_SURFACE_FORMAT_COLOR_LE_X1A7R8G8B8_O1A7R8G8B8_ADJ 0x00000007
#define NV_096_SET_SURFACE_FORMAT_COLOR_LE_A8R8G8B8_ADJ    0x00000008
#define NV_096_SET_SURFACE_FORMAT_COLOR_LE_B8_ADJ          0x00000009
#define NV_096_SET_SURFACE_FORMAT_COLOR_LE_G8B8_ADJ        0x0000000A
#define NV_096_SET_SURFACE_FORMAT_TYPE_MSK                 0x0000FF00 /* 15:8 */ 
#define NV_096_SET_SURFACE_FORMAT_TYPE_RMSK                0x000000FF /* 15:8 */ 
#define NV_096_SET_SURFACE_FORMAT_TYPE_WORD                0
#define NV_096_SET_SURFACE_FORMAT_TYPE_HIGH_FIELD          0x0000000F /* =15 */
#define NV_096_SET_SURFACE_FORMAT_TYPE_LOW_FIELD           0x00000008 /* =8 */
#define NV_096_SET_SURFACE_FORMAT_TYPE_PITCH_ADJ           0x00000100
#define NV_096_SET_SURFACE_FORMAT_TYPE_SWIZZLE_ADJ         0x00000200
#define NV_096_SET_SURFACE_FORMAT_WIDTH_MSK                0x00FF0000 /* 23:16 */ 
#define NV_096_SET_SURFACE_FORMAT_WIDTH_RMSK               0x000000FF /* 23:16 */ 
#define NV_096_SET_SURFACE_FORMAT_WIDTH_WORD               0
#define NV_096_SET_SURFACE_FORMAT_WIDTH_HIGH_FIELD         0x00000017 /* =23 */
#define NV_096_SET_SURFACE_FORMAT_WIDTH_LOW_FIELD          0x00000010 /* =16 */
#define NV_096_SET_SURFACE_FORMAT_WIDTH_1_ADJ              0x00000000
#define NV_096_SET_SURFACE_FORMAT_WIDTH_2_ADJ              0x00010000
#define NV_096_SET_SURFACE_FORMAT_WIDTH_4_ADJ              0x00020000
#define NV_096_SET_SURFACE_FORMAT_WIDTH_8_ADJ              0x00030000
#define NV_096_SET_SURFACE_FORMAT_WIDTH_16_ADJ             0x00040000
#define NV_096_SET_SURFACE_FORMAT_WIDTH_32_ADJ             0x00050000
#define NV_096_SET_SURFACE_FORMAT_WIDTH_64_ADJ             0x00060000
#define NV_096_SET_SURFACE_FORMAT_WIDTH_128_ADJ            0x00070000
#define NV_096_SET_SURFACE_FORMAT_WIDTH_256_ADJ            0x00080000
#define NV_096_SET_SURFACE_FORMAT_WIDTH_512_ADJ            0x00090000
#define NV_096_SET_SURFACE_FORMAT_WIDTH_1024_ADJ           0x000A0000
#define NV_096_SET_SURFACE_FORMAT_WIDTH_2048_ADJ           0x000B0000
#define NV_096_SET_SURFACE_FORMAT_HEIGHT_MSK               0xFF000000 /* 31:24 */ 
#define NV_096_SET_SURFACE_FORMAT_HEIGHT_RMSK              0x000000FF /* 31:24 */ 
#define NV_096_SET_SURFACE_FORMAT_HEIGHT_WORD              0
#define NV_096_SET_SURFACE_FORMAT_HEIGHT_HIGH_FIELD        0x0000001F /* =31 */
#define NV_096_SET_SURFACE_FORMAT_HEIGHT_LOW_FIELD         0x00000018 /* =24 */
#define NV_096_SET_SURFACE_FORMAT_HEIGHT_1_ADJ             0x00000000
#define NV_096_SET_SURFACE_FORMAT_HEIGHT_2_ADJ             0x01000000
#define NV_096_SET_SURFACE_FORMAT_HEIGHT_4_ADJ             0x02000000
#define NV_096_SET_SURFACE_FORMAT_HEIGHT_8_ADJ             0x03000000
#define NV_096_SET_SURFACE_FORMAT_HEIGHT_16_ADJ            0x04000000
#define NV_096_SET_SURFACE_FORMAT_HEIGHT_32_ADJ            0x05000000
#define NV_096_SET_SURFACE_FORMAT_HEIGHT_64_ADJ            0x06000000
#define NV_096_SET_SURFACE_FORMAT_HEIGHT_128_ADJ           0x07000000
#define NV_096_SET_SURFACE_FORMAT_HEIGHT_256_ADJ           0x08000000
#define NV_096_SET_SURFACE_FORMAT_HEIGHT_512_ADJ           0x09000000
#define NV_096_SET_SURFACE_FORMAT_HEIGHT_1024_ADJ          0x0A000000
#define NV_096_SET_SURFACE_FORMAT_HEIGHT_2048_ADJ          0x0B000000
#define NV_096_SET_SURFACE_FORMAT_MSK                      0xFFFFFFFF 
#define NV_096_SET_SURFACE_PITCH_COLOR_MSK                 0x0000FFFF /* 15:0 */ 
#define NV_096_SET_SURFACE_PITCH_COLOR_RMSK                0x0000FFFF /* 15:0 */ 
#define NV_096_SET_SURFACE_PITCH_COLOR_WORD                0
#define NV_096_SET_SURFACE_PITCH_COLOR_HIGH_FIELD          0x0000000F /* =15 */
#define NV_096_SET_SURFACE_PITCH_COLOR_LOW_FIELD           0x00000000 /* =0 */
#define NV_096_SET_SURFACE_PITCH_ZETA_MSK                  0xFFFF0000 /* 31:16 */ 
#define NV_096_SET_SURFACE_PITCH_ZETA_RMSK                 0x0000FFFF /* 31:16 */ 
#define NV_096_SET_SURFACE_PITCH_ZETA_WORD                 0
#define NV_096_SET_SURFACE_PITCH_ZETA_HIGH_FIELD           0x0000001F /* =31 */
#define NV_096_SET_SURFACE_PITCH_ZETA_LOW_FIELD            0x00000010 /* =16 */
#define NV_096_SET_SURFACE_PITCH_MSK                       0xFFFFFFFF 
#define NV_096_SET_SURFACE_COLOR_OFFSET_V_MSK              0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_SURFACE_COLOR_OFFSET_V_RMSK             0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_SURFACE_COLOR_OFFSET_V_WORD             0
#define NV_096_SET_SURFACE_COLOR_OFFSET_V_HIGH_FIELD       0x0000001F /* =31 */
#define NV_096_SET_SURFACE_COLOR_OFFSET_V_LOW_FIELD        0x00000000 /* =0 */
#define NV_096_SET_SURFACE_COLOR_OFFSET_MSK                0xFFFFFFFF 
#define NV_096_SET_SURFACE_ZETA_OFFSET_V_MSK               0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_SURFACE_ZETA_OFFSET_V_RMSK              0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_SURFACE_ZETA_OFFSET_V_WORD              0
#define NV_096_SET_SURFACE_ZETA_OFFSET_V_HIGH_FIELD        0x0000001F /* =31 */
#define NV_096_SET_SURFACE_ZETA_OFFSET_V_LOW_FIELD         0x00000000 /* =0 */
#define NV_096_SET_SURFACE_ZETA_OFFSET_MSK                 0xFFFFFFFF 
#define NV_096_SET_TEXTURE_OFFSET_V_MSK                    0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_TEXTURE_OFFSET_V_RMSK                   0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_TEXTURE_OFFSET_V_WORD                   0
#define NV_096_SET_TEXTURE_OFFSET_V_HIGH_FIELD             0x0000001F /* =31 */
#define NV_096_SET_TEXTURE_OFFSET_V_LOW_FIELD              0x00000000 /* =0 */
#define NV_096_SET_TEXTURE_OFFSET_MSK                      0xFFFFFFFF 
#define NV_096_SET_TEXTURE_FORMAT_CONTEXT_DMA_MSK          0x00000003 /* 1:0 */ 
#define NV_096_SET_TEXTURE_FORMAT_CONTEXT_DMA_RMSK         0x00000003 /* 1:0 */ 
#define NV_096_SET_TEXTURE_FORMAT_CONTEXT_DMA_WORD         0
#define NV_096_SET_TEXTURE_FORMAT_CONTEXT_DMA_HIGH_FIELD   0x00000001 /* =1 */
#define NV_096_SET_TEXTURE_FORMAT_CONTEXT_DMA_LOW_FIELD    0x00000000 /* =0 */
#define NV_096_SET_TEXTURE_FORMAT_CONTEXT_DMA_A_ADJ        0x00000001
#define NV_096_SET_TEXTURE_FORMAT_CONTEXT_DMA_B_ADJ        0x00000002
#define NV_096_SET_TEXTURE_FORMAT_CUBEMAP_ENABLE_MSK       0x00000004 /* 2:2 */ 
#define NV_096_SET_TEXTURE_FORMAT_CUBEMAP_ENABLE_RMSK      0x00000001 /* 2:2 */ 
#define NV_096_SET_TEXTURE_FORMAT_CUBEMAP_ENABLE_WORD      0
#define NV_096_SET_TEXTURE_FORMAT_CUBEMAP_ENABLE_HIGH_FIELD 0x00000002 /* =2 */
#define NV_096_SET_TEXTURE_FORMAT_CUBEMAP_ENABLE_LOW_FIELD 0x00000002 /* =2 */
#define NV_096_SET_TEXTURE_FORMAT_CUBEMAP_ENABLE_FALSE_ADJ 0x00000000
#define NV_096_SET_TEXTURE_FORMAT_CUBEMAP_ENABLE_TRUE_ADJ  0x00000004
#define NV_096_SET_TEXTURE_FORMAT_ORIGIN_ZOH_MSK           0x00000018 /* 4:3 */ 
#define NV_096_SET_TEXTURE_FORMAT_ORIGIN_ZOH_RMSK          0x00000003 /* 4:3 */ 
#define NV_096_SET_TEXTURE_FORMAT_ORIGIN_ZOH_WORD          0
#define NV_096_SET_TEXTURE_FORMAT_ORIGIN_ZOH_HIGH_FIELD    0x00000004 /* =4 */
#define NV_096_SET_TEXTURE_FORMAT_ORIGIN_ZOH_LOW_FIELD     0x00000003 /* =3 */
#define NV_096_SET_TEXTURE_FORMAT_ORIGIN_ZOH_CENTER_ADJ    0x00000008
#define NV_096_SET_TEXTURE_FORMAT_ORIGIN_ZOH_CORNER_ADJ    0x00000010
#define NV_096_SET_TEXTURE_FORMAT_ORIGIN_FOH_MSK           0x00000060 /* 6:5 */ 
#define NV_096_SET_TEXTURE_FORMAT_ORIGIN_FOH_RMSK          0x00000003 /* 6:5 */ 
#define NV_096_SET_TEXTURE_FORMAT_ORIGIN_FOH_WORD          0
#define NV_096_SET_TEXTURE_FORMAT_ORIGIN_FOH_HIGH_FIELD    0x00000006 /* =6 */
#define NV_096_SET_TEXTURE_FORMAT_ORIGIN_FOH_LOW_FIELD     0x00000005 /* =5 */
#define NV_096_SET_TEXTURE_FORMAT_ORIGIN_FOH_CENTER_ADJ    0x00000020
#define NV_096_SET_TEXTURE_FORMAT_ORIGIN_FOH_CORNER_ADJ    0x00000040
#define NV_096_SET_TEXTURE_FORMAT_COLOR_MSK                0x00000F80 /* 11:7 */ 
#define NV_096_SET_TEXTURE_FORMAT_COLOR_RMSK               0x0000001F /* 11:7 */ 
#define NV_096_SET_TEXTURE_FORMAT_COLOR_WORD               0
#define NV_096_SET_TEXTURE_FORMAT_COLOR_HIGH_FIELD         0x0000000B /* =11 */
#define NV_096_SET_TEXTURE_FORMAT_COLOR_LOW_FIELD          0x00000007 /* =7 */
#define NV_096_SET_TEXTURE_FORMAT_COLOR_LE_Y8_ADJ          0x00000000
#define NV_096_SET_TEXTURE_FORMAT_COLOR_LE_AY8_ADJ         0x00000080
#define NV_096_SET_TEXTURE_FORMAT_COLOR_LE_A1R5G5B5_ADJ    0x00000100
#define NV_096_SET_TEXTURE_FORMAT_COLOR_LE_X1R5G5B5_ADJ    0x00000180
#define NV_096_SET_TEXTURE_FORMAT_COLOR_LE_A4R4G4B4_ADJ    0x00000200
#define NV_096_SET_TEXTURE_FORMAT_COLOR_LE_R5G6B5_ADJ      0x00000280
#define NV_096_SET_TEXTURE_FORMAT_COLOR_LE_A8R8G8B8_ADJ    0x00000300
#define NV_096_SET_TEXTURE_FORMAT_COLOR_LE_X8R8G8B8_ADJ    0x00000380
#define NV_096_SET_TEXTURE_FORMAT_COLOR_LE_I8_A1R5G5B5_ADJ 0x00000400
#define NV_096_SET_TEXTURE_FORMAT_COLOR_LE_I8_R5G6B5_ADJ   0x00000480
#define NV_096_SET_TEXTURE_FORMAT_COLOR_LE_I8_A4R4G4B4_ADJ 0x00000500
#define NV_096_SET_TEXTURE_FORMAT_COLOR_LE_I8_A8R8G8B8_ADJ 0x00000580
#define NV_096_SET_TEXTURE_FORMAT_COLOR_LE_DXT1_A1R5G5B5_ADJ 0x00000600
#define NV_096_SET_TEXTURE_FORMAT_COLOR_LE_DXT23_A8R8G8B8_ADJ 0x00000700
#define NV_096_SET_TEXTURE_FORMAT_COLOR_LE_DXT45_A8R8G8B8_ADJ 0x00000780
#define NV_096_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_A1R5G5B5_ADJ 0x00000800
#define NV_096_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_R5G6B5_ADJ 0x00000880
#define NV_096_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_A8R8G8B8_ADJ 0x00000900
#define NV_096_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_Y8_ADJ    0x00000980
#define NV_096_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_SY8_ADJ   0x00000A00
#define NV_096_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_X7SY9_ADJ 0x00000A80
#define NV_096_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_R8B8_ADJ  0x00000B00
#define NV_096_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_G8B8_ADJ  0x00000B80
#define NV_096_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_SG8SB8_ADJ 0x00000C00
#define NV_096_SET_TEXTURE_FORMAT_MIPMAP_LEVELS_MSK        0x0000F000 /* 15:12 */ 
#define NV_096_SET_TEXTURE_FORMAT_MIPMAP_LEVELS_RMSK       0x0000000F /* 15:12 */ 
#define NV_096_SET_TEXTURE_FORMAT_MIPMAP_LEVELS_WORD       0
#define NV_096_SET_TEXTURE_FORMAT_MIPMAP_LEVELS_HIGH_FIELD 0x0000000F /* =15 */
#define NV_096_SET_TEXTURE_FORMAT_MIPMAP_LEVELS_LOW_FIELD  0x0000000C /* =12 */
#define NV_096_SET_TEXTURE_FORMAT_BASE_SIZE_U_MSK          0x000F0000 /* 19:16 */ 
#define NV_096_SET_TEXTURE_FORMAT_BASE_SIZE_U_RMSK         0x0000000F /* 19:16 */ 
#define NV_096_SET_TEXTURE_FORMAT_BASE_SIZE_U_WORD         0
#define NV_096_SET_TEXTURE_FORMAT_BASE_SIZE_U_HIGH_FIELD   0x00000013 /* =19 */
#define NV_096_SET_TEXTURE_FORMAT_BASE_SIZE_U_LOW_FIELD    0x00000010 /* =16 */
#define NV_096_SET_TEXTURE_FORMAT_BASE_SIZE_U_1_ADJ        0x00000000
#define NV_096_SET_TEXTURE_FORMAT_BASE_SIZE_U_2_ADJ        0x00010000
#define NV_096_SET_TEXTURE_FORMAT_BASE_SIZE_U_4_ADJ        0x00020000
#define NV_096_SET_TEXTURE_FORMAT_BASE_SIZE_U_8_ADJ        0x00030000
#define NV_096_SET_TEXTURE_FORMAT_BASE_SIZE_U_16_ADJ       0x00040000
#define NV_096_SET_TEXTURE_FORMAT_BASE_SIZE_U_32_ADJ       0x00050000
#define NV_096_SET_TEXTURE_FORMAT_BASE_SIZE_U_64_ADJ       0x00060000
#define NV_096_SET_TEXTURE_FORMAT_BASE_SIZE_U_128_ADJ      0x00070000
#define NV_096_SET_TEXTURE_FORMAT_BASE_SIZE_U_256_ADJ      0x00080000
#define NV_096_SET_TEXTURE_FORMAT_BASE_SIZE_U_512_ADJ      0x00090000
#define NV_096_SET_TEXTURE_FORMAT_BASE_SIZE_U_1024_ADJ     0x000A0000
#define NV_096_SET_TEXTURE_FORMAT_BASE_SIZE_U_2048_ADJ     0x000B0000
#define NV_096_SET_TEXTURE_FORMAT_BASE_SIZE_V_MSK          0x00F00000 /* 23:20 */ 
#define NV_096_SET_TEXTURE_FORMAT_BASE_SIZE_V_RMSK         0x0000000F /* 23:20 */ 
#define NV_096_SET_TEXTURE_FORMAT_BASE_SIZE_V_WORD         0
#define NV_096_SET_TEXTURE_FORMAT_BASE_SIZE_V_HIGH_FIELD   0x00000017 /* =23 */
#define NV_096_SET_TEXTURE_FORMAT_BASE_SIZE_V_LOW_FIELD    0x00000014 /* =20 */
#define NV_096_SET_TEXTURE_FORMAT_BASE_SIZE_V_1_ADJ        0x00000000
#define NV_096_SET_TEXTURE_FORMAT_BASE_SIZE_V_2_ADJ        0x00100000
#define NV_096_SET_TEXTURE_FORMAT_BASE_SIZE_V_4_ADJ        0x00200000
#define NV_096_SET_TEXTURE_FORMAT_BASE_SIZE_V_8_ADJ        0x00300000
#define NV_096_SET_TEXTURE_FORMAT_BASE_SIZE_V_16_ADJ       0x00400000
#define NV_096_SET_TEXTURE_FORMAT_BASE_SIZE_V_32_ADJ       0x00500000
#define NV_096_SET_TEXTURE_FORMAT_BASE_SIZE_V_64_ADJ       0x00600000
#define NV_096_SET_TEXTURE_FORMAT_BASE_SIZE_V_128_ADJ      0x00700000
#define NV_096_SET_TEXTURE_FORMAT_BASE_SIZE_V_256_ADJ      0x00800000
#define NV_096_SET_TEXTURE_FORMAT_BASE_SIZE_V_512_ADJ      0x00900000
#define NV_096_SET_TEXTURE_FORMAT_BASE_SIZE_V_1024_ADJ     0x00A00000
#define NV_096_SET_TEXTURE_FORMAT_BASE_SIZE_V_2048_ADJ     0x00B00000
#define NV_096_SET_TEXTURE_FORMAT_TEXTUREADDRESSU_MSK      0x07000000 /* 26:24 */ 
#define NV_096_SET_TEXTURE_FORMAT_TEXTUREADDRESSU_RMSK     0x00000007 /* 26:24 */ 
#define NV_096_SET_TEXTURE_FORMAT_TEXTUREADDRESSU_WORD     0
#define NV_096_SET_TEXTURE_FORMAT_TEXTUREADDRESSU_HIGH_FIELD 0x0000001A /* =26 */
#define NV_096_SET_TEXTURE_FORMAT_TEXTUREADDRESSU_LOW_FIELD 0x00000018 /* =24 */
#define NV_096_SET_TEXTURE_FORMAT_TEXTUREADDRESSU_WRAP_ADJ 0x01000000
#define NV_096_SET_TEXTURE_FORMAT_TEXTUREADDRESSU_MIRROR_ADJ 0x02000000
#define NV_096_SET_TEXTURE_FORMAT_TEXTUREADDRESSU_CLAMP_ADJ 0x03000000
#define NV_096_SET_TEXTURE_FORMAT_WRAPU_MSK                0x08000000 /* 27:27 */ 
#define NV_096_SET_TEXTURE_FORMAT_WRAPU_RMSK               0x00000001 /* 27:27 */ 
#define NV_096_SET_TEXTURE_FORMAT_WRAPU_WORD               0
#define NV_096_SET_TEXTURE_FORMAT_WRAPU_HIGH_FIELD         0x0000001B /* =27 */
#define NV_096_SET_TEXTURE_FORMAT_WRAPU_LOW_FIELD          0x0000001B /* =27 */
#define NV_096_SET_TEXTURE_FORMAT_WRAPU_FALSE_ADJ          0x00000000
#define NV_096_SET_TEXTURE_FORMAT_WRAPU_TRUE_ADJ           0x08000000
#define NV_096_SET_TEXTURE_FORMAT_TEXTUREADDRESSV_MSK      0x70000000 /* 30:28 */ 
#define NV_096_SET_TEXTURE_FORMAT_TEXTUREADDRESSV_RMSK     0x00000007 /* 30:28 */ 
#define NV_096_SET_TEXTURE_FORMAT_TEXTUREADDRESSV_WORD     0
#define NV_096_SET_TEXTURE_FORMAT_TEXTUREADDRESSV_HIGH_FIELD 0x0000001E /* =30 */
#define NV_096_SET_TEXTURE_FORMAT_TEXTUREADDRESSV_LOW_FIELD 0x0000001C /* =28 */
#define NV_096_SET_TEXTURE_FORMAT_TEXTUREADDRESSV_WRAP_ADJ 0x10000000
#define NV_096_SET_TEXTURE_FORMAT_TEXTUREADDRESSV_MIRROR_ADJ 0x20000000
#define NV_096_SET_TEXTURE_FORMAT_TEXTUREADDRESSV_CLAMP_ADJ 0x30000000
#define NV_096_SET_TEXTURE_FORMAT_WRAPV_MSK                0x80000000 /* 31:31 */ 
#define NV_096_SET_TEXTURE_FORMAT_WRAPV_RMSK               0x00000001 /* 31:31 */ 
#define NV_096_SET_TEXTURE_FORMAT_WRAPV_WORD               0
#define NV_096_SET_TEXTURE_FORMAT_WRAPV_HIGH_FIELD         0x0000001F /* =31 */
#define NV_096_SET_TEXTURE_FORMAT_WRAPV_LOW_FIELD          0x0000001F /* =31 */
#define NV_096_SET_TEXTURE_FORMAT_WRAPV_FALSE_ADJ          0x00000000
#define NV_096_SET_TEXTURE_FORMAT_WRAPV_TRUE_ADJ           0x80000000
#define NV_096_SET_TEXTURE_FORMAT_MSK                      0xFFFFFFFF 
#define NV_096_SET_TEXTURE_CONTROL0_ENABLE_MSK             0x40000000 /* 30:30 */ 
#define NV_096_SET_TEXTURE_CONTROL0_ENABLE_RMSK            0x00000001 /* 30:30 */ 
#define NV_096_SET_TEXTURE_CONTROL0_ENABLE_WORD            0
#define NV_096_SET_TEXTURE_CONTROL0_ENABLE_HIGH_FIELD      0x0000001E /* =30 */
#define NV_096_SET_TEXTURE_CONTROL0_ENABLE_LOW_FIELD       0x0000001E /* =30 */
#define NV_096_SET_TEXTURE_CONTROL0_ENABLE_FALSE_ADJ       0x00000000
#define NV_096_SET_TEXTURE_CONTROL0_ENABLE_TRUE_ADJ        0x40000000
#define NV_096_SET_TEXTURE_CONTROL0_MIN_LOD_CLAMP_MSK      0x3FFC0000 /* 29:18 */ 
#define NV_096_SET_TEXTURE_CONTROL0_MIN_LOD_CLAMP_RMSK     0x00000FFF /* 29:18 */ 
#define NV_096_SET_TEXTURE_CONTROL0_MIN_LOD_CLAMP_WORD     0
#define NV_096_SET_TEXTURE_CONTROL0_MIN_LOD_CLAMP_HIGH_FIELD 0x0000001D /* =29 */
#define NV_096_SET_TEXTURE_CONTROL0_MIN_LOD_CLAMP_LOW_FIELD 0x00000012 /* =18 */
#define NV_096_SET_TEXTURE_CONTROL0_MAX_LOD_CLAMP_MSK      0x0003FFC0 /* 17:6 */ 
#define NV_096_SET_TEXTURE_CONTROL0_MAX_LOD_CLAMP_RMSK     0x00000FFF /* 17:6 */ 
#define NV_096_SET_TEXTURE_CONTROL0_MAX_LOD_CLAMP_WORD     0
#define NV_096_SET_TEXTURE_CONTROL0_MAX_LOD_CLAMP_HIGH_FIELD 0x00000011 /* =17 */
#define NV_096_SET_TEXTURE_CONTROL0_MAX_LOD_CLAMP_LOW_FIELD 0x00000006 /* =6 */
#define NV_096_SET_TEXTURE_CONTROL0_LOG_MAX_ANISO_MSK      0x00000030 /* 5:4 */ 
#define NV_096_SET_TEXTURE_CONTROL0_LOG_MAX_ANISO_RMSK     0x00000003 /* 5:4 */ 
#define NV_096_SET_TEXTURE_CONTROL0_LOG_MAX_ANISO_WORD     0
#define NV_096_SET_TEXTURE_CONTROL0_LOG_MAX_ANISO_HIGH_FIELD 0x00000005 /* =5 */
#define NV_096_SET_TEXTURE_CONTROL0_LOG_MAX_ANISO_LOW_FIELD 0x00000004 /* =4 */
#define NV_096_SET_TEXTURE_CONTROL0_LOG_MAX_ANISO_0_ADJ    0x00000000
#define NV_096_SET_TEXTURE_CONTROL0_LOG_MAX_ANISO_1_ADJ    0x00000010
#define NV_096_SET_TEXTURE_CONTROL0_IMAGE_FIELD_ENABLE_MSK 0x00000008 /* 3:3 */ 
#define NV_096_SET_TEXTURE_CONTROL0_IMAGE_FIELD_ENABLE_RMSK 0x00000001 /* 3:3 */ 
#define NV_096_SET_TEXTURE_CONTROL0_IMAGE_FIELD_ENABLE_WORD 0
#define NV_096_SET_TEXTURE_CONTROL0_IMAGE_FIELD_ENABLE_HIGH_FIELD 0x00000003 /* =3 */
#define NV_096_SET_TEXTURE_CONTROL0_IMAGE_FIELD_ENABLE_LOW_FIELD 0x00000003 /* =3 */
#define NV_096_SET_TEXTURE_CONTROL0_IMAGE_FIELD_ENABLE_FALSE_ADJ 0x00000000
#define NV_096_SET_TEXTURE_CONTROL0_IMAGE_FIELD_ENABLE_TRUE_ADJ 0x00000008
#define NV_096_SET_TEXTURE_CONTROL0_ALPHA_KILL_ENABLE_MSK  0x00000004 /* 2:2 */ 
#define NV_096_SET_TEXTURE_CONTROL0_ALPHA_KILL_ENABLE_RMSK 0x00000001 /* 2:2 */ 
#define NV_096_SET_TEXTURE_CONTROL0_ALPHA_KILL_ENABLE_WORD 0
#define NV_096_SET_TEXTURE_CONTROL0_ALPHA_KILL_ENABLE_HIGH_FIELD 0x00000002 /* =2 */
#define NV_096_SET_TEXTURE_CONTROL0_ALPHA_KILL_ENABLE_LOW_FIELD 0x00000002 /* =2 */
#define NV_096_SET_TEXTURE_CONTROL0_ALPHA_KILL_ENABLE_FALSE_ADJ 0x00000000
#define NV_096_SET_TEXTURE_CONTROL0_ALPHA_KILL_ENABLE_TRUE_ADJ 0x00000004
#define NV_096_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_MSK 0x00000003 /* 1:0 */ 
#define NV_096_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_RMSK 0x00000003 /* 1:0 */ 
#define NV_096_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_WORD 0
#define NV_096_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_HIGH_FIELD 0x00000001 /* =1 */
#define NV_096_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_LOW_FIELD 0x00000000 /* =0 */
#define NV_096_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_FALSE_ADJ 0x00000000
#define NV_096_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_ALPHA_ADJ 0x00000001
#define NV_096_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_RGBA_ADJ 0x00000002
#define NV_096_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_KILL_ADJ 0x00000003
#define NV_096_SET_TEXTURE_CONTROL0_MSK                    0x7FFFFFFF 
#define NV_096_SET_TEXTURE_CONTROL1_IMAGE_PITCH_MSK        0xFFFF0000 /* 31:16 */ 
#define NV_096_SET_TEXTURE_CONTROL1_IMAGE_PITCH_RMSK       0x0000FFFF /* 31:16 */ 
#define NV_096_SET_TEXTURE_CONTROL1_IMAGE_PITCH_WORD       0
#define NV_096_SET_TEXTURE_CONTROL1_IMAGE_PITCH_HIGH_FIELD 0x0000001F /* =31 */
#define NV_096_SET_TEXTURE_CONTROL1_IMAGE_PITCH_LOW_FIELD  0x00000010 /* =16 */
#define NV_096_SET_TEXTURE_CONTROL1_ZERO_MSK               0x0000FFFF /* 15:0 */ 
#define NV_096_SET_TEXTURE_CONTROL1_ZERO_RMSK              0x0000FFFF /* 15:0 */ 
#define NV_096_SET_TEXTURE_CONTROL1_ZERO_WORD              0
#define NV_096_SET_TEXTURE_CONTROL1_ZERO_HIGH_FIELD        0x0000000F /* =15 */
#define NV_096_SET_TEXTURE_CONTROL1_ZERO_LOW_FIELD         0x00000000 /* =0 */
#define NV_096_SET_TEXTURE_CONTROL1_MSK                    0xFFFFFFFF 
#define NV_096_SET_TEXTURE_CONTROL2_PERTURB_DU_MSK         0x00000FFF /* 11:0 */ 
#define NV_096_SET_TEXTURE_CONTROL2_PERTURB_DU_RMSK        0x00000FFF /* 11:0 */ 
#define NV_096_SET_TEXTURE_CONTROL2_PERTURB_DU_WORD        0
#define NV_096_SET_TEXTURE_CONTROL2_PERTURB_DU_HIGH_FIELD  0x0000000B /* =11 */
#define NV_096_SET_TEXTURE_CONTROL2_PERTURB_DU_LOW_FIELD   0x00000000 /* =0 */
#define NV_096_SET_TEXTURE_CONTROL2_PERTURB_DV_MSK         0x00FFF000 /* 23:12 */ 
#define NV_096_SET_TEXTURE_CONTROL2_PERTURB_DV_RMSK        0x00000FFF /* 23:12 */ 
#define NV_096_SET_TEXTURE_CONTROL2_PERTURB_DV_WORD        0
#define NV_096_SET_TEXTURE_CONTROL2_PERTURB_DV_HIGH_FIELD  0x00000017 /* =23 */
#define NV_096_SET_TEXTURE_CONTROL2_PERTURB_DV_LOW_FIELD   0x0000000C /* =12 */
#define NV_096_SET_TEXTURE_CONTROL2_IMAGE_LODF_MSK         0xFF000000 /* 31:24 */ 
#define NV_096_SET_TEXTURE_CONTROL2_IMAGE_LODF_RMSK        0x000000FF /* 31:24 */ 
#define NV_096_SET_TEXTURE_CONTROL2_IMAGE_LODF_WORD        0
#define NV_096_SET_TEXTURE_CONTROL2_IMAGE_LODF_HIGH_FIELD  0x0000001F /* =31 */
#define NV_096_SET_TEXTURE_CONTROL2_IMAGE_LODF_LOW_FIELD   0x00000018 /* =24 */
#define NV_096_SET_TEXTURE_CONTROL2_MSK                    0xFFFFFFFF 
#define NV_096_SET_TEXTURE_IMAGE_RECT_WIDTH_MSK            0xFFFF0000 /* 31:16 */ 
#define NV_096_SET_TEXTURE_IMAGE_RECT_WIDTH_RMSK           0x0000FFFF /* 31:16 */ 
#define NV_096_SET_TEXTURE_IMAGE_RECT_WIDTH_WORD           0
#define NV_096_SET_TEXTURE_IMAGE_RECT_WIDTH_HIGH_FIELD     0x0000001F /* =31 */
#define NV_096_SET_TEXTURE_IMAGE_RECT_WIDTH_LOW_FIELD      0x00000010 /* =16 */
#define NV_096_SET_TEXTURE_IMAGE_RECT_HEIGHT_MSK           0x0000FFFF /* 15:0 */ 
#define NV_096_SET_TEXTURE_IMAGE_RECT_HEIGHT_RMSK          0x0000FFFF /* 15:0 */ 
#define NV_096_SET_TEXTURE_IMAGE_RECT_HEIGHT_WORD          0
#define NV_096_SET_TEXTURE_IMAGE_RECT_HEIGHT_HIGH_FIELD    0x0000000F /* =15 */
#define NV_096_SET_TEXTURE_IMAGE_RECT_HEIGHT_LOW_FIELD     0x00000000 /* =0 */
#define NV_096_SET_TEXTURE_IMAGE_RECT_MSK                  0xFFFFFFFF 
#define NV_096_SET_TEXTURE_FILTER_MIPMAPLODBIAS_MSK        0x00FFFFFF /* 23:0 */ 
#define NV_096_SET_TEXTURE_FILTER_MIPMAPLODBIAS_RMSK       0x00FFFFFF /* 23:0 */ 
#define NV_096_SET_TEXTURE_FILTER_MIPMAPLODBIAS_WORD       0
#define NV_096_SET_TEXTURE_FILTER_MIPMAPLODBIAS_HIGH_FIELD 0x00000017 /* =23 */
#define NV_096_SET_TEXTURE_FILTER_MIPMAPLODBIAS_LOW_FIELD  0x00000000 /* =0 */
#define NV_096_SET_TEXTURE_FILTER_TEXTUREMIN_MSK           0x0F000000 /* 27:24 */ 
#define NV_096_SET_TEXTURE_FILTER_TEXTUREMIN_RMSK          0x0000000F /* 27:24 */ 
#define NV_096_SET_TEXTURE_FILTER_TEXTUREMIN_WORD          0
#define NV_096_SET_TEXTURE_FILTER_TEXTUREMIN_HIGH_FIELD    0x0000001B /* =27 */
#define NV_096_SET_TEXTURE_FILTER_TEXTUREMIN_LOW_FIELD     0x00000018 /* =24 */
#define NV_096_SET_TEXTURE_FILTER_TEXTUREMIN_NEAREST_ADJ   0x01000000
#define NV_096_SET_TEXTURE_FILTER_TEXTUREMIN_LINEAR_ADJ    0x02000000
#define NV_096_SET_TEXTURE_FILTER_TEXTUREMIN_MIPNEAREST_ADJ 0x03000000
#define NV_096_SET_TEXTURE_FILTER_TEXTUREMIN_MIPLINEAR_ADJ 0x04000000
#define NV_096_SET_TEXTURE_FILTER_TEXTUREMIN_LINEARMIPNEAREST_ADJ 0x05000000
#define NV_096_SET_TEXTURE_FILTER_TEXTUREMIN_LINEARMIPLINEAR_ADJ 0x06000000
#define NV_096_SET_TEXTURE_FILTER_TEXTUREMAG_MSK           0xF0000000 /* 31:28 */ 
#define NV_096_SET_TEXTURE_FILTER_TEXTUREMAG_RMSK          0x0000000F /* 31:28 */ 
#define NV_096_SET_TEXTURE_FILTER_TEXTUREMAG_WORD          0
#define NV_096_SET_TEXTURE_FILTER_TEXTUREMAG_HIGH_FIELD    0x0000001F /* =31 */
#define NV_096_SET_TEXTURE_FILTER_TEXTUREMAG_LOW_FIELD     0x0000001C /* =28 */
#define NV_096_SET_TEXTURE_FILTER_TEXTUREMAG_NEAREST_ADJ   0x10000000
#define NV_096_SET_TEXTURE_FILTER_TEXTUREMAG_LINEAR_ADJ    0x20000000
#define NV_096_SET_TEXTURE_FILTER_MSK                      0xFFFFFFFF 
#define NV_096_SET_TEXTURE_PALETTE_CONTEXT_DMA_MSK         0x0000003F /* 5:0 */ 
#define NV_096_SET_TEXTURE_PALETTE_CONTEXT_DMA_RMSK        0x0000003F /* 5:0 */ 
#define NV_096_SET_TEXTURE_PALETTE_CONTEXT_DMA_WORD        0
#define NV_096_SET_TEXTURE_PALETTE_CONTEXT_DMA_HIGH_FIELD  0x00000005 /* =5 */
#define NV_096_SET_TEXTURE_PALETTE_CONTEXT_DMA_LOW_FIELD   0x00000000 /* =0 */
#define NV_096_SET_TEXTURE_PALETTE_CONTEXT_DMA_A_ADJ       0x00000000
#define NV_096_SET_TEXTURE_PALETTE_CONTEXT_DMA_B_ADJ       0x00000001
#define NV_096_SET_TEXTURE_PALETTE_PALETTE_OFFSET_MSK      0xFFFFFFC0 /* 31:6 */ 
#define NV_096_SET_TEXTURE_PALETTE_PALETTE_OFFSET_RMSK     0x03FFFFFF /* 31:6 */ 
#define NV_096_SET_TEXTURE_PALETTE_PALETTE_OFFSET_WORD     0
#define NV_096_SET_TEXTURE_PALETTE_PALETTE_OFFSET_HIGH_FIELD 0x0000001F /* =31 */
#define NV_096_SET_TEXTURE_PALETTE_PALETTE_OFFSET_LOW_FIELD 0x00000006 /* =6 */
#define NV_096_SET_TEXTURE_PALETTE_MSK                     0xFFFFFFFF 
#define NV_096_SET_COMBINER_ALPHA_ICW_A_MAP_MSK            0xE0000000 /* 31:29 */ 
#define NV_096_SET_COMBINER_ALPHA_ICW_A_MAP_RMSK           0x00000007 /* 31:29 */ 
#define NV_096_SET_COMBINER_ALPHA_ICW_A_MAP_WORD           0
#define NV_096_SET_COMBINER_ALPHA_ICW_A_MAP_HIGH_FIELD     0x0000001F /* =31 */
#define NV_096_SET_COMBINER_ALPHA_ICW_A_MAP_LOW_FIELD      0x0000001D /* =29 */
#define NV_096_SET_COMBINER_ALPHA_ICW_A_MAP_UNSIGNED_IDENTITY_ADJ 0x00000000
#define NV_096_SET_COMBINER_ALPHA_ICW_A_MAP_UNSIGNED_INVERT_ADJ 0x20000000
#define NV_096_SET_COMBINER_ALPHA_ICW_A_MAP_EXPAND_NORMAL_ADJ 0x40000000
#define NV_096_SET_COMBINER_ALPHA_ICW_A_MAP_EXPAND_NEGATE_ADJ 0x60000000
#define NV_096_SET_COMBINER_ALPHA_ICW_A_MAP_HALFBIAS_NORMAL_ADJ 0x80000000
#define NV_096_SET_COMBINER_ALPHA_ICW_A_MAP_HALFBIAS_NEGATE_ADJ 0xA0000000
#define NV_096_SET_COMBINER_ALPHA_ICW_A_MAP_SIGNED_IDENTITY_ADJ 0xC0000000
#define NV_096_SET_COMBINER_ALPHA_ICW_A_MAP_SIGNED_NEGATE_ADJ 0xE0000000
#define NV_096_SET_COMBINER_ALPHA_ICW_A_ALPHA_MSK          0x10000000 /* 28:28 */ 
#define NV_096_SET_COMBINER_ALPHA_ICW_A_ALPHA_RMSK         0x00000001 /* 28:28 */ 
#define NV_096_SET_COMBINER_ALPHA_ICW_A_ALPHA_WORD         0
#define NV_096_SET_COMBINER_ALPHA_ICW_A_ALPHA_HIGH_FIELD   0x0000001C /* =28 */
#define NV_096_SET_COMBINER_ALPHA_ICW_A_ALPHA_LOW_FIELD    0x0000001C /* =28 */
#define NV_096_SET_COMBINER_ALPHA_ICW_A_ALPHA_FALSE_ADJ    0x00000000
#define NV_096_SET_COMBINER_ALPHA_ICW_A_ALPHA_TRUE_ADJ     0x10000000
#define NV_096_SET_COMBINER_ALPHA_ICW_A_SOURCE_MSK         0x0F000000 /* 27:24 */ 
#define NV_096_SET_COMBINER_ALPHA_ICW_A_SOURCE_RMSK        0x0000000F /* 27:24 */ 
#define NV_096_SET_COMBINER_ALPHA_ICW_A_SOURCE_WORD        0
#define NV_096_SET_COMBINER_ALPHA_ICW_A_SOURCE_HIGH_FIELD  0x0000001B /* =27 */
#define NV_096_SET_COMBINER_ALPHA_ICW_A_SOURCE_LOW_FIELD   0x00000018 /* =24 */
#define NV_096_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_0_ADJ   0x00000000
#define NV_096_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_1_ADJ   0x01000000
#define NV_096_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_2_ADJ   0x02000000
#define NV_096_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_3_ADJ   0x03000000
#define NV_096_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_4_ADJ   0x04000000
#define NV_096_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_5_ADJ   0x05000000
#define NV_096_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_8_ADJ   0x08000000
#define NV_096_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_9_ADJ   0x09000000
#define NV_096_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_C_ADJ   0x0C000000
#define NV_096_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_D_ADJ   0x0D000000
#define NV_096_SET_COMBINER_ALPHA_ICW_B_MAP_MSK            0x00E00000 /* 23:21 */ 
#define NV_096_SET_COMBINER_ALPHA_ICW_B_MAP_RMSK           0x00000007 /* 23:21 */ 
#define NV_096_SET_COMBINER_ALPHA_ICW_B_MAP_WORD           0
#define NV_096_SET_COMBINER_ALPHA_ICW_B_MAP_HIGH_FIELD     0x00000017 /* =23 */
#define NV_096_SET_COMBINER_ALPHA_ICW_B_MAP_LOW_FIELD      0x00000015 /* =21 */
#define NV_096_SET_COMBINER_ALPHA_ICW_B_MAP_UNSIGNED_IDENTITY_ADJ 0x00000000
#define NV_096_SET_COMBINER_ALPHA_ICW_B_MAP_UNSIGNED_INVERT_ADJ 0x00200000
#define NV_096_SET_COMBINER_ALPHA_ICW_B_MAP_EXPAND_NORMAL_ADJ 0x00400000
#define NV_096_SET_COMBINER_ALPHA_ICW_B_MAP_EXPAND_NEGATE_ADJ 0x00600000
#define NV_096_SET_COMBINER_ALPHA_ICW_B_MAP_HALFBIAS_NORMAL_ADJ 0x00800000
#define NV_096_SET_COMBINER_ALPHA_ICW_B_MAP_HALFBIAS_NEGATE_ADJ 0x00A00000
#define NV_096_SET_COMBINER_ALPHA_ICW_B_MAP_SIGNED_IDENTITY_ADJ 0x00C00000
#define NV_096_SET_COMBINER_ALPHA_ICW_B_MAP_SIGNED_NEGATE_ADJ 0x00E00000
#define NV_096_SET_COMBINER_ALPHA_ICW_B_ALPHA_MSK          0x00100000 /* 20:20 */ 
#define NV_096_SET_COMBINER_ALPHA_ICW_B_ALPHA_RMSK         0x00000001 /* 20:20 */ 
#define NV_096_SET_COMBINER_ALPHA_ICW_B_ALPHA_WORD         0
#define NV_096_SET_COMBINER_ALPHA_ICW_B_ALPHA_HIGH_FIELD   0x00000014 /* =20 */
#define NV_096_SET_COMBINER_ALPHA_ICW_B_ALPHA_LOW_FIELD    0x00000014 /* =20 */
#define NV_096_SET_COMBINER_ALPHA_ICW_B_ALPHA_FALSE_ADJ    0x00000000
#define NV_096_SET_COMBINER_ALPHA_ICW_B_ALPHA_TRUE_ADJ     0x00100000
#define NV_096_SET_COMBINER_ALPHA_ICW_B_SOURCE_MSK         0x000F0000 /* 19:16 */ 
#define NV_096_SET_COMBINER_ALPHA_ICW_B_SOURCE_RMSK        0x0000000F /* 19:16 */ 
#define NV_096_SET_COMBINER_ALPHA_ICW_B_SOURCE_WORD        0
#define NV_096_SET_COMBINER_ALPHA_ICW_B_SOURCE_HIGH_FIELD  0x00000013 /* =19 */
#define NV_096_SET_COMBINER_ALPHA_ICW_B_SOURCE_LOW_FIELD   0x00000010 /* =16 */
#define NV_096_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_0_ADJ   0x00000000
#define NV_096_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_1_ADJ   0x00010000
#define NV_096_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_2_ADJ   0x00020000
#define NV_096_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_3_ADJ   0x00030000
#define NV_096_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_4_ADJ   0x00040000
#define NV_096_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_5_ADJ   0x00050000
#define NV_096_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_8_ADJ   0x00080000
#define NV_096_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_9_ADJ   0x00090000
#define NV_096_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_C_ADJ   0x000C0000
#define NV_096_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_D_ADJ   0x000D0000
#define NV_096_SET_COMBINER_ALPHA_ICW_C_MAP_MSK            0x0000E000 /* 15:13 */ 
#define NV_096_SET_COMBINER_ALPHA_ICW_C_MAP_RMSK           0x00000007 /* 15:13 */ 
#define NV_096_SET_COMBINER_ALPHA_ICW_C_MAP_WORD           0
#define NV_096_SET_COMBINER_ALPHA_ICW_C_MAP_HIGH_FIELD     0x0000000F /* =15 */
#define NV_096_SET_COMBINER_ALPHA_ICW_C_MAP_LOW_FIELD      0x0000000D /* =13 */
#define NV_096_SET_COMBINER_ALPHA_ICW_C_MAP_UNSIGNED_IDENTITY_ADJ 0x00000000
#define NV_096_SET_COMBINER_ALPHA_ICW_C_MAP_UNSIGNED_INVERT_ADJ 0x00002000
#define NV_096_SET_COMBINER_ALPHA_ICW_C_MAP_EXPAND_NORMAL_ADJ 0x00004000
#define NV_096_SET_COMBINER_ALPHA_ICW_C_MAP_EXPAND_NEGATE_ADJ 0x00006000
#define NV_096_SET_COMBINER_ALPHA_ICW_C_MAP_HALFBIAS_NORMAL_ADJ 0x00008000
#define NV_096_SET_COMBINER_ALPHA_ICW_C_MAP_HALFBIAS_NEGATE_ADJ 0x0000A000
#define NV_096_SET_COMBINER_ALPHA_ICW_C_MAP_SIGNED_IDENTITY_ADJ 0x0000C000
#define NV_096_SET_COMBINER_ALPHA_ICW_C_MAP_SIGNED_NEGATE_ADJ 0x0000E000
#define NV_096_SET_COMBINER_ALPHA_ICW_C_ALPHA_MSK          0x00001000 /* 12:12 */ 
#define NV_096_SET_COMBINER_ALPHA_ICW_C_ALPHA_RMSK         0x00000001 /* 12:12 */ 
#define NV_096_SET_COMBINER_ALPHA_ICW_C_ALPHA_WORD         0
#define NV_096_SET_COMBINER_ALPHA_ICW_C_ALPHA_HIGH_FIELD   0x0000000C /* =12 */
#define NV_096_SET_COMBINER_ALPHA_ICW_C_ALPHA_LOW_FIELD    0x0000000C /* =12 */
#define NV_096_SET_COMBINER_ALPHA_ICW_C_ALPHA_FALSE_ADJ    0x00000000
#define NV_096_SET_COMBINER_ALPHA_ICW_C_ALPHA_TRUE_ADJ     0x00001000
#define NV_096_SET_COMBINER_ALPHA_ICW_C_SOURCE_MSK         0x00000F00 /* 11:8 */ 
#define NV_096_SET_COMBINER_ALPHA_ICW_C_SOURCE_RMSK        0x0000000F /* 11:8 */ 
#define NV_096_SET_COMBINER_ALPHA_ICW_C_SOURCE_WORD        0
#define NV_096_SET_COMBINER_ALPHA_ICW_C_SOURCE_HIGH_FIELD  0x0000000B /* =11 */
#define NV_096_SET_COMBINER_ALPHA_ICW_C_SOURCE_LOW_FIELD   0x00000008 /* =8 */
#define NV_096_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_0_ADJ   0x00000000
#define NV_096_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_1_ADJ   0x00000100
#define NV_096_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_2_ADJ   0x00000200
#define NV_096_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_3_ADJ   0x00000300
#define NV_096_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_4_ADJ   0x00000400
#define NV_096_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_5_ADJ   0x00000500
#define NV_096_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_8_ADJ   0x00000800
#define NV_096_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_9_ADJ   0x00000900
#define NV_096_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_C_ADJ   0x00000C00
#define NV_096_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_D_ADJ   0x00000D00
#define NV_096_SET_COMBINER_ALPHA_ICW_D_MAP_MSK            0x000000E0 /* 7:5 */ 
#define NV_096_SET_COMBINER_ALPHA_ICW_D_MAP_RMSK           0x00000007 /* 7:5 */ 
#define NV_096_SET_COMBINER_ALPHA_ICW_D_MAP_WORD           0
#define NV_096_SET_COMBINER_ALPHA_ICW_D_MAP_HIGH_FIELD     0x00000007 /* =7 */
#define NV_096_SET_COMBINER_ALPHA_ICW_D_MAP_LOW_FIELD      0x00000005 /* =5 */
#define NV_096_SET_COMBINER_ALPHA_ICW_D_MAP_UNSIGNED_IDENTITY_ADJ 0x00000000
#define NV_096_SET_COMBINER_ALPHA_ICW_D_MAP_UNSIGNED_INVERT_ADJ 0x00000020
#define NV_096_SET_COMBINER_ALPHA_ICW_D_MAP_EXPAND_NORMAL_ADJ 0x00000040
#define NV_096_SET_COMBINER_ALPHA_ICW_D_MAP_EXPAND_NEGATE_ADJ 0x00000060
#define NV_096_SET_COMBINER_ALPHA_ICW_D_MAP_HALFBIAS_NORMAL_ADJ 0x00000080
#define NV_096_SET_COMBINER_ALPHA_ICW_D_MAP_HALFBIAS_NEGATE_ADJ 0x000000A0
#define NV_096_SET_COMBINER_ALPHA_ICW_D_MAP_SIGNED_IDENTITY_ADJ 0x000000C0
#define NV_096_SET_COMBINER_ALPHA_ICW_D_MAP_SIGNED_NEGATE_ADJ 0x000000E0
#define NV_096_SET_COMBINER_ALPHA_ICW_D_ALPHA_MSK          0x00000010 /* 4:4 */ 
#define NV_096_SET_COMBINER_ALPHA_ICW_D_ALPHA_RMSK         0x00000001 /* 4:4 */ 
#define NV_096_SET_COMBINER_ALPHA_ICW_D_ALPHA_WORD         0
#define NV_096_SET_COMBINER_ALPHA_ICW_D_ALPHA_HIGH_FIELD   0x00000004 /* =4 */
#define NV_096_SET_COMBINER_ALPHA_ICW_D_ALPHA_LOW_FIELD    0x00000004 /* =4 */
#define NV_096_SET_COMBINER_ALPHA_ICW_D_ALPHA_FALSE_ADJ    0x00000000
#define NV_096_SET_COMBINER_ALPHA_ICW_D_ALPHA_TRUE_ADJ     0x00000010
#define NV_096_SET_COMBINER_ALPHA_ICW_D_SOURCE_MSK         0x0000000F /* 3:0 */ 
#define NV_096_SET_COMBINER_ALPHA_ICW_D_SOURCE_RMSK        0x0000000F /* 3:0 */ 
#define NV_096_SET_COMBINER_ALPHA_ICW_D_SOURCE_WORD        0
#define NV_096_SET_COMBINER_ALPHA_ICW_D_SOURCE_HIGH_FIELD  0x00000003 /* =3 */
#define NV_096_SET_COMBINER_ALPHA_ICW_D_SOURCE_LOW_FIELD   0x00000000 /* =0 */
#define NV_096_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_0_ADJ   0x00000000
#define NV_096_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_1_ADJ   0x00000001
#define NV_096_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_2_ADJ   0x00000002
#define NV_096_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_3_ADJ   0x00000003
#define NV_096_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_4_ADJ   0x00000004
#define NV_096_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_5_ADJ   0x00000005
#define NV_096_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_8_ADJ   0x00000008
#define NV_096_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_9_ADJ   0x00000009
#define NV_096_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_C_ADJ   0x0000000C
#define NV_096_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_D_ADJ   0x0000000D
#define NV_096_SET_COMBINER_ALPHA_ICW_MSK                  0xFFFFFFFF 
#define NV_096_SET_COMBINER_COLOR_ICW_A_MAP_MSK            0xE0000000 /* 31:29 */ 
#define NV_096_SET_COMBINER_COLOR_ICW_A_MAP_RMSK           0x00000007 /* 31:29 */ 
#define NV_096_SET_COMBINER_COLOR_ICW_A_MAP_WORD           0
#define NV_096_SET_COMBINER_COLOR_ICW_A_MAP_HIGH_FIELD     0x0000001F /* =31 */
#define NV_096_SET_COMBINER_COLOR_ICW_A_MAP_LOW_FIELD      0x0000001D /* =29 */
#define NV_096_SET_COMBINER_COLOR_ICW_A_MAP_UNSIGNED_IDENTITY_ADJ 0x00000000
#define NV_096_SET_COMBINER_COLOR_ICW_A_MAP_UNSIGNED_INVERT_ADJ 0x20000000
#define NV_096_SET_COMBINER_COLOR_ICW_A_MAP_EXPAND_NORMAL_ADJ 0x40000000
#define NV_096_SET_COMBINER_COLOR_ICW_A_MAP_EXPAND_NEGATE_ADJ 0x60000000
#define NV_096_SET_COMBINER_COLOR_ICW_A_MAP_HALFBIAS_NORMAL_ADJ 0x80000000
#define NV_096_SET_COMBINER_COLOR_ICW_A_MAP_HALFBIAS_NEGATE_ADJ 0xA0000000
#define NV_096_SET_COMBINER_COLOR_ICW_A_MAP_SIGNED_IDENTITY_ADJ 0xC0000000
#define NV_096_SET_COMBINER_COLOR_ICW_A_MAP_SIGNED_NEGATE_ADJ 0xE0000000
#define NV_096_SET_COMBINER_COLOR_ICW_A_ALPHA_MSK          0x10000000 /* 28:28 */ 
#define NV_096_SET_COMBINER_COLOR_ICW_A_ALPHA_RMSK         0x00000001 /* 28:28 */ 
#define NV_096_SET_COMBINER_COLOR_ICW_A_ALPHA_WORD         0
#define NV_096_SET_COMBINER_COLOR_ICW_A_ALPHA_HIGH_FIELD   0x0000001C /* =28 */
#define NV_096_SET_COMBINER_COLOR_ICW_A_ALPHA_LOW_FIELD    0x0000001C /* =28 */
#define NV_096_SET_COMBINER_COLOR_ICW_A_ALPHA_FALSE_ADJ    0x00000000
#define NV_096_SET_COMBINER_COLOR_ICW_A_ALPHA_TRUE_ADJ     0x10000000
#define NV_096_SET_COMBINER_COLOR_ICW_A_SOURCE_MSK         0x0F000000 /* 27:24 */ 
#define NV_096_SET_COMBINER_COLOR_ICW_A_SOURCE_RMSK        0x0000000F /* 27:24 */ 
#define NV_096_SET_COMBINER_COLOR_ICW_A_SOURCE_WORD        0
#define NV_096_SET_COMBINER_COLOR_ICW_A_SOURCE_HIGH_FIELD  0x0000001B /* =27 */
#define NV_096_SET_COMBINER_COLOR_ICW_A_SOURCE_LOW_FIELD   0x00000018 /* =24 */
#define NV_096_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_0_ADJ   0x00000000
#define NV_096_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_1_ADJ   0x01000000
#define NV_096_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_2_ADJ   0x02000000
#define NV_096_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_3_ADJ   0x03000000
#define NV_096_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_4_ADJ   0x04000000
#define NV_096_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_5_ADJ   0x05000000
#define NV_096_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_8_ADJ   0x08000000
#define NV_096_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_9_ADJ   0x09000000
#define NV_096_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_C_ADJ   0x0C000000
#define NV_096_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_D_ADJ   0x0D000000
#define NV_096_SET_COMBINER_COLOR_ICW_B_MAP_MSK            0x00E00000 /* 23:21 */ 
#define NV_096_SET_COMBINER_COLOR_ICW_B_MAP_RMSK           0x00000007 /* 23:21 */ 
#define NV_096_SET_COMBINER_COLOR_ICW_B_MAP_WORD           0
#define NV_096_SET_COMBINER_COLOR_ICW_B_MAP_HIGH_FIELD     0x00000017 /* =23 */
#define NV_096_SET_COMBINER_COLOR_ICW_B_MAP_LOW_FIELD      0x00000015 /* =21 */
#define NV_096_SET_COMBINER_COLOR_ICW_B_MAP_UNSIGNED_IDENTITY_ADJ 0x00000000
#define NV_096_SET_COMBINER_COLOR_ICW_B_MAP_UNSIGNED_INVERT_ADJ 0x00200000
#define NV_096_SET_COMBINER_COLOR_ICW_B_MAP_EXPAND_NORMAL_ADJ 0x00400000
#define NV_096_SET_COMBINER_COLOR_ICW_B_MAP_EXPAND_NEGATE_ADJ 0x00600000
#define NV_096_SET_COMBINER_COLOR_ICW_B_MAP_HALFBIAS_NORMAL_ADJ 0x00800000
#define NV_096_SET_COMBINER_COLOR_ICW_B_MAP_HALFBIAS_NEGATE_ADJ 0x00A00000
#define NV_096_SET_COMBINER_COLOR_ICW_B_MAP_SIGNED_IDENTITY_ADJ 0x00C00000
#define NV_096_SET_COMBINER_COLOR_ICW_B_MAP_SIGNED_NEGATE_ADJ 0x00E00000
#define NV_096_SET_COMBINER_COLOR_ICW_B_ALPHA_MSK          0x00100000 /* 20:20 */ 
#define NV_096_SET_COMBINER_COLOR_ICW_B_ALPHA_RMSK         0x00000001 /* 20:20 */ 
#define NV_096_SET_COMBINER_COLOR_ICW_B_ALPHA_WORD         0
#define NV_096_SET_COMBINER_COLOR_ICW_B_ALPHA_HIGH_FIELD   0x00000014 /* =20 */
#define NV_096_SET_COMBINER_COLOR_ICW_B_ALPHA_LOW_FIELD    0x00000014 /* =20 */
#define NV_096_SET_COMBINER_COLOR_ICW_B_ALPHA_FALSE_ADJ    0x00000000
#define NV_096_SET_COMBINER_COLOR_ICW_B_ALPHA_TRUE_ADJ     0x00100000
#define NV_096_SET_COMBINER_COLOR_ICW_B_SOURCE_MSK         0x000F0000 /* 19:16 */ 
#define NV_096_SET_COMBINER_COLOR_ICW_B_SOURCE_RMSK        0x0000000F /* 19:16 */ 
#define NV_096_SET_COMBINER_COLOR_ICW_B_SOURCE_WORD        0
#define NV_096_SET_COMBINER_COLOR_ICW_B_SOURCE_HIGH_FIELD  0x00000013 /* =19 */
#define NV_096_SET_COMBINER_COLOR_ICW_B_SOURCE_LOW_FIELD   0x00000010 /* =16 */
#define NV_096_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_0_ADJ   0x00000000
#define NV_096_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_1_ADJ   0x00010000
#define NV_096_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_2_ADJ   0x00020000
#define NV_096_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_3_ADJ   0x00030000
#define NV_096_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_4_ADJ   0x00040000
#define NV_096_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_5_ADJ   0x00050000
#define NV_096_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_8_ADJ   0x00080000
#define NV_096_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_9_ADJ   0x00090000
#define NV_096_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_C_ADJ   0x000C0000
#define NV_096_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_D_ADJ   0x000D0000
#define NV_096_SET_COMBINER_COLOR_ICW_C_MAP_MSK            0x0000E000 /* 15:13 */ 
#define NV_096_SET_COMBINER_COLOR_ICW_C_MAP_RMSK           0x00000007 /* 15:13 */ 
#define NV_096_SET_COMBINER_COLOR_ICW_C_MAP_WORD           0
#define NV_096_SET_COMBINER_COLOR_ICW_C_MAP_HIGH_FIELD     0x0000000F /* =15 */
#define NV_096_SET_COMBINER_COLOR_ICW_C_MAP_LOW_FIELD      0x0000000D /* =13 */
#define NV_096_SET_COMBINER_COLOR_ICW_C_MAP_UNSIGNED_IDENTITY_ADJ 0x00000000
#define NV_096_SET_COMBINER_COLOR_ICW_C_MAP_UNSIGNED_INVERT_ADJ 0x00002000
#define NV_096_SET_COMBINER_COLOR_ICW_C_MAP_EXPAND_NORMAL_ADJ 0x00004000
#define NV_096_SET_COMBINER_COLOR_ICW_C_MAP_EXPAND_NEGATE_ADJ 0x00006000
#define NV_096_SET_COMBINER_COLOR_ICW_C_MAP_HALFBIAS_NORMAL_ADJ 0x00008000
#define NV_096_SET_COMBINER_COLOR_ICW_C_MAP_HALFBIAS_NEGATE_ADJ 0x0000A000
#define NV_096_SET_COMBINER_COLOR_ICW_C_MAP_SIGNED_IDENTITY_ADJ 0x0000C000
#define NV_096_SET_COMBINER_COLOR_ICW_C_MAP_SIGNED_NEGATE_ADJ 0x0000E000
#define NV_096_SET_COMBINER_COLOR_ICW_C_ALPHA_MSK          0x00001000 /* 12:12 */ 
#define NV_096_SET_COMBINER_COLOR_ICW_C_ALPHA_RMSK         0x00000001 /* 12:12 */ 
#define NV_096_SET_COMBINER_COLOR_ICW_C_ALPHA_WORD         0
#define NV_096_SET_COMBINER_COLOR_ICW_C_ALPHA_HIGH_FIELD   0x0000000C /* =12 */
#define NV_096_SET_COMBINER_COLOR_ICW_C_ALPHA_LOW_FIELD    0x0000000C /* =12 */
#define NV_096_SET_COMBINER_COLOR_ICW_C_ALPHA_FALSE_ADJ    0x00000000
#define NV_096_SET_COMBINER_COLOR_ICW_C_ALPHA_TRUE_ADJ     0x00001000
#define NV_096_SET_COMBINER_COLOR_ICW_C_SOURCE_MSK         0x00000F00 /* 11:8 */ 
#define NV_096_SET_COMBINER_COLOR_ICW_C_SOURCE_RMSK        0x0000000F /* 11:8 */ 
#define NV_096_SET_COMBINER_COLOR_ICW_C_SOURCE_WORD        0
#define NV_096_SET_COMBINER_COLOR_ICW_C_SOURCE_HIGH_FIELD  0x0000000B /* =11 */
#define NV_096_SET_COMBINER_COLOR_ICW_C_SOURCE_LOW_FIELD   0x00000008 /* =8 */
#define NV_096_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_0_ADJ   0x00000000
#define NV_096_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_1_ADJ   0x00000100
#define NV_096_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_2_ADJ   0x00000200
#define NV_096_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_3_ADJ   0x00000300
#define NV_096_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_4_ADJ   0x00000400
#define NV_096_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_5_ADJ   0x00000500
#define NV_096_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_8_ADJ   0x00000800
#define NV_096_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_9_ADJ   0x00000900
#define NV_096_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_C_ADJ   0x00000C00
#define NV_096_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_D_ADJ   0x00000D00
#define NV_096_SET_COMBINER_COLOR_ICW_D_MAP_MSK            0x000000E0 /* 7:5 */ 
#define NV_096_SET_COMBINER_COLOR_ICW_D_MAP_RMSK           0x00000007 /* 7:5 */ 
#define NV_096_SET_COMBINER_COLOR_ICW_D_MAP_WORD           0
#define NV_096_SET_COMBINER_COLOR_ICW_D_MAP_HIGH_FIELD     0x00000007 /* =7 */
#define NV_096_SET_COMBINER_COLOR_ICW_D_MAP_LOW_FIELD      0x00000005 /* =5 */
#define NV_096_SET_COMBINER_COLOR_ICW_D_MAP_UNSIGNED_IDENTITY_ADJ 0x00000000
#define NV_096_SET_COMBINER_COLOR_ICW_D_MAP_UNSIGNED_INVERT_ADJ 0x00000020
#define NV_096_SET_COMBINER_COLOR_ICW_D_MAP_EXPAND_NORMAL_ADJ 0x00000040
#define NV_096_SET_COMBINER_COLOR_ICW_D_MAP_EXPAND_NEGATE_ADJ 0x00000060
#define NV_096_SET_COMBINER_COLOR_ICW_D_MAP_HALFBIAS_NORMAL_ADJ 0x00000080
#define NV_096_SET_COMBINER_COLOR_ICW_D_MAP_HALFBIAS_NEGATE_ADJ 0x000000A0
#define NV_096_SET_COMBINER_COLOR_ICW_D_MAP_SIGNED_IDENTITY_ADJ 0x000000C0
#define NV_096_SET_COMBINER_COLOR_ICW_D_MAP_SIGNED_NEGATE_ADJ 0x000000E0
#define NV_096_SET_COMBINER_COLOR_ICW_D_ALPHA_MSK          0x00000010 /* 4:4 */ 
#define NV_096_SET_COMBINER_COLOR_ICW_D_ALPHA_RMSK         0x00000001 /* 4:4 */ 
#define NV_096_SET_COMBINER_COLOR_ICW_D_ALPHA_WORD         0
#define NV_096_SET_COMBINER_COLOR_ICW_D_ALPHA_HIGH_FIELD   0x00000004 /* =4 */
#define NV_096_SET_COMBINER_COLOR_ICW_D_ALPHA_LOW_FIELD    0x00000004 /* =4 */
#define NV_096_SET_COMBINER_COLOR_ICW_D_ALPHA_FALSE_ADJ    0x00000000
#define NV_096_SET_COMBINER_COLOR_ICW_D_ALPHA_TRUE_ADJ     0x00000010
#define NV_096_SET_COMBINER_COLOR_ICW_D_SOURCE_MSK         0x0000000F /* 3:0 */ 
#define NV_096_SET_COMBINER_COLOR_ICW_D_SOURCE_RMSK        0x0000000F /* 3:0 */ 
#define NV_096_SET_COMBINER_COLOR_ICW_D_SOURCE_WORD        0
#define NV_096_SET_COMBINER_COLOR_ICW_D_SOURCE_HIGH_FIELD  0x00000003 /* =3 */
#define NV_096_SET_COMBINER_COLOR_ICW_D_SOURCE_LOW_FIELD   0x00000000 /* =0 */
#define NV_096_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_0_ADJ   0x00000000
#define NV_096_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_1_ADJ   0x00000001
#define NV_096_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_2_ADJ   0x00000002
#define NV_096_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_3_ADJ   0x00000003
#define NV_096_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_4_ADJ   0x00000004
#define NV_096_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_5_ADJ   0x00000005
#define NV_096_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_8_ADJ   0x00000008
#define NV_096_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_9_ADJ   0x00000009
#define NV_096_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_C_ADJ   0x0000000C
#define NV_096_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_D_ADJ   0x0000000D
#define NV_096_SET_COMBINER_COLOR_ICW_MSK                  0xFFFFFFFF 
#define NV_096_SET_COMBINE_FACTOR_BLUE_MSK                 0x000000FF /* 7:0 */ 
#define NV_096_SET_COMBINE_FACTOR_BLUE_RMSK                0x000000FF /* 7:0 */ 
#define NV_096_SET_COMBINE_FACTOR_BLUE_WORD                0
#define NV_096_SET_COMBINE_FACTOR_BLUE_HIGH_FIELD          0x00000007 /* =7 */
#define NV_096_SET_COMBINE_FACTOR_BLUE_LOW_FIELD           0x00000000 /* =0 */
#define NV_096_SET_COMBINE_FACTOR_GREEN_MSK                0x0000FF00 /* 15:8 */ 
#define NV_096_SET_COMBINE_FACTOR_GREEN_RMSK               0x000000FF /* 15:8 */ 
#define NV_096_SET_COMBINE_FACTOR_GREEN_WORD               0
#define NV_096_SET_COMBINE_FACTOR_GREEN_HIGH_FIELD         0x0000000F /* =15 */
#define NV_096_SET_COMBINE_FACTOR_GREEN_LOW_FIELD          0x00000008 /* =8 */
#define NV_096_SET_COMBINE_FACTOR_RED_MSK                  0x00FF0000 /* 23:16 */ 
#define NV_096_SET_COMBINE_FACTOR_RED_RMSK                 0x000000FF /* 23:16 */ 
#define NV_096_SET_COMBINE_FACTOR_RED_WORD                 0
#define NV_096_SET_COMBINE_FACTOR_RED_HIGH_FIELD           0x00000017 /* =23 */
#define NV_096_SET_COMBINE_FACTOR_RED_LOW_FIELD            0x00000010 /* =16 */
#define NV_096_SET_COMBINE_FACTOR_ALPHA_MSK                0xFF000000 /* 31:24 */ 
#define NV_096_SET_COMBINE_FACTOR_ALPHA_RMSK               0x000000FF /* 31:24 */ 
#define NV_096_SET_COMBINE_FACTOR_ALPHA_WORD               0
#define NV_096_SET_COMBINE_FACTOR_ALPHA_HIGH_FIELD         0x0000001F /* =31 */
#define NV_096_SET_COMBINE_FACTOR_ALPHA_LOW_FIELD          0x00000018 /* =24 */
#define NV_096_SET_COMBINE_FACTOR_MSK                      0xFFFFFFFF 
#define NV_096_SET_COMBINER_ALPHA_OCW_OPERATION_MSK        0xFFFF8000 /* 31:15 */ 
#define NV_096_SET_COMBINER_ALPHA_OCW_OPERATION_RMSK       0x0001FFFF /* 31:15 */ 
#define NV_096_SET_COMBINER_ALPHA_OCW_OPERATION_WORD       0
#define NV_096_SET_COMBINER_ALPHA_OCW_OPERATION_HIGH_FIELD 0x0000001F /* =31 */
#define NV_096_SET_COMBINER_ALPHA_OCW_OPERATION_LOW_FIELD  0x0000000F /* =15 */
#define NV_096_SET_COMBINER_ALPHA_OCW_OPERATION_NOSHIFT_ADJ 0x00000000
#define NV_096_SET_COMBINER_ALPHA_OCW_OPERATION_NOSHIFT_BIAS_ADJ 0x00008000
#define NV_096_SET_COMBINER_ALPHA_OCW_OPERATION_SHIFTLEFTBY1_ADJ 0x00010000
#define NV_096_SET_COMBINER_ALPHA_OCW_OPERATION_SHIFTLEFTBY1_BIAS_ADJ 0x00018000
#define NV_096_SET_COMBINER_ALPHA_OCW_OPERATION_SHIFTLEFTBY2_ADJ 0x00020000
#define NV_096_SET_COMBINER_ALPHA_OCW_OPERATION_SHIFTRIGHTBY1_ADJ 0x00030000
#define NV_096_SET_COMBINER_ALPHA_OCW_MUX_ENABLE_MSK       0x00004000 /* 14:14 */ 
#define NV_096_SET_COMBINER_ALPHA_OCW_MUX_ENABLE_RMSK      0x00000001 /* 14:14 */ 
#define NV_096_SET_COMBINER_ALPHA_OCW_MUX_ENABLE_WORD      0
#define NV_096_SET_COMBINER_ALPHA_OCW_MUX_ENABLE_HIGH_FIELD 0x0000000E /* =14 */
#define NV_096_SET_COMBINER_ALPHA_OCW_MUX_ENABLE_LOW_FIELD 0x0000000E /* =14 */
#define NV_096_SET_COMBINER_ALPHA_OCW_MUX_ENABLE_FALSE_ADJ 0x00000000
#define NV_096_SET_COMBINER_ALPHA_OCW_MUX_ENABLE_TRUE_ADJ  0x00004000
#define NV_096_SET_COMBINER_ALPHA_OCW_SUM_DST_MSK          0x00000F00 /* 11:8 */ 
#define NV_096_SET_COMBINER_ALPHA_OCW_SUM_DST_RMSK         0x0000000F /* 11:8 */ 
#define NV_096_SET_COMBINER_ALPHA_OCW_SUM_DST_WORD         0
#define NV_096_SET_COMBINER_ALPHA_OCW_SUM_DST_HIGH_FIELD   0x0000000B /* =11 */
#define NV_096_SET_COMBINER_ALPHA_OCW_SUM_DST_LOW_FIELD    0x00000008 /* =8 */
#define NV_096_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_0_ADJ    0x00000000
#define NV_096_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_4_ADJ    0x00000400
#define NV_096_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_5_ADJ    0x00000500
#define NV_096_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_8_ADJ    0x00000800
#define NV_096_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_9_ADJ    0x00000900
#define NV_096_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_C_ADJ    0x00000C00
#define NV_096_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_D_ADJ    0x00000D00
#define NV_096_SET_COMBINER_ALPHA_OCW_AB_DST_MSK           0x000000F0 /* 7:4 */ 
#define NV_096_SET_COMBINER_ALPHA_OCW_AB_DST_RMSK          0x0000000F /* 7:4 */ 
#define NV_096_SET_COMBINER_ALPHA_OCW_AB_DST_WORD          0
#define NV_096_SET_COMBINER_ALPHA_OCW_AB_DST_HIGH_FIELD    0x00000007 /* =7 */
#define NV_096_SET_COMBINER_ALPHA_OCW_AB_DST_LOW_FIELD     0x00000004 /* =4 */
#define NV_096_SET_COMBINER_ALPHA_OCW_AB_DST_REG_0_ADJ     0x00000000
#define NV_096_SET_COMBINER_ALPHA_OCW_AB_DST_REG_4_ADJ     0x00000040
#define NV_096_SET_COMBINER_ALPHA_OCW_AB_DST_REG_5_ADJ     0x00000050
#define NV_096_SET_COMBINER_ALPHA_OCW_AB_DST_REG_8_ADJ     0x00000080
#define NV_096_SET_COMBINER_ALPHA_OCW_AB_DST_REG_9_ADJ     0x00000090
#define NV_096_SET_COMBINER_ALPHA_OCW_AB_DST_REG_C_ADJ     0x000000C0
#define NV_096_SET_COMBINER_ALPHA_OCW_AB_DST_REG_D_ADJ     0x000000D0
#define NV_096_SET_COMBINER_ALPHA_OCW_CD_DST_MSK           0x0000000F /* 3:0 */ 
#define NV_096_SET_COMBINER_ALPHA_OCW_CD_DST_RMSK          0x0000000F /* 3:0 */ 
#define NV_096_SET_COMBINER_ALPHA_OCW_CD_DST_WORD          0
#define NV_096_SET_COMBINER_ALPHA_OCW_CD_DST_HIGH_FIELD    0x00000003 /* =3 */
#define NV_096_SET_COMBINER_ALPHA_OCW_CD_DST_LOW_FIELD     0x00000000 /* =0 */
#define NV_096_SET_COMBINER_ALPHA_OCW_CD_DST_REG_0_ADJ     0x00000000
#define NV_096_SET_COMBINER_ALPHA_OCW_CD_DST_REG_4_ADJ     0x00000004
#define NV_096_SET_COMBINER_ALPHA_OCW_CD_DST_REG_5_ADJ     0x00000005
#define NV_096_SET_COMBINER_ALPHA_OCW_CD_DST_REG_8_ADJ     0x00000008
#define NV_096_SET_COMBINER_ALPHA_OCW_CD_DST_REG_9_ADJ     0x00000009
#define NV_096_SET_COMBINER_ALPHA_OCW_CD_DST_REG_C_ADJ     0x0000000C
#define NV_096_SET_COMBINER_ALPHA_OCW_CD_DST_REG_D_ADJ     0x0000000D
#define NV_096_SET_COMBINER_ALPHA_OCW_MSK                  0xFFFFCFFF 
#define NV_096_SET_COMBINER0_COLOR_OCW_ZERO_MSK            0xF8000000 /* 31:27 */ 
#define NV_096_SET_COMBINER0_COLOR_OCW_ZERO_RMSK           0x0000001F /* 31:27 */ 
#define NV_096_SET_COMBINER0_COLOR_OCW_ZERO_WORD           0
#define NV_096_SET_COMBINER0_COLOR_OCW_ZERO_HIGH_FIELD     0x0000001F /* =31 */
#define NV_096_SET_COMBINER0_COLOR_OCW_ZERO_LOW_FIELD      0x0000001B /* =27 */
#define NV_096_SET_COMBINER0_COLOR_OCW_OPERATION_MSK       0x07FF8000 /* 26:15 */ 
#define NV_096_SET_COMBINER0_COLOR_OCW_OPERATION_RMSK      0x00000FFF /* 26:15 */ 
#define NV_096_SET_COMBINER0_COLOR_OCW_OPERATION_WORD      0
#define NV_096_SET_COMBINER0_COLOR_OCW_OPERATION_HIGH_FIELD 0x0000001A /* =26 */
#define NV_096_SET_COMBINER0_COLOR_OCW_OPERATION_LOW_FIELD 0x0000000F /* =15 */
#define NV_096_SET_COMBINER0_COLOR_OCW_OPERATION_NOSHIFT_ADJ 0x00000000
#define NV_096_SET_COMBINER0_COLOR_OCW_OPERATION_NOSHIFT_BIAS_ADJ 0x00008000
#define NV_096_SET_COMBINER0_COLOR_OCW_OPERATION_SHIFTLEFTBY1_ADJ 0x00010000
#define NV_096_SET_COMBINER0_COLOR_OCW_OPERATION_SHIFTLEFTBY1_BIAS_ADJ 0x00018000
#define NV_096_SET_COMBINER0_COLOR_OCW_OPERATION_SHIFTLEFTBY2_ADJ 0x00020000
#define NV_096_SET_COMBINER0_COLOR_OCW_OPERATION_SHIFTRIGHTBY1_ADJ 0x00030000
#define NV_096_SET_COMBINER0_COLOR_OCW_MUX_ENABLE_MSK      0x00004000 /* 14:14 */ 
#define NV_096_SET_COMBINER0_COLOR_OCW_MUX_ENABLE_RMSK     0x00000001 /* 14:14 */ 
#define NV_096_SET_COMBINER0_COLOR_OCW_MUX_ENABLE_WORD     0
#define NV_096_SET_COMBINER0_COLOR_OCW_MUX_ENABLE_HIGH_FIELD 0x0000000E /* =14 */
#define NV_096_SET_COMBINER0_COLOR_OCW_MUX_ENABLE_LOW_FIELD 0x0000000E /* =14 */
#define NV_096_SET_COMBINER0_COLOR_OCW_MUX_ENABLE_FALSE_ADJ 0x00000000
#define NV_096_SET_COMBINER0_COLOR_OCW_MUX_ENABLE_TRUE_ADJ 0x00004000
#define NV_096_SET_COMBINER0_COLOR_OCW_AB_DOT_ENABLE_MSK   0x00002000 /* 13:13 */ 
#define NV_096_SET_COMBINER0_COLOR_OCW_AB_DOT_ENABLE_RMSK  0x00000001 /* 13:13 */ 
#define NV_096_SET_COMBINER0_COLOR_OCW_AB_DOT_ENABLE_WORD  0
#define NV_096_SET_COMBINER0_COLOR_OCW_AB_DOT_ENABLE_HIGH_FIELD 0x0000000D /* =13 */
#define NV_096_SET_COMBINER0_COLOR_OCW_AB_DOT_ENABLE_LOW_FIELD 0x0000000D /* =13 */
#define NV_096_SET_COMBINER0_COLOR_OCW_AB_DOT_ENABLE_FALSE_ADJ 0x00000000
#define NV_096_SET_COMBINER0_COLOR_OCW_AB_DOT_ENABLE_TRUE_ADJ 0x00002000
#define NV_096_SET_COMBINER0_COLOR_OCW_CD_DOT_ENABLE_MSK   0x00001000 /* 12:12 */ 
#define NV_096_SET_COMBINER0_COLOR_OCW_CD_DOT_ENABLE_RMSK  0x00000001 /* 12:12 */ 
#define NV_096_SET_COMBINER0_COLOR_OCW_CD_DOT_ENABLE_WORD  0
#define NV_096_SET_COMBINER0_COLOR_OCW_CD_DOT_ENABLE_HIGH_FIELD 0x0000000C /* =12 */
#define NV_096_SET_COMBINER0_COLOR_OCW_CD_DOT_ENABLE_LOW_FIELD 0x0000000C /* =12 */
#define NV_096_SET_COMBINER0_COLOR_OCW_CD_DOT_ENABLE_FALSE_ADJ 0x00000000
#define NV_096_SET_COMBINER0_COLOR_OCW_CD_DOT_ENABLE_TRUE_ADJ 0x00001000
#define NV_096_SET_COMBINER0_COLOR_OCW_SUM_DST_MSK         0x00000F00 /* 11:8 */ 
#define NV_096_SET_COMBINER0_COLOR_OCW_SUM_DST_RMSK        0x0000000F /* 11:8 */ 
#define NV_096_SET_COMBINER0_COLOR_OCW_SUM_DST_WORD        0
#define NV_096_SET_COMBINER0_COLOR_OCW_SUM_DST_HIGH_FIELD  0x0000000B /* =11 */
#define NV_096_SET_COMBINER0_COLOR_OCW_SUM_DST_LOW_FIELD   0x00000008 /* =8 */
#define NV_096_SET_COMBINER0_COLOR_OCW_SUM_DST_REG_0_ADJ   0x00000000
#define NV_096_SET_COMBINER0_COLOR_OCW_SUM_DST_REG_4_ADJ   0x00000400
#define NV_096_SET_COMBINER0_COLOR_OCW_SUM_DST_REG_5_ADJ   0x00000500
#define NV_096_SET_COMBINER0_COLOR_OCW_SUM_DST_REG_8_ADJ   0x00000800
#define NV_096_SET_COMBINER0_COLOR_OCW_SUM_DST_REG_9_ADJ   0x00000900
#define NV_096_SET_COMBINER0_COLOR_OCW_SUM_DST_REG_C_ADJ   0x00000C00
#define NV_096_SET_COMBINER0_COLOR_OCW_SUM_DST_REG_D_ADJ   0x00000D00
#define NV_096_SET_COMBINER0_COLOR_OCW_AB_DST_MSK          0x000000F0 /* 7:4 */ 
#define NV_096_SET_COMBINER0_COLOR_OCW_AB_DST_RMSK         0x0000000F /* 7:4 */ 
#define NV_096_SET_COMBINER0_COLOR_OCW_AB_DST_WORD         0
#define NV_096_SET_COMBINER0_COLOR_OCW_AB_DST_HIGH_FIELD   0x00000007 /* =7 */
#define NV_096_SET_COMBINER0_COLOR_OCW_AB_DST_LOW_FIELD    0x00000004 /* =4 */
#define NV_096_SET_COMBINER0_COLOR_OCW_AB_DST_REG_0_ADJ    0x00000000
#define NV_096_SET_COMBINER0_COLOR_OCW_AB_DST_REG_4_ADJ    0x00000040
#define NV_096_SET_COMBINER0_COLOR_OCW_AB_DST_REG_5_ADJ    0x00000050
#define NV_096_SET_COMBINER0_COLOR_OCW_AB_DST_REG_8_ADJ    0x00000080
#define NV_096_SET_COMBINER0_COLOR_OCW_AB_DST_REG_9_ADJ    0x00000090
#define NV_096_SET_COMBINER0_COLOR_OCW_AB_DST_REG_C_ADJ    0x000000C0
#define NV_096_SET_COMBINER0_COLOR_OCW_AB_DST_REG_D_ADJ    0x000000D0
#define NV_096_SET_COMBINER0_COLOR_OCW_CD_DST_MSK          0x0000000F /* 3:0 */ 
#define NV_096_SET_COMBINER0_COLOR_OCW_CD_DST_RMSK         0x0000000F /* 3:0 */ 
#define NV_096_SET_COMBINER0_COLOR_OCW_CD_DST_WORD         0
#define NV_096_SET_COMBINER0_COLOR_OCW_CD_DST_HIGH_FIELD   0x00000003 /* =3 */
#define NV_096_SET_COMBINER0_COLOR_OCW_CD_DST_LOW_FIELD    0x00000000 /* =0 */
#define NV_096_SET_COMBINER0_COLOR_OCW_CD_DST_REG_0_ADJ    0x00000000
#define NV_096_SET_COMBINER0_COLOR_OCW_CD_DST_REG_4_ADJ    0x00000004
#define NV_096_SET_COMBINER0_COLOR_OCW_CD_DST_REG_5_ADJ    0x00000005
#define NV_096_SET_COMBINER0_COLOR_OCW_CD_DST_REG_8_ADJ    0x00000008
#define NV_096_SET_COMBINER0_COLOR_OCW_CD_DST_REG_9_ADJ    0x00000009
#define NV_096_SET_COMBINER0_COLOR_OCW_CD_DST_REG_C_ADJ    0x0000000C
#define NV_096_SET_COMBINER0_COLOR_OCW_CD_DST_REG_D_ADJ    0x0000000D
#define NV_096_SET_COMBINER0_COLOR_OCW_MSK                 0xFFFFFFFF 
#define NV_096_SET_COMBINER1_COLOR_OCW_ITERATION_COUNT_MSK 0xF0000000 /* 31:28 */ 
#define NV_096_SET_COMBINER1_COLOR_OCW_ITERATION_COUNT_RMSK 0x0000000F /* 31:28 */ 
#define NV_096_SET_COMBINER1_COLOR_OCW_ITERATION_COUNT_WORD 0
#define NV_096_SET_COMBINER1_COLOR_OCW_ITERATION_COUNT_HIGH_FIELD 0x0000001F /* =31 */
#define NV_096_SET_COMBINER1_COLOR_OCW_ITERATION_COUNT_LOW_FIELD 0x0000001C /* =28 */
#define NV_096_SET_COMBINER1_COLOR_OCW_ITERATION_COUNT_ONE_ADJ 0x10000000
#define NV_096_SET_COMBINER1_COLOR_OCW_ITERATION_COUNT_TWO_ADJ 0x20000000
#define NV_096_SET_COMBINER1_COLOR_OCW_MUX_SELECT_MSK      0x08000000 /* 27:27 */ 
#define NV_096_SET_COMBINER1_COLOR_OCW_MUX_SELECT_RMSK     0x00000001 /* 27:27 */ 
#define NV_096_SET_COMBINER1_COLOR_OCW_MUX_SELECT_WORD     0
#define NV_096_SET_COMBINER1_COLOR_OCW_MUX_SELECT_HIGH_FIELD 0x0000001B /* =27 */
#define NV_096_SET_COMBINER1_COLOR_OCW_MUX_SELECT_LOW_FIELD 0x0000001B /* =27 */
#define NV_096_SET_COMBINER1_COLOR_OCW_MUX_SELECT_LSB_ADJ  0x00000000
#define NV_096_SET_COMBINER1_COLOR_OCW_MUX_SELECT_MSB_ADJ  0x08000000
#define NV_096_SET_COMBINER1_COLOR_OCW_OPERATION_MSK       0x07FF8000 /* 26:15 */ 
#define NV_096_SET_COMBINER1_COLOR_OCW_OPERATION_RMSK      0x00000FFF /* 26:15 */ 
#define NV_096_SET_COMBINER1_COLOR_OCW_OPERATION_WORD      0
#define NV_096_SET_COMBINER1_COLOR_OCW_OPERATION_HIGH_FIELD 0x0000001A /* =26 */
#define NV_096_SET_COMBINER1_COLOR_OCW_OPERATION_LOW_FIELD 0x0000000F /* =15 */
#define NV_096_SET_COMBINER1_COLOR_OCW_OPERATION_NOSHIFT_ADJ 0x00000000
#define NV_096_SET_COMBINER1_COLOR_OCW_OPERATION_NOSHIFT_BIAS_ADJ 0x00008000
#define NV_096_SET_COMBINER1_COLOR_OCW_OPERATION_SHIFTLEFTBY1_ADJ 0x00010000
#define NV_096_SET_COMBINER1_COLOR_OCW_OPERATION_SHIFTLEFTBY1_BIAS_ADJ 0x00018000
#define NV_096_SET_COMBINER1_COLOR_OCW_OPERATION_SHIFTLEFTBY2_ADJ 0x00020000
#define NV_096_SET_COMBINER1_COLOR_OCW_OPERATION_SHIFTRIGHTBY1_ADJ 0x00030000
#define NV_096_SET_COMBINER1_COLOR_OCW_MUX_ENABLE_MSK      0x00004000 /* 14:14 */ 
#define NV_096_SET_COMBINER1_COLOR_OCW_MUX_ENABLE_RMSK     0x00000001 /* 14:14 */ 
#define NV_096_SET_COMBINER1_COLOR_OCW_MUX_ENABLE_WORD     0
#define NV_096_SET_COMBINER1_COLOR_OCW_MUX_ENABLE_HIGH_FIELD 0x0000000E /* =14 */
#define NV_096_SET_COMBINER1_COLOR_OCW_MUX_ENABLE_LOW_FIELD 0x0000000E /* =14 */
#define NV_096_SET_COMBINER1_COLOR_OCW_MUX_ENABLE_FALSE_ADJ 0x00000000
#define NV_096_SET_COMBINER1_COLOR_OCW_MUX_ENABLE_TRUE_ADJ 0x00004000
#define NV_096_SET_COMBINER1_COLOR_OCW_AB_DOT_ENABLE_MSK   0x00002000 /* 13:13 */ 
#define NV_096_SET_COMBINER1_COLOR_OCW_AB_DOT_ENABLE_RMSK  0x00000001 /* 13:13 */ 
#define NV_096_SET_COMBINER1_COLOR_OCW_AB_DOT_ENABLE_WORD  0
#define NV_096_SET_COMBINER1_COLOR_OCW_AB_DOT_ENABLE_HIGH_FIELD 0x0000000D /* =13 */
#define NV_096_SET_COMBINER1_COLOR_OCW_AB_DOT_ENABLE_LOW_FIELD 0x0000000D /* =13 */
#define NV_096_SET_COMBINER1_COLOR_OCW_AB_DOT_ENABLE_FALSE_ADJ 0x00000000
#define NV_096_SET_COMBINER1_COLOR_OCW_AB_DOT_ENABLE_TRUE_ADJ 0x00002000
#define NV_096_SET_COMBINER1_COLOR_OCW_CD_DOT_ENABLE_MSK   0x00001000 /* 12:12 */ 
#define NV_096_SET_COMBINER1_COLOR_OCW_CD_DOT_ENABLE_RMSK  0x00000001 /* 12:12 */ 
#define NV_096_SET_COMBINER1_COLOR_OCW_CD_DOT_ENABLE_WORD  0
#define NV_096_SET_COMBINER1_COLOR_OCW_CD_DOT_ENABLE_HIGH_FIELD 0x0000000C /* =12 */
#define NV_096_SET_COMBINER1_COLOR_OCW_CD_DOT_ENABLE_LOW_FIELD 0x0000000C /* =12 */
#define NV_096_SET_COMBINER1_COLOR_OCW_CD_DOT_ENABLE_FALSE_ADJ 0x00000000
#define NV_096_SET_COMBINER1_COLOR_OCW_CD_DOT_ENABLE_TRUE_ADJ 0x00001000
#define NV_096_SET_COMBINER1_COLOR_OCW_SUM_DST_MSK         0x00000F00 /* 11:8 */ 
#define NV_096_SET_COMBINER1_COLOR_OCW_SUM_DST_RMSK        0x0000000F /* 11:8 */ 
#define NV_096_SET_COMBINER1_COLOR_OCW_SUM_DST_WORD        0
#define NV_096_SET_COMBINER1_COLOR_OCW_SUM_DST_HIGH_FIELD  0x0000000B /* =11 */
#define NV_096_SET_COMBINER1_COLOR_OCW_SUM_DST_LOW_FIELD   0x00000008 /* =8 */
#define NV_096_SET_COMBINER1_COLOR_OCW_SUM_DST_REG_0_ADJ   0x00000000
#define NV_096_SET_COMBINER1_COLOR_OCW_SUM_DST_REG_4_ADJ   0x00000400
#define NV_096_SET_COMBINER1_COLOR_OCW_SUM_DST_REG_5_ADJ   0x00000500
#define NV_096_SET_COMBINER1_COLOR_OCW_SUM_DST_REG_8_ADJ   0x00000800
#define NV_096_SET_COMBINER1_COLOR_OCW_SUM_DST_REG_9_ADJ   0x00000900
#define NV_096_SET_COMBINER1_COLOR_OCW_SUM_DST_REG_C_ADJ   0x00000C00
#define NV_096_SET_COMBINER1_COLOR_OCW_SUM_DST_REG_D_ADJ   0x00000D00
#define NV_096_SET_COMBINER1_COLOR_OCW_AB_DST_MSK          0x000000F0 /* 7:4 */ 
#define NV_096_SET_COMBINER1_COLOR_OCW_AB_DST_RMSK         0x0000000F /* 7:4 */ 
#define NV_096_SET_COMBINER1_COLOR_OCW_AB_DST_WORD         0
#define NV_096_SET_COMBINER1_COLOR_OCW_AB_DST_HIGH_FIELD   0x00000007 /* =7 */
#define NV_096_SET_COMBINER1_COLOR_OCW_AB_DST_LOW_FIELD    0x00000004 /* =4 */
#define NV_096_SET_COMBINER1_COLOR_OCW_AB_DST_REG_0_ADJ    0x00000000
#define NV_096_SET_COMBINER1_COLOR_OCW_AB_DST_REG_4_ADJ    0x00000040
#define NV_096_SET_COMBINER1_COLOR_OCW_AB_DST_REG_5_ADJ    0x00000050
#define NV_096_SET_COMBINER1_COLOR_OCW_AB_DST_REG_8_ADJ    0x00000080
#define NV_096_SET_COMBINER1_COLOR_OCW_AB_DST_REG_9_ADJ    0x00000090
#define NV_096_SET_COMBINER1_COLOR_OCW_AB_DST_REG_C_ADJ    0x000000C0
#define NV_096_SET_COMBINER1_COLOR_OCW_AB_DST_REG_D_ADJ    0x000000D0
#define NV_096_SET_COMBINER1_COLOR_OCW_CD_DST_MSK          0x0000000F /* 3:0 */ 
#define NV_096_SET_COMBINER1_COLOR_OCW_CD_DST_RMSK         0x0000000F /* 3:0 */ 
#define NV_096_SET_COMBINER1_COLOR_OCW_CD_DST_WORD         0
#define NV_096_SET_COMBINER1_COLOR_OCW_CD_DST_HIGH_FIELD   0x00000003 /* =3 */
#define NV_096_SET_COMBINER1_COLOR_OCW_CD_DST_LOW_FIELD    0x00000000 /* =0 */
#define NV_096_SET_COMBINER1_COLOR_OCW_CD_DST_REG_0_ADJ    0x00000000
#define NV_096_SET_COMBINER1_COLOR_OCW_CD_DST_REG_4_ADJ    0x00000004
#define NV_096_SET_COMBINER1_COLOR_OCW_CD_DST_REG_5_ADJ    0x00000005
#define NV_096_SET_COMBINER1_COLOR_OCW_CD_DST_REG_8_ADJ    0x00000008
#define NV_096_SET_COMBINER1_COLOR_OCW_CD_DST_REG_9_ADJ    0x00000009
#define NV_096_SET_COMBINER1_COLOR_OCW_CD_DST_REG_C_ADJ    0x0000000C
#define NV_096_SET_COMBINER1_COLOR_OCW_CD_DST_REG_D_ADJ    0x0000000D
#define NV_096_SET_COMBINER1_COLOR_OCW_MSK                 0xFFFFFFFF 
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW0_A_INVERSE_MSK 0xE0000000 /* 31:29 */ 
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW0_A_INVERSE_RMSK 0x00000007 /* 31:29 */ 
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW0_A_INVERSE_WORD 0
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW0_A_INVERSE_HIGH_FIELD 0x0000001F /* =31 */
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW0_A_INVERSE_LOW_FIELD 0x0000001D /* =29 */
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW0_A_INVERSE_FALSE_ADJ 0x00000000
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW0_A_INVERSE_TRUE_ADJ 0x20000000
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW0_A_ALPHA_MSK   0x10000000 /* 28:28 */ 
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW0_A_ALPHA_RMSK  0x00000001 /* 28:28 */ 
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW0_A_ALPHA_WORD  0
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW0_A_ALPHA_HIGH_FIELD 0x0000001C /* =28 */
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW0_A_ALPHA_LOW_FIELD 0x0000001C /* =28 */
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW0_A_ALPHA_FALSE_ADJ 0x00000000
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW0_A_ALPHA_TRUE_ADJ 0x10000000
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_MSK  0x0F000000 /* 27:24 */ 
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_RMSK 0x0000000F /* 27:24 */ 
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_WORD 0
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_HIGH_FIELD 0x0000001B /* =27 */
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_LOW_FIELD 0x00000018 /* =24 */
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_0_ADJ 0x00000000
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_1_ADJ 0x01000000
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_2_ADJ 0x02000000
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_3_ADJ 0x03000000
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_4_ADJ 0x04000000
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_5_ADJ 0x05000000
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_8_ADJ 0x08000000
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_9_ADJ 0x09000000
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_C_ADJ 0x0C000000
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_D_ADJ 0x0D000000
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_SPECLIT_ADJ 0x0E000000
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW0_A_SOURCE_REG_EF_PROD_ADJ 0x0F000000
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW0_B_INVERSE_MSK 0x00E00000 /* 23:21 */ 
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW0_B_INVERSE_RMSK 0x00000007 /* 23:21 */ 
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW0_B_INVERSE_WORD 0
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW0_B_INVERSE_HIGH_FIELD 0x00000017 /* =23 */
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW0_B_INVERSE_LOW_FIELD 0x00000015 /* =21 */
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW0_B_INVERSE_FALSE_ADJ 0x00000000
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW0_B_INVERSE_TRUE_ADJ 0x00200000
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW0_B_ALPHA_MSK   0x00100000 /* 20:20 */ 
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW0_B_ALPHA_RMSK  0x00000001 /* 20:20 */ 
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW0_B_ALPHA_WORD  0
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW0_B_ALPHA_HIGH_FIELD 0x00000014 /* =20 */
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW0_B_ALPHA_LOW_FIELD 0x00000014 /* =20 */
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW0_B_ALPHA_FALSE_ADJ 0x00000000
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW0_B_ALPHA_TRUE_ADJ 0x00100000
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_MSK  0x000F0000 /* 19:16 */ 
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_RMSK 0x0000000F /* 19:16 */ 
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_WORD 0
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_HIGH_FIELD 0x00000013 /* =19 */
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_LOW_FIELD 0x00000010 /* =16 */
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_0_ADJ 0x00000000
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_1_ADJ 0x00010000
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_2_ADJ 0x00020000
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_3_ADJ 0x00030000
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_4_ADJ 0x00040000
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_5_ADJ 0x00050000
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_8_ADJ 0x00080000
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_9_ADJ 0x00090000
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_C_ADJ 0x000C0000
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_D_ADJ 0x000D0000
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_SPECLIT_ADJ 0x000E0000
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW0_B_SOURCE_REG_EF_PROD_ADJ 0x000F0000
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW0_C_INVERSE_MSK 0x0000E000 /* 15:13 */ 
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW0_C_INVERSE_RMSK 0x00000007 /* 15:13 */ 
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW0_C_INVERSE_WORD 0
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW0_C_INVERSE_HIGH_FIELD 0x0000000F /* =15 */
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW0_C_INVERSE_LOW_FIELD 0x0000000D /* =13 */
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW0_C_INVERSE_FALSE_ADJ 0x00000000
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW0_C_INVERSE_TRUE_ADJ 0x00002000
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW0_C_ALPHA_MSK   0x00001000 /* 12:12 */ 
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW0_C_ALPHA_RMSK  0x00000001 /* 12:12 */ 
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW0_C_ALPHA_WORD  0
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW0_C_ALPHA_HIGH_FIELD 0x0000000C /* =12 */
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW0_C_ALPHA_LOW_FIELD 0x0000000C /* =12 */
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW0_C_ALPHA_FALSE_ADJ 0x00000000
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW0_C_ALPHA_TRUE_ADJ 0x00001000
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_MSK  0x00000F00 /* 11:8 */ 
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_RMSK 0x0000000F /* 11:8 */ 
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_WORD 0
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_HIGH_FIELD 0x0000000B /* =11 */
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_LOW_FIELD 0x00000008 /* =8 */
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_0_ADJ 0x00000000
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_1_ADJ 0x00000100
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_2_ADJ 0x00000200
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_3_ADJ 0x00000300
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_4_ADJ 0x00000400
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_5_ADJ 0x00000500
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_8_ADJ 0x00000800
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_9_ADJ 0x00000900
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_C_ADJ 0x00000C00
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_D_ADJ 0x00000D00
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_SPECLIT_ADJ 0x00000E00
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW0_C_SOURCE_REG_EF_PROD_ADJ 0x00000F00
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW0_D_INVERSE_MSK 0x000000E0 /* 7:5 */ 
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW0_D_INVERSE_RMSK 0x00000007 /* 7:5 */ 
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW0_D_INVERSE_WORD 0
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW0_D_INVERSE_HIGH_FIELD 0x00000007 /* =7 */
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW0_D_INVERSE_LOW_FIELD 0x00000005 /* =5 */
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW0_D_INVERSE_FALSE_ADJ 0x00000000
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW0_D_INVERSE_TRUE_ADJ 0x00000020
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW0_D_ALPHA_MSK   0x00000010 /* 4:4 */ 
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW0_D_ALPHA_RMSK  0x00000001 /* 4:4 */ 
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW0_D_ALPHA_WORD  0
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW0_D_ALPHA_HIGH_FIELD 0x00000004 /* =4 */
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW0_D_ALPHA_LOW_FIELD 0x00000004 /* =4 */
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW0_D_ALPHA_FALSE_ADJ 0x00000000
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW0_D_ALPHA_TRUE_ADJ 0x00000010
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_MSK  0x0000000F /* 3:0 */ 
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_RMSK 0x0000000F /* 3:0 */ 
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_WORD 0
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_HIGH_FIELD 0x00000003 /* =3 */
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_LOW_FIELD 0x00000000 /* =0 */
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_0_ADJ 0x00000000
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_1_ADJ 0x00000001
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_2_ADJ 0x00000002
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_3_ADJ 0x00000003
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_4_ADJ 0x00000004
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_5_ADJ 0x00000005
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_8_ADJ 0x00000008
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_9_ADJ 0x00000009
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_C_ADJ 0x0000000C
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_D_ADJ 0x0000000D
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_SPECLIT_ADJ 0x0000000E
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW0_D_SOURCE_REG_EF_PROD_ADJ 0x0000000F
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW0_MSK           0xFFFFFFFF 
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW1_E_INVERSE_MSK 0xE0000000 /* 31:29 */ 
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW1_E_INVERSE_RMSK 0x00000007 /* 31:29 */ 
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW1_E_INVERSE_WORD 0
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW1_E_INVERSE_HIGH_FIELD 0x0000001F /* =31 */
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW1_E_INVERSE_LOW_FIELD 0x0000001D /* =29 */
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW1_E_INVERSE_FALSE_ADJ 0x00000000
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW1_E_INVERSE_TRUE_ADJ 0x20000000
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW1_E_ALPHA_MSK   0x10000000 /* 28:28 */ 
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW1_E_ALPHA_RMSK  0x00000001 /* 28:28 */ 
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW1_E_ALPHA_WORD  0
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW1_E_ALPHA_HIGH_FIELD 0x0000001C /* =28 */
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW1_E_ALPHA_LOW_FIELD 0x0000001C /* =28 */
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW1_E_ALPHA_FALSE_ADJ 0x00000000
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW1_E_ALPHA_TRUE_ADJ 0x10000000
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_MSK  0x0F000000 /* 27:24 */ 
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_RMSK 0x0000000F /* 27:24 */ 
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_WORD 0
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_HIGH_FIELD 0x0000001B /* =27 */
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_LOW_FIELD 0x00000018 /* =24 */
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_0_ADJ 0x00000000
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_1_ADJ 0x01000000
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_2_ADJ 0x02000000
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_3_ADJ 0x03000000
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_4_ADJ 0x04000000
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_5_ADJ 0x05000000
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_8_ADJ 0x08000000
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_9_ADJ 0x09000000
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_C_ADJ 0x0C000000
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW1_E_SOURCE_REG_D_ADJ 0x0D000000
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW1_F_INVERSE_MSK 0x00E00000 /* 23:21 */ 
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW1_F_INVERSE_RMSK 0x00000007 /* 23:21 */ 
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW1_F_INVERSE_WORD 0
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW1_F_INVERSE_HIGH_FIELD 0x00000017 /* =23 */
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW1_F_INVERSE_LOW_FIELD 0x00000015 /* =21 */
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW1_F_INVERSE_FALSE_ADJ 0x00000000
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW1_F_INVERSE_TRUE_ADJ 0x00200000
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW1_F_ALPHA_MSK   0x00100000 /* 20:20 */ 
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW1_F_ALPHA_RMSK  0x00000001 /* 20:20 */ 
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW1_F_ALPHA_WORD  0
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW1_F_ALPHA_HIGH_FIELD 0x00000014 /* =20 */
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW1_F_ALPHA_LOW_FIELD 0x00000014 /* =20 */
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW1_F_ALPHA_FALSE_ADJ 0x00000000
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW1_F_ALPHA_TRUE_ADJ 0x00100000
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_MSK  0x000F0000 /* 19:16 */ 
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_RMSK 0x0000000F /* 19:16 */ 
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_WORD 0
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_HIGH_FIELD 0x00000013 /* =19 */
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_LOW_FIELD 0x00000010 /* =16 */
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_0_ADJ 0x00000000
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_1_ADJ 0x00010000
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_2_ADJ 0x00020000
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_3_ADJ 0x00030000
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_4_ADJ 0x00040000
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_5_ADJ 0x00050000
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_8_ADJ 0x00080000
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_9_ADJ 0x00090000
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_C_ADJ 0x000C0000
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW1_F_SOURCE_REG_D_ADJ 0x000D0000
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW1_G_INVERSE_MSK 0x0000E000 /* 15:13 */ 
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW1_G_INVERSE_RMSK 0x00000007 /* 15:13 */ 
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW1_G_INVERSE_WORD 0
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW1_G_INVERSE_HIGH_FIELD 0x0000000F /* =15 */
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW1_G_INVERSE_LOW_FIELD 0x0000000D /* =13 */
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW1_G_INVERSE_FALSE_ADJ 0x00000000
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW1_G_INVERSE_TRUE_ADJ 0x00002000
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW1_G_ALPHA_MSK   0x00001000 /* 12:12 */ 
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW1_G_ALPHA_RMSK  0x00000001 /* 12:12 */ 
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW1_G_ALPHA_WORD  0
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW1_G_ALPHA_HIGH_FIELD 0x0000000C /* =12 */
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW1_G_ALPHA_LOW_FIELD 0x0000000C /* =12 */
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW1_G_ALPHA_FALSE_ADJ 0x00000000
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW1_G_ALPHA_TRUE_ADJ 0x00001000
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_MSK  0x00000F00 /* 11:8 */ 
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_RMSK 0x0000000F /* 11:8 */ 
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_WORD 0
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_HIGH_FIELD 0x0000000B /* =11 */
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_LOW_FIELD 0x00000008 /* =8 */
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_0_ADJ 0x00000000
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_1_ADJ 0x00000100
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_2_ADJ 0x00000200
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_3_ADJ 0x00000300
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_4_ADJ 0x00000400
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_5_ADJ 0x00000500
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_8_ADJ 0x00000800
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_9_ADJ 0x00000900
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_C_ADJ 0x00000C00
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW1_G_SOURCE_REG_D_ADJ 0x00000D00
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_CLAMP_MSK 0x00000080 /* 7:7 */ 
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_CLAMP_RMSK 0x00000001 /* 7:7 */ 
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_CLAMP_WORD 0
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_CLAMP_HIGH_FIELD 0x00000007 /* =7 */
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_CLAMP_LOW_FIELD 0x00000007 /* =7 */
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_CLAMP_FALSE_ADJ 0x00000000
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_CLAMP_TRUE_ADJ 0x00000080
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_ADD_INVERT_R5_MSK 0x00000040 /* 6:6 */ 
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_ADD_INVERT_R5_RMSK 0x00000001 /* 6:6 */ 
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_ADD_INVERT_R5_WORD 0
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_ADD_INVERT_R5_HIGH_FIELD 0x00000006 /* =6 */
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_ADD_INVERT_R5_LOW_FIELD 0x00000006 /* =6 */
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_ADD_INVERT_R5_FALSE_ADJ 0x00000000
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_ADD_INVERT_R5_TRUE_ADJ 0x00000040
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_ADD_INVERT_R12_MSK 0x0000003F /* 5:0 */ 
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_ADD_INVERT_R12_RMSK 0x0000003F /* 5:0 */ 
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_ADD_INVERT_R12_WORD 0
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_ADD_INVERT_R12_HIGH_FIELD 0x00000005 /* =5 */
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_ADD_INVERT_R12_LOW_FIELD 0x00000000 /* =0 */
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_ADD_INVERT_R12_FALSE_ADJ 0x00000000
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW1_SPECULAR_ADD_INVERT_R12_TRUE_ADJ 0x00000020
#define NV_096_SET_COMBINER_SPECULAR_FOG_CW1_MSK           0xFFFFFFFF 
#define NV_096_SET_CONTROL0_PREMULTIPLIEDALPHA_MSK         0xFF000000 /* 31:24 */ 
#define NV_096_SET_CONTROL0_PREMULTIPLIEDALPHA_RMSK        0x000000FF /* 31:24 */ 
#define NV_096_SET_CONTROL0_PREMULTIPLIEDALPHA_WORD        0
#define NV_096_SET_CONTROL0_PREMULTIPLIEDALPHA_HIGH_FIELD  0x0000001F /* =31 */
#define NV_096_SET_CONTROL0_PREMULTIPLIEDALPHA_LOW_FIELD   0x00000018 /* =24 */
#define NV_096_SET_CONTROL0_PREMULTIPLIEDALPHA_FALSE_ADJ   0x00000000
#define NV_096_SET_CONTROL0_PREMULTIPLIEDALPHA_TRUE_ADJ    0x01000000
#define NV_096_SET_CONTROL0_TEXTUREPERSPECTIVE_MSK         0x00F00000 /* 23:20 */ 
#define NV_096_SET_CONTROL0_TEXTUREPERSPECTIVE_RMSK        0x0000000F /* 23:20 */ 
#define NV_096_SET_CONTROL0_TEXTUREPERSPECTIVE_WORD        0
#define NV_096_SET_CONTROL0_TEXTUREPERSPECTIVE_HIGH_FIELD  0x00000017 /* =23 */
#define NV_096_SET_CONTROL0_TEXTUREPERSPECTIVE_LOW_FIELD   0x00000014 /* =20 */
#define NV_096_SET_CONTROL0_TEXTUREPERSPECTIVE_FALSE_ADJ   0x00000000
#define NV_096_SET_CONTROL0_TEXTUREPERSPECTIVE_TRUE_ADJ    0x00100000
#define NV_096_SET_CONTROL0_Z_PERSPECTIVE_ENABLE_MSK       0x000F0000 /* 19:16 */ 
#define NV_096_SET_CONTROL0_Z_PERSPECTIVE_ENABLE_RMSK      0x0000000F /* 19:16 */ 
#define NV_096_SET_CONTROL0_Z_PERSPECTIVE_ENABLE_WORD      0
#define NV_096_SET_CONTROL0_Z_PERSPECTIVE_ENABLE_HIGH_FIELD 0x00000013 /* =19 */
#define NV_096_SET_CONTROL0_Z_PERSPECTIVE_ENABLE_LOW_FIELD 0x00000010 /* =16 */
#define NV_096_SET_CONTROL0_Z_PERSPECTIVE_ENABLE_FALSE_ADJ 0x00000000
#define NV_096_SET_CONTROL0_Z_PERSPECTIVE_ENABLE_TRUE_ADJ  0x00010000
#define NV_096_SET_CONTROL0_Z_FORMAT_MSK                   0x0000F000 /* 15:12 */ 
#define NV_096_SET_CONTROL0_Z_FORMAT_RMSK                  0x0000000F /* 15:12 */ 
#define NV_096_SET_CONTROL0_Z_FORMAT_WORD                  0
#define NV_096_SET_CONTROL0_Z_FORMAT_HIGH_FIELD            0x0000000F /* =15 */
#define NV_096_SET_CONTROL0_Z_FORMAT_LOW_FIELD             0x0000000C /* =12 */
#define NV_096_SET_CONTROL0_Z_FORMAT_FIXED_ADJ             0x00000000
#define NV_096_SET_CONTROL0_Z_FORMAT_FLOAT_ADJ             0x00001000
#define NV_096_SET_CONTROL0_WBUFFER_SELECT_MSK             0x00000F00 /* 11:8 */ 
#define NV_096_SET_CONTROL0_WBUFFER_SELECT_RMSK            0x0000000F /* 11:8 */ 
#define NV_096_SET_CONTROL0_WBUFFER_SELECT_WORD            0
#define NV_096_SET_CONTROL0_WBUFFER_SELECT_HIGH_FIELD      0x0000000B /* =11 */
#define NV_096_SET_CONTROL0_WBUFFER_SELECT_LOW_FIELD       0x00000008 /* =8 */
#define NV_096_SET_CONTROL0_WBUFFER_SELECT_0_ADJ           0x00000000
#define NV_096_SET_CONTROL0_WBUFFER_SELECT_1_ADJ           0x00000100
#define NV_096_SET_CONTROL0_STENCIL_WRITE_ENABLE_MSK       0x000000FF /* 7:0 */ 
#define NV_096_SET_CONTROL0_STENCIL_WRITE_ENABLE_RMSK      0x000000FF /* 7:0 */ 
#define NV_096_SET_CONTROL0_STENCIL_WRITE_ENABLE_WORD      0
#define NV_096_SET_CONTROL0_STENCIL_WRITE_ENABLE_HIGH_FIELD 0x00000007 /* =7 */
#define NV_096_SET_CONTROL0_STENCIL_WRITE_ENABLE_LOW_FIELD 0x00000000 /* =0 */
#define NV_096_SET_CONTROL0_STENCIL_WRITE_ENABLE_FALSE_ADJ 0x00000000
#define NV_096_SET_CONTROL0_STENCIL_WRITE_ENABLE_TRUE_ADJ  0x00000001
#define NV_096_SET_CONTROL0_MSK                            0xFFFFFFFF 
#define NV_096_SET_LIGHT_CONTROL_LOCALEYE_MSK              0xFFFF0000 /* 31:16 */ 
#define NV_096_SET_LIGHT_CONTROL_LOCALEYE_RMSK             0x0000FFFF /* 31:16 */ 
#define NV_096_SET_LIGHT_CONTROL_LOCALEYE_WORD             0
#define NV_096_SET_LIGHT_CONTROL_LOCALEYE_HIGH_FIELD       0x0000001F /* =31 */
#define NV_096_SET_LIGHT_CONTROL_LOCALEYE_LOW_FIELD        0x00000010 /* =16 */
#define NV_096_SET_LIGHT_CONTROL_LOCALEYE_FALSE_ADJ        0x00000000
#define NV_096_SET_LIGHT_CONTROL_LOCALEYE_TRUE_ADJ         0x00010000
#define NV_096_SET_LIGHT_CONTROL_ATTENUATION_MODE_MSK      0x0000FFFC /* 15:2 */ 
#define NV_096_SET_LIGHT_CONTROL_ATTENUATION_MODE_RMSK     0x00003FFF /* 15:2 */ 
#define NV_096_SET_LIGHT_CONTROL_ATTENUATION_MODE_WORD     0
#define NV_096_SET_LIGHT_CONTROL_ATTENUATION_MODE_HIGH_FIELD 0x0000000F /* =15 */
#define NV_096_SET_LIGHT_CONTROL_ATTENUATION_MODE_LOW_FIELD 0x00000002 /* =2 */
#define NV_096_SET_LIGHT_CONTROL_ATTENUATION_MODE_INVERT_ADJ 0x00000000
#define NV_096_SET_LIGHT_CONTROL_ATTENUATION_MODE_NOT_INVERT_ADJ 0x00000004
#define NV_096_SET_LIGHT_CONTROL_SEPARATE_SPECULAR_EN_MSK  0x00000002 /* 1:1 */ 
#define NV_096_SET_LIGHT_CONTROL_SEPARATE_SPECULAR_EN_RMSK 0x00000001 /* 1:1 */ 
#define NV_096_SET_LIGHT_CONTROL_SEPARATE_SPECULAR_EN_WORD 0
#define NV_096_SET_LIGHT_CONTROL_SEPARATE_SPECULAR_EN_HIGH_FIELD 0x00000001 /* =1 */
#define NV_096_SET_LIGHT_CONTROL_SEPARATE_SPECULAR_EN_LOW_FIELD 0x00000001 /* =1 */
#define NV_096_SET_LIGHT_CONTROL_SEPARATE_SPECULAR_EN_FALSE_ADJ 0x00000000
#define NV_096_SET_LIGHT_CONTROL_SEPARATE_SPECULAR_EN_TRUE_ADJ 0x00000002
#define NV_096_SET_LIGHT_CONTROL_SECONDARY_COLOR_EN_MSK    0x00000001 /* 0:0 */ 
#define NV_096_SET_LIGHT_CONTROL_SECONDARY_COLOR_EN_RMSK   0x00000001 /* 0:0 */ 
#define NV_096_SET_LIGHT_CONTROL_SECONDARY_COLOR_EN_WORD   0
#define NV_096_SET_LIGHT_CONTROL_SECONDARY_COLOR_EN_HIGH_FIELD 0x00000000 /* =0 */
#define NV_096_SET_LIGHT_CONTROL_SECONDARY_COLOR_EN_LOW_FIELD 0x00000000 /* =0 */
#define NV_096_SET_LIGHT_CONTROL_SECONDARY_COLOR_EN_FALSE_ADJ 0x00000000
#define NV_096_SET_LIGHT_CONTROL_SECONDARY_COLOR_EN_TRUE_ADJ 0x00000001
#define NV_096_SET_LIGHT_CONTROL_MSK                       0xFFFFFFFF 
#define NV_096_SET_COLOR_MATERIAL_V_MSK                    0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_COLOR_MATERIAL_V_RMSK                   0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_COLOR_MATERIAL_V_WORD                   0
#define NV_096_SET_COLOR_MATERIAL_V_HIGH_FIELD             0x0000001F /* =31 */
#define NV_096_SET_COLOR_MATERIAL_V_LOW_FIELD              0x00000000 /* =0 */
#define NV_096_SET_COLOR_MATERIAL_V_DISABLED_ADJ           0x00000000
#define NV_096_SET_COLOR_MATERIAL_V_EMISSION_ADJ           0x00000001
#define NV_096_SET_COLOR_MATERIAL_V_AMBIENT_ADJ            0x00000002
#define NV_096_SET_COLOR_MATERIAL_V_EMISSION_AMBIENT_ADJ   0x00000003
#define NV_096_SET_COLOR_MATERIAL_V_DIFFUSE_ADJ            0x00000004
#define NV_096_SET_COLOR_MATERIAL_V_EMISSION_DIFFUSE_ADJ   0x00000005
#define NV_096_SET_COLOR_MATERIAL_V_AMBIENT_DIFFUSE_ADJ    0x00000006
#define NV_096_SET_COLOR_MATERIAL_V_EMISSION_AMBIENT_DIFFUSE_ADJ 0x00000007
#define NV_096_SET_COLOR_MATERIAL_V_SPECULAR_ADJ           0x00000008
#define NV_096_SET_COLOR_MATERIAL_V_EMISSION_SPECULAR_ADJ  0x00000009
#define NV_096_SET_COLOR_MATERIAL_V_AMBIENT_SPECULAR_ADJ   0x0000000A
#define NV_096_SET_COLOR_MATERIAL_V_EMISSION_AMBIENT_SPECULAR_ADJ 0x0000000B
#define NV_096_SET_COLOR_MATERIAL_V_DIFFUSE_SPECULAR_ADJ   0x0000000C
#define NV_096_SET_COLOR_MATERIAL_V_EMISSION_DIFFUSE_SPECULAR_ADJ 0x0000000D
#define NV_096_SET_COLOR_MATERIAL_V_AMBIENT_DIFFUSE_SPECULAR_ADJ 0x0000000E
#define NV_096_SET_COLOR_MATERIAL_V_EMISSION_AMBIENT_DIFFUSE_SPECULAR_ADJ 0x0000000F
#define NV_096_SET_COLOR_MATERIAL_MSK                      0xFFFFFFFF 
#define NV_096_SET_FOG_MODE_FOG_MODE_MSK                   0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_FOG_MODE_FOG_MODE_RMSK                  0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_FOG_MODE_FOG_MODE_WORD                  0
#define NV_096_SET_FOG_MODE_FOG_MODE_HIGH_FIELD            0x0000001F /* =31 */
#define NV_096_SET_FOG_MODE_FOG_MODE_LOW_FIELD             0x00000000 /* =0 */
#define NV_096_SET_FOG_MODE_FOG_MODE_LINEAR_ADJ            0x00002601
#define NV_096_SET_FOG_MODE_FOG_MODE_EXP_ADJ               0x00000800
#define NV_096_SET_FOG_MODE_FOG_MODE_EXP2_ADJ              0x00000801
#define NV_096_SET_FOG_MODE_FOG_MODE_EXP_ABS_ADJ           0x00000802
#define NV_096_SET_FOG_MODE_FOG_MODE_EXP2_ABS_ADJ          0x00000803
#define NV_096_SET_FOG_MODE_MSK                            0xFFFFFFFF 
#define NV_096_SET_FOG_GEN_MODE_FOG_GEN_MODE_MSK           0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_FOG_GEN_MODE_FOG_GEN_MODE_RMSK          0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_FOG_GEN_MODE_FOG_GEN_MODE_WORD          0
#define NV_096_SET_FOG_GEN_MODE_FOG_GEN_MODE_HIGH_FIELD    0x0000001F /* =31 */
#define NV_096_SET_FOG_GEN_MODE_FOG_GEN_MODE_LOW_FIELD     0x00000000 /* =0 */
#define NV_096_SET_FOG_GEN_MODE_FOG_GEN_MODE_USE_INPUT_ADJ 0x00000000
#define NV_096_SET_FOG_GEN_MODE_FOG_GEN_MODE_RADIAL_ADJ    0x00000001
#define NV_096_SET_FOG_GEN_MODE_FOG_GEN_MODE_PLANAR_ADJ    0x00000002
#define NV_096_SET_FOG_GEN_MODE_FOG_GEN_MODE_ABS_PLANAR_ADJ 0x00000003
#define NV_096_SET_FOG_GEN_MODE_MSK                        0xFFFFFFFF 
#define NV_096_SET_FOG_ENABLE_V_MSK                        0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_FOG_ENABLE_V_RMSK                       0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_FOG_ENABLE_V_WORD                       0
#define NV_096_SET_FOG_ENABLE_V_HIGH_FIELD                 0x0000001F /* =31 */
#define NV_096_SET_FOG_ENABLE_V_LOW_FIELD                  0x00000000 /* =0 */
#define NV_096_SET_FOG_ENABLE_V_FALSE_ADJ                  0x00000000
#define NV_096_SET_FOG_ENABLE_V_TRUE_ADJ                   0x00000001
#define NV_096_SET_FOG_ENABLE_MSK                          0xFFFFFFFF 
#define NV_096_SET_FOG_COLOR_FOG_COLOR_RED_MSK             0x000000FF /* 7:0 */ 
#define NV_096_SET_FOG_COLOR_FOG_COLOR_RED_RMSK            0x000000FF /* 7:0 */ 
#define NV_096_SET_FOG_COLOR_FOG_COLOR_RED_WORD            0
#define NV_096_SET_FOG_COLOR_FOG_COLOR_RED_HIGH_FIELD      0x00000007 /* =7 */
#define NV_096_SET_FOG_COLOR_FOG_COLOR_RED_LOW_FIELD       0x00000000 /* =0 */
#define NV_096_SET_FOG_COLOR_FOG_COLOR_GREEN_MSK           0x0000FF00 /* 15:8 */ 
#define NV_096_SET_FOG_COLOR_FOG_COLOR_GREEN_RMSK          0x000000FF /* 15:8 */ 
#define NV_096_SET_FOG_COLOR_FOG_COLOR_GREEN_WORD          0
#define NV_096_SET_FOG_COLOR_FOG_COLOR_GREEN_HIGH_FIELD    0x0000000F /* =15 */
#define NV_096_SET_FOG_COLOR_FOG_COLOR_GREEN_LOW_FIELD     0x00000008 /* =8 */
#define NV_096_SET_FOG_COLOR_FOG_COLOR_BLUE_MSK            0x00FF0000 /* 23:16 */ 
#define NV_096_SET_FOG_COLOR_FOG_COLOR_BLUE_RMSK           0x000000FF /* 23:16 */ 
#define NV_096_SET_FOG_COLOR_FOG_COLOR_BLUE_WORD           0
#define NV_096_SET_FOG_COLOR_FOG_COLOR_BLUE_HIGH_FIELD     0x00000017 /* =23 */
#define NV_096_SET_FOG_COLOR_FOG_COLOR_BLUE_LOW_FIELD      0x00000010 /* =16 */
#define NV_096_SET_FOG_COLOR_FOG_COLOR_ALPHA_MSK           0xFF000000 /* 31:24 */ 
#define NV_096_SET_FOG_COLOR_FOG_COLOR_ALPHA_RMSK          0x000000FF /* 31:24 */ 
#define NV_096_SET_FOG_COLOR_FOG_COLOR_ALPHA_WORD          0
#define NV_096_SET_FOG_COLOR_FOG_COLOR_ALPHA_HIGH_FIELD    0x0000001F /* =31 */
#define NV_096_SET_FOG_COLOR_FOG_COLOR_ALPHA_LOW_FIELD     0x00000018 /* =24 */
#define NV_096_SET_FOG_COLOR_MSK                           0xFFFFFFFF 
#define NV_096_SET_COLOR_KEY_COLOR_V_MSK                   0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_COLOR_KEY_COLOR_V_RMSK                  0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_COLOR_KEY_COLOR_V_WORD                  0
#define NV_096_SET_COLOR_KEY_COLOR_V_HIGH_FIELD            0x0000001F /* =31 */
#define NV_096_SET_COLOR_KEY_COLOR_V_LOW_FIELD             0x00000000 /* =0 */
#define NV_096_SET_COLOR_KEY_COLOR_MSK                     0xFFFFFFFF 
#define NV_096_SET_WINDOW_CLIP_TYPE_V_MSK                  0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_WINDOW_CLIP_TYPE_V_RMSK                 0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_WINDOW_CLIP_TYPE_V_WORD                 0
#define NV_096_SET_WINDOW_CLIP_TYPE_V_HIGH_FIELD           0x0000001F /* =31 */
#define NV_096_SET_WINDOW_CLIP_TYPE_V_LOW_FIELD            0x00000000 /* =0 */
#define NV_096_SET_WINDOW_CLIP_TYPE_V_INCLUSIVE_ADJ        0x00000000
#define NV_096_SET_WINDOW_CLIP_TYPE_V_EXCLUSIVE_ADJ        0x00000001
#define NV_096_SET_WINDOW_CLIP_TYPE_MSK                    0xFFFFFFFF 
#define NV_096_SET_WINDOW_CLIP_HORIZONTAL_XMIN_MSK         0x0000FFFF /* 15:0 */ 
#define NV_096_SET_WINDOW_CLIP_HORIZONTAL_XMIN_RMSK        0x0000FFFF /* 15:0 */ 
#define NV_096_SET_WINDOW_CLIP_HORIZONTAL_XMIN_WORD        0
#define NV_096_SET_WINDOW_CLIP_HORIZONTAL_XMIN_HIGH_FIELD  0x0000000F /* =15 */
#define NV_096_SET_WINDOW_CLIP_HORIZONTAL_XMIN_LOW_FIELD   0x00000000 /* =0 */
#define NV_096_SET_WINDOW_CLIP_HORIZONTAL_XMAX_MSK         0xFFFF0000 /* 31:16 */ 
#define NV_096_SET_WINDOW_CLIP_HORIZONTAL_XMAX_RMSK        0x0000FFFF /* 31:16 */ 
#define NV_096_SET_WINDOW_CLIP_HORIZONTAL_XMAX_WORD        0
#define NV_096_SET_WINDOW_CLIP_HORIZONTAL_XMAX_HIGH_FIELD  0x0000001F /* =31 */
#define NV_096_SET_WINDOW_CLIP_HORIZONTAL_XMAX_LOW_FIELD   0x00000010 /* =16 */
#define NV_096_SET_WINDOW_CLIP_HORIZONTAL_MSK              0xFFFFFFFF 
#define NV_096_SET_WINDOW_CLIP_VERTICAL_YMIN_MSK           0x0000FFFF /* 15:0 */ 
#define NV_096_SET_WINDOW_CLIP_VERTICAL_YMIN_RMSK          0x0000FFFF /* 15:0 */ 
#define NV_096_SET_WINDOW_CLIP_VERTICAL_YMIN_WORD          0
#define NV_096_SET_WINDOW_CLIP_VERTICAL_YMIN_HIGH_FIELD    0x0000000F /* =15 */
#define NV_096_SET_WINDOW_CLIP_VERTICAL_YMIN_LOW_FIELD     0x00000000 /* =0 */
#define NV_096_SET_WINDOW_CLIP_VERTICAL_YMAX_MSK           0xFFFF0000 /* 31:16 */ 
#define NV_096_SET_WINDOW_CLIP_VERTICAL_YMAX_RMSK          0x0000FFFF /* 31:16 */ 
#define NV_096_SET_WINDOW_CLIP_VERTICAL_YMAX_WORD          0
#define NV_096_SET_WINDOW_CLIP_VERTICAL_YMAX_HIGH_FIELD    0x0000001F /* =31 */
#define NV_096_SET_WINDOW_CLIP_VERTICAL_YMAX_LOW_FIELD     0x00000010 /* =16 */
#define NV_096_SET_WINDOW_CLIP_VERTICAL_MSK                0xFFFFFFFF 
#define NV_096_SET_ALPHA_TEST_ENABLE_V_MSK                 0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_ALPHA_TEST_ENABLE_V_RMSK                0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_ALPHA_TEST_ENABLE_V_WORD                0
#define NV_096_SET_ALPHA_TEST_ENABLE_V_HIGH_FIELD          0x0000001F /* =31 */
#define NV_096_SET_ALPHA_TEST_ENABLE_V_LOW_FIELD           0x00000000 /* =0 */
#define NV_096_SET_ALPHA_TEST_ENABLE_V_FALSE_ADJ           0x00000000
#define NV_096_SET_ALPHA_TEST_ENABLE_V_TRUE_ADJ            0x00000001
#define NV_096_SET_ALPHA_TEST_ENABLE_MSK                   0xFFFFFFFF 
#define NV_096_SET_BLEND_ENABLE_V_MSK                      0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_BLEND_ENABLE_V_RMSK                     0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_BLEND_ENABLE_V_WORD                     0
#define NV_096_SET_BLEND_ENABLE_V_HIGH_FIELD               0x0000001F /* =31 */
#define NV_096_SET_BLEND_ENABLE_V_LOW_FIELD                0x00000000 /* =0 */
#define NV_096_SET_BLEND_ENABLE_V_FALSE_ADJ                0x00000000
#define NV_096_SET_BLEND_ENABLE_V_TRUE_ADJ                 0x00000001
#define NV_096_SET_BLEND_ENABLE_MSK                        0xFFFFFFFF 
#define NV_096_SET_CULL_FACE_ENABLE_V_MSK                  0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_CULL_FACE_ENABLE_V_RMSK                 0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_CULL_FACE_ENABLE_V_WORD                 0
#define NV_096_SET_CULL_FACE_ENABLE_V_HIGH_FIELD           0x0000001F /* =31 */
#define NV_096_SET_CULL_FACE_ENABLE_V_LOW_FIELD            0x00000000 /* =0 */
#define NV_096_SET_CULL_FACE_ENABLE_V_FALSE_ADJ            0x00000000
#define NV_096_SET_CULL_FACE_ENABLE_V_TRUE_ADJ             0x00000001
#define NV_096_SET_CULL_FACE_ENABLE_MSK                    0xFFFFFFFF 
#define NV_096_SET_DEPTH_TEST_ENABLE_V_MSK                 0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_DEPTH_TEST_ENABLE_V_RMSK                0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_DEPTH_TEST_ENABLE_V_WORD                0
#define NV_096_SET_DEPTH_TEST_ENABLE_V_HIGH_FIELD          0x0000001F /* =31 */
#define NV_096_SET_DEPTH_TEST_ENABLE_V_LOW_FIELD           0x00000000 /* =0 */
#define NV_096_SET_DEPTH_TEST_ENABLE_V_FALSE_ADJ           0x00000000
#define NV_096_SET_DEPTH_TEST_ENABLE_V_TRUE_ADJ            0x00000001
#define NV_096_SET_DEPTH_TEST_ENABLE_MSK                   0xFFFFFFFF 
#define NV_096_SET_DITHER_ENABLE_V_MSK                     0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_DITHER_ENABLE_V_RMSK                    0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_DITHER_ENABLE_V_WORD                    0
#define NV_096_SET_DITHER_ENABLE_V_HIGH_FIELD              0x0000001F /* =31 */
#define NV_096_SET_DITHER_ENABLE_V_LOW_FIELD               0x00000000 /* =0 */
#define NV_096_SET_DITHER_ENABLE_V_FALSE_ADJ               0x00000000
#define NV_096_SET_DITHER_ENABLE_V_TRUE_ADJ                0x00000001
#define NV_096_SET_DITHER_ENABLE_MSK                       0xFFFFFFFF 
#define NV_096_SET_LIGHTING_ENABLE_V_MSK                   0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_LIGHTING_ENABLE_V_RMSK                  0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_LIGHTING_ENABLE_V_WORD                  0
#define NV_096_SET_LIGHTING_ENABLE_V_HIGH_FIELD            0x0000001F /* =31 */
#define NV_096_SET_LIGHTING_ENABLE_V_LOW_FIELD             0x00000000 /* =0 */
#define NV_096_SET_LIGHTING_ENABLE_V_FALSE_ADJ             0x00000000
#define NV_096_SET_LIGHTING_ENABLE_V_TRUE_ADJ              0x00000001
#define NV_096_SET_LIGHTING_ENABLE_MSK                     0xFFFFFFFF 
#define NV_096_SET_POINT_PARAMS_ENABLE_V_MSK               0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_POINT_PARAMS_ENABLE_V_RMSK              0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_POINT_PARAMS_ENABLE_V_WORD              0
#define NV_096_SET_POINT_PARAMS_ENABLE_V_HIGH_FIELD        0x0000001F /* =31 */
#define NV_096_SET_POINT_PARAMS_ENABLE_V_LOW_FIELD         0x00000000 /* =0 */
#define NV_096_SET_POINT_PARAMS_ENABLE_V_FALSE_ADJ         0x00000000
#define NV_096_SET_POINT_PARAMS_ENABLE_V_TRUE_ADJ          0x00000001
#define NV_096_SET_POINT_PARAMS_ENABLE_MSK                 0xFFFFFFFF 
#define NV_096_SET_POINT_SMOOTH_ENABLE_V_MSK               0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_POINT_SMOOTH_ENABLE_V_RMSK              0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_POINT_SMOOTH_ENABLE_V_WORD              0
#define NV_096_SET_POINT_SMOOTH_ENABLE_V_HIGH_FIELD        0x0000001F /* =31 */
#define NV_096_SET_POINT_SMOOTH_ENABLE_V_LOW_FIELD         0x00000000 /* =0 */
#define NV_096_SET_POINT_SMOOTH_ENABLE_V_FALSE_ADJ         0x00000000
#define NV_096_SET_POINT_SMOOTH_ENABLE_V_TRUE_ADJ          0x00000001
#define NV_096_SET_POINT_SMOOTH_ENABLE_MSK                 0xFFFFFFFF 
#define NV_096_SET_LINE_SMOOTH_ENABLE_V_MSK                0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_LINE_SMOOTH_ENABLE_V_RMSK               0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_LINE_SMOOTH_ENABLE_V_WORD               0
#define NV_096_SET_LINE_SMOOTH_ENABLE_V_HIGH_FIELD         0x0000001F /* =31 */
#define NV_096_SET_LINE_SMOOTH_ENABLE_V_LOW_FIELD          0x00000000 /* =0 */
#define NV_096_SET_LINE_SMOOTH_ENABLE_V_FALSE_ADJ          0x00000000
#define NV_096_SET_LINE_SMOOTH_ENABLE_V_TRUE_ADJ           0x00000001
#define NV_096_SET_LINE_SMOOTH_ENABLE_MSK                  0xFFFFFFFF 
#define NV_096_SET_POLY_SMOOTH_ENABLE_V_MSK                0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_POLY_SMOOTH_ENABLE_V_RMSK               0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_POLY_SMOOTH_ENABLE_V_WORD               0
#define NV_096_SET_POLY_SMOOTH_ENABLE_V_HIGH_FIELD         0x0000001F /* =31 */
#define NV_096_SET_POLY_SMOOTH_ENABLE_V_LOW_FIELD          0x00000000 /* =0 */
#define NV_096_SET_POLY_SMOOTH_ENABLE_V_FALSE_ADJ          0x00000000
#define NV_096_SET_POLY_SMOOTH_ENABLE_V_TRUE_ADJ           0x00000001
#define NV_096_SET_POLY_SMOOTH_ENABLE_MSK                  0xFFFFFFFF 
#define NV_096_SET_SKIN_ENABLE_V_MSK                       0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_SKIN_ENABLE_V_RMSK                      0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_SKIN_ENABLE_V_WORD                      0
#define NV_096_SET_SKIN_ENABLE_V_HIGH_FIELD                0x0000001F /* =31 */
#define NV_096_SET_SKIN_ENABLE_V_LOW_FIELD                 0x00000000 /* =0 */
#define NV_096_SET_SKIN_ENABLE_V_FALSE_ADJ                 0x00000000
#define NV_096_SET_SKIN_ENABLE_V_TRUE_ADJ                  0x00000001
#define NV_096_SET_SKIN_ENABLE_MSK                         0xFFFFFFFF 
#define NV_096_SET_STENCIL_TEST_ENABLE_V_MSK               0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_STENCIL_TEST_ENABLE_V_RMSK              0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_STENCIL_TEST_ENABLE_V_WORD              0
#define NV_096_SET_STENCIL_TEST_ENABLE_V_HIGH_FIELD        0x0000001F /* =31 */
#define NV_096_SET_STENCIL_TEST_ENABLE_V_LOW_FIELD         0x00000000 /* =0 */
#define NV_096_SET_STENCIL_TEST_ENABLE_V_FALSE_ADJ         0x00000000
#define NV_096_SET_STENCIL_TEST_ENABLE_V_TRUE_ADJ          0x00000001
#define NV_096_SET_STENCIL_TEST_ENABLE_MSK                 0xFFFFFFFF 
#define NV_096_SET_POLY_OFFSET_POINT_ENABLE_V_MSK          0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_POLY_OFFSET_POINT_ENABLE_V_RMSK         0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_POLY_OFFSET_POINT_ENABLE_V_WORD         0
#define NV_096_SET_POLY_OFFSET_POINT_ENABLE_V_HIGH_FIELD   0x0000001F /* =31 */
#define NV_096_SET_POLY_OFFSET_POINT_ENABLE_V_LOW_FIELD    0x00000000 /* =0 */
#define NV_096_SET_POLY_OFFSET_POINT_ENABLE_V_FALSE_ADJ    0x00000000
#define NV_096_SET_POLY_OFFSET_POINT_ENABLE_V_TRUE_ADJ     0x00000001
#define NV_096_SET_POLY_OFFSET_POINT_ENABLE_MSK            0xFFFFFFFF 
#define NV_096_SET_POLY_OFFSET_LINE_ENABLE_V_MSK           0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_POLY_OFFSET_LINE_ENABLE_V_RMSK          0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_POLY_OFFSET_LINE_ENABLE_V_WORD          0
#define NV_096_SET_POLY_OFFSET_LINE_ENABLE_V_HIGH_FIELD    0x0000001F /* =31 */
#define NV_096_SET_POLY_OFFSET_LINE_ENABLE_V_LOW_FIELD     0x00000000 /* =0 */
#define NV_096_SET_POLY_OFFSET_LINE_ENABLE_V_FALSE_ADJ     0x00000000
#define NV_096_SET_POLY_OFFSET_LINE_ENABLE_V_TRUE_ADJ      0x00000001
#define NV_096_SET_POLY_OFFSET_LINE_ENABLE_MSK             0xFFFFFFFF 
#define NV_096_SET_POLY_OFFSET_FILL_ENABLE_V_MSK           0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_POLY_OFFSET_FILL_ENABLE_V_RMSK          0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_POLY_OFFSET_FILL_ENABLE_V_WORD          0
#define NV_096_SET_POLY_OFFSET_FILL_ENABLE_V_HIGH_FIELD    0x0000001F /* =31 */
#define NV_096_SET_POLY_OFFSET_FILL_ENABLE_V_LOW_FIELD     0x00000000 /* =0 */
#define NV_096_SET_POLY_OFFSET_FILL_ENABLE_V_FALSE_ADJ     0x00000000
#define NV_096_SET_POLY_OFFSET_FILL_ENABLE_V_TRUE_ADJ      0x00000001
#define NV_096_SET_POLY_OFFSET_FILL_ENABLE_MSK             0xFFFFFFFF 
#define NV_096_SET_ALPHA_FUNC_V_MSK                        0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_ALPHA_FUNC_V_RMSK                       0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_ALPHA_FUNC_V_WORD                       0
#define NV_096_SET_ALPHA_FUNC_V_HIGH_FIELD                 0x0000001F /* =31 */
#define NV_096_SET_ALPHA_FUNC_V_LOW_FIELD                  0x00000000 /* =0 */
#define NV_096_SET_ALPHA_FUNC_V_NEVER_ADJ                  0x00000200
#define NV_096_SET_ALPHA_FUNC_V_LESS_ADJ                   0x00000201
#define NV_096_SET_ALPHA_FUNC_V_EQUAL_ADJ                  0x00000202
#define NV_096_SET_ALPHA_FUNC_V_LEQUAL_ADJ                 0x00000203
#define NV_096_SET_ALPHA_FUNC_V_GREATER_ADJ                0x00000204
#define NV_096_SET_ALPHA_FUNC_V_NOTEQUAL_ADJ               0x00000205
#define NV_096_SET_ALPHA_FUNC_V_GEQUAL_ADJ                 0x00000206
#define NV_096_SET_ALPHA_FUNC_V_ALWAYS_ADJ                 0x00000207
#define NV_096_SET_ALPHA_FUNC_MSK                          0xFFFFFFFF 
#define NV_096_SET_ALPHA_REF_V_MSK                         0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_ALPHA_REF_V_RMSK                        0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_ALPHA_REF_V_WORD                        0
#define NV_096_SET_ALPHA_REF_V_HIGH_FIELD                  0x0000001F /* =31 */
#define NV_096_SET_ALPHA_REF_V_LOW_FIELD                   0x00000000 /* =0 */
#define NV_096_SET_ALPHA_REF_MSK                           0xFFFFFFFF 
#define NV_096_SET_BLEND_FUNC_SFACTOR_V_MSK                0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_BLEND_FUNC_SFACTOR_V_RMSK               0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_BLEND_FUNC_SFACTOR_V_WORD               0
#define NV_096_SET_BLEND_FUNC_SFACTOR_V_HIGH_FIELD         0x0000001F /* =31 */
#define NV_096_SET_BLEND_FUNC_SFACTOR_V_LOW_FIELD          0x00000000 /* =0 */
#define NV_096_SET_BLEND_FUNC_SFACTOR_V_ZERO_ADJ           0x00000000
#define NV_096_SET_BLEND_FUNC_SFACTOR_V_ONE_ADJ            0x00000001
#define NV_096_SET_BLEND_FUNC_SFACTOR_V_SRC_COLOR_ADJ      0x00000300
#define NV_096_SET_BLEND_FUNC_SFACTOR_V_ONE_MINUS_SRC_COLOR_ADJ 0x00000301
#define NV_096_SET_BLEND_FUNC_SFACTOR_V_SRC_ALPHA_ADJ      0x00000302
#define NV_096_SET_BLEND_FUNC_SFACTOR_V_ONE_MINUS_SRC_ALPHA_ADJ 0x00000303
#define NV_096_SET_BLEND_FUNC_SFACTOR_V_DST_ALPHA_ADJ      0x00000304
#define NV_096_SET_BLEND_FUNC_SFACTOR_V_ONE_MINUS_DST_ALPHA_ADJ 0x00000305
#define NV_096_SET_BLEND_FUNC_SFACTOR_V_DST_COLOR_ADJ      0x00000306
#define NV_096_SET_BLEND_FUNC_SFACTOR_V_ONE_MINUS_DST_COLOR_ADJ 0x00000307
#define NV_096_SET_BLEND_FUNC_SFACTOR_V_SRC_ALPHA_SATURATE_ADJ 0x00000308
#define NV_096_SET_BLEND_FUNC_SFACTOR_V_CONSTANT_COLOR_ADJ 0x00008001
#define NV_096_SET_BLEND_FUNC_SFACTOR_V_ONE_MINUS_CONSTANT_COLOR_ADJ 0x00008002
#define NV_096_SET_BLEND_FUNC_SFACTOR_V_CONSTANT_ALPHA_ADJ 0x00008003
#define NV_096_SET_BLEND_FUNC_SFACTOR_V_ONE_MINUS_CONSTANT_ALPHA_ADJ 0x00008004
#define NV_096_SET_BLEND_FUNC_SFACTOR_MSK                  0xFFFFFFFF 
#define NV_096_SET_BLEND_FUNC_DFACTOR_V_MSK                0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_BLEND_FUNC_DFACTOR_V_RMSK               0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_BLEND_FUNC_DFACTOR_V_WORD               0
#define NV_096_SET_BLEND_FUNC_DFACTOR_V_HIGH_FIELD         0x0000001F /* =31 */
#define NV_096_SET_BLEND_FUNC_DFACTOR_V_LOW_FIELD          0x00000000 /* =0 */
#define NV_096_SET_BLEND_FUNC_DFACTOR_V_ZERO_ADJ           0x00000000
#define NV_096_SET_BLEND_FUNC_DFACTOR_V_ONE_ADJ            0x00000001
#define NV_096_SET_BLEND_FUNC_DFACTOR_V_SRC_COLOR_ADJ      0x00000300
#define NV_096_SET_BLEND_FUNC_DFACTOR_V_ONE_MINUS_SRC_COLOR_ADJ 0x00000301
#define NV_096_SET_BLEND_FUNC_DFACTOR_V_SRC_ALPHA_ADJ      0x00000302
#define NV_096_SET_BLEND_FUNC_DFACTOR_V_ONE_MINUS_SRC_ALPHA_ADJ 0x00000303
#define NV_096_SET_BLEND_FUNC_DFACTOR_V_DST_ALPHA_ADJ      0x00000304
#define NV_096_SET_BLEND_FUNC_DFACTOR_V_ONE_MINUS_DST_ALPHA_ADJ 0x00000305
#define NV_096_SET_BLEND_FUNC_DFACTOR_V_DST_COLOR_ADJ      0x00000306
#define NV_096_SET_BLEND_FUNC_DFACTOR_V_ONE_MINUS_DST_COLOR_ADJ 0x00000307
#define NV_096_SET_BLEND_FUNC_DFACTOR_V_CONSTANT_COLOR_ADJ 0x00008001
#define NV_096_SET_BLEND_FUNC_DFACTOR_V_ONE_MINUS_CONSTANT_COLOR_ADJ 0x00008002
#define NV_096_SET_BLEND_FUNC_DFACTOR_V_CONSTANT_ALPHA_ADJ 0x00008003
#define NV_096_SET_BLEND_FUNC_DFACTOR_V_ONE_MINUS_CONSTANT_ALPHA_ADJ 0x00008004
#define NV_096_SET_BLEND_FUNC_DFACTOR_MSK                  0xFFFFFFFF 
#define NV_096_SET_BLEND_COLOR_V_MSK                       0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_BLEND_COLOR_V_RMSK                      0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_BLEND_COLOR_V_WORD                      0
#define NV_096_SET_BLEND_COLOR_V_HIGH_FIELD                0x0000001F /* =31 */
#define NV_096_SET_BLEND_COLOR_V_LOW_FIELD                 0x00000000 /* =0 */
#define NV_096_SET_BLEND_COLOR_MSK                         0xFFFFFFFF 
#define NV_096_SET_BLEND_EQUATION_V_MSK                    0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_BLEND_EQUATION_V_RMSK                   0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_BLEND_EQUATION_V_WORD                   0
#define NV_096_SET_BLEND_EQUATION_V_HIGH_FIELD             0x0000001F /* =31 */
#define NV_096_SET_BLEND_EQUATION_V_LOW_FIELD              0x00000000 /* =0 */
#define NV_096_SET_BLEND_EQUATION_V_FUNC_SUBTRACT_ADJ      0x0000800A
#define NV_096_SET_BLEND_EQUATION_V_FUNC_REVERSE_SUBTRACT_ADJ 0x0000800B
#define NV_096_SET_BLEND_EQUATION_V_FUNC_ADD_ADJ           0x00008006
#define NV_096_SET_BLEND_EQUATION_V_MIN_ADJ                0x00008007
#define NV_096_SET_BLEND_EQUATION_V_MAX_ADJ                0x00008008
#define NV_096_SET_BLEND_EQUATION_MSK                      0xFFFFFFFF 
#define NV_096_SET_DEPTH_FUNC_V_MSK                        0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_DEPTH_FUNC_V_RMSK                       0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_DEPTH_FUNC_V_WORD                       0
#define NV_096_SET_DEPTH_FUNC_V_HIGH_FIELD                 0x0000001F /* =31 */
#define NV_096_SET_DEPTH_FUNC_V_LOW_FIELD                  0x00000000 /* =0 */
#define NV_096_SET_DEPTH_FUNC_V_NEVER_ADJ                  0x00000200
#define NV_096_SET_DEPTH_FUNC_V_LESS_ADJ                   0x00000201
#define NV_096_SET_DEPTH_FUNC_V_EQUAL_ADJ                  0x00000202
#define NV_096_SET_DEPTH_FUNC_V_LEQUAL_ADJ                 0x00000203
#define NV_096_SET_DEPTH_FUNC_V_GREATER_ADJ                0x00000204
#define NV_096_SET_DEPTH_FUNC_V_NOTEQUAL_ADJ               0x00000205
#define NV_096_SET_DEPTH_FUNC_V_GEQUAL_ADJ                 0x00000206
#define NV_096_SET_DEPTH_FUNC_V_ALWAYS_ADJ                 0x00000207
#define NV_096_SET_DEPTH_FUNC_MSK                          0xFFFFFFFF 
#define NV_096_SET_COLOR_MASK_ALPHA_WRITE_ENABLE_MSK       0xFF000000 /* 31:24 */ 
#define NV_096_SET_COLOR_MASK_ALPHA_WRITE_ENABLE_RMSK      0x000000FF /* 31:24 */ 
#define NV_096_SET_COLOR_MASK_ALPHA_WRITE_ENABLE_WORD      0
#define NV_096_SET_COLOR_MASK_ALPHA_WRITE_ENABLE_HIGH_FIELD 0x0000001F /* =31 */
#define NV_096_SET_COLOR_MASK_ALPHA_WRITE_ENABLE_LOW_FIELD 0x00000018 /* =24 */
#define NV_096_SET_COLOR_MASK_ALPHA_WRITE_ENABLE_FALSE_ADJ 0x00000000
#define NV_096_SET_COLOR_MASK_ALPHA_WRITE_ENABLE_TRUE_ADJ  0x01000000
#define NV_096_SET_COLOR_MASK_RED_WRITE_ENABLE_MSK         0x00FF0000 /* 23:16 */ 
#define NV_096_SET_COLOR_MASK_RED_WRITE_ENABLE_RMSK        0x000000FF /* 23:16 */ 
#define NV_096_SET_COLOR_MASK_RED_WRITE_ENABLE_WORD        0
#define NV_096_SET_COLOR_MASK_RED_WRITE_ENABLE_HIGH_FIELD  0x00000017 /* =23 */
#define NV_096_SET_COLOR_MASK_RED_WRITE_ENABLE_LOW_FIELD   0x00000010 /* =16 */
#define NV_096_SET_COLOR_MASK_RED_WRITE_ENABLE_FALSE_ADJ   0x00000000
#define NV_096_SET_COLOR_MASK_RED_WRITE_ENABLE_TRUE_ADJ    0x00010000
#define NV_096_SET_COLOR_MASK_GREEN_WRITE_ENABLE_MSK       0x0000FF00 /* 15:8 */ 
#define NV_096_SET_COLOR_MASK_GREEN_WRITE_ENABLE_RMSK      0x000000FF /* 15:8 */ 
#define NV_096_SET_COLOR_MASK_GREEN_WRITE_ENABLE_WORD      0
#define NV_096_SET_COLOR_MASK_GREEN_WRITE_ENABLE_HIGH_FIELD 0x0000000F /* =15 */
#define NV_096_SET_COLOR_MASK_GREEN_WRITE_ENABLE_LOW_FIELD 0x00000008 /* =8 */
#define NV_096_SET_COLOR_MASK_GREEN_WRITE_ENABLE_FALSE_ADJ 0x00000000
#define NV_096_SET_COLOR_MASK_GREEN_WRITE_ENABLE_TRUE_ADJ  0x00000100
#define NV_096_SET_COLOR_MASK_BLUE_WRITE_ENABLE_MSK        0x000000FF /* 7:0 */ 
#define NV_096_SET_COLOR_MASK_BLUE_WRITE_ENABLE_RMSK       0x000000FF /* 7:0 */ 
#define NV_096_SET_COLOR_MASK_BLUE_WRITE_ENABLE_WORD       0
#define NV_096_SET_COLOR_MASK_BLUE_WRITE_ENABLE_HIGH_FIELD 0x00000007 /* =7 */
#define NV_096_SET_COLOR_MASK_BLUE_WRITE_ENABLE_LOW_FIELD  0x00000000 /* =0 */
#define NV_096_SET_COLOR_MASK_BLUE_WRITE_ENABLE_FALSE_ADJ  0x00000000
#define NV_096_SET_COLOR_MASK_BLUE_WRITE_ENABLE_TRUE_ADJ   0x00000001
#define NV_096_SET_COLOR_MASK_MSK                          0xFFFFFFFF 
#define NV_096_SET_DEPTH_MASK_V_MSK                        0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_DEPTH_MASK_V_RMSK                       0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_DEPTH_MASK_V_WORD                       0
#define NV_096_SET_DEPTH_MASK_V_HIGH_FIELD                 0x0000001F /* =31 */
#define NV_096_SET_DEPTH_MASK_V_LOW_FIELD                  0x00000000 /* =0 */
#define NV_096_SET_DEPTH_MASK_V_FALSE_ADJ                  0x00000000
#define NV_096_SET_DEPTH_MASK_V_TRUE_ADJ                   0x00000001
#define NV_096_SET_DEPTH_MASK_MSK                          0xFFFFFFFF 
#define NV_096_SET_STENCIL_MASK_V_MSK                      0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_STENCIL_MASK_V_RMSK                     0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_STENCIL_MASK_V_WORD                     0
#define NV_096_SET_STENCIL_MASK_V_HIGH_FIELD               0x0000001F /* =31 */
#define NV_096_SET_STENCIL_MASK_V_LOW_FIELD                0x00000000 /* =0 */
#define NV_096_SET_STENCIL_MASK_MSK                        0xFFFFFFFF 
#define NV_096_SET_STENCIL_FUNC_V_MSK                      0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_STENCIL_FUNC_V_RMSK                     0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_STENCIL_FUNC_V_WORD                     0
#define NV_096_SET_STENCIL_FUNC_V_HIGH_FIELD               0x0000001F /* =31 */
#define NV_096_SET_STENCIL_FUNC_V_LOW_FIELD                0x00000000 /* =0 */
#define NV_096_SET_STENCIL_FUNC_V_NEVER_ADJ                0x00000200
#define NV_096_SET_STENCIL_FUNC_V_LESS_ADJ                 0x00000201
#define NV_096_SET_STENCIL_FUNC_V_EQUAL_ADJ                0x00000202
#define NV_096_SET_STENCIL_FUNC_V_LEQUAL_ADJ               0x00000203
#define NV_096_SET_STENCIL_FUNC_V_GREATER_ADJ              0x00000204
#define NV_096_SET_STENCIL_FUNC_V_NOTEQUAL_ADJ             0x00000205
#define NV_096_SET_STENCIL_FUNC_V_GEQUAL_ADJ               0x00000206
#define NV_096_SET_STENCIL_FUNC_V_ALWAYS_ADJ               0x00000207
#define NV_096_SET_STENCIL_FUNC_MSK                        0xFFFFFFFF 
#define NV_096_SET_STENCIL_FUNC_REF_V_MSK                  0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_STENCIL_FUNC_REF_V_RMSK                 0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_STENCIL_FUNC_REF_V_WORD                 0
#define NV_096_SET_STENCIL_FUNC_REF_V_HIGH_FIELD           0x0000001F /* =31 */
#define NV_096_SET_STENCIL_FUNC_REF_V_LOW_FIELD            0x00000000 /* =0 */
#define NV_096_SET_STENCIL_FUNC_REF_MSK                    0xFFFFFFFF 
#define NV_096_SET_STENCIL_FUNC_MASK_V_MSK                 0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_STENCIL_FUNC_MASK_V_RMSK                0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_STENCIL_FUNC_MASK_V_WORD                0
#define NV_096_SET_STENCIL_FUNC_MASK_V_HIGH_FIELD          0x0000001F /* =31 */
#define NV_096_SET_STENCIL_FUNC_MASK_V_LOW_FIELD           0x00000000 /* =0 */
#define NV_096_SET_STENCIL_FUNC_MASK_MSK                   0xFFFFFFFF 
#define NV_096_SET_STENCIL_OP_FAIL_V_MSK                   0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_STENCIL_OP_FAIL_V_RMSK                  0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_STENCIL_OP_FAIL_V_WORD                  0
#define NV_096_SET_STENCIL_OP_FAIL_V_HIGH_FIELD            0x0000001F /* =31 */
#define NV_096_SET_STENCIL_OP_FAIL_V_LOW_FIELD             0x00000000 /* =0 */
#define NV_096_SET_STENCIL_OP_FAIL_V_KEEP_ADJ              0x00001E00
#define NV_096_SET_STENCIL_OP_FAIL_V_ZERO_ADJ              0x00000000
#define NV_096_SET_STENCIL_OP_FAIL_V_REPLACE_ADJ           0x00001E01
#define NV_096_SET_STENCIL_OP_FAIL_V_INCRSAT_ADJ           0x00001E02
#define NV_096_SET_STENCIL_OP_FAIL_V_DECRSAT_ADJ           0x00001E03
#define NV_096_SET_STENCIL_OP_FAIL_V_INVERT_ADJ            0x0000150A
#define NV_096_SET_STENCIL_OP_FAIL_V_INCR_ADJ              0x00008507
#define NV_096_SET_STENCIL_OP_FAIL_V_DECR_ADJ              0x00008508
#define NV_096_SET_STENCIL_OP_FAIL_MSK                     0xFFFFFFFF 
#define NV_096_SET_STENCIL_OP_ZFAIL_V_MSK                  0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_STENCIL_OP_ZFAIL_V_RMSK                 0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_STENCIL_OP_ZFAIL_V_WORD                 0
#define NV_096_SET_STENCIL_OP_ZFAIL_V_HIGH_FIELD           0x0000001F /* =31 */
#define NV_096_SET_STENCIL_OP_ZFAIL_V_LOW_FIELD            0x00000000 /* =0 */
#define NV_096_SET_STENCIL_OP_ZFAIL_V_KEEP_ADJ             0x00001E00
#define NV_096_SET_STENCIL_OP_ZFAIL_V_ZERO_ADJ             0x00000000
#define NV_096_SET_STENCIL_OP_ZFAIL_V_REPLACE_ADJ          0x00001E01
#define NV_096_SET_STENCIL_OP_ZFAIL_V_INCRSAT_ADJ          0x00001E02
#define NV_096_SET_STENCIL_OP_ZFAIL_V_DECRSAT_ADJ          0x00001E03
#define NV_096_SET_STENCIL_OP_ZFAIL_V_INVERT_ADJ           0x0000150A
#define NV_096_SET_STENCIL_OP_ZFAIL_V_INCR_ADJ             0x00008507
#define NV_096_SET_STENCIL_OP_ZFAIL_V_DECR_ADJ             0x00008508
#define NV_096_SET_STENCIL_OP_ZFAIL_MSK                    0xFFFFFFFF 
#define NV_096_SET_STENCIL_OP_ZPASS_V_MSK                  0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_STENCIL_OP_ZPASS_V_RMSK                 0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_STENCIL_OP_ZPASS_V_WORD                 0
#define NV_096_SET_STENCIL_OP_ZPASS_V_HIGH_FIELD           0x0000001F /* =31 */
#define NV_096_SET_STENCIL_OP_ZPASS_V_LOW_FIELD            0x00000000 /* =0 */
#define NV_096_SET_STENCIL_OP_ZPASS_V_KEEP_ADJ             0x00001E00
#define NV_096_SET_STENCIL_OP_ZPASS_V_ZERO_ADJ             0x00000000
#define NV_096_SET_STENCIL_OP_ZPASS_V_REPLACE_ADJ          0x00001E01
#define NV_096_SET_STENCIL_OP_ZPASS_V_INCRSAT_ADJ          0x00001E02
#define NV_096_SET_STENCIL_OP_ZPASS_V_DECRSAT_ADJ          0x00001E03
#define NV_096_SET_STENCIL_OP_ZPASS_V_INVERT_ADJ           0x0000150A
#define NV_096_SET_STENCIL_OP_ZPASS_V_INCR_ADJ             0x00008507
#define NV_096_SET_STENCIL_OP_ZPASS_V_DECR_ADJ             0x00008508
#define NV_096_SET_STENCIL_OP_ZPASS_MSK                    0xFFFFFFFF 
#define NV_096_SET_SHADE_MODE_V_MSK                        0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_SHADE_MODE_V_RMSK                       0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_SHADE_MODE_V_WORD                       0
#define NV_096_SET_SHADE_MODE_V_HIGH_FIELD                 0x0000001F /* =31 */
#define NV_096_SET_SHADE_MODE_V_LOW_FIELD                  0x00000000 /* =0 */
#define NV_096_SET_SHADE_MODE_V_FLAT_ADJ                   0x00001D00
#define NV_096_SET_SHADE_MODE_V_SMOOTH_ADJ                 0x00001D01
#define NV_096_SET_SHADE_MODE_MSK                          0xFFFFFFFF 
#define NV_096_SET_LINE_WIDTH_V_MSK                        0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_LINE_WIDTH_V_RMSK                       0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_LINE_WIDTH_V_WORD                       0
#define NV_096_SET_LINE_WIDTH_V_HIGH_FIELD                 0x0000001F /* =31 */
#define NV_096_SET_LINE_WIDTH_V_LOW_FIELD                  0x00000000 /* =0 */
#define NV_096_SET_LINE_WIDTH_MSK                          0xFFFFFFFF 
#define NV_096_SET_POLYGON_OFFSET_SCALE_FACTOR_V_MSK       0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_POLYGON_OFFSET_SCALE_FACTOR_V_RMSK      0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_POLYGON_OFFSET_SCALE_FACTOR_V_WORD      0
#define NV_096_SET_POLYGON_OFFSET_SCALE_FACTOR_V_HIGH_FIELD 0x0000001F /* =31 */
#define NV_096_SET_POLYGON_OFFSET_SCALE_FACTOR_V_LOW_FIELD 0x00000000 /* =0 */
#define NV_096_SET_POLYGON_OFFSET_SCALE_FACTOR_MSK         0xFFFFFFFF 
#define NV_096_SET_POLYGON_OFFSET_BIAS_V_MSK               0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_POLYGON_OFFSET_BIAS_V_RMSK              0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_POLYGON_OFFSET_BIAS_V_WORD              0
#define NV_096_SET_POLYGON_OFFSET_BIAS_V_HIGH_FIELD        0x0000001F /* =31 */
#define NV_096_SET_POLYGON_OFFSET_BIAS_V_LOW_FIELD         0x00000000 /* =0 */
#define NV_096_SET_POLYGON_OFFSET_BIAS_MSK                 0xFFFFFFFF 
#define NV_096_SET_FRONT_POLYGON_MODE_V_MSK                0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_FRONT_POLYGON_MODE_V_RMSK               0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_FRONT_POLYGON_MODE_V_WORD               0
#define NV_096_SET_FRONT_POLYGON_MODE_V_HIGH_FIELD         0x0000001F /* =31 */
#define NV_096_SET_FRONT_POLYGON_MODE_V_LOW_FIELD          0x00000000 /* =0 */
#define NV_096_SET_FRONT_POLYGON_MODE_V_POINT_ADJ          0x00001B00
#define NV_096_SET_FRONT_POLYGON_MODE_V_LINE_ADJ           0x00001B01
#define NV_096_SET_FRONT_POLYGON_MODE_V_FILL_ADJ           0x00001B02
#define NV_096_SET_FRONT_POLYGON_MODE_MSK                  0xFFFFFFFF 
#define NV_096_SET_BACK_POLYGON_MODE_V_MSK                 0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_BACK_POLYGON_MODE_V_RMSK                0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_BACK_POLYGON_MODE_V_WORD                0
#define NV_096_SET_BACK_POLYGON_MODE_V_HIGH_FIELD          0x0000001F /* =31 */
#define NV_096_SET_BACK_POLYGON_MODE_V_LOW_FIELD           0x00000000 /* =0 */
#define NV_096_SET_BACK_POLYGON_MODE_V_POINT_ADJ           0x00001B00
#define NV_096_SET_BACK_POLYGON_MODE_V_LINE_ADJ            0x00001B01
#define NV_096_SET_BACK_POLYGON_MODE_V_FILL_ADJ            0x00001B02
#define NV_096_SET_BACK_POLYGON_MODE_MSK                   0xFFFFFFFF 
#define NV_096_SET_CLIP_MIN_V_MSK                          0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_CLIP_MIN_V_RMSK                         0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_CLIP_MIN_V_WORD                         0
#define NV_096_SET_CLIP_MIN_V_HIGH_FIELD                   0x0000001F /* =31 */
#define NV_096_SET_CLIP_MIN_V_LOW_FIELD                    0x00000000 /* =0 */
#define NV_096_SET_CLIP_MIN_MSK                            0xFFFFFFFF 
#define NV_096_SET_CLIP_MAX_V_MSK                          0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_CLIP_MAX_V_RMSK                         0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_CLIP_MAX_V_WORD                         0
#define NV_096_SET_CLIP_MAX_V_HIGH_FIELD                   0x0000001F /* =31 */
#define NV_096_SET_CLIP_MAX_V_LOW_FIELD                    0x00000000 /* =0 */
#define NV_096_SET_CLIP_MAX_MSK                            0xFFFFFFFF 
#define NV_096_SET_CULL_FACE_V_MSK                         0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_CULL_FACE_V_RMSK                        0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_CULL_FACE_V_WORD                        0
#define NV_096_SET_CULL_FACE_V_HIGH_FIELD                  0x0000001F /* =31 */
#define NV_096_SET_CULL_FACE_V_LOW_FIELD                   0x00000000 /* =0 */
#define NV_096_SET_CULL_FACE_V_FRONT_ADJ                   0x00000404
#define NV_096_SET_CULL_FACE_V_BACK_ADJ                    0x00000405
#define NV_096_SET_CULL_FACE_V_FRONT_AND_BACK_ADJ          0x00000408
#define NV_096_SET_CULL_FACE_MSK                           0xFFFFFFFF 
#define NV_096_SET_FRONT_FACE_V_MSK                        0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_FRONT_FACE_V_RMSK                       0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_FRONT_FACE_V_WORD                       0
#define NV_096_SET_FRONT_FACE_V_HIGH_FIELD                 0x0000001F /* =31 */
#define NV_096_SET_FRONT_FACE_V_LOW_FIELD                  0x00000000 /* =0 */
#define NV_096_SET_FRONT_FACE_V_CW_ADJ                     0x00000900
#define NV_096_SET_FRONT_FACE_V_CCW_ADJ                    0x00000901
#define NV_096_SET_FRONT_FACE_MSK                          0xFFFFFFFF 
#define NV_096_SET_NORMALIZATION_ENABLE_V_MSK              0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_NORMALIZATION_ENABLE_V_RMSK             0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_NORMALIZATION_ENABLE_V_WORD             0
#define NV_096_SET_NORMALIZATION_ENABLE_V_HIGH_FIELD       0x0000001F /* =31 */
#define NV_096_SET_NORMALIZATION_ENABLE_V_LOW_FIELD        0x00000000 /* =0 */
#define NV_096_SET_NORMALIZATION_ENABLE_V_FALSE_ADJ        0x00000000
#define NV_096_SET_NORMALIZATION_ENABLE_V_TRUE_ADJ         0x00000001
#define NV_096_SET_NORMALIZATION_ENABLE_MSK                0xFFFFFFFF 
#define NV_096_SET_MATERIAL_EMISSION_MSK                   0x00000000 
#define NV_096_SET_MATERIAL_ALPHA_MSK                      0x00000000 
#define NV_096_SET_SPECULAR_ENABLE_V_MSK                   0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_SPECULAR_ENABLE_V_RMSK                  0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_SPECULAR_ENABLE_V_WORD                  0
#define NV_096_SET_SPECULAR_ENABLE_V_HIGH_FIELD            0x0000001F /* =31 */
#define NV_096_SET_SPECULAR_ENABLE_V_LOW_FIELD             0x00000000 /* =0 */
#define NV_096_SET_SPECULAR_ENABLE_V_FALSE_ADJ             0x00000000
#define NV_096_SET_SPECULAR_ENABLE_V_TRUE_ADJ              0x00000001
#define NV_096_SET_SPECULAR_ENABLE_MSK                     0xFFFFFFFF 
#define NV_096_SET_LIGHT_ENABLE_MASK_LIGHT0_MSK            0x00000003 /* 1:0 */ 
#define NV_096_SET_LIGHT_ENABLE_MASK_LIGHT0_RMSK           0x00000003 /* 1:0 */ 
#define NV_096_SET_LIGHT_ENABLE_MASK_LIGHT0_WORD           0
#define NV_096_SET_LIGHT_ENABLE_MASK_LIGHT0_HIGH_FIELD     0x00000001 /* =1 */
#define NV_096_SET_LIGHT_ENABLE_MASK_LIGHT0_LOW_FIELD      0x00000000 /* =0 */
#define NV_096_SET_LIGHT_ENABLE_MASK_LIGHT0_OFF_ADJ        0x00000000
#define NV_096_SET_LIGHT_ENABLE_MASK_LIGHT0_INFINITE_ADJ   0x00000001
#define NV_096_SET_LIGHT_ENABLE_MASK_LIGHT0_LOCAL_ADJ      0x00000002
#define NV_096_SET_LIGHT_ENABLE_MASK_LIGHT0_SPOT_ADJ       0x00000003
#define NV_096_SET_LIGHT_ENABLE_MASK_LIGHT1_MSK            0x0000000C /* 3:2 */ 
#define NV_096_SET_LIGHT_ENABLE_MASK_LIGHT1_RMSK           0x00000003 /* 3:2 */ 
#define NV_096_SET_LIGHT_ENABLE_MASK_LIGHT1_WORD           0
#define NV_096_SET_LIGHT_ENABLE_MASK_LIGHT1_HIGH_FIELD     0x00000003 /* =3 */
#define NV_096_SET_LIGHT_ENABLE_MASK_LIGHT1_LOW_FIELD      0x00000002 /* =2 */
#define NV_096_SET_LIGHT_ENABLE_MASK_LIGHT1_OFF_ADJ        0x00000000
#define NV_096_SET_LIGHT_ENABLE_MASK_LIGHT1_INFINITE_ADJ   0x00000004
#define NV_096_SET_LIGHT_ENABLE_MASK_LIGHT1_LOCAL_ADJ      0x00000008
#define NV_096_SET_LIGHT_ENABLE_MASK_LIGHT1_SPOT_ADJ       0x0000000C
#define NV_096_SET_LIGHT_ENABLE_MASK_LIGHT2_MSK            0x00000030 /* 5:4 */ 
#define NV_096_SET_LIGHT_ENABLE_MASK_LIGHT2_RMSK           0x00000003 /* 5:4 */ 
#define NV_096_SET_LIGHT_ENABLE_MASK_LIGHT2_WORD           0
#define NV_096_SET_LIGHT_ENABLE_MASK_LIGHT2_HIGH_FIELD     0x00000005 /* =5 */
#define NV_096_SET_LIGHT_ENABLE_MASK_LIGHT2_LOW_FIELD      0x00000004 /* =4 */
#define NV_096_SET_LIGHT_ENABLE_MASK_LIGHT2_OFF_ADJ        0x00000000
#define NV_096_SET_LIGHT_ENABLE_MASK_LIGHT2_INFINITE_ADJ   0x00000010
#define NV_096_SET_LIGHT_ENABLE_MASK_LIGHT2_LOCAL_ADJ      0x00000020
#define NV_096_SET_LIGHT_ENABLE_MASK_LIGHT2_SPOT_ADJ       0x00000030
#define NV_096_SET_LIGHT_ENABLE_MASK_LIGHT3_MSK            0x000000C0 /* 7:6 */ 
#define NV_096_SET_LIGHT_ENABLE_MASK_LIGHT3_RMSK           0x00000003 /* 7:6 */ 
#define NV_096_SET_LIGHT_ENABLE_MASK_LIGHT3_WORD           0
#define NV_096_SET_LIGHT_ENABLE_MASK_LIGHT3_HIGH_FIELD     0x00000007 /* =7 */
#define NV_096_SET_LIGHT_ENABLE_MASK_LIGHT3_LOW_FIELD      0x00000006 /* =6 */
#define NV_096_SET_LIGHT_ENABLE_MASK_LIGHT3_OFF_ADJ        0x00000000
#define NV_096_SET_LIGHT_ENABLE_MASK_LIGHT3_INFINITE_ADJ   0x00000040
#define NV_096_SET_LIGHT_ENABLE_MASK_LIGHT3_LOCAL_ADJ      0x00000080
#define NV_096_SET_LIGHT_ENABLE_MASK_LIGHT3_SPOT_ADJ       0x000000C0
#define NV_096_SET_LIGHT_ENABLE_MASK_LIGHT4_MSK            0x00000300 /* 9:8 */ 
#define NV_096_SET_LIGHT_ENABLE_MASK_LIGHT4_RMSK           0x00000003 /* 9:8 */ 
#define NV_096_SET_LIGHT_ENABLE_MASK_LIGHT4_WORD           0
#define NV_096_SET_LIGHT_ENABLE_MASK_LIGHT4_HIGH_FIELD     0x00000009 /* =9 */
#define NV_096_SET_LIGHT_ENABLE_MASK_LIGHT4_LOW_FIELD      0x00000008 /* =8 */
#define NV_096_SET_LIGHT_ENABLE_MASK_LIGHT4_OFF_ADJ        0x00000000
#define NV_096_SET_LIGHT_ENABLE_MASK_LIGHT4_INFINITE_ADJ   0x00000100
#define NV_096_SET_LIGHT_ENABLE_MASK_LIGHT4_LOCAL_ADJ      0x00000200
#define NV_096_SET_LIGHT_ENABLE_MASK_LIGHT4_SPOT_ADJ       0x00000300
#define NV_096_SET_LIGHT_ENABLE_MASK_LIGHT5_MSK            0x00000C00 /* 11:10 */ 
#define NV_096_SET_LIGHT_ENABLE_MASK_LIGHT5_RMSK           0x00000003 /* 11:10 */ 
#define NV_096_SET_LIGHT_ENABLE_MASK_LIGHT5_WORD           0
#define NV_096_SET_LIGHT_ENABLE_MASK_LIGHT5_HIGH_FIELD     0x0000000B /* =11 */
#define NV_096_SET_LIGHT_ENABLE_MASK_LIGHT5_LOW_FIELD      0x0000000A /* =10 */
#define NV_096_SET_LIGHT_ENABLE_MASK_LIGHT5_OFF_ADJ        0x00000000
#define NV_096_SET_LIGHT_ENABLE_MASK_LIGHT5_INFINITE_ADJ   0x00000400
#define NV_096_SET_LIGHT_ENABLE_MASK_LIGHT5_LOCAL_ADJ      0x00000800
#define NV_096_SET_LIGHT_ENABLE_MASK_LIGHT5_SPOT_ADJ       0x00000C00
#define NV_096_SET_LIGHT_ENABLE_MASK_LIGHT6_MSK            0x00003000 /* 13:12 */ 
#define NV_096_SET_LIGHT_ENABLE_MASK_LIGHT6_RMSK           0x00000003 /* 13:12 */ 
#define NV_096_SET_LIGHT_ENABLE_MASK_LIGHT6_WORD           0
#define NV_096_SET_LIGHT_ENABLE_MASK_LIGHT6_HIGH_FIELD     0x0000000D /* =13 */
#define NV_096_SET_LIGHT_ENABLE_MASK_LIGHT6_LOW_FIELD      0x0000000C /* =12 */
#define NV_096_SET_LIGHT_ENABLE_MASK_LIGHT6_OFF_ADJ        0x00000000
#define NV_096_SET_LIGHT_ENABLE_MASK_LIGHT6_INFINITE_ADJ   0x00001000
#define NV_096_SET_LIGHT_ENABLE_MASK_LIGHT6_LOCAL_ADJ      0x00002000
#define NV_096_SET_LIGHT_ENABLE_MASK_LIGHT6_SPOT_ADJ       0x00003000
#define NV_096_SET_LIGHT_ENABLE_MASK_LIGHT7_MSK            0x0000C000 /* 15:14 */ 
#define NV_096_SET_LIGHT_ENABLE_MASK_LIGHT7_RMSK           0x00000003 /* 15:14 */ 
#define NV_096_SET_LIGHT_ENABLE_MASK_LIGHT7_WORD           0
#define NV_096_SET_LIGHT_ENABLE_MASK_LIGHT7_HIGH_FIELD     0x0000000F /* =15 */
#define NV_096_SET_LIGHT_ENABLE_MASK_LIGHT7_LOW_FIELD      0x0000000E /* =14 */
#define NV_096_SET_LIGHT_ENABLE_MASK_LIGHT7_OFF_ADJ        0x00000000
#define NV_096_SET_LIGHT_ENABLE_MASK_LIGHT7_INFINITE_ADJ   0x00004000
#define NV_096_SET_LIGHT_ENABLE_MASK_LIGHT7_LOCAL_ADJ      0x00008000
#define NV_096_SET_LIGHT_ENABLE_MASK_LIGHT7_SPOT_ADJ       0x0000C000
#define NV_096_SET_LIGHT_ENABLE_MASK_MSK                   0x0000FFFF 
#define NV_096_SET_TEXGEN_S_V_MSK                          0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_TEXGEN_S_V_RMSK                         0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_TEXGEN_S_V_WORD                         0
#define NV_096_SET_TEXGEN_S_V_HIGH_FIELD                   0x0000001F /* =31 */
#define NV_096_SET_TEXGEN_S_V_LOW_FIELD                    0x00000000 /* =0 */
#define NV_096_SET_TEXGEN_S_V_DISABLE_ADJ                  0x00000000
#define NV_096_SET_TEXGEN_S_V_NORMAL_MAP_ADJ               0x00008511
#define NV_096_SET_TEXGEN_S_V_REFLECTION_MAP_ADJ           0x00008512
#define NV_096_SET_TEXGEN_S_V_EYE_LINEAR_ADJ               0x00002400
#define NV_096_SET_TEXGEN_S_V_OBJECT_LINEAR_ADJ            0x00002401
#define NV_096_SET_TEXGEN_S_V_SPHERE_MAP_ADJ               0x00002402
#define NV_096_SET_TEXGEN_S_V_EMBOSS_ADJ                   0x0000855F
#define NV_096_SET_TEXGEN_S_MSK                            0xFFFFFFFF 
#define NV_096_SET_TEXGEN_T_V_MSK                          0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_TEXGEN_T_V_RMSK                         0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_TEXGEN_T_V_WORD                         0
#define NV_096_SET_TEXGEN_T_V_HIGH_FIELD                   0x0000001F /* =31 */
#define NV_096_SET_TEXGEN_T_V_LOW_FIELD                    0x00000000 /* =0 */
#define NV_096_SET_TEXGEN_T_V_DISABLE_ADJ                  0x00000000
#define NV_096_SET_TEXGEN_T_V_NORMAL_MAP_ADJ               0x00008511
#define NV_096_SET_TEXGEN_T_V_REFLECTION_MAP_ADJ           0x00008512
#define NV_096_SET_TEXGEN_T_V_EYE_LINEAR_ADJ               0x00002400
#define NV_096_SET_TEXGEN_T_V_OBJECT_LINEAR_ADJ            0x00002401
#define NV_096_SET_TEXGEN_T_V_SPHERE_MAP_ADJ               0x00002402
#define NV_096_SET_TEXGEN_T_V_EMBOSS_ADJ                   0x0000855F
#define NV_096_SET_TEXGEN_T_MSK                            0xFFFFFFFF 
#define NV_096_SET_TEXGEN_R_V_MSK                          0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_TEXGEN_R_V_RMSK                         0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_TEXGEN_R_V_WORD                         0
#define NV_096_SET_TEXGEN_R_V_HIGH_FIELD                   0x0000001F /* =31 */
#define NV_096_SET_TEXGEN_R_V_LOW_FIELD                    0x00000000 /* =0 */
#define NV_096_SET_TEXGEN_R_V_DISABLE_ADJ                  0x00000000
#define NV_096_SET_TEXGEN_R_V_NORMAL_MAP_ADJ               0x00008511
#define NV_096_SET_TEXGEN_R_V_REFLECTION_MAP_ADJ           0x00008512
#define NV_096_SET_TEXGEN_R_V_EYE_LINEAR_ADJ               0x00002400
#define NV_096_SET_TEXGEN_R_V_OBJECT_LINEAR_ADJ            0x00002401
#define NV_096_SET_TEXGEN_R_V_EMBOSS_ADJ                   0x0000855F
#define NV_096_SET_TEXGEN_R_MSK                            0xFFFFFFFF 
#define NV_096_SET_TEXGEN_Q_V_MSK                          0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_TEXGEN_Q_V_RMSK                         0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_TEXGEN_Q_V_WORD                         0
#define NV_096_SET_TEXGEN_Q_V_HIGH_FIELD                   0x0000001F /* =31 */
#define NV_096_SET_TEXGEN_Q_V_LOW_FIELD                    0x00000000 /* =0 */
#define NV_096_SET_TEXGEN_Q_V_DISABLE_ADJ                  0x00000000
#define NV_096_SET_TEXGEN_Q_V_EYE_LINEAR_ADJ               0x00002400
#define NV_096_SET_TEXGEN_Q_V_OBJECT_LINEAR_ADJ            0x00002401
#define NV_096_SET_TEXGEN_Q_MSK                            0xFFFFFFFF 
#define NV_096_SET_TEXTURE_MATRIX0_ENABLE_V_MSK            0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_TEXTURE_MATRIX0_ENABLE_V_RMSK           0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_TEXTURE_MATRIX0_ENABLE_V_WORD           0
#define NV_096_SET_TEXTURE_MATRIX0_ENABLE_V_HIGH_FIELD     0x0000001F /* =31 */
#define NV_096_SET_TEXTURE_MATRIX0_ENABLE_V_LOW_FIELD      0x00000000 /* =0 */
#define NV_096_SET_TEXTURE_MATRIX0_ENABLE_V_FALSE_ADJ      0x00000000
#define NV_096_SET_TEXTURE_MATRIX0_ENABLE_V_TRUE_ADJ       0x00000001
#define NV_096_SET_TEXTURE_MATRIX0_ENABLE_MSK              0xFFFFFFFF 
#define NV_096_SET_TEXTURE_MATRIX1_ENABLE_V_MSK            0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_TEXTURE_MATRIX1_ENABLE_V_RMSK           0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_TEXTURE_MATRIX1_ENABLE_V_WORD           0
#define NV_096_SET_TEXTURE_MATRIX1_ENABLE_V_HIGH_FIELD     0x0000001F /* =31 */
#define NV_096_SET_TEXTURE_MATRIX1_ENABLE_V_LOW_FIELD      0x00000000 /* =0 */
#define NV_096_SET_TEXTURE_MATRIX1_ENABLE_V_FALSE_ADJ      0x00000000
#define NV_096_SET_TEXTURE_MATRIX1_ENABLE_V_TRUE_ADJ       0x00000001
#define NV_096_SET_TEXTURE_MATRIX1_ENABLE_MSK              0xFFFFFFFF 
#define NV_096_SET_TLMODE_PASSTHROUGH_MSK                  0x00000001 /* 0:0 */ 
#define NV_096_SET_TLMODE_PASSTHROUGH_RMSK                 0x00000001 /* 0:0 */ 
#define NV_096_SET_TLMODE_PASSTHROUGH_WORD                 0
#define NV_096_SET_TLMODE_PASSTHROUGH_HIGH_FIELD           0x00000000 /* =0 */
#define NV_096_SET_TLMODE_PASSTHROUGH_LOW_FIELD            0x00000000 /* =0 */
#define NV_096_SET_TLMODE_PASSTHROUGH_TRUE_ADJ             0x00000001
#define NV_096_SET_TLMODE_PASSTHROUGH_FALSE_ADJ            0x00000000
#define NV_096_SET_TLMODE_W_DIVIDE_0_MSK                   0x00000002 /* 1:1 */ 
#define NV_096_SET_TLMODE_W_DIVIDE_0_RMSK                  0x00000001 /* 1:1 */ 
#define NV_096_SET_TLMODE_W_DIVIDE_0_WORD                  0
#define NV_096_SET_TLMODE_W_DIVIDE_0_HIGH_FIELD            0x00000001 /* =1 */
#define NV_096_SET_TLMODE_W_DIVIDE_0_LOW_FIELD             0x00000001 /* =1 */
#define NV_096_SET_TLMODE_W_DIVIDE_0_DISABLE_ADJ           0x00000000
#define NV_096_SET_TLMODE_W_DIVIDE_0_ENABLE_ADJ            0x00000002
#define NV_096_SET_TLMODE_W_DIVIDE_1_MSK                   0x00000004 /* 2:2 */ 
#define NV_096_SET_TLMODE_W_DIVIDE_1_RMSK                  0x00000001 /* 2:2 */ 
#define NV_096_SET_TLMODE_W_DIVIDE_1_WORD                  0
#define NV_096_SET_TLMODE_W_DIVIDE_1_HIGH_FIELD            0x00000002 /* =2 */
#define NV_096_SET_TLMODE_W_DIVIDE_1_LOW_FIELD             0x00000002 /* =2 */
#define NV_096_SET_TLMODE_W_DIVIDE_1_DISABLE_ADJ           0x00000000
#define NV_096_SET_TLMODE_W_DIVIDE_1_ENABLE_ADJ            0x00000004
#define NV_096_SET_TLMODE_MSK                              0x00000007 
#define NV_096_SET_POINT_SIZE_V_MSK                        0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_POINT_SIZE_V_RMSK                       0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_POINT_SIZE_V_WORD                       0
#define NV_096_SET_POINT_SIZE_V_HIGH_FIELD                 0x0000001F /* =31 */
#define NV_096_SET_POINT_SIZE_V_LOW_FIELD                  0x00000000 /* =0 */
#define NV_096_SET_POINT_SIZE_MSK                          0xFFFFFFFF 
#define NV_096_SET_SWATH_WIDTH_V_MSK                       0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_SWATH_WIDTH_V_RMSK                      0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_SWATH_WIDTH_V_WORD                      0
#define NV_096_SET_SWATH_WIDTH_V_HIGH_FIELD                0x0000001F /* =31 */
#define NV_096_SET_SWATH_WIDTH_V_LOW_FIELD                 0x00000000 /* =0 */
#define NV_096_SET_SWATH_WIDTH_V_8_ADJ                     0x00000000
#define NV_096_SET_SWATH_WIDTH_V_16_ADJ                    0x00000001
#define NV_096_SET_SWATH_WIDTH_V_32_ADJ                    0x00000002
#define NV_096_SET_SWATH_WIDTH_V_64_ADJ                    0x00000003
#define NV_096_SET_SWATH_WIDTH_MSK                         0xFFFFFFFF 
#define NV_096_SET_FLAT_SHADE_OP_V_MSK                     0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_FLAT_SHADE_OP_V_RMSK                    0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_FLAT_SHADE_OP_V_WORD                    0
#define NV_096_SET_FLAT_SHADE_OP_V_HIGH_FIELD              0x0000001F /* =31 */
#define NV_096_SET_FLAT_SHADE_OP_V_LOW_FIELD               0x00000000 /* =0 */
#define NV_096_SET_FLAT_SHADE_OP_V_LAST_VTX_ADJ            0x00000000
#define NV_096_SET_FLAT_SHADE_OP_V_FIRST_VTX_ADJ           0x00000001
#define NV_096_SET_FLAT_SHADE_OP_MSK                       0xFFFFFFFF 
#define NV_096_SET_MODEL_VIEW_MATRIX0_MSK                  0x00000000 
#define NV_096_SET_MODEL_VIEW_MATRIX1_MSK                  0x00000000 
#define NV_096_SET_INVERSE_MODEL_VIEW_MATRIX0_MSK          0x00000000 
#define NV_096_SET_INVERSE_MODEL_VIEW_MATRIX1_MSK          0x00000000 
#define NV_096_SET_COMPOSITE_MATRIX_MSK                    0x00000000 
#define NV_096_SET_TEXTURE_MATRIX0_MSK                     0x00000000 
#define NV_096_SET_TEXTURE_MATRIX1_MSK                     0x00000000 
#define NV_096_SET_TEXGEN_SPLANE0_MSK                      0x00000000 
#define NV_096_SET_TEXGEN_TPLANE0_MSK                      0x00000000 
#define NV_096_SET_TEXGEN_RPLANE0_MSK                      0x00000000 
#define NV_096_SET_TEXGEN_QPLANE0_MSK                      0x00000000 
#define NV_096_SET_TEXGEN_SPLANE1_MSK                      0x00000000 
#define NV_096_SET_TEXGEN_TPLANE1_MSK                      0x00000000 
#define NV_096_SET_TEXGEN_RPLANE1_MSK                      0x00000000 
#define NV_096_SET_TEXGEN_QPLANE1_MSK                      0x00000000 
#define NV_096_SET_FOG_PARAMS_MSK                          0x00000000 
#define NV_096_SET_FOG_PLANE_MSK                           0x00000000 
#define NV_096_SET_SPECULAR_PARAMS_MSK                     0x00000000 
#define NV_096_SET_SCENE_AMBIENT_COLOR_MSK                 0x00000000 
#define NV_096_SET_VIEWPORT_OFFSET_MSK                     0x00000000 
#define NV_096_SET_POINT_PARAMS_MSK                        0x00000000 
#define NV_096_SET_EYE_POSITION_MSK                        0x00000000 
#define NV_096_SET_LIGHT_LOCAL_RANGE_MSK                   0x00000000 
#define NV_096_SET_VERTEX3F_MSK                            0x00000000 
#define NV_096_SET_VERTEX4F_MSK                            0x00000000 
#define NV_096_SET_VERTEX4S_MSK                            0x00000000 
#define NV_096_SET_NORMAL3F_MSK                            0x00000000 
#define NV_096_SET_NORMAL3S_MSK                            0x00000000 
#define NV_096_SET_DIFFUSE_COLOR4F_MSK                     0x00000000 
#define NV_096_SET_DIFFUSE_COLOR3F_MSK                     0x00000000 
#define NV_096_SET_DIFFUSE_COLOR4UB_MSK                    0x00000000 
#define NV_096_SET_SPECULAR_COLOR4F_MSK                    0x00000000 
#define NV_096_SET_SPECULAR_COLOR3F_MSK                    0x00000000 
#define NV_096_SET_SPECULAR_COLOR4UB_MSK                   0x00000000 
#define NV_096_SET_TEXCOORD0_2F_MSK                        0x00000000 
#define NV_096_SET_TEXCOORD0_2S_MSK                        0x00000000 
#define NV_096_SET_TEXCOORD0_4F_MSK                        0x00000000 
#define NV_096_SET_TEXCOORD0_4S_MSK                        0x00000000 
#define NV_096_SET_TEXCOORD1_2F_MSK                        0x00000000 
#define NV_096_SET_TEXCOORD1_2S_MSK                        0x00000000 
#define NV_096_SET_TEXCOORD1_4F_MSK                        0x00000000 
#define NV_096_SET_TEXCOORD1_4S_MSK                        0x00000000 
#define NV_096_SET_FOG1F_MSK                               0x00000000 
#define NV_096_SET_WEIGHT1F_MSK                            0x00000000 
#define NV_096_SET_EDGE_FLAG_MSK                           0x00000000 
#define NV_096_INVALIDATE_VERTEX_CACHE_FILE_MSK            0x00000000 
#define NV_096_INVALIDATE_VERTEX_FILE_MSK                  0x00000000 
#define NV_096_TL_NOP_MSK                                  0x00000000 
#define NV_096_TL_SYNC_MSK                                 0x00000000 
#define NV_096_SET_VERTEX_ARRAY_OFFSET_OFFSET_MSK          0x0FFFFFFF /* 27:0 */ 
#define NV_096_SET_VERTEX_ARRAY_OFFSET_OFFSET_RMSK         0x0FFFFFFF /* 27:0 */ 
#define NV_096_SET_VERTEX_ARRAY_OFFSET_OFFSET_WORD         0
#define NV_096_SET_VERTEX_ARRAY_OFFSET_OFFSET_HIGH_FIELD   0x0000001B /* =27 */
#define NV_096_SET_VERTEX_ARRAY_OFFSET_OFFSET_LOW_FIELD    0x00000000 /* =0 */
#define NV_096_SET_VERTEX_ARRAY_OFFSET_MSK                 0x0FFFFFFF 
#define NV_096_SET_VERTEX_ARRAY_FORMAT_W_MSK               0xFF000000 /* 31:24 */ 
#define NV_096_SET_VERTEX_ARRAY_FORMAT_W_RMSK              0x000000FF /* 31:24 */ 
#define NV_096_SET_VERTEX_ARRAY_FORMAT_W_WORD              0
#define NV_096_SET_VERTEX_ARRAY_FORMAT_W_HIGH_FIELD        0x0000001F /* =31 */
#define NV_096_SET_VERTEX_ARRAY_FORMAT_W_LOW_FIELD         0x00000018 /* =24 */
#define NV_096_SET_VERTEX_ARRAY_FORMAT_W_NONE_ADJ          0x00000000
#define NV_096_SET_VERTEX_ARRAY_FORMAT_W_PRESENT_ADJ       0x01000000
#define NV_096_SET_VERTEX_ARRAY_FORMAT_STRIDE_MSK          0x00FFFF00 /* 23:8 */ 
#define NV_096_SET_VERTEX_ARRAY_FORMAT_STRIDE_RMSK         0x0000FFFF /* 23:8 */ 
#define NV_096_SET_VERTEX_ARRAY_FORMAT_STRIDE_WORD         0
#define NV_096_SET_VERTEX_ARRAY_FORMAT_STRIDE_HIGH_FIELD   0x00000017 /* =23 */
#define NV_096_SET_VERTEX_ARRAY_FORMAT_STRIDE_LOW_FIELD    0x00000008 /* =8 */
#define NV_096_SET_VERTEX_ARRAY_FORMAT_SIZE_MSK            0x000000F0 /* 7:4 */ 
#define NV_096_SET_VERTEX_ARRAY_FORMAT_SIZE_RMSK           0x0000000F /* 7:4 */ 
#define NV_096_SET_VERTEX_ARRAY_FORMAT_SIZE_WORD           0
#define NV_096_SET_VERTEX_ARRAY_FORMAT_SIZE_HIGH_FIELD     0x00000007 /* =7 */
#define NV_096_SET_VERTEX_ARRAY_FORMAT_SIZE_LOW_FIELD      0x00000004 /* =4 */
#define NV_096_SET_VERTEX_ARRAY_FORMAT_SIZE_2_ADJ          0x00000020
#define NV_096_SET_VERTEX_ARRAY_FORMAT_SIZE_3_ADJ          0x00000030
#define NV_096_SET_VERTEX_ARRAY_FORMAT_SIZE_4_ADJ          0x00000040
#define NV_096_SET_VERTEX_ARRAY_FORMAT_TYPE_MSK            0x0000000F /* 3:0 */ 
#define NV_096_SET_VERTEX_ARRAY_FORMAT_TYPE_RMSK           0x0000000F /* 3:0 */ 
#define NV_096_SET_VERTEX_ARRAY_FORMAT_TYPE_WORD           0
#define NV_096_SET_VERTEX_ARRAY_FORMAT_TYPE_HIGH_FIELD     0x00000003 /* =3 */
#define NV_096_SET_VERTEX_ARRAY_FORMAT_TYPE_LOW_FIELD      0x00000000 /* =0 */
#define NV_096_SET_VERTEX_ARRAY_FORMAT_TYPE_SHORT_ADJ      0x00000001
#define NV_096_SET_VERTEX_ARRAY_FORMAT_TYPE_FLOAT_ADJ      0x00000002
#define NV_096_SET_VERTEX_ARRAY_FORMAT_MSK                 0xFFFFFFFF 
#define NV_096_SET_DIFFUSE_ARRAY_OFFSET_OFFSET_MSK         0x0FFFFFFF /* 27:0 */ 
#define NV_096_SET_DIFFUSE_ARRAY_OFFSET_OFFSET_RMSK        0x0FFFFFFF /* 27:0 */ 
#define NV_096_SET_DIFFUSE_ARRAY_OFFSET_OFFSET_WORD        0
#define NV_096_SET_DIFFUSE_ARRAY_OFFSET_OFFSET_HIGH_FIELD  0x0000001B /* =27 */
#define NV_096_SET_DIFFUSE_ARRAY_OFFSET_OFFSET_LOW_FIELD   0x00000000 /* =0 */
#define NV_096_SET_DIFFUSE_ARRAY_OFFSET_MSK                0x0FFFFFFF 
#define NV_096_SET_DIFFUSE_ARRAY_FORMAT_STRIDE_MSK         0xFFFFFF00 /* 31:8 */ 
#define NV_096_SET_DIFFUSE_ARRAY_FORMAT_STRIDE_RMSK        0x00FFFFFF /* 31:8 */ 
#define NV_096_SET_DIFFUSE_ARRAY_FORMAT_STRIDE_WORD        0
#define NV_096_SET_DIFFUSE_ARRAY_FORMAT_STRIDE_HIGH_FIELD  0x0000001F /* =31 */
#define NV_096_SET_DIFFUSE_ARRAY_FORMAT_STRIDE_LOW_FIELD   0x00000008 /* =8 */
#define NV_096_SET_DIFFUSE_ARRAY_FORMAT_SIZE_MSK           0x000000F0 /* 7:4 */ 
#define NV_096_SET_DIFFUSE_ARRAY_FORMAT_SIZE_RMSK          0x0000000F /* 7:4 */ 
#define NV_096_SET_DIFFUSE_ARRAY_FORMAT_SIZE_WORD          0
#define NV_096_SET_DIFFUSE_ARRAY_FORMAT_SIZE_HIGH_FIELD    0x00000007 /* =7 */
#define NV_096_SET_DIFFUSE_ARRAY_FORMAT_SIZE_LOW_FIELD     0x00000004 /* =4 */
#define NV_096_SET_DIFFUSE_ARRAY_FORMAT_SIZE_0_ADJ         0x00000000
#define NV_096_SET_DIFFUSE_ARRAY_FORMAT_SIZE_3_ADJ         0x00000030
#define NV_096_SET_DIFFUSE_ARRAY_FORMAT_SIZE_4_ADJ         0x00000040
#define NV_096_SET_DIFFUSE_ARRAY_FORMAT_TYPE_MSK           0x0000000F /* 3:0 */ 
#define NV_096_SET_DIFFUSE_ARRAY_FORMAT_TYPE_RMSK          0x0000000F /* 3:0 */ 
#define NV_096_SET_DIFFUSE_ARRAY_FORMAT_TYPE_WORD          0
#define NV_096_SET_DIFFUSE_ARRAY_FORMAT_TYPE_HIGH_FIELD    0x00000003 /* =3 */
#define NV_096_SET_DIFFUSE_ARRAY_FORMAT_TYPE_LOW_FIELD     0x00000000 /* =0 */
#define NV_096_SET_DIFFUSE_ARRAY_FORMAT_TYPE_UNSIGNED_BYTE_BGRA_ADJ 0x00000000
#define NV_096_SET_DIFFUSE_ARRAY_FORMAT_TYPE_FLOAT_ADJ     0x00000002
#define NV_096_SET_DIFFUSE_ARRAY_FORMAT_TYPE_UNSIGNED_BYTE_RGBA_ADJ 0x00000004
#define NV_096_SET_DIFFUSE_ARRAY_FORMAT_MSK                0xFFFFFFFF 
#define NV_096_SET_SPECULAR_ARRAY_OFFSET_OFFSET_MSK        0x0FFFFFFF /* 27:0 */ 
#define NV_096_SET_SPECULAR_ARRAY_OFFSET_OFFSET_RMSK       0x0FFFFFFF /* 27:0 */ 
#define NV_096_SET_SPECULAR_ARRAY_OFFSET_OFFSET_WORD       0
#define NV_096_SET_SPECULAR_ARRAY_OFFSET_OFFSET_HIGH_FIELD 0x0000001B /* =27 */
#define NV_096_SET_SPECULAR_ARRAY_OFFSET_OFFSET_LOW_FIELD  0x00000000 /* =0 */
#define NV_096_SET_SPECULAR_ARRAY_OFFSET_MSK               0x0FFFFFFF 
#define NV_096_SET_SPECULAR_ARRAY_FORMAT_STRIDE_MSK        0xFFFFFF00 /* 31:8 */ 
#define NV_096_SET_SPECULAR_ARRAY_FORMAT_STRIDE_RMSK       0x00FFFFFF /* 31:8 */ 
#define NV_096_SET_SPECULAR_ARRAY_FORMAT_STRIDE_WORD       0
#define NV_096_SET_SPECULAR_ARRAY_FORMAT_STRIDE_HIGH_FIELD 0x0000001F /* =31 */
#define NV_096_SET_SPECULAR_ARRAY_FORMAT_STRIDE_LOW_FIELD  0x00000008 /* =8 */
#define NV_096_SET_SPECULAR_ARRAY_FORMAT_SIZE_MSK          0x000000F0 /* 7:4 */ 
#define NV_096_SET_SPECULAR_ARRAY_FORMAT_SIZE_RMSK         0x0000000F /* 7:4 */ 
#define NV_096_SET_SPECULAR_ARRAY_FORMAT_SIZE_WORD         0
#define NV_096_SET_SPECULAR_ARRAY_FORMAT_SIZE_HIGH_FIELD   0x00000007 /* =7 */
#define NV_096_SET_SPECULAR_ARRAY_FORMAT_SIZE_LOW_FIELD    0x00000004 /* =4 */
#define NV_096_SET_SPECULAR_ARRAY_FORMAT_SIZE_0_ADJ        0x00000000
#define NV_096_SET_SPECULAR_ARRAY_FORMAT_SIZE_3_ADJ        0x00000030
#define NV_096_SET_SPECULAR_ARRAY_FORMAT_SIZE_4_ADJ        0x00000040
#define NV_096_SET_SPECULAR_ARRAY_FORMAT_TYPE_MSK          0x0000000F /* 3:0 */ 
#define NV_096_SET_SPECULAR_ARRAY_FORMAT_TYPE_RMSK         0x0000000F /* 3:0 */ 
#define NV_096_SET_SPECULAR_ARRAY_FORMAT_TYPE_WORD         0
#define NV_096_SET_SPECULAR_ARRAY_FORMAT_TYPE_HIGH_FIELD   0x00000003 /* =3 */
#define NV_096_SET_SPECULAR_ARRAY_FORMAT_TYPE_LOW_FIELD    0x00000000 /* =0 */
#define NV_096_SET_SPECULAR_ARRAY_FORMAT_TYPE_UNSIGNED_BYTE_BGRA_ADJ 0x00000000
#define NV_096_SET_SPECULAR_ARRAY_FORMAT_TYPE_FLOAT_ADJ    0x00000002
#define NV_096_SET_SPECULAR_ARRAY_FORMAT_TYPE_UNSIGNED_BYTE_RGBA_ADJ 0x00000004
#define NV_096_SET_SPECULAR_ARRAY_FORMAT_MSK               0xFFFFFFFF 
#define NV_096_SET_TEX_COORD0_ARRAY_OFFSET_OFFSET_MSK      0x0FFFFFFF /* 27:0 */ 
#define NV_096_SET_TEX_COORD0_ARRAY_OFFSET_OFFSET_RMSK     0x0FFFFFFF /* 27:0 */ 
#define NV_096_SET_TEX_COORD0_ARRAY_OFFSET_OFFSET_WORD     0
#define NV_096_SET_TEX_COORD0_ARRAY_OFFSET_OFFSET_HIGH_FIELD 0x0000001B /* =27 */
#define NV_096_SET_TEX_COORD0_ARRAY_OFFSET_OFFSET_LOW_FIELD 0x00000000 /* =0 */
#define NV_096_SET_TEX_COORD0_ARRAY_OFFSET_MSK             0x0FFFFFFF 
#define NV_096_SET_TEX_COORD0_ARRAY_FORMAT_STRIDE_MSK      0xFFFFFF00 /* 31:8 */ 
#define NV_096_SET_TEX_COORD0_ARRAY_FORMAT_STRIDE_RMSK     0x00FFFFFF /* 31:8 */ 
#define NV_096_SET_TEX_COORD0_ARRAY_FORMAT_STRIDE_WORD     0
#define NV_096_SET_TEX_COORD0_ARRAY_FORMAT_STRIDE_HIGH_FIELD 0x0000001F /* =31 */
#define NV_096_SET_TEX_COORD0_ARRAY_FORMAT_STRIDE_LOW_FIELD 0x00000008 /* =8 */
#define NV_096_SET_TEX_COORD0_ARRAY_FORMAT_SIZE_MSK        0x000000F0 /* 7:4 */ 
#define NV_096_SET_TEX_COORD0_ARRAY_FORMAT_SIZE_RMSK       0x0000000F /* 7:4 */ 
#define NV_096_SET_TEX_COORD0_ARRAY_FORMAT_SIZE_WORD       0
#define NV_096_SET_TEX_COORD0_ARRAY_FORMAT_SIZE_HIGH_FIELD 0x00000007 /* =7 */
#define NV_096_SET_TEX_COORD0_ARRAY_FORMAT_SIZE_LOW_FIELD  0x00000004 /* =4 */
#define NV_096_SET_TEX_COORD0_ARRAY_FORMAT_SIZE_0_ADJ      0x00000000
#define NV_096_SET_TEX_COORD0_ARRAY_FORMAT_SIZE_1_ADJ      0x00000010
#define NV_096_SET_TEX_COORD0_ARRAY_FORMAT_SIZE_2_ADJ      0x00000020
#define NV_096_SET_TEX_COORD0_ARRAY_FORMAT_SIZE_3_ADJ      0x00000030
#define NV_096_SET_TEX_COORD0_ARRAY_FORMAT_SIZE_4_ADJ      0x00000040
#define NV_096_SET_TEX_COORD0_ARRAY_FORMAT_TYPE_MSK        0x0000000F /* 3:0 */ 
#define NV_096_SET_TEX_COORD0_ARRAY_FORMAT_TYPE_RMSK       0x0000000F /* 3:0 */ 
#define NV_096_SET_TEX_COORD0_ARRAY_FORMAT_TYPE_WORD       0
#define NV_096_SET_TEX_COORD0_ARRAY_FORMAT_TYPE_HIGH_FIELD 0x00000003 /* =3 */
#define NV_096_SET_TEX_COORD0_ARRAY_FORMAT_TYPE_LOW_FIELD  0x00000000 /* =0 */
#define NV_096_SET_TEX_COORD0_ARRAY_FORMAT_TYPE_SHORT_ADJ  0x00000001
#define NV_096_SET_TEX_COORD0_ARRAY_FORMAT_TYPE_FLOAT_ADJ  0x00000002
#define NV_096_SET_TEX_COORD0_ARRAY_FORMAT_MSK             0xFFFFFFFF 
#define NV_096_SET_TEX_COORD1_ARRAY_OFFSET_OFFSET_MSK      0x0FFFFFFF /* 27:0 */ 
#define NV_096_SET_TEX_COORD1_ARRAY_OFFSET_OFFSET_RMSK     0x0FFFFFFF /* 27:0 */ 
#define NV_096_SET_TEX_COORD1_ARRAY_OFFSET_OFFSET_WORD     0
#define NV_096_SET_TEX_COORD1_ARRAY_OFFSET_OFFSET_HIGH_FIELD 0x0000001B /* =27 */
#define NV_096_SET_TEX_COORD1_ARRAY_OFFSET_OFFSET_LOW_FIELD 0x00000000 /* =0 */
#define NV_096_SET_TEX_COORD1_ARRAY_OFFSET_MSK             0x0FFFFFFF 
#define NV_096_SET_TEX_COORD1_ARRAY_FORMAT_STRIDE_MSK      0xFFFFFF00 /* 31:8 */ 
#define NV_096_SET_TEX_COORD1_ARRAY_FORMAT_STRIDE_RMSK     0x00FFFFFF /* 31:8 */ 
#define NV_096_SET_TEX_COORD1_ARRAY_FORMAT_STRIDE_WORD     0
#define NV_096_SET_TEX_COORD1_ARRAY_FORMAT_STRIDE_HIGH_FIELD 0x0000001F /* =31 */
#define NV_096_SET_TEX_COORD1_ARRAY_FORMAT_STRIDE_LOW_FIELD 0x00000008 /* =8 */
#define NV_096_SET_TEX_COORD1_ARRAY_FORMAT_SIZE_MSK        0x000000F0 /* 7:4 */ 
#define NV_096_SET_TEX_COORD1_ARRAY_FORMAT_SIZE_RMSK       0x0000000F /* 7:4 */ 
#define NV_096_SET_TEX_COORD1_ARRAY_FORMAT_SIZE_WORD       0
#define NV_096_SET_TEX_COORD1_ARRAY_FORMAT_SIZE_HIGH_FIELD 0x00000007 /* =7 */
#define NV_096_SET_TEX_COORD1_ARRAY_FORMAT_SIZE_LOW_FIELD  0x00000004 /* =4 */
#define NV_096_SET_TEX_COORD1_ARRAY_FORMAT_SIZE_0_ADJ      0x00000000
#define NV_096_SET_TEX_COORD1_ARRAY_FORMAT_SIZE_1_ADJ      0x00000010
#define NV_096_SET_TEX_COORD1_ARRAY_FORMAT_SIZE_2_ADJ      0x00000020
#define NV_096_SET_TEX_COORD1_ARRAY_FORMAT_SIZE_3_ADJ      0x00000030
#define NV_096_SET_TEX_COORD1_ARRAY_FORMAT_SIZE_4_ADJ      0x00000040
#define NV_096_SET_TEX_COORD1_ARRAY_FORMAT_TYPE_MSK        0x0000000F /* 3:0 */ 
#define NV_096_SET_TEX_COORD1_ARRAY_FORMAT_TYPE_RMSK       0x0000000F /* 3:0 */ 
#define NV_096_SET_TEX_COORD1_ARRAY_FORMAT_TYPE_WORD       0
#define NV_096_SET_TEX_COORD1_ARRAY_FORMAT_TYPE_HIGH_FIELD 0x00000003 /* =3 */
#define NV_096_SET_TEX_COORD1_ARRAY_FORMAT_TYPE_LOW_FIELD  0x00000000 /* =0 */
#define NV_096_SET_TEX_COORD1_ARRAY_FORMAT_TYPE_SHORT_ADJ  0x00000001
#define NV_096_SET_TEX_COORD1_ARRAY_FORMAT_TYPE_FLOAT_ADJ  0x00000002
#define NV_096_SET_TEX_COORD1_ARRAY_FORMAT_MSK             0xFFFFFFFF 
#define NV_096_SET_NORMAL_ARRAY_OFFSET_OFFSET_MSK          0x0FFFFFFF /* 27:0 */ 
#define NV_096_SET_NORMAL_ARRAY_OFFSET_OFFSET_RMSK         0x0FFFFFFF /* 27:0 */ 
#define NV_096_SET_NORMAL_ARRAY_OFFSET_OFFSET_WORD         0
#define NV_096_SET_NORMAL_ARRAY_OFFSET_OFFSET_HIGH_FIELD   0x0000001B /* =27 */
#define NV_096_SET_NORMAL_ARRAY_OFFSET_OFFSET_LOW_FIELD    0x00000000 /* =0 */
#define NV_096_SET_NORMAL_ARRAY_OFFSET_MSK                 0x0FFFFFFF 
#define NV_096_SET_NORMAL_ARRAY_FORMAT_STRIDE_MSK          0xFFFFFF00 /* 31:8 */ 
#define NV_096_SET_NORMAL_ARRAY_FORMAT_STRIDE_RMSK         0x00FFFFFF /* 31:8 */ 
#define NV_096_SET_NORMAL_ARRAY_FORMAT_STRIDE_WORD         0
#define NV_096_SET_NORMAL_ARRAY_FORMAT_STRIDE_HIGH_FIELD   0x0000001F /* =31 */
#define NV_096_SET_NORMAL_ARRAY_FORMAT_STRIDE_LOW_FIELD    0x00000008 /* =8 */
#define NV_096_SET_NORMAL_ARRAY_FORMAT_SIZE_MSK            0x000000F0 /* 7:4 */ 
#define NV_096_SET_NORMAL_ARRAY_FORMAT_SIZE_RMSK           0x0000000F /* 7:4 */ 
#define NV_096_SET_NORMAL_ARRAY_FORMAT_SIZE_WORD           0
#define NV_096_SET_NORMAL_ARRAY_FORMAT_SIZE_HIGH_FIELD     0x00000007 /* =7 */
#define NV_096_SET_NORMAL_ARRAY_FORMAT_SIZE_LOW_FIELD      0x00000004 /* =4 */
#define NV_096_SET_NORMAL_ARRAY_FORMAT_SIZE_0_ADJ          0x00000000
#define NV_096_SET_NORMAL_ARRAY_FORMAT_SIZE_3_ADJ          0x00000030
#define NV_096_SET_NORMAL_ARRAY_FORMAT_TYPE_MSK            0x0000000F /* 3:0 */ 
#define NV_096_SET_NORMAL_ARRAY_FORMAT_TYPE_RMSK           0x0000000F /* 3:0 */ 
#define NV_096_SET_NORMAL_ARRAY_FORMAT_TYPE_WORD           0
#define NV_096_SET_NORMAL_ARRAY_FORMAT_TYPE_HIGH_FIELD     0x00000003 /* =3 */
#define NV_096_SET_NORMAL_ARRAY_FORMAT_TYPE_LOW_FIELD      0x00000000 /* =0 */
#define NV_096_SET_NORMAL_ARRAY_FORMAT_TYPE_SHORT_ADJ      0x00000001
#define NV_096_SET_NORMAL_ARRAY_FORMAT_TYPE_FLOAT_ADJ      0x00000002
#define NV_096_SET_NORMAL_ARRAY_FORMAT_MSK                 0xFFFFFFFF 
#define NV_096_SET_WEIGHT_ARRAY_OFFSET_OFFSET_MSK          0x0FFFFFFF /* 27:0 */ 
#define NV_096_SET_WEIGHT_ARRAY_OFFSET_OFFSET_RMSK         0x0FFFFFFF /* 27:0 */ 
#define NV_096_SET_WEIGHT_ARRAY_OFFSET_OFFSET_WORD         0
#define NV_096_SET_WEIGHT_ARRAY_OFFSET_OFFSET_HIGH_FIELD   0x0000001B /* =27 */
#define NV_096_SET_WEIGHT_ARRAY_OFFSET_OFFSET_LOW_FIELD    0x00000000 /* =0 */
#define NV_096_SET_WEIGHT_ARRAY_OFFSET_MSK                 0x0FFFFFFF 
#define NV_096_SET_WEIGHT_ARRAY_FORMAT_STRIDE_MSK          0xFFFFFF00 /* 31:8 */ 
#define NV_096_SET_WEIGHT_ARRAY_FORMAT_STRIDE_RMSK         0x00FFFFFF /* 31:8 */ 
#define NV_096_SET_WEIGHT_ARRAY_FORMAT_STRIDE_WORD         0
#define NV_096_SET_WEIGHT_ARRAY_FORMAT_STRIDE_HIGH_FIELD   0x0000001F /* =31 */
#define NV_096_SET_WEIGHT_ARRAY_FORMAT_STRIDE_LOW_FIELD    0x00000008 /* =8 */
#define NV_096_SET_WEIGHT_ARRAY_FORMAT_SIZE_MSK            0x000000F0 /* 7:4 */ 
#define NV_096_SET_WEIGHT_ARRAY_FORMAT_SIZE_RMSK           0x0000000F /* 7:4 */ 
#define NV_096_SET_WEIGHT_ARRAY_FORMAT_SIZE_WORD           0
#define NV_096_SET_WEIGHT_ARRAY_FORMAT_SIZE_HIGH_FIELD     0x00000007 /* =7 */
#define NV_096_SET_WEIGHT_ARRAY_FORMAT_SIZE_LOW_FIELD      0x00000004 /* =4 */
#define NV_096_SET_WEIGHT_ARRAY_FORMAT_SIZE_0_ADJ          0x00000000
#define NV_096_SET_WEIGHT_ARRAY_FORMAT_SIZE_1_ADJ          0x00000010
#define NV_096_SET_WEIGHT_ARRAY_FORMAT_TYPE_MSK            0x0000000F /* 3:0 */ 
#define NV_096_SET_WEIGHT_ARRAY_FORMAT_TYPE_RMSK           0x0000000F /* 3:0 */ 
#define NV_096_SET_WEIGHT_ARRAY_FORMAT_TYPE_WORD           0
#define NV_096_SET_WEIGHT_ARRAY_FORMAT_TYPE_HIGH_FIELD     0x00000003 /* =3 */
#define NV_096_SET_WEIGHT_ARRAY_FORMAT_TYPE_LOW_FIELD      0x00000000 /* =0 */
#define NV_096_SET_WEIGHT_ARRAY_FORMAT_TYPE_SHORT_ADJ      0x00000001
#define NV_096_SET_WEIGHT_ARRAY_FORMAT_TYPE_FLOAT_ADJ      0x00000002
#define NV_096_SET_WEIGHT_ARRAY_FORMAT_MSK                 0xFFFFFFFF 
#define NV_096_SET_FOG_ARRAY_OFFSET_OFFSET_MSK             0x0FFFFFFF /* 27:0 */ 
#define NV_096_SET_FOG_ARRAY_OFFSET_OFFSET_RMSK            0x0FFFFFFF /* 27:0 */ 
#define NV_096_SET_FOG_ARRAY_OFFSET_OFFSET_WORD            0
#define NV_096_SET_FOG_ARRAY_OFFSET_OFFSET_HIGH_FIELD      0x0000001B /* =27 */
#define NV_096_SET_FOG_ARRAY_OFFSET_OFFSET_LOW_FIELD       0x00000000 /* =0 */
#define NV_096_SET_FOG_ARRAY_OFFSET_MSK                    0x0FFFFFFF 
#define NV_096_SET_FOG_ARRAY_FORMAT_STRIDE_MSK             0xFFFFFF00 /* 31:8 */ 
#define NV_096_SET_FOG_ARRAY_FORMAT_STRIDE_RMSK            0x00FFFFFF /* 31:8 */ 
#define NV_096_SET_FOG_ARRAY_FORMAT_STRIDE_WORD            0
#define NV_096_SET_FOG_ARRAY_FORMAT_STRIDE_HIGH_FIELD      0x0000001F /* =31 */
#define NV_096_SET_FOG_ARRAY_FORMAT_STRIDE_LOW_FIELD       0x00000008 /* =8 */
#define NV_096_SET_FOG_ARRAY_FORMAT_SIZE_MSK               0x000000F0 /* 7:4 */ 
#define NV_096_SET_FOG_ARRAY_FORMAT_SIZE_RMSK              0x0000000F /* 7:4 */ 
#define NV_096_SET_FOG_ARRAY_FORMAT_SIZE_WORD              0
#define NV_096_SET_FOG_ARRAY_FORMAT_SIZE_HIGH_FIELD        0x00000007 /* =7 */
#define NV_096_SET_FOG_ARRAY_FORMAT_SIZE_LOW_FIELD         0x00000004 /* =4 */
#define NV_096_SET_FOG_ARRAY_FORMAT_SIZE_0_ADJ             0x00000000
#define NV_096_SET_FOG_ARRAY_FORMAT_SIZE_1_ADJ             0x00000010
#define NV_096_SET_FOG_ARRAY_FORMAT_TYPE_MSK               0x0000000F /* 3:0 */ 
#define NV_096_SET_FOG_ARRAY_FORMAT_TYPE_RMSK              0x0000000F /* 3:0 */ 
#define NV_096_SET_FOG_ARRAY_FORMAT_TYPE_WORD              0
#define NV_096_SET_FOG_ARRAY_FORMAT_TYPE_HIGH_FIELD        0x00000003 /* =3 */
#define NV_096_SET_FOG_ARRAY_FORMAT_TYPE_LOW_FIELD         0x00000000 /* =0 */
#define NV_096_SET_FOG_ARRAY_FORMAT_TYPE_SHORT_ADJ         0x00000001
#define NV_096_SET_FOG_ARRAY_FORMAT_TYPE_FLOAT_ADJ         0x00000002
#define NV_096_SET_FOG_ARRAY_FORMAT_MSK                    0xFFFFFFFF 
#define NV_096_SET_LOGIC_OP_ENABLE_V_MSK                   0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_LOGIC_OP_ENABLE_V_RMSK                  0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_LOGIC_OP_ENABLE_V_WORD                  0
#define NV_096_SET_LOGIC_OP_ENABLE_V_HIGH_FIELD            0x0000001F /* =31 */
#define NV_096_SET_LOGIC_OP_ENABLE_V_LOW_FIELD             0x00000000 /* =0 */
#define NV_096_SET_LOGIC_OP_ENABLE_V_FALSE_ADJ             0x00000000
#define NV_096_SET_LOGIC_OP_ENABLE_V_TRUE_ADJ              0x00000001
#define NV_096_SET_LOGIC_OP_ENABLE_MSK                     0xFFFFFFFF 
#define NV_096_SET_LOGIC_OP_V_MSK                          0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_LOGIC_OP_V_RMSK                         0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_LOGIC_OP_V_WORD                         0
#define NV_096_SET_LOGIC_OP_V_HIGH_FIELD                   0x0000001F /* =31 */
#define NV_096_SET_LOGIC_OP_V_LOW_FIELD                    0x00000000 /* =0 */
#define NV_096_SET_LOGIC_OP_V_CLEAR_ADJ                    0x00000000
#define NV_096_SET_LOGIC_OP_V_AND_ADJ                      0x00000001
#define NV_096_SET_LOGIC_OP_V_AND_REVERSE_ADJ              0x00000002
#define NV_096_SET_LOGIC_OP_V_COPY_ADJ                     0x00000003
#define NV_096_SET_LOGIC_OP_V_AND_INVERTED_ADJ             0x00000004
#define NV_096_SET_LOGIC_OP_V_NOOP_ADJ                     0x00000005
#define NV_096_SET_LOGIC_OP_V_XOR_ADJ                      0x00000006
#define NV_096_SET_LOGIC_OP_V_OR_ADJ                       0x00000007
#define NV_096_SET_LOGIC_OP_V_NOR_ADJ                      0x00000008
#define NV_096_SET_LOGIC_OP_V_EQUIV_ADJ                    0x00000009
#define NV_096_SET_LOGIC_OP_V_INVERT_ADJ                   0x0000000A
#define NV_096_SET_LOGIC_OP_V_OR_REVERSE_ADJ               0x0000000B
#define NV_096_SET_LOGIC_OP_V_COPY_INVERTED_ADJ            0x0000000C
#define NV_096_SET_LOGIC_OP_V_OR_INVERTED_ADJ              0x0000000D
#define NV_096_SET_LOGIC_OP_V_NAND_ADJ                     0x0000000E
#define NV_096_SET_LOGIC_OP_V_SET_ADJ                      0x0000000F
#define NV_096_SET_LOGIC_OP_MSK                            0xFFFFFFFF 
#define NV_096_SET_BEGIN_END_OP_MSK                        0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_BEGIN_END_OP_RMSK                       0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_BEGIN_END_OP_WORD                       0
#define NV_096_SET_BEGIN_END_OP_HIGH_FIELD                 0x0000001F /* =31 */
#define NV_096_SET_BEGIN_END_OP_LOW_FIELD                  0x00000000 /* =0 */
#define NV_096_SET_BEGIN_END_OP_END_ADJ                    0x00000000
#define NV_096_SET_BEGIN_END_OP_POINTS_ADJ                 0x00000001
#define NV_096_SET_BEGIN_END_OP_LINES_ADJ                  0x00000002
#define NV_096_SET_BEGIN_END_OP_LINE_LOOP_ADJ              0x00000003
#define NV_096_SET_BEGIN_END_OP_LINE_STRIP_ADJ             0x00000004
#define NV_096_SET_BEGIN_END_OP_TRIANGLES_ADJ              0x00000005
#define NV_096_SET_BEGIN_END_OP_TRIANGLE_STRIP_ADJ         0x00000006
#define NV_096_SET_BEGIN_END_OP_TRIANGLE_FAN_ADJ           0x00000007
#define NV_096_SET_BEGIN_END_OP_QUADS_ADJ                  0x00000008
#define NV_096_SET_BEGIN_END_OP_QUAD_STRIP_ADJ             0x00000009
#define NV_096_SET_BEGIN_END_OP_POLYGON_ADJ                0x0000000A
#define NV_096_SET_BEGIN_END_MSK                           0xFFFFFFFF 
#define NV_096_ARRAY_ELEMENT16_VERTEX0_MSK                 0x0000FFFF /* 15:0 */ 
#define NV_096_ARRAY_ELEMENT16_VERTEX0_RMSK                0x0000FFFF /* 15:0 */ 
#define NV_096_ARRAY_ELEMENT16_VERTEX0_WORD                0
#define NV_096_ARRAY_ELEMENT16_VERTEX0_HIGH_FIELD          0x0000000F /* =15 */
#define NV_096_ARRAY_ELEMENT16_VERTEX0_LOW_FIELD           0x00000000 /* =0 */
#define NV_096_ARRAY_ELEMENT16_VERTEX1_MSK                 0xFFFF0000 /* 31:16 */ 
#define NV_096_ARRAY_ELEMENT16_VERTEX1_RMSK                0x0000FFFF /* 31:16 */ 
#define NV_096_ARRAY_ELEMENT16_VERTEX1_WORD                0
#define NV_096_ARRAY_ELEMENT16_VERTEX1_HIGH_FIELD          0x0000001F /* =31 */
#define NV_096_ARRAY_ELEMENT16_VERTEX1_LOW_FIELD           0x00000010 /* =16 */
#define NV_096_ARRAY_ELEMENT16_MSK                         0xFFFFFFFF 
#define NV_096_SET_BEGIN_END2_OP_MSK                       0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_BEGIN_END2_OP_RMSK                      0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_BEGIN_END2_OP_WORD                      0
#define NV_096_SET_BEGIN_END2_OP_HIGH_FIELD                0x0000001F /* =31 */
#define NV_096_SET_BEGIN_END2_OP_LOW_FIELD                 0x00000000 /* =0 */
#define NV_096_SET_BEGIN_END2_OP_END_ADJ                   0x00000000
#define NV_096_SET_BEGIN_END2_OP_POINTS_ADJ                0x00000001
#define NV_096_SET_BEGIN_END2_OP_LINES_ADJ                 0x00000002
#define NV_096_SET_BEGIN_END2_OP_LINE_LOOP_ADJ             0x00000003
#define NV_096_SET_BEGIN_END2_OP_LINE_STRIP_ADJ            0x00000004
#define NV_096_SET_BEGIN_END2_OP_TRIANGLES_ADJ             0x00000005
#define NV_096_SET_BEGIN_END2_OP_TRIANGLE_STRIP_ADJ        0x00000006
#define NV_096_SET_BEGIN_END2_OP_TRIANGLE_FAN_ADJ          0x00000007
#define NV_096_SET_BEGIN_END2_OP_QUADS_ADJ                 0x00000008
#define NV_096_SET_BEGIN_END2_OP_QUAD_STRIP_ADJ            0x00000009
#define NV_096_SET_BEGIN_END2_OP_POLYGON_ADJ               0x0000000A
#define NV_096_SET_BEGIN_END2_MSK                          0xFFFFFFFF 
#define NV_096_ARRAY_ELEMENT32_V_MSK                       0xFFFFFFFF /* 31:0 */ 
#define NV_096_ARRAY_ELEMENT32_V_RMSK                      0xFFFFFFFF /* 31:0 */ 
#define NV_096_ARRAY_ELEMENT32_V_WORD                      0
#define NV_096_ARRAY_ELEMENT32_V_HIGH_FIELD                0x0000001F /* =31 */
#define NV_096_ARRAY_ELEMENT32_V_LOW_FIELD                 0x00000000 /* =0 */
#define NV_096_ARRAY_ELEMENT32_MSK                         0xFFFFFFFF 
#define NV_096_SET_BEGIN_END3_OP_MSK                       0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_BEGIN_END3_OP_RMSK                      0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_BEGIN_END3_OP_WORD                      0
#define NV_096_SET_BEGIN_END3_OP_HIGH_FIELD                0x0000001F /* =31 */
#define NV_096_SET_BEGIN_END3_OP_LOW_FIELD                 0x00000000 /* =0 */
#define NV_096_SET_BEGIN_END3_OP_END_ADJ                   0x00000000
#define NV_096_SET_BEGIN_END3_OP_POINTS_ADJ                0x00000001
#define NV_096_SET_BEGIN_END3_OP_LINES_ADJ                 0x00000002
#define NV_096_SET_BEGIN_END3_OP_LINE_LOOP_ADJ             0x00000003
#define NV_096_SET_BEGIN_END3_OP_LINE_STRIP_ADJ            0x00000004
#define NV_096_SET_BEGIN_END3_OP_TRIANGLES_ADJ             0x00000005
#define NV_096_SET_BEGIN_END3_OP_TRIANGLE_STRIP_ADJ        0x00000006
#define NV_096_SET_BEGIN_END3_OP_TRIANGLE_FAN_ADJ          0x00000007
#define NV_096_SET_BEGIN_END3_OP_QUADS_ADJ                 0x00000008
#define NV_096_SET_BEGIN_END3_OP_QUAD_STRIP_ADJ            0x00000009
#define NV_096_SET_BEGIN_END3_OP_POLYGON_ADJ               0x0000000A
#define NV_096_SET_BEGIN_END3_MSK                          0xFFFFFFFF 
#define NV_096_DRAW_ARRAYS_COUNT_MSK                       0xFF000000 /* 31:24 */ 
#define NV_096_DRAW_ARRAYS_COUNT_RMSK                      0x000000FF /* 31:24 */ 
#define NV_096_DRAW_ARRAYS_COUNT_WORD                      0
#define NV_096_DRAW_ARRAYS_COUNT_HIGH_FIELD                0x0000001F /* =31 */
#define NV_096_DRAW_ARRAYS_COUNT_LOW_FIELD                 0x00000018 /* =24 */
#define NV_096_DRAW_ARRAYS_START_INDEX_MSK                 0x00FFFFFF /* 23:0 */ 
#define NV_096_DRAW_ARRAYS_START_INDEX_RMSK                0x00FFFFFF /* 23:0 */ 
#define NV_096_DRAW_ARRAYS_START_INDEX_WORD                0
#define NV_096_DRAW_ARRAYS_START_INDEX_HIGH_FIELD          0x00000017 /* =23 */
#define NV_096_DRAW_ARRAYS_START_INDEX_LOW_FIELD           0x00000000 /* =0 */
#define NV_096_DRAW_ARRAYS_MSK                             0xFFFFFFFF 
#define NV_096_SET_BEGIN_END4_OP_MSK                       0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_BEGIN_END4_OP_RMSK                      0xFFFFFFFF /* 31:0 */ 
#define NV_096_SET_BEGIN_END4_OP_WORD                      0
#define NV_096_SET_BEGIN_END4_OP_HIGH_FIELD                0x0000001F /* =31 */
#define NV_096_SET_BEGIN_END4_OP_LOW_FIELD                 0x00000000 /* =0 */
#define NV_096_SET_BEGIN_END4_OP_END_ADJ                   0x00000000
#define NV_096_SET_BEGIN_END4_OP_POINTS_ADJ                0x00000001
#define NV_096_SET_BEGIN_END4_OP_LINES_ADJ                 0x00000002
#define NV_096_SET_BEGIN_END4_OP_LINE_LOOP_ADJ             0x00000003
#define NV_096_SET_BEGIN_END4_OP_LINE_STRIP_ADJ            0x00000004
#define NV_096_SET_BEGIN_END4_OP_TRIANGLES_ADJ             0x00000005
#define NV_096_SET_BEGIN_END4_OP_TRIANGLE_STRIP_ADJ        0x00000006
#define NV_096_SET_BEGIN_END4_OP_TRIANGLE_FAN_ADJ          0x00000007
#define NV_096_SET_BEGIN_END4_OP_QUADS_ADJ                 0x00000008
#define NV_096_SET_BEGIN_END4_OP_QUAD_STRIP_ADJ            0x00000009
#define NV_096_SET_BEGIN_END4_OP_POLYGON_ADJ               0x0000000A
#define NV_096_SET_BEGIN_END4_MSK                          0xFFFFFFFF 
#define NV_096_INLINE_ARRAY_MSK                            0x00000000 
#define NV_UPATT_HIGH_FIELD                                0x00461FFF /* =4595711 */
#define NV_UPATT_LOW_FIELD                                 0x00460000 /* =4587520 */
#define NV_UPATT_CTX_SWITCH_ADJ                            0x00460000
#define NV_UPATT_CTX_SWITCH_INSTANCE_MSK                   0x0000FFFF /* 15:0 */ 
#define NV_UPATT_CTX_SWITCH_INSTANCE_RMSK                  0x0000FFFF /* 15:0 */ 
#define NV_UPATT_CTX_SWITCH_INSTANCE_WORD                  0
#define NV_UPATT_CTX_SWITCH_INSTANCE_HIGH_FIELD            0x0000000F /* =15 */
#define NV_UPATT_CTX_SWITCH_INSTANCE_LOW_FIELD             0x00000000 /* =0 */
#define NV_UPATT_CTX_SWITCH_CHID_MSK                       0x007F0000 /* 22:16 */ 
#define NV_UPATT_CTX_SWITCH_CHID_RMSK                      0x0000007F /* 22:16 */ 
#define NV_UPATT_CTX_SWITCH_CHID_WORD                      0
#define NV_UPATT_CTX_SWITCH_CHID_HIGH_FIELD                0x00000016 /* =22 */
#define NV_UPATT_CTX_SWITCH_CHID_LOW_FIELD                 0x00000010 /* =16 */
#define NV_UPATT_CTX_SWITCH_VOLATILE_MSK                   0x80000000 /* 31:31 */ 
#define NV_UPATT_CTX_SWITCH_VOLATILE_RMSK                  0x00000001 /* 31:31 */ 
#define NV_UPATT_CTX_SWITCH_VOLATILE_WORD                  0
#define NV_UPATT_CTX_SWITCH_VOLATILE_HIGH_FIELD            0x0000001F /* =31 */
#define NV_UPATT_CTX_SWITCH_VOLATILE_LOW_FIELD             0x0000001F /* =31 */
#define NV_UPATT_CTX_SWITCH_VOLATILE_IGNORE_ADJ            0x00000000
#define NV_UPATT_CTX_SWITCH_VOLATILE_RESET_ADJ             0x80000000
#define NV_UPATT_CTX_SWITCH_MSK                            0x807FFFFF 
#define NV_UPATT_NOTIFY_STYLE_MSK                          0xFFFFFFFF /* 31:0 */ 
#define NV_UPATT_NOTIFY_STYLE_RMSK                         0xFFFFFFFF /* 31:0 */ 
#define NV_UPATT_NOTIFY_STYLE_WORD                         0
#define NV_UPATT_NOTIFY_STYLE_HIGH_FIELD                   0x0000001F /* =31 */
#define NV_UPATT_NOTIFY_STYLE_LOW_FIELD                    0x00000000 /* =0 */
#define NV_UPATT_NOTIFY_STYLE_WRITE_ONLY_ADJ               0x00000000
#define NV_UPATT_NOTIFY_STYLE_WRITE_THEN_AWAKEN_ADJ        0x00000001
#define NV_UPATT_NOTIFY_MSK                                0xFFFFFFFF 
#define NV_UPATT_SET_NOTIFY_PARAMETER_MSK                  0xFFFFFFFF /* 31:0 */ 
#define NV_UPATT_SET_NOTIFY_PARAMETER_RMSK                 0xFFFFFFFF /* 31:0 */ 
#define NV_UPATT_SET_NOTIFY_PARAMETER_WORD                 0
#define NV_UPATT_SET_NOTIFY_PARAMETER_HIGH_FIELD           0x0000001F /* =31 */
#define NV_UPATT_SET_NOTIFY_PARAMETER_LOW_FIELD            0x00000000 /* =0 */
#define NV_UPATT_SET_NOTIFY_PARAMETER_WRITE_ADJ            0x00000000
#define NV_UPATT_SET_NOTIFY_MSK                            0xFFFFFFFF 
#define NV_UPATT_SET_CONTEXT_DMA_NOTIFY_PARAMETER_MSK      0xFFFFFFFF /* 31:0 */ 
#define NV_UPATT_SET_CONTEXT_DMA_NOTIFY_PARAMETER_RMSK     0xFFFFFFFF /* 31:0 */ 
#define NV_UPATT_SET_CONTEXT_DMA_NOTIFY_PARAMETER_WORD     0
#define NV_UPATT_SET_CONTEXT_DMA_NOTIFY_PARAMETER_HIGH_FIELD 0x0000001F /* =31 */
#define NV_UPATT_SET_CONTEXT_DMA_NOTIFY_PARAMETER_LOW_FIELD 0x00000000 /* =0 */
#define NV_UPATT_SET_CONTEXT_DMA_NOTIFY_MSK                0xFFFFFFFF 
#define NV_UPATT_SET_IMAGE_OUTPUT_PARAMETER_MSK            0xFFFFFFFF /* 31:0 */ 
#define NV_UPATT_SET_IMAGE_OUTPUT_PARAMETER_RMSK           0xFFFFFFFF /* 31:0 */ 
#define NV_UPATT_SET_IMAGE_OUTPUT_PARAMETER_WORD           0
#define NV_UPATT_SET_IMAGE_OUTPUT_PARAMETER_HIGH_FIELD     0x0000001F /* =31 */
#define NV_UPATT_SET_IMAGE_OUTPUT_PARAMETER_LOW_FIELD      0x00000000 /* =0 */
#define NV_UPATT_SET_IMAGE_OUTPUT_MSK                      0xFFFFFFFF 
#define NV_UPATT_SET_COLOR_FORMAT_LE_MSK                   0xFFFFFFFF /* 31:0 */ 
#define NV_UPATT_SET_COLOR_FORMAT_LE_RMSK                  0xFFFFFFFF /* 31:0 */ 
#define NV_UPATT_SET_COLOR_FORMAT_LE_WORD                  0
#define NV_UPATT_SET_COLOR_FORMAT_LE_HIGH_FIELD            0x0000001F /* =31 */
#define NV_UPATT_SET_COLOR_FORMAT_LE_LOW_FIELD             0x00000000 /* =0 */
#define NV_UPATT_SET_COLOR_FORMAT_LE_X16A8Y8_ADJ           0x00000001
#define NV_UPATT_SET_COLOR_FORMAT_LE_X16A1R5G5B5_ADJ       0x00000002
#define NV_UPATT_SET_COLOR_FORMAT_LE_A8R8G8B8_ADJ          0x00000003
#define NV_UPATT_SET_COLOR_FORMAT_MSK                      0xFFFFFFFF 
#define NV_UPATT_SET_MONOCHROME_FORMAT_VALUE_MSK           0xFFFFFFFF /* 31:0 */ 
#define NV_UPATT_SET_MONOCHROME_FORMAT_VALUE_RMSK          0xFFFFFFFF /* 31:0 */ 
#define NV_UPATT_SET_MONOCHROME_FORMAT_VALUE_WORD          0
#define NV_UPATT_SET_MONOCHROME_FORMAT_VALUE_HIGH_FIELD    0x0000001F /* =31 */
#define NV_UPATT_SET_MONOCHROME_FORMAT_VALUE_LOW_FIELD     0x00000000 /* =0 */
#define NV_UPATT_SET_MONOCHROME_FORMAT_MSK                 0xFFFFFFFF 
#define NV_UPATT_SET_SHAPE_VALUE_MSK                       0x00000003 /* 1:0 */ 
#define NV_UPATT_SET_SHAPE_VALUE_RMSK                      0x00000003 /* 1:0 */ 
#define NV_UPATT_SET_SHAPE_VALUE_WORD                      0
#define NV_UPATT_SET_SHAPE_VALUE_HIGH_FIELD                0x00000001 /* =1 */
#define NV_UPATT_SET_SHAPE_VALUE_LOW_FIELD                 0x00000000 /* =0 */
#define NV_UPATT_SET_SHAPE_VALUE_8X_8Y_ADJ                 0x00000000
#define NV_UPATT_SET_SHAPE_VALUE_64X_1Y_ADJ                0x00000001
#define NV_UPATT_SET_SHAPE_VALUE_1X_64Y_ADJ                0x00000002
#define NV_UPATT_SET_SHAPE_MSK                             0x00000003 
#define NV_UPATT_SET_COLOR0_VALUE_MSK                      0xFFFFFFFF /* 31:0 */ 
#define NV_UPATT_SET_COLOR0_VALUE_RMSK                     0xFFFFFFFF /* 31:0 */ 
#define NV_UPATT_SET_COLOR0_VALUE_WORD                     0
#define NV_UPATT_SET_COLOR0_VALUE_HIGH_FIELD               0x0000001F /* =31 */
#define NV_UPATT_SET_COLOR0_VALUE_LOW_FIELD                0x00000000 /* =0 */
#define NV_UPATT_SET_COLOR0_MSK                            0xFFFFFFFF 
#define NV_UPATT_SET_COLOR1_VALUE_MSK                      0xFFFFFFFF /* 31:0 */ 
#define NV_UPATT_SET_COLOR1_VALUE_RMSK                     0xFFFFFFFF /* 31:0 */ 
#define NV_UPATT_SET_COLOR1_VALUE_WORD                     0
#define NV_UPATT_SET_COLOR1_VALUE_HIGH_FIELD               0x0000001F /* =31 */
#define NV_UPATT_SET_COLOR1_VALUE_LOW_FIELD                0x00000000 /* =0 */
#define NV_UPATT_SET_COLOR1_MSK                            0xFFFFFFFF 
#define NV_UPATT_SET_PATTERN_BITMAP_MSK                    0xFFFFFFFF /* 31:0 */ 
#define NV_UPATT_SET_PATTERN_BITMAP_RMSK                   0xFFFFFFFF /* 31:0 */ 
#define NV_UPATT_SET_PATTERN_BITMAP_WORD                   0
#define NV_UPATT_SET_PATTERN_BITMAP_HIGH_FIELD             0x0000001F /* =31 */
#define NV_UPATT_SET_PATTERN_BITMAP_LOW_FIELD              0x00000000 /* =0 */
#define NV_UPATT_SET_PATTERN_MSK                           0xFFFFFFFF 
#define NV_044_HIGH_FIELD                                  0x00681FFF /* =6823935 */
#define NV_044_LOW_FIELD                                   0x00680000 /* =6815744 */
#define NV_044_CTX_SWITCH_ADJ                              0x00680000
#define NV_044_CTX_SWITCH_MSK                              0x00000000 
#define NV_044_NOP_ADJ                                     0x00680100
#define NV_044_NOP_PARAMETER_MSK                           0xFFFFFFFF /* 31:0 */ 
#define NV_044_NOP_PARAMETER_RMSK                          0xFFFFFFFF /* 31:0 */ 
#define NV_044_NOP_PARAMETER_WORD                          0
#define NV_044_NOP_PARAMETER_HIGH_FIELD                    0x0000001F /* =31 */
#define NV_044_NOP_PARAMETER_LOW_FIELD                     0x00000000 /* =0 */
#define NV_044_NOP_MSK                                     0xFFFFFFFF 
#define NV_044_NOTIFY_STYLE_MSK                            0xFFFFFFFF /* 31:0 */ 
#define NV_044_NOTIFY_STYLE_RMSK                           0xFFFFFFFF /* 31:0 */ 
#define NV_044_NOTIFY_STYLE_WORD                           0
#define NV_044_NOTIFY_STYLE_HIGH_FIELD                     0x0000001F /* =31 */
#define NV_044_NOTIFY_STYLE_LOW_FIELD                      0x00000000 /* =0 */
#define NV_044_NOTIFY_STYLE_WRITE_ONLY_ADJ                 0x00000000
#define NV_044_NOTIFY_STYLE_WRITE_THEN_AWAKEN_ADJ          0x00000001
#define NV_044_SET_NOTIFY_PARAMETER_MSK                    0xFFFFFFFF /* 31:0 */ 
#define NV_044_SET_NOTIFY_PARAMETER_RMSK                   0xFFFFFFFF /* 31:0 */ 
#define NV_044_SET_NOTIFY_PARAMETER_WORD                   0
#define NV_044_SET_NOTIFY_PARAMETER_HIGH_FIELD             0x0000001F /* =31 */
#define NV_044_SET_NOTIFY_PARAMETER_LOW_FIELD              0x00000000 /* =0 */
#define NV_044_SET_NOTIFY_PARAMETER_WRITE_ADJ              0x00000000
#define NV_044_NOTIFY_MSK                                  0xFFFFFFFF 
#define NV_044_SET_CONTEXT_DMA_NOTIFY_PARAMETER_MSK        0xFFFFFFFF /* 31:0 */ 
#define NV_044_SET_CONTEXT_DMA_NOTIFY_PARAMETER_RMSK       0xFFFFFFFF /* 31:0 */ 
#define NV_044_SET_CONTEXT_DMA_NOTIFY_PARAMETER_WORD       0
#define NV_044_SET_CONTEXT_DMA_NOTIFY_PARAMETER_HIGH_FIELD 0x0000001F /* =31 */
#define NV_044_SET_CONTEXT_DMA_NOTIFY_PARAMETER_LOW_FIELD  0x00000000 /* =0 */
#define NV_044_SET_CONTEXT_DMA_NOTIFY_MSK                  0xFFFFFFFF 
#define NV_044_SET_IMAGE_OUTPUT_PARAMETER_MSK              0xFFFFFFFF /* 31:0 */ 
#define NV_044_SET_IMAGE_OUTPUT_PARAMETER_RMSK             0xFFFFFFFF /* 31:0 */ 
#define NV_044_SET_IMAGE_OUTPUT_PARAMETER_WORD             0
#define NV_044_SET_IMAGE_OUTPUT_PARAMETER_HIGH_FIELD       0x0000001F /* =31 */
#define NV_044_SET_IMAGE_OUTPUT_PARAMETER_LOW_FIELD        0x00000000 /* =0 */
#define NV_044_SET_IMAGE_OUTPUT_MSK                        0xFFFFFFFF 
#define NV_044_SET_COLOR_FORMAT_LE_MSK                     0xFFFFFFFF /* 31:0 */ 
#define NV_044_SET_COLOR_FORMAT_LE_RMSK                    0xFFFFFFFF /* 31:0 */ 
#define NV_044_SET_COLOR_FORMAT_LE_WORD                    0
#define NV_044_SET_COLOR_FORMAT_LE_HIGH_FIELD              0x0000001F /* =31 */
#define NV_044_SET_COLOR_FORMAT_LE_LOW_FIELD               0x00000000 /* =0 */
#define NV_044_SET_COLOR_FORMAT_LE_A16R5G6B5_ADJ           0x00000001
#define NV_044_SET_COLOR_FORMAT_LE_X16A1R5G5B5_ADJ         0x00000002
#define NV_044_SET_COLOR_FORMAT_LE_A8R8G8B8_ADJ            0x00000003
#define NV_044_SET_COLOR_FORMAT_MSK                        0xFFFFFFFF 
#define NV_044_SET_MONOCHROME_FORMAT_VALUE_MSK             0xFFFFFFFF /* 31:0 */ 
#define NV_044_SET_MONOCHROME_FORMAT_VALUE_RMSK            0xFFFFFFFF /* 31:0 */ 
#define NV_044_SET_MONOCHROME_FORMAT_VALUE_WORD            0
#define NV_044_SET_MONOCHROME_FORMAT_VALUE_HIGH_FIELD      0x0000001F /* =31 */
#define NV_044_SET_MONOCHROME_FORMAT_VALUE_LOW_FIELD       0x00000000 /* =0 */
#define NV_044_SET_MONOCHROME_FORMAT_VALUE_CGA6_M1_ADJ     0x00000001
#define NV_044_SET_MONOCHROME_FORMAT_VALUE_LE_M1_ADJ       0x00000002
#define NV_044_SET_MONOCHROME_FORMAT_MSK                   0xFFFFFFFF 
#define NV_044_SET_MONOCHROME_SHAPE_VALUE_MSK              0xFFFFFFFF /* 31:0 */ 
#define NV_044_SET_MONOCHROME_SHAPE_VALUE_RMSK             0xFFFFFFFF /* 31:0 */ 
#define NV_044_SET_MONOCHROME_SHAPE_VALUE_WORD             0
#define NV_044_SET_MONOCHROME_SHAPE_VALUE_HIGH_FIELD       0x0000001F /* =31 */
#define NV_044_SET_MONOCHROME_SHAPE_VALUE_LOW_FIELD        0x00000000 /* =0 */
#define NV_044_SET_MONOCHROME_SHAPE_VALUE_8X_8Y_ADJ        0x00000000
#define NV_044_SET_MONOCHROME_SHAPE_VALUE_64X_1Y_ADJ       0x00000001
#define NV_044_SET_MONOCHROME_SHAPE_VALUE_1X_64Y_ADJ       0x00000002
#define NV_044_SET_MONOCHROME_SHAPE_MSK                    0xFFFFFFFF 
#define NV_044_SET_PATTERN_SELECT_VALUE_MSK                0xFFFFFFFF /* 31:0 */ 
#define NV_044_SET_PATTERN_SELECT_VALUE_RMSK               0xFFFFFFFF /* 31:0 */ 
#define NV_044_SET_PATTERN_SELECT_VALUE_WORD               0
#define NV_044_SET_PATTERN_SELECT_VALUE_HIGH_FIELD         0x0000001F /* =31 */
#define NV_044_SET_PATTERN_SELECT_VALUE_LOW_FIELD          0x00000000 /* =0 */
#define NV_044_SET_PATTERN_SELECT_VALUE_MONOCHROME_ADJ     0x00000001
#define NV_044_SET_PATTERN_SELECT_VALUE_COLOR_ADJ          0x00000002
#define NV_044_SET_PATTERN_SELECT_MSK                      0xFFFFFFFF 
#define NV_044_SET_MONOCHROME_COLOR0_VALUE_MSK             0xFFFFFFFF /* 31:0 */ 
#define NV_044_SET_MONOCHROME_COLOR0_VALUE_RMSK            0xFFFFFFFF /* 31:0 */ 
#define NV_044_SET_MONOCHROME_COLOR0_VALUE_WORD            0
#define NV_044_SET_MONOCHROME_COLOR0_VALUE_HIGH_FIELD      0x0000001F /* =31 */
#define NV_044_SET_MONOCHROME_COLOR0_VALUE_LOW_FIELD       0x00000000 /* =0 */
#define NV_044_SET_MONOCHROME_COLOR0_MSK                   0xFFFFFFFF 
#define NV_044_SET_MONOCHROME_COLOR1_VALUE_MSK             0xFFFFFFFF /* 31:0 */ 
#define NV_044_SET_MONOCHROME_COLOR1_VALUE_RMSK            0xFFFFFFFF /* 31:0 */ 
#define NV_044_SET_MONOCHROME_COLOR1_VALUE_WORD            0
#define NV_044_SET_MONOCHROME_COLOR1_VALUE_HIGH_FIELD      0x0000001F /* =31 */
#define NV_044_SET_MONOCHROME_COLOR1_VALUE_LOW_FIELD       0x00000000 /* =0 */
#define NV_044_SET_MONOCHROME_COLOR1_MSK                   0xFFFFFFFF 
#define NV_044_SET_MONOCHROME_PATTERN0_BITMAP_MSK          0xFFFFFFFF /* 31:0 */ 
#define NV_044_SET_MONOCHROME_PATTERN0_BITMAP_RMSK         0xFFFFFFFF /* 31:0 */ 
#define NV_044_SET_MONOCHROME_PATTERN0_BITMAP_WORD         0
#define NV_044_SET_MONOCHROME_PATTERN0_BITMAP_HIGH_FIELD   0x0000001F /* =31 */
#define NV_044_SET_MONOCHROME_PATTERN0_BITMAP_LOW_FIELD    0x00000000 /* =0 */
#define NV_044_SET_MONOCHROME_PATTERN1_BITMAP_MSK          0xFFFFFFFF /* 31:0 */ 
#define NV_044_SET_MONOCHROME_PATTERN1_BITMAP_RMSK         0xFFFFFFFF /* 31:0 */ 
#define NV_044_SET_MONOCHROME_PATTERN1_BITMAP_WORD         0
#define NV_044_SET_MONOCHROME_PATTERN1_BITMAP_HIGH_FIELD   0x0000001F /* =31 */
#define NV_044_SET_MONOCHROME_PATTERN1_BITMAP_LOW_FIELD    0x00000000 /* =0 */
#define NV_044_SET_PATTERN_Y8_Y0_MSK                       0x000000FF /* 7:0 */ 
#define NV_044_SET_PATTERN_Y8_Y0_RMSK                      0x000000FF /* 7:0 */ 
#define NV_044_SET_PATTERN_Y8_Y0_WORD                      0
#define NV_044_SET_PATTERN_Y8_Y0_HIGH_FIELD                0x00000007 /* =7 */
#define NV_044_SET_PATTERN_Y8_Y0_LOW_FIELD                 0x00000000 /* =0 */
#define NV_044_SET_PATTERN_Y8_Y1_MSK                       0x0000FF00 /* 15:8 */ 
#define NV_044_SET_PATTERN_Y8_Y1_RMSK                      0x000000FF /* 15:8 */ 
#define NV_044_SET_PATTERN_Y8_Y1_WORD                      0
#define NV_044_SET_PATTERN_Y8_Y1_HIGH_FIELD                0x0000000F /* =15 */
#define NV_044_SET_PATTERN_Y8_Y1_LOW_FIELD                 0x00000008 /* =8 */
#define NV_044_SET_PATTERN_Y8_Y2_MSK                       0x00FF0000 /* 23:16 */ 
#define NV_044_SET_PATTERN_Y8_Y2_RMSK                      0x000000FF /* 23:16 */ 
#define NV_044_SET_PATTERN_Y8_Y2_WORD                      0
#define NV_044_SET_PATTERN_Y8_Y2_HIGH_FIELD                0x00000017 /* =23 */
#define NV_044_SET_PATTERN_Y8_Y2_LOW_FIELD                 0x00000010 /* =16 */
#define NV_044_SET_PATTERN_Y8_Y3_MSK                       0xFF000000 /* 31:24 */ 
#define NV_044_SET_PATTERN_Y8_Y3_RMSK                      0x000000FF /* 31:24 */ 
#define NV_044_SET_PATTERN_Y8_Y3_WORD                      0
#define NV_044_SET_PATTERN_Y8_Y3_HIGH_FIELD                0x0000001F /* =31 */
#define NV_044_SET_PATTERN_Y8_Y3_LOW_FIELD                 0x00000018 /* =24 */
#define NV_044_SET_PATTERN_Y8_MSK                          0xFFFFFFFF 
#define NV_044_SET_PATTERN_R5G6B5_BLUE0_MSK                0x0000001F /* 4:0 */ 
#define NV_044_SET_PATTERN_R5G6B5_BLUE0_RMSK               0x0000001F /* 4:0 */ 
#define NV_044_SET_PATTERN_R5G6B5_BLUE0_WORD               0
#define NV_044_SET_PATTERN_R5G6B5_BLUE0_HIGH_FIELD         0x00000004 /* =4 */
#define NV_044_SET_PATTERN_R5G6B5_BLUE0_LOW_FIELD          0x00000000 /* =0 */
#define NV_044_SET_PATTERN_R5G6B5_GREEN0_MSK               0x000007E0 /* 10:5 */ 
#define NV_044_SET_PATTERN_R5G6B5_GREEN0_RMSK              0x0000003F /* 10:5 */ 
#define NV_044_SET_PATTERN_R5G6B5_GREEN0_WORD              0
#define NV_044_SET_PATTERN_R5G6B5_GREEN0_HIGH_FIELD        0x0000000A /* =10 */
#define NV_044_SET_PATTERN_R5G6B5_GREEN0_LOW_FIELD         0x00000005 /* =5 */
#define NV_044_SET_PATTERN_R5G6B5_RED0_MSK                 0x0000F800 /* 15:11 */ 
#define NV_044_SET_PATTERN_R5G6B5_RED0_RMSK                0x0000001F /* 15:11 */ 
#define NV_044_SET_PATTERN_R5G6B5_RED0_WORD                0
#define NV_044_SET_PATTERN_R5G6B5_RED0_HIGH_FIELD          0x0000000F /* =15 */
#define NV_044_SET_PATTERN_R5G6B5_RED0_LOW_FIELD           0x0000000B /* =11 */
#define NV_044_SET_PATTERN_R5G6B5_BLUE1_MSK                0x001F0000 /* 20:16 */ 
#define NV_044_SET_PATTERN_R5G6B5_BLUE1_RMSK               0x0000001F /* 20:16 */ 
#define NV_044_SET_PATTERN_R5G6B5_BLUE1_WORD               0
#define NV_044_SET_PATTERN_R5G6B5_BLUE1_HIGH_FIELD         0x00000014 /* =20 */
#define NV_044_SET_PATTERN_R5G6B5_BLUE1_LOW_FIELD          0x00000010 /* =16 */
#define NV_044_SET_PATTERN_R5G6B5_GREEN1_MSK               0x07E00000 /* 26:21 */ 
#define NV_044_SET_PATTERN_R5G6B5_GREEN1_RMSK              0x0000003F /* 26:21 */ 
#define NV_044_SET_PATTERN_R5G6B5_GREEN1_WORD              0
#define NV_044_SET_PATTERN_R5G6B5_GREEN1_HIGH_FIELD        0x0000001A /* =26 */
#define NV_044_SET_PATTERN_R5G6B5_GREEN1_LOW_FIELD         0x00000015 /* =21 */
#define NV_044_SET_PATTERN_R5G6B5_RED1_MSK                 0xF8000000 /* 31:27 */ 
#define NV_044_SET_PATTERN_R5G6B5_RED1_RMSK                0x0000001F /* 31:27 */ 
#define NV_044_SET_PATTERN_R5G6B5_RED1_WORD                0
#define NV_044_SET_PATTERN_R5G6B5_RED1_HIGH_FIELD          0x0000001F /* =31 */
#define NV_044_SET_PATTERN_R5G6B5_RED1_LOW_FIELD           0x0000001B /* =27 */
#define NV_044_SET_PATTERN_R5G6B5_MSK                      0xFFFFFFFF 
#define NV_044_SET_PATTERN_X1R5G5B5_BLUE0_MSK              0x0000001F /* 4:0 */ 
#define NV_044_SET_PATTERN_X1R5G5B5_BLUE0_RMSK             0x0000001F /* 4:0 */ 
#define NV_044_SET_PATTERN_X1R5G5B5_BLUE0_WORD             0
#define NV_044_SET_PATTERN_X1R5G5B5_BLUE0_HIGH_FIELD       0x00000004 /* =4 */
#define NV_044_SET_PATTERN_X1R5G5B5_BLUE0_LOW_FIELD        0x00000000 /* =0 */
#define NV_044_SET_PATTERN_X1R5G5B5_GREEN0_MSK             0x000003E0 /* 9:5 */ 
#define NV_044_SET_PATTERN_X1R5G5B5_GREEN0_RMSK            0x0000001F /* 9:5 */ 
#define NV_044_SET_PATTERN_X1R5G5B5_GREEN0_WORD            0
#define NV_044_SET_PATTERN_X1R5G5B5_GREEN0_HIGH_FIELD      0x00000009 /* =9 */
#define NV_044_SET_PATTERN_X1R5G5B5_GREEN0_LOW_FIELD       0x00000005 /* =5 */
#define NV_044_SET_PATTERN_X1R5G5B5_RED0_MSK               0x00007C00 /* 14:10 */ 
#define NV_044_SET_PATTERN_X1R5G5B5_RED0_RMSK              0x0000001F /* 14:10 */ 
#define NV_044_SET_PATTERN_X1R5G5B5_RED0_WORD              0
#define NV_044_SET_PATTERN_X1R5G5B5_RED0_HIGH_FIELD        0x0000000E /* =14 */
#define NV_044_SET_PATTERN_X1R5G5B5_RED0_LOW_FIELD         0x0000000A /* =10 */
#define NV_044_SET_PATTERN_X1R5G5B5_IGNORE0_MSK            0x00008000 /* 15:15 */ 
#define NV_044_SET_PATTERN_X1R5G5B5_IGNORE0_RMSK           0x00000001 /* 15:15 */ 
#define NV_044_SET_PATTERN_X1R5G5B5_IGNORE0_WORD           0
#define NV_044_SET_PATTERN_X1R5G5B5_IGNORE0_HIGH_FIELD     0x0000000F /* =15 */
#define NV_044_SET_PATTERN_X1R5G5B5_IGNORE0_LOW_FIELD      0x0000000F /* =15 */
#define NV_044_SET_PATTERN_X1R5G5B5_BLUE1_MSK              0x001F0000 /* 20:16 */ 
#define NV_044_SET_PATTERN_X1R5G5B5_BLUE1_RMSK             0x0000001F /* 20:16 */ 
#define NV_044_SET_PATTERN_X1R5G5B5_BLUE1_WORD             0
#define NV_044_SET_PATTERN_X1R5G5B5_BLUE1_HIGH_FIELD       0x00000014 /* =20 */
#define NV_044_SET_PATTERN_X1R5G5B5_BLUE1_LOW_FIELD        0x00000010 /* =16 */
#define NV_044_SET_PATTERN_X1R5G5B5_GREEN1_MSK             0x03E00000 /* 25:21 */ 
#define NV_044_SET_PATTERN_X1R5G5B5_GREEN1_RMSK            0x0000001F /* 25:21 */ 
#define NV_044_SET_PATTERN_X1R5G5B5_GREEN1_WORD            0
#define NV_044_SET_PATTERN_X1R5G5B5_GREEN1_HIGH_FIELD      0x00000019 /* =25 */
#define NV_044_SET_PATTERN_X1R5G5B5_GREEN1_LOW_FIELD       0x00000015 /* =21 */
#define NV_044_SET_PATTERN_X1R5G5B5_RED1_MSK               0x7C000000 /* 30:26 */ 
#define NV_044_SET_PATTERN_X1R5G5B5_RED1_RMSK              0x0000001F /* 30:26 */ 
#define NV_044_SET_PATTERN_X1R5G5B5_RED1_WORD              0
#define NV_044_SET_PATTERN_X1R5G5B5_RED1_HIGH_FIELD        0x0000001E /* =30 */
#define NV_044_SET_PATTERN_X1R5G5B5_RED1_LOW_FIELD         0x0000001A /* =26 */
#define NV_044_SET_PATTERN_X1R5G5B5_IGNORE1_MSK            0x80000000 /* 31:31 */ 
#define NV_044_SET_PATTERN_X1R5G5B5_IGNORE1_RMSK           0x00000001 /* 31:31 */ 
#define NV_044_SET_PATTERN_X1R5G5B5_IGNORE1_WORD           0
#define NV_044_SET_PATTERN_X1R5G5B5_IGNORE1_HIGH_FIELD     0x0000001F /* =31 */
#define NV_044_SET_PATTERN_X1R5G5B5_IGNORE1_LOW_FIELD      0x0000001F /* =31 */
#define NV_044_SET_PATTERN_X1R5G5B5_MSK                    0xFFFFFFFF 
#define NV_044_SET_PATTERN_X8R8G8B8_BLUE_MSK               0x000000FF /* 7:0 */ 
#define NV_044_SET_PATTERN_X8R8G8B8_BLUE_RMSK              0x000000FF /* 7:0 */ 
#define NV_044_SET_PATTERN_X8R8G8B8_BLUE_WORD              0
#define NV_044_SET_PATTERN_X8R8G8B8_BLUE_HIGH_FIELD        0x00000007 /* =7 */
#define NV_044_SET_PATTERN_X8R8G8B8_BLUE_LOW_FIELD         0x00000000 /* =0 */
#define NV_044_SET_PATTERN_X8R8G8B8_GREEN_MSK              0x0000FF00 /* 15:8 */ 
#define NV_044_SET_PATTERN_X8R8G8B8_GREEN_RMSK             0x000000FF /* 15:8 */ 
#define NV_044_SET_PATTERN_X8R8G8B8_GREEN_WORD             0
#define NV_044_SET_PATTERN_X8R8G8B8_GREEN_HIGH_FIELD       0x0000000F /* =15 */
#define NV_044_SET_PATTERN_X8R8G8B8_GREEN_LOW_FIELD        0x00000008 /* =8 */
#define NV_044_SET_PATTERN_X8R8G8B8_RED_MSK                0x00FF0000 /* 23:16 */ 
#define NV_044_SET_PATTERN_X8R8G8B8_RED_RMSK               0x000000FF /* 23:16 */ 
#define NV_044_SET_PATTERN_X8R8G8B8_RED_WORD               0
#define NV_044_SET_PATTERN_X8R8G8B8_RED_HIGH_FIELD         0x00000017 /* =23 */
#define NV_044_SET_PATTERN_X8R8G8B8_RED_LOW_FIELD          0x00000010 /* =16 */
#define NV_044_SET_PATTERN_X8R8G8B8_IGNORE_MSK             0xFF000000 /* 31:24 */ 
#define NV_044_SET_PATTERN_X8R8G8B8_IGNORE_RMSK            0x000000FF /* 31:24 */ 
#define NV_044_SET_PATTERN_X8R8G8B8_IGNORE_WORD            0
#define NV_044_SET_PATTERN_X8R8G8B8_IGNORE_HIGH_FIELD      0x0000001F /* =31 */
#define NV_044_SET_PATTERN_X8R8G8B8_IGNORE_LOW_FIELD       0x00000018 /* =24 */
#define NV_044_SET_PATTERN_X8R8G8B8_MSK                    0xFFFFFFFF 
#define NV_072_HIGH_FIELD                                  0x00621FFF /* =6430719 */
#define NV_072_LOW_FIELD                                   0x00620000 /* =6422528 */
#define NV_072_CTX_SWITCH_ADJ                              0x00620000
#define NV_072_CTX_SWITCH_INSTANCE_MSK                     0x0000FFFF /* 15:0 */ 
#define NV_072_CTX_SWITCH_INSTANCE_RMSK                    0x0000FFFF /* 15:0 */ 
#define NV_072_CTX_SWITCH_INSTANCE_WORD                    0
#define NV_072_CTX_SWITCH_INSTANCE_HIGH_FIELD              0x0000000F /* =15 */
#define NV_072_CTX_SWITCH_INSTANCE_LOW_FIELD               0x00000000 /* =0 */
#define NV_072_CTX_SWITCH_CHID_MSK                         0x007F0000 /* 22:16 */ 
#define NV_072_CTX_SWITCH_CHID_RMSK                        0x0000007F /* 22:16 */ 
#define NV_072_CTX_SWITCH_CHID_WORD                        0
#define NV_072_CTX_SWITCH_CHID_HIGH_FIELD                  0x00000016 /* =22 */
#define NV_072_CTX_SWITCH_CHID_LOW_FIELD                   0x00000010 /* =16 */
#define NV_072_CTX_SWITCH_VOLATILE_MSK                     0x80000000 /* 31:31 */ 
#define NV_072_CTX_SWITCH_VOLATILE_RMSK                    0x00000001 /* 31:31 */ 
#define NV_072_CTX_SWITCH_VOLATILE_WORD                    0
#define NV_072_CTX_SWITCH_VOLATILE_HIGH_FIELD              0x0000001F /* =31 */
#define NV_072_CTX_SWITCH_VOLATILE_LOW_FIELD               0x0000001F /* =31 */
#define NV_072_CTX_SWITCH_VOLATILE_IGNORE_ADJ              0x00000000
#define NV_072_CTX_SWITCH_VOLATILE_RESET_ADJ               0x80000000
#define NV_072_CTX_SWITCH_MSK                              0x807FFFFF 
#define NV_072_NOP_PARAMETER_MSK                           0xFFFFFFFF /* 31:0 */ 
#define NV_072_NOP_PARAMETER_RMSK                          0xFFFFFFFF /* 31:0 */ 
#define NV_072_NOP_PARAMETER_WORD                          0
#define NV_072_NOP_PARAMETER_HIGH_FIELD                    0x0000001F /* =31 */
#define NV_072_NOP_PARAMETER_LOW_FIELD                     0x00000000 /* =0 */
#define NV_072_NOP_MSK                                     0xFFFFFFFF 
#define NV_072_NOTIFY_STYLE_MSK                            0xFFFFFFFF /* 31:0 */ 
#define NV_072_NOTIFY_STYLE_RMSK                           0xFFFFFFFF /* 31:0 */ 
#define NV_072_NOTIFY_STYLE_WORD                           0
#define NV_072_NOTIFY_STYLE_HIGH_FIELD                     0x0000001F /* =31 */
#define NV_072_NOTIFY_STYLE_LOW_FIELD                      0x00000000 /* =0 */
#define NV_072_NOTIFY_STYLE_WRITE_ONLY_ADJ                 0x00000000
#define NV_072_NOTIFY_STYLE_WRITE_THEN_AWAKEN_ADJ          0x00000001
#define NV_072_NOTIFY_MSK                                  0xFFFFFFFF 
#define NV_072_SET_NOTIFY_PARAMETER_MSK                    0xFFFFFFFF /* 31:0 */ 
#define NV_072_SET_NOTIFY_PARAMETER_RMSK                   0xFFFFFFFF /* 31:0 */ 
#define NV_072_SET_NOTIFY_PARAMETER_WORD                   0
#define NV_072_SET_NOTIFY_PARAMETER_HIGH_FIELD             0x0000001F /* =31 */
#define NV_072_SET_NOTIFY_PARAMETER_LOW_FIELD              0x00000000 /* =0 */
#define NV_072_SET_NOTIFY_PARAMETER_WRITE_ADJ              0x00000000
#define NV_072_SET_NOTIFY_MSK                              0xFFFFFFFF 
#define NV_072_SET_CONTEXT_DMA_NOTIFY_PARAMETER_MSK        0xFFFFFFFF /* 31:0 */ 
#define NV_072_SET_CONTEXT_DMA_NOTIFY_PARAMETER_RMSK       0xFFFFFFFF /* 31:0 */ 
#define NV_072_SET_CONTEXT_DMA_NOTIFY_PARAMETER_WORD       0
#define NV_072_SET_CONTEXT_DMA_NOTIFY_PARAMETER_HIGH_FIELD 0x0000001F /* =31 */
#define NV_072_SET_CONTEXT_DMA_NOTIFY_PARAMETER_LOW_FIELD  0x00000000 /* =0 */
#define NV_072_SET_CONTEXT_DMA_NOTIFY_MSK                  0xFFFFFFFF 
#define NV_072_SET_BETA_OUTPUT_PARAMETER_MSK               0xFFFFFFFF /* 31:0 */ 
#define NV_072_SET_BETA_OUTPUT_PARAMETER_RMSK              0xFFFFFFFF /* 31:0 */ 
#define NV_072_SET_BETA_OUTPUT_PARAMETER_WORD              0
#define NV_072_SET_BETA_OUTPUT_PARAMETER_HIGH_FIELD        0x0000001F /* =31 */
#define NV_072_SET_BETA_OUTPUT_PARAMETER_LOW_FIELD         0x00000000 /* =0 */
#define NV_072_SET_BETA_OUTPUT_MSK                         0xFFFFFFFF 
#define NV_072_SET_BETA_FACTOR_BLUE_MSK                    0x000000FF /* 7:0 */ 
#define NV_072_SET_BETA_FACTOR_BLUE_RMSK                   0x000000FF /* 7:0 */ 
#define NV_072_SET_BETA_FACTOR_BLUE_WORD                   0
#define NV_072_SET_BETA_FACTOR_BLUE_HIGH_FIELD             0x00000007 /* =7 */
#define NV_072_SET_BETA_FACTOR_BLUE_LOW_FIELD              0x00000000 /* =0 */
#define NV_072_SET_BETA_FACTOR_GREEN_MSK                   0x0000FF00 /* 15:8 */ 
#define NV_072_SET_BETA_FACTOR_GREEN_RMSK                  0x000000FF /* 15:8 */ 
#define NV_072_SET_BETA_FACTOR_GREEN_WORD                  0
#define NV_072_SET_BETA_FACTOR_GREEN_HIGH_FIELD            0x0000000F /* =15 */
#define NV_072_SET_BETA_FACTOR_GREEN_LOW_FIELD             0x00000008 /* =8 */
#define NV_072_SET_BETA_FACTOR_RED_MSK                     0x00FF0000 /* 23:16 */ 
#define NV_072_SET_BETA_FACTOR_RED_RMSK                    0x000000FF /* 23:16 */ 
#define NV_072_SET_BETA_FACTOR_RED_WORD                    0
#define NV_072_SET_BETA_FACTOR_RED_HIGH_FIELD              0x00000017 /* =23 */
#define NV_072_SET_BETA_FACTOR_RED_LOW_FIELD               0x00000010 /* =16 */
#define NV_072_SET_BETA_FACTOR_ALPHA_MSK                   0xFF000000 /* 31:24 */ 
#define NV_072_SET_BETA_FACTOR_ALPHA_RMSK                  0x000000FF /* 31:24 */ 
#define NV_072_SET_BETA_FACTOR_ALPHA_WORD                  0
#define NV_072_SET_BETA_FACTOR_ALPHA_HIGH_FIELD            0x0000001F /* =31 */
#define NV_072_SET_BETA_FACTOR_ALPHA_LOW_FIELD             0x00000018 /* =24 */
#define NV_072_SET_BETA_FACTOR_MSK                         0xFFFFFFFF 
#define NV_01C_HIGH_FIELD                                  0x006A1FFF /* =6955007 */
#define NV_01C_LOW_FIELD                                   0x006A0000 /* =6946816 */
#define NV_01C_CTX_SWITCH_ADJ                              0x006A0000
#define NV_01C_CTX_SWITCH_INSTANCE_MSK                     0x0000FFFF /* 15:0 */ 
#define NV_01C_CTX_SWITCH_INSTANCE_RMSK                    0x0000FFFF /* 15:0 */ 
#define NV_01C_CTX_SWITCH_INSTANCE_WORD                    0
#define NV_01C_CTX_SWITCH_INSTANCE_HIGH_FIELD              0x0000000F /* =15 */
#define NV_01C_CTX_SWITCH_INSTANCE_LOW_FIELD               0x00000000 /* =0 */
#define NV_01C_CTX_SWITCH_CHID_MSK                         0x007F0000 /* 22:16 */ 
#define NV_01C_CTX_SWITCH_CHID_RMSK                        0x0000007F /* 22:16 */ 
#define NV_01C_CTX_SWITCH_CHID_WORD                        0
#define NV_01C_CTX_SWITCH_CHID_HIGH_FIELD                  0x00000016 /* =22 */
#define NV_01C_CTX_SWITCH_CHID_LOW_FIELD                   0x00000010 /* =16 */
#define NV_01C_CTX_SWITCH_VOLATILE_MSK                     0x80000000 /* 31:31 */ 
#define NV_01C_CTX_SWITCH_VOLATILE_RMSK                    0x00000001 /* 31:31 */ 
#define NV_01C_CTX_SWITCH_VOLATILE_WORD                    0
#define NV_01C_CTX_SWITCH_VOLATILE_HIGH_FIELD              0x0000001F /* =31 */
#define NV_01C_CTX_SWITCH_VOLATILE_LOW_FIELD               0x0000001F /* =31 */
#define NV_01C_CTX_SWITCH_VOLATILE_IGNORE_ADJ              0x00000000
#define NV_01C_CTX_SWITCH_VOLATILE_RESET_ADJ               0x80000000
#define NV_01C_CTX_SWITCH_MSK                              0x807FFFFF 
#define NV_01C_NOP_PARAMETER_MSK                           0xFFFFFFFF /* 31:0 */ 
#define NV_01C_NOP_PARAMETER_RMSK                          0xFFFFFFFF /* 31:0 */ 
#define NV_01C_NOP_PARAMETER_WORD                          0
#define NV_01C_NOP_PARAMETER_HIGH_FIELD                    0x0000001F /* =31 */
#define NV_01C_NOP_PARAMETER_LOW_FIELD                     0x00000000 /* =0 */
#define NV_01C_NOP_MSK                                     0xFFFFFFFF 
#define NV_01C_NOTIFY_STYLE_MSK                            0xFFFFFFFF /* 31:0 */ 
#define NV_01C_NOTIFY_STYLE_RMSK                           0xFFFFFFFF /* 31:0 */ 
#define NV_01C_NOTIFY_STYLE_WORD                           0
#define NV_01C_NOTIFY_STYLE_HIGH_FIELD                     0x0000001F /* =31 */
#define NV_01C_NOTIFY_STYLE_LOW_FIELD                      0x00000000 /* =0 */
#define NV_01C_NOTIFY_STYLE_WRITE_ONLY_ADJ                 0x00000000
#define NV_01C_NOTIFY_STYLE_WRITE_THEN_AWAKEN_ADJ          0x00000001
#define NV_01C_NOTIFY_MSK                                  0xFFFFFFFF 
#define NV_01C_SET_NOTIFY_PARAMETER_MSK                    0xFFFFFFFF /* 31:0 */ 
#define NV_01C_SET_NOTIFY_PARAMETER_RMSK                   0xFFFFFFFF /* 31:0 */ 
#define NV_01C_SET_NOTIFY_PARAMETER_WORD                   0
#define NV_01C_SET_NOTIFY_PARAMETER_HIGH_FIELD             0x0000001F /* =31 */
#define NV_01C_SET_NOTIFY_PARAMETER_LOW_FIELD              0x00000000 /* =0 */
#define NV_01C_SET_NOTIFY_PARAMETER_WRITE_ADJ              0x00000000
#define NV_01C_SET_NOTIFY_MSK                              0xFFFFFFFF 
#define NV_01C_SET_PATCH_PARAMETER_MSK                     0xFFFFFFFF /* 31:0 */ 
#define NV_01C_SET_PATCH_PARAMETER_RMSK                    0xFFFFFFFF /* 31:0 */ 
#define NV_01C_SET_PATCH_PARAMETER_WORD                    0
#define NV_01C_SET_PATCH_PARAMETER_HIGH_FIELD              0x0000001F /* =31 */
#define NV_01C_SET_PATCH_PARAMETER_LOW_FIELD               0x00000000 /* =0 */
#define NV_01C_SET_PATCH_PARAMETER_INVALIDATE_ADJ          0x00000000
#define NV_01C_SET_PATCH_PARAMETER_VALIDATE_ADJ            0x00000001
#define NV_01C_SET_PATCH_MSK                               0xFFFFFFFF 
#define NV_01C_SET_CONTEXT_DMA_NOTIFY_PARAMETER_MSK        0xFFFFFFFF /* 31:0 */ 
#define NV_01C_SET_CONTEXT_DMA_NOTIFY_PARAMETER_RMSK       0xFFFFFFFF /* 31:0 */ 
#define NV_01C_SET_CONTEXT_DMA_NOTIFY_PARAMETER_WORD       0
#define NV_01C_SET_CONTEXT_DMA_NOTIFY_PARAMETER_HIGH_FIELD 0x0000001F /* =31 */
#define NV_01C_SET_CONTEXT_DMA_NOTIFY_PARAMETER_LOW_FIELD  0x00000000 /* =0 */
#define NV_01C_SET_CONTEXT_DMA_NOTIFY_MSK                  0xFFFFFFFF 
#define NV_01C_SET_IMAGE_OUTPUT_PARAMETER_MSK              0xFFFFFFFF /* 31:0 */ 
#define NV_01C_SET_IMAGE_OUTPUT_PARAMETER_RMSK             0xFFFFFFFF /* 31:0 */ 
#define NV_01C_SET_IMAGE_OUTPUT_PARAMETER_WORD             0
#define NV_01C_SET_IMAGE_OUTPUT_PARAMETER_HIGH_FIELD       0x0000001F /* =31 */
#define NV_01C_SET_IMAGE_OUTPUT_PARAMETER_LOW_FIELD        0x00000000 /* =0 */
#define NV_01C_SET_IMAGE_OUTPUT_MSK                        0xFFFFFFFF 
#define NV_01C_SET_COLOR_FORMAT_LE_MSK                     0xFFFFFFFF /* 31:0 */ 
#define NV_01C_SET_COLOR_FORMAT_LE_RMSK                    0xFFFFFFFF /* 31:0 */ 
#define NV_01C_SET_COLOR_FORMAT_LE_WORD                    0
#define NV_01C_SET_COLOR_FORMAT_LE_HIGH_FIELD              0x0000001F /* =31 */
#define NV_01C_SET_COLOR_FORMAT_LE_LOW_FIELD               0x00000000 /* =0 */
#define NV_01C_SET_COLOR_FORMAT_LE_X24Y8_ADJ               0x00000001
#define NV_01C_SET_COLOR_FORMAT_LE_X17R5G5B5_ADJ           0x00000002
#define NV_01C_SET_COLOR_FORMAT_LE_X8R8G8B8_ADJ            0x00000003
#define NV_01C_SET_COLOR_FORMAT_LE_X16Y16_ADJ              0x00000004
#define NV_01C_SET_COLOR_FORMAT_MSK                        0xFFFFFFFF 
#define NV_01C_COLOR_VALUE_MSK                             0xFFFFFFFF /* 31:0 */ 
#define NV_01C_COLOR_VALUE_RMSK                            0xFFFFFFFF /* 31:0 */ 
#define NV_01C_COLOR_VALUE_WORD                            0
#define NV_01C_COLOR_VALUE_HIGH_FIELD                      0x0000001F /* =31 */
#define NV_01C_COLOR_VALUE_LOW_FIELD                       0x00000000 /* =0 */
#define NV_01C_COLOR_MSK                                   0xFFFFFFFF 
#define NV_01C_LIN_0_X_MSK                                 0x0000FFFF /* 15:0 */ 
#define NV_01C_LIN_0_X_RMSK                                0x0000FFFF /* 15:0 */ 
#define NV_01C_LIN_0_X_WORD                                0
#define NV_01C_LIN_0_X_HIGH_FIELD                          0x0000000F /* =15 */
#define NV_01C_LIN_0_X_LOW_FIELD                           0x00000000 /* =0 */
#define NV_01C_LIN_0_Y_MSK                                 0xFFFF0000 /* 31:16 */ 
#define NV_01C_LIN_0_Y_RMSK                                0x0000FFFF /* 31:16 */ 
#define NV_01C_LIN_0_Y_WORD                                0
#define NV_01C_LIN_0_Y_HIGH_FIELD                          0x0000001F /* =31 */
#define NV_01C_LIN_0_Y_LOW_FIELD                           0x00000010 /* =16 */
#define NV_01C_LIN_0_MSK                                   0xFFFFFFFF 
#define NV_01C_LIN_1_X_MSK                                 0x0000FFFF /* 15:0 */ 
#define NV_01C_LIN_1_X_RMSK                                0x0000FFFF /* 15:0 */ 
#define NV_01C_LIN_1_X_WORD                                0
#define NV_01C_LIN_1_X_HIGH_FIELD                          0x0000000F /* =15 */
#define NV_01C_LIN_1_X_LOW_FIELD                           0x00000000 /* =0 */
#define NV_01C_LIN_1_Y_MSK                                 0xFFFF0000 /* 31:16 */ 
#define NV_01C_LIN_1_Y_RMSK                                0x0000FFFF /* 31:16 */ 
#define NV_01C_LIN_1_Y_WORD                                0
#define NV_01C_LIN_1_Y_HIGH_FIELD                          0x0000001F /* =31 */
#define NV_01C_LIN_1_Y_LOW_FIELD                           0x00000010 /* =16 */
#define NV_01C_LIN_1_MSK                                   0xFFFFFFFF 
#define NV_01C_LIN32_0_X_MSK                               0xFFFFFFFF /* 31:0 */ 
#define NV_01C_LIN32_0_X_RMSK                              0xFFFFFFFF /* 31:0 */ 
#define NV_01C_LIN32_0_X_WORD                              0
#define NV_01C_LIN32_0_X_HIGH_FIELD                        0x0000001F /* =31 */
#define NV_01C_LIN32_0_X_LOW_FIELD                         0x00000000 /* =0 */
#define NV_01C_LIN32_0_MSK                                 0xFFFFFFFF 
#define NV_01C_LIN32_1_Y_MSK                               0xFFFFFFFF /* 31:0 */ 
#define NV_01C_LIN32_1_Y_RMSK                              0xFFFFFFFF /* 31:0 */ 
#define NV_01C_LIN32_1_Y_WORD                              0
#define NV_01C_LIN32_1_Y_HIGH_FIELD                        0x0000001F /* =31 */
#define NV_01C_LIN32_1_Y_LOW_FIELD                         0x00000000 /* =0 */
#define NV_01C_LIN32_1_MSK                                 0xFFFFFFFF 
#define NV_01C_LIN32_2_X_MSK                               0xFFFFFFFF /* 31:0 */ 
#define NV_01C_LIN32_2_X_RMSK                              0xFFFFFFFF /* 31:0 */ 
#define NV_01C_LIN32_2_X_WORD                              0
#define NV_01C_LIN32_2_X_HIGH_FIELD                        0x0000001F /* =31 */
#define NV_01C_LIN32_2_X_LOW_FIELD                         0x00000000 /* =0 */
#define NV_01C_LIN32_2_MSK                                 0xFFFFFFFF 
#define NV_01C_LIN32_3_Y_MSK                               0xFFFFFFFF /* 31:0 */ 
#define NV_01C_LIN32_3_Y_RMSK                              0xFFFFFFFF /* 31:0 */ 
#define NV_01C_LIN32_3_Y_WORD                              0
#define NV_01C_LIN32_3_Y_HIGH_FIELD                        0x0000001F /* =31 */
#define NV_01C_LIN32_3_Y_LOW_FIELD                         0x00000000 /* =0 */
#define NV_01C_LIN32_3_MSK                                 0xFFFFFFFF 
#define NV_01C_POLYLIN_X_MSK                               0x0000FFFF /* 15:0 */ 
#define NV_01C_POLYLIN_X_RMSK                              0x0000FFFF /* 15:0 */ 
#define NV_01C_POLYLIN_X_WORD                              0
#define NV_01C_POLYLIN_X_HIGH_FIELD                        0x0000000F /* =15 */
#define NV_01C_POLYLIN_X_LOW_FIELD                         0x00000000 /* =0 */
#define NV_01C_POLYLIN_Y_MSK                               0xFFFF0000 /* 31:16 */ 
#define NV_01C_POLYLIN_Y_RMSK                              0x0000FFFF /* 31:16 */ 
#define NV_01C_POLYLIN_Y_WORD                              0
#define NV_01C_POLYLIN_Y_HIGH_FIELD                        0x0000001F /* =31 */
#define NV_01C_POLYLIN_Y_LOW_FIELD                         0x00000010 /* =16 */
#define NV_01C_POLYLIN_MSK                                 0xFFFFFFFF 
#define NV_01C_POLYLIN32_0_X_MSK                           0xFFFFFFFF /* 31:0 */ 
#define NV_01C_POLYLIN32_0_X_RMSK                          0xFFFFFFFF /* 31:0 */ 
#define NV_01C_POLYLIN32_0_X_WORD                          0
#define NV_01C_POLYLIN32_0_X_HIGH_FIELD                    0x0000001F /* =31 */
#define NV_01C_POLYLIN32_0_X_LOW_FIELD                     0x00000000 /* =0 */
#define NV_01C_POLYLIN32_0_MSK                             0xFFFFFFFF 
#define NV_01C_POLYLIN32_1_Y_MSK                           0xFFFFFFFF /* 31:0 */ 
#define NV_01C_POLYLIN32_1_Y_RMSK                          0xFFFFFFFF /* 31:0 */ 
#define NV_01C_POLYLIN32_1_Y_WORD                          0
#define NV_01C_POLYLIN32_1_Y_HIGH_FIELD                    0x0000001F /* =31 */
#define NV_01C_POLYLIN32_1_Y_LOW_FIELD                     0x00000000 /* =0 */
#define NV_01C_POLYLIN32_1_MSK                             0xFFFFFFFF 
#define NV_01C_CPOLYLIN_0_COLOR_MSK                        0xFFFFFFFF /* 31:0 */ 
#define NV_01C_CPOLYLIN_0_COLOR_RMSK                       0xFFFFFFFF /* 31:0 */ 
#define NV_01C_CPOLYLIN_0_COLOR_WORD                       0
#define NV_01C_CPOLYLIN_0_COLOR_HIGH_FIELD                 0x0000001F /* =31 */
#define NV_01C_CPOLYLIN_0_COLOR_LOW_FIELD                  0x00000000 /* =0 */
#define NV_01C_CPOLYLIN_0_MSK                              0xFFFFFFFF 
#define NV_01C_CPOLYLIN_1_X_MSK                            0x0000FFFF /* 15:0 */ 
#define NV_01C_CPOLYLIN_1_X_RMSK                           0x0000FFFF /* 15:0 */ 
#define NV_01C_CPOLYLIN_1_X_WORD                           0
#define NV_01C_CPOLYLIN_1_X_HIGH_FIELD                     0x0000000F /* =15 */
#define NV_01C_CPOLYLIN_1_X_LOW_FIELD                      0x00000000 /* =0 */
#define NV_01C_CPOLYLIN_1_Y_MSK                            0xFFFF0000 /* 31:16 */ 
#define NV_01C_CPOLYLIN_1_Y_RMSK                           0x0000FFFF /* 31:16 */ 
#define NV_01C_CPOLYLIN_1_Y_WORD                           0
#define NV_01C_CPOLYLIN_1_Y_HIGH_FIELD                     0x0000001F /* =31 */
#define NV_01C_CPOLYLIN_1_Y_LOW_FIELD                      0x00000010 /* =16 */
#define NV_01C_CPOLYLIN_1_MSK                              0xFFFFFFFF 
#define NV_ULIN_HIGH_FIELD                                 0x004A1FFF /* =4857855 */
#define NV_ULIN_LOW_FIELD                                  0x004A0000 /* =4849664 */
#define NV_ULIN_CTX_SWITCH_ADJ                             0x004A0000
#define NV_ULIN_CTX_SWITCH_INSTANCE_MSK                    0x0000FFFF /* 15:0 */ 
#define NV_ULIN_CTX_SWITCH_INSTANCE_RMSK                   0x0000FFFF /* 15:0 */ 
#define NV_ULIN_CTX_SWITCH_INSTANCE_WORD                   0
#define NV_ULIN_CTX_SWITCH_INSTANCE_HIGH_FIELD             0x0000000F /* =15 */
#define NV_ULIN_CTX_SWITCH_INSTANCE_LOW_FIELD              0x00000000 /* =0 */
#define NV_ULIN_CTX_SWITCH_CHID_MSK                        0x007F0000 /* 22:16 */ 
#define NV_ULIN_CTX_SWITCH_CHID_RMSK                       0x0000007F /* 22:16 */ 
#define NV_ULIN_CTX_SWITCH_CHID_WORD                       0
#define NV_ULIN_CTX_SWITCH_CHID_HIGH_FIELD                 0x00000016 /* =22 */
#define NV_ULIN_CTX_SWITCH_CHID_LOW_FIELD                  0x00000010 /* =16 */
#define NV_ULIN_CTX_SWITCH_VOLATILE_MSK                    0x80000000 /* 31:31 */ 
#define NV_ULIN_CTX_SWITCH_VOLATILE_RMSK                   0x00000001 /* 31:31 */ 
#define NV_ULIN_CTX_SWITCH_VOLATILE_WORD                   0
#define NV_ULIN_CTX_SWITCH_VOLATILE_HIGH_FIELD             0x0000001F /* =31 */
#define NV_ULIN_CTX_SWITCH_VOLATILE_LOW_FIELD              0x0000001F /* =31 */
#define NV_ULIN_CTX_SWITCH_VOLATILE_IGNORE_ADJ             0x00000000
#define NV_ULIN_CTX_SWITCH_VOLATILE_RESET_ADJ              0x80000000
#define NV_ULIN_CTX_SWITCH_MSK                             0x807FFFFF 
#define NV_ULIN_NOP_PARAMETER_MSK                          0xFFFFFFFF /* 31:0 */ 
#define NV_ULIN_NOP_PARAMETER_RMSK                         0xFFFFFFFF /* 31:0 */ 
#define NV_ULIN_NOP_PARAMETER_WORD                         0
#define NV_ULIN_NOP_PARAMETER_HIGH_FIELD                   0x0000001F /* =31 */
#define NV_ULIN_NOP_PARAMETER_LOW_FIELD                    0x00000000 /* =0 */
#define NV_ULIN_NOP_MSK                                    0xFFFFFFFF 
#define NV_ULIN_NOTIFY_STYLE_MSK                           0xFFFFFFFF /* 31:0 */ 
#define NV_ULIN_NOTIFY_STYLE_RMSK                          0xFFFFFFFF /* 31:0 */ 
#define NV_ULIN_NOTIFY_STYLE_WORD                          0
#define NV_ULIN_NOTIFY_STYLE_HIGH_FIELD                    0x0000001F /* =31 */
#define NV_ULIN_NOTIFY_STYLE_LOW_FIELD                     0x00000000 /* =0 */
#define NV_ULIN_NOTIFY_STYLE_WRITE_ONLY_ADJ                0x00000000
#define NV_ULIN_NOTIFY_STYLE_WRITE_THEN_AWAKEN_ADJ         0x00000001
#define NV_ULIN_NOTIFY_MSK                                 0xFFFFFFFF 
#define NV_ULIN_SET_NOTIFY_PARAMETER_MSK                   0xFFFFFFFF /* 31:0 */ 
#define NV_ULIN_SET_NOTIFY_PARAMETER_RMSK                  0xFFFFFFFF /* 31:0 */ 
#define NV_ULIN_SET_NOTIFY_PARAMETER_WORD                  0
#define NV_ULIN_SET_NOTIFY_PARAMETER_HIGH_FIELD            0x0000001F /* =31 */
#define NV_ULIN_SET_NOTIFY_PARAMETER_LOW_FIELD             0x00000000 /* =0 */
#define NV_ULIN_SET_NOTIFY_PARAMETER_WRITE_ADJ             0x00000000
#define NV_ULIN_SET_NOTIFY_MSK                             0xFFFFFFFF 
#define NV_ULIN_SET_PATCH_PARAMETER_MSK                    0xFFFFFFFF /* 31:0 */ 
#define NV_ULIN_SET_PATCH_PARAMETER_RMSK                   0xFFFFFFFF /* 31:0 */ 
#define NV_ULIN_SET_PATCH_PARAMETER_WORD                   0
#define NV_ULIN_SET_PATCH_PARAMETER_HIGH_FIELD             0x0000001F /* =31 */
#define NV_ULIN_SET_PATCH_PARAMETER_LOW_FIELD              0x00000000 /* =0 */
#define NV_ULIN_SET_PATCH_PARAMETER_INVALIDATE_ADJ         0x00000000
#define NV_ULIN_SET_PATCH_PARAMETER_VALIDATE_ADJ           0x00000001
#define NV_ULIN_SET_PATCH_MSK                              0xFFFFFFFF 
#define NV_ULIN_SET_CONTEXT_DMA_NOTIFY_PARAMETER_MSK       0xFFFFFFFF /* 31:0 */ 
#define NV_ULIN_SET_CONTEXT_DMA_NOTIFY_PARAMETER_RMSK      0xFFFFFFFF /* 31:0 */ 
#define NV_ULIN_SET_CONTEXT_DMA_NOTIFY_PARAMETER_WORD      0
#define NV_ULIN_SET_CONTEXT_DMA_NOTIFY_PARAMETER_HIGH_FIELD 0x0000001F /* =31 */
#define NV_ULIN_SET_CONTEXT_DMA_NOTIFY_PARAMETER_LOW_FIELD 0x00000000 /* =0 */
#define NV_ULIN_SET_CONTEXT_DMA_NOTIFY_MSK                 0xFFFFFFFF 
#define NV_ULIN_SET_IMAGE_OUTPUT_PARAMETER_MSK             0xFFFFFFFF /* 31:0 */ 
#define NV_ULIN_SET_IMAGE_OUTPUT_PARAMETER_RMSK            0xFFFFFFFF /* 31:0 */ 
#define NV_ULIN_SET_IMAGE_OUTPUT_PARAMETER_WORD            0
#define NV_ULIN_SET_IMAGE_OUTPUT_PARAMETER_HIGH_FIELD      0x0000001F /* =31 */
#define NV_ULIN_SET_IMAGE_OUTPUT_PARAMETER_LOW_FIELD       0x00000000 /* =0 */
#define NV_ULIN_SET_IMAGE_OUTPUT_MSK                       0xFFFFFFFF 
#define NV_ULIN_SET_COLOR_FORMAT_LE_MSK                    0xFFFFFFFF /* 31:0 */ 
#define NV_ULIN_SET_COLOR_FORMAT_LE_RMSK                   0xFFFFFFFF /* 31:0 */ 
#define NV_ULIN_SET_COLOR_FORMAT_LE_WORD                   0
#define NV_ULIN_SET_COLOR_FORMAT_LE_HIGH_FIELD             0x0000001F /* =31 */
#define NV_ULIN_SET_COLOR_FORMAT_LE_LOW_FIELD              0x00000000 /* =0 */
#define NV_ULIN_SET_COLOR_FORMAT_LE_X16R5G6B5_ADJ          0x00000001
#define NV_ULIN_SET_COLOR_FORMAT_LE_X17R5G5B5_ADJ          0x00000002
#define NV_ULIN_SET_COLOR_FORMAT_LE_X8R8G8B8_ADJ           0x00000003
#define NV_ULIN_SET_COLOR_FORMAT_MSK                       0xFFFFFFFF 
#define NV_ULIN_COLOR_VALUE_MSK                            0xFFFFFFFF /* 31:0 */ 
#define NV_ULIN_COLOR_VALUE_RMSK                           0xFFFFFFFF /* 31:0 */ 
#define NV_ULIN_COLOR_VALUE_WORD                           0
#define NV_ULIN_COLOR_VALUE_HIGH_FIELD                     0x0000001F /* =31 */
#define NV_ULIN_COLOR_VALUE_LOW_FIELD                      0x00000000 /* =0 */
#define NV_ULIN_COLOR_MSK                                  0xFFFFFFFF 
#define NV_ULIN_LIN_0_X_MSK                                0x0000FFFF /* 15:0 */ 
#define NV_ULIN_LIN_0_X_RMSK                               0x0000FFFF /* 15:0 */ 
#define NV_ULIN_LIN_0_X_WORD                               0
#define NV_ULIN_LIN_0_X_HIGH_FIELD                         0x0000000F /* =15 */
#define NV_ULIN_LIN_0_X_LOW_FIELD                          0x00000000 /* =0 */
#define NV_ULIN_LIN_0_Y_MSK                                0xFFFF0000 /* 31:16 */ 
#define NV_ULIN_LIN_0_Y_RMSK                               0x0000FFFF /* 31:16 */ 
#define NV_ULIN_LIN_0_Y_WORD                               0
#define NV_ULIN_LIN_0_Y_HIGH_FIELD                         0x0000001F /* =31 */
#define NV_ULIN_LIN_0_Y_LOW_FIELD                          0x00000010 /* =16 */
#define NV_ULIN_LIN_0_MSK                                  0xFFFFFFFF 
#define NV_ULIN_LIN_1_X_MSK                                0x0000FFFF /* 15:0 */ 
#define NV_ULIN_LIN_1_X_RMSK                               0x0000FFFF /* 15:0 */ 
#define NV_ULIN_LIN_1_X_WORD                               0
#define NV_ULIN_LIN_1_X_HIGH_FIELD                         0x0000000F /* =15 */
#define NV_ULIN_LIN_1_X_LOW_FIELD                          0x00000000 /* =0 */
#define NV_ULIN_LIN_1_Y_MSK                                0xFFFF0000 /* 31:16 */ 
#define NV_ULIN_LIN_1_Y_RMSK                               0x0000FFFF /* 31:16 */ 
#define NV_ULIN_LIN_1_Y_WORD                               0
#define NV_ULIN_LIN_1_Y_HIGH_FIELD                         0x0000001F /* =31 */
#define NV_ULIN_LIN_1_Y_LOW_FIELD                          0x00000010 /* =16 */
#define NV_ULIN_LIN_1_MSK                                  0xFFFFFFFF 
#define NV_ULIN_LIN32_0_X_MSK                              0xFFFFFFFF /* 31:0 */ 
#define NV_ULIN_LIN32_0_X_RMSK                             0xFFFFFFFF /* 31:0 */ 
#define NV_ULIN_LIN32_0_X_WORD                             0
#define NV_ULIN_LIN32_0_X_HIGH_FIELD                       0x0000001F /* =31 */
#define NV_ULIN_LIN32_0_X_LOW_FIELD                        0x00000000 /* =0 */
#define NV_ULIN_LIN32_0_MSK                                0xFFFFFFFF 
#define NV_ULIN_LIN32_1_Y_MSK                              0xFFFFFFFF /* 31:0 */ 
#define NV_ULIN_LIN32_1_Y_RMSK                             0xFFFFFFFF /* 31:0 */ 
#define NV_ULIN_LIN32_1_Y_WORD                             0
#define NV_ULIN_LIN32_1_Y_HIGH_FIELD                       0x0000001F /* =31 */
#define NV_ULIN_LIN32_1_Y_LOW_FIELD                        0x00000000 /* =0 */
#define NV_ULIN_LIN32_1_MSK                                0xFFFFFFFF 
#define NV_ULIN_LIN32_2_X_MSK                              0xFFFFFFFF /* 31:0 */ 
#define NV_ULIN_LIN32_2_X_RMSK                             0xFFFFFFFF /* 31:0 */ 
#define NV_ULIN_LIN32_2_X_WORD                             0
#define NV_ULIN_LIN32_2_X_HIGH_FIELD                       0x0000001F /* =31 */
#define NV_ULIN_LIN32_2_X_LOW_FIELD                        0x00000000 /* =0 */
#define NV_ULIN_LIN32_2_MSK                                0xFFFFFFFF 
#define NV_ULIN_LIN32_3_Y_MSK                              0xFFFFFFFF /* 31:0 */ 
#define NV_ULIN_LIN32_3_Y_RMSK                             0xFFFFFFFF /* 31:0 */ 
#define NV_ULIN_LIN32_3_Y_WORD                             0
#define NV_ULIN_LIN32_3_Y_HIGH_FIELD                       0x0000001F /* =31 */
#define NV_ULIN_LIN32_3_Y_LOW_FIELD                        0x00000000 /* =0 */
#define NV_ULIN_LIN32_3_MSK                                0xFFFFFFFF 
#define NV_ULIN_POLYLIN_X_MSK                              0x0000FFFF /* 15:0 */ 
#define NV_ULIN_POLYLIN_X_RMSK                             0x0000FFFF /* 15:0 */ 
#define NV_ULIN_POLYLIN_X_WORD                             0
#define NV_ULIN_POLYLIN_X_HIGH_FIELD                       0x0000000F /* =15 */
#define NV_ULIN_POLYLIN_X_LOW_FIELD                        0x00000000 /* =0 */
#define NV_ULIN_POLYLIN_Y_MSK                              0xFFFF0000 /* 31:16 */ 
#define NV_ULIN_POLYLIN_Y_RMSK                             0x0000FFFF /* 31:16 */ 
#define NV_ULIN_POLYLIN_Y_WORD                             0
#define NV_ULIN_POLYLIN_Y_HIGH_FIELD                       0x0000001F /* =31 */
#define NV_ULIN_POLYLIN_Y_LOW_FIELD                        0x00000010 /* =16 */
#define NV_ULIN_POLYLIN_MSK                                0xFFFFFFFF 
#define NV_ULIN_POLYLIN32_0_X_MSK                          0xFFFFFFFF /* 31:0 */ 
#define NV_ULIN_POLYLIN32_0_X_RMSK                         0xFFFFFFFF /* 31:0 */ 
#define NV_ULIN_POLYLIN32_0_X_WORD                         0
#define NV_ULIN_POLYLIN32_0_X_HIGH_FIELD                   0x0000001F /* =31 */
#define NV_ULIN_POLYLIN32_0_X_LOW_FIELD                    0x00000000 /* =0 */
#define NV_ULIN_POLYLIN32_0_MSK                            0xFFFFFFFF 
#define NV_ULIN_POLYLIN32_1_Y_MSK                          0xFFFFFFFF /* 31:0 */ 
#define NV_ULIN_POLYLIN32_1_Y_RMSK                         0xFFFFFFFF /* 31:0 */ 
#define NV_ULIN_POLYLIN32_1_Y_WORD                         0
#define NV_ULIN_POLYLIN32_1_Y_HIGH_FIELD                   0x0000001F /* =31 */
#define NV_ULIN_POLYLIN32_1_Y_LOW_FIELD                    0x00000000 /* =0 */
#define NV_ULIN_POLYLIN32_1_MSK                            0xFFFFFFFF 
#define NV_ULIN_CPOLYLIN_0_COLOR_MSK                       0xFFFFFFFF /* 31:0 */ 
#define NV_ULIN_CPOLYLIN_0_COLOR_RMSK                      0xFFFFFFFF /* 31:0 */ 
#define NV_ULIN_CPOLYLIN_0_COLOR_WORD                      0
#define NV_ULIN_CPOLYLIN_0_COLOR_HIGH_FIELD                0x0000001F /* =31 */
#define NV_ULIN_CPOLYLIN_0_COLOR_LOW_FIELD                 0x00000000 /* =0 */
#define NV_ULIN_CPOLYLIN_0_MSK                             0xFFFFFFFF 
#define NV_ULIN_CPOLYLIN_1_X_MSK                           0x0000FFFF /* 15:0 */ 
#define NV_ULIN_CPOLYLIN_1_X_RMSK                          0x0000FFFF /* 15:0 */ 
#define NV_ULIN_CPOLYLIN_1_X_WORD                          0
#define NV_ULIN_CPOLYLIN_1_X_HIGH_FIELD                    0x0000000F /* =15 */
#define NV_ULIN_CPOLYLIN_1_X_LOW_FIELD                     0x00000000 /* =0 */
#define NV_ULIN_CPOLYLIN_1_Y_MSK                           0xFFFF0000 /* 31:16 */ 
#define NV_ULIN_CPOLYLIN_1_Y_RMSK                          0x0000FFFF /* 31:16 */ 
#define NV_ULIN_CPOLYLIN_1_Y_WORD                          0
#define NV_ULIN_CPOLYLIN_1_Y_HIGH_FIELD                    0x0000001F /* =31 */
#define NV_ULIN_CPOLYLIN_1_Y_LOW_FIELD                     0x00000010 /* =16 */
#define NV_ULIN_CPOLYLIN_1_MSK                             0xFFFFFFFF 
#define NV_URECT_HIGH_FIELD                                0x00471FFF /* =4661247 */
#define NV_URECT_LOW_FIELD                                 0x00470000 /* =4653056 */
#define NV_URECT_CTX_SWITCH_ADJ                            0x00470000
#define NV_URECT_CTX_SWITCH_INSTANCE_MSK                   0x0000FFFF /* 15:0 */ 
#define NV_URECT_CTX_SWITCH_INSTANCE_RMSK                  0x0000FFFF /* 15:0 */ 
#define NV_URECT_CTX_SWITCH_INSTANCE_WORD                  0
#define NV_URECT_CTX_SWITCH_INSTANCE_HIGH_FIELD            0x0000000F /* =15 */
#define NV_URECT_CTX_SWITCH_INSTANCE_LOW_FIELD             0x00000000 /* =0 */
#define NV_URECT_CTX_SWITCH_CHID_MSK                       0x007F0000 /* 22:16 */ 
#define NV_URECT_CTX_SWITCH_CHID_RMSK                      0x0000007F /* 22:16 */ 
#define NV_URECT_CTX_SWITCH_CHID_WORD                      0
#define NV_URECT_CTX_SWITCH_CHID_HIGH_FIELD                0x00000016 /* =22 */
#define NV_URECT_CTX_SWITCH_CHID_LOW_FIELD                 0x00000010 /* =16 */
#define NV_URECT_CTX_SWITCH_VOLATILE_MSK                   0x80000000 /* 31:31 */ 
#define NV_URECT_CTX_SWITCH_VOLATILE_RMSK                  0x00000001 /* 31:31 */ 
#define NV_URECT_CTX_SWITCH_VOLATILE_WORD                  0
#define NV_URECT_CTX_SWITCH_VOLATILE_HIGH_FIELD            0x0000001F /* =31 */
#define NV_URECT_CTX_SWITCH_VOLATILE_LOW_FIELD             0x0000001F /* =31 */
#define NV_URECT_CTX_SWITCH_VOLATILE_IGNORE_ADJ            0x00000000
#define NV_URECT_CTX_SWITCH_VOLATILE_RESET_ADJ             0x80000000
#define NV_URECT_CTX_SWITCH_MSK                            0x807FFFFF 
#define NV_URECT_NOP_PARAMETER_MSK                         0xFFFFFFFF /* 31:0 */ 
#define NV_URECT_NOP_PARAMETER_RMSK                        0xFFFFFFFF /* 31:0 */ 
#define NV_URECT_NOP_PARAMETER_WORD                        0
#define NV_URECT_NOP_PARAMETER_HIGH_FIELD                  0x0000001F /* =31 */
#define NV_URECT_NOP_PARAMETER_LOW_FIELD                   0x00000000 /* =0 */
#define NV_URECT_NOP_MSK                                   0xFFFFFFFF 
#define NV_URECT_NOTIFY_STYLE_MSK                          0xFFFFFFFF /* 31:0 */ 
#define NV_URECT_NOTIFY_STYLE_RMSK                         0xFFFFFFFF /* 31:0 */ 
#define NV_URECT_NOTIFY_STYLE_WORD                         0
#define NV_URECT_NOTIFY_STYLE_HIGH_FIELD                   0x0000001F /* =31 */
#define NV_URECT_NOTIFY_STYLE_LOW_FIELD                    0x00000000 /* =0 */
#define NV_URECT_NOTIFY_STYLE_WRITE_ONLY_ADJ               0x00000000
#define NV_URECT_NOTIFY_STYLE_WRITE_THEN_AWAKEN_ADJ        0x00000001
#define NV_URECT_NOTIFY_MSK                                0xFFFFFFFF 
#define NV_URECT_SET_NOTIFY_PARAMETER_MSK                  0xFFFFFFFF /* 31:0 */ 
#define NV_URECT_SET_NOTIFY_PARAMETER_RMSK                 0xFFFFFFFF /* 31:0 */ 
#define NV_URECT_SET_NOTIFY_PARAMETER_WORD                 0
#define NV_URECT_SET_NOTIFY_PARAMETER_HIGH_FIELD           0x0000001F /* =31 */
#define NV_URECT_SET_NOTIFY_PARAMETER_LOW_FIELD            0x00000000 /* =0 */
#define NV_URECT_SET_NOTIFY_PARAMETER_WRITE_ADJ            0x00000000
#define NV_URECT_SET_NOTIFY_MSK                            0xFFFFFFFF 
#define NV_URECT_SET_PATCH_PARAMETER_MSK                   0xFFFFFFFF /* 31:0 */ 
#define NV_URECT_SET_PATCH_PARAMETER_RMSK                  0xFFFFFFFF /* 31:0 */ 
#define NV_URECT_SET_PATCH_PARAMETER_WORD                  0
#define NV_URECT_SET_PATCH_PARAMETER_HIGH_FIELD            0x0000001F /* =31 */
#define NV_URECT_SET_PATCH_PARAMETER_LOW_FIELD             0x00000000 /* =0 */
#define NV_URECT_SET_PATCH_PARAMETER_INVALIDATE_ADJ        0x00000000
#define NV_URECT_SET_PATCH_PARAMETER_VALIDATE_ADJ          0x00000001
#define NV_URECT_SET_PATCH_MSK                             0xFFFFFFFF 
#define NV_URECT_SET_CONTEXT_DMA_NOTIFY_PARAMETER_MSK      0xFFFFFFFF /* 31:0 */ 
#define NV_URECT_SET_CONTEXT_DMA_NOTIFY_PARAMETER_RMSK     0xFFFFFFFF /* 31:0 */ 
#define NV_URECT_SET_CONTEXT_DMA_NOTIFY_PARAMETER_WORD     0
#define NV_URECT_SET_CONTEXT_DMA_NOTIFY_PARAMETER_HIGH_FIELD 0x0000001F /* =31 */
#define NV_URECT_SET_CONTEXT_DMA_NOTIFY_PARAMETER_LOW_FIELD 0x00000000 /* =0 */
#define NV_URECT_SET_CONTEXT_DMA_NOTIFY_MSK                0xFFFFFFFF 
#define NV_URECT_SET_IMAGE_OUTPUT_PARAMETER_MSK            0xFFFFFFFF /* 31:0 */ 
#define NV_URECT_SET_IMAGE_OUTPUT_PARAMETER_RMSK           0xFFFFFFFF /* 31:0 */ 
#define NV_URECT_SET_IMAGE_OUTPUT_PARAMETER_WORD           0
#define NV_URECT_SET_IMAGE_OUTPUT_PARAMETER_HIGH_FIELD     0x0000001F /* =31 */
#define NV_URECT_SET_IMAGE_OUTPUT_PARAMETER_LOW_FIELD      0x00000000 /* =0 */
#define NV_URECT_SET_IMAGE_OUTPUT_MSK                      0xFFFFFFFF 
#define NV_URECT_SET_COLOR_FORMAT_LE_MSK                   0xFFFFFFFF /* 31:0 */ 
#define NV_URECT_SET_COLOR_FORMAT_LE_RMSK                  0xFFFFFFFF /* 31:0 */ 
#define NV_URECT_SET_COLOR_FORMAT_LE_WORD                  0
#define NV_URECT_SET_COLOR_FORMAT_LE_HIGH_FIELD            0x0000001F /* =31 */
#define NV_URECT_SET_COLOR_FORMAT_LE_LOW_FIELD             0x00000000 /* =0 */
#define NV_URECT_SET_COLOR_FORMAT_LE_X16R5G6B5_ADJ         0x00000001
#define NV_URECT_SET_COLOR_FORMAT_LE_X17R5G5B5_ADJ         0x00000002
#define NV_URECT_SET_COLOR_FORMAT_LE_X8R8G8B8_ADJ          0x00000003
#define NV_URECT_SET_COLOR_FORMAT_MSK                      0xFFFFFFFF 
#define NV_URECT_COLOR_VALUE_MSK                           0xFFFFFFFF /* 31:0 */ 
#define NV_URECT_COLOR_VALUE_RMSK                          0xFFFFFFFF /* 31:0 */ 
#define NV_URECT_COLOR_VALUE_WORD                          0
#define NV_URECT_COLOR_VALUE_HIGH_FIELD                    0x0000001F /* =31 */
#define NV_URECT_COLOR_VALUE_LOW_FIELD                     0x00000000 /* =0 */
#define NV_URECT_COLOR_MSK                                 0xFFFFFFFF 
#define NV_URECT_RECTANGLE_0_X_MSK                         0x0000FFFF /* 15:0 */ 
#define NV_URECT_RECTANGLE_0_X_RMSK                        0x0000FFFF /* 15:0 */ 
#define NV_URECT_RECTANGLE_0_X_WORD                        0
#define NV_URECT_RECTANGLE_0_X_HIGH_FIELD                  0x0000000F /* =15 */
#define NV_URECT_RECTANGLE_0_X_LOW_FIELD                   0x00000000 /* =0 */
#define NV_URECT_RECTANGLE_0_Y_MSK                         0xFFFF0000 /* 31:16 */ 
#define NV_URECT_RECTANGLE_0_Y_RMSK                        0x0000FFFF /* 31:16 */ 
#define NV_URECT_RECTANGLE_0_Y_WORD                        0
#define NV_URECT_RECTANGLE_0_Y_HIGH_FIELD                  0x0000001F /* =31 */
#define NV_URECT_RECTANGLE_0_Y_LOW_FIELD                   0x00000010 /* =16 */
#define NV_URECT_RECTANGLE_0_MSK                           0xFFFFFFFF 
#define NV_URECT_RECTANGLE_1_WIDTH_MSK                     0x0000FFFF /* 15:0 */ 
#define NV_URECT_RECTANGLE_1_WIDTH_RMSK                    0x0000FFFF /* 15:0 */ 
#define NV_URECT_RECTANGLE_1_WIDTH_WORD                    0
#define NV_URECT_RECTANGLE_1_WIDTH_HIGH_FIELD              0x0000000F /* =15 */
#define NV_URECT_RECTANGLE_1_WIDTH_LOW_FIELD               0x00000000 /* =0 */
#define NV_URECT_RECTANGLE_1_HEIGHT_MSK                    0xFFFF0000 /* 31:16 */ 
#define NV_URECT_RECTANGLE_1_HEIGHT_RMSK                   0x0000FFFF /* 31:16 */ 
#define NV_URECT_RECTANGLE_1_HEIGHT_WORD                   0
#define NV_URECT_RECTANGLE_1_HEIGHT_HIGH_FIELD             0x0000001F /* =31 */
#define NV_URECT_RECTANGLE_1_HEIGHT_LOW_FIELD              0x00000010 /* =16 */
#define NV_URECT_RECTANGLE_1_MSK                           0xFFFFFFFF 
#define NV_UTRI_HIGH_FIELD                                 0x004B1FFF /* =4923391 */
#define NV_UTRI_LOW_FIELD                                  0x004B0000 /* =4915200 */
#define NV_UTRI_CTX_SWITCH_ADJ                             0x004B0000
#define NV_UTRI_CTX_SWITCH_INSTANCE_MSK                    0x0000FFFF /* 15:0 */ 
#define NV_UTRI_CTX_SWITCH_INSTANCE_RMSK                   0x0000FFFF /* 15:0 */ 
#define NV_UTRI_CTX_SWITCH_INSTANCE_WORD                   0
#define NV_UTRI_CTX_SWITCH_INSTANCE_HIGH_FIELD             0x0000000F /* =15 */
#define NV_UTRI_CTX_SWITCH_INSTANCE_LOW_FIELD              0x00000000 /* =0 */
#define NV_UTRI_CTX_SWITCH_CHID_MSK                        0x007F0000 /* 22:16 */ 
#define NV_UTRI_CTX_SWITCH_CHID_RMSK                       0x0000007F /* 22:16 */ 
#define NV_UTRI_CTX_SWITCH_CHID_WORD                       0
#define NV_UTRI_CTX_SWITCH_CHID_HIGH_FIELD                 0x00000016 /* =22 */
#define NV_UTRI_CTX_SWITCH_CHID_LOW_FIELD                  0x00000010 /* =16 */
#define NV_UTRI_CTX_SWITCH_VOLATILE_MSK                    0x80000000 /* 31:31 */ 
#define NV_UTRI_CTX_SWITCH_VOLATILE_RMSK                   0x00000001 /* 31:31 */ 
#define NV_UTRI_CTX_SWITCH_VOLATILE_WORD                   0
#define NV_UTRI_CTX_SWITCH_VOLATILE_HIGH_FIELD             0x0000001F /* =31 */
#define NV_UTRI_CTX_SWITCH_VOLATILE_LOW_FIELD              0x0000001F /* =31 */
#define NV_UTRI_CTX_SWITCH_VOLATILE_IGNORE_ADJ             0x00000000
#define NV_UTRI_CTX_SWITCH_VOLATILE_RESET_ADJ              0x80000000
#define NV_UTRI_CTX_SWITCH_MSK                             0x807FFFFF 
#define NV_UTRI_NOP_PARAMETER_MSK                          0xFFFFFFFF /* 31:0 */ 
#define NV_UTRI_NOP_PARAMETER_RMSK                         0xFFFFFFFF /* 31:0 */ 
#define NV_UTRI_NOP_PARAMETER_WORD                         0
#define NV_UTRI_NOP_PARAMETER_HIGH_FIELD                   0x0000001F /* =31 */
#define NV_UTRI_NOP_PARAMETER_LOW_FIELD                    0x00000000 /* =0 */
#define NV_UTRI_NOP_MSK                                    0xFFFFFFFF 
#define NV_UTRI_NOTIFY_STYLE_MSK                           0xFFFFFFFF /* 31:0 */ 
#define NV_UTRI_NOTIFY_STYLE_RMSK                          0xFFFFFFFF /* 31:0 */ 
#define NV_UTRI_NOTIFY_STYLE_WORD                          0
#define NV_UTRI_NOTIFY_STYLE_HIGH_FIELD                    0x0000001F /* =31 */
#define NV_UTRI_NOTIFY_STYLE_LOW_FIELD                     0x00000000 /* =0 */
#define NV_UTRI_NOTIFY_STYLE_WRITE_ONLY_ADJ                0x00000000
#define NV_UTRI_NOTIFY_STYLE_WRITE_THEN_AWAKEN_ADJ         0x00000001
#define NV_UTRI_NOTIFY_MSK                                 0xFFFFFFFF 
#define NV_UTRI_SET_NOTIFY_PARAMETER_MSK                   0xFFFFFFFF /* 31:0 */ 
#define NV_UTRI_SET_NOTIFY_PARAMETER_RMSK                  0xFFFFFFFF /* 31:0 */ 
#define NV_UTRI_SET_NOTIFY_PARAMETER_WORD                  0
#define NV_UTRI_SET_NOTIFY_PARAMETER_HIGH_FIELD            0x0000001F /* =31 */
#define NV_UTRI_SET_NOTIFY_PARAMETER_LOW_FIELD             0x00000000 /* =0 */
#define NV_UTRI_SET_NOTIFY_PARAMETER_WRITE_ADJ             0x00000000
#define NV_UTRI_SET_NOTIFY_MSK                             0xFFFFFFFF 
#define NV_UTRI_SET_PATCH_PARAMETER_MSK                    0xFFFFFFFF /* 31:0 */ 
#define NV_UTRI_SET_PATCH_PARAMETER_RMSK                   0xFFFFFFFF /* 31:0 */ 
#define NV_UTRI_SET_PATCH_PARAMETER_WORD                   0
#define NV_UTRI_SET_PATCH_PARAMETER_HIGH_FIELD             0x0000001F /* =31 */
#define NV_UTRI_SET_PATCH_PARAMETER_LOW_FIELD              0x00000000 /* =0 */
#define NV_UTRI_SET_PATCH_PARAMETER_INVALIDATE_ADJ         0x00000000
#define NV_UTRI_SET_PATCH_PARAMETER_VALIDATE_ADJ           0x00000001
#define NV_UTRI_SET_PATCH_MSK                              0xFFFFFFFF 
#define NV_UTRI_SET_CONTEXT_DMA_NOTIFY_PARAMETER_MSK       0xFFFFFFFF /* 31:0 */ 
#define NV_UTRI_SET_CONTEXT_DMA_NOTIFY_PARAMETER_RMSK      0xFFFFFFFF /* 31:0 */ 
#define NV_UTRI_SET_CONTEXT_DMA_NOTIFY_PARAMETER_WORD      0
#define NV_UTRI_SET_CONTEXT_DMA_NOTIFY_PARAMETER_HIGH_FIELD 0x0000001F /* =31 */
#define NV_UTRI_SET_CONTEXT_DMA_NOTIFY_PARAMETER_LOW_FIELD 0x00000000 /* =0 */
#define NV_UTRI_SET_CONTEXT_DMA_NOTIFY_MSK                 0xFFFFFFFF 
#define NV_UTRI_SET_IMAGE_OUTPUT_PARAMETER_MSK             0xFFFFFFFF /* 31:0 */ 
#define NV_UTRI_SET_IMAGE_OUTPUT_PARAMETER_RMSK            0xFFFFFFFF /* 31:0 */ 
#define NV_UTRI_SET_IMAGE_OUTPUT_PARAMETER_WORD            0
#define NV_UTRI_SET_IMAGE_OUTPUT_PARAMETER_HIGH_FIELD      0x0000001F /* =31 */
#define NV_UTRI_SET_IMAGE_OUTPUT_PARAMETER_LOW_FIELD       0x00000000 /* =0 */
#define NV_UTRI_SET_IMAGE_OUTPUT_MSK                       0xFFFFFFFF 
#define NV_UTRI_SET_COLOR_FORMAT_LE_MSK                    0xFFFFFFFF /* 31:0 */ 
#define NV_UTRI_SET_COLOR_FORMAT_LE_RMSK                   0xFFFFFFFF /* 31:0 */ 
#define NV_UTRI_SET_COLOR_FORMAT_LE_WORD                   0
#define NV_UTRI_SET_COLOR_FORMAT_LE_HIGH_FIELD             0x0000001F /* =31 */
#define NV_UTRI_SET_COLOR_FORMAT_LE_LOW_FIELD              0x00000000 /* =0 */
#define NV_UTRI_SET_COLOR_FORMAT_LE_X16R5G6B5_ADJ          0x00000001
#define NV_UTRI_SET_COLOR_FORMAT_LE_X17R5G5B5_ADJ          0x00000002
#define NV_UTRI_SET_COLOR_FORMAT_LE_X8R8G8B8_ADJ           0x00000003
#define NV_UTRI_SET_COLOR_FORMAT_MSK                       0xFFFFFFFF 
#define NV_UTRI_COLOR_VALUE_MSK                            0xFFFFFFFF /* 31:0 */ 
#define NV_UTRI_COLOR_VALUE_RMSK                           0xFFFFFFFF /* 31:0 */ 
#define NV_UTRI_COLOR_VALUE_WORD                           0
#define NV_UTRI_COLOR_VALUE_HIGH_FIELD                     0x0000001F /* =31 */
#define NV_UTRI_COLOR_VALUE_LOW_FIELD                      0x00000000 /* =0 */
#define NV_UTRI_COLOR_MSK                                  0xFFFFFFFF 
#define NV_UTRI_TRIANGLE_0_X_MSK                           0x0000FFFF /* 15:0 */ 
#define NV_UTRI_TRIANGLE_0_X_RMSK                          0x0000FFFF /* 15:0 */ 
#define NV_UTRI_TRIANGLE_0_X_WORD                          0
#define NV_UTRI_TRIANGLE_0_X_HIGH_FIELD                    0x0000000F /* =15 */
#define NV_UTRI_TRIANGLE_0_X_LOW_FIELD                     0x00000000 /* =0 */
#define NV_UTRI_TRIANGLE_0_Y_MSK                           0xFFFF0000 /* 31:16 */ 
#define NV_UTRI_TRIANGLE_0_Y_RMSK                          0x0000FFFF /* 31:16 */ 
#define NV_UTRI_TRIANGLE_0_Y_WORD                          0
#define NV_UTRI_TRIANGLE_0_Y_HIGH_FIELD                    0x0000001F /* =31 */
#define NV_UTRI_TRIANGLE_0_Y_LOW_FIELD                     0x00000010 /* =16 */
#define NV_UTRI_TRIANGLE_0_MSK                             0xFFFFFFFF 
#define NV_UTRI_TRIANGLE_1_X_MSK                           0x0000FFFF /* 15:0 */ 
#define NV_UTRI_TRIANGLE_1_X_RMSK                          0x0000FFFF /* 15:0 */ 
#define NV_UTRI_TRIANGLE_1_X_WORD                          0
#define NV_UTRI_TRIANGLE_1_X_HIGH_FIELD                    0x0000000F /* =15 */
#define NV_UTRI_TRIANGLE_1_X_LOW_FIELD                     0x00000000 /* =0 */
#define NV_UTRI_TRIANGLE_1_Y_MSK                           0xFFFF0000 /* 31:16 */ 
#define NV_UTRI_TRIANGLE_1_Y_RMSK                          0x0000FFFF /* 31:16 */ 
#define NV_UTRI_TRIANGLE_1_Y_WORD                          0
#define NV_UTRI_TRIANGLE_1_Y_HIGH_FIELD                    0x0000001F /* =31 */
#define NV_UTRI_TRIANGLE_1_Y_LOW_FIELD                     0x00000010 /* =16 */
#define NV_UTRI_TRIANGLE_1_MSK                             0xFFFFFFFF 
#define NV_UTRI_TRIANGLE_2_X_MSK                           0x0000FFFF /* 15:0 */ 
#define NV_UTRI_TRIANGLE_2_X_RMSK                          0x0000FFFF /* 15:0 */ 
#define NV_UTRI_TRIANGLE_2_X_WORD                          0
#define NV_UTRI_TRIANGLE_2_X_HIGH_FIELD                    0x0000000F /* =15 */
#define NV_UTRI_TRIANGLE_2_X_LOW_FIELD                     0x00000000 /* =0 */
#define NV_UTRI_TRIANGLE_2_Y_MSK                           0xFFFF0000 /* 31:16 */ 
#define NV_UTRI_TRIANGLE_2_Y_RMSK                          0x0000FFFF /* 31:16 */ 
#define NV_UTRI_TRIANGLE_2_Y_WORD                          0
#define NV_UTRI_TRIANGLE_2_Y_HIGH_FIELD                    0x0000001F /* =31 */
#define NV_UTRI_TRIANGLE_2_Y_LOW_FIELD                     0x00000010 /* =16 */
#define NV_UTRI_TRIANGLE_2_MSK                             0xFFFFFFFF 
#define NV_UTRI_TRIANGLE32_0_X_MSK                         0xFFFFFFFF /* 31:0 */ 
#define NV_UTRI_TRIANGLE32_0_X_RMSK                        0xFFFFFFFF /* 31:0 */ 
#define NV_UTRI_TRIANGLE32_0_X_WORD                        0
#define NV_UTRI_TRIANGLE32_0_X_HIGH_FIELD                  0x0000001F /* =31 */
#define NV_UTRI_TRIANGLE32_0_X_LOW_FIELD                   0x00000000 /* =0 */
#define NV_UTRI_TRIANGLE32_0_MSK                           0xFFFFFFFF 
#define NV_UTRI_TRIANGLE32_1_Y_MSK                         0xFFFFFFFF /* 31:0 */ 
#define NV_UTRI_TRIANGLE32_1_Y_RMSK                        0xFFFFFFFF /* 31:0 */ 
#define NV_UTRI_TRIANGLE32_1_Y_WORD                        0
#define NV_UTRI_TRIANGLE32_1_Y_HIGH_FIELD                  0x0000001F /* =31 */
#define NV_UTRI_TRIANGLE32_1_Y_LOW_FIELD                   0x00000000 /* =0 */
#define NV_UTRI_TRIANGLE32_1_MSK                           0xFFFFFFFF 
#define NV_UTRI_TRIANGLE32_2_X_MSK                         0xFFFFFFFF /* 31:0 */ 
#define NV_UTRI_TRIANGLE32_2_X_RMSK                        0xFFFFFFFF /* 31:0 */ 
#define NV_UTRI_TRIANGLE32_2_X_WORD                        0
#define NV_UTRI_TRIANGLE32_2_X_HIGH_FIELD                  0x0000001F /* =31 */
#define NV_UTRI_TRIANGLE32_2_X_LOW_FIELD                   0x00000000 /* =0 */
#define NV_UTRI_TRIANGLE32_2_MSK                           0xFFFFFFFF 
#define NV_UTRI_TRIANGLE32_3_Y_MSK                         0xFFFFFFFF /* 31:0 */ 
#define NV_UTRI_TRIANGLE32_3_Y_RMSK                        0xFFFFFFFF /* 31:0 */ 
#define NV_UTRI_TRIANGLE32_3_Y_WORD                        0
#define NV_UTRI_TRIANGLE32_3_Y_HIGH_FIELD                  0x0000001F /* =31 */
#define NV_UTRI_TRIANGLE32_3_Y_LOW_FIELD                   0x00000000 /* =0 */
#define NV_UTRI_TRIANGLE32_3_MSK                           0xFFFFFFFF 
#define NV_UTRI_TRIANGLE32_4_X_MSK                         0xFFFFFFFF /* 31:0 */ 
#define NV_UTRI_TRIANGLE32_4_X_RMSK                        0xFFFFFFFF /* 31:0 */ 
#define NV_UTRI_TRIANGLE32_4_X_WORD                        0
#define NV_UTRI_TRIANGLE32_4_X_HIGH_FIELD                  0x0000001F /* =31 */
#define NV_UTRI_TRIANGLE32_4_X_LOW_FIELD                   0x00000000 /* =0 */
#define NV_UTRI_TRIANGLE32_4_MSK                           0xFFFFFFFF 
#define NV_UTRI_TRIANGLE32_5_Y_MSK                         0xFFFFFFFF /* 31:0 */ 
#define NV_UTRI_TRIANGLE32_5_Y_RMSK                        0xFFFFFFFF /* 31:0 */ 
#define NV_UTRI_TRIANGLE32_5_Y_WORD                        0
#define NV_UTRI_TRIANGLE32_5_Y_HIGH_FIELD                  0x0000001F /* =31 */
#define NV_UTRI_TRIANGLE32_5_Y_LOW_FIELD                   0x00000000 /* =0 */
#define NV_UTRI_TRIANGLE32_5_MSK                           0xFFFFFFFF 
#define NV_UTRI_TRIMESH_X_MSK                              0x0000FFFF /* 15:0 */ 
#define NV_UTRI_TRIMESH_X_RMSK                             0x0000FFFF /* 15:0 */ 
#define NV_UTRI_TRIMESH_X_WORD                             0
#define NV_UTRI_TRIMESH_X_HIGH_FIELD                       0x0000000F /* =15 */
#define NV_UTRI_TRIMESH_X_LOW_FIELD                        0x00000000 /* =0 */
#define NV_UTRI_TRIMESH_Y_MSK                              0xFFFF0000 /* 31:16 */ 
#define NV_UTRI_TRIMESH_Y_RMSK                             0x0000FFFF /* 31:16 */ 
#define NV_UTRI_TRIMESH_Y_WORD                             0
#define NV_UTRI_TRIMESH_Y_HIGH_FIELD                       0x0000001F /* =31 */
#define NV_UTRI_TRIMESH_Y_LOW_FIELD                        0x00000010 /* =16 */
#define NV_UTRI_TRIMESH_MSK                                0xFFFFFFFF 
#define NV_UTRI_TRIMESH32_0_X_MSK                          0xFFFFFFFF /* 31:0 */ 
#define NV_UTRI_TRIMESH32_0_X_RMSK                         0xFFFFFFFF /* 31:0 */ 
#define NV_UTRI_TRIMESH32_0_X_WORD                         0
#define NV_UTRI_TRIMESH32_0_X_HIGH_FIELD                   0x0000001F /* =31 */
#define NV_UTRI_TRIMESH32_0_X_LOW_FIELD                    0x00000000 /* =0 */
#define NV_UTRI_TRIMESH32_0_MSK                            0xFFFFFFFF 
#define NV_UTRI_TRIMESH32_1_Y_MSK                          0xFFFFFFFF /* 31:0 */ 
#define NV_UTRI_TRIMESH32_1_Y_RMSK                         0xFFFFFFFF /* 31:0 */ 
#define NV_UTRI_TRIMESH32_1_Y_WORD                         0
#define NV_UTRI_TRIMESH32_1_Y_HIGH_FIELD                   0x0000001F /* =31 */
#define NV_UTRI_TRIMESH32_1_Y_LOW_FIELD                    0x00000000 /* =0 */
#define NV_UTRI_TRIMESH32_1_MSK                            0xFFFFFFFF 
#define NV_UTRI_CTRIANGLE_0_COLOR_MSK                      0xFFFFFFFF /* 31:0 */ 
#define NV_UTRI_CTRIANGLE_0_COLOR_RMSK                     0xFFFFFFFF /* 31:0 */ 
#define NV_UTRI_CTRIANGLE_0_COLOR_WORD                     0
#define NV_UTRI_CTRIANGLE_0_COLOR_HIGH_FIELD               0x0000001F /* =31 */
#define NV_UTRI_CTRIANGLE_0_COLOR_LOW_FIELD                0x00000000 /* =0 */
#define NV_UTRI_CTRIANGLE_0_MSK                            0xFFFFFFFF 
#define NV_UTRI_CTRIANGLE_1_X_MSK                          0x0000FFFF /* 15:0 */ 
#define NV_UTRI_CTRIANGLE_1_X_RMSK                         0x0000FFFF /* 15:0 */ 
#define NV_UTRI_CTRIANGLE_1_X_WORD                         0
#define NV_UTRI_CTRIANGLE_1_X_HIGH_FIELD                   0x0000000F /* =15 */
#define NV_UTRI_CTRIANGLE_1_X_LOW_FIELD                    0x00000000 /* =0 */
#define NV_UTRI_CTRIANGLE_1_Y_MSK                          0xFFFF0000 /* 31:16 */ 
#define NV_UTRI_CTRIANGLE_1_Y_RMSK                         0x0000FFFF /* 31:16 */ 
#define NV_UTRI_CTRIANGLE_1_Y_WORD                         0
#define NV_UTRI_CTRIANGLE_1_Y_HIGH_FIELD                   0x0000001F /* =31 */
#define NV_UTRI_CTRIANGLE_1_Y_LOW_FIELD                    0x00000010 /* =16 */
#define NV_UTRI_CTRIANGLE_1_MSK                            0xFFFFFFFF 
#define NV_UTRI_CTRIANGLE_2_X_MSK                          0x0000FFFF /* 15:0 */ 
#define NV_UTRI_CTRIANGLE_2_X_RMSK                         0x0000FFFF /* 15:0 */ 
#define NV_UTRI_CTRIANGLE_2_X_WORD                         0
#define NV_UTRI_CTRIANGLE_2_X_HIGH_FIELD                   0x0000000F /* =15 */
#define NV_UTRI_CTRIANGLE_2_X_LOW_FIELD                    0x00000000 /* =0 */
#define NV_UTRI_CTRIANGLE_2_Y_MSK                          0xFFFF0000 /* 31:16 */ 
#define NV_UTRI_CTRIANGLE_2_Y_RMSK                         0x0000FFFF /* 31:16 */ 
#define NV_UTRI_CTRIANGLE_2_Y_WORD                         0
#define NV_UTRI_CTRIANGLE_2_Y_HIGH_FIELD                   0x0000001F /* =31 */
#define NV_UTRI_CTRIANGLE_2_Y_LOW_FIELD                    0x00000010 /* =16 */
#define NV_UTRI_CTRIANGLE_2_MSK                            0xFFFFFFFF 
#define NV_UTRI_CTRIANGLE_3_X_MSK                          0x0000FFFF /* 15:0 */ 
#define NV_UTRI_CTRIANGLE_3_X_RMSK                         0x0000FFFF /* 15:0 */ 
#define NV_UTRI_CTRIANGLE_3_X_WORD                         0
#define NV_UTRI_CTRIANGLE_3_X_HIGH_FIELD                   0x0000000F /* =15 */
#define NV_UTRI_CTRIANGLE_3_X_LOW_FIELD                    0x00000000 /* =0 */
#define NV_UTRI_CTRIANGLE_3_Y_MSK                          0xFFFF0000 /* 31:16 */ 
#define NV_UTRI_CTRIANGLE_3_Y_RMSK                         0x0000FFFF /* 31:16 */ 
#define NV_UTRI_CTRIANGLE_3_Y_WORD                         0
#define NV_UTRI_CTRIANGLE_3_Y_HIGH_FIELD                   0x0000001F /* =31 */
#define NV_UTRI_CTRIANGLE_3_Y_LOW_FIELD                    0x00000010 /* =16 */
#define NV_UTRI_CTRIANGLE_3_MSK                            0xFFFFFFFF 
#define NV_UTRI_CTRIMESH_0_COLOR_MSK                       0xFFFFFFFF /* 31:0 */ 
#define NV_UTRI_CTRIMESH_0_COLOR_RMSK                      0xFFFFFFFF /* 31:0 */ 
#define NV_UTRI_CTRIMESH_0_COLOR_WORD                      0
#define NV_UTRI_CTRIMESH_0_COLOR_HIGH_FIELD                0x0000001F /* =31 */
#define NV_UTRI_CTRIMESH_0_COLOR_LOW_FIELD                 0x00000000 /* =0 */
#define NV_UTRI_CTRIMESH_0_MSK                             0xFFFFFFFF 
#define NV_UTRI_CTRIMESH_1_X_MSK                           0x0000FFFF /* 15:0 */ 
#define NV_UTRI_CTRIMESH_1_X_RMSK                          0x0000FFFF /* 15:0 */ 
#define NV_UTRI_CTRIMESH_1_X_WORD                          0
#define NV_UTRI_CTRIMESH_1_X_HIGH_FIELD                    0x0000000F /* =15 */
#define NV_UTRI_CTRIMESH_1_X_LOW_FIELD                     0x00000000 /* =0 */
#define NV_UTRI_CTRIMESH_1_Y_MSK                           0xFFFF0000 /* 31:16 */ 
#define NV_UTRI_CTRIMESH_1_Y_RMSK                          0x0000FFFF /* 31:16 */ 
#define NV_UTRI_CTRIMESH_1_Y_WORD                          0
#define NV_UTRI_CTRIMESH_1_Y_HIGH_FIELD                    0x0000001F /* =31 */
#define NV_UTRI_CTRIMESH_1_Y_LOW_FIELD                     0x00000010 /* =16 */
#define NV_UTRI_CTRIMESH_1_MSK                             0xFFFFFFFF 
#define NV_UBLIT_HIGH_FIELD                                0x00501FFF /* =5251071 */
#define NV_UBLIT_LOW_FIELD                                 0x00500000 /* =5242880 */
#define NV_UBLIT_CTX_SWITCH_ADJ                            0x00500000
#define NV_UBLIT_CTX_SWITCH_INSTANCE_MSK                   0x0000FFFF /* 15:0 */ 
#define NV_UBLIT_CTX_SWITCH_INSTANCE_RMSK                  0x0000FFFF /* 15:0 */ 
#define NV_UBLIT_CTX_SWITCH_INSTANCE_WORD                  0
#define NV_UBLIT_CTX_SWITCH_INSTANCE_HIGH_FIELD            0x0000000F /* =15 */
#define NV_UBLIT_CTX_SWITCH_INSTANCE_LOW_FIELD             0x00000000 /* =0 */
#define NV_UBLIT_CTX_SWITCH_CHID_MSK                       0x007F0000 /* 22:16 */ 
#define NV_UBLIT_CTX_SWITCH_CHID_RMSK                      0x0000007F /* 22:16 */ 
#define NV_UBLIT_CTX_SWITCH_CHID_WORD                      0
#define NV_UBLIT_CTX_SWITCH_CHID_HIGH_FIELD                0x00000016 /* =22 */
#define NV_UBLIT_CTX_SWITCH_CHID_LOW_FIELD                 0x00000010 /* =16 */
#define NV_UBLIT_CTX_SWITCH_VOLATILE_MSK                   0x80000000 /* 31:31 */ 
#define NV_UBLIT_CTX_SWITCH_VOLATILE_RMSK                  0x00000001 /* 31:31 */ 
#define NV_UBLIT_CTX_SWITCH_VOLATILE_WORD                  0
#define NV_UBLIT_CTX_SWITCH_VOLATILE_HIGH_FIELD            0x0000001F /* =31 */
#define NV_UBLIT_CTX_SWITCH_VOLATILE_LOW_FIELD             0x0000001F /* =31 */
#define NV_UBLIT_CTX_SWITCH_VOLATILE_IGNORE_ADJ            0x00000000
#define NV_UBLIT_CTX_SWITCH_VOLATILE_RESET_ADJ             0x80000000
#define NV_UBLIT_CTX_SWITCH_MSK                            0x807FFFFF 
#define NV_UBLIT_NOP_PARAMETER_MSK                         0xFFFFFFFF /* 31:0 */ 
#define NV_UBLIT_NOP_PARAMETER_RMSK                        0xFFFFFFFF /* 31:0 */ 
#define NV_UBLIT_NOP_PARAMETER_WORD                        0
#define NV_UBLIT_NOP_PARAMETER_HIGH_FIELD                  0x0000001F /* =31 */
#define NV_UBLIT_NOP_PARAMETER_LOW_FIELD                   0x00000000 /* =0 */
#define NV_UBLIT_NOP_MSK                                   0xFFFFFFFF 
#define NV_UBLIT_NOTIFY_STYLE_MSK                          0xFFFFFFFF /* 31:0 */ 
#define NV_UBLIT_NOTIFY_STYLE_RMSK                         0xFFFFFFFF /* 31:0 */ 
#define NV_UBLIT_NOTIFY_STYLE_WORD                         0
#define NV_UBLIT_NOTIFY_STYLE_HIGH_FIELD                   0x0000001F /* =31 */
#define NV_UBLIT_NOTIFY_STYLE_LOW_FIELD                    0x00000000 /* =0 */
#define NV_UBLIT_NOTIFY_STYLE_WRITE_ONLY_ADJ               0x00000000
#define NV_UBLIT_NOTIFY_STYLE_WRITE_THEN_AWAKEN_ADJ        0x00000001
#define NV_UBLIT_NOTIFY_MSK                                0xFFFFFFFF 
#define NV_UBLIT_SET_NOTIFY_PARAMETER_MSK                  0xFFFFFFFF /* 31:0 */ 
#define NV_UBLIT_SET_NOTIFY_PARAMETER_RMSK                 0xFFFFFFFF /* 31:0 */ 
#define NV_UBLIT_SET_NOTIFY_PARAMETER_WORD                 0
#define NV_UBLIT_SET_NOTIFY_PARAMETER_HIGH_FIELD           0x0000001F /* =31 */
#define NV_UBLIT_SET_NOTIFY_PARAMETER_LOW_FIELD            0x00000000 /* =0 */
#define NV_UBLIT_SET_NOTIFY_PARAMETER_WRITE_ADJ            0x00000000
#define NV_UBLIT_SET_NOTIFY_MSK                            0xFFFFFFFF 
#define NV_UBLIT_SET_PATCH_PARAMETER_MSK                   0xFFFFFFFF /* 31:0 */ 
#define NV_UBLIT_SET_PATCH_PARAMETER_RMSK                  0xFFFFFFFF /* 31:0 */ 
#define NV_UBLIT_SET_PATCH_PARAMETER_WORD                  0
#define NV_UBLIT_SET_PATCH_PARAMETER_HIGH_FIELD            0x0000001F /* =31 */
#define NV_UBLIT_SET_PATCH_PARAMETER_LOW_FIELD             0x00000000 /* =0 */
#define NV_UBLIT_SET_PATCH_PARAMETER_INVALIDATE_ADJ        0x00000000
#define NV_UBLIT_SET_PATCH_PARAMETER_VALIDATE_ADJ          0x00000001
#define NV_UBLIT_SET_PATCH_MSK                             0xFFFFFFFF 
#define NV_UBLIT_SET_CONTEXT_DMA_NOTIFY_PARAMETER_MSK      0xFFFFFFFF /* 31:0 */ 
#define NV_UBLIT_SET_CONTEXT_DMA_NOTIFY_PARAMETER_RMSK     0xFFFFFFFF /* 31:0 */ 
#define NV_UBLIT_SET_CONTEXT_DMA_NOTIFY_PARAMETER_WORD     0
#define NV_UBLIT_SET_CONTEXT_DMA_NOTIFY_PARAMETER_HIGH_FIELD 0x0000001F /* =31 */
#define NV_UBLIT_SET_CONTEXT_DMA_NOTIFY_PARAMETER_LOW_FIELD 0x00000000 /* =0 */
#define NV_UBLIT_SET_CONTEXT_DMA_NOTIFY_MSK                0xFFFFFFFF 
#define NV_UBLIT_SET_IMAGE_OUTPUT_PARAMETER_MSK            0xFFFFFFFF /* 31:0 */ 
#define NV_UBLIT_SET_IMAGE_OUTPUT_PARAMETER_RMSK           0xFFFFFFFF /* 31:0 */ 
#define NV_UBLIT_SET_IMAGE_OUTPUT_PARAMETER_WORD           0
#define NV_UBLIT_SET_IMAGE_OUTPUT_PARAMETER_HIGH_FIELD     0x0000001F /* =31 */
#define NV_UBLIT_SET_IMAGE_OUTPUT_PARAMETER_LOW_FIELD      0x00000000 /* =0 */
#define NV_UBLIT_SET_IMAGE_OUTPUT_MSK                      0xFFFFFFFF 
#define NV_UBLIT_SET_IMAGE_INPUT_PARAMETER_MSK             0xFFFFFFFF /* 31:0 */ 
#define NV_UBLIT_SET_IMAGE_INPUT_PARAMETER_RMSK            0xFFFFFFFF /* 31:0 */ 
#define NV_UBLIT_SET_IMAGE_INPUT_PARAMETER_WORD            0
#define NV_UBLIT_SET_IMAGE_INPUT_PARAMETER_HIGH_FIELD      0x0000001F /* =31 */
#define NV_UBLIT_SET_IMAGE_INPUT_PARAMETER_LOW_FIELD       0x00000000 /* =0 */
#define NV_UBLIT_SET_IMAGE_INPUT_MSK                       0xFFFFFFFF 
#define NV_UBLIT_POINT_IN_X_MSK                            0x0000FFFF /* 15:0 */ 
#define NV_UBLIT_POINT_IN_X_RMSK                           0x0000FFFF /* 15:0 */ 
#define NV_UBLIT_POINT_IN_X_WORD                           0
#define NV_UBLIT_POINT_IN_X_HIGH_FIELD                     0x0000000F /* =15 */
#define NV_UBLIT_POINT_IN_X_LOW_FIELD                      0x00000000 /* =0 */
#define NV_UBLIT_POINT_IN_Y_MSK                            0xFFFF0000 /* 31:16 */ 
#define NV_UBLIT_POINT_IN_Y_RMSK                           0x0000FFFF /* 31:16 */ 
#define NV_UBLIT_POINT_IN_Y_WORD                           0
#define NV_UBLIT_POINT_IN_Y_HIGH_FIELD                     0x0000001F /* =31 */
#define NV_UBLIT_POINT_IN_Y_LOW_FIELD                      0x00000010 /* =16 */
#define NV_UBLIT_POINT_IN_MSK                              0xFFFFFFFF 
#define NV_UBLIT_POINT_OUT_X_MSK                           0x0000FFFF /* 15:0 */ 
#define NV_UBLIT_POINT_OUT_X_RMSK                          0x0000FFFF /* 15:0 */ 
#define NV_UBLIT_POINT_OUT_X_WORD                          0
#define NV_UBLIT_POINT_OUT_X_HIGH_FIELD                    0x0000000F /* =15 */
#define NV_UBLIT_POINT_OUT_X_LOW_FIELD                     0x00000000 /* =0 */
#define NV_UBLIT_POINT_OUT_Y_MSK                           0xFFFF0000 /* 31:16 */ 
#define NV_UBLIT_POINT_OUT_Y_RMSK                          0x0000FFFF /* 31:16 */ 
#define NV_UBLIT_POINT_OUT_Y_WORD                          0
#define NV_UBLIT_POINT_OUT_Y_HIGH_FIELD                    0x0000001F /* =31 */
#define NV_UBLIT_POINT_OUT_Y_LOW_FIELD                     0x00000010 /* =16 */
#define NV_UBLIT_POINT_OUT_MSK                             0xFFFFFFFF 
#define NV_UBLIT_SIZE_WIDTH_MSK                            0x0000FFFF /* 15:0 */ 
#define NV_UBLIT_SIZE_WIDTH_RMSK                           0x0000FFFF /* 15:0 */ 
#define NV_UBLIT_SIZE_WIDTH_WORD                           0
#define NV_UBLIT_SIZE_WIDTH_HIGH_FIELD                     0x0000000F /* =15 */
#define NV_UBLIT_SIZE_WIDTH_LOW_FIELD                      0x00000000 /* =0 */
#define NV_UBLIT_SIZE_HEIGHT_MSK                           0xFFFF0000 /* 31:16 */ 
#define NV_UBLIT_SIZE_HEIGHT_RMSK                          0x0000FFFF /* 31:16 */ 
#define NV_UBLIT_SIZE_HEIGHT_WORD                          0
#define NV_UBLIT_SIZE_HEIGHT_HIGH_FIELD                    0x0000001F /* =31 */
#define NV_UBLIT_SIZE_HEIGHT_LOW_FIELD                     0x00000010 /* =16 */
#define NV_UBLIT_SIZE_MSK                                  0xFFFFFFFF 
#define NV_09F_HIGH_FIELD                                  0x00501FFF /* =5251071 */
#define NV_09F_LOW_FIELD                                   0x00500000 /* =5242880 */
#define NV_09F_NV12_IMAGE_BLIT_ADJ                         0x00500000
#define NV_09F_NV12_IMAGE_BLIT_HANDLE_MSK                  0xFFFFFFFF /* 31:0 */ 
#define NV_09F_NV12_IMAGE_BLIT_HANDLE_RMSK                 0xFFFFFFFF /* 31:0 */ 
#define NV_09F_NV12_IMAGE_BLIT_HANDLE_WORD                 0
#define NV_09F_NV12_IMAGE_BLIT_HANDLE_HIGH_FIELD           0x0000001F /* =31 */
#define NV_09F_NV12_IMAGE_BLIT_HANDLE_LOW_FIELD            0x00000000 /* =0 */
#define NV_09F_NV12_IMAGE_BLIT_MSK                         0xFFFFFFFF 
#define NV_09F_NOP_PARAMETER_MSK                           0xFFFFFFFF /* 31:0 */ 
#define NV_09F_NOP_PARAMETER_RMSK                          0xFFFFFFFF /* 31:0 */ 
#define NV_09F_NOP_PARAMETER_WORD                          0
#define NV_09F_NOP_PARAMETER_HIGH_FIELD                    0x0000001F /* =31 */
#define NV_09F_NOP_PARAMETER_LOW_FIELD                     0x00000000 /* =0 */
#define NV_09F_NOP_MSK                                     0xFFFFFFFF 
#define NV_09F_NOTIFY_STYLE_MSK                            0xFFFFFFFF /* 31:0 */ 
#define NV_09F_NOTIFY_STYLE_RMSK                           0xFFFFFFFF /* 31:0 */ 
#define NV_09F_NOTIFY_STYLE_WORD                           0
#define NV_09F_NOTIFY_STYLE_HIGH_FIELD                     0x0000001F /* =31 */
#define NV_09F_NOTIFY_STYLE_LOW_FIELD                      0x00000000 /* =0 */
#define NV_09F_NOTIFY_STYLE_WRITE_ONLY_ADJ                 0x00000000
#define NV_09F_NOTIFY_STYLE_WRITE_THEN_AWAKEN_ADJ          0x00000001
#define NV_09F_NOTIFY_MSK                                  0xFFFFFFFF 
#define NV_09F_SET_NOTIFY_PARAMETER_MSK                    0xFFFFFFFF /* 31:0 */ 
#define NV_09F_SET_NOTIFY_PARAMETER_RMSK                   0xFFFFFFFF /* 31:0 */ 
#define NV_09F_SET_NOTIFY_PARAMETER_WORD                   0
#define NV_09F_SET_NOTIFY_PARAMETER_HIGH_FIELD             0x0000001F /* =31 */
#define NV_09F_SET_NOTIFY_PARAMETER_LOW_FIELD              0x00000000 /* =0 */
#define NV_09F_SET_NOTIFY_PARAMETER_WRITE_ADJ              0x00000000
#define NV_09F_SET_NOTIFY_MSK                              0xFFFFFFFF 
#define NV_09F_WAIT_FOR_IDLE_PARAMETER_MSK                 0xFFFFFFFF /* 31:0 */ 
#define NV_09F_WAIT_FOR_IDLE_PARAMETER_RMSK                0xFFFFFFFF /* 31:0 */ 
#define NV_09F_WAIT_FOR_IDLE_PARAMETER_WORD                0
#define NV_09F_WAIT_FOR_IDLE_PARAMETER_HIGH_FIELD          0x0000001F /* =31 */
#define NV_09F_WAIT_FOR_IDLE_PARAMETER_LOW_FIELD           0x00000000 /* =0 */
#define NV_09F_WAIT_FOR_IDLE_MSK                           0xFFFFFFFF 
#define NV_09F_SET_READ_PARAMETER_MSK                      0xFFFFFFFF /* 31:0 */ 
#define NV_09F_SET_READ_PARAMETER_RMSK                     0xFFFFFFFF /* 31:0 */ 
#define NV_09F_SET_READ_PARAMETER_WORD                     0
#define NV_09F_SET_READ_PARAMETER_HIGH_FIELD               0x0000001F /* =31 */
#define NV_09F_SET_READ_PARAMETER_LOW_FIELD                0x00000000 /* =0 */
#define NV_09F_SET_READ_MSK                                0xFFFFFFFF 
#define NV_09F_SET_WRITE_PARAMETER_MSK                     0xFFFFFFFF /* 31:0 */ 
#define NV_09F_SET_WRITE_PARAMETER_RMSK                    0xFFFFFFFF /* 31:0 */ 
#define NV_09F_SET_WRITE_PARAMETER_WORD                    0
#define NV_09F_SET_WRITE_PARAMETER_HIGH_FIELD              0x0000001F /* =31 */
#define NV_09F_SET_WRITE_PARAMETER_LOW_FIELD               0x00000000 /* =0 */
#define NV_09F_SET_WRITE_MSK                               0xFFFFFFFF 
#define NV_09F_SET_MODULO_PARAMETER_MSK                    0xFFFFFFFF /* 31:0 */ 
#define NV_09F_SET_MODULO_PARAMETER_RMSK                   0xFFFFFFFF /* 31:0 */ 
#define NV_09F_SET_MODULO_PARAMETER_WORD                   0
#define NV_09F_SET_MODULO_PARAMETER_HIGH_FIELD             0x0000001F /* =31 */
#define NV_09F_SET_MODULO_PARAMETER_LOW_FIELD              0x00000000 /* =0 */
#define NV_09F_SET_MODULO_MSK                              0xFFFFFFFF 
#define NV_09F_INCREMENT_WRITE_PARAMETER_MSK               0xFFFFFFFF /* 31:0 */ 
#define NV_09F_INCREMENT_WRITE_PARAMETER_RMSK              0xFFFFFFFF /* 31:0 */ 
#define NV_09F_INCREMENT_WRITE_PARAMETER_WORD              0
#define NV_09F_INCREMENT_WRITE_PARAMETER_HIGH_FIELD        0x0000001F /* =31 */
#define NV_09F_INCREMENT_WRITE_PARAMETER_LOW_FIELD         0x00000000 /* =0 */
#define NV_09F_INCREMENT_WRITE_MSK                         0xFFFFFFFF 
#define NV_09F_STALL_PARAMETER_MSK                         0xFFFFFFFF /* 31:0 */ 
#define NV_09F_STALL_PARAMETER_RMSK                        0xFFFFFFFF /* 31:0 */ 
#define NV_09F_STALL_PARAMETER_WORD                        0
#define NV_09F_STALL_PARAMETER_HIGH_FIELD                  0x0000001F /* =31 */
#define NV_09F_STALL_PARAMETER_LOW_FIELD                   0x00000000 /* =0 */
#define NV_09F_STALL_MSK                                   0xFFFFFFFF 
#define NV_09F_INCREMENT_READ_RANGE_PARAMETER_MSK          0xFFFFFFFF /* 31:0 */ 
#define NV_09F_INCREMENT_READ_RANGE_PARAMETER_RMSK         0xFFFFFFFF /* 31:0 */ 
#define NV_09F_INCREMENT_READ_RANGE_PARAMETER_WORD         0
#define NV_09F_INCREMENT_READ_RANGE_PARAMETER_HIGH_FIELD   0x0000001F /* =31 */
#define NV_09F_INCREMENT_READ_RANGE_PARAMETER_LOW_FIELD    0x00000000 /* =0 */
#define NV_09F_INCREMENT_READ_RANGE_MSK                    0xFFFFFFFF 
#define NV_09F_SET_CONTEXT_DMA_NOTIFY_PARAMETER_MSK        0xFFFFFFFF /* 31:0 */ 
#define NV_09F_SET_CONTEXT_DMA_NOTIFY_PARAMETER_RMSK       0xFFFFFFFF /* 31:0 */ 
#define NV_09F_SET_CONTEXT_DMA_NOTIFY_PARAMETER_WORD       0
#define NV_09F_SET_CONTEXT_DMA_NOTIFY_PARAMETER_HIGH_FIELD 0x0000001F /* =31 */
#define NV_09F_SET_CONTEXT_DMA_NOTIFY_PARAMETER_LOW_FIELD  0x00000000 /* =0 */
#define NV_09F_SET_CONTEXT_DMA_NOTIFY_MSK                  0xFFFFFFFF 
#define NV_09F_SET_CONTEXT_COLOR_KEY_PARAMETER_MSK         0xFFFFFFFF /* 31:0 */ 
#define NV_09F_SET_CONTEXT_COLOR_KEY_PARAMETER_RMSK        0xFFFFFFFF /* 31:0 */ 
#define NV_09F_SET_CONTEXT_COLOR_KEY_PARAMETER_WORD        0
#define NV_09F_SET_CONTEXT_COLOR_KEY_PARAMETER_HIGH_FIELD  0x0000001F /* =31 */
#define NV_09F_SET_CONTEXT_COLOR_KEY_PARAMETER_LOW_FIELD   0x00000000 /* =0 */
#define NV_09F_SET_CONTEXT_COLOR_KEY_MSK                   0xFFFFFFFF 
#define NV_09F_SET_CONTEXT_CLIP_RECTANGLE_PARAMETER_MSK    0xFFFFFFFF /* 31:0 */ 
#define NV_09F_SET_CONTEXT_CLIP_RECTANGLE_PARAMETER_RMSK   0xFFFFFFFF /* 31:0 */ 
#define NV_09F_SET_CONTEXT_CLIP_RECTANGLE_PARAMETER_WORD   0
#define NV_09F_SET_CONTEXT_CLIP_RECTANGLE_PARAMETER_HIGH_FIELD 0x0000001F /* =31 */
#define NV_09F_SET_CONTEXT_CLIP_RECTANGLE_PARAMETER_LOW_FIELD 0x00000000 /* =0 */
#define NV_09F_SET_CONTEXT_CLIP_RECTANGLE_MSK              0xFFFFFFFF 
#define NV_09F_SET_CONTEXT_PATTERN_PARAMETER_MSK           0xFFFFFFFF /* 31:0 */ 
#define NV_09F_SET_CONTEXT_PATTERN_PARAMETER_RMSK          0xFFFFFFFF /* 31:0 */ 
#define NV_09F_SET_CONTEXT_PATTERN_PARAMETER_WORD          0
#define NV_09F_SET_CONTEXT_PATTERN_PARAMETER_HIGH_FIELD    0x0000001F /* =31 */
#define NV_09F_SET_CONTEXT_PATTERN_PARAMETER_LOW_FIELD     0x00000000 /* =0 */
#define NV_09F_SET_CONTEXT_PATTERN_MSK                     0xFFFFFFFF 
#define NV_09F_SET_CONTEXT_ROP_PARAMETER_MSK               0xFFFFFFFF /* 31:0 */ 
#define NV_09F_SET_CONTEXT_ROP_PARAMETER_RMSK              0xFFFFFFFF /* 31:0 */ 
#define NV_09F_SET_CONTEXT_ROP_PARAMETER_WORD              0
#define NV_09F_SET_CONTEXT_ROP_PARAMETER_HIGH_FIELD        0x0000001F /* =31 */
#define NV_09F_SET_CONTEXT_ROP_PARAMETER_LOW_FIELD         0x00000000 /* =0 */
#define NV_09F_SET_CONTEXT_ROP_MSK                         0xFFFFFFFF 
#define NV_09F_SET_CONTEXT_BETA1_PARAMETER_MSK             0xFFFFFFFF /* 31:0 */ 
#define NV_09F_SET_CONTEXT_BETA1_PARAMETER_RMSK            0xFFFFFFFF /* 31:0 */ 
#define NV_09F_SET_CONTEXT_BETA1_PARAMETER_WORD            0
#define NV_09F_SET_CONTEXT_BETA1_PARAMETER_HIGH_FIELD      0x0000001F /* =31 */
#define NV_09F_SET_CONTEXT_BETA1_PARAMETER_LOW_FIELD       0x00000000 /* =0 */
#define NV_09F_SET_CONTEXT_BETA1_MSK                       0xFFFFFFFF 
#define NV_09F_SET_CONTEXT_BETA4_PARAMETER_MSK             0xFFFFFFFF /* 31:0 */ 
#define NV_09F_SET_CONTEXT_BETA4_PARAMETER_RMSK            0xFFFFFFFF /* 31:0 */ 
#define NV_09F_SET_CONTEXT_BETA4_PARAMETER_WORD            0
#define NV_09F_SET_CONTEXT_BETA4_PARAMETER_HIGH_FIELD      0x0000001F /* =31 */
#define NV_09F_SET_CONTEXT_BETA4_PARAMETER_LOW_FIELD       0x00000000 /* =0 */
#define NV_09F_SET_CONTEXT_BETA4_MSK                       0xFFFFFFFF 
#define NV_09F_SET_CONTEXT_SURFACE_PARAMETER_MSK           0xFFFFFFFF /* 31:0 */ 
#define NV_09F_SET_CONTEXT_SURFACE_PARAMETER_RMSK          0xFFFFFFFF /* 31:0 */ 
#define NV_09F_SET_CONTEXT_SURFACE_PARAMETER_WORD          0
#define NV_09F_SET_CONTEXT_SURFACE_PARAMETER_HIGH_FIELD    0x0000001F /* =31 */
#define NV_09F_SET_CONTEXT_SURFACE_PARAMETER_LOW_FIELD     0x00000000 /* =0 */
#define NV_09F_SET_CONTEXT_SURFACE_MSK                     0xFFFFFFFF 
#define NV_09F_SET_OPERATION_MODE_MSK                      0xFFFFFFFF /* 31:0 */ 
#define NV_09F_SET_OPERATION_MODE_RMSK                     0xFFFFFFFF /* 31:0 */ 
#define NV_09F_SET_OPERATION_MODE_WORD                     0
#define NV_09F_SET_OPERATION_MODE_HIGH_FIELD               0x0000001F /* =31 */
#define NV_09F_SET_OPERATION_MODE_LOW_FIELD                0x00000000 /* =0 */
#define NV_09F_SET_OPERATION_MODE_SRCCOPY_AND_ADJ          0x00000000
#define NV_09F_SET_OPERATION_MODE_ROP_AND_ADJ              0x00000001
#define NV_09F_SET_OPERATION_MODE_BLEND_AND_ADJ            0x00000002
#define NV_09F_SET_OPERATION_MODE_SRCCOPY_ADJ              0x00000003
#define NV_09F_SET_OPERATION_MODE_SRCCOPY_PREMULT_ADJ      0x00000004
#define NV_09F_SET_OPERATION_MODE_BLEND_PREMULT_ADJ        0x00000005
#define NV_09F_SET_OPERATION_MSK                           0xFFFFFFFF 
#define NV_09F_POINT_IN_X_MSK                              0x0000FFFF /* 15:0 */ 
#define NV_09F_POINT_IN_X_RMSK                             0x0000FFFF /* 15:0 */ 
#define NV_09F_POINT_IN_X_WORD                             0
#define NV_09F_POINT_IN_X_HIGH_FIELD                       0x0000000F /* =15 */
#define NV_09F_POINT_IN_X_LOW_FIELD                        0x00000000 /* =0 */
#define NV_09F_POINT_IN_Y_MSK                              0xFFFF0000 /* 31:16 */ 
#define NV_09F_POINT_IN_Y_RMSK                             0x0000FFFF /* 31:16 */ 
#define NV_09F_POINT_IN_Y_WORD                             0
#define NV_09F_POINT_IN_Y_HIGH_FIELD                       0x0000001F /* =31 */
#define NV_09F_POINT_IN_Y_LOW_FIELD                        0x00000010 /* =16 */
#define NV_09F_POINT_IN_MSK                                0xFFFFFFFF 
#define NV_09F_POINT_OUT_X_MSK                             0x0000FFFF /* 15:0 */ 
#define NV_09F_POINT_OUT_X_RMSK                            0x0000FFFF /* 15:0 */ 
#define NV_09F_POINT_OUT_X_WORD                            0
#define NV_09F_POINT_OUT_X_HIGH_FIELD                      0x0000000F /* =15 */
#define NV_09F_POINT_OUT_X_LOW_FIELD                       0x00000000 /* =0 */
#define NV_09F_POINT_OUT_Y_MSK                             0xFFFF0000 /* 31:16 */ 
#define NV_09F_POINT_OUT_Y_RMSK                            0x0000FFFF /* 31:16 */ 
#define NV_09F_POINT_OUT_Y_WORD                            0
#define NV_09F_POINT_OUT_Y_HIGH_FIELD                      0x0000001F /* =31 */
#define NV_09F_POINT_OUT_Y_LOW_FIELD                       0x00000010 /* =16 */
#define NV_09F_POINT_OUT_MSK                               0xFFFFFFFF 
#define NV_09F_SIZE_WIDTH_MSK                              0x0000FFFF /* 15:0 */ 
#define NV_09F_SIZE_WIDTH_RMSK                             0x0000FFFF /* 15:0 */ 
#define NV_09F_SIZE_WIDTH_WORD                             0
#define NV_09F_SIZE_WIDTH_HIGH_FIELD                       0x0000000F /* =15 */
#define NV_09F_SIZE_WIDTH_LOW_FIELD                        0x00000000 /* =0 */
#define NV_09F_SIZE_HEIGHT_MSK                             0xFFFF0000 /* 31:16 */ 
#define NV_09F_SIZE_HEIGHT_RMSK                            0x0000FFFF /* 31:16 */ 
#define NV_09F_SIZE_HEIGHT_WORD                            0
#define NV_09F_SIZE_HEIGHT_HIGH_FIELD                      0x0000001F /* =31 */
#define NV_09F_SIZE_HEIGHT_LOW_FIELD                       0x00000010 /* =16 */
#define NV_09F_SIZE_MSK                                    0xFFFFFFFF 
#define NV_060_HIGH_FIELD                                  0x00691FFF /* =6889471 */
#define NV_060_LOW_FIELD                                   0x00690000 /* =6881280 */
#define NV_060_CTX_SWITCH_ADJ                              0x00690000
#define NV_060_CTX_SWITCH_INSTANCE_MSK                     0x0000FFFF /* 15:0 */ 
#define NV_060_CTX_SWITCH_INSTANCE_RMSK                    0x0000FFFF /* 15:0 */ 
#define NV_060_CTX_SWITCH_INSTANCE_WORD                    0
#define NV_060_CTX_SWITCH_INSTANCE_HIGH_FIELD              0x0000000F /* =15 */
#define NV_060_CTX_SWITCH_INSTANCE_LOW_FIELD               0x00000000 /* =0 */
#define NV_060_CTX_SWITCH_CHID_MSK                         0x007F0000 /* 22:16 */ 
#define NV_060_CTX_SWITCH_CHID_RMSK                        0x0000007F /* 22:16 */ 
#define NV_060_CTX_SWITCH_CHID_WORD                        0
#define NV_060_CTX_SWITCH_CHID_HIGH_FIELD                  0x00000016 /* =22 */
#define NV_060_CTX_SWITCH_CHID_LOW_FIELD                   0x00000010 /* =16 */
#define NV_060_CTX_SWITCH_VOLATILE_MSK                     0x80000000 /* 31:31 */ 
#define NV_060_CTX_SWITCH_VOLATILE_RMSK                    0x00000001 /* 31:31 */ 
#define NV_060_CTX_SWITCH_VOLATILE_WORD                    0
#define NV_060_CTX_SWITCH_VOLATILE_HIGH_FIELD              0x0000001F /* =31 */
#define NV_060_CTX_SWITCH_VOLATILE_LOW_FIELD               0x0000001F /* =31 */
#define NV_060_CTX_SWITCH_VOLATILE_IGNORE_ADJ              0x00000000
#define NV_060_CTX_SWITCH_VOLATILE_RESET_ADJ               0x80000000
#define NV_060_CTX_SWITCH_MSK                              0x807FFFFF 
#define NV_060_NOP_PARAMETER_MSK                           0xFFFFFFFF /* 31:0 */ 
#define NV_060_NOP_PARAMETER_RMSK                          0xFFFFFFFF /* 31:0 */ 
#define NV_060_NOP_PARAMETER_WORD                          0
#define NV_060_NOP_PARAMETER_HIGH_FIELD                    0x0000001F /* =31 */
#define NV_060_NOP_PARAMETER_LOW_FIELD                     0x00000000 /* =0 */
#define NV_060_NOP_MSK                                     0xFFFFFFFF 
#define NV_060_NOTIFY_STYLE_MSK                            0xFFFFFFFF /* 31:0 */ 
#define NV_060_NOTIFY_STYLE_RMSK                           0xFFFFFFFF /* 31:0 */ 
#define NV_060_NOTIFY_STYLE_WORD                           0
#define NV_060_NOTIFY_STYLE_HIGH_FIELD                     0x0000001F /* =31 */
#define NV_060_NOTIFY_STYLE_LOW_FIELD                      0x00000000 /* =0 */
#define NV_060_NOTIFY_STYLE_WRITE_ONLY_ADJ                 0x00000000
#define NV_060_NOTIFY_STYLE_WRITE_THEN_AWAKEN_ADJ          0x00000001
#define NV_060_NOTIFY_MSK                                  0xFFFFFFFF 
#define NV_060_SET_NOTIFY_PARAMETER_MSK                    0xFFFFFFFF /* 31:0 */ 
#define NV_060_SET_NOTIFY_PARAMETER_RMSK                   0xFFFFFFFF /* 31:0 */ 
#define NV_060_SET_NOTIFY_PARAMETER_WORD                   0
#define NV_060_SET_NOTIFY_PARAMETER_HIGH_FIELD             0x0000001F /* =31 */
#define NV_060_SET_NOTIFY_PARAMETER_LOW_FIELD              0x00000000 /* =0 */
#define NV_060_SET_NOTIFY_PARAMETER_WRITE_ADJ              0x00000000
#define NV_060_SET_NOTIFY_MSK                              0xFFFFFFFF 
#define NV_060_SET_PATCH_PARAMETER_MSK                     0xFFFFFFFF /* 31:0 */ 
#define NV_060_SET_PATCH_PARAMETER_RMSK                    0xFFFFFFFF /* 31:0 */ 
#define NV_060_SET_PATCH_PARAMETER_WORD                    0
#define NV_060_SET_PATCH_PARAMETER_HIGH_FIELD              0x0000001F /* =31 */
#define NV_060_SET_PATCH_PARAMETER_LOW_FIELD               0x00000000 /* =0 */
#define NV_060_SET_PATCH_PARAMETER_INVALIDATE_ADJ          0x00000000
#define NV_060_SET_PATCH_PARAMETER_VALIDATE_ADJ            0x00000001
#define NV_060_SET_PATCH_MSK                               0xFFFFFFFF 
#define NV_060_SET_CONTEXT_DMA_NOTIFY_PARAMETER_MSK        0xFFFFFFFF /* 31:0 */ 
#define NV_060_SET_CONTEXT_DMA_NOTIFY_PARAMETER_RMSK       0xFFFFFFFF /* 31:0 */ 
#define NV_060_SET_CONTEXT_DMA_NOTIFY_PARAMETER_WORD       0
#define NV_060_SET_CONTEXT_DMA_NOTIFY_PARAMETER_HIGH_FIELD 0x0000001F /* =31 */
#define NV_060_SET_CONTEXT_DMA_NOTIFY_PARAMETER_LOW_FIELD  0x00000000 /* =0 */
#define NV_060_SET_CONTEXT_DMA_NOTIFY_MSK                  0xFFFFFFFF 
#define NV_060_SET_CONTEXT_DMA_LUT_PARAMETER_MSK           0xFFFFFFFF /* 31:0 */ 
#define NV_060_SET_CONTEXT_DMA_LUT_PARAMETER_RMSK          0xFFFFFFFF /* 31:0 */ 
#define NV_060_SET_CONTEXT_DMA_LUT_PARAMETER_WORD          0
#define NV_060_SET_CONTEXT_DMA_LUT_PARAMETER_HIGH_FIELD    0x0000001F /* =31 */
#define NV_060_SET_CONTEXT_DMA_LUT_PARAMETER_LOW_FIELD     0x00000000 /* =0 */
#define NV_060_SET_CONTEXT_DMA_LUT_MSK                     0xFFFFFFFF 
#define NV_060_SET_IMAGE_OUTPUT_PARAMETER_MSK              0xFFFFFFFF /* 31:0 */ 
#define NV_060_SET_IMAGE_OUTPUT_PARAMETER_RMSK             0xFFFFFFFF /* 31:0 */ 
#define NV_060_SET_IMAGE_OUTPUT_PARAMETER_WORD             0
#define NV_060_SET_IMAGE_OUTPUT_PARAMETER_HIGH_FIELD       0x0000001F /* =31 */
#define NV_060_SET_IMAGE_OUTPUT_PARAMETER_LOW_FIELD        0x00000000 /* =0 */
#define NV_060_SET_IMAGE_OUTPUT_MSK                        0xFFFFFFFF 
#define NV_060_SET_COLOR_FORMAT_LE_MSK                     0xFFFFFFFF /* 31:0 */ 
#define NV_060_SET_COLOR_FORMAT_LE_RMSK                    0xFFFFFFFF /* 31:0 */ 
#define NV_060_SET_COLOR_FORMAT_LE_WORD                    0
#define NV_060_SET_COLOR_FORMAT_LE_HIGH_FIELD              0x0000001F /* =31 */
#define NV_060_SET_COLOR_FORMAT_LE_LOW_FIELD               0x00000000 /* =0 */
#define NV_060_SET_COLOR_FORMAT_LE_R5G6B5_ADJ              0x00000001
#define NV_060_SET_COLOR_FORMAT_LE_A1R5G5B5_ADJ            0x00000002
#define NV_060_SET_COLOR_FORMAT_LE_X1R5G5B5_ADJ            0x00000003
#define NV_060_SET_COLOR_FORMAT_LE_A8R8G8B8_ADJ            0x00000004
#define NV_060_SET_COLOR_FORMAT_LE_X8R8G8B8_ADJ            0x00000005
#define NV_060_SET_COLOR_FORMAT_MSK                        0xFFFFFFFF 
#define NV_060_INDEX_FORMAT_LE_MSK                         0xFFFFFFFF /* 31:0 */ 
#define NV_060_INDEX_FORMAT_LE_RMSK                        0xFFFFFFFF /* 31:0 */ 
#define NV_060_INDEX_FORMAT_LE_WORD                        0
#define NV_060_INDEX_FORMAT_LE_HIGH_FIELD                  0x0000001F /* =31 */
#define NV_060_INDEX_FORMAT_LE_LOW_FIELD                   0x00000000 /* =0 */
#define NV_060_INDEX_FORMAT_LE_I8_ADJ                      0x00000000
#define NV_060_INDEX_FORMAT_LE_I4_ADJ                      0x00000001
#define NV_060_INDEX_FORMAT_MSK                            0xFFFFFFFF 
#define NV_060_LUT_OFFSET_ARGUMENT_MSK                     0xFFFFFFFF /* 31:0 */ 
#define NV_060_LUT_OFFSET_ARGUMENT_RMSK                    0xFFFFFFFF /* 31:0 */ 
#define NV_060_LUT_OFFSET_ARGUMENT_WORD                    0
#define NV_060_LUT_OFFSET_ARGUMENT_HIGH_FIELD              0x0000001F /* =31 */
#define NV_060_LUT_OFFSET_ARGUMENT_LOW_FIELD               0x00000000 /* =0 */
#define NV_060_LUT_OFFSET_MSK                              0xFFFFFFFF 
#define NV_060_POINT_X_MSK                                 0x0000FFFF /* 15:0 */ 
#define NV_060_POINT_X_RMSK                                0x0000FFFF /* 15:0 */ 
#define NV_060_POINT_X_WORD                                0
#define NV_060_POINT_X_HIGH_FIELD                          0x0000000F /* =15 */
#define NV_060_POINT_X_LOW_FIELD                           0x00000000 /* =0 */
#define NV_060_POINT_Y_MSK                                 0xFFFF0000 /* 31:16 */ 
#define NV_060_POINT_Y_RMSK                                0x0000FFFF /* 31:16 */ 
#define NV_060_POINT_Y_WORD                                0
#define NV_060_POINT_Y_HIGH_FIELD                          0x0000001F /* =31 */
#define NV_060_POINT_Y_LOW_FIELD                           0x00000010 /* =16 */
#define NV_060_POINT_MSK                                   0xFFFFFFFF 
#define NV_060_SIZE_OUT_WIDTH_MSK                          0x0000FFFF /* 15:0 */ 
#define NV_060_SIZE_OUT_WIDTH_RMSK                         0x0000FFFF /* 15:0 */ 
#define NV_060_SIZE_OUT_WIDTH_WORD                         0
#define NV_060_SIZE_OUT_WIDTH_HIGH_FIELD                   0x0000000F /* =15 */
#define NV_060_SIZE_OUT_WIDTH_LOW_FIELD                    0x00000000 /* =0 */
#define NV_060_SIZE_OUT_HEIGHT_MSK                         0xFFFF0000 /* 31:16 */ 
#define NV_060_SIZE_OUT_HEIGHT_RMSK                        0x0000FFFF /* 31:16 */ 
#define NV_060_SIZE_OUT_HEIGHT_WORD                        0
#define NV_060_SIZE_OUT_HEIGHT_HIGH_FIELD                  0x0000001F /* =31 */
#define NV_060_SIZE_OUT_HEIGHT_LOW_FIELD                   0x00000010 /* =16 */
#define NV_060_SIZE_OUT_MSK                                0xFFFFFFFF 
#define NV_060_SIZE_IN_WIDTH_MSK                           0x0000FFFF /* 15:0 */ 
#define NV_060_SIZE_IN_WIDTH_RMSK                          0x0000FFFF /* 15:0 */ 
#define NV_060_SIZE_IN_WIDTH_WORD                          0
#define NV_060_SIZE_IN_WIDTH_HIGH_FIELD                    0x0000000F /* =15 */
#define NV_060_SIZE_IN_WIDTH_LOW_FIELD                     0x00000000 /* =0 */
#define NV_060_SIZE_IN_HEIGHT_MSK                          0xFFFF0000 /* 31:16 */ 
#define NV_060_SIZE_IN_HEIGHT_RMSK                         0x0000FFFF /* 31:16 */ 
#define NV_060_SIZE_IN_HEIGHT_WORD                         0
#define NV_060_SIZE_IN_HEIGHT_HIGH_FIELD                   0x0000001F /* =31 */
#define NV_060_SIZE_IN_HEIGHT_LOW_FIELD                    0x00000010 /* =16 */
#define NV_060_SIZE_IN_MSK                                 0xFFFFFFFF 
#define NV_060_COLOR_VALUE_MSK                             0xFFFFFFFF /* 31:0 */ 
#define NV_060_COLOR_VALUE_RMSK                            0xFFFFFFFF /* 31:0 */ 
#define NV_060_COLOR_VALUE_WORD                            0
#define NV_060_COLOR_VALUE_HIGH_FIELD                      0x0000001F /* =31 */
#define NV_060_COLOR_VALUE_LOW_FIELD                       0x00000000 /* =0 */
#define NV_060_COLOR_MSK                                   0xFFFFFFFF 
#define NV_064_HIGH_FIELD                                  0x00651FFF /* =6627327 */
#define NV_064_LOW_FIELD                                   0x00650000 /* =6619136 */
#define NV_064_NV5_INDEXED_IMAGE_FROM_CPU_ADJ              0x00650000
#define NV_064_NV5_INDEXED_IMAGE_FROM_CPU_HANDLE_MSK       0xFFFFFFFF /* 31:0 */ 
#define NV_064_NV5_INDEXED_IMAGE_FROM_CPU_HANDLE_RMSK      0xFFFFFFFF /* 31:0 */ 
#define NV_064_NV5_INDEXED_IMAGE_FROM_CPU_HANDLE_WORD      0
#define NV_064_NV5_INDEXED_IMAGE_FROM_CPU_HANDLE_HIGH_FIELD 0x0000001F /* =31 */
#define NV_064_NV5_INDEXED_IMAGE_FROM_CPU_HANDLE_LOW_FIELD 0x00000000 /* =0 */
#define NV_064_NV5_INDEXED_IMAGE_FROM_CPU_MSK              0xFFFFFFFF 
#define NV_064_NOP_PARAMETER_MSK                           0xFFFFFFFF /* 31:0 */ 
#define NV_064_NOP_PARAMETER_RMSK                          0xFFFFFFFF /* 31:0 */ 
#define NV_064_NOP_PARAMETER_WORD                          0
#define NV_064_NOP_PARAMETER_HIGH_FIELD                    0x0000001F /* =31 */
#define NV_064_NOP_PARAMETER_LOW_FIELD                     0x00000000 /* =0 */
#define NV_064_NOP_MSK                                     0xFFFFFFFF 
#define NV_064_NOTIFY_STYLE_MSK                            0xFFFFFFFF /* 31:0 */ 
#define NV_064_NOTIFY_STYLE_RMSK                           0xFFFFFFFF /* 31:0 */ 
#define NV_064_NOTIFY_STYLE_WORD                           0
#define NV_064_NOTIFY_STYLE_HIGH_FIELD                     0x0000001F /* =31 */
#define NV_064_NOTIFY_STYLE_LOW_FIELD                      0x00000000 /* =0 */
#define NV_064_NOTIFY_STYLE_WRITE_ONLY_ADJ                 0x00000000
#define NV_064_NOTIFY_STYLE_WRITE_THEN_AWAKEN_ADJ          0x00000001
#define NV_064_NOTIFY_MSK                                  0xFFFFFFFF 
#define NV_064_SET_NOTIFY_PARAMETER_MSK                    0xFFFFFFFF /* 31:0 */ 
#define NV_064_SET_NOTIFY_PARAMETER_RMSK                   0xFFFFFFFF /* 31:0 */ 
#define NV_064_SET_NOTIFY_PARAMETER_WORD                   0
#define NV_064_SET_NOTIFY_PARAMETER_HIGH_FIELD             0x0000001F /* =31 */
#define NV_064_SET_NOTIFY_PARAMETER_LOW_FIELD              0x00000000 /* =0 */
#define NV_064_SET_NOTIFY_PARAMETER_WRITE_ADJ              0x00000000
#define NV_064_SET_NOTIFY_MSK                              0xFFFFFFFF 
#define NV_064_SET_CONTEXT_DMA_NOTIFY_PARAMETER_MSK        0xFFFFFFFF /* 31:0 */ 
#define NV_064_SET_CONTEXT_DMA_NOTIFY_PARAMETER_RMSK       0xFFFFFFFF /* 31:0 */ 
#define NV_064_SET_CONTEXT_DMA_NOTIFY_PARAMETER_WORD       0
#define NV_064_SET_CONTEXT_DMA_NOTIFY_PARAMETER_HIGH_FIELD 0x0000001F /* =31 */
#define NV_064_SET_CONTEXT_DMA_NOTIFY_PARAMETER_LOW_FIELD  0x00000000 /* =0 */
#define NV_064_SET_CONTEXT_DMA_NOTIFY_MSK                  0xFFFFFFFF 
#define NV_064_SET_CONTEXT_DMA_LUT_PARAMETER_MSK           0xFFFFFFFF /* 31:0 */ 
#define NV_064_SET_CONTEXT_DMA_LUT_PARAMETER_RMSK          0xFFFFFFFF /* 31:0 */ 
#define NV_064_SET_CONTEXT_DMA_LUT_PARAMETER_WORD          0
#define NV_064_SET_CONTEXT_DMA_LUT_PARAMETER_HIGH_FIELD    0x0000001F /* =31 */
#define NV_064_SET_CONTEXT_DMA_LUT_PARAMETER_LOW_FIELD     0x00000000 /* =0 */
#define NV_064_SET_CONTEXT_DMA_LUT_MSK                     0xFFFFFFFF 
#define NV_064_SET_CONTEXT_COLOR_KEY_PARAMETER_MSK         0xFFFFFFFF /* 31:0 */ 
#define NV_064_SET_CONTEXT_COLOR_KEY_PARAMETER_RMSK        0xFFFFFFFF /* 31:0 */ 
#define NV_064_SET_CONTEXT_COLOR_KEY_PARAMETER_WORD        0
#define NV_064_SET_CONTEXT_COLOR_KEY_PARAMETER_HIGH_FIELD  0x0000001F /* =31 */
#define NV_064_SET_CONTEXT_COLOR_KEY_PARAMETER_LOW_FIELD   0x00000000 /* =0 */
#define NV_064_SET_CONTEXT_COLOR_KEY_MSK                   0xFFFFFFFF 
#define NV_064_SET_CONTEXT_CLIP_RECTANGLE_PARAMETER_MSK    0xFFFFFFFF /* 31:0 */ 
#define NV_064_SET_CONTEXT_CLIP_RECTANGLE_PARAMETER_RMSK   0xFFFFFFFF /* 31:0 */ 
#define NV_064_SET_CONTEXT_CLIP_RECTANGLE_PARAMETER_WORD   0
#define NV_064_SET_CONTEXT_CLIP_RECTANGLE_PARAMETER_HIGH_FIELD 0x0000001F /* =31 */
#define NV_064_SET_CONTEXT_CLIP_RECTANGLE_PARAMETER_LOW_FIELD 0x00000000 /* =0 */
#define NV_064_SET_CONTEXT_CLIP_RECTANGLE_MSK              0xFFFFFFFF 
#define NV_064_SET_CONTEXT_PATTERN_PARAMETER_MSK           0xFFFFFFFF /* 31:0 */ 
#define NV_064_SET_CONTEXT_PATTERN_PARAMETER_RMSK          0xFFFFFFFF /* 31:0 */ 
#define NV_064_SET_CONTEXT_PATTERN_PARAMETER_WORD          0
#define NV_064_SET_CONTEXT_PATTERN_PARAMETER_HIGH_FIELD    0x0000001F /* =31 */
#define NV_064_SET_CONTEXT_PATTERN_PARAMETER_LOW_FIELD     0x00000000 /* =0 */
#define NV_064_SET_CONTEXT_PATTERN_MSK                     0xFFFFFFFF 
#define NV_064_SET_CONTEXT_ROP_PARAMETER_MSK               0xFFFFFFFF /* 31:0 */ 
#define NV_064_SET_CONTEXT_ROP_PARAMETER_RMSK              0xFFFFFFFF /* 31:0 */ 
#define NV_064_SET_CONTEXT_ROP_PARAMETER_WORD              0
#define NV_064_SET_CONTEXT_ROP_PARAMETER_HIGH_FIELD        0x0000001F /* =31 */
#define NV_064_SET_CONTEXT_ROP_PARAMETER_LOW_FIELD         0x00000000 /* =0 */
#define NV_064_SET_CONTEXT_ROP_MSK                         0xFFFFFFFF 
#define NV_064_SET_CONTEXT_BETA1_PARAMETER_MSK             0xFFFFFFFF /* 31:0 */ 
#define NV_064_SET_CONTEXT_BETA1_PARAMETER_RMSK            0xFFFFFFFF /* 31:0 */ 
#define NV_064_SET_CONTEXT_BETA1_PARAMETER_WORD            0
#define NV_064_SET_CONTEXT_BETA1_PARAMETER_HIGH_FIELD      0x0000001F /* =31 */
#define NV_064_SET_CONTEXT_BETA1_PARAMETER_LOW_FIELD       0x00000000 /* =0 */
#define NV_064_SET_CONTEXT_BETA1_MSK                       0xFFFFFFFF 
#define NV_064_SET_CONTEXT_BETA4_PARAMETER_MSK             0xFFFFFFFF /* 31:0 */ 
#define NV_064_SET_CONTEXT_BETA4_PARAMETER_RMSK            0xFFFFFFFF /* 31:0 */ 
#define NV_064_SET_CONTEXT_BETA4_PARAMETER_WORD            0
#define NV_064_SET_CONTEXT_BETA4_PARAMETER_HIGH_FIELD      0x0000001F /* =31 */
#define NV_064_SET_CONTEXT_BETA4_PARAMETER_LOW_FIELD       0x00000000 /* =0 */
#define NV_064_SET_CONTEXT_BETA4_MSK                       0xFFFFFFFF 
#define NV_064_SET_CONTEXT_SURFACE_PARAMETER_MSK           0xFFFFFFFF /* 31:0 */ 
#define NV_064_SET_CONTEXT_SURFACE_PARAMETER_RMSK          0xFFFFFFFF /* 31:0 */ 
#define NV_064_SET_CONTEXT_SURFACE_PARAMETER_WORD          0
#define NV_064_SET_CONTEXT_SURFACE_PARAMETER_HIGH_FIELD    0x0000001F /* =31 */
#define NV_064_SET_CONTEXT_SURFACE_PARAMETER_LOW_FIELD     0x00000000 /* =0 */
#define NV_064_SET_CONTEXT_SURFACE_MSK                     0xFFFFFFFF 
#define NV_064_SET_COLOR_CONVERSION_TYPE_MSK               0xFFFFFFFF /* 31:0 */ 
#define NV_064_SET_COLOR_CONVERSION_TYPE_RMSK              0xFFFFFFFF /* 31:0 */ 
#define NV_064_SET_COLOR_CONVERSION_TYPE_WORD              0
#define NV_064_SET_COLOR_CONVERSION_TYPE_HIGH_FIELD        0x0000001F /* =31 */
#define NV_064_SET_COLOR_CONVERSION_TYPE_LOW_FIELD         0x00000000 /* =0 */
#define NV_064_SET_COLOR_CONVERSION_TYPE_DITHER_ADJ        0x00000000
#define NV_064_SET_COLOR_CONVERSION_TYPE_TRUNCATE_ADJ      0x00000001
#define NV_064_SET_COLOR_CONVERSION_TYPE_SUBTR_TRUNCATE_ADJ 0x00000002
#define NV_064_SET_COLOR_CONVERSION_MSK                    0xFFFFFFFF 
#define NV_064_SET_OPERATION_MODE_MSK                      0xFFFFFFFF /* 31:0 */ 
#define NV_064_SET_OPERATION_MODE_RMSK                     0xFFFFFFFF /* 31:0 */ 
#define NV_064_SET_OPERATION_MODE_WORD                     0
#define NV_064_SET_OPERATION_MODE_HIGH_FIELD               0x0000001F /* =31 */
#define NV_064_SET_OPERATION_MODE_LOW_FIELD                0x00000000 /* =0 */
#define NV_064_SET_OPERATION_MODE_SRCCOPY_AND_ADJ          0x00000000
#define NV_064_SET_OPERATION_MODE_ROP_AND_ADJ              0x00000001
#define NV_064_SET_OPERATION_MODE_BLEND_AND_ADJ            0x00000002
#define NV_064_SET_OPERATION_MODE_SRCCOPY_ADJ              0x00000003
#define NV_064_SET_OPERATION_MODE_SRCCOPY_PREMULT_ADJ      0x00000004
#define NV_064_SET_OPERATION_MODE_BLEND_PREMULT_ADJ        0x00000005
#define NV_064_SET_OPERATION_MSK                           0xFFFFFFFF 
#define NV_064_SET_COLOR_FORMAT_LE_MSK                     0xFFFFFFFF /* 31:0 */ 
#define NV_064_SET_COLOR_FORMAT_LE_RMSK                    0xFFFFFFFF /* 31:0 */ 
#define NV_064_SET_COLOR_FORMAT_LE_WORD                    0
#define NV_064_SET_COLOR_FORMAT_LE_HIGH_FIELD              0x0000001F /* =31 */
#define NV_064_SET_COLOR_FORMAT_LE_LOW_FIELD               0x00000000 /* =0 */
#define NV_064_SET_COLOR_FORMAT_LE_R5G6B5_ADJ              0x00000001
#define NV_064_SET_COLOR_FORMAT_LE_A1R5G5B5_ADJ            0x00000002
#define NV_064_SET_COLOR_FORMAT_LE_X1R5G5B5_ADJ            0x00000003
#define NV_064_SET_COLOR_FORMAT_LE_A8R8G8B8_ADJ            0x00000004
#define NV_064_SET_COLOR_FORMAT_LE_X8R8G8B8_ADJ            0x00000005
#define NV_064_SET_COLOR_FORMAT_MSK                        0xFFFFFFFF 
#define NV_064_INDEX_FORMAT_LE_MSK                         0xFFFFFFFF /* 31:0 */ 
#define NV_064_INDEX_FORMAT_LE_RMSK                        0xFFFFFFFF /* 31:0 */ 
#define NV_064_INDEX_FORMAT_LE_WORD                        0
#define NV_064_INDEX_FORMAT_LE_HIGH_FIELD                  0x0000001F /* =31 */
#define NV_064_INDEX_FORMAT_LE_LOW_FIELD                   0x00000000 /* =0 */
#define NV_064_INDEX_FORMAT_LE_I8_ADJ                      0x00000000
#define NV_064_INDEX_FORMAT_LE_I4_ADJ                      0x00000001
#define NV_064_INDEX_FORMAT_MSK                            0xFFFFFFFF 
#define NV_064_LUT_OFFSET_ARGUMENT_MSK                     0xFFFFFFFF /* 31:0 */ 
#define NV_064_LUT_OFFSET_ARGUMENT_RMSK                    0xFFFFFFFF /* 31:0 */ 
#define NV_064_LUT_OFFSET_ARGUMENT_WORD                    0
#define NV_064_LUT_OFFSET_ARGUMENT_HIGH_FIELD              0x0000001F /* =31 */
#define NV_064_LUT_OFFSET_ARGUMENT_LOW_FIELD               0x00000000 /* =0 */
#define NV_064_LUT_OFFSET_MSK                              0xFFFFFFFF 
#define NV_064_POINT_X_MSK                                 0x0000FFFF /* 15:0 */ 
#define NV_064_POINT_X_RMSK                                0x0000FFFF /* 15:0 */ 
#define NV_064_POINT_X_WORD                                0
#define NV_064_POINT_X_HIGH_FIELD                          0x0000000F /* =15 */
#define NV_064_POINT_X_LOW_FIELD                           0x00000000 /* =0 */
#define NV_064_POINT_Y_MSK                                 0xFFFF0000 /* 31:16 */ 
#define NV_064_POINT_Y_RMSK                                0x0000FFFF /* 31:16 */ 
#define NV_064_POINT_Y_WORD                                0
#define NV_064_POINT_Y_HIGH_FIELD                          0x0000001F /* =31 */
#define NV_064_POINT_Y_LOW_FIELD                           0x00000010 /* =16 */
#define NV_064_POINT_MSK                                   0xFFFFFFFF 
#define NV_064_SIZE_OUT_WIDTH_MSK                          0x0000FFFF /* 15:0 */ 
#define NV_064_SIZE_OUT_WIDTH_RMSK                         0x0000FFFF /* 15:0 */ 
#define NV_064_SIZE_OUT_WIDTH_WORD                         0
#define NV_064_SIZE_OUT_WIDTH_HIGH_FIELD                   0x0000000F /* =15 */
#define NV_064_SIZE_OUT_WIDTH_LOW_FIELD                    0x00000000 /* =0 */
#define NV_064_SIZE_OUT_HEIGHT_MSK                         0xFFFF0000 /* 31:16 */ 
#define NV_064_SIZE_OUT_HEIGHT_RMSK                        0x0000FFFF /* 31:16 */ 
#define NV_064_SIZE_OUT_HEIGHT_WORD                        0
#define NV_064_SIZE_OUT_HEIGHT_HIGH_FIELD                  0x0000001F /* =31 */
#define NV_064_SIZE_OUT_HEIGHT_LOW_FIELD                   0x00000010 /* =16 */
#define NV_064_SIZE_OUT_MSK                                0xFFFFFFFF 
#define NV_064_SIZE_IN_WIDTH_MSK                           0x0000FFFF /* 15:0 */ 
#define NV_064_SIZE_IN_WIDTH_RMSK                          0x0000FFFF /* 15:0 */ 
#define NV_064_SIZE_IN_WIDTH_WORD                          0
#define NV_064_SIZE_IN_WIDTH_HIGH_FIELD                    0x0000000F /* =15 */
#define NV_064_SIZE_IN_WIDTH_LOW_FIELD                     0x00000000 /* =0 */
#define NV_064_SIZE_IN_HEIGHT_MSK                          0xFFFF0000 /* 31:16 */ 
#define NV_064_SIZE_IN_HEIGHT_RMSK                         0x0000FFFF /* 31:16 */ 
#define NV_064_SIZE_IN_HEIGHT_WORD                         0
#define NV_064_SIZE_IN_HEIGHT_HIGH_FIELD                   0x0000001F /* =31 */
#define NV_064_SIZE_IN_HEIGHT_LOW_FIELD                    0x00000010 /* =16 */
#define NV_064_SIZE_IN_MSK                                 0xFFFFFFFF 
#define NV_064_INDICES_VALUE_MSK                           0xFFFFFFFF /* 31:0 */ 
#define NV_064_INDICES_VALUE_RMSK                          0xFFFFFFFF /* 31:0 */ 
#define NV_064_INDICES_VALUE_WORD                          0
#define NV_064_INDICES_VALUE_HIGH_FIELD                    0x0000001F /* =31 */
#define NV_064_INDICES_VALUE_LOW_FIELD                     0x00000000 /* =0 */
#define NV_064_INDICES_MSK                                 0xFFFFFFFF 
#define NV_UIMAGE_HIGH_FIELD                               0x00511FFF /* =5316607 */
#define NV_UIMAGE_LOW_FIELD                                0x00510000 /* =5308416 */
#define NV_UIMAGE_CTX_SWITCH_ADJ                           0x00510000
#define NV_UIMAGE_CTX_SWITCH_INSTANCE_MSK                  0x0000FFFF /* 15:0 */ 
#define NV_UIMAGE_CTX_SWITCH_INSTANCE_RMSK                 0x0000FFFF /* 15:0 */ 
#define NV_UIMAGE_CTX_SWITCH_INSTANCE_WORD                 0
#define NV_UIMAGE_CTX_SWITCH_INSTANCE_HIGH_FIELD           0x0000000F /* =15 */
#define NV_UIMAGE_CTX_SWITCH_INSTANCE_LOW_FIELD            0x00000000 /* =0 */
#define NV_UIMAGE_CTX_SWITCH_CHID_MSK                      0x007F0000 /* 22:16 */ 
#define NV_UIMAGE_CTX_SWITCH_CHID_RMSK                     0x0000007F /* 22:16 */ 
#define NV_UIMAGE_CTX_SWITCH_CHID_WORD                     0
#define NV_UIMAGE_CTX_SWITCH_CHID_HIGH_FIELD               0x00000016 /* =22 */
#define NV_UIMAGE_CTX_SWITCH_CHID_LOW_FIELD                0x00000010 /* =16 */
#define NV_UIMAGE_CTX_SWITCH_VOLATILE_MSK                  0x80000000 /* 31:31 */ 
#define NV_UIMAGE_CTX_SWITCH_VOLATILE_RMSK                 0x00000001 /* 31:31 */ 
#define NV_UIMAGE_CTX_SWITCH_VOLATILE_WORD                 0
#define NV_UIMAGE_CTX_SWITCH_VOLATILE_HIGH_FIELD           0x0000001F /* =31 */
#define NV_UIMAGE_CTX_SWITCH_VOLATILE_LOW_FIELD            0x0000001F /* =31 */
#define NV_UIMAGE_CTX_SWITCH_VOLATILE_IGNORE_ADJ           0x00000000
#define NV_UIMAGE_CTX_SWITCH_VOLATILE_RESET_ADJ            0x80000000
#define NV_UIMAGE_CTX_SWITCH_MSK                           0x807FFFFF 
#define NV_UIMAGE_NOP_PARAMETER_MSK                        0xFFFFFFFF /* 31:0 */ 
#define NV_UIMAGE_NOP_PARAMETER_RMSK                       0xFFFFFFFF /* 31:0 */ 
#define NV_UIMAGE_NOP_PARAMETER_WORD                       0
#define NV_UIMAGE_NOP_PARAMETER_HIGH_FIELD                 0x0000001F /* =31 */
#define NV_UIMAGE_NOP_PARAMETER_LOW_FIELD                  0x00000000 /* =0 */
#define NV_UIMAGE_NOP_MSK                                  0xFFFFFFFF 
#define NV_UIMAGE_NOTIFY_STYLE_MSK                         0xFFFFFFFF /* 31:0 */ 
#define NV_UIMAGE_NOTIFY_STYLE_RMSK                        0xFFFFFFFF /* 31:0 */ 
#define NV_UIMAGE_NOTIFY_STYLE_WORD                        0
#define NV_UIMAGE_NOTIFY_STYLE_HIGH_FIELD                  0x0000001F /* =31 */
#define NV_UIMAGE_NOTIFY_STYLE_LOW_FIELD                   0x00000000 /* =0 */
#define NV_UIMAGE_NOTIFY_STYLE_WRITE_ONLY_ADJ              0x00000000
#define NV_UIMAGE_NOTIFY_STYLE_WRITE_THEN_AWAKEN_ADJ       0x00000001
#define NV_UIMAGE_NOTIFY_MSK                               0xFFFFFFFF 
#define NV_UIMAGE_SET_NOTIFY_PARAMETER_MSK                 0xFFFFFFFF /* 31:0 */ 
#define NV_UIMAGE_SET_NOTIFY_PARAMETER_RMSK                0xFFFFFFFF /* 31:0 */ 
#define NV_UIMAGE_SET_NOTIFY_PARAMETER_WORD                0
#define NV_UIMAGE_SET_NOTIFY_PARAMETER_HIGH_FIELD          0x0000001F /* =31 */
#define NV_UIMAGE_SET_NOTIFY_PARAMETER_LOW_FIELD           0x00000000 /* =0 */
#define NV_UIMAGE_SET_NOTIFY_PARAMETER_WRITE_ADJ           0x00000000
#define NV_UIMAGE_SET_NOTIFY_MSK                           0xFFFFFFFF 
#define NV_UIMAGE_SET_PATCH_PARAMETER_MSK                  0xFFFFFFFF /* 31:0 */ 
#define NV_UIMAGE_SET_PATCH_PARAMETER_RMSK                 0xFFFFFFFF /* 31:0 */ 
#define NV_UIMAGE_SET_PATCH_PARAMETER_WORD                 0
#define NV_UIMAGE_SET_PATCH_PARAMETER_HIGH_FIELD           0x0000001F /* =31 */
#define NV_UIMAGE_SET_PATCH_PARAMETER_LOW_FIELD            0x00000000 /* =0 */
#define NV_UIMAGE_SET_PATCH_PARAMETER_INVALIDATE_ADJ       0x00000000
#define NV_UIMAGE_SET_PATCH_PARAMETER_VALIDATE_ADJ         0x00000001
#define NV_UIMAGE_SET_PATCH_MSK                            0xFFFFFFFF 
#define NV_UIMAGE_SET_CONTEXT_DMA_NOTIFY_PARAMETER_MSK     0xFFFFFFFF /* 31:0 */ 
#define NV_UIMAGE_SET_CONTEXT_DMA_NOTIFY_PARAMETER_RMSK    0xFFFFFFFF /* 31:0 */ 
#define NV_UIMAGE_SET_CONTEXT_DMA_NOTIFY_PARAMETER_WORD    0
#define NV_UIMAGE_SET_CONTEXT_DMA_NOTIFY_PARAMETER_HIGH_FIELD 0x0000001F /* =31 */
#define NV_UIMAGE_SET_CONTEXT_DMA_NOTIFY_PARAMETER_LOW_FIELD 0x00000000 /* =0 */
#define NV_UIMAGE_SET_CONTEXT_DMA_NOTIFY_MSK               0xFFFFFFFF 
#define NV_UIMAGE_SET_IMAGE_OUTPUT_PARAMETER_MSK           0xFFFFFFFF /* 31:0 */ 
#define NV_UIMAGE_SET_IMAGE_OUTPUT_PARAMETER_RMSK          0xFFFFFFFF /* 31:0 */ 
#define NV_UIMAGE_SET_IMAGE_OUTPUT_PARAMETER_WORD          0
#define NV_UIMAGE_SET_IMAGE_OUTPUT_PARAMETER_HIGH_FIELD    0x0000001F /* =31 */
#define NV_UIMAGE_SET_IMAGE_OUTPUT_PARAMETER_LOW_FIELD     0x00000000 /* =0 */
#define NV_UIMAGE_SET_IMAGE_OUTPUT_MSK                     0xFFFFFFFF 
#define NV_UIMAGE_SET_COLOR_FORMAT_LE_MSK                  0xFFFFFFFF /* 31:0 */ 
#define NV_UIMAGE_SET_COLOR_FORMAT_LE_RMSK                 0xFFFFFFFF /* 31:0 */ 
#define NV_UIMAGE_SET_COLOR_FORMAT_LE_WORD                 0
#define NV_UIMAGE_SET_COLOR_FORMAT_LE_HIGH_FIELD           0x0000001F /* =31 */
#define NV_UIMAGE_SET_COLOR_FORMAT_LE_LOW_FIELD            0x00000000 /* =0 */
#define NV_UIMAGE_SET_COLOR_FORMAT_LE_R5G6B5_ADJ           0x00000001
#define NV_UIMAGE_SET_COLOR_FORMAT_LE_A1R5G5B5_ADJ         0x00000002
#define NV_UIMAGE_SET_COLOR_FORMAT_LE_X1R5G5B5_ADJ         0x00000003
#define NV_UIMAGE_SET_COLOR_FORMAT_LE_A8R8G8B8_ADJ         0x00000004
#define NV_UIMAGE_SET_COLOR_FORMAT_LE_X8R8G8B8_ADJ         0x00000005
#define NV_UIMAGE_SET_COLOR_FORMAT_MSK                     0xFFFFFFFF 
#define NV_UIMAGE_POINT_X_MSK                              0x0000FFFF /* 15:0 */ 
#define NV_UIMAGE_POINT_X_RMSK                             0x0000FFFF /* 15:0 */ 
#define NV_UIMAGE_POINT_X_WORD                             0
#define NV_UIMAGE_POINT_X_HIGH_FIELD                       0x0000000F /* =15 */
#define NV_UIMAGE_POINT_X_LOW_FIELD                        0x00000000 /* =0 */
#define NV_UIMAGE_POINT_Y_MSK                              0xFFFF0000 /* 31:16 */ 
#define NV_UIMAGE_POINT_Y_RMSK                             0x0000FFFF /* 31:16 */ 
#define NV_UIMAGE_POINT_Y_WORD                             0
#define NV_UIMAGE_POINT_Y_HIGH_FIELD                       0x0000001F /* =31 */
#define NV_UIMAGE_POINT_Y_LOW_FIELD                        0x00000010 /* =16 */
#define NV_UIMAGE_POINT_MSK                                0xFFFFFFFF 
#define NV_UIMAGE_SIZE_WIDTH_MSK                           0x0000FFFF /* 15:0 */ 
#define NV_UIMAGE_SIZE_WIDTH_RMSK                          0x0000FFFF /* 15:0 */ 
#define NV_UIMAGE_SIZE_WIDTH_WORD                          0
#define NV_UIMAGE_SIZE_WIDTH_HIGH_FIELD                    0x0000000F /* =15 */
#define NV_UIMAGE_SIZE_WIDTH_LOW_FIELD                     0x00000000 /* =0 */
#define NV_UIMAGE_SIZE_HEIGHT_MSK                          0xFFFF0000 /* 31:16 */ 
#define NV_UIMAGE_SIZE_HEIGHT_RMSK                         0x0000FFFF /* 31:16 */ 
#define NV_UIMAGE_SIZE_HEIGHT_WORD                         0
#define NV_UIMAGE_SIZE_HEIGHT_HIGH_FIELD                   0x0000001F /* =31 */
#define NV_UIMAGE_SIZE_HEIGHT_LOW_FIELD                    0x00000010 /* =16 */
#define NV_UIMAGE_SIZE_MSK                                 0xFFFFFFFF 
#define NV_UIMAGE_SIZE_IN_WIDTH_MSK                        0x0000FFFF /* 15:0 */ 
#define NV_UIMAGE_SIZE_IN_WIDTH_RMSK                       0x0000FFFF /* 15:0 */ 
#define NV_UIMAGE_SIZE_IN_WIDTH_WORD                       0
#define NV_UIMAGE_SIZE_IN_WIDTH_HIGH_FIELD                 0x0000000F /* =15 */
#define NV_UIMAGE_SIZE_IN_WIDTH_LOW_FIELD                  0x00000000 /* =0 */
#define NV_UIMAGE_SIZE_IN_HEIGHT_MSK                       0xFFFF0000 /* 31:16 */ 
#define NV_UIMAGE_SIZE_IN_HEIGHT_RMSK                      0x0000FFFF /* 31:16 */ 
#define NV_UIMAGE_SIZE_IN_HEIGHT_WORD                      0
#define NV_UIMAGE_SIZE_IN_HEIGHT_HIGH_FIELD                0x0000001F /* =31 */
#define NV_UIMAGE_SIZE_IN_HEIGHT_LOW_FIELD                 0x00000010 /* =16 */
#define NV_UIMAGE_SIZE_IN_MSK                              0xFFFFFFFF 
#define NV_UIMAGE_COLOR_VALUE_MSK                          0xFFFFFFFF /* 31:0 */ 
#define NV_UIMAGE_COLOR_VALUE_RMSK                         0xFFFFFFFF /* 31:0 */ 
#define NV_UIMAGE_COLOR_VALUE_WORD                         0
#define NV_UIMAGE_COLOR_VALUE_HIGH_FIELD                   0x0000001F /* =31 */
#define NV_UIMAGE_COLOR_VALUE_LOW_FIELD                    0x00000000 /* =0 */
#define NV_UIMAGE_COLOR_MSK                                0xFFFFFFFF 
#define NV_065_HIGH_FIELD                                  0x00661FFF /* =6692863 */
#define NV_065_LOW_FIELD                                   0x00660000 /* =6684672 */
#define NV_065_NV5_IMAGE_FROM_CPU_ADJ                      0x00660000
#define NV_065_NV5_IMAGE_FROM_CPU_HANDLE_MSK               0xFFFFFFFF /* 31:0 */ 
#define NV_065_NV5_IMAGE_FROM_CPU_HANDLE_RMSK              0xFFFFFFFF /* 31:0 */ 
#define NV_065_NV5_IMAGE_FROM_CPU_HANDLE_WORD              0
#define NV_065_NV5_IMAGE_FROM_CPU_HANDLE_HIGH_FIELD        0x0000001F /* =31 */
#define NV_065_NV5_IMAGE_FROM_CPU_HANDLE_LOW_FIELD         0x00000000 /* =0 */
#define NV_065_NV5_IMAGE_FROM_CPU_MSK                      0xFFFFFFFF 
#define NV_065_NOP_PARAMETER_MSK                           0xFFFFFFFF /* 31:0 */ 
#define NV_065_NOP_PARAMETER_RMSK                          0xFFFFFFFF /* 31:0 */ 
#define NV_065_NOP_PARAMETER_WORD                          0
#define NV_065_NOP_PARAMETER_HIGH_FIELD                    0x0000001F /* =31 */
#define NV_065_NOP_PARAMETER_LOW_FIELD                     0x00000000 /* =0 */
#define NV_065_NOP_MSK                                     0xFFFFFFFF 
#define NV_065_NOTIFY_STYLE_MSK                            0xFFFFFFFF /* 31:0 */ 
#define NV_065_NOTIFY_STYLE_RMSK                           0xFFFFFFFF /* 31:0 */ 
#define NV_065_NOTIFY_STYLE_WORD                           0
#define NV_065_NOTIFY_STYLE_HIGH_FIELD                     0x0000001F /* =31 */
#define NV_065_NOTIFY_STYLE_LOW_FIELD                      0x00000000 /* =0 */
#define NV_065_NOTIFY_STYLE_WRITE_ONLY_ADJ                 0x00000000
#define NV_065_NOTIFY_STYLE_WRITE_THEN_AWAKEN_ADJ          0x00000001
#define NV_065_NOTIFY_MSK                                  0xFFFFFFFF 
#define NV_065_SET_NOTIFY_PARAMETER_MSK                    0xFFFFFFFF /* 31:0 */ 
#define NV_065_SET_NOTIFY_PARAMETER_RMSK                   0xFFFFFFFF /* 31:0 */ 
#define NV_065_SET_NOTIFY_PARAMETER_WORD                   0
#define NV_065_SET_NOTIFY_PARAMETER_HIGH_FIELD             0x0000001F /* =31 */
#define NV_065_SET_NOTIFY_PARAMETER_LOW_FIELD              0x00000000 /* =0 */
#define NV_065_SET_NOTIFY_PARAMETER_WRITE_ADJ              0x00000000
#define NV_065_SET_NOTIFY_MSK                              0xFFFFFFFF 
#define NV_065_SET_CONTEXT_DMA_NOTIFY_PARAMETER_MSK        0xFFFFFFFF /* 31:0 */ 
#define NV_065_SET_CONTEXT_DMA_NOTIFY_PARAMETER_RMSK       0xFFFFFFFF /* 31:0 */ 
#define NV_065_SET_CONTEXT_DMA_NOTIFY_PARAMETER_WORD       0
#define NV_065_SET_CONTEXT_DMA_NOTIFY_PARAMETER_HIGH_FIELD 0x0000001F /* =31 */
#define NV_065_SET_CONTEXT_DMA_NOTIFY_PARAMETER_LOW_FIELD  0x00000000 /* =0 */
#define NV_065_SET_CONTEXT_DMA_NOTIFY_MSK                  0xFFFFFFFF 
#define NV_065_SET_CONTEXT_COLOR_KEY_PARAMETER_MSK         0xFFFFFFFF /* 31:0 */ 
#define NV_065_SET_CONTEXT_COLOR_KEY_PARAMETER_RMSK        0xFFFFFFFF /* 31:0 */ 
#define NV_065_SET_CONTEXT_COLOR_KEY_PARAMETER_WORD        0
#define NV_065_SET_CONTEXT_COLOR_KEY_PARAMETER_HIGH_FIELD  0x0000001F /* =31 */
#define NV_065_SET_CONTEXT_COLOR_KEY_PARAMETER_LOW_FIELD   0x00000000 /* =0 */
#define NV_065_SET_CONTEXT_COLOR_KEY_MSK                   0xFFFFFFFF 
#define NV_065_SET_CONTEXT_CLIP_RECTANGLE_PARAMETER_MSK    0xFFFFFFFF /* 31:0 */ 
#define NV_065_SET_CONTEXT_CLIP_RECTANGLE_PARAMETER_RMSK   0xFFFFFFFF /* 31:0 */ 
#define NV_065_SET_CONTEXT_CLIP_RECTANGLE_PARAMETER_WORD   0
#define NV_065_SET_CONTEXT_CLIP_RECTANGLE_PARAMETER_HIGH_FIELD 0x0000001F /* =31 */
#define NV_065_SET_CONTEXT_CLIP_RECTANGLE_PARAMETER_LOW_FIELD 0x00000000 /* =0 */
#define NV_065_SET_CONTEXT_CLIP_RECTANGLE_MSK              0xFFFFFFFF 
#define NV_065_SET_CONTEXT_PATTERN_PARAMETER_MSK           0xFFFFFFFF /* 31:0 */ 
#define NV_065_SET_CONTEXT_PATTERN_PARAMETER_RMSK          0xFFFFFFFF /* 31:0 */ 
#define NV_065_SET_CONTEXT_PATTERN_PARAMETER_WORD          0
#define NV_065_SET_CONTEXT_PATTERN_PARAMETER_HIGH_FIELD    0x0000001F /* =31 */
#define NV_065_SET_CONTEXT_PATTERN_PARAMETER_LOW_FIELD     0x00000000 /* =0 */
#define NV_065_SET_CONTEXT_PATTERN_MSK                     0xFFFFFFFF 
#define NV_065_SET_CONTEXT_ROP_PARAMETER_MSK               0xFFFFFFFF /* 31:0 */ 
#define NV_065_SET_CONTEXT_ROP_PARAMETER_RMSK              0xFFFFFFFF /* 31:0 */ 
#define NV_065_SET_CONTEXT_ROP_PARAMETER_WORD              0
#define NV_065_SET_CONTEXT_ROP_PARAMETER_HIGH_FIELD        0x0000001F /* =31 */
#define NV_065_SET_CONTEXT_ROP_PARAMETER_LOW_FIELD         0x00000000 /* =0 */
#define NV_065_SET_CONTEXT_ROP_MSK                         0xFFFFFFFF 
#define NV_065_SET_CONTEXT_BETA1_PARAMETER_MSK             0xFFFFFFFF /* 31:0 */ 
#define NV_065_SET_CONTEXT_BETA1_PARAMETER_RMSK            0xFFFFFFFF /* 31:0 */ 
#define NV_065_SET_CONTEXT_BETA1_PARAMETER_WORD            0
#define NV_065_SET_CONTEXT_BETA1_PARAMETER_HIGH_FIELD      0x0000001F /* =31 */
#define NV_065_SET_CONTEXT_BETA1_PARAMETER_LOW_FIELD       0x00000000 /* =0 */
#define NV_065_SET_CONTEXT_BETA1_MSK                       0xFFFFFFFF 
#define NV_065_SET_CONTEXT_BETA4_PARAMETER_MSK             0xFFFFFFFF /* 31:0 */ 
#define NV_065_SET_CONTEXT_BETA4_PARAMETER_RMSK            0xFFFFFFFF /* 31:0 */ 
#define NV_065_SET_CONTEXT_BETA4_PARAMETER_WORD            0
#define NV_065_SET_CONTEXT_BETA4_PARAMETER_HIGH_FIELD      0x0000001F /* =31 */
#define NV_065_SET_CONTEXT_BETA4_PARAMETER_LOW_FIELD       0x00000000 /* =0 */
#define NV_065_SET_CONTEXT_BETA4_MSK                       0xFFFFFFFF 
#define NV_065_SET_CONTEXT_SURFACE_PARAMETER_MSK           0xFFFFFFFF /* 31:0 */ 
#define NV_065_SET_CONTEXT_SURFACE_PARAMETER_RMSK          0xFFFFFFFF /* 31:0 */ 
#define NV_065_SET_CONTEXT_SURFACE_PARAMETER_WORD          0
#define NV_065_SET_CONTEXT_SURFACE_PARAMETER_HIGH_FIELD    0x0000001F /* =31 */
#define NV_065_SET_CONTEXT_SURFACE_PARAMETER_LOW_FIELD     0x00000000 /* =0 */
#define NV_065_SET_CONTEXT_SURFACE_MSK                     0xFFFFFFFF 
#define NV_065_SET_COLOR_CONVERSION_TYPE_MSK               0xFFFFFFFF /* 31:0 */ 
#define NV_065_SET_COLOR_CONVERSION_TYPE_RMSK              0xFFFFFFFF /* 31:0 */ 
#define NV_065_SET_COLOR_CONVERSION_TYPE_WORD              0
#define NV_065_SET_COLOR_CONVERSION_TYPE_HIGH_FIELD        0x0000001F /* =31 */
#define NV_065_SET_COLOR_CONVERSION_TYPE_LOW_FIELD         0x00000000 /* =0 */
#define NV_065_SET_COLOR_CONVERSION_TYPE_DITHER_ADJ        0x00000000
#define NV_065_SET_COLOR_CONVERSION_TYPE_TRUNCATE_ADJ      0x00000001
#define NV_065_SET_COLOR_CONVERSION_TYPE_SUBTR_TRUNCATE_ADJ 0x00000002
#define NV_065_SET_COLOR_CONVERSION_MSK                    0xFFFFFFFF 
#define NV_065_SET_OPERATION_MODE_MSK                      0xFFFFFFFF /* 31:0 */ 
#define NV_065_SET_OPERATION_MODE_RMSK                     0xFFFFFFFF /* 31:0 */ 
#define NV_065_SET_OPERATION_MODE_WORD                     0
#define NV_065_SET_OPERATION_MODE_HIGH_FIELD               0x0000001F /* =31 */
#define NV_065_SET_OPERATION_MODE_LOW_FIELD                0x00000000 /* =0 */
#define NV_065_SET_OPERATION_MODE_SRCCOPY_AND_ADJ          0x00000000
#define NV_065_SET_OPERATION_MODE_ROP_AND_ADJ              0x00000001
#define NV_065_SET_OPERATION_MODE_BLEND_AND_ADJ            0x00000002
#define NV_065_SET_OPERATION_MODE_SRCCOPY_ADJ              0x00000003
#define NV_065_SET_OPERATION_MODE_SRCCOPY_PREMULT_ADJ      0x00000004
#define NV_065_SET_OPERATION_MODE_BLEND_PREMULT_ADJ        0x00000005
#define NV_065_SET_OPERATION_MSK                           0xFFFFFFFF 
#define NV_065_SET_COLOR_FORMAT_LE_MSK                     0xFFFFFFFF /* 31:0 */ 
#define NV_065_SET_COLOR_FORMAT_LE_RMSK                    0xFFFFFFFF /* 31:0 */ 
#define NV_065_SET_COLOR_FORMAT_LE_WORD                    0
#define NV_065_SET_COLOR_FORMAT_LE_HIGH_FIELD              0x0000001F /* =31 */
#define NV_065_SET_COLOR_FORMAT_LE_LOW_FIELD               0x00000000 /* =0 */
#define NV_065_SET_COLOR_FORMAT_LE_R5G6B5_ADJ              0x00000001
#define NV_065_SET_COLOR_FORMAT_LE_A1R5G5B5_ADJ            0x00000002
#define NV_065_SET_COLOR_FORMAT_LE_X1R5G5B5_ADJ            0x00000003
#define NV_065_SET_COLOR_FORMAT_LE_A8R8G8B8_ADJ            0x00000004
#define NV_065_SET_COLOR_FORMAT_LE_X8R8G8B8_ADJ            0x00000005
#define NV_065_SET_COLOR_FORMAT_MSK                        0xFFFFFFFF 
#define NV_065_POINT_X_MSK                                 0x0000FFFF /* 15:0 */ 
#define NV_065_POINT_X_RMSK                                0x0000FFFF /* 15:0 */ 
#define NV_065_POINT_X_WORD                                0
#define NV_065_POINT_X_HIGH_FIELD                          0x0000000F /* =15 */
#define NV_065_POINT_X_LOW_FIELD                           0x00000000 /* =0 */
#define NV_065_POINT_Y_MSK                                 0xFFFF0000 /* 31:16 */ 
#define NV_065_POINT_Y_RMSK                                0x0000FFFF /* 31:16 */ 
#define NV_065_POINT_Y_WORD                                0
#define NV_065_POINT_Y_HIGH_FIELD                          0x0000001F /* =31 */
#define NV_065_POINT_Y_LOW_FIELD                           0x00000010 /* =16 */
#define NV_065_POINT_MSK                                   0xFFFFFFFF 
#define NV_065_SIZE_OUT_WIDTH_MSK                          0x0000FFFF /* 15:0 */ 
#define NV_065_SIZE_OUT_WIDTH_RMSK                         0x0000FFFF /* 15:0 */ 
#define NV_065_SIZE_OUT_WIDTH_WORD                         0
#define NV_065_SIZE_OUT_WIDTH_HIGH_FIELD                   0x0000000F /* =15 */
#define NV_065_SIZE_OUT_WIDTH_LOW_FIELD                    0x00000000 /* =0 */
#define NV_065_SIZE_OUT_HEIGHT_MSK                         0xFFFF0000 /* 31:16 */ 
#define NV_065_SIZE_OUT_HEIGHT_RMSK                        0x0000FFFF /* 31:16 */ 
#define NV_065_SIZE_OUT_HEIGHT_WORD                        0
#define NV_065_SIZE_OUT_HEIGHT_HIGH_FIELD                  0x0000001F /* =31 */
#define NV_065_SIZE_OUT_HEIGHT_LOW_FIELD                   0x00000010 /* =16 */
#define NV_065_SIZE_OUT_MSK                                0xFFFFFFFF 
#define NV_065_SIZE_IN_WIDTH_MSK                           0x0000FFFF /* 15:0 */ 
#define NV_065_SIZE_IN_WIDTH_RMSK                          0x0000FFFF /* 15:0 */ 
#define NV_065_SIZE_IN_WIDTH_WORD                          0
#define NV_065_SIZE_IN_WIDTH_HIGH_FIELD                    0x0000000F /* =15 */
#define NV_065_SIZE_IN_WIDTH_LOW_FIELD                     0x00000000 /* =0 */
#define NV_065_SIZE_IN_HEIGHT_MSK                          0xFFFF0000 /* 31:16 */ 
#define NV_065_SIZE_IN_HEIGHT_RMSK                         0x0000FFFF /* 31:16 */ 
#define NV_065_SIZE_IN_HEIGHT_WORD                         0
#define NV_065_SIZE_IN_HEIGHT_HIGH_FIELD                   0x0000001F /* =31 */
#define NV_065_SIZE_IN_HEIGHT_LOW_FIELD                    0x00000010 /* =16 */
#define NV_065_SIZE_IN_MSK                                 0xFFFFFFFF 
#define NV_065_COLOR_VALUE_MSK                             0xFFFFFFFF /* 31:0 */ 
#define NV_065_COLOR_VALUE_RMSK                            0xFFFFFFFF /* 31:0 */ 
#define NV_065_COLOR_VALUE_WORD                            0
#define NV_065_COLOR_VALUE_HIGH_FIELD                      0x0000001F /* =31 */
#define NV_065_COLOR_VALUE_LOW_FIELD                       0x00000000 /* =0 */
#define NV_065_COLOR_MSK                                   0xFFFFFFFF 
#define NV_08A_HIGH_FIELD                                  0x00541FFF /* =5513215 */
#define NV_08A_LOW_FIELD                                   0x00540000 /* =5505024 */
#define NV_08A_NV10_IMAGE_FROM_CPU_ADJ                     0x00540000
#define NV_08A_NV10_IMAGE_FROM_CPU_HANDLE_MSK              0xFFFFFFFF /* 31:0 */ 
#define NV_08A_NV10_IMAGE_FROM_CPU_HANDLE_RMSK             0xFFFFFFFF /* 31:0 */ 
#define NV_08A_NV10_IMAGE_FROM_CPU_HANDLE_WORD             0
#define NV_08A_NV10_IMAGE_FROM_CPU_HANDLE_HIGH_FIELD       0x0000001F /* =31 */
#define NV_08A_NV10_IMAGE_FROM_CPU_HANDLE_LOW_FIELD        0x00000000 /* =0 */
#define NV_08A_NV10_IMAGE_FROM_CPU_MSK                     0xFFFFFFFF 
#define NV_08A_NOP_PARAMETER_MSK                           0xFFFFFFFF /* 31:0 */ 
#define NV_08A_NOP_PARAMETER_RMSK                          0xFFFFFFFF /* 31:0 */ 
#define NV_08A_NOP_PARAMETER_WORD                          0
#define NV_08A_NOP_PARAMETER_HIGH_FIELD                    0x0000001F /* =31 */
#define NV_08A_NOP_PARAMETER_LOW_FIELD                     0x00000000 /* =0 */
#define NV_08A_NOP_MSK                                     0xFFFFFFFF 
#define NV_08A_NOTIFY_STYLE_MSK                            0xFFFFFFFF /* 31:0 */ 
#define NV_08A_NOTIFY_STYLE_RMSK                           0xFFFFFFFF /* 31:0 */ 
#define NV_08A_NOTIFY_STYLE_WORD                           0
#define NV_08A_NOTIFY_STYLE_HIGH_FIELD                     0x0000001F /* =31 */
#define NV_08A_NOTIFY_STYLE_LOW_FIELD                      0x00000000 /* =0 */
#define NV_08A_NOTIFY_STYLE_WRITE_ONLY_ADJ                 0x00000000
#define NV_08A_NOTIFY_STYLE_WRITE_THEN_AWAKEN_ADJ          0x00000001
#define NV_08A_NOTIFY_MSK                                  0xFFFFFFFF 
#define NV_08A_SET_NOTIFY_PARAMETER_MSK                    0xFFFFFFFF /* 31:0 */ 
#define NV_08A_SET_NOTIFY_PARAMETER_RMSK                   0xFFFFFFFF /* 31:0 */ 
#define NV_08A_SET_NOTIFY_PARAMETER_WORD                   0
#define NV_08A_SET_NOTIFY_PARAMETER_HIGH_FIELD             0x0000001F /* =31 */
#define NV_08A_SET_NOTIFY_PARAMETER_LOW_FIELD              0x00000000 /* =0 */
#define NV_08A_SET_NOTIFY_PARAMETER_WRITE_ADJ              0x00000000
#define NV_08A_SET_NOTIFY_MSK                              0xFFFFFFFF 
#define NV_08A_WAIT_FOR_IDLE_PARAMETER_MSK                 0xFFFFFFFF /* 31:0 */ 
#define NV_08A_WAIT_FOR_IDLE_PARAMETER_RMSK                0xFFFFFFFF /* 31:0 */ 
#define NV_08A_WAIT_FOR_IDLE_PARAMETER_WORD                0
#define NV_08A_WAIT_FOR_IDLE_PARAMETER_HIGH_FIELD          0x0000001F /* =31 */
#define NV_08A_WAIT_FOR_IDLE_PARAMETER_LOW_FIELD           0x00000000 /* =0 */
#define NV_08A_WAIT_FOR_IDLE_MSK                           0xFFFFFFFF 
#define NV_08A_SET_CONTEXT_DMA_NOTIFY_PARAMETER_MSK        0xFFFFFFFF /* 31:0 */ 
#define NV_08A_SET_CONTEXT_DMA_NOTIFY_PARAMETER_RMSK       0xFFFFFFFF /* 31:0 */ 
#define NV_08A_SET_CONTEXT_DMA_NOTIFY_PARAMETER_WORD       0
#define NV_08A_SET_CONTEXT_DMA_NOTIFY_PARAMETER_HIGH_FIELD 0x0000001F /* =31 */
#define NV_08A_SET_CONTEXT_DMA_NOTIFY_PARAMETER_LOW_FIELD  0x00000000 /* =0 */
#define NV_08A_SET_CONTEXT_DMA_NOTIFY_MSK                  0xFFFFFFFF 
#define NV_08A_SET_CONTEXT_COLOR_KEY_PARAMETER_MSK         0xFFFFFFFF /* 31:0 */ 
#define NV_08A_SET_CONTEXT_COLOR_KEY_PARAMETER_RMSK        0xFFFFFFFF /* 31:0 */ 
#define NV_08A_SET_CONTEXT_COLOR_KEY_PARAMETER_WORD        0
#define NV_08A_SET_CONTEXT_COLOR_KEY_PARAMETER_HIGH_FIELD  0x0000001F /* =31 */
#define NV_08A_SET_CONTEXT_COLOR_KEY_PARAMETER_LOW_FIELD   0x00000000 /* =0 */
#define NV_08A_SET_CONTEXT_COLOR_KEY_MSK                   0xFFFFFFFF 
#define NV_08A_SET_CONTEXT_CLIP_RECTANGLE_PARAMETER_MSK    0xFFFFFFFF /* 31:0 */ 
#define NV_08A_SET_CONTEXT_CLIP_RECTANGLE_PARAMETER_RMSK   0xFFFFFFFF /* 31:0 */ 
#define NV_08A_SET_CONTEXT_CLIP_RECTANGLE_PARAMETER_WORD   0
#define NV_08A_SET_CONTEXT_CLIP_RECTANGLE_PARAMETER_HIGH_FIELD 0x0000001F /* =31 */
#define NV_08A_SET_CONTEXT_CLIP_RECTANGLE_PARAMETER_LOW_FIELD 0x00000000 /* =0 */
#define NV_08A_SET_CONTEXT_CLIP_RECTANGLE_MSK              0xFFFFFFFF 
#define NV_08A_SET_CONTEXT_PATTERN_PARAMETER_MSK           0xFFFFFFFF /* 31:0 */ 
#define NV_08A_SET_CONTEXT_PATTERN_PARAMETER_RMSK          0xFFFFFFFF /* 31:0 */ 
#define NV_08A_SET_CONTEXT_PATTERN_PARAMETER_WORD          0
#define NV_08A_SET_CONTEXT_PATTERN_PARAMETER_HIGH_FIELD    0x0000001F /* =31 */
#define NV_08A_SET_CONTEXT_PATTERN_PARAMETER_LOW_FIELD     0x00000000 /* =0 */
#define NV_08A_SET_CONTEXT_PATTERN_MSK                     0xFFFFFFFF 
#define NV_08A_SET_CONTEXT_ROP_PARAMETER_MSK               0xFFFFFFFF /* 31:0 */ 
#define NV_08A_SET_CONTEXT_ROP_PARAMETER_RMSK              0xFFFFFFFF /* 31:0 */ 
#define NV_08A_SET_CONTEXT_ROP_PARAMETER_WORD              0
#define NV_08A_SET_CONTEXT_ROP_PARAMETER_HIGH_FIELD        0x0000001F /* =31 */
#define NV_08A_SET_CONTEXT_ROP_PARAMETER_LOW_FIELD         0x00000000 /* =0 */
#define NV_08A_SET_CONTEXT_ROP_MSK                         0xFFFFFFFF 
#define NV_08A_SET_CONTEXT_BETA1_PARAMETER_MSK             0xFFFFFFFF /* 31:0 */ 
#define NV_08A_SET_CONTEXT_BETA1_PARAMETER_RMSK            0xFFFFFFFF /* 31:0 */ 
#define NV_08A_SET_CONTEXT_BETA1_PARAMETER_WORD            0
#define NV_08A_SET_CONTEXT_BETA1_PARAMETER_HIGH_FIELD      0x0000001F /* =31 */
#define NV_08A_SET_CONTEXT_BETA1_PARAMETER_LOW_FIELD       0x00000000 /* =0 */
#define NV_08A_SET_CONTEXT_BETA1_MSK                       0xFFFFFFFF 
#define NV_08A_SET_CONTEXT_BETA4_PARAMETER_MSK             0xFFFFFFFF /* 31:0 */ 
#define NV_08A_SET_CONTEXT_BETA4_PARAMETER_RMSK            0xFFFFFFFF /* 31:0 */ 
#define NV_08A_SET_CONTEXT_BETA4_PARAMETER_WORD            0
#define NV_08A_SET_CONTEXT_BETA4_PARAMETER_HIGH_FIELD      0x0000001F /* =31 */
#define NV_08A_SET_CONTEXT_BETA4_PARAMETER_LOW_FIELD       0x00000000 /* =0 */
#define NV_08A_SET_CONTEXT_BETA4_MSK                       0xFFFFFFFF 
#define NV_08A_SET_CONTEXT_SURFACE_PARAMETER_MSK           0xFFFFFFFF /* 31:0 */ 
#define NV_08A_SET_CONTEXT_SURFACE_PARAMETER_RMSK          0xFFFFFFFF /* 31:0 */ 
#define NV_08A_SET_CONTEXT_SURFACE_PARAMETER_WORD          0
#define NV_08A_SET_CONTEXT_SURFACE_PARAMETER_HIGH_FIELD    0x0000001F /* =31 */
#define NV_08A_SET_CONTEXT_SURFACE_PARAMETER_LOW_FIELD     0x00000000 /* =0 */
#define NV_08A_SET_CONTEXT_SURFACE_MSK                     0xFFFFFFFF 
#define NV_08A_SET_COLOR_CONVERSION_TYPE_MSK               0xFFFFFFFF /* 31:0 */ 
#define NV_08A_SET_COLOR_CONVERSION_TYPE_RMSK              0xFFFFFFFF /* 31:0 */ 
#define NV_08A_SET_COLOR_CONVERSION_TYPE_WORD              0
#define NV_08A_SET_COLOR_CONVERSION_TYPE_HIGH_FIELD        0x0000001F /* =31 */
#define NV_08A_SET_COLOR_CONVERSION_TYPE_LOW_FIELD         0x00000000 /* =0 */
#define NV_08A_SET_COLOR_CONVERSION_TYPE_DITHER_ADJ        0x00000000
#define NV_08A_SET_COLOR_CONVERSION_TYPE_TRUNCATE_ADJ      0x00000001
#define NV_08A_SET_COLOR_CONVERSION_TYPE_SUBTR_TRUNCATE_ADJ 0x00000002
#define NV_08A_SET_COLOR_CONVERSION_MSK                    0xFFFFFFFF 
#define NV_08A_SET_OPERATION_MODE_MSK                      0xFFFFFFFF /* 31:0 */ 
#define NV_08A_SET_OPERATION_MODE_RMSK                     0xFFFFFFFF /* 31:0 */ 
#define NV_08A_SET_OPERATION_MODE_WORD                     0
#define NV_08A_SET_OPERATION_MODE_HIGH_FIELD               0x0000001F /* =31 */
#define NV_08A_SET_OPERATION_MODE_LOW_FIELD                0x00000000 /* =0 */
#define NV_08A_SET_OPERATION_MODE_SRCCOPY_AND_ADJ          0x00000000
#define NV_08A_SET_OPERATION_MODE_ROP_AND_ADJ              0x00000001
#define NV_08A_SET_OPERATION_MODE_BLEND_AND_ADJ            0x00000002
#define NV_08A_SET_OPERATION_MODE_SRCCOPY_ADJ              0x00000003
#define NV_08A_SET_OPERATION_MODE_SRCCOPY_PREMULT_ADJ      0x00000004
#define NV_08A_SET_OPERATION_MODE_BLEND_PREMULT_ADJ        0x00000005
#define NV_08A_SET_OPERATION_MSK                           0xFFFFFFFF 
#define NV_08A_SET_COLOR_FORMAT_LE_MSK                     0xFFFFFFFF /* 31:0 */ 
#define NV_08A_SET_COLOR_FORMAT_LE_RMSK                    0xFFFFFFFF /* 31:0 */ 
#define NV_08A_SET_COLOR_FORMAT_LE_WORD                    0
#define NV_08A_SET_COLOR_FORMAT_LE_HIGH_FIELD              0x0000001F /* =31 */
#define NV_08A_SET_COLOR_FORMAT_LE_LOW_FIELD               0x00000000 /* =0 */
#define NV_08A_SET_COLOR_FORMAT_LE_R5G6B5_ADJ              0x00000001
#define NV_08A_SET_COLOR_FORMAT_LE_A1R5G5B5_ADJ            0x00000002
#define NV_08A_SET_COLOR_FORMAT_LE_X1R5G5B5_ADJ            0x00000003
#define NV_08A_SET_COLOR_FORMAT_LE_A8R8G8B8_ADJ            0x00000004
#define NV_08A_SET_COLOR_FORMAT_LE_X8R8G8B8_ADJ            0x00000005
#define NV_08A_SET_COLOR_FORMAT_MSK                        0xFFFFFFFF 
#define NV_08A_POINT_X_MSK                                 0x0000FFFF /* 15:0 */ 
#define NV_08A_POINT_X_RMSK                                0x0000FFFF /* 15:0 */ 
#define NV_08A_POINT_X_WORD                                0
#define NV_08A_POINT_X_HIGH_FIELD                          0x0000000F /* =15 */
#define NV_08A_POINT_X_LOW_FIELD                           0x00000000 /* =0 */
#define NV_08A_POINT_Y_MSK                                 0xFFFF0000 /* 31:16 */ 
#define NV_08A_POINT_Y_RMSK                                0x0000FFFF /* 31:16 */ 
#define NV_08A_POINT_Y_WORD                                0
#define NV_08A_POINT_Y_HIGH_FIELD                          0x0000001F /* =31 */
#define NV_08A_POINT_Y_LOW_FIELD                           0x00000010 /* =16 */
#define NV_08A_POINT_MSK                                   0xFFFFFFFF 
#define NV_08A_SIZE_OUT_WIDTH_MSK                          0x0000FFFF /* 15:0 */ 
#define NV_08A_SIZE_OUT_WIDTH_RMSK                         0x0000FFFF /* 15:0 */ 
#define NV_08A_SIZE_OUT_WIDTH_WORD                         0
#define NV_08A_SIZE_OUT_WIDTH_HIGH_FIELD                   0x0000000F /* =15 */
#define NV_08A_SIZE_OUT_WIDTH_LOW_FIELD                    0x00000000 /* =0 */
#define NV_08A_SIZE_OUT_HEIGHT_MSK                         0xFFFF0000 /* 31:16 */ 
#define NV_08A_SIZE_OUT_HEIGHT_RMSK                        0x0000FFFF /* 31:16 */ 
#define NV_08A_SIZE_OUT_HEIGHT_WORD                        0
#define NV_08A_SIZE_OUT_HEIGHT_HIGH_FIELD                  0x0000001F /* =31 */
#define NV_08A_SIZE_OUT_HEIGHT_LOW_FIELD                   0x00000010 /* =16 */
#define NV_08A_SIZE_OUT_MSK                                0xFFFFFFFF 
#define NV_08A_SIZE_IN_WIDTH_MSK                           0x0000FFFF /* 15:0 */ 
#define NV_08A_SIZE_IN_WIDTH_RMSK                          0x0000FFFF /* 15:0 */ 
#define NV_08A_SIZE_IN_WIDTH_WORD                          0
#define NV_08A_SIZE_IN_WIDTH_HIGH_FIELD                    0x0000000F /* =15 */
#define NV_08A_SIZE_IN_WIDTH_LOW_FIELD                     0x00000000 /* =0 */
#define NV_08A_SIZE_IN_HEIGHT_MSK                          0xFFFF0000 /* 31:16 */ 
#define NV_08A_SIZE_IN_HEIGHT_RMSK                         0x0000FFFF /* 31:16 */ 
#define NV_08A_SIZE_IN_HEIGHT_WORD                         0
#define NV_08A_SIZE_IN_HEIGHT_HIGH_FIELD                   0x0000001F /* =31 */
#define NV_08A_SIZE_IN_HEIGHT_LOW_FIELD                    0x00000010 /* =16 */
#define NV_08A_SIZE_IN_MSK                                 0xFFFFFFFF 
#define NV_08A_COLOR_VALUE_MSK                             0xFFFFFFFF /* 31:0 */ 
#define NV_08A_COLOR_VALUE_RMSK                            0xFFFFFFFF /* 31:0 */ 
#define NV_08A_COLOR_VALUE_WORD                            0
#define NV_08A_COLOR_VALUE_HIGH_FIELD                      0x0000001F /* =31 */
#define NV_08A_COLOR_VALUE_LOW_FIELD                       0x00000000 /* =0 */
#define NV_08A_COLORA_MSK                                  0xFFFFFFFF 
#define NV_08A_COLORB_VALUE_MSK                            0xFFFFFFFF /* 31:0 */ 
#define NV_08A_COLORB_VALUE_RMSK                           0xFFFFFFFF /* 31:0 */ 
#define NV_08A_COLORB_VALUE_WORD                           0
#define NV_08A_COLORB_VALUE_HIGH_FIELD                     0x0000001F /* =31 */
#define NV_08A_COLORB_VALUE_LOW_FIELD                      0x00000000 /* =0 */
#define NV_08A_COLORB_MSK                                  0xFFFFFFFF 
#define NV_07B_HIGH_FIELD                                  0x00531FFF /* =5447679 */
#define NV_07B_LOW_FIELD                                   0x00530000 /* =5439488 */
#define NV_07B_NV10_TEXTURE_FROM_CPU_ADJ                   0x00530000
#define NV_07B_NV10_TEXTURE_FROM_CPU_HANDLE_MSK            0xFFFFFFFF /* 31:0 */ 
#define NV_07B_NV10_TEXTURE_FROM_CPU_HANDLE_RMSK           0xFFFFFFFF /* 31:0 */ 
#define NV_07B_NV10_TEXTURE_FROM_CPU_HANDLE_WORD           0
#define NV_07B_NV10_TEXTURE_FROM_CPU_HANDLE_HIGH_FIELD     0x0000001F /* =31 */
#define NV_07B_NV10_TEXTURE_FROM_CPU_HANDLE_LOW_FIELD      0x00000000 /* =0 */
#define NV_07B_NV10_TEXTURE_FROM_CPU_MSK                   0xFFFFFFFF 
#define NV_07B_NOP_PARAMETER_MSK                           0xFFFFFFFF /* 31:0 */ 
#define NV_07B_NOP_PARAMETER_RMSK                          0xFFFFFFFF /* 31:0 */ 
#define NV_07B_NOP_PARAMETER_WORD                          0
#define NV_07B_NOP_PARAMETER_HIGH_FIELD                    0x0000001F /* =31 */
#define NV_07B_NOP_PARAMETER_LOW_FIELD                     0x00000000 /* =0 */
#define NV_07B_NOP_MSK                                     0xFFFFFFFF 
#define NV_07B_PM_TRIGGER_PARAMETER_MSK                    0xFFFFFFFF /* 31:0 */ 
#define NV_07B_PM_TRIGGER_PARAMETER_RMSK                   0xFFFFFFFF /* 31:0 */ 
#define NV_07B_PM_TRIGGER_PARAMETER_WORD                   0
#define NV_07B_PM_TRIGGER_PARAMETER_HIGH_FIELD             0x0000001F /* =31 */
#define NV_07B_PM_TRIGGER_PARAMETER_LOW_FIELD              0x00000000 /* =0 */
#define NV_07B_PM_TRIGGER_MSK                              0xFFFFFFFF 
#define NV_07B_NOTIFY_STYLE_MSK                            0xFFFFFFFF /* 31:0 */ 
#define NV_07B_NOTIFY_STYLE_RMSK                           0xFFFFFFFF /* 31:0 */ 
#define NV_07B_NOTIFY_STYLE_WORD                           0
#define NV_07B_NOTIFY_STYLE_HIGH_FIELD                     0x0000001F /* =31 */
#define NV_07B_NOTIFY_STYLE_LOW_FIELD                      0x00000000 /* =0 */
#define NV_07B_NOTIFY_STYLE_WRITE_ONLY_ADJ                 0x00000000
#define NV_07B_NOTIFY_STYLE_WRITE_THEN_AWAKEN_ADJ          0x00000001
#define NV_07B_NOTIFY_MSK                                  0xFFFFFFFF 
#define NV_07B_SET_NOTIFY_PARAMETER_MSK                    0xFFFFFFFF /* 31:0 */ 
#define NV_07B_SET_NOTIFY_PARAMETER_RMSK                   0xFFFFFFFF /* 31:0 */ 
#define NV_07B_SET_NOTIFY_PARAMETER_WORD                   0
#define NV_07B_SET_NOTIFY_PARAMETER_HIGH_FIELD             0x0000001F /* =31 */
#define NV_07B_SET_NOTIFY_PARAMETER_LOW_FIELD              0x00000000 /* =0 */
#define NV_07B_SET_NOTIFY_PARAMETER_WRITE_ADJ              0x00000000
#define NV_07B_SET_NOTIFY_MSK                              0xFFFFFFFF 
#define NV_07B_WAIT_FOR_IDLE_PARAMETER_MSK                 0xFFFFFFFF /* 31:0 */ 
#define NV_07B_WAIT_FOR_IDLE_PARAMETER_RMSK                0xFFFFFFFF /* 31:0 */ 
#define NV_07B_WAIT_FOR_IDLE_PARAMETER_WORD                0
#define NV_07B_WAIT_FOR_IDLE_PARAMETER_HIGH_FIELD          0x0000001F /* =31 */
#define NV_07B_WAIT_FOR_IDLE_PARAMETER_LOW_FIELD           0x00000000 /* =0 */
#define NV_07B_WAIT_FOR_IDLE_MSK                           0xFFFFFFFF 
#define NV_07B_SET_CONTEXT_DMA_NOTIFY_PARAMETER_MSK        0xFFFFFFFF /* 31:0 */ 
#define NV_07B_SET_CONTEXT_DMA_NOTIFY_PARAMETER_RMSK       0xFFFFFFFF /* 31:0 */ 
#define NV_07B_SET_CONTEXT_DMA_NOTIFY_PARAMETER_WORD       0
#define NV_07B_SET_CONTEXT_DMA_NOTIFY_PARAMETER_HIGH_FIELD 0x0000001F /* =31 */
#define NV_07B_SET_CONTEXT_DMA_NOTIFY_PARAMETER_LOW_FIELD  0x00000000 /* =0 */
#define NV_07B_SET_CONTEXT_DMA_NOTIFY_MSK                  0xFFFFFFFF 
#define NV_07B_SET_CONTEXT_SURFACE_PARAMETER_MSK           0xFFFFFFFF /* 31:0 */ 
#define NV_07B_SET_CONTEXT_SURFACE_PARAMETER_RMSK          0xFFFFFFFF /* 31:0 */ 
#define NV_07B_SET_CONTEXT_SURFACE_PARAMETER_WORD          0
#define NV_07B_SET_CONTEXT_SURFACE_PARAMETER_HIGH_FIELD    0x0000001F /* =31 */
#define NV_07B_SET_CONTEXT_SURFACE_PARAMETER_LOW_FIELD     0x00000000 /* =0 */
#define NV_07B_SET_CONTEXT_SURFACE_MSK                     0xFFFFFFFF 
#define NV_07B_SET_COLOR_FORMAT_LE_MSK                     0xFFFFFFFF /* 31:0 */ 
#define NV_07B_SET_COLOR_FORMAT_LE_RMSK                    0xFFFFFFFF /* 31:0 */ 
#define NV_07B_SET_COLOR_FORMAT_LE_WORD                    0
#define NV_07B_SET_COLOR_FORMAT_LE_HIGH_FIELD              0x0000001F /* =31 */
#define NV_07B_SET_COLOR_FORMAT_LE_LOW_FIELD               0x00000000 /* =0 */
#define NV_07B_SET_COLOR_FORMAT_LE_R5G6B5_ADJ              0x00000001
#define NV_07B_SET_COLOR_FORMAT_LE_A1R5G5B5_ADJ            0x00000002
#define NV_07B_SET_COLOR_FORMAT_LE_X1R5G5B5_ADJ            0x00000003
#define NV_07B_SET_COLOR_FORMAT_LE_A8R8G8B8_ADJ            0x00000004
#define NV_07B_SET_COLOR_FORMAT_LE_X8R8G8B8_ADJ            0x00000005
#define NV_07B_SET_COLOR_FORMAT_MSK                        0xFFFFFFFF 
#define NV_07B_POINT_X_MSK                                 0x0000FFFF /* 15:0 */ 
#define NV_07B_POINT_X_RMSK                                0x0000FFFF /* 15:0 */ 
#define NV_07B_POINT_X_WORD                                0
#define NV_07B_POINT_X_HIGH_FIELD                          0x0000000F /* =15 */
#define NV_07B_POINT_X_LOW_FIELD                           0x00000000 /* =0 */
#define NV_07B_POINT_Y_MSK                                 0xFFFF0000 /* 31:16 */ 
#define NV_07B_POINT_Y_RMSK                                0x0000FFFF /* 31:16 */ 
#define NV_07B_POINT_Y_WORD                                0
#define NV_07B_POINT_Y_HIGH_FIELD                          0x0000001F /* =31 */
#define NV_07B_POINT_Y_LOW_FIELD                           0x00000010 /* =16 */
#define NV_07B_POINT_MSK                                   0xFFFFFFFF 
#define NV_07B_SIZE_WIDTH_MSK                              0x0000FFFF /* 15:0 */ 
#define NV_07B_SIZE_WIDTH_RMSK                             0x0000FFFF /* 15:0 */ 
#define NV_07B_SIZE_WIDTH_WORD                             0
#define NV_07B_SIZE_WIDTH_HIGH_FIELD                       0x0000000F /* =15 */
#define NV_07B_SIZE_WIDTH_LOW_FIELD                        0x00000000 /* =0 */
#define NV_07B_SIZE_HEIGHT_MSK                             0xFFFF0000 /* 31:16 */ 
#define NV_07B_SIZE_HEIGHT_RMSK                            0x0000FFFF /* 31:16 */ 
#define NV_07B_SIZE_HEIGHT_WORD                            0
#define NV_07B_SIZE_HEIGHT_HIGH_FIELD                      0x0000001F /* =31 */
#define NV_07B_SIZE_HEIGHT_LOW_FIELD                       0x00000010 /* =16 */
#define NV_07B_SIZE_MSK                                    0xFFFFFFFF 
#define NV_07B_CLIP_HORIZONTAL_X_MSK                       0x0000FFFF /* 15:0 */ 
#define NV_07B_CLIP_HORIZONTAL_X_RMSK                      0x0000FFFF /* 15:0 */ 
#define NV_07B_CLIP_HORIZONTAL_X_WORD                      0
#define NV_07B_CLIP_HORIZONTAL_X_HIGH_FIELD                0x0000000F /* =15 */
#define NV_07B_CLIP_HORIZONTAL_X_LOW_FIELD                 0x00000000 /* =0 */
#define NV_07B_CLIP_HORIZONTAL_WIDTH_MSK                   0xFFFF0000 /* 31:16 */ 
#define NV_07B_CLIP_HORIZONTAL_WIDTH_RMSK                  0x0000FFFF /* 31:16 */ 
#define NV_07B_CLIP_HORIZONTAL_WIDTH_WORD                  0
#define NV_07B_CLIP_HORIZONTAL_WIDTH_HIGH_FIELD            0x0000001F /* =31 */
#define NV_07B_CLIP_HORIZONTAL_WIDTH_LOW_FIELD             0x00000010 /* =16 */
#define NV_07B_CLIP_HORIZONTAL_MSK                         0xFFFFFFFF 
#define NV_07B_CLIP_VERTICAL_Y_MSK                         0x0000FFFF /* 15:0 */ 
#define NV_07B_CLIP_VERTICAL_Y_RMSK                        0x0000FFFF /* 15:0 */ 
#define NV_07B_CLIP_VERTICAL_Y_WORD                        0
#define NV_07B_CLIP_VERTICAL_Y_HIGH_FIELD                  0x0000000F /* =15 */
#define NV_07B_CLIP_VERTICAL_Y_LOW_FIELD                   0x00000000 /* =0 */
#define NV_07B_CLIP_VERTICAL_HEIGHT_MSK                    0xFFFF0000 /* 31:16 */ 
#define NV_07B_CLIP_VERTICAL_HEIGHT_RMSK                   0x0000FFFF /* 31:16 */ 
#define NV_07B_CLIP_VERTICAL_HEIGHT_WORD                   0
#define NV_07B_CLIP_VERTICAL_HEIGHT_HIGH_FIELD             0x0000001F /* =31 */
#define NV_07B_CLIP_VERTICAL_HEIGHT_LOW_FIELD              0x00000010 /* =16 */
#define NV_07B_CLIP_VERTICAL_MSK                           0xFFFFFFFF 
#define NV_07B_COLOR_VALUE_MSK                             0xFFFFFFFF /* 31:0 */ 
#define NV_07B_COLOR_VALUE_RMSK                            0xFFFFFFFF /* 31:0 */ 
#define NV_07B_COLOR_VALUE_WORD                            0
#define NV_07B_COLOR_VALUE_HIGH_FIELD                      0x0000001F /* =31 */
#define NV_07B_COLOR_VALUE_LOW_FIELD                       0x00000000 /* =0 */
#define NV_07B_COLORA_MSK                                  0xFFFFFFFF 
#define NV_07B_COLORB_VALUE_MSK                            0xFFFFFFFF /* 31:0 */ 
#define NV_07B_COLORB_VALUE_RMSK                           0xFFFFFFFF /* 31:0 */ 
#define NV_07B_COLORB_VALUE_WORD                           0
#define NV_07B_COLORB_VALUE_HIGH_FIELD                     0x0000001F /* =31 */
#define NV_07B_COLORB_VALUE_LOW_FIELD                      0x00000000 /* =0 */
#define NV_07B_COLORB_MSK                                  0xFFFFFFFF 
#define NV_USCALED_HIGH_FIELD                              0x004E1FFF /* =5119999 */
#define NV_USCALED_LOW_FIELD                               0x004E0000 /* =5111808 */
#define NV_USCALED_CTX_SWITCH_ADJ                          0x004E0000
#define NV_USCALED_CTX_SWITCH_INSTANCE_MSK                 0x0000FFFF /* 15:0 */ 
#define NV_USCALED_CTX_SWITCH_INSTANCE_RMSK                0x0000FFFF /* 15:0 */ 
#define NV_USCALED_CTX_SWITCH_INSTANCE_WORD                0
#define NV_USCALED_CTX_SWITCH_INSTANCE_HIGH_FIELD          0x0000000F /* =15 */
#define NV_USCALED_CTX_SWITCH_INSTANCE_LOW_FIELD           0x00000000 /* =0 */
#define NV_USCALED_CTX_SWITCH_CHID_MSK                     0x007F0000 /* 22:16 */ 
#define NV_USCALED_CTX_SWITCH_CHID_RMSK                    0x0000007F /* 22:16 */ 
#define NV_USCALED_CTX_SWITCH_CHID_WORD                    0
#define NV_USCALED_CTX_SWITCH_CHID_HIGH_FIELD              0x00000016 /* =22 */
#define NV_USCALED_CTX_SWITCH_CHID_LOW_FIELD               0x00000010 /* =16 */
#define NV_USCALED_CTX_SWITCH_VOLATILE_MSK                 0x80000000 /* 31:31 */ 
#define NV_USCALED_CTX_SWITCH_VOLATILE_RMSK                0x00000001 /* 31:31 */ 
#define NV_USCALED_CTX_SWITCH_VOLATILE_WORD                0
#define NV_USCALED_CTX_SWITCH_VOLATILE_HIGH_FIELD          0x0000001F /* =31 */
#define NV_USCALED_CTX_SWITCH_VOLATILE_LOW_FIELD           0x0000001F /* =31 */
#define NV_USCALED_CTX_SWITCH_VOLATILE_IGNORE_ADJ          0x00000000
#define NV_USCALED_CTX_SWITCH_VOLATILE_RESET_ADJ           0x80000000
#define NV_USCALED_CTX_SWITCH_MSK                          0x807FFFFF 
#define NV_USCALED_NOP_PARAMETER_MSK                       0xFFFFFFFF /* 31:0 */ 
#define NV_USCALED_NOP_PARAMETER_RMSK                      0xFFFFFFFF /* 31:0 */ 
#define NV_USCALED_NOP_PARAMETER_WORD                      0
#define NV_USCALED_NOP_PARAMETER_HIGH_FIELD                0x0000001F /* =31 */
#define NV_USCALED_NOP_PARAMETER_LOW_FIELD                 0x00000000 /* =0 */
#define NV_USCALED_NOP_MSK                                 0xFFFFFFFF 
#define NV_USCALED_NOTIFY_STYLE_MSK                        0xFFFFFFFF /* 31:0 */ 
#define NV_USCALED_NOTIFY_STYLE_RMSK                       0xFFFFFFFF /* 31:0 */ 
#define NV_USCALED_NOTIFY_STYLE_WORD                       0
#define NV_USCALED_NOTIFY_STYLE_HIGH_FIELD                 0x0000001F /* =31 */
#define NV_USCALED_NOTIFY_STYLE_LOW_FIELD                  0x00000000 /* =0 */
#define NV_USCALED_NOTIFY_STYLE_WRITE_ONLY_ADJ             0x00000000
#define NV_USCALED_NOTIFY_STYLE_WRITE_THEN_AWAKEN_ADJ      0x00000001
#define NV_USCALED_NOTIFY_MSK                              0xFFFFFFFF 
#define NV_USCALED_SET_NOTIFY_PARAMETER_MSK                0xFFFFFFFF /* 31:0 */ 
#define NV_USCALED_SET_NOTIFY_PARAMETER_RMSK               0xFFFFFFFF /* 31:0 */ 
#define NV_USCALED_SET_NOTIFY_PARAMETER_WORD               0
#define NV_USCALED_SET_NOTIFY_PARAMETER_HIGH_FIELD         0x0000001F /* =31 */
#define NV_USCALED_SET_NOTIFY_PARAMETER_LOW_FIELD          0x00000000 /* =0 */
#define NV_USCALED_SET_NOTIFY_PARAMETER_WRITE_ADJ          0x00000000
#define NV_USCALED_SET_NOTIFY_MSK                          0xFFFFFFFF 
#define NV_USCALED_SET_PATCH_PARAMETER_MSK                 0xFFFFFFFF /* 31:0 */ 
#define NV_USCALED_SET_PATCH_PARAMETER_RMSK                0xFFFFFFFF /* 31:0 */ 
#define NV_USCALED_SET_PATCH_PARAMETER_WORD                0
#define NV_USCALED_SET_PATCH_PARAMETER_HIGH_FIELD          0x0000001F /* =31 */
#define NV_USCALED_SET_PATCH_PARAMETER_LOW_FIELD           0x00000000 /* =0 */
#define NV_USCALED_SET_PATCH_PARAMETER_INVALIDATE_ADJ      0x00000000
#define NV_USCALED_SET_PATCH_PARAMETER_VALIDATE_ADJ        0x00000001
#define NV_USCALED_SET_PATCH_MSK                           0xFFFFFFFF 
#define NV_USCALED_SET_CONTEXT_DMA_NOTIFY_PARAMETER_MSK    0xFFFFFFFF /* 31:0 */ 
#define NV_USCALED_SET_CONTEXT_DMA_NOTIFY_PARAMETER_RMSK   0xFFFFFFFF /* 31:0 */ 
#define NV_USCALED_SET_CONTEXT_DMA_NOTIFY_PARAMETER_WORD   0
#define NV_USCALED_SET_CONTEXT_DMA_NOTIFY_PARAMETER_HIGH_FIELD 0x0000001F /* =31 */
#define NV_USCALED_SET_CONTEXT_DMA_NOTIFY_PARAMETER_LOW_FIELD 0x00000000 /* =0 */
#define NV_USCALED_SET_CONTEXT_DMA_NOTIFY_MSK              0xFFFFFFFF 
#define NV_USCALED_SET_CONTEXT_DMA_IMAGE_PARAMETER_MSK     0xFFFFFFFF /* 31:0 */ 
#define NV_USCALED_SET_CONTEXT_DMA_IMAGE_PARAMETER_RMSK    0xFFFFFFFF /* 31:0 */ 
#define NV_USCALED_SET_CONTEXT_DMA_IMAGE_PARAMETER_WORD    0
#define NV_USCALED_SET_CONTEXT_DMA_IMAGE_PARAMETER_HIGH_FIELD 0x0000001F /* =31 */
#define NV_USCALED_SET_CONTEXT_DMA_IMAGE_PARAMETER_LOW_FIELD 0x00000000 /* =0 */
#define NV_USCALED_SET_CONTEXT_DMA_IMAGE_MSK               0xFFFFFFFF 
#define NV_USCALED_SET_IMAGE_OUTPUT_PARAMETER_MSK          0xFFFFFFFF /* 31:0 */ 
#define NV_USCALED_SET_IMAGE_OUTPUT_PARAMETER_RMSK         0xFFFFFFFF /* 31:0 */ 
#define NV_USCALED_SET_IMAGE_OUTPUT_PARAMETER_WORD         0
#define NV_USCALED_SET_IMAGE_OUTPUT_PARAMETER_HIGH_FIELD   0x0000001F /* =31 */
#define NV_USCALED_SET_IMAGE_OUTPUT_PARAMETER_LOW_FIELD    0x00000000 /* =0 */
#define NV_USCALED_SET_IMAGE_OUTPUT_MSK                    0xFFFFFFFF 
#define NV_USCALED_SET_COLOR_FORMAT_LE_MSK                 0xFFFFFFFF /* 31:0 */ 
#define NV_USCALED_SET_COLOR_FORMAT_LE_RMSK                0xFFFFFFFF /* 31:0 */ 
#define NV_USCALED_SET_COLOR_FORMAT_LE_WORD                0
#define NV_USCALED_SET_COLOR_FORMAT_LE_HIGH_FIELD          0x0000001F /* =31 */
#define NV_USCALED_SET_COLOR_FORMAT_LE_LOW_FIELD           0x00000000 /* =0 */
#define NV_USCALED_SET_COLOR_FORMAT_LE_A1R5G5B5_ADJ        0x00000001
#define NV_USCALED_SET_COLOR_FORMAT_LE_X1R5G5B5_ADJ        0x00000002
#define NV_USCALED_SET_COLOR_FORMAT_LE_A8R8G8B8_ADJ        0x00000003
#define NV_USCALED_SET_COLOR_FORMAT_LE_X8R8G8B8_ADJ        0x00000004
#define NV_USCALED_SET_COLOR_FORMAT_LE_V8YB8U8YA8_ADJ      0x00000005
#define NV_USCALED_SET_COLOR_FORMAT_LE_YB8V8YA8U8_ADJ      0x00000006
#define NV_USCALED_SET_COLOR_FORMAT_LE_R5G6B5_ADJ          0x00000007
#define NV_USCALED_SET_COLOR_FORMAT_MSK                    0xFFFFFFFF 
#define NV_USCALED_CLIP_0_X_MSK                            0x0000FFFF /* 15:0 */ 
#define NV_USCALED_CLIP_0_X_RMSK                           0x0000FFFF /* 15:0 */ 
#define NV_USCALED_CLIP_0_X_WORD                           0
#define NV_USCALED_CLIP_0_X_HIGH_FIELD                     0x0000000F /* =15 */
#define NV_USCALED_CLIP_0_X_LOW_FIELD                      0x00000000 /* =0 */
#define NV_USCALED_CLIP_0_Y_MSK                            0xFFFF0000 /* 31:16 */ 
#define NV_USCALED_CLIP_0_Y_RMSK                           0x0000FFFF /* 31:16 */ 
#define NV_USCALED_CLIP_0_Y_WORD                           0
#define NV_USCALED_CLIP_0_Y_HIGH_FIELD                     0x0000001F /* =31 */
#define NV_USCALED_CLIP_0_Y_LOW_FIELD                      0x00000010 /* =16 */
#define NV_USCALED_CLIP_0_MSK                              0xFFFFFFFF 
#define NV_USCALED_CLIP_1_WIDTH_MSK                        0x0000FFFF /* 15:0 */ 
#define NV_USCALED_CLIP_1_WIDTH_RMSK                       0x0000FFFF /* 15:0 */ 
#define NV_USCALED_CLIP_1_WIDTH_WORD                       0
#define NV_USCALED_CLIP_1_WIDTH_HIGH_FIELD                 0x0000000F /* =15 */
#define NV_USCALED_CLIP_1_WIDTH_LOW_FIELD                  0x00000000 /* =0 */
#define NV_USCALED_CLIP_1_HEIGHT_MSK                       0xFFFF0000 /* 31:16 */ 
#define NV_USCALED_CLIP_1_HEIGHT_RMSK                      0x0000FFFF /* 31:16 */ 
#define NV_USCALED_CLIP_1_HEIGHT_WORD                      0
#define NV_USCALED_CLIP_1_HEIGHT_HIGH_FIELD                0x0000001F /* =31 */
#define NV_USCALED_CLIP_1_HEIGHT_LOW_FIELD                 0x00000010 /* =16 */
#define NV_USCALED_CLIP_1_MSK                              0xFFFFFFFF 
#define NV_USCALED_RECTANGLE_OUT_0_X_MSK                   0x0000FFFF /* 15:0 */ 
#define NV_USCALED_RECTANGLE_OUT_0_X_RMSK                  0x0000FFFF /* 15:0 */ 
#define NV_USCALED_RECTANGLE_OUT_0_X_WORD                  0
#define NV_USCALED_RECTANGLE_OUT_0_X_HIGH_FIELD            0x0000000F /* =15 */
#define NV_USCALED_RECTANGLE_OUT_0_X_LOW_FIELD             0x00000000 /* =0 */
#define NV_USCALED_RECTANGLE_OUT_0_Y_MSK                   0xFFFF0000 /* 31:16 */ 
#define NV_USCALED_RECTANGLE_OUT_0_Y_RMSK                  0x0000FFFF /* 31:16 */ 
#define NV_USCALED_RECTANGLE_OUT_0_Y_WORD                  0
#define NV_USCALED_RECTANGLE_OUT_0_Y_HIGH_FIELD            0x0000001F /* =31 */
#define NV_USCALED_RECTANGLE_OUT_0_Y_LOW_FIELD             0x00000010 /* =16 */
#define NV_USCALED_RECTANGLE_OUT_0_MSK                     0xFFFFFFFF 
#define NV_USCALED_RECTANGLE_OUT_1_WIDTH_MSK               0x0000FFFF /* 15:0 */ 
#define NV_USCALED_RECTANGLE_OUT_1_WIDTH_RMSK              0x0000FFFF /* 15:0 */ 
#define NV_USCALED_RECTANGLE_OUT_1_WIDTH_WORD              0
#define NV_USCALED_RECTANGLE_OUT_1_WIDTH_HIGH_FIELD        0x0000000F /* =15 */
#define NV_USCALED_RECTANGLE_OUT_1_WIDTH_LOW_FIELD         0x00000000 /* =0 */
#define NV_USCALED_RECTANGLE_OUT_1_HEIGHT_MSK              0xFFFF0000 /* 31:16 */ 
#define NV_USCALED_RECTANGLE_OUT_1_HEIGHT_RMSK             0x0000FFFF /* 31:16 */ 
#define NV_USCALED_RECTANGLE_OUT_1_HEIGHT_WORD             0
#define NV_USCALED_RECTANGLE_OUT_1_HEIGHT_HIGH_FIELD       0x0000001F /* =31 */
#define NV_USCALED_RECTANGLE_OUT_1_HEIGHT_LOW_FIELD        0x00000010 /* =16 */
#define NV_USCALED_RECTANGLE_OUT_1_MSK                     0xFFFFFFFF 
#define NV_USCALED_DELTA_DU_DX_R_FRACTION_MSK              0x000FFFFF /* 19:0 */ 
#define NV_USCALED_DELTA_DU_DX_R_FRACTION_RMSK             0x000FFFFF /* 19:0 */ 
#define NV_USCALED_DELTA_DU_DX_R_FRACTION_WORD             0
#define NV_USCALED_DELTA_DU_DX_R_FRACTION_HIGH_FIELD       0x00000013 /* =19 */
#define NV_USCALED_DELTA_DU_DX_R_FRACTION_LOW_FIELD        0x00000000 /* =0 */
#define NV_USCALED_DELTA_DU_DX_R_INT_MSK                   0xFFF00000 /* 31:20 */ 
#define NV_USCALED_DELTA_DU_DX_R_INT_RMSK                  0x00000FFF /* 31:20 */ 
#define NV_USCALED_DELTA_DU_DX_R_INT_WORD                  0
#define NV_USCALED_DELTA_DU_DX_R_INT_HIGH_FIELD            0x0000001F /* =31 */
#define NV_USCALED_DELTA_DU_DX_R_INT_LOW_FIELD             0x00000014 /* =20 */
#define NV_USCALED_DELTA_DU_DX_R_MSK                       0xFFFFFFFF /* 31:0 */ 
#define NV_USCALED_DELTA_DU_DX_R_RMSK                      0xFFFFFFFF /* 31:0 */ 
#define NV_USCALED_DELTA_DU_DX_R_WORD                      0
#define NV_USCALED_DELTA_DU_DX_R_HIGH_FIELD                0x0000001F /* =31 */
#define NV_USCALED_DELTA_DU_DX_R_LOW_FIELD                 0x00000000 /* =0 */
#define NV_USCALED_DELTA_DU_DX_MSK                         0xFFFFFFFF 
#define NV_USCALED_DELTA_DV_DY_R_FRACTION_MSK              0x000FFFFF /* 19:0 */ 
#define NV_USCALED_DELTA_DV_DY_R_FRACTION_RMSK             0x000FFFFF /* 19:0 */ 
#define NV_USCALED_DELTA_DV_DY_R_FRACTION_WORD             0
#define NV_USCALED_DELTA_DV_DY_R_FRACTION_HIGH_FIELD       0x00000013 /* =19 */
#define NV_USCALED_DELTA_DV_DY_R_FRACTION_LOW_FIELD        0x00000000 /* =0 */
#define NV_USCALED_DELTA_DV_DY_R_INT_MSK                   0xFFF00000 /* 31:20 */ 
#define NV_USCALED_DELTA_DV_DY_R_INT_RMSK                  0x00000FFF /* 31:20 */ 
#define NV_USCALED_DELTA_DV_DY_R_INT_WORD                  0
#define NV_USCALED_DELTA_DV_DY_R_INT_HIGH_FIELD            0x0000001F /* =31 */
#define NV_USCALED_DELTA_DV_DY_R_INT_LOW_FIELD             0x00000014 /* =20 */
#define NV_USCALED_DELTA_DV_DY_R_MSK                       0xFFFFFFFF /* 31:0 */ 
#define NV_USCALED_DELTA_DV_DY_R_RMSK                      0xFFFFFFFF /* 31:0 */ 
#define NV_USCALED_DELTA_DV_DY_R_WORD                      0
#define NV_USCALED_DELTA_DV_DY_R_HIGH_FIELD                0x0000001F /* =31 */
#define NV_USCALED_DELTA_DV_DY_R_LOW_FIELD                 0x00000000 /* =0 */
#define NV_USCALED_DELTA_DV_DY_MSK                         0xFFFFFFFF 
#define NV_USCALED_SIZE_WIDTH_MSK                          0x0000FFFF /* 15:0 */ 
#define NV_USCALED_SIZE_WIDTH_RMSK                         0x0000FFFF /* 15:0 */ 
#define NV_USCALED_SIZE_WIDTH_WORD                         0
#define NV_USCALED_SIZE_WIDTH_HIGH_FIELD                   0x0000000F /* =15 */
#define NV_USCALED_SIZE_WIDTH_LOW_FIELD                    0x00000000 /* =0 */
#define NV_USCALED_SIZE_HEIGHT_MSK                         0xFFFF0000 /* 31:16 */ 
#define NV_USCALED_SIZE_HEIGHT_RMSK                        0x0000FFFF /* 31:16 */ 
#define NV_USCALED_SIZE_HEIGHT_WORD                        0
#define NV_USCALED_SIZE_HEIGHT_HIGH_FIELD                  0x0000001F /* =31 */
#define NV_USCALED_SIZE_HEIGHT_LOW_FIELD                   0x00000010 /* =16 */
#define NV_USCALED_SIZE_MSK                                0xFFFFFFFF 
#define NV_USCALED_FORMAT_PITCH_MSK                        0x0000FFFF /* 15:0 */ 
#define NV_USCALED_FORMAT_PITCH_RMSK                       0x0000FFFF /* 15:0 */ 
#define NV_USCALED_FORMAT_PITCH_WORD                       0
#define NV_USCALED_FORMAT_PITCH_HIGH_FIELD                 0x0000000F /* =15 */
#define NV_USCALED_FORMAT_PITCH_LOW_FIELD                  0x00000000 /* =0 */
#define NV_USCALED_FORMAT_ORIGIN_MSK                       0x00FF0000 /* 23:16 */ 
#define NV_USCALED_FORMAT_ORIGIN_RMSK                      0x000000FF /* 23:16 */ 
#define NV_USCALED_FORMAT_ORIGIN_WORD                      0
#define NV_USCALED_FORMAT_ORIGIN_HIGH_FIELD                0x00000017 /* =23 */
#define NV_USCALED_FORMAT_ORIGIN_LOW_FIELD                 0x00000010 /* =16 */
#define NV_USCALED_FORMAT_ORIGIN_CENTER_ADJ                0x00010000
#define NV_USCALED_FORMAT_ORIGIN_CORNER_ADJ                0x00020000
#define NV_USCALED_FORMAT_INTERPOLATOR_MSK                 0xFF000000 /* 31:24 */ 
#define NV_USCALED_FORMAT_INTERPOLATOR_RMSK                0x000000FF /* 31:24 */ 
#define NV_USCALED_FORMAT_INTERPOLATOR_WORD                0
#define NV_USCALED_FORMAT_INTERPOLATOR_HIGH_FIELD          0x0000001F /* =31 */
#define NV_USCALED_FORMAT_INTERPOLATOR_LOW_FIELD           0x00000018 /* =24 */
#define NV_USCALED_FORMAT_INTERPOLATOR_ZOH_ADJ             0x00000000
#define NV_USCALED_FORMAT_INTERPOLATOR_FOH_ADJ             0x01000000
#define NV_USCALED_FORMAT_MSK                              0xFFFFFFFF 
#define NV_USCALED_OFFSET_VALUE_MSK                        0xFFFFFFFF /* 31:0 */ 
#define NV_USCALED_OFFSET_VALUE_RMSK                       0xFFFFFFFF /* 31:0 */ 
#define NV_USCALED_OFFSET_VALUE_WORD                       0
#define NV_USCALED_OFFSET_VALUE_HIGH_FIELD                 0x0000001F /* =31 */
#define NV_USCALED_OFFSET_VALUE_LOW_FIELD                  0x00000000 /* =0 */
#define NV_USCALED_OFFSET_MSK                              0xFFFFFFFF 
#define NV_USCALED_POINT_V_FRACTION_MSK                    0x00000FFF /* 11:0 */ 
#define NV_USCALED_POINT_V_FRACTION_RMSK                   0x00000FFF /* 11:0 */ 
#define NV_USCALED_POINT_V_FRACTION_WORD                   0
#define NV_USCALED_POINT_V_FRACTION_HIGH_FIELD             0x0000000B /* =11 */
#define NV_USCALED_POINT_V_FRACTION_LOW_FIELD              0x00000000 /* =0 */
#define NV_USCALED_POINT_V_INT_MSK                         0x0000F000 /* 15:12 */ 
#define NV_USCALED_POINT_V_INT_RMSK                        0x0000000F /* 15:12 */ 
#define NV_USCALED_POINT_V_INT_WORD                        0
#define NV_USCALED_POINT_V_INT_HIGH_FIELD                  0x0000000F /* =15 */
#define NV_USCALED_POINT_V_INT_LOW_FIELD                   0x0000000C /* =12 */
#define NV_USCALED_POINT_V_VALUE_MSK                       0x0000FFFF /* 15:0 */ 
#define NV_USCALED_POINT_V_VALUE_RMSK                      0x0000FFFF /* 15:0 */ 
#define NV_USCALED_POINT_V_VALUE_WORD                      0
#define NV_USCALED_POINT_V_VALUE_HIGH_FIELD                0x0000000F /* =15 */
#define NV_USCALED_POINT_V_VALUE_LOW_FIELD                 0x00000000 /* =0 */
#define NV_USCALED_POINT_U_FRACTION_MSK                    0x000F0000 /* 19:16 */ 
#define NV_USCALED_POINT_U_FRACTION_RMSK                   0x0000000F /* 19:16 */ 
#define NV_USCALED_POINT_U_FRACTION_WORD                   0
#define NV_USCALED_POINT_U_FRACTION_HIGH_FIELD             0x00000013 /* =19 */
#define NV_USCALED_POINT_U_FRACTION_LOW_FIELD              0x00000010 /* =16 */
#define NV_USCALED_POINT_U_INT_MSK                         0xFFF00000 /* 31:20 */ 
#define NV_USCALED_POINT_U_INT_RMSK                        0x00000FFF /* 31:20 */ 
#define NV_USCALED_POINT_U_INT_WORD                        0
#define NV_USCALED_POINT_U_INT_HIGH_FIELD                  0x0000001F /* =31 */
#define NV_USCALED_POINT_U_INT_LOW_FIELD                   0x00000014 /* =20 */
#define NV_USCALED_POINT_U_VALUE_MSK                       0xFFFFFFFF /* 31:0 */ 
#define NV_USCALED_POINT_U_VALUE_RMSK                      0xFFFFFFFF /* 31:0 */ 
#define NV_USCALED_POINT_U_VALUE_WORD                      0
#define NV_USCALED_POINT_U_VALUE_HIGH_FIELD                0x0000001F /* =31 */
#define NV_USCALED_POINT_U_VALUE_LOW_FIELD                 0x00000000 /* =0 */
#define NV_USCALED_POINT_MSK                               0xFFFFFFFF 
#define NV_063_HIGH_FIELD                                  0x00641FFF /* =6561791 */
#define NV_063_LOW_FIELD                                   0x00640000 /* =6553600 */
#define NV_063_NV5_SCALED_IMAGE_FROM_MEMORY_ADJ            0x00640000
#define NV_063_NV5_SCALED_IMAGE_FROM_MEMORY_HANDLE_MSK     0xFFFFFFFF /* 31:0 */ 
#define NV_063_NV5_SCALED_IMAGE_FROM_MEMORY_HANDLE_RMSK    0xFFFFFFFF /* 31:0 */ 
#define NV_063_NV5_SCALED_IMAGE_FROM_MEMORY_HANDLE_WORD    0
#define NV_063_NV5_SCALED_IMAGE_FROM_MEMORY_HANDLE_HIGH_FIELD 0x0000001F /* =31 */
#define NV_063_NV5_SCALED_IMAGE_FROM_MEMORY_HANDLE_LOW_FIELD 0x00000000 /* =0 */
#define NV_063_NV5_SCALED_IMAGE_FROM_MEMORY_MSK            0xFFFFFFFF 
#define NV_063_NOP_PARAMETER_MSK                           0xFFFFFFFF /* 31:0 */ 
#define NV_063_NOP_PARAMETER_RMSK                          0xFFFFFFFF /* 31:0 */ 
#define NV_063_NOP_PARAMETER_WORD                          0
#define NV_063_NOP_PARAMETER_HIGH_FIELD                    0x0000001F /* =31 */
#define NV_063_NOP_PARAMETER_LOW_FIELD                     0x00000000 /* =0 */
#define NV_063_NOP_MSK                                     0xFFFFFFFF 
#define NV_063_NOTIFY_STYLE_MSK                            0xFFFFFFFF /* 31:0 */ 
#define NV_063_NOTIFY_STYLE_RMSK                           0xFFFFFFFF /* 31:0 */ 
#define NV_063_NOTIFY_STYLE_WORD                           0
#define NV_063_NOTIFY_STYLE_HIGH_FIELD                     0x0000001F /* =31 */
#define NV_063_NOTIFY_STYLE_LOW_FIELD                      0x00000000 /* =0 */
#define NV_063_NOTIFY_STYLE_WRITE_ONLY_ADJ                 0x00000000
#define NV_063_NOTIFY_STYLE_WRITE_THEN_AWAKEN_ADJ          0x00000001
#define NV_063_NOTIFY_MSK                                  0xFFFFFFFF 
#define NV_063_SET_NOTIFY_PARAMETER_MSK                    0xFFFFFFFF /* 31:0 */ 
#define NV_063_SET_NOTIFY_PARAMETER_RMSK                   0xFFFFFFFF /* 31:0 */ 
#define NV_063_SET_NOTIFY_PARAMETER_WORD                   0
#define NV_063_SET_NOTIFY_PARAMETER_HIGH_FIELD             0x0000001F /* =31 */
#define NV_063_SET_NOTIFY_PARAMETER_LOW_FIELD              0x00000000 /* =0 */
#define NV_063_SET_NOTIFY_PARAMETER_WRITE_ADJ              0x00000000
#define NV_063_SET_NOTIFY_MSK                              0xFFFFFFFF 
#define NV_063_SET_CONTEXT_DMA_NOTIFY_PARAMETER_MSK        0xFFFFFFFF /* 31:0 */ 
#define NV_063_SET_CONTEXT_DMA_NOTIFY_PARAMETER_RMSK       0xFFFFFFFF /* 31:0 */ 
#define NV_063_SET_CONTEXT_DMA_NOTIFY_PARAMETER_WORD       0
#define NV_063_SET_CONTEXT_DMA_NOTIFY_PARAMETER_HIGH_FIELD 0x0000001F /* =31 */
#define NV_063_SET_CONTEXT_DMA_NOTIFY_PARAMETER_LOW_FIELD  0x00000000 /* =0 */
#define NV_063_SET_CONTEXT_DMA_NOTIFY_MSK                  0xFFFFFFFF 
#define NV_063_SET_CONTEXT_DMA_IMAGE_PARAMETER_MSK         0xFFFFFFFF /* 31:0 */ 
#define NV_063_SET_CONTEXT_DMA_IMAGE_PARAMETER_RMSK        0xFFFFFFFF /* 31:0 */ 
#define NV_063_SET_CONTEXT_DMA_IMAGE_PARAMETER_WORD        0
#define NV_063_SET_CONTEXT_DMA_IMAGE_PARAMETER_HIGH_FIELD  0x0000001F /* =31 */
#define NV_063_SET_CONTEXT_DMA_IMAGE_PARAMETER_LOW_FIELD   0x00000000 /* =0 */
#define NV_063_SET_CONTEXT_DMA_IMAGE_MSK                   0xFFFFFFFF 
#define NV_063_SET_CONTEXT_PATTERN_PARAMETER_MSK           0xFFFFFFFF /* 31:0 */ 
#define NV_063_SET_CONTEXT_PATTERN_PARAMETER_RMSK          0xFFFFFFFF /* 31:0 */ 
#define NV_063_SET_CONTEXT_PATTERN_PARAMETER_WORD          0
#define NV_063_SET_CONTEXT_PATTERN_PARAMETER_HIGH_FIELD    0x0000001F /* =31 */
#define NV_063_SET_CONTEXT_PATTERN_PARAMETER_LOW_FIELD     0x00000000 /* =0 */
#define NV_063_SET_CONTEXT_PATTERN_MSK                     0xFFFFFFFF 
#define NV_063_SET_CONTEXT_ROP_PARAMETER_MSK               0xFFFFFFFF /* 31:0 */ 
#define NV_063_SET_CONTEXT_ROP_PARAMETER_RMSK              0xFFFFFFFF /* 31:0 */ 
#define NV_063_SET_CONTEXT_ROP_PARAMETER_WORD              0
#define NV_063_SET_CONTEXT_ROP_PARAMETER_HIGH_FIELD        0x0000001F /* =31 */
#define NV_063_SET_CONTEXT_ROP_PARAMETER_LOW_FIELD         0x00000000 /* =0 */
#define NV_063_SET_CONTEXT_ROP_MSK                         0xFFFFFFFF 
#define NV_063_SET_CONTEXT_BETA1_PARAMETER_MSK             0xFFFFFFFF /* 31:0 */ 
#define NV_063_SET_CONTEXT_BETA1_PARAMETER_RMSK            0xFFFFFFFF /* 31:0 */ 
#define NV_063_SET_CONTEXT_BETA1_PARAMETER_WORD            0
#define NV_063_SET_CONTEXT_BETA1_PARAMETER_HIGH_FIELD      0x0000001F /* =31 */
#define NV_063_SET_CONTEXT_BETA1_PARAMETER_LOW_FIELD       0x00000000 /* =0 */
#define NV_063_SET_CONTEXT_BETA1_MSK                       0xFFFFFFFF 
#define NV_063_SET_CONTEXT_BETA4_PARAMETER_MSK             0xFFFFFFFF /* 31:0 */ 
#define NV_063_SET_CONTEXT_BETA4_PARAMETER_RMSK            0xFFFFFFFF /* 31:0 */ 
#define NV_063_SET_CONTEXT_BETA4_PARAMETER_WORD            0
#define NV_063_SET_CONTEXT_BETA4_PARAMETER_HIGH_FIELD      0x0000001F /* =31 */
#define NV_063_SET_CONTEXT_BETA4_PARAMETER_LOW_FIELD       0x00000000 /* =0 */
#define NV_063_SET_CONTEXT_BETA4_MSK                       0xFFFFFFFF 
#define NV_063_SET_CONTEXT_SURFACE_PARAMETER_MSK           0xFFFFFFFF /* 31:0 */ 
#define NV_063_SET_CONTEXT_SURFACE_PARAMETER_RMSK          0xFFFFFFFF /* 31:0 */ 
#define NV_063_SET_CONTEXT_SURFACE_PARAMETER_WORD          0
#define NV_063_SET_CONTEXT_SURFACE_PARAMETER_HIGH_FIELD    0x0000001F /* =31 */
#define NV_063_SET_CONTEXT_SURFACE_PARAMETER_LOW_FIELD     0x00000000 /* =0 */
#define NV_063_SET_CONTEXT_SURFACE_MSK                     0xFFFFFFFF 
#define NV_063_SET_COLOR_CONVERSION_TYPE_MSK               0xFFFFFFFF /* 31:0 */ 
#define NV_063_SET_COLOR_CONVERSION_TYPE_RMSK              0xFFFFFFFF /* 31:0 */ 
#define NV_063_SET_COLOR_CONVERSION_TYPE_WORD              0
#define NV_063_SET_COLOR_CONVERSION_TYPE_HIGH_FIELD        0x0000001F /* =31 */
#define NV_063_SET_COLOR_CONVERSION_TYPE_LOW_FIELD         0x00000000 /* =0 */
#define NV_063_SET_COLOR_CONVERSION_TYPE_DITHER_ADJ        0x00000000
#define NV_063_SET_COLOR_CONVERSION_TYPE_TRUNCATE_ADJ      0x00000001
#define NV_063_SET_COLOR_CONVERSION_TYPE_SUBTR_TRUNCATE_ADJ 0x00000002
#define NV_063_SET_COLOR_CONVERSION_MSK                    0xFFFFFFFF 
#define NV_063_SET_COLOR_FORMAT_LE_MSK                     0xFFFFFFFF /* 31:0 */ 
#define NV_063_SET_COLOR_FORMAT_LE_RMSK                    0xFFFFFFFF /* 31:0 */ 
#define NV_063_SET_COLOR_FORMAT_LE_WORD                    0
#define NV_063_SET_COLOR_FORMAT_LE_HIGH_FIELD              0x0000001F /* =31 */
#define NV_063_SET_COLOR_FORMAT_LE_LOW_FIELD               0x00000000 /* =0 */
#define NV_063_SET_COLOR_FORMAT_LE_A1R5G5B5_ADJ            0x00000001
#define NV_063_SET_COLOR_FORMAT_LE_X1R5G5B5_ADJ            0x00000002
#define NV_063_SET_COLOR_FORMAT_LE_A8R8G8B8_ADJ            0x00000003
#define NV_063_SET_COLOR_FORMAT_LE_X8R8G8B8_ADJ            0x00000004
#define NV_063_SET_COLOR_FORMAT_LE_V8YB8U8YA8_ADJ          0x00000005
#define NV_063_SET_COLOR_FORMAT_LE_YB8V8YA8U8_ADJ          0x00000006
#define NV_063_SET_COLOR_FORMAT_LE_R5G6B5_ADJ              0x00000007
#define NV_063_SET_COLOR_FORMAT_MSK                        0xFFFFFFFF 
#define NV_063_SET_OPERATION_MODE_MSK                      0xFFFFFFFF /* 31:0 */ 
#define NV_063_SET_OPERATION_MODE_RMSK                     0xFFFFFFFF /* 31:0 */ 
#define NV_063_SET_OPERATION_MODE_WORD                     0
#define NV_063_SET_OPERATION_MODE_HIGH_FIELD               0x0000001F /* =31 */
#define NV_063_SET_OPERATION_MODE_LOW_FIELD                0x00000000 /* =0 */
#define NV_063_SET_OPERATION_MODE_SRCCOPY_AND_ADJ          0x00000000
#define NV_063_SET_OPERATION_MODE_ROP_AND_ADJ              0x00000001
#define NV_063_SET_OPERATION_MODE_BLEND_AND_ADJ            0x00000002
#define NV_063_SET_OPERATION_MODE_SRCCOPY_ADJ              0x00000003
#define NV_063_SET_OPERATION_MODE_SRCCOPY_PREMULT_ADJ      0x00000004
#define NV_063_SET_OPERATION_MODE_BLEND_PREMULT_ADJ        0x00000005
#define NV_063_SET_OPERATION_MSK                           0xFFFFFFFF 
#define NV_063_CLIP_0_X_MSK                                0x0000FFFF /* 15:0 */ 
#define NV_063_CLIP_0_X_RMSK                               0x0000FFFF /* 15:0 */ 
#define NV_063_CLIP_0_X_WORD                               0
#define NV_063_CLIP_0_X_HIGH_FIELD                         0x0000000F /* =15 */
#define NV_063_CLIP_0_X_LOW_FIELD                          0x00000000 /* =0 */
#define NV_063_CLIP_0_Y_MSK                                0xFFFF0000 /* 31:16 */ 
#define NV_063_CLIP_0_Y_RMSK                               0x0000FFFF /* 31:16 */ 
#define NV_063_CLIP_0_Y_WORD                               0
#define NV_063_CLIP_0_Y_HIGH_FIELD                         0x0000001F /* =31 */
#define NV_063_CLIP_0_Y_LOW_FIELD                          0x00000010 /* =16 */
#define NV_063_CLIP_0_MSK                                  0xFFFFFFFF 
#define NV_063_CLIP_1_WIDTH_MSK                            0x0000FFFF /* 15:0 */ 
#define NV_063_CLIP_1_WIDTH_RMSK                           0x0000FFFF /* 15:0 */ 
#define NV_063_CLIP_1_WIDTH_WORD                           0
#define NV_063_CLIP_1_WIDTH_HIGH_FIELD                     0x0000000F /* =15 */
#define NV_063_CLIP_1_WIDTH_LOW_FIELD                      0x00000000 /* =0 */
#define NV_063_CLIP_1_HEIGHT_MSK                           0xFFFF0000 /* 31:16 */ 
#define NV_063_CLIP_1_HEIGHT_RMSK                          0x0000FFFF /* 31:16 */ 
#define NV_063_CLIP_1_HEIGHT_WORD                          0
#define NV_063_CLIP_1_HEIGHT_HIGH_FIELD                    0x0000001F /* =31 */
#define NV_063_CLIP_1_HEIGHT_LOW_FIELD                     0x00000010 /* =16 */
#define NV_063_CLIP_1_MSK                                  0xFFFFFFFF 
#define NV_063_RECTANGLE_OUT_0_X_MSK                       0x0000FFFF /* 15:0 */ 
#define NV_063_RECTANGLE_OUT_0_X_RMSK                      0x0000FFFF /* 15:0 */ 
#define NV_063_RECTANGLE_OUT_0_X_WORD                      0
#define NV_063_RECTANGLE_OUT_0_X_HIGH_FIELD                0x0000000F /* =15 */
#define NV_063_RECTANGLE_OUT_0_X_LOW_FIELD                 0x00000000 /* =0 */
#define NV_063_RECTANGLE_OUT_0_Y_MSK                       0xFFFF0000 /* 31:16 */ 
#define NV_063_RECTANGLE_OUT_0_Y_RMSK                      0x0000FFFF /* 31:16 */ 
#define NV_063_RECTANGLE_OUT_0_Y_WORD                      0
#define NV_063_RECTANGLE_OUT_0_Y_HIGH_FIELD                0x0000001F /* =31 */
#define NV_063_RECTANGLE_OUT_0_Y_LOW_FIELD                 0x00000010 /* =16 */
#define NV_063_RECTANGLE_OUT_0_MSK                         0xFFFFFFFF 
#define NV_063_RECTANGLE_OUT_1_WIDTH_MSK                   0x0000FFFF /* 15:0 */ 
#define NV_063_RECTANGLE_OUT_1_WIDTH_RMSK                  0x0000FFFF /* 15:0 */ 
#define NV_063_RECTANGLE_OUT_1_WIDTH_WORD                  0
#define NV_063_RECTANGLE_OUT_1_WIDTH_HIGH_FIELD            0x0000000F /* =15 */
#define NV_063_RECTANGLE_OUT_1_WIDTH_LOW_FIELD             0x00000000 /* =0 */
#define NV_063_RECTANGLE_OUT_1_HEIGHT_MSK                  0xFFFF0000 /* 31:16 */ 
#define NV_063_RECTANGLE_OUT_1_HEIGHT_RMSK                 0x0000FFFF /* 31:16 */ 
#define NV_063_RECTANGLE_OUT_1_HEIGHT_WORD                 0
#define NV_063_RECTANGLE_OUT_1_HEIGHT_HIGH_FIELD           0x0000001F /* =31 */
#define NV_063_RECTANGLE_OUT_1_HEIGHT_LOW_FIELD            0x00000010 /* =16 */
#define NV_063_RECTANGLE_OUT_1_MSK                         0xFFFFFFFF 
#define NV_063_DELTA_DU_DX_R_FRACTION_MSK                  0x000FFFFF /* 19:0 */ 
#define NV_063_DELTA_DU_DX_R_FRACTION_RMSK                 0x000FFFFF /* 19:0 */ 
#define NV_063_DELTA_DU_DX_R_FRACTION_WORD                 0
#define NV_063_DELTA_DU_DX_R_FRACTION_HIGH_FIELD           0x00000013 /* =19 */
#define NV_063_DELTA_DU_DX_R_FRACTION_LOW_FIELD            0x00000000 /* =0 */
#define NV_063_DELTA_DU_DX_R_INT_MSK                       0xFFF00000 /* 31:20 */ 
#define NV_063_DELTA_DU_DX_R_INT_RMSK                      0x00000FFF /* 31:20 */ 
#define NV_063_DELTA_DU_DX_R_INT_WORD                      0
#define NV_063_DELTA_DU_DX_R_INT_HIGH_FIELD                0x0000001F /* =31 */
#define NV_063_DELTA_DU_DX_R_INT_LOW_FIELD                 0x00000014 /* =20 */
#define NV_063_DELTA_DU_DX_R_MSK                           0xFFFFFFFF /* 31:0 */ 
#define NV_063_DELTA_DU_DX_R_RMSK                          0xFFFFFFFF /* 31:0 */ 
#define NV_063_DELTA_DU_DX_R_WORD                          0
#define NV_063_DELTA_DU_DX_R_HIGH_FIELD                    0x0000001F /* =31 */
#define NV_063_DELTA_DU_DX_R_LOW_FIELD                     0x00000000 /* =0 */
#define NV_063_DELTA_DU_DX_MSK                             0xFFFFFFFF 
#define NV_063_DELTA_DV_DY_R_FRACTION_MSK                  0x000FFFFF /* 19:0 */ 
#define NV_063_DELTA_DV_DY_R_FRACTION_RMSK                 0x000FFFFF /* 19:0 */ 
#define NV_063_DELTA_DV_DY_R_FRACTION_WORD                 0
#define NV_063_DELTA_DV_DY_R_FRACTION_HIGH_FIELD           0x00000013 /* =19 */
#define NV_063_DELTA_DV_DY_R_FRACTION_LOW_FIELD            0x00000000 /* =0 */
#define NV_063_DELTA_DV_DY_R_INT_MSK                       0xFFF00000 /* 31:20 */ 
#define NV_063_DELTA_DV_DY_R_INT_RMSK                      0x00000FFF /* 31:20 */ 
#define NV_063_DELTA_DV_DY_R_INT_WORD                      0
#define NV_063_DELTA_DV_DY_R_INT_HIGH_FIELD                0x0000001F /* =31 */
#define NV_063_DELTA_DV_DY_R_INT_LOW_FIELD                 0x00000014 /* =20 */
#define NV_063_DELTA_DV_DY_R_MSK                           0xFFFFFFFF /* 31:0 */ 
#define NV_063_DELTA_DV_DY_R_RMSK                          0xFFFFFFFF /* 31:0 */ 
#define NV_063_DELTA_DV_DY_R_WORD                          0
#define NV_063_DELTA_DV_DY_R_HIGH_FIELD                    0x0000001F /* =31 */
#define NV_063_DELTA_DV_DY_R_LOW_FIELD                     0x00000000 /* =0 */
#define NV_063_DELTA_DV_DY_MSK                             0xFFFFFFFF 
#define NV_063_SIZE_WIDTH_MSK                              0x0000FFFF /* 15:0 */ 
#define NV_063_SIZE_WIDTH_RMSK                             0x0000FFFF /* 15:0 */ 
#define NV_063_SIZE_WIDTH_WORD                             0
#define NV_063_SIZE_WIDTH_HIGH_FIELD                       0x0000000F /* =15 */
#define NV_063_SIZE_WIDTH_LOW_FIELD                        0x00000000 /* =0 */
#define NV_063_SIZE_HEIGHT_MSK                             0xFFFF0000 /* 31:16 */ 
#define NV_063_SIZE_HEIGHT_RMSK                            0x0000FFFF /* 31:16 */ 
#define NV_063_SIZE_HEIGHT_WORD                            0
#define NV_063_SIZE_HEIGHT_HIGH_FIELD                      0x0000001F /* =31 */
#define NV_063_SIZE_HEIGHT_LOW_FIELD                       0x00000010 /* =16 */
#define NV_063_SIZE_MSK                                    0xFFFFFFFF 
#define NV_063_FORMAT_PITCH_MSK                            0x0000FFFF /* 15:0 */ 
#define NV_063_FORMAT_PITCH_RMSK                           0x0000FFFF /* 15:0 */ 
#define NV_063_FORMAT_PITCH_WORD                           0
#define NV_063_FORMAT_PITCH_HIGH_FIELD                     0x0000000F /* =15 */
#define NV_063_FORMAT_PITCH_LOW_FIELD                      0x00000000 /* =0 */
#define NV_063_FORMAT_ORIGIN_MSK                           0x00FF0000 /* 23:16 */ 
#define NV_063_FORMAT_ORIGIN_RMSK                          0x000000FF /* 23:16 */ 
#define NV_063_FORMAT_ORIGIN_WORD                          0
#define NV_063_FORMAT_ORIGIN_HIGH_FIELD                    0x00000017 /* =23 */
#define NV_063_FORMAT_ORIGIN_LOW_FIELD                     0x00000010 /* =16 */
#define NV_063_FORMAT_ORIGIN_CENTER_ADJ                    0x00010000
#define NV_063_FORMAT_ORIGIN_CORNER_ADJ                    0x00020000
#define NV_063_FORMAT_INTERPOLATOR_MSK                     0xFF000000 /* 31:24 */ 
#define NV_063_FORMAT_INTERPOLATOR_RMSK                    0x000000FF /* 31:24 */ 
#define NV_063_FORMAT_INTERPOLATOR_WORD                    0
#define NV_063_FORMAT_INTERPOLATOR_HIGH_FIELD              0x0000001F /* =31 */
#define NV_063_FORMAT_INTERPOLATOR_LOW_FIELD               0x00000018 /* =24 */
#define NV_063_FORMAT_INTERPOLATOR_ZOH_ADJ                 0x00000000
#define NV_063_FORMAT_INTERPOLATOR_FOH_ADJ                 0x01000000
#define NV_063_FORMAT_MSK                                  0xFFFFFFFF 
#define NV_063_OFFSET_VALUE_MSK                            0xFFFFFFFF /* 31:0 */ 
#define NV_063_OFFSET_VALUE_RMSK                           0xFFFFFFFF /* 31:0 */ 
#define NV_063_OFFSET_VALUE_WORD                           0
#define NV_063_OFFSET_VALUE_HIGH_FIELD                     0x0000001F /* =31 */
#define NV_063_OFFSET_VALUE_LOW_FIELD                      0x00000000 /* =0 */
#define NV_063_OFFSET_MSK                                  0xFFFFFFFF 
#define NV_063_POINT_V_FRACTION_MSK                        0x00000FFF /* 11:0 */ 
#define NV_063_POINT_V_FRACTION_RMSK                       0x00000FFF /* 11:0 */ 
#define NV_063_POINT_V_FRACTION_WORD                       0
#define NV_063_POINT_V_FRACTION_HIGH_FIELD                 0x0000000B /* =11 */
#define NV_063_POINT_V_FRACTION_LOW_FIELD                  0x00000000 /* =0 */
#define NV_063_POINT_V_INT_MSK                             0x0000F000 /* 15:12 */ 
#define NV_063_POINT_V_INT_RMSK                            0x0000000F /* 15:12 */ 
#define NV_063_POINT_V_INT_WORD                            0
#define NV_063_POINT_V_INT_HIGH_FIELD                      0x0000000F /* =15 */
#define NV_063_POINT_V_INT_LOW_FIELD                       0x0000000C /* =12 */
#define NV_063_POINT_V_VALUE_MSK                           0x0000FFFF /* 15:0 */ 
#define NV_063_POINT_V_VALUE_RMSK                          0x0000FFFF /* 15:0 */ 
#define NV_063_POINT_V_VALUE_WORD                          0
#define NV_063_POINT_V_VALUE_HIGH_FIELD                    0x0000000F /* =15 */
#define NV_063_POINT_V_VALUE_LOW_FIELD                     0x00000000 /* =0 */
#define NV_063_POINT_U_FRACTION_MSK                        0x000F0000 /* 19:16 */ 
#define NV_063_POINT_U_FRACTION_RMSK                       0x0000000F /* 19:16 */ 
#define NV_063_POINT_U_FRACTION_WORD                       0
#define NV_063_POINT_U_FRACTION_HIGH_FIELD                 0x00000013 /* =19 */
#define NV_063_POINT_U_FRACTION_LOW_FIELD                  0x00000010 /* =16 */
#define NV_063_POINT_U_INT_MSK                             0xFFF00000 /* 31:20 */ 
#define NV_063_POINT_U_INT_RMSK                            0x00000FFF /* 31:20 */ 
#define NV_063_POINT_U_INT_WORD                            0
#define NV_063_POINT_U_INT_HIGH_FIELD                      0x0000001F /* =31 */
#define NV_063_POINT_U_INT_LOW_FIELD                       0x00000014 /* =20 */
#define NV_063_POINT_U_VALUE_MSK                           0xFFFFFFFF /* 31:0 */ 
#define NV_063_POINT_U_VALUE_RMSK                          0xFFFFFFFF /* 31:0 */ 
#define NV_063_POINT_U_VALUE_WORD                          0
#define NV_063_POINT_U_VALUE_HIGH_FIELD                    0x0000001F /* =31 */
#define NV_063_POINT_U_VALUE_LOW_FIELD                     0x00000000 /* =0 */
#define NV_063_POINT_MSK                                   0xFFFFFFFF 
#define NV_089_HIGH_FIELD                                  0x006E1FFF /* =7217151 */
#define NV_089_LOW_FIELD                                   0x006E0000 /* =7208960 */
#define NV_089_NV10_SCALED_IMAGE_FROM_MEMORY_ADJ           0x006E0000
#define NV_089_NV10_SCALED_IMAGE_FROM_MEMORY_HANDLE_MSK    0xFFFFFFFF /* 31:0 */ 
#define NV_089_NV10_SCALED_IMAGE_FROM_MEMORY_HANDLE_RMSK   0xFFFFFFFF /* 31:0 */ 
#define NV_089_NV10_SCALED_IMAGE_FROM_MEMORY_HANDLE_WORD   0
#define NV_089_NV10_SCALED_IMAGE_FROM_MEMORY_HANDLE_HIGH_FIELD 0x0000001F /* =31 */
#define NV_089_NV10_SCALED_IMAGE_FROM_MEMORY_HANDLE_LOW_FIELD 0x00000000 /* =0 */
#define NV_089_NV10_SCALED_IMAGE_FROM_MEMORY_MSK           0xFFFFFFFF 
#define NV_089_NOP_PARAMETER_MSK                           0xFFFFFFFF /* 31:0 */ 
#define NV_089_NOP_PARAMETER_RMSK                          0xFFFFFFFF /* 31:0 */ 
#define NV_089_NOP_PARAMETER_WORD                          0
#define NV_089_NOP_PARAMETER_HIGH_FIELD                    0x0000001F /* =31 */
#define NV_089_NOP_PARAMETER_LOW_FIELD                     0x00000000 /* =0 */
#define NV_089_NOP_MSK                                     0xFFFFFFFF 
#define NV_089_PM_TRIGGER_PARAMETER_MSK                    0xFFFFFFFF /* 31:0 */ 
#define NV_089_PM_TRIGGER_PARAMETER_RMSK                   0xFFFFFFFF /* 31:0 */ 
#define NV_089_PM_TRIGGER_PARAMETER_WORD                   0
#define NV_089_PM_TRIGGER_PARAMETER_HIGH_FIELD             0x0000001F /* =31 */
#define NV_089_PM_TRIGGER_PARAMETER_LOW_FIELD              0x00000000 /* =0 */
#define NV_089_PM_TRIGGER_MSK                              0xFFFFFFFF 
#define NV_089_NOTIFY_STYLE_MSK                            0xFFFFFFFF /* 31:0 */ 
#define NV_089_NOTIFY_STYLE_RMSK                           0xFFFFFFFF /* 31:0 */ 
#define NV_089_NOTIFY_STYLE_WORD                           0
#define NV_089_NOTIFY_STYLE_HIGH_FIELD                     0x0000001F /* =31 */
#define NV_089_NOTIFY_STYLE_LOW_FIELD                      0x00000000 /* =0 */
#define NV_089_NOTIFY_STYLE_WRITE_ONLY_ADJ                 0x00000000
#define NV_089_NOTIFY_STYLE_WRITE_THEN_AWAKEN_ADJ          0x00000001
#define NV_089_NOTIFY_MSK                                  0xFFFFFFFF 
#define NV_089_SET_NOTIFY_PARAMETER_MSK                    0xFFFFFFFF /* 31:0 */ 
#define NV_089_SET_NOTIFY_PARAMETER_RMSK                   0xFFFFFFFF /* 31:0 */ 
#define NV_089_SET_NOTIFY_PARAMETER_WORD                   0
#define NV_089_SET_NOTIFY_PARAMETER_HIGH_FIELD             0x0000001F /* =31 */
#define NV_089_SET_NOTIFY_PARAMETER_LOW_FIELD              0x00000000 /* =0 */
#define NV_089_SET_NOTIFY_PARAMETER_WRITE_ADJ              0x00000000
#define NV_089_SET_NOTIFY_MSK                              0xFFFFFFFF 
#define NV_089_WAIT_FOR_IDLE_PARAMETER_MSK                 0xFFFFFFFF /* 31:0 */ 
#define NV_089_WAIT_FOR_IDLE_PARAMETER_RMSK                0xFFFFFFFF /* 31:0 */ 
#define NV_089_WAIT_FOR_IDLE_PARAMETER_WORD                0
#define NV_089_WAIT_FOR_IDLE_PARAMETER_HIGH_FIELD          0x0000001F /* =31 */
#define NV_089_WAIT_FOR_IDLE_PARAMETER_LOW_FIELD           0x00000000 /* =0 */
#define NV_089_WAIT_FOR_IDLE_MSK                           0xFFFFFFFF 
#define NV_089_SET_CONTEXT_DMA_NOTIFY_PARAMETER_MSK        0xFFFFFFFF /* 31:0 */ 
#define NV_089_SET_CONTEXT_DMA_NOTIFY_PARAMETER_RMSK       0xFFFFFFFF /* 31:0 */ 
#define NV_089_SET_CONTEXT_DMA_NOTIFY_PARAMETER_WORD       0
#define NV_089_SET_CONTEXT_DMA_NOTIFY_PARAMETER_HIGH_FIELD 0x0000001F /* =31 */
#define NV_089_SET_CONTEXT_DMA_NOTIFY_PARAMETER_LOW_FIELD  0x00000000 /* =0 */
#define NV_089_SET_CONTEXT_DMA_NOTIFY_MSK                  0xFFFFFFFF 
#define NV_089_SET_CONTEXT_DMA_IMAGE_PARAMETER_MSK         0xFFFFFFFF /* 31:0 */ 
#define NV_089_SET_CONTEXT_DMA_IMAGE_PARAMETER_RMSK        0xFFFFFFFF /* 31:0 */ 
#define NV_089_SET_CONTEXT_DMA_IMAGE_PARAMETER_WORD        0
#define NV_089_SET_CONTEXT_DMA_IMAGE_PARAMETER_HIGH_FIELD  0x0000001F /* =31 */
#define NV_089_SET_CONTEXT_DMA_IMAGE_PARAMETER_LOW_FIELD   0x00000000 /* =0 */
#define NV_089_SET_CONTEXT_DMA_IMAGE_MSK                   0xFFFFFFFF 
#define NV_089_SET_CONTEXT_PATTERN_PARAMETER_MSK           0xFFFFFFFF /* 31:0 */ 
#define NV_089_SET_CONTEXT_PATTERN_PARAMETER_RMSK          0xFFFFFFFF /* 31:0 */ 
#define NV_089_SET_CONTEXT_PATTERN_PARAMETER_WORD          0
#define NV_089_SET_CONTEXT_PATTERN_PARAMETER_HIGH_FIELD    0x0000001F /* =31 */
#define NV_089_SET_CONTEXT_PATTERN_PARAMETER_LOW_FIELD     0x00000000 /* =0 */
#define NV_089_SET_CONTEXT_PATTERN_MSK                     0xFFFFFFFF 
#define NV_089_SET_CONTEXT_ROP_PARAMETER_MSK               0xFFFFFFFF /* 31:0 */ 
#define NV_089_SET_CONTEXT_ROP_PARAMETER_RMSK              0xFFFFFFFF /* 31:0 */ 
#define NV_089_SET_CONTEXT_ROP_PARAMETER_WORD              0
#define NV_089_SET_CONTEXT_ROP_PARAMETER_HIGH_FIELD        0x0000001F /* =31 */
#define NV_089_SET_CONTEXT_ROP_PARAMETER_LOW_FIELD         0x00000000 /* =0 */
#define NV_089_SET_CONTEXT_ROP_MSK                         0xFFFFFFFF 
#define NV_089_SET_CONTEXT_BETA1_PARAMETER_MSK             0xFFFFFFFF /* 31:0 */ 
#define NV_089_SET_CONTEXT_BETA1_PARAMETER_RMSK            0xFFFFFFFF /* 31:0 */ 
#define NV_089_SET_CONTEXT_BETA1_PARAMETER_WORD            0
#define NV_089_SET_CONTEXT_BETA1_PARAMETER_HIGH_FIELD      0x0000001F /* =31 */
#define NV_089_SET_CONTEXT_BETA1_PARAMETER_LOW_FIELD       0x00000000 /* =0 */
#define NV_089_SET_CONTEXT_BETA1_MSK                       0xFFFFFFFF 
#define NV_089_SET_CONTEXT_BETA4_PARAMETER_MSK             0xFFFFFFFF /* 31:0 */ 
#define NV_089_SET_CONTEXT_BETA4_PARAMETER_RMSK            0xFFFFFFFF /* 31:0 */ 
#define NV_089_SET_CONTEXT_BETA4_PARAMETER_WORD            0
#define NV_089_SET_CONTEXT_BETA4_PARAMETER_HIGH_FIELD      0x0000001F /* =31 */
#define NV_089_SET_CONTEXT_BETA4_PARAMETER_LOW_FIELD       0x00000000 /* =0 */
#define NV_089_SET_CONTEXT_BETA4_MSK                       0xFFFFFFFF 
#define NV_089_SET_CONTEXT_SURFACE_PARAMETER_MSK           0xFFFFFFFF /* 31:0 */ 
#define NV_089_SET_CONTEXT_SURFACE_PARAMETER_RMSK          0xFFFFFFFF /* 31:0 */ 
#define NV_089_SET_CONTEXT_SURFACE_PARAMETER_WORD          0
#define NV_089_SET_CONTEXT_SURFACE_PARAMETER_HIGH_FIELD    0x0000001F /* =31 */
#define NV_089_SET_CONTEXT_SURFACE_PARAMETER_LOW_FIELD     0x00000000 /* =0 */
#define NV_089_SET_CONTEXT_SURFACE_MSK                     0xFFFFFFFF 
#define NV_089_SET_COLOR_CONVERSION_TYPE_MSK               0xFFFFFFFF /* 31:0 */ 
#define NV_089_SET_COLOR_CONVERSION_TYPE_RMSK              0xFFFFFFFF /* 31:0 */ 
#define NV_089_SET_COLOR_CONVERSION_TYPE_WORD              0
#define NV_089_SET_COLOR_CONVERSION_TYPE_HIGH_FIELD        0x0000001F /* =31 */
#define NV_089_SET_COLOR_CONVERSION_TYPE_LOW_FIELD         0x00000000 /* =0 */
#define NV_089_SET_COLOR_CONVERSION_TYPE_DITHER_ADJ        0x00000000
#define NV_089_SET_COLOR_CONVERSION_TYPE_TRUNCATE_ADJ      0x00000001
#define NV_089_SET_COLOR_CONVERSION_TYPE_SUBTR_TRUNCATE_ADJ 0x00000002
#define NV_089_SET_COLOR_CONVERSION_MSK                    0xFFFFFFFF 
#define NV_089_SET_COLOR_FORMAT_LE_MSK                     0xFFFFFFFF /* 31:0 */ 
#define NV_089_SET_COLOR_FORMAT_LE_RMSK                    0xFFFFFFFF /* 31:0 */ 
#define NV_089_SET_COLOR_FORMAT_LE_WORD                    0
#define NV_089_SET_COLOR_FORMAT_LE_HIGH_FIELD              0x0000001F /* =31 */
#define NV_089_SET_COLOR_FORMAT_LE_LOW_FIELD               0x00000000 /* =0 */
#define NV_089_SET_COLOR_FORMAT_LE_A1R5G5B5_ADJ            0x00000001
#define NV_089_SET_COLOR_FORMAT_LE_X1R5G5B5_ADJ            0x00000002
#define NV_089_SET_COLOR_FORMAT_LE_A8R8G8B8_ADJ            0x00000003
#define NV_089_SET_COLOR_FORMAT_LE_X8R8G8B8_ADJ            0x00000004
#define NV_089_SET_COLOR_FORMAT_LE_V8YB8U8YA8_ADJ          0x00000005
#define NV_089_SET_COLOR_FORMAT_LE_YB8V8YA8U8_ADJ          0x00000006
#define NV_089_SET_COLOR_FORMAT_LE_R5G6B5_ADJ              0x00000007
#define NV_089_SET_COLOR_FORMAT_LE_Y8_ADJ                  0x00000008
#define NV_089_SET_COLOR_FORMAT_LE_AY8_ADJ                 0x00000009
#define NV_089_SET_COLOR_FORMAT_MSK                        0xFFFFFFFF 
#define NV_089_SET_OPERATION_MODE_MSK                      0xFFFFFFFF /* 31:0 */ 
#define NV_089_SET_OPERATION_MODE_RMSK                     0xFFFFFFFF /* 31:0 */ 
#define NV_089_SET_OPERATION_MODE_WORD                     0
#define NV_089_SET_OPERATION_MODE_HIGH_FIELD               0x0000001F /* =31 */
#define NV_089_SET_OPERATION_MODE_LOW_FIELD                0x00000000 /* =0 */
#define NV_089_SET_OPERATION_MODE_SRCCOPY_AND_ADJ          0x00000000
#define NV_089_SET_OPERATION_MODE_ROP_AND_ADJ              0x00000001
#define NV_089_SET_OPERATION_MODE_BLEND_AND_ADJ            0x00000002
#define NV_089_SET_OPERATION_MODE_SRCCOPY_ADJ              0x00000003
#define NV_089_SET_OPERATION_MODE_SRCCOPY_PREMULT_ADJ      0x00000004
#define NV_089_SET_OPERATION_MODE_BLEND_PREMULT_ADJ        0x00000005
#define NV_089_SET_OPERATION_MSK                           0xFFFFFFFF 
#define NV_089_CLIP_0_X_MSK                                0x0000FFFF /* 15:0 */ 
#define NV_089_CLIP_0_X_RMSK                               0x0000FFFF /* 15:0 */ 
#define NV_089_CLIP_0_X_WORD                               0
#define NV_089_CLIP_0_X_HIGH_FIELD                         0x0000000F /* =15 */
#define NV_089_CLIP_0_X_LOW_FIELD                          0x00000000 /* =0 */
#define NV_089_CLIP_0_Y_MSK                                0xFFFF0000 /* 31:16 */ 
#define NV_089_CLIP_0_Y_RMSK                               0x0000FFFF /* 31:16 */ 
#define NV_089_CLIP_0_Y_WORD                               0
#define NV_089_CLIP_0_Y_HIGH_FIELD                         0x0000001F /* =31 */
#define NV_089_CLIP_0_Y_LOW_FIELD                          0x00000010 /* =16 */
#define NV_089_CLIP_0_MSK                                  0xFFFFFFFF 
#define NV_089_CLIP_1_WIDTH_MSK                            0x0000FFFF /* 15:0 */ 
#define NV_089_CLIP_1_WIDTH_RMSK                           0x0000FFFF /* 15:0 */ 
#define NV_089_CLIP_1_WIDTH_WORD                           0
#define NV_089_CLIP_1_WIDTH_HIGH_FIELD                     0x0000000F /* =15 */
#define NV_089_CLIP_1_WIDTH_LOW_FIELD                      0x00000000 /* =0 */
#define NV_089_CLIP_1_HEIGHT_MSK                           0xFFFF0000 /* 31:16 */ 
#define NV_089_CLIP_1_HEIGHT_RMSK                          0x0000FFFF /* 31:16 */ 
#define NV_089_CLIP_1_HEIGHT_WORD                          0
#define NV_089_CLIP_1_HEIGHT_HIGH_FIELD                    0x0000001F /* =31 */
#define NV_089_CLIP_1_HEIGHT_LOW_FIELD                     0x00000010 /* =16 */
#define NV_089_CLIP_1_MSK                                  0xFFFFFFFF 
#define NV_089_RECTANGLE_OUT_0_X_MSK                       0x0000FFFF /* 15:0 */ 
#define NV_089_RECTANGLE_OUT_0_X_RMSK                      0x0000FFFF /* 15:0 */ 
#define NV_089_RECTANGLE_OUT_0_X_WORD                      0
#define NV_089_RECTANGLE_OUT_0_X_HIGH_FIELD                0x0000000F /* =15 */
#define NV_089_RECTANGLE_OUT_0_X_LOW_FIELD                 0x00000000 /* =0 */
#define NV_089_RECTANGLE_OUT_0_Y_MSK                       0xFFFF0000 /* 31:16 */ 
#define NV_089_RECTANGLE_OUT_0_Y_RMSK                      0x0000FFFF /* 31:16 */ 
#define NV_089_RECTANGLE_OUT_0_Y_WORD                      0
#define NV_089_RECTANGLE_OUT_0_Y_HIGH_FIELD                0x0000001F /* =31 */
#define NV_089_RECTANGLE_OUT_0_Y_LOW_FIELD                 0x00000010 /* =16 */
#define NV_089_RECTANGLE_OUT_0_MSK                         0xFFFFFFFF 
#define NV_089_RECTANGLE_OUT_1_WIDTH_MSK                   0x0000FFFF /* 15:0 */ 
#define NV_089_RECTANGLE_OUT_1_WIDTH_RMSK                  0x0000FFFF /* 15:0 */ 
#define NV_089_RECTANGLE_OUT_1_WIDTH_WORD                  0
#define NV_089_RECTANGLE_OUT_1_WIDTH_HIGH_FIELD            0x0000000F /* =15 */
#define NV_089_RECTANGLE_OUT_1_WIDTH_LOW_FIELD             0x00000000 /* =0 */
#define NV_089_RECTANGLE_OUT_1_HEIGHT_MSK                  0xFFFF0000 /* 31:16 */ 
#define NV_089_RECTANGLE_OUT_1_HEIGHT_RMSK                 0x0000FFFF /* 31:16 */ 
#define NV_089_RECTANGLE_OUT_1_HEIGHT_WORD                 0
#define NV_089_RECTANGLE_OUT_1_HEIGHT_HIGH_FIELD           0x0000001F /* =31 */
#define NV_089_RECTANGLE_OUT_1_HEIGHT_LOW_FIELD            0x00000010 /* =16 */
#define NV_089_RECTANGLE_OUT_1_MSK                         0xFFFFFFFF 
#define NV_089_DELTA_DU_DX_R_FRACTION_MSK                  0x000FFFFF /* 19:0 */ 
#define NV_089_DELTA_DU_DX_R_FRACTION_RMSK                 0x000FFFFF /* 19:0 */ 
#define NV_089_DELTA_DU_DX_R_FRACTION_WORD                 0
#define NV_089_DELTA_DU_DX_R_FRACTION_HIGH_FIELD           0x00000013 /* =19 */
#define NV_089_DELTA_DU_DX_R_FRACTION_LOW_FIELD            0x00000000 /* =0 */
#define NV_089_DELTA_DU_DX_R_INT_MSK                       0xFFF00000 /* 31:20 */ 
#define NV_089_DELTA_DU_DX_R_INT_RMSK                      0x00000FFF /* 31:20 */ 
#define NV_089_DELTA_DU_DX_R_INT_WORD                      0
#define NV_089_DELTA_DU_DX_R_INT_HIGH_FIELD                0x0000001F /* =31 */
#define NV_089_DELTA_DU_DX_R_INT_LOW_FIELD                 0x00000014 /* =20 */
#define NV_089_DELTA_DU_DX_R_MSK                           0xFFFFFFFF /* 31:0 */ 
#define NV_089_DELTA_DU_DX_R_RMSK                          0xFFFFFFFF /* 31:0 */ 
#define NV_089_DELTA_DU_DX_R_WORD                          0
#define NV_089_DELTA_DU_DX_R_HIGH_FIELD                    0x0000001F /* =31 */
#define NV_089_DELTA_DU_DX_R_LOW_FIELD                     0x00000000 /* =0 */
#define NV_089_DELTA_DU_DX_MSK                             0xFFFFFFFF 
#define NV_089_DELTA_DV_DY_R_FRACTION_MSK                  0x000FFFFF /* 19:0 */ 
#define NV_089_DELTA_DV_DY_R_FRACTION_RMSK                 0x000FFFFF /* 19:0 */ 
#define NV_089_DELTA_DV_DY_R_FRACTION_WORD                 0
#define NV_089_DELTA_DV_DY_R_FRACTION_HIGH_FIELD           0x00000013 /* =19 */
#define NV_089_DELTA_DV_DY_R_FRACTION_LOW_FIELD            0x00000000 /* =0 */
#define NV_089_DELTA_DV_DY_R_INT_MSK                       0xFFF00000 /* 31:20 */ 
#define NV_089_DELTA_DV_DY_R_INT_RMSK                      0x00000FFF /* 31:20 */ 
#define NV_089_DELTA_DV_DY_R_INT_WORD                      0
#define NV_089_DELTA_DV_DY_R_INT_HIGH_FIELD                0x0000001F /* =31 */
#define NV_089_DELTA_DV_DY_R_INT_LOW_FIELD                 0x00000014 /* =20 */
#define NV_089_DELTA_DV_DY_R_MSK                           0xFFFFFFFF /* 31:0 */ 
#define NV_089_DELTA_DV_DY_R_RMSK                          0xFFFFFFFF /* 31:0 */ 
#define NV_089_DELTA_DV_DY_R_WORD                          0
#define NV_089_DELTA_DV_DY_R_HIGH_FIELD                    0x0000001F /* =31 */
#define NV_089_DELTA_DV_DY_R_LOW_FIELD                     0x00000000 /* =0 */
#define NV_089_DELTA_DV_DY_MSK                             0xFFFFFFFF 
#define NV_089_SIZE_WIDTH_MSK                              0x0000FFFF /* 15:0 */ 
#define NV_089_SIZE_WIDTH_RMSK                             0x0000FFFF /* 15:0 */ 
#define NV_089_SIZE_WIDTH_WORD                             0
#define NV_089_SIZE_WIDTH_HIGH_FIELD                       0x0000000F /* =15 */
#define NV_089_SIZE_WIDTH_LOW_FIELD                        0x00000000 /* =0 */
#define NV_089_SIZE_HEIGHT_MSK                             0xFFFF0000 /* 31:16 */ 
#define NV_089_SIZE_HEIGHT_RMSK                            0x0000FFFF /* 31:16 */ 
#define NV_089_SIZE_HEIGHT_WORD                            0
#define NV_089_SIZE_HEIGHT_HIGH_FIELD                      0x0000001F /* =31 */
#define NV_089_SIZE_HEIGHT_LOW_FIELD                       0x00000010 /* =16 */
#define NV_089_SIZE_MSK                                    0xFFFFFFFF 
#define NV_089_FORMAT_PITCH_MSK                            0x0000FFFF /* 15:0 */ 
#define NV_089_FORMAT_PITCH_RMSK                           0x0000FFFF /* 15:0 */ 
#define NV_089_FORMAT_PITCH_WORD                           0
#define NV_089_FORMAT_PITCH_HIGH_FIELD                     0x0000000F /* =15 */
#define NV_089_FORMAT_PITCH_LOW_FIELD                      0x00000000 /* =0 */
#define NV_089_FORMAT_ORIGIN_MSK                           0x00FF0000 /* 23:16 */ 
#define NV_089_FORMAT_ORIGIN_RMSK                          0x000000FF /* 23:16 */ 
#define NV_089_FORMAT_ORIGIN_WORD                          0
#define NV_089_FORMAT_ORIGIN_HIGH_FIELD                    0x00000017 /* =23 */
#define NV_089_FORMAT_ORIGIN_LOW_FIELD                     0x00000010 /* =16 */
#define NV_089_FORMAT_ORIGIN_CENTER_ADJ                    0x00010000
#define NV_089_FORMAT_ORIGIN_CORNER_ADJ                    0x00020000
#define NV_089_FORMAT_INTERPOLATOR_MSK                     0xFF000000 /* 31:24 */ 
#define NV_089_FORMAT_INTERPOLATOR_RMSK                    0x000000FF /* 31:24 */ 
#define NV_089_FORMAT_INTERPOLATOR_WORD                    0
#define NV_089_FORMAT_INTERPOLATOR_HIGH_FIELD              0x0000001F /* =31 */
#define NV_089_FORMAT_INTERPOLATOR_LOW_FIELD               0x00000018 /* =24 */
#define NV_089_FORMAT_INTERPOLATOR_ZOH_ADJ                 0x00000000
#define NV_089_FORMAT_INTERPOLATOR_FOH_ADJ                 0x01000000
#define NV_089_FORMAT_MSK                                  0xFFFFFFFF 
#define NV_089_OFFSET_VALUE_MSK                            0xFFFFFFFF /* 31:0 */ 
#define NV_089_OFFSET_VALUE_RMSK                           0xFFFFFFFF /* 31:0 */ 
#define NV_089_OFFSET_VALUE_WORD                           0
#define NV_089_OFFSET_VALUE_HIGH_FIELD                     0x0000001F /* =31 */
#define NV_089_OFFSET_VALUE_LOW_FIELD                      0x00000000 /* =0 */
#define NV_089_OFFSET_MSK                                  0xFFFFFFFF 
#define NV_089_POINT_V_FRACTION_MSK                        0x00000FFF /* 11:0 */ 
#define NV_089_POINT_V_FRACTION_RMSK                       0x00000FFF /* 11:0 */ 
#define NV_089_POINT_V_FRACTION_WORD                       0
#define NV_089_POINT_V_FRACTION_HIGH_FIELD                 0x0000000B /* =11 */
#define NV_089_POINT_V_FRACTION_LOW_FIELD                  0x00000000 /* =0 */
#define NV_089_POINT_V_INT_MSK                             0x0000F000 /* 15:12 */ 
#define NV_089_POINT_V_INT_RMSK                            0x0000000F /* 15:12 */ 
#define NV_089_POINT_V_INT_WORD                            0
#define NV_089_POINT_V_INT_HIGH_FIELD                      0x0000000F /* =15 */
#define NV_089_POINT_V_INT_LOW_FIELD                       0x0000000C /* =12 */
#define NV_089_POINT_V_VALUE_MSK                           0x0000FFFF /* 15:0 */ 
#define NV_089_POINT_V_VALUE_RMSK                          0x0000FFFF /* 15:0 */ 
#define NV_089_POINT_V_VALUE_WORD                          0
#define NV_089_POINT_V_VALUE_HIGH_FIELD                    0x0000000F /* =15 */
#define NV_089_POINT_V_VALUE_LOW_FIELD                     0x00000000 /* =0 */
#define NV_089_POINT_U_FRACTION_MSK                        0x000F0000 /* 19:16 */ 
#define NV_089_POINT_U_FRACTION_RMSK                       0x0000000F /* 19:16 */ 
#define NV_089_POINT_U_FRACTION_WORD                       0
#define NV_089_POINT_U_FRACTION_HIGH_FIELD                 0x00000013 /* =19 */
#define NV_089_POINT_U_FRACTION_LOW_FIELD                  0x00000010 /* =16 */
#define NV_089_POINT_U_INT_MSK                             0xFFF00000 /* 31:20 */ 
#define NV_089_POINT_U_INT_RMSK                            0x00000FFF /* 31:20 */ 
#define NV_089_POINT_U_INT_WORD                            0
#define NV_089_POINT_U_INT_HIGH_FIELD                      0x0000001F /* =31 */
#define NV_089_POINT_U_INT_LOW_FIELD                       0x00000014 /* =20 */
#define NV_089_POINT_U_VALUE_MSK                           0xFFFFFFFF /* 31:0 */ 
#define NV_089_POINT_U_VALUE_RMSK                          0xFFFFFFFF /* 31:0 */ 
#define NV_089_POINT_U_VALUE_WORD                          0
#define NV_089_POINT_U_VALUE_HIGH_FIELD                    0x0000001F /* =31 */
#define NV_089_POINT_U_VALUE_LOW_FIELD                     0x00000000 /* =0 */
#define NV_089_POINT_MSK                                   0xFFFFFFFF 
#define NV_038_HIGH_FIELD                                  0x004F1FFF /* =5185535 */
#define NV_038_LOW_FIELD                                   0x004F0000 /* =5177344 */
#define NV_038_NV4_DVD_SUBPICTURE_ADJ                      0x004F0000
#define NV_038_NV4_DVD_SUBPICTURE_MSK                      0x00000000 
#define NV_038_NOP_ADJ                                     0x004F0100
#define NV_038_NOP_PARAMETER_MSK                           0xFFFFFFFF /* 31:0 */ 
#define NV_038_NOP_PARAMETER_RMSK                          0xFFFFFFFF /* 31:0 */ 
#define NV_038_NOP_PARAMETER_WORD                          0
#define NV_038_NOP_PARAMETER_HIGH_FIELD                    0x0000001F /* =31 */
#define NV_038_NOP_PARAMETER_LOW_FIELD                     0x00000000 /* =0 */
#define NV_038_NOP_MSK                                     0xFFFFFFFF 
#define NV_038_NOTIFY_STYLE_MSK                            0xFFFFFFFF /* 31:0 */ 
#define NV_038_NOTIFY_STYLE_RMSK                           0xFFFFFFFF /* 31:0 */ 
#define NV_038_NOTIFY_STYLE_WORD                           0
#define NV_038_NOTIFY_STYLE_HIGH_FIELD                     0x0000001F /* =31 */
#define NV_038_NOTIFY_STYLE_LOW_FIELD                      0x00000000 /* =0 */
#define NV_038_NOTIFY_STYLE_WRITE_ONLY_ADJ                 0x00000000
#define NV_038_NOTIFY_STYLE_WRITE_THEN_AWAKEN_ADJ          0x00000001
#define NV_038_SET_NOTIFY_PARAMETER_MSK                    0xFFFFFFFF /* 31:0 */ 
#define NV_038_SET_NOTIFY_PARAMETER_RMSK                   0xFFFFFFFF /* 31:0 */ 
#define NV_038_SET_NOTIFY_PARAMETER_WORD                   0
#define NV_038_SET_NOTIFY_PARAMETER_HIGH_FIELD             0x0000001F /* =31 */
#define NV_038_SET_NOTIFY_PARAMETER_LOW_FIELD              0x00000000 /* =0 */
#define NV_038_SET_NOTIFY_PARAMETER_WRITE_ADJ              0x00000000
#define NV_038_NOTIFY_MSK                                  0xFFFFFFFF 
#define NV_038_SET_CONTEXT_DMA_NOTIFY_PARAMETER_MSK        0xFFFFFFFF /* 31:0 */ 
#define NV_038_SET_CONTEXT_DMA_NOTIFY_PARAMETER_RMSK       0xFFFFFFFF /* 31:0 */ 
#define NV_038_SET_CONTEXT_DMA_NOTIFY_PARAMETER_WORD       0
#define NV_038_SET_CONTEXT_DMA_NOTIFY_PARAMETER_HIGH_FIELD 0x0000001F /* =31 */
#define NV_038_SET_CONTEXT_DMA_NOTIFY_PARAMETER_LOW_FIELD  0x00000000 /* =0 */
#define NV_038_SET_CONTEXT_DMA_NOTIFY_MSK                  0xFFFFFFFF 
#define NV_038_SET_CONTEXT_DMA_OVERLAY_PARAMETER_MSK       0xFFFFFFFF /* 31:0 */ 
#define NV_038_SET_CONTEXT_DMA_OVERLAY_PARAMETER_RMSK      0xFFFFFFFF /* 31:0 */ 
#define NV_038_SET_CONTEXT_DMA_OVERLAY_PARAMETER_WORD      0
#define NV_038_SET_CONTEXT_DMA_OVERLAY_PARAMETER_HIGH_FIELD 0x0000001F /* =31 */
#define NV_038_SET_CONTEXT_DMA_OVERLAY_PARAMETER_LOW_FIELD 0x00000000 /* =0 */
#define NV_038_SET_CONTEXT_DMA_OVERLAY_MSK                 0xFFFFFFFF 
#define NV_038_SET_CONTEXT_DMA_IMAGEIN_PARAMETER_MSK       0xFFFFFFFF /* 31:0 */ 
#define NV_038_SET_CONTEXT_DMA_IMAGEIN_PARAMETER_RMSK      0xFFFFFFFF /* 31:0 */ 
#define NV_038_SET_CONTEXT_DMA_IMAGEIN_PARAMETER_WORD      0
#define NV_038_SET_CONTEXT_DMA_IMAGEIN_PARAMETER_HIGH_FIELD 0x0000001F /* =31 */
#define NV_038_SET_CONTEXT_DMA_IMAGEIN_PARAMETER_LOW_FIELD 0x00000000 /* =0 */
#define NV_038_SET_CONTEXT_DMA_IMAGEIN_MSK                 0xFFFFFFFF 
#define NV_038_SET_CONTEXT_DMA_IMAGEOUT_PARAMETER_MSK      0xFFFFFFFF /* 31:0 */ 
#define NV_038_SET_CONTEXT_DMA_IMAGEOUT_PARAMETER_RMSK     0xFFFFFFFF /* 31:0 */ 
#define NV_038_SET_CONTEXT_DMA_IMAGEOUT_PARAMETER_WORD     0
#define NV_038_SET_CONTEXT_DMA_IMAGEOUT_PARAMETER_HIGH_FIELD 0x0000001F /* =31 */
#define NV_038_SET_CONTEXT_DMA_IMAGEOUT_PARAMETER_LOW_FIELD 0x00000000 /* =0 */
#define NV_038_SET_CONTEXT_DMA_IMAGEOUT_MSK                0xFFFFFFFF 
#define NV_038_IMAGEOUT_POINT_X_MSK                        0x0000FFFF /* 15:0 */ 
#define NV_038_IMAGEOUT_POINT_X_RMSK                       0x0000FFFF /* 15:0 */ 
#define NV_038_IMAGEOUT_POINT_X_WORD                       0
#define NV_038_IMAGEOUT_POINT_X_HIGH_FIELD                 0x0000000F /* =15 */
#define NV_038_IMAGEOUT_POINT_X_LOW_FIELD                  0x00000000 /* =0 */
#define NV_038_IMAGEOUT_POINT_Y_MSK                        0xFFFF0000 /* 31:16 */ 
#define NV_038_IMAGEOUT_POINT_Y_RMSK                       0x0000FFFF /* 31:16 */ 
#define NV_038_IMAGEOUT_POINT_Y_WORD                       0
#define NV_038_IMAGEOUT_POINT_Y_HIGH_FIELD                 0x0000001F /* =31 */
#define NV_038_IMAGEOUT_POINT_Y_LOW_FIELD                  0x00000010 /* =16 */
#define NV_038_IMAGEOUT_POINT_MSK                          0xFFFFFFFF 
#define NV_038_IMAGEOUT_SIZE_WIDTH_MSK                     0x0000FFFF /* 15:0 */ 
#define NV_038_IMAGEOUT_SIZE_WIDTH_RMSK                    0x0000FFFF /* 15:0 */ 
#define NV_038_IMAGEOUT_SIZE_WIDTH_WORD                    0
#define NV_038_IMAGEOUT_SIZE_WIDTH_HIGH_FIELD              0x0000000F /* =15 */
#define NV_038_IMAGEOUT_SIZE_WIDTH_LOW_FIELD               0x00000000 /* =0 */
#define NV_038_IMAGEOUT_SIZE_HEIGHT_MSK                    0xFFFF0000 /* 31:16 */ 
#define NV_038_IMAGEOUT_SIZE_HEIGHT_RMSK                   0x0000FFFF /* 31:16 */ 
#define NV_038_IMAGEOUT_SIZE_HEIGHT_WORD                   0
#define NV_038_IMAGEOUT_SIZE_HEIGHT_HIGH_FIELD             0x0000001F /* =31 */
#define NV_038_IMAGEOUT_SIZE_HEIGHT_LOW_FIELD              0x00000010 /* =16 */
#define NV_038_IMAGEOUT_SIZE_MSK                           0xFFFFFFFF 
#define NV_038_IMAGEOUT_FMT_PITCH_MSK                      0x0000FFFF /* 15:0 */ 
#define NV_038_IMAGEOUT_FMT_PITCH_RMSK                     0x0000FFFF /* 15:0 */ 
#define NV_038_IMAGEOUT_FMT_PITCH_WORD                     0
#define NV_038_IMAGEOUT_FMT_PITCH_HIGH_FIELD               0x0000000F /* =15 */
#define NV_038_IMAGEOUT_FMT_PITCH_LOW_FIELD                0x00000000 /* =0 */
#define NV_038_IMAGEOUT_FMT_COLOR_MSK                      0xFFFF0000 /* 31:16 */ 
#define NV_038_IMAGEOUT_FMT_COLOR_RMSK                     0x0000FFFF /* 31:16 */ 
#define NV_038_IMAGEOUT_FMT_COLOR_WORD                     0
#define NV_038_IMAGEOUT_FMT_COLOR_HIGH_FIELD               0x0000001F /* =31 */
#define NV_038_IMAGEOUT_FMT_COLOR_LOW_FIELD                0x00000010 /* =16 */
#define NV_038_IMAGEOUT_FMT_COLOR_INVALID_ADJ              0x00000000
#define NV_038_IMAGEOUT_FMT_COLOR_LE_V8YB8U8YA8_ADJ        0x00010000
#define NV_038_IMAGEOUT_FMT_COLOR_LE_YB8V8YA8U8_ADJ        0x00020000
#define NV_038_IMAGEOUT_FMT_MSK                            0xFFFFFFFF 
#define NV_038_IMAGEOUT_OFFSET_VALUE_MSK                   0xFFFFFFFF /* 31:0 */ 
#define NV_038_IMAGEOUT_OFFSET_VALUE_RMSK                  0xFFFFFFFF /* 31:0 */ 
#define NV_038_IMAGEOUT_OFFSET_VALUE_WORD                  0
#define NV_038_IMAGEOUT_OFFSET_VALUE_HIGH_FIELD            0x0000001F /* =31 */
#define NV_038_IMAGEOUT_OFFSET_VALUE_LOW_FIELD             0x00000000 /* =0 */
#define NV_038_IMAGEOUT_OFFSET_MSK                         0xFFFFFFFF 
#define NV_038_IMAGEIN_DELTA_DU_DX_R_FRACTION_MSK          0x000FFFFF /* 19:0 */ 
#define NV_038_IMAGEIN_DELTA_DU_DX_R_FRACTION_RMSK         0x000FFFFF /* 19:0 */ 
#define NV_038_IMAGEIN_DELTA_DU_DX_R_FRACTION_WORD         0
#define NV_038_IMAGEIN_DELTA_DU_DX_R_FRACTION_HIGH_FIELD   0x00000013 /* =19 */
#define NV_038_IMAGEIN_DELTA_DU_DX_R_FRACTION_LOW_FIELD    0x00000000 /* =0 */
#define NV_038_IMAGEIN_DELTA_DU_DX_R_INT_MSK               0xFFF00000 /* 31:20 */ 
#define NV_038_IMAGEIN_DELTA_DU_DX_R_INT_RMSK              0x00000FFF /* 31:20 */ 
#define NV_038_IMAGEIN_DELTA_DU_DX_R_INT_WORD              0
#define NV_038_IMAGEIN_DELTA_DU_DX_R_INT_HIGH_FIELD        0x0000001F /* =31 */
#define NV_038_IMAGEIN_DELTA_DU_DX_R_INT_LOW_FIELD         0x00000014 /* =20 */
#define NV_038_IMAGEIN_DELTA_DU_DX_R_MSK                   0xFFFFFFFF /* 31:0 */ 
#define NV_038_IMAGEIN_DELTA_DU_DX_R_RMSK                  0xFFFFFFFF /* 31:0 */ 
#define NV_038_IMAGEIN_DELTA_DU_DX_R_WORD                  0
#define NV_038_IMAGEIN_DELTA_DU_DX_R_HIGH_FIELD            0x0000001F /* =31 */
#define NV_038_IMAGEIN_DELTA_DU_DX_R_LOW_FIELD             0x00000000 /* =0 */
#define NV_038_IMAGEIN_DELTA_DU_DX_MSK                     0xFFFFFFFF 
#define NV_038_IMAGEIN_DELTA_DV_DY_R_FRACTION_MSK          0x000FFFFF /* 19:0 */ 
#define NV_038_IMAGEIN_DELTA_DV_DY_R_FRACTION_RMSK         0x000FFFFF /* 19:0 */ 
#define NV_038_IMAGEIN_DELTA_DV_DY_R_FRACTION_WORD         0
#define NV_038_IMAGEIN_DELTA_DV_DY_R_FRACTION_HIGH_FIELD   0x00000013 /* =19 */
#define NV_038_IMAGEIN_DELTA_DV_DY_R_FRACTION_LOW_FIELD    0x00000000 /* =0 */
#define NV_038_IMAGEIN_DELTA_DV_DY_R_INT_MSK               0xFFF00000 /* 31:20 */ 
#define NV_038_IMAGEIN_DELTA_DV_DY_R_INT_RMSK              0x00000FFF /* 31:20 */ 
#define NV_038_IMAGEIN_DELTA_DV_DY_R_INT_WORD              0
#define NV_038_IMAGEIN_DELTA_DV_DY_R_INT_HIGH_FIELD        0x0000001F /* =31 */
#define NV_038_IMAGEIN_DELTA_DV_DY_R_INT_LOW_FIELD         0x00000014 /* =20 */
#define NV_038_IMAGEIN_DELTA_DV_DY_R_MSK                   0xFFFFFFFF /* 31:0 */ 
#define NV_038_IMAGEIN_DELTA_DV_DY_R_RMSK                  0xFFFFFFFF /* 31:0 */ 
#define NV_038_IMAGEIN_DELTA_DV_DY_R_WORD                  0
#define NV_038_IMAGEIN_DELTA_DV_DY_R_HIGH_FIELD            0x0000001F /* =31 */
#define NV_038_IMAGEIN_DELTA_DV_DY_R_LOW_FIELD             0x00000000 /* =0 */
#define NV_038_IMAGEIN_DELTA_DV_DY_MSK                     0xFFFFFFFF 
#define NV_038_IMAGEIN_SIZE_WIDTH_MSK                      0x0000FFFF /* 15:0 */ 
#define NV_038_IMAGEIN_SIZE_WIDTH_RMSK                     0x0000FFFF /* 15:0 */ 
#define NV_038_IMAGEIN_SIZE_WIDTH_WORD                     0
#define NV_038_IMAGEIN_SIZE_WIDTH_HIGH_FIELD               0x0000000F /* =15 */
#define NV_038_IMAGEIN_SIZE_WIDTH_LOW_FIELD                0x00000000 /* =0 */
#define NV_038_IMAGEIN_SIZE_HEIGHT_MSK                     0xFFFF0000 /* 31:16 */ 
#define NV_038_IMAGEIN_SIZE_HEIGHT_RMSK                    0x0000FFFF /* 31:16 */ 
#define NV_038_IMAGEIN_SIZE_HEIGHT_WORD                    0
#define NV_038_IMAGEIN_SIZE_HEIGHT_HIGH_FIELD              0x0000001F /* =31 */
#define NV_038_IMAGEIN_SIZE_HEIGHT_LOW_FIELD               0x00000010 /* =16 */
#define NV_038_IMAGEIN_SIZE_MSK                            0xFFFFFFFF 
#define NV_038_IMAGEIN_FMT_PITCH_MSK                       0x0000FFFF /* 15:0 */ 
#define NV_038_IMAGEIN_FMT_PITCH_RMSK                      0x0000FFFF /* 15:0 */ 
#define NV_038_IMAGEIN_FMT_PITCH_WORD                      0
#define NV_038_IMAGEIN_FMT_PITCH_HIGH_FIELD                0x0000000F /* =15 */
#define NV_038_IMAGEIN_FMT_PITCH_LOW_FIELD                 0x00000000 /* =0 */
#define NV_038_IMAGEIN_FMT_COLOR_MSK                       0xFFFF0000 /* 31:16 */ 
#define NV_038_IMAGEIN_FMT_COLOR_RMSK                      0x0000FFFF /* 31:16 */ 
#define NV_038_IMAGEIN_FMT_COLOR_WORD                      0
#define NV_038_IMAGEIN_FMT_COLOR_HIGH_FIELD                0x0000001F /* =31 */
#define NV_038_IMAGEIN_FMT_COLOR_LOW_FIELD                 0x00000010 /* =16 */
#define NV_038_IMAGEIN_FMT_COLOR_INVALID_ADJ               0x00000000
#define NV_038_IMAGEIN_FMT_COLOR_LE_V8YB8U8YA8_ADJ         0x00010000
#define NV_038_IMAGEIN_FMT_COLOR_LE_YB8V8YA8U8_ADJ         0x00020000
#define NV_038_IMAGEIN_FMT_MSK                             0xFFFFFFFF 
#define NV_038_IMAGEIN_OFFSET_VALUE_MSK                    0xFFFFFFFF /* 31:0 */ 
#define NV_038_IMAGEIN_OFFSET_VALUE_RMSK                   0xFFFFFFFF /* 31:0 */ 
#define NV_038_IMAGEIN_OFFSET_VALUE_WORD                   0
#define NV_038_IMAGEIN_OFFSET_VALUE_HIGH_FIELD             0x0000001F /* =31 */
#define NV_038_IMAGEIN_OFFSET_VALUE_LOW_FIELD              0x00000000 /* =0 */
#define NV_038_IMAGEIN_OFFSET_MSK                          0xFFFFFFFF 
#define NV_038_IMAGEIN_POINT_U_FRACTION_MSK                0x0000000F /* 3:0 */ 
#define NV_038_IMAGEIN_POINT_U_FRACTION_RMSK               0x0000000F /* 3:0 */ 
#define NV_038_IMAGEIN_POINT_U_FRACTION_WORD               0
#define NV_038_IMAGEIN_POINT_U_FRACTION_HIGH_FIELD         0x00000003 /* =3 */
#define NV_038_IMAGEIN_POINT_U_FRACTION_LOW_FIELD          0x00000000 /* =0 */
#define NV_038_IMAGEIN_POINT_U_INT_MSK                     0x0000FFF0 /* 15:4 */ 
#define NV_038_IMAGEIN_POINT_U_INT_RMSK                    0x00000FFF /* 15:4 */ 
#define NV_038_IMAGEIN_POINT_U_INT_WORD                    0
#define NV_038_IMAGEIN_POINT_U_INT_HIGH_FIELD              0x0000000F /* =15 */
#define NV_038_IMAGEIN_POINT_U_INT_LOW_FIELD               0x00000004 /* =4 */
#define NV_038_IMAGEIN_POINT_U_VALUE_MSK                   0x0000FFFF /* 15:0 */ 
#define NV_038_IMAGEIN_POINT_U_VALUE_RMSK                  0x0000FFFF /* 15:0 */ 
#define NV_038_IMAGEIN_POINT_U_VALUE_WORD                  0
#define NV_038_IMAGEIN_POINT_U_VALUE_HIGH_FIELD            0x0000000F /* =15 */
#define NV_038_IMAGEIN_POINT_U_VALUE_LOW_FIELD             0x00000000 /* =0 */
#define NV_038_IMAGEIN_POINT_V_FRACTION_MSK                0x000F0000 /* 19:16 */ 
#define NV_038_IMAGEIN_POINT_V_FRACTION_RMSK               0x0000000F /* 19:16 */ 
#define NV_038_IMAGEIN_POINT_V_FRACTION_WORD               0
#define NV_038_IMAGEIN_POINT_V_FRACTION_HIGH_FIELD         0x00000013 /* =19 */
#define NV_038_IMAGEIN_POINT_V_FRACTION_LOW_FIELD          0x00000010 /* =16 */
#define NV_038_IMAGEIN_POINT_V_INT_MSK                     0xFFF00000 /* 31:20 */ 
#define NV_038_IMAGEIN_POINT_V_INT_RMSK                    0x00000FFF /* 31:20 */ 
#define NV_038_IMAGEIN_POINT_V_INT_WORD                    0
#define NV_038_IMAGEIN_POINT_V_INT_HIGH_FIELD              0x0000001F /* =31 */
#define NV_038_IMAGEIN_POINT_V_INT_LOW_FIELD               0x00000014 /* =20 */
#define NV_038_IMAGEIN_POINT_V_VALUE_MSK                   0xFFFFFFFF /* 31:0 */ 
#define NV_038_IMAGEIN_POINT_V_VALUE_RMSK                  0xFFFFFFFF /* 31:0 */ 
#define NV_038_IMAGEIN_POINT_V_VALUE_WORD                  0
#define NV_038_IMAGEIN_POINT_V_VALUE_HIGH_FIELD            0x0000001F /* =31 */
#define NV_038_IMAGEIN_POINT_V_VALUE_LOW_FIELD             0x00000000 /* =0 */
#define NV_038_IMAGEIN_POINT_MSK                           0xFFFFFFFF 
#define NV_038_OVERLAY_DELTA_DU_DX_R_FRACTION_MSK          0x000FFFFF /* 19:0 */ 
#define NV_038_OVERLAY_DELTA_DU_DX_R_FRACTION_RMSK         0x000FFFFF /* 19:0 */ 
#define NV_038_OVERLAY_DELTA_DU_DX_R_FRACTION_WORD         0
#define NV_038_OVERLAY_DELTA_DU_DX_R_FRACTION_HIGH_FIELD   0x00000013 /* =19 */
#define NV_038_OVERLAY_DELTA_DU_DX_R_FRACTION_LOW_FIELD    0x00000000 /* =0 */
#define NV_038_OVERLAY_DELTA_DU_DX_R_INT_MSK               0xFFF00000 /* 31:20 */ 
#define NV_038_OVERLAY_DELTA_DU_DX_R_INT_RMSK              0x00000FFF /* 31:20 */ 
#define NV_038_OVERLAY_DELTA_DU_DX_R_INT_WORD              0
#define NV_038_OVERLAY_DELTA_DU_DX_R_INT_HIGH_FIELD        0x0000001F /* =31 */
#define NV_038_OVERLAY_DELTA_DU_DX_R_INT_LOW_FIELD         0x00000014 /* =20 */
#define NV_038_OVERLAY_DELTA_DU_DX_R_MSK                   0xFFFFFFFF /* 31:0 */ 
#define NV_038_OVERLAY_DELTA_DU_DX_R_RMSK                  0xFFFFFFFF /* 31:0 */ 
#define NV_038_OVERLAY_DELTA_DU_DX_R_WORD                  0
#define NV_038_OVERLAY_DELTA_DU_DX_R_HIGH_FIELD            0x0000001F /* =31 */
#define NV_038_OVERLAY_DELTA_DU_DX_R_LOW_FIELD             0x00000000 /* =0 */
#define NV_038_OVERLAY_DELTA_DU_DX_MSK                     0xFFFFFFFF 
#define NV_038_OVERLAY_DELTA_DV_DY_R_FRACTION_MSK          0x000FFFFF /* 19:0 */ 
#define NV_038_OVERLAY_DELTA_DV_DY_R_FRACTION_RMSK         0x000FFFFF /* 19:0 */ 
#define NV_038_OVERLAY_DELTA_DV_DY_R_FRACTION_WORD         0
#define NV_038_OVERLAY_DELTA_DV_DY_R_FRACTION_HIGH_FIELD   0x00000013 /* =19 */
#define NV_038_OVERLAY_DELTA_DV_DY_R_FRACTION_LOW_FIELD    0x00000000 /* =0 */
#define NV_038_OVERLAY_DELTA_DV_DY_R_INT_MSK               0xFFF00000 /* 31:20 */ 
#define NV_038_OVERLAY_DELTA_DV_DY_R_INT_RMSK              0x00000FFF /* 31:20 */ 
#define NV_038_OVERLAY_DELTA_DV_DY_R_INT_WORD              0
#define NV_038_OVERLAY_DELTA_DV_DY_R_INT_HIGH_FIELD        0x0000001F /* =31 */
#define NV_038_OVERLAY_DELTA_DV_DY_R_INT_LOW_FIELD         0x00000014 /* =20 */
#define NV_038_OVERLAY_DELTA_DV_DY_R_MSK                   0xFFFFFFFF /* 31:0 */ 
#define NV_038_OVERLAY_DELTA_DV_DY_R_RMSK                  0xFFFFFFFF /* 31:0 */ 
#define NV_038_OVERLAY_DELTA_DV_DY_R_WORD                  0
#define NV_038_OVERLAY_DELTA_DV_DY_R_HIGH_FIELD            0x0000001F /* =31 */
#define NV_038_OVERLAY_DELTA_DV_DY_R_LOW_FIELD             0x00000000 /* =0 */
#define NV_038_OVERLAY_DELTA_DV_DY_MSK                     0xFFFFFFFF 
#define NV_038_OVERLAY_SIZE_WIDTH_MSK                      0x0000FFFF /* 15:0 */ 
#define NV_038_OVERLAY_SIZE_WIDTH_RMSK                     0x0000FFFF /* 15:0 */ 
#define NV_038_OVERLAY_SIZE_WIDTH_WORD                     0
#define NV_038_OVERLAY_SIZE_WIDTH_HIGH_FIELD               0x0000000F /* =15 */
#define NV_038_OVERLAY_SIZE_WIDTH_LOW_FIELD                0x00000000 /* =0 */
#define NV_038_OVERLAY_SIZE_HEIGHT_MSK                     0xFFFF0000 /* 31:16 */ 
#define NV_038_OVERLAY_SIZE_HEIGHT_RMSK                    0x0000FFFF /* 31:16 */ 
#define NV_038_OVERLAY_SIZE_HEIGHT_WORD                    0
#define NV_038_OVERLAY_SIZE_HEIGHT_HIGH_FIELD              0x0000001F /* =31 */
#define NV_038_OVERLAY_SIZE_HEIGHT_LOW_FIELD               0x00000010 /* =16 */
#define NV_038_OVERLAY_SIZE_MSK                            0xFFFFFFFF 
#define NV_038_OVERLAY_FMT_PITCH_MSK                       0x0000FFFF /* 15:0 */ 
#define NV_038_OVERLAY_FMT_PITCH_RMSK                      0x0000FFFF /* 15:0 */ 
#define NV_038_OVERLAY_FMT_PITCH_WORD                      0
#define NV_038_OVERLAY_FMT_PITCH_HIGH_FIELD                0x0000000F /* =15 */
#define NV_038_OVERLAY_FMT_PITCH_LOW_FIELD                 0x00000000 /* =0 */
#define NV_038_OVERLAY_FMT_COLOR_MSK                       0xFFFF0000 /* 31:16 */ 
#define NV_038_OVERLAY_FMT_COLOR_RMSK                      0x0000FFFF /* 31:16 */ 
#define NV_038_OVERLAY_FMT_COLOR_WORD                      0
#define NV_038_OVERLAY_FMT_COLOR_HIGH_FIELD                0x0000001F /* =31 */
#define NV_038_OVERLAY_FMT_COLOR_LOW_FIELD                 0x00000010 /* =16 */
#define NV_038_OVERLAY_FMT_COLOR_INVALID_ADJ               0x00000000
#define NV_038_OVERLAY_FMT_COLOR_LE_A8V8U8Y8_ADJ           0x00010000
#define NV_038_OVERLAY_FMT_COLOR_LE_A4V6YB6A4U6YA6_ADJ     0x00020000
#define NV_038_OVERLAY_FMT_COLOR_LE_TRANSPARENT_ADJ        0x00030000
#define NV_038_OVERLAY_FMT_MSK                             0xFFFFFFFF 
#define NV_038_OVERLAY_OFFSET_VALUE_MSK                    0xFFFFFFFF /* 31:0 */ 
#define NV_038_OVERLAY_OFFSET_VALUE_RMSK                   0xFFFFFFFF /* 31:0 */ 
#define NV_038_OVERLAY_OFFSET_VALUE_WORD                   0
#define NV_038_OVERLAY_OFFSET_VALUE_HIGH_FIELD             0x0000001F /* =31 */
#define NV_038_OVERLAY_OFFSET_VALUE_LOW_FIELD              0x00000000 /* =0 */
#define NV_038_OVERLAY_OFFSET_MSK                          0xFFFFFFFF 
#define NV_038_OVERLAY_POINT_U_FRACTION_MSK                0x0000000F /* 3:0 */ 
#define NV_038_OVERLAY_POINT_U_FRACTION_RMSK               0x0000000F /* 3:0 */ 
#define NV_038_OVERLAY_POINT_U_FRACTION_WORD               0
#define NV_038_OVERLAY_POINT_U_FRACTION_HIGH_FIELD         0x00000003 /* =3 */
#define NV_038_OVERLAY_POINT_U_FRACTION_LOW_FIELD          0x00000000 /* =0 */
#define NV_038_OVERLAY_POINT_U_INT_MSK                     0x0000FFF0 /* 15:4 */ 
#define NV_038_OVERLAY_POINT_U_INT_RMSK                    0x00000FFF /* 15:4 */ 
#define NV_038_OVERLAY_POINT_U_INT_WORD                    0
#define NV_038_OVERLAY_POINT_U_INT_HIGH_FIELD              0x0000000F /* =15 */
#define NV_038_OVERLAY_POINT_U_INT_LOW_FIELD               0x00000004 /* =4 */
#define NV_038_OVERLAY_POINT_U_VALUE_MSK                   0x0000FFFF /* 15:0 */ 
#define NV_038_OVERLAY_POINT_U_VALUE_RMSK                  0x0000FFFF /* 15:0 */ 
#define NV_038_OVERLAY_POINT_U_VALUE_WORD                  0
#define NV_038_OVERLAY_POINT_U_VALUE_HIGH_FIELD            0x0000000F /* =15 */
#define NV_038_OVERLAY_POINT_U_VALUE_LOW_FIELD             0x00000000 /* =0 */
#define NV_038_OVERLAY_POINT_V_FRACTION_MSK                0x000F0000 /* 19:16 */ 
#define NV_038_OVERLAY_POINT_V_FRACTION_RMSK               0x0000000F /* 19:16 */ 
#define NV_038_OVERLAY_POINT_V_FRACTION_WORD               0
#define NV_038_OVERLAY_POINT_V_FRACTION_HIGH_FIELD         0x00000013 /* =19 */
#define NV_038_OVERLAY_POINT_V_FRACTION_LOW_FIELD          0x00000010 /* =16 */
#define NV_038_OVERLAY_POINT_V_INT_MSK                     0xFFF00000 /* 31:20 */ 
#define NV_038_OVERLAY_POINT_V_INT_RMSK                    0x00000FFF /* 31:20 */ 
#define NV_038_OVERLAY_POINT_V_INT_WORD                    0
#define NV_038_OVERLAY_POINT_V_INT_HIGH_FIELD              0x0000001F /* =31 */
#define NV_038_OVERLAY_POINT_V_INT_LOW_FIELD               0x00000014 /* =20 */
#define NV_038_OVERLAY_POINT_V_VALUE_MSK                   0xFFFFFFFF /* 31:0 */ 
#define NV_038_OVERLAY_POINT_V_VALUE_RMSK                  0xFFFFFFFF /* 31:0 */ 
#define NV_038_OVERLAY_POINT_V_VALUE_WORD                  0
#define NV_038_OVERLAY_POINT_V_VALUE_HIGH_FIELD            0x0000001F /* =31 */
#define NV_038_OVERLAY_POINT_V_VALUE_LOW_FIELD             0x00000000 /* =0 */
#define NV_038_OVERLAY_POINT_MSK                           0xFFFFFFFF 
#define NV_088_HIGH_FIELD                                  0x006F1FFF /* =7282687 */
#define NV_088_LOW_FIELD                                   0x006F0000 /* =7274496 */
#define NV_088_NV4_DVD_SUBPICTURE_ADJ                      0x006F0000
#define NV_088_NV4_DVD_SUBPICTURE_MSK                      0x00000000 
#define NV_088_NOP_ADJ                                     0x006F0100
#define NV_088_NOP_PARAMETER_MSK                           0xFFFFFFFF /* 31:0 */ 
#define NV_088_NOP_PARAMETER_RMSK                          0xFFFFFFFF /* 31:0 */ 
#define NV_088_NOP_PARAMETER_WORD                          0
#define NV_088_NOP_PARAMETER_HIGH_FIELD                    0x0000001F /* =31 */
#define NV_088_NOP_PARAMETER_LOW_FIELD                     0x00000000 /* =0 */
#define NV_088_NOP_MSK                                     0xFFFFFFFF 
#define NV_088_NOTIFY_STYLE_MSK                            0xFFFFFFFF /* 31:0 */ 
#define NV_088_NOTIFY_STYLE_RMSK                           0xFFFFFFFF /* 31:0 */ 
#define NV_088_NOTIFY_STYLE_WORD                           0
#define NV_088_NOTIFY_STYLE_HIGH_FIELD                     0x0000001F /* =31 */
#define NV_088_NOTIFY_STYLE_LOW_FIELD                      0x00000000 /* =0 */
#define NV_088_NOTIFY_STYLE_WRITE_ONLY_ADJ                 0x00000000
#define NV_088_NOTIFY_STYLE_WRITE_THEN_AWAKEN_ADJ          0x00000001
#define NV_088_SET_NOTIFY_PARAMETER_MSK                    0xFFFFFFFF /* 31:0 */ 
#define NV_088_SET_NOTIFY_PARAMETER_RMSK                   0xFFFFFFFF /* 31:0 */ 
#define NV_088_SET_NOTIFY_PARAMETER_WORD                   0
#define NV_088_SET_NOTIFY_PARAMETER_HIGH_FIELD             0x0000001F /* =31 */
#define NV_088_SET_NOTIFY_PARAMETER_LOW_FIELD              0x00000000 /* =0 */
#define NV_088_SET_NOTIFY_PARAMETER_WRITE_ADJ              0x00000000
#define NV_088_NOTIFY_MSK                                  0xFFFFFFFF 
#define NV_088_WAIT_FOR_IDLE_PARAMETER_MSK                 0xFFFFFFFF /* 31:0 */ 
#define NV_088_WAIT_FOR_IDLE_PARAMETER_RMSK                0xFFFFFFFF /* 31:0 */ 
#define NV_088_WAIT_FOR_IDLE_PARAMETER_WORD                0
#define NV_088_WAIT_FOR_IDLE_PARAMETER_HIGH_FIELD          0x0000001F /* =31 */
#define NV_088_WAIT_FOR_IDLE_PARAMETER_LOW_FIELD           0x00000000 /* =0 */
#define NV_088_WAIT_FOR_IDLE_MSK                           0xFFFFFFFF 
#define NV_088_SET_CONTEXT_DMA_NOTIFY_PARAMETER_MSK        0xFFFFFFFF /* 31:0 */ 
#define NV_088_SET_CONTEXT_DMA_NOTIFY_PARAMETER_RMSK       0xFFFFFFFF /* 31:0 */ 
#define NV_088_SET_CONTEXT_DMA_NOTIFY_PARAMETER_WORD       0
#define NV_088_SET_CONTEXT_DMA_NOTIFY_PARAMETER_HIGH_FIELD 0x0000001F /* =31 */
#define NV_088_SET_CONTEXT_DMA_NOTIFY_PARAMETER_LOW_FIELD  0x00000000 /* =0 */
#define NV_088_SET_CONTEXT_DMA_NOTIFY_MSK                  0xFFFFFFFF 
#define NV_088_SET_CONTEXT_DMA_OVERLAY_PARAMETER_MSK       0xFFFFFFFF /* 31:0 */ 
#define NV_088_SET_CONTEXT_DMA_OVERLAY_PARAMETER_RMSK      0xFFFFFFFF /* 31:0 */ 
#define NV_088_SET_CONTEXT_DMA_OVERLAY_PARAMETER_WORD      0
#define NV_088_SET_CONTEXT_DMA_OVERLAY_PARAMETER_HIGH_FIELD 0x0000001F /* =31 */
#define NV_088_SET_CONTEXT_DMA_OVERLAY_PARAMETER_LOW_FIELD 0x00000000 /* =0 */
#define NV_088_SET_CONTEXT_DMA_OVERLAY_MSK                 0xFFFFFFFF 
#define NV_088_SET_CONTEXT_DMA_IMAGEIN_PARAMETER_MSK       0xFFFFFFFF /* 31:0 */ 
#define NV_088_SET_CONTEXT_DMA_IMAGEIN_PARAMETER_RMSK      0xFFFFFFFF /* 31:0 */ 
#define NV_088_SET_CONTEXT_DMA_IMAGEIN_PARAMETER_WORD      0
#define NV_088_SET_CONTEXT_DMA_IMAGEIN_PARAMETER_HIGH_FIELD 0x0000001F /* =31 */
#define NV_088_SET_CONTEXT_DMA_IMAGEIN_PARAMETER_LOW_FIELD 0x00000000 /* =0 */
#define NV_088_SET_CONTEXT_DMA_IMAGEIN_MSK                 0xFFFFFFFF 
#define NV_088_SET_CONTEXT_DMA_IMAGEOUT_PARAMETER_MSK      0xFFFFFFFF /* 31:0 */ 
#define NV_088_SET_CONTEXT_DMA_IMAGEOUT_PARAMETER_RMSK     0xFFFFFFFF /* 31:0 */ 
#define NV_088_SET_CONTEXT_DMA_IMAGEOUT_PARAMETER_WORD     0
#define NV_088_SET_CONTEXT_DMA_IMAGEOUT_PARAMETER_HIGH_FIELD 0x0000001F /* =31 */
#define NV_088_SET_CONTEXT_DMA_IMAGEOUT_PARAMETER_LOW_FIELD 0x00000000 /* =0 */
#define NV_088_SET_CONTEXT_DMA_IMAGEOUT_MSK                0xFFFFFFFF 
#define NV_088_IMAGEOUT_POINT_X_MSK                        0x0000FFFF /* 15:0 */ 
#define NV_088_IMAGEOUT_POINT_X_RMSK                       0x0000FFFF /* 15:0 */ 
#define NV_088_IMAGEOUT_POINT_X_WORD                       0
#define NV_088_IMAGEOUT_POINT_X_HIGH_FIELD                 0x0000000F /* =15 */
#define NV_088_IMAGEOUT_POINT_X_LOW_FIELD                  0x00000000 /* =0 */
#define NV_088_IMAGEOUT_POINT_Y_MSK                        0xFFFF0000 /* 31:16 */ 
#define NV_088_IMAGEOUT_POINT_Y_RMSK                       0x0000FFFF /* 31:16 */ 
#define NV_088_IMAGEOUT_POINT_Y_WORD                       0
#define NV_088_IMAGEOUT_POINT_Y_HIGH_FIELD                 0x0000001F /* =31 */
#define NV_088_IMAGEOUT_POINT_Y_LOW_FIELD                  0x00000010 /* =16 */
#define NV_088_IMAGEOUT_POINT_MSK                          0xFFFFFFFF 
#define NV_088_IMAGEOUT_SIZE_WIDTH_MSK                     0x0000FFFF /* 15:0 */ 
#define NV_088_IMAGEOUT_SIZE_WIDTH_RMSK                    0x0000FFFF /* 15:0 */ 
#define NV_088_IMAGEOUT_SIZE_WIDTH_WORD                    0
#define NV_088_IMAGEOUT_SIZE_WIDTH_HIGH_FIELD              0x0000000F /* =15 */
#define NV_088_IMAGEOUT_SIZE_WIDTH_LOW_FIELD               0x00000000 /* =0 */
#define NV_088_IMAGEOUT_SIZE_HEIGHT_MSK                    0xFFFF0000 /* 31:16 */ 
#define NV_088_IMAGEOUT_SIZE_HEIGHT_RMSK                   0x0000FFFF /* 31:16 */ 
#define NV_088_IMAGEOUT_SIZE_HEIGHT_WORD                   0
#define NV_088_IMAGEOUT_SIZE_HEIGHT_HIGH_FIELD             0x0000001F /* =31 */
#define NV_088_IMAGEOUT_SIZE_HEIGHT_LOW_FIELD              0x00000010 /* =16 */
#define NV_088_IMAGEOUT_SIZE_MSK                           0xFFFFFFFF 
#define NV_088_IMAGEOUT_FMT_PITCH_MSK                      0x0000FFFF /* 15:0 */ 
#define NV_088_IMAGEOUT_FMT_PITCH_RMSK                     0x0000FFFF /* 15:0 */ 
#define NV_088_IMAGEOUT_FMT_PITCH_WORD                     0
#define NV_088_IMAGEOUT_FMT_PITCH_HIGH_FIELD               0x0000000F /* =15 */
#define NV_088_IMAGEOUT_FMT_PITCH_LOW_FIELD                0x00000000 /* =0 */
#define NV_088_IMAGEOUT_FMT_COLOR_MSK                      0xFFFF0000 /* 31:16 */ 
#define NV_088_IMAGEOUT_FMT_COLOR_RMSK                     0x0000FFFF /* 31:16 */ 
#define NV_088_IMAGEOUT_FMT_COLOR_WORD                     0
#define NV_088_IMAGEOUT_FMT_COLOR_HIGH_FIELD               0x0000001F /* =31 */
#define NV_088_IMAGEOUT_FMT_COLOR_LOW_FIELD                0x00000010 /* =16 */
#define NV_088_IMAGEOUT_FMT_COLOR_INVALID_ADJ              0x00000000
#define NV_088_IMAGEOUT_FMT_COLOR_LE_V8YB8U8YA8_ADJ        0x00010000
#define NV_088_IMAGEOUT_FMT_COLOR_LE_YB8V8YA8U8_ADJ        0x00020000
#define NV_088_IMAGEOUT_FMT_MSK                            0xFFFFFFFF 
#define NV_088_IMAGEOUT_OFFSET_VALUE_MSK                   0xFFFFFFFF /* 31:0 */ 
#define NV_088_IMAGEOUT_OFFSET_VALUE_RMSK                  0xFFFFFFFF /* 31:0 */ 
#define NV_088_IMAGEOUT_OFFSET_VALUE_WORD                  0
#define NV_088_IMAGEOUT_OFFSET_VALUE_HIGH_FIELD            0x0000001F /* =31 */
#define NV_088_IMAGEOUT_OFFSET_VALUE_LOW_FIELD             0x00000000 /* =0 */
#define NV_088_IMAGEOUT_OFFSET_MSK                         0xFFFFFFFF 
#define NV_088_IMAGEIN_DELTA_DU_DX_R_FRACTION_MSK          0x000FFFFF /* 19:0 */ 
#define NV_088_IMAGEIN_DELTA_DU_DX_R_FRACTION_RMSK         0x000FFFFF /* 19:0 */ 
#define NV_088_IMAGEIN_DELTA_DU_DX_R_FRACTION_WORD         0
#define NV_088_IMAGEIN_DELTA_DU_DX_R_FRACTION_HIGH_FIELD   0x00000013 /* =19 */
#define NV_088_IMAGEIN_DELTA_DU_DX_R_FRACTION_LOW_FIELD    0x00000000 /* =0 */
#define NV_088_IMAGEIN_DELTA_DU_DX_R_INT_MSK               0xFFF00000 /* 31:20 */ 
#define NV_088_IMAGEIN_DELTA_DU_DX_R_INT_RMSK              0x00000FFF /* 31:20 */ 
#define NV_088_IMAGEIN_DELTA_DU_DX_R_INT_WORD              0
#define NV_088_IMAGEIN_DELTA_DU_DX_R_INT_HIGH_FIELD        0x0000001F /* =31 */
#define NV_088_IMAGEIN_DELTA_DU_DX_R_INT_LOW_FIELD         0x00000014 /* =20 */
#define NV_088_IMAGEIN_DELTA_DU_DX_R_MSK                   0xFFFFFFFF /* 31:0 */ 
#define NV_088_IMAGEIN_DELTA_DU_DX_R_RMSK                  0xFFFFFFFF /* 31:0 */ 
#define NV_088_IMAGEIN_DELTA_DU_DX_R_WORD                  0
#define NV_088_IMAGEIN_DELTA_DU_DX_R_HIGH_FIELD            0x0000001F /* =31 */
#define NV_088_IMAGEIN_DELTA_DU_DX_R_LOW_FIELD             0x00000000 /* =0 */
#define NV_088_IMAGEIN_DELTA_DU_DX_MSK                     0xFFFFFFFF 
#define NV_088_IMAGEIN_DELTA_DV_DY_R_FRACTION_MSK          0x000FFFFF /* 19:0 */ 
#define NV_088_IMAGEIN_DELTA_DV_DY_R_FRACTION_RMSK         0x000FFFFF /* 19:0 */ 
#define NV_088_IMAGEIN_DELTA_DV_DY_R_FRACTION_WORD         0
#define NV_088_IMAGEIN_DELTA_DV_DY_R_FRACTION_HIGH_FIELD   0x00000013 /* =19 */
#define NV_088_IMAGEIN_DELTA_DV_DY_R_FRACTION_LOW_FIELD    0x00000000 /* =0 */
#define NV_088_IMAGEIN_DELTA_DV_DY_R_INT_MSK               0xFFF00000 /* 31:20 */ 
#define NV_088_IMAGEIN_DELTA_DV_DY_R_INT_RMSK              0x00000FFF /* 31:20 */ 
#define NV_088_IMAGEIN_DELTA_DV_DY_R_INT_WORD              0
#define NV_088_IMAGEIN_DELTA_DV_DY_R_INT_HIGH_FIELD        0x0000001F /* =31 */
#define NV_088_IMAGEIN_DELTA_DV_DY_R_INT_LOW_FIELD         0x00000014 /* =20 */
#define NV_088_IMAGEIN_DELTA_DV_DY_R_MSK                   0xFFFFFFFF /* 31:0 */ 
#define NV_088_IMAGEIN_DELTA_DV_DY_R_RMSK                  0xFFFFFFFF /* 31:0 */ 
#define NV_088_IMAGEIN_DELTA_DV_DY_R_WORD                  0
#define NV_088_IMAGEIN_DELTA_DV_DY_R_HIGH_FIELD            0x0000001F /* =31 */
#define NV_088_IMAGEIN_DELTA_DV_DY_R_LOW_FIELD             0x00000000 /* =0 */
#define NV_088_IMAGEIN_DELTA_DV_DY_MSK                     0xFFFFFFFF 
#define NV_088_IMAGEIN_SIZE_WIDTH_MSK                      0x0000FFFF /* 15:0 */ 
#define NV_088_IMAGEIN_SIZE_WIDTH_RMSK                     0x0000FFFF /* 15:0 */ 
#define NV_088_IMAGEIN_SIZE_WIDTH_WORD                     0
#define NV_088_IMAGEIN_SIZE_WIDTH_HIGH_FIELD               0x0000000F /* =15 */
#define NV_088_IMAGEIN_SIZE_WIDTH_LOW_FIELD                0x00000000 /* =0 */
#define NV_088_IMAGEIN_SIZE_HEIGHT_MSK                     0xFFFF0000 /* 31:16 */ 
#define NV_088_IMAGEIN_SIZE_HEIGHT_RMSK                    0x0000FFFF /* 31:16 */ 
#define NV_088_IMAGEIN_SIZE_HEIGHT_WORD                    0
#define NV_088_IMAGEIN_SIZE_HEIGHT_HIGH_FIELD              0x0000001F /* =31 */
#define NV_088_IMAGEIN_SIZE_HEIGHT_LOW_FIELD               0x00000010 /* =16 */
#define NV_088_IMAGEIN_SIZE_MSK                            0xFFFFFFFF 
#define NV_088_IMAGEIN_FMT_PITCH_MSK                       0x0000FFFF /* 15:0 */ 
#define NV_088_IMAGEIN_FMT_PITCH_RMSK                      0x0000FFFF /* 15:0 */ 
#define NV_088_IMAGEIN_FMT_PITCH_WORD                      0
#define NV_088_IMAGEIN_FMT_PITCH_HIGH_FIELD                0x0000000F /* =15 */
#define NV_088_IMAGEIN_FMT_PITCH_LOW_FIELD                 0x00000000 /* =0 */
#define NV_088_IMAGEIN_FMT_COLOR_MSK                       0xFFFF0000 /* 31:16 */ 
#define NV_088_IMAGEIN_FMT_COLOR_RMSK                      0x0000FFFF /* 31:16 */ 
#define NV_088_IMAGEIN_FMT_COLOR_WORD                      0
#define NV_088_IMAGEIN_FMT_COLOR_HIGH_FIELD                0x0000001F /* =31 */
#define NV_088_IMAGEIN_FMT_COLOR_LOW_FIELD                 0x00000010 /* =16 */
#define NV_088_IMAGEIN_FMT_COLOR_INVALID_ADJ               0x00000000
#define NV_088_IMAGEIN_FMT_COLOR_LE_V8YB8U8YA8_ADJ         0x00010000
#define NV_088_IMAGEIN_FMT_COLOR_LE_YB8V8YA8U8_ADJ         0x00020000
#define NV_088_IMAGEIN_FMT_MSK                             0xFFFFFFFF 
#define NV_088_IMAGEIN_OFFSET_VALUE_MSK                    0xFFFFFFFF /* 31:0 */ 
#define NV_088_IMAGEIN_OFFSET_VALUE_RMSK                   0xFFFFFFFF /* 31:0 */ 
#define NV_088_IMAGEIN_OFFSET_VALUE_WORD                   0
#define NV_088_IMAGEIN_OFFSET_VALUE_HIGH_FIELD             0x0000001F /* =31 */
#define NV_088_IMAGEIN_OFFSET_VALUE_LOW_FIELD              0x00000000 /* =0 */
#define NV_088_IMAGEIN_OFFSET_MSK                          0xFFFFFFFF 
#define NV_088_IMAGEIN_POINT_U_FRACTION_MSK                0x0000000F /* 3:0 */ 
#define NV_088_IMAGEIN_POINT_U_FRACTION_RMSK               0x0000000F /* 3:0 */ 
#define NV_088_IMAGEIN_POINT_U_FRACTION_WORD               0
#define NV_088_IMAGEIN_POINT_U_FRACTION_HIGH_FIELD         0x00000003 /* =3 */
#define NV_088_IMAGEIN_POINT_U_FRACTION_LOW_FIELD          0x00000000 /* =0 */
#define NV_088_IMAGEIN_POINT_U_INT_MSK                     0x0000FFF0 /* 15:4 */ 
#define NV_088_IMAGEIN_POINT_U_INT_RMSK                    0x00000FFF /* 15:4 */ 
#define NV_088_IMAGEIN_POINT_U_INT_WORD                    0
#define NV_088_IMAGEIN_POINT_U_INT_HIGH_FIELD              0x0000000F /* =15 */
#define NV_088_IMAGEIN_POINT_U_INT_LOW_FIELD               0x00000004 /* =4 */
#define NV_088_IMAGEIN_POINT_U_VALUE_MSK                   0x0000FFFF /* 15:0 */ 
#define NV_088_IMAGEIN_POINT_U_VALUE_RMSK                  0x0000FFFF /* 15:0 */ 
#define NV_088_IMAGEIN_POINT_U_VALUE_WORD                  0
#define NV_088_IMAGEIN_POINT_U_VALUE_HIGH_FIELD            0x0000000F /* =15 */
#define NV_088_IMAGEIN_POINT_U_VALUE_LOW_FIELD             0x00000000 /* =0 */
#define NV_088_IMAGEIN_POINT_V_FRACTION_MSK                0x000F0000 /* 19:16 */ 
#define NV_088_IMAGEIN_POINT_V_FRACTION_RMSK               0x0000000F /* 19:16 */ 
#define NV_088_IMAGEIN_POINT_V_FRACTION_WORD               0
#define NV_088_IMAGEIN_POINT_V_FRACTION_HIGH_FIELD         0x00000013 /* =19 */
#define NV_088_IMAGEIN_POINT_V_FRACTION_LOW_FIELD          0x00000010 /* =16 */
#define NV_088_IMAGEIN_POINT_V_INT_MSK                     0xFFF00000 /* 31:20 */ 
#define NV_088_IMAGEIN_POINT_V_INT_RMSK                    0x00000FFF /* 31:20 */ 
#define NV_088_IMAGEIN_POINT_V_INT_WORD                    0
#define NV_088_IMAGEIN_POINT_V_INT_HIGH_FIELD              0x0000001F /* =31 */
#define NV_088_IMAGEIN_POINT_V_INT_LOW_FIELD               0x00000014 /* =20 */
#define NV_088_IMAGEIN_POINT_V_VALUE_MSK                   0xFFFFFFFF /* 31:0 */ 
#define NV_088_IMAGEIN_POINT_V_VALUE_RMSK                  0xFFFFFFFF /* 31:0 */ 
#define NV_088_IMAGEIN_POINT_V_VALUE_WORD                  0
#define NV_088_IMAGEIN_POINT_V_VALUE_HIGH_FIELD            0x0000001F /* =31 */
#define NV_088_IMAGEIN_POINT_V_VALUE_LOW_FIELD             0x00000000 /* =0 */
#define NV_088_IMAGEIN_POINT_MSK                           0xFFFFFFFF 
#define NV_088_OVERLAY_DELTA_DU_DX_R_FRACTION_MSK          0x000FFFFF /* 19:0 */ 
#define NV_088_OVERLAY_DELTA_DU_DX_R_FRACTION_RMSK         0x000FFFFF /* 19:0 */ 
#define NV_088_OVERLAY_DELTA_DU_DX_R_FRACTION_WORD         0
#define NV_088_OVERLAY_DELTA_DU_DX_R_FRACTION_HIGH_FIELD   0x00000013 /* =19 */
#define NV_088_OVERLAY_DELTA_DU_DX_R_FRACTION_LOW_FIELD    0x00000000 /* =0 */
#define NV_088_OVERLAY_DELTA_DU_DX_R_INT_MSK               0xFFF00000 /* 31:20 */ 
#define NV_088_OVERLAY_DELTA_DU_DX_R_INT_RMSK              0x00000FFF /* 31:20 */ 
#define NV_088_OVERLAY_DELTA_DU_DX_R_INT_WORD              0
#define NV_088_OVERLAY_DELTA_DU_DX_R_INT_HIGH_FIELD        0x0000001F /* =31 */
#define NV_088_OVERLAY_DELTA_DU_DX_R_INT_LOW_FIELD         0x00000014 /* =20 */
#define NV_088_OVERLAY_DELTA_DU_DX_R_MSK                   0xFFFFFFFF /* 31:0 */ 
#define NV_088_OVERLAY_DELTA_DU_DX_R_RMSK                  0xFFFFFFFF /* 31:0 */ 
#define NV_088_OVERLAY_DELTA_DU_DX_R_WORD                  0
#define NV_088_OVERLAY_DELTA_DU_DX_R_HIGH_FIELD            0x0000001F /* =31 */
#define NV_088_OVERLAY_DELTA_DU_DX_R_LOW_FIELD             0x00000000 /* =0 */
#define NV_088_OVERLAY_DELTA_DU_DX_MSK                     0xFFFFFFFF 
#define NV_088_OVERLAY_DELTA_DV_DY_R_FRACTION_MSK          0x000FFFFF /* 19:0 */ 
#define NV_088_OVERLAY_DELTA_DV_DY_R_FRACTION_RMSK         0x000FFFFF /* 19:0 */ 
#define NV_088_OVERLAY_DELTA_DV_DY_R_FRACTION_WORD         0
#define NV_088_OVERLAY_DELTA_DV_DY_R_FRACTION_HIGH_FIELD   0x00000013 /* =19 */
#define NV_088_OVERLAY_DELTA_DV_DY_R_FRACTION_LOW_FIELD    0x00000000 /* =0 */
#define NV_088_OVERLAY_DELTA_DV_DY_R_INT_MSK               0xFFF00000 /* 31:20 */ 
#define NV_088_OVERLAY_DELTA_DV_DY_R_INT_RMSK              0x00000FFF /* 31:20 */ 
#define NV_088_OVERLAY_DELTA_DV_DY_R_INT_WORD              0
#define NV_088_OVERLAY_DELTA_DV_DY_R_INT_HIGH_FIELD        0x0000001F /* =31 */
#define NV_088_OVERLAY_DELTA_DV_DY_R_INT_LOW_FIELD         0x00000014 /* =20 */
#define NV_088_OVERLAY_DELTA_DV_DY_R_MSK                   0xFFFFFFFF /* 31:0 */ 
#define NV_088_OVERLAY_DELTA_DV_DY_R_RMSK                  0xFFFFFFFF /* 31:0 */ 
#define NV_088_OVERLAY_DELTA_DV_DY_R_WORD                  0
#define NV_088_OVERLAY_DELTA_DV_DY_R_HIGH_FIELD            0x0000001F /* =31 */
#define NV_088_OVERLAY_DELTA_DV_DY_R_LOW_FIELD             0x00000000 /* =0 */
#define NV_088_OVERLAY_DELTA_DV_DY_MSK                     0xFFFFFFFF 
#define NV_088_OVERLAY_SIZE_WIDTH_MSK                      0x0000FFFF /* 15:0 */ 
#define NV_088_OVERLAY_SIZE_WIDTH_RMSK                     0x0000FFFF /* 15:0 */ 
#define NV_088_OVERLAY_SIZE_WIDTH_WORD                     0
#define NV_088_OVERLAY_SIZE_WIDTH_HIGH_FIELD               0x0000000F /* =15 */
#define NV_088_OVERLAY_SIZE_WIDTH_LOW_FIELD                0x00000000 /* =0 */
#define NV_088_OVERLAY_SIZE_HEIGHT_MSK                     0xFFFF0000 /* 31:16 */ 
#define NV_088_OVERLAY_SIZE_HEIGHT_RMSK                    0x0000FFFF /* 31:16 */ 
#define NV_088_OVERLAY_SIZE_HEIGHT_WORD                    0
#define NV_088_OVERLAY_SIZE_HEIGHT_HIGH_FIELD              0x0000001F /* =31 */
#define NV_088_OVERLAY_SIZE_HEIGHT_LOW_FIELD               0x00000010 /* =16 */
#define NV_088_OVERLAY_SIZE_MSK                            0xFFFFFFFF 
#define NV_088_OVERLAY_FMT_PITCH_MSK                       0x0000FFFF /* 15:0 */ 
#define NV_088_OVERLAY_FMT_PITCH_RMSK                      0x0000FFFF /* 15:0 */ 
#define NV_088_OVERLAY_FMT_PITCH_WORD                      0
#define NV_088_OVERLAY_FMT_PITCH_HIGH_FIELD                0x0000000F /* =15 */
#define NV_088_OVERLAY_FMT_PITCH_LOW_FIELD                 0x00000000 /* =0 */
#define NV_088_OVERLAY_FMT_COLOR_MSK                       0xFFFF0000 /* 31:16 */ 
#define NV_088_OVERLAY_FMT_COLOR_RMSK                      0x0000FFFF /* 31:16 */ 
#define NV_088_OVERLAY_FMT_COLOR_WORD                      0
#define NV_088_OVERLAY_FMT_COLOR_HIGH_FIELD                0x0000001F /* =31 */
#define NV_088_OVERLAY_FMT_COLOR_LOW_FIELD                 0x00000010 /* =16 */
#define NV_088_OVERLAY_FMT_COLOR_INVALID_ADJ               0x00000000
#define NV_088_OVERLAY_FMT_COLOR_LE_A8V8U8Y8_ADJ           0x00010000
#define NV_088_OVERLAY_FMT_COLOR_LE_A4V6YB6A4U6YA6_ADJ     0x00020000
#define NV_088_OVERLAY_FMT_COLOR_LE_TRANSPARENT_ADJ        0x00030000
#define NV_088_OVERLAY_FMT_MSK                             0xFFFFFFFF 
#define NV_088_OVERLAY_OFFSET_VALUE_MSK                    0xFFFFFFFF /* 31:0 */ 
#define NV_088_OVERLAY_OFFSET_VALUE_RMSK                   0xFFFFFFFF /* 31:0 */ 
#define NV_088_OVERLAY_OFFSET_VALUE_WORD                   0
#define NV_088_OVERLAY_OFFSET_VALUE_HIGH_FIELD             0x0000001F /* =31 */
#define NV_088_OVERLAY_OFFSET_VALUE_LOW_FIELD              0x00000000 /* =0 */
#define NV_088_OVERLAY_OFFSET_MSK                          0xFFFFFFFF 
#define NV_088_OVERLAY_POINT_U_FRACTION_MSK                0x0000000F /* 3:0 */ 
#define NV_088_OVERLAY_POINT_U_FRACTION_RMSK               0x0000000F /* 3:0 */ 
#define NV_088_OVERLAY_POINT_U_FRACTION_WORD               0
#define NV_088_OVERLAY_POINT_U_FRACTION_HIGH_FIELD         0x00000003 /* =3 */
#define NV_088_OVERLAY_POINT_U_FRACTION_LOW_FIELD          0x00000000 /* =0 */
#define NV_088_OVERLAY_POINT_U_INT_MSK                     0x0000FFF0 /* 15:4 */ 
#define NV_088_OVERLAY_POINT_U_INT_RMSK                    0x00000FFF /* 15:4 */ 
#define NV_088_OVERLAY_POINT_U_INT_WORD                    0
#define NV_088_OVERLAY_POINT_U_INT_HIGH_FIELD              0x0000000F /* =15 */
#define NV_088_OVERLAY_POINT_U_INT_LOW_FIELD               0x00000004 /* =4 */
#define NV_088_OVERLAY_POINT_U_VALUE_MSK                   0x0000FFFF /* 15:0 */ 
#define NV_088_OVERLAY_POINT_U_VALUE_RMSK                  0x0000FFFF /* 15:0 */ 
#define NV_088_OVERLAY_POINT_U_VALUE_WORD                  0
#define NV_088_OVERLAY_POINT_U_VALUE_HIGH_FIELD            0x0000000F /* =15 */
#define NV_088_OVERLAY_POINT_U_VALUE_LOW_FIELD             0x00000000 /* =0 */
#define NV_088_OVERLAY_POINT_V_FRACTION_MSK                0x000F0000 /* 19:16 */ 
#define NV_088_OVERLAY_POINT_V_FRACTION_RMSK               0x0000000F /* 19:16 */ 
#define NV_088_OVERLAY_POINT_V_FRACTION_WORD               0
#define NV_088_OVERLAY_POINT_V_FRACTION_HIGH_FIELD         0x00000013 /* =19 */
#define NV_088_OVERLAY_POINT_V_FRACTION_LOW_FIELD          0x00000010 /* =16 */
#define NV_088_OVERLAY_POINT_V_INT_MSK                     0xFFF00000 /* 31:20 */ 
#define NV_088_OVERLAY_POINT_V_INT_RMSK                    0x00000FFF /* 31:20 */ 
#define NV_088_OVERLAY_POINT_V_INT_WORD                    0
#define NV_088_OVERLAY_POINT_V_INT_HIGH_FIELD              0x0000001F /* =31 */
#define NV_088_OVERLAY_POINT_V_INT_LOW_FIELD               0x00000014 /* =20 */
#define NV_088_OVERLAY_POINT_V_VALUE_MSK                   0xFFFFFFFF /* 31:0 */ 
#define NV_088_OVERLAY_POINT_V_VALUE_RMSK                  0xFFFFFFFF /* 31:0 */ 
#define NV_088_OVERLAY_POINT_V_VALUE_WORD                  0
#define NV_088_OVERLAY_POINT_V_VALUE_HIGH_FIELD            0x0000001F /* =31 */
#define NV_088_OVERLAY_POINT_V_VALUE_LOW_FIELD             0x00000000 /* =0 */
#define NV_088_OVERLAY_POINT_MSK                           0xFFFFFFFF 
#define NV_042_HIGH_FIELD                                  0x00611FFF /* =6365183 */
#define NV_042_LOW_FIELD                                   0x00610000 /* =6356992 */
#define NV_042_NV4_SURFACE_ADJ                             0x00610000
#define NV_042_NV4_SURFACE_MSK                             0x00000000 
#define NV_042_NOP_ADJ                                     0x00610100
#define NV_042_NOP_PARAMETER_MSK                           0xFFFFFFFF /* 31:0 */ 
#define NV_042_NOP_PARAMETER_RMSK                          0xFFFFFFFF /* 31:0 */ 
#define NV_042_NOP_PARAMETER_WORD                          0
#define NV_042_NOP_PARAMETER_HIGH_FIELD                    0x0000001F /* =31 */
#define NV_042_NOP_PARAMETER_LOW_FIELD                     0x00000000 /* =0 */
#define NV_042_NOP_MSK                                     0xFFFFFFFF 
#define NV_042_PM_TRIGGER_PARAMETER_MSK                    0xFFFFFFFF /* 31:0 */ 
#define NV_042_PM_TRIGGER_PARAMETER_RMSK                   0xFFFFFFFF /* 31:0 */ 
#define NV_042_PM_TRIGGER_PARAMETER_WORD                   0
#define NV_042_PM_TRIGGER_PARAMETER_HIGH_FIELD             0x0000001F /* =31 */
#define NV_042_PM_TRIGGER_PARAMETER_LOW_FIELD              0x00000000 /* =0 */
#define NV_042_PM_TRIGGER_MSK                              0xFFFFFFFF 
#define NV_042_NOTIFY_STYLE_MSK                            0xFFFFFFFF /* 31:0 */ 
#define NV_042_NOTIFY_STYLE_RMSK                           0xFFFFFFFF /* 31:0 */ 
#define NV_042_NOTIFY_STYLE_WORD                           0
#define NV_042_NOTIFY_STYLE_HIGH_FIELD                     0x0000001F /* =31 */
#define NV_042_NOTIFY_STYLE_LOW_FIELD                      0x00000000 /* =0 */
#define NV_042_NOTIFY_STYLE_WRITE_ONLY_ADJ                 0x00000000
#define NV_042_NOTIFY_STYLE_WRITE_THEN_AWAKEN_ADJ          0x00000001
#define NV_042_NOTIFY_MSK                                  0xFFFFFFFF 
#define NV_042_SET_NOTIFY_PARAMETER_MSK                    0xFFFFFFFF /* 31:0 */ 
#define NV_042_SET_NOTIFY_PARAMETER_RMSK                   0xFFFFFFFF /* 31:0 */ 
#define NV_042_SET_NOTIFY_PARAMETER_WORD                   0
#define NV_042_SET_NOTIFY_PARAMETER_HIGH_FIELD             0x0000001F /* =31 */
#define NV_042_SET_NOTIFY_PARAMETER_LOW_FIELD              0x00000000 /* =0 */
#define NV_042_SET_NOTIFY_PARAMETER_WRITE_ADJ              0x00000000
#define NV_042_SET_NOTIFY_MSK                              0xFFFFFFFF 
#define NV_042_SET_CONTEXT_DMA_NOTIFY_PARAMETER_MSK        0xFFFFFFFF /* 31:0 */ 
#define NV_042_SET_CONTEXT_DMA_NOTIFY_PARAMETER_RMSK       0xFFFFFFFF /* 31:0 */ 
#define NV_042_SET_CONTEXT_DMA_NOTIFY_PARAMETER_WORD       0
#define NV_042_SET_CONTEXT_DMA_NOTIFY_PARAMETER_HIGH_FIELD 0x0000001F /* =31 */
#define NV_042_SET_CONTEXT_DMA_NOTIFY_PARAMETER_LOW_FIELD  0x00000000 /* =0 */
#define NV_042_SET_CONTEXT_DMA_NOTIFY_MSK                  0xFFFFFFFF 
#define NV_042_SET_CONTEXT_DMA_IMAGE_SOURCE_PARAMETER_MSK  0xFFFFFFFF /* 31:0 */ 
#define NV_042_SET_CONTEXT_DMA_IMAGE_SOURCE_PARAMETER_RMSK 0xFFFFFFFF /* 31:0 */ 
#define NV_042_SET_CONTEXT_DMA_IMAGE_SOURCE_PARAMETER_WORD 0
#define NV_042_SET_CONTEXT_DMA_IMAGE_SOURCE_PARAMETER_HIGH_FIELD 0x0000001F /* =31 */
#define NV_042_SET_CONTEXT_DMA_IMAGE_SOURCE_PARAMETER_LOW_FIELD 0x00000000 /* =0 */
#define NV_042_SET_CONTEXT_DMA_IMAGE_SOURCE_MSK            0xFFFFFFFF 
#define NV_042_SET_CONTEXT_DMA_IMAGE_DESTIN_PARAMETER_MSK  0xFFFFFFFF /* 31:0 */ 
#define NV_042_SET_CONTEXT_DMA_IMAGE_DESTIN_PARAMETER_RMSK 0xFFFFFFFF /* 31:0 */ 
#define NV_042_SET_CONTEXT_DMA_IMAGE_DESTIN_PARAMETER_WORD 0
#define NV_042_SET_CONTEXT_DMA_IMAGE_DESTIN_PARAMETER_HIGH_FIELD 0x0000001F /* =31 */
#define NV_042_SET_CONTEXT_DMA_IMAGE_DESTIN_PARAMETER_LOW_FIELD 0x00000000 /* =0 */
#define NV_042_SET_CONTEXT_DMA_IMAGE_DESTIN_MSK            0xFFFFFFFF 
#define NV_042_SET_IMAGE_OUTPUT_SOURCE_PARAMETER_MSK       0xFFFFFFFF /* 31:0 */ 
#define NV_042_SET_IMAGE_OUTPUT_SOURCE_PARAMETER_RMSK      0xFFFFFFFF /* 31:0 */ 
#define NV_042_SET_IMAGE_OUTPUT_SOURCE_PARAMETER_WORD      0
#define NV_042_SET_IMAGE_OUTPUT_SOURCE_PARAMETER_HIGH_FIELD 0x0000001F /* =31 */
#define NV_042_SET_IMAGE_OUTPUT_SOURCE_PARAMETER_LOW_FIELD 0x00000000 /* =0 */
#define NV_042_SET_IMAGE_OUTPUT_SOURCE_MSK                 0xFFFFFFFF 
#define NV_042_SET_IMAGE_OUTPUT_DESTIN_PARAMETER_MSK       0xFFFFFFFF /* 31:0 */ 
#define NV_042_SET_IMAGE_OUTPUT_DESTIN_PARAMETER_RMSK      0xFFFFFFFF /* 31:0 */ 
#define NV_042_SET_IMAGE_OUTPUT_DESTIN_PARAMETER_WORD      0
#define NV_042_SET_IMAGE_OUTPUT_DESTIN_PARAMETER_HIGH_FIELD 0x0000001F /* =31 */
#define NV_042_SET_IMAGE_OUTPUT_DESTIN_PARAMETER_LOW_FIELD 0x00000000 /* =0 */
#define NV_042_SET_IMAGE_OUTPUT_DESTIN_MSK                 0xFFFFFFFF 
#define NV_042_SET_IMAGE_INPUT_DESTIN_PARAMETER_MSK        0xFFFFFFFF /* 31:0 */ 
#define NV_042_SET_IMAGE_INPUT_DESTIN_PARAMETER_RMSK       0xFFFFFFFF /* 31:0 */ 
#define NV_042_SET_IMAGE_INPUT_DESTIN_PARAMETER_WORD       0
#define NV_042_SET_IMAGE_INPUT_DESTIN_PARAMETER_HIGH_FIELD 0x0000001F /* =31 */
#define NV_042_SET_IMAGE_INPUT_DESTIN_PARAMETER_LOW_FIELD  0x00000000 /* =0 */
#define NV_042_SET_IMAGE_INPUT_DESTIN_MSK                  0xFFFFFFFF 
#define NV_042_FMT_VALUE_MSK                               0xFFFFFFFF /* 31:0 */ 
#define NV_042_FMT_VALUE_RMSK                              0xFFFFFFFF /* 31:0 */ 
#define NV_042_FMT_VALUE_WORD                              0
#define NV_042_FMT_VALUE_HIGH_FIELD                        0x0000001F /* =31 */
#define NV_042_FMT_VALUE_LOW_FIELD                         0x00000000 /* =0 */
#define NV_042_FMT_VALUE_LE_Y8_ADJ                         0x00000001
#define NV_042_FMT_VALUE_LE_X1R5G5B5_Z1R5G5B5_ADJ          0x00000002
#define NV_042_FMT_VALUE_LE_X1R5G5B5_O1R5G5B5_ADJ          0x00000003
#define NV_042_FMT_VALUE_LE_R5G6B5_ADJ                     0x00000004
#define NV_042_FMT_VALUE_LE_Y16_ADJ                        0x00000005
#define NV_042_FMT_VALUE_LE_X8R8G8B8_Z8R8G8B8_ADJ          0x00000006
#define NV_042_FMT_VALUE_LE_X8R8G8B8_O8R8G8B8_ADJ          0x00000007
#define NV_042_FMT_VALUE_LE_X1A7R8G8B8_Z1A7R8G8B8_ADJ      0x00000008
#define NV_042_FMT_VALUE_LE_X1A7R8G8B8_O1A7R8G8B8_ADJ      0x00000009
#define NV_042_FMT_VALUE_LE_A8R8G8B8_ADJ                   0x0000000A
#define NV_042_FMT_VALUE_LE_Y32_ADJ                        0x0000000B
#define NV_042_FMT_MSK                                     0xFFFFFFFF 
#define NV_042_PITCH_SOURCE_MSK                            0x0000FFFF /* 15:0 */ 
#define NV_042_PITCH_SOURCE_RMSK                           0x0000FFFF /* 15:0 */ 
#define NV_042_PITCH_SOURCE_WORD                           0
#define NV_042_PITCH_SOURCE_HIGH_FIELD                     0x0000000F /* =15 */
#define NV_042_PITCH_SOURCE_LOW_FIELD                      0x00000000 /* =0 */
#define NV_042_PITCH_DESTIN_MSK                            0xFFFF0000 /* 31:16 */ 
#define NV_042_PITCH_DESTIN_RMSK                           0x0000FFFF /* 31:16 */ 
#define NV_042_PITCH_DESTIN_WORD                           0
#define NV_042_PITCH_DESTIN_HIGH_FIELD                     0x0000001F /* =31 */
#define NV_042_PITCH_DESTIN_LOW_FIELD                      0x00000010 /* =16 */
#define NV_042_PITCH_MSK                                   0xFFFFFFFF 
#define NV_042_OFFSET_SOURCE_LINADRS_MSK                   0xFFFFFFFF /* 31:0 */ 
#define NV_042_OFFSET_SOURCE_LINADRS_RMSK                  0xFFFFFFFF /* 31:0 */ 
#define NV_042_OFFSET_SOURCE_LINADRS_WORD                  0
#define NV_042_OFFSET_SOURCE_LINADRS_HIGH_FIELD            0x0000001F /* =31 */
#define NV_042_OFFSET_SOURCE_LINADRS_LOW_FIELD             0x00000000 /* =0 */
#define NV_042_OFFSET_SOURCE_LINADRS_0_ADJ                 0x00000000
#define NV_042_OFFSET_SOURCE_MSK                           0xFFFFFFFF 
#define NV_042_OFFSET_DESTIN_LINADRS_MSK                   0xFFFFFFFF /* 31:0 */ 
#define NV_042_OFFSET_DESTIN_LINADRS_RMSK                  0xFFFFFFFF /* 31:0 */ 
#define NV_042_OFFSET_DESTIN_LINADRS_WORD                  0
#define NV_042_OFFSET_DESTIN_LINADRS_HIGH_FIELD            0x0000001F /* =31 */
#define NV_042_OFFSET_DESTIN_LINADRS_LOW_FIELD             0x00000000 /* =0 */
#define NV_042_OFFSET_DESTIN_LINADRS_0_ADJ                 0x00000000
#define NV_042_OFFSET_DESTIN_MSK                           0xFFFFFFFF 
#define NV_062_HIGH_FIELD                                  0x006D1FFF /* =7151615 */
#define NV_062_LOW_FIELD                                   0x006D0000 /* =7143424 */
#define NV_062_NV10_CONTEXT_SURFACES_2D_ADJ                0x006D0000
#define NV_062_NV10_CONTEXT_SURFACES_2D_HANDLE_MSK         0xFFFFFFFF /* 31:0 */ 
#define NV_062_NV10_CONTEXT_SURFACES_2D_HANDLE_RMSK        0xFFFFFFFF /* 31:0 */ 
#define NV_062_NV10_CONTEXT_SURFACES_2D_HANDLE_WORD        0
#define NV_062_NV10_CONTEXT_SURFACES_2D_HANDLE_HIGH_FIELD  0x0000001F /* =31 */
#define NV_062_NV10_CONTEXT_SURFACES_2D_HANDLE_LOW_FIELD   0x00000000 /* =0 */
#define NV_062_NV10_CONTEXT_SURFACES_2D_MSK                0xFFFFFFFF 
#define NV_062_NOP_PARAMETER_MSK                           0xFFFFFFFF /* 31:0 */ 
#define NV_062_NOP_PARAMETER_RMSK                          0xFFFFFFFF /* 31:0 */ 
#define NV_062_NOP_PARAMETER_WORD                          0
#define NV_062_NOP_PARAMETER_HIGH_FIELD                    0x0000001F /* =31 */
#define NV_062_NOP_PARAMETER_LOW_FIELD                     0x00000000 /* =0 */
#define NV_062_NOP_MSK                                     0xFFFFFFFF 
#define NV_062_PM_TRIGGER_PARAMETER_MSK                    0xFFFFFFFF /* 31:0 */ 
#define NV_062_PM_TRIGGER_PARAMETER_RMSK                   0xFFFFFFFF /* 31:0 */ 
#define NV_062_PM_TRIGGER_PARAMETER_WORD                   0
#define NV_062_PM_TRIGGER_PARAMETER_HIGH_FIELD             0x0000001F /* =31 */
#define NV_062_PM_TRIGGER_PARAMETER_LOW_FIELD              0x00000000 /* =0 */
#define NV_062_PM_TRIGGER_MSK                              0xFFFFFFFF 
#define NV_062_NOTIFY_STYLE_MSK                            0xFFFFFFFF /* 31:0 */ 
#define NV_062_NOTIFY_STYLE_RMSK                           0xFFFFFFFF /* 31:0 */ 
#define NV_062_NOTIFY_STYLE_WORD                           0
#define NV_062_NOTIFY_STYLE_HIGH_FIELD                     0x0000001F /* =31 */
#define NV_062_NOTIFY_STYLE_LOW_FIELD                      0x00000000 /* =0 */
#define NV_062_NOTIFY_STYLE_WRITE_ONLY_ADJ                 0x00000000
#define NV_062_NOTIFY_STYLE_WRITE_THEN_AWAKEN_ADJ          0x00000001
#define NV_062_NOTIFY_MSK                                  0xFFFFFFFF 
#define NV_062_SET_NOTIFY_PARAMETER_MSK                    0xFFFFFFFF /* 31:0 */ 
#define NV_062_SET_NOTIFY_PARAMETER_RMSK                   0xFFFFFFFF /* 31:0 */ 
#define NV_062_SET_NOTIFY_PARAMETER_WORD                   0
#define NV_062_SET_NOTIFY_PARAMETER_HIGH_FIELD             0x0000001F /* =31 */
#define NV_062_SET_NOTIFY_PARAMETER_LOW_FIELD              0x00000000 /* =0 */
#define NV_062_SET_NOTIFY_PARAMETER_WRITE_ADJ              0x00000000
#define NV_062_SET_NOTIFY_MSK                              0xFFFFFFFF 
#define NV_062_WAIT_FOR_IDLE_PARAMETER_MSK                 0xFFFFFFFF /* 31:0 */ 
#define NV_062_WAIT_FOR_IDLE_PARAMETER_RMSK                0xFFFFFFFF /* 31:0 */ 
#define NV_062_WAIT_FOR_IDLE_PARAMETER_WORD                0
#define NV_062_WAIT_FOR_IDLE_PARAMETER_HIGH_FIELD          0x0000001F /* =31 */
#define NV_062_WAIT_FOR_IDLE_PARAMETER_LOW_FIELD           0x00000000 /* =0 */
#define NV_062_WAIT_FOR_IDLE_MSK                           0xFFFFFFFF 
#define NV_062_SET_CONTEXT_DMA_NOTIFY_PARAMETER_MSK        0xFFFFFFFF /* 31:0 */ 
#define NV_062_SET_CONTEXT_DMA_NOTIFY_PARAMETER_RMSK       0xFFFFFFFF /* 31:0 */ 
#define NV_062_SET_CONTEXT_DMA_NOTIFY_PARAMETER_WORD       0
#define NV_062_SET_CONTEXT_DMA_NOTIFY_PARAMETER_HIGH_FIELD 0x0000001F /* =31 */
#define NV_062_SET_CONTEXT_DMA_NOTIFY_PARAMETER_LOW_FIELD  0x00000000 /* =0 */
#define NV_062_SET_CONTEXT_DMA_NOTIFY_MSK                  0xFFFFFFFF 
#define NV_062_SET_CONTEXT_DMA_IMAGE_SOURCE_PARAMETER_MSK  0xFFFFFFFF /* 31:0 */ 
#define NV_062_SET_CONTEXT_DMA_IMAGE_SOURCE_PARAMETER_RMSK 0xFFFFFFFF /* 31:0 */ 
#define NV_062_SET_CONTEXT_DMA_IMAGE_SOURCE_PARAMETER_WORD 0
#define NV_062_SET_CONTEXT_DMA_IMAGE_SOURCE_PARAMETER_HIGH_FIELD 0x0000001F /* =31 */
#define NV_062_SET_CONTEXT_DMA_IMAGE_SOURCE_PARAMETER_LOW_FIELD 0x00000000 /* =0 */
#define NV_062_SET_CONTEXT_DMA_IMAGE_SOURCE_MSK            0xFFFFFFFF 
#define NV_062_SET_CONTEXT_DMA_IMAGE_DESTIN_PARAMETER_MSK  0xFFFFFFFF /* 31:0 */ 
#define NV_062_SET_CONTEXT_DMA_IMAGE_DESTIN_PARAMETER_RMSK 0xFFFFFFFF /* 31:0 */ 
#define NV_062_SET_CONTEXT_DMA_IMAGE_DESTIN_PARAMETER_WORD 0
#define NV_062_SET_CONTEXT_DMA_IMAGE_DESTIN_PARAMETER_HIGH_FIELD 0x0000001F /* =31 */
#define NV_062_SET_CONTEXT_DMA_IMAGE_DESTIN_PARAMETER_LOW_FIELD 0x00000000 /* =0 */
#define NV_062_SET_CONTEXT_DMA_IMAGE_DESTIN_MSK            0xFFFFFFFF 
#define NV_062_FMT_VALUE_MSK                               0xFFFFFFFF /* 31:0 */ 
#define NV_062_FMT_VALUE_RMSK                              0xFFFFFFFF /* 31:0 */ 
#define NV_062_FMT_VALUE_WORD                              0
#define NV_062_FMT_VALUE_HIGH_FIELD                        0x0000001F /* =31 */
#define NV_062_FMT_VALUE_LOW_FIELD                         0x00000000 /* =0 */
#define NV_062_FMT_VALUE_LE_Y8_ADJ                         0x00000001
#define NV_062_FMT_VALUE_LE_X1R5G5B5_Z1R5G5B5_ADJ          0x00000002
#define NV_062_FMT_VALUE_LE_X1R5G5B5_O1R5G5B5_ADJ          0x00000003
#define NV_062_FMT_VALUE_LE_R5G6B5_ADJ                     0x00000004
#define NV_062_FMT_VALUE_LE_Y16_ADJ                        0x00000005
#define NV_062_FMT_VALUE_LE_X8R8G8B8_Z8R8G8B8_ADJ          0x00000006
#define NV_062_FMT_VALUE_LE_X8R8G8B8_O8R8G8B8_ADJ          0x00000007
#define NV_062_FMT_VALUE_LE_X1A7R8G8B8_Z1A7R8G8B8_ADJ      0x00000008
#define NV_062_FMT_VALUE_LE_X1A7R8G8B8_O1A7R8G8B8_ADJ      0x00000009
#define NV_062_FMT_VALUE_LE_A8R8G8B8_ADJ                   0x0000000A
#define NV_062_FMT_VALUE_LE_Y32_ADJ                        0x0000000B
#define NV_062_FMT_MSK                                     0xFFFFFFFF 
#define NV_062_PITCH_SOURCE_MSK                            0x0000FFFF /* 15:0 */ 
#define NV_062_PITCH_SOURCE_RMSK                           0x0000FFFF /* 15:0 */ 
#define NV_062_PITCH_SOURCE_WORD                           0
#define NV_062_PITCH_SOURCE_HIGH_FIELD                     0x0000000F /* =15 */
#define NV_062_PITCH_SOURCE_LOW_FIELD                      0x00000000 /* =0 */
#define NV_062_PITCH_DESTIN_MSK                            0xFFFF0000 /* 31:16 */ 
#define NV_062_PITCH_DESTIN_RMSK                           0x0000FFFF /* 31:16 */ 
#define NV_062_PITCH_DESTIN_WORD                           0
#define NV_062_PITCH_DESTIN_HIGH_FIELD                     0x0000001F /* =31 */
#define NV_062_PITCH_DESTIN_LOW_FIELD                      0x00000010 /* =16 */
#define NV_062_PITCH_MSK                                   0xFFFFFFFF 
#define NV_062_OFFSET_SOURCE_LINADRS_MSK                   0xFFFFFFFF /* 31:0 */ 
#define NV_062_OFFSET_SOURCE_LINADRS_RMSK                  0xFFFFFFFF /* 31:0 */ 
#define NV_062_OFFSET_SOURCE_LINADRS_WORD                  0
#define NV_062_OFFSET_SOURCE_LINADRS_HIGH_FIELD            0x0000001F /* =31 */
#define NV_062_OFFSET_SOURCE_LINADRS_LOW_FIELD             0x00000000 /* =0 */
#define NV_062_OFFSET_SOURCE_LINADRS_0_ADJ                 0x00000000
#define NV_062_OFFSET_SOURCE_MSK                           0xFFFFFFFF 
#define NV_062_OFFSET_DESTIN_LINADRS_MSK                   0xFFFFFFFF /* 31:0 */ 
#define NV_062_OFFSET_DESTIN_LINADRS_RMSK                  0xFFFFFFFF /* 31:0 */ 
#define NV_062_OFFSET_DESTIN_LINADRS_WORD                  0
#define NV_062_OFFSET_DESTIN_LINADRS_HIGH_FIELD            0x0000001F /* =31 */
#define NV_062_OFFSET_DESTIN_LINADRS_LOW_FIELD             0x00000000 /* =0 */
#define NV_062_OFFSET_DESTIN_LINADRS_0_ADJ                 0x00000000
#define NV_062_OFFSET_DESTIN_MSK                           0xFFFFFFFF 
#define NV_052_HIGH_FIELD                                  0x00631FFF /* =6496255 */
#define NV_052_LOW_FIELD                                   0x00630000 /* =6488064 */
#define NV_052_NV4_SWIZZLED_SURFACE_ADJ                    0x00630000
#define NV_052_NV4_SWIZZLED_SURFACE_MSK                    0x00000000 
#define NV_052_NOP_ADJ                                     0x00630100
#define NV_052_NOP_PARAMETER_MSK                           0xFFFFFFFF /* 31:0 */ 
#define NV_052_NOP_PARAMETER_RMSK                          0xFFFFFFFF /* 31:0 */ 
#define NV_052_NOP_PARAMETER_WORD                          0
#define NV_052_NOP_PARAMETER_HIGH_FIELD                    0x0000001F /* =31 */
#define NV_052_NOP_PARAMETER_LOW_FIELD                     0x00000000 /* =0 */
#define NV_052_NOP_MSK                                     0xFFFFFFFF 
#define NV_052_NOTIFY_STYLE_MSK                            0xFFFFFFFF /* 31:0 */ 
#define NV_052_NOTIFY_STYLE_RMSK                           0xFFFFFFFF /* 31:0 */ 
#define NV_052_NOTIFY_STYLE_WORD                           0
#define NV_052_NOTIFY_STYLE_HIGH_FIELD                     0x0000001F /* =31 */
#define NV_052_NOTIFY_STYLE_LOW_FIELD                      0x00000000 /* =0 */
#define NV_052_NOTIFY_STYLE_WRITE_ONLY_ADJ                 0x00000000
#define NV_052_NOTIFY_STYLE_WRITE_THEN_AWAKEN_ADJ          0x00000001
#define NV_052_SET_NOTIFY_PARAMETER_MSK                    0xFFFFFFFF /* 31:0 */ 
#define NV_052_SET_NOTIFY_PARAMETER_RMSK                   0xFFFFFFFF /* 31:0 */ 
#define NV_052_SET_NOTIFY_PARAMETER_WORD                   0
#define NV_052_SET_NOTIFY_PARAMETER_HIGH_FIELD             0x0000001F /* =31 */
#define NV_052_SET_NOTIFY_PARAMETER_LOW_FIELD              0x00000000 /* =0 */
#define NV_052_SET_NOTIFY_PARAMETER_WRITE_ADJ              0x00000000
#define NV_052_NOTIFY_MSK                                  0xFFFFFFFF 
#define NV_052_SET_CONTEXT_DMA_NOTIFY_PARAMETER_MSK        0xFFFFFFFF /* 31:0 */ 
#define NV_052_SET_CONTEXT_DMA_NOTIFY_PARAMETER_RMSK       0xFFFFFFFF /* 31:0 */ 
#define NV_052_SET_CONTEXT_DMA_NOTIFY_PARAMETER_WORD       0
#define NV_052_SET_CONTEXT_DMA_NOTIFY_PARAMETER_HIGH_FIELD 0x0000001F /* =31 */
#define NV_052_SET_CONTEXT_DMA_NOTIFY_PARAMETER_LOW_FIELD  0x00000000 /* =0 */
#define NV_052_SET_CONTEXT_DMA_NOTIFY_MSK                  0xFFFFFFFF 
#define NV_052_SET_CONTEXT_DMA_IMAGE_PARAMETER_MSK         0xFFFFFFFF /* 31:0 */ 
#define NV_052_SET_CONTEXT_DMA_IMAGE_PARAMETER_RMSK        0xFFFFFFFF /* 31:0 */ 
#define NV_052_SET_CONTEXT_DMA_IMAGE_PARAMETER_WORD        0
#define NV_052_SET_CONTEXT_DMA_IMAGE_PARAMETER_HIGH_FIELD  0x0000001F /* =31 */
#define NV_052_SET_CONTEXT_DMA_IMAGE_PARAMETER_LOW_FIELD   0x00000000 /* =0 */
#define NV_052_SET_CONTEXT_DMA_IMAGE_MSK                   0xFFFFFFFF 
#define NV_052_SET_IMAGE_OUTPUT_PARAMETER_MSK              0xFFFFFFFF /* 31:0 */ 
#define NV_052_SET_IMAGE_OUTPUT_PARAMETER_RMSK             0xFFFFFFFF /* 31:0 */ 
#define NV_052_SET_IMAGE_OUTPUT_PARAMETER_WORD             0
#define NV_052_SET_IMAGE_OUTPUT_PARAMETER_HIGH_FIELD       0x0000001F /* =31 */
#define NV_052_SET_IMAGE_OUTPUT_PARAMETER_LOW_FIELD        0x00000000 /* =0 */
#define NV_052_SET_IMAGE_OUTPUT_MSK                        0xFFFFFFFF 
#define NV_052_SET_IMAGE_INPUT_PARAMETER_MSK               0xFFFFFFFF /* 31:0 */ 
#define NV_052_SET_IMAGE_INPUT_PARAMETER_RMSK              0xFFFFFFFF /* 31:0 */ 
#define NV_052_SET_IMAGE_INPUT_PARAMETER_WORD              0
#define NV_052_SET_IMAGE_INPUT_PARAMETER_HIGH_FIELD        0x0000001F /* =31 */
#define NV_052_SET_IMAGE_INPUT_PARAMETER_LOW_FIELD         0x00000000 /* =0 */
#define NV_052_SET_IMAGE_INPUT_MSK                         0xFFFFFFFF 
#define NV_052_SET_FORMAT_COLOR_MSK                        0x0000FFFF /* 15:0 */ 
#define NV_052_SET_FORMAT_COLOR_RMSK                       0x0000FFFF /* 15:0 */ 
#define NV_052_SET_FORMAT_COLOR_WORD                       0
#define NV_052_SET_FORMAT_COLOR_HIGH_FIELD                 0x0000000F /* =15 */
#define NV_052_SET_FORMAT_COLOR_LOW_FIELD                  0x00000000 /* =0 */
#define NV_052_SET_FORMAT_COLOR_LE_Y8_ADJ                  0x00000001
#define NV_052_SET_FORMAT_COLOR_LE_X1R5G5B5_Z1R5G5B5_ADJ   0x00000002
#define NV_052_SET_FORMAT_COLOR_LE_X1R5G5B5_O1R5G5B5_ADJ   0x00000003
#define NV_052_SET_FORMAT_COLOR_LE_R5G6B5_ADJ              0x00000004
#define NV_052_SET_FORMAT_COLOR_LE_Y16_ADJ                 0x00000005
#define NV_052_SET_FORMAT_COLOR_LE_X8R8G8B8_Z8R8G8B8_ADJ   0x00000006
#define NV_052_SET_FORMAT_COLOR_LE_X8R8G8B8_O8R8G8B8_ADJ   0x00000007
#define NV_052_SET_FORMAT_COLOR_LE_X1A7R8G8B8_Z1A7R8G8B8_ADJ 0x00000008
#define NV_052_SET_FORMAT_COLOR_LE_X1A7R8G8B8_O1A7R8G8B8_ADJ 0x00000009
#define NV_052_SET_FORMAT_COLOR_LE_A8R8G8B8_ADJ            0x0000000A
#define NV_052_SET_FORMAT_COLOR_LE_Y32_ADJ                 0x0000000B
#define NV_052_SET_FORMAT_WIDTH_MSK                        0x00FF0000 /* 23:16 */ 
#define NV_052_SET_FORMAT_WIDTH_RMSK                       0x000000FF /* 23:16 */ 
#define NV_052_SET_FORMAT_WIDTH_WORD                       0
#define NV_052_SET_FORMAT_WIDTH_HIGH_FIELD                 0x00000017 /* =23 */
#define NV_052_SET_FORMAT_WIDTH_LOW_FIELD                  0x00000010 /* =16 */
#define NV_052_SET_FORMAT_WIDTH_1_ADJ                      0x00000000
#define NV_052_SET_FORMAT_WIDTH_2_ADJ                      0x00010000
#define NV_052_SET_FORMAT_WIDTH_4_ADJ                      0x00020000
#define NV_052_SET_FORMAT_WIDTH_8_ADJ                      0x00030000
#define NV_052_SET_FORMAT_WIDTH_16_ADJ                     0x00040000
#define NV_052_SET_FORMAT_WIDTH_32_ADJ                     0x00050000
#define NV_052_SET_FORMAT_WIDTH_64_ADJ                     0x00060000
#define NV_052_SET_FORMAT_WIDTH_128_ADJ                    0x00070000
#define NV_052_SET_FORMAT_WIDTH_256_ADJ                    0x00080000
#define NV_052_SET_FORMAT_WIDTH_512_ADJ                    0x00090000
#define NV_052_SET_FORMAT_WIDTH_1024_ADJ                   0x000A0000
#define NV_052_SET_FORMAT_WIDTH_2048_ADJ                   0x000B0000
#define NV_052_SET_FORMAT_HEIGHT_MSK                       0xFF000000 /* 31:24 */ 
#define NV_052_SET_FORMAT_HEIGHT_RMSK                      0x000000FF /* 31:24 */ 
#define NV_052_SET_FORMAT_HEIGHT_WORD                      0
#define NV_052_SET_FORMAT_HEIGHT_HIGH_FIELD                0x0000001F /* =31 */
#define NV_052_SET_FORMAT_HEIGHT_LOW_FIELD                 0x00000018 /* =24 */
#define NV_052_SET_FORMAT_HEIGHT_1_ADJ                     0x00000000
#define NV_052_SET_FORMAT_HEIGHT_2_ADJ                     0x01000000
#define NV_052_SET_FORMAT_HEIGHT_4_ADJ                     0x02000000
#define NV_052_SET_FORMAT_HEIGHT_8_ADJ                     0x03000000
#define NV_052_SET_FORMAT_HEIGHT_16_ADJ                    0x04000000
#define NV_052_SET_FORMAT_HEIGHT_32_ADJ                    0x05000000
#define NV_052_SET_FORMAT_HEIGHT_64_ADJ                    0x06000000
#define NV_052_SET_FORMAT_HEIGHT_128_ADJ                   0x07000000
#define NV_052_SET_FORMAT_HEIGHT_256_ADJ                   0x08000000
#define NV_052_SET_FORMAT_HEIGHT_512_ADJ                   0x09000000
#define NV_052_SET_FORMAT_HEIGHT_1024_ADJ                  0x0A000000
#define NV_052_SET_FORMAT_HEIGHT_2048_ADJ                  0x0B000000
#define NV_052_SET_FORMAT_MSK                              0xFFFFFFFF 
#define NV_052_SET_OFFSET_LINADRS_MSK                      0xFFFFFFFF /* 31:0 */ 
#define NV_052_SET_OFFSET_LINADRS_RMSK                     0xFFFFFFFF /* 31:0 */ 
#define NV_052_SET_OFFSET_LINADRS_WORD                     0
#define NV_052_SET_OFFSET_LINADRS_HIGH_FIELD               0x0000001F /* =31 */
#define NV_052_SET_OFFSET_LINADRS_LOW_FIELD                0x00000000 /* =0 */
#define NV_052_SET_OFFSET_LINADRS_0_ADJ                    0x00000000
#define NV_052_SET_OFFSET_MSK                              0xFFFFFFFF 
#define NV_UINMEM_HIGH_FIELD                               0x005C1FFF /* =6037503 */
#define NV_UINMEM_LOW_FIELD                                0x005C0000 /* =6029312 */
#define NV_UINMEM_CTX_SWITCH_ADJ                           0x005C0000
#define NV_UINMEM_CTX_SWITCH_INSTANCE_MSK                  0x0000FFFF /* 15:0 */ 
#define NV_UINMEM_CTX_SWITCH_INSTANCE_RMSK                 0x0000FFFF /* 15:0 */ 
#define NV_UINMEM_CTX_SWITCH_INSTANCE_WORD                 0
#define NV_UINMEM_CTX_SWITCH_INSTANCE_HIGH_FIELD           0x0000000F /* =15 */
#define NV_UINMEM_CTX_SWITCH_INSTANCE_LOW_FIELD            0x00000000 /* =0 */
#define NV_UINMEM_CTX_SWITCH_CHID_MSK                      0x007F0000 /* 22:16 */ 
#define NV_UINMEM_CTX_SWITCH_CHID_RMSK                     0x0000007F /* 22:16 */ 
#define NV_UINMEM_CTX_SWITCH_CHID_WORD                     0
#define NV_UINMEM_CTX_SWITCH_CHID_HIGH_FIELD               0x00000016 /* =22 */
#define NV_UINMEM_CTX_SWITCH_CHID_LOW_FIELD                0x00000010 /* =16 */
#define NV_UINMEM_CTX_SWITCH_VOLATILE_MSK                  0x80000000 /* 31:31 */ 
#define NV_UINMEM_CTX_SWITCH_VOLATILE_RMSK                 0x00000001 /* 31:31 */ 
#define NV_UINMEM_CTX_SWITCH_VOLATILE_WORD                 0
#define NV_UINMEM_CTX_SWITCH_VOLATILE_HIGH_FIELD           0x0000001F /* =31 */
#define NV_UINMEM_CTX_SWITCH_VOLATILE_LOW_FIELD            0x0000001F /* =31 */
#define NV_UINMEM_CTX_SWITCH_VOLATILE_IGNORE_ADJ           0x00000000
#define NV_UINMEM_CTX_SWITCH_VOLATILE_RESET_ADJ            0x80000000
#define NV_UINMEM_CTX_SWITCH_MSK                           0x807FFFFF 
#define NV_UINMEM_NOP_PARAMETER_MSK                        0xFFFFFFFF /* 31:0 */ 
#define NV_UINMEM_NOP_PARAMETER_RMSK                       0xFFFFFFFF /* 31:0 */ 
#define NV_UINMEM_NOP_PARAMETER_WORD                       0
#define NV_UINMEM_NOP_PARAMETER_HIGH_FIELD                 0x0000001F /* =31 */
#define NV_UINMEM_NOP_PARAMETER_LOW_FIELD                  0x00000000 /* =0 */
#define NV_UINMEM_NOP_MSK                                  0xFFFFFFFF 
#define NV_UINMEM_NOTIFY_STYLE_MSK                         0xFFFFFFFF /* 31:0 */ 
#define NV_UINMEM_NOTIFY_STYLE_RMSK                        0xFFFFFFFF /* 31:0 */ 
#define NV_UINMEM_NOTIFY_STYLE_WORD                        0
#define NV_UINMEM_NOTIFY_STYLE_HIGH_FIELD                  0x0000001F /* =31 */
#define NV_UINMEM_NOTIFY_STYLE_LOW_FIELD                   0x00000000 /* =0 */
#define NV_UINMEM_NOTIFY_STYLE_WRITE_ONLY_ADJ              0x00000000
#define NV_UINMEM_NOTIFY_STYLE_WRITE_THEN_AWAKEN_ADJ       0x00000001
#define NV_UINMEM_NOTIFY_MSK                               0xFFFFFFFF 
#define NV_UINMEM_SET_NOTIFY_PARAMETER_MSK                 0xFFFFFFFF /* 31:0 */ 
#define NV_UINMEM_SET_NOTIFY_PARAMETER_RMSK                0xFFFFFFFF /* 31:0 */ 
#define NV_UINMEM_SET_NOTIFY_PARAMETER_WORD                0
#define NV_UINMEM_SET_NOTIFY_PARAMETER_HIGH_FIELD          0x0000001F /* =31 */
#define NV_UINMEM_SET_NOTIFY_PARAMETER_LOW_FIELD           0x00000000 /* =0 */
#define NV_UINMEM_SET_NOTIFY_PARAMETER_WRITE_ADJ           0x00000000
#define NV_UINMEM_SET_NOTIFY_MSK                           0xFFFFFFFF 
#define NV_UINMEM_SET_CONTEXT_DMA_NOTIFY_PARAMETER_MSK     0xFFFFFFFF /* 31:0 */ 
#define NV_UINMEM_SET_CONTEXT_DMA_NOTIFY_PARAMETER_RMSK    0xFFFFFFFF /* 31:0 */ 
#define NV_UINMEM_SET_CONTEXT_DMA_NOTIFY_PARAMETER_WORD    0
#define NV_UINMEM_SET_CONTEXT_DMA_NOTIFY_PARAMETER_HIGH_FIELD 0x0000001F /* =31 */
#define NV_UINMEM_SET_CONTEXT_DMA_NOTIFY_PARAMETER_LOW_FIELD 0x00000000 /* =0 */
#define NV_UINMEM_SET_CONTEXT_DMA_NOTIFY_MSK               0xFFFFFFFF 
#define NV_UINMEM_SET_CONTEXT_DMA_IMAGE_PARAMETER_MSK      0xFFFFFFFF /* 31:0 */ 
#define NV_UINMEM_SET_CONTEXT_DMA_IMAGE_PARAMETER_RMSK     0xFFFFFFFF /* 31:0 */ 
#define NV_UINMEM_SET_CONTEXT_DMA_IMAGE_PARAMETER_WORD     0
#define NV_UINMEM_SET_CONTEXT_DMA_IMAGE_PARAMETER_HIGH_FIELD 0x0000001F /* =31 */
#define NV_UINMEM_SET_CONTEXT_DMA_IMAGE_PARAMETER_LOW_FIELD 0x00000000 /* =0 */
#define NV_UINMEM_SET_CONTEXT_DMA_IMAGE_MSK                0xFFFFFFFF 
#define NV_UINMEM_SET_IMAGE_OUTPUT_PARAMETER_MSK           0xFFFFFFFF /* 31:0 */ 
#define NV_UINMEM_SET_IMAGE_OUTPUT_PARAMETER_RMSK          0xFFFFFFFF /* 31:0 */ 
#define NV_UINMEM_SET_IMAGE_OUTPUT_PARAMETER_WORD          0
#define NV_UINMEM_SET_IMAGE_OUTPUT_PARAMETER_HIGH_FIELD    0x0000001F /* =31 */
#define NV_UINMEM_SET_IMAGE_OUTPUT_PARAMETER_LOW_FIELD     0x00000000 /* =0 */
#define NV_UINMEM_SET_IMAGE_OUTPUT_MSK                     0xFFFFFFFF 
#define NV_UINMEM_SET_IMAGE_INPUT_PARAMETER_MSK            0xFFFFFFFF /* 31:0 */ 
#define NV_UINMEM_SET_IMAGE_INPUT_PARAMETER_RMSK           0xFFFFFFFF /* 31:0 */ 
#define NV_UINMEM_SET_IMAGE_INPUT_PARAMETER_WORD           0
#define NV_UINMEM_SET_IMAGE_INPUT_PARAMETER_HIGH_FIELD     0x0000001F /* =31 */
#define NV_UINMEM_SET_IMAGE_INPUT_PARAMETER_LOW_FIELD      0x00000000 /* =0 */
#define NV_UINMEM_SET_IMAGE_INPUT_MSK                      0xFFFFFFFF 
#define NV_UINMEM_FORMAT_VALUE_MSK                         0xFFFFFFFF /* 31:0 */ 
#define NV_UINMEM_FORMAT_VALUE_RMSK                        0xFFFFFFFF /* 31:0 */ 
#define NV_UINMEM_FORMAT_VALUE_WORD                        0
#define NV_UINMEM_FORMAT_VALUE_HIGH_FIELD                  0x0000001F /* =31 */
#define NV_UINMEM_FORMAT_VALUE_LOW_FIELD                   0x00000000 /* =0 */
#define NV_UINMEM_FORMAT_VALUE_LE_Y8_ADJ                   0x01010000
#define NV_UINMEM_FORMAT_VALUE_LE_Y16_ADJ                  0x01010001
#define NV_UINMEM_FORMAT_VALUE_LE_X1R5G5B5_Z1R5G5B5_ADJ    0x01000000
#define NV_UINMEM_FORMAT_VALUE_LE_X8R8G8B8_Z8R8G8B8_ADJ    0x00000001
#define NV_UINMEM_FORMAT_MSK                               0xFFFFFFFF 
#define NV_UINMEM_PITCH_VALUE_MSK                          0x0000FFFF /* 15:0 */ 
#define NV_UINMEM_PITCH_VALUE_RMSK                         0x0000FFFF /* 15:0 */ 
#define NV_UINMEM_PITCH_VALUE_WORD                         0
#define NV_UINMEM_PITCH_VALUE_HIGH_FIELD                   0x0000000F /* =15 */
#define NV_UINMEM_PITCH_VALUE_LOW_FIELD                    0x00000000 /* =0 */
#define NV_UINMEM_PITCH_MSK                                0x0000FFFF 
#define NV_UINMEM_OFFSET_LINADRS_MSK                       0x007FFFFF /* 22:0 */ 
#define NV_UINMEM_OFFSET_LINADRS_RMSK                      0x007FFFFF /* 22:0 */ 
#define NV_UINMEM_OFFSET_LINADRS_WORD                      0
#define NV_UINMEM_OFFSET_LINADRS_HIGH_FIELD                0x00000016 /* =22 */
#define NV_UINMEM_OFFSET_LINADRS_LOW_FIELD                 0x00000000 /* =0 */
#define NV_UINMEM_OFFSET_LINADRS_0_ADJ                     0x00000000
#define NV_UINMEM_OFFSET_MSK                               0x007FFFFF 
#define NV_04A_HIGH_FIELD                                  0x004C1FFF /* =4988927 */
#define NV_04A_LOW_FIELD                                   0x004C0000 /* =4980736 */
#define NV_04A_NV4_GDI_RECTANGLE_TEXT_ADJ                  0x004C0000
#define NV_04A_NV4_GDI_RECTANGLE_TEXT_MSK                  0x00000000 
#define NV_04A_NOP_ADJ                                     0x004C0100
#define NV_04A_NOP_PARAMETER_MSK                           0xFFFFFFFF /* 31:0 */ 
#define NV_04A_NOP_PARAMETER_RMSK                          0xFFFFFFFF /* 31:0 */ 
#define NV_04A_NOP_PARAMETER_WORD                          0
#define NV_04A_NOP_PARAMETER_HIGH_FIELD                    0x0000001F /* =31 */
#define NV_04A_NOP_PARAMETER_LOW_FIELD                     0x00000000 /* =0 */
#define NV_04A_NOP_MSK                                     0xFFFFFFFF 
#define NV_04A_PM_TRIGGER_PARAMETER_MSK                    0xFFFFFFFF /* 31:0 */ 
#define NV_04A_PM_TRIGGER_PARAMETER_RMSK                   0xFFFFFFFF /* 31:0 */ 
#define NV_04A_PM_TRIGGER_PARAMETER_WORD                   0
#define NV_04A_PM_TRIGGER_PARAMETER_HIGH_FIELD             0x0000001F /* =31 */
#define NV_04A_PM_TRIGGER_PARAMETER_LOW_FIELD              0x00000000 /* =0 */
#define NV_04A_PM_TRIGGER_MSK                              0xFFFFFFFF 
#define NV_04A_NOTIFY_STYLE_MSK                            0xFFFFFFFF /* 31:0 */ 
#define NV_04A_NOTIFY_STYLE_RMSK                           0xFFFFFFFF /* 31:0 */ 
#define NV_04A_NOTIFY_STYLE_WORD                           0
#define NV_04A_NOTIFY_STYLE_HIGH_FIELD                     0x0000001F /* =31 */
#define NV_04A_NOTIFY_STYLE_LOW_FIELD                      0x00000000 /* =0 */
#define NV_04A_NOTIFY_STYLE_WRITE_ONLY_ADJ                 0x00000000
#define NV_04A_NOTIFY_STYLE_WRITE_THEN_AWAKEN_ADJ          0x00000001
#define NV_04A_NOTIFY_MSK                                  0xFFFFFFFF 
#define NV_04A_SET_PATCH_PARAMETER_MSK                     0xFFFFFFFF /* 31:0 */ 
#define NV_04A_SET_PATCH_PARAMETER_RMSK                    0xFFFFFFFF /* 31:0 */ 
#define NV_04A_SET_PATCH_PARAMETER_WORD                    0
#define NV_04A_SET_PATCH_PARAMETER_HIGH_FIELD              0x0000001F /* =31 */
#define NV_04A_SET_PATCH_PARAMETER_LOW_FIELD               0x00000000 /* =0 */
#define NV_04A_SET_PATCH_PARAMETER_INVALIDATE_ADJ          0x00000000
#define NV_04A_SET_PATCH_PARAMETER_VALIDATE_ADJ            0x00000001
#define NV_04A_SET_PATCH_MSK                               0xFFFFFFFF 
#define NV_04A_SET_CONTEXT_DMA_NOTIFY_PARAMETER_MSK        0xFFFFFFFF /* 31:0 */ 
#define NV_04A_SET_CONTEXT_DMA_NOTIFY_PARAMETER_RMSK       0xFFFFFFFF /* 31:0 */ 
#define NV_04A_SET_CONTEXT_DMA_NOTIFY_PARAMETER_WORD       0
#define NV_04A_SET_CONTEXT_DMA_NOTIFY_PARAMETER_HIGH_FIELD 0x0000001F /* =31 */
#define NV_04A_SET_CONTEXT_DMA_NOTIFY_PARAMETER_LOW_FIELD  0x00000000 /* =0 */
#define NV_04A_SET_CONTEXT_DMA_NOTIFY_MSK                  0xFFFFFFFF 
#define NV_04A_SET_CONTEXT_DMA_FONTS_PARAMETER_MSK         0xFFFFFFFF /* 31:0 */ 
#define NV_04A_SET_CONTEXT_DMA_FONTS_PARAMETER_RMSK        0xFFFFFFFF /* 31:0 */ 
#define NV_04A_SET_CONTEXT_DMA_FONTS_PARAMETER_WORD        0
#define NV_04A_SET_CONTEXT_DMA_FONTS_PARAMETER_HIGH_FIELD  0x0000001F /* =31 */
#define NV_04A_SET_CONTEXT_DMA_FONTS_PARAMETER_LOW_FIELD   0x00000000 /* =0 */
#define NV_04A_SET_CONTEXT_DMA_FONTS_MSK                   0xFFFFFFFF 
#define NV_04A_SET_IMAGE_OUTPUT_PARAMETER_MSK              0xFFFFFFFF /* 31:0 */ 
#define NV_04A_SET_IMAGE_OUTPUT_PARAMETER_RMSK             0xFFFFFFFF /* 31:0 */ 
#define NV_04A_SET_IMAGE_OUTPUT_PARAMETER_WORD             0
#define NV_04A_SET_IMAGE_OUTPUT_PARAMETER_HIGH_FIELD       0x0000001F /* =31 */
#define NV_04A_SET_IMAGE_OUTPUT_PARAMETER_LOW_FIELD        0x00000000 /* =0 */
#define NV_04A_SET_IMAGE_OUTPUT_MSK                        0xFFFFFFFF 
#define NV_04A_SET_COLOR_FORMAT_LE_MSK                     0xFFFFFFFF /* 31:0 */ 
#define NV_04A_SET_COLOR_FORMAT_LE_RMSK                    0xFFFFFFFF /* 31:0 */ 
#define NV_04A_SET_COLOR_FORMAT_LE_WORD                    0
#define NV_04A_SET_COLOR_FORMAT_LE_HIGH_FIELD              0x0000001F /* =31 */
#define NV_04A_SET_COLOR_FORMAT_LE_LOW_FIELD               0x00000000 /* =0 */
#define NV_04A_SET_COLOR_FORMAT_LE_X16R5G6B5_ADJ           0x00000001
#define NV_04A_SET_COLOR_FORMAT_LE_X17R5G5B5_ADJ           0x00000002
#define NV_04A_SET_COLOR_FORMAT_LE_X8R8G8B8_ADJ            0x00000003
#define NV_04A_SET_COLOR_FORMAT_MSK                        0xFFFFFFFF 
#define NV_04A_SET_MONOCHROME_FORMAT_VALUE_MSK             0xFFFFFFFF /* 31:0 */ 
#define NV_04A_SET_MONOCHROME_FORMAT_VALUE_RMSK            0xFFFFFFFF /* 31:0 */ 
#define NV_04A_SET_MONOCHROME_FORMAT_VALUE_WORD            0
#define NV_04A_SET_MONOCHROME_FORMAT_VALUE_HIGH_FIELD      0x0000001F /* =31 */
#define NV_04A_SET_MONOCHROME_FORMAT_VALUE_LOW_FIELD       0x00000000 /* =0 */
#define NV_04A_SET_MONOCHROME_FORMAT_VALUE_CGA6_M1_ADJ     0x00000001
#define NV_04A_SET_MONOCHROME_FORMAT_VALUE_LE_M1_ADJ       0x00000002
#define NV_04A_SET_MONOCHROME_FORMAT_MSK                   0xFFFFFFFF 
#define NV_04A_COLOR1_A_VALUE_MSK                          0xFFFFFFFF /* 31:0 */ 
#define NV_04A_COLOR1_A_VALUE_RMSK                         0xFFFFFFFF /* 31:0 */ 
#define NV_04A_COLOR1_A_VALUE_WORD                         0
#define NV_04A_COLOR1_A_VALUE_HIGH_FIELD                   0x0000001F /* =31 */
#define NV_04A_COLOR1_A_VALUE_LOW_FIELD                    0x00000000 /* =0 */
#define NV_04A_COLOR1_A_MSK                                0xFFFFFFFF 
#define NV_04A_UNCLIPPED_RECTANGLE_POINT_Y_MSK             0x0000FFFF /* 15:0 */ 
#define NV_04A_UNCLIPPED_RECTANGLE_POINT_Y_RMSK            0x0000FFFF /* 15:0 */ 
#define NV_04A_UNCLIPPED_RECTANGLE_POINT_Y_WORD            0
#define NV_04A_UNCLIPPED_RECTANGLE_POINT_Y_HIGH_FIELD      0x0000000F /* =15 */
#define NV_04A_UNCLIPPED_RECTANGLE_POINT_Y_LOW_FIELD       0x00000000 /* =0 */
#define NV_04A_UNCLIPPED_RECTANGLE_POINT_X_MSK             0xFFFF0000 /* 31:16 */ 
#define NV_04A_UNCLIPPED_RECTANGLE_POINT_X_RMSK            0x0000FFFF /* 31:16 */ 
#define NV_04A_UNCLIPPED_RECTANGLE_POINT_X_WORD            0
#define NV_04A_UNCLIPPED_RECTANGLE_POINT_X_HIGH_FIELD      0x0000001F /* =31 */
#define NV_04A_UNCLIPPED_RECTANGLE_POINT_X_LOW_FIELD       0x00000010 /* =16 */
#define NV_04A_UNCLIPPED_RECTANGLE_POINT_MSK               0xFFFFFFFF 
#define NV_04A_UNCLIPPED_RECTANGLE_SIZE_HEIGHT_MSK         0x0000FFFF /* 15:0 */ 
#define NV_04A_UNCLIPPED_RECTANGLE_SIZE_HEIGHT_RMSK        0x0000FFFF /* 15:0 */ 
#define NV_04A_UNCLIPPED_RECTANGLE_SIZE_HEIGHT_WORD        0
#define NV_04A_UNCLIPPED_RECTANGLE_SIZE_HEIGHT_HIGH_FIELD  0x0000000F /* =15 */
#define NV_04A_UNCLIPPED_RECTANGLE_SIZE_HEIGHT_LOW_FIELD   0x00000000 /* =0 */
#define NV_04A_UNCLIPPED_RECTANGLE_SIZE_WIDTH_MSK          0xFFFF0000 /* 31:16 */ 
#define NV_04A_UNCLIPPED_RECTANGLE_SIZE_WIDTH_RMSK         0x0000FFFF /* 31:16 */ 
#define NV_04A_UNCLIPPED_RECTANGLE_SIZE_WIDTH_WORD         0
#define NV_04A_UNCLIPPED_RECTANGLE_SIZE_WIDTH_HIGH_FIELD   0x0000001F /* =31 */
#define NV_04A_UNCLIPPED_RECTANGLE_SIZE_WIDTH_LOW_FIELD    0x00000010 /* =16 */
#define NV_04A_UNCLIPPED_RECTANGLE_SIZE_MSK                0xFFFFFFFF 
#define NV_04A_CLIP_B_POINT0_LEFT_MSK                      0x0000FFFF /* 15:0 */ 
#define NV_04A_CLIP_B_POINT0_LEFT_RMSK                     0x0000FFFF /* 15:0 */ 
#define NV_04A_CLIP_B_POINT0_LEFT_WORD                     0
#define NV_04A_CLIP_B_POINT0_LEFT_HIGH_FIELD               0x0000000F /* =15 */
#define NV_04A_CLIP_B_POINT0_LEFT_LOW_FIELD                0x00000000 /* =0 */
#define NV_04A_CLIP_B_POINT0_TOP_MSK                       0xFFFF0000 /* 31:16 */ 
#define NV_04A_CLIP_B_POINT0_TOP_RMSK                      0x0000FFFF /* 31:16 */ 
#define NV_04A_CLIP_B_POINT0_TOP_WORD                      0
#define NV_04A_CLIP_B_POINT0_TOP_HIGH_FIELD                0x0000001F /* =31 */
#define NV_04A_CLIP_B_POINT0_TOP_LOW_FIELD                 0x00000010 /* =16 */
#define NV_04A_CLIP_B_POINT0_MSK                           0xFFFFFFFF 
#define NV_04A_CLIP_B_POINT1_RIGHT_MSK                     0x0000FFFF /* 15:0 */ 
#define NV_04A_CLIP_B_POINT1_RIGHT_RMSK                    0x0000FFFF /* 15:0 */ 
#define NV_04A_CLIP_B_POINT1_RIGHT_WORD                    0
#define NV_04A_CLIP_B_POINT1_RIGHT_HIGH_FIELD              0x0000000F /* =15 */
#define NV_04A_CLIP_B_POINT1_RIGHT_LOW_FIELD               0x00000000 /* =0 */
#define NV_04A_CLIP_B_POINT1_BOTTOM_MSK                    0xFFFF0000 /* 31:16 */ 
#define NV_04A_CLIP_B_POINT1_BOTTOM_RMSK                   0x0000FFFF /* 31:16 */ 
#define NV_04A_CLIP_B_POINT1_BOTTOM_WORD                   0
#define NV_04A_CLIP_B_POINT1_BOTTOM_HIGH_FIELD             0x0000001F /* =31 */
#define NV_04A_CLIP_B_POINT1_BOTTOM_LOW_FIELD              0x00000010 /* =16 */
#define NV_04A_CLIP_B_POINT1_MSK                           0xFFFFFFFF 
#define NV_04A_COLOR1_B_VALUE_MSK                          0xFFFFFFFF /* 31:0 */ 
#define NV_04A_COLOR1_B_VALUE_RMSK                         0xFFFFFFFF /* 31:0 */ 
#define NV_04A_COLOR1_B_VALUE_WORD                         0
#define NV_04A_COLOR1_B_VALUE_HIGH_FIELD                   0x0000001F /* =31 */
#define NV_04A_COLOR1_B_VALUE_LOW_FIELD                    0x00000000 /* =0 */
#define NV_04A_COLOR1_B_MSK                                0xFFFFFFFF 
#define NV_04A_CLIPPED_RECTANGLE_POINT_0_LEFT_MSK          0x0000FFFF /* 15:0 */ 
#define NV_04A_CLIPPED_RECTANGLE_POINT_0_LEFT_RMSK         0x0000FFFF /* 15:0 */ 
#define NV_04A_CLIPPED_RECTANGLE_POINT_0_LEFT_WORD         0
#define NV_04A_CLIPPED_RECTANGLE_POINT_0_LEFT_HIGH_FIELD   0x0000000F /* =15 */
#define NV_04A_CLIPPED_RECTANGLE_POINT_0_LEFT_LOW_FIELD    0x00000000 /* =0 */
#define NV_04A_CLIPPED_RECTANGLE_POINT_0_TOP_MSK           0xFFFF0000 /* 31:16 */ 
#define NV_04A_CLIPPED_RECTANGLE_POINT_0_TOP_RMSK          0x0000FFFF /* 31:16 */ 
#define NV_04A_CLIPPED_RECTANGLE_POINT_0_TOP_WORD          0
#define NV_04A_CLIPPED_RECTANGLE_POINT_0_TOP_HIGH_FIELD    0x0000001F /* =31 */
#define NV_04A_CLIPPED_RECTANGLE_POINT_0_TOP_LOW_FIELD     0x00000010 /* =16 */
#define NV_04A_CLIPPED_RECTANGLE_POINT_0_MSK               0xFFFFFFFF 
#define NV_04A_CLIPPED_RECTANGLE_POINT_1_RIGHT_MSK         0x0000FFFF /* 15:0 */ 
#define NV_04A_CLIPPED_RECTANGLE_POINT_1_RIGHT_RMSK        0x0000FFFF /* 15:0 */ 
#define NV_04A_CLIPPED_RECTANGLE_POINT_1_RIGHT_WORD        0
#define NV_04A_CLIPPED_RECTANGLE_POINT_1_RIGHT_HIGH_FIELD  0x0000000F /* =15 */
#define NV_04A_CLIPPED_RECTANGLE_POINT_1_RIGHT_LOW_FIELD   0x00000000 /* =0 */
#define NV_04A_CLIPPED_RECTANGLE_POINT_1_BOTTOM_MSK        0xFFFF0000 /* 31:16 */ 
#define NV_04A_CLIPPED_RECTANGLE_POINT_1_BOTTOM_RMSK       0x0000FFFF /* 31:16 */ 
#define NV_04A_CLIPPED_RECTANGLE_POINT_1_BOTTOM_WORD       0
#define NV_04A_CLIPPED_RECTANGLE_POINT_1_BOTTOM_HIGH_FIELD 0x0000001F /* =31 */
#define NV_04A_CLIPPED_RECTANGLE_POINT_1_BOTTOM_LOW_FIELD  0x00000010 /* =16 */
#define NV_04A_CLIPPED_RECTANGLE_POINT_1_MSK               0xFFFFFFFF 
#define NV_04A_CLIP_C_POINT0_LEFT_MSK                      0x0000FFFF /* 15:0 */ 
#define NV_04A_CLIP_C_POINT0_LEFT_RMSK                     0x0000FFFF /* 15:0 */ 
#define NV_04A_CLIP_C_POINT0_LEFT_WORD                     0
#define NV_04A_CLIP_C_POINT0_LEFT_HIGH_FIELD               0x0000000F /* =15 */
#define NV_04A_CLIP_C_POINT0_LEFT_LOW_FIELD                0x00000000 /* =0 */
#define NV_04A_CLIP_C_POINT0_TOP_MSK                       0xFFFF0000 /* 31:16 */ 
#define NV_04A_CLIP_C_POINT0_TOP_RMSK                      0x0000FFFF /* 31:16 */ 
#define NV_04A_CLIP_C_POINT0_TOP_WORD                      0
#define NV_04A_CLIP_C_POINT0_TOP_HIGH_FIELD                0x0000001F /* =31 */
#define NV_04A_CLIP_C_POINT0_TOP_LOW_FIELD                 0x00000010 /* =16 */
#define NV_04A_CLIP_C_POINT0_MSK                           0xFFFFFFFF 
#define NV_04A_CLIP_C_POINT1_RIGHT_MSK                     0x0000FFFF /* 15:0 */ 
#define NV_04A_CLIP_C_POINT1_RIGHT_RMSK                    0x0000FFFF /* 15:0 */ 
#define NV_04A_CLIP_C_POINT1_RIGHT_WORD                    0
#define NV_04A_CLIP_C_POINT1_RIGHT_HIGH_FIELD              0x0000000F /* =15 */
#define NV_04A_CLIP_C_POINT1_RIGHT_LOW_FIELD               0x00000000 /* =0 */
#define NV_04A_CLIP_C_POINT1_BOTTOM_MSK                    0xFFFF0000 /* 31:16 */ 
#define NV_04A_CLIP_C_POINT1_BOTTOM_RMSK                   0x0000FFFF /* 31:16 */ 
#define NV_04A_CLIP_C_POINT1_BOTTOM_WORD                   0
#define NV_04A_CLIP_C_POINT1_BOTTOM_HIGH_FIELD             0x0000001F /* =31 */
#define NV_04A_CLIP_C_POINT1_BOTTOM_LOW_FIELD              0x00000010 /* =16 */
#define NV_04A_CLIP_C_POINT1_MSK                           0xFFFFFFFF 
#define NV_04A_COLOR1_C_VALUE_MSK                          0xFFFFFFFF /* 31:0 */ 
#define NV_04A_COLOR1_C_VALUE_RMSK                         0xFFFFFFFF /* 31:0 */ 
#define NV_04A_COLOR1_C_VALUE_WORD                         0
#define NV_04A_COLOR1_C_VALUE_HIGH_FIELD                   0x0000001F /* =31 */
#define NV_04A_COLOR1_C_VALUE_LOW_FIELD                    0x00000000 /* =0 */
#define NV_04A_COLOR1_C_MSK                                0xFFFFFFFF 
#define NV_04A_SIZE_C_WIDTH_MSK                            0x0000FFFF /* 15:0 */ 
#define NV_04A_SIZE_C_WIDTH_RMSK                           0x0000FFFF /* 15:0 */ 
#define NV_04A_SIZE_C_WIDTH_WORD                           0
#define NV_04A_SIZE_C_WIDTH_HIGH_FIELD                     0x0000000F /* =15 */
#define NV_04A_SIZE_C_WIDTH_LOW_FIELD                      0x00000000 /* =0 */
#define NV_04A_SIZE_C_HEIGHT_MSK                           0xFFFF0000 /* 31:16 */ 
#define NV_04A_SIZE_C_HEIGHT_RMSK                          0x0000FFFF /* 31:16 */ 
#define NV_04A_SIZE_C_HEIGHT_WORD                          0
#define NV_04A_SIZE_C_HEIGHT_HIGH_FIELD                    0x0000001F /* =31 */
#define NV_04A_SIZE_C_HEIGHT_LOW_FIELD                     0x00000010 /* =16 */
#define NV_04A_SIZE_C_MSK                                  0xFFFFFFFF 
#define NV_04A_POINT_C_X_MSK                               0x0000FFFF /* 15:0 */ 
#define NV_04A_POINT_C_X_RMSK                              0x0000FFFF /* 15:0 */ 
#define NV_04A_POINT_C_X_WORD                              0
#define NV_04A_POINT_C_X_HIGH_FIELD                        0x0000000F /* =15 */
#define NV_04A_POINT_C_X_LOW_FIELD                         0x00000000 /* =0 */
#define NV_04A_POINT_C_Y_MSK                               0xFFFF0000 /* 31:16 */ 
#define NV_04A_POINT_C_Y_RMSK                              0x0000FFFF /* 31:16 */ 
#define NV_04A_POINT_C_Y_WORD                              0
#define NV_04A_POINT_C_Y_HIGH_FIELD                        0x0000001F /* =31 */
#define NV_04A_POINT_C_Y_LOW_FIELD                         0x00000010 /* =16 */
#define NV_04A_POINT_C_MSK                                 0xFFFFFFFF 
#define NV_04A_MONOCHROME_COLOR1_C_BITMAP_MSK              0xFFFFFFFF /* 31:0 */ 
#define NV_04A_MONOCHROME_COLOR1_C_BITMAP_RMSK             0xFFFFFFFF /* 31:0 */ 
#define NV_04A_MONOCHROME_COLOR1_C_BITMAP_WORD             0
#define NV_04A_MONOCHROME_COLOR1_C_BITMAP_HIGH_FIELD       0x0000001F /* =31 */
#define NV_04A_MONOCHROME_COLOR1_C_BITMAP_LOW_FIELD        0x00000000 /* =0 */
#define NV_04A_MONOCHROME_COLOR1_C_MSK                     0xFFFFFFFF 
#define NV_04A_CLIP_E_POINT0_LEFT_MSK                      0x0000FFFF /* 15:0 */ 
#define NV_04A_CLIP_E_POINT0_LEFT_RMSK                     0x0000FFFF /* 15:0 */ 
#define NV_04A_CLIP_E_POINT0_LEFT_WORD                     0
#define NV_04A_CLIP_E_POINT0_LEFT_HIGH_FIELD               0x0000000F /* =15 */
#define NV_04A_CLIP_E_POINT0_LEFT_LOW_FIELD                0x00000000 /* =0 */
#define NV_04A_CLIP_E_POINT0_TOP_MSK                       0xFFFF0000 /* 31:16 */ 
#define NV_04A_CLIP_E_POINT0_TOP_RMSK                      0x0000FFFF /* 31:16 */ 
#define NV_04A_CLIP_E_POINT0_TOP_WORD                      0
#define NV_04A_CLIP_E_POINT0_TOP_HIGH_FIELD                0x0000001F /* =31 */
#define NV_04A_CLIP_E_POINT0_TOP_LOW_FIELD                 0x00000010 /* =16 */
#define NV_04A_CLIP_E_POINT0_MSK                           0xFFFFFFFF 
#define NV_04A_CLIP_E_POINT1_RIGHT_MSK                     0x0000FFFF /* 15:0 */ 
#define NV_04A_CLIP_E_POINT1_RIGHT_RMSK                    0x0000FFFF /* 15:0 */ 
#define NV_04A_CLIP_E_POINT1_RIGHT_WORD                    0
#define NV_04A_CLIP_E_POINT1_RIGHT_HIGH_FIELD              0x0000000F /* =15 */
#define NV_04A_CLIP_E_POINT1_RIGHT_LOW_FIELD               0x00000000 /* =0 */
#define NV_04A_CLIP_E_POINT1_BOTTOM_MSK                    0xFFFF0000 /* 31:16 */ 
#define NV_04A_CLIP_E_POINT1_BOTTOM_RMSK                   0x0000FFFF /* 31:16 */ 
#define NV_04A_CLIP_E_POINT1_BOTTOM_WORD                   0
#define NV_04A_CLIP_E_POINT1_BOTTOM_HIGH_FIELD             0x0000001F /* =31 */
#define NV_04A_CLIP_E_POINT1_BOTTOM_LOW_FIELD              0x00000010 /* =16 */
#define NV_04A_CLIP_E_POINT1_MSK                           0xFFFFFFFF 
#define NV_04A_COLOR0_E_VALUE_MSK                          0xFFFFFFFF /* 31:0 */ 
#define NV_04A_COLOR0_E_VALUE_RMSK                         0xFFFFFFFF /* 31:0 */ 
#define NV_04A_COLOR0_E_VALUE_WORD                         0
#define NV_04A_COLOR0_E_VALUE_HIGH_FIELD                   0x0000001F /* =31 */
#define NV_04A_COLOR0_E_VALUE_LOW_FIELD                    0x00000000 /* =0 */
#define NV_04A_COLOR0_E_MSK                                0xFFFFFFFF 
#define NV_04A_COLOR1_E_VALUE_MSK                          0xFFFFFFFF /* 31:0 */ 
#define NV_04A_COLOR1_E_VALUE_RMSK                         0xFFFFFFFF /* 31:0 */ 
#define NV_04A_COLOR1_E_VALUE_WORD                         0
#define NV_04A_COLOR1_E_VALUE_HIGH_FIELD                   0x0000001F /* =31 */
#define NV_04A_COLOR1_E_VALUE_LOW_FIELD                    0x00000000 /* =0 */
#define NV_04A_COLOR1_E_MSK                                0xFFFFFFFF 
#define NV_04A_SIZE_IN_E_WIDTH_MSK                         0x0000FFFF /* 15:0 */ 
#define NV_04A_SIZE_IN_E_WIDTH_RMSK                        0x0000FFFF /* 15:0 */ 
#define NV_04A_SIZE_IN_E_WIDTH_WORD                        0
#define NV_04A_SIZE_IN_E_WIDTH_HIGH_FIELD                  0x0000000F /* =15 */
#define NV_04A_SIZE_IN_E_WIDTH_LOW_FIELD                   0x00000000 /* =0 */
#define NV_04A_SIZE_IN_E_HEIGHT_MSK                        0xFFFF0000 /* 31:16 */ 
#define NV_04A_SIZE_IN_E_HEIGHT_RMSK                       0x0000FFFF /* 31:16 */ 
#define NV_04A_SIZE_IN_E_HEIGHT_WORD                       0
#define NV_04A_SIZE_IN_E_HEIGHT_HIGH_FIELD                 0x0000001F /* =31 */
#define NV_04A_SIZE_IN_E_HEIGHT_LOW_FIELD                  0x00000010 /* =16 */
#define NV_04A_SIZE_IN_E_MSK                               0xFFFFFFFF 
#define NV_04A_SIZE_OUT_E_WIDTH_MSK                        0x0000FFFF /* 15:0 */ 
#define NV_04A_SIZE_OUT_E_WIDTH_RMSK                       0x0000FFFF /* 15:0 */ 
#define NV_04A_SIZE_OUT_E_WIDTH_WORD                       0
#define NV_04A_SIZE_OUT_E_WIDTH_HIGH_FIELD                 0x0000000F /* =15 */
#define NV_04A_SIZE_OUT_E_WIDTH_LOW_FIELD                  0x00000000 /* =0 */
#define NV_04A_SIZE_OUT_E_HEIGHT_MSK                       0xFFFF0000 /* 31:16 */ 
#define NV_04A_SIZE_OUT_E_HEIGHT_RMSK                      0x0000FFFF /* 31:16 */ 
#define NV_04A_SIZE_OUT_E_HEIGHT_WORD                      0
#define NV_04A_SIZE_OUT_E_HEIGHT_HIGH_FIELD                0x0000001F /* =31 */
#define NV_04A_SIZE_OUT_E_HEIGHT_LOW_FIELD                 0x00000010 /* =16 */
#define NV_04A_SIZE_OUT_E_MSK                              0xFFFFFFFF 
#define NV_04A_POINT_E_X_MSK                               0x0000FFFF /* 15:0 */ 
#define NV_04A_POINT_E_X_RMSK                              0x0000FFFF /* 15:0 */ 
#define NV_04A_POINT_E_X_WORD                              0
#define NV_04A_POINT_E_X_HIGH_FIELD                        0x0000000F /* =15 */
#define NV_04A_POINT_E_X_LOW_FIELD                         0x00000000 /* =0 */
#define NV_04A_POINT_E_Y_MSK                               0xFFFF0000 /* 31:16 */ 
#define NV_04A_POINT_E_Y_RMSK                              0x0000FFFF /* 31:16 */ 
#define NV_04A_POINT_E_Y_WORD                              0
#define NV_04A_POINT_E_Y_HIGH_FIELD                        0x0000001F /* =31 */
#define NV_04A_POINT_E_Y_LOW_FIELD                         0x00000010 /* =16 */
#define NV_04A_POINT_E_MSK                                 0xFFFFFFFF 
#define NV_04A_MONOCHROME_COLOR01_E_BITMAP_MSK             0xFFFFFFFF /* 31:0 */ 
#define NV_04A_MONOCHROME_COLOR01_E_BITMAP_RMSK            0xFFFFFFFF /* 31:0 */ 
#define NV_04A_MONOCHROME_COLOR01_E_BITMAP_WORD            0
#define NV_04A_MONOCHROME_COLOR01_E_BITMAP_HIGH_FIELD      0x0000001F /* =31 */
#define NV_04A_MONOCHROME_COLOR01_E_BITMAP_LOW_FIELD       0x00000000 /* =0 */
#define NV_04A_MONOCHROME_COLOR01_E_MSK                    0xFFFFFFFF 
#define NV_04A_FONT_F_OFFSET_MSK                           0x0FFFFFFF /* 27:0 */ 
#define NV_04A_FONT_F_OFFSET_RMSK                          0x0FFFFFFF /* 27:0 */ 
#define NV_04A_FONT_F_OFFSET_WORD                          0
#define NV_04A_FONT_F_OFFSET_HIGH_FIELD                    0x0000001B /* =27 */
#define NV_04A_FONT_F_OFFSET_LOW_FIELD                     0x00000000 /* =0 */
#define NV_04A_FONT_F_PITCH_MSK                            0xF0000000 /* 31:28 */ 
#define NV_04A_FONT_F_PITCH_RMSK                           0x0000000F /* 31:28 */ 
#define NV_04A_FONT_F_PITCH_WORD                           0
#define NV_04A_FONT_F_PITCH_HIGH_FIELD                     0x0000001F /* =31 */
#define NV_04A_FONT_F_PITCH_LOW_FIELD                      0x0000001C /* =28 */
#define NV_04A_FONT_F_PITCH_8_ADJ                          0x30000000
#define NV_04A_FONT_F_PITCH_16_ADJ                         0x40000000
#define NV_04A_FONT_F_PITCH_32_ADJ                         0x50000000
#define NV_04A_FONT_F_PITCH_64_ADJ                         0x60000000
#define NV_04A_FONT_F_PITCH_128_ADJ                        0x70000000
#define NV_04A_FONT_F_PITCH_256_ADJ                        0x80000000
#define NV_04A_FONT_F_PITCH_512_ADJ                        0x90000000
#define NV_04A_FONT_F_MSK                                  0xFFFFFFFF 
#define NV_04A_CLIP_F_POINT0_LEFT_MSK                      0x0000FFFF /* 15:0 */ 
#define NV_04A_CLIP_F_POINT0_LEFT_RMSK                     0x0000FFFF /* 15:0 */ 
#define NV_04A_CLIP_F_POINT0_LEFT_WORD                     0
#define NV_04A_CLIP_F_POINT0_LEFT_HIGH_FIELD               0x0000000F /* =15 */
#define NV_04A_CLIP_F_POINT0_LEFT_LOW_FIELD                0x00000000 /* =0 */
#define NV_04A_CLIP_F_POINT0_TOP_MSK                       0xFFFF0000 /* 31:16 */ 
#define NV_04A_CLIP_F_POINT0_TOP_RMSK                      0x0000FFFF /* 31:16 */ 
#define NV_04A_CLIP_F_POINT0_TOP_WORD                      0
#define NV_04A_CLIP_F_POINT0_TOP_HIGH_FIELD                0x0000001F /* =31 */
#define NV_04A_CLIP_F_POINT0_TOP_LOW_FIELD                 0x00000010 /* =16 */
#define NV_04A_CLIP_F_POINT0_MSK                           0xFFFFFFFF 
#define NV_04A_CLIP_F_POINT1_RIGHT_MSK                     0x0000FFFF /* 15:0 */ 
#define NV_04A_CLIP_F_POINT1_RIGHT_RMSK                    0x0000FFFF /* 15:0 */ 
#define NV_04A_CLIP_F_POINT1_RIGHT_WORD                    0
#define NV_04A_CLIP_F_POINT1_RIGHT_HIGH_FIELD              0x0000000F /* =15 */
#define NV_04A_CLIP_F_POINT1_RIGHT_LOW_FIELD               0x00000000 /* =0 */
#define NV_04A_CLIP_F_POINT1_BOTTOM_MSK                    0xFFFF0000 /* 31:16 */ 
#define NV_04A_CLIP_F_POINT1_BOTTOM_RMSK                   0x0000FFFF /* 31:16 */ 
#define NV_04A_CLIP_F_POINT1_BOTTOM_WORD                   0
#define NV_04A_CLIP_F_POINT1_BOTTOM_HIGH_FIELD             0x0000001F /* =31 */
#define NV_04A_CLIP_F_POINT1_BOTTOM_LOW_FIELD              0x00000010 /* =16 */
#define NV_04A_CLIP_F_POINT1_MSK                           0xFFFFFFFF 
#define NV_04A_COLOR1_F_VALUE_MSK                          0xFFFFFFFF /* 31:0 */ 
#define NV_04A_COLOR1_F_VALUE_RMSK                         0xFFFFFFFF /* 31:0 */ 
#define NV_04A_COLOR1_F_VALUE_WORD                         0
#define NV_04A_COLOR1_F_VALUE_HIGH_FIELD                   0x0000001F /* =31 */
#define NV_04A_COLOR1_F_VALUE_LOW_FIELD                    0x00000000 /* =0 */
#define NV_04A_CHARACTER_COLOR1_F_INDEX_MSK                0x000000FF /* 7:0 */ 
#define NV_04A_CHARACTER_COLOR1_F_INDEX_RMSK               0x000000FF /* 7:0 */ 
#define NV_04A_CHARACTER_COLOR1_F_INDEX_WORD               0
#define NV_04A_CHARACTER_COLOR1_F_INDEX_HIGH_FIELD         0x00000007 /* =7 */
#define NV_04A_CHARACTER_COLOR1_F_INDEX_LOW_FIELD          0x00000000 /* =0 */
#define NV_04A_CHARACTER_COLOR1_F_X_MSK                    0x000FFF00 /* 19:8 */ 
#define NV_04A_CHARACTER_COLOR1_F_X_RMSK                   0x00000FFF /* 19:8 */ 
#define NV_04A_CHARACTER_COLOR1_F_X_WORD                   0
#define NV_04A_CHARACTER_COLOR1_F_X_HIGH_FIELD             0x00000013 /* =19 */
#define NV_04A_CHARACTER_COLOR1_F_X_LOW_FIELD              0x00000008 /* =8 */
#define NV_04A_CHARACTER_COLOR1_F_Y_MSK                    0xFFF00000 /* 31:20 */ 
#define NV_04A_CHARACTER_COLOR1_F_Y_RMSK                   0x00000FFF /* 31:20 */ 
#define NV_04A_CHARACTER_COLOR1_F_Y_WORD                   0
#define NV_04A_CHARACTER_COLOR1_F_Y_HIGH_FIELD             0x0000001F /* =31 */
#define NV_04A_CHARACTER_COLOR1_F_Y_LOW_FIELD              0x00000014 /* =20 */
#define NV_04A_CHARACTER_COLOR1_F_MSK                      0xFFFFFFFF 
#define NV_04A_FONT_G_OFFSET_MSK                           0x0FFFFFFF /* 27:0 */ 
#define NV_04A_FONT_G_OFFSET_RMSK                          0x0FFFFFFF /* 27:0 */ 
#define NV_04A_FONT_G_OFFSET_WORD                          0
#define NV_04A_FONT_G_OFFSET_HIGH_FIELD                    0x0000001B /* =27 */
#define NV_04A_FONT_G_OFFSET_LOW_FIELD                     0x00000000 /* =0 */
#define NV_04A_FONT_G_PITCH_MSK                            0xF0000000 /* 31:28 */ 
#define NV_04A_FONT_G_PITCH_RMSK                           0x0000000F /* 31:28 */ 
#define NV_04A_FONT_G_PITCH_WORD                           0
#define NV_04A_FONT_G_PITCH_HIGH_FIELD                     0x0000001F /* =31 */
#define NV_04A_FONT_G_PITCH_LOW_FIELD                      0x0000001C /* =28 */
#define NV_04A_FONT_G_PITCH_8_ADJ                          0x30000000
#define NV_04A_FONT_G_PITCH_16_ADJ                         0x40000000
#define NV_04A_FONT_G_PITCH_32_ADJ                         0x50000000
#define NV_04A_FONT_G_PITCH_64_ADJ                         0x60000000
#define NV_04A_FONT_G_PITCH_128_ADJ                        0x70000000
#define NV_04A_FONT_G_PITCH_256_ADJ                        0x80000000
#define NV_04A_FONT_G_PITCH_512_ADJ                        0x90000000
#define NV_04A_FONT_G_MSK                                  0xFFFFFFFF 
#define NV_04A_CLIP_G_POINT0_LEFT_MSK                      0x0000FFFF /* 15:0 */ 
#define NV_04A_CLIP_G_POINT0_LEFT_RMSK                     0x0000FFFF /* 15:0 */ 
#define NV_04A_CLIP_G_POINT0_LEFT_WORD                     0
#define NV_04A_CLIP_G_POINT0_LEFT_HIGH_FIELD               0x0000000F /* =15 */
#define NV_04A_CLIP_G_POINT0_LEFT_LOW_FIELD                0x00000000 /* =0 */
#define NV_04A_CLIP_G_POINT0_TOP_MSK                       0xFFFF0000 /* 31:16 */ 
#define NV_04A_CLIP_G_POINT0_TOP_RMSK                      0x0000FFFF /* 31:16 */ 
#define NV_04A_CLIP_G_POINT0_TOP_WORD                      0
#define NV_04A_CLIP_G_POINT0_TOP_HIGH_FIELD                0x0000001F /* =31 */
#define NV_04A_CLIP_G_POINT0_TOP_LOW_FIELD                 0x00000010 /* =16 */
#define NV_04A_CLIP_G_POINT0_MSK                           0xFFFFFFFF 
#define NV_04A_CLIP_G_POINT1_RIGHT_MSK                     0x0000FFFF /* 15:0 */ 
#define NV_04A_CLIP_G_POINT1_RIGHT_RMSK                    0x0000FFFF /* 15:0 */ 
#define NV_04A_CLIP_G_POINT1_RIGHT_WORD                    0
#define NV_04A_CLIP_G_POINT1_RIGHT_HIGH_FIELD              0x0000000F /* =15 */
#define NV_04A_CLIP_G_POINT1_RIGHT_LOW_FIELD               0x00000000 /* =0 */
#define NV_04A_CLIP_G_POINT1_BOTTOM_MSK                    0xFFFF0000 /* 31:16 */ 
#define NV_04A_CLIP_G_POINT1_BOTTOM_RMSK                   0x0000FFFF /* 31:16 */ 
#define NV_04A_CLIP_G_POINT1_BOTTOM_WORD                   0
#define NV_04A_CLIP_G_POINT1_BOTTOM_HIGH_FIELD             0x0000001F /* =31 */
#define NV_04A_CLIP_G_POINT1_BOTTOM_LOW_FIELD              0x00000010 /* =16 */
#define NV_04A_CLIP_G_POINT1_MSK                           0xFFFFFFFF 
#define NV_04A_COLOR1_G_VALUE_MSK                          0xFFFFFFFF /* 31:0 */ 
#define NV_04A_COLOR1_G_VALUE_RMSK                         0xFFFFFFFF /* 31:0 */ 
#define NV_04A_COLOR1_G_VALUE_WORD                         0
#define NV_04A_COLOR1_G_VALUE_HIGH_FIELD                   0x0000001F /* =31 */
#define NV_04A_COLOR1_G_VALUE_LOW_FIELD                    0x00000000 /* =0 */
#define NV_04A_CHARACTER_COLOR1_G_POINT_X_MSK              0x0000FFFF /* 15:0 */ 
#define NV_04A_CHARACTER_COLOR1_G_POINT_X_RMSK             0x0000FFFF /* 15:0 */ 
#define NV_04A_CHARACTER_COLOR1_G_POINT_X_WORD             0
#define NV_04A_CHARACTER_COLOR1_G_POINT_X_HIGH_FIELD       0x0000000F /* =15 */
#define NV_04A_CHARACTER_COLOR1_G_POINT_X_LOW_FIELD        0x00000000 /* =0 */
#define NV_04A_CHARACTER_COLOR1_G_POINT_Y_MSK              0xFFFF0000 /* 31:16 */ 
#define NV_04A_CHARACTER_COLOR1_G_POINT_Y_RMSK             0x0000FFFF /* 31:16 */ 
#define NV_04A_CHARACTER_COLOR1_G_POINT_Y_WORD             0
#define NV_04A_CHARACTER_COLOR1_G_POINT_Y_HIGH_FIELD       0x0000001F /* =31 */
#define NV_04A_CHARACTER_COLOR1_G_POINT_Y_LOW_FIELD        0x00000010 /* =16 */
#define NV_04A_CHARACTER_COLOR1_G_POINT_MSK                0xFFFFFFFF 
#define NV_04A_CHARACTER_COLOR1_G_INDEX_VALUE_MSK          0xFFFFFFFF /* 31:0 */ 
#define NV_04A_CHARACTER_COLOR1_G_INDEX_VALUE_RMSK         0xFFFFFFFF /* 31:0 */ 
#define NV_04A_CHARACTER_COLOR1_G_INDEX_VALUE_WORD         0
#define NV_04A_CHARACTER_COLOR1_G_INDEX_VALUE_HIGH_FIELD   0x0000001F /* =31 */
#define NV_04A_CHARACTER_COLOR1_G_INDEX_VALUE_LOW_FIELD    0x00000000 /* =0 */
#define NV_04A_CHARACTER_COLOR1_G_INDEX_MSK                0xFFFFFFFF 
#define NV_UMEMFMT_HIGH_FIELD                              0x004D1FFF /* =5054463 */
#define NV_UMEMFMT_LOW_FIELD                               0x004D0000 /* =5046272 */
#define NV_UMEMFMT_CTX_SWITCH_ADJ                          0x004D0000
#define NV_UMEMFMT_CTX_SWITCH_MSK                          0x00000000 
#define NV_UMEMFMT_NOP_ADJ                                 0x004D0100
#define NV_UMEMFMT_NOP_PARAMETER_MSK                       0xFFFFFFFF /* 31:0 */ 
#define NV_UMEMFMT_NOP_PARAMETER_RMSK                      0xFFFFFFFF /* 31:0 */ 
#define NV_UMEMFMT_NOP_PARAMETER_WORD                      0
#define NV_UMEMFMT_NOP_PARAMETER_HIGH_FIELD                0x0000001F /* =31 */
#define NV_UMEMFMT_NOP_PARAMETER_LOW_FIELD                 0x00000000 /* =0 */
#define NV_UMEMFMT_NOP_MSK                                 0xFFFFFFFF 
#define NV_UMEMFMT_NOTIFY_STYLE_MSK                        0xFFFFFFFF /* 31:0 */ 
#define NV_UMEMFMT_NOTIFY_STYLE_RMSK                       0xFFFFFFFF /* 31:0 */ 
#define NV_UMEMFMT_NOTIFY_STYLE_WORD                       0
#define NV_UMEMFMT_NOTIFY_STYLE_HIGH_FIELD                 0x0000001F /* =31 */
#define NV_UMEMFMT_NOTIFY_STYLE_LOW_FIELD                  0x00000000 /* =0 */
#define NV_UMEMFMT_NOTIFY_STYLE_WRITE_ONLY_ADJ             0x00000000
#define NV_UMEMFMT_NOTIFY_STYLE_WRITE_THEN_AWAKEN_ADJ      0x00000001
#define NV_UMEMFMT_NOTIFY_MSK                              0xFFFFFFFF 
#define NV_UMEMFMT_SET_NOTIFY_PARAMETER_MSK                0xFFFFFFFF /* 31:0 */ 
#define NV_UMEMFMT_SET_NOTIFY_PARAMETER_RMSK               0xFFFFFFFF /* 31:0 */ 
#define NV_UMEMFMT_SET_NOTIFY_PARAMETER_WORD               0
#define NV_UMEMFMT_SET_NOTIFY_PARAMETER_HIGH_FIELD         0x0000001F /* =31 */
#define NV_UMEMFMT_SET_NOTIFY_PARAMETER_LOW_FIELD          0x00000000 /* =0 */
#define NV_UMEMFMT_SET_NOTIFY_PARAMETER_WRITE_ADJ          0x00000000
#define NV_UMEMFMT_SET_NOTIFY_MSK                          0xFFFFFFFF 
#define NV_UMEMFMT_SET_CONTEXT_DMA_NOTIFY_INSTANCE_MSK     0x0000FFFF /* 15:0 */ 
#define NV_UMEMFMT_SET_CONTEXT_DMA_NOTIFY_INSTANCE_RMSK    0x0000FFFF /* 15:0 */ 
#define NV_UMEMFMT_SET_CONTEXT_DMA_NOTIFY_INSTANCE_WORD    0
#define NV_UMEMFMT_SET_CONTEXT_DMA_NOTIFY_INSTANCE_HIGH_FIELD 0x0000000F /* =15 */
#define NV_UMEMFMT_SET_CONTEXT_DMA_NOTIFY_INSTANCE_LOW_FIELD 0x00000000 /* =0 */
#define NV_UMEMFMT_SET_CONTEXT_DMA_NOTIFY_MSK              0x0000FFFF 
#define NV_UMEMFMT_SET_CONTEXT_DMA_BUFFER_IN_INSTANCE_MSK  0x0000FFFF /* 15:0 */ 
#define NV_UMEMFMT_SET_CONTEXT_DMA_BUFFER_IN_INSTANCE_RMSK 0x0000FFFF /* 15:0 */ 
#define NV_UMEMFMT_SET_CONTEXT_DMA_BUFFER_IN_INSTANCE_WORD 0
#define NV_UMEMFMT_SET_CONTEXT_DMA_BUFFER_IN_INSTANCE_HIGH_FIELD 0x0000000F /* =15 */
#define NV_UMEMFMT_SET_CONTEXT_DMA_BUFFER_IN_INSTANCE_LOW_FIELD 0x00000000 /* =0 */
#define NV_UMEMFMT_SET_CONTEXT_DMA_BUFFER_IN_MSK           0x0000FFFF 
#define NV_UMEMFMT_SET_CONTEXT_DMA_BUFFER_OUT_INSTANCE_MSK 0x0000FFFF /* 15:0 */ 
#define NV_UMEMFMT_SET_CONTEXT_DMA_BUFFER_OUT_INSTANCE_RMSK 0x0000FFFF /* 15:0 */ 
#define NV_UMEMFMT_SET_CONTEXT_DMA_BUFFER_OUT_INSTANCE_WORD 0
#define NV_UMEMFMT_SET_CONTEXT_DMA_BUFFER_OUT_INSTANCE_HIGH_FIELD 0x0000000F /* =15 */
#define NV_UMEMFMT_SET_CONTEXT_DMA_BUFFER_OUT_INSTANCE_LOW_FIELD 0x00000000 /* =0 */
#define NV_UMEMFMT_SET_CONTEXT_DMA_BUFFER_OUT_MSK          0x0000FFFF 
#define NV_UMEMFMT_OFFSET_IN_VALUE_MSK                     0xFFFFFFFF /* 31:0 */ 
#define NV_UMEMFMT_OFFSET_IN_VALUE_RMSK                    0xFFFFFFFF /* 31:0 */ 
#define NV_UMEMFMT_OFFSET_IN_VALUE_WORD                    0
#define NV_UMEMFMT_OFFSET_IN_VALUE_HIGH_FIELD              0x0000001F /* =31 */
#define NV_UMEMFMT_OFFSET_IN_VALUE_LOW_FIELD               0x00000000 /* =0 */
#define NV_UMEMFMT_OFFSET_IN_MSK                           0xFFFFFFFF 
#define NV_UMEMFMT_OFFSET_OUT_VALUE_MSK                    0xFFFFFFFF /* 31:0 */ 
#define NV_UMEMFMT_OFFSET_OUT_VALUE_RMSK                   0xFFFFFFFF /* 31:0 */ 
#define NV_UMEMFMT_OFFSET_OUT_VALUE_WORD                   0
#define NV_UMEMFMT_OFFSET_OUT_VALUE_HIGH_FIELD             0x0000001F /* =31 */
#define NV_UMEMFMT_OFFSET_OUT_VALUE_LOW_FIELD              0x00000000 /* =0 */
#define NV_UMEMFMT_OFFSET_OUT_MSK                          0xFFFFFFFF 
#define NV_UMEMFMT_PITCH_IN_VALUE_MSK                      0xFFFFFFFF /* 31:0 */ 
#define NV_UMEMFMT_PITCH_IN_VALUE_RMSK                     0xFFFFFFFF /* 31:0 */ 
#define NV_UMEMFMT_PITCH_IN_VALUE_WORD                     0
#define NV_UMEMFMT_PITCH_IN_VALUE_HIGH_FIELD               0x0000001F /* =31 */
#define NV_UMEMFMT_PITCH_IN_VALUE_LOW_FIELD                0x00000000 /* =0 */
#define NV_UMEMFMT_PITCH_IN_MSK                            0xFFFFFFFF 
#define NV_UMEMFMT_PITCH_OUT_VALUE_MSK                     0xFFFFFFFF /* 31:0 */ 
#define NV_UMEMFMT_PITCH_OUT_VALUE_RMSK                    0xFFFFFFFF /* 31:0 */ 
#define NV_UMEMFMT_PITCH_OUT_VALUE_WORD                    0
#define NV_UMEMFMT_PITCH_OUT_VALUE_HIGH_FIELD              0x0000001F /* =31 */
#define NV_UMEMFMT_PITCH_OUT_VALUE_LOW_FIELD               0x00000000 /* =0 */
#define NV_UMEMFMT_PITCH_OUT_MSK                           0xFFFFFFFF 
#define NV_UMEMFMT_LINE_LENGTH_IN_VALUE_MSK                0xFFFFFFFF /* 31:0 */ 
#define NV_UMEMFMT_LINE_LENGTH_IN_VALUE_RMSK               0xFFFFFFFF /* 31:0 */ 
#define NV_UMEMFMT_LINE_LENGTH_IN_VALUE_WORD               0
#define NV_UMEMFMT_LINE_LENGTH_IN_VALUE_HIGH_FIELD         0x0000001F /* =31 */
#define NV_UMEMFMT_LINE_LENGTH_IN_VALUE_LOW_FIELD          0x00000000 /* =0 */
#define NV_UMEMFMT_LINE_LENGTH_IN_MSK                      0xFFFFFFFF 
#define NV_UMEMFMT_LINE_COUNT_VALUE_MSK                    0xFFFFFFFF /* 31:0 */ 
#define NV_UMEMFMT_LINE_COUNT_VALUE_RMSK                   0xFFFFFFFF /* 31:0 */ 
#define NV_UMEMFMT_LINE_COUNT_VALUE_WORD                   0
#define NV_UMEMFMT_LINE_COUNT_VALUE_HIGH_FIELD             0x0000001F /* =31 */
#define NV_UMEMFMT_LINE_COUNT_VALUE_LOW_FIELD              0x00000000 /* =0 */
#define NV_UMEMFMT_LINE_COUNT_MSK                          0xFFFFFFFF 
#define NV_UMEMFMT_FORMAT_INPUT_INC_MSK                    0x00000007 /* 2:0 */ 
#define NV_UMEMFMT_FORMAT_INPUT_INC_RMSK                   0x00000007 /* 2:0 */ 
#define NV_UMEMFMT_FORMAT_INPUT_INC_WORD                   0
#define NV_UMEMFMT_FORMAT_INPUT_INC_HIGH_FIELD             0x00000002 /* =2 */
#define NV_UMEMFMT_FORMAT_INPUT_INC_LOW_FIELD              0x00000000 /* =0 */
#define NV_UMEMFMT_FORMAT_INPUT_INC_1_ADJ                  0x00000001
#define NV_UMEMFMT_FORMAT_INPUT_INC_2_ADJ                  0x00000002
#define NV_UMEMFMT_FORMAT_INPUT_INC_4_ADJ                  0x00000004
#define NV_UMEMFMT_FORMAT_OUTPUT_INC_MSK                   0x00000700 /* 10:8 */ 
#define NV_UMEMFMT_FORMAT_OUTPUT_INC_RMSK                  0x00000007 /* 10:8 */ 
#define NV_UMEMFMT_FORMAT_OUTPUT_INC_WORD                  0
#define NV_UMEMFMT_FORMAT_OUTPUT_INC_HIGH_FIELD            0x0000000A /* =10 */
#define NV_UMEMFMT_FORMAT_OUTPUT_INC_LOW_FIELD             0x00000008 /* =8 */
#define NV_UMEMFMT_FORMAT_OUTPUT_INC_1_ADJ                 0x00000100
#define NV_UMEMFMT_FORMAT_OUTPUT_INC_2_ADJ                 0x00000200
#define NV_UMEMFMT_FORMAT_OUTPUT_INC_4_ADJ                 0x00000400
#define NV_UMEMFMT_FORMAT_MSK                              0x00000707 
#define NV_UMEMFMT_BUF_NOTIFY_VALUE_MSK                    0xFFFFFFFF /* 31:0 */ 
#define NV_UMEMFMT_BUF_NOTIFY_VALUE_RMSK                   0xFFFFFFFF /* 31:0 */ 
#define NV_UMEMFMT_BUF_NOTIFY_VALUE_WORD                   0
#define NV_UMEMFMT_BUF_NOTIFY_VALUE_HIGH_FIELD             0x0000001F /* =31 */
#define NV_UMEMFMT_BUF_NOTIFY_VALUE_LOW_FIELD              0x00000000 /* =0 */
#define NV_UMEMFMT_BUF_NOTIFY_MSK                          0xFFFFFFFF 
#define NV_USTRTCH_HIGH_FIELD                              0x00551FFF /* =5578751 */
#define NV_USTRTCH_LOW_FIELD                               0x00550000 /* =5570560 */
#define NV_USTRTCH_CTX_SWITCH_ADJ                          0x00550000
#define NV_USTRTCH_CTX_SWITCH_INSTANCE_MSK                 0x0000FFFF /* 15:0 */ 
#define NV_USTRTCH_CTX_SWITCH_INSTANCE_RMSK                0x0000FFFF /* 15:0 */ 
#define NV_USTRTCH_CTX_SWITCH_INSTANCE_WORD                0
#define NV_USTRTCH_CTX_SWITCH_INSTANCE_HIGH_FIELD          0x0000000F /* =15 */
#define NV_USTRTCH_CTX_SWITCH_INSTANCE_LOW_FIELD           0x00000000 /* =0 */
#define NV_USTRTCH_CTX_SWITCH_CHID_MSK                     0x007F0000 /* 22:16 */ 
#define NV_USTRTCH_CTX_SWITCH_CHID_RMSK                    0x0000007F /* 22:16 */ 
#define NV_USTRTCH_CTX_SWITCH_CHID_WORD                    0
#define NV_USTRTCH_CTX_SWITCH_CHID_HIGH_FIELD              0x00000016 /* =22 */
#define NV_USTRTCH_CTX_SWITCH_CHID_LOW_FIELD               0x00000010 /* =16 */
#define NV_USTRTCH_CTX_SWITCH_VOLATILE_MSK                 0x80000000 /* 31:31 */ 
#define NV_USTRTCH_CTX_SWITCH_VOLATILE_RMSK                0x00000001 /* 31:31 */ 
#define NV_USTRTCH_CTX_SWITCH_VOLATILE_WORD                0
#define NV_USTRTCH_CTX_SWITCH_VOLATILE_HIGH_FIELD          0x0000001F /* =31 */
#define NV_USTRTCH_CTX_SWITCH_VOLATILE_LOW_FIELD           0x0000001F /* =31 */
#define NV_USTRTCH_CTX_SWITCH_VOLATILE_IGNORE_ADJ          0x00000000
#define NV_USTRTCH_CTX_SWITCH_VOLATILE_RESET_ADJ           0x80000000
#define NV_USTRTCH_CTX_SWITCH_MSK                          0x807FFFFF 
#define NV_USTRTCH_NOP_PARAMETER_MSK                       0xFFFFFFFF /* 31:0 */ 
#define NV_USTRTCH_NOP_PARAMETER_RMSK                      0xFFFFFFFF /* 31:0 */ 
#define NV_USTRTCH_NOP_PARAMETER_WORD                      0
#define NV_USTRTCH_NOP_PARAMETER_HIGH_FIELD                0x0000001F /* =31 */
#define NV_USTRTCH_NOP_PARAMETER_LOW_FIELD                 0x00000000 /* =0 */
#define NV_USTRTCH_NOP_MSK                                 0xFFFFFFFF 
#define NV_USTRTCH_NOTIFY_STYLE_MSK                        0xFFFFFFFF /* 31:0 */ 
#define NV_USTRTCH_NOTIFY_STYLE_RMSK                       0xFFFFFFFF /* 31:0 */ 
#define NV_USTRTCH_NOTIFY_STYLE_WORD                       0
#define NV_USTRTCH_NOTIFY_STYLE_HIGH_FIELD                 0x0000001F /* =31 */
#define NV_USTRTCH_NOTIFY_STYLE_LOW_FIELD                  0x00000000 /* =0 */
#define NV_USTRTCH_NOTIFY_STYLE_WRITE_ONLY_ADJ             0x00000000
#define NV_USTRTCH_NOTIFY_STYLE_WRITE_THEN_AWAKEN_ADJ      0x00000001
#define NV_USTRTCH_NOTIFY_MSK                              0xFFFFFFFF 
#define NV_USTRTCH_SET_NOTIFY_PARAMETER_MSK                0xFFFFFFFF /* 31:0 */ 
#define NV_USTRTCH_SET_NOTIFY_PARAMETER_RMSK               0xFFFFFFFF /* 31:0 */ 
#define NV_USTRTCH_SET_NOTIFY_PARAMETER_WORD               0
#define NV_USTRTCH_SET_NOTIFY_PARAMETER_HIGH_FIELD         0x0000001F /* =31 */
#define NV_USTRTCH_SET_NOTIFY_PARAMETER_LOW_FIELD          0x00000000 /* =0 */
#define NV_USTRTCH_SET_NOTIFY_PARAMETER_WRITE_ADJ          0x00000000
#define NV_USTRTCH_SET_NOTIFY_MSK                          0xFFFFFFFF 
#define NV_USTRTCH_SET_PATCH_PARAMETER_MSK                 0xFFFFFFFF /* 31:0 */ 
#define NV_USTRTCH_SET_PATCH_PARAMETER_RMSK                0xFFFFFFFF /* 31:0 */ 
#define NV_USTRTCH_SET_PATCH_PARAMETER_WORD                0
#define NV_USTRTCH_SET_PATCH_PARAMETER_HIGH_FIELD          0x0000001F /* =31 */
#define NV_USTRTCH_SET_PATCH_PARAMETER_LOW_FIELD           0x00000000 /* =0 */
#define NV_USTRTCH_SET_PATCH_PARAMETER_INVALIDATE_ADJ      0x00000000
#define NV_USTRTCH_SET_PATCH_PARAMETER_VALIDATE_ADJ        0x00000001
#define NV_USTRTCH_SET_PATCH_MSK                           0xFFFFFFFF 
#define NV_USTRTCH_SET_CONTEXT_DMA_NOTIFY_PARAMETER_MSK    0xFFFFFFFF /* 31:0 */ 
#define NV_USTRTCH_SET_CONTEXT_DMA_NOTIFY_PARAMETER_RMSK   0xFFFFFFFF /* 31:0 */ 
#define NV_USTRTCH_SET_CONTEXT_DMA_NOTIFY_PARAMETER_WORD   0
#define NV_USTRTCH_SET_CONTEXT_DMA_NOTIFY_PARAMETER_HIGH_FIELD 0x0000001F /* =31 */
#define NV_USTRTCH_SET_CONTEXT_DMA_NOTIFY_PARAMETER_LOW_FIELD 0x00000000 /* =0 */
#define NV_USTRTCH_SET_CONTEXT_DMA_NOTIFY_MSK              0xFFFFFFFF 
#define NV_USTRTCH_SET_IMAGE_OUTPUT_PARAMETER_MSK          0xFFFFFFFF /* 31:0 */ 
#define NV_USTRTCH_SET_IMAGE_OUTPUT_PARAMETER_RMSK         0xFFFFFFFF /* 31:0 */ 
#define NV_USTRTCH_SET_IMAGE_OUTPUT_PARAMETER_WORD         0
#define NV_USTRTCH_SET_IMAGE_OUTPUT_PARAMETER_HIGH_FIELD   0x0000001F /* =31 */
#define NV_USTRTCH_SET_IMAGE_OUTPUT_PARAMETER_LOW_FIELD    0x00000000 /* =0 */
#define NV_USTRTCH_SET_IMAGE_OUTPUT_MSK                    0xFFFFFFFF 
#define NV_USTRTCH_SET_COLOR_FORMAT_LE_MSK                 0xFFFFFFFF /* 31:0 */ 
#define NV_USTRTCH_SET_COLOR_FORMAT_LE_RMSK                0xFFFFFFFF /* 31:0 */ 
#define NV_USTRTCH_SET_COLOR_FORMAT_LE_WORD                0
#define NV_USTRTCH_SET_COLOR_FORMAT_LE_HIGH_FIELD          0x0000001F /* =31 */
#define NV_USTRTCH_SET_COLOR_FORMAT_LE_LOW_FIELD           0x00000000 /* =0 */
#define NV_USTRTCH_SET_COLOR_FORMAT_LE_R5G6B5_ADJ          0x00000001
#define NV_USTRTCH_SET_COLOR_FORMAT_LE_A1R5G5B5_ADJ        0x00000002
#define NV_USTRTCH_SET_COLOR_FORMAT_LE_X1R5G5B5_ADJ        0x00000003
#define NV_USTRTCH_SET_COLOR_FORMAT_LE_A8R8G8B8_ADJ        0x00000004
#define NV_USTRTCH_SET_COLOR_FORMAT_LE_X8R8G8B8_ADJ        0x00000005
#define NV_USTRTCH_SET_COLOR_FORMAT_MSK                    0xFFFFFFFF 
#define NV_USTRTCH_SIZE_IN_WIDTH_MSK                       0x0000FFFF /* 15:0 */ 
#define NV_USTRTCH_SIZE_IN_WIDTH_RMSK                      0x0000FFFF /* 15:0 */ 
#define NV_USTRTCH_SIZE_IN_WIDTH_WORD                      0
#define NV_USTRTCH_SIZE_IN_WIDTH_HIGH_FIELD                0x0000000F /* =15 */
#define NV_USTRTCH_SIZE_IN_WIDTH_LOW_FIELD                 0x00000000 /* =0 */
#define NV_USTRTCH_SIZE_IN_HEIGHT_MSK                      0xFFFF0000 /* 31:16 */ 
#define NV_USTRTCH_SIZE_IN_HEIGHT_RMSK                     0x0000FFFF /* 31:16 */ 
#define NV_USTRTCH_SIZE_IN_HEIGHT_WORD                     0
#define NV_USTRTCH_SIZE_IN_HEIGHT_HIGH_FIELD               0x0000001F /* =31 */
#define NV_USTRTCH_SIZE_IN_HEIGHT_LOW_FIELD                0x00000010 /* =16 */
#define NV_USTRTCH_SIZE_IN_MSK                             0xFFFFFFFF 
#define NV_USTRTCH_DELTA_DX_DU_R_FRACTION_MSK              0x000FFFFF /* 19:0 */ 
#define NV_USTRTCH_DELTA_DX_DU_R_FRACTION_RMSK             0x000FFFFF /* 19:0 */ 
#define NV_USTRTCH_DELTA_DX_DU_R_FRACTION_WORD             0
#define NV_USTRTCH_DELTA_DX_DU_R_FRACTION_HIGH_FIELD       0x00000013 /* =19 */
#define NV_USTRTCH_DELTA_DX_DU_R_FRACTION_LOW_FIELD        0x00000000 /* =0 */
#define NV_USTRTCH_DELTA_DX_DU_R_INT_MSK                   0xFFF00000 /* 31:20 */ 
#define NV_USTRTCH_DELTA_DX_DU_R_INT_RMSK                  0x00000FFF /* 31:20 */ 
#define NV_USTRTCH_DELTA_DX_DU_R_INT_WORD                  0
#define NV_USTRTCH_DELTA_DX_DU_R_INT_HIGH_FIELD            0x0000001F /* =31 */
#define NV_USTRTCH_DELTA_DX_DU_R_INT_LOW_FIELD             0x00000014 /* =20 */
#define NV_USTRTCH_DELTA_DX_DU_R_MSK                       0xFFFFFFFF /* 31:0 */ 
#define NV_USTRTCH_DELTA_DX_DU_R_RMSK                      0xFFFFFFFF /* 31:0 */ 
#define NV_USTRTCH_DELTA_DX_DU_R_WORD                      0
#define NV_USTRTCH_DELTA_DX_DU_R_HIGH_FIELD                0x0000001F /* =31 */
#define NV_USTRTCH_DELTA_DX_DU_R_LOW_FIELD                 0x00000000 /* =0 */
#define NV_USTRTCH_DELTA_DX_DU_MSK                         0xFFFFFFFF 
#define NV_USTRTCH_DELTA_DY_DV_R_FRACTION_MSK              0x000FFFFF /* 19:0 */ 
#define NV_USTRTCH_DELTA_DY_DV_R_FRACTION_RMSK             0x000FFFFF /* 19:0 */ 
#define NV_USTRTCH_DELTA_DY_DV_R_FRACTION_WORD             0
#define NV_USTRTCH_DELTA_DY_DV_R_FRACTION_HIGH_FIELD       0x00000013 /* =19 */
#define NV_USTRTCH_DELTA_DY_DV_R_FRACTION_LOW_FIELD        0x00000000 /* =0 */
#define NV_USTRTCH_DELTA_DY_DV_R_INT_MSK                   0xFFF00000 /* 31:20 */ 
#define NV_USTRTCH_DELTA_DY_DV_R_INT_RMSK                  0x00000FFF /* 31:20 */ 
#define NV_USTRTCH_DELTA_DY_DV_R_INT_WORD                  0
#define NV_USTRTCH_DELTA_DY_DV_R_INT_HIGH_FIELD            0x0000001F /* =31 */
#define NV_USTRTCH_DELTA_DY_DV_R_INT_LOW_FIELD             0x00000014 /* =20 */
#define NV_USTRTCH_DELTA_DY_DV_R_MSK                       0xFFFFFFFF /* 31:0 */ 
#define NV_USTRTCH_DELTA_DY_DV_R_RMSK                      0xFFFFFFFF /* 31:0 */ 
#define NV_USTRTCH_DELTA_DY_DV_R_WORD                      0
#define NV_USTRTCH_DELTA_DY_DV_R_HIGH_FIELD                0x0000001F /* =31 */
#define NV_USTRTCH_DELTA_DY_DV_R_LOW_FIELD                 0x00000000 /* =0 */
#define NV_USTRTCH_DELTA_DY_DV_MSK                         0xFFFFFFFF 
#define NV_USTRTCH_CLIP_0_X_MSK                            0x0000FFFF /* 15:0 */ 
#define NV_USTRTCH_CLIP_0_X_RMSK                           0x0000FFFF /* 15:0 */ 
#define NV_USTRTCH_CLIP_0_X_WORD                           0
#define NV_USTRTCH_CLIP_0_X_HIGH_FIELD                     0x0000000F /* =15 */
#define NV_USTRTCH_CLIP_0_X_LOW_FIELD                      0x00000000 /* =0 */
#define NV_USTRTCH_CLIP_0_Y_MSK                            0xFFFF0000 /* 31:16 */ 
#define NV_USTRTCH_CLIP_0_Y_RMSK                           0x0000FFFF /* 31:16 */ 
#define NV_USTRTCH_CLIP_0_Y_WORD                           0
#define NV_USTRTCH_CLIP_0_Y_HIGH_FIELD                     0x0000001F /* =31 */
#define NV_USTRTCH_CLIP_0_Y_LOW_FIELD                      0x00000010 /* =16 */
#define NV_USTRTCH_CLIP_0_MSK                              0xFFFFFFFF 
#define NV_USTRTCH_CLIP_1_WIDTH_MSK                        0x0000FFFF /* 15:0 */ 
#define NV_USTRTCH_CLIP_1_WIDTH_RMSK                       0x0000FFFF /* 15:0 */ 
#define NV_USTRTCH_CLIP_1_WIDTH_WORD                       0
#define NV_USTRTCH_CLIP_1_WIDTH_HIGH_FIELD                 0x0000000F /* =15 */
#define NV_USTRTCH_CLIP_1_WIDTH_LOW_FIELD                  0x00000000 /* =0 */
#define NV_USTRTCH_CLIP_1_HEIGHT_MSK                       0xFFFF0000 /* 31:16 */ 
#define NV_USTRTCH_CLIP_1_HEIGHT_RMSK                      0x0000FFFF /* 31:16 */ 
#define NV_USTRTCH_CLIP_1_HEIGHT_WORD                      0
#define NV_USTRTCH_CLIP_1_HEIGHT_HIGH_FIELD                0x0000001F /* =31 */
#define NV_USTRTCH_CLIP_1_HEIGHT_LOW_FIELD                 0x00000010 /* =16 */
#define NV_USTRTCH_CLIP_1_MSK                              0xFFFFFFFF 
#define NV_USTRTCH_POINT12D4_X_FRACTION_MSK                0x0000000F /* 3:0 */ 
#define NV_USTRTCH_POINT12D4_X_FRACTION_RMSK               0x0000000F /* 3:0 */ 
#define NV_USTRTCH_POINT12D4_X_FRACTION_WORD               0
#define NV_USTRTCH_POINT12D4_X_FRACTION_HIGH_FIELD         0x00000003 /* =3 */
#define NV_USTRTCH_POINT12D4_X_FRACTION_LOW_FIELD          0x00000000 /* =0 */
#define NV_USTRTCH_POINT12D4_X_INT_MSK                     0x0000FFF0 /* 15:4 */ 
#define NV_USTRTCH_POINT12D4_X_INT_RMSK                    0x00000FFF /* 15:4 */ 
#define NV_USTRTCH_POINT12D4_X_INT_WORD                    0
#define NV_USTRTCH_POINT12D4_X_INT_HIGH_FIELD              0x0000000F /* =15 */
#define NV_USTRTCH_POINT12D4_X_INT_LOW_FIELD               0x00000004 /* =4 */
#define NV_USTRTCH_POINT12D4_X_MSK                         0x0000FFFF /* 15:0 */ 
#define NV_USTRTCH_POINT12D4_X_RMSK                        0x0000FFFF /* 15:0 */ 
#define NV_USTRTCH_POINT12D4_X_WORD                        0
#define NV_USTRTCH_POINT12D4_X_HIGH_FIELD                  0x0000000F /* =15 */
#define NV_USTRTCH_POINT12D4_X_LOW_FIELD                   0x00000000 /* =0 */
#define NV_USTRTCH_POINT12D4_Y_FRACTION_MSK                0x000F0000 /* 19:16 */ 
#define NV_USTRTCH_POINT12D4_Y_FRACTION_RMSK               0x0000000F /* 19:16 */ 
#define NV_USTRTCH_POINT12D4_Y_FRACTION_WORD               0
#define NV_USTRTCH_POINT12D4_Y_FRACTION_HIGH_FIELD         0x00000013 /* =19 */
#define NV_USTRTCH_POINT12D4_Y_FRACTION_LOW_FIELD          0x00000010 /* =16 */
#define NV_USTRTCH_POINT12D4_Y_INT_MSK                     0xFFF00000 /* 31:20 */ 
#define NV_USTRTCH_POINT12D4_Y_INT_RMSK                    0x00000FFF /* 31:20 */ 
#define NV_USTRTCH_POINT12D4_Y_INT_WORD                    0
#define NV_USTRTCH_POINT12D4_Y_INT_HIGH_FIELD              0x0000001F /* =31 */
#define NV_USTRTCH_POINT12D4_Y_INT_LOW_FIELD               0x00000014 /* =20 */
#define NV_USTRTCH_POINT12D4_Y_MSK                         0xFFFF0000 /* 31:16 */ 
#define NV_USTRTCH_POINT12D4_Y_RMSK                        0x0000FFFF /* 31:16 */ 
#define NV_USTRTCH_POINT12D4_Y_WORD                        0
#define NV_USTRTCH_POINT12D4_Y_HIGH_FIELD                  0x0000001F /* =31 */
#define NV_USTRTCH_POINT12D4_Y_LOW_FIELD                   0x00000010 /* =16 */
#define NV_USTRTCH_POINT12D4_MSK                           0xFFFFFFFF 
#define NV_USTRTCH_COLOR_VALUE_MSK                         0xFFFFFFFF /* 31:0 */ 
#define NV_USTRTCH_COLOR_VALUE_RMSK                        0xFFFFFFFF /* 31:0 */ 
#define NV_USTRTCH_COLOR_VALUE_WORD                        0
#define NV_USTRTCH_COLOR_VALUE_HIGH_FIELD                  0x0000001F /* =31 */
#define NV_USTRTCH_COLOR_VALUE_LOW_FIELD                   0x00000000 /* =0 */
#define NV_USTRTCH_COLOR_MSK                               0xFFFFFFFF 
#define NV_066_HIGH_FIELD                                  0x00671FFF /* =6758399 */
#define NV_066_LOW_FIELD                                   0x00670000 /* =6750208 */
#define NV_066_NV5_STRETCHED_IMAGE_FROM_CPU_ADJ            0x00670000
#define NV_066_NV5_STRETCHED_IMAGE_FROM_CPU_HANDLE_MSK     0xFFFFFFFF /* 31:0 */ 
#define NV_066_NV5_STRETCHED_IMAGE_FROM_CPU_HANDLE_RMSK    0xFFFFFFFF /* 31:0 */ 
#define NV_066_NV5_STRETCHED_IMAGE_FROM_CPU_HANDLE_WORD    0
#define NV_066_NV5_STRETCHED_IMAGE_FROM_CPU_HANDLE_HIGH_FIELD 0x0000001F /* =31 */
#define NV_066_NV5_STRETCHED_IMAGE_FROM_CPU_HANDLE_LOW_FIELD 0x00000000 /* =0 */
#define NV_066_NV5_STRETCHED_IMAGE_FROM_CPU_MSK            0xFFFFFFFF 
#define NV_066_NOP_PARAMETER_MSK                           0xFFFFFFFF /* 31:0 */ 
#define NV_066_NOP_PARAMETER_RMSK                          0xFFFFFFFF /* 31:0 */ 
#define NV_066_NOP_PARAMETER_WORD                          0
#define NV_066_NOP_PARAMETER_HIGH_FIELD                    0x0000001F /* =31 */
#define NV_066_NOP_PARAMETER_LOW_FIELD                     0x00000000 /* =0 */
#define NV_066_NOP_MSK                                     0xFFFFFFFF 
#define NV_066_NOTIFY_STYLE_MSK                            0xFFFFFFFF /* 31:0 */ 
#define NV_066_NOTIFY_STYLE_RMSK                           0xFFFFFFFF /* 31:0 */ 
#define NV_066_NOTIFY_STYLE_WORD                           0
#define NV_066_NOTIFY_STYLE_HIGH_FIELD                     0x0000001F /* =31 */
#define NV_066_NOTIFY_STYLE_LOW_FIELD                      0x00000000 /* =0 */
#define NV_066_NOTIFY_STYLE_WRITE_ONLY_ADJ                 0x00000000
#define NV_066_NOTIFY_STYLE_WRITE_THEN_AWAKEN_ADJ          0x00000001
#define NV_066_NOTIFY_MSK                                  0xFFFFFFFF 
#define NV_066_SET_NOTIFY_PARAMETER_MSK                    0xFFFFFFFF /* 31:0 */ 
#define NV_066_SET_NOTIFY_PARAMETER_RMSK                   0xFFFFFFFF /* 31:0 */ 
#define NV_066_SET_NOTIFY_PARAMETER_WORD                   0
#define NV_066_SET_NOTIFY_PARAMETER_HIGH_FIELD             0x0000001F /* =31 */
#define NV_066_SET_NOTIFY_PARAMETER_LOW_FIELD              0x00000000 /* =0 */
#define NV_066_SET_NOTIFY_PARAMETER_WRITE_ADJ              0x00000000
#define NV_066_SET_NOTIFY_MSK                              0xFFFFFFFF 
#define NV_066_SET_CONTEXT_DMA_NOTIFY_PARAMETER_MSK        0xFFFFFFFF /* 31:0 */ 
#define NV_066_SET_CONTEXT_DMA_NOTIFY_PARAMETER_RMSK       0xFFFFFFFF /* 31:0 */ 
#define NV_066_SET_CONTEXT_DMA_NOTIFY_PARAMETER_WORD       0
#define NV_066_SET_CONTEXT_DMA_NOTIFY_PARAMETER_HIGH_FIELD 0x0000001F /* =31 */
#define NV_066_SET_CONTEXT_DMA_NOTIFY_PARAMETER_LOW_FIELD  0x00000000 /* =0 */
#define NV_066_SET_CONTEXT_DMA_NOTIFY_MSK                  0xFFFFFFFF 
#define NV_066_SET_CONTEXT_COLOR_KEY_PARAMETER_MSK         0xFFFFFFFF /* 31:0 */ 
#define NV_066_SET_CONTEXT_COLOR_KEY_PARAMETER_RMSK        0xFFFFFFFF /* 31:0 */ 
#define NV_066_SET_CONTEXT_COLOR_KEY_PARAMETER_WORD        0
#define NV_066_SET_CONTEXT_COLOR_KEY_PARAMETER_HIGH_FIELD  0x0000001F /* =31 */
#define NV_066_SET_CONTEXT_COLOR_KEY_PARAMETER_LOW_FIELD   0x00000000 /* =0 */
#define NV_066_SET_CONTEXT_COLOR_KEY_MSK                   0xFFFFFFFF 
#define NV_066_SET_CONTEXT_PATTERN_PARAMETER_MSK           0xFFFFFFFF /* 31:0 */ 
#define NV_066_SET_CONTEXT_PATTERN_PARAMETER_RMSK          0xFFFFFFFF /* 31:0 */ 
#define NV_066_SET_CONTEXT_PATTERN_PARAMETER_WORD          0
#define NV_066_SET_CONTEXT_PATTERN_PARAMETER_HIGH_FIELD    0x0000001F /* =31 */
#define NV_066_SET_CONTEXT_PATTERN_PARAMETER_LOW_FIELD     0x00000000 /* =0 */
#define NV_066_SET_CONTEXT_PATTERN_MSK                     0xFFFFFFFF 
#define NV_066_SET_CONTEXT_ROP_PARAMETER_MSK               0xFFFFFFFF /* 31:0 */ 
#define NV_066_SET_CONTEXT_ROP_PARAMETER_RMSK              0xFFFFFFFF /* 31:0 */ 
#define NV_066_SET_CONTEXT_ROP_PARAMETER_WORD              0
#define NV_066_SET_CONTEXT_ROP_PARAMETER_HIGH_FIELD        0x0000001F /* =31 */
#define NV_066_SET_CONTEXT_ROP_PARAMETER_LOW_FIELD         0x00000000 /* =0 */
#define NV_066_SET_CONTEXT_ROP_MSK                         0xFFFFFFFF 
#define NV_066_SET_CONTEXT_BETA1_PARAMETER_MSK             0xFFFFFFFF /* 31:0 */ 
#define NV_066_SET_CONTEXT_BETA1_PARAMETER_RMSK            0xFFFFFFFF /* 31:0 */ 
#define NV_066_SET_CONTEXT_BETA1_PARAMETER_WORD            0
#define NV_066_SET_CONTEXT_BETA1_PARAMETER_HIGH_FIELD      0x0000001F /* =31 */
#define NV_066_SET_CONTEXT_BETA1_PARAMETER_LOW_FIELD       0x00000000 /* =0 */
#define NV_066_SET_CONTEXT_BETA1_MSK                       0xFFFFFFFF 
#define NV_066_SET_CONTEXT_BETA4_PARAMETER_MSK             0xFFFFFFFF /* 31:0 */ 
#define NV_066_SET_CONTEXT_BETA4_PARAMETER_RMSK            0xFFFFFFFF /* 31:0 */ 
#define NV_066_SET_CONTEXT_BETA4_PARAMETER_WORD            0
#define NV_066_SET_CONTEXT_BETA4_PARAMETER_HIGH_FIELD      0x0000001F /* =31 */
#define NV_066_SET_CONTEXT_BETA4_PARAMETER_LOW_FIELD       0x00000000 /* =0 */
#define NV_066_SET_CONTEXT_BETA4_MSK                       0xFFFFFFFF 
#define NV_066_SET_CONTEXT_SURFACE_PARAMETER_MSK           0xFFFFFFFF /* 31:0 */ 
#define NV_066_SET_CONTEXT_SURFACE_PARAMETER_RMSK          0xFFFFFFFF /* 31:0 */ 
#define NV_066_SET_CONTEXT_SURFACE_PARAMETER_WORD          0
#define NV_066_SET_CONTEXT_SURFACE_PARAMETER_HIGH_FIELD    0x0000001F /* =31 */
#define NV_066_SET_CONTEXT_SURFACE_PARAMETER_LOW_FIELD     0x00000000 /* =0 */
#define NV_066_SET_CONTEXT_SURFACE_MSK                     0xFFFFFFFF 
#define NV_066_SET_COLOR_CONVERSION_TYPE_MSK               0xFFFFFFFF /* 31:0 */ 
#define NV_066_SET_COLOR_CONVERSION_TYPE_RMSK              0xFFFFFFFF /* 31:0 */ 
#define NV_066_SET_COLOR_CONVERSION_TYPE_WORD              0
#define NV_066_SET_COLOR_CONVERSION_TYPE_HIGH_FIELD        0x0000001F /* =31 */
#define NV_066_SET_COLOR_CONVERSION_TYPE_LOW_FIELD         0x00000000 /* =0 */
#define NV_066_SET_COLOR_CONVERSION_TYPE_DITHER_ADJ        0x00000000
#define NV_066_SET_COLOR_CONVERSION_TYPE_TRUNCATE_ADJ      0x00000001
#define NV_066_SET_COLOR_CONVERSION_TYPE_SUBTR_TRUNCATE_ADJ 0x00000002
#define NV_066_SET_COLOR_CONVERSION_MSK                    0xFFFFFFFF 
#define NV_066_SET_OPERATION_MODE_MSK                      0xFFFFFFFF /* 31:0 */ 
#define NV_066_SET_OPERATION_MODE_RMSK                     0xFFFFFFFF /* 31:0 */ 
#define NV_066_SET_OPERATION_MODE_WORD                     0
#define NV_066_SET_OPERATION_MODE_HIGH_FIELD               0x0000001F /* =31 */
#define NV_066_SET_OPERATION_MODE_LOW_FIELD                0x00000000 /* =0 */
#define NV_066_SET_OPERATION_MODE_SRCCOPY_AND_ADJ          0x00000000
#define NV_066_SET_OPERATION_MODE_ROP_AND_ADJ              0x00000001
#define NV_066_SET_OPERATION_MODE_BLEND_AND_ADJ            0x00000002
#define NV_066_SET_OPERATION_MODE_SRCCOPY_ADJ              0x00000003
#define NV_066_SET_OPERATION_MODE_SRCCOPY_PREMULT_ADJ      0x00000004
#define NV_066_SET_OPERATION_MODE_BLEND_PREMULT_ADJ        0x00000005
#define NV_066_SET_OPERATION_MSK                           0xFFFFFFFF 
#define NV_066_SET_COLOR_FORMAT_LE_MSK                     0xFFFFFFFF /* 31:0 */ 
#define NV_066_SET_COLOR_FORMAT_LE_RMSK                    0xFFFFFFFF /* 31:0 */ 
#define NV_066_SET_COLOR_FORMAT_LE_WORD                    0
#define NV_066_SET_COLOR_FORMAT_LE_HIGH_FIELD              0x0000001F /* =31 */
#define NV_066_SET_COLOR_FORMAT_LE_LOW_FIELD               0x00000000 /* =0 */
#define NV_066_SET_COLOR_FORMAT_LE_R5G6B5_ADJ              0x00000001
#define NV_066_SET_COLOR_FORMAT_LE_A1R5G5B5_ADJ            0x00000002
#define NV_066_SET_COLOR_FORMAT_LE_X1R5G5B5_ADJ            0x00000003
#define NV_066_SET_COLOR_FORMAT_LE_A8R8G8B8_ADJ            0x00000004
#define NV_066_SET_COLOR_FORMAT_LE_X8R8G8B8_ADJ            0x00000005
#define NV_066_SET_COLOR_FORMAT_MSK                        0xFFFFFFFF 
#define NV_066_SIZE_IN_WIDTH_MSK                           0x0000FFFF /* 15:0 */ 
#define NV_066_SIZE_IN_WIDTH_RMSK                          0x0000FFFF /* 15:0 */ 
#define NV_066_SIZE_IN_WIDTH_WORD                          0
#define NV_066_SIZE_IN_WIDTH_HIGH_FIELD                    0x0000000F /* =15 */
#define NV_066_SIZE_IN_WIDTH_LOW_FIELD                     0x00000000 /* =0 */
#define NV_066_SIZE_IN_HEIGHT_MSK                          0xFFFF0000 /* 31:16 */ 
#define NV_066_SIZE_IN_HEIGHT_RMSK                         0x0000FFFF /* 31:16 */ 
#define NV_066_SIZE_IN_HEIGHT_WORD                         0
#define NV_066_SIZE_IN_HEIGHT_HIGH_FIELD                   0x0000001F /* =31 */
#define NV_066_SIZE_IN_HEIGHT_LOW_FIELD                    0x00000010 /* =16 */
#define NV_066_SIZE_IN_MSK                                 0xFFFFFFFF 
#define NV_066_DELTA_DX_DU_R_FRACTION_MSK                  0x000FFFFF /* 19:0 */ 
#define NV_066_DELTA_DX_DU_R_FRACTION_RMSK                 0x000FFFFF /* 19:0 */ 
#define NV_066_DELTA_DX_DU_R_FRACTION_WORD                 0
#define NV_066_DELTA_DX_DU_R_FRACTION_HIGH_FIELD           0x00000013 /* =19 */
#define NV_066_DELTA_DX_DU_R_FRACTION_LOW_FIELD            0x00000000 /* =0 */
#define NV_066_DELTA_DX_DU_R_INT_MSK                       0xFFF00000 /* 31:20 */ 
#define NV_066_DELTA_DX_DU_R_INT_RMSK                      0x00000FFF /* 31:20 */ 
#define NV_066_DELTA_DX_DU_R_INT_WORD                      0
#define NV_066_DELTA_DX_DU_R_INT_HIGH_FIELD                0x0000001F /* =31 */
#define NV_066_DELTA_DX_DU_R_INT_LOW_FIELD                 0x00000014 /* =20 */
#define NV_066_DELTA_DX_DU_R_MSK                           0xFFFFFFFF /* 31:0 */ 
#define NV_066_DELTA_DX_DU_R_RMSK                          0xFFFFFFFF /* 31:0 */ 
#define NV_066_DELTA_DX_DU_R_WORD                          0
#define NV_066_DELTA_DX_DU_R_HIGH_FIELD                    0x0000001F /* =31 */
#define NV_066_DELTA_DX_DU_R_LOW_FIELD                     0x00000000 /* =0 */
#define NV_066_DELTA_DX_DU_MSK                             0xFFFFFFFF 
#define NV_066_DELTA_DY_DV_R_FRACTION_MSK                  0x000FFFFF /* 19:0 */ 
#define NV_066_DELTA_DY_DV_R_FRACTION_RMSK                 0x000FFFFF /* 19:0 */ 
#define NV_066_DELTA_DY_DV_R_FRACTION_WORD                 0
#define NV_066_DELTA_DY_DV_R_FRACTION_HIGH_FIELD           0x00000013 /* =19 */
#define NV_066_DELTA_DY_DV_R_FRACTION_LOW_FIELD            0x00000000 /* =0 */
#define NV_066_DELTA_DY_DV_R_INT_MSK                       0xFFF00000 /* 31:20 */ 
#define NV_066_DELTA_DY_DV_R_INT_RMSK                      0x00000FFF /* 31:20 */ 
#define NV_066_DELTA_DY_DV_R_INT_WORD                      0
#define NV_066_DELTA_DY_DV_R_INT_HIGH_FIELD                0x0000001F /* =31 */
#define NV_066_DELTA_DY_DV_R_INT_LOW_FIELD                 0x00000014 /* =20 */
#define NV_066_DELTA_DY_DV_R_MSK                           0xFFFFFFFF /* 31:0 */ 
#define NV_066_DELTA_DY_DV_R_RMSK                          0xFFFFFFFF /* 31:0 */ 
#define NV_066_DELTA_DY_DV_R_WORD                          0
#define NV_066_DELTA_DY_DV_R_HIGH_FIELD                    0x0000001F /* =31 */
#define NV_066_DELTA_DY_DV_R_LOW_FIELD                     0x00000000 /* =0 */
#define NV_066_DELTA_DY_DV_MSK                             0xFFFFFFFF 
#define NV_066_CLIP_0_X_MSK                                0x0000FFFF /* 15:0 */ 
#define NV_066_CLIP_0_X_RMSK                               0x0000FFFF /* 15:0 */ 
#define NV_066_CLIP_0_X_WORD                               0
#define NV_066_CLIP_0_X_HIGH_FIELD                         0x0000000F /* =15 */
#define NV_066_CLIP_0_X_LOW_FIELD                          0x00000000 /* =0 */
#define NV_066_CLIP_0_Y_MSK                                0xFFFF0000 /* 31:16 */ 
#define NV_066_CLIP_0_Y_RMSK                               0x0000FFFF /* 31:16 */ 
#define NV_066_CLIP_0_Y_WORD                               0
#define NV_066_CLIP_0_Y_HIGH_FIELD                         0x0000001F /* =31 */
#define NV_066_CLIP_0_Y_LOW_FIELD                          0x00000010 /* =16 */
#define NV_066_CLIP_0_MSK                                  0xFFFFFFFF 
#define NV_066_CLIP_1_WIDTH_MSK                            0x0000FFFF /* 15:0 */ 
#define NV_066_CLIP_1_WIDTH_RMSK                           0x0000FFFF /* 15:0 */ 
#define NV_066_CLIP_1_WIDTH_WORD                           0
#define NV_066_CLIP_1_WIDTH_HIGH_FIELD                     0x0000000F /* =15 */
#define NV_066_CLIP_1_WIDTH_LOW_FIELD                      0x00000000 /* =0 */
#define NV_066_CLIP_1_HEIGHT_MSK                           0xFFFF0000 /* 31:16 */ 
#define NV_066_CLIP_1_HEIGHT_RMSK                          0x0000FFFF /* 31:16 */ 
#define NV_066_CLIP_1_HEIGHT_WORD                          0
#define NV_066_CLIP_1_HEIGHT_HIGH_FIELD                    0x0000001F /* =31 */
#define NV_066_CLIP_1_HEIGHT_LOW_FIELD                     0x00000010 /* =16 */
#define NV_066_CLIP_1_MSK                                  0xFFFFFFFF 
#define NV_066_POINT12D4_X_FRACTION_MSK                    0x0000000F /* 3:0 */ 
#define NV_066_POINT12D4_X_FRACTION_RMSK                   0x0000000F /* 3:0 */ 
#define NV_066_POINT12D4_X_FRACTION_WORD                   0
#define NV_066_POINT12D4_X_FRACTION_HIGH_FIELD             0x00000003 /* =3 */
#define NV_066_POINT12D4_X_FRACTION_LOW_FIELD              0x00000000 /* =0 */
#define NV_066_POINT12D4_X_INT_MSK                         0x0000FFF0 /* 15:4 */ 
#define NV_066_POINT12D4_X_INT_RMSK                        0x00000FFF /* 15:4 */ 
#define NV_066_POINT12D4_X_INT_WORD                        0
#define NV_066_POINT12D4_X_INT_HIGH_FIELD                  0x0000000F /* =15 */
#define NV_066_POINT12D4_X_INT_LOW_FIELD                   0x00000004 /* =4 */
#define NV_066_POINT12D4_X_MSK                             0x0000FFFF /* 15:0 */ 
#define NV_066_POINT12D4_X_RMSK                            0x0000FFFF /* 15:0 */ 
#define NV_066_POINT12D4_X_WORD                            0
#define NV_066_POINT12D4_X_HIGH_FIELD                      0x0000000F /* =15 */
#define NV_066_POINT12D4_X_LOW_FIELD                       0x00000000 /* =0 */
#define NV_066_POINT12D4_Y_FRACTION_MSK                    0x000F0000 /* 19:16 */ 
#define NV_066_POINT12D4_Y_FRACTION_RMSK                   0x0000000F /* 19:16 */ 
#define NV_066_POINT12D4_Y_FRACTION_WORD                   0
#define NV_066_POINT12D4_Y_FRACTION_HIGH_FIELD             0x00000013 /* =19 */
#define NV_066_POINT12D4_Y_FRACTION_LOW_FIELD              0x00000010 /* =16 */
#define NV_066_POINT12D4_Y_INT_MSK                         0xFFF00000 /* 31:20 */ 
#define NV_066_POINT12D4_Y_INT_RMSK                        0x00000FFF /* 31:20 */ 
#define NV_066_POINT12D4_Y_INT_WORD                        0
#define NV_066_POINT12D4_Y_INT_HIGH_FIELD                  0x0000001F /* =31 */
#define NV_066_POINT12D4_Y_INT_LOW_FIELD                   0x00000014 /* =20 */
#define NV_066_POINT12D4_Y_MSK                             0xFFFF0000 /* 31:16 */ 
#define NV_066_POINT12D4_Y_RMSK                            0x0000FFFF /* 31:16 */ 
#define NV_066_POINT12D4_Y_WORD                            0
#define NV_066_POINT12D4_Y_HIGH_FIELD                      0x0000001F /* =31 */
#define NV_066_POINT12D4_Y_LOW_FIELD                       0x00000010 /* =16 */
#define NV_066_POINT12D4_MSK                               0xFFFFFFFF 
#define NV_066_COLOR_VALUE_MSK                             0xFFFFFFFF /* 31:0 */ 
#define NV_066_COLOR_VALUE_RMSK                            0xFFFFFFFF /* 31:0 */ 
#define NV_066_COLOR_VALUE_WORD                            0
#define NV_066_COLOR_VALUE_HIGH_FIELD                      0x0000001F /* =31 */
#define NV_066_COLOR_VALUE_LOW_FIELD                       0x00000000 /* =0 */
#define NV_066_COLOR_MSK                                   0xFFFFFFFF 
#define NV_04B_HIGH_FIELD                                  0x006B1FFF /* =7020543 */
#define NV_04B_LOW_FIELD                                   0x006B0000 /* =7012352 */
#define NV_04B_NV3_GDI_RECTANGLE_TEXT_ADJ                  0x006B0000
#define NV_04B_NV3_GDI_RECTANGLE_TEXT_MSK                  0x00000000 
#define NV_04B_NOP_ADJ                                     0x006B0100
#define NV_04B_NOP_PARAMETER_MSK                           0xFFFFFFFF /* 31:0 */ 
#define NV_04B_NOP_PARAMETER_RMSK                          0xFFFFFFFF /* 31:0 */ 
#define NV_04B_NOP_PARAMETER_WORD                          0
#define NV_04B_NOP_PARAMETER_HIGH_FIELD                    0x0000001F /* =31 */
#define NV_04B_NOP_PARAMETER_LOW_FIELD                     0x00000000 /* =0 */
#define NV_04B_NOP_MSK                                     0xFFFFFFFF 
#define NV_04B_NOTIFY_STYLE_MSK                            0xFFFFFFFF /* 31:0 */ 
#define NV_04B_NOTIFY_STYLE_RMSK                           0xFFFFFFFF /* 31:0 */ 
#define NV_04B_NOTIFY_STYLE_WORD                           0
#define NV_04B_NOTIFY_STYLE_HIGH_FIELD                     0x0000001F /* =31 */
#define NV_04B_NOTIFY_STYLE_LOW_FIELD                      0x00000000 /* =0 */
#define NV_04B_NOTIFY_STYLE_WRITE_ONLY_ADJ                 0x00000000
#define NV_04B_NOTIFY_STYLE_WRITE_THEN_AWAKEN_ADJ          0x00000001
#define NV_04B_NOTIFY_MSK                                  0xFFFFFFFF 
#define NV_04B_SET_PATCH_PARAMETER_MSK                     0xFFFFFFFF /* 31:0 */ 
#define NV_04B_SET_PATCH_PARAMETER_RMSK                    0xFFFFFFFF /* 31:0 */ 
#define NV_04B_SET_PATCH_PARAMETER_WORD                    0
#define NV_04B_SET_PATCH_PARAMETER_HIGH_FIELD              0x0000001F /* =31 */
#define NV_04B_SET_PATCH_PARAMETER_LOW_FIELD               0x00000000 /* =0 */
#define NV_04B_SET_PATCH_PARAMETER_INVALIDATE_ADJ          0x00000000
#define NV_04B_SET_PATCH_PARAMETER_VALIDATE_ADJ            0x00000001
#define NV_04B_SET_PATCH_MSK                               0xFFFFFFFF 
#define NV_04B_SET_CONTEXT_DMA_NOTIFY_PARAMETER_MSK        0xFFFFFFFF /* 31:0 */ 
#define NV_04B_SET_CONTEXT_DMA_NOTIFY_PARAMETER_RMSK       0xFFFFFFFF /* 31:0 */ 
#define NV_04B_SET_CONTEXT_DMA_NOTIFY_PARAMETER_WORD       0
#define NV_04B_SET_CONTEXT_DMA_NOTIFY_PARAMETER_HIGH_FIELD 0x0000001F /* =31 */
#define NV_04B_SET_CONTEXT_DMA_NOTIFY_PARAMETER_LOW_FIELD  0x00000000 /* =0 */
#define NV_04B_SET_CONTEXT_DMA_NOTIFY_MSK                  0xFFFFFFFF 
#define NV_04B_SET_IMAGE_OUTPUT_PARAMETER_MSK              0xFFFFFFFF /* 31:0 */ 
#define NV_04B_SET_IMAGE_OUTPUT_PARAMETER_RMSK             0xFFFFFFFF /* 31:0 */ 
#define NV_04B_SET_IMAGE_OUTPUT_PARAMETER_WORD             0
#define NV_04B_SET_IMAGE_OUTPUT_PARAMETER_HIGH_FIELD       0x0000001F /* =31 */
#define NV_04B_SET_IMAGE_OUTPUT_PARAMETER_LOW_FIELD        0x00000000 /* =0 */
#define NV_04B_SET_IMAGE_OUTPUT_MSK                        0xFFFFFFFF 
#define NV_04B_SET_COLOR_FORMAT_LE_MSK                     0xFFFFFFFF /* 31:0 */ 
#define NV_04B_SET_COLOR_FORMAT_LE_RMSK                    0xFFFFFFFF /* 31:0 */ 
#define NV_04B_SET_COLOR_FORMAT_LE_WORD                    0
#define NV_04B_SET_COLOR_FORMAT_LE_HIGH_FIELD              0x0000001F /* =31 */
#define NV_04B_SET_COLOR_FORMAT_LE_LOW_FIELD               0x00000000 /* =0 */
#define NV_04B_SET_COLOR_FORMAT_LE_X24Y8_ADJ               0x00000001
#define NV_04B_SET_COLOR_FORMAT_LE_X17R5G5B5_ADJ           0x00000002
#define NV_04B_SET_COLOR_FORMAT_LE_X8R8G8B8_ADJ            0x00000003
#define NV_04B_SET_COLOR_FORMAT_MSK                        0xFFFFFFFF 
#define NV_04B_SET_MONOCHROME_FORMAT_VALUE_MSK             0xFFFFFFFF /* 31:0 */ 
#define NV_04B_SET_MONOCHROME_FORMAT_VALUE_RMSK            0xFFFFFFFF /* 31:0 */ 
#define NV_04B_SET_MONOCHROME_FORMAT_VALUE_WORD            0
#define NV_04B_SET_MONOCHROME_FORMAT_VALUE_HIGH_FIELD      0x0000001F /* =31 */
#define NV_04B_SET_MONOCHROME_FORMAT_VALUE_LOW_FIELD       0x00000000 /* =0 */
#define NV_04B_SET_MONOCHROME_FORMAT_VALUE_CGA6_M1_ADJ     0x00000001
#define NV_04B_SET_MONOCHROME_FORMAT_VALUE_LE_M1_ADJ       0x00000002
#define NV_04B_SET_MONOCHROME_FORMAT_MSK                   0xFFFFFFFF 
#define NV_04B_COLOR1_A_VALUE_MSK                          0xFFFFFFFF /* 31:0 */ 
#define NV_04B_COLOR1_A_VALUE_RMSK                         0xFFFFFFFF /* 31:0 */ 
#define NV_04B_COLOR1_A_VALUE_WORD                         0
#define NV_04B_COLOR1_A_VALUE_HIGH_FIELD                   0x0000001F /* =31 */
#define NV_04B_COLOR1_A_VALUE_LOW_FIELD                    0x00000000 /* =0 */
#define NV_04B_COLOR1_A_MSK                                0xFFFFFFFF 
#define NV_04B_UNCLIPPED_RECTANGLE_POINT_Y_MSK             0x0000FFFF /* 15:0 */ 
#define NV_04B_UNCLIPPED_RECTANGLE_POINT_Y_RMSK            0x0000FFFF /* 15:0 */ 
#define NV_04B_UNCLIPPED_RECTANGLE_POINT_Y_WORD            0
#define NV_04B_UNCLIPPED_RECTANGLE_POINT_Y_HIGH_FIELD      0x0000000F /* =15 */
#define NV_04B_UNCLIPPED_RECTANGLE_POINT_Y_LOW_FIELD       0x00000000 /* =0 */
#define NV_04B_UNCLIPPED_RECTANGLE_POINT_X_MSK             0xFFFF0000 /* 31:16 */ 
#define NV_04B_UNCLIPPED_RECTANGLE_POINT_X_RMSK            0x0000FFFF /* 31:16 */ 
#define NV_04B_UNCLIPPED_RECTANGLE_POINT_X_WORD            0
#define NV_04B_UNCLIPPED_RECTANGLE_POINT_X_HIGH_FIELD      0x0000001F /* =31 */
#define NV_04B_UNCLIPPED_RECTANGLE_POINT_X_LOW_FIELD       0x00000010 /* =16 */
#define NV_04B_UNCLIPPED_RECTANGLE_POINT_MSK               0xFFFFFFFF 
#define NV_04B_UNCLIPPED_RECTANGLE_SIZE_HEIGHT_MSK         0x0000FFFF /* 15:0 */ 
#define NV_04B_UNCLIPPED_RECTANGLE_SIZE_HEIGHT_RMSK        0x0000FFFF /* 15:0 */ 
#define NV_04B_UNCLIPPED_RECTANGLE_SIZE_HEIGHT_WORD        0
#define NV_04B_UNCLIPPED_RECTANGLE_SIZE_HEIGHT_HIGH_FIELD  0x0000000F /* =15 */
#define NV_04B_UNCLIPPED_RECTANGLE_SIZE_HEIGHT_LOW_FIELD   0x00000000 /* =0 */
#define NV_04B_UNCLIPPED_RECTANGLE_SIZE_WIDTH_MSK          0xFFFF0000 /* 31:16 */ 
#define NV_04B_UNCLIPPED_RECTANGLE_SIZE_WIDTH_RMSK         0x0000FFFF /* 31:16 */ 
#define NV_04B_UNCLIPPED_RECTANGLE_SIZE_WIDTH_WORD         0
#define NV_04B_UNCLIPPED_RECTANGLE_SIZE_WIDTH_HIGH_FIELD   0x0000001F /* =31 */
#define NV_04B_UNCLIPPED_RECTANGLE_SIZE_WIDTH_LOW_FIELD    0x00000010 /* =16 */
#define NV_04B_UNCLIPPED_RECTANGLE_SIZE_MSK                0xFFFFFFFF 
#define NV_04B_CLIP_B_POINT0_LEFT_MSK                      0x0000FFFF /* 15:0 */ 
#define NV_04B_CLIP_B_POINT0_LEFT_RMSK                     0x0000FFFF /* 15:0 */ 
#define NV_04B_CLIP_B_POINT0_LEFT_WORD                     0
#define NV_04B_CLIP_B_POINT0_LEFT_HIGH_FIELD               0x0000000F /* =15 */
#define NV_04B_CLIP_B_POINT0_LEFT_LOW_FIELD                0x00000000 /* =0 */
#define NV_04B_CLIP_B_POINT0_TOP_MSK                       0xFFFF0000 /* 31:16 */ 
#define NV_04B_CLIP_B_POINT0_TOP_RMSK                      0x0000FFFF /* 31:16 */ 
#define NV_04B_CLIP_B_POINT0_TOP_WORD                      0
#define NV_04B_CLIP_B_POINT0_TOP_HIGH_FIELD                0x0000001F /* =31 */
#define NV_04B_CLIP_B_POINT0_TOP_LOW_FIELD                 0x00000010 /* =16 */
#define NV_04B_CLIP_B_POINT0_MSK                           0xFFFFFFFF 
#define NV_04B_CLIP_B_POINT1_RIGHT_MSK                     0x0000FFFF /* 15:0 */ 
#define NV_04B_CLIP_B_POINT1_RIGHT_RMSK                    0x0000FFFF /* 15:0 */ 
#define NV_04B_CLIP_B_POINT1_RIGHT_WORD                    0
#define NV_04B_CLIP_B_POINT1_RIGHT_HIGH_FIELD              0x0000000F /* =15 */
#define NV_04B_CLIP_B_POINT1_RIGHT_LOW_FIELD               0x00000000 /* =0 */
#define NV_04B_CLIP_B_POINT1_BOTTOM_MSK                    0xFFFF0000 /* 31:16 */ 
#define NV_04B_CLIP_B_POINT1_BOTTOM_RMSK                   0x0000FFFF /* 31:16 */ 
#define NV_04B_CLIP_B_POINT1_BOTTOM_WORD                   0
#define NV_04B_CLIP_B_POINT1_BOTTOM_HIGH_FIELD             0x0000001F /* =31 */
#define NV_04B_CLIP_B_POINT1_BOTTOM_LOW_FIELD              0x00000010 /* =16 */
#define NV_04B_CLIP_B_POINT1_MSK                           0xFFFFFFFF 
#define NV_04B_COLOR1_B_VALUE_MSK                          0xFFFFFFFF /* 31:0 */ 
#define NV_04B_COLOR1_B_VALUE_RMSK                         0xFFFFFFFF /* 31:0 */ 
#define NV_04B_COLOR1_B_VALUE_WORD                         0
#define NV_04B_COLOR1_B_VALUE_HIGH_FIELD                   0x0000001F /* =31 */
#define NV_04B_COLOR1_B_VALUE_LOW_FIELD                    0x00000000 /* =0 */
#define NV_04B_COLOR1_B_MSK                                0xFFFFFFFF 
#define NV_04B_CLIPPED_RECTANGLE_POINT_0_LEFT_MSK          0x0000FFFF /* 15:0 */ 
#define NV_04B_CLIPPED_RECTANGLE_POINT_0_LEFT_RMSK         0x0000FFFF /* 15:0 */ 
#define NV_04B_CLIPPED_RECTANGLE_POINT_0_LEFT_WORD         0
#define NV_04B_CLIPPED_RECTANGLE_POINT_0_LEFT_HIGH_FIELD   0x0000000F /* =15 */
#define NV_04B_CLIPPED_RECTANGLE_POINT_0_LEFT_LOW_FIELD    0x00000000 /* =0 */
#define NV_04B_CLIPPED_RECTANGLE_POINT_0_TOP_MSK           0xFFFF0000 /* 31:16 */ 
#define NV_04B_CLIPPED_RECTANGLE_POINT_0_TOP_RMSK          0x0000FFFF /* 31:16 */ 
#define NV_04B_CLIPPED_RECTANGLE_POINT_0_TOP_WORD          0
#define NV_04B_CLIPPED_RECTANGLE_POINT_0_TOP_HIGH_FIELD    0x0000001F /* =31 */
#define NV_04B_CLIPPED_RECTANGLE_POINT_0_TOP_LOW_FIELD     0x00000010 /* =16 */
#define NV_04B_CLIPPED_RECTANGLE_POINT_0_MSK               0xFFFFFFFF 
#define NV_04B_CLIPPED_RECTANGLE_POINT_1_RIGHT_MSK         0x0000FFFF /* 15:0 */ 
#define NV_04B_CLIPPED_RECTANGLE_POINT_1_RIGHT_RMSK        0x0000FFFF /* 15:0 */ 
#define NV_04B_CLIPPED_RECTANGLE_POINT_1_RIGHT_WORD        0
#define NV_04B_CLIPPED_RECTANGLE_POINT_1_RIGHT_HIGH_FIELD  0x0000000F /* =15 */
#define NV_04B_CLIPPED_RECTANGLE_POINT_1_RIGHT_LOW_FIELD   0x00000000 /* =0 */
#define NV_04B_CLIPPED_RECTANGLE_POINT_1_BOTTOM_MSK        0xFFFF0000 /* 31:16 */ 
#define NV_04B_CLIPPED_RECTANGLE_POINT_1_BOTTOM_RMSK       0x0000FFFF /* 31:16 */ 
#define NV_04B_CLIPPED_RECTANGLE_POINT_1_BOTTOM_WORD       0
#define NV_04B_CLIPPED_RECTANGLE_POINT_1_BOTTOM_HIGH_FIELD 0x0000001F /* =31 */
#define NV_04B_CLIPPED_RECTANGLE_POINT_1_BOTTOM_LOW_FIELD  0x00000010 /* =16 */
#define NV_04B_CLIPPED_RECTANGLE_POINT_1_MSK               0xFFFFFFFF 
#define NV_04B_CLIP_C_POINT0_LEFT_MSK                      0x0000FFFF /* 15:0 */ 
#define NV_04B_CLIP_C_POINT0_LEFT_RMSK                     0x0000FFFF /* 15:0 */ 
#define NV_04B_CLIP_C_POINT0_LEFT_WORD                     0
#define NV_04B_CLIP_C_POINT0_LEFT_HIGH_FIELD               0x0000000F /* =15 */
#define NV_04B_CLIP_C_POINT0_LEFT_LOW_FIELD                0x00000000 /* =0 */
#define NV_04B_CLIP_C_POINT0_TOP_MSK                       0xFFFF0000 /* 31:16 */ 
#define NV_04B_CLIP_C_POINT0_TOP_RMSK                      0x0000FFFF /* 31:16 */ 
#define NV_04B_CLIP_C_POINT0_TOP_WORD                      0
#define NV_04B_CLIP_C_POINT0_TOP_HIGH_FIELD                0x0000001F /* =31 */
#define NV_04B_CLIP_C_POINT0_TOP_LOW_FIELD                 0x00000010 /* =16 */
#define NV_04B_CLIP_C_POINT0_MSK                           0xFFFFFFFF 
#define NV_04B_CLIP_C_POINT1_RIGHT_MSK                     0x0000FFFF /* 15:0 */ 
#define NV_04B_CLIP_C_POINT1_RIGHT_RMSK                    0x0000FFFF /* 15:0 */ 
#define NV_04B_CLIP_C_POINT1_RIGHT_WORD                    0
#define NV_04B_CLIP_C_POINT1_RIGHT_HIGH_FIELD              0x0000000F /* =15 */
#define NV_04B_CLIP_C_POINT1_RIGHT_LOW_FIELD               0x00000000 /* =0 */
#define NV_04B_CLIP_C_POINT1_BOTTOM_MSK                    0xFFFF0000 /* 31:16 */ 
#define NV_04B_CLIP_C_POINT1_BOTTOM_RMSK                   0x0000FFFF /* 31:16 */ 
#define NV_04B_CLIP_C_POINT1_BOTTOM_WORD                   0
#define NV_04B_CLIP_C_POINT1_BOTTOM_HIGH_FIELD             0x0000001F /* =31 */
#define NV_04B_CLIP_C_POINT1_BOTTOM_LOW_FIELD              0x00000010 /* =16 */
#define NV_04B_CLIP_C_POINT1_MSK                           0xFFFFFFFF 
#define NV_04B_COLOR1_C_VALUE_MSK                          0xFFFFFFFF /* 31:0 */ 
#define NV_04B_COLOR1_C_VALUE_RMSK                         0xFFFFFFFF /* 31:0 */ 
#define NV_04B_COLOR1_C_VALUE_WORD                         0
#define NV_04B_COLOR1_C_VALUE_HIGH_FIELD                   0x0000001F /* =31 */
#define NV_04B_COLOR1_C_VALUE_LOW_FIELD                    0x00000000 /* =0 */
#define NV_04B_COLOR1_C_MSK                                0xFFFFFFFF 
#define NV_04B_SIZE_C_WIDTH_MSK                            0x0000FFFF /* 15:0 */ 
#define NV_04B_SIZE_C_WIDTH_RMSK                           0x0000FFFF /* 15:0 */ 
#define NV_04B_SIZE_C_WIDTH_WORD                           0
#define NV_04B_SIZE_C_WIDTH_HIGH_FIELD                     0x0000000F /* =15 */
#define NV_04B_SIZE_C_WIDTH_LOW_FIELD                      0x00000000 /* =0 */
#define NV_04B_SIZE_C_HEIGHT_MSK                           0xFFFF0000 /* 31:16 */ 
#define NV_04B_SIZE_C_HEIGHT_RMSK                          0x0000FFFF /* 31:16 */ 
#define NV_04B_SIZE_C_HEIGHT_WORD                          0
#define NV_04B_SIZE_C_HEIGHT_HIGH_FIELD                    0x0000001F /* =31 */
#define NV_04B_SIZE_C_HEIGHT_LOW_FIELD                     0x00000010 /* =16 */
#define NV_04B_SIZE_C_MSK                                  0xFFFFFFFF 
#define NV_04B_POINT_C_X_MSK                               0x0000FFFF /* 15:0 */ 
#define NV_04B_POINT_C_X_RMSK                              0x0000FFFF /* 15:0 */ 
#define NV_04B_POINT_C_X_WORD                              0
#define NV_04B_POINT_C_X_HIGH_FIELD                        0x0000000F /* =15 */
#define NV_04B_POINT_C_X_LOW_FIELD                         0x00000000 /* =0 */
#define NV_04B_POINT_C_Y_MSK                               0xFFFF0000 /* 31:16 */ 
#define NV_04B_POINT_C_Y_RMSK                              0x0000FFFF /* 31:16 */ 
#define NV_04B_POINT_C_Y_WORD                              0
#define NV_04B_POINT_C_Y_HIGH_FIELD                        0x0000001F /* =31 */
#define NV_04B_POINT_C_Y_LOW_FIELD                         0x00000010 /* =16 */
#define NV_04B_POINT_C_MSK                                 0xFFFFFFFF 
#define NV_04B_MONOCHROME_COLOR1_C_BITMAP_MSK              0xFFFFFFFF /* 31:0 */ 
#define NV_04B_MONOCHROME_COLOR1_C_BITMAP_RMSK             0xFFFFFFFF /* 31:0 */ 
#define NV_04B_MONOCHROME_COLOR1_C_BITMAP_WORD             0
#define NV_04B_MONOCHROME_COLOR1_C_BITMAP_HIGH_FIELD       0x0000001F /* =31 */
#define NV_04B_MONOCHROME_COLOR1_C_BITMAP_LOW_FIELD        0x00000000 /* =0 */
#define NV_04B_MONOCHROME_COLOR1_C_MSK                     0xFFFFFFFF 
#define NV_04B_CLIP_D_POINT0_LEFT_MSK                      0x0000FFFF /* 15:0 */ 
#define NV_04B_CLIP_D_POINT0_LEFT_RMSK                     0x0000FFFF /* 15:0 */ 
#define NV_04B_CLIP_D_POINT0_LEFT_WORD                     0
#define NV_04B_CLIP_D_POINT0_LEFT_HIGH_FIELD               0x0000000F /* =15 */
#define NV_04B_CLIP_D_POINT0_LEFT_LOW_FIELD                0x00000000 /* =0 */
#define NV_04B_CLIP_D_POINT0_TOP_MSK                       0xFFFF0000 /* 31:16 */ 
#define NV_04B_CLIP_D_POINT0_TOP_RMSK                      0x0000FFFF /* 31:16 */ 
#define NV_04B_CLIP_D_POINT0_TOP_WORD                      0
#define NV_04B_CLIP_D_POINT0_TOP_HIGH_FIELD                0x0000001F /* =31 */
#define NV_04B_CLIP_D_POINT0_TOP_LOW_FIELD                 0x00000010 /* =16 */
#define NV_04B_CLIP_D_POINT0_MSK                           0xFFFFFFFF 
#define NV_04B_CLIP_D_POINT1_RIGHT_MSK                     0x0000FFFF /* 15:0 */ 
#define NV_04B_CLIP_D_POINT1_RIGHT_RMSK                    0x0000FFFF /* 15:0 */ 
#define NV_04B_CLIP_D_POINT1_RIGHT_WORD                    0
#define NV_04B_CLIP_D_POINT1_RIGHT_HIGH_FIELD              0x0000000F /* =15 */
#define NV_04B_CLIP_D_POINT1_RIGHT_LOW_FIELD               0x00000000 /* =0 */
#define NV_04B_CLIP_D_POINT1_BOTTOM_MSK                    0xFFFF0000 /* 31:16 */ 
#define NV_04B_CLIP_D_POINT1_BOTTOM_RMSK                   0x0000FFFF /* 31:16 */ 
#define NV_04B_CLIP_D_POINT1_BOTTOM_WORD                   0
#define NV_04B_CLIP_D_POINT1_BOTTOM_HIGH_FIELD             0x0000001F /* =31 */
#define NV_04B_CLIP_D_POINT1_BOTTOM_LOW_FIELD              0x00000010 /* =16 */
#define NV_04B_CLIP_D_POINT1_MSK                           0xFFFFFFFF 
#define NV_04B_COLOR1_D_VALUE_MSK                          0xFFFFFFFF /* 31:0 */ 
#define NV_04B_COLOR1_D_VALUE_RMSK                         0xFFFFFFFF /* 31:0 */ 
#define NV_04B_COLOR1_D_VALUE_WORD                         0
#define NV_04B_COLOR1_D_VALUE_HIGH_FIELD                   0x0000001F /* =31 */
#define NV_04B_COLOR1_D_VALUE_LOW_FIELD                    0x00000000 /* =0 */
#define NV_04B_COLOR1_D_MSK                                0xFFFFFFFF 
#define NV_04B_SIZE_IN_D_WIDTH_MSK                         0x0000FFFF /* 15:0 */ 
#define NV_04B_SIZE_IN_D_WIDTH_RMSK                        0x0000FFFF /* 15:0 */ 
#define NV_04B_SIZE_IN_D_WIDTH_WORD                        0
#define NV_04B_SIZE_IN_D_WIDTH_HIGH_FIELD                  0x0000000F /* =15 */
#define NV_04B_SIZE_IN_D_WIDTH_LOW_FIELD                   0x00000000 /* =0 */
#define NV_04B_SIZE_IN_D_HEIGHT_MSK                        0xFFFF0000 /* 31:16 */ 
#define NV_04B_SIZE_IN_D_HEIGHT_RMSK                       0x0000FFFF /* 31:16 */ 
#define NV_04B_SIZE_IN_D_HEIGHT_WORD                       0
#define NV_04B_SIZE_IN_D_HEIGHT_HIGH_FIELD                 0x0000001F /* =31 */
#define NV_04B_SIZE_IN_D_HEIGHT_LOW_FIELD                  0x00000010 /* =16 */
#define NV_04B_SIZE_IN_D_MSK                               0xFFFFFFFF 
#define NV_04B_SIZE_OUT_D_WIDTH_MSK                        0x0000FFFF /* 15:0 */ 
#define NV_04B_SIZE_OUT_D_WIDTH_RMSK                       0x0000FFFF /* 15:0 */ 
#define NV_04B_SIZE_OUT_D_WIDTH_WORD                       0
#define NV_04B_SIZE_OUT_D_WIDTH_HIGH_FIELD                 0x0000000F /* =15 */
#define NV_04B_SIZE_OUT_D_WIDTH_LOW_FIELD                  0x00000000 /* =0 */
#define NV_04B_SIZE_OUT_D_HEIGHT_MSK                       0xFFFF0000 /* 31:16 */ 
#define NV_04B_SIZE_OUT_D_HEIGHT_RMSK                      0x0000FFFF /* 31:16 */ 
#define NV_04B_SIZE_OUT_D_HEIGHT_WORD                      0
#define NV_04B_SIZE_OUT_D_HEIGHT_HIGH_FIELD                0x0000001F /* =31 */
#define NV_04B_SIZE_OUT_D_HEIGHT_LOW_FIELD                 0x00000010 /* =16 */
#define NV_04B_SIZE_OUT_D_MSK                              0xFFFFFFFF 
#define NV_04B_POINT_D_X_MSK                               0x0000FFFF /* 15:0 */ 
#define NV_04B_POINT_D_X_RMSK                              0x0000FFFF /* 15:0 */ 
#define NV_04B_POINT_D_X_WORD                              0
#define NV_04B_POINT_D_X_HIGH_FIELD                        0x0000000F /* =15 */
#define NV_04B_POINT_D_X_LOW_FIELD                         0x00000000 /* =0 */
#define NV_04B_POINT_D_Y_MSK                               0xFFFF0000 /* 31:16 */ 
#define NV_04B_POINT_D_Y_RMSK                              0x0000FFFF /* 31:16 */ 
#define NV_04B_POINT_D_Y_WORD                              0
#define NV_04B_POINT_D_Y_HIGH_FIELD                        0x0000001F /* =31 */
#define NV_04B_POINT_D_Y_LOW_FIELD                         0x00000010 /* =16 */
#define NV_04B_POINT_D_MSK                                 0xFFFFFFFF 
#define NV_04B_MONOCHROME_COLOR1_D_BITMAP_MSK              0xFFFFFFFF /* 31:0 */ 
#define NV_04B_MONOCHROME_COLOR1_D_BITMAP_RMSK             0xFFFFFFFF /* 31:0 */ 
#define NV_04B_MONOCHROME_COLOR1_D_BITMAP_WORD             0
#define NV_04B_MONOCHROME_COLOR1_D_BITMAP_HIGH_FIELD       0x0000001F /* =31 */
#define NV_04B_MONOCHROME_COLOR1_D_BITMAP_LOW_FIELD        0x00000000 /* =0 */
#define NV_04B_MONOCHROME_COLOR1_D_MSK                     0xFFFFFFFF 
#define NV_04B_CLIP_E_POINT0_LEFT_MSK                      0x0000FFFF /* 15:0 */ 
#define NV_04B_CLIP_E_POINT0_LEFT_RMSK                     0x0000FFFF /* 15:0 */ 
#define NV_04B_CLIP_E_POINT0_LEFT_WORD                     0
#define NV_04B_CLIP_E_POINT0_LEFT_HIGH_FIELD               0x0000000F /* =15 */
#define NV_04B_CLIP_E_POINT0_LEFT_LOW_FIELD                0x00000000 /* =0 */
#define NV_04B_CLIP_E_POINT0_TOP_MSK                       0xFFFF0000 /* 31:16 */ 
#define NV_04B_CLIP_E_POINT0_TOP_RMSK                      0x0000FFFF /* 31:16 */ 
#define NV_04B_CLIP_E_POINT0_TOP_WORD                      0
#define NV_04B_CLIP_E_POINT0_TOP_HIGH_FIELD                0x0000001F /* =31 */
#define NV_04B_CLIP_E_POINT0_TOP_LOW_FIELD                 0x00000010 /* =16 */
#define NV_04B_CLIP_E_POINT0_MSK                           0xFFFFFFFF 
#define NV_04B_CLIP_E_POINT1_RIGHT_MSK                     0x0000FFFF /* 15:0 */ 
#define NV_04B_CLIP_E_POINT1_RIGHT_RMSK                    0x0000FFFF /* 15:0 */ 
#define NV_04B_CLIP_E_POINT1_RIGHT_WORD                    0
#define NV_04B_CLIP_E_POINT1_RIGHT_HIGH_FIELD              0x0000000F /* =15 */
#define NV_04B_CLIP_E_POINT1_RIGHT_LOW_FIELD               0x00000000 /* =0 */
#define NV_04B_CLIP_E_POINT1_BOTTOM_MSK                    0xFFFF0000 /* 31:16 */ 
#define NV_04B_CLIP_E_POINT1_BOTTOM_RMSK                   0x0000FFFF /* 31:16 */ 
#define NV_04B_CLIP_E_POINT1_BOTTOM_WORD                   0
#define NV_04B_CLIP_E_POINT1_BOTTOM_HIGH_FIELD             0x0000001F /* =31 */
#define NV_04B_CLIP_E_POINT1_BOTTOM_LOW_FIELD              0x00000010 /* =16 */
#define NV_04B_CLIP_E_POINT1_MSK                           0xFFFFFFFF 
#define NV_04B_COLOR0_E_VALUE_MSK                          0xFFFFFFFF /* 31:0 */ 
#define NV_04B_COLOR0_E_VALUE_RMSK                         0xFFFFFFFF /* 31:0 */ 
#define NV_04B_COLOR0_E_VALUE_WORD                         0
#define NV_04B_COLOR0_E_VALUE_HIGH_FIELD                   0x0000001F /* =31 */
#define NV_04B_COLOR0_E_VALUE_LOW_FIELD                    0x00000000 /* =0 */
#define NV_04B_COLOR0_E_MSK                                0xFFFFFFFF 
#define NV_04B_COLOR1_E_VALUE_MSK                          0xFFFFFFFF /* 31:0 */ 
#define NV_04B_COLOR1_E_VALUE_RMSK                         0xFFFFFFFF /* 31:0 */ 
#define NV_04B_COLOR1_E_VALUE_WORD                         0
#define NV_04B_COLOR1_E_VALUE_HIGH_FIELD                   0x0000001F /* =31 */
#define NV_04B_COLOR1_E_VALUE_LOW_FIELD                    0x00000000 /* =0 */
#define NV_04B_COLOR1_E_MSK                                0xFFFFFFFF 
#define NV_04B_SIZE_IN_E_WIDTH_MSK                         0x0000FFFF /* 15:0 */ 
#define NV_04B_SIZE_IN_E_WIDTH_RMSK                        0x0000FFFF /* 15:0 */ 
#define NV_04B_SIZE_IN_E_WIDTH_WORD                        0
#define NV_04B_SIZE_IN_E_WIDTH_HIGH_FIELD                  0x0000000F /* =15 */
#define NV_04B_SIZE_IN_E_WIDTH_LOW_FIELD                   0x00000000 /* =0 */
#define NV_04B_SIZE_IN_E_HEIGHT_MSK                        0xFFFF0000 /* 31:16 */ 
#define NV_04B_SIZE_IN_E_HEIGHT_RMSK                       0x0000FFFF /* 31:16 */ 
#define NV_04B_SIZE_IN_E_HEIGHT_WORD                       0
#define NV_04B_SIZE_IN_E_HEIGHT_HIGH_FIELD                 0x0000001F /* =31 */
#define NV_04B_SIZE_IN_E_HEIGHT_LOW_FIELD                  0x00000010 /* =16 */
#define NV_04B_SIZE_IN_E_MSK                               0xFFFFFFFF 
#define NV_04B_SIZE_OUT_E_WIDTH_MSK                        0x0000FFFF /* 15:0 */ 
#define NV_04B_SIZE_OUT_E_WIDTH_RMSK                       0x0000FFFF /* 15:0 */ 
#define NV_04B_SIZE_OUT_E_WIDTH_WORD                       0
#define NV_04B_SIZE_OUT_E_WIDTH_HIGH_FIELD                 0x0000000F /* =15 */
#define NV_04B_SIZE_OUT_E_WIDTH_LOW_FIELD                  0x00000000 /* =0 */
#define NV_04B_SIZE_OUT_E_HEIGHT_MSK                       0xFFFF0000 /* 31:16 */ 
#define NV_04B_SIZE_OUT_E_HEIGHT_RMSK                      0x0000FFFF /* 31:16 */ 
#define NV_04B_SIZE_OUT_E_HEIGHT_WORD                      0
#define NV_04B_SIZE_OUT_E_HEIGHT_HIGH_FIELD                0x0000001F /* =31 */
#define NV_04B_SIZE_OUT_E_HEIGHT_LOW_FIELD                 0x00000010 /* =16 */
#define NV_04B_SIZE_OUT_E_MSK                              0xFFFFFFFF 
#define NV_04B_POINT_E_X_MSK                               0x0000FFFF /* 15:0 */ 
#define NV_04B_POINT_E_X_RMSK                              0x0000FFFF /* 15:0 */ 
#define NV_04B_POINT_E_X_WORD                              0
#define NV_04B_POINT_E_X_HIGH_FIELD                        0x0000000F /* =15 */
#define NV_04B_POINT_E_X_LOW_FIELD                         0x00000000 /* =0 */
#define NV_04B_POINT_E_Y_MSK                               0xFFFF0000 /* 31:16 */ 
#define NV_04B_POINT_E_Y_RMSK                              0x0000FFFF /* 31:16 */ 
#define NV_04B_POINT_E_Y_WORD                              0
#define NV_04B_POINT_E_Y_HIGH_FIELD                        0x0000001F /* =31 */
#define NV_04B_POINT_E_Y_LOW_FIELD                         0x00000010 /* =16 */
#define NV_04B_POINT_E_MSK                                 0xFFFFFFFF 
#define NV_04B_MONOCHROME_COLOR01_E_BITMAP_MSK             0xFFFFFFFF /* 31:0 */ 
#define NV_04B_MONOCHROME_COLOR01_E_BITMAP_RMSK            0xFFFFFFFF /* 31:0 */ 
#define NV_04B_MONOCHROME_COLOR01_E_BITMAP_WORD            0
#define NV_04B_MONOCHROME_COLOR01_E_BITMAP_HIGH_FIELD      0x0000001F /* =31 */
#define NV_04B_MONOCHROME_COLOR01_E_BITMAP_LOW_FIELD       0x00000000 /* =0 */
#define NV_04B_MONOCHROME_COLOR01_E_MSK                    0xFFFFFFFF 
#define NV_053_HIGH_FIELD                                  0x00601FFF /* =6299647 */
#define NV_053_LOW_FIELD                                   0x00600000 /* =6291456 */
#define NV_053_NV4_CONTEXT_SURFACES_ARGB_ZS_ADJ            0x00600000
#define NV_053_NV4_CONTEXT_SURFACES_ARGB_ZS_MSK            0x00000000 
#define NV_053_NOP_ADJ                                     0x00600100
#define NV_053_NOP_PARAMETER_MSK                           0xFFFFFFFF /* 31:0 */ 
#define NV_053_NOP_PARAMETER_RMSK                          0xFFFFFFFF /* 31:0 */ 
#define NV_053_NOP_PARAMETER_WORD                          0
#define NV_053_NOP_PARAMETER_HIGH_FIELD                    0x0000001F /* =31 */
#define NV_053_NOP_PARAMETER_LOW_FIELD                     0x00000000 /* =0 */
#define NV_053_NOP_MSK                                     0xFFFFFFFF 
#define NV_053_NOTIFY_STYLE_MSK                            0xFFFFFFFF /* 31:0 */ 
#define NV_053_NOTIFY_STYLE_RMSK                           0xFFFFFFFF /* 31:0 */ 
#define NV_053_NOTIFY_STYLE_WORD                           0
#define NV_053_NOTIFY_STYLE_HIGH_FIELD                     0x0000001F /* =31 */
#define NV_053_NOTIFY_STYLE_LOW_FIELD                      0x00000000 /* =0 */
#define NV_053_NOTIFY_STYLE_WRITE_ONLY_ADJ                 0x00000000
#define NV_053_NOTIFY_STYLE_WRITE_THEN_AWAKEN_ADJ          0x00000001
#define NV_053_NOTIFY_MSK                                  0xFFFFFFFF 
#define NV_053_SET_CONTEXT_DMA_NOTIFY_PARAMETER_MSK        0xFFFFFFFF /* 31:0 */ 
#define NV_053_SET_CONTEXT_DMA_NOTIFY_PARAMETER_RMSK       0xFFFFFFFF /* 31:0 */ 
#define NV_053_SET_CONTEXT_DMA_NOTIFY_PARAMETER_WORD       0
#define NV_053_SET_CONTEXT_DMA_NOTIFY_PARAMETER_HIGH_FIELD 0x0000001F /* =31 */
#define NV_053_SET_CONTEXT_DMA_NOTIFY_PARAMETER_LOW_FIELD  0x00000000 /* =0 */
#define NV_053_SET_CONTEXT_DMA_NOTIFY_MSK                  0xFFFFFFFF 
#define NV_053_SET_CONTEXT_DMA_COLOR_PARAMETER_MSK         0xFFFFFFFF /* 31:0 */ 
#define NV_053_SET_CONTEXT_DMA_COLOR_PARAMETER_RMSK        0xFFFFFFFF /* 31:0 */ 
#define NV_053_SET_CONTEXT_DMA_COLOR_PARAMETER_WORD        0
#define NV_053_SET_CONTEXT_DMA_COLOR_PARAMETER_HIGH_FIELD  0x0000001F /* =31 */
#define NV_053_SET_CONTEXT_DMA_COLOR_PARAMETER_LOW_FIELD   0x00000000 /* =0 */
#define NV_053_SET_CONTEXT_DMA_COLOR_MSK                   0xFFFFFFFF 
#define NV_053_SET_CONTEXT_DMA_ZETA_PARAMETER_MSK          0xFFFFFFFF /* 31:0 */ 
#define NV_053_SET_CONTEXT_DMA_ZETA_PARAMETER_RMSK         0xFFFFFFFF /* 31:0 */ 
#define NV_053_SET_CONTEXT_DMA_ZETA_PARAMETER_WORD         0
#define NV_053_SET_CONTEXT_DMA_ZETA_PARAMETER_HIGH_FIELD   0x0000001F /* =31 */
#define NV_053_SET_CONTEXT_DMA_ZETA_PARAMETER_LOW_FIELD    0x00000000 /* =0 */
#define NV_053_SET_CONTEXT_DMA_ZETA_MSK                    0xFFFFFFFF 
#define NV_053_SET_CLIP_HORIZONTAL_X_MSK                   0x0000FFFF /* 15:0 */ 
#define NV_053_SET_CLIP_HORIZONTAL_X_RMSK                  0x0000FFFF /* 15:0 */ 
#define NV_053_SET_CLIP_HORIZONTAL_X_WORD                  0
#define NV_053_SET_CLIP_HORIZONTAL_X_HIGH_FIELD            0x0000000F /* =15 */
#define NV_053_SET_CLIP_HORIZONTAL_X_LOW_FIELD             0x00000000 /* =0 */
#define NV_053_SET_CLIP_HORIZONTAL_WIDTH_MSK               0xFFFF0000 /* 31:16 */ 
#define NV_053_SET_CLIP_HORIZONTAL_WIDTH_RMSK              0x0000FFFF /* 31:16 */ 
#define NV_053_SET_CLIP_HORIZONTAL_WIDTH_WORD              0
#define NV_053_SET_CLIP_HORIZONTAL_WIDTH_HIGH_FIELD        0x0000001F /* =31 */
#define NV_053_SET_CLIP_HORIZONTAL_WIDTH_LOW_FIELD         0x00000010 /* =16 */
#define NV_053_SET_CLIP_HORIZONTAL_MSK                     0xFFFFFFFF 
#define NV_053_SET_CLIP_VERTICAL_Y_MSK                     0x0000FFFF /* 15:0 */ 
#define NV_053_SET_CLIP_VERTICAL_Y_RMSK                    0x0000FFFF /* 15:0 */ 
#define NV_053_SET_CLIP_VERTICAL_Y_WORD                    0
#define NV_053_SET_CLIP_VERTICAL_Y_HIGH_FIELD              0x0000000F /* =15 */
#define NV_053_SET_CLIP_VERTICAL_Y_LOW_FIELD               0x00000000 /* =0 */
#define NV_053_SET_CLIP_VERTICAL_HEIGHT_MSK                0xFFFF0000 /* 31:16 */ 
#define NV_053_SET_CLIP_VERTICAL_HEIGHT_RMSK               0x0000FFFF /* 31:16 */ 
#define NV_053_SET_CLIP_VERTICAL_HEIGHT_WORD               0
#define NV_053_SET_CLIP_VERTICAL_HEIGHT_HIGH_FIELD         0x0000001F /* =31 */
#define NV_053_SET_CLIP_VERTICAL_HEIGHT_LOW_FIELD          0x00000010 /* =16 */
#define NV_053_SET_CLIP_VERTICAL_MSK                       0xFFFFFFFF 
#define NV_053_SET_FORMAT_COLOR_MSK                        0x000000FF /* 7:0 */ 
#define NV_053_SET_FORMAT_COLOR_RMSK                       0x000000FF /* 7:0 */ 
#define NV_053_SET_FORMAT_COLOR_WORD                       0
#define NV_053_SET_FORMAT_COLOR_HIGH_FIELD                 0x00000007 /* =7 */
#define NV_053_SET_FORMAT_COLOR_LOW_FIELD                  0x00000000 /* =0 */
#define NV_053_SET_FORMAT_COLOR_LE_X1R5G5B5_Z1R5G5B5_ADJ   0x00000001
#define NV_053_SET_FORMAT_COLOR_LE_X1R5G5B5_O1R5G5B5_ADJ   0x00000002
#define NV_053_SET_FORMAT_COLOR_LE_R5G6B5_ADJ              0x00000003
#define NV_053_SET_FORMAT_COLOR_LE_X8R8G8B8_Z8R8G8B8_ADJ   0x00000004
#define NV_053_SET_FORMAT_COLOR_LE_X8R8G8B8_O8R8G8B8_ADJ   0x00000005
#define NV_053_SET_FORMAT_COLOR_LE_X1A7R8G8B8_Z1A7R8G8B8_ADJ 0x00000006
#define NV_053_SET_FORMAT_COLOR_LE_X1A7R8G8B8_O1A7R8G8B8_ADJ 0x00000007
#define NV_053_SET_FORMAT_COLOR_LE_A8R8G8B8_ADJ            0x00000008
#define NV_053_SET_FORMAT_TYPE_MSK                         0x0000FF00 /* 15:8 */ 
#define NV_053_SET_FORMAT_TYPE_RMSK                        0x000000FF /* 15:8 */ 
#define NV_053_SET_FORMAT_TYPE_WORD                        0
#define NV_053_SET_FORMAT_TYPE_HIGH_FIELD                  0x0000000F /* =15 */
#define NV_053_SET_FORMAT_TYPE_LOW_FIELD                   0x00000008 /* =8 */
#define NV_053_SET_FORMAT_TYPE_PITCH_ADJ                   0x00000100
#define NV_053_SET_FORMAT_TYPE_SWIZZLE_ADJ                 0x00000200
#define NV_053_SET_FORMAT_WIDTH_MSK                        0x00FF0000 /* 23:16 */ 
#define NV_053_SET_FORMAT_WIDTH_RMSK                       0x000000FF /* 23:16 */ 
#define NV_053_SET_FORMAT_WIDTH_WORD                       0
#define NV_053_SET_FORMAT_WIDTH_HIGH_FIELD                 0x00000017 /* =23 */
#define NV_053_SET_FORMAT_WIDTH_LOW_FIELD                  0x00000010 /* =16 */
#define NV_053_SET_FORMAT_HEIGHT_MSK                       0xFF000000 /* 31:24 */ 
#define NV_053_SET_FORMAT_HEIGHT_RMSK                      0x000000FF /* 31:24 */ 
#define NV_053_SET_FORMAT_HEIGHT_WORD                      0
#define NV_053_SET_FORMAT_HEIGHT_HIGH_FIELD                0x0000001F /* =31 */
#define NV_053_SET_FORMAT_HEIGHT_LOW_FIELD                 0x00000018 /* =24 */
#define NV_053_SET_FORMAT_MSK                              0xFFFFFFFF 
#define NV_053_SET_CLIP_SIZE_WIDTH_MSK                     0x0000FFFF /* 15:0 */ 
#define NV_053_SET_CLIP_SIZE_WIDTH_RMSK                    0x0000FFFF /* 15:0 */ 
#define NV_053_SET_CLIP_SIZE_WIDTH_WORD                    0
#define NV_053_SET_CLIP_SIZE_WIDTH_HIGH_FIELD              0x0000000F /* =15 */
#define NV_053_SET_CLIP_SIZE_WIDTH_LOW_FIELD               0x00000000 /* =0 */
#define NV_053_SET_CLIP_SIZE_HEIGHT_MSK                    0xFFFF0000 /* 31:16 */ 
#define NV_053_SET_CLIP_SIZE_HEIGHT_RMSK                   0x0000FFFF /* 31:16 */ 
#define NV_053_SET_CLIP_SIZE_HEIGHT_WORD                   0
#define NV_053_SET_CLIP_SIZE_HEIGHT_HIGH_FIELD             0x0000001F /* =31 */
#define NV_053_SET_CLIP_SIZE_HEIGHT_LOW_FIELD              0x00000010 /* =16 */
#define NV_053_SET_CLIP_SIZE_MSK                           0xFFFFFFFF 
#define NV_053_SET_PITCH_COLOR_MSK                         0x0000FFFF /* 15:0 */ 
#define NV_053_SET_PITCH_COLOR_RMSK                        0x0000FFFF /* 15:0 */ 
#define NV_053_SET_PITCH_COLOR_WORD                        0
#define NV_053_SET_PITCH_COLOR_HIGH_FIELD                  0x0000000F /* =15 */
#define NV_053_SET_PITCH_COLOR_LOW_FIELD                   0x00000000 /* =0 */
#define NV_053_SET_PITCH_ZETA_MSK                          0xFFFF0000 /* 31:16 */ 
#define NV_053_SET_PITCH_ZETA_RMSK                         0x0000FFFF /* 31:16 */ 
#define NV_053_SET_PITCH_ZETA_WORD                         0
#define NV_053_SET_PITCH_ZETA_HIGH_FIELD                   0x0000001F /* =31 */
#define NV_053_SET_PITCH_ZETA_LOW_FIELD                    0x00000010 /* =16 */
#define NV_053_SET_PITCH_MSK                               0xFFFFFFFF 
#define NV_053_SET_OFFSET_COLOR_VALUE_MSK                  0xFFFFFFFF /* 31:0 */ 
#define NV_053_SET_OFFSET_COLOR_VALUE_RMSK                 0xFFFFFFFF /* 31:0 */ 
#define NV_053_SET_OFFSET_COLOR_VALUE_WORD                 0
#define NV_053_SET_OFFSET_COLOR_VALUE_HIGH_FIELD           0x0000001F /* =31 */
#define NV_053_SET_OFFSET_COLOR_VALUE_LOW_FIELD            0x00000000 /* =0 */
#define NV_053_SET_OFFSET_COLOR_MSK                        0xFFFFFFFF 
#define NV_053_SET_OFFSET_ZETA_VALUE_MSK                   0xFFFFFFFF /* 31:0 */ 
#define NV_053_SET_OFFSET_ZETA_VALUE_RMSK                  0xFFFFFFFF /* 31:0 */ 
#define NV_053_SET_OFFSET_ZETA_VALUE_WORD                  0
#define NV_053_SET_OFFSET_ZETA_VALUE_HIGH_FIELD            0x0000001F /* =31 */
#define NV_053_SET_OFFSET_ZETA_VALUE_LOW_FIELD             0x00000000 /* =0 */
#define NV_053_SET_OFFSET_ZETA_MSK                         0xFFFFFFFF 
#define NV_093_HIGH_FIELD                                  0x00581FFF /* =5775359 */
#define NV_093_LOW_FIELD                                   0x00580000 /* =5767168 */
#define NV_093_NV10_CONTEXT_SURFACES_ARGB_ZS_ADJ           0x00580000
#define NV_093_NV10_CONTEXT_SURFACES_ARGB_ZS_MSK           0x00000000 
#define NV_093_NOP_ADJ                                     0x00580100
#define NV_093_NOP_PARAMETER_MSK                           0xFFFFFFFF /* 31:0 */ 
#define NV_093_NOP_PARAMETER_RMSK                          0xFFFFFFFF /* 31:0 */ 
#define NV_093_NOP_PARAMETER_WORD                          0
#define NV_093_NOP_PARAMETER_HIGH_FIELD                    0x0000001F /* =31 */
#define NV_093_NOP_PARAMETER_LOW_FIELD                     0x00000000 /* =0 */
#define NV_093_NOP_MSK                                     0xFFFFFFFF 
#define NV_093_NOTIFY_STYLE_MSK                            0xFFFFFFFF /* 31:0 */ 
#define NV_093_NOTIFY_STYLE_RMSK                           0xFFFFFFFF /* 31:0 */ 
#define NV_093_NOTIFY_STYLE_WORD                           0
#define NV_093_NOTIFY_STYLE_HIGH_FIELD                     0x0000001F /* =31 */
#define NV_093_NOTIFY_STYLE_LOW_FIELD                      0x00000000 /* =0 */
#define NV_093_NOTIFY_STYLE_WRITE_ONLY_ADJ                 0x00000000
#define NV_093_NOTIFY_STYLE_WRITE_THEN_AWAKEN_ADJ          0x00000001
#define NV_093_NOTIFY_MSK                                  0xFFFFFFFF 
#define NV_093_SET_CONTEXT_DMA_NOTIFY_PARAMETER_MSK        0xFFFFFFFF /* 31:0 */ 
#define NV_093_SET_CONTEXT_DMA_NOTIFY_PARAMETER_RMSK       0xFFFFFFFF /* 31:0 */ 
#define NV_093_SET_CONTEXT_DMA_NOTIFY_PARAMETER_WORD       0
#define NV_093_SET_CONTEXT_DMA_NOTIFY_PARAMETER_HIGH_FIELD 0x0000001F /* =31 */
#define NV_093_SET_CONTEXT_DMA_NOTIFY_PARAMETER_LOW_FIELD  0x00000000 /* =0 */
#define NV_093_SET_CONTEXT_DMA_NOTIFY_MSK                  0xFFFFFFFF 
#define NV_093_SET_CONTEXT_DMA_COLOR_PARAMETER_MSK         0xFFFFFFFF /* 31:0 */ 
#define NV_093_SET_CONTEXT_DMA_COLOR_PARAMETER_RMSK        0xFFFFFFFF /* 31:0 */ 
#define NV_093_SET_CONTEXT_DMA_COLOR_PARAMETER_WORD        0
#define NV_093_SET_CONTEXT_DMA_COLOR_PARAMETER_HIGH_FIELD  0x0000001F /* =31 */
#define NV_093_SET_CONTEXT_DMA_COLOR_PARAMETER_LOW_FIELD   0x00000000 /* =0 */
#define NV_093_SET_CONTEXT_DMA_COLOR_MSK                   0xFFFFFFFF 
#define NV_093_SET_CONTEXT_DMA_ZETA_PARAMETER_MSK          0xFFFFFFFF /* 31:0 */ 
#define NV_093_SET_CONTEXT_DMA_ZETA_PARAMETER_RMSK         0xFFFFFFFF /* 31:0 */ 
#define NV_093_SET_CONTEXT_DMA_ZETA_PARAMETER_WORD         0
#define NV_093_SET_CONTEXT_DMA_ZETA_PARAMETER_HIGH_FIELD   0x0000001F /* =31 */
#define NV_093_SET_CONTEXT_DMA_ZETA_PARAMETER_LOW_FIELD    0x00000000 /* =0 */
#define NV_093_SET_CONTEXT_DMA_ZETA_MSK                    0xFFFFFFFF 
#define NV_093_SET_CLIP_HORIZONTAL_X_MSK                   0x0000FFFF /* 15:0 */ 
#define NV_093_SET_CLIP_HORIZONTAL_X_RMSK                  0x0000FFFF /* 15:0 */ 
#define NV_093_SET_CLIP_HORIZONTAL_X_WORD                  0
#define NV_093_SET_CLIP_HORIZONTAL_X_HIGH_FIELD            0x0000000F /* =15 */
#define NV_093_SET_CLIP_HORIZONTAL_X_LOW_FIELD             0x00000000 /* =0 */
#define NV_093_SET_CLIP_HORIZONTAL_WIDTH_MSK               0xFFFF0000 /* 31:16 */ 
#define NV_093_SET_CLIP_HORIZONTAL_WIDTH_RMSK              0x0000FFFF /* 31:16 */ 
#define NV_093_SET_CLIP_HORIZONTAL_WIDTH_WORD              0
#define NV_093_SET_CLIP_HORIZONTAL_WIDTH_HIGH_FIELD        0x0000001F /* =31 */
#define NV_093_SET_CLIP_HORIZONTAL_WIDTH_LOW_FIELD         0x00000010 /* =16 */
#define NV_093_SET_CLIP_HORIZONTAL_MSK                     0xFFFFFFFF 
#define NV_093_SET_CLIP_VERTICAL_Y_MSK                     0x0000FFFF /* 15:0 */ 
#define NV_093_SET_CLIP_VERTICAL_Y_RMSK                    0x0000FFFF /* 15:0 */ 
#define NV_093_SET_CLIP_VERTICAL_Y_WORD                    0
#define NV_093_SET_CLIP_VERTICAL_Y_HIGH_FIELD              0x0000000F /* =15 */
#define NV_093_SET_CLIP_VERTICAL_Y_LOW_FIELD               0x00000000 /* =0 */
#define NV_093_SET_CLIP_VERTICAL_HEIGHT_MSK                0xFFFF0000 /* 31:16 */ 
#define NV_093_SET_CLIP_VERTICAL_HEIGHT_RMSK               0x0000FFFF /* 31:16 */ 
#define NV_093_SET_CLIP_VERTICAL_HEIGHT_WORD               0
#define NV_093_SET_CLIP_VERTICAL_HEIGHT_HIGH_FIELD         0x0000001F /* =31 */
#define NV_093_SET_CLIP_VERTICAL_HEIGHT_LOW_FIELD          0x00000010 /* =16 */
#define NV_093_SET_CLIP_VERTICAL_MSK                       0xFFFFFFFF 
#define NV_093_SET_FORMAT_COLOR_MSK                        0x000000FF /* 7:0 */ 
#define NV_093_SET_FORMAT_COLOR_RMSK                       0x000000FF /* 7:0 */ 
#define NV_093_SET_FORMAT_COLOR_WORD                       0
#define NV_093_SET_FORMAT_COLOR_HIGH_FIELD                 0x00000007 /* =7 */
#define NV_093_SET_FORMAT_COLOR_LOW_FIELD                  0x00000000 /* =0 */
#define NV_093_SET_FORMAT_COLOR_LE_X1R5G5B5_Z1R5G5B5_ADJ   0x00000001
#define NV_093_SET_FORMAT_COLOR_LE_X1R5G5B5_O1R5G5B5_ADJ   0x00000002
#define NV_093_SET_FORMAT_COLOR_LE_R5G6B5_ADJ              0x00000003
#define NV_093_SET_FORMAT_COLOR_LE_X8R8G8B8_Z8R8G8B8_ADJ   0x00000004
#define NV_093_SET_FORMAT_COLOR_LE_X8R8G8B8_O8R8G8B8_ADJ   0x00000005
#define NV_093_SET_FORMAT_COLOR_LE_X1A7R8G8B8_Z1A7R8G8B8_ADJ 0x00000006
#define NV_093_SET_FORMAT_COLOR_LE_X1A7R8G8B8_O1A7R8G8B8_ADJ 0x00000007
#define NV_093_SET_FORMAT_COLOR_LE_A8R8G8B8_ADJ            0x00000008
#define NV_093_SET_FORMAT_TYPE_MSK                         0x0000FF00 /* 15:8 */ 
#define NV_093_SET_FORMAT_TYPE_RMSK                        0x000000FF /* 15:8 */ 
#define NV_093_SET_FORMAT_TYPE_WORD                        0
#define NV_093_SET_FORMAT_TYPE_HIGH_FIELD                  0x0000000F /* =15 */
#define NV_093_SET_FORMAT_TYPE_LOW_FIELD                   0x00000008 /* =8 */
#define NV_093_SET_FORMAT_TYPE_PITCH_ADJ                   0x00000100
#define NV_093_SET_FORMAT_TYPE_SWIZZLE_ADJ                 0x00000200
#define NV_093_SET_FORMAT_WIDTH_MSK                        0x00FF0000 /* 23:16 */ 
#define NV_093_SET_FORMAT_WIDTH_RMSK                       0x000000FF /* 23:16 */ 
#define NV_093_SET_FORMAT_WIDTH_WORD                       0
#define NV_093_SET_FORMAT_WIDTH_HIGH_FIELD                 0x00000017 /* =23 */
#define NV_093_SET_FORMAT_WIDTH_LOW_FIELD                  0x00000010 /* =16 */
#define NV_093_SET_FORMAT_HEIGHT_MSK                       0xFF000000 /* 31:24 */ 
#define NV_093_SET_FORMAT_HEIGHT_RMSK                      0x000000FF /* 31:24 */ 
#define NV_093_SET_FORMAT_HEIGHT_WORD                      0
#define NV_093_SET_FORMAT_HEIGHT_HIGH_FIELD                0x0000001F /* =31 */
#define NV_093_SET_FORMAT_HEIGHT_LOW_FIELD                 0x00000018 /* =24 */
#define NV_093_SET_FORMAT_MSK                              0xFFFFFFFF 
#define NV_093_SET_CLIP_SIZE_WIDTH_MSK                     0x0000FFFF /* 15:0 */ 
#define NV_093_SET_CLIP_SIZE_WIDTH_RMSK                    0x0000FFFF /* 15:0 */ 
#define NV_093_SET_CLIP_SIZE_WIDTH_WORD                    0
#define NV_093_SET_CLIP_SIZE_WIDTH_HIGH_FIELD              0x0000000F /* =15 */
#define NV_093_SET_CLIP_SIZE_WIDTH_LOW_FIELD               0x00000000 /* =0 */
#define NV_093_SET_CLIP_SIZE_HEIGHT_MSK                    0xFFFF0000 /* 31:16 */ 
#define NV_093_SET_CLIP_SIZE_HEIGHT_RMSK                   0x0000FFFF /* 31:16 */ 
#define NV_093_SET_CLIP_SIZE_HEIGHT_WORD                   0
#define NV_093_SET_CLIP_SIZE_HEIGHT_HIGH_FIELD             0x0000001F /* =31 */
#define NV_093_SET_CLIP_SIZE_HEIGHT_LOW_FIELD              0x00000010 /* =16 */
#define NV_093_SET_CLIP_SIZE_MSK                           0xFFFFFFFF 
#define NV_093_SET_PITCH_COLOR_MSK                         0x0000FFFF /* 15:0 */ 
#define NV_093_SET_PITCH_COLOR_RMSK                        0x0000FFFF /* 15:0 */ 
#define NV_093_SET_PITCH_COLOR_WORD                        0
#define NV_093_SET_PITCH_COLOR_HIGH_FIELD                  0x0000000F /* =15 */
#define NV_093_SET_PITCH_COLOR_LOW_FIELD                   0x00000000 /* =0 */
#define NV_093_SET_PITCH_ZETA_MSK                          0xFFFF0000 /* 31:16 */ 
#define NV_093_SET_PITCH_ZETA_RMSK                         0x0000FFFF /* 31:16 */ 
#define NV_093_SET_PITCH_ZETA_WORD                         0
#define NV_093_SET_PITCH_ZETA_HIGH_FIELD                   0x0000001F /* =31 */
#define NV_093_SET_PITCH_ZETA_LOW_FIELD                    0x00000010 /* =16 */
#define NV_093_SET_PITCH_MSK                               0xFFFFFFFF 
#define NV_093_SET_OFFSET_COLOR_VALUE_MSK                  0xFFFFFFFF /* 31:0 */ 
#define NV_093_SET_OFFSET_COLOR_VALUE_RMSK                 0xFFFFFFFF /* 31:0 */ 
#define NV_093_SET_OFFSET_COLOR_VALUE_WORD                 0
#define NV_093_SET_OFFSET_COLOR_VALUE_HIGH_FIELD           0x0000001F /* =31 */
#define NV_093_SET_OFFSET_COLOR_VALUE_LOW_FIELD            0x00000000 /* =0 */
#define NV_093_SET_OFFSET_COLOR_MSK                        0xFFFFFFFF 
#define NV_093_SET_OFFSET_ZETA_VALUE_MSK                   0xFFFFFFFF /* 31:0 */ 
#define NV_093_SET_OFFSET_ZETA_VALUE_RMSK                  0xFFFFFFFF /* 31:0 */ 
#define NV_093_SET_OFFSET_ZETA_VALUE_WORD                  0
#define NV_093_SET_OFFSET_ZETA_VALUE_HIGH_FIELD            0x0000001F /* =31 */
#define NV_093_SET_OFFSET_ZETA_VALUE_LOW_FIELD             0x00000000 /* =0 */
#define NV_093_SET_OFFSET_ZETA_MSK                         0xFFFFFFFF 
#define NV_PPM_HIGH_FIELD                                  0x0000AFFF /* =45055 */
#define NV_PPM_LOW_FIELD                                   0x0000A000 /* =40960 */
#define NV_PPM_NV_TRIG0_SEL_ADJ                            0x0000A400
#define NV_PPM_NV_TRIG0_SEL_SEL0_MSK                       0x000000FF /* 7:0 */ 
#define NV_PPM_NV_TRIG0_SEL_SEL0_RMSK                      0x000000FF /* 7:0 */ 
#define NV_PPM_NV_TRIG0_SEL_SEL0_WORD                      0
#define NV_PPM_NV_TRIG0_SEL_SEL0_HIGH_FIELD                0x00000007 /* =7 */
#define NV_PPM_NV_TRIG0_SEL_SEL0_LOW_FIELD                 0x00000000 /* =0 */
#define NV_PPM_NV_TRIG0_SEL_SEL1_MSK                       0x0000FF00 /* 15:8 */ 
#define NV_PPM_NV_TRIG0_SEL_SEL1_RMSK                      0x000000FF /* 15:8 */ 
#define NV_PPM_NV_TRIG0_SEL_SEL1_WORD                      0
#define NV_PPM_NV_TRIG0_SEL_SEL1_HIGH_FIELD                0x0000000F /* =15 */
#define NV_PPM_NV_TRIG0_SEL_SEL1_LOW_FIELD                 0x00000008 /* =8 */
#define NV_PPM_NV_TRIG0_SEL_SEL2_MSK                       0x00FF0000 /* 23:16 */ 
#define NV_PPM_NV_TRIG0_SEL_SEL2_RMSK                      0x000000FF /* 23:16 */ 
#define NV_PPM_NV_TRIG0_SEL_SEL2_WORD                      0
#define NV_PPM_NV_TRIG0_SEL_SEL2_HIGH_FIELD                0x00000017 /* =23 */
#define NV_PPM_NV_TRIG0_SEL_SEL2_LOW_FIELD                 0x00000010 /* =16 */
#define NV_PPM_NV_TRIG0_SEL_SEL3_MSK                       0xFF000000 /* 31:24 */ 
#define NV_PPM_NV_TRIG0_SEL_SEL3_RMSK                      0x000000FF /* 31:24 */ 
#define NV_PPM_NV_TRIG0_SEL_SEL3_WORD                      0
#define NV_PPM_NV_TRIG0_SEL_SEL3_HIGH_FIELD                0x0000001F /* =31 */
#define NV_PPM_NV_TRIG0_SEL_SEL3_LOW_FIELD                 0x00000018 /* =24 */
#define NV_PPM_NV_TRIG0_SEL_MSK                            0xFFFFFFFF 
#define NV_PPM_NV_TRIG0_OP_FUNC_MSK                        0x0000FFFF /* 15:0 */ 
#define NV_PPM_NV_TRIG0_OP_FUNC_RMSK                       0x0000FFFF /* 15:0 */ 
#define NV_PPM_NV_TRIG0_OP_FUNC_WORD                       0
#define NV_PPM_NV_TRIG0_OP_FUNC_HIGH_FIELD                 0x0000000F /* =15 */
#define NV_PPM_NV_TRIG0_OP_FUNC_LOW_FIELD                  0x00000000 /* =0 */
#define NV_PPM_NV_TRIG0_OP_DSEL0_MSK                       0x00010000 /* 16:16 */ 
#define NV_PPM_NV_TRIG0_OP_DSEL0_RMSK                      0x00000001 /* 16:16 */ 
#define NV_PPM_NV_TRIG0_OP_DSEL0_WORD                      0
#define NV_PPM_NV_TRIG0_OP_DSEL0_HIGH_FIELD                0x00000010 /* =16 */
#define NV_PPM_NV_TRIG0_OP_DSEL0_LOW_FIELD                 0x00000010 /* =16 */
#define NV_PPM_NV_TRIG0_OP_DSEL1_MSK                       0x00020000 /* 17:17 */ 
#define NV_PPM_NV_TRIG0_OP_DSEL1_RMSK                      0x00000001 /* 17:17 */ 
#define NV_PPM_NV_TRIG0_OP_DSEL1_WORD                      0
#define NV_PPM_NV_TRIG0_OP_DSEL1_HIGH_FIELD                0x00000011 /* =17 */
#define NV_PPM_NV_TRIG0_OP_DSEL1_LOW_FIELD                 0x00000011 /* =17 */
#define NV_PPM_NV_TRIG0_OP_MSK                             0x0003FFFF 
#define NV_PPM_NV_TRIG1_SEL_SEL0_MSK                       0x000000FF /* 7:0 */ 
#define NV_PPM_NV_TRIG1_SEL_SEL0_RMSK                      0x000000FF /* 7:0 */ 
#define NV_PPM_NV_TRIG1_SEL_SEL0_WORD                      0
#define NV_PPM_NV_TRIG1_SEL_SEL0_HIGH_FIELD                0x00000007 /* =7 */
#define NV_PPM_NV_TRIG1_SEL_SEL0_LOW_FIELD                 0x00000000 /* =0 */
#define NV_PPM_NV_TRIG1_SEL_SEL1_MSK                       0x0000FF00 /* 15:8 */ 
#define NV_PPM_NV_TRIG1_SEL_SEL1_RMSK                      0x000000FF /* 15:8 */ 
#define NV_PPM_NV_TRIG1_SEL_SEL1_WORD                      0
#define NV_PPM_NV_TRIG1_SEL_SEL1_HIGH_FIELD                0x0000000F /* =15 */
#define NV_PPM_NV_TRIG1_SEL_SEL1_LOW_FIELD                 0x00000008 /* =8 */
#define NV_PPM_NV_TRIG1_SEL_SEL2_MSK                       0x00FF0000 /* 23:16 */ 
#define NV_PPM_NV_TRIG1_SEL_SEL2_RMSK                      0x000000FF /* 23:16 */ 
#define NV_PPM_NV_TRIG1_SEL_SEL2_WORD                      0
#define NV_PPM_NV_TRIG1_SEL_SEL2_HIGH_FIELD                0x00000017 /* =23 */
#define NV_PPM_NV_TRIG1_SEL_SEL2_LOW_FIELD                 0x00000010 /* =16 */
#define NV_PPM_NV_TRIG1_SEL_SEL3_MSK                       0xFF000000 /* 31:24 */ 
#define NV_PPM_NV_TRIG1_SEL_SEL3_RMSK                      0x000000FF /* 31:24 */ 
#define NV_PPM_NV_TRIG1_SEL_SEL3_WORD                      0
#define NV_PPM_NV_TRIG1_SEL_SEL3_HIGH_FIELD                0x0000001F /* =31 */
#define NV_PPM_NV_TRIG1_SEL_SEL3_LOW_FIELD                 0x00000018 /* =24 */
#define NV_PPM_NV_TRIG1_SEL_MSK                            0xFFFFFFFF 
#define NV_PPM_NV_TRIG1_OP_FUNC_MSK                        0x0000FFFF /* 15:0 */ 
#define NV_PPM_NV_TRIG1_OP_FUNC_RMSK                       0x0000FFFF /* 15:0 */ 
#define NV_PPM_NV_TRIG1_OP_FUNC_WORD                       0
#define NV_PPM_NV_TRIG1_OP_FUNC_HIGH_FIELD                 0x0000000F /* =15 */
#define NV_PPM_NV_TRIG1_OP_FUNC_LOW_FIELD                  0x00000000 /* =0 */
#define NV_PPM_NV_TRIG1_OP_DSEL0_MSK                       0x00010000 /* 16:16 */ 
#define NV_PPM_NV_TRIG1_OP_DSEL0_RMSK                      0x00000001 /* 16:16 */ 
#define NV_PPM_NV_TRIG1_OP_DSEL0_WORD                      0
#define NV_PPM_NV_TRIG1_OP_DSEL0_HIGH_FIELD                0x00000010 /* =16 */
#define NV_PPM_NV_TRIG1_OP_DSEL0_LOW_FIELD                 0x00000010 /* =16 */
#define NV_PPM_NV_TRIG1_OP_DSEL1_MSK                       0x00020000 /* 17:17 */ 
#define NV_PPM_NV_TRIG1_OP_DSEL1_RMSK                      0x00000001 /* 17:17 */ 
#define NV_PPM_NV_TRIG1_OP_DSEL1_WORD                      0
#define NV_PPM_NV_TRIG1_OP_DSEL1_HIGH_FIELD                0x00000011 /* =17 */
#define NV_PPM_NV_TRIG1_OP_DSEL1_LOW_FIELD                 0x00000011 /* =17 */
#define NV_PPM_NV_TRIG1_OP_MSK                             0x0003FFFF 
#define NV_PPM_NV_EVENT_SEL_SEL0_MSK                       0x000000FF /* 7:0 */ 
#define NV_PPM_NV_EVENT_SEL_SEL0_RMSK                      0x000000FF /* 7:0 */ 
#define NV_PPM_NV_EVENT_SEL_SEL0_WORD                      0
#define NV_PPM_NV_EVENT_SEL_SEL0_HIGH_FIELD                0x00000007 /* =7 */
#define NV_PPM_NV_EVENT_SEL_SEL0_LOW_FIELD                 0x00000000 /* =0 */
#define NV_PPM_NV_EVENT_SEL_SEL1_MSK                       0x0000FF00 /* 15:8 */ 
#define NV_PPM_NV_EVENT_SEL_SEL1_RMSK                      0x000000FF /* 15:8 */ 
#define NV_PPM_NV_EVENT_SEL_SEL1_WORD                      0
#define NV_PPM_NV_EVENT_SEL_SEL1_HIGH_FIELD                0x0000000F /* =15 */
#define NV_PPM_NV_EVENT_SEL_SEL1_LOW_FIELD                 0x00000008 /* =8 */
#define NV_PPM_NV_EVENT_SEL_SEL2_MSK                       0x00FF0000 /* 23:16 */ 
#define NV_PPM_NV_EVENT_SEL_SEL2_RMSK                      0x000000FF /* 23:16 */ 
#define NV_PPM_NV_EVENT_SEL_SEL2_WORD                      0
#define NV_PPM_NV_EVENT_SEL_SEL2_HIGH_FIELD                0x00000017 /* =23 */
#define NV_PPM_NV_EVENT_SEL_SEL2_LOW_FIELD                 0x00000010 /* =16 */
#define NV_PPM_NV_EVENT_SEL_SEL3_MSK                       0xFF000000 /* 31:24 */ 
#define NV_PPM_NV_EVENT_SEL_SEL3_RMSK                      0x000000FF /* 31:24 */ 
#define NV_PPM_NV_EVENT_SEL_SEL3_WORD                      0
#define NV_PPM_NV_EVENT_SEL_SEL3_HIGH_FIELD                0x0000001F /* =31 */
#define NV_PPM_NV_EVENT_SEL_SEL3_LOW_FIELD                 0x00000018 /* =24 */
#define NV_PPM_NV_EVENT_SEL_MSK                            0xFFFFFFFF 
#define NV_PPM_NV_EVENT_OP_FUNC_MSK                        0x0000FFFF /* 15:0 */ 
#define NV_PPM_NV_EVENT_OP_FUNC_RMSK                       0x0000FFFF /* 15:0 */ 
#define NV_PPM_NV_EVENT_OP_FUNC_WORD                       0
#define NV_PPM_NV_EVENT_OP_FUNC_HIGH_FIELD                 0x0000000F /* =15 */
#define NV_PPM_NV_EVENT_OP_FUNC_LOW_FIELD                  0x00000000 /* =0 */
#define NV_PPM_NV_EVENT_OP_DSEL0_MSK                       0x00010000 /* 16:16 */ 
#define NV_PPM_NV_EVENT_OP_DSEL0_RMSK                      0x00000001 /* 16:16 */ 
#define NV_PPM_NV_EVENT_OP_DSEL0_WORD                      0
#define NV_PPM_NV_EVENT_OP_DSEL0_HIGH_FIELD                0x00000010 /* =16 */
#define NV_PPM_NV_EVENT_OP_DSEL0_LOW_FIELD                 0x00000010 /* =16 */
#define NV_PPM_NV_EVENT_OP_DSEL1_MSK                       0x00020000 /* 17:17 */ 
#define NV_PPM_NV_EVENT_OP_DSEL1_RMSK                      0x00000001 /* 17:17 */ 
#define NV_PPM_NV_EVENT_OP_DSEL1_WORD                      0
#define NV_PPM_NV_EVENT_OP_DSEL1_HIGH_FIELD                0x00000011 /* =17 */
#define NV_PPM_NV_EVENT_OP_DSEL1_LOW_FIELD                 0x00000011 /* =17 */
#define NV_PPM_NV_EVENT_OP_MSK                             0x0003FFFF 
#define NV_PPM_NV_SAMPLE_SEL_SEL0_MSK                      0x000000FF /* 7:0 */ 
#define NV_PPM_NV_SAMPLE_SEL_SEL0_RMSK                     0x000000FF /* 7:0 */ 
#define NV_PPM_NV_SAMPLE_SEL_SEL0_WORD                     0
#define NV_PPM_NV_SAMPLE_SEL_SEL0_HIGH_FIELD               0x00000007 /* =7 */
#define NV_PPM_NV_SAMPLE_SEL_SEL0_LOW_FIELD                0x00000000 /* =0 */
#define NV_PPM_NV_SAMPLE_SEL_SEL1_MSK                      0x0000FF00 /* 15:8 */ 
#define NV_PPM_NV_SAMPLE_SEL_SEL1_RMSK                     0x000000FF /* 15:8 */ 
#define NV_PPM_NV_SAMPLE_SEL_SEL1_WORD                     0
#define NV_PPM_NV_SAMPLE_SEL_SEL1_HIGH_FIELD               0x0000000F /* =15 */
#define NV_PPM_NV_SAMPLE_SEL_SEL1_LOW_FIELD                0x00000008 /* =8 */
#define NV_PPM_NV_SAMPLE_SEL_SEL2_MSK                      0x00FF0000 /* 23:16 */ 
#define NV_PPM_NV_SAMPLE_SEL_SEL2_RMSK                     0x000000FF /* 23:16 */ 
#define NV_PPM_NV_SAMPLE_SEL_SEL2_WORD                     0
#define NV_PPM_NV_SAMPLE_SEL_SEL2_HIGH_FIELD               0x00000017 /* =23 */
#define NV_PPM_NV_SAMPLE_SEL_SEL2_LOW_FIELD                0x00000010 /* =16 */
#define NV_PPM_NV_SAMPLE_SEL_SEL3_MSK                      0xFF000000 /* 31:24 */ 
#define NV_PPM_NV_SAMPLE_SEL_SEL3_RMSK                     0x000000FF /* 31:24 */ 
#define NV_PPM_NV_SAMPLE_SEL_SEL3_WORD                     0
#define NV_PPM_NV_SAMPLE_SEL_SEL3_HIGH_FIELD               0x0000001F /* =31 */
#define NV_PPM_NV_SAMPLE_SEL_SEL3_LOW_FIELD                0x00000018 /* =24 */
#define NV_PPM_NV_SAMPLE_SEL_MSK                           0xFFFFFFFF 
#define NV_PPM_NV_SAMPLE_OP_FUNC_MSK                       0x0000FFFF /* 15:0 */ 
#define NV_PPM_NV_SAMPLE_OP_FUNC_RMSK                      0x0000FFFF /* 15:0 */ 
#define NV_PPM_NV_SAMPLE_OP_FUNC_WORD                      0
#define NV_PPM_NV_SAMPLE_OP_FUNC_HIGH_FIELD                0x0000000F /* =15 */
#define NV_PPM_NV_SAMPLE_OP_FUNC_LOW_FIELD                 0x00000000 /* =0 */
#define NV_PPM_NV_SAMPLE_OP_DSEL0_MSK                      0x00010000 /* 16:16 */ 
#define NV_PPM_NV_SAMPLE_OP_DSEL0_RMSK                     0x00000001 /* 16:16 */ 
#define NV_PPM_NV_SAMPLE_OP_DSEL0_WORD                     0
#define NV_PPM_NV_SAMPLE_OP_DSEL0_HIGH_FIELD               0x00000010 /* =16 */
#define NV_PPM_NV_SAMPLE_OP_DSEL0_LOW_FIELD                0x00000010 /* =16 */
#define NV_PPM_NV_SAMPLE_OP_DSEL1_MSK                      0x00020000 /* 17:17 */ 
#define NV_PPM_NV_SAMPLE_OP_DSEL1_RMSK                     0x00000001 /* 17:17 */ 
#define NV_PPM_NV_SAMPLE_OP_DSEL1_WORD                     0
#define NV_PPM_NV_SAMPLE_OP_DSEL1_HIGH_FIELD               0x00000011 /* =17 */
#define NV_PPM_NV_SAMPLE_OP_DSEL1_LOW_FIELD                0x00000011 /* =17 */
#define NV_PPM_NV_SAMPLE_OP_MSK                            0x0003FFFF 
#define NV_PPM_NV_SETFLAG_SEL_SEL0_MSK                     0x000000FF /* 7:0 */ 
#define NV_PPM_NV_SETFLAG_SEL_SEL0_RMSK                    0x000000FF /* 7:0 */ 
#define NV_PPM_NV_SETFLAG_SEL_SEL0_WORD                    0
#define NV_PPM_NV_SETFLAG_SEL_SEL0_HIGH_FIELD              0x00000007 /* =7 */
#define NV_PPM_NV_SETFLAG_SEL_SEL0_LOW_FIELD               0x00000000 /* =0 */
#define NV_PPM_NV_SETFLAG_SEL_SEL1_MSK                     0x0000FF00 /* 15:8 */ 
#define NV_PPM_NV_SETFLAG_SEL_SEL1_RMSK                    0x000000FF /* 15:8 */ 
#define NV_PPM_NV_SETFLAG_SEL_SEL1_WORD                    0
#define NV_PPM_NV_SETFLAG_SEL_SEL1_HIGH_FIELD              0x0000000F /* =15 */
#define NV_PPM_NV_SETFLAG_SEL_SEL1_LOW_FIELD               0x00000008 /* =8 */
#define NV_PPM_NV_SETFLAG_SEL_SEL2_MSK                     0x00FF0000 /* 23:16 */ 
#define NV_PPM_NV_SETFLAG_SEL_SEL2_RMSK                    0x000000FF /* 23:16 */ 
#define NV_PPM_NV_SETFLAG_SEL_SEL2_WORD                    0
#define NV_PPM_NV_SETFLAG_SEL_SEL2_HIGH_FIELD              0x00000017 /* =23 */
#define NV_PPM_NV_SETFLAG_SEL_SEL2_LOW_FIELD               0x00000010 /* =16 */
#define NV_PPM_NV_SETFLAG_SEL_SEL3_MSK                     0xFF000000 /* 31:24 */ 
#define NV_PPM_NV_SETFLAG_SEL_SEL3_RMSK                    0x000000FF /* 31:24 */ 
#define NV_PPM_NV_SETFLAG_SEL_SEL3_WORD                    0
#define NV_PPM_NV_SETFLAG_SEL_SEL3_HIGH_FIELD              0x0000001F /* =31 */
#define NV_PPM_NV_SETFLAG_SEL_SEL3_LOW_FIELD               0x00000018 /* =24 */
#define NV_PPM_NV_SETFLAG_SEL_MSK                          0xFFFFFFFF 
#define NV_PPM_NV_SETFLAG_OP_FUNC_MSK                      0x0000FFFF /* 15:0 */ 
#define NV_PPM_NV_SETFLAG_OP_FUNC_RMSK                     0x0000FFFF /* 15:0 */ 
#define NV_PPM_NV_SETFLAG_OP_FUNC_WORD                     0
#define NV_PPM_NV_SETFLAG_OP_FUNC_HIGH_FIELD               0x0000000F /* =15 */
#define NV_PPM_NV_SETFLAG_OP_FUNC_LOW_FIELD                0x00000000 /* =0 */
#define NV_PPM_NV_SETFLAG_OP_DSEL0_MSK                     0x00010000 /* 16:16 */ 
#define NV_PPM_NV_SETFLAG_OP_DSEL0_RMSK                    0x00000001 /* 16:16 */ 
#define NV_PPM_NV_SETFLAG_OP_DSEL0_WORD                    0
#define NV_PPM_NV_SETFLAG_OP_DSEL0_HIGH_FIELD              0x00000010 /* =16 */
#define NV_PPM_NV_SETFLAG_OP_DSEL0_LOW_FIELD               0x00000010 /* =16 */
#define NV_PPM_NV_SETFLAG_OP_DSEL1_MSK                     0x00020000 /* 17:17 */ 
#define NV_PPM_NV_SETFLAG_OP_DSEL1_RMSK                    0x00000001 /* 17:17 */ 
#define NV_PPM_NV_SETFLAG_OP_DSEL1_WORD                    0
#define NV_PPM_NV_SETFLAG_OP_DSEL1_HIGH_FIELD              0x00000011 /* =17 */
#define NV_PPM_NV_SETFLAG_OP_DSEL1_LOW_FIELD               0x00000011 /* =17 */
#define NV_PPM_NV_SETFLAG_OP_MSK                           0x0003FFFF 
#define NV_PPM_NV_CLRFLAG_SEL_SEL0_MSK                     0x000000FF /* 7:0 */ 
#define NV_PPM_NV_CLRFLAG_SEL_SEL0_RMSK                    0x000000FF /* 7:0 */ 
#define NV_PPM_NV_CLRFLAG_SEL_SEL0_WORD                    0
#define NV_PPM_NV_CLRFLAG_SEL_SEL0_HIGH_FIELD              0x00000007 /* =7 */
#define NV_PPM_NV_CLRFLAG_SEL_SEL0_LOW_FIELD               0x00000000 /* =0 */
#define NV_PPM_NV_CLRFLAG_SEL_SEL1_MSK                     0x0000FF00 /* 15:8 */ 
#define NV_PPM_NV_CLRFLAG_SEL_SEL1_RMSK                    0x000000FF /* 15:8 */ 
#define NV_PPM_NV_CLRFLAG_SEL_SEL1_WORD                    0
#define NV_PPM_NV_CLRFLAG_SEL_SEL1_HIGH_FIELD              0x0000000F /* =15 */
#define NV_PPM_NV_CLRFLAG_SEL_SEL1_LOW_FIELD               0x00000008 /* =8 */
#define NV_PPM_NV_CLRFLAG_SEL_SEL2_MSK                     0x00FF0000 /* 23:16 */ 
#define NV_PPM_NV_CLRFLAG_SEL_SEL2_RMSK                    0x000000FF /* 23:16 */ 
#define NV_PPM_NV_CLRFLAG_SEL_SEL2_WORD                    0
#define NV_PPM_NV_CLRFLAG_SEL_SEL2_HIGH_FIELD              0x00000017 /* =23 */
#define NV_PPM_NV_CLRFLAG_SEL_SEL2_LOW_FIELD               0x00000010 /* =16 */
#define NV_PPM_NV_CLRFLAG_SEL_SEL3_MSK                     0xFF000000 /* 31:24 */ 
#define NV_PPM_NV_CLRFLAG_SEL_SEL3_RMSK                    0x000000FF /* 31:24 */ 
#define NV_PPM_NV_CLRFLAG_SEL_SEL3_WORD                    0
#define NV_PPM_NV_CLRFLAG_SEL_SEL3_HIGH_FIELD              0x0000001F /* =31 */
#define NV_PPM_NV_CLRFLAG_SEL_SEL3_LOW_FIELD               0x00000018 /* =24 */
#define NV_PPM_NV_CLRFLAG_SEL_MSK                          0xFFFFFFFF 
#define NV_PPM_NV_CLRFLAG_OP_FUNC_MSK                      0x0000FFFF /* 15:0 */ 
#define NV_PPM_NV_CLRFLAG_OP_FUNC_RMSK                     0x0000FFFF /* 15:0 */ 
#define NV_PPM_NV_CLRFLAG_OP_FUNC_WORD                     0
#define NV_PPM_NV_CLRFLAG_OP_FUNC_HIGH_FIELD               0x0000000F /* =15 */
#define NV_PPM_NV_CLRFLAG_OP_FUNC_LOW_FIELD                0x00000000 /* =0 */
#define NV_PPM_NV_CLRFLAG_OP_DSEL0_MSK                     0x00010000 /* 16:16 */ 
#define NV_PPM_NV_CLRFLAG_OP_DSEL0_RMSK                    0x00000001 /* 16:16 */ 
#define NV_PPM_NV_CLRFLAG_OP_DSEL0_WORD                    0
#define NV_PPM_NV_CLRFLAG_OP_DSEL0_HIGH_FIELD              0x00000010 /* =16 */
#define NV_PPM_NV_CLRFLAG_OP_DSEL0_LOW_FIELD               0x00000010 /* =16 */
#define NV_PPM_NV_CLRFLAG_OP_DSEL1_MSK                     0x00020000 /* 17:17 */ 
#define NV_PPM_NV_CLRFLAG_OP_DSEL1_RMSK                    0x00000001 /* 17:17 */ 
#define NV_PPM_NV_CLRFLAG_OP_DSEL1_WORD                    0
#define NV_PPM_NV_CLRFLAG_OP_DSEL1_HIGH_FIELD              0x00000011 /* =17 */
#define NV_PPM_NV_CLRFLAG_OP_DSEL1_LOW_FIELD               0x00000011 /* =17 */
#define NV_PPM_NV_CLRFLAG_OP_MSK                           0x0003FFFF 
#define NV_PPM_NV_ELAPSED_0_VAL_MSK                        0xFFFFFFFF /* 31:0 */ 
#define NV_PPM_NV_ELAPSED_0_VAL_RMSK                       0xFFFFFFFF /* 31:0 */ 
#define NV_PPM_NV_ELAPSED_0_VAL_WORD                       0
#define NV_PPM_NV_ELAPSED_0_VAL_HIGH_FIELD                 0x0000001F /* =31 */
#define NV_PPM_NV_ELAPSED_0_VAL_LOW_FIELD                  0x00000000 /* =0 */
#define NV_PPM_NV_ELAPSED_0_MSK                            0xFFFFFFFF 
#define NV_PPM_NV_ELAPSED_1_VAL_MSK                        0x000000FF /* 7:0 */ 
#define NV_PPM_NV_ELAPSED_1_VAL_RMSK                       0x000000FF /* 7:0 */ 
#define NV_PPM_NV_ELAPSED_1_VAL_WORD                       0
#define NV_PPM_NV_ELAPSED_1_VAL_HIGH_FIELD                 0x00000007 /* =7 */
#define NV_PPM_NV_ELAPSED_1_VAL_LOW_FIELD                  0x00000000 /* =0 */
#define NV_PPM_NV_ELAPSED_1_MSK                            0x000000FF 
#define NV_PPM_NV_CYCLECNT_0_VAL_MSK                       0xFFFFFFFF /* 31:0 */ 
#define NV_PPM_NV_CYCLECNT_0_VAL_RMSK                      0xFFFFFFFF /* 31:0 */ 
#define NV_PPM_NV_CYCLECNT_0_VAL_WORD                      0
#define NV_PPM_NV_CYCLECNT_0_VAL_HIGH_FIELD                0x0000001F /* =31 */
#define NV_PPM_NV_CYCLECNT_0_VAL_LOW_FIELD                 0x00000000 /* =0 */
#define NV_PPM_NV_CYCLECNT_0_MSK                           0xFFFFFFFF 
#define NV_PPM_NV_CYCLECNT_1_VAL_MSK                       0x000000FF /* 7:0 */ 
#define NV_PPM_NV_CYCLECNT_1_VAL_RMSK                      0x000000FF /* 7:0 */ 
#define NV_PPM_NV_CYCLECNT_1_VAL_WORD                      0
#define NV_PPM_NV_CYCLECNT_1_VAL_HIGH_FIELD                0x00000007 /* =7 */
#define NV_PPM_NV_CYCLECNT_1_VAL_LOW_FIELD                 0x00000000 /* =0 */
#define NV_PPM_NV_CYCLECNT_1_MSK                           0x000000FF 
#define NV_PPM_NV_EVENTCNT_0_VAL_MSK                       0xFFFFFFFF /* 31:0 */ 
#define NV_PPM_NV_EVENTCNT_0_VAL_RMSK                      0xFFFFFFFF /* 31:0 */ 
#define NV_PPM_NV_EVENTCNT_0_VAL_WORD                      0
#define NV_PPM_NV_EVENTCNT_0_VAL_HIGH_FIELD                0x0000001F /* =31 */
#define NV_PPM_NV_EVENTCNT_0_VAL_LOW_FIELD                 0x00000000 /* =0 */
#define NV_PPM_NV_EVENTCNT_0_MSK                           0xFFFFFFFF 
#define NV_PPM_NV_EVENTCNT_1_VAL_MSK                       0x000000FF /* 7:0 */ 
#define NV_PPM_NV_EVENTCNT_1_VAL_RMSK                      0x000000FF /* 7:0 */ 
#define NV_PPM_NV_EVENTCNT_1_VAL_WORD                      0
#define NV_PPM_NV_EVENTCNT_1_VAL_HIGH_FIELD                0x00000007 /* =7 */
#define NV_PPM_NV_EVENTCNT_1_VAL_LOW_FIELD                 0x00000000 /* =0 */
#define NV_PPM_NV_EVENTCNT_1_MSK                           0x000000FF 
#define NV_PPM_NV_THRESHCNT_0_VAL_MSK                      0xFFFFFFFF /* 31:0 */ 
#define NV_PPM_NV_THRESHCNT_0_VAL_RMSK                     0xFFFFFFFF /* 31:0 */ 
#define NV_PPM_NV_THRESHCNT_0_VAL_WORD                     0
#define NV_PPM_NV_THRESHCNT_0_VAL_HIGH_FIELD               0x0000001F /* =31 */
#define NV_PPM_NV_THRESHCNT_0_VAL_LOW_FIELD                0x00000000 /* =0 */
#define NV_PPM_NV_THRESHCNT_0_MSK                          0xFFFFFFFF 
#define NV_PPM_NV_THRESHCNT_1_VAL_MSK                      0x000000FF /* 7:0 */ 
#define NV_PPM_NV_THRESHCNT_1_VAL_RMSK                     0x000000FF /* 7:0 */ 
#define NV_PPM_NV_THRESHCNT_1_VAL_WORD                     0
#define NV_PPM_NV_THRESHCNT_1_VAL_HIGH_FIELD               0x00000007 /* =7 */
#define NV_PPM_NV_THRESHCNT_1_VAL_LOW_FIELD                0x00000000 /* =0 */
#define NV_PPM_NV_THRESHCNT_1_MSK                          0x000000FF 
#define NV_PPM_NV_TRIGGERCNT_VAL_MSK                       0xFFFFFFFF /* 31:0 */ 
#define NV_PPM_NV_TRIGGERCNT_VAL_RMSK                      0xFFFFFFFF /* 31:0 */ 
#define NV_PPM_NV_TRIGGERCNT_VAL_WORD                      0
#define NV_PPM_NV_TRIGGERCNT_VAL_HIGH_FIELD                0x0000001F /* =31 */
#define NV_PPM_NV_TRIGGERCNT_VAL_LOW_FIELD                 0x00000000 /* =0 */
#define NV_PPM_NV_TRIGGERCNT_MSK                           0xFFFFFFFF 
#define NV_PPM_NV_SAMPLECNT_VAL_MSK                        0xFFFFFFFF /* 31:0 */ 
#define NV_PPM_NV_SAMPLECNT_VAL_RMSK                       0xFFFFFFFF /* 31:0 */ 
#define NV_PPM_NV_SAMPLECNT_VAL_WORD                       0
#define NV_PPM_NV_SAMPLECNT_VAL_HIGH_FIELD                 0x0000001F /* =31 */
#define NV_PPM_NV_SAMPLECNT_VAL_LOW_FIELD                  0x00000000 /* =0 */
#define NV_PPM_NV_SAMPLECNT_MSK                            0xFFFFFFFF 
#define NV_PPM_NV_THRESHOLD_0_VAL_MSK                      0xFFFFFFFF /* 31:0 */ 
#define NV_PPM_NV_THRESHOLD_0_VAL_RMSK                     0xFFFFFFFF /* 31:0 */ 
#define NV_PPM_NV_THRESHOLD_0_VAL_WORD                     0
#define NV_PPM_NV_THRESHOLD_0_VAL_HIGH_FIELD               0x0000001F /* =31 */
#define NV_PPM_NV_THRESHOLD_0_VAL_LOW_FIELD                0x00000000 /* =0 */
#define NV_PPM_NV_THRESHOLD_0_MSK                          0xFFFFFFFF 
#define NV_PPM_NV_THRESHOLD_1_VAL_MSK                      0x000000FF /* 7:0 */ 
#define NV_PPM_NV_THRESHOLD_1_VAL_RMSK                     0x000000FF /* 7:0 */ 
#define NV_PPM_NV_THRESHOLD_1_VAL_WORD                     0
#define NV_PPM_NV_THRESHOLD_1_VAL_HIGH_FIELD               0x00000007 /* =7 */
#define NV_PPM_NV_THRESHOLD_1_VAL_LOW_FIELD                0x00000000 /* =0 */
#define NV_PPM_NV_THRESHOLD_1_MSK                          0x000000FF 
#define NV_PPM_NV_WATCH0_GR_XF2PM_XF_IDLE_MSK              0x00000001 /* 0:0 */ 
#define NV_PPM_NV_WATCH0_GR_XF2PM_XF_IDLE_RMSK             0x00000001 /* 0:0 */ 
#define NV_PPM_NV_WATCH0_GR_XF2PM_XF_IDLE_WORD             0
#define NV_PPM_NV_WATCH0_GR_XF2PM_XF_IDLE_HIGH_FIELD       0x00000000 /* =0 */
#define NV_PPM_NV_WATCH0_GR_XF2PM_XF_IDLE_LOW_FIELD        0x00000000 /* =0 */
#define NV_PPM_NV_WATCH0_GR_XF2PM_XF2VTX_DATA_VALID_MSK    0x00000003 /* 1:0 */ 
#define NV_PPM_NV_WATCH0_GR_XF2PM_XF2VTX_DATA_VALID_RMSK   0x00000003 /* 1:0 */ 
#define NV_PPM_NV_WATCH0_GR_XF2PM_XF2VTX_DATA_VALID_WORD   0
#define NV_PPM_NV_WATCH0_GR_XF2PM_XF2VTX_DATA_VALID_HIGH_FIELD 0x00000001 /* =1 */
#define NV_PPM_NV_WATCH0_GR_XF2PM_XF2VTX_DATA_VALID_LOW_FIELD 0x00000000 /* =0 */
#define NV_PPM_NV_WATCH0_GR_XF2PM_XF2IDX_BUSY_MSK          0x00000007 /* 2:0 */ 
#define NV_PPM_NV_WATCH0_GR_XF2PM_XF2IDX_BUSY_RMSK         0x00000007 /* 2:0 */ 
#define NV_PPM_NV_WATCH0_GR_XF2PM_XF2IDX_BUSY_WORD         0
#define NV_PPM_NV_WATCH0_GR_XF2PM_XF2IDX_BUSY_HIGH_FIELD   0x00000002 /* =2 */
#define NV_PPM_NV_WATCH0_GR_XF2PM_XF2IDX_BUSY_LOW_FIELD    0x00000000 /* =0 */
#define NV_PPM_NV_WATCH0_GR_VTX2PM_VTXPRIMIDLE_MSK         0x0000000F /* 3:0 */ 
#define NV_PPM_NV_WATCH0_GR_VTX2PM_VTXPRIMIDLE_RMSK        0x0000000F /* 3:0 */ 
#define NV_PPM_NV_WATCH0_GR_VTX2PM_VTXPRIMIDLE_WORD        0
#define NV_PPM_NV_WATCH0_GR_VTX2PM_VTXPRIMIDLE_HIGH_FIELD  0x00000003 /* =3 */
#define NV_PPM_NV_WATCH0_GR_VTX2PM_VTXPRIMIDLE_LOW_FIELD   0x00000000 /* =0 */
#define NV_PPM_NV_WATCH0_GR_VTX2PM_VTX2STP_PRIMVALID_MSK   0x0000001F /* 4:0 */ 
#define NV_PPM_NV_WATCH0_GR_VTX2PM_VTX2STP_PRIMVALID_RMSK  0x0000001F /* 4:0 */ 
#define NV_PPM_NV_WATCH0_GR_VTX2PM_VTX2STP_PRIMVALID_WORD  0
#define NV_PPM_NV_WATCH0_GR_VTX2PM_VTX2STP_PRIMVALID_HIGH_FIELD 0x00000004 /* =4 */
#define NV_PPM_NV_WATCH0_GR_VTX2PM_VTX2STP_PRIMVALID_LOW_FIELD 0x00000000 /* =0 */
#define NV_PPM_NV_WATCH0_GR_VTX2PM_VTX2IDX_BUSY_MSK        0x0000003F /* 5:0 */ 
#define NV_PPM_NV_WATCH0_GR_VTX2PM_VTX2IDX_BUSY_RMSK       0x0000003F /* 5:0 */ 
#define NV_PPM_NV_WATCH0_GR_VTX2PM_VTX2IDX_BUSY_WORD       0
#define NV_PPM_NV_WATCH0_GR_VTX2PM_VTX2IDX_BUSY_HIGH_FIELD 0x00000005 /* =5 */
#define NV_PPM_NV_WATCH0_GR_VTX2PM_VTX2IDX_BUSY_LOW_FIELD  0x00000000 /* =0 */
#define NV_PPM_NV_WATCH0_GR_VTX2PM_VTX2COL_VALID_MSK       0x0000007F /* 6:0 */ 
#define NV_PPM_NV_WATCH0_GR_VTX2PM_VTX2COL_VALID_RMSK      0x0000007F /* 6:0 */ 
#define NV_PPM_NV_WATCH0_GR_VTX2PM_VTX2COL_VALID_WORD      0
#define NV_PPM_NV_WATCH0_GR_VTX2PM_VTX2COL_VALID_HIGH_FIELD 0x00000006 /* =6 */
#define NV_PPM_NV_WATCH0_GR_VTX2PM_VTX2COL_VALID_LOW_FIELD 0x00000000 /* =0 */
#define NV_PPM_NV_WATCH0_GR_TEX2PM_TP1_REPLACER_STALL_MSK  0x000000FF /* 7:0 */ 
#define NV_PPM_NV_WATCH0_GR_TEX2PM_TP1_REPLACER_STALL_RMSK 0x000000FF /* 7:0 */ 
#define NV_PPM_NV_WATCH0_GR_TEX2PM_TP1_REPLACER_STALL_WORD 0
#define NV_PPM_NV_WATCH0_GR_TEX2PM_TP1_REPLACER_STALL_HIGH_FIELD 0x00000007 /* =7 */
#define NV_PPM_NV_WATCH0_GR_TEX2PM_TP1_REPLACER_STALL_LOW_FIELD 0x00000000 /* =0 */
#define NV_PPM_NV_WATCH0_GR_TEX2PM_TP1_MP_QUEUE_STALL_MSK  0x000001FF /* 8:0 */ 
#define NV_PPM_NV_WATCH0_GR_TEX2PM_TP1_MP_QUEUE_STALL_RMSK 0x000001FF /* 8:0 */ 
#define NV_PPM_NV_WATCH0_GR_TEX2PM_TP1_MP_QUEUE_STALL_WORD 0
#define NV_PPM_NV_WATCH0_GR_TEX2PM_TP1_MP_QUEUE_STALL_HIGH_FIELD 0x00000008 /* =8 */
#define NV_PPM_NV_WATCH0_GR_TEX2PM_TP1_MP_QUEUE_STALL_LOW_FIELD 0x00000000 /* =0 */
#define NV_PPM_NV_WATCH0_GR_TEX2PM_TP1_COALESCER_STALL_MSK 0x000003FF /* 9:0 */ 
#define NV_PPM_NV_WATCH0_GR_TEX2PM_TP1_COALESCER_STALL_RMSK 0x000003FF /* 9:0 */ 
#define NV_PPM_NV_WATCH0_GR_TEX2PM_TP1_COALESCER_STALL_WORD 0
#define NV_PPM_NV_WATCH0_GR_TEX2PM_TP1_COALESCER_STALL_HIGH_FIELD 0x00000009 /* =9 */
#define NV_PPM_NV_WATCH0_GR_TEX2PM_TP1_COALESCER_STALL_LOW_FIELD 0x00000000 /* =0 */
#define NV_PPM_NV_WATCH0_GR_TEX2PM_TP0_REPLACER_STALL_MSK  0x00000400 /* 10:10 */ 
#define NV_PPM_NV_WATCH0_GR_TEX2PM_TP0_REPLACER_STALL_RMSK 0x00000001 /* 10:10 */ 
#define NV_PPM_NV_WATCH0_GR_TEX2PM_TP0_REPLACER_STALL_WORD 0
#define NV_PPM_NV_WATCH0_GR_TEX2PM_TP0_REPLACER_STALL_HIGH_FIELD 0x0000000A /* =10 */
#define NV_PPM_NV_WATCH0_GR_TEX2PM_TP0_REPLACER_STALL_LOW_FIELD 0x0000000A /* =10 */
#define NV_PPM_NV_WATCH0_GR_TEX2PM_TP0_MP_QUEUE_STALL_MSK  0x00000800 /* 11:11 */ 
#define NV_PPM_NV_WATCH0_GR_TEX2PM_TP0_MP_QUEUE_STALL_RMSK 0x00000001 /* 11:11 */ 
#define NV_PPM_NV_WATCH0_GR_TEX2PM_TP0_MP_QUEUE_STALL_WORD 0
#define NV_PPM_NV_WATCH0_GR_TEX2PM_TP0_MP_QUEUE_STALL_HIGH_FIELD 0x0000000B /* =11 */
#define NV_PPM_NV_WATCH0_GR_TEX2PM_TP0_MP_QUEUE_STALL_LOW_FIELD 0x0000000B /* =11 */
#define NV_PPM_NV_WATCH0_GR_TEX2PM_TP0_COALESCER_STALL_MSK 0x00001000 /* 12:12 */ 
#define NV_PPM_NV_WATCH0_GR_TEX2PM_TP0_COALESCER_STALL_RMSK 0x00000001 /* 12:12 */ 
#define NV_PPM_NV_WATCH0_GR_TEX2PM_TP0_COALESCER_STALL_WORD 0
#define NV_PPM_NV_WATCH0_GR_TEX2PM_TP0_COALESCER_STALL_HIGH_FIELD 0x0000000C /* =12 */
#define NV_PPM_NV_WATCH0_GR_TEX2PM_TP0_COALESCER_STALL_LOW_FIELD 0x0000000C /* =12 */
#define NV_PPM_NV_WATCH0_GR_TEX2PM_TEX2MATH_TP1_BUSY_MSK   0x00002000 /* 13:13 */ 
#define NV_PPM_NV_WATCH0_GR_TEX2PM_TEX2MATH_TP1_BUSY_RMSK  0x00000001 /* 13:13 */ 
#define NV_PPM_NV_WATCH0_GR_TEX2PM_TEX2MATH_TP1_BUSY_WORD  0
#define NV_PPM_NV_WATCH0_GR_TEX2PM_TEX2MATH_TP1_BUSY_HIGH_FIELD 0x0000000D /* =13 */
#define NV_PPM_NV_WATCH0_GR_TEX2PM_TEX2MATH_TP1_BUSY_LOW_FIELD 0x0000000D /* =13 */
#define NV_PPM_NV_WATCH0_GR_TEX2PM_TEX2MATH_TP0_BUSY_MSK   0x00004000 /* 14:14 */ 
#define NV_PPM_NV_WATCH0_GR_TEX2PM_TEX2MATH_TP0_BUSY_RMSK  0x00000001 /* 14:14 */ 
#define NV_PPM_NV_WATCH0_GR_TEX2PM_TEX2MATH_TP0_BUSY_WORD  0
#define NV_PPM_NV_WATCH0_GR_TEX2PM_TEX2MATH_TP0_BUSY_HIGH_FIELD 0x0000000E /* =14 */
#define NV_PPM_NV_WATCH0_GR_TEX2PM_TEX2MATH_TP0_BUSY_LOW_FIELD 0x0000000E /* =14 */
#define NV_PPM_NV_WATCH0_GR_TEX2PM_TEX2LIT_REQ_MSK         0x00008000 /* 15:15 */ 
#define NV_PPM_NV_WATCH0_GR_TEX2PM_TEX2LIT_REQ_RMSK        0x00000001 /* 15:15 */ 
#define NV_PPM_NV_WATCH0_GR_TEX2PM_TEX2LIT_REQ_WORD        0
#define NV_PPM_NV_WATCH0_GR_TEX2PM_TEX2LIT_REQ_HIGH_FIELD  0x0000000F /* =15 */
#define NV_PPM_NV_WATCH0_GR_TEX2PM_TEX2LIT_REQ_LOW_FIELD   0x0000000F /* =15 */
#define NV_PPM_NV_WATCH0_GR_TEX2PM_TEX2LIT_REGLD_MSK       0x00010000 /* 16:16 */ 
#define NV_PPM_NV_WATCH0_GR_TEX2PM_TEX2LIT_REGLD_RMSK      0x00000001 /* 16:16 */ 
#define NV_PPM_NV_WATCH0_GR_TEX2PM_TEX2LIT_REGLD_WORD      0
#define NV_PPM_NV_WATCH0_GR_TEX2PM_TEX2LIT_REGLD_HIGH_FIELD 0x00000010 /* =16 */
#define NV_PPM_NV_WATCH0_GR_TEX2PM_TEX2LIT_REGLD_LOW_FIELD 0x00000010 /* =16 */
#define NV_PPM_NV_WATCH0_GR_TEX2PM_SNAP_PULSE_MSK          0x00020000 /* 17:17 */ 
#define NV_PPM_NV_WATCH0_GR_TEX2PM_SNAP_PULSE_RMSK         0x00000001 /* 17:17 */ 
#define NV_PPM_NV_WATCH0_GR_TEX2PM_SNAP_PULSE_WORD         0
#define NV_PPM_NV_WATCH0_GR_TEX2PM_SNAP_PULSE_HIGH_FIELD   0x00000011 /* =17 */
#define NV_PPM_NV_WATCH0_GR_TEX2PM_SNAP_PULSE_LOW_FIELD    0x00000011 /* =17 */
#define NV_PPM_NV_WATCH0_GR_TEX2PM_RBFR_FULL_STALL_MSK     0x00040000 /* 18:18 */ 
#define NV_PPM_NV_WATCH0_GR_TEX2PM_RBFR_FULL_STALL_RMSK    0x00000001 /* 18:18 */ 
#define NV_PPM_NV_WATCH0_GR_TEX2PM_RBFR_FULL_STALL_WORD    0
#define NV_PPM_NV_WATCH0_GR_TEX2PM_RBFR_FULL_STALL_HIGH_FIELD 0x00000012 /* =18 */
#define NV_PPM_NV_WATCH0_GR_TEX2PM_RBFR_FULL_STALL_LOW_FIELD 0x00000012 /* =18 */
#define NV_PPM_NV_WATCH0_GR_TEX2PM_CACHE_IDLE_MSK          0x00080000 /* 19:19 */ 
#define NV_PPM_NV_WATCH0_GR_TEX2PM_CACHE_IDLE_RMSK         0x00000001 /* 19:19 */ 
#define NV_PPM_NV_WATCH0_GR_TEX2PM_CACHE_IDLE_WORD         0
#define NV_PPM_NV_WATCH0_GR_TEX2PM_CACHE_IDLE_HIGH_FIELD   0x00000013 /* =19 */
#define NV_PPM_NV_WATCH0_GR_TEX2PM_CACHE_IDLE_LOW_FIELD    0x00000013 /* =19 */
#define NV_PPM_NV_WATCH0_GR_TEX2PM_C2DMA_DV_MSK            0x00100000 /* 20:20 */ 
#define NV_PPM_NV_WATCH0_GR_TEX2PM_C2DMA_DV_RMSK           0x00000001 /* 20:20 */ 
#define NV_PPM_NV_WATCH0_GR_TEX2PM_C2DMA_DV_WORD           0
#define NV_PPM_NV_WATCH0_GR_TEX2PM_C2DMA_DV_HIGH_FIELD     0x00000014 /* =20 */
#define NV_PPM_NV_WATCH0_GR_TEX2PM_C2DMA_DV_LOW_FIELD      0x00000014 /* =20 */
#define NV_PPM_NV_WATCH0_GR_STP2PM_VTX_OFFSCREEN_MSK       0x00200000 /* 21:21 */ 
#define NV_PPM_NV_WATCH0_GR_STP2PM_VTX_OFFSCREEN_RMSK      0x00000001 /* 21:21 */ 
#define NV_PPM_NV_WATCH0_GR_STP2PM_VTX_OFFSCREEN_WORD      0
#define NV_PPM_NV_WATCH0_GR_STP2PM_VTX_OFFSCREEN_HIGH_FIELD 0x00000015 /* =21 */
#define NV_PPM_NV_WATCH0_GR_STP2PM_VTX_OFFSCREEN_LOW_FIELD 0x00000015 /* =21 */
#define NV_PPM_NV_WATCH0_GR_STP2PM_STP_IDLE_MSK            0x00400000 /* 22:22 */ 
#define NV_PPM_NV_WATCH0_GR_STP2PM_STP_IDLE_RMSK           0x00000001 /* 22:22 */ 
#define NV_PPM_NV_WATCH0_GR_STP2PM_STP_IDLE_WORD           0
#define NV_PPM_NV_WATCH0_GR_STP2PM_STP_IDLE_HIGH_FIELD     0x00000016 /* =22 */
#define NV_PPM_NV_WATCH0_GR_STP2PM_STP_IDLE_LOW_FIELD      0x00000016 /* =22 */
#define NV_PPM_NV_WATCH0_GR_STP2PM_STP2VTX_BUSY_MSK        0x00800000 /* 23:23 */ 
#define NV_PPM_NV_WATCH0_GR_STP2PM_STP2VTX_BUSY_RMSK       0x00000001 /* 23:23 */ 
#define NV_PPM_NV_WATCH0_GR_STP2PM_STP2VTX_BUSY_WORD       0
#define NV_PPM_NV_WATCH0_GR_STP2PM_STP2VTX_BUSY_HIGH_FIELD 0x00000017 /* =23 */
#define NV_PPM_NV_WATCH0_GR_STP2PM_STP2VTX_BUSY_LOW_FIELD  0x00000017 /* =23 */
#define NV_PPM_NV_WATCH0_GR_STP2PM_STP2RSTR_VALID_MSK      0x01000000 /* 24:24 */ 
#define NV_PPM_NV_WATCH0_GR_STP2PM_STP2RSTR_VALID_RMSK     0x00000001 /* 24:24 */ 
#define NV_PPM_NV_WATCH0_GR_STP2PM_STP2RSTR_VALID_WORD     0
#define NV_PPM_NV_WATCH0_GR_STP2PM_STP2RSTR_VALID_HIGH_FIELD 0x00000018 /* =24 */
#define NV_PPM_NV_WATCH0_GR_STP2PM_STP2RSTR_VALID_LOW_FIELD 0x00000018 /* =24 */
#define NV_PPM_NV_WATCH0_GR_STP2PM_STP2RSTR_DO_SWATHS_MSK  0x02000000 /* 25:25 */ 
#define NV_PPM_NV_WATCH0_GR_STP2PM_STP2RSTR_DO_SWATHS_RMSK 0x00000001 /* 25:25 */ 
#define NV_PPM_NV_WATCH0_GR_STP2PM_STP2RSTR_DO_SWATHS_WORD 0
#define NV_PPM_NV_WATCH0_GR_STP2PM_STP2RSTR_DO_SWATHS_HIGH_FIELD 0x00000019 /* =25 */
#define NV_PPM_NV_WATCH0_GR_STP2PM_STP2RSTR_DO_SWATHS_LOW_FIELD 0x00000019 /* =25 */
#define NV_PPM_NV_WATCH0_GR_STP2PM_STP2CLP_VALID_MSK       0x04000000 /* 26:26 */ 
#define NV_PPM_NV_WATCH0_GR_STP2PM_STP2CLP_VALID_RMSK      0x00000001 /* 26:26 */ 
#define NV_PPM_NV_WATCH0_GR_STP2PM_STP2CLP_VALID_WORD      0
#define NV_PPM_NV_WATCH0_GR_STP2PM_STP2CLP_VALID_HIGH_FIELD 0x0000001A /* =26 */
#define NV_PPM_NV_WATCH0_GR_STP2PM_STP2CLP_VALID_LOW_FIELD 0x0000001A /* =26 */
#define NV_PPM_NV_WATCH0_GR_STP2PM_START_PRIM_MSK          0x08000000 /* 27:27 */ 
#define NV_PPM_NV_WATCH0_GR_STP2PM_START_PRIM_RMSK         0x00000001 /* 27:27 */ 
#define NV_PPM_NV_WATCH0_GR_STP2PM_START_PRIM_WORD         0
#define NV_PPM_NV_WATCH0_GR_STP2PM_START_PRIM_HIGH_FIELD   0x0000001B /* =27 */
#define NV_PPM_NV_WATCH0_GR_STP2PM_START_PRIM_LOW_FIELD    0x0000001B /* =27 */
#define NV_PPM_NV_WATCH0_GR_STP2PM_POLYMODE_MSK            0x10000000 /* 28:28 */ 
#define NV_PPM_NV_WATCH0_GR_STP2PM_POLYMODE_RMSK           0x00000001 /* 28:28 */ 
#define NV_PPM_NV_WATCH0_GR_STP2PM_POLYMODE_WORD           0
#define NV_PPM_NV_WATCH0_GR_STP2PM_POLYMODE_HIGH_FIELD     0x0000001C /* =28 */
#define NV_PPM_NV_WATCH0_GR_STP2PM_POLYMODE_LOW_FIELD      0x0000001C /* =28 */
#define NV_PPM_NV_WATCH0_GR_STP2PM_DUAL_TEXTURE_MSK        0x20000000 /* 29:29 */ 
#define NV_PPM_NV_WATCH0_GR_STP2PM_DUAL_TEXTURE_RMSK       0x00000001 /* 29:29 */ 
#define NV_PPM_NV_WATCH0_GR_STP2PM_DUAL_TEXTURE_WORD       0
#define NV_PPM_NV_WATCH0_GR_STP2PM_DUAL_TEXTURE_HIGH_FIELD 0x0000001D /* =29 */
#define NV_PPM_NV_WATCH0_GR_STP2PM_DUAL_TEXTURE_LOW_FIELD  0x0000001D /* =29 */
#define NV_PPM_NV_WATCH0_GR_STP2PM_DO_POINT_MSK            0x40000000 /* 30:30 */ 
#define NV_PPM_NV_WATCH0_GR_STP2PM_DO_POINT_RMSK           0x00000001 /* 30:30 */ 
#define NV_PPM_NV_WATCH0_GR_STP2PM_DO_POINT_WORD           0
#define NV_PPM_NV_WATCH0_GR_STP2PM_DO_POINT_HIGH_FIELD     0x0000001E /* =30 */
#define NV_PPM_NV_WATCH0_GR_STP2PM_DO_POINT_LOW_FIELD      0x0000001E /* =30 */
#define NV_PPM_NV_WATCH0_GR_STP2PM_DO_LINE_MSK             0x80000000 /* 31:31 */ 
#define NV_PPM_NV_WATCH0_GR_STP2PM_DO_LINE_RMSK            0x00000001 /* 31:31 */ 
#define NV_PPM_NV_WATCH0_GR_STP2PM_DO_LINE_WORD            0
#define NV_PPM_NV_WATCH0_GR_STP2PM_DO_LINE_HIGH_FIELD      0x0000001F /* =31 */
#define NV_PPM_NV_WATCH0_GR_STP2PM_DO_LINE_LOW_FIELD       0x0000001F /* =31 */
#define NV_PPM_NV_WATCH0_MSK                               0xFFFFFFFF 
#define NV_PPM_NV_WATCH1_GR_STP2PM_CYL_WRAP_MSK            0x00000001 /* 0:0 */ 
#define NV_PPM_NV_WATCH1_GR_STP2PM_CYL_WRAP_RMSK           0x00000001 /* 0:0 */ 
#define NV_PPM_NV_WATCH1_GR_STP2PM_CYL_WRAP_WORD           0
#define NV_PPM_NV_WATCH1_GR_STP2PM_CYL_WRAP_HIGH_FIELD     0x00000000 /* =0 */
#define NV_PPM_NV_WATCH1_GR_STP2PM_CYL_WRAP_LOW_FIELD      0x00000000 /* =0 */
#define NV_PPM_NV_WATCH1_GR_STP2PM_CULL_SMALL_MSK          0x00000003 /* 1:0 */ 
#define NV_PPM_NV_WATCH1_GR_STP2PM_CULL_SMALL_RMSK         0x00000003 /* 1:0 */ 
#define NV_PPM_NV_WATCH1_GR_STP2PM_CULL_SMALL_WORD         0
#define NV_PPM_NV_WATCH1_GR_STP2PM_CULL_SMALL_HIGH_FIELD   0x00000001 /* =1 */
#define NV_PPM_NV_WATCH1_GR_STP2PM_CULL_SMALL_LOW_FIELD    0x00000000 /* =0 */
#define NV_PPM_NV_WATCH1_GR_STP2PM_CULL_NEAR_MSK           0x00000007 /* 2:0 */ 
#define NV_PPM_NV_WATCH1_GR_STP2PM_CULL_NEAR_RMSK          0x00000007 /* 2:0 */ 
#define NV_PPM_NV_WATCH1_GR_STP2PM_CULL_NEAR_WORD          0
#define NV_PPM_NV_WATCH1_GR_STP2PM_CULL_NEAR_HIGH_FIELD    0x00000002 /* =2 */
#define NV_PPM_NV_WATCH1_GR_STP2PM_CULL_NEAR_LOW_FIELD     0x00000000 /* =0 */
#define NV_PPM_NV_WATCH1_GR_STP2PM_CULL_FRONT_MSK          0x0000000F /* 3:0 */ 
#define NV_PPM_NV_WATCH1_GR_STP2PM_CULL_FRONT_RMSK         0x0000000F /* 3:0 */ 
#define NV_PPM_NV_WATCH1_GR_STP2PM_CULL_FRONT_WORD         0
#define NV_PPM_NV_WATCH1_GR_STP2PM_CULL_FRONT_HIGH_FIELD   0x00000003 /* =3 */
#define NV_PPM_NV_WATCH1_GR_STP2PM_CULL_FRONT_LOW_FIELD    0x00000000 /* =0 */
#define NV_PPM_NV_WATCH1_GR_STP2PM_CULL_FAR_MSK            0x0000001F /* 4:0 */ 
#define NV_PPM_NV_WATCH1_GR_STP2PM_CULL_FAR_RMSK           0x0000001F /* 4:0 */ 
#define NV_PPM_NV_WATCH1_GR_STP2PM_CULL_FAR_WORD           0
#define NV_PPM_NV_WATCH1_GR_STP2PM_CULL_FAR_HIGH_FIELD     0x00000004 /* =4 */
#define NV_PPM_NV_WATCH1_GR_STP2PM_CULL_FAR_LOW_FIELD      0x00000000 /* =0 */
#define NV_PPM_NV_WATCH1_GR_STP2PM_CULL_ENA_MSK            0x0000003F /* 5:0 */ 
#define NV_PPM_NV_WATCH1_GR_STP2PM_CULL_ENA_RMSK           0x0000003F /* 5:0 */ 
#define NV_PPM_NV_WATCH1_GR_STP2PM_CULL_ENA_WORD           0
#define NV_PPM_NV_WATCH1_GR_STP2PM_CULL_ENA_HIGH_FIELD     0x00000005 /* =5 */
#define NV_PPM_NV_WATCH1_GR_STP2PM_CULL_ENA_LOW_FIELD      0x00000000 /* =0 */
#define NV_PPM_NV_WATCH1_GR_STP2PM_CULL_BBOX_MSK           0x0000007F /* 6:0 */ 
#define NV_PPM_NV_WATCH1_GR_STP2PM_CULL_BBOX_RMSK          0x0000007F /* 6:0 */ 
#define NV_PPM_NV_WATCH1_GR_STP2PM_CULL_BBOX_WORD          0
#define NV_PPM_NV_WATCH1_GR_STP2PM_CULL_BBOX_HIGH_FIELD    0x00000006 /* =6 */
#define NV_PPM_NV_WATCH1_GR_STP2PM_CULL_BBOX_LOW_FIELD     0x00000000 /* =0 */
#define NV_PPM_NV_WATCH1_GR_STP2PM_CULL_BACK_MSK           0x000000FF /* 7:0 */ 
#define NV_PPM_NV_WATCH1_GR_STP2PM_CULL_BACK_RMSK          0x000000FF /* 7:0 */ 
#define NV_PPM_NV_WATCH1_GR_STP2PM_CULL_BACK_WORD          0
#define NV_PPM_NV_WATCH1_GR_STP2PM_CULL_BACK_HIGH_FIELD    0x00000007 /* =7 */
#define NV_PPM_NV_WATCH1_GR_STP2PM_CULL_BACK_LOW_FIELD     0x00000000 /* =0 */
#define NV_PPM_NV_WATCH1_GR_RSTR2PM_SEARCH_MODE_MSK        0x000001FF /* 8:0 */ 
#define NV_PPM_NV_WATCH1_GR_RSTR2PM_SEARCH_MODE_RMSK       0x000001FF /* 8:0 */ 
#define NV_PPM_NV_WATCH1_GR_RSTR2PM_SEARCH_MODE_WORD       0
#define NV_PPM_NV_WATCH1_GR_RSTR2PM_SEARCH_MODE_HIGH_FIELD 0x00000008 /* =8 */
#define NV_PPM_NV_WATCH1_GR_RSTR2PM_SEARCH_MODE_LOW_FIELD  0x00000000 /* =0 */
#define NV_PPM_NV_WATCH1_GR_RSTR2PM_RSTR_EOPRIM_MSK        0x000003FF /* 9:0 */ 
#define NV_PPM_NV_WATCH1_GR_RSTR2PM_RSTR_EOPRIM_RMSK       0x000003FF /* 9:0 */ 
#define NV_PPM_NV_WATCH1_GR_RSTR2PM_RSTR_EOPRIM_WORD       0
#define NV_PPM_NV_WATCH1_GR_RSTR2PM_RSTR_EOPRIM_HIGH_FIELD 0x00000009 /* =9 */
#define NV_PPM_NV_WATCH1_GR_RSTR2PM_RSTR_EOPRIM_LOW_FIELD  0x00000000 /* =0 */
#define NV_PPM_NV_WATCH1_GR_RSTR2PM_RSTR2PIPE_XY_VALID_MSK 0x00000400 /* 10:10 */ 
#define NV_PPM_NV_WATCH1_GR_RSTR2PM_RSTR2PIPE_XY_VALID_RMSK 0x00000001 /* 10:10 */ 
#define NV_PPM_NV_WATCH1_GR_RSTR2PM_RSTR2PIPE_XY_VALID_WORD 0
#define NV_PPM_NV_WATCH1_GR_RSTR2PM_RSTR2PIPE_XY_VALID_HIGH_FIELD 0x0000000A /* =10 */
#define NV_PPM_NV_WATCH1_GR_RSTR2PM_RSTR2PIPE_XY_VALID_LOW_FIELD 0x0000000A /* =10 */
#define NV_PPM_NV_WATCH1_GR_RSTR2PM_RSTR2PIPE_EOPOLY_MSK   0x00000800 /* 11:11 */ 
#define NV_PPM_NV_WATCH1_GR_RSTR2PM_RSTR2PIPE_EOPOLY_RMSK  0x00000001 /* 11:11 */ 
#define NV_PPM_NV_WATCH1_GR_RSTR2PM_RSTR2PIPE_EOPOLY_WORD  0
#define NV_PPM_NV_WATCH1_GR_RSTR2PM_RSTR2PIPE_EOPOLY_HIGH_FIELD 0x0000000B /* =11 */
#define NV_PPM_NV_WATCH1_GR_RSTR2PM_RSTR2PIPE_EOPOLY_LOW_FIELD 0x0000000B /* =11 */
#define NV_PPM_NV_WATCH1_GR_RSTR2PM_RSTR2MATH_NEWLINE_MSK  0x00001000 /* 12:12 */ 
#define NV_PPM_NV_WATCH1_GR_RSTR2PM_RSTR2MATH_NEWLINE_RMSK 0x00000001 /* 12:12 */ 
#define NV_PPM_NV_WATCH1_GR_RSTR2PM_RSTR2MATH_NEWLINE_WORD 0
#define NV_PPM_NV_WATCH1_GR_RSTR2PM_RSTR2MATH_NEWLINE_HIGH_FIELD 0x0000000C /* =12 */
#define NV_PPM_NV_WATCH1_GR_RSTR2PM_RSTR2MATH_NEWLINE_LOW_FIELD 0x0000000C /* =12 */
#define NV_PPM_NV_WATCH1_GR_RSTR2PM_RSTR2MATH_ABC_VALID_MSK 0x00002000 /* 13:13 */ 
#define NV_PPM_NV_WATCH1_GR_RSTR2PM_RSTR2MATH_ABC_VALID_RMSK 0x00000001 /* 13:13 */ 
#define NV_PPM_NV_WATCH1_GR_RSTR2PM_RSTR2MATH_ABC_VALID_WORD 0
#define NV_PPM_NV_WATCH1_GR_RSTR2PM_RSTR2MATH_ABC_VALID_HIGH_FIELD 0x0000000D /* =13 */
#define NV_PPM_NV_WATCH1_GR_RSTR2PM_RSTR2MATH_ABC_VALID_LOW_FIELD 0x0000000D /* =13 */
#define NV_PPM_NV_WATCH1_GR_RSTR2PM_PIXCNT_0_MSK           0x00004000 /* 14:14 */ 
#define NV_PPM_NV_WATCH1_GR_RSTR2PM_PIXCNT_0_RMSK          0x00000001 /* 14:14 */ 
#define NV_PPM_NV_WATCH1_GR_RSTR2PM_PIXCNT_0_WORD          0
#define NV_PPM_NV_WATCH1_GR_RSTR2PM_PIXCNT_0_HIGH_FIELD    0x0000000E /* =14 */
#define NV_PPM_NV_WATCH1_GR_RSTR2PM_PIXCNT_0_LOW_FIELD     0x0000000E /* =14 */
#define NV_PPM_NV_WATCH1_GR_RSTR2PM_PIXCNT_1_MSK           0x00008000 /* 15:15 */ 
#define NV_PPM_NV_WATCH1_GR_RSTR2PM_PIXCNT_1_RMSK          0x00000001 /* 15:15 */ 
#define NV_PPM_NV_WATCH1_GR_RSTR2PM_PIXCNT_1_WORD          0
#define NV_PPM_NV_WATCH1_GR_RSTR2PM_PIXCNT_1_HIGH_FIELD    0x0000000F /* =15 */
#define NV_PPM_NV_WATCH1_GR_RSTR2PM_PIXCNT_1_LOW_FIELD     0x0000000F /* =15 */
#define NV_PPM_NV_WATCH1_GR_RSTR2PM_PIXCNT_2_MSK           0x00010000 /* 16:16 */ 
#define NV_PPM_NV_WATCH1_GR_RSTR2PM_PIXCNT_2_RMSK          0x00000001 /* 16:16 */ 
#define NV_PPM_NV_WATCH1_GR_RSTR2PM_PIXCNT_2_WORD          0
#define NV_PPM_NV_WATCH1_GR_RSTR2PM_PIXCNT_2_HIGH_FIELD    0x00000010 /* =16 */
#define NV_PPM_NV_WATCH1_GR_RSTR2PM_PIXCNT_2_LOW_FIELD     0x00000010 /* =16 */
#define NV_PPM_NV_WATCH1_GR_RSTR2PM_FINE_STALL_MSK         0x00020000 /* 17:17 */ 
#define NV_PPM_NV_WATCH1_GR_RSTR2PM_FINE_STALL_RMSK        0x00000001 /* 17:17 */ 
#define NV_PPM_NV_WATCH1_GR_RSTR2PM_FINE_STALL_WORD        0
#define NV_PPM_NV_WATCH1_GR_RSTR2PM_FINE_STALL_HIGH_FIELD  0x00000011 /* =17 */
#define NV_PPM_NV_WATCH1_GR_RSTR2PM_FINE_STALL_LOW_FIELD   0x00000011 /* =17 */
#define NV_PPM_NV_WATCH1_GR_RSTR2PM_FINE_IDLE_MSK          0x00040000 /* 18:18 */ 
#define NV_PPM_NV_WATCH1_GR_RSTR2PM_FINE_IDLE_RMSK         0x00000001 /* 18:18 */ 
#define NV_PPM_NV_WATCH1_GR_RSTR2PM_FINE_IDLE_WORD         0
#define NV_PPM_NV_WATCH1_GR_RSTR2PM_FINE_IDLE_HIGH_FIELD   0x00000012 /* =18 */
#define NV_PPM_NV_WATCH1_GR_RSTR2PM_FINE_IDLE_LOW_FIELD    0x00000012 /* =18 */
#define NV_PPM_NV_WATCH1_GR_RSTR2PM_FINE_EDGE_EVAL_MSK     0x00080000 /* 19:19 */ 
#define NV_PPM_NV_WATCH1_GR_RSTR2PM_FINE_EDGE_EVAL_RMSK    0x00000001 /* 19:19 */ 
#define NV_PPM_NV_WATCH1_GR_RSTR2PM_FINE_EDGE_EVAL_WORD    0
#define NV_PPM_NV_WATCH1_GR_RSTR2PM_FINE_EDGE_EVAL_HIGH_FIELD 0x00000013 /* =19 */
#define NV_PPM_NV_WATCH1_GR_RSTR2PM_FINE_EDGE_EVAL_LOW_FIELD 0x00000013 /* =19 */
#define NV_PPM_NV_WATCH1_GR_RSTR2PM_FINE_ALIASED_MSK       0x00100000 /* 20:20 */ 
#define NV_PPM_NV_WATCH1_GR_RSTR2PM_FINE_ALIASED_RMSK      0x00000001 /* 20:20 */ 
#define NV_PPM_NV_WATCH1_GR_RSTR2PM_FINE_ALIASED_WORD      0
#define NV_PPM_NV_WATCH1_GR_RSTR2PM_FINE_ALIASED_HIGH_FIELD 0x00000014 /* =20 */
#define NV_PPM_NV_WATCH1_GR_RSTR2PM_FINE_ALIASED_LOW_FIELD 0x00000014 /* =20 */
#define NV_PPM_NV_WATCH1_GR_RSTR2PM_COARSE_VALID_MSK       0x00200000 /* 21:21 */ 
#define NV_PPM_NV_WATCH1_GR_RSTR2PM_COARSE_VALID_RMSK      0x00000001 /* 21:21 */ 
#define NV_PPM_NV_WATCH1_GR_RSTR2PM_COARSE_VALID_WORD      0
#define NV_PPM_NV_WATCH1_GR_RSTR2PM_COARSE_VALID_HIGH_FIELD 0x00000015 /* =21 */
#define NV_PPM_NV_WATCH1_GR_RSTR2PM_COARSE_VALID_LOW_FIELD 0x00000015 /* =21 */
#define NV_PPM_NV_WATCH1_GR_RSTR2PM_COARSE_STALL_MSK       0x00400000 /* 22:22 */ 
#define NV_PPM_NV_WATCH1_GR_RSTR2PM_COARSE_STALL_RMSK      0x00000001 /* 22:22 */ 
#define NV_PPM_NV_WATCH1_GR_RSTR2PM_COARSE_STALL_WORD      0
#define NV_PPM_NV_WATCH1_GR_RSTR2PM_COARSE_STALL_HIGH_FIELD 0x00000016 /* =22 */
#define NV_PPM_NV_WATCH1_GR_RSTR2PM_COARSE_STALL_LOW_FIELD 0x00000016 /* =22 */
#define NV_PPM_NV_WATCH1_GR_RSTR2PM_COARSE_IDLE_MSK        0x00800000 /* 23:23 */ 
#define NV_PPM_NV_WATCH1_GR_RSTR2PM_COARSE_IDLE_RMSK       0x00000001 /* 23:23 */ 
#define NV_PPM_NV_WATCH1_GR_RSTR2PM_COARSE_IDLE_WORD       0
#define NV_PPM_NV_WATCH1_GR_RSTR2PM_COARSE_IDLE_HIGH_FIELD 0x00000017 /* =23 */
#define NV_PPM_NV_WATCH1_GR_RSTR2PM_COARSE_IDLE_LOW_FIELD  0x00000017 /* =23 */
#define NV_PPM_NV_WATCH1_GR_ROP2PM_ZWRITE_MSK              0x01000000 /* 24:24 */ 
#define NV_PPM_NV_WATCH1_GR_ROP2PM_ZWRITE_RMSK             0x00000001 /* 24:24 */ 
#define NV_PPM_NV_WATCH1_GR_ROP2PM_ZWRITE_WORD             0
#define NV_PPM_NV_WATCH1_GR_ROP2PM_ZWRITE_HIGH_FIELD       0x00000018 /* =24 */
#define NV_PPM_NV_WATCH1_GR_ROP2PM_ZWRITE_LOW_FIELD        0x00000018 /* =24 */
#define NV_PPM_NV_WATCH1_GR_ROP2PM_ZPARTIAL_MSK            0x02000000 /* 25:25 */ 
#define NV_PPM_NV_WATCH1_GR_ROP2PM_ZPARTIAL_RMSK           0x00000001 /* 25:25 */ 
#define NV_PPM_NV_WATCH1_GR_ROP2PM_ZPARTIAL_WORD           0
#define NV_PPM_NV_WATCH1_GR_ROP2PM_ZPARTIAL_HIGH_FIELD     0x00000019 /* =25 */
#define NV_PPM_NV_WATCH1_GR_ROP2PM_ZPARTIAL_LOW_FIELD      0x00000019 /* =25 */
#define NV_PPM_NV_WATCH1_GR_ROP2PM_WAITMEMWR_MSK           0x04000000 /* 26:26 */ 
#define NV_PPM_NV_WATCH1_GR_ROP2PM_WAITMEMWR_RMSK          0x00000001 /* 26:26 */ 
#define NV_PPM_NV_WATCH1_GR_ROP2PM_WAITMEMWR_WORD          0
#define NV_PPM_NV_WATCH1_GR_ROP2PM_WAITMEMWR_HIGH_FIELD    0x0000001A /* =26 */
#define NV_PPM_NV_WATCH1_GR_ROP2PM_WAITMEMWR_LOW_FIELD     0x0000001A /* =26 */
#define NV_PPM_NV_WATCH1_GR_ROP2PM_WAITMEMRD_MSK           0x08000000 /* 27:27 */ 
#define NV_PPM_NV_WATCH1_GR_ROP2PM_WAITMEMRD_RMSK          0x00000001 /* 27:27 */ 
#define NV_PPM_NV_WATCH1_GR_ROP2PM_WAITMEMRD_WORD          0
#define NV_PPM_NV_WATCH1_GR_ROP2PM_WAITMEMRD_HIGH_FIELD    0x0000001B /* =27 */
#define NV_PPM_NV_WATCH1_GR_ROP2PM_WAITMEMRD_LOW_FIELD     0x0000001B /* =27 */
#define NV_PPM_NV_WATCH1_GR_ROP2PM_WAIT_BUF_MSK            0x10000000 /* 28:28 */ 
#define NV_PPM_NV_WATCH1_GR_ROP2PM_WAIT_BUF_RMSK           0x00000001 /* 28:28 */ 
#define NV_PPM_NV_WATCH1_GR_ROP2PM_WAIT_BUF_WORD           0
#define NV_PPM_NV_WATCH1_GR_ROP2PM_WAIT_BUF_HIGH_FIELD     0x0000001C /* =28 */
#define NV_PPM_NV_WATCH1_GR_ROP2PM_WAIT_BUF_LOW_FIELD      0x0000001C /* =28 */
#define NV_PPM_NV_WATCH1_GR_ROP2PM_ROP_IDLE_MSK            0x20000000 /* 29:29 */ 
#define NV_PPM_NV_WATCH1_GR_ROP2PM_ROP_IDLE_RMSK           0x00000001 /* 29:29 */ 
#define NV_PPM_NV_WATCH1_GR_ROP2PM_ROP_IDLE_WORD           0
#define NV_PPM_NV_WATCH1_GR_ROP2PM_ROP_IDLE_HIGH_FIELD     0x0000001D /* =29 */
#define NV_PPM_NV_WATCH1_GR_ROP2PM_ROP_IDLE_LOW_FIELD      0x0000001D /* =29 */
#define NV_PPM_NV_WATCH1_GR_ROP2PM_ROP2FB_REQ_MSK          0x40000000 /* 30:30 */ 
#define NV_PPM_NV_WATCH1_GR_ROP2PM_ROP2FB_REQ_RMSK         0x00000001 /* 30:30 */ 
#define NV_PPM_NV_WATCH1_GR_ROP2PM_ROP2FB_REQ_WORD         0
#define NV_PPM_NV_WATCH1_GR_ROP2PM_ROP2FB_REQ_HIGH_FIELD   0x0000001E /* =30 */
#define NV_PPM_NV_WATCH1_GR_ROP2PM_ROP2FB_REQ_LOW_FIELD    0x0000001E /* =30 */
#define NV_PPM_NV_WATCH1_GR_ROP2PM_ROP2FB_RD_MSK           0x80000000 /* 31:31 */ 
#define NV_PPM_NV_WATCH1_GR_ROP2PM_ROP2FB_RD_RMSK          0x00000001 /* 31:31 */ 
#define NV_PPM_NV_WATCH1_GR_ROP2PM_ROP2FB_RD_WORD          0
#define NV_PPM_NV_WATCH1_GR_ROP2PM_ROP2FB_RD_HIGH_FIELD    0x0000001F /* =31 */
#define NV_PPM_NV_WATCH1_GR_ROP2PM_ROP2FB_RD_LOW_FIELD     0x0000001F /* =31 */
#define NV_PPM_NV_WATCH1_MSK                               0xFFFFFFFF 
#define NV_PPM_NV_WATCH2_GR_ROP2PM_ROP2FB_ALOM_MSK         0x00000001 /* 0:0 */ 
#define NV_PPM_NV_WATCH2_GR_ROP2PM_ROP2FB_ALOM_RMSK        0x00000001 /* 0:0 */ 
#define NV_PPM_NV_WATCH2_GR_ROP2PM_ROP2FB_ALOM_WORD        0
#define NV_PPM_NV_WATCH2_GR_ROP2PM_ROP2FB_ALOM_HIGH_FIELD  0x00000000 /* =0 */
#define NV_PPM_NV_WATCH2_GR_ROP2PM_ROP2FB_ALOM_LOW_FIELD   0x00000000 /* =0 */
#define NV_PPM_NV_WATCH2_GR_ROP2PM_CWRITE_MSK              0x00000003 /* 1:0 */ 
#define NV_PPM_NV_WATCH2_GR_ROP2PM_CWRITE_RMSK             0x00000003 /* 1:0 */ 
#define NV_PPM_NV_WATCH2_GR_ROP2PM_CWRITE_WORD             0
#define NV_PPM_NV_WATCH2_GR_ROP2PM_CWRITE_HIGH_FIELD       0x00000001 /* =1 */
#define NV_PPM_NV_WATCH2_GR_ROP2PM_CWRITE_LOW_FIELD        0x00000000 /* =0 */
#define NV_PPM_NV_WATCH2_GR_R2D2PM_PRE_OUTPUT_BUSY_MSK     0x00000007 /* 2:0 */ 
#define NV_PPM_NV_WATCH2_GR_R2D2PM_PRE_OUTPUT_BUSY_RMSK    0x00000007 /* 2:0 */ 
#define NV_PPM_NV_WATCH2_GR_R2D2PM_PRE_OUTPUT_BUSY_WORD    0
#define NV_PPM_NV_WATCH2_GR_R2D2PM_PRE_OUTPUT_BUSY_HIGH_FIELD 0x00000002 /* =2 */
#define NV_PPM_NV_WATCH2_GR_R2D2PM_PRE_OUTPUT_BUSY_LOW_FIELD 0x00000000 /* =0 */
#define NV_PPM_NV_WATCH2_GR_R2D2PM_R2D2MATH_IM_NEWLINE_MSK 0x0000000F /* 3:0 */ 
#define NV_PPM_NV_WATCH2_GR_R2D2PM_R2D2MATH_IM_NEWLINE_RMSK 0x0000000F /* 3:0 */ 
#define NV_PPM_NV_WATCH2_GR_R2D2PM_R2D2MATH_IM_NEWLINE_WORD 0
#define NV_PPM_NV_WATCH2_GR_R2D2PM_R2D2MATH_IM_NEWLINE_HIGH_FIELD 0x00000003 /* =3 */
#define NV_PPM_NV_WATCH2_GR_R2D2PM_R2D2MATH_IM_NEWLINE_LOW_FIELD 0x00000000 /* =0 */
#define NV_PPM_NV_WATCH2_GR_R2D2PM_RSTR2D_IDLE_MSK         0x0000001F /* 4:0 */ 
#define NV_PPM_NV_WATCH2_GR_R2D2PM_RSTR2D_IDLE_RMSK        0x0000001F /* 4:0 */ 
#define NV_PPM_NV_WATCH2_GR_R2D2PM_RSTR2D_IDLE_WORD        0
#define NV_PPM_NV_WATCH2_GR_R2D2PM_RSTR2D_IDLE_HIGH_FIELD  0x00000004 /* =4 */
#define NV_PPM_NV_WATCH2_GR_R2D2PM_RSTR2D_IDLE_LOW_FIELD   0x00000000 /* =0 */
#define NV_PPM_NV_WATCH2_GR_R2D2PM_R2D2FE_RSTR2D_BUSY_MSK  0x0000003F /* 5:0 */ 
#define NV_PPM_NV_WATCH2_GR_R2D2PM_R2D2FE_RSTR2D_BUSY_RMSK 0x0000003F /* 5:0 */ 
#define NV_PPM_NV_WATCH2_GR_R2D2PM_R2D2FE_RSTR2D_BUSY_WORD 0
#define NV_PPM_NV_WATCH2_GR_R2D2PM_R2D2FE_RSTR2D_BUSY_HIGH_FIELD 0x00000005 /* =5 */
#define NV_PPM_NV_WATCH2_GR_R2D2PM_R2D2FE_RSTR2D_BUSY_LOW_FIELD 0x00000000 /* =0 */
#define NV_PPM_NV_WATCH2_GR_R2D2PM_MATH_CACHE_BUSY_MSK     0x0000007F /* 6:0 */ 
#define NV_PPM_NV_WATCH2_GR_R2D2PM_MATH_CACHE_BUSY_RMSK    0x0000007F /* 6:0 */ 
#define NV_PPM_NV_WATCH2_GR_R2D2PM_MATH_CACHE_BUSY_WORD    0
#define NV_PPM_NV_WATCH2_GR_R2D2PM_MATH_CACHE_BUSY_HIGH_FIELD 0x00000006 /* =6 */
#define NV_PPM_NV_WATCH2_GR_R2D2PM_MATH_CACHE_BUSY_LOW_FIELD 0x00000000 /* =0 */
#define NV_PPM_NV_WATCH2_GR_R2D2PM_R2D2PRE_OUTPUT_REQ_MSK  0x000000FF /* 7:0 */ 
#define NV_PPM_NV_WATCH2_GR_R2D2PM_R2D2PRE_OUTPUT_REQ_RMSK 0x000000FF /* 7:0 */ 
#define NV_PPM_NV_WATCH2_GR_R2D2PM_R2D2PRE_OUTPUT_REQ_WORD 0
#define NV_PPM_NV_WATCH2_GR_R2D2PM_R2D2PRE_OUTPUT_REQ_HIGH_FIELD 0x00000007 /* =7 */
#define NV_PPM_NV_WATCH2_GR_R2D2PM_R2D2PRE_OUTPUT_REQ_LOW_FIELD 0x00000000 /* =0 */
#define NV_PPM_NV_WATCH2_GR_R2D2PM_R2D2PRE_OUTPUT_NOP_MSK  0x000001FF /* 8:0 */ 
#define NV_PPM_NV_WATCH2_GR_R2D2PM_R2D2PRE_OUTPUT_NOP_RMSK 0x000001FF /* 8:0 */ 
#define NV_PPM_NV_WATCH2_GR_R2D2PM_R2D2PRE_OUTPUT_NOP_WORD 0
#define NV_PPM_NV_WATCH2_GR_R2D2PM_R2D2PRE_OUTPUT_NOP_HIGH_FIELD 0x00000008 /* =8 */
#define NV_PPM_NV_WATCH2_GR_R2D2PM_R2D2PRE_OUTPUT_NOP_LOW_FIELD 0x00000000 /* =0 */
#define NV_PPM_NV_WATCH2_GR_R2D2PM_R2D2MATH_IM_RIGHT_DV_MSK 0x000003FF /* 9:0 */ 
#define NV_PPM_NV_WATCH2_GR_R2D2PM_R2D2MATH_IM_RIGHT_DV_RMSK 0x000003FF /* 9:0 */ 
#define NV_PPM_NV_WATCH2_GR_R2D2PM_R2D2MATH_IM_RIGHT_DV_WORD 0
#define NV_PPM_NV_WATCH2_GR_R2D2PM_R2D2MATH_IM_RIGHT_DV_HIGH_FIELD 0x00000009 /* =9 */
#define NV_PPM_NV_WATCH2_GR_R2D2PM_R2D2MATH_IM_RIGHT_DV_LOW_FIELD 0x00000000 /* =0 */
#define NV_PPM_NV_WATCH2_GR_R2D2PM_R2D2MATH_IM_LEFT_DV_MSK 0x00000400 /* 10:10 */ 
#define NV_PPM_NV_WATCH2_GR_R2D2PM_R2D2MATH_IM_LEFT_DV_RMSK 0x00000001 /* 10:10 */ 
#define NV_PPM_NV_WATCH2_GR_R2D2PM_R2D2MATH_IM_LEFT_DV_WORD 0
#define NV_PPM_NV_WATCH2_GR_R2D2PM_R2D2MATH_IM_LEFT_DV_HIGH_FIELD 0x0000000A /* =10 */
#define NV_PPM_NV_WATCH2_GR_R2D2PM_R2D2MATH_IM_LEFT_DV_LOW_FIELD 0x0000000A /* =10 */
#define NV_PPM_NV_WATCH2_GR_R2D2PM_FE_REQ_MSK              0x00000800 /* 11:11 */ 
#define NV_PPM_NV_WATCH2_GR_R2D2PM_FE_REQ_RMSK             0x00000001 /* 11:11 */ 
#define NV_PPM_NV_WATCH2_GR_R2D2PM_FE_REQ_WORD             0
#define NV_PPM_NV_WATCH2_GR_R2D2PM_FE_REQ_HIGH_FIELD       0x0000000B /* =11 */
#define NV_PPM_NV_WATCH2_GR_R2D2PM_FE_REQ_LOW_FIELD        0x0000000B /* =11 */
#define NV_PPM_NV_WATCH2_GR_PRE2PM_PREROP_IDLE_MSK         0x00001000 /* 12:12 */ 
#define NV_PPM_NV_WATCH2_GR_PRE2PM_PREROP_IDLE_RMSK        0x00000001 /* 12:12 */ 
#define NV_PPM_NV_WATCH2_GR_PRE2PM_PREROP_IDLE_WORD        0
#define NV_PPM_NV_WATCH2_GR_PRE2PM_PREROP_IDLE_HIGH_FIELD  0x0000000C /* =12 */
#define NV_PPM_NV_WATCH2_GR_PRE2PM_PREROP_IDLE_LOW_FIELD   0x0000000C /* =12 */
#define NV_PPM_NV_WATCH2_GR_PRE2PM_PRE2ROP_ROP_REQ_MSK     0x00002000 /* 13:13 */ 
#define NV_PPM_NV_WATCH2_GR_PRE2PM_PRE2ROP_ROP_REQ_RMSK    0x00000001 /* 13:13 */ 
#define NV_PPM_NV_WATCH2_GR_PRE2PM_PRE2ROP_ROP_REQ_WORD    0
#define NV_PPM_NV_WATCH2_GR_PRE2PM_PRE2ROP_ROP_REQ_HIGH_FIELD 0x0000000D /* =13 */
#define NV_PPM_NV_WATCH2_GR_PRE2PM_PRE2ROP_ROP_REQ_LOW_FIELD 0x0000000D /* =13 */
#define NV_PPM_NV_WATCH2_GR_PRE2PM_PRE2ROP_POSTING_BUFFER_MSK 0x00004000 /* 14:14 */ 
#define NV_PPM_NV_WATCH2_GR_PRE2PM_PRE2ROP_POSTING_BUFFER_RMSK 0x00000001 /* 14:14 */ 
#define NV_PPM_NV_WATCH2_GR_PRE2PM_PRE2ROP_POSTING_BUFFER_WORD 0
#define NV_PPM_NV_WATCH2_GR_PRE2PM_PRE2ROP_POSTING_BUFFER_HIGH_FIELD 0x0000000E /* =14 */
#define NV_PPM_NV_WATCH2_GR_PRE2PM_PRE2ROP_POSTING_BUFFER_LOW_FIELD 0x0000000E /* =14 */
#define NV_PPM_NV_WATCH2_GR_PRE2PM_PRE2R2D_OUTPUT_BUSY_MSK 0x00008000 /* 15:15 */ 
#define NV_PPM_NV_WATCH2_GR_PRE2PM_PRE2R2D_OUTPUT_BUSY_RMSK 0x00000001 /* 15:15 */ 
#define NV_PPM_NV_WATCH2_GR_PRE2PM_PRE2R2D_OUTPUT_BUSY_WORD 0
#define NV_PPM_NV_WATCH2_GR_PRE2PM_PRE2R2D_OUTPUT_BUSY_HIGH_FIELD 0x0000000F /* =15 */
#define NV_PPM_NV_WATCH2_GR_PRE2PM_PRE2R2D_OUTPUT_BUSY_LOW_FIELD 0x0000000F /* =15 */
#define NV_PPM_NV_WATCH2_GR_PRE2PM_PRE2PIPE_BUSY_MSK       0x00010000 /* 16:16 */ 
#define NV_PPM_NV_WATCH2_GR_PRE2PM_PRE2PIPE_BUSY_RMSK      0x00000001 /* 16:16 */ 
#define NV_PPM_NV_WATCH2_GR_PRE2PM_PRE2PIPE_BUSY_WORD      0
#define NV_PPM_NV_WATCH2_GR_PRE2PM_PRE2PIPE_BUSY_HIGH_FIELD 0x00000010 /* =16 */
#define NV_PPM_NV_WATCH2_GR_PRE2PM_PRE2PIPE_BUSY_LOW_FIELD 0x00000010 /* =16 */
#define NV_PPM_NV_WATCH2_GR_PRE2PM_PRE2LIT_BUSY_MSK        0x00020000 /* 17:17 */ 
#define NV_PPM_NV_WATCH2_GR_PRE2PM_PRE2LIT_BUSY_RMSK       0x00000001 /* 17:17 */ 
#define NV_PPM_NV_WATCH2_GR_PRE2PM_PRE2LIT_BUSY_WORD       0
#define NV_PPM_NV_WATCH2_GR_PRE2PM_PRE2LIT_BUSY_HIGH_FIELD 0x00000011 /* =17 */
#define NV_PPM_NV_WATCH2_GR_PRE2PM_PRE2LIT_BUSY_LOW_FIELD  0x00000011 /* =17 */
#define NV_PPM_NV_WATCH2_GR_PRE2PM_COALESCE_MSK            0x00040000 /* 18:18 */ 
#define NV_PPM_NV_WATCH2_GR_PRE2PM_COALESCE_RMSK           0x00000001 /* 18:18 */ 
#define NV_PPM_NV_WATCH2_GR_PRE2PM_COALESCE_WORD           0
#define NV_PPM_NV_WATCH2_GR_PRE2PM_COALESCE_HIGH_FIELD     0x00000012 /* =18 */
#define NV_PPM_NV_WATCH2_GR_PRE2PM_COALESCE_LOW_FIELD      0x00000012 /* =18 */
#define NV_PPM_NV_WATCH2_GR_PRE2PM_ALL3D_REQ_MSK           0x00080000 /* 19:19 */ 
#define NV_PPM_NV_WATCH2_GR_PRE2PM_ALL3D_REQ_RMSK          0x00000001 /* 19:19 */ 
#define NV_PPM_NV_WATCH2_GR_PRE2PM_ALL3D_REQ_WORD          0
#define NV_PPM_NV_WATCH2_GR_PRE2PM_ALL3D_REQ_HIGH_FIELD    0x00000013 /* =19 */
#define NV_PPM_NV_WATCH2_GR_PRE2PM_ALL3D_REQ_LOW_FIELD     0x00000013 /* =19 */
#define NV_PPM_NV_WATCH2_GR_PIPE2PM_PIPE_XY_RDY_MSK        0x00100000 /* 20:20 */ 
#define NV_PPM_NV_WATCH2_GR_PIPE2PM_PIPE_XY_RDY_RMSK       0x00000001 /* 20:20 */ 
#define NV_PPM_NV_WATCH2_GR_PIPE2PM_PIPE_XY_RDY_WORD       0
#define NV_PPM_NV_WATCH2_GR_PIPE2PM_PIPE_XY_RDY_HIGH_FIELD 0x00000014 /* =20 */
#define NV_PPM_NV_WATCH2_GR_PIPE2PM_PIPE_XY_RDY_LOW_FIELD  0x00000014 /* =20 */
#define NV_PPM_NV_WATCH2_GR_PIPE2PM_PIPE_IDLE_MSK          0x00200000 /* 21:21 */ 
#define NV_PPM_NV_WATCH2_GR_PIPE2PM_PIPE_IDLE_RMSK         0x00000001 /* 21:21 */ 
#define NV_PPM_NV_WATCH2_GR_PIPE2PM_PIPE_IDLE_WORD         0
#define NV_PPM_NV_WATCH2_GR_PIPE2PM_PIPE_IDLE_HIGH_FIELD   0x00000015 /* =21 */
#define NV_PPM_NV_WATCH2_GR_PIPE2PM_PIPE_IDLE_LOW_FIELD    0x00000015 /* =21 */
#define NV_PPM_NV_WATCH2_GR_MATH2PM_MATH2TEX_TP1_REQ_MSK   0x00400000 /* 22:22 */ 
#define NV_PPM_NV_WATCH2_GR_MATH2PM_MATH2TEX_TP1_REQ_RMSK  0x00000001 /* 22:22 */ 
#define NV_PPM_NV_WATCH2_GR_MATH2PM_MATH2TEX_TP1_REQ_WORD  0
#define NV_PPM_NV_WATCH2_GR_MATH2PM_MATH2TEX_TP1_REQ_HIGH_FIELD 0x00000016 /* =22 */
#define NV_PPM_NV_WATCH2_GR_MATH2PM_MATH2TEX_TP1_REQ_LOW_FIELD 0x00000016 /* =22 */
#define NV_PPM_NV_WATCH2_GR_MATH2PM_MATH2TEX_TP0_REQ_MSK   0x00800000 /* 23:23 */ 
#define NV_PPM_NV_WATCH2_GR_MATH2PM_MATH2TEX_TP0_REQ_RMSK  0x00000001 /* 23:23 */ 
#define NV_PPM_NV_WATCH2_GR_MATH2PM_MATH2TEX_TP0_REQ_WORD  0
#define NV_PPM_NV_WATCH2_GR_MATH2PM_MATH2TEX_TP0_REQ_HIGH_FIELD 0x00000017 /* =23 */
#define NV_PPM_NV_WATCH2_GR_MATH2PM_MATH2TEX_TP0_REQ_LOW_FIELD 0x00000017 /* =23 */
#define NV_PPM_NV_WATCH2_GR_MATH2PM_MATH2TEX_MAGNIFY_MSK   0x01000000 /* 24:24 */ 
#define NV_PPM_NV_WATCH2_GR_MATH2PM_MATH2TEX_MAGNIFY_RMSK  0x00000001 /* 24:24 */ 
#define NV_PPM_NV_WATCH2_GR_MATH2PM_MATH2TEX_MAGNIFY_WORD  0
#define NV_PPM_NV_WATCH2_GR_MATH2PM_MATH2TEX_MAGNIFY_HIGH_FIELD 0x00000018 /* =24 */
#define NV_PPM_NV_WATCH2_GR_MATH2PM_MATH2TEX_MAGNIFY_LOW_FIELD 0x00000018 /* =24 */
#define NV_PPM_NV_WATCH2_GR_MATH2PM_MATH2TEX_ANISO_SAMPLE_MSK 0x02000000 /* 25:25 */ 
#define NV_PPM_NV_WATCH2_GR_MATH2PM_MATH2TEX_ANISO_SAMPLE_RMSK 0x00000001 /* 25:25 */ 
#define NV_PPM_NV_WATCH2_GR_MATH2PM_MATH2TEX_ANISO_SAMPLE_WORD 0
#define NV_PPM_NV_WATCH2_GR_MATH2PM_MATH2TEX_ANISO_SAMPLE_HIGH_FIELD 0x00000019 /* =25 */
#define NV_PPM_NV_WATCH2_GR_MATH2PM_MATH2TEX_ANISO_SAMPLE_LOW_FIELD 0x00000019 /* =25 */
#define NV_PPM_NV_WATCH2_GR_MATH2PM_MATH2RSTR_RDY_MSK      0x04000000 /* 26:26 */ 
#define NV_PPM_NV_WATCH2_GR_MATH2PM_MATH2RSTR_RDY_RMSK     0x00000001 /* 26:26 */ 
#define NV_PPM_NV_WATCH2_GR_MATH2PM_MATH2RSTR_RDY_WORD     0
#define NV_PPM_NV_WATCH2_GR_MATH2PM_MATH2RSTR_RDY_HIGH_FIELD 0x0000001A /* =26 */
#define NV_PPM_NV_WATCH2_GR_MATH2PM_MATH2RSTR_RDY_LOW_FIELD 0x0000001A /* =26 */
#define NV_PPM_NV_WATCH2_GR_MATH2PM_MATH2RSTR_ABC_RDY_MSK  0x08000000 /* 27:27 */ 
#define NV_PPM_NV_WATCH2_GR_MATH2PM_MATH2RSTR_ABC_RDY_RMSK 0x00000001 /* 27:27 */ 
#define NV_PPM_NV_WATCH2_GR_MATH2PM_MATH2RSTR_ABC_RDY_WORD 0
#define NV_PPM_NV_WATCH2_GR_MATH2PM_MATH2RSTR_ABC_RDY_HIGH_FIELD 0x0000001B /* =27 */
#define NV_PPM_NV_WATCH2_GR_MATH2PM_MATH2RSTR_ABC_RDY_LOW_FIELD 0x0000001B /* =27 */
#define NV_PPM_NV_WATCH2_GR_LIT2PM_RECIRC_CYCLE_MSK        0x10000000 /* 28:28 */ 
#define NV_PPM_NV_WATCH2_GR_LIT2PM_RECIRC_CYCLE_RMSK       0x00000001 /* 28:28 */ 
#define NV_PPM_NV_WATCH2_GR_LIT2PM_RECIRC_CYCLE_WORD       0
#define NV_PPM_NV_WATCH2_GR_LIT2PM_RECIRC_CYCLE_HIGH_FIELD 0x0000001C /* =28 */
#define NV_PPM_NV_WATCH2_GR_LIT2PM_RECIRC_CYCLE_LOW_FIELD  0x0000001C /* =28 */
#define NV_PPM_NV_WATCH2_GR_LIT2PM_LIT2TEX_BUSY_MSK        0x20000000 /* 29:29 */ 
#define NV_PPM_NV_WATCH2_GR_LIT2PM_LIT2TEX_BUSY_RMSK       0x00000001 /* 29:29 */ 
#define NV_PPM_NV_WATCH2_GR_LIT2PM_LIT2TEX_BUSY_WORD       0
#define NV_PPM_NV_WATCH2_GR_LIT2PM_LIT2TEX_BUSY_HIGH_FIELD 0x0000001D /* =29 */
#define NV_PPM_NV_WATCH2_GR_LIT2PM_LIT2TEX_BUSY_LOW_FIELD  0x0000001D /* =29 */
#define NV_PPM_NV_WATCH2_GR_LIT2PM_LIT2PRE_REQ_MSK         0x40000000 /* 30:30 */ 
#define NV_PPM_NV_WATCH2_GR_LIT2PM_LIT2PRE_REQ_RMSK        0x00000001 /* 30:30 */ 
#define NV_PPM_NV_WATCH2_GR_LIT2PM_LIT2PRE_REQ_WORD        0
#define NV_PPM_NV_WATCH2_GR_LIT2PM_LIT2PRE_REQ_HIGH_FIELD  0x0000001E /* =30 */
#define NV_PPM_NV_WATCH2_GR_LIT2PM_LIT2PRE_REQ_LOW_FIELD   0x0000001E /* =30 */
#define NV_PPM_NV_WATCH2_GR_LIT2PM_LIT2COL_BUSY_MSK        0x80000000 /* 31:31 */ 
#define NV_PPM_NV_WATCH2_GR_LIT2PM_LIT2COL_BUSY_RMSK       0x00000001 /* 31:31 */ 
#define NV_PPM_NV_WATCH2_GR_LIT2PM_LIT2COL_BUSY_WORD       0
#define NV_PPM_NV_WATCH2_GR_LIT2PM_LIT2COL_BUSY_HIGH_FIELD 0x0000001F /* =31 */
#define NV_PPM_NV_WATCH2_GR_LIT2PM_LIT2COL_BUSY_LOW_FIELD  0x0000001F /* =31 */
#define NV_PPM_NV_WATCH2_MSK                               0xFFFFFFFF 
#define NV_PPM_NV_WATCH3_GR_IDX2PM_THREADSTALLED_MSK       0x00000001 /* 0:0 */ 
#define NV_PPM_NV_WATCH3_GR_IDX2PM_THREADSTALLED_RMSK      0x00000001 /* 0:0 */ 
#define NV_PPM_NV_WATCH3_GR_IDX2PM_THREADSTALLED_WORD      0
#define NV_PPM_NV_WATCH3_GR_IDX2PM_THREADSTALLED_HIGH_FIELD 0x00000000 /* =0 */
#define NV_PPM_NV_WATCH3_GR_IDX2PM_THREADSTALLED_LOW_FIELD 0x00000000 /* =0 */
#define NV_PPM_NV_WATCH3_GR_IDX2PM_PTEBUSY_MSK             0x00000003 /* 1:0 */ 
#define NV_PPM_NV_WATCH3_GR_IDX2PM_PTEBUSY_RMSK            0x00000003 /* 1:0 */ 
#define NV_PPM_NV_WATCH3_GR_IDX2PM_PTEBUSY_WORD            0
#define NV_PPM_NV_WATCH3_GR_IDX2PM_PTEBUSY_HIGH_FIELD      0x00000001 /* =1 */
#define NV_PPM_NV_WATCH3_GR_IDX2PM_PTEBUSY_LOW_FIELD       0x00000000 /* =0 */
#define NV_PPM_NV_WATCH3_GR_IDX2PM_INTALIGN_MSK            0x00000007 /* 2:0 */ 
#define NV_PPM_NV_WATCH3_GR_IDX2PM_INTALIGN_RMSK           0x00000007 /* 2:0 */ 
#define NV_PPM_NV_WATCH3_GR_IDX2PM_INTALIGN_WORD           0
#define NV_PPM_NV_WATCH3_GR_IDX2PM_INTALIGN_HIGH_FIELD     0x00000002 /* =2 */
#define NV_PPM_NV_WATCH3_GR_IDX2PM_INTALIGN_LOW_FIELD      0x00000000 /* =0 */
#define NV_PPM_NV_WATCH3_GR_IDX2PM_IDXFRONTIDLE_MSK        0x0000000F /* 3:0 */ 
#define NV_PPM_NV_WATCH3_GR_IDX2PM_IDXFRONTIDLE_RMSK       0x0000000F /* 3:0 */ 
#define NV_PPM_NV_WATCH3_GR_IDX2PM_IDXFRONTIDLE_WORD       0
#define NV_PPM_NV_WATCH3_GR_IDX2PM_IDXFRONTIDLE_HIGH_FIELD 0x00000003 /* =3 */
#define NV_PPM_NV_WATCH3_GR_IDX2PM_IDXFRONTIDLE_LOW_FIELD  0x00000000 /* =0 */
#define NV_PPM_NV_WATCH3_GR_IDX2PM_IDX2XF_VALID_0_MSK      0x0000001F /* 4:0 */ 
#define NV_PPM_NV_WATCH3_GR_IDX2PM_IDX2XF_VALID_0_RMSK     0x0000001F /* 4:0 */ 
#define NV_PPM_NV_WATCH3_GR_IDX2PM_IDX2XF_VALID_0_WORD     0
#define NV_PPM_NV_WATCH3_GR_IDX2PM_IDX2XF_VALID_0_HIGH_FIELD 0x00000004 /* =4 */
#define NV_PPM_NV_WATCH3_GR_IDX2PM_IDX2XF_VALID_0_LOW_FIELD 0x00000000 /* =0 */
#define NV_PPM_NV_WATCH3_GR_IDX2PM_IDX2XF_VALID_1_MSK      0x0000003F /* 5:0 */ 
#define NV_PPM_NV_WATCH3_GR_IDX2PM_IDX2XF_VALID_1_RMSK     0x0000003F /* 5:0 */ 
#define NV_PPM_NV_WATCH3_GR_IDX2PM_IDX2XF_VALID_1_WORD     0
#define NV_PPM_NV_WATCH3_GR_IDX2PM_IDX2XF_VALID_1_HIGH_FIELD 0x00000005 /* =5 */
#define NV_PPM_NV_WATCH3_GR_IDX2PM_IDX2XF_VALID_1_LOW_FIELD 0x00000000 /* =0 */
#define NV_PPM_NV_WATCH3_GR_IDX2PM_IDX2VTX_VALID_MSK       0x0000007F /* 6:0 */ 
#define NV_PPM_NV_WATCH3_GR_IDX2PM_IDX2VTX_VALID_RMSK      0x0000007F /* 6:0 */ 
#define NV_PPM_NV_WATCH3_GR_IDX2PM_IDX2VTX_VALID_WORD      0
#define NV_PPM_NV_WATCH3_GR_IDX2PM_IDX2VTX_VALID_HIGH_FIELD 0x00000006 /* =6 */
#define NV_PPM_NV_WATCH3_GR_IDX2PM_IDX2VTX_VALID_LOW_FIELD 0x00000000 /* =0 */
#define NV_PPM_NV_WATCH3_GR_IDX2PM_IDX2PMI_VALID_MSK       0x000000FF /* 7:0 */ 
#define NV_PPM_NV_WATCH3_GR_IDX2PM_IDX2PMI_VALID_RMSK      0x000000FF /* 7:0 */ 
#define NV_PPM_NV_WATCH3_GR_IDX2PM_IDX2PMI_VALID_WORD      0
#define NV_PPM_NV_WATCH3_GR_IDX2PM_IDX2PMI_VALID_HIGH_FIELD 0x00000007 /* =7 */
#define NV_PPM_NV_WATCH3_GR_IDX2PM_IDX2PMI_VALID_LOW_FIELD 0x00000000 /* =0 */
#define NV_PPM_NV_WATCH3_GR_IDX2PM_IDX2FBI_VALID_MSK       0x000001FF /* 8:0 */ 
#define NV_PPM_NV_WATCH3_GR_IDX2PM_IDX2FBI_VALID_RMSK      0x000001FF /* 8:0 */ 
#define NV_PPM_NV_WATCH3_GR_IDX2PM_IDX2FBI_VALID_WORD      0
#define NV_PPM_NV_WATCH3_GR_IDX2PM_IDX2FBI_VALID_HIGH_FIELD 0x00000008 /* =8 */
#define NV_PPM_NV_WATCH3_GR_IDX2PM_IDX2FBI_VALID_LOW_FIELD 0x00000000 /* =0 */
#define NV_PPM_NV_WATCH3_GR_IDX2PM_IDX2DEC_BUSY_MSK        0x000003FF /* 9:0 */ 
#define NV_PPM_NV_WATCH3_GR_IDX2PM_IDX2DEC_BUSY_RMSK       0x000003FF /* 9:0 */ 
#define NV_PPM_NV_WATCH3_GR_IDX2PM_IDX2DEC_BUSY_WORD       0
#define NV_PPM_NV_WATCH3_GR_IDX2PM_IDX2DEC_BUSY_HIGH_FIELD 0x00000009 /* =9 */
#define NV_PPM_NV_WATCH3_GR_IDX2PM_IDX2DEC_BUSY_LOW_FIELD  0x00000000 /* =0 */
#define NV_PPM_NV_WATCH3_GR_IDX2PM_COMPOVFL_MSK            0x00000400 /* 10:10 */ 
#define NV_PPM_NV_WATCH3_GR_IDX2PM_COMPOVFL_RMSK           0x00000001 /* 10:10 */ 
#define NV_PPM_NV_WATCH3_GR_IDX2PM_COMPOVFL_WORD           0
#define NV_PPM_NV_WATCH3_GR_IDX2PM_COMPOVFL_HIGH_FIELD     0x0000000A /* =10 */
#define NV_PPM_NV_WATCH3_GR_IDX2PM_COMPOVFL_LOW_FIELD      0x0000000A /* =10 */
#define NV_PPM_NV_WATCH3_GR_IDX2PM_CACHETHRASH_MSK         0x00000800 /* 11:11 */ 
#define NV_PPM_NV_WATCH3_GR_IDX2PM_CACHETHRASH_RMSK        0x00000001 /* 11:11 */ 
#define NV_PPM_NV_WATCH3_GR_IDX2PM_CACHETHRASH_WORD        0
#define NV_PPM_NV_WATCH3_GR_IDX2PM_CACHETHRASH_HIGH_FIELD  0x0000000B /* =11 */
#define NV_PPM_NV_WATCH3_GR_IDX2PM_CACHETHRASH_LOW_FIELD   0x0000000B /* =11 */
#define NV_PPM_NV_WATCH3_GR_FF2PM_FF_GR_RDY_MSK            0x00001000 /* 12:12 */ 
#define NV_PPM_NV_WATCH3_GR_FF2PM_FF_GR_RDY_RMSK           0x00000001 /* 12:12 */ 
#define NV_PPM_NV_WATCH3_GR_FF2PM_FF_GR_RDY_WORD           0
#define NV_PPM_NV_WATCH3_GR_FF2PM_FF_GR_RDY_HIGH_FIELD     0x0000000C /* =12 */
#define NV_PPM_NV_WATCH3_GR_FF2PM_FF_GR_RDY_LOW_FIELD      0x0000000C /* =12 */
#define NV_PPM_NV_WATCH3_GR_FF2PM_FF_GR_B2B_MSK            0x00002000 /* 13:13 */ 
#define NV_PPM_NV_WATCH3_GR_FF2PM_FF_GR_B2B_RMSK           0x00000001 /* 13:13 */ 
#define NV_PPM_NV_WATCH3_GR_FF2PM_FF_GR_B2B_WORD           0
#define NV_PPM_NV_WATCH3_GR_FF2PM_FF_GR_B2B_HIGH_FIELD     0x0000000D /* =13 */
#define NV_PPM_NV_WATCH3_GR_FF2PM_FF_GR_B2B_LOW_FIELD      0x0000000D /* =13 */
#define NV_PPM_NV_WATCH3_GR_FE2PM_NVINTR_GR_MSK            0x00004000 /* 14:14 */ 
#define NV_PPM_NV_WATCH3_GR_FE2PM_NVINTR_GR_RMSK           0x00000001 /* 14:14 */ 
#define NV_PPM_NV_WATCH3_GR_FE2PM_NVINTR_GR_WORD           0
#define NV_PPM_NV_WATCH3_GR_FE2PM_NVINTR_GR_HIGH_FIELD     0x0000000E /* =14 */
#define NV_PPM_NV_WATCH3_GR_FE2PM_NVINTR_GR_LOW_FIELD      0x0000000E /* =14 */
#define NV_PPM_NV_WATCH3_GR_FE2PM_WAIT_GR_IDLE_MSK         0x00008000 /* 15:15 */ 
#define NV_PPM_NV_WATCH3_GR_FE2PM_WAIT_GR_IDLE_RMSK        0x00000001 /* 15:15 */ 
#define NV_PPM_NV_WATCH3_GR_FE2PM_WAIT_GR_IDLE_WORD        0
#define NV_PPM_NV_WATCH3_GR_FE2PM_WAIT_GR_IDLE_HIGH_FIELD  0x0000000F /* =15 */
#define NV_PPM_NV_WATCH3_GR_FE2PM_WAIT_GR_IDLE_LOW_FIELD   0x0000000F /* =15 */
#define NV_PPM_NV_WATCH3_GR_FE2PM_NOP_MSK                  0x00010000 /* 16:16 */ 
#define NV_PPM_NV_WATCH3_GR_FE2PM_NOP_RMSK                 0x00000001 /* 16:16 */ 
#define NV_PPM_NV_WATCH3_GR_FE2PM_NOP_WORD                 0
#define NV_PPM_NV_WATCH3_GR_FE2PM_NOP_HIGH_FIELD           0x00000010 /* =16 */
#define NV_PPM_NV_WATCH3_GR_FE2PM_NOP_LOW_FIELD            0x00000010 /* =16 */
#define NV_PPM_NV_WATCH3_GR_FE2PM_GR_SWITCH_MSK            0x00020000 /* 17:17 */ 
#define NV_PPM_NV_WATCH3_GR_FE2PM_GR_SWITCH_RMSK           0x00000001 /* 17:17 */ 
#define NV_PPM_NV_WATCH3_GR_FE2PM_GR_SWITCH_WORD           0
#define NV_PPM_NV_WATCH3_GR_FE2PM_GR_SWITCH_HIGH_FIELD     0x00000011 /* =17 */
#define NV_PPM_NV_WATCH3_GR_FE2PM_GR_SWITCH_LOW_FIELD      0x00000011 /* =17 */
#define NV_PPM_NV_WATCH3_GR_FE2PM_GR_IDLE_MSK              0x00040000 /* 18:18 */ 
#define NV_PPM_NV_WATCH3_GR_FE2PM_GR_IDLE_RMSK             0x00000001 /* 18:18 */ 
#define NV_PPM_NV_WATCH3_GR_FE2PM_GR_IDLE_WORD             0
#define NV_PPM_NV_WATCH3_GR_FE2PM_GR_IDLE_HIGH_FIELD       0x00000012 /* =18 */
#define NV_PPM_NV_WATCH3_GR_FE2PM_GR_IDLE_LOW_FIELD        0x00000012 /* =18 */
#define NV_PPM_NV_WATCH3_GR_FE2PM_FBI_REQ_BURST_MSK        0x00080000 /* 19:19 */ 
#define NV_PPM_NV_WATCH3_GR_FE2PM_FBI_REQ_BURST_RMSK       0x00000001 /* 19:19 */ 
#define NV_PPM_NV_WATCH3_GR_FE2PM_FBI_REQ_BURST_WORD       0
#define NV_PPM_NV_WATCH3_GR_FE2PM_FBI_REQ_BURST_HIGH_FIELD 0x00000013 /* =19 */
#define NV_PPM_NV_WATCH3_GR_FE2PM_FBI_REQ_BURST_LOW_FIELD  0x00000013 /* =19 */
#define NV_PPM_NV_WATCH3_GR_FE2PM_FBI_REQ_MSK              0x00100000 /* 20:20 */ 
#define NV_PPM_NV_WATCH3_GR_FE2PM_FBI_REQ_RMSK             0x00000001 /* 20:20 */ 
#define NV_PPM_NV_WATCH3_GR_FE2PM_FBI_REQ_WORD             0
#define NV_PPM_NV_WATCH3_GR_FE2PM_FBI_REQ_HIGH_FIELD       0x00000014 /* =20 */
#define NV_PPM_NV_WATCH3_GR_FE2PM_FBI_REQ_LOW_FIELD        0x00000014 /* =20 */
#define NV_PPM_NV_WATCH3_GR_FE2PM_FBI_RD_MSK               0x00200000 /* 21:21 */ 
#define NV_PPM_NV_WATCH3_GR_FE2PM_FBI_RD_RMSK              0x00000001 /* 21:21 */ 
#define NV_PPM_NV_WATCH3_GR_FE2PM_FBI_RD_WORD              0
#define NV_PPM_NV_WATCH3_GR_FE2PM_FBI_RD_HIGH_FIELD        0x00000015 /* =21 */
#define NV_PPM_NV_WATCH3_GR_FE2PM_FBI_RD_LOW_FIELD         0x00000015 /* =21 */
#define NV_PPM_NV_WATCH3_GR_FE2PM_FBI_INST_MSK             0x00400000 /* 22:22 */ 
#define NV_PPM_NV_WATCH3_GR_FE2PM_FBI_INST_RMSK            0x00000001 /* 22:22 */ 
#define NV_PPM_NV_WATCH3_GR_FE2PM_FBI_INST_WORD            0
#define NV_PPM_NV_WATCH3_GR_FE2PM_FBI_INST_HIGH_FIELD      0x00000016 /* =22 */
#define NV_PPM_NV_WATCH3_GR_FE2PM_FBI_INST_LOW_FIELD       0x00000016 /* =22 */
#define NV_PPM_NV_WATCH3_GR_FE2PM_CACHE_INVALIDATE_MSK     0x00800000 /* 23:23 */ 
#define NV_PPM_NV_WATCH3_GR_FE2PM_CACHE_INVALIDATE_RMSK    0x00000001 /* 23:23 */ 
#define NV_PPM_NV_WATCH3_GR_FE2PM_CACHE_INVALIDATE_WORD    0
#define NV_PPM_NV_WATCH3_GR_FE2PM_CACHE_INVALIDATE_HIGH_FIELD 0x00000017 /* =23 */
#define NV_PPM_NV_WATCH3_GR_FE2PM_CACHE_INVALIDATE_LOW_FIELD 0x00000017 /* =23 */
#define NV_PPM_NV_WATCH3_GR_FBI2PM_FBI2IDX_BUSY_MSK        0x01000000 /* 24:24 */ 
#define NV_PPM_NV_WATCH3_GR_FBI2PM_FBI2IDX_BUSY_RMSK       0x00000001 /* 24:24 */ 
#define NV_PPM_NV_WATCH3_GR_FBI2PM_FBI2IDX_BUSY_WORD       0
#define NV_PPM_NV_WATCH3_GR_FBI2PM_FBI2IDX_BUSY_HIGH_FIELD 0x00000018 /* =24 */
#define NV_PPM_NV_WATCH3_GR_FBI2PM_FBI2IDX_BUSY_LOW_FIELD  0x00000018 /* =24 */
#define NV_PPM_NV_WATCH3_GR_DMA2PM_DMA2C_DV_MSK            0x02000000 /* 25:25 */ 
#define NV_PPM_NV_WATCH3_GR_DMA2PM_DMA2C_DV_RMSK           0x00000001 /* 25:25 */ 
#define NV_PPM_NV_WATCH3_GR_DMA2PM_DMA2C_DV_WORD           0
#define NV_PPM_NV_WATCH3_GR_DMA2PM_DMA2C_DV_HIGH_FIELD     0x00000019 /* =25 */
#define NV_PPM_NV_WATCH3_GR_DMA2PM_DMA2C_DV_LOW_FIELD      0x00000019 /* =25 */
#define NV_PPM_NV_WATCH3_GR_DMA2PM_DMA2C_ASTALL_MSK        0x04000000 /* 26:26 */ 
#define NV_PPM_NV_WATCH3_GR_DMA2PM_DMA2C_ASTALL_RMSK       0x00000001 /* 26:26 */ 
#define NV_PPM_NV_WATCH3_GR_DMA2PM_DMA2C_ASTALL_WORD       0
#define NV_PPM_NV_WATCH3_GR_DMA2PM_DMA2C_ASTALL_HIGH_FIELD 0x0000001A /* =26 */
#define NV_PPM_NV_WATCH3_GR_DMA2PM_DMA2C_ASTALL_LOW_FIELD  0x0000001A /* =26 */
#define NV_PPM_NV_WATCH3_GR_DEC2PM_DEC2IDX_VALID_0_MSK     0x08000000 /* 27:27 */ 
#define NV_PPM_NV_WATCH3_GR_DEC2PM_DEC2IDX_VALID_0_RMSK    0x00000001 /* 27:27 */ 
#define NV_PPM_NV_WATCH3_GR_DEC2PM_DEC2IDX_VALID_0_WORD    0
#define NV_PPM_NV_WATCH3_GR_DEC2PM_DEC2IDX_VALID_0_HIGH_FIELD 0x0000001B /* =27 */
#define NV_PPM_NV_WATCH3_GR_DEC2PM_DEC2IDX_VALID_0_LOW_FIELD 0x0000001B /* =27 */
#define NV_PPM_NV_WATCH3_GR_DEC2PM_DEC2IDX_VALID_1_MSK     0x10000000 /* 28:28 */ 
#define NV_PPM_NV_WATCH3_GR_DEC2PM_DEC2IDX_VALID_1_RMSK    0x00000001 /* 28:28 */ 
#define NV_PPM_NV_WATCH3_GR_DEC2PM_DEC2IDX_VALID_1_WORD    0
#define NV_PPM_NV_WATCH3_GR_DEC2PM_DEC2IDX_VALID_1_HIGH_FIELD 0x0000001C /* =28 */
#define NV_PPM_NV_WATCH3_GR_DEC2PM_DEC2IDX_VALID_1_LOW_FIELD 0x0000001C /* =28 */
#define NV_PPM_NV_WATCH3_GR_COL2PM_SPECULAR_RECIRC_MSK     0x20000000 /* 29:29 */ 
#define NV_PPM_NV_WATCH3_GR_COL2PM_SPECULAR_RECIRC_RMSK    0x00000001 /* 29:29 */ 
#define NV_PPM_NV_WATCH3_GR_COL2PM_SPECULAR_RECIRC_WORD    0
#define NV_PPM_NV_WATCH3_GR_COL2PM_SPECULAR_RECIRC_HIGH_FIELD 0x0000001D /* =29 */
#define NV_PPM_NV_WATCH3_GR_COL2PM_SPECULAR_RECIRC_LOW_FIELD 0x0000001D /* =29 */
#define NV_PPM_NV_WATCH3_GR_COL2PM_COLOR_IDLE_MSK          0x40000000 /* 30:30 */ 
#define NV_PPM_NV_WATCH3_GR_COL2PM_COLOR_IDLE_RMSK         0x00000001 /* 30:30 */ 
#define NV_PPM_NV_WATCH3_GR_COL2PM_COLOR_IDLE_WORD         0
#define NV_PPM_NV_WATCH3_GR_COL2PM_COLOR_IDLE_HIGH_FIELD   0x0000001E /* =30 */
#define NV_PPM_NV_WATCH3_GR_COL2PM_COLOR_IDLE_LOW_FIELD    0x0000001E /* =30 */
#define NV_PPM_NV_WATCH3_GR_COL2PM_COL2XYPIPE_BUSY_MSK     0x80000000 /* 31:31 */ 
#define NV_PPM_NV_WATCH3_GR_COL2PM_COL2XYPIPE_BUSY_RMSK    0x00000001 /* 31:31 */ 
#define NV_PPM_NV_WATCH3_GR_COL2PM_COL2XYPIPE_BUSY_WORD    0
#define NV_PPM_NV_WATCH3_GR_COL2PM_COL2XYPIPE_BUSY_HIGH_FIELD 0x0000001F /* =31 */
#define NV_PPM_NV_WATCH3_GR_COL2PM_COL2XYPIPE_BUSY_LOW_FIELD 0x0000001F /* =31 */
#define NV_PPM_NV_WATCH3_MSK                               0xFFFFFFFF 
#define NV_PPM_NV_WATCH4_GR_COL2PM_COL2VTX_BUSY_MSK        0x00000001 /* 0:0 */ 
#define NV_PPM_NV_WATCH4_GR_COL2PM_COL2VTX_BUSY_RMSK       0x00000001 /* 0:0 */ 
#define NV_PPM_NV_WATCH4_GR_COL2PM_COL2VTX_BUSY_WORD       0
#define NV_PPM_NV_WATCH4_GR_COL2PM_COL2VTX_BUSY_HIGH_FIELD 0x00000000 /* =0 */
#define NV_PPM_NV_WATCH4_GR_COL2PM_COL2VTX_BUSY_LOW_FIELD  0x00000000 /* =0 */
#define NV_PPM_NV_WATCH4_GR_COL2PM_COL2LIT_REQ_MSK         0x00000003 /* 1:0 */ 
#define NV_PPM_NV_WATCH4_GR_COL2PM_COL2LIT_REQ_RMSK        0x00000003 /* 1:0 */ 
#define NV_PPM_NV_WATCH4_GR_COL2PM_COL2LIT_REQ_WORD        0
#define NV_PPM_NV_WATCH4_GR_COL2PM_COL2LIT_REQ_HIGH_FIELD  0x00000001 /* =1 */
#define NV_PPM_NV_WATCH4_GR_COL2PM_COL2LIT_REQ_LOW_FIELD   0x00000000 /* =0 */
#define NV_PPM_NV_WATCH4_GR_COL2PM_COL2FCOMB_REQ_MSK       0x00000007 /* 2:0 */ 
#define NV_PPM_NV_WATCH4_GR_COL2PM_COL2FCOMB_REQ_RMSK      0x00000007 /* 2:0 */ 
#define NV_PPM_NV_WATCH4_GR_COL2PM_COL2FCOMB_REQ_WORD      0
#define NV_PPM_NV_WATCH4_GR_COL2PM_COL2FCOMB_REQ_HIGH_FIELD 0x00000002 /* =2 */
#define NV_PPM_NV_WATCH4_GR_COL2PM_COL2FCOMB_REQ_LOW_FIELD 0x00000000 /* =0 */
#define NV_PPM_NV_WATCH4_GR_COL2PM_COL2CLP_BUSY_MSK        0x0000000F /* 3:0 */ 
#define NV_PPM_NV_WATCH4_GR_COL2PM_COL2CLP_BUSY_RMSK       0x0000000F /* 3:0 */ 
#define NV_PPM_NV_WATCH4_GR_COL2PM_COL2CLP_BUSY_WORD       0
#define NV_PPM_NV_WATCH4_GR_COL2PM_COL2CLP_BUSY_HIGH_FIELD 0x00000003 /* =3 */
#define NV_PPM_NV_WATCH4_GR_COL2PM_COL2CLP_BUSY_LOW_FIELD  0x00000000 /* =0 */
#define NV_PPM_NV_WATCH4_GR_CLP2PM_CLP2STP_BUSY_MSK        0x0000001F /* 4:0 */ 
#define NV_PPM_NV_WATCH4_GR_CLP2PM_CLP2STP_BUSY_RMSK       0x0000001F /* 4:0 */ 
#define NV_PPM_NV_WATCH4_GR_CLP2PM_CLP2STP_BUSY_WORD       0
#define NV_PPM_NV_WATCH4_GR_CLP2PM_CLP2STP_BUSY_HIGH_FIELD 0x00000004 /* =4 */
#define NV_PPM_NV_WATCH4_GR_CLP2PM_CLP2STP_BUSY_LOW_FIELD  0x00000000 /* =0 */
#define NV_PPM_NV_WATCH4_TOP_PMI2PM_PMI2IDX_VALID_MSK      0x0000003F /* 5:0 */ 
#define NV_PPM_NV_WATCH4_TOP_PMI2PM_PMI2IDX_VALID_RMSK     0x0000003F /* 5:0 */ 
#define NV_PPM_NV_WATCH4_TOP_PMI2PM_PMI2IDX_VALID_WORD     0
#define NV_PPM_NV_WATCH4_TOP_PMI2PM_PMI2IDX_VALID_HIGH_FIELD 0x00000005 /* =5 */
#define NV_PPM_NV_WATCH4_TOP_PMI2PM_PMI2IDX_VALID_LOW_FIELD 0x00000000 /* =0 */
#define NV_PPM_NV_WATCH4_TOP_PMI2PM_PMI2IDX_BUSY_MSK       0x0000007F /* 6:0 */ 
#define NV_PPM_NV_WATCH4_TOP_PMI2PM_PMI2IDX_BUSY_RMSK      0x0000007F /* 6:0 */ 
#define NV_PPM_NV_WATCH4_TOP_PMI2PM_PMI2IDX_BUSY_WORD      0
#define NV_PPM_NV_WATCH4_TOP_PMI2PM_PMI2IDX_BUSY_HIGH_FIELD 0x00000006 /* =6 */
#define NV_PPM_NV_WATCH4_TOP_PMI2PM_PMI2IDX_BUSY_LOW_FIELD 0x00000000 /* =0 */
#define NV_PPM_NV_WATCH4_TOP_HOST2PM_TIMER_262US_MSK       0x000000FF /* 7:0 */ 
#define NV_PPM_NV_WATCH4_TOP_HOST2PM_TIMER_262US_RMSK      0x000000FF /* 7:0 */ 
#define NV_PPM_NV_WATCH4_TOP_HOST2PM_TIMER_262US_WORD      0
#define NV_PPM_NV_WATCH4_TOP_HOST2PM_TIMER_262US_HIGH_FIELD 0x00000007 /* =7 */
#define NV_PPM_NV_WATCH4_TOP_HOST2PM_TIMER_262US_LOW_FIELD 0x00000000 /* =0 */
#define NV_PPM_NV_WATCH4_TOP_HOST2PM_FF_GR_MDV_MSK         0x000001FF /* 8:0 */ 
#define NV_PPM_NV_WATCH4_TOP_HOST2PM_FF_GR_MDV_RMSK        0x000001FF /* 8:0 */ 
#define NV_PPM_NV_WATCH4_TOP_HOST2PM_FF_GR_MDV_WORD        0
#define NV_PPM_NV_WATCH4_TOP_HOST2PM_FF_GR_MDV_HIGH_FIELD  0x00000008 /* =8 */
#define NV_PPM_NV_WATCH4_TOP_HOST2PM_FF_GR_MDV_LOW_FIELD   0x00000000 /* =0 */
#define NV_PPM_NV_WATCH4_TOP_HOST2PM_FF_DHV_MSK            0x000003FF /* 9:0 */ 
#define NV_PPM_NV_WATCH4_TOP_HOST2PM_FF_DHV_RMSK           0x000003FF /* 9:0 */ 
#define NV_PPM_NV_WATCH4_TOP_HOST2PM_FF_DHV_WORD           0
#define NV_PPM_NV_WATCH4_TOP_HOST2PM_FF_DHV_HIGH_FIELD     0x00000009 /* =9 */
#define NV_PPM_NV_WATCH4_TOP_HOST2PM_FF_DHV_LOW_FIELD      0x00000000 /* =0 */
#define NV_PPM_NV_WATCH4_TOP_HOST2PM_FF_CHSW_MSK           0x00000400 /* 10:10 */ 
#define NV_PPM_NV_WATCH4_TOP_HOST2PM_FF_CHSW_RMSK          0x00000001 /* 10:10 */ 
#define NV_PPM_NV_WATCH4_TOP_HOST2PM_FF_CHSW_WORD          0
#define NV_PPM_NV_WATCH4_TOP_HOST2PM_FF_CHSW_HIGH_FIELD    0x0000000A /* =10 */
#define NV_PPM_NV_WATCH4_TOP_HOST2PM_FF_CHSW_LOW_FIELD     0x0000000A /* =10 */
#define NV_PPM_NV_WATCH4_TOP_FBI2PM_X_DLY_MSK              0x00000800 /* 11:11 */ 
#define NV_PPM_NV_WATCH4_TOP_FBI2PM_X_DLY_RMSK             0x00000001 /* 11:11 */ 
#define NV_PPM_NV_WATCH4_TOP_FBI2PM_X_DLY_WORD             0
#define NV_PPM_NV_WATCH4_TOP_FBI2PM_X_DLY_HIGH_FIELD       0x0000000B /* =11 */
#define NV_PPM_NV_WATCH4_TOP_FBI2PM_X_DLY_LOW_FIELD        0x0000000B /* =11 */
#define NV_PPM_NV_WATCH4_TOP_FBI2PM_S_DLY_MSK              0x00001000 /* 12:12 */ 
#define NV_PPM_NV_WATCH4_TOP_FBI2PM_S_DLY_RMSK             0x00000001 /* 12:12 */ 
#define NV_PPM_NV_WATCH4_TOP_FBI2PM_S_DLY_WORD             0
#define NV_PPM_NV_WATCH4_TOP_FBI2PM_S_DLY_HIGH_FIELD       0x0000000C /* =12 */
#define NV_PPM_NV_WATCH4_TOP_FBI2PM_S_DLY_LOW_FIELD        0x0000000C /* =12 */
#define NV_PPM_NV_WATCH4_TOP_FBI2PM_R2W_DLY_MSK            0x00002000 /* 13:13 */ 
#define NV_PPM_NV_WATCH4_TOP_FBI2PM_R2W_DLY_RMSK           0x00000001 /* 13:13 */ 
#define NV_PPM_NV_WATCH4_TOP_FBI2PM_R2W_DLY_WORD           0
#define NV_PPM_NV_WATCH4_TOP_FBI2PM_R2W_DLY_HIGH_FIELD     0x0000000D /* =13 */
#define NV_PPM_NV_WATCH4_TOP_FBI2PM_R2W_DLY_LOW_FIELD      0x0000000D /* =13 */
#define NV_PPM_NV_WATCH4_TOP_FBI2PM_H_DLY_MSK              0x00004000 /* 14:14 */ 
#define NV_PPM_NV_WATCH4_TOP_FBI2PM_H_DLY_RMSK             0x00000001 /* 14:14 */ 
#define NV_PPM_NV_WATCH4_TOP_FBI2PM_H_DLY_WORD             0
#define NV_PPM_NV_WATCH4_TOP_FBI2PM_H_DLY_HIGH_FIELD       0x0000000E /* =14 */
#define NV_PPM_NV_WATCH4_TOP_FBI2PM_H_DLY_LOW_FIELD        0x0000000E /* =14 */
#define NV_PPM_NV_WATCH4_TOP_FB2PM_FB2ROP_BUSY_MSK         0x00008000 /* 15:15 */ 
#define NV_PPM_NV_WATCH4_TOP_FB2PM_FB2ROP_BUSY_RMSK        0x00000001 /* 15:15 */ 
#define NV_PPM_NV_WATCH4_TOP_FB2PM_FB2ROP_BUSY_WORD        0
#define NV_PPM_NV_WATCH4_TOP_FB2PM_FB2ROP_BUSY_HIGH_FIELD  0x0000000F /* =15 */
#define NV_PPM_NV_WATCH4_TOP_FB2PM_FB2ROP_BUSY_LOW_FIELD   0x0000000F /* =15 */
#define NV_PPM_NV_WATCH4_TOP_FBI2PM_D_DLY_MSK              0x00010000 /* 16:16 */ 
#define NV_PPM_NV_WATCH4_TOP_FBI2PM_D_DLY_RMSK             0x00000001 /* 16:16 */ 
#define NV_PPM_NV_WATCH4_TOP_FBI2PM_D_DLY_WORD             0
#define NV_PPM_NV_WATCH4_TOP_FBI2PM_D_DLY_HIGH_FIELD       0x00000010 /* =16 */
#define NV_PPM_NV_WATCH4_TOP_FBI2PM_D_DLY_LOW_FIELD        0x00000010 /* =16 */
#define NV_PPM_NV_WATCH4_TOP_FBI2PM_BC_MSK                 0x00020000 /* 17:17 */ 
#define NV_PPM_NV_WATCH4_TOP_FBI2PM_BC_RMSK                0x00000001 /* 17:17 */ 
#define NV_PPM_NV_WATCH4_TOP_FBI2PM_BC_WORD                0
#define NV_PPM_NV_WATCH4_TOP_FBI2PM_BC_HIGH_FIELD          0x00000011 /* =17 */
#define NV_PPM_NV_WATCH4_TOP_FBI2PM_BC_LOW_FIELD           0x00000011 /* =17 */
#define NV_PPM_NV_WATCH4_TOP_CRTC2PM_CRTC2DAC_VSYNC2DAC_MSK 0x00040000 /* 18:18 */ 
#define NV_PPM_NV_WATCH4_TOP_CRTC2PM_CRTC2DAC_VSYNC2DAC_RMSK 0x00000001 /* 18:18 */ 
#define NV_PPM_NV_WATCH4_TOP_CRTC2PM_CRTC2DAC_VSYNC2DAC_WORD 0
#define NV_PPM_NV_WATCH4_TOP_CRTC2PM_CRTC2DAC_VSYNC2DAC_HIGH_FIELD 0x00000012 /* =18 */
#define NV_PPM_NV_WATCH4_TOP_CRTC2PM_CRTC2DAC_VSYNC2DAC_LOW_FIELD 0x00000012 /* =18 */
#define NV_PPM_NV_WATCH4_MSK                               0x0007FFFF 
#define NV_PPM_CONTROL_OUT_SEL_MSK                         0x00000001 /* 0:0 */ 
#define NV_PPM_CONTROL_OUT_SEL_RMSK                        0x00000001 /* 0:0 */ 
#define NV_PPM_CONTROL_OUT_SEL_WORD                        0
#define NV_PPM_CONTROL_OUT_SEL_HIGH_FIELD                  0x00000000 /* =0 */
#define NV_PPM_CONTROL_OUT_SEL_LOW_FIELD                   0x00000000 /* =0 */
#define NV_PPM_CONTROL_OUT_SEL_PM_ADJ                      0x00000000
#define NV_PPM_CONTROL_OUT_SEL_FBIDEBUG_ADJ                0x00000001
#define NV_PPM_CONTROL_DRIVE_OUT_MSK                       0x00000002 /* 1:1 */ 
#define NV_PPM_CONTROL_DRIVE_OUT_RMSK                      0x00000001 /* 1:1 */ 
#define NV_PPM_CONTROL_DRIVE_OUT_WORD                      0
#define NV_PPM_CONTROL_DRIVE_OUT_HIGH_FIELD                0x00000001 /* =1 */
#define NV_PPM_CONTROL_DRIVE_OUT_LOW_FIELD                 0x00000001 /* =1 */
#define NV_PPM_CONTROL_DRIVE_OUT_NORMAL_ADJ                0x00000000
#define NV_PPM_CONTROL_DRIVE_OUT_OBSERVE_ADJ               0x00000002
#define NV_PPM_CONTROL_NV_ADDTOEVENT_MSK                   0x00000004 /* 2:2 */ 
#define NV_PPM_CONTROL_NV_ADDTOEVENT_RMSK                  0x00000001 /* 2:2 */ 
#define NV_PPM_CONTROL_NV_ADDTOEVENT_WORD                  0
#define NV_PPM_CONTROL_NV_ADDTOEVENT_HIGH_FIELD            0x00000002 /* =2 */
#define NV_PPM_CONTROL_NV_ADDTOEVENT_LOW_FIELD             0x00000002 /* =2 */
#define NV_PPM_CONTROL_NV_ADDTOEVENT_INCR_ADJ              0x00000000
#define NV_PPM_CONTROL_NV_ADDTOEVENT_ADDTRIG1_ADJ          0x00000004
#define NV_PPM_CONTROL_NV_STATE_MSK                        0x00000018 /* 4:3 */ 
#define NV_PPM_CONTROL_NV_STATE_RMSK                       0x00000003 /* 4:3 */ 
#define NV_PPM_CONTROL_NV_STATE_WORD                       0
#define NV_PPM_CONTROL_NV_STATE_HIGH_FIELD                 0x00000004 /* =4 */
#define NV_PPM_CONTROL_NV_STATE_LOW_FIELD                  0x00000003 /* =3 */
#define NV_PPM_CONTROL_NV_CLEAR_EVENT_ONCE_MSK             0x00000100 /* 8:8 */ 
#define NV_PPM_CONTROL_NV_CLEAR_EVENT_ONCE_RMSK            0x00000001 /* 8:8 */ 
#define NV_PPM_CONTROL_NV_CLEAR_EVENT_ONCE_WORD            0
#define NV_PPM_CONTROL_NV_CLEAR_EVENT_ONCE_HIGH_FIELD      0x00000008 /* =8 */
#define NV_PPM_CONTROL_NV_CLEAR_EVENT_ONCE_LOW_FIELD       0x00000008 /* =8 */
#define NV_PPM_CONTROL_NV_CLEAR_EVENT_ONCE_DISABLE_ADJ     0x00000000
#define NV_PPM_CONTROL_NV_CLEAR_EVENT_ONCE_ENABLE_ADJ      0x00000100
#define NV_PPM_CONTROL_MSK                                 0x0000011F 
#define NV_PNVM_HIGH_FIELD                                 0x0FFFFFFF /* =268435455 */
#define NV_PNVM_LOW_FIELD                                  0x08000000 /* =134217728 */
#define NV_PNVM_DATA032_VALUE_MSK                          0xFFFFFFFF /* 31:0 */ 
#define NV_PNVM_DATA032_VALUE_RMSK                         0xFFFFFFFF /* 31:0 */ 
#define NV_PNVM_DATA032_VALUE_WORD                         0
#define NV_PNVM_DATA032_VALUE_HIGH_FIELD                   0x0000001F /* =31 */
#define NV_PNVM_DATA032_VALUE_LOW_FIELD                    0x00000000 /* =0 */
#define NV_PNVM_DATA032_MSK                                0xFFFFFFFF 
#define NV_PNVM_DATA016_VALUE_MSK                          0x0000FFFF /* 15:0 */ 
#define NV_PNVM_DATA016_VALUE_RMSK                         0x0000FFFF /* 15:0 */ 
#define NV_PNVM_DATA016_VALUE_WORD                         0
#define NV_PNVM_DATA016_VALUE_HIGH_FIELD                   0x0000000F /* =15 */
#define NV_PNVM_DATA016_VALUE_LOW_FIELD                    0x00000000 /* =0 */
#define NV_PNVM_DATA016_MSK                                0x0000FFFF 
#define NV_PNVM_DATA008_VALUE_MSK                          0x000000FF /* 7:0 */ 
#define NV_PNVM_DATA008_VALUE_RMSK                         0x000000FF /* 7:0 */ 
#define NV_PNVM_DATA008_VALUE_WORD                         0
#define NV_PNVM_DATA008_VALUE_HIGH_FIELD                   0x00000007 /* =7 */
#define NV_PNVM_DATA008_VALUE_LOW_FIELD                    0x00000000 /* =0 */
#define NV_PNVM_DATA008_MSK                                0x000000FF 
#define NV_PDFB_HIGH_FIELD                                 0x0FFFFFFF /* =268435455 */
#define NV_PDFB_LOW_FIELD                                  0x08000000 /* =134217728 */
#define NV_PRAMIN_HIGH_FIELD                               0x007FFFFF /* =8388607 */
#define NV_PRAMIN_LOW_FIELD                                0x00700000 /* =7340032 */
#define NV_PRAMIN_CONTEXT_0_MSK                            0xFFFFFFFF /* 31:0 */ 
#define NV_PRAMIN_CONTEXT_0_RMSK                           0xFFFFFFFF /* 31:0 */ 
#define NV_PRAMIN_CONTEXT_0_WORD                           0
#define NV_PRAMIN_CONTEXT_0_HIGH_FIELD                     0x0000001F /* =31 */
#define NV_PRAMIN_CONTEXT_0_LOW_FIELD                      0x00000000 /* =0 */
#define NV_PRAMIN_CONTEXT_1_MSK                            0xFFFFFFFF /* 63:32 */ 
#define NV_PRAMIN_CONTEXT_1_RMSK                           0xFFFFFFFF /* 63:32 */ 
#define NV_PRAMIN_CONTEXT_1_WORD                           1
#define NV_PRAMIN_CONTEXT_1_HIGH_FIELD                     0x0000003F /* =63 */
#define NV_PRAMIN_CONTEXT_1_LOW_FIELD                      0x00000020 /* =32 */
#define NV_PRAMIN_CONTEXT_2_MSK                            0xFFFFFFFF /* 95:64 */ 
#define NV_PRAMIN_CONTEXT_2_RMSK                           0xFFFFFFFF /* 95:64 */ 
#define NV_PRAMIN_CONTEXT_2_WORD                           2
#define NV_PRAMIN_CONTEXT_2_HIGH_FIELD                     0x0000005F /* =95 */
#define NV_PRAMIN_CONTEXT_2_LOW_FIELD                      0x00000040 /* =64 */
#define NV_PRAMIN_CONTEXT_3_MSK                            0xFFFFFFFF /* 127:96 */ 
#define NV_PRAMIN_CONTEXT_3_RMSK                           0xFFFFFFFF /* 127:96 */ 
#define NV_PRAMIN_CONTEXT_3_WORD                           3
#define NV_PRAMIN_CONTEXT_3_HIGH_FIELD                     0x0000007F /* =127 */
#define NV_PRAMIN_CONTEXT_3_LOW_FIELD                      0x00000060 /* =96 */
#define NV_PRAMIN_RAMHT_0_HIGH_FIELD                       0x00710FFF /* =7409663 */
#define NV_PRAMIN_RAMHT_0_LOW_FIELD                        0x00710000 /* =7405568 */
#define NV_PRAMIN_RAMFC_0_HIGH_FIELD                       0x007113FF /* =7410687 */
#define NV_PRAMIN_RAMFC_0_LOW_FIELD                        0x00711000 /* =7409664 */
#define NV_PRAMIN_RAMRO_0_HIGH_FIELD                       0x007115FF /* =7411199 */
#define NV_PRAMIN_RAMRO_0_LOW_FIELD                        0x00711400 /* =7410688 */
#define NV_PRAMIN_CTX_0_NVCLASS_MSK                        0x00000FFF /* 11:0 */ 
#define NV_PRAMIN_CTX_0_NVCLASS_RMSK                       0x00000FFF /* 11:0 */ 
#define NV_PRAMIN_CTX_0_NVCLASS_WORD                       0
#define NV_PRAMIN_CTX_0_NVCLASS_HIGH_FIELD                 0x0000000B /* =11 */
#define NV_PRAMIN_CTX_0_NVCLASS_LOW_FIELD                  0x00000000 /* =0 */
#define NV_PRAMIN_CTX_0_NVCLASS_NV_ROOT_ADJ                0x00000000
#define NV_PRAMIN_CTX_0_NVCLASS_012_ADJ                    0x00000012
#define NV_PRAMIN_CTX_0_NVCLASS_017_ADJ                    0x00000017
#define NV_PRAMIN_CTX_0_NVCLASS_018_ADJ                    0x00000018
#define NV_PRAMIN_CTX_0_NVCLASS_019_ADJ                    0x00000019
#define NV_PRAMIN_CTX_0_NVCLASS_01C_ADJ                    0x0000001C
#define NV_PRAMIN_CTX_0_NVCLASS_01D_ADJ                    0x0000001D
#define NV_PRAMIN_CTX_0_NVCLASS_01E_ADJ                    0x0000001E
#define NV_PRAMIN_CTX_0_NVCLASS_01F_ADJ                    0x0000001F
#define NV_PRAMIN_CTX_0_NVCLASS_021_ADJ                    0x00000021
#define NV_PRAMIN_CTX_0_NVCLASS_030_ADJ                    0x00000030
#define NV_PRAMIN_CTX_0_NVCLASS_036_ADJ                    0x00000036
#define NV_PRAMIN_CTX_0_NVCLASS_037_ADJ                    0x00000037
#define NV_PRAMIN_CTX_0_NVCLASS_038_ADJ                    0x00000038
#define NV_PRAMIN_CTX_0_NVCLASS_039_ADJ                    0x00000039
#define NV_PRAMIN_CTX_0_NVCLASS_042_ADJ                    0x00000042
#define NV_PRAMIN_CTX_0_NVCLASS_043_ADJ                    0x00000043
#define NV_PRAMIN_CTX_0_NVCLASS_044_ADJ                    0x00000044
#define NV_PRAMIN_CTX_0_NVCLASS_048_ADJ                    0x00000048
#define NV_PRAMIN_CTX_0_NVCLASS_04A_ADJ                    0x0000004A
#define NV_PRAMIN_CTX_0_NVCLASS_04B_ADJ                    0x0000004B
#define NV_PRAMIN_CTX_0_NVCLASS_052_ADJ                    0x00000052
#define NV_PRAMIN_CTX_0_NVCLASS_053_ADJ                    0x00000053
#define NV_PRAMIN_CTX_0_NVCLASS_054_ADJ                    0x00000054
#define NV_PRAMIN_CTX_0_NVCLASS_055_ADJ                    0x00000055
#define NV_PRAMIN_CTX_0_NVCLASS_057_ADJ                    0x00000057
#define NV_PRAMIN_CTX_0_NVCLASS_058_ADJ                    0x00000058
#define NV_PRAMIN_CTX_0_NVCLASS_059_ADJ                    0x00000059
#define NV_PRAMIN_CTX_0_NVCLASS_05A_ADJ                    0x0000005A
#define NV_PRAMIN_CTX_0_NVCLASS_05B_ADJ                    0x0000005B
#define NV_PRAMIN_CTX_0_NVCLASS_05C_ADJ                    0x0000005C
#define NV_PRAMIN_CTX_0_NVCLASS_05E_ADJ                    0x0000005E
#define NV_PRAMIN_CTX_0_NVCLASS_05F_ADJ                    0x0000005F
#define NV_PRAMIN_CTX_0_NVCLASS_060_ADJ                    0x00000060
#define NV_PRAMIN_CTX_0_NVCLASS_061_ADJ                    0x00000061
#define NV_PRAMIN_CTX_0_NVCLASS_064_ADJ                    0x00000064
#define NV_PRAMIN_CTX_0_NVCLASS_065_ADJ                    0x00000065
#define NV_PRAMIN_CTX_0_NVCLASS_066_ADJ                    0x00000066
#define NV_PRAMIN_CTX_0_NVCLASS_067_ADJ                    0x00000067
#define NV_PRAMIN_CTX_0_NVCLASS_072_ADJ                    0x00000072
#define NV_PRAMIN_CTX_0_NVCLASS_076_ADJ                    0x00000076
#define NV_PRAMIN_CTX_0_NVCLASS_077_ADJ                    0x00000077
#define NV_PRAMIN_CTX_0_CHROMA_KEY_MSK                     0x00001000 /* 12:12 */ 
#define NV_PRAMIN_CTX_0_CHROMA_KEY_RMSK                    0x00000001 /* 12:12 */ 
#define NV_PRAMIN_CTX_0_CHROMA_KEY_WORD                    0
#define NV_PRAMIN_CTX_0_CHROMA_KEY_HIGH_FIELD              0x0000000C /* =12 */
#define NV_PRAMIN_CTX_0_CHROMA_KEY_LOW_FIELD               0x0000000C /* =12 */
#define NV_PRAMIN_CTX_0_CHROMA_KEY_DISABLE_ADJ             0x00000000
#define NV_PRAMIN_CTX_0_CHROMA_KEY_ENABLE_ADJ              0x00001000
#define NV_PRAMIN_CTX_0_USER_CLIP_MSK                      0x00002000 /* 13:13 */ 
#define NV_PRAMIN_CTX_0_USER_CLIP_RMSK                     0x00000001 /* 13:13 */ 
#define NV_PRAMIN_CTX_0_USER_CLIP_WORD                     0
#define NV_PRAMIN_CTX_0_USER_CLIP_HIGH_FIELD               0x0000000D /* =13 */
#define NV_PRAMIN_CTX_0_USER_CLIP_LOW_FIELD                0x0000000D /* =13 */
#define NV_PRAMIN_CTX_0_USER_CLIP_DISABLE_ADJ              0x00000000
#define NV_PRAMIN_CTX_0_USER_CLIP_ENABLE_ADJ               0x00002000
#define NV_PRAMIN_CTX_0_SWIZZLE_MSK                        0x00004000 /* 14:14 */ 
#define NV_PRAMIN_CTX_0_SWIZZLE_RMSK                       0x00000001 /* 14:14 */ 
#define NV_PRAMIN_CTX_0_SWIZZLE_WORD                       0
#define NV_PRAMIN_CTX_0_SWIZZLE_HIGH_FIELD                 0x0000000E /* =14 */
#define NV_PRAMIN_CTX_0_SWIZZLE_LOW_FIELD                  0x0000000E /* =14 */
#define NV_PRAMIN_CTX_0_SWIZZLE_DISABLE_ADJ                0x00000000
#define NV_PRAMIN_CTX_0_SWIZZLE_ENABLE_ADJ                 0x00004000
#define NV_PRAMIN_CTX_0_PATCH_CONFIG_MSK                   0x00038000 /* 17:15 */ 
#define NV_PRAMIN_CTX_0_PATCH_CONFIG_RMSK                  0x00000007 /* 17:15 */ 
#define NV_PRAMIN_CTX_0_PATCH_CONFIG_WORD                  0
#define NV_PRAMIN_CTX_0_PATCH_CONFIG_HIGH_FIELD            0x00000011 /* =17 */
#define NV_PRAMIN_CTX_0_PATCH_CONFIG_LOW_FIELD             0x0000000F /* =15 */
#define NV_PRAMIN_CTX_0_PATCH_CONFIG_SRCCOPY_AND_ADJ       0x00000000
#define NV_PRAMIN_CTX_0_PATCH_CONFIG_ROP_AND_ADJ           0x00008000
#define NV_PRAMIN_CTX_0_PATCH_CONFIG_BLEND_AND_ADJ         0x00010000
#define NV_PRAMIN_CTX_0_PATCH_CONFIG_SRCCOPY_ADJ           0x00018000
#define NV_PRAMIN_CTX_0_PATCH_CONFIG_SRCCOPY_PRE_ADJ       0x00020000
#define NV_PRAMIN_CTX_0_PATCH_CONFIG_BLEND_PRE_ADJ         0x00028000
#define NV_PRAMIN_CTX_0_DITHER_MODE_MSK                    0x00300000 /* 21:20 */ 
#define NV_PRAMIN_CTX_0_DITHER_MODE_RMSK                   0x00000003 /* 21:20 */ 
#define NV_PRAMIN_CTX_0_DITHER_MODE_WORD                   0
#define NV_PRAMIN_CTX_0_DITHER_MODE_HIGH_FIELD             0x00000015 /* =21 */
#define NV_PRAMIN_CTX_0_DITHER_MODE_LOW_FIELD              0x00000014 /* =20 */
#define NV_PRAMIN_CTX_0_DITHER_MODE_COMPATIBILITY_ADJ      0x00000000
#define NV_PRAMIN_CTX_0_DITHER_MODE_DITHER_ADJ             0x00100000
#define NV_PRAMIN_CTX_0_DITHER_MODE_TRUNCATE_ADJ           0x00200000
#define NV_PRAMIN_CTX_0_DITHER_MODE_SUBTRACT_TRUNCATE_ADJ  0x00300000
#define NV_PRAMIN_CTX_0_SINGLE_STEP_MSK                    0x00800000 /* 23:23 */ 
#define NV_PRAMIN_CTX_0_SINGLE_STEP_RMSK                   0x00000001 /* 23:23 */ 
#define NV_PRAMIN_CTX_0_SINGLE_STEP_WORD                   0
#define NV_PRAMIN_CTX_0_SINGLE_STEP_HIGH_FIELD             0x00000017 /* =23 */
#define NV_PRAMIN_CTX_0_SINGLE_STEP_LOW_FIELD              0x00000017 /* =23 */
#define NV_PRAMIN_CTX_0_SINGLE_STEP_DISABLE_ADJ            0x00000000
#define NV_PRAMIN_CTX_0_SINGLE_STEP_ENABLE_ADJ             0x00800000
#define NV_PRAMIN_CTX_0_PATCH_STATUS_MSK                   0x01000000 /* 24:24 */ 
#define NV_PRAMIN_CTX_0_PATCH_STATUS_RMSK                  0x00000001 /* 24:24 */ 
#define NV_PRAMIN_CTX_0_PATCH_STATUS_WORD                  0
#define NV_PRAMIN_CTX_0_PATCH_STATUS_HIGH_FIELD            0x00000018 /* =24 */
#define NV_PRAMIN_CTX_0_PATCH_STATUS_LOW_FIELD             0x00000018 /* =24 */
#define NV_PRAMIN_CTX_0_PATCH_STATUS_INVALID_ADJ           0x00000000
#define NV_PRAMIN_CTX_0_PATCH_STATUS_VALID_ADJ             0x01000000
#define NV_PRAMIN_CTX_0_CONTEXT_SURFACE0_MSK               0x02000000 /* 25:25 */ 
#define NV_PRAMIN_CTX_0_CONTEXT_SURFACE0_RMSK              0x00000001 /* 25:25 */ 
#define NV_PRAMIN_CTX_0_CONTEXT_SURFACE0_WORD              0
#define NV_PRAMIN_CTX_0_CONTEXT_SURFACE0_HIGH_FIELD        0x00000019 /* =25 */
#define NV_PRAMIN_CTX_0_CONTEXT_SURFACE0_LOW_FIELD         0x00000019 /* =25 */
#define NV_PRAMIN_CTX_0_CONTEXT_SURFACE0_INVALID_ADJ       0x00000000
#define NV_PRAMIN_CTX_0_CONTEXT_SURFACE0_VALID_ADJ         0x02000000
#define NV_PRAMIN_CTX_0_CONTEXT_SURFACE1_MSK               0x04000000 /* 26:26 */ 
#define NV_PRAMIN_CTX_0_CONTEXT_SURFACE1_RMSK              0x00000001 /* 26:26 */ 
#define NV_PRAMIN_CTX_0_CONTEXT_SURFACE1_WORD              0
#define NV_PRAMIN_CTX_0_CONTEXT_SURFACE1_HIGH_FIELD        0x0000001A /* =26 */
#define NV_PRAMIN_CTX_0_CONTEXT_SURFACE1_LOW_FIELD         0x0000001A /* =26 */
#define NV_PRAMIN_CTX_0_CONTEXT_SURFACE1_INVALID_ADJ       0x00000000
#define NV_PRAMIN_CTX_0_CONTEXT_SURFACE1_VALID_ADJ         0x04000000
#define NV_PRAMIN_CTX_0_CONTEXT_PATTERN_MSK                0x08000000 /* 27:27 */ 
#define NV_PRAMIN_CTX_0_CONTEXT_PATTERN_RMSK               0x00000001 /* 27:27 */ 
#define NV_PRAMIN_CTX_0_CONTEXT_PATTERN_WORD               0
#define NV_PRAMIN_CTX_0_CONTEXT_PATTERN_HIGH_FIELD         0x0000001B /* =27 */
#define NV_PRAMIN_CTX_0_CONTEXT_PATTERN_LOW_FIELD          0x0000001B /* =27 */
#define NV_PRAMIN_CTX_0_CONTEXT_PATTERN_INVALID_ADJ        0x00000000
#define NV_PRAMIN_CTX_0_CONTEXT_PATTERN_VALID_ADJ          0x08000000
#define NV_PRAMIN_CTX_0_CONTEXT_ROP_MSK                    0x10000000 /* 28:28 */ 
#define NV_PRAMIN_CTX_0_CONTEXT_ROP_RMSK                   0x00000001 /* 28:28 */ 
#define NV_PRAMIN_CTX_0_CONTEXT_ROP_WORD                   0
#define NV_PRAMIN_CTX_0_CONTEXT_ROP_HIGH_FIELD             0x0000001C /* =28 */
#define NV_PRAMIN_CTX_0_CONTEXT_ROP_LOW_FIELD              0x0000001C /* =28 */
#define NV_PRAMIN_CTX_0_CONTEXT_ROP_INVALID_ADJ            0x00000000
#define NV_PRAMIN_CTX_0_CONTEXT_ROP_VALID_ADJ              0x10000000
#define NV_PRAMIN_CTX_0_CONTEXT_BETA1_MSK                  0x20000000 /* 29:29 */ 
#define NV_PRAMIN_CTX_0_CONTEXT_BETA1_RMSK                 0x00000001 /* 29:29 */ 
#define NV_PRAMIN_CTX_0_CONTEXT_BETA1_WORD                 0
#define NV_PRAMIN_CTX_0_CONTEXT_BETA1_HIGH_FIELD           0x0000001D /* =29 */
#define NV_PRAMIN_CTX_0_CONTEXT_BETA1_LOW_FIELD            0x0000001D /* =29 */
#define NV_PRAMIN_CTX_0_CONTEXT_BETA1_INVALID_ADJ          0x00000000
#define NV_PRAMIN_CTX_0_CONTEXT_BETA1_VALID_ADJ            0x20000000
#define NV_PRAMIN_CTX_0_CONTEXT_BETA4_MSK                  0x40000000 /* 30:30 */ 
#define NV_PRAMIN_CTX_0_CONTEXT_BETA4_RMSK                 0x00000001 /* 30:30 */ 
#define NV_PRAMIN_CTX_0_CONTEXT_BETA4_WORD                 0
#define NV_PRAMIN_CTX_0_CONTEXT_BETA4_HIGH_FIELD           0x0000001E /* =30 */
#define NV_PRAMIN_CTX_0_CONTEXT_BETA4_LOW_FIELD            0x0000001E /* =30 */
#define NV_PRAMIN_CTX_0_CONTEXT_BETA4_INVALID_ADJ          0x00000000
#define NV_PRAMIN_CTX_0_CONTEXT_BETA4_VALID_ADJ            0x40000000
#define NV_PRAMIN_CTX_1_MONO_FORMAT_MSK                    0x000000FF /* 7:0 */ 
#define NV_PRAMIN_CTX_1_MONO_FORMAT_RMSK                   0x000000FF /* 7:0 */ 
#define NV_PRAMIN_CTX_1_MONO_FORMAT_WORD                   0
#define NV_PRAMIN_CTX_1_MONO_FORMAT_HIGH_FIELD             0x00000007 /* =7 */
#define NV_PRAMIN_CTX_1_MONO_FORMAT_LOW_FIELD              0x00000000 /* =0 */
#define NV_PRAMIN_CTX_1_MONO_FORMAT_INVALID_ADJ            0x00000000
#define NV_PRAMIN_CTX_1_MONO_FORMAT_CGA6_M1_ADJ            0x00000001
#define NV_PRAMIN_CTX_1_MONO_FORMAT_LE_M1_ADJ              0x00000002
#define NV_PRAMIN_CTX_1_MONO_FORMAT_018_ADJ                0x00000001
#define NV_PRAMIN_CTX_1_MONO_FORMAT_044_ADJ                0x00000001
#define NV_PRAMIN_CTX_1_MONO_FORMAT_04A_ADJ                0x00000001
#define NV_PRAMIN_CTX_1_MONO_FORMAT_04B_ADJ                0x00000001
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_MSK                   0x0000FF00 /* 15:8 */ 
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_RMSK                  0x000000FF /* 15:8 */ 
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_WORD                  0
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_HIGH_FIELD            0x0000000F /* =15 */
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_LOW_FIELD             0x00000008 /* =8 */
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_INVALID_ADJ           0x00000000
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_LE_Y8_ADJ             0x00000100
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_LE_X16A8Y8_ADJ        0x00000200
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_LE_X24Y8_ADJ          0x00000300
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_LE_A1R5G5B5_ADJ       0x00000600
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_LE_X1R5G5B5_ADJ       0x00000700
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_LE_X16A1R5G5B5_ADJ    0x00000800
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_LE_X17R5G5B5_ADJ      0x00000900
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_LE_R5G6B5_ADJ         0x00000A00
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_LE_A16R5G6B5_ADJ      0x00000B00
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_LE_X16R5G6B5_ADJ      0x00000C00
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_LE_A8R8G8B8_ADJ       0x00000D00
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_LE_X8R8G8B8_ADJ       0x00000E00
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_LE_Y16_ADJ            0x00000F00
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_LE_A16Y16_ADJ         0x00001000
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_LE_X16Y16_ADJ         0x00001100
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_LE_V8YB8U8YA8_ADJ     0x00001200
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_LE_YB8V8YA8U8_ADJ     0x00001300
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_LE_Y32_ADJ            0x00001400
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_017_ADJ               0x00000200
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_018_ADJ               0x00000200
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_01C_ADJ               0x00000300
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_01D_ADJ               0x00000300
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_01E_ADJ               0x00000300
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_021_ADJ               0x00000100
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_036_ADJ               0x00000100
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_037_ADJ               0x00000600
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_044_ADJ               0x00000B00
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_04A_ADJ               0x00000C00
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_04B_ADJ               0x00000300
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_057_ADJ               0x00000B00
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_05C_ADJ               0x00000C00
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_05D_ADJ               0x00000C00
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_05E_ADJ               0x00000C00
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_060_ADJ               0x00000A00
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_061_ADJ               0x00000A00
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_076_ADJ               0x00000A00
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_077_ADJ               0x00000600
#define NV_PRAMIN_CTX_1_NOTIFY_INSTANCE_MSK                0xFFFF0000 /* 31:16 */ 
#define NV_PRAMIN_CTX_1_NOTIFY_INSTANCE_RMSK               0x0000FFFF /* 31:16 */ 
#define NV_PRAMIN_CTX_1_NOTIFY_INSTANCE_WORD               0
#define NV_PRAMIN_CTX_1_NOTIFY_INSTANCE_HIGH_FIELD         0x0000001F /* =31 */
#define NV_PRAMIN_CTX_1_NOTIFY_INSTANCE_LOW_FIELD          0x00000010 /* =16 */
#define NV_PRAMIN_CTX_1_NOTIFY_INSTANCE_INVALID_ADJ        0x00000000
#define NV_PRAMIN_CTX_2_DMA_0_INSTANCE_MSK                 0x0000FFFF /* 15:0 */ 
#define NV_PRAMIN_CTX_2_DMA_0_INSTANCE_RMSK                0x0000FFFF /* 15:0 */ 
#define NV_PRAMIN_CTX_2_DMA_0_INSTANCE_WORD                0
#define NV_PRAMIN_CTX_2_DMA_0_INSTANCE_HIGH_FIELD          0x0000000F /* =15 */
#define NV_PRAMIN_CTX_2_DMA_0_INSTANCE_LOW_FIELD           0x00000000 /* =0 */
#define NV_PRAMIN_CTX_2_DMA_0_INSTANCE_INVALID_ADJ         0x00000000
#define NV_PRAMIN_CTX_2_DMA_1_INSTANCE_MSK                 0xFFFF0000 /* 31:16 */ 
#define NV_PRAMIN_CTX_2_DMA_1_INSTANCE_RMSK                0x0000FFFF /* 31:16 */ 
#define NV_PRAMIN_CTX_2_DMA_1_INSTANCE_WORD                0
#define NV_PRAMIN_CTX_2_DMA_1_INSTANCE_HIGH_FIELD          0x0000001F /* =31 */
#define NV_PRAMIN_CTX_2_DMA_1_INSTANCE_LOW_FIELD           0x00000010 /* =16 */
#define NV_PRAMIN_CTX_2_DMA_1_INSTANCE_INVALID_ADJ         0x00000000
#define NV_PRAMIN_CTX_3_METHOD_TRAPS_MSK                   0xFFFFFFFF /* 31:0 */ 
#define NV_PRAMIN_CTX_3_METHOD_TRAPS_RMSK                  0xFFFFFFFF /* 31:0 */ 
#define NV_PRAMIN_CTX_3_METHOD_TRAPS_WORD                  0
#define NV_PRAMIN_CTX_3_METHOD_TRAPS_HIGH_FIELD            0x0000001F /* =31 */
#define NV_PRAMIN_CTX_3_METHOD_TRAPS_LOW_FIELD             0x00000000 /* =0 */
#define NV_PRAMIN_CTX_3_METHOD_TRAPS_DISABLED_ADJ          0x00000000
#define NV_PRAMIN_DATA032_VALUE_MSK                        0xFFFFFFFF /* 31:0 */ 
#define NV_PRAMIN_DATA032_VALUE_RMSK                       0xFFFFFFFF /* 31:0 */ 
#define NV_PRAMIN_DATA032_VALUE_WORD                       0
#define NV_PRAMIN_DATA032_VALUE_HIGH_FIELD                 0x0000001F /* =31 */
#define NV_PRAMIN_DATA032_VALUE_LOW_FIELD                  0x00000000 /* =0 */
#define NV_PRAMIN_DATA032_MSK                              0xFFFFFFFF 
#define NV_PRAMIN_DATA016_VALUE_MSK                        0x0000FFFF /* 15:0 */ 
#define NV_PRAMIN_DATA016_VALUE_RMSK                       0x0000FFFF /* 15:0 */ 
#define NV_PRAMIN_DATA016_VALUE_WORD                       0
#define NV_PRAMIN_DATA016_VALUE_HIGH_FIELD                 0x0000000F /* =15 */
#define NV_PRAMIN_DATA016_VALUE_LOW_FIELD                  0x00000000 /* =0 */
#define NV_PRAMIN_DATA016_MSK                              0x0000FFFF 
#define NV_PRAMIN_DATA008_VALUE_MSK                        0x000000FF /* 7:0 */ 
#define NV_PRAMIN_DATA008_VALUE_RMSK                       0x000000FF /* 7:0 */ 
#define NV_PRAMIN_DATA008_VALUE_WORD                       0
#define NV_PRAMIN_DATA008_VALUE_HIGH_FIELD                 0x00000007 /* =7 */
#define NV_PRAMIN_DATA008_VALUE_LOW_FIELD                  0x00000000 /* =0 */
#define NV_FIFO_DMA_OPCODE_MSK                             0xE0000000 /* 31:29 */ 
#define NV_FIFO_DMA_OPCODE_RMSK                            0x00000007 /* 31:29 */ 
#define NV_FIFO_DMA_OPCODE_WORD                            0
#define NV_FIFO_DMA_OPCODE_HIGH_FIELD                      0x0000001F /* =31 */
#define NV_FIFO_DMA_OPCODE_LOW_FIELD                       0x0000001D /* =29 */
#define NV_FIFO_DMA_OPCODE_METHOD_ADJ                      0x00000000
#define NV_FIFO_DMA_OPCODE_JUMP_ADJ                        0x20000000
#define NV_FIFO_DMA_OPCODE_NONINC_METHOD_ADJ               0x40000000
#define NV_FIFO_DMA_OPCODE2_MSK                            0x00000003 /* 1:0 */ 
#define NV_FIFO_DMA_OPCODE2_RMSK                           0x00000003 /* 1:0 */ 
#define NV_FIFO_DMA_OPCODE2_WORD                           0
#define NV_FIFO_DMA_OPCODE2_HIGH_FIELD                     0x00000001 /* =1 */
#define NV_FIFO_DMA_OPCODE2_LOW_FIELD                      0x00000000 /* =0 */
#define NV_FIFO_DMA_OPCODE2_NONE_ADJ                       0x00000000
#define NV_FIFO_DMA_OPCODE2_JUMP_LONG_ADJ                  0x00000001
#define NV_FIFO_DMA_OPCODE2_CALL_ADJ                       0x00000002
#define NV_FIFO_DMA_OPCODE_MSK                             0xE0000000 /* 31:29 */ 
#define NV_FIFO_DMA_OPCODE_RMSK                            0x00000007 /* 31:29 */ 
#define NV_FIFO_DMA_OPCODE_WORD                            0
#define NV_FIFO_DMA_OPCODE_HIGH_FIELD                      0x0000001F /* =31 */
#define NV_FIFO_DMA_OPCODE_LOW_FIELD                       0x0000001D /* =29 */
#define NV_FIFO_DMA_OPCODE_METHOD_ADJ                      0x00000000
#define NV_FIFO_DMA_OPCODE_NONINC_METHOD_ADJ               0x40000000
#define NV_FIFO_DMA_METHOD_COUNT_MSK                       0x1FFC0000 /* 28:18 */ 
#define NV_FIFO_DMA_METHOD_COUNT_RMSK                      0x000007FF /* 28:18 */ 
#define NV_FIFO_DMA_METHOD_COUNT_WORD                      0
#define NV_FIFO_DMA_METHOD_COUNT_HIGH_FIELD                0x0000001C /* =28 */
#define NV_FIFO_DMA_METHOD_COUNT_LOW_FIELD                 0x00000012 /* =18 */
#define NV_FIFO_DMA_OPCODE3_MSK                            0x00030000 /* 17:16 */ 
#define NV_FIFO_DMA_OPCODE3_RMSK                           0x00000003 /* 17:16 */ 
#define NV_FIFO_DMA_OPCODE3_WORD                           0
#define NV_FIFO_DMA_OPCODE3_HIGH_FIELD                     0x00000011 /* =17 */
#define NV_FIFO_DMA_OPCODE3_LOW_FIELD                      0x00000010 /* =16 */
#define NV_FIFO_DMA_OPCODE3_NONE_ADJ                       0x00000000
#define NV_FIFO_DMA_METHOD_SUBCHANNEL_MSK                  0x0000E000 /* 15:13 */ 
#define NV_FIFO_DMA_METHOD_SUBCHANNEL_RMSK                 0x00000007 /* 15:13 */ 
#define NV_FIFO_DMA_METHOD_SUBCHANNEL_WORD                 0
#define NV_FIFO_DMA_METHOD_SUBCHANNEL_HIGH_FIELD           0x0000000F /* =15 */
#define NV_FIFO_DMA_METHOD_SUBCHANNEL_LOW_FIELD            0x0000000D /* =13 */
#define NV_FIFO_DMA_METHOD_ADDRESS_MSK                     0x00001FFC /* 12:2 */ 
#define NV_FIFO_DMA_METHOD_ADDRESS_RMSK                    0x000007FF /* 12:2 */ 
#define NV_FIFO_DMA_METHOD_ADDRESS_WORD                    0
#define NV_FIFO_DMA_METHOD_ADDRESS_HIGH_FIELD              0x0000000C /* =12 */
#define NV_FIFO_DMA_METHOD_ADDRESS_LOW_FIELD               0x00000002 /* =2 */
#define NV_FIFO_DMA_OPCODE2_MSK                            0x00000003 /* 1:0 */ 
#define NV_FIFO_DMA_OPCODE2_RMSK                           0x00000003 /* 1:0 */ 
#define NV_FIFO_DMA_OPCODE2_WORD                           0
#define NV_FIFO_DMA_OPCODE2_HIGH_FIELD                     0x00000001 /* =1 */
#define NV_FIFO_DMA_OPCODE2_LOW_FIELD                      0x00000000 /* =0 */
#define NV_FIFO_DMA_OPCODE2_NONE_ADJ                       0x00000000
#define NV_FIFO_DMA_DATA_MSK                               0xFFFFFFFF /* 63:32 */ 
#define NV_FIFO_DMA_DATA_RMSK                              0xFFFFFFFF /* 63:32 */ 
#define NV_FIFO_DMA_DATA_WORD                              1
#define NV_FIFO_DMA_DATA_HIGH_FIELD                        0x0000003F /* =63 */
#define NV_FIFO_DMA_DATA_LOW_FIELD                         0x00000020 /* =32 */
#define NV_FIFO_DMA_OPCODE_MSK                             0xE0000000 /* 31:29 */ 
#define NV_FIFO_DMA_OPCODE_RMSK                            0x00000007 /* 31:29 */ 
#define NV_FIFO_DMA_OPCODE_WORD                            0
#define NV_FIFO_DMA_OPCODE_HIGH_FIELD                      0x0000001F /* =31 */
#define NV_FIFO_DMA_OPCODE_LOW_FIELD                       0x0000001D /* =29 */
#define NV_FIFO_DMA_OPCODE_JUMP_ADJ                        0x20000000
#define NV_FIFO_DMA_OPCODE2_MSK                            0x00000003 /* 1:0 */ 
#define NV_FIFO_DMA_OPCODE2_RMSK                           0x00000003 /* 1:0 */ 
#define NV_FIFO_DMA_OPCODE2_WORD                           0
#define NV_FIFO_DMA_OPCODE2_HIGH_FIELD                     0x00000001 /* =1 */
#define NV_FIFO_DMA_OPCODE2_LOW_FIELD                      0x00000000 /* =0 */
#define NV_FIFO_DMA_OPCODE2_NONE_ADJ                       0x00000000
#define NV_FIFO_DMA_JUMP_OFFSET_MSK                        0x1FFFFFFC /* 28:2 */ 
#define NV_FIFO_DMA_JUMP_OFFSET_RMSK                       0x07FFFFFF /* 28:2 */ 
#define NV_FIFO_DMA_JUMP_OFFSET_WORD                       0
#define NV_FIFO_DMA_JUMP_OFFSET_HIGH_FIELD                 0x0000001C /* =28 */
#define NV_FIFO_DMA_JUMP_OFFSET_LOW_FIELD                  0x00000002 /* =2 */
#define NV_FIFO_DMA_OPCODE2_MSK                            0x00000003 /* 1:0 */ 
#define NV_FIFO_DMA_OPCODE2_RMSK                           0x00000003 /* 1:0 */ 
#define NV_FIFO_DMA_OPCODE2_WORD                           0
#define NV_FIFO_DMA_OPCODE2_HIGH_FIELD                     0x00000001 /* =1 */
#define NV_FIFO_DMA_OPCODE2_LOW_FIELD                      0x00000000 /* =0 */
#define NV_FIFO_DMA_OPCODE2_JUMP_LONG_ADJ                  0x00000001
#define NV_FIFO_DMA_JUMP_LONG_OFFSET_MSK                   0xFFFFFFFC /* 31:2 */ 
#define NV_FIFO_DMA_JUMP_LONG_OFFSET_RMSK                  0x3FFFFFFF /* 31:2 */ 
#define NV_FIFO_DMA_JUMP_LONG_OFFSET_WORD                  0
#define NV_FIFO_DMA_JUMP_LONG_OFFSET_HIGH_FIELD            0x0000001F /* =31 */
#define NV_FIFO_DMA_JUMP_LONG_OFFSET_LOW_FIELD             0x00000002 /* =2 */
#define NV_FIFO_DMA_OPCODE2_MSK                            0x00000003 /* 1:0 */ 
#define NV_FIFO_DMA_OPCODE2_RMSK                           0x00000003 /* 1:0 */ 
#define NV_FIFO_DMA_OPCODE2_WORD                           0
#define NV_FIFO_DMA_OPCODE2_HIGH_FIELD                     0x00000001 /* =1 */
#define NV_FIFO_DMA_OPCODE2_LOW_FIELD                      0x00000000 /* =0 */
#define NV_FIFO_DMA_OPCODE2_CALL_ADJ                       0x00000002
#define NV_FIFO_DMA_CALL_OFFSET_MSK                        0xFFFFFFFC /* 31:2 */ 
#define NV_FIFO_DMA_CALL_OFFSET_RMSK                       0x3FFFFFFF /* 31:2 */ 
#define NV_FIFO_DMA_CALL_OFFSET_WORD                       0
#define NV_FIFO_DMA_CALL_OFFSET_HIGH_FIELD                 0x0000001F /* =31 */
#define NV_FIFO_DMA_CALL_OFFSET_LOW_FIELD                  0x00000002 /* =2 */
#define NV_FIFO_DMA_OPCODE3_MSK                            0x00030000 /* 17:16 */ 
#define NV_FIFO_DMA_OPCODE3_RMSK                           0x00000003 /* 17:16 */ 
#define NV_FIFO_DMA_OPCODE3_WORD                           0
#define NV_FIFO_DMA_OPCODE3_HIGH_FIELD                     0x00000011 /* =17 */
#define NV_FIFO_DMA_OPCODE3_LOW_FIELD                      0x00000010 /* =16 */
#define NV_FIFO_DMA_OPCODE3_RETURN_ADJ                     0x00020000
#define NV_PRAMIN_DATA008_MSK                              0xFFFFFFFF 
#define NV_PRAM_HIGH_FIELD                                 0x00006FFF /* =28671 */
#define NV_PRAM_LOW_FIELD                                  0x00006000 /* =24576 */
#define NV_PFB_HIGH_FIELD                                  0x00100FFF /* =1052671 */
#define NV_PFB_LOW_FIELD                                   0x00100000 /* =1048576 */
#define NV_PFB_DEBUG_0_ADJ                                 0x00100080
#define NV_PFB_DEBUG_0_CLM1_MSK                            0x00000001 /* 0:0 */ 
#define NV_PFB_DEBUG_0_CLM1_RMSK                           0x00000001 /* 0:0 */ 
#define NV_PFB_DEBUG_0_CLM1_WORD                           0
#define NV_PFB_DEBUG_0_CLM1_HIGH_FIELD                     0x00000000 /* =0 */
#define NV_PFB_DEBUG_0_CLM1_LOW_FIELD                      0x00000000 /* =0 */
#define NV_PFB_DEBUG_0_CLM1_DISABLED_ADJ                   0x00000000
#define NV_PFB_DEBUG_0_CLM1_ENABLED_ADJ                    0x00000001
#define NV_PFB_DEBUG_0_CLP1_MSK                            0x00000002 /* 1:1 */ 
#define NV_PFB_DEBUG_0_CLP1_RMSK                           0x00000001 /* 1:1 */ 
#define NV_PFB_DEBUG_0_CLP1_WORD                           0
#define NV_PFB_DEBUG_0_CLP1_HIGH_FIELD                     0x00000001 /* =1 */
#define NV_PFB_DEBUG_0_CLP1_LOW_FIELD                      0x00000001 /* =1 */
#define NV_PFB_DEBUG_0_CLP1_DISABLED_ADJ                   0x00000000
#define NV_PFB_DEBUG_0_CLP1_ENABLED_ADJ                    0x00000002
#define NV_PFB_DEBUG_0_MRS_MSK                             0x00000010 /* 4:4 */ 
#define NV_PFB_DEBUG_0_MRS_RMSK                            0x00000001 /* 4:4 */ 
#define NV_PFB_DEBUG_0_MRS_WORD                            0
#define NV_PFB_DEBUG_0_MRS_HIGH_FIELD                      0x00000004 /* =4 */
#define NV_PFB_DEBUG_0_MRS_LOW_FIELD                       0x00000004 /* =4 */
#define NV_PFB_DEBUG_0_MRS_256_ADJ                         0x00000000
#define NV_PFB_DEBUG_0_MRS_2_ADJ                           0x00000010
#define NV_PFB_DEBUG_0_PREA_MSK                            0x00000100 /* 8:8 */ 
#define NV_PFB_DEBUG_0_PREA_RMSK                           0x00000001 /* 8:8 */ 
#define NV_PFB_DEBUG_0_PREA_WORD                           0
#define NV_PFB_DEBUG_0_PREA_HIGH_FIELD                     0x00000008 /* =8 */
#define NV_PFB_DEBUG_0_PREA_LOW_FIELD                      0x00000008 /* =8 */
#define NV_PFB_DEBUG_0_PREA_DISABLED_ADJ                   0x00000000
#define NV_PFB_DEBUG_0_PREA_ENABLED_ADJ                    0x00000100
#define NV_PFB_DEBUG_0_PREL_MSK                            0x00001000 /* 12:12 */ 
#define NV_PFB_DEBUG_0_PREL_RMSK                           0x00000001 /* 12:12 */ 
#define NV_PFB_DEBUG_0_PREL_WORD                           0
#define NV_PFB_DEBUG_0_PREL_HIGH_FIELD                     0x0000000C /* =12 */
#define NV_PFB_DEBUG_0_PREL_LOW_FIELD                      0x0000000C /* =12 */
#define NV_PFB_DEBUG_0_PREL_DISABLED_ADJ                   0x00000000
#define NV_PFB_DEBUG_0_PREL_ENABLED_ADJ                    0x00001000
#define NV_PFB_DEBUG_0_ADR_MSK                             0x00030000 /* 17:16 */ 
#define NV_PFB_DEBUG_0_ADR_RMSK                            0x00000003 /* 17:16 */ 
#define NV_PFB_DEBUG_0_ADR_WORD                            0
#define NV_PFB_DEBUG_0_ADR_HIGH_FIELD                      0x00000011 /* =17 */
#define NV_PFB_DEBUG_0_ADR_LOW_FIELD                       0x00000010 /* =16 */
#define NV_PFB_DEBUG_0_ADR_NV10_ADJ                        0x00000000
#define NV_PFB_DEBUG_0_ADR_NV5_ADJ                         0x00010000
#define NV_PFB_DEBUG_0_ADR_FIXED_ADJ                       0x00020000
#define NV_PFB_DEBUG_0_TC_MSK                              0x00300000 /* 21:20 */ 
#define NV_PFB_DEBUG_0_TC_RMSK                             0x00000003 /* 21:20 */ 
#define NV_PFB_DEBUG_0_TC_WORD                             0
#define NV_PFB_DEBUG_0_TC_HIGH_FIELD                       0x00000015 /* =21 */
#define NV_PFB_DEBUG_0_TC_LOW_FIELD                        0x00000014 /* =20 */
#define NV_PFB_DEBUG_0_TC_8_ADJ                            0x00000000
#define NV_PFB_DEBUG_0_TC_4_ADJ                            0x00100000
#define NV_PFB_DEBUG_0_TC_2_ADJ                            0x00200000
#define NV_PFB_DEBUG_0_MSK                                 0x00331113 
#define NV_PFB_CFG_TYPE_MSK                                0x00000001 /* 0:0 */ 
#define NV_PFB_CFG_TYPE_RMSK                               0x00000001 /* 0:0 */ 
#define NV_PFB_CFG_TYPE_WORD                               0
#define NV_PFB_CFG_TYPE_HIGH_FIELD                         0x00000000 /* =0 */
#define NV_PFB_CFG_TYPE_LOW_FIELD                          0x00000000 /* =0 */
#define NV_PFB_CFG_TYPE_SDR_ADJ                            0x00000000
#define NV_PFB_CFG_TYPE_DDR_ADJ                            0x00000001
#define NV_PFB_CFG_BUS_MSK                                 0x00000030 /* 5:4 */ 
#define NV_PFB_CFG_BUS_RMSK                                0x00000003 /* 5:4 */ 
#define NV_PFB_CFG_BUS_WORD                                0
#define NV_PFB_CFG_BUS_HIGH_FIELD                          0x00000005 /* =5 */
#define NV_PFB_CFG_BUS_LOW_FIELD                           0x00000004 /* =4 */
#define NV_PFB_CFG_BUS_64_ADJ                              0x00000000
#define NV_PFB_CFG_BUS_128_ADJ                             0x00000010
#define NV_PFB_CFG_BUS_32_ADJ                              0x00000020
#define NV_PFB_CFG_RAM_MSK                                 0x00000100 /* 8:8 */ 
#define NV_PFB_CFG_RAM_RMSK                                0x00000001 /* 8:8 */ 
#define NV_PFB_CFG_RAM_WORD                                0
#define NV_PFB_CFG_RAM_HIGH_FIELD                          0x00000008 /* =8 */
#define NV_PFB_CFG_RAM_LOW_FIELD                           0x00000008 /* =8 */
#define NV_PFB_CFG_RAM_8_ADJ                               0x00000000
#define NV_PFB_CFG_RAM_32_ADJ                              0x00000100
#define NV_PFB_CFG_EXTBANK_MSK                             0x00001000 /* 12:12 */ 
#define NV_PFB_CFG_EXTBANK_RMSK                            0x00000001 /* 12:12 */ 
#define NV_PFB_CFG_EXTBANK_WORD                            0
#define NV_PFB_CFG_EXTBANK_HIGH_FIELD                      0x0000000C /* =12 */
#define NV_PFB_CFG_EXTBANK_LOW_FIELD                       0x0000000C /* =12 */
#define NV_PFB_CFG_EXTBANK_0_ADJ                           0x00000000
#define NV_PFB_CFG_EXTBANK_1_ADJ                           0x00001000
#define NV_PFB_CFG_BANK_MSK                                0x00010000 /* 16:16 */ 
#define NV_PFB_CFG_BANK_RMSK                               0x00000001 /* 16:16 */ 
#define NV_PFB_CFG_BANK_WORD                               0
#define NV_PFB_CFG_BANK_HIGH_FIELD                         0x00000010 /* =16 */
#define NV_PFB_CFG_BANK_LOW_FIELD                          0x00000010 /* =16 */
#define NV_PFB_CFG_BANK_1_ADJ                              0x00000000
#define NV_PFB_CFG_BANK_2_ADJ                              0x00010000
#define NV_PFB_CFG_ROW_MSK                                 0x00F00000 /* 23:20 */ 
#define NV_PFB_CFG_ROW_RMSK                                0x0000000F /* 23:20 */ 
#define NV_PFB_CFG_ROW_WORD                                0
#define NV_PFB_CFG_ROW_HIGH_FIELD                          0x00000017 /* =23 */
#define NV_PFB_CFG_ROW_LOW_FIELD                           0x00000014 /* =20 */
#define NV_PFB_CFG_ROW_9_ADJ                               0x00900000
#define NV_PFB_CFG_ROW_10_ADJ                              0x00A00000
#define NV_PFB_CFG_ROW_11_ADJ                              0x00B00000
#define NV_PFB_CFG_ROW_12_ADJ                              0x00C00000
#define NV_PFB_CFG_COL_MSK                                 0x01000000 /* 24:24 */ 
#define NV_PFB_CFG_COL_RMSK                                0x00000001 /* 24:24 */ 
#define NV_PFB_CFG_COL_WORD                                0
#define NV_PFB_CFG_COL_HIGH_FIELD                          0x00000018 /* =24 */
#define NV_PFB_CFG_COL_LOW_FIELD                           0x00000018 /* =24 */
#define NV_PFB_CFG_COL_8_ADJ                               0x00000000
#define NV_PFB_CFG_COL_9_ADJ                               0x01000000
#define NV_PFB_CFG_COLU_MSK                                0x0E000000 /* 27:25 */ 
#define NV_PFB_CFG_COLU_RMSK                               0x00000007 /* 27:25 */ 
#define NV_PFB_CFG_COLU_WORD                               0
#define NV_PFB_CFG_COLU_HIGH_FIELD                         0x0000001B /* =27 */
#define NV_PFB_CFG_COLU_LOW_FIELD                          0x00000019 /* =25 */
#define NV_PFB_CFG_COLU_4_ADJ                              0x08000000
#define NV_PFB_CFG_DQS_MSK                                 0x10000000 /* 28:28 */ 
#define NV_PFB_CFG_DQS_RMSK                                0x00000001 /* 28:28 */ 
#define NV_PFB_CFG_DQS_WORD                                0
#define NV_PFB_CFG_DQS_HIGH_FIELD                          0x0000001C /* =28 */
#define NV_PFB_CFG_DQS_LOW_FIELD                           0x0000001C /* =28 */
#define NV_PFB_CFG_DQS_NORMAL_ADJ                          0x00000000
#define NV_PFB_CFG_DQS_EARLY_ADJ                           0x10000000
#define NV_PFB_CFG_ROWM_MSK                                0x60000000 /* 30:29 */ 
#define NV_PFB_CFG_ROWM_RMSK                               0x00000003 /* 30:29 */ 
#define NV_PFB_CFG_ROWM_WORD                               0
#define NV_PFB_CFG_ROWM_HIGH_FIELD                         0x0000001E /* =30 */
#define NV_PFB_CFG_ROWM_LOW_FIELD                          0x0000001D /* =29 */
#define NV_PFB_CFG_ROWM_0_ADJ                              0x00000000
#define NV_PFB_CFG_ROWM_1_ADJ                              0x20000000
#define NV_PFB_CFG_ROWM_2_ADJ                              0x40000000
#define NV_PFB_CFG_ROWM_3_ADJ                              0x60000000
#define NV_PFB_CFG_BANKM_MSK                               0x80000000 /* 31:31 */ 
#define NV_PFB_CFG_BANKM_RMSK                              0x00000001 /* 31:31 */ 
#define NV_PFB_CFG_BANKM_WORD                              0
#define NV_PFB_CFG_BANKM_HIGH_FIELD                        0x0000001F /* =31 */
#define NV_PFB_CFG_BANKM_LOW_FIELD                         0x0000001F /* =31 */
#define NV_PFB_CFG_BANKM_0_ADJ                             0x00000000
#define NV_PFB_CFG_BANKM_1_ADJ                             0x80000000
#define NV_PFB_CFG_MSK                                     0xFFF11131 
#define NV_PFB_CSTATUS_RAMAMOUNT_MSK                       0x0FF00000 /* 27:20 */ 
#define NV_PFB_CSTATUS_RAMAMOUNT_RMSK                      0x000000FF /* 27:20 */ 
#define NV_PFB_CSTATUS_RAMAMOUNT_WORD                      0
#define NV_PFB_CSTATUS_RAMAMOUNT_HIGH_FIELD                0x0000001B /* =27 */
#define NV_PFB_CSTATUS_RAMAMOUNT_LOW_FIELD                 0x00000014 /* =20 */
#define NV_PFB_CSTATUS_MSK                                 0x0FF00000 
#define NV_PFB_REFCTRL_PUT_MSK                             0x0000001F /* 4:0 */ 
#define NV_PFB_REFCTRL_PUT_RMSK                            0x0000001F /* 4:0 */ 
#define NV_PFB_REFCTRL_PUT_WORD                            0
#define NV_PFB_REFCTRL_PUT_HIGH_FIELD                      0x00000004 /* =4 */
#define NV_PFB_REFCTRL_PUT_LOW_FIELD                       0x00000000 /* =0 */
#define NV_PFB_REFCTRL_PUT_0_ADJ                           0x00000000
#define NV_PFB_REFCTRL_GET_MSK                             0x00001F00 /* 12:8 */ 
#define NV_PFB_REFCTRL_GET_RMSK                            0x0000001F /* 12:8 */ 
#define NV_PFB_REFCTRL_GET_WORD                            0
#define NV_PFB_REFCTRL_GET_HIGH_FIELD                      0x0000000C /* =12 */
#define NV_PFB_REFCTRL_GET_LOW_FIELD                       0x00000008 /* =8 */
#define NV_PFB_REFCTRL_GET_0_ADJ                           0x00000000
#define NV_PFB_REFCTRL_VALID_MSK                           0x80000000 /* 31:31 */ 
#define NV_PFB_REFCTRL_VALID_RMSK                          0x00000001 /* 31:31 */ 
#define NV_PFB_REFCTRL_VALID_WORD                          0
#define NV_PFB_REFCTRL_VALID_HIGH_FIELD                    0x0000001F /* =31 */
#define NV_PFB_REFCTRL_VALID_LOW_FIELD                     0x0000001F /* =31 */
#define NV_PFB_REFCTRL_VALID_0_ADJ                         0x00000000
#define NV_PFB_REFCTRL_VALID_1_ADJ                         0x80000000
#define NV_PFB_REFCTRL_MSK                                 0x80001F1F 
#define NV_PFB_NVM_MODE_MSK                                0x00000001 /* 0:0 */ 
#define NV_PFB_NVM_MODE_RMSK                               0x00000001 /* 0:0 */ 
#define NV_PFB_NVM_MODE_WORD                               0
#define NV_PFB_NVM_MODE_HIGH_FIELD                         0x00000000 /* =0 */
#define NV_PFB_NVM_MODE_LOW_FIELD                          0x00000000 /* =0 */
#define NV_PFB_NVM_MODE_DISABLE_ADJ                        0x00000000
#define NV_PFB_NVM_MODE_ENABLE_ADJ                         0x00000001
#define NV_PFB_NVM_LIMIT_MSK                               0x000000F0 /* 7:4 */ 
#define NV_PFB_NVM_LIMIT_RMSK                              0x0000000F /* 7:4 */ 
#define NV_PFB_NVM_LIMIT_WORD                              0
#define NV_PFB_NVM_LIMIT_HIGH_FIELD                        0x00000007 /* =7 */
#define NV_PFB_NVM_LIMIT_LOW_FIELD                         0x00000004 /* =4 */
#define NV_PFB_NVM_LIMIT_64K_ADJ                           0x00000000
#define NV_PFB_NVM_LIMIT_128K_ADJ                          0x00000010
#define NV_PFB_NVM_LIMIT_192K_ADJ                          0x00000020
#define NV_PFB_NVM_LIMIT_256K_ADJ                          0x00000030
#define NV_PFB_NVM_LIMIT_320K_ADJ                          0x00000040
#define NV_PFB_NVM_LIMIT_384K_ADJ                          0x00000050
#define NV_PFB_NVM_LIMIT_448K_ADJ                          0x00000060
#define NV_PFB_NVM_LIMIT_512K_ADJ                          0x00000070
#define NV_PFB_NVM_LIMIT_576K_ADJ                          0x00000080
#define NV_PFB_NVM_LIMIT_640K_ADJ                          0x00000090
#define NV_PFB_NVM_LIMIT_704K_ADJ                          0x000000A0
#define NV_PFB_NVM_LIMIT_768K_ADJ                          0x000000B0
#define NV_PFB_NVM_LIMIT_832K_ADJ                          0x000000C0
#define NV_PFB_NVM_LIMIT_896K_ADJ                          0x000000D0
#define NV_PFB_NVM_LIMIT_960K_ADJ                          0x000000E0
#define NV_PFB_NVM_LIMIT_1024K_ADJ                         0x000000F0
#define NV_PFB_NVM_MSK                                     0x000000F1 
#define NV_PFB_PIN_CKE_MSK                                 0x00000001 /* 0:0 */ 
#define NV_PFB_PIN_CKE_RMSK                                0x00000001 /* 0:0 */ 
#define NV_PFB_PIN_CKE_WORD                                0
#define NV_PFB_PIN_CKE_HIGH_FIELD                          0x00000000 /* =0 */
#define NV_PFB_PIN_CKE_LOW_FIELD                           0x00000000 /* =0 */
#define NV_PFB_PIN_CKE_POWERDOWN_ADJ                       0x00000000
#define NV_PFB_PIN_CKE_NORMAL_ADJ                          0x00000001
#define NV_PFB_PIN_DQM_MSK                                 0x00000010 /* 4:4 */ 
#define NV_PFB_PIN_DQM_RMSK                                0x00000001 /* 4:4 */ 
#define NV_PFB_PIN_DQM_WORD                                0
#define NV_PFB_PIN_DQM_HIGH_FIELD                          0x00000004 /* =4 */
#define NV_PFB_PIN_DQM_LOW_FIELD                           0x00000004 /* =4 */
#define NV_PFB_PIN_DQM_NORMAL_ADJ                          0x00000000
#define NV_PFB_PIN_DQM_INACTIVE_ADJ                        0x00000010
#define NV_PFB_PIN_MSK                                     0x00000011 
#define NV_PFB_PAD_CKE_MSK                                 0x00000001 /* 0:0 */ 
#define NV_PFB_PAD_CKE_RMSK                                0x00000001 /* 0:0 */ 
#define NV_PFB_PAD_CKE_WORD                                0
#define NV_PFB_PAD_CKE_HIGH_FIELD                          0x00000000 /* =0 */
#define NV_PFB_PAD_CKE_LOW_FIELD                           0x00000000 /* =0 */
#define NV_PFB_PAD_CKE_TRISTATE_ADJ                        0x00000000
#define NV_PFB_PAD_CKE_NORMAL_ADJ                          0x00000001
#define NV_PFB_PAD_MSK                                     0x00000001 
#define NV_PFB_TIMING0_RC_MSK                              0x0000001F /* 4:0 */ 
#define NV_PFB_TIMING0_RC_RMSK                             0x0000001F /* 4:0 */ 
#define NV_PFB_TIMING0_RC_WORD                             0
#define NV_PFB_TIMING0_RC_HIGH_FIELD                       0x00000004 /* =4 */
#define NV_PFB_TIMING0_RC_LOW_FIELD                        0x00000000 /* =0 */
#define NV_PFB_TIMING0_RC_31_ADJ                           0x0000001F
#define NV_PFB_TIMING0_RFC_MSK                             0x00001F00 /* 12:8 */ 
#define NV_PFB_TIMING0_RFC_RMSK                            0x0000001F /* 12:8 */ 
#define NV_PFB_TIMING0_RFC_WORD                            0
#define NV_PFB_TIMING0_RFC_HIGH_FIELD                      0x0000000C /* =12 */
#define NV_PFB_TIMING0_RFC_LOW_FIELD                       0x00000008 /* =8 */
#define NV_PFB_TIMING0_RFC_31_ADJ                          0x00001F00
#define NV_PFB_TIMING0_RAS_MSK                             0x001F0000 /* 20:16 */ 
#define NV_PFB_TIMING0_RAS_RMSK                            0x0000001F /* 20:16 */ 
#define NV_PFB_TIMING0_RAS_WORD                            0
#define NV_PFB_TIMING0_RAS_HIGH_FIELD                      0x00000014 /* =20 */
#define NV_PFB_TIMING0_RAS_LOW_FIELD                       0x00000010 /* =16 */
#define NV_PFB_TIMING0_RAS_31_ADJ                          0x001F0000
#define NV_PFB_TIMING0_RCD_MSK                             0x0F000000 /* 27:24 */ 
#define NV_PFB_TIMING0_RCD_RMSK                            0x0000000F /* 27:24 */ 
#define NV_PFB_TIMING0_RCD_WORD                            0
#define NV_PFB_TIMING0_RCD_HIGH_FIELD                      0x0000001B /* =27 */
#define NV_PFB_TIMING0_RCD_LOW_FIELD                       0x00000018 /* =24 */
#define NV_PFB_TIMING0_RCD_15_ADJ                          0x0F000000
#define NV_PFB_TIMING0_RP_MSK                              0xF0000000 /* 31:28 */ 
#define NV_PFB_TIMING0_RP_RMSK                             0x0000000F /* 31:28 */ 
#define NV_PFB_TIMING0_RP_WORD                             0
#define NV_PFB_TIMING0_RP_HIGH_FIELD                       0x0000001F /* =31 */
#define NV_PFB_TIMING0_RP_LOW_FIELD                        0x0000001C /* =28 */
#define NV_PFB_TIMING0_RP_15_ADJ                           0xF0000000
#define NV_PFB_TIMING0_MSK                                 0xFF1F1F1F 
#define NV_PFB_TIMING1_R2W_MSK                             0x00000070 /* 6:4 */ 
#define NV_PFB_TIMING1_R2W_RMSK                            0x00000007 /* 6:4 */ 
#define NV_PFB_TIMING1_R2W_WORD                            0
#define NV_PFB_TIMING1_R2W_HIGH_FIELD                      0x00000006 /* =6 */
#define NV_PFB_TIMING1_R2W_LOW_FIELD                       0x00000004 /* =4 */
#define NV_PFB_TIMING1_R2W_7_ADJ                           0x00000070
#define NV_PFB_TIMING1_R2P_MSK                             0x00000700 /* 10:8 */ 
#define NV_PFB_TIMING1_R2P_RMSK                            0x00000007 /* 10:8 */ 
#define NV_PFB_TIMING1_R2P_WORD                            0
#define NV_PFB_TIMING1_R2P_HIGH_FIELD                      0x0000000A /* =10 */
#define NV_PFB_TIMING1_R2P_LOW_FIELD                       0x00000008 /* =8 */
#define NV_PFB_TIMING1_R2P_7_ADJ                           0x00000700
#define NV_PFB_TIMING1_REXT_MSK                            0x00003000 /* 13:12 */ 
#define NV_PFB_TIMING1_REXT_RMSK                           0x00000003 /* 13:12 */ 
#define NV_PFB_TIMING1_REXT_WORD                           0
#define NV_PFB_TIMING1_REXT_HIGH_FIELD                     0x0000000D /* =13 */
#define NV_PFB_TIMING1_REXT_LOW_FIELD                      0x0000000C /* =12 */
#define NV_PFB_TIMING1_REXT_1_ADJ                          0x00001000
#define NV_PFB_TIMING1_REXT_2_ADJ                          0x00002000
#define NV_PFB_TIMING1_W2R_MSK                             0x00070000 /* 18:16 */ 
#define NV_PFB_TIMING1_W2R_RMSK                            0x00000007 /* 18:16 */ 
#define NV_PFB_TIMING1_W2R_WORD                            0
#define NV_PFB_TIMING1_W2R_HIGH_FIELD                      0x00000012 /* =18 */
#define NV_PFB_TIMING1_W2R_LOW_FIELD                       0x00000010 /* =16 */
#define NV_PFB_TIMING1_W2R_7_ADJ                           0x00070000
#define NV_PFB_TIMING1_W2P_MSK                             0x00700000 /* 22:20 */ 
#define NV_PFB_TIMING1_W2P_RMSK                            0x00000007 /* 22:20 */ 
#define NV_PFB_TIMING1_W2P_WORD                            0
#define NV_PFB_TIMING1_W2P_HIGH_FIELD                      0x00000016 /* =22 */
#define NV_PFB_TIMING1_W2P_LOW_FIELD                       0x00000014 /* =20 */
#define NV_PFB_TIMING1_W2P_7_ADJ                           0x00700000
#define NV_PFB_TIMING1_RRD_MSK                             0x07000000 /* 26:24 */ 
#define NV_PFB_TIMING1_RRD_RMSK                            0x00000007 /* 26:24 */ 
#define NV_PFB_TIMING1_RRD_WORD                            0
#define NV_PFB_TIMING1_RRD_HIGH_FIELD                      0x0000001A /* =26 */
#define NV_PFB_TIMING1_RRD_LOW_FIELD                       0x00000018 /* =24 */
#define NV_PFB_TIMING1_RRD_7_ADJ                           0x07000000
#define NV_PFB_TIMING1_MSK                                 0x07773770 
#define NV_PFB_TIMING2_REFRESH_MSK                         0x0000FFE0 /* 15:5 */ 
#define NV_PFB_TIMING2_REFRESH_RMSK                        0x000007FF /* 15:5 */ 
#define NV_PFB_TIMING2_REFRESH_WORD                        0
#define NV_PFB_TIMING2_REFRESH_HIGH_FIELD                  0x0000000F /* =15 */
#define NV_PFB_TIMING2_REFRESH_LOW_FIELD                   0x00000005 /* =5 */
#define NV_PFB_TIMING2_REFRESH_0_ADJ                       0x00000000
#define NV_PFB_TIMING2_REFRESH_LO_MSK                      0x0000001F /* 4:0 */ 
#define NV_PFB_TIMING2_REFRESH_LO_RMSK                     0x0000001F /* 4:0 */ 
#define NV_PFB_TIMING2_REFRESH_LO_WORD                     0
#define NV_PFB_TIMING2_REFRESH_LO_HIGH_FIELD               0x00000004 /* =4 */
#define NV_PFB_TIMING2_REFRESH_LO_LOW_FIELD                0x00000000 /* =0 */
#define NV_PFB_TIMING2_REFRESH_LO_1F_ADJ                   0x0000001F
#define NV_PFB_TIMING2_MSK                                 0x0000FFFF 
#define NV_PFB_TILE_ADR_MSK                                0x07FFC000 /* 26:14 */ 
#define NV_PFB_TILE_ADR_RMSK                               0x00001FFF /* 26:14 */ 
#define NV_PFB_TILE_ADR_WORD                               0
#define NV_PFB_TILE_ADR_HIGH_FIELD                         0x0000001A /* =26 */
#define NV_PFB_TILE_ADR_LOW_FIELD                          0x0000000E /* =14 */
#define NV_PFB_TILE_REGION_MSK                             0x80000000 /* 31:31 */ 
#define NV_PFB_TILE_REGION_RMSK                            0x00000001 /* 31:31 */ 
#define NV_PFB_TILE_REGION_WORD                            0
#define NV_PFB_TILE_REGION_HIGH_FIELD                      0x0000001F /* =31 */
#define NV_PFB_TILE_REGION_LOW_FIELD                       0x0000001F /* =31 */
#define NV_PFB_TILE_REGION_INVALID_ADJ                     0x00000000
#define NV_PFB_TILE_REGION_VALID_ADJ                       0x80000000
#define NV_PFB_TILE_MSK                                    0x87FFC000 
#define NV_PFB_TLIMIT_ADR_MSK                              0x07FFC000 /* 26:14 */ 
#define NV_PFB_TLIMIT_ADR_RMSK                             0x00001FFF /* 26:14 */ 
#define NV_PFB_TLIMIT_ADR_WORD                             0
#define NV_PFB_TLIMIT_ADR_HIGH_FIELD                       0x0000001A /* =26 */
#define NV_PFB_TLIMIT_ADR_LOW_FIELD                        0x0000000E /* =14 */
#define NV_PFB_TLIMIT_ADR_LO_MSK                           0x00003FFF /* 13:0 */ 
#define NV_PFB_TLIMIT_ADR_LO_RMSK                          0x00003FFF /* 13:0 */ 
#define NV_PFB_TLIMIT_ADR_LO_WORD                          0
#define NV_PFB_TLIMIT_ADR_LO_HIGH_FIELD                    0x0000000D /* =13 */
#define NV_PFB_TLIMIT_ADR_LO_LOW_FIELD                     0x00000000 /* =0 */
#define NV_PFB_TLIMIT_ADR_LO_3FFF_ADJ                      0x00003FFF
#define NV_PFB_TLIMIT_MSK                                  0x07FFFFFF 
#define NV_PFB_TSIZE_PITCH_MSK                             0x0000FF00 /* 15:8 */ 
#define NV_PFB_TSIZE_PITCH_RMSK                            0x000000FF /* 15:8 */ 
#define NV_PFB_TSIZE_PITCH_WORD                            0
#define NV_PFB_TSIZE_PITCH_HIGH_FIELD                      0x0000000F /* =15 */
#define NV_PFB_TSIZE_PITCH_LOW_FIELD                       0x00000008 /* =8 */
#define NV_PFB_TSIZE_PITCH_0200_ADJ                        0x00000200
#define NV_PFB_TSIZE_PITCH_0400_ADJ                        0x00000400
#define NV_PFB_TSIZE_PITCH_0600_ADJ                        0x00000600
#define NV_PFB_TSIZE_PITCH_0800_ADJ                        0x00000800
#define NV_PFB_TSIZE_PITCH_0A00_ADJ                        0x00000A00
#define NV_PFB_TSIZE_PITCH_0C00_ADJ                        0x00000C00
#define NV_PFB_TSIZE_PITCH_0E00_ADJ                        0x00000E00
#define NV_PFB_TSIZE_PITCH_1000_ADJ                        0x00001000
#define NV_PFB_TSIZE_PITCH_1400_ADJ                        0x00001400
#define NV_PFB_TSIZE_PITCH_1800_ADJ                        0x00001800
#define NV_PFB_TSIZE_PITCH_1C00_ADJ                        0x00001C00
#define NV_PFB_TSIZE_PITCH_2000_ADJ                        0x00002000
#define NV_PFB_TSIZE_PITCH_2800_ADJ                        0x00002800
#define NV_PFB_TSIZE_PITCH_3000_ADJ                        0x00003000
#define NV_PFB_TSIZE_PITCH_3800_ADJ                        0x00003800
#define NV_PFB_TSIZE_PITCH_4000_ADJ                        0x00004000
#define NV_PFB_TSIZE_PITCH_5000_ADJ                        0x00005000
#define NV_PFB_TSIZE_PITCH_6000_ADJ                        0x00006000
#define NV_PFB_TSIZE_PITCH_7000_ADJ                        0x00007000
#define NV_PFB_TSIZE_PITCH_8000_ADJ                        0x00008000
#define NV_PFB_TSIZE_PITCH_A000_ADJ                        0x0000A000
#define NV_PFB_TSIZE_PITCH_C000_ADJ                        0x0000C000
#define NV_PFB_TSIZE_PITCH_E000_ADJ                        0x0000E000
#define NV_PFB_TSIZE_MSK                                   0x0000FF00 
#define NV_PFB_TSTATUS_PRIME_MSK                           0x00000003 /* 1:0 */ 
#define NV_PFB_TSTATUS_PRIME_RMSK                          0x00000003 /* 1:0 */ 
#define NV_PFB_TSTATUS_PRIME_WORD                          0
#define NV_PFB_TSTATUS_PRIME_HIGH_FIELD                    0x00000001 /* =1 */
#define NV_PFB_TSTATUS_PRIME_LOW_FIELD                     0x00000000 /* =0 */
#define NV_PFB_TSTATUS_PRIME_1_ADJ                         0x00000000
#define NV_PFB_TSTATUS_PRIME_3_ADJ                         0x00000001
#define NV_PFB_TSTATUS_PRIME_5_ADJ                         0x00000002
#define NV_PFB_TSTATUS_PRIME_7_ADJ                         0x00000003
#define NV_PFB_TSTATUS_FACTOR_MSK                          0x00000070 /* 6:4 */ 
#define NV_PFB_TSTATUS_FACTOR_RMSK                         0x00000007 /* 6:4 */ 
#define NV_PFB_TSTATUS_FACTOR_WORD                         0
#define NV_PFB_TSTATUS_FACTOR_HIGH_FIELD                   0x00000006 /* =6 */
#define NV_PFB_TSTATUS_FACTOR_LOW_FIELD                    0x00000004 /* =4 */
#define NV_PFB_TSTATUS_FACTOR_1_ADJ                        0x00000000
#define NV_PFB_TSTATUS_FACTOR_2_ADJ                        0x00000010
#define NV_PFB_TSTATUS_FACTOR_4_ADJ                        0x00000020
#define NV_PFB_TSTATUS_FACTOR_8_ADJ                        0x00000030
#define NV_PFB_TSTATUS_FACTOR_16_ADJ                       0x00000040
#define NV_PFB_TSTATUS_FACTOR_32_ADJ                       0x00000050
#define NV_PFB_TSTATUS_FACTOR_64_ADJ                       0x00000060
#define NV_PFB_TSTATUS_FACTOR_128_ADJ                      0x00000070
#define NV_PFB_TSTATUS_REGION_MSK                          0x80000000 /* 31:31 */ 
#define NV_PFB_TSTATUS_REGION_RMSK                         0x00000001 /* 31:31 */ 
#define NV_PFB_TSTATUS_REGION_WORD                         0
#define NV_PFB_TSTATUS_REGION_HIGH_FIELD                   0x0000001F /* =31 */
#define NV_PFB_TSTATUS_REGION_LOW_FIELD                    0x0000001F /* =31 */
#define NV_PFB_TSTATUS_REGION_INVALID_ADJ                  0x00000000
#define NV_PFB_TSTATUS_REGION_VALID_ADJ                    0x80000000
#define NV_PFB_TSTATUS_MSK                                 0x80000073 
#define NV_PFB_MRS_BL_MSK                                  0x00000007 /* 2:0 */ 
#define NV_PFB_MRS_BL_RMSK                                 0x00000007 /* 2:0 */ 
#define NV_PFB_MRS_BL_WORD                                 0
#define NV_PFB_MRS_BL_HIGH_FIELD                           0x00000002 /* =2 */
#define NV_PFB_MRS_BL_LOW_FIELD                            0x00000000 /* =0 */
#define NV_PFB_MRS_BL_1_ADJ                                0x00000000
#define NV_PFB_MRS_BL_2_ADJ                                0x00000001
#define NV_PFB_MRS_BT_MSK                                  0x00000008 /* 3:3 */ 
#define NV_PFB_MRS_BT_RMSK                                 0x00000001 /* 3:3 */ 
#define NV_PFB_MRS_BT_WORD                                 0
#define NV_PFB_MRS_BT_HIGH_FIELD                           0x00000003 /* =3 */
#define NV_PFB_MRS_BT_LOW_FIELD                            0x00000003 /* =3 */
#define NV_PFB_MRS_BT_SEQ_ADJ                              0x00000000
#define NV_PFB_MRS_CL_MSK                                  0x00000070 /* 6:4 */ 
#define NV_PFB_MRS_CL_RMSK                                 0x00000007 /* 6:4 */ 
#define NV_PFB_MRS_CL_WORD                                 0
#define NV_PFB_MRS_CL_HIGH_FIELD                           0x00000006 /* =6 */
#define NV_PFB_MRS_CL_LOW_FIELD                            0x00000004 /* =4 */
#define NV_PFB_MRS_CL_2_ADJ                                0x00000020
#define NV_PFB_MRS_CL_3_ADJ                                0x00000030
#define NV_PFB_MRS_CL_4_ADJ                                0x00000040
#define NV_PFB_MRS_R0_MSK                                  0x00000080 /* 7:7 */ 
#define NV_PFB_MRS_R0_RMSK                                 0x00000001 /* 7:7 */ 
#define NV_PFB_MRS_R0_WORD                                 0
#define NV_PFB_MRS_R0_HIGH_FIELD                           0x00000007 /* =7 */
#define NV_PFB_MRS_R0_LOW_FIELD                            0x00000007 /* =7 */
#define NV_PFB_MRS_R0_NORMAL_ADJ                           0x00000000
#define NV_PFB_MRS_DLL_MSK                                 0x00000100 /* 8:8 */ 
#define NV_PFB_MRS_DLL_RMSK                                0x00000001 /* 8:8 */ 
#define NV_PFB_MRS_DLL_WORD                                0
#define NV_PFB_MRS_DLL_HIGH_FIELD                          0x00000008 /* =8 */
#define NV_PFB_MRS_DLL_LOW_FIELD                           0x00000008 /* =8 */
#define NV_PFB_MRS_DLL_NORMAL_ADJ                          0x00000000
#define NV_PFB_MRS_DLL_RESET_ADJ                           0x00000100
#define NV_PFB_MRS_R1_MSK                                  0x00000E00 /* 11:9 */ 
#define NV_PFB_MRS_R1_RMSK                                 0x00000007 /* 11:9 */ 
#define NV_PFB_MRS_R1_WORD                                 0
#define NV_PFB_MRS_R1_HIGH_FIELD                           0x0000000B /* =11 */
#define NV_PFB_MRS_R1_LOW_FIELD                            0x00000009 /* =9 */
#define NV_PFB_MRS_R1_NORMAL_ADJ                           0x00000000
#define NV_PFB_MRS_MSK                                     0x00000FFF 
#define NV_PFB_EMRS_DLL_MSK                                0x00000001 /* 0:0 */ 
#define NV_PFB_EMRS_DLL_RMSK                               0x00000001 /* 0:0 */ 
#define NV_PFB_EMRS_DLL_WORD                               0
#define NV_PFB_EMRS_DLL_HIGH_FIELD                         0x00000000 /* =0 */
#define NV_PFB_EMRS_DLL_LOW_FIELD                          0x00000000 /* =0 */
#define NV_PFB_EMRS_DLL_ENABLE_ADJ                         0x00000000
#define NV_PFB_EMRS_DLL_DISABLE_ADJ                        0x00000001
#define NV_PFB_EMRS_R0_MSK                                 0x00000FFE /* 11:1 */ 
#define NV_PFB_EMRS_R0_RMSK                                0x000007FF /* 11:1 */ 
#define NV_PFB_EMRS_R0_WORD                                0
#define NV_PFB_EMRS_R0_HIGH_FIELD                          0x0000000B /* =11 */
#define NV_PFB_EMRS_R0_LOW_FIELD                           0x00000001 /* =1 */
#define NV_PFB_EMRS_R0_NORMAL_ADJ                          0x00000000
#define NV_PFB_EMRS_MSK                                    0x00000FFF 
#define NV_PFB_REF_CMD_MSK                                 0x00000001 /* 0:0 */ 
#define NV_PFB_REF_CMD_RMSK                                0x00000001 /* 0:0 */ 
#define NV_PFB_REF_CMD_WORD                                0
#define NV_PFB_REF_CMD_HIGH_FIELD                          0x00000000 /* =0 */
#define NV_PFB_REF_CMD_LOW_FIELD                           0x00000000 /* =0 */
#define NV_PFB_REF_CMD_REFRESH_ADJ                         0x00000001
#define NV_PFB_REF_MSK                                     0x00000001 
#define NV_PFB_PRE_CMD_MSK                                 0x00000001 /* 0:0 */ 
#define NV_PFB_PRE_CMD_RMSK                                0x00000001 /* 0:0 */ 
#define NV_PFB_PRE_CMD_WORD                                0
#define NV_PFB_PRE_CMD_HIGH_FIELD                          0x00000000 /* =0 */
#define NV_PFB_PRE_CMD_LOW_FIELD                           0x00000000 /* =0 */
#define NV_PFB_PRE_CMD_PRECHARGE_ADJ                       0x00000001
#define NV_PFB_PRE_MSK                                     0x00000001 
#define NV_PFB_STRAP_PCI_AD_MSK                            0x00000001 /* 0:0 */ 
#define NV_PFB_STRAP_PCI_AD_RMSK                           0x00000001 /* 0:0 */ 
#define NV_PFB_STRAP_PCI_AD_WORD                           0
#define NV_PFB_STRAP_PCI_AD_HIGH_FIELD                     0x00000000 /* =0 */
#define NV_PFB_STRAP_PCI_AD_LOW_FIELD                      0x00000000 /* =0 */
#define NV_PFB_STRAP_PCI_AD_REVERSED_ADJ                   0x00000000
#define NV_PFB_STRAP_PCI_AD_NORMAL_ADJ                     0x00000001
#define NV_PFB_STRAP_SUB_VENDOR_MSK                        0x00000002 /* 1:1 */ 
#define NV_PFB_STRAP_SUB_VENDOR_RMSK                       0x00000001 /* 1:1 */ 
#define NV_PFB_STRAP_SUB_VENDOR_WORD                       0
#define NV_PFB_STRAP_SUB_VENDOR_HIGH_FIELD                 0x00000001 /* =1 */
#define NV_PFB_STRAP_SUB_VENDOR_LOW_FIELD                  0x00000001 /* =1 */
#define NV_PFB_STRAP_SUB_VENDOR_NO_BIOS_ADJ                0x00000000
#define NV_PFB_STRAP_SUB_VENDOR_BIOS_ADJ                   0x00000002
#define NV_PFB_STRAP_RAMCFG_MSK                            0x0000003C /* 5:2 */ 
#define NV_PFB_STRAP_RAMCFG_RMSK                           0x0000000F /* 5:2 */ 
#define NV_PFB_STRAP_RAMCFG_WORD                           0
#define NV_PFB_STRAP_RAMCFG_HIGH_FIELD                     0x00000005 /* =5 */
#define NV_PFB_STRAP_RAMCFG_LOW_FIELD                      0x00000002 /* =2 */
#define NV_PFB_STRAP_CRYSTAL_MSK                           0x00000040 /* 6:6 */ 
#define NV_PFB_STRAP_CRYSTAL_RMSK                          0x00000001 /* 6:6 */ 
#define NV_PFB_STRAP_CRYSTAL_WORD                          0
#define NV_PFB_STRAP_CRYSTAL_HIGH_FIELD                    0x00000006 /* =6 */
#define NV_PFB_STRAP_CRYSTAL_LOW_FIELD                     0x00000006 /* =6 */
#define NV_PFB_STRAP_CRYSTAL_13500K_ADJ                    0x00000000
#define NV_PFB_STRAP_CRYSTAL_14318180_ADJ                  0x00000040
#define NV_PFB_STRAP_TVMODE_MSK                            0x00000180 /* 8:7 */ 
#define NV_PFB_STRAP_TVMODE_RMSK                           0x00000003 /* 8:7 */ 
#define NV_PFB_STRAP_TVMODE_WORD                           0
#define NV_PFB_STRAP_TVMODE_HIGH_FIELD                     0x00000008 /* =8 */
#define NV_PFB_STRAP_TVMODE_LOW_FIELD                      0x00000007 /* =7 */
#define NV_PFB_STRAP_TVMODE_SECAM_ADJ                      0x00000000
#define NV_PFB_STRAP_TVMODE_NTSC_ADJ                       0x00000080
#define NV_PFB_STRAP_TVMODE_PAL_ADJ                        0x00000100
#define NV_PFB_STRAP_TVMODE_DISABLED_ADJ                   0x00000180
#define NV_PFB_STRAP_AGP_4X_MSK                            0x00000200 /* 9:9 */ 
#define NV_PFB_STRAP_AGP_4X_RMSK                           0x00000001 /* 9:9 */ 
#define NV_PFB_STRAP_AGP_4X_WORD                           0
#define NV_PFB_STRAP_AGP_4X_HIGH_FIELD                     0x00000009 /* =9 */
#define NV_PFB_STRAP_AGP_4X_LOW_FIELD                      0x00000009 /* =9 */
#define NV_PFB_STRAP_AGP_4X_ENABLED_ADJ                    0x00000000
#define NV_PFB_STRAP_AGP_4X_DISABLED_ADJ                   0x00000200
#define NV_PFB_STRAP_AGP_SBA_MSK                           0x00000400 /* 10:10 */ 
#define NV_PFB_STRAP_AGP_SBA_RMSK                          0x00000001 /* 10:10 */ 
#define NV_PFB_STRAP_AGP_SBA_WORD                          0
#define NV_PFB_STRAP_AGP_SBA_HIGH_FIELD                    0x0000000A /* =10 */
#define NV_PFB_STRAP_AGP_SBA_LOW_FIELD                     0x0000000A /* =10 */
#define NV_PFB_STRAP_AGP_SBA_ENABLED_ADJ                   0x00000000
#define NV_PFB_STRAP_AGP_SBA_DISABLED_ADJ                  0x00000400
#define NV_PFB_STRAP_AGP_FASTWR_MSK                        0x00000800 /* 11:11 */ 
#define NV_PFB_STRAP_AGP_FASTWR_RMSK                       0x00000001 /* 11:11 */ 
#define NV_PFB_STRAP_AGP_FASTWR_WORD                       0
#define NV_PFB_STRAP_AGP_FASTWR_HIGH_FIELD                 0x0000000B /* =11 */
#define NV_PFB_STRAP_AGP_FASTWR_LOW_FIELD                  0x0000000B /* =11 */
#define NV_PFB_STRAP_AGP_FASTWR_ENABLED_ADJ                0x00000000
#define NV_PFB_STRAP_AGP_FASTWR_DISABLED_ADJ               0x00000800
#define NV_PFB_STRAP_PCI_DEVID_MSK                         0x00003000 /* 13:12 */ 
#define NV_PFB_STRAP_PCI_DEVID_RMSK                        0x00000003 /* 13:12 */ 
#define NV_PFB_STRAP_PCI_DEVID_WORD                        0
#define NV_PFB_STRAP_PCI_DEVID_HIGH_FIELD                  0x0000000D /* =13 */
#define NV_PFB_STRAP_PCI_DEVID_LOW_FIELD                   0x0000000C /* =12 */
#define NV_PFB_STRAP_PCI_DEVID_20_ADJ                      0x00000000
#define NV_PFB_STRAP_PCI_DEVID_21_ADJ                      0x00001000
#define NV_PFB_STRAP_PCI_DEVID_22_ADJ                      0x00002000
#define NV_PFB_STRAP_PCI_DEVID_23_ADJ                      0x00003000
#define NV_PFB_STRAP_AGP_MSK                               0x00004000 /* 14:14 */ 
#define NV_PFB_STRAP_AGP_RMSK                              0x00000001 /* 14:14 */ 
#define NV_PFB_STRAP_AGP_WORD                              0
#define NV_PFB_STRAP_AGP_HIGH_FIELD                        0x0000000E /* =14 */
#define NV_PFB_STRAP_AGP_LOW_FIELD                         0x0000000E /* =14 */
#define NV_PFB_STRAP_AGP_DISABLED_ADJ                      0x00000000
#define NV_PFB_STRAP_AGP_ENABLED_ADJ                       0x00004000
#define NV_PFB_STRAP_FP_IFACE_MSK                          0x00008000 /* 15:15 */ 
#define NV_PFB_STRAP_FP_IFACE_RMSK                         0x00000001 /* 15:15 */ 
#define NV_PFB_STRAP_FP_IFACE_WORD                         0
#define NV_PFB_STRAP_FP_IFACE_HIGH_FIELD                   0x0000000F /* =15 */
#define NV_PFB_STRAP_FP_IFACE_LOW_FIELD                    0x0000000F /* =15 */
#define NV_PFB_STRAP_FP_IFACE_24BIT_ADJ                    0x00000000
#define NV_PFB_STRAP_FP_IFACE_12BIT_ADJ                    0x00008000
#define NV_PFB_STRAP_OVERWRITE_MSK                         0x80000000 /* 31:31 */ 
#define NV_PFB_STRAP_OVERWRITE_RMSK                        0x00000001 /* 31:31 */ 
#define NV_PFB_STRAP_OVERWRITE_WORD                        0
#define NV_PFB_STRAP_OVERWRITE_HIGH_FIELD                  0x0000001F /* =31 */
#define NV_PFB_STRAP_OVERWRITE_LOW_FIELD                   0x0000001F /* =31 */
#define NV_PFB_STRAP_OVERWRITE_DISABLED_ADJ                0x00000000
#define NV_PFB_STRAP_OVERWRITE_ENABLED_ADJ                 0x80000000
#define NV_PFB_STRAP_MSK                                   0x8000FFFF 
#define NV_PFB_NEW_STRAP_VALUE_MSK                         0x0000FFFF /* 15:0 */ 
#define NV_PFB_NEW_STRAP_VALUE_RMSK                        0x0000FFFF /* 15:0 */ 
#define NV_PFB_NEW_STRAP_VALUE_WORD                        0
#define NV_PFB_NEW_STRAP_VALUE_HIGH_FIELD                  0x0000000F /* =15 */
#define NV_PFB_NEW_STRAP_VALUE_LOW_FIELD                   0x00000000 /* =0 */
#define NV_PFB_NEW_STRAP_OVERWRITE_MSK                     0x80000000 /* 31:31 */ 
#define NV_PFB_NEW_STRAP_OVERWRITE_RMSK                    0x00000001 /* 31:31 */ 
#define NV_PFB_NEW_STRAP_OVERWRITE_WORD                    0
#define NV_PFB_NEW_STRAP_OVERWRITE_HIGH_FIELD              0x0000001F /* =31 */
#define NV_PFB_NEW_STRAP_OVERWRITE_LOW_FIELD               0x0000001F /* =31 */
#define NV_PFB_NEW_STRAP_OVERWRITE_DISABLED_ADJ            0x00000000
#define NV_PFB_NEW_STRAP_OVERWRITE_ENABLED_ADJ             0x80000000
#define NV_PFB_NEW_STRAP_MSK                               0x8000FFFF 
#define NV_PFBM_HIGH_FIELD                                 0x0FFFFFFF /* =268435455 */
#define NV_PFBM_LOW_FIELD                                  0x08000000 /* =134217728 */
#define NV_PFBIN_HIGH_FIELD                                0x007FFFFF /* =8388607 */
#define NV_PFBIN_LOW_FIELD                                 0x00700000 /* =7340032 */
#define NV_PEXTDEV_HIGH_FIELD                              0x00101FFF /* =1056767 */
#define NV_PEXTDEV_LOW_FIELD                               0x00101000 /* =1052672 */
#define NV_PEXTDEV_BOOT_0_ADJ                              0x00101000
#define NV_PEXTDEV_BOOT_0_STRAP_PCI_AD_MSK                 0x00000001 /* 0:0 */ 
#define NV_PEXTDEV_BOOT_0_STRAP_PCI_AD_RMSK                0x00000001 /* 0:0 */ 
#define NV_PEXTDEV_BOOT_0_STRAP_PCI_AD_WORD                0
#define NV_PEXTDEV_BOOT_0_STRAP_PCI_AD_HIGH_FIELD          0x00000000 /* =0 */
#define NV_PEXTDEV_BOOT_0_STRAP_PCI_AD_LOW_FIELD           0x00000000 /* =0 */
#define NV_PEXTDEV_BOOT_0_STRAP_PCI_AD_REVERSED_ADJ        0x00000000
#define NV_PEXTDEV_BOOT_0_STRAP_PCI_AD_NORMAL_ADJ          0x00000001
#define NV_PEXTDEV_BOOT_0_STRAP_SUB_VENDOR_MSK             0x00000002 /* 1:1 */ 
#define NV_PEXTDEV_BOOT_0_STRAP_SUB_VENDOR_RMSK            0x00000001 /* 1:1 */ 
#define NV_PEXTDEV_BOOT_0_STRAP_SUB_VENDOR_WORD            0
#define NV_PEXTDEV_BOOT_0_STRAP_SUB_VENDOR_HIGH_FIELD      0x00000001 /* =1 */
#define NV_PEXTDEV_BOOT_0_STRAP_SUB_VENDOR_LOW_FIELD       0x00000001 /* =1 */
#define NV_PEXTDEV_BOOT_0_STRAP_SUB_VENDOR_NO_BIOS_ADJ     0x00000000
#define NV_PEXTDEV_BOOT_0_STRAP_SUB_VENDOR_BIOS_ADJ        0x00000002
#define NV_PEXTDEV_BOOT_0_STRAP_RAMCFG_MSK                 0x0000003C /* 5:2 */ 
#define NV_PEXTDEV_BOOT_0_STRAP_RAMCFG_RMSK                0x0000000F /* 5:2 */ 
#define NV_PEXTDEV_BOOT_0_STRAP_RAMCFG_WORD                0
#define NV_PEXTDEV_BOOT_0_STRAP_RAMCFG_HIGH_FIELD          0x00000005 /* =5 */
#define NV_PEXTDEV_BOOT_0_STRAP_RAMCFG_LOW_FIELD           0x00000002 /* =2 */
#define NV_PEXTDEV_BOOT_0_STRAP_CRYSTAL_MSK                0x00000040 /* 6:6 */ 
#define NV_PEXTDEV_BOOT_0_STRAP_CRYSTAL_RMSK               0x00000001 /* 6:6 */ 
#define NV_PEXTDEV_BOOT_0_STRAP_CRYSTAL_WORD               0
#define NV_PEXTDEV_BOOT_0_STRAP_CRYSTAL_HIGH_FIELD         0x00000006 /* =6 */
#define NV_PEXTDEV_BOOT_0_STRAP_CRYSTAL_LOW_FIELD          0x00000006 /* =6 */
#define NV_PEXTDEV_BOOT_0_STRAP_CRYSTAL_13500K_ADJ         0x00000000
#define NV_PEXTDEV_BOOT_0_STRAP_CRYSTAL_14318180_ADJ       0x00000040
#define NV_PEXTDEV_BOOT_0_STRAP_TVMODE_MSK                 0x00000180 /* 8:7 */ 
#define NV_PEXTDEV_BOOT_0_STRAP_TVMODE_RMSK                0x00000003 /* 8:7 */ 
#define NV_PEXTDEV_BOOT_0_STRAP_TVMODE_WORD                0
#define NV_PEXTDEV_BOOT_0_STRAP_TVMODE_HIGH_FIELD          0x00000008 /* =8 */
#define NV_PEXTDEV_BOOT_0_STRAP_TVMODE_LOW_FIELD           0x00000007 /* =7 */
#define NV_PEXTDEV_BOOT_0_STRAP_TVMODE_PAL_ADJ             0x00000000
#define NV_PEXTDEV_BOOT_0_STRAP_TVMODE_NTSC_ADJ            0x00000080
#define NV_PEXTDEV_BOOT_0_STRAP_TVMODE_RESERVED_ADJ        0x00000100
#define NV_PEXTDEV_BOOT_0_STRAP_TVMODE_DISABLED_ADJ        0x00000180
#define NV_PEXTDEV_BOOT_0_STRAP_AGP_4X_MSK                 0x00000200 /* 9:9 */ 
#define NV_PEXTDEV_BOOT_0_STRAP_AGP_4X_RMSK                0x00000001 /* 9:9 */ 
#define NV_PEXTDEV_BOOT_0_STRAP_AGP_4X_WORD                0
#define NV_PEXTDEV_BOOT_0_STRAP_AGP_4X_HIGH_FIELD          0x00000009 /* =9 */
#define NV_PEXTDEV_BOOT_0_STRAP_AGP_4X_LOW_FIELD           0x00000009 /* =9 */
#define NV_PEXTDEV_BOOT_0_STRAP_AGP_4X_ENABLED_ADJ         0x00000000
#define NV_PEXTDEV_BOOT_0_STRAP_AGP_4X_DISABLED_ADJ        0x00000200
#define NV_PEXTDEV_BOOT_0_STRAP_AGP_SBA_MSK                0x00000400 /* 10:10 */ 
#define NV_PEXTDEV_BOOT_0_STRAP_AGP_SBA_RMSK               0x00000001 /* 10:10 */ 
#define NV_PEXTDEV_BOOT_0_STRAP_AGP_SBA_WORD               0
#define NV_PEXTDEV_BOOT_0_STRAP_AGP_SBA_HIGH_FIELD         0x0000000A /* =10 */
#define NV_PEXTDEV_BOOT_0_STRAP_AGP_SBA_LOW_FIELD          0x0000000A /* =10 */
#define NV_PEXTDEV_BOOT_0_STRAP_AGP_SBA_ENABLED_ADJ        0x00000000
#define NV_PEXTDEV_BOOT_0_STRAP_AGP_SBA_DISABLED_ADJ       0x00000400
#define NV_PEXTDEV_BOOT_0_STRAP_AGP_FASTWR_MSK             0x00000800 /* 11:11 */ 
#define NV_PEXTDEV_BOOT_0_STRAP_AGP_FASTWR_RMSK            0x00000001 /* 11:11 */ 
#define NV_PEXTDEV_BOOT_0_STRAP_AGP_FASTWR_WORD            0
#define NV_PEXTDEV_BOOT_0_STRAP_AGP_FASTWR_HIGH_FIELD      0x0000000B /* =11 */
#define NV_PEXTDEV_BOOT_0_STRAP_AGP_FASTWR_LOW_FIELD       0x0000000B /* =11 */
#define NV_PEXTDEV_BOOT_0_STRAP_AGP_FASTWR_ENABLED_ADJ     0x00000000
#define NV_PEXTDEV_BOOT_0_STRAP_AGP_FASTWR_DISABLED_ADJ    0x00000800
#define NV_PEXTDEV_BOOT_0_STRAP_PCI_DEVID_MSK              0x00003000 /* 13:12 */ 
#define NV_PEXTDEV_BOOT_0_STRAP_PCI_DEVID_RMSK             0x00000003 /* 13:12 */ 
#define NV_PEXTDEV_BOOT_0_STRAP_PCI_DEVID_WORD             0
#define NV_PEXTDEV_BOOT_0_STRAP_PCI_DEVID_HIGH_FIELD       0x0000000D /* =13 */
#define NV_PEXTDEV_BOOT_0_STRAP_PCI_DEVID_LOW_FIELD        0x0000000C /* =12 */
#define NV_PEXTDEV_BOOT_0_STRAP_PCI_DEVID_0_ADJ            0x00000000
#define NV_PEXTDEV_BOOT_0_STRAP_PCI_DEVID_1_ADJ            0x00001000
#define NV_PEXTDEV_BOOT_0_STRAP_PCI_DEVID_2_ADJ            0x00002000
#define NV_PEXTDEV_BOOT_0_STRAP_PCI_DEVID_3_ADJ            0x00003000
#define NV_PEXTDEV_BOOT_0_STRAP_BUS_TYPE_MSK               0x00004000 /* 14:14 */ 
#define NV_PEXTDEV_BOOT_0_STRAP_BUS_TYPE_RMSK              0x00000001 /* 14:14 */ 
#define NV_PEXTDEV_BOOT_0_STRAP_BUS_TYPE_WORD              0
#define NV_PEXTDEV_BOOT_0_STRAP_BUS_TYPE_HIGH_FIELD        0x0000000E /* =14 */
#define NV_PEXTDEV_BOOT_0_STRAP_BUS_TYPE_LOW_FIELD         0x0000000E /* =14 */
#define NV_PEXTDEV_BOOT_0_STRAP_BUS_TYPE_PCI_ADJ           0x00000000
#define NV_PEXTDEV_BOOT_0_STRAP_BUS_TYPE_AGP_ADJ           0x00004000
#define NV_PEXTDEV_BOOT_0_STRAP_FP_IFACE_MSK               0x00008000 /* 15:15 */ 
#define NV_PEXTDEV_BOOT_0_STRAP_FP_IFACE_RMSK              0x00000001 /* 15:15 */ 
#define NV_PEXTDEV_BOOT_0_STRAP_FP_IFACE_WORD              0
#define NV_PEXTDEV_BOOT_0_STRAP_FP_IFACE_HIGH_FIELD        0x0000000F /* =15 */
#define NV_PEXTDEV_BOOT_0_STRAP_FP_IFACE_LOW_FIELD         0x0000000F /* =15 */
#define NV_PEXTDEV_BOOT_0_STRAP_FP_IFACE_24BIT_ADJ         0x00000000
#define NV_PEXTDEV_BOOT_0_STRAP_FP_IFACE_12BIT_ADJ         0x00008000
#define NV_PEXTDEV_BOOT_0_STRAP_OVERWRITE_MSK              0x80000000 /* 31:31 */ 
#define NV_PEXTDEV_BOOT_0_STRAP_OVERWRITE_RMSK             0x00000001 /* 31:31 */ 
#define NV_PEXTDEV_BOOT_0_STRAP_OVERWRITE_WORD             0
#define NV_PEXTDEV_BOOT_0_STRAP_OVERWRITE_HIGH_FIELD       0x0000001F /* =31 */
#define NV_PEXTDEV_BOOT_0_STRAP_OVERWRITE_LOW_FIELD        0x0000001F /* =31 */
#define NV_PEXTDEV_BOOT_0_STRAP_OVERWRITE_DISABLED_ADJ     0x00000000
#define NV_PEXTDEV_BOOT_0_STRAP_OVERWRITE_ENABLED_ADJ      0x80000000
#define NV_PEXTDEV_BOOT_0_MSK                              0x8000FFFF 
#define NV_PEXTDEV_NEW_BOOT_0_STRAP_VALUE_MSK              0x0000FFFF /* 15:0 */ 
#define NV_PEXTDEV_NEW_BOOT_0_STRAP_VALUE_RMSK             0x0000FFFF /* 15:0 */ 
#define NV_PEXTDEV_NEW_BOOT_0_STRAP_VALUE_WORD             0
#define NV_PEXTDEV_NEW_BOOT_0_STRAP_VALUE_HIGH_FIELD       0x0000000F /* =15 */
#define NV_PEXTDEV_NEW_BOOT_0_STRAP_VALUE_LOW_FIELD        0x00000000 /* =0 */
#define NV_PEXTDEV_NEW_BOOT_0_STRAP_OVERWRITE_MSK          0x80000000 /* 31:31 */ 
#define NV_PEXTDEV_NEW_BOOT_0_STRAP_OVERWRITE_RMSK         0x00000001 /* 31:31 */ 
#define NV_PEXTDEV_NEW_BOOT_0_STRAP_OVERWRITE_WORD         0
#define NV_PEXTDEV_NEW_BOOT_0_STRAP_OVERWRITE_HIGH_FIELD   0x0000001F /* =31 */
#define NV_PEXTDEV_NEW_BOOT_0_STRAP_OVERWRITE_LOW_FIELD    0x0000001F /* =31 */
#define NV_PEXTDEV_NEW_BOOT_0_STRAP_OVERWRITE_DISABLED_ADJ 0x00000000
#define NV_PEXTDEV_NEW_BOOT_0_STRAP_OVERWRITE_ENABLED_ADJ  0x80000000
#define NV_PEXTDEV_NEW_BOOT_0_MSK                          0x8000FFFF 
#define NV_PDAC_HIGH_FIELD                                 0x00680FFF /* =6819839 */
#define NV_PDAC_LOW_FIELD                                  0x00680000 /* =6815744 */
#define NV_PDAC_DATA_VALUE_MSK                             0x000000FF /* 7:0 */ 
#define NV_PDAC_DATA_VALUE_RMSK                            0x000000FF /* 7:0 */ 
#define NV_PDAC_DATA_VALUE_WORD                            0
#define NV_PDAC_DATA_VALUE_HIGH_FIELD                      0x00000007 /* =7 */
#define NV_PDAC_DATA_VALUE_LOW_FIELD                       0x00000000 /* =0 */
#define NV_PDAC_DATA_MSK                                   0x000000FF 
#define NV_PROM_HIGH_FIELD                                 0x0030FFFF /* =3211263 */
#define NV_PROM_LOW_FIELD                                  0x00300000 /* =3145728 */
#define NV_PROM_DATA_VALUE_MSK                             0x000000FF /* 7:0 */ 
#define NV_PROM_DATA_VALUE_RMSK                            0x000000FF /* 7:0 */ 
#define NV_PROM_DATA_VALUE_WORD                            0
#define NV_PROM_DATA_VALUE_HIGH_FIELD                      0x00000007 /* =7 */
#define NV_PROM_DATA_VALUE_LOW_FIELD                       0x00000000 /* =0 */
#define NV_PROM_DATA_MSK                                   0x000000FF 
#define NV_UDMA_OBJECT_HANDLE_MSK                          0xFFFFFFFF /* 31:0 */ 
#define NV_UDMA_OBJECT_HANDLE_RMSK                         0xFFFFFFFF /* 31:0 */ 
#define NV_UDMA_OBJECT_HANDLE_WORD                         0
#define NV_UDMA_OBJECT_HANDLE_HIGH_FIELD                   0x0000001F /* =31 */
#define NV_UDMA_OBJECT_HANDLE_LOW_FIELD                    0x00000000 /* =0 */
#define NV_UDMA_SET_REF_CNT_MSK                            0xFFFFFFFF /* 31:0 */ 
#define NV_UDMA_SET_REF_CNT_RMSK                           0xFFFFFFFF /* 31:0 */ 
#define NV_UDMA_SET_REF_CNT_WORD                           0
#define NV_UDMA_SET_REF_CNT_HIGH_FIELD                     0x0000001F /* =31 */
#define NV_UDMA_SET_REF_CNT_LOW_FIELD                      0x00000000 /* =0 */
#define NV_UDMA_SEM_CTXDMA_HANDLE_MSK                      0xFFFFFFFF /* 31:0 */ 
#define NV_UDMA_SEM_CTXDMA_HANDLE_RMSK                     0xFFFFFFFF /* 31:0 */ 
#define NV_UDMA_SEM_CTXDMA_HANDLE_WORD                     0
#define NV_UDMA_SEM_CTXDMA_HANDLE_HIGH_FIELD               0x0000001F /* =31 */
#define NV_UDMA_SEM_CTXDMA_HANDLE_LOW_FIELD                0x00000000 /* =0 */
#define NV_UDMA_SEM_OFFSET_ADDRESS_MSK                     0x00000FFC /* 11:2 */ 
#define NV_UDMA_SEM_OFFSET_ADDRESS_RMSK                    0x000003FF /* 11:2 */ 
#define NV_UDMA_SEM_OFFSET_ADDRESS_WORD                    0
#define NV_UDMA_SEM_OFFSET_ADDRESS_HIGH_FIELD              0x0000000B /* =11 */
#define NV_UDMA_SEM_OFFSET_ADDRESS_LOW_FIELD               0x00000002 /* =2 */
#define NV_UDMA_SEM_ACQUIRE_VALUE_MSK                      0xFFFFFFFF /* 31:0 */ 
#define NV_UDMA_SEM_ACQUIRE_VALUE_RMSK                     0xFFFFFFFF /* 31:0 */ 
#define NV_UDMA_SEM_ACQUIRE_VALUE_WORD                     0
#define NV_UDMA_SEM_ACQUIRE_VALUE_HIGH_FIELD               0x0000001F /* =31 */
#define NV_UDMA_SEM_ACQUIRE_VALUE_LOW_FIELD                0x00000000 /* =0 */
#define NV_UDMA_SEM_RELEASE_VALUE_MSK                      0xFFFFFFFF /* 31:0 */ 
#define NV_UDMA_SEM_RELEASE_VALUE_RMSK                     0xFFFFFFFF /* 31:0 */ 
#define NV_UDMA_SEM_RELEASE_VALUE_WORD                     0
#define NV_UDMA_SEM_RELEASE_VALUE_HIGH_FIELD               0x0000001F /* =31 */
#define NV_UDMA_SEM_RELEASE_VALUE_LOW_FIELD                0x00000000 /* =0 */
#define NV_USER_ADR_CHID_MSK                               0x007F0000 /* 22:16 */ 
#define NV_USER_ADR_CHID_RMSK                              0x0000007F /* 22:16 */ 
#define NV_USER_ADR_CHID_WORD                              0
#define NV_USER_ADR_CHID_HIGH_FIELD                        0x00000016 /* =22 */
#define NV_USER_ADR_CHID_LOW_FIELD                         0x00000010 /* =16 */
#define NV_USER_ADR_SUBCHID_MSK                            0x0000E000 /* 15:13 */ 
#define NV_USER_ADR_SUBCHID_RMSK                           0x00000007 /* 15:13 */ 
#define NV_USER_ADR_SUBCHID_WORD                           0
#define NV_USER_ADR_SUBCHID_HIGH_FIELD                     0x0000000F /* =15 */
#define NV_USER_ADR_SUBCHID_LOW_FIELD                      0x0000000D /* =13 */
#define NV_USER_ADR_METHOD_MSK                             0x00001FFF /* 12:0 */ 
#define NV_USER_ADR_METHOD_RMSK                            0x00001FFF /* 12:0 */ 
#define NV_USER_ADR_METHOD_WORD                            0
#define NV_USER_ADR_METHOD_HIGH_FIELD                      0x0000000C /* =12 */
#define NV_USER_ADR_METHOD_LOW_FIELD                       0x00000000 /* =0 */
#define NV_USER_DEVICE_MSK                                 0x007F0000 /* 22:16 */ 
#define NV_USER_DEVICE_RMSK                                0x0000007F /* 22:16 */ 
#define NV_USER_DEVICE_WORD                                0
#define NV_USER_DEVICE_HIGH_FIELD                          0x00000016 /* =22 */
#define NV_USER_DEVICE_LOW_FIELD                           0x00000010 /* =16 */
#define NV_USER_HIGH_FIELD                                 0x00FFFFFF /* =16777215 */
#define NV_USER_LOW_FIELD                                  0x00800000 /* =8388608 */
#define NV_USER_OBJECT_HANDLE_MSK                          0xFFFFFFFF /* 31:0 */ 
#define NV_USER_OBJECT_HANDLE_RMSK                         0xFFFFFFFF /* 31:0 */ 
#define NV_USER_OBJECT_HANDLE_WORD                         0
#define NV_USER_OBJECT_HANDLE_HIGH_FIELD                   0x0000001F /* =31 */
#define NV_USER_OBJECT_HANDLE_LOW_FIELD                    0x00000000 /* =0 */
#define NV_USER_FREE016_COUNT_LO_MSK                       0x00000003 /* 1:0 */ 
#define NV_USER_FREE016_COUNT_LO_RMSK                      0x00000003 /* 1:0 */ 
#define NV_USER_FREE016_COUNT_LO_WORD                      0
#define NV_USER_FREE016_COUNT_LO_HIGH_FIELD                0x00000001 /* =1 */
#define NV_USER_FREE016_COUNT_LO_LOW_FIELD                 0x00000000 /* =0 */
#define NV_USER_FREE016_COUNT_LO_0_ADJ                     0x00000000
#define NV_USER_FREE016_COUNT_MSK                          0x000003FC /* 9:2 */ 
#define NV_USER_FREE016_COUNT_RMSK                         0x000000FF /* 9:2 */ 
#define NV_USER_FREE016_COUNT_WORD                         0
#define NV_USER_FREE016_COUNT_HIGH_FIELD                   0x00000009 /* =9 */
#define NV_USER_FREE016_COUNT_LOW_FIELD                    0x00000002 /* =2 */
#define NV_USER_FREE016_COUNT_HI_MSK                       0x0000FC00 /* 15:10 */ 
#define NV_USER_FREE016_COUNT_HI_RMSK                      0x0000003F /* 15:10 */ 
#define NV_USER_FREE016_COUNT_HI_WORD                      0
#define NV_USER_FREE016_COUNT_HI_HIGH_FIELD                0x0000000F /* =15 */
#define NV_USER_FREE016_COUNT_HI_LOW_FIELD                 0x0000000A /* =10 */
#define NV_USER_FREE016_COUNT_HI_0_ADJ                     0x00000000
#define NV_USER_FREE032_COUNT_LO_MSK                       0x00000003 /* 1:0 */ 
#define NV_USER_FREE032_COUNT_LO_RMSK                      0x00000003 /* 1:0 */ 
#define NV_USER_FREE032_COUNT_LO_WORD                      0
#define NV_USER_FREE032_COUNT_LO_HIGH_FIELD                0x00000001 /* =1 */
#define NV_USER_FREE032_COUNT_LO_LOW_FIELD                 0x00000000 /* =0 */
#define NV_USER_FREE032_COUNT_LO_0_ADJ                     0x00000000
#define NV_USER_FREE032_COUNT_MSK                          0x000003FC /* 9:2 */ 
#define NV_USER_FREE032_COUNT_RMSK                         0x000000FF /* 9:2 */ 
#define NV_USER_FREE032_COUNT_WORD                         0
#define NV_USER_FREE032_COUNT_HIGH_FIELD                   0x00000009 /* =9 */
#define NV_USER_FREE032_COUNT_LOW_FIELD                    0x00000002 /* =2 */
#define NV_USER_FREE032_COUNT_HI_MSK                       0xFFFFFC00 /* 31:10 */ 
#define NV_USER_FREE032_COUNT_HI_RMSK                      0x003FFFFF /* 31:10 */ 
#define NV_USER_FREE032_COUNT_HI_WORD                      0
#define NV_USER_FREE032_COUNT_HI_HIGH_FIELD                0x0000001F /* =31 */
#define NV_USER_FREE032_COUNT_HI_LOW_FIELD                 0x0000000A /* =10 */
#define NV_USER_FREE032_COUNT_HI_0_ADJ                     0x00000000
#define NV_USER_ZERO016_COUNT_MSK                          0x0000FFFF /* 15:0 */ 
#define NV_USER_ZERO016_COUNT_RMSK                         0x0000FFFF /* 15:0 */ 
#define NV_USER_ZERO016_COUNT_WORD                         0
#define NV_USER_ZERO016_COUNT_HIGH_FIELD                   0x0000000F /* =15 */
#define NV_USER_ZERO016_COUNT_LOW_FIELD                    0x00000000 /* =0 */
#define NV_USER_ZERO016_COUNT_0_ADJ                        0x00000000
#define NV_USER_ZERO032_COUNT_MSK                          0xFFFFFFFF /* 31:0 */ 
#define NV_USER_ZERO032_COUNT_RMSK                         0xFFFFFFFF /* 31:0 */ 
#define NV_USER_ZERO032_COUNT_WORD                         0
#define NV_USER_ZERO032_COUNT_HIGH_FIELD                   0x0000001F /* =31 */
#define NV_USER_ZERO032_COUNT_LOW_FIELD                    0x00000000 /* =0 */
#define NV_USER_ZERO032_COUNT_0_ADJ                        0x00000000
#define NV_USER_DMA_PUT_OFFSET_MSK                         0xFFFFFFFC /* 31:2 */ 
#define NV_USER_DMA_PUT_OFFSET_RMSK                        0x3FFFFFFF /* 31:2 */ 
#define NV_USER_DMA_PUT_OFFSET_WORD                        0
#define NV_USER_DMA_PUT_OFFSET_HIGH_FIELD                  0x0000001F /* =31 */
#define NV_USER_DMA_PUT_OFFSET_LOW_FIELD                   0x00000002 /* =2 */
#define NV_USER_DMA_GET_OFFSET_MSK                         0xFFFFFFFC /* 31:2 */ 
#define NV_USER_DMA_GET_OFFSET_RMSK                        0x3FFFFFFF /* 31:2 */ 
#define NV_USER_DMA_GET_OFFSET_WORD                        0
#define NV_USER_DMA_GET_OFFSET_HIGH_FIELD                  0x0000001F /* =31 */
#define NV_USER_DMA_GET_OFFSET_LOW_FIELD                   0x00000002 /* =2 */
#define NV_USER_REF_CNT_MSK                                0xFFFFFFFF /* 31:0 */ 
#define NV_USER_REF_CNT_RMSK                               0xFFFFFFFF /* 31:0 */ 
#define NV_USER_REF_CNT_WORD                               0
#define NV_USER_REF_CNT_HIGH_FIELD                         0x0000001F /* =31 */
#define NV_USER_REF_CNT_LOW_FIELD                          0x00000000 /* =0 */
#define NV_USER_ADR_CHID_MSK                               0x007F0000 /* 22:16 */ 
#define NV_USER_ADR_CHID_RMSK                              0x0000007F /* 22:16 */ 
#define NV_USER_ADR_CHID_WORD                              0
#define NV_USER_ADR_CHID_HIGH_FIELD                        0x00000016 /* =22 */
#define NV_USER_ADR_CHID_LOW_FIELD                         0x00000010 /* =16 */
#define NV_USER_ADR_SUBCHID_MSK                            0x0000E000 /* 15:13 */ 
#define NV_USER_ADR_SUBCHID_RMSK                           0x00000007 /* 15:13 */ 
#define NV_USER_ADR_SUBCHID_WORD                           0
#define NV_USER_ADR_SUBCHID_HIGH_FIELD                     0x0000000F /* =15 */
#define NV_USER_ADR_SUBCHID_LOW_FIELD                      0x0000000D /* =13 */
#define NV_USER_ADR_METHOD_MSK                             0x00001FFF /* 12:0 */ 
#define NV_USER_ADR_METHOD_RMSK                            0x00001FFF /* 12:0 */ 
#define NV_USER_ADR_METHOD_WORD                            0
#define NV_USER_ADR_METHOD_HIGH_FIELD                      0x0000000C /* =12 */
#define NV_USER_ADR_METHOD_LOW_FIELD                       0x00000000 /* =0 */
#define NV_USER_DEVICE_MSK                                 0x007F0000 /* 22:16 */ 
#define NV_USER_DEVICE_RMSK                                0x0000007F /* 22:16 */ 
#define NV_USER_DEVICE_WORD                                0
#define NV_USER_DEVICE_HIGH_FIELD                          0x00000016 /* =22 */
#define NV_USER_DEVICE_LOW_FIELD                           0x00000010 /* =16 */
#define NV_PTIMER_HIGH_FIELD                               0x00009FFF /* =40959 */
#define NV_PTIMER_LOW_FIELD                                0x00009000 /* =36864 */
#define NV_PTIMER_INTR_0_ADJ                               0x00009100
#define NV_PTIMER_INTR_0_ALARM_MSK                         0x00000001 /* 0:0 */ 
#define NV_PTIMER_INTR_0_ALARM_RMSK                        0x00000001 /* 0:0 */ 
#define NV_PTIMER_INTR_0_ALARM_WORD                        0
#define NV_PTIMER_INTR_0_ALARM_HIGH_FIELD                  0x00000000 /* =0 */
#define NV_PTIMER_INTR_0_ALARM_LOW_FIELD                   0x00000000 /* =0 */
#define NV_PTIMER_INTR_0_ALARM_NOT_PENDING_ADJ             0x00000000
#define NV_PTIMER_INTR_0_ALARM_PENDING_ADJ                 0x00000001
#define NV_PTIMER_INTR_0_ALARM_RESET_ADJ                   0x00000001
#define NV_PTIMER_INTR_0_MSK                               0x00000001 
#define NV_PTIMER_INTR_EN_0_ALARM_MSK                      0x00000001 /* 0:0 */ 
#define NV_PTIMER_INTR_EN_0_ALARM_RMSK                     0x00000001 /* 0:0 */ 
#define NV_PTIMER_INTR_EN_0_ALARM_WORD                     0
#define NV_PTIMER_INTR_EN_0_ALARM_HIGH_FIELD               0x00000000 /* =0 */
#define NV_PTIMER_INTR_EN_0_ALARM_LOW_FIELD                0x00000000 /* =0 */
#define NV_PTIMER_INTR_EN_0_ALARM_DISABLED_ADJ             0x00000000
#define NV_PTIMER_INTR_EN_0_ALARM_ENABLED_ADJ              0x00000001
#define NV_PTIMER_INTR_EN_0_MSK                            0x00000001 
#define NV_PTIMER_NUMERATOR_VALUE_MSK                      0x0000FFFF /* 15:0 */ 
#define NV_PTIMER_NUMERATOR_VALUE_RMSK                     0x0000FFFF /* 15:0 */ 
#define NV_PTIMER_NUMERATOR_VALUE_WORD                     0
#define NV_PTIMER_NUMERATOR_VALUE_HIGH_FIELD               0x0000000F /* =15 */
#define NV_PTIMER_NUMERATOR_VALUE_LOW_FIELD                0x00000000 /* =0 */
#define NV_PTIMER_NUMERATOR_VALUE_0_ADJ                    0x00000000
#define NV_PTIMER_NUMERATOR_MSK                            0x0000FFFF 
#define NV_PTIMER_DENOMINATOR_VALUE_MSK                    0x0000FFFF /* 15:0 */ 
#define NV_PTIMER_DENOMINATOR_VALUE_RMSK                   0x0000FFFF /* 15:0 */ 
#define NV_PTIMER_DENOMINATOR_VALUE_WORD                   0
#define NV_PTIMER_DENOMINATOR_VALUE_HIGH_FIELD             0x0000000F /* =15 */
#define NV_PTIMER_DENOMINATOR_VALUE_LOW_FIELD              0x00000000 /* =0 */
#define NV_PTIMER_DENOMINATOR_VALUE_0_ADJ                  0x00000000
#define NV_PTIMER_DENOMINATOR_MSK                          0x0000FFFF 
#define NV_PTIMER_TIME_0_NSEC_MSK                          0xFFFFFFE0 /* 31:5 */ 
#define NV_PTIMER_TIME_0_NSEC_RMSK                         0x07FFFFFF /* 31:5 */ 
#define NV_PTIMER_TIME_0_NSEC_WORD                         0
#define NV_PTIMER_TIME_0_NSEC_HIGH_FIELD                   0x0000001F /* =31 */
#define NV_PTIMER_TIME_0_NSEC_LOW_FIELD                    0x00000005 /* =5 */
#define NV_PTIMER_TIME_0_MSK                               0xFFFFFFE0 
#define NV_PTIMER_TIME_1_NSEC_MSK                          0x1FFFFFFF /* 28:0 */ 
#define NV_PTIMER_TIME_1_NSEC_RMSK                         0x1FFFFFFF /* 28:0 */ 
#define NV_PTIMER_TIME_1_NSEC_WORD                         0
#define NV_PTIMER_TIME_1_NSEC_HIGH_FIELD                   0x0000001C /* =28 */
#define NV_PTIMER_TIME_1_NSEC_LOW_FIELD                    0x00000000 /* =0 */
#define NV_PTIMER_TIME_1_MSK                               0x1FFFFFFF 
#define NV_PTIMER_ALARM_0_NSEC_MSK                         0xFFFFFFE0 /* 31:5 */ 
#define NV_PTIMER_ALARM_0_NSEC_RMSK                        0x07FFFFFF /* 31:5 */ 
#define NV_PTIMER_ALARM_0_NSEC_WORD                        0
#define NV_PTIMER_ALARM_0_NSEC_HIGH_FIELD                  0x0000001F /* =31 */
#define NV_PTIMER_ALARM_0_NSEC_LOW_FIELD                   0x00000005 /* =5 */
#define NV_PTIMER_ALARM_0_MSK                              0xFFFFFFE0 
#define NV_RAMHT__SIZE_0_HIGH_FIELD                        0x00000FFF /* =4095 */
#define NV_RAMHT__SIZE_0_LOW_FIELD                         0x00000000 /* =0 */
#define NV_RAMHT__SIZE_1_HIGH_FIELD                        0x00001FFF /* =8191 */
#define NV_RAMHT__SIZE_1_LOW_FIELD                         0x00000000 /* =0 */
#define NV_RAMHT__SIZE_2_HIGH_FIELD                        0x00003FFF /* =16383 */
#define NV_RAMHT__SIZE_2_LOW_FIELD                         0x00000000 /* =0 */
#define NV_RAMHT__SIZE_3_HIGH_FIELD                        0x00007FFF /* =32767 */
#define NV_RAMHT__SIZE_3_LOW_FIELD                         0x00000000 /* =0 */
#define NV_RAMHT_HANDLE_MSK                                0xFFFFFFFF /* 31:0 */ 
#define NV_RAMHT_HANDLE_RMSK                               0xFFFFFFFF /* 31:0 */ 
#define NV_RAMHT_HANDLE_WORD                               0
#define NV_RAMHT_HANDLE_HIGH_FIELD                         0x0000001F /* =31 */
#define NV_RAMHT_HANDLE_LOW_FIELD                          0x00000000 /* =0 */
#define NV_RAMHT_INSTANCE_MSK                              0x0000FFFF /* 47:32 */ 
#define NV_RAMHT_INSTANCE_RMSK                             0x0000FFFF /* 47:32 */ 
#define NV_RAMHT_INSTANCE_WORD                             1
#define NV_RAMHT_INSTANCE_HIGH_FIELD                       0x0000002F /* =47 */
#define NV_RAMHT_INSTANCE_LOW_FIELD                        0x00000020 /* =32 */
#define NV_RAMHT_ENGINE_MSK                                0x00030000 /* 49:48 */ 
#define NV_RAMHT_ENGINE_RMSK                               0x00000003 /* 49:48 */ 
#define NV_RAMHT_ENGINE_WORD                               1
#define NV_RAMHT_ENGINE_HIGH_FIELD                         0x00000031 /* =49 */
#define NV_RAMHT_ENGINE_LOW_FIELD                          0x00000030 /* =48 */
#define NV_RAMHT_ENGINE_SW_ADJ                             0x00000000
#define NV_RAMHT_ENGINE_GRAPHICS_ADJ                       0x00010000
#define NV_RAMHT_ENGINE_DVD_ADJ                            0x00020000
#define NV_RAMHT_CHID_MSK                                  0x1F000000 /* 60:56 */ 
#define NV_RAMHT_CHID_RMSK                                 0x0000001F /* 60:56 */ 
#define NV_RAMHT_CHID_WORD                                 1
#define NV_RAMHT_CHID_HIGH_FIELD                           0x0000003C /* =60 */
#define NV_RAMHT_CHID_LOW_FIELD                            0x00000038 /* =56 */
#define NV_RAMHT_STATUS_MSK                                0x80000000 /* 63:63 */ 
#define NV_RAMHT_STATUS_RMSK                               0x00000001 /* 63:63 */ 
#define NV_RAMHT_STATUS_WORD                               1
#define NV_RAMHT_STATUS_HIGH_FIELD                         0x0000003F /* =63 */
#define NV_RAMHT_STATUS_LOW_FIELD                          0x0000003F /* =63 */
#define NV_RAMHT_STATUS_INVALID_ADJ                        0x00000000
#define NV_RAMHT_STATUS_VALID_ADJ                          0x80000000
#define NV_RAMRO__SIZE_0_HIGH_FIELD                        0x000001FF /* =511 */
#define NV_RAMRO__SIZE_0_LOW_FIELD                         0x00000000 /* =0 */
#define NV_RAMRO__SIZE_1_HIGH_FIELD                        0x00001FFF /* =8191 */
#define NV_RAMRO__SIZE_1_LOW_FIELD                         0x00000000 /* =0 */
#define NV_RAMRO_METHOD_MSK                                0x00001FFF /* 12:0 */ 
#define NV_RAMRO_METHOD_RMSK                               0x00001FFF /* 12:0 */ 
#define NV_RAMRO_METHOD_WORD                               0
#define NV_RAMRO_METHOD_HIGH_FIELD                         0x0000000C /* =12 */
#define NV_RAMRO_METHOD_LOW_FIELD                          0x00000000 /* =0 */
#define NV_RAMRO_SUBCHANNEL_MSK                            0x0000E000 /* 15:13 */ 
#define NV_RAMRO_SUBCHANNEL_RMSK                           0x00000007 /* 15:13 */ 
#define NV_RAMRO_SUBCHANNEL_WORD                           0
#define NV_RAMRO_SUBCHANNEL_HIGH_FIELD                     0x0000000F /* =15 */
#define NV_RAMRO_SUBCHANNEL_LOW_FIELD                      0x0000000D /* =13 */
#define NV_RAMRO_CHID_MSK                                  0x007F0000 /* 22:16 */ 
#define NV_RAMRO_CHID_RMSK                                 0x0000007F /* 22:16 */ 
#define NV_RAMRO_CHID_WORD                                 0
#define NV_RAMRO_CHID_HIGH_FIELD                           0x00000016 /* =22 */
#define NV_RAMRO_CHID_LOW_FIELD                            0x00000010 /* =16 */
#define NV_RAMRO_TYPE_MSK                                  0x00800000 /* 23:23 */ 
#define NV_RAMRO_TYPE_RMSK                                 0x00000001 /* 23:23 */ 
#define NV_RAMRO_TYPE_WORD                                 0
#define NV_RAMRO_TYPE_HIGH_FIELD                           0x00000017 /* =23 */
#define NV_RAMRO_TYPE_LOW_FIELD                            0x00000017 /* =23 */
#define NV_RAMRO_TYPE_WRITE_ADJ                            0x00000000
#define NV_RAMRO_TYPE_READ_ADJ                             0x00800000
#define NV_RAMRO_BYTE_ENABLES_MSK                          0x0F000000 /* 27:24 */ 
#define NV_RAMRO_BYTE_ENABLES_RMSK                         0x0000000F /* 27:24 */ 
#define NV_RAMRO_BYTE_ENABLES_WORD                         0
#define NV_RAMRO_BYTE_ENABLES_HIGH_FIELD                   0x0000001B /* =27 */
#define NV_RAMRO_BYTE_ENABLES_LOW_FIELD                    0x00000018 /* =24 */
#define NV_RAMRO_REASON_MSK                                0xF0000000 /* 31:28 */ 
#define NV_RAMRO_REASON_RMSK                               0x0000000F /* 31:28 */ 
#define NV_RAMRO_REASON_WORD                               0
#define NV_RAMRO_REASON_HIGH_FIELD                         0x0000001F /* =31 */
#define NV_RAMRO_REASON_LOW_FIELD                          0x0000001C /* =28 */
#define NV_RAMRO_REASON_ILLEGAL_ACCESS_ADJ                 0x00000000
#define NV_RAMRO_REASON_NO_CACHE_AVAILABLE_ADJ             0x10000000
#define NV_RAMRO_REASON_CACHE_RAN_OUT_ADJ                  0x20000000
#define NV_RAMRO_REASON_FREE_COUNT_OVERRUN_ADJ             0x30000000
#define NV_RAMRO_REASON_CAUGHT_LYING_ADJ                   0x40000000
#define NV_RAMRO_REASON_RESERVED_ACCESS_ADJ                0x50000000
#define NV_RAMRO_DATA_MSK                                  0xFFFFFFFF /* 63:32 */ 
#define NV_RAMRO_DATA_RMSK                                 0xFFFFFFFF /* 63:32 */ 
#define NV_RAMRO_DATA_WORD                                 1
#define NV_RAMRO_DATA_HIGH_FIELD                           0x0000003F /* =63 */
#define NV_RAMRO_DATA_LOW_FIELD                            0x00000020 /* =32 */
#define NV_RAMFC__SIZE_0_HIGH_FIELD                        0x000003FF /* =1023 */
#define NV_RAMFC__SIZE_0_LOW_FIELD                         0x00000000 /* =0 */
#define NV_RAMFC__SIZE_1_HIGH_FIELD                        0x000007FF /* =2047 */
#define NV_RAMFC__SIZE_1_LOW_FIELD                         0x00000000 /* =0 */
#define NV_RAMFC_DMA_PUT_MSK                               0xFFFFFFFC /* 31:2 */ 
#define NV_RAMFC_DMA_PUT_RMSK                              0x3FFFFFFF /* 31:2 */ 
#define NV_RAMFC_DMA_PUT_WORD                              0
#define NV_RAMFC_DMA_PUT_HIGH_FIELD                        0x0000001F /* =31 */
#define NV_RAMFC_DMA_PUT_LOW_FIELD                         0x00000002 /* =2 */
#define NV_RAMFC_DMA_GET_MSK                               0xFFFFFFFC /* 63:34 */ 
#define NV_RAMFC_DMA_GET_RMSK                              0x3FFFFFFF /* 63:34 */ 
#define NV_RAMFC_DMA_GET_WORD                              1
#define NV_RAMFC_DMA_GET_HIGH_FIELD                        0x0000003F /* =63 */
#define NV_RAMFC_DMA_GET_LOW_FIELD                         0x00000022 /* =34 */
#define NV_RAMFC_REF_CNT_MSK                               0xFFFFFFFF /* 95:64 */ 
#define NV_RAMFC_REF_CNT_RMSK                              0xFFFFFFFF /* 95:64 */ 
#define NV_RAMFC_REF_CNT_WORD                              2
#define NV_RAMFC_REF_CNT_HIGH_FIELD                        0x0000005F /* =95 */
#define NV_RAMFC_REF_CNT_LOW_FIELD                         0x00000040 /* =64 */
#define NV_RAMFC_DMA_INST_MSK                              0x0000FFFF /* 111:96 */ 
#define NV_RAMFC_DMA_INST_RMSK                             0x0000FFFF /* 111:96 */ 
#define NV_RAMFC_DMA_INST_WORD                             3
#define NV_RAMFC_DMA_INST_HIGH_FIELD                       0x0000006F /* =111 */
#define NV_RAMFC_DMA_INST_LOW_FIELD                        0x00000060 /* =96 */
#define NV_RAMFC_DMA_COUNT_MSK                             0x1FFC0000 /* 124:114 */ 
#define NV_RAMFC_DMA_COUNT_RMSK                            0x000007FF /* 124:114 */ 
#define NV_RAMFC_DMA_COUNT_WORD                            3
#define NV_RAMFC_DMA_COUNT_HIGH_FIELD                      0x0000007C /* =124 */
#define NV_RAMFC_DMA_COUNT_LOW_FIELD                       0x00000072 /* =114 */
#define NV_RAMFC_DMA_METHOD_MSK                            0x00001FFC /* 140:130 */ 
#define NV_RAMFC_DMA_METHOD_RMSK                           0x000007FF /* 140:130 */ 
#define NV_RAMFC_DMA_METHOD_WORD                           4
#define NV_RAMFC_DMA_METHOD_HIGH_FIELD                     0x0000008C /* =140 */
#define NV_RAMFC_DMA_METHOD_LOW_FIELD                      0x00000082 /* =130 */
#define NV_RAMFC_DMA_SUBCHANNEL_MSK                        0x0000E000 /* 143:141 */ 
#define NV_RAMFC_DMA_SUBCHANNEL_RMSK                       0x00000007 /* 143:141 */ 
#define NV_RAMFC_DMA_SUBCHANNEL_WORD                       4
#define NV_RAMFC_DMA_SUBCHANNEL_HIGH_FIELD                 0x0000008F /* =143 */
#define NV_RAMFC_DMA_SUBCHANNEL_LOW_FIELD                  0x0000008D /* =141 */
#define NV_RAMFC_DMA_METHOD_COUNT_MSK                      0x1FFC0000 /* 156:146 */ 
#define NV_RAMFC_DMA_METHOD_COUNT_RMSK                     0x000007FF /* 156:146 */ 
#define NV_RAMFC_DMA_METHOD_COUNT_WORD                     4
#define NV_RAMFC_DMA_METHOD_COUNT_HIGH_FIELD               0x0000009C /* =156 */
#define NV_RAMFC_DMA_METHOD_COUNT_LOW_FIELD                0x00000092 /* =146 */
#define NV_RAMFC_DMA_METHOD_TYPE_MSK                       0x00000001 /* 128:128 */ 
#define NV_RAMFC_DMA_METHOD_TYPE_RMSK                      0x00000001 /* 128:128 */ 
#define NV_RAMFC_DMA_METHOD_TYPE_WORD                      4
#define NV_RAMFC_DMA_METHOD_TYPE_HIGH_FIELD                0x00000080 /* =128 */
#define NV_RAMFC_DMA_METHOD_TYPE_LOW_FIELD                 0x00000080 /* =128 */
#define NV_RAMFC_DMA_FETCH_TRIG_MSK                        0x000000F8 /* 167:163 */ 
#define NV_RAMFC_DMA_FETCH_TRIG_RMSK                       0x0000001F /* 167:163 */ 
#define NV_RAMFC_DMA_FETCH_TRIG_WORD                       5
#define NV_RAMFC_DMA_FETCH_TRIG_HIGH_FIELD                 0x000000A7 /* =167 */
#define NV_RAMFC_DMA_FETCH_TRIG_LOW_FIELD                  0x000000A3 /* =163 */
#define NV_RAMFC_DMA_FETCH_SIZE_MSK                        0x0000E000 /* 175:173 */ 
#define NV_RAMFC_DMA_FETCH_SIZE_RMSK                       0x00000007 /* 175:173 */ 
#define NV_RAMFC_DMA_FETCH_SIZE_WORD                       5
#define NV_RAMFC_DMA_FETCH_SIZE_HIGH_FIELD                 0x000000AF /* =175 */
#define NV_RAMFC_DMA_FETCH_SIZE_LOW_FIELD                  0x000000AD /* =173 */
#define NV_RAMFC_DMA_FETCH_MAX_REQS_MSK                    0x001F0000 /* 180:176 */ 
#define NV_RAMFC_DMA_FETCH_MAX_REQS_RMSK                   0x0000001F /* 180:176 */ 
#define NV_RAMFC_DMA_FETCH_MAX_REQS_WORD                   5
#define NV_RAMFC_DMA_FETCH_MAX_REQS_HIGH_FIELD             0x000000B4 /* =180 */
#define NV_RAMFC_DMA_FETCH_MAX_REQS_LOW_FIELD              0x000000B0 /* =176 */
#define NV_RAMFC_ENGINE_SUB_0_MSK                          0x00000003 /* 193:192 */ 
#define NV_RAMFC_ENGINE_SUB_0_RMSK                         0x00000003 /* 193:192 */ 
#define NV_RAMFC_ENGINE_SUB_0_WORD                         6
#define NV_RAMFC_ENGINE_SUB_0_HIGH_FIELD                   0x000000C1 /* =193 */
#define NV_RAMFC_ENGINE_SUB_0_LOW_FIELD                    0x000000C0 /* =192 */
#define NV_RAMFC_ENGINE_SUB_1_MSK                          0x00000030 /* 197:196 */ 
#define NV_RAMFC_ENGINE_SUB_1_RMSK                         0x00000003 /* 197:196 */ 
#define NV_RAMFC_ENGINE_SUB_1_WORD                         6
#define NV_RAMFC_ENGINE_SUB_1_HIGH_FIELD                   0x000000C5 /* =197 */
#define NV_RAMFC_ENGINE_SUB_1_LOW_FIELD                    0x000000C4 /* =196 */
#define NV_RAMFC_ENGINE_SUB_2_MSK                          0x00000300 /* 201:200 */ 
#define NV_RAMFC_ENGINE_SUB_2_RMSK                         0x00000003 /* 201:200 */ 
#define NV_RAMFC_ENGINE_SUB_2_WORD                         6
#define NV_RAMFC_ENGINE_SUB_2_HIGH_FIELD                   0x000000C9 /* =201 */
#define NV_RAMFC_ENGINE_SUB_2_LOW_FIELD                    0x000000C8 /* =200 */
#define NV_RAMFC_ENGINE_SUB_3_MSK                          0x00003000 /* 205:204 */ 
#define NV_RAMFC_ENGINE_SUB_3_RMSK                         0x00000003 /* 205:204 */ 
#define NV_RAMFC_ENGINE_SUB_3_WORD                         6
#define NV_RAMFC_ENGINE_SUB_3_HIGH_FIELD                   0x000000CD /* =205 */
#define NV_RAMFC_ENGINE_SUB_3_LOW_FIELD                    0x000000CC /* =204 */
#define NV_RAMFC_ENGINE_SUB_4_MSK                          0x00030000 /* 209:208 */ 
#define NV_RAMFC_ENGINE_SUB_4_RMSK                         0x00000003 /* 209:208 */ 
#define NV_RAMFC_ENGINE_SUB_4_WORD                         6
#define NV_RAMFC_ENGINE_SUB_4_HIGH_FIELD                   0x000000D1 /* =209 */
#define NV_RAMFC_ENGINE_SUB_4_LOW_FIELD                    0x000000D0 /* =208 */
#define NV_RAMFC_ENGINE_SUB_5_MSK                          0x00300000 /* 213:212 */ 
#define NV_RAMFC_ENGINE_SUB_5_RMSK                         0x00000003 /* 213:212 */ 
#define NV_RAMFC_ENGINE_SUB_5_WORD                         6
#define NV_RAMFC_ENGINE_SUB_5_HIGH_FIELD                   0x000000D5 /* =213 */
#define NV_RAMFC_ENGINE_SUB_5_LOW_FIELD                    0x000000D4 /* =212 */
#define NV_RAMFC_ENGINE_SUB_6_MSK                          0x03000000 /* 217:216 */ 
#define NV_RAMFC_ENGINE_SUB_6_RMSK                         0x00000003 /* 217:216 */ 
#define NV_RAMFC_ENGINE_SUB_6_WORD                         6
#define NV_RAMFC_ENGINE_SUB_6_HIGH_FIELD                   0x000000D9 /* =217 */
#define NV_RAMFC_ENGINE_SUB_6_LOW_FIELD                    0x000000D8 /* =216 */
#define NV_RAMFC_ENGINE_SUB_7_MSK                          0x30000000 /* 221:220 */ 
#define NV_RAMFC_ENGINE_SUB_7_RMSK                         0x00000003 /* 221:220 */ 
#define NV_RAMFC_ENGINE_SUB_7_WORD                         6
#define NV_RAMFC_ENGINE_SUB_7_HIGH_FIELD                   0x000000DD /* =221 */
#define NV_RAMFC_ENGINE_SUB_7_LOW_FIELD                    0x000000DC /* =220 */
#define NV_RAMFC_PULL1_ENGINE_MSK                          0x00000003 /* 225:224 */ 
#define NV_RAMFC_PULL1_ENGINE_RMSK                         0x00000003 /* 225:224 */ 
#define NV_RAMFC_PULL1_ENGINE_WORD                         7
#define NV_RAMFC_PULL1_ENGINE_HIGH_FIELD                   0x000000E1 /* =225 */
#define NV_RAMFC_PULL1_ENGINE_LOW_FIELD                    0x000000E0 /* =224 */
#define NV_RAMFC_PULL1_ENGINE_SW_ADJ                       0x00000000
#define NV_RAMFC_PULL1_ENGINE_GRAPHICS_ADJ                 0x00000001
#define NV_RAMFC_PULL1_ENGINE_DVD_ADJ                      0x00000002
#define NV_RAMFC_PULL1_ACQ_STATE_MSK                       0x00000010 /* 228:228 */ 
#define NV_RAMFC_PULL1_ACQ_STATE_RMSK                      0x00000001 /* 228:228 */ 
#define NV_RAMFC_PULL1_ACQ_STATE_WORD                      7
#define NV_RAMFC_PULL1_ACQ_STATE_HIGH_FIELD                0x000000E4 /* =228 */
#define NV_RAMFC_PULL1_ACQ_STATE_LOW_FIELD                 0x000000E4 /* =228 */
#define NV_RAMFC_PULL1_ACQ_STATE_INACTIVE_ADJ              0x00000000
#define NV_RAMFC_PULL1_ACQ_STATE_ACTIVE_ADJ                0x00000010
#define NV_RAMFC_PULL1_SEM_TARGET_NODE_MSK                 0x00030000 /* 241:240 */ 
#define NV_RAMFC_PULL1_SEM_TARGET_NODE_RMSK                0x00000003 /* 241:240 */ 
#define NV_RAMFC_PULL1_SEM_TARGET_NODE_WORD                7
#define NV_RAMFC_PULL1_SEM_TARGET_NODE_HIGH_FIELD          0x000000F1 /* =241 */
#define NV_RAMFC_PULL1_SEM_TARGET_NODE_LOW_FIELD           0x000000F0 /* =240 */
#define NV_RAMFC_PULL1_SEM_TARGET_NODE_NVM_ADJ             0x00000000
#define NV_RAMFC_PULL1_SEM_TARGET_NODE_PCI_ADJ             0x00020000
#define NV_RAMFC_PULL1_SEM_TARGET_NODE_AGP_ADJ             0x00030000
#define NV_RAMFC_ACQUIRE_VALUE_MSK                         0xFFFFFFFF /* 287:256 */ 
#define NV_RAMFC_ACQUIRE_VALUE_RMSK                        0xFFFFFFFF /* 287:256 */ 
#define NV_RAMFC_ACQUIRE_VALUE_WORD                        8
#define NV_RAMFC_ACQUIRE_VALUE_HIGH_FIELD                  0x0000011F /* =287 */
#define NV_RAMFC_ACQUIRE_VALUE_LOW_FIELD                   0x00000100 /* =256 */
#define NV_RAMFC_ACQUIRE_TIMESTAMP_MSK                     0xFFFFFFFF /* 319:288 */ 
#define NV_RAMFC_ACQUIRE_TIMESTAMP_RMSK                    0xFFFFFFFF /* 319:288 */ 
#define NV_RAMFC_ACQUIRE_TIMESTAMP_WORD                    9
#define NV_RAMFC_ACQUIRE_TIMESTAMP_HIGH_FIELD              0x0000013F /* =319 */
#define NV_RAMFC_ACQUIRE_TIMESTAMP_LOW_FIELD               0x00000120 /* =288 */
#define NV_RAMFC_ACQUIRE_TIMEOUT_MSK                       0x7FFFFFFF /* 350:320 */ 
#define NV_RAMFC_ACQUIRE_TIMEOUT_RMSK                      0x7FFFFFFF /* 350:320 */ 
#define NV_RAMFC_ACQUIRE_TIMEOUT_WORD                      10
#define NV_RAMFC_ACQUIRE_TIMEOUT_HIGH_FIELD                0x0000015E /* =350 */
#define NV_RAMFC_ACQUIRE_TIMEOUT_LOW_FIELD                 0x00000140 /* =320 */
#define NV_RAMFC_SEMAPHORE_CTXDMA_MSK                      0x00000001 /* 352:352 */ 
#define NV_RAMFC_SEMAPHORE_CTXDMA_RMSK                     0x00000001 /* 352:352 */ 
#define NV_RAMFC_SEMAPHORE_CTXDMA_WORD                     11
#define NV_RAMFC_SEMAPHORE_CTXDMA_HIGH_FIELD               0x00000160 /* =352 */
#define NV_RAMFC_SEMAPHORE_CTXDMA_LOW_FIELD                0x00000160 /* =352 */
#define NV_RAMFC_SEMAPHORE_CTXDMA_INVALID_ADJ              0x00000000
#define NV_RAMFC_SEMAPHORE_CTXDMA_VALID_ADJ                0x00000001
#define NV_RAMFC_SEMAPHORE_OFFSET_MSK                      0x00000FFC /* 363:354 */ 
#define NV_RAMFC_SEMAPHORE_OFFSET_RMSK                     0x000003FF /* 363:354 */ 
#define NV_RAMFC_SEMAPHORE_OFFSET_WORD                     11
#define NV_RAMFC_SEMAPHORE_OFFSET_HIGH_FIELD               0x0000016B /* =363 */
#define NV_RAMFC_SEMAPHORE_OFFSET_LOW_FIELD                0x00000162 /* =354 */
#define NV_RAMFC_SEMAPHORE_PAGE_ADDRESS_MSK                0xFFFFF000 /* 383:364 */ 
#define NV_RAMFC_SEMAPHORE_PAGE_ADDRESS_RMSK               0x000FFFFF /* 383:364 */ 
#define NV_RAMFC_SEMAPHORE_PAGE_ADDRESS_WORD               11
#define NV_RAMFC_SEMAPHORE_PAGE_ADDRESS_HIGH_FIELD         0x0000017F /* =383 */
#define NV_RAMFC_SEMAPHORE_PAGE_ADDRESS_LOW_FIELD          0x0000016C /* =364 */
#define NV_RAMFC_DMA_SUBROUTINE_STATE_MSK                  0x00000001 /* 384:384 */ 
#define NV_RAMFC_DMA_SUBROUTINE_STATE_RMSK                 0x00000001 /* 384:384 */ 
#define NV_RAMFC_DMA_SUBROUTINE_STATE_WORD                 12
#define NV_RAMFC_DMA_SUBROUTINE_STATE_HIGH_FIELD           0x00000180 /* =384 */
#define NV_RAMFC_DMA_SUBROUTINE_STATE_LOW_FIELD            0x00000180 /* =384 */
#define NV_RAMFC_DMA_SUBROUTINE_STATE_INACTIVE_ADJ         0x00000000
#define NV_RAMFC_DMA_SUBROUTINE_STATE_ACTIVE_ADJ           0x00000001
#define NV_RAMFC_DMA_SUBROUTINE_RETURN_OFFSET_MSK          0xFFFFFFFC /* 415:386 */ 
#define NV_RAMFC_DMA_SUBROUTINE_RETURN_OFFSET_RMSK         0x3FFFFFFF /* 415:386 */ 
#define NV_RAMFC_DMA_SUBROUTINE_RETURN_OFFSET_WORD         12
#define NV_RAMFC_DMA_SUBROUTINE_RETURN_OFFSET_HIGH_FIELD   0x0000019F /* =415 */
#define NV_RAMFC_DMA_SUBROUTINE_RETURN_OFFSET_LOW_FIELD    0x00000182 /* =386 */
#define NV_RAMDVD_CTX_TABLE_HIGH_FIELD                     0x000007FF /* =2047 */
#define NV_RAMDVD_CTX_TABLE_LOW_FIELD                      0x00000000 /* =0 */
#define NV_RAMDVD_CTX_TABLE_OBJECT_0_0_MSK                 0x0000FFFF /* 15:0 */ 
#define NV_RAMDVD_CTX_TABLE_OBJECT_0_0_RMSK                0x0000FFFF /* 15:0 */ 
#define NV_RAMDVD_CTX_TABLE_OBJECT_0_0_WORD                0
#define NV_RAMDVD_CTX_TABLE_OBJECT_0_0_HIGH_FIELD          0x0000000F /* =15 */
#define NV_RAMDVD_CTX_TABLE_OBJECT_0_0_LOW_FIELD           0x00000000 /* =0 */
#define NV_RAMDVD_CTX_TABLE_OBJECT_0_1_MSK                 0xFFFF0000 /* 31:16 */ 
#define NV_RAMDVD_CTX_TABLE_OBJECT_0_1_RMSK                0x0000FFFF /* 31:16 */ 
#define NV_RAMDVD_CTX_TABLE_OBJECT_0_1_WORD                0
#define NV_RAMDVD_CTX_TABLE_OBJECT_0_1_HIGH_FIELD          0x0000001F /* =31 */
#define NV_RAMDVD_CTX_TABLE_OBJECT_0_1_LOW_FIELD           0x00000010 /* =16 */
#define NV_RAMDVD_CTX_TABLE_OBJECT_0_2_MSK                 0x0000FFFF /* 47:32 */ 
#define NV_RAMDVD_CTX_TABLE_OBJECT_0_2_RMSK                0x0000FFFF /* 47:32 */ 
#define NV_RAMDVD_CTX_TABLE_OBJECT_0_2_WORD                1
#define NV_RAMDVD_CTX_TABLE_OBJECT_0_2_HIGH_FIELD          0x0000002F /* =47 */
#define NV_RAMDVD_CTX_TABLE_OBJECT_0_2_LOW_FIELD           0x00000020 /* =32 */
#define NV_RAMDVD_CTX_TABLE_OBJECT_0_3_MSK                 0xFFFF0000 /* 63:48 */ 
#define NV_RAMDVD_CTX_TABLE_OBJECT_0_3_RMSK                0x0000FFFF /* 63:48 */ 
#define NV_RAMDVD_CTX_TABLE_OBJECT_0_3_WORD                1
#define NV_RAMDVD_CTX_TABLE_OBJECT_0_3_HIGH_FIELD          0x0000003F /* =63 */
#define NV_RAMDVD_CTX_TABLE_OBJECT_0_3_LOW_FIELD           0x00000030 /* =48 */
#define NV_RAMDVD_CTX_TABLE_OBJECT_0_4_MSK                 0x0000FFFF /* 79:64 */ 
#define NV_RAMDVD_CTX_TABLE_OBJECT_0_4_RMSK                0x0000FFFF /* 79:64 */ 
#define NV_RAMDVD_CTX_TABLE_OBJECT_0_4_WORD                2
#define NV_RAMDVD_CTX_TABLE_OBJECT_0_4_HIGH_FIELD          0x0000004F /* =79 */
#define NV_RAMDVD_CTX_TABLE_OBJECT_0_4_LOW_FIELD           0x00000040 /* =64 */
#define NV_RAMDVD_CTX_TABLE_OBJECT_0_5_MSK                 0xFFFF0000 /* 95:80 */ 
#define NV_RAMDVD_CTX_TABLE_OBJECT_0_5_RMSK                0x0000FFFF /* 95:80 */ 
#define NV_RAMDVD_CTX_TABLE_OBJECT_0_5_WORD                2
#define NV_RAMDVD_CTX_TABLE_OBJECT_0_5_HIGH_FIELD          0x0000005F /* =95 */
#define NV_RAMDVD_CTX_TABLE_OBJECT_0_5_LOW_FIELD           0x00000050 /* =80 */
#define NV_RAMDVD_CTX_TABLE_OBJECT_0_6_MSK                 0x0000FFFF /* 111:96 */ 
#define NV_RAMDVD_CTX_TABLE_OBJECT_0_6_RMSK                0x0000FFFF /* 111:96 */ 
#define NV_RAMDVD_CTX_TABLE_OBJECT_0_6_WORD                3
#define NV_RAMDVD_CTX_TABLE_OBJECT_0_6_HIGH_FIELD          0x0000006F /* =111 */
#define NV_RAMDVD_CTX_TABLE_OBJECT_0_6_LOW_FIELD           0x00000060 /* =96 */
#define NV_RAMDVD_CTX_TABLE_OBJECT_0_7_MSK                 0xFFFF0000 /* 127:112 */ 
#define NV_RAMDVD_CTX_TABLE_OBJECT_0_7_RMSK                0x0000FFFF /* 127:112 */ 
#define NV_RAMDVD_CTX_TABLE_OBJECT_0_7_WORD                3
#define NV_RAMDVD_CTX_TABLE_OBJECT_0_7_HIGH_FIELD          0x0000007F /* =127 */
#define NV_RAMDVD_CTX_TABLE_OBJECT_0_7_LOW_FIELD           0x00000070 /* =112 */
#define NV_RAMDVD_CTX_TABLE_OBJECT_15_0_MSK                0x0000FFFF /* 1935:1920 */ 
#define NV_RAMDVD_CTX_TABLE_OBJECT_15_0_RMSK               0x0000FFFF /* 1935:1920 */ 
#define NV_RAMDVD_CTX_TABLE_OBJECT_15_0_WORD               60
#define NV_RAMDVD_CTX_TABLE_OBJECT_15_0_HIGH_FIELD         0x0000078F /* =1935 */
#define NV_RAMDVD_CTX_TABLE_OBJECT_15_0_LOW_FIELD          0x00000780 /* =1920 */
#define NV_RAMDVD_CTX_TABLE_OBJECT_15_1_MSK                0xFFFF0000 /* 1951:1936 */ 
#define NV_RAMDVD_CTX_TABLE_OBJECT_15_1_RMSK               0x0000FFFF /* 1951:1936 */ 
#define NV_RAMDVD_CTX_TABLE_OBJECT_15_1_WORD               60
#define NV_RAMDVD_CTX_TABLE_OBJECT_15_1_HIGH_FIELD         0x0000079F /* =1951 */
#define NV_RAMDVD_CTX_TABLE_OBJECT_15_1_LOW_FIELD          0x00000790 /* =1936 */
#define NV_RAMDVD_CTX_TABLE_OBJECT_15_2_MSK                0x0000FFFF /* 1967:1952 */ 
#define NV_RAMDVD_CTX_TABLE_OBJECT_15_2_RMSK               0x0000FFFF /* 1967:1952 */ 
#define NV_RAMDVD_CTX_TABLE_OBJECT_15_2_WORD               61
#define NV_RAMDVD_CTX_TABLE_OBJECT_15_2_HIGH_FIELD         0x000007AF /* =1967 */
#define NV_RAMDVD_CTX_TABLE_OBJECT_15_2_LOW_FIELD          0x000007A0 /* =1952 */
#define NV_RAMDVD_CTX_TABLE_OBJECT_15_3_MSK                0xFFFF0000 /* 1983:1968 */ 
#define NV_RAMDVD_CTX_TABLE_OBJECT_15_3_RMSK               0x0000FFFF /* 1983:1968 */ 
#define NV_RAMDVD_CTX_TABLE_OBJECT_15_3_WORD               61
#define NV_RAMDVD_CTX_TABLE_OBJECT_15_3_HIGH_FIELD         0x000007BF /* =1983 */
#define NV_RAMDVD_CTX_TABLE_OBJECT_15_3_LOW_FIELD          0x000007B0 /* =1968 */
#define NV_RAMDVD_CTX_TABLE_OBJECT_15_4_MSK                0x0000FFFF /* 1999:1984 */ 
#define NV_RAMDVD_CTX_TABLE_OBJECT_15_4_RMSK               0x0000FFFF /* 1999:1984 */ 
#define NV_RAMDVD_CTX_TABLE_OBJECT_15_4_WORD               62
#define NV_RAMDVD_CTX_TABLE_OBJECT_15_4_HIGH_FIELD         0x000007CF /* =1999 */
#define NV_RAMDVD_CTX_TABLE_OBJECT_15_4_LOW_FIELD          0x000007C0 /* =1984 */
#define NV_RAMDVD_CTX_TABLE_OBJECT_15_5_MSK                0xFFFF0000 /* 2015:2000 */ 
#define NV_RAMDVD_CTX_TABLE_OBJECT_15_5_RMSK               0x0000FFFF /* 2015:2000 */ 
#define NV_RAMDVD_CTX_TABLE_OBJECT_15_5_WORD               62
#define NV_RAMDVD_CTX_TABLE_OBJECT_15_5_HIGH_FIELD         0x000007DF /* =2015 */
#define NV_RAMDVD_CTX_TABLE_OBJECT_15_5_LOW_FIELD          0x000007D0 /* =2000 */
#define NV_RAMDVD_CTX_TABLE_OBJECT_15_6_MSK                0x0000FFFF /* 2031:2016 */ 
#define NV_RAMDVD_CTX_TABLE_OBJECT_15_6_RMSK               0x0000FFFF /* 2031:2016 */ 
#define NV_RAMDVD_CTX_TABLE_OBJECT_15_6_WORD               63
#define NV_RAMDVD_CTX_TABLE_OBJECT_15_6_HIGH_FIELD         0x000007EF /* =2031 */
#define NV_RAMDVD_CTX_TABLE_OBJECT_15_6_LOW_FIELD          0x000007E0 /* =2016 */
#define NV_RAMDVD_CTX_TABLE_OBJECT_15_7_MSK                0xFFFF0000 /* 2047:2032 */ 
#define NV_RAMDVD_CTX_TABLE_OBJECT_15_7_RMSK               0x0000FFFF /* 2047:2032 */ 
#define NV_RAMDVD_CTX_TABLE_OBJECT_15_7_WORD               63
#define NV_RAMDVD_CTX_TABLE_OBJECT_15_7_HIGH_FIELD         0x000007FF /* =2047 */
#define NV_RAMDVD_CTX_TABLE_OBJECT_15_7_LOW_FIELD          0x000007F0 /* =2032 */
#define NV_DMA_CLASS_MSK                                   0x00000FFF /* 11:0 */ 
#define NV_DMA_CLASS_RMSK                                  0x00000FFF /* 11:0 */ 
#define NV_DMA_CLASS_WORD                                  0
#define NV_DMA_CLASS_HIGH_FIELD                            0x0000000B /* =11 */
#define NV_DMA_CLASS_LOW_FIELD                             0x00000000 /* =0 */
#define NV_DMA_PAGE_TABLE_MSK                              0x00001000 /* 12:12 */ 
#define NV_DMA_PAGE_TABLE_RMSK                             0x00000001 /* 12:12 */ 
#define NV_DMA_PAGE_TABLE_WORD                             0
#define NV_DMA_PAGE_TABLE_HIGH_FIELD                       0x0000000C /* =12 */
#define NV_DMA_PAGE_TABLE_LOW_FIELD                        0x0000000C /* =12 */
#define NV_DMA_PAGE_TABLE_NOT_PRESENT_ADJ                  0x00000000
#define NV_DMA_PAGE_TABLE_PRESENT_ADJ                      0x00001000
#define NV_DMA_PAGE_ENTRY_MSK                              0x00002000 /* 13:13 */ 
#define NV_DMA_PAGE_ENTRY_RMSK                             0x00000001 /* 13:13 */ 
#define NV_DMA_PAGE_ENTRY_WORD                             0
#define NV_DMA_PAGE_ENTRY_HIGH_FIELD                       0x0000000D /* =13 */
#define NV_DMA_PAGE_ENTRY_LOW_FIELD                        0x0000000D /* =13 */
#define NV_DMA_PAGE_ENTRY_NOT_LINEAR_ADJ                   0x00000000
#define NV_DMA_PAGE_ENTRY_LINEAR_ADJ                       0x00002000
#define NV_DMA_FLAGS_ACCESS_MSK                            0x00004000 /* 14:14 */ 
#define NV_DMA_FLAGS_ACCESS_RMSK                           0x00000001 /* 14:14 */ 
#define NV_DMA_FLAGS_ACCESS_WORD                           0
#define NV_DMA_FLAGS_ACCESS_HIGH_FIELD                     0x0000000E /* =14 */
#define NV_DMA_FLAGS_ACCESS_LOW_FIELD                      0x0000000E /* =14 */
#define NV_DMA_FLAGS_ACCESS_READ_WRITE_ADJ                 0x00000000
#define NV_DMA_FLAGS_ACCESS_OTHER_ADJ                      0x00004000
#define NV_DMA_FLAGS_MAPPING_COHERENCY_MSK                 0x00008000 /* 15:15 */ 
#define NV_DMA_FLAGS_MAPPING_COHERENCY_RMSK                0x00000001 /* 15:15 */ 
#define NV_DMA_FLAGS_MAPPING_COHERENCY_WORD                0
#define NV_DMA_FLAGS_MAPPING_COHERENCY_HIGH_FIELD          0x0000000F /* =15 */
#define NV_DMA_FLAGS_MAPPING_COHERENCY_LOW_FIELD           0x0000000F /* =15 */
#define NV_DMA_FLAGS_MAPPING_COHERENCY_UNCACHED_ADJ        0x00000000
#define NV_DMA_FLAGS_MAPPING_COHERENCY_CACHED_ADJ          0x00008000
#define NV_DMA_TARGET_NODE_MSK                             0x00030000 /* 17:16 */ 
#define NV_DMA_TARGET_NODE_RMSK                            0x00000003 /* 17:16 */ 
#define NV_DMA_TARGET_NODE_WORD                            0
#define NV_DMA_TARGET_NODE_HIGH_FIELD                      0x00000011 /* =17 */
#define NV_DMA_TARGET_NODE_LOW_FIELD                       0x00000010 /* =16 */
#define NV_DMA_TARGET_NODE_NVM_ADJ                         0x00000000
#define NV_DMA_TARGET_NODE_NVM_TILED_ADJ                   0x00010000
#define NV_DMA_TARGET_NODE_PCI_ADJ                         0x00020000
#define NV_DMA_TARGET_NODE_AGP_ADJ                         0x00030000
#define NV_DMA_MEMORY_CLASS_MSK                            0x000C0000 /* 19:18 */ 
#define NV_DMA_MEMORY_CLASS_RMSK                           0x00000003 /* 19:18 */ 
#define NV_DMA_MEMORY_CLASS_WORD                           0
#define NV_DMA_MEMORY_CLASS_HIGH_FIELD                     0x00000013 /* =19 */
#define NV_DMA_MEMORY_CLASS_LOW_FIELD                      0x00000012 /* =18 */
#define NV_DMA_MEMORY_CLASS_NV01_MEMORY_LOCAL_LINEAR_ADJ   0x00000000
#define NV_DMA_MEMORY_CLASS_NV01_MEMORY_LOCAL_BANKED_ADJ   0x00040000
#define NV_DMA_MEMORY_CLASS_NV01_MEMORY_SYSTEM_ADJ         0x00080000
#define NV_DMA_MEMORY_CLASS_OTHER_ADJ                      0x000C0000
#define NV_DMA_ADJUST_MSK                                  0xFFF00000 /* 31:20 */ 
#define NV_DMA_ADJUST_RMSK                                 0x00000FFF /* 31:20 */ 
#define NV_DMA_ADJUST_WORD                                 0
#define NV_DMA_ADJUST_HIGH_FIELD                           0x0000001F /* =31 */
#define NV_DMA_ADJUST_LOW_FIELD                            0x00000014 /* =20 */
#define NV_DMA_LIMIT_MSK                                   0xFFFFFFFF /* 63:32 */ 
#define NV_DMA_LIMIT_RMSK                                  0xFFFFFFFF /* 63:32 */ 
#define NV_DMA_LIMIT_WORD                                  1
#define NV_DMA_LIMIT_HIGH_FIELD                            0x0000003F /* =63 */
#define NV_DMA_LIMIT_LOW_FIELD                             0x00000020 /* =32 */
#define NV_DMA_ACCESS_MSK                                  0x00000002 /* 65:65 */ 
#define NV_DMA_ACCESS_RMSK                                 0x00000001 /* 65:65 */ 
#define NV_DMA_ACCESS_WORD                                 2
#define NV_DMA_ACCESS_HIGH_FIELD                           0x00000041 /* =65 */
#define NV_DMA_ACCESS_LOW_FIELD                            0x00000041 /* =65 */
#define NV_DMA_ACCESS_READ_ONLY_ADJ                        0x00000000
#define NV_DMA_ACCESS_READ_AND_WRITE_ADJ                   0x00000002
#define NV_DMA_FRAME_ADDRESS_MSK                           0xFFFFF000 /* 95:76 */ 
#define NV_DMA_FRAME_ADDRESS_RMSK                          0x000FFFFF /* 95:76 */ 
#define NV_DMA_FRAME_ADDRESS_WORD                          2
#define NV_DMA_FRAME_ADDRESS_HIGH_FIELD                    0x0000005F /* =95 */
#define NV_DMA_FRAME_ADDRESS_LOW_FIELD                     0x0000004C /* =76 */
#define NV_SUBCHAN_CTX_SWITCH_MSK                          0xFFFFFFFF /* 31:0 */ 
#define NV_SUBCHAN_CTX_SWITCH_RMSK                         0xFFFFFFFF /* 31:0 */ 
#define NV_SUBCHAN_CTX_SWITCH_WORD                         0
#define NV_SUBCHAN_CTX_SWITCH_HIGH_FIELD                   0x0000001F /* =31 */
#define NV_SUBCHAN_CTX_SWITCH_LOW_FIELD                    0x00000000 /* =0 */
#define NV_SUBCHAN_DMA_INSTANCE_MSK                        0x0000FFFF /* 47:32 */ 
#define NV_SUBCHAN_DMA_INSTANCE_RMSK                       0x0000FFFF /* 47:32 */ 
#define NV_SUBCHAN_DMA_INSTANCE_WORD                       1
#define NV_SUBCHAN_DMA_INSTANCE_HIGH_FIELD                 0x0000002F /* =47 */
#define NV_SUBCHAN_DMA_INSTANCE_LOW_FIELD                  0x00000020 /* =32 */
#define NV_SUBCHAN_NOTIFY_INSTANCE_MSK                     0xFFFF0000 /* 63:48 */ 
#define NV_SUBCHAN_NOTIFY_INSTANCE_RMSK                    0x0000FFFF /* 63:48 */ 
#define NV_SUBCHAN_NOTIFY_INSTANCE_WORD                    1
#define NV_SUBCHAN_NOTIFY_INSTANCE_HIGH_FIELD              0x0000003F /* =63 */
#define NV_SUBCHAN_NOTIFY_INSTANCE_LOW_FIELD               0x00000030 /* =48 */
#define NV_SUBCHAN_MEMFMT_INSTANCE_MSK                     0x0000FFFF /* 79:64 */ 
#define NV_SUBCHAN_MEMFMT_INSTANCE_RMSK                    0x0000FFFF /* 79:64 */ 
#define NV_SUBCHAN_MEMFMT_INSTANCE_WORD                    2
#define NV_SUBCHAN_MEMFMT_INSTANCE_HIGH_FIELD              0x0000004F /* =79 */
#define NV_SUBCHAN_MEMFMT_INSTANCE_LOW_FIELD               0x00000040 /* =64 */
#define NV_SUBCHAN_MEMFMT_LINEAR_MSK                       0x00010000 /* 80:80 */ 
#define NV_SUBCHAN_MEMFMT_LINEAR_RMSK                      0x00000001 /* 80:80 */ 
#define NV_SUBCHAN_MEMFMT_LINEAR_WORD                      2
#define NV_SUBCHAN_MEMFMT_LINEAR_HIGH_FIELD                0x00000050 /* =80 */
#define NV_SUBCHAN_MEMFMT_LINEAR_LOW_FIELD                 0x00000050 /* =80 */
#define NV_SUBCHAN_MEMFMT_LINEAR_OUT_ADJ                   0x00000000
#define NV_SUBCHAN_MEMFMT_LINEAR_IN_ADJ                    0x00010000
#endif /* __NV_REF_PLUS_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\bootx\bldr32\i386\drvslw.c ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    drvslw.c

Abstract:

    This module implements code to perform Drive/Slew Pad compensation, so we
    can bring the memory clock up to fullspeed early during boot.

--*/

#include "bldr32.h"
#include <bldr.h>
#include "romdata.h"
#include <nv_ref_2a.h>

//
// To enable cache checking code using PMC, define CHECKCACHE
//
#undef CHECKCACHE

//
// Location of the ROM base (mapped in BldrStartup) and the datatbl offset.
//
#define BLDR_ROM_BASE               0xFFC00000
#define BLDR_ROM_DATA_OFFSET        0x0000007C

//
// Macros used by calibration code
//
#define TOFIXEDPOINT(d)             ((d) << 20)
#define SLW_VALUE(r,f)              SlwValue(r,f)
#define FROMFIXEDPOINT(d)           FromFixedPoint(d);

#define NV_PBUS_FBIO_CALEN_VAL      0x000f0f0f
#define NV_PBUS_FBIO_CALSEL_VCCQ    0x00040004
#define NV_PBUS_FBIO_CALSEL_VCC     0x00040000

#define DRF_MASK(drf)               (0xFFFFFFFF>>(31-((1?drf) % 32)+((0?drf) % 32)))

//
// PMC event to use for cache checking code
//
#define PMC_EVENT    0x65   // Number of bus burst read transactions

//
// LDT flow control enable bits
//
#define LDT_FLOW_CONTROL_BITS       0x88000000


//
// LDT registers
//
#define CR_CPU_LDT_1                0x80000064
#define CR_CPU_LDT_3_USER_CNFG      0x8000006C
#define MCP_LEG_CFG_21              0x80000854
 

#define CR_CPU_MEMTOP               0x80000084
#define CR_CPU_MEMTOP_LIMIT_64MB    0x03FFFFFF
#define CR_CPU_MEMTOP_LIMIT_128MB   0x07FFFFFF

#define CR_CPU_GRAP                 0x80000080

//
// Memory test results
//
#define MCP_USBA_CFG_15             0x8000103C
#define MCP_USBB_CFG_15             0x8000183C



typedef struct _REGVALUEPAIR {
    ULONG Register;
    ULONG Value;
} REGVALUEPAIR, *PREGVALUEPAIR;



FORCEINLINE
ULONG
REG_RD32(
    VOID* Ptr,
    ULONG Addr
    )
{
    return *((volatile ULONG*)((UCHAR*)(Ptr) + (Addr)));
}


FORCEINLINE
VOID
REG_WR32(
    VOID* Ptr,
    ULONG Addr,
    ULONG Val)
{
    *((volatile ULONG*)((UCHAR*)(Ptr) + (Addr))) = (ULONG)(Val);
}


#ifdef CHECKCACHE
FORCEINLINE
VOID
SetPMCEvent(
    ULONG Event
    )
{
    Event |= ((1 << 22) | (1 << 17) | (1 << 18) | (1 << 20));

    __asm {
        mov     ecx, 0x186
        mov     eax, Event
        xor     edx, edx
        wrmsr  

        ;
        ; mov eax, cr4
        ;
        _emit   0Fh
        _emit   20h
        _emit   0E0h  

        or eax, 100h
        
        ;
        ; mov cr4, eax
        ;
        _emit   0Fh
        _emit   22h
        _emit   0E0h  
    }
}


FORCEINLINE
ULONG
ReadPMCLow(
    VOID
    )
{
    ULONG LowPart;

    __asm {
        xor     edx, edx
        xor     ecx, ecx
        _emit   0fh
        _emit   33h
        mov     LowPart, eax
    }
    
    return LowPart;
};
#endif


VOID 
BldrDelay(
    ULONG nsec
    )
/*++

Routine Description:

    This is a busy wait loop for the drive/slew calibration only.  Its not very 
    accurate, since the 733MHz cycle time (1.364ns) is rounded to 1ns and also 
    doesn't account for the instructions that make-up the loop.  The idle times 
    being passed in are currently 10us, so delaying a little longer in this 
    routine shouldn't be noticeable.


Arguments:


Return Value:

    None.

--*/
{
    ULONG tick_curr_lo, tick_curr_hi;
    ULONG tick_end_lo, tick_end_hi;

    //
    // Read start counters
    //
    __asm {
        rdtsc
        mov tick_curr_lo, eax
        mov tick_curr_hi, edx
    }

    tick_end_hi = tick_curr_hi;
    tick_end_lo = tick_curr_lo + nsec;  

    // 
    // Handle rollover
    //
    if (tick_end_lo < tick_curr_lo) {
        tick_end_hi++;  
    }

    //
    // Do nothing loop for specified time
    //
    do {
        __asm {
            rdtsc
            mov tick_curr_lo, eax
            mov tick_curr_hi, edx
        }
    } while ((tick_curr_hi <= tick_end_hi) &&
             (tick_curr_lo < tick_end_lo)); 
}


static _declspec(noinline)
ULONG 
SlwValue(
    ULONG r, 
    ULONG f
    )
{
   return ((r << 28) | (f << 24) | (r << 20) | (f << 16) | (r << 12) | (f << 8)  | (r <<  4) |  f);
}


static _declspec(noinline)
ULONG 
FromFixedPoint(
    ULONG d
    )
{
    return ((((d) + (0x1 << 19)) >> 20) & 0xf);
}



FORCEINLINE
ULONG
ReadPCIConfig(
    ULONG Reg
    )
{
    _outpd(PCI_TYPE1_ADDR_PORT, Reg);
    return _inpd(PCI_TYPE1_DATA_PORT);
}


VOID
BldrSetDrvSlwFromROMData(
    PVOID RegisterBase
    )
{
    ULONG *offsetp;
    PROM_DATATBL pROMData;
    PDRVSLWCALPARAMS pDrvSlwCalParams;
    PDRVSLWPADPARAMS pPadParams, pDrvSlwPadParam_lo, pDrvSlwPadParam_hi;
    ULONG adr_drv_fall, adr_drv_rise, adr_drv,
          clk_drv_fall, clk_drv_rise, clk_drv,
          dat_drv_fall, dat_drv_rise, dat_drv,
          dqs_drv_fall, dqs_drv_rise, dqs_drv;
    ULONG adr_slw_fall, adr_slw_rise, adr_slw,
          clk_slw_fall, clk_slw_rise, clk_slw,
          dat_slw_fall, dat_slw_rise, dat_slw,
          dqs_slw_fall, dqs_slw_rise, dqs_slw;
    ULONG dqs_ib_del, data_ib_del, clk_ic_del, fbio_dly;
    ULONG vccq_a, vccq_b, vccq_c, vccq_d, avg_vccq;
    ULONG vcc_a, vcc_b, vcc_c, vcc_d, avg_vcc;
    ULONG ratio_a, ratio_b;

    REGVALUEPAIR RegValuePair[9];
    ULONG Pass;
    ULONG i;
#ifdef CHECKCACHE
    ULONG BeginHits;
    ULONG EndHits;
#endif
    ULONG StrapEMRS;

    //
    // Find start of ROM datatbl containing drive/slew data
    //
    offsetp = (ULONG *)(BLDR_ROM_BASE + BLDR_ROM_DATA_OFFSET);
    pROMData = (PROM_DATATBL)(BLDR_ROM_BASE + *offsetp);
    pDrvSlwCalParams = &pROMData->calParams;

    //
    // Check to see if its Samsung or a Micron memory bits 19:18
    //
    StrapEMRS = REG_RD32(RegisterBase, NV_PEXTDEV_BOOT_0) & 0x0000C0000;

    if (StrapEMRS == 0) {
        pPadParams = &(pROMData->MicronParams[0]);
        BldrPrint(("Bldr: Memory type: Micron"));
    }
    else {
        pPadParams = &(pROMData->SamsungParams[0]);
        BldrPrint(("Bldr: Memory type: Samsung"));
    }
    
#ifdef BLDRSPEW
    //
    // Dump out memory sizes etc
    //
    if (ReadPCIConfig(CR_CPU_MEMTOP) == CR_CPU_MEMTOP_LIMIT_64MB) {
        BldrPrint(("Bldr: Memory size: 64MB"));
    } else {
        BldrPrint(("Bldr: Memory size: 128MB")); 
    }
    
    BldrPrint(("Bldr: Memory test results: 4MB/2MB=%x, Pass/Fail=%x", 
        ReadPCIConfig(MCP_USBA_CFG_15) & 0xff, 
        ReadPCIConfig(MCP_USBB_CFG_15) & 0xff));
    
    BldrPrint(("Bldr: NV_PBUS_FBIO_DLY=%x", REG_RD32(RegisterBase, NV_PBUS_FBIO_DLY)));
    BldrPrint(("Bldr: PadParams=%x", pPadParams));

    BldrPrint(("Bldr: DriveSlewCalibration started"));
#endif    

    //
    // Read the calibration for outbound/inbound 
    //
    REG_WR32(RegisterBase, NV_PBUS_FBIO_CALEN, NV_PBUS_FBIO_CALEN_VAL);

    REG_WR32(RegisterBase, NV_PBUS_FBIO_CALSEL, NV_PBUS_FBIO_CALSEL_VCCQ);
    BldrDelay(10*1000);    // 10 usecs
    vccq_a = REG_RD32(RegisterBase, NV_PBUS_FBIO_CALCNT);

    REG_WR32(RegisterBase, NV_PBUS_FBIO_CALSEL, NV_PBUS_FBIO_CALSEL_VCCQ+1);
    BldrDelay(10*1000);    // 10 usecs
    vccq_b = REG_RD32(RegisterBase, NV_PBUS_FBIO_CALCNT);

    REG_WR32(RegisterBase, NV_PBUS_FBIO_CALSEL, NV_PBUS_FBIO_CALSEL_VCCQ+2);
    BldrDelay(10*1000);    // 10 usecs
    vccq_c = REG_RD32(RegisterBase, NV_PBUS_FBIO_CALCNT);

    REG_WR32(RegisterBase, NV_PBUS_FBIO_CALSEL, NV_PBUS_FBIO_CALSEL_VCCQ+3);
    BldrDelay(10*1000);    // 10 usecs
    vccq_d = REG_RD32(RegisterBase, NV_PBUS_FBIO_CALCNT);

    avg_vccq = (vccq_a + vccq_b + vccq_c + vccq_d) / 4;

    BldrPrint(("Bldr: DriveSlewCalibration VCCQ_A=0x%x", vccq_a));
    BldrPrint(("Bldr: DriveSlewCalibration VCCQ_B=0x%x", vccq_b));
    BldrPrint(("Bldr: DriveSlewCalibration VCCQ_C=0x%x", vccq_c));
    BldrPrint(("Bldr: DriveSlewCalibration VCCQ_D=0x%x", vccq_d));

    REG_WR32(RegisterBase, NV_PBUS_FBIO_CALSEL, NV_PBUS_FBIO_CALSEL_VCC);
    BldrDelay(10*1000);    // 10 usecs
    vcc_a = REG_RD32(RegisterBase, NV_PBUS_FBIO_CALCNT);

    REG_WR32(RegisterBase, NV_PBUS_FBIO_CALSEL, NV_PBUS_FBIO_CALSEL_VCC+1);
    BldrDelay(10*1000);    // 10 usecs
    vcc_b = REG_RD32(RegisterBase, NV_PBUS_FBIO_CALCNT);

    REG_WR32(RegisterBase, NV_PBUS_FBIO_CALSEL, NV_PBUS_FBIO_CALSEL_VCC+2);
    BldrDelay(10*1000);    // 10 usecs
    vcc_c = REG_RD32(RegisterBase, NV_PBUS_FBIO_CALCNT);

    REG_WR32(RegisterBase, NV_PBUS_FBIO_CALSEL, NV_PBUS_FBIO_CALSEL_VCC+3);
    BldrDelay(10*1000);    // 10 usecs
    vcc_d = REG_RD32(RegisterBase, NV_PBUS_FBIO_CALCNT);

    avg_vcc = (vcc_a + vcc_b + vcc_c + vcc_d) / 4;

    BldrPrint(("Bldr: DriveSlewCalibration VCC_A=0x%x", vcc_a));
    BldrPrint(("Bldr: DriveSlewCalibration VCC_B=0x%x", vcc_b));
    BldrPrint(("Bldr: DriveSlewCalibration VCC_C=0x%x", vcc_c));
    BldrPrint(("Bldr: DriveSlewCalibration VCC_D=0x%x", vcc_d));

    REG_WR32(RegisterBase, NV_PBUS_FBIO_CALEN, 0);

    //
    // Determine outbound process params and interp ratio_a/ratio_b
    //
    if (avg_vccq <= pDrvSlwCalParams->SlowCountAvg) {
        BldrPrint(("Bldr: Outbound interp slow ext -> slow avg"));

        pDrvSlwPadParam_lo = &pPadParams[DrvSlwExtSlow];
        pDrvSlwPadParam_hi = &pPadParams[DrvSlwAvgSlow];

        ratio_a = TOFIXEDPOINT(avg_vccq - pDrvSlwCalParams->SlowCountExt) /
                              (pDrvSlwCalParams->SlowCountAvg - pDrvSlwCalParams->SlowCountExt);
        if (ratio_a & 0x80000000)  
            ratio_a = 0;
    
    } else if (avg_vccq >= pDrvSlwCalParams->FastCountAvg) {
        BldrPrint(("Bldr: Outbound interp fast avg -> fast ext"));

        pDrvSlwPadParam_lo = &pPadParams[DrvSlwAvgFast];
        pDrvSlwPadParam_hi = &pPadParams[DrvSlwExtFast];

        ratio_a = TOFIXEDPOINT(avg_vccq - pDrvSlwCalParams->FastCountAvg) /
                              (pDrvSlwCalParams->FastCountExt - pDrvSlwCalParams->FastCountAvg);
        if (ratio_a > TOFIXEDPOINT(1))
            ratio_a = 1;
    
    } else if (avg_vccq < pDrvSlwCalParams->TypiCount) {
        BldrPrint(("Bldr: Outbound interp slow avg -> typical"));

        pDrvSlwPadParam_lo = &pPadParams[DrvSlwAvgSlow];
        pDrvSlwPadParam_hi = &pPadParams[DrvSlwTypical];

        ratio_a = TOFIXEDPOINT(avg_vccq - pDrvSlwCalParams->SlowCountAvg) /
                              (pDrvSlwCalParams->TypiCount - pDrvSlwCalParams->SlowCountAvg);
    } else {
        BldrPrint(("Bldr: Outbound interp typical -> fast avg"));

        pDrvSlwPadParam_lo = &pPadParams[DrvSlwTypical];
        pDrvSlwPadParam_hi = &pPadParams[DrvSlwAvgFast];

        ratio_a = TOFIXEDPOINT(avg_vccq - pDrvSlwCalParams->TypiCount) /
                              (pDrvSlwCalParams->FastCountAvg - pDrvSlwCalParams->TypiCount);
    }

    ratio_b = TOFIXEDPOINT(1) - ratio_a;

    adr_drv_fall = FROMFIXEDPOINT((pDrvSlwPadParam_lo->AdrDrvFall * ratio_b) +
                                  (pDrvSlwPadParam_hi->AdrDrvFall * ratio_a)); 
    adr_drv_rise = FROMFIXEDPOINT((pDrvSlwPadParam_lo->AdrDrvRise * ratio_b) +
                                  (pDrvSlwPadParam_hi->AdrDrvRise * ratio_a));
    adr_slw_fall = FROMFIXEDPOINT((pDrvSlwPadParam_lo->AdrSlwFall * ratio_b) +
                                  (pDrvSlwPadParam_hi->AdrSlwFall * ratio_a));
    adr_slw_rise = FROMFIXEDPOINT((pDrvSlwPadParam_lo->AdrSlwRise * ratio_b) +
                                  (pDrvSlwPadParam_hi->AdrSlwRise * ratio_a));

    clk_drv_fall = FROMFIXEDPOINT((pDrvSlwPadParam_lo->ClkDrvFall * ratio_b) +
                                  (pDrvSlwPadParam_hi->ClkDrvFall * ratio_a));
    clk_drv_rise = FROMFIXEDPOINT((pDrvSlwPadParam_lo->ClkDrvRise * ratio_b) +
                                  (pDrvSlwPadParam_hi->ClkDrvRise * ratio_a));
    clk_slw_fall = FROMFIXEDPOINT((pDrvSlwPadParam_lo->ClkSlwFall * ratio_b) +
                                  (pDrvSlwPadParam_hi->ClkSlwFall * ratio_a));
    clk_slw_rise = FROMFIXEDPOINT((pDrvSlwPadParam_lo->ClkSlwRise * ratio_b) +
                                  (pDrvSlwPadParam_hi->ClkSlwRise * ratio_a));

    dat_drv_fall = FROMFIXEDPOINT((pDrvSlwPadParam_lo->DatDrvFall * ratio_b) +
                                  (pDrvSlwPadParam_hi->DatDrvFall * ratio_a));
    dat_drv_rise = FROMFIXEDPOINT((pDrvSlwPadParam_lo->DatDrvRise * ratio_b) +
                                  (pDrvSlwPadParam_hi->DatDrvRise * ratio_a));
    dat_slw_fall = FROMFIXEDPOINT((pDrvSlwPadParam_lo->DatSlwFall * ratio_b) +
                                  (pDrvSlwPadParam_hi->DatSlwFall * ratio_a));
    dat_slw_rise = FROMFIXEDPOINT((pDrvSlwPadParam_lo->DatSlwRise * ratio_b) +
                                  (pDrvSlwPadParam_hi->DatSlwRise * ratio_a));

    dqs_drv_fall = FROMFIXEDPOINT((pDrvSlwPadParam_lo->DqsDrvFall * ratio_b) +
                                  (pDrvSlwPadParam_hi->DqsDrvFall * ratio_a));
    dqs_drv_rise = FROMFIXEDPOINT((pDrvSlwPadParam_lo->DqsDrvRise * ratio_b) +
                                  (pDrvSlwPadParam_hi->DqsDrvRise * ratio_a));
    dqs_slw_fall = FROMFIXEDPOINT((pDrvSlwPadParam_lo->DqsSlwFall * ratio_b) +
                                  (pDrvSlwPadParam_hi->DqsSlwFall * ratio_a));
    dqs_slw_rise = FROMFIXEDPOINT((pDrvSlwPadParam_lo->DqsSlwRise * ratio_b) +
                                  (pDrvSlwPadParam_hi->DqsSlwRise * ratio_a));

    //
    // Determine inbound process params and interp ratio_a/ratio_b
    //
    if (avg_vcc <= pDrvSlwCalParams->SlowCountBAvg) {
        
        BldrPrint(("Bldr: Inbound interp slow ext -> slow avg"));

        pDrvSlwPadParam_lo = &pPadParams[DrvSlwExtSlow];
        pDrvSlwPadParam_hi = &pPadParams[DrvSlwAvgSlow];

        ratio_a = TOFIXEDPOINT(avg_vcc - pDrvSlwCalParams->SlowCountBExt) /
                              (pDrvSlwCalParams->SlowCountBAvg - pDrvSlwCalParams->SlowCountBExt);
        if (ratio_a & 0x80000000) {      
            ratio_a = 0;
        }
    
    } else if (avg_vcc >= pDrvSlwCalParams->FastCountBAvg) {
        
        BldrPrint(("Bldr: Inbound interp fast avg -> fast ext"));

        pDrvSlwPadParam_lo = &pPadParams[DrvSlwAvgFast];
        pDrvSlwPadParam_hi = &pPadParams[DrvSlwExtFast];

        ratio_a = TOFIXEDPOINT(avg_vcc - pDrvSlwCalParams->FastCountBAvg) /
                              (pDrvSlwCalParams->FastCountBExt - pDrvSlwCalParams->FastCountBAvg);
        if (ratio_a > TOFIXEDPOINT(1)) {
            ratio_a = 1;
        }
    
    } else if (avg_vcc < pDrvSlwCalParams->TypiCountB) {
        
        BldrPrint(("Bldr: Inbound interp slow avg -> typical"));

        pDrvSlwPadParam_lo = &pPadParams[DrvSlwAvgSlow];
        pDrvSlwPadParam_hi = &pPadParams[DrvSlwTypical];

        ratio_a = TOFIXEDPOINT(avg_vcc - pDrvSlwCalParams->SlowCountBAvg) /
                              (pDrvSlwCalParams->TypiCountB - pDrvSlwCalParams->SlowCountBAvg);
    
    } else {

        BldrPrint(("Bldr: Inbound interp typical -> fast avg"));

        pDrvSlwPadParam_lo = &pPadParams[DrvSlwTypical];
        pDrvSlwPadParam_hi = &pPadParams[DrvSlwAvgFast];

        ratio_a = TOFIXEDPOINT(avg_vcc - pDrvSlwCalParams->TypiCountB) /
                              (pDrvSlwCalParams->FastCountBAvg - pDrvSlwCalParams->TypiCountB);
    }
    
    ratio_b = TOFIXEDPOINT(1) - ratio_a;

    dqs_ib_del = FROMFIXEDPOINT((pDrvSlwPadParam_lo->DqsInbDely * ratio_b) +
                                (pDrvSlwPadParam_hi->DqsInbDely * ratio_a));

    data_ib_del = FROMFIXEDPOINT((pDrvSlwPadParam_lo->DataInbDely * ratio_b) +
                                 (pDrvSlwPadParam_hi->DataInbDely * ratio_a));

    clk_ic_del = FROMFIXEDPOINT((pDrvSlwPadParam_lo->ClkIcDely * ratio_b) +
                                (pDrvSlwPadParam_hi->ClkIcDely * ratio_a));
    
    //
    // NOTE: We must write all 9 register values without accessing memory
    //       Therefore, all code and data must be present in the cache
    // 

    //
    // Clear the cache
    //
    __asm wbinvd;

    //
    // Save the final register values and registers in an array
    //

    adr_drv = SLW_VALUE(adr_drv_rise, adr_drv_fall);
    RegValuePair[0].Register = NV_PBUS_FBIO_ADRDRV; 
    RegValuePair[0].Value = adr_drv;  

    adr_slw = SLW_VALUE(adr_slw_rise, adr_slw_fall);
    RegValuePair[1].Register = NV_PBUS_FBIO_ADRSLW; 
    RegValuePair[1].Value = adr_slw;  

    clk_drv = SLW_VALUE(clk_drv_rise, clk_drv_fall);
    RegValuePair[2].Register = NV_PBUS_FBIO_CLKDRV; 
    RegValuePair[2].Value = clk_drv;

    clk_slw = SLW_VALUE(clk_slw_rise, clk_slw_fall);
    RegValuePair[3].Register = NV_PBUS_FBIO_CLKSLW; 
    RegValuePair[3].Value = clk_slw;  

    dat_drv = SLW_VALUE(dat_drv_rise, dat_drv_fall);
    RegValuePair[4].Register = NV_PBUS_FBIO_DATDRV; 
    RegValuePair[4].Value = dat_drv;  

    dat_slw = SLW_VALUE(dat_slw_rise, dat_slw_fall);
    RegValuePair[5].Register = NV_PBUS_FBIO_DATSLW; 
    RegValuePair[5].Value = dat_slw;  

    dqs_drv = SLW_VALUE(dqs_drv_rise, dqs_drv_fall);
    RegValuePair[6].Register = NV_PBUS_FBIO_DQSDRV; 
    RegValuePair[6].Value = dqs_drv;  

    dqs_slw = SLW_VALUE(dqs_slw_rise, dqs_slw_fall);
    RegValuePair[7].Register = NV_PBUS_FBIO_DQSSLW; 
    RegValuePair[7].Value = dqs_slw;  

    fbio_dly = (dqs_ib_del << 29) | (clk_ic_del << 27) | (data_ib_del << 24) |
               (dqs_ib_del << 21) | (clk_ic_del << 19) | (data_ib_del << 16) |
               (dqs_ib_del << 13) | (clk_ic_del << 11) | (data_ib_del << 8) |
               (dqs_ib_del << 5)  | (clk_ic_del << 3)  |  data_ib_del;
    
    RegValuePair[8].Register = NV_PBUS_FBIO_DLY; 
    RegValuePair[8].Value = fbio_dly;

    //
    // Read the array byte by byte to ensure it is in cache.  
    //
    for (i = 0; i < 9; i++) {
        if (RegValuePair[i].Register == 0 || RegValuePair[i].Value == 0) {
            RegValuePair[i].Register = 0;
        }
    }

#ifdef CHECKCACHE
    SetPMCEvent(PMC_EVENT);   
#endif
    
    //
    // First pass is a NOP and used to ensure the code is in cache
    // Second pass actually writes the register values out
    //
    for (Pass = 0; Pass < 2; Pass++) {

#ifdef CHECKCACHE
        BeginHits = ReadPMCLow();
#endif

        for (i = 0; i < 9; i++) {
            if (Pass == 1) {
                REG_WR32(RegisterBase, RegValuePair[i].Register, 
                    RegValuePair[i].Value);
            }

        }

#ifdef CHECKCACHE
        EndHits = ReadPMCLow();
#endif
    
    }
    
#ifdef CHECKCACHE
    BldrPrint(("Bldr: Mem reads during register writes=%d (must be zero) (%d,%d)", 
              (EndHits - BeginHits), EndHits, BeginHits));
#endif
    

#ifdef BLDRSPEW
    for (i = 0; i < 9; i++) {
        BldrPrint(("Bldr: DriveSlewCalibration register %x=%x", RegValuePair[i].Register, 
            RegValuePair[i].Value));
    }

    BldrPrint(("Bldr: DriveSlewCalibration setup finished"));
#endif

}




VOID
BldrSetupLDTBus(
    VOID
    )
{
    ULONG ldt_data;
    
    //
    // NOTE: Since we have to reset the LDT bus as part of this initialization, we
    // can't run this code out of the ROM (while resetting the bus, we won't be
    // able to execute the code to reenable it), so it has to be in memory.
    //
 
    BldrPrint(("Bldr: Enabling LDT DWORD flow control"));

    // 
    // Enable DWORD flow control in the MCP
    //
    _outpd(PCI_TYPE1_ADDR_PORT, MCP_LEG_CFG_21);
    ldt_data = _inpd(PCI_TYPE1_DATA_PORT);
    ldt_data |= LDT_FLOW_CONTROL_BITS;
    _outpd(PCI_TYPE1_DATA_PORT, ldt_data);
 
    //
    // Enable DWORD flow control in the NV2A
    //
    _outpd(PCI_TYPE1_ADDR_PORT, CR_CPU_LDT_1);
    ldt_data = _inpd(PCI_TYPE1_DATA_PORT);
    ldt_data |= LDT_FLOW_CONTROL_BITS;
    _outpd(PCI_TYPE1_DATA_PORT, ldt_data);
 
    //
    // Force a reset of the LDT link. This is done by toggling the
    // WARM_RESET bit (bit0), where a 0 initiates the reset and a 1 
    // completes it
    //
    _outpd(PCI_TYPE1_ADDR_PORT, CR_CPU_LDT_3_USER_CNFG);
    ldt_data = _inpd(PCI_TYPE1_DATA_PORT);
    _outpd(PCI_TYPE1_DATA_PORT, (ldt_data & 0xFFFFFFFE));
    _outpd(PCI_TYPE1_DATA_PORT, ldt_data);

    //
    // Allow the LDT->1GB transactions by ensuring that the GART is visible to LDT.
    // Due to the fact there is a shadow copy of this register, we must do this write
    // even though the power on value is already 0x100
    //
    _outpd(PCI_TYPE1_ADDR_PORT, CR_CPU_GRAP);
    _outpd(PCI_TYPE1_DATA_PORT, 0x100);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\bootx\bldr32\i386\startup.asm ===
;++
;
;  Copyright (c) 2000-2001  Microsoft Corporation
;
;  Module Name:
;
;     startup.asm
;
;  Abstract:
;
;     This module implements the entry point for the 32-bit boot loader code.
;
;  Environment:
;
;     32-bit protected mode.
;
;--

        .586p

        INCLUDE bldr.inc
        INCLUDE ks386.inc

        EXTERN  _BldrStartup2@0:NEAR
        EXTERN  _BldrTopOfROMAddress:DWORD
        EXTERN  _XboxCryptKeys:DWORD
        EXTERN  _BldrReencryptROM@0:NEAR

_TEXT   SEGMENT PARA USE32 PUBLIC 'CODE'

        ASSUME  DS:_TEXT, ES:_TEXT, SS:_TEXT, FS:NOTHING, GS:NOTHING

;
; BldrStartup
;
; Entry point for the 32-bit boot loader.
;
; The DWORD immediately before the entry point is the address of the routine to
; reload a media ROM.  When the kernel loads a ROM from the hard disk or CD-ROM,
; it will decrypt the boot loader, extract this function pointer relative to the
; boot loader entry point and jump to that code.
;
; The DWORD before the above is used to point to key data.  ROMBLD uses this
; to find where the keys are located in this image
;

        dd      OFFSET _XboxCryptKeys
        dd      OFFSET @BldrLoadMediaROM@4
        PUBLIC  _BldrStartup
_BldrStartup PROC

;
; Flush the processor's caches and disable the MTRRs in order to change the MTRR
; policy.  At this point, the MTRRs are initialized to map memory either as
; uncached or write-back.
;

        mov     eax, cr0                ; disable and flush cache
        or      eax, (CR0_CD OR CR0_NW)
        mov     cr0, eax
        wbinvd

        mov     eax, cr3                ; flush TLB
        mov     cr3, eax

        mov     ecx, 2FFh               ; disable MTRR
        xor     eax, eax
        xor     edx, edx
        wrmsr

;
; Set up the first 64MB (or 128MB for DEVKIT) to writeback using the first
; variable-range MTRR.
;

        mov     ecx, 200h
        mov     eax, 6                  ; physical base 00000h as writeback
        xor     edx, edx
        wrmsr

        inc     ecx
ifdef DEVKIT
        mov     eax, 0F8000800h         ; physical mask FF8000h, 128MB for DEVKIT
else
        mov     eax, 0FC000800h         ; physical mask FFC000h, 64MB
endif
        mov     edx, 00000000Fh
        wrmsr

;
; Set up the top 512KB to write-protected using the second variable-range MTRR.
;

        inc     ecx
        mov     eax, 0FFF80005h         ; physical base 0FFF80h as write-protected
        xor     edx, edx
        wrmsr

        inc     ecx
        mov     eax, 0FFF80800h         ; physical mask FFFF80h
        mov     edx, 00000000Fh
        wrmsr

;
; Reset the contents of the rest of the variable-range MTRRs.
;

        inc     ecx
        xor     eax, eax
        xor     edx, edx
@@:
        wrmsr
        inc     ecx
        cmp     ecx, 20Fh
        jbe     @B

;
; Enable MTRR, disable fix-range MTRRs and set default memory type to UC.
;

        mov     ecx, 2FFh
        mov     eax, 800h
        wrmsr

;
; Enable the processor cache by clearing cache disable and not-write-through
; flags in CR0.
;

        mov     eax, cr0
        and     eax, NOT (CR0_CD OR CR0_NW)
        mov     cr0, eax

;
; Load the various segment registers with the expected values.
;

        mov     eax, KGDT_R0_DATA
        mov     ds, eax
        mov     es, eax
        mov     ss, eax
        mov     esp, BLDR_RELOCATED_ORIGIN

        xor     eax, eax
        mov     fs, eax
        mov     gs, eax

;
; Copy the boot loader to the relocated boot origin so that once we jump to
; BldrStartup2, we'll be out of the way of the base address of XBOXKRNL.EXE.
;

        cld
ifdef MCP_B02XM3
        mov     esi, BLDR_BOOT_ORIGIN
else
        mov     esi, ebp
endif
        mov     edi, BLDR_RELOCATED_ORIGIN
        mov     ecx, ROMLDR_SIZE / 4
        rep     movsd

;
; Fill in the page directory with identify mappings for the first 256M of memory
; at both linear address 0x00000000 and 0x80000000.  Large pages (4MB) are used
; for this mapping.  Zero out the rest of the page directory.
;

        mov     edi, PAGE_DIRECTORY_PHYSICAL_ADDRESS
        mov     ecx, 64
        mov     eax, BLDR_VALID_KERNEL_LARGE_PTE_BITS   ; Set valid, write, large Page, PFN=0
@@:
        mov     DWORD PTR [edi+800h], eax
        stosd
        add     eax, 400000h                            ; Advanced PFN to the next 4MB page.
        loop    @B

        mov     ecx, 448
        xor     eax, eax
@@:
        mov     DWORD PTR [edi+800h], eax
        stosd
        loop    @B

;
; Double map the page directory page.
;

        mov     edi, PAGE_DIRECTORY_PHYSICAL_ADDRESS
        mov     eax, PAGE_DIRECTORY_PHYSICAL_ADDRESS + BLDR_VALID_KERNEL_PTE_BITS
        mov     DWORD PTR [edi + ((0C0000000h SHR 22) SHL 2)], eax

;
; Identity map 4MB of ROM space to the page directory.
;

        mov     eax, 0FFC00000h + BLDR_VALID_KERNEL_LARGE_PTE_BITS
        mov     DWORD PTR [edi + ((0FFC00000h SHR 22) SHL 2)], eax

;
; Identity map 16MB of GPU register space to the page directory (uncached)
;
        mov     eax, XPCICFG_GPU_MEMORY_REGISTER_BASE_0 + BLDR_VALID_KERNEL_LARGE_PTE_UC_BITS
        mov     ebx, eax
        shr     ebx, (22 - 2)
        add     edi, ebx
        mov     DWORD PTR [edi], eax    ; 4MB
        add     edi, 4
        add     eax, 400000h
        mov     DWORD PTR [edi], eax    ; 8MB
        add     edi, 4
        add     eax, 400000h
        mov     DWORD PTR [edi], eax    ; 12MB
        add     edi, 4
        add     eax, 400000h
        mov     DWORD PTR [edi], eax    ; 16MB

;
; Initialize the page attribute table (PAT_TYPE_WB, PAT_TYPE_USWC,
; PAT_TYPE_WEAK_UC, PAT_TYPE_STRONG_UC in the low and high elements of the
; table).
;

        mov     eax, cr0
        mov     ebx, eax
        and     eax, NOT CR0_NW
        or      eax, CR0_CD
        mov     cr0, eax                ; Disable caching and line fill
        wbinvd
        mov     ecx, 277h               ; PAT register
        mov     eax, 00070106h          ; STRONG_UC, WEAK_UC, UWSC, WB
        mov     edx, eax
        wrmsr
        wbinvd
        mov     cr0, ebx                ; Restore cr0

;
; Enable the processor's large page support, FXSR support, and XMMI exception
; handling.
;

        mov     eax, cr4
        or      eax, CR4_PSE + CR4_FXSR + CR4_XMMEXCPT
        mov     cr4, eax

;
; Load the address of the page directory into the processor.
;

        mov     eax, PAGE_DIRECTORY_PHYSICAL_ADDRESS
        mov     cr3, eax

;
; Enable the paging support, and numeric exception support.
;

        mov     eax, cr0
        or      eax, CR0_PG + CR0_WP + CR0_NE
        mov     cr0, eax

        jmp     @F
@@:

;
; Reload the stack segment register with its mapped address.
;

        mov     esp, 080000000h + BLDR_RELOCATED_ORIGIN

;
; Call the C entry point of the boot loader.  Note that we need to load the
; address of the C entry point into a register in order to obtain the absolute
; address of the entry point.  If we call BldrStartup2 directly, then a EIP
; relative call will be generated and we'll run from the boot origin instead of
; the relocated origin.
;

        lea     eax, _BldrStartup2@0
        call    eax

;
; Spin. We should not get here
;

@@:     jmp     @B

_BldrStartup ENDP

;
; BldrLoadMediaROM
;
; Invoked by XBOXKRNL.EXE to load another instance of the ROM from the CD-ROM or
; hard disk.
;

        PUBLIC  @BldrLoadMediaROM@4

@BldrLoadMediaROM@4 PROC

IFNDEF MCP_XMODE3
        
        cli
        mov     edx, ecx

;
; Fill in the page directory with identify mappings for the first 256M of memory
; at both linear address 0x00000000 and 0x80000000.  Large pages (4MB) are used
; for this mapping.  Zero out the rest of the page directory.
;

        mov     edi, 080000000h + PAGE_DIRECTORY_PHYSICAL_ADDRESS
        mov     ecx, 64
        mov     eax, BLDR_VALID_KERNEL_LARGE_PTE_BITS   ; Set valid, write, large Page, PFN=0
@@:
        mov     DWORD PTR [edi+800h], eax
        stosd
        add     eax, 400000h                            ; Advanced PFN to the next 4MB page.
        loop    @B

        mov     ecx, 448
        xor     eax, eax
@@:
        mov     DWORD PTR [edi+800h], eax
        stosd
        loop    @B

;
; Double map the page directory page.
;

        mov     edi, 080000000h + PAGE_DIRECTORY_PHYSICAL_ADDRESS
        mov     eax, PAGE_DIRECTORY_PHYSICAL_ADDRESS + BLDR_VALID_KERNEL_PTE_BITS
        mov     DWORD PTR [edi + ((0C0000000h SHR 22) SHL 2)], eax

;
; Map the shadow ROM into the top of memory.  This can't be done with large
; page mapping, so we borrow the page below the page directory for the
; page table.  We'll map the upper 1MB and leave the rest of it undefined
;
        sub     eax, 01000h
        mov     DWORD PTR [edi + ((0FFF00000h SHR 22) SHL 2)], eax
        sub     edi, 0400h
        lea     eax, [edx + BLDR_VALID_KERNEL_PTE_BITS]
        mov     ecx, 0100h
@@:
        stosd
        add     eax, 01000h
        loop    @B

;
; Load the address of the page directory into the processor.  This should end up
; being the same page directory that we're already running on, but this will
; flush out the stale entries in the TLB.
;

        mov     eax, PAGE_DIRECTORY_PHYSICAL_ADDRESS
        mov     cr3, eax

;
; We're going to be overwriting the current kernel image, including the current
; global descriptor table, so move us to a safe table.
;

        lgdt    FWORD PTR [BldrRestartGDTFWORD]

;
; Execute a 16:32 jump to reload the code selector.
;

        db      0EAh
        dd      OFFSET lmr10
        dw      KGDT_R0_CODE
lmr10:

;
; Load the various segment registers with the expected values.
;

        mov     eax, KGDT_R0_DATA
        mov     ds, eax
        mov     es, eax
        mov     ss, eax
        mov     esp, 080000000h + BLDR_RELOCATED_ORIGIN

        xor     eax, eax
        mov     fs, eax
        mov     gs, eax

;
; Store the virtual address of the shadow ROM in the global pointer so that we
; don't go back to the real ROM.
;

        add     edx, 080000000h + ROM_SHADOW_SIZE
        mov     DWORD PTR [_BldrTopOfROMAddress], edx

;
; Reencrypt the boot loader to restore the original ROM image
;

        call    _BldrReencryptROM@0

;
; Call the C entry point of the boot loader.
;

        lea     eax, _BldrStartup2@0
        call    eax
ENDIF
;
; Spin. We should not get here.
;

@@:     jmp     @B

@BldrLoadMediaROM@4 ENDP

;
; Values to initialize the processor's descriptor tables.
;

        ALIGN   4
BldrRestartGDT LABEL DWORD
        dd      0                       ; KGDT_NULL
        dd      0
        dd      00000FFFFh              ; KGDT_R0_CODE
        dd      000CF9B00h
        dd      00000FFFFh              ; KGDT_R0_DATA
        dd      000CF9300h
BldrRestartGDTEnd LABEL DWORD

        ALIGN   4
BldrRestartGDTFWORD LABEL FWORD
        dw      OFFSET BldrRestartGDTEnd - OFFSET BldrRestartGDT
        dd      OFFSET BldrRestartGDT

_TEXT   ENDS

        END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\bootx\bldr32\i386\debug.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    debug.c

Abstract:

    This module implements routines to assist debugging the boot loader.

--*/

#include "bldr32.h"
#include <stdio.h>
#include <dos.h>

VOID
DbgInitializeSuperIo(
    VOID
    );

#define COM_DAT     0x00
#define COM_IEN     0x01            // interrupt enable register
#define COM_LCR     0x03            // line control registers
#define COM_MCR     0x04            // modem control reg
#define COM_LSR     0x05            // line status register
#define COM_MSR     0x06            // modem status register
#define COM_DLL     0x00            // divisor latch least sig
#define COM_DLM     0x01            // divisor latch most sig

#define COM_BI      0x10
#define COM_FE      0x08
#define COM_PE      0x04
#define COM_OE      0x02

#define LC_DLAB     0x80            // divisor latch access bit

#define CLOCK_RATE  0x1C200         // USART clock rate

#define MC_DTRRTS   0x03            // Control bits to assert DTR and RTS
#define MS_DSRCTSCD 0xB0            // Status bits for DSR, CTS and CD
#define MS_CD       0x80

#define COM_OUTRDY  0x20
#define COM_DATRDY  0x01

BOOLEAN DbgInitialized = FALSE;
USHORT DbgBaseAddress = 0x3F8;
ULONG DbgBaudRate = 19200;

VOID
DbgInitialize(
    VOID
    )
{
    ULONG DivisorLatch;

    DbgInitializeSuperIo();

    DivisorLatch = CLOCK_RATE / DbgBaudRate;

    _outp(DbgBaseAddress + COM_LCR, 0x83);
    _outp(DbgBaseAddress + COM_DLM, (UCHAR)(DivisorLatch >> 8));
    _outp(DbgBaseAddress + COM_DLL, (UCHAR)(DivisorLatch));
    _outp(DbgBaseAddress + COM_LCR, 0x03);

    _outp(DbgBaseAddress + COM_MCR, MC_DTRRTS);
    _outp(DbgBaseAddress + COM_IEN, 0);

    DbgInitialized = TRUE;
}

VOID
DbgPrintCharacter(
    IN UCHAR Character
    )
{
    while (!(_inp(DbgBaseAddress + COM_LSR) & COM_OUTRDY));

    _outp(DbgBaseAddress + COM_DAT, Character);
}


ULONG
DbgPrint(
    PCHAR Format,
    ...
    )
{
    va_list arglist;
    UCHAR Buffer[512];
    int cb;
    int current;

    if (!DbgInitialized) {
        DbgInitialize();
    }

    va_start(arglist, Format);

    cb = _vsnprintf(Buffer, sizeof(Buffer), Format, arglist);

    va_end(arglist);

    for (current = 0; current < cb; current++) {
        DbgPrintCharacter(Buffer[current]);
    }
    DbgPrintCharacter('\r');
    DbgPrintCharacter('\n');

    return STATUS_SUCCESS;
}


VOID
DbgPrintHex(
    PUCHAR Buffer,
    ULONG  BufferSize
    )
{
    UCHAR Nibble;
    ULONG i;
    
    if (!DbgInitialized) {
        DbgInitialize();
    }

    for (i = 0; i < BufferSize; i++) {

        Nibble = (Buffer[i] & 0xF0) >> 4;
    
        if (Nibble <= 9) {
            Nibble += '0';
        } else {
            Nibble -= 10;
            Nibble += 'A';
        }
        DbgPrintCharacter(Nibble);
    
        Nibble = (Buffer[i] & 0x0F);
    
        if (Nibble <= 9) {
            Nibble += '0';
        } else {
            Nibble -= 10;
            Nibble += 'A';
        }
        DbgPrintCharacter(Nibble);
    }
    DbgPrintCharacter('\r');
    DbgPrintCharacter('\n');
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\bootx\bldr32\i386\romdata.h ===
/*++

Copyright (c) 1989-2000  Microsoft Corporation

Module Name:

    romdata.h

Abstract:

    Header file for XBox boot loader (contains datatbl format)


--*/

#ifndef _DATATBL_H
#define _DATATBL_H

//
// Data struct contains all of the drive/slew parameters.
//
typedef struct _drv_slw_cal_params {
    USHORT MaxMClk;

    UCHAR SlowCountExt;
    UCHAR SlowCountBExt;
    UCHAR SlowCountAvg;
    UCHAR SlowCountBAvg;
    UCHAR TypiCount;
    UCHAR TypiCountB;
    UCHAR FastCountAvg;
    UCHAR FastCountBAvg;
    UCHAR FastCountExt;
    UCHAR FastCountBExt;
} DRVSLWCALPARAMS, *PDRVSLWCALPARAMS;

//
// Data structure contains the drive/slew per-speed process parameters.
//
typedef struct _drv_slw_pad_params {
    UCHAR AdrDrvFall;
    UCHAR AdrDrvRise;
    UCHAR AdrSlwFall;
    UCHAR AdrSlwRise;

    UCHAR ClkDrvFall;
    UCHAR ClkDrvRise;
    UCHAR ClkSlwFall;
    UCHAR ClkSlwRise;

    UCHAR DatDrvFall;
    UCHAR DatDrvRise;
    UCHAR DatSlwFall;
    UCHAR DatSlwRise;

    UCHAR DqsDrvFall;
    UCHAR DqsDrvRise;
    UCHAR DqsSlwFall;
    UCHAR DqsSlwRise;

    UCHAR DataInbDely;
    UCHAR ClkIcDely;
    UCHAR DqsInbDely;
} DRVSLWPADPARAMS, *PDRVSLWPADPARAMS;


enum {
    DrvSlwExtFast = 0,
    DrvSlwAvgFast,
    DrvSlwTypical,
    DrvSlwAvgSlow,
    DrvSlwExtSlow,
    DrvSlwTotal,
};


//
// Complete layout of the ROM data table
//
typedef struct _rom_datatbl {
    DRVSLWCALPARAMS calParams;
    DRVSLWPADPARAMS SamsungParams[DrvSlwTotal];
    DRVSLWPADPARAMS MicronParams[DrvSlwTotal];
} ROM_DATATBL, *PROM_DATATBL;

#endif // _DATATBL_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\bootx\bldr32\i386\smbus.asm ===
TITLE   "SMBus Routines"
;++
;
;  Copyright (c) Microsoft Corporation
;
;  Module Name:
;
;     smbus.asm
;
;  Abstract:
;
;     This module implements the routines to send and receive data over SMBus.
;
;
;--

        .686p
        .xlist
INCLUDE ks386.inc
INCLUDE callconv.inc
        .list

;
; Define the SMBus registers starting at XPCICFG_SMBUS_IO_REGISTER_BASE_1.
;

MCPX_SMBUS_HOST_STATUS_REGISTER         EQU     00h
MCPX_SMBUS_HOST_CONTROL_REGISTER        EQU     02h
MCPX_SMBUS_HOST_ADDRESS_REGISTER        EQU     04h
MCPX_SMBUS_HOST_DATA_REGISTER           EQU     06h
MCPX_SMBUS_HOST_COMMAND_REGISTER        EQU     08h
MCPX_SMBUS_HOST_BLOCK_DATA_REGISTER     EQU     09h

;
; Define the status bits for MCPX_SMBUS_HOST_STATUS_REGISTER.
;

MCPX_STATUS_HOST_ABORT                  EQU     0001h
MCPX_STATUS_COLLISION                   EQU     0002h
MCPX_STATUS_PROTOCOL_ERROR              EQU     0004h
MCPX_STATUS_HOST_BUSY                   EQU     0008h
MCPX_STATUS_HOST_CYCLE_COMPLETE         EQU     0010h
MCPX_STATUS_TIMEOUT_ERROR               EQU     0020h

;
; Define the control bits for MCPX_SMBUS_HOST_CONTROL_REGISTER.
;

MCPX_CONTROL_CYCLE_READ_WRITE_BYTE      EQU     0002h
MCPX_CONTROL_CYCLE_READ_WRITE_WORD      EQU     0003h
MCPX_CONTROL_HOST_START                 EQU     0008h

_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

;++
;
; NTSTATUS
; BldrReadSMBusValue(
;     IN UCHAR SlaveAddress,
;     IN UCHAR CommandCode,
;     IN BOOLEAN ReadWordValue,
;     OUT UCHAR *DataValue
;     )
;
; Routine Description:
;
;     This routine submits a "read byte" or "read word" transaction over SMBus.
;
; Arguments:
;
;     SlaveAddress - Specifies the slave address of the SMBus device to access.
;
;     CommandCode - Specifies the command field to pass during as part of the
;         host cycle.
;
;     ReadWordValue - Specifies TRUE if 16-bits should be read, else FALSE if
;         8-bits should be read.
;
;     DataValue - Specifies the location of the buffer to receive the data read
;         from the SMBus.
;
; Return Value:
;
;     Status of operation.
;
;--
cPublicProc _BldrReadSMBusValue, 4

RsmbSlaveAddress    EQU     4
RsmbCommandCode     EQU     8
RsmbReadWordValue   EQU     12
RsmbDataValue       EQU     16


;
; Set the host address register.
;

rsmb10: xor     eax, eax                        ; eliminate partial stall
        mov     al, BYTE PTR [esp+RsmbSlaveAddress]
        mov     edx, XPCICFG_SMBUS_IO_REGISTER_BASE_1 + MCPX_SMBUS_HOST_ADDRESS_REGISTER
        or      al, 1                           ; force a read cycle
        out     dx, al

;
; Set the host command register.
;

        mov     al, BYTE PTR [esp+RsmbCommandCode]
        add     edx, MCPX_SMBUS_HOST_COMMAND_REGISTER - MCPX_SMBUS_HOST_ADDRESS_REGISTER
        out     dx, al

;
; Write the current contents of the status register out to itself in order to
; clear the register.
;

        sub     edx, MCPX_SMBUS_HOST_COMMAND_REGISTER - MCPX_SMBUS_HOST_STATUS_REGISTER
        in      ax, dx
        out     dx, ax

;
; Initiate the read transaction.
;

        add     edx, MCPX_SMBUS_HOST_CONTROL_REGISTER - MCPX_SMBUS_HOST_STATUS_REGISTER
        mov     al, MCPX_CONTROL_HOST_START + MCPX_CONTROL_CYCLE_READ_WRITE_BYTE
        cmp     BYTE PTR [esp+RsmbReadWordValue], 0
        je      rsmb15
        inc     al                              ; select the read word cycle
rsmb15: out     dx, al

;
; Spin until the host controller indicates that its not busy.
;

        sub     edx, MCPX_SMBUS_HOST_CONTROL_REGISTER - MCPX_SMBUS_HOST_STATUS_REGISTER
rsmb20: in      al, dx
        test    al, MCPX_STATUS_HOST_BUSY
        jnz     rsmb20

;
; Check if there was a collision on the SMBus.  If so, retry the operation.
;

        test    al, MCPX_STATUS_COLLISION
        jnz     rsmb10

;
; Check if the transaction timed out.
;

        mov     edx, STATUS_IO_TIMEOUT
        test    al, MCPX_STATUS_TIMEOUT_ERROR
        jnz     rsmb30

;
; Check if the transaction caused a protocol error.
;

        mov     edx, STATUS_DEVICE_PROTOCOL_ERROR
        test    al, MCPX_STATUS_PROTOCOL_ERROR
        jnz     rsmb30

;
; Check if the transaction completed successfully.
;

        mov     edx, STATUS_IO_DEVICE_ERROR
        test    al, MCPX_STATUS_HOST_CYCLE_COMPLETE
        jz      rsmb30

;
; Read the host data register and write the contents back to the user's buffer
; and return STATUS_SUCCESS;
;

        xor     eax, eax
        mov     edx, XPCICFG_SMBUS_IO_REGISTER_BASE_1 + MCPX_SMBUS_HOST_DATA_REGISTER
        in      ax, dx
        cmp     BYTE PTR [esp+RsmbReadWordValue], 0
        jne     rsmb25
        xor     ah, ah                          ; only return eight bits of data
rsmb25: mov     edx, DWORD PTR [esp+RsmbDataValue]
        mov     DWORD PTR [edx], eax
        xor     edx, edx                        ; edx = STATUS_SUCCESS

rsmb30:
        mov     eax, edx
        
        stdRET  _BldrReadSMBusValue

stdENDP _BldrReadSMBusValue

;++
;
; NTSTATUS
; BldrWriteSMBusByte(
;     IN UCHAR SlaveAddress,
;     IN UCHAR CommandCode,
;     IN BOOLEAN WriteWordValue,
;     IN ULONG DataValue
;     )
;
; Routine Description:
;
;     This routine submits a "write byte" or "write word" transaction over
;     SMBus.
;
; Arguments:
;
;     SlaveAddress - Specifies the slave address of the SMBus device to access.
;
;     CommandCode - Specifies the command field to pass during as part of the
;         host cycle.
;
;     WriteWordValue - Specifies TRUE if 16-bits should be written, else FALSE
;         if 8-bits should be written.
;
;     DataValue - Specifies the data value to transmit over SMBus.
;
; Return Value:
;
;     Status of operation.
;
;--
cPublicProc _BldrWriteSMBusValue, 4

WsmbSlaveAddress    EQU     4
WsmbCommandCode     EQU     8
WsmbWriteWordValue  EQU     12
WsmbDataValue       EQU     16


;
; Set the host address register.
;

wsmb10: xor     eax, eax                        ; eliminate partial stall
        mov     al, BYTE PTR [esp+WsmbSlaveAddress]
        mov     edx, XPCICFG_SMBUS_IO_REGISTER_BASE_1 + MCPX_SMBUS_HOST_ADDRESS_REGISTER
        and     al, NOT 1                       ; force a write cycle
        out     dx, al

;
; Set the host command register.
;

        mov     al, BYTE PTR [esp+WsmbCommandCode]
        add     edx, MCPX_SMBUS_HOST_COMMAND_REGISTER - MCPX_SMBUS_HOST_ADDRESS_REGISTER
        out     dx, al

;
; Set the host data register.
;

        mov     eax, DWORD PTR [esp+WsmbDataValue]
        sub     edx, MCPX_SMBUS_HOST_COMMAND_REGISTER - MCPX_SMBUS_HOST_DATA_REGISTER
        out     dx, ax

;
; Write the current contents of the status register out to itself in order to
; clear the register.
;

        sub     edx, MCPX_SMBUS_HOST_DATA_REGISTER - MCPX_SMBUS_HOST_STATUS_REGISTER
        in      ax, dx
        out     dx, ax

;
; Initiate the write transaction.
;

        add     edx, MCPX_SMBUS_HOST_CONTROL_REGISTER - MCPX_SMBUS_HOST_STATUS_REGISTER
        mov     al, MCPX_CONTROL_HOST_START + MCPX_CONTROL_CYCLE_READ_WRITE_BYTE
        cmp     BYTE PTR [esp+WsmbWriteWordValue], 0
        je      wsmb15
        inc     al                              ; select the read word cycle
wsmb15: out     dx, al

;
; Spin until the host controller indicates that its not busy.
;

        sub     edx, MCPX_SMBUS_HOST_CONTROL_REGISTER - MCPX_SMBUS_HOST_STATUS_REGISTER
wsmb20: in      al, dx
        test    al, MCPX_STATUS_HOST_BUSY
        jnz     wsmb20

;
; Check if there was a collision on the SMBus.  If so, retry the operation.
;

        test    al, MCPX_STATUS_COLLISION
        jnz     wsmb10

;
; Check if the transaction timed out.
;

        mov     edx, STATUS_IO_TIMEOUT
        test    al, MCPX_STATUS_TIMEOUT_ERROR
        jnz     wsmb30

;
; Check if the transaction caused a protocol error.
;

        mov     edx, STATUS_DEVICE_PROTOCOL_ERROR
        test    al, MCPX_STATUS_PROTOCOL_ERROR
        jnz     wsmb30

;
; Check if the transaction completed successfully.
;

        test    al, MCPX_STATUS_HOST_CYCLE_COMPLETE
        mov     edx, STATUS_IO_DEVICE_ERROR
        jz      wsmb30

;
; The write completed successfully, so return STATUS_SUCCESS.
;

        xor     edx, edx                        ; edx = STATUS_SUCCESS

wsmb30:
        mov     eax, edx
        
        stdRET  _BldrWriteSMBusValue

stdENDP _BldrWriteSMBusValue

_TEXT   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\bootx\bldr32\i386\romcpy.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    romcpy.c

Abstract:

    This module implements code to uncompress, copy, and check Xbox ROM

--*/

#include "bldr32.h"
#include <ldi.h>
#include <bldr.h>
#include <sha.h>
#include <rc4.h>

//
// Local support
//

BOOLEAN
BldrDecompress(
    IN  ULONG FromAddress,
    IN  ULONG ToAddress,
    IN  ULONG UncompressedSize
    );

MI_MEMORY
DIAMONDAPI
BldrAlloc(
    ULONG NumberOfBytes
    );

VOID
DIAMONDAPI
BldrFree(
    MI_MEMORY pointer
    );

//
// Location of the topmost byte, not inclusive, of the ROM.
//
ULONG BldrTopOfROMAddress = 0;

//
// Number of bytes that have been allocated for LZX decompression.  Used to mark
// the top of the heap.
//
ULONG BldrNumberOfBytesAllocated;

VOID
BldrCopyROMToRAM(
    IN const UCHAR* DecryptionKey
    )
/*++

Routine Description:

    Decrypts and decompresses kernel image from ROM to the RAM.  

Arguments:

    DecryptionKey - Key used to decrypt the kernel image

Return Value:

    None.

--*/
{
    ULONG BldrAddress;
    PBOOTLDRPARAM BootLdrParam;
    PXBOOT_PARAM BootParam;
    ULONG CompressedKernelAddress;
    ULONG UncompressedKernelDataAddress;
#ifdef MCP_B02XM3
    A_SHA_CTX SHAHash;
    UCHAR SHADigest[A_SHA_DIGEST_LEN];
    ULONG InitTableAddress;
#endif
    PUCHAR KernelBuffer;

    //
    // Start address for the boot loader image
    //
    BldrAddress = 0x80000000 + BLDR_RELOCATED_ORIGIN;

    //
    // Calculate a pointer to the boot parameters stored at the begining of
    // of the boot loader image eg command line.  In case of ROM, entire image
    // including the parameter structure is decrypted so its safe to use
    // the command line which will normally be empty.
    //
    BootLdrParam = (PBOOTLDRPARAM)BldrAddress;

    //
    // Boot param structure is at the end of the boot loader block
    //
    BootParam = (PXBOOT_PARAM)(BldrAddress + BLDR_BLOCK_SIZE - sizeof(XBOOT_PARAM));

    //
    // Compute the address of the uncompressed kernel data block
    //
    UncompressedKernelDataAddress = 0 - ROM_DEC_SIZE -
        BLDR_BLOCK_SIZE - BootParam->UncompressedKernelDataSize;

    //
    // Compute the address of the compressed kernel image
    //
    CompressedKernelAddress = UncompressedKernelDataAddress -
        BootParam->CompressedKernelSize;

#ifdef MCP_B02XM3

    //
    // Calculate SHA1 digest for the compressed kernel image and uncompressed
    // kernel data block.
    //
    // Compute the address of the init table.  The ROM image is aliased
    // through out the top 16MB of address space.  For a 1MB image, it will
    // be aliased 16 times.  We use the top 1MB alias and the address mapped
    // in startup.asm.  This should work fine for 512K or 256K but will not
    // work for parts larger than 1MB.
    //
    InitTableAddress = 0UL - 0x100000;

    BldrPrint(("Bldr: Init Table=%08x, Version=%x", InitTableAddress, 
        *((PUCHAR)(InitTableAddress + 0x78))));

    //
    // Calculate a SHA1 digest with the following ROM components
    //     1. Size and contents of compressed and encrypted kernel in ROM
    //     2. Size and contents of uncompressed data
    //     3. Size and contents of init table
    //
    // Note: We calculate the digests directly from ROM rather than 
    // depending on the contents of RAM at this point
    //

    A_SHAInit(&SHAHash);
    A_SHAUpdate(&SHAHash, (PUCHAR)DecryptionKey, 16);
    A_SHAUpdate(&SHAHash, (PUCHAR)&BootParam->CompressedKernelSize, sizeof(ULONG));
    A_SHAUpdate(&SHAHash, (PVOID)CompressedKernelAddress, BootParam->CompressedKernelSize);
    
    A_SHAUpdate(&SHAHash, (PUCHAR)&BootParam->UncompressedKernelDataSize, sizeof(ULONG));
    A_SHAUpdate(&SHAHash, (PVOID)UncompressedKernelDataAddress, BootParam->UncompressedKernelDataSize);
    
#ifdef DEVKIT
    //
    // Hack to allow manual editing of the init table.  For devkit systems, if
    // the InitTableSize is 0, we skip calculating the digest for the init table
    // This can be initiatiated by ROMBLD's /HACKINITTABLE option
    //
    if (BootParam->InitTableSize != 0) {
        A_SHAUpdate(&SHAHash, (PUCHAR)&BootParam->InitTableSize, sizeof(ULONG));
        A_SHAUpdate(&SHAHash, (PVOID)InitTableAddress, BootParam->InitTableSize);
    }

#else
    
    A_SHAUpdate(&SHAHash, (PUCHAR)&BootParam->InitTableSize, sizeof(ULONG));
    A_SHAUpdate(&SHAHash, (PVOID)InitTableAddress, BootParam->InitTableSize);

#endif

    A_SHAFinal(&SHAHash, SHADigest);
    A_SHAInit(&SHAHash);
    A_SHAUpdate(&SHAHash, (PUCHAR)DecryptionKey, 16);
    A_SHAUpdate(&SHAHash, SHADigest, sizeof SHADigest);
    A_SHAFinal(&SHAHash, SHADigest);

    //
    // Compare the calculated digest with the digest in the boot param
    //
    if (memcmp(SHADigest, BootParam->MainRomDigest, sizeof(SHADigest)) != 0) {
        BldrPrint(("Bldr: ROM digests do not match"));

        BldrShutdownSystem();
    }

#endif // MCP_B02XM3

    //
    // If we got here, the ROM image is OK to decrypt.  Allocate enough space
    // so we can copy the compessed encrypted kernel image to RAM.  We don't have to
    // worry about freeing this memory.
    //
    KernelBuffer = (PUCHAR)BldrAlloc(BootParam->CompressedKernelSize);

    //
    // Copy the compress encrypted kernel image from ROM to RAM
    //
    BldrPrint(("Bldr: Copying from %08x to %08x", CompressedKernelAddress, KernelBuffer));
    memcpy(KernelBuffer, (PUCHAR)CompressedKernelAddress, BootParam->CompressedKernelSize);

    //
    // Decrypt the RAM kernel buffer in place
    //
    BldrEncDec(KernelBuffer, BootParam->CompressedKernelSize, DecryptionKey, 16);

    //
    // Decompress the decrypted RAM kernel buffer to the location kernel image
    // needs to run from
    //
    BldrDecompress((ULONG_PTR)KernelBuffer, (ULONG_PTR)PsNtosImageBase,
        BootParam->CompressedKernelSize);

    //
    // Fixup the pointer to the uncompressed .data with the actual load address
    // of the ROM.  If the ROM is loaded at the top of memory, then this doesn't
    // affect the pointer.
    //
    ((PXDATA_SECTION_HEADER)(((PIMAGE_DOS_HEADER)PsNtosImageBase)->e_res2))->PointerToRawData +=
        BldrTopOfROMAddress;
}

MI_MEMORY
DIAMONDAPI
BldrAlloc(
    ULONG NumberOfBytes
    )
/*++

Routine Description:

    Simple memory allocation used for limited known allocation

Arguments:

Return Value:

    A pointer to where the memory was allocated

--*/
{
    PVOID BaseAddress;

    BaseAddress = (PVOID)(0x80000000 + BLDR_RELOCATED_ORIGIN + BLDR_BLOCK_SIZE +
        BldrNumberOfBytesAllocated);

    BldrNumberOfBytesAllocated += NumberOfBytes;

    BldrPrint(("Bldr: Allocate %d bytes at %x", NumberOfBytes, BaseAddress));

    return BaseAddress;
}

VOID
DIAMONDAPI
BldrFree(
    MI_MEMORY pointer
    )
{
    // we don't need to free the memory
}

BOOLEAN
BldrDecompress(
    IN  ULONG FromAddress,
    IN  ULONG ToAddress,
    IN  ULONG UncompressedSize
    )
{
    PLZXBOX_BLOCK Block;
    ULONG Source;
    ULONG Dest;
    UINT SourceSize;
    LZXDECOMPRESS Decomp;
    UINT DestSize;
    ULONG BytesDecompressed;
    LDI_CONTEXT_HANDLE Handle;
    BOOLEAN Success = FALSE;

    BldrPrint(("Bldr: Decompressing from=0x%08X to=0x%08X bytes=%d", 
        FromAddress, ToAddress, UncompressedSize));
    
    //
    // Initialize decompression engine
    //
    Decomp.fCPUtype = LDI_CPU_80386;
    Decomp.WindowSize = LZX_WINDOW_SIZE;

    SourceSize = LZX_CHUNK_SIZE;
    if (LDICreateDecompression(&SourceSize, &Decomp, BldrAlloc, BldrFree, &DestSize,
        &Handle, NULL,NULL,NULL,NULL,NULL) != MDI_ERROR_NO_ERROR) {
        
        BldrPrint(("Bldr: Failed to init decompression engine"));
        
        return Success;
    }

    Source = FromAddress;
    Dest = ToAddress;
    for (;;) {

        //
        // Read the compression block
        //
        Block = (PLZXBOX_BLOCK)Source;
        Source += sizeof(LZXBOX_BLOCK);

        //
        // Perform decompression
        //
        BytesDecompressed = Block->UncompressedSize;
        if (LDIDecompress(Handle, (PVOID)Source, Block->CompressedSize, (PVOID)Dest,
            &BytesDecompressed) != MDI_ERROR_NO_ERROR) {
            goto CleanupAndExit;
        }

        //
        // Advance the pointers
        //
        Source += Block->CompressedSize;
        Dest += Block->UncompressedSize;

        //
        // Check to see if we are done
        //
        if ((Source - FromAddress) >= UncompressedSize) {
            break;
        }
    }

    Success = TRUE;

CleanupAndExit:
    (VOID)LDIDestroyDecompression(Handle);

    BldrPrint(("Bldr: Decompression %s", (Success ? "successful" : "failed")));

    return Success;
}

VOID
BldrShutdownSystem(
    VOID
    )
/*++

Routine Description:

    Shutdown the system.

Arguments:

    None.

Return Value:

    None.

--*/
{
    BldrPrint(("Bldr: *** Shutdown occurred"));

#ifdef RETAILXM3
    //
    // Flat line the clocks
    //

    _outpd(PCI_TYPE1_ADDR_PORT, 0x8000036C);
    _outpd(PCI_TYPE1_DATA_PORT, 0x01000000);
    
#endif

    __asm {
        hlt
    }
}


VOID
BldrEncDec(
    IN  PUCHAR  MsgData,
    IN  ULONG   MsgDataLen,
    IN  const UCHAR* Key,
    IN  ULONG   KeyBytes
    )
/*++

Routine Description:

    Encrypt or decrypt the given data buffer in-place using RC4 which is symmetric algorithm.

Arguments:


Return Value:

    None

--*/
{
    struct RC4_KEYSTRUCT rc4KeyCtl;

    BldrPrint(("Bldr: Decrypting %d bytes at %x", MsgDataLen, MsgData));

    rc4_key(&rc4KeyCtl, (UINT)KeyBytes, (PUCHAR)Key);

    rc4(&rc4KeyCtl, (UINT)MsgDataLen, MsgData);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\bootx\bldr32\i386\enckey.h ===
//
// NOTE: Checked in version of this file should only contain the test keys
// The checked in keys are intended to be used for DevKits (xm2) only.
//


//
// Encryption key used to encrypt the boot loader.  We only use this when
// reloading a media ROM
//
const UCHAR KeyToDecryptBldr[] =
    {
        0x57,0x42,0x29,0x0C,0x30,0x1E,0xD3,0x01,
        0xB3,0xE5,0x5D,0x28,0x50,0x31,0xE1,0xCE
    };

//
// This array contains multiple 16-byte decryption keys:
//  1. The first key is used to decrypt the encrypted section of the EEPROM.
//  2. The second key is the CERT key.
//  3. Encryption key used to encrypt/decrypt the kernel
//
const UCHAR XboxCryptKeys[3 * XBOX_KEY_LENGTH] = {
    // EEPROM key
    0x7b, 0x35, 0xa8, 0xb7, 0x27, 0xed, 0x43, 0x7a,
    0xa0, 0xba, 0xfb, 0x8f, 0xa4, 0x38, 0x61, 0x80,

    // CERT key
    0x66, 0x81, 0x0d, 0x37, 0x91, 0xfd, 0x45, 0x7f,
    0xbf, 0xa9, 0x76, 0xf8, 0xa4, 0x46, 0xa4, 0x94,

    // Kernel encryption key
    0xAD, 0x32, 0x64, 0x01, 0x2F, 0xC8, 0xF4, 0xAD,  
    0xA9, 0xF5, 0xAF, 0x45, 0x22, 0xB7, 0x18, 0xD1   

};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\bootx\bldr32\i386\superio.asm ===
TITLE   "Memory Management Support Routines"
;++
;
;  Copyright (c) 2001  Microsoft Corporation
;
;  Module Name:
;
;     superio.asm
;
;  Abstract:
;
;     This module implements the routines to interact with the system super I/O
;     controller.
;
;  Environment:
;
;     Kernel mode only.
;
;--

        .586p
        .xlist
INCLUDE ks386.inc
INCLUDE callconv.inc
        .list

;
; Define the ports used to interact with the super I/O controller.
;

SMC_CONFIG_PORT                     EQU     02Eh
SMC_INDEX_PORT                      EQU     02Fh
SMC_DATA_PORT                       EQU     02Fh

;
; Define the values to enter and exit the configuration mode of the super I/O
; controller.
;

SMC_ENTER_CONFIGURATION_MODE        EQU     055h
SMC_EXIT_CONFIGURATION_MODE         EQU     0AAh

;
; Define the logical device numbers.
;

SMC_FLOPPY_DRIVE_CONTROLLER         EQU     000h
SMC_PARALLEL_PORT                   EQU     003h
SMC_SERIAL_PORT_1                   EQU     004h
SMC_SERIAL_PORT_2                   EQU     005h
SMC_KEYBOARD                        EQU     007h
SMC_GAME_PORT                       EQU     009h
SMC_PME                             EQU     00Ah
SMC_MPU_401                         EQU     00Bh
SMC_USB_HUB                         EQU     00Ch

;
; Define the global configuration registers.
;

SMC_LOGICAL_DEVICE_NUMBER           EQU     007h

SMC_DEVICE_ACTIVATE                 EQU     030h
SMC_DEVICE_PRIMARY_ADDRESS_HIGH     EQU     060h
SMC_DEVICE_PRIMARY_ADDRESS_LOW      EQU     061h

;++
;
;   IODELAY
;
;   Macro Description:
;
;       This macro simply does a jmp to next instruction to synchronize
;       IO port access.
;
;   Arguments:
;
;       None
;
;--

IODELAY         macro
ifdef NEC_98
        out     5fh,al              ; same effect with "stdcall IODelay8259"
else  ; NEC_98
        jmp     $+2
endif ; NEC_98
endm

_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

;++
;
; VOID
; DbgInitializeSuperIo(
;     VOID
;     )
;
; Routine Description:
;
;     This function initializes the super I/O controller.
;
; Arguments:
;
;     None.
;
; Return Value:
;
;     None.
;
;--
cPublicProc _DbgInitializeSuperIo, 0

;
; Place the the super I/O controller in configuration mode.
;

        mov     edx, SMC_CONFIG_PORT
        mov     al, SMC_ENTER_CONFIGURATION_MODE
        out     dx, al
        IODelay

;
; Select the first serial I/O port for configuration.
;

        mov     al, SMC_LOGICAL_DEVICE_NUMBER
        out     dx, al
        IODelay
        inc     edx
        mov     al, SMC_SERIAL_PORT_1
        out     dx, al
        IODelay
        dec     edx

;
; Activate the first serial I/O port at a base address of 0x03F8.
;

        mov     al, SMC_DEVICE_ACTIVATE
        out     dx, al
        IODelay
        inc     edx
        mov     al, 1
        out     dx, al
        IODelay
        dec     edx

        mov     al, SMC_DEVICE_PRIMARY_ADDRESS_HIGH
        out     dx, al
        IODelay
        inc     edx
        mov     al, 003h
        out     dx, al
        IODelay
        dec     edx

        mov     al, SMC_DEVICE_PRIMARY_ADDRESS_LOW
        out     dx, al
        IODelay
        inc     edx
        mov     al, 0F8h
        out     dx, al
        IODelay
        dec     edx

;
; Take the the super I/O controller out of configuration mode.
;

        mov     al, SMC_EXIT_CONFIGURATION_MODE
        out     dx, al

        stdRET  _DbgInitializeSuperIo

stdENDP _DbgInitializeSuperIo

_TEXT  ends

        END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\bootx\preldr32\i386\superio.asm ===
TITLE   "Memory Management Support Routines"
;++
;
;  Copyright (c) 2001  Microsoft Corporation
;
;  Module Name:
;
;     superio.asm
;
;  Abstract:
;
;     This module implements the routines to interact with the system super I/O
;     controller.
;
;  Environment:
;
;     Kernel mode only.
;
;--

        .586p
        .xlist
INCLUDE ks386.inc
INCLUDE callconv.inc
        .list

;
; Define the ports used to interact with the super I/O controller.
;

SMC_CONFIG_PORT                     EQU     02Eh
SMC_INDEX_PORT                      EQU     02Fh
SMC_DATA_PORT                       EQU     02Fh

;
; Define the values to enter and exit the configuration mode of the super I/O
; controller.
;

SMC_ENTER_CONFIGURATION_MODE        EQU     055h
SMC_EXIT_CONFIGURATION_MODE         EQU     0AAh

;
; Define the logical device numbers.
;

SMC_FLOPPY_DRIVE_CONTROLLER         EQU     000h
SMC_PARALLEL_PORT                   EQU     003h
SMC_SERIAL_PORT_1                   EQU     004h
SMC_SERIAL_PORT_2                   EQU     005h
SMC_KEYBOARD                        EQU     007h
SMC_GAME_PORT                       EQU     009h
SMC_PME                             EQU     00Ah
SMC_MPU_401                         EQU     00Bh
SMC_USB_HUB                         EQU     00Ch

;
; Define the global configuration registers.
;

SMC_LOGICAL_DEVICE_NUMBER           EQU     007h

SMC_DEVICE_ACTIVATE                 EQU     030h
SMC_DEVICE_PRIMARY_ADDRESS_HIGH     EQU     060h
SMC_DEVICE_PRIMARY_ADDRESS_LOW      EQU     061h

;++
;
;   IODELAY
;
;   Macro Description:
;
;       This macro simply does a jmp to next instruction to synchronize
;       IO port access.
;
;   Arguments:
;
;       None
;
;--

IODELAY         macro
ifdef NEC_98
        out     5fh,al              ; same effect with "stdcall IODelay8259"
else  ; NEC_98
        jmp     $+2
endif ; NEC_98
endm

_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

;++
;
; VOID
; DbgInitializeSuperIo(
;     VOID
;     )
;
; Routine Description:
;
;     This function initializes the super I/O controller.
;
; Arguments:
;
;     None.
;
; Return Value:
;
;     None.
;
;--
cPublicProc _DbgInitializeSuperIo, 0

;
; Place the the super I/O controller in configuration mode.
;

        mov     edx, SMC_CONFIG_PORT
        mov     al, SMC_ENTER_CONFIGURATION_MODE
        out     dx, al
        IODelay

;
; Select the first serial I/O port for configuration.
;

        mov     al, SMC_LOGICAL_DEVICE_NUMBER
        out     dx, al
        IODelay
        inc     edx
        mov     al, SMC_SERIAL_PORT_1
        out     dx, al
        IODelay
        dec     edx

;
; Activate the first serial I/O port at a base address of 0x03F8.
;

        mov     al, SMC_DEVICE_ACTIVATE
        out     dx, al
        IODelay
        inc     edx
        mov     al, 1
        out     dx, al
        IODelay
        dec     edx

        mov     al, SMC_DEVICE_PRIMARY_ADDRESS_HIGH
        out     dx, al
        IODelay
        inc     edx
        mov     al, 003h
        out     dx, al
        IODelay
        dec     edx

        mov     al, SMC_DEVICE_PRIMARY_ADDRESS_LOW
        out     dx, al
        IODelay
        inc     edx
        mov     al, 0F8h
        out     dx, al
        IODelay
        dec     edx

;
; Take the the super I/O controller out of configuration mode.
;

        mov     al, SMC_EXIT_CONFIGURATION_MODE
        out     dx, al

        stdRET  _DbgInitializeSuperIo

stdENDP _DbgInitializeSuperIo

_TEXT  ends

        END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\bootx\preldr32\preldr32.c ===
/*
 *
 * preldr32.c
 *
 * Boot pre-loader
 *
 */

#include "ntos.h"
typedef ULONG DWORD, *PDWORD, *LPDWORD;
typedef UCHAR BYTE, *PBYTE, *LPBYTE;
typedef ULONG BOOL;
#define far
#include <xcrypt.h>
#include <sha.h>
#include <rsa.h>
#include <rc4.h>
#include <bldr.h>
#include <stdio.h>

BOOLEAN
VerifyDigest(
    PUCHAR PubKey,
    PUCHAR EncryptedDigest, 
    PUCHAR PlaintextDigest
);

VOID
DbgInitialize(
    VOID
    );

VOID
DbgPrintCharacter(
    UCHAR
    );

#ifndef MCP_XMODE3P
static UCHAR BldrEncKey[] =
{
    0x57,0x42,0x29,0x0C,0x30,0x1E,0xD3,0x01,
    0xB3,0xE5,0x5D,0x28,0x50,0x31,0xE1,0xCE
};
#endif

// Public key matches the XBE public key

UCHAR EncryptedPubKey[] =
{
#ifdef RETAILPUBKEY
#else
    0x52,0x53,0x41,0x31,0x08,0x01,0x00,0x00,
    0x00,0x08,0x00,0x00,0xFF,0x00,0x00,0x00,
    0x01,0x00,0x01,0x00,0x9B,0x83,0xD4,0xD5,
    0xDE,0x16,0x25,0x8E,0xE5,0x15,0xF2,0x18,
    0x9D,0x19,0x1C,0xF8,0xFE,0x91,0xA5,0x83,
    0xAE,0xA5,0xA8,0x95,0x3F,0x01,0xB2,0xC9,
    0x34,0xFB,0xC7,0x51,0x2D,0xAC,0xFF,0x38,
    0xE6,0xB6,0x7B,0x08,0x4A,0xDF,0x98,0xA3,
    0xFD,0x31,0x81,0xBF,0xAA,0xD1,0x62,0x58,
    0xC0,0x6C,0x8F,0x8E,0xCD,0x96,0xCE,0x6D,
    0x03,0x44,0x59,0x93,0xCE,0xEA,0x8D,0xF4,
    0xD4,0x6F,0x6F,0x34,0x5D,0x50,0xF1,0xAE,
    0x99,0x7F,0x1D,0x92,0x15,0xF3,0x6B,0xDB,
    0xF9,0x95,0x8B,0x3F,0x54,0xAD,0x37,0xB5,
    0x4F,0x0A,0x58,0x7B,0x48,0xA2,0x9F,0x9E,
    0xA3,0x16,0xC8,0xBD,0x37,0xDA,0x9A,0x37,
    0xE6,0x3F,0x10,0x1B,0xA8,0x4F,0xA3,0x14,
    0xFA,0xBE,0x12,0xFB,0xD7,0x19,0x4C,0xED,
    0xAD,0xA2,0x95,0x8F,0x39,0x8C,0xC4,0x69,
    0x0F,0x7D,0xB8,0x84,0x0A,0x99,0x5C,0x53,
    0x2F,0xDE,0xF2,0x1B,0xC5,0x1D,0x4C,0x43,
    0x3C,0x97,0xA7,0xBA,0x8F,0xC3,0x22,0x67,
    0x39,0xC2,0x62,0x74,0x3A,0x0C,0xB5,0x57,
    0x01,0x3A,0x67,0xC6,0xDE,0x0C,0x0B,0xF6,
    0x08,0x01,0x64,0xDB,0xBD,0x81,0xE4,0xDC,
    0x09,0x2E,0xD0,0xF1,0xD0,0xD6,0x1E,0xBA,
    0x38,0x36,0xF4,0x4A,0xDD,0xCA,0x39,0xEB,
    0x76,0xCF,0x95,0xDC,0x48,0x4C,0xF2,0x43,
    0x8C,0xD9,0x44,0x26,0x7A,0x9E,0xEB,0x99,
    0xA3,0xD8,0xFB,0x30,0xA8,0x14,0x42,0x82,
    0x8D,0xB4,0x31,0xB3,0x1A,0xD5,0x2B,0xF6,
    0x32,0xBC,0x62,0xC0,0xFE,0x81,0x20,0x49,
    0xE7,0xF7,0x58,0x2F,0x2D,0xA6,0x1B,0x41,
    0x62,0xC7,0xE0,0x32,0x02,0x5D,0x82,0xEC,
    0xA3,0xE4,0x6C,0x9B,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00
#endif
};

/* We dole out RAM from below the relocated boot loader.  We'll overwrite this
 * when we decrypt the boot loader */
ULONG pbNextAlloc = BLDR_RELOCATED_ORIGIN;

PVOID RSA32Alloc(ULONG u1)
{
    /* Round up to 32 bytes */
    u1 = (u1 + 31) & ~31;
    pbNextAlloc -= u1;
    return (PVOID)pbNextAlloc;
}
    
VOID RSA32Free(PVOID pv) {}

typedef struct _PRELDR_FUNCS {
    void (*pfnSHAInit)(A_SHA_CTX *);
    void (*pfnSHAUpdate)(A_SHA_CTX *, unsigned char *, unsigned int);
    void (*pfnSHAFinal)(A_SHA_CTX *, unsigned char [A_SHA_DIGEST_LEN]);
    BOOLEAN (*pfnVerifyDigest)(PUCHAR, PUCHAR, PUCHAR);
} PRELDR_FUNCS, *PPRELDR_FUNCS;

PRELDR_FUNCS PreloaderFuncTable = {
    A_SHAInit,
    A_SHAUpdate,
    A_SHAFinal,
    VerifyDigest
};

//
// Reverse ASN.1 Encodings of possible hash identifiers.
//
static PBYTE shaEncodings[] = {
            //      1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18
            "\x0f\x14\x04\x00\x05\x1a\x02\x03\x0e\x2b\x05\x06\x09\x30\x21\x30",
            "\x0d\x14\x04\x1a\x02\x03\x0e\x2b\x05\x06\x07\x30\x1f\x30",
            "\x00" };

BOOLEAN VerifyDigest(PUCHAR PubKey, PUCHAR EncryptedDigest, PUCHAR PlaintextDigest)
{
    UCHAR Encrypt[264];
    UCHAR Decrypt[264];
    BYTE      rgbTmpHash[A_SHA_DIGEST_LEN];
    DWORD     i;
    DWORD     cb;
    BYTE*     pbStart;
    DWORD     cbTmp;
    BSAFE_PUB_KEY *pKey = (LPBSAFE_PUB_KEY)PubKey;

    /* We need a 264-byte work area, so copy the digest into it and fill out
     * with zeroes */
    memcpy(Encrypt, EncryptedDigest, 256);
    memset(Encrypt+256, 0, 8);
    if(!BSafeEncPublic(pKey, Encrypt, Decrypt))
        return FALSE;

    //
    // reverse the hash to match the signature.
    //
    for (i = 0; i < A_SHA_DIGEST_LEN; i++) {
        rgbTmpHash[i] = PlaintextDigest[A_SHA_DIGEST_LEN - (i + 1)];
    }

    //
    // see if it matches.
    //
    if (memcmp(rgbTmpHash, Decrypt, A_SHA_DIGEST_LEN)) {
        return FALSE;
    }

    cb = A_SHA_DIGEST_LEN;

    //
    // check for any signature type identifiers
    //
    for (i = 0; 0 != *shaEncodings[i]; i += 1) {
        pbStart = (LPBYTE)shaEncodings[i];
        cbTmp = *pbStart++;
        if (0 == memcmp(&Decrypt[cb], pbStart, cbTmp)) {
            // adjust the end of the hash data.
            cb += cbTmp;
            break;
        }
    }

    //
    // check to make sure the rest of the PKCS #1 padding is correct
    //

    if ((0x00 != Decrypt[cb]) || (0x00 != Decrypt[pKey->datalen]) ||
         (0x1 != Decrypt[pKey->datalen - 1])) {
        return FALSE;
    }

    for (i = cb + 1; i < (DWORD)pKey->datalen - 1; i++) {
        if (0xff != Decrypt[i]) {
            return FALSE;
        }
    }

    return TRUE;
}

ULONG PreloaderStartup2(PUCHAR DecryptAddress)
{
    struct RC4_KEYSTRUCT RC4KeyStruct;
    PUCHAR EncBldr;
    ULONG EntryAddress;
    UCHAR Digest[XC_DIGEST_LEN];
    UCHAR PubKey[sizeof EncryptedPubKey];
    A_SHA_CTX SHAHash;
    PUCHAR SignTop;
    PUCHAR Signature;
    PUCHAR SignBase;
    PUCHAR InitTop;
    PUCHAR KernelBase;
    PULONG ROMRegions;
    const PUCHAR SBKey = (PUCHAR)(0LU - ROMDEC_N);
#ifdef MCP_XMODE3P
    int i;
    UCHAR EncKey[XC_DIGEST_LEN];
#endif

    /* The keyset we have is encrypted.  We decrypt it using the SB key */
    rc4_key(&RC4KeyStruct, 12, SBKey);
    memcpy(PubKey, EncryptedPubKey, sizeof EncryptedPubKey);
    rc4(&RC4KeyStruct, sizeof PubKey, PubKey);

    /* Find the pieces */
    SignTop = (PUCHAR)0 - ROM_DEC_SIZE;
    Signature = SignTop - 0x180;
    ROMRegions = (PULONG)(Signature + 0x100);

    /* We ask this ROM what its size is, but we only allow 256k - 1MB in
     * multiples of 256k */
    SignBase = (PUCHAR)ROMRegions[0];
    SignBase = (PUCHAR)(((ULONG)SignBase & 0xFFFC0000) | 0xFFF00000);
    InitTop = SignBase + ROMRegions[1];
    KernelBase = (PUCHAR)ROMRegions[2];

    /* Do some sanity checking on the ROM sizes so we don't try to hash all
     * 4 GB of address space */
    if(InitTop < SignBase || KernelBase < InitTop)
        return 0;
    
    /* SHA digest the ROM contents (top 128, then init table, then the rest)
     * and verify the signature */
    A_SHAInit(&SHAHash);
    A_SHAUpdate(&SHAHash, (PUCHAR)ROMRegions, SignTop - (PUCHAR)ROMRegions);
    A_SHAUpdate(&SHAHash, SignBase, InitTop - SignBase);
    A_SHAUpdate(&SHAHash, KernelBase, Signature - KernelBase);
    A_SHAFinal(&SHAHash, Digest);

    if(!VerifyDigest(PubKey, Signature, Digest))
        return 0;

#if 0
    PULONG pdwTimes = (PULONG)0x8F020;

    DbgInitialize();
    DbgPrint("Got to preldr!\n");

    DbgPrint("Before times: %08X %08X\n", pdwTimes[0], pdwTimes[1]);
    DbgPrint("After times: %08X %08X\n", pdwTimes[2], pdwTimes[3]);
#endif

    /* Now we decrypt the boot loader */

#ifdef MCP_XMODE3P
    /* Build the bldr key */
    A_SHAInit(&SHAHash);
    A_SHAUpdate(&SHAHash, SBKey, 16);
    A_SHAUpdate(&SHAHash, (PUCHAR)(0LU - ROM_DEC_SIZE - 16), 16);
    for(i = 0; i < 16; ++i)
        EncKey[i] = SBKey[i] ^ 0x5C;
    A_SHAUpdate(&SHAHash, EncKey, 16);
    A_SHAFinal(&SHAHash, EncKey);
    rc4_key(&RC4KeyStruct, sizeof EncKey, EncKey);
    memset(EncKey, 0, sizeof EncKey);
#else
    rc4_key(&RC4KeyStruct, sizeof BldrEncKey, BldrEncKey);
#endif

    EncBldr = (PUCHAR)0xFFFFFE00 - BLDR_BLOCK_SIZE;
    memcpy(DecryptAddress, EncBldr, BLDR_BLOCK_SIZE);
    rc4(&RC4KeyStruct, BLDR_BLOCK_SIZE, DecryptAddress);
    
    EntryAddress = ((PULONG)(DecryptAddress + BLDR_BLOCK_SIZE -
        PRELDR_BLOCK_SIZE))[-2];
    return (ULONG)DecryptAddress + EntryAddress;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\bootx\preldr32\i386\startup.asm ===
;++
;
;  Copyright (c) 2000-2001  Microsoft Corporation
;
;  Module Name:
;
;     startup.asm
;
;  Abstract:
;
;     This module implements the entry point for the 32-bit boot preloader code.
;
;  Environment:
;
;     32-bit protected mode.
;
;--

        .586p

        INCLUDE bldr.inc
        INCLUDE ks386.inc

        EXTERN  _PreloaderStartup2@4:NEAR
        EXTERN  _PreloaderFuncTable:DWORD
        EXTERN  _EncryptedPubKey:DWORD

_TEXT   SEGMENT PARA USE32 PUBLIC 'CODE'

        ASSUME  DS:_TEXT, ES:_TEXT, SS:_TEXT, FS:NOTHING, GS:NOTHING

;
; PreloaderStartup
;
; Entry point for the 32-bit boot preloader.  We don't do much work here; we
; inherit the cache policies that the romdec set up, and we set up just enough
; register and segment state for code to actually run.
;
; The entry point has to be preceded by a dword which indicates where the
; SHA function table lives.  This is so bldrbld can mark it somewhere where
; the bldr can find it.  The dword before that is the location of the public
; key.
;
;
        PUBLIC  _PreloaderStartup
        dd      _EncryptedPubKey
        dd      _PreloaderFuncTable
_PreloaderStartup PROC

        mov     eax, KGDT_R0_DATA
        mov     ds, eax
        mov     es, eax
        mov     ss, eax
        mov     esp, ROMDEC_STACK

        xor     eax, eax
        mov     fs, eax
        mov     gs, eax

;
; we should really set up the GDT here as well so we can unmap the SB ROM,
; but we'll put that off to the bldr for now
;

;
; Figure out where we're going to decrypt the boot loader to
;

        mov     esi, BLDR_RELOCATED_ORIGIN - ROMLDR_SIZE

;
; Call off to the loader code, which will return with the actual address
; to call off to, and then go to the final destination.  We'll load ebp with
; the decrypt address so it can find itself
;
        push    esi
        call    _PreloaderStartup2@4
        test    eax, eax
        jz      @F
        mov     ebp, esi
        jmp     eax

;
; If the load failed, we stop the clocks
; 
@@:     mov     edx, 0cf8h
        mov     eax, 08000036ch
        out     dx, eax
        add     edx, 4
        mov     eax, 01000000h
        out     dx, eax
        cli
        hlt

_PreloaderStartup ENDP

_TEXT   ENDS

        END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\bootx\preldr32\makefile.inc ===
$(BASEDIR)\private\ntos\obj\i386\xpreldr.bin: obj\i386\preldr32.exe
    bldrbld -p obj\i386\preldr32.exe $(BASEDIR)\private\ntos\obj\i386\xpreldr.bin
!IFDEF _NT386TREE
    binplace -R $(_NTTREE) $(BINPLACE_DBGFLAGS_NT) $(BINPLACE_FLAGS) $@
!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\bootx\romdec\decrypt.asm ===
;++
;
; Copyright (c) 1989-2000  Microsoft Corporation
;
; Portions Copyright (C) 1987 RSA Data Security, Inc. Created 1987.
;    This is an unpublished work protected as such under copyright law.
;    This work contains proprietary, confidential, and trade secret information
;    of RSA Data Security, Inc.  Use, disclosure, or reproduction without the
;    express written authorization of RSA Data Security, Inc., is prohibited.
;
; Module Name:
;
;    decrypt.asm
;
; Abstract:
;
;    The module decrypts the ROM loader
;
;    This module implements the RSA Data Security RC4 encryption algorithm.
;
; Author:
;
;    Yasser Asmi (yasmi)  7-Jun-2000
;
; Environment:
;
;    Real Address Mode
;
;--

; ==========================================================================

.586p

BOOT_CODE_ORIGIN  EQU    0FE00h          ; start of the code

ROMLDR_SIZE       EQU    6000h           ; size of the rom loader (must match BLDR_BLOCK_SIZE)

ENC_BUF_SIZE      EQU    ROMLDR_SIZE

ENC_INPUT_OFFSET  EQU    (BOOT_CODE_ORIGIN - ROMLDR_SIZE)

ENC_OUTPUT_OFFSET EQU    0

; ==========================================================================


; temp EQUs will be replaced by include files
BLDR_CODE         EQU    90000h
CR0_CD            EQU    040000000H
CR0_NW            EQU    020000000H


;
; For now, the boot loader will be loaded at 9000:0000.
;
BLDRTEXT SEGMENT USE16 AT (BLDR_CODE SHR 4)

        ORG     0h
Bldr16Startup   LABEL BYTE

BLDRTEXT ENDS



STACKSEG SEGMENT USE16 AT 8000h

        ORG     0FFFEh
StackStartup    LABEL BYTE

STACKSEG ENDS







_TEXT   SEGMENT  PARA USE16 PUBLIC 'CODE' 
        ASSUME  CS:_TEXT, DS:NOTHING, SS:NOTHING, ES:NOTHING


        PUBLIC Start

        ORG BOOT_CODE_ORIGIN

Start:
        cld

; 
; enable processor cache
;
        mov     eax, cr0
        and     eax, NOT (CR0_NW OR CR0_CD)
        mov     cr0, eax  


; INTEL 440BX

; initialize DRAM using SDROM Control Register  
;

        ; setup PCI cycle to 76h
        mov     eax, 080000074h
        mov     dx, 0CFEh

        ; NOP Command Enable
        mov     al, 20h 
        out     dx, al

        mov     cx, -1
@@:     loop    @B

         ; All Banks Precharge Enable
        mov     al, 40h  
        out     dx, al

    	mov	    ebx, ds:[0]

        mov     cx, 1000h
@@:     loop    @B
        	

        ; CBR Enable Command
        mov     al, 80h   
        out     dx, al

        mov     cx, 8
CBRLoop:
    	mov	    ebx, ds:[0]
        loop    CBRLoop


        ; Mode Register Set Enable Command 
        mov     al, 60h   
        out     dx, al

    	;mov     di, 01F0h    ;MKF_CL2_ADDRESS_FOR_MAA;CL2 address for Rows 3:0
	    ;mov     di, 0FEA8h   ; MKF_CL2_ADDRESS_FOR_MAB; No, get correct address
    	;mov     di, 01D0h    ; CL3

        mov     di, 0DE28h
	    mov     ebx, ds:[di]


        ; Normal SDRAM Operation
        mov     al, 0h   
        out     dx, al

        mov     ebx, ds:[0] 

; 
; initialize chipset registers
;
        xor     si, si
        xor     bx, bx

RAMInitLoop:
        mov     bl, cs:BYTE PTR RAMInitData[si]
        cmp     bl, 0
        je      RAMInitDone
            
        mov     eax, 080000000h
        mov     al, bl
        mov     dx, 0CF8h
        inc     si
        out     dx, eax
        
        mov     dx, 0CFCh
        mov     ax, bx
        mov     eax, cs:DWORD PTR RAMInitData[si]
        out     dx, eax
        add     si, 4
        jmp     RAMInitLoop
                
RAMInitDone:


;
; 
        mov     ax, SEG STACKSEG          
        mov     ss, ax                           
        mov     sp, 0FFFEh

        mov     ax, SEG STACKSEG
        mov     ds, ax

        mov     ax, SEG BLDRTEXT
        mov     es, ax

        call    RC4Encrypt
        ;call    JustCopy


        jmp     FAR PTR Bldr16Startup
        
      
; ==========================================================================

EncKey           DB      'abcdefgh'       ; the encryption key 


;
; ram initialization data pairs (register offset byte, value dword)
;
RAMInitData:

        DB  050h
        DD  0FF00800Ch
        DB  054h
        DD  009000000h
        DB  058h
        DD  000111003h
        DB  05Ch
        DD  011110000h
        DB  060h
        DD  004040404h
        DB  064h
        DD  004040404h
        DB  068h
        DD  000000000h
        DB  06Ch
        DD  000000000h
        DB  074h
        DD  000000000h
        DB  078h
        DD  0381C0100h

        ; end of RAM init data
        DB  00h
    
; ==========================================================================



JustCopy PROC NEAR 

        xor     bx, bx                          ; clear loop counter
.REPEAT
        mov	    di, WORD PTR ENC_INPUT_OFFSET   ; get input buffer[k]
        mov	    cl, BYTE PTR cs:[bx + di]  

        mov     di, WORD PTR ENC_OUTPUT_OFFSET  ; write the result to the output buffer   
        mov     BYTE PTR es:[bx + di], cl

        inc     bx                              ; advance loop counter

.UNTIL (bx >= ENC_BUF_SIZE)

        ret     0

JustCopy ENDP




;++
;
; RC4Encrypt - This function carries performs decryption using the RC4 algorithm
;
; Arguments - 
;
; Returns
;
;--

RC4_TABLESIZE     EQU     256             ; RC4 state table size



RC4Encrypt PROC NEAR 

        LOCAL   statetable[RC4_TABLESIZE]:BYTE
        LOCAL   i:BYTE 
        LOCAL   j:BYTE
        LOCAL   k:BYTE
;
; RC4 key expansion functionality (rc4_key) 
;



;!  for (ii=0;ii<RC4_TABLESIZE;ii++)
;!    keystruct.S[ii] = (unsigned char)ii;
;!
;! bx => ii

        xor     bx, bx
        lea     di, statetable               
.REPEAT
        mov     [di + bx], bl                ; write out loop counter to statetable[ii]
        inc     bx 
.UNTIL (bx > RC4_TABLESIZE)


;!  j = k = (unsigned char) 0;
;!  for (ii=0;ii<RC4_TABLESIZE;ii++)
;!  {
;!    j = (unsigned char)((j + keystruct.S[ii] + enckey[k]) % RC4_TABLESIZE);
;!
;!    t = keystruct.S[ii];
;!    keystruct.S[ii] = keystruct.S[j];
;!    keystruct.S[j] = t;
;!
;!    k = (unsigned char) ((k+1) % RC4_KEYSIZE);
;!  }
;! 
;! bx => ii


        xor     bx, bx                          ; clear loop counter, j, k
        mov     j, bl
        mov     k, bl

.REPEAT
        xor     ch, ch
        
        lea     di, statetable                  ; calculate expression result in ax 
        xor     ah, ah        
        mov     al, j                           ;   add j
        mov     cl, [di + bx]                   ;   add statetable[ii]
        add     ax, cx

        xor     si, si                          ;   put value of k in cx and add it to si
        mov     cl, k
        add     si, cx 
        
        inc     cx                              ;   calculate new value of k
        and     cx, 7                           ;      (k + 1) % RC4_KEYSIZE(=8)
        mov     k, cl

        mov	    cl, cs:BYTE PTR EncKey[si]        ;   add enckey[k] to expression result
        add     ax, cx

        mov     cx, RC4_TABLESIZE               ; divide ax by tablesize and put remainer byte in j
        cwd 
        idiv    cx
        mov     j, dl

        lea     di, statetable                  ; swap bytes at ii and j in the keytable
        xor     ch, ch       
        mov     cl, j 
        add     di, cx 
        mov     al, [di]                        ;   statetable[j] => al
        
        lea     si, statetable                  ;   swap al with statetable[ii] 
        xchg    al, BYTE PTR [si + bx]
        mov     [di], al                        ;   write al back


        inc     bx                              ; advance loop counter
.UNTIL (bx >= RC4_TABLESIZE)



; RC4 encryption functionality (rc4) 
;


;!  for (k = 0; k < buffersize; k++)
;!  {
;!    i = (unsigned char) ((i + 1) % RC4_TABLESIZE);
;!    j = (unsigned char) ((j + keystruct.S[i]) % RC4_TABLESIZE);
;!
;!    t = keystruct.S[i];
;!    keystruct.S[i] = keystruct.S[j];
;!    keystruct.S[j] = t;
;!
;!    outbuffer[k] = inbuffer[k] ^ keystruct.S[(keystruct.S[i]+keystruct.S[j]) % RC4_TABLESIZE];
;!   }
;!
;! bx => k


        xor     bx, bx                          ; clear loop counter, i, j
        mov     i, bl
        mov     j, bl
.REPEAT

        xor     ah, ah                          ; calculate new value of i
        mov     al, i                           ;   i + 1
        inc     ax
        
        mov     cx, RC4_TABLESIZE               ;   divide by table size and put remained byte in i
        cwd 
        idiv    cx
        mov     i, dl

        xor     ah, ah                          ; calculate new value of j in ax
        mov     al, j

        lea     di, statetable                  ;   add statetable[i]                  
        xor     ch, ch         
        mov     cl, i
        add     di, cx
        add     ax, [di]

        mov     cx, RC4_TABLESIZE               ;   divide by table size and put remained byte in j
        cwd 
        idiv    cx
        mov     j, dl

        lea     di, statetable                  ; swap bytes at i and j in the statetable
        xor     ch, ch                          
        mov     cl, j 
        add     di, cx 
        mov     al, [di]                        ;   statetable[j] => al
        
        lea     si, statetable
        mov     cl, i
        add     si, cx  
        
        xchg    al, BYTE PTR [si]               ;   swap al with statetable[i] 
        mov     [di], al                        ;   write al back


        xor     ax, ax                          ; calculate expression result in ax

        xor     ch, ch                          ;   add previously obtained statetable[i] and statetable[i]
        mov     cl, [di]  
        add     ax, cx
        mov     cl, [si]  
        add     ax, cx

        mov     cx, RC4_TABLESIZE               ;   divide by table size
        cwd
        idiv    cx


        lea     di, statetable                  ; get the statetable[modresult]
        add     di, dx
        mov     al, BYTE PTR [di]      


        mov	    di, WORD PTR ENC_INPUT_OFFSET   ; get input buffer[k]
        mov	    cl, cs:BYTE PTR [bx + di]      
        xor     cl, al                          ; xor the two values

        mov     di, WORD PTR ENC_OUTPUT_OFFSET  ; write the result to the output buffer   
        mov     es:BYTE PTR [bx + di], cl

        inc     bx                              ; advance loop counter

.UNTIL (bx >= ENC_BUF_SIZE)


        ret     0

RC4Encrypt ENDP




; ==========================================================================
;
; Pad until processor startup location.  The code will be loaded at 512 bytes
; below the uppermost memory location.  The processor starts execution at 16
; bytes below the uppermost memory location.  If the above code takes less than
; 512-16 bytes, then we want to put padding of appropriate number of bytes
; so that we can put a jmp to our start of code at the right place

PadLabel:

        PadSize = (200h - 10h - (PadLabel - Start))
        
        ;db      PadSize     DUP(90H)                ; 90h=NOP
        db      11h     DUP(90H)                ; 90h=NOP

ProcessorInit:

        jmp     Start                    ; jump to the start of code
        
        REPT 13                                 ; pad with nop to complete 512 bytes
            nop
        ENDM

; ==========================================================================


_TEXT   ENDS



        END      Start
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\bootx\preldr32\debug.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    debug.c

Abstract:

    This module implements routines to assist debugging the boot loader.

--*/

#include <ntos.h>
#include <stdio.h>
#include <dos.h>

VOID
DbgInitializeSuperIo(
    VOID
    );

#define COM_DAT     0x00
#define COM_IEN     0x01            // interrupt enable register
#define COM_LCR     0x03            // line control registers
#define COM_MCR     0x04            // modem control reg
#define COM_LSR     0x05            // line status register
#define COM_MSR     0x06            // modem status register
#define COM_DLL     0x00            // divisor latch least sig
#define COM_DLM     0x01            // divisor latch most sig

#define COM_BI      0x10
#define COM_FE      0x08
#define COM_PE      0x04
#define COM_OE      0x02

#define LC_DLAB     0x80            // divisor latch access bit

#define CLOCK_RATE  0x1C200         // USART clock rate

#define MC_DTRRTS   0x03            // Control bits to assert DTR and RTS
#define MS_DSRCTSCD 0xB0            // Status bits for DSR, CTS and CD
#define MS_CD       0x80

#define COM_OUTRDY  0x20
#define COM_DATRDY  0x01

BOOLEAN DbgInitialized = FALSE;
USHORT DbgBaseAddress = 0x3F8;
ULONG DbgBaudRate = 19200;

VOID
DbgInitialize(
    VOID
    )
{
    ULONG DivisorLatch;

    DbgInitializeSuperIo();

    DivisorLatch = CLOCK_RATE / DbgBaudRate;

    _outp(DbgBaseAddress + COM_LCR, 0x83);
    _outp(DbgBaseAddress + COM_DLM, (UCHAR)(DivisorLatch >> 8));
    _outp(DbgBaseAddress + COM_DLL, (UCHAR)(DivisorLatch));
    _outp(DbgBaseAddress + COM_LCR, 0x03);

    _outp(DbgBaseAddress + COM_MCR, MC_DTRRTS);
    _outp(DbgBaseAddress + COM_IEN, 0);

    DbgInitialized = TRUE;
}

VOID
DbgPrintCharacter(
    IN UCHAR Character
    )
{
    while (!(_inp(DbgBaseAddress + COM_LSR) & COM_OUTRDY));

    _outp(DbgBaseAddress + COM_DAT, Character);
}

ULONG
DbgPrint(
    PCHAR Format,
    ...
    )
{
    va_list arglist;
    UCHAR Buffer[512];
    int cb;
    int current;

    if (!DbgInitialized) {
        DbgInitialize();
    }

    va_start(arglist, Format);

    cb = _vsnprintf(Buffer, sizeof(Buffer), Format, arglist);

    va_end(arglist);

    for (current = 0; current < cb; current++) {
        DbgPrintCharacter(Buffer[current]);
    }
    DbgPrintCharacter('\r');
    DbgPrintCharacter('\n');

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\bootx\romdec\i386\enckey.inc ===
; 
; the encryption key 
;
EncKey:
        DB 057h,042h,029h,00Ch,030h,01Eh,0D3h,001h
        DB 0B3h,0E5h,05Dh,028h,050h,031h,0E1h,0CEh
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\bootx\romdec\dostest\dostest.asm ===
.586p

ENC_BUF_SIZE      EQU    6000h


ORIGIN            EQU    100h
                

; ==========================================================================

_TEXT   SEGMENT  PARA USE16 PUBLIC 'CODE'
        ASSUME  CS:_TEXT, DS:_TEXT, SS:_TEXT, ES:_TEXT
        ORG ORIGIN


        PUBLIC Start

Start:
        mov     sp, OFFSET StackBase

;
; open input file
;
        mov     ax, 3D00h
        lea     dx, InFileName
        int     21h
        mov     [FileHandle], ax

;
; read input file
;
        mov     ah, 3Fh
        mov     bx, [FileHandle]
        mov     cx, ENC_BUF_SIZE
        lea     dx, InBuffer
        int     21h

;
; close input file
;
        mov     ah, 3Eh        
        mov     bx, [FileHandle]
        int     21h


; ==========================================================================
;
; encrypt the buffer
;        
        mov     ax, ds
        mov     es, ax
          
        call    ZTimerOn
 
        call    RC4Encrypt

        call    ZTimerOff
        call	ZTimerReport


 
; ==========================================================================

;
; create output file
;
        mov     ah, 3Ch
        mov     cx, 0
        lea     dx, OutFileName
        int     21h

;
; open output file
;
        mov     ax, 3D01h
        lea     dx, OutFileName
        int     21h
        mov     [FileHandle], ax

;
; write output file
;
        mov     ah, 40h
        mov     bx, [FileHandle]
        mov     cx, ENC_BUF_SIZE
        lea     dx, OutBuffer
        int     21h
;
; close output file
;
        mov     ah, 3Eh        
        mov     bx, [FileHandle]
        int     21h


;
; DOS Exit 
;
Exit:
        mov     ah, 04Ch
        mov     al, 0
        int     21h


;
; encryption key
;
INCLUDE ENCKEY.INC



INCLUDE ..\I386\ENCRYPT.INC

INCLUDE ..\I386\ZENTIME.INC


_rc4KeyCtl  db 258 dup(?)


InFileName      db "in.bin", 0
FileHandle      dw -1

OutFileName     db "out.bin", 0
OutFileHandle   dw -1


        ALIGN   2

StackLimit      db 1024 dup (?)
StackBase       EQU $

ENC_INPUT_OFFSET  EQU    $
InBuffer        db  ENC_BUF_SIZE    DUP(0)
        
ENC_OUTPUT_OFFSET EQU    $
OutBuffer       db  ENC_BUF_SIZE    DUP(0)



_TEXT   ENDS
 
        END      Start
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\bootx\romdec\dostest\enckey.inc ===
; 
; the encryption key 
;
EncKey:
        DB 057h,042h,029h,00Ch,030h,01Eh,0D3h,001h
        DB 0B3h,0E5h,05Dh,028h,050h,031h,0E1h,0CEh
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\bootx\romdec\dostest\enc\enc.cpp ===
/*++

Copyright (c) 1989-2000  Microsoft Corporation

Module Name:

    rombld.cpp

Abstract:


--*/

#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <xcrypt.h>
#include <bldr.h>


static BYTE EncKey[] = 

    {
           0x57,0x42,0x29,0x0C,0x30,0x1E,0xD3,0x01,
           0xB3,0xE5,0x5D,0x28,0x50,0x31,0xE1,0xCE
    };




void
BuildFiles(
    PBYTE pData,
    DWORD dwDataSize
    )
{

    char szOrgFile[MAX_PATH];
    char szEncFile[MAX_PATH];
    HANDLE hWriteFile = INVALID_HANDLE_VALUE;
    DWORD dwBytes;
    PBYTE pEncBuffer = NULL;
    DWORD dwEncBufSize;
    DWORD dwFileNum = 0;
    PBYTE p = pData;
    DWORD dwLeft = dwDataSize;
    DWORD dwCopySize;

    //
    // allocate buffer for encryption
    //
    dwEncBufSize = BLDR_BLOCK_SIZE;
    pEncBuffer = (PBYTE)malloc(dwEncBufSize);


    printf("File size set to boot loader filesize (%d)\n", BLDR_BLOCK_SIZE);

    for (;;)
    {

        sprintf(szOrgFile, "%d.ORG", dwFileNum);
        sprintf(szEncFile, "%d.ENC", dwFileNum);
        dwFileNum++;

        printf("Creating %s and %s files\n", szOrgFile, szEncFile);


        dwCopySize = BLDR_BLOCK_SIZE;
        if (dwCopySize >= dwLeft)
        {
            dwCopySize = dwLeft;
            dwLeft = 0;
            memset(pEncBuffer, 0, dwEncBufSize);
        }
        else
        {
            dwLeft -= dwCopySize;
        }
        memcpy(pEncBuffer, p, dwCopySize);
        p += dwCopySize;


        hWriteFile = CreateFile(szOrgFile, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if (hWriteFile == INVALID_HANDLE_VALUE) {
            printf("Failed to open output file\n");
            goto Cleanup;
        }
        if (!WriteFile(hWriteFile, pEncBuffer, dwEncBufSize, &dwBytes, NULL))
        {
            printf("Failed to write to output file\n");
            goto Cleanup;
        }
        CloseHandle(hWriteFile);

        
        //
        // encrypt the buffer
        //
        XCSymmetricEncDec(pEncBuffer, dwEncBufSize, EncKey, 16);

        hWriteFile = CreateFile(szEncFile, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if (hWriteFile == INVALID_HANDLE_VALUE) {
            printf("Failed to open output file\n");
            goto Cleanup;
        }
        if (!WriteFile(hWriteFile, pEncBuffer, dwEncBufSize, &dwBytes, NULL))
        {
            printf("Failed to write to output file\n");
            goto Cleanup;
        }
        CloseHandle(hWriteFile);

        hWriteFile = INVALID_HANDLE_VALUE;

        if (dwLeft == 0)
        {
            break;
        }

    }
        

Cleanup:
    if (hWriteFile != INVALID_HANDLE_VALUE)
    {
        CloseHandle(hWriteFile);
    }

    if (pEncBuffer != NULL)
    {
        free(pEncBuffer);
    }
 
}





extern "C"
int
_cdecl
main(
	int,
	char** argv
	)
{
	HANDLE hFile;
	DWORD dwBytes;
    DWORD dwSize;
    PBYTE p;

    hFile = CreateFile(argv[1], GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hFile != INVALID_HANDLE_VALUE)
    {
        dwSize = GetFileSize(hFile, NULL);
        if (dwSize > 0)
        {
            p = (PBYTE)malloc(dwSize);
            if (p != NULL)
            {
                if (ReadFile(hFile, p, dwSize, &dwBytes, NULL))
                {
                    BuildFiles(p, dwSize);
                }
            }

            free(p);
        }
        CloseHandle(hFile);
    }

    return 0;
    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\bootx\romdec\i386\initcode.inc ===
; initialize DRAM using SDRAM Control Register  
;

        ; setup PCI cycle to 76h
        mov     eax, 080000074h
        mov     dx, 0CFEh

        ; NOP Command Enable
        mov     al, 20h 
        out     dx, al

        mov     cx, -1
@@:     loop    @B

         ; All Banks Precharge Enable
        mov     al, 40h  
        out     dx, al

    	mov	    ebx, ds:[0]

        mov     cx, 1000h
@@:     loop    @B
        	

        ; CBR Enable Command
        mov     al, 80h   
        out     dx, al

        mov     cx, 8
CBRLoop:
    	mov	    ebx, ds:[0]
        loop    CBRLoop


        ; Mode Register Set Enable Command 
        mov     al, 60h   
        out     dx, al

    	;mov     di, 01F0h    ;MKF_CL2_ADDRESS_FOR_MAA;CL2 address for Rows 3:0
	    ;mov     di, 0FEA8h   ; MKF_CL2_ADDRESS_FOR_MAB; No, get correct address
    	;mov     di, 01D0h    ; CL3

        mov     di, 0DE28h
	    mov     ebx, ds:[di]


        ; Normal SDRAM Operation
        mov     al, 0h   
        out     dx, al

        mov     ebx, ds:[0] 

; 
; initialize chipset registers
;
        xor     si, si
        xor     bx, bx

RAMInitLoop:
        mov     bl, cs:BYTE PTR RAMInitData[si]
        cmp     bl, 0
        je      RAMInitDone
            
        mov     eax, 080000000h
        mov     al, bl
        mov     dx, 0CF8h
        inc     si
        out     dx, eax
        
        mov     dx, 0CFCh
        mov     ax, bx
        mov     eax, cs:DWORD PTR RAMInitData[si]
        out     dx, eax
        add     si, 4
        jmp     RAMInitLoop
                
RAMInitDone:
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\bootx\romdec\i386\initdata.inc ===
;
; ram initialization data pairs (register offset byte, value dword)
;
RAMInitData:

        DB  050h
        DD  0FF00800Ch
        DB  054h
        DD  009000000h
        DB  058h
        DD  000111003h
        DB  05Ch
        DD  011110000h
        DB  060h
        DD  004040404h
        DB  064h
        DD  004040404h
        DB  068h
        DD  000000000h
        DB  06Ch
        DD  000000000h
        DB  074h
        DD  000000000h
        DB  078h
        DD  0381C0100h

        ; end of RAM init data
        DB  00h
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\bootx\romdec\makefile.inc ===
.SUFFIXES: .com .exe .obj .lst .c .asm .def .lnk .inc

{i386\}.asm{obj\i386\}.obj:
    $(386_ASSEMBLER_NAME) -Sa -Fl -c -omf -Fo$(MAKEDIR)\$@ -I. $(INCPATH1) $<

OBJ=obj\i386\romdec.obj

obj\i386\romdec.com: $(OBJ)

obj\i386\romdec.obj: i386\romdec.asm

obj\i386\romdec.com: $(OBJ)
    echo foo
    link16.exe @<<
/tiny /nod /noi +
$(OBJ)
obj\i386\romdec.com



<<
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\bootx\romdec\i386\encrypt.inc ===
;++
;
; Copyright (c) 1989-2000  Microsoft Corporation
;
; Portions Copyright (C) 1987 RSA Data Security, Inc. Created 1987.
;    This is an unpublished work protected as such under copyright law.
;    This work contains proprietary, confidential, and trade secret information
;    of RSA Data Security, Inc.  Use, disclosure, or reproduction without the
;    express written authorization of RSA Data Security, Inc., is prohibited.
;
; Abstract:
;
;    This module implements the RSA Data Security RC4 encryption algorithm.
;
;--


RC4_TABLESIZE     EQU     256             ; RC4 state table size



RC4Encrypt PROC NEAR

        LOCAL   statetable[RC4_TABLESIZE]:BYTE
        LOCAL   i:BYTE
        LOCAL   j:BYTE
        LOCAL   k:BYTE

;
; RC4 key expansion functionality (rc4_key)
;------------------------------------------

        lea     dx, statetable                  ; keep address of statetable in dx
        xor     ch, ch                          ; clear high byte of cx

;
; for (ii=0;ii<RC4_TABLESIZE;ii++)
;    keystruct.S[ii] = (unsigned char)ii;
; (bx => ii)
;
        xor     bx, bx
        mov     di, dx
.REPEAT
        mov     [di + bx], bl                   ; write out loop counter to statetable[ii]
        inc     bx
.UNTIL (bx > RC4_TABLESIZE)

;
; j = k = (unsigned char) 0;
; for (ii=0;ii<RC4_TABLESIZE;ii++) {
;    j = (unsigned char)((j + keystruct.S[ii] + enckey[k]) % RC4_TABLESIZE);
;
;    t = keystruct.S[ii];
;    keystruct.S[ii] = keystruct.S[j];
;    keystruct.S[j] = t;
;
;    k = (unsigned char) ((k+1) % RC4_KEYSIZE);
; }
; (bx => ii)
;
        xor     bx, bx                          ; clear loop counter, j, k
        xor     al, al                          ; keep j in al
        mov     k, bl

.REPEAT
        mov     di, dx                          ; calculate expression result in ax

        add     al, [di + bx]                   ; add statetable[ii]

        mov     cl, k
        mov     si, cx                          ; put value of k in si

        inc     cl                              ; calculate new value of k
        and     cl, 0Fh                         ; (k + 1) % RC4_KEYSIZE(=16)
        mov     k, cl

        add     al, cs:BYTE PTR EncKey[si]      ; add enckey[k] to expression result

        mov     di, dx                          ; swap bytes at ii and j in the keytable
        mov     cl, al                          ; word extend j to cx
        add     di, cx
        mov     cl, [di]                        ; statetable[j] => cl

        mov     si, dx                          ; swap ah with statetable[ii]
        mov     ah, [si + bx]
        mov     [si + bx], cl
        mov     [di], ah

        inc     bx                              ; advance loop counter
.UNTIL (bx >= RC4_TABLESIZE)


;
; RC4 encryption functionality (rc4)
;-----------------------------------

;
; for (k = 0; k < buffersize; k++) {
;    i = (unsigned char) ((i + 1) % RC4_TABLESIZE);
;    j = (unsigned char) ((j + keystruct.S[i]) % RC4_TABLESIZE);
;
;    t = keystruct.S[i];
;    keystruct.S[i] = keystruct.S[j];
;    keystruct.S[j] = t;
;
;    outbuffer[k] = inbuffer[k] ^ keystruct.S[(keystruct.S[i]+keystruct.S[j]) % RC4_TABLESIZE];
; }
; (bx => k)

        xor     bx, bx                          ; clear loop counter, i, j
        mov     i, bl
        mov     j, bl
.REPEAT

        inc     i                               ; calculate new value of i

        mov     di, dx                          ; add statetable[i]
        mov     cl, i
        add     di, cx
        mov     al, [di]
        add     j, al                           ; mod 256

        mov     di, dx                          ; swap bytes at i and j in the statetable
        mov     cl, j
        add     di, cx
        mov     al, [di]

        mov     si, dx
        mov     cl, i
        add     si, cx

        mov     ah, [si]                        ; swap al with statetable[i]
        mov     [si], al
        mov     [di], ah

        mov     cl, [di]                        ; add previously obtained statetable[i] and statetable[j] in ax
        mov     ax, cx
        add     al, [si]                        ; mod 256

        mov     di, dx                          ; get the statetable[modresult]
        add     di, ax

        mov     al, BYTE PTR [di]

IFDEF ENC_USE_FS_GS
        mov	    cl, fs:BYTE PTR [bx]
ELSE
        mov	    di, ENC_INPUT_OFFSET            ; get input buffer[k]
        mov	    cl, cs:BYTE PTR [bx + di]
ENDIF

        xor     cl, al                          ; xor the two values

IFDEF ENC_USE_FS_GS
        mov     gs:BYTE PTR [bx], cl
ELSE
        mov     di, ENC_OUTPUT_OFFSET           ; write the result to the output buffer
        mov     es:BYTE PTR [bx + di], cl
ENDIF

        inc     bx                              ; advance loop counter

.UNTIL (bx >= ENC_BUF_SIZE)

        ret

RC4Encrypt ENDP
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\bootx\romdec32\i386\chipset.inc ===
;++
;
; Copyright (c) Microsoft Corporation
;
; Module Name:
;
;    chipset.inc
;
; Abstract:
;
;    This file contains defines that control which chipset romdec and
;    init table are built for
;
;--

IFNDEF RETAILXM3
;
; We want MCP_XMODE2 unless retail XM3 is being built
;
MCP_XMODE2 = 1

ENDIF

;
; Define the following, when building for MCP Rev B01 in XMODE3
; Otherwise, this should undefined
;
;MCP_REV_B01 = 1


IFDEF SYS_QT
;
; If we are building for QT which implies C03 (or higher), the following 
; should be defined For C02, it should not be defined
;
MCP_REV_C03 = 1

;
; If we are building for QT, we need to automatically define DVT6
;
SYS_DVT6 = 1

ENDIF

;
; If we are building retail, set the local retail define
;
IFDEF RETAILXM3

SYS_RETAIL = 1

ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\bootx\romdec32\i386\enckey.inc ===
; 
; the encryption key (ROMDEC_KEYSIZE bytes)
;

EncKey:
        DB 057h,042h,029h,00Ch,030h,01Eh,0D3h,001h
        DB 0B3h,0E5h,05Dh,028h,050h,031h,0E1h,0CEh
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\bootx\romdec32\i386\cr11init.inc ===
;++
;
;  Copyright (c) Microsoft Corporation. All rights reserved
;
;  Module Name:
;
;    cr11init.inc
;
;  Abstract:
;
;    Crush11 initialization table
;
;    This module contains table of commands used by South Bridge to initialize
;    hardware and test memory during boot startup.  For definition of each
;    command, please see initcode.inc and command.inc
;--

        page    84,132

        .MODEL  compact
        .486p

DATA_TABLE_OFFSET  EQU 0FFFFFE00h

        INCLUDE command.inc

CODE    SEGMENT PARA PUBLIC 'CODE'
        ASSUME  DS:CODE, ES:NOTHING, SS:NOTHING
        ORG     0000H

IFDEF OLDNBDATA

;
; NB data for Crush 11 on the emulator
;

        dd      2B16D065h
        dd      (1 + (1 SHL 2))                 ; Intel
        dd      0
        dd      7 SHL 28
        dd      11 SHL 28
        dd      0
        dd      0
        dd      0
        dd      0
        dd      0FFFFFF7Fh
        dd      0FFFFFFFFh
        dd      (28-11) dup (0h)
        dd      0Fh
        dd      00000000h                       ; Intel
        dd      0
        dd      0
        dd      19234121h, 25268001h, 19234121h, 25268001h
        dd      19234121h, 25268001h, 19234121h, 25268001h
        dd      19234121h, 25268001h, 19234121h, 25268001h
        dd      19234121h, 25268001h, 19234121h, 25268001h
        dd      19234121h, 25268001h, 19234121h, 25268001h
        dd      19234121h, 25268001h, 19234121h, 25268001h
        dd      19234121h, 25268001h, 19234121h, 25268001h
        dd      19234121h, 25268001h, 19234121h, 25268001h

ELSE

IFDEF FIRST_TRY

;
; NB data for Crush 11 on the EVT boards
;

        db      065h, 0D0h, 016h, 02Bh          ; 2B16D065
        db      04Dh, 043h, 046h, 033h          ; 3346434D
        db      003h, 003h, 003h, 003h          ; 03030303
        db      00Eh, 015h, 01Ch, 01Ch          ; 1C1C150E
        db      003h, 015h, 000h, 000h          ; 00001503
        db      08Ah, 070h, 0E4h, 0A8h          ; A8E4708A
        db      030h, 002h, 0FDh, 045h          ; 45FD0230
        db      001h, 000h, 0E2h, 010h          ; 10E20001
        db      000h, 000h, 000h, 0F0h          ; F0000000
        dd      (55) dup (0FFFFFFFFh)           ; FFFFFFFF, ETC

ELSE

;
; NB data for Crush 11 on the EVT boards
;

        dd      2B16D065h
        dd      4444444Dh                       ; Intel
        dd      03030303h
        dd      15151515h
        dd      1503h
        dd      0A8E4708Ah
        dd      45FD0230h
        dd      10E20001h
        dd      0F0000000h
        dd      0FFFFFFFFh
        dd      0FFFFFFFFh
        dd      (28-11) dup (0h)                ; 4 DWORD follow to fill up to 128 bytes

;
; SB data for MCP1 on the EVT boards
;

        dd      0Fh
        dd      00000000h                       ; Intel
        dd      0                               ; pad for DWORD 30
        dd      0                               ; pad for DWORD 31 (32*4 = byte location 128)

;
; Force 256 byte alignment.
;

        db      (080h) dup (0)                  ; dup 0's into remaining 0x80/128 bytes

ENDIF   ; FIRST_TRY

ENDIF   ; OLDNBDATA


        ORG     0100h

data_table_test LABEL BYTE

;c00 nv_command_struct <COMMAND_TIMING_DELAY ,      5 ,                    DONT_CARE >
;c01 nv_command_struct <COMMAND_READ_MEM,           050000000h,            DONT_CARE >
;c02 nv_command_struct <COMMAND_WRITE_MEM,          050000000h,            55aa55aah >
;c04 nv_command_struct <COMMAND_PCI_CFG_WRITE,      80000004h,             7         >
;c05 nv_command_struct <COMMAND_PCI_CFG_READ,       80000004h,             DONT_CARE >
;c06 nv_command_struct <COMMAND_RMW_RESULT,         5,                     00007700h >
;c07 nv_command_struct <COMMAND_USE_RESULT_AS_DATA, COMMAND_PCI_CFG_WRITE, 80000004h >

;
; Crush11 init sequence.
;

nv_command_struct< COMMAND_PCI_CFG_WRITE, 8000017Ch, 170F17C0h >        ; CR_CMC_CFG0, 0x170f17c0 | CR_CMC_CFG0_PART_INTLV_32B = 0
nv_command_struct< COMMAND_PCI_CFG_WRITE, 80000164h, 00000001h >        ; CR_CMC_NVM, 0x1
nv_command_struct< COMMAND_PCI_CFG_WRITE, 80000240h, 00110401h >        ; CR_XL_DIMM_CFG_0, 0x1 | 0x10000 | 0x100000 | 0x0 | 0x400 = 0x110401
nv_command_struct< COMMAND_PCI_CFG_WRITE, 80000170h, 00000038h >        ; CR_CMC_MEMIO_CFG0, 0x38
nv_command_struct< COMMAND_PCI_CFG_WRITE, 80000190h, 22228807h >        ; CR_CMC_TIMING0, 0x22228807

nv_command_struct< COMMAND_PCI_CFG_WRITE, 80000194h, 22452250h >        ; CR_CMC_TIMING1, 0x22452250
nv_command_struct< COMMAND_PCI_CFG_WRITE, 80000198h, 036900FFh >        ; CR_CMC_TIMING2, 0x032100FF / 0x036900FF
nv_command_struct< COMMAND_PCI_CFG_WRITE, 80000178h, 0100021Fh >        ; CR_CMC_MEMIO_CFG2, 0x0100021F
nv_command_struct< COMMAND_PCI_CFG_WRITE, 8000019Ch, 00000020h >        ; CR_CMC_ARB_PREDIVIDER, 0x20
nv_command_struct< COMMAND_PCI_CFG_WRITE, 800001C0h, 00000013h >        ; CR_CMC_ARB, 0x13

nv_command_struct< COMMAND_PCI_CFG_WRITE, 800001CCh, 00028880h >        ; CR_CMC_ARB_TIMEOUT, 0x28880
nv_command_struct< COMMAND_PCI_CFG_WRITE, 800001D0h, 00004C40h >        ; CR_CMC_ARB_XFER_SZ, 0x4C40
nv_command_struct< COMMAND_PCI_CFG_WRITE, 800001D4h, 00002220h >        ; CR_CMC_ARB_XFER_REM, 0x2220
nv_command_struct< COMMAND_PCI_CFG_WRITE, 800001D8h, 0000000Ch >        ; CR_CMC_ARB_DIFF_BANK, 0xC
nv_command_struct< COMMAND_PCI_CFG_WRITE, 800001DCh, 0000000Fh >        ; CR_CMC_CLOSE_PAGE0, 0xF

nv_command_struct< COMMAND_PCI_CFG_WRITE, 800001E0h, 0000000Bh >        ; CR_CMC_CLOSE_PAGE1, 0xB
nv_command_struct< COMMAND_PCI_CFG_WRITE, 800001E4h, 000001CFh >        ; CR_CMC_CLOSE_PAGE2, 0x1CF
nv_command_struct< COMMAND_PCI_CFG_WRITE, 800001ECh, 00000F31h >        ; CR_CMC_AUTOCLOSE, 0xF31
nv_command_struct< COMMAND_PCI_CFG_WRITE, 800001F0h, 11001018h >        ; CR_CMC_WBC, 0x11001018
nv_command_struct< COMMAND_PCI_CFG_WRITE, 800001F8h, 00000401h >        ; CR_CMC_CPU_RRQ, 0x401

nv_command_struct< COMMAND_PCI_CFG_WRITE, 800001FCh, 02750031h >        ; CR_CMC_BYPASS, 0x2750031
nv_command_struct< COMMAND_PCI_CFG_WRITE, 80000168h, 00000001h >        ; CR_CMC_PIN, 0x1
nv_command_struct< COMMAND_PCI_CFG_WRITE, 8000016Ch, 00000001h >        ; CR_CMC_PAD, 0x1
nv_command_struct< COMMAND_PCI_CFG_WRITE, 800001E8h, 24924488h >        ; CR_CMC_CMDQ, 0x24924488
nv_command_struct< COMMAND_PCI_CFG_WRITE, 800001F4h, 00001008h >        ; CR_CMC_CMDQ_PRT, 0x1008

nv_command_struct< COMMAND_PCI_CFG_WRITE, 800001c8h, 00000001h >        ; CR_CMC_PRE, 0x1

;.repeat
;  in   eax,dx
;  not  eax
;.until eax & 1

nv_command_struct< COMMAND_PCI_CFG_WRITE, 800001a0h, 8000002Ah >        ; CR_CMC_MRS_DIMM0, 0x8000002A

;.repeat
;  in   eax,dx
;  not  eax
;.until eax & 80000000h

nv_command_struct< COMMAND_PCI_CFG_WRITE, 800001a4h, 80200001h >        ; CR_CMC_EMRS_DIMM0, 0x80200001

;.repeat
;  in   eax,dx
;  not  eax
;.until eax & 80000000h

nv_command_struct< COMMAND_PCI_CFG_WRITE, 800001c8h, 00000001h >        ; CR_CMC_PRE, 0x1

;.repeat
;  in   eax,dx
;  not  eax
;.until eax & 1

; do 8 memory refresh cycles:

nv_command_struct< COMMAND_PCI_CFG_WRITE, 800001c4h, 00000001h >        ; CR_CMC_REF, 0x1

;.repeat
;  in   eax,dx
;  not  eax
;.until eax & 1

nv_command_struct< COMMAND_PCI_CFG_WRITE, 80000168h, 00000001h >        ; CR_CMC_PIN, 0x1
nv_command_struct< COMMAND_PCI_CFG_WRITE, 80000160h, 80000000h >        ; CR_CMC_REFCTRL, 0x80000000
nv_command_struct< COMMAND_PCI_CFG_WRITE, 80000084h, 03000000h >        ; CR_CPU_MEMTOP, 0x3000000 = 64MB limit (as a RMW, reads as 0x3FFFFFF)

IFDEF MEMTEST

;
; Memory test
;

nv_command_struct< COMMAND_RMW_ACCUM, 0, 0 >                              ; clear accumulator

;
; dram0 chip
;

dram0_begin:

MemBase = 0
MemChip = 0

nv_command_struct< COMMAND_WRITE_MEM, (MemBase + 002555558h), 05A5A5A5Ah >
nv_command_struct< COMMAND_WRITE_MEM, (MemBase + 000555554h), 0FFFFFFFFh >
nv_command_struct< COMMAND_WRITE_MEM, (MemBase + 00055555Ch), 0FFFFFFFFh >

nv_command_struct< COMMAND_READ_MEM, (MemBase + 002555558h), DONT_CARE >        ; read mem in edi
nv_command_struct< COMMAND_COMPARE_RESULT_JNE, 05A5A5A5Ah, (dram0_err-$-4) >    ; if edi != val, jump

nv_command_struct< COMMAND_READ_MEM, (MemBase + 002555554h), DONT_CARE >        ; read mem in edi
nv_command_struct< COMMAND_COMPARE_RESULT_JNE, 0FFFFFFFFh, (dram0_err-$-4) >    ; if edi != val, jump

nv_command_struct< COMMAND_READ_MEM, (MemBase + 002555558h), DONT_CARE >        ; read mem in edi
nv_command_struct< COMMAND_COMPARE_RESULT_JNE, 0A5A5A5A5h, (dram0_2MB-$-4) >    ; if edi != val, jump

dram0_4mb:
nv_command_struct< COMMAND_RMW_ACCUM, 0FFFFFFFFh, (1 shl MemChip) >             ; indicate 4mb for this chip
nv_command_struct< COMMAND_JMP, DONT_CARE, (dram0_end-$-4) >

dram0_2mb:
nv_command_struct< COMMAND_JMP, DONT_CARE, (dram0_end-$-4) >

dram0_err:
nv_command_struct< COMMAND_RMW_ACCUM, 0FFFFFFFFh, (1 shl MemChip) shl 8 >       ; indicate error for this chip

dram0_end:

;
; dram1 chip
;

dram1_begin:

MemBase = 010h
MemChip = 1

nv_command_struct< COMMAND_WRITE_MEM, (MemBase + 002555558h), 05A5A5A5Ah >
nv_command_struct< COMMAND_WRITE_MEM, (MemBase + 000555554h), 0FFFFFFFFh >
nv_command_struct< COMMAND_WRITE_MEM, (MemBase + 00055555Ch), 0FFFFFFFFh >

nv_command_struct< COMMAND_READ_MEM, (MemBase + 002555558h), DONT_CARE >        ; read mem in edi
nv_command_struct< COMMAND_COMPARE_RESULT_JNE, 05A5A5A5Ah, (dram1_err-$-4) >    ; if edi != val, jump

nv_command_struct< COMMAND_READ_MEM, (MemBase + 002555554h), DONT_CARE>         ; read mem in edi
nv_command_struct< COMMAND_COMPARE_RESULT_JNE, 0FFFFFFFFh, (dram1_err-$-4) >    ; if edi != val, jump

nv_command_struct< COMMAND_READ_MEM, (MemBase + 002555558h), DONT_CARE >        ; read mem in edi
nv_command_struct< COMMAND_COMPARE_RESULT_JNE, 0A5A5A5A5h, (dram1_2MB-$-4) >    ; if edi != val, jump

dram1_4mb:
nv_command_struct< COMMAND_RMW_ACCUM, 0FFFFFFFFh, (1 shl MemChip) >             ; indicate 4mb for this chip
nv_command_struct< COMMAND_JMP, DONT_CARE, (dram1_end-$-4) >

dram1_2mb:
nv_command_struct< COMMAND_JMP, DONT_CARE, (dram1_end-$-4) >

dram1_err:
nv_command_struct< COMMAND_RMW_ACCUM, 0FFFFFFFFh, (1 shl MemChip) shl 8 >       ; indicate error for this chip

dram1_end:

;
; dram2 chip
;

dram2_begin:

MemBase = 020h
MemChip = 2

nv_command_struct< COMMAND_WRITE_MEM, (MemBase + 002555558h), 05A5A5A5Ah >
nv_command_struct< COMMAND_WRITE_MEM, (MemBase + 000555554h), 0FFFFFFFFh >
nv_command_struct< COMMAND_WRITE_MEM, (MemBase + 00055555Ch), 0FFFFFFFFh >

nv_command_struct< COMMAND_READ_MEM, (MemBase + 002555558h), DONT_CARE >        ; read mem in edi
nv_command_struct< COMMAND_COMPARE_RESULT_JNE, 05A5A5A5Ah, (dram2_err-$-4) >    ; if edi != val, jump

nv_command_struct< COMMAND_READ_MEM, (MemBase + 002555554h), DONT_CARE >        ; read mem in edi
nv_command_struct< COMMAND_COMPARE_RESULT_JNE, 0FFFFFFFFh, (dram2_err-$-4) >    ; if edi != val, jump

nv_command_struct< COMMAND_READ_MEM, (MemBase + 002555558h), DONT_CARE >        ; read mem in edi
nv_command_struct< COMMAND_COMPARE_RESULT_JNE, 0A5A5A5A5h, (dram2_2MB-$-4)>     ; if edi != val, jump

dram2_4mb:
nv_command_struct< COMMAND_RMW_ACCUM, 0FFFFFFFFh, (1 shl MemChip) >             ; indicate 4mb for this chip
nv_command_struct< COMMAND_JMP, DONT_CARE, (dram2_end-$-4) >

dram2_2mb:
nv_command_struct< COMMAND_JMP, DONT_CARE, (dram2_end-$-4) >

dram2_err:
nv_command_struct< COMMAND_RMW_ACCUM, 0FFFFFFFFh, (1 shl MemChip) shl 8 >       ; indicate error for this chip

dram2_end:

;
; dram3 chip
;

dram3_begin:

MemBase = 030h
MemChip = 3

nv_command_struct< COMMAND_WRITE_MEM, (MemBase + 002555558h), 05A5A5A5Ah >
nv_command_struct< COMMAND_WRITE_MEM, (MemBase + 000555554h), 0FFFFFFFFh >
nv_command_struct< COMMAND_WRITE_MEM, (MemBase + 00055555Ch), 0FFFFFFFFh >

nv_command_struct< COMMAND_READ_MEM, (MemBase + 002555558h), DONT_CARE >        ; read mem in edi
nv_command_struct< COMMAND_COMPARE_RESULT_JNE, 05A5A5A5Ah, (dram3_err-$-4) >    ; if edi != val, jump

nv_command_struct< COMMAND_READ_MEM, (MemBase + 002555554h), DONT_CARE >        ; read mem in edi
nv_command_struct< COMMAND_COMPARE_RESULT_JNE, 0FFFFFFFFh, (dram3_err-$-4) >    ; if edi != val, jump

nv_command_struct< COMMAND_READ_MEM, (MemBase + 002555558h), DONT_CARE >        ; read mem in edi
nv_command_struct< COMMAND_COMPARE_RESULT_JNE, 0A5A5A5A5h, (dram3_2MB-$-4) >    ; if edi != val, jump

dram3_4mb:
nv_command_struct< COMMAND_RMW_ACCUM, 0FFFFFFFFh, (1 shl MemChip) >             ; indicate 4mb for this chip
nv_command_struct< COMMAND_JMP, DONT_CARE, (dram3_end-$-4) >

dram3_2mb:
nv_command_struct< COMMAND_JMP, DONT_CARE, (dram3_end-$-4) >

dram3_err:
nv_command_struct< COMMAND_RMW_ACCUM, 0FFFFFFFFh, (1 shl MemChip) shl 8 >       ; indicate error for this chip

dram3_end:

;
; dram4 chip
;

dram4_begin:

MemBase = 04000000h
MemChip = 4

nv_command_struct< COMMAND_WRITE_MEM, (MemBase + 002555558h), 05A5A5A5Ah >
nv_command_struct< COMMAND_WRITE_MEM, (MemBase + 000555554h), 0FFFFFFFFh >
nv_command_struct< COMMAND_WRITE_MEM, (MemBase + 00055555Ch), 0FFFFFFFFh >

nv_command_struct< COMMAND_READ_MEM, (MemBase + 002555558h), DONT_CARE >        ; read mem in edi
nv_command_struct< COMMAND_COMPARE_RESULT_JNE, 05A5A5A5Ah, (dram4_err-$-4) >    ; if edi != val, jump

nv_command_struct< COMMAND_READ_MEM, (MemBase + 002555554h), DONT_CARE >        ; read mem in edi
nv_command_struct< COMMAND_COMPARE_RESULT_JNE, 0FFFFFFFFh, (dram4_err-$-4) >    ; if edi != val, jump

nv_command_struct< COMMAND_READ_MEM, (MemBase + 002555558h), DONT_CARE >        ; read mem in edi
nv_command_struct< COMMAND_COMPARE_RESULT_JNE, 0A5A5A5A5h, (dram4_2MB-$-4) >    ; if edi != val, jump

dram4_4mb:
nv_command_struct< COMMAND_RMW_ACCUM, 0FFFFFFFFh, (1 shl MemChip) >             ; indicate 4mb for this chip
nv_command_struct< COMMAND_JMP, DONT_CARE, (dram4_end-$-4) >

dram4_2mb:
nv_command_struct< COMMAND_JMP, DONT_CARE, (dram4_end-$-4) >

dram4_err:
nv_command_struct< COMMAND_RMW_ACCUM, 0FFFFFFFFh, (1 shl MemChip) shl 8 >       ; indicate error for this chip

dram4_end:

;
; dram5 chip
;

dram5_begin:

MemBase = 04000010h
MemChip = 5

nv_command_struct< COMMAND_WRITE_MEM, (MemBase + 002555558h), 05A5A5A5Ah >
nv_command_struct< COMMAND_WRITE_MEM, (MemBase + 000555554h), 0FFFFFFFFh >
nv_command_struct< COMMAND_WRITE_MEM, (MemBase + 00055555Ch), 0FFFFFFFFh >

nv_command_struct< COMMAND_READ_MEM, (MemBase + 002555558h), DONT_CARE >        ; read mem in edi
nv_command_struct< COMMAND_COMPARE_RESULT_JNE, 05A5A5A5Ah, (dram5_err-$-4) >    ; if edi != val, jump

nv_command_struct< COMMAND_READ_MEM, (MemBase + 002555554h), DONT_CARE >        ; read mem in edi
nv_command_struct< COMMAND_COMPARE_RESULT_JNE, 0FFFFFFFFh, (dram5_err-$-4) >    ; if edi != val, jump

nv_command_struct< COMMAND_READ_MEM, (MemBase + 002555558h), DONT_CARE >        ; read mem in edi
nv_command_struct< COMMAND_COMPARE_RESULT_JNE, 0A5A5A5A5h, (dram5_2MB-$-4) >    ; if edi != val, jump

dram5_4mb:
nv_command_struct< COMMAND_RMW_ACCUM, 0FFFFFFFFh, (1 shl MemChip) >             ; indicate 4mb for this chip
nv_command_struct< COMMAND_JMP, DONT_CARE, (dram5_end-$-4) >

dram5_2mb:
nv_command_struct< COMMAND_JMP, DONT_CARE, (dram5_end-$-4) >

dram5_err:
nv_command_struct< COMMAND_RMW_ACCUM, 0FFFFFFFFh, (1 shl MemChip) shl 8 >       ; indicate error for this chip

dram5_end:

;
; dram6 chip
;

dram6_begin:

MemBase = 04000020h
MemChip = 6

nv_command_struct< COMMAND_WRITE_MEM, (MemBase + 002555558h), 05A5A5A5Ah >
nv_command_struct< COMMAND_WRITE_MEM, (MemBase + 000555554h), 0FFFFFFFFh >
nv_command_struct< COMMAND_WRITE_MEM, (MemBase + 00055555Ch), 0FFFFFFFFh >

nv_command_struct< COMMAND_READ_MEM, (MemBase + 002555558h), DONT_CARE >        ; read mem in edi
nv_command_struct< COMMAND_COMPARE_RESULT_JNE, 05A5A5A5Ah, (dram6_err-$-4) >    ; if edi != val, jump

nv_command_struct< COMMAND_READ_MEM, (MemBase + 002555554h), DONT_CARE >        ; read mem in edi
nv_command_struct< COMMAND_COMPARE_RESULT_JNE, 0FFFFFFFFh, (dram6_err-$-4) >    ; if edi != val, jump

nv_command_struct< COMMAND_READ_MEM, (MemBase + 002555558h), DONT_CARE >        ; read mem in edi
nv_command_struct< COMMAND_COMPARE_RESULT_JNE, 0A5A5A5A5h, (dram6_2MB-$-4) >    ; if edi != val, jump

dram6_4mb:
nv_command_struct< COMMAND_RMW_ACCUM, 0FFFFFFFFh, (1 shl MemChip) >             ; indicate 4mb for this chip
nv_command_struct< COMMAND_JMP, DONT_CARE, (dram6_end-$-4) >

dram6_2mb:
nv_command_struct< COMMAND_JMP, DONT_CARE, (dram6_end-$-4) >

dram6_err:
nv_command_struct< COMMAND_RMW_ACCUM, 0FFFFFFFFh, (1 shl MemChip) shl 8 >       ; indicate error for this chip

dram6_end:

;
; dram7 chip
;

dram7_begin:

MemBase = 04000030h
MemChip = 7

nv_command_struct< COMMAND_WRITE_MEM, (MemBase + 002555558h), 05A5A5A5Ah >
nv_command_struct< COMMAND_WRITE_MEM, (MemBase + 000555554h), 0FFFFFFFFh >
nv_command_struct< COMMAND_WRITE_MEM, (MemBase + 00055555Ch), 0FFFFFFFFh >

nv_command_struct< COMMAND_READ_MEM, (MemBase + 002555558h), DONT_CARE >        ; read mem in edi
nv_command_struct< COMMAND_COMPARE_RESULT_JNE, 05A5A5A5Ah, (dram7_err-$-4) >    ; if edi != val, jump

nv_command_struct< COMMAND_READ_MEM, (MemBase + 002555554h), DONT_CARE >        ; read mem in edi
nv_command_struct< COMMAND_COMPARE_RESULT_JNE, 0FFFFFFFFh, (dram7_err-$-4) >    ; if edi != val, jump

nv_command_struct< COMMAND_READ_MEM, (MemBase + 002555558h), DONT_CARE >        ; read mem in edi
nv_command_struct< COMMAND_COMPARE_RESULT_JNE, 0A5A5A5A5h, (dram7_2MB-$-4) >    ; if edi != val, jump

dram7_4mb:
nv_command_struct< COMMAND_RMW_ACCUM, 0FFFFFFFFh, (1 shl MemChip) >             ; indicate 4mb for this chip
nv_command_struct< COMMAND_JMP, DONT_CARE, (dram7_end-$-4) >

dram7_2mb:
nv_command_struct< COMMAND_JMP, DONT_CARE, (dram7_end-$-4) >

dram7_err:
nv_command_struct< COMMAND_RMW_ACCUM, 0FFFFFFFFh, (1 shl MemChip) shl 8 >       ; indicate error for this chip

dram7_end:

ENDIF

;
; End of table
;

nv_command_struct < COMMAND_QUIT, DONT_CARE, DONT_CARE >

        ORG     07FFh           ; 0FFFFh

        db      00h

CODE    ENDS
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\bootx\romdec32\i386\command.inc ===
IFDEF MCP_XMODE2

;
; Opcodes for devkits (XMODE2)

COMMAND_RESERVED             EQU 0E7h
COMMAND_READ_MEM             EQU 09Ah
COMMAND_WRITE_MEM            EQU 05Bh
COMMAND_PCI_CFG_WRITE        EQU 0F9h
COMMAND_PCI_CFG_READ         EQU 0F5h
COMMAND_RMW_RESULT           EQU 0EDh
COMMAND_USE_RESULT_AS_DATA   EQU 068h
COMMAND_COMPARE_RESULT_JNE   EQU 004h
COMMAND_JMP                  EQU 025h
COMMAND_RMW_ACCUM            EQU 06Ch
COMMAND_OUT_BYTE             EQU 03Ch
COMMAND_IN_BYTE              EQU 0C8h
COMMAND_QUIT                 EQU 0BFh

ELSE

;
; Opcodes for internal ROM (XMODE3)
;

COMMAND_RESERVED             EQU 1h
COMMAND_READ_MEM             EQU 2h
COMMAND_WRITE_MEM            EQU 3h
COMMAND_PCI_CFG_WRITE        EQU 4h
COMMAND_PCI_CFG_READ         EQU 5h
COMMAND_RMW_RESULT           EQU 6h
COMMAND_USE_RESULT_AS_DATA   EQU 7h
COMMAND_COMPARE_RESULT_JNE   EQU 8h
COMMAND_JMP                  EQU 9h
COMMAND_RMW_ACCUM            EQU 10h
COMMAND_OUT_BYTE             EQU 11h
COMMAND_IN_BYTE              EQU 12h
COMMAND_QUIT                 EQU 0EEh

COMMAND_UNUSED1              EQU 0F5h
COMMAND_UNUSED2              EQU 080h

ENDIF


DONT_CARE                    EQU 0

nv_command_struct struct
        nv_command db 0
        nv_address dd 0
        nv_data    dd 0
nv_command_struct ends
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\bootx\romdec\i386\romdec.asm ===
;++
;
; Copyright (c) 1989-2000  Microsoft Corporation
;
; Module Name:
;
;    romdec.asm
;
; Abstract:
;
;    The module decrypts the ROM loader
;
; Environment:
;
;    Real Address Mode
;
;--

; ==========================================================================

        .586p

        INCLUDE bldr.inc


ENC_BUF_SIZE      EQU    ROMLDR_SIZE

ENC_INPUT_OFFSET  EQU    (BOOT_CODE_ORIGIN - ROMLDR_SIZE)

ENC_OUTPUT_OFFSET EQU    0

CR0_CD            EQU    040000000H

CR0_NW            EQU    020000000H

; ==========================================================================
;
; segment where bootloader code will be decrypted
;
BLDRTEXT SEGMENT USE16 AT (BLDR_CODE SHR 4)

        ORG     0h
Bldr16Startup   LABEL BYTE

BLDRTEXT ENDS


; ==========================================================================
;
; stack segment
;
STACKSEG SEGMENT USE16 AT 8000h

        ORG     0FFFEh
StackStartup    LABEL BYTE

STACKSEG ENDS



; ==========================================================================
;
; main segment
;
_TEXT   SEGMENT  PARA USE16 PUBLIC 'CODE' 
        ASSUME  CS:_TEXT, DS:NOTHING, SS:NOTHING, ES:NOTHING


        PUBLIC  Start

        ORG     BOOT_CODE_ORIGIN

Start:
;
; reset vector transfers the control here
;

        cld
; 
; enable processor cache
;
        mov     eax, cr0
        and     eax, NOT (CR0_NW OR CR0_CD)
        mov     cr0, eax  

;
; initialize chipset and DRAM
;
        INCLUDE INITCODE.INC


;
; setup segments
; 
        mov     ax, SEG STACKSEG          
        mov     ss, ax                           
        mov     sp, 0FFFEh

        mov     ax, SEG STACKSEG
        mov     ds, ax

        mov     ax, SEG BLDRTEXT
        mov     es, ax

;
; decrypt the boot loader
;
        call    RC4Encrypt


;
; check to see if the encryption was successful.  RC4 algorithm does not provide
; success information.  Therefore, we check for a known signature in the
; decrypted boot loader
;

        mov     eax, es:DWORD PTR [ROMLDR_SIZE - ROMLDR_BOOTPARAMSIZE]   
        cmp     eax, ROMLDR_SIGNATURE
        jz      JumpToBootLoader

Fail:
;
; ROM is not valid.  Shutdown by copying the shutdown sequence to RAM and executing it.  We
; cannot execute in SB ROM because after we turn of SB ROM, the CPU will continue execution
; in the main ROM.  
;
        
        mov     si, OFFSET TurnOffSbRom
        xor     di, di
        mov     cx, 22
ShutdownCopyLoop:
        mov     al, cs:BYTE PTR [si]                           
        mov     es:BYTE PTR [di], al
        inc     si
        inc     di
        loop    ShutdownCopyLoop

JumpToBootLoader:
;
; jump to the boot loader startup or in case of failure the shutdown sequence
;
        mov     si, OFFSET CmdLine
        jmp     FAR PTR Bldr16Startup
        
      
; ==========================================================================

;
; command line options to boot loader 
;
CmdLine     DB      0

;
; sequence of instructions to turn off SB ROM and halt
;
TurnOffSBRom:
          
;        mov     eax, 80000880h
;        mov     dx, 0CF8h
;        out     dx, eax
;        mov     dx, 0CFCh
;        mov     al, 2
;        out     dx, al
        hlt

;
; encryption key
;
        INCLUDE ENCKEY.INC

;
; chipset initialization related data
;
        INCLUDE INITDATA.INC


;
; encryption function
;
        INCLUDE ENCRYPT.INC

; ==========================================================================


;
; pad until processor startup location.  The code will be loaded at 512 bytes
; below the uppermost memory location.  The processor starts execution at 16
; bytes below the uppermost memory location.  If the above code takes less than
; 512-16 bytes, then we want to put padding of appropriate number of bytes
; so that we can put a jmp to our start of code at the right place

PadLabel:

;
; NOTE: following constant sets the number of bytes to be used for padding.  If
; the above code changes then the pad size must be adjusted.  We cannot use 
; this directly because of one-pass assembly.  However, if the number is not
; correct the following .ERRNZ condition will fail with A2045.  If you see the
; error during compilation, look at the .lst file and change PadSize value to
; the value reported for RequiredPadSize
;
        PadSize = 44h
        RequiredPadSize = (200h - 10h - (PadLabel - Start))

.ERRNZ (200h - 10h - (PadLabel - Start)) - PadSize


        db      PadSize     DUP(90H)                ; 90h=NOP

;
; this is where the processor will start executing code
;
ProcessorInit:
        jmp     Start                    ; jump to the start of code


;
; pad with nop to complete 512 bytes
;
        REPT 13
            nop
        ENDM

; ==========================================================================

_TEXT   ENDS

        END      Start
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\bootx\romdec\i386\zentime.inc ===
;
; *** Listing 3-1 ***
;
; The precision Zen timer (PZTIMER.ASM)
;
; Uses the 8253 timer to time the performance of code that takes
; less than about 54 milliseconds to execute, with a resolution
; of better than 10 microseconds.
;
; By Michael Abrash 
;
; Externally callable routines:
;
;  ZTimerOn: Starts the Zen timer, with interrupts disabled.
;
;  ZTimerOff: Stops the Zen timer, saves the timer count,
;	times the overhead code, and restores interrupts to the
;	state they were in when ZTimerOn was called.
;
;  ZTimerReport: Prints the net time that passed between starting
;	and stopping the timer.
;
; Note: If longer than about 54 ms passes between ZTimerOn and
;	ZTimerOff calls, the timer turns over and the count is
;	inaccurate. When this happens, an error message is displayed
;	instead of a count. The long-period Zen timer should be used
;	in such cases.
;
; Note: Interrupts *MUST* be left off between calls to ZTimerOn
;	and ZTimerOff for accurate timing and for detection of
;	timer overflow.
;
; Note: These routines can introduce slight inaccuracies into the
;	system clock count for each code section timed even if
;	timer 0 doesn't overflow. If timer 0 does overflow, the
;	system clock can become slow by virtually any amount of
;	time, since the system clock can't advance while the
;	precison timer is timing. Consequently, it's a good idea
;	to reboot at the end of each timing session. (The
;	battery-backed clock, if any, is not affected by the Zen
;	timer.)
;
; All registers, and all flags except the interrupt flag, are
; preserved by all routines. Interrupts are enabled and then disabled
; by ZTimerOn, and are restored by ZTimerOff to the state they were
; in when ZTimerOn was called.
;


;
; Base address of the 8253 timer chip.
;
BASE_8253		equ	40h
;
; The address of the timer 0 count registers in the 8253.
;
TIMER_0_8253		equ	BASE_8253 + 0
;
; The address of the mode register in the 8253.
;
MODE_8253		equ	BASE_8253 + 3
;
; The address of Operation Command Word 3 in the 8259 Programmable
; Interrupt Controller (PIC) (write only, and writable only when
; bit 4 of the byte written to this address is 0 and bit 3 is 1).
;
OCW3			equ	20h
;
; The address of the Interrupt Request register in the 8259 PIC
; (read only, and readable only when bit 1 of OCW3 = 1 and bit 0
; of OCW3 = 0).
;
IRR			equ	20h
;
; Macro to emulate a POPF instruction in order to fix the bug in some
; 80286 chips which allows interrupts to occur during a POPF even when
; interrupts remain disabled.
;
MPOPF macro 
	local	p1, p2
	jmp short p2
p1:	iret			;jump to pushed address & pop flags
p2:	push	cs		;construct far return address to
	call	p1		; the next instruction
	endm

;
; Macro to delay briefly to ensure that enough time has elapsed
; between successive I/O accesses so that the device being accessed
; can respond to both accesses even on a very fast PC.
;
DELAY	macro
	jmp	$+2
	jmp	$+2
	jmp	$+2
	endm

OriginalFlags		db	?	;storage for upper byte of
					; FLAGS register when
					; ZTimerOn called
TimedCount		dw	?	;timer 0 count when the timer
					; is stopped
ReferenceCount		dw	?	;number of counts required to
					; execute timer overhead code
OverflowFlag		db	?	;used to indicate whether the
					; timer overflowed during the
					; timing interval
;
; String printed to report results.
;
OutputStr	label	byte
		db	0dh, 0ah, 'Timed count: ', 5 dup (?)
ASCIICountEnd	label	byte
		db	' microseconds', 0dh, 0ah
		db	'$'
;
; String printed to report timer overflow.
;
OverflowStr	label	byte
	db	0dh, 0ah
	db	'****************************************************'
	db	0dh, 0ah
	db	'* The timer overflowed, so the interval timed was  *'
	db	0dh, 0ah
	db	'* too long for the precision timer to measure.     *'
	db	0dh, 0ah
	db	'* Please perform the timing test again with the    *'
	db	0dh, 0ah
	db	'* long-period timer.                               *'
	db	0dh, 0ah
	db	'****************************************************'
	db	0dh, 0ah
	db	'$'

;********************************************************************
;* Routine called to start timing.				    *
;********************************************************************

ZTimerOn	proc	near

;
; Save the context of the program being timed.
;
	push	ax
	pushf
	pop	ax			;get flags so we can keep
					; interrupts off when leaving
					; this routine
	mov	cs:[OriginalFlags],ah	;remember the state of the
					; Interrupt flag
	and	ah,0fdh 		;set pushed interrupt flag
					; to 0
	push	ax
;
; Turn on interrupts, so the timer interrupt can occur if it's
; pending.
;
	sti
;
; Set timer 0 of the 8253 to mode 2 (divide-by-N), to cause
; linear counting rather than count-by-two counting. Also
; leaves the 8253 waiting for the initial timer 0 count to
; be loaded.
;
	mov	al,00110100b		;mode 2
	out	MODE_8253,al
;
; Set the timer count to 0, so we know we won't get another
; timer interrupt right away.
; Note: this introduces an inaccuracy of up to 54 ms in the system
; clock count each time it is executed.
;
	DELAY
	sub	al,al
	out	TIMER_0_8253,al		;lsb
	DELAY
	out	TIMER_0_8253,al		;msb
;
; Wait before clearing interrupts to allow the interrupt generated
; when switching from mode 3 to mode 2 to be recognized. The delay
; must be at least 210 ns long to allow time for that interrupt to
; occur. Here, 10 jumps are used for the delay to ensure that the
; delay time will be more than long enough even on a very fast PC.
;
	rept 10
	jmp	$+2
	endm
;
; Disable interrupts to get an accurate count.
;
	cli
;
; Set the timer count to 0 again to start the timing interval.
;
	mov	al,00110100b		;set up to load initial
	out	MODE_8253,al		; timer count
	DELAY
	sub	al,al
	out	TIMER_0_8253,al		;load count lsb
	DELAY
	out	TIMER_0_8253,al		;load count msb
;
; Restore the context and return.
;
	MPOPF				;keeps interrupts off
	pop	ax
	ret

ZTimerOn	endp

;********************************************************************
;* Routine called to stop timing and get count.			    *
;********************************************************************

ZTimerOff proc	near

;
; Save the context of the program being timed.
;
	push	ax
	push	cx
	pushf
;
; Latch the count.
;
	mov	al,00000000b		;latch timer 0
	out	MODE_8253,al
;
; See if the timer has overflowed by checking the 8259 for a pending
; timer interrupt.
;
	mov	al,00001010b		;OCW3, set up to read
	out	OCW3,al			; Interrupt Request register
	DELAY
	in	al,IRR			;read Interrupt Request
					; register
	and	al,1			;set AL to 1 if IRQ0 (the
					; timer interrupt) is pending
	mov	cs:[OverflowFlag],al	;store the timer overflow
					; status
;
; Allow interrupts to happen again.
;
	sti
;
; Read out the count we latched earlier.
;
	in	al,TIMER_0_8253		;least significant byte
	DELAY
	mov	ah,al
	in	al,TIMER_0_8253		;most significant byte
	xchg	ah,al
	neg	ax			;convert from countdown
					; remaining to elapsed
					; count
	mov	cs:[TimedCount],ax
; Time a zero-length code fragment, to get a reference for how
; much overhead this routine has. Time it 16 times and average it,
; for accuracy, rounding the result.
;
	mov	cs:[ReferenceCount],0
	mov	cx,16
	cli				;interrupts off to allow a
					; precise reference count
RefLoop:
	call	ReferenceZTimerOn
	call	ReferenceZTimerOff
	loop	RefLoop
	sti
	add	cs:[ReferenceCount],8	;total + (0.5 * 16)
	mov	cl,4
	shr	cs:[ReferenceCount],cl	;(total) / 16 + 0.5
;
; Restore original interrupt state.
;
	pop	ax			;retrieve flags when called
	mov	ch,cs:[OriginalFlags]	;get back the original upper
					; byte of the FLAGS register
	and	ch,not 0fdh		;only care about original
					; interrupt flag...
	and	ah,0fdh			;...keep all other flags in
					; their current condition
	or	ah,ch			;make flags word with original
					; interrupt flag
	push	ax			;prepare flags to be popped
;
; Restore the context of the program being timed and return to it.
;
	MPOPF				;restore the flags with the
					; original interrupt state
	pop	cx
	pop	ax
	ret

ZTimerOff endp

;
; Called by ZTimerOff to start timer for overhead measurements.
;

ReferenceZTimerOn	proc	near
;
; Save the context of the program being timed.
;
	push	ax
	pushf		;interrupts are already off
;
; Set timer 0 of the 8253 to mode 2 (divide-by-N), to cause
; linear counting rather than count-by-two counting.
;
	mov	al,00110100b	;set up to load
	out	MODE_8253,al	; initial timer count
	DELAY
;
; Set the timer count to 0.
;
	sub	al,al
	out	TIMER_0_8253,al	;load count lsb
	DELAY
	out	TIMER_0_8253,al	;load count msb
;
; Restore the context of the program being timed and return to it.
;
	MPOPF
	pop	ax
	ret

ReferenceZTimerOn	endp

;
; Called by ZTimerOff to stop timer and add result to ReferenceCount
; for overhead measurements.
;

ReferenceZTimerOff proc	near
;
; Save the context of the program being timed.
;
	push	ax
	push	cx
	pushf
;
; Latch the count and read it.
;
	mov	al,00000000b		;latch timer 0
	out	MODE_8253,al
	DELAY
	in	al,TIMER_0_8253		;lsb
	DELAY
	mov	ah,al
	in	al,TIMER_0_8253		;msb
	xchg	ah,al
	neg	ax			;convert from countdown
					; remaining to amount
					; counted down
	add	cs:[ReferenceCount],ax
;
; Restore the context of the program being timed and return to it.
;
	MPOPF
	pop	cx
	pop	ax
	ret

ReferenceZTimerOff endp

;********************************************************************
;* Routine called to report timing results.			    *
;********************************************************************

ZTimerReport	proc	near

	pushf
	push	ax
	push	bx
	push	cx
	push	dx
	push	si
	push	ds
;
	push	cs	;DOS functions require that DS point
	pop	ds	; to text to be displayed on the screen
;
; Check for timer 0 overflow.
;
	cmp	[OverflowFlag],0
	jz	PrintGoodCount
	mov	dx,offset OverflowStr
	mov	ah,9
	int	21h
	jmp	short EndZTimerReport
;
; Convert net count to decimal ASCII in microseconds.
;
PrintGoodCount:
	mov	ax,[TimedCount]
	sub	ax,[ReferenceCount]
	mov	si,offset ASCIICountEnd - 1
;
; Convert count to microseconds by multiplying by .8381.
;
	mov	dx,8381
	mul	dx
	mov	bx,10000
	div	bx		;* .8381 = * 8381 / 10000
;
; Convert time in microseconds to 5 decimal ASCII digits.
;
	mov	bx,10
	mov	cx,5
CTSLoop:
	sub	dx,dx
	div	bx
	add	dl,'0'
	mov	[si],dl
	dec	si
	loop	CTSLoop
;
; Print the results.
;
	mov	ah,9
	mov	dx,offset OutputStr
	int	21h
;
EndZTimerReport:
	pop	ds
	pop	si
	pop	dx
	pop	cx
	pop	bx
	pop	ax
	MPOPF
	ret

ZTimerReport	endp
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\bootx\romdec32\bin\makefile.inc ===
$(BASEDIR)\private\ntos\obj\i386\romdec32.bin: ..\r16\obj\i386\rstartup.com ..\r32\obj\i386\romdec32.exe
    rdbld ..\r32\obj\i386\romdec32.exe ..\r16\obj\i386\rstartup.com $(BASEDIR)\private\ntos\obj\i386\romdec32.bin
!IFDEF _NT386TREE
    binplace -R $(_NTTREE) $(BINPLACE_DBGFLAGS_NT) $(BINPLACE_FLAGS) $@
!ENDIF


# Hack to get around a MP build problem where romdec32.exe isn't linked by
# the time the above build dependency rule is evaluated.
..\r32\obj\i386\romdec32.exe:
    sleep 1
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\bootx\romdec32\i386\inittbl.asm ===
;++
;
;  Copyright (c) Microsoft Corporation. All rights reserved
;
;  Module Name:
;
;    inittbl.asm
;
;  Abstract:
;
;    This module contains table of commands used by South Bridge to initialize
;    hardware and test memory during boot startup.  For definition of each
;    command, please see initcode.inc and command.inc
;
;--
        INCLUDE chipset.inc

;
; To build the init table for old A02 (without M7, fansink) DVT3s, DVT2s and 
; DVT1, define INITTABLE_OLDA02.  To build the init table for fullspeed systems, 
; this should undefined.  We are currently building two init tables:
;
;
;   Init Table            Ver    Defines
;   --------------------- ------ ----------------------------------------------------------
;   DVT4/5                0x46   SYS_DVT4  
;
;   DVT6                  0x60   SYS_DVT6 (SYS_DVT4 undefined)
;
;   QT                    0x70   SYS_QT (automatically defines SYS_DVT6)
;

        INCLUDE nv2ainit.inc

        END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\bootx\romdec32\i386\nv2a.inc ===
;
; NV2A ROM table ptr (NV20 Register Base/Limit (BAR0)
;
NV2A_XBOX_ROM_TABLE_PTR          EQU 0FF000008h

;
; Datatbl starts at this offset
;
; IMPORTANT: This must be adjusted if the size of the init table
; code has changed
;
IFDEF SYS_RETAIL
DATATBL_BASE_OFFSET              EQU 0C90h
ELSE
DATATBL_BASE_OFFSET              EQU 0BF0h
ENDIF

;
; Integrated NV20 Register Base (BAR0)
;
NV20_REG_BASE                    EQU 00F000000h    ; only during the init tbl
NV20_REG_BASE_KERNEL             EQU 0FD000000h    ; reloaded to agree with kernel code
NV20_FB_BASE                     EQU 0F0000000h
APERTURE_BASE                    EQU 040000000h

SMB_CONTROL_BASE                 EQU 00000C000h
SMB_DDC_SPIO_BASE                EQU 00000C200h

;
; NV2A config equates
;
CR_CPU_MEMTOP                    EQU 080000084h
CR_CPU_MEMTOP_LIMIT_64MB         EQU 003FFFFFFh
CR_CPU_MEMTOP_LIMIT_128MB        EQU 007FFFFFFh

CR_CPU_CST_0                     EQU 080000340h
CR_CPU_CST_1                     EQU 080000344h
CR_CPU_CST_7                     EQU 08000035Ch

CR_CPU_MPLL_COEFF                EQU 08000036Ch

CR_APC_P2P_1                     EQU 08000F004h
CR_APC_P2P_1_BUS_MSTR_MEM_IO     EQU 000000007h    ; should be RMW, still ok?

CR_APC_P2P_6                     EQU 08000F018h
CR_APC_P2P_6_SUB_SEC_PRI_BUS     EQU 000010100h    ; change CR_NV20, if bus changes

CR_APC_P2P_8                     EQU 08000F020h
CR_APC_P2P_8_MLIMIT_MBASE_INIT   EQU (NV20_REG_BASE + 0F00000h) OR (NV20_REG_BASE SHR 16)
CR_APC_P2P_8_MLIMIT_MBASE_KERNEL EQU (NV20_REG_BASE_KERNEL + 0F00000h) OR (NV20_REG_BASE_KERNEL SHR 16)
CR_APC_P2P_9                     EQU 08000F024h
CR_APC_P2P_9_PREF_MLIMIT_MBASE   EQU (NV20_FB_BASE +  7F00000h) OR (NV20_FB_BASE SHR 16)

CR_APC_P2P_19                    EQU 08000F04Ch
CR_APC_P2P_19_NV20_ENABLE        EQU 000000001h    ; enables internal graphics

;
; MCP config equates
;
MCP_LEG_CFG_1                    EQU 080000804h    ; enable IO space
MCP_LEG_CFG_2                    EQU 080000808h    ; holds MCP revision ID

IFDEF MCP_REV_C03
MCP_LEG_CFG_4                    EQU 080000884h    ; IO BAR for revs >= C03
ELSE
MCP_LEG_CFG_4                    EQU 080000810h    ; IO BAR for revs < C03
ENDIF

MCP_LEG_CFG_19                   EQU 08000084Ch
MCP_LEG_CFG_24                   EQU 080000860h
MCP_LEG_CFG_39                   EQU 08000089Ch
MCP_LEG_CFG_45                   EQU 0800008B4h

MCP_SMB_CFG_1                    EQU 080000904h
MCP_SMB_CFG_1_IO_SPACE           EQU 000000001h    ; should be RMW, still ok?

MCP_SMB_CFG_5                    EQU 080000914h
MCP_SMB_CFG_5_IO_BASE            EQU SMB_CONTROL_BASE + 1

MCP_SMB_CFG_6                    EQU 080000918h
MCP_SMB_CFG_6_IO_BASE            EQU SMB_DDC_SPIO_BASE + 1

MCP_USBA_CFG_15                  EQU 08000103Ch    ; scratch pad for meminit
MCP_USBB_CFG_15                  EQU 08000183Ch    ; scratch pad for meminit

;
; MCP registers used as scratchpad for memory test
;
MEMTEST_TYPE                     EQU 08000103Ch    ; MCP_USBA_CFG_15 
MEMTEST_RESULT                   EQU 08000183Ch    ; MCP_USBB_CFG_15 

;
; Memory test patterns
;
MEMTEST_PATTERN1                 EQU 0AAAAAAAAh
MEMTEST_PATTERN2                 EQU 05A5A5A5Ah
MEMTEST_PATTERN3                 EQU 055555555h
MEMTEST_PATTERN4                 EQU 0CCCCCCCCh


; Internal NV20 config equates (assumes bus 1)
;
CR_NV20_PCI_1                    EQU 080010004h
CR_NV20_PCI_1_BUS_MSTR_MEM_IO    EQU 000000007h    ; should be RMW, still ok?

CR_NV20_PCI_4                    EQU 080010010h
CR_NV20_PCI_5                    EQU 080010014h

;
; NV20 register offsets and init values (from nv2a\manuals\rom_table.txt)
;
NV_PBUS_DEBUG_CTRIM_0            EQU 0000010B0h
NV_PBUS_DEBUG_CTRIM_1            EQU 0000010B4h
NV_PBUS_DEBUG_CTRIM_2            EQU 0000010B8h
NV_PBUS_DEBUG_CTRIM_3            EQU 0000010BCh
NV_PBUS_DEBUG_CTRIM_4            EQU 0000010C4h
NV_PBUS_DEBUG_CTRIM_5            EQU 0000010C8h
NV_PBUS_DEBUG_CTRIM_6            EQU 0000010CCh
NV_PBUS_DEBUG_CTRIM_7            EQU 0000010D4h
NV_PBUS_DEBUG_CTRIM_8            EQU 0000010D8h
NV_PBUS_DEBUG_CTRIM_9            EQU 0000010DCh
NV_PBUS_DEBUG_CTRIM_10           EQU 0000010E8h

NV_PBUS_FBIO_CFG                 EQU 000001210h

NV_PBUS_FBIO_CALEN               EQU 000001220h
NV_PBUS_FBIO_CALEN_OFF           EQU 000000000h

NV_PBUS_FBIO_CALSEL              EQU 000001228h
NV_PBUS_FBIO_CALSEL_VALUE        EQU 000000000h

NV_PBUS_FBIO_DLY                 EQU 000001214h

NV_PBUS_FBIO_ADRDRV              EQU 00000122Ch
NV_PBUS_FBIO_CLKDRV              EQU 000001230h
NV_PBUS_FBIO_DATDRV              EQU 000001234h
NV_PBUS_FBIO_DATDRV_INIT         EQU 0AAAAAAAAh
NV_PBUS_FBIO_DQSDRV              EQU 000001238h
NV_PBUS_FBIO_DQSDRV_INIT         EQU 0AAAAAAAAh
NV_PBUS_FBIO_ADRSLW              EQU 00000123Ch
NV_PBUS_FBIO_ADRSLW_INIT         EQU 08B8B8B8Bh
NV_PBUS_FBIO_CLKSLW              EQU 000001240h
NV_PBUS_FBIO_DATSLW              EQU 000001244h
NV_PBUS_FBIO_DATSLW_INIT         EQU 08B8B8B8Bh
NV_PBUS_FBIO_DQSSLW              EQU 000001248h
NV_PBUS_FBIO_DQSSLW_INIT         EQU 08B8B8B8Bh
NV_PBUS_DISPIO_PADCTL            EQU 00000124Ch
NV_PBUS_DISPIO_PADCTL_INIT       EQU 0AA8BAA8Bh
NV_PBUS_TVDIO_PADCTL             EQU 000001250h
NV_PBUS_TVDIO_PADCTL_INIT        EQU 00000AA8Bh

NV_PBUS_TVDIO_CALEN              EQU 000001264h
NV_PBUS_TVDIO_CALEN_OFF          EQU 000000000h

NV_PEXTDEV_BOOT_0                EQU 000101000h

NV_PFB_REF                       EQU 0001002D0h
NV_PFB_PRE                       EQU 0001002D4h
NV_PFB_PRE_CMD_PRECHARGE_1       EQU 000000001h
NV_PFB_EMRS                      EQU 0001002C4h
NV_PFB_EMRS_EXT                  EQU 0001002CCh
NV_PFB_MRS                       EQU 0001002C0h
NV_PFB_MRS_DLL_RESET             EQU 000000132h
NV_PFB_MRS_EXT                   EQU 0001002C8h
NV_PFB_MRS_EXT_DLL_RESET         EQU 000000132h
NV_PFB_REFCTRL                   EQU 000100210h
NV_PFB_REFCTRL_VALID_1           EQU 080000000h
NV_PFB_WBC                       EQU 000100410h
NV_PFB_CPU_RRQ                   EQU 000100420h
NV_PFB_CPU_RRQ_FWP_LAT_ENABLE    EQU 000000401h
NV_PFB_BYPASS                    EQU 000100424h
NV_PFB_BYPASS_VALUE              EQU 0F1780031h

NV_PMC_BOOT_0                    EQU 000000000h

NV_PRAMDAC_PLL_COEFF_SELECT      EQU 00068050Ch
NV_PFB_CFG0                      EQU 000100200h
NV_PFB_CFG1                      EQU 000100204h

NV_PFB_TIMING2                   EQU 000100228h

NV_PFB_ARB_XFER_SZ               EQU 000100330h
NV_PFB_ARB_TIMEOUT               EQU 00010032Ch
NV_PFB_ARB_PREDIVIDER            EQU 000100328h
NV_PFB_ARB_DIFF_BANK             EQU 000100338h

NV_PBUS_FBIO_RAM                 EQU 000001218h

NV_PRAMDAC_NVPLL_COEFF           EQU 000680500h

NV_PGRAPH_DEBUG_2                EQU 000400880h
NV_PGRAPH_DEBUG_2_VALUE          EQU 0002EC3FFh
NV_PGRAPH_DEBUG_10               EQU 000400b88h
NV_PGRAPH_DEBUG_10_ROP_BLEND     EQU 000000003h

;
; Equates used for the memory detect/test
;
MEM_PART_0                       EQU 000000000h
MEM_PART_1                       EQU 000000010h
MEM_PART_2                       EQU 000000020h
MEM_PART_3                       EQU 000000030h
MEM_PART_4                       EQU 004000000h
MEM_PART_5                       EQU 004000010h
MEM_PART_6                       EQU 004000020h
MEM_PART_7                       EQU 004000030h


;
; First byte of the desired SMC revision
;
DESIRED_SMC_VER                  EQU 050h
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\bootx\romdec32\i386\encrypt.inc ===
;++
;  Copyright (c) 1996, 1997 Microsoft Corporation
;
;  Copyright (C) 1987 RSA Data Security, Inc. Created 1987.
;  This is an unpublished work protected as such under copyright law.
;  This work contains proprietary, confidential, and trade secret information
;  of RSA Data Security, Inc.  Use, disclosure, or reproduction without the
;  express written authorization of RSA Data Security, Inc., is prohibited.
;
;
;  Abstract:
;
;     This code is derived from Scott Field's optimized implementation of the
;     RC4 algorithm.  Following changes were made.
;        1.  rc4_key and rc4 functionality have been merged 
;        2.  Does not preserve any registers--does not use stack
;        3.  Does not take any parameters--everything is hardcoded
;        4.  Does not update the indicies in the key structure at end
;        5.  Separate input/output buffers
;
;  Environment:
;
;     32-bit Protected Mode
;
;--



;
; RC4 key expansion functionality (rc4_key) 
;

        mov     eax, 03020100H          ; initial fill value
        mov     ecx, 64                 ; loop iteration count

        mov     esi, ROMDEC_KEYSTRUCT

        mov     edx, esi

;
; for (a=0x03020100,i=0;i<RC4_TABLESIZE/sizeof(DWORD);i++, a+= 0x04040404)
;       ((DWORD*)p)[i] = a;

init_loop:

        mov     DWORD PTR [edx], eax
        add     edx, 4

        add     eax, 04040404H
        dec     ecx

        jne     init_loop

; i = j = k = 0;

        xor     ecx, ecx                ; k = 0
        xor     edi, edi

        mov     ebp, OFFSET EncKey
        mov     BYTE PTR [esi+256], cl  ; Key->i = 0;

        mov     BYTE PTR [esi+257], cl  ; Key->j = 0;
        xor     ebx, ebx


; while (i < RC4_TABLESIZE) {

permute_loop:

        ; ti = p[i];

        ; tk = K[k];
        ; j += tk;

        ; j += ti;

        ; j &= (RC4_TABLESIZE - 1);
        ; tj = p[j];
        ; k++;

        ; p[i] = tj;

        ; i++;
        ; p[j] = ti;

        xor     edx, edx                        ; avoid p6 partial stall
        xor     eax, eax                        ; avoid p6 partial stall

        mov     dl, BYTE PTR [esi+edi]
        mov     al, BYTE PTR [ecx+ebp]

        add     bl, al                          ; add ebx, eax
        inc     ecx

        add     bl, dl                          ; add ebx, edx
        inc     edi

        ; if (k == m)

;        and     ebx, 0FFh                      ; and not needed due to 8 bit add

        mov     al, BYTE PTR [esi+ebx]
        mov     BYTE PTR [esi+edi-1], al

        cmp     ecx, ROMDEC_KEYSIZE      
        mov     BYTE PTR [esi+ebx], dl

        jne     skip_zero_k

        xor     ecx, ecx

skip_zero_k:

        cmp     edi, 256
        jb      permute_loop



;
; RC4 encryption functionality (rc4) 
;

        xor     ecx, ecx
        xor     edx, edx
        xor     edi, edi
        xor     eax, eax

        mov     esi, ROMDEC_KEYSTRUCT   ; p = Key->S
        mov     ebp, ROMDEC_BUFFERSIZE  ; byte count
        
        mov     cl, BYTE PTR [esi+256]  ; i = Key->i

        mov     dl, BYTE PTR [esi+257]  ; j = Key->j

rc4_loop:

        inc     cl                      ; i ++ ; i &= (RC4_TABLESIZE-1)

        mov     al, BYTE PTR [ecx+esi]  ; t = p[i]

        add     dl, al                  ; j += t ; j &= (RC4_TABLESIZE-1)

        mov     bl, BYTE PTR [edx+esi]  ; pickup p[j]

        mov     BYTE PTR [ecx+esi], bl  ; p[i] = p[j]
        mov     BYTE PTR [edx+esi], al  ; p[j] = t (potential bank conflict)

;
; *outputbuffer++ = *inputbuffer++ ^ p[( p[i] + t) & (RC4_TABLESIZE-1) ];
;

        add     al, bl                                  ; (t += p[i]) & RC4_TABLESIZE-1

        mov     bl, BYTE PTR ROMDEC_INPUTBUFFER[edi]    ; get byte from input buffer

        mov     al, BYTE PTR [eax+esi]                  ; pickup p[t]

        xor     bl, al                  

        mov     BYTE PTR ROMDEC_OUTPUTBUFFER[edi], bl   ; write byte to output buffer

        inc     edi                                     ; bufferindex++

        dec     ebp                                     ; loop until no input left to process
        jnz     rc4_loop                

rc4_done:
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\bootx\romdec32\i386\nvidia.inc ===
COMMAND_QUIT		   EQU 0
COMMAND_TIMING_DELAY       EQU 00000001b
COMMAND_READ_MEM           EQU 00000010b
COMMAND_WRITE_MEM          EQU 00000100b
COMMAND_PCI_CFG_WRITE      EQU 00001000b
COMMAND_PCI_CFG_READ       EQU 00010000b
COMMAND_RMW_RESULT         EQU 00100000b
COMMAND_USE_RESULT_AS_DATA EQU 01000000b

DONT_CARE		   EQU 0

nv_command_struct struct
  nv_command db 0
  nv_address dd 0
  nv_data    dd 0
nv_command_struct ends

;
; Sample Table
;
;data_table_test LABEL BYTE
;c00 nv_command_struct <COMMAND_TIMING_DELAY ,      5 ,                    DONT_CARE >
;c01 nv_command_struct <COMMAND_READ_MEM,           050000000h,            DONT_CARE >
;c02 nv_command_struct <COMMAND_WRITE_MEM,          050000000h,            55aa55aah >
;c04 nv_command_struct <COMMAND_PCI_CFG_WRITE,      80000004h,             7         >
;c05 nv_command_struct <COMMAND_PCI_CFG_READ,       80000004h,             DONT_CARE >
;c06 nv_command_struct <COMMAND_RMW_RESULT,         5,                     00007700h >
;c07 nv_command_struct <COMMAND_USE_RESULT_AS_DATA, COMMAND_PCI_CFG_WRITE, 80000004h >
;c19 nv_command_struct <>



  mov  esi, ROMDEC_NVIDIA_TABLE

.repeat

  mov  al, ds:[esi]
  mov  ebx, ds:[esi+1]
  mov  ecx, ds:[esi+5]
  
  .if al & COMMAND_USE_RESULT_AS_DATA
    mov  edx, ecx
    mov  al, bl
    mov  ebx, edx
    mov  ecx, edi
  .endif
  
  .if al & COMMAND_TIMING_DELAY
; cx will already have the io's to do.
    mov  dx, 80h
    rep  insb
  .elseif al & COMMAND_READ_MEM
    mov  edi, [ebx]
  .elseif al & COMMAND_WRITE_MEM
    mov  [ebx], ecx
  .elseif al & COMMAND_RMW_RESULT
    and  edi, ebx
    or   edi, ecx
  .elseif al & COMMAND_PCI_CFG_WRITE 
    mov  eax, ebx
    mov  dx, 0cf8h
    out  dx, eax
    add  dx, 4
    mov  eax, ecx
    out  dx,eax
  .elseif al & COMMAND_PCI_CFG_READ
    mov  eax, ebx
    mov  dx, 0cf8h
    out  dx, eax
    add  dx, 4
    in   eax, dx
    mov  edi, eax
  .elseif al == COMMAND_QUIT
    mov  esi, -9
  .endif
  add  esi, SIZEOF nv_command_struct
.until esi == 0
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\bootx\romdec32\i386\initcode.inc ===
;++
;
;  Copyright (c) Microsoft Corporation. All rights reserved
;
;  Module Name:
;
;    initcode.inc
;
;  Abstract:
;
;    This module contains code to parse and process the init table opcodes
;--


;
; Load the start address of the init table 
;        
        mov  esi, ROMDEC_INIT_TABLE


InitLoop:
;
; Load command and parameters
;        
        mov     al, ds:[esi]
        mov     ebx, ds:[esi+1]
        mov     ecx, ds:[esi+5]
        
        .if al == COMMAND_USE_RESULT_AS_DATA
;
; Use Result As Data Command 
;        
        mov     edx, ecx
        mov     al, bl
        mov     ebx, edx
        mov     ecx, edi
        .endif


IFDEF MCP_REV_B01
        .if al == COMMAND_RESERVED
;
; This used to be the "Timing Delay Command" but was broken and not used
;
        mov     dx, 80h
        rep     insb

        .elseif al == COMMAND_READ_MEM
ELSE
        .if al == COMMAND_READ_MEM
        
ENDIF   
;
; Read Memory Command 
;        
;    Disallow read memory for top of address space.  The Rev B01
;    implementation used a cmp, others use an and instruction
;
        
IFDEF MCP_REV_B01

IFDEF MCP_XMODE2
        and     ebx, 00FFFFFFFh    
        mov     edi, [ebx]
ELSE
        cmp     ebx, 0FF000000h 
        ja      ReadNotAllowed
        mov     edi, [ebx]

ReadNotAllowed:
ENDIF
        
ELSE    
        and     ebx, 00FFFFFFFh    
        mov     edi, [ebx]
ENDIF   

        .elseif al == COMMAND_WRITE_MEM
;
; Write Memory Command
;        
        mov     [ebx], ecx

        .elseif al == COMMAND_RMW_RESULT
;
; Read Modify Write Result Command
;        
        and     edi, ebx
        or      edi, ecx
        
        .elseif al == COMMAND_PCI_CFG_WRITE 
        
IFNDEF MCP_XMODE2
;
; PCI Config Write Command
;
;    Check to see if the PCI write is for the General SM Ctrl 1 register
;    which is used to turn off the SB ROM.  If it is, turn off the bit 1
;    
        cmp     ebx, 80000880h
        jnz     OKToWrite
        and     ecx, 0FFFFFFFDh 
                
OKToWrite:    

ENDIF
        mov     eax, ebx
        mov     dx, 0cf8h
        out     dx, eax
        add     dl, 4
        mov     eax, ecx
        out     dx,eax

        .elseif al == COMMAND_PCI_CFG_READ
;
; PCI Config Read Command
;        
        mov     eax, ebx
        mov     dx, 0cf8h
        out     dx, eax
        add     dl, 4
        in      eax, dx
        mov     edi, eax

        .elseif al == COMMAND_COMPARE_RESULT_JNE
;
; Compare Result Jump Command
;       
        .if edi != ebx
        add     esi, ecx
        .endif
        
        .elseif al == COMMAND_JMP
;
; Jump Command  
;       
        add  esi, ecx

        .elseif al == COMMAND_RMW_ACCUM
;
; Read Modify Write Accumulator Command
;        
        and     ebp, ebx
        or      ebp, ecx
        mov     edi, ebp
        

        .elseif al == COMMAND_OUT_BYTE
;
; OUT
;       
        mov     edx, ebx
        mov     eax, ecx
        out     dx, al

        .elseif al == COMMAND_IN_BYTE
;
; IN
;       
        mov     edx, ebx
        in      al, dx
        movzx   edi, al
        
        .elseif al == COMMAND_QUIT
        jmp     InitDone
        .endif
        
;
; Advance to next entry in the table
;
Continue:
        add     esi, SIZEOF nv_command_struct
        
        jmp     InitLoop

InitDone:
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\bootx\romdec32\i386\nv2ainit.inc ===
;++
;
;  Copyright (c) Microsoft Corporation. All rights reserved
;
;  Module Name:
;
;    nv2ainit.inc
;
;  Abstract:
;
;    NV2A initialization table
;
;    This module contains table of commands used by South Bridge to initialize
;    hardware and test memory during boot startup.  For definition of each
;    command, please see initcode.inc and command.inc
;--

page    84,132
.MODEL compact
.486p

INCLUDE COMMAND.INC
INCLUDE NV2A.INC

CODE SEGMENT PARA PUBLIC 'code'
  assume  ds:code,es:nothing,ss:nothing
org 0000h

;
; NB data for NV2A on the DVT boards
;

;
; Not currently documented, NV2A expects table ptrs to exist in the first
; 2 DWORDS of the ROM image, which point to the beginning of the ROM table.
; The MCPX still expects to find it's init values starting at 0x70.
;
dd NV2A_XBOX_ROM_TABLE_PTR + 1        ; LSB needs to be 1 to appear valid
dd NV2A_XBOX_ROM_TABLE_PTR

; CR_ROM_NB_BOOT_HEADER                    (0*32+31):(0*32+0) /* R--VF */
;
dd 2B16D065h

; CR_ROM_NB_BOOT_PROC                       (1*32+0):(1*32+0) /* R--VF */
; CR_ROM_NB_BOOT_PROC_INTEL                        0x00000001 /* R---V */
; CR_ROM_NB_BOOT_RAMTYPE                    (1*32+2):(1*32+2) /* R--VF */
; CR_ROM_NB_BOOT_RAMTYPE_DDR                       0x00000001 /* R---V */
; CR_ROM_NB_BOOT_RAMWIDTH                   (1*32+3):(1*32+3) /* R--VF */
; CR_ROM_NB_BOOT_RAMWIDTH_128                      0x00000001 /* R---V */
; CR_ROM_NB_BOOT_MEM_POSTDIV                (1*32+7):(1*32+4) /* R--VF */
; CR_ROM_NB_BOOT_AGP_POSTDIV               (1*32+11):(1*32+8) /* R--VF */
; CR_ROM_NB_BOOT_FSB_ROM                  (1*32+15):(1*32+12) /* R--VF */
; CR_ROM_NB_BOOT_FSB_66                   (1*32+19):(1*32+16) /* R--VF */
; CR_ROM_NB_BOOT_FSB_100                  (1*32+23):(1*32+20) /* R--VF */
; CR_ROM_NB_BOOT_FSB_TUALATIN             (1*32+27):(1*32+24) /* R--VF */
; CR_ROM_NB_BOOT_FSB_133                  (1*32+31):(1*32+28) /* R--VF */
;
; dd 4444444dh    ; (100MHz FSB hardcoded)
; dd 3346323Dh      ; (AGP_PDIV = 2, MEM_PDIV = 3), start at 133MHz
dd 3346322Dh    ; (AGP_PDIV = 2, MEM_PDIV = 2)

;    These COREPLL values are based on using a 13.5MHz xtal.
;
;    NOTE: If you change the MDIV, NDIV, FSB POSTDIV or MEM_POSTDIV you'll
;    need to sync the change with the  CR_CPU_MPLL_COEFF write in the inittbl
;    below.
;
; CR_ROM_NB_BOOT_COREPLL_MDIV_66            (2*32+7):(2*32+0) /* R--VF */
; CR_ROM_NB_BOOT_COREPLL_MDIV_66_VALUE             0x00000007 /* R---V */ 
; CR_ROM_NB_BOOT_COREPLL_MDIV_100          (2*32+15):(2*32+8) /* R--VF */
; CR_ROM_NB_BOOT_COREPLL_MDIV_100_VALUE            0x00000007 /* R---V */ 
; CR_ROM_NB_BOOT_COREPLL_MDIV_TUALATIN    (2*32+23):(2*32+16) /* R--VF */
; CR_ROM_NB_BOOT_COREPLL_MDIV_TUALATIN_VALUE       0x00000007 /* R---V */ 
; CR_ROM_NB_BOOT_COREPLL_MDIV_133         (2*32+31):(2*32+24) /* R--VF */
; CR_ROM_NB_BOOT_COREPLL_MDIV_133_VALUE            0x00000007 /* R---V */ 
;
; dd 07070707h
; dd 01010101h
dd 01010101h

; CR_ROM_NB_BOOT_COREPLL_NDIV_66            (3*32+7):(3*32+0) /* R--VF */
; CR_ROM_NB_BOOT_COREPLL_NDIV_66_VALUE             0x00000022 /* R---V */
; CR_ROM_NB_BOOT_COREPLL_NDIV_100          (3*32+15):(3*32+8) /* R--VF */
; CR_ROM_NB_BOOT_COREPLL_NDIV_100_VALUE            0x00000034 /* R---V */
; CR_ROM_NB_BOOT_COREPLL_NDIV_TUALATIN    (3*32+23):(3*32+16) /* R--VF */
; CR_ROM_NB_BOOT_COREPLL_NDIV_TUALATIN_VALUE       0x00000045 /* R---V */
; CR_ROM_NB_BOOT_COREPLL_NDIV_133         (3*32+31):(3*32+24) /* R--VF */
; CR_ROM_NB_BOOT_COREPLL_NDIV_133_VALUE            0x00000045 /* R---V */
;
; dd 45453422h
; dd 07070707h        ; (100MHz FSB)
; dd 08080808h        ; (106MHz FSB)
; dd 0A0A0A0Ah        ; (135MHz FSB)
; dd 09090909h        ; (133MHz FSB)
dd 08080808h          ; (133MHz FSB 16.66MHz input clock)

; CR_ROM_NB_BOOT_COREPLL_MDIV_ROM           (4*32+7):(4*32+0) /* R--VF */
; CR_ROM_NB_BOOT_COREPLL_MDIV_ROM_VALUE            0x00000007 /* R---V */
; CR_ROM_NB_BOOT_COREPLL_NDIV_ROM          (4*32+15):(4*32+8) /* R--VF */
; CR_ROM_NB_BOOT_COREPLL_NDIV_ROM_VALUE            0x00000045 /* R---V */
; CR_ROM_NB_BOOT_ASRC_CPU                 (4*32+23):(4*32+16) /* R--VF */
; CR_ROM_NB_BOOT_ASRC_LDT                 (4*32+31):(4*32+24) /* R--VF */
;
; dd 4507h
; dd 0801h          ; (106MHz FSB)
; dd 0701h          ; (100MHz FSB)
; dd 0A01h          ; (135MHz FSB)
; dd 1D03h          ; (133MHz FSB)
dd 0801h            ; (133MHz FSB w/ 16.66MHz input clock)

; CR_ROM_NB_BOOT_SADDOUTCLK_DLY             (5*32+3):(5*32+0) /* R--VF */
; CR_ROM_NB_BOOT_SDATAOUTCLK_DLY            (5*32+7):(5*32+4) /* R--VF */
; CR_ROM_NB_BOOT_CPU_VREF_EN_               (5*32+8):(5*32+8) /* R--VF */
; CR_ROM_NB_BOOT_APIC_33                    (5*32+9):(5*32+9) /* R--VF */
; CR_ROM_NB_BOOT_COREPLL_SETUP            (5*32+18):(5*32+10) /* R--VF */
; CR_ROM_NB_BOOT_CPUPLL_SETUP             (5*32+27):(5*32+19) /* R--VF */
; CR_ROM_NB_BOOT_COREPLL_DLY              (5*32+31):(5*32+28) /* R--VF */
;
dd 0C8FC7C8Ah

; CR_ROM_NB_BOOT_CTRIM_CPUCLKFB             (6*32+3):(6*32+0) /* R--VF */
; CR_ROM_NB_BOOT_CTRIM_CPUCLKFB_VALUE              0x00000003 /* R---V */
; CR_ROM_NB_BOOT_CTRIM_CPUCLK2X_BL          (6*32+7):(6*32+4) /* R--VF */
; CR_ROM_NB_BOOT_CTRIM_CPUCLK2X_BL_VALUE           0x00000001 /* R---V */
; CR_ROM_NB_BOOT_CTRIM_CPUCLK2X_BR         (6*32+11):(6*32+8) /* R--VF */
; CR_ROM_NB_BOOT_CTRIM_CPUCLK2X_BR_VALUE           0x00000002 /* R---V */
; CR_ROM_NB_BOOT_CTRIM_CPUCLK_NW          (6*32+15):(6*32+12) /* R--VF */
; CR_ROM_NB_BOOT_CTRIM_CPUCLK_NW_VALUE_DONTCARE    0x00000000 /* R---V */
; CR_ROM_NB_BOOT_CTRIM_CPUCLK_SW          (6*32+19):(6*32+16) /* R--VF */
; CR_ROM_NB_BOOT_CTRIM_CPUCLK_SW_VALUE             0x00000009 /* R---V */
; CR_ROM_NB_BOOT_CTRIM_CPUCLK_SE          (6*32+23):(6*32+20) /* R--VF */
; CR_ROM_NB_BOOT_CTRIM_CPUCLK_SE_VALUE             0x00000002 /* R---V */
; CR_ROM_NB_BOOT_CTRIM_CPUOCLK_BL         (6*32+27):(6*32+24) /* R--VF */
; CR_ROM_NB_BOOT_CTRIM_CPUOCLK_BL_VALUE            0x00000002 /* R---V */
; CR_ROM_NB_BOOT_CTRIM_CPUOCLK_BR         (6*32+31):(6*32+28) /* R--VF */
; CR_ROM_NB_BOOT_CTRIM_CPUOCLK_BR_VALUE            0x00000002 /* R---V */
;
dd 44290213h        ; A03


; CR_ROM_NB_BOOT_CTRIM_CPUCLKOUT            (7*32+3):(7*32+0) /* R--VF */
; CR_ROM_NB_BOOT_CTRIM_CPUCLKOUT_VALUE             0x00000008 /* R---V */
; CR_ROM_NB_BOOT_CTRIM_APICCLK_MCP          (7*32+7):(7*32+4) /* R--VF */
; CR_ROM_NB_BOOT_CTRIM_APICCLK_MCP_VALUE           0x00000009 /* R---V */
; CR_ROM_NB_BOOT_CTRIM_APICCLK_CPU         (7*32+11):(7*32+8) /* R--VF */
; CR_ROM_NB_BOOT_CTRIM_APICCLK_CPU_VALUE           0x00000009 /* R---V */
; CR_ROM_NB_BOOT_CTRIM_COREPLLFB          (7*32+15):(7*32+12) /* R--VF */
; CR_ROM_NB_BOOT_CTRIM_COREPLLFB_VALUE             0X00000004 /* R---V */
; CR_ROM_NB_BOOT_CTRIM_CPUPLLFB           (7*32+19):(7*32+16) /* R--VF */
; CR_ROM_NB_BOOT_CTRIM_SPARE1             (7*32+23):(7*32+20) /* R--VF */
; CR_ROM_NB_BOOT_CTRIM_SPARE1_VALUE_DONTCARE       0x00000000 /* R---V */
; CR_ROM_NB_BOOT_CTRIM_SPARE2             (7*32+27):(7*32+24) /* R--VF */
; CR_ROM_NB_BOOT_CTRIM_SPARE2_VALUE_DONTCARE       0x00000000 /* R---V */
; CR_ROM_NB_BOOT_CTRIM_SPARE3             (7*32+31):(7*32+28) /* R--VF */
;
IFDEF SYS_DVT6
dd 90004998h
ELSE
dd 00064998h
ENDIF

; CR_ROM_NB_BOOT_CSHAPE_CPUCLKFB            (8*32+3):(8*32+0) /* R--VF */
; CR_ROM_NB_BOOT_CSHAPE_CPUCLKFB_VALUE             0x00000000 /* R---V */
; CR_ROM_NB_BOOT_CSHAPE_CPUCLK2X            (8*32+7):(8*32+4) /* R--VF */
; CR_ROM_NB_BOOT_CSHAPE_CPUCLK2X_VALUE             0x00000000 /* R---V */
; CR_ROM_NB_BOOT_CSHAPE_CPUCLK             (8*32+11):(8*32+8) /* R--VF */
; CR_ROM_NB_BOOT_CSHAPE_CPUCLK_VALUE               0x00000000 /* R---V */
; CR_ROM_NB_BOOT_CSHAPE_CPUCLKOUT         (8*32+15):(8*32+12) /* R--VF */
; CR_ROM_NB_BOOT_CSHAPE_CPUCLKOUT_VALUE            0x00000000 /* R---V */
; CR_ROM_NB_BOOT_CSHAPE_APICCLK_CPU       (8*32+19):(8*32+16) /* R--VF */
; CR_ROM_NB_BOOT_CSHAPE_APICCLK_CPU_VALUE          0x00000000 /* R---V */
; CR_ROM_NB_BOOT_CSHAPE_APICCLK_MCP       (8*32+23):(8*32+20) /* R--VF */
; CR_ROM_NB_BOOT_CSHAPE_APICCLK_MCP_VALUE          0x00000000 /* R---V */
; CR_ROM_NB_BOOT_CSHAPE_SPARE1            (8*32+27):(8*32+24) /* R--VF */
; CR_ROM_NB_BOOT_CSHAPE_SPARE1_VALUE_DONTCARE      0x00000000 /* R---V */
; CR_ROM_NB_BOOT_CSHAPE_SPARE2            (8*32+31):(8*32+28) /* R--VF */
; CR_ROM_NB_BOOT_CSHAPE_SPARE2_VALUE               0x00000000 /* R---V */
;
dd 000000000h

; CR_ROM_NB_BOOT_INTEL_BPRI_                (9*32+0):(9*32+0) /* R--VF */    
; CR_ROM_NB_BOOT_INTEL_BNR_                 (9*32+1):(9*32+1) /* R--VF */    
; CR_ROM_NB_BOOT_INTEL_ADS_                 (9*32+2):(9*32+2) /* R--VF */    
; CR_ROM_NB_BOOT_INTEL_ADDR_               (9*32+31):(9*32+3) /* R--VF */    
;
dd 0FFFFFFFFh

; CR_ROM_NB_BOOT_INTEL_TRDY_              (10*32+0):(10*32+0) /* R--VF */
; CR_ROM_NB_BOOT_INTEL_RS_                (10*32+3):(10*32+1) /* R--VF */
; CR_ROM_NB_BOOT_INTEL_REQ_               (10*32+8):(10*32+4) /* R--VF */
; CR_ROM_NB_BOOT_INTEL_HITM_              (10*32+9):(10*32+9) /* R--VF */
; CR_ROM_NB_BOOT_INTEL_HIT_             (10*32+10):(10*32+10) /* R--VF */
; CR_ROM_NB_BOOT_INTEL_DRDY_            (10*32+11):(10*32+11) /* R--VF */
; CR_ROM_NB_BOOT_INTEL_DEFER_           (10*32+12):(10*32+12) /* R--VF */
; CR_ROM_NB_BOOT_INTEL_DBSY_            (10*32+13):(10*32+13) /* R--VF */
; CR_ROM_NB_BOOT_INTEL_AGTL_PLUS        (10*32+14):(10*32+14) /* R--VF */
; CR_ROM_NB_BOOT_INTEL_SPARE1           (10*32+31):(10*32+15) /* R--VF */
;
dd 0FFFFFFFFh

;
; 14 DWORDS used (11 for CR_ROM_BOOT, 2 table ptrs, 1 DWORD ROM rev)
;
dd (28-14) dup (0h)

; ROM/Trims Revision number
;
; To keep track of TRIM changes and other inittbl/datatbl changes, we'll
; use this DWORD as the revision ID. We'll also keep the history here, so
; clear what's been changed.
;
; rev1.00 - 
;    . set QUSE_NORMAL in NV_PBUS_FBIO_CFG
;    . set NB_BOOT_CPUPLL_SETUP[3:0] and NB_BOOT_COREPLL_SETUP[3:0] to 0xF
;    . set NB_BOOT_CTRIM_CPUPLLFB to 0x6
;    . set NV_PBUS_DEBUG_CTRIM_6 to 0x66660000 and
;          NV_PBUS_DEBUG_CTRIM_2 to 0x11110000, in that order
;    . clear most significant nibble from NV_PBUS_DEBUG_CTRIM_4
;    . add SYS_DVT3 ifdef for (DVT3) 13.5 vs. (DVT4) 16.6 input clocks,
;      with changes to:
;          NB_BOOT_COREPLL_NDIV and MDIV
;          NV_PRAMDAC_NVPLL_COEFF
;          CR_CPU_MPLL_COEFF
;    . add NV2A_REV_A03 ifdef for A03 related trims:
;          CTRIM_CPUOCLK_BL = 0x4
;          CTRIM_CPUOCLK_BR = 0x4
;          CR_CPU_CST_0     = 0xF0F0C0C0
;    . update 13.5 and 16.6 calibration speedometer settings
;          (previous VCC values were incorrect for both input clocks)
;
; rev1.01 - 
;    . set WBC from 0x11000001 (which is no buffering) to 0x11000016
;    . reset PFB_ARB_XFER_SZ_ZW from 0xF (unlimited burst) to 0x8
;          since NV2A doesn't need the zcull workaround like NV20.
;    . set DQS/DQ inbound delay to 0x1/0x0 in the Samsung calibration table
;    . set the MCLK drive/slew parameters to their max (helps clock jitter).
;
; rev1.02 -
;    . change NV_PBUS_FBIO_CFG (from 0x1 to 0x10) for 1/4 clock delay
;    . change NV_PBUS_DEBUG_CTRIM_2 (from 0x11110000 to 0x0)
;
; rev1.03 - 
;    . max MCP_LEG_CFG_45_PCICLKO5_TRIM to better line up the PCI clk
;           for the LPC card 
;    . DVT6 trims (tested with the Cypress zero delay buffer):
;           PBUS_DEBUG_CTRIM_2 = 0xFFFF0000
;           CR_ROM_NB_BOOT_CTRIM_CPUPLLFB = 0x0
;           CR_ROM_NB_BOOT_CTRIM_SPARE3   = 0x9
;           change calibration inbound delay values (DQS = 0, DATA = 1)
;
; rev1.04 - 
;    . Add support for MCP C03's different base address
;
; rev1.05 - 
;    . update Micron FBIO_DLY and ADDRESS_DRIVE settings during init and
;        in the calibration table.
;    . PBUS_DEBUG_CTRIM_2 is now different between Samsung/Micron.
;
; rev1.06 - 
;    . Changed pre-calibration defaults for Samsung memory.
;    . FBIO_DLY default was 012121212 is now 009090909
;    . CLKDRV/CLKSLW value is now 0FFFFFFFF
;

;
dd 00000106h        ; bits 31:8 = major rev, 7:0 = minor rev

;
; SB data for MCPX on the DVT boards (starts at offset 0x70)
;

; MCP_ROM_BOOT_FREQ_STRAP                 (28*32+3):(28*32+0) /* R--VF */
; MCP_ROM_BOOT_FREQ_STRAP_SAFE                     0x0000000f /* R---V */
;
;dd 00000000h
dd 0Fh

; MCP_ROM_BOOT_PIC_DIS                    (29*32+0):(29*32+0) /* RWIVF */
; MCP_ROM_BOOT_PIT_DIS                    (29*32+1):(29*32+1) /* RW-VF */
; MCP_ROM_BOOT_DMA_DIS                    (29*32+2):(29*32+2) /* RW-VF */
; MCP_ROM_BOOT_P92_DIS                    (29*32+3):(29*32+3) /* RW-VF */
; MCP_ROM_BOOT_FERR_DIS                   (29*32+4):(29*32+4) /* RW-VF */
; MCP_ROM_BOOT_RTC_NMI_DIS                (29*32+5):(29*32+5) /* RW-VF */
; MCP_ROM_BOOT_USB0_DIS                   (29*32+8):(29*32+8) /* RW-VF */
; MCP_ROM_BOOT_USB1_DIS                   (29*32+9):(29*32+9) /* RW-VF */
; MCP_ROM_BOOT_MAC0_DIS                 (29*32+10):(29*32+10) /* RW-VF */
; MCP_ROM_BOOT_MAC1_DIS                 (29*32+11):(29*32+11) /* RW-VF */
; MCP_ROM_BOOT_ACI_DIS                  (29*32+12):(29*32+12) /* RW-VF */
; MCP_ROM_BOOT_MCI_DIS                  (29*32+13):(29*32+13) /* RW-VF */
; MCP_ROM_BOOT_IDE_DIS                  (29*32+14):(29*32+14) /* RW-VF */
; MCP_ROM_BOOT_P2P_DIS                  (29*32+15):(29*32+15) /* RW-VF */
; MCP_ROM_BOOT_SMB_DIS                  (29*32+16):(29*32+16) /* RW-VF */
; MCP_ROM_BOOT_FST_RST                  (29*32+24):(29*32+24) /* R--VF */
; MCP_ROM_BOOT_FST_RST_NO                          0x00000000 /* R---V */
; MCP_ROM_BOOT_REBOOT                   (29*32+25):(29*32+25) /* RW-VF */
; MCP_ROM_BOOT_REBOOT_NO                           0x00000000 /* RW--V */
; MCP_ROM_BOOT_LDT_FRQ                  (29*32+26):(29*32+26) /* RW-VF */
; MCP_ROM_BOOT_LDT_FRQ_400MHz                      0x00000000 /* RW--V */
; MCP_ROM_BOOT_LDT_FRQ_200MHz                      0x00000001 /* RW--V */
; MCP_ROM_BOOT_PROC                     (29*32+27):(29*32+27) /* RW-VF */
; MCP_ROM_BOOT_PROC_INTEL                          0x00000000 /* RWI-V */
; MCP_ROM_BOOT_APU_TYP                  (29*32+28):(29*32+28) /* RW-VF */
; MCP_ROM_BOOT_APU_TYP_256V                        0x00000000 /* RW--V */
; MCP_ROM_BOOT_IDE_SEC                  (29*32+29):(29*32+29) /* RW-VF */
; MCP_ROM_BOOT_IDE_SEC_IDE                         0x00000000 /* RWI-V */
; MCP_ROM_BOOT_XBOX_ROM_SPEED           (29*32+30):(29*32+30) /* RWIVF */
; MCP_ROM_BOOT_XBOX_ROM_SPEED_SLOW                 0x00000000 /* RWI-V */
; MCP_ROM_BOOT_XBOX_ROM_SPEED_FAST                 0x00000001 /* RW--V */
;
IFDEF SYS_RETAIL
dd 40004400h
ELSE
dd 40000000h
ENDIF
;
; Init table identifier number 
;
IFDEF SYS_DVT4
dd 000000046h            
ELSE
IFDEF SYS_QT
dd 000000070h
ELSE
dd 000000060h
ENDIF
ENDIF
;
; offset from ROM base to the datatbl
;
; IMPORTANT: If size of the init table code below changes, this offset must be adjusted
;
dd DATATBL_BASE_OFFSET   

;
; Force 128 byte alignment MCPX in XBox mode.
;
org 0080h

;//////////////////////////////////////////
;
; NV2A init sequence.
;
;//////////////////////////////////////////

IFDEF SYS_RETAIL
nv_command_struct <COMMAND_UNUSED1, 000081000h, 001h>   
nv_command_struct <COMMAND_UNUSED2, 0000114h, 0228h>   
ENDIF

        
;
; Setup the IO BAR in MCP.  MCP_LEG_CFG_4 below evaluates to different
; values based on MCP rev we are building for. 
;
nv_command_struct<COMMAND_PCI_CFG_WRITE, MCP_LEG_CFG_4, 8001h>  

;
; Enable the IO space
;
nv_command_struct <COMMAND_PCI_CFG_WRITE, MCP_LEG_CFG_1, 3h>          

;
; Disable the TCO timer
;
nv_command_struct <COMMAND_OUT_BYTE,      08049h,     8h> 

;
; Also, the KBDRSTIN# signal should've been pulled low on XBox. It wasn't and
; was left floating. As a workaround, will change the mode to be a GPIO.
;
nv_command_struct <COMMAND_OUT_BYTE,      080D9h,     0h>       ; KBDRSTIN# in GPIO mode
nv_command_struct <COMMAND_OUT_BYTE,      08026h,     1h>       ; disable PWRBTN# in PM26

;
; First, we have to gain access to the integrated NV20. This involves
; enabling intergrated graphics and setting up the NB P2P to configure
; Bus2.
;
nv_command_struct <COMMAND_PCI_CFG_WRITE, CR_APC_P2P_19, CR_APC_P2P_19_NV20_ENABLE>    ; internal graphics enabled
nv_command_struct <COMMAND_PCI_CFG_WRITE, CR_APC_P2P_6,  CR_APC_P2P_6_SUB_SEC_PRI_BUS> ; setup secondary bus 1

;
; Now, config cycles to graphics should work. Setup the memory base/limit
; on the P2P and the BAR0 of the integrated graphics, so we can access priv
; regs. Enable BUS_MASTER and MEM/IO space accesses for NV20 and P2P.
;
; Note, because of a limitation in COMMAND_READ_MEM, we can't read from an
; address larger than 28bits, so we need to make our register base mapping
; under this (0x0D000000), but there's likely kernel code that assumes we're
; at 0xFD000000, so we'll reload to this address at the end of the inittbl.
;
nv_command_struct <COMMAND_PCI_CFG_WRITE, CR_CPU_MEMTOP, CR_CPU_MEMTOP_LIMIT_128MB>    ; for proper P2P addr decode

nv_command_struct <COMMAND_PCI_CFG_WRITE, CR_APC_P2P_8,  CR_APC_P2P_8_MLIMIT_MBASE_INIT>
nv_command_struct <COMMAND_PCI_CFG_WRITE, CR_APC_P2P_9,  CR_APC_P2P_9_PREF_MLIMIT_MBASE>
nv_command_struct <COMMAND_PCI_CFG_WRITE, CR_NV20_PCI_4, NV20_REG_BASE>    ; set register BAR0
nv_command_struct <COMMAND_PCI_CFG_WRITE, CR_NV20_PCI_5, NV20_FB_BASE>     ; set framebuffer BAR1
nv_command_struct <COMMAND_PCI_CFG_WRITE, CR_NV20_PCI_1, CR_NV20_PCI_1_BUS_MSTR_MEM_IO>
nv_command_struct <COMMAND_PCI_CFG_WRITE, CR_APC_P2P_1,  CR_APC_P2P_1_BUS_MSTR_MEM_IO>  ; enable spaces

;
; Also, setup the PBUS_DEBUG_CTRIM values
;
nv_command_struct<COMMAND_READ_MEM, (NV20_REG_BASE + NV_PMC_BOOT_0), DONT_CARE>
nv_command_struct<COMMAND_RMW_RESULT, 0000000FFh, 000000000h>
nv_command_struct<COMMAND_COMPARE_RESULT_JNE, 0A1h, (pbus_ctrim_A2-$-4)>    ; (rev >= A2)
;
pbus_ctrim_A1:
nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PBUS_DEBUG_CTRIM_0),    007633451h>
nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PBUS_DEBUG_CTRIM_6),    000000000h>
nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PBUS_DEBUG_CTRIM_2),    0FFFF0000h>
nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PBUS_DEBUG_CTRIM_7),    000000005h>
nv_command_struct<COMMAND_JMP, DONT_CARE, (pbus_ctrim_common-$-4)>

pbus_ctrim_A2:
nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PBUS_DEBUG_CTRIM_0),    007633461h>
nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PBUS_DEBUG_CTRIM_6),    066660000h>

IFDEF SYS_DVT6
;
; PBUS_DEBUG_CTRIM_2 is different between Samsung/Micron
;
nv_command_struct<COMMAND_READ_MEM, (NV20_REG_BASE + NV_PEXTDEV_BOOT_0), DONT_CARE>
nv_command_struct<COMMAND_RMW_RESULT, 0000C0000h, 000000000h>
nv_command_struct<COMMAND_COMPARE_RESULT_JNE, 0h, (samsung_ctrim2-$-4)> 

micron_ctrim2:
nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PBUS_DEBUG_CTRIM_2),    0EEEE0000h>
nv_command_struct<COMMAND_JMP, DONT_CARE, (ctrim_continue-$-4)>

samsung_ctrim2:
nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PBUS_DEBUG_CTRIM_2),    0FFFF0000h>

ctrim_continue:
ELSE
nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PBUS_DEBUG_CTRIM_2),    000000000h>
ENDIF
nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PBUS_DEBUG_CTRIM_7),    000000009h>

pbus_ctrim_common:
nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PBUS_DEBUG_CTRIM_1),    000000000h>
nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PBUS_DEBUG_CTRIM_3),    000005866h>
nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PBUS_DEBUG_CTRIM_4),    00351C858h>
nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PBUS_DEBUG_CTRIM_5),    030007D67h>
nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PBUS_DEBUG_CTRIM_8),    000000000h>
nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PBUS_DEBUG_CTRIM_9),    0A0423635h>
nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PBUS_DEBUG_CTRIM_10),   00C6558C6h>

;
; Before we do MRS_EXT/EMRS_EXT cycles, make sure we've enabled the external bank
;
nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PFB_CFG0),              003070103h>

;
; Setup WBC High water mark 
; The NV_PFB_WBC_HWM field should always be set no greater than 0x17
;
nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PFB_WBC),               011000016h>

;
; FB Arbitration settings 
;
nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PFB_ARB_XFER_SZ),       084848888h>
nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PFB_ARB_TIMEOUT),       0FFFFCFFFh>
nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PFB_ARB_PREDIVIDER),    01h>
nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PFB_ARB_DIFF_BANK),     0DFh>


;
; Update PEXTDEV_BOOT_0 (if A01)
;
;    0x80354C01 = turn on the override, disables AGP SBA/FW
;    0x803D4C01 = also sets EMRS_MATCHED
;    0x803D4C01 = no fast writes
;
nv_command_struct<COMMAND_READ_MEM, (NV20_REG_BASE + NV_PMC_BOOT_0), DONT_CARE>
nv_command_struct<COMMAND_RMW_RESULT, 0000000FFh, 000000000h>
nv_command_struct<COMMAND_COMPARE_RESULT_JNE, 0A1h, (skip_strap_override-$-4)>    ; (rev >= A2)

nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PEXTDEV_BOOT_0),        0803D4401h>
skip_strap_override:

;
; Setup the SMBus for talking to the encoder.
;
; On the DVT boards controller 0 isn't used, so only setup controller 1. Besides
; enabling IO's, we'll also convert the pins from GPIOs to SMBus clk/data. This
; need to be done early during boot, so there's a pixclk before setting NVCLK.
;
nv_command_struct <COMMAND_PCI_CFG_WRITE, MCP_SMB_CFG_1,     MCP_SMB_CFG_1_IO_SPACE>
nv_command_struct <COMMAND_PCI_CFG_WRITE, MCP_SMB_CFG_5,     MCP_SMB_CFG_5_IO_BASE>
nv_command_struct <COMMAND_PCI_CFG_WRITE, MCP_SMB_CFG_6,     MCP_SMB_CFG_6_IO_BASE>
nv_command_struct <COMMAND_OUT_BYTE,      SMB_DDC_SPIO_BASE, 70h>    ; converts from GPIO

IFNDEF FOCUS                                                                          
;
; Now, make sure the TV encoder is driving a pixclk.
;
nv_command_struct <COMMAND_OUT_BYTE, SMB_CONTROL_BASE+4, 08Ah>    ; CX871 slave addr

; CX871 offset 0xBA = 0x3F
nv_command_struct <COMMAND_OUT_BYTE, SMB_CONTROL_BASE+8, 0BAh>
nv_command_struct <COMMAND_OUT_BYTE, SMB_CONTROL_BASE+6, 03Fh>    ; turn on slave bit
nv_command_struct <COMMAND_OUT_BYTE, SMB_CONTROL_BASE+2, 00Ah>    ; kickoff

nv_command_struct <COMMAND_IN_BYTE,  SMB_CONTROL_BASE, DONT_CARE> ; read back status
nv_command_struct <COMMAND_COMPARE_RESULT_JNE, 010h,     -18>     ; spin if not idle
nv_command_struct <COMMAND_OUT_BYTE, SMB_CONTROL_BASE, 010h>      ; clear status

; CX871 offset 0x6C = 0x46
nv_command_struct <COMMAND_OUT_BYTE, SMB_CONTROL_BASE+8, 06Ch>
nv_command_struct <COMMAND_OUT_BYTE, SMB_CONTROL_BASE+6, 046h>
nv_command_struct <COMMAND_OUT_BYTE, SMB_CONTROL_BASE+2, 00Ah>    ; write byte kickoff

nv_command_struct <COMMAND_IN_BYTE,  SMB_CONTROL_BASE, DONT_CARE> ; read back status
nv_command_struct <COMMAND_COMPARE_RESULT_JNE, 010h,     -18>     ; spin if not idle
nv_command_struct <COMMAND_OUT_BYTE, SMB_CONTROL_BASE, 010h>      ; clear status

; CX871 offset 0xB8 = 0x0
nv_command_struct <COMMAND_OUT_BYTE, SMB_CONTROL_BASE+8, 0B8h>
nv_command_struct <COMMAND_OUT_BYTE, SMB_CONTROL_BASE+6, 000h>    ; autoconfig
nv_command_struct <COMMAND_OUT_BYTE, SMB_CONTROL_BASE+2, 00Ah>    ; kickoff

nv_command_struct <COMMAND_IN_BYTE,  SMB_CONTROL_BASE, DONT_CARE> ; read back status
nv_command_struct <COMMAND_COMPARE_RESULT_JNE, 010h,     -18>     ; spin if not idle
nv_command_struct <COMMAND_OUT_BYTE, SMB_CONTROL_BASE, 010h>      ; clear status

; CX871 offset 0xCE = 0x19
nv_command_struct <COMMAND_OUT_BYTE, SMB_CONTROL_BASE+8, 0CEh>
nv_command_struct <COMMAND_OUT_BYTE, SMB_CONTROL_BASE+6, 019h>
nv_command_struct <COMMAND_OUT_BYTE, SMB_CONTROL_BASE+2, 00Ah>    ; kickoff

nv_command_struct <COMMAND_IN_BYTE,  SMB_CONTROL_BASE, DONT_CARE> ; read back status
nv_command_struct <COMMAND_COMPARE_RESULT_JNE, 010h,     -18>     ; spin if not idle
nv_command_struct <COMMAND_OUT_BYTE, SMB_CONTROL_BASE, 010h>      ; clear status

; CX871 offset 0xC6 = 0x9C
nv_command_struct <COMMAND_OUT_BYTE, SMB_CONTROL_BASE+8, 0C6h>
nv_command_struct <COMMAND_OUT_BYTE, SMB_CONTROL_BASE+6, 09Ch>
nv_command_struct <COMMAND_OUT_BYTE, SMB_CONTROL_BASE+2, 00Ah>    ; kickoff

nv_command_struct <COMMAND_IN_BYTE,  SMB_CONTROL_BASE, DONT_CARE> ; read back status
nv_command_struct <COMMAND_COMPARE_RESULT_JNE, 010h,     -18>     ; spin if not idle
nv_command_struct <COMMAND_OUT_BYTE, SMB_CONTROL_BASE, 010h>      ; clear status

; CX871 offset 0x32 = 0x08
nv_command_struct <COMMAND_OUT_BYTE, SMB_CONTROL_BASE+8, 032h>
nv_command_struct <COMMAND_OUT_BYTE, SMB_CONTROL_BASE+6, 008h>
nv_command_struct <COMMAND_OUT_BYTE, SMB_CONTROL_BASE+2, 00Ah>    ; kickoff

nv_command_struct <COMMAND_IN_BYTE,  SMB_CONTROL_BASE, DONT_CARE> ; read back status
nv_command_struct <COMMAND_COMPARE_RESULT_JNE, 010h,     -18>     ; spin if not idle
nv_command_struct <COMMAND_OUT_BYTE, SMB_CONTROL_BASE, 010h>      ; clear status

; CX871 offset 0xC4 = 0x01
nv_command_struct <COMMAND_OUT_BYTE, SMB_CONTROL_BASE+8, 0C4h>
nv_command_struct <COMMAND_OUT_BYTE, SMB_CONTROL_BASE+6, 001h>    ; enable clk output
nv_command_struct <COMMAND_OUT_BYTE, SMB_CONTROL_BASE+2, 00Ah>    ; kickoff

nv_command_struct <COMMAND_IN_BYTE,  SMB_CONTROL_BASE, DONT_CARE> ; read back status
nv_command_struct <COMMAND_COMPARE_RESULT_JNE, 010h,     -18>     ; spin if not idle
nv_command_struct <COMMAND_OUT_BYTE, SMB_CONTROL_BASE, 010h>      ; clear status

ENDIF


IFDEF SYS_RETAIL
;
; Verify SMC revision
;
nv_command_struct<COMMAND_OUT_BYTE, SMB_CONTROL_BASE+4, 020h>     ; SMC slave write addr
nv_command_struct<COMMAND_OUT_BYTE, SMB_CONTROL_BASE+8, 001h>     ; SMC revision register
nv_command_struct<COMMAND_OUT_BYTE, SMB_CONTROL_BASE+6, 000h>     ; Clear SMC rev pointer
nv_command_struct<COMMAND_OUT_BYTE, SMB_CONTROL_BASE+2, 00Ah>     ; kickoff
nv_command_struct<COMMAND_IN_BYTE,  SMB_CONTROL_BASE, DONT_CARE>  ; read back status
nv_command_struct<COMMAND_COMPARE_RESULT_JNE, 010h,     -18>      ; spin if not idle
nv_command_struct<COMMAND_OUT_BYTE, SMB_CONTROL_BASE, 010h>       ; clear status

nv_command_struct <COMMAND_OUT_BYTE, SMB_CONTROL_BASE+4, 021h>    ; SMC slave read addr
nv_command_struct <COMMAND_OUT_BYTE, SMB_CONTROL_BASE+8, 001h>    ; read revision register
nv_command_struct <COMMAND_OUT_BYTE, SMB_CONTROL_BASE+2, 00Ah>    ; kickoff
nv_command_struct <COMMAND_IN_BYTE,  SMB_CONTROL_BASE, DONT_CARE> ; read back status
nv_command_struct <COMMAND_COMPARE_RESULT_JNE, 010h,     -18>     ; spin if not idle
nv_command_struct <COMMAND_OUT_BYTE, SMB_CONTROL_BASE, 010h>      ; clear status
nv_command_struct <COMMAND_IN_BYTE, SMB_CONTROL_BASE+6, DONT_CARE>   ; get the result

nv_command_struct <COMMAND_COMPARE_RESULT_JNE, DESIRED_SMC_VER, (SmcIsWrong-$-4)> ; if smc is bad
nv_command_struct<COMMAND_JMP, DONT_CARE, (SmcIsOK-$-4)>          ; smc is fine

SmcIsWrong:
;
; SMC is bad, flatline the clocks
;
nv_command_struct <COMMAND_PCI_CFG_WRITE, CR_CPU_MPLL_COEFF, 001000000h>  

SmcIsOK:

ENDIF

;
; Set NVCLK (M, N, P may need adjusting if integrated NV20 VCOs are different)
;    0x0001ED08 = 200MHz
;    0x00011701 = 155MHz    (rev == 0xA01)
;    0x00011C01 = 189MHz
;    0x00011E01 = 202.5MHz   (rev >= 0xA02)
;    0x00011F01 = 209.25MHz  (rev >= 0xA02)
;    0x00014502 = 229.5MHz   (rev >= 0xA02 and 1.7V w/ fansink DVT3)
;
;nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PRAMDAC_NVPLL_COEFF),      00001ED08h>
;
nv_command_struct<COMMAND_READ_MEM, (NV20_REG_BASE + NV_PMC_BOOT_0), DONT_CARE>
nv_command_struct<COMMAND_RMW_RESULT, 0000000FFh, 000000000h>
nv_command_struct<COMMAND_COMPARE_RESULT_JNE, 0A1h, (nvclk_200-$-4)>    ; (rev >= A2)

nvclk_155:
nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PRAMDAC_NVPLL_COEFF),      000011701h>
nv_command_struct<COMMAND_JMP, DONT_CARE, (pll_select-$-4)>

nvclk_200:

nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PRAMDAC_NVPLL_COEFF),      000011C01h>

pll_select:
nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PRAMDAC_PLL_COEFF_SELECT), 0000A0400h>

;
; Disable FBIO/TVD calibration
;
nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PBUS_FBIO_CALEN),  NV_PBUS_FBIO_CALEN_OFF>
nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PBUS_FBIO_CALSEL), NV_PBUS_FBIO_CALSEL_VALUE>
nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PBUS_TVDIO_CALEN), NV_PBUS_TVDIO_CALEN_OFF>

;
; Set the ADR_EDGE_HALF bit in FBIO_CFG
;
nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PBUS_FBIO_CFG), 000000010h>

;
; DRAM configuration
;
; Determine Samsung vs Micron by checking NV_PEXTDEV_BOOT_0_STRAP_EMRS (19:18)
; 0=Micron, 3=Samsung
;
nv_command_struct<COMMAND_READ_MEM, (NV20_REG_BASE + NV_PEXTDEV_BOOT_0), DONT_CARE>
nv_command_struct<COMMAND_RMW_RESULT, 0000C0000h, 000000000h>
nv_command_struct<COMMAND_COMPARE_RESULT_JNE, 0h, (samsung_memory-$-4)> 

;
; Configure for Micron
;
nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PBUS_FBIO_DLY),    028282828h>
nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PBUS_FBIO_ADRDRV), 088888888h>
nv_command_struct<COMMAND_JMP, DONT_CARE, (memory_pad_config-$-4)>

samsung_memory:
;
; Configure for Samsung
;
nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PBUS_FBIO_DLY),    009090909h>
nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PBUS_FBIO_ADRDRV), 0AAAAAAAAh> 

memory_pad_config:

;
; Memory PAD configuration
;
nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PBUS_FBIO_CLKDRV), 0FFFFFFFFh>
nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PBUS_FBIO_DATDRV), NV_PBUS_FBIO_DATDRV_INIT>
nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PBUS_FBIO_DQSDRV), NV_PBUS_FBIO_DQSDRV_INIT>
nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PBUS_FBIO_ADRSLW), NV_PBUS_FBIO_ADRSLW_INIT>
nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PBUS_FBIO_CLKSLW), 0FFFFFFFFh>
nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PBUS_FBIO_DATSLW), NV_PBUS_FBIO_DATSLW_INIT>
nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PBUS_FBIO_DQSSLW), NV_PBUS_FBIO_DQSSLW_INIT>

;
; RAM Initialization (XXX should we be waiting for cmds to complete?)
;
nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PFB_PRE),      NV_PFB_PRE_CMD_PRECHARGE_1>
nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PFB_EMRS),     000100042h>
nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PFB_EMRS_EXT), 000100042h>
nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PFB_MRS),      000000011h>
nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PFB_MRS_EXT),  000000011h>
nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PFB_MRS),      000000032h>
nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PFB_MRS_EXT),  000000032h>
nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PFB_MRS),      NV_PFB_MRS_DLL_RESET>
nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PFB_MRS_EXT),  NV_PFB_MRS_EXT_DLL_RESET>
nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PFB_REF),      000000001h>
nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PFB_REF),      000000001h>
nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PFB_REFCTRL),  NV_PFB_REFCTRL_VALID_1>

;
; Display PAD configuration
;
nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PBUS_DISPIO_PADCTL), NV_PBUS_DISPIO_PADCTL_INIT>

;
; TVD PAD configuration
;
nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PBUS_TVDIO_PADCTL), NV_PBUS_TVDIO_PADCTL_INIT>

;
; Change PFB_TIMING2 and PBUS_FBIO_RAM
;
; NV_PFB_TIMING2 = 0x081202FF
;                = 0x081205FF    (increase REFRESH count with M=1, N=9, MEMPDIV=2)
;
nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PFB_TIMING2),   0081205FFh>
nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PBUS_FBIO_RAM), 000010000h>

;
; Tell MCP not to generate INIT# in response to the shutdown cycle 
;
nv_command_struct<COMMAND_PCI_CFG_READ, MCP_LEG_CFG_24, DONT_CARE>
nv_command_struct<COMMAND_RMW_RESULT, 0FFFFFFFFh, 000000400h>
nv_command_struct<COMMAND_USE_RESULT_AS_DATA, COMMAND_PCI_CFG_WRITE, MCP_LEG_CFG_24>

;
; Init ISO/non-ISO bits for the various MCP unit IDs
;
nv_command_struct <COMMAND_PCI_CFG_WRITE, MCP_LEG_CFG_19, 00000FDDEh>

;
; Make sure the USB PLL has the correct value (not the POR value).
;
; nv_command_struct <COMMAND_PCI_CFG_WRITE, MCP_LEG_CFG_39, 0851CAA0Ch>
nv_command_struct <COMMAND_PCI_CFG_WRITE, MCP_LEG_CFG_39, 0871CC707h>

;
; Set the maximum PCICLK_OUT5 trim (bits 11:8 = 0xF).
;
nv_command_struct<COMMAND_PCI_CFG_READ, MCP_LEG_CFG_45, DONT_CARE>
nv_command_struct<COMMAND_RMW_RESULT,   0FFFFF0FFh, 000000F00h>
nv_command_struct<COMMAND_USE_RESULT_AS_DATA, COMMAND_PCI_CFG_WRITE, MCP_LEG_CFG_45>

;
; Set cshape/ctrim for clocks in CR_top.
;
nv_command_struct <COMMAND_PCI_CFG_WRITE, CR_CPU_CST_0, 0F0F0C0C0h>    ; A03
nv_command_struct <COMMAND_PCI_CFG_WRITE, CR_CPU_CST_1, 000C00000h>
nv_command_struct <COMMAND_PCI_CFG_WRITE, CR_CPU_CST_7, 004070000h>

;
; These values have been set by the straps, but we'll write them into the
; CR_CPU_MPLL_COEFF register, so the values are knowable outside the ROM.
;
; Currently, we have MEM_PDIV of 3, which is 133MHz and will be left that
; way for A01. For A02, we set the MEM_PDIV to 2, which sets a 200MHz mclk.
;
;    (0x230901: MEM_PDIV = 2, FSB_PDIV = 3; NDIV = 9;  MDIV = 1)
;    (0x230A01: MEM_PDIV = 2, FSB_PDIV = 3; NDIV = A;  MDIV = 1)
;    (0x231D03: MEM_PDIV = 2, FSB_PDIV = 3; NDIV = 1D; MDIV = 3)
;
; nv_command_struct <COMMAND_PCI_CFG_WRITE, CR_CPU_MPLL_COEFF, 000230901h>
; nv_command_struct <COMMAND_PCI_CFG_WRITE, CR_CPU_MPLL_COEFF, 000230901h>    ; 182MHz
; nv_command_struct <COMMAND_PCI_CFG_WRITE, CR_CPU_MPLL_COEFF, 000231D03h>    ; 200MHz
; nv_command_struct <COMMAND_PCI_CFG_WRITE, CR_CPU_MPLL_COEFF, 000230A01h>    ; 202MHz
;
nv_command_struct<COMMAND_READ_MEM, (NV20_REG_BASE + NV_PMC_BOOT_0), DONT_CARE>
nv_command_struct<COMMAND_RMW_RESULT, 0000000FFh, 000000000h>
nv_command_struct<COMMAND_COMPARE_RESULT_JNE, 0A1h, (mclk_200-$-4)>    ; (rev >= A2)
nv_command_struct<COMMAND_JMP, DONT_CARE, (mclk_133-$-4)>              ; (rev == A1)

mclk_133:
mclk_200:
;
; Set the clocks and override. CR_CPU_MPLL_COEFF must be set once without override
; and then again with override. 
;
nv_command_struct <COMMAND_PCI_CFG_WRITE, CR_CPU_MPLL_COEFF, 000230801h>
nv_command_struct <COMMAND_PCI_CFG_WRITE, CR_CPU_MPLL_COEFF, 001230801h>  

;
; Delay ~15 nano seconds by performing jmps
; 
nv_command_struct< COMMAND_JMP, DONT_CARE, (DelayJump1-$-4) >
DelayJump1:
nv_command_struct< COMMAND_JMP, DONT_CARE, (DelayJump2-$-4) >
DelayJump2:

; MEMORY TEST
; 
; This section does memory detection and test, and then updates
; the memory config registers and reports this config (and memory errors) back
; to the SMC.
;
; First, this is how the addressing works, with 12 row bits and an
; external bank:
;
;    E[0:0],R[11:10] | R[9:6] | R[5:2] | R[1:0],B[1:0] | C[7:4] | C[3:2],P[1:0] | C[1:0],00
;
; We determine a particular DRAMs number of row bits (11 or 12) by toggling
; the R11 bit and looking for an alias within the DRAM (row address bit doesn't
; exist with the 2Mx32 parts).
;
; For row detection with the first 4 DRAM partitions (MEM_PART_0 -> MEM_PART_3),
; we'll address at 0x2500000 (R11 = 1, ext_bank = 0) and cycle the partition bits.
; For the second set of DRAMS (MEM_PART_4 -> MEM_PART_7), we'll address at
; 0x6500000 (R11 = 1, ext_bank = 1).
;
; In addition to row detection, we'll update the SMC controller with the number
; of 2Mx32 and 4Mx32 DRAMS and any memory errors we've found. We use the 2 USB
; registers as scratchpad (reset to 0 and later overwritten by the kernel).
;
;    rows = 2^12, cols = 2^8, banks = 2^2, external bank
;


nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PFB_CFG0),  003070103h>
nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PFB_CFG1),  011448000h>

;
; Clear the scratchpad registers used in memory test
;
nv_command_struct<COMMAND_PCI_CFG_WRITE, MEMTEST_TYPE, 0>
nv_command_struct<COMMAND_PCI_CFG_WRITE, MEMTEST_RESULT, 0>

;-------------------------------------------------------------------------------
dram0:
nv_command_struct<COMMAND_WRITE_MEM, (MEM_PART_0 + 000555548h), MEMTEST_PATTERN1>
nv_command_struct<COMMAND_WRITE_MEM, (MEM_PART_0 + 002555548h), MEMTEST_PATTERN2>

; does the DRAM exist?
nv_command_struct<COMMAND_READ_MEM,  (MEM_PART_0 + 002555548h), DONT_CARE>
nv_command_struct<COMMAND_COMPARE_RESULT_JNE, MEMTEST_PATTERN2, (dram0_err-$-4)>

; did we alias in the DRAM?
nv_command_struct<COMMAND_READ_MEM,  (MEM_PART_0 + 000555548h), DONT_CARE>
nv_command_struct<COMMAND_COMPARE_RESULT_JNE, MEMTEST_PATTERN1, (dram0_alt_write-$-4)>

dram0_4mb:
nv_command_struct<COMMAND_PCI_CFG_READ, MEMTEST_TYPE, DONT_CARE>
nv_command_struct<COMMAND_RMW_RESULT,   0FFFFFFFFh, 000000001h>
nv_command_struct<COMMAND_USE_RESULT_AS_DATA, COMMAND_PCI_CFG_WRITE, MEMTEST_TYPE>

dram0_alt_write:
nv_command_struct<COMMAND_WRITE_MEM, (MEM_PART_0 + 000555548h), MEMTEST_PATTERN3>
nv_command_struct<COMMAND_READ_MEM,  (MEM_PART_0 + 000555548h), DONT_CARE>
nv_command_struct<COMMAND_COMPARE_RESULT_JNE, MEMTEST_PATTERN3, (dram0_err-$-4)>
nv_command_struct<COMMAND_JMP, DONT_CARE, (dram1-$-4)>

dram0_err:
nv_command_struct<COMMAND_PCI_CFG_READ, MEMTEST_RESULT, DONT_CARE>
nv_command_struct<COMMAND_RMW_RESULT,   0FFFFFFFFh, 000000001h>
nv_command_struct<COMMAND_USE_RESULT_AS_DATA, COMMAND_PCI_CFG_WRITE, MEMTEST_RESULT>


;-------------------------------------------------------------------------------
dram1:
nv_command_struct<COMMAND_WRITE_MEM, (MEM_PART_1 + 000555548h), MEMTEST_PATTERN1>
nv_command_struct<COMMAND_WRITE_MEM, (MEM_PART_1 + 002555548h), MEMTEST_PATTERN2>

; does the DRAM exist?
nv_command_struct<COMMAND_READ_MEM,  (MEM_PART_1 + 002555548h), DONT_CARE>
nv_command_struct<COMMAND_COMPARE_RESULT_JNE, MEMTEST_PATTERN2, (dram1_err-$-4)>

; did we alias in the DRAM?
nv_command_struct<COMMAND_READ_MEM,  (MEM_PART_1 + 000555548h), DONT_CARE>
nv_command_struct<COMMAND_COMPARE_RESULT_JNE, MEMTEST_PATTERN1, (dram1_alt_write-$-4)>

dram1_4mb:
nv_command_struct<COMMAND_PCI_CFG_READ, MEMTEST_TYPE, DONT_CARE>
nv_command_struct<COMMAND_RMW_RESULT,   0FFFFFFFFh, 000000002h>
nv_command_struct<COMMAND_USE_RESULT_AS_DATA, COMMAND_PCI_CFG_WRITE, MEMTEST_TYPE>

dram1_alt_write:
nv_command_struct<COMMAND_WRITE_MEM, (MEM_PART_1 + 000555548h), MEMTEST_PATTERN3>
nv_command_struct<COMMAND_READ_MEM,  (MEM_PART_1 + 000555548h), DONT_CARE>
nv_command_struct<COMMAND_COMPARE_RESULT_JNE, MEMTEST_PATTERN3, (dram1_err-$-4)>
nv_command_struct<COMMAND_JMP, DONT_CARE, (dram2-$-4)>

dram1_err:
nv_command_struct<COMMAND_PCI_CFG_READ, MEMTEST_RESULT, DONT_CARE>
nv_command_struct<COMMAND_RMW_RESULT,   0FFFFFFFFh, 000000002h>
nv_command_struct<COMMAND_USE_RESULT_AS_DATA, COMMAND_PCI_CFG_WRITE, MEMTEST_RESULT>


;-------------------------------------------------------------------------------
dram2:
nv_command_struct<COMMAND_WRITE_MEM, (MEM_PART_2 + 000555548h), MEMTEST_PATTERN1>
nv_command_struct<COMMAND_WRITE_MEM, (MEM_PART_2 + 002555548h), MEMTEST_PATTERN2>

; does the DRAM exist?
nv_command_struct<COMMAND_READ_MEM,  (MEM_PART_2 + 002555548h), DONT_CARE>
nv_command_struct<COMMAND_COMPARE_RESULT_JNE, MEMTEST_PATTERN2, (dram2_err-$-4)>

; did we alias in the DRAM?
nv_command_struct<COMMAND_READ_MEM,  (MEM_PART_2 + 000555548h), DONT_CARE>
nv_command_struct<COMMAND_COMPARE_RESULT_JNE, MEMTEST_PATTERN1, (dram2_alt_write-$-4)>

dram2_4mb:
nv_command_struct<COMMAND_PCI_CFG_READ, MEMTEST_TYPE, DONT_CARE>
nv_command_struct<COMMAND_RMW_RESULT,   0FFFFFFFFh, 000000004h>
nv_command_struct<COMMAND_USE_RESULT_AS_DATA, COMMAND_PCI_CFG_WRITE, MEMTEST_TYPE>

dram2_alt_write:
nv_command_struct<COMMAND_WRITE_MEM, (MEM_PART_2 + 000555548h), MEMTEST_PATTERN3>
nv_command_struct<COMMAND_READ_MEM,  (MEM_PART_2 + 000555548h), DONT_CARE>
nv_command_struct<COMMAND_COMPARE_RESULT_JNE, MEMTEST_PATTERN3, (dram2_err-$-4)>
nv_command_struct<COMMAND_JMP, DONT_CARE, (dram3-$-4)>

dram2_err:
nv_command_struct<COMMAND_PCI_CFG_READ, MEMTEST_RESULT, DONT_CARE>
nv_command_struct<COMMAND_RMW_RESULT,   0FFFFFFFFh, 000000004h>
nv_command_struct<COMMAND_USE_RESULT_AS_DATA, COMMAND_PCI_CFG_WRITE, MEMTEST_RESULT>


;-------------------------------------------------------------------------------
dram3:
nv_command_struct<COMMAND_WRITE_MEM, (MEM_PART_3 + 000555548h), MEMTEST_PATTERN1>
nv_command_struct<COMMAND_WRITE_MEM, (MEM_PART_3 + 002555548h), MEMTEST_PATTERN2>

; does the DRAM exist?
nv_command_struct<COMMAND_READ_MEM,  (MEM_PART_3 + 002555548h), DONT_CARE>
nv_command_struct<COMMAND_COMPARE_RESULT_JNE, MEMTEST_PATTERN2, (dram3_err-$-4)>

; did we alias in the DRAM?
nv_command_struct<COMMAND_READ_MEM,  (MEM_PART_3 + 000555548h), DONT_CARE>
nv_command_struct<COMMAND_COMPARE_RESULT_JNE, MEMTEST_PATTERN1, (dram3_alt_write-$-4)>

dram3_4mb:
nv_command_struct<COMMAND_PCI_CFG_READ, MEMTEST_TYPE, DONT_CARE>
nv_command_struct<COMMAND_RMW_RESULT,   0FFFFFFFFh, 000000008h>
nv_command_struct<COMMAND_USE_RESULT_AS_DATA, COMMAND_PCI_CFG_WRITE, MEMTEST_TYPE>

dram3_alt_write:
nv_command_struct<COMMAND_WRITE_MEM, (MEM_PART_3 + 000555548h), MEMTEST_PATTERN3>
nv_command_struct<COMMAND_READ_MEM,  (MEM_PART_3 + 000555548h), DONT_CARE>
nv_command_struct<COMMAND_COMPARE_RESULT_JNE, MEMTEST_PATTERN3, (dram3_err-$-4)>
nv_command_struct<COMMAND_JMP, DONT_CARE, (dram4-$-4)>

dram3_err:
nv_command_struct<COMMAND_PCI_CFG_READ, MEMTEST_RESULT, DONT_CARE>
nv_command_struct<COMMAND_RMW_RESULT,   0FFFFFFFFh, 000000008h>
nv_command_struct<COMMAND_USE_RESULT_AS_DATA, COMMAND_PCI_CFG_WRITE, MEMTEST_RESULT>


;-------------------------------------------------------------------------------
dram4:
nv_command_struct<COMMAND_WRITE_MEM, (MEM_PART_4 + 000555548h), MEMTEST_PATTERN1>
nv_command_struct<COMMAND_WRITE_MEM, (MEM_PART_4 + 002555548h), MEMTEST_PATTERN2>

; does the DRAM exist?
nv_command_struct<COMMAND_READ_MEM,  (MEM_PART_4 + 002555548h), DONT_CARE>
nv_command_struct<COMMAND_COMPARE_RESULT_JNE, MEMTEST_PATTERN2, (dram4_err-$-4)>

; did we alias in the DRAM?
nv_command_struct<COMMAND_READ_MEM,  (MEM_PART_4 + 000555548h), DONT_CARE>
nv_command_struct<COMMAND_COMPARE_RESULT_JNE, MEMTEST_PATTERN1, (dram4_alt_write-$-4)>

dram4_4mb:
nv_command_struct<COMMAND_PCI_CFG_READ, MEMTEST_TYPE, DONT_CARE>
nv_command_struct<COMMAND_RMW_RESULT,   0FFFFFFFFh, 000000010h>
nv_command_struct<COMMAND_USE_RESULT_AS_DATA, COMMAND_PCI_CFG_WRITE, MEMTEST_TYPE>

dram4_alt_write:
nv_command_struct<COMMAND_WRITE_MEM, (MEM_PART_4 + 000555548h), MEMTEST_PATTERN3>
nv_command_struct<COMMAND_READ_MEM,  (MEM_PART_4 + 000555548h), DONT_CARE>
nv_command_struct<COMMAND_COMPARE_RESULT_JNE, MEMTEST_PATTERN3, (dram4_err-$-4)>
nv_command_struct<COMMAND_JMP, DONT_CARE, (dram5-$-4)>

dram4_err:
nv_command_struct<COMMAND_PCI_CFG_READ, MEMTEST_RESULT, DONT_CARE>
nv_command_struct<COMMAND_RMW_RESULT,   0FFFFFFFFh, 000000010h>
nv_command_struct<COMMAND_USE_RESULT_AS_DATA, COMMAND_PCI_CFG_WRITE, MEMTEST_RESULT>


;-------------------------------------------------------------------------------
dram5:
nv_command_struct<COMMAND_WRITE_MEM, (MEM_PART_5 + 000555548h), MEMTEST_PATTERN1>
nv_command_struct<COMMAND_WRITE_MEM, (MEM_PART_5 + 002555548h), MEMTEST_PATTERN2>

; does the DRAM exist?
nv_command_struct<COMMAND_READ_MEM,  (MEM_PART_5 + 002555548h), DONT_CARE>
nv_command_struct<COMMAND_COMPARE_RESULT_JNE, MEMTEST_PATTERN2, (dram5_err-$-4)>

; did we alias in the DRAM?
nv_command_struct<COMMAND_READ_MEM,  (MEM_PART_5 + 000555548h), DONT_CARE>
nv_command_struct<COMMAND_COMPARE_RESULT_JNE, MEMTEST_PATTERN1, (dram5_alt_write-$-4)>

dram5_4mb:
nv_command_struct<COMMAND_PCI_CFG_READ, MEMTEST_TYPE, DONT_CARE>
nv_command_struct<COMMAND_RMW_RESULT,   0FFFFFFFFh, 000000020h>
nv_command_struct<COMMAND_USE_RESULT_AS_DATA, COMMAND_PCI_CFG_WRITE, MEMTEST_TYPE>

dram5_alt_write:
nv_command_struct<COMMAND_WRITE_MEM, (MEM_PART_5 + 000555548h), MEMTEST_PATTERN3>
nv_command_struct<COMMAND_READ_MEM,  (MEM_PART_5 + 000555548h), DONT_CARE>
nv_command_struct<COMMAND_COMPARE_RESULT_JNE, MEMTEST_PATTERN3, (dram5_err-$-4)>
nv_command_struct<COMMAND_JMP, DONT_CARE, (dram6-$-4)>

dram5_err:
nv_command_struct<COMMAND_PCI_CFG_READ, MEMTEST_RESULT, DONT_CARE>
nv_command_struct<COMMAND_RMW_RESULT,   0FFFFFFFFh, 000000020h>
nv_command_struct<COMMAND_USE_RESULT_AS_DATA, COMMAND_PCI_CFG_WRITE, MEMTEST_RESULT>


;-------------------------------------------------------------------------------
dram6:
nv_command_struct<COMMAND_WRITE_MEM, (MEM_PART_6 + 000555548h), MEMTEST_PATTERN1>
nv_command_struct<COMMAND_WRITE_MEM, (MEM_PART_6 + 002555548h), MEMTEST_PATTERN2>

; does the DRAM exist?
nv_command_struct<COMMAND_READ_MEM,  (MEM_PART_6 + 002555548h), DONT_CARE>
nv_command_struct<COMMAND_COMPARE_RESULT_JNE, MEMTEST_PATTERN2, (dram6_err-$-4)>

; did we alias in the DRAM?
nv_command_struct<COMMAND_READ_MEM,  (MEM_PART_6 + 000555548h), DONT_CARE>
nv_command_struct<COMMAND_COMPARE_RESULT_JNE, MEMTEST_PATTERN1, (dram6_alt_write-$-4)>

dram6_4mb:
nv_command_struct<COMMAND_PCI_CFG_READ, MEMTEST_TYPE, DONT_CARE>
nv_command_struct<COMMAND_RMW_RESULT,   0FFFFFFFFh, 000000040h>
nv_command_struct<COMMAND_USE_RESULT_AS_DATA, COMMAND_PCI_CFG_WRITE, MEMTEST_TYPE>

dram6_alt_write:
nv_command_struct<COMMAND_WRITE_MEM, (MEM_PART_6 + 000555548h), MEMTEST_PATTERN3>
nv_command_struct<COMMAND_READ_MEM,  (MEM_PART_6 + 000555548h), DONT_CARE>
nv_command_struct<COMMAND_COMPARE_RESULT_JNE, MEMTEST_PATTERN3, (dram6_err-$-4)>
nv_command_struct<COMMAND_JMP, DONT_CARE, (dram7-$-4)>

dram6_err:
nv_command_struct<COMMAND_PCI_CFG_READ, MEMTEST_RESULT, DONT_CARE>
nv_command_struct<COMMAND_RMW_RESULT,   0FFFFFFFFh, 000000040h>
nv_command_struct<COMMAND_USE_RESULT_AS_DATA, COMMAND_PCI_CFG_WRITE, MEMTEST_RESULT>


;-------------------------------------------------------------------------------
dram7:
nv_command_struct<COMMAND_WRITE_MEM, (MEM_PART_7 + 000555548h), MEMTEST_PATTERN1>
nv_command_struct<COMMAND_WRITE_MEM, (MEM_PART_7 + 002555548h), MEMTEST_PATTERN2>

; does the DRAM exist?
nv_command_struct<COMMAND_READ_MEM,  (MEM_PART_7 + 002555548h), DONT_CARE>
nv_command_struct<COMMAND_COMPARE_RESULT_JNE, MEMTEST_PATTERN2, (dram7_err-$-4)>

; did we alias in the DRAM?
nv_command_struct<COMMAND_READ_MEM,  (MEM_PART_7 + 000555548h), DONT_CARE>
nv_command_struct<COMMAND_COMPARE_RESULT_JNE, MEMTEST_PATTERN1, (dram7_alt_write-$-4)>

dram7_4mb:
nv_command_struct<COMMAND_PCI_CFG_READ, MEMTEST_TYPE, DONT_CARE>
nv_command_struct<COMMAND_RMW_RESULT,   0FFFFFFFFh, 000000080h>
nv_command_struct<COMMAND_USE_RESULT_AS_DATA, COMMAND_PCI_CFG_WRITE, MEMTEST_TYPE>

dram7_alt_write:
nv_command_struct<COMMAND_WRITE_MEM, (MEM_PART_7 + 000555548h), MEMTEST_PATTERN3>
nv_command_struct<COMMAND_READ_MEM,  (MEM_PART_7 + 000555548h), DONT_CARE>
nv_command_struct<COMMAND_COMPARE_RESULT_JNE, MEMTEST_PATTERN3, (dram7_err-$-4)>
nv_command_struct<COMMAND_JMP, DONT_CARE, (memtest_done-$-4)>

dram7_err:
nv_command_struct<COMMAND_PCI_CFG_READ, MEMTEST_RESULT, DONT_CARE>
nv_command_struct<COMMAND_RMW_RESULT,   0FFFFFFFFh, 000000080h>
nv_command_struct<COMMAND_USE_RESULT_AS_DATA, COMMAND_PCI_CFG_WRITE, MEMTEST_RESULT>


memtest_done:
;
; Start by assuming we're using a 4Mx32, 64MB config (no external bank).
; We've already set rows = 2^12, so clear the external bank bit.
;
nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PFB_CFG0),  003070003h>
nv_command_struct<COMMAND_PCI_CFG_WRITE, CR_CPU_MEMTOP, CR_CPU_MEMTOP_LIMIT_64MB>

;
; Read out our bitmask of 4Mx32 parts into the SMBus register and update our
; memory config, if necessary.
; 
nv_command_struct<COMMAND_PCI_CFG_READ, MEMTEST_TYPE, DONT_CARE>
nv_command_struct<COMMAND_RMW_RESULT,   0000000FFh, 000000000h>
nv_command_struct<COMMAND_USE_RESULT_AS_DATA, COMMAND_OUT_BYTE, SMB_CONTROL_BASE+6>

nv_command_struct<COMMAND_IN_BYTE,  SMB_CONTROL_BASE+6, DONT_CARE>
nv_command_struct<COMMAND_COMPARE_RESULT_JNE, 000000000h, (dram_4M-$-4)>

; Reset back to 11 row bits and add back the external bank bit
nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PFB_CFG0),  003070103h>    ; extbank bit
nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PFB_CFG1),  011338000h>    ; 11 row bits
nv_command_struct<COMMAND_JMP, DONT_CARE, (mem_report-$-4)>

dram_4M:
; We've got some 4Mx32 parts, check if we're a 128MB config?
nv_command_struct<COMMAND_IN_BYTE,  SMB_CONTROL_BASE+6, DONT_CARE>
nv_command_struct<COMMAND_COMPARE_RESULT_JNE, 0000000FFh, (mem_report-$-4)>

; Add back the external bank bit and update MEMTOP
nv_command_struct<COMMAND_WRITE_MEM, (NV20_REG_BASE + NV_PFB_CFG0),  003070103h>    ; extback bit
nv_command_struct<COMMAND_PCI_CFG_WRITE, CR_CPU_MEMTOP, CR_CPU_MEMTOP_LIMIT_128MB>


mem_report:

;
; Report the results to the SMC
;
nv_command_struct<COMMAND_OUT_BYTE, SMB_CONTROL_BASE+4, 020h>     ; SMC slave addr

;
; Send Memory Type (already in SMB_CONTROL_BASE+6) to SMC
;
nv_command_struct<COMMAND_OUT_BYTE, SMB_CONTROL_BASE+8, 013h>     ; SMC Register
nv_command_struct<COMMAND_OUT_BYTE, SMB_CONTROL_BASE+2, 00Ah>     ; kickoff

nv_command_struct<COMMAND_IN_BYTE,  SMB_CONTROL_BASE, DONT_CARE>  ; read back status
nv_command_struct<COMMAND_COMPARE_RESULT_JNE, 010h,     -18>      ; spin if not idle
nv_command_struct<COMMAND_OUT_BYTE, SMB_CONTROL_BASE, 010h>       ; clear status

;
; Send Memory test results to SMC
;
nv_command_struct<COMMAND_PCI_CFG_READ, MEMTEST_RESULT, DONT_CARE>
nv_command_struct<COMMAND_RMW_RESULT,   0000000FFh, 000000000h>
nv_command_struct<COMMAND_USE_RESULT_AS_DATA, COMMAND_OUT_BYTE, SMB_CONTROL_BASE+6>

nv_command_struct<COMMAND_OUT_BYTE, SMB_CONTROL_BASE+8, 012h>     ; SMC Register
nv_command_struct<COMMAND_OUT_BYTE, SMB_CONTROL_BASE+2, 00Ah>     ; kickoff

nv_command_struct<COMMAND_IN_BYTE,  SMB_CONTROL_BASE, DONT_CARE>  ; read back status
nv_command_struct<COMMAND_COMPARE_RESULT_JNE, 010h,     -18>      ; spin if not idle
nv_command_struct<COMMAND_OUT_BYTE, SMB_CONTROL_BASE, 010h>       ; clear status

mem_report_end:


;
; Reload the NV20 register base (should be just prior to COMMAND_QUIT)
; to what the kernel expects.
;
nv_command_struct <COMMAND_PCI_CFG_WRITE, CR_APC_P2P_8,  CR_APC_P2P_8_MLIMIT_MBASE_KERNEL>
nv_command_struct <COMMAND_PCI_CFG_WRITE, CR_NV20_PCI_4, NV20_REG_BASE_KERNEL>

; End of table.  First argument is used as the value for the default MTRR register
;
nv_command_struct <COMMAND_QUIT, 0806h, DONT_CARE>

;
; Drive/Slew Parameter Offset and Data.  Boot loader needs to access this data
; 

org DATATBL_BASE_OFFSET  

;DATATBL_DRVSLWPARAM_OFFSET   EQU DATATBL_BASE_OFFSET+0

;-----------------------------------------------------------------------------

DrvSlwParamBegin:
;
; Common calibration data
;
dw    20000    ; MaxMClk (230Mhz)
;
; Operating condition based on speedometer
;     (Count is from VCCQ; CountB is from VCC)
;

;
; 16.6 clock
;

db    4Eh      ; SlowCountExt
db    3Eh      ; SlowCountBExt

db    56h      ; SlowCountAvg
db    43h      ; SlowCountBAvg

db    5Dh      ; TypiCount
db    4Ah      ; TypiCountB

db    64h      ; FastCountAvg
db    50h      ; FastCountBAvg

db    6Ah      ; FastCountExt
db    55h      ; FastCountBExt

;-----------------------------------------------------------------------------
;
; Samsung Extreme FAST values 
;
db    09h      ; AdrDrvFallFastExt
db    09h      ; AdrDrvRiseFastExt
db    0Eh      ; AdrSlwFallFastExt
db    08h      ; AdrSlwRiseFastExt

db    0Fh      ; ClkDrvFallFastExt
db    0Fh      ; ClkDrvRiseFastExt
db    0Fh      ; ClkSlwFallFastExt
db    0Fh      ; ClkSlwRiseFastExt

db    09h      ; DatDrvFallFastExt
db    09h      ; DatDrvRiseFastExt
db    0Eh      ; DatSlwFallFastExt
db    08h      ; DatSlwRiseFastExt

db    09h      ; DqsDrvFallFastExt
db    09h      ; DqsDrvRiseFastExt
db    0Eh      ; DqsSlwFallFastExt
db    08h      ; DqsSlwRiseFastExt

IFDEF SYS_DVT6
db    01h      ; DataInbDelyFastExt
db    00h      ; ClkIcDelyFastExt
db    00h      ; DqsInbDelyFastExt
ELSE
db    00h      ; DataInbDelyFastExt
db    00h      ; ClkIcDelyFastExt
db    01h      ; DqsInbDelyFastExt
ENDIF
;
; Samsung Average FAST values
;
db    09h      ; AdrDrvFallFastAvg
db    09h      ; AdrDrvRiseFastAvg
db    0Eh      ; AdrSlwFallFastAvg
db    08h      ; AdrSlwRiseFastAvg

db    0Fh      ; ClkDrvFallFastAvg
db    0Fh      ; ClkDrvRiseFastAvg
db    0Fh      ; ClkSlwFallFastAvg
db    0Fh      ; ClkSlwRiseFastAvg

db    09h      ; DatDrvFallFastAvg
db    09h      ; DatDrvRiseFastAvg
db    0Eh      ; DatSlwFallFastAvg
db    08h      ; DatSlwRiseFastAvg

db    09h      ; DqsDrvFallFastAvg
db    09h      ; DqsDrvRiseFastAvg
db    0Eh      ; DqsSlwFallFastAvg
db    08h      ; DqsSlwRiseFastAvg

IFDEF SYS_DVT6
db    01h      ; DataInbDelyFastAvg
db    01h      ; ClkIcDelyFastAvg
db    00h      ; DqsInbDelyFastAvg 
ELSE
db    00h      ; DataInbDelyFastAvg
db    01h      ; ClkIcDelyFastAvg
db    01h      ; DqsInbDelyFastAvg 
ENDIF
;
; Samsung Typical values
;
db    09h      ; AdrDrvFallTypi
db    09h      ; AdrDrvRiseTypi
db    0Eh      ; AdrSlwFallTypi
db    08h      ; AdrSlwRiseTypi

db    0Fh      ; ClkDrvFallTypi
db    0Fh      ; ClkDrvRiseTypi
db    0Fh      ; ClkSlwFallTypi
db    0Fh      ; ClkSlwRiseTypi

db    09h      ; DatDrvFallTypi
db    09h      ; DatDrvRiseTypi
db    0Eh      ; DatSlwFallTypi
db    08h      ; DatSlwRiseTypi

db    09h      ; DqsDrvFallTypi
db    09h      ; DqsDrvRiseTypi
db    0Eh      ; DqsSlwFallTypi
db    08h      ; DqsSlwRiseTypi

IFDEF SYS_DVT6
db    01h      ; DataInbDelyTypi
db    02h      ; ClkIcDelyTypi
db    00h      ; DqsInbDelyTypi
ELSE
db    00h      ; DataInbDelyTypi
db    02h      ; ClkIcDelyTypi
db    01h      ; DqsInbDelyTypi
ENDIF
;
; Samsung Average SLOW values
;
db    0Ah      ; AdrDrvFallSlowAvg
db    0Bh      ; AdrDrvRiseSlowAvg
db    0Eh      ; AdrSlwFallSlowAvg
db    08h      ; AdrSlwRiseSlowAvg

db    0Fh      ; ClkDrvFallSlowAvg
db    0Fh      ; ClkDrvRiseSlowAvg
db    0Fh      ; ClkSlwFallSlowAvg
db    0Fh      ; ClkSlwRiseSlowAvg

db    0Ah      ; DatDrvFallSlowAvg
db    0Bh      ; DatDrvRiseSlowAvg
db    0Eh      ; DatSlwFallSlowAvg
db    08h      ; DatSlwRiseSlowAvg

db    0Ah      ; DqsDrvFallSlowAvg
db    0Bh      ; DqsDrvRiseSlowAvg
db    0Eh      ; DqsSlwFallSlowAvg
db    08h      ; DqsSlwRiseSlowAvg

IFDEF SYS_DVT6
db    01h      ; DataInbDelySlowAvg
db    02h      ; ClkIcDelySlowAvg
db    00h      ; DqsInbDelySlowAvg
ELSE
db    00h      ; DataInbDelySlowAvg
db    02h      ; ClkIcDelySlowAvg
db    01h      ; DqsInbDelySlowAvg
ENDIF
;
; Samsung Extreme SLOW values
;
db    0Bh      ; AdrDrvFallSlowExt
db    0Eh      ; AdrDrvRiseSlowExt
db    0Eh      ; AdrSlwFallSlowExt
db    08h      ; AdrSlwRiseSlowExt

db    0Fh      ; ClkDrvFallSlowExt
db    0Fh      ; ClkDrvRiseSlowExt
db    0Fh      ; ClkSlwFallSlowExt
db    0Fh      ; ClkSlwRiseSlowExt

db    0Bh      ; DatDrvFallSlowExt
db    0Eh      ; DatDrvRiseSlowExt
db    0Eh      ; DatSlwFallSlowExt
db    08h      ; DatSlwRiseSlowExt

db    0Bh      ; DqsDrvFallSlowExt
db    0Eh      ; DqsDrvRiseSlowExt
db    0Eh      ; DqsSlwFallSlowExt
db    08h      ; DqsSlwRiseSlowExt

IFDEF SYS_DVT6
db    01h      ; DataInbDelySlowExt
db    03h      ; ClkIcDelySlowExt
db    00h      ; DqsInbDelySlowExt
ELSE
db    00h      ; DataInbDelySlowExt
db    03h      ; ClkIcDelySlowExt
db    01h      ; DqsInbDelySlowExt
ENDIF
;-----------------------------------------------------------------------------
;
; Micron Extreme FAST values
;
db    08h      ; AdrDrvFallFastExt
db    08h      ; AdrDrvRiseFastExt
db    0Eh      ; AdrSlwFallFastExt
db    08h      ; AdrSlwRiseFastExt

db    0Fh      ; ClkDrvFallFastExt
db    0Fh      ; ClkDrvRiseFastExt
db    0Fh      ; ClkSlwFallFastExt
db    0Fh      ; ClkSlwRiseFastExt

db    09h      ; DatDrvFallFastExt
db    09h      ; DatDrvRiseFastExt
db    0Eh      ; DatSlwFallFastExt
db    08h      ; DatSlwRiseFastExt

db    09h      ; DqsDrvFallFastExt
db    09h      ; DqsDrvRiseFastExt
db    0Eh      ; DqsSlwFallFastExt
db    08h      ; DqsSlwRiseFastExt

db    00h      ; DataInbDelyFastExt
db    01h      ; ClkIcDelyFastExt
db    01h      ; DqsInbDelyFastExt
;
; Micron Average FAST values
;
db    08h      ; AdrDrvFallFastAvg
db    08h      ; AdrDrvRiseFastAvg
db    0Eh      ; AdrSlwFallFastAvg
db    08h      ; AdrSlwRiseFastAvg

db    0Fh      ; ClkDrvFallFastAvg
db    0Fh      ; ClkDrvRiseFastAvg
db    0Fh      ; ClkSlwFallFastAvg
db    0Fh      ; ClkSlwRiseFastAvg

db    09h      ; DatDrvFallFastAvg
db    09h      ; DatDrvRiseFastAvg
db    0Eh      ; DatSlwFallFastAvg
db    08h      ; DatSlwRiseFastAvg

db    09h      ; DqsDrvFallFastAvg
db    09h      ; DqsDrvRiseFastAvg
db    0Eh      ; DqsSlwFallFastAvg
db    08h      ; DqsSlwRiseFastAvg

db    00h      ; DataInbDelyFastAvg
db    01h      ; ClkIcDelyFastAvg
db    01h      ; DqsInbDelyFastAvg 
;
; Micron Typical values
;
db    08h      ; AdrDrvFallTypi
db    08h      ; AdrDrvRiseTypi
db    0Eh      ; AdrSlwFallTypi
db    08h      ; AdrSlwRiseTypi

db    0Fh      ; ClkDrvFallTypi
db    0Fh      ; ClkDrvRiseTypi
db    0Fh      ; ClkSlwFallTypi
db    0Fh      ; ClkSlwRiseTypi

db    09h      ; DatDrvFallTypi
db    09h      ; DatDrvRiseTypi
db    0Eh      ; DatSlwFallTypi
db    08h      ; DatSlwRiseTypi

db    09h      ; DqsDrvFallTypi
db    09h      ; DqsDrvRiseTypi
db    0Eh      ; DqsSlwFallTypi
db    08h      ; DqsSlwRiseTypi

db    00h      ; DataInbDelyTypi
db    01h      ; ClkIcDelyTypi
db    01h      ; DqsInbDelyTypi
;
; Micron Average SLOW values
;
db    08h      ; AdrDrvFallSlowAvg
db    08h      ; AdrDrvRiseSlowAvg
db    0Eh      ; AdrSlwFallSlowAvg
db    08h      ; AdrSlwRiseSlowAvg

db    0Fh      ; ClkDrvFallSlowAvg
db    0Fh      ; ClkDrvRiseSlowAvg
db    0Fh      ; ClkSlwFallSlowAvg
db    0Fh      ; ClkSlwRiseSlowAvg

db    0Ah      ; DatDrvFallSlowAvg
db    0Bh      ; DatDrvRiseSlowAvg
db    0Eh      ; DatSlwFallSlowAvg
db    08h      ; DatSlwRiseSlowAvg

db    0Ah      ; DqsDrvFallSlowAvg
db    0Bh      ; DqsDrvRiseSlowAvg
db    0Eh      ; DqsSlwFallSlowAvg
db    08h      ; DqsSlwRiseSlowAvg

db    00h      ; DataInbDelySlowAvg
db    01h      ; ClkIcDelySlowAvg
db    01h      ; DqsInbDelySlowAvg
;
; Micron Extreme SLOW values
;
db    08h      ; AdrDrvFallSlowExt
db    08h      ; AdrDrvRiseSlowExt
db    0Eh      ; AdrSlwFallSlowExt
db    08h      ; AdrSlwRiseSlowExt

db    0Fh      ; ClkDrvFallSlowExt
db    0Fh      ; ClkDrvRiseSlowExt
db    0Fh      ; ClkSlwFallSlowExt
db    0Fh      ; ClkSlwRiseSlowExt

db    0Bh      ; DatDrvFallSlowExt
db    0Eh      ; DatDrvRiseSlowExt
db    0Eh      ; DatSlwFallSlowExt
db    08h      ; DatSlwRiseSlowExt

db    0Bh      ; DqsDrvFallSlowExt
db    0Eh      ; DqsDrvRiseSlowExt
db    0Eh      ; DqsSlwFallSlowExt
db    08h      ; DqsSlwRiseSlowExt

db    00h      ; DataInbDelySlowExt
db    01h      ; ClkIcDelySlowExt
db    01h      ; DqsInbDelySlowExt

DrvSlwParamEnd:

DB   'Copyright (c) Microsoft Corporation. All rights reserved.'


CODE ENDS
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\bootx\romdec32\i386\romdec32.asm ===
;++
;
; Copyright (c) 1989-2000  Microsoft Corporation
;
; Module Name:
;
;    romdec.asm
;
; Abstract:
;
;    The module decrypts the ROM loader
;
; Environment:
;
;    32-bit Protected Mode
;
;--

; ==========================================================================

        .586p

        .xlist
        INCLUDE bldr.inc
        INCLUDE ks386.inc
        .list
        
        INCLUDE chipset.inc
        

_TEXT   SEGMENT PARA USE32 PUBLIC 'CODE'
        ASSUME  DS:_TEXT, ES:_TEXT, SS:NOTHING, FS:NOTHING, GS:NOTHING


        PUBLIC  _Startup32

_Startup32 PROC

;
; Setup segment registers
;       
        xor     eax, eax
        mov     al, KGDT_R0_DATA
        
        mov     ds, eax
        mov     es, eax
        mov     ss, eax


;
; Initialize chipset and RAM by parsing the init table
;
        INCLUDE command.inc
        INCLUDE initcode.inc

;
; Setup MTRRs and enable caching.  EBX was setup by the COMMAND_QUIT
; command in the init table and is supposed to contain the value
; used for default MTRR register
;
        xor     ecx, ecx
        mov     ch, 02h
        xor     eax, eax
        xor     edx, edx
@@:
        wrmsr
        inc     ecx
        cmp     cl, 0Fh
        jbe     @B

;
; Enable MTRR, disable fix-range MTRRs and set default memory type to UC.
;

        mov     cl, 0FFh
        mov     eax, ebx
        wrmsr

;
; Enable the processor cache by clearing cache disable and not-write-through
; flags in CR0.
;
        mov     eax, cr0
        and     eax, NOT (CR0_CD OR CR0_NW)
        mov     cr0, eax

IFNDEF MCP_XMODE2
IFNDEF MCP_XMODE3P
;
; XMODE3: Decrypt the boot loader.  Destination ROMDEC_OUTPUTBUFFER
;
        INCLUDE encrypt.inc

;
; Check to see if the encryption was successful.  RC4 algorithm does not provide
; success information.  Therefore, we check for a known signature at the end of
; decrypted boot loader
;

        mov     eax, ds:DWORD PTR [ROMDEC_OUTPUTBUFFER + ROMLDR_SIZE - ROMLDR_BOOTPARAMSIZE]
        cmp     eax, ROMLDR_SIGNATURE
        jne     Shutdown

; Jump to the boot loader startup.  The entry point of the boot loader is
; stored as the first DWORD at the decrypted code
;
; NOTE: The content of eax register must be the entry point of the boot
;       loader to indicate that we are not running in XDK box so that
;       boot loader will initialize MTRRs to enable RAM/ROM caching
; stored just prior to the signature in the boot param
;

        mov     eax, ds:DWORD PTR [ROMDEC_OUTPUTBUFFER]
        jmp     eax

ELSE ; XM3P

;
; XMODE3P: Hash the boot loader and verify that its hash is what we expect to find
;
        INCLUDE boothash.inc

; returns with ZF indicating whether we matched the hash
        jnz Shutdown

;
; Jump to the boot loader startup.  The entry point of the boot loader is
; stored just prior to the signature in the boot param
;

        jmp     _Startup32 - ROMPRELDR_SIZE

ENDIF ; XM3P
ELSE ; XM2

;
; XMODE2: Jump to the boot loader startup.  The entry point of the boot loader is
; stored just prior to the signature in the boot param
;

        jmp     _Startup32 - ROMPRELDR_SIZE

ENDIF ; XM2

;
; Sequence of instructions to turn off SB ROM and halt.  The following code
; does not do RMW because the system is shutting down
;
Shutdown:
IFDEF MCP_XMODE2

        hlt
        
ELSE

        mov     eax, 80000880h
        mov     dx, 0CF8h
        out     dx, eax

ENDIF
;
; Now jump to the top of the address space.  The code there will complete the shutdown sequence
;
        db      0EAh
        dd      0FFFFFFFAh
        dw      KGDT_R0_CODE

_Startup32 ENDP

IFNDEF MCP_XMODE2
IFNDEF MCP_XMODE3P
;
; XMODE3: Encryption key placeholder
;
        INCLUDE ENCKEY.INC
ENDIF
ENDIF


_TEXT   ENDS

; ==========================================================================

        END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\bootx\romdec32\i386\rstartup.asm ===
;++
;
; Copyright (c) 1989-2000  Microsoft Corporation
;
; Module Name:
;
;    rstartup.asm
;
; Abstract:
;
;    The module implements code to put the processor in protected mode.  This code executes
;    at processor reset vector
;
; Environment:
;
;    16-bit Real Mode
;
;--

; ==========================================================================

        .586p

        .xlist
        INCLUDE bldr.inc
        INCLUDE ks386.inc
        .list
        INCLUDE chipset.inc


_TEXT   SEGMENT  PARA USE16 PUBLIC 'CODE' 
        ASSUME  CS:_TEXT, DS:_TEXT, SS:_TEXT, ES:NOTHING


        PUBLIC  Startup16

;
; NOTE: Following ORG is hardcoded.  Changing any code below requires changing the ORG value
; so that the processor init always lines up at FFF0. To calculate this value, subtract the value of
; CodeSoFar label in the .lst file from FFF0 
;

IFDEF MCP_REV_B01
        ORG     0FFBCh  
ELSE    
        ORG     0FFB8h
ENDIF   


Startup16:

;
; Load the processor's global descriptor table by executing a 32-bit lgdt
;

        db      066h
        lgdt    cs:[RomDecGDTFWORD]
        
IFNDEF MCP_REV_B01
;
; Load the processor's interrupt descriptor table by executing a 32-bit lidt
; We point it to the same structure as the gdt to force the idt limit to be
; very small thus limiting the processor's capability to execute interrupt
; and fault handlers
;

        db      066h
        lidt    cs:[RomDecGDTFWORD]

ENDIF

;
; Enable the processor's protected mode support 
;

        mov     eax, cr0
        or      al, CR0_PE
        mov     cr0, eax

;
; Execute a 16:32 jump to the 32-bit part of romdec which is 512 bytes from 
; top of the address space
;

        db      066h, 0EAh
        dd      0FFFFFE00h
        dw      KGDT_R0_CODE
   

;
; NOTE: The linear address of this table is hardcoded in RomDecGDTFWORD below.  Changing the
; the size of this table requires updating the address
;
        ALIGN   4
RomDecGDT LABEL DWORD
        dd      0                       ; KGDT_NULL
        dd      0
        dd      00000FFFFh              ; KGDT_R0_CODE
        dd      000CF9B00h
        dd      00000FFFFh              ; KGDT_R0_DATA
        dd      000CF9300h
RomDecGDTEnd LABEL DWORD


;
; Processor will start executing code here which must be at FFFF_FFF0
;

ProcessorInit:
       
        CodeSoFar = (ProcessorInit - Startup16)

;
; Jump to the start of 16-bit code
;
        jmp     Startup16                    

;
; FWORD to initialize the processor's descriptor tables.
;

        ALIGN   4
RomDecGDTFWORD LABEL FWORD
        dw      OFFSET RomDecGDTEnd - OFFSET RomDecGDT    

        dd      0FFFFFFD8h

;
; The 32-bit part of the RomDec jumps to this code located FFFF FFFA.  This code finishes the PCI
; cycle that was started by the 32-bit code to turn of the Southbridge ROM.  Turning off SB ROM causes
; the next instruction being executed fetched from main ROM.  This code causes the next instruction 
; to fall outside of the the address space causing an unhandled exception to occur so
; we don't execute any code from main ROM
;
; The processor will be in Protected Mode while executing this code.  This code must always ORG to FFFA.
;
ShutdownEnd:
        add     dl, 04h
        mov     al, 2
        out     dx, al

_TEXT ENDS


; ==========================================================================

        END Startup16
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\bootx\romdec32\qtdevkit\makefile.inc ===
.SUFFIXES: .com .exe .obj .lst .c .asm .def .lnk .inc

{..\i386\}.asm{obj\i386\}.obj:
    $(386_ASSEMBLER_NAME) -c -omf -Fl -Fo$(MAKEDIR)\$@ -I. $(INCPATH1) $(ASM_DEFINES) $<

OBJ=obj\i386\inittbl.obj

$(BASEDIR)\private\ntos\obj\i386\inittbl_qt.bin: $(OBJ)

obj\i386\inittbl.obj: ..\i386\inittbl.asm

$(BASEDIR)\private\ntos\obj\i386\inittbl_qt.bin: $(OBJ)
    echo foo
    link16.exe @<<
/tiny /nod /noi +
$(OBJ)
$(BASEDIR)\private\ntos\obj\i386\inittbl_qt.bin



<<
!IFDEF _NT386TREE
    binplace -R $(_NTTREE) $(BINPLACE_DBGFLAGS_NT) $(BINPLACE_FLAGS) $@
!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\bootx\romdec32\inittbl2\makefile.inc ===
.SUFFIXES: .com .exe .obj .lst .c .asm .def .lnk .inc

{..\i386\}.asm{obj\i386\}.obj:
    $(386_ASSEMBLER_NAME) -c -omf -Fl -Fo$(MAKEDIR)\$@ -I. $(INCPATH1) $(ASM_DEFINES) $<

OBJ=obj\i386\inittbl.obj

$(BASEDIR)\private\ntos\obj\i386\inittbl_ret.bin: $(OBJ)

obj\i386\inittbl.obj: ..\i386\inittbl.asm

$(BASEDIR)\private\ntos\obj\i386\inittbl_ret.bin: $(OBJ)
    echo foo
    link16.exe @<<
/tiny /nod /noi +
$(OBJ)
$(BASEDIR)\private\ntos\obj\i386\inittbl_ret.bin



<<
!IFDEF _NT386TREE
    binplace -R $(_NTTREE) $(BINPLACE_DBGFLAGS_NT) $(BINPLACE_FLAGS) $@
!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\bootx\romdec32\inittbl\makefile.inc ===
.SUFFIXES: .com .exe .obj .lst .c .asm .def .lnk .inc

{..\i386\}.asm{obj\i386\}.obj:
    $(386_ASSEMBLER_NAME) -c -omf -Fl -Fo$(MAKEDIR)\$@ -I. $(INCPATH1) $(ASM_DEFINES) $<

OBJ=obj\i386\inittbl.obj

$(BASEDIR)\private\ntos\obj\i386\inittbl_dvt6.bin: $(OBJ)

obj\i386\inittbl.obj: ..\i386\inittbl.asm

$(BASEDIR)\private\ntos\obj\i386\inittbl_dvt6.bin: $(OBJ)
    echo foo
    link16.exe @<<
/tiny /nod /noi +
$(OBJ)
$(BASEDIR)\private\ntos\obj\i386\inittbl_dvt6.bin



<<
!IFDEF _NT386TREE
    binplace -R $(_NTTREE) $(BINPLACE_DBGFLAGS_NT) $(BINPLACE_FLAGS) $@
!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\bootx\romdec32\inittbl3\makefile.inc ===
.SUFFIXES: .com .exe .obj .lst .c .asm .def .lnk .inc

{..\i386\}.asm{obj\i386\}.obj:
    $(386_ASSEMBLER_NAME) -c -omf -Fl -Fo$(MAKEDIR)\$@ -I. $(INCPATH1) $(ASM_DEFINES) $<

OBJ=obj\i386\inittbl.obj

$(BASEDIR)\private\ntos\obj\i386\inittbl_dvt4.bin: $(OBJ)

obj\i386\inittbl.obj: ..\i386\inittbl.asm

$(BASEDIR)\private\ntos\obj\i386\inittbl_dvt4.bin: $(OBJ)
    echo foo
    link16.exe @<<
/tiny /nod /noi +
$(OBJ)
$(BASEDIR)\private\ntos\obj\i386\inittbl_dvt4.bin



<<
!IFDEF _NT386TREE
    binplace -R $(_NTTREE) $(BINPLACE_DBGFLAGS_NT) $(BINPLACE_FLAGS) $@
!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\bootx\romdec32\qtretail\makefile.inc ===
.SUFFIXES: .com .exe .obj .lst .c .asm .def .lnk .inc

{..\i386\}.asm{obj\i386\}.obj:
    $(386_ASSEMBLER_NAME) -c -omf -Fl -Fo$(MAKEDIR)\$@ -I. $(INCPATH1) $(ASM_DEFINES) $<

OBJ=obj\i386\inittbl.obj

$(BASEDIR)\private\ntos\obj\i386\inittbl_ret_qt.bin: $(OBJ)

obj\i386\inittbl.obj: ..\i386\inittbl.asm

$(BASEDIR)\private\ntos\obj\i386\inittbl_ret_qt.bin: $(OBJ)
    echo foo
    link16.exe @<<
/tiny /nod /noi +
$(OBJ)
$(BASEDIR)\private\ntos\obj\i386\inittbl_ret_qt.bin



<<
!IFDEF _NT386TREE
    binplace -R $(_NTTREE) $(BINPLACE_DBGFLAGS_NT) $(BINPLACE_FLAGS) $@
!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\bootx\romdec32\r16\makefile.inc ===
.SUFFIXES: .com .exe .obj .lst .c .asm .def .lnk .inc

{..\i386\}.asm{obj\i386\}.obj:
    $(386_ASSEMBLER_NAME) -c -omf -Fl -Fo$(MAKEDIR)\$@ -I. $(INCPATH1) $<

OBJ=obj\i386\rstartup.obj

obj\i386\rstartup.com: $(OBJ)

obj\i386\rstartup.obj: ..\i386\rstartup.asm

obj\i386\rstartup.com: $(OBJ)
    echo foo
    link16.exe @<<
/tiny /nod /noi +
$(OBJ)
obj\i386\rstartup.com



<<
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\dd\usb\brainbox\bbtype.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation


Module Name:

    bbtype.cpp

Abstract:
    
    Pluggable table entry for the Brain Box controller device.
    
    
Environment:

    Designed for XBOX.

Notes:

Revision History:

    12-03-00 created by Mitchell Dernis (mitchd)

--*/
extern "C" {
#include <ntos.h>
}
#include <ntrtl.h>
#include <nturtl.h>
#include <xtl.h>
#include <xboxp.h>
#include <usb.h>
#include "xid.h"
#include "brainbox.h"

// Forward declare
void FASTCALL fProcessBrainBoxData(PXID_OPEN_DEVICE OpenDevice);

//Brain Box 
#define  XID_DEVTYPE_BRAINBOX              0x80
#define  XID_INPUT_REPORT_ID_MAX_BRAINBOX  0
#define  XID_OUTPUT_REPORT_ID_MAX_BRAINBOX 0
#define  XID_DEFAULT_MAX_BRAINBOX          2

DECLARE_XPP_TYPE(XDEVICE_TYPE_BRAINBOX)
XINPUT_BRAINBOX_DATA BrainboxDefaults = {0};  //Everything zero.
XID_REPORT_TYPE_INFO BrainboxInputReportInfoList[1] = {sizeof(XINPUT_BRAINBOX_DATA),(PVOID)&BrainboxDefaults};
WORD bmLEDDefaults[3] = {0};  //All lights are off
XID_REPORT_TYPE_INFO BrainboxOutputReportInfoList[1] = {6,(PVOID)&bmLEDDefaults};
XINPUT_POLLING_PARAMETERS BrainboxDefaultPolling = {TRUE,FALSE,0,8,0,0}; //AutoPoll On, control-OUT

XID_TYPE_INFORMATION  BrainBoxTypeInfo = 
 {XID_DEVTYPE_BRAINBOX, XID_DEFAULT_MAX_BRAINBOX, XID_INPUT_REPORT_ID_MAX_BRAINBOX, XID_OUTPUT_REPORT_ID_MAX_BRAINBOX,
  XDEVICE_TYPE_BRAINBOX, BrainboxInputReportInfoList, BrainboxOutputReportInfoList, &BrainboxDefaultPolling, fProcessBrainBoxData, 0};
     
#pragma data_seg(".XID$BrainBox")
extern "C" ULONG_PTR BrainBoxTypeInfoENTRY = (ULONG_PTR)&BrainBoxTypeInfo;
#pragma data_seg(".XPP$Data")

void
FASTCALL
fProcessBrainBoxData(
    PXID_OPEN_DEVICE OpenDevice
    )
/*++
 Routine Description:
   Processing of brain box data.  Basically, it copies the data
   from the buffer that is ping-ponged to the hardware, to the one
   that is always available for copying from XInputGetState.

   Then it checks to see if anything changes and hits XAutoPowerDownResetTimer
--*/
{
    XINPUT_BRAINBOX_DATA *pBrainBox = (XINPUT_BRAINBOX_DATA *)OpenDevice->Report;
    if(OpenDevice->Urb.CommonTransfer.TransferBufferLength >= XID_REPORT_HEADER)
    {
        RtlCopyMemory(
          (PVOID)pBrainBox,
          (PVOID)(OpenDevice->ReportForUrb+XID_REPORT_HEADER),
          OpenDevice->Urb.ControlTransfer.TransferBufferLength-XID_REPORT_HEADER
          );

        //
        //  XAutoPowerDownResetTimer if any digital buttons are pressed.
        //  
        int i;
        for(i=0; i<3; i++)
        {
            if(pBrainBox->bmButtons[i])
            {
                XAutoPowerDownResetTimer();
                return;
            }
        }
        //
        //  ??? Should we check any other controls to avoid auto power down. ???
        //
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\dd\usb\brainbox\brainbox.h ===
//Declare the type
extern   XPP_DEVICE_TYPE       XDEVICE_TYPE_BRAINBOX_TABLE;
#define  XDEVICE_TYPE_BRAINBOX (&XDEVICE_TYPE_BRAINBOX_TABLE)

#include <PSHPACK1.H>
typedef struct _XINPUT_BRAINBOX_DATA
{
    WORD  bmButtons[3];
    WORD  wRightLeverX;
    WORD  wRightLeverY;
    WORD  wLeftLeverX;
    WORD  wUpperLeftLeverX;
    WORD  wUpperLeftLeverY;
    WORD  wFootPedal1;
    WORD  wFootPedal2;
    WORD  wFootPedal3;
    BYTE  bTuner;
    BYTE  bShiftLever;
} XINPUT_BRAINBOX_DATA;

typedef struct _XINPUT_BRAINBOX
{
  DWORD dwPacketNumber;
  XINPUT_BRAINBOX_DATA data;
} XINPUT_BRAINBOX, *PXINPUT_BRAINBOX;

// You can write your own named macros for getting at the digital buttons.
typedef struct _XINPUT_BRAINBOX_LEDS
{
    XINPUT_FEEDBACK_HEADER Header;
    WORD bmLEDs[3];
} XINPUT_BRAINBOX_LEDS, *PXINPUT_BRAINBOX_LEDS;

//UNTIL POST DECEMBER RELEASE DON'T USE GET CAPABILITIES 

#include <POPPACK.H>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\dd\usb\enumtest\bitfont.h ===
//-----------------------------------------------------------------------------
// FILE: BITFONT.H
//
// Desc: bit font header file
//
// Copyright (c) 1999-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#pragma once
#ifndef _BITFONT_H_
#define _BITFONT_H_


#ifdef XBOX
#include <xtl.h>
#else
#include <windows.h>
#include <d3d8.h>
#endif

// disable C4200: nonstandard extension used : zero-sized array in struct/union
#pragma warning(push)
#pragma warning(disable:4200)

// pack the structure as we're reading it from the disk
#pragma pack(1)

//----------------------------------------------------------------------------
// BXF file signature
#define BITFONT_SIG     '00BF'

//----------------------------------------------------------------------------
struct BitFontCharInfo
{
    BYTE bWidth;
    DWORD dwOffset;
};

//----------------------------------------------------------------------------
struct BitFontInfo
{
    DWORD   dwSig;
    DWORD   dwFontHeight;
    DWORD   cBfis;
    BitFontCharInfo rgBfi[];
};

#pragma warning(pop)
#pragma pack()


//----------------------------------------------------------------------------
// Draw flags
const DWORD DRAWTEXT_TRANSPARENTBKGND =     0x00000001;


//----------------------------------------------------------------------------
// A BitFont class that can be used with the DrawText routines above to
//  render text to various surfaces.
class BitFont
{
public:
    //----------------------------------------------------------------------------
    BitFont();

    //----------------------------------------------------------------------------
    ~BitFont();

    //----------------------------------------------------------------------------
    // Load a BitFont font from a file
    bool Load(const CHAR* filename);

    //----------------------------------------------------------------------------
    // Returns pixel height and width of string
    void GetTextStringLength(DWORD *pdwWidth, DWORD *pdwHeight, 
        const WCHAR* Message);

    //----------------------------------------------------------------------------
    // Draw the text to a surface
    void BitFont::DrawText
    (
        IDirect3DSurface8 *pSurface,
        const WCHAR*    str,
        int             iX,
        int             iY,
        DWORD           dwFlags,
        D3DCOLOR        colFore,
        D3DCOLOR        colBack
    );

private:
    //----------------------------------------------------------------------------
    // various pointers to font data, index tables and width tables
    BitFontInfo     *m_pBitFontInfo;
};

#endif // _BITFONT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\dd\usb\enumtest\draw.h ===
#ifndef __DRAW_H__
#define __DRAW_H__

#include <d3d8.h>
#include "bitfont.h"

class Draw
{
private:

    static IDirect3DDevice8* m_pDevice;

    IDirect3DSurface8* m_pBackBuffer;

    BitFont m_font;

public:

    Draw(INT width = 640, INT height = 480);

    ~Draw();

    VOID FillRect(
        INT x,
        INT y,
        INT width,
        INT height,
        D3DCOLOR color);

    VOID DrawText(
        const WCHAR* string,
        INT x,
        INT y,
        D3DCOLOR foregroundColor,           // 0xff0000 is red
        D3DCOLOR backgroundColor = 0,
        DWORD flags = DRAWTEXT_TRANSPARENTBKGND);

    VOID Present();

    BOOL IsValid() { return m_pDevice != NULL; }
};


#endif __DRAW_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\dd\usb\enumtest\bitfont.cpp ===
//-----------------------------------------------------------------------------
// FILE: BITFONT.CPP
//
// Desc: bit font rasterizer
//
// Copyright (c) 1999-2000 Microsoft Corporation. All rights reserved.
//-----------------------------------------------------------------------------

#include "bitfont.h"
#include <stdio.h>
#include <assert.h>
#include <D3DX8Math.h>

DWORD dwColorFromD3DXColor(D3DFORMAT dwSurfaceFormat, D3DCOLOR color);

// default font: 'Small Fonts' size 7
static const DWORD rgSmallFont[] =
{
    0x30304246, 0x0000000b, 0x00000060, 0x00000002,
    0x000b0200, 0x16040000, 0x06000000, 0x00000021,
    0x00002c06, 0x00370700, 0x42060000, 0x02000000,
    0x0000004d, 0x00005803, 0x00630300, 0x6e030000,
    0x04000000, 0x00000079, 0x00008402, 0x008f0300,
    0x9a020000, 0x03000000, 0x000000a5, 0x0000b005,
    0x00bb0300, 0xc6050000, 0x05000000, 0x000000d1,
    0x0000dc05, 0x00e70500, 0xf2050000, 0x05000000,
    0x000000fd, 0x00010805, 0x01130500, 0x1e020000,
    0x02000001, 0x00000129, 0x00013405, 0x013f0500,
    0x4a050000, 0x05000001, 0x00000155, 0x00016009,
    0x01760700, 0x81070000, 0x07000001, 0x0000018c,
    0x00019707, 0x01a20600, 0xad060000, 0x07000001,
    0x000001b8, 0x0001c307, 0x01ce0200, 0xd9050000,
    0x06000001, 0x000001e4, 0x0001ef05, 0x01fa0900,
    0x10070000, 0x07000002, 0x0000021b, 0x00022607,
    0x02310700, 0x3c070000, 0x06000002, 0x00000247,
    0x00025206, 0x025d0600, 0x68060000, 0x08000002,
    0x00000273, 0x00027e06, 0x02890600, 0x94060000,
    0x03000002, 0x0000029f, 0x0002aa03, 0x02b50300,
    0xc0040000, 0x05000002, 0x000002cb, 0x0002d603,
    0x02e10500, 0xec050000, 0x05000002, 0x000002f7,
    0x00030205, 0x030d0500, 0x18030000, 0x05000003,
    0x00000323, 0x00032e05, 0x03390200, 0x44020000,
    0x05000003, 0x0000034f, 0x00035a02, 0x03650800,
    0x70050000, 0x06000003, 0x0000037b, 0x00038605,
    0x03910500, 0x9c030000, 0x05000003, 0x000003a7,
    0x0003b203, 0x03bd0500, 0xc8050000, 0x06000003,
    0x000003d3, 0x0003de04, 0x03e90400, 0xf4040000,
    0x03000003, 0x000003ff, 0x00040a02, 0x04150300,
    0x20050000, 0x02000004, 0x0000042b, 0xc0c0c0c0,
    0xc0c0c0c0, 0xc0c0c0c0, 0x808080c0, 0x80c08080,
    0xf0f0c0c0, 0xf0f0a0a0, 0xf0f0f0f0, 0xd4fcfcf0,
    0x80d480d4, 0xfcfcd4d4, 0xc4ecfcfc, 0xa8e4cca8,
    0xfefcecc4, 0x9a9cfefe, 0xb8d8eef6, 0xfefefefe,
    0xaadeacde, 0xfec8b4b6, 0x9efefefe, 0xf6eadeac,
    0xfefec8f4, 0xacdefefe, 0xb4b6aabe, 0xfedebea8,
    0xdeccbefe, 0xc8d4d6ca, 0xfefebede, 0xeafe8c9e,
    0xfee8f4f6, 0xfefefefe, 0x86dafefc, 0xfefef8d4,
    0xfcfefefe, 0xd4c6dafe, 0xfefebeb8, 0xfefcfefe,
    0xf8f486fa, 0xfefefefe, 0xfafefcfe, 0xfeb8f4c6,
    0xdefefefe, 0xa69adedc, 0xfefeb8b4, 0xb4cefefe,
    0xb4b6b2b6, 0xfefefec8, 0xd694cefe, 0xc8d4d6d2,
    0xfefefefe, 0xeaf6b4ce, 0xfe80bcde, 0xcefefefe,
    0xf6eaf6b4, 0xfefec8b4, 0xcceefefe, 0xec86aace,
    0xfefefee8, 0x8ebc86fe, 0xc8b4f6b2, 0xfefefefe,
    0x8abeb4ce, 0xfec8b4b6, 0x86fefefe, 0xdeeaeef4,
    0xfefed8dc, 0xb4cefefe, 0xb4b6cab6, 0xfefefec8,
    0xb6b4cefe, 0xc8b4f6c2, 0xfefefefe, 0x82f6f4ce,
    0xfe88f4f6, 0xcefefefe, 0xf682f6f4, 0xfebe88f4,
    0xfcfefefe, 0xdcbedaee, 0xfefefee8, 0xfefcfefe,
    0xf88cfe8a, 0xfefefefe, 0xdabefcfe, 0xfeb8dcee,
    0xcefefefe, 0xdeeaf6b4, 0xfefed8fc, 0x80ff80ff,
    0x80de80e1, 0x00ab00b3, 0x80b400ab, 0x80e180df,
    0xffff80ff, 0xdbdbe6e7, 0xffbdbcc3, 0x83ffffff,
    0xbd83bdbc, 0xffff83bc, 0xbcc3ffff, 0xbcbfbfbf,
    0xffffffc3, 0xbdbc83ff, 0x83bcbdbd, 0xffffffff,
    0x85bdbc83, 0xff83bcbd, 0x83ffffff, 0xbd85bdbc,
    0xffffbfbc, 0xbcc3ffff, 0xb8bdb1bf, 0xffffffc5,
    0xbdbcbdff, 0xbdbcbd81, 0xffffffff, 0x81bdbcbd,
    0xffbdbcbd, 0xf5ffffff, 0xb5f1f5f4, 0xffffcdb4,
    0xb4b9ffff, 0xb4ad9dad, 0xffffffb9, 0xbdbcb9ff,
    0x81bcbdbd, 0x80ffffff, 0x009e80ff, 0x00ad009e,
    0x00b300ad, 0x00bf00b3, 0x80ff80ff, 0x9c9cffff,
    0xb5b5adad, 0xffffffb9, 0xbdbcc2ff, 0xc3bdbdbd,
    0xffffffff, 0x83bdbc82, 0xffbfbfbf, 0xc2ffffff,
    0xb5bdbdbc, 0xfffdc3b9, 0xbc82ffff, 0xbdbd83bd,
    0xffffffbd, 0xbdb8c6ff, 0xc5b9f9c7, 0xffffffff,
    0xefedec82, 0xffededed, 0xbaffffff, 0xb9bbb9b8,
    0xffffc5b9, 0xb8baffff, 0xedd5d7d5, 0xffffffed,
    0xddbebeff, 0xebebd5d5, 0xffffffff, 0xedd5baba,
    0xffbbbbd5, 0xbaffffff, 0xededd5ba, 0xffffefef,
    0xfa82ffff, 0xbfddedf5, 0xffffff83, 0xb5ba82ff,
    0xa3bfbdad, 0xffff9fbf, 0xadb5bae2, 0xffc3df9d,
    0x82ffffff, 0xddcdd5da, 0x9fdfc3df, 0xaad2ffff,
    0xfffdfdf5, 0xfffffff3, 0xfdfafaff, 0xfbfffdfd,
    0xffff07ff, 0xfdfddaba, 0xfffbfffd, 0xfaffffe7,
    0xc5f5cdfa, 0xffffc3b7, 0xbabaffff, 0xb7b5b58d,
    0xffffff8b, 0xcdfafaff, 0xcbb7bdb5, 0xffffffff,
    0xb5c5f2f2, 0xffc3b7b5, 0xfaffffff, 0x85b5cdfa,
    0xffffcbbf, 0xbadaffff, 0xbfa595ad, 0xffffffab,
    0xc5fafaff, 0xc3b7b5b5, 0xffff8ff7, 0x95adbaba,
    0xffb3b7b5, 0xbaffffff, 0xb595adfa, 0xffffb3b7,
    0xfabaffff, 0xb7b595ad, 0xffbfbfb3, 0xadbabaff,
    0xb3af9d9d, 0xffffffff, 0x9dadbaba, 0xffb3af9d,
    0xffffffff, 0xb6b681ff, 0xffffb6b6, 0xffffffff,
    0xb6b6b689, 0xffffffb6, 0xc5ffffff, 0xc6bababa,
    0xffffffff, 0xb28dffff, 0xbf8eb2b2, 0xffffffbf,
    0xb2b2c5ff, 0xf7f7c6b2, 0xffffffff, 0xb2b2b285,
    0xfff7f7a6, 0xc5ffffff, 0x8ef2caba, 0xffffffff,
    0xba85bfff, 0xffceb2aa, 0xffffffff, 0xb2b2b5ff,
    0xffffc6b2, 0xffffffff, 0xcab2b2b5, 0xffffffce,
    0xb9ffffff, 0xd6d6aaaa, 0xffffffff, 0xaaa9ffff,
    0xffa6a6da, 0xffffffff, 0xaaaaa9ff, 0x9fefc6a6,
    0xffffffff, 0xb6daea89, 0xffffff86, 0xc9dfdfff,
    0xc6d69aca, 0xffffdfdf, 0x8a899fdf, 0x9f86969a,
    0xbfffffdf, 0xdaaaa9bf, 0xbfbfa6b6, 0xd7ffffff,
    0xfefafaa9, 0xfffffffe, 0xa997ffff, 0xbebebaba,
    0x0000ffbf, 0x0006fe21, 0x0fffff9d, 0x00000002,
};

//----------------------------------------------------------------------------
BitFont::BitFont()
{
    // start out with our default font
    m_pBitFontInfo = (BitFontInfo *)rgSmallFont;
}

//----------------------------------------------------------------------------
BitFont::~BitFont()
{
    if(m_pBitFontInfo != (BitFontInfo *)rgSmallFont)
        delete m_pBitFontInfo;
}

//----------------------------------------------------------------------------
// Intialize a BitFont from a specified filename
bool BitFont::Load(const CHAR* filename)
{
	bool retval = false;
	BitFontInfo *pBitFontInfo = NULL;

	HANDLE hFile = CreateFile(filename, 
		                      GENERIC_READ, 
							  FILE_SHARE_READ, 
							  NULL, 
							  OPEN_EXISTING, 
							  FILE_ATTRIBUTE_NORMAL, 
							  NULL);


    if (hFile == INVALID_HANDLE_VALUE)
    {
		goto err;
	}

    // Get the file size.
	BY_HANDLE_FILE_INFORMATION info;

	if (!GetFileInformationByHandle(hFile, &info))
	{
		goto err;
	}

    // need at least a BITFONT and one BITFONTINFO, but the
	// file can be too big as well.
	//
	if (info.nFileSizeLow < sizeof(BitFontInfo) + sizeof(BitFontCharInfo)
		|| info.nFileSizeHigh != 0)
	{
		goto err;
	}

	// Allocate the BITFONT.
	pBitFontInfo = (BitFontInfo *)new BYTE[info.nFileSizeLow];

	if (!pBitFontInfo)
	{
		goto err;
	}

	// Load it.
	if (!ReadFile(hFile, pBitFontInfo, info.nFileSizeLow, NULL, NULL))
	{
		goto err;
	}

    // if the sig doesn't match or we don't have any bitfontinfos then bail
    if (pBitFontInfo->dwSig != BITFONT_SIG || !pBitFontInfo->cBfis)
	{
        goto err;
	}

	// Delete any old fonts.
    if(m_pBitFontInfo != (BitFontInfo *)rgSmallFont)
	{
		delete m_pBitFontInfo;
	}

	// Set the new.
	m_pBitFontInfo = pBitFontInfo;
	pBitFontInfo = NULL;

	retval = true;

err:
	if (pBitFontInfo)
	{
		delete pBitFontInfo;
	}

    if (hFile != INVALID_HANDLE_VALUE)
	{
        CloseHandle(hFile);
	}

    return retval;
}


//----------------------------------------------------------------------------
// Returns pixel height and width of string
void BitFont::GetTextStringLength(DWORD *pdwWidth, DWORD *pdwHeight, const WCHAR *str)
{
    if(pdwHeight)
        *pdwHeight = m_pBitFontInfo->dwFontHeight;

    if(pdwWidth)
    {
        DWORD dwWidth = 0;

        // go through the string adding up the widths
        for(const WCHAR *sz = str; *sz; sz++)
        {
            DWORD iBfi = *sz - 32;

            if(iBfi >= m_pBitFontInfo->cBfis)
                iBfi = 0;

            dwWidth += m_pBitFontInfo->rgBfi[iBfi].bWidth;
        }

        *pdwWidth = dwWidth;
    }
}

//----------------------------------------------------------------------------
void DrawText16
(
    D3DSURFACE_DESC*    pDesc,
    D3DLOCKED_RECT*     pLock,
    BitFontInfo*        m_pBitFontInfo,
    const WCHAR*        str,
    int                 iX,
    int                 iY,
    DWORD               dwFlags,
    DWORD               dwcolFore,
    DWORD               dwcolBack
)
{
    bool fdrawBkgnd = !(dwFlags & DRAWTEXT_TRANSPARENTBKGND);

    // rgColor[0] is background color
    WORD rgColor[2] = { LOWORD(dwcolBack), LOWORD(dwcolFore) };

    // pointer to font bytestream data
    BYTE *lpData = (BYTE *)&m_pBitFontInfo->rgBfi[m_pBitFontInfo->cBfis];
    // pointer to end of dest surface
    WORD *pwSurfaceMaxY = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * pDesc->Height);

    // go through the string
    for(const WCHAR *sz = str; *sz; sz++)
    {
        DWORD iBfi = *sz - 32;

        if(iBfi >= m_pBitFontInfo->cBfis)
            iBfi = 0;

        // get data for this char
        BitFontCharInfo *pbfi = &m_pBitFontInfo->rgBfi[iBfi];
        BYTE *lpBits = &lpData[pbfi->dwOffset];

        // where we're drawing
        WORD *pwSurface = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + iX;
        // max x for the line we're on
        WORD *pwSurfaceMaxX = (WORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + pDesc->Width;

        // go through bitfont drawing each line
        for(DWORD y = 0; y < m_pBitFontInfo->dwFontHeight; y++)
        {
            DWORD dwWidth = pbfi->bWidth;

            while(dwWidth)
            {
                DWORD dwByte = *lpBits++;
                DWORD dwNumBits = min(dwWidth, 8);

                dwWidth -= dwNumBits;

                // check number of bits and clipping
                while(dwNumBits-- && (pwSurface < pwSurfaceMaxX))
                {
                    DWORD iIndex = !(dwByte & 0x80);

                    if(fdrawBkgnd || iIndex)
                        *pwSurface = rgColor[iIndex];

                    pwSurface++;
                    dwByte <<= 1;
                }
            }

            // get next line data
            pwSurface = (WORD *)((BYTE *)(pwSurface - pbfi->bWidth - dwWidth) + pLock->Pitch);
            pwSurfaceMaxX = (WORD *)((BYTE *)pwSurfaceMaxX + pLock->Pitch);

            // check clipping
            if(pwSurface >= pwSurfaceMaxY)
                break;
        }

        // move to next char position
        iX += pbfi->bWidth;
    }
}

//----------------------------------------------------------------------------
void DrawText32
(
    D3DSURFACE_DESC*    pDesc,
    D3DLOCKED_RECT*     pLock,
    BitFontInfo*        m_pBitFontInfo,
    const WCHAR*        str,
    int                 iX,
    int                 iY,
    DWORD               dwFlags,
    DWORD               dwcolFore,
    DWORD               dwcolBack
)
{
    bool fdrawBkgnd = !(dwFlags & DRAWTEXT_TRANSPARENTBKGND);
    DWORD rgColor[2] = { dwcolBack, dwcolFore };

    BYTE *lpData = (BYTE *)&m_pBitFontInfo->rgBfi[m_pBitFontInfo->cBfis];
    DWORD *pdwSurfaceMaxY = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * pDesc->Height);

    for(const WCHAR *sz = str; *sz; sz++)
    {
        DWORD iBfi = *sz - 32;

        if(iBfi >= m_pBitFontInfo->cBfis)
            iBfi = 0;

        BitFontCharInfo *pbfi = &m_pBitFontInfo->rgBfi[iBfi];
        BYTE *lpBits = &lpData[pbfi->dwOffset];

        DWORD *pdwSurface = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + iX;
        DWORD *pdwSurfaceMaxX = (DWORD *)((BYTE *)pLock->pBits + pLock->Pitch * iY) + pDesc->Width;

        for(DWORD y = 0; y < m_pBitFontInfo->dwFontHeight; y++)
        {
            DWORD dwWidth = pbfi->bWidth;

            while(dwWidth)
            {
                DWORD dwByte = *lpBits++;
                DWORD dwNumBits = min(dwWidth, 8);

                dwWidth -= dwNumBits;

                while(dwNumBits-- && (pdwSurface < pdwSurfaceMaxX))
                {
                    DWORD iIndex = !(dwByte & 0x80);

                    if(fdrawBkgnd || iIndex)
                        *pdwSurface = rgColor[iIndex];

                    pdwSurface++;
                    dwByte <<= 1;
                }
            }

            pdwSurface = (DWORD *)((BYTE *)(pdwSurface - pbfi->bWidth - dwWidth) + pLock->Pitch);
            pdwSurfaceMaxX = (DWORD *)((BYTE *)pdwSurfaceMaxX + pLock->Pitch);
            if(pdwSurface >= pdwSurfaceMaxY)
                break;
        }

        iX += pbfi->bWidth;
    }
}

//----------------------------------------------------------------------------
// Draw the specified text to a surface
void BitFont::DrawText
(
    IDirect3DSurface8 *pSurface,
    const WCHAR*    str,
    int             iX,
    int             iY,
    DWORD           dwFlags,
    D3DCOLOR        colFore,
    D3DCOLOR        colBack
)
{
    typedef void (*PFNDRAWTEXT)(
        D3DSURFACE_DESC*    pDesc,
        D3DLOCKED_RECT*     pLock,
        BitFontInfo*        m_pBitFontInfo,
        const WCHAR*        str,
        int                 iX,
        int                 iY,
        DWORD               dwFlags,
        DWORD               dwcolFore,
        DWORD               dwcolBack
    );

    PFNDRAWTEXT rgpfnDrawText[] =
    {
        DrawText16,
        DrawText32
    };

    D3DLOCKED_RECT lockRect;
    if(pSurface->LockRect(&lockRect, NULL, D3DLOCK_NOSYSLOCK) != S_OK)
    {
        assert(FALSE);
        return;
    }

    D3DSURFACE_DESC desc;
    (void)pSurface->GetDesc(&desc);


    UINT BitsPerPixel =
        (desc.Format == D3DFMT_X8R8G8B8 
          || desc.Format == D3DFMT_A8R8G8B8
          || desc.Format == D3DFMT_LIN_X8R8G8B8
          || desc.Format == D3DFMT_LIN_A8R8G8B8) ? 32 : 16;

    // use the correct draw routine for the job
    rgpfnDrawText[BitsPerPixel == 32](
        &desc,
        &lockRect,
        m_pBitFontInfo,
        str,
        iX,
        iY,
        dwFlags,
        dwColorFromD3DXColor(desc.Format, colFore),
        dwColorFromD3DXColor(desc.Format, colBack)
    );

    // Relase the lock on the surface
    pSurface->UnlockRect();
}

//----------------------------------------------------------------------------
// Given a surfaceformet and color, return the dude as a native pixel
DWORD dwColorFromD3DXColor(D3DFORMAT dwSurfaceFormat, D3DCOLOR color)
{
    DWORD dwColor;
    D3DXCOLOR col(color);

    switch(dwSurfaceFormat)
    {
    // 32-bit
    case D3DFMT_A8R8G8B8:
    case D3DFMT_LIN_A8R8G8B8:
        dwColor =
            (((long)(col.a * 255)) << 24) |
            (((long)(col.r * 255)) << 16) |
            (((long)(col.g * 255)) << 8) |
            (long)(col.b * 255);
        break;

    // 32-bit
    case D3DFMT_X8R8G8B8:
    case D3DFMT_LIN_X8R8G8B8:
        dwColor =
            0xff000000L |
            (((long)(col.r * 255)) << 16) |
            (((long)(col.g * 255)) << 8) |
            (long)(col.b * 255);
        break;

    // 16-bit
    case D3DFMT_R5G6B5:
    case D3DFMT_LIN_R5G6B5:
        dwColor =
            (((long)(col.r * 255)) << 11) |
            (((long)(col.g * 255)) << 5) |
            (long)(col.b * 255);
        break;
    case D3DFMT_X1R5G5B5:
    case D3DFMT_LIN_X1R5G5B5:
        dwColor =
            (1 << 15) |
            (((long)(col.r * 255)) << 10) |
            (((long)(col.g * 255)) << 5) |
            (long)(col.b * 255);
        break;
    case D3DFMT_A4R4G4B4:
    case D3DFMT_LIN_A4R4G4B4:
        dwColor =
            (((long)(col.a * 15)) << 12) |
            (((long)(col.r * 15)) << 8) |
            (((long)(col.g * 15)) << 4) |
            (long)(col.b * 15);
        break;
    case D3DFMT_A1R5G5B5:
    case D3DFMT_LIN_A1R5G5B5:
        dwColor =
            (((long)(col.a > .9f)) << 15) |
            (((long)(col.r * 31)) << 10) |
            (((long)(col.g * 31)) << 5) |
            (long)(col.b * 31);
        break;

    default:
        dwColor = 0;
        assert(FALSE);
        break;
    }
    return dwColor;
};

//----------------------------------------------------------------------------
// Map our 'new' directly to LocalAlloc
void* __cdecl operator new(size_t size)
{
    return LocalAlloc(0, size);
}

//----------------------------------------------------------------------------
// Map our 'delete' directly to LocalFree   
VOID __cdecl operator delete(VOID* alloc)
{
    LocalFree(alloc);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\dd\usb\enumtest\draw.cpp ===
/*--
Copyright (c) 2000 Microsoft Corporation - Xbox SDK

Module Name:

    Main.cpp

Abstract:

    Simple sample for drawing text on the screen.

Revision History:

    Derived from a DX8 sample.
--*/

#include <xtl.h>
#include "draw.h"

//------------------------------------------------------------------------------
// Draw
//
// Handy little D3D encapsulation for simple 2D drawing.


//------------------------------------------------------------------------------
// Draw::m_pDevice
//
// Instantiate static class member, initialized to NULL.

IDirect3DDevice8* Draw::m_pDevice;

//------------------------------------------------------------------------------
// Draw constructor

Draw::Draw(INT width, INT height)
{
    m_pBackBuffer = NULL;

    // If we're invoked multiple times, we inherit the old mode (largely
    // because we don't support multiple mode sets on Xbox yet):

    if (m_pDevice == NULL)
    {
        // Create D3D 8.
    
        IDirect3D8 *pD3D = Direct3DCreate8(D3D_SDK_VERSION);
        if (pD3D == NULL)
            return;
    
        // Set the screen mode.
    
        D3DPRESENT_PARAMETERS d3dpp;
        ZeroMemory(&d3dpp, sizeof(d3dpp));
    
        d3dpp.BackBufferWidth           = width;
        d3dpp.BackBufferHeight          = height;
        d3dpp.BackBufferFormat          = D3DFMT_X8R8G8B8;
        d3dpp.BackBufferCount           = 1;
        d3dpp.Windowed                  = false;    // Must be false for Xbox
        d3dpp.EnableAutoDepthStencil    = true;
        d3dpp.AutoDepthStencilFormat    = D3DFMT_D24S8;
        d3dpp.SwapEffect                = D3DSWAPEFFECT_DISCARD;
        d3dpp.FullScreen_RefreshRateInHz= 60;
        d3dpp.hDeviceWindow             = NULL;
    
        // Create the device.
    
        if (pD3D->CreateDevice
        (
            D3DADAPTER_DEFAULT,
            D3DDEVTYPE_HAL,
            NULL,
            D3DCREATE_HARDWARE_VERTEXPROCESSING,
            &d3dpp,
            &m_pDevice
        ) != S_OK)
        {
            pD3D->Release();

            return;
        }
    
        // Now we no longer need the D3D interface so let's free it.
    
        pD3D->Release();
    }

    m_pDevice->GetBackBuffer(0, D3DBACKBUFFER_TYPE_MONO, &m_pBackBuffer);
}

//------------------------------------------------------------------------------
// Draw::~Draw

Draw::~Draw()
{
    if (m_pBackBuffer)
        m_pBackBuffer->Release();
}

//------------------------------------------------------------------------------
// Draw::FillRect

VOID Draw::FillRect(
    INT x,
    INT y,
    INT width,
    INT height,
    D3DCOLOR color)
{
    D3DRECT rect;

    if (m_pDevice != NULL)
    {
        rect.x1 = x;
        rect.y1 = y;
        rect.x2 = x + width;
        rect.y2 = y + height;

        m_pDevice->Clear(1, &rect, D3DCLEAR_TARGET, color, 0, 0);
    }
}

//------------------------------------------------------------------------------
// Draw::DrawText

VOID Draw::DrawText(
    const WCHAR* string,
    INT x,
    INT y,
    D3DCOLOR foregroundColor,   // 0xff0000 is red
    D3DCOLOR backgroundColor,
    DWORD flags)
{
    if (m_pBackBuffer != NULL)
    {
        m_font.DrawText(m_pBackBuffer, string, x, y, flags, foregroundColor,
                        backgroundColor);
    }
}

//------------------------------------------------------------------------------
// Draw::Present
//
// Make the current back-buffer visible

VOID Draw::Present()
{
    if (m_pDevice != NULL)
    {
        m_pDevice->Present(NULL, NULL, NULL, NULL);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\dd\usb\enumtest\main.cpp ===
#include <xtl.h>
#include "draw.h"


// Hack! DbgPrint is much nicer than OutputDebugString so JonT exported it from xapi.lib
// (as DebugPrint) but the prototype isn't in the public headers...
extern "C"
{
	ULONG
	DebugPrint(
		PCHAR Format,
		...
		);
}
//
// Colors
//
#define BACKDROP_BLUE 0x000080
#define LABEL_WHITE 0xffffff
#define DISCONNECTED_BLUE 0x000040
#define CONNECTED_YELLOW 0xffff00

//
//  Useful Macro
//
#define DECLARE_DO_TWICE int doTwice;
#define DO_TWICE doTwice=2; while(doTwice--)

//
//  Forward Declations
//
void InitDisplay(Draw *pDraw);
void InitDevices(PXPP_DEVICE_TYPE DeviceType, DWORD& dwState, BOOL fHasBottomSlots, Draw *pDraw, ULONG yPos);
void UpdateDevices(PXPP_DEVICE_TYPE DeviceType, DWORD& dwState, BOOL fHasBottomSlots, Draw *pDraw, ULONG yPos);
LPWSTR DeviceTypeToString(PXPP_DEVICE_TYPE DeviceType);
void DrawPortTopSlotsBitmap(Draw *pDraw, DWORD dwState, ULONG yPos);
void DrawPortBottomSlotsBitmap(Draw *pDraw, DWORD dwState, ULONG yPos);

//------------------------------------------------------------------------------
// TestMain

void __cdecl main()
{
    DebugPrint("ENUMTEST APPLICATION.\nBuilt on %s at %s\n", __DATE__, __TIME__);
    
    //Initialize core peripheral port support
    XDEVICE_PREALLOC_TYPE deviceTypes[] = 
    {
        {XDEVICE_TYPE_GAMEPAD,4},
        {XDEVICE_TYPE_MEMORY_UNIT,8},
        {XDEVICE_TYPE_VOICE_MICROPHONE,4},
        {XDEVICE_TYPE_VOICE_HEADPHONE,4}
    };
    XInitDevices(sizeof(deviceTypes)/sizeof(XDEVICE_PREALLOC_TYPE),deviceTypes);

    Draw draw;
    DWORD dwStateGamePads;
    DWORD dwStateMemoryUnits;
    DWORD dwStateChatButtons;
    DWORD dwStateChatMicrophone;
    DWORD dwStateChatHeadphone;
    InitDisplay(&draw);
    InitDevices(XDEVICE_TYPE_GAMEPAD, dwStateGamePads,  FALSE, &draw,      80);
    InitDevices(XDEVICE_TYPE_MEMORY_UNIT, dwStateMemoryUnits, TRUE, &draw,   100);
    InitDevices(XDEVICE_TYPE_VOICE_MICROPHONE, dwStateChatMicrophone, FALSE, &draw,   130);
    InitDevices(XDEVICE_TYPE_VOICE_HEADPHONE, dwStateChatHeadphone, FALSE, &draw,   150);
    while(1)
    {
        UpdateDevices(XDEVICE_TYPE_GAMEPAD, dwStateGamePads, FALSE, &draw,       80);
        UpdateDevices(XDEVICE_TYPE_MEMORY_UNIT, dwStateMemoryUnits, TRUE, &draw,   100);
        UpdateDevices(XDEVICE_TYPE_VOICE_MICROPHONE, dwStateChatMicrophone, FALSE, &draw,   130);
        UpdateDevices(XDEVICE_TYPE_VOICE_HEADPHONE, dwStateChatHeadphone, FALSE, &draw,   150);
    }
}

void InitDisplay(Draw *pDraw)
{
    DECLARE_DO_TWICE;
    DO_TWICE{
        //Draw the title screen
        pDraw->FillRect(0, 0, 640, 480, BACKDROP_BLUE); 
        pDraw->DrawText(L"USB Enumeration Test Application", 50,  50, LABEL_WHITE);
        pDraw->Present();
    }
}

void InitDevices(PXPP_DEVICE_TYPE DeviceType, DWORD& dwState, BOOL fHasBottomSlots, Draw *pDraw, ULONG yPos)
{
    WCHAR FormatBuffer[80];
    DECLARE_DO_TWICE;
    if(fHasBottomSlots)
    {
        DO_TWICE{
            wsprintf(FormatBuffer, L"%ws's(Top):", DeviceTypeToString(DeviceType));
            pDraw->DrawText(FormatBuffer, 55, yPos, LABEL_WHITE);
            wsprintf(FormatBuffer, L"%ws's(Bottom):", DeviceTypeToString(DeviceType));
            pDraw->DrawText(FormatBuffer, 55, yPos+10, LABEL_WHITE);
            pDraw->Present();
        }
    } else
    {
        DO_TWICE
        {
            wsprintf(FormatBuffer, L"%ws's:", DeviceTypeToString(DeviceType));
            pDraw->DrawText(FormatBuffer, 55, yPos, LABEL_WHITE);
            pDraw->Present();
        }
    }
    dwState = XGetDevices(DeviceType);
    DebugPrint("%ws Initial State = 0x%0.8x\n", DeviceTypeToString(DeviceType), dwState);
    DrawPortTopSlotsBitmap(pDraw, dwState, yPos);
    if(fHasBottomSlots) DrawPortBottomSlotsBitmap(pDraw, dwState, yPos+10);
}

void UpdateDevices(PXPP_DEVICE_TYPE DeviceType, DWORD& dwState, BOOL fHasBottomSlots, Draw *pDraw, ULONG yPos)
{
    DWORD dwInsertions, dwRemovals;
    //
    //  Only update the text, if something changed.
    //  This is why you want to ask for insertions and removals (last parameter is false)
    //  rather than state, which returns TRUE if anything is attached.
    //
    if(XGetDeviceChanges(DeviceType, &dwInsertions, &dwRemovals))
    {
        dwState &= ~dwRemovals;  //Always process removals first
        dwState |= dwInsertions;
        DebugPrint("%ws Changed, Insert=0x%0.8x, Remove=0x%0.8x, State=0x%0.8x\n", DeviceTypeToString(DeviceType), dwInsertions, dwRemovals, dwState);
        DrawPortTopSlotsBitmap(pDraw, dwState, yPos);
        if(fHasBottomSlots) DrawPortBottomSlotsBitmap(pDraw, dwState, yPos+10);
    }
}

LPWSTR DeviceTypeToString(PXPP_DEVICE_TYPE DeviceType)
{
    if(XDEVICE_TYPE_GAMEPAD == DeviceType) return L"XDEVICE_TYPE_GAMEPAD";
    if(XDEVICE_TYPE_MEMORY_UNIT  == DeviceType) return L"XDEVICE_TYPE_MEMORY_UNIT";
    if(XDEVICE_TYPE_VOICE_MICROPHONE == DeviceType) return L"XDEVICE_TYPE_VOICE_MICROPHONE";
    if(XDEVICE_TYPE_VOICE_HEADPHONE  == DeviceType) return L"XDEVICE_TYPE_VOICE_HEADPHONE";
    return L"XDEVICE_TYPE_????";
}

void DrawPortTopSlotsBitmap(Draw *pDraw, DWORD dwState, ULONG yPos)
/*++
    Draws the state of the top slots of players one to four.
--*/
{
  DECLARE_DO_TWICE;
  DO_TWICE
  {
      ULONG xPos = 250;
      WCHAR PortString[2]=L"0";
      for(int index = 0; index < XGetPortCount(); index++)
      {
        (*PortString)++;        
        pDraw->DrawText(PortString, xPos, yPos, (dwState&(1<<index)) ? CONNECTED_YELLOW : DISCONNECTED_BLUE);
        xPos += 20;
       }
       pDraw->Present();
  }
}

void DrawPortBottomSlotsBitmap(Draw *pDraw, DWORD dwState, ULONG yPos)
/*++
    Draws the state of the bottom slots of players one to four
--*/
{
  DECLARE_DO_TWICE;
  DO_TWICE
  {
      ULONG xPos = 250;
      WCHAR PortString[2]=L"0";
      for(int index = 0; index < XGetPortCount(); index++)
      {
        (*PortString)++;        
        pDraw->DrawText(PortString, xPos, yPos, (dwState&(1<<(index+16))) ? CONNECTED_YELLOW : DISCONNECTED_BLUE);
        xPos += 20;
       }
       pDraw->Present();
  }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\dd\usb\ezusbdef\ezusbdef.cpp ===
/*++

Copyright (c) 2002  Microsoft Corporation

Module Name:

    ezusbdef.cpp

Abstract:

    This module implements a USB class driver for the EZ-USB default device.

--*/

#define _NTOS_
#include <ntddk.h>
#include <xtl.h>
#include <usb.h>
#include "ezusbdef.h"

//
// Declare the structure used by the USB enumeration code to internally track
// devices of this type.
//

DECLARE_XPP_TYPE(XDEVICE_TYPE_EZUSBDEF)

//
// Create the table of device types that this class driver supports.
//

USB_DEVICE_TYPE_TABLE_BEGIN(Ezusb)
    USB_DEVICE_TYPE_TABLE_ENTRY(XDEVICE_TYPE_EZUSBDEF)
USB_DEVICE_TYPE_TABLE_END()

//
// Create the structure that binds the USB class, subclass, and protocol codes
// to this class driver.
//

USB_CLASS_DRIVER_DECLARATION_DEVICE_LEVEL(Ezusb, USB_DEVICE_CLASS_VENDOR_SPECIFIC, 0xFF, 0xFF)

//
// Register the class driver with the USB core driver by placing a pointer to
// the above structure in the .XPP$Class section.
//

#pragma data_seg(".XPP$ClassEzusb")
USB_CLASS_DECLARATION_POINTER(Ezusb)
#pragma data_seg(".XPP$Data")

//
// Stores all of the per-port instance data related to a device.  Allocate the
// maximum number of devices as a global.
//

typedef struct _EZUSB_DEVICE_STATE {
    IUsbDevice *Device;
    BOOLEAN DeviceAttached : 1;
    BOOLEAN DeviceRemoved : 1;
    BOOLEAN DefaultEndpointOpened : 1;
    BOOLEAN ClosingEndpoints : 1;
    BOOLEAN RemoveDevicePending : 1;
    URB CloseEndpointUrb;
    KEVENT CloseEndpointEvent;
} EZUSB_DEVICE_STATE, *PEZUSB_DEVICE_STATE;

EZUSB_DEVICE_STATE EzusbDeviceState[XGetPortCount()];

//
// Track the device insertions and removal bitmasks here.  The application
// cannot use XGetDeviceChanges because the USB core driver only reports changes
// to XTL for devices without USB_DEVICE_CLASS_VENDOR_SPECIFIC as a class code.
//

DWORD EzusbDeviceInsertions;
DWORD EzusbDeviceRemovals;

//
// Define the EZ-USB vendor specific request codes.
//

#define EZUSB_REQUEST_FIRMWARE_LOAD                     0xA0

//
// Local support.
//

VOID
EzusbCloseEndpointsAsync(
    PEZUSB_DEVICE_STATE DeviceState
    );

VOID
EzusbInit(
    IUsbInit *UsbInit
    )
/*++

Routine Description:

    This routine is invoked by the core USB driver to initialize the class
    driver.  This routine can allocate resources for the expected number of
    devices (either statically known or dynamically determined from the values
    from XInitDevices) and register resource requirements with the core USB
    driver.

Arguments:

    UsbInit - Specifies a virtual table of functions that can be used to control
        the behavior of this class driver.

Return Value:

    None.

--*/
{
    DWORD dwPort;
    PEZUSB_DEVICE_STATE DeviceState;

    for (dwPort = 0; dwPort < XGetPortCount(); dwPort++) {

        DeviceState = &EzusbDeviceState[dwPort];

        //
        // Initialize the event used to synchronize the closing of endpoints.
        //

        KeInitializeEvent(&DeviceState->CloseEndpointEvent,
            NotificationEvent, FALSE);
    }
}

VOID
EzusbAddDevice(
    IUsbDevice *Device
    )
/*++

Routine Description:

    This routine is invoked by the core USB driver during enumeration time when
    a device has been added that is supported by this class driver.

Arguments:

    Device - Specifies a virtual table of functions that can be used to control
        the behavior of the device.

Return Value:

    None.

--*/
{
    DWORD dwPort;
    PEZUSB_DEVICE_STATE DeviceState;

    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    //
    // Verify that the device is attached to a legal port number.  Note that if
    // the device were plugged into the bottom slot of a hub, then the port
    // number will exceed XGetPortCount() and we'll ignore the device.
    //

    dwPort = Device->GetPort();

    if (dwPort >= XGetPortCount()) {
        Device->AddComplete(USBD_STATUS_UNSUPPORTED_DEVICE);
        return;
    }

    DeviceState = &EzusbDeviceState[dwPort];

    //
    // Verify that we haven't already seen a device attached.
    //

    if (DeviceState->DeviceAttached) {
        Device->AddComplete(USBD_STATUS_UNSUPPORTED_DEVICE);
        return;
    }

    //
    // Remember that a device is physically attached.
    //

    DeviceState->DeviceAttached = TRUE;

    //
    // Store information about the device in our globals.
    //

    DeviceState->Device = Device;

    //
    // Notify the USB enumeration code that we have successfully added the
    // device.
    //

    DeviceState->Device->AddComplete(USBD_STATUS_SUCCESS);

    //
    // Remember that this device has been inserted in the global device bitmap.
    //

    EzusbDeviceInsertions |= (1 << dwPort);
}

VOID
EzusbRemoveDevice(
    IUsbDevice *Device
    )
/*++

Routine Description:

    This routine is invoked by the core USB driver during enumeration time when
    a device has been removed that had successfully been added before.

Arguments:

    Device - Specifies a virtual table of functions that can be used to control
        the behavior of the device.

Return Value:

    None.

--*/
{
    DWORD dwPort;
    PEZUSB_DEVICE_STATE DeviceState;

    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    dwPort = Device->GetPort();

    ASSERT(dwPort < XGetPortCount());

    DeviceState = &EzusbDeviceState[dwPort];

    ASSERT(DeviceState->DeviceAttached);
    ASSERT(DeviceState->Device == Device);

    //
    // Remember that we're in the middle of a device removal.
    //

    DeviceState->RemoveDevicePending = TRUE;

    //
    // Close all of the open endpoints.  When this operation completes, the
    // remove device process will be completed.
    //

    EzusbCloseEndpointsAsync(DeviceState);

    //
    // Remember that this device has been removed in the global device bitmap.
    //

    EzusbDeviceRemovals |= (1 << dwPort);
}

VOID
EzusbCloseEndpointsComplete(
    PURB Urb,
    PVOID Context
    )
/*++

Routine Description:

    This routine is invoked after the URB has completed to close an endpoint.

Arguments:

    Urb - Specifies the pointer to the URB that has completed.

    Context - Specifies the context supplied to URB_BUILD_CONTROL_TRANSFER.

Return Value:

    None.

--*/
{
    PEZUSB_DEVICE_STATE DeviceState;

    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    DeviceState = (PEZUSB_DEVICE_STATE)Context;

    if (DeviceState->DefaultEndpointOpened) {

        //
        // Close the default endpoint.
        //

        USB_BUILD_CLOSE_DEFAULT_ENDPOINT(&Urb->CloseEndpoint,
                                         EzusbCloseEndpointsComplete,
                                         DeviceState);

        DeviceState->DefaultEndpointOpened = FALSE;

    } else {

        //
        // All endpoints are closed.  Signal the close endpoint event in case a
        // thread is waiting for the close endpoint to complete.
        //

        KeSetEvent(&DeviceState->CloseEndpointEvent, IO_NO_INCREMENT,
            FALSE);
        DeviceState->ClosingEndpoints = FALSE;

        //
        // If the device has been removed, then complete the device removal
        // process by notifying the USB enumeration code.
        //

        if (DeviceState->RemoveDevicePending) {

            DeviceState->RemoveDevicePending = FALSE;
            DeviceState->DeviceAttached = FALSE;
            DeviceState->DeviceRemoved = TRUE;

            DeviceState->Device->RemoveComplete();
        }

        return;
    }

    //
    // There's at least one endpoint still open.  If an endpoint is open, then
    // we must still think the device is logically attached and connected to
    // this device extension.
    //

    ASSERT(DeviceState->DeviceAttached);

    //
    // Submit the close request and wait for the USB driver to close the
    // endpoint.
    //

    DeviceState->Device->SubmitRequest(Urb);
}

VOID
EzusbCloseEndpointsAsync(
    PEZUSB_DEVICE_STATE DeviceState
    )
/*++

Routine Description:

    This routine asynchronously closes all of the open endpoints.

Arguments:

    DeviceState - Specifies the device whose endpoints are to be closed.

Return Value:

    None.

--*/
{
    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

    //
    // If we haven't already started closing endpoints, then kick off the
    // process.
    //

    if (!DeviceState->ClosingEndpoints) {

        //
        // Clear the close endpoint event used for synchronous close operations.
        //

        KeClearEvent(&DeviceState->CloseEndpointEvent);
        DeviceState->ClosingEndpoints = TRUE;

        //
        // Enter the close endpoints state machine.
        //

        EzusbCloseEndpointsComplete(&DeviceState->CloseEndpointUrb,
            DeviceState);
    }
}

VOID
EzusbCloseEndpoints(
    PEZUSB_DEVICE_STATE DeviceState
    )
/*++

Routine Description:

    This routine synchronously closes all of the open endpoints.

Arguments:

    DeviceState - Specifies the device whose endpoints are to be opened.

Return Value:

    None.

--*/
{
    KIRQL OldIrql;

    ASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

    //
    // Asynchronously close all of the open endpoints.  When all of the
    // endpoints are closed, the close endpoint event is signaled.
    //

    OldIrql = KeRaiseIrqlToDpcLevel();

    EzusbCloseEndpointsAsync(DeviceState);

    KeLowerIrql(OldIrql);

    //
    // Block until the endpoints have been closed.
    //

    KeWaitForSingleObject(&DeviceState->CloseEndpointEvent, Executive,
        KernelMode, FALSE, NULL);
}

VOID
EzusbGetDeviceChanges(
    LPDWORD lpdwInsertions,
    LPDWORD lpdwRemovals
    )
/*++

Routine Description:

    This routine is the equivalent of XGetDeviceChanges for the EZ-USB device.

Arguments:

    lpdwInsertions - Specifies the buffer to receive the bitmask of devices that
        have been inserted.

    lpdwRemovals - Specifies the buffer to receive the bitmask of devices that
        have been removed.

Return Value:

    None.

--*/
{
    KIRQL OldIrql;

    OldIrql = KeRaiseIrqlToDpcLevel();

    *lpdwInsertions = EzusbDeviceInsertions;
    *lpdwRemovals = EzusbDeviceRemovals;

    EzusbDeviceInsertions = 0;
    EzusbDeviceRemovals = 0;

    KeLowerIrql(OldIrql);
}

VOID
EzusbSignalEventComplete(
    PURB Urb,
    PVOID Context
    )
/*++

Routine Description:

    This routine is invoked after a generic URB has completed.

Arguments:

    Urb - Specifies the pointer to the URB that has completed.

    Context - Specifies the context supplied to the URB builder macro.

Return Value:

    None.

--*/
{
    //
    // Wake up the thread waiting for the URB to complete.
    //

    KeSetEvent((PKEVENT)Context, EVENT_INCREMENT, FALSE);
}

DWORD
EzusbFirmwareLoad(
    DWORD dwPort,
    WORD wStartingAddress,
    LPVOID lpvFirmware,
    WORD wNumberOfBytes,
    BOOL fUpload
    )
/*++

Routine Description:

    This routine performs a firmware upload or download for the EZ-USB default
    device.

Arguments:

    dwPort - Specifies the port number of the device to be accessed.

    wStartingAddress - Specifies the starting address to begin the transfer.

    lpvFirmware - Specifies the buffer that contains the data to be uploaded or
        the buffer to receive the data to be downloaded.

    wNumberOfBytes - Specifies the number of bytes to transfer.

    fUpload - Specifies TRUE if data is to be uploaded to the EZ-USB device,
        else FALSE if data is to be downloaded from the EZ-USB device.

Return Value:

    Status of operation.

--*/
{
    PEZUSB_DEVICE_STATE DeviceState;
    KIRQL OldIrql;
    DWORD UsbdStatus;
    KEVENT Event;
    URB Urb;

    ASSERT(dwPort < XGetPortCount());

    DeviceState = &EzusbDeviceState[dwPort];

    OldIrql = KeRaiseIrqlToDpcLevel();

    //
    // Verify that the device is attached.
    //

    if (!DeviceState->DeviceAttached) {
        KeLowerIrql(OldIrql);
        return ERROR_DEVICE_NOT_CONNECTED;
    }

    //
    // Open the default control endpoint, if we haven't already opened it.
    //

    if (!DeviceState->DefaultEndpointOpened) {

        USB_BUILD_OPEN_DEFAULT_ENDPOINT(&Urb.OpenEndpoint);

        UsbdStatus = DeviceState->Device->SubmitRequest(&Urb);

        if (!USBD_SUCCESS(UsbdStatus)) {
            KeLowerIrql(OldIrql);
            return IUsbDevice::Win32FromUsbdStatus(Urb.Header.Status);
        }

        DeviceState->DefaultEndpointOpened = TRUE;
    }

    //
    // Initialize the event used to wait URBs to complete.
    //

    KeInitializeEvent(&Event, NotificationEvent, FALSE);

    //
    // Build and submit the vendor specific command to transfer the buffer.
    //

    USB_BUILD_CONTROL_TRANSFER(&Urb.ControlTransfer,
                               NULL,
                               lpvFirmware,
                               wNumberOfBytes,
                               USB_TRANSFER_DIRECTION_IN,
                               EzusbSignalEventComplete,
                               &Event,
                               TRUE,
                               USB_DEVICE_TO_HOST | USB_VENDOR_COMMAND | USB_COMMAND_TO_DEVICE,
                               EZUSB_REQUEST_FIRMWARE_LOAD,
                               wStartingAddress,
                               0,
                               wNumberOfBytes);

    if (fUpload) {
        Urb.ControlTransfer.TransferDirection = USB_TRANSFER_DIRECTION_OUT;
        Urb.ControlTransfer.SetupPacket.bmRequestType =
            USB_HOST_TO_DEVICE | USB_VENDOR_COMMAND | USB_COMMAND_TO_DEVICE;
    }

    DeviceState->Device->SubmitRequest(&Urb);

    //
    // Wait for the URB to complete.  This must be done at lowered IRQL.
    //

    KeLowerIrql(OldIrql);
    KeWaitForSingleObject(&Event, Executive, KernelMode, FALSE, NULL);

    //
    // Check the URB for any errors.
    //

    if (USBD_ERROR(Urb.Header.Status)) {
        DbgPrint("EzusbFirmwareLoad failed %08x\n", Urb.Header.Status);
        return IUsbDevice::Win32FromUsbdStatus(Urb.Header.Status);
    }

    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\dd\usb\ezusbdef\ezusbdef.h ===
/*++

Copyright (c) 2002  Microsoft Corporation

Module Name:

    ezusbdef.h

Abstract:

    This module contains the public interface for a sample USB class driver.

--*/

#ifndef _EZUSBDEF_
#define _EZUSBDEF_

#ifdef __cplusplus
extern "C" {
#endif

extern XPP_DEVICE_TYPE XDEVICE_TYPE_EZUSBDEF_TABLE;
#define XDEVICE_TYPE_EZUSBDEF (&XDEVICE_TYPE_EZUSBDEF_TABLE)

VOID
WINAPI
EzusbGetDeviceChanges(
    LPDWORD lpdwInsertions,
    LPDWORD lpdwRemovals
    );

DWORD
WINAPI
EzusbFirmwareLoad(
    DWORD dwPort,
    WORD wStartingAddress,
    LPVOID lpvFirmware,
    WORD wNumberOfBytes,
    BOOL fUpload
    );

#ifdef __cplusplus
}
#endif

#endif  // EZUSBDEF
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\dd\usb\hawk\hawk2.h ===
/*++

Copyright (c) 1996-2000 Microsoft Corporation

Module Name:

    hawk.H

Abstract:

    Header file for hawk driver

Environment:

    kernel mode

Revision History:

    06-28-2000 : started : georgioc

--*/

//*****************************************************************************
// I N C L U D E S
//*****************************************************************************

#define _XAPI_
#define _KERNEL32_
#define NODSOUND  //so we can use the private version
extern "C" {
#include <ntos.h>
}
#include <ntrtl.h>
#include <nturtl.h>
#include <xtl.h>
#include <xboxp.h>
#include <usb.h>
#include <xapidrv.h>
#include <dsoundp.h>
#include <xdbg.h>

//*****************************************************************************
// Useful Macros
//*****************************************************************************

#define max(a,b) (((a) > (b)) ? (a) : (b))
#define min(a,b) (((a) < (b)) ? (a) : (b))

#define SET_FLAG(Flags, Bit)    ((Flags) |= (Bit))
#define CLEAR_FLAG(Flags, Bit)  ((Flags) &= ~(Bit))
#define TEST_FLAG(Flags, Bit)   ((Flags) & (Bit))

#if DBG || DEBUG_LOG

    extern ULONG               HawkDebugLevel;     // Level of debug output

#endif

#if !DBG

#define DBGPRINT(level, _x_)

#else

#define DBGPRINT(level, _x_) do { \
    if (level <= HawkDebugLevel) { \
        KdPrint(("HAWK: ")); \
        KdPrint( _x_ ); \
    } \
} while (0)

#endif

//*****************************************************************************
// A few remainder macros shamelessly stolen from dsound.
//*****************************************************************************
#define QUOTE0(a)               #a
#define QUOTE1(a)               QUOTE0(a)
                                
//
// #pragma Reminders
//

#define MESSAGE(a)              message(__FILE__ "(" QUOTE1(__LINE__) "): " a)
#define TODO(a)                 MESSAGE("TODO: " a)
#define BUGBUG(a)               MESSAGE("BUGBUG: " a)
#define HACKHACK(a)             MESSAGE("HACKHACK: " a)

//*****************************************************************************
// Helpful defintions
//*****************************************************************************
#define HAWK_MICROPHONE_CLASS_SPECIFIC_TYPE 0
#define HAWK_HEADPHONE_CLASS_SPECIFIC_TYPE  1
#define HAWK_VENDOR_FEATURE_AGC             1
#define HAWK_VENDOR_FEATURE_SAMPLE_RATE     0
#define HAWK_BYTES_PER_SAMPLE               2
#define HAWK_USB_MAX_FRAMES                 8
#define HAWK_ISOCH_MAX_ATTACH_BUFFERS       3
#define HAWK_MIN_PACKET_FRAMES              10
#define HAWK_DEFAULT_MAX_OPENED             4
#define HAWK_MAX_SAMPLES_PER_USB_FRAME      24  //The highest support rate is 24 kHz
#define HAWK_MAX_BYTES_PER_USB_FRAME        (HAWK_MAX_SAMPLES_PER_USB_FRAME * HAWK_BYTES_PER_SAMPLE)
#define HAWK_WRAP_BUFFER_SIZE               (HAWK_USB_MAX_FRAMES * HAWK_MAX_BYTES_PER_USB_FRAME + 2)

#define HAWK_AGC_ON                         1
#define HAWK_AGC_OFF                        0
	
typedef struct _HAWK_STREAMING_RESOURCES *PHAWK_STREAMING_RESOURCES;
typedef struct _HAWK_PACKET_CONTEXT *PHAWK_PACKET_CONTEXT;
typedef struct _HAWK_TRANSFER_CONTEXT *PHAWK_TRANSFER_CONTEXT;
typedef struct _HAWK_WRAP_BUFFER *PHAWK_WRAP_BUFFER;
class XHawkMediaObject;

//*****************************************************************************
//  HAWK_PACKET_CONTEXT tracks a packet submitted via XMediaObject::Process  
//*****************************************************************************
typedef struct _HAWK_PACKET_CONTEXT
{
    XMEDIAPACKET         MediaPacket;
    PHAWK_PACKET_CONTEXT pNextPacket;
} HAWK_PACKET_CONTEXT;

//*****************************************************************************
//  HAWK_WRAP_BUFFER used to wrap 
//*****************************************************************************
typedef struct _HAWK_WRAP_BUFFER
{
    PHAWK_PACKET_CONTEXT pSecondPacket;
    PUCHAR               pucTransferBuffer;   //The beginning of the second buffer
    ULONG                ulSecondPacketBytes;
    UCHAR                Buffer[HAWK_WRAP_BUFFER_SIZE]; 
} HAWK_WRAP_BUFFER;

//*****************************************************************************
//  HAWK_TRANSFER_CONTEXT represents an oustanding Isoch Transfer
//*****************************************************************************
typedef struct _HAWK_TRANSFER_CONTEXT
{
    XHawkMediaObject           *pHawkMediaObject;    //The media object we are acting for.
    PHAWK_PACKET_CONTEXT        pPacketContext;      //The context we are tracking
    PUCHAR                      pucTransferBuffer;   //The beginning of this transfer
    ULONG                       ulTransferBytes;     //Bytes programmed in this transfer
    BOOLEAN                     fWrapBuffer;         //If TRUE, the wrap buffer was used.
    CHAR                        cFirstFrame;         //The first frame programmed
    UCHAR                       ucContextNumber;     //Number of this transfer frame.
    BOOLEAN                     fLastTransfer;       //Last Transfer of a Packet
} HAWK_TRANSFER_CONTEXT;

//*****************************************************************************
//  HAWK_SAMPLE_RATE_INFORMATION 
//*****************************************************************************
typedef struct _HAWK_SAMPLE_RATE_INFORMATION
{
    USHORT nSamplePerSecond;
    UCHAR  BytesPerUSBFrame;
    UCHAR  ExtraSampleInterval;
} HAWK_SAMPLE_RATE_INFORMATION, *PHAWK_SAMPLE_RATE_INFORMATION;
#define HAWK_SAMPLE_RATE_COUNT 5

class CHawkPacketQueue
{
    public:

     void InsertTail(PHAWK_PACKET_CONTEXT pPacketContext);
     PHAWK_PACKET_CONTEXT RemoveHead();
     PHAWK_PACKET_CONTEXT GetHead () {return m_pHead;}
        
    private:

     PHAWK_PACKET_CONTEXT m_pHead;
     PHAWK_PACKET_CONTEXT m_pTail;
};

#define HAWK_BCF_SHORT_PACKET  1
#define HAWK_BCF_DISCONTINUITY 2

#define HAWK_TRANSFER_CONTEXT_0 1
#define HAWK_TRANSFER_CONTEXT_1 2
#define HAWK_TRANSFER_CONTEXT_BOTH 3

typedef struct _HAWK_STREAMING_RESOURCES *PHAWK_STREAMING_RESOURCES;
typedef struct _HAWK_STREAMING_RESOURCES
{
    
    union
    {
        PHAWK_PACKET_CONTEXT m_pContextArray; //used to track the original allocation.
                                              //of packet contexts, so we can free them.

        PHAWK_STREAMING_RESOURCES pNextFree;  //only used while the streaming resources is on the 
                                              //free list.
    };      
    //
    //  Packet Queues
    //

    CHawkPacketQueue PendingProgram;
    CHawkPacketQueue Free;
    

    //
    //  USB Frame Information
    //
    
    CHAR  BytesPerUSBFrame;           //Bytes per USB frame (at some rates there is an extra 2 bytes, every
                                       //ExtraSampleInterval frames.
    CHAR  ExtraSampleInterval;        //USB frame intervals for which we must send\receive an extra sample.
    CHAR  ProgrammedFrame;            //Counts up to the ExtraSampleInterval
    CHAR  AvailableTransferContexts;  //Bit 0, is the 0

    //
    //  Contexts for keeping track of outstanding DMA
    //
    HAWK_TRANSFER_CONTEXT TransferContext[2];
    HAWK_WRAP_BUFFER      WrapBuffer;

    //
    //  Members for communicating with USB stack
    //
    KEVENT CloseEvent;
    URB_ISOCH_CLOSE_ENDPOINT     CloseUrb;
    PVOID EndpointHandle;
    
} HAWK_STREAMING_RESOURCES, *PHAWK_STREAMING_RESOURCES;


EXTERNUSB VOID
HawkInit (IUsbInit *pUsbInit);

EXTERNUSB VOID
HawkAddDevice (
    IN IUsbDevice *Device
    );

EXTERNUSB VOID
HawkRemoveDevice (
    IN IUsbDevice *Device
    );

XBOXAPI
EXTERN_C
HRESULT
WINAPI
XVoiceCreateMediaObject(
      IN PXPP_DEVICE_TYPE XppDeviceType,
      IN DWORD dwPort,
      IN DWORD dwMaxAttachedPackets,
      IN PWAVEFORMATEX  pwfxFormat OPTIONAL,
      OUT XMediaObject **ppXmediaObject
      );

EXTERN_C
HRESULT
WINAPI
XVoiceCreateMediaObjectInternal(
      IN PXPP_DEVICE_TYPE XppDeviceType,
      IN DWORD dwPort,
      IN DWORD dwMaxAttachedPackets,
      IN LPWAVEFORMATEX pwfxFormat,
      IN PFNXMEDIAOBJECTCALLBACK    pfnCallback,
      IN PVOID                      pvContext,
      OUT XMediaObject **ppXmediaObject
      );

//*****************************************************************************
// XHawkMediaObject
//*****************************************************************************

class XHawkMediaObject : public XMediaObject
{

    public:
        //
        //  Declaration of IUnknown members
        //  (minus QI which was nuked)
        
        STDMETHOD_(ULONG, AddRef) (void);

        STDMETHOD_(ULONG, Release) (void);

        //
        //  Declaration of XMediaObject members
        //
       STDMETHOD(GetInfo) (
            OUT PXMEDIAINFO pInfo
            );
        
        STDMETHOD(Flush) (void);
        
        STDMETHOD(Discontinuity) (void);
        
        STDMETHOD(GetStatus) (
            OUT DWORD *pdwFlags
            );
        
        STDMETHOD(Process) (
            IN LPCXMEDIAPACKET   pInputPacket,
            IN LPCXMEDIAPACKET   pOutputPacket
            );
        
        XHawkMediaObject() :
            m_pDevice(NULL),
		    m_wMaxPacket(0),
            m_bEndpointAddress(0),
            m_fConnected(FALSE),
		    m_fOpened(FALSE),
		    m_fClosePending(FALSE),
            m_fRemovePending(FALSE),
            m_fMicrophone(FALSE),
            m_fReady(FALSE),
            m_fClosingEndpoint(FALSE),
            m_Reserved(0),
            m_lRefCount(0),
            m_pStreamingResources(NULL),
            m_pfnCallback(NULL),
            m_pvContext(NULL)
            {}

        static void InitializeClass(ULONG ulMicrophoneCount, ULONG ulHeadphoneCount); //Initialize static members
	
		//
        //	Keeps track of the static list
		//	of objects
		//
		static XHawkMediaObject *sm_pMicrophones;	//Array of microphone instances
		static XHawkMediaObject *sm_pHeadphones;	//Array of headphone instances
        static UCHAR            *sm_pRateIndices;   //Array of sample rate indices for device instances
        static UCHAR            *sm_pRateIndexRefCounts; //Array of reference counts on rate indices
        static USHORT           sm_AvailableHeadphoneResources; //Count of streaming resources available for headphones
        static USHORT           sm_AvailableMicrophoneResources; //Count of streaming resources available for microphones
        static PHAWK_STREAMING_RESOURCES sm_pFreeStreamingResources; //Free list of streaming resource structures.
        static HAWK_SAMPLE_RATE_INFORMATION sm_HawkSampleRates[HAWK_SAMPLE_RATE_COUNT];
        

    private:
        
        //
		//	Information Detected During enumeration.
		//
        IUsbDevice          *m_pDevice;
		WORD			    m_wMaxPacket;
        UCHAR			    m_bEndpointAddress;
		
		//
		//	Running Per Instance State Information
		//
        //  Notes on state flag.  Connecting
        //  and opening a device is synchronous.
        //  Closing a device is asynchronous.
        //
        
		UCHAR			   m_fConnected:1;
		UCHAR			   m_fOpened:1;
		UCHAR			   m_fClosePending:1;
        UCHAR			   m_fRemovePending:1;
        UCHAR			   m_fMicrophone:1;
        UCHAR              m_fReady:1;
        UCHAR              m_fClosingEndpoint:1;
        UCHAR              m_Reserved:1;

        LONG			   m_lRefCount;

        //
        //  For internal callbacks
        //
        PFNXMEDIAOBJECTCALLBACK    m_pfnCallback;
        PVOID                      m_pvContext;

	    //
		//	Streaming Resources (only needed for operation)
		//
		PHAWK_STREAMING_RESOURCES m_pStreamingResources;

        //
        //  Private help methods
        //
        HRESULT AllocateStreamingResources (ULONG ulMaxAttachedPackets, ULONG ulRateIndex);
        void FreeStreamingResources (void);
        void CloseEndpoint (void);
        static void CloseEndpointComplete (IN PURB, IN XHawkMediaObject *pThis);
        void ProgramTransfer(void);
        static void TransferComplete(IN PUSBD_ISOCH_TRANSFER_STATUS Status, IN PVOID pvContext);
        void AbortMediaPackets();
        HRESULT SetSampleRate(UCHAR ucRateIndex, KIRQL BaseIrql);
		HRESULT SetAGC(UCHAR ucAGC, KIRQL BaseIrql);


    //
    //  The XcreateHawkMediaObject factory method, and the
    //  USB interface methods, need to be friends.  They
    //  all would be members, but they must be C calleable.
    //
    friend HRESULT 
    XVoiceCreateMediaObject(
      IN PXPP_DEVICE_TYPE XppDeviceType,
      IN DWORD dwPort,
      IN DWORD dwMaxAttachedPackets,
      IN PWAVEFORMATEX  pwfxFormat  OPTIONAL,
      OUT XMediaObject **ppXmediaObject
      );

    friend HRESULT
    XVoiceCreateMediaObjectInternal(
      IN PXPP_DEVICE_TYPE XppDeviceType,
      IN DWORD dwPort,
      IN DWORD dwMaxAttachedPackets,
      IN LPWAVEFORMATEX pwfxFormat,
      IN PFNXMEDIAOBJECTCALLBACK    pfnCallback,
      IN PVOID                      pvContext,
      OUT XMediaObject **ppXmediaObject
      );

    
    friend VOID HawkInit (IUsbInit *pUsbInit);

    friend VOID HawkAddDevice (
                    IN IUsbDevice *Device
                    );

    friend VOID HawkRemoveDevice (
                    IN IUsbDevice *Device
                    );
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\dd\usb\hawk\hawkxmo.h ===
/*++

Copyright (c) 1996-2000 Microsoft Corporation

Module Name:

    hawk.H

Abstract:

    Header file for hawk driver

Environment:

    kernel mode

Revision History:

    06-28-2000 : started : georgioc

--*/

//*****************************************************************************
// I N C L U D E S
//*****************************************************************************

#define _XAPI_
#define _KERNEL32_
#define NODSOUND
extern "C" {
#include <ntos.h>
}
#include <ntrtl.h>
#include <nturtl.h>
#include <xtl.h>
#include <usb.h>
#include <xapidrv.h>
#include <dsoundp.h>
#include <xdbg.h>

//
// BUGBUG   If we are using a standard USB reader for dev, set this define
//

#define STANDARD_USB_DEVICE 1

//*****************************************************************************
// D E F I N E S
//*****************************************************************************

#define max(a,b) (((a) > (b)) ? (a) : (b))
#define min(a,b) (((a) < (b)) ? (a) : (b))

#define SET_FLAG(Flags, Bit)    ((Flags) |= (Bit))
#define CLEAR_FLAG(Flags, Bit)  ((Flags) &= ~(Bit))
#define TEST_FLAG(Flags, Bit)   ((Flags) & (Bit))

#if DBG || DEBUG_LOG

    extern ULONG               HawkDebugLevel;     // Level of debug output

#endif

#if !DBG

#define DBGPRINT(level, _x_)

#else

#define DBGPRINT(level, _x_) do { \
    if (level <= HawkDebugLevel) { \
        KdPrint(("HAWK: ")); \
        KdPrint( _x_ ); \
    } \
} while (0)

#endif

//*****************************************************************************
// A few remainder macros shamelessly stolen from dsound.
//*****************************************************************************
#define QUOTE0(a)               #a
#define QUOTE1(a)               QUOTE0(a)
                                
//
// #pragma Reminders
//

#define MESSAGE(a)              message(__FILE__ "(" QUOTE1(__LINE__) "): " a)
#define TODO(a)                 MESSAGE("TODO: " a)
#define BUGBUG(a)               MESSAGE("BUGBUG: " a)
#define HACKHACK(a)             MESSAGE("HACKHACK: " a)

//*****************************************************************************
// Helpful defintions
//*****************************************************************************
#define HAWK_MICROPHONE_CLASS_SPECIFIC_TYPE 0
#define HAWK_HEADPHONE_CLASS_SPECIFIC_TYPE 1

//*****************************************************************************
//  The sample rate and size of the device are hardcoded by specification.
//  The sources file can override this for building against test hardware
//  that doesn't meet spec.
//*****************************************************************************
#ifndef HAWK_CONSTANTS_PREDEFINED
#define HAWK_MICROPHONE_SAMPLE_RATE 16 //In kilohertz
#define HAWK_MICROPHONE_BYTES_PER_SAMPLE 2
#define HAWK_HEADPHONE_SAMPLE_RATE 16 //In kilohertz
#define HAWK_HEADPHONE_BYTES_PER_SAMPLE 2
#endif

#pragma TODO("Performance tune HAWK_ISOCH_MAX_ATTACH_BUFFERS")
#define HAWK_ISOCH_MAX_ATTACH_BUFFERS 3
#define HAWK_BYTES_PER_USB_FRAME (HAWK_HEADPHONE_SAMPLE_RATE*HAWK_HEADPHONE_BYTES_PER_SAMPLE)
#define HAWK_USB_MAX_FRAMES 8 //This is a fundemental USB isoch thing.

#if (HAWK_MICROPHONE_SAMPLE_RATE!=HAWK_HEADPHONE_SAMPLE_RATE)
#error Microphone Sample Rate Must Equal Headphone Sample Rate
#endif
#if (HAWK_MICROPHONE_BYTES_PER_SAMPLE!=HAWK_HEADPHONE_BYTES_PER_SAMPLE)
#error Microphone Bytes Per Sample Must Equal Headphone Bytes Per Sample
#endif

    
typedef struct _HAWK_TYPE_SETTINGS
{
    ULONG         ulHawkClassSpecificType;
    
    // Pointer to waveformat to report
    PWAVEFORMATEX pWaveFormat;

    // Fixed parameters returned by GetInputInfo,
    // or GetOutputInfo
    DWORD dwFlags;
    DWORD cbSize;
    DWORD cbMaxLookahead;
    DWORD cbAlignment;

} HAWK_TYPE_SETTINGS, *PHAWK_TYPE_SETTINGS;


typedef struct _HAWK_PACKET_CONTEXT *PHAWK_PACKET_CONTEXT;
typedef struct _HAWK_PACKET_CONTEXT
{
    XMEDIAPACKET         mediaPacket;
    DWORD                dwCompletedSize;
    PHAWK_PACKET_CONTEXT pNextPacket;
} HAWK_PACKET_CONTEXT;

class CHawkPacketQueue
{
    public:

     void InsertTail(PHAWK_PACKET_CONTEXT pPacketContext);
     PHAWK_PACKET_CONTEXT RemoveHead();
     PHAWK_PACKET_CONTEXT GetHead () {return m_pHead;}
        
    private:

     PHAWK_PACKET_CONTEXT m_pHead;
     PHAWK_PACKET_CONTEXT m_pTail;
};


#define HAWK_BCF_SHORT_PACKET  1
#define HAWK_BCF_DISCONTINUITY 2

typedef struct _HAWK_STREAMING_RESOURCES
{
    PVOID EndpointHandle;

    //
    //  Packet Queues
    //

    CHawkPacketQueue PendingProgram;
    CHawkPacketQueue PendingComplete;
    CHawkPacketQueue Free;

    //
    //  Programming State
    //

    ULONG ulBytesRemaining; 
    ULONG ulOutstandingTransfers;

    //
    //  The IsochBufferDescriptor could be allocated
    //  on the stack in ProgramTransfer, but many
    //  of the arguments are set at open time (a.k.a.
    //  XcreateHawkMediaObject) so we just keep
    //  the structure around.
    //
    //  CloseEvent is used to synchronize
    //  closing the endpoint handle when the
    //  object reference count goes to zero.
    //  Since ProgramTransfer won't initiate
    //  any transfers after a close is initiated
    //  the memory can be shared with IsochBufferDescriptor.
    //

    union 
    {
        USBD_ISOCH_BUFFER_DESCRIPTOR IsochBufferDescriptor;
        KEVENT CloseEvent;
    };
    
    //
    //  The close urb is needed when it is time to close  
    //  the stream.
    //
    
    URB_ISOCH_CLOSE_ENDPOINT     CloseUrb;
    
} HAWK_STREAMING_RESOURCES, *PHAWK_STREAMING_RESOURCES;


EXTERNUSB VOID
HawkInit ();

EXTERNUSB VOID
HawkAddDevice (
    IN IUsbDevice *Device
    );

EXTERNUSB VOID
HawkRemoveDevice (
    IN IUsbDevice *Device
    );


//*****************************************************************************
// XHawkMediaObject
//*****************************************************************************

class XHawkMediaObject : public XMediaObject
{

    public:
        //
        //  Declaration of IUnknown members
        //  (minus QI which was nuked)
        
        STDMETHOD_(ULONG, AddRef) (void);

        STDMETHOD_(ULONG, Release) (void);

        //
        //  Declaration of XMediaObject members
        //
        STDMETHOD(GetInfo) (
            IN OUT LPXMEDIAINFO pInfo
            );
                
        STDMETHOD(Flush) (void);
        
        STDMETHOD(Discontinuity) (void);
        
        STDMETHOD(GetStatus) (
            OUT DWORD *pdwFlags
            );
        
        STDMETHOD(Process) (
            IN const XMEDIAPACKET *pInputPacket,
            IN const XMEDIAPACKET *pOutputPacket
            );
        
        XHawkMediaObject() :
            m_pTypeSettings(NULL),
            m_pDevice(NULL),
		    m_wMaxPacket(0),
            m_bEndpointAddress(0),
            m_fConnected(FALSE),
		    m_fOpened(FALSE),
		    m_fClosePending(FALSE),
            m_fRemovePending(FALSE),
            m_Reserved(0),
            m_lRefCount(0),
            m_pStreamingResources(NULL),
            m_pfnCallback(NULL),
            m_pvContext(NULL)
            {}

        static void InitializeClass(); //Initialize static members
	
		//
        //	Keeps track of the static list
		//	of objects
		//
		static XHawkMediaObject *sm_pMicrophones;	//Array of microphone instances
		static XHawkMediaObject *sm_pHeadphones;	//Array of headphone instances

    private:
		//
		//	Static tables that apply to all instances
		//	(or for all instances of one type.)s
		//

		static WAVEFORMATEX sm_MicrophoneWaveformat;
		static WAVEFORMATEX sm_HeadphoneWaveformat;

		static HAWK_TYPE_SETTINGS sm_MicrophoneSettings;
		static HAWK_TYPE_SETTINGS sm_HeadphoneSettings;
		
		//
		//	Information Detected During enumeration.
		//

		PHAWK_TYPE_SETTINGS m_pTypeSettings;
        IUsbDevice          *m_pDevice;
		WORD			    m_wMaxPacket;
        UCHAR			    m_bEndpointAddress;
		
		//
		//	Running Per Instance State Information
		//
        //  Notes on state flag.  Connecting
        //  and opening a device is synchronous.
        //  Closing a device is asynchronous, because
        //  the 
        
		UCHAR			   m_fConnected:1;
		UCHAR			   m_fOpened:1;
		UCHAR			   m_fClosePending:1;
        UCHAR			   m_fRemovePending:1;
		UCHAR			   m_Reserved:4;
        
        
        LONG			   m_lRefCount;

        //
        // callback values
        //

        PFNXMEDIAOBJECTCALLBACK    m_pfnCallback;
        PVOID                      m_pvContext;

	    //
		//	Streaming Resources (only needed for operation)
		//
		PHAWK_STREAMING_RESOURCES m_pStreamingResources;

        //
        //  Private help methods
        //
        HRESULT AllocateStreamingResources (ULONG ulMaxAttachedPackets);
        void FreeStreamingResources (void);
        void CloseEndpoint (void);
        static void CloseEndpointComplete (IN PURB, IN XHawkMediaObject *pThis);
        void ProgramTransfer(void);
        static void TransferComplete(IN PUSBD_ISOCH_TRANSFER_STATUS Status, IN XHawkMediaObject *pThis);
        void AbortMediaPackets(IN CHawkPacketQueue *pPacketQueue);

    //
    //  The XcreateHawkMediaObject factory method, and the
    //  USB interface methods, need to be friends.  They
    //  all would be members, but they must be C calleable.
    //
    friend HRESULT WINAPI
    XHawkCreateMediaObject(
      IN PXPP_DEVICE_TYPE XppDeviceType,
      IN DWORD dwPort,
      IN DWORD dwMaxAttachedPackets,
      OUT LPWAVEFORMATEX pwfxFormat OPTIONAL,
      OUT XMediaObject **ppXmediaObject
      );
    

    friend HRESULT WINAPI
    XHawkCreateMediaObjectInternal(
          IN PXPP_DEVICE_TYPE XppDeviceType,
          IN DWORD dwPort,
          IN DWORD dwMaxAttachedPackets,
          OUT LPWAVEFORMATEX pwfxFormat OPTIONAL,
          PFNXMEDIAOBJECTCALLBACK    pfnCallback,
          PVOID                      pvContext,
          OUT XMediaObject **ppXmediaObject
          );

    friend VOID HawkInit ();

    friend VOID HawkAddDevice (
                    IN IUsbDevice *Device
                    );

    friend VOID HawkRemoveDevice (
                    IN IUsbDevice *Device
                    );
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\dd\usb\hawk\makefile.inc ===
$(XDK_LIB_PATH)\$(TARGETNAME).lib: $(SDK_LIB_PATH)\$(TARGETNAME).lib
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\dd\usb\hawk\hawk2.cpp ===
/*++

Copyright (c) 1996-2000 Microsoft Corporation

Module Name:

    hawk.CPP

Abstract:


Environment:

    kernel mode

Revision History:


--*/

//*****************************************************************************
// I N C L U D E S
//*****************************************************************************
#include "hawk2.h"

#include "xvocver.h"

#if DBG || DEBUG_LOG

    ULONG               HawkDebugLevel=2;     // Level of debug output

#endif

//------------------------------------------------------------------------------
//  Declaration of static tables
//------------------------------------------------------------------------------
XHawkMediaObject *XHawkMediaObject::sm_pMicrophones = NULL;
XHawkMediaObject *XHawkMediaObject::sm_pHeadphones = NULL;
USHORT            XHawkMediaObject::sm_AvailableHeadphoneResources = 0;
USHORT            XHawkMediaObject::sm_AvailableMicrophoneResources = 0;
PHAWK_STREAMING_RESOURCES XHawkMediaObject::sm_pFreeStreamingResources = NULL;
HAWK_SAMPLE_RATE_INFORMATION XHawkMediaObject::sm_HawkSampleRates[HAWK_SAMPLE_RATE_COUNT] = 
{
    { 8000, 16, 0},     // 8.000 kHz
    {11025, 22, 40},    //11.025 kHz
    {16000, 32, 0},     //16.000 kHz
    {22050, 44, 20},    //22.050 kHz
    {24000, 48, 0}      //24.000 kHz
};
PUCHAR XHawkMediaObject::sm_pRateIndices = NULL;
PUCHAR XHawkMediaObject::sm_pRateIndexRefCounts = NULL;

//------------------------------------------------------------------------------
//  Declare Hawk types and class.
//------------------------------------------------------------------------------
DECLARE_XPP_TYPE(XDEVICE_TYPE_VOICE_MICROPHONE)
DECLARE_XPP_TYPE(XDEVICE_TYPE_VOICE_HEADPHONE)
USB_DEVICE_TYPE_TABLE_BEGIN(Hawk)
USB_DEVICE_TYPE_TABLE_ENTRY(XDEVICE_TYPE_VOICE_MICROPHONE),
USB_DEVICE_TYPE_TABLE_ENTRY(XDEVICE_TYPE_VOICE_HEADPHONE)
USB_DEVICE_TYPE_TABLE_END()
USB_CLASS_DRIVER_DECLARATION(Hawk, USB_DEVICE_CLASS_AUDIO, 0xFF, 0xFF)
USB_CLASS_DRIVER_DECLARATION_DUPLICATE(Hawk, 1, XBOX_DEVICE_CLASS_AUDIO_DEVICE, 0xFF, 0xFF)

#pragma data_seg(".XPP$ClassHawk")
USB_CLASS_DECLARATION_POINTER(Hawk)
USB_CLASS_DECLARATION_POINTER_DUPLICATE(Hawk, 1)
#pragma data_seg(".XPP$Data")

USB_RESOURCE_REQUIREMENTS HAWK_gResourceRequirements = 
    {USB_CONNECTOR_TYPE_HIGH_POWER, 0, 2, 1, 0, 0, 0, 0, 2, HAWK_ISOCH_MAX_ATTACH_BUFFERS};

//------------------------------------------------------------------------------
// USB Class Driver Interface
//------------------------------------------------------------------------------
#pragma code_seg(".XPPCINIT")
EXTERNUSB VOID
HawkInit (IUsbInit *pUsbInit)
{
    DBGPRINT(3, ("enter: HawkInit\n"));
    ULONG MicrophoneCount;
    ULONG HeadphoneCount; 
    
    //sentry against double init, required because we have two driver
    //table entries (look in the tables above) - this is still in there to support some older firmware.
    #pragma BUGBUG("Supporting USB_DEVICE_CLASS_AUDIO for old Hawk FW, we don't support any USB audio, so this must go at some point.")
    static BOOL fInitialized = FALSE;
    if(fInitialized) return;
    fInitialized = TRUE;

    
    if(pUsbInit->UseDefaultCount())
    {
        MicrophoneCount = HAWK_DEFAULT_MAX_OPENED;
        HeadphoneCount = HAWK_DEFAULT_MAX_OPENED;
    } else
    {
        MicrophoneCount = pUsbInit->GetMaxDeviceTypeCount(XDEVICE_TYPE_VOICE_MICROPHONE);
        HeadphoneCount = pUsbInit->GetMaxDeviceTypeCount(XDEVICE_TYPE_VOICE_HEADPHONE);
        ULONG ulMaxPorts = XGetPortCount();
        RIP_ON_NOT_TRUE_WITH_MESSAGE(MicrophoneCount <= ulMaxPorts, "XInitDevices: requested more XDEVICE_TYPE_VOICE_MICROPHONE than available ports.");
        if(MicrophoneCount > ulMaxPorts) MicrophoneCount = ulMaxPorts;
        RIP_ON_NOT_TRUE_WITH_MESSAGE(HeadphoneCount <= ulMaxPorts, "XInitDevices: requested more XDEVICE_TYPE_VOICE_HEADPHONE than available ports.");
        if(HeadphoneCount > ulMaxPorts) HeadphoneCount = ulMaxPorts;
    }
    //
    //  Register for microphones and headphone
    //
    HAWK_gResourceRequirements.MaxDevices = (UCHAR)MicrophoneCount;
    pUsbInit->RegisterResources(&HAWK_gResourceRequirements);
    HAWK_gResourceRequirements.MaxDevices = (UCHAR)HeadphoneCount;
    pUsbInit->RegisterResources(&HAWK_gResourceRequirements);
    
    XHawkMediaObject::InitializeClass(MicrophoneCount, HeadphoneCount);

    DBGPRINT(3, ("exit:  HawkInit\n"));    
    return;
}
#pragma code_seg(".XPPCODE")

EXTERNUSB VOID
HawkAddDevice(
     IN IUsbDevice *Device
     )
{
	const USB_ENDPOINT_DESCRIPTOR   *pEndpointDescriptor;
    XHawkMediaObject *pHawkMediaObject = NULL;
    DWORD dwPort;

    //
	//  Get the device port and slot
	//

    dwPort = Device->GetPort();
    if(dwPort >= 16)
    {
        DBGPRINT(2,("AddDevice: dwPort %d, bottom slot, not supported!\n",  dwPort));
        Device->AddComplete(USBD_STATUS_UNSUPPORTED_DEVICE);
        return;
    }

    //
    //  get an endpoint descriptor for the isoch endpoint
    //  (we don't know the direction (microphone or
    //  headphone).  Try input first.
    //

    pEndpointDescriptor = Device->GetEndpointDescriptor(
                                USB_ENDPOINT_TYPE_ISOCHRONOUS,
                                TRUE,
                                0);
    if(pEndpointDescriptor)
    {
        pHawkMediaObject = &XHawkMediaObject::sm_pMicrophones[dwPort];
        pHawkMediaObject->m_fMicrophone = TRUE;
    }
    else {
        pEndpointDescriptor = Device->GetEndpointDescriptor(
                                USB_ENDPOINT_TYPE_ISOCHRONOUS,
                                FALSE,
                                0);
        if(pEndpointDescriptor)
        {
            pHawkMediaObject = &XHawkMediaObject::sm_pHeadphones[dwPort];
            pHawkMediaObject->m_fMicrophone = FALSE;
        } else 
        {
            ASSERT(FALSE && "Isoch endpoint not found");
            Device->AddComplete(USBD_STATUS_UNSUPPORTED_DEVICE);
            return;
        }
    }
    
    //
    //  Check and initialize the state 
    //
    pHawkMediaObject->m_fConnected = TRUE;

    //
    // Use XHawkMediaObject as the device extension
    //
    
    Device->SetExtension(pHawkMediaObject);
    pHawkMediaObject->m_pDevice = Device;
    
    //
    //  Record the endpoint address, and wMaxPacket
    //

    pHawkMediaObject->m_bEndpointAddress = pEndpointDescriptor->bEndpointAddress;
    pHawkMediaObject->m_wMaxPacket = pEndpointDescriptor->wMaxPacketSize;

    DBGPRINT(3,("IsochMaxPacket = %x, bEndpointAddress = 0x%02x\n, Interface = %d\n", 
                     (ULONG)pEndpointDescriptor->wMaxPacketSize,
                     (ULONG)pEndpointDescriptor->bEndpointAddress,
                     Device->GetInterfaceNumber()
                     ));

    //
    // Set the class specific type so it can be enumerated
    //
    Device->SetClassSpecificType(
                pHawkMediaObject->m_fMicrophone ? HAWK_MICROPHONE_CLASS_SPECIFIC_TYPE : HAWK_HEADPHONE_CLASS_SPECIFIC_TYPE
                );

    Device->AddComplete(USBD_STATUS_SUCCESS);
}


EXTERNUSB VOID
HawkRemoveDevice (
    IN IUsbDevice *Device
    )
{
    XHawkMediaObject *pHawkMediaObject = (XHawkMediaObject *)Device->GetExtension();
 
    //
    //  Mark the device as not connected 
    //

    pHawkMediaObject->m_fConnected = FALSE;

    //
    //  If the device is opened, we cannot call
    //  remove complete, because there is
    //  an endpoint open (or in the process
    //  of being closed.)
    //

    //
    //  Mark the media object remove pending,
    //
    pHawkMediaObject->m_fRemovePending = TRUE;

    //
    //  If the device is ready, we should close the endpoints
    //
    if(pHawkMediaObject->m_fReady)
    {
        //
        //  If the endpoint is not in the process
        //  of being closed, then start that process
        //
        pHawkMediaObject->CloseEndpoint();
    } else
    //
    //  The media object wasn't opened, so we can
    //  call remove complete
    //
    {
        //
        //  If a close is pending then we 
        //  cannot call RemoveComplete, but
        //  when the close completes it will
        //  see the m_fRemovePending flag.
        //
        if(!pHawkMediaObject->m_fClosePending)
        {
            pHawkMediaObject->m_pDevice = NULL;
            Device->SetExtension(NULL);
            Device->RemoveComplete();
            pHawkMediaObject->m_fRemovePending = FALSE;
        }
    }
}    

//------------------------------------------------------------------------------
//  We do not include the CRT, but we need new.
//  we declare it static, so we don't conflict on linking
//  with other modules overriding new.
//------------------------------------------------------------------------------
#pragma warning(disable:4211)
static __inline void * __cdecl operator new(size_t memSize)
    {
        return ExAllocatePoolWithTag(
                            memSize,
                            'kwah'
                            );
    }
static __inline void __cdecl operator delete(void *pMemory)
    {
        ExFreePool(pMemory);
    }
#pragma warning(default:4211)


//------------------------------------------------------------------------------
// XHawkMediaObject
//------------------------------------------------------------------------------
#pragma code_seg(".XPPCINIT")
void XHawkMediaObject::InitializeClass(ULONG ulMicrophoneCount, ULONG ulHeadphoneCount)
{
    //
    //  Allocate a microphone and a headphone
    //  instance for each of the ports up front.
    //
    ULONG ulPortCount = XGetPortCount();
    ULONG ulTotalStreamingResources = ulHeadphoneCount + ulMicrophoneCount;
    PHAWK_STREAMING_RESOURCES pStreamingResourceArray;
    
    //
    //  Handle insane case, where the user requested no microphone or headphones, but
    //  some how we are here anyway.
    //
    if(ulTotalStreamingResources)
        pStreamingResourceArray = new HAWK_STREAMING_RESOURCES[ulTotalStreamingResources];

    
    sm_pHeadphones = new XHawkMediaObject[ulPortCount];
    sm_pMicrophones = new XHawkMediaObject[ulPortCount];
    sm_pRateIndices = new UCHAR[ulPortCount];
    sm_pRateIndexRefCounts = new UCHAR[ulPortCount];
    
    RIP_ON_NOT_TRUE_WITH_MESSAGE(sm_pHeadphones, "XInitDevices failed due to insufficent memory.  There is no graceful recovery.");
    RIP_ON_NOT_TRUE_WITH_MESSAGE(sm_pMicrophones, "XInitDevices failed due to insufficent memory.  There is no graceful recovery.");
    RIP_ON_NOT_TRUE_WITH_MESSAGE(sm_pRateIndices, "XInitDevices failed due to insufficent memory.  There is no graceful recovery.");
    RIP_ON_NOT_TRUE_WITH_MESSAGE(sm_pRateIndexRefCounts, "XInitDevices failed due to insufficent memory.  There is no graceful recovery.");
    RIP_ON_NOT_TRUE_WITH_MESSAGE(pStreamingResourceArray, "XInitDevices failed due to insufficent memory.  There is no graceful recovery.");
    
    //
    //  Make a free list out of pStreamingResourceArray
    //
    sm_pFreeStreamingResources = NULL;
    for(ULONG i=0; i < ulTotalStreamingResources; i++)
    {
        pStreamingResourceArray[i].pNextFree = sm_pFreeStreamingResources;
        sm_pFreeStreamingResources = &pStreamingResourceArray[i];
    }
    //
    //  Initialize the number of available microphone and headphone resources
    //
    sm_AvailableMicrophoneResources = (USHORT)ulMicrophoneCount;
    sm_AvailableHeadphoneResources = (USHORT)ulHeadphoneCount;


    //
    //  Initially none of the rates are set.
    //
    RtlZeroMemory(sm_pRateIndexRefCounts, sizeof(UCHAR)*ulPortCount);
    
    //
    //  We could loop over them and morph them into
    //  microphones and headphones, but we might
    //  as well leave that until an AddDevice.
    //

}
#pragma code_seg(".XPPCODE")

STDMETHODIMP_(ULONG) XHawkMediaObject::AddRef (void)
{
	return (ULONG) InterlockedIncrement(&m_lRefCount);
}

STDMETHODIMP_(ULONG) XHawkMediaObject::Release (void)
{
	LONG lRefCount;
	lRefCount = InterlockedDecrement(&m_lRefCount);
	//
	//	Check for decrement below zero
	//
	if(0>lRefCount)
	{
		DBGPRINT(1, ("XHawkMediaObject: Reference Count Error: Count went below 0!\n"));
		return 0;
	} else if (0==lRefCount)
	{
        FreeStreamingResources();
	}
	return (ULONG)lRefCount;
}

STDMETHODIMP
XHawkMediaObject::GetInfo (
    OUT PXMEDIAINFO pInfo
    )
{
    //
    //  If this assert fails the reference count is hosed
    //  or the caller called us after releasing the last
    //  reference.
    //
    ASSERT(m_pStreamingResources);
    
    //
    // align values to our block size. In gets CEILed, out gets FLOORed
    //
    if (m_fMicrophone) {
        pInfo->dwFlags =
	        XMO_STREAMF_FIXED_SAMPLE_SIZE |
            XMO_STREAMF_OUTPUT_ASYNC;
        pInfo->dwOutputSize = 
            m_pStreamingResources->BytesPerUSBFrame * HAWK_MIN_PACKET_FRAMES;
        pInfo->dwInputSize = 0;
    } else {
        pInfo->dwFlags =
	        XMO_STREAMF_FIXED_SAMPLE_SIZE |
            XMO_STREAMF_INPUT_ASYNC;
        pInfo->dwInputSize = 
            m_pStreamingResources->BytesPerUSBFrame * HAWK_MIN_PACKET_FRAMES;
        pInfo->dwOutputSize = 0;
    }
    
    //
    //  Look ahead is 0.
    //
    pInfo->dwMaxLookahead = 0;
    
    return S_OK;
}

STDMETHODIMP 
XHawkMediaObject::Flush (void)
{
    return S_OK;
}
        

STDMETHODIMP 
XHawkMediaObject::Discontinuity (void)
{
    return S_OK;
}
        

STDMETHODIMP
XHawkMediaObject::GetStatus (
            OUT DWORD *pdwFlags
            )
{
    RIP_ON_NOT_TRUE("XHawkMediaObject::GetStatus", NULL!=pdwFlags);

    KIRQL oldIrql = KeRaiseIrqlToDpcLevel();
    
    ASSERT(m_pStreamingResources);
    if( m_fReady && m_pStreamingResources->Free.GetHead())
    {
        if(m_fMicrophone)
        {
           *pdwFlags = XMO_STATUSF_ACCEPT_OUTPUT_DATA;
        } else
        {
           *pdwFlags = XMO_STATUSF_ACCEPT_INPUT_DATA;            
        }
    } else
    {
        *pdwFlags = 0;        
    }
    
    KeLowerIrql(oldIrql);
    
    return S_OK;
}
        
HRESULT
XHawkMediaObject::Process (
    IN LPCXMEDIAPACKET pInputPacket,
    IN LPCXMEDIAPACKET pOutputPacket
    )
{
    HRESULT hr = S_OK;
    LPCXMEDIAPACKET pMediaPacket;
    
    if(m_fMicrophone)
    {
        RIP_ON_NOT_TRUE("Hawk Microphone XMediaObject::Process", NULL==pInputPacket);
        RIP_ON_NOT_TRUE("Hawk Microphone XMediaObject::Process", NULL!=pOutputPacket);
        RIP_ON_NOT_TRUE("Hawk Microphone XMediaObject::Process", 
                         pOutputPacket->dwMaxSize > (DWORD)m_pStreamingResources->BytesPerUSBFrame * HAWK_MIN_PACKET_FRAMES);
        RIP_ON_NOT_TRUE("Hawk Microphone XMediaObject::Process", 
                         0 == pOutputPacket->dwMaxSize%HAWK_BYTES_PER_SAMPLE);
        pMediaPacket = pOutputPacket;
         
    } else 
    {
        RIP_ON_NOT_TRUE("Hawk Headphone XMediaObject::Process", NULL!=pInputPacket);
        RIP_ON_NOT_TRUE("Hawk Headphone XMediaObject::Process", NULL==pOutputPacket);
        RIP_ON_NOT_TRUE("Hawk Headphone XMediaObject::Process", 
                         pInputPacket->dwMaxSize > (DWORD)m_pStreamingResources->BytesPerUSBFrame * HAWK_MIN_PACKET_FRAMES);
        RIP_ON_NOT_TRUE("Hawk Headphone XMediaObject::Process", 
                         0 == pInputPacket->dwMaxSize%HAWK_BYTES_PER_SAMPLE);
        pMediaPacket = pInputPacket;
    }

    // Raise IRQL after rips
    KIRQL oldIrql = KeRaiseIrqlToDpcLevel();
    if(m_fReady)
    {

        PHAWK_PACKET_CONTEXT pPacketContext = m_pStreamingResources->Free.RemoveHead();    
        if(pPacketContext)
        {

            //
            //  Initialize the packet
            //
            
            XMOAcceptPacket(pMediaPacket);

            //
            //  Copy the media packet into the hawk packet context.
            //  The structure is identical except hawk has one extra
            //  field, for queuing
            //
            
            RtlCopyMemory(&pPacketContext->MediaPacket, pMediaPacket, sizeof(XMEDIAPACKET));
                
            //
            //  Insert the packet onto the pending programming queue.
            //

            m_pStreamingResources->PendingProgram.InsertTail(pPacketContext);
                
            //
            //  Jog the programming routine.
            //

            ProgramTransfer();
            
        } else
        {
            hr = HRESULT_FROM_WIN32(ERROR_BUSY);
        }
    } else
    {
        hr = HRESULT_FROM_WIN32(ERROR_DEVICE_NOT_CONNECTED);
    }

    if(FAILED(hr))
    {
        XMOCompletePacket(pMediaPacket, 0, m_pfnCallback, m_pvContext, XMEDIAPACKET_STATUS_FAILURE);
    }

    KeLowerIrql(oldIrql);
    return hr;

}

EXTERN_C HRESULT WINAPI
XVoiceCreateMediaObjectInternal(
      IN PXPP_DEVICE_TYPE XppDeviceType,
      IN DWORD dwPort,
      IN DWORD dwMaxAttachedPackets,
      IN LPWAVEFORMATEX pwfxFormat,
      IN PFNXMEDIAOBJECTCALLBACK    pfnCallback,
      IN PVOID                      pvContext,
      OUT XMediaObject **ppXmediaObject
      )
{
    HRESULT hr;
    XHawkMediaObject *pHawkMediaObject = NULL;

    hr = XVoiceCreateMediaObject(
          XppDeviceType,
          dwPort,
          dwMaxAttachedPackets,
          pwfxFormat,
          ppXmediaObject
          );

    if (SUCCEEDED(hr)) {

        //
        // save callback and context
        //

        pHawkMediaObject = (XHawkMediaObject *) *ppXmediaObject;
        pHawkMediaObject->m_pvContext = pvContext;
        pHawkMediaObject->m_pfnCallback = pfnCallback;

    }


    return hr;

}


XBOXAPI EXTERN_C HRESULT WINAPI
XVoiceCreateMediaObject(
      IN PXPP_DEVICE_TYPE XppDeviceType,
      IN DWORD dwPort,
      IN DWORD dwMaxAttachedPackets,
      IN PWAVEFORMATEX  pwfxFormat  OPTIONAL,
      OUT XMediaObject **ppXmediaObject
      )
/*++
    Routine Description:
        This is the factory method for XHawkMediaObjects.
        It is an exported API for games.
--*/
{
    //
    //  We need the class Id to find the device.
    //
	
    KIRQL		     oldIrql;
    PNP_CLASS_ID     classId;
    HRESULT          hr = S_OK;
    XHawkMediaObject *pHawkMediaObject = NULL;
    UCHAR            ucRateIndex=2; //default rate is 16 kHz, at index 2 in the rate table.
    
    //
    //  Verify that XInitDevices has been called.
    //
    RIP_ON_NOT_TRUE_WITH_MESSAGE(XPP_XInitDevicesHasBeenCalled, "XVoiceCreateMediaObject: XInitDevices must be called first!");

    //
    //  Verify port
    //
    RIP_ON_NOT_TRUE(XVoiceCreateMediaObject, dwPort<XGetPortCount());

    //
    //  Verify that a reasonable dwMaxAttachedPackets was passed.
    //
    RIP_ON_NOT_TRUE(XVoiceCreateMediaObject, (dwMaxAttachedPackets > 1));

    //
    //  Use raised Irql to synchronize the allocation
    //  and opening of instances
    //

    oldIrql = KeRaiseIrqlToDpcLevel();

    //
    //  Claim an existing instance of XHawkMediaObject
    //
	
    if(XDEVICE_TYPE_VOICE_MICROPHONE == XppDeviceType)
	{
        if(0==XHawkMediaObject::sm_AvailableMicrophoneResources)
        {
            KeLowerIrql(oldIrql);
            RIP("XVoiceCreateMediaObject: attempt to exceed number of mircophones requested in XInitDevices.\n");
            return E_OUTOFMEMORY;
        }
        pHawkMediaObject = &XHawkMediaObject::sm_pMicrophones[dwPort];
    } else if(XDEVICE_TYPE_VOICE_HEADPHONE == XppDeviceType)
    {
        if(0==XHawkMediaObject::sm_AvailableHeadphoneResources)
        {
            KeLowerIrql(oldIrql);
            RIP("XVoiceCreateMediaObject: attempt to exceed number of headphones requested in XInitDevices.\n");
            return E_OUTOFMEMORY;
        }
        pHawkMediaObject = &XHawkMediaObject::sm_pHeadphones[dwPort];
    }
#if DBG    
    else {
        KeLowerIrql(oldIrql);
        RIP("XVoiceCreateMediaObject: XppDeviceType is not a valid type for XVoiceCreateMediaObject\n");
	}
#endif //DBG

    //
    //  Check the wave format
    //
    if(pwfxFormat)
    {
        //
        //  Verify that the setting are supported
        //
#if DBG
        KeLowerIrql(oldIrql);
        RIP_ON_NOT_TRUE(XVoiceCreateMediaObject, pwfxFormat->wFormatTag==WAVE_FORMAT_PCM);
        RIP_ON_NOT_TRUE(XVoiceCreateMediaObject, pwfxFormat->nChannels==1);
        RIP_ON_NOT_TRUE(XVoiceCreateMediaObject, 2*pwfxFormat->nSamplesPerSec==pwfxFormat->nAvgBytesPerSec);
        RIP_ON_NOT_TRUE(XVoiceCreateMediaObject, pwfxFormat->wBitsPerSample==16);
        RIP_ON_NOT_TRUE(XVoiceCreateMediaObject, pwfxFormat->nBlockAlign == 2);
        oldIrql = KeRaiseIrqlToDpcLevel();
#endif

        //
        //  First validate rate against allowed rates.
        //
        for(ucRateIndex=0; ucRateIndex < HAWK_SAMPLE_RATE_COUNT; ucRateIndex++)
        {
            if(pwfxFormat->nSamplesPerSec == (DWORD)XHawkMediaObject::sm_HawkSampleRates[ucRateIndex].nSamplePerSecond)
            {
                break;
            }
        }
#if DBG
        if(HAWK_SAMPLE_RATE_COUNT == ucRateIndex)
        {
            KeLowerIrql(oldIrql);
            RIP("XVoiceCreateMediaObject: pWaveFormatEx->nSamplesPerSec has illegal value");
        }
#endif //DBG
    }

    if( pHawkMediaObject->m_fOpened )
    {
        pHawkMediaObject = NULL;
        hr = HRESULT_FROM_WIN32(ERROR_SHARING_VIOLATION);
    } else if (pHawkMediaObject->m_fConnected)
    {
        //
        //  Set the sample rate
        //
        if(XHawkMediaObject::sm_pRateIndexRefCounts[dwPort])
        //
        //  If the reference count is non-zero, then the
        //  other half of this device has set the rate
        //  (microphone and headphone must have the same rate)
        //
        {
            XHawkMediaObject::sm_pRateIndexRefCounts[dwPort]++;
            //
            //  Verify that the rates match
            //
            if(XHawkMediaObject::sm_pRateIndices[dwPort]!=ucRateIndex)
            {
                // Be kinder here, return an error, I could vaguely see this slipping through testing.
                KeLowerIrql(oldIrql);
                RIP("XVoiceCreateMediaObject: Attempt to open microphone and headphone of same device with different sampling rates.");
                return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
            }
        } else
        //
        //  The rate hasn't been set yet, so set it
        //
        {
            XHawkMediaObject::sm_pRateIndexRefCounts[dwPort] = 1;
            XHawkMediaObject::sm_pRateIndices[dwPort]=ucRateIndex;
            hr = pHawkMediaObject->SetSampleRate(ucRateIndex, oldIrql);
			hr = pHawkMediaObject->SetAGC(HAWK_AGC_ON, oldIrql);
        }

        //
        //  Allocate the streaming resources.
        //
        if(SUCCEEDED(hr))
        {
            hr = pHawkMediaObject->AllocateStreamingResources(dwMaxAttachedPackets, ucRateIndex);
        }
        if(SUCCEEDED(hr))
        {
            pHawkMediaObject->m_fOpened = TRUE;
            pHawkMediaObject->m_fReady = TRUE;
            pHawkMediaObject->m_lRefCount = 1;
        } else
        {
           pHawkMediaObject = NULL;
           XHawkMediaObject::sm_pRateIndexRefCounts[dwPort]--;
        }
    } else
    {
        pHawkMediaObject = NULL;
        hr = HRESULT_FROM_WIN32(ERROR_DEVICE_NOT_CONNECTED);
    }

    // Record that we opened a device
    if(pHawkMediaObject)
    {
        if(pHawkMediaObject->m_fMicrophone) XHawkMediaObject::sm_AvailableMicrophoneResources--;
        else XHawkMediaObject::sm_AvailableHeadphoneResources--;
    }

    //
    //  Restore Irql since the stuff that needs
    //  to be synchronous is done.
    //
    KeLowerIrql(oldIrql);
    
    *ppXmediaObject = pHawkMediaObject;	
    return hr;
}
            
HRESULT XHawkMediaObject::SetSampleRate(UCHAR ucRateIndex, KIRQL BaseIrql)
/*++
    Routine Description:
        Sends a command to hawk to change the sample rate.  This routine opens the
        default pipe. Sends a vendor specific SetFeature to change the rate.  The closes
        the default pipe.  The routine is synchronous, which means it must drop to below
        DISPATCH_LEVEL.
    Parameters:
        ucRateIndex - rate index to send to the device.
        BaseIrql - the lowest irql we are permitted to drop to.
    Comments:
        Must be called at DPC level, BaseIrql must be lower than DPC.
--*/
{
    USBD_STATUS usbdStatus;
    
    //
    //  Open the default endpoints
    //
    URB Urb;
    USB_BUILD_OPEN_DEFAULT_ENDPOINT(&Urb.OpenEndpoint);
    usbdStatus = m_pDevice->SubmitRequest(&Urb);
    if(USBD_ERROR(usbdStatus))
    {
        return HRESULT_FROM_WIN32(IUsbDevice::Win32FromUsbdStatus(usbdStatus));
    }

    //
    //  While still at DPC, set the m_fClosePending flag.  This will prevent HawkRemoveDevice
    //  from calling RemoveComplete on us.  We take on the burden of checking for m_fRemovePending
    //  when clearing this flag.
    //

    m_fClosePending = TRUE;   
    //
    //  Drop to BaseIrql so we can start doing the asynchronous parts synchronously.
    //

    ASSERT(BaseIrql < DISPATCH_LEVEL);
    KeLowerIrql(BaseIrql);

    //
    //  Send the SET_FEATURE(SampleRate) command.
    //

    USB_BUILD_CONTROL_TRANSFER(
        &Urb.ControlTransfer,
        NULL,   //Use the default endpoint
        NULL,   //No transfer buffer
        0,      
        0,
        NULL,   //Do this transfer synchronously
        0,      
        FALSE,  //Short Transfer NOT OK
        USB_VENDOR_COMMAND | USB_COMMAND_TO_INTERFACE | USB_HOST_TO_DEVICE,
        USB_REQUEST_SET_FEATURE,
        (USHORT) 0x0100 | ucRateIndex, // DD: ucRateIndex, //Rate Index to set, see Talon Specification.
        HAWK_VENDOR_FEATURE_SAMPLE_RATE,
        0); //Transfer length is zero

    usbdStatus = m_pDevice->SubmitRequest(&Urb);

    //
    //  Close the default endpoint
    //
    USB_BUILD_CLOSE_DEFAULT_ENDPOINT(&Urb.CloseEndpoint, NULL, NULL);
    m_pDevice->SubmitRequest(&Urb);

    //
    //  Now all the synchronous stuff is done we can
    //  go back up to DISPATCH_LEVEL
    //

    KeRaiseIrqlToDpcLevel();

    //
    //  We are not really open yet, nor are we pending a close.
    //

    m_fOpened = FALSE; 
    m_fClosePending = FALSE; 

    //
    //  Check the remove pending flag, and complete the remove
    //  it one was pending.
    //  Also fail this request with ERROR_DEVICE_NOT_CONNECTED.
    //
    if(m_fRemovePending)
    {
        m_pDevice->SetExtension(NULL);
        m_pDevice->RemoveComplete();
        m_pDevice = NULL;
        m_fRemovePending = FALSE;
        return HRESULT_FROM_WIN32(ERROR_DEVICE_NOT_CONNECTED);
    }
    
    //
    //  If we are supporting fixed rate devices
    //  tolerate a failure, if the
    //  requested rate was 16 ksamples/second
    #ifdef HAWK_SUPPORT_FIXED_RATE
    if(ucRateIndex==2)
    {
        usbdStatus = USBD_STATUS_SUCCESS;
    }
    #endif //HAWK_SUPPORT_FIXED_RATE

    //
    //  Return the status of the request to set the data rate.  
    //

    return HRESULT_FROM_WIN32(IUsbDevice::Win32FromUsbdStatus(usbdStatus));
}

HRESULT XHawkMediaObject::SetAGC(UCHAR ucAGC, KIRQL BaseIrql)
/*++
    Routine Description:
        Sends a command to hawk to change the sample rate.  This routine opens the
        default pipe. Sends a vendor specific SetFeature to change the rate.  The closes
        the default pipe.  The routine is synchronous, which means it must drop to below
        DISPATCH_LEVEL.
    Parameters:
        ucAGC - rate index to send to the device.
        BaseIrql - the lowest irql we are permitted to drop to.
    Comments:
        Must be called at DPC level, BaseIrql must be lower than DPC.
--*/
{
    USBD_STATUS usbdStatus;
    
	//
    //  Open the default endpoints
    //
    URB Urb;
    USB_BUILD_OPEN_DEFAULT_ENDPOINT(&Urb.OpenEndpoint);
    usbdStatus = m_pDevice->SubmitRequest(&Urb);
    if(USBD_ERROR(usbdStatus))
    {
        return HRESULT_FROM_WIN32(IUsbDevice::Win32FromUsbdStatus(usbdStatus));
    }

    //
    //  While still at DPC, set the m_fClosePending flag.  This will prevent HawkRemoveDevice
    //  from calling RemoveComplete on us.  We take on the burden of checking for m_fRemovePending
    //  when clearing this flag.
    //

    m_fClosePending = TRUE;   
    //
    //  Drop to BaseIrql so we can start doing the asynchronous parts synchronously.
    //

    ASSERT(BaseIrql < DISPATCH_LEVEL);
    KeLowerIrql(BaseIrql);

    //
    //  Send the SET_FEATURE(SampleRate) command.
    //

    USB_BUILD_CONTROL_TRANSFER(
        &Urb.ControlTransfer,
        NULL,   //Use the default endpoint
        NULL,   //No transfer buffer
        0,      
        0,
        NULL,   //Do this transfer synchronously
        0,      
        FALSE,  //Short Transfer NOT OK
        USB_VENDOR_COMMAND | USB_COMMAND_TO_INTERFACE | USB_HOST_TO_DEVICE,
        USB_REQUEST_SET_FEATURE,
        (USHORT)ucAGC, //ON/OFF, see Talon Specification.
        (USHORT)HAWK_VENDOR_FEATURE_AGC, 
        0); //Transfer length is zero

    usbdStatus = m_pDevice->SubmitRequest(&Urb);

    //
    //  Close the default endpoint
    //
    USB_BUILD_CLOSE_DEFAULT_ENDPOINT(&Urb.CloseEndpoint, NULL, NULL);
    m_pDevice->SubmitRequest(&Urb);

    //
    //  Now all the synchronous stuff is done we can
    //  go back up to DISPATCH_LEVEL
    //

    KeRaiseIrqlToDpcLevel();

    //
    //  We are not really open yet, nor are we pending a close.
    //

    m_fOpened = FALSE; 
    m_fClosePending = FALSE; 

    //
    //  Check the remove pending flag, and complete the remove
    //  it one was pending.
    //  Also fail this request with ERROR_DEVICE_NOT_CONNECTED.
    //
    if(m_fRemovePending)
    {
        m_pDevice->SetExtension(NULL);
        m_pDevice->RemoveComplete();
        m_pDevice = NULL;
        m_fRemovePending = FALSE;
        return HRESULT_FROM_WIN32(ERROR_DEVICE_NOT_CONNECTED);
    }
    
    //
    //  Return the status of the request to set the data rate.  
    //
    return HRESULT_FROM_WIN32(IUsbDevice::Win32FromUsbdStatus(usbdStatus));
}


HRESULT XHawkMediaObject::AllocateStreamingResources(ULONG ulMaxAttachedPackets, ULONG ulRateIndex)
/*++
    Routine Description:
        This is a helper function called by Factory Method,
        XVoiceCreateMediaObject, to allocate resources for
        providing streaming.
--*/
{
    ULONG i;
    
    //
    //  Allocate memory for Attached Packets
    //
    PHAWK_PACKET_CONTEXT pPacketContextArray  = new HAWK_PACKET_CONTEXT[ulMaxAttachedPackets];
    if(!pPacketContextArray) return E_OUTOFMEMORY;
    RtlZeroMemory(pPacketContextArray, sizeof(HAWK_PACKET_CONTEXT)*ulMaxAttachedPackets);

    //
    //  Grab a free streaming resources  (there has to be one
    //  at this point or there is a bug somewhere in this driver.)
    //
    PHAWK_STREAMING_RESOURCES pResources = sm_pFreeStreamingResources;
    ASSERT(pResources);
    sm_pFreeStreamingResources = pResources->pNextFree;
    RtlZeroMemory(pResources, sizeof(HAWK_STREAMING_RESOURCES));
    
    //
    // Populate the free list of packet contexts
    //
    pResources->m_pContextArray = pPacketContextArray;
    for(i=0; i < ulMaxAttachedPackets; i++)
    {
        pResources->Free.InsertTail(pPacketContextArray + i);
    }

    //
    //  Copy the sample rate parameters from the rate table into the
    //  pResources structure for quick access.
    //

    pResources->BytesPerUSBFrame = sm_HawkSampleRates[ulRateIndex].BytesPerUSBFrame;
    pResources->ExtraSampleInterval = sm_HawkSampleRates[ulRateIndex].ExtraSampleInterval;
    pResources->AvailableTransferContexts = HAWK_TRANSFER_CONTEXT_BOTH;
    //pResources->ProgrammedFrame = 0; //Not necessary since the memory was zeroed.
    pResources->TransferContext[0].pHawkMediaObject =
    pResources->TransferContext[1].pHawkMediaObject = this;
    pResources->TransferContext[0].ucContextNumber = HAWK_TRANSFER_CONTEXT_0;
    pResources->TransferContext[1].ucContextNumber = HAWK_TRANSFER_CONTEXT_1;

    //
    //  Open the isoch endpoint
    //

    URB_ISOCH_OPEN_ENDPOINT OpenUrb;
    USB_BUILD_ISOCH_OPEN_ENDPOINT(
                &OpenUrb,
                m_bEndpointAddress,
                m_wMaxPacket,
                0);
    USBD_STATUS status = m_pDevice->SubmitRequest((PURB)&OpenUrb);
    
    if(USBD_ERROR(status))
    {
        delete [] pPacketContextArray;
        pResources->pNextFree = sm_pFreeStreamingResources;
        sm_pFreeStreamingResources = pResources;
        return HRESULT_FROM_WIN32(IUsbDevice::Win32FromUsbdStatus(status));
    }
    pResources->EndpointHandle = OpenUrb.EndpointHandle;

    //
    //  start the stream (since we don't have a start API)
    //

    URB_ISOCH_START_TRANSFER StartTransferUrb;
    USB_BUILD_ISOCH_START_TRANSFER(
        &StartTransferUrb,
        pResources->EndpointHandle,
        0,
        URB_FLAG_ISOCH_START_ASAP
        );
    status = m_pDevice->SubmitRequest((PURB)&StartTransferUrb);
    ASSERT(USBD_SUCCESS(status));
        
    //
    //  The stream should be ready to go, we just need to
    //  attach transfers.
    //

    m_pStreamingResources = pResources;

    return S_OK;
}

void XHawkMediaObject::CloseEndpoint( void )
{
    ASSERT(m_pStreamingResources);
    ASSERT(m_pStreamingResources->EndpointHandle);
    
    //
    //  The device is not ready, if the endpoint is not open.
    //

    m_fReady = FALSE;
    
    if(m_fClosingEndpoint) return;
    m_fClosingEndpoint = TRUE;

    //
    //  Build and submit the close URB for the Isoch endpoint
    //

    USB_BUILD_ISOCH_CLOSE_ENDPOINT(
            &m_pStreamingResources->CloseUrb,
            m_pStreamingResources->EndpointHandle,
            (PURB_COMPLETE_PROC)&XHawkMediaObject::CloseEndpointComplete,
            (PVOID)this
            );
    m_pDevice->SubmitRequest((PURB)&m_pStreamingResources->CloseUrb);
}

void XHawkMediaObject::CloseEndpointComplete (PURB pUrb, XHawkMediaObject *pThis)
/*++
    Routine Description:
        This is the call back when an isoch endpoint is closed.
        This could happen if a close is pending, or if 
        a remove is pending, or both.

--*/
{
    DWORD dwPort;
    ASSERT(USBD_SUCCESS(pUrb->Header.Status));

    //
    //  Now mark the endpoint closed.
    //
    pThis->m_pStreamingResources->EndpointHandle = NULL;

    //
    //  Decrement the reference count on the rate, for
    //  which we need the port index.
    //

    if(pThis->m_fMicrophone)
    {
        dwPort = (DWORD)(pThis - XHawkMediaObject::sm_pMicrophones);
    } else
    {
        dwPort = (DWORD)(pThis - XHawkMediaObject::sm_pHeadphones);
    }
    XHawkMediaObject::sm_pRateIndexRefCounts[dwPort]--;
    
    
    //
    //  Abort outstanding packets.
    //
    pThis->AbortMediaPackets();

    //
    //  Deal with the remove pending case.
    //

    if(pThis->m_fRemovePending)
    {
        pThis->m_pDevice->SetExtension(NULL);
        pThis->m_pDevice->RemoveComplete();
        pThis->m_pDevice = NULL;
        pThis->m_fRemovePending = FALSE;
    }

    //
    //  If this is the close pending case,
    //  then there is an event that we need to set
    //
    if(pThis->m_fClosePending)
    {
        //
        //  We have to clear the m_fClosePending
        //  and m_fOpened flags while still at
        //  DPC for synchronization purposes.
        //

        pThis->m_fClosePending = FALSE;
        pThis->m_fOpened = FALSE;

        //
        //  Signal the close event so that
        //  FreeStreamingResources can continue
        //  to clean up.
        //

        KeSetEvent(
            &pThis->m_pStreamingResources->CloseEvent,
            IO_NO_INCREMENT,
            FALSE
            );
    }
    pThis->m_fClosingEndpoint = FALSE;
}

void XHawkMediaObject::FreeStreamingResources (void)
{
    KIRQL oldIrql = KeRaiseIrqlToDpcLevel();

    if(m_fConnected && m_pStreamingResources->EndpointHandle)
    {

        //
        //  Mark that this object is pending close
        //  and initialize the close event.
        //

        m_fClosePending = TRUE;
        KeInitializeEvent(
            &m_pStreamingResources->CloseEvent,
            SynchronizationEvent,
            FALSE);

        //
        //  If it is already pending remove
        //  then we can just wait for
        //  the endpoint to close, other
        //  wise we must initiate closing
        //   it.
        //
        
        if(!m_fRemovePending)
        {
            CloseEndpoint();
        }

        //
        //  Lower Irql and let the endpoint close.
        //

        KeLowerIrql(oldIrql);
        
        //
        // The endpoint close is under way,
        // wait for it to complete.
        //

        KeWaitForSingleObject (
            &m_pStreamingResources->CloseEvent,
            Executive,
            KernelMode,
            FALSE,
            NULL
            );

    } else
    {
        m_fOpened = FALSE;
        KeLowerIrql(oldIrql);
    }
    
    if(m_fMicrophone) sm_AvailableMicrophoneResources++;
    else sm_AvailableHeadphoneResources++;

    //
    //  Now we can cleanup what is left of the streaming resources
    //
    delete [] m_pStreamingResources->m_pContextArray;
    m_pStreamingResources->pNextFree = sm_pFreeStreamingResources;
    sm_pFreeStreamingResources = m_pStreamingResources;
    m_pStreamingResources = NULL;
    
}

void XHawkMediaObject::ProgramTransfer()
/*++
    Routine Description:
        This routine translates a portion of a packet into USB Isochronous
        Transfer Requests.

    Note: Sometimes this routine in called at PASSIVE_LEVEL and sometimes
    at DISPATCH_LEVEL.  This routine is not inherently reentrant so we raise
    the IRQL to DISPATCH_LEVEL all the time.
--*/
{
    KIRQL oldIrql = KeRaiseIrqlToDpcLevel();   
    USBD_ISOCH_BUFFER_DESCRIPTOR isochBufferDescriptor;
    PHAWK_TRANSFER_CONTEXT pTransferContext = NULL;
    int i;

    //
    //  Claim a context
    //
    if(TEST_FLAG(m_pStreamingResources->AvailableTransferContexts, HAWK_TRANSFER_CONTEXT_0))
    {
        CLEAR_FLAG(m_pStreamingResources->AvailableTransferContexts, HAWK_TRANSFER_CONTEXT_0);
        pTransferContext = &m_pStreamingResources->TransferContext[0];
    } else if(TEST_FLAG(m_pStreamingResources->AvailableTransferContexts, HAWK_TRANSFER_CONTEXT_1))
    {
        CLEAR_FLAG(m_pStreamingResources->AvailableTransferContexts, HAWK_TRANSFER_CONTEXT_1);
        pTransferContext = &m_pStreamingResources->TransferContext[1];
    }

    isochBufferDescriptor.TransferComplete = (PFNUSBD_ISOCH_TRANSFER_COMPLETE)XHawkMediaObject::TransferComplete;

    while(pTransferContext)
    {
        PHAWK_PACKET_CONTEXT pPacketContext = m_pStreamingResources->PendingProgram.GetHead();
        
        //
        //  If there are no more packet contexts pending programming, break the
        //  loop, we are done.
        //

        if(!pPacketContext)
        {
            SET_FLAG(m_pStreamingResources->AvailableTransferContexts, pTransferContext->ucContextNumber);
            break;
        }

        //
        //  Fill out the transfer context
        //

        pTransferContext->pPacketContext = pPacketContext;
        pTransferContext->pucTransferBuffer = (PUCHAR) pPacketContext->MediaPacket.pvBuffer;
        pTransferContext->ulTransferBytes = 0;
        pTransferContext->cFirstFrame = m_pStreamingResources->ProgrammedFrame;
        pTransferContext->fWrapBuffer = FALSE;
        pTransferContext->fLastTransfer = FALSE;

        //
        //  Walk through each frame, up to HAWK_USB_MAX_FRAMES,
        //

        for(i=0; i < HAWK_USB_MAX_FRAMES; i++)
        {   
            isochBufferDescriptor.Pattern[i] = m_pStreamingResources->BytesPerUSBFrame;
            if(
                m_pStreamingResources->ExtraSampleInterval && 
                (++m_pStreamingResources->ProgrammedFrame == m_pStreamingResources->ExtraSampleInterval)
            )
            {
                isochBufferDescriptor.Pattern[i] += 2;
                m_pStreamingResources->ProgrammedFrame=0;
            }
            pTransferContext->ulTransferBytes += isochBufferDescriptor.Pattern[i];
            
            if(pTransferContext->ulTransferBytes > pPacketContext->MediaPacket.dwMaxSize)
            {
                m_pStreamingResources->WrapBuffer.ulSecondPacketBytes = 
                        pTransferContext->ulTransferBytes - pPacketContext->MediaPacket.dwMaxSize;
                pTransferContext->ulTransferBytes = pPacketContext->MediaPacket.dwMaxSize;
                pTransferContext->fWrapBuffer = TRUE;
                //
                //  If this is for a headphones copy the output bytes
                //  for this packet.
                //
                if(!m_fMicrophone)
                {
                    RtlCopyMemory(
                        m_pStreamingResources->WrapBuffer.Buffer,
                        pPacketContext->MediaPacket.pvBuffer,
                        pTransferContext->ulTransferBytes);
                }
            }
            if(pTransferContext->ulTransferBytes == pPacketContext->MediaPacket.dwMaxSize)
            {
                pTransferContext->fLastTransfer = TRUE;
                i++;
                break;
            }
        }
        ASSERT(i==8 || pTransferContext->fLastTransfer);
        pPacketContext->MediaPacket.dwMaxSize -= pTransferContext->ulTransferBytes;
        isochBufferDescriptor.Context = pTransferContext;
        isochBufferDescriptor.FrameCount = i;
        isochBufferDescriptor.TransferBuffer = pPacketContext->MediaPacket.pvBuffer;
        pPacketContext->MediaPacket.pvBuffer = ((PUCHAR)pPacketContext->MediaPacket.pvBuffer) + pTransferContext->ulTransferBytes;

        //
        //  If we are done with the current packet, then pop it off the pending program queue.
        //
        if(pTransferContext->fLastTransfer)
        {
            m_pStreamingResources->PendingProgram.RemoveHead();
        }

        //
        //  If the wrap buffer is in use than we need to get the next
        //  packet and start programming it in the beginning of the wrap buffer.
        //
        if(pTransferContext->fWrapBuffer)
        {
            DBGPRINT(1,("W"));
            PHAWK_WRAP_BUFFER pWrapBuffer = &m_pStreamingResources->WrapBuffer;
            isochBufferDescriptor.TransferBuffer = pWrapBuffer->Buffer;
            pPacketContext = m_pStreamingResources->PendingProgram.GetHead();
            if(pPacketContext)
            {
                pWrapBuffer->pSecondPacket = pPacketContext;
                pWrapBuffer->pucTransferBuffer = (PUCHAR)pPacketContext->MediaPacket.pvBuffer;
                ASSERT(pWrapBuffer->ulSecondPacketBytes <= pPacketContext->MediaPacket.dwMaxSize);
                if(!m_fMicrophone)
                {
                    RtlCopyMemory(
                        pWrapBuffer->Buffer+pTransferContext->ulTransferBytes,
                        pWrapBuffer->pucTransferBuffer,
                        pWrapBuffer->ulSecondPacketBytes);
                }
                pPacketContext->MediaPacket.pvBuffer = pWrapBuffer->pucTransferBuffer + pWrapBuffer->ulSecondPacketBytes;
                pPacketContext->MediaPacket.dwMaxSize -= pWrapBuffer->ulSecondPacketBytes; 
            } else
            //
            //  No more packets pending
            //
            {
                pWrapBuffer->pSecondPacket = NULL;
                pWrapBuffer->pucTransferBuffer = NULL;
                if(!m_fMicrophone)
                {
                    RtlZeroMemory(
                        pWrapBuffer->Buffer+pTransferContext->ulTransferBytes,
                        pWrapBuffer->ulSecondPacketBytes);
                }
            }
        }

        //
        //  Build and submit a USB request
        //
        
        URB_ISOCH_ATTACH_BUFFER Urb;
        USB_BUILD_ISOCH_ATTACH_BUFFER(
            &Urb,
            m_pStreamingResources->EndpointHandle,
            USBD_DELAY_INTERRUPT_0_MS,
            &isochBufferDescriptor
            );
        
        USBD_STATUS usbdStatus = m_pDevice->SubmitRequest((PURB)&Urb);
        ASSERT(USBD_SUCCESS(usbdStatus));
        
        //
        //  Try to claim another context
        //  
        if(TEST_FLAG(m_pStreamingResources->AvailableTransferContexts, HAWK_TRANSFER_CONTEXT_0))
        {
            CLEAR_FLAG(m_pStreamingResources->AvailableTransferContexts, HAWK_TRANSFER_CONTEXT_0);
            pTransferContext = &m_pStreamingResources->TransferContext[0];
        } else if(TEST_FLAG(m_pStreamingResources->AvailableTransferContexts, HAWK_TRANSFER_CONTEXT_1))
        {
            CLEAR_FLAG(m_pStreamingResources->AvailableTransferContexts, HAWK_TRANSFER_CONTEXT_1);
            pTransferContext = &m_pStreamingResources->TransferContext[1];
        } else
        {   //
            //  no more contexts
            //
            pTransferContext = NULL;
        }
    }

    KeLowerIrql(oldIrql);
}


void XHawkMediaObject::TransferComplete(PUSBD_ISOCH_TRANSFER_STATUS Status,  PVOID pvContext)
/*++
    Routine Description:
        This is the completion routine whenever an isoch transfer completes.
        It continues to program the current media packet, releases the media
        packet when it is complete, and moves on to the next packet.
--*/
{
    PHAWK_TRANSFER_CONTEXT pTransferContext = (PHAWK_TRANSFER_CONTEXT)pvContext;
    XHawkMediaObject *pThis = pTransferContext->pHawkMediaObject;
    PHAWK_STREAMING_RESOURCES pStreamingResources = pThis->m_pStreamingResources;
    PHAWK_PACKET_CONTEXT pPacketContext = pTransferContext->pPacketContext;
    CHAR extraSampleClock = pThis->m_pStreamingResources->ExtraSampleInterval;
    if(extraSampleClock) extraSampleClock--;
   
    //
    //  Post processing of data is only useful\needed for microphones.
    //
    if(pThis->m_fMicrophone)
    {
        ULONG bytesThisFrame;
        PUSHORT pBufferPosition;
        if(pTransferContext->fWrapBuffer)
        {
            pBufferPosition = (PUSHORT)pStreamingResources->WrapBuffer.Buffer;
        } else
        {
            pBufferPosition = (PUSHORT)pTransferContext->pucTransferBuffer;
        }
        //
        //  First handle overflow and underflow conditions
        //
        
        for(ULONG ulFrameIndex = 0; ulFrameIndex < Status->FrameCount; ulFrameIndex++)
        {
            bytesThisFrame = pStreamingResources->BytesPerUSBFrame;
            if(
                extraSampleClock &&
                (ulFrameIndex + pTransferContext->cFirstFrame == (ULONG)extraSampleClock)
            )
            {
                bytesThisFrame += 2;
            }
            //
            //  Fill in short frames with data copied from the previous samples(s)
            //
            if(USBD_ISOCH_STATUS_DATA_UNDERRUN == Status->PacketStatus[ulFrameIndex].ConditionCode)
            {
                //Copy bytes from the previous sample
                if(Status->PacketStatus[ulFrameIndex].BytesRead)
                {
                    #if DBG
                    if(0!=Status->PacketStatus[ulFrameIndex].BytesRead%2)
                    {
                        DBGPRINT(1,("Hardware violated sample boundary"));
                    }
                    #endif
                    ULONG samplesToDuplicate = (bytesThisFrame - Status->PacketStatus[ulFrameIndex].BytesRead) >> 1;
                    pBufferPosition = (PUSHORT)(((ULONG_PTR)pBufferPosition) + Status->PacketStatus[ulFrameIndex].BytesRead-2);
                    USHORT sample = *pBufferPosition++;
                    while(samplesToDuplicate--)
                    {
                        *pBufferPosition++ = sample;
                    }
                } else
                //
                //  This handles devices that mute by sending zero length data packets.
                //
                {
                    RtlZeroMemory(pBufferPosition,bytesThisFrame);
                    pBufferPosition  = (PUSHORT)((ULONG_PTR)pBufferPosition + bytesThisFrame); 
                }
            } else
            {
                pBufferPosition  = (PUSHORT)((ULONG_PTR)pBufferPosition + bytesThisFrame); 
            }
            //
            //  Check for data overrun to try to adapt to 
            //  small clock differences
            //
            if(
                extraSampleClock &&
                (USBD_ISOCH_STATUS_DATA_OVERRUN == Status->PacketStatus[ulFrameIndex].ConditionCode)
            )
            {
                CHAR clockDifference = extraSampleClock - (pTransferContext->cFirstFrame+(CHAR)ulFrameIndex);
                pStreamingResources->ProgrammedFrame += clockDifference;
            }
        }
        //
        //  If the wrap buffer was in use, then we need to copy the bytes back to their
        //  original buffer
        //
        if(pTransferContext->fWrapBuffer)
        {
            //
            //  First copy the part for the first packet
            //
            RtlCopyMemory(
                pTransferContext->pucTransferBuffer,
                pStreamingResources->WrapBuffer.Buffer, 
                pTransferContext->ulTransferBytes
                );
            //
            //  Then copy the part for the second packet
            //
            if(pStreamingResources->WrapBuffer.pSecondPacket)
            {
                RtlCopyMemory(
                    pStreamingResources->WrapBuffer.pucTransferBuffer,
                    pStreamingResources->WrapBuffer.Buffer + pTransferContext->ulTransferBytes,
                    pStreamingResources->WrapBuffer.ulSecondPacketBytes
                    );
            }
        }
    } else
    {
        #if DBG
        for(ULONG ulFrameIndex = 0; ulFrameIndex < Status->FrameCount; ulFrameIndex++)
        {
            if(Status->PacketStatus[ulFrameIndex].ConditionCode!=USBD_STATUS_SUCCESS)
            {
                DBGPRINT(1,("Failed Write: Frame=%d, CC=0x%0.1x, BytesWritten=0x%0.3x", 
                        ulFrameIndex,
                        (DWORD)Status->PacketStatus[ulFrameIndex].ConditionCode,
                        (DWORD)Status->PacketStatus[ulFrameIndex].BytesRead
                        ));
            }
        }
        #endif
    }
    
    //
    //  Post processing of data is complete, update completed size
    // 
    
    if(pPacketContext->MediaPacket.pdwCompletedSize)
        *pPacketContext->MediaPacket.pdwCompletedSize += pTransferContext->ulTransferBytes;
    if( pTransferContext->fWrapBuffer&&
        pStreamingResources->WrapBuffer.pSecondPacket&&
        pStreamingResources->WrapBuffer.pSecondPacket->MediaPacket.pdwCompletedSize
    )
    {
        *pStreamingResources->WrapBuffer.pSecondPacket->MediaPacket.pdwCompletedSize += 
            pStreamingResources->WrapBuffer.ulSecondPacketBytes;
    }
    //
    //  Mark the pTransferContext as unused
    //
    BOOL fLastTransfer = pTransferContext->fLastTransfer;
    SET_FLAG(
        pStreamingResources->AvailableTransferContexts,
        pTransferContext->ucContextNumber
        );

    //
    //  Complete packet if necessary
    //
    if(fLastTransfer)
    {
        //
        //  Cache the media packet info on the stack
        //  so we can free the packet context
        //  before calling XMOCompletePacket.
        //
        XMEDIAPACKET mediaPacket;
        DWORD       dwCompletedSize = 0;
        RtlCopyMemory(&mediaPacket, &pPacketContext->MediaPacket, sizeof(XMEDIAPACKET));
        if(mediaPacket.pdwCompletedSize)
            dwCompletedSize = *mediaPacket.pdwCompletedSize;
        

        //
        //  Place the packet back on the free list  (do this before
        //  calling XMOCompletePacket) so that a packet context
        //  is available during the callback (if a callaback is
        //  used) to program the next packet.
        //
        pStreamingResources->Free.InsertTail(pPacketContext);

        XMOCompletePacket(&mediaPacket,
                          dwCompletedSize, 
                          pThis->m_pfnCallback,
                          pThis->m_pvContext,
                          XMEDIAPACKET_STATUS_SUCCESS);

    }

    //
    //  Jog the program loop (if the device is still opened and ready).
    //
    if(pThis->m_fReady)
    {
        pThis->ProgramTransfer();
    }
}

void XHawkMediaObject::AbortMediaPackets()
{

    PHAWK_PACKET_CONTEXT pPacketContext = NULL;
    if(!TEST_FLAG(m_pStreamingResources->AvailableTransferContexts,HAWK_TRANSFER_CONTEXT_0))
    {
        //
        //  Complete the packet (it cannot be on the pending program list)
        //
        if(m_pStreamingResources->TransferContext[0].fLastTransfer)
        {
            pPacketContext = m_pStreamingResources->TransferContext[0].pPacketContext;
        }
    }
    if((NULL==pPacketContext )&& !TEST_FLAG(m_pStreamingResources->AvailableTransferContexts,HAWK_TRANSFER_CONTEXT_1))
    {
        //
        //  Complete the packet (it cannot be on the pending program list)
        //
        if(m_pStreamingResources->TransferContext[1].fLastTransfer)
        {
            pPacketContext = m_pStreamingResources->TransferContext[1].pPacketContext;
        }
    }
    if(NULL==pPacketContext)
    {
        pPacketContext = m_pStreamingResources->PendingProgram.RemoveHead();
    }

    while(pPacketContext)
    {
        //
        //  Cache the media packet info on the stack
        //  so we can free the packet context
        //  before calling XMOCompletePacket.
        //
        XMEDIAPACKET mediaPacket;
        RtlCopyMemory(&mediaPacket, &pPacketContext->MediaPacket, sizeof(XMEDIAPACKET));

        //
        //  Place the packet back on the free list  (do this before
        //  calling XMOCompletePacket) so that a packet context
        //  is available during the callback (if a callaback is
        //  used) to program the next packet.
        //
        m_pStreamingResources->Free.InsertTail(pPacketContext);

        XMOCompletePacket(&mediaPacket,
                          0, 
                          m_pfnCallback,
                          m_pvContext,
                          XMEDIAPACKET_STATUS_FLUSHED);

        //
        //  Get the next packet.
        //

        pPacketContext = m_pStreamingResources->PendingProgram.RemoveHead();
    }
}




//-------------------------------------------------------------------------
// CHawkPacketQueue implementation
//-------------------------------------------------------------------------

void CHawkPacketQueue::InsertTail(PHAWK_PACKET_CONTEXT pPacketContext)
{
    pPacketContext->pNextPacket = NULL;
    if(m_pTail)
    {
        m_pTail->pNextPacket = pPacketContext;
    } else
    {
        m_pHead = pPacketContext;
    }
    m_pTail = pPacketContext;
}

PHAWK_PACKET_CONTEXT CHawkPacketQueue::RemoveHead()
{
    PHAWK_PACKET_CONTEXT pRetVal;
    if(m_pHead)
    {
         pRetVal = m_pHead;
         m_pHead = m_pHead->pNextPacket;
         if(!m_pHead) m_pTail = NULL;
    } else
    {
        pRetVal = NULL;
    }
    return pRetVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\dd\usb\hawk\hawkxmo.cpp ===
/*++

Copyright (c) 1996-2000 Microsoft Corporation

Module Name:

    hawk.CPP

Abstract:


Environment:

    kernel mode

Revision History:


--*/

//*****************************************************************************
// I N C L U D E S
//*****************************************************************************
#include "hawkxmo.h"

#if DBG || DEBUG_LOG

    ULONG               HawkDebugLevel=3;     // Level of debug output

#endif


//------------------------------------------------------------------------------
//  Declare Hawk types and class.
//------------------------------------------------------------------------------
DECLARE_XPP_TYPE(XDEVICE_TYPE_CHAT_MICROPHONE)
DECLARE_XPP_TYPE(XDEVICE_TYPE_CHAT_HEADPHONE)
USB_DEVICE_TYPE_TABLE_BEGIN(Hawk)
USB_DEVICE_TYPE_TABLE_ENTRY(XDEVICE_TYPE_CHAT_MICROPHONE, USB_CONNECTOR_TYPE_HIGH_POWER,1,0,0,2,4,40,0),
USB_DEVICE_TYPE_TABLE_ENTRY(XDEVICE_TYPE_CHAT_HEADPHONE, USB_CONNECTOR_TYPE_HIGH_POWER,1,0,0,2,4,40,0)
USB_DEVICE_TYPE_TABLE_END()
USB_CLASS_DRIVER_DECLARATION(Hawk, USB_DEVICE_CLASS_AUDIO, 0xFF, 0xFF)
USB_CLASS_DRIVER_DECLARATION_DUPLICATE(Hawk, 1, XBOX_DEVICE_CLASS_AUDIO_DEVICE, 0xFF, 0xFF)
#pragma data_seg(".XPP$ClassHawk")
USB_CLASS_DECLARATION_POINTER(Hawk)
USB_CLASS_DECLARATION_POINTER_DUPLICATE(Hawk, 1)
#pragma data_seg(".XPP$Data")

//------------------------------------------------------------------------------
// USB Class Driver Interface
//------------------------------------------------------------------------------

EXTERNUSB VOID
HawkInit ()
{
    DBGPRINT(2, ("enter: HawkInit\n"));
    
    XHawkMediaObject::InitializeClass();

    DBGPRINT(2, ("exit:  HawkInit\n"));    
    return;
}


EXTERNUSB VOID
HawkAddDevice(
     IN IUsbDevice *Device
     )
{
	const USB_ENDPOINT_DESCRIPTOR   *pEndpointDescriptor;
    XHawkMediaObject *pHawkMediaObject = NULL;
    DWORD dwPort;

    //
	//  Get the device port and slot
	//

    dwPort = Device->GetPort();
    if(dwPort >= 16)
    {
        DBGPRINT(2,("AddDevice: dwPort %d, bottom slot, not supported!\n",  dwPort));
        Device->AddComplete(USBD_STATUS_UNSUPPORTED_DEVICE);
        return;
    }

    //
    //  get an endpoint descriptor for the isoch endpoint
    //  (we don't know the direction (microphone or
    //  headphone).  Try input first.
    //

    pEndpointDescriptor = Device->GetEndpointDescriptor(
                                USB_ENDPOINT_TYPE_ISOCHRONOUS,
                                TRUE,
                                0);
    if(pEndpointDescriptor)
    {
        pHawkMediaObject = &XHawkMediaObject::sm_pMicrophones[dwPort];
        pHawkMediaObject->m_pTypeSettings = &pHawkMediaObject->sm_MicrophoneSettings;
    }
    else {
        pEndpointDescriptor = Device->GetEndpointDescriptor(
                                USB_ENDPOINT_TYPE_ISOCHRONOUS,
                                FALSE,
                                0);
        if(pEndpointDescriptor)
        {
            pHawkMediaObject = &XHawkMediaObject::sm_pHeadphones[dwPort];
            pHawkMediaObject->m_pTypeSettings = &pHawkMediaObject->sm_HeadphoneSettings;
        } else 
        {
            ASSERT(FALSE && "Isoch endpoint not found");
            Device->AddComplete(USBD_STATUS_UNSUPPORTED_DEVICE);
            return;
        }
    }
    
    //
    //  Check and initialize the state 
    //
    pHawkMediaObject->m_fConnected = TRUE;

    //
    // Use XHawkMediaObject as the device extension
    //
    
    Device->SetExtension(pHawkMediaObject);
    pHawkMediaObject->m_pDevice = Device;
    
    //
    //  Record the endpoint address, and wMaxPacket
    //

    pHawkMediaObject->m_bEndpointAddress = pEndpointDescriptor->bEndpointAddress;
    pHawkMediaObject->m_wMaxPacket = pEndpointDescriptor->wMaxPacketSize;

    DBGPRINT(2,("IsochMaxPacket = %x, bEndpointAddress = 0x%02x\n, Interface = %d\n", 
                     (ULONG)pEndpointDescriptor->wMaxPacketSize,
                     (ULONG)pEndpointDescriptor->bEndpointAddress,
                     Device->GetInterfaceNumber()
                     ));

    //
    // Set the class specific type so it can be enumerated
    //
    Device->SetClassSpecificType(
                (UCHAR)pHawkMediaObject->m_pTypeSettings->ulHawkClassSpecificType
                );

    Device->AddComplete(USBD_STATUS_SUCCESS);
}


EXTERNUSB VOID
HawkRemoveDevice (
    IN IUsbDevice *Device
    )
{
    XHawkMediaObject *pHawkMediaObject = (XHawkMediaObject *)Device->GetExtension();
 
    //
    //  Mark the device as not connected 
    //

    pHawkMediaObject->m_fConnected = FALSE;

    //
    //  If the device is opened, we cannot call
    //  remove complete, because there is
    //  an endpoint open (or in the process
    //  of being closed.
    //

    if(pHawkMediaObject->m_fOpened)
    {
        //
        //  Mark the media object remove pending,
        //  so that when the endpoint finishes
        //  closing, the CloseEndpointComplete
        //  routine will call RemoveComplete.
        //

        pHawkMediaObject->m_fRemovePending = TRUE;

        //
        //  If the endpoint is not in the process
        //  of being closed, then start that process
        //

        if(!pHawkMediaObject->m_fClosePending)
        {
            pHawkMediaObject->CloseEndpoint();
        }

    } else

    //
    //  The media object wasn't opened, so we can
    //  call remove complete
    //

    {
        pHawkMediaObject->m_pDevice = NULL;
        Device->SetExtension(NULL);
        Device->RemoveComplete();
    }
}    

//------------------------------------------------------------------------------
//  We do not include the CRT, but we need new.
//  we declare it static, so we don't conflict on linking
//  with other modules overriding new.
//------------------------------------------------------------------------------
#pragma warning(disable:4211)
static __inline void * __cdecl operator new(size_t memSize)
    {
        return ExAllocatePoolWithTag(
                            memSize,
                            'kwah'
                            );
    }
static __inline void __cdecl operator delete(void *pMemory)
    {
        ExFreePool(pMemory);
    }
#pragma warning(default:4211)

//------------------------------------------------------------------------------
//  Declaration of static tables
//------------------------------------------------------------------------------
XHawkMediaObject *XHawkMediaObject::sm_pMicrophones = NULL;
XHawkMediaObject *XHawkMediaObject::sm_pHeadphones = NULL;


WAVEFORMATEX 
XHawkMediaObject::sm_MicrophoneWaveformat = 
    {
        WAVE_FORMAT_PCM, //wFormatTag
        1,               //nChannels
        HAWK_MICROPHONE_SAMPLE_RATE*1000,   //nSamplesPerSec 
        HAWK_MICROPHONE_SAMPLE_RATE*1000*
        HAWK_MICROPHONE_BYTES_PER_SAMPLE,   //nAvgBytesPerSec
        HAWK_MICROPHONE_BYTES_PER_SAMPLE,   //nBlockAlign
        HAWK_MICROPHONE_BYTES_PER_SAMPLE*8, //wBitsPerSample
        0                                  //cbSize
    };

WAVEFORMATEX 
XHawkMediaObject::sm_HeadphoneWaveformat = 
    {
        WAVE_FORMAT_PCM, //wFormatTag
        1,               //nChannels
        HAWK_HEADPHONE_SAMPLE_RATE*1000,   //nSamplesPerSec 
        HAWK_HEADPHONE_SAMPLE_RATE*1000*
        HAWK_HEADPHONE_BYTES_PER_SAMPLE,   //nAvgBytesPerSec
        HAWK_HEADPHONE_BYTES_PER_SAMPLE,   //nBlockAlign
        HAWK_HEADPHONE_BYTES_PER_SAMPLE*8, //wBitsPerSample
        0                //cbSize
    };  

HAWK_TYPE_SETTINGS 
XHawkMediaObject::sm_MicrophoneSettings = 
    {
        HAWK_MICROPHONE_CLASS_SPECIFIC_TYPE,        //ulHawkClassSpecificType
        &XHawkMediaObject::sm_MicrophoneWaveformat, //pWaveFormat
        XMO_STREAMF_WHOLE_SAMPLES	|
	    XMO_STREAMF_FIXED_SAMPLE_SIZE |
        XMO_STREAMF_OUTPUT_ASYNC,                   //dwFlags
        HAWK_BYTES_PER_USB_FRAME,                   //cbSize
        0,                                          //cbMaxLookahead
        1                                           //cbAlignment
    };

HAWK_TYPE_SETTINGS 
XHawkMediaObject::sm_HeadphoneSettings = 
    {
        HAWK_HEADPHONE_CLASS_SPECIFIC_TYPE,        //ulHawkClassSpecificType
        &XHawkMediaObject::sm_HeadphoneWaveformat, //pWaveFormat
        XMO_STREAMF_WHOLE_SAMPLES |
	    XMO_STREAMF_FIXED_SAMPLE_SIZE |
        XMO_STREAMF_INPUT_ASYNC,                    //dwFlags
        HAWK_BYTES_PER_USB_FRAME,                   //cbSize
        0,                                          //cbMaxLookahead
        1                                           //cbAlignment
    };

//------------------------------------------------------------------------------
// XHawkMediaObject
//------------------------------------------------------------------------------
void XHawkMediaObject::InitializeClass()
{
    //
    //  Allocate a microphone and a headphone
    //  instance for each of the ports up front.
    //
    ULONG ulPortCount = XGetPortCount();
    sm_pHeadphones = new XHawkMediaObject[ulPortCount];
    sm_pMicrophones = new XHawkMediaObject[ulPortCount];
    
    //
    //  We could loop over them and morph them into
    //  microphones and headphones, but we might
    //  as leave that until an AddDevice.
    //
}


STDMETHODIMP_(ULONG) XHawkMediaObject::AddRef (void)
{
	return (ULONG) InterlockedIncrement(&m_lRefCount);
}

STDMETHODIMP_(ULONG) XHawkMediaObject::Release (void)
{
	LONG lRefCount;
	lRefCount = InterlockedDecrement(&m_lRefCount);
	//
	//	Check for decrement below zero
	//
	if(0>lRefCount)
	{
		DBGPRINT(1, ("XHawkMediaObject: Reference Count Error: Count went below 0!\n"));
		return 0;
	} else if (0==lRefCount)
	{
        FreeStreamingResources();
	}
	return (ULONG)lRefCount;
}

STDMETHODIMP
XHawkMediaObject::GetInfo (
    IN OUT PXMEDIAINFO pInfo
    )
{
    #pragma TODO("RIP args for XHawkMediaObject::GetInputInfo")
    
    pInfo->dwFlags = m_pTypeSettings->dwFlags;
    
    if (HAWK_MICROPHONE_CLASS_SPECIFIC_TYPE == m_pTypeSettings->ulHawkClassSpecificType) {

        pInfo->dwInputSize = 0;
        pInfo->dwOutputSize = m_pTypeSettings->cbSize;

    } else {

        pInfo->dwInputSize = m_pTypeSettings->cbSize;
        pInfo->dwOutputSize = 0;
    }

    pInfo->dwMaxLookahead = m_pTypeSettings->cbMaxLookahead;
    
    return ERROR_SUCCESS;
}
        

STDMETHODIMP 
XHawkMediaObject::Flush (void)
{
    #pragma TODO("Implement Flush")
    return E_NOTIMPL;
}
        

STDMETHODIMP 
XHawkMediaObject::Discontinuity (void)
{
    return S_OK;
}
        

STDMETHODIMP
XHawkMediaObject::GetStatus (
            OUT DWORD *pdwFlags
            )
{
    
    #pragma TODO("RIP args for XHawkMediaObject::GetStatus")

    KIRQL oldIrql = KeRaiseIrqlToDpcLevel();
    
    if( m_fConnected && m_pStreamingResources->Free.GetHead())
    {
        if(HAWK_MICROPHONE_CLASS_SPECIFIC_TYPE == m_pTypeSettings->ulHawkClassSpecificType)
        {
            *pdwFlags = XMO_STATUSF_ACCEPT_OUTPUT_DATA;
    
        } else
        {
            *pdwFlags = XMO_STATUSF_ACCEPT_INPUT_DATA;            
        }

    } else
    {
        *pdwFlags = 0;
    }
    
    KeLowerIrql(oldIrql);
    
    return S_OK;
}
        
HRESULT
XHawkMediaObject::Process (
    IN const XMEDIAPACKET *pInputPacket,
    IN const XMEDIAPACKET *pOutputPacket
    )
{
    KIRQL oldIrql = KeRaiseIrqlToDpcLevel();
    HRESULT hr = S_OK;
    const XMEDIAPACKET *pMediaPacket;
    
    if(HAWK_MICROPHONE_CLASS_SPECIFIC_TYPE == m_pTypeSettings->ulHawkClassSpecificType)
    {
        RIP_ON_NOT_TRUE("Hawk Microphone XMediaObject::Process", NULL==pInputPacket);
        RIP_ON_NOT_TRUE("Hawk Microphone XMediaObject::Process", NULL!=pOutputPacket);
        RIP_ON_NOT_TRUE("Hawk Microphone XMediaObject::Process", pOutputPacket->dwMaxSize > 0);
        RIP_ON_NOT_TRUE("Hawk Microphone XMediaObject::Process", 0 == (pOutputPacket->dwMaxSize % m_pTypeSettings->cbSize));
        
        pMediaPacket = pOutputPacket;
         
    } else 
    {
        RIP_ON_NOT_TRUE("Hawk Headphone XMediaObject::Process", NULL!=pInputPacket);
        RIP_ON_NOT_TRUE("Hawk Headphone XMediaObject::Process", NULL==pOutputPacket);
        RIP_ON_NOT_TRUE("Hawk Headphone XMediaObject::Process", pInputPacket->dwMaxSize > 0);
        RIP_ON_NOT_TRUE("Hawk Headphone XMediaObject::Process", 0 == (pInputPacket->dwMaxSize % m_pTypeSettings->cbSize));

        pMediaPacket = pInputPacket;
    }

    if(m_fConnected)
    {

        PHAWK_PACKET_CONTEXT pPacketContext = m_pStreamingResources->Free.RemoveHead();    
        if(pPacketContext)
        {

            //
            //  Copy the media packet into the hawk packet context.
            //  The structure is identical except hawk has one few extra
            //  field, for queuing
            //

            RtlCopyMemory(&pPacketContext->mediaPacket, pMediaPacket, sizeof(XMEDIAPACKET));

            //
            //  Record that we haven't done anything yet, and that 
            //  the request is pending.
            //
            XMOAcceptPacket(&pPacketContext->mediaPacket);
            pPacketContext->dwCompletedSize=0;

            //
            //  Insert the packet onto the pending programming queue.
            //

            m_pStreamingResources->PendingProgram.InsertTail(pPacketContext);
            
            //
            //  Jog the programming routine.
            //

            ProgramTransfer();
            
        } else
        {
            hr = HRESULT_FROM_WIN32(ERROR_BUSY);
        }

    } else 
    {
        hr = HRESULT_FROM_WIN32(ERROR_DEVICE_NOT_CONNECTED);
    }

    if(FAILED(hr))
    {
        XMOCompletePacket(pMediaPacket, 0, m_pfnCallback, m_pvContext, XMEDIAPACKET_STATUS_FAILURE);
    }

    KeLowerIrql(oldIrql);
    return hr;

}


EXTERN_C HRESULT WINAPI
XHawkCreateMediaObjectInternal(
      IN PXPP_DEVICE_TYPE XppDeviceType,
      IN DWORD dwPort,
      IN DWORD dwMaxAttachedPackets,
      OUT LPWAVEFORMATEX pwfxFormat OPTIONAL,
      PFNXMEDIAOBJECTCALLBACK    pfnCallback,
      PVOID                      pvContext,
      OUT XMediaObject **ppXmediaObject
      )
{
    HRESULT hr;
    XHawkMediaObject *pHawkMediaObject = NULL;

    hr = XHawkCreateMediaObject(
          XppDeviceType,
          dwPort,
          dwMaxAttachedPackets,
          pwfxFormat,
          ppXmediaObject
          );

    if (SUCCEEDED(hr)) {

        //
        // save callback and context
        //

        pHawkMediaObject = (XHawkMediaObject *) *ppXmediaObject;
        pHawkMediaObject->m_pvContext = pvContext;
        pHawkMediaObject->m_pfnCallback = pfnCallback;

    }


    return hr;

}

EXTERN_C HRESULT WINAPI
XHawkCreateMediaObject(
      IN PXPP_DEVICE_TYPE XppDeviceType,
      IN DWORD dwPort,
      IN DWORD dwMaxAttachedPackets,
      OUT LPWAVEFORMATEX pwfxFormat OPTIONAL,
      OUT XMediaObject **ppXmediaObject
      )
/*++
    Routine Description:
        This is the factory method for XHawkMediaObjects.
        It is an exported API for games.
--*/
{
    #pragma TODO("RIP args for XcreateHawkMediaObject")

    //
    //  We need the class Id to find the device.
    //
	
    KIRQL		     oldIrql;
    PNP_CLASS_ID     classId;
    HRESULT          hr = S_OK;
    XHawkMediaObject *pHawkMediaObject = NULL;
    USHORT           portBit = (SHORT)(1 << dwPort);
    
    
    //
    //  Use raised Irql to synchronize the allocation
    //  and opening of instances
    //

    oldIrql = KeRaiseIrqlToDpcLevel();

    //
    //  Claim an existing instance of XHawkMediaObject
    //
	
    if(XDEVICE_TYPE_CHAT_MICROPHONE == XppDeviceType)
	{
	    pHawkMediaObject = &XHawkMediaObject::sm_pMicrophones[dwPort];
    } else if(XDEVICE_TYPE_CHAT_HEADPHONE == XppDeviceType)
    {

        pHawkMediaObject = &XHawkMediaObject::sm_pHeadphones[dwPort];
    } else
    {
        RIP("XHawkCreateMediaObject: XppDeviceType is not a valid type for XHawkCreateMediaObject\n");
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
	};
	
    if( pHawkMediaObject->m_fOpened )
    {
        pHawkMediaObject = NULL;
        hr = HRESULT_FROM_WIN32(ERROR_SHARING_VIOLATION);

    } else if (pHawkMediaObject->m_fConnected)
    {

        //
        //  Allocate the streaming resources.
        //
        hr = pHawkMediaObject->AllocateStreamingResources(dwMaxAttachedPackets);
        if(SUCCEEDED(hr))
        {
            pHawkMediaObject->m_fOpened = TRUE;
            pHawkMediaObject->m_lRefCount = 1;
        } else
        {
           pHawkMediaObject = NULL;
        }

    } else
    {
        pHawkMediaObject = NULL;
        hr = HRESULT_FROM_WIN32(ERROR_DEVICE_NOT_CONNECTED);
    }

    //
    //  Restore Irql since the stuff needs
    //  to be synchronously is done.
    //

    KeLowerIrql(oldIrql);

    //
    //  Fill out the pWaveFormatEx output
    //
    if(pwfxFormat && pHawkMediaObject)
    {
        RtlCopyMemory(
            pwfxFormat,
            pHawkMediaObject->m_pTypeSettings->pWaveFormat,
            sizeof(*pwfxFormat)
            );
    }

    *ppXmediaObject = pHawkMediaObject;	
    return hr;
}


HRESULT XHawkMediaObject::AllocateStreamingResources(ULONG ulMaxAttachedPackets)
/*++
    Routine Description:
        This is a helper function called by Factory Method,
        XcreateHawkMediaObject, to allocate resources for
        providing streaming.
--*/
{
    ULONG i;
    
    //
    //  Allocate memory for streaming resources
    //
    ULONG AllocLength = sizeof(HAWK_STREAMING_RESOURCES) + 
                        (sizeof(HAWK_PACKET_CONTEXT)*ulMaxAttachedPackets);
    PUCHAR pResourceMemory = new UCHAR[AllocLength];
    if(!pResourceMemory) return E_OUTOFMEMORY;    

    //
    //  Zero the memory for good measure.
    //

    RtlZeroMemory(pResourceMemory, AllocLength);
    
    //
    //  Break that memory up into the pStreamingResouces and ulMaxAttachedPackets
    //  count of packet contexts.
    //
    
    PHAWK_STREAMING_RESOURCES pResources = (PHAWK_STREAMING_RESOURCES)pResourceMemory;
    PHAWK_PACKET_CONTEXT  pPacketContextArray = (PHAWK_PACKET_CONTEXT) (pResourceMemory +
                                                sizeof(HAWK_STREAMING_RESOURCES));

    //
    // Populate the free list of packet contexts
    //

    for(i=0; i < ulMaxAttachedPackets; i++)
    {
        pResources->Free.InsertTail(pPacketContextArray + i);
    }
         
    //
    //  Open the isoch endpoint
    //

    URB_ISOCH_OPEN_ENDPOINT OpenUrb;
    USB_BUILD_ISOCH_OPEN_ENDPOINT(
                &OpenUrb,
                m_bEndpointAddress,
                m_wMaxPacket,
                HAWK_ISOCH_MAX_ATTACH_BUFFERS,
                0);
    USBD_STATUS status = m_pDevice->SubmitRequest((PURB)&OpenUrb);
    
    if(USBD_ERROR(status))
    {
        delete pResources;
        return HRESULT_FROM_WIN32(IUsbDevice::Win32FromUsbdStatus(status));
    }
    pResources->EndpointHandle = OpenUrb.EndpointHandle;

    //
    //  Initialize the portion of the IsochBufferDescriptor
    //  that is the same for all transfers.
    //

    for(i =0; i < 8; i++)
    {
        pResources->IsochBufferDescriptor.Pattern[i] = HAWK_BYTES_PER_USB_FRAME;
    }
    pResources->IsochBufferDescriptor.TransferComplete = (PFNUSBD_ISOCH_TRANSFER_COMPLETE)XHawkMediaObject::TransferComplete;
    pResources->IsochBufferDescriptor.Context = (PVOID) this;

    //
    //  start the stream (since we don't have a start API)
    //

    URB_ISOCH_START_TRANSFER StartTransferUrb;
    USB_BUILD_ISOCH_START_TRANSFER(
        &StartTransferUrb,
        pResources->EndpointHandle,
        0,
        URB_FLAG_ISOCH_START_ASAP
        );
    status = m_pDevice->SubmitRequest((PURB)&StartTransferUrb);
    ASSERT(USBD_SUCCESS(status));
        
    //
    //  The stream should be ready to go, we just need to
    //  attach transfers.
    //

    m_pStreamingResources = (PHAWK_STREAMING_RESOURCES) pResources;

    return S_OK;
}

void XHawkMediaObject::CloseEndpoint( void )
{
    ASSERT(m_pStreamingResources);
    //
    //  Build and submit the close URB for the Isoch endpoint
    //

    USB_BUILD_ISOCH_CLOSE_ENDPOINT(
            &m_pStreamingResources->CloseUrb,
            m_pStreamingResources->EndpointHandle,
            (PURB_COMPLETE_PROC)&XHawkMediaObject::CloseEndpointComplete,
            (PVOID)this
            );
    m_pStreamingResources->EndpointHandle = NULL;
    m_pDevice->SubmitRequest((PURB)&m_pStreamingResources->CloseUrb);
}

void XHawkMediaObject::CloseEndpointComplete (PURB pUrb, XHawkMediaObject *pThis)
/*++
    Routine Description:
        This is the call back when an isoch endpoint is closed.
        This could happen if a close is pending, or if 
        a remove is pending, or both.

--*/
{
    ASSERT(USBD_SUCCESS(pUrb->Header.Status));

    //
    //  Deal with the remove pending case.
    //

    if(pThis->m_fRemovePending)
    {
        pThis->m_pDevice->SetExtension(NULL);
        pThis->m_pDevice->RemoveComplete();
        pThis->m_pDevice = NULL;
        pThis->m_fRemovePending = FALSE;
    }

    //
    //  If this is the close pending case,
    //  then there is an event that we need to set
    //
    if(pThis->m_fClosePending)
    {
        //
        //  We have to clear the m_fClosePending
        //  and m_fOpened flags while still at
        //  DPC for synchronization purposes.
        //

        pThis->m_fClosePending = FALSE;
        pThis->m_fOpened = FALSE;

        //
        //  Signal the close event so that
        //  FreeStreamingResources can continue
        //  to clean up.
        //

        KeSetEvent(
            &pThis->m_pStreamingResources->CloseEvent,
            IO_NO_INCREMENT,
            FALSE
            );
    }
}

void XHawkMediaObject::FreeStreamingResources (void)
{
    KIRQL oldIrql = KeRaiseIrqlToDpcLevel();

    if(m_fConnected)
    {

        //
        //  Mark that this object is pending close
        //  and initialize the close event.
        //

        m_fClosePending = TRUE;
        KeInitializeEvent(
            &m_pStreamingResources->CloseEvent,
            SynchronizationEvent,
            FALSE);

        //
        //  If it is already pending remove
        //  then we can just wait for
        //  the endpoint to close, other
        //  wise we must initiate closing
        //   it.
        //

        if(!m_fRemovePending)
        {
            CloseEndpoint();
        }

        //
        //  Lower Irql and let the endpoint close.
        //

        KeLowerIrql(oldIrql);
        
        //
        // The endpoint close is under way,
        // wait fpr it to complete.
        //

        KeWaitForSingleObject (
            &m_pStreamingResources->CloseEvent,
            Executive,
            KernelMode,
            FALSE,
            NULL
            );

    } else
    {
        m_fOpened = FALSE;
        KeLowerIrql(oldIrql);
    }

    //
    //  Now we can cleanup what is left of the streaming resources
    //
    AbortMediaPackets(&m_pStreamingResources->PendingComplete);
    AbortMediaPackets(&m_pStreamingResources->PendingProgram);
    delete m_pStreamingResources;
    m_pStreamingResources = NULL;
}


void XHawkMediaObject::ProgramTransfer()
/*++
    Routine Description:
        This routine translates a portion of a packet into USB Isochronous
        Transfer Requests.

    Note: Sometimes this routine in called at PASSIVE_LEVEL and sometimes
    at DISPATCH_LEVEL.  This routine is not inherently reentrant so we raise
    the IRQL to DISPATCH_LEVEL all the time.
--*/
{
    KIRQL oldIrql = KeRaiseIrqlToDpcLevel();   
 
    while(m_pStreamingResources->ulOutstandingTransfers < HAWK_ISOCH_MAX_ATTACH_BUFFERS)
    {
        PHAWK_PACKET_CONTEXT pPacketContext = m_pStreamingResources->PendingProgram.GetHead();
        
        //
        //  If there are no more packet contexts pending programming, break the
        //  loop, we are done.
        //

        if(!pPacketContext) break;
        
        //
        //  If there are no bytes remaining, then this item was just added to the
        //  pending program list, so reset a programing context for this packet
        //

        if(0 == m_pStreamingResources->ulBytesRemaining)
        {
            //
            //  ulBytesComplete may start as non-zero if there was data
            //  in the packet prior to the calling ProcessOutput.
            //

            m_pStreamingResources->ulBytesRemaining = pPacketContext->mediaPacket.dwMaxSize;
        }

        //
        //  Calculate the maximum number of frames we can transfer
        //
        
        ULONG ulFrameCount = m_pStreamingResources->ulBytesRemaining/HAWK_BYTES_PER_USB_FRAME;
        if(ulFrameCount > HAWK_USB_MAX_FRAMES) ulFrameCount = HAWK_USB_MAX_FRAMES;
        m_pStreamingResources->IsochBufferDescriptor.FrameCount = ulFrameCount;
        
        //
        //  Update the transfer packet information
        //
        
        m_pStreamingResources->IsochBufferDescriptor.TransferBuffer = pPacketContext->mediaPacket.pvBuffer;
                
        //
        //  Update the Current Buffer Pos and the bytes remaining.
        //

        ULONG ulTransferBytes = HAWK_BYTES_PER_USB_FRAME * ulFrameCount;
        pPacketContext->mediaPacket.pvBuffer = (PVOID)(((PUCHAR)pPacketContext->mediaPacket.pvBuffer) + ulTransferBytes);
        m_pStreamingResources->ulBytesRemaining -= ulTransferBytes;

        //
        //  If there are no bytes remaining, move this packet context
        //  onto the pending complete queue

        if(0 == m_pStreamingResources->ulBytesRemaining)
        {
            m_pStreamingResources->PendingProgram.RemoveHead();
            m_pStreamingResources->PendingComplete.InsertTail(pPacketContext);
        }

        //
        //  Build and submit a USB request
        //
        
        URB_ISOCH_ATTACH_BUFFER Urb;
        USB_BUILD_ISOCH_ATTACH_BUFFER(
            &Urb,
            m_pStreamingResources->EndpointHandle,
            USBD_DELAY_INTERRUPT_0_MS,
            &m_pStreamingResources->IsochBufferDescriptor
            );
        
        m_pStreamingResources->ulOutstandingTransfers++;

        USBD_STATUS usbdStatus = m_pDevice->SubmitRequest((PURB)&Urb);
        ASSERT(USBD_SUCCESS(usbdStatus));
        
    }

    KeLowerIrql(oldIrql);
}

void XHawkMediaObject::TransferComplete(PUSBD_ISOCH_TRANSFER_STATUS Status, XHawkMediaObject *pThis)
/*++
    Routine Description:
        This is the completion routine whenever an isoch transfer completes.
        It continues to program the current media packet, releases the media
        packet when it is complete, and moves on to the next packet.
--*/
{

    PHAWK_STREAMING_RESOURCES pStreamingResources = pThis->m_pStreamingResources;

    //
    //  Diagnostics to determine data overrun and data underrun
    //
    #ifdef HAWK_OVERRUN_UNDERRUN_SPEW
    static int TotalCalls=0;
    static int Overrun=0;
    static int Underrun=0;
    TotalCalls++;
    if(HAWK_MICROPHONE_CLASS_SPECIFIC_TYPE == pThis->m_pTypeSettings->ulHawkClassSpecificType)
    {
        for(ULONG i=0; i<Status->FrameCount;i++)
        {
            if(USBD_ISOCH_STATUS_DATA_OVERRUN==Status->PacketStatus[i].ConditionCode)
            {
                DbgPrint("Overrun:%dof%d\n", ++Overrun,TotalCalls);
            } else if(32!=Status->PacketStatus[i].BytesRead)
            {
                DbgPrint("Underrun:%dof%d\n", ++Underrun,TotalCalls);
            }
        }
    }
    #endif
                
    //
    //  Find the correct packet context.  It is the oldest context waiting
    //  for completion. Either the head of the PendingComplete Queue, or
    //  the head of PendingProgram queue.
    //
    PHAWK_PACKET_CONTEXT pPacketContext = pStreamingResources->PendingComplete.GetHead();
    if(NULL == pPacketContext)
    {
        pPacketContext = pStreamingResources->PendingProgram.GetHead();
        ASSERT(pPacketContext);
    }

    //
    //  increment the count of completed bytes.
    //
    pPacketContext->dwCompletedSize += Status->FrameCount*HAWK_BYTES_PER_USB_FRAME;

    //
    //  Check if this completion, completes the whole packet
    //

    ASSERT(pPacketContext->dwCompletedSize <= pPacketContext->mediaPacket.dwMaxSize);
    if(pPacketContext->dwCompletedSize == pPacketContext->mediaPacket.dwMaxSize)
    {
        //
        //  Remove the packet from the pending complete list
        //

        PHAWK_PACKET_CONTEXT pCompletedPacketContext = pStreamingResources->PendingComplete.RemoveHead();
        ASSERT(pCompletedPacketContext == pPacketContext);

        //
        //  Move the packet context to the free list
        //

        pStreamingResources->Free.InsertTail(pCompletedPacketContext);

        //
        //  Update the users status and signal the event if there is one.
        //
        XMOCompletePacket(&pCompletedPacketContext->mediaPacket,
                          pPacketContext->dwCompletedSize,
                          pThis->m_pfnCallback,
                          pThis->m_pvContext,
                          XMEDIAPACKET_STATUS_SUCCESS);
    }

    pStreamingResources->ulOutstandingTransfers--;

    //
    // Jog Program Transfer, as we just freed up a transfer
    //
    if(pThis->m_fConnected && pThis->m_fOpened && !pThis->m_fClosePending)
    {
        pThis->ProgramTransfer();
    }
}

void XHawkMediaObject::AbortMediaPackets(CHawkPacketQueue *pPacketQueue)
{
    PHAWK_PACKET_CONTEXT pPacketContext = pPacketQueue->RemoveHead();
    while(pPacketContext)
    {
        //
        //  Move the packet context to the free list
        //
        m_pStreamingResources->Free.InsertTail(pPacketContext);

        //
        //  Update the users status and signal the event if there is one.
        //

        XMOCompletePacket(&pPacketContext->mediaPacket,
                          0,
                          m_pfnCallback,
                          m_pvContext,
                          XMEDIAPACKET_STATUS_FLUSHED);

        //
        //  Get the next packet.
        //
        pPacketContext = pPacketQueue->RemoveHead();
    }
}


//-------------------------------------------------------------------------
// CHawkPacketQueue implementation
//-------------------------------------------------------------------------

void CHawkPacketQueue::InsertTail(PHAWK_PACKET_CONTEXT pPacketContext)
{
    pPacketContext->pNextPacket = NULL;
    if(m_pTail)
    {
        m_pTail->pNextPacket = pPacketContext;
    } else
    {
        m_pHead = pPacketContext;
    }
    m_pTail = pPacketContext;
}

PHAWK_PACKET_CONTEXT CHawkPacketQueue::RemoveHead()
{
    PHAWK_PACKET_CONTEXT pRetVal;
    if(m_pHead)
    {
         pRetVal = m_pHead;
         m_pHead = m_pHead->pNextPacket;
         if(!m_pHead) m_pTail = NULL;
    } else
    {
        pRetVal = NULL;
    }
    return pRetVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\dd\usb\inc\hcdi.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    hcdi.h

    Generated from usb.x

Abstract:

    Header File for  host controller driver

Environment:

    Xbox

--*/

#ifndef __USB_X__
#define __USB_X__



//
//	USB drivers, and XAPI code modules that rely on USB all go into 
//	the XPP section.
//
#pragma code_seg(".XPPCODE")
#pragma data_seg(".XPP$Data")
#pragma const_seg(".XPPRDATA")

#include <usb100.h>

//
// XBOX platform USB device classes
//

#define XBOX_DEVICE_CLASS_INPUT_DEVICE              0x58
#define XBOX_DEVICE_CLASS_XDCS                      0x59
#define XBOX_DEVICE_CLASS_AUDIO_DEVICE              0x78

//
// USBD status codes
//
//  Status values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+---------------------------+-------------------------------+
//  | S |               Status Code                                 |
//  +---+---------------------------+-------------------------------+
//
//  where
//
//      S - is the state code
//
//          00 - completed with success
//          01 - request is pending
//          10 - completed with error, endpoint not stalled
//          11 - completed with error, endpoint stalled
//
//
//      Code - is the status code
//

typedef LONG USBD_STATUS;

//
// Generic test for success on any status value (non-negative numbers
// indicate success).
//

#define USBD_SUCCESS(Status) ((USBD_STATUS)(Status) >= 0)

//
// Generic test for pending status value.
//

#define USBD_PENDING(Status) ((ULONG)(Status) >> 30 == 1)

//
// Generic test for error on any status value.
//

#define USBD_ERROR(Status) ((USBD_STATUS)(Status) < 0)

//
//  Macro to ensure that error bit is set.
//
#define SET_USBD_ERROR(err)  ((err) | USBD_STATUS_ERROR)


//
// Generic test for stall on any status value.
//

#define USBD_HALTED(Status) ((ULONG)(Status) >> 30 == 3)

#define USBD_STATUS_SUCCESS                  ((USBD_STATUS)0x00000000L)
#define USBD_STATUS_PENDING                  ((USBD_STATUS)0x40000000L)
#define USBD_STATUS_HALTED                   ((USBD_STATUS)0xC0000000L)
#define USBD_STATUS_ERROR                    ((USBD_STATUS)0x80000000L)

//
// HC status codes
// Note: these status codes have both the error and the stall bit set.
//
#define USBD_STATUS_CRC                      ((USBD_STATUS)0xC0000001L)
#define USBD_STATUS_BTSTUFF                  ((USBD_STATUS)0xC0000002L)
#define USBD_STATUS_DATA_TOGGLE_MISMATCH     ((USBD_STATUS)0xC0000003L)
#define USBD_STATUS_STALL_PID                ((USBD_STATUS)0xC0000004L)
#define USBD_STATUS_DEV_NOT_RESPONDING       ((USBD_STATUS)0xC0000005L)
#define USBD_STATUS_PID_CHECK_FAILURE        ((USBD_STATUS)0xC0000006L)
#define USBD_STATUS_UNEXPECTED_PID           ((USBD_STATUS)0xC0000007L)
#define USBD_STATUS_DATA_OVERRUN             ((USBD_STATUS)0xC0000008L)
#define USBD_STATUS_DATA_UNDERRUN            ((USBD_STATUS)0xC0000009L)
#define USBD_STATUS_RESERVED1                ((USBD_STATUS)0xC000000AL)
#define USBD_STATUS_RESERVED2                ((USBD_STATUS)0xC000000BL)
#define USBD_STATUS_BUFFER_OVERRUN           ((USBD_STATUS)0xC000000CL)
#define USBD_STATUS_BUFFER_UNDERRUN          ((USBD_STATUS)0xC000000DL)
#define USBD_STATUS_NOT_ACCESSED             ((USBD_STATUS)0xC000000EL)
#define USBD_STATUS_FIFO                     ((USBD_STATUS)0xC0000010L)

//
// HC status codes
// Note: these status codes have the error bit and not the stall bit set.
//
#define USBD_ISOCH_STATUS_CRC                      (1)
#define USBD_ISOCH_STATUS_BTSTUFF                  (2)
#define USBD_ISOCH_STATUS_DATA_TOGGLE_MISMATCH     (3)
#define USBD_ISOCH_STATUS_STALL_PID                (4)
#define USBD_ISOCH_STATUS_DEV_NOT_RESPONDING       (5)
#define USBD_ISOCH_STATUS_PID_CHECK_FAILURE        (6)
#define USBD_ISOCH_STATUS_UNEXPECTED_PID           (7)
#define USBD_ISOCH_STATUS_DATA_OVERRUN             (8)
#define USBD_ISOCH_STATUS_DATA_UNDERRUN            (9)
#define USBD_ISOCH_STATUS_RESERVED1                (A)
#define USBD_ISOCH_STATUS_RESERVED2                (B)
#define USBD_ISOCH_STATUS_BUFFER_OVERRUN           (C)
#define USBD_ISOCH_STATUS_BUFFER_UNDERRUN          (D)
#define USBD_ISOCH_STATUS_NOT_ACCESSED             (E)

//
// returned by HCD if a transfer is submitted to an endpoint that is 
// stalled
//
#define USBD_STATUS_ENDPOINT_HALTED         ((USBD_STATUS)0xC0000030L)

//
// Software status codes
// Note: the following status codes have only the error bit set
//
#define USBD_STATUS_NO_MEMORY                ((USBD_STATUS)0x80000100L)
#define USBD_STATUS_INVALID_URB_FUNCTION     ((USBD_STATUS)0x80000200L)
#define USBD_STATUS_INVALID_PARAMETER        ((USBD_STATUS)0x80000300L)
#define USBD_STATUS_UNSUPPORTED_DEVICE       ((USBD_STATUS)0x80000400L)
#define USBD_STATUS_TRANSFER_TOO_LONG        ((USBD_STATUS)0x80000500L)

//
// returned by USBD if it cannot complete a URB request, typically this 
// will be returned in the URB status field when the Irp is completed
// with a more specific NT error code in the irp.status field.
//
#define USBD_STATUS_REQUEST_FAILED           ((USBD_STATUS)0x80000600L)

#define USBD_STATUS_NO_DEVICE                ((USBD_STATUS)0x80000700L)

// returned when there is not enough bandwidth avialable
// to open a requested endpoint
#define USBD_STATUS_NO_BANDWIDTH             ((USBD_STATUS)0x80000800L)
//
// generic HC error
// 
#define USBD_STATUS_INTERNAL_HC_ERROR        ((USBD_STATUS)0x80000900L)
//
// returned when a short packet terminates the transfer
// ie USBD_SHORT_TRANSFER_OK bit not set
// 
#define USBD_STATUS_ERROR_SHORT_TRANSFER     ((USBD_STATUS)0x80000A00L)


// 
// returned if the requested start frame is not within
// USBD_ISOCH_START_FRAME_RANGE of the current USB frame, 
// note that the stall bit is set
// 
#define USBD_STATUS_BAD_START_FRAME          ((USBD_STATUS)0xC0000B00L)
//
// returned by HCD if all packets in an iso transfer complete with an error 
//
#define USBD_STATUS_ISOCH_REQUEST_FAILED     ((USBD_STATUS)0xC0000C00L)
//
// returned by HCD if an attempt is made to attach more isoch
// buffers to an endpoint than specified as the maximum when opening
// the endpoint.
//
#define USBD_STATUS_ISOCH_TOO_MANY_BUFFERS   ((USBD_STATUS)0xC0000D00L)
//
// returned by HCD if an attempt is made to start an endpoint which is
// already started.
//
#define USBD_STATUS_ISOCH_ALREADY_STARTED    ((USBD_STATUS)0xC0000E00L)
//
// returned by HCD if an attempt is made to stop an endpoint which is
// not already started.
//
#define USBD_STATUS_ISOCH_NOT_STARTED        ((USBD_STATUS)0xC0000F00L)
//
// returned by HCD if an attempt is made to start an endpoint setup for
// circular DMA with fewer than MaxAttachedBuffers,
//
#define USBD_STATUS_ISOCH_ATTACH_MORE_BUFFERS ((USBD_STATUS)0xC0001000L)
//
// This build of the usb driver does not support isochronous requests.
//
#define USBD_STATUS_ISOCH_NOT_SUPPORTED      ((USBD_STATUS)0xC0002000L)
//
// set when a transfers is completed due to an AbortPipe request from
// the client driver
//
#define USBD_STATUS_CANCELED                 ((USBD_STATUS)0xC000000FL)
#define USBD_STATUS_CANCELING                ((USBD_STATUS)0x40020000L)

//
//	Status returned by hub, when a reset completes successfully and the
//	device is low-speed.
//
#define USBD_STATUS_LOWSPEED				 ((USBD_STATUS)0x01000000L)


//------------------------------------------------------------------------------------
// URB Function Codes   - High bit indicates that USBD (pre-)processes URB
//------------------------------------------------------------------------------------
//-- special bit in URB_FUNCTION codes -----------------
#define URB_FUNCTION_USBD_PROCESSED                 0x80    
#define URB_FUNCTION_ASYNCHRONOUS                   0x40
//------------------------------------------------------
#define URB_FUNCTION_CONTROL_TRANSFER               (0x00 | URB_FUNCTION_ASYNCHRONOUS)
#define URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER     (0x01 | URB_FUNCTION_ASYNCHRONOUS)
#define URB_FUNCTION_OPEN_ENDPOINT                  0x02
#define URB_FUNCTION_CLOSE_ENDPOINT                 (0x03 | URB_FUNCTION_ASYNCHRONOUS)
#define URB_FUNCTION_GET_ENDPOINT_STATE             0x04
#define URB_FUNCTION_SET_ENDPOINT_STATE             0x05
#define URB_FUNCTION_ABORT_ENDPOINT                 (0x06 | URB_FUNCTION_ASYNCHRONOUS)
#define URB_FUNCTION_GET_FRAME_NUMBER               0x07
#define URB_FUNCTION_OPEN_DEFAULT_ENDPOINT          (URB_FUNCTION_USBD_PROCESSED | URB_FUNCTION_OPEN_ENDPOINT)
#define URB_FUNCTION_CLOSE_DEFAULT_ENDPOINT         (URB_FUNCTION_USBD_PROCESSED | URB_FUNCTION_CLOSE_ENDPOINT)
#define URB_FUNCTION_RESET_PORT                     (URB_FUNCTION_USBD_PROCESSED | 0x08)
#define URB_FUNCTION_ISOCH_OPEN_ENDPOINT            0x09
#define URB_FUNCTION_ISOCH_CLOSE_ENDPOINT           (0x0A | URB_FUNCTION_ASYNCHRONOUS)
#define URB_FUNCTION_ISOCH_ATTACH_BUFFER            0x0B
#define URB_FUNCTION_ISOCH_START_TRANSFER           0x0C
#define URB_FUNCTION_ISOCH_STOP_TRANSFER            0x0D

//------------------------------------------------------------------------------------
//  Values for the transfer directions
//------------------------------------------------------------------------------------
#define USB_TRANSFER_DIRECTION_OUT              0x01
#define USB_TRANSFER_DIRECTION_IN               0x02

//----------------------------------------------------------------------------------------------------------------------
// Flags for URB_FUNCTION_GET_ENDPOINT_STATE
//----------------------------------------------------------------------------------------------------------------------
#define USB_ENDPOINT_STATE_HALTED              	0x01    //Set on return if endpoint is halted.
#define USB_ENDPOINT_STATE_TRANSFERS_QUEUED     0x02    //Set on return if one or more transfers are queued to endpoint.

//----------------------------------------------------------------------------------------------------------------------
// Flags for URB_FUNCTION_SET_ENDPOINT_STATE
//----------------------------------------------------------------------------------------------------------------------
#define USB_ENDPOINT_STATE_CLEAR_HALT		    0x00    //Clear endpoint halt.
#define USB_ENDPOINT_STATE_KEEP_HALT		    0x01    //Do not clear enddpoint halt
#define USB_ENDPOINT_STATE_DATA_TOGGLE_RESET    0x04    //Reset data toggle. (i.e. DATA0)
#define USB_ENDPOINT_STATE_DATA_TOGGLE_SET      0x08    //Set data toggle. (i.e. DATA1), provided for testing.
//There is no USB_ENDPOINT_STATE_SET_HALT, since only the hardware may set it.

//----------------------------------------------------------------------------------------------------------------------
// Macros for the InterruptDelay variable in transfer and attach buffer URBs - this is really an OpenHCI thing,
// but gives more control to class drivers.  These are the same as OHCI_TD_DELAY_INTERRUPT_XXX
// DUE TO BUG 9512 IT IS ONLY SAFE TO USE USBD_DELAY_INTERRUPT_0_MS.  OTHERWISE, YOU MAY EXPERIENCE PROBLEMS
// WHEN CLOSING THE ENDPOINT.  SEE BUG 9512 FOR MORE DETAILS.
//----------------------------------------------------------------------------------------------------------------------
#define USBD_DELAY_INTERRUPT_0_MS        0   // Interrupt at end of frame TD is completed
#define USBD_DELAY_INTERRUPT_1_MS        1   // Interrupt within 1 frame of TD compeletion
#define USBD_DELAY_INTERRUPT_2_MS        2   // Interrupt within 2 frames of TD compeletion
#define USBD_DELAY_INTERRUPT_3_MS        3   // Interrupt within 3 frame of TD compeletion
#define USBD_DELAY_INTERRUPT_4_MS        4   // Interrupt within 4 frame of TD compeletion
#define USBD_DELAY_INTERRUPT_5_MS        5   // Interrupt within 5 frame of TD compeletion
#define USBD_DELAY_INTERRUPT_6_MS        6   // Interrupt within  frame of TD compeletion
#define USBD_DELAY_INTERRUPT_NONE        7   // Do not Interrupt upon completion of TD

//------------------------------------------------------------------------------------
// USBD Structures for class drivers
//------------------------------------------------------------------------------------
typedef union _URB *PURB;
typedef VOID (*PURB_COMPLETE_PROC)(PURB Urb, PVOID Context);

//
//  See approptate HCD header file for
//  for flags.
//
struct _URB_HCD_AREA
{
    union
    {
        USHORT  HcdTDCount;
        USHORT  HcdOriginalLength;  //While programed contains the original length
    
	};
    USHORT  HcdUrbFlags;
	PURB    HcdUrbLink;     //Used while the URB is pending
};

struct _URB_HEADER
{
    UCHAR               Length;
    UCHAR               Function;
    USBD_STATUS         Status;
    PURB_COMPLETE_PROC  CompleteProc;       // A completetion routine if the URB is not associated with an Irp
    PVOID               CompleteContext;    // Context to pass into the completion routine.
};

typedef struct _USB_CONTROL_SETUP_PACKET
{
    UCHAR   bmRequestType;
    UCHAR   bRequest;
    USHORT  wValue;
    USHORT  wIndex;
    USHORT  wLength;
} USB_CONTROL_SETUP_PACKET;

typedef struct _URB_CONTROL_TRANSFER
{
    struct _URB_HEADER          Hdr;                    
    PVOID                       EndpointHandle;
    ULONG                       TransferBufferLength;
    PVOID                       TransferBuffer;
    UCHAR                       TransferDirection;
    BOOLEAN                     ShortTransferOK;
    UCHAR                       InterruptDelay;
    UCHAR                       Padding;
    struct _URB_HCD_AREA        Hca;
    USB_CONTROL_SETUP_PACKET    SetupPacket;
} URB_CONTROL_TRANSFER, *PURB_CONTROL_TRANSFER;

typedef struct _URB_BULK_OR_INTERRUPT_TRANSFER
{
    struct _URB_HEADER      Hdr;
    PVOID                   EndpointHandle;
    ULONG                   TransferBufferLength;
    PVOID                   TransferBuffer;
    UCHAR                   TransferDirection;
    BOOLEAN                 ShortTransferOK;
    UCHAR                   InterruptDelay;
    UCHAR                   Padding;
    struct _URB_HCD_AREA    Hca;   // fields for HCD use
} URB_BULK_OR_INTERRUPT_TRANSFER, *PURB_BULK_OR_INTERRUPT_TRANSFER;


typedef struct _URB_OPEN_ENDPOINT
{
    struct _URB_HEADER          Hdr;
    PVOID                       EndpointHandle;
    UCHAR                       FunctionAddress;
    UCHAR                       EndpointAddress;
    UCHAR                       EndpointType;
    UCHAR                       Interval;
    PULONG                      DataToggleBits; // Filled out by USBD
    USHORT                      MaxPacketSize;
    BOOLEAN                     LowSpeed;   //Temporary - filled out by USBD
} URB_OPEN_ENDPOINT, *PURB_OPEN_ENDPOINT;

typedef struct _URB_CLOSE_ENDPOINT
{
    struct _URB_HEADER     Hdr;
    PVOID                  EndpointHandle;
    PURB                   HcdNextClose;   // An extra pointer which Hcd can use to link pending closes.
    PULONG                 DataToggleBits; // Filled out by USBD
} URB_CLOSE_ENDPOINT, *PURB_CLOSE_ENDPOINT;

typedef struct _URB_GET_SET_ENDPOINT_STATE
{
    struct _URB_HEADER      Hdr;
    PVOID                   EndpointHandle;
    ULONG                   EndpointState;
} URB_GET_SET_ENDPOINT_STATE, *PURB_GET_SET_ENDPOINT_STATE;

typedef struct _URB_ABORT_ENDPOINT
{
    struct _URB_HEADER      Hdr;
    PVOID                   EndpointHandle;
    PURB                    HcdNextAbort;   // An extra pointer which Hcd can use to link pending aborts.
} URB_ABORT_ENDPOINT, *PURB_ABORT_ENDPOINT;

typedef struct _URB_RESET_PORT
{
    struct _URB_HEADER  Hdr;
    UCHAR               DeviceNode;
    UCHAR               PortNumber;
} URB_RESET_PORT, *PURB_RESET_PORT;

typedef struct _URB_GET_FRAME_NUMBER
{
    struct _URB_HEADER  Hdr;
    UCHAR               DeviceNode;
    ULONG               FrameNumber;
} URB_GET_FRAME_NUMBER, *PURB_GET_FRAME_NUMBER;


//------------------------------------------------
// Isoch related URBs and related structures
//------------------------------------------------
typedef struct _USBD_ISOCH_PACKET_STATUS_WORD
{
    USHORT BytesRead:12;
    USHORT ConditionCode:4;
} USBD_ISOCH_PACKET_STATUS_WORD, *PUSBD_ISOCH_PACKET_STATUS_WORD;

typedef struct _USBD_ISOCH_TRANSFER_STATUS
{
    USBD_STATUS                     Status;
    ULONG                           FrameCount;
    USBD_ISOCH_PACKET_STATUS_WORD   PacketStatus[8];
} USBD_ISOCH_TRANSFER_STATUS, *PUSBD_ISOCH_TRANSFER_STATUS;

typedef VOID (*PFNUSBD_ISOCH_TRANSFER_COMPLETE)(PUSBD_ISOCH_TRANSFER_STATUS Status, PVOID Context);

typedef struct _USBD_ISOCH_BUFFER_DESCRIPTOR
{
    ULONG                               FrameCount;
    PVOID                               TransferBuffer;
    USHORT                              Pattern[8];
    PFNUSBD_ISOCH_TRANSFER_COMPLETE     TransferComplete;
    PVOID                               Context;
} USBD_ISOCH_BUFFER_DESCRIPTOR, *PUSBD_ISOCH_BUFFER_DESCRIPTOR;

typedef struct _URB_ISOCH_ATTACH_BUFFER
{
    struct _URB_HEADER            Hdr;
    PVOID                         EndpointHandle;
    UCHAR                         InterruptDelay;
    PUSBD_ISOCH_BUFFER_DESCRIPTOR BufferDescriptor;
} URB_ISOCH_ATTACH_BUFFER, *PURB_ISOCH_ATTACH_BUFFER;

typedef struct _URB_ISOCH_START_TRANSFER
{
    struct _URB_HEADER     Hdr;
    PVOID                  EndpointHandle;
    ULONG                  FrameNumber;
    ULONG                  Flags;
} URB_ISOCH_START_TRANSFER, *PURB_ISOCH_START_TRANSFER;
#define URB_FLAG_ISOCH_START_ASAP 0x0001
#define USBD_ISOCH_START_FRAME_RANGE 1024

typedef struct _URB_ISOCH_STOP_TRANSFER
{
    struct _URB_HEADER     Hdr;
    PVOID                  EndpointHandle;
} URB_ISOCH_STOP_TRANSFER, *PURB_ISOCH_STOP_TRANSFER;

typedef struct _URB_ISOCH_OPEN_ENDPOINT
{
    struct _URB_HEADER              Hdr;
    PVOID                           EndpointHandle;
    UCHAR                           FunctionAddress;
    UCHAR                           EndpointAddress;
    USHORT                          MaxPacketSize;
    USHORT                          Flags;
    USHORT                          Pad;
} URB_ISOCH_OPEN_ENDPOINT, *PURB_ISOCH_OPEN_ENDPOINT;
#define URB_FLAG_ISOCH_CIRCULAR_DMA 0x0001

typedef struct _URB_CLOSE_ENDPOINT URB_ISOCH_CLOSE_ENDPOINT, *PURB_ISOCH_CLOSE_ENDPOINT;

//------------------------------------------------
// Union of all URBs
//------------------------------------------------
typedef union _URB
{
    struct _URB_HEADER              Header;
    URB_CONTROL_TRANSFER            ControlTransfer;
    URB_BULK_OR_INTERRUPT_TRANSFER  BulkOrInterruptTransfer;
    URB_BULK_OR_INTERRUPT_TRANSFER  CommonTransfer;
    URB_OPEN_ENDPOINT               OpenEndpoint;
    URB_CLOSE_ENDPOINT              CloseEndpoint;
    URB_GET_SET_ENDPOINT_STATE      GetSetEndpointState;
    URB_ABORT_ENDPOINT              AbortEndpoint;
    URB_RESET_PORT                  ResetPort;
    URB_GET_FRAME_NUMBER            GetFrame;
    URB_ISOCH_ATTACH_BUFFER         IsochAttachBuffer;
    URB_ISOCH_START_TRANSFER        IsochStartTransfer;
    URB_ISOCH_STOP_TRANSFER         IsochStopTransfer;
    URB_ISOCH_OPEN_ENDPOINT         IsochOpenEndpoint;
    URB_ISOCH_CLOSE_ENDPOINT        IsochCloseEndpoint;
} URB;

//------------------------------------------------------------------------------------
// Macros to build USB Request Blocks
//------------------------------------------------------------------------------------
#define USB_BUILD_CONTROL_TRANSFER(\
                        _UrbControlTransfer_,\
                        _EndpointHandle_,\
                        _TransferBuffer_,\
                        _TransferBufferLength_,\
                        _TransferDirection_,\
                        _CompleteProc_,\
                        _CompleteContext_,\
                        _ShortTransferOK_,\
                        _bmRequestType_,\
                        _bRequest_,\
                        _wValue_,\
                        _wIndex_,\
                        _wLength_\
    )\
    {\
        (_UrbControlTransfer_)->Hdr.Length                  =   sizeof(URB_CONTROL_TRANSFER);\
        (_UrbControlTransfer_)->Hdr.Function                =   URB_FUNCTION_CONTROL_TRANSFER;\
        (_UrbControlTransfer_)->Hdr.CompleteProc            =   (_CompleteProc_);\
        (_UrbControlTransfer_)->Hdr.CompleteContext         =   (_CompleteContext_);\
        (_UrbControlTransfer_)->EndpointHandle              =   (_EndpointHandle_);\
        (_UrbControlTransfer_)->TransferBuffer              =   (_TransferBuffer_);\
        (_UrbControlTransfer_)->TransferBufferLength        =   (_TransferBufferLength_);\
        (_UrbControlTransfer_)->TransferDirection           =   (_TransferDirection_);\
        (_UrbControlTransfer_)->ShortTransferOK             =   (_ShortTransferOK_);\
        (_UrbControlTransfer_)->InterruptDelay              =   USBD_DELAY_INTERRUPT_0_MS;\
        (_UrbControlTransfer_)->SetupPacket.bmRequestType   =   (_bmRequestType_);\
        (_UrbControlTransfer_)->SetupPacket.bRequest        =   (_bRequest_);\
        (_UrbControlTransfer_)->SetupPacket.wValue          =   (_wValue_);\
        (_UrbControlTransfer_)->SetupPacket.wIndex          =   (_wIndex_);\
        (_UrbControlTransfer_)->SetupPacket.wLength         =   (_wLength_);\
    }


#define USB_BUILD_BULK_OR_INTERRUPT_TRANSFER(\
                        _UrbBulkOrInterruptTransfer_,\
                        _EndpointHandle_,\
                        _TransferBuffer_,\
                        _TransferBufferLength_,\
                        _TransferDirection_,\
                        _CompleteProc_,\
                        _CompleteContext_,\
                        _ShortTransferOK_\
    )\
    {\
        (_UrbBulkOrInterruptTransfer_)->Hdr.Length          =   sizeof(URB_BULK_OR_INTERRUPT_TRANSFER);\
        (_UrbBulkOrInterruptTransfer_)->Hdr.Function        =   URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER;\
        (_UrbBulkOrInterruptTransfer_)->Hdr.CompleteProc    =   (_CompleteProc_);\
        (_UrbBulkOrInterruptTransfer_)->Hdr.CompleteContext =   (_CompleteContext_);\
        (_UrbBulkOrInterruptTransfer_)->EndpointHandle      =   (_EndpointHandle_);\
        (_UrbBulkOrInterruptTransfer_)->TransferBuffer      =   (_TransferBuffer_);\
        (_UrbBulkOrInterruptTransfer_)->TransferBufferLength=   (_TransferBufferLength_);\
        (_UrbBulkOrInterruptTransfer_)->TransferDirection   =   (_TransferDirection_);\
        (_UrbBulkOrInterruptTransfer_)->ShortTransferOK     =   (_ShortTransferOK_);\
        (_UrbBulkOrInterruptTransfer_)->InterruptDelay      =   USBD_DELAY_INTERRUPT_0_MS;\
    }

//
// Isoch requests
//

#define USB_BUILD_ISOCH_OPEN_ENDPOINT(\
                        _UrbIsochOpenEndpoint_,\
                        _EndpointAddress_,\
                        _MaxPacketSize_,\
                        _Flags_\
    )\
    {\
        (_UrbIsochOpenEndpoint_)->Hdr.Length         =   sizeof(URB_ISOCH_OPEN_ENDPOINT);\
        (_UrbIsochOpenEndpoint_)->Hdr.Function       =   URB_FUNCTION_ISOCH_OPEN_ENDPOINT;\
        (_UrbIsochOpenEndpoint_)->Hdr.CompleteProc   =   NULL;\
        (_UrbIsochOpenEndpoint_)->Hdr.CompleteContext=   NULL;\
        (_UrbIsochOpenEndpoint_)->EndpointAddress    =   (_EndpointAddress_);\
        (_UrbIsochOpenEndpoint_)->MaxPacketSize      =   (_MaxPacketSize_);\
        (_UrbIsochOpenEndpoint_)->Flags              =   (_Flags_);\
    }

#define USB_BUILD_ISOCH_CLOSE_ENDPOINT(\
                        _UrbIsochCloseEndpoint_,\
                        _EndpointHandle_,\
						_CompleteProc_,\
						_CompleteContext_\
    )\
    {\
        (_UrbIsochCloseEndpoint_)->Hdr.Length           =   sizeof(URB_ISOCH_CLOSE_ENDPOINT);\
        (_UrbIsochCloseEndpoint_)->Hdr.Function         =   URB_FUNCTION_ISOCH_CLOSE_ENDPOINT;\
        (_UrbIsochCloseEndpoint_)->Hdr.CompleteProc     =   (_CompleteProc_);\
        (_UrbIsochCloseEndpoint_)->Hdr.CompleteContext  =   (_CompleteContext_);\
        (_UrbIsochCloseEndpoint_)->EndpointHandle       =   (_EndpointHandle_);\
    }

#define USB_BUILD_ISOCH_START_TRANSFER(\
                        _UrbIsochStartTransfer_,\
                        _EndpointHandle_,\
                        _FrameNumber_,\
                        _Flags_\
    )\
    {\
        (_UrbIsochStartTransfer_)->Hdr.Length           =   sizeof(URB_ISOCH_START_TRANSFER);\
        (_UrbIsochStartTransfer_)->Hdr.Function         =   URB_FUNCTION_ISOCH_START_TRANSFER;\
        (_UrbIsochStartTransfer_)->Hdr.CompleteProc     =   NULL;\
        (_UrbIsochStartTransfer_)->Hdr.CompleteContext  =   NULL;\
        (_UrbIsochStartTransfer_)->EndpointHandle       =   (_EndpointHandle_);\
        (_UrbIsochStartTransfer_)->FrameNumber          =   (_FrameNumber_);\
        (_UrbIsochStartTransfer_)->Flags                =   (_Flags_);\
    }

#define USB_BUILD_ISOCH_STOP_TRANSFER(\
                        _UrbIsochStopTransfer_,\
                        _EndpointHandle_\
    )\
    {\
        (_UrbIsochStopTransfer_)->Hdr.Length           =   sizeof(URB_ISOCH_STOP_TRANSFER);\
        (_UrbIsochStopTransfer_)->Hdr.Function         =   URB_FUNCTION_ISOCH_STOP_TRANSFER;\
        (_UrbIsochStopTransfer_)->Hdr.CompleteProc     =   NULL;\
        (_UrbIsochStopTransfer_)->Hdr.CompleteContext  =   NULL;\
        (_UrbIsochStopTransfer_)->EndpointHandle       =   (_EndpointHandle_);\
    }


#define USB_BUILD_ISOCH_ATTACH_BUFFER(\
                        _UrbIsochAttachBuffer_,\
                        _EndpointHandle_,\
                        _InterruptDelay_,\
                        _BufferDescriptor_\
    )\
    {\
        (_UrbIsochAttachBuffer_)->Hdr.Length            =   sizeof(URB_ISOCH_ATTACH_BUFFER);\
        (_UrbIsochAttachBuffer_)->Hdr.Function          =   URB_FUNCTION_ISOCH_ATTACH_BUFFER;\
        (_UrbIsochAttachBuffer_)->Hdr.CompleteProc      =   NULL;\
        (_UrbIsochAttachBuffer_)->Hdr.CompleteContext   =   NULL;\
        (_UrbIsochAttachBuffer_)->EndpointHandle       =   (_EndpointHandle_);\
        (_UrbIsochAttachBuffer_)->InterruptDelay       =   (_InterruptDelay_);\
        (_UrbIsochAttachBuffer_)->BufferDescriptor     =   (_BufferDescriptor_);\
    }

//
// Bulk or Interrupt requests
//

#define USB_BUILD_OPEN_ENDPOINT(\
                        _UrbOpenEndpoint_,\
                        _EndpointAddress_,\
                        _EndpointType_,\
                        _MaxPacketSize_,\
                        _Interval_\
    )\
    {\
        (_UrbOpenEndpoint_)->Hdr.Length         =   sizeof(URB_OPEN_ENDPOINT);\
        (_UrbOpenEndpoint_)->Hdr.Function       =   URB_FUNCTION_OPEN_ENDPOINT;\
        (_UrbOpenEndpoint_)->Hdr.CompleteProc   =   NULL;\
        (_UrbOpenEndpoint_)->EndpointAddress    =   (_EndpointAddress_);\
        (_UrbOpenEndpoint_)->EndpointType       =   (_EndpointType_);\
        (_UrbOpenEndpoint_)->Interval           =   (_Interval_);\
        (_UrbOpenEndpoint_)->MaxPacketSize      =   (_MaxPacketSize_);\
    }

#define USB_BUILD_CLOSE_ENDPOINT(\
                        _UrbCloseEndpoint_,\
                        _EndpointHandle_,\
                        _CompleteProc_,\
                        _CompleteContext_\
    )\
    {\
        (_UrbCloseEndpoint_)->Hdr.Length        =   sizeof(URB_CLOSE_ENDPOINT);\
        (_UrbCloseEndpoint_)->Hdr.Function      =   URB_FUNCTION_CLOSE_ENDPOINT;\
        (_UrbCloseEndpoint_)->Hdr.CompleteProc  =   (_CompleteProc_);\
        (_UrbCloseEndpoint_)->Hdr.CompleteContext = (_CompleteContext_);\
        (_UrbCloseEndpoint_)->EndpointHandle    =   (_EndpointHandle_);\
    }

#define USB_BUILD_OPEN_DEFAULT_ENDPOINT(\
                            _UrbOpenEndpoint_\
    )\
    {\
        (_UrbOpenEndpoint_)->Hdr.Length         =   sizeof(URB_OPEN_ENDPOINT);\
        (_UrbOpenEndpoint_)->Hdr.Function       =   URB_FUNCTION_OPEN_DEFAULT_ENDPOINT;\
        (_UrbOpenEndpoint_)->Hdr.CompleteProc   =   NULL;\
    }

#define USB_BUILD_CLOSE_DEFAULT_ENDPOINT(_UrbCloseEndpoint_, _CompleteProc_, _CompleteContext_)\
    {\
        (_UrbCloseEndpoint_)->Hdr.Length        =   sizeof(URB_CLOSE_ENDPOINT);\
        (_UrbCloseEndpoint_)->Hdr.Function      =   URB_FUNCTION_CLOSE_DEFAULT_ENDPOINT;\
        (_UrbCloseEndpoint_)->Hdr.CompleteProc  =   (_CompleteProc_);\
        (_UrbCloseEndpoint_)->Hdr.CompleteContext = (_CompleteContext_);\
    }

#define USB_BUILD_GET_ENDPOINT_STATE(_UrbGetSetEndpointState_, _EndpointHandle_)\
{\
    (_UrbGetSetEndpointState_)->Hdr.Length          =   sizeof(URB_GET_SET_ENDPOINT_STATE);\
    (_UrbGetSetEndpointState_)->Hdr.Function        =   URB_FUNCTION_GET_ENDPOINT_STATE;\
    (_UrbGetSetEndpointState_)->Hdr.CompleteProc    =   NULL;\
    (_UrbGetSetEndpointState_)->EndpointHandle      =   (_EndpointHandle_);\
}

#define USB_BUILD_SET_ENDPOINT_STATE(_UrbGetSetEndpointState_, _EndpointHandle_, _StateFlags_)\
{\
    (_UrbGetSetEndpointState_)->Hdr.Length          =   sizeof(URB_GET_SET_ENDPOINT_STATE);\
    (_UrbGetSetEndpointState_)->Hdr.Function        =   URB_FUNCTION_SET_ENDPOINT_STATE;\
    (_UrbGetSetEndpointState_)->Hdr.CompleteProc    =   NULL;\
    (_UrbGetSetEndpointState_)->EndpointHandle      =   (_EndpointHandle_);\
    (_UrbGetSetEndpointState_)->EndpointState       =   (_StateFlags_);\
}

#define USB_BUILD_ABORT_ENDPOINT(_UrbAbortEndpoint_, _EndpointHandle_, _CompleteProc_, _CompleteContext_)\
{\
    (_UrbAbortEndpoint_)->Hdr.Length          =   sizeof(URB_ABORT_ENDPOINT);\
    (_UrbAbortEndpoint_)->Hdr.Function        =   URB_FUNCTION_ABORT_ENDPOINT;\
    (_UrbAbortEndpoint_)->Hdr.CompleteProc    =   (_CompleteProc_);\
	(_UrbAbortEndpoint_)->Hdr.CompleteContext =   (_CompleteContext_);\
    (_UrbAbortEndpoint_)->EndpointHandle      =   (_EndpointHandle_);\
}

#define USB_BUILD_RESET_PORT(_UrbResetPort_)\
{\
    (_UrbResetPort_)->Hdr.Length        =   sizeof(URB_RESET_PORT);\
    (_UrbResetPort_)->Hdr.Function      =   URB_FUNCTION_RESET_PORT;\
    (_UrbResetPort_)->Hdr.CompleteProc  =   NULL;\
}

#define USB_BUILD_GET_FRAME(_UrbGetFrame_)\
{\
    (_UrbResetPort_)->Hdr.Length        =   sizeof(URB_GET_FRAME);\
    (_UrbResetPort_)->Hdr.Function      =   URB_FUNCTION_GET_FRAME;\
    (_UrbResetPort_)->Hdr.CompleteProc  =   NULL;\
}

//------------------------------------------------------------------------------------
// Macros to build standard USB Command Request Blocks
//------------------------------------------------------------------------------------
#define USB_BUILD_CLEAR_FEATURE(\
                _UrbControlTransfer_,\
                _Recipient_,\
                _FeatureSelect_,\
                _Index_,\
                _CompleteProc_,\
                _CompleteContext_\
                )\
{\
    (_UrbControlTransfer_)->Hdr.Length                  = sizeof(URB_CONTROL_TRANSFER);\
    (_UrbControlTransfer_)->Hdr.Function                = URB_FUNCTION_CONTROL_TRANSFER;\
    (_UrbControlTransfer_)->Hdr.CompleteProc            = (_CompleteProc_);\
    (_UrbControlTransfer_)->Hdr.CompleteContext         = (_CompleteContext_);\
    (_UrbControlTransfer_)->EndpointHandle              = NULL;\
    (_UrbControlTransfer_)->TransferBuffer              = NULL;\
    (_UrbControlTransfer_)->TransferBufferLength        = 0;\
    (_UrbControlTransfer_)->TransferDirection           = 0;\
    (_UrbControlTransfer_)->ShortTransferOK             = 0;\
    (_UrbControlTransfer_)->InterruptDelay              = USBD_DELAY_INTERRUPT_0_MS;\
    (_UrbControlTransfer_)->SetupPacket.bmRequestType   = (_Recipient_);\
    (_UrbControlTransfer_)->SetupPacket.bRequest        = USB_REQUEST_CLEAR_FEATURE;\
    (_UrbControlTransfer_)->SetupPacket.wValue          = (_FeatureSelect_);\
    (_UrbControlTransfer_)->SetupPacket.wIndex          = (_Index_);\
    (_UrbControlTransfer_)->SetupPacket.wLength         = 0;\
}

#define USB_BUILD_SET_FEATURE(\
                _UrbControlTransfer_,\
                _Recipient_,\
                _FeatureSelect_,\
                _Index_,\
                _CompleteProc_,\
                _CompleteContext_\
                )\
{\
    (_UrbControlTransfer_)->Hdr.Length                  = sizeof(URB_CONTROL_TRANSFER);\
    (_UrbControlTransfer_)->Hdr.Function                = URB_FUNCTION_CONTROL_TRANSFER;\
    (_UrbControlTransfer_)->Hdr.CompleteProc            = (_CompleteProc_);\
    (_UrbControlTransfer_)->Hdr.CompleteContext         = (_CompleteContext_);\
    (_UrbControlTransfer_)->EndpointHandle              = NULL;\
    (_UrbControlTransfer_)->TransferBuffer              = NULL;\
    (_UrbControlTransfer_)->TransferBufferLength        = 0;\
    (_UrbControlTransfer_)->TransferDirection           = 0;\
    (_UrbControlTransfer_)->ShortTransferOK             = 0;\
    (_UrbControlTransfer_)->InterruptDelay              = USBD_DELAY_INTERRUPT_0_MS;\
    (_UrbControlTransfer_)->SetupPacket.bmRequestType   = (_Recipient_);\
    (_UrbControlTransfer_)->SetupPacket.bRequest        = USB_REQUEST_SET_FEATURE;\
    (_UrbControlTransfer_)->SetupPacket.wValue          = (_FeatureSelect_);\
    (_UrbControlTransfer_)->SetupPacket.wIndex          = (_Index_);\
    (_UrbControlTransfer_)->SetupPacket.wLength         = 0;\
}

#define USB_BUILD_GET_CONFIGURATION(\
                _UrbControlTransfer_,\
                _Configuration_,\
                _CompleteProc_,\
                _CompleteContext_\
                )\
{\
    (_UrbControlTransfer_)->Hdr.Length                  = sizeof(URB_CONTROL_TRANSFER);\
    (_UrbControlTransfer_)->Hdr.Function                = URB_FUNCTION_CONTROL_TRANSFER;\
    (_UrbControlTransfer_)->Hdr.CompleteProc            = (_CompleteProc_);\
    (_UrbControlTransfer_)->Hdr.CompleteContext         = (_CompleteContext_);\
    (_UrbControlTransfer_)->EndpointHandle              = NULL;\
    (_UrbControlTransfer_)->TransferBuffer              = (_Configuration_);\
    (_UrbControlTransfer_)->TransferBufferLength        = sizeof(UCHAR);\
    (_UrbControlTransfer_)->TransferDirection           = USB_TRANSFER_DIRECTION_IN;\
    (_UrbControlTransfer_)->ShortTransferOK             = 0;\
    (_UrbControlTransfer_)->InterruptDelay              = USBD_DELAY_INTERRUPT_0_MS;\
    (_UrbControlTransfer_)->SetupPacket.bmRequestType   = USB_DEVICE_TO_HOST;\
    (_UrbControlTransfer_)->SetupPacket.bRequest        = USB_REQUEST_GET_CONFIGURATION;\
    (_UrbControlTransfer_)->SetupPacket.wValue          = 0;\
    (_UrbControlTransfer_)->SetupPacket.wIndex          = 0;\
    (_UrbControlTransfer_)->SetupPacket.wLength         = 1;\
}

#define USB_BUILD_SET_CONFIGURATION(\
                _UrbControlTransfer_,\
                _Configuration_,\
                _CompleteProc_,\
                _CompleteContext_\
                )\
{\
    (_UrbControlTransfer_)->Hdr.Length                  = sizeof(URB_CONTROL_TRANSFER);\
    (_UrbControlTransfer_)->Hdr.Function                = URB_FUNCTION_CONTROL_TRANSFER;\
    (_UrbControlTransfer_)->Hdr.CompleteProc            = (_CompleteProc_);\
    (_UrbControlTransfer_)->Hdr.CompleteContext         = (_CompleteContext_);\
    (_UrbControlTransfer_)->EndpointHandle              = NULL;\
    (_UrbControlTransfer_)->TransferBuffer              = 0;\
    (_UrbControlTransfer_)->TransferBufferLength        = 0;\
    (_UrbControlTransfer_)->TransferDirection           = 0;\
    (_UrbControlTransfer_)->ShortTransferOK             = 0;\
    (_UrbControlTransfer_)->InterruptDelay              = USBD_DELAY_INTERRUPT_0_MS;\
    (_UrbControlTransfer_)->SetupPacket.bmRequestType   = USB_HOST_TO_DEVICE;\
    (_UrbControlTransfer_)->SetupPacket.bRequest        = USB_REQUEST_SET_CONFIGURATION;\
    (_UrbControlTransfer_)->SetupPacket.wValue          = (_Configuration_);\
    (_UrbControlTransfer_)->SetupPacket.wIndex          = 0;\
    (_UrbControlTransfer_)->SetupPacket.wLength         = 0;\
}


#define USB_BUILD_GET_DESCRIPTOR(\
                _UrbControlTransfer_,\
                _DescriptorType_,\
                _DescriptorIndex_,\
                _LanguageID_,\
                _DescriptorBuffer_,\
                _DescriptorBufferLength_,\
                _CompleteProc_,\
                _CompleteContext_\
                )\
{\
    (_UrbControlTransfer_)->Hdr.Length                  = sizeof(URB_CONTROL_TRANSFER);\
    (_UrbControlTransfer_)->Hdr.Function                = URB_FUNCTION_CONTROL_TRANSFER;\
    (_UrbControlTransfer_)->Hdr.CompleteProc            = (_CompleteProc_);\
    (_UrbControlTransfer_)->Hdr.CompleteContext         = (_CompleteContext_);\
    (_UrbControlTransfer_)->EndpointHandle              = NULL;\
    (_UrbControlTransfer_)->TransferBuffer              = (_DescriptorBuffer_);\
    (_UrbControlTransfer_)->TransferBufferLength        = (_DescriptorBufferLength_);\
    (_UrbControlTransfer_)->TransferDirection           = USB_TRANSFER_DIRECTION_IN;\
    (_UrbControlTransfer_)->ShortTransferOK             = TRUE;\
    (_UrbControlTransfer_)->InterruptDelay              = USBD_DELAY_INTERRUPT_0_MS;\
    (_UrbControlTransfer_)->SetupPacket.bmRequestType   = USB_DEVICE_TO_HOST;\
    (_UrbControlTransfer_)->SetupPacket.bRequest        = USB_REQUEST_GET_DESCRIPTOR;\
    (_UrbControlTransfer_)->SetupPacket.wValue          = ((_DescriptorType_)<<8)|(_DescriptorIndex_);\
    (_UrbControlTransfer_)->SetupPacket.wIndex          = (_LanguageID_);\
    (_UrbControlTransfer_)->SetupPacket.wLength         = (_DescriptorBufferLength_);\
}

#define USB_BUILD_SET_DESCRIPTOR(\
                _UrbControlTransfer_,\
                _DescriptorType_,\
                _DescriptorIndex_,\
                _LanguageID_,\
                _DescriptorBuffer_,\
                _DescriptorBufferLength_,\
                _CompleteProc_,\
                _CompleteContext_\
                )\
{\
    (_UrbControlTransfer_)->Hdr.Length                  = sizeof(URB_CONTROL_TRANSFER);\
    (_UrbControlTransfer_)->Hdr.Function                = URB_FUNCTION_CONTROL_TRANSFER;\
    (_UrbControlTransfer_)->Hdr.CompleteProc            = (_CompleteProc_);\
    (_UrbControlTransfer_)->Hdr.CompleteContext         = (_CompleteContext_);\
    (_UrbControlTransfer_)->EndpointHandle              = NULL;\
    (_UrbControlTransfer_)->TransferBuffer              = (_DescriptorBuffer_);\
    (_UrbControlTransfer_)->TransferBufferLength        = (_DescriptorBufferLength_);\
    (_UrbControlTransfer_)->TransferDirection           = USB_TRANSFER_DIRECTION_OUT;\
    (_UrbControlTransfer_)->ShortTransferOK             = FALSE;\
    (_UrbControlTransfer_)->InterruptDelay              = USBD_DELAY_INTERRUPT_0_MS;\
    (_UrbControlTransfer_)->SetupPacket.bmRequestType   = USB_HOST_TO_DEVICE;\
    (_UrbControlTransfer_)->SetupPacket.bRequest        = USB_REQUEST_SET_DESCRIPTOR;\
    (_UrbControlTransfer_)->SetupPacket.wValue          = ((_DescriptorType_)<<8)|(_DescriptorIndex_);\
    (_UrbControlTransfer_)->SetupPacket.wIndex          = (_LanguageID_);\
    (_UrbControlTransfer_)->SetupPacket.wLength         = (_DescriptorBufferLength_);\
}


#define USB_BUILD_GET_INTERFACE(\
                _UrbControlTransfer_,\
                _Interface_,\
                _AlternateSetting_,\
                _CompleteProc_,\
                _CompleteContext_\
                )\
{\
    (_UrbControlTransfer_)->Hdr.Length                  = sizeof(URB_CONTROL_TRANSFER);\
    (_UrbControlTransfer_)->Hdr.Function                = URB_FUNCTION_CONTROL_TRANSFER;\
    (_UrbControlTransfer_)->Hdr.CompleteProc            = (_CompleteProc_);\
    (_UrbControlTransfer_)->Hdr.CompleteContext         = (_CompleteContext_);\
    (_UrbControlTransfer_)->EndpointHandle              = NULL;\
    (_UrbControlTransfer_)->TransferBuffer              = (_AlternateSetting_);\
    (_UrbControlTransfer_)->TransferBufferLength        = sizeof(UCHAR);\
    (_UrbControlTransfer_)->TransferDirection           = USB_TRANSFER_DIRECTION_IN;\
    (_UrbControlTransfer_)->ShortTransferOK             = 0;\
    (_UrbControlTransfer_)->InterruptDelay              = USBD_DELAY_INTERRUPT_0_MS;\
    (_UrbControlTransfer_)->SetupPacket.bmRequestType   = USB_DEVICE_TO_HOST;\
    (_UrbControlTransfer_)->SetupPacket.bRequest        = USB_REQUEST_GET_INTERFACE;\
    (_UrbControlTransfer_)->SetupPacket.wValue          = 0\
    (_UrbControlTransfer_)->SetupPacket.wIndex          = (_Interface_);\
    (_UrbControlTransfer_)->SetupPacket.wLength         = 1;\
}

#define USB_BUILD_SET_INTERFACE(\
                _UrbControlTransfer_,\
                _Interface_,\
                _AlternateSetting_,\
                _CompleteProc_,\
                _CompleteContext_\
                )\
{\
    (_UrbControlTransfer_)->Hdr.Length                  = sizeof(URB_CONTROL_TRANSFER);\
    (_UrbControlTransfer_)->Hdr.Function                = URB_FUNCTION_CONTROL_TRANSFER;\
    (_UrbControlTransfer_)->Hdr.CompleteProc            = (_CompleteProc_);\
    (_UrbControlTransfer_)->Hdr.CompleteContext         = (_CompleteContext_);\
    (_UrbControlTransfer_)->EndpointHandle              = NULL;\
    (_UrbControlTransfer_)->TransferBuffer              = 0;\
    (_UrbControlTransfer_)->TransferBufferLength        = 0;\
    (_UrbControlTransfer_)->TransferDirection           = 0;\
    (_UrbControlTransfer_)->ShortTransferOK             = 0;\
    (_UrbControlTransfer_)->InterruptDelay              = USBD_DELAY_INTERRUPT_0_MS;\
    (_UrbControlTransfer_)->SetupPacket.bmRequestType   = USB_HOST_TO_DEVICE;\
    (_UrbControlTransfer_)->SetupPacket.bRequest        = USB_REQUEST_SET_INTERFACE;\
    (_UrbControlTransfer_)->SetupPacket.wValue          = (_AlternateSetting_);\
    (_UrbControlTransfer_)->SetupPacket.wIndex          = (_Interface_);\
    (_UrbControlTransfer_)->SetupPacket.wLength         = 0;\
}


#define USB_BUILD_GET_STATUS(\
                _UrbControlTransfer_,\
                _Recipient_,\
                _Index_,\
                _Status_,\
                _CompleteProc_,\
                _CompleteContext_\
                )\
{\
    (_UrbControlTransfer_)->Hdr.Length                  = sizeof(URB_CONTROL_TRANSFER);\
    (_UrbControlTransfer_)->Hdr.Function                = URB_FUNCTION_CONTROL_TRANSFER;\
    (_UrbControlTransfer_)->Hdr.CompleteProc            = (_CompleteProc_);\
    (_UrbControlTransfer_)->Hdr.CompleteContext         = (_CompleteContext_);\
    (_UrbControlTransfer_)->EndpointHandle              = NULL;\
    (_UrbControlTransfer_)->TransferBuffer              = (_Status_);\
    (_UrbControlTransfer_)->TransferBufferLength        = size(WORD);\
    (_UrbControlTransfer_)->TransferDirection           = USB_TRANSFER_DIRECTION_IN;\
    (_UrbControlTransfer_)->ShortTransferOK             = 0;\
    (_UrbControlTransfer_)->InterruptDelay              = USBD_DELAY_INTERRUPT_0_MS;\
    (_UrbControlTransfer_)->SetupPacket.bmRequestType   = (USB_DEVICE_TO_HOST|(_Recipient_));\
    (_UrbControlTransfer_)->SetupPacket.bRequest        = USB_REQUEST_GET_STATUS;\
    (_UrbControlTransfer_)->SetupPacket.wValue          = 0;\
    (_UrbControlTransfer_)->SetupPacket.wIndex          =(_Index_);\
    (_UrbControlTransfer_)->SetupPacket.wLength         = 2;\
}

#define USB_BUILD_SYNC_FRAME(\
                _UrbControlTransfer_,\
                _Endpoint_,\
                _Frame_,\
                _CompleteProc_,\
                _CompleteContext_\
                )\
{\
    (_UrbControlTransfer_)->Hdr.Length                  = sizeof(URB_CONTROL_TRANSFER);\
    (_UrbControlTransfer_)->Hdr.Function                = URB_FUNCTION_CONTROL_TRANSFER;\
    (_UrbControlTransfer_)->Hdr.CompleteProc            = (_CompleteProc_);\
    (_UrbControlTransfer_)->Hdr.CompleteContext         = (_CompleteContext_);\
    (_UrbControlTransfer_)->EndpointHandle              = NULL;\
    (_UrbControlTransfer_)->TransferBuffer              = (_Frame_);\
    (_UrbControlTransfer_)->TransferBufferLength        = size(WORD);\
    (_UrbControlTransfer_)->TransferDirection           = USB_TRANSFER_DIRECTION_IN;\
    (_UrbControlTransfer_)->ShortTransferOK             = 0;\
    (_UrbControlTransfer_)->InterruptDelay              = USBD_DELAY_INTERRUPT_0_MS;\
    (_UrbControlTransfer_)->SetupPacket.bmRequestType   = (USB_DEVICE_TO_HOST|USB_COMMAND_TO_ENDPOINT);\
    (_UrbControlTransfer_)->SetupPacket.bRequest        = USB_REQUEST_SYNC_FRAME;\
    (_UrbControlTransfer_)->SetupPacket.wValue          = 0;\
    (_UrbControlTransfer_)->SetupPacket.wIndex          =(_Endpoint_);\
    (_UrbControlTransfer_)->SetupPacket.wLength         = 2;\
}

//-------------------------------------------------------------------------------------------------------------
// Get the USB status code
//-------------------------------------------------------------------------------------------------------------
#define URB_STATUS(urb) ((urb)->Header.Status)
//------------------------------------------------------------------------------------
// bmRequestType values for commands over control pipes, belongs in usb100.h
//------------------------------------------------------------------------------------

//  Data Direction
#define USB_HOST_TO_DEVICE              0x00    
#define USB_DEVICE_TO_HOST              0x80

//  Type
#define USB_STANDARD_COMMAND            0x00
#define USB_CLASS_COMMAND               0x20
#define USB_VENDOR_COMMAND              0x40

//  Recipient
#define USB_COMMAND_TO_DEVICE           0x00
#define USB_COMMAND_TO_INTERFACE        0x01
#define USB_COMMAND_TO_ENDPOINT         0x02
#define USB_COMMAND_TO_OTHER            0x03

//------------------------------------------------------------------------------------
// The enumerator only provides the first eight bytes of the device descriptor
//------------------------------------------------------------------------------------
typedef struct _USB_DEVICE_DESCRIPTOR8 {
    UCHAR bLength;
    UCHAR bDescriptorType;
    USHORT bcdUSB;
    UCHAR bDeviceClass;
    UCHAR bDeviceSubClass;
    UCHAR bDeviceProtocol;
    UCHAR bMaxPacketSize0;
} USB_DEVICE_DESCRIPTOR8, *PUSB_DEVICE_DESCRIPTOR8;
//---------------------------------------------------------------------------------------------------------------
// USB_HOST_CONTROLLER - Host Controller Configuration Selection
//---------------------------------------------------------------------------------------------------------------
#define USB_SINGLE_HOST_CONTROLLER 1
#define USB_DUAL_HOST_CONTROLLER_XDK 2
//  Select which configuragtion to use.

#ifndef USB_HOST_CONTROLLER_CONFIGURATION
#ifdef SILVER
#define USB_HOST_CONTROLLER_CONFIGURATION USB_DUAL_HOST_CONTROLLER_XDK
#else  //!SILVER
#define USB_HOST_CONTROLLER_CONFIGURATION USB_SINGLE_HOST_CONTROLLER
#endif ////!SILVER
#endif  USB_HOST_CONTROLLER_CONFIGURATION


#

//--------------------------------------------------------------------------------
//  Resource structure shared between USBD and OHCD
//--------------------------------------------------------------------------------
#define HCD_INTERRUPT_TD_QUOTA 3
typedef struct _HCD_RESOURCE_REQUIREMENTS
{
    ULONG EndpointCount;
    ULONG IsochEndpointCount;
    ULONG TDCount;
    UCHAR ControlTDQuota;
    UCHAR BulkTDQuota;
    UCHAR IsochMaxBuffers;
} HCD_RESOURCE_REQUIREMENTS, *PHCD_RESOURCE_REQUIREMENTS;


//--------------------------------------------------------------------------------
//  Interface between the host controller driver and usbd
//--------------------------------------------------------------------------------

//
// HCD specific URBs
//
#define USBD_EP_FLAG_LOWSPEED                0x0001
#define USBD_EP_FLAG_NEVERHALT               0x0002

//
// Common transfer request definition, all transfer
// requests passed to the HCD will be mapped to this
// format.  The HCD will can use this structure to
// reference fields that are common to all transfers
// as well as fields specific to isochronous and
// control transfers.

//
// bandwidth related definitions
//

// overhead in bytes/ms

#define USB_ISO_OVERHEAD_BYTES              9
#define USB_INTERRUPT_OVERHEAD_BYTES        13

  
//-------------------------------------------------------------
// Utility procedures supported by USB System Driver
//-------------------------------------------------------------
VOID
USBD_CompleteRequest(
    IN  PURB Urb
    );

USHORT
USBD_CalculateUsbBandwidth(
    IN USHORT   MaxPacketSize,
    IN UCHAR    EndpointType,
    IN BOOLEAN  LowSpeed
    );

VOID
USBD_DeviceConnected(
    IN  PVOID    HcdExtension,
    IN  UCHAR    PortNumber
    );

VOID
USBD_DeviceDisconnected(
    IN  PVOID HcdExtension,
    IN  UCHAR PortNumber
    );

VOID
USBD_NewHostController(
    IN PPCI_DEVICE_DESCRIPTOR PciDevice,
	IN ULONG HcdDeviceExtensionSize
    );

//-------------------------------------------------------------
// Procedures which must be exported by Host Controller Driver
//-------------------------------------------------------------
VOID
HCD_DriverEntry(
    PHCD_RESOURCE_REQUIREMENTS ResourceRequirements
    );

VOID
HCD_EnumHardware();

NTSTATUS
HCD_NewHostController(
    IN PVOID  HcdExtension,
    IN UCHAR  HostControllerNumber,
    IN PPCI_DEVICE_DESCRIPTOR PciDevice
    );

USBD_STATUS
HCD_SubmitRequest(
    IN PVOID HcdExtension,
    IN PURB Urb
    );

USBD_STATUS
HCD_CancelRequest(
    IN PVOID HcdExtension,
    IN PURB  Urb
    );

typedef
VOID
(*PFNHCD_RESET_COMPLETE)(
    IN USBD_STATUS  Status,
    IN PVOID        Context
    );

VOID
HCD_ResetRootHubPort(
    IN PVOID                    HcdExtension,
    IN ULONG                    PortNumber,
    IN PFNHCD_RESET_COMPLETE    ResetCompleteProc,
    IN PVOID                    CompleteContext
    );

VOID
HCD_DisableRootHubPort(
    IN PVOID                    HcdExtension,
    IN ULONG                    PortNumber
    );


#endif //__USB_X__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\dd\usb\kdexts\mu\mukdx.cpp ===
/*++

Copyright (c) 1998	Microsoft Corporation

Module Name: 

    1394kdx.c

Abstract


Author:


Revision History:
--*/

#define KDEXTMODE

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ntos.h>
#include <zwapi.h>

#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#include <imagehlp.h>

#include <memory.h>
#pragma hdrstop

#include <wdbgexts.h>
extern WINDBG_EXTENSION_APIS ExtensionApis;

#include <ntverp.h>
#include <imagehlp.h>

#include <mu.h>
#include "usb.h"
#include "urb.h"

//
//  Globals
//

EXT_API_VERSION        ApiVersion = {
    (VER_PRODUCTVERSION_W >> 8),
    (VER_PRODUCTVERSION_W & 0xff),
    EXT_API_VERSION_NUMBER,
    0
    };

WINDBG_EXTENSION_APIS  ExtensionApis;
USHORT                  SavedMajorVersion;
USHORT                  SavedMinorVersion;

PSTR    ApiDescriptions[] =
{
    "\nUSB MU driver debugging Extensions\n\n",
    "help           - displays help for this extension\n",
    "ext            - dump the contents of a device extension\n",
    "\n"
};

#define NUMBER_API_DESCRIPTIONS     3

//
//  LibMain32
//
BOOL
WINAPI
DLLMain(
    HINSTANCE   hInstance, 
    ULONG       ulReason, 
    LPVOID      pvReserved
    )
{
    switch(ulReason) {

        case DLL_PROCESS_ATTACH:
            break;

        case DLL_PROCESS_DETACH:
            break;

        case DLL_THREAD_ATTACH:
            break;

        case DLL_THREAD_DETACH:
            break;

        default:
            break;
    }

    return(TRUE);
} // DLLMain

DllInit(
    HANDLE hModule,
    DWORD  dwReason,
    DWORD  dwReserved
    )
{
    switch (dwReason) {
        case DLL_THREAD_ATTACH:
            break;

        case DLL_THREAD_DETACH:
            break;

        case DLL_PROCESS_DETACH:
            break;

        case DLL_PROCESS_ATTACH:
            break;
    }

    return TRUE;
}


void
WinDbgExtensionDllInit(
    PWINDBG_EXTENSION_APIS  pExtensionApis,
    USHORT                  MajorVersion,
    USHORT                  MinorVersion
    )
{
    ExtensionApis = *pExtensionApis;

    SavedMajorVersion = MajorVersion;
    SavedMinorVersion = MinorVersion;

    return;
} // WinDbgExtensionDllInit

void
CheckVersion(void)
{

} // CheckVersion

LPEXT_API_VERSION
ExtensionApiVersion(void)
{
    return(&ApiVersion);
} // ExtensionApiVersion

DECLARE_API(help)
{
    ULONG   i;

    for (i=0; i < NUMBER_API_DESCRIPTIONS; i++)
        dprintf(ApiDescriptions[i]);

    return;
} // version

DECLARE_API(ext)
{
    DEVICE_EXTENSION    ext;
    ULONG   Address, BytesRead;

    if (0 == args[0]) {

        dprintf("ext <PDEVICE_EXTENSION>\n");
        return;
    }

    sscanf(args, "%lx", &Address);

    dprintf("\nohci DeviceExtension = 0x%x\n\n", Address);

    if (!ReadMemory(Address, &ext, sizeof(DEVICE_EXTENSION), &BytesRead)) {

        dprintf("Unable to read extension\n");
        return;
    }

    if (BytesRead < sizeof(DEVICE_EXTENSION)) {

        dprintf("Only read %d bytes of extension, expected %d\n", BytesRead, sizeof(DEVICE_EXTENSION));
        return;
    }

    dprintf("\text.FdoDeviceObject = 0x%x\n", ext.FdoDeviceObject);
    dprintf("\text.IUsbDevice = 0x%x\n", ext.Device);
    dprintf("\text.UsbDeviceData.InterfaceNumber = 0x%x\n", ext.UsbDeviceData.InterfaceNumber);
    dprintf("\text.UsbDeviceData.PlayerSlot = 0x%x\n", ext.UsbDeviceData.PlayerSlot);
    dprintf("\text.UsbDeviceData.ControllerSlot = 0x%x\n", ext.UsbDeviceData.ControllerSlot);
    dprintf("\text.UsbDeviceData.BulkInEndpointAddress = 0x%x\n", ext.UsbDeviceData.BulkInEndpointAddress);
    dprintf("\text.UsbDeviceData.BulkOutEndpointAddress = 0x%x\n", ext.UsbDeviceData.BulkOutEndpointAddress);

    dprintf("\text.PendingIoCount = 0x%x\n", ext.PendingIoCount);
    dprintf("\text.DeviceFlags = 0x%x\n", ext.DeviceFlags);
    dprintf("\text.OriginalMrb = 0x%x\n", ext.OriginalMrb);

    dprintf("\text.PendingIrp = 0x%x\n", &ext.PendingIrp);

    dprintf("\text.DiskExtension.Fdo = 0x%x\n", ext.DiskExtension.Fdo);
    dprintf("\text.DiskExtension.SectorShift = 0x%x\n", ext.DiskExtension.SectorShift);
    dprintf("\text.DiskExtension.PartitionLength.LowPart = 0x%x\n", ext.DiskExtension.PartitionLength.LowPart);
    dprintf("\text.DiskExtension.PartitionLength.HighPart = 0x%x\n", ext.DiskExtension.PartitionLength.HighPart);

    dprintf("\text.CbwCswMdl = 0x%x\n", ext.CbwCswMdl);

    dprintf("\n");
    return;
} // device extension
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\dd\usb\inc\debug.h ===
/*++

Copyright (c) 1990 Microsoft Corporation


Module Name:

    debug.h

Abstract:

    Debug related definitions and declarations used in uhcd, usbd, usbn, and usbh.

    The following compiler definitions are effective

    DBG - Debug function, only works in debug builds.
    RAISE_TODO_AND_BUGBUG - causes USB_TODO() and USB_BUGBUG statments to compile
    DBG_MAX     - Changes the default Traceout Level to Maximum (does NOT include RAISE_TODO_AND_BUGBUG)
    DBG_CALL    - Changes the default Traceout Level to include function entry and exit

Environment:

    XBOX kernel mode only

Notes:

Revision History:

    12-27-99 created by Mitchell Dernis (mitchd)

--*/

#ifndef DEBUG_H
#define DEBUG_H

#pragma warning(push, 4)
#pragma warning(disable:4244) //This warning seems to be broken.
#pragma warning(disable:4505) //XUSBDbg* functions should be discarded if not used
#include <xdbg.h>


/*
**  Definitions for compiler warnings.
**
*/
#define QUOTE0(a)  #a
#define QUOTE1(a)  QUOTE0(a)
#define MESSAGE(a) message(__FILE__ "(" QUOTE1(__LINE__) "): " a)
#define TODO(a)    MESSAGE("TODO: " a)
#define BUGBUG(a)  MESSAGE("BUGBUG: " a)

/*
**  Definitions for DEBUG BUILDS
**
**
*/
#if DBG

//
//  Declaration for debug module
//

#define DEFINE_USB_DEBUG_FUNCTIONS(Module) \
    static VOID XUSBDbgErr(PCHAR Format, ...) \
    { va_list args; va_start(args, Format); \
      vXDebugPrint(XDBG_ERROR, Module, Format, args); va_end(args); } \
    static VOID XUSBDbgWrn(PCHAR Format, ...) \
    { va_list args; va_start(args, Format); \
      vXDebugPrint(XDBG_WARNING, Module, Format, args); va_end(args); } \
    static VOID XUSBDbgTrc(PCHAR Format, ...) \
    { va_list args; va_start(args, Format); \
      vXDebugPrint(XDBG_TRACE, Module, Format, args); va_end(args); } \
    static VOID XUSBDbgEnt(PCHAR Format, ...) \
    { va_list args; va_start(args, Format); \
      vXDebugPrint(XDBG_ENTRY, Module, Format, args); va_end(args); } \
    static VOID XUSBDbgExt(PCHAR Format, ...) \
    { va_list args; va_start(args, Format); \
      vXDebugPrint(XDBG_EXIT, Module, Format, args); va_end(args); }

//
//  Conditional debug output procedures
//

#if (XDBG_COMPILE_LEVEL >= XDBG_ENTRY)
#define USB_DBG_ENTRY_PRINT(__x__) XUSBDbgEnt __x__;
#else
#define USB_DBG_ENTRY_PRINT(__x__)
#endif
    
#if (XDBG_COMPILE_LEVEL >= XDBG_EXIT)
#define USB_DBG_EXIT_PRINT(__x__) XUSBDbgExt __x__;
#else
#define USB_DBG_EXIT_PRINT(__x__)
#endif
    
#if (XDBG_COMPILE_LEVEL >= XDBG_WARNING)
#define USB_DBG_WARN_PRINT(__x__) XUSBDbgWrn __x__;
#else
#define USB_DBG_WARN_PRINT(__x__)
#endif

#ifdef PROMOTE_TRACE_TO_WARN
#define USB_DBG_TRACE_PRINT(__x__) XUSBDbgWrn __x__;
#else
#if (XDBG_COMPILE_LEVEL >= XDBG_TRACE)
#define USB_DBG_TRACE_PRINT(__x__) XUSBDbgTrc __x__;
#else
#define USB_DBG_TRACE_PRINT(__x__)
#endif
#endif
    
#if (XDBG_COMPILE_LEVEL >= XDBG_ERROR)
#define USB_DBG_ERROR_PRINT(__x__) XUSBDbgErr __x__;
#else
#define USB_DBG_ERROR_PRINT(__x__)
#endif
    
#define DBG_BREAK() DbgBreakPoint()

#undef  PAGED_CODE
#define PAGED_CODE() \
    if (KeGetCurrentIrql() > APC_LEVEL) \
    {\
        USB_DBG_CRITICAL_PRINT(("Pageable code called at IRQL %ld (file: %s, line:#%ld)\n", KeGetCurrentIrql(),__FILE__,__LINE__))\
        ASSERT(FALSE);\
    }

#define ASSERT_LESS_THAN_DISPATCH_LEVEL() \
    if (KeGetCurrentIrql() >= DISPATCH_LEVEL)   \
    {\
        DbgPrint("%s(%ld): Assertion that IRQL was below DISPATCH_LEVEL failed: IRQL %ld .\n", __FILE__, __LINE__, KeGetCurrentIrql());\
        DbgBreakPoint();\
    }

#define ASSERT_LESS_THAN_OR_EQUAL_DISPATCH_LEVEL() \
    if (KeGetCurrentIrql() > DISPATCH_LEVEL)    \
    {\
        DbgPrint("%s(%ld): Assertion that IRQL was less than or equal to DISPATCH_LEVEL failed: IRQL %ld .\n", __FILE__, __LINE__, KeGetCurrentIrql());\
        DbgBreakPoint();\
    }

#define ASSERT_PASSIVE_LEVEL()\
{\
    if(KeGetCurrentIrql() != PASSIVE_LEVEL)\
    {\
        DbgPrint("%s(%ld): Routine which must be called at PASSIVE_LEVEL was called at IRQL %ld .\n", __FILE__, __LINE__, KeGetCurrentIrql());\
        DbgBreakPoint();\
    }\
}

#define ASSERT_DISPATCH_LEVEL()\
{\
    if(KeGetCurrentIrql() != DISPATCH_LEVEL)\
    {\
        DbgPrint("%s(%ld): Routine which must be called at DISPATCH_LEVEL was called at IRQL %ld .\n", __FILE__, __LINE__, KeGetCurrentIrql());\
        DbgBreakPoint();\
    }\
}

#define USING_CASE_FALLTHROUGH_TRACE    ULONG macro_ulTraceoutSentAlready = FALSE;
#define START_CASE_FALLTHROUGH_TRACE    macro_ulTraceoutSentAlready = FALSE;
#define TRACEOUT_THIS_CASE_ONLY         if(!macro_ulTraceoutSentAlready && (macro_ulTraceoutSentAlready=TRUE) )



//#define RTL_ALLOCATE_HEAP(_size_) ExAllocatePoolWithTag(_size_,MODULE_POOL_TAG)
//#define RTL_FREE_HEAP(_block_) ExFreePool(_block_)

//
//  Beefed up allocate pool with traceout
//
#ifdef USB_TRACE_MEMORY_ALLOCATE_FREE
static PVOID pvAllocateTemp;
#define RTL_ALLOCATE_HEAP(_size_)\
    ( \
        (pvAllocateTemp = ExAllocatePoolWithTag((_size_),MODULE_POOL_TAG)),\
        DbgPrint( "%s(%d): RTL_ALLOCATE_HEAP(%d) returning 0x%0.8x\n",\
                    __FILE__,\
                    __LINE__,\
                    _size_,\
                    pvAllocateTemp\
        ),\
        pvAllocateTemp\
    )

#define RTL_FREE_HEAP(_block_)\
    (\
        DbgPrint("%s(%d): RTL_FREE_HEAP(0x%0.8x)\n", __FILE__, __LINE__, _block_),\
        ExFreePool(_block_)\
    )

#else  //not defined USB_TRACE_MEMORY_ALLOCATE_FREE

#define RTL_ALLOCATE_HEAP(_size_) ExAllocatePoolWithTag((_size_),MODULE_POOL_TAG)
#define RTL_FREE_HEAP(_block_) ExFreePool(_block_)

#endif //USB_TRACE_MEMORY_ALLOCATE_FREE

/*
**  Definitions for RELEASE builds
**
**
*/

#else       // DBG=0

#define USB_DBG_ENTRY_PRINT(__x__)
#define USB_DBG_EXIT_PRINT(__x__)
#define USB_DBG_TRACE_PRINT(__x__)
#define USB_DBG_WARN_PRINT(__x__)
#define USB_DBG_ERROR_PRINT(__x__)
#define DEFINE_USB_DEBUG_FUNCTIONS(Module)
#define DBG_BREAK()
#undef  PAGED_CODE
#define PAGED_CODE()
#define ASSERT_LESS_THAN_DISPATCH_LEVEL()
#define ASSERT_LESS_THAN_OR_EQUAL_DISPATCH_LEVEL()
#define ASSERT_DISPATCH_LEVEL()
#define ASSERT_PASSIVE_LEVEL()
#define DECLARE_MODULE_DEBUG_LEVEL(__x__)
#define SET_MODULE_DEBUG_LEVEL(__x__)
#define USING_CASE_FALLTHROUGH      
#define START_CASE_FALLTHROUGH_TRACE
#define TRACEOUT_THIS_CASE_ONLY     

#define EX_ALLOCATE_POOL(_size_) ExAllocatePool(_size_)
#define EX_FREE_POOL(_block_) ExFreePool(_block_)
#define RTL_ALLOCATE_HEAP(_size_) ExAllocatePool(_size_)
#define RTL_FREE_HEAP(_block_) ExFreePool(_block_)

#endif  // DBG=?

//===========================================================================
//  Profiling things
//===========================================================================
#ifdef PERFORM_PROFILING


//
//  Some macros for neatly adding profiling checks and traceouts
//  in the future we may choose to log these instead.
//
#define PROFILE_DECLARE_TIME_STAMP(_Timer_)\
            LARGE_INTEGER _Timer_;
#define PROFILE_BEGIN_TIMING(_Timer_)\
            _Timer_ = KeQueryPerformanceCounter();
#define PROFILE_END_TIMING(_Timer_)\
        {\
            LARGE_INTEGER _TempTimeDiff_;\
            LARGE_INTEGER _TempTimerFreq_;\
            ULONG         _TempTimeDiffUs_;\
            _TempTimeDiff_ = (_Timer_ - KeQueryPerformanceCounter(&_TempTimerFreq_);\
            _TempTimerFreq_.QuadPart /= 100000; /*Convert to ticks per us*/\
            _TempTimeDiffUs_ = (ULONG)(_TempTimeDiff_.QuadPart / _TempTimerFreq_.QuadPart);
            DbgPrint( USB_TRACE_NAME );\
            DbgPrint( ": " );\
            DbgPrint("\'%s\' took %d us.\n", #_Timer_, _TempTimeDiffUs_);\
        }


#else //PERFORM_PROFILING

//
//  These are all NOPs
//
#define PROFILE_DECLARE_TIME_STAMP(_Timer_)
#define PROFILE_BEGIN_TIMING(_Timer_)
#define PROFILE_END_TIMING(_Timer_)

#endif //PERFORM_PROFILING


//===========================================================================
//          End
//===========================================================================

#endif  // DEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\dd\usb\mu\disk.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    disk.c

Abstract:

    MU disk and partition routines. Top level interface of MU driver

Environment:

    kernel mode

Revision History:

    06/12/2000 - started re-write - georgioc 
    03/08/20001 - arbitray media block size support, see comments - mitchd

--*/


/*++

    03/08/2001 - MEDIA BLOCK SIZES.  Flash ROM media in used in the Memory
                 Units has two relevant lengths: a media page size and a
                 media block size.  The media page size is the smallest
                 unit of storage that can be read from or written to.  The
                 catch is that write doesn't really write it just ORs.
                 The media block size is the smallest block unit of storage
                 that can be erased.

                 A typical media page size is 512 bytes, and a typical media
                 block size is 8k for an 8 MB media and larger for larger media.
                 On all products for Windows, the FW in the media drives report the
                 SCSI Logical Block Size as their page size.  The devices manage
                 the media block internally using on-board RAM to buffer writes
                 as needed.  In addition to supporting much smaller logical
                 block sizes, the extra RAM helps them improve through-put.  An
                 erase operation takes significant time.  Without on-board RAM
                 a write command stalls while blocks are being erased.  With enough 
                 on-board the write is buffered during the erase and transfer proceeds
                 at the USB bandwidth limit.  Still the media write (and read) is
                 comparable and often slower than the USB bus.  Again the RAM helps
                 by allowing multiple blocks to be read to and written from simultaneously.
                 With a well implemented media drive, the USB bus is definately the
                 bottle-neck.

                 On Xbox, COGS were a signficant issue since the media drive and the
                 media are both sold as a single integrated unit.  Thus there is no
                 tolerance for added cost to the drive.  RAM was reduced to a minimum
                 and the Xbox side Memory Unit driver (this code) manages the media block
                 size.  The FW is designed to erase the relevant blocks with any write.
                 So all writes must be to full media blocks, or there adjacent media pages
                 will be erased.  A simple solution is to increase the sector size reported
                 to the filesystem to the media block size.  Unfortunately, the filesystem
                 only supports sector sizes up to one x86 page of 4 kilobytes, while the
                 media block size are typically larger than this.  So writes to less than
                 a full block are supported by reading the remaining portion of the block
                 and writing the whole block out.

                 The initial implementation was designed around the 8 MB media with 8 kbyte
                 media block sizes.  The simplifying assumption that the block size is
                 twice the 4k sector size of the filesystem was used extensively. However,
                 it has become clear that media prices are dropping and larger media (With
                 larger block sizes) are becoming available.

                 This revision addresses this issue by generalizing the scheme to support any
                 media block size that is a positive integral multiple of the 4k sector size.
                 Since the driver is not allowed to dynamically allocate memory according to
                 the MU size, for predictability reasons, a maximum buffer size and thus maximum
                 media block size must be set at compile time of XSS.  That limit has been
                 chosen as of this date to be 16 kbyte.  The code has been written so that this
                 limit is simply a #define and can be changed at any time.  However, if units
                 with larger block sizes become available, the games compiled with the
                 smaller maximum block size will refuse to mount them.  Unfortunately, it is
                 much more difficult to completely hide the units from these games.

                 All writes are broken up into up to three of four phases.  An initial unaligned
                 portion, a whole portion that is completely aligned, and a final portion that
                 is unaligned on the end.  The fourth type I have dubbed a "middle partial portion"
                 which is a small write that begins and ends within a single media block and is
                 not aligned to either end of the block.

                 Partial Middle Writes have their own state machine that reads the portion before,
                 then the portion after and then spits out the whole block.

                 Other writes, send the whole poriton first (if there is one), and then if there
                 was an initial or final portion enter a state machine that handles the initial
                 and final portions in sequence.

                 In order to minimize buffer memory there is one global buffer for partial writes.
                 Requests to either state machine are queued in a single global queue.  Note that
                 since requests for a given device are also queued, there can never be more than
                 one request per device in the partial write queue.  Both state machines, whenever
                 they complete a partial write, pull the next request off the partial write queue
                 and start in the proper state machine.

                 See the comments at the top mrb.cpp for discussion of changes to the mrb state
                 machine (that implements the MU Bulk-Only protocol) to better accomodate the
                 needs of the more generalized buffering.

--*/

//*******************************************************************************
// Includes
//*******************************************************************************
#include "mu.h"

//*******************************************************************************
// local function declarations
//*******************************************************************************
DEFINE_USB_DEBUG_FUNCTIONS("MU");

VOID
MU_fDiskDeviceControl(
    IN PMU_DEVICE_EXTENSION DeviceExtension,
    IN PIRP Irp
    );

NTSTATUS
FASTCALL
MU_fDiskReadDriveCapacity(
    IN PMU_DEVICE_EXTENSION DeviceExtension,
    PIRP Irp
    );

VOID
MU_DiskReadCapacityCompletion(
    IN PMU_DEVICE_EXTENSION DeviceExtension,
    IN NTSTATUS Status
    );

VOID
FASTCALL
MU_fDiskVerify(
    IN PMU_DEVICE_EXTENSION DeviceExtension,
    IN PIRP Irp
    );

VOID
MU_DiskReadComplete(
    IN PMU_DEVICE_EXTENSION DeviceExtension,
    IN NTSTATUS Status
    );

VOID
MU_DiskIoComplete(
    IN PMU_DEVICE_EXTENSION DeviceExtension,
    IN NTSTATUS Status
    );

VOID
FASTCALL
MU_fDiskReadWrite(
    IN PMU_DEVICE_EXTENSION DeviceExtension,
    IN PIRP Irp
    );

VOID
MU_DiskStartPartialWrite(
    IN PMU_DEVICE_EXTENSION DeviceExtension,
    IN NTSTATUS Status
    );

VOID
MU_DiskWriteBuildPartialRequest(
    IN PMU_DEVICE_EXTENSION DeviceExtension,
    IN NTSTATUS Status
    );

VOID
MU_DiskWriteBuildMiddlePartialRequest(
    IN PMU_DEVICE_EXTENSION DeviceExtension,
    IN NTSTATUS Status
    );

VOID
FASTCALL
MU_fMarkWriteBufferCorrupt(
    IN PMU_REQUEST_BLOCK Mrb
    );


VOID
MU_DiskWriteStartNextPartialRequest();




//*******************************************************************************
// Declarations for diagnostic IOCTL's
//*******************************************************************************

#ifdef MU_DIAGNOSTIC_IOCTLS

NTSTATUS
FASTCALL         
MU_fVscCommand(
 IN PMU_DEVICE_EXTENSION DeviceExtension,
 IN PIRP Irp,
 IN BYTE bRequest,
 IN ULONG ulOutputSize
 );


VOID
MU_VscComplete(
    IN PURB   Urb,
    IN PVOID  Context
    );

#endif


//*******************************************************************************
// debug write log stuff
//*******************************************************************************
#if DBG

    #define WRITE_LOG_LENGTH 2000
    ULONG WriteLog[WRITE_LOG_LENGTH];
	ULONG WriteBlock[WRITE_LOG_LENGTH];
    LONG  WriteCount = 0;

    ULONG MU_GetWriteSize(LONG count) { return WriteLog[count]; }
	ULONG MU_GetWriteBlock(LONG count) { return WriteBlock[count]; }
    LONG MU_GetWriteCount() { return WriteCount; }

#endif

//*******************************************************************************
// Implementation
//*******************************************************************************
NTSTATUS
MU_InternalIo (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
/*++
    Routine Description:
    
      Entry Point for:
        IRP_MJ_READ
        IRP_MJ_WRITE
        IRP_MJ_DEVICE_CONTROL
        IRP_MJ_INTERNAL_DEVICE

    In other words, excepting IRP_MJ_CREATE and IRP_MJ_CLOSE, all
    supported IRPs go through here.

    Since all USB requests to a single device are serialized by the bulk-only
    protocol anyway, we just serialize all the IRPs coming in with a device queue.


--*/
{
    PMU_DEVICE_EXTENSION deviceExtension;
    KIRQL                oldIrql;
    NTSTATUS             ntStatus = STATUS_PENDING;

    USB_DBG_ENTRY_PRINT(("MU_InternalIo(DeviceObject=0x%0.8x,Irp=0x%0.8x)", DeviceObject, Irp));

    deviceExtension = (PMU_DEVICE_EXTENSION) DeviceObject->DeviceExtension;

    oldIrql = KeRaiseIrqlToDpcLevel();

    //
    //  Other parts of the system (XAPI, or intelligent private caller of MU_CreateDeviceObject
    //  and MU_CloseDeviceObject) are supposed to ensure that we do not have outstanding I/O
    //  before calling MU_CloseDeviceObject, and that no new I/O will be initiated after calling
    //  MU_CloseDeviceObject.  We will just ASSERT that this is so.
    //

    ASSERT(!TEST_FLAG(deviceExtension->DeviceFlags, DF_PENDING_CLOSE));

    //
    //  Ensure that device is connected.
    //
    if(TEST_FLAG(deviceExtension->DeviceFlags, DF_REMOVED|DF_PENDING_REMOVE))
    {
        ntStatus = STATUS_DEVICE_NOT_CONNECTED;
        Irp->IoStatus.Status = ntStatus;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        USB_DBG_WARN_PRINT(("An I/O Request has been sent to an MU which is removed"));
    } else
    {
        //
        //  Mark the Irp Pending and add it to the device queue.
        //
        IoMarkIrpPending(Irp);
        IoStartPacket(DeviceObject,
                      Irp,
                      NULL);
    }
    KeLowerIrql(oldIrql);

    USB_DBG_EXIT_PRINT(("MU_InternalIo returning 0x%0.8x", ntStatus));
    return ntStatus;
}

VOID
MU_StartIo (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
/*++
    Routine Description:
        Typical StartIo routine.  Handles one request at a time
        and dispatches it.
--*/
{
    PMU_DEVICE_EXTENSION   deviceExtension;
    PIO_STACK_LOCATION  irpStack;

    USB_DBG_ENTRY_PRINT(("MU_StartIo(DeviceObject=0x%0.8x,Irp=0x%0.8x)", DeviceObject, Irp));

    deviceExtension = (PMU_DEVICE_EXTENSION) DeviceObject->DeviceExtension;
    irpStack = IoGetCurrentIrpStackLocation(Irp);

    USB_DBG_ENTRY_PRINT(("MU_StartIo(0x%0.8x(0x%0.8x), 0x%0.8x)", DeviceObject, deviceExtension, Irp));

    //
    //  Other parts of the system (XAPI, or intelligent private caller of MU_CreateDeviceObject
    //  and MU_CloseDeviceObject) are supposed to ensure that we do not have outstanding I/O
    //  before calling MU_CloseDeviceObject, and that no new I/O will be initiated after calling
    //  MU_CloseDeviceObject.  We will just ASSERT that this is so.
    //

    ASSERT(!TEST_FLAG(deviceExtension->DeviceFlags, DF_PENDING_CLOSE));

    //
    //  If the console is preparing to reset or shutdown, there's no reason to
    //  continue processing this request.
    //

    if (HalIsResetOrShutdownPending())
    {
        Irp->IoStatus.Status = STATUS_REQUEST_ABORTED;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        IoStartNextPacket(DeviceObject);
        return;
    }

    //
    //  Store our device object in the
    //  our stack so we can get back at it.
    //  (This is used by the partial write queue
    //  to relate an Irp back to its device object.)
    //

    irpStack->DeviceObject = DeviceObject;

    //
    //  Save the IRP we are working on
    //  so it doesn't need to be passed everywhere.
    //

    deviceExtension->PendingIrp = Irp;

    //
    //  For debug builds only set a watchdog timer
    //  on the IRP.
    //
    MU_DEBUG_SET_WATCHDOG(deviceExtension);

    //
    //  Handle\Dispatch the request
    //

    switch (irpStack->MajorFunction)
    {
      case IRP_MJ_DEVICE_CONTROL:
        MU_fDiskDeviceControl(deviceExtension,Irp);
        break;
      case IRP_MJ_WRITE:
        IoMarkIrpMustComplete(Irp);
        // FALL THROUGH
      case IRP_MJ_READ:
        MU_fDiskReadWrite(deviceExtension,Irp);
        break;
      default:
        ASSERT("MU called with unsupported I/O Request.");
    }

    USB_DBG_EXIT_PRINT(("MU_StartIo returning"));
    return;
}

VOID
MU_fDiskDeviceControl(
    IN PMU_DEVICE_EXTENSION DeviceExtension,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called by MU_StartIo to handle
    IRP_MJ_DEVICE_CONTROL sent to an MU.
        
    The following IOCTLs are supported, others spew ERROR strings:
        IOCTL_DISK_GET_DRIVE_GEOMETRY
        IOCTL_DISK_GET_PARTITION_INFO
        IOCTL_DISK_VERIFY

    Whenever possible these are satisified with cached information.
    Otherwise, they are dispatched to a routine which builds and
    submits an Mrb to the MRB state machine.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    None

--*/
{
    NTSTATUS               status;
    PDISK_GEOMETRY         diskGeometry;
    PPARTITION_INFORMATION partitionInformation;
    PIO_STACK_LOCATION     irpStack = IoGetCurrentIrpStackLocation(Irp);


    //
    //  Most of the time, the request
    //  will just be pending, so set it here,
    //  and change it if necessary when processing
    //  specific cases.
    //

    status = STATUS_PENDING;

    switch (irpStack->Parameters.DeviceIoControl.IoControlCode)
    {
      case IOCTL_DISK_GET_DRIVE_GEOMETRY:

        diskGeometry = (PDISK_GEOMETRY)Irp->UserBuffer;
        //debug parameter check
        ASSERT(sizeof(DISK_GEOMETRY) <= irpStack->Parameters.DeviceIoControl.OutputBufferLength);

        //
        //  If the Partition Length is zero, we need
        //  to fetch the capacity from the device.
        //
        if (DeviceExtension->PartitionLength.QuadPart == 0)
        {
            //
            //  MU_fDiskReadDriveCapacity doesn't
            //  return a status, it always, pends
            //  the IRP.
            //

            USB_DBG_TRACE_PRINT(("GetDriveGeometry, issuing read capacity"));
            status = MU_fDiskReadDriveCapacity(DeviceExtension,Irp);

        } else
        //
        //  We already know the geometry, just copy it.
        //
        {

            RtlCopyMemory(diskGeometry, &DeviceExtension->DiskGeometry,
                          sizeof(DISK_GEOMETRY));

            status = STATUS_SUCCESS;
            Irp->IoStatus.Information = sizeof(DISK_GEOMETRY);
        }

        break;        

      case IOCTL_DISK_GET_PARTITION_INFO:

        //debug parameter check
        ASSERT(sizeof(PARTITION_INFORMATION) <= irpStack->Parameters.DeviceIoControl.OutputBufferLength);

        //
        // Fill in the output buffer and return.
        //

        partitionInformation = (PPARTITION_INFORMATION)Irp->UserBuffer;
        RtlZeroMemory(partitionInformation, sizeof(PARTITION_INFORMATION));

        //
        //  If the Partition Length is zero, we need
        //  to fetch the capacity from the device.
        //

        if (DeviceExtension->PartitionLength.QuadPart == 0) {

            //
            //  MU_fDiskReadDriveCapacity doesn't
            //  return a status, it always pends
            //  the IRP.
            //

            USB_DBG_TRACE_PRINT(("GetPartitionInfo, issuing read capacity"));
            status = MU_fDiskReadDriveCapacity(DeviceExtension,Irp);

        } else
        //
        //  We already know the partition length, just copy it.
        //
        {
            partitionInformation->PartitionLength = DeviceExtension->PartitionLength;
            partitionInformation->RecognizedPartition = TRUE;
            status = STATUS_SUCCESS;
            Irp->IoStatus.Information = sizeof(PARTITION_INFORMATION);
        }

        break;

      case IOCTL_DISK_VERIFY:
        
        //
        //  MU_fDiskVerify doesn't return status, it always
        //  pends the IRP.
        //
        MU_fDiskVerify(DeviceExtension, Irp);
        break;

        //
        //  The following requests are for running
        //  diagnostics on the memory unit and require
        //  a special build.
        //

#ifdef MU_DIAGNOSTIC_IOCTLS
      case MU_IOCTL_GET_BAD_BLOCK_TABLE:
         
        ASSERT(Irp->UserBuffer && "MU_IOCTL_GET_BAD_BLOCK_TABLE");
         
        ASSERT((MU_VSC_BAD_BLOCK_TABLE_SIZE <= irpStack->Parameters.DeviceIoControl.OutputBufferLength) &&
                "MU_IOCTL_GET_BAD_BLOCK_TABLE");

        //
        //  MU_VSC_GET_BAD_BLOCK_TABLE, must always be proceeded
        //  by a read capacity.
        //
        status = MU_fDiskReadDriveCapacity(DeviceExtension,Irp);
        break;

      case MU_IOCTL_MEMORY_TEST:
   
        ASSERT(Irp->UserBuffer && "MU_IOCTL_MEMORY_TEST");
         
        ASSERT((MU_VSC_BAD_BLOCK_COUNT_SIZE <= irpStack->Parameters.DeviceIoControl.OutputBufferLength) && 
                MU_IOCTL_MEMORY_TEST);
        
        status = MU_fVscCommand(
                    DeviceExtension,
                    Irp,
                    MU_VSC_MEMORY_TEST,
                    MU_VSC_BAD_BLOCK_COUNT_SIZE
                    );
        break;
      
#endif

      default:
        USB_DBG_ERROR_PRINT((
            "MuDiskDeviceControl: disk device doesn't handle IOCTL %08x\n",
            irpStack->Parameters.DeviceIoControl.IoControlCode
            ));
        Irp->IoStatus.Information = 0;
        status = STATUS_INVALID_DEVICE_REQUEST;
        break;
    }
    
    //
    //  If the status is not pending, complete
    //  the current IRP and return an error
    //

    if(status != STATUS_PENDING)
    {
        Irp->IoStatus.Status = status;
        MU_COMPLETE_REQUEST(DeviceExtension, Irp, IO_NO_INCREMENT);
        IoStartNextPacket(DeviceExtension->DeviceObject);
    }
    return;    
}


NTSTATUS
FASTCALL
MU_fDiskReadDriveCapacity(
    IN PMU_DEVICE_EXTENSION DeviceExtension,
    PIRP Irp
    )
/*++
    Routine Description:
        Builds an MRB for Read Capacity and submits it
        to the MRB state machine
--*/
{
    PREAD_CAPACITY_DATA readCapacityBuffer;
    PMU_REQUEST_BLOCK   mrb;

    //
    // Allocate read capacity buffer
    //

    readCapacityBuffer = (PREAD_CAPACITY_DATA) RTL_ALLOCATE_HEAP(sizeof(READ_CAPACITY_DATA));
    
    if (!readCapacityBuffer)
    {
        DeviceExtension->PendingIrp->IoStatus.Information = 0;
        USB_DBG_WARN_PRINT(("Insufficient Memory to allocate READ_CAPACITY_DATA buffer"));
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Fill out the mrb
    //
 
    mrb = &DeviceExtension->Mrb;
    mrb->DataBuffer = (PUCHAR) readCapacityBuffer;
    mrb->TransferLength = sizeof(READ_CAPACITY_DATA);
    mrb->CompletionRoutine = MU_DiskReadCapacityCompletion;
    mrb->TimeOutValue = MRB_READ_CAPACITY_TIMEOUT;
    mrb->Retries = MRB_MAXIMUM_RETRIES;
    mrb->Flags = MRB_FLAGS_DATA_IN;

    //
    //  Fill out the CDB
    //

    RtlZeroMemory(&mrb->Cbw.Cdb, sizeof(CDB));
    mrb->Cbw.Cdb.CDB10.OperationCode = SCSIOP_READ_CAPACITY;
    
    //
    //  Submit the MRB
    //

    MU_fStartMrb(DeviceExtension);

    return STATUS_PENDING;
} // end MuDiskReadDriveCapacity()

VOID
MU_DiskReadCapacityCompletion(
    IN PMU_DEVICE_EXTENSION DeviceExtension,
    IN NTSTATUS Status
    )
/*++
    Routine Description:
        The MRB completion routine called when SCIOP_READ_CAPACITY
        returns.

        This was called either so we could complete an
        IOCTL_DISK_GET_DRIVE_GEOMETRY request or to complete
        IOCTL_DISK_GET_PARTITION_INFO.

        So we calculate both and cache them, then figure
        out which Irp is outstanding and complete it.
--*/
{

    PDISK_GEOMETRY diskGeometry;
    PPARTITION_INFORMATION partitionInformation;
    PREAD_CAPACITY_DATA readCapacityBuffer = (PREAD_CAPACITY_DATA) DeviceExtension->Mrb.DataBuffer;
    PIO_STACK_LOCATION  irpStack = IoGetCurrentIrpStackLocation(DeviceExtension->PendingIrp);

    //
    //  If the Mrb failed, then fail the Irp.  The Mrb
    //

    if(NT_ERROR(Status))
    {
        DeviceExtension->PendingIrp->IoStatus.Information = 0;
        DeviceExtension->PendingIrp->IoStatus.Status = Status;
        USB_DBG_WARN_PRINT(("ReadCapacity Transfer Failed"));
        goto MU_DiskReadCapacityCompletionCleanup;
    }
        
    ULONG bytesPerLogicalBlock = ReverseEndian(readCapacityBuffer->BytesPerLogicalBlock);
    ULONG mediaBlockSize = bytesPerLogicalBlock * 
                           ReverseEndian(readCapacityBuffer->LogicalBlocksPerMediaBlock);
    ULONG logicalBlockCount = ReverseEndian(readCapacityBuffer->LogicalBlockAddress) + 1;
    ULONGLONG totalCapacity = ((ULONGLONG)logicalBlockCount) * bytesPerLogicalBlock ;

    // The LogicalBlocksPerMediaBlock was added after the original FW, so if it is zero
    // use the default value.
    if(0 == mediaBlockSize) 
        mediaBlockSize = DEFAULT_MEDIA_BLOCK_SIZE;

    //
    //  Check the capacity data to ensure we can support the device.
    //  If any of our requirements are not met, we will fail the IRP.
    //  This effectively makes the MU unmountable.
    //  Requirements:
    //  1) BytesPerLogicalBlock - Must be a power of 2 not greater than the EMULATED_SECTOR_SIZE(=4096).
    //  2) MediaBlockSize - Must be an integer multiple of the EMULATED_SECTOR_SIZE, but not greater than
    //                      the MAXIMUM_MEDIA_BLOCK_SIZE.
    //  3) Total Capacity - must be not less than the mediaBlockSize and not greater than 2^32 = 4 GB.
    //  4) logicalBlockCount - must be non-zero.  This is an artifact of adding 1 to the LogicalBlockAddress
    //                         really it is saying that the LogicalBlockAddress may not be the maximum
    //                         value, which would exceed the capacity limit anyway.
    if(
        !IsPowerOf2(bytesPerLogicalBlock) ||
        (bytesPerLogicalBlock > EMULATED_SECTOR_SIZE) ||
        (mediaBlockSize > MAXIMUM_MEDIA_BLOCK_SIZE) ||
        (mediaBlockSize%EMULATED_SECTOR_SIZE) ||
        (0 == logicalBlockCount) ||
        (totalCapacity < mediaBlockSize) ||
        (totalCapacity > (((ULONGLONG)1)<<32))
    )
    {
        DeviceExtension->PendingIrp->IoStatus.Information = 0;
        DeviceExtension->PendingIrp->IoStatus.Status = STATUS_UNRECOGNIZED_VOLUME;
        USB_DBG_WARN_PRINT(("The logical block configuration of an MU is outside supported parameter ranges."));
        goto MU_DiskReadCapacityCompletionCleanup;
    }

    //
    //  Store media capacity and media block size
    //
    DeviceExtension->PartitionLength.QuadPart = totalCapacity;
    DeviceExtension->MediaBlockSize = mediaBlockSize;
    
    //
    // Calculate logical block to byte shift.
    //
    DeviceExtension->LogicalBlockShift = WhichBit(bytesPerLogicalBlock);
    
    //
    //  Fill out the geometry information (note that BytesPerSector
    //  is our fixed EMULATED_SECTOR_SIZE.)
    USB_DBG_TRACE_PRINT(("Geometry Buffer @ 0x%0.8x", &DeviceExtension->DiskGeometry));
    DeviceExtension->DiskGeometry.MediaType = FixedMedia;
    DeviceExtension->DiskGeometry.Cylinders.QuadPart = totalCapacity/mediaBlockSize;
    DeviceExtension->DiskGeometry.TracksPerCylinder = 1; 
    DeviceExtension->DiskGeometry.SectorsPerTrack = mediaBlockSize / EMULATED_SECTOR_SIZE;
    DeviceExtension->DiskGeometry.BytesPerSector = EMULATED_SECTOR_SIZE;

    //
    // now fill the appropriate Irp buffer results
    //

    switch (irpStack->Parameters.DeviceIoControl.IoControlCode)
    {
      case IOCTL_DISK_GET_DRIVE_GEOMETRY:

        diskGeometry = (PDISK_GEOMETRY)DeviceExtension->PendingIrp->UserBuffer;
        RtlCopyMemory(diskGeometry, &DeviceExtension->DiskGeometry, sizeof(DISK_GEOMETRY));

        DeviceExtension->PendingIrp->IoStatus.Information = sizeof(DISK_GEOMETRY);
        DeviceExtension->PendingIrp->IoStatus.Status = STATUS_SUCCESS;

        break;        

      case IOCTL_DISK_GET_PARTITION_INFO:

        //
        // Fill in the output buffer and return.
        //

        partitionInformation = (PPARTITION_INFORMATION)DeviceExtension->PendingIrp->UserBuffer;

        RtlZeroMemory(partitionInformation, sizeof(PARTITION_INFORMATION));

        partitionInformation->PartitionLength = DeviceExtension->PartitionLength;
        partitionInformation->RecognizedPartition = TRUE;

        DeviceExtension->PendingIrp->IoStatus.Information = sizeof(PARTITION_INFORMATION);
        DeviceExtension->PendingIrp->IoStatus.Status = STATUS_SUCCESS;

        break;

#ifdef MU_DIAGNOSTIC_IOCTLS
      //
      //  MU_IOCTL_GET_BAD_BLOCK_TABLE requires a READ_CAPACITY to proceed it.
      //  This could be why we are here.
      //
      case MU_IOCTL_GET_BAD_BLOCK_TABLE:
        {        
          NTSTATUS status = MU_fVscCommand(
                              DeviceExtension,
                              DeviceExtension->PendingIrp,
                              MU_VSC_GET_BAD_BLOCK_TABLE,
                              MU_VSC_BAD_BLOCK_TABLE_SIZE
                              );
          if(STATUS_PENDING == status)
          {
            RTL_FREE_HEAP(readCapacityBuffer);
            return;
          }
        }        
        break;            
#endif

    }

MU_DiskReadCapacityCompletionCleanup: //error paths rejoin here for cleanup

    //
    // Deallocate read capacity buffer.
    //

    RTL_FREE_HEAP(readCapacityBuffer);

    //
    //  Complete the Irp
    //

    MU_COMPLETE_REQUEST(DeviceExtension, DeviceExtension->PendingIrp, IO_NO_INCREMENT);
    
    //
    //  Start processing the next Irp.
    //

    IoStartNextPacket(DeviceExtension->DeviceObject);

   return;
} 

VOID
FASTCALL
MU_fDiskVerify(
    IN PMU_DEVICE_EXTENSION DeviceExtension,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine handles the IOCTL_DISK_VERIFY request.

Arguments:

    DeviceObject - Specifies the device object that the I/O request is for.

    Irp - Specifies the packet that describes the I/O request.

Return Value:

    Status of operation.

--*/
{
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    PVERIFY_INFORMATION verifyInfo = (PVERIFY_INFORMATION)irpStack->Parameters.DeviceIoControl.InputBuffer;
    PMU_REQUEST_BLOCK    mrb = &DeviceExtension->Mrb;

    ULONG         logicalBlockOffset;
    USHORT        logicalBlockCount;

    //
    // Verify sectors
    //

    mrb->Cbw.Cdb.CDB10.OperationCode = SCSIOP_VERIFY;

    //
    //  Assert that the parameter to verify are reasonable.
    //
    ASSERT(sizeof(VERIFY_INFORMATION) <= irpStack->Parameters.DeviceIoControl.InputBufferLength);
    ASSERT(verifyInfo);
    ASSERT(0==verifyInfo->StartingOffset.QuadPart%EMULATED_SECTOR_SIZE);
    ASSERT(verifyInfo->Length);
    ASSERT(0==verifyInfo->Length%EMULATED_SECTOR_SIZE);
    
    //
    // Convert byte offset to logical block offset.
    //

    logicalBlockOffset = (ULONG)(verifyInfo->StartingOffset.QuadPart >> DeviceExtension->LogicalBlockShift);

    //
    // Convert ULONG byte count to USHORT sector count.
    //
    
    logicalBlockCount = (USHORT)(verifyInfo->Length >> DeviceExtension->LogicalBlockShift);

    //
    // Fill out the mrb
    //
 
    mrb->DataBuffer = NULL;
    mrb->TransferLength = 0;
    mrb->CompletionRoutine = MU_DiskIoComplete;
    mrb->TimeOutValue = MRB_CALC_VERIFY_TIMEOUT(verifyInfo->Length);
    mrb->Retries = MRB_MAXIMUM_RETRIES;
    mrb->Flags = MRB_FLAGS_NO_DATA_TRANSFER;
    
    //
    //  Fill out the CDB
    //

    RtlZeroMemory(&mrb->Cbw.Cdb, sizeof(CDB));
    mrb->Cbw.Cdb.CDB10.OperationCode = SCSIOP_VERIFY;
    
    //
    // Move little endian values into CDB in big endian format.
    //

    mrb->Cbw.Cdb.CDB10.LogicalBlock = ReverseEndian(logicalBlockOffset);
    mrb->Cbw.Cdb.CDB10.TransferBlocks = ReverseEndian(logicalBlockCount);

    //
    //  Submit the MRB
    //

    MU_fStartMrb(DeviceExtension);

    return;
}


VOID
MU_DiskReadComplete(
    IN PMU_DEVICE_EXTENSION DeviceExtension,
    IN NTSTATUS Status
    )
/*++
    Routine Description:
        Completion routine for read requests.  Added so we can check for
        the corruption pattern at the start of each EMULATED_SECTOR.
--*/
{

    PUCHAR buffer = DeviceExtension->Mrb.DataBuffer;
    PUCHAR bufferEnd = DeviceExtension->Mrb.DataBuffer + DeviceExtension->Mrb.TransferLength;
    //Loop over the buffer checking the beginning of each emulated sector
    for(; buffer < bufferEnd; buffer += EMULATED_SECTOR_SIZE)
    {
        ULONG patternOffset = 0;
        //
        //  Loop as long as the pattern matches
        //
        while( ((PULONG)buffer)[patternOffset] == MU_CORRUPT_SECTOR_PATTERN[patternOffset])
        {
            //If we have reach the end of the pattern, then there is a match
            //we need to complete with an error
            if(++patternOffset == MU_CORRUPT_SECTOR_PATTERN_ULONG_COUNT)
            {
                ULONG oldProtect = MmQueryAddressProtect(buffer);
                ULONG newProtect = ((ULONG)-1);
                USB_DBG_WARN_PRINT(("MU_DiskReadComplete Corrupt Sector Found"));

                //Only change the status, if it was a success code.
                if(NT_SUCCESS(Status)) 
                {
                    Status = STATUS_DATA_ERROR;
                }

                //erase the pattern from the return buffer (if the user doesn't
                //check the error and reads it, then they may write and this
                //will make us return more problems.  Just nip it in the bud
                //here. Fill with "FAIL" a.k.a 'LIAF'.
                //
                // BTW, even though we read into it via DMA, if it is the filesystem
                // cache it may be marked PAGE_READONLY.  If so we need to
                // switch that off first, then switch it back on.
                if(PAGE_READONLY == ((PAGE_READONLY|PAGE_READWRITE)&oldProtect))
                {
                    newProtect = oldProtect; //Use the old protection as the base.
                    newProtect &= ~PAGE_READONLY; //clear readonly
                    newProtect |= PAGE_READWRITE; //set readwrite
	                MmSetAddressProtect(buffer, MU_CORRUPT_SECTOR_PATTERN_SIZE, newProtect);
                }
                
                while(patternOffset--)
                {
                    ((PULONG)buffer)[patternOffset] = 'LIAF';
                }
        
                if(((ULONG)-1) != newProtect)
                {
                    MmSetAddressProtect(buffer, MU_CORRUPT_SECTOR_PATTERN_SIZE, oldProtect);
                }
                break;
            }
        }
    }

    MU_DiskIoComplete(DeviceExtension, Status);
    return;
}


VOID
MU_DiskIoComplete(
    IN PMU_DEVICE_EXTENSION DeviceExtension,
    IN NTSTATUS Status
    )
/*++
    Routine Description:
        General compeltion routine for MRB requests that require no post processing.
        The status is checked and the Irp is completed accordingly.  On success,
        Information is set to the length of the transfer, on failure it is set to
        zero.

    This is used as the completion for MU_fDiskVerify and MU_fDiskRead.  Unfortunately,
    it cannot be worked into the write state machine.
--*/
{
    DeviceExtension->PendingIrp->IoStatus.Status = Status;
    if(NT_ERROR(Status))
    {
        DeviceExtension->PendingIrp->IoStatus.Information = 0;
        USB_DBG_WARN_PRINT(("MU_DiskIoComplete Transfer Failed"));
    } else
    {
        DeviceExtension->PendingIrp->IoStatus.Information = DeviceExtension->Mrb.TransferLength;
    }
    
    //
    //  Complete the request
    //

    MU_COMPLETE_REQUEST(DeviceExtension, DeviceExtension->PendingIrp, IO_NO_INCREMENT);
    
    //
    //  Start processing the next Irp.
    //
    IoStartNextPacket(DeviceExtension->DeviceObject);
}


VOID
FASTCALL
MU_fDiskReadWrite(
    IN PMU_DEVICE_EXTENSION DeviceExtension,
    IN PIRP Irp
    )
/*++
    Routine Description:
       Does the basic work of setting up a Read or Write to determine if
       a the operation may be performed, to calculate the logical block
       offset and count. On read submits the Mrb and sets MU_DiskIoComplete
       as the completion routine.  On write, it needs to worry about
       aligment issues and to submit the request to the MrbState machine.
--*/
{
    PIO_STACK_LOCATION  irpStack = IoGetCurrentIrpStackLocation(Irp);
    PUCHAR              virtualAddress = NULL;

    ULONG               byteOffset = irpStack->Parameters.Read.ByteOffset.LowPart;
    ASSERT(0==irpStack->Parameters.Read.ByteOffset.HighPart);

    ULONG               transferLength = irpStack->Parameters.Read.Length;

    //
    //  Check the byteOffset and transferLength against the disk
    //  partition length, also double check that they are properly
    //  sector aligned.
    //
    if(
        (0!=byteOffset%EMULATED_SECTOR_SIZE) ||
        (0!=transferLength%EMULATED_SECTOR_SIZE) ||
        (irpStack->Parameters.Read.ByteOffset.QuadPart + transferLength) >
        DeviceExtension->PartitionLength.QuadPart)
    {
        USB_DBG_WARN_PRINT(("MU_fDiskReadWrite: failing transfer with illegal byte offset or length"));
        Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
    }

    //
    //  Check for Zero length transfer, just succeed these
    //

    else if (transferLength == 0)
    {
        Irp->IoStatus.Status = STATUS_SUCCESS;
    }

    //
    //  Get the usable virtual address of the buffer to send,
    //  or receive data.
    //
    else
    {

        //
        //  SL_FSCACHE_REQUEST indicate that the transfer is to\from cached memory mapped
        //  by the buffer in the irpStack.
        //

        if(TEST_FLAG(irpStack->Flags,SL_FSCACHE_REQUEST))
        {
            virtualAddress = (PUCHAR) irpStack->Parameters.Read.CacheBuffer;

            ASSERT(virtualAddress != NULL);
        }
        else
        //
        //  SL_FSCACHE_REQUEST is not set.  The transfer is to\from the UserBuffer.
        //
        {
            virtualAddress = (PUCHAR) Irp->UserBuffer;

            ASSERT(virtualAddress != NULL);

            //
            //  Add the buffer offset to the address we were passed.
            //
            virtualAddress += irpStack->Parameters.Read.BufferOffset;
        }

        //
        //  For convience we reuse the BufferOffset to store
        //  the computed virtual address for later.
        //

        irpStack->Parameters.Read.BufferOffset = (ULONG) virtualAddress;
    }

    //
    //  If for some reason no transfer is required
    //  complete the Irp and start the next one.
    //

    if(NULL == virtualAddress)
    {
        Irp->IoStatus.Information = 0;
        MU_COMPLETE_REQUEST(DeviceExtension, Irp, IO_NO_INCREMENT);
        IoStartNextPacket(DeviceExtension->DeviceObject);
        return;
    }

    //
    //  Zero out the Cdb, we will start filling it out.
    //

    RtlZeroMemory(&DeviceExtension->Mrb.Cbw.Cdb, sizeof(CDB));
    
    //
    //  If this is a write then make then check for alignment,
    //  set flags and make appropriate adjustment.
    //

    if(IRP_MJ_WRITE == irpStack->MajorFunction)
    {

        //
        //  Clear the write state machine has flags
        //

        CLEAR_FLAG(DeviceExtension->DeviceFlags, MU_WRITE_HAS_FLAGS);

        //
        //  Adjust the starting offset alignment.
        //

        if(byteOffset%DeviceExtension->MediaBlockSize)
        {
            ULONG initialLength = DeviceExtension->MediaBlockSize - (byteOffset%DeviceExtension->MediaBlockSize);
            DeviceExtension->InitialWriteByteCount = initialLength;
            
            // Check for a Partial Middle Write (i.e. a write
            // which starts in the middle of a media block and
            // and ends before the end of the same media block).
            if(initialLength > transferLength)
            {
                //Set the middle portion flag 
                SET_FLAG(DeviceExtension->DeviceFlags, MU_WRITE_HAS_MIDDLE_PORTION);
                //Fix up the FinalWriteByteCount the way the middle state machine likes it.
                DeviceExtension->FinalWriteByteCount = initialLength - transferLength;
                //Start the partial write state machine.
                MU_DiskStartPartialWrite(DeviceExtension, STATUS_SUCCESS);
                return;
            }
            byteOffset += initialLength;
            virtualAddress += initialLength;
            transferLength -= initialLength;
            SET_FLAG(DeviceExtension->DeviceFlags, MU_WRITE_HAS_INITIAL_PORTION);
            USB_DBG_TRACE_PRINT(("Write has initial portion."));
        }

        //
        //  Adjust the ending alignment
        //
        if(transferLength%DeviceExtension->MediaBlockSize)
        {
            DeviceExtension->FinalWriteByteCount = transferLength%DeviceExtension->MediaBlockSize;
            transferLength -= DeviceExtension->FinalWriteByteCount;
            SET_FLAG(DeviceExtension->DeviceFlags, MU_WRITE_HAS_FINAL_PORTION);
            USB_DBG_TRACE_PRINT(("Write has final portion."));
        }

        //
        //  If there is no whole portion, then jump into partial
        //  transfer state machine.
        //

        if(0 == transferLength)
        {
           MU_DiskStartPartialWrite(DeviceExtension, STATUS_SUCCESS);
           return;
        }

        USB_DBG_TRACE_PRINT(("Write has whole portion."));
        //
        //  If there were alignment adjustments then set the completion
        //  routine to MU_DiskStartPartialWrite, otherwise
        //  it is a one step write and we can use MU_DiskIoComplete.
        //

        if(TEST_FLAG(DeviceExtension->DeviceFlags, MU_WRITE_HAS_FLAGS))
        {
            DeviceExtension->Mrb.CompletionRoutine = MU_DiskStartPartialWrite;        
        } else
        {
            DeviceExtension->Mrb.CompletionRoutine = MU_DiskIoComplete;
        }

        //
        //  Setup the parts of the MRB that indicate a write request
        //

        DeviceExtension->Mrb.Flags = MRB_FLAGS_DATA_OUT;
        DeviceExtension->Mrb.Cbw.Cdb.CDB10.OperationCode = SCSIOP_WRITE;

    } else
    //
    //  This is a read request, setup the parts of the MRB
    //  that indicate a read request
    //
    {
        DeviceExtension->Mrb.CompletionRoutine = MU_DiskReadComplete;
        DeviceExtension->Mrb.Flags = MRB_FLAGS_DATA_IN;
        DeviceExtension->Mrb.Cbw.Cdb.CDB10.OperationCode = SCSIOP_READ;
    }
    
    //
    //  Setup the rest of the MRB
    //

    DeviceExtension->Mrb.DataBuffer = virtualAddress;
    DeviceExtension->Mrb.TransferLength = transferLength;
    DeviceExtension->Mrb.TimeOutValue = MRB_STANDARD_TIMEOUT;
    DeviceExtension->Mrb.Retries = MRB_MAXIMUM_RETRIES;

    //
    //  Set the block information in the CDB
    //
    DeviceExtension->Mrb.Cbw.Cdb.CDB10.LogicalBlock = ReverseEndian(byteOffset >> DeviceExtension->LogicalBlockShift);
    DeviceExtension->Mrb.Cbw.Cdb.CDB10.TransferBlocks = ReverseEndian((USHORT)(transferLength >> DeviceExtension->LogicalBlockShift));

    //
    //  Submit the MRB
    //

    MU_fStartMrb(DeviceExtension);
}

VOID
MU_DiskStartPartialWrite(
    IN PMU_DEVICE_EXTENSION DeviceExtension,
    IN NTSTATUS Status
    )
/*++
    Routine Description:
        This routine is called to begin writes of partial media blocks.  It can
        be called directly by MU_fDiskReadWrite if there is no contiguous portion
        of the write or it is called as the MRB completion routine for the
        contiguous portion.  Either way, it is called at DPC level.

        Partial Write requests use a global write buffer.  As such they must be
        serialized system wide across all MUs.  This routine either begins
        the partial transfer, or it inserts the request into the queue.
--*/
{
    PIRP irp = DeviceExtension->PendingIrp;
    
    //
    //  Clear the write state machine flags
    //
    CLEAR_FLAG(DeviceExtension->DeviceFlags,MU_WRITE_STATE_BITS);

    //
    //  Make sure that the previous stage succeeded, if not
    //  just fail the Irp here.
    //
    if(NT_ERROR(Status))
    {
       irp->IoStatus.Status = Status;
       irp->IoStatus.Information = 0;
       MU_COMPLETE_REQUEST(DeviceExtension, irp, IO_NO_INCREMENT);
       IoStartNextPacket(DeviceExtension->DeviceObject);
       return;
    }

    //
    //  We can setup the common section of the MRB here
    //
    
    PMU_REQUEST_BLOCK mrb = &DeviceExtension->Mrb;
    RtlZeroMemory(&mrb->Cbw.Cdb, sizeof(CDB));
    mrb->TimeOutValue = MRB_STANDARD_TIMEOUT;
    mrb->Retries = MRB_MAXIMUM_RETRIES;

    // Choose the correct state machine, and initialize to start.
    if(TEST_FLAG(DeviceExtension->DeviceFlags,MU_WRITE_HAS_MIDDLE_PORTION))
    {
        mrb->CompletionRoutine = MU_DiskWriteBuildMiddlePartialRequest;
        SET_FLAG(DeviceExtension->DeviceFlags,MU_WRITE_STATE_MIDDLE_START);
    } else
    {
        mrb->CompletionRoutine = MU_DiskWriteBuildPartialRequest;
        SET_FLAG(DeviceExtension->DeviceFlags,MU_WRITE_STATE_START);
    }

    //
    // see if the list of pending partial requests is empty
    //

    if (IsListEmpty(&MU_DriverExtension.PartialRequestQueue))
    {
        //
        // process this one immediately
        //

        InsertHeadList(&MU_DriverExtension.PartialRequestQueue,
                       &irp->Tail.Overlay.ListEntry);

        USB_DBG_TRACE_PRINT(("StartPartialRequest: Queuing Irp at the head %x, flink %x, blink %x",
                   irp,
                   MU_DriverExtension.PartialRequestQueue.Flink,
                   MU_DriverExtension.PartialRequestQueue.Blink));
        //
        //  Start the request, call through the mrb->CompletionRoutine
        //  pointer so as to start the proper state machine.
        //

        mrb->CompletionRoutine(DeviceExtension, STATUS_SUCCESS);
        return;
       
    } else {

        ASSERT(MU_DriverExtension.PartialRequestQueue.Flink != (PLIST_ENTRY)&irp->Tail.Overlay.ListEntry);

        //
        // queue this request...
        //

        InsertTailList(&MU_DriverExtension.PartialRequestQueue, &irp->Tail.Overlay.ListEntry);

        USB_DBG_TRACE_PRINT(("StartPartialRequest: Queuing Irp %x, f %x, b %x",
                       irp,
                       MU_DriverExtension.PartialRequestQueue.Flink,
                       MU_DriverExtension.PartialRequestQueue.Blink));
    }
}

VOID
MU_DiskWriteBuildPartialRequest(
    IN PMU_DEVICE_EXTENSION DeviceExtension,
    IN NTSTATUS Status
    )
/*++
    Routine Description:
        This routine is the heart of MU write state machine.  It is its own completion routine
        routine.   It builds and submits MRBs.  It works as follows:

        1) Increment the write state to the next state needed based on the DF_WRITE_HAS_XXX
        flags.

        2) switch the new state, and build an appriopriate MRB.

        3) submit the MRB.

        When the last required stage completes:
        
        4) Complete the Irp.

        5) Call IoStartNextPacket for current device

        5) Continue with the next pending partial write (for a different device)

   Note:
    There are fields of the MRB that are NOT setup here:  


    These are the same for every stage and MU_DiskStartPartialWrite before the partial portion of the request
    is queued.

--*/
{
        PIRP irp = DeviceExtension->PendingIrp;
        PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(irp);
        ULONG  byteOffset;
        ULONG  writeState = DeviceExtension->DeviceFlags&MU_WRITE_STATE_BITS;

        if(NT_SUCCESS(Status))
        {
            //
            // Increment to the next state.  
            //
            writeState += MU_WRITE_STATE_INCREMENT;
        
            //
            //  If the current stage is an initial read, and an initial
            //  read is not required, skip to final read.
            //
            if(MU_WRITE_STATE_INITIAL_READ == writeState)
            {
                if(!TEST_FLAG(DeviceExtension->DeviceFlags, MU_WRITE_HAS_INITIAL_PORTION))
                {
                    writeState = MU_WRITE_STATE_FINAL_READ;
                }
            }

            //
            //  If the current stage is a final read, and a final
            //  read is not required, skip to done.
            //

            if(MU_WRITE_STATE_FINAL_READ == writeState)
            {
                if(!TEST_FLAG(DeviceExtension->DeviceFlags, MU_WRITE_HAS_FINAL_PORTION))
                {
                    writeState = MU_WRITE_STATE_DONE;
                }
            }
        } else
        //
        //  On any read errors in the state machine
        //  we need to modify the buffer with a bad
        //  sector pattern pattern and proceed to
        //  the write stage anyway
        //
        {
            //
            if(
                ( (MU_WRITE_STATE_INITIAL_READ == writeState)
                  ||(MU_WRITE_STATE_FINAL_READ == writeState) ) &&
                (STATUS_DATA_ERROR == Status)
            )
            {
                MU_fMarkWriteBufferCorrupt(&DeviceExtension->Mrb);
                // Go on to the next phase
                Status = STATUS_SUCCESS;
                writeState += MU_WRITE_STATE_INCREMENT;
            } else
            //
            //  If the write failed during a write phase, or
            //  for a reason other than a STATUS_DATA_ERROR
            //  (failed CSW), then just keep the error go to
            //  the done state, which will complete the IRP
            //  with the error.
            //
            {
                writeState = MU_WRITE_STATE_DONE;
            }
        }

        //
        //  Write the writeState back
        //
        CLEAR_FLAG(DeviceExtension->DeviceFlags,MU_WRITE_STATE_BITS);
        SET_FLAG(DeviceExtension->DeviceFlags,writeState);
        
        //
        //  Start working on the mrb.
        //
        PMU_REQUEST_BLOCK mrb = &DeviceExtension->Mrb;
        
        //
        //  switch on the stage we need to program
        //
        switch(writeState)
        {
          case MU_WRITE_STATE_INITIAL_READ:
            USB_DBG_TRACE_PRINT(("Starting initial portion."));
            
            //
            //  Read the portion of the first block prior to the start of the
            //  requested write.
            //

            mrb->DataBuffer = MU_DriverExtension.WriteBuffer;
            mrb->TransferLength = DeviceExtension->MediaBlockSize - DeviceExtension->InitialWriteByteCount;
            mrb->Flags = MRB_FLAGS_DATA_IN;
            mrb->Cbw.Cdb.CDB10.OperationCode = SCSIOP_READ;

            //
            //  The byteOffset is transfer length bytes behind the original byteOffset of the
            //  write request
            //
            byteOffset = irpStack->Parameters.Read.ByteOffset.LowPart-mrb->TransferLength;
            

            break;
          case MU_WRITE_STATE_INITIAL_WRITE:

            //
            //  Write one media block size out.  DataBuffer points to the user's
            //  data we are writing.

            //
            //  Setup MRB_FLAGS_SPLIT_WRITE feature, and its parameters: UserStartOffset,
            //  UserEndOffset so that MRB state machine knows to get the remaining data
            //  from the WriteBuffer.
            //
            mrb->Flags = MRB_FLAGS_DATA_OUT | MRB_FLAGS_SPLIT_WRITE;
            mrb->UserStartOffset = mrb->TransferLength;  //the UserStartOffset is the length we just read.
            mrb->UserEndOffset = DeviceExtension->MediaBlockSize; //The UserEndOffset is the end of the block

            mrb->DataBuffer = (PUCHAR)irpStack->Parameters.Read.BufferOffset;
            mrb->TransferLength = DeviceExtension->MediaBlockSize;
            mrb->Cbw.Cdb.CDB10.OperationCode = SCSIOP_WRITE;
            
            //
            //  The byteOffset is the UserStartOffset before the original write request byteOffset
            //
            byteOffset = irpStack->Parameters.Read.ByteOffset.LowPart-mrb->UserStartOffset;
            break;

          case MU_WRITE_STATE_FINAL_READ:
            
            USB_DBG_TRACE_PRINT(("Starting final portion."));
            
            //
            //  Read the the end of the block behind the final write byte count
            //
            
            mrb->DataBuffer = MU_DriverExtension.WriteBuffer;
            mrb->TransferLength = DeviceExtension->MediaBlockSize - DeviceExtension->FinalWriteByteCount;
            mrb->Flags = MRB_FLAGS_DATA_IN;
            mrb->Cbw.Cdb.CDB10.OperationCode = SCSIOP_READ;
            
            //
            //  The logicalBlockAddress should be the sector right after the length that
            //  we really want to write to.
            //
            //
            //  The byteOffset is the end of the original write request.
            //
            byteOffset = irpStack->Parameters.Read.ByteOffset.LowPart +
                         irpStack->Parameters.Read.Length;

            break;
          case MU_WRITE_STATE_FINAL_WRITE:

            //
            //  Write one media block size out.  DataBuffer points to the user's buffer.
            //
            
            //
            //  Setup MRB_FLAGS_SPLIT_WRITE feature, and its parameters: UserStartOffset,
            //  UserEndOffset so that MRB state machine knows to get the remaining data
            //  from the WriteBuffer.
            //
            mrb->Flags = MRB_FLAGS_DATA_OUT | MRB_FLAGS_SPLIT_WRITE;
            mrb->UserStartOffset = 0;  //The UserStartOffset is the beginning of the write.
            mrb->UserEndOffset = DeviceExtension->FinalWriteByteCount; //The UserEndOffset is the size of the user data
            mrb->Cbw.Cdb.CDB10.OperationCode = SCSIOP_WRITE;

            //
            //  The user data comes from the end of the user buffer.
            //
            mrb->DataBuffer = (PUCHAR) (irpStack->Parameters.Read.BufferOffset +
                                        irpStack->Parameters.Read.Length -
                                        DeviceExtension->FinalWriteByteCount);
            mrb->TransferLength = DeviceExtension->MediaBlockSize;

            //
            //  The byte offset is the length of the user buffer, DeviceExtension->FinalWriteByteCount
            //  before the end of the of the original request
            //
            byteOffset = irpStack->Parameters.Read.ByteOffset.LowPart +
                         irpStack->Parameters.Read.Length -
                         DeviceExtension->FinalWriteByteCount;

            break;
          case MU_WRITE_STATE_DONE:

            //*
            //* This case can be reached due to an error or because
            //* the transfer is over, either way the Status is correct
            //* complete the Irp with that status.
            //

            //
            //  Clear the write state flags.
            //

            CLEAR_FLAG(DeviceExtension->DeviceFlags, MU_WRITE_STATE_BITS);

            //
            // Remove the IRP we are working on from the global queue.
            //

            ASSERT(!IsListEmpty(&MU_DriverExtension.PartialRequestQueue));
            RemoveHeadList(&MU_DriverExtension.PartialRequestQueue);
            
            //
            //  Complete the write Irp
            //

            irp->IoStatus.Information = irpStack->Parameters.Read.Length;
            irp->IoStatus.Status = Status;
            MU_COMPLETE_REQUEST(DeviceExtension, irp, IO_NO_INCREMENT);

            //
            //  Start the next partial request.
            //  NOTE: that this request could not be
            //  for the same device we just finished with.
            //
            MU_DiskWriteStartNextPartialRequest();

            //
            //  Start the next I/O for the current device.
            //
            IoStartNextPacket(DeviceExtension->DeviceObject);

            return;

          default:

            //
            //  Reaching here is a bug in the write state machine.
            //

            ASSERT(FALSE);
            return; //To avoid a compiler warning, without extra code.
        }

        //
        //  Do the endian conversions to plug the LBA and Block Counts
        //  into the Cdb structure.
        //

        mrb->Cbw.Cdb.CDB10.LogicalBlock = ReverseEndian(byteOffset >> DeviceExtension->LogicalBlockShift);
        mrb->Cbw.Cdb.CDB10.TransferBlocks = ReverseEndian((USHORT)(mrb->TransferLength >> DeviceExtension->LogicalBlockShift));
        
        //
        //  Start the MRB
        //

        MU_fStartMrb(DeviceExtension);

        return;
}

VOID
MU_DiskWriteBuildMiddlePartialRequest(
    IN PMU_DEVICE_EXTENSION DeviceExtension,
    IN NTSTATUS Status
    )
/*++
    This routine is an alternative MU write state machine.  It is its own completion routine
    routine.   It handles the special case of a write to a "middle" partial request, that is a request
    that starts unaligned on the media block boundary and ends unaligned on the same media block.

    This state machine breaks a single media block up as follows:

    1) Read the portion of the media block before user's buffer into the WriteBuffer.
    2) Read the portion of the media block after the user's buffer into the WriteBuffer
       after the data read in 1).
    3) Write, use the MRB_FLAG_SPLIT_WRITE flag, to glue it all together properly.

    Only one instance of this state machine or the MU_DiskWriteBuildPartialRequest state machine
    can be running on the system globally.  Thus these routine work in tandem.

    NOTE: InitialWriteByteCount and FinalWriteByteCount were really named for the other
    state machine.  The interpretation here is as follows:
        InitialWriteByteCount - The length from offset of the beginning of the user buffer to
                                the end of the media block.
        FinalWriteByteCount - The length from offset of the end of the user buffer to
                              the end of the media block. (This is actually set after MU_fDiskReadWrite
                              knows the write will end up here).

--*/
{

        PIRP irp = DeviceExtension->PendingIrp;
        PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(irp);
        ULONG  byteOffset;
        ULONG  writeState = DeviceExtension->DeviceFlags&MU_WRITE_STATE_BITS;

        if(NT_SUCCESS(Status))
        {
            //
            // Increment to the next state.  
            //
            writeState += MU_WRITE_STATE_INCREMENT;
        } else
        //
        //  Handle errors
        //
        {

            //
            //  If the error occured during either of the read
            //  states and it was STATUS_DATA_ERROR, mark the
            //  sector as corrupt and continue
            //
            if(
                ( (MU_WRITE_STATE_MIDDLE_READ_BEFORE == writeState)
                  ||(MU_WRITE_STATE_MIDDLE_READ_AFTER == writeState) ) &&
                (STATUS_DATA_ERROR == Status)
            )
            {
                MU_fMarkWriteBufferCorrupt(&DeviceExtension->Mrb);
                // Go on to the next phase
                Status = STATUS_SUCCESS;
                writeState += MU_WRITE_STATE_INCREMENT;
            } else
            //
            //  If the write failed during a write phase, or
            //  for a reason other than a STATUS_DATA_ERROR
            //  (failed CSW), then just keep the error and go to
            //  the done state, which will complete the IRP
            //  with the error.
            //
            {
                writeState = MU_WRITE_STATE_MIDDLE_DONE;
            }
        }

        //
        //  Write the writeState back
        //
        CLEAR_FLAG(DeviceExtension->DeviceFlags,MU_WRITE_STATE_BITS);
        SET_FLAG(DeviceExtension->DeviceFlags,writeState);
        
        //
        //  Start working on the mrb.
        //
        PMU_REQUEST_BLOCK mrb = &DeviceExtension->Mrb;
        
        //
        //  switch on the stage we need to program
        //
        switch(writeState)
        {
      
          case MU_WRITE_STATE_MIDDLE_READ_BEFORE:
                
            //
            //  Read operation goes in
            //
            mrb->Flags = MRB_FLAGS_DATA_IN;
            mrb->Cbw.Cdb.CDB10.OperationCode = SCSIOP_READ;
            //
            //  Read the length of the media block before the requested read
            //  into the start of the WriteBuffer.
            //
            mrb->DataBuffer = MU_DriverExtension.WriteBuffer;
            mrb->TransferLength = DeviceExtension->MediaBlockSize - DeviceExtension->InitialWriteByteCount;
            //
            //  byteOffset start transferLength before the requested write.
            //
            byteOffset = irpStack->Parameters.Read.ByteOffset.LowPart-mrb->TransferLength;
            break;

          case MU_WRITE_STATE_MIDDLE_READ_AFTER:
            // Still a read since the last step.

            // Pickup read into the buffer where we left off in the last step, and
            // read until the end of the block
            mrb->DataBuffer = MU_DriverExtension.WriteBuffer + mrb->TransferLength;
            mrb->TransferLength = DeviceExtension->FinalWriteByteCount;
            //  
            //  The byteOffset starts right after the original requested write.
            //
            byteOffset = irpStack->Parameters.Read.ByteOffset.LowPart+
                                   irpStack->Parameters.Read.Length;

            break;

          case MU_WRITE_STATE_MIDDLE_WRITE:
            //
            //  Switch to a write operation and use MRB_FLAGS_SPLIT_WRITE
            //  feature.
            //
            mrb->Cbw.Cdb.CDB10.OperationCode = SCSIOP_WRITE;
            mrb->Flags = MRB_FLAGS_DATA_OUT | MRB_FLAGS_SPLIT_WRITE;

            //Set the offsets for the split write
            mrb->UserStartOffset = DeviceExtension->MediaBlockSize - DeviceExtension->InitialWriteByteCount;
            mrb->UserEndOffset = DeviceExtension->MediaBlockSize - DeviceExtension->FinalWriteByteCount;

            //The data buffer is the users data buffer, the transfer length
            //is a full media block
            mrb->DataBuffer = (PUCHAR)irpStack->Parameters.Read.BufferOffset;
            mrb->TransferLength = DeviceExtension->MediaBlockSize;

            //The byteOffste is StartOffset before the requested write.
            byteOffset = irpStack->Parameters.Read.ByteOffset.LowPart-mrb->UserStartOffset;
            break;

          case MU_WRITE_STATE_MIDDLE_DONE:       
            //*
            //* This case can be reached due to an error or because
            //* the transfer is over, either way the Status is correct
            //* complete the Irp with that status.
            //

            //
            //  Clear the write state flags.
            //

            CLEAR_FLAG(DeviceExtension->DeviceFlags, MU_WRITE_STATE_BITS);

            //
            // Remove the IRP we are working on from the global queue.
            //

            ASSERT(!IsListEmpty(&MU_DriverExtension.PartialRequestQueue));
            RemoveHeadList(&MU_DriverExtension.PartialRequestQueue);
            
            //
            //  Complete the write Irp
            //

            irp->IoStatus.Information = irpStack->Parameters.Read.Length;
            irp->IoStatus.Status = Status;
            MU_COMPLETE_REQUEST(DeviceExtension, irp, IO_NO_INCREMENT);

            //
            //  Start the next partial request.
            //  NOTE: that this request could not be
            //  for the same device we just finished with.
            //
            MU_DiskWriteStartNextPartialRequest();

            //
            //  Start the next I/O for the current device.
            //
            IoStartNextPacket(DeviceExtension->DeviceObject);

            return;

          default:

            //
            //  Reaching here is a bug in the write state machine.
            //

            ASSERT(FALSE);
            return; //To avoid a compiler warning, without extra code.
        }
        
        //
        //  Do the endian conversions to plug the LBA and Block Counts
        //  into the Cdb structure.
        //

        mrb->Cbw.Cdb.CDB10.LogicalBlock = ReverseEndian(byteOffset >> DeviceExtension->LogicalBlockShift);
        mrb->Cbw.Cdb.CDB10.TransferBlocks = ReverseEndian((USHORT)(mrb->TransferLength >> DeviceExtension->LogicalBlockShift));

        //
        //  Start the MRB
        //

        MU_fStartMrb(DeviceExtension);

        return;
}

VOID MU_DiskWriteStartNextPartialRequest()
/*++
  Routine Description:
    When either of the partial write state machines completes
    it calls this function to start the next pending partial
    on the correct state machine.
--*/
{
    PIRP irp;
    PIO_STACK_LOCATION irpStack;
    PMU_DEVICE_EXTENSION deviceExtension;

    if(!IsListEmpty(&MU_DriverExtension.PartialRequestQueue))
    {
        //
        //  Peek at head of list to get IRP, but don't
        //  dequeue it.
        //
        irp = CONTAINING_RECORD(
               MU_DriverExtension.PartialRequestQueue.Flink,
               IRP,
               Tail.Overlay.ListEntry
               );

        //
        //  We can find the device object in the stack location
        //  for the irp.  From their we get the device extension
        //  to start the irp on the proper partial write state machine
        //
        irpStack = IoGetCurrentIrpStackLocation(irp);
        deviceExtension = (PMU_DEVICE_EXTENSION) irpStack->DeviceObject->DeviceExtension;
        deviceExtension->Mrb.CompletionRoutine(deviceExtension,STATUS_SUCCESS);
    }
};



VOID
FASTCALL
MU_fMarkWriteBufferCorrupt(
    IN PMU_REQUEST_BLOCK Mrb
    )
/*++
    Routine Description:
        Marks up the WriteBuffer (used for partial write
        operations) with a pattern marking corruption at the
        beginning of each emulated sector.  This routine
        is called when the read phase of a partial write fails
        with a STATUS_DATA_ERROR (i.e. the device returned
        an error in the CSW).
--*/
{
    //
    //  Write the corrupt sector pattern at the beginning of each 4k of the 
    //  the data buffer in the MRB (should point somewhere into global write
    //  buffer).
    //
    for(ULONG Offset = 0; Offset < Mrb->TransferLength; Offset += EMULATED_SECTOR_SIZE)
    {
        RtlCopyMemory(
            Mrb->DataBuffer+Offset,
            MU_CORRUPT_SECTOR_PATTERN,
            MU_CORRUPT_SECTOR_PATTERN_SIZE
            );
    }
}


//*
//* These IOCTL are for running diagnostics on Memory Units.  The production line tests application
//* is the intended client, but there may be others.  A special compile switch is required
//* to build this.
//*
//*
#ifdef MU_DIAGNOSTIC_IOCTLS

NTSTATUS
FASTCALL         
MU_fVscCommand(
 IN PMU_DEVICE_EXTENSION DeviceExtension,
 IN PIRP Irp,
 IN BYTE bRequest,
 IN ULONG ulOutputSize
 )
/*++
    Routine Description:
       Sets up a request to get the Bad Block Table from an MU.
       
    Arguments:
        Irp->UserBuffer should have the output buffer for the
        Bad Block Table
        
        irpStack->DeviceIoControl.OutputBufferLength should be greater
        than or equal to MU_VSD_BAD_BLOCK_TABLE_SIZE
--*/
{
    NTSTATUS status = STATUS_PENDING;
    if(DeviceExtension->MuInstance)
    {
        PURB urb = (PURB)RTL_ALLOCATE_HEAP(sizeof(URB));
        if(urb)
        {
            //
            //  Build VSC request
            //
            
            USB_BUILD_CONTROL_TRANSFER(
                &urb->ControlTransfer,
                NULL,
                Irp->UserBuffer,
                ulOutputSize,
                USB_TRANSFER_DIRECTION_IN,
                MU_VscComplete,
                DeviceExtension,
                FALSE,
                USB_DEVICE_TO_HOST|USB_CLASS_COMMAND|USB_COMMAND_TO_INTERFACE,
                bRequest,
                0,
                DeviceExtension->MuInstance->InterfaceNumber,
                ulOutputSize
                );
            //
            //  Submit the request
            //

            DeviceExtension->MuInstance->Device->SubmitRequest(urb);
        } else
        {
            status = STATUS_INSUFFICIENT_RESOURCES;
        }
    } else
    {
        status = STATUS_DEVICE_NOT_CONNECTED;
    }

    return status;
}

VOID
MU_VscComplete(
    IN PURB   Urb,
    IN PVOID  Context
    )
/*++
    Routine Description:
       Completion routine for all VSC, just fills out
       the Irp.IoStatus fields and completes the IRP.
--*/
{

    PMU_DEVICE_EXTENSION deviceExtension = (PMU_DEVICE_EXTENSION)Context;
    PIRP irp = deviceExtension->PendingIrp;

    irp->IoStatus.Status = IUsbDevice::NtStatusFromUsbdStatus(Urb->Header.Status);
    irp->IoStatus.Information = Urb->ControlTransfer.TransferBufferLength;

    //
    //  Free the URB
    //
    RTL_FREE_HEAP(Urb);

     //
    //  Complete the Irp
    //

    MU_COMPLETE_REQUEST(deviceExtension, irp, IO_NO_INCREMENT);
    
    //
    //  Start processing the next Irp.
    //

    IoStartNextPacket(deviceExtension->DeviceObject);

    return;
}

#endif


//*
//* These routines are called via macros that should only call them in debug
//* builds.
//*

#if DBG

VOID
MUDebugWatchdogDpcRoutine(
    PKDPC,
    PMU_DEVICE_EXTENSION DeviceExtension,
    PVOID,
    PVOID
    )
{
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(DeviceExtension->PendingIrp);
    //
    //  This gets hit when an IRP hangs.
    //  Spew as much useful information
    //  The call KeDebugBreak;
    //
    DbgPrint("MU DRIVER IRP WATCHDOG TIMER HAS EXPIRED. Please report this hang.\n");
    DbgPrint("MU Device Extension: 0x%0.8x, Irp: 0x%0.8x\n", DeviceExtension, DeviceExtension->PendingIrp);

    // Print Irp Information
    switch (irpStack->MajorFunction)
    {
      case IRP_MJ_DEVICE_CONTROL:
        switch(irpStack->Parameters.DeviceIoControl.IoControlCode)
        {
            case IOCTL_DISK_GET_DRIVE_GEOMETRY:
                DbgPrint("IOCTL_DISK_GET_DRIVE_GEOMETRY\n");
                break;
            case IOCTL_DISK_GET_PARTITION_INFO:
                DbgPrint("IOCTL_DISK_GET_PARTITION_INFO\n");
                break;
            case IOCTL_DISK_VERIFY:
                DbgPrint("IOCTL_DISK_VERIFY: Offset = 0x%0.8x, Length = 0x%0.8x\n",
                        irpStack->Parameters.Read.ByteOffset.LowPart,irpStack->Parameters.Read.Length);
                break;
            #ifdef MU_DIAGNOSTIC_IOCTLS
            case MU_IOCTL_GET_BAD_BLOCK_TABLE:
                DbgPrint("MU_IOCTL_GET_BAD_BLOCK_TABLE\n");
                break;
            case MU_IOCTL_MEMORY_TEST:
                DbgPrint("MU_IOCTL_MEMORY_TEST\n");
                break;
            #endif
            default:
                DbgPrint("IOCTL = 0x%0.8x\n", irpStack->Parameters.DeviceIoControl.IoControlCode);
                break;
        }
        break;
      case IRP_MJ_WRITE:
        DbgPrint("Write: Buffer = 0x%0.8x, Offset = 0x%0.8x, Length = 0x%0.8x\n",
            irpStack->Parameters.Read.BufferOffset,
            irpStack->Parameters.Read.ByteOffset.LowPart,
            irpStack->Parameters.Read.Length
            );
        if(TEST_FLAG(DeviceExtension->DeviceFlags, MU_WRITE_HAS_MIDDLE_PORTION))
        {
            DbgPrint("Middle Partial Write:");
            switch(DeviceExtension->DeviceFlags&MU_WRITE_STATE_BITS)
            {
                case MU_WRITE_STATE_MIDDLE_START:
                    DbgPrint("MU_WRITE_STATE_MIDDLE_START\n");
                    break;
                case MU_WRITE_STATE_MIDDLE_READ_BEFORE:
                    DbgPrint("MU_WRITE_STATE_MIDDLE_READ_BEFORE\n");
                    break;
                case MU_WRITE_STATE_MIDDLE_READ_AFTER:
                    DbgPrint("MU_WRITE_STATE_MIDDLE_READ_AFTER\n");
                    break;
                case MU_WRITE_STATE_MIDDLE_WRITE:
                    DbgPrint("MU_WRITE_STATE_MIDDLE_WRITE\n");
                    break;
                case MU_WRITE_STATE_MIDDLE_DONE:
                    DbgPrint("MU_WRITE_STATE_MIDDLE_DONE\n");
                    break;
                default:
                    break;
            }
        } else
        {
            if(TEST_FLAG(DeviceExtension->DeviceFlags, MU_WRITE_HAS_INITIAL_PORTION))
                DbgPrint("Start on a block aligned.\n");
            if(TEST_FLAG(DeviceExtension->DeviceFlags, MU_WRITE_HAS_FINAL_PORTION))
                DbgPrint("End on a block aligned.\n");
            DbgPrint("Partial Write State:");
            switch(DeviceExtension->DeviceFlags&MU_WRITE_STATE_BITS)
            {
                case MU_WRITE_STATE_START:
                    DbgPrint("MU_WRITE_STATE_START\n");
                    break;
                case MU_WRITE_STATE_INITIAL_READ:
                    DbgPrint("MU_WRITE_STATE_INITIAL_READ\n");
                    break;
                case MU_WRITE_STATE_INITIAL_WRITE:
                    DbgPrint("MU_WRITE_STATE_INITIAL_WRITE\n");
                    break;
                case MU_WRITE_STATE_FINAL_READ:
                    DbgPrint("MU_WRITE_STATE_FINAL_READ\n");
                    break;
                case MU_WRITE_STATE_FINAL_WRITE:
                    DbgPrint("MU_WRITE_STATE_FINAL_WRITE\n");
                case MU_WRITE_STATE_DONE:
                    DbgPrint("MU_WRITE_STATE_DONE\n");
                default:
                    break;
            }
        }
        break;
      case IRP_MJ_READ:
        DbgPrint("Read: Buffer = 0x%0.8x, Offset = 0x%0.8x, Length = 0x%0.8x\n",
            irpStack->Parameters.Read.BufferOffset,
            irpStack->Parameters.Read.ByteOffset.LowPart,
            irpStack->Parameters.Read.Length
            );
        break;
      default:
        DbgPrint("Unknown Request: 0x%0.8x\n", irpStack->MajorFunction);
    }
    //Now print out MRB state machine information
    DbgPrint("MU Request State machine flags:\n");
    if(TEST_FLAG(DeviceExtension->DeviceFlags, DF_MRB_TIMER_RUNNING))
      DbgPrint("   DF_MRB_TIMER_RUNNING\n");
    if(TEST_FLAG(DeviceExtension->DeviceFlags, DF_PRIMARY_URB_PENDING))
      DbgPrint("   DF_PRIMARY_URB_PENDING\n");
    if(TEST_FLAG(DeviceExtension->DeviceFlags, DF_SECONDARY_URB_PENDING))
      DbgPrint("   DF_SECONDARY_URB_PENDING\n");
    if(TEST_FLAG(DeviceExtension->DeviceFlags, DF_ERROR_PENDING))
      DbgPrint("   DF_ERROR_PENDING\n");
    if(TEST_FLAG(DeviceExtension->DeviceFlags, DF_RESET_STEP1))
      DbgPrint("   DF_RESET_STEP1\n");
    if(TEST_FLAG(DeviceExtension->DeviceFlags, DF_RESET_STEP2))
      DbgPrint("   DF_RESET_STEP2\n");
    if(TEST_FLAG(DeviceExtension->DeviceFlags, DF_RESET_STEP3))
      DbgPrint("   DF_RESET_STEP3\n");

    // Print out state machine info
    DbgPrint("Primary Urb @0x%0.8x, Secondary Urb @0x%0.8x\n", &DeviceExtension->Urb, &DeviceExtension->BulkUrbSecondary);
    //Break into debugger
    DbgBreakPoint();
}


VOID
MUDebugInitWatchDogParameters(
    PMU_DEVICE_EXTENSION DeviceExtension
    )
{
    KeInitializeTimer(&DeviceExtension->DbgIrpTimer);
    KeInitializeDpc(
        &DeviceExtension->DbgIrpTimeoutDpc, 
        (PKDEFERRED_ROUTINE)MUDebugWatchdogDpcRoutine,
        (PVOID)DeviceExtension
        );
}

VOID 
MuDebugSetWatchDogTimer(
    PMU_DEVICE_EXTENSION DeviceExtension
    )
{
    //If the timer is running cancel it, it should not have been
    //running so ASSERT that it wasn't.
    LARGE_INTEGER timeoutTime;
    
    BOOL fWasSet = KeCancelTimer(&DeviceExtension->DbgIrpTimer);
    ASSERT(!fWasSet);
    
    
    //
    //  GEt the stack location
    //
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(DeviceExtension->PendingIrp);

    //
    //  Based on the IRP, guess how long this should take, in ms
    //  (we will multiple accordingly after the switch statements)
    //
    switch (irpStack->MajorFunction)
    {
      case IRP_MJ_DEVICE_CONTROL:
        switch(irpStack->Parameters.DeviceIoControl.IoControlCode)
        {
            case IOCTL_DISK_GET_DRIVE_GEOMETRY:
            case IOCTL_DISK_GET_PARTITION_INFO:
                timeoutTime.QuadPart = 2000;  // 2 second
                break;
            case IOCTL_DISK_VERIFY:
                timeoutTime.QuadPart = irpStack->Parameters.Read.Length; //assume 25k verified per second
                timeoutTime.QuadPart /= 25;
                timeoutTime.QuadPart += 4000; //add 4 seconds for overhead
                break;
            #ifdef MU_DIAGNOSTIC_IOCTLS
            case MU_IOCTL_GET_BAD_BLOCK_TABLE:
                timeoutTime.QuadPart = 4000; // 4 seconds
                break;
            case MU_IOCTL_MEMORY_TEST:
                timeoutTime.QuadPart = 60000; //1 minute
                break;
            #endif
            default:
                timeoutTime.QuadPart = 10000; //10 seconds for anything else (there are none at this time)
        }
        break;
      case IRP_MJ_WRITE:
        timeoutTime.QuadPart = irpStack->Parameters.Read.Length; //assume 25k written per second
        timeoutTime.QuadPart /= 25;
        timeoutTime.QuadPart += 4000; //add 4 seconds for overhead
        break;
      case IRP_MJ_READ:
        timeoutTime.QuadPart = irpStack->Parameters.Read.Length; //assume 50k read per second
        timeoutTime.QuadPart /= 50;
        timeoutTime.QuadPart += 4000; //add 4 seconds for overhead
        break;
      default:
        timeoutTime.QuadPart = 10000; // 10 seconds in all other cases, actually there shouldn't be any.
    }
    
    //Convert from milliseconds to relative .1 microsecond units.
    timeoutTime.QuadPart *= -10000;
    DeviceExtension->DbgIrpTimeoutTime.QuadPart = timeoutTime.QuadPart;
    //Set the timer running
    KeSetTimer(&DeviceExtension->DbgIrpTimer, timeoutTime, &DeviceExtension->DbgIrpTimeoutDpc);
}

VOID 
MuDebugPetWatchDogTimer(
    PMU_DEVICE_EXTENSION DeviceExtension
    )
{
    KeSetTimer(&DeviceExtension->DbgIrpTimer, DeviceExtension->DbgIrpTimeoutTime, &DeviceExtension->DbgIrpTimeoutDpc);
}
 

VOID 
MuDebugCompleteRequest(
    PMU_DEVICE_EXTENSION DeviceExtension,
    PIRP Irp,
    CCHAR PriorityBoost
    )
{
    
    BOOL fWasSet = KeCancelTimer(&DeviceExtension->DbgIrpTimer);
    ASSERT(fWasSet);
    IoCompleteRequest(Irp, PriorityBoost);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\dd\usb\mu\mu.cpp ===
/*++

Copyright (c) 1996-2000 Microsoft Corporation

Module Name:

    MU.CPP

Abstract:

    This source file implements the major entry points to the MU driver.

        Entries required by the USB core stack:
            MU_Init
            MU_AddDevice
            MU_RemoveDevice
        Entries used by XAPI for making MU's accessible.



Environment:

    Xbox USB class driver.

Revision History:

    George Chrysanthakopoulos (georgioc) wrote the original several months ago, loosely based
    on the existing Win2k USB mass storage driver.

    10-18-00 : Mitchell Dernis(mitchd) - systematic code and comment cleanup, now that all
               the major architectural issues are resolved.
    11-08-00 : Mitchell Dernis(mitchd) - change when DeviceObject are allocated

--*/

//*****************************************************************************
// I N C L U D E S
//*****************************************************************************
#include "mu.h"
#include <stdio.h>

//*****************************************************************************
// Global Declarations
//*****************************************************************************
MU_DRIVER_EXTENSION MU_DriverExtension;

DRIVER_OBJECT MU_DriverObject = {
    MU_StartIo,                         // DriverStartIo
    NULL,                               // DriverDeleteDevice
    NULL,                               // DriverDismountVolume
    {
        IoInvalidDeviceRequest,         // IRP_MJ_CREATE
        IoInvalidDeviceRequest,         // IRP_MJ_CLOSE
        MU_InternalIo,                  // IRP_MJ_READ
        MU_InternalIo,                  // IRP_MJ_WRITE
        IoInvalidDeviceRequest,         // IRP_MJ_QUERY_INFORMATION
        IoInvalidDeviceRequest,         // IRP_MJ_SET_INFORMATION
        IoInvalidDeviceRequest,         // IRP_MJ_FLUSH_BUFFERS
        IoInvalidDeviceRequest,         // IRP_MJ_QUERY_VOLUME_INFORMATION
        IoInvalidDeviceRequest,         // IRP_MJ_DIRECTORY_CONTROL
        IoInvalidDeviceRequest,         // IRP_MJ_FILE_SYSTEM_CONTROL
        MU_InternalIo,                  // IRP_MJ_DEVICE_CONTROL
        MU_InternalIo,                  // IRP_MJ_INTERNAL_DEVICE_CONTROL
        IoInvalidDeviceRequest,         // IRP_MJ_SHUTDOWN
        IoInvalidDeviceRequest,         // IRP_MJ_CLEANUP
    }
};

//This is exposed for XAPI so that XMountMU can check if the user tries to exceed it.
#if DBG
extern "C" ULONG MU_MaxUserDevices = MU_DEFAULT_MAX_MOUNTED;
#endif 

//*****************************************************************************
// Local Function Declarations
//*****************************************************************************
DEFINE_USB_DEBUG_FUNCTIONS("MU");

VOID
FASTCALL
MU_fCloseEndpoints (
    IN PMU_DEVICE_EXTENSION   DeviceExtension
    );

VOID
MU_CloseEndpointCompletion (
    IN PURB Urb,
    IN PVOID Context
    );


//*****************************************************************************
//  Declare XID types and class.
//*****************************************************************************
DECLARE_XPP_TYPE(XDEVICE_TYPE_MEMORY_UNIT)
USB_DEVICE_TYPE_TABLE_BEGIN(MU_)
USB_DEVICE_TYPE_TABLE_ENTRY(XDEVICE_TYPE_MEMORY_UNIT)
USB_DEVICE_TYPE_TABLE_END()
USB_CLASS_DRIVER_DECLARATION(MU_, USB_DEVICE_CLASS_STORAGE, 0xFF, 0xFF)
#pragma data_seg(".XPP$ClassMU")
USB_CLASS_DECLARATION_POINTER(MU_)
#pragma data_seg(".XPP$Data")

USB_RESOURCE_REQUIREMENTS MU_gResourceRequirements = 
    {USB_CONNECTOR_TYPE_LOW_POWER, 0, 0, 1, 2, 0, 0, MU_BULK_MIN_TD_QUOTA, 0, 0};

//*****************************************************************************
// Implementation of USB Required Entry Points:
//  MU_Init,
//  MU_AddDevice,
//  MU_RemoveDevice
//*****************************************************************************
#pragma code_seg(".XPPCINIT")
EXTERNUSB VOID MU_Init (IUsbInit *pUsbInit)
/*++
    Routine Description:

        Called by the USB core stack if the MU driver's description table is
        linked in to the application.
--*/
{
    ULONG portCount;
    ULONG maxDeviceCount;
    ULONG maxOpenCount;
    ULONG allocSize;
    ULONG index;
    OBJECT_STRING deviceObjectName;
    PMU_DEVICE_EXTENSION deviceExtension;
    PDEVICE_OBJECT deviceObject;

    USB_DBG_ENTRY_PRINT(("entering MU_Init\n"));

    //
    //  The "MU_DriverExtension" is just a global.  Initialize it.
    //

    RtlZeroMemory(&MU_DriverExtension,sizeof(MU_DRIVER_EXTENSION));
    InitializeListHead(&MU_DriverExtension.PartialRequestQueue);

    //
    //  Calculate maxDeviceCount and allocate the array of devices.
    //

    portCount = XGetPortCount();
    maxDeviceCount =  portCount * MU_CONTROLLERS_PER_PORT;

    //
    // Allocate an array of pointers to hold the nodes (MU_INSTANCES)
    //

    allocSize = sizeof(MU_INSTANCE)*maxDeviceCount;
    MU_DriverExtension.Nodes = (PMU_INSTANCE) RTL_ALLOCATE_HEAP(allocSize);
    ASSERT(MU_DriverExtension.Nodes);  //This allocation happens at boot, it better not fail.
    RtlZeroMemory(MU_DriverExtension.Nodes, allocSize);
    
    //
    //  Register the user selected devices
    //
    if(pUsbInit->UseDefaultCount())
    {
        maxOpenCount = MU_DEFAULT_MAX_MOUNTED;
    } else
    {
        maxOpenCount = pUsbInit->GetMaxDeviceTypeCount(XDEVICE_TYPE_MEMORY_UNIT);
        RIP_ON_NOT_TRUE_WITH_MESSAGE(maxOpenCount <= maxDeviceCount, "XInitDevices: requested more XDEVICE_TYPE_MEMORY_UNIT than available ports.");
        
        // Save the number of devices that the user requested so we can RIP in debug versions of XMountMU if the user tries to exceed this.
        #if DBG
        MU_MaxUserDevices = maxOpenCount;
        #endif 
        
        // Bump up the maximum opened count. This is because API's such as XGetMUNameFromPortAndSlot,
        // and XReadMUMetaData may need to mount an MU behind the game's back, the game has not already mounted it.
        // These API's are smart enough never to mount more than one at a time beyond what the game has mounted.
        maxOpenCount++; 
        // The maximum count never needs to exceed the maximum physical devices.
        if(maxOpenCount > maxDeviceCount) maxOpenCount = maxDeviceCount;
    }

    //
    //  Allocate all the device objects and place them on a free list
    //
    RtlInitObjectString(&deviceObjectName, OTEXT("\\Device\\MU_0"));
    for(index = 0; index < maxOpenCount; index++)
    {
        NTSTATUS status;
        deviceObjectName.Buffer[sizeof("\\Device\\MU")] = (index > 9) ? (index + OTEXT('A')) : (index + OTEXT('0'));
        status = IoCreateDevice(
                    &MU_DriverObject,
                    sizeof(MU_DEVICE_EXTENSION),
                    &deviceObjectName,
                    FILE_DEVICE_MEMORY_UNIT,
                    FALSE,
                    &deviceObject
                    );
        if(NT_SUCCESS(status))
        {
            
            deviceExtension = (PMU_DEVICE_EXTENSION)deviceObject->DeviceExtension;
            RtlZeroMemory(deviceExtension, sizeof(MU_DEVICE_EXTENSION));    
            deviceExtension->DeviceObject = deviceObject;
            deviceExtension->DeviceObjectNumber = index;
            deviceExtension->DeviceFlags = DF_REMOVED;
            deviceObject->StackSize = 1;
            deviceObject->Flags |=  DO_DIRECT_IO;
            deviceObject->Flags &= ~DO_DEVICE_INITIALIZING;
            MU_ReleaseDeviceObject(deviceExtension);
        } else break;
    }

#if DBG 
    if(index < maxOpenCount)
    {
        RIP("XInitDevices: Memory Unit failed to allocate memory all requested instances.");
    }
#endif 

    //
    //  Register the resources for the support device count
    //
    MU_gResourceRequirements.MaxDevices = maxOpenCount;
    if(maxOpenCount > 1) MU_gResourceRequirements.MaxBulkTDperTransfer *= 2;
    pUsbInit->RegisterResources(&MU_gResourceRequirements);

    //
    //  Xbox has no concept of drivers failing load
    //  so there is no point in returning an error code
    //  other than STATUS_SUCCESS
    //
    
    USB_DBG_EXIT_PRINT(("exiting MU_Init\n"));

    return;
}
#pragma code_seg(".XPPCODE")

EXTERNUSB VOID MU_AddDevice(IN IUsbDevice *Device)
/*++
    Routine Description:
        Standard USB class driver AddDevice routine.

        Verifies that MU is supported.

        Claims a preallocated MU_INSTANCE, and caches
        enumtime information needed later.
        
        Connects the IUsbDevice to the MU_INSTANCE.

    Arguments:
        Device - Interface to USB core stack for device.

    Notes:
        AddDevice routines are always called at DPC level.
--*/
{
    PMU_INSTANCE      muInstance;
    ULONG             port;
    ULONG             slot;
	const USB_ENDPOINT_DESCRIPTOR *endpointDescriptor;

    USB_DBG_ENTRY_PRINT(("MU_AddDevice(Device=0x%0.8x)", Device));

    //
    //  Get the device port and slot
    //

    port = Device->GetPort();
    if(port >= 16)
    {
        port -= 16;
        slot = 1;
    } else
    {
        slot = 0;
    }
    USB_DBG_TRACE_PRINT(("Memory Unit Added: Port = %d, Slot = %d", port, slot));

    //
    //  Choose the correct MU instance object
    //

    muInstance = &MU_DriverExtension.Nodes[NODE_INDEX_FROM_PORT_AND_SLOT(port,slot)];
    ASSERT(1==++muInstance->AddRemoveCount);
    //
    //	get the endpoint descriptor for bulk-IN
    //

    endpointDescriptor = Device->GetEndpointDescriptor(USB_ENDPOINT_TYPE_BULK, TRUE, 0);
    if(endpointDescriptor)
    {

        muInstance->BulkInEndpointAddress = endpointDescriptor->bEndpointAddress;
        
        //
        //  Verify wMaxPacketSize, for Xbox performance reasons, we require
        //  MU_MAX_BULK_PACKET_SIZE (64 bytes).  Furthermore, assumptions are
        //  made regarding max packet size based on 64 bytes.  So this really
        //  is a requirement.
        //

        if (endpointDescriptor->wMaxPacketSize != MU_MAX_BULK_PACKET_SIZE)
        {
            USB_DBG_WARN_PRINT(("unsupported device: wMaxPacketSize is incorrect for the bulk-IN endpoint."));
            Device->AddComplete(USBD_STATUS_UNSUPPORTED_DEVICE);
            return;
        }

    } else
    {
        USB_DBG_WARN_PRINT(("unsupported device: endpoint descriptor not found for bulk-IN."));
        Device->AddComplete(USBD_STATUS_UNSUPPORTED_DEVICE);
        return;
    }

    //
    //	get the endpoint descriptor for bulk-OUT
    //
    
    endpointDescriptor = Device->GetEndpointDescriptor(USB_ENDPOINT_TYPE_BULK, FALSE, 0);
    if (endpointDescriptor)
    {
        muInstance->BulkOutEndpointAddress =  endpointDescriptor->bEndpointAddress;

        //
        //  Verify wMaxPacketSize, see comments a few lines above regarding wMaxPacketSize
        //  for the bulk-IN endpoint.
        //

        if (endpointDescriptor->wMaxPacketSize != MU_MAX_BULK_PACKET_SIZE)
        {
            USB_DBG_WARN_PRINT(("unsupported device: wMaxPacketSize is incorrect for the bulk-OUT endpoint."));
            Device->AddComplete(USBD_STATUS_UNSUPPORTED_DEVICE);
            return;
        }

    } else {
        USB_DBG_WARN_PRINT(("unsupported device: endpoint descriptor not found for bulk-OUT."));
        Device->AddComplete(USBD_STATUS_UNSUPPORTED_DEVICE);
        return;
    }

    //
    // Set our muInstance in our IUsbDevice
    //

    Device->SetExtension(muInstance);

    //
    // save our IUsbDevice pointer
    //

    muInstance->Device = Device;
    muInstance->InterfaceNumber = Device->GetInterfaceNumber();

    //
    // set the class specific type so that it gets enumerated to applications.
    //

    Device->SetClassSpecificType(0);
    Device->AddComplete(USBD_STATUS_SUCCESS);
}

EXTERNUSB VOID
MU_RemoveDevice (
    IN IUsbDevice *Device
    )
/*++
    Routine Description:
        Standard USB class driver RemoveDevice routine.
        
        There are two possibilities: the device is in use (has a 
        DeviceObject attached and the endpoints are opened), or
        the device is not in use.  In the former case, we mark
        the device as DF_PENDING_REMOVE, and kick off the state
        machine to close the endpoints.  The last step of that state
        machine will see DF_PENDING_REMOVE and call Device->RemoveComplete()
        for us.  In the latter case, we can just call Device->RemoveComplete().

    Arguments:
        Device - Interface to USB core stack for device that is to be
                 removed.
    Notes:
        RemoveDevice routines are always called at DPC level.
--*/
{
    USB_DBG_ENTRY_PRINT(("MU_RemoveDevice(Device=0x%0.8x)", Device));

    PMU_INSTANCE           muInstance = (PMU_INSTANCE) Device->GetExtension();
    PMU_DEVICE_EXTENSION   deviceExtension = muInstance->DeviceExtension;
    ASSERT(0==--muInstance->AddRemoveCount);

    //
    //  If the MU_INSTANCE is currently attached to a device object
    //  for the current muInstance, then the endpoints are open and need to
    //  be closed before we can complete the remove.  However, it is possible
    //  that the deviceExtension is for a previous incarnation of this
    //  muInstance (a.k.a. the MU was removed, added, and now is being removed 
    //  again, without the device object ever having been closed).  In this
    //  bizarre circumstance, we can just complete the remove.
    //
    if(deviceExtension && !TEST_FLAG(deviceExtension->DeviceFlags, DF_REMOVED))
    {
        //
        //  Mark the device remove pending and let the close
        //  endpoint state machine take care of the rest.
        //
        SET_FLAG(deviceExtension->DeviceFlags, DF_PENDING_REMOVE);
        MU_fCloseEndpoints(deviceExtension);
    } else
    //
    //  Otherwise, the device is not in use, we can just complete the
    //  remove right here.
    //
    {
        muInstance->Device->RemoveComplete();
        muInstance->Device = NULL;
    }
    
    USB_DBG_EXIT_PRINT(("exiting MU_RemoveDevice"));

}

//*****************************************************************************
// Implementation of XAPI Entry Points:
//  MU_CreateDeviceObject,
//  MU_CloseDeviceObject
//*****************************************************************************

NTSTATUS
MU_CreateDeviceObject(
    IN  ULONG            Port,
    IN  ULONG            Slot,
    IN  POBJECT_STRING   DeviceName
    )
/*++
    Routine Description:

        This routine is called to expose an MU as a device object.  It is called by XMountMU,
        and it also must be called to open a device with the RAW filesystem, which is used for
        formatting and some low-level tests.

        All endpoint handles are opened at them same time.

    Arguments:

        Port         - port of MU to open
        Slot         - slot of MU to open
        DeviceName   - name to give device object

    Notes:
        
        MU_CloseDeviceObject reverses MU_CreateDeviceObject
        freeing all memory.

        MU_CreateDeviceObject should only be called once on a particular port and slot.
--*/
{
    PMU_INSTANCE         muInstance;
    PMU_DEVICE_EXTENSION deviceExtension;
    NTSTATUS             status = STATUS_SUCCESS;
    USBD_STATUS          usbdStatus;
    KIRQL                oldIrql;

    USB_DBG_ENTRY_PRINT(("MU_CreateDeviceObject(Port=0x%0.8x, Slot=0x%0.8x)", Port, Slot));

    //
    //  ASSERT arguments.
    //

    ASSERT(Port < XGetPortCount());
    ASSERT((Slot == XDEVICE_TOP_SLOT) || (Slot == XDEVICE_BOTTOM_SLOT));

    //
    //  Choose the correct MU instance object
    //

    muInstance = &MU_DriverExtension.Nodes[NODE_INDEX_FROM_PORT_AND_SLOT(Port,Slot)];

    oldIrql = KeRaiseIrqlToDpcLevel();

    deviceExtension = MU_AcquireDeviceObject();

    if(NULL == deviceExtension)
    {
        KeLowerIrql(oldIrql);
        RIP("XMountMu() - exceeded number of devices requested with XInitDevices");
        return STATUS_NO_MEMORY;
    }

    //
    //  Verify that the device is connected.
    //
    if(!muInstance->Device)
    {
        MU_ReleaseDeviceObject(deviceExtension);
        KeLowerIrql(oldIrql);
        return STATUS_DEVICE_NOT_CONNECTED;
    }

    //
    //  Point the MU_INSTANCE to the device extension
    //  and vice versa.  Now the failure processing
    //  can survive the normal close processing, even
    //  if the reset of open fails.
    //
    ASSERT(NULL == muInstance->DeviceExtension);
    muInstance->DeviceExtension = deviceExtension;
    deviceExtension->MuInstance = muInstance;

    //
    //  Initialize the DPC object and mrb timeouts
    //

    KeInitializeDpc(&deviceExtension->Mrb.TimeoutDpcObject, MU_MrbTimeout, deviceExtension);
    KeInitializeTimer(&deviceExtension->Mrb.Timer);

    //
    //  Initialize the debug watchdog parameters
    //
    MU_DEBUG_INIT_WATCHDOG_PARAMETERS(deviceExtension);

    //
    //  Initialize the close event.
    //

    KeInitializeEvent(&deviceExtension->CloseEvent, NotificationEvent, FALSE);

    //
    // Open the default endpoint
    //
    
    USB_BUILD_OPEN_DEFAULT_ENDPOINT(&deviceExtension->Urb.OpenEndpoint);
    usbdStatus = muInstance->Device->SubmitRequest(&deviceExtension->Urb);
    if(USBD_SUCCESS(usbdStatus))
    {
        SET_FLAG(deviceExtension->DeviceFlags,DF_DEFAULT_ENDPOINT_OPEN);
    } else
    {
        status = IUsbDevice::NtStatusFromUsbdStatus(usbdStatus);
        USB_DBG_WARN_PRINT(("Failed to open the default endpoint for an MU: usbdStatus = 0x%0.8x", usbdStatus));
        goto SkipRemainingEndpointOpens;
    }

    //
    // Open the Bulk-IN endpoint
    //
    USB_BUILD_OPEN_ENDPOINT(
        &deviceExtension->Urb.OpenEndpoint,
        muInstance->BulkInEndpointAddress,
        USB_ENDPOINT_TYPE_BULK,
        MU_MAX_BULK_PACKET_SIZE,
        0 //interval unimportant for bulk endpoint 
        );
    usbdStatus = muInstance->Device->SubmitRequest(&deviceExtension->Urb);
    if(USBD_SUCCESS(usbdStatus))
    {
        SET_FLAG(deviceExtension->DeviceFlags,DF_BULK_IN_ENDPOINT_OPEN);
        deviceExtension->BulkInEndpointHandle = deviceExtension->Urb.OpenEndpoint.EndpointHandle;
    } else 
    {
        status = IUsbDevice::NtStatusFromUsbdStatus(usbdStatus);
        USB_DBG_WARN_PRINT(("Failed to open the bulk-IN endpoint for an MU: usbdStatus = 0x%0.8x", usbdStatus));
        goto SkipRemainingEndpointOpens;
    }

    //
    // Open the Bulk-OUT endpoint (if needed)
    //

    USB_BUILD_OPEN_ENDPOINT(
       &deviceExtension->Urb.OpenEndpoint,
       muInstance->BulkOutEndpointAddress,
       USB_ENDPOINT_TYPE_BULK,
       MU_MAX_BULK_PACKET_SIZE,
       0
       );
    usbdStatus = muInstance->Device->SubmitRequest(&deviceExtension->Urb);
    if(USBD_SUCCESS(usbdStatus))
    {
        SET_FLAG(deviceExtension->DeviceFlags,DF_BULK_OUT_ENDPOINT_OPEN);
        deviceExtension->BulkOutEndpointHandle =  deviceExtension->Urb.OpenEndpoint.EndpointHandle;
    } else
    {
        status = IUsbDevice::NtStatusFromUsbdStatus(usbdStatus);
        USB_DBG_WARN_PRINT(("Failed to open the bulk-OUT endpoint for an MU: usbdStatus = 0x%0.8x", usbdStatus));
    }

SkipRemainingEndpointOpens:

    KeLowerIrql(oldIrql);

    //
    //  If an error occured, the device may be "half" opened.
    //  MU_CloseDeviceObject is smart enough to close a partially
    //  opened device, so we will just call it.
    //
    if(NT_ERROR(status))
    {
        MU_CloseDeviceObject(Port, Slot);
    }  else
    {
        //generate the device object name in the caller's buffer
        DeviceName->Length = (sizeof(OTEXT("\\Device\\MU_0"))/sizeof(OCHAR))-1;
        ASSERT(DeviceName->MaximumLength-1 >= DeviceName->Length);
        ASSERT(deviceExtension->DeviceObjectNumber < 16);
        soprintf(DeviceName->Buffer, OTEXT("\\Device\\MU_%x"), deviceExtension->DeviceObjectNumber);
    }

    USB_DBG_EXIT_PRINT(("MU_CreateDeviceObject returning 0x%0.8x" status));
    return status;
}

VOID
MU_CloseDeviceObject(
    IN  ULONG  Port,
    IN  ULONG  Slot
    )
/*++
    Routine Description:
        Reverse MU_CreateDeviceObject.

    Argument:
        DeviceObject - MU DeviceObject to close.
--*/
{
    PMU_DEVICE_EXTENSION deviceExtension;
    PMU_INSTANCE         muInstance;
    KIRQL                oldIrql;

    USB_DBG_ENTRY_PRINT(("MU_CloseDeviceObject(Port=%d,Slot=%d)", Port, Slot));

    ASSERT_LESS_THAN_DISPATCH_LEVEL();

    //
    //  ASSERT arguments.
    //

    ASSERT(Port < XGetPortCount());
    ASSERT((Slot == XDEVICE_TOP_SLOT) || (Slot == XDEVICE_BOTTOM_SLOT));

    //
    //  Choose the correct MU instance object
    //

    muInstance = &MU_DriverExtension.Nodes[NODE_INDEX_FROM_PORT_AND_SLOT(Port,Slot)];

    //
    //  Raise Irql to synchronize
    //

    oldIrql = KeRaiseIrqlToDpcLevel();

    //
    //  Get the deviceExtension from the muInstance.
    //

    deviceExtension = muInstance->DeviceExtension;

    //
    //  Hitting assert probably indicates that MU_CloseDeviceObject was called
    //  for an MU that was already closed.  Since this is not a
    //  public API, we just ASSERT.  Fix the calling code!
    //

    ASSERT(deviceExtension);

    //
    //  If the device extension points back to an active MU_INSTANCE behind this device object,
    //  close the endpoints on it first.
    //

    if(deviceExtension->MuInstance)
    {
        //
        //  Mark the device as pending close
        //
        SET_FLAG(deviceExtension->DeviceFlags, DF_PENDING_CLOSE);

        //
        //  Let the close endpoint state machine finish up the work of closing.
        //
        MU_fCloseEndpoints(deviceExtension);

        //
        //  Lower irql for synchronization purposes.
        //
        KeLowerIrql(oldIrql);

        //
        //  Wait for the close endpoint state machine to finish
        //
        KeWaitForSingleObject(&deviceExtension->CloseEvent, Executive, KernelMode, FALSE, NULL);
        
    } else
    {
        muInstance->DeviceExtension = NULL;
        KeLowerIrql(oldIrql);
    }
    //
    //  The MU instance can now forget about the device object.
    //
    MU_ReleaseDeviceObject(deviceExtension);

    USB_DBG_EXIT_PRINT(("MU_CloseDeviceObject returning."));
    return;
};

PDEVICE_OBJECT
MU_GetExistingDeviceObject(
    IN  ULONG  Port,
    IN  ULONG  Slot
    )
{
    PMU_INSTANCE         muInstance;

    USB_DBG_ENTRY_PRINT(("MU_GetExistingDeviceObject(Port=%d,Slot=%d)", Port, Slot));

    //
    //  ASSERT arguments.
    //

    ASSERT(Port < XGetPortCount());
    ASSERT((Slot == XDEVICE_TOP_SLOT) || (Slot == XDEVICE_BOTTOM_SLOT));

    //
    //  Choose the correct MU instance object
    //

    muInstance = &MU_DriverExtension.Nodes[NODE_INDEX_FROM_PORT_AND_SLOT(Port,Slot)];

    //
    //  This routine should only be invoked for a MU object that has been
    //  created.  The caller is responsible for synchronizing calls to create
    //  and close MUs with this routine.
    //

    ASSERT(muInstance->DeviceExtension);

    return muInstance->DeviceExtension->DeviceObject;
}

//*****************************************************************************
//  Implementation of local functions:
//      MU_fCloseEndpoints
//      MU_CloseEndpointCompletion
//*****************************************************************************
VOID
FASTCALL
MU_fCloseEndpoints (
    IN PMU_DEVICE_EXTENSION   DeviceExtension
    )
/*++
    Routine Description:
        Enters the close endpoint state machine.

        It is protected against reentrancy, by checking
        a flag.

        If an MU_fOpenEndpoints is in progress, it signals
        that MU_fOpenEndpoints should call it when it
        syncs up its new status.
--*/
{
    ASSERT_DISPATCH_LEVEL();

    //
    // If a close is not already in progress, start one
    //

    if(!TEST_FLAG(DeviceExtension->DeviceFlags, DF_CLOSING_ENDPOINTS))
    {
       SET_FLAG(DeviceExtension->DeviceFlags,DF_CLOSING_ENDPOINTS);
       MU_CloseEndpointCompletion(NULL, DeviceExtension);
    }

    return;
}

VOID
MU_CloseEndpointCompletion (
    PURB Urb,
    PVOID Context
    )
/*++
    Routine Description:

        This is the heart of the close endpoint state machine.
        Each time it is called, it looks for an endpoint that
        needs to be closed, and builds an URB to close it and
        return back to this routine when it is closed.  At the
        end of the routine, whichever URB was built is submitted.
        
        When all the endpoints are closed, it will get to the
        last else clause.  It will complete a remove if one
        was pending, and exit the close endpoint state machine,
        before the URB is submitted (since it build one).
    
--*/
{
    PMU_DEVICE_EXTENSION deviceExtension = (PMU_DEVICE_EXTENSION) Context;
    PMU_INSTANCE muInstance = deviceExtension->MuInstance;
    
    ASSERT_DISPATCH_LEVEL();

    if(TEST_FLAG(deviceExtension->DeviceFlags, DF_BULK_OUT_ENDPOINT_OPEN))
    //
    //  The Bulk-OUT endpoint needs to be closed.
    //
    {
        //
        //  Build the URB.
        //

        USB_BUILD_CLOSE_ENDPOINT(
          &deviceExtension->CloseEndpointUrb,
          deviceExtension->BulkOutEndpointHandle,
          MU_CloseEndpointCompletion,
          deviceExtension
          );

        //
        //  Mark the endpoint closed
        //

        deviceExtension->BulkOutEndpointHandle = 0;
        CLEAR_FLAG(deviceExtension->DeviceFlags,DF_BULK_OUT_ENDPOINT_OPEN);

    } else if(TEST_FLAG(deviceExtension->DeviceFlags, DF_BULK_IN_ENDPOINT_OPEN))
    //
    //  The Bulk-IN endpoint needs to be closed.
    //
    {
        //
        //  Build the URB.
        //

        USB_BUILD_CLOSE_ENDPOINT(
          &deviceExtension->CloseEndpointUrb,
          deviceExtension->BulkInEndpointHandle,
          MU_CloseEndpointCompletion,
          deviceExtension
          );

        //
        //  Mark the endpoint closed
        //

        deviceExtension->BulkInEndpointHandle = 0;
        CLEAR_FLAG(deviceExtension->DeviceFlags,DF_BULK_IN_ENDPOINT_OPEN);

    } else if(TEST_FLAG(deviceExtension->DeviceFlags, DF_DEFAULT_ENDPOINT_OPEN))
    //
    //  The default endpoint needs to be closed.
    //
    {
        //
        //  Build the URB.
        //

        USB_BUILD_CLOSE_DEFAULT_ENDPOINT(
          &deviceExtension->CloseEndpointUrb,
          MU_CloseEndpointCompletion,
          deviceExtension
          );

        //
        //  Mark the endpoint closed
        //

        CLEAR_FLAG(deviceExtension->DeviceFlags, DF_DEFAULT_ENDPOINT_OPEN);

    } else
    //
    // Our state machine is done closing endpoints
    //
    {

        //
        //  We are no longer closing endpoints.
        //
        CLEAR_FLAG(deviceExtension->DeviceFlags, DF_CLOSING_ENDPOINTS);

        //
        //  This state machine has been invoked because
        //  a remove and\or close is pending.  In either
        //  case, the device object needs to forget about
        //  the MU_INSTANCE, but NOT vice versa.  The MuInstance
        //  only forgets about the device object on close.
        //
        deviceExtension->MuInstance = NULL;

        //
        //  If a close is pending, signal the close event
        //  so the close caller that started the state machine
        //  can finish up its processing.
        //
        if(TEST_FLAG(deviceExtension->DeviceFlags, DF_PENDING_CLOSE))
        {
            //
            //  We can forget about the device object now
            //  as it will be deleted by MU_CloseDeviceObject
            //  when we signal the close event.
            //
            muInstance->DeviceExtension = NULL;
            KeSetEvent(&deviceExtension->CloseEvent, IO_NO_INCREMENT, FALSE);
            CLEAR_FLAG(deviceExtension->DeviceFlags, DF_PENDING_CLOSE);
        }

        //
        //  If a remove is pending, then process it.
        //

        if(TEST_FLAG(deviceExtension->DeviceFlags, DF_PENDING_REMOVE))
        {
            //
            //  if remove was pending, call remove complete
            //

            muInstance->Device->RemoveComplete();
            muInstance->Device = NULL;

            //
            //  it is now removed, not remove pending.
            //

            CLEAR_FLAG(deviceExtension->DeviceFlags, DF_PENDING_REMOVE);
            SET_FLAG(deviceExtension->DeviceFlags, DF_REMOVED);
        }
        
        //
        //  We are done, so return before submitting the URB
        //

        return;
    }

    //
    //  If we are here, we have built an URB, submit it.
    //

    muInstance->Device->SubmitRequest((PURB)&deviceExtension->CloseEndpointUrb);
    
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\dd\usb\mu\rbc.h ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    rbc.h

Abstract:

    This was scsi.h from the Windows 2000 tree.  Our Xbox MU protocol is an extreme subset of the
    SCSI commands.  Additionally, we are packing a little extra information into the READ_CAPACITY
    command than is specified in the RBC specification.  Not really an issue, since do not need to
    be SCSI compatible anyway.

    So this file is paired don't to have only relevant definitions

Authors:

Revision History:

--*/
#ifndef __RBC_H__
#define __RBC_H__

//
// Command Descriptor Block. Passed by SCSI controller chip over the SCSI bus
//

#include <pshpack1.h>
typedef union _CDB {
    
    //
    // Standard 10-byte CDB
    //

    struct _CDB10 {
        UCHAR OperationCode;
        UCHAR RelativeAddress : 1;
        UCHAR Reserved1 : 2;
        UCHAR ForceUnitAccess : 1;
        UCHAR DisablePageOut : 1;
        UCHAR LogicalUnitNumber : 3;
        union {
            struct {
                UCHAR LogicalBlockByte0;
                UCHAR LogicalBlockByte1;
                UCHAR LogicalBlockByte2;
                UCHAR LogicalBlockByte3;
            };
            ULONG LogicalBlock;
        };
        UCHAR Reserved2;
        union {
            struct {
                UCHAR TransferBlocksMsb;
                UCHAR TransferBlocksLsb;
            };
            USHORT TransferBlocks;
        };
        UCHAR Control;
    } CDB10, *PCDB10;

    //
    // Access as array of ULONGS or BYTES
    //

    ULONG AsUlong[4];
    UCHAR AsByte[16];

} CDB, *PCDB;
#include <poppack.h>

//
// SCSI CDB operation codes
//

#define SCSIOP_READ_CAPACITY       0x25
#define SCSIOP_READ                0x28
#define SCSIOP_WRITE               0x2A
#define SCSIOP_VERIFY              0x2F

//
// Read Capacity Data - returned in Big Endian format
//
// (CAVEAT! - this is not the structure defined by SCSI!!!)
// We added the LogicalBlocKPerMediaBlock by carving away
// 16 bits 

typedef struct _READ_CAPACITY_DATA {
    ULONG  LogicalBlockAddress;
    USHORT LogicalBlocksPerMediaBlock; 
    USHORT BytesPerLogicalBlock;
} READ_CAPACITY_DATA, *PREAD_CAPACITY_DATA;

#endif // !defined __RBC_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\dd\usb\mu\mu.h ===
/*++

Copyright (c) 1996-2000 Microsoft Corporation

Module Name:

    MU.H

Abstract:

    Header file for MU driver

Environment:

    kernel mode

Revision History:

    06-13-2000 : started rewrite : georgioc
    10-11-2000 : cleanup : mitchd

--*/

//*****************************************************************************
// Includes
//*****************************************************************************
extern "C" {
#include <ntos.h>
}
#include <ntrtl.h>
#include <nturtl.h>
#include <rbc.h>
#include <ntdddisk.h>
#include <xtl.h>
#include <xdbg.h>
#include <usb.h>
#define  MODULE_POOL_TAG '__UM'
#include <debug.h>

//*****************************************************************************
// Forward declaration
//*****************************************************************************


//*****************************************************************************
// Useful Macros
//*****************************************************************************

#define max(a,b) (((a) > (b)) ? (a) : (b))
#define min(a,b) (((a) < (b)) ? (a) : (b))

#define SET_FLAG(Flags, Bit)    ((Flags) |= (Bit))
#define CLEAR_FLAG(Flags, Bit)  ((Flags) &= ~(Bit))
#define TEST_FLAG(Flags, Bit)   ((Flags) & (Bit))
#define TEST_ALL_FLAGS(Flags, Bits) ((Bits) == ((Flags) & (Bits)))

#if DBG || DEBUG_LOG

    extern ULONG               MU_DebugFlags;     // DBGF_* Flags
    extern ULONG               MU_DebugLevel;     // Level of debug output

#endif


// A better WhichBit written as an inline template function.
// It returns the lowest order bit set.  If only one bit is set
// 
template <class T>
inline UCHAR WhichBit(T data)
{
    UCHAR bit;
    T mask;
    for(
        bit=0, mask=1;
        bit < sizeof(T)*8;
        bit++, mask <<= 1)
    {
        if(mask&data) break;
    }
    ASSERT(bit != sizeof(T)*8);
    return bit;
}

template <class T>
inline BOOL IsPowerOf2(T data)
/*
    Routine Description:
        Returns TRUE if data is a power of 2.  Implemented
        as inline template to work on any data type, with
        the type safety of a real function, but the efficiency
        of a MACRO.

        bitwise ANDing a value with itself minus one
        drops the lowest bit.  If the result is zero
        then it is a power of 2, provided that it
        wasn't zero or one to begin with.

        Ex. 010110 => 010110 & 010101 == 010100 NOT Power of 2.
        Ex. 001000 => 001000 & 000111 == 000000 Power of 2.
*/
{
    return ((data > 1) && !(data&(data-1))) ? TRUE : FALSE;
}


//
//  ReverseEndian for ULONG and USHORT, could have
//  used a template instead of overloading, but
//  the loop would have been less efficient.
//
inline ULONG ReverseEndian(ULONG Data)
{
    ULONG RetData;
    ((BYTE *)&RetData)[0]=((BYTE *)&Data)[3];
    ((BYTE *)&RetData)[1]=((BYTE *)&Data)[2];
    ((BYTE *)&RetData)[2]=((BYTE *)&Data)[1];
    ((BYTE *)&RetData)[3]=((BYTE *)&Data)[0];
    return RetData;
}
inline USHORT ReverseEndian(USHORT Data)
{
    USHORT RetData;
    ((BYTE *)&RetData)[0]=((BYTE *)&Data)[1];
    ((BYTE *)&RetData)[1]=((BYTE *)&Data)[0];
    return RetData;
}


//*****************************************************************************
// Defintions for a debug only IRP watchdog
//*****************************************************************************
#if DBG
#define MU_DEBUG_DECLARE_WATCHDOG_PARAMETERS() \
    KTIMER        DbgIrpTimer;\
    KDPC          DbgIrpTimeoutDpc;\
    LARGE_INTEGER DbgIrpTimeoutTime;
#define MU_DEBUG_INIT_WATCHDOG_PARAMETERS(DeviceExtension) MUDebugInitWatchDogParameters(DeviceExtension)
#define MU_DEBUG_SET_WATCHDOG(DeviceExtension) MuDebugSetWatchDogTimer(DeviceExtension)
#define MU_DEBUG_PET_WATCHDOG(DeviceExtension) MuDebugPetWatchDogTimer(DeviceExtension)
#define MU_COMPLETE_REQUEST(DeviceExtension, Irp, PriorityBoost) MuDebugCompleteRequest(DeviceExtension, Irp, PriorityBoost)
#else
#define MU_DEBUG_INIT_WATCHDOG_PARAMETERS(DeviceExtension)
#define MU_DEBUG_DECLARE_WATCHDOG_PARAMETERS()
#define MU_DEBUG_SET_WATCHDOG(DeviceExtension)
#define MU_DEBUG_PET_WATCHDOG(DeviceExtension)
#define MU_COMPLETE_REQUEST(DeviceExtension, Irp, PriorityBoost) IoCompleteRequest((Irp), (PriorityBoost))
#endif


//*****************************************************************************
// USB Definitions that are not elsewhere
//*****************************************************************************

//
// Interface Descriptor values
//

#define MU_SUBCLASS_RBC                 0x01
#define MU_SUBCLASS_TRANSPARENT         42
#define MU_PROTOCOL_BULK_ONLY           0x50

//
// Bulk-Only class-specific bRequest codes
//

#define BULK_ONLY_MASS_STORAGE_RESET    0xFF


//*****************************************************************************
// Declarations for performing diagnostics on Memory Units (requires special build)
//*****************************************************************************
#ifdef MU_DIAGNOSTIC_IOCTLS

//
//  VENDOR Specific Debug Commands bRequest
//

#define MU_VSC_GET_BAD_BLOCK_TABLE   0
#define MU_VSC_MEMORY_TEST           1

//
//  Definitions for VENDOR  Specific Debug Commands
//

#define MU_VSC_BAD_BLOCK_TABLE_SIZE (sizeof(USHORT)*16)
#define MU_VSC_BAD_BLOCK_COUNT_SIZE sizeof(USHORT)

//
// IOCTL to expose the vendor specific commands
// (supported only in debug builds)
//

#define MU_IOCTL_GET_BAD_BLOCK_TABLE\
    CTL_CODE(FILE_DEVICE_DISK, MU_VSC_GET_BAD_BLOCK_TABLE, METHOD_NEITHER, FILE_ANY_ACCESS)
#define MU_IOCTL_MEMORY_TEST\
    CTL_CODE(FILE_DEVICE_DISK, MU_VSC_MEMORY_TEST, METHOD_NEITHER, FILE_ANY_ACCESS)

#endif  //end of DIAGNOSTIC IOCTLS


//*****************************************************************************
// USB Bulk-Only Protocol Definitions
//*****************************************************************************

//
//  The MU driver requires that MU BULK endpoints
//  have a wMaxPacket of MU_MAX_BULK_PACKET_SIZE
//  (extra stringent Xbox requirement)

#define MU_MAX_BULK_PACKET_SIZE         0x40

//
// Command Block Wrapper Signature 'USBC'
//

#define CBW_SIGNATURE               0x43425355
#define CBW_FLAGS_DATA_IN           0x80
#define CBW_FLAGS_DATA_OUT          0x00

//
// Command Status Wrapper Signature 'USBS'
//

#define CSW_SIGNATURE               0x53425355

#define CSW_STATUS_GOOD             0x00
#define CSW_STATUS_FAILED           0x01
#define CSW_STATUS_PHASE_ERROR      0x02


#pragma pack (push, 1)

//
// Command Block Wrapper
//
typedef struct _CBW
{
    ULONG   dCBWSignature;

    ULONG   dCBWTag;

    ULONG   dCBWDataTransferLength;

    UCHAR   bCBWFlags;

    UCHAR   bCBWLUN;

    UCHAR   bCDBLength;
    union
    {
        UCHAR   CBWCDB[16];
        CDB     Cdb;
    };
} CBW, *PCBW;


// Command Status Wrapper
//
typedef struct _CSW
{
    ULONG   dCSWSignature;

    ULONG   dCSWTag;

    ULONG   dCSWDataResidue;

    UCHAR   bCSWStatus;

} CSW, *PCSW;

#pragma pack (pop)

//******************************************************************************
//  Various Hard-coded sizes.
//
//      EMULATED_SECTOR_SIZE - This is the sector size reported to the filesystem.
//          It is the smallest unit of data the filesystem will ever try to
//          read or write.
//
//      MEDIA_BLOCK_SIZE - This is the size of a block on the media.  A block on the
//          media is the smallest unit which can be erased.  All writes must
//          start on a block boundary and end on a block boundary.  The Xbox MU
//          protocol does NOT currently provide a mechanism to query the device.
//          This value is is hardcoded as 8192 bytes.  Devices with smaller
//          media block sizes should work fine with this driver, devices with
//          larger media block sizes would not work.
//
//      The other type of block size is the logical block size.  This is reported
//      back as BytesPerBlock in the READ_CAPACITY_DATA structure received in
//      in response to a read capacity command.  Any power of 2 value less than
//      4096 is supported.  This is typically the page size of the media, which
//      is the smallest unit which may be read or written (but not erased,
//      or rewritten).  For the standard Xbox hawk this value is 512 bytes.
//
//      WRITE_BUFFER_SIZE - This buffer is used store the original contents
//          of the portion of a media block that we need to write over.  When
//          a write for a portion of a media block is requested, the original
//          contents are read into this block, and then the whole thing is
//          written back out.
//
//******************************************************************************
#define EMULATED_SECTOR_SIZE             4096
#define EMULATED_SECTOR_SHIFT            12
#define MAXIMUM_MEDIA_BLOCK_SIZE         16384
#define DEFAULT_MEDIA_BLOCK_SIZE         8192
#define WRITE_BUFFER_SIZE                (MAXIMUM_MEDIA_BLOCK_SIZE - EMULATED_SECTOR_SIZE)

//*****************************************************************************
// Forward declarations of pointer to structure types
//*****************************************************************************
typedef struct _MU_DRIVER_EXTENSION *PMU_DRIVER_EXTENSION;
typedef struct _MU_INSTANCE *PMU_INSTANCE;
typedef struct _MU_DEVICE_EXTENSION *PMU_DEVICE_EXTENSION;

//*****************************************************************************
// Driver object and driver(not device) specific definitions
//*****************************************************************************
#define MU_CONTROLLERS_PER_PORT 2
#define MU_DEFAULT_MAX_MOUNTED  8
/* DEVICE_INDEX_FROM_PORT_AND_SLOT depends on MU_CONTROLLERS_PER_PORT = 2 */
#define NODE_INDEX_FROM_PORT_AND_SLOT(port, slot) ((port<<1)+slot)

typedef struct MU_DRIVER_EXTENSION {
   
    PMU_DEVICE_EXTENSION DeviceObjectFreeList;
    //
    //  Resources for handling writes to only a portion of
    //  a media block.  Not that there is one global WriteBuffer
    //  and partial requests are queued.
    //
    
    LIST_ENTRY  PartialRequestQueue;
    UCHAR       WriteBuffer[WRITE_BUFFER_SIZE];
    
    PMU_INSTANCE Nodes;

}  MU_DRIVER_EXTENSION;

extern MU_DRIVER_EXTENSION MU_DriverExtension;

//*****************************************************************************
// MU Request Block (MRB) defintions
//*****************************************************************************

#define MRB_TIMEOUT_UNIT                      (-100000) //This constant represents 10 ms to the timer routines.
#define MRB_STANDARD_TIMEOUT                  (8)       //Standard Timeout is 80 ms (spec says 50 ms), this applies to CBW's
#define MRB_DATA_TIMEOUT                      (15)      //Time out is 150 ms for each 2k portion of a read or write.
#define MRB_RESET_TIMEOUT                     (10)      //Time out is 100 ms for each stage of the reset sequence.
                                                          
#define MRB_READ_CAPACITY_TIMEOUT             (10)      // a 100 ms delay for the CSW of read capacity.
#define MRB_VERIFY_TIMEOUT_PER_64K            (100)     // 1 second per 64 kbytes verified for CSW of VERIFY.
#define MRB_CALC_VERIFY_TIMEOUT(VerifyLength) ((USHORT)(MRB_VERIFY_TIMEOUT_PER_64K*((VerifyLength) >> 16)))

#define MRB_MAXIMUM_RETRIES                    2        //Maximum number of times an MRB is retried.

#define MRB_FLAGS_NO_DATA_TRANSFER  0x00
#define MRB_FLAGS_DATA_IN           0x01
#define MRB_FLAGS_DATA_OUT          0x02
#define MRB_FLAGS_SPLIT_WRITE       0x04
#define MRB_FLAGS_UNSPECIFIED_DIRECTION (MRB_FLAGS_DATA_IN | MRB_FLAGS_DATA_OUT)
#define MRB_TRANSFER_SIZE           1024 //size of each transfer
#define MU_BULK_MIN_TD_QUOTA        ((2*MRB_TRANSFER_SIZE)/MU_MAX_BULK_PACKET_SIZE)

typedef VOID (*PFMU_IO_COMPLETION)(PMU_DEVICE_EXTENSION DeviceExtension, NTSTATUS Status);

typedef struct _MU_REQUEST_BLOCK {
    // filled out by disk layer
    // (are guaranteed to remain intact)
    PUCHAR             DataBuffer;
    ULONG              TransferLength;
    PFMU_IO_COMPLETION CompletionRoutine;
    USHORT             TimeOutValue; //in 10's of milliseconds
    UCHAR              Retries;
    UCHAR              Flags;
    ULONG              UserStartOffset; //For partial writes (read\modify\write)
    ULONG              UserEndOffset;   //Specifies which portion of the read goes
                                        //into the user buffer.
    CBW                Cbw; // Disk layer fills out only CDB
    //  Used by the MRB state machine
    CSW                Csw;
    union
    {
    NTSTATUS            FailedStatus;    //used to hold failure during reset.       
    ULONG              BytesSubmitted;
    };
    
    KTIMER             Timer;
    KDPC               TimeoutDpcObject;
} MU_REQUEST_BLOCK, *PMU_REQUEST_BLOCK;

//*****************************************************************************
// MU DeviceExtension and related defintions
//*****************************************************************************

//
// PDEVICE_EXTENSION->DeviceFlags state flags
//
#define DF_PENDING_CLOSE           0x00000001
#define DF_PENDING_REMOVE          0x00000002
#define DF_REMOVED                 0x00000004

//
//  Flags used by the MRB state machine,
//  these are internal to it.  The flags
//  in the MRB is only a direction.
//

#define DF_MRB_TIMER_RUNNING       0x00000100
#define DF_PRIMARY_URB_PENDING     0x00000200
#define DF_SECONDARY_URB_PENDING   0x00000400
#define DF_ERROR_PENDING           0x00000800
#define DF_RESET_STEP1             0x00001000
#define DF_RESET_STEP2             0x00002000
#define DF_RESET_STEP3             0x00004000
#define DF_RESET_STEPS (DF_RESET_STEP1|DF_RESET_STEP2|DF_RESET_STEP3)

#define DF_ANY_URB_PENDING (DF_PRIMARY_URB_PENDING|DF_SECONDARY_URB_PENDING)

//
// PDEVICE_EXTENSION->DeviceFlags state flags
// related to the endpoint state machine.
//

#define DF_ENDPOINT_FLAGS          0x000F0000
#define DF_DEFAULT_ENDPOINT_OPEN   0x00010000
#define DF_BULK_IN_ENDPOINT_OPEN   0x00020000
#define DF_BULK_OUT_ENDPOINT_OPEN  0x00040000
#define DF_CLOSING_ENDPOINTS       0x00080000
#define DF_ENDPOINTS_READY         0x00070000

//
// PDEVICE_EXTENSION->DeviceFlags state flags
// related to the write state machine.
//

#define MU_WRITE_HAS_INITIAL_PORTION 0x02000000
#define MU_WRITE_HAS_FINAL_PORTION   0x04000000
#define MU_WRITE_HAS_MIDDLE_PORTION  0x08000000
#define MU_WRITE_HAS_FLAGS   (MU_WRITE_HAS_INITIAL_PORTION|MU_WRITE_HAS_FINAL_PORTION|MU_WRITE_HAS_MIDDLE_PORTION)

//
//  Write state machine flags for the normal
//  partial write state machine.
//
#define MU_WRITE_STATE_START         0x10000000
#define MU_WRITE_STATE_INITIAL_READ  0x20000000
#define MU_WRITE_STATE_INITIAL_WRITE 0x30000000
#define MU_WRITE_STATE_FINAL_READ    0x40000000
#define MU_WRITE_STATE_FINAL_WRITE   0x50000000
#define MU_WRITE_STATE_DONE          0x60000000
#define MU_WRITE_STATE_BITS          0xF0000000
#define MU_WRITE_STATE_INCREMENT     0x10000000

//
//  Write state machine flags for the "middle" partial
//  write state machine.
//
#define MU_WRITE_STATE_MIDDLE_START        0x10000000
#define MU_WRITE_STATE_MIDDLE_READ_BEFORE  0x20000000
#define MU_WRITE_STATE_MIDDLE_READ_AFTER   0x30000000
#define MU_WRITE_STATE_MIDDLE_WRITE        0x40000000
#define MU_WRITE_STATE_MIDDLE_DONE         0x50000000


//
//  Pattern that we use for marking corrupt sectors.
//  (Don't worry how long it is (except for code space;),
//  in the success case, we stop comparing on the first
//  mismatch.  In the error case we have plenty of time
//  anyway.)  The number pattern at the beginning is part
//  of GUID generated with GUIDGEN.
//
const char tagMU_CORRUPT_SECTOR_PATTERN[]="951F0EF630DC46d9_CORRUPT_SECTOR";
#define MU_CORRUPT_SECTOR_PATTERN ((PULONG)tagMU_CORRUPT_SECTOR_PATTERN)
#define MU_CORRUPT_SECTOR_PATTERN_SIZE sizeof(tagMU_CORRUPT_SECTOR_PATTERN)
#define MU_CORRUPT_SECTOR_PATTERN_ULONG_COUNT (MU_CORRUPT_SECTOR_PATTERN_SIZE/sizeof(ULONG))

//
// MU_INSTANCE contains context data for each MU.
// These are statically allocated at startup time.
// 

typedef struct _MU_INSTANCE
{
    //
    // Device class interface to USB core stack
    //

    IUsbDevice      *Device;
    
    //
    // USB related data retrieved during 
    // enumeration, or when opening endpoints
    //

    UCHAR  InterfaceNumber;
    UCHAR  BulkInEndpointAddress;
    UCHAR  BulkOutEndpointAddress;
    UCHAR  AddRemoveCount;  //DEBUG ONLY, catches double removes and\or adds.    
    
    //
    //  Pointer to assigned device extension
    //

    PMU_DEVICE_EXTENSION DeviceExtension;

} MU_INSTANCE; 


typedef struct _MU_DEVICE_EXTENSION
{
    //
    //  Points to the Device Object
    //
    PDEVICE_OBJECT DeviceObject;

    //
    //  Number (used to regenerate the name)
    //
    ULONG DeviceObjectNumber;

    //
    //  Points to our MU_INSTANCE
    //
    union {
        PMU_INSTANCE         MuInstance;
        PMU_DEVICE_EXTENSION NextFree;
    };
    //
    // Various DF_xxxx flags
    //

    ULONG   DeviceFlags;

    
    //***
    //*** Above here is maintained while the device object
    //*** is on the free list, below is always zeroed.
    //***

    //
    // At any time, each device is processing
    // one IRP, this is it.
    //

    PIRP    PendingIrp;
    ULONG   IrpCount;   //Count of outstanding IRPs

    //  Variables to cache results of calculations
    //  for partial writes
    ULONG   InitialWriteByteCount;
    ULONG   FinalWriteByteCount;

    PVOID   BulkInEndpointHandle;
    PVOID   BulkOutEndpointHandle;

    //
    // The Mrb for managing commands
    //

    MU_REQUEST_BLOCK    Mrb;

    //
    //  Each instance maitains three independent URBs
    //  for communication with the device.
    //  This is so that two bulk URBs can be outstanding
    //  at once (which better utilizes bandwidth).
    //  Furthermore, a dedicated close URB is provided
    //  so that the close state machine does not need
    //  to synchronize with the MRB state machine.
    //
    
    URB                             Urb;
    URB_BULK_OR_INTERRUPT_TRANSFER  BulkUrbSecondary;
    URB_CLOSE_ENDPOINT              CloseEndpointUrb;
    KEVENT                          CloseEvent; //signaled when a close completes

    //
    //  Geomerty Information
    //

    DISK_GEOMETRY       DiskGeometry;
    ULONG               LogicalBlockShift;
    LARGE_INTEGER       PartitionLength;
    ULONG               MediaBlockSize;

    //
    //  Watchdog timer parameters
    //  
    MU_DEBUG_DECLARE_WATCHDOG_PARAMETERS()

} MU_DEVICE_EXTENSION;


//*****************************************************************************
// F U N C T I O N    P R O T O T Y P E S
//*****************************************************************************
// Only those between translation units.

//
//  inline [acquire and release preallocate device objects.
//
__inline 
PMU_DEVICE_EXTENSION
MU_AcquireDeviceObject()
{ 
    PMU_DEVICE_EXTENSION retVal;
    retVal = MU_DriverExtension.DeviceObjectFreeList;
    if(retVal)
    {
        MU_DriverExtension.DeviceObjectFreeList = retVal->NextFree;
        retVal->DeviceFlags = 0;
        retVal->MuInstance = NULL;
    }
    return retVal;
}

__inline 
VOID
MU_ReleaseDeviceObject(PMU_DEVICE_EXTENSION DeviceExtension)
{
    RtlZeroMemory(&DeviceExtension->PendingIrp, sizeof(MU_DEVICE_EXTENSION)-FIELD_OFFSET(MU_DEVICE_EXTENSION, PendingIrp));
    DeviceExtension->DeviceFlags = DF_REMOVED;
    DeviceExtension->NextFree = MU_DriverExtension.DeviceObjectFreeList;
    MU_DriverExtension.DeviceObjectFreeList = DeviceExtension;
}




//
// mu.cpp  [These are all called from outside the MU driver]
//

EXTERNUSB VOID
MU_Init(IUsbInit *pUsbInit);

EXTERNUSB VOID
MU_AddDevice (
    IN IUsbDevice *Device
    );

EXTERNUSB VOID
MU_RemoveDevice (
    IN IUsbDevice *Device
    );

extern "C"
{
NTSTATUS
MU_CreateDeviceObject(
    IN  ULONG            Port,
    IN  ULONG            Slot,
    IN  POBJECT_STRING  DeviceName
    );

VOID
MU_CloseDeviceObject(
    IN  ULONG  Port,
    IN  ULONG  Slot
    );

PDEVICE_OBJECT
MU_GetExistingDeviceObject(
    IN  ULONG  Port,
    IN  ULONG  Slot
    );
}
//
// mrb.cpp
//

VOID
FASTCALL
MU_fStartMrb(
    IN PMU_DEVICE_EXTENSION DeviceExtension
    );

VOID
MU_MrbTimeout (
    IN PKDPC Dpc,
    IN PVOID fdoDeviceExtension,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

//
//  disk.cpp
//

NTSTATUS
MU_InternalIo (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

VOID
MU_StartIo (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    );

//
//  Debug Only Methods, defined at the bottom of disk.cpp
//
#if DBG
VOID
MUDebugWatchdogDpcRoutine(
    PKDPC,
    PMU_DEVICE_EXTENSION DeviceExtension,
    PVOID,
    PVOID
    );

VOID
MUDebugInitWatchDogParameters(
    PMU_DEVICE_EXTENSION DeviceExtension
    );

VOID 
MuDebugSetWatchDogTimer(
    PMU_DEVICE_EXTENSION DeviceExtension
    );
VOID
MuDebugPetWatchDogTimer(
    PMU_DEVICE_EXTENSION DeviceExtension
    );

VOID 
MuDebugCompleteRequest(
    PMU_DEVICE_EXTENSION DeviceExtension,
    PIRP Irp,
    CCHAR PriorityBoost
    );
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\dd\usb\kdexts\usb\usbkdx.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name: 

    usbkdx.cpp

Abstract:

    Debugger extension for the XBox USB stack

Author:

    Josh Poley (jpoley)

Revision History:


USB Globals:
    ohcd\isr.c
        int IsrEntryCount=0;

    xid\xid.cpp
        XID_GLOBALS XID_Globals;
        USB_PNP_CLASS_DRIVER_DESCRIPTION GLOBAL_ClassDescription
        USB_PNP_DEVICE_TYPE_DESCRIPTION GLOBAL_DeviceTypes[XINPUT_DEVTYPE_COUNT];

    usbd\usbd.cpp
        UCHAR                    GLOBAL_HostControllerCount;
        PDRIVER_OBJECT           GLOBAL_DriverObject;
        XAPI_NOTIFICATION_SOURCE GLOBAL_NotificationSource;

    usbd\tree.cpp
        CDeviceTree g_DeviceTree;

    usbd\notify.cpp
        USBD_NOTIFICATIONS g_Notifications={0};

    usbpnp\pnp.cpp
        PFNUSBHUB_ResetHubPort				g_ResetRoutine = NULL;
        PUSB_PNP_CLASS_DRIVER_DESCRIPTION	g_FirstClassDriver = NULL;
        BOOLEAN								g_BaseDriverCalledYet = FALSE;

    usbhub\hub.cpp
        USBHUB_INFO						 GLOBAL_HubInfo;
        USBHUB_ENUM_BLOCK				 GLOBAL_HubEnum;
        USB_PNP_CLASS_DRIVER_DESCRIPTION GLOBAL_ClassDescription;

--*/

#define KDEXTMODE

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ntos.h>
#include <zwapi.h>

#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#include <imagehlp.h>

#include <memory.h>
#pragma hdrstop

#include <wdbgexts.h>
extern WINDBG_EXTENSION_APIS ExtensionApis;

#include <ntverp.h>
#include <imagehlp.h>

//
// include the necessary USB headers
//
#include "usb.h"
#include "urb.h"
//#include <xusbenum.h>
#include <xinput.h>

#include "xid.h"
#include "hub.h"
#include "usbd.h"


//
//  Globals
//
EXT_API_VERSION apiVersion = {
    (VER_PRODUCTVERSION_W >> 8),
    (VER_PRODUCTVERSION_W & 0xff),
    EXT_API_VERSION_NUMBER,
    0
    };

WINDBG_EXTENSION_APIS   ExtensionApis;
USHORT                  SavedMajorVersion;
USHORT                  SavedMinorVersion;

PSTR apiDescriptions =
    "\nUSB Debugging Extensions:\n\n"
    "help - show this help text\n"

    "device - displays a CUsbDevice from the CDeviceTree class\n"
    "    !usbkdx.device <&g_DeviceTree> <index>\n"
    "    dd g_DeviceTree l1\n"

    "hubclass - displays the global USB_PNP_CLASS_DRIVER_DESCRIPTION struct\n"
    "    !usbkdx.hubclass <&GLOBAL_ClassDescription>\n"
    "    dd GLOBAL_ClassDescription l1\n"

    "hubenum - displays the global USBHUB_ENUM_BLOCK struct\n"
    "    !usbkdx.hubenum <&GLOBAL_HubEnum>\n"
    "    dd GLOBAL_HubEnum l1\n"

    "hubinfo - displays the global USBHUB_INFO struct\n"
    "    !usbkdx.hubinfo <&GLOBAL_HubInfo>\n"
    "    dd GLOBAL_HubInfo l1\n"

    "tree - displays the global CDeviceTree class\n"
    "    !usbkdx.tree <&g_DeviceTree>\n"
    "    dd g_DeviceTree l1\n"

    "xidglobals - displays the global XID_GLOBALS struct\n"
    "    !usbkdx.xidglobals <&XID_Globals>\n"
    "    dd XID_Globals l1\n"
    "\n";


void PrintHexDump(const void* buffer, DWORD length);


//
//  DLLMain
//
BOOL WINAPI DLLMain(HINSTANCE hInstance, ULONG ulReason, LPVOID pvReserved)
    {
    switch(ulReason)
        {
        case DLL_PROCESS_ATTACH:
        case DLL_PROCESS_DETACH:
        case DLL_THREAD_ATTACH:
        case DLL_THREAD_DETACH:
        default:
            break;
        }

    return(TRUE);
    }


/*****************************************************************************

Routine Description:

    help

    Describes the extensions available from this library

Arguments:

    HANDLE hCurrentProcess
    HANDLE hCurrentThread
    ULONG  dwCurrentPc
    ULONG  dwProcessor
    PCSTR  args

Return Value:

    none

Notes:

    This function is ONLY called via the debugger

*****************************************************************************/
DECLARE_API(help)
    {
    dprintf(apiDescriptions);
    return;
    } // help


/*****************************************************************************

Routine Description:

    xidglobals

    Dumps out the values of the global XID_GLOBALS struct

Arguments:

    HANDLE hCurrentProcess
    HANDLE hCurrentThread
    ULONG  dwCurrentPc
    ULONG  dwProcessor
    PCSTR  args

Return Value:

    none

Notes:

    This function is ONLY called via the debugger

*****************************************************************************/
DECLARE_API(xidglobals)
    {
    XID_GLOBALS *globals;
    ULONG address;

    if(0 == args[0])
        {
        dprintf("xidglobals <address>\n");
        return;
        }

    sscanf(args, "%lx", &address);
    globals = (XID_GLOBALS *)address;

    dprintf("\nXID_GLOBALS:\n");
    dprintf("    DeviceNodeCount:       %u\n", globals->DeviceNodeCount);
    dprintf("    DeviceNodeInUseCount:  %u\n", globals->DeviceNodeInUseCount);
    dprintf("    DeviceNodes:           0x%X\n", globals->DeviceNodes);
    dprintf("    OpenDeviceList:        0x%X\n", globals->OpenDeviceList);
    dprintf("    EnumNode:              %u\n", globals->EnumNode);
    dprintf("    EnumUrb.Header:\n");
    dprintf("        Length:            %u\n", globals->EnumUrb.Header.Length);
    dprintf("        Function:          %u\n", globals->EnumUrb.Header.Function);
    dprintf("        Status:            0x%X\n", globals->EnumUrb.Header.Status);
    dprintf("        CompleteProc:      0x%X\n", globals->EnumUrb.Header.CompleteProc);
    dprintf("        CompleteContext:   0x%X\n", globals->EnumUrb.Header.CompleteContext);

    //union
    //{
    //    XID_DESCRIPTOR          EnumXidDescriptor;
    //    USB_DEVICE_DESCRIPTOR   EnumDeviceDescriptor;
    //};
    //UCHAR                       EnumMdlBuffer[sizeof(MDL)+sizeof(PFN_NUMBER)*2];
    //KTIMER                      EnumWatchdogTimer;
    //KDPC                        EnumWatchdogTimerDpc;

    return;
    } // xidglobals


/*****************************************************************************

Routine Description:

    hubinfo

    Dumps out the values of the global USBHUB_INFO struct

Arguments:

    HANDLE hCurrentProcess
    HANDLE hCurrentThread
    ULONG  dwCurrentPc
    ULONG  dwProcessor
    PCSTR  args

Return Value:

    none

Notes:

    This function is ONLY called via the debugger

*****************************************************************************/
DECLARE_API(hubinfo)
    {
    USBHUB_INFO *globals;
    ULONG address;

    if(0 == args[0])
        {
        dprintf("hubinfo <address>\n");
        return;
        }

    sscanf(args, "%lx", &address);
    globals = (USBHUB_INFO *)address;

    dprintf("\nUSBHUB_INFO:\n");
    dprintf("    NodeCount:             %u\n", globals->NodeCount);
    dprintf("    NodesInUse:            %u\n", globals->NodesInUse);
    dprintf("    EndpointMemory:        0x%X\n", globals->EndpointMemory);
    dprintf("    Nodes:\n");
    for(unsigned i=0; i<USBHUB_MAXIMUM_HUB_COUNT; i++)
        {
        dprintf("      %02d InUse:                  %u\n", i, globals->Nodes[i].InUse);
        dprintf("         OutstandingRequest:     %u\n", globals->Nodes[i].OutstandingRequest);
        dprintf("         RemovePending:          %u\n", globals->Nodes[i].RemovePending);
        dprintf("         PoweringPorts:          %u\n", globals->Nodes[i].PoweringPorts);
        dprintf("         UsbNodeIndex:           %u\n", globals->Nodes[i].UsbNodeIndex);
        dprintf("         PortCount:              %u\n", globals->Nodes[i].PortCount);
        dprintf("         PortProcessIndex:       %u\n", globals->Nodes[i].PortProcessIndex);
        dprintf("         PortStatusChangeBitmap: %u\n", globals->Nodes[i].PortStatusChangeBitmap);
        dprintf("         PortConnectedBitmap:    %u\n", globals->Nodes[i].PortConnectedBitmap);
        dprintf("         InterruptEndpointHandle:0x%X\n", globals->Nodes[i].InterruptEndpointHandle);
        //URB				Urb;
        //union
        //{
        //    UCHAR			RequestBuffer[4];
        //    struct {
        //	    USHORT		Status;
        //	    USHORT		StatusChange;
        //    }				PortStatus;
        //};
	    //UCHAR			MdlBuffer[sizeof(MDL)+sizeof(PFN_NUMBER)*2];
        }

    return;
    } // hubinfo


/*****************************************************************************

Routine Description:

    hubenum

    Dumps out the values of the global USBHUB_ENUM_BLOCK struct

Arguments:

    HANDLE hCurrentProcess
    HANDLE hCurrentThread
    ULONG  dwCurrentPc
    ULONG  dwProcessor
    PCSTR  args

Return Value:

    none

Notes:

    This function is ONLY called via the debugger

*****************************************************************************/
DECLARE_API(hubenum)
    {
    USBHUB_ENUM_BLOCK *globals;
    ULONG address;

    if(0 == args[0])
        {
        dprintf("hubenum <address>\n");
        return;
        }

    sscanf(args, "%lx", &address);
    globals = (USBHUB_ENUM_BLOCK*)address;

    dprintf("\nUSBHUB_ENUM_BLOCK:\n");
    dprintf("    EnumBuffer:\n");
    PrintHexDump(globals->EnumBuffer, 32);
    dprintf("    ResetUrb.Header:\n");
    dprintf("        Length:            %u\n", globals->ResetUrb.Header.Length);
    dprintf("        Function:          %u\n", globals->ResetUrb.Header.Function);
    dprintf("        Status:            0x%X\n", globals->ResetUrb.Header.Status);
    dprintf("        CompleteProc:      0x%X\n", globals->ResetUrb.Header.CompleteProc);
    dprintf("        CompleteContext:   0x%X\n", globals->ResetUrb.Header.CompleteContext);
    dprintf("    ResetContext:          %u\n", globals->ResetContext);

    //UCHAR						MdlBuffer[sizeof(MDL)+sizeof(PFN_NUMBER)*2];
    //KTIMER                      WatchdogTimer;
    //KDPC                        WatchdogTimerDpc;

    return;
    } // hubenum

/*****************************************************************************

Routine Description:

    hubclass

    Dumps out the values of the global USB_PNP_CLASS_DRIVER_DESCRIPTION struct

Arguments:

    HANDLE hCurrentProcess
    HANDLE hCurrentThread
    ULONG  dwCurrentPc
    ULONG  dwProcessor
    PCSTR  args

Return Value:

    none

Notes:

    This function is ONLY called via the debugger

*****************************************************************************/
DECLARE_API(hubclass)
    {
    USB_PNP_CLASS_DRIVER_DESCRIPTION *globals;
    ULONG address;

    if(0 == args[0])
        {
        dprintf("hubclass <address>\n");
        return;
        }

    sscanf(args, "%lx", &address);
    globals = (USB_PNP_CLASS_DRIVER_DESCRIPTION *)address;

    dprintf("\nUSB_PNP_CLASS_DRIVER_DESCRIPTION:\n");
    dprintf("    ClassId:\n");
    dprintf("        AsLong:            %u\n", globals->ClassId.AsLong);
    dprintf("        bClassSpecificType:%u\n", globals->ClassId.USB.bClassSpecificType);
    dprintf("        bClass:            %u\n", globals->ClassId.USB.bClass);
    dprintf("        bSubClass:         %u\n", globals->ClassId.USB.bSubClass);
    dprintf("        bProtocol:         %u\n", globals->ClassId.USB.bProtocol);
    dprintf("    Context:               0x%X\n", globals->Context);
    dprintf("    Reserved:              0x%X\n", globals->Reserved);
    dprintf("    DeviceTypeCount:       %u\n", globals->DeviceTypeCount);

/*
    PFNADD_USB_DEVICE                AddDevice;
    PFNREMOVE_USB_DEVICE             RemoveDevice;
    PUSB_PNP_DEVICE_TYPE_DESCRIPTION DeviceTypes;
*/
    return;
    } // hubclass


/*****************************************************************************

Routine Description:

    tree

    Dumps out the values of the global CDeviceTree class

Arguments:

    HANDLE hCurrentProcess
    HANDLE hCurrentThread
    ULONG  dwCurrentPc
    ULONG  dwProcessor
    PCSTR  args

Return Value:

    none

Notes:

    This function is ONLY called via the debugger

*****************************************************************************/
DECLARE_API(tree)
    {
    CDeviceTree *globals;
    ULONG address;

    if(0 == args[0])
        {
        dprintf("tree <address>\n");
        return;
        }

    sscanf(args, "%lx", &address);
    globals = (CDeviceTree *)address;

    dprintf("\nCDeviceTree:\n");
    dprintf("    m_InProgress:          %u\n", globals->m_InProgress);
    dprintf("    m_DeviceRemoved:       %u\n", globals->m_DeviceRemoved);
    dprintf("    m_EnumUrb.Header:\n");
    dprintf("        Length:            %u\n", globals->m_EnumUrb.Header.Length);
    dprintf("        Function:          %u\n", globals->m_EnumUrb.Header.Function);
    dprintf("        Status:            0x%X\n", globals->m_EnumUrb.Header.Status);
    dprintf("        CompleteProc:      0x%X\n", globals->m_EnumUrb.Header.CompleteProc);
    dprintf("        CompleteContext:   0x%X\n", globals->m_EnumUrb.Header.CompleteContext);
    dprintf("    m_TimerReason:         %u\n", globals->m_TimerReason);
    dprintf("    m_FirstFree:           %u\n", globals->m_FirstFree);
    dprintf("    m_Topology:            %02X %02X %02X %02X\n", globals->m_Topology[0], globals->m_Topology[1], globals->m_Topology[2], globals->m_Topology[3]);
    dprintf("    m_DeviceDescriptor:\n");
    dprintf("        bLength:           %u\n", globals->m_DeviceDescriptor.bLength);
    dprintf("        bDescriptorType:   %u\n", globals->m_DeviceDescriptor.bDescriptorType);
    dprintf("        bcdUSB:            %u\n", globals->m_DeviceDescriptor.bcdUSB);
    dprintf("        bDeviceClass:      %u\n", globals->m_DeviceDescriptor.bDeviceClass);
    dprintf("        bDeviceSubClass:   %u\n", globals->m_DeviceDescriptor.bDeviceSubClass);
    dprintf("        bDeviceProtocol:   %u\n", globals->m_DeviceDescriptor.bDeviceProtocol);
    dprintf("        bMaxPacketSize0:   %u\n", globals->m_DeviceDescriptor.bMaxPacketSize0);
    if(globals->m_InterfaceDescriptor)
        {
        dprintf("    m_InterfaceDescriptor:\n");
        dprintf("        bLength:           %u\n", globals->m_InterfaceDescriptor->bLength);
        dprintf("        bDescriptorType:   %u\n", globals->m_InterfaceDescriptor->bDescriptorType);
        dprintf("        bInterfaceNumber:  %u\n", globals->m_InterfaceDescriptor->bInterfaceNumber);
        dprintf("        bAlternateSetting: %u\n", globals->m_InterfaceDescriptor->bAlternateSetting);
        dprintf("        bNumEndpoints:     %u\n", globals->m_InterfaceDescriptor->bNumEndpoints);
        dprintf("        bInterfaceClass:   %u\n", globals->m_InterfaceDescriptor->bInterfaceClass);
        dprintf("        bInterfaceSubClass:%u\n", globals->m_InterfaceDescriptor->bInterfaceSubClass);
        dprintf("        bInterfaceProtocol:%u\n", globals->m_InterfaceDescriptor->bInterfaceProtocol);
        dprintf("        iInterface:        %u\n", globals->m_InterfaceDescriptor->iInterface);
        }

/*
    UCHAR                       m_MdlBuffer[sizeof(MDL)+sizeof(PFN_NUMBER)*2];
    KDPC                        m_EnumDpc;
    KTIMER                      m_EnumTimer;
    CUsbDevice                  *m_FirstPendingEnum;
    CUsbDevice                  *m_CurrentEnum;
    UCHAR                       m_ConfigurationDescriptorBuffer[USBD_MAX_CONFIG_DESC_SIZE];
    CUsbDevice                  m_Devices[UDN_MAX_NODES];
*/

    return;
    } // tree


/*****************************************************************************

Routine Description:

    device

    Dumps out the values of a CUsbDevice from the global CDeviceTree class

Arguments:

    HANDLE hCurrentProcess
    HANDLE hCurrentThread
    ULONG  dwCurrentPc
    ULONG  dwProcessor
    PCSTR  args

Return Value:

    none

Notes:

    This function is ONLY called via the debugger

*****************************************************************************/
DECLARE_API(device)
    {
    CDeviceTree *globals;
    ULONG address;
    unsigned index;

    if(0 == args[0])
        {
        dprintf("device <address> <index>\n");
        return;
        }

    sscanf(args, "%lx %u", &address, &index);
    globals = (CDeviceTree *)address;

    dprintf("\nCDeviceTree.CUsbDevice[%u]:\n", index);
    dprintf("    m_Type:                %u\n", globals->m_Devices[index].m_Type);
    dprintf("    m_NextFree:            %u\n", globals->m_Devices[index].m_NextFree);
    dprintf("    m_bInterfaceNumber:    %u\n", globals->m_Devices[index].m_bInterfaceNumber);
    dprintf("    m_Sibling:             %u\n", globals->m_Devices[index].m_Sibling);
    dprintf("    m_PortNumber:          %u\n", globals->m_Devices[index].m_PortNumber);
    dprintf("    m_Address:             %u\n", globals->m_Devices[index].m_Address);
    dprintf("    m_MaxPacket0:          %u\n", globals->m_Devices[index].m_MaxPacket0);
    dprintf("    m_ClassSpecificType:   %u\n", globals->m_Devices[index].m_ClassSpecificType);
    dprintf("    m_DefaultEndpoint:     0x%X\n", globals->m_Devices[index].m_DefaultEndpoint);
    if(globals->m_Devices[index].m_HostController)
        {
        dprintf("    m_HostController:\n");
        dprintf("        ControllerNumber:  %u\n", globals->m_Devices[index].m_HostController->ControllerNumber);
        dprintf("        RootHub:           0x%X\n", globals->m_Devices[index].m_HostController->RootHub);
        dprintf("        AddressList:       %X %X %X %X\n", globals->m_Devices[index].m_HostController->AddressList[0], globals->m_Devices[index].m_HostController->AddressList[1], globals->m_Devices[index].m_HostController->AddressList[2], globals->m_Devices[index].m_HostController->AddressList[3]);
        dprintf("        HcdExtension:      0x%X\n", &globals->m_Devices[index].m_HostController->HcdExtension);
        }
    dprintf("    m_ClassDriverExtension:0x%X\n", globals->m_Devices[index].m_ClassDriverExtension);
    dprintf("    m_ExternalPort:         %u\n", globals->m_Devices[index].m_ExternalPort);

    return;
    } // device

void WinDbgExtensionDllInit(PWINDBG_EXTENSION_APIS pExtensionApis, USHORT MajorVersion, USHORT MinorVersion)
    {
    ExtensionApis = *pExtensionApis;

    SavedMajorVersion = MajorVersion;
    SavedMinorVersion = MinorVersion;

    return;
    }

void CheckVersion(void)
    {
    }

LPEXT_API_VERSION ExtensionApiVersion(void)
    {
    return &apiVersion;
    }


/*****************************************************************************

Routine Description:

    PrintHexDump

    Outputs a hex dump of memory

Arguments:

        const void* buffer - pointer to start of the memory
        DWORD length - how many bytes to dump

Return Value:

    none

*****************************************************************************/
void PrintHexDump(const void* buffer, DWORD length)
    {
    DWORD i,count,index;
    CHAR rgbLine[100];
    char cbLine;
    const char *buff = (const char*)buffer;

    for(index = 0; length; length -= count, buff += count, index += count)
        {
        count = (length > 16) ? 16:length;

        sprintf(rgbLine, "%4.4X  ",index);
        cbLine = 6;

        for(i=0;i<count;i++)
            {
            sprintf(rgbLine+cbLine, "%02X", buff[i]);
            cbLine +=2;

            if(i == 7)
                {
                rgbLine[cbLine++] = ' ';
                }
            else
                {
                rgbLine[cbLine++] = ' ';
                }
            }
        for(; i < 16; i++)
            {
            rgbLine[cbLine++] = ' ';
            rgbLine[cbLine++] = ' ';
            rgbLine[cbLine++] = ' ';
            }

        rgbLine[cbLine++] = ' ';

        for(i = 0; i < count; i++)
            {
            if(buff[i] < 32 || buff[i] > 126)
                {
                rgbLine[cbLine++] = '.';
                }
            else
                {
                rgbLine[cbLine++] = buff[i];
                }
            }

        rgbLine[cbLine++] = 0;
        dprintf("    %s\n", rgbLine);
        }

    return;
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\dd\usb\kdexts\usb\dumpstruct.cpp ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    usbkdx.cpp

Abstract:

    Debugger extensions to dump out (pretty print) different 
    classes and structs

Author:

    Josh Poley (jpoley)

Revision History:


USB Globals:

    ohcd\isr.c
        int                                 IsrEntryCount=0;

    xid\xid.cpp
        XID_GLOBALS                         XID_Globals;
        USB_PNP_CLASS_DRIVER_DESCRIPTION    GLOBAL_ClassDescription
        USB_PNP_DEVICE_TYPE_DESCRIPTION     GLOBAL_DeviceTypes[XINPUT_DEVTYPE_COUNT];

    usbd\usbd.cpp
        UCHAR                               GLOBAL_HostControllerCount;
        PDRIVER_OBJECT                      GLOBAL_DriverObject;
        XAPI_NOTIFICATION_SOURCE            GLOBAL_NotificationSource;

    usbd\tree.cpp
        CDeviceTree                         g_DeviceTree;

    usbd\notify.cpp
        USBD_NOTIFICATIONS                  g_Notifications={0};

    usbpnp\pnp.cpp
        PFNUSBHUB_ResetHubPort              g_ResetRoutine = NULL;
        PUSB_PNP_CLASS_DRIVER_DESCRIPTION   g_FirstClassDriver = NULL;
        BOOLEAN                             g_BaseDriverCalledYet = FALSE;

    usbhub\hub.cpp
        USBHUB_INFO						    GLOBAL_HubInfo;
        USBHUB_ENUM_BLOCK				    GLOBAL_HubEnum;
        USB_PNP_CLASS_DRIVER_DESCRIPTION    GLOBAL_ClassDescription;

--*/

#define KDEXTMODE

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ntos.h>
#include <stdio.h>
#include <string.h>
#include <ntverp.h>
#include <wdbgexts.h>


//
// include the necessary USB headers
//
#include <xinput.h>
//#include <xusbenum.h>
#include "usb.h"
#include "urb.h"
#include "xid.h"
#include "hub.h"
#include "usbd.h"


extern void PrintHexDump(const void* buffer, DWORD length);


/*****************************************************************************

Routine Description:

    xidglobals

    Dumps out the values of the global XID_GLOBALS struct

Arguments:

    HANDLE hCurrentProcess
    HANDLE hCurrentThread
    ULONG  dwCurrentPc
    ULONG  dwProcessor
    PCSTR  args

Return Value:

    none

Notes:

    This function is ONLY called via the debugger

*****************************************************************************/
DECLARE_API(xidglobals)
    {
    XID_GLOBALS *globals;
    ULONG address;

    if(0 == args[0])
        {
        dprintf("xidglobals <address>\n");
        return;
        }

    sscanf(args, "%lx", &address);
    globals = (XID_GLOBALS *)address;

    dprintf("\nXID_GLOBALS:\n");
    dprintf("    DeviceNodeCount:       %u\n", globals->DeviceNodeCount);
    dprintf("    DeviceNodeInUseCount:  %u\n", globals->DeviceNodeInUseCount);
    dprintf("    DeviceNodes:           0x%X\n", globals->DeviceNodes);
    dprintf("    OpenDeviceList:        0x%X\n", globals->OpenDeviceList);
    dprintf("    EnumNode:              %u\n", globals->EnumNode);
    dprintf("    EnumUrb.Header:\n");
    dprintf("        Length:            %u\n", globals->EnumUrb.Header.Length);
    dprintf("        Function:          %u\n", globals->EnumUrb.Header.Function);
    dprintf("        Status:            0x%X\n", globals->EnumUrb.Header.Status);
    dprintf("        CompleteProc:      0x%X\n", globals->EnumUrb.Header.CompleteProc);
    dprintf("        CompleteContext:   0x%X\n", globals->EnumUrb.Header.CompleteContext);

    //union
    //{
    //    XID_DESCRIPTOR          EnumXidDescriptor;
    //    USB_DEVICE_DESCRIPTOR   EnumDeviceDescriptor;
    //};
    //UCHAR                       EnumMdlBuffer[sizeof(MDL)+sizeof(PFN_NUMBER)*2];
    //KTIMER                      EnumWatchdogTimer;
    //KDPC                        EnumWatchdogTimerDpc;

    return;
    } // xidglobals


/*****************************************************************************

Routine Description:

    hubinfo

    Dumps out the values of the global USBHUB_INFO struct

Arguments:

    HANDLE hCurrentProcess
    HANDLE hCurrentThread
    ULONG  dwCurrentPc
    ULONG  dwProcessor
    PCSTR  args

Return Value:

    none

Notes:

    This function is ONLY called via the debugger

*****************************************************************************/
DECLARE_API(hubinfo)
    {
    USBHUB_INFO *globals;
    ULONG address;

    if(0 == args[0])
        {
        dprintf("hubinfo <address>\n");
        return;
        }

    sscanf(args, "%lx", &address);
    globals = (USBHUB_INFO *)address;

    dprintf("\nUSBHUB_INFO:\n");
    dprintf("    NodeCount:             %u\n", globals->NodeCount);
    dprintf("    NodesInUse:            %u\n", globals->NodesInUse);
    dprintf("    EndpointMemory:        0x%X\n", globals->EndpointMemory);
    dprintf("    Nodes:\n");
    for(unsigned i=0; i<USBHUB_MAXIMUM_HUB_COUNT; i++)
        {
        dprintf("      %02d InUse:                  %u\n", i, globals->Nodes[i].InUse);
        dprintf("         OutstandingRequest:     %u\n", globals->Nodes[i].OutstandingRequest);
        dprintf("         RemovePending:          %u\n", globals->Nodes[i].RemovePending);
        dprintf("         PoweringPorts:          %u\n", globals->Nodes[i].PoweringPorts);
        dprintf("         UsbNodeIndex:           %u\n", globals->Nodes[i].UsbNodeIndex);
        dprintf("         PortCount:              %u\n", globals->Nodes[i].PortCount);
        dprintf("         PortProcessIndex:       %u\n", globals->Nodes[i].PortProcessIndex);
        dprintf("         PortStatusChangeBitmap: %u\n", globals->Nodes[i].PortStatusChangeBitmap);
        dprintf("         PortConnectedBitmap:    %u\n", globals->Nodes[i].PortConnectedBitmap);
        dprintf("         InterruptEndpointHandle:0x%X\n", globals->Nodes[i].InterruptEndpointHandle);
        //URB				Urb;
        //union
        //{
        //    UCHAR			RequestBuffer[4];
        //    struct {
        //	    USHORT		Status;
        //	    USHORT		StatusChange;
        //    }				PortStatus;
        //};
	    //UCHAR			MdlBuffer[sizeof(MDL)+sizeof(PFN_NUMBER)*2];
        }

    return;
    } // hubinfo


/*****************************************************************************

Routine Description:

    hubenum

    Dumps out the values of the global USBHUB_ENUM_BLOCK struct

Arguments:

    HANDLE hCurrentProcess
    HANDLE hCurrentThread
    ULONG  dwCurrentPc
    ULONG  dwProcessor
    PCSTR  args

Return Value:

    none

Notes:

    This function is ONLY called via the debugger

*****************************************************************************/
DECLARE_API(hubenum)
    {
    USBHUB_ENUM_BLOCK *globals;
    ULONG address;

    if(0 == args[0])
        {
        dprintf("hubenum <address>\n");
        return;
        }

    sscanf(args, "%lx", &address);
    globals = (USBHUB_ENUM_BLOCK*)address;

    dprintf("\nUSBHUB_ENUM_BLOCK:\n");
    dprintf("    EnumBuffer:\n");
    PrintHexDump(globals->EnumBuffer, 32);
    dprintf("    ResetUrb.Header:\n");
    dprintf("        Length:            %u\n", globals->ResetUrb.Header.Length);
    dprintf("        Function:          %u\n", globals->ResetUrb.Header.Function);
    dprintf("        Status:            0x%X\n", globals->ResetUrb.Header.Status);
    dprintf("        CompleteProc:      0x%X\n", globals->ResetUrb.Header.CompleteProc);
    dprintf("        CompleteContext:   0x%X\n", globals->ResetUrb.Header.CompleteContext);
    dprintf("    ResetContext:          %u\n", globals->ResetContext);

    //UCHAR						MdlBuffer[sizeof(MDL)+sizeof(PFN_NUMBER)*2];
    //KTIMER                      WatchdogTimer;
    //KDPC                        WatchdogTimerDpc;

    return;
    } // hubenum

/*****************************************************************************

Routine Description:

    hubclass

    Dumps out the values of the global USB_PNP_CLASS_DRIVER_DESCRIPTION struct

Arguments:

    HANDLE hCurrentProcess
    HANDLE hCurrentThread
    ULONG  dwCurrentPc
    ULONG  dwProcessor
    PCSTR  args

Return Value:

    none

Notes:

    This function is ONLY called via the debugger

*****************************************************************************/
DECLARE_API(hubclass)
    {
    USB_PNP_CLASS_DRIVER_DESCRIPTION *globals;
    ULONG address;

    if(0 == args[0])
        {
        dprintf("hubclass <address>\n");
        return;
        }

    sscanf(args, "%lx", &address);
    globals = (USB_PNP_CLASS_DRIVER_DESCRIPTION *)address;

    dprintf("\nUSB_PNP_CLASS_DRIVER_DESCRIPTION:\n");
    dprintf("    ClassId:\n");
    dprintf("        AsLong:            %u\n", globals->ClassId.AsLong);
    dprintf("        bClassSpecificType:%u\n", globals->ClassId.USB.bClassSpecificType);
    dprintf("        bClass:            %u\n", globals->ClassId.USB.bClass);
    dprintf("        bSubClass:         %u\n", globals->ClassId.USB.bSubClass);
    dprintf("        bProtocol:         %u\n", globals->ClassId.USB.bProtocol);
    dprintf("    Context:               0x%X\n", globals->Context);
    dprintf("    Reserved:              0x%X\n", globals->Reserved);
    dprintf("    DeviceTypeCount:       %u\n", globals->DeviceTypeCount);

/*
    PFNADD_USB_DEVICE                AddDevice;
    PFNREMOVE_USB_DEVICE             RemoveDevice;
    PUSB_PNP_DEVICE_TYPE_DESCRIPTION DeviceTypes;
*/
    return;
    } // hubclass


/*****************************************************************************

Routine Description:

    tree

    Dumps out the values of the global CDeviceTree class

Arguments:

    HANDLE hCurrentProcess
    HANDLE hCurrentThread
    ULONG  dwCurrentPc
    ULONG  dwProcessor
    PCSTR  args

Return Value:

    none

Notes:

    This function is ONLY called via the debugger

*****************************************************************************/
DECLARE_API(tree)
    {
    CDeviceTree *globals;
    ULONG address;

    if(0 == args[0])
        {
        dprintf("tree <address>\n");
        return;
        }

    sscanf(args, "%lx", &address);
    globals = (CDeviceTree *)address;

    dprintf("\nCDeviceTree:\n");
    dprintf("    m_InProgress:          %u\n", globals->m_InProgress);
    dprintf("    m_DeviceRemoved:       %u\n", globals->m_DeviceRemoved);
    dprintf("    m_EnumUrb.Header:\n");
    dprintf("        Length:            %u\n", globals->m_EnumUrb.Header.Length);
    dprintf("        Function:          %u\n", globals->m_EnumUrb.Header.Function);
    dprintf("        Status:            0x%X\n", globals->m_EnumUrb.Header.Status);
    dprintf("        CompleteProc:      0x%X\n", globals->m_EnumUrb.Header.CompleteProc);
    dprintf("        CompleteContext:   0x%X\n", globals->m_EnumUrb.Header.CompleteContext);
    dprintf("    m_TimerReason:         %u\n", globals->m_TimerReason);
    dprintf("    m_FirstFree:           %u\n", globals->m_FirstFree);
    dprintf("    m_Topology:            %02X %02X %02X %02X\n", globals->m_Topology[0], globals->m_Topology[1], globals->m_Topology[2], globals->m_Topology[3]);
    dprintf("    m_DeviceDescriptor:\n");
    dprintf("        bLength:           %u\n", globals->m_DeviceDescriptor.bLength);
    dprintf("        bDescriptorType:   %u\n", globals->m_DeviceDescriptor.bDescriptorType);
    dprintf("        bcdUSB:            %u\n", globals->m_DeviceDescriptor.bcdUSB);
    dprintf("        bDeviceClass:      %u\n", globals->m_DeviceDescriptor.bDeviceClass);
    dprintf("        bDeviceSubClass:   %u\n", globals->m_DeviceDescriptor.bDeviceSubClass);
    dprintf("        bDeviceProtocol:   %u\n", globals->m_DeviceDescriptor.bDeviceProtocol);
    dprintf("        bMaxPacketSize0:   %u\n", globals->m_DeviceDescriptor.bMaxPacketSize0);
    if(globals->m_InterfaceDescriptor)
        {
        dprintf("    m_InterfaceDescriptor:\n");
        dprintf("        bLength:           %u\n", globals->m_InterfaceDescriptor->bLength);
        dprintf("        bDescriptorType:   %u\n", globals->m_InterfaceDescriptor->bDescriptorType);
        dprintf("        bInterfaceNumber:  %u\n", globals->m_InterfaceDescriptor->bInterfaceNumber);
        dprintf("        bAlternateSetting: %u\n", globals->m_InterfaceDescriptor->bAlternateSetting);
        dprintf("        bNumEndpoints:     %u\n", globals->m_InterfaceDescriptor->bNumEndpoints);
        dprintf("        bInterfaceClass:   %u\n", globals->m_InterfaceDescriptor->bInterfaceClass);
        dprintf("        bInterfaceSubClass:%u\n", globals->m_InterfaceDescriptor->bInterfaceSubClass);
        dprintf("        bInterfaceProtocol:%u\n", globals->m_InterfaceDescriptor->bInterfaceProtocol);
        dprintf("        iInterface:        %u\n", globals->m_InterfaceDescriptor->iInterface);
        }

/*
    UCHAR                       m_MdlBuffer[sizeof(MDL)+sizeof(PFN_NUMBER)*2];
    KDPC                        m_EnumDpc;
    KTIMER                      m_EnumTimer;
    CUsbDevice                  *m_FirstPendingEnum;
    CUsbDevice                  *m_CurrentEnum;
    UCHAR                       m_ConfigurationDescriptorBuffer[USBD_MAX_CONFIG_DESC_SIZE];
    CUsbDevice                  m_Devices[UDN_MAX_NODES];
*/

    return;
    } // tree


/*****************************************************************************

Routine Description:

    device

    Dumps out the values of a CUsbDevice from the global CDeviceTree class

Arguments:

    HANDLE hCurrentProcess
    HANDLE hCurrentThread
    ULONG  dwCurrentPc
    ULONG  dwProcessor
    PCSTR  args

Return Value:

    none

Notes:

    This function is ONLY called via the debugger

*****************************************************************************/
DECLARE_API(device)
    {
    CDeviceTree *globals;
    ULONG address;
    unsigned index;

    if(0 == args[0])
        {
        dprintf("device <address> <index>\n");
        return;
        }

    sscanf(args, "%lx %u", &address, &index);
    globals = (CDeviceTree *)address;

    dprintf("\nCDeviceTree.CUsbDevice[%u]:\n", index);
    dprintf("    m_Type:                %u\n", globals->m_Devices[index].m_Type);
    dprintf("    m_NextFree:            %u\n", globals->m_Devices[index].m_NextFree);
    dprintf("    m_bInterfaceNumber:    %u\n", globals->m_Devices[index].m_bInterfaceNumber);
    dprintf("    m_Sibling:             %u\n", globals->m_Devices[index].m_Sibling);
    dprintf("    m_PortNumber:          %u\n", globals->m_Devices[index].m_PortNumber);
    dprintf("    m_Address:             %u\n", globals->m_Devices[index].m_Address);
    dprintf("    m_MaxPacket0:          %u\n", globals->m_Devices[index].m_MaxPacket0);
    dprintf("    m_ClassSpecificType:   %u\n", globals->m_Devices[index].m_ClassSpecificType);
    dprintf("    m_DefaultEndpoint:     0x%X\n", globals->m_Devices[index].m_DefaultEndpoint);
    if(globals->m_Devices[index].m_HostController)
        {
        dprintf("    m_HostController:\n");
        dprintf("        ControllerNumber:  %u\n", globals->m_Devices[index].m_HostController->ControllerNumber);
        dprintf("        RootHub:           0x%X\n", globals->m_Devices[index].m_HostController->RootHub);
        dprintf("        AddressList:       %X %X %X %X\n", globals->m_Devices[index].m_HostController->AddressList[0], globals->m_Devices[index].m_HostController->AddressList[1], globals->m_Devices[index].m_HostController->AddressList[2], globals->m_Devices[index].m_HostController->AddressList[3]);
        dprintf("        HcdExtension:      0x%X\n", &globals->m_Devices[index].m_HostController->HcdExtension);
        }
    dprintf("    m_ClassDriverExtension:0x%X\n", globals->m_Devices[index].m_ClassDriverExtension);
    dprintf("    m_ExternalPort:         %u\n", globals->m_Devices[index].m_ExternalPort);

    return;
    } // device
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\dd\usb\mu\mrb.cpp ===
/*++

Copyright (c) 1996-2000 Microsoft Corporation

Module Name:

    mrb.cpp

Abstract:

    This source file contains the state machine for 
    MU requests blocks to the device.  The bulk-only protocol
    specifices three stages for every transfer.

    The only entry point to the MRB state machine is

    MU_fStartMrb

Environment:

    kernel mode

Revision History:

    06-12-2000 : started rewrite : georgioc
    10-20-2000 : major cleanup (separated out the MRB state machine,
                 from the partial write state machine, which is now
                 in disk.cpp : mitchd
    03-07-2001 : generalized the way write commands are handled to aid
                 the partial write state machine (in disk.cpp) support
                 more flexible block sizes : mitchd

--*/


/*++
    Description of MRB state machine changes started on 03/07/01.
    
    Even after the cleanup on 10-20-2000, there was still a special case in
    the state machine to transfer the data stage of an MRB from two buffers:
    the user's buffer, and the MU WriteBuffer used to maintain media block
    integrity.  This code peered into disk.cpp's flags to figure out when this
    was necessary, somewhat of a hack.  The problem with this code is that it
    only supports a media block size that is double the emulated sector size.  
    We now need to lift this restriction in order to support larger media.

    So this change formalizes the hack by adding supporting a new MRB flag,
    MRB_FLAGS_SPLIT_WRITE, and to new fields filled out by disk.cpp: UserStartOffset,
    and UserEndOffset.  When MRB_FLAGS_SPLIT_WRITE the transfer length, must be
    exactly one media block.  The write is performed as follows:

    1) Write UserStartOffset bytes from the beginning of the WriteBuffer.
    2) Write (UserEndOffset-UserStartOffset) bytes from the beginning of the
       user buffer.
    3) Write (MediaBlockSize-UserEndOffset) bytes from the WriteBuffer begining
       UserStartOffset bytes into the WriteBuffer.

    This process allows a write to be submitted from the WriteBuffer inserting an
    arbitrary number of bytes from the user buffer at any point.  In the process
    the MRB state machine becomes more independent of the disk.cpp layer.  The
    new code should be ever scalable to larger and larger media block sizes.

--*/

//*****************************************************************************
// I N C L U D E S
//*****************************************************************************
#include "mu.h"

//*****************************************************************************
// Local Functions
//*****************************************************************************
DEFINE_USB_DEBUG_FUNCTIONS("MU");
VOID
FASTCALL
MU_fCbwTransfer(
    IN PMU_DEVICE_EXTENSION DeviceExtension
    );

VOID
MU_CbwCompletion (
    IN PURB   Urb,
    IN PVOID  Context
    );

VOID
FASTCALL
MU_fDataTransfer (
    PURB Urb,
    PMU_DEVICE_EXTENSION DeviceExtension
    );

VOID
MU_DataCompletion (
    IN PURB  Urb,
    IN PVOID Context
    );

VOID
FASTCALL
MU_fCswTransfer (
    IN PMU_DEVICE_EXTENSION DeviceExtension
    );

VOID
MU_CswCompletion (
    IN PURB            Urb,
    IN PVOID           Context
    );

//
//  MU_MrbTimeout is local, but declared also in mu.h, because
//  mu.cpp sets up the DPC at init time.
//

VOID
MU_MrbTimeout (
    IN PKDPC Dpc,
    IN PVOID Context,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

VOID
FASTCALL
MU_fMrbErrorHandler(
    IN PMU_DEVICE_EXTENSION DeviceExtension,
    IN NTSTATUS Status
    );


VOID
MU_ResetDeviceCompletionRoutine (
    IN PURB             Urb,
    IN PVOID            Context
    );

#if DBG
VOID
FASTCALL
MU_fValidateMrb(
    IN PMU_DEVICE_EXTENSION DeviceExtension
    );
#define MU_DBG_VALIDATE_MRB(DeviceExtension) MU_fValidateMrb(DeviceExtension)
#else
#define MU_DBG_VALIDATE_MRB(DeviceExtension)
#endif

//*****************************************************************************
// Implementation
//*****************************************************************************

VOID
FASTCALL
MU_fStartMrb(
    IN PMU_DEVICE_EXTENSION DeviceExtension
    )
/*++

    Routine Description:
        Entry point for the MRB state machine.
            
        Does some sanity checks in debug, makes
        sure the device is still connected,
        and calls MU_fCbwTransfer - the first
        phase of any request.

--*/
{
    KIRQL oldIrql;

    USB_DBG_ENTRY_PRINT(("MU_fStartMrb(0x%0.8x)", DeviceExtension));

    //
    //  In Debug perform some simple tests
    //  to make sure that the MRB is well formed.
    //

    MU_DBG_VALIDATE_MRB(DeviceExtension);

    

    //
    //  Raise Irql to synchronize with removal
    //

    oldIrql = KeRaiseIrqlToDpcLevel();

    //
    //  Make sure that the device is still there.
    //

    if(TEST_FLAG(DeviceExtension->DeviceFlags, DF_PENDING_REMOVE|DF_REMOVED))
    {
        //
        //  Call the callback with a failure.
        //
        USB_DBG_TRACE_PRINT(("Mrb.CompletionRoutine(0x%0.8x, STATUS_DEVICE_NOT_CONNECTED)", DeviceExtension));
        DeviceExtension->Mrb.CompletionRoutine(DeviceExtension, STATUS_DEVICE_NOT_CONNECTED);
    } else
    {
        //
        //  Send the CBW
        //

        ASSERT(!TEST_FLAG(DeviceExtension->DeviceFlags, DF_ANY_URB_PENDING|DF_RESET_STEPS));
        MU_fCbwTransfer(DeviceExtension);
    }
    KeLowerIrql(oldIrql);
    return;
}

VOID
FASTCALL
MU_fCbwTransfer(
    IN PMU_DEVICE_EXTENSION DeviceExtension
    )
/*++
    Routine Description:
         Builds an URB for the CBW phase and send it.
--*/
{

    PMU_REQUEST_BLOCK       mrb;
    PCBW                    cbw;
    LARGE_INTEGER           deltaTime;

    USB_DBG_ENTRY_PRINT(("MU_CbwTransfer(DeviceExtension=0x%0.8x)", DeviceExtension));

    //
    // Get the mrb
    //

    mrb = &DeviceExtension->Mrb;

    //
    // Initialize the Command Block Wrapper
    //

    cbw = &DeviceExtension->Mrb.Cbw;
    cbw->dCBWSignature = CBW_SIGNATURE;
    cbw->dCBWTag = PtrToUlong(DeviceExtension->PendingIrp);
    cbw->dCBWDataTransferLength = mrb->TransferLength;
    cbw->bCBWFlags = (UCHAR)((mrb->Flags & MRB_FLAGS_DATA_IN) ? CBW_FLAGS_DATA_IN : CBW_FLAGS_DATA_OUT);
    cbw->bCBWLUN = 0; // Xbox supports only signle LUN
    cbw->bCDBLength = 10;  //Xbox supports on 10 byte cdb's

    //
    //  The caller filled out the CDB in the CBW
    //

    //
    // start the request timer
    //
    SET_FLAG(DeviceExtension->DeviceFlags, DF_MRB_TIMER_RUNNING);
    deltaTime.QuadPart = MRB_STANDARD_TIMEOUT * MRB_TIMEOUT_UNIT;
    KeSetTimer(&DeviceExtension->Mrb.Timer, deltaTime, &DeviceExtension->Mrb.TimeoutDpcObject);
    
    
    //
    //  Build and submit an URB for the CBW
    //
    SET_FLAG(DeviceExtension->DeviceFlags, DF_PRIMARY_URB_PENDING);
    USB_BUILD_BULK_OR_INTERRUPT_TRANSFER(
        &DeviceExtension->Urb.BulkOrInterruptTransfer,
        DeviceExtension->BulkOutEndpointHandle,
        cbw,
        sizeof(CBW),
        USB_TRANSFER_DIRECTION_OUT,
        MU_CbwCompletion,
        DeviceExtension,
        FALSE //short transfer is an error
        );

    //
    //  Don't worry about errors the completion
    //  routine will handle them.
    //
    ASSERT(DeviceExtension->MuInstance);
    DeviceExtension->MuInstance->Device->SubmitRequest(&DeviceExtension->Urb);

    USB_DBG_EXIT_PRINT(("MU_CbwTransfer returning"));

    return;
}

VOID
MU_CbwCompletion (
    IN PURB            Urb,
    IN PVOID           Context
    )
/*
    Routine Description:
        Completion routine for MU_fStartMrb.
        
        If any type of error occured (including a timeout) call MU_HandleBulkError()
        to handle it, and exit.

        On success, if a data phase is required start it, otherwise call MU_fCswTransfer.
*/
{
    PMU_DEVICE_EXTENSION    deviceExtension;
    PMU_REQUEST_BLOCK       mrb;

    USB_DBG_ENTRY_PRINT(("MU_CbwCompletion(Urb=0x%0.8x,Context=0x%0.8x)", Urb, Context));

    deviceExtension = (PMU_DEVICE_EXTENSION) Context;
    ASSERT(Urb == &deviceExtension->Urb);

    //
    //  If the URB failed (which includes being cancelled by the timer DPC) 
    //  call the error handling code.
    //

    if(USBD_ERROR(Urb->Header.Status) || 
       TEST_FLAG(deviceExtension->DeviceFlags, DF_REMOVED|DF_PENDING_REMOVE)
    )
    {
        USB_DBG_WARN_PRINT(("CBW transfer failed, usbdStatus=0x%0.8x", Urb->Header.Status));
        CLEAR_FLAG(deviceExtension->DeviceFlags, DF_PRIMARY_URB_PENDING);
        MU_fMrbErrorHandler(deviceExtension, IUsbDevice::NtStatusFromUsbdStatus(Urb->Header.Status));
        return;
    }
    
    mrb = &deviceExtension->Mrb;
    
    // The CBW Bulk Transfer was successful.  Start the next phase, either
    // the Data Bulk Transfer or CSW Bulk Transfer, and do not complete the
    // request yet.
    //

    if(mrb->DataBuffer)
    {

        ASSERT(mrb->TransferLength != 0);
        mrb->BytesSubmitted = 0;
        
        //
        // Start the first URB
        //
        
        ASSERT(TEST_FLAG(deviceExtension->DeviceFlags, DF_PRIMARY_URB_PENDING));
        MU_fDataTransfer(&deviceExtension->Urb, deviceExtension);
        
        //
        //  If there is more data, start up with the second URB
        //
        
        if(mrb->BytesSubmitted < mrb->TransferLength)
        {
            SET_FLAG(deviceExtension->DeviceFlags, DF_SECONDARY_URB_PENDING);
            MU_fDataTransfer((PURB)&deviceExtension->BulkUrbSecondary, deviceExtension);
        }

    } else
    {
        ASSERT(0 == mrb->TransferLength);
        MU_fCswTransfer(deviceExtension);
    }

    USB_DBG_EXIT_PRINT(("MU_CbwCompletion returning"));
    return;
}

VOID
FASTCALL
MU_fDataTransfer (
    PURB Urb,
    PMU_DEVICE_EXTENSION DeviceExtension
    )
/*
    Routine Description:
        Submit URB for the data stage of the MRB
        stage machine.  It uses the URB passed to it.

        Since USB guarantees that multiple requests
        on the same endpoint will complete in sequence
        we can just keep alternating them until the
        whole transfer buffer is sent.
*/
{
    PMU_REQUEST_BLOCK  mrb;
    PVOID              endpointHandle;
    PVOID              transferBuffer;
    ULONG              transferLength;
    UCHAR              direction;
    
    USB_DBG_ENTRY_PRINT(("MU_DataTransfer(Urb=0x%0.8x,DeviceExtension=0x%0.8x)", Urb, DeviceExtension));

    
    mrb = &DeviceExtension->Mrb;
    
    //
    // Bulk IN or Bulk OUT?
    //

    if ((mrb->Flags & MRB_FLAGS_UNSPECIFIED_DIRECTION) == MRB_FLAGS_DATA_IN)
    {
        endpointHandle = DeviceExtension->BulkInEndpointHandle;
        direction = USB_TRANSFER_DIRECTION_IN;
    } else {
        ASSERT((mrb->Flags & MRB_FLAGS_UNSPECIFIED_DIRECTION) == MRB_FLAGS_DATA_OUT);
        endpointHandle = DeviceExtension->BulkOutEndpointHandle;
        direction = USB_TRANSFER_DIRECTION_OUT;
    }

    //**
    //**  Calculate the transfer buffer for this URB
    //**
    if(TEST_FLAG(mrb->Flags,MRB_FLAGS_SPLIT_WRITE))
    //
    //  MRB_FLAGS_SPLIT_WRITE has three stages, handle
    //  the correct one.
    {
        ASSERT(USB_TRANSFER_DIRECTION_OUT == direction);
        if (mrb->BytesSubmitted < mrb->UserStartOffset)
        //
        //  First stage - from beginning of WriteBuffer
        //
        {
            transferBuffer = MU_DriverExtension.WriteBuffer + mrb->BytesSubmitted;

        } else if(mrb->BytesSubmitted < mrb->UserEndOffset)
        //
        //  Second stage - from User's buffer
        //
        {
            transferBuffer = mrb->DataBuffer + (mrb->BytesSubmitted - mrb->UserStartOffset);

        } else
        //
        //  Third stage - from end of WriteBuffer
        //
        {
            transferBuffer = MU_DriverExtension.WriteBuffer + mrb->UserStartOffset + (mrb->BytesSubmitted - mrb->UserEndOffset);
        }
    } else
    //
    //  The MRB_FLAGS_SPLIT_WRITE is NOT set, so just do the simple thing
    //  from the user buffer.
    {
        transferBuffer = mrb->DataBuffer + mrb->BytesSubmitted;
    }
    
    //
    //  Calculate the transfer length
    //

    transferLength = mrb->TransferLength - mrb->BytesSubmitted;
    if(transferLength > MRB_TRANSFER_SIZE)
    {
        transferLength = MRB_TRANSFER_SIZE;
    }
    mrb->BytesSubmitted += transferLength;

    //
    //  Build and submit an URB for the Transfer
    //

    USB_BUILD_BULK_OR_INTERRUPT_TRANSFER(
        &Urb->BulkOrInterruptTransfer,
        endpointHandle,
        transferBuffer,
        transferLength,
        direction,
        MU_DataCompletion,
        DeviceExtension,
        FALSE //short transfer is an error
        );

    //
    //  Extend the timeout.
    //
    LARGE_INTEGER deltaTime;
    deltaTime.QuadPart = MRB_DATA_TIMEOUT * MRB_TIMEOUT_UNIT;
    KeSetTimer(&DeviceExtension->Mrb.Timer, deltaTime, &DeviceExtension->Mrb.TimeoutDpcObject);

    //
    //  Don't worry about errors the completion
    //  routine will handle them.
    //
    ASSERT(DeviceExtension->MuInstance);
    DeviceExtension->MuInstance->Device->SubmitRequest(Urb);

    return;
}

VOID
MU_DataCompletion (
    IN PURB  Urb,
    IN PVOID Context
    )
/*++
    Routine Description:
        This is the completion routine for MU_fDataTransfer.
        
        On an error (from USB), it calls MU_HandleBulkErrors.
        Then it returns.

        If there is more data to submit it loops back to
        MU_fDataTransfer to keep the data moving.

        If there is no more data to submit, it checks to
        see if there is an other URB outstanding.  If there
        are no more URBs outstanding, then it moves on to the
        next stage by calling MU_fTransferCsw.
--*/
{
    PMU_DEVICE_EXTENSION    deviceExtension = (PMU_DEVICE_EXTENSION) Context;
    PMU_REQUEST_BLOCK       mrb;

    mrb = &deviceExtension->Mrb;

    //
    //  Check to see if there is an error pending (from the other URB)
    //

    if(TEST_FLAG(deviceExtension->DeviceFlags,DF_ERROR_PENDING))
    {
        USBD_STATUS usbdStatus;

        
        //
        //  DF_ERROR_PENDING was set only so that we get here,
        //  clear it now.
        //

        CLEAR_FLAG(deviceExtension->DeviceFlags,DF_ERROR_PENDING);

        // Grab the status from the OTHER Urb
        if(Urb == &deviceExtension->Urb)
        {
            usbdStatus = deviceExtension->BulkUrbSecondary.Hdr.Status;
        } else
        {
            usbdStatus = deviceExtension->Urb.Header.Status;
        }
        //
        //  There is definately no URB pending now.
        //  (it is more efficient to clear both flags, than to
        //  figure out which one we need to clear).
        //
        CLEAR_FLAG(deviceExtension->DeviceFlags, DF_PRIMARY_URB_PENDING|DF_SECONDARY_URB_PENDING);
        MU_fMrbErrorHandler(deviceExtension, IUsbDevice::NtStatusFromUsbdStatus(usbdStatus));
        return;
    }

    //
    //  If this URB failed, cancel the other URB, if it is outstanding,
    //  otherwise, start handling the error here.
    //

    if(USBD_ERROR(Urb->Header.Status) ||
       TEST_FLAG(deviceExtension->DeviceFlags, DF_REMOVED|DF_PENDING_REMOVE)
    )
    {
        USB_DBG_WARN_PRINT(("Data transfer failed (USB status)0x%0.8x", Urb->Header.Status));
        
        //
        //  On error, we figure out which URB we are processing and
        //  clear its pending flag.  If the URB is pending we need
        //  to cancel it, and return.
        //
        if(Urb == &deviceExtension->Urb)
        {
            CLEAR_FLAG(deviceExtension->DeviceFlags,DF_PRIMARY_URB_PENDING);
            if(TEST_FLAG(deviceExtension->DeviceFlags,DF_SECONDARY_URB_PENDING))
            {
               ASSERT(deviceExtension->MuInstance);
               SET_FLAG(deviceExtension->DeviceFlags,DF_ERROR_PENDING);
               deviceExtension->MuInstance->Device->CancelRequest((PURB)&deviceExtension->BulkUrbSecondary);
               return;
            }
        } else
        {
            ASSERT(Urb == (PURB)&deviceExtension->BulkUrbSecondary);
            CLEAR_FLAG(deviceExtension->DeviceFlags,DF_SECONDARY_URB_PENDING);
            if(TEST_FLAG(deviceExtension->DeviceFlags,DF_PRIMARY_URB_PENDING))
            {
                ASSERT(deviceExtension->MuInstance);
                SET_FLAG(deviceExtension->DeviceFlags,DF_ERROR_PENDING);
                deviceExtension->MuInstance->Device->CancelRequest(&deviceExtension->Urb);
                return;
            }
        }

        //
        //  If we are here there are no outstanding URBs for this device, so
        //  we can start the error handling.
        //

        MU_fMrbErrorHandler(deviceExtension, IUsbDevice::NtStatusFromUsbdStatus(Urb->Header.Status));
        return;
    }

    //
    //  Ugh, that was a lot of error handling code,
    //  but we want to be robust!
    //
    
    //
    //  If there is more data to submit
    //  then call MU_fDataTransfer,
    //  and return.
    //
    if(mrb->BytesSubmitted < mrb->TransferLength)
    {
        MU_fDataTransfer(Urb, deviceExtension);
        return;
    }

    //
    //  We could just move on to the CSW stage now,
    //  even if the other URB is still pending for
    //  a read or write.  This is acceptable, because
    //  of 3.3 of the Bulk-Only specification.  However,
    //  we do not lose measurable efficiency by only
    //  continuing if there are no more data URB
    //  outstanding.  This method reduces the number
    //  of possible error cases we need to check,
    //  and there are already too many!
    //

    if(Urb == &deviceExtension->Urb)
    {
        CLEAR_FLAG(deviceExtension->DeviceFlags,DF_PRIMARY_URB_PENDING);
        if(TEST_FLAG(deviceExtension->DeviceFlags,DF_SECONDARY_URB_PENDING))
        {
            // Nothing to do, because our twin URB is still pending
            return;
        }
    } else
    {
        ASSERT(Urb == (PURB)&deviceExtension->BulkUrbSecondary);
        CLEAR_FLAG(deviceExtension->DeviceFlags,DF_SECONDARY_URB_PENDING);
        if(TEST_FLAG(deviceExtension->DeviceFlags,DF_PRIMARY_URB_PENDING))
        {
            // Nothing to do, because our twin URB is still pending
            return;
        }
    }

    //
    //  Reset the primary URB flag as MU_fCswTransfer will use it.
    //

    SET_FLAG(deviceExtension->DeviceFlags,DF_PRIMARY_URB_PENDING);
    
    //
    //  The data transfer is over, go on to CSW stage
    //
    MU_fCswTransfer(deviceExtension);

    return;
}

VOID
FASTCALL
MU_fCswTransfer (
    IN PMU_DEVICE_EXTENSION DeviceExtension
    )
/*++
    Routine Description:
        Builds and submits an URB for the CswTransfer.  It is broken
        out as a separate routineas it is called from two places
        (MU_DataCompletion and MU_CbwCompletion).
--*/
{
    USB_DBG_ENTRY_PRINT(("MU_DataTransfer(DeviceExtension=0x%0.8x)",DeviceExtension));

    USB_BUILD_BULK_OR_INTERRUPT_TRANSFER(
        &DeviceExtension->Urb.BulkOrInterruptTransfer,
        DeviceExtension->BulkInEndpointHandle,
        &DeviceExtension->Mrb.Csw,
        sizeof(CSW),
        USB_TRANSFER_DIRECTION_IN,
        MU_CswCompletion,
        DeviceExtension,
        FALSE //short transfer is an error
        );

    //
    //  Extend the timeout for the CSW.
    //
    LARGE_INTEGER deltaTime;
    deltaTime.QuadPart = ((LONGLONG)DeviceExtension->Mrb.TimeOutValue) * MRB_TIMEOUT_UNIT;
    KeSetTimer(&DeviceExtension->Mrb.Timer, deltaTime, &DeviceExtension->Mrb.TimeoutDpcObject);

    //
    //  Submit the URB, the completion routine will worry about errors.
    //
    ASSERT(DeviceExtension->MuInstance);
    DeviceExtension->MuInstance->Device->SubmitRequest(&DeviceExtension->Urb);
    
    USB_DBG_EXIT_PRINT(("MU_CswTransfer returning"));

    return;
}

VOID
MU_CswCompletion (
    IN PURB            Urb,
    IN PVOID           Context
    )
/*++
    Routine Description:
        Completion routine for the CSW transfer.

        Checks for a number of possible error conditions.
        If any are found it calls MU_HandleBulkError.

        Otherwise calls the MRBs completion routine
        with STATUS_SUCCESS.
--*/
{
    PMU_DEVICE_EXTENSION deviceExtension = (PMU_DEVICE_EXTENSION)Context;
    NTSTATUS status = STATUS_SUCCESS;

    USB_DBG_ENTRY_PRINT(("MU_CswCompletion(Urb=0x%0.8x,Context=0x%0.8x)", Urb, Context));

    //
    //  Cancel the timer
    //
    
    if(TEST_FLAG(deviceExtension->DeviceFlags, DF_MRB_TIMER_RUNNING))
    {
        KeCancelTimer(&deviceExtension->Mrb.Timer);
        CLEAR_FLAG(deviceExtension->DeviceFlags, DF_MRB_TIMER_RUNNING);
    }
    CLEAR_FLAG(deviceExtension->DeviceFlags,DF_PRIMARY_URB_PENDING);

    if(USBD_ERROR(Urb->Header.Status))
    {
        // The Data Bulk Transfer was not successful.  Look at how the
        // the transfer failed to figure out how to recover.
        //

        USB_DBG_WARN_PRINT(("CSW transfer failed, usbdStatus=0x%0.8x", Urb->Header.Status));
        status = IUsbDevice::NtStatusFromUsbdStatus(Urb->Header.Status);
    }
    
    //
    //  Check Signature.
    //

    if(deviceExtension->Mrb.Csw.dCSWSignature != CSW_SIGNATURE)
    {
        USB_DBG_WARN_PRINT(("CSW signature incorrect."));
        status = STATUS_UNSUCCESSFUL;
    }

    //
    //  Check Tag
    //
    
    if(deviceExtension->Mrb.Csw.dCSWTag != deviceExtension->Mrb.Cbw.dCBWTag)
    {
        USB_DBG_WARN_PRINT(("CSW tag incorrect, expecting 0x%0.8x, was 0x%0.8x.", 
                                                deviceExtension->Mrb.Cbw.dCBWTag,
                                                deviceExtension->Mrb.Csw.dCSWTag
                                                ));
        status = STATUS_UNSUCCESSFUL;
    }

    //
    //  Check For Phase Error (means missed handshake in the protocol)
    //

    if(deviceExtension->Mrb.Csw.bCSWStatus == CSW_STATUS_PHASE_ERROR)
    {
        USB_DBG_WARN_PRINT(("CSW returned CSW_STATUS_PHASE_ERROR\n"));
        status = STATUS_UNSUCCESSFUL;
    }

    //
    //  Check for failed CSW.  Basically the device had trouble
    //  completing the command.  It could be that we sent an unsupported
    //  command or that we tried to write past the end of the media
    //  or some other error on our part.  OR, THE MEDIA IS BAD.
    //  On a read or write, we ASSUME that this driver did not screw up
    //  and infact a media block has failed!!!  It sucks that we don't
    //  have more specific errors, but we didn't invent the protocol,
    //  we just borrowed it from the USB mass storage committee.
    //

    if(deviceExtension->Mrb.Csw.bCSWStatus == CSW_STATUS_FAILED)
    {
        USB_DBG_WARN_PRINT(("CSW returned CSW_STATUS_FAILED\n"));
        status = STATUS_DATA_ERROR;
    }

    ASSERT(!TEST_FLAG(deviceExtension->DeviceFlags, DF_ANY_URB_PENDING));
     
    //
    //  If any error occurred, call the handle bulk error routine.
    //

    if(NT_ERROR(status))
    {
        MU_fMrbErrorHandler(deviceExtension, status);
        return;
    }
    
    ASSERT(deviceExtension->Mrb.Csw.bCSWStatus == CSW_STATUS_GOOD);

    //
    // Call the MRB completion routine with a success code
    //        
    USB_DBG_TRACE_PRINT(("Mrb.CompletionRoutine(0x%0.8x, STATUS_SUCCESS)", deviceExtension));
    deviceExtension->Mrb.CompletionRoutine(deviceExtension, STATUS_SUCCESS);
    
    USB_DBG_EXIT_PRINT(("MU_CswCompletion returning"));

    return;
}


VOID
MU_MrbTimeout (
    IN PKDPC Dpc,
    IN PVOID Context,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )
/*++
    Routine Description:
        
        This is the DPC routine for the MRB timeout timer.  The timer is set
        before the Cbw is transmitted, and canceled when the bulk-only request
        completes by receiving a Csw, or when error occurs aborting the request.

        The timer is intended to protect against devices that NAK forever.
        Device that are just extremely slow will hit this as well.  This code
        does not protect against software bugs in this driver or lower in the
        USB stack.

        All this routine does is cancel any URBs that are outstanding.  This will break
        the deadlock, and the normal error handling in the state machine will kick in.
        
    Timeout Timing:

        The timer is set at CBW, and extended at each data stage and at CSW.
        The length of the timeout for the data stages and CSW is fixed.  The caller
        in the disk layer can set the timeout for the CBW.  This is to accomodate commands
        like VERIFY that may require very long timeouts on the CBW and they don't have
        a data stage.

--*/
{
    PMU_DEVICE_EXTENSION  deviceExtension = (PMU_DEVICE_EXTENSION) Context;

    USB_DBG_WARN_PRINT(("MRB state machine timed out."));

    CLEAR_FLAG(deviceExtension->DeviceFlags, DF_MRB_TIMER_RUNNING);

    if(TEST_FLAG(deviceExtension->DeviceFlags,DF_PRIMARY_URB_PENDING))
    {
        ASSERT(deviceExtension->MuInstance);
        deviceExtension->MuInstance->Device->CancelRequest(&deviceExtension->Urb);
    }

    if(TEST_FLAG(deviceExtension->DeviceFlags, DF_SECONDARY_URB_PENDING))
    {
        ASSERT(deviceExtension->MuInstance);
        deviceExtension->MuInstance->Device->CancelRequest((PURB)&deviceExtension->BulkUrbSecondary);
    }
}

VOID
FASTCALL
MU_fMrbErrorHandler(
    IN PMU_DEVICE_EXTENSION DeviceExtension,
    IN NTSTATUS Status
    )
/*++
    Routine Description:
        This routine is called whenever a stage of the Mrb state machine detects
        an error (USB failure, device removed, CSW problem, or timeout).  There
        should be no outstanding Urbs when this routine is called.  
        
        If the MRB timer is running, cancel it.

        If the device has been removed, this routine cleans up the Mrb state machine
        and calls the Mrb competion routine with STATUS_DEVICE_NOT_CONNECTED.

        If the device is still present, it kicks of the USB bulk-only reset
        sequence.  This a fairly gentle way to get the bulk-only transport
        protocol back in-sync between the device and this driver.
        
        See the MU_ResetDeviceCompletionRoutine description for details on
        the reset sequence.  This routine performs the first two steps,
        then second of which is asynchronous and completes in
        MU_ResetDeviceCompletionRoutine.
--*/
{
    PMU_INSTANCE muInstance = DeviceExtension->MuInstance;

    //
    //  Stop the Mrb Timer, if it is running
    //

    if(TEST_FLAG(DeviceExtension->DeviceFlags, DF_MRB_TIMER_RUNNING))
    {
        KeCancelTimer(&DeviceExtension->Mrb.Timer);
        CLEAR_FLAG(DeviceExtension->DeviceFlags, DF_MRB_TIMER_RUNNING);
    }

    //
    //  There should be no URB's pending when this routine is hit.
    //

    ASSERT(!TEST_FLAG(DeviceExtension->DeviceFlags, DF_ANY_URB_PENDING));
    
    //
    //  Check if the device has been removed
    //

    if(TEST_FLAG(DeviceExtension->DeviceFlags, DF_REMOVED|DF_PENDING_REMOVE))
    {
        USB_DBG_TRACE_PRINT(("Mrb.CompletionRoutine(0x%0.8x, STATUS_DEVICE_NOT_CONNECTED)", DeviceExtension));
        DeviceExtension->Mrb.CompletionRoutine(DeviceExtension, STATUS_DEVICE_NOT_CONNECTED);
        return;
    }

    ASSERT(muInstance);

    //**
    //**  Start the reset sequence,
    //**
    
    USB_DBG_TRACE_PRINT(("Initiating Bulk-Only reset sequence."));
    
    SET_FLAG(DeviceExtension->DeviceFlags, DF_RESET_STEP1);

    //
    //  stored the failed status, so that we still have it 
    //  after a reset.  Note this field is a union with 
    //  BytesSubmitted so it is not valid if we resubmit the MRB.
    //
    DeviceExtension->Mrb.FailedStatus = Status;

    //
    //  Clear the data toggle and software halt flag.  This is a
    //  synchronous USB request and should never fail.
    //

    USB_BUILD_SET_ENDPOINT_STATE(
            &DeviceExtension->Urb.GetSetEndpointState,
            DeviceExtension->BulkInEndpointHandle,
            USB_ENDPOINT_STATE_DATA_TOGGLE_RESET | USB_ENDPOINT_STATE_CLEAR_HALT
            );
    if(USBD_ERROR(muInstance->Device->SubmitRequest(&DeviceExtension->Urb)))
    {
        USB_DBG_WARN_PRINT(("MU_ResetDeviceDpc: Bulk-IN SetEndpointStatus failed!\n"));
        ASSERT(FALSE);
    }

    //
    //  Set the MRB timer to time the reset.
    //
    LARGE_INTEGER deltaTime;
    deltaTime.QuadPart = MRB_RESET_TIMEOUT*MRB_TIMEOUT_UNIT;
    SET_FLAG(DeviceExtension->DeviceFlags, DF_MRB_TIMER_RUNNING);
    SET_FLAG(DeviceExtension->DeviceFlags,DF_PRIMARY_URB_PENDING);
    KeSetTimer(&DeviceExtension->Mrb.Timer, deltaTime, &DeviceExtension->Mrb.TimeoutDpcObject);

    //
    // now send CLEAR_FEATURE(ENDPOINT_STALL) for the IN endpoint
    //

    USB_BUILD_CLEAR_FEATURE(
            &DeviceExtension->Urb.ControlTransfer,
            USB_COMMAND_TO_ENDPOINT,
            USB_FEATURE_ENDPOINT_STALL,
            muInstance->BulkInEndpointAddress,
            (PURB_COMPLETE_PROC)MU_ResetDeviceCompletionRoutine,
            DeviceExtension
            );

    //
    //  The completion routine deal with errors.
    //
    muInstance->Device->SubmitRequest(&DeviceExtension->Urb);
}

VOID
MU_ResetDeviceCompletionRoutine (
    IN PURB             Urb,
    IN PVOID            Context
    )
/*++
    Routine Description:
        
        This routine is the heart of the USB Bulk-Only Mass Storage Reset Sequence.
        The reset sequence consists of:
            1) Clear the STALL on the Bulk-IN endpoint.
            2) Clear the STALL on the Bulk-OUT endpoint.
            3) Send the the BULK_ONLY_MASS_STORAGE_RESET command on the control pipe.

        Clearing a STALL is a two step process on Xbox, first you send a 
        SET_ENDPOINT_STATE Urb to clear the endpoint HALT bit, and to reset the
        data toggle.  Then you send a CLEAR_FEATURE(ENDPOINT_STALL) over the 
        control endpoint to the device, so it clears its STALL bit.

        Step 1) was initiated by MU_fMrbErrorHandler.  So this routine verifies
        that that succeeded.

        Steps 2) and 3) are both asynchronous.  So this routine is a multistage
        state machine.  DeviceFlags are used to keep track of the stage.

        Any failure during the reset sequence, results in reporting the device as
        not responding to the core USB stack, if MU_Remove has not been called in
        the interm.  The core USB stack will drop the device (notifying everyone
        it is gone), and then reenumerate.  This procedure is not gentle!

        At the end of the reset sequence the retry count of the MRB is decremented
        and checked, if there are still retries remaining, then MU_fCbwTransfer is
        called to restart the Mrb.

        Otherwise, the MRB completion routine is called with STATUS_UNSUCCESSFUL.
        Unfortunately, the original error (timeout, or transmission failure)
        has not been propogated.
--*/
{
    PMU_DEVICE_EXTENSION deviceExtension = (PMU_DEVICE_EXTENSION) Context;
    ULONG                resetStage = deviceExtension->DeviceFlags & DF_RESET_STEPS;
    PMU_INSTANCE         muInstance = deviceExtension->MuInstance;

    //
    //  Mark that the primary URB is not outstanding
    //
    CLEAR_FLAG(deviceExtension->DeviceFlags,DF_PRIMARY_URB_PENDING);

    //
    //  Stop the MRB timer if it is running
    //
    if(TEST_FLAG(deviceExtension->DeviceFlags, DF_MRB_TIMER_RUNNING))
    {
        KeCancelTimer(&deviceExtension->Mrb.Timer);
        CLEAR_FLAG(deviceExtension->DeviceFlags, DF_MRB_TIMER_RUNNING);
    }

    //
    //  Check for device not connected.
    //
    if(TEST_FLAG(deviceExtension->DeviceFlags, DF_REMOVED|DF_PENDING_REMOVE))
    {
        USB_DBG_TRACE_PRINT(("Mrb.CompletionRoutine(0x%0.8x, STATUS_DEVICE_NOT_CONNECTED)", deviceExtension));
        deviceExtension->Mrb.CompletionRoutine(deviceExtension, STATUS_DEVICE_NOT_CONNECTED);
        return;
    }

    ASSERT(muInstance);

    //
    //  Check for USB errors
    //

    if(USBD_ERROR(Urb->Header.Status))
    {
        
        USB_DBG_WARN_PRINT(("Reset Sequence Failed, reporting device as not responding."));
        
        //
        //  Clear all the reset flags, reset is over, wherever it was
        //  
        CLEAR_FLAG(deviceExtension->DeviceFlags, DF_RESET_STEPS);

        //
        //  Report the device as not responding
        //
        muInstance->Device->DeviceNotResponding();
        
        //
        //  Fail the MRB as STATUS_DEVICE_NOT_CONNECTED
        //
        USB_DBG_TRACE_PRINT(("Mrb.CompletionRoutine(0x%0.8x, STATUS_DEVICE_NOT_CONNECTED)", deviceExtension));
        deviceExtension->Mrb.CompletionRoutine(deviceExtension, STATUS_DEVICE_NOT_CONNECTED);

        return;
    }

    //
    //  Move on to the next stage of the Reset sequence.
    //  (note that we are switching on the resetStage 
    //  of the just completed stage.)
    //

    switch(resetStage)
    {
        case DF_RESET_STEP1:
            
            //
            //  Switch the flag to indicate step2
            //

            CLEAR_FLAG(deviceExtension->DeviceFlags, DF_RESET_STEP1);
            SET_FLAG(deviceExtension->DeviceFlags, DF_RESET_STEP2);

            //
            //  Clear the data toggle and software halt flag for Bulk-OUT
            //  This is a synchronous USB request and should never fail.
            //

            USB_BUILD_SET_ENDPOINT_STATE(
                    &deviceExtension->Urb.GetSetEndpointState,
                    deviceExtension->BulkOutEndpointHandle,
                    USB_ENDPOINT_STATE_DATA_TOGGLE_RESET | USB_ENDPOINT_STATE_CLEAR_HALT
                    );

            if(USBD_ERROR(muInstance->Device->SubmitRequest(&deviceExtension->Urb)))
            {
                USB_DBG_WARN_PRINT(("MU_ResetDeviceDpc: Bulk-OUT SetEndpointStatus failed!"));
                ASSERT(FALSE);
            }

            //
            // Build CLEAR_FEATURE(ENDPOINT_STALL) for the OUT endpoint
            // (it will get sent at the end of this routine.)

            USB_BUILD_CLEAR_FEATURE(
                    &deviceExtension->Urb.ControlTransfer,
                    USB_COMMAND_TO_ENDPOINT,
                    USB_FEATURE_ENDPOINT_STALL,
                    muInstance->BulkOutEndpointAddress,
                    (PURB_COMPLETE_PROC)MU_ResetDeviceCompletionRoutine,
                    deviceExtension
                    );

            break;
        case DF_RESET_STEP2:
            
            //
            //  Switch the flag to indicate step2
            //
            
            CLEAR_FLAG(deviceExtension->DeviceFlags, DF_RESET_STEP2);
            SET_FLAG(deviceExtension->DeviceFlags, DF_RESET_STEP3);

            //
            // Build the BULK_ONLY_MASS_STORAGE_RESET command
            // (it will get sent at the end of this routine.)

            USB_BUILD_CONTROL_TRANSFER(
                &deviceExtension->Urb.ControlTransfer,
                NULL,
                NULL, 
                0,
                USB_TRANSFER_DIRECTION_OUT,
                MU_ResetDeviceCompletionRoutine,
                deviceExtension,
                FALSE,
                (USB_HOST_TO_DEVICE | USB_CLASS_COMMAND | USB_COMMAND_TO_INTERFACE),
                BULK_ONLY_MASS_STORAGE_RESET,
                0,
                muInstance->InterfaceNumber,
                0);

            break;
        case DF_RESET_STEP3:
            
            //
            //  Clear DF_RESET_STEP3, the reset sequence is over.
            //

            CLEAR_FLAG(deviceExtension->DeviceFlags, DF_RESET_STEP3);

            //
            //  Check for retries.
            //
            //  retries = (total tries) - 1, so post decrement
            //  when checking.
            //

            if(deviceExtension->Mrb.Retries--)
            {
               //
               //   If we resubmit the Mrb we need to pet the
               //   watchdog, it wasn't intended to wait through
               //   lots of retries.
               //
               MU_DEBUG_PET_WATCHDOG(deviceExtension);
               //
               //   Resubmit the Mrb
               //
               MU_fCbwTransfer(deviceExtension);
            } else
            {
               //
               //   Fail with status unsuccessful
               //
               USB_DBG_TRACE_PRINT(("Mrb.CompletionRoutine(0x%0.8x, STATUS_UNSUCCESSFUL)", deviceExtension));
               deviceExtension->Mrb.CompletionRoutine(deviceExtension, deviceExtension->Mrb.FailedStatus);
            }

            return;

        default:
            USB_DBG_ERROR_PRINT(("Reaching here indicates an MU driver bug!"));
            return;
    }

    //
    //  Set the MRB timer to time the reset.
    //
    LARGE_INTEGER deltaTime;
    deltaTime.QuadPart = MRB_RESET_TIMEOUT*MRB_TIMEOUT_UNIT;
    SET_FLAG(deviceExtension->DeviceFlags,DF_PRIMARY_URB_PENDING);
    SET_FLAG(deviceExtension->DeviceFlags, DF_MRB_TIMER_RUNNING);
    KeSetTimer(&deviceExtension->Mrb.Timer, deltaTime, &deviceExtension->Mrb.TimeoutDpcObject);

    //
    //  Submit the URB built in either case DF_RESET_STEP1, 
    //  or case DF_RESET_STEP2.
    //
    SET_FLAG(deviceExtension->DeviceFlags,DF_PRIMARY_URB_PENDING);
    muInstance->Device->SubmitRequest(&deviceExtension->Urb);
    
    return;
}


#if DBG
VOID
FASTCALL
MU_fValidateMrb(
    IN PMU_DEVICE_EXTENSION DeviceExtension
    )
/*++
    Routine Description:
        Debug Only routine that validates the current mrb.  All this
        routine does is spew errors or possible errors, otherwise
        it does not effect the operation of the driver.
      
--*/
{
    //
    //  1) If no direction flag is set, then the DataBuffer
    //     and TransferLength are NULL, and 0.
    //
    if(!TEST_FLAG(DeviceExtension->Mrb.Flags, MRB_FLAGS_UNSPECIFIED_DIRECTION))
    {
        if(DeviceExtension->Mrb.DataBuffer || DeviceExtension->Mrb.TransferLength)
        {
            USB_DBG_ERROR_PRINT(("No direction, but non-NULL DataBuffer or non-zero length"));
        }
    }
        
    //
    //  2) Only one direction flag is set.
    //
    if(TEST_ALL_FLAGS(DeviceExtension->Mrb.Flags, MRB_FLAGS_UNSPECIFIED_DIRECTION))
    {
        USB_DBG_ERROR_PRINT(("More than one direction flag is set in Mrb!"));
    }
    //
    //  3) If a direction flag is that the DataBuffer is non-NULL
    //     and that the size is finite.
    //
    if(TEST_FLAG(DeviceExtension->Mrb.Flags, MRB_FLAGS_UNSPECIFIED_DIRECTION))
    {
        if(NULL == DeviceExtension->Mrb.DataBuffer)
        {
            USB_DBG_ERROR_PRINT(("Mrb with transfer to\from NULL DataBuffer!"));
        }
        if(0 == DeviceExtension->Mrb.TransferLength)
        {
            USB_DBG_ERROR_PRINT(("Mrb with transfer of 0 length!"));
        }
    }

    return;
}

#endif //DBG
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\dd\usb\mutest\mutest.h ===
// Hack! DbgPrint is much nicer than OutputDebugString so JonT exported it from xapi.lib
// (as DebugPrint) but the prototype isn't in the public headers...
extern "C"
{
	ULONG
	DebugPrint(
		PCHAR Format,
		...
		);
}

VOID
LowLevelTest(
          ULONG Port,
          ULONG Slot
          );
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\dd\usb\netsim\client\makefile.inc ===
$(XDK_LIB_PATH)\$(TARGETNAME).lib: $(SDK_LIB_PATH)\$(TARGETNAME).lib
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\dd\usb\mutest\lowlvl.cpp ===
/*++

Copyright (c) 1996-2000 Microsoft Corporation

Module Name:

    MUTEST.CPP

Abstract:

    This source file contains a simple test code for the MU

Environment:

    kernel mode

Revision History:

--*/

//*****************************************************************************
// I N C L U D E S
//*****************************************************************************

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntdddisk.h>
#include <stdio.h>
#include <xtl.h>
extern "C" {
#include <ntos.h>
#include <xapip.h>  //private XAPI methods for low-level tests
}

#include <mutest.h>
#include <stdio.h>

//
// to test the double buffering code on the 8k fw restricted writes
// play with the two values below
// I tested (A=8k aligned, NA=non aligned)
// a) offset=A, length=N, 4k
// b) offset=NA,length=A, 8k
// c) offset=A, length=N, 12k
// d) offset=NA,length=N, 12k
// f) offset=NA,length=N, 4k
// g) offset=NA,length=A, 16k

#define WRITE_SIZE       (4096*256)   //1MB write size
#define TEST_BUFFER_SIZE (4096*32)    //128KB
#define TRANSFER_SIZE    4096
#define MU_MEDIA_OFFSET  4096*8

#define EXTRA_SIZE 4096
#define SECTOR_MASK 0xFFFFFF000

VOID
LowLevelTest(
          ULONG Port,
          ULONG Slot
          )
{
	
	ULONG					tryCount = 0;
    OCHAR                   name[64];
    HRESULT                 hr;
    HANDLE                  hFile;
    PUCHAR buffer,buffer2;
    UCHAR pattern[4] = {1,2,3,4};
    ULONG i;
    HANDLE hVolume;
    OBJECT_ATTRIBUTES oa;
    IO_STATUS_BLOCK statusBlock;
    DISK_GEOMETRY diskGeometry;
    OCHAR oszDeviceObjectBuffer[64];
    OBJECT_STRING objName;
    NTSTATUS status;
    ULONG   totalErrorCount = 0;
    ULONG   localErrorCount = 0;
    ULONGLONG bytesPerSecond = 0;
    

    //
    //  Create a device object for the MU
    //
    objName.Length = 
    objName.MaximumLength = sizeof(oszDeviceObjectBuffer)-1;
    objName.Buffer = oszDeviceObjectBuffer;
    status = MU_CreateDeviceObject(Port, Slot, &objName);
    if(NT_ERROR(status))
    {
        DebugPrint("Could not create device object for MU, status = 0x%0.8x");
        return;
    }

    buffer =  (PUCHAR) LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, TEST_BUFFER_SIZE+EXTRA_SIZE);
    buffer2 =  (PUCHAR) LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, TEST_BUFFER_SIZE+EXTRA_SIZE);

    //
    // sector align buffers
    //

    buffer = (PUCHAR)((ULONG) buffer & SECTOR_MASK);
    buffer += EXTRA_SIZE;

    buffer2 = (PUCHAR)((ULONG) buffer2 & SECTOR_MASK);
    buffer2 += EXTRA_SIZE;

    //
    // fill the buffer with a pattern
    //

    for (i=0;i<TEST_BUFFER_SIZE/sizeof(ULONG);i++) {

        *((PULONG)buffer+i) = i;

    }

    DebugPrint("MUTEST: LowLevelTest: Test buffer 1 at %x, 2 at %x\n",buffer,buffer2);

    InitializeObjectAttributes(&oa, (POBJECT_STRING) &objName, OBJ_CASE_INSENSITIVE, NULL, NULL);

    DebugPrint("MUTEST: LowLevelTest: Opening volume \n");

    status = NtOpenFile(&hVolume,
                        SYNCHRONIZE | GENERIC_ALL,
                        &oa,
                        &statusBlock,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        FILE_NO_INTERMEDIATE_BUFFERING | FILE_SYNCHRONOUS_IO_ALERT);

    if (NT_SUCCESS(status)) {

        status = NtDeviceIoControlFile(hVolume,
                                       0,
                                       NULL,
                                       NULL,
                                       &statusBlock,
                                       IOCTL_DISK_GET_DRIVE_GEOMETRY,
                                       NULL,
                                       0,
                                       &diskGeometry,
                                       sizeof(diskGeometry));

        if (NT_SUCCESS(status)) {
            PARTITION_INFORMATION pi;
            ULONG ulSectorSize = diskGeometry.BytesPerSector;
            ULONG ulSectorsPerTrack = diskGeometry.SectorsPerTrack;
            ULONG ulHeads = diskGeometry.TracksPerCylinder;
            ULONG ulTotalSectorCount = (RtlExtendedIntegerMultiply(
                                        diskGeometry.Cylinders,
                                        diskGeometry.SectorsPerTrack *
                                            diskGeometry.TracksPerCylinder)).LowPart;

            DebugPrint("MUTEST: SectorSize %x, SectorCount %x\n",
                       ulSectorSize,
                       ulTotalSectorCount);
                                            
            status = NtDeviceIoControlFile(hVolume,
                                           0,
                                           NULL,
                                           NULL,
                                           &statusBlock,
                                           IOCTL_DISK_GET_PARTITION_INFO,
                                           NULL,
                                           0,
                                           &pi,
                                           sizeof(pi));
                                                      
            if ((NT_SUCCESS(status) && pi.RecognizedPartition) ||
                (status == STATUS_NOT_SUPPORTED)) {

                LARGE_INTEGER offset;
                LARGE_INTEGER start, end;
                LARGE_INTEGER freq;
                
                offset.QuadPart = MU_MEDIA_OFFSET;
                freq = KeQueryPerformanceFrequency();
                start = KeQueryPerformanceCounter();
                
                DebugPrint("MUTEST: Writing complete test pattern to offset %x, iterations %x, write length %x\n",
                           offset.LowPart,
                           WRITE_SIZE/TEST_BUFFER_SIZE,
                           TEST_BUFFER_SIZE);

                

                for (i=0;i<WRITE_SIZE/TEST_BUFFER_SIZE;i++) {

                    //DebugPrint("MUTEST: current offset %x\n",
                    //       offset.LowPart);

                    status = NtWriteFile(hVolume,
                                         0,
                                         NULL,
                                         NULL,
                                         &statusBlock,
                                         buffer,
                                         TEST_BUFFER_SIZE,
                                         &offset
                                         );
                    offset.QuadPart += TEST_BUFFER_SIZE;
                    if(NT_ERROR(status)) localErrorCount++;
                }

                end = KeQueryPerformanceCounter();
                end.QuadPart -= start.QuadPart;                

                if(localErrorCount)
                {
                    DebugPrint("MUTEST: %d write errors occured.\n", localErrorCount);
                    totalErrorCount += localErrorCount;
                }
                
                //
                //  Calculate bytes per second.
                //
                bytesPerSecond = (WRITE_SIZE * freq.QuadPart)/end.QuadPart;
                DebugPrint("MUTEST: data rate writing %d bytes was %d bytes per second.\n", WRITE_SIZE, (ULONG)bytesPerSecond);
                
                

                ///////////////////////////////////////////////////////////////
                //
                // READ perf test
                //
                ///////////////////////////////////////////////////////////////

                offset.QuadPart = MU_MEDIA_OFFSET;
                localErrorCount = 0;
                start = KeQueryPerformanceCounter();
                
                DebugPrint("MUTEST: Reading complete test pattern to offset %x, iterations %x, write length %x\n",
                           offset.LowPart,
                           WRITE_SIZE/TEST_BUFFER_SIZE,
                           TEST_BUFFER_SIZE);

                for (i=0;i<WRITE_SIZE/TEST_BUFFER_SIZE;i++) {

                    //DebugPrint("MUTEST: current offset %x\n",
                    //       offset.LowPart);

                    status = NtReadFile(hVolume,
                                         0,
                                         NULL,
                                         NULL,
                                         &statusBlock,
                                         buffer2,
                                         TEST_BUFFER_SIZE,
                                         &offset
                                         );
                    offset.QuadPart += TEST_BUFFER_SIZE;
                    if(NT_ERROR(status)) localErrorCount++;
                }

                end = KeQueryPerformanceCounter();
                end.QuadPart -= start.QuadPart;                

                if(localErrorCount)
                {
                    DebugPrint("MUTEST: %d read errors occured.\n", localErrorCount);
                    totalErrorCount += localErrorCount;
                }
                
                //
                //  Calculate bytes per second.
                //
                bytesPerSecond = (WRITE_SIZE * freq.QuadPart)/end.QuadPart;
                DebugPrint("MUTEST: data rate reading %d bytes was %d bytes per second.\n", WRITE_SIZE, (ULONG)bytesPerSecond);

                ///////////////////////////////////////////////////////////////
                //
                // check loop back for errors
                //
                ///////////////////////////////////////////////////////////////
                
                localErrorCount = TEST_BUFFER_SIZE - RtlCompareMemory(buffer, buffer2, TEST_BUFFER_SIZE);
                if(0==localErrorCount)
                {
                  DebugPrint("MUTEST: data read back matched what was written.\n");
                } else
                {
                    DebugPrint("MUTEST: There were %d errors in the read back.\n", localErrorCount);
                    totalErrorCount += localErrorCount;
                    DebugPrint("MUTEST: Offset: Written,  Read\n", i, buffer[i], buffer2[i]);
                    int errorCount = 0;
                    for(int i=0; i<TEST_BUFFER_SIZE; i++)
                    {
                        if(buffer[i]!=buffer2[i])
                        {
                            errorCount++;
                            if(errorCount < 5)
                            {
                                DebugPrint("MUTEST: 0x%0.4x:   0x%0.2x,  0x%0.2x\n", i, (ULONG)buffer[i], (ULONG)buffer2[i]);
                            } else
                            {
                                break;
                            }
                        }
                    }
                    _asm int 3;
                }


                ///////////////////////////////////////////////////////////////
                //
                // alignment fault check.
                //
                //  Test on 4k, 8k, 12k and 16k writes.  Induce alignment faults by
                //  repeating each write at three times changing the offset by
                //  4k each time.  
                //  
                //  Test by wiping the read back buffer, and reading the entire
                //  MU contents.  These should match the cached buffer with
                //  what ever changes were made to the pattern in the portion
                //  written.
                //
                ///////////////////////////////////////////////////////////////

                offset.QuadPart = MU_MEDIA_OFFSET;

                
                //
                //  Loop over write size
                //
                ULONG writeOffset = 0;
                for(ULONG writeLength = 0x1000; writeLength <= 0x4000; writeLength += 0x1000)
                {
                    //
                    //  repeat each length with three different offsets.
                    //  never reset the offset to 0, just keep incrementing by 4k
                    for(ULONG offsetRepeat = 0; offsetRepeat < 3; offsetRepeat++, writeOffset += 0x1000)
                    {
                        DebugPrint("MUTEST: Alignment Test: writeOffset = 0x%0.8x, writeLength = 0x%0.8x", writeOffset, writeLength);
                        //
                        //  fill write buffer with test pattern
                        //
                        
                        for(i=0; i < writeLength; i+=4)
                        {
                            *((PULONG)(buffer+i+writeOffset)) = writeLength-i;
                        }
                        
                        //
                        //  Setup offset, we bias the offset to try to avoid
                        //  corrupting a formatted MU.
                        //

                        offset.QuadPart = MU_MEDIA_OFFSET + writeOffset;

                        //
                        //  Execute write
                        //
                        status = NtWriteFile(hVolume,
                                         0,
                                         NULL,
                                         NULL,
                                         &statusBlock,
                                         buffer + writeOffset,
                                         writeLength,
                                         &offset
                                         );

                        if (!NT_SUCCESS(status)) {
                            DebugPrint("\nMUTEST: Write failed with status 0x%0.8x\n", status);
                            continue;
                        }

                        //
                        //  wipe read buffer
                        //
                        
                        RtlZeroMemory(buffer2, TEST_BUFFER_SIZE);

                        //
                        //  Reset offset to beginning of MU test area
                        //

                        offset.QuadPart = MU_MEDIA_OFFSET;

                        //
                        //  execute read on whole test area
                        //
                        status = NtReadFile(hVolume,
                                         0,
                                         NULL,
                                         NULL,
                                         &statusBlock,
                                         buffer2,
                                         TEST_BUFFER_SIZE,
                                         &offset
                                         );
                        if (!NT_SUCCESS(status)) {
                            DebugPrint("\nMUTEST: read failed with status 0x%0.8x\n", status);
                            continue;
                        }

                        //
                        //  Byte compare the buffers
                        //
                        localErrorCount = TEST_BUFFER_SIZE - RtlCompareMemory(buffer, buffer2, TEST_BUFFER_SIZE);
                        if(0==localErrorCount)
                        {
                            DebugPrint(": Success\n");
                        } else
                        {
                            DebugPrint(": Error\nMUTEST: There were %d errors, dumping first five errors.\n", localErrorCount);
                            totalErrorCount += localErrorCount;
                            DebugPrint("MUTEST: Offset: Written,  Read\n", i, buffer[i], buffer2[i]);
                            int errorCount = 0;
                            for(int i=0; i<TEST_BUFFER_SIZE; i++)
                            {
                                if(buffer[i]!=buffer2[i])
                                {
                                    errorCount++;
                                    if(errorCount < 5)
                                    {
                                        DebugPrint("MUTEST: 0x%0.4x:   0x%0.2x,  0x%0.2x\n", i, (ULONG)buffer[i], (ULONG)buffer2[i]);
                                    } else
                                    {
                                        break;
                                    }
                                }
                            }
                            _asm int 3;
                        }

                    }   //loop over write offset
                } //loop over write length
            } else  // if get geometry failed
            {
                DebugPrint("MUTEST: Couldn't get drive geometry, status 0x%0.8x\n", status);
                totalErrorCount++;
            }
        } else  // if get partition info failed
        {
                DebugPrint("MUTEST: Couldn't get partition info, status 0x%0.8x\n", status);
                totalErrorCount++;
        }
        //
        //  Close the volume
        //
        NtClose(hVolume);
    } else  //if NtOpenFile failed
    {
            DebugPrint("MUTEST: NtOpenFileFailed, status 0x%0.8x\n", status);
            totalErrorCount++;
    }
    if(totalErrorCount)
    {
        DebugPrint("MUTEST: FAILURE: Test completed with %d errors\n", totalErrorCount);
    } else
    {
        DebugPrint("MUTEST: SUCCESS: No Errors\n");
    }

    //
    //  Format the Mu
    //
    
    DebugPrint("MUTEST: Formatting the MU, so we can do the higher level tests\n");
    if (XapiFormatFATVolume(&objName))
    {
        DbgPrint("FormatFATVolume() succeeded\n");
    } else
    {
        DbgPrint("FormatFATVolume() failed\n");
    }

    //
    //  Close the device object that we created to test the mu.
    //

    MU_CloseDeviceObject(Port, Slot);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\dd\usb\netsim\client\precomp.h ===
#define DEBUG_KEYBOARD

#include <stddef.h>
#include <ntos.h>
#include <xtl.h>
#include <xdbg.h>
#include <xbdm.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\dd\usb\mutest\mutest.cpp ===
/*++

Copyright (c) 1996-2000 Microsoft Corporation

Module Name:

    MUTEST.CPP

Abstract:

    This source file contains a simple test code for the MU

Environment:

    kernel mode

Revision History:

--*/

//*****************************************************************************
// I N C L U D E S
//*****************************************************************************

#include <xtl.h>
#include <xboxp.h>

#include <mutest.h>
#include <devioctl.h>
#include <ntdddisk.h>
#include <stdio.h>

#define ARRAYSIZE(a) (sizeof(a) / sizeof(a[0]))

VOID
ReadWriteTest(
          CHAR DriveLetter
          );

VOID
ReadWriteScatterGatherTest(
          CHAR DriveLetter
          );

VOID
MUNameTest(
          CHAR DriveLetter
          );

VOID
DumpLogicalDriveList()
{
    CHAR szDriveStrings[] = "D:\\\0F:\\\0G:\\\0H:\\\0I:\\\0J:\\\0K:\\\0L:\\\0M:\\\0T:\\\0U:\\\0X:\\";
    LPSTR pszDrive;

    DebugPrint("Logical drive list:");
    pszDrive = szDriveStrings;
    while ('\0' != *pszDrive)
    {
        ULARGE_INTEGER ullFreeAvail, ullFree, ullTotal;
        if (GetDiskFreeSpaceEx(pszDrive, &ullFreeAvail, &ullTotal, &ullFree))
        {
            DebugPrint(" %s", pszDrive);
        }
        // Seek until next NULL:
        while (L'\0' != *pszDrive)
        {
            pszDrive++;
        }
        // Skip over the NULL:
        pszDrive++;
    }
    DebugPrint("\n");
}

VOID
WINAPI
GetDriveTypeTest()
{
    CHAR szDriveStrings[] = "D:\\\0F:\\\0G:\\\0H:\\\0I:\\\0J:\\\0K:\\\0L:\\\0M:\\\0T:\\\0U:\\\0X:\\";
    LPSTR pszDrive;

    // GetDriveType test
    DebugPrint("Logical drive list:\n");
    pszDrive = szDriveStrings;
    while (L'\0' != *pszDrive)
    {
        ULARGE_INTEGER ullFreeAvail, ullFree, ullTotal;
        if (GetDiskFreeSpaceEx(pszDrive, &ullFreeAvail, &ullTotal, &ullFree))
        {
            CHAR szLabel[MAX_PATH], szFileSystem[MAX_PATH];
            DWORD dwSerial, dwMaxNameLength, dwFSFlags;

            // Shift into a dword (right shift 20 and label as MB) to we can print it out..
            ullFreeAvail.LowPart = (ullFreeAvail.LowPart >> 20) | (ullFreeAvail.HighPart << 12);
            ullTotal.LowPart = (ullTotal.LowPart >> 20) | (ullTotal.HighPart << 12);
            ullFree.LowPart = (ullFree.LowPart >> 20) | (ullFree.HighPart << 12);

            if (GetVolumeInformation(pszDrive,
                                     szLabel,
                                     ARRAYSIZE(szLabel),
                                     &dwSerial,
                                     &dwMaxNameLength,
                                     &dwFSFlags,
                                     szFileSystem,
                                     ARRAYSIZE(szFileSystem)))
            {
                DebugPrint("Drive %s (label \"%s\", serial 0x%08x, maxname %lu, fsflags %lu, fs \"%s\")\n"
                           "          (total %lu MB, free %lu MB, avail %lu MB)\n",
                            pszDrive, szLabel, dwSerial, dwMaxNameLength, dwFSFlags, szFileSystem,
                            ullTotal.LowPart, ullFree.LowPart, ullFreeAvail.LowPart);
            }
            else
            {
                DWORD dwErr = GetLastError();
                DebugPrint("GetVolumeInformation() failed for %s: GetLastError()=0x%08x\n", pszDrive, dwErr);
            }
        }
        // Seek until next NULL:
        while (L'\0' != *pszDrive)
        {
            pszDrive++;
        }
        // Skip over the NULL:
        pszDrive++;
    }
    DebugPrint("\n");
}

VOID
WINAPI
FindFirstFindNextTest(LPCSTR pcszFilter)
{
    // FindFirstFile/FindNextFile/FindClose test
    WIN32_FIND_DATA wfd;
    HANDLE hFind = FindFirstFile(pcszFilter, &wfd);
    if (INVALID_HANDLE_VALUE != hFind)
    {
        DebugPrint("Directory listing for %s\n", pcszFilter);
        do
        {
            DebugPrint("%s, size=0x%08x, attributes=\n", wfd.cFileName,
                wfd.nFileSizeLow, wfd.dwFileAttributes);
            
        } while (FindNextFile(hFind, &wfd));
        
        FindClose(hFind);
    }
    else
    {
        DWORD dwErr = GetLastError();
        DebugPrint("FindFirstFile() failed for %s: GetLastError()=0x%08x\n", pcszFilter, dwErr);
    }
    DebugPrint("\n");
}


void __cdecl main()
{
    DWORD err;
    ULONG DeviceTypes = 0xFFFF0000;//USB_DEVICE_TYPE_MU;
    CHAR szFilter[] = "C:\\*";
    DWORD dwInsertions, dwRemovals;
    int i;
    
    DebugPrint("MUTEST: Built on %s at %s\n", __DATE__,__TIME__);
    
    //Initialize core peripheral port support
    XInitDevices(0,NULL);
    
    DebugPrint("MUTEST: Polling for device insertions/removals..\n");

    while (TRUE) {

        if(XGetDeviceChanges(XDEVICE_TYPE_MEMORY_UNIT, &dwInsertions, &dwRemovals))
        {
        
            DebugPrint("MUTEST: Insertions 0x%08x, Removals 0x%08x\n", dwInsertions, dwRemovals);

            for(i=0; i < 32; i++)
            {
                if(dwRemovals&(1 << i))
                {
                    DWORD dwSlot;
                    DWORD dwPort;
                    if(i < 16)
                    {
                        dwPort = i;
                        dwSlot = XDEVICE_TOP_SLOT;
                    } else
                    {
                        dwPort = i-16;
                        dwSlot = XDEVICE_BOTTOM_SLOT;
                    }
                    XUnmountMU(dwPort, dwSlot);
                }
                //
                //  Handle Insertions
                //
                if(dwInsertions&(1 << i))
                {
                    CHAR chDrive;
                    DWORD dwSlot;
                    DWORD dwPort;
                    if(i < 16)
                    {
                        dwPort = i;
                        dwSlot = XDEVICE_TOP_SLOT;
                    } else
                    {
                        dwPort = i-16;
                        dwSlot = XDEVICE_BOTTOM_SLOT;
                    }
                    if(dwPort >= 4)
                    {
                        DebugPrint("ERROR: MU in illegal port, p=%d, s=%s\n", dwPort, (XDEVICE_TOP_SLOT==dwSlot) ? "XDEVICE_TOP_SLOT" : "XDEVICE_BOTTOM_SLOT" );
                    }

                    LowLevelTest(dwPort, dwSlot);


                    DWORD dwErr = XMountMU(dwPort, dwSlot, &chDrive);

                    if (ERROR_SUCCESS == dwErr)
                    {

                        DebugPrint("XMountMU() succeeded, dr=%lc, p=%d, s=%d\n",
                                   chDrive,
                                   XMUPortFromDriveLetter(chDrive),
                                   XMUSlotFromDriveLetter(chDrive));

                        GetDriveTypeTest();

                        szFilter[0] = chDrive;

                        FindFirstFindNextTest(szFilter);

                        ReadWriteTest(chDrive);

                        ReadWriteScatterGatherTest(chDrive);

                        FindFirstFindNextTest(szFilter);

                        MUNameTest(chDrive);
                    }
                    else
                    {
                        DebugPrint("XMountMU() failed, error = 0x%08x\n", dwErr);
                    }
                }
            } // for loop
            DumpLogicalDriveList();
        } // if

    } // while
}


#define TEST_BUFFER_SIZE 8192
#define EXTRA_SIZE 8192
#define SECTOR_MASK 0xFFFFE000

VOID
ReadWriteTest(
          CHAR DriveLetter
          )
{

	ULONG					tryCount = 0;
    CHAR                    name[64];
    HRESULT                 hr;
    HANDLE                  hFile;
    PUCHAR buffer,buffer2;
    UCHAR pattern[4] = {1,2,3,4};
    ULONG i;

    sprintf(name,"C:\\test.dat");

    name[0] = DriveLetter;

    hFile = CreateFile(name,
                    GENERIC_READ | GENERIC_WRITE,
                    FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_FLAG_WRITE_THROUGH,
                    NULL,
                    OPEN_ALWAYS,
                    0,
                    NULL);

    if(INVALID_HANDLE_VALUE == hFile) {

        hr = GetLastError();
        return;
    }

    buffer =  (PUCHAR)LocalAlloc(LPTR, TEST_BUFFER_SIZE+EXTRA_SIZE);
    buffer2 =  (PUCHAR)LocalAlloc(LPTR, TEST_BUFFER_SIZE+EXTRA_SIZE);

    //
    // sector align buffers
    //

    buffer = (PUCHAR)((ULONG) buffer & SECTOR_MASK);
    buffer += EXTRA_SIZE;

    buffer2 = (PUCHAR)((ULONG) buffer2 & SECTOR_MASK);
    buffer2 += EXTRA_SIZE;

    //
    // fill the buffer with a pattern
    //

    for (i=0;i<TEST_BUFFER_SIZE;i+=sizeof(pattern)) {

        RtlCopyMemory(buffer+i,pattern,sizeof(pattern));

    }

    DebugPrint("MUTEST: Test buffer 1 at %x, 2 at %x\n",buffer,buffer2);

    DebugPrint("MUTEST: Writing pattern to file\n");

    //
    // write the pattern to the file, close the file then read it
    //

    if (!WriteFile(hFile,
                  buffer,
                  TEST_BUFFER_SIZE,
                  &i,
                  NULL)) {

        hr = GetLastError();
        DebugPrint("MUTEST: Write Failed with %x\n",hr);

        LocalFree(buffer);
        LocalFree(buffer2);

    }

    DebugPrint("MUTEST: Closing file\n");

    //
    // close the file
    //

    CloseHandle(hFile);

    DebugPrint("MUTEST: Re-opening file\n");

    //
    // open the file and read from it
    //

    hFile = CreateFile(name,
                GENERIC_READ | GENERIC_WRITE,
                FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_FLAG_NO_BUFFERING,
                NULL,
                OPEN_ALWAYS,
                0,
                NULL);

    if(INVALID_HANDLE_VALUE == hFile) {

        hr = GetLastError();
        return;
    }

    DebugPrint("MUTEST: Reading pattern to file\n");

    if (!ReadFile(hFile,
                  buffer2,
                  TEST_BUFFER_SIZE,
                  &i,
                  NULL)) {

        hr = GetLastError();
        DebugPrint("MUTEST: Read Failed with %x\n",hr);

        LocalFree(buffer);
        LocalFree(buffer2);

    }

    CloseHandle(hFile);

    DebugPrint("MUTEST: Success: Test buffer at %x\n",buffer);
}


#define PAGE_SIZE 4096
#define TEST_SG_BUFFER_SIZE (PAGE_SIZE * 5)

VOID
ReadWriteScatterGatherTest(
          CHAR DriveLetter
          )
{

	ULONG					tryCount = 0;
    CHAR                    name[64];
    HRESULT                 hr;
    HANDLE                  hFile;
    PUCHAR buffer,buffer2;
    FILE_SEGMENT_ELEMENT sg1[TEST_SG_BUFFER_SIZE / PAGE_SIZE + 1];
    FILE_SEGMENT_ELEMENT sg2[TEST_SG_BUFFER_SIZE / PAGE_SIZE + 1];
    UCHAR pattern[4] = {1,2,3,4};
    ULONG i;
    OVERLAPPED ov;

    sprintf(name,"C:\\testsg.dat");

    name[0] = DriveLetter;

    hFile = CreateFile(name,
                    GENERIC_READ | GENERIC_WRITE,
                    FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_FLAG_WRITE_THROUGH,
                    NULL,
                    OPEN_ALWAYS,
                    FILE_FLAG_OVERLAPPED | FILE_FLAG_NO_BUFFERING,
                    NULL);

    if(INVALID_HANDLE_VALUE == hFile) {

        hr = GetLastError();
        return;
    }

    buffer =  (PUCHAR)VirtualAlloc(NULL,TEST_SG_BUFFER_SIZE,MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
    buffer2 =  (PUCHAR)VirtualAlloc(NULL,TEST_SG_BUFFER_SIZE,MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);

    ZeroMemory(sg1, sizeof(sg1));
    ZeroMemory(sg2, sizeof(sg2));

    for (i = 0; i < TEST_SG_BUFFER_SIZE / PAGE_SIZE; i++) {
        sg1[i].Buffer = buffer + i * PAGE_SIZE;
        sg2[i].Buffer = buffer2 + i * PAGE_SIZE;
    }

    //
    // fill the buffer with a pattern
    //

    for (i=0;i<TEST_SG_BUFFER_SIZE;i+=sizeof(pattern)) {

        RtlCopyMemory(buffer+i,pattern,sizeof(pattern));

    }

    DebugPrint("MUTEST: Scatter/gather test\n");

    DebugPrint("MUTEST: Test S/G buffer 1 at %x, 2 at %x\n",buffer,buffer2);

    DebugPrint("MUTEST: Writing pattern to file\n");

    //
    // write the pattern to the file, close the file then read it
    //

    ZeroMemory(&ov, sizeof(ov));

    if (!WriteFileGather(hFile,
                  sg1,
                  TEST_SG_BUFFER_SIZE,
                  NULL,
                  &ov)) {

        hr = GetLastError();

        if (hr != ERROR_IO_PENDING ||
            !GetOverlappedResult(hFile, &ov, &i, TRUE)) {

            hr = GetLastError();

            DebugPrint("MUTEST: Write Failed with %x\n",hr);
        }
    }

    DebugPrint("MUTEST: Closing file\n");

    //
    // close the file
    //

    CloseHandle(hFile);

    DebugPrint("MUTEST: Re-opening file\n");

    //
    // open the file and read from it
    //

    hFile = CreateFile(name,
                GENERIC_READ | GENERIC_WRITE,
                FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_FLAG_NO_BUFFERING,
                NULL,
                OPEN_ALWAYS,
                FILE_FLAG_OVERLAPPED | FILE_FLAG_NO_BUFFERING,
                NULL);

    if(INVALID_HANDLE_VALUE == hFile) {

        hr = GetLastError();
        return;
    }

    DebugPrint("MUTEST: Reading pattern to file\n");

    ZeroMemory(&ov, sizeof(ov));

    if (!ReadFileScatter(hFile,
                  sg2,
                  TEST_SG_BUFFER_SIZE,
                  NULL,
                  &ov)) {

        hr = GetLastError();

        if (hr != ERROR_IO_PENDING ||
            !GetOverlappedResult(hFile, &ov, &i, TRUE)) {

            hr = GetLastError();

            DebugPrint("MUTEST: Read Failed with %x\n",hr);
        }
    }

    CloseHandle(hFile);

    DebugPrint("MUTEST: Success: Test S/G buffer at %x\n",buffer);
}

VOID
MUNameTest(
          CHAR DriveLetter
          )
{
    DWORD error;
    WCHAR MUName[MAX_MUNAME];

    RtlFillMemory(MUName, sizeof(MUName), 0xCC);

    error = XMUWriteNameToDriveLetter(DriveLetter, L"Test Name");

    if (error != ERROR_SUCCESS) {
        DebugPrint("MUTEST: Failed to write MU name with %x\n", error);
    }

    error = XMUNameFromDriveLetter(DriveLetter, MUName, MAX_MUNAME);

    if (error == ERROR_SUCCESS) {

        if (lstrcmpW(MUName, L"Test Name") != 0) {
            DebugPrint("MUTEST: Failed to read back correct MU name\n");
        }

    } else {
        DebugPrint("MUTEST: Failed to read MU name with %x\n", error);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\dd\usb\netsim\server\precomp.h ===
#define DEBUG_KEYBOARD

#include <stddef.h>
#include <stdio.h>
#include <xtl.h>
#include <xdbg.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\dd\usb\netsim\server\xirm_server.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    xirm_server.c

Abstract:

    XInput remote server program

--*/

#include "precomp.h"
#include "xinput_remote.h"
#include "list.h"

// Our module name for debug spews
#define MYMODNAME "XIRM"

BOOL dosetup;
SOCKET sock, listensock;
HANDLE recvevt;
CHAR recvbuf[XIRM_MAX_PACKET_SIZE];
struct sockaddr_in clientaddr;
#define CLIENTADDR clientaddr.sin_addr.s_addr

BOOL autonetmode;
CHAR clientname[XIRM_MACHINE_NAME_MAXLEN];
DWORD connecttime;
DWORD clientisn, clientseq;
DWORD serverseq_una, serverseq_nxt;
INT fastrexmit, rexmit_timer, rexmit_count;
BOOL rexmit_disabled;
LIST_ENTRY sendq;

struct ConnectionRequest {
    DWORD clientisn;
    struct sockaddr_in clientaddr;
    CHAR clientname[XIRM_MACHINE_NAME_MAXLEN];
} connection_request;
CRITICAL_SECTION connection_request_lock;

#define ConnectReqLock()    EnterCriticalSection(&connection_request_lock)
#define ConnectReqUnlock()  LeaveCriticalSection(&connection_request_lock)
#define HasPendingConnectReq() (connection_request.clientaddr.sin_addr.s_addr != 0)

__inline BOOL GetPendingConnectReq(struct ConnectionRequest* connreq) {
    ConnectReqLock();
    *connreq = connection_request;
    connection_request.clientaddr.sin_addr.s_addr = 0;
    ConnectReqUnlock();

    return (connreq->clientaddr.sin_addr.s_addr != 0);
}

#define GetSendqHead() ((SendBuf*) sendq.Flink)
#define GetSendqLen() ((INT) (serverseq_nxt - serverseq_una))
#define IsSendqFull() (GetSendqLen() >= XIRM_SEND_WINDOW)
#define IsSendqEmpty() (serverseq_una == serverseq_nxt)

typedef struct _SendBuf {
    LIST_ENTRY links;
    INT datalen;
    XIrmPacketHeader data;
} SendBuf;

DWORD active_device_masks;
DWORD pending_insertions;
DWORD pending_removals;
struct DeviceData {
    HANDLE handle;
    XINPUT_STATE current_states;
    XINPUT_STATE last_states;
    XINPUT_CAPABILITIES devicecaps;
} devices[XIRM_PORTMAX];

//
// Main server loop sampling interval (10 msecs = 100Hz)
//
#define SAMPLING_INTERVAL 10

//
// Read the processor timestamp counter in milliseconds
//
__inline DWORD ReadTimestamp() {
    __asm {
        rdtsc
        mov ebx, 733000
        div ebx
    }
}

//
// Read the client configuration file
//
#define CONFIGFILENAME "d:\\xirmsrv.cfg"

BOOL
ReadConfig()
{
    CHAR buf[256];
    FILE* fin = fopen(CONFIGFILENAME, "r");

    if (!fin) {
        XDBGTRC(MYMODNAME, "cannot open config file");
        return FALSE;
    }

    while (fgets(buf, sizeof(buf), fin)) {
        CHAR *p, *val;
        
        p = strchr(buf, '=');
        if (!p) continue;

        *p++ = '\0';
        while (*p && isspace(*p)) p++;
        val = p;

        while (*p && *p != '\r' && *p != '\n' && !isspace(*p)) p++;
        *p = '\0';

        if (*val == '\0') continue;
        if (strcmp(buf, "name") == 0) {
            if (strlen(val) < XIRM_MACHINE_NAME_MAXLEN) {
                strcpy(clientname, val);
            }
        } else if (strcmp(buf, "ipaddr") == 0) {
            ULONG addr = inet_addr(val);
            if (addr != INADDR_NONE)
                CLIENTADDR = addr;
        }
    }
    fclose(fin);

    XDBGTRC(MYMODNAME, "client config: %s %u.%u.%u.%u", clientname, clientaddr.sin_addr.S_un.S_un_b.s_b1, clientaddr.sin_addr.S_un.S_un_b.s_b2, clientaddr.sin_addr.S_un.S_un_b.s_b3, clientaddr.sin_addr.S_un.S_un_b.s_b4);
    return (clientname[0] != '\0' || CLIENTADDR != 0);
}

//
// Write the client configuration file
//
BOOL
WriteConfig()
{
    FILE* fout = fopen(CONFIGFILENAME, "w");
    if (!fout) return FALSE;

    fprintf(fout, "name=%s\n", clientname[0] ? clientname : "<NONE>");
    fprintf(fout, "ipaddr=%u.%u.%u.%u\n", clientaddr.sin_addr.S_un.S_un_b.s_b1, clientaddr.sin_addr.S_un.S_un_b.s_b2, clientaddr.sin_addr.S_un.S_un_b.s_b3, clientaddr.sin_addr.S_un.S_un_b.s_b4);
    fclose(fout);
    return TRUE;
}

//
// Close the specified port
//
VOID ClosePort(DWORD port) {
    struct DeviceData* device = &devices[port];
    if (device->handle) {
        XInputClose(device->handle);
        memset(device, 0, sizeof(*device));
    }
}

//
// Open the specified port
//
BOOL OpenPort(DWORD port) {
    struct DeviceData* device = &devices[port];
    DWORD err;

    ASSERT(device->handle == NULL);
    device->handle = XInputOpen(
                        XDEVICE_TYPE_GAMEPAD,
                        port,
                        XDEVICE_NO_SLOT,
                        NULL);

    if (device->handle == NULL) {
        XDBGWRN(MYMODNAME, "XInputOpen failed: %d", GetLastError());
        return FALSE;
    }

    err = XInputGetCapabilities(device->handle, &device->devicecaps);
    if (err != ERROR_SUCCESS) {
        XDBGWRN(MYMODNAME, "XInputGetCapabilities failed: %d", err);
        return FALSE;
    }

    return TRUE;
}

//
// Poll the input states
//
VOID
PollInput()
{
    DWORD insertions, removals;
    DWORD port;

    // Check if there has been any device changes
    if (XGetDeviceChanges(XDEVICE_TYPE_GAMEPAD, &insertions, &removals)) {
        // close devices that have been removed
        for (port=0; port < XIRM_PORTMAX; port++) {
            if (removals & (1 << port)) {
                if (devices[port].handle) {
                    ClosePort(port);
                }
            }
        }

        // open devices that have been inserted
        for (port=0; port < XIRM_PORTMAX; port++) {
            if (insertions & (1 << port)) {
                if (!OpenPort(port)) {
                    // If we failed to open the port, treat it as not plugged in
                    removals |= (1 << port);
                    insertions &= ~(1 << port);
                    ClosePort(port);
                }
            }
        }

        active_device_masks &= ~removals;
        active_device_masks |= insertions;

        pending_removals |= removals;
        pending_insertions &= ~removals;
        pending_insertions |= insertions;
    }

    // Now for currently inserted devices, update the state information
    for (port=0; port < XIRM_PORTMAX; port++) {
        struct DeviceData* device = &devices[port];
        if (device->handle) {
            DWORD err = XInputGetState(device->handle, &device->current_states);
            if (err != ERROR_SUCCESS) {
                XDBGWRN(MYMODNAME, "XInputGetState failed: %d", err);
                device->current_states = device->last_states;
            }
        }
    }
}

//
// Initialize the input module
//
#define MAGIC_KEYCOMBO (XINPUT_GAMEPAD_START | XINPUT_GAMEPAD_BACK)

VOID
InitInput()
{
    DWORD port;

    XInitDevices(0, NULL);
    Sleep(2000);

    // Get the initial device states
    PollInput();

    // Look for the special key combination to enter Setup mode
    for (port=0; port < XIRM_PORTMAX; port++) {
        if (devices[port].handle &&
            devices[port].current_states.Gamepad.wButtons == MAGIC_KEYCOMBO &&
            devices[port].current_states.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_X]) {
            dosetup = TRUE;
            break;
        }
    }
}

//
// Transmit the first packet in the send queue
//
#define SetRexmitTimer() (rexmit_timer = ReadTimestamp() + XIRM_RETRANSMIT_TIMEOUT)
__inline VOID EnableRexmit() {
    if (rexmit_disabled) {
        rexmit_disabled = FALSE;
        rexmit_count = 1;
    }
}

VOID
SendqXmit(
    SendBuf* sendbuf
    )
{
    INT count;

    count = send(sock, (CHAR*) &sendbuf->data, sendbuf->datalen, 0);
    if (count != sendbuf->datalen) {
        XDBGWRN(MYMODNAME, "send failed: %d, %d", count, GetLastError());
    }

    if (sendbuf == GetSendqHead()) {
        SetRexmitTimer();
    }
    rexmit_count++;
    fastrexmit = 0;
}

//
// Do retransmission if needed
//
VOID
CheckRexmit()
{
    if (rexmit_disabled || IsSendqEmpty()) return;

    if ((INT) (rexmit_timer - ReadTimestamp()) < 0) {
        if (rexmit_count >= XIRM_RETRANSMIT_RETRY) {
            // If too many retries, we assume the client is down
            // and stop retransmitting until we receive a packet
            // from the client or there is an input state change.
            XDBGTRC(MYMODNAME, "client down?");
            rexmit_disabled = TRUE;
        } else {
            SendqXmit(GetSendqHead());
        }
    }
}

//
// Insert a new send buffer to the end of the send queue
// and then transmit it out to the client
//
VOID
InsertSendBuf(
    SendBuf* sendbuf
    )
{
    if (IsListEmpty(&sendq)) rexmit_count = 0;

    InsertTailList(&sendq, &sendbuf->links);
    SendqXmit(sendbuf);
}

//
// Allocate memory buffer for a new outgoing packet
//
SendBuf*
AllocSendBuf(
    INT size
    )
{
    SendBuf* sendbuf = (SendBuf*) malloc(offsetof(SendBuf, data) + size);

    if (sendbuf) {
        sendbuf->datalen = size;
        sendbuf->data.sendseq = serverseq_nxt++;
        sendbuf->data.ackseq = clientseq;
    } else {
        XDBGWRN(MYMODNAME, "out of memory");
    }
    return sendbuf;
}

//
// Send device changes to the client
//
VOID
SendDeviceChanges()
{
    SendBuf* sendbuf;
    XIrmPacketDeviceChanges* devchgpkt;
    XINPUT_CAPABILITIES* devcaps;
    INT pktlen;
    DWORD port;

    // Return immediately if:
    //  there has been no changes, or
    //  the send queue is full
    if ((pending_insertions | pending_removals) == 0 || IsSendqFull())
        return;

    pktlen = offsetof(XIrmPacketDeviceChanges, devicecaps) +
             XIrmCountDevices(active_device_masks) * sizeof(XINPUT_CAPABILITIES);
   
    sendbuf = AllocSendBuf(pktlen);
    if (!sendbuf) return;

    devchgpkt = (XIrmPacketDeviceChanges*) &sendbuf->data;
    devchgpkt->header.type = PKTTYPE_DEVICE_CHANGES;
    devchgpkt->active_devices = active_device_masks;
    devchgpkt->insertions = pending_insertions;
    devchgpkt->removals = pending_removals;

    // NOTE: We don't bother with keyboard support on silver box.
    devchgpkt->keyboard_device = 0;

    pending_insertions = pending_removals = 0;
    devcaps = devchgpkt->devicecaps;

    for (port=0; port < XIRM_PORTMAX; port++) {
        if (active_device_masks & (1 << port)) {
            *devcaps++ = devices[port].devicecaps;
        }
    }

    // Start retransmission again if input state has changed
    EnableRexmit();
    InsertSendBuf(sendbuf);
}

//
// Send input state changes to the client
//
VOID
SendStateChanges()
{
    DWORD port, masks = 0;
    INT pktlen = 0;
    SendBuf* sendbuf;
    XIrmPacketStateChanges* stchgpkt;
    XINPUT_STATE* states;
    
    if (IsSendqFull()) return;

    // Check if there has been any state changes
    for (port=0; port < XIRM_PORTMAX; port++) {
        if (devices[port].handle) {
            ASSERT(active_device_masks & (1 << port));
            if (memcmp(&devices[port].current_states,
                       &devices[port].last_states,
                       sizeof(XINPUT_STATE)) != 0) {
                masks |= (1 << port);
                pktlen++;
            }
        }
    }
    if (masks == 0) return;

    pktlen = offsetof(XIrmPacketStateChanges, states) + pktlen * sizeof(XINPUT_STATE);
    sendbuf = AllocSendBuf(pktlen);
    if (!sendbuf) return;

    stchgpkt = (XIrmPacketStateChanges*) &sendbuf->data;
    stchgpkt->header.type = PKTTYPE_STATE_CHANGES;
    stchgpkt->device_masks = masks;
    states = stchgpkt->states;
    for (port=0; port < XIRM_PORTMAX; port++) {
        if (masks & (1 << port)) {
            *states++ = devices[port].last_states = devices[port].current_states;
        }
    }

    // Start retransmission again if input state has changed
    EnableRexmit();
    InsertSendBuf(sendbuf);
}

//
// Initialize the connection with the client
//
VOID
InitClient(
    struct ConnectionRequest* connreq
    )
{
    SendBuf* sendbuf;
    DWORD port;
    INT err;

    strcpy(clientname, connreq->clientname);
    clientaddr = connreq->clientaddr;

    XDBGTRC(MYMODNAME,
        "connected to client: %s %u.%u.%u.%u:%d",
        clientname,
        clientaddr.sin_addr.S_un.S_un_b.s_b1, clientaddr.sin_addr.S_un.S_un_b.s_b2, clientaddr.sin_addr.S_un.S_un_b.s_b3, clientaddr.sin_addr.S_un.S_un_b.s_b4,
        ntohs(clientaddr.sin_port));

    err = connect(sock, (struct sockaddr*) &clientaddr, sizeof(clientaddr));
    ASSERT(err == NO_ERROR);

    connecttime = ReadTimestamp();
    rexmit_disabled = FALSE;
    clientisn = connreq->clientisn;
    clientseq = clientisn+1;
    serverseq_una = serverseq_nxt = XIrmGetISN();

    while (!IsListEmpty(&sendq)) {
        LIST_ENTRY* p = RemoveHeadList(&sendq);
        free(p);
    }

    sendbuf = AllocSendBuf(sizeof(XIrmPacketHeader));
    ASSERT(sendbuf != NULL);
    sendbuf->data.type = PKTTYPE_SERVER_INIT;
    InsertSendBuf(sendbuf);

    // Send the initial device caps and states
    pending_insertions = active_device_masks;
    pending_removals = 0;
    for (port=0; port < XIRM_PORTMAX; port++) {
        memset(&devices[port].last_states, 0, sizeof(devices[port].last_states));
    }

    SendDeviceChanges();
    SendStateChanges();
}

//
// Process a set-state packet from the client
//
VOID
ProcessClientSetState(
    XIrmPacketSetState* pkt
    )
{
    static XINPUT_FEEDBACK feedback;
    DWORD err;

    if (pkt->port < XIRM_PORTMAX &&
        devices[pkt->port].handle &&
        feedback.Header.dwStatus != ERROR_IO_PENDING) {
        feedback = pkt->feedback;
        err = XInputSetState(devices[pkt->port].handle, &feedback);
        if (err != ERROR_SUCCESS &&
            err != ERROR_IO_PENDING &&
            err != ERROR_NOT_SUPPORTED) {
            XDBGWRN(MYMODNAME, "XInputSetState failed: %d", err);
        }
    }
}

//
// Check to see if we should serve an incoming connection request from a client
//
__inline BOOL IsAutonetAddr(ULONG addr) {
    // autonet address range is 169.254.x.x/16
    addr = ntohl(addr);
    return (addr & 0xffff0000) == 0xa9fe0000;
}

INT
MatchClient(
    CHAR* name,
    ULONG addr
    )
{
    XNADDR  XnAddr;
    static struct in_addr myaddr;

    // Try name match first
    if (clientname[0] && strcmp(clientname, name) == 0) return 1;

    // Then try explicit address match
    if (CLIENTADDR && CLIENTADDR == addr) return 2;

    // Now check to see if both client and server are using autonet addresses
    if (IsAutonetAddr(addr)) {
        if (myaddr.s_addr == 0) {
            XNetGetTitleXnAddr(&XnAddr);
            CopyMemory(&myaddr, &XnAddr.ina, sizeof(myaddr));
        }
        if (IsAutonetAddr(myaddr.s_addr)) return 3;
    }

    return 0;
}

//
// Process a client-init packet from the client
//
VOID
ProcessClientInit()
{
    struct ConnectionRequest connreq;

    if (GetPendingConnectReq(&connreq) &&
        MatchClient(connreq.clientname, connreq.clientaddr.sin_addr.s_addr)) {
        // Figure out how long has it been since the last connect
        INT time = ReadTimestamp() - connecttime;
        if (connreq.clientisn == clientisn && time >= 0 && time <= 3000) {
            // The packet is a duplicate - just drop it
        } else {
            // The client must have rebooted, reestablish connection
            XDBGTRC(MYMODNAME, "client must have rebooted");
            InitClient(&connreq);
        }
    }
}

//
// Process an acknowledgement packet from the client
//
VOID
ProcessClientAck(
    XIrmPacketHeader* pkt
    )
{
    DWORD ack;
    INT index, sent;

    ack = pkt->ackseq;
    index = (INT) (ack - serverseq_una);
    sent = GetSendqLen();

    if (index > 0 && index <= sent) {
        // The acknowledgement is valid
        ASSERT(!IsListEmpty(&sendq));
        serverseq_una = ack;

        do {
            SendBuf* sendbuf = GetSendqHead();
            if (sendbuf->data.sendseq == ack) {
                SetRexmitTimer();
                rexmit_count = 1;
                fastrexmit = 0;
                break;
            }
            RemoveHeadList(&sendq);
            free(sendbuf);
        } while (!IsListEmpty(&sendq));

    } else if (index == 0 && sent != 0) {
        // Fast retransmit
        if (++fastrexmit >= 2) {
            XDBGTRC(MYMODNAME, "fast rexmit");
            SendqXmit(GetSendqHead());
        }
    } else {
        XDBGTRC(MYMODNAME,
            "ack ignored: %u, %u, %u",
            ack, serverseq_una, serverseq_nxt);
    }
}

//
// Service network traffic from the client
//
VOID
ServiceClient()
{
    static BOOL pending = FALSE;
    static WSAOVERLAPPED overlapped;
    DWORD bytesrecv, flags;
    INT err;

    while (TRUE) {
        // Issue the overlapped recv request if necessary
        if (!pending) {
            WSABUF wsabuf;
            wsabuf.buf = recvbuf;
            wsabuf.len = sizeof(recvbuf);
            flags = 0;
            overlapped.hEvent = recvevt;
            err = WSARecv(sock, &wsabuf, 1, &bytesrecv, &flags, &overlapped, NULL);
            if (err == SOCKET_ERROR) {
                err = WSAGetLastError();
                if (err == WSA_IO_PENDING) {
                    pending = TRUE;
                } else {
                    XDBGWRN(MYMODNAME, "failed to issue recv request: %d", err);
                    return;
                }
            }
        }

        // If an overlapped recv request is pending,
        // check to see if it's completed yet.
        if (pending) {
            if (!WSAGetOverlappedResult(sock, &overlapped, &bytesrecv, FALSE, &flags)) {
                err = WSAGetLastError();
                if (err == WSA_IO_INCOMPLETE) return;

                //
                // This is very bad -
                //  cancel the pending recv request and try to issue a new one
                //
                XDBGWRN(MYMODNAME, "get overlapped result failed: %d", err);
                WSACancelOverlappedIO(sock);
                pending = FALSE;
                continue;
            }
            pending = FALSE;
        }

        // Client must be alive again - enable retransmission
        EnableRexmit();

        if (bytesrecv >= sizeof(XIrmPacketHeader)) {
            XIrmPacketHeader* pkt = (XIrmPacketHeader*) recvbuf;

            if (pkt->sendseq != clientseq) {
                XDBGTRC(MYMODNAME,
                    "client packet seq? %d %u, %u",
                    pkt->type, pkt->sendseq, clientseq);
            }

            switch (pkt->type) {
            case PKTTYPE_ACK:
                if (bytesrecv == sizeof(XIrmPacketHeader)) {
                    ProcessClientAck(pkt);
                }
                break;

            case PKTTYPE_SET_STATE:
                if (bytesrecv == sizeof(XIrmPacketSetState)) {
                    ProcessClientSetState((XIrmPacketSetState*) pkt);
                }
                break;

            default:
                XDBGTRC(MYMODNAME, "client packet type? %d", pkt->type);
                break;
            }
        } else {
            XDBGWRN(MYMODNAME, "client packet size? %d", bytesrecv);
        }
    }
}

//
// Wait for a client connection
//
VOID
WaitForClient()
{
    struct ConnectionRequest connreq;
    INT match = 0;
    
    XDBGTRC(MYMODNAME,
        "waiting for client connection: %u.%u.%u.%u %s",
        clientname,
        clientaddr.sin_addr.S_un.S_un_b.s_b1, clientaddr.sin_addr.S_un.S_un_b.s_b2, clientaddr.sin_addr.S_un.S_un_b.s_b3, clientaddr.sin_addr.S_un.S_un_b.s_b4);

    do {
        Sleep(SAMPLING_INTERVAL);
        if (HasPendingConnectReq() && GetPendingConnectReq(&connreq)) {
            match = MatchClient(connreq.clientname, connreq.clientaddr.sin_addr.s_addr);
            if (!match) {
                // the connection request wasn't valid
                XDBGTRC(MYMODNAME, "client-init doesn't match");
            }
        }
    } while (!match);

    if (match == 2 && connreq.clientname[0]) {
        // We have an address match and the client has a name.
        // Update the config file with the client name so
        // that we can do name match next time around.
        strcpy(clientname, connreq.clientname);
        WriteConfig();
    }

    InitClient(&connreq);
}

//
// Server loop
//
VOID
RunServer()
{
    DWORD timer;

    recvevt = WSACreateEvent();
    ASSERT(recvevt != NULL);
    ServiceClient();

    timer = ReadTimestamp() + SAMPLING_INTERVAL;
    while (TRUE) {
        INT timeout = timer - ReadTimestamp();

        if (timeout > 0) {
            DWORD wait = WaitForSingleObject(recvevt, timeout);
            if (wait == WAIT_OBJECT_0) {
                // Process packets from the client
                ServiceClient();
            }
        } else {
            if (HasPendingConnectReq()) {
                ProcessClientInit();
            }

            // Do retransmit if necessary
            CheckRexmit();

            // Check input state changes
            PollInput();
            SendDeviceChanges();
            SendStateChanges();

            timer = ReadTimestamp() + SAMPLING_INTERVAL;
        }
    }
}

//
// Client setup mode
//
VOID
DoSetup()
{
    struct ConnectionRequest connreq;

    XDBGTRC(MYMODNAME, "enter setup mode");
    memset(clientname, 0, sizeof(clientname));
    CLIENTADDR = 0;

    while (TRUE) {
        Sleep(SAMPLING_INTERVAL);
        if (HasPendingConnectReq()) {
            if (!GetPendingConnectReq(&connreq)) continue;

            // If both the client and server are using autonet address,
            // we'll automatically accept the client connection request.
            if (MatchClient(connreq.clientname, connreq.clientaddr.sin_addr.s_addr)) {
                autonetmode = TRUE;
                break;
            }

            // Display the client name / address in the UI and
            // ask the user for confirmation.
            // BUGBUG - not yet implemented
            XDBGWRN(MYMODNAME,
                "accept connection from %s %u.%u.%u.%u?",
                connreq.clientname,
                connreq.clientaddr.sin_addr.S_un.S_un_b.s_b1, connreq.clientaddr.sin_addr.S_un.S_un_b.s_b2, connreq.clientaddr.sin_addr.S_un.S_un_b.s_b3, connreq.clientaddr.sin_addr.S_un.S_un_b.s_b4);
        }
    }

    InitClient(&connreq);
}

//
// Initialize network stack
//
VOID
InitNet()
{
    INT err;
    WSADATA wsadata;
    struct sockaddr_in sockname;

    err = XNetStartup(NULL);
    ASSERT(err == NO_ERROR);

    err = WSAStartup(WINSOCK_VERSION, &wsadata);
    ASSERT(err == NO_ERROR);

    sock = socket(AF_INET, SOCK_DGRAM, 0);
    ASSERT(sock != INVALID_SOCKET);

    memset(&sockname, 0, sizeof(sockname));
    sockname.sin_family = AF_INET;
    err = bind(sock, (struct sockaddr*) &sockname, sizeof(sockname));
    ASSERT(err == NO_ERROR);

    listensock = socket(AF_INET, SOCK_DGRAM, 0);
    ASSERT(listensock != INVALID_SOCKET);

    sockname.sin_port = htons(XIRM_SERVER_PORT);
    err = bind(listensock, (struct sockaddr*) &sockname, sizeof(sockname));
    ASSERT(err == NO_ERROR);
}

//
// Server thread that listens for incoming client connection requests
//
DWORD WINAPI
ListenThreadProc(
    VOID* param
    )
{
    CHAR buf[XIRM_MAX_PACKET_SIZE];
    struct sockaddr sockname;
    struct sockaddr_in* sockin;
    XIrmPacketClientInit* initpkt;
    INT err;

    initpkt = (XIrmPacketClientInit*) buf;
    memset(&sockname, 0, sizeof(sockname));
    sockin = (struct sockaddr_in*) &sockname;

    while (TRUE) {
        INT fromlen = sizeof(sockname);
        INT count = recvfrom(listensock, buf, sizeof(buf), 0, &sockname, &fromlen);

        if (count != sizeof(*initpkt) || initpkt->header.type != PKTTYPE_CLIENT_INIT) {
            if (count >= sizeof(XIrmPacketHeader)) {
                XDBGTRC(MYMODNAME, "packet from %u.%u.%u.%u:%d discard: %d",
                    sockin->sin_addr.S_un.S_un_b.s_b1, sockin->sin_addr.S_un.S_un_b.s_b2, sockin->sin_addr.S_un.S_un_b.s_b3, sockin->sin_addr.S_un.S_un_b.s_b4,
                    ntohs(sockin->sin_port),
                    initpkt->header.type);
            } else {
                XDBGWRN(MYMODNAME, "recv error? %d, %d", count, GetLastError());
            }
            continue;
        }

        XDBGTRC(MYMODNAME,
            "client-init from %u.%u.%u.%u:%d - %x %u",
            sockin->sin_addr.S_un.S_un_b.s_b1, sockin->sin_addr.S_un.S_un_b.s_b2, sockin->sin_addr.S_un.S_un_b.s_b3, sockin->sin_addr.S_un.S_un_b.s_b4,
            ntohs(sockin->sin_port),
            initpkt->protocol_version,
            initpkt->header.sendseq);

        if (initpkt->protocol_version != XIRM_PROTOCOL_VERSION) {
            XDBGTRC(MYMODNAME, "client version mismatch: %x %x");
            continue;
        }

        ConnectReqLock();
        connection_request.clientisn = initpkt->header.sendseq;
        connection_request.clientaddr = *sockin;
        memcpy(connection_request.clientname, initpkt->client_name, XIRM_MACHINE_NAME_MAXLEN-1);
        ConnectReqUnlock();
    }
}


void __cdecl main()
{
    HANDLE thread;
    DWORD tid;

    InitializeListHead(&sendq);

    // Initialize network stack
    InitNet();

    // Initialize input
    InitInput();

    // Create server listening thread
    InitializeCriticalSection(&connection_request_lock);
    thread = CreateThread(NULL, 0, ListenThreadProc, NULL, 0, &tid);
    ASSERT(thread != NULL);
    CloseHandle(thread);

    // Check if the config file is present
    if (!dosetup) {
        if (!ReadConfig()) dosetup = TRUE;
    }

    if (dosetup) {
        DoSetup();
    } else {
        // Server loop
        WaitForClient();
    }

    RunServer();
    Sleep(INFINITE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\dd\usb\netsim\server\list.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    list.h

Abstract:

    Macros for manipulating linked lists

Notes:

    Copied here from ntrtl.h ...

--*/

#pragma once

//
//  VOID
//  InitializeListHead(
//      PLIST_ENTRY ListHead
//      );
//

#define InitializeListHead(ListHead) (\
    (ListHead)->Flink = (ListHead)->Blink = (ListHead))

//
//  BOOLEAN
//  IsListEmpty(
//      PLIST_ENTRY ListHead
//      );
//

#define IsListEmpty(ListHead) \
    ((ListHead)->Flink == (ListHead))

//
//  PLIST_ENTRY
//  RemoveHeadList(
//      PLIST_ENTRY ListHead
//      );
//

#define RemoveHeadList(ListHead) \
    (ListHead)->Flink;\
    {RemoveEntryList((ListHead)->Flink)}

//
//  VOID
//  RemoveEntryList(
//      PLIST_ENTRY Entry
//      );
//

#define RemoveEntryList(Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_Flink;\
    _EX_Flink = (Entry)->Flink;\
    _EX_Blink = (Entry)->Blink;\
    _EX_Blink->Flink = _EX_Flink;\
    _EX_Flink->Blink = _EX_Blink;\
    }

//
//  VOID
//  InsertTailList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#define InsertTailList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Blink = _EX_ListHead->Blink;\
    (Entry)->Flink = _EX_ListHead;\
    (Entry)->Blink = _EX_Blink;\
    _EX_Blink->Flink = (Entry);\
    _EX_ListHead->Blink = (Entry);\
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\dd\usb\netsim\client\xirm_client.c ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    xirm_client.c

Abstract:

    Remote XInput - client code

--*/

#include "precomp.h"
#include "xinput_remote.h"

// Module name string for the debug spews
#define MYMODNAME "XIRM"

// Global critical section for synchronization
CRITICAL_SECTION XIrmCriticalSection;
#define XIrmUnlock() LeaveCriticalSection(&XIrmCriticalSection)
#define XIrmLockAndServiceNet() do { \
            EnterCriticalSection(&XIrmCriticalSection); \
            XIrmNetService(); \
        } while (0)

//
// Current state of input devices
//
DWORD XIrmCurrentDevices;
DWORD XIrmDeviceInsertions;
DWORD XIrmDeviceRemovals;

#define XIRM_OPENPORT 0x80000000
struct DeviceData {
    DWORD cookie;
    XINPUT_STATE states;
    XINPUT_CAPABILITIES devicecaps;
} XIrmDevices[XIRM_PORTMAX];

#define XIrmCookieFromHandle(hdev) (((DWORD) (hdev) >> XIRM_PORTSHIFT) | XIRM_OPENPORT)
#define XIrmPortFromHandle(hdev) ((DWORD) (hdev) & (XIRM_PORTMAX-1))
#define XIrmMakeHandle(port) ((HANDLE) ((XIrmDevices[port].cookie << XIRM_PORTSHIFT) | (port)))
#define XIrmIsDeviceOpen(port) ((XIrmDevices[port].cookie & XIRM_OPENPORT) != 0)
#define XIrmMarkDeviceAsOpened(port) (XIrmDevices[port].cookie |= XIRM_OPENPORT)
#define XIrmMarkDeviceAsClosed(port) (XIrmDevices[port].cookie &= ~XIRM_OPENPORT)

//
// Current state of the keyboard
//
#define XIRM_KEYBOARD_HANDLE 0x7fffffff
DWORD XIrmKeyboardDevice;
DWORD XIrmKeyboardPending;
HANDLE XIrmKeyboardHandle;

XINPUT_DEBUG_KEYSTROKE* XIrmKeyboardQueue;
DWORD XIrmKeyboardQueueLimit = 32;
DWORD XIrmKeyboardQueueCount;
DWORD XIrmKeyboardQueueHead;
DWORD XIrmKeyboardQueueTail;
DWORD XIrmKeyboardQueueFlags =
        XINPUT_DEBUG_KEYQUEUE_FLAG_KEYDOWN |
        XINPUT_DEBUG_KEYQUEUE_FLAG_KEYREPEAT |
        XINPUT_DEBUG_KEYQUEUE_FLAG_KEYUP;

// Current sequence numbers for the client and the server
DWORD XIrmClientSeq;
DWORD XIrmServerSeq;

// Socket for connection with the server
SOCKET XIrmSock;
CHAR XIrmPacketBuf[XIRM_MAX_PACKET_SIZE];

//
// Send an acknowledgement packet to the server
//  NOTE: ACK packets don't affect the send sequence number.
//
BOOL
XIrmSendAck()
{
    XIrmPacketHeader pkt;
    INT err;

    pkt.type = PKTTYPE_ACK;
    pkt.sendseq = XIrmClientSeq;
    pkt.ackseq = XIrmServerSeq;

    err = send(XIrmSock, (CHAR*) &pkt, sizeof(pkt), 0);
    if (err != sizeof(pkt)) {
        XDBGWRN(MYMODNAME, "send ack failed: %d, %d", err, GetLastError());
        return FALSE;
    }

    return TRUE;
}

//
// Send a SET_STATE packet to the server
//
DWORD
XIrmSendSetState(
    DWORD port,
    XINPUT_FEEDBACK* feedback
    )
{
    XIrmPacketSetState pkt;
    INT count;

    pkt.header.type = PKTTYPE_SET_STATE;
    pkt.header.sendseq = XIrmClientSeq;
    pkt.header.ackseq = XIrmServerSeq;
    pkt.port = port;
    pkt.feedback = *feedback;

    count = send(XIrmSock, (CHAR*) &pkt, sizeof(pkt), 0);
    return (count == SOCKET_ERROR) ? WSAGetLastError() : ERROR_SUCCESS;
}

//
// Handle the packet that has validated to be in sequence
//
VOID
XIrmHandlePacket(
    XIrmPacketHeader* pkt,
    INT pktlen
    )
{
    INT devcount, port;
    DWORD masks;
    XIrmPacketDeviceChanges* devchgpkt;
    XIrmPacketStateChanges* stchgpkt;
    XINPUT_CAPABILITIES* devcaps;
    XINPUT_STATE* states;
    XINPUT_DEBUG_KEYSTROKE* key;

    // Increment the next expected server sequence number
    XIrmServerSeq++;

    switch (pkt->type) {
    case PKTTYPE_DEVICE_CHANGES:
        pktlen -= offsetof(XIrmPacketDeviceChanges, devicecaps);
        ASSERT(pktlen >= 0);
        devchgpkt = (XIrmPacketDeviceChanges*) pkt;
        devcount = XIrmCountDevices(devchgpkt->active_devices);
        ASSERT(pktlen == devcount * sizeof(XINPUT_CAPABILITIES));

        XIrmCurrentDevices = masks = devchgpkt->active_devices;
        XIrmDeviceInsertions = devchgpkt->insertions;
        XIrmDeviceRemovals = devchgpkt->removals;

        // NOTE: we don't report keyboard removal.
        if ((devchgpkt->keyboard_device & 1) && !XIrmKeyboardDevice)
            XIrmKeyboardDevice = XIrmKeyboardPending = 1;

        // Update the cached device capabilities information
        devcaps = devchgpkt->devicecaps;
        for (port=0; port < XIRM_PORTMAX; port++) {
            if (masks & (1 << port))
                XIrmDevices[port].devicecaps = *devcaps++;
        }

        // If there is any change for a port, change its cookie
        masks = XIrmDeviceInsertions | XIrmDeviceRemovals;
        for (port=0; port < XIRM_PORTMAX; port++) {
            if (masks & (1 << port))
                XIrmDevices[port].cookie += 1;

            if (XIrmDeviceRemovals & (1 << port)) {
                struct DeviceData* device = &XIrmDevices[port];
                memset(&device->states, 0, sizeof(device->states));
                memset(&device->devicecaps, 0, sizeof(device->devicecaps));
            }
        }
        break;

    case PKTTYPE_STATE_CHANGES:
        pktlen -= offsetof(XIrmPacketStateChanges, states);
        ASSERT(pktlen >= 0);
        stchgpkt = (XIrmPacketStateChanges*) pkt;
        devcount = XIrmCountDevices(stchgpkt->device_masks);
        ASSERT(pktlen == devcount * sizeof(XINPUT_STATE));

        states = stchgpkt->states;
        masks = stchgpkt->device_masks;
        for (port=0; port < XIRM_PORTMAX; port++) {
            if (masks & (1 << port))
                XIrmDevices[port].states = *states++;
        }
        break;

    case PKTTYPE_KEYSTROKE:
        if (!XIrmKeyboardHandle) break;

        ASSERT(pktlen == sizeof(XIrmPacketKeystroke));
        key = &((XIrmPacketKeystroke*) pkt)->keystroke;

        // Filter out unwanted keystrokes
        if (!(key->Flags & XINPUT_DEBUG_KEYSTROKE_FLAG_KEYUP) &&
            !(XIrmKeyboardQueueFlags & XINPUT_DEBUG_KEYQUEUE_FLAG_KEYDOWN) ||
            (key->Flags & XINPUT_DEBUG_KEYSTROKE_FLAG_KEYUP) &&
            !(XIrmKeyboardQueueFlags & XINPUT_DEBUG_KEYQUEUE_FLAG_KEYUP) ||
            (key->Flags & XINPUT_DEBUG_KEYSTROKE_FLAG_REPEAT) &&
            !(XIrmKeyboardQueueFlags & XINPUT_DEBUG_KEYQUEUE_FLAG_KEYREPEAT) ||
            (key->Ascii == 0) &&
            (XIrmKeyboardQueueFlags & XINPUT_DEBUG_KEYQUEUE_FLAG_ASCII_ONLY))
            break;

        // Queue up the keystroke
        if (XIrmKeyboardQueueCount < XIrmKeyboardQueueLimit) {
            XIrmKeyboardQueueCount++;
            XIrmKeyboardQueue[XIrmKeyboardQueueTail++] = *key;
            if (XIrmKeyboardQueueTail == XIrmKeyboardQueueLimit)
                XIrmKeyboardQueueTail;
        }
        break;

    default:
        XDBGWRN(MYMODNAME, "server packet type? %d", pkt->type);
        break;
    }
}

//
// Process a received packet from the server
//

// Cached list of packets that were received out-of-sequence
typedef struct _XIrmRecvBuf {
    struct _XIrmRecvBuf* next;
    INT datalen;
    XIrmPacketHeader data;
} XIrmRecvBuf;
XIrmRecvBuf* XIrmRecvq;

INT
XIrmProcessReceivedPacket(
    INT pktlen
    )
{
    XIrmPacketHeader* pkt = (XIrmPacketHeader*) XIrmPacketBuf;
    INT index, acks;

    if (pkt->ackseq != XIrmClientSeq) {
        XDBGTRC(MYMODNAME, "server packet ack? %u, %u", pkt->ackseq, XIrmClientSeq);
    }

    index = (INT) (pkt->sendseq - XIrmServerSeq);
    if (index == 0) {
        // Normal case - in sequence packet
        acks = 1;
        XIrmHandlePacket(pkt, pktlen);

        while (XIrmRecvq && XIrmRecvq->data.sendseq == XIrmServerSeq) {
            XIrmRecvBuf* p = XIrmRecvq;
            XIrmRecvq = p->next;
            acks++;

            XIrmHandlePacket(&p->data, p->datalen);
            free(p);
        }
    } else if (index > 0 && index < XIRM_SEND_WINDOW) {
        // Out-of-sequence but inside the send window
        XIrmRecvBuf** list;
        XDBGTRC(MYMODNAME, "server packet out-of-seq: %u, %u", pkt->sendseq, XIrmServerSeq);

        list = &XIrmRecvq;
        while (*list && (*list)->data.sendseq < pkt->sendseq)
            list = &(*list)->next;
        
        if (*list && (*list)->data.sendseq == pkt->sendseq) {
            // duplicate packet - just throw it away
            XDBGTRC(MYMODNAME, "server packet duplicate");
        } else {
            XIrmRecvBuf* p;
            p = (XIrmRecvBuf*) malloc(offsetof(XIrmRecvBuf, data) + pktlen);
            if (p) {
                *list = p;
                p->next = NULL;
                p->datalen = pktlen;
                memcpy(&p->data, pkt, pktlen);
            } else {
                XDBGWRN(MYMODNAME, "out of memory");
            }
        }

        // Send an ack immediately
        acks = XIRM_DELAY_ACKS;
    } else {
        XDBGTRC(MYMODNAME,
            "server packet unexpected: %u, %u",
            pkt->sendseq,
            XIrmServerSeq);

        acks = 0;
    }

    return acks;
}

//
// Service network traffic from the server
//
VOID
XIrmNetService()
{
    // NOTE: we assume the caller has acquired the global lock at this point.
    u_long bytesavail;
    INT err, count;
    INT delayacks = 0;

    // Check if we have any data to read
    while (TRUE) {
        err = ioctlsocket(XIrmSock, FIONREAD, &bytesavail);
        if (err == NO_ERROR) {
            if (!bytesavail) break;
            count = recv(XIrmSock, XIrmPacketBuf, sizeof(XIrmPacketBuf), 0);
            if (count >= sizeof(XIrmPacketHeader)) {
                delayacks += XIrmProcessReceivedPacket(count);
                if (delayacks >= XIRM_DELAY_ACKS && XIrmSendAck())
                    delayacks = 0;
            } else {
                XDBGTRC(MYMODNAME, "server packet size? %d, %d", count, GetLastError());
            }
        } else {
            XDBGWRN(MYMODNAME, "ioctlsocket failed: %d", GetLastError());
            break;
        }
    }

    // Send the last ACK if needed
    if (delayacks) {
        XIrmSendAck();
    }
}

//
// Send out client-init broadcasts and wait for a server connection
//
VOID
XIrmFindServer()
{
    INT err, opt;
    struct sockaddr_in sockname;
    XIrmPacketClientInit initpkt;
    DWORD namelen;
    HRESULT hr;
    struct timeval timeout;
    fd_set readfds;

    // BUGBUG - spew out a debug message even on free builds
    DbgPrint("XINPUT_REMOTE: Trying to connect to a server...\n");

    // Enable broadcast on the socket
    opt = 1;
    err = setsockopt(XIrmSock, SOL_SOCKET, SO_BROADCAST, (CHAR*) &opt, sizeof(opt));
    ASSERT(err == NO_ERROR);

    XIrmClientSeq = XIrmGetISN();

    // Assemble the client-init packet
    memset(&initpkt, 0, sizeof(initpkt));
    initpkt.header.type = PKTTYPE_CLIENT_INIT;
    initpkt.header.sendseq = XIrmClientSeq++;
    initpkt.header.ackseq = 0;
    initpkt.protocol_version = XIRM_PROTOCOL_VERSION;

    // Get xbox name
    namelen = sizeof(initpkt.client_name);
    hr = DmGetXboxName(initpkt.client_name, &namelen);
    if (FAILED(hr)) {
        memset(initpkt.client_name, 0, sizeof(initpkt.client_name));
    }

    memset(&sockname, 0, sizeof(sockname));
    sockname.sin_family = AF_INET;
    timeout.tv_sec = XIRM_CLIENT_INIT_INTERVAL / 1000;
    timeout.tv_usec = (XIRM_CLIENT_INIT_INTERVAL % 1000) * 1000;

    while (TRUE) {
        XDBGTRC(MYMODNAME, "broadcast client-init: %u", initpkt.header.sendseq);

        // Broadcast the client-init packet
        sockname.sin_port = htons(XIRM_SERVER_PORT);
        sockname.sin_addr.s_addr = INADDR_BROADCAST;
        err = sendto(XIrmSock,
                     (CHAR*) &initpkt,
                     sizeof(initpkt),
                     0,
                     (struct sockaddr*) &sockname,
                     sizeof(sockname));
        ASSERT(err != SOCKET_ERROR);

        // Wait for a server to respond
        FD_ZERO(&readfds);
        FD_SET(XIrmSock, &readfds);
        err = select(1, &readfds, NULL, NULL, &timeout);

        if (err == 1) {
            // Read the packet from the server
            XIrmPacketHeader* pkt = (XIrmPacketHeader*) XIrmPacketBuf;
            INT fromlen = sizeof(sockname);
            INT count = recvfrom(
                            XIrmSock,
                            XIrmPacketBuf,
                            sizeof(XIrmPacketBuf),
                            0, 
                            (struct sockaddr*) &sockname,
                            &fromlen);

            if (count >= sizeof(*pkt)) {
                if (pkt->type == PKTTYPE_SERVER_INIT && pkt->ackseq == XIrmClientSeq) {
                    // Great - we got a connection
                    // Remember the server sequence number and proceed
                    XIrmServerSeq = pkt->sendseq+1;
                    break;
                } else {
                    XDBGTRC(MYMODNAME, "server packet type/ack? %d %u", pkt->type, pkt->ackseq);
                }
            } else {
                XDBGTRC(MYMODNAME, "server packet size? %d, %d", count, GetLastError());
            }
        } else if (err != 0) {
            XDBGWRN(MYMODNAME, "select failed: %d, %d", err, GetLastError());
        }
    }

    // Disable broadcast on the socket
    opt = 0;
    err = setsockopt(XIrmSock, SOL_SOCKET, SO_BROADCAST, (CHAR*) &opt, sizeof(opt));
    ASSERT(err == NO_ERROR);

    // Now connect the socket to the server
    err = connect(XIrmSock, (struct sockaddr*) &sockname, sizeof(sockname));
    ASSERT(err == NO_ERROR);
    XDBGTRC(MYMODNAME, "connected to server: %u.%u.%u.%u", sockname.sin_addr.S_un.S_un_b.s_b1, sockname.sin_addr.S_un.S_un_b.s_b2, sockname.sin_addr.S_un.S_un_b.s_b3, sockname.sin_addr.S_un.S_un_b.s_b4);

    // Acknowledge the server-init packet
    XIrmSendAck();

    // Wait for a while to receive the initial packets from the server
    FD_ZERO(&readfds);
    FD_SET(XIrmSock, &readfds);
    timeout.tv_sec = XIRM_RETRANSMIT_TIMEOUT / 1000;
    timeout.tv_usec = (XIRM_RETRANSMIT_TIMEOUT % 1000) * 1000;

    err = select(1, &readfds, NULL, NULL, &timeout);

    if (err == 1) {
        XIrmNetService();
    } else if (err != 0) {
        XDBGWRN(MYMODNAME, "select failed: %d, %d", err, GetLastError());
    }
}

//------------------------------------------------------------------
// Public APIs
//------------------------------------------------------------------

VOID WINAPI
XInitDevices(
    IN DWORD NumDeviceTypes,
    IN PXDEVICE_PREALLOC_TYPE DeviceTypes
    )
{
    INT err;
    WSADATA wsadata;
    struct sockaddr_in sockname;

    XDBGENT(MYMODNAME, "XInitDevices: %d %x", NumDeviceTypes, DeviceTypes);

    InitializeCriticalSection(&XIrmCriticalSection);

    // Initialize the network stack
    err = XNetStartup(NULL);
    ASSERT(err == NO_ERROR);

    err = WSAStartup(WINSOCK_VERSION, &wsadata);
    ASSERT(err == NO_ERROR);

    XIrmSock = socket(AF_INET, SOCK_DGRAM, 0);
    ASSERT(XIrmSock != INVALID_SOCKET);

    // Bind the socket to a randomly-chosen port
    memset(&sockname, 0, sizeof(sockname));
    sockname.sin_family = AF_INET;
    err = bind(XIrmSock, (struct sockaddr*) &sockname, sizeof(sockname));
    ASSERT(err == NO_ERROR);

    // Send out client-init broadcasts and wait for a server connection
    XIrmFindServer();
}

DWORD WINAPI
XGetDevices(
    IN PXPP_DEVICE_TYPE DeviceType
    )
{
    DWORD devices;

    XDBGENT(MYMODNAME, "XGetDevices: %x", DeviceType);

    XIrmLockAndServiceNet();
    if (DeviceType == XDEVICE_TYPE_GAMEPAD) {
        devices = XIrmCurrentDevices;
        XIrmDeviceInsertions = XIrmDeviceRemovals = 0;
    } else if (DeviceType == XDEVICE_TYPE_DEBUG_KEYBOARD) {
        devices = XIrmKeyboardDevice;
        XIrmKeyboardPending = 0;
    } else {
        devices = 0;
    }
    XIrmUnlock();

    return devices;
}

BOOL WINAPI
XGetDeviceChanges(
    IN PXPP_DEVICE_TYPE DeviceType,
    OUT PDWORD pInsertions,
    OUT PDWORD pRemovals
    )
{
    BOOL changed;

    XDBGENT(MYMODNAME, "XGetDeviceChanges: %x %x %x", DeviceType, pInsertions, pRemovals);

    XIrmLockAndServiceNet();
    if (DeviceType == XDEVICE_TYPE_GAMEPAD) {
        *pInsertions = XIrmDeviceInsertions;
        *pRemovals = XIrmDeviceRemovals;
        changed = (XIrmDeviceInsertions | XIrmDeviceRemovals) != 0;
        XIrmDeviceInsertions = XIrmDeviceRemovals = 0;
    } else if (DeviceType == XDEVICE_TYPE_DEBUG_KEYBOARD) {
        // Note: we don't have keyboard insertion and removal.
        *pInsertions = XIrmKeyboardPending;
        *pRemovals = 0;
        changed = XIrmKeyboardPending != 0;
        XIrmKeyboardPending = 0;
    } else {
        changed = FALSE;
    }
    XIrmUnlock();

    return changed;
}

HANDLE WINAPI
XInputOpen(
    IN PXPP_DEVICE_TYPE XppDeviceType,
    IN DWORD dwPort,
    IN DWORD dwSlot,
    IN PXINPUT_POLLING_PARAMETERS pPollingParameters OPTIONAL
    )
{
    HANDLE hdev;
    DWORD err = ERROR_SUCCESS;

    XDBGENT(MYMODNAME, "XInputOpen: %x %d %d %x",
        XppDeviceType,
        dwPort,
        dwSlot,
        pPollingParameters);

    XIrmLockAndServiceNet();

    if (XppDeviceType == XDEVICE_TYPE_GAMEPAD) {
        ASSERT(dwPort >= XDEVICE_PORT0 &&
               dwPort <= XDEVICE_PORT3 &&
               dwSlot == XDEVICE_NO_SLOT);

        if (XIrmIsDeviceOpen(dwPort)) {
            // The specified port is already open
            err = ERROR_BUSY;
        } else if (XIrmCurrentDevices & (1 << dwPort)) {
            XIrmMarkDeviceAsOpened(dwPort);
            hdev = XIrmMakeHandle(dwPort);
            err = ERROR_SUCCESS;
        } else {
            // The specified port doesn't have anything plugged in
            err = ERROR_DEVICE_NOT_CONNECTED;
        }
    } else if (XppDeviceType == XDEVICE_TYPE_DEBUG_KEYBOARD) {
        // We support at most one keyboard
        ASSERT(dwPort == XDEVICE_PORT0 && dwSlot == XDEVICE_NO_SLOT);
        if (XIrmKeyboardHandle) {
            err = ERROR_BUSY;
        } else if (XIrmKeyboardDevice == 0) {
            err = ERROR_DEVICE_NOT_CONNECTED;
        } else if (!XIrmKeyboardQueue) {
            // XInputDebugInitKeyboardQueue must be called first
            err = ERROR_INVALID_STATE;
        } else {
            hdev = XIrmKeyboardHandle = (HANDLE) XIRM_KEYBOARD_HANDLE;
            err = ERROR_SUCCESS;
        }
    } else {
        err = ERROR_CALL_NOT_IMPLEMENTED;
    }

    XIrmUnlock();

    if (err == ERROR_SUCCESS) {
        return hdev;
    } else {
        SetLastError(err);
        return NULL;
    }
}

VOID WINAPI
XInputClose(
    IN HANDLE hDevice
    )
{
    DWORD port;

    XDBGENT(MYMODNAME, "XInputClose: %x", hDevice);

    if (hDevice == NULL) return;
    XIrmLockAndServiceNet();

    if (hDevice == XIrmKeyboardHandle) {
        // Close keyboard device
        XIrmKeyboardHandle = NULL;
        XIrmKeyboardQueueCount =
        XIrmKeyboardQueueHead =
        XIrmKeyboardQueueTail = 0;
    } else {
        port = XIrmPortFromHandle(hDevice);
        if (XIrmIsDeviceOpen(port)) {
            XIrmMarkDeviceAsClosed(port);
        } else {
            XDBGWRN(MYMODNAME, "port already closed: %d", port);
        }
    }

    XIrmUnlock();
}

DWORD WINAPI
XInputGetCapabilities(
    IN HANDLE hDevice,
    OUT PXINPUT_CAPABILITIES pCapabilities
    )
{
    DWORD port;
    DWORD err = ERROR_SUCCESS;

    XDBGENT(MYMODNAME, "XInputGetCapabilities: %x %x", hDevice, pCapabilities);
    ASSERT(hDevice != NULL);
    
    XIrmLockAndServiceNet();

    port = XIrmPortFromHandle(hDevice);
    if (XIrmCookieFromHandle(hDevice) == XIrmDevices[port].cookie) {
        *pCapabilities = XIrmDevices[port].devicecaps;
    } else {
        // Device isn't opened or has been remved and reinserted
        err = ERROR_DEVICE_NOT_CONNECTED;
    }

    XIrmUnlock();
    return err;
}

DWORD WINAPI
XInputGetState(
    IN HANDLE hDevice,
    OUT PXINPUT_STATE pState
    )
{
    DWORD port;
    DWORD err = ERROR_SUCCESS;

    XDBGENT(MYMODNAME, "XInputGetState: %x %x", hDevice, pState);
    ASSERT(hDevice != NULL);
    
    XIrmLockAndServiceNet();

    port = XIrmPortFromHandle(hDevice);
    if (XIrmCookieFromHandle(hDevice) == XIrmDevices[port].cookie) {
        *pState = XIrmDevices[port].states;
    } else {
        // Device isn't opened or has been remved and reinserted
        err = ERROR_DEVICE_NOT_CONNECTED;
    }

    XIrmUnlock();
    return err;
}

DWORD WINAPI
XInputSetState(
    IN HANDLE hDevice,
    OUT PXINPUT_FEEDBACK pFeedback
    )
{
    DWORD port, err;

    XIrmLockAndServiceNet();

    port = XIrmPortFromHandle(hDevice);
    if (XIrmCookieFromHandle(hDevice) == XIrmDevices[port].cookie) {
        err = XIrmSendSetState(port, pFeedback);
    } else {
        // Device isn't opened or has been remved and reinserted
        err = ERROR_DEVICE_NOT_CONNECTED;
    }

    XIrmUnlock();
    return err;
}

DWORD WINAPI
XInputPoll(
    IN HANDLE hDevice
    )
{
    DWORD port;
    DWORD err = ERROR_SUCCESS;

    XDBGENT(MYMODNAME, "XInputPoll: %x", hDevice);
    ASSERT(hDevice != NULL);

    XIrmLockAndServiceNet();

    port = XIrmPortFromHandle(hDevice);
    if (XIrmCookieFromHandle(hDevice) != XIrmDevices[port].cookie) {
        // Device isn't opened or has been remved and reinserted
        err = ERROR_DEVICE_NOT_CONNECTED;
    }

    XIrmUnlock();
    return err;
}

DWORD WINAPI
XInputDebugInitKeyboardQueue(
    IN PXINPUT_DEBUG_KEYQUEUE_PARAMETERS pParameters OPTIONAL
    )
{
    DWORD err;
    XIrmLockAndServiceNet();

    if (XIrmKeyboardQueue) {
        // Keyboard already initialized
        err = ERROR_ALREADY_INITIALIZED;
    } else {
        if (pParameters) {
            XIrmKeyboardQueueFlags = pParameters->dwFlags;
            if (pParameters->dwQueueSize)
                XIrmKeyboardQueueLimit = pParameters->dwQueueSize;
        }

        XIrmKeyboardQueue = (XINPUT_DEBUG_KEYSTROKE*)
            malloc(XIrmKeyboardQueueLimit*sizeof(XINPUT_DEBUG_KEYSTROKE));
        err = XIrmKeyboardQueue ? ERROR_SUCCESS : ERROR_OUTOFMEMORY;
    }
    
    XIrmUnlock();
    return err;
}

DWORD WINAPI
XInputDebugGetKeystroke(
    OUT PXINPUT_DEBUG_KEYSTROKE pKeystroke
    )
{
    DWORD err;

    ASSERT(pKeystroke != NULL);
    XIrmLockAndServiceNet();

    if (!XIrmKeyboardHandle) {
        // Must have called XInputDebugInitKeyboardQueue and XInputOpen
        err = ERROR_NOT_READY;
    } else if (XIrmKeyboardQueueCount == 0) {
        err = ERROR_HANDLE_EOF;
    } else {
        XIrmKeyboardQueueCount--;
        *pKeystroke = XIrmKeyboardQueue[XIrmKeyboardQueueHead++];
        if (XIrmKeyboardQueueHead == XIrmKeyboardQueueLimit)
            XIrmKeyboardQueueHead = 0;

        err = ERROR_SUCCESS;
    }

    XIrmUnlock();
    return err;
}

DWORD WINAPI
XMountMUA(
    IN DWORD dwPort,
    IN DWORD dwSlot,
    OUT POCHAR pchDrive
    )
{
    XDBGWRN(MYMODNAME, "XMountMU not supported");
    return ERROR_CALL_NOT_IMPLEMENTED;
}

DWORD WINAPI
XUnmountMU(
    IN DWORD dwPort,
    IN DWORD dwSlot
    )
{
    XDBGWRN(MYMODNAME, "XUnmountMU not supported");
    return ERROR_CALL_NOT_IMPLEMENTED;
}

DWORD WINAPI
XMUPortFromDriveLetterA(
    OCHAR chDrive
    )
{
    XDBGWRN(MYMODNAME, "XMUPortFromDriveLetter not supported");
    return (DWORD) -1;
}

DWORD WINAPI
XMUSlotFromDriveLetterA(
    OCHAR chDrive
    )
{
    XDBGWRN(MYMODNAME, "XMUSlotFromDriveLetter not supported");
    return (DWORD) -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\dd\usb\netsim\client\test\xirmtest.c ===
#define DEBUG_KEYBOARD

#include <xtl.h>
#include <xdbg.h>

#ifdef D3DTEST
//
// One-time D3D initialization
//
#define CHECKHR(expr) do { hr = (expr); ASSERT(SUCCEEDED(hr)); } while (0)
IDirect3DDevice8* d3ddev;
VOID D3DInitialize()
{
    D3DPRESENT_PARAMETERS d3dpp;
    HRESULT hr;

    IDirect3D8* d3d = Direct3DCreate8(D3D_SDK_VERSION);
    ASSERT(d3d != NULL);

    memset(&d3dpp, 0, sizeof(d3dpp));
    d3dpp.BackBufferWidth                 = 640;
    d3dpp.BackBufferHeight                = 480;
    d3dpp.BackBufferFormat                = D3DFMT_X8R8G8B8;
    d3dpp.BackBufferCount                 = 1;
    d3dpp.Windowed                        = FALSE;
    d3dpp.EnableAutoDepthStencil          = TRUE;
    d3dpp.AutoDepthStencilFormat          = D3DFMT_D24S8;
    d3dpp.SwapEffect                      = D3DSWAPEFFECT_DISCARD;
    d3dpp.hDeviceWindow                   = NULL;
    d3dpp.FullScreen_PresentationInterval = D3DPRESENT_INTERVAL_IMMEDIATE;

    CHECKHR(IDirect3D8_CreateDevice(d3d,
                D3DADAPTER_DEFAULT,
                D3DDEVTYPE_HAL,
                NULL,
                D3DCREATE_HARDWARE_VERTEXPROCESSING,
                &d3dpp,
                &d3ddev));

    IDirect3D8_Release(d3d);

    CHECKHR(IDirect3DDevice8_Clear(d3ddev,
                0,
                NULL,
                D3DCLEAR_TARGET|D3DCLEAR_ZBUFFER,
                0x00000080,
                1.0,
                0));

    CHECKHR(IDirect3DDevice8_Present(d3ddev, NULL, NULL, NULL, NULL));
    IDirect3DDevice8_BlockUntilIdle(d3ddev);
}
#endif // D3DTEST


ULONG __cdecl DbgPrint(CHAR*, ...);

#define MAXPORTS 4
struct DeviceData {
    HANDLE handle;
    XINPUT_STATE states;
    XINPUT_CAPABILITIES devicecaps;
} devices[MAXPORTS];
DWORD active_device_masks;
HANDLE keyboard;

CHAR* GetDeviceType(UINT type)
{
    static CHAR* typestrs[3] = {
        "Gamepad",
        "Joystick",
        "Wheel"
    };

    return (type < 3) ? typestrs[type] : "<Unknown>";
}

VOID DumpThumbField(CHAR* name, SHORT old, SHORT new)
{
    if (old != new) {
        DbgPrint("  %10s: %d\n", name, new);
    }
}

VOID DumpGamepadChanges(XINPUT_GAMEPAD* oldst, XINPUT_GAMEPAD* newst)
{
    static CHAR* dbuttons[8] = {
        "UP",
        "DOWN",
        "LEFT",
        "RIGHT",
        "START",
        "BACK",
        "L-THUMB",
        "R-THUMB"
    };
    static CHAR* abuttons[8] = {
        "A",
        "B",
        "X",
        "Y",
        "BLACK",
        "WHITE",
        "L-TRIGGER",
        "R-TRIGGER"
    };

    INT i;
    DWORD dw0, dw1;

    // digital buttons
    dw0 = oldst->wButtons;
    dw1 = newst->wButtons;
    for (i=0; i < 8; i++) {
        DWORD m0 = dw0 & (1 << i);
        DWORD m1 = dw1 & (1 << i);
        if (m0 != m1) {
            DbgPrint("  %10s %s\n", dbuttons[i], m0 ? "-" : "+");
        }
    }

    // analog buttons
    for (i=0; i < 8; i++) {
        if (oldst->bAnalogButtons[i] != newst->bAnalogButtons[i]) {
            DbgPrint("  %10s %d\n", abuttons[i], newst->bAnalogButtons[i]);
        }
    }

    #define DUMPTHUMBFIELD(name) DumpThumbField(#name, oldst->s##name, newst->s##name)
    DUMPTHUMBFIELD(ThumbLX);
    DUMPTHUMBFIELD(ThumbLY);
    DUMPTHUMBFIELD(ThumbRX);
    DUMPTHUMBFIELD(ThumbRY);
}

VOID ClosePort(DWORD port)
{
    struct DeviceData* device = &devices[port];
    if (device->handle) {
        DbgPrint("Closing port %d...\n", port);
        XInputClose(device->handle);
        memset(device, 0, sizeof(*device));
    }
}

BOOL OpenPort(DWORD port)
{
    struct DeviceData* device = &devices[port];
    DWORD err;

    DbgPrint("Opening port %d...\n", port);
    if (device->handle) {
        DbgPrint("*** Port already open\n");
    }

    device->handle = XInputOpen(
                        XDEVICE_TYPE_GAMEPAD,
                        port,
                        XDEVICE_NO_SLOT,
                        NULL);

    if (device->handle == NULL) {
        DbgPrint("*** XInputOpen failed: %d\n", GetLastError());
        return FALSE;
    }

    err = XInputGetCapabilities(device->handle, &device->devicecaps);
    if (err != ERROR_SUCCESS) {
        DbgPrint("*** XInputGetCapabilities failed: %d\n", err);
        return FALSE;
    }

    DbgPrint("  device type: %s\n", GetDeviceType(device->devicecaps.SubType));
    return TRUE;
}

VOID PollInput()
{
    DWORD insertions, removals;
    DWORD port;
    static XINPUT_FEEDBACK feedback;
    XINPUT_DEBUG_KEYSTROKE key;

    // Check if there has been any device changes
    if (XGetDeviceChanges(XDEVICE_TYPE_GAMEPAD, &insertions, &removals)) {
        DbgPrint("Device changes: in = %x out = %x\n", insertions, removals);

        // close devices that have been removed
        for (port=0; port < MAXPORTS; port++) {
            if (removals & (1 << port)) {
                if (devices[port].handle) {
                    ClosePort(port);
                }
            }
        }

        // open devices that have been inserted
        for (port=0; port < MAXPORTS; port++) {
            if (insertions & (1 << port)) {
                if (!OpenPort(port)) {
                    // If we failed to open the port, treat it as not plugged in
                    removals |= (1 << port);
                    insertions &= ~(1 << port);
                    ClosePort(port);
                }
            }
        }

        active_device_masks &= ~removals;
        active_device_masks |= insertions;
        DbgPrint("  active devices: %x\n", active_device_masks);
    }

    // Now for currently inserted devices, update the state information
    for (port=0; port < MAXPORTS; port++) {
        struct DeviceData* device = &devices[port];
        if (device->handle) {
            XINPUT_STATE states;
            DWORD err = XInputGetState(device->handle, &states);
            if (err == ERROR_SUCCESS) {
                if (memcmp(&device->states, &states, sizeof(states)) != 0) {
                    DbgPrint("Input state change: port %d\n", port);
                    DumpGamepadChanges(&device->states.Gamepad, &states.Gamepad);

                    if (states.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_X] !=
                        device->states.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_X]) {
                        feedback.Rumble.wLeftMotorSpeed =
                            (WORD) states.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_X] << 8;
                        DbgPrint("Rumble-L: %d\n", feedback.Rumble.wLeftMotorSpeed);
                        err = XInputSetState(device->handle, &feedback);
                        if (err != ERROR_SUCCESS) {
                            DbgPrint("*** XInputSetState failed: %d\n", err);
                        }
                    }

                    device->states = states;
                }
            } else {
                DbgPrint("*** XInputGetState failed: %d\n", err);
            }
        }
    }

    // Poll keystrokes
    #define DumpKeyFlags(f) \
            if (key.Flags & XINPUT_DEBUG_KEYSTROKE_FLAG_##f) { DbgPrint(" %s", #f); }
    while (XInputDebugGetKeystroke(&key) == ERROR_SUCCESS) {
        DbgPrint("Keystroke: ");
        DbgPrint(isprint(key.Ascii) ? "%c " : "%02x", key.Ascii);
        DbgPrint(" %02x", key.VirtualKey);
        DumpKeyFlags(KEYUP);
        DumpKeyFlags(REPEAT);
        DumpKeyFlags(CTRL);
        DumpKeyFlags(SHIFT);
        DumpKeyFlags(ALT);
        DumpKeyFlags(CAPSLOCK);
        DumpKeyFlags(NUMLOCK);
        DumpKeyFlags(SCROLLLOCK);
        DbgPrint("\n");
    }
}

VOID InitKeyboardDevice()
{
    DWORD err, devices;

    err = XInputDebugInitKeyboardQueue(NULL);
    if (err == ERROR_SUCCESS) {
        devices = XGetDevices(XDEVICE_TYPE_DEBUG_KEYBOARD);
        if (devices & 1) {
            keyboard = XInputOpen(
                            XDEVICE_TYPE_DEBUG_KEYBOARD,
                            XDEVICE_PORT0,
                            XDEVICE_NO_SLOT,
                            NULL);
        }
    }

    if (keyboard) DbgPrint("Keyboard initialized.\n");
}

void __cdecl main()
{
    DbgPrint("Starting XInput Remote tests...\n");
    XInitDevices(0, NULL);
    InitKeyboardDevice();

    #ifdef D3DTEST
    D3DInitialize();
    #endif

    while (TRUE) {
        PollInput();
        Sleep(20);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\dd\usb\netsim\win2k\xbinput.cpp ===
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <winsock2.h>
#include <xboxdbg.h>

extern "C" {
#include "xboxstub.h"
#include "xinput_remote.h"
}

#define DIRECTINPUT_VERSION 0x0700
#include <initguid.h>
#include <dinput.h>

CHAR* programname;
HINSTANCE appinstance;
HWND hwndmain;
BOOL hasfocus;
SOCKET sock, listensock;
HANDLE recvevt;
CHAR recvbuf[XIRM_MAX_PACKET_SIZE];
CHAR clientname[XIRM_MACHINE_NAME_MAXLEN];
CHAR xboxname[XIRM_MACHINE_NAME_MAXLEN];
ULONG clientaddr;
INT connected;
DWORD connecttime;
DWORD clientisn, clientseq;
DWORD serverseq_una, serverseq_nxt;
INT fastrexmit, rexmit_timer, rexmit_count;
BOOL rexmit_disabled;
IDirectInput7* dinput7;

//
// Pending connection request
//
struct ConnectionRequest {
    BOOL active;
    DWORD clientisn;
    struct sockaddr_in clientaddr;
    CHAR clientname[XIRM_MACHINE_NAME_MAXLEN];
} connection_request;
CRITICAL_SECTION connection_request_lock;

#define ConnectReqLock()    EnterCriticalSection(&connection_request_lock)
#define ConnectReqUnlock()  LeaveCriticalSection(&connection_request_lock)
#define HasPendingConnectReq() (connection_request.active)

//
// Send queue
//
#define GetSendqHead() ((SendBuf*) sendq.Flink)
#define GetSendqLen() ((INT) (serverseq_nxt - serverseq_una))
#define IsSendqFull() (GetSendqLen() >= XIRM_SEND_WINDOW)
#define IsSendqEmpty() (serverseq_una == serverseq_nxt)

LIST_ENTRY sendq;
typedef struct _SendBuf {
    LIST_ENTRY links;
    INT datalen;
    XIrmPacketHeader data;
} SendBuf;

//
// Device state information
//
DWORD device_count;
XINPUT_CAPABILITIES device_caps;
struct DeviceData {
    GUID guid_instance;
    IDirectInputDevice7* indev7;
    XINPUT_GAMEPAD current_states;
    XINPUT_GAMEPAD last_states;
} devices[XIRM_PORTMAX];

//
// InterAct HammerHead FX product GUID and capabilities
//
const GUID HammerHeadGuid = {
    0x262A05FD,
    0,
    0,
    { 0x00, 0x00, 0x50, 0x49, 0x44, 0x56, 0x49, 0x44 }
};

//
// Main server loop sampling interval (10 msecs = 100Hz)
//
#define SAMPLING_INTERVAL 10


//
// Error handling functions
//
inline VOID errormsg(CHAR* msg) {
    MessageBox(hwndmain, msg, programname, MB_OK|MB_ICONERROR);
}

VOID error(CHAR* format, ...)
{
    CHAR buf[1024];
    va_list arglist;

    va_start(arglist, format);
    vsprintf(buf, format, arglist);
    va_end(arglist);

    errormsg(buf);
    exit(-1);
}

#define ASSERT(cond) do { if (!(cond)) assert(__LINE__, #cond); } while(0)
VOID assert(INT line, CHAR* msg)
{
    error("Assertion failed: line %d\n"
          "  %s\n"
          "  error code = %d",
          line, msg, GetLastError());
}

VOID usage()
{
    CHAR buf[256];

    sprintf(buf, "usage: %s [-x xboxname]", programname);
    errormsg(buf);
    exit(1);
}

//
// Initialize the input module
//
BOOL CALLBACK EnumDevicesCallback(LPCDIDEVICEINSTANCE lpddi, LPVOID pvRef)
{
    if (memcmp(&lpddi->guidProduct, &HammerHeadGuid, sizeof(HammerHeadGuid)) == 0 &&
        device_count < XIRM_PORTMAX) {
        devices[device_count++].guid_instance = lpddi->guidInstance;
    }
    return DIENUM_CONTINUE;
}

VOID InitInput()
{
    //
    // Initialize DirectInput
    //
    HRESULT hr;
    hr= DirectInputCreateEx(
            appinstance,
            DIRECTINPUT_VERSION,
            IID_IDirectInput7,
            (VOID**) &dinput7,
            NULL);

    ASSERT(SUCCEEDED(hr)); 

    //
    // Enumerate attached HammerHead controllers
    //
    hr = dinput7->EnumDevices(
            DIDEVTYPE_JOYSTICK ,
            EnumDevicesCallback,
            0,
            DIEDFL_ATTACHEDONLY);

    if (device_count == 0) {
        error("Found no HammerHead controller.");
    }

    //
    // Acquire all enumerated controllers for exclusive access
    //
    for (DWORD i=0; i < device_count; i++) {
        IDirectInputDevice7* indev7;
        hr = dinput7->CreateDeviceEx(
                devices[i].guid_instance,
                IID_IDirectInputDevice7,
                (VOID**) &indev7,
                NULL);

        if (FAILED(hr)) break;

        hr = indev7->SetDataFormat(&c_dfDIJoystick);
        if (FAILED(hr)) break;
        
        DIPROPDWORD prop;
        prop.diph.dwSize = sizeof(prop);
        prop.diph.dwHeaderSize = sizeof(prop.diph);
        prop.diph.dwObj = 0;
        prop.diph.dwHow = DIPH_DEVICE;
        prop.dwData = DIPROPAXISMODE_ABS;
        hr = indev7->SetProperty(DIPROP_AXISMODE, &prop.diph);
        if (FAILED(hr)) break;

        hr = indev7->SetCooperativeLevel(hwndmain, DISCL_EXCLUSIVE|DISCL_BACKGROUND);
        if (FAILED(hr)) break;

        hr = indev7->Acquire();
        if (FAILED(hr)) break;
        devices[i].indev7 = indev7;
    }

    if (i != device_count) {
        error("Failed to acquire controller %d: %x", i, hr);
    }

    XINPUT_GAMEPAD* gamepad = &device_caps.In.Gamepad;
    device_caps.SubType = XINPUT_DEVSUBTYPE_GC_GAMEPAD;
    gamepad->wButtons = 0xff;
    memset(gamepad->bAnalogButtons, 0x80, 8);
    gamepad->sThumbLX =
    gamepad->sThumbLY =
    gamepad->sThumbRX =
    gamepad->sThumbRY = (SHORT) 0xff00;
}

//
// Transmit the first packet in the send queue
//
#define SetRexmitTimer() (rexmit_timer = GetTickCount() + XIRM_RETRANSMIT_TIMEOUT)
inline VOID EnableRexmit() {
    if (rexmit_disabled) {
        rexmit_disabled = FALSE;
        rexmit_count = 1;
    }
}

VOID SendqXmit(SendBuf* sendbuf)
{
    send(sock, (CHAR*) &sendbuf->data, sendbuf->datalen, 0);
    if (sendbuf == GetSendqHead()) {
        SetRexmitTimer();
    }
    rexmit_count++;
    fastrexmit = 0;
}

//
// Do retransmission if needed
//
VOID CheckRexmit()
{
    if (rexmit_disabled || IsSendqEmpty()) return;

    if ((INT) (rexmit_timer - GetTickCount()) < 0) {
        if (rexmit_count >= XIRM_RETRANSMIT_RETRY) {
            // If too many retries, we assume the client is down
            // and stop retransmitting until we receive a packet
            // from the client or there is an input state change.
            rexmit_disabled = TRUE;
        } else {
            SendqXmit(GetSendqHead());
        }
    }
}

//
// Insert a new send buffer to the end of the send queue
// and then transmit it out to the client
//
VOID InsertSendBuf(SendBuf* sendbuf)
{
    if (IsListEmpty(&sendq)) rexmit_count = 0;

    InsertTailList(&sendq, &sendbuf->links);
    SendqXmit(sendbuf);
}

//
// Allocate memory buffer for a new outgoing packet
//
SendBuf* AllocSendBuf(INT size)
{
    SendBuf* sendbuf = (SendBuf*) malloc(offsetof(SendBuf, data) + size);

    if (sendbuf) {
        sendbuf->datalen = size;
        sendbuf->data.sendseq = serverseq_nxt++;
        sendbuf->data.ackseq = clientseq;
    }
    return sendbuf;
}

//
// Send device changes to the client
//
VOID
SendDeviceChanges()
{
    SendBuf* sendbuf;
    XIrmPacketDeviceChanges* devchgpkt;
    INT pktlen;

    pktlen = offsetof(XIrmPacketDeviceChanges, devicecaps) +
             device_count * sizeof(XINPUT_CAPABILITIES);
    sendbuf = AllocSendBuf(pktlen);
    if (!sendbuf) return;

    devchgpkt = (XIrmPacketDeviceChanges*) &sendbuf->data;
    devchgpkt->header.type = PKTTYPE_DEVICE_CHANGES;

    devchgpkt->keyboard_device = 1;
    devchgpkt->active_devices = 
    devchgpkt->insertions = (1 << device_count) - 1;
    devchgpkt->removals = 0;

    for (DWORD i=0; i < device_count; i++)
        devchgpkt->devicecaps[i] = device_caps;

    // Start retransmission again if input state has changed
    EnableRexmit();
    InsertSendBuf(sendbuf);
}

//
// Send input state changes to the client
//
VOID SendStateChanges()
{
    static DWORD pktnumber;
    SendBuf* sendbuf;
    XIrmPacketStateChanges* stchgpkt;
    
    // Send queue is full, do nothing during this interval
    if (IsSendqFull()) return;

    // Check to see if anything has changed
    DWORD masks = 0;
    INT pktlen = 0;
    for (DWORD i=0; i < device_count; i++) {
        if (memcmp(&devices[i].current_states,
                   &devices[i].last_states,
                   sizeof(XINPUT_GAMEPAD)) != 0) {
            masks |= (1 << i);
            pktlen++;
        }
    }
    if (masks == 0) return;

    pktlen = offsetof(XIrmPacketStateChanges, states) + pktlen*sizeof(XINPUT_STATE);
    sendbuf = AllocSendBuf(pktlen);
    if (!sendbuf) return;

    stchgpkt = (XIrmPacketStateChanges*) &sendbuf->data;
    stchgpkt->header.type = PKTTYPE_STATE_CHANGES;
    stchgpkt->device_masks = masks;

    XINPUT_STATE* states = stchgpkt->states;
    for (i=0; i < XIRM_PORTMAX; i++) {
        if (masks & (1 << i)) {
            states->Gamepad = devices[i].last_states = devices[i].current_states;
            states->dwPacketNumber = pktnumber++;
        }
    }

    // Start retransmission again if input state has changed
    EnableRexmit();
    InsertSendBuf(sendbuf);
}

//
// Poll the current state of the controllers
//
#define BUTTON_MAP1(x, w) \
        if (joystate.rgbButtons[w-1] & 0x80) buttons |= x

#define BUTTON_MAP2(x, w) \
        xstate->bAnalogButtons[x] = (joystate.rgbButtons[w-1] & 0x80)

#define BUTTON_MAP3(d) \
        buttons |= XINPUT_GAMEPAD_DPAD_##d

#define BUTTON_MAP4(d1, d2) \
        buttons |= (XINPUT_GAMEPAD_DPAD_##d1 | XINPUT_GAMEPAD_DPAD_##d2)

#define BUTTON_MAP5(x, w) \
        xstate->x = MapThumbValue(joystate.w)

inline SHORT MapThumbValue(LONG val) {
    // convert from range 0-ffff to 0-ff
    val = (val >> 8) & 0xff;

    // 0 - 8000
    // 7f and 80 - 0
    // ff - 7fff
    return (SHORT) ((val == 0x7f || val == 0x80) ? 0 : ((val | (val << 8)) - 0x8000));
}

VOID PollInput()
{
    IDirectInputDevice7* indev7;
    HRESULT hr;
    DIJOYSTATE joystate;

    if (!connected) return;

    for (DWORD i=0; i < device_count; i++) {
        indev7 = devices[i].indev7;
        
        memset(&joystate, 0, sizeof(joystate));
        indev7->Poll();
        hr = indev7->GetDeviceState(sizeof(joystate), &joystate);
        if (FAILED(hr)) continue;

        // Map the buttons
        XINPUT_GAMEPAD* xstate = &devices[i].current_states;
        DWORD buttons = 0;

        BUTTON_MAP1(XINPUT_GAMEPAD_LEFT_THUMB, 9);
        BUTTON_MAP1(XINPUT_GAMEPAD_RIGHT_THUMB, 10);
        BUTTON_MAP1(XINPUT_GAMEPAD_START, 11);
        BUTTON_MAP1(XINPUT_GAMEPAD_BACK, 12);

        BUTTON_MAP2(XINPUT_GAMEPAD_X, 1);
        BUTTON_MAP2(XINPUT_GAMEPAD_Y, 2);
        BUTTON_MAP2(XINPUT_GAMEPAD_WHITE, 3);
        BUTTON_MAP2(XINPUT_GAMEPAD_A, 4);
        BUTTON_MAP2(XINPUT_GAMEPAD_B, 5);
        BUTTON_MAP2(XINPUT_GAMEPAD_BLACK, 6);
        BUTTON_MAP2(XINPUT_GAMEPAD_B, 5);
        BUTTON_MAP2(XINPUT_GAMEPAD_LEFT_TRIGGER, 7);
        BUTTON_MAP2(XINPUT_GAMEPAD_RIGHT_TRIGGER, 8);
        
        DWORD pov = (joystate.rgdwPOV[0] & 0xffff);
        if (pov != 0xffff) {
            switch ((pov / 4500) % 8) {
            case 0:
                BUTTON_MAP3(UP); break;
            case 1:
                BUTTON_MAP4(UP,RIGHT); break;
            case 2:
                BUTTON_MAP3(RIGHT); break;
            case 3:
                BUTTON_MAP4(RIGHT,DOWN); break;
            case 4:
                BUTTON_MAP3(DOWN); break;
            case 5:
                BUTTON_MAP4(DOWN,LEFT); break;
            case 6:
                BUTTON_MAP3(LEFT); break;
            case 7:
                BUTTON_MAP4(LEFT,UP); break;
            }
        }
        xstate->wButtons = (WORD) buttons;

        joystate.lY ^= 0xffff;
        joystate.lRz ^= 0xffff;
        
        BUTTON_MAP5(sThumbLX, lX);
        BUTTON_MAP5(sThumbLY, lY);
        BUTTON_MAP5(sThumbRX, lZ);
        BUTTON_MAP5(sThumbRY, lRz);
    }

    SendStateChanges();
}

//
// Process an acknowledgement packet from the client
//
VOID ProcessClientAck(XIrmPacketHeader* pkt)
{
    DWORD ack;
    INT index, sent;

    ack = pkt->ackseq;
    index = (INT) (ack - serverseq_una);
    sent = GetSendqLen();

    if (index > 0 && index <= sent) {
        // The acknowledgement is valid
        ASSERT(!IsListEmpty(&sendq));
        serverseq_una = ack;

        do {
            SendBuf* sendbuf = GetSendqHead();
            if (sendbuf->data.sendseq == ack) {
                SetRexmitTimer();
                rexmit_count = 1;
                fastrexmit = 0;
                break;
            }
            RemoveHeadList(&sendq);
            free(sendbuf);
        } while (!IsListEmpty(&sendq));

    } else if (index == 0 && sent != 0) {
        // Fast retransmit
        if (++fastrexmit >= 2) {
            SendqXmit(GetSendqHead());
        }
    }
}

//
// Service network traffic from the client
//
VOID
ServiceClient()
{
    static BOOL pending = FALSE;
    static WSAOVERLAPPED overlapped;

    XIrmPacketHeader* pkt;
    DWORD bytesrecv, flags;
    INT err;

    while (TRUE) {
        // Issue the overlapped recv request if necessary
        if (!pending) {
            WSABUF wsabuf;
            wsabuf.buf = recvbuf;
            wsabuf.len = sizeof(recvbuf);
            flags = 0;
            overlapped.hEvent = recvevt;
            err = WSARecv(sock, &wsabuf, 1, &bytesrecv, &flags, &overlapped, NULL);
            if (err == SOCKET_ERROR) {
                err = WSAGetLastError();
                if (err == WSA_IO_PENDING) {
                    pending = TRUE;
                } else {
                    // recv failed, try again
                    continue;
                }
            }
        }

        // If an overlapped recv request is pending,
        // check to see if it's completed yet.
        if (pending) {
            if (!WSAGetOverlappedResult(sock, &overlapped, &bytesrecv, FALSE, &flags)) {
                err = WSAGetLastError();
                if (err == WSA_IO_INCOMPLETE) return;

                //
                // This is very bad -
                //  cancel the pending recv request and try to issue a new one
                //
                CancelIo((HANDLE) sock);
                pending = FALSE;
                continue;
            }
            pending = FALSE;
        }

        // Client must be alive again - enable retransmission
        EnableRexmit();

        // The only packet type we care about is ACK
        pkt = (XIrmPacketHeader*) recvbuf;
        if (bytesrecv == sizeof(XIrmPacketHeader) &&
            pkt->type == PKTTYPE_ACK) {
            ProcessClientAck(pkt);
        }
    }
}

//
// Initialize the connection with the client
//
VOID InitClient(struct ConnectionRequest* connreq)
{
    SendBuf* sendbuf;
    INT err;

    connected++;
    strcpy(clientname, connreq->clientname);
    clientaddr = connreq->clientaddr.sin_addr.s_addr;
    err = connect(sock, (struct sockaddr*) &connreq->clientaddr, sizeof(connreq->clientaddr));
    ASSERT(err == NO_ERROR);

    // Force a window update
    InvalidateRect(hwndmain, NULL, TRUE);

    connecttime = GetTickCount();
    rexmit_disabled = FALSE;
    clientisn = connreq->clientisn;
    clientseq = clientisn+1;
    serverseq_una = serverseq_nxt = XIrmGetISN();

    while (!IsListEmpty(&sendq)) {
        LIST_ENTRY* p = RemoveHeadList(&sendq);
        free(p);
    }

    sendbuf = AllocSendBuf(sizeof(XIrmPacketHeader));
    ASSERT(sendbuf != NULL);
    sendbuf->data.type = PKTTYPE_SERVER_INIT;
    InsertSendBuf(sendbuf);

    // Send the initial device caps and states
    for (DWORD i=0; i < device_count; i++) {
        memset(&devices[i].last_states, 0, sizeof(XINPUT_GAMEPAD));
    }
    SendDeviceChanges();
    
    PollInput();
}

//
// Process a client-init packet from the client
//
VOID ProcessClientInit()
{
    struct ConnectionRequest connreq;

    // Retrieve information about the pending connection request
    ConnectReqLock();
    connreq = connection_request;
    connection_request.active = FALSE;
    ConnectReqUnlock();

    if (clientname[0] && strcmp(clientname, connreq.clientname) == 0 ||
        clientaddr == connreq.clientaddr.sin_addr.s_addr) {
        if (connected) {
            // We were connected to the client already.
            // Check to see if this client-init packet is a duplicate
            // or if the client has been rebooted.
            INT time = GetTickCount() - connecttime;
            if (connreq.clientisn == clientisn && time >= 0 && time <= 3000) return;
        }
        InitClient(&connreq);

        // For first time connection, start the overlapped receive request
        if (connected == 1) {
            ServiceClient();
        }
    }
}

//
// Handle keyboard events
//
VOID HandleKeyEvents(INT vkey, INT flags, BOOL keydown)
{
    SendBuf* sendbuf;
    XIrmPacketKeystroke* kbdpkt;
    BYTE xflags = 0;

    // Send queue is full, drop the keystroke
    if (!connected || IsSendqFull()) return;

    sendbuf = AllocSendBuf(sizeof(XIrmPacketKeystroke));
    if (!sendbuf) return;

    kbdpkt = (XIrmPacketKeystroke*) &sendbuf->data;
    kbdpkt->header.type = PKTTYPE_KEYSTROKE;

    kbdpkt->keystroke.VirtualKey = (BYTE) vkey;
    kbdpkt->keystroke.Ascii = (CHAR) MapVirtualKey(vkey, 2);
    
    if (!keydown) xflags |= XINPUT_DEBUG_KEYSTROKE_FLAG_KEYUP;
    if (keydown && (flags & (1 << 30))) xflags |= XINPUT_DEBUG_KEYSTROKE_FLAG_REPEAT;
    if (GetKeyState(VK_SHIFT) & 0x8000) xflags |= XINPUT_DEBUG_KEYSTROKE_FLAG_SHIFT;
    if (GetKeyState(VK_CONTROL) & 0x8000) xflags |= XINPUT_DEBUG_KEYSTROKE_FLAG_CTRL;
    if (GetKeyState(VK_MENU) & 0x8000) xflags |= XINPUT_DEBUG_KEYSTROKE_FLAG_ALT;
    if (GetKeyState(VK_CAPITAL) & 1) xflags |= XINPUT_DEBUG_KEYSTROKE_FLAG_CAPSLOCK;
    if (GetKeyState(VK_NUMLOCK) & 1) xflags |= XINPUT_DEBUG_KEYSTROKE_FLAG_NUMLOCK;
    if (GetKeyState(VK_SCROLL) & 1) xflags |= XINPUT_DEBUG_KEYSTROKE_FLAG_SCROLLLOCK;
    kbdpkt->keystroke.Flags = xflags;

    // Start retransmission again if input state has changed
    EnableRexmit();
    InsertSendBuf(sendbuf);
}

//
// Handle window repaint event
//
VOID DoPaint(HWND hwnd)
{
    static HFONT font;
    HDC hdc;
    PAINTSTRUCT ps;
    CHAR* p;
    INT x, y;
    CHAR buf[64];

    hdc = BeginPaint(hwnd, &ps);

    if (font == NULL) {
        LOGFONT lf;
        INT mmy = GetDeviceCaps(hdc, VERTSIZE);
        INT pixy = GetDeviceCaps(hdc, VERTRES);
        double pt = pixy * 25.4 / (mmy * 72);

        memset(&lf, 0, sizeof(lf));
        lf.lfHeight = -(INT) (10 * pt);
        lf.lfWeight = FW_BOLD;
        strcpy(lf.lfFaceName, "Arial");
        font = CreateFontIndirect(&lf);
    }

    SetBkMode(hdc, TRANSPARENT);
    SetTextColor(hdc, RGB(0, 255, 0));
    SelectObject(hdc, font);

    x = 5;
    y = 0;
    if (connected) {
        sprintf(buf, "Connected to client (%d):", connected);
        p = buf;
    } else {
        p = "Waiting for client connection...";
    }
    TextOut(hdc, x, y, p, strlen(p));

    if (clientname[0]) {
        p = clientname;
        y += 20;
        TextOut(hdc, x, y, p, strlen(p));
    }

    if (clientaddr) {
        p = inet_ntoa(*((struct in_addr*) &clientaddr));
        y += 20;
        TextOut(hdc, x, y, p, strlen(p));
    }

    EndPaint(hwnd, &ps);
}

//
// Window callback procedure
//
LRESULT CALLBACK MyWindowProc(HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam)
{
    switch (msg) {
    case WM_PAINT:
        DoPaint(hwnd);
        break;

    case WM_SETFOCUS:
        hasfocus = TRUE;
        break;

    case WM_KILLFOCUS:
        hasfocus = FALSE;
        break;

    case WM_DESTROY:
        PostQuitMessage(0);
        break;

    case WM_KEYDOWN:
    case WM_KEYUP:
        HandleKeyEvents(wparam, lparam, msg==WM_KEYDOWN);
        break;

    case WM_SYSKEYDOWN:
    case WM_SYSKEYUP:
        HandleKeyEvents(wparam, lparam, msg==WM_SYSKEYDOWN);
        // fall through to the default winproc

    default:
        return DefWindowProc(hwnd, msg, wparam, lparam);
    }

    return 0;
}

//
// Create the main application window
//
VOID CreateMainWindow()
{
    HBITMAP bitmap;
    BITMAP bmpinfo;
    HBRUSH brush;
    LOGBRUSH logbrush;
    INT ret;

    WNDCLASS wndclass = {
        0,
        MyWindowProc,
        0,
        0,
        appinstance,
        LoadIcon(appinstance, MAKEINTRESOURCE(128)),
        LoadCursor(NULL, IDC_ARROW),
        NULL,
        NULL,
        "XBINPUT"
    };

    // Load the background bitmap
    bitmap = LoadBitmap(appinstance, MAKEINTRESOURCE(128));
    ASSERT(bitmap != NULL);
    ret = GetObject(bitmap, sizeof(bmpinfo), &bmpinfo);
    ASSERT(ret != 0);

    // Create the pattern brush
    logbrush.lbStyle = BS_PATTERN;
    logbrush.lbColor = 0;
    logbrush.lbHatch = (LONG) bitmap;
    brush = CreateBrushIndirect(&logbrush);
    ASSERT(brush != NULL);

    wndclass.hbrBackground = brush;
    RegisterClass(&wndclass);

    hwndmain = CreateWindowEx(
                    WS_EX_APPWINDOW|WS_EX_OVERLAPPEDWINDOW,
                    "XBINPUT",
                    programname,
                    WS_POPUPWINDOW|WS_CAPTION|WS_MINIMIZEBOX,
                    CW_USEDEFAULT,
                    CW_USEDEFAULT,
                    bmpinfo.bmWidth +
                        2*GetSystemMetrics(SM_CXFIXEDFRAME),
                    bmpinfo.bmHeight +
                        2*GetSystemMetrics(SM_CYFIXEDFRAME) +
                        GetSystemMetrics(SM_CYCAPTION),
                    NULL,
                    NULL,
                    appinstance,
                    NULL);

    ASSERT(hwndmain != NULL);
    ShowWindow(hwndmain, SW_SHOW);
}

//
// Server loop
//
VOID RunServer()
{
    MSG msg;
    DWORD wait;

    while (TRUE) {
        // NOTE: We can't call MsgWaitForMultipleObjects when we're inactive
        //  because it doesn't return long after the event is signaled.
        if (hasfocus) {
            wait = MsgWaitForMultipleObjects(1, &recvevt, FALSE, SAMPLING_INTERVAL, QS_ALLEVENTS);
        } else {
            wait = WaitForSingleObject(recvevt, SAMPLING_INTERVAL);
        }

        // Process client packets
        if (wait == WAIT_OBJECT_0) {
            ServiceClient();
        }

        // Check if there is any pending connection request
        if (HasPendingConnectReq()) {
            ProcessClientInit();
        }
        
        // Process window messages
        while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {
            if (msg.message == WM_QUIT) return;
            DispatchMessage(&msg);
        }

        // Check input state changes
        PollInput();

        // Do retransmit if necessary
        CheckRexmit();
    }
}

//
// Initialize network stack
//
VOID InitNet()
{
    INT err;
    WSADATA wsadata;
    struct sockaddr_in sockname;

    err = WSAStartup(WINSOCK_VERSION, &wsadata);
    ASSERT(err == NO_ERROR);

    sock = socket(AF_INET, SOCK_DGRAM, 0);
    ASSERT(sock != INVALID_SOCKET);

    memset(&sockname, 0, sizeof(sockname));
    sockname.sin_family = AF_INET;
    err = bind(sock, (struct sockaddr*) &sockname, sizeof(sockname));
    ASSERT(err == NO_ERROR);

    listensock = socket(AF_INET, SOCK_DGRAM, 0);
    ASSERT(listensock != INVALID_SOCKET);

    sockname.sin_port = htons(XIRM_SERVER_PORT);
    err = bind(listensock, (struct sockaddr*) &sockname, sizeof(sockname));
    ASSERT(err == NO_ERROR);
}

//
// Server thread that listens for incoming client connection requests
//
DWORD WINAPI ListenThreadProc(VOID* param)
{
    CHAR buf[XIRM_MAX_PACKET_SIZE];
    struct sockaddr sockname;
    struct sockaddr_in* sockin;
    XIrmPacketClientInit* initpkt;

    initpkt = (XIrmPacketClientInit*) buf;
    memset(&sockname, 0, sizeof(sockname));
    sockin = (struct sockaddr_in*) &sockname;

    while (TRUE) {
        INT fromlen = sizeof(sockname);
        INT count = recvfrom(listensock, buf, sizeof(buf), 0, &sockname, &fromlen);

        if (count != sizeof(*initpkt) ||
            initpkt->header.type != PKTTYPE_CLIENT_INIT ||
            initpkt->protocol_version != XIRM_PROTOCOL_VERSION) {
            continue;
        }

        ConnectReqLock();
        connection_request.clientisn = initpkt->header.sendseq;
        connection_request.clientaddr = *sockin;
        memcpy(connection_request.clientname, initpkt->client_name, XIRM_MACHINE_NAME_MAXLEN-1);
        connection_request.active = TRUE;
        ConnectReqUnlock();
    }
}

INT __cdecl main(INT argc, CHAR** argv)
{
    HANDLE thread;
    DWORD tid;
    HRESULT hr;

    appinstance = GetModuleHandle(NULL);
    programname = *argv++;
    argc--;

    hr = CoInitialize(NULL);
    ASSERT(SUCCEEDED(hr));

    InitializeCriticalSection(&connection_request_lock);
    InitializeListHead(&sendq);
    recvevt = WSACreateEvent();
    ASSERT(recvevt != NULL);

    // Parse command line arguments
    while (argc) {
        CHAR* opt = *argv++;
        argc--;

        if (strcmp(opt, "-x") == 0 && argc > 0 &&
            strlen(*argv) < XIRM_MACHINE_NAME_MAXLEN && !xboxname[0]) {
            strcpy(xboxname, *argv);
            argv++;
            argc--;
        } else {
            usage();
        }
    }

    // Initialize network stack
    InitNet();

    if (xboxname[0]) {
        hr = DmSetXboxName(xboxname);
    } else {
        DWORD size = sizeof(xboxname);
        hr = DmGetXboxName(xboxname, &size);
    }

    if (FAILED(hr)) {
        error("Failed to determine the client xbox name");
    }

    clientaddr = inet_addr(xboxname);
    if (clientaddr == INADDR_NONE) clientaddr = 0;
    if (!clientaddr) {
        strcpy(clientname, xboxname);
    }

    // Create the main application window
    CreateMainWindow();

    // Initialize input
    InitInput();

    // Create server listening thread
    thread = CreateThread(NULL, 0, ListenThreadProc, NULL, 0, &tid);
    ASSERT(thread != NULL);
    CloseHandle(thread);

    RunServer();

    CoUninitialize();
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\dd\usb\netsim\inc\xinput_remote.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    xinput_remote.h

Abstract:

    Remote XInput protocol declarations

--*/

#ifndef _XINPUT_REMOTE_H
#define _XINPUT_REMOTE_H

//
// XIrm packet format
//
typedef struct _XIrmPacketHeader {
    // Packet type
    DWORD type;

    #define PKTTYPE_CLIENT_INIT     1
    #define PKTTYPE_SERVER_INIT     2
    #define PKTTYPE_DEVICE_CHANGES  3
    #define PKTTYPE_STATE_CHANGES   4
    #define PKTTYPE_SET_STATE       5
    #define PKTTYPE_ACK             6
    #define PKTTYPE_KEYSTROKE       7

    // Sender sequence number
    DWORD sendseq;

    // Acknowledgement sequence number
    DWORD ackseq;
} XIrmPacketHeader;

// for PKTTYPE_CLIENT_INIT
#define XIRM_MACHINE_NAME_MAXLEN 32
#define XIRM_CLIENT_INIT_INTERVAL 1000 // msecs
typedef struct _XIrmPacketClientInit {
    XIrmPacketHeader header;
    DWORD protocol_version;
    CHAR client_name[XIRM_MACHINE_NAME_MAXLEN];
} XIrmPacketClientInit;
        
// for PKTTYPE_DEVICE_CHANGES
typedef struct _XIrmPacketDeviceChanges {
    XIrmPacketHeader header;
    DWORD keyboard_device;
    DWORD active_devices;
    DWORD insertions;
    DWORD removals;
    XINPUT_CAPABILITIES devicecaps[1];
} XIrmPacketDeviceChanges;

// for PKTTYPE_STATE_CHANGES
typedef struct _XIrmPacketStateChanges {
    XIrmPacketHeader header;
    DWORD device_masks;
    XINPUT_STATE states[1];
} XIrmPacketStateChanges;

// for PKTTYPE_SET_STATE
typedef struct _XIrmPacketSetState {
    XIrmPacketHeader header;
    DWORD port;
    XINPUT_FEEDBACK feedback;
} XIrmPacketSetState;

// for PKTTYPE_KEYSTROKE
typedef struct _XIrmPacketKeystroke {
    XIrmPacketHeader header;
    XINPUT_DEBUG_KEYSTROKE keystroke;
} XIrmPacketKeystroke;


//
// Protocol version number
//
#define XIRM_PROTOCOL_VERSION 0x00010001

//
// UDP port numbers used by XInput remote
//
#define XIRM_SERVER_PORT 8873

//
// Send retransmission timeout (in msec)
//
#define XIRM_RETRANSMIT_TIMEOUT 500
#define XIRM_RETRANSMIT_RETRY 3

//
// Send window size, i.e. number of packets that can be sent
// before we must receive an acknowledgement
//
#define XIRM_SEND_WINDOW 8

//
// Number of packets that can be received before
// we must send out an acknowledgement
//
#define XIRM_DELAY_ACKS 4

//
// Maximum packet size
//
#define XIRM_MAX_PACKET_SIZE 1024

//
// Generate a random initial sequence number
//
__inline DWORD XIrmGetISN() {
    DWORD isn;
    FILETIME filetime;

    // Get the current CPU cycle count
    __asm {
        rdtsc
        mov isn, eax
    }

    // XOR with the current time
    GetSystemTimeAsFileTime(&filetime);
    return isn ^ filetime.dwLowDateTime;
}

//
// Max number of supported devices
//
#define XIRM_PORTMAX    4   // must be a power of 2
#define XIRM_PORTSHIFT  2

// Count the number of device mask bits
__inline INT XIrmCountDevices(DWORD device_masks) {
    INT count = 0;
    DWORD i = 1 << (XIRM_PORTMAX-1);
    do {
        if (device_masks & i) count++;
        i = i >> 1;
    } while (i);
    return count;
}

#endif // !_XINPUT_REMOTE_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\dd\usb\netsim\win2k\xboxstub.h ===
#pragma once

//
//  VOID
//  InitializeListHead(
//      PLIST_ENTRY ListHead
//      );
//

#define InitializeListHead(ListHead) (\
    (ListHead)->Flink = (ListHead)->Blink = (ListHead))

//
//  BOOLEAN
//  IsListEmpty(
//      PLIST_ENTRY ListHead
//      );
//

#define IsListEmpty(ListHead) \
    ((ListHead)->Flink == (ListHead))

//
//  PLIST_ENTRY
//  RemoveHeadList(
//      PLIST_ENTRY ListHead
//      );
//

#define RemoveHeadList(ListHead) \
    (ListHead)->Flink;\
    {RemoveEntryList((ListHead)->Flink)}

//
//  VOID
//  RemoveEntryList(
//      PLIST_ENTRY Entry
//      );
//

#define RemoveEntryList(Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_Flink;\
    _EX_Flink = (Entry)->Flink;\
    _EX_Blink = (Entry)->Blink;\
    _EX_Blink->Flink = _EX_Flink;\
    _EX_Flink->Blink = _EX_Blink;\
    }

//
//  VOID
//  InsertTailList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#define InsertTailList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Blink = _EX_ListHead->Blink;\
    (Entry)->Flink = _EX_ListHead;\
    (Entry)->Blink = _EX_Blink;\
    _EX_Blink->Flink = (Entry);\
    _EX_ListHead->Blink = (Entry);\
    }

//
// XInput types
//
#include <PSHPACK1.H>

typedef struct _XINPUT_GAMEPAD
{
    WORD    wButtons;
    BYTE    bAnalogButtons[8];
    SHORT   sThumbLX;
    SHORT   sThumbLY;
    SHORT   sThumbRX;
    SHORT   sThumbRY;
} XINPUT_GAMEPAD, *PXINPUT_GAMEPAD;

#define XINPUT_GAMEPAD_DPAD_UP          0x00000001
#define XINPUT_GAMEPAD_DPAD_DOWN        0x00000002
#define XINPUT_GAMEPAD_DPAD_LEFT        0x00000004
#define XINPUT_GAMEPAD_DPAD_RIGHT       0x00000008
#define XINPUT_GAMEPAD_START            0x00000010
#define XINPUT_GAMEPAD_BACK             0x00000020
#define XINPUT_GAMEPAD_LEFT_THUMB       0x00000040
#define XINPUT_GAMEPAD_RIGHT_THUMB      0x00000080

#define XINPUT_GAMEPAD_A                0
#define XINPUT_GAMEPAD_B                1
#define XINPUT_GAMEPAD_X                2
#define XINPUT_GAMEPAD_Y                3
#define XINPUT_GAMEPAD_BLACK            4
#define XINPUT_GAMEPAD_WHITE            5
#define XINPUT_GAMEPAD_LEFT_TRIGGER     6
#define XINPUT_GAMEPAD_RIGHT_TRIGGER    7

typedef struct _XINPUT_RUMBLE
{
   WORD   wLeftMotorSpeed;
   WORD   wRightMotorSpeed;
} XINPUT_RUMBLE, *PXINPUT_RUMBLE;

typedef struct _XINPUT_STATE
{
    DWORD dwPacketNumber;
    union
    {
        XINPUT_GAMEPAD Gamepad;
    };
} XINPUT_STATE, *PXINPUT_STATE;

#define XINPUT_FEEDBACK_HEADER_INTERNAL_SIZE 58
typedef struct _XINPUT_FEEDBACK_HEADER
{
    DWORD           dwStatus;
    HANDLE OPTIONAL hEvent;
    BYTE            Reserved[XINPUT_FEEDBACK_HEADER_INTERNAL_SIZE];
} XINPUT_FEEDBACK_HEADER, *PXINPUT_FEEDBACK_HEADER;

typedef struct _XINPUT_FEEDBACK
{
    XINPUT_FEEDBACK_HEADER Header;
    union
    {
      XINPUT_RUMBLE              Rumble;
    };
} XINPUT_FEEDBACK, *PXINPUT_FEEDBACK;

typedef struct _XINPUT_CAPABILITIES
{
    BYTE    SubType;
    WORD    Reserved;
    union
    {
      XINPUT_GAMEPAD Gamepad;
    } In;
    union
    {
      XINPUT_RUMBLE Rumble;
    } Out;
} XINPUT_CAPABILITIES, *PXINPUT_CAPABILITIES;

#include <POPPACK.H>

#define XINPUT_DEVSUBTYPE_GC_GAMEPAD	 0x01
#define XINPUT_DEVSUBTYPE_GC_GAMEPAD_ALT 0x02
#define XINPUT_DEVSUBTYPE_GC_WHEEL		 0x10
#define XINPUT_DEVSUBTYPE_KBD_STANDARD   0

typedef struct _XINPUT_DEBUG_KEYSTROKE
{
    BYTE VirtualKey;
    CHAR Ascii;
    BYTE Flags;
} XINPUT_DEBUG_KEYSTROKE, *PXINPUT_DEBUG_KEYSTROKE;

#define XINPUT_DEBUG_KEYSTROKE_FLAG_CTRL       0x01
#define XINPUT_DEBUG_KEYSTROKE_FLAG_SHIFT      0x02
#define XINPUT_DEBUG_KEYSTROKE_FLAG_ALT        0x04
#define XINPUT_DEBUG_KEYSTROKE_FLAG_CAPSLOCK   0x08
#define XINPUT_DEBUG_KEYSTROKE_FLAG_NUMLOCK    0x10
#define XINPUT_DEBUG_KEYSTROKE_FLAG_SCROLLLOCK 0x20
#define XINPUT_DEBUG_KEYSTROKE_FLAG_KEYUP      0x40
#define XINPUT_DEBUG_KEYSTROKE_FLAG_REPEAT     0x80

typedef struct _XINPUT_DEBUG_KEYQUEUE_PARAMETERS
{
    DWORD dwFlags;
    DWORD dwQueueSize;
    DWORD dwRepeatDelay;
    DWORD dwRepeatInterval;
} XINPUT_DEBUG_KEYQUEUE_PARAMETERS, *PXINPUT_DEBUG_KEYQUEUE_PARAMETERS;

#define XINPUT_DEBUG_KEYQUEUE_FLAG_KEYDOWN      0x00000001
#define XINPUT_DEBUG_KEYQUEUE_FLAG_KEYREPEAT    0x00000002
#define XINPUT_DEBUG_KEYQUEUE_FLAG_KEYUP        0x00000004
#define XINPUT_DEBUG_KEYQUEUE_FLAG_ASCII_ONLY   0x00000010
#define XINPUT_DEBUG_KEYQUEUE_FLAG_ONE_QUEUE    0x00000020
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\dd\usb\ohcd\devsys.c ===
/*++

Copyright (c) 2000 Microsoft Corporation


Module Name:

    devsys.c

Abstract:
    
    Implementation of code that is conditionally compiled to perform
    operation on development systems (i.e. non-final development system
    hardware.)  This code may also be useful for verifying final hardware.
    
Environment:

    Designed for XBOX.

Notes:

Revision History:

    01-21-00 created by Mitchell Dernis (mitchd)

--*/

//
//  This file only compiles if development system
//  operations are enabled.
#ifdef PERFORM_DEVSYS_OPERATIONS

//
//  Pull in OS headers
//
#include <ntos.h>

//
//  Setup the debug information for this file (see ..\inc\debug.h)
//
#define MODULE_POOL_TAG          'DCHO'
#include <debug.h>
DEFINE_USB_DEBUG_FUNCTIONS("OHCD");

//
//  Pull in usb headers
//
#include <hcdi.h>       //Interface between USBD and HCD
#include "ohcd.h"       //Private OHCD stuff


#pragma code_seg(".XPPCINIT")

VOID
OHCD_DevSysCheckHardware(
    IN POHCD_DEVICE_EXTENSION DeviceExtension
    )


{
    ULONG Revision;

    USB_DBG_ENTRY_PRINT(("Entering OHCD_DevSysCheckHardware"));
    //
    //  Read the OHCI version
    //
    Revision = READ_REGISTER_ULONG(&DeviceExtension->OperationalRegisters->HcRevision);
    USB_DBG_TRACE_PRINT(("OpenHCI controller version = %d.%d", ((0xF0 & Revision) >> 4), (0x0F & Revision)));
    
    //
    //  We only support version 1.0 of OpenHCI
    //
    ASSERT( (0x10 == (0xFF & Revision)) && "We only support version 1.0 of OpenHCI");
    USB_DBG_EXIT_PRINT(("Exiting OHCD_DevSysCheckHardware"));
}


VOID
OHCD_DevSysTakeControl(
    IN POHCD_DEVICE_EXTENSION DeviceExtension
    )
{
    LARGE_INTEGER DelayTime;
    HC_CONTROL_REGISTER HcControl;
    HC_COMMAND_STATUS   HcCommandStatus;

    USB_DBG_ENTRY_PRINT(("Entering OHCD_DevSysTakeControl"));
    //
    //  Read control register to determine if we have an SMM or BIOS driver
    //  to steel control from
    HcControl.ul = READ_REGISTER_ULONG(&DeviceExtension->OperationalRegisters->HcControl.ul);
    
    //
    //  Check for SMM driver (spec. says to check InterruptRouting Bit)
    //
    if(HcControl.InterruptRouting)
    {
        USB_DBG_TRACE_PRINT(("Placing OwnerShipChangeRequest to get control from SMM driver."));
        //
        //  Put in an OwnerShipChangeRequest
        //
        HcCommandStatus.ul = READ_REGISTER_ULONG(&DeviceExtension->OperationalRegisters->HcCommandStatus.ul);
        HcCommandStatus.OwnerShipChangeRequest = 1;
        WRITE_REGISTER_ULONG(&DeviceExtension->OperationalRegisters->HcCommandStatus.ul, HcCommandStatus.ul);

        //
        //  Wait for SMM driver to clear the interrupt routing bit
        //
        do
        {
            HcControl.ul = READ_REGISTER_ULONG(&DeviceExtension->OperationalRegisters->HcControl.ul);
        }while(HcControl.InterruptRouting);
        USB_DBG_TRACE_PRINT(("SMM driver has yielded control."));
    }
    //
    //  If not SMM driver check for BIOS driver
    //
    else if(HC_OPSTATE_USB_RESET != HcControl.HostControllerFunctionalState )
    {
        USB_DBG_TRACE_PRINT(("A BIOS driver was present, set to UsbResume to get control."));
        //
        //  If the state is not operational set it to resume and wait
        //
        if(HC_OPSTATE_USB_OPERATIONAL != HcControl.HostControllerFunctionalState)
        {
            HcControl.HostControllerFunctionalState = HC_OPSTATE_USB_RESUME;
            //
            //  Signal RESUME and WAIT 20 ms.
            //
            WRITE_REGISTER_ULONG(&DeviceExtension->OperationalRegisters->HcControl.ul, HcControl.ul);
            DelayTime.QuadPart = -200000;
            KeDelayExecutionThread( KernelMode, FALSE, &DelayTime);
        }
    }
    USB_DBG_EXIT_PRINT(("Exiting OHCD_DevSysTakeControl"));
}

#endif //PERFORM_DEVSYS_OPERATIONS
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\dd\usb\ohcd\devsys.h ===
#ifndef __DEVSYS_H__
#define __DEVSYS_H__

#ifdef PERFORM_DEVSYS_OPERATIONS
//
//  If development system only operations are on
//  the macros call functions
//

#define OHCD_DEVSYS_CHECK_HARDWARE(_DeviceExtension_)   OHCD_DevSysCheckHardware(_DeviceExtension_);
#define OHCD_DEVSYS_TAKE_CONTROL(_DeviceExtension_) OHCD_DevSysTakeControl(_DeviceExtension_);

// 
// The functions behind the macros
//
VOID
OHCD_DevSysCheckHardware(
    IN POHCD_DEVICE_EXTENSION DeviceExtension
    );

VOID
OHCD_DevSysTakeControl(
    IN POHCD_DEVICE_EXTENSION DeviceExtension
    );

#else

//
//  If development system only operations are off
//  the macros are NOPs.
//
#define OHCD_DEVSYS_CHECK_HARDWARE(_DeviceExtension_)
#define OHCD_DEVSYS_TAKE_CONTROL(_DeviceExtension_)

#endif


#endif//__DEVSYS_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\dd\usb\ohcd\isr.c ===
/*++

Copyright (c) 2000 Microsoft Corporation


Module Name:

    isr.c

Abstract:
    
    Implementation of the OpenHCI interrupt service routine and related code
    including the DPC.
    
Environment:

    Designed for XBOX.

Notes:

Revision History:

    01-24-00 created by Mitchell Dernis (mitchd)

--*/

//
//  Pull in OS headers
//
#include <ntos.h>

//
//  Setup the debug information for this file (see ..\inc\debug.h)
//
#define MODULE_POOL_TAG          'DCHO'
#include <debug.h>
DEFINE_USB_DEBUG_FUNCTIONS("OHCD");

int IsrEntryCount=0;
//
//  Pull in usb headers
//
#include <hcdi.h>       //Interface between USBD and HCD
#include "ohcd.h"       //Private OHCD stuff


//----------------------------------------------------------------------------
// Forward declaration of functions defined and used only this in this module
//----------------------------------------------------------------------------
VOID
FASTCALL
OHCD_fProcessDoneTD(
    POHCD_DEVICE_EXTENSION      DeviceExtension,
    POHCD_TRANSFER_DESCRIPTOR   TD
    );

VOID
FASTCALL
OHCD_fProcessFailedTD(
    POHCD_DEVICE_EXTENSION      DeviceExtension,
    POHCD_TRANSFER_DESCRIPTOR   TD
    );

VOID
FASTCALL
OHCD_fCompleteRequest(
    IN POHCD_DEVICE_EXTENSION DeviceExtension, 
    IN POHCD_ENDPOINT Endpoint,
    IN PURB Urb
    );

VOID
FASTCALL
OHCD_fCreditTDQuota(
    IN POHCD_DEVICE_EXTENSION DeviceExtension, 
    IN POHCD_ENDPOINT Endpoint
    );

BOOLEAN
FASTCALL
OHCD_fProcessCancelPendingList(
    POHCD_DEVICE_EXTENSION DeviceExtension,
    ULONG                  CurrentFrame
    );

BOOLEAN
FASTCALL
OHCD_fProcessAbortPendingList(
    POHCD_DEVICE_EXTENSION DeviceExtension,
    ULONG                  CurrentFrame
    );

BOOLEAN
FASTCALL
OHCD_fProcessClosePendingList(
    IN POHCD_DEVICE_EXTENSION DeviceExtension,
    ULONG                  CurrentFrame
    );

VOID
FASTCALL
OHCD_fCleanEndpointTDs(
    IN POHCD_DEVICE_EXTENSION   DeviceExtension,
    IN POHCD_ENDPOINT           Endpoint
    );

//----------------------------------------------------------------------------
// Implementation of function called from other modules:
//      OHCD_InterruptService
//      OHCD_IsrDpc
//      OHCD_Get32BitFrameNumber
//----------------------------------------------------------------------------
BOOLEAN 
OHCD_InterruptService( 
    IN PKINTERRUPT Interrupt, 
    IN PVOID ServiceContext 
    )
{
    POHCD_DEVICE_EXTENSION      deviceExtension = (POHCD_DEVICE_EXTENSION)ServiceContext;
    ULONG                       interruptsSignaled;
    ULONG                       interruptEnable;
    POHCI_OPERATIONAL_REGISTERS HcRegs = deviceExtension->OperationalRegisters;
        
    IsrEntryCount++;
    //
    //  Get the interrupts which are actually signaled on USB.  According to OpenHCI 7.1.5
    //  the ine bits set in HcInterruptEnable and in HcInterrupt are actually signaled.
    //
    //
    interruptEnable = READ_REGISTER_ULONG(&HcRegs->HcInterruptEnable);
    interruptsSignaled = interruptEnable &  READ_REGISTER_ULONG(&HcRegs->HcInterruptStatus);

    //
    //  If an enabled interrupt was not signaled, or if the master interrupt
    //  is off this interrupt couldn't have been for us.
    //
    if( (0 == interruptsSignaled) || !(interruptEnable&HCINT_MasterInterruptEnable) ) return FALSE;

    //
    // Disable Interrupts on Host Controller
    //
    WRITE_REGISTER_ULONG(&HcRegs->HcInterruptDisable, HCINT_MasterInterruptEnable);

    //**
    //**    In sequence check and handle the following conditions:
    //**
    //**    SchedulingOverrun
    //**    FrameNumberOverflow
    //**
    //**    The following conditions are handled only in the DPC:
    //**
    //**    WritebackDoneHead
    //**    StartOfFrame
    //**    UnrecoverableError
    //**    RootHubStatusChange
    //**

    //
    // Today we ack but otherwise ignore a SchedulingOverrun interrupt.
    // In the future we may want to do something as suggested in section
    // 5.2.10.1 of the OpenHCI specification.
    //
    if (interruptsSignaled & HCINT_SchedulingOverrun)
    {
        WRITE_REGISTER_ULONG(&HcRegs->HcInterruptStatus, HCINT_SchedulingOverrun);
        //
        //  record that we handled the interrupt
        //
        interruptsSignaled &= ~HCINT_SchedulingOverrun;
    }

    //
    // Check for Frame Number Overflow The following insures that the 32 bit
    // frame never runs backward.
    //
    if (interruptsSignaled & HCINT_FrameNumberOverflow)
    {
        //
        //  Fix up our high part.
        //
        deviceExtension->FrameHighPart += 0x10000 -
                    (0x8000 & (deviceExtension->HCCA->FrameNumber ^ deviceExtension->FrameHighPart));
        //
        //  Clear the status flag, we handled it.
        //
        WRITE_REGISTER_ULONG(&HcRegs->HcInterruptStatus, HCINT_FrameNumberOverflow);

        //
        //  record that we handled the interrupt
        //
        interruptsSignaled &= ~HCINT_FrameNumberOverflow;
    };
    
    //
    //  If there is something left to do,
    //  queue a DPC item, let the DPC reenable interrupts
    //  when it is done.
    //
    if(interruptsSignaled)
    {
        deviceExtension->IsrDpc_Context.InterruptsSignaled  = interruptsSignaled;
        KeInsertQueueDpc(&deviceExtension->IsrDpc, NULL, NULL);
    }
    else
    {
        //
        // If we didn't queue anything than reenable interrupts.
        //
        WRITE_REGISTER_ULONG(&deviceExtension->OperationalRegisters->HcInterruptEnable, HCINT_MasterInterruptEnable);
    }
    return TRUE;
}

VOID
OHCD_IsrDpc(
    PKDPC Dpc,
    PVOID DeviceExtensionPtr,
    PVOID Bogus1,
    PVOID Bogus2
    )
/*++

Routine Description:

  The OHCD_InterruptService will have queued the DPC, if any of the following
  conditions occured:

    WritebackDoneHead
    StartOfFrame
    UnrecoverableError
    RootHubStatusChange

  We handled any and all of these conditions which are present, and then
  reenable interrupts for the host controller.

Arguments:

    Dpc                 - pointer to our DPC object
    DeviceExtensionPtr  - pointer to device extension for our HC.

    Bogus1              - These are arguments that the ISR
    Bogus2              - could have supplied, but we don't need them.

Return Value:
    
    Noned

--*/               
{
    //
    //  Declare and initialize a whole bunch of convenience variables.
    //
    POHCD_DEVICE_EXTENSION          deviceExtension = (POHCD_DEVICE_EXTENSION)DeviceExtensionPtr;
    POHCI_OPERATIONAL_REGISTERS     hcRegs = deviceExtension->OperationalRegisters;
    ULONG                           interruptsSignaled = deviceExtension->IsrDpc_Context.InterruptsSignaled;
    ULONG                           doneHead;
    POHCD_TRANSFER_DESCRIPTOR       completedTDs = NULL;
    POHCD_TRANSFER_DESCRIPTOR       tempTD = 0;
    BOOLEAN                         fItemsStillPending = FALSE;
    ULONG                           currentFrame;
    
    USB_DBG_ENTRY_PRINT(("Entering OHCD_IsrDpc"));

    //
    //  The pause routine checks this to see if it
    //  is between an ISR and the DPC executing.
    //

    deviceExtension->IsrDpc_Context.InterruptsSignaled = 0;

    //
    //  Check for UnrecoverableError first, because there is no point.
    //  in doing anything else, if this has occured.
    //
    if (interruptsSignaled & HCINT_UnrecoverableError)
    {
        ASSERT(FALSE && "Wow, what do we do here?  Try reseting USB?  Reset the whole box?");
    }

    // 
    // Check for WritebackDoneHead, to see if we have TDs on the done list
    //
    if(interruptsSignaled & HCINT_WritebackDoneHead)
    {
        USB_DBG_TRACE_PRINT(("HCINT_WritebackDoneHead is set: processing . . ."));
        doneHead = deviceExtension->HCCA->DoneHead;
        doneHead &= 0xFFFFFFF0;    //LSb's can be used to indicate other interrupt conditions, get rid of them
        deviceExtension->HCCA->DoneHead = 0;

#ifdef SILVER
        //
        //  If the done head was lost, try to find it.
        //
        if(0==doneHead)
        {
            doneHead = OHCD_fPoolFindLostDoneHead(deviceExtension);
        }
#else 
        ASSERT(doneHead && "Xbox hardware should not have this bug");
#endif
        //
        //  The Done Queue can be treated as a LIFO.  Furthermore, they are linked only
        //  by physical address pointers.  So in one fell swoop we:
        //      1) dequeue them from the head
        //      2) reverse the links
        //      3) switch the physical addresses to virtual addresses.
        //
        while(doneHead)
        {
            //
            //  Get a virtual pointer to a TD
            //
            tempTD = OHCD_PoolTDFromPhysicalAddress(doneHead);
            ASSERT(tempTD);

            //
            //  Dequeue TD  from Host Controller Queue
            //
            doneHead = tempTD->HcTransferDescriptor.NextTD;

            //
            //  Queue TD at head our CompletedTDs list
            //
            tempTD->HcTransferDescriptor.NextTDVirtual = (POHCI_TRANSFER_DESCRIPTOR)completedTDs;
            completedTDs = tempTD;
        }
        //
        //  Now step through each TD in the order of completion
        //  and deal with it.
        //
        while(completedTDs)
        {
            //
            //  Dequeue a TD off the head
            //
            tempTD = completedTDs;
            completedTDs = (POHCD_TRANSFER_DESCRIPTOR)tempTD->HcTransferDescriptor.NextTDVirtual;
            //
            //  Process the TD
            //
            if(OHCD_IS_ISOCH_TD(tempTD))
            {
                OHCD_PROCESS_ISOCHRONOUS_TD(deviceExtension, tempTD);
            } else
            {
                OHCD_fProcessDoneTD(deviceExtension, tempTD);
            }
        }
        //
        //  Tell the Host Controller we are done
        //
        WRITE_REGISTER_ULONG(&hcRegs->HcInterruptStatus, HCINT_WritebackDoneHead);
        interruptsSignaled &= ~HCINT_WritebackDoneHead;
        //
        //  This shouldn't be necessary! However, in some cases we added to the schedule while interrupts were
        //  still disabled and the operation completed before this DPC routine finished.  The interrupt seems to
        //  be lost in these cases.  Hitting these flags after restoring the interrupt gets things going again.
        //  I would call this a hardware bug.  Not worth complaining about though, this fix is pretty straightforward.
        //
        WRITE_REGISTER_ULONG((PULONG)&deviceExtension->OperationalRegisters->HcCommandStatus, HCCS_ControlListFilled | HCCS_BulkListFilled);
    }

    // 
    // Check for StartOfFrame
    //
    if (interruptsSignaled & HCINT_StartOfFrame)
    {
        //
        //  Why did we ask for a SOF?  Probably to guarantee an interrupt so
        //  that we could deal with closing endpoints, or canceling requests
        //
        
        //
        //  We treat SOF interrupts as one time events, so shut them
        //  back off.
        WRITE_REGISTER_ULONG(&hcRegs->HcInterruptStatus, HCINT_StartOfFrame);
        WRITE_REGISTER_ULONG(&hcRegs->HcInterruptDisable, HCINT_StartOfFrame);
        interruptsSignaled &= ~HCINT_StartOfFrame;
    }

    //
    //  Handle pending cancels
    //
    currentFrame = OHCD_Get32BitFrameNumber(deviceExtension);
    if(OHCD_fProcessCancelPendingList(deviceExtension, currentFrame))
    {
        fItemsStillPending = TRUE;
    }

    //
    //  Handle pending aborts
    //
    //  IT IS IMPORTANT TO HANDLE PENDING ABORTS BEFORE PENDING
    //  CLOSES, SO THAT WE DO NOT CLOSE AN ENDPOINT WITH AN ABORT
    //  PENDING.
    //
    if(OHCD_fProcessAbortPendingList(deviceExtension, currentFrame))
    {
        fItemsStillPending = TRUE;
    }

    //
    //  Handle pending closes
    //
    if(OHCD_fProcessClosePendingList(deviceExtension, currentFrame))
    {
        fItemsStillPending = TRUE;
    }

    //
    //  If there anything (cancels, aborts, or closes)
    //  are still pending, then set an interrupt at
    //  the next start of frame.
    //
    if(fItemsStillPending)
    {
        USB_DBG_TRACE_PRINT(("Items still pending setting an SOF interrupt."));
        WRITE_REGISTER_ULONG(&deviceExtension->OperationalRegisters->HcInterruptStatus, HCINT_StartOfFrame);
        WRITE_REGISTER_ULONG(&deviceExtension->OperationalRegisters->HcInterruptEnable, HCINT_StartOfFrame);
    }

    // 
    // Process Root Hub changes 
    //
    if(interruptsSignaled & HCINT_RootHubStatusChange)
    {

        USB_DBG_TRACE_PRINT(("Root hub interrupt signaled"));
        OHCD_RootHubProcessInterrupt(deviceExtension);
        
        WRITE_REGISTER_ULONG(&hcRegs->HcInterruptStatus, HCINT_RootHubStatusChange);                                  
        interruptsSignaled &= ~HCINT_RootHubStatusChange;
    }
    
    //
    //  If some interrupt occured and we haven't
    //  handled it, we obviously don't care about it, so disable
    //  it.
    if(interruptsSignaled)
    {
        ASSERT(FALSE && "Not expecting interrupts that we don't handle.");
        WRITE_REGISTER_ULONG(&hcRegs->HcInterruptStatus, interruptsSignaled);
        interruptsSignaled = 0;
    }

    //
    //  Turn interrupts back on.
    //
    WRITE_REGISTER_ULONG(&hcRegs->HcInterruptEnable, HCINT_MasterInterruptEnable);

    USB_DBG_EXIT_PRINT(("Exiting OHCD_IsrDpc"));
}

ULONG
FASTCALL
OHCD_Get32BitFrameNumber(
    POHCD_DEVICE_EXTENSION DeviceExtension
    )
{
    ULONG hp, fn, n;
    /* This code accounts for the fact that HccaFrameNumber is updated by the
     * HC before the HCD gets an interrupt that will adjust FrameHighPart. No
     * synchronization is necessary due to great cleaverness. */
    hp = DeviceExtension->FrameHighPart;
    fn = DeviceExtension->HCCA->FrameNumber;
    n = ((fn & 0x7FFF) | hp) + ((fn ^ hp) & 0x8000);
    return n;
}

//----------------------------------------------------------------------------
// Implementation of functions used only locally:
//      OHCD_ProcessDoneTD
//      OHCD_ProcessFailedTD
//      OHCD_ProcessCancelPendingList
//----------------------------------------------------------------------------

VOID
FASTCALL
OHCD_fProcessDoneTD(
    POHCD_DEVICE_EXTENSION      DeviceExtension,
    POHCD_TRANSFER_DESCRIPTOR   TD
    )
/*++

Routine Description:

    Called from the IsrDpc to cleanup each TD that was
    in the done queue.  There are a large number of cases.

Arguments:

    DeviceExtension - pointer to device extension for our HC.
    TD              - Transfer Descriptor that completed.
    

Return Value:
    
    None

--*/               
{
    PURB                        urb = TD->Urb;
    POHCD_ENDPOINT              endpoint = TD->Endpoint;
    POHCD_TRANSFER_DESCRIPTOR   setupBlock;
    BOOLEAN                     isLastTD;
    USB_DBG_ENTRY_PRINT(("Entering OHCD_ProcessDoneTD"));
    
    //
    //  Success or failure, if this is a setup TD, we need to free the
    //  setupBlock.
    //
    if(OHCD_TD_TYPE_SETUP == TD->Type)
    {
        USB_DBG_TRACE_PRINT(("TD is a setup TD, so free the descriptor used for the data payload."));
        //
        //  Clean up the setup packet which we stored in a descriptor block.
        //  Get the virtual address of the setup packet (BufferEnd points
        //  to the physical address of the last byte of the 8 byte setup
        //  packet).  
        //
        setupBlock = OHCD_PoolTDFromPhysicalAddress(TD->HcTransferDescriptor.BufferEnd - 7);
        //
        //  With Virtual address in hand we can free it.
        //
        OHCD_PoolFreeTD(setupBlock);
        OHCD_PoolCreditControlTDQuota(1);
    }

    //
    //  If this TD completed with an error, than
    //  let OHCD_ProcessFailedTD take over.
    //
    if(OHCI_CC_NO_ERROR != TD->HcTransferDescriptor.ConditionCode)
    {
        USB_DBG_TRACE_PRINT(("TD @0x%0.8x had an error. CC = %x", TD, TD->HcTransferDescriptor.ConditionCode));   
        ASSERT(TD->Type != OHCD_TD_TYPE_DUMMY);
        
        OHCD_fProcessFailedTD(DeviceExtension, TD);
        return;
    }

    //
    //  Calculate bytes transfered.
    //
    if(TD->HcTransferDescriptor.CurrentBufferPointer)
    {
        //
        //  We do everything signed to account for page wrap
        //
        LONG currentBufferPointerOffset = (LONG)BYTE_OFFSET(TD->HcTransferDescriptor.CurrentBufferPointer);
        LONG endBufferPointerOffset = (LONG)BYTE_OFFSET(TD->HcTransferDescriptor.BufferEnd);
        LONG bytesTransfered;
        if(endBufferPointerOffset >= currentBufferPointerOffset)
        {
            bytesTransfered = TD->Bytes - (endBufferPointerOffset - currentBufferPointerOffset);
        } else
        {
            bytesTransfered = TD->Bytes - (PAGE_SIZE - (currentBufferPointerOffset - endBufferPointerOffset));
        }
        bytesTransfered--;
        ASSERT(bytesTransfered >= 0);
        urb->CommonTransfer.TransferBufferLength += bytesTransfered;
    } else
    {
        urb->CommonTransfer.TransferBufferLength += TD->Bytes;
    }
    //
    //  Record whether this was the last TD in an URB
    //
    isLastTD = TD->Flags & OHCD_TD_FLAG_LAST_TD;

    //
    //  Free the TD
    //
    OHCD_PoolFreeTD(TD);

    //
    //  Credit the proper quota
    //
    OHCD_fCreditTDQuota(DeviceExtension, endpoint);
    
    //
    //  If that TD completed the URB then we need to process
    //  the URB
    //
    if(isLastTD)
    {
        USB_DBG_TRACE_PRINT(("TD was last in an URB."));

        urb->Header.Status = USBD_STATUS_SUCCESS;
        OHCD_fCompleteRequest(DeviceExtension, endpoint, urb);
    }
    USB_DBG_EXIT_PRINT(("Exiting OHCD_ProcessDoneTD"));
    //
    //  Nothing else to do
    //
    return;
}


VOID
FASTCALL
OHCD_fProcessFailedTD(
    POHCD_DEVICE_EXTENSION      DeviceExtension,
    POHCD_TRANSFER_DESCRIPTOR   TD
    )
/*++

Routine Description:

    Called from the OHCD_ProcessDoneTD (in the context of IsrDPC),
    because the condition code indicated an error.  Not called if
    TD is for an isochronous endpoint.

    Our job is to deal with that condition.  Firstly, the
    associated endpoint has definately been halted, so we
    can party on the endpoint. In most cases we do
    the following:
        1) Copy the error condition into the URB's status field.
        2) Clean up all the TD's associated with that URB.
        5) Complete the URB.

    There is one exceptions for DataUnderrun when ShortXferOK. There
    is a slight difference in the way control endpoints are handled.
    For Bulk and  Interrupt endpoints we proceed as follows:
        1) Clean up all the remaining TD's associated with the URB.
        2) Complete the URB successfully.
    
    For control endpoints we do the following:
        1) Clean up all the remaining TD's associated with the URB, except
        the status TD.

    When we are done the endpoint should be ready to go again.  The
    caller must clear the halted bit though.
        
Arguments:

    DeviceExtension - pointer to device extension for our HC.
    TD              - Transfer Descriptor that completed.

Return Value:
    
    None

--*/               
{
    PURB                        urb = TD->Urb;
    POHCD_ENDPOINT              endpoint = TD->Endpoint;
    BOOLEAN                     errorCondition = TRUE;
    BOOLEAN                     isLastTD;
    ULONG                       tempTDPhysical;
    POHCD_TRANSFER_DESCRIPTOR   tempTD;
    
    ASSERT(OHCI_CC_NO_ERROR != TD->HcTransferDescriptor.ConditionCode);

    //
    //  DataUnderrun when USBD_SHORT_TRANSFER_OK, is not an error
    //  mark it as success, and record the bytes that were transfered
    //
    if(
        (OHCI_CC_DATA_UNDERRUN == TD->HcTransferDescriptor.ConditionCode) &&
        (urb->CommonTransfer.ShortTransferOK)
    )
    {
       if(TD->HcTransferDescriptor.CurrentBufferPointer)
       {
            //
            //  We do everything signed to account for page wrap
            //
            LONG currentBufferPointerOffset = (LONG)BYTE_OFFSET(TD->HcTransferDescriptor.CurrentBufferPointer);
            LONG endBufferPointerOffset = (LONG)BYTE_OFFSET(TD->HcTransferDescriptor.BufferEnd);
            LONG bytesTransfered;
            if(endBufferPointerOffset >= currentBufferPointerOffset)
            {
                bytesTransfered = TD->Bytes - (endBufferPointerOffset - currentBufferPointerOffset);
            } else
            {
                bytesTransfered = TD->Bytes - (PAGE_SIZE - (currentBufferPointerOffset - endBufferPointerOffset));
            }
            bytesTransfered--;
            ASSERT(bytesTransfered >= 0);
            urb->CommonTransfer.TransferBufferLength += bytesTransfered;
        } else
        {
            urb->CommonTransfer.TransferBufferLength += TD->Bytes;
        }

        USB_DBG_TRACE_PRINT(("OHCI_CC_DATA_UNDERRUN with ShortTransferOK"));
        urb->Header.Status = USBD_STATUS_SUCCESS;
        errorCondition = FALSE;
    }
    else
    //
    //  It really is an error, convert the condition code to a USBD_STATUS_XXXX code.
    //
    {
        if(OHCI_CC_NOT_ACCESSED2 == TD->HcTransferDescriptor.ConditionCode)
        {
            //
            //  TDs are initialized with OHCD_CC_DATA_NOT_ACCESSED.  If the condition
            //  code is OHCD_CC_DATA_NOT_ACCESSED2, it is because the OHCD_ProcessCancelPendingList
            //  called OHCD_ProcessDoneTD to finish off its dirty work.
            //
            urb->Header.Status = USBD_STATUS_CANCELED;
        }
        urb->Header.Status = OHCI_CC_TO_USBD_STATUS(TD->HcTransferDescriptor.ConditionCode);
        
    }
    
    tempTD = TD;
    //
    //  tempTDPhysical will be kept one TD ahead of tempTD
    //  on the queue.  This is because, we need to get the
    //  first one from the endpoints programmed queue (it hasn't
    //  failed yet, so it was not in the done queue).  Subsequent
    //  tempTDPhysical values are obtained in the loop, by walking the
    //  queue.
    //
    tempTDPhysical = READ_HEADP(&endpoint->HcEndpointDescriptor);
    //
    //  Loop until all the TDs of the failed URB are freed.
    //
    USB_DBG_TRACE_PRINT(("Freeing TDs from failed Transfer:"));
    do
    {
        //
        //  Before freeing the TD, record whether or
        //  not it is the last one in the URB.
        //
        isLastTD = tempTD->Flags & OHCD_TD_FLAG_LAST_TD;

        //
        //  Free the TD
        //
        USB_DBG_TRACE_PRINT(("0x%0.8x", tempTD));
        OHCD_PoolFreeTD(tempTD);

        //
        //  Credit the proper quota
        //
        OHCD_fCreditTDQuota(DeviceExtension, endpoint);

        //
        //  update tempTD for the next iteration.
        //
        tempTD = OHCD_PoolTDFromPhysicalAddress(tempTDPhysical);
        tempTDPhysical = tempTD->HcTransferDescriptor.NextTD;
        
        //
        //  If tempTD is a OHCD_TD_TYPE_STATUS and we
        //  did not really fail, than we should break out
        //  before freeing it.
        //
        if( (OHCD_TD_TYPE_STATUS == tempTD->Type) && !errorCondition)
        {
            USB_DBG_TRACE_PRINT(("Leaving Status TD (0x%0.8x) on ED", tempTD));
            break;
        }
    } while(!isLastTD);
        
    //
    //  Update the Queue to reflect that we freed all of them TDs
    //  (remember that tempTDPhysical was one TD ahead of the last
    //  one we didn't free)
    tempTDPhysical = tempTD->PhysicalAddress;
    WRITE_HEADP(&endpoint->HcEndpointDescriptor, tempTDPhysical);
    
    //
    // If we cleaned up a whole URB (i.e. it was not
    // a short control transfer) then complete the Urb.
    //
    if(isLastTD)
    {
        OHCD_fCompleteRequest(DeviceExtension, endpoint, urb);
    }

    //
    //  For control endpoints and short transfers, automatically clear the
    //  halted condition.
    //
    if(USB_ENDPOINT_TYPE_CONTROL == endpoint->EndpointType || !errorCondition)
    {
        CLEAR_HALTED(&endpoint->HcEndpointDescriptor);
    }
}


VOID
FASTCALL
OHCD_fCompleteRequest(
    IN POHCD_DEVICE_EXTENSION DeviceExtension, 
    IN POHCD_ENDPOINT Endpoint,
    IN PURB Urb
    )
/*++
  Routine Description:
    Helper method for OHCD_fProcessDoneTD and OHCD_fProcessFailedTD.
    It just pulls some duplicate code out, and puts it in one place.

   Actions Performed:
    
    1) Clean up Urb out of endpoint.
    2) If the Urb is pending cancel, do maintenance
       on the pending cancel list and endpoint.
    3) Mark Urb Completed.
    4) Complete URb.

    It does not set the Urb status, the caller does that.
--*/
{
    Endpoint->ProgrammedUrbCount--;
    
    //
    //  Unlock buffer pages if needed
    //
    if(Urb->CommonTransfer.TransferBuffer)
    {
        MmLockUnlockBufferPages(Urb->CommonTransfer.TransferBuffer, Urb->CommonTransfer.Hca.HcdOriginalLength, TRUE);
        #ifdef DVTSNOOPBUG
        OHCD_PoolEndDoubleBufferTransfer(Urb);
        #endif
    }

    //
    //  If OHCD_URB_FLAG_CANCELED is set, it may mean
    //  that the URB is sitting in our device extension's
    //  pending cancel list.  If so we have some work to do.
    //
    if(OHCD_URB_FLAG_CANCELED&Urb->CommonTransfer.Hca.HcdUrbFlags)
    {
        //
        //  Search the pending cancel list for the Urb.
        //
        PURB urbPrev=NULL;
        PURB urbCur=DeviceExtension->PendingCancels;
        while(urbCur && Urb!=urbCur)
        {
            urbPrev = urbCur;
            urbCur = urbPrev->CommonTransfer.Hca.HcdUrbLink;
        }

        //
        // If we find it, better clean up.
        //
        if(urbCur)
        {
            ASSERT(urbCur==Urb);

            //
            //  Splice the Urb out of the pending cancel list.
            //
            if(!urbPrev)
            {
                DeviceExtension->PendingCancels = urbCur->CommonTransfer.Hca.HcdUrbLink;
            } else
            {
                urbPrev->CommonTransfer.Hca.HcdUrbLink = urbCur->CommonTransfer.Hca.HcdUrbLink;
            }
            urbCur->CommonTransfer.Hca.HcdUrbLink = NULL;
    
            //
            //  Handle the endpoint pause associated with the Urb pending cancel.
            //
            if( 0 == --Endpoint->PendingPauseCount)
            {   
                Endpoint->Flags &= ~OHCD_ENDPOINT_FLAG_PAUSING;
                Endpoint->HcEndpointDescriptor.Control.Skip = 0;
            }

        } else
        //
        //  There is only one legitimate reason that the Urb would
        //  not be in the pending cancel list.  That is if 
        //  OHCD_fProcessCancelPendingList is in our call stack.  If that
        //  is the case Urb->Header.Status  will already be set to
        //  USBD_STATUS_CANCELED.
        //
        {
            ASSERT(USBD_STATUS_CANCELED == Urb->Header.Status);
        }
    }
    
    //
    //  Complete the request.
    //

    Urb->CommonTransfer.Hca.HcdUrbFlags |= OHCD_URB_FLAG_COMPLETED;
    USBD_CompleteRequest(Urb);
}

VOID
FASTCALL
OHCD_fCreditTDQuota(
    IN POHCD_DEVICE_EXTENSION DeviceExtension, 
    IN POHCD_ENDPOINT Endpoint
    )
/*++
    Routine Description:
        Called whenever a TD is retired.  It credits the proper
        quota (control, bulk or interrupt), and jogs the appropriate
        queue that may be waiting to fit under the quota.

   DeviceExtension - pointer to device extension for our HC.
   Endpoint - endpoint the TD was associated with.

--*/
{
    switch(Endpoint->EndpointType)
    {
        case USB_ENDPOINT_TYPE_CONTROL:
            OHCD_PoolCreditControlTDQuota(1);
            OHCD_fProgramControlTransfer(DeviceExtension);
            break;
        case USB_ENDPOINT_TYPE_BULK:
            OHCD_PoolCreditBulkTDQuota(1);
            OHCD_fProgramBulkTransfer(DeviceExtension);
            break;
        case USB_ENDPOINT_TYPE_INTERRUPT:
            Endpoint->TDInUseCount--;
            OHCD_fProgramInterruptTransfer(DeviceExtension, Endpoint);
            break;
		default:
            //ISOCH endpoint never expected here.
            USB_DBG_ERROR_PRINT(("Unrecognized endpoint type in OHCD_ProcessDoneTD"));
            //This is a serious error, please dump the stack, bug it, and reboot.
    }
}

BOOLEAN
FASTCALL
OHCD_fProcessCancelPendingList(
    POHCD_DEVICE_EXTENSION DeviceExtension,
    ULONG                  CurrentFrame
    )
/*++

Routine Description:

    Called from the IsrDpc to cleanup any pending cancels.
    The DPC has to do it, because the endpoint must be paused.

Arguments:

    DeviceExtension - pointer to device extension for our HC.

    Return Value:
    
    None

--*/               
{
    PURB            stillPending = NULL;
    PURB            urb;
    POHCD_ENDPOINT  endpoint;

    ASSERT_DISPATCH_LEVEL();
    //
    //  Pop the first URB in each request pending cancel off
    //  the Pending Cancel queue and deal with it.  Note that
    //  we have an inner loop to deal with URBs of the same request.
    //
    while(DeviceExtension->PendingCancels)
    {
        //
        //  pop an urb off the pending cancels queue
        //
        urb = DeviceExtension->PendingCancels;
        DeviceExtension->PendingCancels = urb->CommonTransfer.Hca.HcdUrbLink;

        //
        //  Get the endpoint for the urb
        //
        endpoint = (POHCD_ENDPOINT)urb->CommonTransfer.EndpointHandle;
        
        //
        //  If the endpoint is not paused yet, hold the urb aside on
        //  the stillPending list.
        //
        if(CurrentFrame < endpoint->PauseFrame)
        {
            urb->CommonTransfer.Hca.HcdUrbLink = stillPending;
            stillPending = urb;
        } else if(endpoint->Flags&OHCD_ENDPOINT_FLAG_DELAY_PAUSE)
        {
            // Change the pause frame so that OHCD_fProcessAbortPendingList
            // and OHCD_fProcessClosePendingList won't process anything for
            // this endpoint until the next interrupt.
            endpoint->PauseFrame = CurrentFrame+1; 
            // Clear the delay pause flag.
            endpoint->Flags &= ~OHCD_ENDPOINT_FLAG_DELAY_PAUSE;
            // Put the Urb on the still pending list
            urb->CommonTransfer.Hca.HcdUrbLink = stillPending;
            stillPending = urb;
        } else   
        {
            //
            //  The endpoint is paused,  we need to cleanup all the TDs associated with
            //  the Urb and complete it.  We can leverage the OHCD_ProcessDoneTD routine,
            //  here's how:
            //
            //  1) Find our URB on the endpoints queue.
            //  2) Save physical pointers to the original first TD, and the
            //     last TD prior to the first TD of our URB.
            //  3) Set the head of the queue to point the second TD of our URB.
            //  4) Set the condition code of the first TD is set to
            //     OHCI_CC_NOT_ACCESSED2.
            //  5) Call OHCD_ProcessDoneTD.
            //  6) Restore the portion of the queue prior to our URB
            //
            
            ULONG                       firstTDPhysical;
            ULONG                       priorTDPhysical;
            ULONG                       currentTDPhysical;
            POHCD_TRANSFER_DESCRIPTOR   currentTD;

            //
            //  ASSERT that the Urb is not yet completed.
            //
            ASSERT(!(urb->CommonTransfer.Hca.HcdUrbFlags & OHCD_URB_FLAG_COMPLETED));

            //
            //  Loop until we find the first TD of our URB, or until we found the end
            //  of the queue.
            //  Steps 1) and 2)
            //
            priorTDPhysical = 0;
            firstTDPhysical =
            currentTDPhysical = READ_HEADP(&endpoint->HcEndpointDescriptor);
            currentTD = OHCD_PoolTDFromPhysicalAddress(currentTDPhysical);
            while(
                (urb != currentTD->Urb) &&
                (currentTDPhysical != endpoint->HcEndpointDescriptor.TailP)
            )
            {
                priorTDPhysical = currentTDPhysical;
                currentTDPhysical = currentTD->HcTransferDescriptor.NextTD;
                currentTD = OHCD_PoolTDFromPhysicalAddress(currentTDPhysical);
            }
            //
            //  ASSERT that we found the Urb.  Basically, we should
            //  always find it.  If we didn't, it got lost, and that
            //  would be very bad.
            //
            ASSERT(urb == currentTD->Urb);
            
            //
            //  3) Adjusting queue for OHCD_ProcessDoneTD
            //
            WRITE_HEADP(&endpoint->HcEndpointDescriptor, currentTD->HcTransferDescriptor.NextTD);
            //
            //  4) Verify that the condition code of the first TD is set to
            //     OHCI_CC_NOT_ACCESSED2.
            currentTD->HcTransferDescriptor.ConditionCode = OHCI_CC_NOT_ACCESSED2;
            //
            //  5) Call OHCD_ProcessDoneTD.
            //
            OHCD_fProcessDoneTD(DeviceExtension, currentTD);
            //
            //  6) Restore endpoint's queue
            //
            if(0 != priorTDPhysical)
            {
                currentTD = OHCD_PoolTDFromPhysicalAddress(priorTDPhysical);
                currentTD->HcTransferDescriptor.NextTD = READ_HEADP(&endpoint->HcEndpointDescriptor);
                WRITE_HEADP(&endpoint->HcEndpointDescriptor, firstTDPhysical);
            }
            //
            //  Decrement pending pause count, and restart the endpoint
            //  if it is time.
            //
            if( 0 == --endpoint->PendingPauseCount)
            {   
                endpoint->Flags &= ~OHCD_ENDPOINT_FLAG_PAUSING;
                endpoint->HcEndpointDescriptor.Control.Skip = 0;
            }
        }
    }//Loop over all URBs pending cancel
        
    //
    //  Put all the cancels we passed over back on the
    //  pending list.
    //
    DeviceExtension->PendingCancels = stillPending;
    return stillPending ? TRUE : FALSE;
}

BOOLEAN
FASTCALL
OHCD_fProcessAbortPendingList(
    POHCD_DEVICE_EXTENSION DeviceExtension,
    ULONG                  CurrentFrame
    )
/*++

Routine Description:

    Called from the IsrDpc to cleanup any pending aborts.
    The DPC has to do it, because the endpoint must be paused.

Arguments:

    DeviceExtension - pointer to device extension for our HC.

    Return Value:
    
    None

--*/               
{
    PURB            stillPending = NULL;
    PURB            urb;
    POHCD_ENDPOINT  endpoint;

    ASSERT_DISPATCH_LEVEL();
    //
    //  Pop the first URB in each request pending cancel off
    //  the Pending Cancel queue and deal with it.  Note that
    //  we have an inner loop to deal with URBs of the same request.
    //
    while(DeviceExtension->PendingAborts)
    {
        //
        //  pop an urb off the pending aborts queue
        //
        urb = DeviceExtension->PendingAborts;
        DeviceExtension->PendingAborts = urb->CommonTransfer.Hca.HcdUrbLink;

        //
        //  Get the endpoint for the urb
        //
        endpoint = (POHCD_ENDPOINT)urb->CommonTransfer.EndpointHandle;
        
        //
        //  If the endpoint is not paused yet, hold the urb aside on
        //  the stillPending list.
        if(CurrentFrame < endpoint->PauseFrame)
        {
            urb->AbortEndpoint.HcdNextAbort = stillPending;
            stillPending = urb;
        } else if(endpoint->Flags&OHCD_ENDPOINT_FLAG_DELAY_PAUSE)
        {
            // Change the pause frame so that OHCD_fProcessClosePendingList won't
            // process anything for this endpoint until the next interrupt.
            endpoint->PauseFrame = CurrentFrame+1; 
            // Clear the delay pause flag.
            endpoint->Flags &= ~OHCD_ENDPOINT_FLAG_DELAY_PAUSE;
            // Put the Urb on the still pending list
            urb->AbortEndpoint.HcdNextAbort = stillPending;
            stillPending = urb;
        } else
        //
        //  The endpoint is paused.
        //
        {
            OHCD_fCleanEndpointTDs(DeviceExtension, endpoint);
            //
            //  Decrement PendingPauseCount, and restart endpoint if necessary.
            //
            if(0 == --endpoint->PendingPauseCount)
            {   
                endpoint->Flags &= ~OHCD_ENDPOINT_FLAG_PAUSING;
                endpoint->HcEndpointDescriptor.Control.Skip = 0;
            }
            //
            //  Complete the Abort URB
            //
            urb->Header.Status = USBD_STATUS_SUCCESS;
            USBD_CompleteRequest(urb);
        }
    }//Loop over all URBs pending cancel
        
    //
    //  Put all the cancels we passed over back on the
    //  pending list.
    //
    DeviceExtension->PendingAborts = stillPending;
    return stillPending ? TRUE : FALSE;
}

BOOLEAN
FASTCALL    
OHCD_fProcessClosePendingList(
    IN POHCD_DEVICE_EXTENSION DeviceExtension,
    ULONG                     CurrentFrame
    )
{
    PURB_CLOSE_ENDPOINT urb;
    PURB_CLOSE_ENDPOINT notClosedYet = NULL;
    POHCD_ENDPOINT      endpoint;
    
    while(DeviceExtension->PendingCloses)
    {
        //
        // Remove an endpoint from the queue.
        //
        urb = &DeviceExtension->PendingCloses->CloseEndpoint;
        DeviceExtension->PendingCloses = urb->HcdNextClose;
        
        //
        //  Retrieve the endpoint from the URB
        //
        endpoint = (POHCD_ENDPOINT)urb->EndpointHandle;

        //
        //  If the endpoint is not paused yet, hold the endpoint aside on
        //  the notClosedYet list.
        //
        if(CurrentFrame < endpoint->PauseFrame)
        {
            urb->HcdNextClose = (PURB)notClosedYet;
            notClosedYet = urb;
        } else if(endpoint->Flags&OHCD_ENDPOINT_FLAG_DELAY_PAUSE)
        {
            // Clear the delay pause flag.
            endpoint->Flags &= ~OHCD_ENDPOINT_FLAG_DELAY_PAUSE;
            // Put the Urb on the still pending list
            urb->HcdNextClose = (PURB)notClosedYet;
            notClosedYet = urb;
        }
        //
        //  Otherwise, cleanup the endpoint and complete the URB
        //
        else
        {
            if(OHCD_IS_ISOCH_CLOSE(urb))
            {
                OHCD_ISOCH_COMPLETE_CLOSE_ENDPOINT(DeviceExtension, urb);
            } else
            {
                //
                //  Cleanup any straggling TDS, canceling any pending transfers
                //  in the process.
                //
                OHCD_fCleanEndpointTDs(DeviceExtension, endpoint);

                //
                //  Serious programming error if we haven't cleaned everything.
                //
                ASSERT(0==endpoint->QueuedUrbCount);
                ASSERT(0==endpoint->ProgrammedUrbCount);
                ASSERT(0==--endpoint->PendingPauseCount);
                //
                //  Update the data toggle bits in the close URB
                //
                if(urb->DataToggleBits)
                {
                    ULONG dataToggleMask = 1 << endpoint->HcEndpointDescriptor.Control.EndpointAddress;
                    if(endpoint->HcEndpointDescriptor.Control.Direction == 2)
                    {
                        dataToggleMask <<= 16;
                    }
                    if(GET_TOGGLECARRY(&endpoint->HcEndpointDescriptor))
                    {
                        *urb->DataToggleBits |= dataToggleMask;
                    } else
                    {
                        *urb->DataToggleBits &= ~dataToggleMask;
                    }
                }
                OHCD_PoolFreeEndpoint(endpoint);
                urb->Hdr.Status = USBD_STATUS_SUCCESS;
                USBD_CompleteRequest((PURB)urb);
            }
        }
    }
    //
    //  Place the endpoints that weren't closed yet, back on
    //  the PendingCloses list.  So what if we reversed the order.
    //
    DeviceExtension->PendingCloses = (PURB)notClosedYet;
    return notClosedYet ? TRUE : FALSE;
}

VOID
FASTCALL
OHCD_fCleanEndpointTDs(
    IN POHCD_DEVICE_EXTENSION   DeviceExtension,
    IN POHCD_ENDPOINT           Endpoint
    )
{
    ULONG                       TDPhysical;
    POHCD_TRANSFER_DESCRIPTOR   TD = NULL;
    BOOLEAN                     done = FALSE;
    
    //
    //  1) Pull the TDs off one at a time.
    //  2) Make sure that the ConditionCode is OHCI_CC_NOT_ACCESSED2.
    //  3) Call OHCD_ProcessDoneTD, which will call OHCD_ProcessFailedTD,
    //     which will:
    //          a) Clean all the TDs associated with the same URB.
    //          b) Complete the URB as USBD_STATUS_CANCELED
    //  4) Clean up the dummy TD when we get to it.     
    //  
    while(!done)
    {
        TDPhysical = READ_HEADP(&Endpoint->HcEndpointDescriptor);
        if(0 == TDPhysical) break;
        TD = OHCD_PoolTDFromPhysicalAddress(TDPhysical);
        if(TDPhysical != Endpoint->HcEndpointDescriptor.TailP)
        {
            ASSERT(OHCD_TD_TYPE_DUMMY != TD->Type);
            TD->HcTransferDescriptor.ConditionCode = OHCI_CC_NOT_ACCESSED2;
            WRITE_HEADP(&Endpoint->HcEndpointDescriptor, TD->HcTransferDescriptor.NextTD);
            OHCD_fProcessDoneTD(DeviceExtension, TD);
        }else
        {
            ASSERT(OHCD_TD_TYPE_DUMMY == TD->Type);
            WRITE_HEADP(&Endpoint->HcEndpointDescriptor, 0);
            Endpoint->HcEndpointDescriptor.TailP = 0;
            OHCD_PoolFreeTD(TD);
            done = TRUE;
        }
    }   
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\dd\usb\ohcd\isoch.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.


Module Name:

    isoch.c

Abstract:

    Functions used to support isochronous transfers.

Environment:

    Designed for XBOX.

Notes:

Revision History:

    06-29-00 created by Mitchell Dernis (mitchd)

--*/
#ifdef  OHCD_ISOCHRONOUS_SUPPORTED
//
//  Pull in OS headers
//
#include <ntos.h>

//
//  Setup the debug information for this file (see ..\inc\debug.h)
//
#define MODULE_POOL_TAG          'DCHO'
#include <debug.h>
DEFINE_USB_DEBUG_FUNCTIONS("OHCD");


//
//  Pull in usb headers
//
#include <hcdi.h>       //Interface between USBD and HCD
#include "ohcd.h"       //Private OHCD stuff

USBD_STATUS
FASTCALL
OHCD_fIsochOpenEndpoint(
    IN POHCD_DEVICE_EXTENSION   DeviceExtension,
    IN PURB                     Urb
    )
/*++
    Routine Description:
        Called to open an isochronous endpoint.
--*/
{
    POHCD_ISOCH_ENDPOINT     endpoint = NULL;
    USBD_STATUS              status = USBD_STATUS_SUCCESS;
    ULONG                    allocSize;
    ULONG                    maxBuffers;
    ULONG_PTR                endpointMemory;
    UCHAR                    index;
    ULONG_PTR                nextTdPhysical;
    ULONG_PTR                tdPhysical;
    KIRQL                    oldIrql;


    USB_DBG_ENTRY_PRINT(("Entering OHCD_OpenEndpoint"));

    maxBuffers = OHCD_IsochPoolGetMaxBuffers();
    allocSize = maxBuffers*sizeof(OHCD_ISOCH_TRANSFER_DESCRIPTOR)+sizeof(OHCD_ISOCH_ENDPOINT);

    oldIrql = KeRaiseIrqlToDpcLevel();

    //
    //  Allocate the isoch endpoint (with prepended TD's) form pool
    //
    endpointMemory = OHCD_IsochPoolAllocateEndpoint();
    
    //
    //  If there was no memory than fail the open.
    //
    if(!endpointMemory)
    {
        status = USBD_STATUS_NO_MEMORY;
        goto ExitOpenIsochEndpoint;
    }
    
    //
    //  Zero the memory
    //
    RtlZeroMemory((PVOID)endpointMemory, allocSize);

    //
    // Break the memory up into the endpoint and the transfer descriptor memory.
    // (The endpoint starts after the transfer descriptor memory).
    //
    endpoint = (POHCD_ISOCH_ENDPOINT)(
                            endpointMemory +
                            maxBuffers*sizeof(OHCD_ISOCH_TRANSFER_DESCRIPTOR)
                            );
    endpoint->TransferDescriptors = (POHCD_ISOCH_TRANSFER_DESCRIPTOR)(endpointMemory);
    endpoint->PhysicalAddress = OHCD_PoolGetPhysicalAddress(endpoint);
    endpoint->EndpointType = USB_ENDPOINT_TYPE_ISOCHRONOUS;
    endpoint->PollingInterval = 1;
    endpoint->Bandwidth = USBD_CalculateUsbBandwidth(
                                Urb->IsochOpenEndpoint.MaxPacketSize,
                                endpoint->EndpointType, 
                                FALSE
                                );
    endpoint->MaxAttachedBuffers = (UCHAR)maxBuffers;
    endpoint->Flags = (Urb->IsochOpenEndpoint.Flags&URB_FLAG_ISOCH_CIRCULAR_DMA) ? OHCD_ISOCH_EDFL_CIRCULAR_DMA : 0;

    //
    //  Fill out everything in the control structure.
    //  Note the Direction here is set correctly for non-control endpoints.
    //  in the next step we have an if USB_ENDPOINT_TYPE_CONTROL and we fix it
    //  for the control endpoints.
    //
    endpoint->HcEndpointDescriptor.Control.FunctionAddress = Urb->IsochOpenEndpoint.FunctionAddress;
    endpoint->HcEndpointDescriptor.Control.EndpointAddress = Urb->IsochOpenEndpoint.EndpointAddress;
    endpoint->HcEndpointDescriptor.Control.Direction = (USB_ENDPOINT_DIRECTION_MASK & Urb->OpenEndpoint.EndpointAddress) ? 2 : 1;
    endpoint->HcEndpointDescriptor.Control.Speed = 0;
    endpoint->HcEndpointDescriptor.Control.Skip = 1;
    endpoint->HcEndpointDescriptor.Control.Format = 1;
    endpoint->HcEndpointDescriptor.Control.MaximumPacketSize = Urb->IsochOpenEndpoint.MaxPacketSize;

    //
    //  Set the head and tail pointer to point to the first transfer descriptor
    //
    tdPhysical = OHCD_PoolGetPhysicalAddress(endpoint->TransferDescriptors);
    WRITE_HEADP(&endpoint->HcEndpointDescriptor, (ULONG)tdPhysical);
    endpoint->HcEndpointDescriptor.TailP = (ULONG)tdPhysical;
    //
    //  Link up all transfer descriptors in a big circle.
    //  The hardware won't see them because HeadP and TailP point
    //  to the same one.
    //  
    for(index = 0; index < maxBuffers; index++)
    {
        nextTdPhysical = OHCD_PoolGetPhysicalAddress(endpoint->TransferDescriptors+index+1);
        endpoint->TransferDescriptors[index].TdIndexPrev = index-1;
        endpoint->TransferDescriptors[index].TdIndex = index;
        endpoint->TransferDescriptors[index].Endpoint = endpoint;
        endpoint->TransferDescriptors[index].Context = NULL;
        endpoint->TransferDescriptors[index].TransferComplete = NULL;
        endpoint->TransferDescriptors[index].IsochTransferDescriptor.Format=1;
        endpoint->TransferDescriptors[index].IsochTransferDescriptor.NextTD = nextTdPhysical;
        tdPhysical = nextTdPhysical;
    }
    endpoint->TransferDescriptors[index-1].IsochTransferDescriptor.NextTD = 0;
    endpoint->TransferDescriptors[0].TdIndexPrev = index - 1;

    //
    //  Insert the endpoint into the schedule (it will then be visible to the hardware).
    //  (The cast is safe because, the beginning of the endpoint structure is the same
    //  as the beginning of the isochronous endpoint structure.)
    //
    status = OHCD_ScheduleAddEndpointPeriodic(DeviceExtension, (POHCD_ENDPOINT)endpoint);
    //
    //  Udpate URB handle
    //
    if(USBD_SUCCESS(status))
    {
        Urb->IsochOpenEndpoint.EndpointHandle = endpoint;
    }
    else
    {
        Urb->IsochOpenEndpoint.EndpointHandle = NULL;
        //
        // Free the endpoint memory
        //
        OHCD_IsochPoolFreeEndpoint(endpointMemory);
    }

ExitOpenIsochEndpoint:
    Urb->Header.Status = status;
    KeLowerIrql(oldIrql);
    USB_DBG_EXIT_PRINT(("Exiting OHCD_OpenIsochEndpoint: usbdStatus = 0x%0.8x", status));
    return status;
}

USBD_STATUS
FASTCALL
OHCD_fIsochCloseEndpoint(
    IN POHCD_DEVICE_EXTENSION   DeviceExtension,
    IN PURB                     Urb
    )
/*++
    Routine Description:
        This routine is the handler for URB_ISOCH_CLOSE_ENDPOINT
        
        By the time this routine returns, all of the attached buffers can be freed.

    Parameters:

        DeviceExtension - host controller context
        Urb             - urb to handle

    Return Value:

        USBD_STATUS_SUCCESS                     success
--*/
{
    POHCD_ISOCH_ENDPOINT endpoint = (POHCD_ISOCH_ENDPOINT)Urb->IsochCloseEndpoint.EndpointHandle;
    KIRQL oldIrql;
    //
    //  Use high Irql to synchronize.
    //
    oldIrql = KeRaiseIrqlToDpcLevel();

    //
    //  Remove the endpoint from the schedule.
    //
    OHCD_ScheduleRemoveEndpointPeriodic(DeviceExtension, (POHCD_ENDPOINT)endpoint);

    //
    //  Pause the endpoint.  The cast is OK, because the relevant fields are the same.
    //
    OHCD_fPauseEndpoint(DeviceExtension, (POHCD_ENDPOINT)endpoint);
    
    //
    //  Link the URB into the list of pending closes.
    //
    ASSERT(DeviceExtension->PendingCloses != Urb);
    Urb->CloseEndpoint.HcdNextClose = DeviceExtension->PendingCloses;
    DeviceExtension->PendingCloses = Urb;
    //
    //  At this point, the only software that knows about the endpoint is us, so high
    //  Irql is no longer needed.
    //
    KeLowerIrql(oldIrql);
   
    //
    //  Complete this as pending.
    //
    return USBD_STATUS_PENDING;
}

VOID
FASTCALL
OHCD_fIsochCompleteCloseEndpoint(
    IN POHCD_DEVICE_EXTENSION      DeviceExtension,
    IN PURB_ISOCH_CLOSE_ENDPOINT   Urb
    )
{
    
    POHCD_ISOCH_ENDPOINT endpoint = (POHCD_ISOCH_ENDPOINT)Urb->EndpointHandle;
    ULONG_PTR endpointMemory;
    POHCD_ISOCH_TRANSFER_DESCRIPTOR transferDescriptor;
    ULONG descriptorIndex = endpoint->NextFreeTD + (endpoint->MaxAttachedBuffers - endpoint->AttachedBuffers);

    //
    //  Unlock pages of attached buffers
    //
    
    while(endpoint->AttachedBuffers--)
    {
        descriptorIndex = descriptorIndex%endpoint->MaxAttachedBuffers;
        transferDescriptor = endpoint->TransferDescriptors + (descriptorIndex++);
        //
        //  Unlock the page(s)
        //
        //
        MmLockUnlockPhysicalPage(transferDescriptor->IsochTransferDescriptor.BufferPage0, TRUE);
        if((transferDescriptor->IsochTransferDescriptor.BufferPage0 ^ transferDescriptor->IsochTransferDescriptor.BufferEnd) & ~(PAGE_SIZE-1))
        {
            MmLockUnlockPhysicalPage(transferDescriptor->IsochTransferDescriptor.BufferEnd, TRUE);
        }
    }

    //
    //  Find the original endpoint pointer allocated
    //
    
    endpointMemory = ((ULONG_PTR)(endpoint)) - (endpoint->MaxAttachedBuffers*sizeof(OHCD_ISOCH_TRANSFER_DESCRIPTOR));
    OHCD_IsochPoolFreeEndpoint(endpointMemory);
    
    //
    //  Complete the close
    //
    Urb->Hdr.Status = USBD_STATUS_SUCCESS;
    USBD_CompleteRequest((PURB)Urb);
}


USBD_STATUS
FASTCALL
OHCD_fIsochAttachBuffer(
    IN POHCD_DEVICE_EXTENSION   DeviceExtension,
    IN PURB                     Urb
    )
/*++
    Routine Description:
        This routine is the handler for URB_ISOCH_ATTACH_BUFFER
        1) check parameters
        2) figure out which TD to use, and fill out basic stuff.
        3) calculate the offset information
        4) Move the tail pointer
        5) Deal with starting frame if transfers are started.
        
    Parameters:
        DeviceExtension - host controller context
        Urb             - urb to handle
    Return Value:
        USBD_STATUS_SUCCESS                     success
        USBD_STATUS_ISOCH_ALREADY_STARTED       the transfers have already been started.
        USBD_STATUS_ISOCH_ATTACH_MORE_BUFFERS   circular DMA and fewer the MaxAttached Buffers are attached.
        USBD_STATUS_BAD_START_FRAME             Start frame is in the past or too far in the future.
--*/

{
    POHCD_ISOCH_ENDPOINT endpoint = (POHCD_ISOCH_ENDPOINT)Urb->IsochAttachBuffer.EndpointHandle;
    USBD_STATUS status = USBD_STATUS_SUCCESS;
    POHCD_ISOCH_TRANSFER_DESCRIPTOR transferDescriptor;
    PUSBD_ISOCH_BUFFER_DESCRIPTOR bufferDescriptor;
    ULONG_PTR physicalAddress;
    ULONG initialByteOffset, byteOffset;
    ULONG frameIndex;
    ULONG tdIndex;
    ULONG bufferSize;
    KIRQL oldIrql;

    ASSERT(endpoint);

    //
    //  Raise IRQL for synchronization purposes.  Also it would
    //  could cause some frame problems if we were interrupted for
    //  an extended period of time.
    //
    oldIrql = KeRaiseIrqlToDpcLevel();
    
    //
    //  make sure we have transfer descriptors for the buffers.
    //
    if(endpoint->MaxAttachedBuffers == endpoint->AttachedBuffers)
    {
        status = USBD_STATUS_ISOCH_TOO_MANY_BUFFERS;
        goto ExitIsochAttachBuffers;
    }
    //
    //  Get a pointer to the buffer descriptor and transfer descriptor
    //
    bufferDescriptor = Urb->IsochAttachBuffer.BufferDescriptor;
    tdIndex = endpoint->NextFreeTD;
    transferDescriptor =  endpoint->TransferDescriptors + tdIndex;
    endpoint->NextFreeTD = (endpoint->NextFreeTD+1)%endpoint->MaxAttachedBuffers;
    
    //
    //  Fill out the software section of the TD.
    //
    transferDescriptor->TransferComplete = bufferDescriptor->TransferComplete;
    transferDescriptor->Context = bufferDescriptor->Context;
    transferDescriptor->Endpoint = endpoint;
    //
    //  Fill copy the Delay interrupt information.
    //
    transferDescriptor->IsochTransferDescriptor.DelayInterrupt = Urb->IsochAttachBuffer.InterruptDelay;
    
    //
    //  Fill out the offset from the pattern.
    //
    transferDescriptor->IsochTransferDescriptor.FrameCount = bufferDescriptor->FrameCount-1;
    initialByteOffset = byteOffset = BYTE_OFFSET(bufferDescriptor->TransferBuffer);
    for(frameIndex = 0; frameIndex < bufferDescriptor->FrameCount; frameIndex++)
    {
        transferDescriptor->IsochTransferDescriptor.Offset_PSW[frameIndex] = (USHORT)(byteOffset|(OHCI_CC_NOT_ACCESSED << 12));
        byteOffset += bufferDescriptor->Pattern[frameIndex];
    }
    bufferSize = (byteOffset-initialByteOffset);

    //
    //  Fillout the start address (and lock it)
    //
    MmLockUnlockBufferPages(bufferDescriptor->TransferBuffer, bufferSize, FALSE);
    physicalAddress = MmGetPhysicalAddress(bufferDescriptor->TransferBuffer);
    transferDescriptor->IsochTransferDescriptor.BufferPage0 = physicalAddress;
    
    //
    //  Fill out the end address (and lock it, if it is a different page).
    //
    physicalAddress = ((ULONG_PTR)(bufferDescriptor->TransferBuffer)) + bufferSize - 1;
    physicalAddress = MmGetPhysicalAddress((PVOID)physicalAddress);
    transferDescriptor->IsochTransferDescriptor.BufferEnd = physicalAddress;

    //
    //   If we are in circular DMA mode, cache the offset information.
    //
    if(endpoint->Flags&OHCD_ISOCH_EDFL_CIRCULAR_DMA)
    {
        RtlCopyMemory((PVOID)(&transferDescriptor->Offsets), (PVOID)transferDescriptor->IsochTransferDescriptor.Offset_PSW, sizeof(USHORT)*8);
    }
    //
    //  If the endpoint is running than we need to deal with the starting frame stuff.
    //
    if(endpoint->Flags&OHCD_ISOCH_EDFL_TRANSFERING)
    {
        //
        //  If the next unused frame is not in the past, use it.
        //  Otherwise, use the current frame (plus one for safety).
        //
        ULONG frame = OHCD_Get32BitFrameNumber(DeviceExtension)+1;
        if( 0 < (((LONG)endpoint->NextUnusedFrame) - ((LONG)frame)) )
        {
            frame = endpoint->NextUnusedFrame;
        }
        transferDescriptor->IsochTransferDescriptor.StartingFrame = frame;
        endpoint->NextUnusedFrame = frame + bufferDescriptor->FrameCount;
    }
    //
    //   Mark that we used a TD
    //
    endpoint->AttachedBuffers++;
    //
    //   Move the tail pointer, if we can, if we cannot, the completion routine
    //   will get it.
    if(endpoint->AttachedBuffers == endpoint->MaxAttachedBuffers)
    {
        ASSERT(0 == transferDescriptor->IsochTransferDescriptor.NextTD);
    } else
    {
        ASSERT(transferDescriptor->IsochTransferDescriptor.NextTD);
        endpoint->HcEndpointDescriptor.TailP = transferDescriptor->IsochTransferDescriptor.NextTD;        
    }
    
   
ExitIsochAttachBuffers:
    //
    //  Done, we can lower the IRQL again.
    //
    KeLowerIrql(oldIrql);
    Urb->Header.Status = status;
    USBD_CompleteRequest(Urb);
    return status;
}

USBD_STATUS
FASTCALL
OHCD_fIsochStartTransfer(
    IN POHCD_DEVICE_EXTENSION   DeviceExtension,
    IN PURB                     Urb
    )
/*++
    Routine Description:
        This routine is the handler for URB_ISOCH_START_TRANSFER
        1) check parameters
        2) Make sure transfer's are stopped.
        3) Fix up starting frame information.
        4) Clear the skip bit.
        5) Set the transfering flag.
    Parameters:
        DeviceExtension - host controller context
        Urb             - urb to handle
    Return Value:
        USBD_STATUS_SUCCESS                     success
        USBD_STATUS_ISOCH_ALREADY_STARTED       the transfers have already been started.
        USBD_STATUS_ISOCH_ATTACH_MORE_BUFFERS   circular DMA and fewer the MaxAttached Buffers are attached.
        USBD_STATUS_BAD_START_FRAME             Start frame is in the past or too far in the future.
--*/
{
    ULONG startingFrame, currentFrame;
    UCHAR startingTD, tdIndex;
    USBD_STATUS status = STATUS_SUCCESS;
    KIRQL oldIrql;
    POHCD_ISOCH_ENDPOINT endpoint = (POHCD_ISOCH_ENDPOINT)Urb->IsochStartTransfer.EndpointHandle;
    
    ASSERT(USB_ENDPOINT_TYPE_ISOCHRONOUS == endpoint->EndpointType);
    
    //
    //  Raise IRQL for synchronization purposes.  Also it would
    //  could cause some frame problems if we were interrupted for
    //  an extended period of time.
    //
    oldIrql = KeRaiseIrqlToDpcLevel();
    //
    //  Make sure that the endpoint is not running already.
    //
    if(endpoint->Flags&OHCD_ISOCH_EDFL_TRANSFERING) 
    {
        status = USBD_STATUS_ISOCH_ALREADY_STARTED;
        goto ExitIsochStartTransfer;
    }
    //
    //  If the endpoint has been stopped, make sure it is late enough to restart.
    //
    currentFrame = OHCD_Get32BitFrameNumber(DeviceExtension); //We need the current frame now.
    if(endpoint->Flags & OHCD_ISOCH_EDFL_STOPPING)
    {
        endpoint->Flags &= ~OHCD_ISOCH_EDFL_STOPPING;
        //
        //  If the pause frame is the current frame, than wait a millsecond to
        //  make sure that the stop completed.
        //
        if(endpoint->PauseFrame == currentFrame)
        {
           LARGE_INTEGER Wait;
           KeLowerIrql(oldIrql);  //Can't wait at high Irql
           Wait.QuadPart = -10000;
           KeDelayExecutionThread(KernelMode, FALSE, &Wait);
           oldIrql = KeRaiseIrqlToDpcLevel();
        }
        //The frame has changed by now
        currentFrame = OHCD_Get32BitFrameNumber(DeviceExtension);
    }

    //
    //  If circular DMA, make sure that all of the buffers are attached.
    //
    if(
        (endpoint->Flags&OHCD_ISOCH_EDFL_CIRCULAR_DMA) && 
        (endpoint->MaxAttachedBuffers != endpoint->AttachedBuffers)
    )
    {
        status = USBD_STATUS_ISOCH_ATTACH_MORE_BUFFERS;
        goto ExitIsochStartTransfer;
    }
    //
    //  Check that the starting frame is valid.
    //
    startingFrame = currentFrame+1;
    if(!(Urb->IsochStartTransfer.Flags&URB_FLAG_ISOCH_START_ASAP))
    {
        //
        //  Signed subtraction account for wrap around
        //
        LONG FrameDiff = (LONG)Urb->IsochStartTransfer.FrameNumber - (LONG)startingFrame;
        if( FrameDiff < 0 || FrameDiff > USBD_ISOCH_START_FRAME_RANGE)
        {
            status = USBD_STATUS_BAD_START_FRAME;
            goto ExitIsochStartTransfer;
        } else
        {
            startingFrame = Urb->IsochStartTransfer.FrameNumber;            
        }
    }
    //
    //  Propogate the frame information into all the TDs
    //
    //
    startingTD = (endpoint->MaxAttachedBuffers - endpoint->AttachedBuffers) + endpoint->NextFreeTD;
    startingTD = startingTD%endpoint-